<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>保护您的PostgreSQL数据库 Securing Your PostgreSQL Database</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Securing Your PostgreSQL Database<br/>保护您的PostgreSQL数据库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-03 04:08:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/21137f6a309a78dd12682fe7473eb64c.png"><img src="http://img2.diglog.com/img/2021/4/21137f6a309a78dd12682fe7473eb64c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Databases are the Holy Grail for hackers, and as such, must be protectedwith utmost care. This is the first in a series of articles in which we’ll givean overview of best practices for securing your databases. We’re starting withone of the most popular open-source databases, PostgreSQL, and will go overseveral levels of security you’d need to think about:</p><p>数据库是黑客的圣杯，因此，必须遵守最大的小心。这是一系列文章中的第一个，其中我们将介绍保障您的数据库的最佳实践概述。我们开始符合最受欢迎的开源数据库，PostgreSQL，并将过度达到您需要思考的安全水平：</p><p>    In the ideal world, your PostgreSQL server would be completely isolated and notallow any inbound connections, SSH or psql. Unfortunately, this sort ofair-gapped setup is not something PostgreSQL supports out-of-the-box.</p><p>    在理想的世界中，您的PostgreSQL服务器将完全孤立，并不允许任何入站连接，SSH或PSQL。遗憾的是，这种类型的空中安装程序不是PostgreSQL的东西支持的东西。</p><p> The next best thing you can do to improve the security of your database serveris to lock down the port-level access to the node where the database is runningwith a firewall. By default, PostgreSQL listens on a TCP port 5432. Depending onthe operating system, there may be different ways to block other ports. But usingLinux’s most widely available  iptables firewall utility, the following will dothe trick:</p><p> 您可以做的下一个最佳方法可以改善数据库Server的安全性，以锁定对数据库正在运行的节点的端口级访问。默认情况下，PostgreSQL在TCP端口5432上侦听。根据操作系统，可能会有不同的方法来阻止其他端口。但是使用inlux最广泛使用的防火墙实用程序，以下将成为技巧：</p><p> # Make sure not to drop established connections.iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # Allow SSH.iptables -A INPUT -p tcp -m state --state NEW --dport  22 -j ACCEPT # Allow PostgreSQL.iptables -A INPUT -p tcp -m state --state NEW --dport  5432 -j ACCEPT # Allow all outbound, drop everything else inbound.iptables -A OUTPUT -j ACCEPTiptables -A INPUT -j DROPiptables -A FORWARD -j DROP</p><p> ＃确保不要删除已建立的连接。-A输入-M状态--State已建立，相关--j接受＃允许ssh.ptables -a输入-p tcp-m状态 -  state new --dport 22 -j接受＃允许postgreesql.partabes-a输入-p tcp-m状态--state new --dport 5432 -j接受＃允许所有出站，删除其他inbound.past -a-a output -j acceptiptables -a输入-j dropiptables -a转发-J降</p><p> Note: When updating the iptables rules, it is a good idea to use the iptables-applytool which automatically rolls back the changes in case you lock yourself out.</p><p> 注意：更新iptables规则时，使用iptables-applytool是一个好主意，它会自动滚动更改，以防您锁定自己。</p><p> The PostgreSQL rule above will allow anyone to connect to port 5432. You couldmake it more strict by only accepting connections from certain IP addresses orsubnets:</p><p> 上面的PostgreSQL规则将允许任何人连接到端口5432.只需接受来自某些IP地址或SUBNETS的连接即可更严格：</p><p> # Only allow access to PostgreSQL port from the local subnet.iptables -A INPUT -p tcp -m state --state NEW --dport  5432 -s 192.168.1.0/24 -j ACCEPT</p><p> ＃只允许访问本地子网的PostgreSQL端口。-a输入-p tcp-m状态 -  state new --dport 5432-s 192.168.1.0/24 -J接受 </p><p> Going back to our ideal scenario, being able to entirely prevent inboundconnections to port 5432 would require a some sort of a local agent thatmaintains a persistent outbound connection to the client node(-s) and has theability to proxy traffic to the local PostgreSQL instance.</p><p>回到我们理想的方案，能够完全防止端口5432的inboundConnection将需要某种本地代理，该代理将持久的出站连接与客户端节点（-s）进行持久的出站连接，并且可以举办到本地PostgreSQL实例的代理流量。</p><p> This technique is called “reverse tunneling” and can be demonstrated using SSHremote port forwarding feature. You can open up a reverse tunnel by running thefollowing command from the node where your PostgreSQL database is running:</p><p> 此技术称为“反向隧道”，可以使用SShremote端口转发功能进行演示。您可以通过从PostgreSQL数据库运行的节点运行文件来打开反向隧道：</p><p>  Of course, the  &lt;client-host&gt; should be accessible from the PostgreSQL node andhave the SSH daemon running. The command will forward the port 5432 on thedatabase server to the port 5432 on the client machine, and you will be able toconnect to the database over the tunnel:</p><p>  当然，＆lt; client-host＆gt;应该从PostgreSQL节点访问，并运行SSH守护程序。该命令将在客户端计算机上的端口5432上将端口5432转发到端口5432，并且您将能够通过隧道将数据库连接到数据库：</p><p>   It is a good practice to restrict addresses on which the server is listening forclient connections using the  listen_addresses configuration file directive. Ifthe node PostgreSQL is running on has multiple network interfaces, use it tomake sure the server is only listening on the interface(-s) over which theclients will be connecting to it:</p><p>   一个很好的做法，可以使用listens_addresses配置文件指令限制服务器正在侦听前链接连接的地址。如果节点PostgreSQL运行有多个网络接口，请使用它捣碎，确保服务器仅在侦听该界面（-S）上，以其将连接到它：</p><p>  If the clients connecting to the database always reside on the same node (or,say, co-located in the same Kubernetes pod with PostgreSQL running as a side-carcontainer), disabling TCP socket listening can completely eliminate network fromthe picture. Setting listen addresses to an empty string makes the server acceptonly Unix-domain socket connections:</p><p>  如果连接到数据库的客户端始终驻留在同一节点上（或者说，请与作为侧面配置文件运行的PostgreSQL一起使用的Poctgr​​eSQL），则禁用TCP套接字侦听可以完全消除来自图片的网络。将收听地址设置为空字符串使服务器接受acceptonly unix-domain套接字连接：</p><p>   With the majority of the world’s web moving to HTTPs, there’s little excuse fornot using a strong transport encryption for database connections as well.PostgreSQL supports TLS (which is still referred to as SSL in the documentation,configuration and CLI for legacy reasons) natively and provides ways to use itfor both server and client authentication.</p><p>   随着世界上大部分网络迁移到HTTPS，还有很少的借口，使用强大的传输加密，对于数据库连接而不是，因此PostgresQL支持TLS（仍称为文档，配置和CLI的SSL）本地性和提供了使用它的方法，包括服务器和客户端身份验证。</p><p>  For server authentication, you first need to obtain a certificate the serverwill present to the connecting clients. Let’s Encrypt makes it really easy toget free X.509 certificates, for example using the  certbotCLI tool:</p><p>  对于服务器身份验证，您首先需要获取提供给连接客户端的ServerWill的证书。让我们加密使得它真的很容易忘记免费X.509证书，例如使用CESTBOTCLI工具： </p><p>  Keep in mind that by default certbot uses  HTTP-01ACME challenge to validate the certificate request which requires a valid DNSfor the requested domain pointing to the node and port 80 to be open.</p><p>请记住，默认情况下，默认情况下使用HTTP-01ACME挑战来验证证书请求，该挑战需要指向要打开的节点和端口80的所请求域的有效DNS的证书请求。</p><p> If you can’t use Let’s Encrypt for some reason and want to generate all secretslocally, you can do it using openssl CLI tool:</p><p> 如果您无法使用允许员加密某种原因并希望生成所有秘密接种，则可以使用OpenSSL CLI工具来执行以下操作：</p><p> # Make a self-signed server CA.openssl req -sha256 -new -x509 -days  365 -nodes  \  -out server-ca.crt  \  -keyout server-ca.key # Generate server CSR. Put the hostname you will be using to connect to # the database in the CN field.openssl req -sha256 -new -nodes  \  -subj  &#34;/CN=postgres.example.com&#34;  \  -out server.csr  \  -keyout server.key # Sign a server certificate.openssl x509 -req -sha256 -days  365  \  -in server.csr  \  -CA server-ca.crt  \  -CAkey server-ca.key  \  -CAcreateserial  \  -out server.crt</p><p> ＃制作自签名服务器ca.openssl req -sha256 -new-x509 -days 365-nodes \ -out server-ca.crt \ -keyout server-ca.key＃生成服务器csr。将主机名置于CN Fields.Openssl req -sha256中的#todation to to to＃the divels。 \ -out server.csr \ -keyout server.key＃sign一个服务器证书。apenssl x509 -req -sha256 -days 365 \ -in server.csr \ -ca server-ca.crt \ -cakey server-ca.key \ -cacreateserial \ -out server.crt</p><p> Of course, in the production environment you’d want to make sure that thesecertificates are updated prior to their expiration date.</p><p> 当然，在生产环境中，您要确保在到期日之前更新复杂化物。</p><p>  Client certificate authentication allows the server to verify the identity of aconnecting client by validating that the X.509 certificate presented by theclient is signed by a trusted certificate authority.</p><p>  客户端证书身份验证允许服务器通过验证TheClient呈现的X.509证书来验证AConnecting客户端的标识。由可信证书颁发机构签名。</p><p> It’s a good idea to use different certificate authorities to issue client andserver certificates, so let’s create a client CA and use it to sign a clientcertificate:</p><p> 使用不同的证书机构来发出Client Andserver证书是一个很好的想法，因此让我们创建一个客户端CA并使用它来签署ClientCertificate：</p><p> # Make a self-signed client CA.openssl req -sha256 -new -x509 -days  365 -nodes  \  -out client-ca.crt  \  -keyout client-ca.key # Generate client CSR. CN must contain the name of the database role you # will be using to connect to the database.openssl req -sha256 -new -nodes  \  -subj  &#34;/CN=alice&#34;  \  -out client.csr  \  -keyout server.key # Sign a client certificate.openssl x509 -req -sha256 -days  365  \  -in client.csr  \  -CA client-ca.crt  \  -CAkey client-ca.key  \  -CAcreateserial  \  -out client.crt</p><p> ＃制作一个自签名的客户端ca.openssl req -sha256 -new-x509 -days 365-nodes \ -out client-ca.crt \ -keyout client-ca.key＃生成客户端csr。 CN必须包含您＃的数据库角色的名称，您将使用它来连接到Database.openssl req -sha256 -new -nodes \ -subj＆＃34; / cn = Alice＆＃34; \ -out client.csr \ -keyout server.key＃签名客户端证书.Openssl x509 -req -sha256 -days 365 \ -in client.csr \ -ca client-ca.crt \ -cakey client-ca.key \ -cacreateserial \ -out client.crt </p><p> Note that the CommonName (CN) field of the client certificate must contain thename of the database account the client is connecting to. PostgreSQL server willuse it to establish the identity of the client.</p><p>请注意，客户端证书的公共名称（CN）字段必须包含客户端连接到的数据库帐户的名称。 postgreSQL服务器威尔斯建立客户的身份。</p><p>  Getting all the pieces together, you can now configure the PostgreSQL server toaccept TLS connections:</p><p>  将所有的作品放在一起，您现在可以配置PostgreSQL Server TOACcept TLS连接：</p><p> ssl  = onssl_cert_file  =  &#39;/path/to/server.crt&#39;ssl_key_file  =  &#39;/path/to/server.key&#39;ssl_ca_file  =  &#39;/path/to/client-ca.crt&#39; # This setting is on by default but it’s always a good idea to # be explicit when it comes to security.ssl_prefer_server_ciphers  = on # TLS 1.3 will give the strongest security and is advised when # controlling both server and clients.ssl_min_protocol_version  =  &#39;TLSv1.3&#39;</p><p> ssl = onssl_cert_file =＆＃39; /path/to/server.crt&#39; ssl_key_file =＆＃39; /path/to/server.key&#39; ssl_ca_file =＆＃39; / path / to / client-ca .crt＆＃39; ＃此设置默认情况下，但是当涉及到Security.ssl_prefer_server_ciphers =上，＃tls 1.3将提供最强大的安全性，并在＃控制服务器和客户端时建议＃3.ssl_min_protocol_version =＆＃39 ; tlsv1.3＆＃39;</p><p> One last remaining bit of configuration is to update the PostgreSQL serverhost-based authentication file ( pg_hba.conf) to require TLS for all connectionsand authenticate the clients using X.509 certificates:</p><p> 最后一个配置的配置是要更新基于PostgreSQL ServerHost的身份验证文件（PG_HBA.conf），以要求所有连接的TLS使用X.509证书对客户端进行身份验证：</p><p>  Now, clients connecting to the database server will have to present a validcertificate signed by the client certificate authority:</p><p>  现在，连接到数据库服务器的客户端必须呈现由客户端证书颁发机构签名的validCertificate：</p><p>  Note that by default psql will not perform the server certificate validation so“sslmode” must be set to  verify-full or  verify-ca, depending on whetheryou’re connecting to the PostgreSQL server using the same hostname as encoded inits X.509 certificate’s CN field.</p><p>  请注意，默认情况下，默认情况下，PSQL不会执行服务器证书验证，因此必须将“SSLMode”设置为验证 - 完全或验证-CA，具体取决于使用与编码X.509证书的相同主机名是否与PostgreSQL服务器连接到PostgreSQL服务器场地。</p><p> To reduce the command verbosity and not have to enter the paths to TLS secretsevery time you want to connect to a database, you can use a PostgreSQLconnection service file. It allows you to group connection parameters into“services” which can then be referred to in the connection string via a“service” parameter.</p><p> 要减少命令的详细程度，不必输入要连接到数据库的TLS秘密时间的路径，可以使用PostgreSQLConnection服务文件。它允许您将连接参数分组为“服务”，然后通过“服务”参数在连接字符串中引用。 </p><p>   Now, when connecting to a database, you’d only need to specify the service nameand the name of the database you want to connect to:</p><p>现在，在连接到数据库时，您只需要指定服务命名为要连接的数据库的名称：</p><p>    So far we have explored how to protect the PostgreSQL database server fromunauthorized network connections, use strong transport encryption and make surethat server and clients can trust each other’s identities with mutual TLSauthentication. Another piece of the puzzle is to figure out what users can doand what they have access to once they’ve connected to the database and hadtheir identity verified. This is usually referred to as authorization.</p><p>    到目前为止，我们已经探索了如何保护PostgreSQL数据库服务器从销售网络连接，使用强大的传输加密，并使服务器和客户端可以相互信任相互TLSAuthentication的彼此的身份。另一个拼图是弄清楚用户可以在连接到数据库和HATTHEIR身份验证的情况下访问的内容。这通常被称为授权。</p><p> PostgreSQL has a comprehensive user permissions system that is built around theconcept of roles. In modern PostgreSQL versions (8.1 and newer) a “role” issynonymous with “user” so any database account name you use, say, with psql(e.g. “user=alice”) is actually a role with a  LOGIN attribute that lets itconnect to a database. In fact, the following SQL commands are equivalent:</p><p> PostgreSQL具有全面的用户权限系统，该系统围绕Colescolscolce构建。在现代PostgreSQL版本（8.1和较新）中“角色”与“用户”签名，因此使用PSQL（例如“User = Alice”）的任何数据库帐户名称，实际上是具有Login属性的角色，允许ITConnect数据库。实际上，以下SQL命令等同于：</p><p>  Besides the ability to log in, roles can have other attributes that allow themto bypass all permission checks ( SUPERUSER), create databases ( CREATEDB),create other roles ( CREATEROLE), and others.</p><p>  除了登录的能力之外，角色可以具有其他属性，允许它们绕过所有权限检查（超级用户），创建数据库（创建的），创建其他角色（CreereeLe）等。</p><p> In addition to attributes, roles can be granted permissions which can be splitin two categories: membership in other roles and database object privileges.Let’s take a look at how these work in action.</p><p> 除了属性之外，角色可以被授予可以分离的权限两类：其他角色和数据库对象权限的成员身份.Llet看看这些工作如何行动。</p><p>   CREATE  TABLE server_inventory ( id int  PRIMARY  KEY, description text, ip_address text, environment text,  owner text,);</p><p>   创建表server_inventory（ID INT主键，描述文本，IP_Address文本，环境文本，所有者文本，）;</p><p> By default, PostgreSQL installation includes a superuser role (usually called“postgres”) used to bootstrap the database. Using this role for all databaseoperations would be equivalent to always using “root” login on Linux, which isnever a good idea. Instead, let’s create an unprivileged role and assignpermissions to it as needed following the principle of least privilege.</p><p> 默认情况下，PostgreSQL安装包括用于引导数据库的超级用户角色（通常称为“postgres”）。对所有数据库过程使用此角色相当于始终使用Linux上的“root”登录，这不是一个好主意。相反，让我们在最不特权原则之后根据需要创建一个不特权的角色和分配。 </p><p> Rather than assigning privileges to each new user/role individually, you cancreate a “group role” and grant other roles (mapping onto individual users)membership in this group. Say, you want to allow your developers, Alice and Bob,to view the server inventory but not modify it:</p><p>您可以单独为每个新用户/角色分配权限，而不是为每个新用户/角色分配权限，而是Cancreate将“组角色”并授予此组中的其他角色（映射到各个用户）。说，您希望允许您的开发人员，Alice和Bob，查看服务器库存，但不会修改它：</p><p> -- Create a group role that doesn&#39;t have ability to login by itself and -- grant it SELECT privileged on the server inventory table.  CREATE  ROLE developer; GRANT  SELECT  ON server_inventory  TO developer; -- Create two user accounts which will inherit &#34;developer&#34; permissions upon -- logging into the database.  CREATE  ROLE alice LOGIN INHERIT; CREATE  ROLE bob LOGIN INHERIT; -- Assign both user account to the &#34;developer&#34; group role.  GRANT developer  TO alice, bob;</p><p>  - 创建一个＆＃39; t的组角色，它具有自己登录的能力 - 授予它在服务器清单表上选择权限。创建角色开发人员;在server_inventory上授予选择到开发人员; - 创建两个将继承的用户帐户＆＃34;开发人员＆＃34;权限次登录到数据库。创建角色Alice Login继承;创建角色Bob登录继承; - 将用户帐户分配给＆＃34;开发人员＆＃34;团体角色。授予爱丽丝的开发人员，鲍勃;</p><p> Now, when connected to the database, both Alice and Bob will inherit privilegesof the “developer” group role and be able to run queries on the server inventory.</p><p> 现在，当连接到数据库时，Alice和Bob都将继承“开发人员”组角色的权限，并能够在服务器库存上运行查询。</p><p> The  SELECT privilege applies to all table columns by default, though it doesn’thave to. Say, you only wanted to allow your interns to view the general serverinventory information without letting them connect by hiding the IP address:</p><p> 默认情况下，SELECT权限适用于所有表列，但它并没有。说，您只想允许您的实习生查看一般的ServerInventory信息而不让他们通过隐藏IP地址来连接：</p><p> CREATE  ROLE intern; GRANT  SELECT(id, description)  ON server_inventory  TO intern; CREATE  ROLE charlie LOGIN INHERIT; GRANT intern  TO charlie;</p><p> 创建角色实习生;授予server_inventory的select（id，description）到实习生;创建角色查理登录继承;授予查理实习生;</p><p> Other most commonly used database object privileges are  INSERT,  UPDATE, DELETE and  TRUNCATE that correspond to the respective SQL statements, butyou can also assign privileges for connecting to specific databases, creatingnew schemas or objects within the schema, executing functions and so on. Take alook at the  Privilegessection of PostgreSQL documentation to see the whole list.</p><p> 其他最常用的数据库对象权限是插入，更新，删除和截断对应于相应的SQL语句，但也可以分配用于连接到特定数据库，在模式中创建新的数据库，创建函数等的特定数据库的权限，执行函数等。在PostgreSQL文档的特权上拍摄Alook以查看整个列表。</p><p>  One of the more advanced features of PostgreSQL privilege system is row-levelsecurity, which allows you to grant privileges to a subset of rows in a table.This includes both rows that can be queried with the  SELECT statement, as wellas rows that can be  INSERTed,  UPDATEd and  DELETEd.</p><p>  postgreSQL权限系统的更高级功能之一是行 - 水彩安全，允许您授予表中的行的子集。这包括可以用SELECT语句查询的两行，因为可以插入的WELLAS行，更新和删除。 </p><p> To start using row-level security, you need two things: enable it for a table anddefine a policy that will control row-level access.</p><p>要开始使用行级安全性，您需要两件事：使其能够为表anddefine控制行级访问的策略。</p><p> Building on our previous example, let’s say that you want to allow users toupdate only their own servers. First, enable RLS on the table:</p><p> 在我们上一个示例的建筑物上，假设您希望允许用户只授予自己的服务器。首先，在表上启用RLS：</p><p>  Without any policy defined, PostgreSQL defaults to the “deny” policy which meansno role (other than the table owner which is typically the role that created thetable) has any access to it.</p><p>  没有定义的任何策略，PostgreSQL默认为均扮演角色（表所有者除了创建的角色）的角色（表所有者）有任何访问权限。</p><p> A row security policy is a Boolean expression that PostgreSQL will evaluate foreach row that is supposed to be returned or updated. The rows returned by SELECT statements are checked against the expression specified with the USING clause, while the rows updated by  INSERT,  UPDATE or  DELETEstatements are checked against the  WITH CHECK expression.</p><p> 行安全策略是PostgreSQL的布尔表达式将评估应该退回或更新的Foreach行。选择语句返回的行按使用子句指定的表达式检查，而通过插入，更新或deleteStatememed更新的行将针对带检查表达式检查。</p><p> Let’s define a couple of policies that allow users to see all servers but onlyupdate their own, as determined by the “owner” field of the table:</p><p> 让我们定义几个策略，允许用户查看所有服务器，而是仅由表的“所有者”字段所确定的：</p><p> CREATE POLICY select_all_servers  ON server_inventory  FOR  SELECT  USING ( true); CREATE POLICY update_own_servers  ON server_inventory  FOR  UPDATE  USING ( current_user  =  owner)  WITH  CHECK ( current_user  =  owner);</p><p> 在server_inventory上创建策略select_all_servers以供选择（true）;在server_inventory上创建策略update_own_servers for使用check（current_user =所有者）使用（current_user =所有者）更新;</p><p> Note that only the owner of the table can create or update row security policiesfor it.</p><p> 请注意，只有表的所有者只能为其创建或更新行安全策略。 </p><p>  So far we have mostly talked about preemptive security measures. Following oneof the cornerstone security principles, defense in depth, we have explored howthey layer on top of each other to help slow down a hypothetical attacker’sprogression through the system.</p><p>到目前为止，我们大多符合先发制人的安全措施。在基石安全原则之后，防守深入，我们已经互相探讨了Howthey层，以帮助减慢假设的攻击者通过系统进行前进。</p><p> Keeping an accurate and detailed audit trail is one of the security properties ofthe system that is often overlooked. Monitoring the network-level or node-levelaccess for your database server is out of scope of this post, but let’s take alook at what options we have when it comes to PostgreSQL server itself.</p><p> 保持准确且详细的审计跟踪是经常被忽视的系统的安全属性之一。监视数据库服务器的网络级别或节点级别是此帖子的范围，但是让我们在PostgreSQL Server本身时获取我们有哪些选项。</p><p> The most basic thing you can do to enhance visibility into what’s happeningwithin the database is to enable verbose logging. Add the following directivesto the server configuration file to turn on logging of all connection attemptsand all executed SQL statements:</p><p> 您可以做的最基本的事情，以提高对MobileWithIn在数据库中的内容的可见性，以便启用详细日志记录。添加以下DirectIvesto服务器配置文件以打开所有连接尝试的日志记录，所有已执行的SQL语句：</p><p> ; Log successful and unsuccessful connection attempts. log_connections  =  on ; Log terminated sessions. log_disconnections  =  on ; Log all executed SQL statements. log_statement  =  all</p><p> ;日志成功和不成功的连接尝试。 log_connections =上;日志终止会话。 log_disconnections =上;记录所有执行的SQL语句。 log_statement =全部</p><p> Unfortunately, this is pretty much the extent of what you can do with the standardself-hosted PostgreSQL installation out-of-the-box. It is better than nothing, ofcourse, but it doesn’t scale well beyond a handful of database servers and simple“grepping”.</p><p> 不幸的是，这几乎是您可以在箱子外安装的标准托管的PostgreSQL安装程度。这比无所事事更好，但它不会超越少数数据库服务器和简单的“Grepping”。</p><p> For a more advanced PostgreSQL auditing solution, you can use a 3rd partyextension such as  pgAudit. You will haveto install the extension manually if you’re using a self-hosted PostgreSQLinstance. Some hosted versions such as AWS RDS support it out-of-the-box, so youjust need to enable it.</p><p> 对于更高级的PostgreSQL审核解决方案，您可以使用诸如PGAudit的第3个PartyExtension。如果您正在使用自托管的Postgresqlinstance，则您将手动安装分机。一些托管版本，例如AWS RDS支持它的框中，因此您需要启用它。</p><p> pgAudit brings more structure and granularity to the logged statements. However,keep in mind that it is still logs-based, which makes it challenging to use ifyou want to ship your audit logs in structured format to an external SIEM systemfor detailed analysis.</p><p> PGaudit为记录的陈述带来了更多的结构和粒度。但是，请记住，它仍然是基于日志的，这使得使用IFYOU将以结构化格式将您的审计日志运送到外部SIEM System，这使得其挑战是有挑战性的。 </p><p>  Teleport for Database Accessis the open source project we built with the goal of helping you implement thebest practices for securing your PostgreSQL (and other) databases that wediscussed in this post.</p><p>传送数据库访问中的开源项目，我们建立了帮助，以帮助您实现在此帖子中呈现的PostgreSQL（和其他）数据库的最值实践。</p><p> Users can access the databases through the single sign-on flow and useshort-lived X.509 certificates for authentication instead of regularcredentials.</p><p> 用户可以通过单点登录流程和useShort Live X.509证书访问数据库，而不是RengalCredentials。</p><p> Databases do not need to be exposed on the public Internet and can safelyoperate in air-gapped environments using Teleport’s built-in reverse tunnelsubsystem.</p><p> 数据库不需要在公共互联网上暴露，并且可以使用Teleport的内置反向隧道系统安全地在空调环境中进行安全。</p><p> Administrators and auditors can see the database activity such as sessionsand SQL statements tied to a particular user’s identity in the audit log,and optionally ship it to an external system.</p><p> 管理员和审核员可以看到数据库活动，例如与特定用户在审核日志中的特定用户身份相关联的Sessionsand SQL语句，并可选择将其运送到外部系统。</p><p> If you’re interested, you can get started with Teleport Database Access bywatching the  demo,reading the  docs,downloading the  open-source version,and exploring the code on  Github.</p><p> 如果您有兴趣，您可以开始使用Teleport Database Access and，浏览演示，读取文档，下载开源版本，并在Github上探索代码。</p><p>  As with any system designed with security in mind, properly guarding access toyour database instance requires taking protective measures on multiple levels ofthe stack.</p><p>  与任何具有安全性的系统一样，正确保护的访问Toyour数据库实例需要对堆栈的多个级别采取保护措施。</p><p> In this article we’ve taken a look at the best practices in protecting yourPostgreSQL database access on multiple levels, starting with the network andtransport security, and explored how to use PostgreSQL flexible user privilegesystem.</p><p> 在本文中，我们已经了解了在多个级别保护您的yourpostgresql数据库访问的最佳实践，从网络和触发安全性开始，并探索了如何使用PostgreSQL灵活的用户权限。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://goteleport.com/blog/securing-postgres-postgresql/">https://goteleport.com/blog/securing-postgres-postgresql/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>