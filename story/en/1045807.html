<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rqlite：基于SQLite的轻量级分布式关系数据库 Rqlite: The lightweight, distributed relational database built on SQLite</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rqlite: The lightweight, distributed relational database built on SQLite<br/>Rqlite：基于SQLite的轻量级分布式关系数据库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-22 23:21:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/f14f749b704163853612f5a235e479e7.png"><img src="http://img2.diglog.com/img/2021/1/f14f749b704163853612f5a235e479e7.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>rqlite is a lightweight, distributed relational database, which uses  SQLite as its storage engine. Forming a cluster is very straightforward, it gracefully handles leader elections, and tolerates failures of machines, including the leader. rqlite is available for Linux, OSX, and Microsoft Windows.</p><p>rqlite是一个轻量级的分布式关系数据库，它使用SQLite作为其存储引擎。形成集群非常简单，可以很好地处理领导者选举，并容忍包括领导者在内的机器故障。 rqlite可用于Linux，OSX和Microsoft Windows。</p><p>   rqlite gives you the functionality of a  rock solid, fault-tolerant, replicated relational database, but with very  easy installation, deployment, and operation. With it you&#39;ve got a  lightweight and  reliable distributed relational data store. Think  etcd or  Consul, but with relational data modelling also available.</p><p>   rqlite为您提供坚如磐石的，容错的，复制的关系数据库的功能，但安装，部署和操作非常简单。有了它，您将获得轻量级且可靠的分布式关系数据存储。可以考虑使用etcd或Consul，但也可以使用关系数据建模。</p><p> You could use rqlite as part of a larger system, as a central store for some critical relational data, without having to run larger, more complex distributed databases.</p><p> 您可以将rqlite用作大型系统的一部分，作为一些关键关系数据的中央存储，而不必运行更大，更复杂的分布式数据库。</p><p> Finally, if you&#39;re interested in understanding how distributed systems actually work,  rqlite is a good example to study. Much thought has gone into its  design and implementation, with clear separation between the various components, including storage, distributed consensus, and API.</p><p> 最后，如果您有兴趣了解分布式系统的实际工作方式，那么rqlite是一个很好的研究示例。在其设计和实现中已经进行了很多思考，各个组件之间的清晰分离，包括存储，分布式共识和API。</p><p>  rqlite uses  Raft to achieve consensus across all the instances of the SQLite databases, ensuring that every change made to the system is made to a quorum of SQLite databases, or none at all. You can learn more about the design  here.</p><p>  rqlite使用Raft在SQLite数据库的所有实例之间达成共识，从而确保对系统所做的每个更改都是针对一定数量的SQLite数据库进行的，或者根本不进行。您可以在此处了解有关该设计的更多信息。</p><p>  An easy-to-use  HTTP(S) API, including leader-redirection and bulk-update support. A  command-line interface is also available, as are various  client libraries.</p><p>  易于使用的HTTP（S）API，包括领导者重定向和批量更新支持。命令行界面以及各种客户端库也都可用。</p><p>  Detailed documentation  is available. You may also wish to check out the  rqlite Google Group.</p><p>  详细文档可用。您可能还希望查看rqlite Google网上论坛。 </p><p> The quickest way to get running on OSX and Linux is to download a pre-built release binary. You can find these binaries on the  Github releases page. If you prefer Windows you can download the latest build  here. Once installed, you can start a single rqlite node like so:</p><p>在OSX和Linux上运行的最快方法是下载预构建的发行版二进制文件。您可以在Github版本页面上找到这些二进制文件。如果您喜欢Windows，可以在此处下载最新版本。安装后，您可以像这样启动一个rqlite节点：</p><p>  Setting  -node-id isn&#39;t strictly necessary at this time, but highly recommended. It makes cluster management much clearer.</p><p>  目前绝对不需要设置-node-id，但强烈建议您设置。它使群集管理更加清晰。</p><p> This single node automatically becomes the leader. You can pass  -h to  rqlited to list all configuration options.</p><p> 该单个节点自动成为领导者。您可以将-h传递给rqlited以列出所有配置选项。</p><p>    While not strictly necessary to run rqlite, running multiple nodes means you&#39;ll have a fault-tolerant cluster. Start two more nodes, allowing the cluster to tolerate failure of a single node, like so:</p><p>    虽然并非严格要求运行rqlite，但运行多个节点意味着您将拥有容错群集。再启动两个节点，使群集可以容忍单个节点的故障，如下所示：</p><p> rqlited -node-id 2 -http-addr localhost:4003 -raft-addr localhost:4004 -join http://localhost:4001  ~/node.2rqlited -node-id 3 -http-addr localhost:4005 -raft-addr localhost:4006 -join http://localhost:4001  ~/node.3</p><p> rqlited -node-id 2 -http-addr localhost：4003 -raft-addr localhost：4004 -join http：// localhost：4001〜/ node.2rqlited -node-id 3 -http-addr localhost：4005 -raft-addr本地主机：4006-加入http：//本地主机：4001〜/ node.3</p><p> This demonstration shows all 3 nodes running on the same host. In reality you probably wouldn&#39;t do this, and then you wouldn&#39;t need to select different -http-addr and -raft-addr ports for each rqlite node.</p><p> 此演示显示了在同一主机上运行的所有3个节点。实际上，您可能不需要这样做，然后就不必为每个rqlite节点选择不同的-http-addr和-raft-addr端口。</p><p> With just these few steps you&#39;ve now got a fault-tolerant, distributed relational database. For full details on creating and managing real clusters, including running read-only nodes, check out  this documentation.</p><p> 只需完成这几个步骤，您就可以得到一个容错的分布式关系数据库。有关创建和管理实际集群（包括运行只读节点）的完整详细信息，请查阅此文档。 </p><p>  There is also a rqlite  Discovery Service, allowing nodes to automatically connect and form a cluster. This can be much more convenient, allowing clusters to be dynamically created. Check out  the documentation for more details.</p><p>还有一个rqlite发现服务，允许节点自动连接并形成集群。这样可以更加方便，从而可以动态创建集群。查看文档以获取更多详细信息。</p><p>  Let&#39;s insert some records via the  rqlite CLI, using standard SQLite commands. Once inserted, these records will be replicated across the cluster, in a durable and fault-tolerant manner. Your 3-node cluster can suffer the failure of a single node without any loss of functionality or data.</p><p>  让我们使用标准SQLite命令通过rqlite CLI插入一些记录。插入后，这些记录将以持久且容错的方式在整个群集中复制。您的3节点群集可以遭受单个节点的故障，而不会损失任何功能或数据。</p><p> $ rqlite127.0.0.1:4001&gt; CREATE TABLE foo (id INTEGER NOT NULL PRIMARY KEY, name TEXT)0 row affected (0.000668 sec)127.0.0.1:4001&gt; .schema+-----------------------------------------------------------------------------+| sql |+-----------------------------------------------------------------------------+| CREATE TABLE foo (id INTEGER NOT NULL PRIMARY KEY, name TEXT) |+-----------------------------------------------------------------------------+127.0.0.1:4001&gt; INSERT INTO foo(name) VALUES(&#34;fiona&#34;)1 row affected (0.000080 sec)127.0.0.1:4001&gt; SELECT * FROM foo+----+-------+| id | name |+----+-------+| 1 | fiona |+----+-------+</p><p> $ rqlite127.0.0.1：4001＆gt; CREATE TABLE foo（id INTEGER NOT NULL PRIMARY KEY，name TEXT）受影响的0行（0.000668秒）127.0.0.1:4001&gt; .schema + ------------------------------------------------ ----------------------------- + | sql | + ----------------------------------------------- ------------------------------ + | CREATE TABLE foo（id INTEGER NOT NULL PRIMARY KEY，name TEXT）| + ---------------------------------- ------------------------------------------- + 127.0.0.1:4001&gt;将INSERT INTO foo（name）VALUES（＆＃34; fiona＆＃34;）1受影响的行（0.000080秒）127.0.0.1:4001&gt;选择* FROM foo + ---- + ------- + | id |名称| + ---- + ------- + | 1 |菲奥娜| + ---- + ------- +</p><p>  rqlite has a rich HTTP API, allowing full control over writing to, and querying from, rqlite. Check out  the documentation for full details. There are also  client libraries available.</p><p>  rqlite具有丰富的HTTP API，可以完全控制对rqlite的写入和查询。查看文档以获取完整详细信息。也有可用的客户端库。</p><p>  rqlite replicates SQLite for fault-tolerance. It does not replicate it for performance. In fact performance is reduced somewhat due to the network round-trips.</p><p>  rqlite复制SQLite以实现容错。它不会复制它以提高性能。实际上，由于网络往返，性能有所降低。</p><p> Depending on your machine (particularly its IO performance) and network, individual INSERT performance could be anything from 10 operations per second to more than 200 operations per second. However, by using the  bulk API, transactions, or both, throughput will increase significantly, often by 2 orders of magnitude. This speed-up is due to the way Raft and SQLite work. So for high throughput, execute as many operations as possible within a single transaction.</p><p> 取决于您的计算机（尤其是其IO性能）和网络，单个INSERT性能可能从每秒10次操作到每秒200次以上的操作。但是，通过使用批量API，事务或同时使用两者，吞吐量将显着增加，通常增加2个数量级。这种加速是由于Raft和SQLite的工作方式所致。因此，为了获得高吞吐量，请在单个事务中执行尽可能多的操作。</p><p>  By default rqlite uses an  in-memory SQLite database to maximise performance. In this mode no actual SQLite file is created and the entire database is stored in memory. If you wish rqlite to use an actual file-based SQLite database, pass  -on-disk to rqlite on start-up.</p><p>  默认情况下，rqlite使用内存中的SQLite数据库来最大化性能。在这种模式下，不会创建实际的SQLite文件，并且整个数据库都存储在内存中。如果您希望rqlite使用实际的基于文件的SQLite数据库，请在启动时将-on-disk传递给rqlite。 </p><p>   Since the Raft log is the authoritative store for all data, and it is written to disk by each node, an in-memory database can be fully recreated on start-up. Using an in-memory database does not put your data at risk.</p><p>由于Raft日志是所有数据的权威存储，并且由每个节点写入到磁盘，因此可以在启动时完全重新创建内存数据库。使用内存数据库不会使您的数据面临风险。</p><p>  Only SQL statements that are   deterministic are safe to use with rqlite, because statements are committed to the Raft log before they are sent to each node. In other words, rqlite performs  statement-based replication. For example, the following statement could result in a different SQLite database under each node:</p><p>  只有确定性的SQL语句才可以与rqlite一起使用，因为这些语句在发送到每个节点之前已提交到Raft日志。换句话说，rqlite执行基于语句的复制。例如，以下语句可能导致每个节点下都有一个不同的SQLite数据库：</p><p>  Technically this is not supported, but you can directly read the SQLite under any node at anytime, assuming you run in &#34;on-disk&#34; mode. However there is no guarantee that the SQLite file reflects all the changes that have taken place on the cluster unless you are sure the host node itself has received and applied all changes.</p><p>  从技术上讲，这不受支持，但是您可以随时在任何节点下直接读取SQLite，前提是您是在“磁盘上”运行的。模式。但是，除非您确定主机节点本身已接收并应用了所有更改，否则无法保证SQLite文件会反映群集上已发生的所有更改。</p><p> In case it isn&#39;t obvious, rqlite does not replicate any changes made directly to any underlying SQLite file, when run in &#34;on disk&#34; mode.  If you change the SQLite file directly, you will cause rqlite to fail. Only modify the database via the HTTP API.</p><p> 如果不是很明显，当在磁盘上运行时，rqlite不会直接对任何基础SQLite文件复制所做的任何更改。模式。如果直接更改SQLite文件，将导致rqlite失败。仅通过HTTP API修改数据库。</p><p> SQLite dot-commands such as  .schema or  .tables are not directly supported by the API, but the rqlite CLI supports some very similar functionality. This is because those commands are features of the  sqlite3 command, not SQLite itself.</p><p> API不直接支持SQLite点命令（例如.schema或.tables），但是rqlite CLI支持一些非常相似的功能。这是因为这些命令是sqlite3命令的功能，而不是SQLite本身的功能。</p><p>    Learn how to hot backup your rqlite cluster  here. You can also load data  directly from a SQLite dump file.</p><p>    在此处了解如何热备份rqlite群集。您也可以直接从SQLite转储文件加载数据。</p><p>      How do I pronounce rqlite? For what it&#39;s worth I try to pronounce it &#34;ree-qwell-lite&#34;. But it seems most people, including me, often pronouce it &#34;R Q lite&#34;.</p><p>      我如何发音？对于它的价值，我尝试将其发音为“ ree-qwell-lite”。但是似乎大多数人，包括我在内，常常都对它赞不绝口。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/rqlite/rqlite">https://github.com/rqlite/rqlite</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分布式/">#分布式</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>