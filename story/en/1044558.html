<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>代码预算 Code Budgets</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Code Budgets<br/>代码预算 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-16 23:10:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/36d3647f6e240a6c6f713d6acbacaaab.png"><img src="http://img2.diglog.com/img/2021/1/36d3647f6e240a6c6f713d6acbacaaab.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The naive answer is that it costs nothing. Bytes are free -- or as close to free as we can come. But it  has to cost something. After all, it took time to type in, right? So that takes us to our first rule of &#34;Code Economics&#34;: the cost of a line of code is measured in how much time we spend working with it.</p><p>天真的答案是它不花钱。字节是免费的-或尽可能接近免费。但这一定要花些钱。毕竟，输入需要花费时间，对吗？因此，这使我们进入了“代码经济学”的第一个规则：代码行的成本是根据我们花在代码上的时间来衡量的。</p><p>  The naive answer is that the economic value of a line of code is the value of the application (which can be measured various ways) divided by the total line-of-codes (LOC). If you&#39;re making $10K per month from a thousand lines of code, each line is bringing in $10.</p><p>  天真的答案是，代码行的经济价值是应用程序的价值（可以通过各种方式衡量）除以总代码行（LOC）。如果您每月从一千行代码中赚取$ 10,000，则每行会带来$ 10。</p><p> But that&#39;s obviously not true. We know that the same application can be written using a thousand, ten thousand, or a hundred thousand LOC. The thing the application does for people -- its value -- and the amount of code it takes to write it? They&#39;re not related at all. That takes us to the second rule of &#34;Code Economics&#34;: a line of code has no value whatsoever. It only has value as part of some deployable application. The application is the smallest unit of economic value. (Actually, it&#39;s UX flow, but for our purposes today an application supports one UX flow that the user finds value interacting with.)</p><p> 但这显然是不正确的。我们知道可以使用一千，一万或十万个LOC编写同一应用程序。应用程序为人们做的事情-它的价值-以及编写它所需的代码量？它们根本不相关。这将我们带到“代码经济学”的第二条规则：代码行毫无价值。它仅在某些可部署应用程序中具有价值。该应用程序是经济价值的最小单位。 （实际上，它是UX流程，但是就我们今天的目的而言，一个应用程序支持一个UX流，用户可以从中找到与之交互的价值。）</p><p> The value of an app is more directly measurable. Yes, sometimes it gets more complicated, like if the business purpose of the app is in-app purchases or referrals, but at some point money comes in and we can trace that money back to the app.</p><p> 应用程序的价值可以直接衡量。是的，有时它会变得更加复杂，例如，如果应用程序的业务目的是应用程序内购买或推荐，但是有时会赚钱，我们可以将这些钱追溯到应用程序中。</p><p> How about the cost of a line of code? Is it just the time we spend typing it in? That&#39;s obviously wrong. You have to design it, even if only in your head. You have to test it. You have to deploy it. In fact, once you start thinking about it, there&#39;s no limit to the amount of money you can spend on a line of code. If your app is successful, you might spend the rest of your lifetime maintaining that line of code -- looking at it every now and then, tweaking it, changing how it&#39;s used.</p><p> 一行代码的成本如何？这只是我们花时间输入的时间吗？这显然是错误的。即使只在脑海中，您也必须进行设计。您必须进行测试。您必须部署它。实际上，一旦您开始考虑，花在一行代码上的钱就没有限制了。如果您的应用程序成功，那么您可能会花费一生的时间来维护这行代码-时不时地查看它，进行调整，更改其使用方式。</p><p> Of course, most lines of code either work fine or they never provide enough value to make anybody bother with them again. (No economic value = no technical debt) But, assuming you know enough to write an app that has value, each line of code in that app has an potentially-infinite cost.</p><p> 当然，大多数代码行都可以正常工作，或者它们永远无法提供足够的价值来使任何人再次为它们烦恼。 （无经济价值=无技术债务）但是，假设您足够了解编写具有价值的应用程序，那么该应用程序中的每一行代码都有潜在的无限成本。</p><p> So value comes in app-sized chunks while costs is related to the tiny pieces we use to make that app -- and to a large degree this is under our control.</p><p> 因此，价值来自于应用程序大小的块，而成本与我们用于制作该应用程序的微小部分有关-很大程度上在我们的控制之下。 </p><p> We have a way in finance of dealing with things that have a limited value but a potentially-unlimited downside. We use a budget. I could go out next month and buy $500 worth of sugar-free bubblegum (I love the stuff), but I don&#39;t. I have a budget of $10 per month and I stick to it. That&#39;s not because bubblegum is such a huge drain on our finances. It&#39;s because little things add up. Without a budget, I have no reasonable way for my wife and I to discuss what&#39;s important to us. The budget isn&#39;t important. The conversation about values it drives is irreplaceable.</p><p>我们有一种财务方法来处理价值有限但可能受到无限限制的事物。我们使用预算。我下个月可以出去买价值500美元的无糖泡泡糖（我喜欢这种东西），但我不知道。我每月有10美元的预算，而且我坚持执行。那不是因为泡泡糖严重浪费了我们的财务。因为小事加起来。没有预算，我就没有合理的办法让我的妻子和我讨论对我们重要的事情。预算并不重要。关于它所驱动的价值的讨论是不可替代的。</p><p>   So far in our discussion, there&#39;s really no reason to pick one set of budget numbers over another. Should we limit our applications to a million lines of code? A hundred? We don&#39;t know. We can safely say two things. One, given the same value, more code equals more cost. Two, lines-of-code always grows out-of-control the more we poke at it. This leads to the conclusion in the third rule of Code Economics: the only way to limit the costs of solving a problem using programming is to arbitrarily limit the amount of code humans have to mentally-manipulate solving it.</p><p>   到目前为止，在我们的讨论中，实际上没有理由选择一组预算数字来代替另一组预算数字。我们应该将应用程序限制为一百万行代码吗？一百？我们不知道。我们可以放心地说两件事。一，给定相同的值，更多的代码等于更多的成本。第二，我们对它的戳入越多，代码行总是失控。这就得出了《代码经济学》第三条规则的结论：限制使用编程解决问题的成本的唯一方法是任意限制人们为解决问题而需要进行心理操作的代码数量。</p><p> In a way, this is all common sense. We&#39;ve been doing it for years. We just haven&#39;t been explicit about it. Shared libraries, frameworks, industry standards, and a dozen other things all exist in an effort to limit the amount of code humans have to mentally-manipulate to solve problems.</p><p> 在某种程度上，这是常识。我们已经做了很多年了。我们只是没有明确指出。共享的库，框架，行业标准以及许多其他东西都存在，以限制人们为解决问题而必须进行精神操作的代码量。</p><p> So why haven&#39;t we succeeded? Why can&#39;t most programmers today do their job using four or five lines of code?</p><p> 那为什么我们没有成功呢？为什么当今大多数程序员不能使用四到五行代码来完成工作？</p><p> Because lines-of-code always grows the more we poke at it. When the http protocol first appeared, if you wanted a web page? You brought up a terminal and telnetted a small number of commands. Boom, there&#39;s your webpage. Now, there are easily 10, maybe 20 various standards and libraries related to what used to be 10 seconds of work. Fifty years from now there will be 40 standards. Same value, more code. Value stays the same, cost of code continues to increase.</p><p> 因为代码行总是随着我们戳的越多而增长。当HTTP协议首次出现时，是否需要网页？您打开了一个终端，并通过telnet输入了少量命令。景气，这是您的网页。现在，很容易就有10到20种不同的标准和库，这些标准和库与过去需要10秒钟的工作有关。从现在开始的五十年中，将有40个标准。相同的值，更多的代码。价值保持不变，代码成本不断增加。</p><p> I&#39;d like to suggest a completely random rule that I just made up:   Arbitrarily limit lines of code used to solve a problem and write the app with the goal of never touching it again</p><p> 我想提出一个我刚刚制定的完全随机的规则：任意限制用于解决问题的代码行，并编写应用程序，以免再碰它</p><p>     Furthermore, since I&#39;m making stuff up, how about a 2000-200-20 rule for folks writing microservices? Whatever problem you have to solve using microservices, you have 20 microservices to solve it in. Each of those microservices can be written with no more than 200 lines of unique code.</p><p>     而且，由于我正在编造东西，所以编写微服务的人的2000-200-20规则怎么样？无论使用微服务必须解决什么问题，您都可以解决20个微服务。每个微服务都可以用不超过200行的唯一代码编写。 </p><p> But wait, I hear you say. That&#39;s never going to work! Okay, so among all of those microservices you can have 2,000 lines of code in a shared library. Anything you could ever touch counts as code.</p><p>但是，等等，我听到你说。那永远都行不通！好的，因此在所有这些微服务中，共享库中可以包含2,000行代码。您可能碰到的任何东西都算作代码。</p><p> I&#39;m not going to defend my made-up rules aside from saying that budgets always seem arbitrary, and it&#39;s not right to create a budget so small that the work can&#39;t get done. I don&#39;t believe I&#39;ve done that here -- but I might be wrong! Use other budgets if you like. Hell if I care. But use budgets.</p><p> 除了说预算似乎总是武断的，我不会捍卫自己的编造规则，而且创建如此小的预算以至于无法完成工作是不合适的。我不相信我在这里做到了-但我可能错了！如果愿意，可以使用其他预算。地狱，如果我在乎。但是要使用预算。</p><p> Most programmers probably don&#39;t think such a budget is fair, or workable. And I think it&#39;s fine. That&#39;s fascinating to me and indicates a lack of alignment somewhere in the way we train and socialize programmers.</p><p> 大多数程序员可能都不认为这样的预算是公平的或可行的。而且我认为很好。这让我着迷，并表明我们在培训和社交程序员方面缺乏一致性。</p><p> I&#39;m also suggesting a new thing that has to happen: a code budgeting discussion. Yes, Daniel, your WhizzBang widget is freaking awesome, but it uses 500 lines of code, and that&#39;s 500 lines we can&#39;t afford right now.</p><p> 我还建议必须发生的新事情：代码预算讨论。是的，丹尼尔，您的WhizzBang小部件很棒，但是它使用了500行代码，而这500行我们现在无法负担。</p><p> Whoa horsey! Wouldn&#39;t I love to hear somebody actually say that! Cost control, in a programming team. Imagine that! And what would come next? I have no idea!</p><p> 哇！我不想听到有人真的这么说吗！成本控制，在一个编程团队中。想象一下！接下来会发生什么？我不知道！</p><p>  Don&#39;t some problems require a lot of code? Don&#39;t some applications -- most, in fact -- require us to come back to them again and again in order to keep them in alignment with changing user needs?</p><p>  某些问题不需要很多代码吗？某些应用程序（事实上，大多数应用程序）是否要求我们一次又一次地与他们联系，以使其与不断变化的用户需求保持一致？</p><p> Both statements are true. For complex things, we write components. Those components have executing tests that describe them and are used/shared in multiple places. The more they are used/shared, the better they get. That means that components are just another project. It also means that if you don&#39;t have multiple teams using your component, you don&#39;t have a component. Component creation should be a decision made between teams and involve a completely new project. After all, they have both cost and value.</p><p> 两种说法都是正确的。对于复杂的事情，我们编写组件。这些组件具有描述它们的执行测试，并在多个地方使用/共享。他们使用/共享的次数越多，获得的效果越好。这意味着组件只是另一个项目。这也意味着，如果您没有多个团队使用您的组件，那么您就没有一个组件。组件的创建应该是团队之间的决定，并且涉及一个全新的项目。毕竟，它们既具有成本又具有价值。 </p><p> What about coming back to tweak the app as the business needs change? Assuming you have a release that is currently demonstrating value -- a big assumption, by the way -- I think you have to timebox it. Three months of verifying that the app got things mostly right. After that? You write a new app, of course. With the budget we&#39;re talking about it&#39;s not going to be a huge effort, you&#39;ve already been living in this space, and it&#39;s good to rethink things. Code budgets and timelines prevent  Second System Syndrome. (I think we went off-the-rails somewhere with Second System Syndrome, but I digress)</p><p>随着业务需求的变化回来重新调整应用程序怎么样？假设您当前发布的版本具有价值-顺便说一下，这是一个很大的假设-我认为您必须对其进行时间限制。三个月的时间来验证该应用程序是否正确。之后？当然，您编写了一个新应用。有了预算，我们谈论的并不是什么大的努力，您已经生活在这个领域中了，重新思考事情是件好事。代码预算和时间表可以防止“第二系统综合症”。 （我认为我们因第二系统综合症而偏离了轨道，但我离题了）</p><p> There are parts of this essay that are completely made-up. I tried to point those out. There are also parts that are built on decades of experience both coding solutions and watching teams work. What I&#39;ve seen over-and-over again is that really cool things happen with smart people and creative constraints. Really stupid stuff happens otherwise, because without constraints it&#39;s all  bike shedding.</p><p> 本文的某些部分是完全编造的。我试图指出这些。还有一些部分是建立在数十年的编码解决方案和观察团队工作经验的基础上的。我一遍又一遍地看到，聪明的人和创造性的约束会发生真正的酷事。否则，确实会发生愚蠢的事情，因为没有限制，这会导致所有自行车脱落。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danielbmarkham.com/code-budgets/">https://danielbmarkham.com/code-budgets/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>