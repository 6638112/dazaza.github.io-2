<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为WebAssembly制作预算Pascal编译器Making a budget Pascal compiler to WebAssembly</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Making a budget Pascal compiler to WebAssembly<br/>为WebAssembly制作预算Pascal编译器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 01:11:33</div><div class="page_narrow text-break page_content"><p>TL;DR: I made a budget Pascal compiler to WebAssembly so that I can play a hangman game that my friends and I made 10 years ago. Check out the  demo and the  github repository.</p><p>TL；博士：我为WebAssembly做了一个预算帕斯卡编译器，这样我就可以玩我和朋友10年前做的一个刽子手游戏。查看演示和github存储库。</p><p> About a month ago, I was reorganizing my old files in my laptop when I found something interesting. It was a console-based hangman game that my friends and I made in Pascal as a final project for intro to programming class  1 back in 2011. I had just finished reading  Crafting Interpreters by Robert Nystrom, so I thought it would be fun to move to compilers and try to compile the hangman game to WebAssembly. Here are some of many interesting things I learned and made during the development.</p><p>大约一个月前，我在整理笔记本电脑中的旧文件时，发现了一些有趣的东西。这是一款基于控制台的刽子手游戏，我和我的朋友在Pascal制作，作为2011年编程入门课程1的最后一个项目。我刚刚读完罗伯特·尼斯特罗姆（Robert Nystrom）的《手工艺解释器》（Crafting Translators），所以我觉得转向编译器并尝试将《刽子手》游戏编译成WebAssembly会很有趣。以下是我在开发过程中学到的许多有趣的东西。</p><p>  Making a full-fledge Pascal compiler is a very time-consuming task. I want the project to be small enough that I can finish it in 4-6 weeks, so I decided to support only a subset of Pascal features and language constructs (hence, “budget”). I chose which features to implement based on three principles:</p><p>制作一个完整的Pascal编译器是一项非常耗时的任务。我希望这个项目足够小，可以在4-6周内完成，所以我决定只支持Pascal特性和语言结构的子集（因此称为“预算”）。我根据三个原则选择了要实现的功能：</p><p> The compiler should be able to compile the hangman game without any changes to the game’s source code. This means I need to handle things that normally I don’t handle like files, output formatting, standard library methods like  pos,  clrscr,  readkey, and so on.</p><p>编译器应该能够在不改变游戏源代码的情况下编译刽子手游戏。这意味着我需要处理通常无法处理的事情，比如文件、输出格式、pos、CLRSC、readkey等标准库方法。</p><p>  The compiler should be able to handle things that “naturally” exist given the chosen features. For example, while the game source code doesn’t have any recursion call or use any floating-point number type, I think it would be weird not implementing those. However, things like dynamic length array, dynamic memory allocation, pointers, and fully-implemented set type are surplus to the requirements. This rationale is quite arbitrary but I settled on it.</p><p>编译器应该能够处理给定所选特性的“自然”存在的事物。例如，虽然游戏源代码没有任何递归调用或使用任何浮点数类型，但我认为不实现它们会很奇怪。然而，动态长度数组、动态内存分配、指针和完全实现的集合类型等都超出了需求。这个理由很武断，但我还是决定了。</p><p>  The compiler should compile a strict subset of Pascal. This means while it can’t compile some Pascal programs, all programs that it can compile should be compilable by other full-feature Pascal compiler like FreePascal. There should be no program that is valid for this compiler but invalid for other compilers. This is easier said than done and I’m still not 100% sure if the implementation is indeed a strict subset.</p><p>编译器应该编译Pascal的严格子集。这意味着，虽然它不能编译某些Pascal程序，但它可以编译的所有程序都应该可以由其他完整功能的Pascal编译器（如FreePascal）编译。不应该有任何程序对此编译器有效，但对其他编译器无效。这说起来容易做起来难，我仍然不能100%确定实现是否确实是一个严格的子集。</p><p> The full detail of chosen features can be found in the  repository’s readme. In summary, the compiler can handle:</p><p>所选功能的完整细节可以在存储库的自述中找到。总之，编译器可以处理：</p><p>   I wanted the hangman game to be playable on a web page. There are three approaches  2 to do it: (1) make a virtual machine that interprets and runs the Pascal program, (2) transpile the Pascal program to Javascript and then run it using  Function object, and (3) compile the Pascal program to WebAssembly. I chose the third option because I’m interested in WebAssembly for quite some time and it seems more fun and challenging than “just” making a VM or transpiling to Javascript.</p><p>我想让刽子手游戏可以在网页上玩。有三种方法可以做到这一点：（1）制作一个解释并运行Pascal程序的虚拟机，（2）将Pascal程序转换为Javascript，然后使用Function object运行它，（3）将Pascal程序编译为WebAssembly。我选择了第三个选项，因为我对WebAssembly感兴趣已经有相当一段时间了，它似乎比“仅仅”制作虚拟机或转换为Javascript更有趣、更具挑战性。</p><p> While it is possible to just manually produce WebAssembly binary bytecodes, I used the  binaryen-js library because it’s easier and it also have validation and optimization features. The downside is that it is quite large, about 5 MB even after packed using parceljs. It also uses tree representation for validating and optimizing the WebAssembly module, so a few expressions like multivalue tuples and manual stack manipulation are a little bit harder to express. At the time I didn’t realize there’s also  wabt.js, so it is possible to produce WebAssembly code in text format first and then convert it to binary format.</p><p>虽然可以手动生成WebAssembly二进制字节码，但我使用了binaryen js库，因为它更简单，而且还具有验证和优化功能。缺点是它相当大，即使使用parceljs打包，也大约有5MB。它还使用树表示来验证和优化WebAssembly模块，因此一些表达式，如多值元组和手动堆栈操作，更难表达。当时我不知道还有wabt。js，所以可以先生成文本格式的WebAssembly代码，然后将其转换为二进制格式。</p><p>  WebAssembly has concept for  local variable, so locally-used variable can be implemented using it. However, it can only store integer or float value. For basic types the compiler can just directly use  f64 variable for real and  i32 variable for ordinals (integer, char, boolean), but for complex type like string, array, or record, it needs to maintain a call stack in the memory and store the address of the value as an  i32 local variable. Values in the call stack are allocated when a subroutine is called, and deallocated when the subroutine returns. The call stack is implemented in three parts:</p><p>WebAssembly有局部变量的概念，所以可以使用它实现局部使用的变量。但是，它只能存储整型或浮点值。对于基本类型，编译器可以直接将f64变量用于实数，将i32变量用于序数（整数、字符、布尔），但对于字符串、数组或记录等复杂类型，编译器需要在内存中维护调用堆栈，并将值的地址存储为i32局部变量。调用子例程时会分配调用堆栈中的值，子例程返回时会取消分配。调用堆栈由三部分实现：</p><p> Two global variable SP (stack pointer) and (FP) frame pointer. SP stores an address to top of value stack, and FP stores an address to top of call frame stack.</p><p>两个全局变量SP（堆栈指针）和FP（帧指针）。SP将地址存储到值堆栈的顶部，FP将地址存储到调用帧堆栈的顶部。</p><p>    Call frame stack, a region of the memory that stores base address of the value stack for that call and subroutine id.</p><p>调用帧堆栈，存储该调用的值堆栈基址和子例程id的内存区域。</p><p>  program  test ;  type  SmallStr  =  string [ 9 ];  var  str :  SmallStr ;  x :  integer ;  procedure  a ( strA :  SmallStr ;  z :  char );  begin  // ...  end ;  procedure  b ( strB :  SmallStr );  var  strB1 :  SmallStr ;  y :  boolean ;  begin  // ...  y  :=  false ;  a ( strB ,  &#39;a&#39; );  end ; begin  b ( str ); end .</p><p>程序测试；输入SmallStr=string[9]；var-str:SmallStr；x：整数；程序a（strA:SmallStr；z:char）；开始。。。终止程序b（strB:SmallStr）；var-strB1:SmallStr；y：布尔；开始。。。y:=假；a（strB，&#39；a&#39；）；终止开始b（str）；终止</p><p> When procedure  a is called, the call frame and value stack would look something like this in memory. Notice that variables  x,  y and  z are not manually stored in the memory.</p><p>当调用过程a时，调用帧和值堆栈在内存中看起来像这样。请注意，变量x、y和z不是手动存储在内存中的。</p><p> Things are a little more complicated for non-locally used variable; that is using variable declared by the parent scope or using variable as an argument to a var parameter. One big limitation of WebAssembly local variable is that it can’t be referenced as a pointer from outside of that function that declare it, so all non-locally used variable must be stored in memory regardless of the data type. For example, consider the following Pascal program.</p><p>对于非局部使用的变量，情况要复杂一些；即使用父作用域声明的变量，或使用变量作为var参数的参数。WebAssembly局部变量的一大限制是，它不能作为声明它的函数外部的指针引用，因此所有非局部使用的变量必须存储在内存中，而不管数据类型如何。例如，考虑下面的PASCAL程序。</p><p> program  test ;  var  x1 ,  x2 :  integer ;  procedure  outer ( var  x :  integer );  var  y1 ,  y2 :  integer ;  procedure  inner ();  var  z :  integer ;  begin  y1  :=  1 ;  // use y1 in inner  // ...  end ;  begin  x  :=  2 ;  inner ();  // ...  end ; begin  outer ( x1 );  // use x1 as argument to a var parameter end .</p><p>程序测试；变量x1，x2：整数；程序外部（变量x：整数）；变量y1，y2：整数；程序内部（）；var z：整数；从y1开始：=1；//在内部使用y1/。。。终止开始x:=2；内部（）；/。。。终止从外部开始（x1）；//使用x1作为变量参数结尾的参数。</p><p> Variable x1 and y1 will be stored in memory, while x2, y2 and z will be stored as WebAssembly local variables. The call frame and value stack will look like this when procedure  inner is called.</p><p>变量x1和y1将存储在内存中，而x2、y2和z将存储为WebAssembly局部变量。调用内部过程时，调用帧和值堆栈将如下所示。</p><p>   This part looked deceptively easy when it’s actually not. I wanted to emulate the terminal console on the web page. So naturally I used the  xterm.js library. It’s not the easiest thing to use because I needed to manually handle the key and data event from the library, but it’s still way faster and easier than reimplementing a terminal UI. The terminal emulator worked!</p><p>这一部分看似简单，但实际上并非如此。我想在网页上模拟终端控制台。所以我很自然地使用了xterm。js图书馆。这不是最容易使用的东西，因为我需要手动处理库中的键和数据事件，但它仍然比重新实现终端UI快得多，也容易得多。终端模拟器成功了！</p><p> This was the point where I realized that WebAssembly currently do not support call to asynchronous function or coroutines. If an imported function is an async function or a coroutine, it won’t pause execution to wait for the result. There is a way to handle this from inside the WebAssembly code using  Asyncify, but it involves call stack rewinding and is quite complicated. Instead, I used a combination of  Web Workers and  Atomics wait and notify API. Basically, the compiled Pascal program is instantiated and executed inside a Web Worker. When there is an asynchronous call, such as readln, the web worker calls  Atomics.wait() to pause itself. The main UI thread will call  Atomics.notify() to the worker thread after a certain event is fired, in this case when a new line is read by the terminal emulator. So problem solved! Well, not quite yet.</p><p>在这一点上，我意识到WebAssembly目前不支持对异步函数或协同路由的调用。如果导入的函数是异步函数或协同程序，则不会暂停执行以等待结果。有一种方法可以使用Asyncify从WebAssembly代码内部处理这个问题，但它涉及调用堆栈倒带，而且相当复杂。相反，我使用了Web Workers和Atomics wait and notify API的组合。基本上，已编译的Pascal程序是在Web Worker中实例化和执行的。当有一个异步调用时，比如readln，web工作者调用原子。等待（）暂停自己。主UI线程将调用Atomics。在触发特定事件后（在本例中，当终端仿真器读取新行时），通知工作线程。所以问题解决了！嗯，还没有。</p><p> It turned out that Atomics wait and notify API need SharedArrayBuffer to work, and SharedArrayBuffer is only enabled  3 if the page was  cross-origin isolated. This is actually quite simple to achieve by adding extra headers to the top level document http response. Simple, if you have control of the server that serves the page. I didn’t have any active VPS at the time and I certainly didn’t have access to change response header in Github Page server. While VPS are quite cheap and easy to setup and I might need to use it for other purposes in the future, it’s still too much of a hassle and waste to set it up just for serving a static content. Luckily, I found  a blog post by stefnotch that exactly solves my problem. The article has more detailed explanation, but it basically works by using a Service Worker to manually add the needed headers to the response.</p><p>事实证明，Atomics等待并通知API需要SharedArrayBuffer才能工作，而SharedArrayBuffer只有在页面被跨源隔离时才启用3。通过向顶层文档http响应中添加额外的头，这实际上非常简单。很简单，如果你控制了为页面服务的服务器。我当时没有任何活动的VP，当然也没有权限更改Github页面服务器中的响应头。虽然VPS非常便宜，易于安装，而且我将来可能需要将其用于其他目的，但仅为提供静态内容而设置它仍然是一件非常麻烦和浪费的事情。幸运的是，我找到了stefnotch的一篇博客文章，它正好解决了我的问题。本文有更详细的解释，但它基本上是通过使用服务工作者手动将所需的头添加到响应中来工作的。</p><p>  There are a lot of things that can be improved in my compiler implementation, but here are some of the more important ones.</p><p>在我的编译器实现中有很多地方可以改进，但这里有一些更重要的地方。</p><p> I really should have the parser and the type checker &amp; resolver be seperated into different modules. I made it combined so that it only need two passes (parse + type check then emit binary) instead of three or more (parse, type check, then emit binary). It is faster but in hindsight it’s not that big of a difference and it makes the parser code more complex.</p><p>我真的应该有解析器和类型检查器&amp；分解器可分为不同的模块。我将其组合在一起，这样它只需要两次（解析+类型检查，然后发射二进制）而不是三次或更多（解析、类型检查，然后发射二进制）。它的速度更快，但事后看来，差别并不大，而且它使解析器代码更加复杂。</p><p>  The runtime library is currently always recompiled everytime a program is compiled. It shouldn’t be that hard to pre-compile it and then “copy” it to the compiled program, but I haven’t got the time. Also, I should have make the runtime library in higher-level language like C then compile it to WebAssembly, instead of making it manually in WebAssembly. There are some issues with that method (for example, the Pascal runtime will include C runtime and I need to remove it or handle it so it plays nicely), but I think it’s way much easier and better to do that if I were to made a serious compiler with a complete standard library.</p><p>当前，每次编译程序时都会重新编译运行库。预编译并将其“复制”到已编译的程序中应该不难，但我没有时间。此外，我应该用更高级的语言（如C）创建运行库，然后将其编译到WebAssembly，而不是在WebAssembly中手动创建。该方法存在一些问题（例如，Pascal运行时将包含C运行时，我需要删除它或处理它，以便它能很好地发挥作用），但我认为，如果我用一个完整的标准库成为一个认真的编译器，这样做会更容易、更好。</p><p>  Handling messaging for async operations between the program runner worker thread and the main UI thread is quite a mess and tightly coupled. I haven’t got a good idea on how to tidy it up without going too generalized.</p><p>在program runner worker线程和主UI线程之间处理异步操作的消息传递非常混乱，而且紧密耦合。我不知道如何在不太笼统的情况下整理它。</p><p>  All in all I’m satisfied with the result of this project. I found WebAssembly to be an interesting compilation target, although there are definitely some growing pains which should be resolved in the future. I also found this project to be a good reminder of where I am now compared to where I was ten years ago. Hopefully, in another ten years I will see this project the way I see the old hangman game that started this project.</p><p>总而言之，我对这个项目的结果很满意。我发现WebAssembly是一个有趣的编译目标，尽管在未来肯定会有一些成长的烦恼需要解决。我还发现，与十年前相比，这个项目很好地提醒了我现在的处境。希望在接下来的十年里，我能像我看到老刽子手游戏那样看待这个项目。</p><p>   PTI-A class, for those who were pre-2012 ITB students. If I remember correctly, the class was reorganized into PTI-B and DasPro classes for CS &amp; EE students due to a syllabus change in 2012.  ↩︎︎</p><p>PTI-A课程，面向2012年之前的ITB学生。如果我没记错的话，该课程被重新组织为用于CS&amp；的PTI-B和DasPro课程；由于2012年课程大纲的改变，EE学生。  ↩︎︎</p><p>  I’m fully aware that there is a way to  compile Pascal to WebAssembly using FreePascal and maybe a lot more other ways, but I also want to make a compiler!  ↩︎︎</p><p>我完全知道有一种方法可以使用FreePascal和其他很多方法将Pascal编译成WebAssembly，但我也想做一个编译器！  ↩︎︎</p><p>  This was originally not the case, until Meltdown and Spectre changed everything.  ↩︎︎</p><p>最初情况并非如此，直到熔毁和幽灵改变了一切。  ↩︎︎</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/制作/">#制作</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/budget/">#budget</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>