<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>盒子里有什么东西？ What's in the Box?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What's in the Box?<br/>盒子里有什么东西？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 23:34:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The first, is that the advice is very rarely heeded, and instead, whoever Ijust said it to disappears for two days, emerging victorious, basking in theknowledge that, YES, the compiler  could inline that, if it wanted to.</p><p>首先，这一建议很少见到，而且，无论谁说，谁都说它会消失两天，所以胜利，是因为它，编译器可能会在线，如果它想要。</p><p> And the second is that, without a  lot of context, this sentence is utternonsense if you don&#39;t have a working knowledge of Rust. As a Java developer,you may be wondering if we&#39;re trying to turn numbers into objects (we arenot). In fact, even as a Rust developer, you may have just accepted that boxingis just a fact of life.</p><p> 第二，如果没有很多背景，如果你没有工作知识，就没有很多背景，这句话是Utternonsense。作为Java开发人员，您可能会想知道我们是否尝试将数字转换为对象（我们的arenot）。事实上，即使是作为铁锈开发商，您也可能刚刚接受了拳击只是一个生命的事实。</p><p> It&#39;s just a thing we have to do sometimes, so the compiler stops being mad atus, and things just  suddenly start working. That&#39;s not necessarily a badthing. That&#39;s just  how good compiler diagnostics are, that it can just tellyou &#34;hold on there friend, I really think you want to box it&#34;, and you can copyand paste the solution, and the puzzle is cracked.</p><p> 它＆＃39;只是我们有时要做的一件事，所以编译器停止疯狂的atus，突然开始工作。那个＆＃39;不一定是一个坏话。 ＆＃39; s只是如何良好的编译器诊断，它可以只是tellyou＆＃34;在那里抱着朋友，我真的认为你想要盒子＆＃34;，你可以复制和粘贴解决方案，拼图是破解。</p><p> But! Just because we can get by for a very long time without knowing what itmeans, doesn&#39;t mean I can resist the sweet sweet temptation of explaining inexcruciating details what it actually means, and so, that&#39;s exactly whatwe&#39;re going to do in this article.</p><p> 但！仅仅因为我们可以在不知道它的情况下获得很长一段时间，而不是意味着我可以抵抗甜蜜的甜蜜诱惑，解释解释的甜蜜甜蜜的细节它实际意味着什么，所以＆＃39;究竟是什么＆＃39 ;重申在这篇文章中。</p><p> Before we do that, though, let&#39;s look at a simple example where we might beenjoined by a well-intentioned colleague to, as it were, &#34;just box it&#34;.</p><p> 然而，在我们这样做之前，让我们看看一个简单的例子，我们可能会被一位善意的同事们所做的，因为它，＆＃34;只是框＆＃34;</p><p>  Whenever  cargo new is invoked, it generates a simple &#34;hello world&#34;application, that looks like this:</p><p>  每当调用货物新建时，它会生成一个简单的＆＃34;你好世界＆＃34;应用程序，看起来像这样：</p><p>  It is pure, and innocent, and devoid of things that can fail, which is great.</p><p>  它是纯洁的，无辜的，没有任何可能失败的东西，这很好。 </p><p> $ cargo run Compiling whatbox v0.1.0 (/home/amos/ftl/whatbox) Finished dev [unoptimized + debuginfo] target(s) in 0.47s Running `target/debug/whatbox`Hello, world!</p><p>$ Cargo Run编译Whatbox V0.1.0（/ home / amos / ftl / whatbox）完成的dev [未通过+ debuginfo] target 0.47s运行`target / debug / whatbox`hello，world！</p><p>     read_to_string can fail! And that&#39;s why it returns a  Result&lt;String, E&gt;and not just a  String.</p><p>     read_to_string可能会失败！并且它为什么它返回结果＆lt; string，e＆gt;而不仅仅是一个字符串。</p><p> And that&#39;s also why we need to call  .unwrap() on it, to go from Result&lt;String, E&gt; to either:</p><p> 而且，它也是为什么我们需要调用.unwrap（），从结果＆lt; string，e＆gt;要么：</p><p>  $ cargo run --quietthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &#34;No such file or directory&#34; }&#39;, src/main.rs:2:59note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</p><p>  $货物运行--quietthread＆＃39; main＆＃39;闹剧＆＃39;被叫`结果:: unwrap（）`在`err` value：ore {代码：2，种类：notfound，message：＆＃34;没有这样的文件或目录＆＃34; }＆＃39;，src / main.rs：2：59注意：使用`rust_backtrace = 1`环境变量来显示回溯</p><p>   But let&#39;s say we want to read a string  inside a function. Our own function.</p><p>   但是，假设我们想在函数内读取一个字符串。我们自己的功能。</p><p>     But that&#39;s not really the code we want. See, the  read_issue function feelslike &#34;library code&#34;. Right now, it&#39;s in our application, but I could seemyself splitting that function into its own crate, maybe a crate named linux-info or something, because it could be useful to other applications.</p><p>     但它不是我们想要的代码。请参阅，Read_issue函数Feelslike＆＃34;图书馆代码＆＃34;现在，它在我们的应用程序中，但我可以看到函数分成自己的箱子，也许是一个名叫Linux-Info或其他东西的箱子，因为它对其他应用程序有用。</p><p> And so, even though it&#39;s in the same crate as the  main function, I don&#39;t feelcomfortable causing a panic in  read_issue, the way I felt comfortable causinga panic  at the disco in  main.</p><p> 所以，即使它在与主要功能相同的箱子中，我也不会在read_issue中引起恐慌的，我在迪斯科舞厅中感到舒适地引起恐慌。 </p><p> Instead, I think I want  read_issue to return a  Result, too. Because Result&lt;T, E&gt; is an enum, that can represent two things: the operation hassucceeded (and we get a  T), or it failed (and we get an  E).</p><p>相反，我想我也希望read_issue返回结果。因为结果＆lt; t，e＆gt;是一个枚举，可以代表两件事：hassucceeded的操作（我们得到一个t），或者它失败了（我们得到了一个e）。</p><p>  And we know that when the operation succeeds, we get a  String, so we knowwhat to pick for  T. But the question is: what do we pick for  E?</p><p>  我们知道，当操作成功时，我们得到一个字符串，所以我们知道要选择T.但问题是：我们选择了什么？</p><p> fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // what is `E` supposed to be? 👇 fn  read_issue ( ) -&gt;  Result &lt; String,  E &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p> fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //是什么是`E`应该是什么？ 👇fn read_issue（） - ＆gt;结果＆lt;字符串，E＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p> And that problem, that specific problem, is not something we really have toworry about in some other languages, like for instance... ECMAScript! I mean,JavaScript!</p><p> 那个问题，那个具体的问题，不是我们真正拥有的一些其他语言的东西，比如...... ECMAScript！我的意思是，javascript！</p><p>  import  {  readFileSync  }  from  &#34;fs&#34; ; function  main ( )  {  let  issue  =  readIssue ( ) ;  console . log ( ` ${ issue }` ) ; } function  readIssue ( )  {  readFileSync ( &#34;/etc/i-do-not-exist&#34; ) ; } main ( ) ;</p><p>  从＆＃34导入{readfilesync}; fs＆＃34; ; function main（）{let问题= readissue（）;安慰 。日志（`$ {问题}`）; }函数readissue（）{readfilesync（＆＃34; / etc / i-do-not-witt-witts＆＃34;）; } 主要的 （ ） ;</p><p> $ node js/index.mjs node:fs:505 handleErrorFromBinding(ctx); ^Error: ENOENT: no such file or directory, open &#39;/etc/i-do-not-exist&#39; at Object.openSync (node:fs:505:3) at readFileSync (node:fs:401:35) at readIssue (file:///home/amos/ftl/whatbox/js/index.mjs:9:5) at main (file:///home/amos/ftl/whatbox/js/index.mjs:4:17) at file:///home/amos/ftl/whatbox/js/index.mjs:12:1 at ModuleJob.run (node:internal/modules/esm/module_job:154:23) at async Loader.import (node:internal/modules/esm/loader:177:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) { errno: -2, syscall: &#39;open&#39;, code: &#39;ENOENT&#39;, path: &#39;/etc/i-do-not-exist&#39;}</p><p> $节点js / index.mjs节点：FS：505 HanderErrorfrombinIning（CTX）; ^错误：Enoent：没有这样的文件或目录，打开＆＃39; / etc / i-do-not-witts＆＃39;在Readfilesync（node：fs：401：35）在Readissue（文件：///home/amos/ftl/whatbox/js/index.mjs：9：5）在主要（文件：//home/amos/ftl/whatbox/js/index.mjs：4：17）文件：///home/amos/ftl/whatbox/js/index.mjs：12：1在modulejob.run（节点：内部/模块/ ESM / module_job：154：23）在Async Loader.import（Neuts：Modules / ESM / Loader：177：24）在Async Object.LoadM中（节点：内部/流程/ ESM_Loader：68：5）{errno：-2，syscall：＆＃39;打开＆＃39;，代码：＆＃39; enoent＆＃39;，路径：＆＃39; / etc / i-do-not-ides＆ ＃39;}</p><p> And we don&#39;t  have to worry whether  readIssue can or cannot throw when wecall it:</p><p> 我们不必担心阅读是否可以担心阅读可以或不能抛出： </p><p>  Well, maybe we should! Maybe we should wrap it in a try-catch, just so we canrecover from any exceptions thrown. But we don&#39;t  have to. Our programfollows the happy path happily.</p><p>好吧，也许我们应该！也许我们应该在一个尝试中包装它，只需从任何抛出的任何例外都可以释放。但我们不得不。我们的编程愉快地愉快地散步。</p><p> In Go, there&#39;s no exceptions, but there is usually an indication that afunction can fail in its signature.</p><p> 在Go，没有例外，但通常有一个指示在其签名中可能会失败。</p><p> package main import (	 &#34;log&#34;	 &#34;os&#34;) func  main() {	 issue  :=  readIssue()	 log. Printf( &#34;issue = %v&#34;,  issue)} func  readIssue()  string {	 bs,  _  :=  os. ReadFile( &#34;&#34;)	 return  string( bs)}</p><p> 包主要导入（＆＃34; log＆＃34;＆＃34; os＆＃34;）func main（）{问题：= readissue（）日志。 printf（＆＃34;问题=％v＆＃34;问题）} func readissue（）字符串{bs，_：=操作系统。 ReadFile（＆＃34;＆＃34;）返回字符串（BS）}</p><p>   package main import (	 &#34;log&#34;	 &#34;os&#34;) func  main() {	 // we get two values out of readIssue, including `err`	 issue,  err  :=  readIssue()	 // ...which we should check for nil-ness	 if  err  !=  nil {		 // ...and handle		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} func  readIssue() ( string,  error) {	 bs,  err  :=  os. ReadFile( &#34;&#34;)	 // same here, `ReadFile` does a multi-valued return, so we need	 // to check `err` first:	 if  err  !=  nil {		 return  &#34;&#34;,  err	}	 // and only here do we know reading the file actually succeeded:	 return  string( bs),  nil}</p><p>   包主要导入（＆＃34; log＆＃34;＆＃34; OS＆＃34;）func main（）{//我们获得了两个值，包括`err`问题，err：= readissue（）// ...如果err！= nil {// ......并处理日志，我们应该检查nil-ness。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} func Readissue（）（字符串，错误）{bs，err：=操作系统。 ReadFile（＆＃34;＆＃34;）//同样，'readfile`是一个多价值的返回，所以我们需要//首先检查`err`：如果err！= nil {返回＆＃34;＆ ＃34;，err} //只有在这里我们知道读取文件实际上成功：返回字符串（BS），nil}</p><p>  $ go run go/main.go2021/04/17 20:47:37 fatal error: open : no such file or directoryexit status 1</p><p>  $ go运行go / main.go2021 / 04/17 20:47:37致命错误：打开：没有这样的文件或directoryexit状态1</p><p> However, note that it does not tell us  where in the code the erroroccurred, whereas the JavaScript/Node.js version did.</p><p> 但是，请注意，它没有告诉我们在代码中的何处是错误的，而JavaScript / node.js版本。</p><p> There&#39;s  a solution to that, but bydefault, out of the box, Go errors do not capture stack traces.</p><p> 在那里有一个解决方案，但是bydefault开箱即用，go错误不会捕获堆栈痕迹。 </p><p> And then there&#39;s Rust, which is the most strict of the three, that forces usto declare that a function can fail, forces us to handle any error that mayhave occurred in a function, but also forces us to describe &#34;what possibleerror values are there&#34;.</p><p>然后是那里的生锈，这是三者中最严格的rust，迫使USTO声明一个函数可以失败，强迫我们处理可能在函数中发生的任何错误，但也迫使我们描述＆＃34 ;有可能的错误值是有可能的。</p><p>    $ node js/index.mjsnode:internal/process/esm_loader:74 internalBinding(&#39;errors&#39;).triggerUncaughtException( ^woops(Use `node --trace-uncaught ...` to show where the exception was thrown)</p><p>    $ node js / index.mjsnode：内部/进程/ ESM_LOADER：74内部屏障（＆＃39;错误＆＃39;）。triggerung ackexception（^ woops（使用`node -trace-undaught ...`来显示异常的位置扔了）</p><p> This is not a good idea. Mostly, because then we don&#39;t get a stack trace.</p><p> 这不是一个好主意。大多数情况下，因为那么我们不会得到堆栈迹象。</p><p>      $ node js/index.mjs file:///home/amos/ftl/whatbox/js/index.mjs:7 throw new Error(&#34;woops&#34;); ^Error: woops at readIssue (file:///home/amos/ftl/whatbox/js/index.mjs:7:11) at main (file:///home/amos/ftl/whatbox/js/index.mjs:2:17) at file:///home/amos/ftl/whatbox/js/index.mjs:10:1 at ModuleJob.run (node:internal/modules/esm/module_job:154:23) at async Loader.import (node:internal/modules/esm/loader:177:24) at async Object.loadESM (node:internal/process/esm_loader:68:5)</p><p>      $节点js / index.mjs文件：///home/amos/ftl/whatbox/js/index.mjs：7抛出新的错误（＆＃34; Woops＆＃34;）; ^错误：在Readissue（文件：///home/amos/ftl/whatbox/js/index.mms：7：11）在main（文件：///主页/ amos / ftl / whatbox / js / index。 MJS：2：17）AT文件：///home/amos/ftl/whatbox/js/index.mjs：10：1在modulejob.run（节点：内部/ modules / Esm / module_job：154：23）在异步Loader.import（Node：内部/模块/ ESM / LOADER：177：24）在ASYNC Object.LoadMSM（节点：内部/进程/ ESM_Loader：68：5）</p><p> As for Go, well. You can&#39;t just say you&#39;re going to return an  error, andjust return a  string. That&#39;s good.</p><p> 至于去。你可以＆＃39; t只是说你＆＃39;重新返回一个错误，返回一个字符串。那个＆＃39;好。</p><p>  $ go run go/main.go# command-line-argumentsgo/main.go:17:13: cannot use &#34;woops&#34; (type string) as type error in return argument: string does not implement error (missing Error method)</p><p>  $ go / main.go＃命令行 -  argipsge / main.go：17：13：不能使用＆＃34; woops＆＃34; （类型字符串）作为返回参数中的类型错误：字符串不实现错误（缺少错误方法）</p><p> Whatever you return has to be of type  error, and there is a shorthandfor that:</p><p> 无论你返回什么都是错误的错误，而且有一个替代方案： </p><p>   // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func  New( text  string)  error {	 return  &amp; errorString{ text}}</p><p>// new返回格式为给定文本的错误。 //即使文本是相同的，每个对新的呼叫也返回一个不同的错误值。 Func new（文本字符串）错误{return＆amp; errorstring {text}}</p><p>   That implements the  error interface. All the interface asks for is thatthere is an  Error() method that returns a  string:</p><p>   这实现了错误界面。所有接口都要求返回字符串的错误（）方法：</p><p>    Which is not to say that error handling in Go is a walk in the park.</p><p>    这并不是说去的错误处理是在公园散步。</p><p> This first bit has been pointed out in almost every article that has eventhe slightest amount of feelings about Go: it&#39;s just way too easy to ignore,or &#34;forget to handle&#34; Go errors:</p><p> 几乎所有关于Go的感觉几乎所有文章都指出了这一比特：它＆＃39;虽然太容易忽视了，或者＆＃34;忘记处理＆＃34;去错误：</p><p> func  readIssue() ( string,  error) {	 bs,  err  :=  os. ReadFile( &#34;/etc/issue&#34;)	 err  =  os. WriteFile( &#34;/tmp/issue-copy&#34;,  bs, 0o644)	 if  err  !=  nil {		 return  &#34;&#34;,  err	}	 return  string( bs),  nil}</p><p> Func Readissue（）（字符串，错误）{BS，ERR：= OS。 ReadFile（＆＃34; / etc /问题＆＃34;）err = os。 writefile（＆＃34; / tmp / moss-copy＆＃34; bs，0o644）如果err！= nil {return＆＃34;＆＃34;，err} return字符串（bs），nil}</p><p> Woops! No warnings, no nothing. If we fail to read the file, that error isgone forever. The issue here is of course that Go returns &#34;multiple things&#34;:both the &#34;success value&#34; and the &#34;error value&#34;, and it&#39;s on you to pinky swear not to touch the success value, if you haven&#39;t checked the error value first.</p><p> Woops！没有警告，没有什么。如果我们无法读取该文件，那么永远错误地错误。这里的问题当然是返回＆＃34;多件事＆＃34;：＆＃34;成功价值＆＃34;和＃34;误差值＆＃34;和它＆＃39;在粉红色发誓不要触摸成功价值，如果你verven＆＃39; t先检查了错误值。</p><p> And that problem doesn&#39;t exist in a language with sum types — a Rust Resultis either  Result::Ok(T), or  Result::Err(E), never both.</p><p> 并且这个问题并不存在于一种语言中的语言 - 一个生锈结果，结果:: OK（t），或结果:: err（e），从不兼而有之。 </p><p>    Then we can return it as an  error. Because  error is an interface, and *naughtyError has an  Error method that returns a string, everything fitstogether, boom, composition, alright!</p><p>然后我们可以将其作为错误返回。因为错误是一个接口，而* naugtyerror有一个错误的方法返回一个字符串，一切都很紧身，繁荣，组成，好！</p><p>   But if we accidentally return a value of type  *naughtyError, that justhappens to be  nil, well...</p><p>   但是，如果我们不小心返回了一个类型的* naugtyerror的价值，那么justhappens就是零，好吧......</p><p> package main import (	 &#34;log&#34;) func  readIssue() ( string,  error) {	 var  err  * naughtyError	 log. Printf( &#34;(in readIssue) is err nil? %v&#34;,  err  ==  nil)	 return  &#34;&#34;,  err} func  main() {	 issue,  err  :=  readIssue()	 log. Printf( &#34;(in main) is err nil? %v&#34;,  err  ==  nil)	 if  err  !=  nil {		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} // type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;}</p><p> 包主要导入（＆＃34; log＆＃34;）func Readissue（）（字符串，错误）{var Err * naughtyError日志。 Printf（＆＃34;（在Readissues中）是错误的吗？％v＆＃34;，err == nil）返回＆＃34;＆＃34;，err} func main（）{问题，err：= readissue（）日志。如果err！= nil {log，printf（＆＃34;（主要）是err nil？％v＆＃34;，err == nil）。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} //类型naughtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob no＆＃34;}</p><p> $ go run go/main.go2021/04/17 21:08:08 (in readIssue) is err nil? true2021/04/17 21:08:08 (in main) is err nil? false2021/04/17 21:08:08 fatal error: oh noexit status 1</p><p> $ go运行go / main.go2021 / 04/17 21:08:08（在Readissue）是错误的吗？ True2021 / 04/17 21:08:08（主要）是错误吗？ False2021 / 04/17 21:08:08致命错误：oh noxit状态1</p><p>   The first issue, &#34;forgetting to check for nil&#34;, is easy to understand.  Wetold you where the error was. Just don&#39;t forget to check it. It&#39;s easy to fitinto one&#39;s mental model of Go, which is advertised as really really simple.</p><p>   第一个问题，＆＃34;忘记检查nil＆＃34;很容易理解。韦尔托你错误的地方。只是不要忘记检查一下。它易于Fitinto One＆＃39; Go的心理模型，这是真正简单的宣传。</p><p>    We have two  err values in our last, naughty sample program. One of themcompares equal to  nil, and the other does not.</p><p>    我们上次顽皮的示例计划中有两个错误的值。其中一个比例等于nil，另一个没有。</p><p>  package main import (	 &#34;log&#34;	 &#34;unsafe&#34;) func  readIssue() ( string,  error) {	 var  err  * naughtyError	 log. Printf( &#34;(in readIssue) nil? %v, size = %v&#34;,  err  ==  nil,  unsafe. Sizeof( err))	 return  &#34;&#34;,  err} func  main() {	 issue,  err  :=  readIssue()	 log. Printf( &#34;(in main) nil? %v, size = %v&#34;,  err  ==  nil,  unsafe. Sizeof( err))	 if  err  !=  nil {		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} // type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;}</p><p>  包主要导入（＆＃34; log＆＃34;＆＃34;不安全＆＃34;）func readissue（）（字符串，错误）{var err * naughtyerror日志。 printf（＆＃34;（readissuee）nil？％v，size =％v＆＃34;，err == nil，不安全。sizeof（错误））返回＆＃34;＆＃34;，err} func main（ ）{问题，err：= readissue（）日志。 printf（＆＃34;（主要）nil？％v，size =％v＆＃34;，err == nil，不安全。如果err！= nil {log {log。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} //类型naughtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob no＆＃34;} </p><p> Packages that import unsafe may be non-portable and are not protected by theGo 1 compatibility guidelines.</p><p>进口不安全的软件包可能是不可移植的，不受兼容性指南的保护。</p><p> ...but what we&#39;re doing here is completely harmless. The important bit, as Iunderstand it, is that as a Go developer,  you&#39;re not supposed to care.</p><p> ......但我们在这里做什么是完全无害的。重要的位，正如Iyunderstand，就是作为一个去开发人员，你＆＃39;重申不应该关心。</p><p> You&#39;re not supposed to look at these things. Go is simple! Byte slices arestrings! Go has no pointer arithmetic! Who cares how large a type is!</p><p> 你＆＃39;重申不应该看这些东西。 Go很简单！字节切片arstrings！ Go没有指针算术！谁关心一种类型的态度！</p><p> Until you do care, and then, well, you&#39;re on your own. And &#34;using unsafe&#34; isexactly what being on your own here. But it&#39;s okay. We&#39;re all on our owntogether.</p><p> 直到你照顾，然后，嗯，你自己＆＃39;他们自己。和＃34;使用不安全＆＃34; isexactly在这里自行。但它＆＃39;好吧。我们＆＃39;所有这些都在我们的唯一。</p><p>  $ go run go/main.go2021/04/17 21:19:12 (in readIssue) nil? true, size = 82021/04/17 21:19:12 (in main) nil? false, size = 162021/04/17 21:19:12 fatal error: oh noexit status 1</p><p>  $ go运行go / main.go2021 / 04/17 21:19:12（在Readissue）nil？真实的，大小= 82021/04/17 21:19:12（主要）零？ FALSE，SIZE = 162021/04/17 21:19:12致命错误：OH Noxit状态1</p><p>  This is the kind of example that, given enough time, one could figure out thesolution all on their own. But when falling face to face with it, and when ithas been a while, it is... puzzling.</p><p>  这是一个示例，给出足够的时间，人们可以自己弄清楚自己的选择。但是当面对面坠落时，当伊萨已经有一段时间时，它就是......令人费解的。</p><p>    The zero value of a pointer is  nil, so it&#39;s equal to  nil. And we&#39;re (well,I&#39;m) on 64-bit Linux, so the size of a pointer is 64 bits, or 8 bytes.</p><p>    指针的零值为nil，所以它等于nil。和我们＆＃39;在64位Linux上（井，i＆＃39; m），因此指针的大小为64位或8个字节。 </p><p> If you&#39;re reading this from a machine whose byte isn&#39;t 8 bits, please,  please send a picture.</p><p>如果你＆＃39;从一台byte isn＆＃39; t 8位的机器读取这一点，请发一张照片。</p><p> The second line is a lot more surprising — not only does it not equal  nil,but, it&#39;s also twice as large.</p><p> 第二行更令人惊讶 - 不仅它不等于零，而且，它也是两倍的两倍。</p><p>  package main import (	 &#34;log&#34;) func  main() {	 var  err  error	 err  = ( * naughtyError)( nil)	 log. Printf( &#34;%v&#34;,  err)	 err  = ( * niceError)( nil)	 log. Printf( &#34;%v&#34;,  err)} type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;} type  niceError  struct{} func ( ne  * niceError)  Error()  string {	 return  &#34;ho ho ho!&#34;}</p><p>  包主要导入（＆＃34; log＆＃34;）func main（）{var err错误err =（* naugtyerror）（nil）日志。 printf（＆＃34;％v＆＃34; err）err =（* niceError）（nil）日志。 printf（＆＃34;％v＆＃34; err）} type naugtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob＆＃34;} type niceerror struct {} func（ne * niceError）错误（）字符串{返回＆＃34;何浩浩！＆＃34;}</p><p> What a nice holiday-themed error. We have two  nil values, and they bothprint different things!</p><p> 多么愉快的假期主题错误。我们有两个零价值观，他们涉现不同的东西！</p><p>    Because these values are are both  nil! But uhhh when acting as an interfacevalue (for the  error interface), they behave differently!</p><p>    因为这些值都是nil！但是，uhhh充当interfacevalue（对于错误界面），它们的行为方式不同！</p><p>  And so the size of an  error interface value is 16 bytes because... there&#39;stwo pointers!</p><p>  因此错误界面值的大小是16个字节，因为...有......＆＃39; stwo指针！</p><p>      To &#34;downcast&#34; it, ie. to go from the interface type, back to the concrete type:</p><p>      ＆＃34;悲伤和＃34;它，即。要从界面类型转到混凝土类型： </p><p> package main import (	 &#34;errors&#34;	 &#34;log&#34;) func  showType( err  error) {	 // 👇 downcasting action happens here	 if  _,  ok  :=  err.( * naughtyError);  ok {		 log. Printf( &#34;got a *naughtyError&#34;)	}  else  if  _,  ok  :=  err.( * niceError);  ok {		 log. Printf( &#34;got a *niceError&#34;)	}  else {		 log. Printf( &#34;got another kind of error&#34;)	}} func  main() {	 showType(( * naughtyError)( nil))	 showType(( * niceError)( nil))	 showType( errors. New( &#34;&#34;))} type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;} type  niceError  struct{} func ( ne  * niceError)  Error()  string {	 return  &#34;ho ho ho!&#34;}</p><p>包主要导入（＆＃34;错误＆＃34;＆＃34; log＆＃34;）func showtype（错误错误）{//👇越震惊的操作如果_，好的话：= err。（* naughtyerror）;好的{log。 printf（＆＃34;有一个* naugtyerror＆＃34;）}如果_，好的：= err。（* niceError）;好的{log。 printf（＆＃34;得到了一个* niceError＆＃34;）} else {log。 printf（＆＃34;得到了另一种错误＆＃34;）} func main（）{showtype（（* naugtyerror）（nil））showtype（（* niceError）（nil））showtype（错误。新（＆＃ 34;＆＃34;））} type naugtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob＆＃34;} type nicereror struct {} func（ne * niceError）错误（）字符串{返回＆＃34;何浩浩！＆＃34;}</p><p> $ go run go/main.go2021/04/17 21:33:48 got a *naughtyError2021/04/17 21:33:48 got a *niceError2021/04/17 21:33:48 got another kind of error</p><p> $ go / main.go2021 / 04/17 21:33:48 GOT a * naugtyerror2021 / 04/17 21:33:48 GOT A * NiceError2021 / 04/17 21:33:48得到了另一种错误</p><p> Ah, so mystery solved! One pointer for the value, one pointer for the type:8 bytes each, together, 16 bytes.</p><p> 啊，所以神秘解决了！一个指针的值，一个指针为类型：8个字节，每个，一起，16个字节。</p><p>        But... there is also a standard error type. Except in Rust, capitalizationdoes not mean &#34;private or public&#34; (there&#39;s a keyword for that). Instead, all types are capitalized, by convention, so it&#39;s not  error, it&#39;s Error.</p><p>        但是......还有一个标准错误类型。除了生锈，资本化并非意味着＆＃34;私人或公共和＃34; （那里有关键字）。相反，所有类型的所有类型都是大写的，所以它＆＃39; s不是错误，它＆＃39; s错误。</p><p>   // 👇 we import it here use std ::error ::Error ; fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // and use it there 👇 fn  read_issue ( ) -&gt;  Result &lt; String,  Error &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p>   //👇我们在这里导入它使用std ::错误::错误; fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //并使用它👇fn read_issue（） - ＆gt;结果＆lt;字符串，错误＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p>  $ cargo run --quietwarning: trait objects without an explicit `dyn` are deprecated --&gt; src/main.rs:7:35 |7 | fn read_issue() -&gt; Result&lt;String, Error&gt; { | ^^^^^ help: use `dyn`: `dyn Error` | = note: `#[warn(bare_trait_objects)]` on by default(rest omitted)</p><p>  $货物跑步 -  Quietwarning：没有明确的“dyn`的特质物品被贬值 - ＆gt; src / main.rs：7：35 | 7 | fn read_issue（） - ＆gt;结果＆lt;字符串，错误＆gt; {| ^^^^^^帮助：使用`dyn`：`dyn错误` =注意：`＃[warn（baren_trait_objects）]`默认情况下（省略休息）</p><p> Oh, no, a warning! It says to use the  dyn keyword. Alright, who am Ito object, let&#39;s use the  dyn keyword.</p><p> 哦，不，警告！它说要使用dyn关键字。好吧，谁是ITO对象，让＆＃39; s使用dyn关键字。 </p><p>   $ cargo run --quieterror[E0277]: the size for values of type `(dyn std::error::Error + &#39;static)` cannot be known at compilation time --&gt; src/main.rs:7:20 |7 | fn read_issue() -&gt; Result&lt;String, dyn Error&gt; { | ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn&#39;t have a size known at compile-time | ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:241:20 |241 | pub enum Result&lt;T, E&gt; { | - required by this bound in `std::result::Result` | = help: the trait `Sized` is not implemented for `(dyn std::error::Error + &#39;static)`error: aborting due to previous error</p><p>$ Cargo Run --quieterror [E0277]：类型的大小为`（Dyn STD ::错误:: error +＆＃39;静态）`不能在编译时已知 - ＆gt; src / main.rs：7：20 | 7 | fn read_issue（） - ＆gt;结果＆lt;字符串，dyn error＆gt; {| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^ ^^＆＃39; t在编译时已知尺寸| ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:241:20 | 241 | PUB枚举结果＆lt; t，e> {| - 在“STD ::”结果::结果：结果界定的界限= help：trait`大小`未实现`（dyn std :: serrer :: serror +＆＃39;静态）`错误：由于上一个错误而中止</p><p>       use std ::error ::Error ; fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // 👇 fn  read_issue ( ) -&gt;  Result &lt; String,  Box &lt; dyn  Error &gt; &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p>       使用std ::错误::错误; fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //👇fn read_issue（） - ＆gt;结果＆lt;字符串，框＆lt; Dyn错误＆gt; ＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p>  $ cargo run --quieterror[E0308]: mismatched types --&gt; src/main.rs:8:5 |7 | fn read_issue() -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; { | ------------------------------ expected `std::result::Result&lt;String, Box&lt;(dyn std::error::Error + &#39;static)&gt;&gt;` because of return type8 | std::fs::read_to_string(&#34;/etc/issue&#34;) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Box`, found struct `std::io::Error` | = note: expected enum `std::result::Result&lt;_, Box&lt;(dyn std::error::Error + &#39;static)&gt;&gt;` found enum `std::result::Result&lt;_, std::io::Error&gt;`error: aborting due to previous error</p><p>  $货物运行 -  quieterror [e0308]：无匹配类型 - ＆gt; src / main.rs：8：5 | 7 | fn read_issue（） - ＆gt;结果＆lt;串，框＆lt; dyn＆gt;＆gt; {| ---------------------------------结果::结果＆lt;串，框＆lt; :: errat +＆＃39;静态）＆gt;＆gt;“因为返回type8 | std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^预计struct`box`，找到struct` std :: io ::错误'| =注意：预期enum`STD ::结果::结果＆lt; _，box＆lt;（dyn std :: serr :: error +＆＃39;静态）＆gt;＆gt;`找到enum` std ::结果::结果＆lt; _，std :: io ::错误＆gt;`错误：由于上一个错误而中止</p><p>    Theeeeeeere we go. Now we&#39;re even. This is the closest we&#39;ll get to theaforementioned Go code.</p><p>    我们走了。现在我们甚至是re。这是最接近的我们＆＃39; ll到来的守则。</p><p>   Well, for the time being, you can sort of think about it as a pointer.</p><p>   好吧，暂时，你可以对它作为指针进行思考。</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ptr:  * const  MyError =  &amp;e ;  print_error (e_ptr ) ;} fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ptr：* const myError =＆amp; e; print_error（e_ptr）;} fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }}</p><p>   fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  // 👇  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{//👇println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }} </p><p> Why is dereferencing a pointer  unsafe? Well, because it might be null! Orit might point to an address that does not fall within an area that&#39;smeaningful for the currently running program, and that would cause asegmentation fault.</p><p>为什么取消引用指针不安全？好吧，因为它可能是空！ ORIT可能指向没有落在一个区域内的地址;对于当前正在运行的程序而言，它会导致ASEGING FOURT。</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ptr:  * const  MyError =  &amp;e ;  // 👇 no unsafe!  dbg ! (std::mem::size_of_val (&amp;e_ptr ) ) ;  print_error (e_ptr ) ;} fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ptr：* const myError =＆amp; e; //👇没有不安全！ DBG！ （std :: mem :: size_of_val（＆amp; e_ptr））; print_error（e_ptr）;} fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }}</p><p>  And, as expected, the size of a pointer is 8 bytes, because I&#39;m  stillwriting this from Linux 64-bit.</p><p>  并且，正如所预期的那样，指针的大小是8字节，因为我＆＃39; m instwriting从linux 64位。</p><p> But: if constructing a pointer value is safe, dereferencing it (reading fromthe memory it points to, or writing to it) is not.</p><p> 但是：如果构建指针值是安全的，请解释它（从它指向的内存读取或写入它）不是。</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ref:  &amp; MyError =  &amp;e ;  dbg ! (std::mem::size_of_val (&amp;e_ref ) ) ;  print_error (e_ref ) ;} fn  print_error ( e:  &amp; MyError ) {  println ! ( &#34;MyError (value = {})&#34;,  (*e ).value ) ;}</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ref：＆amp; myerror =＆amp; e; DBG！ （std :: mem :: size_of_val（＆amp; e_ref））; print_error（e_ref）;} fn print_error（e：＆amp; myError）{println！ （＆＃34; myError（value = {}）＆＃34;（* e）.value）;}</p><p>   ...but they&#39;re also perfectly safe to dereference, because it is guaranteedthat they point to valid memory: in safe code, it is impossible to constructan invalid reference, or to keep a reference to some value after that valuehas been freed.</p><p>   ......但它们也非常安全地对解除引用，因为它可以保证它们指向有效内存：在安全的代码中，无法构建无效的参考，或者在释放估值后保持参考一些值。</p><p> In fact, it&#39;s  so safe that we don&#39;t even need to use the  * operator todereference: we can just rely on &#34;autoderef&#34;:</p><p> 事实上，它如此安全，我们甚至需要使用*运营商才能使用：我们可以依靠＆＃34; autoderef＆＃34 ;: </p><p>   And now, a quick note about safety: you&#39;ll notice that I just said &#34; insafe code, it is impossible to construct an invalid reference&#34;.</p><p>现在，关于安全的快速记录：你＆＃39;请注意，我只是说＆＃34; Insafe代码，无法构建无效的参考文献＆＃34;</p><p>  struct  MyError {  value:  u32,} fn  main ( ) {  let e:  * const  MyError = std ::ptr :: null ( ) ;  // ooooh no no no. crimes! 👇  let e_ref:  &amp; MyError =  unsafe {  &amp; *e } ;  dbg ! (std::mem::size_of_val (&amp;e_ref ) ) ;  print_error (e_ref ) ;} fn  print_error ( e:  &amp; MyError ) {  println ! ( &#34;MyError (value = {})&#34;, e.value ) ;}</p><p>  struct myerror {value：u32，} fn main（）{让e：* const myError = std :: ptr :: null（）; // ooooh否否。犯罪！ 👇让e_ref：＆amp; myerror =不安全{＆amp; * e}; DBG！ （std :: mem :: size_of_val（＆amp; e_ref））; print_error（e_ref）;} fn print_error（e：＆amp; myError）{println！ （＆＃34; myError（value = {}）＆＃34;，e.value）;}</p><p>      The idea is that,  if all the unsafe code is sound, then all the safe codeis safe, too.</p><p>      这个想法是，如果所有不安全的代码都是声音，那么所有安全的码头都安全。</p><p> And you have a lot less &#34;unsafe&#34; code than you have &#34;safe&#34; code, which makesit a lot easier to audit. It&#39;s also very visible, with explicit  unsafeblocks,  unsafe traits and  unsafe functions, and so it&#39;s easy to statically determine where unsafe codeis — it&#39;s not just &#34;woops you importedthe forbidden package&#34;.</p><p> 而且你有很多少量＆＃34;不安全＆＃34;代码比你＆＃34;安全＆＃34;代码，这使得审计更容易。它也是非常可见的，具有明确的不安全块，不安全的特征和不安全的函数，所以它＆＃39;很容易静态地确定不安全的码头 - 它＆＃39; s不只是＆＃34;你进口禁止包＆＃34;你进口禁止包＆＃34 ＃34;</p><p> Finally, there&#39;s tools like the  Miriinterpreter, that help with unsafe code,just like there&#39;s sanitizers for C/C++, which do not have that safe/unsafesplit.</p><p> 最后，在那里的工具如miri interpreter，那就帮助了不安全的代码，就像那里的c / c ++的消毒者那里，没有那些安全/ unsafeplit。</p><p>  So, we&#39;ve seen two kinds of &#34;pointers&#34; in Rust so far: raw pointers, aka *const T (and its sibling,  *mut T), and references ( &amp;T and  &amp;mut T).</p><p>  所以，我们看到两种＆＃34;指针＆＃34;到目前为止，迄今为止：原始指针，AKA * const t（及其兄弟姐妹，* mut t）和参考（＆amp; t和＆amp; mut t）。</p><p>  In Go, when you get a pointer to an object, you can do anything with it. Youcan hold onto it as long as you want, you can shove it into a  map — even ifthat object was originally going to be freed, you, as a function thatreceives a pointer to that object, can extend the lifetim</p><p>  在Go，当您对对象的指针时，可以使用它。 YouCan只要你想要，你就可以把它推到地图上 - 即使是最初是释放的，你也是，你作为一个函数，你可以伸出一个指向该对象的指针，可以扩展寿命 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/whats-in-the-box">https://fasterthanli.me/articles/whats-in-the-box</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/盒子/">#盒子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/box/">#box</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>