<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PIN和痛苦 - 异步防锈教程 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PIN和痛苦 - 异步防锈教程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 01:19:29</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/3/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我想认为我对＆＃34的理解;异步生锈＆＃34;过去一年左右增加了。我＆＃39; m 100％船上的基本原理：我会觉得使用少数线程处理数千个并发任务。听起来不错！</p><p> 并变得精通异步生锈，我接受了很多东西。蓝色功能和重新碰交，红色（异步）功能具有传染性。</p><p> EH，并非完全 - 您可以在蓝色（同步）函数toblock中构建执行者，直到完成红色（异步）函数。</p><p>  我猜困难是当你从红色到蓝色时，回到红色 - 因为你可以在executer内制作一个执行者。</p><p> 看熊，这就是我谈论的是什么：在那里＆＃39;我这么多，我必须得到批准。 ＆＃34; Don＆＃39; t阻止了执行者＆＃34 ;,＆＃34;未来任何人都无所作为，除非轮询＆＃34;，＆＃34;您需要在轮询它之前固定未来＆＃34;</p><p>  但熊，一切都是如此简单的同步生锈，突然间我忍受了所有这些规则？我必须考虑这些？</p><p> 在这里让我告诉你。说，在同步生锈，我只想打印你好，睡觉，然后打印再见。 </p><p>什么？我没有看到任何堵塞。实际上，它表现得完全是同步版本。对我来说似乎没关系。</p><p>   使用std :: {thread ::睡眠，时间::持续时间}; ＃[tokio :: main] async fn main（）{让一个= tokio :: spawn（hold（））;让两个= tokio :: spawn（hold（））;让（_，_）= tokio ::加入！ （一，两个）;} async fn hell（）{println！ （＆＃34;你好！＆＃34;）;睡眠（持续时间:: from_millis（500））; println！ （＆＃34;再见！＆＃34;）;}</p><p>  那里！它只是有效！谢谢熊，我不知道我抱怨的是什么，异步生锈真的很容易。</p><p>  什么？哦，哦，等一下，我看到了它，我可以刚刚将味道论证传递给tokio :: main属性宏：</p><p> //👇＃[tokio :: main（风味=＆＃34; current_thread＆＃34;）] async fn main（）{let一个= tokio :: spawn（hold（））;让两个= tokio :: spawn（hold（））;让（_，_）= tokio ::加入！ （一，两）;} //省略：其他一切</p><p>   所以我们阻止了执行者。但是，看，＆＃39;他们的复杂性，我不得不思考一切！</p><p> 对我来说，睡觉只是一个syscall.你打电话给它和繁荣！它睡觉了。无需担心任何事情。 </p><p>使用STD ::时间::持续时间;使用tokio ::时间::睡眠; ＃[tokio :: main（风味=＆＃34; current_thread＆＃34;）] async fn main（）{let一个= tokio :: spawn（hold（））;让两个= tokio :: spawn（hold（））;让（_，_）= tokio ::加入！ （一，两个）;} async fn hell（）{println！ （＆＃34;你好！＆＃34;）;睡眠（持续时间:: from_millis（500））.await; println！ （＆＃34;再见！＆＃34;）;}</p><p>   但是，看到熊，我不知道这一切的作品。它＆＃39; s都只是伏都教给我.One函数阻止了执行者，另一个并不是为什么？在引擎盖下它真的是如何建立的？</p><p>   虽然Tokio的睡眠返回了未来......这将在第一次轮询它时注册一个计时器......只达到截止日期时它只完成。</p><p> 我呃......没有任何意义。我不记得＆＃34;轮询＆＃34;任何事物。和你说它...＆＃34;寄存器＆＃34;计时器？如同，全球州？你的意思是什么＆＃34;完成＆＃34 ;?</p><p>      是的，为什么不，如果它可以在整个事情上脱掉一些光线，我会弄清楚未来。</p><p> 所以我想自＆＃39;是一个特征......我知道特质。我们可以在any型式中实施它？像空的结构？</p><p>   好的，编译器抱怨，并非所有特征项目都已实施：itwants产出和民意调查。现在怎么办？ </p><p>MyFuture {型输出; FN民意调查（SEC：STD :: PIN :: PIN＆lt;＆amp; ul self＆gt;，cx：＆amp; mut std :: task :: task :: task :: task＆lt;＆gt;＆gt; std ::任务::民意调查＆lt; self ::输出＆gt; {  去做 ！ （）}}</p><p>   使用STD :: {未来::未来，PIN :: PIN，任务:: {上下文，轮询}，}; struct myfuture {} ill ich将来{型输出; FN民意调查（Self：Pin＆lt;＆lt; um self＆gt;，cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {  去做 ！ （）}}</p><p>  好吧，首先，您需要选择您的输出类型。你想要你的未来，嗯，产出吗？</p><p>   ich将来为myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt; um self＆gt;，cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {  去做 ！ （）}}</p><p>        $货物运行--quietthread＆＃39; main＆＃39;恐慌AT＆＃39;尚未实施＆＃39;，SRC / MAIN。 RS：19：9：使用“rust_backtrace = 1`环境变量来显示回溯运行</p><p>     $ rust_backtrace = 1个货运run -quietthread＆＃39;主要＆＃39; and＃39;尚未实施，尚未实施。 ：恐慌:: panic_fmt在/rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14 2：核心::恐慌::惊慌/rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:50 ：5 3：＆lt; manual_futures :: myfuture作为核心::未来::未来:: future＆gt; ::民意调查at ./src/main.rs:19：9 4：manual_futures :: main :: {{closure}}在./src/main.rs:10:5 5：＆lt;核心::未来:: from_generator :: genfuture＆lt; t＆gt;作为核心::未来::未来::未来和gt; ::民意调查/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/未来/ mod.rs：80：19 6：＆lt;核心:: pin :: pin＆lt; p＆gt;作为核心::未来::未来::未来和gt; ::民意调查/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/未来/未来.rs：119：9 7：tokio :: runtime :: basic_scheduler ::内部＆lt; p＆gt; :: block_on :: {{closure}} :: {{closure}}在/home/amos/.cargo/注册表/ src / github.com-1ECC6299DB9EC823 / TOKIO-1.4.0 / SRC / RUNTETE / BASIC_SCHEDULER.RS：196：62 8：TOKIO :: COOP :: _BUDGET :: {{closure}}在/ home / amos /。 CARGO / REGINGRY / SRC / GITHUB.COM-1ECC6299DB9EC823 / TOKIO-1.4.0 / SRC / COOP.RS：106：9 9：STD :: Thread :: local :: localKey＆lt; t＆gt; :: try_with在/ home / amos /.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:272:16 10：std :: thread :: local :: localkey＆lt; t＆gt; ::在/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustib/src/rust/library/std/src/thread/local.rs:248： 9 11：tokio :: coop :: with_budget在/home/amos/.cargo/registry/src/github.com-1cc6299db9ec823/tokio-1.4.0/src/coop.rs:99:5 12：tokio :: coop :: /家庭预算/amos/.cargo/registry/src/github.com-1c6299db9ec823/tokio-1.4.0/src/coop.rs:76:5 13：tokio :: runtime :: basic_scheduler ::内部＆lt; p＆gt; :: block_on： ：{{closure}}在/home/amos/.cargo/registry/src/github.com-1c6299db9ec823/tokio-1.4.0/src/runtime/basic_scheduler.rs:196:39 14：tokio ::运行时:: basic_scheduler ::输入:: {{closure}}在/home/amos/.cargo/registry/src/github.com-1cc6299db9ec823/tokio-1.4.0/src/runtime/basic_scheduler.rs:279:29 15：tokio ::宏:: scoped_tls :: scopedkey＆lt; t＆gt; ::坐在/home/amos/.cargo/registry/src/github.com-1c6299db9ec823/tokio-1.4.0/src/macros/scoped_tls.rs:61： 9 16：tokio ::运行时:: basic_scheduler ::在/home/amos/.cargo/registry/src/github.com-1c6299db9ec823/tc/.4.0/src/runtime/basic_scheduler.rs:279:5 17 ：tokio :: runtime :: basic_scheduler ::内部＆lt; p＆gt; :: block_on在/home/amos/.cargo/registry/src/github.com-1c6299db9ec823/tokio-1.4.0/src/runtime/basic_scheduler.rs： 185：9 18：tokio :: runtime :: basic_scheduler :: connguard＆lt; p＆gt; :: block_on在/ home / Amos / .cargo / registry / src / github.com-1ECC6299DB9EC823 / TOKIO-1.4.0 / SRC / RUNTETE / BASIC_SCHEDULER.RS：425：9 19：TOKIO :: Runtime :: Basic_scheduler :: Basicscheduler＆lt; p＆gt; p＆gt; :: block_on在/home/amos/.cargo/registry/src/github.com-1cc6299db9ec823/tokio-1.4.0/src/runtime/basic_scheduler.rs:145:24 20：tokio :: runtime ::运行时:: block_on at /主页/ amos / .cargo / registry / src / github.com-1ECC6299DB9EC823 / TOKIO-1.4.0 / SRC / RUNTIME / MOD.RS：450：46 21：MANUAL_FUTURES :: MAIN AT ./src/main.rs:7 ：1 22：核心:: ops ::函数:: fnonce :: call_once在/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/ src / ops / function.rs：227：5？省略了一些细节，使用`rust_backtrace = full`进行详细回溯运行。</p><p>       fn main（）{let rt = tokio ::运行时:: builder :: new_current_thread（）。建造 （ ）  。 unwrap（）;让FUT = myfuture {}; RT。 block_on（fut）;} </p><p>好的，好的，好吧，我真的想建立一个运行时自己，我＆＃39; m feedwith tokio :: main版本现在。</p><p>  好吧，回来！你可以看到它＆＃39应该返回一个轮询，这是一个有两个变体的枚举。</p><p> ..我假设我们在未来完成时返回，好吧。所以，如果我这样做：</p><p> 使用STD :: {未来::未来，PIN :: PIN，任务:: {上下文，轮询}，}; ＃[tokio :: main] async fn main（）{让fut = myfuture {}; println！ （＆＃34;等待Fut ...＆＃34;）; FUT .aiawait; println！ （＆＃34;等待Fut ......完成！＆＃34;）;} struct myfuture {} iclilcure for myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt;＆lt;＆lt; um＆gt;，_cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {//👇轮询::就绪（（））}}</p><p>   正确的！而另一个变体是待处理的，如果yourfuture尚未完整，您应该返回。</p><p>    ich将来为myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt;＆lt;＆lt; um＆gt;，_cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {//👇轮询:: pending}}</p><p>   不好了。它没有被阻止＆＃39;嗯，实际的，生成的同步主功能被封锁在异步主要和＃39;未来 - 它＆＃39; s等待完成，它从未完成。 </p><p>所以它＆＃39;没有再次被调查？但是你刚刚告诉我..挂断，让Metjust添加一些调试打印：</p><p> ich将来为myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt;＆lt;＆lt; um＆gt;，_cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {//👇println！ （＆＃34; myfuture :: poll（）＆＃34;）;民意调查:: pending}}</p><p>  是的！它＆＃39;唯一的被调查一次！什么给予，熊？我以为你告诉我会再次受到调查吗？</p><p> 啊，它只会再次被调查再次被调查。 Didyou认为它会在循环中调查吗？想象一下，如果你尝试读取套接字，另一个对等体没有发送五秒钟。</p><p> 阅读未来将被轮询和调查并在繁忙的循环中轮询并轮询了Fiveseconds。它会消耗整个CPU核心！不，期货只是＆＃34;唤醒＆＃34;什么时候发生了什么。</p><p>  有趣的事情！喜欢，一个计时器耗尽。或者已准备好的文件。那种东西。</p><p> 啊。那种东西。好的，所以说我希望我的未来成为＆＃34;唤醒＆＃34;在第二个。我该怎么做？ </p><p>啊，右 - 轮询方法采用两个参数。接收器是......某种形式的自我，所以，myfuture，第二个论点是一个＆amp; mut背景。</p><p> 让＆＃39; s看它有什么......它有...返回A＆amp的Waker（）方法;歌剧！看起来很有趣。</p><p>  和威克有...唤醒和唤醒_by_ref方法。好吧，我们可以＆＃39; t叫醒唤醒，因为它想要掌握威克，我们所有的所有权都是一个不可改变的参考。</p><p>  ich将来为myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt; um self＆gt;，cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）; CX。 Waker（）。 key_by_ref（）;民意调查:: pending}}</p><p> $ Cargo run -quietawaiting fut ... myfuture :: poll（）myfuture :: poll（）myfuture :: poll（）myfuture :: poll（）myfuture :: poll（）myfuture :: poll（）myfuture :: poll（）轮询（）myfutur ^ c（那行很快重复，只有在我们点击Ctrl-c时停止）</p><p> heyyyy。现在它是一个忙碌的循环！它尽可能快地被调查。</p><p>  但那＆＃39;仍然不是我想要的。我想要的是......为了我的未来在一秒钟后再次遭到攻击。 </p><p>所以？？？只需使用帖子！你只是继续介绍如何轻松的线程，而且你明白他们，这位布拉拉布拉。只需使用一个线程。</p><p> 但我只参考歌诈，我可以＆＃39;哦，你会看到它，它可以实现克隆。好的。好的。我猜我＆＃39; ll刚刚产卵。</p><p> ich将来为myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt; um self＆gt;，cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;让Waker = CX。 Waker（）。克隆（）; std :: thread :: spawn（move || {std :: thread :: sleep（持续时间:: from_secs（1））;摇摆。唤醒（）;}）;民意调查:: pending}}</p><p>  啊啊！有趣的。好吧，最终我猜我想回来准备好，所以一切都是保持一些状态，让＆＃39; s看...</p><p> ＃[tokio :: main] async fn main（）{让fut = myfuture :: new（）; println！ （＆＃34;等待Fut ...＆＃34;）; FUT .aiawait; println！ （＆＃34;等待Fut ......完成！＆＃34;）; struct myfuture {slept：bool，} iclich myfuture {fn new（） - ＆gt; self {self {slept：false}}} illicure for myfuture {type output =（）; FN民意调查（Self：Pin＆lt;＆lt; um self＆gt;，cx：＆amp; mut语调＆lt; 39; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;匹配自我。睡觉{false =＆gt; {//确保我们在一秒钟内再次轮询，让Waker = CX。 Waker（）。克隆（）; std :: thread :: spawn（move || {std :: thread :: sleep（持续时间:: from_secs（1））;摇摆。唤醒（）;}）;自己 。睡觉=真;民意调查::待处理} true =＆gt; POLL ::就绪（（）），}}}}</p><p> 不，等待 - 它抱怨自己是不可变形的。呃......我可以写它，如果那个＆＃39; d verv？</p><p> ich将来为myfuture {type output =（）; //👇FN轮询（MUT SELF：PIN＆LT; um self＆gt;，cx：＆amp; mum; mul nut nully＆lt;＆gt;） - ＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {  // ETC。 }} </p><p>它真的是＆＃39; t。嘿等一分钟。我们＆＃39;重新返回使用线程，有点。</p><p> 我不想每次想要等待时旋转一个新的线程。似乎过度过度。肯定的Async rust™有一些东西可以解决这个问题吗？</p><p>   是的，是的，那个我们使用的东西。但我们可以在Myfuture内嵌入它，豆腐仍然可以看到机器。</p><p>   啊啊！所以，如果我只是将其存储为myfuture的领域，我必须做的是ispoll它，从我自己的民意调查方法中？</p><p>  使用tokio ::时间::睡眠; struct myfuture {睡眠：睡眠，} iclich myfuture {fn new（） - ＆gt; self {self {leep：tokio ::时间::睡眠（持续时间:: from_secs（1）），}}}} islicure for myfuture {type输出=（）; FN民意调查（MUT SELF：PIN＆lt;＆lt; um self＆gt;，cx：＆amp; mum; mul nut语言＆lt; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;自己 。睡觉 。民意调查（CX）}}</p><p> 啊，太棒了！它甚至具有与MyFuture ::民意调查民意调查结果相同的精确返回类型</p><p>  $货物检查检查手册 - 期货V0.1.0（/ home / amos / ftl /手动期货）错误[e0599]：没有命名为struct`睡眠状态的poll`的方法 - ＆gt; SRC / MAIN.RS：35：20 | 35 | self.sleep.poll（cx）| ^^^^在`sleep`error中找不到的方法：由于此错误的更多信息，尝试使用前一个错误，请尝试使用“rustc  -  explain e0599`.Error：无法编译”手册期货“以了解更多信息，运行命令再次与 - 鼠标。 </p><p>哦！我知道！民意调查是特征未来的方法，所以我需要将其导入能够调用它...等待不，我们已经导入了它。</p><p>  看看接收者！它＆＃39; s不是自我，它＆＃39; s not＆＃39; self，它＆＃39; s不是甚至＆amp; mut self。</p><p> m好的。我们如何构建PIN ...它有一种新方法。让＆＃39;试试。</p><p> ich将来为myfuture {type output =（）; FN民意调查（MUT SELF：PIN＆lt;＆lt; um self＆gt;，cx：＆amp; mum; mul nut语言＆lt; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）; //👇让mut sleep = pin :: new（＆amp; mut self。睡觉）;睡觉 。民意调查（CX）}}</p><p> $ Cargo Check检查手册 - 期货V0.1.0（/ home / amos / ftl /手动期货）错误[e0277]：`phantompinned`不能卸载 - ＆gt; src / main.rs：35：25 | 35 |让mut睡眠= Pin :: new（＆amp; mut self.sleep）; | ^^^^^^^ ^^在`tokio ::时间:: drive ::睡眠:: _ :: __ orize＆＃39; _＆gt;`，特质`unpin`没有为`phantompinned`而实施=注意：所需的是因为它出现在“tokio ::时间:: driver :: strider :: stry :: timerentry` =注意：所需的：它出现在类型”tokio :: time :: drive :: sleep :: _：_：_： ：__原点＆lt;＆＃39; _＆gt;`=注意：所需的：由于“睡眠”\ notel的icric icric的要求：PIN ::＆lt; p＆gt; :: new`</p><p>     呃，好的......返回销＆lt;框＆lt;睡眠＆gt;＆gt;所以我猜我也必须改变菲尔德类型......</p><p> struct myfuture {睡眠：引脚＆lt;盒子＆lt;睡觉＆gt; ＆gt;，} islich myfuture {fn new（） - ＆gt; self {self {sleep：box :: pin（tokio ::时间::睡眠（休眠时间:: from_secs（1））），}} iscrame for myfuture {type output =（）; FN民意调查（MUT SELF：PIN＆lt;＆lt; um self＆gt;，cx：＆amp; mum; mul nut语言＆lt; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;让睡眠=针:: new（＆amp; mut self。睡觉）;睡觉 。民意调查（CX）}} </p><p>是的！而且你诚实地不要自己建造那个针，因为引脚＆lt;盒子＆gt;＆gt;已经固定 - 所以你＆＃39;重新建立销＆lt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;。</p><p> ich将来为myfuture {type output =（）; FN民意调查（MUT SELF：PIN＆lt;＆lt; um self＆gt;，cx：＆amp; mum; mul nut语言＆lt; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;自己 。睡觉 。 AS_MUT（）。民意调查（CX）}}</p><p>  您甚至可以进一步逐步并添加期货箱，以便您可以使用Futureext :: Poll_Unpin，因为轮询了取消投票的未来是一个公平的操作。</p><p>   使用期货:: futureext; ich将来为myfuture {type output =（）; FN民意调查（MUT SELF：PIN＆lt;＆lt; um self＆gt;，cx：＆amp; mum; mul nut语言＆lt; _＆gt;） - ＆gt;民意调查＆lt; self ::输出＆gt; {println！ （＆＃34; myfuture :: poll（）＆＃34;）;自己 。睡觉 。 poll_unpin（cx）}}}</p><p>  在这一点，我可以＆＃39; t帮助但是奇迹 - 我们真的需要tounderstand吗？喜欢，它＆＃39;我们整洁，我们曾经做过，不要给我错了。</p><p> 但在现实世界中，有一点在手动实施未来？ Don＆＃39; t我们有异步/ await关键字，以便我们不要＆＃39; t haveTo？</p><p> 好吧！在这种情况下，是的，它的无偿。但是，我们说我们想用不同的东西...... </p><p>让＆＃39; s表示我们想要制作一种实现Tokio＆＃39; sasyncreadInterface的类型（这样我们可以在任何地方使用另一个读者的地方），但是在每个读取之间人为地引入一些延迟。</p><p>  你＆＃39; D Than Thel这样的，但没有。不是现在。看，异步锈病仍处于其批评的少年。几乎一切都在那里，但它可以有点achale居住。</p><p>  嗯，asyncread是一种特质。和特质可以＆＃39; t具有异步方法。 （在这个写作的TheTime，即。用生锈1.51）。</p><p>  对，是的，但是！我们始终读成某事。缓冲区。当我们这样做时，异步土地：</p><p> ......如果我们＆＃39，我们早期返回;还没有准备好。我们只是回到轮询::等待，等待我们＆＃39; requateder唤醒了。 Ohhhhh Andjust，因为我们返回并不意味着我们与缓冲区完成了！</p><p> 所以它不是如何诅咒工作的。它确实给你一个缓冲区，但是你＆＃39;重新调整到任一个：</p><p> 准备好，然后你填充部分（或全部）缓冲区，并回到轮询::准备好 </p><p>Gotcha。 好的，所以，我们知道如何通过调查睡眠未来来睡觉，我认为我们足够了解我们一个缓慢的读者......  它将成为一个结构（它＆＃39;总是一个结构），它和＃39; ll与Anyki一起工作  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/pin-and-suffering">https://fasterthanli.me/articles/pin-and-suffering</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pin/">#pin</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/suffering/">#suffering</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/未来/">#未来</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1049531.html"><img src="http://img2.diglog.com/img/2021/2/thumb_12cb7c4c9cc3718f7e348cc71911a02e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1049531.html">Rust中的宏：带有示例的教程 </a></div><span class="my_story_list_date">2021-2-26 7:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1047027.html"><img src="http://img2.diglog.com/img/2021/1/thumb_496bc0e2ec586adbd0a003eb06927c0d.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1047027.html">构建您自己的X，一系列教程（搜索引擎，Neural Net等） </a></div><span class="my_story_list_date">2021-1-31 12:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041117.html"><img src="http://img2.diglog.com/img/2020/12/thumb_1ffe08f1f1b66c5527785109651bdc59.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041117.html">每个编程教程[视频] </a></div><span class="my_story_list_date">2020-12-22 4:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038248.html"><img src="http://img2.diglog.com/img/2020/12/thumb_e8752c43638017a9a725f38f2fe08d5a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038248.html">现代JavaScript教程 </a></div><span class="my_story_list_date">2020-12-8 0:39</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>