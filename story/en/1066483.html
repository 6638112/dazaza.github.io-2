<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>io_uring不是一个事件系统 Io_uring is not an event system</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Io_uring is not an event system<br/>io_uring不是一个事件系统 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-17 23:28:13</div><div class="page_narrow text-break page_content"><p>I’ve been hearing about  io_uring on and off for the last couple of years. Its a relatively new technology in Linux to allow high-performance IO with very few overheads.</p><p>在过去的几年里，我一直在听到IO_调节。它是Linux中相对较新的技术，以允许高性能的IO具有很少的开销。</p><p> Whenever its been mentioned, its usually been presented as a new alternative to  select,  poll and  epoll. This led me to believe that it was just the next iteration of those facilities, which is to say, another facility to inform a program that something has happened on a file or network socket or whatever, so that it can take action. In other words, and incremental improvement, presumably with fewer overheads, but otherwise just more of the same. Which is great, but boring for me: I understand the concept well, but these days I run other peoples&#39; software and don’t really write my own, so I haven’t cared too much about the finer details.</p><p> 每当被提及时，它通常被呈现为选择，民意调查和威拓的新替代方案。这让我相信它只是那些设施的下一次迭代，这就是告知一个程序发生在文件或网络套接字或其他内容的程序中的另一个设施，以便它可以采取行动。换句话说，递增的改进，大概是较少的开销，但否则更多的是。哪个很好，但对我来说无聊：我很了解这个概念，但这些天我跑了其他人和＃39;软件，并不真正写自己，所以我没有太多关心更精细的细节。</p><p> Then last week I was watching Brendan Gregg’s LISA21 talk “ Computing Performance: On The Horizon”, and this slide caught my eye:</p><p> 然后上周我正在观看Brendan Gregg的Lisa21谈话“计算性能：在地平线上”，这张滑块引起了我的注意：</p><p>    I don’t know if it was the promise of “faster syscalls” or the diagram, but something told me there was more to io_uring than I realised. I didn’t know what, but enough that I thought I figured I should try it out.</p><p>    我不知道这是“更快的Syscalls”或图表的承诺，但有些东西告诉我，我意识到的是我的意识。我不知道是什么，但我以为我认为我应该尝试一下。</p><p> Thinkng it was a new kind of descriptor readiness facility, I thought to just write a dumb multiuser telnet chat server. This kind of program was bread-and-butter for me once, long ago - writing MUD-like chat servers was where I got my start learning C, UNIX and network programming. As it turns out though, that was too long ago, and most of the interesting information had fallen out of my head.</p><p> Thinkng它是一种新的描述符读取性设施，我想只是写一个愚蠢的多用户Telnet聊天服务器。这种程序是对我来说的曾经是面包和黄油一次，很久以前 - 写作泥浆聊天服务器是我开始学习C，UNIX和网络编程的地方。事实证明，这还有很久以前，大多数有趣的信息都脱离了我的头脑。</p><p> So, I devised  yoctochat: a sort of shape for the simplest possible chat server, implemented multiple times using a different descriptor readiness facility each time. I started with  one for  select, then  one for  poll. The  epoll version tool a little longer because I’d never used it before, but since its more of the same, the shape was basically the same.</p><p> 因此，我设计了yoctochat：最简单的聊天服务器的一种形状，每次使用不同的描述符读取性设施多次实现。我开始选择一个，然后是一个投票。 EPOLS版本工具一点时间更长，因为我以前从未使用过，但是因为它更多的是，形状基本相同。</p><p> With those out of the way, and a clea runderstanding of what these programs are, even are, a couple of days ago I started on   yc_uring.c. After a few abortive starts I started to get a feel for things and it began to take shape. Later, I stopped to do some house chores and was thinking about the shape of the program I was building, and it hit me:</p><p> 随着那些脱离的人，即使是几天，我甚至是yc_uration.c，即使是那些这些计划的人，也是一个人的统一。几次失败后，我开始感受到事物，它开始形成。后来，我停下来做一些房子琐事，正在考虑我建造的程序的形状，它打了我： </p><p> io_uring is not an event system at all. io_uring is actually a generic asynchronous syscall facility.</p><p>IO_调节根本不是一个事件系统。 io_uring实际上是一般的异步Syscall设施。</p><p>  The classic UNIX IO syscalls (eg  read()) are all synchronous, and blocking. You call them, and your program goes to sleep until the thing you requested occurs. In the case of  read(), that’s “data arrived”.</p><p>  Classic UNIX IO SYSCALL（例如，read（））都是同步的，阻塞。你称他们为他们，你的程序睡觉，直到你要求的东西发生。在read（）的情况下，即“数据到达”。</p><p> The obvious problem is, what do you do if you want to  read() from more than one thing at a time? What if we block while trying to read from one thing, and then something happens on the other one thing? It might wait forever!</p><p> 显而易见的问题是，如果你想一次从多件事中读取（），你会怎么做？如果我们在试图从一件事中读取时阻止怎么办，那么另一件事就会发生一些事情？它可能会永远等待！</p><p> There are awkward solutions like setting an alarm to interrupt the operation so we can move to the next thing, or using “non-blocking” mode, but both have their problems. The only thing that works is to use a descriptor readiness facility such that we can say “wake me when any of these things have stuff to be read, and then tell me which ones the are”. Once that fires, we go through the things it reported, and call  read() on each of them, knowing that they won’t block because they all have stuff waiting.</p><p> 有一个尴尬的解决方案，如设置警报以中断操作，以便我们可以移动到下一件事，或使用“非阻塞”模式，但两者都有他们的问题。唯一有效的是使用描述符读取性设施，以便我们可以说“当任何这些东西都有要读取的东西时叫醒我，然后告诉我哪些是”。一旦火灾，我们就会通过它报告的东西，并在每个人上呼叫读（），知道他们不会阻止，因为它们都有等待的东西。</p><p> select() is the original UNIX facility for descriptor readiness. It works fine for small numbers of things, but doesn’t scale very far.  poll() was created to address some of its problems, but added some of its own. Most UNIXlikes went their own way with improved systems after this, most notably Linux’s  epoll and FreeBSD’s  kqueue, which have been extended over the years the be the weapon of choice to date. They are all conceptually the same as the old methods though: ask the system to wake the process when something happens to any number of interesting things, so the process can then go and take action each one.</p><p> select（）是用于描述符准备的原始UNIX工具。它适用于少数人，但不缩放到很远。 poll（）是创建的，以解决其中一些问题，而是添加了一些问题。大多数Unixlikes在此之后，最重要的系统，最符合的是Linux的ePoll和FreeBSD的kque，这是多年来延伸的迄今为止的武器。它们都是概念上的与旧方法相同：让系统在任何有趣的事情发生的事情发生时唤醒过程，因此该过程可以去采取行动。</p><p> io_uring takes a different approach though. It goes right back and looks at the original problem with fresh eyes, and says what if, instead of the kernel telling us when something is ready for an action to be taken so that we can take it, we tell the kernel what action to we want to take, and it will do it when the conditions become right.</p><p> 虽然我会采取不同的方法。它往后回来看看新的眼睛原来的问题，并说它是什么，而不是内核告诉我们什么时候准备好采取行动，以便我们可以接受它，我们告诉内核对我们有什么行动想采取，当条件变得正确时它会这样做。</p><p> This is almost always what we want anyway. In the traditional model, the user program calls into the kernel to ask it to tell it when something is ready, and then immediately afterwards calls back into the kernel to make it perform the action. The user program doesn’t do anything in between, so if those two calls can be combined and submitted to the kernel, the user program doesn’t have to get involved at all.</p><p> 无论如何，这几乎总是我们想要的。在传统的模型中，用户程序调用内核，要求它告诉它，当某些东西已准备就绪时，然后立即调用回内核以使其执行该操作。用户程序之间的任何内容都没有，因此如果可以将这两个调用组合并提交给内核，则用户程序根本不必参与。 </p><p> Its operation is fairly straightforward too. All it does is split a call in half - you make a request, and some time later, its done and you get the results back. While the requests and responses are encoded differently (the call name and arguments are in a memory buffer that you submit, rather than an actual function call), its the same effect - the kernel is asked to do something on behalf of the program.</p><p>它的操作也相当简单。所有它确实都分开了一半的呼叫 - 你提出了一个请求，一段时间后，它完成了，你会得到结果。虽然请求和响应以不同方式进行编码（调用名称和参数在您提交的内存缓冲区中，而不是实际函数调用），但它的效果相同 - 内核被要求代表该程序进行操作。</p><p> The whole thing works with a pair of queues: the submission queue, where you put requests for service, and the completion queue, where you find completed requests with their results.</p><p> 整件事件适用于一对队列：提交队列，您将请求服务，以及完成队列，您可以在那里找到与其结果完成的请求。</p><p> The whole “ring buffer” and “uring” thing? They’re really just implementation details, which probably goes some way to explain my confusion all this time: every damn description gets excited about ring buffers, so I thought they were actually an important part of it, when really it feels a lot more like just calling a remote API.</p><p> 整个“环形缓冲区”和“催促”的东西？他们真的只是实施细节，这可能是这样的方式来解释我的混淆：每个该死的描述都对环形缓冲区感到兴奋，所以我认为它们实际上是它的重要组成部分，当真的感觉更像只是打电话给远程API。</p><p> And since just another way of doing syscalls, it works for basically everything, including file IO which has traditionally been hard to do asynchronously. So it has the potential to make a lot of programs much simpler.</p><p> 自从另一种做Syscalls的方式，它基本上适用于一切，包括文件IO，传统上是难以异步的。所以它有可能使很多程序更简单。</p><p> I was very impressed once I figured it out, and I’m looking forward to seeing it in more of the programs I use. I just wish it had a bit better documentation around it, because I wonder how many others haven’t yet looked at it because they thought it was something different? Who knows!</p><p> 一旦我想出来，我留下了非常深刻的印象，我很期待在我使用的更多程序中看到它。我只是希望它周围有点更好的文档，因为我想知道还有多少还没有看过它，因为他们认为这是不同的东西？谁知道！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://despairlabs.com/posts/2021-06-16-io-uring-is-not-an-event-system/">https://despairlabs.com/posts/2021-06-16-io-uring-is-not-an-event-system/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/io/">#io</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/uring/">#uring</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>