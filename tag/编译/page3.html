<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#编译</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#编译</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031170.html">在不使用延续的情况下编译</a></div><div class="item_title_en"><a target="_blank" href="https://dl.acm.org/doi/10.1145/3062341.3062380">Compiling Without Continuations</a><span>(dl.acm.org)</span></div><span class="my_story_list_date">2020-10-26 8:21</span><div class="my_story_list_item_desc">我们使用饼干，以确保我们给你最好的经验，在我们的网站。
您的浏览器似乎不支持它们，这会影响网站功能。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiling/">#compiling</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/网站/">#网站</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031022.html">罗马工具链：Linter、编译器、绑定器等</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/rome/tools">The Rome Toolchain: A linter, compiler, bundler, and more</a><span>(github.com)</span></div><span class="my_story_list_date">2020-10-25 7:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1031022.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6e4f4bad7bb9be861f0eccbbc527e64d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Roman是一个用于JavaScript、TypeScript、JSON、HTML、Markdown和CSS的Linter、编译器、绑定器等。
罗马统一了以前作为独立工具的功能。基于共享库的构建允许我们在处理代码、显示错误、并行化工作、缓存和配置方面提供一致的体验。
罗马有很强的惯例，目标是最低限度的配置。阅读更多关......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/toolchain/">#toolchain</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/项目/">#项目</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030829.html">我自己的编译器基础结构上的我自己的C编译器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/maekawatoshiki/cilk/tree/master/cilkcc">My own C compiler on my own compiler infrastructure</a><span>(github.com)</span></div><span class="my_story_list_date">2020-10-24 7:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030829.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b71f23a653e4ac6df1ae71037508c3c3.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">(玩具)用Rust-maekawatoshiki/cilk编写的受LLVM影响的编译器基础设施</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基础/">#基础</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030633.html">使用Bakeware将Elixir应用程序编译为单个可执行的二进制文件</a></div><div class="item_title_en"><a target="_blank" href="https://www.poeticoding.com/compile-elixir-applications-into-single-executable-binaries-with-bakeware/">Compile Elixir applications into single executable binaries, with Bakeware</a><span>(www.poeticoding.com)</span></div><span class="my_story_list_date">2020-10-23 2:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030633.html"><img src="http://img2.diglog.com/img/2020/10/thumb_21054de7abd23919431e2a8a7caa1f96.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">BAKWARE是一个新的奇妙的工具，是在一个周末为SpawnFest 2020而构建的，它将一个药剂、一个风景或一个凤凰应用程序编译成单一的可执行二进制文件(是的，就像Go-Lang！)。分发我们的应用程序非常有用，特别是当它们是命令行工具或Scen应用程序时。
对于大多数Phoenix应用程序部署来说，这个工具可能......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bakeware/">#bakeware</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029716.html">编译Lisp：指令编码插曲</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-10/">Compiling a Lisp: Instruction encoding interlude</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-10-19 13:54</span><div class="my_story_list_item_desc">欢迎回到编译Lisp系列。在这个激动人心的新更新中，我们将学习更多关于x86-64指令编码的知识，而不是在堆上分配更多有趣的东西或添加过程调用。
我之所以写这段插曲，是因为我把编译器代码中的一个寄存器(krbp改成了krsp)，所有的地狱都崩溃了-结果程序崩溃了，rasm2/Cutter在给我的二进制文件时解码古怪的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029348.html">使用多阶段构建的较小的Docker映像</a></div><div class="item_title_en"><a target="_blank" href="https://codesalad.dev/blog/smaller-docker-images-using-multi-stage-builds-8">Smaller Docker Images Using Multi-Stage Builds</a><span>(codesalad.dev)</span></div><span class="my_story_list_date">2020-10-17 6:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1029348.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c51e4db2a1d234d9b999247de43b0b4d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Docker 17引入了一项名为多阶段构建的新功能，大大简化了优化Docker映像的过程。这篇文章概述了多阶段构建，以及如何使用它们来简化Dockerfile并大大减小映像大小。🥳。
来自戈朗：1.14-编译时的高山ADD。.run go build-o myapp.#将工件复制到最小运行时映像FROM alpine......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/阶段/">#阶段</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028888.html">将SQL存储过程(如LANGUAGE)转换为C for SQLite的编译器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/facebookincubator/CG-SQL">A compiler that converts a SQL Stored Procedure like language into C for SQLite</a><span>(github.com)</span></div><span class="my_story_list_date">2020-10-15 4:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1028888.html"><img src="http://img2.diglog.com/img/2020/10/thumb_239bb5b07a2c9f9cf3f664f649f25217.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Mac上的默认野牛版本非常旧(2.3版)。你需要更换它。如果发生这种情况，则生成器会产生错误。你可以得到一头最近的野牛，就像这样：
Ubuntu系统上的默认SQLite也相当旧。某些测试(特别是查询计划测试)使用此版本中没有的功能。您将希望链接到较新的sqlite以通过所有测试。
如果您将CGSQL_GCC添加到您的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/converts/">#converts</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028194.html">将Lisp编译为x86-64：堆分配</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-9/">Compiling a Lisp to x86-64: Heap allocation</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-10-12 7:5</span><div class="my_story_list_item_desc">欢迎回到“编译Lisp”系列。上次我们添加了对IF表达式的支持。这一次，我们将添加对基本堆分配的支持。
堆分配有几种形式，但我们现在关心的是cons原语。与编译器中的AST_NEW_Pair非常类似，consout应该：
一旦我们有了那一对，我们就可以查看它的数据了。这意味着我们现在可能还应该实现CAR和CDR原始函......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/buf/">#buf</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027938.html">法语DGFiP的M语言编译程序</a></div><div class="item_title_en"><a target="_blank" href="https://gitlab.inria.fr/verifisc/mlang">Compiler for the M language of the French DGFiP</a><span>(gitlab.inria.fr)</span></div><span class="my_story_list_date">2020-10-11 15:45</span><div class="my_story_list_item_desc">法语DGFiP的M语言编译程序</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dgfip/">#dgfip</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027497.html">在使用自制C编译器的自制CPU上运行类Unix操作系统</a></div><div class="item_title_en"><a target="_blank" href="https://fuel.edby.coffee/posts/how-we-ported-xv6-os-to-a-home-built-cpu-with-a-home-built-c-compiler/">Running a Unix-like OS on a home-built CPU with a home-built C compiler</a><span>(fuel.edby.coffee)</span></div><span class="my_story_list_date">2020-10-7 8:43</span><div class="my_story_list_item_desc">我开始做软件工程师已经两年了，我有时会给同事们讲我在大学三年级做的一个学生项目，它非常受欢迎，所以我写了这篇文章。1个。
现在，让我问你一个问题。你有没有设计过你自己的ISA，在FPGA上建立了一个ISA的处理器，并为它构建了一个编译器？另外，你在那个处理器上运行过操作系统吗？实际上，我们有。
在这篇文章中，我将谈论......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/自制/">#自制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/built/">#built</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpu/">#cpu</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027361.html">在用户将泄漏的代码编译到正常运行的操作系统后确认Windows XP泄漏</a></div><div class="item_title_en"><a target="_blank" href="https://www.zdnet.com/article/windows-xp-leak-confirmed-after-user-compiles-the-leaked-code-into-a-working-os/">Windows XP Leak Confirmed After User Compiles the Leaked Code Into a Working OS</a><span>(www.zdnet.com)</span></div><span class="my_story_list_date">2020-10-1 3:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027361.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9e006679c4e31e5eb57c277f6878a6b6.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">上周4chan网站在网上泄露的Windows XP和Windows Server 2003源代码，在一名YouTube用户将代码编译成可以正常工作的操作系统后，已被证实是真实的。
上周泄密事件发生后不久，ZDNet就联系了多名现任和前任微软软件工程师，以确认泄露文件的有效性。
当时，消息人士告诉路透社ZDNet记者，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/泄漏/">#泄漏</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027345.html">从泄露的源代码编译的Windows XP和Server 2003</a></div><div class="item_title_en"><a target="_blank" href="https://www.bleepingcomputer.com/news/microsoft/windows-xp-and-server-2003-compiled-from-leaked-source-code/">Windows XP and Server 2003 compiled from leaked source code</a><span>(www.bleepingcomputer.com)</span></div><span class="my_story_list_date">2020-10-1 3:26</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027345.html"><img src="http://img2.diglog.com/img/2020/10/thumb_e5e69b4ff60daa309a222f467a868fe5.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">一位Windows开发人员上周从网上泄露的源代码中成功编译了Windows XP和Windows Server2003。
上周，在4chan论坛上，一组43 GB的微软源代码作为洪流发布。
该集合包括许多Microsoft操作系统的源代码，包括Windows XP SP1、Windows Server 2003、MS......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/源代码/">#源代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/xp/">#xp</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027243.html">除非它是编译器错误，否则它永远不会是编译器错误</a></div><div class="item_title_en"><a target="_blank" href="http://r6.ca/blog/20200929T023701Z.html">It Is Never a Compiler Bug Until It Is</a><span>(r6.ca)</span></div><span class="my_story_list_date">2020-9-30 18:43</span><div class="my_story_list_item_desc">上周，我试图向libsecp256k1添加一些测试代码，我拔掉头发试图让它正常工作。没有多少printf工作来说明我做错了什么。最后，出于无奈，我想我应该快速检查一下是否有与memcmp相关的编译器错误，结果，我发现了GCC错误#95189：memcmp像strcmp一样被错误地剥离。
老实说，读起来这是一个相当可怕......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027186.html">Fortran编译为WebAssembly</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/StarGate01/Full-Stack-Fortran">Fortran Compiled to WebAssembly</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-30 10:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027186.html"><img src="http://img2.diglog.com/img/2020/9/thumb_58aac13b501d3f2584c0513305c907cd.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">GitHub是5000多万开发人员的家园，他们一起工作，共同托管和审查代码、管理项目和构建软件。
报名</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiled/">#compiled</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/审查/">#审查</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026428.html">柯特林快速编译的秘密</a></div><div class="item_title_en"><a target="_blank" href="https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/">The Dark Secrets of Fast Compilation for Kotlin</a><span>(blog.jetbrains.com)</span></div><span class="my_story_list_date">2020-9-26 1:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1026428.html"><img src="http://img2.diglog.com/img/2020/9/thumb_d02f4c54c8e68a5c86bf0882c0f51ab7.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">快速编译大量代码是一个难题，尤其是当编译器必须使用泛型执行复杂的分析(如重载解析和类型推断)时。在这篇文章中，我将告诉你Kotlin的一个巨大且基本上不可见的部分，这使得它在日常运行-测试-调试循环中经常发生的相对较小的更改上编译得更快。
此外，我们正在寻找高级开发人员加入JetBrains的团队，为Kotlin进行......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/特林/">#特林</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/secrets/">#secrets</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026209.html">编译Lisp：Reader</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-6/">Compiling a Lisp: Reader</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-9-25 1:2</span><div class="my_story_list_item_desc">欢迎回到“编译Lisp”系列。这一次，我想暂停编译，最后添加一个阅读器。我终于对手动输入日益复杂的AST感到沮丧了，所以我想是时候了。在这篇帖子之后，我们将能够输入如下程序：
让我们的编译器为我们制作ast！魔法。这也将为我们增加一些很好的调试工具。例如，假设有一个交互式命令行实用程序，我们可以在其中输入Lisp表达......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/符号/">#符号</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026145.html">SCC-用于DOS的小型C编译器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/mras0/scc">SCC – Small C Compiler for DOS</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-24 21:24</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1026145.html"><img src="http://img2.diglog.com/img/2020/9/thumb_1c8c2396c163ddb4444d6f1c648b9e59.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">SCC是一个有限的C编译器，可生成微小模型(即单段)DOS COM文件。它应该可以在大多数操作系统上运行，并且可以在具有128K RAM的DOS2.0+兼容系统(例如SDO)下自托管(编译器只使用64K，但是操作系统也需要具有生命力：)。
使用C99编译器编译scc.c并在scc.c上运行输出，这将生成scc.com......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/small/">#small</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026110.html">CPython编译器的工作原理</a></div><div class="item_title_en"><a target="_blank" href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">How the CPython compiler works</a><span>(tenthousandmeters.com)</span></div><span class="my_story_list_date">2020-9-24 17:31</span><div class="my_story_list_item_desc">在本系列的第一篇文章中，我们介绍了CPython VM。我们已经了解到它是通过执行一系列称为字节码的指令来工作的。我们还看到，Python字节码不足以完全描述一段代码的功能。这就是存在代码对象概念的原因。执行诸如模块或函数的代码块意味着执行相应的代码对象。代码对象包含块的字节码、常量和块中使用的变量名称以及块的各种属......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025529.html">MOUD：Rust的编译时HTML模板</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/lambda-fairy/maud">Maud: Compile-time HTML templates for Rust</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-22 17:45</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1025529.html"><img src="http://img2.diglog.com/img/2020/9/thumb_563882bcb1024417cfff4c50746d40ae.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">MOUD是Rust的HTML模板引擎。它是以宏html！的形式实现的，它将您的标记编译成专门的Rust代码。这种独特的方法使Maud模板快速、超级类型安全且易于部署。
请注意，Maud依赖于不稳定的过程宏API，因此需要Rust的夜间版本。
从0.11版开始，我对库的核心语法和语义感到满意。此阶段的开发重点是添加功能......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025369.html">Cobaul：一个COBOL到WebAssembly编译器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/cloudflare/cobaul">Cobaul: A COBOL to WebAssembly Compiler</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-22 0:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1025369.html"><img src="http://img2.diglog.com/img/2020/9/thumb_33a8e77c64c3d397f09eb40f54df5377.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">为了避免在本地设置编译器环境，您可以使用预先构建的Docker镜像：xtuc/cobaul：
Docker run\-e EM_OUT\-e EM_args\-v/tmp/cobol-worker：/root/.emscripten_cache/\-v$pwd：/worker\-v$pwd/build：/build\......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cobol/">#cobol</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/worker/">#worker</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025241.html">小事：加速C++编译</a></div><div class="item_title_en"><a target="_blank" href="https://codingnest.com/the-little-things-speeding-up-c-compilation/">The Little Things: Speeding up C++ compilation</a><span>(codingnest.com)</span></div><span class="my_story_list_date">2020-9-21 5:2</span><div class="my_story_list_item_desc">“小事”是一系列基于洛克斯利内部培训课程的新帖子。通常，内容要么是专有的(例如，特定主密钥平台的内部工作原理)，要么通常不是很有趣(例如，我们的内部库和工具)，但有时内容适合更广泛的受众，在这种情况下，我想分享它们。
这篇文章将介绍一些加速C++编译的源码级技术，以及它们的(不)优势。它不会谈论C++之外的事情，比如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/加速/">#加速</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024535.html">BAKWARE-将Elixir应用程序编译为单个可执行的二进制文件</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/spawnfest/bakeware">Bakeware – Compile Elixir applications into single executable binaries</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-17 18:36</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1024535.html"><img src="http://img2.diglog.com/img/2020/9/thumb_e32e962840c0f890cf6fd2e18df359a1.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">你有没有羡慕过分配公用设施是多么容易呢？或者，也许您的脚本变得过多，并且遇到了需要特定于平台的代码的库的障碍？或者那个OTP版本看起来很容易发布，但不知何故，运行untar正好有足够的摩擦让人抱怨你使用长生不老药。
BAKWARE通过扩展MixRelease来解决这些问题，使其能够将Elixir项目转换为可复制和直接......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/示例/">#示例</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023547.html">Elixir v1.11的ChangeLog</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/elixir-lang/elixir/blob/master/CHANGELOG.md">Changelog for Elixir v1.11</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-12 17:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023547.html"><img src="http://img2.diglog.com/img/2020/9/thumb_71f2e192dc5bc2a6f662ff2bccaa9300.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">PermalLink GitHub是5000多万开发人员的家园，他们一起工作，共同托管和审查代码、管理项目和构建软件。
报名。
在最近的版本中，Elixir团队一直专注于编译器，无论是在编译时捕获更多错误，还是在提高速度方面都是如此。ELEXIRV1.11在这两个方面都取得了很好的进展。此版本还包括许多其他优点，例如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023409.html">APRLE，一个通用Lisp的APL编译器[视频]</a></div><div class="item_title_en"><a target="_blank" href="https://youtube.com/watch?v=AUEIgfj9koc">April, an APL Compiler for Common Lisp [video]</a><span>(youtube.com)</span></div><span class="my_story_list_date">2020-9-12 2:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023409.html"><img src="http://img2.diglog.com/img/2020/9/thumb_f054050a82a5fb70d4a42bf9e60ce89a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Andrew Sengul将介绍APRL语言到Common Lisp的编译器APRPLE。APL是一种使用简洁、一致的语法和数组的语言……</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apl/">#apl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023229.html">编译Word for Windows v1.1a</a></div><div class="item_title_en"><a target="_blank" href="https://richardlewis.org/blog/2020/7/31/opus-compiling-word-for-windows-1-1a">Compiling Word for Windows v1.1a</a><span>(richardlewis.org)</span></div><span class="my_story_list_date">2020-9-11 21:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023229.html"><img src="http://img2.diglog.com/img/2020/9/thumb_38cc3f2d3069fa5445d3ddcbb87314bb.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">OPUS是Microsoft内部开发人员用于Microsoft Word for Windows v1.1a的代码名-让我们从源代码编译它，看看它是否可以运行！Microsoft Word for Windows v1.1a版权所有©Microsoft 1989。
这篇博客记录了如何获取源代码，并将其转换成可以工作的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/word/">#word</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dos/">#dos</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023162.html">JIT编译历险记(2017)</a></div><div class="item_title_en"><a target="_blank" href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/">Adventures in JIT Compilation (2017)</a><span>(eli.thegreenplace.net)</span></div><span class="my_story_list_date">2020-9-10 13:8</span><div class="my_story_list_item_desc">这是关于JIT编译器系列文章的第一篇。我们的计划是采用一种简单的输入语言，并为其开发一些解释器和JIT，其复杂程度大致递增。我希望在本系列结束时，读者能够很好地理解开发JIT编译器需要什么，以及有哪些工具可以帮助完成这项任务。
输入语言将是Brainfuck，或BF，因为我将从现在起和整个系列中都会提到它。我认为这是......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jit/">#jit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/循环/">#循环</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022962.html">优化的R6RS Scheme编译器Loko Scheme</a></div><div class="item_title_en"><a target="_blank" href="https://scheme.fail/">Loko Scheme, an optimizing R6RS Scheme compiler</a><span>(scheme.fail)</span></div><span class="my_story_list_date">2020-9-9 22:40</span><div class="my_story_list_item_desc">Loko方案在GNU Affero通用公共许可证版本3或更高版本下可用。
Loko Scheme是一款小众编译器。它并没有试图取代任何其他编译器。一些关于你可以用它做什么的想法：
尝试让C在Scheme上运行，而不是反过来。
驱动程序基于编译器内部机制、伙伴分配器和基于并发ML的并发性。
请将问题报告给GitLab上......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scheme/">#scheme</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/loko/">#loko</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022623.html">如何对Rust编译器进行最后一次加速</a></div><div class="item_title_en"><a target="_blank" href="https://blog.mozilla.org/nnethercote/2020/09/08/how-to-speed-up-the-rust-compiler-one-last-time/">How to speed up the Rust compiler one last time</a><span>(blog.mozilla.org)</span></div><span class="my_story_list_date">2020-9-8 7:16</span><div class="my_story_list_item_desc">由于Mozilla最近的变化，我从事Rust编译器的时间即将结束。我仍然在Mozilla工作，但在可预见的未来，我将专注于Firefox的工作。
所以我想我应该结束我的“如何加速铁锈编译器”系列，这个系列始于2016年。
如何提高铁锈编译器的速度。原始的帖子，标题最有意义的帖子。它主要关注如何为性能工作设置编译器，包......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022401.html">将Lisp编译为x86-64：基本函数</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-4/">Compiling a Lisp to x86-64: primitive functions</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-9-6 23:49</span><div class="my_story_list_item_desc">欢迎回到“编译Lisp”系列。上一次，我们完成了将其余常量作为标记指针立即数添加的操作。由于只有值(无法对其进行操作)没有多大用处，我们将添加一些原始的一元函数。
“原语”在这里指的是它们内置于编译器中，因此我们实际上不会编译对汇编过程调用的调用。这也称为编译器内部机制。“一元”表示函数只有一个参数，“函数”有点用词......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/buf/">#buf</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022100.html">GCC自动并行编译可行性结果帮助高达3.3倍</a></div><div class="item_title_en"><a target="_blank" href="https://www.phoronix.com/scan.php?page=news_item&px=GCC-Auto-Parallel-Compilation">GCC Automatic Parallel Compilation Viability Results Help Up to 3.3x</a><span>(www.phoronix.com)</span></div><span class="my_story_list_date">2020-9-4 19:50</span><div class="my_story_list_item_desc">我们依赖您的支持：您知道您每月只需不到3美元就可以获得Phoronix Premium吗？今天就试着在一个页面上查看我们的网站无广告、多页文章，以及更多内容，这样我们就可以写更多的Linux硬件评论了。Google Summer of Code2020中最有趣的项目之一是正在进行的允许并行编译单个代码文件的工作，这是......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/自动/">#自动</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/automatic/">#automatic</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并行/">#并行</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/编译/">0</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page2.html">2</a></li><li class="page-item active"><a class="page-link" href="/tag/编译/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page4.html">4</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page5.html">5</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page6.html">6</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>