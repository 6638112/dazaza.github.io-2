<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>熵：简介</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">熵：简介</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-18 03:25:22</div><div class="page_narrow text-break page_content"><p>随着第一台数字计算机在20世纪40年代被发明，像艾伦·图灵这样的研究人员正在将他们的能力正规化，科学界和工程界需要一种方法来量化以前对信息和通信的直觉概念。1948年，克劳德·香农(Claude Shannon)在贝尔实验室(也是晶体管和Unix操作系统的发源地，以及计算机科学的其他主要成就)工作期间，在他的里程碑式的论文“通信的数学理论”中提供了第一个全面的框架来做到这一点。有了这个理论(现在称为信息论)提供的工具，我们可以回答有关现代计算机局限性的重要问题，比如：我们如何才能以最有效的方式存储信息(比如，硬盘上的文件)？或者，我们如何通过可能不是100%可靠的信道(例如，我们的蜂窝网络)成功地传送信息(例如，文本消息)？</p><p>我们已经提供了几个抽象意义上的“信息”示例，但是我们如何才能以正式、精确的方式定义信息呢？我们将从一个示例开始。假设西雅图市已经决定引入一项新的服务，即每个居民每天早上都会收到一条包含当天天气预报的短信。如果是冬天，那里的天气百分之百都是阴天，发短信是多余的；如果一个居民对城市的天气模式有基本的了解，并假设每天都会阴天，那么他就永远是正确的。换句话说，预测不会为城市居民提供任何新的信息，因为结果没有不确定性。</p><p>现在，假设我们处在一个不同的季节，一天的天气有多种可能性。在这种情况下，我们的服务实际上将是有用的-居民不再能够仅仅假设天气每天都是阴天，并且100%的时间都是正确的。一个给定的预测到底有多大用处呢？假设我们现在是夏天，天气(乐观地说)有75%的时间是晴朗的，25%的时间是阴天。在这种情况下，如果居民天真地假设当天的天气会是晴朗的，那么他们在大多数日子里都会是正确的，因此，与天真的基线相比，对晴天的预测不会提供太多新的信息。相应地，由于它们的相对稀有性，预测阴天的预报将提供更多的信息，因为在这种情况下，天真的预测将是不正确的。</p><p>从前面的示例中我们可以看到，在传达事件结果时传输的信息与该结果的频率密切相关。带着这个想法，我们引入了信息论中的第一个概念--自我信息。</p><p>假设我们有一些离散随机变量X∼p(X)X\sim p(X)X∼p(X)，它具有一组势值x∈X x\in数学{X}x∈X，具有对应的概率质量函数p(X)。然后我们定义。</p><p>自我信息(有时也被称为“惊喜”)。X∈X x\in\数学{X}x∈X定义为i(X)=1log⁡p(X)=−log⁡p(X)i(X)=\frac{1}{\logp(X)}=-\logp(X)i(X)=log p(X)1​=−log p(X)。</p><p>我们通常将上述定义中的LOG⁡\LOG LOG设为以2为底，因此自我信息是以位为单位度量的。乍一看，我们对i(X)的定义可能看起来很武断，但我们可以看到，它包含了我们早先在思维实验中的想法，以及其他一些很好的性质。作为p(X)→1p(X)\to 1 p(X)→1，我们有i(X)→0 i(X)\to 0 i(X)→0。这与我们的直觉一致，即只有在接收方尚未意识到事件的结果时，才会将有关该事件的信息从源传输到接收方。类似地，作为p(X)→0 p(X)\to 0 p(X)→0，我们有i(X)→∞i(X)\to ininfty I(X)→∞，反映了罕见结果的传达比普通结果更有信息量。</p><p>最后，假设我们希望传达两个独立事件X1，X2∼I.I.D.的结果。P(X)X_1，X_2\stackrel{\TEXT{I.I.D.}}{\sim}p(X)X 1​，X 2​∼I.D.。P(X)。由于X1X1X1X1​和X2X2X2​的结果彼此独立，我们预计包含这两个结果的复合消息将传递的信息量等于分别发送包含每个结果的两个消息的总和。自信息也满足这一性质，因为对于某些联合结果(x1，x2)∈X×X(x_1，x_2)\in\数学{X}\次\数学{X}(x 1​，x 2​)∈X×X</p><p>I(x1，x2)=对数对齐p(x1，x2)=对数对数对齐(p(X1)p(X2))=−[对数对齐p(X1)+对数对数点p(X2)]=i(X1)+i(X2)\⁡{−}i(x_1，x_2)&amp；=-\log p(x_1，x_2)\\&amp；=-\log\BIG(p(X_1)p(X_2)\BIG)\\&amp；=-[\log p(X_1)+\log p(X_2)]\\&amp；=i(X_1)+i(X_2)\End{Alignment}i(x 1​，x 2​)​=−lg p(x 1​，X 2​)=−log(p(x 1​)p(x 2​))=−[lo g p(x 1​)+lo p(x 2​)])=i(x 1​)+i(x 2​)​。</p><p>现在，假设结果不是提前知道的，但我们仍然想知道我们将传输多少信息。要做到这一点，一种简单的方法是用每个结果的概率p(X)来加权每个结果的自我信息i(X)。这给了我们信息论中的第二个主要概念？？熵。</p><p>随机变量X的熵H(X)定义为H(X)=∑x∈Xp(X)i(X)=−∑x∈Xp(X)log⁡p(X)H(X)=\SUM_{x\in\数学{X}}p(X)I(X)=-\SUM_{x\in\数学{X}}p(X)\。Log p(X)H(X)=x∈X∑​p(X)i(X)=−x∈X∑​p(X)log p(X)。</p><p>按照惯例，当x=0x=0x=0时，我们为p(X)loglogp(X)p(X)\logp(X)⁡p(X)log p(X)赋值0 0 0，即使从技术上讲，0 log⁡0 0\log0 0 log 0是未定义的。我们可以用连续性来证明这一点，因为它可以显示为x log⁡x→0 x\log x\to 0 x lo g x→0 as x→0+x\to 0^{+}x→0+。1这也符合我们的直觉--一个不可能发生的结果对我们的事件X的可变性没有任何影响。</p><p>熵很可能是信息论的“基本单位”，它将继续以各种有趣的方式出现。我们可以认为H(X)量化了我们平均会对X的结果感到多少“惊讶”。举一个例子将有助于说明这一观点。</p><p>设X∼B e r n(P)X\sim Bern(P)X∼B e r n(P)。换句话说，我们有X={1，概率为p 0，概率为1−p X=\Begin{Cases}1&amp；\TEXT{概率为$p$}\\0&amp；\TEXT{概率为$1-p$}\End{Cases}X={1 0​，概率为1−p​。</p><p>H(X)=−p log⁡p−(1−p)log⁡(1−p)H(X)=-p\log p-(1-p)\log(1-p)H(X)=−p lo g p−(1−p)log g(1−p)。</p><p>为了建立我们的直觉，我们可以在下面的图中可视化不同的p值的熵(其中我们让H(P)表示H(X)作为p p的函数)</p><p>正如我们所期望的那样，当X X是确定性的(p=0p=0p=0或p=1p=1p=1)时，H(X)是0，因为在这种情况下不会有意外的可能性。另一方面，当结果的变异性最大时，当p=1/2p=1/2p=1/2时，它是最大的。在继续之前，我们将完成另一个更复杂的示例。</p><p>设X∼G e o m(P)X\sim Geom(P)X∼G e o m(P)。换句话说，在达到第一个1之前需要k k次伯努利试验的概率是(设q=1−p q=1-p q=1−p)P(X=k)=q k−1 p P(X=k)=q^{k-1}p P(X=k)=q k−1 p。</p><p>H(X)=−∑k=1∞q k−1 p⋅log⁡(q k−1 p)=−[∑k=1∞p q k−1 log⁡p+∑k=1∞p q k−1 log⁡q]=−[∑k=0∞p q k log⁡p+∑k=0∞p q k log⁡q]\Begin{Alignment}H(X)&amp；=-\sum_{k=1}^{\infty}q^{k-1}p\cdot\log\Big(q^{k-1}p\Big)\\&amp；=-\Bigg[\sum_{k=1}^{\infty}pq^{k-1}\log p+\sum_{k=1}^{\infty}pq^{k-1}\log q\Bigg]\\&amp；=-\Bigg[\sum_{k=0}^{\infty}Pq^{k}\logp+\sum_{k=0}^{\infty}Pq^{k}\logq\Bigg]\End{Alignment}H(X)​=−k=1∑∞​q k−1 p⋅log(q k−1 p。)=−[k=1∑∞​p q k−1 lo g p+k=1∑∞​p q k−1 lo q]=−[k=0∑∞​p q k lo g p+k=0。∑∞​p q k lo g q]​。</p><p>从微积分开始，我们知道∑n=0∞rn=1 1−r\sum_{n=0}^{\infty}r^{n}=\frac{1}{1-r}n=0∞​rn=1−r 1​∑n=0∞n rn=r(1−r)2\sum_{n=0}^{。\infty}nr^{n}=\frac{r}{(1-r)^2}n=0∞​n r n=(1−r)2 r​对于任意实数r，|r|&lt；1|r|&lt；1|r|&lt；1。这为我们提供了。</p><p>H(X)=−[p log⁡p 1−q+p q log⁡q p 2]=−[p log⁡p+q log⁡q p]=−[p log⁡p+(1−p)log⁡(1−p)p]\BEGIN{Alignment}H(X)&amp；=-\bigg[\frac{p\log p}{1-q}+\frac{pq\log q}{p^2}\bigg]\\&amp；=-\Bigg[\frac{p\logp+q\logq}{p}\bigg]\\&amp；=-\BIGG[\FRAC{p\logp+(1-p)\log(1-p)}{p}\Bigg]\End{Alignment}H(X)​=−[1−q p lo g p​+p 2 p q lo g q​]=−]。P p lo g p+q lo g q​]=−[p p lo g p+(1−p)lo(1−p)​]​。</p><p>正如我们可能预期的那样，H(P)→0 H(P)\to 0 H(P)→0 as p→1 p\to 1 p→1，因为在第一次成功之前，我们需要的试验次数的可变性较小。另一方面，H(P)→∞H(P)\to\ininfty H(P)→∞as p→0 p\to 0 p→0反映了这样一个事实，即随着成功概率的降低，预测成功所需的试验次数变得更加困难。</p><p>H(X)=−∑x∈X p(X)log⁡p(X)H(X)=-\sum_{x\in\数学{X}}p(X)\log p(X)H(X)=−x∈X∑​p(X)log p(X)。</p><p>因为我们的p(X)项是概率项，所以我们必须有0≤p(X)≤1 0\leq p(X)\leq 1 0≤p(X)≤1。由于0&lt；x⁡1 0&lt；x\leq 1 0&leq 1的log≤x≤0\log x\leq 0 log x≤0。X≤1，所以我们必须有∑x∈X p(X)⁡p(X)≤0\∈_{x\in\Mathcal{X}}p(X)\log p(X)\leq 0 x∈X​p(X)log p(X)≤0。然后乘以H(X)的定义中的负号，就完成了证明。-\正方形-</p><p>这一事实将在我们继续课程的过程中被证明是非常有用的，所以现在最好记住这一点。</p><p>读者可能已经注意到，我们对熵的定义与随机变量的期望值的定义几乎相同，只是在存在LOG⁡\LOGLOG函数时有所不同。这就回避了一个问题--我们能调和这两个概念吗？首先，作为提醒，我们将期望值定义为。</p><p>离散随机变量X∼p(X)X\sim p(X)X∼p(X)的期望值E[X]为E[X]=∑x∈Xp(X)⋅x E[X]=\SUM_{x\in\数学{X}}p(X)\cotxE[X]=x∈X∑​p(X)⋅x。</p><p>现在，假设我们将某个确定性函数应用于随机变量X，这给出了一个新的随机变量g(X)。由于g(X)中的随机性完全是由于XXX中的随机性所致，因此直观上我们应该能够使用XXX的分布p(X)来计算Eg(X)，而不需要计算g(X)的分布。事实证明，我们在这里的直觉是正确的；这是概率论中的一个众所周知的结果，使用得够多了，以至于有了自己的名字。</p><p>对于离散随机变量X∼p(X)X\sim p(X)X∼p(X)和函数g ⁣：r→R g\冒号\mathbb{R}\to\mathbb{R}g：r→R E[g(X)]=∑x∈X p(X)⋅g(X)E[g(X)]=\sum_{x\。在数学上{X}}p(X)\cot g(X)E[g(X)]=x∈X∑​p(X)⋅g(X)。</p><p>尽管这个定理的本质是直观的，但证明它需要一些工作，我们在这里省略这些工作，把这些工作留给读者作为练习。2设置g(X)=−log⁡p(X)g(X)=-\logp(X)g(X)=−log p(X)，然后使用莲花。</p><p>这使得我们可以正式证明熵的概念，即包含在随机变量的结果中的平均信息量。</p><p>在结束这些注释之前，我们将复习最后一个示例。假设我们想要传达由随机变量X表示的事件的结果。理想情况下(为了节省金钱、电力等)。平均而言，我们希望消息越短越好。自然，我们的编码方案应该使用较少的比特来表示高概率事件，而使用更多的比特来编码低概率事件。事实证明(我们稍后将证明这一点)，这个问题的任何编码方案平均至少需要I(X)比特才能在不破坏其内容的情况下发送我们的消息。换言之，H(X)=E[I(X)]提供了保证我们的消息将被成功发送所需的平均比特数的下限。虽然我们稍后才会有工具来证明这一点，但一个简单的示例将有助于说明这一想法</p><p>设X={a，概率为1/2 b，概率为1/4 c，概率为1/8 d，X=\Begin{Cases}a&amp；\text{概率为1/2}\\b&amp；\text{概率为1/4}\\c&amp；\text{概率为1/8}\\d&amp；\text{概率为1/8}\end{案例}X=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a b c d​，概率为1/2，概率为1/4，概率为1/8，概率为1/8​。</p><p>在这种情况下，我们怎么才能设计出密码来传送X的结果呢？一种可能的方案如下：如果X=aX=aX=a，我们发送1并结束传输，否则我们发送0并继续。类似地，如果X=bX=bX=b，那么我们发送一个1并停止，否则我们发送另一个0。最后，如果X=c，我们发送1并停止，否则发送0并停止。在该方案下，我们一半的时间总共发送1比特，2比特1/4的时间发送，1/4的时间发送3比特，平均总共1.75比特。</p><p>在这个方案中，每当我们提出“问题”时，我们就消除了剩余概率空间的一半。这与二进制搜索在算法的每一步消除一半可能的解空间的方式非常相似。此外，正如二分搜索是一种最优算法(即，采用尽可能少的步骤来保证正确答案)一样，我们期望我们的编码方案对于X、X、X是最优的。</p><p>H(X)=−1 2 LOG⁡1 2−1 4 LOG⁡1 4−1 8 LOG⁡1 8−1 8 LOG⁡1 8=1.75G比特H(X)=HSP1。\FRAC{1}{8}=1.75\Text{Bits}H(X)=−2 1​log 2 1​−4 1​log 4 1​−8 1​lo g 8 1​。−8 1​log 8 1​=1。7个5位。</p><p>由于我们对X×X的结果进行编码所需的平均比特数不能小于H(X)，因此我们提出的方案确实是最优的。</p><p>一个潜在的证据是应用微积分↩中的L‘Hôpital规则</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://homes.cs.washington.edu/~ewein/blog/2020/07/14/entropy/">https://homes.cs.washington.edu/~ewein/blog/2020/07/14/entropy/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/简介/">#简介</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/entropy/">#entropy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/log/">#log</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>