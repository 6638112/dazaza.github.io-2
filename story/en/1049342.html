<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>带有SBCL v2的静态可执行文件 Static Executables with SBCL v2</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Static Executables with SBCL v2<br/>带有SBCL v2的静态可执行文件 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 18:22:04</div><div class="page_narrow text-break page_content"><p>It&#39;s taken me much longer than I hoped, but I finally have a second version ofmy patches to build static executables tested and ready to go! This set ofpatches vastly improves upon the first by reducing the amount of compilationneeded at the cost of sacrificing a little purity. Additionally I have createda system that automates the process of building a static executable, along withother release related tasks.</p><p>它花了我比我希望的更长的时间，但是我终于有了补丁的第二个版本来构建经过测试的静态可执行文件，并且可以开始使用！通过减少所需的编译量（以牺牲一些纯度为代价），这组修补程序在第一个方面有了很大的改进。另外，我创建了一个系统，该系统可自动完成构建静态可执行文件的过程以及其他与发布相关的任务。</p><p>  The new patch set can be found on the  static-executable-v2 branch of my SBCL fork or at  https://www.timmons.dev/static/patches/sbcl/$VERSION/static-executable-support-v2.patch with a detached signature available at  https://www.timmons.dev/static/patches/sbcl/$VERSION/static-executable-support-v2.patch.asc signed with GPG key  0x9ACF6934.</p><p>  新的补丁集可以在我的SBCL分支的static-executable-v2分支上找到，也可以在https://www.timmons.dev/static/patches/sbcl/$VERSION/static-executable-support-v2.patch中找到可通过https://www.timmons.dev/static/patches/sbcl/$VERSION/static-executable-support-v2.patch.asc使用GPG密钥0x9ACF6934签名的分离签名。</p><p> You&#39;ll definitely want to build SBCL with the  :sb-prelink-linkage-table feature (newly added by the patch). You&#39;ll probably also want the  :sb-linkable-runtime feature (already exists, but the patch also enables it on arm/arm64).</p><p> 您肯定要使用：sb-prelink-linkage-table功能（由修补程序新添加）来构建SBCL。您可能还需要：sb-linkable-runtime功能（已经存在，但是该补丁还在arm / arm64上启用了它）。</p><p> The new patch lets you build a static executable with less compilation of Lisp code.</p><p> 新的补丁程序使您可以使用更少的Lisp代码编译来构建静态可执行文件。</p><p> The  asdf-release-ops system automates the process of building a static executable by tying it into ASDF.</p><p> asdf-release-ops系统通过将静态可执行文件绑定到ASDF中来自动执行构建静态可执行文件的过程。</p><p>  If you need a refresher about what static executables are or what use casesthey&#39;re good for, seemy  previous post on this topic.</p><p>  如果您需要复习什么是静态可执行文件或它们最适合的用例，请参考此主题之前的文章。</p><p> With my previous patch, the only way you could create a static executable wasto perform the following steps:</p><p> 在我以前的补丁程序中，创建静态可执行文件的唯一方法是执行以下步骤： </p><p> Determine the foreign symbols needed by your code. The easiest way to do this is to compile all your Lisp code and then dump the information from the image.</p><p>确定您的代码所需的外国符号。最简单的方法是编译所有Lisp代码，然后从映像中转储信息。</p><p> From that list of foreign symbols, create a C file that contains fills an array with references to those symbols.</p><p> 从该外来符号列表中，创建一个C文件，其中包含对这些符号的引用填充数组。</p><p> Recompile the SBCL core and runtime with this new file, additionally disabling libdl support and linking against your foreign libraries.</p><p> 使用此新文件重新编译SBCL核心和运行时，另外禁用libdl支持并链接到外部库。</p><p> (Re)compile all your Lisp code with the new runtime (if you made an image in step 1 it will not be compatible with the new runtime due to feature and build ID mismatches).</p><p> 用新的运行时（重新）编译所有Lisp代码（如果在步骤1中创建了映像，由于功能和内部版本ID不匹配，它将与新的运行时不兼容）。</p><p> In the most general case, this involved compiling your entire Lisp imagetwice. After some #lisp discussions, I realized there was a better way of doingthis. While the previous process still works, the new recommended process nowlooks like:</p><p> 在最一般的情况下，这涉及两次编译整个Lisp image。经过#lisp讨论后，我意识到有一种更好的方法。尽管先前的过程仍然有效，但新推荐的过程现在看起来像：</p><p> Build the image you would like to make into a static executable and save it.</p><p> 将您要制作的映像构建为静态可执行文件并保存。</p><p> Dump the foreign symbol info from this image and write the C file that SBCL can use to prelink itself.</p><p> 从此映像中转储外部符号信息，并写入SBCL可用来预链接自身的C文件。 </p><p> Compile that C file and link it into an existing sbcl.o file to make a new runtime. sbcl.o is the SBCL runtime in object form, created when building with the  :sb-linkable-runtime feature.</p><p>编译该C文件并将其链接到现有的sbcl.o文件中以创建新的运行时。 sbcl.o是对象形式的SBCL运行时，是使用：sb-linkable-runtime功能进行构建时创建的。</p><p> Load the image from step 1 into your new runtime. It will be compatible because the build ID and feature set are the same!</p><p> 将步骤1中的映像加载到新的运行时中。因为构建ID和功能集相同，所以它将兼容！</p><p> This new process can significantly reduce the amount of time needed to make anexecutable. Plus it lets you take more advantage of image baseddevelopment. It&#39;s fairly trivial to build an image exactly like you want, dumpit, and then pair it with a custom static runtime to make a static executable.</p><p> 此新过程可以大大减少使可执行文件所需的时间。另外，它还使您可以充分利用基于图像的开发功能。完全按照您的需要构建映像，然后将其转储，然后将其与自定义静态运行时配对以创建静态可执行文件，这是相当简单的。</p><p> There were two primary challenges that needed to be overcome for this versionof the patch set.</p><p> 对于此版本的补丁集，需要克服两个主要挑战。</p><p> First, the SBCL core had to be made robust to every libdl functionuncondtionally returning an error. Since we want the feature set to remainconstant we can&#39;t recompile the runtime with  #-os-provides-dlopen. Instead,we take advantage of the fact that Musl libc lets you link static executablesagainst libdl, but all those functions are noops. This is the &#34;purity&#34;sacrifice I alluded to above.</p><p> 首先，必须使SBCL内核对每个libdl函数都健壮，无条件地返回错误。由于我们希望功能集保持不变，因此我们无法使用＃-os-provides-dlopen重新编译运行时。相反，我们利用了Musl libc允许您相对于libdl链接静态可执行文件这一事实，但是所有这些功能都是noop。这是我上面提到的“纯度”牺牲。</p><p> Second, since we are reusing a image, the prelink info table (the generated Cfile) needed to order the symbols exactly as the image expects them to beordered. The tricky bit here is that some libraries (like  cl-plus-ssl) addsymbols to the linkage table that will always be undefined.  cl-plus-ssl doesthis in order to support a wide range of openssl versions. The previous patchset unconditionally filtered out undefined symbols, which horribly broke thingsin the new approach.</p><p> 其次，由于我们正在重用图像，因此需要按照图像期望对符号进行精确排序的方式对预链接信息表（生成的Cfile）进行排序。棘手的是，某些库（例如cl-plus-ssl）在链接表中添加了始终未定义的符号。 cl-plus-ssl这样做是为了支持各种opensl版本。先前的补丁集无条件地滤除了未定义的符号，这在新方法中令人震惊地破坏了一切。</p><p>  As before, after applying the patch you&#39;ll find a README.static-executable filein the root of the repo. You&#39;ll also find a Dockerfile and an example of how touse it in the README.static-executable.</p><p>  和以前一样，在应用补丁之后，您将在存储库的根目录中找到一个README.static-executable文件。您还将在README.static-executable中找到一个Dockerfile以及如何使用它的示例。 </p><p>   The  :sb-prelink-linkage-table feature does not work on 32-bit ARM + Musl libc &gt;= 1.2. Musl switched to 64-bit time under the hood while still mataining compatibility with everything compiled for 32-bit time.</p><p>：sb-prelink-linkage-table功能在32位ARM + Musl libc＆gt; = 1.2上不起作用。 Musl在后台转换为64位时间，同时仍然与所有为32位时间编译的内容保持兼容性。</p><p> The issue is how they maintained backwards compatibility. Every time related symbol still exists and implements everything on top of the 32-bit time interface. However, if you include the standard header file where the symbol is defined  or you look up the symbol via  dlsym you actually get a pointer to the 64-bit time version of the symbol. We can&#39;t use  dlsym (it doesn&#39;t work in static executables). And the generated C file doesn&#39;t include any headers.</p><p> 问题是它们如何保持向后兼容性。每次与时间相关的符号仍然存在，并在32位时间接口的顶部实现所有功能。但是，如果包括定义符号的标准头文件，或者通过dlsym查找符号，则实际上会得到一个指向该符号的64位时间版本的指针。我们不能使用dlsym（它在静态可执行文件中不起作用）。并且生成的C文件不包含任何标题。</p><p> This  could be fixed if someone is motiviated enough to create/find a complete, easy to use map between libc symbols and the headers that define them and integrate it into the prelink info generator.</p><p> 如果有人有足够的动力在libc符号和定义它们的标头之间创建/查找完整，易于使用的映射并将其集成到预链接信息生成器中，则可以修复此问题。</p><p> The  :sb-prelink-linkage-table works on Windows but causes test failures. The root issue is that mingw64 has implemented their own libm. Their trig functions are fast, but use inaccurate instructions (like FSIN) under the hood. When prelinking these inaccurate implementations are used instead of the more accurate ones (from msvcrt.dll ?) found when using  dlsym to look up the symbol.</p><p> ：sb-prelink-linkage-table在Windows上有效，但会导致测试失败。根本问题是mingw64已经实现了自己的libm。它们的触发功能很快，但是在后台使用了不正确的指令（例如FSIN）。当进行预链接时，将使用这些不准确的实现，而不是使用dlsym查找符号时发现的更准确的实现（来自msvcrt.dll吗？）。</p><p>  I would love to get feedback on this approach and any ideas on how to improve it! Please drop me a line (etimmons on Freenode or daewok on Github/Gitlab) if you have suggestions.</p><p>  我很乐意收到有关此方法以及如何改进它的任何想法的反馈！如果您有任何建议，请给我留言（Freenode上的emimmons或Github / Gitlab上的daewok）。</p><p> I&#39;ve already incorporated static executables into  CLPM and will be distributing them starting with v0.4.0! I&#39;m going to continue rolling out static executables in my other projects.</p><p> 我已经将静态可执行文件合并到CLPM中，并将从v0.4.0开始分发它们！我将继续在其他项目中推出静态可执行文件。</p><p> Pieces of the patch set are now solid enough that I think they can be submitted for upstream consideration. I&#39;ll start sending them after the current 2.1.2 freeze.</p><p> 补丁集的各个部分现在已经足够牢固，我认为可以将其提交上游考虑。当前2.1.2冻结后，我将开始发送它们。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.timmons.dev/posts/static-executables-with-sbcl-v2.html">https://www.timmons.dev/posts/static-executables-with-sbcl-v2.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sbcl/">#sbcl</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>