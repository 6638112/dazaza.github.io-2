<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>正则表达式文字优化（或如何欺骗基准） Regex literals optimization (or how to cheat on benchmarks)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Regex literals optimization (or how to cheat on benchmarks)<br/>正则表达式文字优化（或如何欺骗基准） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-12 17:49:10</div><div class="page_narrow text-break page_content"><p>The regex literals optimization avoids running the regex engine on parts of the input text that cannot possibly ever match the regex.</p><p>正则表达式文字优化可避免在输入文本的某些部分（可能无法与正则表达式匹配）上运行正则表达式引擎。</p><p> An example of a regex this can be applied to is  \w+@\w+\.\w+, where the algorithm  quickly finds the first  @, then matches  \w+ backwards to find the start of the match, and then matches  \w+\.\w+ forward to find the end of the match. It then finds the second  @, starting from the end of the previous match, and so on. This is a fairly naive (and incorrect) implementation, but it gives the idea of how it works.</p><p> 可以应用的正则表达式的一个示例是\ w + @ \ w + \。\ w +，其中算法快速找到第一个@，然后向后匹配\ w +以找到匹配的开始，然后匹配\ w + \。 \ w +向前查找比赛结束。然后，从上一个匹配项的末尾开始，找到第二个@，依此类推。这是一个相当幼稚的（并且不正确的）实现，但是它给出了其工作原理的想法。</p><p> I’ve recently implemented it in my pet project  nim-regex, an NFA based regex engine that runs in (super)linear time. The results show it’s around ~100x faster than before in some benchmarks. It’s up to ~60x faster than PCRE when the optimization kicks in. The tests are based on  mariomka/regex-benchmark.</p><p> 我最近在我的宠物项目nim-regex中实现了它，这是一个基于NFA的正则表达式引擎，可以在（超）线性时间内运行。结果表明，在某些基准测试中，它的速度比以前快了约100倍。进行优化后，它的速度比PCRE快60倍。测试基于mariomka / regex-benchmark。</p><p>   Since nim-regex has to guarantee linear time, I’ll describe optimizations that are guaranteed to take linear time. We must also ensure the matches are not overlapped.</p><p>   由于nim-regex必须保证线性时间，因此我将介绍保证线性时间的优化。我们还必须确保比赛不重叠。</p><p> I think the best way to understand how this optimization works is by example. However, here’s a high-level description of the algorithm:</p><p> 我认为了解这种优化方式的最佳方法是通过示例。但是，这是该算法的高级描述：</p><p> We pick a literal that is  memchr‘ed to skip parts of the text.</p><p> 我们选择一个用于跳过部分文本的文字。</p><p>  The prefix is the regex part before the literal; none of thecharacters or symbols within the prefix must match the literal.</p><p>  前缀是文字前的正则表达式部分；前缀中的任何字符或符号都不得与文字匹配。 </p><p>    A full scan is ran from the start of the matchuntil a character that cannot be matched is found (safe break point)or the end is reached. The scan tries to start the match at every character (NFAs can do this in linear time).</p><p>从匹配开始到完全扫描，直到找到无法匹配的字符（安全断点）或到达末尾。扫描尝试在每个字符处开始匹配（NFA可以在线性时间内执行此操作）。</p><p>  Go to step one and repeat from the last scanned char. Make the prefixmatch until the previous last scanned char.</p><p>  转到第一步，并从最后扫描的字符开始重复。进行前缀匹配，直到前一个最后扫描的字符为止。</p><p>  “none of the characters or symbols within the prefix must match the literal”, why? consider the regex:  \d\w+x, and the input text:  xxxxxxxxxxx; this would take quadratic time, as the prefix will match until the start of the string every time. What about the limit? while the limit does avoid the excessive matching, sometimes we’d need to match past the limit, ex: regex:  \d\w+x, and text:  1xxx. If we add this constraint, the literal becomes a delimeter, and these cases are solved.</p><p>  “前缀内的任何字符或符号都不得与文字匹配”，为什么？考虑正则表达式：\ d \ w + x，输入文本：xxxxxxxxxxx;这将花费二次时间，因为前缀将一直匹配到每次字符串的开头。限制呢？虽然限制确实避免了过度匹配，但有时我们需要匹配超出限制，例如：正则表达式：\ d \ w + x，文本：1xxx。如果添加此约束，则文字将成为分母，并且将解决这些情况。</p><p>  The literal cannot be part of a repetition, nor it can be part of an alternation. For example:  (abc)*def the first literal candidate is  d, since  (abc)* may or may not be part of the match. Same thing for alternations.</p><p>  文字不能是重复的一部分，也不能是替代的一部分。例如：（abc）* def第一个文字候选对象是d，因为（abc）*可能是匹配项，也可能不是匹配项的一部分。交替也一样。</p><p>  func  findAll (  matches :  var  Matches ,  text :  string ,  regex :  Regex ,  start :  int ):  int  =  var  i  =  start  var  limit  =  start  while  i  &lt;  text . len :  limit  =  i  # rather pointless since the literal is a delimiter  i  =  memchr ( text ,  regex . lit ,  i )  if  i  ==  - 1 :  return  - 1  var  litIdx  =  i  i  =  matchPrefix ( text ,  regex ,  i ,  limit )  if  i  ==  - 1 :  i  =  litIdx + 1  else :  i  =  findSome ( matches ,  text ,  regex ,  i )  if  i  ==  - 1 :  return  - 1  if  matches . len  &gt;  0 :  return  i  # this is used as &#34;start&#34; to resume the matching  return  - 1</p><p>  func findAll（matchs：var Matches，text：string，regex：Regex，start：int）：int = var i =起始var limit =在i ＜时开始文字。 len：limit = i＃相当没有意义，因为文字是定界符i = memchr（text，regex。lit，i）如果i ==-1：返回-1 var litIdx = ii = matchPrefix（text，regex，i，limit ）如果i ==-1：i = litIdx + 1；否则：i = findSome（匹配项，文本，正则表达式，i）；如果i ==-1：如果匹配项则返回-1。伦＆gt; 0：返回i＃用作＆＃34; start＆＃34;恢复匹配的收益-1</p><p> A given character may be consumed only twice, once by the backward prefix match, and a second time by the forward scan. Hence the algorithm runs in linear time.</p><p> 给定字符只能使用两次，一次通过后向前缀匹配，第二次通过前向扫描。因此，该算法以线性时间运行。</p><p> I may describe how  matchPrefix and  findSome work, how to construct the reversed NFA in the right order, and how to pick the literal in a future article. The nim-regex code contains descriptions of the algorithms, though.</p><p> 我可能会描述matchPrefix和findSome的工作原理，如何以正确的顺序构造反向NFA，以及如何在以后的文章中选择原义。但是，nim-regex代码包含算法的描述。 </p><p>  The  benchmarks regexes are based on  mariomka/regex-benchmark. The only difference is the regexes are pre-compiled, so just the matching is tested. The results show nim-regex is ~63x faster than PCRE in the email test, and ~2x faster in the URI and IP tests.</p><p>基准正则表达式基于mariomka / regex-benchmark。唯一的区别是正则表达式是预编译的，因此仅测试匹配项。结果显示，nim-regex在电子邮件测试中比PCRE快约63倍，在URI和IP测试中快约2倍。</p><p> Why is nim-regex so fast in the email case? The regex engine doesn’t run as often. There are orders of magnitud more IP/URI candidates than email candidates ( @ chars within the text) to match. In the former case the time is dominated by the regex engine, while in the latter case it’s dominated by searching the char literal.</p><p> 为什么nim-regex在电子邮件中如此之快？正则表达式引擎运行频率不高。匹配的IP / URI候选数比电子邮件候选数（文本中的@字符）大得多。在前一种情况下，时间由正则表达式引擎控制，而在后一种情况下，时间由搜索字符常量控制。</p><p> ==================================================GlobalBenchmark relative time/iter iters/s==================================================GlobalBenchmark 294.86ps 3.39G==================================================bench.nim relative time/iter iters/s==================================================pcre_email 21.76ms 45.96nim_regex_email 3247.14% 670.02us 1.49Knim_regex_email_macro 6335.93% 343.38us 2.91Kpcre_uri 22.15ms 45.14nim_regex_uri 92.82% 23.87ms 41.90nim_regex_uri_macro 256.29% 8.64ms 115.68pcre_ip 5.73ms 174.58nim_regex_ip 88.70% 6.46ms 154.84nim_regex_ip_macro 214.75% 2.67ms 374.91</p><p> ================================================== GlobalBenchmark相对时间/迭代次数/ s ========================================== ========全球基准294.86ps 3.39G ==================================== ============ bench.nim相对时间/迭代次数/ s =========================== ========================= pcre_email 21.76ms 45.96nim_regex_email 3247.14％670.02us 1.49Knim_regex_email_macro 6335.93％343.38us 2.91Kpcre_uri 22.15ms 45.14nim_regex_uri 87.82ms。 256.29％8.64ms 115.68pcre_ip 5.73ms 174.58nim_regex_ip 88.70％6.46ms 154.84nim_regex_ip_macro 214.75％2.67ms 374.91</p><p> Note Nim’s PCRE is at the top of the mariomka/regex-benchmark. I ran those benchmarks, and IIRC nim-regex was just a bit faster, mainly because the non-macro regex engine is slower (see the above results), and the regex compilation is also tested.</p><p> 注意Nim的PCRE位于mariomka / regex基准的顶部。我运行了这些基准测试，而IIRC nim-regex只是快了一点，主要是因为非宏regex引擎较慢（请参见上面的结果），并且还测试了regex编译。</p><p>   Picking a literal —even if the prefix matches it— should take linear time as long as the prefix is bounded (i.e: does not contain repetitions), ex:  \d\wx.</p><p>   选择一个文字（即使前缀与之匹配）也应花费线性时间，只要前缀是有界的（即：不包含重复项），例如：\ d \ wx。</p><p>  Picking a literal within a “one or more” repetition/repetition group should be possible, since  (abc)+ matches the same as  abc(abc)*.</p><p>  因为（abc）+与abc（abc）*相同，所以应该可以在“一个或多个”重复/重复组中选择一个文字。</p><p>  It’s better to pick the last literal within the first literal sequence, since that way we always try to match as many literals as possible early on, and potentially fail early. We want to keep the prefix regex as short as possible, so the picking a literal in the first sequence is best.</p><p>  最好在第一个文字序列中选择最后一个文字，因为这样一来，我们总是尽早匹配尽可能多的文字，并且可能会尽早失败。我们希望前缀regex尽可能短，因此在第一个序列中选择文字是最好的。 </p><p>  Alternations can be optimized this very same way in some cases, ex:  bar|baz, since both alternations have  ba in common,  a can be picked as the literal.</p><p>在某些情况下，交替可以以相同的方式进行优化，例如：bar | baz，由于两个交替都有ba相同，因此可以选择a作为文字。</p><p>  Alternations can be optimized in other cases. PCRE seems to use  memchr or similar for up to two alternation terms. A DFA could be used to quickly match candidates instead of  memchr, as that’s a more general solution.</p><p>  在其他情况下，可以优化替代方案。 PCRE似乎使用memchr或类似词来表示最多两个交替项。 DFA可以用来快速匹配候选人而不是memchr，因为这是更通用的解决方案。</p><p>  Literals optimization is not a general optimization as it does not work on every regex, but when it does, it can greatly improve the matching speed.</p><p>  文字优化不是通用优化，因为它不适用于每个正则表达式，但是当它适用时，可以大大提高匹配速度。</p><p> Can a backtracker like PCRE implement this? PCRE in particular already has some sort of similar optimization, but it’s not as good/fast as this one. Backtrackers cannot implement this as described here exactly, but they can do something similar that requires backtracking. If they provide a resumable  find function, then probably yes.</p><p> 像PCRE这样的回溯者可以实现吗？特别是PCRE已经进行了某种类似的优化，但是不如优化。回溯者无法完全按照此处的描述来实现此目的，但是他们可以执行需要回溯的类似操作。如果它们提供可恢复的查找功能，则可能是。</p><p> Hopefully, more regex engines will implement these sort of optimizations, so they are more compelling alternatives to backtrackers such as PCRE.</p><p> 希望更多的正则表达式引擎将实现这类优化，因此它们是PCRE等回溯者的更有吸引力的替代方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nitely.github.io/2020/11/30/regex-literals-optimization.html">https://nitely.github.io/2020/11/30/regex-literals-optimization.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文字/">#文字</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/literals/">#literals</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/匹配/">#匹配</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>