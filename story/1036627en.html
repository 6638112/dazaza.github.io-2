<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析器生成器DSL：使用Babel和JavaScript模板构建解析器Parser Generator DSLs: Building Parsers with Babel and JavaScript Templates</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parser Generator DSLs: Building Parsers with Babel and JavaScript Templates<br/>解析器生成器DSL：使用Babel和JavaScript模板构建解析器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 06:52:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1bf7db1cefcd5c92e57847aa36377f1c.png"><img src="http://img2.diglog.com/img/2020/11/1bf7db1cefcd5c92e57847aa36377f1c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Ever since I started working on  styled-components I’ve been fascinated by parsers. Writing a plugin forWebpack or Babel for the first time felt like pure magic, especially if the plugin doesn’t just transpilesome code for compatibility reasons or adds some metadata but instead generates entirely new codeor enables functionality that just isn’t feasibly implemented as runtime-only code.</p><p>自从我开始处理样式化组件以来，我一直对解析器着迷。第一次为Webpack或Babel编写插件感觉就像是纯粹的魔术，尤其是如果该插件不只是出于兼容性原因而传递一些可移植的代码或添加一些元数据，而是生成了全新的编码器或启用了无法在运行时实现的功能时，仅代码。</p><p> These days as JavaScript developers parsers are all around us. When we’re starting up aWebpack or Rollup process Acorn parses our code in the background. When we’re using a CSS-in-JSlibrary then there’s a good chance  stylis is parsing ourCSS code. When we’re using GraphQL the reference implementation’s parser diligently does its workin the background.</p><p> 这些天来，JavaScript开发人员解析器无处不在。当我们启动Webpack或汇总过程时，Acorn会在后台解析我们的代码。当我们使用CSS-in-JSlibrary时，stylis很可能会解析CSS代码。当我们使用GraphQL时，参考实现的解析器会在后台努力工作。</p><p> To me, nothing exemplifies this  omnipresence of parsers more than  “BabelMacros”, which is a Babel plugin that initself runs other plugins, which are embedded in special npm packages, called “macros”. Very meta.With macros, a package can feasibly appear as if it was just a JS library but use the fullpower of compile-time transpilation without us having to update our Babel config.For example,  eval.macro evaluates JS code inside tagged template literals during compile-time. Tagged template literals were even meant for embedding domain-specific languages(“DSLs”) into JavaScript, as Dr. Axel Rauschmayer writes  in his post onthem:</p><p> 对我而言，没有什么比“ BabelMacros”更能说明这种解析器的无处不在了。BabelMacros是一个Babel插件，它本身可以运行其他插件，这些插件嵌入特殊的npm软件包中，称为“ macros”。非常具有元功能，有了宏，程序包就可以看起来像只是一个JS库，但是可以使用编译时编译的全部功能，而无需更新Babel配置。例如，eval.macro在标记的模板文字中评估JS代码在编译时。正如Axel Rauschmayer博士在其主题文章中所写的那样，带有标记的模板文字甚至甚至旨在将特定领域的语言（“ DSLs”）嵌入到JavaScript中：</p><p> “In ECMAScript 6, template strings are a syntactic construct that facilitates the implementationof embedded DSLs in JavaScript.”</p><p> “在ECMAScript 6中，模板字符串是一种语法构造，有助于在JavaScript中实现嵌入式DSL。”</p><p> Given that macros can be used ad hoc to transpile any code, including tagged template literals,just by using importing a package, plugins like  eval.macro — which itself technically embedsJS into JS — can pre-compile some of their functionality:</p><p> 鉴于可以立即使用宏来转译任何代码，包括加标签的模板文字，只需使用导入包，eval.macro之类的插件（其技术上就将JS嵌入JS中）可以预编译其某些功能：</p><p> import  eval  from  &#39;eval.macro&#39; ; // using the macro this: const val  = eval  ` 7 * 6 ` ; // …turns into this: const val  =  42 ;</p><p> 从'eval.macro'导入eval; //使用以下宏：const val = eval`7 * 6`; // ...变成这样：const val = 42;</p><p> Parsers are indeed all around us and frequently grant us  amazing new abilities. But if we lookat the state of the JavaScript ecosystem from the perspective of native, compiled languages wemay notice that we can go a step further than this with  metacompilers, a fancy category ofprograms that also includes  parser generators. Parser Generators — an examplein JavaScript being  peg.js — allow us to write a parser in a DSL, whichoften looks similar to regular expressions, and subsequently generate the parser’s codeautomatically.</p><p> 解析器确实无处不在，并经常赋予我们惊人的新能力。但是，如果我们从本地编译语言的角度看待JavaScript生态系统的状态，我们可能会注意到，我们可以通过元编译器（比这还不错的程序类别，还包括解析器生成器）在此方面走得更远。解析器生成器（在JavaScript中是peg.js的一个示例）使我们可以在DSL中编写解析器，该解析器通常看起来与正则表达式类似，然后自动生成解析器的代码。</p><p> Parser Generators allow us to write a parser in a DSL, which oftenlooks similar to regular expressions, and subsequently output the parser itself automatically.</p><p>解析器生成器使我们可以在DSL中编写解析器，该DSL通常看起来与正则表达式相似，然后自动输出解析器本身。</p><p> This on its own is pretty useful knowledge, but knowing Babel Macros, I was wondering whetherit was feasible to create a macro that allowed me to write a  parsing grammar in a taggedtemplate literal and transpile it to a parser. If a parser generator in JS was able to outputcompact code that is still reasonably fast, it’d make itself very useful to create small &amp; quickDSLs that can be run in the browser. Let’s look at how I built  RegHex!</p><p> 这本身是非常有用的知识，但是了解Babel Macros后，我想知道创建一个宏是否可行，该宏可以使我以标记模板文字编写解析语法并将其转换为解析器。如果JS中的解析器生成器能够输出仍然相当快的紧凑代码，那么创建可在浏览器中运行的小型且快速的DSL本身将非常有用。让我们看看我如何构建RegHex！</p><p>  When jumping into a complex project like this, I typically start at both ends of the processand ask, “What should the library’s API look like?” and “What are the small implementationdetails I need some investigation first?” However, planning and starting are two steps that due to procrastination take me quite…a considerable amount of time.</p><p>  当进入这样一个复杂的项目时，我通常从流程的两端开始，问：“库的API应该是什么样？”和“小的实施细节是什么，我首先需要进行调查？”但是，计划和开始是两个步骤，由于拖延，我花了相当多的时间。</p><p> For this project, I came up with the rough idea for it about a year ago in 2019. I then wrote thefirst API design draft in April 2020, and implemented the library a month later in May 2020.I was pretty excited about the idea and have no excuses for this, so let’s just move on. Thefirst draft for the  API design looked something like the following:</p><p> 对于这个项目，我大约在一年前的2019年提出了一个粗略的想法。然后，我在2020年4月编写了第一个API设计草案，并在2020年5月一个月后实现了该库。没有任何借口，让我们继续前进。 API设计的初稿如下所示：</p><p> const identifier  =  match ( &#39;identifier&#39; )  `    ${ / [ -\w ] + / }  ` ; const string  =  match ( &#39;string&#39; )  `  (   ${ / &#34;[^&#34; ] *&#34; / }  |   ${ / &#39;[^&#39; ] *&#39; / }  ) ` ; const values  =  match ( &#39;values&#39; )  `  (   ${identifier }  |   ${string }  )* ` ; // Input: &#34;string&#34; // Output: [[&#39;&#34;string&#34;&#39;, .tag: &#39;string&#39;], .tag: &#39;values&#39;] // Input: ident // Output: [[&#39;ident&#39;, .tag: &#39;identifier&#39;], .tag: &#39;values&#39;]</p><p> const identifier = match（'identifier'）`$ {/ [-\ w] + /}`; const string = match（'string'）`（$ {/“ [^”] *“ /} | $ {/'[^'] *'/}）`; const values = match（'values'）`（ $ {identifier} | $ {string}）*`; //输入：“ string” //输出：[['“ string”'，.tag：'string']，.tag：'values'] //输入：ident //输出：[['ident'，.tag：'identifier']，.tag：'values']</p><p> The API’s general idea is to expose a  match function that is called with a parsing grammar’sname. It then is called as a tagged template literal with a regular expression-like grammar,which contains interpolations with either regular expressions or other grammars, which areused to recursively parse bits of the input.The output of  match can then be used to start parsing a string and will return an abstractsyntax tree (“AST”), nested nodes describing the parsed contents of the input.</p><p> API的一般想法是公开一个使用语法分析名称调用的match函数。然后将其称为带有正则表达式样语法的标记模板文字，其中包含具有正则表达式或其他语法的插值，用于对输入的位进行递归解析.match的输出可用于开始解析a字符串，并将返回一个抽象语法树（“ AST”），该嵌套节点描述输入的解析内容。</p><p> To control the logic of how inputs are parsed around the interpolations “operators” similarto a regular expression syntax are used, while regular expressions will match at the currentindex of the input. Since regular expression syntax is common in parser generators and isfamiliar to many, it felt rather natural to write, e.g.  | for matching something elseif the first part of a group didn’t match, or  * to allow for multiple matches.</p><p> 为了控制如何在插值周围解析输入的逻辑，使用了类似于正则表达式语法的“运算符”，而正则表达式将在输入的当前索引处匹配。由于正则表达式语法在解析器生成器中很常见，并且对许多语法生成器来说都很熟悉，因此编写例如|如果组的第一部分不匹配，则用于匹配其他内容；或*允许多个匹配。</p><p>  This initial draft revealed a crucial feature of my planned API. Because I chose to embedthe parsing grammar into JS code via a tagged template literal, the draft started lookinglike a “parser combinator”. In short,  parser combinatorsare functions that accept other parsers as inputs and return a new parser. In this case, match’s template optionally accepts other  match parsers as interpolations.</p><p>此初稿显示了我计划的API的关键功能。因为我选择通过标记的模板文字将解析语法嵌入JS代码，所以草稿开始看起来像“解析器组合器”。简而言之，解析器组合器是接受其他解析器作为输入并返回新解析器的函数。在这种情况下，比赛的模板可以选择接受其他比赛解析器作为插值。</p><p> The grammar in the draft API states that either an identifier or a string matches as often as possible, while the two are grammars of their own too.</p><p> API草案中的语法指出，标识符或字符串尽可能匹配，而两者也是它们自己的语法。</p><p> In short, parser combinators are functions that accept other parsers as inputs andreturn a new parser.</p><p> 简而言之，解析器组合器是接受其他解析器作为输入并返回新解析器的函数。</p><p> This allows a larger parser to be gradually composed from smaller, reusable bits of grammar, whichalso narrows down the task of generating parsing code to one small  match tag at a time. Asan API, this is what made tagged template literals a really compelling choice. To me, this feltsimilar to how styled-components splits up CSS for separate components, each rendering a singleelement with their own styles. 🤩 Tagged template literals naturally force a library’sAPI to  simplify and split up the exposed API surface.</p><p> 这允许较大的解析器由较小的可重用语法位逐渐组成，这也将一次生成解析代码的任务的范围缩小到一个小的匹配标记。作为Asan API，这就是使标记模板文字成为真正引人注目的选择的原因。对我来说，这类似于样式化组件如何将CSS拆分为单独的组件，每个组件都使用自己的样式来呈现单个元素。 🤩带有标签的模板文字自然会迫使库的API简化并拆分暴露的API表面。</p><p>  So far, the parser generator works by creating smaller pieces of grammar, defined by interpolatingother small matching grammars or regular expressions. Intuitively, the most straightforwardapproach to generate code from this would be to only transpile the pieces of grammar in thetemplate string, and to  reuse the interpolated regular expressions as is. Doing so withoutskipping over any characters in the input string is crucial however.</p><p>  到目前为止，解析器生成器通过创建较小的语法片段来工作，这些语法片段是通过插值其他小的匹配语法或正则表达式来定义的。直观地讲，从中生成代码的最直接方法是仅在模板字符串中转换语法片段，并按原样重用内插的正则表达式。但是，这样做的前提是不跳过输入字符串中的任何字符。</p><p> Executing a regular expression typically scans over an input string until a match is found,which is both costly and counter to how a parser works. Instead of scanning the string, whatthe parser generator needs is to attempt to match the regular expression only at an exactlocation. Luckily, in  ECMAScript 6 support for the  “stickyflag”was added, which does just that:</p><p> 执行正则表达式通常会扫描输入字符串，直到找到匹配为止，这既昂贵又与解析器的工作方式背道而驰。而不是扫描字符串，解析器生成器需要的是尝试仅在精确位置上匹配正则表达式。幸运的是，在ECMAScript 6中添加了对“ stickyflag”的支持，它的作用是：</p><p> const regex  =  new   ( &#39;hi&#39; ,  &#39;y&#39; ) ; const input  =  &#39;oh hi&#39; ;regex . lastIndex  =  0 ;regex . exec (input ) ;  // nullregex . lastIndex  =  3 ;regex . exec (input ) ;  // [&#39;hi&#39;, index: 3]regex . lastIndex ;  // 5</p><p> const regex = new（'hi'，'y'）; const input ='哦嗨';正则表达式。 lastIndex = 0; regex。 exec（输入）; // nullregex。 lastIndex = 3; regex。 exec（输入）; // ['hi'，索引：3] regex。 lastIndex; // 5</p><p> The  lastIndex property now indicates where the regular expression should be executed,rather than where it should start searching the input string. As usual, the index isalso moved along if the regular expression has successfully matched a part of the inputstring. This lends itself very well to building a continuous parser combinator thatconsists mostly of regular expressions and some branches and loops, and enables theparser generator to only transpile our custom DSL rather than also reimplementingregular expressions.</p><p>现在，lastIndex属性指示应在何处执行正则表达式，而不是从何处开始搜索输入字符串。与往常一样，如果正则表达式已成功匹配输入字符串的一部分，则索引也会随之移动。这非常适合于构建一个连续的解析器组合器，该组合器主要由正则表达式以及一些分支和循环组成，并使解析器生成器仅能够转换我们的自定义DSL，而不必重新实现正则表达式。</p><p>  Starting the implementation of this parser generator, this is where things become  meta.Since  match’s tagged template API I’ve outlined is in itself a language that looks likeregular expression syntax, a small parser for this DSL is necessary. Luckily, the syntaxthat this particular DSL has to support is rather small and hence the parser ended up beingquite easy to write and compact too.RegHex’s DSL was set to support  quantifiers, various types of groups,and alternations. As I’ve decided in the design process early on, it would be whitespaceinsignificant fore readability. Here’s a small overview of the operators that ended upin the DSL’s syntax:</p><p>  开始执行此解析器生成器后，事情就变成了元数据。由于我概述的匹配标签模板API本身就是一种类似于正则表达式语法的语言，因此需要用于此DSL的小型解析器。幸运的是，该特定DSL必须支持的语法很小，因此解析器最终也变得很容易编写和压缩。RegHex的DSL被设置为支持量词，各种类型的组和替换。正如我早在设计过程中所决定的那样，它对于空格的可读性意义不大。以下是以DSL语法结尾的运营商的简要概述：</p><p> A  quantifier may be used to change how many matches are accepted, in order: one or none, one or more, or any amount.</p><p> 量词可用于按顺序更改接受多少个匹配：一个或一个，一个或多个或任意数量。</p><p> An  alternation can be used to match either one thing or another, falling back when the first interpolation fails.</p><p> 交替可用于匹配事物，当第一个插值失败时回退。</p><p> A  non-capturing group is like a regular group, but the interpolations matched inside it don’t appear in the parser’s output.</p><p> 非捕获组类似于常规组，但是内部匹配的插值不会出现在解析器的输出中。</p><p> A  positive lookahead checks whether interpolations match, and if so continues the matcher without changing the input. If it matches, it’s essentially ignored.</p><p> 正前瞻将检查插值是否匹配，如果匹配，则匹配器将继续运行而不会更改输入。如果匹配，则基本上被忽略。</p><p> A  negative lookahead checks whether interpolations  don’t match, and if so continues the matcher without changing the input. If the interpolations do match the matcher is aborted.</p><p> 否定的超前检查会检查插值是否不匹配，如果匹配不匹配，则匹配器将继续而不更改输入。如果插值匹配，匹配器将中止。</p><p> Arguably, the most important feature of this syntax listed above is undoubtedly alternations,since a parser that can’t match several alternative patterns, won’t be able to express anyuseful grammar. Let’s look at an example of the RegHex DSL in action with a grammar thatmatches strings of repeated “this”s and “that”s:</p><p>可以说，上面列出的这种语法的最重要特征无疑是交替，因为解析器无法匹配几种替代模式，因此无法表达任何有用的语法。让我们来看一个RegHex DSL的示例，该DSL的语法与重复的“ this”和“ that”字符串匹配：</p><p> const thisThat  =  match ( &#39;thisThat&#39; )  `  (?:   ${ /and / } ) ( ((?!   ${ / . *that / } )   ${ / this / } +) | ((?!   ${ / . * this / } )   ${ /that / } +) ) ` ;</p><p> const thisThat = match（'thisThat'）`（？：$ {/ and /}）（（（？！$ {/。* that /}）$ {/ this /} +）|（（？！$ {/ * * this /}）$ {/ that /} +））`;</p><p> This snippet will only match a given input if it starts with “and”. However, “and” is in anon-capturing group and won’t be output to the AST node. It then matches either a repetitionof “this” or a repetition of “that”. There are negative lookahead groups which will makesure that we  don’t unnecessarily start parsing the entire string if any of the repeatedsequences contain both “this” and “that”.</p><p> 如果此代码段以“ and”开头，则只会匹配给定的输入。但是，“ and”属于非捕获组，不会输出到AST节点。然后，它匹配“ this”的重复或“ that”的重复。否定的前瞻性组将确保，如果任何重复序列同时包含“ this”和“ that”，我们就不必不必要地开始解析整个字符串。</p><p> Given that this is very similar to the behaviour of regular expressions and fairlyconcise this made me pretty optimistic in that this would be a usable syntax and API.</p><p> 鉴于这与正则表达式的行为非常相似并且非常简洁，这使我非常乐观，因为这将是可用的语法和API。</p><p> A diagram of our longer grammar of the matcher as shown in the code snippet above.</p><p> 上面的代码段中显示的匹配器较长语法的图。</p><p>  Finally, the last part of the endeavour was writing the Babel plugin code which would pickup all written grammars and replace them with parsing code. While writing the Babel codeitself wasn’t too hard, since I had some experience writing Babel plugins before, becauseone of the goals was to generate small &amp; quick code for the DSL, deciding  what the generatedparsing code’s patterns should be proved to be a little tricky. I decided early on togenerate code that is as compact as possible, which meant to me that each usage of  matchshould be compiled to only  a single function.</p><p>  最后，工作的最后一部分是编写Babel插件代码，该代码将提取所有已编写的语法并将其替换为解析代码。虽然自己编写Babel代码并不难，但由于我之前有编写Babel插件的经验，因为目标之一是为DSL生成小型快速代码，确定应证明生成的解析代码的模式有些棘手。我很早就决定生成尽可能紧凑的代码，这对我来说意味着match的每次使用都应编译为一个函数。</p><p> There are a lot of places in the parsing grammar where one part of the match may beunsuccessful and will jump to another — mostly due to alternations around groups.This means that there may be chained interpolations that the generated function willstart to match and, after failing, may give up on while skipping to the next partof the grammar after an alternation.</p><p> 解析语法中有很多地方匹配的一部分可能不成功，并且会跳转到另一部分-主要是由于组周围的交替。这意味着可能会有链式插值，生成的函数将开始匹配，并且在失败之后，可能会在交替后跳到语法的下一部分时放弃。</p><p>  For instance, given the above code, the grammar may match  1 and then repeatedly  2.However if at any point of the first part this grammar fails to match against theinput string, the function will still need to attempt to match  3. It needs to skipto  | ${3} and ensure that any results from the previously failed attempt arediscarded.</p><p>例如，给定上述代码，语法可能先匹配1，然后重复2。但是，如果在第一部分的任何一点上该语法与输入字符串不匹配，则该函数仍需要尝试匹配3。它需要skipto | $ {3}，并确保丢弃先前尝试失败的结果。</p><p>  Investigating some potential patterns for this problem, I discovered that just asingle solution seems to exist to have this amount of control in a single function,and this solution is — what I’d consider — quite an archaic language feature inJavaScript:  Labelled Block Statements.</p><p>  在研究该问题的一些潜在模式时，我发现似乎只有一个解决方案可以在单个函数中拥有如此多的控制权，而该解决方案（我认为）是JavaScript中的一种古老的语言功能：Labeled Block Statements。</p><p> We may not see this feature very often in handwritten JavaScript code, but anyloop or block may be annotated using a label. Once we have a label we may breakout of it by calling  break.</p><p> 我们可能不会在手写JavaScript代码中经常看到此功能，但是可以使用标签对anyloop或block进行注释。一旦有了标签，我们可以通过调用break突破它。</p><p> loop1 :  for  ( let i  =  0 ; i  &lt;  3 ; i ++ )  { loop2 :  for  ( let j  =  0 ; j  &lt;  3 ; j ++ )  {  if  (i  ===  1  &amp;&amp; j  ===  1 )  break loop1 ;  } }</p><p> loop1：for（令i = 0; i <3; i ++）{loop2：for（令j = 0; j <3; j ++）{if（i === 1 && j === 1）中断loop1; }}</p><p> This is quite useful for generated code that is trying to avoid additional functionsin its code output. However, if you use labels in your code a reviewer may likelyjust either complain or even exclaim in confusion. 🤷 As  MDN putsitin their explanation of labelled statements:</p><p> 这对于试图在其代码输出中避免附加功能的生成代码非常有用。但是，如果您在代码中使用标签，则审阅者可能会感到困惑甚至抱怨甚至惊叹。 M正如MDN所说，他们对带标签的陈述的解释是：</p><p> “Labelled loops or blocks are very uncommon. Usually, function calls can be used instead of loop jumps.”</p><p> 缩环或块很少见。通常，可以使用函数调用来代替循环跳转。”</p><p>  The Babel  code I wrotewasn’t much of a surprise at this point — although it did end up becoming messy — andsplits each part of the grammar into a separate “Node Class”, specialised in acceptinga part of  the parsed meta DSL and outputting generated code justfor this part of the grammar. Some classes of nodes are  QuantifierNode,  AlternationNode,or  GroupNode.</p><p>  我写的Babel代码在这一点上并不令人惊讶-尽管它最终变得一团糟-并将语法的每个部分拆分为一个单独的“节点类”，专门用于接受已解析的元DSL的一部分并输出生成的代码只为这部分语法。某些类别的节点为QuantifierNode，AlternationNode或GroupNode。</p><p> The resulting output of the  earlier example lookslike the following. I’ve annotated and modified the code snippet to be easier to read:</p><p>先前示例的结果输出如下所示。我已注释并修改了代码段，以使其更易于阅读：</p><p> // A helper function to execute sticky regexes and return the matched string import   { _exec  }  from  &#34;reghex&#34; ; const  parser  =  function  _parsed ( state )  {  // This creates the AST node, which is an array with a tag  const node  =  [ ] ; node . tag  =  &#34;parsed&#34; ;  let last_index  = state . index ;  let match ;  // This &#34;block_0&#34; contains the first group of our grammar block_0 :  {  var index_0  = state . index ;  var length_0  = node . length ;  // We first attempt to match &#34;1&#34;  if  (match  =  _exec (state ,   / 1 / y ) )  { node . push (match ) ;  }  else  {  // If we fail, we restore the node as it was, and break out of &#34;block_0&#34; node . length  = length_0 ; state . index  = index_0 ;  break block_0 ;  }  // We then attempt to match &#34;2&#34; repeatedly loop_1 :  for  ( var i  =  0 ;  true ; i ++ )  {  var index_1  = state . index ;  // Note that the matching itself is done the same, even in a loop  if  (match  =  _exec (state ,   / 2 / y ) )  { node . push (match ) ;  }  else  {  // If we had results we&#39;re good and can end the loop  if  (iter_1 )  { state . index  = index_1 ;  break loop_1 ;  }  // If we didn&#39;t, we again restore the node, and break out of &#34;block_0&#34; node . length  = length_0 ; state . index  = index_0 ;  break block_0 ;  }  }  // If we get here the first group matched. Success!  return node ;  }  // This is the second part of our grammar, where we attempt to match &#34;3&#34;  if  (match  =  _exec (state ,   / 3 / y ) )  { node . push (match ) ;  }  else  {  // there&#39;s nothing left anymore since the grammar is over  // restore the the index from before any matchers ran and return state . index  = last_index ;  return ;  }  // We matched a &#34;3&#34;. Success!  return node ; } ;</p><p> //一个辅助函数，用于执行粘性正则表达式并从“ reghex”返回匹配的字符串import {_exec}； const parser = function _parsed（state）{//这将创建AST节点，该节点是带有标签的数组const node = [];节点。 tag =“已解析”；让last_index = state。指标;让比赛; //这个“ block_0”包含我们语法的第一组block_0：{var index_0 = state。指标; var length_0 =节点。长度 ; // //如果（match = _exec（state，/ 1 / y））{node，我们首先尝试匹配“ 1”。推（比赛）; } else {//如果失败，我们将按原样还原该节点，然后脱离“ block_0” node。长度= length_0;状态。索引=索引_0;打破block_0; } //然后，我们尝试反复匹配loop_1的“ 2”：for（var i = 0; true; i ++）{var index_1 = state。指标; // //注意，即使（match = _exec（state，/ 2 / y））{node，即使在循环中，匹配本身也是一样。推（比赛）; } else {//如果我们有结果，我们就很好，如果（iter_1）{state，可以结束循环。 index = index_1;中断loop_1; } //如果没有，则再次还原该节点，然后脱离“ block_0”节点。长度= length_0;状态。索引=索引_0;打破block_0; }} //如果到达此处，则第一个组匹配。成功！返回节点; } //这是语法的第二部分，如果（match = _exec（state，/ 3 / y））{node，我们尝试匹配“ 3”。推（比赛）; } else {//自从语法结束以来，已经一无所有// //从匹配器运行并返回state之前恢复索引。索引= last_index;回报; } //我们匹配了“ 3”。成功！返回节点; };</p><p> In general,  each sequence that RegHex generatesfollows this same pattern of setting up a block, adding the prior index and node length to it,and then adding in the rest of the grammar recursively. It passes on a  break statement tothe lower nodes, which those can use to break out of a block.</p><p> 通常，RegHex生成的每个序列都遵循以下相同的模式：建立一个块，向其添加先验索引和节点长度，然后递归地添加其余语法。它会将break语句传递到较低的节点，这些较低的节点可用于中断一个块。</p><p> If you use labelled block statements in your code a reviewer may likely just either complainor even exclaim in confusion. 🤷</p><p> 如果您在代码中使用带标签的语句，则审阅者可能只是抱怨者中的任何一个甚至会感到困惑。 🤷</p><p> The trickiest part here is to even  read the code that the generator outputs,as it’s not very readable to humans. However, I believe it’s the  mostcompact code that can be generated given the requirements — and  Google’s ClosureCompiler, which is an optimisingJavaScript compiler, agrees! Closure Compiler actually outputs labelled blockstatements too when inlining some functions into loops. In fact, when I triedto  handcode the above example with inline functions instead, Closure Compilerturned those back into labelled block statements.</p><p> 这里最棘手的部分是甚至阅读生成器输出的代码，因为它对人类不是很可读。但是，我认为这是可以根据要求生成的最紧凑的代码-Google的ClosureCompiler（一种优化的JavaScript编译器）也同意！当将某些函数内联到循环中时，Closure Compiler实际上也会输出标记的语句块。实际上，当我尝试使用内联函数手动编码上面的示例时，Closure Compiler将它们转换回带有标签的语句。</p><p>  From an implementation standpoint, I’m quite pleased with the result. The APIthat I ended up with uses a lot of different ideas and language features allin a single project, which has been a rewarding learning experience and exercise.If you’ve read this far this post has already covered four broad topics:</p><p>  从实现的角度来看，我对结果感到非常满意。我最终使用的API在一个项目中都使用了许多不同的想法和语言功能，这是一次有益的学习体验和练习。如果您到目前为止已读过这篇文章，则已经涵盖了四个主题：</p><p>  To then put RegHex through its paces, I generated a parser for the  GraphQL querylanguage, which has been published as  graphql-parse. The grammar ended upbeing about  300 lines long and given that the generated implementation isreally compact the compiled output comes in at only about  2.6kB (minified andgzipped).</p><p>  为了使RegHex步入正轨，我为GraphQL查询语言生成了一个解析器，该解析器已发布为graphql-parse。语法结束时长约300行，并且考虑到生成的实现确实非常紧凑，因此编译后的输出仅约2.6kB（最小化并压缩）。</p><p> Because it looks nice and fits. The graphql-parse bundle in one image. Ok, old joke thanks to Jason Miller.</p><p>因为它看起来不错并且很合适。一个图像中的graphql-parse捆绑包。好的，老笑话要感谢Jason Miller。</p><p> Running some benchmarks reveals that, probably due to the non-trivial overhead ofregular expressions in JavaScript however, the performance of this parser is onlya third of the reference implementation. That being said, this is a little betterthan I expected given that RegHex is still a good tool for prototyping and createsa rather small parser implementation at  a fraction of the effort for developers.</p><p> 运行一些基准测试表明，可能是由于JavaScript中的正则表达式具有不小的开销，但是，此解析器的性能仅是参考实现的三分之一。话虽这么说，这比我预期的要好一些，因为RegHex仍然是原型制作和创建相当小的解析器实现的好工具，而开发人员的工作量很小。</p><p>  It’s worth noting that RegHex could also  support parsing entire tagged templateliterals, which would increase thelevel of meta-ness even more, since it’d allow RegHex to generate its own DSL’sparser, which would make it somewhat of a  self-hostingparser.</p><p>  值得注意的是，RegHex还可以支持解析整个带标签的模板文字，这将进一步提高元性水平，因为它允许RegHex生成自己的DSL分析器，这使其具有某种自我托管分析器的能力。</p><p> RegHex also doesn’t support errors very well, since it doesn’t unroll a nicestack to where parsing ultimately failed, which means it may not give any usefulhints as to what went wrong at all. Adding this could be a major improvementfor using its generated parsers in a build tool or server-side code.</p><p> RegHex也不能很好地支持错误，因为它无法将尼斯栈展开到最终导致解析失败的地方，这意味着它可能根本无法提供任何提示。添加此功能可能是对在构建工具或服务器端代码中使用其生成的解析器的一项重大改进。</p><p> However, given how many concepts RegHex’s code base touches, it was still aworthwhile experience to work on this proof of concept, despite its currentshortcomings.   Check out the code, if you’d like to learn more even more about RegHex!</p><p> 但是，考虑到RegHex的代码库涉及多少个概念，尽管存在当前的缺陷，但仍值得从事此概念验证工作。如果您想进一步了解RegHex，请查看代码！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kitten.sh/parser-generator-dsl">https://kitten.sh/parser-generator-dsl</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/generator/">#generator</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>