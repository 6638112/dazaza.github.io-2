<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go 1.18中如何实现泛型How generics are implemented in Go 1.18</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How generics are implemented in Go 1.18<br/>Go 1.18中如何实现泛型</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-03-02 05:02:50</div><div class="page_narrow text-break page_content"><p>This document describes the implementation of generics via dictionaries andgcshape stenciling in Go 1.18. It provides more concrete and up-to-dateinformation than described in the  Gcshape design document</p><p>本文档描述了Go 1.18中通过字典和GCShape模板的泛型实现。它提供了比Gcshape设计文档中描述的更具体和最新的信息</p><p> The compiler implementation of generics (after typechecking) focuses mainly on creating instantiations of generic functions and methods that will execute with arguments that have concrete types. In order to avoid creating a different function instantiation for each invocation of a generic function/method with distinct type arguments (which would be pure stenciling), we pass a  dictionary along with every call to a generic function/method. The  dictionary provides relevant information about the type arguments that allows a single function instantiation to run correctly for many distinct type arguments.</p><p>泛型的编译器实现（在类型检查之后）主要关注于创建泛型函数和方法的实例化，这些函数和方法将使用具有具体类型的参数执行。为了避免为具有不同类型参数的泛型函数/方法的每次调用创建不同的函数实例化（这将是纯粹的模板化），我们在每次调用泛型函数/方法时都会传递一个字典。字典提供了有关类型参数的相关信息，这些信息允许单个函数实例化为许多不同的类型参数正确运行。</p><p> However, for simplicity (and performance) of implementation, we do not have a single compilation of a generic function/method for all possible type arguments. Instead, we share an instantiation of a generic function/method among sets of type arguments that have the same gcshape.</p><p>然而，为了实现的简单性（和性能），对于所有可能的类型参数，我们没有单一的泛型函数/方法编译。相反，我们在具有相同gcshape的类型参数集之间共享泛型函数/方法的实例化。</p><p>  A  gcshape (or  gcshape grouping) is a collection of types that can all share the same instantiation of a generic function/method in our implementation when specified as one of the type arguments. So, for example, in the case of a generic function with a single type parameter, we only need one function instantiation for all type arguments in the same  gcshape grouping. Similarly, for a method of a generic type with a single type parameter, we only need one instantiation for all type arguments (of the generic type) in the same gcshape grouping. A  gcshape type is a specific type that we use in the implementation in such an instantiation to fill in for all types of the gcshape grouping.</p><p>gcshape（或gcshape grouping）是一组类型，当指定为类型参数之一时，这些类型在我们的实现中可以共享通用函数/方法的相同实例化。因此，例如，对于具有单个类型参数的泛型函数，对于同一gcshape分组中的所有类型参数，我们只需要一个函数实例化。类似地，对于具有单个类型参数的泛型类型的方法，我们只需要对同一gcshape分组中的所有类型参数（泛型类型）进行一次实例化。gcshape类型是我们在此类实例化的实现中使用的特定类型，用于填充gcshape分组的所有类型。</p><p> We are currently implementing gcshapes in a fairly fine-grained manner. Two concrete types are in the same gcshape grouping if and only if they have the same underlying type or they are both pointer types. We are intentionally defining gcshapes such that we don’t ever need to include any operator methods (e.g. the implementation of the “+” operator for a specified type arg) in a dictionary. In particular, fundamentally different built-in types such as  int and  float64 are never in the same gcshape. Even  int16 and  int32 have distinct operations (notably left and right shift), so we don’t put them in the same gcshape. Similarly, we intend that all types in a gcshape will always implement builtin methods (such as  make /  new /  len ) in the same way. We could include some very closely related built-in types (such as  uint and  uintptr) in the same gcshape, but are not currently doing that. This is already implied by our current fine-grain gcshapes, but we also always want an interface type to be in a different gcshape from a non-interface type (even if the non-interface type has the same two-field structure as an interface type). Interface types behave very differently from non-interface types in terms of calling methods, etc.</p><p>我们目前正在以一种相当细粒度的方式实现gcshapes。当且仅当两个具体类型具有相同的基础类型或它们都是指针类型时，它们才处于相同的gcshape分组中。我们有意定义gcshapes，这样就不需要在字典中包含任何运算符方法（例如，为指定类型arg实现“+”运算符）。特别是，本质上不同的内置类型（如int和float64）绝不是同一个形状。即使是int16和int32也有不同的操作（尤其是左移位和右移位），所以我们不把它们放在同一个形状中。类似地，我们希望gcshape中的所有类型始终以相同的方式实现内置方法（例如make/new/len）。我们可以在同一个gcshape中包含一些密切相关的内置类型（如uint和uintptr），但目前还没有这样做。我们目前的细粒度gcshape已经暗示了这一点，但我们也总是希望界面类型与非界面类型处于不同的gcshape中（即使非界面类型与界面类型具有相同的双场结构）。接口类型在调用方法等方面与非接口类型的行为非常不同。</p><p> We currently name each gcshape type based on the unique string representation (as implemented in  types.LinkString) of its underlying type. We put all shape types in a unique builtin-package “ go.shape”. For implementation reasons (see next section), we happen to include in the name of a gcshape type the index of the gcshape argument in the type parameter list. So, a type with underlying type “string” would correspond to a gcshape type named “ go.shape.string_0” or “ go.shape.string_1”, depending on whether the type is used as the first or second type argument of a generic function or type. All pointer types are named after a single example type  *uint8, so the names of gcshapes for pointer shapes are  go.shape.*uint8_0,  go.shape.*uint8_1, etc.</p><p>目前，我们根据基础类型的唯一字符串表示（在types.LinkString中实现）来命名每个gcshape类型。我们将所有形状类型放入一个独特的内置包“go.shape”。出于实现原因（请参见下一节），我们碰巧在gcshape类型的名称中包含了类型参数列表中gcshape参数的索引。因此，基础类型为“string”的类型将对应于名为“go.shape.string_0”或“go.shape.string_1”的gcshape类型，具体取决于该类型是用作泛型函数或类型的第一个类型参数还是第二个类型参数。所有指针类型都是以单个示例类型*uint8命名的，因此指针形状的gcshapes名称为go。形状*快去。形状*uint8_1等。</p><p> We refer to an instantiation of a generic function or method for a specific set of shape type arguments as a  shape instantiation.</p><p>我们将一组特定形状类型参数的泛型函数或方法的实例化称为形状实例化。</p><p>  Each dictionary is statically defined at compile-time. A dictionary corresponds to a call site in a program where a specific generic function/method is called with a specific set of concrete type arguments. A dictionary is needed whenever a generic function/method is called, regardless if called from a non-generic or generic function/method. A dictionary is currently named after the fully-qualified generic function/method name being called and the names of the concrete type arguments. Two example dictionary names are  main..dict.Map[int,bool] and  main..dict.mapCons[int,bool].Apply). These are the dictionaries needed for a call or reference to  main.Map[int, bool]() and  rcvr.Apply(), where  rcvr has type  main.mapCons[int, bool]. The dictionary contains the information needed to execute a gcshape-based instantiation of that generic function/method with those concrete type arguments. Dictionaries with the same name are fully de-duped (by some combination of the compiler and the linker).</p><p>每个字典都是在编译时静态定义的。字典对应于程序中的调用站点，其中使用一组特定的具体类型参数调用特定的泛型函数/方法。无论是从非泛型函数还是泛型函数/方法调用，每当调用泛型函数/方法时都需要字典。字典当前以被调用的完全限定的泛型函数/方法名和具体类型参数的名称命名。主要有两个字典名示例。。dict.Map[int，bool]和main。。dict.mapCons[int，bool]。应用）。这些是调用或引用main所需的词典。映射[int，bool]（）和rcvr。Apply（），其中rcvr具有main类型。mapCons[int，bool]。字典包含使用这些具体类型参数执行基于gcshape的泛型函数/方法实例化所需的信息。具有相同名称的词典被完全消除重复（通过编译器和链接器的某种组合）。</p><p> We can gather information on the expected format of a dictionary by analyzing the shape instantiation of a generic function/method. We analyze an instantiation, instead of the generic function/method itself, because the required dictionary entries can depend on the shape arguments - notably whether a shape argument is an interface type or not. It is important that the instantiation has been “transformed” enough that all implicit interface conversions ( OCONVIFACE) have been made explicit. Explicit or implicit interface conversions (in particular, conversions to non-empty interfaces) may require an extra entry in the dictionary.</p><p>通过分析泛型函数/方法的形状实例化，我们可以收集有关字典预期格式的信息。我们分析一个实例化，而不是泛型函数/方法本身，因为所需的字典条目可能取决于形状参数——尤其是形状参数是否是接口类型。重要的是，实例化已经“转换”到所有隐式接口转换（oconvidace）都显式的程度。显式或隐式接口转换（尤其是转换为非空接口）可能需要字典中的额外条目。</p><p> In order to create the dictionary entries, we often need to substitute the shape type arguments with the real type arguments associated with the dictionary. The shape type arguments must therefore be fully distinguishable, even if several of the type arguments happen to have the same shape (e.g. they are both pointer types). Therefore, as mentioned above, we actually add the index of the type parameter to the shape type, so that different type arguments can be fully distinguished correctly.</p><p>为了创建字典条目，我们通常需要用与字典关联的实际类型参数替换形状类型参数。因此，即使多个类型参数恰好具有相同的形状（例如，它们都是指针类型），形状类型参数也必须是完全可区分的。因此，如上所述，我们实际上将type参数的索引添加到shape类型中，这样就可以完全正确地区分不同的类型参数。</p><p>  The list of all (or needed) derived types, which appear in or are implicit in some way in the generic function/method, substituted with the concrete type arguments. That is, the list of concrete types that are specifically derived from the type parameters of the function/method (e.g.  *T,  []T,  map[K, V], etc) and used in some way in the generic function/method.</p><p>所有（或所需）派生类型的列表，这些派生类型出现在泛型函数/方法中，或以某种方式隐式出现在泛型函数/方法中，用具体的类型参数替换。也就是说，从函数/方法的类型参数（例如.*T、[]T、map[K、V]等）中具体派生并以某种方式在泛型函数/方法中使用的具体类型列表。</p><p> We currently use the derived types for several cases where we need the runtime type of an expression. These cases include explicit or implicit conversions to an empty interface, and type assertions and type switches, where the type of the source value is an empty interface.</p><p>目前，我们在需要表达式的运行时类型的情况下使用派生类型。这些情况包括到空接口的显式或隐式转换，以及类型断言和类型开关，其中源值的类型是空接口。</p><p> The derived type and type argument entries are also used at run time by the debugger to determine the concrete type of arguments and local variables. At compile time, information about the type argument and derived type dictionary entries is emitted with the DWARF info. For each argument or local variable that has a parameterized type, the DWARF info also indicates the dictionary entry that will contain the concrete type of the argument or variable.</p><p>在运行时，调试器还使用派生类型和类型参数项来确定参数和局部变量的具体类型。在编译时，有关类型参数和派生类型字典项的信息将与DWARF信息一起发出。对于具有参数化类型的每个参数或局部变量，DWARF信息还指示将包含参数或变量具体类型的字典条目。</p><p> The list of all sub-dictionaries: A sub-dictionary is needed for a generic function/method call inside a generic function/method, where the type arguments of the inner call depend on the type parameters of the outer function. Sub-dictionaries are similarly needed for function/method values and method expressions that refer to generic functions/methods.</p><p>所有子字典的列表：泛型函数/方法内部的泛型函数/方法调用需要一个子字典，其中内部调用的类型参数取决于外部函数的类型参数。对于引用泛型函数/方法的函数/方法值和方法表达式，同样需要子字典。</p><p> A sub-dictionary entry points to the normal top-level dictionary that is needed to execute the called function/method with the required type arguments, as substituted using the type arguments of the dictionary of the outer function.</p><p>子字典条目指向使用所需类型参数执行被调用函数/方法所需的普通顶级字典，使用外部函数字典的类型参数进行替换。</p><p> Any specific itabs needed for conversion to a specific non-empty interface from a type param or derived type. There are currently four main cases where we use dictionary-derived itabs. In all cases, the itab must come from the dictionary, since it depends on the type arguments of the current function. For all explicit or implicit  OCONVIFACE calls from a non-interface type to a non-empty interface. The itab is used to create the destination interface.</p><p>从类型参数或派生类型转换为特定非空接口所需的任何特定ITAB。目前，我们使用字典派生的ITAB主要有四种情况。在所有情况下，itab都必须来自字典，因为它取决于当前函数的类型参数。用于从非接口类型到非空接口的所有显式或隐式OConvidace调用。itab用于创建目标接口。</p><p> For all method calls on a type parameter (which must be to a method in the type parameter’s bound). This method call is implemented as a conversion of the receiver to the type bound interface, and hence is handled similarly to an implicit  OCONVIFACE call.</p><p>对于类型参数的所有方法调用（必须是类型参数绑定中的方法）。此方法调用作为接收方到类型绑定接口的转换来实现，因此处理方式类似于隐式oconvidace调用。</p><p> For all type assertions from a non-empty interface to a non-interface type. The itab is needed to implement the type assertion.</p><p>用于从非空接口到非接口类型的所有类型断言。需要itab来实现类型断言。</p><p> For type switch cases that involve a non-interface type derived from the type params, where the value being switched on has a non-empty interface type. As with type assertions, the itab is needed to implement the type switch.</p><p>对于涉及从类型参数派生的非接口类型的类型切换情况，其中打开的值具有非空接口类型。与类型断言一样，需要itab来实现类型切换。</p><p> We have decided that closures in generic functions/methods that reference generic values/types should use the same dictionary as their containing function/method. Therefore, a dictionary for an instantiated function/method should include all the entries needed for all bodies of the closures it contains as well.</p><p>我们已经决定，引用泛型值/类型的泛型函数/方法中的闭包应该使用与其包含的函数/方法相同的字典。因此，一个实例化函数/方法的字典应该包括它所包含的闭包的所有主体所需的所有条目。</p><p> The current implementation may have duplicate subdictionary entries and/or duplicate itab entries. The entries can clearly be deduplicated and shared with a bit more work in the implementation. For some unusual cases, there may also be some unused dictionary entries that could be optimized away.</p><p>当前实现可能有重复的子词典条目和/或重复的itab条目。通过在实现过程中多做一些工作，这些条目显然可以消除重复并共享。对于一些不寻常的情况，可能还有一些未使用的字典条目可以优化掉。</p><p>  Our choice to compute all dictionaries and sub-dictionaries at compile time does mean that there are some programs that we cannot run. We must have a dictionary for each possible instantiation of a generic function/method with specific concrete types. Because we require all dictionaries to be created statically at compile-time, there must be a finite, known set of types that are used for creating function/method instantiations. Therefore, we cannot handle programs that, via recursion of generic functions/methods, can create an unbounded number of distinct types (typically by repeated nesting of a generic type). A typical example is shown in  issue #48018. These types of programs are often called  non-monomorphisable. If we could create dictionaries (and instantiations of generic types) dynamically at run-time, then we might be able to handle some of these cases of non-monomorphisable code.</p><p>我们选择在编译时计算所有字典和子字典，这确实意味着有些程序无法运行。对于具有特定具体类型的泛型函数/方法的每个可能实例化，我们必须有一个字典。因为我们要求所有字典都在编译时静态创建，所以必须有一组有限的已知类型用于创建函数/方法实例化。因此，我们无法处理通过泛型函数/方法的递归可以创建无限多个不同类型（通常通过重复嵌套泛型类型）的程序。一个典型的例子见第48018期。这些类型的程序通常被称为非单态程序。如果我们能够在运行时动态创建字典（以及泛型类型的实例化），那么我们可能能够处理这些不可单态代码的情况。</p><p>  A compile-time instantiation of a generic function or method of a generic type is created for a specific set of gcshape type arguments. As mentioned above, we sometimes call such an instantiation a  shape instantiation. We determine on-the-fly during compilation which shape instantiations need to be created, as described below in “Compiler processing for calls to generic functions and methods”. Given a set of gcshape type arguments, we create an instantiated function or method by substituting the shape type arguments for the corresponding type parameters throughout the function/method body and header. The function body includes any closures contained in the function.</p><p>为一组特定的gcshape类型参数创建泛型函数或泛型类型方法的编译时实例化。如上所述，我们有时将这种实例化称为形状实例化。我们在编译过程中动态地确定需要创建哪些形状实例化，如下面的“调用泛型函数和方法的编译器处理”中所述。给定一组gcshape类型参数，我们通过在函数/方法体和头中用shape类型参数替换相应的类型参数来创建实例化的函数或方法。函数体包括函数中包含的任何闭包。</p><p> During the substitution, we also “transform” any relevant nodes. The old typechecker (the  typecheck package) not only determined the type of every node in a function or declaration, but also did a variety of transformations of the code, usually to a more specific node operation, but also to make explicit nodes for any implicit operations (such as conversions). These transformations often cannot be done until the exact type of the operands are known. So, we delay applying these transformations to generic functions during the noding process. Instead, we apply the transforms while doing the type substitution to create an instantiation. A number of these transformations include adding implicit  OCONVIFACE nodes. It is important that all  OCONVIFACE nodes are represented explicitly before determining the dictionary format of the instantiation.</p><p>在替换过程中，我们还“变换”任何相关节点。旧的typechecker（typecheck包）不仅确定了函数或声明中每个节点的类型，还对代码进行了各种转换，通常转换为更具体的节点操作，还为任何隐式操作（如转换）生成显式节点。在知道操作数的确切类型之前，通常无法进行这些转换。因此，我们会在点头过程中延迟将这些转换应用于泛型函数。相反，我们在进行类型替换以创建实例化时应用转换。其中许多转换包括添加隐式OConvidace节点。在确定实例化的字典格式之前，显式表示所有OConvidace节点非常重要。</p><p> When creating an instantiated function/method, we also automatically add a dictionary parameter “.dict” as the first parameter, preceding even the method receiver.</p><p>在创建实例化的函数/方法时，我们还会自动添加一个字典参数“.dict”作为第一个参数，甚至在方法接收者之前。</p><p> We have a hash table of shape instantiations that have already been created during this package compilation, so we do not need to create the same instantiation repeatedly. Along with the instantiated function itself, we also save some extra information that is needed for the dictionary pass described below. This includes the format of the dictionary associated with the instantiation and other information that is only accessible from the generic function (such as the bounds of the type params) or is hard to access directly from the instantiation body. We compute this extra information (dictionary format, etc.) as the final step of creating an instantiation.</p><p>我们有一个在这个包编译期间已经创建的形状实例化的哈希表，所以我们不需要重复创建相同的实例化。除了实例化的函数本身，我们还保存了下面描述的字典传递所需的一些额外信息。这包括与实例化相关联的字典的格式，以及只能从泛型函数（例如类型参数的边界）访问或很难直接从实例化体访问的其他信息。我们计算这些额外的信息（字典格式等），作为创建实例化的最后一步。</p><p>  In the compiler, the naming of generic and instantiated functions and methods is as follows:</p><p>在编译器中，泛型和实例化函数和方法的命名如下：</p><p> generic method - the receiver type with the type parameter that is used in the method definition, and the method name, such as  (*value[T]).Set. (As a reminder, a method cannot have any extra type parameters besides the type parameters of its receiver type.)</p><p>泛型方法-方法定义中使用的带有类型参数的接收器类型，以及方法名称，例如（*value[T]）。设置（提醒一下，除了接收方类型的类型参数外，方法不能有任何额外的类型参数。）</p><p> instantiated method - the receiver type with the type argument, and the method name, such as  (*value[int]).Set or  (*value[go.shape.string_0]).Set.</p><p>实例化方法——带有类型参数的接收方类型和方法名称，例如（*value[int]）。设置或（*值[go.shape.string_0]）。设置</p><p> Currently, because the compiler is using only dictionaries (never pure stenciling), the only function names that typically appear in the executable are the function and methods instantiated by shape types. Some methods instantiated by concrete types can appear if there are required itabs that must include references to these fully-instantiated methods (see the &#34;Itab dictionary wrappers&#34; section just below)</p><p>目前，由于编译器仅使用字典（从不使用纯模板），因此通常出现在可执行文件中的唯一函数名是由形状类型实例化的函数和方法。如果所需的Itab必须包含对这些完全实例化方法的引用，则可能会出现一些由具体类型实例化的方法（请参阅下面的&#34；Itab字典包装器&#34；部分）</p><p> Dictionaries are named similarly to the associated instantiated function or method, but with “.dict” preprended. So, examples include:  .dict.Max[float64] and  .dict.(*value[int]).get . A dictionary is always defined for a concrete set of types, so there are never any type params or shape types in a dictionary name.</p><p>字典的命名类似于相关的实例化函数或方法，但带有“.dict”前缀。例如：。dict.Max[float64]和。指令（*值[int]）。收到字典总是为一组具体的类型定义的，因此字典名称中从来没有任何类型参数或形状类型。</p><p> The concrete type names that are included in instantiated function and method names, as well as dictionary names, are fully-specified (including the package name, if not the builtin package). Therefore, the instantiated function, instantiated method, and dictionary names are uniquely specified. Therefore, they can be generated on demand in any package, as needed, and multiple instances of the same function, method, or dictionary will automatically be de-duplicated by the linker.</p><p>实例化的函数和方法名中包含的具体类型名，以及字典名，都是完全指定的（包括包名，如果不是内置包的话）。因此，实例化函数、实例化方法和字典名称是唯一指定的。因此，它们可以根据需要在任何包中按需生成，链接器将自动消除同一函数、方法或字典的多个实例的重复。</p><p>  For direct calls of generic functions or methods of generic types, the compiler automatically adds an extra initial argument, which is the required dictionary, when calling the appropriate shape instantiation. That dictionary may be either a reference to a static dictionary (if the concrete types are statically known) or to a sub-dictionary of the containing function’s dictionary. If a function value, method value, or method expression is created, then the compiler will automatically create a closure that calls the appropriate shape instantiation with the correct dictionary when the function or method value or method expression is called. A similar closure wrapper is needed when generating each entry of the itab of a fully-instantiated generic type, since an itab entry must be a function that takes the appropriate receiver and other arguments, but no dictionary.</p><p>对于泛型函数或泛型类型方法的直接调用，编译器在调用适当的形状实例化时会自动添加额外的初始参数，这是必需的字典。该字典可以是对静态字典（如果具体类型是静态已知的）的引用，也可以是对包含函数字典的子字典的引用。如果创建了函数值、方法值或方法表达式，那么编译器将自动创建一个闭包，在调用函数或方法值或方法表达式时，使用正确的字典调用相应的形状实例化。在生成完全实例化泛型类型的itab的每个条目时，需要一个类似的闭包包装器，因为itab条目必须是一个接受适当的接收方和其他参数的函数，而不是字典。</p><p>   Types2 typechecker (new) - the types2-typechecker is a new typechecker which can do complete validation and typechecking of generic programs. It is written to be independent of the rest of the compiler, and passes the typechecking information that it computes to the rest of the compiler in a set of maps.</p><p>Types2 typechecker（新）-Types2 typechecker是一种新的typechecker，可以完成通用程序的验证和类型检查。它被编写为独立于编译器的其余部分，并以一组映射的形式将其计算的类型检查信息传递给编译器的其余部分。</p><p> Noder pass (pre-existing, but completely rewritten to use the type2 typechecker information) - the noder pass creates the ir.Node representation of all functions/methods in the current package. We create node representations for both generic and non-generic functions. We use information from the types2-typechecker to set the type of each Node. Various nodes in generic functions may have types that depend on the type parameters. For non-generic functions, we do the normal transformations associated with the old typechecker, as mentioned above. We do not do the transformations for generic functions, since many of the transformations are dependent on concrete type information.</p><p>节点通行证（预先存在，但完全重写以使用type2 typechecker信息）——节点通行证创建ir。当前包中所有函数/方法的节点表示形式。我们为泛型和非泛型函数创建节点表示。我们使用来自types2 typechecker的信息来设置每个节点的类型。泛型函数中的各种节点可能具有依赖于类型参数的类型。对于非泛型函数，我们进行与旧的typechecker相关的常规转换，如上所述。我们不会对泛型函数进行转换，因为许多转换都依赖于具体的类型信息。</p><p> During noding, we record each fully-instantiated non-interface type that already exists in the source code. For example, any function (generic or non-generic) might happen to specify a variable of type ‘ List[int]’. We do the same thing when importing a needed function body (either because it is a generic function that will be instantiated or because it is needed for inlining).</p><p>在点头过程中，我们记录源代码中已经存在的每个完全实例化的非接口类型。例如，任何函数（泛型或非泛型）都可能碰巧指定“List[int]”类型的变量。我们在导入所需的函数体时也会做同样的事情（要么因为它是将被实例化的通用函数，要么因为它是内联所需的）。</p><p> The body of an exportable generic function is always exported, since an exported generic function may be called and hence need to be instantiated in any other package in which it is referenced. Similarly, the bodies of the methods of an exportable generic type are also always exported, since we need to instantiate these methods whenever the generic type is instantiated. Unexported generic functions and types may need to be exported if they are referenced by an inlinable function (see  crawler.go)</p><p>可导出泛型函数的主体始终是导出的，因为导出的泛型函数可能会被调用，因此需要在引用它的任何其他包中实例化。类似地，可导出泛型类型的方法体也总是导出的，因为我们需要在实例化泛型类型时实例化这些方法。如果未报告的泛型函数和类型被可内联函数引用，则可能需要导出它们（请参见crawler.go）</p><p> Scan pass (new) - a pass over all non-generic functions and instantiated functions that looks for references to generic functions/methods. At any such reference, it creates the required shape instantiation (if not yet created during the current compilation) and transforms the reference to use the shape instantiation and pass in the appropriate dictionary. The scan pass is executed repeatedly over all newly created instantiated functions/methods, until there are no more instantiations that have been created.</p><p>扫描传递（新）-传递所有非泛型函数和实例化函数，以查找泛型函数/方法的引用。在任何这样的引用中，它都会创建所需的形状实例化（如果在当前编译期间尚未创建），并将引用转换为使用形状实例化并传递到相应的字典中。扫描过程会在所有新创建的实例化函数/方法上重复执行，直到不再创建实例化为止。</p><p> At the beginning of each iteration of the scan pass, we create all the instantiated methods and dictionaries needed for each fully-instantiated type that has been seen since the last iteration of the scan pass (or from the noder pass, in the case of the first iteration of the scan pass). This ensures that the required method instantiations will be available when creating runtime type descriptors and itabs, including the itabs needed in dictionaries.</p><p>在扫描过程的每次迭代开始时，我们为每个完全实例化的类型创建所需的所有实例化方法和字典，这些类型是自扫描过程的最后一次迭代（或者在扫描过程的第一次迭代中，从节点过程）以来看到的。这确保了在创建运行时类型描述符和ITAB（包括字典中所需的ITAB）时，所需的方法实例化可用。</p><p> For each reference to a generic function/method in a function being scanned, we determine the GC shapes of the type arguments. If we haven’t already created the needed instantiation with those shape arguments, we create the instantiation by doing a substitution of types on the generic function header and body. The generic function may be from another package, in which case we need to import its function body. Once we have created the instantiation, we can then determine the format of the associated dictionary. We replace the reference to the generic function/method with a call (possibly in a closure) to the required instantiation with the required dictionary argument. If the reference is in a non-generic function, then the required dictionary argument will be a top-level static dictionary. If the reference is in a shape instantiation, then the dictionary argument will be a sub-dictionary entry from the dictionary of the containing function. We compute top-level dictionaries (and all their required sub-dictionaries, recursively) on demand as needed using the dictionary format information.</p><p>对于正在扫描的函数中对泛型函数/方法的每个引用，我们确定类型参数的GC形状。如果我们还没有用这些形状参数创建所需的实例化，我们可以通过替换泛型函数头和函数体上的类型来创建实例化。泛型函数可能来自另一个包，在这种情况下，我们需要导入它的函数体。一旦我们创建了实例化，我们就可以确定关联字典的格式。我们用调用（可能在闭包中）替换对泛型函数/方法的引用，用所需的字典参数调用所需的实例化。如果引用位于非泛型函数中，那么所需的dictionary参数将是顶级静态dictionary。如果引用在形状实例化中，那么dictionary参数将是包含函数的dictionary中的子dictionary条目。我们根据需要使用字典格式信息计算顶级字典（以及它们所需的所有子字典，递归）。</p><p> As with the noder pass, we record any new fully-instantiated non-interface type that is created. In the case of the scan pass, this type will be created because of type substitution. Typically, it will be for dictionary entries for derived types. If we were doing pure stenciling in some cases, then it would happen analogously when creating the concrete types in a purely stenciled function (no dictionaries).</p><p>与节点传递一样，我们记录创建的任何新的完全实例化的非接口类型。在扫描过程中，由于类型替换，将创建此类型。通常，它将用于派生类型的字典条目。如果我们在某些情况下使用纯模板，那么在纯模板函数（没有字典）中创建具体类型时也会发生类似的情况。</p><p> Dictionary pass (new) - a pass over all instantiated functions/methods that transforms operations that require a dictionary entry. These operations include calls to a method of a type parameter’s bound, conversion of a parameterized type to an interface, and type assertions and type switches on a parameterized type. This</p><p>字典传递（new）——传递所有实例化函数/方法，转换需要字典条目的操作。这些操作包括对类型参数绑定的方法的调用、参数化类型到接口的转换，以及参数化类型上的类型断言和类型开关。这</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/generics/">#generics</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>