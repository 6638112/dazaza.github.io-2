<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Futhark和Dex的比较 A Comparison of Futhark and Dex</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Comparison of Futhark and Dex<br/>Futhark和Dex的比较 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 01:52:11</div><div class="page_narrow text-break page_content"><p>Dex is a functional array programming language developed by a team of researchers at Google. I recently re-read  their paper, which got me excited enough to want to take a closer look. Dex and Futhark are more or less aimed at the same kinds of problems, so my interpretation of Dex is rooted in how it differs from Futhark. In this post I will describe some of the interesting differences based on  translating five Dex example programs to Futhark. I’m not a Dex expert, so maybe I’ve missed a thing here or there.</p><p>Dex是Google的一组研究人员开发的一种功能数组编程语言。最近，我重新阅读了他们的论文，这让我很兴奋，想仔细看看。 Dex和Futhark或多或少地针对相同类型的问题，因此我对Dex的解释植根于它与Futhark的不同之处。在这篇文章中，我将基于将五个Dex示例程序翻译为Futhark来描述一些有趣的区别。我不是敏捷专家，所以也许我错过了这里或那里的东西。</p><p> Futhark wasn’t originally designed to be a user-facing programming language. We were doing research in compiler optimisations for parallel computers, and the language was just a crude little thing so we could write programs for our optimiser to work on. Over time the language grew and eventually became fairly pleasant to use ( full story here), but it was still never designed as a cohesive or novel approach to array programming. That also means it’s fairly conventional or even old-fashioned, as functional languages go. In contrast, Dex’s authors had more imagination and designed their language from the start with novel ideas, chief of which is to consider  index sets as types. To illustrate the idea, here is how to compute all-pairs L₁ distances in Dex:</p><p> Futhark最初并不是设计成面向用户的编程语言。我们正在针对并行计算机的编译器优化进行研究，而该语言只是一件简陋的小事，因此我们可以编写程序供优化器使用。随着时间的流逝，语言逐渐发展起来，最终变得相当令人愉悦（此处为全文），但它仍然从未被设计为结合或新颖的数组编程方法。这也意味着，随着函数式语言的发展，它已经相当传统甚至过时了。相比之下，Dex的作者具有更多的想象力，并从一开始就用新颖的想法设计了他们的语言，其主要思想是将索引集视为类型。为了说明这一点，这里是如何计算Dex中所有对L₁距离的方法：</p><p> pairwiseL1 :: n=&gt;d=&gt;Real -&gt; n=&gt;n=&gt;RealpairwiseL1 x = for i j.sum (for k. abs (x.i.k - x.j.k))</p><p> pairwiseL1 :: n =＆gt; d =＆gt; Real-＆gt; n => n => RealpairwiseL1 x =对于i j.sum（对于k。abs（x.i.k-x.j.k））</p><p> The  n=&gt;d=&gt;Real is the type of an  n by  d array of  Reals. Dex leans heavily on an analogy between arrays and functions, as arrays can be seen as merely functions from indexes to values. In Futhark, we’d write this type as  [n][d]Real. Note that in Dex,  n and  d are completely abstract type parameters, while in Futhark they are term-level variables.</p><p> n ＝＞ d ＝＞ Real是n乘d的实数数组的类型。 Dex在很大程度上依赖于数组和函数之间的类比，因为数组可以看作仅仅是从索引到值的函数。在Futhark中，我们将此类型写为[n] [d] Real。请注意，在Dex中，n和d是完全抽象的类型参数，而在Futhark中，它们是术语级变量。</p><p> The real advantage of Dex’s approach is that it permits a very lightweight notation for index spaces. For example,  for i j.e produces a two-dimensional array where each element is given by the expression  e, and the type checker figures out the span of  i and  j based on the context. For example, in  for k, Dex figures out that  k must be part of the index set  d, because it is used to index the innermost dimension of  x. Pretty cool!</p><p> Dex方法的真正优点是它允许对索引空间使用非常轻量级的符号。例如，对于i j，e生成一个二维数组，其中每个元素都由表达式e给出，类型检查器根据上下文确定i和j的范围。例如，在for k中，Dex指出k必须是索引集d的一部分，因为它用于索引x的最内维度。太酷了！</p><p>  let pairwiseL1 [n][d] (x: [n][d]f64) =   tabulate_ 2d n n (\i j -&gt; f64.sum (tabulate d (\k -&gt; x[i,k] - x[j,k])))</p><p>  让pairwiseL1 [n] [d]（x：[n] [d] f64）=表格2d nn（\ ij-> f64.sum（表格d（\ k-> x [i，k]-x [ j，k]）））</p><p> Note that the tabulation functions require explicit size-passing, and that the indexes are just integers - the type checker will not help us if we accidentally use the  k along the wrong dimension.</p><p> 请注意，制表函数需要显式的大小传递，并且索引仅是整数-如果我们不小心沿错误的维度使用k，则类型检查器将无济于事。 </p><p> Of course, the above is not how you’d actually write this program in Futhark. Instead you’d first define a function for computing the L₁ distance:</p><p>当然，以上并不是您实际在Futhark中编写此程序的方式。相反，您首先要定义一个用于计算L₁距离的函数：</p><p> let L1 [n] (xs: [n]f64) (ys: [n]f64) : f64 =   map2 (-) xs ys |&gt; map f64.abs |&gt; f64.sum</p><p> 令L1 [n]（xs：[n] f64）（ys：[n] f64）：f64 ＝ map2（-）xsys |＞。映射f64.abs |＆gt; f64.sum</p><p>  let pairwiseL1 [n][m] (xss: [n][m]f64) : [n][n]f64 =   map (\a -&gt; map (\b -&gt; L1 a b) xss) xss</p><p>  让pairwiseL1 [n] [m]（xss：[n] [m] f64）：[n] [n] f64 = map（\ a-> map（\ b-> L1 a b）xss）xss</p><p> I think this program illustrates the main difference in philosophy between Dex and Futhark. While Dex uses dependent types to secure an index-based notation, Futhark instead encourages index-free programming. I suspect the two approaches are fundamentally equivalent, but it’s an interesting contrast that I think is due to the two language’s different backgrounds. Dex is specifically designed to implement scientific code and formulae, which is traditionally very index-oriented. Futhark is more about supporting a “traditional” combinator-based functional programming style, but just making it run much faster. You could view Futhark as a data-parallel ML, while Dex is  higher-order dependently typed Einstein summation.</p><p> 我认为该程序说明了Dex和Futhark之​​间在哲学上的主要区别。尽管Dex使用依赖类型来保护基于索引的表示法，但Futhark鼓励使用无索引编程。我怀疑这两种方法在根本上是等效的，但是我认为这是一个有趣的对比，原因是两种语言的背景不同。 Dex专为实现科学的代码和公式而设计，而科学的代码和公式在传统上非常面向索引。 Futhark的主要目的是支持基于“传统”组合器的函数式编程风格，但仅仅是使其运行速度更快。您可以将Futhark视为数据并行ML，而Dex是高阶依赖类型的爱因斯坦求和。</p><p> I also suspect this focus on indexes is because the Dex authors have a background of being frustrated with NumPy-style programming, where the absence of efficient indexing can be quite restrictive. They even even use this NumPy implementation of L₁ distances as motivation in their paper:</p><p> 我也怀疑这种对索引的关注是因为Dex作者的背景是对NumPy风格的编程感到沮丧，在这种情况下，缺乏有效的索引可能会造成很大的限制。他们甚至在论文中将L₁距离的NumPy实现用作动机：</p><p>    Porting a two-line Dex program to Futhark is enough to wax philosophically for a paragraph or two, but it’s still a pretty shallow comparison. Therefore, I also ported five of  the Dex example programs, plus whatever of the  Dex prelude I needed along the way. I’m not going to claim that I ported the five most difficult programs, but at least one of them was quite complicated. The Futhark programs total about 450 lines of code (excluding comments and blanks).</p><p>    将两行Dex程序移植到Futhark足以在哲学上修饰一两段，但这仍然是一个比较浅的比较。因此，我还移植了五个Dex示例程序，以及在此过程中需要的所有Dex前奏。我不会声称我已移植了五个最困难的程序，但其中至少有一个非常复杂。 Futhark程序总共约450行代码（不包括注释和空格）。</p><p> My general impression is that when it comes to expressing parallelism, Dex and Futhark are about equivalent. Dex’s index notation is more concise, but I personally find it slightly easier to understand and decompose Futhark expressions. As an example, this Dex function computes the covariance of a matrix:</p><p> 我的总体印象是，在表达并行性时，Dex和Futhark差不多。 Dex的索引符号更简洁，但我个人认为它更易于理解和分解Futhark表达式。例如，此Dex函数计算矩阵的协方差： </p><p> def covariance (n:Type) ?-&gt; (d:Type) ?-&gt; (xs:n=&gt;d=&gt;Float) : (d=&gt;d=&gt;Float) = xsMean : d=&gt;Float = (for i. sum for j. xs.j.i) / IToF (size n) xsCov : d=&gt;d=&gt;Float = (for i i&#39;. sum for j. (xs.j.i&#39; - xsMean.i&#39;) * (xs.j.i - xsMean.i ) ) / IToF (size n - 1) xsCov</p><p>def covariance（n：Type）？-> （d：Type）？-＆gt; （xs：n =＆gt; d =＆gt; Float）：（d =＆gt; d =＆gt; Float）= xsMean：d =＆gt; Float =（对于i。j。 n）xsCov：d =＆gt; d =＆gt; Float =（对于i i＆＃39; .j的总和（xs.j.i＆＃39;-xsMean.i＆＃39;）*（xs.ji-xsMean .i））/ IToF（大小n-1）xsCov</p><p>  let covariance0 [n] (xs:[n]f64) (xsm:f64) (ys:[n]f64) (ysm:f64) =   f64.sum (map2 (\x y -&gt; (x-xsm) * (y-ysm)) xs ys) / f64.i64 (n -1)     let covariance [n][d] (xs:[n][d]f64) =    let xsT = transpose xs    let means = map mean xsT    in map2 (\a a_mean -&gt;   map2 (\b b_mean -&gt; covariance0 a a_mean b b_mean)   xsT means)   xsT means</p><p>  让covariance0 [n]（xs：[n] f64）（xsm：f64）（ys：[n] f64）（ysm：f64）= f64.sum（map2（\ xy-＆gt;（x-xsm）*（ y-ysm））xs ys）/ f64.i64（n -1）让协方差[n] [d]（xs：[n] [d] f64）=让xsT =转置xs让均值=地图均值map2中的xsT （\ a a_mean-> map2（\ b b_mean-> covariance0 a a_mean b b_mean）xsT表示）xsT表示</p><p> It’s certainly more verbose, but I had to read the Dex function carefully to understand what the indexes implied, while I have a much easier time understanding the structure of the computation from the Futhark formulation. Of course, I also have years of experience with Futhark, compared to just days with Dex.</p><p> 当然，它比较冗长，但是我必须仔细阅读Dex函数才能理解索引的含义，而我却更容易理解Futhark公式的计算结构。当然，与Dex相比，我在Futhark方面也有多年的经验。</p><p> Most of the translations were pretty simple, for example the  Mandelbrot set,  Monte Carlo pi, and  Brownian motion programs. One difference that made me feel  major jealousy is that the  dex script command is also able to generate  pleasant reports containing both the code and visualisations and plots of various values. We definitely need a tool like this for Futhark!</p><p> 大多数翻译非常简单，例如Mandelbrot集，Monte Carlo pi和Brownian运动程序。让我感到非常嫉妒的一个区别是，dex脚本命令还能够生成令人愉悦的报告，其中包含代码以及各种值的可视化效果和图形。我们绝对需要这样的工具才能用于Futhark！</p><p> The  Sierpinski triangle program has a fun little detail in Dex, which is that the  randIdx function uses the Dex type system to determine the range of the index being produced. While the  randIdx function itself can still be wrong, this makes it hard to  use it incorrectly. The Futhark translation of  randIdx asks the user to pass in a range explicitly, and also returns just an integer.</p><p> Sierpinski三角程序在Dex中有一个有趣的小细节，那就是randIdx函数使用Dex类型系统来确定所生成索引的范围。尽管randIdx函数本身仍然可能是错误的，但这使得难以正确使用它。 randIdx的Futhark转换要求用户显式传递范围，并且仅返回整数。</p><p>  The largest ported example by far is  a ray tracer. It uses ray marching with  signed distance functions to describe objects. The Dex program rather casually uses the  grad operator to apply  automatic differentiation (AD) to compute surface normals from the distance function. This is a really elegant technique, but Futhark does not (yet!) have a  grad operator. In Futhark, the sensible thing to do is to hard-code the gradient functions for the three different kinds of objects, so of course I instead used  forward-mode AD with dual numbers implemented via the Futhark module system. The resulting code finally convinced me that built-in AD is a necessity for a modern numerical languages. I was on the fence before, since I worry that doing it well will be invasive in both the language and compiler, but I never want to write this kind of boilerplate again.</p><p>  到目前为止，最大的移植示例是光线跟踪器。它使用带有标志距离函数的光线行进来描述对象。 Dex程序相当随意地使用grad运算符应用自动微分（AD）来从距离函数计算表面法线。这是一种非常优雅的技术，但是Futhark（尚未！）没有Grad运算符。在Futhark中，明智的做法是对三种不同类型的对象的梯度函数进行硬编码，因此，我当然使用通过Futhark模块系统实现的具有双数的正向模式AD。最终的代码最终使我确信，内置AD是现代数字语言的必要条件。以前，我一直处于困境，因为我担心做得好对语言和编译器都具有侵入性，但是我再也不想写这种样板了。</p><p> The rest of the ray tracer was fairly straightforward to implement. Dex uses its effect system to implement the loop where the lights in the scene apply their contributions to a given point, which I wrote in Futhark as basically a fold. In fact, I didn’t yet find a Dex example where the effect system was more than a small notational convenience. I’m sure there’s one, though! Effect systems are not things you just add on a lark.</p><p> 射线追踪器的其余部分非常容易实现。 Dex使用其效果系统来实现循环，其中场景中的灯光将其贡献应用于给定点，这在我在Futhark中基本上是折叠的。实际上，我还没有找到Dex的示例，该示例中的效果系统不仅仅是一个小的符号上的便利。我敢肯定有一个！效果系统不是您刚刚添加的东西。 </p><p> There was one part that confused me initially, but which makes perfect sense in retrospect. The ray tracer normalises the intensity of all pixels (triples of floats) based on the average intensity (unusual I think, but fine). In Dex this is done like this:</p><p>最初有一部分让我感到困惑，但是回想起来，这很有意义。光线追踪器会根据平均强度（我认为是异常，但很好）对所有像素（三重浮子）的强度进行归一化。在Dex中，这样做是这样的：</p><p>  When I first read this, I couldn’t figure out whether it was normalising  per channel. I always get a bit wary when overloaded operators like that  / are involved. Of course, that  for-expression is over a  single index that just happens to be a triple, and the components of which are then used to index the three-dimensional  image array. It’s really just flattening the array, and the type checker makes the individual  i,  j and  ks take on the appropriate value.</p><p>  初读这篇文章时，我无法弄清楚它是否对每个频道都正常。当涉及到这样的重载运算符时，我总是会有些警惕。当然，该表达式是一个单一索引，而该索引恰好是三重索引，然后使用该索引的组件对三维图像阵列进行索引。它实际上只是使数组变平，并且类型检查器使各个i，j和ks取适当的值。</p><p>  With respect to expressing parallelism, Dex and Futhark seem equivalent in expressive power, but Dex has the edge in concision. I’d be curious about going the other way, and porting some of the original Futhark benchmark programs  to Dex, like  local volumetric calibration.</p><p>  关于表达并行性，Dex和Futhark在表达能力上似乎是等效的，但是Dex在简洁方面具有优势。我很好奇，反而将一些原始的Futhark基准程序移植到Dex，例如本地体积校准。</p><p> Dex has several small conveniences over Futhark: while the effect system didn’t matter much for the examples I looked at, Dex’s type classes and broadcasting operators did help a bit with making things more concise.</p><p> 与Futhark相比，Dex有几个小方便之处：虽然效果系统对我看过的示例并没有多大影响，但Dex的类型类和广播运营商确实在使事情变得更简洁方面有所帮助。</p><p> If you need AD, then Dex is miles ahead of Futhark. While I managed to implement the surface normals in the ray tracer, I gave up on porting  mcmc.dx because it contains a higher-order function that applies the  grad operator to a functional argument. This would have to be implemented with a higher order parametric module ( which I wrote were useless not long ago), but I just didn’t have the heart for it. I’ll keep this as a usage case for when we implement AD properly.</p><p> 如果您需要AD，那么Dex比Futhark领先几英里。当我设法在光线跟踪器中实现表面法线时，我放弃了移植mcmc.dx，因为它包含将grad运算符应用于函数自变量的高阶函数。这必须使用更高阶的参数模块来实现（我不久前写的没用），但我只是没有心。我将在适当实施AD时将其作为用例。</p><p> I didn’t look much at performance, since Dex is sparsely documented and the benchmarking tools seem to be mostly for internal use. I performed a rough timing of sequential execution of the ray tracer, where the Futhark and Dex versions are about equally fast. Dex also has multi-threaded and CUDA backends, but I did not try them.</p><p> 我对性能没什么要求，因为Dex的文档很少，基准测试工具似乎主要供内部使用。我对光线追踪器的顺序执行进行了大致计时，其中Futhark和Dex版本的速度差不多。 Dex还具有多线程和CUDA后端，但是我没有尝试。</p><p> Speaking of sparse documentation, Dex is still young and appears to be changing frequently. My understanding is based on  the paper, reading the example programs, and skimming some of the implementation. I may have missed important details, and this post may even be outdated by the time you read it.</p><p> 说到稀疏的文档，Dex还很年轻，并且似乎经常变化。我的理解是基于本文的内容，阅读示例程序，并浏览了一些实现。我可能错过了重要的细节，并且在您阅读本文时，该帖子甚至可能已过时。 </p><p>  I don’t think it would take that much effort to let Futhark be more implicit with respect to sizes. An easy start would be to permit return-size polymorphism, which would let us write a  tabulate function with this type:</p><p>我认为无需花费太多精力让Futhark在尺寸方面更加隐性。一个简单的开始就是允许返回大小的多态性，这将使我们编写具有以下类型的表格函数：</p><p>  Currently the Futhark type checker forbids size parameters that are used only in negative position. This restriction is mostly because I implemented the size type system on my own, and since I had little experience with implementing dependent type systems, I was worried about inadvertently admitting unsound constructs (and more pragmatically, I was worried about bugs in the implementation). I locked it down more than might strictly be necessary. If we want to support this kind of result size inference, then we do need to figure out what to do with expressions like</p><p>  当前，Futhark类型检查器禁止仅在负位置使用尺寸参数。这种限制主要是因为我自己实现了大小类型系统，并且由于我几乎没有实现依赖类型系统的经验，所以我担心无意间接受了不合理的结构（更实际的是，我担心实现中的错误）。我将其锁定的程度超出了绝对必要的范围。如果我们想支持这种结果大小推断，那么我们确实需要弄清楚如何处理像</p><p>  Here the size of the  tabulate must be the size of the array returned by  filter, which is existential. As far as I can figure based on the paper, Dex wouldn’t allow an expression like the above, as it handles existentials in an conventional and explicit manner:</p><p>  在此，表格的大小必须是filter返回的数组的大小，该数组是存在的。据我所知，Dex不允许上述表达式，因为它以常规和显式的方式处理存在性：</p><p>  Presumably it’s up to the user to do the unpacking of the existential context as needed. In Futhark I wanted to preserve “direct style” programming, so you could write expressions like  map f (filter p xs) where the compiler implicitly unpacks the existential context for you, but maybe the cost is too great.</p><p>  大概是由用户根据需要对存在的上下文进行解包。在Futhark中，我想保留“直接样式”编程，因此您可以编写诸如map f（过滤器p xs）之类的表达式，在该表达式中编译器会为您隐式解压缩存在的上下文，但代价可能会太大。</p><p> I think  some degree of Dex’s type-safe indexing can almost already be implemented in Futhark, especially if we loosen the above restriction that size parameters must be used in parameters. We already have an example where  “phantom sizes” are used to implement triangular arrays. Maybe Futhark should go more in the direction of dependent types? It’s unfortunate that we’re a small team, as it also takes a lot of time to write  papers about making the language go wrooooom…</p><p> 我认为某种程度的Dex的类型安全索引几乎可以在Futhark中实现，特别是如果我们放松了上述限制，即必须在参数中使用大小参数。我们已经有一个示例，其中“幻像大小”用于实现三角形阵列。也许Futhark应该在依赖类型的方向上走得更多？不幸的是，我们是一个小团队，因为花费大量时间来撰写有关使该语言逐渐发展的论文。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://futhark-lang.org/blog/2020-12-28-futhark-and-dex.html">https://futhark-lang.org/blog/2020-12-28-futhark-and-dex.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/futhark/">#futhark</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>