<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>修复Nvidia GeForce Experience中3年的错误 Fixing a 3 year old bug in Nvidia GeForce Experience</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fixing a 3 year old bug in Nvidia GeForce Experience<br/>修复Nvidia GeForce Experience中3年的错误 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-06 18:29:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/827ab061b9bb2b93b18575418ceadb72.jpeg"><img src="http://img2.diglog.com/img/2020/12/827ab061b9bb2b93b18575418ceadb72.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A few months ago, I thought I ought to try Microsoft Flight Simulator 2020.  The facsimile of our planet that Asobo had created with photogrammetry and machine learning seemed like a good place to relax,   &#34;in these trying times.&#34; I plugged in my trusty Logitech Freedom 2.4 wireless joystick and took to the skies.</p><p>几个月前，我认为我应该尝试使用Microsoft Flight Simulator2020。在这些艰难的时期，Asobo通过摄影测量和机器学习创建的地球传真机似乎是放松的好地方。 ;我插入了可靠的Logitech Freedom 2.4无线游戏杆，然后飞向天空。</p><p>   After spending a few hours flying around my alma mater and my childhood home, it was time to call it a day. I have my machine configured to turn off the displays after a few minutes of inactivity, and I quickly realized it wasn&#39;t doing that any longer.</p><p>   在我的母校和童年时代的家中呆了几个小时之后，就该将其称为“一天”了。我将计算机配置为在闲置几分钟后关闭显示器，然后我很快意识到它不再需要这样做了。</p><p> This isn&#39;t something I&#39;m altogether unfamiliar with. Sometimes it is a browser tab open with a sneaky video trying to play in the background, sometimes it is an issue with a web application, and sometimes it is a system task deciding it is too important to allow the machine to get anywhere near Standby/Sleep while it completes. On Windows, applications can request this privilege - of keeping the machine awake - from the operating system&#39;s  Kernel-Mode Power Manager. This is useful as you wouldn&#39;t want your machine going to sleep or turning off the display while you are watching a movie, playing a game, or copying a file. You can see such requests by opening an  elevated command prompt and running   powercfg /requests.</p><p> 这不是我完全不熟悉的东西。有时是打开浏览器选项卡，尝试在后台播放偷偷摸摸的视频，有时是Web应用程序的问题，有时是系统任务，决定是否允许机器靠近Standby /位置很重要。完成时进入睡眠状态。在Windows上，应用程序可以从操作系统的内核模式电源管理器请求此特权-保持计算机处于唤醒状态。这很有用，因为您不想在看电影，玩游戏或复制文件时让机器进入睡眠状态或关闭显示器。您可以通过打开提升的命令提示符并运行powercfg / requests来查看此类请求。</p><p>       I had an idea, though. I had previously contributed to a project called  procrastitracker, a fantastic little time tracking application for Windows, and the feature I implemented was  XInput activity detection. You see, I used the application to track how much time I spent playing games, and it thought my machine was idle when I was using the Xbox controller, so my change was just to have the application detect XInput as user activity. One thing I had noticed is that Windows does use controller inputs - not just mouse &amp; keyboard inputs - to determine that the machine is currently in use, and prevent the display from sleeping. I also noticed that one of my controllers&#39; analog inputs would actually drift around quite a bit, so my naïve implementation without deadzones was not going to work, or procrastitracker would think I was using my controller while I slept. Deadzones solved the issue with procrastitracker, and the controller never kept Windows awake, so that was good. Was my old Logitech joystick to blame? It is easily 15 years old by now. I unplugged the receiver and within minutes my display went to sleep.  Mystery solved!</p><p>       我有个主意。我以前曾参与一个名为procrastitracker的项目，这是一个用于Windows的出色的时间跟踪应用程序，我实现的功能是XInput活动检测。可以看到，我使用该应用程序来跟踪我玩游戏的时间，并且它以为我在使用Xbox控制器时机器处于闲置状态，所以我所做的更改只是让该应用程序将XInput检测为用户活动。我注意到的一件事是Windows确实使用了控制器输入-不仅是鼠标＆amp;键盘输入-确定机器当前正在使用，并防止显示器休眠。我还注意到我的一位控制员模拟输入实际上会漂移很多，所以我没有死区的天真的实现无法正常工作，或者拖延追踪器会认为我睡觉时正在使用控制器。死区通过procrastitracker解决了该问题，并且该控制器从未使Windows保持清醒，因此很好。是我的罗技摇杆老怪吗？到现在已经15岁了。我拔下接收器的电源，数分钟后显示器进入睡眠状态。谜团已揭开！</p><p>   I&#39;d made a few upgrades to my computer in the months since, which included getting a better joystick, and a throttle, and some flight rudder pedals. Windows still wasn&#39;t letting the display sleep with them plugged in, but I decided I should look into the issue more. Looking at the USB Game Controllers control panel with the new joystick plugged in, I noticed absolutely no drift. No analog instability. No spurious inputs. It certainly wasn&#39;t the device&#39;s activity keeping the machine awake, I was sure of that now.</p><p>   从那以后的几个月中，我对计算机进行了一些升级，包括获得更好的操纵杆，节气门和一些飞行舵踏板。 Windows仍然不能让显示器在插入显示器后进入休眠状态，但是我决定我应该进一步研究这个问题。看着插入了新游戏杆的USB游戏控制器控制面板，我发现绝对没有漂移。没有模拟不稳定。无虚假输入。肯定不是设备的活动使机器保持清醒状态，我现在确定了这一点。</p><p>   I decided to do what&#39;s worked so well in the past - I asked Google.</p><p>   我决定做过去做得很好的事情-我问Google。</p><p>   And Google knew.  People had tracked the issue down to the NVIDIA&#39;s GeForce Experience overlay, sometimes called ShadowPlay (or NVIDIA Share). It&#39;s a piece of software that allows you to use the NVIDIA graphics cards&#39;  NVENC encoder to capture compressed video in real time. People use it to share videos of moments in video games, and it&#39;s very handy because NVENC is  good. Compressing high-resolution high-framerate video in real time on the CPU while maintaining quality would be quite a difficult task, especially for a machine already tasked with running a video game, and NVENC produces quality output without much additional load on the machine by leveraging fixed-function encoding hardware in the GPU. It&#39;s cool stuff, so I didn&#39;t want to just get rid of it.</p><p>   而且Google知道。人们已经将问题归结为NVIDIA的GeForce Experience叠加层，有时也称为ShadowPlay（或NVIDIA Share）。它是一款软件，可让您使用NVIDIA显卡。 NVENC编码器可实时捕获压缩视频。人们使用它来共享视频游戏中的瞬间视频，因为NVENC很好，所以非常方便。在保持质量的同时，在CPU上实时压缩高分辨率高帧率视频将是一项艰巨的任务，特别是对于已经负责运行视频游戏的机器，并且NVENC可以通过利用机器而在机器上不增加额外负载的情况下产生高质量的输出GPU中的固定功能编码硬件。它是很酷的东西，所以我不想摆脱它。 </p><p> So the issue is such: If you have a joystick plugged in, and the GeForce Experience overlay enabled, your display will not sleep. If you unplug the joystick, the display sleeps. If you disable the overlay, the display sleeps. You can have one or the other - but not both.</p><p>因此，问题是这样的：如果插入了操纵杆，并且启用了GeForce Experience覆盖，则显示器将无法进入睡眠状态。如果拔下操纵杆，显示屏将进入休眠状态。如果禁用覆盖，则显示器将休眠。您可以拥有一个，但不能同时拥有。</p><p> People hadn&#39;t just tracked the issue down - people tracked it down 3 years ago!</p><p> 人们还没有找到问题的根源-人们在3年前就找到了它！</p><p>     I couldn&#39;t really believe the issue had gone unresolved for so long. So I reported a bug.</p><p>     我真的不能相信这个问题已经解决了很长时间了。所以我报告了一个错误。</p><p>     I&#39;m sure they&#39;ll figure it out, but I wanted to have a crack at it. When you enable the overlay, many processes start up - all of the NVIDIA ones at the top.</p><p>     我确定他们会弄清楚的，但我想对此有所帮助。启用覆盖后，将启动许多进程-所有NVIDIA进程都位于顶部。</p><p>      Each one loads many modules:   My initial theory was that the overlay was perhaps probing the controllers for input, and translating those events into  Windows messages. If it was injecting messages into one of its processes, maybe as keyboard events, perhaps some default event handling routine was resetting the system idle state. I had no evidence, but what I knew was that it wasn&#39;t Windows acting alone. The NVIDIA software was causing the issue, but the overlay doesn&#39;t react to joystick input anyway, so I somehow doubted that it was an accidental side-effect of intentional joystick-handling code. Abusing Win32  isn&#39;t unusual among GPU makers, so I expected it would be something weird. I should note at this point I am not an expert in Win32. On the other hand, I do own  Raymond Chen&#39;s book and I&#39;ve read it, too.  The Old New Thing  is a great blog. I&#39;m still a bit lost here, though.</p><p>      每个模块都加载许多模块：我的最初理论是，覆盖图可能正在探测控制器的输入，并将这些事件转换为Windows消息。如果它正在将消息注入其进程之一（可能作为键盘事件），则可能是某些默认事件处理例程正在重置系统空闲状态。我没有证据，但是我知道的不是Windows单独运行。 NVIDIA软件是造成此问题的原因，但是覆盖层无论如何都不会对操纵杆输入做出反应，因此我以某种方式怀疑这是故意操纵杆处理代码的意外副作用。在GPU制造商中滥用Win32并不少见，因此我希望这会很奇怪。在这一点上，我应该指出我不是Win32专家。另一方面，我确实拥有Raymond Chen的书，并且也已阅读。旧的新事物是一个很棒的博客。不过，我在这里仍然有些失落。</p><p> I digress. First I needed a way to identify when the issue was happening without waiting for the display to sleep, so I quickly wrote a simple application that dumps the output of  GetLastInputInfo. I didn&#39;t expect this function to be authoritative on the system idle state - you want to get  SYSTEM_POWER_INFORMATION from CallNtPowerInformation for that - but it proved to be effective.</p><p> 我离题了。首先，我需要一种方法来确定何时发生问题，而无需等待显示器进入休眠状态，因此我快速编写了一个简单的应用程序，该应用程序转储了GetLastInputInfo的输出。我不希望此功能在系统空闲状态下具有权威性-您希望为此从CallNtPowerInformation获取SYSTEM_POWER_INFORMATION-但事实证明它是有效的。</p><p>    I attached to  NVIDIA Share.exe in  x64dbg and started looking for things related to input.</p><p>    我附加到x64dbg中的NVIDIA Share.exe，并开始寻找与输入有关的内容。 </p><p>    I knew Xinput wasn&#39;t causing the issue - that&#39;s only for Xbox Controllers and those who emulate them, plus I knew procrastitracker was in the background polling Xinput all the time anyway and didn&#39;t cause this. What I did notice was that even with the process suspended in the debugger (and my little application monitoring idle state), I could see it was still getting reset. There are many processes it spawned, I thought, so I went through and suspended them one by one (killing them one by one doesn&#39;t work - they restart immediately). The idle state kept resetting. This was a huge clue - it means the application wasn&#39;t running any code to do this. It wasn&#39;t injecting messages or anything of the sort.  It has to be something it does on initialization.</p><p>我知道Xinput并不是问题的根源-仅适用于Xbox Controller和模拟它们的人，另外我知道procrastitracker一直在后台轮询Xinput并没有造成此问题。我确实注意到的是，即使在调试器中暂停了进程（并且我的小应用程序监视着空闲状态），我仍然可以看到它仍在重置。我认为，它产生了许多过程，因此我一一进行了暂停，并一一暂停了（一一杀死它们是行不通的-它们会立即重新启动）。空闲状态保持复位状态。这是一个巨大的线索-这意味着该应用程序没有运行任何代码来执行此操作。它不是在注入消息或任何类似的东西。它必须是初始化时要做的事情。</p><p> I wanted to see how NVIDIA Share initializes, in the debugger, but it&#39;s complicated. You can&#39;t start it directly, it needs to be started by  nvcontainer.exe. It starts three copies of it, each with different parameters. They probably communicate with each other, as well, so their environment would have to be carefully managed to bring them up manually. Not insurmountable by any means, but there were other things to try. I thought it would be neat if I could attach &amp; break in x64dbg as soon as the process starts, and  some tips pointed me to  WinDbg&#39;s  gflags.exe utility.</p><p> 我想看看NVIDIA Share是如何在调试器中初始化的，但是它很复杂。您不能直接启动它，它需要由nvcontainer.exe启动。它开始三个副本，每个副本具有不同的参数。它们之间也可能相互通信，因此必须仔细管理其环境以手动启动它们。任何方式都不是无法克服的，但是还有其他尝试。我认为如果可以附加＆amp;该过程开始后立即中断x64dbg，并且一些提示将我引向了WinDbg的gflags.exe实用程序。</p><p>  Theoretically you can use it to throw a key in the registry that tells Windows to execute a particular &#39;image&#39; (executable) with a debugger when it&#39;s encountered. I wasn&#39;t able to get this to work - maybe because the process is spawned by  nvcontainer, or maybe I just hadn&#39;t done it correctly.</p><p>  从理论上讲，您可以使用它在注册表中抛出一个键，该键告诉Windows执行特定的“图像”。 （可执行），当遇到调试器时。我无法使其正常工作-可能是因为该过程是由nvcontainer产生的，或者也许我只是没有正确地完成它。</p><p> Luckily, we have  Ghidra. I did the same silly thing that I did in the debugger, I loaded up the most obvious executable ( NVIDIA Share.exe) and asked the most obvious question.</p><p> 幸运的是，我们有吉德拉。我做了与调试器中相同的愚蠢的事情，加载了最明显的可执行文件（NVIDIA Share.exe），并提出了最明显的问题。</p><p>   This was immediately promising! But first, I had to do some reading. Raw input isn&#39;t something that I&#39;m familiar with. Back in the good old days, there was DirectInput. DirectInput let you do force feedback, DirctInput let you have tons of buttons and axes, and at least on Windows it made using games controllers generally a smoother experience than it had been in the past, where games needed to support your particular controller (or your controller&#39;s drivers needed to emulate another, more popular controller). After DirectInput came Xinput, and Xinput is very much built around the Xbox Controller. You don&#39;t get any more buttons or axes than an Xbox Controller can have. You can&#39;t connect more controllers than an Xbox would be able to connect. It &#34;just works&#34;, but it&#39;s not the kind of API that supports uses like this:</p><p>   这是立即有希望的！但是首先，我必须做一些阅读。原始输入不是我熟悉的东西。在过去的美好时光中，有了DirectInput。 DirectInput使您可以进行强制反馈，DirctInput使您拥有大量的按钮和轴，至少在Windows上，使用游戏控制器所获得的体验通常比过去需要用户支持特定控制器（或您的游戏）的体验更为流畅。控制器的驱动程序来模拟另一个更流行的控制器）。在DirectInput出现Xinput之后，Xinput很大程度上围绕Xbox Controller构建。您没有获得比Xbox Controller更多的按钮或轴。您无法连接比Xbox能够连接的控制器更多的控制器。它可以正常工作，但是它不是支持以下用途的API：</p><p>    Now that heavyweight API is raw input. Anything that conforms to the HID standard will have its events passed through, and your role as an application developer is to support the  HID usage pages that you deem appropriate. I especially like that in the middle of the Simulations Control page (0x02) is the usage ID for Magic Carpet Simulation (0x0B). Standards committees think of everything.  So, what is NVIDIA Share doing with raw input?  RegisterRawInputDevices. Don&#39;t worry, I can clean it up a bit:  It&#39;s registering its window handle to receive raw events from the keyboard at all times (regardless of which window is in the foreground). Keyboard, bummer. Not joystick. But it gave me an idea. What if I expand my little application to request raw input as well? What about DirectInput? Can I replicate the issue without NVIDIA&#39;s software? I spent one night and one day implementing various inputs methods, relearning Win32, and learning DirectInput ... and  COM ... again.</p><p>    现在，重量级API是原始输入。符合HID标准的所有事件都将通过其事件，并且您作为应用程序开发人员的作用是支持您认为适当的HID使用页面。我特别喜欢“模拟控制”页面（0x02）中间的内容，它是Magic Carpet Simulation（0x0B）的使用ID。标准委员会考虑了一切。那么，NVIDIA Share如何处理原始输入？ RegisterRawInputDevices。不用担心，我可以对其进行一些清理：它正在注册其窗口句柄，以随时接收来自键盘的原始事件（无论哪个窗口位于前台）。键盘，笨拙。不是操纵杆。但这给了我一个主意。如果我还要扩展小应用程序以请求原始输入怎么办？那么DirectInput呢？如果没有NVIDIA软件，是否可以复制该问题？我花了一整天的时间来实现各种输入方法，重新学习Win32，并再次学习DirectInput ...和COM...。</p><p>   Enabling raw input either as a system-wide input sink ( dwFlags = RIDEV_INPUTSINK 0x100) or only on foreground focus ( default, dwFlags = 0x0) causes devices to flood the HWND&#39;s message queue with   WM_INPUTs, and prevents the system from becoming idle. My suggestion to Microsoft would be to make this clearer in the documentation, and to have an application requesting raw input show up in  powercfg /requests and in  WPA. The application I wrote to demonstrate the issue is available here:  https://github.com/nuzayets/rawinput-debug/</p><p>   将原始输入启用为系统范围的输入接收器（dwFlags = RIDEV_INPUTSINK 0x100）或仅在前台焦点上启用（默认值dwFlags = 0x0）会导致设备使用WM_INPUT泛洪HWND消息队列，并阻止系统成为闲。我对Microsoft的建议是在文档中更清楚地说明这一点，并在powercfg / requests和WPA中显示一个请求原始输入的应用程序。我编写的用于演示该问题的应用程序可在以下位置找到：https://github.com/nuzayets/rawinput-debug/ </p><p>  Not directly, anyhow. NVIDIA Share is partially built upon  CEF, Chromium Embedded Framework. Why be happy with only wrapping your head around esoteric desktop development when you can throw frustrating web development into the mix? The more the merrier, I say. We didn&#39;t need that RAM anyway.</p><p>无论如何，不​​是直接的。 NVIDIA Share部分基于CEF Chromium嵌入式框架。当您将令人沮丧的Web开发混为一谈时，为什么只为专注于深奥的桌面开发而高兴呢？我说，越多越好。无论如何，我们不需要那个RAM。</p><p> NVIDIA Share loads the Chromium Embedded Framework as an &gt;100MB module called  libcef.dll. This took Ghidra a bit of time to analyze, but I found the interesting bit.</p><p> NVIDIA Share将Chromium嵌入式框架作为称为libcef.dll的大于100MB的模块加载。 Ghidra花了一些时间进行分析，但是我发现了有趣的一点。</p><p>    They request raw input as part of their gamepad driver, which makes sense. They call that  FUN_1842af9b4 to set up its parameters in all cases. Here is that function:</p><p>    他们要求原始输入作为其游戏手柄驱动程序的一部分，这很有意义。他们在任何情况下都称FUN_1842af9b4来设置其参数。这是该函数：</p><p>             Luckily there wasn&#39;t any code patching to do. The values for the usage IDs live in the  .rdata section of the executable (that  DAT_1861e16e8 in Ghidra&#39;s decompilation).  The file is  C:\Program Files\NVIDIA Corporation\NVIDIA GeForce Experience\libcef.dll and with my version of GeForce Experience (3.20.5.70), the offending byte was at  0x61e0ae8. Changing  the  0x04 to a  0x06 means that instead of trying to get raw input from joysticks, they get it from the keyboard instead. I&#39;m still not sure why the NVIDIA overlay was asking for raw joystick input from Chromium.</p><p>             幸运的是，没有任何代码修补程序可做。使用ID的值位于可执行文件（在Ghidra的反编译中为DAT_1861e16e8）的.rdata节中。该文件为C：\ Program Files \ NVIDIA Corporation \ NVIDIA GeForce Experience \ libcef.dll，在我的GeForce Experience版本（3.20.5.70）中，有问题的字节位于0x61e0ae8。将0x04更改为0x06意味着他们不是尝试从操纵杆获取原始输入，而是从键盘获取原始输入。我仍然不确定为什么NVIDIA叠加层要求从Chromium输入原始操纵杆。</p><p>  I spent two days on this, and it ended up being one byte in the end. At least now my computer can sleep.</p><p>  我花了两天的时间，最后结果是一个字节。至少现在我的电脑可以入睡了。</p><p>       If you don&#39;t want to try using a hex editor,  this Powershell script will do it for you.</p><p>       如果您不想尝试使用十六进制编辑器，则此Powershell脚本将为您完成此操作。</p><p> Please disable the overlay first, and make sure Powershell is run as Administrator so you are able to write to the directory.</p><p> 请首先禁用该覆盖，并确保Powershell以管理员身份运行，以便您能够写入该目录。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://details-of-note.blogspot.com/2020/12/nvidia-3-year-old-bug.html">https://details-of-note.blogspot.com/2020/12/nvidia-3-year-old-bug.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/nvidia/">#nvidia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/year/">#year</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>