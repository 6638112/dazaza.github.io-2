<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>最后，一个只有量子计算机才能解决的问题(2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">最后，一个只有量子计算机才能解决的问题(2018)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 01:59:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/47b797d963157e2be9c3b465530cc1c2.jpg"><img src="http://img2.diglog.com/img/2020/11/47b797d963157e2be9c3b465530cc1c2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Early on in the study of quantum computers, computer scientists posed a question whose answer, they knew, would reveal something deep about the power of these futuristic machines. Twenty-five years later, it’s been all but solved. In a paper  posted online at the end of May, computer scientists  Ran Raz and  Avishay Tal provide strong evidence that quantum computers possess a computing capacity beyond anything classical computers could ever achieve.</p><p>在量子计算机研究的早期，计算机科学家提出了一个问题，他们知道，这个问题的答案将深刻揭示这些未来机器的力量。25年后，这个问题几乎解决了。在5月底发布在网上的一篇论文中，计算机科学家朗·拉兹(Run Raz)和阿维沙伊·塔尔(Avishay Tal)提供了强有力的证据，证明量子计算机拥有传统计算机无法实现的计算能力。</p><p> Raz, a professor at Princeton University and the Weizmann Institute of Science, and Tal, a postdoctoral fellow at Stanford University, define a specific kind of computational problem. They prove, with a certain caveat, that quantum computers could handle the problem efficiently while traditional computers would bog down forever trying to solve it. Computer scientists have been looking for such a problem since 1993, when they first defined a class of problems known as “BQP,” which encompasses all problems that quantum computers can solve.</p><p>普林斯顿大学(Princeton University)和魏茨曼科学研究所(Weizmann Institute Of Science)教授拉兹(Raz)和斯坦福大学(Stanford University)博士后研究员塔尔(Tal)定义了一种特定的计算问题。他们证明，有一定的警告，量子计算机可以有效地处理这个问题，而传统计算机将永远陷入困境，试图解决这个问题。自1993年以来，计算机科学家一直在寻找这样的问题，当时他们首次定义了一类被称为BQP的问题，这类问题涵盖了量子计算机可以解决的所有问题。</p><p>  Since then, computer scientists have hoped to contrast BQP with a class of problems known as “PH,” which encompasses all the problems workable by any possible classical computer — even unfathomably advanced ones engineered by some future civilization. Making that contrast depended on finding a problem that could be proven to be in BQP but not in PH. And now, Raz and Tal have done it.</p><p>从那时起，计算机科学家们就希望将BQP与一类被称为“PH”的问题进行对比，“PH”涵盖了任何可能的经典计算机所能解决的所有问题--甚至包括由某些未来文明设计的深不可测的高级问题。进行这种对比取决于找到一个可以被证明存在于BQP而不是PH中的问题。现在，拉兹和塔尔做到了。</p><p> The result does not elevate quantum computers over classical computers in any practical sense. For one, theoretical computer scientists already knew that quantum computers can solve any problems that classical computers can. And engineers are still  struggling to build a useful quantum machine. But Raz and Tal’s paper demonstrates that quantum and classical computers really are a category apart — that even in a world where classical computers succeed beyond all realistic dreams, quantum computers would still stand beyond them.</p><p>这一结果在任何实际意义上都不会使量子计算机超越经典计算机。首先，理论计算机科学家已经知道量子计算机可以解决经典计算机所能解决的任何问题。工程师们仍在努力建造一台有用的量子机。但拉兹和塔尔的论文证明，量子计算机和经典计算机实际上是一个截然不同的类别-即使在一个经典计算机取得了超越所有现实梦想的成功的世界里，量子计算机仍然会超越它们。</p><p>  A basic task of theoretical computer science is to  sort problems into complexity classes. A complexity class contains all problems that can be solved within a given resource budget, where the resource is something like time or memory.</p><p>理论计算机科学的一项基本任务是将问题归类为复杂类。复杂性类包含在给定资源预算内可以解决的所有问题，其中资源是时间或内存之类的东西。</p><p> Computer scientists have found an efficient algorithm, for example, for testing whether a number is prime. They have not, however, been able to find an efficient algorithm for identifying the prime factors of large numbers. Therefore, computer scientists believe (but have not been able to prove) that those two problems belong to different complexity classes.</p><p>例如，计算机科学家已经找到了一种有效的算法来测试一个数字是否为质数。然而，他们还没有找到一种有效的算法来识别大数的素因数。因此，计算机科学家认为(但还无法证明)这两个问题属于不同的复杂性类别。</p><p> The two most famous complexity classes are “P” and “NP.” P is all the problems that a classical computer can solve quickly. (“Is this number prime?” belongs to P.) NP is all the problems that classical computers can’t necessarily solve quickly, but for which they can quickly verify an answer if presented with one. (“What are its prime factors?” belongs to NP.) Computer scientists believe that P and NP are distinct classes, but actually proving that distinctness is the hardest and most important open problem in the field.</p><p>最著名的两个复杂类是“P”和“NP”。P是经典计算机可以快速解决的所有问题。(“这个数字是质数吗？”属于P.)。NP是经典计算机不一定能快速解决的所有问题，但如果有答案，它们可以快速验证答案。(“它的主要因素是什么？”属于NP。)。计算机科学家认为P和NP是两个截然不同的类别，但实际上证明其区分性是该领域最困难和最重要的公开问题。</p><p>  In 1993 computer scientists Ethan Bernstein and  Umesh Vazirani defined a new complexity class that they called BQP, for “bounded-error quantum polynomial time.” They defined this class to contain all the decision problems — problems with a yes or no answer — that quantum computers can solve efficiently. Around the same time they also proved that quantum computers can solve all the problems that classical computers can solve. That is, BQP contains all the problems that are in P.</p><p>1993年，计算机科学家伊桑·伯恩斯坦(Ethan Bernstein)和乌梅什·瓦兹拉尼(Uesh Vazirani)定义了一个新的复杂性类别，他们称之为BQP，意为“有界误差量子多项式时间”。他们将这一类定义为包含量子计算机可以有效解决的所有决策问题--答案为是或否的问题。大约在同一时间，他们还证明了量子计算机可以解决经典计算机能够解决的所有问题。也就是说，BQP包含了P中的所有问题。</p><p>  But they could not determine whether BQP contains problems not found in another important class of problems known as “PH,” which stands for “polynomial hierarchy.” PH is a generalization of NP. This means it contains all problems you get if you start with a problem in NP and make it more complex by layering qualifying statements like “there exists” and “for all.” 1 Classical computers today can’t solve most of the problems in PH, but you can think of PH as the class of all problems classical computers could solve if P turned out to equal NP. In other words, to compare BQP and PH is to determine whether quantum computers have an advantage over classical computers that would survive even if classical computers could (unexpectedly) solve many more problems than they can today.</p><p>但他们无法确定BQP是否包含另一类重要问题“PH”中没有的问题，PH代表“多项式层次”。PH是NP的推广。这意味着它包含了你从NP问题开始的所有问题，并通过层次化限定语句，如“存在”和“为了所有人”，使问题变得更加复杂。1今天的经典计算机不能解决PH中的大多数问题，但你可以把PH看作是如果P被证明等于NP，那么经典计算机可以解决的所有问题的类别。换句话说，比较BQP和PH就是确定量子计算机是否比经典计算机更有优势，即使经典计算机(出人意料地)能够解决比现在多得多的问题，经典计算机也能存活下来。</p><p> “PH is one of the most basic classical complexity classes there is,” said  Scott Aaronson, a computer scientist at the University of Texas at Austin. “So we sort of want to know, where does quantum computing fit into the world of classical complexity theory?”</p><p>德克萨斯大学奥斯汀分校(University Of Texas At Austin)的计算机科学家斯科特·亚伦森(Scott Aaronson)说：“PH是最基本的经典复杂性课程之一。”“所以我们有点想知道，量子计算在经典复杂性理论的世界中处于什么位置？”</p><p> The best way to distinguish between two complexity classes is to find a problem that is provably in one and not the other. Yet due to a combination of fundamental and technical obstacles, finding such a problem has been a challenge.</p><p>区分两个复杂性类别的最好方法是找到一个可以证明存在于其中一个而不是另一个中的问题。然而，由于基本面和技术上的障碍，找到这样一个问题一直是一个挑战。</p><p> If you want a problem that is in BQP but not in PH, you have to identify something that “by definition a classical computer could not even efficiently verify the answer, let alone find it,” said Aaronson. “That rules out a lot of the problems we think about in computer science.”</p><p>Aaronson说，如果你想要一个存在于BQP而非PH中的问题，你必须找出一些“根据定义，经典计算机甚至无法有效地验证答案，更不用说找到它了”。“这排除了我们在计算机科学中思考的很多问题。”</p><p>  Here’s the problem. Imagine you have two random number generators, each producing a sequence of digits. The question for your computer is this: Are the two sequences completely independent from each other, or are they related in a hidden way (where one sequence is the “Fourier transform” of the other)? Aaronson introduced this “forrelation” problem in 2009 and proved that it belongs to BQP. That left the harder, second step — to prove that forrelation is not in PH.</p><p>这就是问题所在。假设您有两个随机数生成器，每个生成器都产生一个数字序列。你的计算机面临的问题是：这两个序列是完全相互独立的，还是以一种隐藏的方式联系在一起的(其中一个序列是另一个序列的“傅立叶变换”)？Aaronson在2009年提出了这个“关联”问题，并证明它属于BQP。这就留下了更难的第二步--证明For Relationship不在PH中。</p><p>  Which is what Raz and Tal have done, in a particular sense. Their paper achieves what is called “oracle” (or “black box”) separation between BQP and PH. This is a common kind of result in computer science and one that researchers resort to when the thing they’d really like to prove is beyond their reach.</p><p>这就是拉兹和塔尔在某种意义上所做的事情。他们的论文实现了BQP和PH之间所谓的“先知”(或“黑箱”)分离。这在计算机科学中是一种常见的结果，当他们真正想要证明的东西超出了他们的能力范围时，研究人员就会求助于这种结果。</p><p> The actual best way to distinguish between complexity classes like BQP and PH is to measure the computational time required to solve a problem in each. But computer scientists “don’t have a very sophisticated understanding of, or ability to measure, actual computation time,” said  Henry Yuen, a computer scientist at the University of Toronto.</p><p>区分BQP和PH等复杂类的实际最佳方法是测量解决每类复杂类中的问题所需的计算时间。但多伦多大学(University Of Toronto)的计算机科学家亨利·袁说，计算机科学家“对实际计算时间的理解或测量能力不是很高”。</p><p> So instead, computer scientists measure something else that they hope will provide insight into the computation times they can’t measure: They work out the number of times a computer needs to consult an “oracle” in order to come back with an answer. An oracle is like a hint-giver. You don’t know how it comes up with its hints, but you do know they’re reliable.</p><p>取而代之的是，计算机科学家们测量了一些其他的东西，他们希望这些东西能为他们无法测量的计算时间提供洞察力：他们计算出一台计算机为了得到答案而需要咨询一位“先知”的次数。先知就像一个提示者。你不知道它的提示是怎么来的，但你知道它们是可靠的。</p><p> If your problem is to figure out whether two random number generators are secretly related, you can ask the oracle questions such as “What’s the sixth number from each generator?” Then you compare computational power based on the number of hints each type of computer needs to solve the problem. The computer that needs more hints is slower.</p><p>如果您的问题是要弄清楚两个随机数生成器是否秘密相关，您可以问一些先知问题，比如“每个生成器的第六个数字是什么？”然后，根据每种类型的计算机需要解决问题的提示数来比较计算能力。需要更多提示的计算机速度较慢。</p><p> “In some sense we understand this model much better. It talks more about information than computation,” said Tal.</p><p>“从某种意义上说，我们对这种模式的理解要好得多。它更多地谈论信息，而不是计算。“塔尔说。</p><p>  The new paper by Raz and Tal proves that a quantum computer needs far fewer hints than a classical computer to solve the forrelation problem. In fact, a quantum computer needs just one hint, while even with unlimited hints, there’s no algorithm in PH that can solve the problem. “This means there is a very efficient quantum algorithm that solves that problem,” said Raz. “But if you only consider classical algorithms, even if you go to very high classes of classical algorithms, they cannot.” This establishes that with an oracle, forrelation is a problem that is in BQP but not in PH.</p><p>Raz和Tal的新论文证明，量子计算机比经典计算机需要更少的提示来解决关联问题。事实上，量子计算机只需要一个提示，而即使有无限的提示，PH中也没有算法可以解决这个问题。拉兹说：“这意味着有一种非常有效的量子算法可以解决这个问题。”“但如果你只考虑经典算法，即使你上的是非常高级的经典算法，他们也做不到。”这表明，对于先知，关系是BQP中的问题，而不是PH中的问题。</p><p> Raz and Tal nearly achieved this result almost four years ago, but they couldn’t complete one step in their would-be proof. Then just a month ago, Tal heard a talk on a  new paper on pseudorandom number generators and realized the techniques in that paper were just what he and Raz needed to finish their own. “This was the missing piece,” said Tal.</p><p>拉兹和塔尔几乎在四年前就实现了这一结果，但他们在未来的证据中一步也没能完成。就在一个月前，塔尔听了一篇关于伪随机数生成器的新论文的演讲，意识到论文中的技术正是他和拉兹完成自己的论文所需要的。“这就是缺失的部分，”塔尔说。</p><p>  News of the separation between BQP and PH circulated quickly. “The quantum complexity world is a-rocking,”  wrote Lance Fortnow, a computer scientist at Georgia Tech, the day after Raz and Tal posted their proof.</p><p>BQP和PH分离的消息很快就传开了。佐治亚理工学院的计算机科学家兰斯·福特诺(Lance Fortnow)在拉兹(Raz)和塔尔(Tal)发表了他们的证明的第二天写道：“量子复杂性的世界正在震撼。”</p><p> The work provides an ironclad assurance that quantum computers exist in a different computational realm than classical computers (at least relative to an oracle). Even in a world where P equals NP — one where the  traveling salesman problem is as simple as finding a best-fit line on a spreadsheet — Raz and Tal’s proof demonstrates that there would still be problems only quantum computers could solve.</p><p>这项工作提供了一个确凿的保证，即量子计算机存在于与经典计算机不同的计算领域(至少相对于先知而言)。即使在P等于NP的世界里--旅行推销员问题就像在电子表格上找到一条最合适的线一样简单--Raz和Tal的证明表明，仍然存在只有量子计算机才能解决的问题。</p><p> “Even if P were equal to NP, even making that strong assumption,” said Fortnow, “that’s not going to be enough to capture quantum computing.”</p><p>Fortnow说：“即使P等于NP，即使做出这样强有力的假设，也不足以捕获量子计算。”</p><p> Correction June 21, 2018: An earlier version of this article stated that the version of the traveling salesman problem that asks if a certain path is exactly the shortest distance is “likely” to be in PH. In fact, it has been proved to be in PH.</p><p>更正2018年6月21日：这篇文章的早期版本指出，询问某条路径是否恰好是最短距离的旅行商问题的版本很可能是PH。事实上，它已经被证明处于PH状态。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.quantamagazine.org/finally-a-problem-that-only-quantum-computers-will-ever-be-able-to-solve-20180621/">https://www.quantamagazine.org/finally-a-problem-that-only-quantum-computers-will-ever-be-able-to-solve-20180621/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/计算机/">#计算机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/problem/">#problem</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>