<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CQRS：命令查询责任分离</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CQRS：命令查询责任分离</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 21:49:05</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/d8709d8002954da060a33832d31b8b67.png"><img src="http://img2.diglog.com/img/2020/11/d8709d8002954da060a33832d31b8b67.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>CQRS stands for  Command Query Responsibility Segregation. It&#39;s a pattern that I first heard described by  Greg Young. At its heart is the notion that you can use a different model to update information than the model you use to read information. For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity.</p><p>CQRS代表命令查询责任分离。这是我第一次听到格雷格·杨(Greg Young)描述的一种模式。其核心是这样一个概念，即您可以使用与读取信息所用的模型不同的模型来更新信息。对于某些情况，这种分离可能很有价值，但请注意，对于大多数系统来说，CQRS增加了风险复杂性。</p><p> The mainstream approach people use for interacting with an information system is to treat it as a CRUD datastore. By this I mean that we have mental model of some record structure where we can  create new records,  read records,  update existing records, and  delete records when we&#39;re done with them. In the simplest case, our interactions are all about storing and retrieving these records.</p><p>人们在与信息系统交互时使用的主流方法是将其视为CRUD数据存储。我的意思是，我们有某种记录结构的心理模型，在这种模型中，我们可以创建新记录、读取记录、更新现有记录，以及在处理完记录后删除记录。在最简单的情况下，我们的交互都是关于存储和检索这些记录。</p><p> As our needs become more sophisticated we steadily move away from that model. We may want to look at the information in a different way to the record store, perhaps collapsing multiple records into one, or forming virtual records by combining information for different places. On the update side we may find validation rules that only allow certain combinations of data to be stored, or may even infer data to be stored that&#39;s different from that we provide.</p><p>随着我们的需求变得越来越复杂，我们逐渐远离这种模式。我们可能希望以与记录存储不同的方式查看信息，可能是将多条记录合并为一条记录，或者通过组合不同位置的信息来形成虚拟记录。在更新方面，我们可能会发现只允许存储某些数据组合的验证规则，甚至可以推断要存储的数据与我们提供的数据不同。</p><p>   As this occurs we begin to see multiple representations of information. When users interact with the information they use various presentations of this information, each of which is a different representation. Developers typically build their own conceptual model which they use to manipulate the core elements of the model. If you&#39;re using a Domain Model, then this is usually the conceptual representation of the domain. You typically also make the persistent storage as close to the conceptual model as you can.</p><p>当这种情况发生时，我们开始看到信息的多种表示形式。当用户与信息交互时，他们使用该信息的各种表示形式，每种表示形式都不同。开发人员通常构建他们自己的概念模型，他们使用该模型来操作模型的核心元素。如果您使用的是域模型，则这通常是域的概念性表示。通常，您还可以使持久存储尽可能接近概念模型。</p><p> This structure of multiple layers of representation can get quite complicated, but when people do this they still resolve it down to a single conceptual representation which acts as a conceptual integration point between all the presentations.</p><p>这种多层表示的结构可能会变得相当复杂，但当人们这样做时，他们仍然会将其分解为单个概念表示，该概念表示充当所有表示之间的概念集成点。</p><p> The change that CQRS introduces is to split that conceptual model into separate models for update and display, which it refers to as Command and Query respectively following the vocabulary of  CommandQuerySeparation. The rationale is that for many problems, particularly in more complicated domains, having the same conceptual model for commands and queries leads to a more complex model that does neither well.</p><p>CQRS引入的更改是将概念模型拆分成单独的模型进行更新和显示，根据CommandQuerySeparation的词汇表，CQRS将其分别称为Command和Query。其基本原理是，对于许多问题，特别是在更复杂的领域中，拥有相同的命令和查询概念模型会导致更复杂的模型，两者都做不好。</p><p>   By separate models we most commonly mean different object models, probably running in different logical processes, perhaps on separate hardware. A web example would see a user looking at a web page that&#39;s rendered using the query model. If they initiate a change that change is routed to the separate command model for processing, the resulting change is communicated to the query model to render the updated state.</p><p>我们所说的独立模型通常指的是不同的对象模型，它们可能运行在不同的逻辑进程中，也可能运行在不同的硬件上。一个Web示例可以看到，用户正在查看使用查询模型呈现的网页。如果它们发起更改，该更改将被路由到单独的命令模型进行处理，所产生的更改将被传送到查询模型以呈现更新后的状态。</p><p> There&#39;s room for considerable variation here. The in-memory models may share the same database, in which case the database acts as the communication between the two models. However they may also use separate databases, effectively making the query-side&#39;s database into a real-time  ReportingDatabase. In this case there needs to be some communication mechanism between the two models or their databases.</p><p>这里有相当大的变化空间。内存中的模型可以共享相同的数据库，在这种情况下，数据库充当两个模型之间的通信。但是，它们也可以使用单独的数据库，从而有效地将查询端的数据库变成实时报告数据库。在这种情况下，两个模型或它们的数据库之间需要某种通信机制。</p><p> The two models might not be separate object models, it could be that the same objects have different interfaces for their command side and their query side, rather like views in relational databases. But usually when I hear of CQRS, they are clearly separate models.</p><p>这两个模型可能不是单独的对象模型，可能是相同的对象为其命令端和查询端提供了不同的接口，这与关系数据库中的视图非常相似。但通常情况下，当我听说CQR时，它们显然是两种不同的型号。</p><p>  As we move away from a single representation that we interact with via CRUD, we can easily move to a task-based UI.</p><p>当我们从通过CRUD与之交互的单一表示形式转移到基于任务的用户界面时，我们可以很容易地转移到基于任务的用户界面。</p><p> CQRS fits well with  event-based programming models. It&#39;s common to see CQRS system split into separate services communicating with  Event Collaboration. This allows these services to easily take advantage of  Event Sourcing.</p><p>CQRS非常适合基于事件的编程模型。CQRS系统被分成多个独立的服务，与活动协作进行通信，这是很常见的。这使得这些服务可以轻松地利用事件采购(Event Sourcing)。</p><p> Having separate models raises questions about how hard to keep those models consistent, which raises the likelihood of using  eventual consistency.</p><p>拥有独立的模型会引发关于保持这些模型一致性的难度有多大的问题，这增加了使用最终一致性的可能性。</p><p> For many domains, much of the logic is needed when you&#39;re updating, so it may make sense to use  EagerReadDerivation to simplify your query-side models.</p><p>对于许多域，重新更新时需要很多逻辑，因此使用EagerReadDerivation来简化查询端模型可能是有意义的。</p><p> If the write model generates events for all updates, you can structure read models as  EventPosters, allowing them to be  MemoryImages and thus avoiding a lot of database interactions.</p><p>如果写入模型为所有更新生成事件，则可以将读取模型构造为EventPoster，从而允许它们成为Memory Images，从而避免大量的数据库交互。</p><p> Like any pattern, CQRS is useful in some places, but not in others. Many systems do fit a CRUD mental model, and so should be done in that style. CQRS is a significant mental leap for all concerned, so shouldn&#39;t be tackled unless the benefit is worth the jump. While I have come across successful uses of CQRS, so far the majority of cases I&#39;ve run into have not been so good, with CQRS seen as a significant force for getting a software system into serious difficulties.</p><p>与任何模式一样，CQRS在某些地方有用，但在其他地方没有用。许多系统确实符合一个肮脏的心理模型，因此应该按照这种风格来做。CQRS对于所有相关的人来说都是一次重大的思想飞跃，所以除非好处值得一跃，否则不应该去解决。虽然我遇到过CQRS的成功使用，但到目前为止，我遇到的大多数案例都不太好，CQRS被视为让软件系统陷入严重困境的一股重要力量。</p><p> In particular CQRS should only be used on specific portions of a system (a  BoundedContext in DDD lingo) and not the system as a whole. In this way of thinking, each Bounded Context needs its own decisions on how it should be modeled.</p><p>特别是，CQR应该只用于系统的特定部分(在DDD行话中是BoundedContext)，而不是整个系统。按照这种思路，每个受限上下文都需要自己决定如何建模。</p><p> So far I see benefits in two directions. Firstly is that a few complex domains may be easier to tackle by using CQRS. I must stress, however, that such suitability for CQRS is very much the minority case. Usually there&#39;s enough overlap between the command and query sides that sharing a model is easier. Using CQRS on a domain that doesn&#39;t match it will add complexity, thus reducing productivity and increasing risk.</p><p>到目前为止，我看到了两个方向的好处。首先，使用CQRS可能更容易处理一些复杂的领域。然而，我必须强调，这种适合CQRS的情况在很大程度上是少数人的情况。通常情况下，命令端和查询端之间有足够的重叠，因此共享一个模型更容易。在与CQRS不匹配的域上使用CQRS会增加复杂性，从而降低工作效率并增加风险。</p><p> The other main benefit is in handling high performance applications. CQRS allows you to separate the load from reads and writes allowing you to scale each independently. If your application sees a big disparity between reads and writes this is very handy. Even without that, you can apply different optimization strategies to the two sides. An example of this is using different database access techniques for read and update.</p><p>另一个主要好处是在处理高性能应用程序方面。CQRS允许您将负载与读取和写入分开，从而允许您独立地扩展每个负载。如果您的应用程序看到读取和写入之间的巨大差异，这是非常方便的。即使没有这一点，您也可以对两端应用不同的优化策略。这方面的一个例子是使用不同的数据库访问技术进行读取和更新。</p><p> If your domain isn&#39;t suited to CQRS, but you have demanding queries that add complexity or performance problems, remember that you can still use a  ReportingDatabase. CQRS uses a separate model for all queries. With a reporting database you still use your main system for most queries, but offload the more demanding ones to the reporting database.</p><p>如果您的域不适合CQRS，但您有增加复杂性或性能问题的苛刻查询，请记住您仍然可以使用ReportingDatabase。CQRS对所有查询使用单独的模型。对于报告数据库，您仍然使用主系统进行大多数查询，但会将要求更高的查询卸载到报告数据库。</p><p> Despite these benefits,  you should be very cautious about using CQRS. Many information systems fit well with the notion of an information base that is updated in the same way that it&#39;s read, adding CQRS to such a system can add significant complexity. I&#39;ve certainly seen cases where it&#39;s made a significant drag on productivity, adding an unwarranted amount of risk to the project, even in the hands of a capable team. So while CQRS is a pattern that&#39;s good to have in the toolbox, beware that it is difficult to use well and you can easily chop off important bits if you mishandle it.</p><p>尽管有这些好处，您在使用CQRS时应该非常谨慎。许多信息系统与信息库的概念非常契合，信息库的更新方式与其读取的方式相同，将CQR添加到这样的系统中可能会增加相当大的复杂性。我当然看到过这样的情况，它严重拖累了生产率，给项目增加了不必要的风险，即使是在一个有能力的团队手中也是如此。因此，虽然CQRS是工具箱中的一个很好的模式，但要注意它很难很好地使用，如果处理不当，很容易砍掉重要的部分。</p><p> Greg Young was the first person I heard talking about this approach - this is  the summary from him that I like best.</p><p>格雷格·杨(Greg Young)是我听到的第一个谈论这种方法的人--这是我最喜欢的他的总结。</p><p> Udi Dahan is another advocate of CQRS, he has a  detailed description of the technique.</p><p>UDI Dahan是CQRS的另一位倡导者，他对该技术有详细的描述。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://martinfowler.com/bliki/CQRS.html">https://martinfowler.com/bliki/CQRS.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/命令/">#命令</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/command/">#command</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模型/">#模型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>