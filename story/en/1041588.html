<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数据科学的交互式C ++ Interactive C++ for Data Science</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Interactive C++ for Data Science<br/>数据科学的交互式C ++ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:40:53</div><div class="page_narrow text-break page_content"><p>In our previous blog post  “Interactive C++ with Cling”we mentioned that exploratory programming is an effective way to reduce thecomplexity of the problem. This post will discuss some applications of Clingdeveloped to support data science researchers. In particular, interactivelyprobing data and interfaces makes complex libraries and complex data moreaccessible users. We aim to demonstrate some of Cling’s features at scale;Cling’s eval-style programming support; projects related to Cling; and showinteractive C++/CUDA.</p><p>在我们以前的博客文章“ Interactive C ++ with Cling”中，我们提到了探索性编程是减少问题复杂性的有效方法。这篇文章将讨论为支持数据科学研究人员而开发的Cling的一些应用程序。特别是，交互式探测数据和接口使复杂的库和复杂的数据更易于访问。我们旨在大规模展示Cling的某些功能； Cling的评估风格的编程支持；以及与保鲜相关的项目；和showinteractive C ++ / CUDA。</p><p>  A Cling instance can access itself through its runtime. The example creates a cling::Value to store the execution result of the incremented variable  i.That mechanism can be used further to support dynamic scopes extending the namelookup at runtime.</p><p>  Cling实例可以通过其运行时访问自身。该示例创建了一个cling :: Value来存储增量变量i的执行结果。该机制可以进一步用于支持动态范围，从而在运行时扩展名称查找。</p><p> [cling] $  #include  &lt;cling /Interpreter /Value.h &gt;[cling] $  #include  &lt;cling /Interpreter /Interpreter.h &gt;[cling] $  int i  =  1;[cling] $ cling ::Value V;[cling] $ gCling -&gt;evaluate( &#34;++i&#34;, V);[cling] $ i( int)  2[cling] $ V(cling ::Value  &amp;) boxes [( int)  2]</p><p> [cling] $ #include＆lt; cling / Interpreter /Value.h＆gt; [cling] $ #include＆lt; cling / Interpreter /Interpreter.h＆gt; [cling] $ int i = 1; [cling] $ cling ::值V; [cling] $ gCling-> evaluate（＆＃34; ++ i＆＃34 ;, V）; [cling] $ i（int）2 [cling] $ V（cling :: Value＆amp;）框[（int）2]</p><p> V “boxes” the expression result providing extended lifetime if necessary.The  cling::Value can be used to communicate expression values from theinterpreter to compiled code.</p><p> V将表达式结果“装箱”，必要时可以提供更长的生存期。cling :: Value可用于将表达式值从解释器传递到已编译的代码。</p><p>  This mechanism introduces a delayed until runtime evaluation which enables somefeatures increasing the dynamic look and feel of the C++ language.</p><p>  这种机制引入了延迟直到运行时评估，这使得某些功能可以增加C ++语言的动态外观。</p><p>  The main tool for storage, research and visualization of scientific data in thefield of high energy physics (HEP) is the specialized software package  ROOT.ROOT is a set of interconnected components that assist scientists from datastorage and research to their visualization when published in a scientificpaper. ROOT has played a significant role in scientific discoveries such asgravitational waves, the great cavity in the Pyramid of Cheops, the discovery ofthe Higgs boson by the Large Hadron Collider. For the last 5 years, Cling hashelped to analyze 1 EB physical data, serving as a basis for over 1000scientific publications, and supports software run across a distributed millionCPU core computing facility.</p><p>  高能物理（HEP）领域中用于存储，研究和可视化科学数据的主要工具是专用软件包ROOT.ROOT是一组相互连接的组件，可帮助科学家从科学论文发表后的数据存储和研究到其可视化。根在科学发现中起着重要作用，例如重力波，基奥普斯金字塔中的大空腔，大强子对撞机发现希格斯玻色子。在过去的5年中，Cling帮助分析了1个EB物理数据，作为1000多种科学出版物的基础，并支持在分布式百万CPU核心计算设施中运行的软件。</p><p> ROOT uses Cling as a reflection information service for data serialization. TheC++ objects are stored in a binary format, vertically. The content of a loadeddata file is made available to the users and C++ objects become a first classcitizen.</p><p> ROOT使用Cling作为数据序列化的反射信息服务。 C ++对象以二进制格式垂直存储。用户可以使用已加载数据文件的内容，并且C ++对象成为第一类。 </p><p> A central component of ROOT enabled by Cling is eval-style programming. We usethis in HEP to make it easy to inspect and use C++ objects stored by ROOT.Cling enables ROOT to inject available object names into the name lookup whena file is opened:</p><p>由Cling启用的ROOT的核心组件是eval风格的编程。我们在HEP​​中使用this来简化检查和使用ROOT存储的C ++对象的功能.Cling使ROOT可以在打开文件时将可用的对象名称注入名称查找中：</p><p> [root] ntuple -&gt;GetTitle()error: use of undeclared identifier  &#39;ntuple &#39;[root] TFile ::Open( &#34;tutorials/hsimple.root&#34;); ntuple -&gt;GetTitle()  // #1 ( const  char  *)  &#34;Demo ntuple&#34;[root] gFile -&gt;ls();TFile ** tutorials /hsimple.root Demo ROOT file with histograms TFile * tutorials /hsimple.root Demo ROOT file with histograms OBJ: TH1F hpx This is the px distribution :  0 at:  0x7fadbb84e390 OBJ: TNtuple ntuple Demo ntuple :  0 at:  0x7fadbb93a890 KEY: TH1F hpx; 1 This is the px distribution [...] KEY: TNtuple ntuple; 1 Demo ntuple[root] hpx -&gt;Draw()</p><p> [root] ntuple-＆gt; GetTitle（）错误：使用未声明的标识符＆＃39; ntuple＆＃39; [root] TFile :: Open（＆＃34; tutorials / hsimple.root＆＃34;）; ntuple-＆gt; GetTitle（）//＃1（const char *）＆＃34; Demo ntuple＆＃34; [root] gFile-＆gt; ls（）; TFile **教程/hsimple.root具有直方图TFile的演示根文件*教程/hsimple.root带有直方图的演示根文件OBJ：TH1F hpx这是px分布：0 at：0x7fadbb84e390 OBJ：TNtuple ntuple Demo ntuple：0 at：0x7fadbb93a890 KEY：TH1F hpx; 1这是px分布。KEY：TNtuple ntuple; 1个演示ntuple [root] hpx-> Draw（）</p><p> The ROOT framework injects additional names to the name lookup on two stages.First, it builds an invalid AST by marking the occurrence of ntuple (#1), thenit is transformed into gCling-&gt;EvaluateT&lt;/*return type*/void&gt;(&#34;ntuple-&gt;GetTitle()&#34;, /*context*/);On the next stage, at runtime, ROOT opens the file, reads its preambule andinjects the names via the external name lookup facility in clang. Thetransformation becomes more complex if  ntuple-&gt;GetTitle() takes arguments.</p><p> ROOT框架分两个阶段向名称查找中注入其他名称：首先，它通过标记ntuple（＃1）的存在来构建无效的AST，然后将nit转换为gCling-> EvaluateT＆lt; / * return type * / void＆gt ;. （＆＃34; ntuple-＆gt; GetTitle（）＆＃34 ;, / * context * /）;在下一阶段，ROOT在运行时打开文件，读取其序言，并通过外部名称查找工具注入名称。铛。如果ntuple-> GetTitle（）接受参数，则转换将变得更加复杂。</p><p>    The  Jupyter Notebooktechnology allows users to create and share documents that contain live code,equations, visualizations and narrative text. It enables data scientists toeasily exchange ideas or collaborate by sharing their analyses in astraight-forward and reproducible way. Language agnosticism is a key designprinciple for the Jupyter project, and the Jupyter frontend communicates withthe kernel (the part of the infrastructure that runs the code) through awell-specified protocol. Kernels have been developed for dozens of programminglanguages, such as R, Julia, Python, Fortran (through the LLVM-based LFortranproject).</p><p>    Jupyter Notebook技术允许用户创建和共享包含实时代码，等式，可视化和叙述文本的文档。它使数据科学家能够以直接，可重复的方式共享他们的分析，从而轻松地交换想法或进行协作。语言不可知论是Jupyter项目的关键设计原则，Jupyter前端通过明确指定的协议与内核（运行代码的基础结构部分）进行通信。已经为R，Julia，Python，Fortran等多种编程语言开发了内核（通过基于LLVM的LFortranproject）。</p><p> Jupyter’s official C++ kernel relies on  Xeus,a C++ implementation of the kernel protocol, and Cling. An advantage of using areference implementation for the kernel protocol is that a lot of features comefor free, such as rich mime type display, interactive widgets, auto-complete,and much more.</p><p> Jupyter的官方C ++内核依赖于Xeus（一种内核协议的C ++实现）和Cling。对内核协议使用引用实现的一个优点是免费提供了许多功能，例如丰富的mime类型显示，交互式小部件，自动完成等等。</p><p> Rich mime-type rendering for user-defined types can be specified by providingan overload of  mime_bundle_repr for the said type, which is picked up byargument dependent lookup.</p><p> 可以通过为所述类型提供mime_bundle_repr的重载来指定用于用户定义类型的丰富的mime类型呈现，该重载由依赖参数的查找来获取。</p><p>  Possibilities with rich mime type rendering are endless, such as rich display ofdataframes with HTML tables, or even mime types that are rendered in thefront-end with JavaScript extensions.</p><p>  丰富的mime类型呈现的可能性是无止境的，例如带有HTML表的数据帧的丰富显示，甚至是在前端使用JavaScript扩展呈现的mime类型。 </p><p> An advanced example making use of rich rendering with Mathjax is the SymEnginesymbolic computing library.</p><p>SymEnginesymbolic计算库是使用Mathjax进行丰富呈现的一个高级示例。</p><p>  Xeus-cling comes along with an implementation of the Jupyter widgets protocolwhich enables bidirectional communication with the backend.</p><p>  Xeus-cling随附Jupyter小部件协议的实现，该协议支持与后端的双向通信。</p><p>      The Xeus and Xeus-cling kernels were recently incorporated as subprojects toJupyter, and are governed by its code of conduct and general governance.</p><p>      Xeus和Xeus-cling内核最近被合并为Jupyter的子项目，并受其行为准则和一般治理的约束。</p><p> Planned future developments for the xeus-cling kernel include: adding supportfor the Jupyter console interface, through an implementation of the Jupyter is_complete message, currently lacking; adding support for cling“dot commands” as Jupyter magics; and supporting the new debugger protocol thatwas recently added to the Jupyter kernel protocol, which will enable the use ofthe JupyterLab visual debugger with the C++ kernel.</p><p> 针对xeus-cling内核的计划未来开发包括：通过实现目前缺乏的Jupyter is_complete消息，增加对Jupyter控制台界面的支持；增加了对紧贴“点命令”作为Jupyter魔术的支持；并支持最近添加到Jupyter内核协议中的新调试器协议，该协议将使JupyterLab可视调试器与C ++内核一起使用。</p><p> Another tool that brings interactive plotting features to xeus-cling is xvega,which is at an early stage of development, produces vega charts that can bedisplayed in the notebook.</p><p> 另一个将交互式绘图功能引入xeus-cling的工具是xvega，它处于开发的早期阶段，它可以生成可在笔记本中显示的vega图表。</p><p>    The Cling CUDA extension brings the workflows of interactive C++ to GPUs withoutlosing performance and compatibility to existing software. To execute CUDA C++Code, Cling activates an extension in the compiler frontend to understand theCUDA C++ dialect and creates a second compiler instance that compiles the codefor the GPU.</p><p>    Cling CUDA扩展将交互式C ++的工作流程带到了GPU，而不会损失性能和与现有软件的兼容性。为了执行CUDA C ++代码，Cling激活了编译器前端中的扩展以了解CUDA C ++的方言，并创建了第二个编译器实例来编译GPU的代码。</p><p>  Like the normal C++ mode, the CUDA C++ mode uses AST transformation to enableinteractive CUDA C++ or special features as the Cling print system. In contrastto the normal Cling compiler pipeline used for the host code, the devicecompiler pipeline does not use all the transformations of the host pipeline.Therefore, the device pipeline has some special transformation.</p><p>  像普通的C ++模式一样，CUDA C ++模式使用AST转换来启用交互式CUDA C ++或特殊功能（如Cling打印系统）。与用于主机代码的普通Cling编译器管道不同，devicecompiler管道并未使用主机管道的所有转换，因此设备管道具有一些特殊的转换。 </p><p> [cling]  #include  &lt;iostream &gt;[cling]  #include  &lt;cublas_v2.h &gt;[cling]  #pragma cling(load  &#34;libcublas.so&#34;)  // link a shared library // set parameters // allocate memory // ... [cling] __global__  void init( float  *matrix,  int size){[cling]  ?  int x  = blockIdx.x  * blockDim.x  + threadIdx.x;[cling]  ?  if (x  &lt; size)[cling]  ? matrix[x]  = x;[cling]  ? }[cling][cling]  // launching a function direct in the global space [cling] init &lt;&lt;&lt;blocks, threads &gt;&gt;&gt;(d_A, dim *dim);[cling] init &lt;&lt;&lt;blocks, threads &gt;&gt;&gt;(d_B, dim *dim);[cling][cling] cublasSgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, dim, dim, dim,  &amp;alpha, d_A, dim, d_B, dim,  &amp;beta, d_C, dim);[cling] cublasGetVector(dim *dim,  sizeof(h_C[ 0]), d_C,  1, h_C,  1);[cling] cudaGetLastError()(cudaError_t) (cudaError ::cudaSuccess)  : ( unsigned  int)  0</p><p>[cling] #include＆lt; iostream＆gt; [cling] #include＆lt; cublas_v2.h＆gt; [cling] #pragma cling（load＆＃34; libcublas.so＆＃34;）//链接共享库//设置参数//分配内存// // ... [cling] __global__ void init（float * matrix，int size）{[cling]吗？ int x = blockIdx.x * blockDim.x + threadIdx.x; [cling]吗？如果（x＆lt; size）[依附]？ matrix [x] = x; [cing]吗？ } [cling] [cling] //直接在全局空间中启动函数[cling] init＆lt;＆lt;＆lt ;;块，线程＆gt;＆gt;＆gt;（d_A，dim * dim）; [cling] init＆lt; ＆lt;＆lt;＆lt;块，线程＆gt;＆gt;＆gt;（d_B，暗* dim）; ，dim，＆amp; beta，d_C，dim）; [cling] cublasGetVector（dim * dim，sizeof（h_C [0]），d_C，1，h_C，1）; [cling] cudaGetLastError（）（cudaError_t）（cudaError： ：cudaSuccess）：（unsigned int）0</p><p> Like the normal C++ mode, the CUDA mode can be used in a Jupyter Notebook.</p><p> 像普通的C ++模式一样，CUDA模式可以在Jupyter Notebook中使用。</p><p>  A special property of Cling in CUDA mode is that the Cling application becomes anormal CUDA application at the time of the first CUDA API call. This enables theCUDA SDK with Cling. For example, you can use the CUDA profiler nvprof ./cling -xcuda to profile your interactive application. This docker container can be used toexperiment with Cling’s CUDA mode.</p><p>  CUDA模式下Cling的一个特殊属性是，在第一次CUDA API调用时，Cling应用程序成为普通的CUDA应用程序。这将启用带有Cling的CUDA SDK。例如，您可以使用CUDA分析器nvprof ./cling -xcuda来分析您的交互式应用程序。该docker容器可用于体验Cling的CUDA模式。</p><p> Planned future developments for the CUDA mode include: Supporting of thecomplete current CUDA API; Redefining CUDA Kernels; Supporting other GPU SDK’slike HIP (AMD) and SYCL (Intel).</p><p> CUDA模式的计划未来开发包括：支持完整的当前CUDA API；重新定义CUDA内核；支持其他GPU SDK，例如HIP（AMD）和SYCL（Intel）。</p><p>  We see the use of Interactive C++ as an important tool to develop forresearchers in the data science community. Cling has enabled ROOT to be the“go to” data analysis tool in the field of High Energy Physics for everythingfrom efficient I/O to plotting and fitting. The interactive CUDA backend allowseasy integration of research workflows and simpler communication between C++ andCUDA. As Jupyter Notebooks have become a standard way for data analysts toexplore ideas, Xeus-cling ensures that great interactive C++ ingredients areavailable in every C++ notebook.</p><p>  我们将Interactive C ++的使用视为开发数据科学界的研究人员的重要工具。 Cling使ROOT成为高能物理领域中的“必备”数据分析工具，从有效的I / O到绘图和拟合，应有尽有。交互式CUDA后端允许轻松集成研究工作流，并简化C ++和CUDA之间的通信。由于Jupyter Notebook已成为数据分析人员探索想法的标准方式，因此Xeus-cling确保在每个C ++笔记本中都可以使用出色的交互式C ++成分。</p><p> In the next blog post we will focus on Cling enabling features beyondinteractive C++, and in particular language interoperability.</p><p> 在下一篇博客文章中，我们将重点介绍交互式C ++之外的Cling支持功能，尤其是语言的互操作性。</p><p>  The author would like to thank Sylvain Corlay, Simeon Ehrig, David Lange,Chris Lattner, Javier Lopez Gomez, Wim Lavrijsen, Axel Naumann, Alexander Penev,Xavier Valls Pla, Richard Smith, Martin Vassilev, who contributed to this post.</p><p>  作者在此感谢Sylvain Corlay，Simeon Ehrig，David Lange，Chris Lattner，Javier Lopez Gomez，Wim Lavrijsen，Axel Naumann，Alexander Penev，Xavier Valls Pla，Richard Smith，Martin Vassilev的贡献。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.llvm.org/posts/2020-12-21-interactive-cpp-for-data-science/">https://blog.llvm.org/posts/2020-12-21-interactive-cpp-for-data-science/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/科学/">#科学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cling/">#cling</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>