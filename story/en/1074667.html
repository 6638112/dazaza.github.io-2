<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实时播放Macintosh PlusLive Streaming a Macintosh Plus</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Live Streaming a Macintosh Plus<br/>实时播放Macintosh Plus</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 14:37:06</div><div class="page_narrow text-break page_content"><p>Since recording a handful of C Programming on System 6videos, I’ve occasionally wanted to live-stream the more casual dailyprogramming being done on my Macintosh Plus.After getting all of the pieces together, I now have a working self-hostedbroadcasting setup.</p><p>自从在System 6videos上录制了一些C编程之后，我偶尔想直播在Macintosh Plus上进行的更随意的日常编程。在把所有的片段整合在一起之后，我现在有了一个工作的自助广播设置。</p><p> If I happen to be programming on my Mac right now, you can watch here at my website.</p><p>如果我现在正在Mac上编程，你可以在我的网站上观看。</p><p>    Back in 2020, I experimentedwith writing a pseudo-driver for my Macintosh Plus that would send its screendata over the SCSI port to a Raspberry Pi with a RaSCSI hat,which would then display the data on the Pi’s framebuffer, making it possible tocapture the Mac’s screen through the Pi’s HDMI output.This proved to be too slowto work and ate a lot of processing time on the Mac (though it was admittedlynot well optimized), so I went back to recording videos with an actual camera(an iPad).</p><p>回到2020年，我尝试为我的Macintosh Plus编写一个伪驱动程序，通过SCSI端口将其屏幕数据发送到带有RaSCSI帽的Raspberry Pi，该帽随后会在Pi的帧缓冲区上显示数据，从而可以通过Pi的HDMI输出捕获Mac的屏幕。这被证明是太慢的工作，在Mac上消耗了大量的处理时间（尽管它被承认没有得到很好的优化），所以我回去用一台真正的相机（iPad）录制视频。</p><p>  After watching Adrian Black’s videoin 2021 about using an RGBtoHDMIdevice to get video from a Macintosh Classic, I tried to get one but they werenot being sold anywhere.The RGBtoHDMI is a board that attaches to a Raspberry Pi Zero’s GPIO header anduses a CPLDto process analog or TTL digital video from a variety of sources and then feedit to some bare-metal software running on the Pi to display on the Pi’s HDMIoutput.</p><p>在观看了Adrian Black的VideoIn 2021关于使用一个RGBTHDMI设备从Macintosh经典获得视频，我试图得到一个，但他们不出售任何地方。RGBtoHDMI是一块板，连接到Raspberry Pi Zero的GPIO头，使用CPLDT处理来自各种源的模拟或TTL数字视频，然后将其馈送到Pi上运行的一些裸机软件，以在Pi的HDMIoutput上显示。</p><p> Building my own RGBtoHDMI ended up taking me quite a while.I first had to send the open source PCB designsto PCBWayfor printing (and I now have 9 extra PCBs) and then source all of thecomponents.The most important component, the Xilinx XC9572XL CPLD, was also the hardest toacquire due to the worldwide component shortage.Finally, assembly required soldering a bunch of tiny capacitors and the CPLD’s44 pins but I had never done surface-mount soldering before, so I was a bitnervous.</p><p>建立自己的RGBtoHDMI最终花了我很长时间。我首先必须将开放源代码的PCB设计发送到PCBway进行打印（现在我有9个额外的PCB），然后对所有组件进行源代码开发。最重要的组件Xilinx XC9572XL CPLD也因全球组件短缺而最难获得。最后，组装需要焊接一堆小电容器和CPLD的44引脚，但我以前从未做过表面贴装焊接，所以我有点紧张。</p><p>  With the RGBtoHDMI working, I needed to connect it to my Mac Plus.I soldered in four wires on the wiring harness that connects the Mac Plus’sanalog and logic boards, tapping into the monochrome video signal, horizontalsync, vertical sync, and ground.(These wires carry only low-voltage TTL signals so it should be pretty safe, butdon’t take my word for it.)</p><p>随着RGBtoHDMI的工作，我需要将其连接到我的Mac Plus。我在连接Mac Plus的sanalog和逻辑板的线束上焊接了四根电线，接入单色视频信号、水平同步、垂直同步和接地。（这些电线只传输低压TTL信号，所以应该很安全，但不要相信我的话。）</p><p>  I added heat-shrink tubing around the wires and ran them through the lockingdesk connector on the rear of the Mac.I also 3D-printed a casefor the Raspberry Pi Zero and RGBtoHDMI.</p><p>我在电线周围加了热缩管，并把它们穿过Mac电脑后部的锁桌连接器。我还3D打印了覆盆子皮零和RGBtoHDMI的外壳。</p><p>  Once the wires were correctly hooked up and the RGBtoHDMI was tuned with theclock settings from Adrian’s video, I had a pixel-perfect copy of my Mac Plus’s512x342 screen appearing in real-time on an HDMI screen (with padding to fillits 640x480 framebuffer).</p><p>一旦电线正确连接，RGBtoHDMI使用Adrian视频中的锁定设置进行调整，我的Mac Plus的512x342屏幕的像素完美副本就会实时出现在HDMI屏幕上（通过填充填充填充640x480帧缓冲区）。</p><p>   I purchased a cheap $20 HDMI capture device(with the most unfortunate  Markov Chain brand name)which presents an HDMI source as a standard USB webcam.On my OpenBSD laptop, it appears as a  uvideo USB device with accompanying uaudio:</p><p>我买了一个便宜的20美元的HDMI捕捉设备（用最不幸的马尔可夫链品牌），它把一个HDMI源作为一个标准的USB网络摄像头。在我的OpenBSD笔记本电脑上，它显示为带有uaudio的uvideo USB设备：</p><p> uvideo1 at uhub5 port 4 configuration 1 interface 0 &#34;MACROSILICON USB3. 0 capture&#34; rev 2.00/21.00 addr 14video1 at uvideo1uaudio1 at uhub5 port 4 configuration 1 interface 3 &#34;MACROSILICON USB3. 0 capture&#34; rev 2.00/21.00 addr 14uaudio1: class v1, high-speed, sync, channels: 0 play, 1 rec, 1 ctlsaudio2 at uaudio1uhidev4 at uhub5 port 4 configuration 1 interface 4 &#34;MACROSILICON USB3. 0 capture&#34; rev 2.00/21.00 addr 14uhidev4: iclass 3/0uhid7 at uhidev4: input=0, output=0, feature=8</p><p>uhub5端口4配置1接口0和34处的uvideo1；宏硅USB3。0次捕获#34次；rev 2.00/21.00 addr 14video1在uhub5端口4的Uvideo1Audio1配置1接口3和#34；宏硅USB3。0次捕获#34次；rev 2.00/21.00 addr 14uaudio1:class v1，高速，同步，通道：0播放，1录制，1 ctlsaudio2在UAUDIO1HIDEV4在uhub5端口4配置1接口4和#34；宏硅USB3。0次捕获#34次；修订版2.00/21.00增补14uhidev4:uhidev4处的iclass 3/0uhid7:input=0，output=0，feature=8</p><p> I was able to use the  video(1)utility to see a pixel-perfect (when using YUY2 encoding) copy of the Mac’sscreen.In my testing, this cheap HDMI capture device was fully capable of displayingthe Mac’s screen at 30fps, though it is of course only a 640x480 1-bit videostream.I don’t know whether it (or OpenBSD) is capable of keeping up with a much higherresolution, full-color source like capturing a game.</p><p>我能够使用video（1）实用程序查看Mac屏幕的像素完美拷贝（使用YUY2编码时）。在我的测试中，这个廉价的HDMI捕获设备完全能够以30fps的速度显示Mac的屏幕，尽管它当然只是一个640x480的1位视频流。我不知道它（或OpenBSD）是否能够跟上更高分辨率的全彩源代码，比如捕捉游戏。</p><p>  In my usual fashion of wanting to retain control over my content, I didn’t wantto outsource my streaming to YouTube or Twitch.</p><p>按照我一贯希望保留对内容控制权的方式，我不想将流媒体外包给YouTube或Twitch。</p><p> Since the black and white screen data is so compact (a full screen as a 1-bitPNG is between 5Kb and 9Kb) and I wanted to avoid blurring it by compressing itas a video stream, I started writing a programto read the YUY2 data directly from the device, discard unnecessary pixel data,and then send it to a program running on my server that would serve it throughWebSockets.The idea was that some Javascript could read the WebSocket data as a stream anddirectly draw each frame on a  &lt;canvas&gt; element.</p><p>由于黑白屏幕数据非常紧凑（1位PNG的全屏数据在5Kb到9Kb之间），我希望通过将其压缩为视频流来避免模糊，因此我开始编写一个程序，直接从设备读取YUY2数据，丢弃不必要的像素数据，然后将其发送到我的服务器上运行的程序，该程序将通过网络套接字为其提供服务。其想法是，一些Javascript可以将WebSocket数据读取为流，并直接在&lt；帆布&gt；要素</p><p> I eventually scrapped that idea and turned to a more traditional streamingsetup with FFmpeg and the wonderful rtsp-simple-server.After much reading documentation, testing, and guessing at why Firefox wouldn’tplay any video that I was sending (it is unable to play  avc1.f4001e video), Ireached a solution that works:</p><p>我最终放弃了这个想法，转而使用FFmpeg和出色的rtsp simple服务器进行更传统的流媒体设置。在大量阅读文档、测试并猜测Firefox为什么不播放我发送的任何视频（它无法播放avc1.f4001e视频）后，我找到了一个有效的解决方案：</p><p> ffmpeg -f v4l2 -i /dev/video1 \	-c:v libx264 -profile:v main -pix_fmt yuv420p -preset ultrafast \	-filter:v &#34;crop=512:344:64:69&#34; \	-max_muxing_queue_size 1024 -g 30 \	-rtsp_transport tcp \	-f rtsp rtsp://user:pass@jcs.org:8554/live</p><p>ffmpeg-f v4l2-i/dev/video1 \-c:v libx264-profile:v main-pix_fmt yuv420p-preset ultrafast \-filter:v&#34；作物=512:344:64:69&#34\-max_muxing_queue_size 1024-g 30 \-rtsp_传输tcp \-f rtsprtsp://user:pass@jcs。组织：8554/live</p><p> This instructs FFmpeg to read from the HDMI capture V4L2 device at /dev/video1, encode it as x264 video with a pixel format of YUV420p neededfor Firefox, after cropping it down from 640x480 to 512x344.It sends that stream as an RTSP TCP stream to rtsp-simple-server which isrunning on my server, which then serves it as an HLS stream.To have FFmpeg broadcast while also saving a copy of the stream to a local file,its  tee output can be used instead:</p><p>这将指示FFmpeg从/dev/video1处的HDMI capture V4L2设备读取数据，在将其从640x480裁剪到512x344后，将其编码为x264视频，并使用Firefox所需的YUV420p像素格式。它将该流作为RTSP TCP流发送到运行在我的服务器上的RTSP simple server，然后将其作为HLS流使用。要在将流的副本保存到本地文件的同时进行FFmpeg广播，可以使用其tee输出：</p><p>  The Mac’s screen is 512x342, but for whatever reason I can’t get it to encodeproperly at that resolution without adding a 1-pixel black bar at the top,making it 512x343.I made it 512x344 just to make it even, and then adjust the video position on mywebsite to show it as 512x342.</p><p>Mac的屏幕是512x342，但无论出于什么原因，我都无法在顶部添加一个1像素的黑条，使其成为512x343，以该分辨率正确编码。我制作了512x344只是为了让它更均匀，然后在我的网站上调整视频位置，将其显示为512x342。</p><p> I’m not sending any audio to the stream, but doing so would just be an extra -c:a flag to ffmpeg to also mux in audio from my laptop’s microphone.Maybe I’ll do this with just ambient audio of my keyboard and mouse clicks whenI’m not listening to music.</p><p>我没有向流发送任何音频，但这样做只是额外的-c：ffmpeg的一个标志，也可以从我笔记本电脑的麦克风对音频进行多路复用。也许我会在不听音乐的时候用键盘和鼠标点击的环境音频来实现这一点。</p><p> Since the RGBtoHDMI software runs directly on the Raspberry Pi, it boots andstarts displaying HDMI data within a couple seconds of receiving USB powerwithout having to wait for a full Linux kernel to boot.</p><p>由于RGBtoHDMI软件直接在Raspberry Pi上运行，它在接收USB电源的几秒钟内启动并开始显示HDMI数据，而无需等待完整的Linux内核启动。</p><p> Once the video is available, I can run the FFmpeg script and start streaming tortsp-simple-server which then makes the stream available to anyone with my Livepage open.Since I’m not using OBS or other heavy video muxing process, it’s all verylightweight and my fanless OpenBSD laptophandles streaming while playing music and running my web browser without anyissues.</p><p>一旦视频可用，我就可以运行FFmpeg脚本并启动流媒体服务器，然后让任何打开Livepage的人都可以使用流媒体。由于我没有使用OBS或其他繁重的视频多路复用过程，所以它非常轻量级，我的无风扇OpenBSD Laptop在播放音乐和运行web浏览器时处理流媒体，没有任何问题。</p><p>  On the server side I have nginx serving my usual website, but requests forthings in the  /live directory are proxied back to rtsp-simple-server whichhandles all of the HLS processing and serving of the individual video chunks andplaylist generation.I am using hls.jsto do the actual HLS processing in the browser since only Mobile Safari hasnative support for a  &lt;video&gt; tag with an HLS stream as its source.I would have liked to do everything without Javascript, but even my non-videosolution with WebSockets would have required it.</p><p>在服务器端，我让nginx为我的常用网站提供服务，但/live目录中的内容请求被代理回rtsp simple server，该服务器处理所有HLS处理和服务的单个视频块和播放列表生成。我用的是hls。由于只有Mobile Safari支持a&lt；视频&gt；标记HLS流作为其源。我本想在没有Javascript的情况下做任何事情，但即使是我使用WebSockets的非视频解决方案也需要它。</p><p> I added some little flourishes on the Livepage like drawing a Mac monitor around the video stream, similar to my Amendand Wallopsscreenshots.I also used a CSS transition to “turn the screen on” when the video startsplaying by fading in the opacity change.</p><p>我在Livepage上添加了一些小装饰，比如在视频流周围画一个Mac显示器，类似于我的修正和Wallopsscreenshots。当视频开始播放时，我还使用了CSS转换来“打开屏幕”，在不透明度变化中淡入淡出。</p><p> I’m also displaying a live viewer count which is done by a script on my server tailing the rtsp-simple-server log file and making a rough count of viewersbased on unique IPs that have fetched a video chunk within the past 30 seconds.It writes this count to a text file that some Javascript  fetches every 10seconds when the video is on and then updates the view counter under the screen.It would have been nice if rtsp-simple-server could do this rough viewer countcalculation on its own and send the count as some kind of metadata in the HLSplaylist, so I could avoid the additional server process and each client havingto fetch this counter separately.</p><p>我还显示了一个实时的观看者计数，这是由服务器上的一个脚本跟踪rtsp简单服务器日志文件完成的，并根据在过去30秒内获取视频块的唯一IP对观看者进行粗略计数。它将此计数写入一个文本文件，当视频打开时，一些Javascript每10秒获取一次该文件，然后更新屏幕下的视图计数器。如果rtsp simple server能够自己进行粗略的查看器计数计算，并将计数作为HLSplaylist中的某种元数据发送，那就太好了，这样我就可以避免额外的服务器进程，每个客户端都必须单独获取这个计数器。</p><p>   One component of services like YouTube or Twitch that I did want is integratedchat.Users can send comments or questions about what’s going on on screen and I canrespond either in chat or by showing something on the stream.</p><p>YouTube或Twitch等服务的一个组成部分是integratedchat。用户可以发送关于屏幕上正在发生的事情的评论或问题，我可以在聊天中或通过在流媒体上显示内容来回复。</p><p> Since I already have an IRC channelfor a community based around my other videos, I just used Libera Chat’sJavascript chat widget in an  &lt;iframe&gt; to allow users to join right from thestream page.Of course, for users that don’t want to chat in the browser, they can just joinin a normal IRC client and still interact with me and other viewers, somethingthat is not (easily) possible with a YouTube or Twitch stream.I can also be in the IRC channel from my Mac with the IRC clientI just wrote for System 6.</p><p>因为我已经有了一个基于我其他视频的社区IRC频道，我只是在一个&lt；iframe&gt；允许用户直接从流页面加入。当然，对于不想在浏览器中聊天的用户，他们可以加入一个普通的IRC客户端，仍然与我和其他观众互动，这在YouTube或Twitch流中是不可能的（很容易）。我也可以用我刚刚为System 6编写的IRC客户端从Mac进入IRC频道。</p><p>  My usual videosrequire an iPad on my desk in between my Mac and me  † to film from bothcameras at once which sort of “detaches” me from experiencing the Mac and reallygetting into the groove of programming since I have to do everything lookingthrough the iPad’s screen.They also require an hour or more of my undivided attention when it’s quietenough in my house to record, and then another hour re-encoding the video, thenmaybe another of editing the automated closed-captioning files.</p><p>我通常的视频需要在我和Mac电脑之间的桌子上放一台iPad†立即从两台摄像机上拍摄，这有点“脱离”了我对Mac电脑的体验，并真正进入了编程的最佳状态，因为我必须通过iPad的屏幕做所有事情。他们还需要我在家里安静的时候花一个小时或更长时间全神贯注地录制视频，然后再花一个小时重新编码视频，然后可能再编辑一个自动的闭路字幕文件。</p><p> Since my live-streaming setup only captures my Mac’s screen and no audio orvideo of me, it allows me to broadcast on a whim without having to worry aboutwhat I look like at the moment, what noise is being made elsewhere in my house(usually my son running around downstairs) or what music I’m playing on mylaptop, and I can get up from my desk whenever I need to for short amounts oftime.</p><p>由于我的实时流媒体设置只捕捉Mac电脑的屏幕，没有我的音频或视频，因此我可以随心所欲地进行广播，而不必担心我此刻的样子、家里其他地方发出的噪音（通常是我儿子在楼下跑来跑去）或我在笔记本电脑上播放的音乐，我可以在需要的时候从办公桌上站起来，时间很短。</p><p> I may add an optional small video and audio stream of myself separately on thepage in the future, but for now I like that it’s just an ephemeral stream of myMacintosh screen.</p><p>将来我可能会在页面上单独添加一个可选的视频和音频流，但现在我喜欢的是，它只是我的Macintosh屏幕上的一个短暂的流。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/播放/">#播放</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/streaming/">#streaming</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/视频/">#视频</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>