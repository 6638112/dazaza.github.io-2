<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们绘制了一百万个网页，以找出导致网络缓慢的原因 We rendered a million web pages to find out what makes the web slow</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">We rendered a million web pages to find out what makes the web slow<br/>我们绘制了一百万个网页，以找出导致网络缓慢的原因 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:37:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/df28b94fc63354031c6cb09ad7ffc7fe.png"><img src="http://img2.diglog.com/img/2020/12/df28b94fc63354031c6cb09ad7ffc7fe.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We rendered the  top 1 million pages on the web, tracking every conceivable performance metric, logging every error, noting every requested URL. To our knowledge, this produces the first dataset that connects performance, errors, and library use on the web. In this article, we analyze what the data can tell us about creating high performance web sites.</p><p>我们在网络上渲染了前一百万个页面，跟踪所有可能的性能指标，记录每个错误，记录每个请求的URL。据我们所知，这将产生第一个连接性能，错误和库在网络上使用情况的数据集。在本文中，我们分析了数据可以告诉我们有关创建高性能网站的信息。</p><p>  Can you do better than our analysis? We  published the dataset to Kaggle, so you can crunch the numbers yourself.</p><p>  您能比我们的分析做得更好吗？我们将数据集发布到Kaggle，因此您可以自己计算数字。</p><p>  A common sentiment these days is that the web is somehow slower and buggier than it was 15 years ago. Because of an ever-growing pile of JavaScript and frameworks and webfonts and polyfills, we’ve eaten up all the gains that faster computers, networks and protocols have given us. Or so the argument goes. We wanted to check if this was actually true and try to find what common factors are causing slow and broken websites in 2020.</p><p>  如今，人们普遍的看法是，与15年前相比，网络在某种程度上更慢，更容易出错。由于JavaScript，框架，网络字体和polyfill的不断增长，我们已经吞噬了更快的计算机，网络和协议给我们带来的所有收益。大概是这样。我们想检查一下这是否真的成立，并尝试找出导致2020年网站缓慢和崩溃的常见因素。</p><p> The high level plan was simple: Scripting a web browser, having it render the root page of the top 1 million domains, and logging every conceivable metric: render times, request counts, repaints, JavaScript errors, libraries used, etc. With all this data, we can ask questions about how one factor correlates with another. What factors contribute most to slow render times? Which libraries are correlated with long time-to-interactive? What are the most common errors, and what’s causing them?</p><p> 高层计划很简单：编写Web浏览器的脚本，让其呈现前100万个域的根页面，并记录所有可能的指标：呈现时间，请求计数，重绘，JavaScript错误，使用的库等。数据，我们可以问一个因素如何与另一个因素相关的问题。哪些因素是导致渲染时间延长的最主要因素？哪些库与长时间交互相关？最常见的错误是什么，是什么引起的？</p><p> Gathering the data was a matter of writing a bit of code to use Puppeteer to script Chrome, firing up 200 EC2 instances, rendering a million web pages over the weekend, and praying that you’ve actually understood how AWS pricing works.</p><p> 收集数据仅需编写一些代码即可使用Puppeteer编写Chrome脚本，启动200个EC2实例，在周末渲染一百万个网页，并祈祷您真正了解AWS定价的工作原理。</p><p>   HTTP 2 is now more common than HTTP 1.1, but HTTP 3 is still rare. (Note: We’re counting anything using the QUIC protocol as HTTP 3, even if Chrome sometimes reports this as HTTP 2 + QUIC.) This was for the root document, for linked resources the protocol numbers look a bit different.</p><p>   HTTP 2现在比HTTP 1.1更为普遍，但是HTTP 3仍然很少见。 （注意：即使使用Chrome有时会将其报告为HTTP 2 + QUIC，我们也将使用QUIC协议作为HTTP 3进行计数。）这是针对根文档的，对于链接的资源，协议编号看起来有些不同。</p><p>  For linked resources, HTTP 3 is about 100x more prevalent. How can this be true? Because all the sites are linking the same stuff:</p><p>  对于链接的资源，HTTP 3的普及率约为100倍。这怎么可能是真的？因为所有站点都链接相同的内容： </p><p>  There’s a handful of scripts that are linked on a large portion of web sites. This means we can expect these resources to be in cache, right? Not any more: Since Chrome 86,  resources requested from different domains will not share a cache. Firefox is planning to implement the same. Safari has been splitting its cache like this for years.</p><p>很多网站上都链接了一些脚本。这意味着我们可以期望这些资源在缓存中，对吗？从此不再如此：从Chrome 86开始，从不同域请求的资源将不会共享缓存。 Firefox计划实现相同的功能。 Safari多年来一直在像这样拆分其缓存。</p><p>  Given this dataset of web pages and their load time metrics, it would be nice to learn something about what it is that makes web pages slow. We’ll investigate the dominteractive metric, which is the time it takes before the document becomes interactive to the user. The simplest thing we could do is just to look at the correlation of each metric with dominteractive.</p><p>  给定此网页数据集及其加载时间指标，最好能了解使网页变慢的原因。我们将研究dominteractive指标，这是文档与用户互动之前所花费的时间。我们可以做的最简单的事情就是查看每个度量与dominteractive的相关性。</p><p>  Essentially every metric is positively correlated with dominteractive, except the 0–1 variable indicating HTTP2 or greater. Many of these metrics are also positively correlated with each other. We need a more sophisticated approach to get at individual factors contributing to a high time-to-interactive.</p><p>  基本上，每个指标都与dominteractive正相关，除了0–1变量表示HTTP2或更高。这些指标中的许多指标也彼此呈正相关。我们需要一种更复杂的方法来了解导致长时间互动的各个因素。</p><p> Some of the metrics are timings, measured in milliseconds. We can look at their box-plot to get an idea of where browsers are spending their time.</p><p> 一些指标是计时，以毫秒为单位。我们可以看一下它们的方框图，以了解浏览器在哪里花费时间。</p><p>  One way to get at the individual factors contributing to a high time-to-interactive is to do a linear regression, where we predict dominteractive from other metrics. That means we assign a weight to each metric and model the dominteractive time of a page as the weighted sum of the other metrics, plus some constant. An optimization algorithm sets the weights so as to minimize the prediction error over the whole dataset. The size of the weights found by the regression tells us something about how much each metric contributes to the slowness of the page.</p><p>  弄清促成高交互时间的各个因素的一种方法是进行线性回归，在此我们可以根据其他指标来预测交互性。这意味着我们为每个指标分配一个权重，并将页面的交互时间建模为其他指标的加权总和，再加上一些常数。优化算法设置权重，以最小化整个数据集的预测误差。回归发现的权重大小告诉我们有关每个指标对网页运行缓慢有多大贡献。</p><p> We’ll exclude timing metrics from the regression. If we spend 500ms establishing a connection, that adds 500ms to dominteractive, but this is not a particularly interesting insight. Timing metrics are fundamentally  outcomes. We want to learn what causes them.</p><p> 我们将从回归中排除计时指标。如果我们花费500毫秒建立连接，那么dominteractive就会增加500毫秒，但这并不是特别有趣的见解。时间指标从根本上说是结果。我们想了解导致它们的原因。</p><p>  The numbers in parenthesis are the regression coefficients learned by the optimization algorithm. You can interpret these as having units of milliseconds. While the exact numbers should be taken with a grain of salt (see note below), it is interesting to see the scale assigned to each feature. For example, the model predicts a 354ms slow down for every redirect needed to deliver the main document. Whenever the main HTML document is delivered via HTTP2 or higher, the model predicts a 477ms lower time-to-interactive. For each request triggered by the document, it predicts an additional 16 ms.</p><p>  括号中的数字是优化算法学习的回归系数。您可以将它们解释为以毫秒为单位。虽然确切的数字应该用一粒盐（请参阅下面的注释）来获取，但是有趣的是看到分配给每个特征的比例。例如，该模型预测，交付主文档所需的每个重定向都将延迟354毫秒。每当通过HTTP2或更高版本传递主HTML文档时，该模型预计互动时间将缩短477毫秒。对于文档触发的每个请求，它会预测额外的16毫秒。 </p><p> When interpreting regression coefficients, we need to keep in mind that we’re operating on a simplified model of reality. Time-to-interactive is not in fact determined by a weighted sum of these input metrics. There are clearly causal factors the model has no chance of discovering. Confounding variables is clearly an issue. As an example, if loading the main document with HTTP2 is correlated with loading  other requests over HTTP2, then the model will bake this advantage into the weights for main_doc_is_http2_or_greater, even if the speed up comes from requests other than the main document. We need to be cautious when mapping what the model says onto conclusions about reality.</p><p>在解释回归系数时，我们需要记住，我们是在简化的现实模型上进行操作。交互时间实际上不是由这些输入指标的加权总和确定的。显然，模型没有发现因果关系的机会。混淆变量显然是一个问题。例如，如果使用HTTP2加载主文档与通过HTTP2加载其他请求相关联，则该模型将把这一优势纳入main_doc_is_http2_or_greater的权重中，即使加速来自于除主文档以外的其他请求。在将模型所说的内容映射到有关现实的结论时，我们需要谨慎。</p><p>  Here’s a fun plot of dominteractive split by the HTTP protocol version used to deliver the root HTML page.</p><p>  这是一个有趣的图表，显示了dominteractive按用于分发根HTML页面的HTTP协议版本进行拆分的情况。</p><p>  Box-plot of dominteractive split by HTTP protocol version of the first request. The orange line is the median, the box goes from the 25th to the 75th percentile. The percentages in parenthesis are the fraction of requests made with this protocol.</p><p>  按第一个请求的HTTP协议版本划分的dominteractive箱形图。橙色线是中位数，框从25％到75％。括号中的百分比是使用此协议发出的请求的分数。</p><p> There’s a tiny number of sites still delivered over HTTP 0.9 and 1.0. And these sites happen to be fast. It seems we can’t disentangle the fact that protocols have gotten faster with the effect that programmers will happily consume this speed-up by delivering more stuff to the browser.</p><p> 仍然有少数网站仍通过HTTP 0.9和1.0交付。这些网站碰巧很快。似乎我们无法弄清协议变得越来越快的事实，即程序员会通过向浏览器提供更多内容来愉快地消耗这种加速。</p><p> This is for the protocol version used to deliver the root HTML page. What if we look at the effect of the protocol for resources linked in that document? If we do a regression on number of requests by protocol version, we get the following.</p><p> 这是用于交付根HTML页面的协议版本。如果我们看一下协议对于该文档中链接的资源的影响，该怎么办？如果我们按协议版本对请求数进行回归，则会得到以下结果。</p><p>  If we were to believe this, we would conclude that moving requested resources from HTTP 1.1 to 2 gives a 1.8x speed-up, while going from HTTP 2 to 3 causes 0.6x slow down. Is it really true that HTTP 3 is a slower protocol? No: A more likely explanation is that HTTP 3 is rare, and that the few resources that are being sent over HTTP 3 (e.g. Google Analytics) are things that have a larger than average effect on dominteractive.</p><p>  如果我们相信这一点，我们可以得出结论，将请求的资源从HTTP 1.1移到2可以使速度提高1.8倍，而从HTTP 2移到3则可以使速度降低0.6倍。 HTTP 3是一个较慢的协议，这是真的吗？否：更可能的解释是HTTP 3很少，并且通过HTTP 3发送的少数资源（例如Google Analytics（分析））对dominteractive的影响要大于平均水平。</p><p>  Let’s predict time-to-interactive from the number of bytes transferred, split by the type of data being transferred.</p><p>  让我们根据传输的字节数（除以传输的数据类型来预测）来预测互动时间。 </p><p>  Here’s a similar regression, this time looking at the number of requests per request initiator type.</p><p>这是类似的回归，这一次是查看每种请求发起者类型的请求数量。</p><p>  Here the requests are split up by what initiated the requests. Clearly, not all requests are made equal. Requests triggered by the link element (i.e. CSS, favicons) and requests triggered by CSS (i.e. fonts, more CSS) and scripts and iframes slow things down considerably. Doing requests over XHR and fetch are predictive of a faster than baseline dominteractive time (likely because these requests are almost always async). CSS and scripts are often loaded in a render-blocking way, so it is no surprise to find them associated with slower time-to-interactive. Video is comparatively  cheap.</p><p>  在这里，请求按发起请求的方式进行拆分。显然，并非所有请求都相等。由link元素触发的请求（即CSS，收藏夹图标）以及由CSS触发的请求（即字体，更多CSS）以及脚本和iframe会大大降低速度。通过XHR和提取进行请求可以预测比基线交互时间要快（可能是因为这些请求几乎总是异步的）。 CSS和脚本通常以渲染阻止方式加载，因此找到与交互时间较慢的关联并不奇怪。视频相对便宜。</p><p>  We haven’t uncovered any new optimization tricks here, but the analysis does give an idea of the scale of the impact one can expect from various optimizations. The following claims seem to have good empirical backing:</p><p>  我们在这里还没有发现任何新的优化技巧，但是分析确实提供了人们可以从各种优化中获得的预期影响的范围的概念。以下主张似乎有很好的经验支持：</p><p> Make as few requests as you can. Number of requests matters more than number of kilobytes transferred.</p><p> 尽可能少地提出请求。请求数比传输的千字节数重要。</p><p> For the request you have to make, do them over HTTP2 or greater if you can.</p><p> 对于您必须发出的请求，请尽可能通过HTTP2或更高版本进行处理。</p><p>  To figure out what libraries are in use on a page, we took the following approach: On every site we noted the global variables (i.e. the properties on the window object). Afterwards, every global variable with more than six thousand appearances were associated (where possible) with a JavaScript library. This is a painstaking undertaking, but since the dataset also has the requested URLs for every page it was possible to look at the overlap between variable occurrences and URL requests, which would often be enough to identify which library would set each global variable. Global variables that could not be confidently associated with a single library were ignored. This methodology will undercount to some extent: JS libraries have no obligation to leave anything in the global namespace. It will also have some noise, whenever different libraries set the same property, and this fact was missed during labeling.</p><p>  为了弄清页面上正在使用哪些库，我们采用以下方法：在每个站点上，我们都记录了全局变量（即window对象上的属性）。之后，每个具有六千多个外观的全局变量都与一个JavaScript库相关联（如果可能）。这是一项艰苦的工作，但是由于数据集还具有每个页面所请求的URL，因此可以查看变量出现与URL请求之间的重叠，这通常足以确定哪个库将设置每个全局变量。无法与单个库可靠关联的全局变量将被忽略。这种方法在某种程度上会被低估：JS库没有义务在全局名称空间中保留任何内容。每当不同的库设置相同的属性时，它也会产生噪音，并且在标记过程中会遗漏此事实。</p><p> What are the most common JavaScript libraries in use today? Going by the topics of conferences and blog posts, you’d be excused for suggesting React, Vue and Angular. In this ranking they are nowhere near the top.</p><p> 当今最常用的JavaScript库是什么？按照会议和博客文章的主题，您会被推荐React，Vue和Angular。在这个排名中，他们离排名靠前。 </p><p>   Yes, good old jQuery is at the top. JQuery was first released in 2006, which is 14 years ago in human years, but much longer in JavaScript years. Measured in Angular versions, it is probably hundreds of versions ago. 2006 was a different time. The most used browser was called Internet Explorer 6, the largest social network was MySpace, and rounded corners in web pages were such a revolution that  people called it web 2.0. JQuery’s primary use case was cross-browser compatibility, which is a different beast in 2020 than it was in 2006. Still, 14 years later, a full half of the web pages in our sample loaded jQuery.</p><p>是的，好的旧jQuery在顶部。 JQuery于2006年首次发布，这在人类时代是14年前，但在JavaScript时代则更长。以Angular版本衡量，它可能是数百个版本之前的版本。 2006年是另一个时代。最常用的浏览器是Internet Explorer 6，最大的社交网络是MySpace，网页上的圆角是一场革命，人们称之为Web 2.0。 JQuery的主要用例是跨浏览器兼容性，这在2020年与2006年是不同的野兽。14年后的今天，示例中的整个网页都加载了jQuery。</p><p>  Judging by this top 10, our browsers are mostly running analytics, ads, and code to be compatible with old browsers. Somehow 8% of web sites define a setImmediate/clearImmediate polyfill for a feature that isn’t on track to be implemented by any browser.</p><p>  从前十名来看，我们的浏览器主要运行分析，广告和代码以与旧的浏览器兼容。 8％的网站以某种方式为无法通过任何浏览器实现的功能定义了setImmediate / clearImmediate填充。</p><p>  We’ll again run a linear regression, predicting dominteractive from the presence of libraries. The input to the regression is a vector X, with X.length == number of libraries, where X[i] == 1.0 if library i is present, X[i] == 0.0 if it is not. Of course, we know that dominteractive is not actually determined by the presence or absence of certain libraries. However, modeling each library as having an additive contribution to slowness, and regressing over hundreds of thousands of examples still leaves us with interesting findings.</p><p>  我们将再次进行线性回归，根据存在的库预测dominteractive。回归的输入是向量X，其中X.length ==库数，如果存在库i，则X [i] == 1.0，如果不存在，则X [i] == 0.0。当然，我们知道dominteractive实际上不是由某些库的存在与否决定的。但是，将每个库建模为对速度的累加贡献，并回归数十万个示例，仍然给我们带来有趣的发现。</p><p>   The negative coefficients here mean that the model predicts a lower time-to-interactive when those libraries are present than it does when no libraries are present. Of course, it doesn’t mean that adding those libraries will make your site faster, it only means that the sites with those libraries happen to be faster than some baseline that the model has established. The results here may be as much sociological as they are technical. For example, libraries for lazy-loading predict low time-to-interactive. This may be just as much because pages with these libraries are made by programmers who spent time optimizing for fast page loads as it is directly caused by lazy-loading. We can’t untangle these factors with this set-up.</p><p>   此处的负系数表示，与没有库时相比，该模型预测的交互时间要短。当然，这并不意味着添加这些库可以使您的网站更快，它仅意味着具有这些库的网站碰巧比模型所建立的某些基准要快。这里的结果可能既具有社会学意义，又具有技术意义。例如，用于延迟加载的库预计交互时间很短。这可能是同样多的，因为带有这些库的页面是由程序员制作的，他们花费时间优化快速页面加载，这是由延迟加载直接导致的。我们无法通过此设置来解决这些因素。</p><p>  We can repeat the exercise above, but this time predicting onloadtime. Onloadtime is the time it takes for the window’s “load” event to fire, which is the time it takes for all resources on the page to load. We do a linear regression in the same way as before.</p><p>  我们可以重复上面的练习，但是这次是预测加载时间。 Onloadtime是触发窗口的“加载”事件所花费的时间，也就是加载页面上所有资源所花费的时间。我们以与以前相同的方式进行线性回归。</p><p>     Internet commentators are fond of saying that correlation does not equal causation, and indeed we can’t get at causality directly with these models. Great caution should be exercised when interpreting the coefficients, particularly because a lot confounding factors may be involved. However, there’s certainly enough there to make you go “hmm”. The fact that the model associates a 982ms slower time-to-interactive with the presence of jQuery, and that half of the sites load this script should give us some concern. If you’re optimizing your own site, cross-referencing its list of dependencies with the ranks and coefficients here should give you a decent indicator of which dependency removal can get you the most bang for your buck.</p><p>     互联网评论家喜欢说关联不等于因果关系，实际上我们无法直接利用这些模型来了解因果关系。解释系数时应格外小心，尤其是因为可能涉及许多混淆因素。但是，肯定有足够的东西可以使您变得“嗯”。该模型将982ms的交互式交互时间与jQuery的存在关联起来的时间缩短了，并且有一半的站点加载了此脚本，这一事实应引起我们的关注。如果您要优化自己的网站，请在此处将其依赖项列表与等级和系数进行交叉引用，这样可以很好地指示出哪些依赖项删除可以最大程度地发挥您的优势。</p><p> You may also be interested in our deep dive into the errors found in the crawl. See our article on  JavaScript Errors In The Wild, where we analyze the errors found and discuss what they can tell us about how web technology could develop to create a less error prone future.</p><p> 您可能还对我们深入研究爬网中发现的错误感兴趣。请参阅我们关于The JavaScript Errors In The Wild的文章，其中我们分析发现的错误，并讨论它们可以告诉我们有关网络技术如何发展以创造一个不太容易出错的未来的信息。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://itnext.io/we-rendered-a-million-web-pages-to-find-out-what-makes-the-web-slow-72bbba9ade96">https://itnext.io/we-rendered-a-million-web-pages-to-find-out-what-makes-the-web-slow-72bbba9ade96</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/找出/">#找出</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>