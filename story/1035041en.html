<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>API设计停留在过去</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">API设计停留在过去</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:08:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/34e35c5d0ce00b1c8507dd7284ab1b8e.png"><img src="http://img2.diglog.com/img/2020/11/34e35c5d0ce00b1c8507dd7284ab1b8e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Two decades ago, it was widely argued that dynamic programming languages were more productive because you didn&#39;t have to spend time dealing with type signatures. The only reason, then, to use a statically typed language, was for better performance. Truth be told, at the time, this argument had some validity, and many organizations chose to move away from the Javas of the world, and towards the Pythons. However, this was largely because of the specific statically-typed languages in wide use, and because of a lack of tooling available at the time to support them.</p><p>二十年前，人们普遍认为动态编程语言效率更高，因为您不必花费时间处理类型签名。那么，使用静态类型语言的唯一原因是为了更好的性能。说实话，在当时，这一观点有一定的道理，许多组织选择离开世界上的爪哇，转向蟒蛇。然而，这在很大程度上是因为广泛使用的特定静态类型语言，以及当时缺乏支持它们的工具。</p><p>  By now, that tooling has become much more widely available. In fact, the industry has learned over time that statically typed languages actually enable a whole host of new tooling possibilities, and ultimately, this tooling can drastically improve developer productivity and codebase maintainability. Editor features like auto-complete and jump-to-definition make programmers much more productive, and are mostly only possible in statically typed languages. We see TypeScript taking off, even though it has no performance benefit over JavaScript, because it is more productive. In addition, larger code bases become easier to manage when everyone is able to have some typed reason about each others’ code,  resulting in the ability to add features faster, with fewer bugs. In other words, the benefit of maintaining type signatures now well outweighs the cost.</p><p>到目前为止，这种工具已经变得更加广泛。事实上，随着时间的推移，业界已经了解到，静态类型语言实际上支持一系列新的工具，最终，这种工具可以极大地提高开发人员的工作效率和代码库的可维护性。像自动补全和跳转到定义这样的编辑器特性使程序员的工作效率大大提高，而且这些特性大多只在静态类型的语言中才能实现。我们看到了Tyescript的兴起，尽管它没有比JavaScript更好的性能优势，因为它的工作效率更高。此外，当每个人都能够对彼此的代码有某种类型的原因时，更大的代码库变得更容易管理，从而能够更快地添加功能，减少错误。换句话说，维护类型签名的好处现在远远超过了成本。</p><p> The industry has learned over time that statically typed languages  actually enable a whole host of new tooling possibilities, and ultimately, this tooling can drastically improve developer productivity and codebase maintainability</p><p>随着时间的推移，业界已经了解到，静态类型语言实际上可以实现一系列新的工具，最终，这种工具可以极大地提高开发人员的工作效率和代码库的可维护性。</p><p>  When it comes to network APIs, however, the industry is still twenty years behind. Most developers continue to rely on the path of least resistance: defining RESTful services, relying on JSON as the data format and HTTP as the transport protocol. Some feel that dynamically typed JSON, along with loosely-defined REST standards, are more productive than the alternatives, or that the learning curve associated with other API standards is too steep. However, similar to dynamic languages 20 years ago, the status quo of API development leaves a lot of room for improvement.</p><p>然而，当谈到网络API时，该行业仍然落后了20年。大多数开发人员继续依赖阻力最小的方法：定义RESTful服务，依赖JSON作为数据格式，使用HTTP作为传输协议。有些人认为动态类型的JSON和定义松散的REST标准比替代标准更有效率，或者与其他API标准相关的学习曲线过于陡峭。然而，与20年前的动态语言类似，API开发的现状留下了很大的改进空间。</p><p>  API development today is overwhelmingly freeform. Fundamentally, that means that every company -- and every team within every company -- that claims their services are RESTful can actually have very different API design standards. For example, naming conventions, pagination and versioning could all be radically different on one team compared to another. Often, a team might overload an object with unnecessary fields and use inconsistent data types. Unfortunately, this causes a number of problems.</p><p>如今的API开发绝大多数是自由形式的。从根本上说，这意味着声称他们的服务是RESTful的每个公司--以及每个公司内的每个团队--实际上可以有非常不同的API设计标准。例如，在一个团队中，命名约定、分页和版本控制都可能与另一个团队截然不同。通常，团队可能会用不必要的字段重载对象，并使用不一致的数据类型。不幸的是，这导致了许多问题。</p><p>  It’s straightforward to understand why having APIs structured differently harms service grokability. When APIs are designed differently, it’s not always obvious how the service should be used, preventing teams from quickly and confidently building applications around a new service.</p><p>很容易理解为什么不同结构的API会损害服务的可理解性。当API以不同的方式设计时，应该如何使用服务并不总是显而易见的，这使得团队无法快速、自信地围绕新服务构建应用程序。</p><p>  Organizations do make attempts to standardize the service structure, mostly by way of API style guides. Setting a style guide is a headache in and of itself, either requiring a team to craft one or select a popular one. Teams and individuals can rarely agree on a style guide, so this decision often gets ignored and relitigated regularly in code reviews. Ultimately, even if there was internal consensus on an approach to style, there is no good way to enforce, monitor or lint APIs for adherence.</p><p>组织确实尝试过标准化服务结构，主要是通过API样式指南的方式。设置风格指南本身就是一件令人头疼的事情，要么需要团队精心制作，要么需要选择一个受欢迎的指南。团队和个人很少能就风格指南达成一致，因此在代码评审中，这个决定经常被忽略和重申。归根结底，即使内部就样式的方法达成了共识，也没有好的方法来强制、监视或嵌入API以确保遵守。</p><p>  An inconsistent approach to service design and maintenance has another unintended effect: breaking changes. In a freeform API environment, you can’t fully understand the downstream impacts of making changes to the contract. This works in the opposite direction too; clients with an updated view of the world talking to servers that remain in need of an update, including during rolling updates, can send requests that servers do not understand. There isn’t a good way to work around this as an organization. You either expect that the service will consistently break users, or you develop some sort of internal process to better manage changes to the contract. Many teams avoid making changes altogether, choosing instead to only add to their API as needs change. In any case, considerable time is wasted on internal communication, APIs drift, and users still break. Ultimately, teams want and need API evolution to be more strictly governed.</p><p>服务设计和维护的不一致方法还有另一个意想不到的影响：破坏更改。在自由格式的API环境中，您不能完全理解对合同进行更改的下游影响。这也是反向的；与仍需要更新的服务器交谈(包括在滚动更新期间)的客户端可以发送服务器不理解的请求。作为一个组织，没有一个很好的方法来解决这个问题。您要么希望该服务持续破坏用户，要么开发某种内部流程来更好地管理合同更改。许多团队避免完全进行更改，而是选择只在需求更改时添加他们的API。无论如何，相当多的时间浪费在内部通信上，API漂移，用户仍然中断。归根结底，团队希望并需要对API演进进行更严格的管理。</p><p> Many teams avoid making changes altogether, choosing instead to only add to their API as needs change. In any case, considerable time is wasted on internal communication, APIs drift, and users still break. Ultimately, teams want and need API evolution to be more strictly governed.</p><p>许多团队避免完全进行更改，而是选择只在需求更改时添加他们的API。无论如何，相当多的时间浪费在内部通信上，API漂移，用户仍然中断。归根结底，团队希望并需要对API演进进行更严格的管理。</p><p>  It’s time for the industry to shift from a freeform approach to a world where all APIs are defined programmatically with schemas. Schema driven development solves many of the challenges summarized above. APIs are much easier to grok and can be relied on from day one. Organizations can set and enforce API standards across multiple teams. Service owners can make the changes they need to their service, with more structure in place to prevent breaking clients.</p><p>现在是业界从自由形式方法转向所有API都以编程方式使用模式定义的时候了。模式驱动开发解决了上面总结的许多挑战。API更容易理解，而且从第一天起就可以依赖。组织可以在多个团队中设置和执行API标准。服务所有者可以根据需要对其服务进行更改，并建立更多的结构以防止客户端中断。</p><p>  This is already a major improvement, but the full opportunity for schemas to improve developer productivity is much greater. Similar to the way that statically typed languages enabled new potential for tools to improve developer productivity, the major promise of schema driven development is the assets that the schema can generate automatically. This is a topic big enough to explore in another article, but suffice it to say, relying on a schema can automate all of the boilerplate code required to actually interact with services.</p><p>这已经是一个重大改进，但是模式提高开发人员生产率的机会要大得多。与静态类型语言为工具带来新潜力以提高开发人员生产力的方式类似，模式驱动开发的主要承诺是模式可以自动生成的资产。这是一个大到足以在另一篇文章中探讨的主题，但可以说，依赖模式可以自动化实际与服务交互所需的所有样板代码。</p><p>  Today, schema driven API protocols are sometimes viewed as something you use only if performance matters. In the same way that typed languages needed tooling to support their adoption, a tooling ecosystem is needed to support the use of schema driven API protocols.</p><p>如今，模式驱动的API协议有时被视为只有在性能重要时才使用的协议。类型化语言需要工具来支持它们的采用，同样，需要一个工具生态系统来支持模式驱动的API协议的使用。</p><p>  We at Buf feel that the best option available today for schema driven development is Protocol Buffers (a topic we’ll explore in a future article), and we’re hard at work building such tooling to support organizations using Protobuf to define their services. We hope that with this kind of tooling, teams will look to API schemas for all-around productivity gains, and not just performance.</p><p>我们BUF认为，目前模式驱动开发的最佳选择是协议缓冲区(我们将在未来的文章中探讨这一主题)，我们正在努力构建这样的工具来支持使用Protobuf定义其服务的组织。我们希望，有了这种工具，团队将把目光投向API模式，以获得全面的生产力提升，而不仅仅是性能。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://buf.build/blog/api-design-is-stuck-in-the-past">https://buf.build/blog/api-design-is-stuck-in-the-past</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034772.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c83d0d8ca23f3104d0f7450b748daf39.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034772.html">苹果HomePod迷你评论：设计紧凑，价格合理，Siri速度快，但听起来不如类似价格的竞争对手</a></div><span class="my_story_list_date">2020-11-12 22:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034771.html"><img src="http://img2.diglog.com/img/2020/11/thumb_335f8e5f9f9993f06ce19d5b4508c834.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034771.html">Facebook重新设计了Instagram的布局，在应用程序的导航栏中增加了专门的购物标签和卷轴</a></div><span class="my_story_list_date">2020-11-12 22:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034582.html"><img src="http://img2.diglog.com/img/2020/11/thumb_8d0a0c3b53de30ee4d46b3264debb1d0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034582.html">盖伊·斯蒂尔：计算机科学中最流行的语言(2017)</a></div><span class="my_story_list_date">2020-11-12 1:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034362.html"><img src="http://img2.diglog.com/img/2020/11/thumb_481d23735450203347d99f64567a872c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034362.html">
苹果用苹果设计的M1芯片更新Mac Mini</a></div><span class="my_story_list_date">2020-11-11 3:1</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>