<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>高级GraphQL功能</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">高级GraphQL功能</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 16:44:22</div><div class="page_narrow text-break page_content"><p>GraphQL has become a widely adopted standard over the past few years. However, not everyone is taking advantage of the full capabilities of the standard. In this article, I’ll demonstrate methods for creating more expressive schemas that better fit your data needs.</p><p>在过去的几年里，GraphQL已经成为一个被广泛采用的标准。然而，并不是每个人都在利用该标准的全部功能。在本文中，我将演示创建更具表现力的模式以更好地满足您的数据需求的方法。</p><p>  Let’s start by defining an example scenario. We’re building a forum application, which will have several types of users:</p><p>让我们从定义一个示例场景开始。我们正在构建一个论坛应用程序，它将拥有几种类型的用户：</p><p> Administrators that manage the operations of the forum. For example, dealing with technical issues, assigning moderators, and more.</p><p>管理论坛操作的管理员。例如，处理技术问题、指定版主等。</p><p>  What might a schema for such a site look like? Let’s start off with a barebones schema. This example will be using a Node Express and GraphQL project. I’ll assume you already know how to do that, but I will include the entire project code at the bottom of the article later. Create a typeDefs.ts file like this. Notice that we’re using TypeScript, since the type annotations help make the code more clear.</p><p>这样一个站点的架构可能是什么样子的？让我们从一个基本架构开始。此示例将使用Node Express和GraphQL项目。我假设您已经知道如何做到这一点，但稍后我将在本文的底部包含整个项目代码。创建一个typeDefs.ts文件，如下所示。请注意，我们使用的是TypeScript，因为类型注释有助于使代码更清晰。</p><p>  import { gql } from &#34;apollo-server-express&#34;; const typeDefs = gql` type StandardUser { id: ID! userName: String! stars: Int! } type Moderator { id: ID! userName: String! stars: Int! categories: [Category!] } type Administrator { id: ID! userName: String! } type Category { id: ID! name: String! } `; export default typeDefs;</p><p>从&#34；appollo-server-express&#34；导入{gql}；const typeDefs=gql`类型StandardUser{id：id！用户名：String！明星：int！}类型版主{id：id！用户名：String！星星：INT！类别：[类别！]}类型管理员{id：id！用户名：字符串！}类型类别{id：id！名称：String！}`；导出默认typeDefs；</p><p>  You’ll notice that we have the three user types, and an additional type called Category, which represents the group that our posts will go into. However it’s clear there is repetition across our fields (e.g. id, username). It’s in fact possible to pull out a “base type” from each of the three user related types. Let’s attempt to do this by updating this schema using Interfaces.</p><p>您会注意到，我们有三个用户类型，以及一个名为Category的附加类型，它表示我们的帖子将进入的组。然而，很明显，我们的字段之间存在重复(例如，id、用户名)。实际上，可以从三个用户相关类型中的每一个中提取一个“基类型”。让我们尝试通过使用Interfaces更新此架构来实现此目的。</p><p>    An interface is just a skeleton of sorts. It’s a contract that declares rules, in this case specific fields, however it has no implementation and therefore cannot return data. Only types can. However since it does provide structure, we are using Interfaces to define base fields and then have our types implement those Interfaces. For example, if we update our typeDefs with Interfaces it could look like this.</p><p>界面只是某种形式的骨架。它是一个声明规则的约定，在本例中是特定的字段，但是它没有实现，因此不能返回数据。只有类型可以。但是，因为它确实提供了结构，所以我们使用接口来定义基本字段，然后让我们的类型实现这些接口。例如，如果我们使用Interfaces更新typeDefs，它可能如下所示。</p><p> const typeDefs = gql` interface Identifiable { id: ID! } interface User implements Identifiable { id: ID! userName: String! } interface Rating { stars: Int! } type StandardUser implements Identifiable &amp; User &amp; Rating { id: ID! userName: String! stars: Int! } type Moderator implements Identifiable &amp; User &amp; Rating { id: ID! userName: String! stars: Int! categories: [Category!] } type Administrator implements Identifiable &amp; User { id: ID! userName: String! } type Category implements Identifiable { id: ID! name: String! } `;</p><p>Const typeDefs=gql`接口可识别{id：id！}接口用户实现可识别{id：id！Username：string！}接口评级{STARS：INT！}类型StandardUser实现可识别的&amp；用户&amp；评级{id：id！用户名：String！STARS：INT！}类型版主实现可识别&amp；用户&amp；评级{id：id！用户名：String！星星：INT！类别：[类别！]}类型管理员实现可识别的&amp；用户{id：id！UserName：string！}类型类别实现可识别的{id：id！名称：String！}`；</p><p>  If we start at the top, you’ll see our first interface is called Identifiable. Since all of the entities in our data model have a unique ID, this interface will be the base for all of our entities. Next, we see that the User interface implements the Identifiable interface. Notice how User has both the id field and its own field called userName. When a type or interface implements an interface, they must implement all of its fields.</p><p>如果我们从顶部开始，您将看到我们的第一个界面名为“可识别”。因为我们的数据模型中的所有实体都有一个惟一的ID，所以这个接口将是我们所有实体的基础。接下来，我们看到用户界面实现了可识别接口。请注意，用户如何同时拥有id字段和自己的字段(名为username)。当类型或接口实现接口时，它们必须实现其所有字段。</p><p>  Next up we have another interface called Rating. Since two of our types StandardUser and Moderator use the stars field, but Administrator does not, we have this interface so that only the types that use the stars field can implement it – otherwise, the User models can skip it.</p><p>接下来，我们有另一个名为Rating的接口。因为我们的两个类型StandardUser和Master使用STARS字段，而管理员没有，所以我们有这个接口，以便只有使用STARS字段的类型才能实现它-否则，用户模型可以跳过它。</p><p>  Now, we finally have our actual types StandardUser, Moderator, and Administrator, where each one implements only the interfaces it needs by using an &amp; symbol to denote more than one interface being implemented. Then lastly the Category type.</p><p>现在，我们终于拥有了实际的StandardUser、Master和Administrator类型，其中每个类型都使用&amp；符号表示要实现的多个接口，从而仅实现其所需的接口。最后是类别类型。</p><p>  So, as you can see this set of types and hierarchies is quite reminiscent of most modern programming languages, for example TypeScript.</p><p>因此，正如您所看到的，这组类型和层次结构非常类似于大多数现代编程语言，例如TypeScript。</p><p>  We now have a reasonable schema model. Let’s try querying it. Update the typeDefs variable by adding this Query.</p><p>我们现在有了一个合理的模式模型。让我们试着查询一下。通过添加此查询更新typeDefs变量。</p><p>   As you can see, we’ve added a function that retrieves all of our site’s users, but returns them as an array of Users. Let’s now write our resolver and see if this will work. First create your resolver file like the following:</p><p>如您所见，我们添加了一个函数，该函数检索站点的所有用户，但将他们作为用户数组返回。现在让我们编写解析器，看看这是否可以工作。首先创建您的解析器文件，如下所示：</p><p> import { IResolvers } from &#34;apollo-server-express&#34;; import { getAllUsers, User } from &#34;../dataService&#34;; import { GqlContext } from &#34;./GqlContext&#34;; const resolvers: IResolvers = { Query: { getAllUsers: async ( parent, args: null, ctx: GqlContext, info: any 	): Promise &gt; =&gt; { return getAllUsers(); 	}, }, }; export default resolvers;</p><p>从&#34；Apollo-server-express&#34；导入{IResolvers}；从&#34；../dataService&#34；导入{GqlContext}；从&#34；导入{GqlContext}。/GqlContext&#34；；Const解析器：IResolvers={query：{getAllUsers：async(parent，args：null，ctx：GqlContext，info：any)：Promise&gt；=&gt；{return getAllUsers()；}，}，}；导出默认解析器；</p><p> Our resolver’s only action is to call our getAllUsers function in order to retrieve the actual data. You’ll notice that our getAllUsers resolver is returning an array of User Interfaces. This should be a bit suspicious, but for now let’s just see what happens.</p><p>我们的解析器唯一的操作是调用getAllUsers函数来检索实际数据。您会注意到，我们的getAllUsers解析器返回一个用户界面数组。这应该有点可疑，但现在让我们看看会发生什么。</p><p>  Now we must implement the getAllUsers function in code. But to make this article simpler and focus on GraphQL we’ll create a function that returns hard coded values. Create a file called dataService.ts and add this code.</p><p>现在，我们必须在代码中实现getAllUsers函数。但为了使本文更简单，并将重点放在GraphQL上，我们将创建一个返回硬编码值的函数。创建名为dataService.ts的文件并添加以下代码。</p><p>  import { v4 } from &#34;uuid&#34;; export interface Identifiable { id: string; } export interface User extends Identifiable { userName: string; } export interface Rating { stars: number; } export class StandardUser implements User { constructor( public id: string, public userName: string, public stars: number ) {} } export class Moderator implements User { constructor( public id: string, public userName: string, public stars: number, public categories: [Category] ) {} } export class Administrator implements User { constructor(public id: string, public userName: string) {} } export class Category implements Identifiable { constructor(public id: string, public name: string) {} } export function getAllUsers() { const users: Array  = []; users.push(new StandardUser(v4(), &#34;dave&#34;, 4)); users.push(new Moderator(v4(), &#34;ruth&#34;, 5, [new Category(v4(), &#34;Cooking&#34;)])); users.push(new StandardUser(v4(), &#34;jane&#34;, 5)); users.push(new StandardUser(v4(), &#34;tom&#34;, 1)); users.push(new Administrator(v4(), &#34;linda&#34;)); users.push( new Moderator(v4(), &#34;tom&#34;, 2, [new Category(v4(), &#34;Programming&#34;)]) ); users.push(new Administrator(v4(), &#34;betty&#34;)); return users; }</p><p>从&#34；uuid&#34；导入{v4}；导出接口可标识{id：string；}导出接口用户扩展可标识{username：string；}导出接口评级{STARS：NUMBER；}导出类StandardUser实现user{structor(public id：string，public username：string，public star：number){}}导出类版主实现user{structor(public id：string，public username：string，public star：number，public ategories：[类别]){}}导出类管理员实现user{structor(public id：string，public username：string){}}导出类类别实现可识别的{structor(public id：string，public name：string){}}export函数getAllUsers(){const Users：array=[]；Users.ush(new StandardUser(v4()，&#34；dave&#34；，4))；users.ush(new版主(v4()，&#34；Ruth&#34；，5，[new Category(v4()，&#34；Cooking&#34；)])；users.ush(new StandardUser(v4()，&#34；Jane&#34；，5))；users.ush(new StandardUser(v4()，&#34；tom&#34；，1))；Users.ush(new Administrator(v4()，&#34；linda&34；))；users.ush(new版主(v4()，&#34；tom&#34；，2，[new Category(v4()，&#34；Programming&#34；)])；users.ush(new Administrator(v4()，&#34；Betty&#34；))；返回用户；}。</p><p>  Our dataService contains all of our TypeScript types that mirror our GraphQL schemas, as well as the getAllUsers function that returns a list of objects that inherit from our User Interface. As you can see, getAllUsers all types of Users, including StandardUsers and Administrators, but since they all implement the User interface (i.e. User is the parent type for all of them), the function’s return type is set as an array of User types. Now let’s try querying it!</p><p>我们的dataService包含反映我们的GraphQL模式的所有类型脚本类型，以及返回从用户界面继承的对象列表的getAllUsers函数。如您所见，getAllUsers使用所有类型的用户，包括StandardUsers和Administrators，但是由于他们都实现了用户界面(即User是所有用户的父类型)，所以函数的返回类型被设置为一组用户类型。现在让我们试着查询一下！</p><p>  Open your GraphQL playground by opening your browser to the GraphQL server URL, which would be something like http://localhost:&lt;port number&gt;/graphql. Then add this Query as shown.</p><p>通过打开浏览器访问GraphQL服务器URL(类似于http://localhost：&lt；port Number&&gt;；/GraphQl)，打开您的GraphQL游乐场。然后添加此查询，如下所示。</p><p>   This is our Query for getAllUsers, but instead of fields we see three periods. What we’re seeing with the “…” is called an inline Fragment. This tells the GraphQL service which type of data we are looking for. In this case we indicate that we want the Interface User and its fields of id and userName.</p><p>这是我们对getAllUsers的查询，但是我们看到的不是字段，而是三个句点。我们看到的“…”称为内联片段。这将告诉GraphQL服务我们要查找的数据类型。在本例中，我们指出需要Interface User及其id和username字段。</p><p>  So let’s try and run this Query, but when we do we get this error shown.</p><p>因此，让我们尝试运行此查询，但当我们这样做时，会显示此错误。</p><p>    What does this error mean? If we look back at our definition of GraphQL Interfaces we said they only have declarations, but no implementations. Therefore, we need to replace the interface with an implementation of the interface, the type, that does return data. Let’s see how to do that.</p><p>这个错误意味着什么？如果我们回顾一下我们对GraphQL接口的定义，我们会说它们只有声明，没有实现。因此，我们需要将接口替换为接口的实现，即返回数据的类型。让我们看看如何做到这一点。</p><p>   User: { __resolveType(obj: any, ctx: GqlContext, info: any) { if (obj.categories) { return &#34;Moderator&#34;; 	} else if (obj.stars) { return &#34;StandardUser&#34;; 	} return &#34;Administrator&#34;; 	}, },</p><p>用户：{__Resolution veType(obj：any，ctx：GqlContext，info：any){if(obj.ategories){return&#34；；版主&#34；；}Else if(obj.star){return&#34；StandardUser&34；；}return&#34；Administrator&#34；；}，}，</p><p>  By defining the User Interface in our resolvers we are telling GraphQL that when it encounters the User in a Query it should instead return one of the specific types listed. Note, the logic of how to go about determining this is entirely up to you. However an obvious potential way of doing this would be to use member fields unique to each type, as we have done here.</p><p>通过在解析器中定义用户界面，我们告诉GraphQL，当它在查询中遇到用户时，应该返回列出的特定类型之一。请注意，如何确定这一点的逻辑完全取决于您。但是，一种明显的潜在方法是使用每种类型唯一的成员字段，就像我们在这里所做的那样。</p><p>      Clearly this works, but we’re not getting all the related fields and it’s hard to tell which type each returned item is. Let’s update our query a bit to show these details.</p><p>显然，这是可行的，但是我们没有获得所有相关字段，并且很难判断每个返回的项是哪种类型。让我们稍微更新一下查询以显示这些详细信息。</p><p>    If we go over this Query, we can see that by using the __typename field we get back the type name of every item in our result set. So that definitely helps clarify things somewhat. However only the StandardUser type is returning actual fields. The other types are indicated, but their type-specific data is blank! It’s clear what we need to do so let’s take a stab at it.</p><p>如果我们遍历此查询，可以看到通过使用__typeName字段，我们可以获得结果集中每一项的类型名称。因此，这在一定程度上肯定有助于澄清一些事情。但是，只有StandardUser类型返回实际字段。显示了其他类型，但具体类型数据为空！我们需要做什么是很清楚的，所以让我们试一试吧。</p><p>   As you probably guessed, we needed to add our other types and their specific fields. For example, in the case of Moderator we have a unique field called categories, Since the category is its own type as well, we also specified the “name” member from the type.</p><p>正如您可能猜到的那样，我们需要添加其他类型及其特定字段。例如，在Master的情况下，我们有一个名为Categories的唯一字段，因为该类别也是它自己的类型，所以我们还从类型中指定了“name”成员。</p><p>  Now we’ve got everything working! Alas, there’s one small issue. Even after implementing such robust types, we’re still repeating the id and userName fields multiple times. In this case, it doesn’t matter much. But for larger data models, it’s quite easy to have dozens of shared fields – imagine specific all those fields repeatedly!</p><p>现在我们已经把一切都准备好了！唉，还有一个小问题。即使在实现了这样的健壮类型之后，我们仍然要多次重复id和username字段。在这种情况下，这无关紧要。但是对于较大的数据模型，拥有几十个共享字段是相当容易的-想象一下重复指定所有这些字段！</p><p>  We’ve already seen how we can use inline Fragments to indicate the fields we want for a specific type, but we can also use Fragments to help reduce repetition. Let’s update our Query one more time like this.</p><p>我们已经看到了如何使用内联片段来指示我们想要的特定类型的字段，但是我们也可以使用片段来帮助减少重复。让我们像这样再次更新我们的查询。</p><p>    That’s much better. We were able to remove the redundancy and make our code cleaner. Now let’s make one more change to improve things further.</p><p>那好多了。我们能够删除冗余并使我们的代码更干净。现在，让我们再做一次更改，以进一步改善情况。</p><p>    A Union in GraphQL is a type that could be one of several type definitions. For example, this is what a Union for our schema types could look like.</p><p>GraphQL中的UNION是一种可以是几个类型定义之一的类型。例如，我们的模式类型的UNION可能是这样的。</p><p>   If we now make our getAllUsers Query function return a Result Union instead of the User Interface, it becomes much clearer what specific types we were intending to return. Additionally, in larger schemas, it is possible that we may want to have Unions for different purposes so that one Union may only contain two of several types in our schema while another Union might contain several other types.</p><p>如果我们现在让getAllUsers查询函数返回一个Result Union而不是User Interface，那么我们打算返回哪些特定类型就变得更加清楚了。此外，在较大的模式中，我们可能希望将UNION用于不同的目的，以便一个UNION在我们的模式中只能包含几个类型中的两个，而另一个UNION可能包含几个其他类型。</p><p>  Now that we’ve created a Union, we also need to create a resolver for it. For our schema the resolver implementation can actually be the same as the User resolver. It would look like this.</p><p>现在我们已经创建了一个Union，我们还需要为它创建一个解析器。对于我们的模式，解析器实现实际上可以与用户解析器相同。它看起来会是这样的。</p><p> Result: { __resolveType(obj: any, ctx: GqlContext, info: any) { if (obj.categories) { return &#34;Moderator&#34;; 	} else if (obj.stars) { return &#34;StandardUser&#34;; 	} return &#34;Administrator&#34;; 	}, },</p><p>结果：{__ResolveType(obj：any，ctx：GqlContext，info：any){if(obj.ategories){return&#34；；版主&#34；；}Else if(obj.star){return&#34；StandardUser&34；；}return&#34；Administrator&#34；；}，}，</p><p> If you re-run the last query as is, it should work the same as before. In the case of our sample app, it happens to be the same implementation. In a more complete and realistic schema, it can and would be different – we’d have many different types, with differences in the way they could be combined together into a Union.</p><p>如果您按原样重新运行最后一个查询，它的工作方式应该与以前相同。在我们的样例应用程序中，它恰好是相同的实现。在更完整、更现实的模式中，它可以也将是不同的-我们会有许多不同的类型，在将它们组合成一个UNION的方式上会有所不同。</p><p>  In this tutorial, you were introduced to Interfaces, Fragments, and Unions. Each feature can help improve your schemas to more precisely align to your data needs and be more easily queryable.</p><p>在本教程中，我们向您介绍了接口、片段和联合。每个特性都可以帮助改进您的模式，使其更精确地符合您的数据需求，并且更易于查询。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.getcortexapp.com/post/more-sophisticated-schemas-with-advanced-graphql-features">https://www.getcortexapp.com/post/more-sophisticated-schemas-with-advanced-graphql-features</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>