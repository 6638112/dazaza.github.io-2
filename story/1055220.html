<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在戈兰尼尔兔洞下来 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在戈兰尼尔兔洞下来 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 12:04:50</div><div class="page_narrow text-break page_content"><p>我不确定我还有另一个生锈＆amp; Postgres在我身上博客帖子现在，唯一的学习了一些关于去的东西。</p><p> 最近我决定我想向Omegasort添加一个 -  unique标志。等等，有什么看法？</p><p> 这是一个文本文件排序工具，支持许多不同的排序方法。例如，此外，另外一个标准文本排序，它可以对NumberEedLines，日期前缀行，路径（包括Windows Paths包含Windows路径），IP地址和IP网络。它还支持Unicodelocales，反向排序和语言环境感知差点分类。</p><p> 我将它与preciouso排序的东西一起使用，如.gitignore文件，拼写检查程序alletlists和thatthatthatthat的东西。</p><p> 我意识到我真的想要一个 - 所有这一切的国旗。虽然Icould在* nix系统上将其输出输出到Uniq，但这在Windows上不起作用。此外，如果我可以为特定任务使用一个单一的任务，那么用工具可以更容易。如果我想用管东西在阿什尔脚本中掌握那种宝贵的电话。</p><p> 但我的兔子洞经验没有直接用omegasort发生。相反，它发生在我尝试添加一些集成测试时发生。</p><p> 在编写这些集成测试时，我使用github.com/houseabsolute/detest。 ITINIS I创建的Golang软件包，提供了一个测试断言界面，它在Perl中的Test2-Suite启发。 </p><p>使用test2 ::套房;对象subtest =＆gt;子{呼叫名称=＆gt; ＆＃39; testsfor :: basic＆＃39; ;呼叫通行证=＆gt; T（）;呼叫子宫=＆gt;数组{对象计划=＆gt;子{呼叫max =＆gt; 4;呼叫跟踪=＆gt;对象{呼叫包=＆gt; ＆＃39; test :: class :: moose ::角色:: executor＆＃39; ;呼叫子名称=＆gt; ＆＃39; test :: class :: moose :: util :: context_do＆＃39; ; }; }; ...}</p><p> 除了T（）外，我认为这是非常自我解释的，这意味着“真实”。</p><p>  进口（＆＃34;测试＆＃34;＆＃34; github.com/houseabsolute/detest/pkg/detest& lap34;）func testsomething（t * testing。t）{d：=讨厌。新（t）d。是（somestuct，d。struct（stecc（st * detest。Structtester）{st。字段（＆＃34; size＆＃34; 43）st。字段（＆＃34;名称＆＃34;和＃34;道格拉斯＆ ＃34;）d。地图（Func（MT *抢劫）{Mt。钥匙（＆＃34; foo＆＃34; d。切片（Func（st * dibestess）{st。Idx（0，d 。地图（Func（MT *抢劫）{MT.键（＆＃34;酒吧＆＃34;，d。切片（Func（st *抢劫）{st。idx（1，＆＃34; buz＆＃ 34;）ST。IDX（2，＆＃34;不是QUUX＆＃34;）}）））））}））ST。IDX（1，D. MAP（FUNC（MT *讨论）MAPTESTER）{MT。键（＆＃ 34; Nosuchkey＆＃34;，d。切片（Func（ST *抢劫。Slicetester）{ST。IDX（1，＆＃34; Buz＆＃34; Buz＆＃34;）st。Idx（2，＆＃34;不是QUUX＆＃34; ）}））}））}）}）}），）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）。</p><p> 它不像Perl版本那么好，因为它变得非常冗长，但是我可以来的最接近的。 Go的类型系统，结合缺乏个性的灵活性，意味着整个努力呼叫，牙套和柱子。</p><p> 在引擎盖下，这是使用STDLIB的反射包装的公制叉吨RuntimeReflection实现。我不喜欢这个，但缺乏泛型，除了Codegeneration之外，没有其他方法可以实现这种API。那据，该代码必须由一个anabagethat被翻译成真实的and，这似乎是一个可怕的想法。</p><p>  因此，虽然我正在使用讨论者编写那些omegasort集成测试，但致命地发现讨论了很多错误。</p><p>  所以这是一个有趣的事实，Go有多种“类型”的零。具体而言，身体既可键入和没有型号的零变量。这首先惊讶了我，但是当你想到它时它就会感觉到。 </p><p>包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{v1：=反映。 valueof（nil）var uninit [] int v2：=反射。 valueof（uninit）logvalue（＆＃34; nil＆＃34;，v1）logvalue（＆＃34; [] int＆＃34;，v2）fmt。 printf（＆＃34; [] int == nil？％v \ n＆＃34;，uninit == nil）} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}}</p><p>  nil有效？假[] int有效？真实[] int是nil？ true [] int type = [] int [] int == nil？真的</p><p> 所以一个裸露的nil和一个有一个类型但没有值的变量是相等的，但如果你试图得到一个反射。对于nil，它无效。如果您尝试在无效的2 reflex.value上调用V.Isnil（）或v.type（）这样的其他方法.Value，您将获得恐慌。</p><p> 我在尝试测试Func Callwas Nil返回的错误时遇到过这一点。</p><p> 这导致了一系列的拆除术，因为我意识到这种受影响的遗弃代码的HowMany部分。在它使用的大多数地方，我必须防范裸露的零。</p><p> 但等等，它变得更加令人困惑。有时，Go编译器将将AnUnty Nil转换为键入的NIL。这是一个例子3：</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{ta​​kesslice（＆＃34; nil＆＃34;，nil）var uninit [] int tapesslice（＆＃34; [] int＆＃34;，uninit）} func takesslice（什么字符串，s [] int）{logvalue（什么，反映。valyof（s））} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}} </p><p>nil有效？ Truenil是零吗？ truenil type = [] int [] int有效？真实[] int是nil？ true [] int type = [] int</p><p> 因此，当我裸露的零才能传递给Taklice时，它会被打字，就像典型的函数的签名所说应该是。</p><p> 但等等，它又更加困惑！有时，Go编译器不会将一个没有型号的NIL转换为键入的NIL。这是一个例子4：</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{ta​​keerror（＆＃34; nil＆＃34;，nil）var uninit retererror（＆＃34;错误＆＃ 34;，UNINIT）} FUNC TAKERROR（什么字符串，E错误）{LOGVALUE（什么，反映。value（e））} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}}</p><p> 如果函数签名中的参数的类型是任何类型的接口，包括接口{}，那么底层值仍然是untypedand而无效。这个＆amp; mldr有意义吗？我认为这项工作的方法是作为界面键入的东西也有一个真正的底层类型。所以错误可以是错误.Errorring或exec.exitError或mypackage.dogError。但如果我们通过裸露的零或未初始化的Variable，那么没有底层类型。</p><p> 当我想测试我没有收到错误时，这提出了困难。</p><p>  在引擎盖下，D.is（）的签名使用界面{}进行比较的双轨。如此裸露的，因为第二个论点永远不会是无效的。第一个参数可能有效或可能不是。如果dothing（）的返回类型只是错误，并且它返回一个nil，那么Err中的Value没有类型。 </p><p>所有这一切都导致了讨论的比特在讨论的肠道中的代码。例如，因为两个变量没有相同的类型，但它们不等于（从Go的角度来看）。与==相比，裸零和anuninitialized切片相等，这是D.IS（）使用反射模拟的。</p><p> 因此，在一个或两个参数上存在相当多的案例无效的处理。还有许多具有同一问题的其他方法，包括D.Cap（）和d.struct等内容，所有这些都应该正确处理无效值。</p><p>  好吧，我不知道很多其他语言。在Perl中，这并不是真正的阴沉，因为它具有一个非常最小的系统。 Perl的Undef可以因为在严格试图在特定的时候在严格尝试时是一个错误，就像写这一点一样：</p><p>  这将爆炸罐＆＃39; t在第2行使用未定义的值作为数组参考。</p><p> RUDE（至少安全生锈5）没有任何缺陷或未定义的valiues。相反，您有选项＆lt; t＆gt;始终具有类型的类型。例如6：</p><p> PUB FN MAIN（）{让答：选项＆lt;字符串＆gt; =没有;让B：选项＆lt; I32＆gt; =没有; println！ （＆＃34; a == b？{}}＆＃34;，a == b）; }</p><p> 这将无法编译。虽然A和B都没有，但它们不是相同的无，所以你不能用==比较它们。编译： </p><p>错误[E0308]：不匹配类型 - ＆gt; src / main.rs：4：33 | 4 | println！（＆＃34; a == b？{}}}}}}} == b）; | ^预期的struct` string`，发现`i32` =注意：预期enum`选项＆lt; string＆gt;'找到enum`选项＆lt; i32＆gt;`</p><p> 顺便问一下，不是这些生锈编译器错误很好吗？使用此类极其详细的编译器错误的唯一其他语言是Raku。</p><p>  选择Go并抱怨它很诱人。我当然会做那么棒。但要公平，这真的不是最多的代码问题。它，因为我正在尝试做奇怪的东西，反映我正在学习这种内心怪异。在日常之路代码中，编译器的处理方式“只是作品”的方式，就像你期望的那样。使用裸零是非常方便的。</p><p> 但我仍然喜欢使用参数化选项＆lt; t＆gt;类型。这样我可以轻松检查某些东西是否没有任何特殊套件。一切都在使用相同类型的系统，虽然那种系统是比Go的更复杂。</p><p> 请注意，反映的上下文中的“无效”值不是无效的Go程序的上下文。您可以使用无效的值，每一个地都可以使用相应的有效但未初始化的nil值。 ↩︎</p><p>   我对不安全的生锈很少，这就是我对冲的原因。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.urth.org/2021/03/27/down-the-golang-nil-rabbit-hole/">https://blog.urth.org/2021/03/27/down-the-golang-nil-rabbit-hole/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/兔洞/">#兔洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nil/">#nil</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>