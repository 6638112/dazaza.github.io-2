<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们在Go中编写GitHub操作We Write GitHub Actions in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">We Write GitHub Actions in Go<br/>我们在Go中编写GitHub操作</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 12:39:48</div><div class="page_narrow text-break page_content"><p>Since the  release of GitHub Actions in 2019, GitHub has been heavilyinvesting in improvements to the CI / CD experience. As part of thisinvestment, repeatable tasks can be provided as  custom actions andshared externally with the community or internally within a GitHub Enterpriseinstance.</p><p>自2019年发布GitHub Actions以来，GitHub一直在大力改进CI/CD体验。作为这项投资的一部分，可重复的任务可以作为自定义操作提供，并在社区外部或GitHub Enterpriseinstance内部共享。</p><p> At Blend, we’ve benefited from adopting GitHub Actions. We have builttooling that enables writing an action in Go and automates the releaseprocess for actions within our GitHub Enterprise instance. Below, we’ll sharethe set of unique challenges for running and releasing actions written in Goand outline our strategies for solving these problems.</p><p>在Blend，我们从采用GitHub操作中受益匪浅。我们已经构建了能够在Go中编写动作的工具，并自动化了GitHub企业实例中动作的发布过程。下面，我们将分享运行和发布用GOA编写的操作的一系列独特挑战，并概述我们解决这些问题的策略。</p><p>  GitHub has published lots of tutorials and many fundamentalactions  1 as examples. In order to let the community usethe same tools, they have released the  @actions/core package on  npm.</p><p>GitHub发布了大量教程和许多基础动作1作为示例。为了让社区使用相同的工具，他们在npm上发布了@actions/core包。</p><p> An action is a GitHub repository with a root action.yml file and supporting files. For authors of an action,the most common choice is to write it  in JavaScript and run the codenatively on the actions runner during the workflow. If that isn’t anoption  2, a  Docker container action allows runninga Docker image; the image can either be built directly from a Dockerfile orpulled from a public Docker registry.</p><p>action是带有根操作的GitHub存储库。yml文件和支持文件。对于动作的作者来说，最常见的选择是用JavaScript编写动作，并在工作流期间在动作运行程序上以代码方式运行。如果这不是选项2，Docker容器操作允许运行Docker映像；图像可以直接从Docker文件构建，也可以从公共Docker注册表获取。</p><p> The third option, a  composite action, allowscreating an action as a series of steps (very similar to how jobs work ina GitHub Actions workflow). This makes it possible to write lightweightactions—e.g. with shell scripts. A composite action can even reference other actions in those steps.</p><p>第三个选项是复合操作，它允许将操作创建为一系列步骤（非常类似于GitHub操作工作流中作业的工作方式）。这使得编写轻量级操作成为可能，例如使用shell脚本。复合动作甚至可以引用这些步骤中的其他动作。</p><p>  To distribute our actions written in Go, we build static binaries fromthe source code and check them into the GitHub repository for theaction.</p><p>为了分发用Go编写的操作，我们从源代码中构建静态二进制文件，并将它们签入GitHub存储库中以供操作。</p><p>  For an action that needs to run on both 64-bit x86 and ARMmachines running Linux or Windows, it would be enough to use six files:</p><p>对于需要在运行Linux或Windows的64位x86和ARM机器上运行的操作，使用六个文件就足够了：</p><p> $ tree.├── action.yml├── invoke-binary.js├── main-linux-amd64-e9d351bd367300ec85b9ba777812c42be2570a64├── main-linux-arm64-e9d351bd367300ec85b9ba777812c42be2570a64├── main-windows-amd64-e9d351bd367300ec85b9ba777812c42be2570a64└── main-windows-arm64-e9d351bd367300ec85b9ba777812c42be2570a640 directories, 6 files</p><p>$tree。├── 行动yml├── 调用二进制文件。js├── main-linux-amd64-e9d351bd367300ec85b9ba777812c42be2570a64├── main-linux-arm64-e9d351bd367300ec85b9ba777812c42be2570a64├── main-windows-amd64-e9d351bd367300ec85b9ba777812c42be2570a64└── main-windows-arm64-e9d351bd367300ec85b9ba777812c42be2570a640目录，6个文件</p><p> In order to invoke the  correct static binary, we use a tiny JavaScript shim to determine the current operating system ( GOOS) andplatform / architecture ( GOARCH). The shim dispatches the correct staticbinary as follows:</p><p>为了调用正确的静态二进制文件，我们使用一个小小的JavaScript垫片来确定当前的操作系统（GOOS）和平台/架构（GOARCH）。垫片发送正确的静态二进制文件，如下所示：</p><p> function  chooseBinary ( )  {  // ...   if  ( platform  ===  &#39;linux&#39;  &amp;&amp;  arch  ===  &#39;x64&#39; )  {  return  ` main-linux-amd64- ${ VERSION } `  }  // ...  } const  binary  =  chooseBinary ( ) const  mainScript  =  ` ${ __dirname } / ${ binary } ` const  spawnSyncReturns  =  childProcess . spawnSync ( mainScript ,  {  stdio :  &#39;inherit&#39;  } )</p><p>函数选择binary（）{/…if（平台==&#39；linux&#39；&amp；&amp；&amp；arch===&#39；x64&#39；）{return`main-linux-amd64-${VERSION}`/..}const binary=chooseBinary（）const mainScript=`${_dirname}/${binary}`const spawnsynchreturns=childProcess。spawnSync（主脚本，{stdio:&#39；继承&#39；}）</p><p> and in the  action.yml we just “pretend to be JavaScript” to call out toour shim:</p><p>在行动中。yml我们只是“假装是JavaScript”来呼唤我们的shim：</p><p>   At Blend, we maintain all Go actions in our internal Go monorepo. We publishthem into the  actions organization within our GitHub Enterpriseinstance. When a Go action is updated, a post-merge step builds static binariesfor the subset of architectures we need to support and pushes a commit directlyto the respective  actions/${ACTION} repository. For example, changes in theGo monorepo to code in  project/github-actions/{cmd,pkg}/build-docker-image/will result in a commit to the  actions/build-docker-image repository.</p><p>在Blend，我们在内部Go monorepo中保留所有Go操作。我们将其发布到GitHub Enterpriseinstance内的actions组织中。更新Go操作时，合并后的步骤会为我们需要支持的体系结构子集构建静态二进制文件，并将提交直接推送到相应的actions/${action}存储库。例如，将Go monorepo更改为project/github actions/{cmd，pkg}/build docker image/中的代码将导致提交到actions/build docker image存储库。</p><p>  Using this approach, an action written in Go runs  immediatelyin the same way an action written in JavaScript does. We eliminate theneed for  any Go dependencies on the actions runner: GitHub only grabs our invoke-binary.js and static binaries. To make the retrieval fast, we go outof our way to  shrink the static binaries and make a special “release”branch that contains a minimal set of files to run theaction  3.</p><p>使用这种方法，用Go编写的操作会立即运行，就像用JavaScript编写的操作一样。我们消除了对actions runner的任何Go依赖：GitHub只获取我们的调用二进制文件。js和静态二进制文件。为了加快检索速度，我们特意压缩静态二进制文件，并创建一个特殊的“发布”分支，其中包含运行Action 3所需的最小文件集。</p><p> Our approach of using prebuilt binaries is the same idea in spirit as therecommended approach for JavaScript actions. For JavaScript actions, itis recommended to use the  ncc  compiler to create a single  index.jsfile. With this  single file entrypoint, the action just executesthat file without any other setup necessary. Since Go is a compiled language,there is no direct equivalent of the “I have some source code and aninterpreter” Node.js approach, hence the need for including prebuilt binaries.Interestingly enough, the  ncc project lists the Go compiler as one of itsmotivations, so there must be something there!</p><p>我们使用预构建二进制文件的方法与推荐的JavaScript操作方法在精神上是相同的。对于JavaScript操作，建议使用ncc编译器创建单个索引。jsfile。有了这个单文件入口点，操作就可以执行该文件，而无需任何其他必要的设置。由于Go是一种编译语言，所以并没有“我有一些源代码和解释程序”节点的直接等价物。js方法，因此需要包含预构建的二进制文件。有趣的是，ncc项目将Go编译器列为其动机之一，所以肯定有什么原因！</p><p>  This approach can absolutely be used by programming language ecosystems otherthan Go. For example, with the Nuitka  compiler for Python, standaloneexecutables can be produced in the same way. For compiled languages like C++ orRust, creating prebuilt binaries can be straightforward.</p><p>这种方法绝对可以被编程语言生态系统而不是Go使用。例如，使用针对Python的Nuitka编译器，可以以相同的方式生成StandaloneExecutable。对于C++语言这样的编译语言，创建预构建的二进制文件是很简单的。</p><p> One unique advantage Go has in this arena is the default mode of creating statically linked binaries. This makes it much easier to  just run ona new machine without needing  4 to install or locate dependencies.Additionally, the Go compiler’s ability to  cross-compile binaries from asingle development machine is incredibly useful for the distribution strategywe use here:</p><p>Go在这个领域的一个独特优势是创建静态链接二进制文件的默认模式。这使得只在一台新机器上运行而不需要安装或定位依赖项变得更加容易。此外，Go编译器从单个开发机器交叉编译二进制文件的能力对于我们在这里使用的分发策略非常有用：</p><p>    As a rule, we try to make  cmd/${ACTION}/main.go scripts as short as possibleso we can maximize the amount of code that can be tested  5:</p><p>通常，我们尝试将cmd/${ACTION}/main设置为。go脚本尽可能短，这样我们可以最大限度地增加可测试的代码量5：</p><p> // FILE: cmd/hypothetical/main.go  package  main import  (	 &#34;context&#34;	 githubactions  &#34;github.com/sethvargo/go-githubactions&#34;	 &#34;github.com/blend/hypothetical-action/pkg/hypothetical&#34; ) func  run ( )  error  {	 ctx  :=  context . Background ( )	 action  :=  githubactions . New ( )	 cfg ,  err  :=  NewFromInputs ( action )	 if  err  !=  nil  {		 return  err	 }	 return  hypothetical . Run ( ctx ,  cfg ) } func  main ( )  {	 err  :=  run ( )	 if  err  !=  nil  {		 action . Fatalf ( &#34;%v&#34; ,  err )	 } }</p><p>//文件：cmd/impositional/main。go软件包主要导入（&#34；context&#34；githubactions&#34；github.com/sethvargo/go githubactions&#34；&#34；github.com/blend/impositional action/pkg/impositional&#34；）func run（）错误{ctx:=context.Background（）操作：=githubactions.New（）cfg，err:=NewFromInputs（操作），如果err！=nil{return err}返回假设。Run（ctx，cfg）}func main（）{err:=Run（），如果err！=nil{action.Fatalf（&#34；%v&#34；，err）}</p><p>  By loading  all inputs and configuration at the outset, an actioncan be much easier to reason about: once parsed, a single configurationstruct can be passed to the code implementing the business logic. For example:</p><p>通过从一开始就加载所有输入和配置，可以更容易地对操作进行推理：解析后，可以将单个configurationstruct传递给实现业务逻辑的代码。例如：</p><p> // FILE: pkg/hypothetical/config.go  type  Config  struct  {	 Role  string	 LeaseDuration  time . Duration } func  NewFromInputs ( action  * githubactions . Action )  ( * Config ,  error )  {	 lease  :=  action . GetInput ( &#34;lease-duration&#34; )	 d ,  err  :=  time . ParseDuration ( lease )	 if  err  !=  nil  {		 return  nil ,  err	 }	 c  :=  Config {		 Role :  action . GetInput ( &#34;role&#34; ) ,		 LeaseDuration :  d ,	 }	 return  &amp; c ,  nil }</p><p>//文件：pkg/impositional/config。go type Config struct{Role string LeaseDuration time.Duration}func NewFromInputs（action*githubactions.action）（*Config，error）{lease:=action.GetInput（&#34；lease Duration&#34；）d，err:=时间。如果出现错误，解析持续时间（租约）=nil{return nil，err}c:=Config{Role:action.GetInput（&#34；Role&#34；），租赁：d、}退货&amp；c，无}</p><p>  The  sethvargo/go-githubactions project provides an idiomaticGo package that is roughly equivalent to the  @actions/core JavaScript package. We utilize it wherever we can, but try to follow some largerprinciples to write testable code.</p><p>sethvargo/go githubactions项目提供了一个与@actions/core JavaScript包大致相当的惯用软件包。我们尽可能地利用它，但尝试遵循一些更大的原则来编写可测试代码。</p><p> When writing code that uses the  githubactions package, a pointer action *githubactions.Action should be used rather than the global wrappersaround the package  defaultAction  struct. For example:</p><p>在编写使用githubactions包的代码时，指针操作*githubactions。应该使用Action，而不是包defaultAction结构周围的全局包装器。例如：</p><p>  In order to test code involving GitHub Actions, it’s critical to be able toboth control environment variables (these are inputs) and to monitor writes toSTDOUT. In order to do this in tests, both the STDOUT writer and the Getenv() provider can be replaced:</p><p>为了测试涉及GitHub操作的代码，关键是既要能够控制环境变量（这些是输入），又要能够监视对输出的写入。为了在测试中做到这一点，可以替换标准输出编写器和Getenv（）提供程序：</p><p> func  TestNewFromInputs ( t  * testing . T )  {	 // ... 	 actionLog  :=  bytes . NewBuffer ( nil )	 envMap  :=  map [ string ] string {		 &#34;INPUT_ROLE&#34; :  &#34;user&#34; ,		 &#34;INPUT_LEASE-DURATION&#34; :  &#34;1h&#34; ,	 }	 getenv  :=  func ( key  string )  string  {		 return  envMap [ key ]	 }	 action  :=  githubactions . New (		 githubactions . WithWriter ( actionLog ) ,		 githubactions . WithGetenv ( getenv ) ,	 )	 // ... 	 it . Equal ( &#34;...&#34; ,  actionLog . String ( ) ) }</p><p>func TestNewFromInputs（t*testing.t）{/…actionLog:=bytes.NewBuffer（nil）envMap:=map[string]string{&#34；INPUT#u ROLE&#34；：&#34；user&#34；&#34；INPUT#LEASE-DURATION&#34；：&#34；1h&#34；}getenv:=func（key string）string{return envMap[key]=hubActions:=。新的（githubactions.WithWriter（actionLog），githubactions。使用getenv（getenv），）/。。。信息技术相等（&#34；…&#34；，actionLog.String（））}</p><p>  To sanity check an implementation, it can be quite useful to run anaction  locally instead of doing a pre-release and waiting on a fullytriggered GitHub Actions workflow. To run an action locally, it’s enough to runthe Go script with the correct environment variables.</p><p>为了检查实现的合理性，可以在本地运行操作，而不是执行预发布并等待完全触发的GitHub操作工作流。要在本地运行操作，使用正确的环境变量运行Go脚本就足够了。</p><p> There are two types of environment variables needed. The first type are GITHUB_* environment variables that come with theworkflow. The other type are inputs that are providedin  inputs: to the action (i.e. the inputs from  action.yml), which gettransformed into  INPUT_* environment variables by GitHub.</p><p>需要两种类型的环境变量。第一类是工作流附带的GITHUB_*环境变量。另一种类型是输入中提供的输入：操作（即action.yml的输入），GitHub将其转换为输入*环境变量。</p><p>    Using prebuilt static binaries is not the only choice for writing anaction. We explicitly considered using a Docker container action or acomposite action but elected not to use either.</p><p>使用预构建的静态二进制文件并不是编写操作的唯一选择。我们明确考虑使用Docker容器操作或复合操作，但选择不使用这两种操作。</p><p>  The first obvious choice here would be to write a Dockerfile for the Gocode and use a Docker container action. For example, the GitHub Actions tutorial at GopherCon 2021 recommended this approach as do the publishing instructions for the  githubactions package. However, thisexperience is not as smooth as the JavaScript one.</p><p>这里第一个明显的选择是为Gocode编写Dockerfile并使用Docker容器操作。例如，GopHeCub 2021的GITHUB动作教程推荐了这种方法，就像GithuBACTS包的发布说明一样。然而，这种体验并不像JavaScript体验那样流畅。</p><p> With a Docker container action, the image reference can either be a Dockerfileor an image in a container registry. Referencing a Dockerfile directlyincurs a large cost: every  7 invocation of the action requiresthe image to be built. Pulling an image from a public container registryemulates the snappy “run it now” behavior of JavaScript actions.For images stored in a  private container registry, this creates a newchallenge. To use an action referencing a private image, users would need tofirst authenticate to a registry to pull an image that they didn’t even knowthey were using:</p><p>通过Docker容器操作，图像引用可以是DockerFile或容器注册表中的图像。引用Dockerfile会直接带来巨大的成本：每调用7次操作，就需要构建映像。从公共容器注册表中提取图像模拟JavaScript操作的快速“立即运行”行为。对于存储在私有容器注册表中的图像，这会产生一个新的挑战。要使用引用私有映像的操作，用户需要首先对注册表进行身份验证，以获取他们甚至不知道正在使用的映像：</p><p> steps :  -  name :  Login  to  ECR    uses :  docker/login-action@v1    with :     registry :  ${{  env.AWS_ACCOUNT_NUMBER  }}.dkr.ecr.${{  env.AWS_REGION  }}.amazonaws.com    username :  ${{  secrets.AWS_ACCESS_KEY_ID  }}    password :  ${{  secrets.AWS_SECRET_ACCESS_KEY  }}   -  name :  Invoke  Hypothetical    uses :  blend/hypothetical-action@main    with :     role :  user    lease-duration :  1h</p><p>步骤：-名称：登录到ECR使用：docker/登录-action@v1使用：注册表：${env.AWS_ACCOUNT_NUMBER}。dkr。ecr${{env.AWS_地区}。亚马逊。com用户名：${secrets.AWS_-ACCESS_-KEY_-ID}}密码：${{secrets.AWS_-SECRET_-ACCESS_-KEY}名称：调用假设用法：混合/假设-action@main使用：角色：用户租赁期限：1小时</p><p> For internal actions used within an engineering organization(e.g. within a GitHub Enterprise instance) it’s very likely that most imageswill be in a private container registry.</p><p>对于工程组织（例如GitHub企业实例）中使用的内部操作，大多数图像很可能位于私有容器注册表中。</p><p>  It is possible to avoid the overhead of Docker build and authentication byusing a composite action. Starting from Go source code  8, the onlyoption is to compile and run that code. This means a composite action needs toensure Go is installed on the actions runner. For example:</p><p>通过使用复合操作，可以避免Docker构建和身份验证的开销。从Go源代码8开始，唯一的选择是编译并运行该代码。这意味着复合操作需要确保Go安装在操作运行程序上。例如：</p><p> runs :     using :  composite    steps :    -  uses :  actions/setup-go@v2    with :     go-version :   &#39;1.17.6&#39;    -  run :  go  run  ./main.go</p><p>运行：使用：复合步骤：-使用：操作/设置-go@v2使用：go版本：&#39；1.17.6&#39;    -  快跑：快跑/主要的去</p><p> However, this has the same problem as the approach of building a Dockerfilebefore running it: the default usage (no caching) involves a significantcost waiting for build before the action actually runs. What’s more,running  actions/setup-go on the actions runner may overwrite an existingversion of Go installed by the workflow job actually invoking this action,causing invisible breakage in workflows using this action.</p><p>然而，这与在运行DockerFile之前构建DockerFile的方法存在相同的问题：默认使用（无缓存）会导致在操作实际运行之前等待构建的巨大成本。此外，在actions runner上运行actions/setup go可能会覆盖由实际调用此操作的工作流作业安装的现有版本的go，从而导致使用此操作的工作流中出现不可见的中断。</p><p>  Using a tiny JavaScript shim, actions written in Go can be on equalfooting with native JavaScript actions. As we discussed above, there are manybenefits that come from this first-class native support—chiefly speed ofinvocation and simplicity of setup. Best of all, this allows us to bring allthe benefits of Go when writing an action. For internalactions within an engineering organization, this allows us to reuse existingGo libraries within our actions. With GitHub Actions and Go, we  canhave our cake and eat it too.</p><p>使用一个小小的JavaScript垫片，用Go编写的动作可以与本机JavaScript动作保持一致。正如我们前面所讨论的，这种一流的本地支持带来了许多好处，主要是调用速度和设置的简单性。最重要的是，这让我们在编写动作时能够充分利用围棋的所有好处。对于工程组织中的内部操作，这允许我们在操作中重用现有的Go库。有了GitHub Actions和Go，我们就可以吃蛋糕了。</p><p>  For example, using  actions/checkout to checkout code and actions/cache to cache dependencies to speed up CI runs.  ↩︎</p><p>例如，使用actions/checkout签出代码，使用actions/cache-to-cache依赖项加快CI运行。↩︎</p><p>  This means we don’t need to include any Go source code (or  go.mod, etc.)in our “release” branch. By the same token, we wouldn’t want to check incompiled static binaries to our “development” branch.  ↩︎</p><p>这意味着我们不需要在“release”分支中包含任何Go源代码（或Go.mod等）。出于同样的原因，我们不想将不完整的静态二进制文件检查到“开发”分支。↩︎</p><p> It’s worth  mentioning: cgo is not Go. Generating a static binarywhen using cgo is possible but much more challenging. Cross-compiling astatic binary is even more challenging.  ↩︎</p><p>值得一提的是：cgo不是Go。使用cgo生成静态二进制文件是可能的，但更具挑战性。交叉编译无定向二进制文件更具挑战性。↩︎</p><p> Though it is possible to test code in  package main, it is not common.This is particularly challenging for code paths that end with  os.Exit().  ↩︎</p><p>虽然可以在包main中测试代码，但这并不常见。对于以os结尾的代码路径来说，这尤其具有挑战性。退出（）。↩︎</p><p> For action inputs in  kebab-case, the corresponding environmentvariable will have a hyphen, e.g.  INPUT_LEASE-DURATION. Using environmentvariable names with a hyphen requires a little bit of extra care in mostshells, hence the usage of  env INPUT_LEASE-DURATION=....  ↩︎</p><p>对于烤肉串案例中的操作输入，相应的环境变量将有一个连字符，例如INPUT_LEASE-DURATION。在大多数shell中，使用带有连字符的environmentvariable名称需要格外小心，因此使用env INPUT_LEASE-DURATION=。。。。↩︎</p><p> It’s certainly possible to  use  actions/cache toreuse a Docker build context across workflow runs, but it is not easy toget right. This puts an unnecessary burden on users of an action.  ↩︎</p><p>当然可以使用actions/cache跨工作流运行使用Docker构建上下文，但要正确设置并不容易。这给操作的用户带来了不必要的负担。↩︎</p><p> “Starting from Go source code” as opposed to the other approach, i.e. justdistributing prebuilt binaries.  ↩︎</p><p>“从Go源代码开始”，而不是另一种方法，即只分发预构建的二进制文件。↩︎</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>