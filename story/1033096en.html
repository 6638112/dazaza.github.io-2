<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>码头10分钟后开工</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">码头10分钟后开工</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 09:51:17</div><div class="page_narrow text-break page_content"><p>I&#39;ve been exposed to docker on and off and every time I see it, I seem to need a refresher. In this article we will go through everything you need to know about Docker in order to either jump into an existing project or get started with it.</p><p>我断断续续地接触过码头，每次我看到它，似乎都需要重温一下。在本文中，我们将介绍您需要了解的关于Docker的所有内容，以便您可以直接进入现有项目，也可以开始使用它。</p><p>  Docker is basically a system of running processes on the host machine in an isolated way, using several Linux kernel features. Thus, Docker is more lightweight than a full-blown virtual machine. The disadvantage of a Docker container vs. a virtual machine is that multiple containers share the same underlying OS kernel. While the concept of jailed processes is not new, Docker&#39;s popularity was essentially due to the tooling that it provided to which made it really straightforward to spin up and manage containers.</p><p>Docker基本上是一个在主机上以隔离方式运行进程的系统，使用了几个Linux内核功能。因此，Docker比成熟的虚拟机更轻量级。Docker容器与虚拟机相比的缺点是多个容器共享相同的底层操作系统内核。虽然监禁进程的概念并不新鲜，Docker的流行本质上是因为它提供的工具使得旋转和管理容器变得非常简单。</p><p> Docker is made up of various components. The main component is the the docker engine, which consists of a lightweight runtime that manages containers, images, builds, and more. It runs natively on Linux systems and is made up of:</p><p>Docker由各种组件组成。主要组件是docker引擎，它由管理容器、映像、构建等的轻量级运行时组成。它在Linux系统上本机运行，由以下部分组成：</p><p>  The Docker client is what you, as the end-user use to communicate with the Docker daemon, e.g.  docker run hello-world.</p><p>Docker客户端是您作为最终用户用来与Docker守护进程通信的工具，例如docker run hello-world。</p><p> The Docker daemon is what actually executes commands like building and running containers on the host machine. The Docker Client can run on the same machine as well, but it does not have to. It can also communicate with the Docker Daemon running on a different host.</p><p>Docker守护进程实际上执行的是在主机上构建和运行容器等命令。Docker客户端也可以在同一台计算机上运行，但它不是必须的。它还可以与运行在不同主机上的Docker守护进程通信。</p><p> We will look at other Docker components like the Docker hub, etc. later in this article.</p><p>我们将在本文后面介绍其他Docker组件，如Docker集线器等。</p><p>  A Docker image can be though of as a recipe for setting up a machine with all required software and dependencies installed. Apart from installing software, images can also define what processes to run when launched. Docker images are created via instructions written in a  Dockerfile. Images are built on the concept of layers. There is always a base layer, potentially followed by additional layers that represent file changes. Each layer is stacked on top of the others, consisting of the differences between it and the previous layer. This is achieved via a  Union file system.</p><p>可以将Docker映像视为设置安装了所有必需软件和依赖项的计算机的秘诀。除了安装软件，映像还可以定义启动时要运行的进程。Docker镜像是通过Dockerfile中写入的指令创建的。图像是建立在层的概念之上的。始终有一个基本层，后面可能跟有表示文件更改的附加层。每一层都堆叠在其他层之上，由它与上一层之间的差异组成。这是通过联合文件系统实现的。</p><p> A Docker container is the running instance of an image. This includes the operating system, application code, runtime, system tools, system libraries, etc. A Docker image can be thought of as an executable and a container can be thought of as the running application. Note that in this analogy each running application is its own instance and independent of the others.</p><p>Docker容器是镜像的运行实例。这包括操作系统、应用程序代码、运行时、系统工具、系统库等。Docker镜像可以看作是可执行文件，容器可以看作正在运行的应用程序。请注意，在此类比中，每个运行的应用程序都是其自己的实例，并且独立于其他应用程序。</p><p> The general idea is that once you have successfully created a container, you can then run it in any environment without having to make changes.</p><p>一般的想法是，一旦您成功创建了容器，您就可以在任何环境中运行它，而不必进行更改。</p><p> A Docker volume is the &#34;data&#34; part of a container, initialized when a container is created. Volumes allow you to persist and share a container&#39;s data. Docker volumes are separate from the default Union File System and exist as normal directories and files on the host filesystem.</p><p>Docker卷是容器的数据部分，在创建容器时初始化。卷允许您持久化和共享容器的数据。Docker卷独立于默认的联合文件系统，并作为普通目录和文件存在于主机文件系统上。</p><p>  As part of the docker installation process, a hello world image was downloaded and executed via:  docker run hello-world</p><p>作为docker安装过程的一部分，通过docker run hello-world下载并执行hello world映像。</p><p>  $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 94e814e2efa8 2 weeks ago 88.9MBhello-world latest fce289e99eb9 2 months ago 1.84kB</p><p>$docker imagesRePOSITORY标记映像ID创建SIZEubuntu最新94e814e2efa8 2周前88.9MB hello-world最新fce289e99eb9 2个月前1.84kB。</p><p> Run a command interactively from an image in a new container:  docker run -it ubuntu bash</p><p>从新容器中的映像交互运行命令：docker run-it ubuntu bash。</p><p> List all running containers:  docker ps. To list all previously run containers use  docker ps -a:</p><p>列出所有正在运行的容器：Docker PS。要列出所有以前运行的容器，请使用docker ps-a：</p><p> $ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd2d651741317 ubuntu &#34;bash&#34; 45 minutes ago Exited (0) 43 minutes ago suspicious_kalam36813bdb6434 ubuntu &#34;bash&#34; About an hour ago Exited (0) About an hour ago inspiring_banach46f352a0cde9 hello-world &#34;/hello&#34; 2 hours ago Exited (0) 2 hours ago thirsty_clarke</p><p>$docker ps-aCONTAINER ID image命令CREATED STATUS PORTS NAMESd2d651741317 ubuntu&#34；bash&#34；45分钟前退出(0)43分钟前可疑_kalam36813bdb6434 ubuntu&#34；bash&#34；大约一小时前退出(0)大约一小时前正在激励_banach46f352a0cde9 hello-world&#34；/hello&#34；2小时前退出(0)2小时前口渴_clke。</p><p> Note that in the output above, for each docker  run command, a new container was created. As mentioned previously, each container has it&#39;s own data volume and changes to one do not affect the others. To run an existing container:  docker run [container-name. This will start the container and  docker attach [container-name] will jump into it.</p><p>请注意，在上面的输出中，对于每个docker run命令，都创建了一个新容器。如前所述，每个容器都有自己的数据卷，对其中一个的更改不会影响其他容器。要运行现有容器：Docker run[CONTAINER-NAME.。这将启动容器，停靠器ATTACH[CONTAINER-NAME]将跳到其中。</p><p> At this point, you should have enough to get started with an existing docker project. Read on if you&#39;re looking to develop with docker.</p><p>此时，您应该有足够的资源开始使用现有的docker项目。如果您希望与Ddocker一起开发，请继续阅读。</p><p>  As noted previously, Docker images are specified via a  Dockerfile. Here&#39;s an extremely basic example that uses a ubuntu base image and copies an executable called  sysinfo from the current directory into the container and executes it:</p><p>如前所述，Docker镜像是通过Dockerfile指定的。下面是一个非常基本的示例，它使用ubuntu基本映像，并将名为sysinfo的可执行文件从当前目录复制到容器中并执行它：</p><p>  Let&#39;s see how we can get this image up and running via the  docker build command (note that gcc is required to compile the binary):</p><p>让我们看看如何通过docker build命令启动并运行此映像(请注意，需要GCC编译二进制文件)：</p><p> $ cd ~$ mkdir -p docker/sysinfo$ cd docker/sysinfo$ vim sysinfo.cpp#include &lt;iostream&gt;#include &lt;sys/utsname.h&gt;using namespace std;int main() { struct utsname sysinfo; uname(&amp;sysinfo); cout &lt;&lt; &#34;System Name: &#34; &lt;&lt; sysinfo.sysname &lt;&lt; endl; cout &lt;&lt; &#34;Host Name: &#34; &lt;&lt; sysinfo.nodename &lt;&lt; endl; cout &lt;&lt; &#34;Release(Kernel) Version: &#34; &lt;&lt; sysinfo.release &lt;&lt; endl; cout &lt;&lt; &#34;Kernel Build Timestamp: &#34; &lt;&lt; sysinfo.version &lt;&lt; endl; cout &lt;&lt; &#34;Machine Arch: &#34; &lt;&lt; sysinfo.machine &lt;&lt; endl; cout &lt;&lt; &#34;Domain Name: &#34; &lt;&lt; sysinfo.domainname &lt;&lt; endl; return 0;}$ g++ sysinfo.cpp -o sysinfo$ ./sysinfoSystem Name: LinuxHost Name: coolbeansRelease(Kernel) Version: 4.18.0-16-genericKernel Build Timestamp: #17-Ubuntu SMP Fri Feb 8 00:06:57 UTC 2019Machine Arch: x86_64Domain Name: (none)$ vim DockerfileFROM ubuntu:18.04COPY sysinfo /CMD [&#34;/sysinfo&#34;]$ docker build . -t sysinfo$ docker run sysinfoSystem Name: LinuxHost Name: d8e53b009d72Release(Kernel) Version: 4.18.0-16-genericKernel Build Timestamp: #17-Ubuntu SMP Fri Feb 8 00:06:57 UTC 2019Machine Arch: x86_64Domain Name: (none)</p><p>$cd~$mkdir-p docker/sysinfo$cd docker/sysinfo$vim sysinfo.cpp#include&lt；iostream&gt；#include&lt；sys/utsname.h&gt；Using&lt；int main(){struct utsname sysinfo；uname(&amp；sysinfo)；cout&lt；&lt；&#34；系统名称：&#34；&lt；&lt；sysinfo.sysname&lt；&lt；Endl；cout&lt；&lt；&34；主机名：&34；&lt；&lt；nodename&lt；发布(内核)版本：&#34；&lt；&lt；sysinfo.release&lt；&lt；Endl；cout&lt；&lt；&34；内核构建时间戳：&#34；&lt；版本&lt；&lt；sysinfo.version&lt；&lt；&#34；Machine Arch：&#34；&lt；&lt；sysinfo.Machine&lt；&lt；Endl；cout&lt；&lt；&#34；Machine Arch：&#34；&lt；&lt；sysinfo.Machine&lt；&lt；Endl；cout&lt；&lt；&#34；域名：&#34；&lt；&lt；sysinfo.domainname&lt；&lt；Endl；return 0；}$g++sysinfo.cpp-o sysinfo$。/sysinfoSystem名称：Linux主机名：CoolbeansRelease(内核)版本：4.18.0-16-GenericKernel Build时间戳：#17-Ubuntu SMP Fri Feb 8 00：06：57 UTC 2019Machine Arch：x86_64域名：(无)$vim DockerfileROM Fubuntu：18.04COPY sysinfo/cmd[&#34；/sysinfo&#34；$docker build。-t sysinfo$docker run sysinfoSystem名称：Linux主机名称：d8e53b009d72Release(内核)版本：4.18.0-16-GenericKernel Build Timestamp：#17-Ubuntu SMP Fri Feb 8 00：06：57 UTC 2019Machine Arch：x86_64域名：(无)。</p><p> Note in the difference in hostname between local system (coolbeans) and the running container (d8e53b009d72) in the above output.</p><p>请注意以上输出中本地系统(CoolBeans)和运行容器(D8e53b009d72)之间的主机名差异。</p><p> If you make a mistake, you can remove an image via  docker rmi [image-name] --force. Cleaning up unused containers and volumes related to the image can be accomplished via  docker system prune --volumes.</p><p>如果您犯了错误，可以通过docker RMI[image-name]--force删除图像。清理与映像相关的未使用的容器和卷可以通过停靠系统修剪--卷来完成。</p><p> In the above example, we created a custom image using the standard Ubuntu image as our base image, before we go further with creating custom images it would be good to note that the docker  hub provides lots of free pre-configured images for various software. This is the second Docker component and is also sometimes called the Docker registry (one can also have private registries).</p><p>在上面的示例中，我们使用标准的Ubuntu映像作为基础映像创建了一个自定义映像，在我们进一步创建自定义映像之前，最好注意到docker集线器为各种软件提供了大量免费的预配置映像。这是第二个Docker组件，有时也称为Docker注册表(也可以有私有注册表)。</p><p>  In most cases, we would like to run a service via Docker. Let is look at how we can accomplish this by using a very simple web server as an example. Create the image as follows (note that the example below uses Go to create the binary):</p><p>在大多数情况下，我们希望通过Docker运行服务。让我们以一个非常简单Web服务器为例，看看如何实现这一点。按如下方式创建映像(请注意，下面的示例使用GO创建二进制文件)：</p><p> $ cd ~$ mkdir -p docker/webapp$ cd docker/webapp$ vim webapp.gopackage mainimport (	&#34;io&#34;	&#34;net/http&#34;)func hello(w http.ResponseWriter, r *http.Request) {	io.WriteString(w, &#34;Hello from webapp!&#34;)}func main() {	http.HandleFunc(&#34;/&#34;, hello)	http.ListenAndServe(&#34;:8000&#34;, nil)}$ go build webapp.go$ vim DockerfileFROM ubuntu:18.04COPY webapp /CMD [&#34;/webapp&#34;]$ docker build . -t webapp$ docker run -d webappcfab907c828a40ce4cc53b88b26badabf8fa6672fd538d0c072fd0947f36d650</p><p>$cd~$mkdir-p docker/webapp$cd docker/webapp$vim webapp.gopackage mainimport(&#34；io&#34；&#34；net/http&34；)func hello(w http.ResponseWriter，r*http.Request){io.WriteString(w，&#34；Hello from webapp！&#34；)}func main(){http.HandleFunc(&#34；/&#34；，hello)http.ListenAndServe(&#34；：8000&#34；)。，nil)}$go build webapp.go$vim DockerfileFROM ubuntu：18.04COPY webapp/cmd[&#34；/webapp&#34；]$docker build。-t Webapp$docker run-d webappcfab907c828a40ce4cc53b88b26badabf8fa6672fd538d0c072fd0947f36d650。</p><p> In the above example we built a webapp image and started the docker container with the  -d flag. This started the container in detached mode and printed the container id so that we could interact with it. We can confirm it is running via  docker ps:</p><p>在上面的示例中，我们构建了一个webapp映像，并使用-d标志启动了docker容器。这将以分离模式启动容器，并打印容器ID，以便我们可以与其交互。我们可以通过坞站PS确认它正在运行：</p><p> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScfab907c828a webapp &#34;/webapp&#34; 4 minutes ago Up 4 minutes zealous_herschel</p><p>容器ID映像命令已创建状态端口NAMEScFab907c828a Webapp&#34；/webapp&#34；4分钟前开始工作4分钟HERELAUS_HERSCEL。</p><p> At this point we have our web application running in a docker container but we have no way to communicate with it. Run  docker inspect cfab907c828a to output the container configuration in json format. We are interested in the  NetworkSettings.Networks.bridge.IPAddress property. Let&#39;s try connecting to the provided ip address, http://172.17.0.2:8000 (in my case) and we can see our web application in action!</p><p>此时，我们的Web应用程序在停靠容器中运行，但我们无法与其通信。运行docker check cFab907c828a以json格式输出容器配置。我们对NetworkSettings.Networks.bridge ge.IPAddress属性感兴趣。让我们尝试连接到提供的IP地址http://172.17.0.2:8000(在我的例子中)，我们可以看到我们的Web应用程序正在运行！</p><p> It is also possible to bind ports on from the docker container to the host machine so that we can access services as if they were running locally,  docker run -d -p3000:8000 webapp. Thus our web application is now available on http://localhost:3000!</p><p>还可以将端口从docker容器绑定到主机，这样我们就可以访问服务，就像它们在本地运行一样，docker run-d-p3000：8000 webapp。因此，我们的Web应用程序现在可以在http://localhost:3000！上使用。</p><p>  By default Docker containers come with their own storage which lives as long as the container is running. If we would like to persist data across containers, we can either bind a local file/directory to our container or create and mount a named Docker volume. The added benefit of using a Docker volume is that it does not necessarily have to be a resource on the host file system, it can also be an external cloud storage service depending upon the driver.</p><p>默认情况下，Docker容器具有自己的存储空间，只要容器在运行，该存储空间就会一直存在。如果我们想要跨容器持久化数据，可以将本地文件/目录绑定到容器，也可以创建并挂载命名的Docker卷。使用Docker卷的额外好处是，它不必是主机文件系统上的资源，也可以是外部云存储服务，具体取决于驱动程序。</p><p> A very practical example of using a postgres docker image with persistent data storage can be found  here.</p><p>这里有一个使用Postgres docker图像和持久数据存储的非常实用的示例。</p><p>  We looked at Docker basic concepts, created a few containers, ran some services and even persisted data across machine restarts! This was longer than 10 minutes but it should be enough to get going with Docker.</p><p>我们了解了Docker的基本概念，创建了几个容器，运行了一些服务，甚至在机器重新启动时保存了数据！这超过了10分钟，但应该足够和多克一起走了。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://smalldata.tech/blog/2019/06/08/docker-in-10-minutes">https://smalldata.tech/blog/2019/06/08/docker-in-10-minutes</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/码头/">#码头</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032947.html"><img src="http://img2.diglog.com/img/2020/11/thumb_332bb03fa233c678c2dfb5877fdcf1f3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032947.html">Kraken-P2P Docker注册表</a></div><span class="my_story_list_date">2020-11-3 17:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032645.html"><img src="http://img2.diglog.com/img/2020/11/thumb_e2d2cb3132e376fe7f69d08d8c3d8a92.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032645.html">在没有码头工人的情况下建造集装箱</a></div><span class="my_story_list_date">2020-11-2 1:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031859.html"><img src="http://img2.diglog.com/img/2020/10/thumb_916a4bb375c3015e55b3fdd880d8aa8d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031859.html">Docker Hub映像保留策略延迟</a></div><span class="my_story_list_date">2020-10-29 10:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031217.html"><img src="http://img2.diglog.com/img/2020/10/thumb_683f76973c3deabfab3d9be9c2e0a460.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031217.html">如何使用Docker图像、容器和Dockerfile</a></div><span class="my_story_list_date">2020-10-26 21:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>