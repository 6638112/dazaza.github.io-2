<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>结构亚型：对于Python中缺少的Go接口 Structural Subtyping: For those missing Go interfaces in Python</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Structural Subtyping: For those missing Go interfaces in Python<br/>结构亚型：对于Python中缺少的Go接口 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 00:03:23</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/de5b16ff621cd845890982b126f9b15f.png"><img src="http://img2.diglog.com/img/2021/3/de5b16ff621cd845890982b126f9b15f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Welcome to the second edition of “Station Wagon Full of Tapes”. This is a deep dive into how we can achieve structural subtyping in Python using Protocol definitions from.  In this post there will be excerpts from code attached as images, so make sure the images are set to be displayed.</p><p>欢迎来到第二版“车站旅行车装满了磁带”。这是一种深入潜入如何使用来自的协议定义在Python中实现结构亚型的深度。在此帖子中，将从附加的代码摘录为图像，因此确保将图像设置为显示。</p><p> How do we infer if a certain type is compatible with a different type while building a new feature or an endpoint? For me it used to be centered around building classes. Class type attributes and inheritance between different types by creating a hierarchical view on the feature holistically.</p><p> 如果某种类型在构建新功能或端点时，我们如何推广某种类型与不同类型兼容？对我来说，它曾经以建筑课为中心。通过全面地在特征上创建分层视图，在不同类型之间的类类型属性和继承。</p><p> This habit was mostly formed around the idea of object-oriented programming. Starting with C++, and later on with professional experience around C#, representing type relationships with objects and their attributes became a second nature. In general, as it has been the core of the software development architectures for this long. I still find that object-oriented structures are very easy to comprehend and scalable.</p><p> 这种习惯主要是在面向对象编程的思想周围形成的。从C ++开始，后来围绕C＃的专业经验，代表与对象的类型关系以及它们的属性成为第二种性质。一般来说，它一直是软件开发架构的核心。我仍然发现面向对象的结构非常容易理解和可扩展。</p><p> But, I have a new favorite way to represent type relationships and the love was injected when I started working with Go.</p><p> 但是，我有一个新的最喜欢的方式来表示类型的关系，当我开始使用时注入了爱情。</p><p> For those who are not familiar with Go, and its relationship with object-oriented programming, the answer is,  yes and no. Here’s the excerpt from the documentation;</p><p> 对于那些不熟悉Go的人和其与面向对象编程的关系，答案是，是和否。这是文档中的摘录;</p><p> Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes). Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.</p><p> 是和否。虽然Go具有类型和方法，允许面向对象的编程风格，但没有类型的层次结构。 “界面”的概念提供了一种不同的方法，我们相信易于使用，并且在某种程度上更加一般。还有方法可以在其他类型中嵌入类型，以提供类似于但不相同的子类化。此外，Go的方法比C ++或Java更常见：可以为任何类型的数据定义，甚至内置类型，例如普通的类型，“未填充”整数。它们不限于结构（课程）。此外，缺少类型的层次结构使“对象”在Go的情况下比诸如C ++或Java等语言更轻微。</p><p>  My relationship with Go started at Docker. Containers are built with Go, and so are container orchestration libraries such as Kubernetes. It has since become the standard language for many new additions to the cloud native space.</p><p>  我与去往Docker的关系。包含Go构建的容器，也是Kubernetes等容器编排库。它已经成为云本机空间的许多新增添加的标准语言。 </p><p> I have really struggled when I first started working with Go. Years  (literally) of approaching each feature by representing it with an object-oriented model, it wasn’t an easy transition to move away from inheritance to represent hierarchies.</p><p>当我第一次开始使用时，我真的很挣扎。多年（字面意思）通过用面向对象的模型代表它来接近每个特征，它不是一个容易的转换来远离继承来表示层次结构。</p><p> Once it clicks, it sticks. It clicked for me when I was implementing “.zip” file support for Docker CLI. ( #1895) I basically had to represent a new structure that is supposed to be extended off of the base “Reader” library, and have a limitation around how many bytes should be read per run. This change also included a fork of the base definition for a “LimitedReader” type as the base did not error out properly if it exceeded the size or reached EOF.</p><p> 一旦点击，它就会粘。当我为Docker CLI实现“.zip”文件支持时，它点击了我。 （＃1895）我基本上不得不代表一个应该延长基本“读者”库的新结构，并限制每个运行多少字节。此更改还包括一个“有限公司”类型的基本定义的叉子，因为如果它超出大小或达到eof，则基本没有正确出错。</p><p>   That’s it. “Reader” is an interface that has a function that will take in a byte array and read. So how can one make sure their type can be passed in to the functions that require a “Reader”?</p><p>   而已。 “读者”是一个函数的接口，该函数将采用字节数组并读取。那么如何确保他们的类型可以传递给需要“读者”的功能？</p><p>  Very simple and straight-forward. No need to dance around variables, imports, inheritance. Let Go handle the type relationships.</p><p>  非常简单和直接。无需在变量，进口，继承周围跳舞。让我们处理类型的关系。</p><p> Once comfortable, the approach to represent type relationships with interfaces feels like a super-power. This was an addicting way to approach new features.</p><p> 一旦舒适，可以表示与接口的类型关系的方法感觉就像超功率。这是一种接近新功能的瘾方式。</p><p> Representing a relationship between two different types by not focusing on the type attributes and strict inheritance hierarchies, but solely focusing on the features of those types (its functions) is what “structural subtyping” is.</p><p> 代表两种不同类型之间的关系，不关注类型属性和严格的继承层次结构，但仅关注这些类型（其功能）的功能是“结构亚型”是什么。</p><p> We now know how powerful this way of structuring can be for architecturing new APIs. Although there are libraries at Dropbox written in Go, I now primarily work in Python. But, I wasn’t ready to say goodbye to “interfaces”.</p><p> 我们现在知道这种结构化方式有多强大，可以用于架构新的API。虽然Dropbox中有图书馆，但我现在主要在Python工作。但是，我还没有准备好向“界面”说再见。 </p><p>    Mypy is a static type checker, and is a must especially when the code base is massive. It doesn’t bring a massive overhead, as it is not a compile time checker, but more of a linter style type checker.</p><p>mypy是一个静态类型检查器，尤其是常规群体时的唯一。它不会带来大量开销，因为它不是编译时间检查器，而是更多的Linter样式Checker。</p><p> By annotating the code with type definitions, it is really easy to achieve a productive Python development experience, making it feel more secure.</p><p> 通过用类型定义注释代码，它真的很容易实现高效的Python开发经验，使其感觉更加安全。</p><p> Mypy has a typing definition called  Protocol. The idea of assuming certain functions exist in certain types and writing modules according to that is not new for Python developers and it is referred to as duck-typing. What protocols introduce is the type checking security, and some hand-holding for developers when they are using types that are protocol based.</p><p> Mypy有一个称为协议的键入定义。假设某些功能的想法存在于某些类型和写入模块中，根据该类型并不是Python开发人员的新功能，它被称为鸭键。什么协议介绍是检查安全性的类型，以及在使用基于协议的类型的类型时，开发人员的某些手持持有。</p><p> Here’s the same example I’ve shared above but in Python with Mypy;</p><p> 这是我上面共享的相同的例子，但用yypy在python中;</p><p>  Now any function that needs a type argument that can “read” they can use this definition, and any object that has defined a “read” function regardless of its class type definition or inheritance pattern can be used.</p><p>  现在，需要使用此定义可以使用此定义的类型参数的任何函数，以及任何已定义“读取”函数的对象，无论其类类型定义或继承模式如何。</p><p> As Python continues to implement more of these type hints into the language itself with  PEP 484,  PEP 545 and so forth, we are getting closer to a future where Python keeps its flexibility and nimble nature with proper type support. I am very excited for that future.</p><p> 随着Python继续使用PEP 484，PEP 545等待更多这些类型的提示，我们正在接近Python保持其灵活性和灵活性，并具有适当类型的支持。我对这个未来感到非常兴奋。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://p99th.substack.com/p/structural-subtyping">https://p99th.substack.com/p/structural-subtyping</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/亚型/">#亚型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/subtyping/">#subtyping</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>