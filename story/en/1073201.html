<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>简单的XMPP命令行客户端Simple XMPP command line client</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Simple XMPP command line client<br/>简单的XMPP命令行客户端</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 00:58:00</div><div class="page_narrow text-break page_content"><p>/*-- Tiny XMPP Client --txmppc reads commands from stdin and prints to stdout.It is a KISS client for command line or automation.Out of scope:roster -&gt; there is a presence list -&gt; no name (alias), group or subscription stateMUC management -&gt; basic works: join (with password), write and leave -&gt; no administration, invitation, register, disco, ...no disco, bookmark, pubsub, vcard, files, voice, ...OMEMO - encryption is good, but too complicated for a tiny client: There is one lib ( https://github.com/gkdr/libomemo ) and profanity has a good implementation, but the code of omemo is 5x larger than txmppc. -&gt; profanity (tui - OMEMO, OTR and PGP and plugins) -&gt; https://profanity-im.github.io/ (c uses libstrophe) -&gt; poezio (tui - OMEMO and OTR) -&gt; https://poez.io/ (python uses slixmpp lib) -&gt; mcabber (tui - No OMEMO, but OTR and PGP, external scripts + fifo) -&gt; https://mcabber.com/ (c uses lib loudmouth -&gt; https://github.com/mcabber/loudmouth ) -&gt; xmppc (cli, which can send messages (chat + PGP), monitor and query some data) -&gt; https://codeberg.org/Anoxinon_e.V./xmppc (c uses libstrophe) -&gt; smplxmpp -&gt; https://codeberg.org/tropf/smplxmpp (c++ uses gloox lib) -&gt; freetalk -&gt; https://www.gnu.org/software/freetalk/ (c uses loudmouth) -&gt; jj (creates filesystem (fifo) structure) -&gt; https://23.fi/jj/ (c uses loudmouth)Build:Depends only on libstophe&gt; gcc txmppc.c -lstrophe -o txmppcStatic compile (musl)&gt; gcc txmppc.c -lstrophe -lc -lssl -lcrypto -lexpat -static -o txmppc_static (depending on libstrophe, it can be xml2 instead of expat and/or gnutls instead of openssl)optional: &gt; strip txmppc_staticUse:[echo &#34;command jid message&#34; |] txmppc[_static] &lt;jid&gt; &lt;pass&gt; [&lt;server&gt;[(:|=)&lt;port&gt;]]- jid and password are mandatory- optional is a third parameter with server (and :port or =port -&gt; ignores if tls startup (self-signed cert) fails)txmppc logs incomming messages to stdout and reads commands from stdin- just start as a slim client: &gt; txmppc- Sending single message: &gt; echo &#34;[mM] jid message&#34; | txmppc -&gt; txmppc executes the command and exits (on close of stdin)- Using fifo for commands: &gt; tail -f fifo | txmppc -&gt; executes the commands from fifo and prints to stdout &gt; echo &#34;q&#34; &gt;&gt; fifo # ! tail will still wait - so it doesn&#39;t exit -&gt; send another line- tmux horizontal split + rlwrap client example: (mkfifo fifo; echo &#34;contact@example.com&#34; &gt;&gt; jid_file) 90% pane&gt; while read line; do printf &#39;%s: &gt; %s\n&#39; &#34;$(date &#34;+%Y-%m-%d %H:%M&#34;)&#34; &#34;${line}&#34; &gt;&amp;2; printf &#39;%s\n&#39; &#34;${line}&#34;; test &#34;q&#34; = &#34;${line}&#34; &amp;&amp; break; done &lt; fifo | txmppc JID PASS | while read line; do printf &#39;%s: %s\n&#39; &#34;$(date &#34;+%Y-%m-%d %H:%M&#34;)&#34; &#34;${line}&#34;; done 10% pane&gt; rlwrap -s -10 -H /dev/null -b &#34; &#34; -f jid_file awk &#39;{print} /^q$/ {exit}&#39; &gt;&gt; fifo -&gt; readline editing with 10 lines history (not saved) and jid completion from fid_file, output will have a date prepended -&gt; Hint: In that case the fifo can&#39;t be used for other processes, because sending an EOF will end the client.Commands:j[ muc [password]] -&gt; join multi user conference (without muc &#34;join&#34; presence status changes - default on)J muc [password] -&gt; join multi user conference - no historyl[ muc] -&gt; leave multi user conference (without muc &#34;leave&#34; presence status changes)[m ]jid[ message] -&gt; send (chat) message to jid (without message enter multi line mode)h jid message -&gt; send headline message to jidn jid message -&gt; send normal message to jidM muc_jid message -&gt; send (groupchat) message to multi user conference (if not in the muc, it will be joined and left).[ message] -&gt; send (chat|headline|normal|groupchat) message to last jid (without message enter multi line mode)p[ [priority] presence [status]] -&gt; priority: -128 / 127, presence: on[line]|of[fline]|aw[ay]|ch[at]|dn[d]|xa -&gt; without arg: show presence list; without priority: change presence onlyP[ jid [priority] presence [status]] -&gt; send presence to jid, extra presence: subscribe|subscribed|unsubscribe|unsubscribed -&gt; without arg show presence list including unavailable/offlineq -&gt; end/exitr stanza -&gt; send raw stanza (invalid data may result in immediate stream termination by the XMPP server)R[ key] -&gt; show raw (message, iq.result) stanza, if it contains key - disabled without key -&gt; &#34;&lt;&#34; (will match every stanza), &#34;iq&#34;, &#34;message&#34;, &#34;carbons&#34;, &#34;openpgp&#34;, &#34;juliet@example.org&#34;, ... (to see every stanza compile with -DDEBUG, which will enable libstrophe XMPP_LEVEL_DEBUG)Output:i -&gt; infoI -&gt; Info offline, lost connectionp -&gt; presence (join/leave status changes with j/l command)P -&gt; presence listm -&gt; message chat (&#34;m from: message&#34;, if carbon from self &#34;m -&gt; to: message&#34;)n -&gt; message normalh -&gt; message headlineM -&gt; message mucH -&gt; message muc historyr -&gt; raw message stanzae -&gt; errorW -&gt; Warn - command errorE -&gt; (stderr) startup error -&gt; will exitEnd-to-end encryption:- It is possible to send PGP encrypted messages (sending a raw stanza): &gt; BASE64_OPENPGP_MESSAGE=$(echo &#34;message&#34; | gpg | base64)&#34; &gt; echo &#34;r &lt;message to=&#39;juliet@example.org&#39;&gt;&lt;openpgp xmlns=&#39;urn:xmpp:openpgp:0&#39;&gt;${BASE64_OPENPGP_MESSAGE}&lt;/openpgp&gt;&lt;/message&gt;&#34; | txmppc (stanza has to be in one line, might be supported by other clients: https://xmpp.org/extensions/xep-0373.html) -&gt; Be aware that most clients have implemented the obsolete: https://xmpp.org/extensions/xep-0027.html -&gt; For receiving raw message stanza filtering (&#34;R opengpg&#34;) is an option.- A non XMPP conformant way, if both clients use txmppc can be scripted with any encryption. Example with age (don&#39;t use password protected key): sender: &gt; ENCRYPTED_MESSAGE=&#34;$(printf &#39;message&#39; | age -r age1urredcd3g8dfachch0d6gzt5katx3tsfesz35zc6jn3fl23jrfmq027uu9 | base64 -w0)&#34; &gt; printf &#39;m juliet@example.org MYCRYPT:%s&#39; &#34;${ENCRYPTED_MESSAGE}&#34; | txmppc receiver: &gt; txmppc | while read line; do ENCRYPTED_MESSAGE=&#34;${line#*MYCRYPT:}&#34; if [ &#34;${line}&#34; = &#34;${ENCRYPTED_MESSAGE}&#34; ]; then printf &#39;%s\n&#39; &#34;${line}&#34; else MESSAGE=&#34;$(printf &#39;%s&#39; &#34;${ENCRYPTED_MESSAGE}&#34; | base64 -d | age -d -i juliet.key)&#34; printf &#39;%s%s\n&#39; &#34;${line%MYCRYPT:*}&#34; &#34;${MESSAGE}&#34; fi doneLicense:https://holmeinbuch.de/repo/txmppc/ - matthias@Copyright (c) ISC LicensePermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.THE SOFTWARE IS PROVIDED &#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.*/#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;sys/select.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;// https://www.rfc-editor.org/rfc/rfc6120 - core// https://www.rfc-editor.org/rfc/rfc6121 - IM + presence#include &lt;strophe.h&gt;static unsigned short ignore_cert_fail = 0;static short reconnect = 1;// https://www.rfc-editor.org/rfc/rfc6120 -&gt; 4.6.4 Use of Checking Methods: RECOMMENDED not more than once every 5 minutes#define PING_INTERVAL 60static char ping_id[32];#define BUFIN_MAX 4096// https://www.rfc-editor.org/rfc/rfc6121 -&gt; don&#39;t mess with priority, negative might get no messagesstatic short conn_priority = 0;static unsigned short show_presence_status_change = 1;#define PRESENCE_MAX 5#define PRESENCE_JID_MAX 9static char presence_type[10][13] = {&#34;offline&#34;, &#34;online&#34;, &#34;away&#34;, &#34;chat&#34;, &#34;dnd&#34;, &#34;xa&#34;, &#34;subscribe&#34;, &#34;subscribed&#34;, &#34;unsubscribe&#34;, &#34;unsubscribed&#34;};#define PRESENCE_OFFLINE 0#define PRESENCE_ONLINE 1#define PRESENCE_ONLINE_MUC -1#define PRESENCE_ONLINE_MUC_NO_HISTORY -101#define PRESENCE_OFFLINE_MUC -100// https://www.rfc-editor.org/rfc/rfc7622 - address (jid)#define JID_MAX 3071 + 1static char last_sent_type_jid[1 + JID_MAX];struct list_node { char jid[JID_MAX]; short presence; short priority; struct list_node *next;};static struct list_node *jid_list = NULL;// https://xmpp.org/extensions/xep-0172.html - nick -&gt; nickname length not defined// https://xmpp.org/extensions/xep-0045.html - muc -&gt; nickname is resource part of jid#define NICK_MAX 1023 + 1static char nick[NICK_MAX];static short multi_line = 0;#define SHOW_RAW_STANZA_MAX 32static char show_raw_stanza[SHOW_RAW_STANZA_MAX];unsigned short get_start_pos(char *buf, unsigned short start_pos) { unsigned short buf_len = (unsigned short)strlen(&amp;buf[start_pos]) + start_pos; for (unsigned short i = start_pos; i &lt; buf_len; i++) { if (!isspace(buf[i])) { return i; } } return buf_len;}void update_jid_list(const char *jid, short presence, short priority) { struct list_node *list_before = NULL; struct list_node *list_current = jid_list; struct list_node *list_new = NULL; size_t jid_len = strlen(jid); while (list_current) { int jid_match = strncmp(jid, list_current-&gt;jid, jid_len); if (jid_match == 0) { if (presence == PRESENCE_OFFLINE_MUC) { // remove jid, who leave the muc from list // if self leaves muc, called with bare jid -&gt; remove every muc entry while (list_current &amp;&amp; strncmp(jid, list_current-&gt;jid, jid_len) == 0) { if (list_before) { list_before-&gt;next = list_current-&gt;next; free(list_current); list_current = list_before-&gt;next; } else { jid_list = list_current-&gt;next; free(list_current); list_current = jid_list-&gt;next; } } return; } // update jid state for self and subscription (offline too) list_current-&gt;presence = presence; list_current-&gt;priority = priority; return; } if (jid_match &lt; 0) { // insert new jid here break; } list_before = list_current; list_current = list_current-&gt;next; } list_new = (struct list_node*) malloc(sizeof(struct list_node)); strncpy(list_new-&gt;jid, jid, JID_MAX - 1); list_new-&gt;presence = presence; list_new-&gt;priority = priority; if (list_before) { list_before-&gt;next = list_new; } else { jid_list = list_new; } list_new-&gt;next = list_current;}void send_presence(xmpp_conn_t *conn, short presence_index, const char *status_text, const char *jid, const char *priority_text) { xmpp_ctx_t *ctx = xmpp_conn_get_context(conn); xmpp_stanza_t *presence_stanza = xmpp_presence_new(ctx); if (jid) { xmpp_stanza_set_to(presence_stanza, jid); } if (presence_index == PRESENCE_OFFLINE) { xmpp_stanza_set_type(presence_stanza, &#34;unavailable&#34;); } else if (PRESENCE_MAX &lt; presence_index) { xmpp_stanza_set_type(presence_stanza, presence_type[presence_index]); // inverse presence for muc } else if (presence_index &lt; 0) { // MUC special xmpp_stanza_t *extension_stanza; unsigned short jid_len = (unsigned short)strlen(jid); unsigned short i = 0; for (;;) { // muc_jid is only muc, no nick if (i == jid_len) { char muc_jid_nick[JID_MAX]; if (JID_MAX - 1 - NICK_MAX &lt; strlen(jid)) { fprintf(stdout, &#34;W invalid muc jid\n&#34;); fflush(stdout); xmpp_stanza_release(presence_stanza); return; } sprintf(muc_jid_nick, &#34;%s/%s&#34;, jid, nick); xmpp_stanza_set_to(presence_stanza, muc_jid_nick); break; } // muc_jid contains nick if (jid[i++] == &#39;/&#39;) { break; } } extension_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(extension_stanza, &#34;x&#34;); xmpp_stanza_set_ns(extension_stanza, &#34;http://jabber.org/protocol/muc&#34;); if (presence_index == PRESENCE_ONLINE_MUC_NO_HISTORY) { xmpp_stanza_t *history_stanza; history_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(history_stanza, &#34;history&#34;); xmpp_stanza_set_attribute(history_stanza, &#34;maxstanzas&#34;, &#34;0&#34;); xmpp_stanza_add_child_ex(extension_stanza, history_stanza, 0); } if (status_text) { xmpp_stanza_t *password_stanza, *value_stanza; password_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(password_stanza, &#34;password&#34;); value_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_text(value_stanza, status_text); xmpp_stanza_add_child_ex(password_stanza, value_stanza, 0); xmpp_stanza_add_child_ex(extension_stanza, password_stanza, 0); } xmpp_stanza_add_child_ex(presence_stanza, extension_stanza, 0); } else { if (1 &lt; presence_index) { xmpp_stanza_t *show_stanza, *value_stanza; show_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(show_stanza, &#34;show&#34;); value_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_text(value_stanza, presence_type[presence_index]); xmpp_stanza_add_child_ex(show_stanza, value_stanza, 0); xmpp_stanza_add_child_ex(presence_stanza, show_stanza, 0); } if (priority_text || (conn_priority &amp;&amp; -128 &lt; conn_priority &amp;&amp; conn_priority &lt; 127)) { xmpp_stanza_t *priority_stanza, *value_stanza; priority_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(priority_stanza, &#34;priority&#34;); value_stanza = xmpp_stanza_new(ctx); if (!priority_text) { char conn_priority_text[5]; sprintf(conn_priority_text, &#34;%d&#34;, conn_priority); xmpp_stanza_set_text(value_stanza, conn_priority_text); } else { xmpp_stanza_set_text(value_stanza, priority_text); } xmpp_stanza_add_child_ex(priority_stanza, value_stanza, 0); xmpp_stanza_add_child_ex(presence_stanza, priority_stanza, 0); } if (status_text) { xmpp_stanza_t *status_stanza, *value_stanza; status_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_name(status_stanza, &#34;status&#34;); value_stanza = xmpp_stanza_new(ctx); xmpp_stanza_set_text(value_stanza, status_text); xmpp_stanza_add_child_ex(status_stanza, value_stanza, 0); xmpp_stanza_add_child_ex(presence_stanza, status_stanza, 0); } } xmpp_send(conn, presence_stanza); xmpp_stanza_release(presence_stanza);}void disconnect(xmpp_conn_t *conn) { if (reconnect == 1) { reconnect = 0; } send_presence(conn, PRESENCE_OFFLINE, NULL, NULL, NULL); xmpp_disconnect(conn);}void send_message(xmpp_conn_t *conn, const char *jid, const char command, const char *text) { xmpp_ctx_t *ctx = xmpp_conn_get_context(conn); xmpp_stanza_t *message_stanza; xmpp_stanza_t *extension_stanza = NULL; const char *type = &#34;chat&#34;; switch (command) { case &#39;x&#39;: // x: m -&gt; jid in muc extension_stanza = xmpp_stanza_new(ctx); break; case &#39;M&#39;: type = &#34;groupchat&#34;; break; case &#39;h&#39;: type = &#34;headline&#34;; break; case &#39;N&#39;: // N: n -&gt; jid in muc extension_stanza = xmpp_stanza_new(ctx); // fall through case &#39;n&#39;: type = &#34;normal&#34;; break; } message_stanza = xmpp_message_new(ctx, type, jid, NULL); xmpp_message_set_body(message_stanza, text); if (extension_stanza) { xmpp_stanza_set_name(extension_stanza, &#34;x&#34;); xmpp_stanza_set_ns(extension_stanza, &#34;http://jabber.org/protocol/muc#user&#34;); xmpp_stanza_add_child_ex(message_stanza, extension_stanza, 0); } xmpp_send(conn, message_stanza); xmpp_stanza_release(message_stanza);}short muc_in_jid_list(const char *jid) { struct list_node *list_current = jid_list; unsigned short jid_len = (unsigned short)strlen(jid); while (list_current) { // inverse presence for muc jid if (list_current-&gt;presence &lt; 0 &amp;&amp; strncmp(jid, list_current-&gt;jid, jid_len) == 0) { return 1; } list_current = list_current-&gt;next; } return 0;}int input_handler(xmpp_conn_t *conn, void *userdata) { struct timeval tv; fd_set rd; int cin; char bufin[BUFIN_MAX]; unsigned short bufin_len = 0; unsigned short index; // starting with a jid -&gt; default (chat) [m]essage to jid char command = &#39;m&#39;; char *jid = NULL; if (reconnect &lt; 0) { // signal received disconnect(conn); return 1; } FD_ZERO(&amp;rd); FD_SET(0, &amp;rd); tv.tv_sec = 0; tv.tv_usec = 250; cin = select(1, &amp;rd, 0, 0, &amp;tv); if (cin == 0) { // timeout - no input return 1; } if (cin == -1) { // stdin broken disconnect(conn); return 1; } while (cin != &#39;\n&#39;) { cin = fgetc(stdin); if (cin == EOF) { disconnect(conn); return 1; } // if space left, else still read/remove everything from input if (bufin_len &lt; BUFIN_MAX - 1) { bufin[bufin_len++] = (char)cin; } } if (bufin_len == BUFIN_MAX - 1) { fprintf(stdout, &#34;W too much input\n&#34;); fflush(stdout); return 1; } while (0 &lt; bufin_len &amp;&amp; isspace(bufin[bufin_len - 1])) { // trim end of input bufin_len--; } bufin[bufin_len] = 0; if (multi_line) { if (bufin[0] == &#39;.&#39; &amp;&amp; bufin[1] == 0) { if (multi_line == -1) { send_presence(conn, PRESENCE_OFFLINE, NULL, &amp;last_sent_type_jid[1], NULL); } multi_line = 0; fprintf(stdout, &#34;i end multi line\n&#34;); fflush(stdout); return 1; } send_message(conn, &amp;last_sent_type_jid[1], last_sent_type_jid[0], bufin); return 1; } if (bufin[0] == 0) { // ignore empty lines return 1; } // trim start index = get_start_pos(bufin, 0); if (bufin[index + 1] == &#39; &#39;) { // get command (if second char is empty it is no jid) command = bufin[index]; index = get_start_pos(bufin, index + 2); } else if (bufin[index + 1] == 0) { // just single char command struct list_node *list_current; char priority_text[8]; unsigned short show_offline = 0; command = bufin[index]; switch (command) { case &#39;.&#39;: if (last_sent_type_jid[0] == 0) { fprintf(stdout, &#34;W no last jid\n&#34;); fflush(stdout); return 1; } multi_line = 1; if (last_sent_type_jid[0] == &#39;M&#39;) { if (!muc_in_jid_list(&amp;last_sent_type_jid[1])) { multi_line = -1; } } fprintf(stdout, &#34;i multi line - end with \&#34;.\&#34;\n&#34;); fflush(stdout); return 1; case &#39;j&#39;: show_presence_status_change = 1; return 1; case &#39;l&#39;: show_presence_status_change = 0; return 1; case &#39;P&#39;: show_offline = 1; // fall through case &#39;p&#39;: list_current = jid_list; while (list_current) { if (list_current-&gt;priority) { sprintf(priority_text, &#34; (%d)&#34;, list_current-&gt;priority); } else { priority_text[0] = 0; } if (list_current-&gt;presence &lt; 0) { // use inverse presence for muc fprintf(stdout, &#34;P %s (M) - %s%s\n&#34;, list_current-&gt;jid, presence_type[-list_current-&gt;presence], priority_text); } else if (show_offline || list_current-&gt;presence != PRESENCE_OFFLINE) { fprintf(stdout, &#34;P %s - %s%s\n&#34;, list_current-&gt;jid, presence_type[list_current-&gt;presence], priority_text); } list_current = list_current-&gt;next; } fflush(stdout); return 1; case &#39;q&#39;: disconnect(conn); return 1; case &#39;R&#39;: show_raw_stanza[0] = 0; return 1; } } if (command == &#39;r&#39;) { xmpp_send_raw_string(conn, &#34;%s&#34;, &amp;bufin[index]); return 1; } if (command == &#39;R&#39;) { strncpy(show_raw_stanza, &amp;bufin[index], SHOW_RAW_STANZA_MAX - 1); return 1; } if (command != &#39;.&#39; &amp;&amp; command != &#39;m&#39; &amp;&amp; command != &#39;M&#39; &amp;&amp; command != &#39;j&#39; &amp;&amp; command != &#39;J&#39; &amp;&amp; command != &#39;l&#39; &amp;&amp; command != &#39;p&#39; &amp;&amp; command != &#39;P&#39; &amp;&amp; command != &#39;n&#39; &amp;&amp; command != &#39;h&#39;) { fprintf(stdout, &#34;W invalid command\n&#34;); fflush(stdout); return 1; } if (command != &#39;.&#39; &amp;&amp; command != &#39;p&#39;) { // get jid (if not message to last jid or global presence) unsigned short jid_local_and_domain = 0; for (unsigned short i = index; i &lt; bufin_len; i++) { if (bufin[i] == &#39;@&#3</p><p>/*--微小的XMPP客户端——txmppc从stdin读取命令并打印到stdout。它是用于命令行或自动化的KISS客户端。超出范围：花名册-&gt；有一个状态列表-&gt；没有名称（别名）、组或订阅状态MUC管理-&gt；基本工作：加入（使用密码）、写入和离开-&gt；没有管理、邀请、注册、迪斯科。。。没有迪斯科舞厅、书签、pubsub、vcard、文件、语音。。。OMEMO-加密很好，但对于一个小客户端来说太复杂了：有一个库（https://github.com/gkdr/libomemo）和亵渎有一个很好的实现，但omemo的代码比txmppc大5倍-&gt；亵渎（tui-OMEMO、OTR和PGP及插件）&gt；https://profanity-im.github.io/（c使用libstrophe）——&gt；poezio（tui-欧米莫和OTR）&gt；https://poez.io/（python使用slixmpp lib）&gt；mcabber（tui——没有OMEMO，但有OTR和PGP，外部脚本+fifo）——&gt；https://mcabber.com/（c）使用lib loudmouth-&gt；https://github.com/mcabber/loudmouth）——&gt；xmppc（cli，它可以发送消息（聊天+PGP），监视和查询一些数据）->；https://codeberg.org/Anoxinon_e.V./xmppc（c使用libstrophe）——&gt；smplxmpp-&gt；https://codeberg.org/tropf/smplxmpp（c++使用gloox库）——&gt；freetalk-&gt；https://www.gnu.org/software/freetalk/（c）使用loudmouth）&gt；jj（创建文件系统（fifo）结构）&gt；https://23.fi/jj/（c使用loudmouth）构建：仅取决于libstophe&gt；gcc txmppc。c-lstrophe-o txmppcStatic编译（musl）&gt；gcc txmppc。c-lstrophe-lc-lssl-lcrypto-lexpat-static-o txmppc_static（取决于libstrophe，它可以是xml2而不是expat和/或gnutls而不是openssl）可选：&gt；strip txmppc_staticUse:[echo&#34；命令jid消息&#34；|]txmppc[_static]&lt；jid&gt&书信电报；通过&gt；[&lt；服务器&gt；[（：|=）&lt；端口&gt；]-jid和密码是必需的-可选的是服务器的第三个参数（和：port或=port-&gt；如果tls启动（自签名证书）失败则忽略）。txmppc记录向stdout输入消息并从stdin读取命令-仅作为瘦客户端启动：&gt；txmppc-发送单个消息：&gt；echo和#34；[mM]jid消息&#34；|txmppc-&gt；txmppc执行命令并退出（在stdin关闭时）-对命令使用fifo：&gt；tail-f fifo | txmppc-&gt；从fifo执行命令并打印到标准输出&gt；echo和#34；q&#34&gt&gt；先进先出！尾巴仍然会等待——所以它不会&#39；t出口-&gt；发送另一行-tmux水平拆分+rlwrap客户端示例：（mkfifo-fifo；echo&#34；contact@example.com&#34; &gt&gt；jid_文件）90%窗格&gt；一边读台词；打印F&#39；%s:&gt；%s\n和#39&#34;$（日期和#34；+%Y-%m-%d%H:%m和#34；）&#34; &#34;${line}&#34&gt&amp；2.printf&#39；%s\n和#39&#34;${line}&#34；；测试&#34；q&#34；=&#34;${line}&#34&amp&amp；打破完成&lt；fifo | txmppc JID PASS |读线时；打印F&#39；%s:%s\n&#39&#34;$（日期和#34；+%Y-%m-%d%H:%m和#34；）&#34; &#34;${line}&#34；；完成10%窗格&gt；rlwrap-s-10-H/dev/null-b&#34&#34; -f jid#U文件awk和#39；{print}/^q$/{exit}&#39&gt&gt；先进先出-&gt；通过10行历史记录（未保存）和fid_文件中的jid完成，读取行编辑，输出将有一个日期前缀-&gt；提示：在这种情况下，fifo可以&#39；不能用于其他进程，因为发送EOF将结束客户端。命令：j[muc[密码]]-&gt；加入多用户会议（无muc和#34；加入和#34；状态更改-默认打开）J muc[密码]-&gt；加入多用户会议-无历史记录[muc]-&gt；离开多用户会议（无muc和#34；离开和#34；状态更改）[m]jid[message]-&gt；向jid发送（聊天）信息（无信息进入多行模式）h jid信息-&gt；将标题消息发送到jidn jid消息-&gt；将正常消息发送至jidM muc_jid消息-&gt；向多用户会议发送（groupchat）消息（如果不在muc中，它将被加入并离开）。[信息]-&gt；将（聊天|标题|正常|群组聊天）消息发送到最后一个jid（无消息进入多行模式）p[[优先级]状态]-&gt；优先顺序：-128/127，出席：在[fline]| aw[ay]| ch[at]| dn[d]| xa-&gt；不带arg：显示状态列表；无优先级：仅更改状态yp[jid[priority]状态[status]]-&gt；向jid发送状态，额外状态：订阅|订阅|取消订阅|取消订阅-&gt；无arg显示状态列表，包括不可用/离线Q-&gt；结束/退出节-&gt；发送原始节（无效数据可能导致XMPP服务器立即终止流）R[key]-&gt；显示原始（消息、iq.result）节，如果它包含键-禁用而没有键-&gt&#34;&lt&#34; （将匹配每一节），&#34；智商&#34&#34;信息&#34&#34;碳&#34&#34;openpgp&#34&#34;juliet@example.org&#34;, ... （要查看使用-DDEBUG编译的每一节，它将启用libstrophe XMPP_LEVEL_DEBUG）输出：i-&gt；infoI-&gt；信息离线，失去连接P-&gt；在场（使用j/l命令更改加入/离开状态）P-&gt；状态列表M-&gt；信息聊天（&#34；m from:message&#34；，如果碳来自self&#34；m-&gt；to:message&#34；）n-&gt；消息正常H-&gt；消息标题M-&gt；信息多-&gt；消息muc historyr-&gt；原始信息节-&gt；错误w-&gt；警告-命令错误-&gt；（标准）启动错误-&gt；将退出加密：-可以发送PGP加密消息（发送原始节）：&gt；BASE64_OPENPGP_MESSAGE=$（echo和#34；MESSAGE和#34；|gpg | BASE64）和#34&gt；echo和#34；r&lt；致=&#39；juliet@example.org&#39;&gt&书信电报；openpgp xmlns=&#39；urn:xmpp:openpgp:0&#39&gt${BASE64_OPENPGP_MESSAGE}&lt/openpgp&gt&lt/信息&gt&#34; | txmppc（节必须在一行中，可能由其他客户端支持：https://xmpp.org/extensions/xep-0373.html)-&gt；请注意，大多数客户已经实施了过时的：https://xmpp.org/extensions/xep-0027.html-&gt；用于接收原始消息节过滤（&#34；R opengpg&#34；）这是一种选择。-一种不符合XMPP的方式，如果两个客户端都使用txmppc，则可以使用任何加密编写脚本。年龄示例（不要使用受密码保护的密钥）：发件人：&gt；加密消息=&#34$（printf和#39；message和#39；age-r age1rredc3g8dfachch0d6gzt5katx3tsfesz35zc6jn3fl23jrfmq027uuuu9 | base64-w0）和#34&gt；printf和#39；Mjuliet@example.orgMYCRYPT:%s&#39&#34;${ENCRYPTED_MESSAGE}&#34；|txmppc接收器：&gt；txmppc |读线时；做加密的_消息=&#34${line#*MYCRYPT:}&#34；如果[&#34；${line}&#34；=&#34；${ENCRYPTED#MESSAGE}&#34；]；然后printf&#39；%s\n和#39&#34;${line}&#34；else MESSAGE=&#34$（printf&#39；%s&#39；&#34；${ENCRYPTED#u MESSAGE}&#34；| base64-d | age-d-i juliet.key）&#34；printf&#39；%s%s\n&#39&#34;${line%MYCRYPT:}&#34&#34;${MESSAGE}&#34；fi Donelices：https://holmeinbuch.de/repo/txmppc/ - matthias@Copyright（c）ISC License特此授予出于任何目的使用、复制、修改和/或分发本软件的许可，无论是否收费，前提是上述版权声明和本许可声明出现在所有副本中。软件提供&#34；原样&#34；作者否认与本软件有关的所有保证，包括所有关于适销性和适用性的暗示保证。在任何情况下，作者均不对因使用或执行本软件而产生的或与之相关的任何特殊、直接、间接或后果性损害或因使用、数据或利润损失而导致的任何损害负责，无论是在合同诉讼、疏忽或其他侵权诉讼中*/#包括&lt；ctype。h&gt#包括&lt；斯特迪奥。h&gt#包括&lt；stdlib。h&gt#包括&lt；一串h&gt#包括&lt；信号h&gt#包括&lt；系统/选择。h&gt#包括&lt；时间h&gt#包括&lt；unistd。h&gt；//https://www.rfc-editor.org/rfc/rfc6120-核心//https://www.rfc-editor.org/rfc/rfc6121-即时通讯+状态#包括&lt；斯特罗弗。h&gt；静态无符号短忽略证书失败=0；静态短路重新连接=1；//https://www.rfc-editor.org/rfc/rfc6120-&gt；4.6.4检查方法的使用：建议每5分钟不超过一次#定义PING_间隔60静态字符PING_id[32]#定义BUFIN_MAX 4096//https://www.rfc-editor.org/rfc/rfc6121-&gt；唐&#39；t干扰优先级，负数可能得不到消息静态短连接优先级=0；静态无符号短显示\存在\状态\更改=1#定义存在；定义存在；定义存在；定义存在；定义存在。JID）JID）JID）最大静态字符。静态字符表示。类型[10][[13][[10][[13]={35；34；离线；离线；离线和34；34；34；在线和34；在线和34；在线和34；在线和34；在线和34；在线和34；在线和34；34；34；34；以及以及以及以及以及以及（35；34；34；34；在线和34；在线；34；34；34；34；34；34；34；34；34；在线和，以及以及以及，以及以及，以及以及以及以及以及，以及以及以及以及以及以及，34；在线；34；34；34；34；34；34；34；34；34；34；在线和，以及，以及，以及，以及，以及，以及，以及，以及，以及以及，以及，以及以及，以及以及以及以及，以及以及以及以及，以及以及以及以及以及以及，34；34；34；34；34；34#34；取消订阅&#34；，&#34；取消订阅&#34；}#定义状态_离线0#定义状态_在线1#定义状态_在线_MUC-1#定义状态_在线_MUC-NO _历史-101#定义状态_离线_MUC-100//https://www.rfc-editor.org/rfc/rfc7622-地址（jid）#定义jid_MAX 3071+1上次发送的静态字符_类型_jid[1+jid_MAX]；struct list_node{char jid[jid_MAX]；短存在；短优先级；struct list_node*next；}；静态结构列表节点*jid\u list=NULL；//https://xmpp.org/extensions/xep-0172.html-尼克-&gt；昵称长度未定义//https://xmpp.org/extensions/xep-0045.html-muc-&gt；昵称是jid的资源部分#定义NICK_MAX 1023+1静态字符NICK[NICK_MAX]；静态短多_线=0#定义SHOW_RAW_STANZA_MAX 32静态字符SHOW_RAW_STANZA[SHOW_RAW_STANZA_MAX]；无符号短截取开始位置（char*buf，unsigned short start_pos）{unsigned short buf_len=（unsigned short）strlen（&amp；buf[start_pos]）+start_pos for（unsigned short i=start_pos；i&lt；buf_len；i++）{if（！isspace（buf[i]）{return i；}返回buf_len；}void update_jid_list（const char*jid，short presence，short priority）{struct list_node*list_before=NULL；struct list_node*list_current=jid_list；struct list_node*list_new=NULL；size_jid_len=strlen（jid）；而（list_current）{int jid_match=strnmp（jid，list_current-&gt；jid，jidlen）；if（jid_match==0）{（presence==presence\u OFFLINE\u MUC）{//remove jid，将MUC从列表中删除//如果self离开MUC，则使用裸jid-&gt；删除每个MUC条目，而（list\u current&amp；strncmp（jid，list\u current-&gt；jid\u len）==0）{if（list\u before）{list\u before-&gt；next=list\u current-&gt；next；free（list\u current）; list_current=list_before-&gt；下一步；}否则{jid_list=l</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/命令行/">#命令行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/xmpp/">#xmpp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>