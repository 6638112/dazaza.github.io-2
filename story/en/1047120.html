<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go的本机Mac API Native Mac APIs for Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Native Mac APIs for Go<br/>Go的本机Mac API </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:01:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/273c8ee3604a4d298fbc753acc6bd179.png"><img src="http://img2.diglog.com/img/2021/2/273c8ee3604a4d298fbc753acc6bd179.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>MacDriver is a toolkit for working with Apple/Mac APIs and frameworks in Go. It currently has 3 &#34;layers&#34;:</p><p>MacDriver是用于在Go中使用Apple / Mac API和框架的工具包。目前有3个＆＃34; layers＆＃34 ;：</p><p>  The  objc package wraps the  Objective-C runtime to dynamically interact with Objective-C objects and classes:</p><p>  objc包包装了Objective-C运行时以与Objective-C对象和类动态交互：</p><p>    The  cocoa,  webkit, and  core packages wrap  objc with wrapper types for parts of the Apple/Mac APIs. They&#39;re being added to as needed by hand untilwe can automate this process with schema data. These packages effectively let you use Apple APIs as if they were native Go libraries, lettingyou write Mac applications (potentially also iOS, watchOS, etc) as Go applications:</p><p>    可可，webkit和核心程序包使用部分Apple / Mac API的包装器类型包装objc。将根据需要手动添加它们，直到我们可以使用架构数据自动执行此过程。这些软件包可让您有效地使用Apple API，就像它们是本地Go库一样，从而使您可以将Mac应用程序（可能还包括iOS，watchOS等）编写为Go应用程序：</p><p> func  main() {	 app  :=  cocoa. NSApp_WithDidLaunch( func( notification objc. Object) {		 config  :=  webkit. WKWebViewConfiguration_New()		 wv  :=  webkit. WKWebView_Init( core. Rect( 0,  0,  1440,  900),  config)		 url  :=  core. URL( &#34;http://progrium.com&#34;)		 req  :=  core. NSURLRequest_Init( url)		 wv. LoadRequest( req)		 w  :=  cocoa. NSWindow_Init( core. Rect( 0,  0,  1440,  900),			 cocoa. NSClosableWindowMask |				 cocoa. NSTitledWindowMask,			 cocoa. NSBackingStoreBuffered,  false)		 w. SetContentView( wv)		 w. MakeKeyAndOrderFront( w)		 w. Center()	})	 app. SetActivationPolicy( cocoa. NSApplicationActivationPolicyRegular)	 app. ActivateIgnoringOtherApps( true)	 app. Run()}</p><p> func main（）{app：=可可粉。 NSApp_WithDidLaunch（func（通知objc.Object）{config：= webkit。WKWebViewConfiguration_New（）wv：= webkit。WKWebView_Init（core。Rect（0，0，1440，900），config）url：= core。URL（＆＃34 ; http：//progrium.com&#34;）req：= core。NSURLRequest_Init（url）wv。LoadRequest（req）w：= cocoa。NSWindow_Init（core。Rect（0，0，1440，900），cocoa。NSClosableWindowMask |可可NSTitledWindowMask，可可NSBackingStoreBuffered，false）w。SetContentView（wv）w。MakeKeyAndOrderFront（w）w。Center（）}）应用程序。 SetActivationPolicy（可可NSApplicationActivationPolicyRegular）应用程序。 ActivateIgnoringOtherApps（true）应用。跑（）}</p><p>     examples/topframe - A non-interactive, always-on-top webview with transparent background in 120 lines so you can draw on yourscreen with HTML/JS:</p><p>     examples / topframe-非交互式，始终位于顶部的webview，具有120行透明背景，因此您可以使用HTML / JS在屏幕上绘制：</p><p>   Lastly, a common case for this toolkit is not just building full native apps, but integrating Go applicationswith Mac systems, like windows, native menus, status icons (systray), etc.One-off libraries for some of these exist, but besides often limiting what you can do,they&#39;re also just not composable. They all want to own the main thread!</p><p>   最后，此工具包的常见情况不仅是构建完整的本机应用程序，还包括将Go应用程序与Mac系统（例如Windows，本机菜单，状态图标（系统托盘）等）集成在一起。限制您可以做的事情，它们也是无法组合的。他们都想拥有主线程！</p><p> For this and other reasons, we often run the above kind of code in a separate process altogether from ourGo application. This might seem like a step backwards, but it is safer and more robust in a way.</p><p> 由于这个原因和其他原因，我们通常在与Go应用程序分开的单独流程中运行上述代码。这似乎是倒退了一步，但从某种程度上讲它更安全，更可靠。 </p><p> The  bridge package takes advantage of this situation to create a higher-level abstraction more aligned with a potentialcross-platform toolkit. You can declaratively describe and modify structs that can be copied to the bridge process and applied to the Objective-Cobjects in a manner similar to configuration management:</p><p>桥接程序包利用这种情况来创建更高级的抽象，使其与潜在的跨平台工具包更加一致。您可以以类似于配置管理的方式声明性地描述和修改可复制到桥接过程并应用于Objective-C对象的结构：</p><p> package main  import (	 &#34;os&#34;	 &#34;github.com/progrium/macdriver/bridge&#34;) func  main() {	 // start a bridge subprocess	 host  :=  bridge. NewHost( os. Stderr)	 go  host. Run()	 // create a window	 window  := bridge. Window{		 Title:  &#34;My Title&#34;,		 Size: bridge. Size{ W:  480,  H:  240},		 Position: bridge. Point{ X:  200,  Y:  200},		 Closable:  true,		 Minimizable:  false,		 Resizable:  false,		 Borderless:  false,		 AlwaysOnTop:  true,		 Background:  &amp;bridge. Color{ R:  1,  G:  1,  B:  1,  A:  0.5},	}	 host. Sync( &amp; window)	 // change its title	 window. Title  =  &#34;My New Title&#34;	 host. Sync( &amp; window)	 // destroy the window	 host. Release( &amp; window)}</p><p> 包main import（＆＃34; os＆＃34;＆＃34; github.com/progrium/macdriver/bridge&#34;）func main（）{//启动网桥子进程主机：= bridge。 NewHost（os。Stderr）成为主机。 Run（）//创建一个窗口window：= bridge。窗口{标题：＆＃34;我的标题＆＃34 ;，大小：桥。大小{W：480，H：240}，位置：网桥。点{X：200，Y：200}，可关闭：true，最小化：false，可调整大小：false，无边界：false，AlwaysOnTop：true，背景：＆bridge。颜色{R：1，G：1，B：1，A：0.5}，}主机。 Sync（＆amp; window）//更改其标题窗口。标题=＆＃34;我的新标题＆＃34;主办。 Sync（＆amp; window）//销毁窗口主机。释放（＆amp; window）}</p><p> This is the most WIP part of the project, but once developed further we can take this API and build a bridgesystem with the same resources for Windows and Linux, making a cross-platform OS &#34;driver&#34;. We&#39;ll see.</p><p> 这是该项目中WIP最多的部分，但是一旦进一步开发，我们就可以使用此API并使用具有相同资源的Windows和Linux构建桥接系统，从而创建跨平台的OS驱动程序。我们将会看到。</p><p>   As far as we know, due to limitations of Go modules, we often need to add  replace directives to our  go.mod during developmentto work against a local checkout of some dependency (like qtalk). However, these should not be versioned, so for now we encourageyou to use  git update-index --skip-worktree go.mod on your checkout if you need to add  replace directives. When updates need tobe checked in,  git update-index --no-skip-worktree go.mod can be used to reverse this on your local repo to commit changes and then re-enable.</p><p>   据我们所知，由于Go模块的局限性，我们经常需要在开发过程中向go.mod中添加replace指令，以对某些依赖项（例如qtalk）进行本地检出。但是，这些版本不应进行版本控制，因此，现在我们建议您在结帐时使用git update-index --skip-worktree go.mod，如果需要添加替换指令。当需要检查更新时，可以使用git update-index --no-skip-worktree go.mod在本地存储库上将其撤消以提交更改，然后重新启用。</p><p>  Eventually we can generate most of the wrapper APIs using bridgesupport and/or doc schemas. However, the number of APIsis pretty ridiculous so there are lots of edge cases I wouldn&#39;t know how to automate yet. We can just continue to create them by handas needed until we have enough coverage/confidence to know how we&#39;d generate wrappers.</p><p>  最终，我们可以使用bridgesupport和/或doc模式生成大多数包装器API。但是，APIsis的数量非常可笑，所以有很多我不知道如何自动化的极端情况。我们可以继续根据需要手动创建它们，直到我们有足够的覆盖范围/信心来知道我们如何生成包装器。</p><p>  The original  objc and  variadic packages were written by  Mikkel Krautz. The  variadic package is some assembly magic to make everything possible since libobjc relies heavily on variadic function calls, which aren&#39;t possible out of the box in Cgo.</p><p>  原始objc和可变参数程序包是由Mikkel Krautz编写的。可变参数包是使一切变为可能的某种汇编魔术，因为libobjc严重依赖可变参数函数调用，而Cgo中的可变参数调用是不可能的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/progrium/macdriver">https://github.com/progrium/macdriver</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/mac/">#mac</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>