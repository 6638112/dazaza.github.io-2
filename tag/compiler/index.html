<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#compiler</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#compiler</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1063800.html">-O3编译器优化级别仍然被视为Linux内核太不安全 </a></div><div class="item_title_en"><a target="_blank" href="https://www.phoronix.com/scan.php?page=news_item&px=No-O3-For-Linux-Kernel">-O3 Compiler Optimization Level Still Deemed Too Unsafe for the Linux Kernel</a><span>(www.phoronix.com)</span></div><span class="my_story_list_date">2021-6-6 11:31</span><div class="my_story_list_item_desc">我们依靠您的支持：您是否知道每个月在Phoronix上写的数百篇文章主要是由一个人疯狂时间的人撰写？ Phoronix.com并不是有一个全新的新闻室，拥有无限的资源，并依赖于阅读我们的内容的人们而不阻止广告，并且通过订阅Phoronix保费的人与其他额外功能。您还可以通过PayPal考虑提示。由于GNU编译器集合（......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062609.html">Quantaichi：GPU上量化（“低精度”）模拟的编译器 </a></div><div class="item_title_en"><a target="_blank" href="https://yuanming.taichi.graphics/publication/2021-quantaichi/">QuanTaichi: A Compiler for Quantized (“Low-Precision”) Simulations on the GPU</a><span>(yuanming.taichi.graphics)</span></div><span class="my_story_list_date">2021-5-14 9:16</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1062609.html"><img src="http://img2.diglog.com/img/2021/5/thumb_6b1cf3e020bff07d8aa0ba0e8366f38c.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">高分辨率模拟可以提供很大的视觉质量，但它们通常受到可用内存的限制，特别是在GPU上。我们通过启用灵活和积极的量化，提供了一个用于物理仿真的编译器，可以实现高性能并显着降低内存成本。使用低精度（“量化”）数值数据类型并打包以表示模拟状态，从而降低了内存空间和带宽消耗。量化仿真允许更高的存储器模拟，内存较少，这对GPU特......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模拟/">#模拟</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/量化/">#量化</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062098.html">编译假设 </a></div><div class="item_title_en"><a target="_blank" href="https://babel.dev/docs/en/assumptions">Compiler assumptions</a><span>(babel.dev)</span></div><span class="my_story_list_date">2021-5-12 11:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1062098.html"><img src="http://img2.diglog.com/img/2021/5/thumb_ae2b9c15eaa7e3e47c424e9f1f8179a7.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">默认情况下，BABEL尝试编译代码，以便与您尽可能贴近本机行为。然而，这有时意味着产生更多的输出代码或较慢的输出代码，只是为了支持一些边缘案例，你不在乎。
 由于Babel 7.13.0，您可以在配置中指定假设选项，以告诉Babel哪些假设它可以弄乱的代码，以更好地优化编译结果。注意：这取代了插件中的各种松动选项，支......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1060559.html">编译器将优化它 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.royalsloth.eu/posts/the-compiler-will-optimize-that-away/">The compiler will optimize that away</a><span>(blog.royalsloth.eu)</span></div><span class="my_story_list_date">2021-5-5 20:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1060559.html"><img src="http://img2.diglog.com/img/2021/5/thumb_2dc7adb413e443e6dedaa2c19a2ef1c2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">很多程序员都认为编译器是魔法黑匣子，您可以在其中普通杂乱的代码，并获得一个很好的优化二进制。走廊哲学家频道经常开始争论哪个语言功能或编译器标志使用的命令来捕获编译器的魔术的全部力量。如果您见过GCC码库，您真的相信它必须是来自另一个星球的工人魔法优化。
 尽管如此，如果您分析编译器的输出，您将发现编译器并不是在优化代......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1053655.html">OpenBSD上的工作D编译器 </a></div><div class="item_title_en"><a target="_blank" href="https://briancallahan.net/blog/20210320.html">A working D compiler on OpenBSD</a><span>(briancallahan.net)</span></div><span class="my_story_list_date">2021-3-20 23:35</span><div class="my_story_list_item_desc">我得到了GDC，GNU D编译器，在OpenBSD上工作。支持D已经很长时间了。在这里，我们在这里到达的故事以及我们需要走的故事。
  回到2017年的方式是我第一次学习D.似乎有趣，我们没有港口。我喜欢挑战所以我想我会试一试。我最终设法获得LDC，LLVM D编译器，在OpenBSD上构建。或者，至少，它的LTS版......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/openbsd/">#openbsd</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1052673.html">kotlin编译器崩溃课程 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/ahinchman1/Kotlin-Compiler-Crash-Course">Kotlin Compiler Crash Course</a><span>(github.com)</span></div><span class="my_story_list_date">2021-3-16 14:56</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1052673.html"><img src="http://img2.diglog.com/img/2021/3/thumb_86209d8c77a4f7f8ba0b1ee05ac78f17.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">根据Kotlin编译器，PSI或Program Struction界面，树是基于AST的顶部构建的，为操纵特定语言构造添加语义和方法。  AST节点具有直接映射到底层文档中的文本范围。 AST的最底部节点匹配Lexer返回的单个令牌，更高级别的节点匹配多个令牌片段。 对AST树的节点执行的操作，例如插入，删除，重新排......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1047442.html">编译器类 </a></div><div class="item_title_en"><a target="_blank" href="https://norswap.com/compilers/">Compiler Class</a><span>(norswap.com)</span></div><span class="my_story_list_date">2021-2-9 20:38</span><div class="my_story_list_item_desc">所有课程材料都可以在线获取，以供有兴趣的人阅读。 我也很乐意回答您的问题。  该课程的项目是创建自己的编程语言。 提供了一些库来协助完成此任务： </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/回答/">#回答</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041787.html">Vacietis，一个针对Common Lisp的C编译器 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/vsedach/Vacietis">Vacietis, a C compiler targeting Common Lisp</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-26 0:13</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041787.html"><img src="http://img2.diglog.com/img/2020/12/thumb_f615d833ece725d282b56c4c82184eb8.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Vacietis是Common Lisp系统的C编译器.Vacietis的工作原理是将C代码加载到Common Lisp运行时中，就像Lisp代码一样，然后可以在其中进行编译或回避。重载的C代码具有与常规CL代码相同的函数调用约定，并使用相同的数字表示形式。 C内存由regularCommon Lisp数组支持。Va......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vacietis/">#vacietis</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037150.html">Richard Miller的RISC-V计划9 C编译器[视频]</a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=LHJqdXGb0uc">A Plan 9 C Compiler for RISC-V by Richard Miller [video]</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-11-30 0:30</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037150.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b5310b7ab14bd3f2dcb5e98a7f9dc32a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">理查德·米勒（Richard Miller）提出Plan 9 C编译器与Plan 9和Inferno操作系统一起起源于贝尔实验室。这是最初开发的一部分...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/miller/">#miller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037116.html">Nim编译器— Pascal源代码</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nim-lang/Nim/tree/ea1f1ec6d4d6c776eb0f81c2bebdd4cb4c817ebe/nim">Nim compiler — Pascal source code</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-29 16:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037116.html"><img src="http://img2.diglog.com/img/2020/11/thumb_025b67dc2053e70abacf6317da9484ff.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Nim是一种静态类型的编译系统编程语言。它结合了来自成熟语言（如Python，Ada和Modula）的成功概念。其设计注重效率，表达力，...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036520.html">法国税法的现代编译器</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2011.07966">A Modern Compiler for the French Tax Code</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-11-25 22:0</span><div class="my_story_list_item_desc">下载PDF摘要：在法国，所得税是根据法国公共财政局（DGFiP）创作，设计和维护的，从纳税人的个人收益中计算得出的。该算法依赖于传统的自定义语言和最初于1990年设计的编译器，它与法国葡萄酒不同，没有随着时间的流逝而衰老。由于输入语言的不足和编译器的技术局限性，该算法越来越难以维护，它依靠临时行为和变通办法来实现税法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/税法/">#税法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034291.html">从内部增强C源代码到源代码的编译器</a></div><div class="item_title_en"><a target="_blank" href="https://hal.inria.fr/hal-02998412">C source-to-source compiler enhancement from within</a><span>(hal.inria.fr)</span></div><span class="my_story_list_date">2020-11-11 0:23</span><div class="my_story_list_item_desc">1加缪-汇编和建筑多核心结构：233382 ICUBE-实验室科学，信息和图像结构：217648 ENGEES-国家学院斯特拉斯堡环境结构：94023；Eau et de l&#39；Eau et de l&39；Eau et de l&39；
Réseau Nanoptonique et Optique Struc......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/源代码/">#源代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/结构/">#结构</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030829.html">我自己的编译器基础结构上的我自己的C编译器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/maekawatoshiki/cilk/tree/master/cilkcc">My own C compiler on my own compiler infrastructure</a><span>(github.com)</span></div><span class="my_story_list_date">2020-10-24 7:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030829.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b71f23a653e4ac6df1ae71037508c3c3.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">(玩具)用Rust-maekawatoshiki/cilk编写的受LLVM影响的编译器基础设施</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基础/">#基础</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027243.html">除非它是编译器错误，否则它永远不会是编译器错误</a></div><div class="item_title_en"><a target="_blank" href="http://r6.ca/blog/20200929T023701Z.html">It Is Never a Compiler Bug Until It Is</a><span>(r6.ca)</span></div><span class="my_story_list_date">2020-9-30 18:43</span><div class="my_story_list_item_desc">上周，我试图向libsecp256k1添加一些测试代码，我拔掉头发试图让它正常工作。没有多少printf工作来说明我做错了什么。最后，出于无奈，我想我应该快速检查一下是否有与memcmp相关的编译器错误，结果，我发现了GCC错误#95189：memcmp像strcmp一样被错误地剥离。
老实说，读起来这是一个相当可怕......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026110.html">CPython编译器的工作原理</a></div><div class="item_title_en"><a target="_blank" href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">How the CPython compiler works</a><span>(tenthousandmeters.com)</span></div><span class="my_story_list_date">2020-9-24 17:31</span><div class="my_story_list_item_desc">在本系列的第一篇文章中，我们介绍了CPython VM。我们已经了解到它是通过执行一系列称为字节码的指令来工作的。我们还看到，Python字节码不足以完全描述一段代码的功能。这就是存在代码对象概念的原因。执行诸如模块或函数的代码块意味着执行相应的代码对象。代码对象包含块的字节码、常量和块中使用的变量名称以及块的各种属......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017900.html">我们能比我们的C编译器做得更好吗？</a></div><div class="item_title_en"><a target="_blank" href="https://briancallahan.net/blog/20200812.html">Can we do better than our C compiler?</a><span>(briancallahan.net)</span></div><span class="my_story_list_date">2020-8-13 13:22</span><div class="my_story_list_item_desc">今天，我想成为一名C编译器。我从前面的编码练习中添加了一个手工编译的ECHO汇编版本，并添加了一个新的make目标make asm，它将对其进行汇编。让我们看看我们手工编译的程序集，并将其与我们的C编译器进行比较，然后问问它是否值得。
.text.p2ign 2.globl main.type main，@funct......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/argv/">#argv</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013322.html">编译器基准测试</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nordlow/compiler-benchmark">Compiler Benchmark</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-22 2:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013322.html"><img src="http://img.diglog.com/img/2020/7/thumb_2d9745cfe2a1ae038646d105cceecc63.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这将在生成的目录中生成代码，然后针对语言、操作类型和编译器的每种组合，运行支持的基准测试。最后，一个显示基准结果的Markdown格式表被打印到标准输出。
GCC和克朗并没有为C++执行所有的语义检查(因为它太昂贵了)。这与执行所有这些任务的D&39；s和Rust&#39；编译器形成了鲜明对比。
LONG ADD_L......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基准/">#基准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/long/">#long</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012823.html">CUCU：一个你能理解的编译器(1/3)</a></div><div class="item_title_en"><a target="_blank" href="https://zserge.com/posts/cucu-part1/">Cucu: A compiler you can understand (1/3)</a><span>(zserge.com)</span></div><span class="my_story_list_date">2020-7-19 10:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012823.html"><img src="http://img.diglog.com/img/2020/7/thumb_3cd67f8c773c5df13d60d9d2e7f8918c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我会试着告诉你这有多简单。第一部分很有理论性，所以要有耐心。
CUCU是玩具语言的玩具编译器。我希望它尽可能接近ANSI CA，这样每个有效的CUCU程序都可以用C编译器编译，没有任何错误。当然，整个ANSI C标准的支持非常困难，所以我选择了一个非常小的C语言子集。
Int cucu_strlen(char*s){......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/理解/">#理解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/expr/">#expr</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010827.html">GCC编译器针对ARM直线投机漏洞的土地保护</a></div><div class="item_title_en"><a target="_blank" href="https://www.phoronix.com/scan.php?page=news_item&px=GCC-Lands-SLS-Mitigation">GCC Compiler Lands Mitigation for Arm's Straight Line Speculation Vulnerability</a><span>(www.phoronix.com)</span></div><span class="my_story_list_date">2020-7-10 0:44</span><div class="my_story_list_item_desc">在ARM披露CPUSLS漏洞和LLVM编译器初始缓解后花了一个月的时间，但GNU编译器集合(GCC)现在也针对此直线推测漏洞进行了缓解。(注：Gnu Compiler Collection(Gnu Compiler Collection，GNU Compiler Collection)(GCC))现在也针对此直线推测......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/直线/">#直线</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓解/">#缓解</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010197.html">Go与C#：编译器、运行时、类型系统、模块</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/servicetitan-engineering/go-vs-c-part-3-compiler-runtime-type-system-modules-and-everything-else-faa423dddb34">Go vs. C#: Compiler, Runtime, Type System, Modules</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-7 5:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010197.html"><img src="http://img.diglog.com/img/2020/7/thumb_fe5ff336acc9de4afb0853043ce93294.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是系列文章中的最后一篇，也是最有趣的一篇。第1部分和第2部分重点介绍了Golang-Goroutines和几乎停顿的GC的两个关键特性。这篇帖子补充了所有缺失的部分。
但是，在如何实现所有这些功能方面，有更多的不同之处而不是相似之处。让我们跳到这些内容：)。
Go编译成本机二进制文件--也就是说，它的二进制文件“绑......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006819.html">铁锈编译器不慢，我们慢</a></div><div class="item_title_en"><a target="_blank" href="https://blog.kodewerx.org/2020/06/the-rust-compiler-isnt-slow-we-are.html">The Rust compiler isn't slow; we are</a><span>(blog.kodewerx.org)</span></div><span class="my_story_list_date">2020-6-16 23:36</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006819.html"><img src="http://img.diglog.com/img/2020/6/thumb_64f792b778acfccbf5f64e6ca4044b24.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这可能是一个有点不受欢迎的观点，所以点击诱饵标题应该是合适的！从1.6版开始，我已经学习和使用Rust将近四年半了。对于熟悉语言、工具和生态系统的一些问题来说，这是一段很长的时间。但这是一个略有不同的故事，这是对编译器速度慢的常见批评的异议。在这次讨论中，我将争辩说，这些说法充其量只是误导。有大量证据表明，与其他语言......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/铁锈/">#铁锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1005256.html">Go编译器需要更智能</a></div><div class="item_title_en"><a target="_blank" href="https://lemire.me/blog/2020/06/04/the-go-compiler-needs-to-be-smarter/">The Go Compiler Needs to Be Smarter</a><span>(lemire.me)</span></div><span class="my_story_list_date">2020-6-5 11:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1005256.html"><img src="http://img.diglog.com/img/2020/6/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我最喜欢的语言之一是围棋语言。我喜欢它的简约。它在云环境中很受欢迎，也很有用。许多流行的工具都是用Go编写的，这是有充分理由的。
去年我做了一次关于围棋的演讲，有人要求我对围棋进行批评。我不介意围棋缺少例外或泛型。这些功能通常被高估了。
然而，尽管Go很有魅力，但我发现它的编译器与我对其他编程语言的期望不一样。当围棋......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/围棋/">#围棋</a></button></div></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>