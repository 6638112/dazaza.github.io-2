<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Fossil SCM同步协议使用CRDTFossil SCM sync protocol uses CRDTs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fossil SCM sync protocol uses CRDTs<br/>Fossil SCM同步协议使用CRDT</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-28 14:34:10</div><div class="page_narrow text-break page_content"><p>The following are the known pragma names as of 2019-06-30: send-private The send-private pragma instructs the server to send all of itsprivate artifacts to the client. The server will only obey thisrequest if the user has the &#34;x&#34; or &#34;Private&#34; privilege.</p><p>以下是自2019年6月30日起的已知实用名称：send-private send-private实用指令指示服务器将其所有私有工件发送到客户端。如果用户具有“ x”或“私人”特权，则服务器将仅服从该请求。</p><p> send-catalog The send-catalog pragma instructs the server to transmit igotcards for every known artifact. This can help the client and serverto get back in synchronization after a prior protocol error. The&#34;--verily&#34; option to the  fossil sync command causesthe send-catalog pragma to be transmitted.</p><p> send-catalog send-catalog指示命令服务器为每个已知工件传输igotcard。这可以帮助客户端和服务器在先前的协议错误后恢复到同步状态。化石同步命令的“ --very”选项将导致发送目录编译指示。</p><p> uv-hash  HASH The uv-hash pragma is sent from client to server to provoke asynchronization of unversioned content. The  HASH is a SHA1hash of the names, modification times, and individual hashes of allunversioned files on the client. If the unversioned content hashfrom the client does not match the unversioned content hash on theserver, then the server will reply with either a &#34;pragma uv-push-ok&#34;or &#34;pragma uv-pull-only&#34; card followed by one &#34;uvigot&#34; card foreach unversioned file currently held on the server. The collectionof &#34;uvigot&#34; cards sent in response to a &#34;uv-hash&#34; pragma is calledthe &#34;unversioned catalog&#34;. The client will used the unversionedcatalog to figure out which files (if any) need to be synchronizedbetween client and server and send appropriate &#34;uvfile&#34; or &#34;uvgimme&#34;cards on the next HTTP request.</p><p> uv-hash哈希uv-hash编译指示从客户端发送到服务器，以引起未版本化内容的异步。哈希是客户端上所有未转换文件的名称，修改时间和单个哈希的SHA1哈希。如果来自客户端的未版本化内容哈希值与服务器上的未版本化内容哈希值不匹配，则服务器将通过“ pragma uv-push-ok”或“ pragma uv-pull-only”卡后跟一个“ uvigot”卡进行回复当前保存在服务器上的foreach未版本化文件。响应“ uv-hash”编译指示而发送的“ uvigot”卡的集合称为“未版本化目录”。客户端将使用unversioned目录，以确定客户端和服务器之间需要同步哪些文件（如果有），并在下一个HTTP请求上发送适当的“ uvfile”或“ uvgimme”卡。</p><p> If a client sends a uv-hash pragma and does not receive backeither a uv-pull-only or uv-push-ok pragma, that means that thecontent on the server exactly matches the content on the client andno further synchronization is required.</p><p> 如果客户端发送uv散列杂项并且没有收到uv-pull-only或uv-push-ok杂项，则意味着服务器上的内容与客户端上的内容完全匹配，并且不需要进一步的同步。</p><p> uv-pull-only A server sends the uv-pull-only pragma to the client in responseto a uv-hash pragma with a mismatched content hash argument. Thispragma indicates that there are differences in unversioned contentbetween the client and server but that content can only be transferredfrom server to client. The server is unwilling to accept content fromthe client because the client login lacks the &#34;write-unversioned&#34;permission.</p><p> 仅uv-pull服务器响应于内容哈希参数不匹配的uv-hash语法，服务器将uv-pull-pragma发送给客户端。此实用程序指示客户端和服务器之间的未版本化内容存在差异，但是只能将内容从服务器传输到客户端。服务器不愿接受来自客户端的内容，因为客户端登录缺少“未写版本”权限。</p><p> uv-push-ok A server sends the uv-push-ok pragma to the client in responseto a uv-hash pragma with a mismatched content hash argument. Thispragma indicates that there are differences in unversioned contentbetween the client and server and that content can only be transferredin either direction. The server is willing to accept content fromthe client because the client login has the &#34;write-unversioned&#34;permission.</p><p> uv-push-ok服务器将uv-push-ok编译指示发送给客户端，以响应内容哈希参数不匹配的uv-hash编译指示。此实用程序指示客户端和服务器之间的未版本化内容存在差异，并且内容只能沿任一方向传输。服务器愿意接受来自客户端的内容，因为客户端登录名具有“未写版本”权限。</p><p> A client sends the &#34;ci-lock&#34; pragma to the server to indicatethat it is about to add a new check-in as a child of theCHECKIN-HASH check-in and on the same branch as CHECKIN-HASH.If some other client has already indicated that it was alsotrying to commit against CHECKIN-HASH, that indicates that afork is about to occur, and the server will reply witha &#34;ci-lock-fail&#34; pragma (see below). Check-in locksautomatically expire when the check-in actually occurs, orafter a timeout (currently 24-hours but subject to change).</p><p> 客户端将“ ci-lock”编译指示发送到服务器，以指示它将作为CHECKIN-HASH签入的子级并在与CHECKIN-HASH相同的分支上添加新的签入。已经表明它也在尝试对CHECKIN-HASH进行提交，这表明将要发生分支，服务器将以“ ci-lock-fail”编译指示答复（请参阅下文）。当实际发生入住时或在超时之后（当前为24小时，但可能会更改），入住锁将自动过期。</p><p> When a server receives two or more &#34;ci-lock&#34; pragma messagesfor the same check-in but from different clients, the second asubsequent ci-lock will provoke a ci-lock-fail pragma in thereply to let the client know that it if continues with thecheck-in it will likely generate a fork. The LOGIN and MTIMEarguments are intended to provide information to the client tohelp it generate a more useful error message.</p><p>当服务器从同一客户端但从不同客户端收到两个或更多个“ ci-lock”编译指示消息时，第二个后续ci-lock将在答复中引发ci-lock-fail编译指示，以使客户端知道它是否继续签入时可能会产生一个叉子。 LOGIN和MTIME参数旨在向客户端提供信息，以帮助客户端生成更有用的错误消息。</p><p> A client sends the &#34;ci-unlock&#34; pragma to the server aftera successful commit. This instructs the server to releaseany lock on any check-in previously held by that client.The ci-unlock pragma helps to avoid false-positive lock warningsthat might arise if a check-in is aborted and then restartedon a branch.</p><p> 成功提交后，客户端会将“ ci-unlock”编译指示发送到服务器。这指示服务器释放对该客户端先前持有的任何签入的任何锁定。ci-unlock编译指示有助于避免如果中止签入然后在分支上重新启动时可能出现的假阳性锁定警告。</p><p>  Any card that begins with &#34;#&#34; (ASCII 0x23) is a comment card andis silently ignored.</p><p>  任何以“＃”（ASCII 0x23）开头的卡都是注释卡，并且会被忽略。</p><p>  If the server discovers anything wrong with a request, it generatesan error card in its reply. When the client sees the error card,it displays an error message to the user and aborts the syncoperation. An error card looks like this:</p><p>  如果服务器发现请求有任何问题，则会在其回复中生成一个错误卡。当客户端看到错误卡时，它将向用户显示错误消息并中止同步操作。错误卡如下所示：</p><p>  The error message is English text that is encoded in order tobe a single token.A space (ASCII 0x20) is represented as &#34;\s&#34; (ASCII 0x5C, 0x73). Anewline (ASCII 0x0a) is &#34;\n&#34; (ASCII 0x6C, x6E). A backslash(ASCII 0x5C) is represented as two backslashes &#34;\\&#34;. Apart fromspace and newline, no other whitespace characters nor anyunprintable characters are allowed inthe error message.</p><p>  错误消息是英语文本，被编码为单个令牌。空格（ASCII 0x20）表示为“ \ s”（ASCII 0x5C，0x73）。换行符（ASCII 0x0a）为“ \ n”（ASCII 0x6C，x6E）。反斜杠（ASCII 0x5C）表示为两个反斜杠“ \\”。除空格和换行符外，错误消息中不允许其他空格字符或任何不可打印的字符。</p><p> The server can also send a message card that also prints amessage on the client console, but which is not an error:  The message-text uses the same format as an error message.  If either the client or the server sees a card that is notdescribed above, then it generates an error and aborts.</p><p> 服务器还可以发送消息卡，该消息卡还可以在客户端控制台上打印消息，但这不是错误：消息文本使用与错误消息相同的格式。如果客户端或服务器看到以上未描述的卡，则它将生成错误并中止。</p><p>  When a repository knows that an artifact exists and knows the ID ofthat artifact, but it does not know the artifact content, then it stores thatartifact as a &#34;phantom&#34;. A repository will typically create a phantom whenit receives an igot card for an artifact that it does not hold or when itreceives a file card that references a delta source that it does nothold. When a server is generating its reply or when a client isgenerating a new request, it will usually send gimme cards for everyphantom that it holds.</p><p>  当存储库知道工件存在并且知道该工件的ID，但不知道工件内容时，则将该工件存储为“幻像”。存储库通常会在收到其不持有的工件的仿卡或接收到引用不持有的增量源的文件卡时创建幻像。当服务器生成其答复或客户端生成新请求时，通常会为其所持有的每个幻像发送gimme卡。</p><p> A cluster is a special artifact that tells of the existence of otherartifacts. Any artifact in the repository that follows the syntactic rulesof a cluster is considered a cluster.</p><p>簇是一种特殊的人工制品，它可以说明其他人工制品的存在。存储库中遵循集群句法规则的任何工件都被视为集群。</p><p> A cluster is line oriented. Each line of a clusteris a card. The cards are separated by the newline (&#34;\n&#34;) character.Each card consists of a single character card type, a space, and asingle argument. No extra whitespace and no trailing or leadingwhitespace is allowed. All cards in the cluster must occur instrict lexicographical order.</p><p> 集群是面向行的。集群的每一行都是一张卡。这些卡用换行符（“ \ n”）分隔。每张卡均由单个字符卡类型，空格和单个参数组成。不允许有多余的空格，也不允许尾随或前导空格。群集中的所有卡必须按照严格的字典顺序出现。</p><p> A cluster consists of one or more &#34;M&#34; cards followed by a single&#34;Z&#34; card. Each M card holds an argument which is an artifact ID for anartifact in the repository. The Z card has a single argument which is thelower-case hexadecimal representation of the MD5 checksum of allpreceding M cards up to and included the newline character thatoccurred just before the Z that starts the Z card.</p><p> 群集由一个或多个“ M”卡，然后是单个“ Z”卡组成。每个M卡都有一个参数，该参数是存储库中伪影的伪影ID。 Z卡具有一个自变量，它是之前所有M卡的MD5校验和的小写十六进制表示，直到并包括在启动Z卡的Z之前发生的换行符。</p><p> Any artifact that does not match the specifications of a clusterexactly is not a cluster. There must be no extra whitespace inthe artifact. There must be one or more M cards. There must be asingle Z card with a correct MD5 checksum. And all cards mustbe in strict lexicographical order.</p><p> 完全不符合集群规范的任何工件都不是集群。工件中必须没有多余的空格。必须有一张或多张M卡。必须有正确的MD5校验和的单个Z卡。并且所有卡片必须严格按照字典顺序排列。</p><p>  Every repository maintains a table named &#34; unclustered&#34;which records the identity of every artifact and phantom it holds that is notmentioned in a cluster. The entries in the unclustered table canbe thought of as leaves on a tree of artifacts. Some of the unclusteredartifacts will be other clusters. Those clusters may contain other clusters,which might contain still more clusters, and so forth. Beginningwith the artifacts in the unclustered table, one can follow the chainof clusters to find every artifact in the repository.</p><p>  每个存储库都维护一个名为“未聚簇”的表，该表记录了集群中未提及的每个工件和幻影的身份。可以将未聚簇表中的条目视为人工制品上的叶子。某些非集群工件将是其他集群。这些群集可能包含其他群集，其中可能包含更多群集，依此类推。从未聚簇表中的工件开始，可以遵循集群链来查找存储库中的每个工件。</p><p>   A typical pull operation proceeds as shown below. Detailsof the actual implementation may very slightly but the gist ofa pull is captured in the following steps:</p><p>   典型的拉动操作如下所示。实际实现的细节可能会非常少，但是在以下步骤中可以了解到要点：</p><p> The server checks the login password and rejects the session ifthe user does not have permission to pull.</p><p> 如果用户没有拉权限，服务器将检查登录密码并拒绝会话。</p><p> If the number of entries in the unclustered table on the server isgreater than 100, then the server constructs a new cluster artifact tocover all those unclustered entries.</p><p>如果服务器上非集群表中的条目数大于100，则服务器将构造一个新的集群工件以覆盖所有那些非集群条目。</p><p>  The server sends igot cards for every artifact in its unclusteredtable that is not a phantom.</p><p>  服务器为它的非幻像表（不是幻像）中的每个工件发送Igot卡。</p><p>  The client creates a phantom for every igot card in the server replythat mentions an artifact that the client does not possess.</p><p>  客户端会为服务器答复中提到自己不具备的工件的每个智能卡创建一个幻像。</p><p> The client creates a phantom for the delta source of file cards whenthe delta source is an artifact that the client does not possess.</p><p> 当增量源是客户端不具备的工件时，客户端会为文件卡的增量源创建幻像。</p><p> These ten steps represent a single HTTP round-trip request.The first three steps are the processing that occurs on the clientto generate the request. The middle four steps are processingthat occurs on the server to interpret the request and generate areply. And the last three steps are the processing that theclient does to interpret the reply.</p><p> 这十个步骤代表一个HTTP往返请求。前三个步骤是在客户端上生成请求的处理。中间的四个步骤是在服务器上进行的处理，以解释请求并生成区域。最后三个步骤是客户端对回复进行解释的过程。</p><p> During a pull, the client will keep sending HTTP requestsuntil it holds all artifacts that exist on the server.</p><p> 在拉动期间，客户端将继续发送HTTP请求，直到它保留服务器上存在的所有工件。</p><p> Note that the server triesto limit the size of its reply message to something reasonable(usually about 1MB) so that it might stop sending file cards asdescribed in step (6) if the reply becomes too large.</p><p> 请注意，服务器尝试将其回复消息的大小限制在合理的范围内（通常约为1MB），以便如果回复太大，它可能会停止发送文件卡，如步骤（6）所述。</p><p> Step (5) is the only way in which new clusters can be created.By only creating clusters on the server, we hope to minimize theamount of overlap between clusters in the common configuration wherethere is a single server and many clients. The same synchronizationprotocol will continue to work even if there are multiple serversor if servers and clients sometimes change roles. The only negativeeffects of these unusual arrangements is that more than the minimumnumber of clusters might be generated.</p><p>步骤（5）是创建新集群的唯一方法。通过仅在服务器上创建集群，我们希望在具有单个服务器和许多客户端的通用配置中，最大程度地减少集群之间的重叠量。即使有多个服务器，或者服务器和客户端有时会更改角色，相同的同步协议也将继续起作用。这些异常安排的唯一负面影响是，可能会生成超过最小数量的群集。</p><p>  A typical push operation proceeds roughly as shown below. Aswith a pull, the actual implementation may vary slightly.</p><p>  典型的推动操作大致如下进行。随着拉动，实际的实现可能会略有不同。</p><p> The client sends file cards for any artifacts that it holds that havenever before been pushed - artifacts that come from local check-ins.</p><p> 客户端会发送文件卡，以获取从未保存过的任何工件（即来自本地签入的工件）。</p><p> If this is the second or later cycle in a push, then theclient sends file cards for any gimme cards that the server sentin the previous cycle.</p><p> 如果这是推送中的第二个或更晚的周期，则客户端将为服务器在上一个周期中发送的所有gimme卡发送文件卡。</p><p> The client sends igot cards for every artifact in its unclustered tablethat is not a phantom.</p><p> 客户端会为非幻像表中的非伪造表中的每个工件发送Igot卡。</p><p> The server checks the login and push cards and issues an error ifanything is amiss.</p><p> 如果出现任何问题，服务器将检查登录卡和推送卡并发出错误。</p><p>  The server creates phantoms for igot cards that mention artifacts itdoes not possess or for file cards that mention delta source artifacts thatit does not possess.</p><p>  服务器为提及它不拥有的工件的Igot卡或提及它不拥有的增量源工件的文件卡创建幻像。</p><p>  The client remembers the gimme cards from the server so that itcan generate file cards in reply on the next cycle.</p><p>客户端会记住服务器中的gimme卡，以便它可以在下一个周期生成文件卡作为答复。</p><p> As with a pull, the steps of a push operation repeat until theserver knows all artifacts that exist on the client. Also, as withpull, the client attempts to keep the size of the request fromgrowing too large by suppressing file cards once thesize of the request reaches 1MB.</p><p> 与拉取一样，重复推入操作的步骤，直到服务器知道客户端上存在的所有工件为止。同样，与拉时一样，一旦请求的大小达到1MB，客户端就会通过抑制文件卡来阻止请求的大小过大。</p><p>  A sync is just a pull and a push that happen at the same time.The first three steps of a pull are combined with the first five stepsof a push. Steps (4) through (7) of a pull are combined with steps(5) through (8) of a push. And steps (8) through (10) of a pullare combined with step (9) of a push.</p><p>  同步只是同时发生的一次拉动和一次推动。一次拉动的前三个步骤与一次推压的前五个步骤结合在一起。拉动的步骤（4）至（7）与推入的步骤（5）至（8）组合在一起。然后将拉杆的步骤（8）到（10）与推入的步骤（9）相结合。</p><p>  &#34;Unversioned files&#34; are files held in the repositorywhere only the most recent version of the file is kept rather thanthe entire change history. Unversioned files are intended to beused to store ephemeral content, such as compiled binaries of themost recent release. Unversioned files are identified by name and timestamp (mtime).Only the most recent version of each file (the version withthe largest mtime value) is retained. Unversioned files are synchronized using the fossil unversioned sync command. A schematic of an unversioned file synchronization is as follows: The client sends a &#34;pragma uv-hash&#34; card to the server. The argument to the uv-hash pragma is a hash of all filesnames, mtimes, and content hashes for the unversioned files held by the client.</p><p>  “未版本化的文件”是存储在存储库中的文件，仅保留文件的最新版本，而不是整个更改历史记录。未经版本控制的文件旨在用于存储临时内容，例如最新发行版的已编译二进制文件。未版本控制的文件通过名称和时间戳（mtime）进行标识。仅保留每个文件的最新版本（具有最大mtime值的版本）。使用化石unversioned sync命令同步未版本化的文件。未版本控制的文件同步的示意图如下：客户端向服务器发送“ pragma uv-hash”卡。 uv-hash pragma的参数是客户端持有的所有未版本化文件的所有文件名，mtimes和内容哈希的哈希。</p><p> If the unversioned content hash from the client matches the unversioned content hash on the server, then nothing needs to be done and the server no-ops. But if the hashes are different, then the server replies with either a uv-pull-only or a uv-push-ok pragma followed by uvigot cards for all unversioned files held on the server.</p><p> 如果来自客户端的未版本化内容哈希与服务器上的未版本化内容哈希匹配，则无需执行任何操作，并且服务器不操作。但是，如果哈希值不同，则服务器将对仅保留uv-pull或uv-push-ok编译指示进行响应，然后对存储在服务器上的所有未版本控制的文件进行uvigot卡答复。</p><p> The client examines the uvigot cards received from the server and determines which unversioned files need to be exchanged in order to bring the client and server into synchronization. The client then sends appropriate &#34;uvgimme&#34; or &#34;uvfile&#34; cards back to the server.</p><p> 客户端检查从服务器收到的uvigot卡，并确定需要交换哪些未版本控制的文件才能使客户端和服务器同步。然后，客户端将适当的“ uvgimme”或“ uvfile”卡发送回服务器。</p><p> The server updates its unversioned file store with received &#34;uvfile&#34; cards and answers &#34;uvgimme&#34; cards with &#34;uvfile&#34; cards in its reply.</p><p> 服务器使用收到的“ uvfile”卡更新其未版本控制的文件存储，并在答复中用“ uvfile”卡答复“ uvgimme”卡。</p><p> The last two steps might be repeated multipletimes if there is more unversioned content to be transferred than willfit comfortably in a single HTTP request.   The client sends one or more PUSH HTTP requests to the server. The request and reply content type is &#34;application/x-fossil&#34;.</p><p>如果要传输的未版本化内容比单个HTTP请求中所能容纳的内容多，那么最后两个步骤可能会重复多次。客户端向服务器发送一个或多个PUSH HTTP请求。请求和答复内容类型为“ application / x-fossil”。</p><p>       Repositories keep track of all artifacts that are not named in anycluster and send igot messages for those artifacts.</p><p>       存储库会跟踪anycluster中未命名的所有工件，并为这些工件发送igot消息。</p><p> Repositories keep track of all the phantoms they hold and sendgimme messages for those artifacts.</p><p> 存储库会跟踪它们持有的所有幻像，并为这些工件发送消息。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.fossil-scm.org/home/doc/trunk/www/sync.wiki">https://www.fossil-scm.org/home/doc/trunk/www/sync.wiki</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/scm/">#scm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>