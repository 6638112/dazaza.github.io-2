<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Apple M1，ARM / x86 Linux虚拟化和Boinc The Apple M1, ARM/x86 Linux Virtualization, and Boinc</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Apple M1, ARM/x86 Linux Virtualization, and Boinc<br/>Apple M1，ARM / x86 Linux虚拟化和Boinc </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-11 17:22:54</div><div class="page_narrow text-break page_content"><p>About  six months ago, I speculated a bit on what Apple might do with their upcoming (rumored at the time) ARM transition. Apple did it, has shipped hardware, and I’ve had a chance to play with for a while now. I’ve also, as is usual for me, gone down some weird paths - like ARM Linux virtualization, x86 Linux emulation, and BOINC in an ARM VM!</p><p>大约六个月前，我推测苹果公司将如何应对即将到来的（当时传闻的）ARM过渡。苹果公司做到了，已经交付了硬件，而且我现在有机会玩了一段时间。我也像往常一样走了一些怪异的道路-如ARM Linux虚拟化，x86 Linux仿真和ARM VM中的BOINC！</p><p> The fastest Linux machine I’ve  ever used is a hardware virtualized install on the Apple M1 - and this post covers how to do it!</p><p> 我使用过的最快的Linux机器是Apple M1上的硬件虚拟化安装-这篇文章介绍了如何做！</p><p>       While I don’t generally  make a habit of buying brand new, just-released hardware, I made an exception for the M1 and bought a M1 Mac Mini to replace an Intel Mac Mini (which had replaced a perfectly function 2014 iMac I’d still be running if the monitor hadn’t failed - the display assembly, used, cost $600 in not-cracked condition). The Intel one wasn’t doing most of what I wanted (to say the GPU sucked would be an understatement), I’ve been lusting after a mid-range ARM desktop for a long while, and the fact that things would be broken on it doesn’t bother me - it’s not a production machine for me, so I’m happy to run on the bleeding, slightly broken edge. It’s a common theme with ARM desktop use, especially 64-bit, so this is no different.</p><p>       虽然我通常不习惯购买刚发布的全新硬件，但我为M1买了个例外，并购买了M1 Mac Mini来代替Intel Mac Mini（我已经替换了功能完善的2014 iMac如果显示器没有发生故障，仍然可以运行-使用的显示器组件在未破裂的情况下售价为600美元）。英特尔公司并没有满足我的大部分要求（说GPU烂透了，这是一种轻描淡写的说法），我一直在追求中端ARM台式机很久了，而且事情会破裂。它不会打扰我-对我来说这不是生产机器，所以我很高兴在流血的，略微断裂的边缘上运行。这是ARM台式机使用的共同主题，尤其是64位，因此没有什么不同。</p><p> How is it? It’s  fast. It’s  really, really fast. Not just for the power - that’s amazing too, but simple, flat out, using it for stuff. It’s amazing. I figured it would be really good, but it’s beyond good, crossing into the “Yeah, I’ll call this magical…” realm. The fan almost never comes off idle, power consumption (I work in a solar office, remember?) is a rounding error, and it just does what I ask of it in a real hurry.</p><p> 如何？它很快。真的非常快。不仅是强大的功能-这也很棒，而且简单，平坦，可以将其用于其他用途。太奇妙了。我认为这真的很好，但是超越了它，超越了“是的，我称之为神奇……”的境界。风扇几乎永远不会闲置，功耗（我在太阳能办公室工作，还记得吗？）是一个舍入误差，它确实可以按我的要求快速完成。</p><p> I mean, it’ll even play Kerbal Space Program with pretty darn good graphics! That’s an x86 game with no native port yet, and it’s not exactly a CPU sipper!</p><p> 我的意思是，它甚至可以播放具有相当不错的图形的Kerbal Space Program！那是一个没有本机端口的x86游戏，也不完全是CPU吸盘！</p><p>      This does mean that, once again, Jeb ends up stuck places he’d probably rather not be stuck. Lock your staging, or a thumb twitch might just leave you 100m above Mun with no descent (or ascent!) stage left attached…</p><p>      这确实意味着杰布再次陷入了他可能宁愿不被卡住的地方。锁定舞台，否则拇指抽搐可能会使您离开Mun之上100m，而没有附加下降（或上升！）的舞台…</p><p>      Should you buy one of Apple’s M1 devices? Probably not - wait 6 months for the next round of hardware, and buy then. Most of the software ecosystem quirks will be worked out by then, and just about everything will work. For now, there are enough weird little broken corner cases that I’d suggest holding off unless you’re OK with that and want legitimately insane battery life and performance.</p><p>      您是否应该购买Apple的M1设备之一？可能不是-等待6个月以获取下一轮硬件，然后再购买。到那时，大多数软件生态系统的怪癖都将得到解决，并且几乎所有东西都将起作用。就目前而言，我建议您别无选择，除非您对此表示满意，并希望电池寿命和性能达到合理的水平，否则我建议您推迟一下。 </p><p>  Yes, yes, I  know, your overclocked AMD ThreadBlaster 7970XP, with enough threads, will build the kernel faster on 400W. All this performance is on about 30W, and this is their first pass at it. Just wait…</p><p>是的，是的，我知道，您超频的AMD ThreadBlaster 7970XP具有足够的线程数，可以在400W上更快地构建内核。所有这些性能都在30W左右，这是他们的第一遍。等等...</p><p>  We also have an answer now to the insane x86 translation performance (around 80% of native performance, give or take - and, yes, this does mean that the M1 runs x86 binaries faster than an awful lot of x86 hardware out there). I’ve messed around with running x86 binaries in emulation on ARM before, and got about 10% of native performance on a Rpi4. Painful. Apple’s Rosetta 2 gets a lot of benefit from being a pre-compiling translator (for most cases - it still has to interpret JIT type workloads), but most people figured that would get you to 50% - at best. The ARM memory model is so radically different from x86 that you end up sprinkling memory barriers everywhere to guarantee cross threaded consistency, and that really hurts performance.</p><p>  现在，我们对疯狂的x86转换性能也有一个答案（付出或付出大约是本机性能的80％，是的，这的确意味着M1运行x86二进制文件的速度比许多x86硬件要快）。之前，我已经在ARM上运行过x86二进制文件，并且在Rpi4上获得了大约10％的本机性能。痛苦。苹果的Rosetta 2可以从预编译翻译器中受益匪浅（在大多数情况下-它仍然必须解释JIT类型的工作负载），但是大多数人认为，充其量可以使您获得50％的收益。 ARM内存模型与x86根本不同，您最终会在各处散布内存障碍以确保跨线程一致性，这确实损害了性能。</p><p> The issue is that on x86, if you write memory addresses in a certain sequence,  all other cores will see the writes in the same sequence. If you write some blob of data and then write the “Ready!” flag, by the time other cores see the flag change value, you can be certain that the blob of data has been written. ARM has no such guarantees without explicit (and slow) memory barrier instructions, and this is why the x86 emulation on ARM Windows was painful - guaranteeing correctness of a translated binary on a weaker memory model is slow.</p><p> 问题是在x86上，如果您按特定顺序写入内存地址，则所有其他内核将看到相同顺序的写入。如果您写入一些数据，然后写入“ Ready！”标记，等到其他内核看到标记更改值时，就可以确定已经写入了数据blob。没有明确的（且缓慢的）内存屏障指令，ARM无法提供此类保证，这就是为什么ARM Windows上的x86仿真很痛苦的原因-保证较弱的内存模型上已翻译二进制文件的正确性很慢。</p><p> As it turns out, Apple  isn’t doing it purely in software - they have  Total Store Ordering support in their hardware! When the M1 runs a translated x86 binary, the OS just tells the chip, “Hey, use x86 memory ordering for this thread.” Things built natively for ARM can take advantage of the performance gains of the memory reordering, and things that requires strict ordering get strict ordering. It’s a very, very clever way to totally bypass the memory ordering issues with translated binaries, and it’s not a thing in any other ARM chip on the planet (I’d say yet, but I really don’t think this will become a popular thing to implement - perks of Apple building their own silicon).</p><p> 事实证明，Apple并不仅仅是在软件方面做到这一点-他们的硬件中拥有Total Store Ordering支持！当M1运行翻译后的x86二进制文件时，操作系统只是告诉芯片：“嘿，为此线程使用x86内存排序。”本机为ARM构建的事物可以利用内存重新排序的性能提升，而需要严格排序的事物可以得到严格排序。这是一种非常，非常聪明的方法，可以完全绕开翻译后的二进制文件的内存排序问题，这在星球上的任何其他ARM芯片中都不是问题（我会说，但我真的不认为这会成为流行实施的东西-苹果公司建立自己的芯片的特权）。</p><p>  Now, to the core of the post: Building qemu to run hardware virtualized ARM Linux! I’m starting with  these excellent instructions as a guide, but I’ve got some extra patches thrown in (because it doesn’t run x86 emulation my M1 with 11.1), and I’m doing a few other things in the process.</p><p>  现在，发布的核心内容是：构建qemu以运行硬件虚拟化的ARM Linux！我从这些出色的说明开始作为指导，但是我还抛出了一些额外的补丁程序（因为它无法在我的M1和11.1上运行x86仿真），并且在此过程中我还要做其他一些事情。</p><p> You’ll need XCode installed, and we’ll be using  homebrew to install some of the prerequisites for building qemu. Plus some patches to the source, and… it’s all good fun, I promise! What I don’t promise is that this will work perfectly for you, though I’ll try!</p><p> 您需要安装XCode，并且我们将使用自制软件安装构建qemu的一些先决条件。加上源代码的一些补丁，……我保证，这一切都很好玩！我不保证这会完全适合您，尽管我会尽力！</p><p> Yes, I know Parallels has a tech preview out, and you still can’t change the resolution of a Linux guest. If you’re fine with 1024x768, it certainly works, but… we can do better with open source!</p><p> 是的，我知道Parallels可以进行技术预览，您仍然无法更改Linux guest虚拟机的分辨率。如果您可以使用1024x768，则可以使用它，但是…我们可以使用开源做得更好！ </p><p>  You’ll need the XCode command line tools (gcc and such) to build this, so if you don’t already have those installed, go ahead and install XCode from the App Store. It’s huge.</p><p>您将需要XCode命令行工具（gcc等）来构建它，因此，如果尚未安装，请继续从App Store安装XCode。很大。</p><p> I understand you can also install them from the command line, if you don’t want the full install, by running  xcode-select --install. That’s the first thing I do with any Mac, so I had them laying around. You may have to agree to some license terms as well - it’s been a while since I had a clean install.</p><p> 据了解，如果您不想完全安装，也可以通过运行xcode-select --install从命令行安装它们。这是我使用任何Mac电脑所做的第一件事，因此我将它们放到了周围。您可能还必须同意一些许可条款-自从我进行全新安装以来已经有一段时间了。</p><p> If you use the normal Homebrew install path, you’ll get x86 Homebrew, running under Rosetta. This is fine for most use cases, and it certainly  works better than the ARM Homebrew (half the code won’t build under ARM), but it’s no good for ARM native dependencies, and we’re going to be building ARM native qemu.</p><p> 如果您使用正常的Homebrew安装路径，则将获得在Rosetta下运行的x86 Homebrew。这对大多数用例来说都很好，并且肯定比ARM Homebrew更好（一半代码不会在ARM下构建），但对ARM本机依赖项没有好处，我们将构建ARM本机qemu。</p><p> If you rely on x86 homebrew, well… uh… fix the ARM stuff that doesn’t build? Or install to a different directory, I suppose. I have no great advice on parallel Homebrew installs, sorry.</p><p> 如果您依靠x86自制软件，那么……呃……修复没有构建的ARM东西？我想还是要安装到另一个目录。抱歉，我对并行安装Homebrew没有很好的建议。</p><p> cd ~mkdir homebrew &amp;&amp; curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C homebrewsudo mv homebrew /opt/homebrewecho &#39;export PATH=&#34;/opt/homebrew/bin:$PATH&#34;&#39; &gt;&gt; ~/.zshrcsource ~/.zshrcbrew update</p><p> cd〜mkdir自酿＆amp;＆amp; curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C homebrewsudo mv homebrew / opt / homebrewecho＆＃39; export PATH =＆＃34; / opt / homebrew / bin：$ PATH＆＃34;＆＃39; ＆gt;＆gt; 〜/ .zshrcsource〜/ .zshrcbrew更新</p><p> This will run some git fetches, some builds, and you should generally have a working brew install. Like XCode, this may take a while, depending on your internet connection. My ISPs have been sucking more than usual lately, and I don’t keep a local mirror of Homebrew, so… coffee time.</p><p> 这将运行一些git fetch，一些构建，并且您通常应该有一个有效的brew安装。与XCode一样，这可能需要一段时间，具体取决于您的Internet连接。最近，我的ISP比平时吸吮更多，而且我没有本地制作Homebrew的镜像，所以……喝咖啡。</p><p>    Next step: we’re going to download the qemu source, check out the proper version, apply a couple patches, and build it!</p><p>    下一步：我们将下载qemu源码，签出正确的版本，应用几个补丁并进行构建！ </p><p> The  first patch series is the core of the updates - it adds  Hypervisor.framework support (Apple’s recent “So, you wanna do hardware virtualization without a kernel module…” framework), adds the ability to sign the output binary to allow it to use that, and various other things related to Apple Silicon support.</p><p>第一个补丁程序系列是更新的核心-它增加了Hypervisor.framework支持（Apple最近的“所以，您想在没有内核模块的情况下进行硬件虚拟化……”框架），增加了对输出二进制文件进行签名以使其能够使用的功能。以及与Apple Silicon支持有关的各种其他事项。</p><p> The  second patch series isn’t actually required to run hardware virtualization, but if you wanted to mess around with the (somewhat awful, but still usable) performance of x86 VMs on the M1, you’ll need this. Apple Silicon prevents memory pages from being both writable and executable at the same time, and this adds the toggles to handle things properly so the JIT engine can work.</p><p> 运行硬件虚拟化实际上并不需要第二个修补程序系列，但是如果您想弄清楚M1上x86 VM的（有点糟糕，但仍然可以使用）性能，则需要此。 Apple Silicon防止内存页面同时可写和可执行，并且这添加了切换开关以正确处理事情，以便JIT引擎可以工作。</p><p> If you  don’t apply the second patches, and you try to run x86 system emulation, you’ll get the exceedingly unhelpful error “Could not allocate dynamic translator buffer” when you try to run it.</p><p> 如果您没有应用第二个补丁，并且尝试运行x86系统仿真，则在尝试运行它时会收到极其无用的错误“无法分配动态翻译器缓冲区”。</p><p> And, of course, if you’re not interested in x86 emulation, you can skip the  x86_64-softmmu and  i386-softmmu options in the target-list for configure.</p><p> 而且，当然，如果您对x86仿真不感兴趣，则可以跳过目标列表中的x86_64-softmmu和i386-softmmu选项进行配置。</p><p> git clone https://git.qemu.org/git/qemu.gitgit checkout master -b wip/hvfcurl &#39;https://patchwork.kernel.org/series/400619/mbox/&#39;|git am --3waycurl &#39;https://patchwork.kernel.org/project/qemu-devel/patch/ [email protected]/mbox/&#39;|git am --3waymkdir buildcd build../configure --target-list=aarch64-softmmu,x86_64-softmmu,i386-softmmu --enable-cocoamake -j 8</p><p> git clone https://git.qemu.org/git/qemu.gitgit结帐主-b wip / hvfcurl＆＃39; https：//patchwork.kernel.org/series/400619/mbox/&#39; | git是--3waycurl＆＃39; https：//patchwork.kernel.org/project/qemu-devel/patch/ [受电子邮件保护] / mbox /＆| git am --3waymkdir buildcd build ../ configure- -target-list = aarch64-softmmu，x86_64-softmmu，i386-softmmu --enable-cocoamake -j 8</p><p> Sit back, relax, wait… actually, not very long, this system is blazing fast on all 8 cores, and you should have some qemu binaries!</p><p> 坐下来，放松，等待……实际上，时间不长，该系统在所有8个内核上都运行很快，并且您应该有一些qemu二进制文件！</p><p>  There are plenty of ways to install the ARM version of Ubuntu, but there’s a convenient desktop build now at  https://cdimage.ubuntu.com/focal/daily-live/current/ - grab  focal-desktop-arm64.iso. You do NOT want the ‘amd64’ version - make sure you get ‘arm64’ or it won’t work!</p><p>  安装ARM版本的Ubuntu的方法有很多，但是现在可以通过https://cdimage.ubuntu.com/focal/daily-live/current/便捷地进行桌面构建-抓住focus-desktop-arm64.iso。您不希望使用“ amd64”版本-确保获得“ arm64”版本，否则将无法正常运行！ </p><p> You also need a EFI blob built for ARM. The instructions I’m working from cover how to build it with your own ARM VM (and include a link to some built ones), but I’ve also uploaded one for you, if you happen to want it:  QEMU_EFI.fd</p><p>您还需要为ARM构建的EFI Blob。我正在按照的说明介绍如何使用自己的ARM VM进行构建（并包括指向一些已构建的ARM的链接），但是如果您碰巧需要的话，我还为您上传了一个：QEMU_EFI.fd</p><p> While you could just run the live ISO, there’s no fun in that - create a disk image for the install (you’ll be doing this from the qemu/build directory you were just in, and stick the image somewhere fast). I’ll assume you’ve put the QEMU_EFI.fd file in the same directory.</p><p> 尽管您可以运行实时ISO，但这样做没有任何乐趣-为安装创建磁盘映像（您可以从刚刚进入的qemu / build目录中执行此操作，然后将映像快速粘贴到某处）。我假设您已将QEMU_EFI.fd文件放在同一目录中。</p><p>   Now, let’s light up a VM from the installer CD! It’s Linux, so we’re just using  all the virtio devices. Virtio is a way for hypervisors and guests to say, “Look, let’s skip all the pretending that you’re talking to real hardware, which I’m pretending to be. I’m a hypervisor, you know I am, so just tell me what you want me to do and I’ll do it.” It’s far faster than any sort of hardware emulation (on less CPU too), and you should definitely use it. Because we’re running a Linux guest, it’ll just do the right thing!</p><p>   现在，让我们从安装程序CD中点亮虚拟机！它是Linux，因此我们仅使用所有virtio设备。 Virtio是虚拟化管理程序和来宾使用的一种方式，“您看，让我们跳过所有您在与真实硬件（我是假装）交谈的假装。我是系统管理程序，您知道我是，所以只要告诉我您想让我做什么，我会做的。”它比任何类型的硬件仿真都快得多（也使用更少的CPU），因此您绝对应该使用它。因为我们正在运行Linux guest虚拟机，所以它将做正确的事！</p><p> If you just copy-paste this, it won’t work. Set your file paths properly. This sets up a 4 core VM with 4GB of RAM, which should work even if you’re on an 8GB system.</p><p> 如果您只复制粘贴此内容，则将无法使用。正确设置文件路径。这将设置一个具有4GB RAM的4核VM，即使您使用的是8GB系统，它也可以正常工作。</p><p> ./qemu-system-aarch64 \ -serial stdio \ -M virt,highmem=off \ -accel hvf \ -cpu cortex-a72 \ -smp 4 \ -m 4096 \ -bios /path/to/QEMU_EFI.fd -device virtio-gpu-pci \ -display default,show-cursor=on \ -device qemu-xhci \ -device usb-kbd \ -device usb-tablet \ -device intel-hda \ -device hda-duplex \ -drive file=/path/to/Ubuntu.qcow2,if=virtio,cache=writethrough \ -cdrom /path/to/focal-desktop-arm64.iso</p><p> ./qemu-system-aarch64 \-串行stdio \ -M virt，highmem = off \ -accel hvf \ -cpu cortex-a72 \ -smp 4 \ -m 4096 \ -bios /path/to/QEMU_EFI.fd -device virtio-gpu-pci \-显示默认值，show-cursor = on \ -device qemu-xhci \ -device usb-kbd \ -device usb-tablet \ -device intel-hda \ -device hda-duplex \ -drive file = /path/to/Ubuntu.qcow2,if=virtio,cache=writethrough \ -cdrom /path/to/focal-desktop-arm64.iso</p><p> By the way, if you’ve not messed with zsh too much before Apple made it the default, you can use the up/down arrows to edit a multi-line command like this! Super nice!</p><p> 顺便说一句，如果您在Apple使其不成为默认设置之前对zsh的了解不多，则可以使用向上/向下箭头编辑这样的多行命令！超好！</p><p> If all goes well, you should get a quick EFI screen, then a boot loader! If not, check the serial output on the console, because it’s probably telling you something important.</p><p> 如果一切顺利，您应该快速获得EFI屏幕，然后是引导加载程序！如果不是，请检查控制台上的串行输出，因为它可能告诉您一些重要的信息。 </p><p>      Go ahead and pick “Install Ubuntu” - and you should rapidly find yourself, very soon, in what should be a very familiar seeming installer environment. At some point during the boot process, you’ll probably get a pop-up asking about network access - allow it, if you want network access (you almost certainly do).</p><p>继续并选择“安装Ubuntu”-您应该很快在一个看起来非常熟悉的安装程序环境中迅速找到自己。在启动过程中的某个时候，您可能会弹出一个询问网络访问的弹出窗口-如果您想进行网络访问，则允许这样做（几乎可以肯定）。</p><p> qemu is occasionally a bit weird with actually noticing the mouse. If it seems like the mouse isn’t working in the VM (you try to interact with the VM and nothing happens), try switching to another window and back - it should pick it up.</p><p> qemu在实际注意到鼠标时有时会有些奇怪。如果看起来鼠标在VM中无法正常工作（您尝试与VM交互但没有任何反应），请尝试切换到另一个窗口然后再返回-它应该将其拾起。</p><p> Install Ubuntu. You probably know how to do this if you’re this far into a post about VMs on Apple Silicon.</p><p> 安装Ubuntu。如果您深入了解有关Apple Silicon上VM的文章，则可能知道如何执行此操作。</p><p>       After it’s done, update packages. For subsequent launches, you can skip the  -cdrom line, and be on your way! I’ve had poor luck with VMs rebooting in this setup - it seems far more reliable to just shut them down and relaunch.</p><p>       完成后，更新软件包。对于后续的启动，您可以跳过-cdrom行，然后开始执行！我在此设置下重新启动了虚拟机，但运气不佳-仅关闭虚拟机并重新启动似乎更加可靠。</p><p>  Disable monitor sleep in your guest. It’s under Settings -&gt; Power, Blank Screen. Set it to “Never.” I’ll probably lock the VM up if it tries for reasons I don’t fully understand.</p><p>  禁用访客中的监视器睡眠。在“设置”下->电源，黑屏。将其设置为“从不”。如果我出于无法完全理解的原因尝试运行该虚拟机，则可能会锁定它。</p><p> The first thing most people will do is try to set a sane resolution, and there are plenty of them available. However, the one I really like (2560x1440) is missing for… reasons? No matter, it’s easy to add custom resolutions under Linux in qemu (this works in KVM too).</p><p> 大多数人会做的第一件事是尝试设置合理的分辨率，并且有很多可用的方法。但是，我真正喜欢的（2560x1440）缺少是出于……原因？没关系，在qemu中的Linux下添加自定义分辨率很容易（这也适用于KVM）。</p><p>      Just create a magic little script called  setres.sh with the following contents and call it thusly:  ./setres.sh 2560 1440</p><p>      只需创建一个带有以下内容的神奇小脚本setres.sh并对其进行调用：./setres.sh 2560 1440 </p><p> #!/bin/bashMODELINE=`cvt $1 $2 | tail -n 1 | sed &#34;s/Modeline//&#34; | sed &#39;s/&#34;//g&#39;`MODENAME=`cvt $1 $2 | tail -n 1 | cut -d&#39;&#34;&#39; -f 2``xrandr --newmode $MODELINE``xrandr --addmode Virtual-1 $MODENAME``xrandr --output Virtual-1 --mode $MODENAME`</p><p>/ bin / bashMODELINE =`cvt $ 1 $ 2 |尾-n 1 | sed /＃Model //＆＃34; | sed＆＃39; // g＆＃39;`MODENAME =`cvt $ 1 $ 2 |尾-n 1 |切-d＆＃39;＆＃34;＆＃39; -f 2``xrandr --newmode $ MODELINE''xrandr --addmode虚拟-1 $ MODENAME``xrandr-输出虚拟-1 --mode $ MODENAME`</p><p> If you fullscreen the VM, I’m not actually sure how to get it de-fullscreened either. Toss it on another display… this isn’t actually an issue for how I use my VMs. I like them full screened, on another display. When in doubt, three fingers up (or F3) ought to get you some sanity.</p><p> 如果您对虚拟机进行全屏显示，则实际上也不确定如何对其进行全屏显示。将其扔到另一个显示器上……这实际上并不是我如何使用虚拟机的问题。我喜欢它们在另一个显示器上全屏显示。如有疑问，请用三个手指（或F3）抬起头来。</p><p>       So, we’ve got this Linux VM. Is it actually fast? Can you do real work with it?</p><p>       因此，我们有了这个Linux VM。真的快吗？你能用它做真正的工作吗？</p><p>  I’m not going to go through a full benchmark suite here - I just don’t find it that interesting when this is one of the more-benchmarked CPUs on the planet. But, I’ll toss Speedometer at both (Chrome on OS X, Chrome on Linux). Which is which?</p><p>  我不会在这里介绍完整的基准测试套件-当它是这个星球上性能更高的CPU之一时，我只是觉得不那么有趣。但是，我会同时抛弃速度计（在OS X上使用Chrome，在Linux上使用Chrome）。哪一个</p><p>      Actually, you’re wrong. Chrome on Linux, in a VM, is  faster than Chrome in OS X, by a non-trivial margin, and also pegs the “speedometer” gauge. Take from that what you will.</p><p>      其实你错了在VM中，Linux上的Chrome的运行速度比OS X中的Chrome快很多，而且还与“速度计”指标挂钩。从中得到什么。</p><p> For reference, a Raspberry Pi 4 (overclocked to 2GHz) gets about 22, and my office NUC, which is hardly a slouch, gets about 75.</p><p> 作为参考，Raspberry Pi 4（超频至2GHz）大约为22，而我的办公室NUC大约为75。</p><p> And in something less synthetic and more practical, the ARM VM will build (including image processing - I have a lot of that) my blog in 48 minutes, vs 62 minutes for a VM on an AMD 3700X (single threaded in both cases).</p><p> 而且，ARM虚拟机将在48分钟内构建我的博客（包括图像处理，我有很多），而在AMD 3700X上虚拟机则为62分钟（两种情况下都是单线程的），因此，它们的合成性和实用性较低。 </p><p>  Actually, I lied about benchmarks. I do like memory bandwidth an awful lot, and one of the things that the M1 is supposedly really, really good at is memory bandwidth. Is it? I’m going to use the standard dinky little memory bandwidth tester I use ( mbw) on a couple systems I use regularly, and then this Linux VM.</p><p>实际上，我对基准撒谎了。我确实非常喜欢内存带宽，而M1确实非常擅长的事情之一就是内存带宽。是吗？我将在经常使用的几个系统上使用标准的dinky小内存带宽测试仪（mbw），然后在此Linux VM上使用。</p><p> I’ll just run  mbw 1024 and graph the average for each of the memcpy types…</p><p> 我将运行mbw 1024并绘制每种memcpy类型的平均值…</p><p>      Well then. The 6770HQ has eDRAM, the 3700X I’ll give some leeway to because it’s running slower ECC, the i7-77070K is a decent box, and the  VM on a Mac Mini absolutely slaughters them in this test, peaking at 41.2GB/s! It’s a dumb little test, not trying to be terribly clever, because most software isn’t, and it’s just staggering how much faster memory is on this system.</p><p>      好吧。 6770HQ具有eDRAM，3700X具有一定的余地，因为它运行的ECC速度较慢，i7-77070K是一个不错的盒子，而Mac Mini上的VM在此测试中绝对会杀死它们，峰值为41.2GB / s！这是一个愚蠢的小测试，并不是要非常聪明，因为大多数软件都不是，它只是使该系统上的内存速度增加了很多。</p><p>    Fire up the BOINC manager, add  [email protected] (I know they have ARM workunits), and watch your system go! Subject to the quirks and such mentioned below about CPU scheduling…</p><p>    启动BOINC管理器，添加[受电子邮件保护]（我知道它们具有ARM工作单元），然后观察系统运行情况！遵循以下有关CPU调度的怪癖之类的内容……</p><p> I’ve heard that you can run BOINC with Rosetta2 (different Rosetta, amusingly), and it has problems with memory bloat from the x86 translation layer. No such problems running ARM natively!</p><p> 我听说您可以使用Rosetta2（有趣的是不同的Rosetta）运行BOINC，并且x86转换层的内存膨胀有问题。在本地运行ARM时没有此类问题！</p><p>      If you really want to let things rip, launch your vm with  -smp 8 so it can access all 8 CPUs! As long as the VM window is visible and the screen isn’t asleep and… etc.</p><p>      如果您真的想让事情变得糟透了，请使用-smp 8启动您的虚拟机，以便它可以访问所有8个CPU！只要可见VM窗口且屏幕未处于睡眠状态等等。</p><p>        One of the interesting things I noticed here is that CPU scheduling, on the M1s, is really, really aggressive about pushing tasks onto the “efficiency” cores (Core 1-4). If the VM window is visible, it’ll schedule threads on Core 5-8 (the Performance cores), but if you minimize it, or your screen goes to sleep, they get unloaded and everything is shoved over on the efficiency cores - even an 8 core VM. You can see this easily with the CPU history window from Activity Monitor.</p><p>        我在这里注意到的有趣的事情之一是，在M1上，CPU调度对于将任务推送到“高效”内核（内核1-4）上确实非常积极。如果VM窗口可见，它将在Core 5-8（性能内核）上调度线程，但是如果将其最小化，或者屏幕进入睡眠状态，它们将被卸载，并且所有内容都将移交给效率内核-甚至8核心VM。您可以通过“活动监视器”中的“ CPU历史记录”窗口轻松看到这一点。 </p><p> With a 4 CPU VM running BOINC, and the display visible, the compute is on the performance cores (as expected). It’s a CPU bound task, thrashing away hard. Performance cores make sense.</p><p>在运行BOINC的4 CPU VM且显示可见的情况下，计算位于性能核心上（如预期的那样）。这是一项与CPU绑定的任务，很难完成。性能核心很有意义。</p><p> But shortly after minimizing it, look what happens! I obviously don’t care about performance on a minimized task, so… bazoop! Over it goes to the efficiency cores.</p><p> 但是在将其最小化后不久，看看会发生什么！我显然不关心最小化任务的性能，所以……bazoop！最重要的是效率核心。</p><p>      If you give the VM 8 cores, it will stay scheduled across all 8 cores while the machine is up and running, as one might hope. However, as soon as you lock the screen, well…</p><p>      如果您为VM提供8个核心，那么正如机器可能会希望的那样，它将在计算机启动并运行时在所有8个核心上保持调度。但是，只要锁定屏幕，就可以…</p><p>      Everything gets pushed over to the efficiency cores. You’ll see the same behavior if the VM is minimized.</p><p>      一切都推到了效率核心。如果将VM最小化，您将看到相同的行为。</p><p> Now, I don’t mind so much - my office runs on battery at night, so this is fine with me. But it’s a weird behavior, is certainly inefficient for running a lot of compute, and likely relates to Apple’s application QoS parameters. I expect there’s an easy way to tell OS X, “Hey, go do this thing on the performance cores.” I’m just not exactly sure what it is…</p><p> 现在，我不太介意-我的办公室在晚上用电池供电，所以我觉得很好。但这是一种怪异的行为，对于运行大量计算而言肯定是低效的，并且可能与Apple的应用QoS参数有关。我希望有一种简单的方法可以告诉OS X：“嘿，在性能核心上执行此操作。”我不确定这是什么...</p><p> But if you’re wondering how they get such amazing battery life on their laptops? Here’s a major hint - it simply runs almost everything on the efficiency cores if it can. And it seems to work just fine! Unless, say, you’re on AC power and want stuff to just run. I’ll have to work on that.</p><p> 但是，如果您想知道他们如何在笔记本电脑上获得如此惊人的电池寿命？这是一个主要提示-如果可以的话，它几乎可以在效率核心上运行几乎所有内容。而且似乎工作正常！除非您使用交流电源，否则不要运行任何东西。我将不得不对此进行处理。</p><p>  With the second set of patches applied, you can also run an x86 VM in qemu. We can skip a few of the parameters for x86, and I’m just running a LiveCD here to make my point, but you can add your disk if you really feel the need.</p><p>  应用第二套补丁程序后，您还可以在qemu中运行x86 VM。我们可以跳过x86的一些参数，我只是在这里运行LiveCD来说明我的观点，但是如果您确实有需要，可以添加磁盘。 </p><p> ./qemu-system-x86_64 \ -serial stdio \ -M q35 \ -cpu qemu64 \ -smp 1 \ -m 4096 \ -device virtio-gpu-pci \ -display default,show-cursor=on \ -device qemu-xhci \ -device usb-kbd \ -device usb-tablet \ -device intel-hda \ -device hda-duplex \ -cdrom /path/to/ubuntu-20.04-desktop-amd64.iso</p><p>./qemu-system-x86_64 \-串行stdio \ -M q35 \ -cpu qemu64 \ -smp 1 \ -m 4096 \ -device virtio-gpu-pci \-显示默认值，show-cursor = on \ -device qemu- xhci \-设备usb-kbd \-设备usb平板电脑\-设备intel-hda \-设备hda-duplex \ -cdrom /path/to/ubuntu-20.04-desktop-amd64.iso</p><p>  If you want to get “proper” SMP, you can add the following and change your  -smp 1 to  -smp 4 :</p><p>  如果要获得“适当的” SMP，则可以添加以下内容，并将-smp 1更改为-smp 4：</p><p>   qemu-system-x86_64: --accel tcg,thread=multi: warning: Guest expects a stronger memory ordering than the host providesThis may cause strange/hard to debug errors</p><p>   qemu-system-x86_64：--accel tcg，thread = multi：警告：来宾期望比主机提供更强的内存排序这可能会导致奇怪/难以调试的错误</p><p>  There ought to be be some way to request TCO as a userspace process to deal with this - it would certainly be a good use of it. There’s a way to use the TSO Enabler mentioned earlier to do it, but I just don’t feel like building a kernel module for something I’m not going to use regularly.</p><p>  应该有某种方法可以请求将TCO作为处理此问题的用户空间流程-这肯定是一种很好的用法。有一种方法可以使用前面提到的TSO启动器来实现，但是我只是不想为我不打算经常使用的东西构建内核模块。</p><p> But it’s a legitimate x86 VM, running Ubuntu 20.04 Desktop, and while I’m not going to call it “fast,” it’s not utterly unusable either. I mean, you  shouldn’t use it, but you could.</p><p> 但这是一台合法的x86 VM，运行Ubuntu 20.04 Desktop，尽管我不会将其称为“快速”，但也并非完全无法使用。我的意思是，您不应使用它，但可以使用。</p><p>      QEMU is doing JIT - Just In Time compilation. It translates the x86 operations into ARM operations, emulating complex things as needed, and then runs those. So performance isn’t going to be anywhere close to native. Browser benchmarks are a double whammy, because the browser is doing JIT for Javascript, which then has to be run through  another JIT for the x86 translation, but they do run and complete. It runs, just not terribly quickly. It’s generally comparable to my old netbook Clank, or a Raspberry Pi 3, but performance really varies depending on the task. Definitely not something you’d want to use heavily.</p><p>      QEMU正在执行JIT-即时编译。它将x86操作转换为ARM操作，根据需要模拟复杂的事物，然后运行它们。因此，性能不会接近原生。浏览器基准测试是双重打击，因为浏览器正在执行Javascript的JIT，然后必须通过另一个JIT运行x86转换，但是它们确实可以运行并完成。它可以运行，只是速度不是很快。它通常可以与我的旧上网本Clank或Raspberry Pi 3相提并论，但性能确实因任务而异。绝对不是您想大量使用的东西。</p><p>             But then hangs - either here, or on a black screen with a frozen mouse cursor. The CPUs are still doing  something based on CPU utilization on the host, but the mouse is frozen and a bit of casual poking doesn’t resolve the issue.</p><p>             但是随后挂起-在这里，或者在黑屏上显示冻结的鼠标光标。 CPU仍根据主机上的CPU利用率执行某些操作，但是鼠标被冻结了，有些随意的拨动不能解决问题。 </p><p>  Of course, you  can run ARM Windows 10, if you want, and are willing to fiddle around with drivers and such - I just don’t find such a thing terribly interesting at the moment. But this build ought to do it, and the instructions I’m working from contain information on how to make that work! But, based on other reports, the Win10 ARM build runs fine in a VM, and it will run x86 applications well enough if you really want.</p><p>当然，如果愿意，您可以运行ARM Windows 10，并且愿意摆弄驱动程序之类的东西-我暂时不觉得这件事非常有趣。但是，此版本应该可以做到，而我正在按照的说明中包含有关如何实现此目的的信息！但是，根据其他报告，Win10 ARM构建可以在VM中正常运行，并且如果您确实需要，它将可以很好地运行x86应用程序。</p><p>   Linux, in hardware virtualization on the M1, is fast. Like, vastly, hugely, mind-bogglingly fast. Absolutely useful for anything that “needs Linux” on a M1, and very likely the fastest Linux machine you can get right now for single threaded work.</p><p>   在M1的硬件虚拟化中，Linux速度很快。就像，巨大，巨大，令人难以置信的快速。对于M1上“需要Linux”的任何事物绝对有用，而且很可能是您现在可以获得的用于单线程工作的最快的Linux计算机。</p><p>    You  can run a full x86 system on the M1 - just, very slowly right now. And you probably shouldn’t.</p><p>    您可以在M1上运行完整的x86系统-现在非常缓慢。而且您可能不应该。</p><p>  Old readers may have noticed that I’m on a new platform, with new hosting, with a new commenting system. If you find anything that’s not working as it should, the best way to get in touch with me is my  Conversation forum. The fine details of the blog lay</p><p>  老读者可能已经注意到我正在使用新平台，新主机，新评论系统。如果您发现任何无法正常工作的内容，那么与我联系的最佳方法是我的对话论坛。博客的细节在于</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.sevarg.net/2021/01/09/arm-mac-mini-and-boinc/">https://www.sevarg.net/2021/01/09/arm-mac-mini-and-boinc/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟化/">#虚拟化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/m1/">#m1</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/运行/">#运行</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>