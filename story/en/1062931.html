<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Commodore的装配商：第1部分：MOS交叉装配器 Commodore’s Assemblers: Part 1: MOS Cross-Assembler</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Commodore’s Assemblers: Part 1: MOS Cross-Assembler<br/>Commodore的装配商：第1部分：MOS交叉装配器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-16 04:28:05</div><div class="page_narrow text-break page_content"><p>In the series about the assemblers Commodore used for developing the ROMs of their 8-bit computers, this article covers the 1975 “MOS Cross-Assembler”, which was available for various mainfraimes of the era.</p><p>本文介绍了用于开发8位计算机的ROM的汇编程序的系列，本文介绍了1975年的“MOS交叉组件”，可用于时代的各种主要框架。</p><p>      With the introduction of the 6502 in 1975, MOS Technology, Inc. also released two assemblers for the new architecture: the “ Cross-Assembler”, available for various mainframes and minicomputers, and the “ Resident Assembler”, running on natively on 6502 systems.</p><p>      随着1975年的6502，MOS Technology，Inc。还发布了两个用于新架构的汇编程序：“交叉汇编程序”，可用于各种大型机和小型计算机，以及“驻留汇编程序”，在6502个系统上自然运行。 。</p><p> According to the master’s thesis  A Cross-Assembler/Simulator for a Microprocessor-Based Industrial Controller, the original MOS Cross-Assembler, together with a simulator, was implemented by the student Robert E. Blanton at the University of Illinois at Urbana-Champaign.</p><p> 根据硕士的论文，用于基于微处理器的工业控制器的交叉汇编/模拟器，原始MOS交叉装配机与模拟器一起由伊利诺伊大学的学生Robert E.Blanton在Urbana-Champaign实施。</p><p> It was written in FORTRAN and used a 6-bit (i.e. all uppercase) character encoding. On the university’s CDC Cyber 175 system, it required 120K (!) 60-bit words of memory to run and had “generally acceptable” response times.</p><p> 它是用Fortran编写的，并使用了6位（即所有大写）字符编码。在大学的CDC网络175系统上，它需要120k（！）60位内存的单词来运行，并具有“通常可接受的”响应时间。</p><p> The Resident Assembler (part 2 of the series) was then developed using the Cross-Assembler, and designed to be compatible in that it understood the same source format, with the same math features and the same directives and options. This way, MOS defined the basic format supported by all future Commodore assemblers.</p><p> 然后使用交叉汇编器开发驻留汇编器（系列的第2部分），并设计用于兼容它，以便它符合相同的源格式，具有相同的数学特征和相同的指令和选项。这样，MOS定义了所有未来的Commodore汇编程序支持的基本格式。</p><p>  Today, you would expect a cross-assembler to run on Linux, Windows or Mac. But these were different times: When the 6502 was released,  microcomputers were just appearing – and the 6502 was a part of this shift – and even the first fridge-sized  minicomputers like the PDP series had only been introduced 10 years earlier. Most companies that used computers at the time used terminals that dialed into mainframes hosted in computing centers. And the market was very fragmented.</p><p>  今天，您希望在Linux，Windows或Mac上运行交叉汇编程序。但这些是不同的时间：当6502被释放时，微电脑刚刚出现 - 并且6502是这一班次的一部分 - 即使是PDP系列等第一冰箱大小的小型计算机才刚刚推出10年。大多数使用计算机在使用终端的计算机中拨入计算中心托管的大型机的计算机。市场非常零碎。</p><p>  The Cross Assembler is available on various time share systems or for batch use on the user’s system.</p><p>  交叉汇编程序可在各种时间份额系统或用户系统上使用批量使用。 </p><p> According to the 6502  Cross Assembler Manual (6500-60P), the supported platforms as of August 1975 were:</p><p>根据6502跨装配手册（6500-60P），截至1975年8月的支持平台是：</p><p>   Current plans involve having the software available on several of the more popular Time Sharing services.</p><p>   目前的计划涉及具有在几个更普遍的时间共享服务的多个产品中提供的软件。</p><p> In addition, it will be available for deck sales. Batch decks for the CDC, IBM, and PDP-11 class machines are available and we will support several other popular mini and major computer systems in the near future.</p><p> 此外，它还可以用于甲板销售。可以使用CDC，IBM和PDP-11类机的批量甲板，我们将在不久的将来支持其他几个流行的迷你和主要计算机系统。</p><p> The 1975  MCS6500 Microprocessor Software Support brochure shows the Cross-Assembler running on the United Computing Systems (UCS) time-sharing service.</p><p> 1975 MCS6500微处理器软件支持手册显示了在联合计算系统（UCS）时间共享服务上运行的交叉汇编程序。</p><p> This  dissertation shows that the Iowa State University ran version 4 of the Cross-Assembler locally on an IBM 360/370.</p><p> 本文展示了爱荷华州大学在IBM 360/370上本地跨汇编程序的版本4。</p><p>   Back then, not all computer systems used the ASCII encoding, and some computers didn’t even support lower case. The encoding of source files is therefore specific to the platform the Cross-Assembler runs on, and only uppercase characters were allowed.</p><p>   然后，并非所有计算机系统都使用ASCII编码，并且某些计算机甚至没有支持小写。因此，源文件的编码是特定于平台运行跨汇编程序的平台，只允许大写字符。</p><p>  ; ; 650X CROSS ASSEMBLER SAMPLE PROGRAM. ; *=$C000 DEFINE ORIGIN.  LDX #$FF SET UP STACK.  TXS LOAD STACK POINTER.  LDA #$F0 LOAD A WITH HEX F0.  STA ASAVE SAVE A IN ASAVE. ;; ALLOCATE SAVE AREA. ; *=$0000 ASAVE *=*  .END</p><p>  ;; 650x交叉汇编程序样本程序。; * = $ C000定义源。 LDX＃$ FF设置堆栈。 TXS加载堆栈指针。 LDA＃$ F0加载Hex F0。 sta asave拯救了asave。;;分配保存区域。; * = $ 0000asave * = * 。结尾 </p><p>  The rule about the start columns of labels and assembly statements is actually more relaxed, as this very compressed example from the C64 KERNAL shows:</p><p>关于标签和装配语句的开始列的规则实际上更加放松，因为来自C64 Kernal的这一非常压缩示例：</p><p> ;COMMAND SERIAL BUS DEVICE TO LISTEN ;LISTN ORA #$20 ;MAKE A LISTEN ADR JSR RSP232 ;PROTECT SELF FROM RS232 NMI&#39;S LIST1 PHA</p><p> ;命令串行总线设备侦听;Listn Ora＃20美元;让听听ADRJSR RSP232;保护自我来自RS232 NMI＆＃39; slist1 pha.</p><p> Since all mnemos and register names are reserved keywords and cannot be used for labels, the assembler does not enforce indenting for assembly statement. The  JSR RSP232 starting at the first column is legal. In fact, even labels may be indented. This example prepends comments after statements with  ;, which is legal because the assembler ignores everything after the statement anyway.</p><p> 由于所有MNEMOS和寄存器名称都是保留的关键字，并且不能用于标签，因此汇编程序不会强制缩进汇编语句。在第一列开始的JSR RSP232是合法的。事实上，甚至标签也可能缩进。此示例将在语句之后添加注释，这是合法的，因为汇编程序无论如何陈述后忽略了所有内容。</p><p> If you want to go for maximum readability (and don’t care about the size of the source), you could also indent the above example like this:</p><p> 如果您想获得最大可读性（并且不关心源的大小），您还可以缩进上面的示例：</p><p> ; COMMAND SERIAL BUS DEVICE TO LISTEN ;LISTN ORA #$20 ; MAKE A LISTEN ADR  JSR RSP232 ; PROTECT SELF FROM RS232 NMI&#39;S LIST1 PHA</p><p> ;命令串行总线设备侦听;Listn Ora＃20美元;让听听ADR JSR RSP232;保护自我从RS232 NMI＆＃39; slist1 pha.</p><p> Labels can be up to 6 characters in length, so one could use 7 character indents for statements so that they always line up. That’s also how the LST output is formatted, which will be described later.</p><p> 标签长度最多可达6个字符，因此可以使用7个字符的缩进进行语句，以便它们总是排队。这也是LST输出的格式化方式，这将在稍后描述。</p><p>  The accepted syntax of assembly statements matches the one in the  6502 Programming Manual. This includes the syntax for statements that take the accumulator as the argument:</p><p>  装配语句的已接受语法与6502编程手册中的一个匹配。这包括将累加器作为参数的语句的语句： </p><p>   One additional feature is an alternative syntax to the indirect, y-indexed addressing mode. In addition to</p><p>一个附加功能是间接，y索引寻址模式的替代语法。此外</p><p>     Operands of assembly statements can use hexadecimal ( $), octal ( @), binary ( %) and decimal (no prefix) constants. Mathematical expressions using  +,  -,  * and  / are possible, but they are always evaluated left-to-right with no operator precedence and no parenthetical grouping. Character/string literals are prefixed with  &#39;.</p><p>     装配声明的操作数可以使用十六进制（$），八进制（@），二进制（％）和十进制（无前缀）常量。使用+， - ，*和/是可能的数学表达式，但它们始终以左右进行评估，没有操作员优先级，没有括号分组。字符/字符串文字以＆＃39为前缀。</p><p>      Like most development tools from the 1970s, the assembler can create a so-called listing file (suggested file extension  .LST) during assembly that shows the source and the generated bytes side-by-side and is meant to be printed on paper. Here is a example from the manual:</p><p>      与20世纪70年代的大多数开发工具一样，汇编程序可以在装配期间创建所谓的列表文件（建议的文件扩展名为.lst），该文件显示源和并排生成的字节，并在纸上打印。以下是手册的示例：</p><p> CARD # LOC CODE CARD  1 CR=15  2 LF=12  3 ; LOW CORE DATA AREAS  4 0000 E7 06 TEMTBL .WORD G3TEM, G1TEM  5 0002 E7 05  6 GROUP=B10  7 0004 00 THI .BYTE 0  8 0005 00 TLO .BYTE 0  9 0006 00 00 00 3PER .WORD 0 ***** ERROR ** LABEL DOESN&#39;T BEGIN WITH ALPHABETIC CHARACTER - NEAR COLUMN 1  10 0009 B1 0E NEXT LDA (SAVIL)Y [...]  269 07C9 C9 3B CMP #&#39;;  270 07CB 00 00 BEQ DONE ***** ERROR ** UNDEFINED SYMBOL - NEAR COLUMN 18  280 .ENDEND OF MOS/TECHNOLOGY 650X ASSEMBLY VERSION 4 NUMBER OF ERRORS = 2, NUMBER OF WARNINGS = 0</p><p> 卡＃LOC代码卡 1 Cr = 15 2 lf = 12 3;低核心数据区域 4 0000 E7 06 Temtbl .Word G3TEM，G1TEM 5 0002 E7 05 6组= B10 7 0004 00 THI .BYTE 0 8 0005 00 TLO .BYTE 0 90006 00 00 00 00 3per .Word 0*****错误**标签并在字母字符中开始 - 靠近第1列 10 0009 B1 0E下一个LDA（Savil）y[...] 269 07C9 C9 3B CMP＃＆＃39 ;; 270 07CB 00 00 BEQ完成*****错误**未定义的符号 - 第18栏附近 280MOS / Technology的结尾650x装配版本4错误= 2，警告数= 0</p><p> The first column ( CARD #) is the line number in the source. The  LOC field is the memory address, which is followed by the output bytes ( CODE) and the source line ( CARD), which the assembler re-indented for readability.</p><p> 第一列（卡＃）是源中的行号。 LOC字段是存储器地址，后跟输出字节（代码）和源行（卡），该汇编器重新缩进可读性。</p><p> The  CARD nomenclature stems from 1960s mainframes, where each line of text was represented by one punch card.</p><p> 卡命名法从20世纪60年代的主机源，其中每行文本由一个打卡表示。</p><p> Error messages are shown as extra lines after the line that caused the error. Note that the assembler will keep working through the file no matter what, and will output placeholder bytes for lines with errors.</p><p> 错误消息显示为导致错误的行后的额外行。请注意，汇编程序将不惜此操作继续通过文件工作，并且将输出具有错误的行的占位符字节。 </p><p> The  original LST printout of the KIM-1 ROM, which was part of the  user manual, is a real-world example of a 1200-line LST file, with the symbol table and the mnemo statistics ( .OPT COUNT) at the end.</p><p>作为用户手册的一部分的Kim-1 ROM的原始LST打印输出是一个1200线LST文件的真实示例，符号表和末尾的Mnemo统计信息（.opt计数）。</p><p>  The main output of the assembler is the binary program, which is in the form of a so-called “interface file” with a suggested file extension of  .OBJ.</p><p>  汇编程序的主输出是二进制程序，它以所谓的“接口文件”的形式，具有建议的文件扩展名.obj。</p><p> The diverse set of platforms that the Cross-Assembler ran on all had different word sizes, and many of them measured memory only in words and did not even have a concept of (8-bit) “bytes”. Therefore, the assembler could not output a binary file, but instead wrote a portable, hex-encoded text file, like this:</p><p> 交叉汇编程序在所有平台上运行的不同平台具有不同的单词大小，而且它们中的许多只能用文字测量存储器，并且甚至没有概念（8位）“字节”。因此，汇编程序无法输出二进制文件，而是写入便携式的十六进制编码的文本文件，如下所示：</p><p>    The last line is *  ;00: identifier for last line * 4 chars: number of preceding lines * 4 chars: checksum</p><p>    最后一行是*; 00：上行的标识符* 4字符：前一行的数量* 4字符：校验和</p><p>  This text-only file is platform-independent and can easily be transferred between different computer systems, and e.g. downloaded from a time-sharing system in order to write it to an EPROM.</p><p>  仅此文本文件独立于平台，可以在不同的计算机系统之间轻松传输，例如，可以在不同的计算机系统之间传输。从时间共享系统下载，以便将其写入EPROM。</p><p>  The Cross-Assembler was used at MOS to create the very first 6502 code, like the KIM-1 ROM (shown above), or the  TIM ROM (MCS6530-004).</p><p>  交叉汇编器用于MOS以创建第一6502代码，如KIM-1 ROM（如上所示）或TIM ROM（MCS6530-004）。</p><p> A large amount of the  original Commodore source code has been preserved, and all code before 1984 is in a format very similar to the original MOS definition supported by both the Cross-Assembler and the Resident Assembler. So at first sight, it is not so clear which assembler Commodore used for developing ROMs of the PET, VIC-20 etc. and the disk drives.</p><p> 已经保留了大量原始Commodore源代码，1984年之前的所有代码都是一种非常类似于跨汇编器和驻留汇编程序支持的原始MOS定义的格式。所以一见钟情，它不太清楚哪种汇编商Commodore用于开发PET，VIC-20等和磁盘驱动器的ROM。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.pagetable.com/?p=1520">https://www.pagetable.com/?p=1520</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/装配/">#装配</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编程序/">#汇编程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>