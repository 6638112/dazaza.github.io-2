<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>循序渐进：增量编程</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">循序渐进：增量编程</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 22:33:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/66677dbb1fb90331051acf350be81b57.png"><img src="http://img2.diglog.com/img/2020/10/66677dbb1fb90331051acf350be81b57.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>One thing that has really benefited my productivity (and also my general sanity), has been learninghow to take a big task and break it down into smaller, more manageable steps. Big tasks can befrightening and overwhelming, but if I just keep working on the list of smaller tasks, then somehow,as if by magic, the big task gets completed.</p><p>有一件事真正提高了我的工作效率(也让我头脑清醒)，那就是学会了如何接受一项大任务，并将其分解成更小、更容易管理的步骤。大任务可能会令人恐惧和不堪重负，但如果我只是继续做小任务的清单，那么不知何故，就像变魔术一样，大任务完成了。</p><p>   When programming, I take a very specific approach to this breakdown. I make sure that each step issomething that  compiles, runs, passes all the tests , and  adds value to the codebase . Exactlywhat “adds value” means is purposefully left vague, but it can be things like adding a smallfeature, fixing a bug, or taking a step towards refactoring the code into better shape (i.e.,reducing  technicaldebt).</p><p>在编程时，我对这种分解采取了非常具体的方法。我确保每个步骤都是编译、运行、通过所有测试并为代码库增加价值的步骤。确切地说，“增加价值”的意思是故意保持模糊的，但它可以是添加一个小功能，修复一个错误，或者朝着将代码重构为更好的形状迈出一步(即，减少技术债务)。</p><p> An example of  not adding value is adding a new feature, but also introducing ten new bugs. It’snot clear that the value of the feature outweighs the cost of the bugs, so it might be a net loss.</p><p>没有增加价值的一个例子是添加了一个新功能，但也引入了十个新的bug。目前还不清楚这一功能的价值是否超过了漏洞的成本，因此可能是净亏损。</p><p> Another example of not adding value is making the UI prettier, but also make the app run ten timesslower. Again, it’s not clear that the prettier look is worth the performance hit, so it might be anet loss.</p><p>另一个没有增值的例子是让UI更美观，但也让应用程序的运行速度降低了10倍。再说一次，还不清楚更漂亮的外观是否值得性能上的打击，所以这可能是一个净损失。</p><p> Of course, I can’t always be sure that I’m not introducing bugs, and “value” is inherentlysubjective (how much performance is a new feature worth). The important part is the  intention. My intention is to always add value with every single commit.</p><p>当然，我不能总是确信我没有引入bug，而且“值”本身就是主观的(新特性的性能值有多高)。重要的部分是意图。我的意图是始终通过每一次提交来增加价值。</p><p> Basically, what I want to avoid is the “It has to get worse before it gets better”-attitude. Alsoknown as: “The new system is the modern way to do it. Sure, it has some bugs and runs kind of slowright now, but once we’ve fixed that, it’s going to be way better than what we had before.” I’veseen too many cases where these supposed fixes never happen and the new system, which was supposedto be better, just made things worse.</p><p>基本上，我想要避免的是“必须先变得更糟，然后才会变得更好”的态度。也被称为：“新系统是做这件事的现代方式。当然，它现在有一些漏洞，运行速度有点慢，但一旦我们修复了这一点，它将比以前好得多。“。我见过太多的案例，这些所谓的修复从来没有发生过，而新的系统本来应该更好，但只会让事情变得更糟。</p><p> Plus, you know, it feels good to add value. If every day I can make a commit and that commit makesthe engine better in some way, that makes me happy.</p><p>另外，你知道，增加价值的感觉很好。如果我每天都能做出承诺，而这个承诺在某种程度上让引擎变得更好，那我就会很高兴。</p><p>  In addition to implementing changes through a series of small commits, I also  push every one ofthose small commits back to the master branch.</p><p>除了通过一系列小提交实现更改之外，我还将这些小提交中的每一个都推回主分支。</p><p> Note that this is the exact opposite of a  featurebranch workflow, instead, it is a form of trunk-baseddevelopment:</p><p>请注意，这与功能分支工作流正好相反，相反，它是一种基于干线的开发形式：</p><p> In a feature branch workflow developers work on new features in isolated, separate branches of thecode and don’t merge them back to master until they’re “complete”: fully working, debugged,documented, code reviewed, etc.</p><p>在功能分支工作流中，开发人员在独立的、独立的代码分支中处理新功能，并且在它们“完成”之前不会将它们合并回主功能：完全工作、调试、记录、代码审查等。</p><p> In the trunk-based approach, features are implemented as a series of small individual commits tothe master branch itself. Care must be taken so that everything works even when the features areonly “partially implemented”:</p><p>在基于主干的方法中，功能被实现为对主分支本身的一系列小的个体提交。必须小心，以便即使在功能仅“部分实现”的情况下也能正常工作：</p><p>  Proponents of the feature branch approach claim that it is a safer way to work since changes to thefeature branch don’t disrupt the master and cause bugs. Personally, I think this safety is illusory.Bugs in the feature branch just get hidden until it’s merged back to master when we suddenly get all the bugs.</p><p>功能分支方法的支持者声称，这是一种更安全的工作方式，因为对功能分支的更改不会扰乱主程序并导致错误。就我个人而言，我认为这种安全性是虚幻的，特性分支中的bug只是被隐藏起来，直到它被合并回master，这时我们突然得到了所有的bug。</p><p> Feature branches also go against my philosophy that every commit should add value. The whole ideabehind a feature branch is: “we’re going to break a bunch of shit over here, but don’t worry, we’llfix it before we merge back to master”. Better not to break stuff in the first place.</p><p>特性分支也违背了我的理念，即每次提交都应该增加价值。功能分支背后的整个想法是：“我们会在这里打破一堆狗屎，但别担心，我们会在合并回主站之前把它修好的。”最好一开始就不要弄坏东西。</p><p>  Fewer merge conflicts. With long-running feature branches, the code in the branch driftsfurther and further away from the code in master, causing more and more merge conflicts. Dealingwith these is a lot of busy work for programmers and it also risks introducing bugs. Some of thesebugs won’t be seen until the branch is merged.</p><p>合并冲突更少。随着功能分支的长时间运行，分支中的代码会越来越远离master中的代码，导致越来越多的合并冲突。处理这些对于程序员来说是一项非常忙碌的工作，而且还有引入错误的风险。其中一些错误在分支合并之前是看不到的。</p><p> Less release-day chaos. Typically, all features scheduled for a certain release have the samedeadline. This leads to all feature branches being merged just before the deadline. This meansthat we get all the merge and integration bugs at the same time, just before the release date.Getting a lot of bugs at the same time is a lot worse than having them spread out evenly. Andgetting them just before a release is due is the absolute worst time to get them.</p><p>减少了释放日的混乱。通常，为某个版本安排的所有功能都有相同的截止日期。这会导致所有功能分支恰好在截止日期之前合并。这意味着就在发布日期之前，我们同时得到了所有的合并和集成错误。同时得到很多错误比让它们均匀分布要糟糕得多。而在发布日期前拿到它们绝对是最糟糕的时机。</p><p> No worry about the right time to merge. Since everybody knows that merging a feature branchtends to cause instability, this leads to worry about the “right time” to merge. You want to avoidmerging right before a release (unless the feature is required for the release) to avoidintroducing bugs in the release. So maybe just after the release has been made? But what if weneed a hotfix for the release? While the merge is being held, valuable programmer time is beingwasted.</p><p>不用担心合并的合适时机。因为每个人都知道合并一个功能分支往往会导致不稳定，这会导致人们担心合并的“合适时机”。您希望避免在发布之前进行合并(除非该功能是发布所必需的)，以避免在发布中引入错误。那么也许就在发布之后？但是如果我们需要一个补丁来发布呢？在进行合并的同时，程序员宝贵的时间也被浪费了。</p><p> No rush to merge. When working with feature branches, I often felt a hurriedness about gettingthe branches merged. Sometimes because a branch was needed for a specific release. But also oftenbecause the developer was tired of dealing with merge conflicts, wanted to get it over with, andmove on to the next thing. Thus, the goal of only merging feature branches when they are“complete” was often compromised. (And of course, nothing is ever really “complete”.)</p><p>不急于合并。在处理功能分支时，我经常感到急于合并分支。有时是因为特定版本需要分支。但也经常是因为开发人员厌倦了处理合并冲突，想要结束它，然后转到下一件事上。因此，仅在功能分支“完成”时才合并它们的目标经常会受到影响。(当然，没有什么是真正“完整”的。)。</p><p> Easier to revert. If major issues are discovered after the merge of a feature branch (whichoften happens), there is often a lot of reluctance to revert the merge. Another big feature branchmight already have been merged on top of it (since lots of feature branches often get merged atthe same time, just before a release), and reverting it would cause total merge chaos. So insteadof doing a calm, sensible rollback, the team has to scramble desperately to fix the issues beforethe release. With trunk-based development, any major issues would most likely have already beendiscovered. The final commit that makes the new feature “go live” is typically a simple one-linechange that is painless to revert.</p><p>更容易还原。如果在功能分支合并后发现重大问题(通常会发生)，通常会有很多人不愿意恢复合并。另一个大的功能分支可能已经在其上面合并了(因为很多功能分支经常同时合并，就在发布之前)，恢复它会导致完全的合并混乱。因此，团队必须在发布之前拼命修复问题，而不是冷静、明智地回滚。使用基于主干的开发，很可能已经发现了任何重大问题。使新特性“上线”的最终提交通常是一个简单的单行更改，恢复起来很容易。</p><p> Partial work is shared. In trunk-based development, the partial work done on a feature is seenby all developers (in the master branch). Thus, everybody has a good idea of where the engine isgoing. Bugs, design flaws, and other issues can be discovered early. And it is easier for othersto adapt their code to work with the new feature. It’s also easier to get an estimate of how muchwork is needed to complete a feature when everybody can see how far it has progressed.</p><p>部分工作是共享的。在基于主干的开发中，所有开发人员(在主分支中)都可以看到在特性上所做的部分工作。因此，每个人都对发动机的去向了如指掌。错误、设计缺陷和其他问题可以及早发现。其他人也更容易修改他们的代码来使用新功能。当每个人都能看到它已经进展到什么程度时，也更容易估计完成一项功能需要做多少工作。</p><p> Easier to pause and pick up later. Sometimes, work on a feature might have to be paused for avariety of reasons. There might be more critical issues that need to be addressed. Or the maindeveloper of the feature might get sick, or have vacation coming up. This is a problem for featurebranches because they tend to “rot” over time, as the code base drifts further and further away,causing more and more merge conflicts with the branch. Code that is checked into master does not“rot” in the same way.</p><p>稍后更容易暂停和接听。有时，由于各种原因，某个功能的工作可能不得不暂停。可能还有更关键的问题需要解决。或者该功能的主要开发人员可能会生病，或者即将休假。对于功能分支来说，这是一个问题，因为随着代码库漂移得越来越远，它们往往会随着时间的推移而“腐烂”，从而导致越来越多的与分支的合并冲突。签入到MASTER中的代码不会以同样的方式“腐烂”。</p><p> Easier to address other bugs/refactors at the same time. When working on a feature or aproblem, it is pretty common to find other, related problems, exposed by the work you are doing.In the trunk-based approach, this is not an issue. You would just make one or more separatecommits to the trunk to fix those issues. With the feature branch approach, it is more tricky. Iguess the  right thing to do would be to branch off a new separate bug fix branch from master,fix the issue in that branch, merge  that branch into the branch you are currently working on,and (once it passes code review) into master (so that other people get the bug fix before yourfeature branch is merged, because who knows when that will happen). But who has time for all thatshit? So instead, people just fix the problem in their feature branch, and maybe cherry-pick itinto master if they’re having a good day. So now, instead of being about a single isolatedfeature, the feature branch becomes a tangled mix of different features, bug fixes, and refactors.</p><p>更容易同时解决其他错误/重构。在处理特性或问题时，经常会发现您正在做的工作暴露出的其他相关问题。在基于主干的方法中，这不是问题。您只需向主干提交一个或多个单独的命令即可解决这些问题。使用功能分支方法，就会更加棘手。我想正确的做法应该是从master中分离出一个新的单独的bug修复分支，修复该分支中的问题，将该分支合并到您当前正在处理的分支中，然后(一旦通过代码审查)合并到master中(这样其他人就可以在合并您的功能分支之前获得bug修复，因为谁知道什么时候会发生这种情况)。但是谁有时间做这些狗屎呢？取而代之的是，人们只需在功能分支中修复问题，如果他们今天过得不错，也许可以将其挑选到主功能中。因此，现在，特性分支不再是单个孤立的特性，而是不同特性、错误修复和重构的混杂在一起。</p><p> The main challenge of the trunk-based approach is how to break a big task down into individualpieces. Especially, with the requirement that each piece should compile, run, add value, and beready to be pushed into master. How can we push partial work without exposing users to half-baked,not yet fully working features?</p><p>基于主干的方法的主要挑战是如何将大任务分解为单独的任务。特别是要求每件作品都要编译好、运行好、增值好，随时可以推入大师手中。我们如何才能推送部分工作，而不会让用户接触到不成熟、还没有完全工作的功能呢？</p><p>   An approach that works well for new features is to use a flag to control whether a feature isvisible to end-users or not.</p><p>适用于新功能的一种方法是使用标志来控制功能对最终用户是否可见。</p><p> Let’s look at an example. A feature that I recently added to the engine was a  Download tab thatlets the users download new engine versions and sample projects from within the engine itself:</p><p>让我们看一个例子。我最近添加到引擎中的一个功能是一个下载选项卡，它允许用户从引擎内部下载新的引擎版本和示例项目：</p><p>  There are lots of different ways this could be broken down into smaller steps. Here’s an example:</p><p>有很多不同的方法可以将其分解为更小的步骤。这里有一个例子：</p><p> Add the  Download tab to the menus and show a new blank tab when it’s opened.</p><p>将下载选项卡添加到菜单中，并在打开时显示一个新的空白选项卡。</p><p> Normally, I don’t do a full breakdown like this upfront. Instead, I just kind of figure out the nextlogical step as I go along. I only sit down and do a serious planning session if the task isparticularly tricky and incremental steps like this don’t come naturally.</p><p>通常情况下，我不会像这样预先做一个全面的分析。取而代之的是，我只是边走边想出下一个合乎逻辑的步骤。我只有在任务特别棘手的情况下才会坐下来认真地做计划，而且像这样的增量步骤不是自然而然的。</p><p> To prevent end-users from seeing the tab before it’s actually working, I hide it behind a flag. Thiscan be as simple as:</p><p>为了防止最终用户在选项卡实际工作之前看到它，我将其隐藏在一面旗帜后面。这可以简单到如下所示：</p><p>  To get the menu option to show the  Download tab, you have to change the  download_tab_enabledflag to  true and recompile.</p><p>要获得显示下载选项卡的菜单选项，必须将download_tab_enabledflag更改为true并重新编译。</p><p> We call these flags   feature flags since theyselectively enable or disable individual features of the application. Once the feature is complete,we can remove the flag and just leave the  true code path.</p><p>我们称这些标志为功能标志，因为它们选择性地启用或禁用应用程序的各个功能。一旦功能完成，我们就可以删除该标志，只留下真正的代码路径。</p><p>  Through a dynamic  bool variable that is initialized from a config file, a menu option or aninternal debug console.</p><p>通过从配置文件、菜单选项或内部调试控制台初始化的动态布尔变量。</p><p> Out of these options, I think the third one is the best. You want to expose your new code to  asmany people as possible. That way, they can find bugs in your code, if they refactor the codebase,they take your code into account, etc.</p><p>在这些选择中，我认为第三个是最好的。您希望向尽可能多的人公开您的新代码。这样，他们就可以发现你代码中的错误，如果他们重构了代码库，他们就会把你的代码考虑在内，等等。</p><p> If you use a  #define flag, other people on your team won’t even compile your code. Thus, one oftheir changes could easily end up breaking your code. A  const flag is better, because your codewill still be compiled, but since people can’t try the new feature without recompiling your code,most people won’t bother.</p><p>如果您使用#DEFINE标志，您团队中的其他人甚至不会编译您的代码。因此，它们的某个更改很容易破坏您的代码。常量标志更好，因为您的代码仍将被编译，但是由于人们不能在不重新编译您的代码的情况下尝试新功能，所以大多数人不会费心。</p><p> With a dynamic flag, artists, producers, or end-users who don’t want to be bothered with rebuildingthe application can just modify the config file and then give your new feature a test run.</p><p>有了动态标志，不想为应用程序重建而烦恼的艺术家、制作人或最终用户只需修改配置文件，然后对您的新功能进行测试运行即可。</p><p> When the time comes to release a feature, you simply flip the default value of the feature flag from false to  true and everybody will see the new feature. If there are issues and you need torevert, you simply flip the flag back. Later, when the feature seems stable, you can get rid of theflag and just keep the  true path in the code.</p><p>到了发布特性的时候，您只需将特性标志的默认值从false反转为true，每个人都会看到新特性。如果有问题，您需要恢复，您只需将旗帜翻转回来。稍后，当特性看起来稳定时，您可以去掉标志，只保留代码中的真实路径。</p><p> You can even do a partial, staged rollout. E.g., you could set the flag to  true for 1 % of theusers and then slowly ramp that up while monitoring the crash logs and the forums for any issues.That way, if a problem is encountered, it will only affect a small number of users and you canquickly revert.</p><p>您甚至可以进行部分、分阶段的推出。例如，您可以将1%的用户的标志设置为true，然后在监控崩溃日志和论坛中的任何问题的同时缓慢增加该标志。这样，如果遇到问题，只会影响一小部分用户，您可以快速恢复。</p><p>  The above approach works well for new features, but what should you do if you are doing a majorrewrite of an existing system?</p><p>上述方法适用于新功能，但是如果您主要是重写现有系统，您应该怎么做呢？</p><p> In this case, it might be trickier to find an incremental step-by-step approach, because you mightwant to rip out large parts of the old system and it will take a while until the replacement codereaches feature parity.</p><p>在这种情况下，可能更难找到一种逐步递增的方法，因为您可能需要拆除旧系统的大部分，并且需要一段时间才能使替换的代码缓存具有相同的功能。</p><p> It might be tempting to reach for the feature branch approach in this case, but again, I don’t thinkit’s the right strategy. A big problem is you will have two conflicting goals. On the one hand, youwant to merge early so that people see the improved code and you get some testing on the rewrites.On the other hand, you want to delay it as long as possible, so that you can reach feature parityand iron out all the bugs. What usually happens is an unsatisfying mix of the two.</p><p>在这种情况下，使用功能分支方法可能很有诱惑力，但同样，我认为这不是正确的策略。一个大问题是你会有两个相互冲突的目标。一方面，您希望尽早合并，这样人们就可以看到改进后的代码，而您可以对重写代码进行一些测试；另一方面，您希望尽可能地推迟合并，这样您就可以达到特性一致性并消除所有错误。通常情况下，这两者的结合并不令人满意。</p><p> A better approach is to make a parallel implementation and let the engine have two copies of thesame system.</p><p>更好的方法是进行并行实现，让引擎拥有同一系统的两个副本。</p><p> If you are doing a major overhaul, you could start by just copying the entire system code to a newfolder. If you are rewriting from the ground up, you could start with an empty folder.</p><p>如果您正在进行大修，您可以从只将整个系统代码复制到新文件夹开始。如果您要从头开始重写，您可以从一个空文件夹开始。</p><p> Depending on the nature of the system you are replacing, you could either have both systems (the oldand the new one) running in parallel, or you could have a feature flag that selects which of thesystems should be the default. For example, if you are rewriting the physics simulation, youprobably need a flag to select if you are using the old or the new one since you want all physicsobjects to live in the same simulation (otherwise they won’t interact). On the other hand, if youare rewriting the particle effect system, you could potentially have both systems running and justselect for each played effect whether it should play in the old or the new system.</p><p>根据您要更换的系统的性质，您可以让两个系统(旧系统和新系统)并行运行，也可以有一个功能标志来选择哪个系统应该是默认系统。例如，如果要重写物理模拟，可能需要一个标志来选择是使用旧的还是使用新的，因为您希望所有物理对象都位于同一模拟中(否则它们不会交互)。另一方面，如果您正在重写粒子效果系统，您可能会同时运行两个系统，并且只需为每个播放的效果选择在旧系统还是新系统中播放。</p><p> Having parallel implementations lets you do a much smoother transition from the old to the newsystem. Everyone on the team can easily test out the new system. You can compare it to the old onefor feature completeness, stability, performance, etc. If applicable, you could even run automatedtests to verify that the new system produces the exact same output as the old one. Once the newsystem has been thoroughly verified, you can change the flag and start using it as the default.</p><p>拥有并行实现可以让您更顺利地从旧系统过渡到新系统。团队中的每个人都可以很容易地测试新系统。您可以将其与旧系统进行功能完整性、稳定性、性能等方面的比较。如果适用，您甚至可以运行自动测试来验证新系统产生的输出是否与旧系统完全相同。一旦彻底验证了新系统，您就可以更改标志并开始将其用作默认值。</p><p> The parallel implementations also provide a much gentler upgrade path for end-users. Instead oftying everyone to the same “merge date”, you can just expose the system selection flag to theend-users. Users who are eager to try out the improved features in the new system can turn the flagon early, while users who favor stability or depend on certain quirks in the old system can decideto stay on it, even after the new one has become the default.</p><p>并行实现还为最终用户提供了更为温和的升级途径。您可以只将系统选择标志暴露给最终用户，而不是将每个人都绑定到相同的“合并日期”。渴望在新系统中试用改进功能的用户可以提前打开旗帜，而喜欢稳定性或依赖旧系统某些怪癖的用户可以决定继续使用它，即使在新系统成为默认系统之后也是如此。</p><p> And there is no immediate rush to retire the old system once the new one has become the default, youcan eventually deprecate and phase it out once the burden of maintaining it outweighs the value ofhaving it around.</p><p>而且，一旦新系统成为默认系统，就不会立即急于淘汰旧系统，一旦维护它的负担超过了保留它的价值，你最终可以反对并逐步淘汰它。</p><p>  For our final problem, let’s consider something even trickier — making a big refactoring change tothe entire codebase. It could be things like:</p><p>对于我们的最后一个问题，让我们考虑一些更棘手的问题-对整个代码库进行重大重构更改。可能是这样的：</p><p> Changing a commonly used type, such as switching from  std::string to an internal string type.</p><p>更改常用类型，例如从std：：string类型切换到内部字符串类型。</p><p>  They tend to touch a lot of the code, increasing the risk of merge conflicts.</p><p>它们往往会触及大量代码，从而增加合并冲突的风险。</p><p> It’s often tricky to see how to do them incrementally. For example, if you change the parametersof a function, you must update all the call sites. Otherwise, the code simply won’t compile.</p><p>要了解如何渐进地完成它们通常是很棘手的。例如，如果更改函数的参数，则必须更新所有调用点。否则，代码根本无法编译。</p><p> In some cases, it can be pretty straightforward how to approach the problem incrementally. Forexample, when we add a new warning such as  -Wshadow, the fixes we do in order to make the codecompile  with the warning do not cause any problems when compiling the code  without the warning.So we can simply turn on the warning, fix a bunch of the errors we get (however many makes asuitably sized commit), turn the warning off again, and then commit the result. Rinse and repeatuntil all the warnings are fixed and then do a final commit that turns the  -Wshadow flag on foreverybody.</p><p>在某些情况下，如何逐步解决问题可能相当简单。例如，当我们添加一个新的警告(如-WShadow)时，当编译没有警告的代码时，我们为使带有警告的协反编译所做的修复不会导致任何问题。因此，我们只需打开警告，修复我们收到的一大堆错误(无论多少错误都会进行适当大小的提交)，再次关闭警告，然后提交结果。冲洗并重复，直到所有警告都已修复，然后执行最后一次提交，将-Wdow标志打开为Everybody。</p><p> In other cases, we can employ the parallel implementation strategy. Suppose we have a function thatis used all over the code to allocate memory:</p><p>在其他情况下，我们可以采用并行实现策略。假设我们有一个在整个代码中用于分配内存的函数：</p><p>  Now we want to add a  system parameter so that all memory allocations can be tagged as belonging to a particular system (gameplay, graphics, sound, animation, etc):</p><p>现在我们要添加一个系统参数，以便可以将所有内存分配标记为属于特定系统(游戏、图形、声音、动画等)：</p><p>  If we just added the parameter like this, the code wouldn’t compile until we fixed  all the callsites. I.e., the incremental approach would not work.</p><p>如果我们像这样添加参数，直到我们修复了所有调用点，代码才会编译。也就是说，渐进式的方法不会奏效。</p><p>   Now we can incrementally transition all of the code to use  mem_alloc_new() instead of mem_alloc(). Once we have transitioned all of the code, we can remove  mem_alloc() and then do aglobal search-and-replace that renames  mem_alloc_new() →  mem_alloc().</p><p>现在，我们可以增量地将所有代码转换为使用mem_alloc_new()，而不是mem_alloc()。一旦我们转换了所有代码，就可以删除mem_alloc()，然后执行全局搜索并替换，将mem_alloc_new()重命名为mem_alloc()→mem_alloc()。</p><p> The final challenge is the trickiest one of them all — changing one of the fundamental types in thecodebase.</p><p>最后一个挑战是最棘手的挑战之一--改变代码库中的一个基本类型。</p><p> In fact, I recently had a run-in with this, which is what prompted me to write this whole blog post.In my case, I wanted to refactor our codebase to introduce a new type to represent the IDs ofobjects in The Truth.  TheTruth is our maindata store in The Machinery. All the data that the editor works on is stored in The Truth, and everyobject in The Truth is referenced by its ID.</p><p>事实上，我最近与此发生了冲突，这就是促使我写整篇博客文章的原因。在我的例子中，我想重构我们的代码库，引入一种新的类型来表示Truth中的对象的ID。这是我们在机器上的主要数据存储。编辑器处理的所有数据都存储在Truth中，Truth中的每个对象都由其ID引用。</p><p> We used to represent Truth IDs with just an  uint64_t, but since we have lots of other values thatare also represented by  uint64_ts this was causing increasing confusion. In order to providebetter documentation of where a Truth ID is expected and some type-safety against passing other uint64_t values, we decided to switch from using a plain  uint64_t to wrapping it in a struct:</p><p>我们过去只用uint64_t来表示Truth ID，但是因为我们有很多其他的值也由uint64_ts来表示，这就造成了越来越多的混乱。为了更好地记录Truth ID的预期位置，以及防止传递其他uint64_t值的一些类型安全性，我们决定从使用普通uint64_t切换到将其包装在struct中：</p><p>  Note that since Truth IDs are used  everywhere, this change impacts thousands of lines in the code.</p><p>请注意，由于到处都使用Truth ID，因此此更改会影响代码中的数千行。</p><p> Somewhat arrogantly, I still set out to do this refactor as a single concentrated push. I  know Ishould do things incrementally, that’s what this whole blog post is about, but sometimes I mess up.</p><p>有点傲慢的是，我仍然开始将这种重构作为一次集中的推动。我知道我应该循序渐进，这就是这篇博客的全部意义所在，但有时我会搞砸。</p><p> As I worked on it, I realized this change was a lot bigger than I had originally thought and therewas no way I was going to be able to finish it in a single sitting. I started to get that sinkingfeeling that things were spiraling out of control. I was changing  thousands of lines of code. WasI really sure that I wasn’t introducing typos anywhere?</p><p>当我工作的时候，我意识到这个变化比我原来想象的要大得多，我不可能一下子就能完成它。我开始有一种情绪低落的感觉，觉得事情正在失控。我更改了数千行代码。我真的确定我没有在任何地方引入打字错误吗？</p><p>       instead? Running some tests would have increased my confidence, but since the code wouldn’t compileuntil I had fixed  everything, I couldn’t run any tests.</p><p>取而代之？运行一些测试会增加我的信心，但是因为代码只有在我修复了所有东西之后才会编译，所以我不能运行任何测试。</p><p> Then I started to get merge conflicts with other people’s changes which I had to resolve by hand,hoping that I understood their code well enough not to break anything. It became harder and harderto picture the consequences of all the changes. How many bugs was I introducing?</p><p>然后，我开始与其他人的更改发生合并冲突，我必须手动解决这些冲突，希望我对他们的代码理解得足够好，不会破坏任何东西。描绘所有这些变化的后果变得越来越难。我引入了多少个错误？</p><p> In the past, I’ve often tried to deal with these “panicky” feelings by “powering through”. Startingto pull long late-night coding sessions to try to wrestle this thing that is slipping away from meback under control. Get all my changes in before someone else has a chance to push anything so thatI don’t have to deal with the merge conflicts. (Which of course just means that  they have to dealwith the merge conflicts instead. Ha ha!)</p><p>在过去，我经常试图通过“强力克服”来应对这些“恐慌”情绪。开始进行长时间的深夜编码会议，试图摆脱这件正在我掌控中的事情。在其他人有机会推送任何东西之前，让我的所有更改生效，这样我就不必处理合并冲突了。(当然，这仅仅意味着他们必须改为处理合并冲突。哈哈！)。</p><p> But these days I’m maybe a little bit wiser? I realize that these feelings are a sign that I havebitten off more than I could chew and that the right response is not to push forward, but insteadtake a step back, reflect and try to reformulate the problem so it can be approached in a series ofsmaller steps instead. Depending on how much trouble I’ve gotten myself into, I might be able tosalvage some of the changes or I might just throw it all away and start over with an iterativeapproach. Even when I’ve had to throw everything away, I’ve never regretted it. In the end, workingin a series of small, controlled steps is so much more productive that I feel like I always gainedback the time I “lost”.</p><p>但这几天我可能更聪明了一点？我意识到，这些感觉是一个迹象，表明我已经吃了太多东西，正确的反应不是向前推进，而是后退一步，反思并尝试重新阐述问题，这样就可以通过一系列较小的步骤来解决问题。根据我给自己带来了多大的麻烦，我可能能够挽救一些更改，也可能干脆把它们全部扔掉，用迭代的方法重新开始。即使当我不得不扔掉所有东西的时候，我也从来没有后悔过。最后，在一系列小的、可控的步骤中工作效率要高得多，以至于我觉得我总是能找回我“失去的”时间。</p><p> Back to the problem at hand. I knew I wanted to change the type  incrementally. I.e., change it insome files, but not in others, and still be able to compile and test the code. But how could Ipossibly do that, when everything depends on everything else? Once I change some parameters to use tm_tt_id_t, anything that calls it with  uint64_t will produce an error.</p><p>回到手头的问题上来。我知道我想逐步改变类型。也就是说，在一些文件中更改它，而不是在其他文件中更改，并且仍然能够编译和测试代码。但是，当一切都依赖于其他一切的时候，我怎么可能做到这一点呢？一旦我将一些参数更改为使用tm_tt_id_t，任何使用uint64_t调用它的操作都将产生错误。</p><p> My key insight was that this situation is very similar to the one of enabling  -Wshadow. Thattransition was easy to do because we changed the code from compiling just under  -Wno-shadow sothat it compiles under  both  -Wshadow and  -Wno-shadow. We can do this change incrementallyuntil we’re finally ready to turn on  -Wshadow.</p><p>我的主要见解是，这种情况与Enabling-Wdow非常相似。这种转换很容易完成，因为我们将代码从仅在-WNO-SHADOW下编译改为在-WNO-SHADOW和-WNO-SHADOW下编译。我们可以递增地进行此更改，直到我们最终准备好打开-wdow。</p><p> Let’s do the same thing here. We’ll call the type of the ID objects  ID_TYPE. Right now, our codecompiles when  ID_TYPE is  uint64_t. Our goal is to rewrite that code so that it compiles  bothwhen  ID_TYPE is  uint64_t and when it is  tm_tt_id_t. If we can incrementally transition to thatstate, then once all the code compiles when  ID_TYPE is  tm_tt_id_t we can make that the default.</p><p>让我们在这里做同样的事情。我们将ID对象的类型称为ID_TYPE。现在，我们的代码在ID_TYPE为uint64_t时进行编译。我们的目标是重写该代码，以便在ID_TYPE为uint64_t时和为tm_tt_id_t时都编译。如果我们可以增量地转换到该状态，那么一旦ID_TYPE为tm_tt_id_t时所有代码都编译完毕，我们就可以将其设为默认值。</p><p>  uint64_t get_data(uint64_t asset){ const tm_the_truth_object_o *asset_r = tm_tt_read(tt, asset); uint64_t data = api-&gt;get_subobject(tt, asset_r, TM_TT_PROP__ASSET__OBJECT); return data;}</p><p>Uint64_t get_data(uint64_t资产){const tm_the_true_object_o*Asset_r=tm_tt_read(TT，ASSET)；uint64_t data=api-&gt；get_subbobject(TT，ASSET_r，TM_TT_PROP__ASSET_OBJECT)；返回数据；}。</p><p>  ID_TYPE get_data(ID_TYPE asset){ const tm_the_truth_object_o *asset_r = tm_tt_read(tt, asset); ID_TYPE data = api-&g</p><p>ID_TYPE GET_DATA(ID_TYPE ASSET){const tm_the_true_object_o*ASSET_r=tm_tt_read(TT，ASSET)；ID_TYPE DATA=api-&g。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ourmachinery.com/post/step-by-step-programming-incrementally/">https://ourmachinery.com/post/step-by-step-programming-incrementally/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/增量/">#增量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030394.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2c2bdfa2dc7529c1988bef213a9e80ef.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030394.html">Kite将其AI代码完成从2种扩展到13种编程语言</a></div><span class="my_story_list_date">2020-10-22 9:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029787.html"><img src="http://img2.diglog.com/img/2020/10/thumb_e53752bd18d47c7f19ff44e8b34448be.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029787.html">如何学习编程：成为软件工程师的路线图</a></div><span class="my_story_list_date">2020-10-19 20:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029744.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2b1c3f1133dbde2d6b5698f13be2ca90.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029744.html">克里斯·拉特纳：计算和编程语言的未来[音频]</a></div><span class="my_story_list_date">2020-10-19 15:17</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029727.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c3a445836064069f2ad57496e87f5ed2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029727.html">克里斯·拉特纳：计算和编程语言的未来--莱克斯·弗里德曼</a></div><span class="my_story_list_date">2020-10-19 14:35</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>