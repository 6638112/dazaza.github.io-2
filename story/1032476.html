<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>迷你编译器：lexing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">迷你编译器：lexing</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 19:54:31</div><div class="page_narrow text-break page_content"><p>我一直想做自己的编译器。编译器是我日常工作中不可或缺的一部分，我经常使用它们的成果。不久前，当我浏览TempleOS源代码时，在：：/Demos/Lessons文件夹中发现了MiniCompiler.HC，我有点吃惊。它实现了一个从简单的数学表达式到AMD64字节码的两阶段编译器(完成后将其比特转换为代码稍后跳转到的数组)，并且有很多关于编译器如何工作的内容要教授。对于那些手头没有TempleOS虚拟机的人，这里有一段MiniCompiler.HC运行的视频：</p><p>您输入一个数学表达式，编译器构建它，然后输出一堆程序集并运行它以返回结果。在本系列中，我们将创建该编译器的一个面向WebAssembly的实现。该编译器将用Rust编写，除了最后的字节码编译和执行阶段外，将只使用标准库。这里发生了很多事情，所以我希望这至少是一个三集的系列。源代码在xe/mini编译器中，如果您想详细了解的话。跟着走，让我们在路上学到一些生锈的东西！</p><p>像C这样的语言的编译器是建立在这里的基础之上的，但是它们要复杂得多。</p><p>理想情况下，我们应该能够将括号嵌套到我们想要的深度，而不会出现任何问题。</p><p>查看这些值，我们可以注意到一些模式，它们将使解析变得容易得多：</p><p>这将创建一个名为minicompiler的文件夹和一个名为src/main.rs的文件。在编辑器中打开该文件，并将以下内容复制到其中：</p><p>//src/main.rs/编译器可以执行的数学运算。#[Derate(Debug，Eq，PartialEq)]枚举Op{Mul，Div，Add，Sub，}/编译器的所有可能令牌，这将编译器限制为/简单的数学表达式。#[Derate(Debug，Eq，PartialEq)]枚举Token{EOF，Number(I32)，Operation(Op)，LeftParen，RightParen，}。</p><p>在编译器中，标记指的是您正在使用的语言的各个部分。在这种情况下，每个令牌代表程序的每个可能部分。</p><p>然后，让我们启动一个函数，该函数可以将程序字符串转换为一串令牌：</p><p>等等，你怎么处理不好的输入，比如不是数学表达式的东西？这个函数不应该失败吗？</p><p>你说得对！让我们做一个代表错误输入的小错误类型。看在创造力的份上，让我们称它为BadInput：</p><p>//src/main.rsuse std：：Error：：Error；Use std：：fmt；/输入错误时返回的错误。这只会告诉用户它是错误的，因为调试信息不在这里的范围内。抱歉。#[Deriate(Debug，Eq，PartialEq)]struct BadInput；//需要显示错误。Iml fmt：：Display for BadInput{fn fmt(&amp；self，f：&amp；mut fmt：：Formatter)-&gt；fmt：：result{write！(F，&#34；Something is Bad，Good&34；)}}//默认错误实现将在此执行。BadInput{}。</p><p>现在我们有了我们想要的函数类型，让我们通过设置结果并对输入字符串中的字符进行循环来开始实现lex()：</p><p>//src/main.rsfn lex(input：&amp；str)-&gt；result&lt；vec&lt；Token&gt；，BadInput&gt；{let mut result：vec&lt；Token&gt；=vec：：new()；对于input.chars(){TODO！(&#34；Implementate this&#34；)；}OK(Result)}。</p><p>看一下前面的示例，我们可以开始编写一些样板来将字符转换为标记：</p><p>//src/main.rs//...对于input.chars(){匹配字符{//跳过空白&#39；&#39；=&&gt;；继续，//结束字符&#39；；&#39；\n&#39；=&gt；{result t.ush(Token：：EOF)；Break；}//数学运算&#39；*&#39；=&gt；result t.ush(Token：：operation(opp：：mul))，&#39；/&#39；=&gt；Result.Push(Token：：Operation(Op：div))，&#39；+&#39；=&gt；Result.Push(Token：：Operation(Op：：Add))，&#39；-&#39；=&gt；Result.Push(Token：：Operation(Op：：Sub))，//括号&#39；(&#39；=&gt；result t.ush(Token：：LeftParen)，&#39；)=&gt；Result t.ush(Token：：RightParen)，//Numbers&#39；0&#39；|&#39；1&#39；|&#39；2&#39；|&#39；3&#39；|&#39；4&#39；|&#39；5&#39；|&#39；6&#39；|&#39；7&#39；|&#39；8&#39；|&#39；9&#39；=&gt；{TODO！(&#34；实现数字解析&#34；)}//其他一切都是错误的input_=&gt；return err(BadInput)，}}//...</p><p>//src/main.rs//...Use Op：：*；Use Token：：*；Match Character{//...//数学运算&#39；*&#39；=&gt；result t.ush(Operation(Mul))，&#39；/&#39；=&gt；result t.ush(Operation(Div))，&#39；+&#39；=&gt；result t.ush(Operation(Add))，&#39；-&#39；=&gt；Result t.ush(Operation(Sub))，//括号&#39；(&#39；=&gt；result t.ush(LeftParen)，&#39；=&gt；result t.ush(RightParen)，//...}//...。</p><p>您几乎可以在程序中的任何位置使用USE语句。但是，为了保持更好的流畅性，Use语句就在这些示例中需要它的位置旁边。</p><p>现在我们可以开始享受解析数字的乐趣了。在编写MiniCompiler时，Terry Davis使用了类似以下内容的方法(为可读性添加了空格)：</p><p>案例&#39；0&#39；...&#39；9&#39；：i=0；do{i=i*10+*src-&#39；0&#39；；src++；}While(&#39；0&#39；&lt；=*src&lt；=&#39；9&#39；)；*num=i；</p><p>这会将中间变量i设置为0，然后消耗输入字符串中的字符，只要它们介于&#39；0&#39；和&#39；9&#39；之间。作为以10为基数输入的数字的一个巧妙副作用，您可以将40概念化为(4*10)+2。因此，它将旧数字乘以10，然后将新数字与结果数字相加。我们的设置不会让我们那么容易实现，但是我们可以根据以下规则通过一些堆栈操作来模拟它：</p><p>如果最后一个是一个数字，则将该数字乘以10，然后将当前数字加到该数字上。</p><p>否则，将节点推回RESULT，并将当前数字也推入RESULT。</p><p>//src/main.rs//...//Numbers&#39；0&#39；|&#39；1&#39；|&#39；2&#39；|&#39；3&#39；|&#39；4&#39；|&#39；5&#39；|&#39；6&#39；|&#39；7&#39；|&#39；8&#39；|&#39；9&#39；=&gt；{let num：I32=(Character as U8-&#39；0&#39；as U8)as I32；if result t.len()==0{result t.ush(number(Num))；Continue；}let last=result t.op().unrapp()；Match last{number(I)=&gt；{result t.ush(number((i*10)+num))；}_=&gt；{result t.ush(Last)；result t.ush(number(Num))；}}//...</p><p>这不是世界上最健壮的数字解析代码，但是目前它已经足够了。如果你能辨认出边缘的话就加分！</p><p>这应该包括该语言的标记。让我们写一些测试，以确保一切都像我们想象的那样工作！</p><p>RUST在标准库中内置了一个健壮的测试框架。我们可以在这里使用它来确保我们生成的令牌是正确的。让我们将以下内容添加到main.rs的底部：</p><p>#[cfg(Test)]//告诉编译器仅在运行测试时编译此代码{use Super：：{Op：：*，Token：：*，*}；//将以下函数注册为测试函数#[test]FN BASIC_Lexing(){assert！(lex(&#34；420+69&#34；).is_ok())；assert！(lex(&#34；Tacos Are Tavy&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；)，确定(vec！[number(420)，Operation(Add)，number(69)])；assert_eq！(lex(&#34；(30+560)/4&#34；)，OK(vec！[LeftParen，number(30)，Operation(Add)，number(560)，right Paren，Operation(Div)，number(4)])；}}。</p><p>这个测试可以而且可能应该扩展，但是当我们运行货物测试时：</p><p>$Cargo测试编译迷你编译器v0.1.0(/HOME/cadey/code/xe/minicompiler)在0.22s内完成测试[未优化+调试信息]目标运行target/debug/deps/minicompiler-03cad314858b0419running 1测试测试：BASIC_LEXING...。OK测试结果：OK。1通过；0失败；0忽略；0测量；0过滤掉。</p><p>嘿，马上！我们验证了所有解析都工作正常。最小的用例应该足以涵盖该语言的所有功能。</p><p>第一部分就到这里。我们今天讲了很多。下次我们要在程序上运行avalidation pass时，将中缀表达式转换为反向Polishnotation，然后也开始将其编译为WebAssembly。到目前为止，这一直很有趣，我希望你能从中学到东西。</p><p>这篇文章发表在2020年M10 29上。自发表以来，事实和情况可能发生了变化。如果有什么不对劲或不清楚的地方，请在匆忙下结论之前与我联系。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://christine.website/blog/minicompiler-lexing-2020-10-29">https://christine.website/blog/minicompiler-lexing-2020-10-29</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031619.html"><img src="http://img2.diglog.com/img/2020/10/thumb_99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031619.html">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</a></div><span class="my_story_list_date">2020-10-28 5:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031022.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6e4f4bad7bb9be861f0eccbbc527e64d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031022.html">罗马工具链：Linter、编译器、绑定器等</a></div><span class="my_story_list_date">2020-10-25 7:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030829.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b71f23a653e4ac6df1ae71037508c3c3.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030829.html">我自己的编译器基础结构上的我自己的C编译器</a></div><span class="my_story_list_date">2020-10-24 7:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030633.html"><img src="http://img2.diglog.com/img/2020/10/thumb_21054de7abd23919431e2a8a7caa1f96.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030633.html">使用Bakeware将Elixir应用程序编译为单个可执行的二进制文件</a></div><span class="my_story_list_date">2020-10-23 2:54</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>