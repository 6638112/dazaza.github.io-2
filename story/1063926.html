<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>戴夫学会叉 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">戴夫学会叉 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-07 04:27:10</div><div class="page_narrow text-break page_content"><p>在这篇文章中，我制作了一个以Zig编写的真实的工作交互式壳牌。虽然基本上是一个玩具，它展示了Fork（）系统调用的令人难以置信的优雅，并且可以绝对没有运行时内存扩展的isan示例。</p><p> 你也可以直接去回购以查看Zigish的来源。但请记住，这是一个玩具壳。它的价值是在学习练习中。</p><p> 这一天显然是出现的。用颤抖的双手，我达到了我的树干和＃34;当我终于学习系统语言时写的节目;并从堆的顶部挑选书签：在c.a shell中写一个shell！惊人的。这是我的＆＃34;铲斗列表＆＃34;程序 - 就像游戏，操作系统，文本编辑器或编程语言（但比任何一个更容易）。</p><p> 我与C教程一起开始。 shellloop（）函数是真实的工作：</p><p> const std = @import（＆＃34; std＆＃34;）; pub fn main（）！u8 {const stdin = std.io.getstdin（）。reader（）; const stdout = std.io.getstdout（）。作家（）;尝试stdout.print（＆＃34; ***你好，我是一个真正的shell！*** \ n＆＃34;。{}）;尝试shellloop（stdin，stdout）;返回0;}</p><p> 我的main（）在它中有一点，因为与c不同，Zig标准库没有隐含到STDIN和STDOUT的局部处理。所以我得到了一个读者和作家托盘，把它们传递给我的循环函数。（事实上，有很多内容在C中隐含，并在Zig.i中明确地说明这个＆＃34;没有隐藏的东西＆＃34;方法。 ）</p><p>   如果您是Zig新的，请！U8和！Void返回这两个功能的返回类型错误联合类型的Areexamples。也就是说，其值将是指定值或错误。您还可以指定错误的错误可以返回：fooError！ReticulatedFoo。 </p><p>即使它是短暂的（目前，整件事只有45行！SED＆＃39; / ^ $ / d; / ^ * \ / \ // d＆＃39; src / main.zig | wc -l） ，我不会经过每一条节目的一行。</p><p> 让我们使用一个简单的shell提示，因为这是一个很少的shell：</p><p>  再次，如果您是Zig的新手，请尝试将任何错误从打印（）向上调用堆栈（到main（），在这种情况下）。这就是为什么我们必须拥有！void错误返回联盟类型。</p><p> 第二个参数中的{}语法是A＆＃34;元组＆＃34; （匿名结构）将保存我们希望在第一个参数中打印的任何值，格式化字符串。</p><p> var input_buffer：[max_input] u8 =未定义; var input_str =（尝试stdin.readuntildelimiteroreof（input_buffer [0 ..]，＆＃39; \ n＆＃39;））orelse {// no输入，可能ctrl-d（eof ）。打印换行符并退出！尝试stdout.print（＆＃34; \ n＆＃34; {}）;返回;};</p><p> 这里，ReadpuntIndelimiteroreOf（）函数将切片（指针向长度）带到我在阵列Input_Buffer中静态分配的块的块。它读取输入（＆＃34;煮熟的模式＆＃34;），直到它命中whewline分隔符开字符。然后它返回包含输入的新切片。</p><p> 接下来，我们需要将输入拆分为命令，它的arguments.i将使用返回splinterator的拆分（）函数以最简单的方式执行以下操作： </p><p>我们将稍后回到此循环中的那一刻。现在，只要知道我们已经拆分了输入字符串并存储了碎片：ls -al foo变为ls，-al和foo。</p><p> 我们有命令和任何参数。我们已准备好拼接一个新的进程并执行命令。</p><p>  const fork_pid = try std.os.fork（）;如果（fork_pid == 0）{//我们是孩子，请执行命令。} else {//我们是父父，等待孩子退出。}</p><p> 我不了解你，但我盯着那个时候暂时盯着一段时间。流程ID（PID）可以在同一节目中有两个不同的东西吗？</p><p>  Fork（）通过重复调用进程创建新进程。新进程称为子进程。调用Process被称为父进程。子进程和父进程在单独的存储空间中运行。在Fork（）时，两个内存空间都有SameContent。</p><p> 因此，在我们调用上面的fork（）后，我们现在有两个几乎相同的进程运行相同的代码，并且在内存中具有相同的值。</p><p>  其中一个是父进程，返回值是子进程的PID。 </p><p>IF语句是我们如何将父流程做一件事和儿童进程进行换句话说。</p><p>  您可能会想知道是否重复了该过程，并且所有的跑步站都非常低效率。我也想知道。 Fork（）的现代实现使用副本写入仅在其奠定了奠定了重复数据。在此之前，它实际上是内存中的数据。至于Program的指令代码，它处于只读段，因此它永远不需要重复。</p><p> 对于这个简单的外壳，父母的工作很容易。我们只是等待着那索切尔退出。</p><p> waitpid（）系统调用等待特定进程（通过PID）具有状态更改（终止，停止，恢复）。如果父母的分支，它在我们的后叉之外：</p><p> if（fork_pid == 0）{//我们是孩子，请执行命令。} else {const wait_result = std.os.waitpid（fork_pid，0）; if（wait_result.status！= 0）{try stdout.print（＆＃34;命令返回{}。\ n＆＃34; {wait_result.status}）; }}</p><p> 如果孩子的返回状态为0，则表示错误，所以我们将打印出来。</p><p> 重复的子进程现在具有一个有趣的作业：用请求的命令替换自己的命令.WE使用system调用的evally of system调用。 </p><p>if（fork_pid == 0）{const结果= std.os.execvpez（args_ptrs [0]。？，＆amp; args_ptrs，＆amp; env）;尝试stdout.print（＆＃34;错误：{} \ n＆＃34; {结果}）;} else {const wait_result = std.os.waitpid（fork_pid，0）; if（wait_result.status！= 0）{try stdout.print（＆＃34;命令返回{}。\ n＆＃34; {wait_result.status}）; }}</p><p> 这将从Zig标准库中使用execvpez（）变体，该库将哪些提供者和任何环境数据到新过程。此变体也使用$ pathto解析命令而不包含名称。</p><p> 所以exec（）呼叫并不像Fork（）那样吹脑力，但他们仍然很有趣来思考。在成功调用exec（）函数后，不要在子进程中的其余代码中运行。伊萨已被新的命令流程所取代！</p><p> 这就是为什么我们打印错误：下一行的消息。线路曾经执行的唯一原因是因为exec（）调用失败了。</p><p> 一旦孩子退出，waitpid（）调用返回返回和父级继续运行，循环回提示并从用户获取下一个命令。</p><p>  顺便说一下，我从C教程中获得了这个shell的基本结构，但是对于系统调用的古统，我通过Michael Kerrisk读取了Linux编程接口中的第24-27章。我期待着在优秀的书中花费更优质的时间。</p><p> 我提到我会回到那个spliniderator循环的内部，在那里我们用用户输入字符串的命令和参数块做点什么。 </p><p>我不介意说，我花了一个整个晚上，一晚睡觉，然后艾滋病变得正确。原因是我对TheIDEA陷入困境，即我的shell不会在运行时进行任何动态内存分配。这就是我从zig标准库中选择的execvpez（）以与exec（）呼叫接口。它不需要分配器。要避免分配器，它要求您将其与Sentinel终止的多项指针提供。</p><p> 原则很简单：许多项目指针是Zig的说法，＆＃34;这指向这种类型的一些未知数量的项目（具有已知尺寸）。＆＃34;使用许多项目指针安全地，您需要了解确切的尺寸，或者您在结束时放置Sentinel值，当您到达时作为停车标志。</p><p>  许多项目指针到由Sentinel值0终止的U8值列表的语法为[*：0]。</p><p> （ZIG允许您选择子类型的任何值作为Sentinel值。您可以使用81或＆＃39; Q＆＃39;和字母＆＃39; Q＆＃39;将是Sentinel价值！）</p><p> 嗯，对于命令参数参数参数argv_ptr，execvpez（）想要类型[*：null] const的值？[*：0] const u8，它是一个＆＃34; null终止的许多项目指针到oncstant列表零终止的多项指针到常量无符号八个比特内容列表。</p><p>  [*：null]意味着我们指向具有空终止器的项目列表。</p><p>  ？意味着以下每个值都是＆＃34;可选的＆＃34;，即表示它们可能为null。这是必需的，因为许多项目指针的Sentinel值必须是子类型的值！ </p><p>[*：0]表示（可选）的每个（可选）值本身是零终止的多项指针（零是＆＃34;空字符＆＃34;在ASCII和Unicode中）。</p><p>  U8表示我们指向的实际数据是一系列无符号八位整数（这是我们存储ASCII或UTF-8编码的Unicode值的序列）。</p><p>  我们可以跳过我的失败尝试，并直接到我最终的内容：</p><p> var args：[max_args] [max_arg_size：0] u8 =未定义; var args_ptrs：[max_args：null]？[*：0] u8 =未定义; ... var i：mexize = 0; while（tokens.next（） ）| TOK | {std.mem.copy（U8，＆amp; args [i]，tok）; args [i] [tok.len] = 0; //添加sentinel 0 args_ptrs [i] =＆amp; args [i]; i + = 1;} args_ptrs [i] = null; //添加sentinel null</p><p> 我使用std.mem.copy（）函数将spertaterator next（）方法返回的切片中的字节复制到args存储阵列。</p><p> 我在复制的字节后手动添加0值。 Zig仅强制执行阵列以终端结尾，但它不会自动将其插入到我们的阵列中，因为它无法知道这是我们想要的（对于所有知识，我们想在这个之后追加另一个字符串）。</p><p> 然后我立即将指针存储到我的args_ptrs数组中的存储阵列插槽。 </p><p>（在我早期的一些尝试失败的尝试中，我试图从[n] [m：0] u8到[*：null] [*：0] u8被证明是很多精神体操，令人惊讶的数量代码，我从来没有得到它。）</p><p> 让我们来看看我用这个信息调用execoke的位置：</p><p>  第一个参数（命令）是来自args_ptrs数组中的第一个项目。我＆＃34;未包装＆＃34;可选（可能为null）指针。？如果它为null，则程序将崩溃。</p><p> 第二个参数只是args_ptrs数组本身的地址。 （预计，但不是必需的，它与第一个参数相同）。</p><p> 最后，最后一个参数是包含环境的另一个结构的地址（您知道，环境变量如$ PATH）。对于此玩具，我刚刚在null中传递。但不仅仅是任何null，它的null：</p><p>  这不仅仅是簿记。它很重要，null是多大（0000和00000000占用不同数量的内存）。</p><p> 要查看此问题的示例，请查看本文遇到的（在我的失败尝试中获取我的args指针，导致efault错误）：无法exec的exec。 </p><p>让我们玩Zigish！顺便说一下，名字代表＆＃34; Zig interactiveshell＆＃34;但我也在玩＆＃34; ish＆＃34;英语意思的修饰符＆＃34;主要是，有点，sorta＆＃34;</p><p> $ zig build $ zig-cache / bin / zigish ***你好，我是一个真正的shell！ ***＆gt; lsreadme.adoc build.zig src zig-cache＆gt; Datesat 6月5日13:26:59 EDT 2021＆GT; fooError：Error.FiLenotFound＆gt;＆gt;＆gt; ^ D $</p><p>   值得注意的是，任何需要特定环境的东西都有问题。尝试运行Zig Build fromzigish：appdatadirunavailable时，我收到了此错误。我追溯到当I exec（）时将在$ path环境变量传递到子进程的事实。呃，没什么大不了的。</p><p> 最后（出于某种原因，这一直是使这个＆＃34;桶列表＆＃34;程序）的一部分，我想将其设置为用户的登录外壳。</p><p> 首先，我将在/ usr / bin中对它进行符号链接/给予它官方Flair：</p><p>   $ sudo useradd  -  shell / usr / bin / zigish ziggy $ sudo passwd ziggy $ su ziggy ***你好，我是一个真正的shell！ ***＆gt;</p><p> 是的，我真的确实重新启动并以用户＆＃39登录; Ziggy＆＃39;之后只是看它＆＃34;对于真实的和＃34; </p><p>我学到了很多事情，它是（大多数）的乐趣。 我强烈推荐在某个时候写下你的壳牌。 这是您可以幸福的最大爆炸项目之一。  如果您正在寻找C替换，肯定会给Zig拍摄。 它仍然是正在进行的作用，事情正在迅速变化，但它拥有我见过的最好的社区。  好的，所以，贝壳完成了！ 现在用于文本编辑器，操作系统，游戏，编程语言，以及Web浏览器。 :-) </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://ratfactor.com/zig/forking-is-cool">http://ratfactor.com/zig/forking-is-cool</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/学会/">#学会</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learns/">#learns</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1056323.html"><img src="http://img2.diglog.com/img/2021/4/thumb_b3d0f0d8723cb9f25691c390d53f59b7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056323.html">人们如何学会成为弹性（2016年） </a></div><span class="my_story_list_date">2021-4-6 3:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1054970.html"><img src="http://img2.diglog.com/img/2021/3/thumb_1df5b28830fc31f85dbd847fa85848f5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054970.html">今天，我学会了宝马收取额外的费用，因为'不要盲人其他人的软件更新 </a></div><span class="my_story_list_date">2021-3-29 18:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029790.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5c6abf016fc501755456c9f2c7a12d0c.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029790.html">当我学习的时候，我学会了闭嘴</a></div><span class="my_story_list_date">2020-10-19 20:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1023612.html"><img src="http://img2.diglog.com/img/2020/9/thumb_88757519fa1ccb93117d6ff61eefab69.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1023612.html">论“学会总结”</a></div><span class="my_story_list_date">2020-9-13 3:52</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>