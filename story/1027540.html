<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Clojure中模拟机器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在Clojure中模拟机器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-07 10:39:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/18e2f2f2bc88612e611f3a093c344b3e.png"><img src="http://img2.diglog.com/img/2020/10/18e2f2f2bc88612e611f3a093c344b3e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我的联合创始人乔和我最近完成了SiCp。这是一次令人费解的经历：您只需从3个概念开始，然后递归地构建代数方程解算器、电路仿真器、4个解释器和一个编译器。</p><p>在某种程度上，你会体验到一种发自内心的感觉：如果你被丢在森林里，…。您可以创建自己的计算机。对这种感觉贡献最大的项目是创造一个机器模拟器。</p><p>我们偏离了本书，用Clojure而不是Scheme编写模拟器。我们可以在Clojure中使用不可变的数据结构和更高级别的概念来压缩解决方案，以至于我认为您可以在几天的时间内构建自己的解决方案。</p><p>本文将指导您完成这项工作：让我们构建一个机器模拟器，历经几天的黑客攻击！我希望这能激励您尝试Clojure，并更深入地了解SiCp。</p><p>在我们模拟普通机器之前，让我们先考虑一下混凝土机器。我们怎样才能创造出一台能计算阶乘的机器呢？</p><p>(Defn阶乘[n](循环[res 1计数器1](if(&gt；Counter n)res(Recur(*Counter res)(Inc Counter)。</p><p>嗯，我们需要一种方法来跟踪计数器、res和n。要做到这一点，我们需要一个存储信息的设备。</p><p>我们可以说，如果灯泡亮着，那就代表数字1，如果灯泡熄灭了，那就代表数字0。</p><p>如果我们在设备中有一串灯泡，我们可以将这些灯泡的状态解释为越来越大的二进制数。例如，我刚才向您展示的设备中的灯泡将代表“10101”，这是“21”的二进制表示。</p><p>现在，想象一下，任何时候都有一串其他导线连接到这个设备。这些电线为灯泡带来了“新的”电荷，但有一点不同：传入的电荷目前还不会影响灯泡内部。</p><p>注意“a”灯泡的来电是如何“关闭”的，但里面的灯泡仍然亮着。相反，传入费用是亮的，但灯泡是关的。如果设备可以做到这一点，这意味着无论设备内部的灯泡的费用是什么，都是一个存储值。非常酷！</p><p>现在，我们需要这些传入的电线在某个时刻做一些事情。如果这台设备有一个“保存”按钮会怎么样。</p><p>一旦我们按下“保存”，输入的电流就会转移到盒子里：</p><p>这里，灯泡“a”从“开”变为“关”，灯泡&#34；b&#34；从&#34；开&#34；变为&#34；关。</p><p>我们还需要一种方式将内部内容的状态共享给其他设备。要做到这一点，我们所需要做的就是让一束电线离开我们的设备，这些电线带有与灯泡相同的电荷：</p><p>现在，如果我们把这些传出的电荷连接到其他设备上，那个设备就会收到存储在这个设备上的“号码”。</p><p>我们刚才描述的内容类似于计算机的寄存器(1)。寄存器使我们能够存储和共享信息。</p><p>现在，我们可以使用三个寄存器来存储res count和n的值。</p><p>接下来，我们需要一个可以“添加”两个寄存器的设备。想象一下这样一个设备，它有两个寄存器的传入线路和一个寄存器的传出线路：</p><p>如果设备能够以这样的方式连接那些传入的线路，即传出的线路代表这些寄存器的“相加”，我们就有了一个“加法器”设备！</p><p>在上面的示例中，左边的寄存器表示“10101”(21)，右边的寄存器表示“00001”(1)。输出线充电为“10110”…。代表22个人！</p><p>类似地，我们可以有一个器件，它有两条寄存器值的输入线和一条寄存器值的输出线：</p><p>如果我们能以这样一种方式连接输入导线，使输出导线代表乘法的结果，那么我们就会有一个乘法装置！</p><p>上面左边的寄存器表示“00101”(5)，右边的寄存器表示“00010”(2)，出线的电荷是“01010”(10)。好的!。这就给了我们一个乘法器。</p><p>我们还需要一个装置。假设一个设备需要两条相当于寄存器的输入线，但只有一条输出线：</p><p>如果我们可以这样组合输入线，即当左侧寄存器较大时，输出线为“ON”，否则为OFF，我们可以将其用作比较器机器！</p><p>如果我们有所有这些机器，我们可以用这样的方式连接它们，这样我们就可以计算阶乘：</p><p>在这里，我们将res和Counter的输出线连接到*机器。我们将*机器的输出线连接起来，作为RES的输入线。</p><p>这样，如果我们按“A”，我们将“存储”计数器与res相乘的结果！</p><p>类似地，我们将COUNTER和一个保持值1的寄存器的输出线连接到+机器。</p><p>如果我们按“B”，计数器将与加1的结果一起存储！</p><p>接下来，我们将COUNTER和n连接起来。例如，如果我们将一个灯泡连接到&gt；机器的输出线上，那么每当它打开时，我们就会知道COUNTER大于n。</p><p>(循环[资源1计数器1](IF(&gt；计数器n)资源(RECUR(*计数器资源)(INC计数器)。</p><p>想象一下，如果我们有“数据路径”机器。如果我们遵循下面的食谱会发生什么：</p><p>&#34；按A&#34；。这将使用*计算机在RES和计数器上的结果更新RES。</p><p>“按B键”。这将使用1上的+机器和计数器的结果更新计数器。</p><p>如果我们反复这样做，一旦连接到&gt；机器输出的灯泡打开，RES将包含阶乘的结果！</p><p>很酷，但是这种体力劳动会很烦人。不过，如果你看了这些说明，就会有一个相当重要的见解：所有这些说明都很简单：看一下给灯泡充电，按下按钮...&#34；。</p><p>事实上，它们是如此简单，以至于我们可以连接一台机器来通过那个食谱！想象一下，如果我们创建了一台机器，它可以根据&gt；机器的输出线是否打开来为我们“按”按钮：</p><p>现在，在这个阶段，您可能在想：究竟如何产生表示乘法的输出线？+是怎么工作的，控制器又是怎么走的呢？</p><p>如果你仔细想想，这些都可以简化为非常简单的机器。它们甚至不一定是电子的：</p><p>想象一下，你有一个球从山上滚下来。您可以通过将RES和计数器放在天平上来构建类似于&gt；机器的东西：根据哪个更大，球将走不同的路径。</p><p>有了足够的精力、空间、时间和独创性，你真的可以在山上用一个球建造这一切。现在，你不一定会这么做(2)，但是你可以想象组成我们机器的电子部件是如何类似的简单的逻辑机器：如果关闭就打开，如果打开就关闭，等等。这些逻辑机器被称为“逻辑门”。你可以查一下，但希望我很快就能给你写一篇关于这些机器的文章🙂。</p><p>现在，我们拿出我们的机器，看看如何用简单的设备来建造它们。我们怎么能模拟这些机器呢？</p><p>为了模拟这些机器，我们需要将我们的图片描述转换成计算机可以操作的东西。计算机可以更好地处理文本：让我们创建一种语言来描述这些机器。</p><p>(def阶乘指令&#39；(START(TEST(OP&&gt;；)(REG COUNTER)(Reg N))(BRANCH(LABEL DONE))(分配RES(OP*)(REG COUNTER)(REG RES))(ASSIGN COUNTER(OP+)(REG COUNTER)(Const 1))(GOTO(LABEL START))DONE))。</p><p>我们的分支指令检查测试指令是否说是。如果是，它将移动到Done。否则它就不工作了，机器就向前移动一步。</p><p>之后，我们的(ASSIGN RES)表达式类似于“按A”。(分配计数器类似于“按下B”，而(GOTO(标签开始)类似于将我们带回到起点的箭头。</p><p>有了这个文本表示，我们可以构建一个解释器并模拟我们的机器。我们开始吧！</p><p>我们的机器在Clojure中的状态是什么？那么，我们如何用Clojure来表示大多数东西呢？用地图！让我们将机器的状态表示为地图：</p><p>注册表映射可以保持寄存器到值的映射。Label→idx可以在指令列表中保持标签到其idx的映射。</p><p>这样，我们就可以使用我们语言中最基本的部分：我们使用(const…。(REG..。AND(标签…。到处都是。</p><p>如果我们的机器看到(Reg Foo)，它应该查找foo寄存器中的任何内容，并返回。</p><p>如果我们的机器看到(标签为foo)，它应该在我们的指令表中返回正确的索引。</p><p>(Def Tag First)；(tag&#39；(Const 1))=&gt；const(Defn tag-of？[sym s](=sym(Tag S)；(tag-of？&#39；const&#39；(Const 1))=&gt；true(定义解析原语[{：项[注册表映射标签-&gt；idx]：AS机器状态}prim-exp](condp tag-of？Prim-exp&39；const(Second prim-exp)&#39；reg(获取注册表映射(Second prim-exp))&#39；Label(Label-&&gt;；IDX(Second prim-exp)。</p><p>我们的解析原语函数获取机器状态，并根据表达式的标记执行正确的操作。</p><p>(解析基元出机器状态-V0&#39；(Const 1))；=&gt；1(解析基元出机器状态-V0&#39；(Reg N))；=&gt；10(解析基元出机器状态-V0&#39；(标签完成))；=&gt；5。</p><p>好的，我们有基本体在工作，让我们更上一层楼。我们的模拟器允许我们访问其他一些机器，如*+和&gt；</p><p>&#39；(...(OP&gt；)(REG计数器)(REG N))&#39；(...(OP*)(REG COUNTER)(REG RES))&#39；(...(OP+)(REG COUNTER)(Const 1))。</p><p>当我们的模拟器看到这些指令时，它需要查找与OP相对应的机器，并使用提供的原始参数运行它。</p><p>(def ex-Machine-state-v1{：注册表映射{&#39；n 10&#39；分辨率1&#39；计数器1}：标签-&gt；idx{&#39；开始0&#39；完成5}：操作映射{&#39；**&#39；++&#39；&gt；&gt；}})。</p><p>(def operation-sym(Comp Second First))；((op&gt；)...)=&gt；&gt；(def operation-args rest)；((op&gt；)(Reg Count)(Reg N))=&gt；((注册表计数器)(Reg N))(defn parse-operation[{：keys[op-map]：as data}op-exp](let[op-fn(get op-map(operation-sym op-exp)valed-args(map(部分解析原始数据)(operation-args op-exp))](Apply op-fn valed-args))。</p><p>(parse-operation ex-Machine-state-v1&#39；((op&gt；)(Reg Count)(Reg N))；=&gt；false(parse-operation ex-Machine-state-v1&#39；((op*)(Reg Count)(Reg Res)；=&gt；1(parse-operation ex-Machine-state-v1&#39；((op+)(Reg Count)(Const 1)；=&gt；2。</p><p>现在是时候更上一层楼，开始实现我们的实际指令表达式了。</p><p>让我们从赋值开始。分配有两种形式。我们可以指定一个原始值：</p><p>一旦赋值完成，我们的机器状态需要“前进”到下一条指令。</p><p>(def ex-Machine-state-v2{：注册表映射{&#39；n 10&#39；分辨率1&#39；计数器1}：Label-&gt；idx{&#39；start 0&#39；Done 5}：op-map{&#39；**&#39；++&#39；&gt；&gt；}：idx 0})。</p><p>我们现在有一个IDX状态，它跟踪指令列表中机器的当前索引。这将允许我们通过简单地递增索引来“向前移动”。</p><p>(def Assign-reg-name Second)；(Assign Foo...)=&gt；Foo(def Assign-Operator#(nth%2))；(Assign Foo(Const 1)=&gt；(def operation-exp？(comp(part tag-of？&#39；op)Assign-Operator))；(Assign Foo(op...=&gt；true(def assign-operation-exp(Part Drop 2)；(Assign Foo(op*)...)=&gt；((op*)...)(Defn exec-Assign&34；Assign有两种形式：(Assign reg-name&lt；primitive-op&gt；)i.E(Assign Foo(Const 1))(Assign reg-name&lt；operation&lt；args...&gt；)i.E(Assign Foo(op*)(Const 2)(Reg Foo))&#34；[DATA INS](让[注册表名(ASSIGN-REG-NAME INS)VAL(IF(OPERATION-EXP？INS)(解析操作数据(ASSIGN-OPERATION-EXP INS))(解析原语数据(ASSIGN-OPERATOR INS))](-&gt；DATA(ASSOC-IN[：REGISTRY-MAP REG-NAME]VAL)(UPDATE：IDX INC))。</p><p>(SELECT-KEYS(EXEC-ASSIGN EX-MACHINE-STATE-v2&#39；(ASSIGN COUNTER(CONST 0)[：注册表映射：IDX])；=&gt；{：注册表映射{n 10，RES 1，Counter 0}，：IDX 1}(SELECT-KEYS(EXEC-ASSIGN EX-MACHINE-STATE-v2&#39；(ASSIGN COUNTER(CONST 10)[：REGISTRY-MAP：IDX])；=&gT；{：注册表映射{n 10，分辨率1，计数器10}，：idx 1}。</p><p>(goto&lt；primitive-exp&gt；)应该将我们机器中的idx设置为基元表达式的结果值：</p><p>(def GOTO-DEST秒)；(GOTO(标签完成))=&gt；(标签完成)(DEFN EXEC-GOTO[DATA INS](ASSOC DATA：IDX(Parse-Primitive Data(GOTO-DEST INS)</p><p>(SELECT-KEYS(EXEC-GOTO EX-MACHINE-STATE-v2&#39；(GOTO(标签完成)[：Label-&gt；idx：idx])=&gt；{：Label-&gt；idx{Start 0，Done 5}，：idx 5}。</p><p>我们就快到了！接下来，让我们考虑一下测试和分支指令：</p><p>请记住，当测试运行时，我们需要确定OP是否返回是或否，然后我们将机器向前移动。当分支运行时，我们需要检查最后一条测试指令是否说是。如果是，我们就跳到分支目的地。否则，我们不执行操作，并将指令表向前移动一位。</p><p>(def ex Machine-state-v3{：Registry-map{&#39；n 10&#39；res 1&#39；Counter 1}：Label-&gt；idx{&#39；start 0&#39；Done 5}：op-map{&#39；**&#39；++&#39；&gt；&gt；}：idx 0：测试通过？False})。</p><p>(def drop-tag rest)；(test(op&gt；)...)=&gt；((op&gt；)...)。(Defn EXEC-TEST[DATA INS](-&gt；DATA(ASSOC：测试通过？(解析操作数据(Drop-Tag INS)(UPDATE：IDX Inc))。</p><p>)：考试通过了吗？(exec-test ex-Machine-state-v3&#39；(test(op&gt；)(reg计数器)(Reg N)；=&gt；false(：test-pass？(EXEC-TEST EXM-MACHINE-STATE-v3&#39；(test(op&gt；)(Reg N)(Reg Count)；=&gt；true。</p><p>机器测试通过了吗？状态IS设置为操作值。</p><p>(def BRANCH-DEST秒)；(BRANCH(标签完成))=&gt；(标签完成)(DEFN EXEC-BRANCH[DATA INS](LET[DEST(解析基元数据(BRANCH-DEST INS)](IF(：测试通过？数据)(ASSOC数据：IDX DEST)(更新数据：IDX Inc))</p><p>(EXEC-BRANCH{：LABEL-&gt；IDX{&#39；Done 5}：测试通过？FALSE：idx 0}&#39；(分支(标签完成))；=&gt；{：标签-&gt；idx{完成5}，：测试通过？FALSE，：IDX 1}(EXEC-BRANCH{：LABEL-&gt；IDX{&#39；Done 5}：测试通过？True：idx 0}&#39；(分支(标签完成))；=&gt；{：标签-&gt；idx{完成5}，：测试通过？TRUE，：IDX 5}。</p><p>我们现在已经实现了使阶乘机器工作所需的所有指令。让我们创建一个将它们放在一起的函数：</p><p>(定义EXEC-INS[数据INS](让[type-&gt;；f{##39；ASSIGN EXEC-ASSIGN&#39；TEST EXEC-ASSIGN&#39；BRANCH EXEC-BRANCH&#39；GOTO EXEC-GOTO}f(或(TYPE-&gt;；f(TAG INS)(抛出(异常。&#34；意外指令&#34；)](f数据输入))。</p><p>&#39；(START(TEST(OP&&gt;；)(REG COUNTER)(Reg N))(BRANCH(LABEL DONE))(ASSIGN(LABEL DONE))(赋值RES(OP*)(REG COUNTER)(REG RES))(ASSIGN COUNTER(OP+)(REG COUNTER)(Const 1))(GOTO(Label Start))DONE)。</p><p>但是我们需要Label→idx映射。为了使这些索引有意义，我们还需要仅表示可执行指令。让我们写下这些：</p><p>(Defn Extract-Instructions[RAW-Instructions](vec(Remove Symbol？RAW-Instructions)(Defn Extract-Label-&gt；idx[RAW-Instructions](Second(Reduce(Fn[[IDX Label-&gt；IDX]Part])(IF(Symbol？Part)[IDX(Assoc Label-&gt；IDX Part IDX)][(Inc IDX)Label-&gt；IDX])[0{}]RAW-Instructions))。</p><p>(Extract-Label-&gt；IDX阶乘指令)；=&gt；{Start 0，Done 5}(Extract-Instructions阶乘指令)；=&gt；[(test(op&gt；)(Reg Counter)(Reg N))(分支(Label Done))(Assign RES(OP*)(Reg Counter)(Reg Res))(Assign Counter(OP+)(Reg Counter)(Const 1))(GOTO(LABEL START))]。</p><p>好的，exec可以接受一个机器状态和一条指令，然后返回一个全新的机器状态。Extract-Label→idx可以创建我们的标签→idx映射，而Extract-Instructions只能为我们提供可执行表达式。</p><p>(Defn运行[注册表映射操作映射原始指令](让[标签-&&gt;；idx(提取-标签-&&gt;；idx原始指令)指令(提取-指令原始指令)初始机器状态{：注册表映射注册表映射：操作映射操作映射：idx 0：测试通过？Nil：标签-&gt；idx标签-&gt；idx}](loop[机器状态初始机器状态](if-let[ins(第n条指令(：idx机器状态)nil)](recur(exec-ins机器状态ins))机器状态))。</p><p>我们接收一个注册表、一个操作映射和一些原始指令。之后，我们在循环中运行，根据idx执行指令，并在idx不再返回可执行指令时返回。</p><p>(Get-in(运行{&#39；n5&#39；计数器1&#39；分辨率1}{&#39；**&#39；&gt；&gt；&#39；++}阶乘说明)[：注册表映射&#39；分辨率])；=&gt；120。</p><p>哇，那真是一次旅行。希望你玩得开心！🙂。如果您想了解整个过程，请查看GitHub回购。</p><p>准备接受挑战？尝试实现其他一些机器：Fibonacci序列、求幂等。尝试编写这些算法的递归版本，要做到这一点，您需要机器状态中的堆栈结构和(save&lt；reg-name&gt；)(restore&lt；reg-name&gt；)指令。在那之后，见鬼，你可以实现一个LISP求值器！</p><p>如果你对这类东西感兴趣，可以在推特或电子邮件上联系一下-我总是很乐意与志同道合的黑客🙂聊天。</p><p>感谢Joe Averbukh，David Magaltadze，Ian Sinnot，Raghavan Lakshmana审阅了这篇文章的草稿。</p><p>(1)计算机寄存器也有一个启动子，但我决定不把它包括在论文中。我认为没有必要抓住本质。我计划再写一篇更深入的文章：)</p><p>(2)你在球上可能达到的最高速度是200公里/小时，而光的传播速度是30万公里/小时(…)。马上就到。你可以想象这种速度会如何改变游戏规则：从让计算器变得不切实际到生产iPhone。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/255">https://stopa.io/post/255</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/模拟/">#模拟</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/machines/">#machines</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/机器/">#机器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1026621.html"><img src="http://img2.diglog.com/img/2020/9/thumb_9e2f7918f52cd34ba6e43ae64e20968c.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026621.html">在一个伪造的模拟乘法器里</a></div><span class="my_story_list_date">2020-9-27 4:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1023100.html"><img src="http://img2.diglog.com/img/2020/9/thumb_d41d164b0e1633b08c7df709335b18cd.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1023100.html">万事达卡推出一种工具，供各国央行模拟发行其货币的数字版本，并测试其对消费者是否实用</a></div><span class="my_story_list_date">2020-9-10 6:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1020887.html"><img src="http://img.diglog.com/img/2020/8/thumb_03856a7ab7ea49b0637751602486d8bf.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1020887.html">超导量子比特计算机上的Hartree-Fock</a></div><span class="my_story_list_date">2020-8-28 17:0</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019991.html"><img src="http://img.diglog.com/img/2020/8/thumb_721d331b358b7894b63d7eae1d57f344.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019991.html">新的搅拌器附加组件精确建模亚原子粒子，让社区参与竞赛</a></div><span class="my_story_list_date">2020-8-24 11:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>