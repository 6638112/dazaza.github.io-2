<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>漂亮的JSON革命 The Pretty JSON Revolution</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Pretty JSON Revolution<br/>漂亮的JSON革命 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:48:58</div><div class="page_narrow text-break page_content"><p>Wouldn&#39;t it be nice if more JSON tools supported a truly		 pretty JSON format? Demand options for truly pretty JSON		 now! Viva la revolucion!</p><p>如果更多的JSON工具支持真正漂亮的JSON格式会不会很好？现在就需要真正漂亮的JSON的选项！万岁！</p><p>  If only it were that easy. JSON format has become wildly		 popular over the last decade easily passing XML as the		 format of choice. For us humans JSON is much easier to read		 than XML if the JSON is properly formatted. Sadly most tools		 for viewing or formating JSON seem to be stuck on one of two		 formats. One format is the single line format and the other		 is a simple expanded format. There are other options though		 with some tools.</p><p>  如果那么简单就好了。在过去的十年中，JSON格式已变得非常流行，轻松地将XML作为首选格式。对我们来说，如果JSON的格式正确，那么JSON比XML更容易阅读。可悲的是，大多数用于查看或格式化JSON的工具似乎都停留在两种格式之一上。一种格式是单行格式，另一种是简单的扩展格式。尽管还有一些工具，但还有其他选择。</p><p>  One tool that offers more options is		 the  oj application		 which is part of the		 golang  OjG		 package. The  oj		 application will be used to illustrate the range of JSON		 formats from the ugly up to the beauty of pretty		 JSON. Follow along and try out your favorite JSON sample on		 each step.</p><p>  oj应用程序是提供更多选项的一种工具，它是golang OjG软件包的一部分。 oj应用程序将用于说明JSON格式的范围，从丑陋到漂亮的JSON。跟随并在每个步骤中尝试您喜欢的JSON示例。</p><p>  The tight one line JSON format is used when trying to		 minimize the size of a JSON document. It is the preferred		 format for transmitting and storing JSON as it takes less		 bandwidth and less disk space. For viewing, it is hard for		 the eye to find elements of interests and difficult to		 determine element boundaries. It has to be the ugliest of		 all JSON formats.</p><p>  尝试最小化JSON文档的大小时，使用紧密的JSON格式。它是传输和存储JSON的首选格式，因为它占用更少的带宽和更少的磁盘空间。对于观看而言，眼睛很难找到兴趣元素，也很难确定元素边界。它必须是所有JSON格式中最丑的。</p><p>  What many packages refer to as pretty is an expanded format		 where every element and each array and object start are on		 separate lines. The core		 golang  json.MarshalIndent() function produces		 an example of this format. The format takes up so much		 vertical space the example on the right had to be cut off to		 avoid filling up this article with just large amounts of		 white space.</p><p>  许多软件包都将其称为“漂亮”是一种扩展格式，其中每个元素，每个数组和对象的开始都位于单独的行上。核心golang json.MarshalIndent（）函数产生了这种格式的示例。该格式占用了太多垂直空间，因此必须剪掉右边的示例，以避免在本文中仅填充大量空白。</p><p>  With the expanded (pretty?) format it is certainly easier to		 determine element boundaries but you need a large screen or		 to be good at scrolling to find what you are looking for. So		 the expanded format is a step up from the one line format		 which makes it a bit prettier but it is a weak effort that		 is not without flaws.</p><p>  使用扩展的（pretty？）格式，确定元素边界当然更容易，但是您需要大屏幕或擅长滚动查找所需内容。因此，扩展格式比单行格式要先进一些，这使它更漂亮，但这是一项艰巨的努力，并非没有缺陷。</p><p>  $ oj -i 2 colors.json{ &#34;colors&#34;: [ { &#34;color&#34;: &#34;black&#34;, &#34;hex&#34;: &#34;#000&#34;, &#34;rgb&#34;: [ 0, 0, 0 ] }, { &#34;hex&#34;: &#34;#f00&#34;, &#34;rgb&#34;: [ 255, 0, 0 ], &#34;color&#34;: &#34;red&#34; },...</p><p>  $ oj -i 2 colors.json {＆＃34; colors＆＃34 ;: [{＆＃34; color＆＃34 ;:＆＃34; black＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34 ;＃000＆＃34 ;,＆＃34; rgb＆＃34 ;: [0，0，0]}，{＆＃34; hex＆＃34 ;:＆＃34;＃f00＆＃34 ;,＆＃34; rgb＆ ＃34 ;: [255，0，0]，＆＃34; color＆＃34 ;:＆＃34; red＆＃34; }，... </p><p>  In many implementations JSON objects, whether implemented as		 a golang map, Ruby Hash, Python dict, or what ever your		 language of choice uses, the order of object elements is		 random. That makes it more difficult to visually scan a set		 of elements and pick out the same keyed element in each JSON		 object. The brain is good at picking out visual or spacial		 patterns but if the layout changes each each time there is		 no pattern to pickup on. A visual scan has to be done,		 looking at each key until the target is identified. JSON can		 be made prettier by sorting the JSON object members by		 element keys.</p><p>在许多实现中，无论是作为golang映射，Ruby Hash，Python dict还是您所选择的语言使用的JSON对象，对象元素的顺序都是随机的。这使得在视觉上扫描一组元素并在每个JSON对象中挑选出相同的键控元素变得更加困难。大脑擅长挑选视觉或空间图案，但是如果每次每次都更改布局，就没有图案可以拾取。必须进行视觉扫描，查看每个按键，直到识别出目标为止。通过按元素键对JSON对象成员进行排序，可以使JSON更漂亮。</p><p>  A sorted expanded format is a step up from just the expanded		 format but it still suffers from taking up lot of vertical		 space. If someone was writing the JSON by hand they would		 probably not elect to expand the JSON to quite the level		 that most packages or libraries do.</p><p>  排序的扩展格式仅是扩展格式的一种，但它仍然要占用大量垂直空间。如果有人手工编写JSON，他们可能不会选择将JSON扩展到大多数软件包或库所能达到的水平。</p><p>  $ oj -i 2 -s colors.json{ &#34;colors&#34;: [ { &#34;color&#34;: &#34;black&#34;, &#34;hex&#34;: &#34;#000&#34;, &#34;rgb&#34;: [ 0, 0, 0 ] }, { &#34;color&#34;: &#34;red&#34;, &#34;hex&#34;: &#34;#f00&#34;, &#34;rgb&#34;: [ 255, 0, 0 ] },...</p><p>  $ oj -i 2 -s colors.json {＆＃34; colors＆＃34 ;: [{＆＃34; color＆＃34 ;:＆＃34; black＆＃34 ;、＆＃34; hex＆＃34 ;：＆ ＃34;＃000＆＃34 ;,＆＃34; rgb＆＃34 ;: [0，0，0]}，{＆＃34; color＆＃34 ;:＆＃34; red＆＃34 ;,＆＃34;十六进制＆＃34 ;：＆＃34;＃f00＆＃34 ;、＆＃34; rgb＆＃34 ;： [255，0，0]}，...</p><p>  The ideal pretty JSON pretty is to have the format look like		 a human had typed it in. Well a pedantic human that didn&#39;t		 make mistakes. Just like Goldilocks, the optimum middle		 ground between a single line and a fully expanded format is		 the goal. The		 algorithm  oj uses		 considers a suggested edge to not exceed and a maximum		 element depth allowed on a single line. Those two parameters		 are specified as a float where the whole number part is the		 edge and the fractional part or the number of 10ths is the		 maximum depth on a single line. With those two parameters a		 reasonable human style format can be achieved and the		 results are looking rather pretty.</p><p>  理想的漂亮JSON漂亮的是让格式看起来像是人类键入的格式。好吧，学究的人类没有犯错。就像Goldilocks一样，目标是在单行和完全扩展的格式之间找到最佳的中间点。 oj使用的算法认为建议边缘不超过一条，并且单行允许的最大元素深度。这两个参数被指定为浮点数，其中整数部分是边，小数部分或十分之一是单行上的最大深度。有了这两个参数，就可以实现合理的人文风格格式，并且效果看起来还不错。</p><p>  $ oj -p 80.3 colors.json{ &#34;colors&#34;: [ {&#34;color&#34;: &#34;black&#34;, &#34;hex&#34;: &#34;#000&#34;, &#34;rgb&#34;: [0, 0, 0]}, {&#34;color&#34;: &#34;red&#34;, &#34;hex&#34;: &#34;#f00&#34;, &#34;rgb&#34;: [255, 0, 0]}, {&#34;color&#34;: &#34;yellow&#34;, &#34;hex&#34;: &#34;#ff0&#34;, &#34;rgb&#34;: [255, 255, 0]}, {&#34;color&#34;: &#34;green&#34;, &#34;hex&#34;: &#34;#0f0&#34;, &#34;rgb&#34;: [0, 255, 0]}, {&#34;color&#34;: &#34;cyan&#34;, &#34;hex&#34;: &#34;#0ff&#34;, &#34;rgb&#34;: [0, 255, 255]}, {&#34;color&#34;: &#34;blue&#34;, &#34;hex&#34;: &#34;#00f&#34;, &#34;rgb&#34;: [0, 0, 255]}, {&#34;color&#34;: &#34;magenta&#34;, &#34;hex&#34;: &#34;#f0f&#34;, &#34;rgb&#34;: [255, 0, 255]}, {&#34;color&#34;: &#34;white&#34;, &#34;hex&#34;: &#34;#fff&#34;, &#34;rgb&#34;: [255, 255, 255]} ]}</p><p>  $ oj -p 80.3 colors.json {＆＃34; colors＆＃34 ;: [{＆＃34; color＆＃34 ;:＆＃34; black＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34 ;＃000＆＃34 ;,＆＃34; rgb＆＃34 ;: [0，0，0]}，{＆＃34; color＆＃34 ;:＆＃34; red＆＃34 ;,＆＃34; hex＆＃ 34 ;:＆＃34;＃f00＆＃34 ;,＆＃34; rgb＆＃34 ;: [255，0，0]}，{＆＃34; color＆＃34 ;:＆＃34; yellow＆＃34 ;, ＆＃34; hex＆＃34 ;：＆＃34;＃ff0＆＃34 ;、＆＃34; rgb＆＃34;：[255、255、0]}，{＆＃34; color＆＃34 ;：＆＃34 ; green＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34;＃0f0＆＃34 ;,＆＃34; rgb＆＃34 ;: [0，255，0]}，{＆＃34; color＆＃ 34 ;:＆＃34; cyan＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34;＃0ff＆＃34 ;,＆＃34; rgb＆＃34 ;: [0，255，255]}，{ ＆＃34;颜色＆＃34 ;：＆＃34;蓝色＆＃34 ;，＆＃34;十六进制＆＃34 ;：＆＃34;＃00f＆＃34 ;，＆＃34; rgb＆＃34 ;： [0，0 ，255]}，{＆＃34; color＆＃34 ;:＆＃34;洋红色＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34;＃f0f＆＃34 ;,＆＃34; rgb＆＃34 ;：[255，0，255]}，{＆＃34; color＆＃34 ;:＆＃34; white＆＃34 ;,＆＃34; hex＆＃34 ;:＆＃34;＃fff＆＃34 ;,＆ ＃34; rgb＆＃34;：[255，255，255]}]}</p><p>  With the human style formatting the JSON sample is very		 readable but it can be made prettier. Well at least for		 those of us than see in color. With the  -c		 option or the  -b option the formatted JSON now		 has colors. While colors do make the output prettier they		 also make it easier for the eye to discern keys, string,		 boolean, and numbers more easily. Try it, look at the		 non-colored JSON and the colored and pick out your preferred		 color name. Maybe not nirvana but compared to the first, one		 line format, the colored pretty output is a completely		 different level.</p><p>  使用人类样式格式，JSON示例非常易读，但可以使其更漂亮。至少对于我们这些人来说，比肤色还好。使用-c选项或-b选项，格式化的JSON现在具有颜色。尽管颜色确实使输出更漂亮，但它们也使眼睛更容易分辨键，字符串，布尔值和数字。尝试一下，查看非彩色的JSON和彩色的，然后选择您喜欢的颜色名称。也许不是必杀技，但与第一行格式相比，彩色漂亮输出是完全不同的水平。</p><p>  $ oj -p 80.3 -c colors.json {  &#34;colors&#34; :  [  { &#34;color&#34; :  &#34;black&#34; ,  &#34;hex&#34; :  &#34;#000&#34; ,  &#34;rgb&#34; :  [ 0 ,  0 ,  0 ] } ,  { &#34;color&#34; :  &#34;red&#34; ,  &#34;hex&#34; :  &#34;#f00&#34; ,  &#34;rgb&#34; :  [ 255 ,  0 ,  0 ] } ,  { &#34;color&#34; :  &#34;yellow&#34; ,  &#34;hex&#34; :  &#34;#ff0&#34; ,  &#34;rgb&#34; :  [ 255 ,  255 ,  0 ] } ,  { &#34;color&#34; :  &#34;green&#34; ,  &#34;hex&#34; :  &#34;#0f0&#34; ,  &#34;rgb&#34; :  [ 0 ,  255 ,  0 ] } ,  { &#34;color&#34; :  &#34;cyan&#34; ,  &#34;hex&#34; :  &#34;#0ff&#34; ,  &#34;rgb&#34; :  [ 0 ,  255 ,  255 ] } ,  { &#34;color&#34; :  &#34;blue&#34; ,  &#34;hex&#34; :  &#34;#00f&#34; ,  &#34;rgb&#34; :  [ 0 ,  0 ,  255 ] } ,  { &#34;color&#34; :  &#34;magenta&#34; ,  &#34;hex&#34; :  &#34;#f0f&#34; ,  &#34;rgb&#34; :  [ 255 ,  0 ,  255 ] } ,  { &#34;color&#34; :  &#34;white&#34; ,  &#34;hex&#34; :  &#34;#fff&#34; ,  &#34;rgb&#34; :  [ 255 ,  255 ,  255 ] }  ] }</p><p>  $ oj -p 80.3 -c colors.json {＆＃34; colors＆＃34; ：[{＆＃34; color＆＃34; ：＆＃34;黑色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃000＆＃34; ，＆rgb＆＃34; ：[0，0，0]}，{＆＃34; color＆＃34; ：＆＃34; red＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃f00＆＃34; ，＆rgb＆＃34; ：[255，0，0]}，{＆＃34; color＆＃34; ：＆＃34;黄色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃ff0＆＃34; ，＆rgb＆＃34; ：[255，255，0]}，{＆＃34; color＆＃34; ：＆＃34;绿色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃0f0＆＃34; ，＆rgb＆＃34; ：[0，255，0]}，{＆＃34; color＆＃34; ：＆＃34;青色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃0ff＆＃34; ，＆rgb＆＃34; ：[0，255，255]}，{＆＃34; color＆＃34; ：＆＃34;蓝色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃00f＆＃34; ，＆rgb＆＃34; ：[0，0，255]}，{＆＃34; color＆＃34; ：＆＃34;洋红色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃f0f＆＃34; ，＆rgb＆＃34; ：[255，0，255]}，{＆＃34; color＆＃34; ：＆＃34;白色＆＃34; ，＆＃34; hex＆＃34; ：＆＃34;＃fff＆＃34; ，＆rgb＆＃34; ：[255，255，255]}]} </p><p>  Sorted human style with colors is about as good as it gets		 but what if we deviate from strict JSON format and take a		 few shortcuts that Javascript and GraphQL allow such as		 unquoted strings and optional		 commas. The  SEN		 format is that		 format. The  oj		 application supports parsing and encoding in SEN		 format. It&#39;s not JSON but the conversion from SEN to JSON		 and the reverse is lossless. Getting rid of the extra quotes		 and unnecessary commas make the data easier to read and as a		 side benefit the SEN format takes up less space so		 transmission and disk space requirements are reduced when		 compared to JSON.</p><p>用颜色排序人类风格与它变得一样好，但如果我们偏离严格的JSON格式，那么拍摄JavaScript和GraphQL允许的一些快捷方式允许未引用的字符串和可选的逗号。森格式是这种格式。 OJ应用程序支持以森格式解析和编码。它不是JSON，但从SEN到JSON的转换而反向是无损的。摆脱额外的报价和不必要的逗号使数据更容易阅读，并且作为森格格式占用的侧面，所以与JSON相比，传输和磁盘空间要求减少。</p><p>  $ oj -p 80.3 -c -sen colors.json {  colors :  [  { color :  black  hex :  &#34;#000&#34;  rgb :  [ 0  0  0 ] }  { color :  red  hex :  &#34;#f00&#34;  rgb :  [ 255  0  0 ] }  { color :  yellow  hex :  &#34;#ff0&#34;  rgb :  [ 255  255  0 ] }  { color :  green  hex :  &#34;#0f0&#34;  rgb :  [ 0  255  0 ] }  { color :  cyan  hex :  &#34;#0ff&#34;  rgb :  [ 0  255  255 ] }  { color :  blue  hex :  &#34;#00f&#34;  rgb :  [ 0  0  255 ] }  { color :  magenta  hex :  &#34;#f0f&#34;  rgb :  [ 255  0  255 ] }  { color :  white  hex :  &#34;#fff&#34;  rgb :  [ 255  255  255 ] }  ] }</p><p>  $ oj -p 80.3 -c -c -sen colors.json {颜色：[{颜色：黑色十六进制：＆＃34;＃000＆＃34; RGB：[0 0 0]} {颜色：红色十六进制：＆＃34;＃f00＆＃34; RGB：[255 0 0]} {颜色：黄色十六进制：＆＃34;＃ff0＆＃34; RGB：[255 255 0]} {颜色：绿色十六进制：＆＃34;＃0f0＆＃34; RGB：[0 255 0]} {颜色：青色十六进制：＆＃34;＃0FF＆＃34; RGB：[0 255 255]} {颜色：蓝色十六进制：＆＃34;＃00f＆＃34; RGB：[0 0 255]} {颜色：洋红色十六进制：＆＃34;＃f0f＆＃34; RGB：[255 0 255]} {颜色：白色十六进制：＆＃34; #fff＆＃34; RGB：[255 255 255]}]}}}</p><p>  Beauty is in the eye of the beholder. My preference is the		 pretty colored SEN format. You might have a different		 preference but let&#39;s continue the revolution together and get		 more pretty JSON out there. Use pretty JSON on web pages and		 in email. For the tool builders out there, offer the		 option for pretty JSON.</p><p>  美在旁观者的眼中。我的偏好是漂亮的森森格式。你可能有不同的偏好，但是，让＆＃39;革命一起继续革命，并在那里获得更漂亮的杰克。在网页和电子邮件中使用漂亮的JSON。对于那里的工具构建器，为漂亮的JSON提供选择。</p><p>  Note: In case you are wondering if the colored JSON HTML was		 written or colorized by hand, it was		 not. The  -html option		 of  oj was used to		 produce the colorized HTML for this article. It&#39;s a handy		 option when including JSON on web pages or in email.</p><p>  注意：如果您想知道彩色的JSON HTML是否用手写入或着色，则不是。 OJ的-HTML选项用于生成本文的彩色HTML。当网页或电子邮件中包括JSON时，它＆＃39; s affic选项。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.ohler.com/dev/pretty.html">http://www.ohler.com/dev/pretty.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>