<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>git有什么问题？ 概念设计分析（2016） What’s wrong with Git? A conceptual design analysis (2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What’s wrong with Git? A conceptual design analysis (2016)<br/>git有什么问题？ 概念设计分析（2016） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 11:11:02</div><div class="page_narrow text-break page_content"><p>What’s wrong with Git? A conceptual design analysis De Rossi &amp; Jackson  Onward! 2013</p><p>git有什么问题？概念设计分析de rossi＆amp;杰克逊向前！ 2013年</p><p> We finished up last week talking about the how to find good concepts / abstractions in a software design and what good modularization looks like. Today’s paper jumps 40+ years to look at some of those issues in a modern context and a tool that many readers of this blog will be very familiar with: Git. With many thanks to Glyn Normington for the recommendation.</p><p> 我们上周结束了谈论如何在软件设计中找到良好的概念/抽象，以及什么好的模块化看起来像。今天的纸张跳跃40多年来看看现代背景下的一些问题，这个博客的许多读者都会非常熟悉：Git。非常感谢Glyn Normyton的推荐。</p><p> The best software designers already know how important it is to discover or invent the right concepts, and that rough edges in these concepts and their relationships will lead to rough edges in the delivered product… Despite this there have been few attempts to study the design of concepts and their impact in software.</p><p> 最好的软件设计师已经知道发现或发明正确的概念是多么重要，以及这些概念中的粗糙边缘以及它们的关系将导致交付的产品中的粗糙边缘...尽管这几乎没有尝试研究设计概念及其对软件的影响。</p><p> The authors chose to use Git to explore the role of concepts in design – it is widely known and used, and at the same time known to be confusing and difficult to learn. Are the usability problems of git just on the surface, in the expression of the commands, or do they run deeper?</p><p> 作者选择使用Git来探讨设计中概念的作用 - 它广为人知和使用，并且同时知道令人困惑，难以学习。是刚刚在表面上的可用性问题，在命令的表达式中，或者它们更深入？</p><p> We believe that the usability problems of Git run deeper, and can only be addressed by a more fundamental reworking that considers the underlying concepts. This is not to say that such a reworking cannot be achieved in a lightweight fashion. Indeed, our own reworking hides Git behind a veneer just as these other tool do. The difference however, is that we are willing to completely reconsider the core concepts that are presented to the user.</p><p> 我们相信Git的可用性问题更深，只能通过更基本的重新加工来解决潜在的概念。这并不是说这种重新加工不能以轻质的方式实现。实际上，我们自己的重新加工隐藏了一个像素后面的Git就像这些其他工具一样。然而，差异是，我们愿意完全重新考虑给用户呈现的核心概念。</p><p> The results of the reworking are made available in a tool called  gitless, which I’ve installed on my system to try out for a few days. (Note: if you use oh-my-zsh with the git plugin then this defines an alias for gl which you’ll need to unalias). As of this paper (2013), Gitless was only just beginning as a project, but it continues to this day and tomorrow we’ll look at the 2016 paper that brings the story up to date.</p><p> 重新加工的结果是在一个名为Gittress的工具中提供的，我安装在我的系统上进行几天时间。 （注意：如果使用GIT插件使用OH-MY-ZSH，那么这为您需要unalias需要的gl定义了一个别名）。截至本文（2013年），Gittress才刚刚开始作为一个项目，但它仍然持续到今日，明天我们将看看2016纸张，使故事迄今为止。</p><p> The kinds of concepts the authors are interested in are those which are essential to the design, to an understanding of the workings of the system, and hence will be apparent in the external interface of the system, as well as in the implementation.</p><p> 作者对该设计至关重要的概念，以了解系统的工作，因此在系统的外部界面以及实施中将显而易见。 </p><p> In our view, concepts have psychological content; they correspond to how users think about the application. Conceptual design for us, therefore, is about the design of user-visible behavior, and not the design of internal software structure, and we use the term ‘conceptual model’ for a specification that focuses on concepts rather than the details of behavior.</p><p>在我们看来，概念具有心理内容;它们对应于用户如何考虑应用程序。因此，我们的概念设计是关于用户可见行为的设计，而不是内部软件结构的设计，并且我们使用术语“概念模型”来专注于概念而不是行为细节。</p><p> Fred Brooks described conceptual integrity as “the most important consideration in system design” and gave three principles upon which it is based:</p><p> Fred Brooks将概念完整性描述为“系统设计中最重要的考虑”，并提供了三个原则：</p><p> propriety – a product should have only the functions (concepts) essential to its purpose and no more, and</p><p> 所有权 - 产品应该只有对其目的至关重要的功能（概念），也不是</p><p> The authors add a fourth:  consistency – requiring for example that actions behave in a similar way irrespective of the arguments they are presented with or the states in which they are invoked.</p><p> 作者添加了第四个：一致性 - 例如，措施以类似的方式行事，而不管他们所呈现的参数或调用它们的州。</p><p> The paper then proceeds as follows: first the authors build a conceptual model for git as it is today, and then they show how the conceptual model leads to a number of difficulties experienced by git users. Finally they introduce gitless, which is based on a simpler conceptual model.</p><p> 此论文然后按如下方式进行：首先，作者为今天的Git构建了一个概念模型，然后他们展示了概念模型如何导致Git用户所经历的许多困难。最后，他们介绍了无缝的，这是基于更简单的概念模型。</p><p>  Ideally, a description of a conceptual design should be implementation-independent; it should be easy to understand; it should be precise enough to support objective analysis; and it should be lightweight, presenting little inertia to the exploration of different ponits in the design space.</p><p>  理想情况下，概念设计的描述应该独立于实现;它应该很容易理解;它应该精确地支持客观分析;它应该重量轻，向设计空间中的不同小便探来展示一点惯性。</p><p> The authors’ tool of choice for this is a kind of concept-relationship diagram. Here’s the model they built for Git:</p><p> 作者的选择工具是一种概念 - 关系图。这是他们为git构建的模型： </p><p>  It’s kind of complicated to explain – which is really the authors’ point. Though reading through their description did remind me of some of the subtleties in Git. As I imagine many people do, I’ve evolved my own basic way of using git and try not to stray too far from that. Much of the complexity in Git’s conceptual model comes from the variety of different states and roles that files can be in/play. Files may be tracked or untracked, marked as ‘assumed unchanged’, ignored, staged, stashed and more. Distinguishing between the  working version of a file and the  staged version of a file is a common cause of confusion. For example, if I follow the sequence:</p><p>解释它是一种复杂的 - 这真的是作者的观点。虽然通过他们的描述阅读确实提醒我一些git中的一些微妙之处。正如我想象很多人所做的那样，我已经进化了自己的基本方式，使用了Git，并尽量不要迷失太远。 Git概念模型的大部分复杂性来自各种状态和角色可以在/播放中的各种状态和角色。可以跟踪文件或未触发文件，标记为“假设不变”，忽略，暂存，粘附等。区分文件的工作版本和文件的暂存版本是混淆的常见原因。例如，如果我遵循序列：</p><p>  Update: in the original post the last line erroneously read ‘git commit  foo.rb‘ which  will commit the working version of foo.rb.</p><p>  更新：在原始帖子中，最后一行错误地读取“git commit foo.rb”，它将提交foo.rb的工作版本。</p><p> Then the version of foo.rb that gets commited is the version as of the time of the add command (because that copies foo.rb to staging, and commit works from the copies in staging).  Here are a few of the key git commands and how they relate to the concepts of staging and working copies:</p><p> 然后，所致的foo.rb的版本是as add命令的时间的版本（因为它将foo.rb复制到暂存，并且提交从暂停中的副本工作）。以下是一些关键git命令以及它们如何与暂存和工作副本的概念相关：</p><p> git add _f_ causes the working version of a file  f to be copied to staging, and if the file was  untracked, it also becomes  tracked.</p><p> git add _f_使文件f的工作版本要复制到暂存，如果文件未经触发，则会跟踪文件。</p><p>  git reset restores a file to a previous state. E.g.  git reset HEAD f for a file  f removes its association with the staged version, makes it untracked if was previously untracked before being staged, and makes it tracked if it was previously an assumed unchanged file. (The authors don’t model the variations of reset that work on history).</p><p>  git重置将文件恢复为先前状态。例如。文件F的Git Reset Head F删除其与暂存版本的关联，如果先前在暂存之前未经触发，则不会触及，并且如果先前是假设的不变文件，则跟踪其跟踪。 （作者不会模拟在历史上工作的重置的变化）。</p><p> git checkout _f_ reverts local changes to file  f by replacing the working version with the staged version if there is one, or with the committed version otherwise.  The same command is also used to switch branches…</p><p> git checkout _f_通过替换有暂存版本的工作版本来恢复本地更改f如果有一个，或者与提交版本否则。相同的命令也用于切换分支...</p><p> git stash takes the working version of each file (with modifications) and makes it a stashed version in a new stash….</p><p> git stash拍摄每个文件的工作版本（具有修改），并在新的藏品中使其成为困难的版本...... </p><p> The very complexity of the conceptual model we have described suggests to us that something is amiss in the design of Git. Can a version control system really require so many, and such intricate concepts? And before we have even considered synchronizing multiple repositories?</p><p>我们所描述的概念模型的非常复杂性表明，我们在Git设计中是不对的。版本控制系统是否真的需要这么多，并且如此复杂的概念？在我们甚至考虑同步多个存储库之前？</p><p>    The staged and working versions of a file are  coupled in complex ways, and Git commands that one might expect to affect only one often affect the other too. One way to get into trouble is to add a file, then continue working on it before committing. If you then decide to undo the commit with a reset command then depending on the arguments not just the staged version but also the working version wil be replaced (wiping out subsequent work since the commit).</p><p>    文件的分阶段和工作版本以复杂的方式耦合，并且可能期望仅影响一个人的Git命令也会影响另一个。遇到麻烦的一种方法是添加文件，然后在提交之前继续工作。如果你决定用重置命令撤消提交，那么取决于参数不仅仅是暂存的版本，还要替换WIL的工作版本（自提交以来擦除后续工作）。</p><p> Why this happens: the concepts of staged and working versions are not orthogonal. Many commands that are primarily intended to modify one of the two modify the other too. Worse, whether or not these ripple effects occur depends on which arguments are presented to the commands.</p><p> 为什么会发生这种情况：上演和工作版本的概念不是正交的。许多主要旨在修改两个修改另一个的命令也修改了另一个。更糟糕的是，是否发生这些纹波效果取决于哪些参数呈现给命令。</p><p>  Committing files is non-trivial in git, in large part because of the intrusion of the concept of staging.</p><p>  提交文件在Git中是非微不足道的，大部分是因为暂存概念的侵入。</p><p> The git commit command takes versions from staging, not the working version. The  git commit -a variation almost gets around this (it performs an implicit add prior to commit), but it won’t pick up untracked files and can only be used to commit  all tracked files with modifications. In short, it’s too blunt a tool.</p><p> Git Commit命令从暂存中占用版本，而不是工作版本。 Git Commit -A变型几乎绕过此变体（它在提交之前执行一个隐式添加），但它不会选择未触发的文件，只能用于使用修改的所有跟踪文件。简而言之，它太钝了工具。</p><p> Some Git enthusiasts make arguments for the value of the staging concept, but for most users it offers inessential functionality, and its presence complicates the use of Git considerably.</p><p> 一些git爱好者对舞台概念的价值进行了论据，但对于大多数用户提供非必需功能，它的存在使得使用的使用使得大大复杂化。</p><p>  Switching branches… and those painful conflicts which can occur when there are uncommitted changes.</p><p>  切换分支......以及存在未提交的变化时可能发生的痛苦冲突。 </p><p> Branches are intended to support independent lines of development. A line of development comprise both the working versions of files and committed versions. And yet, in Git’s conceptual model, only the committed versions are organized by branch; while there are potentially multiple committed versions of a file (one per branch), there can only be one working version. There is thus a lack of generality, with the branching feature essentially available only in one area and not the other.</p><p>分支机构旨在支持独立的发展线。开发线包括文件的工作版本和已提交版本。然而，在GIT的概念模型中，只有所承诺的版本由分支组织;虽然有可能的文件的潜在多个忠诚版本（每个分支一个），但只能有一个工作版本。因此缺乏一般性，分支特征仅在一个区域中仅可用，而不是另一个区域。</p><p>  Gitless is the OSS project maintained by the authors that first cleans up the conceptual model, and the puts a user interface on top.</p><p>  Gittress是由作者维护的OSS项目，首先清理概念模型，并将用户界面放在上面。</p><p> The key differences between Git and Gitless are: (a) the elimination of the concept of Assumed Unchanged File, and the generalization of Untracked File to subsume it; (b) the elimination of staged versions; (c) the elimination of the concept of Stash, and stashed versions; (d) indexing of working versions by branch. Switching branches in Gitless is equivalent to always creating a stash (more precisely, of executing git stash –all) before switching to a different branch in Git, and then retrieving this stash when the user switches back to the original branch. Thus, it is as if there are multiple working directories (one for each branch), or in other words, one can think of it as a file potentially having several working versions accessible via a branch name b (noted as working[b] in the diagram). This means that the user can freely switch from branch to branch without having to stash or commit unfinished changes. We believe this lives up to the expectation of a branch being an independent line of development.</p><p> git和gittress之间的关键差异是：（a）消除假定的不变文件的概念，以及未经触发的文件的概念来归存它; （b）消除分阶段版本; （c）消除藏匿件和藏品的概念; （d）分支机构的工作版本索引。在Gittress中切换分支相当于始终在切换到Git中的不同分支之前始终创建存储功能（更精确地执行Git Stash -All），然后在用户切换回原始分支时检索此缺陷。因此，就好像有多个工作目录（每个分支一个）或换句话说，可以将其视为可能通过分支名称B可访问的若干工作版本的文件（注册为工作[b]）图表）。这意味着用户可以自由地从分支切换到分支，而无需删除或提交未完成的更改。我们认为这使得这一生命达到一个分支是一个独立的发展线。</p><p> If not all of the above makes sense to you, then Gitless is probably a good choice! The conceptual model of Gitless looks like this:</p><p> 如果不是所有上述内容对你有意义，那么Gitress可能是一个不错的选择！ Gitress的概念模型如下所示：</p><p>  At the point this paper was released, only very early evaluation studies had been done of the Gitless model, but “the elimination of the staging area was enthusiastically received as a major reduction in complexity.”</p><p>  本文发布了这篇文章，只有非常早期的评估研究已经完成了无巨头的模型，但是“消除分期区域的消除被热情地接受了复杂性的主要减少。”</p><p> It’s an interesting project since it relates to a tool many of us use on a daily basis. But beyond the specifics of Git, one of the takeaways for me is the reminder that good usability is deeply rooted in the conceptual design, and is far from just being about the presentation layer.</p><p> 这是一个有趣的项目，因为它与我们每天使用的工具涉及一次。但除了GIT的细节之外，我的一个外卖器是提醒的是，良好的可用性深深植根于概念设计中，远远距离演示层。</p><p> Most usability experts seem to recognize the importance of a product’s conceptual model, and the problems that arise when the user’s mental model, and the correct conceptual model of the product diverge.</p><p> 大多数可用性专家似乎都认识到产品概念模型的重要性，以及用户心理模型以及产品偏离的正确概念模型所产生的问题。 </p><p> The classic work on this last point is of course Donald Norman’s “The Design of Everyday Things.”</p><p>最后一点的经典工作当然是唐纳德诺曼的“日常事徒的设计”。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.acolyer.org/2016/10/24/whats-wrong-with-git-a-conceptual-design-analysis/">https://blog.acolyer.org/2016/10/24/whats-wrong-with-git-a-conceptual-design-analysis/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>