<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>小径运输 Laravel Transporter</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Laravel Transporter<br/>小径运输 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-24 22:16:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/2881028ca38bb15867c472c783f51de4.webp"><img src="http://img2.diglog.com/img/2021/6/2881028ca38bb15867c472c783f51de4.webp" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Sending API requests in any PHP framework has always been a little bit of a manual process, yes you can create an SDK or wrapper - but you are still having to do the same thing.</p><p>在任何PHP框架中发送API请求一直是一点点手动过程，是的，您可以创建一个SDK或包装器 - 但您仍然必须做同样的事情。</p><p> You pull in the HTTP client, or facade, you configure it in a proceedural way entering the URI you want to send a request to, then tag on the optional extras such as authentication, payload, any additional headers. It is quite a manual process.</p><p> 您在HTTP客户端或Facade中拉动，您将其配置为进入要发送请求的URI的运算方式，然后标记在可选的附件，如身份验证，有效载荷，任何其他标题。这是一个非常手动过程。</p><p> A lot of the time you have a specific request you want to send, yes you may slightly adjust things as you go by passing in an identifier etc etc - but in general they remain relatively constant.</p><p> 很多时候您都有要发送的特定请求，是的，你可以在通过进入标识符等时略微调整东西 - 但通常它们保持相对常量。</p><p> This has frustrated me for a while, we have to great lengths to make a lot of our code Object Oriented. Yet, we hadn&#39;t tried to do this with API requests. I have been sitting on this question for quite a while, pondering on the possible solutions - how it might look, and how it might be used.</p><p> 这让我感到沮丧了一段时间，我们必须很长的长度来制造我们面向的很多代码对象。然而，我们尝试用API请求完成此操作。我一直坐在这个问题上很长一段时间，思考可能的解决方案 - 它可能看起来如何，以及如何使用它。</p><p> The result of this has turned into my latest Laravel package:  Laravel Transporter which I describe as:</p><p> 这是我最新的Laravel包装：我描述为：</p><p> Transporter is a futuristic way to send API requests in PHP. This is an OOP approach to handle API requests.</p><p> Transporter是在PHP中发送API请求的未来派方式。这是处理API请求的OOP方法。</p><p>  To get started all you need to do is install it, theres no configuration required nothing extra to add to your project - it will only be used when you want to use it.</p><p>  要开始，您需要做的就是安装它，没有配置无需添加到您的项目中没有任何额外的东西 - 它只在您想要使用它时使用。 </p><p>   All we are doing here is filtering a list of todos that are completed - nothing overly difficult.</p><p>我们在这里所做的就是过滤完成的托多列表 - 没有什么意思是困难的。</p><p> Firstly let us have a look at how we would do this usually (but let&#39;s pretend this API required us to be authenticated using an API token we have previously generated).</p><p> 首先让我们看一下我们通常如何做到这一点（但是假装我们假装此API要求我们使用先前生成的API令牌进行身份验证）。</p><p>  Not terrible right? I mean, it works and does what you might expect. But, this is very proceedural. What happens if the URL changes? What happens if the query parameters change? We have to hunt through our code base, and update these everywhere. You know, the thing we are trying to avoid more and more in everything we build.</p><p>  不可思议的权利？我的意思是，它有效，并做你可能期望的。但是，这是非常成绩。如果URL更改会发生什么？如果查询参数更改，会发生什么？我们必须通过我们的代码库追捕，并在任何地方更新这些。你知道，我们正在努力避免更多和更多的东西我们构建的一切。</p><p> Let&#39;s add a little magic to these requests and see how we would send this exact same request using Laravel Transporter:</p><p> 让＆＃39; s为这些请求添加了一点魔法，并了解我们如何使用Laravel运输车发送完全相同的请求：</p><p>  That&#39;s it. The entire thing condensed into a class. Let&#39;s look how we got there.</p><p>  它＆＃39; s。整个东西凝聚在课程中。让＆＃39;看看我们如何到达那里。</p><p>    &lt;?phpdeclare(strict_types=1);namespace App\Transporter;use Illuminate\Http\Client\PendingRequest;use JustSteveKing\Transporter\Request;class TodoRequest extends Request{ protected string $method = &#39;GET&#39;; protected string $baseUrl = &#39;https://jsonplaceholder.typicode.com&#39;; protected string $path = &#39;/todos&#39;; protected array $data = [ &#39;completed&#39; =&gt; true, ]; protected function withRequest(PendingRequest $request): void { $request-&gt;withToken(config(&#39;jsonplaceholder.api.token&#39;)); }}</p><p>    ＆lt;？phpdeclare（strict_types = 1）;命名空间app \ transporter;使用illuminate \ http \ client \ pendingrequest;使用juststeveking \ transporter \ prodect; class todorequest扩展请求{protected string $ method =＆＃39; get＆＃39;受保护的字符串$ baseurl =＆＃39; https：//jsonplaceholder.typicode.com&#39 ;;受保护的字符串$ path =＆＃39; / todos＆＃39 ;;受保护的数组$ DATA = [＆＃39;已完成＆＃39; =＆gt;真的， ];受保护的函数有查询（PendingRequest $请求）：void {$ equest-＆gt; outtoken（config（＆＃39; jsonplaceholder.api.token＆＃39;））; }}</p><p> Going back to the original problem, if options change - we have to hunt everywhere in our application for where we may have used it. That problem has been solved by moving this to a class based request. Also, as the request itself is just a fancy wrapper around Laravels inbuilt  PendingRequest - we can call all the same methods before and after sending. Meaning there is no new API to learn, so it is relatively straight forward. You can override options at runtime too - want to show not completed todos?</p><p> 返回原来的问题，如果选择改变 - 我们必须在我们的应用程序中捕获我们可能已经使用过的地方。通过将此移动到基于类的请求来解决该问题。此外，由于请求本身只是一个围绕Laravels Inbuilt PendingRequest的花哨的包装器 - 我们可以在发送之前和之后调用所有相同的方法。意思是没有新的API学习，所以它相对直截了当。您也可以在运行时覆盖选项 - 想要显示未完成的户户曲？ </p><p>  This may not be a ground breaking package that is going to change the world, however what it is going to do is make you start asking the question: Could I send API requests in a more structured and organised way?</p><p>这可能不是一个接地破碎的包，即将改变世界，但是要做的就是让你开始询问问题：我可以以更具结构化和有组织的方式发送API请求吗？</p><p> Imagine a scenario, where you needed to work with a 3rd party API. You could quite quickly generate a series of requests and it will be done! Let&#39;s take the example of Laravel Forge, which if you remember I wrote about before when I released PHP-SDK  here is that article.</p><p> 想象一下，您需要使用第三方API所需的方案。您可以很快生成一系列请求，并将完成！让＆＃39借用Laravel Forge的示例，如果你记得我在此之前写过关于我在这里发布的PHP-SDK的那篇文章。</p><p>    &lt;?phpdeclare(strict_types=1);namespace App\Transporter\Forge;use Illuminate\Http\Client\PendingRequest;use JustSteveKing\Transporter\Request;class ForgeRequest extends Request{ protected string $baseUrl = &#39;https://forge.laravel.com/api/v1&#39;; protected function withRequest(PendingRequest $request): void { $request-&gt;withToken(config(&#39;services.forge.token&#39;)); }}</p><p>    ＆lt; phpdeclare（strict_types = 1）;命名空间app \ transporter \ forge;使用illuminate \ http \ client \ pendingrequest;使用juststeveking \ transporter \ lequest;类忘记扩展请求{受保护的字符串$ baseurl =＆＃39; https：/ /forge.laravel.com/api/v1&#39 ;;受保护的函数有查询（pendingrequest $请求）：void {$ locue-＆gt; outtoken（config（＆＃39; services.forge.token＆＃39;））; }}</p><p> Next let&#39;s take the example of getting all servers. Generate a new request for this request:</p><p> 下一个Let＆＃39;借用所有服务器的示例。为此请求生成新请求：</p><p>   &lt;?phpdeclare(strict_types=1);namespace App\Transporter\Forge\Servers;use App\Transporter\Forge\ForgeRequest;use Illuminate\Http\Client\PendingRequest;class ListServers extends ForgeRequest{ protected string $method = &#39;GET&#39;; protected string $path = &#39;/servers&#39;;}</p><p>   ＆lt;？phpdeclare（strict_types = 1）;命名空间app \ transporter \ forge \ server;使用app \ transporter \ forge \ forgerequest;使用illuminate \ http \ client \ pendingrequest; class listservers扩展谅解{protected string $方法=＆＃39 ; Get＆＃39 ;;受保护的字符串$ path =＆＃39; /服务器＆＃39 ;;}</p><p> All we have done here is used inheritance to extend the ForgeRequest which contains our initial state for every request we need - and allows us to build upon that where we want to.</p><p> 我们在这里所做的就是使用继承来扩展遗忘，该遗传包含我们需要的每个请求的初始状态 - 并允许我们建立在我们想要的地方。</p><p> Thanks for reading, I welcome any feedback that may assist in pushing this package forward and making it easier to use! Feel free to start a discussion or open an issue on the  GitHub Repository or even drop me a tweet/DM on  twitter.</p><p> 感谢您的阅读，我欢迎任何可能有助于推动此包装的反馈，并使更容易使用！随意开始讨论或打开GitHub存储库的问题，甚至在Twitter上丢弃我的推文/ DM。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.juststeveking.uk/introducing-laravel-transporter/">https://www.juststeveking.uk/introducing-laravel-transporter/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/小径/">#小径</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/laravel/">#laravel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>