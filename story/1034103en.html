<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何用Ruby、Rails、Active Record和No N+1绘制QL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何用Ruby、Rails、Active Record和No N+1绘制QL</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 02:32:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/feb0307586085b572c07461c5885df6e.png"><img src="http://img2.diglog.com/img/2020/11/feb0307586085b572c07461c5885df6e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You work on a mature web application that cleanly separates backend and frontend. The server-side code, written in Ruby, is mostly responsible for translating HTTP requests into SQL statements (with the help of an ORM) through rich and well-documented API. You choose GraphQL over REST to streamline your endpoints, but your database is not happy with all the extra queries. After much searching, you find an exhaustive hands-on guide on fighting N+1 from a fellow GraphQL-ing Rubyist… Here it comes!</p><p>你的工作是开发一个非常成熟的Web应用程序，将后端和前端完全分开。这些服务器端代码是用Ruby编写的，主要负责通过丰富且文档齐全的API将HTTP请求转换成SQL语句(在Java ORM的帮助下)。您选择GraphQL而不是REST来简化您的端点，但是您的数据库对所有这些额外的查询并不满意。经过多次搜索，你会发现一本关于如何与N+1搏斗的详尽的动手指南，这本指南来自一位资深的图形QL-Rubyist…。它来了！</p><p> GraphQL can do wonders in a backend-only Rails application, giving your clients (whether a frontend framework or other API consumers) a single endpoint for fetching data in any shapes and sizes they might need.</p><p>GraphQL可以在创建仅限后端的Rails应用程序方面创造奇迹，为您的客户端(无论是前端框架还是其他API使用者)提供一个单一的端点，用于获取任何形状和大小的数据，无论它们可能需要什么形状和大小。</p><p> There’s only one catch, but it’s a big one. N+1 big.</p><p>只有一个圈套，但这是一个非常大的圈套。N+1大。</p><p> As the list of the associations to load is always determined  at the runtime, it is very hard to be smart about querying the database.</p><p>由于要卸载的最新关联的列表通常是在运行时确定的，因此在查询数据库时很难变得非常聪明。</p><p> You can either accept the sad reality of one query for parent record + one query for  each association (hence “N+1”, even though the stricter term will be “1+N”)—or you can load all possible associations in advance with fancy SQL statements. But if you have a rich schema, and that’s the reason to switch to GraphQL in the first place, preloading can put an even bigger strain on a database than letting N+1 run amock. Luckily, there are tools in the Ruby-GraphQL world that allow us to be more selective and smarter about what we load, when, and how.</p><p>您可以接受父记录的一个查询+每个关联的一个查询的悲哀现实(因此是“N+1”，尽管更严格的术语将是“1+N”)-或者您可以提前用花哨的SQL语句加载所有可能的关联。但是，如果你有一个非常丰富的模式，而这也是你一开始就不会改用GraphQL的主要原因，那么预加载可能会给整个数据库带来比让N+1锁定运行更大的压力。幸运的是，在Ruby-GraphQL世界中有一些工具可以让我们在加载什么、何时加载以及如何加载方面变得更有选择性、更聪明。</p><p>  To not be unfounded, let’s draw up a practical example of a simple schema for a simple “Twitter clone” application. The goal here is not to be original but to be able to relate to types right away. They are  Tweet,  User, and  Viewer. The  Viewer is  the user who views the feed of other user’s tweets. We created a separate type for a “current user” because it may expose properties otherwise inaccessible on “general” users.</p><p>为了不是没有根据，让我们为一个非常简单的“Twitter克隆”应用程序起草一个简单的应用程序的简单模式的实际例子。这里的主要目标不是保持原创，而是能够立即与不同类型的人联系起来。它们是推特(Tweet)、用户(User)和用户查看器(Viewer)。微博阅读器是指查看其他用户推文的推送的用户。我们为“当前用户”创建了一个单独的类型，因为它可能会在“一般”用户上公开否则无法访问的属性。</p><p> class  Types::Tweet  &lt;  BaseObject  field  :content ,  String ,  null:  false  field  :author ,  Types :: User ,  null:  false end class  Types::User  &lt;  Types :: BaseObject  field  :nickname ,  String ,  null:  false end class  Types::Viewer  &lt;  Types :: BaseObject  field  :feed ,  [ Types :: Tweet ],  null:  false  def  feed  # In this case, FeedBuilder is a query object  # that returns a Tweet relation based on passed params  FeedBuilder . for ( current_user )  end end class  Types::Query  &lt;  Types :: BaseObject  field  :viewer ,  Types :: Viewer ,  null:  true ,  resolver_method: :current_user end class  GraphqlSchema  &lt;  GraphQL :: Schema  query  Types :: Query end</p><p>类类型：：tweet&lt；BaseObject字段：内容，字符串，NULL：FALSE字段：作者，Types：：User，NULL：FALSE结束类类型：：User&lt；Types：：BaseObject字段：昵称，字符串，NULL：FALSE结束类类型：：查看器&lt；Types：：BaseObject字段：Feed，[Types：：Tweet]，NULL：FALSE def Feed#在本例中，FeedBuilder是返回Tweet关系的查询对象#。对于(CURRENT_USER)结束类类型：：Query&lt；Types：：BaseObject字段：查看器，Types：：Viewer，NULL：TRUE，RESOVER_METHOD：：CURRENT_USER END类GraphqlSchema&lt；GraphQL：：Schema Query Types：：Query End。</p><p> I have also prepared a  gist that contains our whole Rails “application” in a single file. You can’t run it, but it’s functional enough to pass the included specs for comparing different optimization methods that we discuss in this article. To view the code and run the specs, you can run the following in your terminal in any temporary folder:</p><p>我还准备了一份摘要，在一个单独的文件中包含了我们整个Rails的“应用程序”。您不能运行它，但是它的功能足以通过我们在本文后面讨论的比较不同优化方法所包含的规范。要查看代码并运行测试规范，您可以在任何临时文件夹中的终端中运行以下命令：</p><p> curl  &#34;https://gist.githubusercontent.com/DmitryTsepelev/d0d4f52b1d0a0f6acf3c5894b11a52ca/raw/cba338548f3f87c165fc7ec07eb2c5b55120f7a2/2_demo.rb&#34;  &gt; demo.rbcreatedb nplusonedb  # To create a PostgreSQL test database, requires Postgres installationrspec demo.rb  # to run tests that compare different N+1-fighting techniques</p><p>CURL&#34；https://gist.githubusercontent.com/DmitryTsepelev/d0d4f52b1d0a0f6acf3c5894b11a52ca/raw/cba338548f3f87c165fc7ec07eb2c5b55120f7a2/2_demo.rb&#34；&&gt;demo.rbcreatedb nplusonedb#要创建PostgreSQL测试数据库，需要Postgres安装rspec demo.rb#来运行比较不同N+1格斗技术的测试。</p><p> This code contains an N+1 problem right away. Querying the feed that includes nicknames of tweet authors will trigger a single query for  tweets tables, and N queries in  users.</p><p>此代码立即包含一个NN+1问题。查询包括推文作者昵称的推文提要将触发对推文表格的单一查询，并在特定用户中触发N个查询。</p><p> {   query   {   viewer   {   feed   {   content   author   {   nickname   }   }   }   }  }</p><p>{Query{观众{feed{内容作者{昵称}。</p><p>  Let’s start by cleaning up our code and extracting feed loading to a resolver—a special class that encapsulates our database-querying logic.</p><p>让我们从清理代码开始，并将提要加载提取到解析程序--一个封装数据库查询逻辑的特殊类。</p><p> class  Resolvers::FeedResolver  &lt;  BaseResolver  type  [ Types :: Tweet ],  null:  false  def  resolve  FeedBuilder . for ( current_user )  end end class  Types::Viewer  &lt;  Types :: BaseObject  field  :feed ,  resolver:  Resolvers :: FeedResolver end</p><p>类解析器：：FeedResolver&lt；BaseResolver类型[Types：：Tweet]，NULL：False def Resolve FeedBuilder。对于(CURRENT_USER)END类类型：：Viewer&lt；Types：：BaseObject字段：Feed，Resolver：Resolvers：：FeedResolver End。</p><p> If you’re interested, here’s the definition for our  FeedBuilder module that abstracts out some Active Record calls:</p><p>如果您感兴趣，下面是我们的FeedBuilder模块的以下定义，该模块抽象出一些活动记录调用：</p><p>  Extracting logic to a resolver allows us to create alternative resolvers and hot-swap them to compare results. Here’s a resolver that solves the N+1 problem by preloading all associations:</p><p>通过提取逻辑来创建新的解析器，我们可以创建替代的解析器，并对它们进行热插拔，以便更好地比较结果。以下是一个通过预加载所有关联来解决NN+1问题的解析程序：</p><p> class  Resolvers::FeedResolverPreload  &lt;  Resolvers :: BaseResolver  type  [ Types :: Tweet ],  null:  false  def  resolve  FeedBuilder . for ( current_user ). includes ( :author )  # Use AR eager loading magic  end end</p><p>类解析程序：：FeedResolverPreload&lt；解析程序：：BaseResolver类型[Types：：Tweet]，NULL：False def Resolve FeedBuilder。对于(CURRENT_USER)。包括(：作者)#使用AR自动加载魔术结束</p><p> This solution is most obvious, but not ideal: we will make an extra SQL query to preload users no matter what, even if we request just the tweets and don’t care about their authors (I know, it’s hard to imagine, but let’s say it’s for the anonymized data-mining operation).</p><p>这个解决方案是最明显的，但不是最理想的：我们将创建一个额外的SQL查询，以便无论如何都可以预加载用户，即使我们只请求最新的推文，而他们并不关心它们的作者(我知道，这很难想象，但假设这是为了更多的匿名数据挖掘操作)。</p><p> Also, we have to define a list of associations on the top level (in  Query type or inside resolvers that belong to it). It’s easy to forget to add a new association to the list when a new nested field appears deep inside the graph.</p><p>此外，我们还必须在最顶层(在查询类型中或在属于它的内部解析器中)定义一个完整的关联列表。当一个新的嵌套字段出现在图表的深处时，很容易忘记在列表中添加一个新的关联。</p><p> However, this approach is helpful when you know that client  does ask for the author data most of the time (for instance, when you control the frontend code).</p><p>然而，当您知道客户端在大多数情况下(例如，当您控制前端代码时)确实会询问作者的数据时，这种方法非常有用。</p><p>  GraphQL execution engine is a tool responsible for processing a query and preparing a response. Read more in our 3-part  “GraphQL on Rails” tutorial.</p><p>GraphQL执行引擎是一种测试工具，负责处理数据查询并准备数据响应。在我们的三部分教程“GraphQL on Trails”中阅读更多内容。</p><p> While resolving a query, the GraphQL’s  execution engine knows which data was requested, so it’s possible to find out what should be loaded at the runtime. The  graphql-ruby gem comes with a handy  Lookahead feature that can tell us in advance if a specific field was requested. Let’s try it out in a separate resolver:</p><p>在解析数据查询时，GraphQL的执行引擎知道请求了哪些数据，因此有可能在数据运行时找出应该加载的数据。GraphQL-Ruby宝石配备了一个非常方便的Lookhead功能，可以提前告诉我们是否有特定的字段被请求。让我们在另一个单独的解析器中尝试一下：</p><p> class  Resolvers::FeedResolverLookahead  &lt;  Resolvers :: BaseResolver  type  [ Types :: Tweet ],  null:  false  extras  [ :lookahead ]  def  resolve ( lookahead :)  FeedBuilder . for ( current_user )  . merge ( relation_with_includes ( lookahead ))  end  private  def  relation_with_includes ( lookahead )  # .selects?(:author) returns true when author field is requested  return  Tweet . all  unless  lookahead . selects? ( :author )  Tweet . includes ( :author )  end end</p><p>类解析程序：：FeedResolverLookhead&lt；解析程序：：BaseResolver type[Types：：Tweet]，NULL：False Extras[：Lookhead]def Resolve(Lookhead：)FeedBuilder。对于(CURRENT_USER)。Merge(Relationship_with_Includes(Lookhead))End Private def Relationship_with_Includes(Lookhead)#.Select？(：Author)在请求作者字段时返回TRUE返回Tweet。除非向前看，否则一切都是如此。选择？(：作者)推文。包括(：作者)结束端。</p><p> In this case, we make the query in the  users table only when the client asks for the  author field. This approach works fine only in case associations are minimal and not nested. If we take a more complex data model where users have avatars and tweets have likes, then our resolver can get out of hand real quick:</p><p>在本例中，我们仅在客户端要求输入作者字段时，才在USERS表中执行查询。只有在关联最小且不嵌套的情况下，这种方法才能很好地发挥作用。如果我们采用更加复杂的数据模型，其中用户有头像，推文有赞，那么我们的解析器就可以真正快速地脱离控制：</p><p> class  Resolvers::FeedResolverLookahead  &lt;  Resolvers :: BaseResolver  type  [ Types :: Tweet ],  null:  false  extras  [ :lookahead ]  def  resolve ( lookahead :)  scope  =  Tweet . where ( user:  User . followed_by ( current_user ))  . order ( created_at: :desc )  . limit ( 10 )  scope  =  with_author ( scope ,  lookahead )  if  lookahead . selects? ( :author )  scope  =  with_liked_by ( scope ,  lookahead )  if  lookahead . selects? ( :liked_by )  scope  end  private  def  with_author ( scope ,  lookahead )  if  lookahead . selection ( :author ). selects? ( :avatar )  scope . includes ( user: :avatar_attachment )  else  scope . includes ( :user )  end  end  def  with_liked_by ( scope ,  lookahead )  if  lookahead . selection ( :liked_by ). selects? ( :user )  if  lookahead . selection ( :liked_by ). selection ( :user ). selects? ( :avatar )  scope . includes ( likes:  {  user: :avatar_attachment  })  else  scope . includes ( likes: :user )  end  else  scope . includes ( :likes )  end  end end</p><p>类解析程序：：FeedResolverLookhead&lt；解析程序：：BaseResolver type[Types：：Tweet]，NULL：False Extras[：Lookhead]def Resolve(Lookhead：)Scope=Tweet。其中(用户：用户。后跟_(CURRENT_USER))。订单(CREATED_AT：：DESC)。LIMIT(10)SCOPE=WITH_AUTHER(作用域，前视)，如果是前视。如果先行查找，则选择？(：作者)SCOPE=WITH_LIKE_BY(SCOPE，LOOKAAD)。如果先行查找，则选择？(：LIKE_BY)作用域结束私有定义WITH_AUTHER(作用域，前视)。精选(：作者)。选择？(：阿凡达)范围。包括(User：：Avata_Attach)其他作用域。如果先行查找，则包含(：user)end end def with_like_by(scope，lookhead)。精选(：Like_By)。如果向前看，则选择？(：User)。精选(：Like_By)。选择(：用户)。选择？(：阿凡达)范围。包括(Like：{user：：Avata_Attach})其他作用域。包括(Like：：User)End Else作用域。包括(：赞)结束</p><p> You’re right, that’s not elegant at all! What if there was a way to load associations  only when they are accessed? Lazy preloading can help us!</p><p>你说得对，那一点也不优雅！如果有一种更好的方法，只在关联被访问时才加载它们，那该怎么办？懒惰的预装可以帮助我们！</p><p>  With some help from my Evil Martian colleagues, I’ve written a little gem called  ar_lazy_preload that lets us fall back to the preloading solution but makes it smarter without any additional effort. It makes a single request to fetch all associated objects  only after the association was accessed for the first time. Of course, it works outside of GraphQL examples too and can be really handy in REST APIs or while building server-rendered views. All you need is to add  gem &#34;ar_lazy_preload&#34; to your Gemfile,  bundle install, and then you’ll be able to write your resolver like so:</p><p>在邪恶火星同事的一些帮助下，我写了一个名为ar_lazy_preload的小宝石，它让我们可以后退到最新的预加载解决方案，但不需要任何额外的努力就能让它变得更智能。它发出一个单独的请求，仅在第一次访问该关联之后才会提取所有关联的对象。当然，它也可以在GraphQL示例之外工作，在构建服务器渲染的视图时，它在Rest API或应用程序中非常方便。你所需要做的就是添加gem&34；ar_lazy_preload&#34；来安装你的Gemfile，捆绑安装，然后你就可以像这样写你的解析器了：</p><p>  The gem is created with  laziness in mind, so if you feel lazy even to type  .lazy_preload all the time, you can enable it globally for all Active Record calls by adding a line of configuration:</p><p>GEM的创建完全是出于懒惰的考虑，所以如果你觉得懒惰，即使一直都在输入.lazy_preload，你可以通过添加一行配置来全局启用它，用于所有活动的记录调用：</p><p>   we do not have much control over queries that are made and it will be hard to customize them;</p><p>我们对所做的查询没有太多的控制权，因此很难对其进行定制；</p><p>  if lazy preloading is not turned on, we still have to list all possible associations at the top level;</p><p>如果懒惰预加载没有打开，我们还是要在最顶层列出所有可能的联想；</p><p>  if one table is referenced from two places, we will make twice the database requests.</p><p>如果一个表从两个地方被引用，我们将发出两倍的数据库请求。</p><p>   The  graphql-ruby gem that makes GraphQL possible in our Ruby apps comes bundles with a way to use  lazy execution:</p><p>在我们的Ruby应用程序中，GraphQL-ruby宝石使GraphQL成为可能，它捆绑了一种更好的方式来使用懒惰执行：</p><p> instead of returning data, you can return a special  lazy object (this object should remember the data it replaced);</p><p>你可以返回一个特殊的懒惰对象，而不是返回数据(这个对象应该记住它替换的数据)；</p><p>  when a lazy value is returned from a resolver, the execution engine stops further processing of the current subtree;</p><p>当数据解析器返回懒惰值时，数据执行引擎停止对当前子树的进一步处理；</p><p>  when all non–lazy values are resolved, the execution engine asks the lazy object to resolve;</p><p>当所有非惰性值都被解析时，执行引擎会要求懒惰对象进行解析；</p><p>  lazy object loads the data it needs to resolve and returns it for each lazy field.</p><p>惰性对象加载它需要解析的数据，然后为每个惰性字段返回该数据。</p><p> It takes some time to wrap your head around this, so let’s implement a lazy resolver step by step. First of all, we can reuse the initial  FeedResolver that is not aware of associations:</p><p>这需要一些时间才能完全理解这一点，所以让我们一步一步地实现一个懒惰的解析器。首先，我们可以重复使用不知道这些关联的初始FeedResolver：</p><p>  Then, we should return a lazy object from our  Tweet type. We need to pass the ID of the user and a query context because we will use it to store a list of IDs to load:</p><p>然后，我们应该从我们的Tweet类型返回一个非常懒惰的对象。我们需要先传递第一个用户的ID并提供一个完整的查询上下文，因为我们将使用它来存储要加载的ID的列表：</p><p> class  Types::Tweet  &lt;  Types :: BaseObject  field  :content ,  String ,  null:  false  field  :author ,  Types :: User ,  null:  false  def  author  Resolvers :: LazyUserResolver . new ( context ,  object . user_id )  end end</p><p>类类型：：tweet&lt；Types：：BaseObject字段：Content，String，NULL：FALSE字段：Author，Types：：User，NULL：False def Author Resolver：：LazyUserResolver。新建(上下文、对象。User_id)结束。</p><p> Each time a new object is initialized, we add a pending user ID to the query context, and, when  #user is called for the first time, we make a single database request to get all the users we need. After that, we can fill user data for all lazy fields. Here is how we can implement it:</p><p>每次初始化一个新对象时，我们都会添加一个挂起的用户ID来更新查询上下文，当第一次调用#user时，我们会发出一个单独的数据库请求，以确保获得我们需要的所有用户。之后，我们可以填写所有惰性字段的用户数据。以下是我们如何实施它：</p><p> class  Resolvers::LazyUserResolver  def  initialize ( context ,  user_id )  @user_id  =  user_id  @lazy_state  =  context [ :lazy_user_resolver ]  ||=  {  user_ids:  Set . new ,  users_cache:  nil  }  @lazy_state [ :user_ids ]  &lt;&lt;  user_id  end  def  user  users_cache [ @user_id ]  end  private  def  users_cache  @lazy_state [ :users_cache ]  ||=  begin  user_ids  =  @lazy_state [ :user_ids ]. to_a  @lazy_state [ :user_ids ]. clear  User . where ( id:  user_ids ). index_by ( &amp; :id )  end  end end</p><p>类解析器：：LazyUserResolver def Initialize(Context，user_id)@user_id=user_id@lazy_state=Context[：LAZY_USER_RESOVER]||={user_ids：set。新建，USERS_CACHE：nil}@LAZY_STATE[：user_ids]&lt；&lt；user_id end def user_cache[@user_id]end私有定义USERS_CACHE@LAZY_STATE[：USERS_CACHE]||=BEGIN USER_ID=@LAZY_STATE[：USER_ID]。To_a@lazy_state[：user_ids]。清除用户。其中(id：user_ids)。INDEX_BY(&amp；：ID)结束</p><p> Wondering how the execution engine can tell the difference between regular and lazy objects? We should define lazy resolver in the schema:</p><p>想知道执行引擎如何才能区分常规对象和懒惰对象？我们应该在模式中定义懒惰解析器：</p><p>  It tells the execution engine to stop resolving users when the  Resolvers::LazyUserResolver object is returned and only come back to it  after all the other, non-lazy fields are resolved.</p><p>它告诉执行引擎在解析程序：：LazyUserResolver对象未返回时停止解析用户，只有在其他所有非惰性字段解析完成后才会返回解析它。</p><p> That works, but it’s quite a bit of boilerplate code that you might have to repeat often. Plus, the code can become quite convoluted when our lazy resolvers need to resolve other lazy objects. Fortunately, there exists a less verbose alternative.</p><p>这是可行的，但这是相当多的样板代码，你可能不得不经常重复。此外，当我们的懒惰解析器需要解析其他懒惰对象时，代码可能会变得相当复杂。幸运的是，还有一种不那么冗长的替代方案。</p><p>  The gem  graphql-batch from Shopify uses the same lazy mechanism of  graphql-ruby but hides the ugly boilerplate part. All we need to do is inherit from  GraphQL::Batch::Loader and implement the  perform method:</p><p>来自Shopify的宝石GraphQL-Batch使用了与GraphQL-Ruby相同的懒惰机制，但隐藏了难看的样板部分。我们需要做的就是继承GraphQL：：Batch：：Loader，并实现下一步的Performance方法：</p><p> class  RecordLoader  &lt;  GraphQL :: Batch :: Loader  def  initialize ( model )  @model  =  model  end  def  perform ( ids )  @model . where ( id:  ids ). each  {  | record |  fulfill ( record . id ,  record )  }  ids . each  {  | id |  fulfill ( id ,  nil )  unless  fulfilled? ( id )  }  end end</p><p>类RecordLoader&lt；GraphQL：：Batch：：Loader def Initialize(Model)@model=model end def Perform(IDS)@model。其中(id：ids)。每个{|记录|完成(记录。ID，记录)}个ID。除非已完成？(ID)}结束，否则每个{|ID|FULTURE(ID，NIL)结束。</p><p> This loader (taken from the  examples directory in the official repo) expects a model class in the initializer (to decide where the data should be loaded from).  #perform method is responsible for fetching data,  #fulfill method is used to associate a key with the loaded data.</p><p>这个加载器(取自官方repo中的示例目录)在初始化式中需要一个新的模型类(以决定数据应该从哪里加载)。#Performance Method主要负责获取数据，#Fully Method主要用于将关键字与已加载的数据进行关联。</p><p> Batch loader usage is similar to the lazy version. We pass  User to the initializer and ID of the user to load lazily (this ID will be used as a key to fetch the associated user):</p><p>批处理加载器的使用与它的懒惰版本非常相似。我们将User传递给第一个初始值设定项和第二个用户的ID，以便延迟加载(这个ID将被用作获取第二个关联用户的关键字)：</p><p> class  Types::Tweet  &lt;  BaseObject  field  :content ,  String ,  null:  false  field  :author ,  Types :: User ,  null:  false  def  author  RecordLoader . for ( :: User ). load ( object . author_id )  end end</p><p>类类型：：tweet&lt；BaseObject字段：Content，String，NULL：FALSE字段：Author，Types：：User，NULL：False def Author RecordLoader。对于(：：User)。加载(对象。Author_id)结束结束</p><p>   How does this work? When  use GraphQL::Batch is added to the schema,  Promise#sync method is registered to resolve lazily (it uses  Promise.rb under the hood). When  #load method is called on a class that inherits from  GraphQL::Batch::Loader, it returns a  Promise object—that is why the execution engine treats it as a lazy value.</p><p>这是怎么回事？当将Use GraphQL：：Batch添加到模式中时，Promise#Sync方法会被注册为懒惰地进行解析(它在幕后使用Promise.rb)。当在从GraphQL：：Batch：：Loader继承的类上调用#Load Method时，它返回一个新的Promise对象-这就是为什么应用执行引擎将其视为一个惰性值。</p><p> This approach has a useful side–effect—you can chain loading in the following way:</p><p>这种方法有一个非常有用的副作用--你可以通过以下方式链式加载：</p><p>   But even with all the advanced techniques we described above, it is still possible to end up with N+1. Imagine that we are adding an admin panel where you can see a list of users. When a user is selected, a user profile pops up, and you can see a list of their followers. In GraphQL world, where data should be accessed from the place it belongs to, we could do something like this:</p><p>但是，即使有了我们上面描述的所有高级技术，最终仍有可能得到N+1。想象一下，我们正在添加一个管理面板，您可以在其中看到一个完整的用户列表。当用户被选中时，会弹出一个新的用户档案，然后你就可以看到他们的粉丝的详细列表。在GraphQL的世界里，数据应该从它所属的地方直接访问，我们可以这样做：</p><p> class  Types::User  &lt;  BaseObject  field  :nickname ,  String ,  null:  false  field  :followers ,  [ User ],  null:  false  do  argument  :limit ,  Integer ,  required:  true ,  default_value:  2  argument  :cursor ,  Integer ,  required:  false  end  def  followers ( limit :,  cursor:  nil )  scope  =  object . followers . order ( id: :desc ). limit ( limit )  scope  =  scope . where ( &#34;id &lt; cursor&#34; ,  cursor )  if  cursor  scope  end end class  Types::Query  &lt;  BaseObject  field  :users ,  [ User ],  null:  false  field  :user ,  User ,  null:  true  do  argument  :user_id ,  ID ,  required:  true  end  def  users  :: User . all  end  def  user ( user_id :)  :: User . find ( user_id )  end end</p><p>类类型：：User&lt；BaseObject字段：昵称，字符串，NULL：FALSE字段：Followers，[user]，NULL：FALSE DO参数：Limit，Integer，Required：True，Default_Value：2 Argument：Cursor，Integer，Required：False End Def Followers(Limit：，Cursor：Nil)Scope=Object。追随者。订单(ID：：DESC)。限制(限制)范围=范围。如果游标范围结束类类型：：Query&lt；BaseObject字段：USERS，[USER]，NULL：FALSE字段：USER，USER，NULL：TRUE DO参数：USER_ID，ID，REQUIRED：TRUE END DEF USERS：：USER。所有终端定义用户(user_id：)：：user。查找(User_Id)结束端。</p><p>    query   GetUser ( $userId :   ID ,   $followersLimit :   Int ,   $followersCursor :   ID )   {   user ( userId :   $userId )   {   followers ( limit :   $limit ,   cursor :   $followersCursor )   {   nickname   }   }  }</p><p>查询GetUser($UserID：ID，$FollowersLimit：Int，$FollowersCursor：ID){user(UserID：$UserID){Followers(Limit：$Limit，Cursor：$FollowersCursor){昵称}}。</p><p> The problem appears when someone tries to load a list of users  with their followers in the same query:</p><p>当有人试图在相同的查询中用自己的追随者加载一个完整的用户列表时，就会出现这个问题：</p><p> query   GetUsersWithFollowers (   $limit :   Int   $followersLimit :   Int   $followersCursor :   ID  )   {   users ( limit :   $limit )   {   nickname   followers ( limit :   $limit ,   cursor :   $followersCursor )   {   nickname   }   }  }</p><p>查询GetUsersWithFollowers($Limit：INT$FollowersLimit：INT$FollowersCursor：ID){Users(Limit：$Limit){昵称Followers(Limit：$Limit，Cursor：$FollowersCursor){昵称}}。</p><p> In this case, we cannot get rid of N+1 at all: we have to make a database call for each user because of cursor pagination. To handle such a case, we could to use the less elegant solution and move pagination to the top level:</p><p>在这种情况下，我们根本摆脱不了N+1：因为游标分页，我们不得不为每个用户做一个简单的数据库调用。要更好地处理这样的案件，我们可以改用不那么优雅的解决方案，并将分页移动到最高层：</p><p> class  Types::Query  &lt;  BaseObject  field  :users ,  [ User ],  null:  false  field  :user ,  User ,  null:  true  do  argument  :user_id ,  ID ,  required:  true  end  field  :user_followers ,  [ User ],  null:  false  do  argument  :limit ,  Integer ,  required:  true ,  default_value:  2  argument  :cursor ,  Integer ,  required:  false  end  def  users  :: User . all  end  def  user ( user_id :)  :: User . find ( user_id )  end  def  user_followers ( user_id :,  limit :,  cursor:  nil )  scope  =  UserConnection . where ( user_id:  user_id ). order ( user_id: :desc ). limit ( limit )  scope  =  scope . where ( &#34;user_id &lt; cursor&#34; ,  cursor )  if  cursor  scope  end end</p><p>类类型：：Query&lt；BaseObject字段：USERS，[USER]，NULL：FALSE字段：USER，USER，NULL：TRUE DO参数：user_id，ID，Required：TRUE结束字段：USER_Followers，[User]，NULL：FALSE DO参数：Limit，Integer，Required：TRUE，DEFAULT_VALUE：2参数：Cursor，Integer，Required：FALSE End Def Users：：User。所有终端定义用户(user_id：)：：user。Find(User_Id)end def user_Followers(user_id：，Limit：，Cursor：nil)Scope=UserConnection。其中(user_id：user_id)。订单(user_id：：desc)。限制(限制)范围=范围。如果游标作用域结束，则其中(&#34；user_id&lt；Cursor&#34；，Cursor)。</p><p> This design still makes it possible to load users and their followers, but it turns out that we move from N+1 on the server side to N+1 HTTP requests. The solution looks fine, but hey, we love GraphQL for its logical schema structure! We want to fetch followers from the  User type!</p><p>这种设计仍然可以让用户轻松加载用户并吸引他们的追随者，但事实证明，我们从传统服务器端的N+1移动到了N+1个HTTP请求。这个解决方案看起来不错，但是嘿，我们喜欢GraphQL的逻辑架构结构！我们想要从新的用户类型中获得追随者！</p><p> No problem. We can to restrict fetching the  followers field when multiple users are requested. Let’s return an error when it happens:</p><p>没问题。我们可以限制在请求多个用户时获取更多关注者字段。当发生这种情况时，让我们返回一个错误：</p><p> class  Types::Query  &lt;  BaseObject  field  :users ,  [ User ],  null:  false ,  extras:  [ :lookahead ]  field  :user ,  User ,  null:  true  do  argument  :user_id ,  ID ,  required:  true  end  def  users ( lookahead :)  if  lookahead . selects? ( :followers )  raise  GraphQL :: ExecutionError ,  &#34;followers can be accessed in singular association only&#34;  end  :: User . all  end  def  user ( user_id :)  :: User . find ( user_id )  end end</p><p>类类型：：Query&lt；BaseObject字段：Users，[user]，NULL：FALSE，Extras：[：Lookhead]字段：User，User，NULL：TRUE DO参数：user_id，id，Required：True End Def Users(Lookhead：)if Lookhead。选择？(：关注者)提升GraphQL：：ExecutionError，&#34；关注者只能以单一关联&#34；End：：User访问。所有终端定义用户(user_id：)：：user。查找(User_Id)结束端。</p><p> With this schema, it’s still possible to fetch followers of a singular user, and we have completely prevented the unwanted scenario. Don’t forget to mention it in the docs!</p><p>有了这个方案，仍然有可能吸引一个单一用户的追随者，而且我们已经完全防止了不想要的情况。别忘了在我们的文档中提到这一点！</p><p> That’s it! You’ve made it to the end of our little guide, and now you have at least six different approaches to try out in your Ruby-GrapgQL code to make your application N+1 free.</p><p>就这样!。你已经完成了我们的小指南，现在你至少有六种不同的方法可以在你的Ruby-GrapgQL代码中试用，从而让你的应用程序N+1免费。</p><p> Don’t forget to check out other articles on GraphQL and N+1 problem in our blog: from the beginner-friendly code-along tutorial on building a Rails GraphQL application with React frontend in three parts (start  here) to the more specific use-cases of  using GraphQL with Active Storage Direct Upload, dealing with  persisted queries coming from Apollo, and  reporting non-nullable violations in  graphql-ruby.</p><p>别忘了在我们的博客上查看关于GraphQL和N+1问题的其他文章：从初学者友好的代码沿线教程(分三部分(从这里开始)介绍如何使用Active Storage Direct Upload构建一个GraphQL应用程序和Reaction前端)，到更具体的使用案例-使用GraphQL和Active Storage Direct Upload，处理来自Apollo的持久化查询，以及在GraphQL-Ruby中报告不可为空的违规。</p><p> We also have a couple of gems to make dealing with N+1 easier in “classic” Rails apps and a couple of articles to go along with them:  Squash N+1 queries early with n_plus_one_control test matchers for Ruby and Rails and  Fighting the Hydra of N+1 queries.</p><p>我们还有几个小技巧可以让处理N+1变得更容易，比如在经典的Rails应用程序中处理N+1更容易，我们还提供了几篇与之配套的文章：使用Ruby和Trails的n_plus_one_control测试匹配器及早粉碎N+1个查询，以及如何对抗N+1个查询的九头蛇(Hydra)查询。</p><p>  Over the past few years, our team has invested a lot of effort, including building open source, for making GraphQL a first-class citizen in Rails applications. If you think of introducing a GraphQL API in  your Ruby backend—feel free to  give us a shout.</p><p>在过去的几年里，我们的团队投入了大量的精力，包括构建开源，让GraphQL成为Erails应用领域的一流公民。如果你想在你的Ruby后端引入一个新的GraphQL API--尽管跟我们联系吧。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://evilmartians.com/chronicles/how-to-graphql-with-ruby-rails-active-record-and-no-n-plus-one">https://evilmartians.com/chronicles/how-to-graphql-with-ruby-rails-active-record-and-no-n-plus-one</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rails/">#rails</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033533.html"><img src="http://img2.diglog.com/img/2020/11/thumb_cccadfda5717fb02f0d800b74567d803.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033533.html">为什么不是GraphQL呢？REST API更胜一筹，但GraphQL仍胜出</a></div><span class="my_story_list_date">2020-11-6 18:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032573.html"><img src="http://img2.diglog.com/img/2020/11/thumb_390e8ddcba753f161bef2fd17e1dfc95.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032573.html">OpenAPI-to-GraphQL</a></div><span class="my_story_list_date">2020-11-1 11:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031558.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fb0b501bde81980754d20d39df41c8e8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031558.html">GraphQL Editor 3.0-新版本</a></div><span class="my_story_list_date">2020-10-28 2:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030324.html"><img src="http://img2.diglog.com/img/2020/10/thumb_8cfda1366c590932e2fd6101bfca173d.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030324.html">GraphQL和REST API只需几秒钟，Hypi的低码后端即可成为服务</a></div><span class="my_story_list_date">2020-10-22 3:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>