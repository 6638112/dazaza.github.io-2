<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在RISC-V上加载到X0时会发生什么？ What happens when you load into x0 on RISC-V?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What happens when you load into x0 on RISC-V?<br/>在RISC-V上加载到X0时会发生什么？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-16 13:33:43</div><div class="page_narrow text-break page_content"><p>A small thing of which I am irrationally proud: I was the proximate cause for the addition of a sentence to the  RISC-V ISA spec.</p><p>我是一个不合理的人自豪的小事：我是向RISC-V ISA规范添加句子的近似原因。</p><p>  Loads with a destination of x0 must still raise any exceptions and cause any other side effects even though the load value is discarded.</p><p>  带有X0的目的地的负载必须仍然介绍任何异常，并使任何其他副作用即使丢弃负载值也是如此。</p><p>    In the summer of 2016, I wrote most of the initial RISC-V Go compiler implementation. ( Michael Pratt and  Benjamin Barenblat worked on the assembler, linker, and runtime, and other people  jumped in and  ultimately completed the port.)</p><p>    在2016年夏天，我写了大部分初始RISC-V Go Compiler实现。 （Michael Pratt和Benjamin Barenblat在汇编程序，链接器和运行时工作，其他人跳入并最终完成了港口。）</p><p> I was writing the first version of the RISC-V SSA lowering rules. Those rules turn a generic, architecture-independent description of Go code into a RISC-V-specific set of operations that ultimately get lowered into RISC-V instructions.</p><p> 我正在编写第一个版本的RISC-V SSA降低规则。这些规则将GO代码的通用，架构无关描述为RISC-V特定的操作集，最终降低到RISC-V指令中。</p><p>    type  T  struct {  a [ 5000] byte  // we&#39;ll explain this later   b  bool} func  f( t  * T) {  _ =  t. b}</p><p>    type t struct {a [5000]字节// we＆＃39; ll解释出这个稍后b bool} func f（t * t）{_ = t。 B}</p><p> f does  almost nothing. But not nothing.  f evaluates  t.b for side-effects. If  t is nil,  f panics.</p><p> F几乎没有。但不是什么。 f评估T.B以进行副作用。如果T是零，F ancics。</p><p> In the Go compiler, this is (unsurprisingly) called a nil check. The compiler arranges to execute an instruction that will fault if  t is nil.</p><p> 在Go编译器中，这是（不出所料）称为NIL检查。如果T为零，编译器将安排执行将发生故障的指令。 </p><p>   Get the value of  t off of the stack and put it in the  AX register.</p><p>获取堆栈中T的值并将其放在轴寄存器中。</p><p>  Load the value pointed to by  AX and do something with it. The parens around  AX mean dereference the pointer in the  AX register. It doesn&#39;t matter here what the  TESTB instruction does; it was chosen because it is short to encode. It&#39;s the deferencing that matters. If the load faults, the runtime will receive a signal and turn that into a panic.</p><p>  加载轴指向的值并用它做点什么。 AX周围的柱均衡AX寄存器中的指针。它在此处并不重要，这是测试的指示;它被选中，因为它是短暂的编码。它＆＃39;这是重要的推进。如果负载故障，则运行时将接收信号并将其转换为恐慌。</p><p>     There are  lots of nil checks in a typical Go program. As an optimization, the runtime allocates a  guard page at address 0, typically with size 4096 bytes. Any loads from an address &lt; 4096 will fault.</p><p>     典型的Go程序中有很多零检查。作为优化，运行时在地址0处分配保护页面，通常具有大小为4096字节。从地址且来自地址的任何加载4096将出现故障。</p><p> As a result, if you&#39;re dereferencing a struct field with a small offset, we can directly attempt to load from the calculated address of that struct field. If the pointer is zero, then the calculated address will be &lt; 4096, and it&#39;ll fault. There&#39;s no need for a separate, explicit nil check.</p><p> 结果，如果您＆＃39;重新取消引用具有小偏移量的结构字段，我们可以直接尝试从计算出的该结构字段的地址加载。如果指针为零，则计算出的地址将是＆lt; 4096，它＆＃39; ll故障。在那里没有必要单独的，明确的零支票。</p><p> For example, if I had used  [20]byte above, then  *t.b requires loading from  t plus 20. If  t is nil (0), then that address is 20, which is located in the guard page.</p><p> 例如，如果我在上面使用的[20]字节，则* t.b需要从t加20加载。如果t为nil（0），则该地址为20，位于Guard页面中。</p><p> Since we have a  [5000]byte field above, the guard page isn&#39;t enough, so we need an explicit nil check.</p><p> 由于我们上面有一个[5000]字节字段，因此Guard页面＆＃39; t足够，所以我们需要一个明确的零支票。</p><p> This makes it sounds like explicit nil checks are exceedingly rare. They&#39;re not; they show up in other ways too.</p><p> 这使它听起来像明确的零检查非常罕见。他们＆＃39;重新;他们也以其他方式出现。 </p><p>   RISC-V has a dedicated  zero register,  x0. It always holds the value zero, and writes to it are discarded. It&#39;s like  /dev/null and  /dev/zero rolled into one.</p><p>RISC-V具有专用零寄存器X0。它始终保持零值，并丢弃它的写入。它＆＃39; s喜欢/ dev / null和/ dev / zero滚动到一个。</p><p> It sounds like just the thing for a nil check: We can derefence the pointer and load the value into  x0.</p><p> 这听起来像是一个nil检查的东西：我们可以将指针放在x0中的指针并加载到x0中。</p><p>   It is almost identical to the amd64 version. The first instruction loads the pointer from the stack. The second instruction dereferences it into  x0. The final instruction returns.</p><p>   它几乎与AMD64版本相同。第一个指令从堆栈加载指针。第二个指令将其解除到X0中。最终的指令返回。</p><p>   If you&#39;re loading a value in order to discard it, do you really need to load it at all? if you&#39;re writing to  x0, maybe you can just skip it.</p><p>   如果你＆＃39;重新加载一个值才能丢弃它，你真的需要加载它吗？如果你＆＃39;重新写入x0，也许你可以跳过它。</p><p> There is an analog from amd64. The  CMOV instruction does a conditional move. If a flag is set, then it loads or moves a value, and not otherwise. It shows up when compiling code like this:</p><p> 来自AMD64的类似物。 CMOV指令有条件移动。如果设置了标志，则它会加载或移动值，而不是其他。它在编译这样的代码时出现：</p><p> func  g( x  int)  int {	 y  :=  1	 if  x  ==  0 {		 y =  3	}	 return  y}</p><p> Func g（x int）int {y：= 1如果x == 0 {y = 3}返回y}</p><p>   TESTQ sets the  EQ flag if x is 0. The next two instructions put 1 in  AX and 3 in  CX. Last, if the  EQ flag is set, we move  CX into  AX.  AX now holds the correct value of y to return.</p><p>   TestQ设置EQ标志如果x为0.下一个指令在CX中放入AX和3中。最后，如果设置了EQ标志，我们将CX移动到AX中。 AX现在持有y的正确值返回。 </p><p> If a  CMOV instruction includes a load from memory, that load is done unconditionally, even though the write of that value into the destination register is conditional.</p><p>如果CMOV指令包括来自存储器的负载，则即使将该值写入目标寄存器的位置是条件的，也会无条件地完成该负载。</p><p> I knew (and know) approximately nothing about hardware, but I can guess why this is a good decision. If you&#39;re doing out of order execution, you might not know yet what the flags are going to be when you reach that  CMOV instruction. But memory loads are slow. We want to start that memory load early for maximum benefit. So it is useful to be able to do the load unconditionally, even if it is inconvenient for compiler developers.</p><p> 我知道（并知道）关于硬件，我猜测为什么这是一个很好的决定。如果您＆＃39;重新执行订单执行，您可能不知道旗帜将在达到CMOV指令时是什么。但内存负荷很慢。我们希望早期开始该内存负载以获得最大的好处。因此，能够无条件地执行负载是有用的，即使对编译器开发人员不方便。</p><p> But the same consideration doesn&#39;t really apply to RISC-V. There&#39;s no uncertainty about whether the instruction writes to  x0. Skipping the load would be easy and cheap.</p><p> 但同样的考虑不适用于RISC-V。在那里没有关于指令是否写入X0的不确定性。跳绳将是简单又便宜的。</p><p>    We debated this hole in the spec at length, but neglected to write down the conclusion.</p><p>    我们在规格中辩论了这个洞，但忽略了写下结论。</p><p> The main reason we went with this definition is cleaner semantics for memory-mapped I/O loads that trigger side effects. The opposite choice is also defensible (it gives you a non-binding prefetch instruction for free).</p><p> 我们使用此定义的主要原因是用于触发副作用的内存映射I / O负载的清洁语义。相反的选择也是可靠的（它为您提供免费的非绑定预取指令）。</p><p> Light-years ahead of me, unsurprisingly. But convenient for Go&#39;s nil checks. And me having asked did help tie up one little loose end.</p><p> 未兴望的灯光，未享受。但方便的Go＆＃39; s nil checks。我已经问过确实有助于捆绑一个有点松散。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://commaok.xyz/post/riscv_isa_blog_post/">https://commaok.xyz/post/riscv_isa_blog_post/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/时会/">#时会</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/x0/">#x0</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>