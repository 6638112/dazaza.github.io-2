<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通过Python而不是常规Bash程序轻松处理CLI操作Easily handle CLI operation via Python instead of regular Bash programs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Easily handle CLI operation via Python instead of regular Bash programs<br/>通过Python而不是常规Bash程序轻松处理CLI操作</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 00:16:38</div><div class="page_narrow text-break page_content"><p>Ever wished to use Python in Bash? Would you choose the Python syntax over  sed,  awk, ...? Should you exactly know what command would you use in Python, but you end up querying  man again and again, read further. The utility allows you to  pythonize the shell: to pipe arbitrary contents through  pz, loaded with your tiny Python script.</p><p>有没有想过在Bash中使用Python？你会选择Python语法而不是sed、awk等等吗。。。？如果您确切地知道在Python中使用什么命令，但最终却一次又一次地查询man，请进一步阅读。该实用工具允许您对shell进行pythonize：通过pz传输任意内容，并加载您的小Python脚本。</p><p>         How does your data look when pythonized via  pz? Which Bash programs may the utility substitute?</p><p>通过pz进行pythonization时，您的数据看起来如何？实用程序可以替代哪些Bash程序？</p><p>    Note that suppressing quotes around the argument may not work (Zsh) or lead to an unexpected behaviour:  touch s1 &amp;&amp; echo &#34;hello&#34; | pz s[1] →  Exception: &lt;class &#39;NameError&#39;&gt;. Use  echo &#34;hello&#34; | pz &#39;s[1]&#39; instead.</p><p>请注意，在参数周围隐藏引号可能不起作用（Zsh）或导致意外行为：触摸s1&amp&amp；echo和#34；你好&#34；|pz s[1]→  例外情况：&lt；39岁；名称错误&#39&gt；。使用echo和#34；你好&#34；|pz和#39；s[1]和#39；相反</p><p>   # let&#39;s use the f-string `--format` flagtail -f /var/log/syslog  | pz -f   &#39;{len(s)}: {s} &#39;   # or do it the long way, explicitly setting the `s` variabletail -f /var/log/syslog  | pz   &#39;s = str(len(s)) + &#34;: &#34; + s &#39;</p><p>#让&#39；使用f-string`--format`flagtail-f/var/log/syslog |pz-f&#39；{len（s）}：{s}&#39；#或者长期使用，显式设置's'variabletail-f/var/log/syslog | pz&#39；s=str（len（s））+&#34；：&#34; + s&#39；</p><p>     Replacing  cut. Note you can chain multiple  pz calls. Split by a comma &#39; ,&#39;, then use  n to access the line converted to a number.</p><p>替换切口。注意，您可以链接多个pz呼叫。被逗号分隔&#39&#39;, 然后使用n访问转换为数字的行。</p><p>   Replacing  sed. We know that all functions from the  re library are already included, ex: &#34;findall&#34;.</p><p>替换sed。我们知道re库中的所有功能都已经包括在内，例如：&#34；findall&#34；。</p><p> # either use the `--findall` flagpz --findall   &#34;(https?://[^\s]+) &#34;  &lt; file.log  # or expand the full command to which is the `--findall` flag equivalentpz   &#34;findall(r&#39;(https?://[^\s]+)&#39;, s) &#34;  &lt; file.log</p><p>#或者使用`--findall`flagpz--findall&#34；（https？：/[^\s]+）和#34&书信电报；文件记录#或展开“--findall”标志等效于tpz&#34的完整命令；findall（r&#39；（https？：/[^\s]+）&#39；，s） &#34&书信电报；文件日志</p><p> If chained, you can open all the URLs in the current web browser. Note that the function  webbrowser.open gets auto-imported from the standard library.</p><p>如果链接，则可以在当前web浏览器中打开所有URL。请注意，功能webbrowser。open从标准库自动导入。</p><p>   Replacing  | awk &#39;{count+=$1} END{print count}&#39; or  | paste -sd+ | bc. Just use  sum in the  --end clause.</p><p>更换| awk和#39；{count+=$1}END{print count}&#39；或者|粘贴-sd+| bc。只需在--end子句中使用sum。</p><p> # internally changed to --end `s = sum(numbers)` echo -e   &#34;1\n2\n3\n4 &#34;  | pz --end sum   # 10</p><p>#内部更改为--end`s=sum（number）`echo-e&#34；1\n2\n3\n4&#34；|pz——最终总和#10</p><p>  Replacing  | sort | uniq makes little sense, but the demonstration gives you the idea. We initialize a set  c (like a  collection). When processing a line,  skip is set to  True if already seen.</p><p>替换| sort | uniq没有什么意义，但演示给出了一个想法。我们初始化一个集合c（就像一个集合）。在处理一行时，如果已经看到跳过，则将其设置为True。</p><p>  However, an advantage over  | sort | uniq comes when handling a stream. You see unique lines instantly, without waiting a stream to finish. Useful when using with  tail --follow.</p><p>然而，与| sort | uniq相比，在处理流时有一个优势。您可以立即看到独特的线条，而无需等待流结束。与tail一起使用时很有用——跟随。</p><p> Alternatively, to assure the values are sorted, we can make a use of  --end flag that produces the output after the processing finished.</p><p>或者，为了确保对值进行排序，我们可以使用--end标志，在处理完成后生成输出。</p><p>  Note that we used the variable  S which is initialized by default to an empty set (hence we do not have to use  --setup at all) and the flag  -0 to prevent the processing from output (we do not have to use  skip parameter then).</p><p>请注意，我们使用了默认情况下初始化为空集的变量S（因此我们根本不必使用--setup）和标志-0来防止处理输出（我们不必使用skip参数）。</p><p> (Strictly speaking we could omit  -0 too. If you use the verbose  -v flag, you would see the command changed to  s = S.add(s) internally. And since  set.add produces  None output, it is the same as if it was skipped.)</p><p>（严格来说，我们也可以省略-0。如果使用verbose-v标志，您会看到命令在内部更改为s=s.add（s）。从设定开始。“添加”不会生成任何输出，这与跳过它的情况相同。）</p><p> We can omit  (s) in the  main clause and hence get rid of the quotes all together.</p><p>我们可以省略主句中的（s），从而去掉所有的引号。</p><p>  Nevertheless, the most straightforward approach would involve the  lines variable, available when using the  --end clause.</p><p>然而，最直接的方法是使用--end子句时使用lines变量。</p><p>   We split the line to get the words and put them in  S, a global instance of the  set. Then, we print the set length to get the number of unique words.</p><p>我们将行拆分以获取单词，并将它们放入S中，这是集合的一个全局实例。然后，我们打印设置的长度以获得唯一单词的数量。</p><p>  But what if we want to get the most common words and the count of its usages? Let&#39;s use  C, a global instance of the  collections.Counter. We see then the  red is the most_common word and has been used 2 times.</p><p>但是，如果我们想得到最常见的单词及其用法，该怎么办？让&#39；让我们使用C，一个集合的全局实例。柜台我们看到红色是最常见的词，已经被使用了两次。</p><p> $  echo -e   &#34;red green\nblue red green &#34;  | pz   &#39;C.update(s.split()) &#39; --end C.most_commonred, 2green, 2blue, 1</p><p>$echo-e&#34；红绿\n蓝红绿&#34；|pz和#39；C.更新（s.split（））和#39--C端：最常见的红色、绿色、蓝色、1</p><p>  Accessing internet is easy thanks to the   requests library. Here, we fetch  example.com, grep it for all lines containing &#34;href&#34; and print them out while stripping spaces.</p><p>多亏了图书馆，上网很容易。这里，我们来举个例子。com，对所有包含&#34；href&#34；并在剥离空间的同时打印出来。</p><p> $  echo   &#34;http://example.com &#34;  | pz   &#39;requests.get(s).content &#39;  | grep href  | pz s.strip  &lt;p&gt;&lt;a href=  &#34;https://www.iana.org/domains/example &#34; &gt;More information... &lt;/a&gt;&lt;/p &gt;</p><p>$echo和#34；http://example.com &#34;  | pz和#39；请求。得到（s）。内容&#39；|grep href | pz s.strip&lt；p&gt&书信电报；a href=&#34；https://www.iana.org/domains/example &#34; &gt；更多信息&lt/a&gt&lt/p&gt；</p><p> To see how auto-import are resolved, use the verbose mode. (Notice the line  Importing requests.)</p><p>要查看自动导入是如何解决的，请使用详细模式。（请注意导入请求的行。）</p><p> $  echo   &#34;http://example.com &#34;  | pz   &#39;requests.get(s).content &#39; -v  | grep href  | pz s.strip Changing the  command clause to: s = requests.get(s).contentImporting requests &lt;p&gt;&lt;a href=  &#34;https://www.iana.org/domains/example &#34; &gt;More information... &lt;/a&gt;&lt;/p &gt;</p><p>$echo和#34；http://example.com &#34;  | pz和#39；请求。得到（s）。内容&#39-v|grep href |pz s.strip将命令子句更改为：s=requests。得到（s）。内容导入请求&lt；p&gt&书信电报；a href=&#34；https://www.iana.org/domains/example &#34; &gt；更多信息&lt/a&gt&lt/p&gt；</p><p>  To match every line that has a quoted expressions and print out the quoted contents, you may serve yourself of Python triple quotes. In the example below, an apostrophe is used to delimit the  COMMAND flag. If we used an apostrophe in the text, we would have to slash it. Instead, triple quotes might improve readability.</p><p>为了匹配每一行带有引号的表达式并打印出引用的内容，您可以使用Python三重引号。在下面的示例中，使用撇号分隔命令标志。如果我们在课文中使用撇号，我们将不得不删掉它。相反，三重引号可能会提高可读性。</p><p>  In that case, even better is to use the  --match flag to get rid of the quoting as much as possible.</p><p>在这种情况下，更好的方法是使用--match标志来尽可能地消除引用。</p><p>     What happens in the background?  factorial is available from  math.factorial. Since it is a callable, we try to put current line as the parameter:  factorial(s). Since  s = &#34;5&#34; which means a string, it fails. It then tries to use  factorial(n) where  n is current line automatically fetched to a number. That works.</p><p>背景中发生了什么？阶乘可以从数学中找到。阶乘的。因为它是可调用的，所以我们尝试将当前行作为参数：factorial（s）。因为s=&#34；5&#34; 这意味着一个字符串，它失败了。然后它尝试使用阶乘（n），其中n是自动提取到数字的当前行。行得通。</p><p>   Without any built-in library? Let&#39;s just use a for-cycle. Process all numbers from 1 to  n (which is 5) and multiply to product. Finally, assign  n to  s which is output.</p><p>没有内置的图书馆？让&#39；那就用自行车吧。处理从1到n（即5）的所有数字，然后乘以乘积。最后，将n分配给输出的s。</p><p> echo 5  | pz   &#39;for c in range(1,n): n*= c ; s = n &#39;   # 120</p><p>回声5 | pz#39；对于范围（1，n）内的c:n*=c；s=n&#39；#120</p><p>    As  csv is one of the auto-imported libraries, we may directly access instantiate the reader object. In the following example, we output the second element of every line either progressively or at once when processing finished.</p><p>由于csv是自动导入的库之一，我们可以直接访问并实例化reader对象。在下面的示例中，我们逐步或在处理完成后立即输出每行的第二个元素。</p><p> # output line by line echo   &#39;&#34;a&#34;,&#34;b1,b2,b3&#34;,&#34;c&#34; &#39;  | pz   &#34;(x[1] for x in csv.reader([s])) &#34;   # &#34;b1,b2,b3&#34;  # output at the end echo   &#39;&#34;a&#34;,&#34;b1,b2,b3&#34;,&#34;c&#34; &#39;  | pz --end   &#34;(x[1] for x in csv.reader(lines)) &#34;   # &#34;b1,b2,b3&#34;</p><p>#输出逐行回波#39&#34;a&#34&#34;b1、b2、b3和#34&#34;c&#34&#39;  | pz和#34；（x[1]代表csv.reader（[s]）中的x和#34；#&#34;b1、b2、b3和#34；#输出端回声&#39&#34;a&#34&#34;b1、b2、b3和#34&#34;c&#34&#39;  | pz——结束&#34；（x[1]代表csv.reader中的x（行））&#34；#&#34;b1、b2、b3和#34；</p><p>        Let&#39;s generate few random strings of variable length 1 to 30. When generator flag is used without a number, it cycles five times.</p><p>让&#39；s生成几个长度为1到30的随机字符串。如果使用的生成器标志没有数字，它会循环五次。</p><p>    # print out current line `count` and current average `sum/count`$  while  : ;  do  echo   $(( 1  +  $RANDOM  %  100 ))  ; sleep 0.1 ;  done  | pz   &#39;sum+=n;s=count, sum/count &#39; --setup   &#34;sum=0 &#34;1, 38.02, 67.03, 62.04, 49.75  # print out every 10 000 lines  # (thanks to `not i % 10000` expression) $  while  : ;  do  echo   $(( 1  +  $RANDOM  %  100 ))  ;  done  | pz   &#39;sum+=n;s=sum/count; s = (count,s) if not count % 10000 else &#34;&#34; &#39; --setup   &#34;sum=0 &#34;10000, 50.905820000, 50.734430000, 50.69346666666666640000, 50.5904</p><p>#打印当前行“count”和当前平均值“sum/count”$while:；do echo$（（1+$RANDOM%100））；睡眠0.1；完成| pz和#39；总和+=n；s=计数、总和/计数和#39--设置&#34；总和=0&#34；1,38.02,67.03,62.04,49.75#每10000行打印一次#（感谢'not i%10000'表达式）$while:；do echo$（（1+$RANDOM%100））；完成| pz和#39；总和+=n；s=总和/计数；s=（计数，s）如果不计数%10000，则为其他&#34&#34; &#39; --设置&#34；总和=0&#34；10000, 50.905820000, 50.734430000, 50.69346666666666640000, 50.5904</p><p> How can this be simplified? Let&#39;s use an infinite generator  -g0. As we know,  n is given current line number by the generator and  i is by default implicitly declared to  i=0 so we use it to hold the sum. No setup clause needed. No Bash cycle needed.</p><p>如何简化？让&#39；s使用一个无限的生成器-g0。正如我们所知，n由生成器给定当前行号，而i默认隐式声明为i=0，因此我们使用它来保存和。不需要设置条款。不需要Bash循环。</p><p> $ pz   &#34;i+=randint(1,100); s = (n,i/n) if not n % 10000 else &#39;&#39; &#34; -g010000, 49.948820000, 50.539930000, 50.3990666666666740000, 50.494425</p><p>$pz&#34；i+=randint（1100）；s=（n，i/n）如果不是n%10000其他&#39&#39; &#34; -g010000、49.948820000、50.539930000、50.399066666740000、50.494425</p><p>  Should you need to evaluate a short multiline statement, use standard multiline statements, supported by Bash.</p><p>如果需要计算短多行语句，请使用Bash支持的标准多行语句。</p><p> $  echo -e   &#34;1\n2\n3 &#34;  | pz   &#34;if n &gt; 2:  s = &#39;bigger&#39; else:  s = &#39;smaller&#39;  &#34;smallerbiggerbigger</p><p>$echo-e&#34；1\n2\n3&#34；|pz和#34；如果n&gt；2:s=&#39；更大&#39；其他：s=&#39；较小的&#39&#34;小的大的</p><p>  Simulate a lengthy processing by generating a long sequence of numbers (as they are not needed, we throw them away by  1&gt;/dev/null).On every 100th line, we move cursor up ( \033[1A), clear line ( \033[K) and print to  STDERR current status.</p><p>通过生成一个长的数字序列来模拟一个漫长的处理过程（因为不需要它们，我们将它们按1&gt；/dev/null丢弃）。在每100行上，我们向上移动光标（\033[1A），清除行（\033[K），并打印到STDERR当前状态。</p><p> $ seq 1 100000  | pz   &#39;s = f&#34;\033[1A\033[K ... {count} ...&#34; if count % 100 == 0 else None  &#39; --stderr  1&gt;/dev/null ... 100 ...   # replaced by ... 200 ...</p><p>$SEQ100000 | pz和#39；s=f&#34\033[1A\033[K…{count}…&#34；如果count%100==0，则无&#39；--stderr 1&gt；/dev/null…100…#替换为…200。。。</p><p>          Sometimes the input cannot be converted to str easily. A warning is output, however, you can still operate with raw bytes.</p><p>有时输入无法轻松转换为str。虽然会输出一条警告，但您仍然可以使用原始字节进行操作。</p><p> echo -e   &#39;\x80 invalid line &#39;  | pz sCannot parse line correctly: b  &#39;\x80 invalid line &#39;� invalid line  # use the `--quiet` flag to suppress the warning, then decode the bytes echo -e   &#39;\x80 invalid line &#39;  | pz   &#39;b.decode(&#34;cp1250&#34;) &#39; --quiet€ invalid line</p><p>echo-e&#39；\x80无效行&#39；|pz不能正确解析行：b&#39；\x80无效行&#39；� 无效行#使用`--quiet`标志抑制警告，然后解码字节echo-e&#39；\x80无效行&#39；|pz和#39；b、 解码（&#34；cp1250&#34；）&#39; --无效线路</p><p>  # display every 1_000nth line$ pz -g0 n *3  | pz   &#34;n if not count % 1000 else None &#34;300060009000  # the same, using the `--filter` flag$ pz -g0 n *3  | pz -F   &#34;not count % 1000 &#34;</p><p>#每1000行显示一次$pz-g0 n*3 | pz和#34；n如果不算%1000，则不算&#34；3000060009000#相同，使用`--filter`标志$pz-g0n*3 |pz-F&#34；不算%1000&#34；</p><p>  Not available with the  --overflow-safe flag set nor in the  main clause unless the  --whole flag set.Ex: get character count (an alternative to  | wc -c).</p><p>不适用于--overflow safe标志集，也不适用于main子句，除非设置了--whole标志集。例如：获取字符计数（替代| wc-c）。</p><p>   $  echo -e   &#34;1\n2\n3 &#34;  | pz   &#39;len(text) &#39;Did not you forget to use --text ?Exception:  &lt;class   &#39;NameError &#39; &gt; name   &#39;text &#39; is not defined on line: 1</p><p>$echo-e&#34；1\n2\n3&#34；|pz和#39；len（文本）和#39；你不是忘了用文本吗？例外情况：&lt；39岁；名称错误&#39&gt；姓名&#39；文本&#39；未在第行定义：1</p><p>         Not available with the  --overflow-safe flag set. Ex: show current average of the stream. More specifically, we output tuples:  line count, current line, average.</p><p>设置了--overflow safe标志时不可用。示例：显示流的当前平均值。更具体地说，我们输出元组：行计数、当前行、平均值。</p><p> $  echo -e   &#34;20\n40\n25\n28 &#34;  | pz   &#39;s = count, s, sum(numbers)/count &#39;1, 20, 20.02, 40, 30.03, 25, 28.3333333333333324, 28, 28.25</p><p>$echo-e&#34；20\n40\n25\n28和#34；|pz和#39；s=计数，s，和（数）/计数和#39；1, 20, 20.02, 40, 30.03, 25, 28.3333333333333324, 28, 28.25</p><p>  If set to  True, current line will not be output. If set to  False when using the  -0 flag, the line will be output regardless.</p><p>如果设置为True，则不会输出当前行。如果在使用-0标志时设置为False，则该行将被输出。</p><p>  Some variables are initialized and ready to be used globally. They are common for all the lines.</p><p>一些变量已初始化，可以全局使用。它们在所有的线路中都很常见。</p><p>  It is true that using uppercase is not conforming the naming convention. However, in these tiny scripts the readability is the chief principle, every character counts.</p><p>的确，使用大写不符合命名约定。然而，在这些微小的脚本中，可读性是首要原则，每个字符都很重要。</p><p> Using a set  S. In the example, we add every line to the set and end print it out in a sorted manner.</p><p>使用集合S。在本例中，我们将每一行添加到集合中，并以排序方式将其打印出来。</p><p>  Using a list  L. Append lines that contains a number bigger than one and finally, print their count. As only the final count matters, suppress the line output with the flag  -0.</p><p>使用列表L。追加包含大于1的数字的行，最后打印它们的计数。因为只有最终计数才重要，所以使用-0标记抑制行输出。</p><p>   Some others are auto-imported whenever its use has been detected. In such case, the line is reprocessed.</p><p>其他一些则在检测到其使用时自动导入。在这种情况下，管线将重新处理。</p><p> Caveat: When accessed first time, the auto-import makes the row reprocessed. It may influence your global variables. Use verbose output to see if something has been auto-imported.</p><p>警告：首次访问时，自动导入会使行重新处理。它可能会影响你的全局变量。使用详细输出查看是否自动导入了某些内容。</p><p> $  echo -e   &#34;hey\nbuddy &#34;  | pz   &#39;a+=1; sleep(1); b+=1; s = a,b  &#39; --setup   &#34;a=0;b=0; &#34; -vImporting sleep from  time2, 13, 2</p><p>$echo-e&#34；嘿\nbuddy&#34；|pz和#39；a+=1；睡眠（1）；b+=1；s=a、b和#39--设置&#34；a=0；b=0&#34; -从时间2、13、2导入睡眠</p><p> As seen,  a was incremented 3× times and  b on twice because we had to process the first line twice in order to auto-import sleep. In the first run, the processing raised an exception because  sleep was not known. To prevent that, explicitly appending  from time import sleep to the  --setup flag would do.</p><p>如图所示，a增加了3倍，b增加了两倍，因为为了自动导入睡眠，我们必须处理第一行两次。在第一次运行中，处理引发了一个异常，因为不知道睡眠。为了防止出现这种情况，可以将time import sleep显式地附加到--setup标志。</p><p>  Consider piping two lines &#39;hey&#39; and &#39;buddy&#39;. We return three elements, original text, reversed text and its length.</p><p>考虑管道两条和39条；嘿&#39；和&#39；巴迪&#39；。我们返回三个元素，原始文本、反向文本及其长度。</p><p> List: When  s ends up as a list, its elements are printed to independent lines.</p><p>列表：当s最终成为一个列表时，它的元素被打印成独立的行。</p><p> Regular match: All groups are treated as a tuple. If no group used, we print the entire matched string.</p><p>常规匹配：所有组都被视为一个元组。如果没有使用组，则打印整个匹配字符串。</p><p> # no group → print entire matched string echo   &#34;hello world &#34;  | pz   &#39;search(r&#34;\s.*&#34;, s) &#39;   # &#34; world&#34;  # single matched group echo   &#34;hello world &#34;  | pz   &#39;search(r&#34;\s(.*)&#34;, s) &#39;   # &#34;world&#34;  # matched groups treated as tuple echo   &#34;hello world &#34;  | pz   &#39;search(r&#34;(.*)\s(.*)&#34;, s) &#39;   # &#34;hello, world&#34;</p><p>#没有团体→ 打印完整匹配的字符串echo&#34；你好，世界&#34；|pz和#39；搜索（r&#34；\s.&#34；，s）&#39；#&#34; 世界&#34；#单组匹配回声#34；你好，世界&#34；|pz和#39；搜索（r&#34；\s（.*）&#34；，s） &39；#&#34;世界&#34；#匹配组被视为元组回声#34；你好，世界&#34；|pz和#39；搜索（r&#34；（.*）s（.*）和#34；，s） &39；#&#34;你好，世界&#34；</p><p> Callable: It gets called. Very useful when handling simple function – without the need of explicitly putting parenthesis to call the function, we can omit quoting in Bash (expression  s.lower() would have had to be quoted.) Use the verbose flag  -v to inspect the internal change of the command.</p><p>Callable:它会被调用。在处理简单函数时非常有用——不需要显式地放入括号来调用函数，我们可以在Bash中省略引号（必须引用表达式s.lower（））使用verbose标志-v检查命令的内部更改。</p><p> # internally changed to `s = s.lower()` echo   &#34;HEllO &#34;  | pz s.lower   # &#34;hello&#34;   # internally changed to `s = len(s)` echo   &#34;HEllO &#34;  | pz len   # &#34;5&#34;  # internally changed to `s = base64.b64encode(s.encode(&#39;utf-8&#39;))` echo   &#34;HEllO &#34;  | pz b64encode   # &#34;SEVsbE8=&#34;  # internally changed to `s = math.sqrt(n)`  # and then to `s = round(n)` echo   &#34;25 &#34;  | pz sqrt  | pz round   # &#34;5&#34;  # internally changed to `s = sum(numbers)`  echo -e   &#34;1\n2\n3\n4 &#34;  | pz sum13610  # internally changed to `&#39; - &#39;.join(lines)`  echo -e   &#34;1\n2\n3\n4 &#34;  | pz --end   &#34;&#39; - &#39;.join &#34;1 - 2 - 3 - 4</p><p>#内部更改为's=s.lower（）'echo&#34；你好&#34；|pz s.下#和#34；你好&#34；#内部更改为's=len（s）'echo&#34；你好&#34；|pz len#&#34；5&#34;  # 内部更改为's=base64。B64编码（s.encode（&#39；utf-8&#39；）`echo和#34；你好&#34；|pz B64编码#和#34；SEVsbE8=&#34；#内部更改为's=math。sqrt（n）`s=round（n）`echo&#34；25 &#34;  | pz sqrt | pz round#和#34；5&#34;  # 内部改为's=sum（number）`echo-e&#34；1\n2\n3\n4&#34；|pz sum13610#内部改为&#39；-&#39;.加入（行）`echo-e&#34；1\n2\n3\n4&#34；|pz——结束&#34&#39; - &#39;.加入&#34；1 - 2 - 3 - 4</p><p> As you see in the examples, if  TypeError raised, we try to reprocess the row while adding current line as the argument:</p><p>正如您在示例中看到的，如果出现TypeError，我们将尝试重新处理该行，同时添加当前行作为参数：</p><p>  -v,  --verbose: See what happens under the hood. Show automatic imports and internal command modification (attempts to make it callable and prepending  s = if omitted). $  echo -e   &#34;hello &#34;  | pz   &#39;invalid command &#39;Exception:  &lt;class   &#39;SyntaxError &#39; &gt; invalid syntax ( &lt;string &gt;, line 1) on line: hello$  echo -e   &#34;hello &#34;  | pz   &#39;sleep(1) &#39; --verboseImporting sleep from  time</p><p>-v、 --详细：看看引擎盖下面发生了什么。显示自动导入和内部命令修改（尝试使其可调用，如果省略，则在s=前加前缀）。$echo-e&#34；你好&#34；|pz和#39；无效命令&#39；例外情况：&lt；39岁；SyntaxError和#39&gt；第1行的语法无效（&lt；string&gt；，第1行）：hello$echo-e&#34；你好&#34；|pz和#39；睡眠（1）和#39--逐字逐句</p><p>  -S COMMAND,  --setup COMMAND: Any Python script, executed before processing. Useful for variable initializing.Ex: prepend line numbers by incrementing a variable  count. $  echo -e   &#34;row\nanother row &#34;  | pz   &#39;count+=1;s = f&#34;{count}: {s}&#34; &#39; --setup   &#39;count=0 &#39;1: row2: another row  # the same using globally available variable `count` instead of using `--setup` and the `--format` flag$  echo -e   &#34;row\nanother row &#34;  | pz -f   &#39;{count}: {s} &#39;</p><p>-S命令，-setup命令：任何Python脚本，在处理之前执行。用于变量初始化。例如：通过增加一个变量计数来预先结束行号。$echo-e&#34；第34排pz和#39；计数+=1；s=f&#34；{count}：{s}&#34&#39; --设置&#39；计数=0&#39；1：第2行：另一行#使用全局可用变量'count'而不是使用'--setup'和'--format'标志$echo-e&#34；第34排pz-f&#39；{count}：{s}&#39；</p><p> -E COMMAND,  --end COMMAND: Any Python script, executed after processing. Useful for the final output.The variable  text is available by default here. $  echo -e   &#34;1\n2\n3\n4 &#34;  | pz --end sum10$  echo -e   &#34;1\n2\n3\n4 &#34;  | pz s --end sum123410 $  echo -e   &#34;1\n2\n3\n4 &#34;  | pz sum --end sum1361010</p><p>-E命令，--end命令：任何Python脚本，在处理后执行。对最终输出有用。默认情况下，变量文本在此处可用。$echo-e&#34；1\n2\n3\n4&#34；|pz——最终价格10美元echo-e&#34；1\n2\n3\n4&#34；|pz s——最终金额123410美元echo-e&#34；1\n2\n3\n4&#34；|pz总和——结束总和1361010</p><p> -F,  --filter: Line is piped out unchanged, however only if evaluated to  True.When piping in numbers to 5, we pass only such bigger than 3. The statement is equivalent to using  skip (and not using  --filter). When not using filter,  s evaluates to  True /  False. By default,  False or empty values are not output.</p><p>-F、 --过滤器：管线输出不变，但仅当计算为True时。当管道数为5时，我们只通过大于3的管道。该语句相当于使用skip（而不是使用--filter）。不使用过滤器时，s的计算结果为True/False。默认情况下，不会输出假值或空值。</p><p> -f,  --format: Main and end clauses are considered f-strings. The clause is inserted in between three-apostrophes  f&#39;&#39;&#39;COMMAND&#39;&#39;&#39; internally.</p><p>-f、 --格式：主句和尾句被视为f字串。该条款插入三个撇号f和#39之间&#39;&#39;指挥部&#39&#39;&#39; 内部。</p><p>  --empty Output even empty lines. (By default skipped.) Consider shortening the text by 3 last letters. First line  hey disappears completely then.</p><p>--空输出，甚至空行。（默认情况下跳过。）考虑用3个最后的字母缩短文本。第一行，嘿，然后就完全消失了。</p><p> -g [NUM],  --generate [NUM] Generate lines while ignoring the input pipe. Line will correspond to the iteration cycle count (unless having the  --overflow-safe flag on while having an infinite generator – in that case, lines will equal to &#39;1&#39;). If  NUM not specified, 5 lines will be produced by default. Putting  NUM == 0 means an infinite generator. If no  main clause set, the number is piped out.</p><p>-g[NUM]，--generate[NUM]在忽略输入管道的情况下生成行。行将对应于迭代周期计数（除非在具有无限生成器的情况下启用了--overflow safe标志——在这种情况下，行将等于&#39；1&#39；）。如果未指定NUM，默认情况下将生成5行。将NUM==0表示一个无限的生成器。如果没有设置main子句，则通过管道输出该数字。</p><p> $ pz -g212$ pz   &#39;i=i+5 &#39; -g -vChanging the main clause to: s = i=i+5Generating s = 1 .. 5510152025</p><p>$pz-g212$pz和#39；i=i+5&#39-g-v将主句改为：s=i=i+5生成s=1。。5510152025</p><p> --stderr Print clauses&#39; output to the  STDERR, while letting the original line piped to  STDOUT intact. Useful for generating reports during a long operation. Take a look at the following example, every third line will make  STDERR to receive a message.</p><p>--标准印刷条款&#39；输出到STDERR，同时让原始行完整地通过管道传输到STDOUT。用于在长时间操作期间生成报告。看看下面的例子，每隔三行STDERR就会收到一条消息。</p><p> $ pz -g=9 s  | pz   &#34;s = &#39;Processed next few lines&#39; if count % 3 == 0 else None &#34; --stderr 123Processed next few lines456Processed next few lines789Processed next few lines</p><p>$pz-g=9s | pz#34；s=&#39；处理接下来的几行&#39；如果计数%3==0，则无&#34--stderr 123处理后几行456处理后几行789处理后几行</p><p> Demonstrate different pipes by writing  STDOUT to a file and leaving  STDERR in the terminal.</p><p>通过将STDOUT写入文件并将STDERR留在终端中来演示不同的管道。</p><p> $ pz -g=9 s  | pz   &#34;s = &#39;Processed next few lines&#39; if count % 3 == 0 else None &#34; --stderr  &gt; /tmp/exampleProcessed next few linesProcessed next few linesProcessed next few linescat /tmp/example123...</p><p>$pz-g=9s | pz#34；s=&#39；处理接下来的几行&#39；如果计数%3==0，则无&#34--stderr&gt/tmp/Example处理后几行处理后几行处理后几行处理后几行SCAT/tmp/Example 123。。。</p><p> --overflow-safe Prevent  lines,  numbers,  text variables to be available. Useful when handling an infinite input.</p><p>--溢出安全防止行、数字、文本变量可用。在处理无限输入时非常有用。</p><p> # prevent `text` to be populated by defaultecho -e &#34;1\n2\n2\n3&#34; | pz --end &#34;len(text)&#34; --overflow-safeDid you not forget to use --while to access `text`?Exception: &lt;class &#39;NameError&#39;&gt; name &#39;text&#39; is not defined in the --end clause# force to populate `text` echo -e &#34;1\n2\n2\n3&#34; | pz --end &#34;len(text)&#34; --overflow-safe --whole7</p><p>#防止用defaultecho-e&#34填充“text”；1\n2\n2\n3&#34；|pz——结束&#34；len（文本）和#34--在访问“文本”时，您没有忘记使用--while吗？例外情况：&lt；39岁；名称错误&#39&gt；姓名&#39；文本&#39；在--end子句#force to populate`text`echo-e&#34中没有定义；1\n2\n2\n3&#34；|pz——结束&#34；len（文本）和#34--溢流保险箱——全套</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/handle/">#handle</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>