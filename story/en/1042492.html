<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby 3.0的变化 Ruby 3.0 Changes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby 3.0 Changes<br/>Ruby 3.0的变化 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-30 07:03:44</div><div class="page_narrow text-break page_content"><p>Ruby 3.0 is a major language release. The core team worked hard to preserve backward compatibility while delivering some huge and exciting new features.</p><p>Ruby 3.0是主要的语言版本。核心团队努力保持向后兼容性，同时提供了一些巨大而令人兴奋的新功能。</p><p> Ractors: Thread-alike object implementing the actor model, and finally lifting the GVL (Global Virtual machine Lock) and enabling true concurrency</p><p> Ractors：类似线程的对象，用于实现actor模型，并最终解除GVL（全局虚拟机锁）并实现真正的并发</p><p>   The separation which  started in 2.7 with deprecations, is now fully finished. It means keyword arguments are not a “syntax sugar” on top of hashes, and they never converted into each other implicitly:</p><p>   分离从2.7开始（已弃用），现已完全完成。这意味着关键字参数不是在哈希值之上的“语法糖”，并且它们永远不会隐式地相互转换：</p><p> Code:  def  old_style ( name ,  options  =  {}) end def  new_style ( name ,  ** options ) end new_style ( &#39;John&#39; ,  { age:  10 }) # Ruby 2.6: works # Ruby 2.7: warns: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call # Ruby 3.0: ArgumentError (wrong number of arguments (given 2, expected 1)) new_style ( &#39;John&#39; ,  age:  10 ) # =&gt; works h  =  { age:  10 } new_style ( &#39;John&#39; ,  ** h ) # =&gt; works, ** is mandatory # The last hash argument still allowed to be passed without {}: old_style ( &#39;John&#39; ,  age:  10 ) # =&gt; works</p><p> 代码：def old_style（name，options = {}）end def new_style（name，** options）end new_style（＆＃39; John＆＃39;，{age：10}）＃Ruby 2.6：有效＃Ruby 2.7：警告：不建议使用最后一个参数作为关键字参数；也许应该在通话中添加**＃Ruby 3.0：ArgumentError（错误的参数数量（给定2个，预期为1个））new_style（＆＃39; John＆＃39;，年龄：10）＃=＆gt;作品h = {age：10} new_style（＆＃39; John＆＃39;，** h）＃=＆gt;有效，**是必填项＃仍允许不使用{}传递最后一个哈希参数：old_style（＆＃39; John＆＃39;，年龄：10）＃=＆gt;作品</p><p>  Notes: There is a  big and detailed explanation of the separation reasons, logic, and edge cases on Ruby site, written at the dawn of 2.7, so we will not go into more details here.</p><p>  注意：在Ruby站点上，有一个大而详尽的解释，解释了分离的原因，逻辑和边缘情况，该解释是在2.7年初问世的，因此在这里我们将不再赘述。</p><p>   Code:  block  =  proc  {  |* args ,  ** kwargs |  puts  &#34;args= #{ args } , kwargs= #{ kwargs } &#34; } block . call ( 1 ,  2 ,  a:  true ) # Ruby 2.7: args=[1, 2], kwargs={:a=&gt;true} -- as expected # Ruby 2.7: args=[1, 2], kwargs={:a=&gt;true} -- same block . call ( 1 ,  2 ,  { a:  true }) # Ruby 2.7: # warning: Using the last argument as keyword parameters is deprecated # args=[1, 2], kwargs={:a=&gt;true} -- but extracted to keyword args nevertheless # Ruby 3.0: # args=[1, 2, {:a=&gt;true}], kwargs={} -- no attempt to extract hash into keywords, and no error/warning</p><p>   代码：block = proc {| * args，** kwargs |放置＆＃34; args =＃{args}，kwargs =＃{kwargs}＆＃34; }块。 call（1，2，a：true）＃Ruby 2.7：args = [1，2]，kwargs = {：a =＆gt; true}-如预期的那样＃Ruby 2.7：args = [1，2]，kwargs = {：a =＆gt; true}-相同的块。 call（1，2，{a：true））＃Ruby 2.7：＃警告：不建议将最后一个参数用作关键字参数＃args = [1，2]，kwargs = {：a =＆gt; true}-但尽管如此，还是提取为关键字args＃Ruby 3.0：＃args = [1、2，{：a =＆gt; true}]，kwargs = {} –不会尝试将哈希提取到关键字中，也不会出现错误/警告</p><p>  Reason: Argument forwarding, when  introduced in 2.7, was able to forward only all-or-nothing. It turned out to be not enough. One of the important usages for leading arguments are cases like  method_missing and other DSL-defined methods that need to pass to the nested method  :some_symbol + all of the original arguments.</p><p>  原因：参数转发在2.7中引入时，只能转发全有或全无。事实证明这还不够。前导参数的重要用法之一是诸如method_missing和其他DSL定义的方法之类的情况，这些情况需要传递给嵌套方法：some_symbol +所有原始参数。 </p><p>      Code:  def  request ( method ,  url ,  headers:  {})  puts  &#34; #{ method . upcase }   #{ url }  (headers= #{ headers } )&#34; end def  get ( ... )  request ( :get ,  ... ) end get ( &#39;https://example.com&#39; ,  headers:  { content_type:  &#39;json&#39; }) # GET https://example.com (headers={:content_type=&gt;&#34;json&#34;}) # Leading arguments may be present both in the call and in the definition: def  logged_get ( message ,  ... )  puts  message  get ( ... ) end logged_get ( &#39;Logging&#39; ,  &#39;https://example.com&#39; ,  headers:  { content_type:  &#39;json&#39; })</p><p>代码：def请求（method，url，标头：{}）放入＆＃34; ＃{ 方法 。大写}＃{url}（headers =＃{headers}）＆＃34; end def get（...）请求（：get，...）end get（＆＃39; https：//example.com&#39;，标头：{content_type：＆＃39; json＆＃39;}） ＃GET https://example.com（headers = {：content_type =＆gt;＆＃34; json＆＃34;}）＃调用和定义中都可能存在前置参数：def logging_get（message，.. ）放置消息get（...）结束日志记录（＆＃39; Logging＆＃39;，＆＃39; https：//example.com&#39;，标头：{content_type：＆＃39; json＆＃39; }）</p><p>  Notes:  “all arguments splat”  ... should be the last statement in the argument list (both on a declaration and a call)</p><p>  注意：“所有参数splat” ...应该是参数列表中的最后一条语句（在声明和调用上）</p><p>  on a method declaration, arguments before  ... can only be positional (not keyword) arguments, and can’t have default values (it would be  SyntaxError);</p><p>  在方法声明中，...之前的参数只能是位置（而不是关键字）参数，并且不能具有默认值（应为SyntaxError）；</p><p>  on a method call, arguments passed before  ... can’t be keyword arguments (it would be  SyntaxError);</p><p>  在方法调用中，...之前传递的参数不能为关键字参数（应为SyntaxError）；</p><p>  make sure to check your punctuation thoroughly, because  anything ... is a syntax for endless range, those constructs are valid syntax, but would do not what is expected:  def  delegates ( ... )  # call without &#34;()&#34; -- actually parsed as (p()...)  p  ...  # Prints nothing, but warns: warning: ... at EOL, should be parenthesized?  # &#34;,&#34; accidentally missing after 1, there is just one argument: 1...  p ( 1  ... )  # Prints &#34;1...&#34;  p ( 1 ,  ... )  # Prints, as expected:  # 1  # 5 end delegates ( 5 )</p><p>  确保彻底检查标点符号，因为任何...都是无限范围的语法，这些构造是有效的语法，但不会达到预期的效果：def委托（...）＃调用时不带＆＃34;（） ＆＃34; -实际上解析为（p（）...）p ...＃不输出任何内容，但发出警告：警告：...在EOL时，应加括号吗？ ＃＆＃34;，＆＃34; 1之后意外丢失，只有一个参数：1 ... p（1 ...）＃打印＆＃34; 1 ...＆＃34; p（1，...）＃按预期方式打印：＃1＃5个最终代表（5）</p><p>  Methods of exactly one statement now can be defined with syntax  def method() = statement. (The syntax doesn’t need  end, hence the “endless definition” moniker.)</p><p>  现在可以使用语法def method（）= statement定义仅一个语句的方法。 （语法不需要结尾，因此是“无尽定义”的绰号。）</p><p> Reason: Ruby’s  ends (unlike C-like languages’  {}) are generally OK for Rubyists, but make small utility methods look more heavy than they should. For small utility methods with body containing just one short statement like:    …the “proper” definition might look so heavy that one will decide against it to leave the class more readable (and instead make class’ clients to just do  obj.internal.empty? themselves, making it less semantical). For such cases, a shortcut one-line definition may change the perceiving of utility method creation:</p><p> 原因：Ruby的终结点（与C语言类似，{}不同）对于Rubyist来说通常是可以的，但是使小型实用程序方法看起来比他们应有的繁重。对于主体仅包含一个简短语句的小型实用程序方法，例如：…“正确”的定义可能看起来如此繁重，以至于人们会决定反对该定义，以使类更具可读性（相反，使类的客户端仅执行obj.internal.empty ？本身，从而减少语义）。在这种情况下，单行快捷方式定义可能会更改对实用程序方法创建的理解： </p><p>      Code:  def  dbg  =  puts ( &#34;DBG:  #{ caller . first } &#34; ) dbg # Prints: DBG: test.rb:3:in `&lt;main&gt;&#39; # The method definition supports all kinds of arguments: def  dbg_args ( a ,  b = 1 ,  c :,  d:  6 ,  &amp; block )  =  puts ( &#34;Args passed:  #{ [ a ,  b ,  c ,  d ,  block . call ] } &#34; ) dbg_args ( 0 ,  c:  5 )  {  7  } # Prints: Args passed: [0, 1, 5, 6, 7] # For argument definition, () is mandatory def  square  x  =  x ** 2 # syntax error, unexpected end-of-input -- because Ruby treats it as # def square(x = x**2) # ...e.g. an argument with default value, referencing itself, and no method body # This works def  square ( x )  =  x ** 2 square ( 100 )  # =&gt; 10000 # To avoid confusion, defining method names like #foo= is prohibited class  A  # SyntaxError &#34;setter method cannot be defined in an endless method definition&#34;:  def  attr = ( val )  =  @attr  =  val  # Other suffixes are OK:  def  attr? ()  =  !! @attr  def  attr! ()  =  @attr  =  true end # funnily enough, operator methods are OK, including #== class  A  def  == ( other )  =  true end p  A . new  ==  5  # =&gt; true # any singular expression can be method body # This works: def  read ( name )  =  File . read ( name )  . split ( &#34; \n &#34; )  . map ( &amp; :strip )  . reject ( &amp; :empty? )  . uniq  . sort # Or even this, though, what&#39;s the point?.. def  weird ( name )  =  begin  data  =  File . read ( name )  process ( data )  true  rescue  false  end # inside method body, method calls without parentheses cause a syntax error: def  foo ()  =  puts  &#34;bar&#34; # ^ syntax error, unexpected string literal, expecting `do&#39; or &#39;{&#39; or &#39;(&#39; # This is due to parsing ambiguity and is aligned with some other places, like x  =  1  +  sin  y # ^ syntax error, unexpected tIDENTIFIER, expecting keyword_do or &#39;{&#39; or &#39;(&#39;</p><p>代码：def dbg = puts（＆＃34; DBG：＃{呼叫者。首先}＆＃34;）dbg＃打印：DBG：test.rb：3：＆lt; main＆gt;＆＃39; ＃方法定义支持各种参数：def dbg_args（a，b = 1，c：，d：6，＆amp; block）= puts（＆＃34;传递的Args：＃{[a，b，c，d ，block。call]}＆＃34;）dbg_args（0，c：5）{7}＃打印：传递了Args：[0，1，5，6，7]＃对于参数定义，（）是强制性的def方x = x ** 2＃语法错误，意外的输入终止-因为Ruby将其视为＃def square（x = x ** 2）＃... eg一个具有默认值的参数，它本身是引用的，并且没有方法主体＃这可以使def square（x）= x ** 2 square（100）＃=> 10000＃为避免混淆，禁止定义方法名称，例如＃foo =，类A＃SyntaxError＆＃34; setter方法不能在无休止的方法定义中定义＆＃34 ;： def attr =（val）= @attr = val＃其他后缀还可以：def attr？ （）= !! @attr def attr！ （）= @attr = true end＃很有趣，运算符方法也可以，包括＃== class A def ==（other）= true end p A。 new == 5＃=＆gt; true＃任何奇异的表达式都可以是方法body＃这可以正常工作：def read（name）= File。读（名字）。分割（＆＃34; \ n＆＃34;）。地图（＆amp;：strip）。拒绝（＆amp;：：empty？）。 uniq。排序＃或什至是什么意思？.. def weird（name）=开始数据= File。 read（名称）进程（数据）true抢救false end＃方法主体内部，不带括号的方法调用会导致语法错误：def foo（）= puts＆＃34; bar＆＃34; ＃^语法错误，意外的字符串文字，期望`do＆＃39;或＆＃39; {＆＃39;或＆＃39;（＆＃39;＃这是由于解析歧义而导致的，并且与其他一些地方对齐，例如x = 1 + sin y＃^语法错误，意外的tIDENTIFIER，期望keyword_do或＆＃39; {＆＃ 39;或＆＃39;（＆＃39;</p><p>  Notes:  The initial proposal seems to be a good-natured April Fool’s joke, then everybody suddenly liked it, and, with a slight change of syntax, it was accepted;</p><p>  注意：最初的提议似乎是愚蠢的愚人节玩笑，然后每个人都突然喜欢上了它，并且在语法上稍作更改，它就被接受了；</p><p>  Feature is marked as EXPERIMENTAL, but it does NOT produce a warning, it is deliberate, see discussion in  Misc #17399.</p><p>  该功能被标记为EXPERIMENTAL，但它不会产生警告，它是有意的，请参阅其他＃17399中的讨论。</p><p>    Reason: This is an interesting one. Two facts were discussed between 2.7 and 3.0: the fact that in most of the other languages one-line pattern matching has a different order ( &lt;pattern&gt; &lt;operator&gt; &lt;data&gt;) than introduced in Ruby 2.7 ( &lt;data&gt; in &lt;pattern&gt;); and the idea of “rightward assignment operator”  =&gt; for more natural chaining. And then, at some point, ideas converged most fruitfully.</p><p>    原因：这很有趣。在2.7和3.0之间讨论了两个事实：在大多数其他语言中，单行模式匹配的顺序（＆lt; pattern＆gt;＆lt; operator＆gt;＆lt; data＆gt;）与在Ruby 2.7中引入的顺序（＆lt; data＆gt; ;＆lt; pattern＆gt;）中的内容；和“向右赋值运算符”的思想=>以获得更自然的链接。然后，在某个时候，想法汇聚得最为成功。</p><p>  Discussion:  Feature #17260 (main pattern matching tracking ticket),  Feature #16670 (reverse order),  Feature #15921 (standalone rightward assignment operator),  Feature #15799 (abandoned “pipeline operator” idea, in discussion of which “rightward assignment” was born)</p><p>  讨论：功能＃17260（主模式匹配跟踪票），功能＃16670（反向顺序），功能＃15921（独立的向右赋值运算符），功能＃15799（废弃的“管道运算符”构想），在讨论哪种“向右赋值”出生于）</p><p>    Code:  # match and unpack: { db:  { user:  &#39;John&#39; ,  role:  &#39;admin&#39; }}  =&gt;  { db:  { user :,  role :}} p  [ user ,  role ]  # =&gt; [&#34;John&#34;, &#34;admin&#34;] # pattern-matching as a rightward assignment for long experessions: File . read ( &#39;test.txt&#39; )  . split ( &#34; \n &#34; )  . map ( &amp; :strip )  . reject ( &amp; :empty? )  . first ( 10 )  =&gt;  lines p  lines  # first 10 non-empty lines of the file # unpacking+assignment is extremely powerful: ( 1 .. 10 ). to_a . shuffle  =&gt;  [ * before ,  ( 2 .. 4 )  =&gt;  threshold ,  * after ] # ...in input sequence, find first entry in range 2..4, put it into `threshold`, # and split parts of the sequence before/after it p  [ before ,  threshold ,  after ]  # your results might be different due to shuffle :) # =&gt; [[7, 5, 8], 3, [1, 10, 6, 9, 4, 2]] # The things can get really out of hand quickly: Time . now . hour  =&gt;  .. 9  |  18 ..  =&gt;  non_working_hour</p><p>    代码：＃匹配并解压缩：{db：{用户：＆＃39; John＆＃39; ，角色：＆＃39; admin＆＃39; }} =＆gt; {db：{user：，role：}} p [user，role]＃=＆gt; [＆＃34; John＆＃34 ;,＆＃34; admin＆＃34;]＃模式匹配作为长时间实验的向右分配：File。阅读（＆＃39; test.txt＆＃39;）。分割（＆＃34; \ n＆＃34;）。地图（＆amp;：strip）。拒绝（＆amp;：：empty？）。首先（10）=> lines p lines＃文件的前10个非空行＃拆包+分配功能非常强大：（1 .. 10）。 to_a。洗牌=> [*之前，（2 .. 4）=＆gt;阈值，*在]＃...之后，在输入序列中，找到2..4范围内的第一个条目，将其放入`threshold`，＃并分割序列之前/之后的部分p [之前，threshold，之后]＃由于随机播放，您的结果可能会有所不同:)＃=＆gt; [[7，5，8]，3，[1，10，6，9，4，2]]＃事情真的可以很快失控：Time。现在。小时=> .. 9 | 18 .. =>非工作时间</p><p>  Notes:  Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future;</p><p>  注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改； </p><p>  But simple assignment usage ( data =&gt; variable) is  not considered experimental and is here to stay;</p><p>但是简单的分配用法（数据=＆gt;变量）不被认为是实验性的，并且在这里仍然存在；</p><p>  One quirk that might be non-obvious: pattern matching can desconstruct-assign only to local variables, so when using  =&gt; as an assignment operator, you will see those are syntax errors:  some_statement  =&gt;  @x some_statement  =&gt;  obj . attr  # meaning to call `obj.attr=` some_statement  =&gt;  $y  # ...though maybe don&#39;t use global variables :)</p><p>  一个可能不是很明显的怪癖：模式匹配只能对局部变量进行解构分配，因此使用=＆gt;作为赋值运算符，您将看到这些是语法错误：some_statement =＆gt; @x some_statement =＆gt; obj。 attr＃的意思是调用`obj.attr =`some_statement =＆gt; $ y＃...虽然也许不要使用全局变量:)</p><p>  After the change described above,  in was reintroduced to return  true/ false (whether the pattern matches) instead of raising  NoMatchingPatternError.</p><p>  在上述更改之后，重新引入了in以返回true / false（模式是否匹配），而不是引发NoMatchingPatternError。</p><p> Reason: The new meaning allows pattern matching to be more tightly integrated with other constructs in the control flow, like iteration and regular conditions.</p><p> 原因：新含义允许模式匹配与控制流程中的其他构造（例如迭代和常规条件）更紧密地集成在一起。</p><p>      Code:  user  =  { role:  &#39;admin&#39; ,  login:  &#39;matz&#39; } if  user  in  { role:  &#39;admin&#39; ,  name :}  puts  &#34;Granting admin scope:  #{ name } &#34; end # otherwise just proceed with regular scope, no need to raise users  =  [  { name:  &#39;John&#39; ,  role:  &#39;user&#39; },  { name:  &#39;Jane&#39; ,  registered_at:  Time . new ( 2017 ,  5 ,  8 )  },  { name:  &#39;Barb&#39; ,  role:  &#39;admin&#39; },  { name:  &#39;Dave&#39; ,  role:  &#39;user&#39; } ] old_users_range  =  Time . new ( 2016 ) .. Time . new ( 2019 ) # Choose for some notification only admins and old users users . select  {  | u |  u  in  { role:  &#39;admin&#39; }  |  { registered_at:  ^ old_users_range }  } #=&gt; [{:name=&gt;&#34;Jane&#34;, :registered_at=&gt;2017-05-08 00:00:00 +0300}, {:name=&gt;&#34;Barb&#34;, :role=&gt;&#34;admin&#34;}]</p><p>      代码：用户= {角色：＆＃39; admin＆＃39; ，登录：＆＃39; matz＆＃39; }（如果用户以{角色：＆＃39; admin＆＃39; ，name：}放置＆＃34;授予管理范围：＃{name}＆＃34;结束＃，否则只需进行常规操作，无需提高用户= [{名称：＆＃39; John＆＃39; ，角色：＆＃39;用户＆＃39; }，{名称：＆＃39; Jane＆＃39; ，registered_at：时间。 new（2017，5，8）}，{名称：＆＃39; Barb＆＃39; ，角色：＆＃39; admin＆＃39; }，{名称：＆＃39; Dave＆＃39; ，角色：＆＃39;用户＆＃39; }] old_users_range =时间。新（2016）..时间。新增功能（2019）＃仅针对某些通知选择管理员和旧用户用户。选择{|你担任{角色：＆＃39; admin＆＃39; } | {register_at：^ old_users_range}}＃=＆gt; [{：name =＆gt;＆＃34; Jane＆＃34 ;,：registered_at =＆gt; 2017-05-08 00:00:00 +0300}，{：name =＆gt;＆＃34; Barb＆＃34 ;, ：role =＆gt;＆＃34; admin＆＃34;}]</p><p>  Notes:  Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.</p><p>  注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改。</p><p>   Code:  users  =  [  { name:  &#39;John&#39; ,  role:  &#39;user&#39; },  { name:  &#39;Jane&#39; ,  role:  &#39;manager&#39; },  { name:  &#39;Barb&#39; ,  role:  &#39;admin&#39; },  { name:  &#39;Dave&#39; ,  role:  &#39;manager&#39; } ] # Now, how do you find admin with just pattern matching?.. # Ruby 3.0: case  users in  [ * ,  { name :,  role:  &#39;admin&#39; },  * ]  # Note the pattern: find something in the middle, with unknown number of items before/after  puts  &#34;Admin:  #{ name } &#34; end # =&gt; Admin: Barb # Without any limitations to choose the value, the first splat is non-greedy: case  users in  [ * before ,  user ,  * after ]  puts  &#34;Before match:  #{ before } &#34;  puts  &#34;Match:  #{ user } &#34;  puts  &#34;After match:  #{ after } &#34; end # Before match: [] # Match: {:name=&gt;&#34;John&#34;, :role=&gt;&#34;user&#34;} # After match: [{:name=&gt;&#34;Jane&#34;, :role=&gt;&#34;manager&#34;}, {:name=&gt;&#34;Barb&#34;, :role=&gt;&#34;admin&#34;}, {:name=&gt;&#34;Dave&#34;, :role=&gt;&#34;manager&#34;}] # Guard clause does not considered when choosing where to splat: case  users in  [ * ,  user ,  * ]  if  user [ :role ]  ==  &#39;admin&#39;  puts  &#34;User:  #{ user } &#34; end # =&gt; NoMatchingPatternError -- it first put John into `user`, # and only then checked the guard clause, which is not matching # If the &#34;find pattern&#34; is used (there is more than one splat in the pattern), # there should be exactly TWO of them, and they may ONLY be the very first and # the very last element: case  users in  [ first_user ,  * ,  { name :,  role:  &#39;admin&#39; },  * ]  # ^ syntax error, unexpected *  puts  &#34;Admin:  #{ name } &#34; end # Singular splat is still allowe in any place: case  users in  [{ name:  first_user_name },  * ,  { name:  last_user_name }]  puts  &#34;First user:  #{ first_user_name } , last user:  #{ last_user_name } &#34; end # =&gt; First user: John, last user: Dave</p><p>   代码：用户= [{名称：＆＃39; John＆＃39; ，角色：＆＃39;用户＆＃39; }，{名称：＆＃39; Jane＆＃39; ，角色：＆manager＆＃39; }，{名称：＆＃39; Barb＆＃39; ，角色：＆＃39; admin＆＃39; }，{名称：＆＃39; Dave＆＃39; ，角色：＆manager＆＃39; }]＃现在，您如何找到仅具有模式匹配功能的管理员？。＃Ruby 3.0：[*，{name：，role：＆＃39; admin＆＃39; }，*]＃注意模式：在中间放置一些东西，放置之前和之后的物品数量未知＆＃34; Admin：＃{name}＆＃34;结束＃=＆gt;管理员：Barb＃在不受限制的情况下选择值，第一个splat是非贪婪的：[* before，user，* after]的case用户将＆＃34;匹配之前：＃{before}＆＃34;放置＆＃34;匹配：＃{用户}＆＃34;比赛后放置＆＃34 ;：}＆＃34;之后## end＃比赛之前：[]＃比赛：{：name =＆gt;＆＃34; John＆＃34 ;,：role =＆gt;＆＃34; user＆＃34;}＃比赛后：[{：name =＆gt; ＆＃34; Jane＆＃34 ;,：role =＆gt;＆＃34; manager＆＃34;}，{：name =＆gt;＆＃34; Barb＆＃34 ;,：role =＆gt;＆＃34; admin＆＃ 34;}，{：name =＆gt;＆＃34; Dave＆＃34 ;,：role =＆gt;＆＃34; manager＆＃34;}]＃选择从何处开始播放时不考虑Guard子句：[ *，用户，*]（如果用户[：role] ==＆＃39; admin＆＃39;将＆＃34;用户：＃{用户}＆＃34;结束＃=＆gt; NoMatchingPatternError-它首先将John放入`user`中，＃然后才检查了guard子句，该子句不匹配使用（模式中有多个splat），＃应该恰好有两个，并且它们可能仅是第一个，而＃是最后一个元素：[first_user，*，{name：，角色：＆＃39;管理员＆＃39; }，*]＃^语法错误，意外*将＆＃34; Admin：＃{name}＆＃34; end＃仍然可以在任意位置使用splat：在[{name：first_user_name}，*，{name：last_user_name}]中的case用户将＆＃34;第一用户：＃{first_user_name}，最后一个用户：＃{last_user_name}＆ ＃34;结束＃=＆gt;第一个用户：John，最后一个用户：Dave </p><p>  Notes:  Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.</p><p>注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改。</p><p>  When class  @@variable is overwritten by the parent of the class, or by the module included, the error is raised. In addition, top-level class variable access also raises an error.</p><p>  当类@@ variable被类的父级或所包含的模块覆盖时，将引发错误。此外，顶级类变量访问也会引发错误。</p><p> Reason: Class variables, with their “non-intuitive” access rules, are frequently considered a bad practice. They still can be very useful for tracking something across class hierarchy. But the fact that the entire hierarchy shares the same variable may lead to hard-to-debug bugs, so it was fixed to raise on the usage that seems unintentional.</p><p> 原因：具有“非直观”访问规则的类变量通常被认为是不良做法。它们对于在整个类层次结构中跟踪某些内容仍然非常有用。但是，整个层次结构共享相同的变量这一事实可能会导致难以调试的错误，因此已进行了修正，以提高似乎无意的用法。</p><p>      Code:  # Intended usage: parent defines the variable available for all children class  Good  @@registry  =  []  # assume it is meant to store all the children  def  self . registry  @@registry  end end class  GoodChild  &lt;  Good  def  self . register!  @@registry  &lt;&lt;  self  @@registry  =  @@registry . sort  # reassigning the value -- but it is still the PARENT&#39;s variable  end end GoodChild . register! p  Good . registry  # =&gt; [GoodChild] # Unintended usage: the variable is defined in the child, but then the parent changes it class  Bad  def  self . corrupt_registry!  @@registry  =  []  end end class  BadChild  &lt;  Bad  @@registry  =  {}  # This is some variable which meant to belong to THIS class  def  self . registry  @@registry  end end Bad . corrupt_registry!  # Probably unexpected for BadChild&#39;s author, its ancestor have changed the variable BadChild . registry  # On the next attempt to _access_ the variable the error will be raised # 2.7: =&gt; [] # 3.0: RuntimeError (class variable @@registry of BadChild is overtaken by Bad) # The same error is raised if the included module suddenly changes class module  OtherRegistry  @@registry  =  {} end Good . include  OtherRegistry Good . registry  # On the next attempt to _access_ the variable the error will be raised # 2.7: =&gt; {} # 3.0: RuntimeError (class variable @@registry of Good is overtaken by OtherRegistry)</p><p>      代码：＃预期用途：父类定义了所有子类都可用的变量Good @@ registry = []＃假定它旨在存储所有子类def self。注册表@@ registry结束结束类GoodChild＆lt;自我防卫能力强。寄存器！ @@ registry＆lt;＆lt;自我@@ registry = @@ registry。 sort＃重新分配值-但它仍然是PARENT的变量结束端GoodChild。寄存器！ p好。注册表＃=＆gt; [GoodChild]＃意外使用：该变量在子级中定义，但随后父级将其更改为Bad def self类。腐败注册表！ @@ registry = []结束类BadChild＆lt;错误的@@ registry = {}＃这是一些变量，它属于THIS类def self。注册表@@ registry结束结束错误。腐败注册表！ ＃对于BadChild的作者来说可能是意外的，其祖先更改了变量BadChild。注册表＃下次尝试访问变量时，将引发错误＃2.7：=＆gt; []＃3.0：RuntimeError（BadChild的类变量@@ registry被Bad取代）＃如果所包含的模块突然更改类模块OtherRegistry @@ registry = {} end Good，则会引发相同的错误。包括OtherRegistry Good。注册表＃下次尝试访问变量时，将引发错误＃2.7：=＆gt; {}＃3.0：RuntimeError（GoodRegistry的类变量@@ registry被OtherRegistry覆盖）</p><p>  yield in a singleton class definitions, which was deprecated in  2.7 is now  SyntaxError –  Feature #15575</p><p>  在2.7中已弃用的单例类定义中的yield现在是SyntaxError – Feature＃15575</p><p>  Assigning to a numbered parameter ( introduced in 2.7) is now a  SyntaxError instead of a warning.</p><p>  现在，分配给带编号的参数（在2.7中引入）是SyntaxError而不是警告。</p><p>  The discussion of possible solutions for  static or  gradual typing and possible syntax of type declarations in Ruby code had been open for years. At 3.0, Ruby’s core team made their mind towards  type declaration in separate files and  separate tools to check types. So, as of 3.0:</p><p>  关于静态或渐进类型的可能解决方案以及Ruby代码中类型声明的可能语法的讨论已经开放了多年。在3.0版本中，Ruby的核心团队决定在单独的文件和单独的工具中检查类型的类型声明。因此，从3.0开始： </p><p> the syntax for type declarations is like following (small example):  class  Dog  attr_reader  name:  String  def  initialize :  ( name:  String )  -&gt;  void  def  bark :  ( at:  Person  |  Dog  |  nil )  -&gt;  String end</p><p>类型声明的语法如下（小示例）：类Dog attr_reader名称：String def initialize：（name：String）-＆gt; void def bark：（at：Person | Dog | nil）-＆gt;弦尾</p><p>  type declaration for the core classes and the standard library is shipped with the language;</p><p>  核心类的类型声明和标准库随语言一起提供；</p><p>  rbs library is shipped with Ruby, providing tools for checking actual types in code against the declarations; and for auto-detecting (to some extent) the actual types of yet-untyped code;</p><p>  rbs库随Ruby一起提供，提供了用于根据声明检查代码中实际类型的工具；用于（在某种程度上）自动检测尚未键入的代码的实际类型；</p><p>  TypeProf is another tool (“Type Profiler”) shipping with Ruby 3.0 as a bundled gem, allowing  to auto-detect the actual types of the Ruby by “abstract interpretation” (running through code without actually executing it);</p><p>  TypeProf是随Ruby 3.0捆绑提供的另一个工具（“ Type Profiler”），可通过“抽象解释”（无需实际执行代码即可遍历代码）自动检测Ruby的实际类型；</p><p> For a deeper understanding, please check those tools’ documentation; also  this article by Vladimir Dementiev of Evil Martians takes a detailed look into tools and concepts.</p><p> 为了更深入地了解，请查看这些工具的文档；邪恶火星人的弗拉基米尔·德门蒂耶夫（Vladimir Dementiev）的这篇文章也对工具和概念进行了详细研究。</p><p>    Reason: Mostly for consistency.  Object#clone(freeze: false) was  introduced in Ruby 2.4 as an  only way of producing unfrozen object;  clone(freeze: true) is basically an equivalent of  clone +  freeze.</p><p>    原因：主要是为了保持一致性。 Ruby 2.4中引入了Object＃clone（freeze：false）作为产生未冻结对象的唯一方法。 clone（freeze：true）基本上等同于clone + Frozen。</p><p>      Code:  o  =  Object . new o . clone ( freeze:  true ). frozen? # =&gt; false in Ruby 2.7 # =&gt; true in Ruby 3.0 o  =  Object . new . freeze o . clone ( freeze:  false ). frozen? # =&gt; false in Ruby 2.7 and 3.0</p><p>      代码：o =对象。新o。克隆（Frozen：true）。冻结？ ＃=＆gt;在Ruby 2.7中为false。在Ruby 3.0中为true o = Object。新的。冻结o。克隆（Frozen：false）。冻结？ ＃=＆gt;在Ruby 2.7和3.0中为false </p><p>  Specialized constructor  #initialize_clone, which is called when object is cloned, now receives  freeze: argument if it was passed to  #clone.</p><p>专门的构造函数#initialize_clone（在克隆对象时调用）现在可以接收Frozen：参数（如果已将其传递给#clone）。</p><p> Reason: For composite objects, it is hard to address freezing/unfreezing of nested data in  #initialize_clone without this argument.</p><p> 原因：对于复合对象，如果没有此参数，则很难解决#initialize_clone中嵌套数据的冻结/取消冻结。</p><p>      Code:  require  &#39;set&#39; set  =  Set [ 1 ,  2 ,  3 ]. freeze set . frozen?  # =&gt; true set . instance_variable_get ( &#39;@hash&#39; ). frozen?  # =&gt; true, as expected unfrozen  =  set . clone ( freeze:  false ) unfrozen . frozen?  # =&gt; false, as expected unfrozen . instance_variable_get ( &#39;@hash&#39; ). frozen? # 2.7: =&gt; true, still # 3.0: =&gt; false, as it should be -- becase Set have redefined #initialize_clone unfrozen  &lt;&lt;  4 # 2.7: FrozenError (can&#39;t modify frozen Hash: {1=&gt;true, 2=&gt;true, 3=&gt;true}) # 3.0: =&gt; #&lt;Set: {1, 2, 3, 4}&gt;</p><p>      代码：require＆＃39;设置＆＃39; set =设置[1，2，3]。冻结设置。冻结？ ＃=＆gt;真实设置。 instance_variable_get（＆＃39; @ hash＆＃39;）。冻结？ ＃=＆gt;正确，如预期的那样取消冻结= set。复制（frozen：false）未冻结。冻结？ ＃=＆gt;错误，如预期的那样冻结。 instance_variable_get（＆＃39; @ hash＆＃39;）。冻结？ ＃2.7：=＆gt;正确，仍然是＃3.0：=＆gt;假，应该是这样-如果Set已重新定义#initialize_clone unfrozen＆lt;＆lt; 4＃2.7：FrozenError（无法修改冻结的Hash：{1 =＆gt; true，2 =＆gt; true，3 =＆gt; true}）＃3.0：=＆gt; ＃＆lt;设置：{1、2、3、4}＆gt;</p><p>  Notes: A lot of attention to proper object freezing in Ruby 3.0 is due to the introduction of  Ractors, which made the important distinction if the object is truly frozen (and therefore safe to share between parallel ractors).</p><p>  注意：Ruby 3.0中适当的对象冻结引起了很多关注，这是由于引入了Ractors，如果真正地冻结了对象（因此可以安全地在并行的ractors之间共享），Ractors就会带来重要的区别。</p><p>  Now, when the second argument ( binding) is passed to  eval,  __FILE__ in evaluated code is  (eval), and  __LINE__ starts from  1 (just like without  binding). Before 2.7 it was evaluated in context of  binding (e.g. returned file from where  binding came from), on 2.7 the warning was printed; now the behavior is considered final.</p><p>  现在，当第二个参数（绑定）传递给eval时，评估代码中的__FILE__为（eval），而__LINE__从1开始（就像没有绑定一样）。在2.7之前，它是在绑定的上下文中进行评估的（例如，绑定来自的返回文件），在2.7上会打印警告；现在该行为被认为是最终的。</p><p> Reason: Binding might be passed to  eval in order to provide the access to some context necessary for evaluation (this technique, for example, frequently used in templating engines); but it had an unintended consequence of making  __FILE__ and  __LINE__ to point not to actually evaluated code, which can be misleading, for example, on errors processing.</p><p> 原因：绑定可能会传递给eval，以便提供对评估所必需的某些上下文的访问（例如，此技术在模板引擎中经常使用）；但这会使__FILE__和__LINE__指向未实际评估的代码产生了意想不到的结果，这可能会引起误解，例如在错误处理方面。</p><p>      Code:  # file a.rb class  A  def  get_binding  binding  end end # file b.rb require_relative  &#39;a&#39; eval ( &#39;p [__FILE__, __LINE__]&#39; )  # without binding eval ( &#39;p [__FILE__, __LINE__]&#39; ,  A . new . get_binding )  # with binding from another file # Ruby 2.6: # [&#34;(eval)&#34;, 1] # [&#34;a.rb&#34;, 3] # Ruby 2.7: # [&#34;(eval)&#34;, 1] # [&#34;a.rb&#34;, 3] # warning: __FILE__ in eval may not return location in binding; use Binding#source_location instead # warning: __LINE__ in eval may not return location in binding; use Binding#source_location instead # Ruby 3.0: # [&#34;(eval)&#34;, 1] # [&#34;(eval)&#34;, 1]</p><p>      代码：＃文件a.rb类A def get_binding绑定结束端＃文件b.rb require_relative＆＃39; a＆＃39; eval（＆＃39; p [__FILE__，__LINE __]＆＃39;）＃不绑定eval（＆＃39; p [__FILE__，__LINE __]＆＃39;，A. new。get_binding）＃从另一个文件绑定＃ Ruby 2.6：＃[＆＃34;（eval）＆＃34;，1]＃[＆＃34; a.rb＆＃34;，3]＃Ruby 2.7：＃[＆＃34;（eval）＆＃34 ;，1]＃[＆＃34; a.rb＆＃34 ;, 3]＃警告：eval中的__FILE__可能不会返回绑定中的位置；使用Binding＃source_location代替＃警告：eval中的__LINE__可能不会返回绑定中的位置；使用Binding＃source_location代替＃Ruby 3.0：＃[＆＃34;（eval）＆＃34 ;, 1]＃[＆＃34;（eval）＆＃34 ;, 1] </p><p>  Reason: The change is related to Ractor introduction (see below): it makes a difference whether an object is frozen when sharing it between ractors. As both ranges and regexps have immutable core data, it was considered that making them frozen is the right thing to do.</p><p>原因：更改与Ractor的引入有关（请参见下文）：当在tracer之间共享对象时，是否冻结对象产生了不同。由于范围和正则表达式都具有不变的核心数据，因此认为冻结它们是正确的做法。</p><p>    Code:  /foo/ . frozen?  # =&gt; true ( 42 ... ). frozen?  # =&gt; true # Regexps are frozen even when constructed with dynamic interpolation /. #{ rand ( 10 ) } / . frozen?  # =&gt; true # ...but not when they are constructed with the constructor Regexp . new ( &#39;foo&#39; ). frozen?  # =&gt; false # ...but ranges are always frozen Range . new ( &#39;a&#39; ,  &#39;b&#39; ). frozen?  # =&gt; true # Regularly, as the data can&#39;t be changed anyways, the frozenness wouldn&#39;t affect your code. # It might, though, if the code does something smart like: regexp  =  /^\w+\s*\w*$/ regexp . instance_variable_set ( &#39;@context&#39; ,  :name ) # 2.7: ok # 3.0: FrozenError (can&#39;t modify frozen Regexp: /^\w+\s*\w*$/) # ...or RANGE  =  Time . new ( 2020 ,  3 ,  1 ) .. Time . new ( 2020 ,  9 ,  1 ) def  RANGE . to_s  self . begin . strftime ( &#39;%Y, %b %d&#39; )  +  &#39; - &#39;  +  self . end . strftime ( &#39;%b %d&#39; ) end # 2.7: OK # 3.0: FrozenError (can&#39;t modify frozen object: 2020-03-01 00:00:00 +0200..2020-09-01 00:00:00 +0300) # Note also, that range freezing is not &#34;deep&#34;: string_range  =  &#39;a&#39; .. &#39;z&#39; string_range . end . upcase! string_range # =&gt; &#39;a&#39;..&#39;Z&#39; # clone(freeze: false) still allows to unfreeze both: unfrozen  =  RANGE </p><p>    代码：/ foo /。冻结？ ＃=＆gt;正确（42 ...）。冻结？ ＃=＆gt; true＃即使使用动态插值/构造正则表达式也会冻结。 ＃{rand（10）} /。冻结？ ＃=＆gt; true＃...但是当使用构造函数Regexp构造它们时不是。新（＆＃39; foo＆＃39;）。冻结？ ＃=＆gt; false＃...但范围始终冻结Range。新（＆＃39; a＆＃39;，＆＃39; b＆＃39;）。冻结？ ＃=＆gt; true＃定期地，由于无论如何都无法更改数据，因此冻结不会影响您的代码。 ＃但是，如果代码做了一些聪明的事情，则可能是这样：regexp = / ^ \ w + \ s * \ w * $ / regexp。 instance_variable_set（＆＃39; @ context＆＃39;，：name）＃2.7：好的＃3.0：FrozenError（无法修改冻结的Regexp：/ ^ \ w + \ s * \ w * $ /）＃...或RANGE = Time。新（2020,3,1）..时间。新（2020,9,1）def RANGE。自我。开始 。 strftime（＆＃39;％Y，％b％d＆＃39;）+＆＃39; -＆＃39; +自我。结束 。 strftime（＆＃39;％b％d＆＃39;）结束＃2.7：OK＃3.0：FrozenError（无法修改冻结的对象：2020-03-01 00:00:00 + 0200..2020-09 -01 00:00:00 +0300）＃另请注意，范围冻结不是＆＃34; deep＆＃34 ;： string_range =＆＃39; a＆＃39; ..＆＃39; z＆＃39; string_range。结束 。大写！ string_range＃=＆gt; ＆＃39; ..＆＃39; Z＆＃39; ＃clone（freeze：false）仍然允许解冻两个：unfrozen = RANGE</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rubyreferences.github.io/rubychanges/3.0.html">https://rubyreferences.github.io/rubychanges/3.0.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/def/">#def</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>