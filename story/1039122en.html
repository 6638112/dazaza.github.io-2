<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Python对象系统如何工作 How Python object system works</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Python object system works<br/>Python对象系统如何工作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-12 01:56:01</div><div class="page_narrow text-break page_content"><p>As we know from the previous parts of this series, the execution of a Python program consists of two major steps:</p><p>从本系列前面的部分我们知道，Python程序的执行包括两个主要步骤：</p><p>  We&#39;ve been focusing on the second step for quite a while. In  part 4 we&#39;ve looked at the evaluation loop, a place where Python bytecode gets executed. And in  part 5 we&#39;ve studied how the VM executes the instructions that are used to implement variables. What we haven&#39;t covered yet is how the VM actually computes something. We postponed this question because to answer it, we first need to understand how the most fundamental part of the language works. Today, we&#39;ll study the Python object system.</p><p>  我们已经将重点放在第二步已经有一段时间了。在第4部分中，我们研究了评估循环，即执行Python字节码的地方。在第5部分中，我们研究了VM如何执行用于实现变量的指令。我们还没有讨论虚拟机实际上是如何计算某些东西的。我们推迟这个问题是因为要回答这个问题，我们首先需要了解语言最基本的部分是如何工作的。今天，我们将研究Python对象系统。</p><p> Note: In this post I&#39;m referring to CPython 3.9. Some implementation details will certainly change as CPython evolves. I&#39;ll try to keep track of important changes and add update notes.</p><p> 注意：在本文中，我指的是CPython 3.9。随着CPython的发展，某些实现细节肯定会发生变化。我将尝试跟踪重要的更改并添加更新说明。</p><p>    To compute the function  f, CPython must evaluate the expression  x + 7. The question I&#39;d like to ask is: How does CPython do that? Special methods such as  __add__() and  __radd__() probably come to your mind. When we define these methods on a class, the instances of that class can be added using the  + operator. So, you might think that CPython does something like this:</p><p>    为了计算函数f，CPython必须计算表达式x +7。我想问的问题是：CPython如何做到这一点？您可能会想到诸如__add __（）和__radd __（）之类的特殊方法。当我们在类上定义这些方法时，可以使用+运算符添加该类的实例。因此，您可能会认为CPython会执行以下操作：</p><p> If  x doesn&#39;t have  __add__(), or if this method fails, it calls  (7).__radd__(x) or  int.__radd__(7, x).</p><p> 如果x没有__add __（），或者此方法失败，它将调用（7）.__ radd __（x）或int .__ radd __（7，x）。</p><p> The reality, tough, is a bit more complicated. What really happens depends on what  x is. For example, if  x is an instance of a user-defined class, the algorithm described above resembles the truth. If, however,  x is an instance of a built-in type, like  int or  float, CPython doesn&#39;t call any special methods at all.</p><p> 艰难的现实要复杂得多。实际发生的情况取决于x是多少。例如，如果x是用户定义类的实例，则上述算法类似于事实。但是，如果x是内置类型的实例（例如int或float），则CPython根本不会调用任何特殊方法。</p><p>   Let&#39;s apply this algorithm to the function  f. The compiler translates the body of this function to the following bytecode:</p><p>   让我们将此算法应用于函数f。编译器将此函数的主体转换为以下字节码： </p><p> $ python -m dis f.py... 2 0 LOAD_FAST 0 (x) 2 LOAD_CONST 1 (7) 4 BINARY_ADD 6 RETURN_VALUE</p><p>$ python -m dis f.py ... 2 0 LOAD_FAST 0（x）2 LOAD_CONST 1（7）4 BINARY_ADD 6 RETURN_VALUE</p><p>  BINARY_ADD pops two values from the stack, adds them and pushes the result back onto the stack.</p><p>  BINARY_ADD从堆栈中弹出两个值，将它们相加并将结果推回堆栈中。</p><p> How does the VM add two values? To answer this question, we need to understand what these values are. For us,  7 is an instance of  int and  x is, well, anything. For the VM, though, everything is a Python object. All values the VM pushes onto the stack and pops from the stack are pointers to  PyObject structs (hence the phrase &#34;Everything in Python is an object&#34;).</p><p> VM如何将两个值相加？要回答这个问题，我们需要了解这些值是什么。对我们来说，7是int的实例，而x是任何东西。但是，对于VM，一切都是Python对象。 VM推送到堆栈并从堆栈弹出的所有值都是指向PyObject结构的指针（因此，短语＆＃34; Python中的所有内容都是对象）。</p><p> The VM doesn&#39;t need to know how to add integers or strings, that is, how to do the arithmetic or concatenate sequences. All it needs to know is that every Python object has a type. A type, in turn, knows everything about its objects. For example, the  int type knows how to add integers, and the  float type knows how to add floats. So, the VM asks the type to perform the operation.</p><p> VM不需要知道如何添加整数或字符串，即如何进行算术或连接序列。它需要知道的是每个Python对象都有一个类型。反过来，类型知道有关其对象的所有信息。例如，int类型知道如何添加整数，而float类型则知道如何添加浮点数。因此，VM要求类型执行操作。</p><p> This simplified explanation captures the essence of the solution, but it also omits a lot of important details. To get a more realistic picture, we need to understand what Python objects and types really are and how they work.</p><p> 这种简化的说明抓住了解决方案的本质，但同时也省略了许多重要的细节。为了获得更真实的画面，我们需要了解什么是真正的Python对象和类型以及它们如何工作。</p><p>  We&#39;ve discussed Python objects a little in  part 3. This discussion is worth repeating here.</p><p>  我们已经在第3部分中讨论了Python对象。在这里值得重复讨论。</p><p>  typedef  struct  _object  {  _PyObject_HEAD_EXTRA  // macro, for debugging purposes only  Py_ssize_t  ob_refcnt ;  PyTypeObject  * ob_type ; }  PyObject ;</p><p>  typedef struct _object {_PyObject_HEAD_EXTRA //宏，仅用于调试目的Py_ssize_t ob_refcnt; PyTypeObject * ob_type; } PyObject; </p><p>   We said that the VM treats any Python object as  PyObject. How is that possible? The C programming language has no notion of classes and inheritance. Nevertheless, it&#39;s possible to implement in C something that can be called a single inheritance. The C standard states that a pointer to any struct can be converted to a pointer to its first member and vice versa. So, we can &#34;extend&#34;  PyObject by defining a new struct whose first member is  PyObject.</p><p>我们说过，VM将任何Python对象都视为PyObject。那怎么可能？ C编程语言没有类和继承的概念。不过，可以在C中实现可以称为单一继承的东西。 C标准指出，指向任何结构的指针都可以转换为指向其第一个成员的指针，反之亦然。因此，我们可以＆＃34;扩展＆＃34;通过定义第一个成员为PyObject的新结构来实现PyObject。</p><p>   A  float object stores everything  PyObject stores plus a floating-point value  ob_fval. The C standard simply states that we can convert a pointer to  PyFloatObject to a pointer to  PyObject and vice versa:</p><p>   浮点对象存储PyObject存储的所有内容以及浮点值ob_fval。 C标准仅声明我们可以将指向PyFloatObject的指针转换为指向PyObject的指针，反之亦然：</p><p>  The reason why the VM treats every Python object as  PyObject is because all it needs to access is the object&#39;s type. A type is also a Python object, an instance of the  PyTypeObject struct:</p><p>  VM之所以将每个Python对象都视为PyObject，是因为它需要访问的只是对象的类型。类型也是Python对象，是PyTypeObject结构的实例：</p><p> // PyTypeObject is a typedef for &#34;struct _typeobject&#34; struct  _typeobject  {  PyVarObject  ob_base ;  // expansion of PyObject_VAR_HEAD macro  const  char  * tp_name ;  /* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */  Py_ssize_t  tp_basicsize ,  tp_itemsize ;  /* For allocation */  /* Methods to implement standard operations */  destructor  tp_dealloc ;  Py_ssize_t  tp_vectorcall_offset ;  getattrfunc  tp_getattr ;  setattrfunc  tp_setattr ;  PyAsyncMethods  * tp_as_async ;  /* formerly known as tp_compare (Python 2)  or tp_reserved (Python 3) */  reprfunc  tp_repr ;  /* Method suites for standard classes */  PyNumberMethods  * tp_as_number ;  PySequenceMethods  * tp_as_sequence ;  PyMappingMethods  * tp_as_mapping ;  /* More standard operations (here for binary compatibility) */  hashfunc  tp_hash ;  ternaryfunc  tp_call ;  reprfunc  tp_str ;  getattrofunc  tp_getattro ;  setattrofunc  tp_setattro ;  /* Functions to access object as input/output buffer */  PyBufferProcs  * tp_as_buffer ;  /* Flags to define presence of optional/expanded features */  unsigned  long  tp_flags ;  const  char  * tp_doc ;  /* Documentation string */  /* Assigned meaning in release 2.0 */  /* call function for all accessible objects */  traverseproc  tp_traverse ;  /* delete references to contained objects */  inquiry  tp_clear ;  /* Assigned meaning in release 2.1 */  /* rich comparisons */  richcmpfunc  tp_richcompare ;  /* weak reference enabler */  Py_ssize_t  tp_weaklistoffset ;  /* Iterators */  getiterfunc  tp_iter ;  iternextfunc  tp_iternext ;  /* Attribute descriptor and subclassing stuff */  struct  PyMethodDef  * tp_methods ;  struct  PyMemberDef  * tp_members ;  struct  PyGetSetDef  * tp_getset ;  struct  _typeobject  * tp_base ;  PyObject  * tp_dict ;  descrgetfunc  tp_descr_get ;  descrsetfunc  tp_descr_set ;  Py_ssize_t  tp_dictoffset ;  initproc  tp_init ;  allocfunc  tp_alloc ;  newfunc  tp_new ;  freefunc  tp_free ;  /* Low-level free-memory routine */  inquiry  tp_is_gc ;  /* For PyObject_IS_GC */  PyObject  * tp_bases ;  PyObject  * tp_mro ;  /* method resolution order */  PyObject  * tp_cache ;  PyObject  * tp_subclasses ;  PyObject  * tp_weaklist ;  destructor  tp_del ;  /* Type attribute cache version tag. Added in version 2.6 */  unsigned  int  tp_version_tag ;  destructor  tp_finalize ;  vectorcallfunc  tp_vectorcall ; };</p><p> // PyTypeObject是＆＃34; struct _typeobject＆＃34;的typedef struct _typeobject {PyVarObject ob_base; //扩展PyObject_VAR_HEAD宏const char * tp_name; / *对于打印，格式为＆＃34;＆lt; module＆gt;。＆lt; name＆gt;＆＃34; * / Py_ssize_t tp_basicsize，tp_itemsize; / *对于分配* / / *实现标准操作的方法* /析构函数tp_dealloc; Py_ssize_t tp_vectorcall_offset; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods * tp_as_async; / *以前称为tp_compare（Python 2）或tp_reserved（Python 3）* / reprfunc tp_repr; / *标准类的方法套件* / PyNumberMethods * tp_as_number; PySequenceMethods * tp_as_sequence; PyMappingMethods * tp_as_mapping; / *更多标准操作（此处为二进制兼容性）* / hashfunc tp_hash; ternaryfunc tp_call; reprfunc tp_str; getattrofunc tp_getattro; setattrofunc tp_setattro; / *访问对象作为输入/输出缓冲区的功能* / PyBufferProcs * tp_as_buffer; / *标志定义可选/扩展功能的存在* /无符号长tp_flags; const char * tp_doc; / *文档字符串* / / *在2.0版中分配的含义* / / *所有可访问对象的调用函数* / traverseproc tp_traverse; / *删除对包含对象的引用* /查询tp_clear; / *在2.1版中分配的含义* / / *丰富的比较* / richcmpfunc tp_richcompare; / *弱参考启用码* / Py_ssize_t tp_weaklistoffset; / *迭代器* / getiterfunc tp_iter; iternextfunc tp_iternext; / *属性描述符和子类化的东西* / struct PyMethodDef * tp_methods; struct PyMemberDef * tp_members; struct PyGetSetDef * tp_getset; struct _typeobject * tp_base; PyObject * tp_dict; descrgetfunc tp_descr_get; descrsetfunc tp_descr_set; Py_ssize_t tp_dictoffset; initproc tp_init; allocfunc tp_alloc; newfunc tp_new; freefunc tp_free; / *低级自由内存例程* /查询tp_is_gc; / *对于PyObject_IS_GC * / PyObject * tp_bases; PyObject * tp_mro; / *方法解析顺序* / PyObject * tp_cache; PyObject * tp_subclasses; PyObject * tp_weaklist;析构函数tp_del; / *类型属性高速缓存版本标记。在2.6版中添加* / unsigned int tp_version_tag;析构函数tp_finalize; vectorcallfunc tp_vectorcall; };</p><p> By the way, note that the first member of a type is not  PyObject but  PyVarObject, which is defined as follows:</p><p> 顺便说一句，请注意，类型的第一个成员不是PyObject而是PyVarObject，其定义如下：</p><p> typedef  struct  {  PyObject  ob_base ;  Py_ssize_t  ob_size ;  /* Number of items in variable part */ }  PyVarObject ;</p><p> typedef struct {PyObject ob_base; Py_ssize_t ob_size; / *可变部分中的项目数* /} PyVarObject;</p><p> Nevertheless, since the first member of  PyVarObject is  PyObject, a pointer to a type can still be converted to a pointer to  PyObject.</p><p> 但是，由于PyVarObject的第一个成员是PyObject，所以仍然可以将指向类型的指针转​​换为指向PyObject的指针。 </p><p> So, what is a type and why does it have so many members? A type determines how the objects of that type behave. Each member of a type, called slot, is responsible for a particular aspect of the object&#39;s behavior. For example:</p><p>那么，什么是类型？为什么它有这么多成员？类型确定该类型的对象的行为。类型的每个成员（称为插槽）负责对象行为的特定方面。例如：</p><p> tp_str is a pointer to a function that implements  str() for objects of the type.</p><p> tp_str是指向为该类型的对象实现str（）的函数的指针。</p><p> tp_hash is a pointer to a function that implements  hash() for objects of the type.</p><p> tp_hash是指向为该类型的对象实现hash（）的函数的指针。</p><p> Some slots, called sub-slots, are grouped together in suites. A suite is just a struct that contains related slots. For example, the  PySequenceMethods struct is a suite of sub-slots that implement the sequence protocol:</p><p> 一些插槽（称为子插槽）在套件中分组在一起。套件只是包含相关插槽的结构。例如，PySequenceMethods结构是实现序列协议的一组子插槽：</p><p> typedef  struct  {  lenfunc  sq_length ;  binaryfunc  sq_concat ;  ssizeargfunc  sq_repeat ;  ssizeargfunc  sq_item ;  void  * was_sq_slice ;  ssizeobjargproc  sq_ass_item ;  void  * was_sq_ass_slice ;  objobjproc  sq_contains ;  binaryfunc  sq_inplace_concat ;  ssizeargfunc  sq_inplace_repeat ; }  PySequenceMethods ;</p><p> typedef struct {lenfunc sq_length; binaryfunc sq_concat; ssizeargfunc sq_repeat; ssizeargfunc sq_item;无效* was_sq_slice; ssizeobjargproc sq_ass_item;无效* was_sq_ass_slice; objobjproc sq_contains; binaryfunc sq_inplace_concat; ssizeargfunc sq_inplace_repeat; pySequenceMethods；</p><p> If you count all the slots and sub-slots, you&#39;ll get a scary number. Fortunately, each slot is very well  documented in the Python/C API Reference Manual (I strongly recommend you to bookmark this link). Today we&#39;ll cover only a few slots. Nevertheless, it shall give us a general idea of how slots are used.</p><p> 如果计算所有插槽和子插槽的数量，您会得到一个可怕的数字。幸运的是，每个插槽在《 Python / C API参考手册》中都有很好的记录（我强烈建议您为该链接添加书签）。今天，我们将只介绍几个插槽。但是，它应该使我们对如何使用插槽有一个总体了解。</p><p> Since we&#39;re interested in how CPython adds objects, let&#39;s find the slots responsible for addition. There must be at least one such slot. After careful inspection of the  PyTypeObject struct, we find that it has the &#34;number&#34; suite  PyNumberMethods, and the first slot of this suite is a binary function called  nd_add:</p><p> 由于我们对CPython如何添加对象感兴趣，因此我们找到负责添加的插槽。必须至少有一个这样的插槽。仔细检查PyTypeObject结构后，我们发现它具有＆＃34; number＆＃34;套件PyNumberMethods，该套件的第一个插槽是一个名为nd_add的二进制函数： </p><p> typedef  struct  {  binaryfunc  nb_add ;  // typedef PyObject * (*binaryfunc)(PyObject *, PyObject *)  binaryfunc  nb_subtract ;  binaryfunc  nb_multiply ;  binaryfunc  nb_remainder ;  binaryfunc  nb_divmod ;  // ... more sub-slots }  PyNumberMethods ;</p><p>typedef struct {binaryfunc nb_add; // typedef PyObject *（* binaryfunc）（PyObject *，PyObject *）binaryfunc nb_subtract; binaryfunc nb_multiply; binaryfunc nb_remainder; binaryfunc nb_divmod; // ...更多子插槽} PyNumberMethods;</p><p> It seems that the  nb_add slot is what we&#39;re looking for. Two questions naturally arise regarding this slot:</p><p> 看来nb_add插槽正是我们要寻找的。关于此广告位自然会引起两个问题：</p><p>  I think it&#39;s better to start with the second. We should expect that the VM calls  nb_add to execute the  BINARY_ADD opcode. So, let&#39;s, for a moment, suspend our discussion about types and take a look at how the  BINARY_ADD opcode is implemented.</p><p>  我认为最好从第二个开始。我们应该期望VM调用nb_add来执行BINARY_ADD操作码。因此，暂时让我们暂停对类型的讨论，并看看BINARY_ADD操作码是如何实现的。</p><p>   case  TARGET ( BINARY_ADD ) :  {  PyObject  * right  =  POP ();  PyObject  * left  =  TOP ();  PyObject  * sum ;  /* NOTE(haypo): Please don&#39;t try to micro-optimize int+int on  CPython using bytecode, it is simply worthless.  See http://bugs.python.org/issue21955 and  http://bugs.python.org/issue10044 for the discussion. In short,  no patch shown any impact on a realistic benchmark, only a minor  speedup on microbenchmarks. */  if  ( PyUnicode_CheckExact ( left )  &amp;&amp;  PyUnicode_CheckExact ( right ))  {  sum  =  unicode_concatenate ( tstate ,  left ,  right ,  f ,  next_instr );  /* unicode_concatenate consumed the ref to left */  }  else  {  sum  =  PyNumber_Add ( left ,  right );  Py_DECREF ( left );  }  Py_DECREF ( right );  SET_TOP ( sum );  if  ( sum  ==  NULL )  goto  error ;  DISPATCH (); }</p><p>   案例TARGET（BINARY_ADD）：{PyObject * right = POP（）; PyObject *左= TOP（）; PyObject *总和; / *注意（haypo）：请不要尝试使用字节码在CPython上微优化int + int，这简直一文不值。有关讨论，请参见http://bugs.python.org/issue21955和http://bugs.python.org/issue10044。简而言之，没有补丁对现实的基准产生任何影响，只是微基准测试的微小提升。 * / if（PyUnicode_CheckExact（左）＆amp;＆amp; PyUnicode_CheckExact（右））{sum = unicode_concatenate（tstate，left，right，f，next_instr）; / * unicode_concatenate使用了对左侧的引用* /} else {sum = PyNumber_Add（left，right）; Py_DECREF（左）; } Py_DECREF（右）; SET_TOP（sum）;如果（sum == NULL）转到错误; DISPATCH（）; }</p><p> This code requires some comments. We can see that it calls  PyNumber_Add() to add two objects, but if the objects are strings, it calls  unicode_concatenate() instead. Why so? This is an optimization. Python strings seem immutable, but sometimes CPython mutates a string and thus avoids creating a new string. Consider appending one string to another:</p><p> 此代码需要一些注释。我们可以看到它调用PyNumber_Add（）以添加两个对象，但是如果对象是字符串，它将改为调用unicode_concatenate（）。为什么这样？这是一个优化。 Python字符串似乎是不可变的，但有时CPython会更改字符串，从而避免创建新的字符串。考虑将一个字符串附加到另一个字符串：</p><p>  If the  output variable points to a string that has no other references, it&#39;s safe to mutate that string. This is exactly the logic that  unicode_concatenate() implements.</p><p>  如果输出变量指向​​没有其他引用的字符串，则可以安全地对该字符串进行突变。这正是unicode_concatenate（）实现的逻辑。</p><p> It might be tempting to handle other special cases in the evaluation loop as well and optimize, for example, integers and floats. The comment explicitly warns against it. The problem is that a new special case comes with an additional check, and this check is only useful when it succeeds. Otherwise, it may have a negative effect on performance.</p><p> 在评估循环中还要处理其他特殊情况并进行优化（例如整数和浮点数）可能很诱人。该评论明确警告不要这样做。问题在于，新的特殊情况带有附加检查，并且此检查仅在成功时才有用。否则，可能会对性能产生负面影响。 </p><p>  PyObject  * PyNumber_Add ( PyObject  * v ,  PyObject  * w ) {  // NB_SLOT(nb_add) expands to &#34;offsetof(PyNumberMethods, nb_add)&#34;  PyObject  * result  =  binary_op1 ( v ,  w ,  NB_SLOT ( nb_add ));  if  ( result  ==  Py_NotImplemented )  {  PySequenceMethods  * m  =  Py_TYPE ( v ) -&gt; tp_as_sequence ;  Py_DECREF ( result );  if  ( m  &amp;&amp;  m -&gt; sq_concat )  {  return  ( * m -&gt; sq_concat )( v ,  w );  }  result  =  binop_type_error ( v ,  w ,  &#34;+&#34; );  }  return  result ; }</p><p>PyObject * PyNumber_Add（PyObject * v，PyObject * w）{// NB_SLOT（nb_add）扩展为＆＃34; offsetof（PyNumberMethods，nb_add）＆＃34; PyObject *结果= binary_op1（v，w，NB_SLOT（nb_add））;如果（结果== Py_NotImplemented）{PySequenceMethods * m = Py_TYPE（v）-＆gt; tp_as_sequence; Py_DECREF（结果）; if（m＆amp; m-＆gt; sq_concat）{返回（* m-＆gt; sq_concat）（v，w）; } result = binop_type_error（v，w，＆＃34; +＆＃34;）;返回结果; }</p><p> I suggest to step into  binary_op1() straight away and figure out what the rest of  PyNumber_Add() does later:</p><p> 我建议立即进入binary_op1（）并弄清楚PyNumber_Add（）的其余部分以后做什么：</p><p> static  PyObject  * binary_op1 ( PyObject  * v ,  PyObject  * w ,  const  int  op_slot ) {  PyObject  * x ;  binaryfunc  slotv  =  NULL ;  binaryfunc  slotw  =  NULL ;  if  ( Py_TYPE ( v ) -&gt; tp_as_number  !=  NULL )  slotv  =  NB_BINOP ( Py_TYPE ( v ) -&gt; tp_as_number ,  op_slot );  if  ( ! Py_IS_TYPE ( w ,  Py_TYPE ( v ))  &amp;&amp;  Py_TYPE ( w ) -&gt; tp_as_number  !=  NULL )  {  slotw  =  NB_BINOP ( Py_TYPE ( w ) -&gt; tp_as_number ,  op_slot );  if  ( slotw  ==  slotv )  slotw  =  NULL ;  }  if  ( slotv )  {  if  ( slotw  &amp;&amp;  PyType_IsSubtype ( Py_TYPE ( w ),  Py_TYPE ( v )))  {  x  =  slotw ( v ,  w );  if  ( x  !=  Py_NotImplemented )  return  x ;  Py_DECREF ( x );  /* can&#39;t do it */  slotw  =  NULL ;  }  x  =  slotv ( v ,  w );  if  ( x  !=  Py_NotImplemented )  return  x ;  Py_DECREF ( x );  /* can&#39;t do it */  }  if  ( slotw )  {  x  =  slotw ( v ,  w );  if  ( x  !=  Py_NotImplemented )  return  x ;  Py_DECREF ( x );  /* can&#39;t do it */  }  Py_RETURN_NOTIMPLEMENTED ; }</p><p> 静态PyObject * binary_op1（PyObject * v，PyObject * w，const int op_slot）{PyObject * x; binaryfunc slotv = NULL; binaryfunc slotw = NULL; if（Py_TYPE（v）-> tp_as_number！= NULL）slotv = NB_BINOP（Py_TYPE（v）-> tp_as_number，op_slot）;如果（！Py_IS_TYPE（w，Py_TYPE（v））＆amp;＆amp; Py_TYPE（w）-> tp_as_number！= NULL）{slotw = NB_BINOP（Py_TYPE（w）-> tp_as_number，op_slot）;如果（slotw == slotv）slotw = NULL; } if（slotv）{if（slotw＆amp;＆amp; PyType_IsSubtype（Py_TYPE（w），Py_TYPE（v）））{x = slotw（v，w）;如果（x！= Py_NotImplemented）返回x; Py_DECREF（x）; / *无法做到* / slotw = NULL; } x = slotv（v，w）;如果（x！= Py_NotImplemented）返回x; Py_DECREF（x）; / *无法做到* /}如果（slotw）{x = slotw（v，w）;如果（x！= Py_NotImplemented）返回x; Py_DECREF（x）; / *无法做到* /} Py_RETURN_NOTIMPLEMENTED; }</p><p> The  binary_op1() function takes three parameters: the left operand, the right operand and an offset that identifies the slot. Types of both operands can implement the slot. Therefore,  binary_op1() looks up both implementations. To calculate the result, it calls one implementation or another relying on the following logic:</p><p> binary_op1（）函数采用三个参数：左操作数，右操作数和标识插槽的偏移量。两个操作数的类型都可以实现插槽。因此，binary_op1（）查找两种实现。为了计算结果，它依赖以下逻辑调用一个实现或另一个实现：</p><p> If the type of one operand is a subtype of another, call the slot of the subtype.</p><p> 如果一个操作数的类型是另一个操作数的子类型，则调用该子类型的插槽。</p><p> If the left operand doesn&#39;t have the slot, call the slot of the right operand.</p><p> 如果左侧操作数没有该插槽，请调用右侧操作数的插槽。</p><p> The reason to prioritize the slot of a subtype is to allow the subtypes to override the behavior of their ancestors:</p><p> 优先考虑子类型的插槽的原因是允许子类型覆盖其祖先的行为： </p><p> $ python -q &gt;&gt;&gt;  class  HungryInt ( int ): ...   def  __add__ ( self ,  o ): ...   return  self ... &gt;&gt;&gt;  x  =  HungryInt ( 5 ) &gt;&gt;&gt;  x  +  2 5 &gt;&gt;&gt;  2  +  x 7 &gt;&gt;&gt;  HungryInt . __radd__  =  lambda  self ,  o :  self &gt;&gt;&gt;  2  +  x 5</p><p>$ python -q＆gt;＆gt;＆gt; class HungryInt（int）：... def __add__（self，o）：... return self ...＆gt;＆gt;＆gt; x = HungryInt（5）＆gt;＆gt; x + 2 5＆gt;＆gt; 2 + x 7＆gt;＆gt; HungryInt。 __radd__ = lambda self，o：self＆gt;＆gt;＆gt; 2 + 5</p><p> Let&#39;s turn back to  PyNumber_Add(). If  binary_op1() succeeds,  PyNumber_Add() simply returns the result of  binary_op1(). If, however,  binary_op1() returns the   NotImplemented constant, which means that the operation cannot be performed for a given combination of types,  PyNumber_Add() calls the  sq_concat &#34;sequence&#34; slot of the first operand and returns the result of this call:</p><p> 让我们回到PyNumber_Add（）。如果binary_op1（）成功，则PyNumber_Add（）仅返回binary_op1（）的结果。但是，如果binary_op1（）返回NotImplemented常量，则意味着不能对给定的类型组合执行该操作，则PyNumber_Add（）调用sq_concat＆＃34; sequence＆＃34;。第一个操作数的插槽，并返回此调用的结果：</p><p>  A type can support the  + operator either by implementing  nb_add or  sq_concat. These slots have different meanings:</p><p>  通过实现nb_add或sq_concat，类型可以支持+运算符。这些插槽具有不同的含义：</p><p>  Built-in types such as  int and  float implement  nb_add, and built-in types such as  str and  list implement  sq_concat. Technically, there&#39;s no much difference. The main reason to choose one slot over another is to indicate the appropriate meaning. In fact, the  sq_concat slot is so unnecessary that it&#39;s set to  NULL for all user-defined types (i.e. classes).</p><p>  诸如int和float的内置类型实现nb_add，诸如str和list的内置类型实现sq_concat。从技术上讲，没有太大区别。选择一个插槽而不是另一个插槽的主要原因是要指出适当的含义。实际上，sq_concat插槽是不必要的，因此对于所有用户定义的类型（即类），都将其设置为NULL。</p><p> We saw how the  nb_add slot is used: it&#39;s called by the  binary_op1() function. The next step is to see what it&#39;s set to.</p><p> 我们看到了nb_add插槽的用法：binary_op1（）函数调用了该插槽。下一步是查看其设置。</p><p>  Since addition is a different operation for different types, the  nb_add slot of a type must be one of two things:</p><p>  由于加法对于不同类型是不同的操作，因此类型的nb_add插槽必须是以下两项之一：</p><p> it&#39;s a type-agnostic function that calls some type-specific functions, such as type&#39;s  __add__() special method.</p><p> 它是一个与类型无关的函数，它调用某些特定于类型的函数，例如类型的__add __（）特殊方法。 </p><p> It&#39;s indeed one of these two, and which one depends on the type. For example, built-in types such as  int and  float have their own implementations of  nb_add. In contrast, all classes share the same implementation. Fundamentally, built-in types and classes are the same thing – instances of  PyTypeObject. The important difference between them is how they are created. This difference effects the way the slots are set, so we should discuss it.</p><p>确实是这两者之一，而哪一个取决于类型。例如，诸如int和float之类的内置类型具有其自己的nb_add实现。相反，所有类共享相同的实现。从根本上讲，内置类型和类是一回事-PyTypeObject的实例。它们之间的重要区别是它们的创建方式。这种差异会影响插槽设置的方式，因此我们应该对其进行讨论。</p><p>     An example of a statically defined type is any built-in type. Here&#39;s, for instance, how CPython defines the  float type:</p><p>     静态定义类型的一个示例是任何内置类型。例如，下面是CPython如何定义浮点类型的方法：</p><p> PyTypeObject  PyFloat_Type  =  {  PyVarObject_HEAD_INIT ( &amp; PyType_Type ,  0 )  &#34;float&#34; ,  sizeof ( PyFloatObject ),  0 ,  ( destructor ) float_dealloc ,  /* tp_dealloc */  0 ,  /* tp_vectorcall_offset */  0 ,  /* tp_getattr */  0 ,  /* tp_setattr */  0 ,  /* tp_as_async */  ( reprfunc ) float_repr ,  /* tp_repr */  &amp; float_as_number ,  /* tp_as_number */  0 ,  /* tp_as_sequence */  0 ,  /* tp_as_mapping */  ( hashfunc ) float_hash ,  /* tp_hash */  0 ,  /* tp_call */  0 ,  /* tp_str */  PyObject_GenericGetAttr ,  /* tp_getattro */  0 ,  /* tp_setattro */  0 ,  /* tp_as_buffer */  Py_TPFLAGS_DEFAULT  |  Py_TPFLAGS_BASETYPE ,  /* tp_flags */  float_new__doc__ ,  /* tp_doc */  0 ,  /* tp_traverse */  0 ,  /* tp_clear */  float_richcompare ,  /* tp_richcompare */  0 ,  /* tp_weaklistoffset */  0 ,  /* tp_iter */  0 ,  /* tp_iternext */  float_methods ,  /* tp_methods */  0 ,  /* tp_members */  float_getset ,  /* tp_getset */  0 ,  /* tp_base */  0 ,  /* tp_dict */  0 ,  /* tp_descr_get */  0 ,  /* tp_descr_set */  0 ,  /* tp_dictoffset */  0 ,  /* tp_init */  0 ,  /* tp_alloc */  float_new ,  /* tp_new */ };</p><p> PyTypeObject PyFloat_Type = {PyVarObject_HEAD_INIT（＆amp; PyType_Type，0）＆＃34; float＆＃34; ，sizeof（PyFloatObject），0，（析构函数）float_dealloc，/ * tp_dealloc * / 0，/ * tp_vectorcall_offset * / 0，/ * tp_getattr * / 0，/ * tp_setattr * / 0，/ * tp_as_async * /（reprfunc）float_repr ，/ * tp_repr * /＆amp; float_as_number，/ * tp_as_number * / 0，/ * tp_as_sequence * / 0，/ * tp_as_mapping * /（hashfunc）float_hash，/ * tp_hash * / 0，/ * tp_call * / 0，/ * tp_str * / PyObject_GenericGetAttr，/ * tp * / 0，/ * tp_setattro * / 0，/ * tp_as_buffer * / Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE，/ * tp_flags * / float_new__doc__，/ * tp_doc * / 0，/ * tp_traverse * / 0，/ * tp_clear * / float_richcompare，/ * tp_richcompare * / 0，/ * tp_weaklistoffset * / 0，/ * tp_iter * / ，/ * tp_iternext * / float_methods，/ * tp_methods * / 0，/ * tp_members * / float_getset，/ * tp_getset * / 0，/ * tp_base * / 0，/ * tp_dict * / 0，/ * tp_descr_get * / 0， / * tp_descr_set * / 0，/ * tp_dictoffset * / 0，/ * tp_init * / 0，/ * tp_alloc * / float_new，/ * tp_new * /};</p><p> The slots of a statically defined type are specified explicitly. We can easily see how the  float type implements  nb_add by looking at the &#34;number&#34; suite:</p><p> 静态定义类型的插槽已明确指定。通过查看＆＃34; number＆＃34 ;，我们可以轻松地看到float类型如何实现nb_add。套房：</p><p> static  PyNumberMethods  float_as_number  =  {  float_add ,  /* nb_add */  float_sub ,  /* nb_subtract */  float_mul ,  /* nb_multiply */  // ... more number slots };</p><p> 静态PyNumberMethods float_as_number = {float_add，/ * nb_add * / float_sub，/ * nb_subtract * / float_mul，/ * nb_multiply * / // ... ...更多数字插槽};</p><p>  static  PyObject  * float_add ( PyObject  * v ,  PyObject  * w ) {  double  a , b ;  CONVERT_TO_DOUBLE ( v ,  a );  CONVERT_TO_DOUBLE ( w ,  b );  a  =  a  +  b ;  return  PyFloat_FromDouble ( a ); }</p><p>  静态PyObject * float_add（PyObject * v，PyObject * w）{double a，b; CONVERT_TO_DOUBLE（v，a）; CONVERT_TO_DOUBLE（w，b）; a = a + b;返回PyFloat_FromDouble（a）; }</p><p> The floating-point arithmetic is not that important for our discussion. This example demonstrates how to specify the behavior of a statically defined type. It turned out to be quite easy: just write the implementation of slots and point each slot to the corresponding implementation.</p><p> 对于我们的讨论，浮点算法并不那么重要。本示例演示如何指定静态定义的类型的行为。事实证明这很容易：只需编写插槽的实现并将每个插槽指向相应的实现即可。 </p><p> If you want to learn how to statically define your own types, check out  Python&#39;s tutorial for C/C++ programmers.</p><p>如果您想学习如何静态定义自己的类型，请查看C / C ++程序员的Python教程。</p><p>  Dynamically allocated types are the types we define using the  class statement. As we&#39;ve already said, they are instances of  PyTypeObject, just like statically defined types. Traditionally, we call them classes but we might call them user-defined types as well.</p><p>  动态分配的类型是我们使用class语句定义的类型。正如我们已经说过的那样，它们是PyTypeObject的实例，就像静态定义的类型一样。传统上，我们称它们为类，但也可以称它们为用户定义类型。</p><p> From the programmer&#39;s perspective, it&#39;s easier to define a class in Python than a type in C. This is because CPython does a lot of things behind the scenes when it creates a class. Let&#39;s see what&#39;s involved in this process.</p><p> 从程序员的角度来看，在Python中定义类比在C中定义类型要容易。这是因为CPython创建类时在幕后做了很多事情。让我们看看此过程涉及什么。</p><p>       Feel free to do that if you find the time, or read  the article on classes by Eli Bendersky. We&#39;ll take a shortcut.</p><p>       如果有时间，请随时进行操作，或者阅读Eli Bendersky上关于班级的文章。我们会走捷径。</p><p> An object is created by a call to a type, e.g.  list() or  MyClass(). A class is created by a call to a metatype. A metatype is just a type whose instances are types. Python has one built-in metatype called  PyType_Type, which is known to us simply as  type. Here&#39;s how it&#39;s defined:</p><p> 通过调用类型（例如）创建对象。 list（）或MyClass（）。通过调用元类型创建类。元类型只是实例是类型的类型。 Python具有一个称为PyType_Type的内置元类型，我们将其简称为type。定义方式如下：</p><p> PyTypeObject  PyType_Type  =  {  PyVarObject_HEAD_INIT ( &amp; PyType_Type ,  0 )  &#34;type&#34; ,  /* tp_name */  sizeof ( PyHeapTypeObject ),  /* tp_basicsize */  sizeof ( PyMemberDef ),  /* tp_itemsize */  ( destructor ) type_dealloc ,  /* tp_dealloc */  offsetof ( PyTypeObject ,  tp_vectorcall ),  /* tp_vectorcall_offset */  0 ,  /* tp_getattr */  0 ,  /* tp_setattr */  0 ,  /* tp_as_async */  ( reprfunc ) type_repr ,  /* tp_repr */  0 ,  /* tp_as_number */  0 ,  /* tp_as_sequence */  0 ,  /* tp_as_mapping */  0 ,  /* tp_hash */  ( ternaryfunc ) type_call ,  /* tp_call */  0 ,  /* tp_str */  ( getattrofunc ) type_getattro ,  /* tp_getattro */  ( setattrofunc ) type_setattro ,  /* tp_setattro */  0 ,  /* tp_as_buffer */  Py_TPFLAGS_DEFAULT  |  Py_TPFLAGS_HAVE_GC  |  Py_TPFLAGS_BASETYPE  |  Py_TPFLAGS_TYPE_SUBCLASS  |  Py_TPFLAGS_HAVE_VECTORCALL ,  /* tp_flags */  type_doc ,  /* tp_doc */  ( traverseproc ) type_traverse ,  /* tp_traverse */  ( inquiry ) type_clear ,  /* tp_clear */  0 ,  /* tp_richcompare */  offsetof ( PyTypeObject ,  tp_weaklist ),  /* tp_weaklistoffset */  0 ,  /* tp_iter */  0 ,  /* tp_iternext */  type_methods ,  /* tp_methods */  type_members ,  /* tp_members */  type_getsets ,  /* tp_getset */  0 ,  /* tp_base */  0 ,  /* tp_dict */  0 ,  /* tp_descr_get */  0 ,  /* tp_descr_set */  offsetof ( PyTypeObject ,  tp_dict ),  /* tp_dictoffset */  type_init ,  /* tp_init */  0 ,  /* tp_alloc */  type_new ,  /* tp_new */  PyObject_GC_Del ,  /* tp_free */  ( inquiry ) type_is_gc ,  /* tp_is_gc */ };</p><p> PyTypeObject PyType_Type = {PyVarObject_HEAD_INIT（＆amp; PyType_Type，0）＆＃34; type＆＃34; ，/ * tp_name * / sizeof（PyHeapTypeObject），/ * tp_basicsize * / sizeof（PyMemberDef），/ * tp_itemsize * /（destructor）type_dealloc，/ * tp_dealloc * / offsetof（PyTypeObject，tp_vectorcall），/ * tp_vectorcall / * tp_getattr * / 0，/ * tp_setattr * / 0，/ * tp_as_async * /（reprfunc）type_repr，/ * tp_repr * / 0，/ * tp_as_number * / 0，/ * tp_as_sequence * / 0，/ * tp_as_mapping * / 0，/ * tp_hash * /（ternaryfunc）type_call，/ * tp_call * / 0，/ * tp_str * /（getattrofunc）type_getattro，/ * tp_getattro * /（setattrofunc）type_setattro，/ * tp_setattro * / 0，/ * tp_buffer / Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS | Py_TPFLAGS_HAVE_VECTORCALL，/ * tp_flags * / type_doc，/ * tp_doc * /（traverseproc）type_traverse，/ * tp_traverse * /（查询）type_clear，/ * tp_clear * / 0，/ * tp_richcompare * / offsetof_（PyTypelist，t * ak） tp_weaklistoffset * / 0，/ * tp_iter * / 0，/ * tp_iternext * / type_methods，/ * tp_methods * / type_members，/ * tp_members * / type_getsets，/ * tp_getset * / 0，/ * tp_base * / 0，/ * tp_dict * / 0，/ * tp_descr_get * / 0，/ * tp_descr_set * / offsetof（PyTypeObject，tp_dict），/ * tp_dictoffset * / type_init，/ * tp_init * / 0，/ * tp_alloc * / type_new，/ * tp_new * / PyObject_GC_Del ，/ * tp_free * /（查询）type_is_gc，/ * tp_is_gc * /};</p><p> The type of all built-in types is  type, and the type of all classes defaults to  type. So,  type determines how types behave. For example, what happens when we call a type, like  list() or  MyClass(), is specified by the  tp_call slot of  type. The implementation of the  tp_ca</p><p> 所有内置类型的类型均为type，所有类的类型默认为type。因此，类型决定了类型的行为。例如，当我们调用诸如list（）或MyClass（）之类的类型时，将通过类型的tp_call插槽指定发生什么。 tp_ca的执行 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tenthousandmeters.com/blog/python-behind-the-scenes-6-how-python-object-system-works/">https://tenthousandmeters.com/blog/python-behind-the-scenes-6-how-python-object-system-works/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/object/">#object</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tp/">#tp</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1038084.html"><img src="http://img2.diglog.com/img/2020/12/thumb_69ef48daa734671d855c895143ac5bf2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038084.html">Python金融存量分析[YouTube] </a></div><span class="my_story_list_date">2020-12-7 0:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038059.html"><img src="http://img2.diglog.com/img/2020/12/thumb_977df6d26a6381e3ca831650b8902e09.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038059.html">Skybolt：具有Python绑定的C ++行星环境渲染引擎 </a></div><span class="my_story_list_date">2020-12-6 20:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037975.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b1990a980bc067dad1651281b534e083.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037975.html">具有Python WebSocket的高通量游戏消息服务器 </a></div><span class="my_story_list_date">2020-12-6 7:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037949.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5af4351444b5b1b417f41614f907d30f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037949.html">Python在新的GitHub年度报告中再次击败Java </a></div><span class="my_story_list_date">2020-12-6 2:41</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>