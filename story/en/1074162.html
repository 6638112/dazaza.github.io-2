<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对自动推理的温和介绍A gentle introduction to automated reasoning</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A gentle introduction to automated reasoning<br/>对自动推理的温和介绍</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 10:59:10</div><div class="page_narrow text-break page_content"><p>This week, Amazon Science added  automated reasoning to its list of  research areas. We made this change because of the impact that automated reasoning is having here at Amazon. For example, Amazon Web Services’ customers now have direct access to automated-reasoning-based features such as  IAM Access Analyzer,  S3 Block Public Access, or  VPC Reachability Analyzer. We also see Amazon development teams  integrating automated-reasoning tools into their development processes, raising the bar on the  security,  durability, availability, and quality of our products.</p><p>本周，亚马逊科学公司在其研究领域列表中增加了自动推理。我们之所以做出这样的改变，是因为自动化推理在亚马逊的影响力。例如，Amazon Web Services的客户现在可以直接访问基于自动推理的功能，如IAM access Analyzer、S3 Block Public access或VPC可达性分析器。我们还看到亚马逊开发团队将自动推理工具集成到他们的开发过程中，提高了我们产品的安全性、耐用性、可用性和质量。</p><p> The goal of this article is to provide a gentle introduction to automated reasoning for the industry professional who knows nothing about the area but is curious to learn more. All you will need to make sense of this article is to be able to read a few small C and Python code fragments. I will refer to a few specialist concepts along the way, but only with the goal of introducing them in an informal manner. I close with links to some of our favorite publicly available tools, videos, books, and articles for those looking to go more in-depth.</p><p>本文的目的是为对该领域一无所知但又好奇了解更多的行业专业人士提供一个关于自动推理的温和介绍。理解本文所需要的只是能够阅读一些小的C和Python代码片段。在此过程中，我将提及一些专业概念，但目的只是以非正式的方式介绍它们。最后，我提供了一些我们最喜欢的公开工具、视频、书籍和文章的链接，供那些希望深入了解的人使用。</p><p>   Take a few moments to answer the question  “Could f  ever return false?” This is not a trick question: I’ve purposefully used a simple example to make a point.</p><p>花点时间回答“f是否会返回false？”这不是一个骗人的问题：我特意用一个简单的例子来说明问题。</p><p> To check the answer with exhaustive testing, we could try executing the following doubly nested test loop, which calls  f on all possible pairs of values of the type unsigned int:</p><p>为了通过穷举测试来检查答案，我们可以尝试执行以下双嵌套测试循环，该循环对unsigned int类型的所有可能的值对调用f：</p><p> #include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;limits.h&gt;bool f(unsigned int x, unsigned int y) { return (x+y == y+x);}void main() { for (unsigned int x=0;1;x++) { for (unsigned int y=0;1;y++) { if (!f(x,y)) printf(&#34;Error!\n&#34;); if (y==UINT_MAX) break; } if (x==UINT_MAX) break; }}</p><p>#包括&lt；斯特迪奥。h&gt；</p><p> Unfortunately, even on modern hardware, this doubly nested loop will run for a  very long time. I compiled it and ran it on a 2.6 GHz Intel processor for over 48 hours before giving up.</p><p>不幸的是，即使在现代硬件上，这种双重嵌套循环也会运行很长时间。我编译了它，并在2.6GHz的英特尔处理器上运行了48个多小时才放弃。</p><p> Why does testing take so long? Because UINT_MAX is typically 4,294,967,295, there are 18,446,744,065,119,617,025 separate  f calls to consider. On my 2.6 GHz machine, the compiled test loop called  f approximately 430 million times a second. But to test all 18 quintillion cases at this performance, we would need over 1,360 years.</p><p>为什么测试需要这么长时间？因为UntIX MAX通常为4294967295，所以要考虑的是1844 6740401196196025单独的F调用。在我的2.6GHz机器上，编译的测试循环每秒调用f大约4.3亿次。但要在这种情况下测试所有18个五分之一的病例，我们需要1360多年的时间。</p><p> When we show the above code to industry professionals, they almost immediately work out that  f can&#39;t return false as long as the underlying compiler/interpreter and hardware are correct. How do they do that? They  reason about it. They remember from their school days that  x + y can be rewritten as  y + x and conclude that  f always returns true.</p><p>当我们向行业专业人士展示上述代码时，他们几乎立即得出f可以&#39；只要底层编译器/解释器和硬件正确，就不能返回false。他们是怎么做到的？他们对此进行了推理。他们从上学时就记得x+y可以改写为y+x，并得出f总是返回真的结论。</p><p>  An  automated reasoning tool does this work for us: it attempts  to answer questions about a program (or a logic formula) by using known techniques from mathematics. In this case, the tool would use algebra to deduce that  x + y == y + x can be replaced with the simple expression true.</p><p>自动推理工具为我们做这项工作：它试图通过使用已知的数学技术来回答有关程序（或逻辑公式）的问题。在这种情况下，该工具将使用代数来推断x+y==y+x可以替换为简单的表达式true。</p><p> Automated-reasoning tools can be incredibly fast, even when the domains are infinite (e.g., unbounded mathematical integers rather than finite C ints). Unfortunately, the tools may answer  “Don’t know” in some instances. We&#39;ll see a famous example of that below.</p><p>即使域是无限的（例如，无界的数学整数而不是有限的整数），自动推理工具也可以非常快。不幸的是，在某些情况下，这些工具可能会回答“不知道”。我们&#39；我将在下面看到一个著名的例子。</p><p> The  science of automated reasoning is essentially focused on driving the frequency of these  “Don’t know” answers down as far as possible: the less often the tools report  &#34;Don&#39;t know&#34; (or time out while trying), the more useful they are.</p><p>自动推理的科学本质上专注于尽可能降低这些“不知道”答案的频率：工具报告的频率越低&#34；唐&#39；我不知道&#34；（或尝试时暂停），它们就越有用。</p><p> Today’s tools are able to give answers for programs and queries where yesterday’s tools could not. Tomorrow’s tools will be even more powerful. We are seeing rapid progress in this field, which is why at Amazon, we are increasingly getting so much value from it. In fact, we see automated reasoning forming its own Amazon-style virtuous cycle, where more input problems to our tools drive improvements to the tools, which encourages more use of the tools.</p><p>今天的工具能够为昨天的工具无法回答的程序和查询提供答案。明天的工具将更加强大。我们看到了这个领域的快速发展，这就是为什么在亚马逊，我们从中获得了越来越多的价值。事实上，我们看到自动推理形成了亚马逊式的良性循环，在这种循环中，更多的工具输入问题推动了工具的改进，从而鼓励更多地使用工具。</p><p> A slightly more complex example. Now that we know the rough outlines of what automated reasoning is, the next small example gives a slightly more realistic taste of the sort of complexity that the tools are managing for us.</p><p>一个稍微复杂一点的例子。现在我们已经大致了解了什么是自动推理，接下来的一个小例子让我们更真实地感受到了这些工具为我们管理的那种复杂性。</p><p> void g(int x, int y) { if (y &gt; 0) while (x &gt; y) x = x - y;}</p><p>空g（整数x，整数y）{</p><p>  def g(x, y): assert isinstance(x, int) and isinstance(y, int) if y &gt; 0: while x &gt; y: x = x - y</p><p>def g（x，y）：</p><p> Try to answer this question:  “Does g  always eventually return control back to its caller?”</p><p>试着回答这个问题：“g是否总是最终将控制权返回给它的调用者？”</p><p> When we show this program to industry professionals, they usually figure out the right answer quickly. A few, especially those who are aware of results in theoretical computer science, sometimes mistakenly think that we can&#39;t answer this question, with the rationale  “This is an example of the  halting problem , which has been proved insoluble”. In fact, we  can reason about the halting behavior for  specific programs, including this one. We’ll talk more about that later.</p><p>当我们向行业专业人士展示这个程序时，他们通常会很快找到正确的答案。一些人，尤其是那些了解理论计算机科学成果的人，有时会错误地认为我们可以&#39；我不能回答这个问题，理由是“这是一个停顿问题的例子，已经被证明是无法解决的”。事实上，我们可以对特定程序的停止行为进行推理，包括这一个。稍后我们将进一步讨论这个问题。</p><p> Here’s the reasoning that most industry professionals use when looking at this problem:</p><p>以下是大多数行业专业人士在研究这个问题时使用的推理：</p><p> In the case where  y is not positive, execution jumps to the end of the function  g. That’s the easy case.</p><p>在y不是正的情况下，执行跳到函数g的末尾。这是一个简单的情况。</p><p> If, in every iteration of the loop, the value of the variable  x decreases, then eventually, the loop condition  x &gt;  y will fail, and the end of  g will be reached.</p><p>如果在循环的每次迭代中，变量x的值减小，那么最终，循环条件x&gt；y将失败，g的末端将到达。</p><p> The value of  x always decreases only if  y is always positive, because only then does the update to x (i.e.,  x =  x -  y) decrease  x. But  y’s positivity is established by the conditional expression, so  x always decreases.</p><p>只有当y始终为正时，x的值才会减小，因为只有这样，对x的更新（即x=x-y）才会减小x。但是y的正性是由条件表达式确定的，因此x始终减小。</p><p> The experienced programmer will usually worry about underflow in the  x =  x -  y command of the C program but will then notice that  x &gt;  y before the update to  x and thus cannot underflow.</p><p>有经验的程序员通常会担心C程序的x=x-y命令中的下溢，但随后会注意到x&gt；在更新到x之前为y，因此不能下溢。</p><p> If you carried out the three steps above yourself, you now have a very intuitive view of the type of thinking an automated-reasoning tool is performing on our behalf when reasoning about a computer program. There are many nitty-gritty details that the tools have to face (e.g., heaps, stacks, strings, pointer arithmetic, recursion, concurrency, callbacks, etc.), but there’s also decades of research papers on techniques for handling these and other topics, along with various practical tools that put these ideas to work.</p><p>如果你执行了以上三个步骤，你现在可以非常直观地看到自动推理工具在对计算机程序进行推理时代表我们执行的思维类型。这些工具必须面对许多细节（例如，堆、堆栈、字符串、指针算法、递归、并发、回调等），但也有几十年的研究论文涉及处理这些和其他主题的技术，以及各种实用工具，将这些想法付诸实施。</p><p>  The main takeaway is that automated-reasoning tools are usually working through the three steps above on our behalf: Item 1 is reasoning about the program’s  control structure. Item 2 is reasoning about what is  eventually true within the program. Item 3 is reasoning about what is  always true in the program.</p><p>主要的收获是，自动推理工具通常代表我们完成上述三个步骤：第1项是关于程序控制结构的推理。第2项是关于程序中最终正确的内容的推理。第3项是关于程序中什么总是正确的推理。</p><p> Note that configuration artifacts such as AWS resource policies, VPC network descriptions, or even makefiles can be thought of as code. This viewpoint allows us to use the same techniques we use to reason about C or Python code to answer questions about the  interpretation of configurations. It’s this insight that gives us tools like IAM Access Analyzer or VPC Reachability Analyzer.</p><p>请注意，AWS资源策略、VPC网络描述甚至makefiles等配置工件都可以被视为代码。这种观点允许我们使用我们用来推理C或Python代码的相同技术来回答有关配置解释的问题。正是这种见解为我们提供了IAM访问分析器或VPC可达性分析器等工具。</p><p>   As we saw above when looking at  f and  g, automated reasoning can be dramatically faster than exhaustive testing. With tools available today, we can show properties of  f or  g in milliseconds, rather than waiting lifetimes with exhaustive testing.</p><p>正如我们在上面研究f和g时所看到的，自动推理可以比穷举测试快得多。有了今天可用的工具，我们可以以毫秒为单位显示f或g的属性，而不是通过穷举测试来等待生命周期。</p><p> Can we throw away our testing tools now and just move to automated reasoning? Not quite. Yes, we can dramatically reduce our dependency on testing, but we will not be completely eliminating it any time soon, if ever. Consider our first example:</p><p>我们现在能抛弃我们的测试工具，转向自动推理吗？不完全是。是的，我们可以大大减少对测试的依赖，但我们不会很快完全消除它，如果有的话。考虑我们的第一个例子：</p><p> bool f(unsigned int x, unsigned int y) { return (x + y == y + x);}</p><p>bool f（无符号整数x，无符号整数y）{</p><p> Recall the worry that a buggy compiler or microprocessor could in fact cause an executable program constructed from this source code to return false. We might also need to worry about the language runtime. For example, the C math library or the Python garbage collector might have bugs that cause a program to misbehave.</p><p>回想一下，一个有缺陷的编译器或微处理器实际上可能会导致由该源代码构造的可执行程序返回false。我们可能还需要担心语言运行时。例如，C数学库或Python垃圾收集器可能存在导致程序行为异常的错误。</p><p> What’s interesting about testing, and something we often forget, is that it’s doing much more than just telling us about the C or Python source code. It’s also testing the compiler, the runtime, the interpreter, the microprocessor, etc. A test failure could be rooted in any of those tools in the stack.</p><p>关于测试，我们经常忘记的一点是，它所做的远不止是告诉我们C或Python源代码。它还测试编译器、运行时、解释器、微处理器等。测试失败可能源于堆栈中的任何工具。</p><p> Automated reasoning, in contrast, is usually applied to just one layer of that stack — the source code itself, or sometimes the compiler or the microprocessor. What we find so valuable about reasoning is it allows us to clearly define both what we  do know and what we  do not know about the layer under inspection.</p><p>相比之下，自动推理通常只适用于堆栈的一层——源代码本身，有时也适用于编译器或微处理器。我们发现，推理的价值在于，它可以让我们清楚地定义我们知道的和不知道的关于被检查层的信息。</p><p> Furthermore, the models of the surrounding environment (e.g., the compiler or the procedure calling our procedure) used by the automated-reasoning tool make our assumptions  very precise. Separating the layers of the computational stack helps make better use of our time, energy, and money and the capabilities of the tools today and tomorrow.</p><p>此外，自动推理工具使用的周围环境模型（例如，编译器或调用我们的过程的过程）使我们的假设非常精确。分离计算堆栈的各个层有助于更好地利用我们的时间、精力、金钱以及今天和明天工具的功能。</p><p> Unfortunately, we will almost always need to make assumptions about  something when using  automated reasoning — for example, the principles of physics that govern our silicon chips. Thus, testing will never be fully replaced. We will want to perform end-to-end testing to try and validate our assumptions as best we can.</p><p>不幸的是，在使用自动推理时，我们几乎总是需要对某些事情做出假设——例如，控制我们的硅芯片的物理原理。因此，测试永远不会被完全取代。我们希望进行端到端测试，尽可能地验证我们的假设。</p><p>    I previously mentioned that automated-reasoning tools sometimes return  “Don’t know” rather than  “yes” or  “no”. They also sometimes run forever (or time out), thus never returning an answer. Let’s look at the famous &#34;halting problem&#34; program, in which we know tools  cannot return  “yes” or  “no”.</p><p>我之前提到过，自动推理工具有时会返回“不知道”，而不是“是”或“否”。它们有时也会永远运行（或超时），因此永远不会返回答案。让我们看看著名的&#34；停顿问题&#34；程序中，我们知道工具不能返回“是”或“否”。</p><p> Imagine that we have an automated-reasoning API, called  terminates, that returns  “yes” if a C function always terminates or  “no” when the function could execute forever. As an example, we could build such an API using the tool described  here (shameless self-promotion of author’s previous work). To get the idea of what a termination tool can do for us, consider two basic C functions,  g (from above),</p><p>假设我们有一个名为terminates的自动推理API，如果一个C函数总是终止，它会返回“是”，如果该函数可以永远执行，它会返回“否”。例如，我们可以使用这里描述的工具（作者之前工作的无耻自我推广）构建这样一个API。为了了解终止工具能为我们做什么，考虑两个基本的C函数，g（来自上面），</p><p> void g(int x, int y) { if (y &gt; 0) while (x &gt; y) x = x - y;}</p><p>空g（整数x，整数y）{</p><p>  void g2(int x, int y) { while (x &gt; y) x = x - y;}</p><p>空g2（整数x，整数y）{</p><p> For the reasons we have already discussed, the function  g always returns control back to its caller, so  terminates(g) should return true. Meanwhile,  terminates(g2) should return false because, for example,  g2(5, 0) will never terminate.</p><p>由于我们已经讨论过的原因，函数g总是将控制返回给它的调用者，因此终止（g）应该返回true。同时，terminates（g2）应该返回false，因为例如，g2（5，0）永远不会终止。</p><p>   Notice that it&#39;s recursive. What’s the right answer for  terminates(h)? The answer cannot be &#34;yes&#34;. It also cannot be &#34;no&#34;. Why?</p><p>注意它&#39；这是递归的。什么是终止（h）的正确答案？答案不可能是&#34；是的；。它也不能是&#34；没有；。为什么？</p><p> Imagine that  terminates(h) were to return &#34;yes&#34;. If you read the code of  h, you’ll see that in this case, the function does not terminate because of the conditional statement in the code of  h that will execute the infinite loop  while(1){}. Thus, in this case, the  terminates(h) answer would be wrong, because  h is defined recursively, calling terminates on itself.</p><p>想象一下（h）将返回&#34；是的；。如果你读h的代码，你会发现在这种情况下，函数不会因为h代码中的条件语句而终止，它将在（1）{}时执行无限循环。因此，在这种情况下，terminates（h）答案是错误的，因为h是递归定义的，调用terminates本身。</p><p> Similarly, if  terminates(h) were to return &#34;no&#34;, then  h would in fact terminate and return control to its caller, because the  if case of the conditional statement is not met, and there is no else branch. Again, the answer would be wrong. This is why the  “Don’t know” answer is actually unavoidable in this case.</p><p>同样，如果终止（h）返回&#34；没有&#34；，然后h实际上会终止并将控制权返回给它的调用者，因为条件语句的if情况不满足，并且没有else分支。同样，答案是错误的。这就是为什么在这种情况下，“不知道”的答案实际上是不可避免的。</p><p> The program  h is a variation of examples given in Turing’s  famous 1936 paper on decidability and  Gödel’s incompleteness theorems from 1931. These papers tell us that problems like the halting problem cannot be “solved”, if by “solved ” we mean that the solution procedure itself always terminates and answers either  “yes” or  “no” but never  “Don’t know”. But that is not the definition of “solved” that many of us have in mind. For many of us, a tool that sometimes times out or occasionally returns  “Don’t know” but, when it gives an answer, always gives the right answer is good enough.</p><p>程序h是图灵1936年关于可判定性和1931年哥德尔不完全性定理的著名论文中给出的例子的变体。这些论文告诉我们，像停顿问题这样的问题是无法“解决”的，如果“解决”是指解决过程本身总是终止，回答“是”或“否”，但永远不回答“不知道”。但这并不是我们许多人心目中“已解决”的定义。对于我们中的许多人来说，一个工具有时会超时或偶尔返回“不知道”，但当它给出答案时，总是给出正确的答案就足够了。</p><p> This problem is analogous to airline travel: we know it’s not 100% safe, because crashes have happened in the past, and we are sure that they will happen in the future. But when you land safely, you  know it worked that time. The goal of the airline industry is to reduce failure as much as possible, even though it’s in principle unavoidable.</p><p>这个问题类似于航空旅行：我们知道它不是100%安全的，因为坠机事故在过去发生过，我们确信它们在未来也会发生。但当你安全着陆时，你知道那次它起了作用。航空业的目标是尽可能减少失败，尽管原则上这是不可避免的。</p><p> To put that in the context of automated reasoning: for some programs, like  h, we can never improve the tool enough to replace the  &#34;Don&#39;t know&#34; answer. But there are many other cases where today&#39;s tools answer  &#34;Don&#39;t know&#34;, but future tools may be able to answer  &#34;yes&#34; or  &#34;no&#34;. The modern scientific challenge for automated-reasoning subject-matter experts is to get the practical tools to return  “yes” or  “no” as often as possible. As an example of current work, check out CMU professor and  Amazon scholar  Marijn Heule and his  quest to solve the Collatz termination problem.</p><p>把它放在自动推理的背景下：对于一些程序，比如h，我们永远无法对工具进行足够的改进，以取代&#34；唐&#39；我不知道&#34；答复但今天还有许多其他情况&#39；s工具回答&#34；唐&#39；我不知道&#34；，但未来的工具可能能够回答#34；是的&#34；或&#34；没有；。自动推理主题专家面临的现代科学挑战是让实用工具尽可能多地返回“是”或“否”。作为当前工作的一个例子，请查看CMU教授和亚马逊学者Marijn Heule，以及他对解决Collatz终止问题的探索。</p><p> Another thing to keep in mind is that automated-reasoning tools are regularly trying to solve “intractable” problems, e.g. , problems in the  NP complexity class. Here, the same thinking applies that we saw in the case of the halting problem: automated-reasoning tools have powerful heuristics that often work around the intractability problem for specific cases, but those heuristics can (and sometimes do) fail, resulting in  “Don’t know” answers or impractically long execution time. The science is to improve the heuristics to minimize that problem.</p><p>另一件需要记住的事情是，自动推理工具经常试图解决“棘手”的问题，例如NP复杂性类中的问题。在这里，与我们在暂停问题中看到的想法相同：自动推理工具具有强大的启发式算法，通常可以解决特定情况下的棘手问题，但这些启发式算法可能（有时确实）失败，导致“不知道”答案或执行时间过长。科学的目标是改进启发式算法，以最小化这个问题。</p><p>   A host of names are used in the scientific literature to describe interrelated topics, of which automated reasoning is just one. Here’s a quick glossary:</p><p>科学文献中使用了大量名称来描述相关主题，而自动推理只是其中之一。下面是一个快速词汇表：</p><p> A  logic is a formal and mechanical system for defining what is true and untrue. Examples:  propositional logic or  first-order logic.</p><p>逻辑是一个正式的、机械的系统，用来定义什么是真的，什么是假的。例子：命题逻辑或一阶逻辑。</p><p>  A  proof is a valid argument in logic of a theorem. Example: Gonthier&#39;s  proof of the four-color theorem.</p><p>证明是定理逻辑中的有效论点。例如：Gonthier和#39；这是四色定理的证明。</p><p> A  mechanical theorem prover is a semi-automated-reasoning tool that checks a machine-readable expression of a proof often written down by a human. These tools often require human guidance. Example:  HOL-light, from Amazon researcher  John Harrison.</p><p>机械定理证明器是一种半自动推理工具，用于检查通常由人写下的证明的机器可读表达式。这些工具通常需要人工指导。例子：来自亚马逊研究员约翰·哈里森的霍尔·莱特。</p><p> Formal verification is the use of theorem proving when applied to models of computer systems to prove desired properties of the systems. Example: the  CompCert verified C compiler.</p><p>形式验证是将定理证明应用于计算机系统模型，以证明系统的期望属性。示例：CompCert验证了C编译器。</p><p> Formal methods is the broadest term, meaning simply the use of logic to reason formally about models of systems.</p><p>形式化方法是最广泛的术语，简单地说就是使用逻辑对系统模型进行形式化推理。</p><p>  A  semi-automated-reasoning tool is one that requires hints from the user but still finds valid proofs in logic.</p><p>半自动推理工具需要用户提供提示，但仍能在逻辑上找到有效的证据。</p><p> As you can see, we have a choice of monikers when working in this space. At Amazon, we’ve chosen to use automated reasoning, as we think it best captures our ambition for automation and scale. In practice, some of our internal teams use both automated and  semi-automated reasoning tools, because the scientists we&#39;ve hired can often get semi-automated reasoning tools to succeed where the heuristics in fully automated reasoning might fail. For our externally facing customer features, we currently use only fully automated approaches.</p><p>正如你所见，在这个空间工作时，我们可以选择名字。在亚马逊，我们选择使用自动推理，因为我们认为它最能体现我们对自动化和规模的雄心。在实践中，我们的一些内部团队同时使用自动和半自动推理工具，因为我们的科学家&#39；在全自动推理中的启发式可能失败的情况下，我们通常可以获得半自动推理工具。对于我们面向外部的客户功能，我们目前只使用完全自动化的方法。</p><p>   In this essay, I’ve introduced the idea of automated reasoning, with the smallest of toy programs. I haven’t described how to handle realistic programs, with heap or concurrency. In fact, there are a wide variety of automated-reasoning tools and techniques, solving problems in all kinds of different domains, some of them quite narrow. To describe them all and the many branches and sub-disciplines of the field (e.g. “SMT solving”, “higher-order logic theorem proving”, “separation logic”) would take thousands of blogs posts and books.</p><p>在这篇文章中，我介绍了自动推理的概念，使用最小的玩具程序。我还没有描述如何处理具有堆或并发性的实际程序。事实上，有各种各样的自动推理工具和技术，用于解决各种不同领域的问题，其中一些领域相当狭窄。要描述它们以及该领域的许多分支和子学科（如“SMT求解”、“高阶逻辑定理证明”、“分离逻辑”），需要数千篇博客文章和书籍。</p><p> Automated reasoning goes back to the early inventors of computers. And logic itself (which automated reasoning attempts to solve) is thousands of years old. In order to keep this post brief, I’ll stop here and suggest further reading. Note that it’s very easy to get lost in the weeds reading depth-first into this area, and you could emerge more confused than when you started. I encourage you to use a bounded depth-first search approach, looking sequentially at a wide variety of tools and techniques in only some detail and then moving on, rather than learning only one aspect deeply.</p><p>自动推理可以追溯到计算机的早期发明者。逻辑本身（自动推理试图解决的问题）已有数千年的历史。为了使这篇文章简短，我将在这里停下来，并建议进一步阅读。请注意，首先进入这个区域很容易迷失在杂草阅读深度中，你可能会比开始时更加困惑。我鼓励你使用有限的深度优先搜索方法，只在一些细节中顺序查看各种工具和技术，然后继续，而不是只深入学习一个方面。</p><p>                  Automating Compliance Verification on AWS Using Provable Security, lecture with AWS VP of compliance Chad Woolf, and compliance auditor Coalfire&#39;s CEO Tom McAndrew</p><p>使用可证明安全性自动化AWS合规性验证，与AWS合规副总裁查德·伍尔夫和合规审计员Coalfire#39进行讲座；公司首席执行官汤姆·麦坎德罗</p><p>   The Evolution of automated reasoning Technology at AWS, lecture with AWS VP of security Eric Brandwine</p><p>AWS自动推理技术的发展，与AWS安全副总裁埃里克·布兰德温（Eric Brandwine）一起演讲</p><p> Lecture by AWS CISO and VP of security Steve Schmidt about on the development and use of formal/constraint-based tools in AWS</p><p>AWS CISO和安全副总裁Steve Schmidt关于AWS中基于形式/约束的工具的开发和使用的讲座</p><p>            Some algorithms found in the automated theorem provers we use today date as far back as 1959, when  Hao Wang used automated reasoning to prove the theorems from  Principia Mathematica.</p><p>我们今天使用的自动定理证明器中发现的一些算法可以追溯到1959年，当时王浩使用自动推理来证明《数学原理》中的定理。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/自动/">#自动</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/工具/">#工具</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>