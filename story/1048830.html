<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go服务器中HTTP请求的生存期（2017） </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Go服务器中HTTP请求的生存期（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-22 01:06:35</div><div class="page_narrow text-break page_content"><p>Go是编写HTTP服务器的通用且非常适合的工具。本文讨论了典型的HTTP请求通过Go服务器，touchupon路由器，中间件和其他相关问题（如并发性）所经过的路由。</p><p> 要查看一些具体代码，让我们从这个琐碎的服务器（摘自https://gobyexample.com/http-servers）开始：</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; net / http＆＃34;）func hello（w http。ResponseWriter，req * http.Request）{fmt。 Fprintf（w，＆＃34; hello \ n＆＃34;）} func头文件（w http。ResponseWriter，req * http。Request）{对于名称，头文件：= range req。标头{表示_，h：=范围标头{fmt。 Fprintf（w，＆＃34;％v：％v \ n＆＃34;，name，h）}}} func main（）{http。 HandleFunc（＆＃34; / hello＆＃34;，你好）http。 HandleFunc（＆＃34; / headers＆＃34;，标头）http。 ListenAndServe（＆＃34;：8090＆＃34;，nil）}</p><p> 我们将通过查看http.ListenAndServe函数开始通过该服务器跟踪HTTP请求的生命周期：</p><p>  下图显示了调用过程的简化流程：</p><p>  这是一个非常内联的＆＃34;函数和方法调用的实际序列的版本，但是原始代码不太难遵循。</p><p> 主要流程几乎是您所期望的：ListenAndServe在TCP端口上侦听给定的地址，然后循环接受新的连接。对于每个新的连接，它会旋转一个goroutine来为其服务（稍后会详细介绍）。连接涉及以下循环： </p><p>在我们的示例代码中，使用nil作为第二个参数调用ListenAndServe，它应该是用户定义的处理程序。这是怎么回事？</p><p> 我们的图简化了一些细节。实际上，当HTTP包提供arequest时，它不会直接调用用户的处理程序，而是使用此适配器：</p><p> 类型serverHandler struct {srv * Server} func（sh serverHandler）ServeHTTP（rw ResponseWriter，req * Request）{handler：= sh。 srv。如果处理程序==零，则处理程序{处理程序= DefaultServeMux}如果需要。 RequestURI ==＆＃34; *＆＃34; ＆amp;＆amp;要求方法==＆＃34;选项＆＃34; {handler = globalOptionsHandler {}}处理程序。服务HTTP（rw，req）}</p><p> 请注意突出显示的行：如果handler == nil，则将http.DefaultServeMuxis用作处理程序。这是默认的服务器多路复用器-http包中保存的http.ServeMux类型的全局实例。顺便说一句，当我们的示例代码向http.HandleFunc注册处理程序时，它将为其注册这个非常相同的默认多路复用器。</p><p> 我们可以按以下方式重写示例服务器，而无需使用默认的mux。仅主要功能发生了变化，因此我不会显示hello和headers处理程序，但是您可以在此处看到完整的代码。功能更改[1]：</p><p> 在阅读大量Go服务器示例时，很容易相信ListenAndServe会使用多路复用器。作为论点，但这并不精确。如上所述，ListenAndServe所采用的是实现http.Handler接口的值。我们可以编写以下没有任何复用的服务器：</p><p> 键入PoliteServer struct {} func（ms * PoliteServer）ServeHTTP（w http。ResponseWriter，req * http。Request）{fmt。 Fprintf（w，＆＃34;欢迎光临！\ n＆＃34;）} func main（）{ps：=＆amp; PoliteServer {}日志。致命（http。ListenAndServe（＆＃34;：8090＆＃34;，ps））} </p><p>这里没有路由；所有HTTP请求都转到PoliteServer的ServeHTTP方法，并且对所有请求都返回相同的消息。尝试使用不同的路径和方法来卷曲服务器。如果不一致，那什么也没有。</p><p>  func politeGreeting（w http.ResponseWriter，req * http.Request） Fprintf（w，＆＃34; Welcome！感谢您的光临！\ n＆＃34;）} func main（）{log。致命（http。ListenAndServe（＆＃34;：8090＆＃34;，http。HandlerFunc（politeGreeting）））}</p><p>  // HandlerFunc类型是一个适配器，允许将//普通函数用作HTTP处理程序。如果f是具有适当签名的函数//，则HandlerFunc（f）是//调用f的处理程序。类型HandlerFunc func（ResponseWriter，* Request）// ServeHTTP调用f（w，r）。 func（f HandlerFunc）ServeHTTP（w ResponseWriter，r * Request）{f（w，r）}</p><p> 如果您在文章[2]的第一个示例中注意到http.HandleFunc，它将对具有HandlerFunc签名的函数使用相同的适配器。</p><p> 就像PoliteServer一样，http.ServeMux是实现http.Handler接口的类型。如果您喜欢，则可以仔细阅读其完整代码。这是一个大纲：</p><p>  这样，多路复用器可以看作是转发处理程序；这种模式在HTTP服务器编程中极为常见。这是中间件。</p><p> 很难精确定义中间件，因为中间件在不同的上下文，语言和框架中意味着稍有不同。 </p><p>让我们从这篇文章的开头看一下流程图，并简化一点，隐藏http包的详细信息：</p><p>    在Go中，中间件只是包装了不同处理程序的另一个HTTP处理程序。中间件处理程序注册为由ListenAndServe调用；当被调用时，它可以执行任意预处理，调用包装器处理程序，然后进行任意后处理。</p><p> 我们已经在上面看到了一个中间件示例-http.ServeMux;在这种情况下，预处理将根据请求的路径选择要调用的正确用户处理程序。没有后处理。</p><p> 再举一个具体的例子，让我们重新访问礼貌的服务器并添加一些基本的日志记录中间件。该中间件记录每个请求的详细信息，包括执行多长时间：</p><p> 键入LoggingMiddleware struct {处理程序http。处理程序} func（lm * LoggingMiddleware）ServeHTTP（w http.ResponseWriter，req * http.Request）{开始：=时间。 Now（）lm。处理程序。服务HTTP（w，req）日志。 Printf（＆＃34;％s％s％s＆＃34 ;，要求方法，要求RequestURI，时间。自（开始））}类型PoliteServer struct {} func（ms * PoliteServer）ServeHTTP（w http。ResponseWriter， req * http。Request）{fmt Fprintf（w，＆＃34;欢迎光临！\ n＆＃34;）} func main（）{ps：=＆amp; PoliteServer {} lm：=＆amp; LoggingMiddleware {handler：ps}日志。致命（http。ListenAndServe（＆＃34;：8090＆＃34;，lm））}</p><p> 请注意，LoggingMiddleware本身就是一个http.Handler，将userhandler保留为一个字段。当ListenAndServe调用其ServeHTTP方法时，它会执行以下操作：</p><p>  中间件的伟大之处在于它是可组合的。中间件包装的＆＃34;用户处理程序可以是另一个中间件，依此类推。它是一串互相包装的http.Handler值。实际上，这是Go中常见的模式，它使我们了解Go中间件的典型外观。这再次是我们的loggingpolite服务器，具有更易于识别的Go中间件实现： </p><p>func politeGreeting（w http.ResponseWriter，req * http.Request） Fprintf（w，＆＃34; Welcome！感谢您的光临！\ n＆＃34;）} func loggingMiddleware（下一个http。Handler）http。处理程序{返回http。 HandlerFunc（func（w http。ResponseWriter，req * http。Request）{start：= time。Now（）next。ServeHTTP（w，req）log。Printf（＆＃34;％s％s％s＆＃34;， req。方法，req.RequestURI，时间，自（start））}}}} func main（）{lm：= loggingMiddleware（http.HandlerFunc（politeGreeting））日志。致命（http。ListenAndServe（＆＃34;：8090＆＃34;，lm））}</p><p> loggingMiddleware并未使用方法创建结构，而是利用http.HandlerFunc与闭包相结合来使代码更加简洁，同时保留相同的功能。更重要的是，这演示了中间件的事实上的标准签名：该函数采用http.Handler（有时带有其他状态）并返回不同的http.Handler。现在应该使用返回的处理程序代替传递到中间件的处理程序，并且将“神奇地”使用。执行包含中间件功能的原始功能。</p><p>        在这两行之后，处理程序将安装超时和日志记录。您可能会注意到，中间件的长链编写起来可能很繁琐。 Go有许多受欢迎的软件包可以解决此问题，但这超出了本文的范围。</p><p> 顺便说一下，即使http包也可以在内部使用中间件来满足其需求;例如，参见本文前面描述的serverHandler适配器，它提供了一种干净的方法来以默认方式处理nil用户处理程序（将请求传递给默认的mux） 。</p><p> 我希望这可以弄清楚中间件为什么是有吸引力的设计辅助工具。我们可以根据业务逻辑进行工作处理程序，而我们完全采用正交的中间件，可以通过多种方式增强处理程序。不过，我将在这里继续探讨其他职位的可能性。</p><p> 为了完成对GoHTTP服务器中HTTP请求通过的内容的探索，让我们介绍另外两个主题：并发和紧急处理。</p><p> 首先，并发。如上文所述，http.Server.Serve在新的goroutine中处理每个连接。 </p><p>这是Go的net / http的强大功能，因为它利用了Go的出色的并发功能，廉价的goroutines确保了HTTP处理程序的非常干净的并发模型。处理程序可以阻塞（例如，通过从数据库读取），而不必担心使其他处理程序停顿。但是，这需要在编写具有共享数据的处理程序时要格外小心。阅读我的早期文章了解更多详细信息。</p><p> 最后，进行紧急处理。 HTTP服务器通常意味着在后台运行。假设在某些用户提供的请求处理程序中发生了一些问题，例如某种导致运行时恐慌的错误。这可能会使整个服务器崩溃，这不是一个很好的方案。为了保护自己免受这种情况的侵扰，您可以考虑在服务器的主要功能中添加恢复功能，但是由于几个原因，该功能无济于事：</p><p> 等到控件返回main时，ListenAndServe已经完成，因此不再进行任何服务。</p><p> 由于每个连接都是在单独的goroutine中处理的，因此，来自处理程序的恐慌甚至不会到达main，而是会导致进程崩溃。</p><p> 为了对此提供保护，net / http为每个服务goroutine内置了恢复功能（在conn.serve方法中）。我们可以通过一个简单的示例看到它：</p><p> func你好（w http。ResponseWriter，req * http。Request）{fmt。 Fprintf（w，＆＃34; hello \ n＆＃34;）} func doPanic（w http。ResponseWriter，req * http。Request）{恐慌（＆＃34; oops＆＃34;）} func main（）{http。 HandleFunc（＆＃34; / hello＆＃34;，你好）http。 HandleFunc（＆＃34; / panic＆＃34;，doPanic）http。 ListenAndServe（＆＃34;：8090＆＃34;，nil）}</p><p>    2021/02/16 09:44:31 http：紧急服务127.0.0.1:52908：oopsgoroutine 8 [正在运行]：net / http。（* conn）.serve.func1（0xc00010cbe0）/ usr / local / go / src / net / http / server.go：1801 + 0x147panic（0x654840，0x6f0b80）/usr/local/go/src/runtime/panic.go:975 + 0x47amain.doPanic（0x6fa060，0xc0001401c0，0xc000164200）[...其余部分转储到这里...] </p><p>尽管这种内置保护比使服务器崩溃更好，但许多开发人员发现它有一定的局限性。 它所做的只是关闭连接并记录错误； 通常，将某种错误响应（例如代码500-内部服务器错误）返回给客户端并附带其他详细信息会更加有用。  阅读了这篇文章之后，编写实现这一目标的中间件应该很容易。 试试看作为练习！ 我将在以后的文章中介绍这个用例。  与使用默认多路复用器的版本相比，有充分的理由偏爱此版本。 默认的多路复用器存在一定的安全风险； 因为globalit可以通过您的项目导入的任何软件包进行修改。 恶意软件包可用于邪恶的需求。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eli.thegreenplace.net/2021/life-of-an-http-request-in-a-go-server/">https://eli.thegreenplace.net/2021/life-of-an-http-request-in-a-go-server/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/http/">#http</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1041577.html"><img src="http://img2.diglog.com/img/2020/12/thumb_df28b94fc63354031c6cb09ad7ffc7fe.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041577.html">我们绘制了一百万个网页，以找出导致网络缓慢的原因 </a></div><span class="my_story_list_date">2020-12-24 21:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035303.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68e69ef16f17d5aea61eb99f5dda9b76.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035303.html">包含DI、遥测等功能的Golang Web服务框架</a></div><span class="my_story_list_date">2020-11-16 2:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031634.html"><img src="http://img2.diglog.com/img/2020/10/thumb_a99a94603a5f681f07f620f3dab259a0.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031634.html">Hoppscotch-一个免费、快速、漂亮的API请求构建器</a></div><span class="my_story_list_date">2020-10-28 6:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030435.html"><img src="http://img2.diglog.com/img/2020/10/thumb_88ff603dc5afd4b7b8a6dd89a5244b0b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030435.html">维基媒体基金会的透明度报告</a></div><span class="my_story_list_date">2020-10-22 9:36</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>