<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用Python计算事物的历史 Counting Things in Python: A History</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Counting Things in Python: A History<br/>用Python计算事物的历史 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-16 17:15:24</div><div class="page_narrow text-break page_content"><p>Sometimes the  Pythonic way to solve a problem changes over time. As Python has evolved, so has the Pythonic way to count list items.</p><p>有时，解决问题的Python方法会随着时间而改变。随着Python的发展，用Python方式计算列表项的方式也是如此。</p><p> Let’s look at different techniques for counting the number of times things appear in a list. While analyzing these techniques, we will  only be looking at code style. We’ll worry about performance later.</p><p> 我们来看一下计算事物在列表中出现的次数的不同技术。在分析这些技术时，我们只会关注代码样式。稍后我们会担心性能。</p><p> We will need some historical context to understand these different techniques. Fortunately we live in the  __future__ and we have a time machine. Let’s jump in our DeLorean and head to 1997.</p><p> 我们需要一些历史背景来理解这些不同的技术。幸运的是，我们生活在__future__中，并且拥有一台时间机器。让我们跳入DeLorean并进入1997年。</p><p>  It’s January 1, 1997 and we’re using Python 1.4. We have a list of colors and we’d love to know how many times each color occurs in this list. Let’s use  a dictionary!</p><p>  是1997年1月1日，我们正在使用Python 1.4。我们有一个颜色列表，我们很想知道每种颜色在该列表中出现了多少次。让我们使用字典！</p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  {}  for  c  in  colors :   if  color_counts . has_key ( c ):   color_counts [ c ]  =  color_counts [ c ]  +  1   else :   color_counts [ c ]  =  1</p><p> 颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = {}对于颜色c：if color_counts。 has_key（c）：color_counts [c] = color_counts [c] + 1 else：color_counts [c] = 1</p><p> Note: we’re not using  += because augmented assignment won’t be added until  Python 2.0 and we’re not using the  c in color_counts idiom because that won’t be invented until  Python 2.2!</p><p> 注意：我们不使用+ =，因为在Python 2.0之前不会添加增强分配，并且我们不会在color_counts惯用语中使用c，因为在Python 2.2之前不会发明c！</p><p> After running this we’ll see that our  color_counts dictionary now contains the counts of each color in our list:</p><p> 运行此命令后，我们将看到我们的color_counts词典现在包含列表中每种颜色的计数： </p><p>  That was pretty simple. We just looped through each color, checked if it was in the dictionary, added the color if it wasn’t, and incremented the count if it was.</p><p>那很简单。我们只是循环浏览每种颜色，检查它是否在字典中，如果不是，则添加颜色，如果是，则增加计数。</p><p>  colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  {}  for  c  in  colors :   if  not  color_counts . has_key ( c ):   color_counts [ c ]  =  0   color_counts [ c ]  =  color_counts [ c ]  +  1</p><p>  颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = {}对于c颜色：如果不是color_counts。 has_key（c）：color_counts [c] = 0 color_counts [c] = color_counts [c] + 1</p><p> This might be a little slower on sparse lists (lists with lots of non-repeating colors) because it executes two statements instead of one, but we’re not worried about performance, we’re worried about code style. After some thought, we decide to stick with this new version.</p><p> 在稀疏列表（具有很多非重复颜色的列表）上，这可能会稍慢一些，因为它执行的是两个语句而不是一个，但是我们并不担心性能，我们担心代码风格。经过一番思考，我们决定继续使用这个新版本。</p><p>  It’s January 2, 1997 and we’re still using Python 1.4. We woke up this morning with a sudden realization: our code is practicing “Look Before You Leap” ( LBYL) when we should be practicing “Easier to Ask Forgiveness, Than Permission” ( EAFP) because EAFP is more Pythonic. Let’s refactor our code to use a try-except block:</p><p>  是1997年1月2日，我们仍在使用Python 1.4。我们今天早上醒来时突然意识到：我们的代码正在练习“跨越式的思考”（LBYL），而我们本应练习“比请求权限更容易宽恕”（EAFP），因为EAFP更像Python。让我们重构代码以使用try-except块：</p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  {}  for  c  in  colors :   try :   color_counts [ c ]  =  color_counts [ c ]  +  1   except  KeyError :   color_counts [ c ]  =  1</p><p> 颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = {}对于颜色中的c：try：color_counts [c] = color_counts [c] + 1，但KeyError：color_counts [c] = 1</p><p> Now our code attempts to increment the count for each color and if the color isn’t in the dictionary, a  KeyError will be raised and we will instead set the color count to 1 for the color.</p><p> 现在，我们的代码尝试增加每种颜色的计数，如果该颜色不在词典中，则会引发KeyError，而是将颜色的颜色计数设置为1。</p><p>  It’s January 1, 1998 and we’ve upgraded to Python 1.5. We’ve decided to refactor our code to use the  new  get method on dictionaries:</p><p>  1998年1月1日，我们已经升级到Python 1.5。我们决定将代码重构为对字典使用新的get方法： </p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  {}  for  c  in  colors :   color_counts [ c ]  =  color_counts . get ( c ,  0 )  +  1</p><p>颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = {}对于颜色为c的颜色：color_counts [c] = color_counts。得到（c，0）+ 1</p><p> Now our code loops through each color, gets the current count for the color from the dictionary, defaulting this count to  0, adds  1 to the count, and sets the dictionary key to this new value.</p><p> 现在，我们的代码循环遍历每种颜色，从字典中获取颜色的当前计数，将该计数默认为0，将计数加1，然后将字典键设置为此新值。</p><p> It’s cool that this is all one line of code, but we’re not entirely sure if this is more Pythonic. We decide this might be too clever so we revert this change.</p><p> 这全是一行代码，这很酷，但是我们不确定这是否是Pythonic。我们认为这可能太聪明了，因此我们恢复了此更改。</p><p>  It’s January 1, 2001 and we’re now using Python 2.0! We’ve heard that  dictionaries have a  setdefault method now and we decide to refactor our code to use this new method. We also decide to use the new  += augmented assignment operator:</p><p>  是2001年1月1日，我们现在正在使用Python 2.0！我们听说字典现在有一个setdefault方法，我们决定重构代码以使用此新方法。我们还决定使用新的+ =扩充赋值运算符：</p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  {}  for  c  in  colors :   color_counts . setdefault ( c ,  0 )   color_counts [ c ]  +=  1</p><p> 颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = {}对于颜色为c的颜色：color_counts。 setdefault（c，0）color_counts [c] + = 1</p><p> The  setdefault method is being called on every loop, regardless of whether it’s needed, but this does seem a little more readable. We decide that this is more Pythonic than our previous solutions and commit our change.</p><p> 无论是否需要，都会在每个循环中调用setdefault方法，但这似乎更具可读性。我们认为这比以前的解决方案更具Python风格，并做出更改。</p><p>  It’s January 1, 2004 and we’re using Python 2.3. We’ve heard about a  new  fromkeys class method on dictionaries for constructing dictionaries from a list of keys. We refactor our code to use this new method:</p><p>  是2004年1月1日，我们正在使用Python 2.3。我们听说过字典上有一个新的fromkeys类方法，该方法可从键列表中构造字典。我们将代码重构为使用此新方法： </p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  dict . fromkeys ( colors ,  0 )  for  c  in  colors :   color_counts [ c ]  +=  1</p><p>颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = dict。 fromkeys（colors，0）for c的颜色：color_counts [c] + = 1</p><p> This creates a new dictionary using our colors as keys, with all values set to  0 initially. This allows us to increment each key without worrying whether it has been set. We’ve removed the need for any checking or exception handling which seems like an improvement. We decide to keep this change.</p><p> 这将使用我们的颜色作为键创建一个新字典，所有值最初都设置为0。这使我们可以递增每个键，而不必担心它是否已设置。我们不再需要进行任何检查或异常处理，这似乎是一种改进。我们决定保留此更改。</p><p>  It’s January 1, 2005 and we’re using Python 2.4. We realize that we could solve our counting problem using sets ( released in Python 2.3 and made into  a built-in in 2.4) and list comprehensions ( released in Python 2.0). After further thought, we remember that  generator expressions were also just released in Python 2.4 and we decide to use one of those instead of a list comprehension:</p><p>  是2005年1月1日，我们正在使用Python 2.4。我们意识到，我们可以使用集（在Python 2.3中发布并在2.4中内置）和列表推导（在Python 2.0中发布）解决计数问题。经过进一步思考，我们记得生成器表达式也是在Python 2.4中发布的，我们决定使用其中一个而不是列表理解：</p><p> colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  dict (( c ,  colors . count ( c ))  for  c  in  set ( colors ))</p><p> 颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts = dict（（set（colors）中c的（（c，colors。count（c））））</p><p> Note: we didn’t use a dictionary comprehension because those won’t be invented until  Python 2.7.</p><p> 注意：我们没有使用字典理解，因为只有在Python 2.7之前，它们才被发明。</p><p>  We remember the  Zen of Python, which  started in a python-list email thread and was  snuck into Python 2.2.1. We type  import this at our REPL:</p><p>  我们记得Python的Zen，它始于python-list电子邮件线程中，并被Python 2.2.1所吸引。我们在REPL中输入import this：</p><p> &gt;&gt;&gt;  import  this  The Zen of Python, by Tim Peters   Beautiful is better than ugly.  Explicit is better than implicit.  Simple is better than complex.  Complex is better than complicated.  Flat is better than nested.  Sparse is better than dense.  Readability counts.  Special cases aren&#39;t special enough to break the rules.  Although practicality beats purity.  Errors should never pass silently.  Unless explicitly silenced.  In the face of ambiguity, refuse the temptation to guess.  There should be one-- and preferably only one --obvious way to do it.  Although that way may not be obvious at first unless you&#39;re Dutch.  Now is better than never.  Although never is often better than *right* now.  If the implementation is hard to explain, it&#39;s a bad idea.  If the implementation is easy to explain, it may be a good idea.  Namespaces are one honking great idea -- let&#39;s do more of those!</p><p> ＆gt;＆gt;＆gt;蒂姆·彼得斯（Tim Peters Beautiful）导入的《 Python的禅宗》比丑陋更好。显式胜于隐式。简单胜于复杂。复杂胜于复杂。扁平比嵌套更好。稀疏胜于密集。可读性很重要。特殊情况不足以违反规则。尽管实用性胜过纯度。错误绝不能默默传递。除非明确地保持沉默。面对模棱两可的想法，拒绝猜测的诱惑。应该有一种-最好只有一种-显而易见的方法。除非您是荷兰人，否则起初这种方式可能并不明显。现在总比没有好。尽管从来没有比现在“正确”好。如果难以解释该实现，则是个坏主意。如果实现易于解释，则可能是个好主意。命名空间是一个很棒的主意-让我们做更多的事吧！ </p><p> Our code is  more complex ( O(n 2) instead of  O(n)),  less beautiful, and  less readable. That change was a fun experiment, but this one-line solution is  less Pythonic than what we already had. We decide to revert this change.</p><p>我们的代码更复杂（用O（n 2）代替O（n）），不太漂亮，可读性更差。所做的更改是一个有趣的实验，但是这种单线解决方案比我们现有的Pythonic少。我们决定还原此更改。</p><p>  It’s January 1, 2007 and we’re using Python 2.5. We’ve just found out that   defaultdict is in the standard library now. This should allow us to set  0 as the default value in our dictionary. Let’s refactor our code to count using a  defaultdict instead:</p><p>  这是2007年1月1日，我们正在使用Python 2.5。我们刚刚发现defaultdict现在在标准库中。这应该允许我们将0设置为字典中的默认值。让我们重构代码以使用defaultdict进行计数：</p><p> from  collections  import  defaultdict  colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  defaultdict ( int )  for  c  in  colors :   color_counts [ c ]  +=  1</p><p> 从集合中导入defaultdict colors = [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts =用于颜色c的defaultdict（int）：color_counts [c] + = 1</p><p>  We realize that our  color_counts variable does act differently, however it  does inherit from  dict and supports all the same mapping functionality.</p><p>  我们意识到，color_counts变量的行为不同，但是它确实继承自dict并且支持所有相同的映射功能。</p><p>  Instead of converting  color_counts to a  dict, we’ll assume the rest of our code practices  duck typing and leave this dict-like object as-is.</p><p>  我们假设其余的代码实践未将color_counts转换为dict，而是直接进行了鸭式输入，并将此类似dict的对象保持原样。</p><p>  It’s January 1, 2011 and we’re using Python 2.7. We’ve been told that our  defaultdict code is no longer the most Pythonic way to count colors.  A  Counter class was included in the standard library in Python 2.7 and it does all of the work for us!</p><p>  是2011年1月1日，我们正在使用Python 2.7。有人告诉我们，我们的defaultdict代码不再是计算颜色的最Python方式。 Python 2.7的标准库中包含一个Counter类，它为我们完成了所有工作！</p><p> from  collections  import  Counter  colors  =  [ &#34;brown&#34; ,  &#34;red&#34; ,  &#34;green&#34; ,  &#34;yellow&#34; ,  &#34;yellow&#34; ,  &#34;brown&#34; ,  &#34;brown&#34; ,  &#34;black&#34; ]  color_counts  =  Counter ( colors )</p><p> 从集合中导入专柜颜色= [＆＃34;棕色＆＃34; ，＆＃34;红色＆＃34; ，＆＃34;绿色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;黄色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;棕色＆＃34; ，＆＃34;黑色＆＃34; ] color_counts =计数器（颜色） </p><p>  Like  defaultdict, this returns a dict-like object (a  dict subclass actually), which should be good enough for our purposes, so we’ll stick with it.</p><p>像defaultdict一样，它返回一个类似dict的对象（实际上是dict的子类），对于我们的目的来说应该足够好，因此我们会坚持下去。</p><p>   Notice that we didn’t focus on efficiency for these solutions. Most of these solutions have the same time complexity ( O(n) in big O notation) but runtimes could vary based on the Python implementation.</p><p>   请注意，我们并未关注这些解决方案的效率。这些解决方案中的大多数具有相同的时间复杂度（大O表示法为O（n）），但运行时可能会因Python实现而异。</p><p> While performance isn’t our main concern,  I did measure the run-times on CPython 3.5.0. It’s interesting to see how each implementation changes in relative efficiency based on the density of color names in the list.</p><p> 尽管性能不是我们的主要关注点，但是我确实测量了CPython 3.5.0的运行时间。有趣的是，每种实现方式如何根据列表中颜色名称的密度改变相对效率。</p><p>  Per the  Zen of Python, “there should be one– and preferably only one– obvious way to do it”. This is an aspirational message. There isn’t always one obvious way to do it. The “obvious” way can vary by time, need, and level of expertise.</p><p>  按照Python Zen的说法，“应该有一种（最好只有一种）明显的方式来做到这一点”。这是一个理想的消息。并非总是有一种明显的方式来做到这一点。 “显而易见”的方式会随时间，需求和专业水平的不同而变化。</p><p>   import this and the Zen of Python: Zen of Python trivia borrowed from this post</p><p>   导入此内容和Python的Zen：从这篇文章中借来的Python Zen琐事</p><p>  Python How To: Group and Count with Dictionaries: while writing this post, I discovered this related article</p><p>  Python如何：用字典进行分组和计数：在撰写本文时，我发现了这篇相关文章</p><p>  Thanks to  Brian Schrader and  David Lord for proof-reading this post and  Micah Denbraver for actually  testing out these solutions on the correct versions of Python.</p><p>  感谢Brian Schrader和David Lord对本文的校对，并感谢Micah Denbraver在正确版本的Python上实际测试了这些解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://treyhunner.com/2015/11/counting-things-in-python/">https://treyhunner.com/2015/11/counting-things-in-python/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/计算/">#计算</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>