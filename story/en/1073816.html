<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>区别是什么：JSON差异和补丁What's the Difference: JSON diff and patch</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What's the Difference: JSON diff and patch<br/>区别是什么：JSON差异和补丁</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 12:22:12</div><div class="page_narrow text-break page_content"><p>How will we have a distributed network of data stores which allow updates and synchronizations?</p><p>我们将如何拥有一个允许更新和同步的分布式数据存储网络？</p><p>    These questions are really at the heart of the distributed part of web3. Web3 has other parts: immutability, cryptographic security, etc. But these other elements do not answer how to perform updates on distributed data stores.*</p><p>这些问题实际上是web3分布式部分的核心。Web3还有其他部分：不变性、加密安全性等。但这些其他元素不回答如何在分布式数据存储上执行更新*</p><p> In seeking the answer to these questions I was led to see a rather simple tool as foundational: JSON diff and patch.</p><p>在寻找这些问题的答案时，我看到了一个相当简单的工具作为基础：JSON diff和patch。</p><p> JSON, because JSON is the structured data format for the web. This will continue to be true for Web3. Everyone uses JSON for just about everything in our web architecture. Other formats are going to be increasingly used as mere optimizations of JSON. Associative arrays have the beauty of (reasonable) human readability, combined with widespread native support in modern computer programming languages. Both computers and humans can read it, what’s not to love!</p><p>JSON，因为JSON是web的结构化数据格式。对于Web3来说，这种情况将继续存在。在我们的web架构中，几乎所有人都使用JSON。其他格式将越来越多地被用作JSON的优化。关联数组具有（合理的）人类可读性之美，加上现代计算机编程语言中广泛的本机支持。电脑和人类都能读，这不是爱！</p><p>   A fundamental tool in git’s strategy for distributed management of source code is the concept of the diff and the patch. These foundational operations are what make git possible. Diff is used to construct a patch that can be applied to an object such that the final state makes sense for some value of makes sense.</p><p>git分布式管理源代码策略中的一个基本工具是diff和补丁的概念。这些基本操作使git成为可能。Diff用于构造可应用于对象的面片，从而使最终状态对某些值有意义。</p><p> The application of patches happens because we want a certain before state to be lifted to a certain after state. The patch doesn’t specify everything. Only what it expects to be true of the source, and what it expects to be true after the update.</p><p>应用补丁是因为我们希望将某个前状态提升到某个后状态。补丁并没有指定所有内容。只有源代码的预期正确，以及更新后的预期正确。</p><p> With this, it’s possible to have distributed updates performed on different parts of source text. Collisions result in some remedial action being required, but if there are no collisions everything can be merged to obtain a final state which respects all updates, no matter when or where they came from.</p><p>这样，就可以对源文本的不同部分执行分布式更新。冲突会导致需要采取一些补救措施，但如果没有冲突，则可以合并所有内容以获得最终状态，该状态尊重所有更新，无论它们来自何时何地。</p><p> This is what allows git to be fully multi-master, without requiring or forcing synchronization using any complex protocols (like RAFT).</p><p>这使得git可以完全多主，而不需要或强制使用任何复杂的协议（如RAFT）进行同步。</p><p>     {  &#34;id&#34; :  13234 ,  &#34;name&#34; :  &#34;Retro Encabulator Mark 2&#34; ,  &#34;description&#34; :  &#34;The Retro Encabulator Mark II is the lastest   development of the Retro Encabulator used to   generate inverse reactive current for unilateral   phase detractors.&#34; &#34; category&#34; :  &#34;Cardinal Grammeter Synchronisers&#34; ,  &#34;price&#34; :  {  &#34;value&#34; :  &#34;3430.23&#34; ,  &#34;currency&#34; :  &#34;Euro&#34;  } } ,  &#34;stock&#34; :  32 ,  &#34;suppliers&#34; :  [ &#34;Supplier/123&#34; , &#34;Supplier/4332&#34; ]  }</p><p>逆包器Mark 2&#34；id&#34；：13234，&#34；名称&#34；&#34；&#描述&#34；&#34；&#34；描述&#34；&#34；&#34；&#34；逆包器Mark II是逆包器的最新发展，用于为单侧相位分配器产生反向无功电流。&#，  &#34;价格&#34；：{&#34；价值&#34；&#34；3430.23&#34；&#34；货币&#34；&#34；欧元&#34；}&#34;股票&#34；：32 ,  &#34;供应商&#34；：[&#34；供应商/123&#34；，&#34；供应商/4332&#34；]</p><p> If Alice opens the object in an application and changes the name ofthe item to &#34;Retro Encabulator Mark II&#34;, it should be possible for Bobto update the suppliers list simultaneously without either steppingon each other&#39;s toes.</p><p>如果Alice在应用程序中打开对象并将项目名称更改为&#34；复古建筑标志II&#34；，BOB应该可以同时更新供应商名单，而无需相互干涉&#39；脚趾。</p><p> In applications, this sort of curation operation is often achieved witha  lock on the object. Which means only one person can win. And locksare a massive source of pain, not only because you can&#39;t achieveotherwise perfectly reasonable concurrent operations, but because yourisk getting stale locks and having to figure out when to release them.</p><p>在应用中，这种策展操作通常通过锁定对象来实现。这意味着只有一个人能赢。锁是巨大的痛苦来源，不仅因为你可以&#39；无法实现其他完全合理的并发操作，但因为您可能会遇到过时的锁，并且必须确定何时释放它们。</p><p> But what if Sally didn&#39;t submit her whole object for update, but onlythe part she wanted to be changed? And Bob did the same?</p><p>但如果萨莉没有&#39；Don’我不能提交她的整个对象进行更新，但只提交她想更改的部分？鲍勃也这么做了？</p><p> Now we can perform the updates in three different places, locally forAlice, locally for Bob, and then finally at a shared server resource.</p><p>现在我们可以在三个不同的地方执行更新，本地为Lice，本地为Bob，最后在共享服务器资源上执行。</p><p> The structured patch could be determined by looking at the object before Alice submitted it, and after, using  diff. The patchconstructed from Alice&#39;s diff might look like this:</p><p>结构化补丁可以通过在Alice提交之前查看对象来确定，然后使用diff从Alice&#39构建补丁；s diff可能是这样的：</p><p> {  &#34;name&#34; :  {  &#34;@before&#34; :  &#34;Retro Encabulator Mark 2&#34; ,  &#34;@after&#34; :  &#34;Retro Encabulator Mark II&#34; } }</p><p>{&#34；姓名&#34；：{&#34；前&#34；&#34；复古装潢师标志2&#34；&#34；&#34；&#34；复古装潢师标志II&#34；}</p><p>   Now both can apply cleanly to the original document listed above. Wecan stack either patch in any order without difficulty. Perhaps we askBob and Alice to agree on the application order (using pull / push asis done with git). But maybe we just allow them to apply when theyarrive. The answer depends on the workflow.</p><p>现在，两者都可以清晰地应用于上面列出的原始文档。我们可以毫无困难地按任何顺序堆叠任何一个补丁。也许我们要求KBOB和Alice就应用程序顺序达成一致（使用git完成拉/推操作）。但也许我们只是允许他们在他们来的时候申请。答案取决于工作流程。</p><p>   {  &#34;name&#34; :  {  &#34;@before&#34; :  &#34;Retro Encabulator Mark 2&#34; ,  &#34;@after&#34; :  &#34;Retro Encabulator Mark two&#34; } }</p><p>{&#34；姓名&#34；：{&#34；前&#34；&#34；复古装潢师标志2&#34；&#34；&#34；&#34；复古装潢师标志2&#34；&#</p><p> We have a problem. But we see immediately that the two are in conflictand Alice can be asked to resolve the question by surfacing it. In thecase of data curation, this is a perfectly reasonable workflow. And itis this problem of data curation that we can solve with the simplestversion of JSON diff.</p><p>我们有个问题。但我们立即发现，这两者存在冲突，爱丽丝可以被要求通过浮出水面来解决这个问题。在数据整理的情况下，这是一个完全合理的工作流程。我们可以用JSON diff最简单的版本来解决这个数据整理问题。</p><p> This conflict can be surfaced to Alice, and Bob can be allowed to goabout his business. Could this particular problem be resolved in apurely automatic way with a CRDT? Definitely, but it probably will notresult in what you want. Last first will work of course, but thenwhich is  more right might need human review, and even worse it mightresult in both results being interleaved (a likely outcome!).</p><p>这种冲突可以向爱丽丝浮出水面，鲍勃可以被允许继续他的生意。这个特殊的问题能用CRDT自动解决吗？当然，但它可能不会产生你想要的结果。最后一步当然会奏效，但接下来哪一步更正确可能需要人工审查，更糟糕的是，这可能会导致两种结果交错（一种可能的结果！）。</p><p> We  could make the before and after, however, be a text-based patchusing a textual diff. Probably gits line-based approach is  not whatwe want here, but rather one that takes words as atoms. It will notsolve this particular conflict, but it could make text fields muchmore flexible.</p><p>然而，我们可以使用文本差异将前后的内容制作成基于文本的补丁。可能gits基于行的方法不是我们想要的，而是将单词作为原子的方法。它不会解决这个特定的冲突，但它可以使文本字段更加灵活。</p><p> Which of these you want, however, requires  semantic direction of thediff algorithm. While lots of structured diff problems will be solvedby the simplest algorithm, ultimately we need to have a schema thathelps to direct the meaning of our diffs. String fields might be bestline-based, word-based, or perhaps they must always be atomic (as withidentifiers).</p><p>然而，您想要哪一个，需要DIFF算法的语义方向。虽然许多结构化的差异问题将通过最简单的算法来解决，但最终我们需要一个有助于指导差异含义的模式。字符串字段可以是基于最佳行的、基于单词的，或者它们必须始终是原子的（就像标识符一样）。</p><p>  Patch is actually the simpler operation. Patch application basicallyjust checks that the read state matches, and then substitutes thewrites.</p><p>补丁实际上是更简单的操作。补丁应用程序基本上只是检查读取状态是否匹配，然后替换写入。</p><p> Diff, by contrast, has to calculate, and often in practice  guess agood transition from the read state to the write state. The specifictuning of the patch provided by a diff is dependent on the needs ofthe application. There are  generic algorithms that can work decentlyfor a range of applications, but there is no one size fits all. Thisis why we will need the  semantic direction which can be provided bya schema.</p><p>相比之下，Diff必须进行计算，而且在实践中经常需要猜测从读状态到写状态的良好转换。diff提供的补丁的具体调整取决于应用程序的需要。有一些通用算法可以在一系列应用中正常工作，但没有一种通用算法。这就是为什么我们需要模式提供的语义方向。</p><p> Diff is also computationally  much more expensive. Finding theminimal change means finding the maximal similarity. As it turns out,this is pretty easy for the skeleton of a JSON dictionary, but rathera pain for lists, and strings. And for lists of lists... Well, I&#39;llget into that later.</p><p>Diff在计算上也要昂贵得多。找到最小的变化意味着找到最大的相似性。事实证明，这对于JSON字典的框架来说非常简单，但对于列表和字符串来说却非常困难。对于列表列表。。。嗯，我&#39；我待会儿再谈。</p><p> Let&#39;s just say it&#39;s no exaggeration that you can easily wander intothe heat-death of the universe. Hence heuristics have to be part ofany fully automatic diff.</p><p>让&#39；就这么说吧&#39；毫不夸张地说，你可以轻易地陷入宇宙的热寂之中。因此，启发式必须是任何全自动差异的一部分。</p><p>  But there are other workflows that might want a slightly more flexibleapproach to ensuring data integrity. The  before state is reallysitting there to specify the  read object model. It tells us what wewant to be true when we apply the patch.</p><p>但也有其他工作流可能需要更灵活的方法来确保数据完整性。before状态正在重新设置以指定读取对象模型。它告诉我们，当我们应用补丁时，我们希望什么是真实的。</p><p> With git, this might be lines of text. For instance, to change a verysimple  README.txt which initially says  hello world to one thatsays  hello squirrels, git will produce a patch that looks somethinglike the following:</p><p>对于git，这可能是一行行文本。例如，更改一个非常简单的自述文件。txt最初是向一个向松鼠问好的人问好，git将生成一个如下所示的补丁：</p><p>  This isn&#39;t the most compact patch, and it will conflict if hello werechanged to some other word, for instance  greetings perhaps. Thereason that it works well for git is that lines of text are a somewhatreasonable granularity for programming languages.</p><p>这不是&#39；它不是最紧凑的补丁，如果hello被改成其他单词，比如“问候语”，它就会发生冲突。它对git很有效的原因是，对于编程语言来说，文本行是一种合理的粒度。</p><p> But the before and after don&#39;t have to be lines or words. The beforecould be any specification of the read state. For a bank accountwithdrawal, we might ask for the before state to be larger than, orequal to the after state. This would be a nice little transaction forensuring we don&#39;t overdraw.</p><p>但是唐的前后&#39；不必是台词或文字。before可以是读取状态的任何规范。对于银行账户提款，我们可能会要求前状态大于后状态，或与后状态相等。这将是一个很好的小交易，以确保我们不&#39；不要透支。</p><p> Or perhaps we want the before state to be specified with a regex? Ormaybe we read a  lot of values in order to calculate a further valuein the object, in which case we want to know that  none of thesevalues change.</p><p>或者我们希望用正则表达式指定before状态？或者，我们读取了很多值，以便计算对象中的进一步值，在这种情况下，我们希望知道这些值都不会改变。</p><p> This approach gives us a kind of read isolation that is  tuned tothe use-case we&#39;re actually working with. Making patch the unit ofupdate gives us just the right granularity for our application, whichreally can&#39;t be known in advance.</p><p>这种方法为我们提供了一种读隔离，它根据我们使用的用例进行调整&#39；我们真的在一起工作。将补丁作为更新的单位，为我们的应用程序提供了恰到好处的粒度，这实际上可以&#39；我们不能提前知道。</p><p> This is an advancement beyond the sort of isolation options usuallyprovided by a database, and one that extends naturally to objects orgraphs of interconnected objects (as exists in TerminusDB).</p><p>这是一个超越了通常由数据库提供的隔离选项的进步，并且自然地扩展到了对象或互连对象的组织图（如USDB中存在的）。</p><p>  I&#39;ve implemented a simple JSON diff and patch in TerminusX. But we&#39;realso working on the extensions of this to those specified by aschema. It&#39;s also easy to implement and very interesting to imagine afull space of patches, many of which could never be determined by adiff, but which would be extremely handy to have for distributedtransactions over document stores. We will be adding these variousoperations as we run into use-cases in practice, but we&#39;re also verykeen to hear about use cases that people have already encountered inthe wild. Do let me know!</p><p>我&#39；我们在TerminusX中实现了一个简单的JSON差异和补丁。但我们&#39；realso正在将其扩展到aschema指定的版本。它&#39；它也很容易实现，而且想象一个完整的补丁空间非常有趣，其中许多补丁永远无法由adiff确定，但对于通过文档存储进行分布式传输来说，这将非常方便。我们将在实践中遇到用例时添加这些不同的操作，但我们&#39；我们也很高兴听到人们在野外已经遇到的用例。一定要告诉我！</p><p> * CRDTs answer this question for certain types ofdata structures - but not for all. Only certain  types ofdata structures can be updated with these approaches. In addition, manyupdates require human aided review and will never require aCRDT. Still others will have  object read model conditions that cannot be specified in a CRDT. Ultimately our databases should support arange of distributed datatypes including CRDT.</p><p>*CRDT针对特定类型的数据结构回答了这个问题，但不是针对所有类型的数据结构。这些方法只能更新某些类型的数据结构。此外，许多更新需要人工辅助审查，并且永远不需要aCRDT。还有一些将具有无法在CRDT中指定的对象读取模型条件。最终，我们的数据库应该支持一系列分布式数据类型，包括CRDT。</p><p>  If you are interesed in JSON diff &amp; patch, we&#39;ll be streaming on Twitch on 17 Feb at 3pm GMT.</p><p>如果您对JSON diff&amp；感兴趣；帕奇，我们&#39；将于2月17日格林威治标准时间下午3点在Twitch上播放。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>