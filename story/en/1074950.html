<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>网络浏览器中IPFS连接指南A guide to IPFS connectivity in web browsers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A guide to IPFS connectivity in web browsers<br/>网络浏览器中IPFS连接指南</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 19:02:02</div><div class="page_narrow text-break page_content"><p>We see a lot of questions about how to get started with using  js-ipfs in the browser. This post demonstrates a minimal chat example in  js-ipfs entirely in the browser. It uses WebRTC to achieve browser-to-browser connectivity where possible, and a circuit relay to connect browser nodes where not. Message passing is done with libp2p&#39;s pubsub.</p><p>我们看到了很多关于如何开始在浏览器中使用js ipfs的问题。本文演示了一个完全在浏览器中使用js ipfs的聊天示例。它使用WebRTC在可能的情况下实现浏览器到浏览器的连接，并使用电路中继在不可能的情况下连接浏览器节点。消息传递是通过libp2p和#39完成的；酒吧。</p><p>    You can see the live demo  here       (opens new window). If you&#39;d like a local copy you can edit yourself, you can download the whole directory using IPFS:</p><p>你可以在这里看到实时演示（打开新窗口）。如果你&#39；我想要一份本地副本，你可以自己编辑，你可以使用IPFS下载整个目录：</p><p>   Then simply open  index.html in your web browser and you&#39;ll immediately begin automatically connecting to nodes and looking for peers!</p><p>然后简单地打开索引。网页浏览器中的html和你&#39；我们将立即开始自动连接到节点并寻找对等节点！</p><p>  You can also fork  TheDiscordian/browser-ipfs-chat       (opens new window) on GitHub, and it&#39;ll be ready to test right away! If you want to deploy your own version, simply edit  index.html and follow the setup information below.</p><p>你也可以在GitHub上打开Discordian/browser ipfs聊天（打开新窗口），它&#39；I’我马上就准备好测试！如果您想部署自己的版本，只需编辑索引即可。并按照下面的设置信息进行操作。</p><p>  The libraries used in this example are   js-ipfs       (opens new window) and Bootstrap (just their minified CSS). If you want a newer version of  js-ipfs, feel free to download  this one here       (opens new window) to use the latest version available 😃.</p><p>本例中使用的库是js ipfs（打开新窗口）和Bootstrap（只是它们的缩小CSS）。如果你想要更新版本的js ipfs，可以在这里下载（打开新窗口）以使用最新版本😃.</p><p>          In a browser, discovering and connecting to peers can be very hard, as we can&#39;t listen for new peers and we don&#39;t have access to the DHT. In order to have the best experience working in a browser, it&#39;s important to understand how to both find peers and stay connected with them.</p><p>在浏览器中，发现和连接同龄人可能非常困难，就像我们一样&#39；不要倾听新同事的声音，我们也不会&#39；我无法使用DHT。为了获得在浏览器中工作的最佳体验，它&#39；了解如何找到同龄人并与他们保持联系很重要。</p><p>  The chat example achieves this in two ways. Using WebRTC-Star, we achieve direct browser-to-browser communication, and with a circuit relay, we have a relay in the middle. The chat application also has a status indicator in the top left to let you know what kind of connection you have. Green means you&#39;re connected to the relay, even if it&#39;s via another peer; yellow means you&#39;re only seeing direct peers; and red means you have no peers (at least none using the chat application).</p><p>聊天示例通过两种方式实现这一点。使用WebRTC星，实现了浏览器与浏览器的直接通信，并通过电路继电器，在中间有一个继电器。聊天应用程序在左上角还有一个状态指示器，可以让你知道你的连接类型。绿色意味着你&#39；重新连接到继电器，即使它&#39；通过另一个同龄人；黄色表示你&#39；我们只看到直接的同龄人；红色表示你没有同伴（至少没有使用聊天应用程序的同伴）。</p><p>    🌟 The diagram above demonstrates what a three-user network can look like. It&#39;s worth noting that the browser nodes can communicate with  go-ipfs as well, so BrowserC doesn&#39;t have to be a browser at all, but instead could be a  go-ipfs node!</p><p>🌟 上图展示了三用户网络的样子。它&#39；值得注意的是，浏览器节点也可以与go IPF通信，因此BrowserC不&#39；不必是浏览器，但可以是go ipfs节点！</p><p>      After this section we&#39;ll go over what WebRTC-Star and circuit relay do, and how to set them up. However, if you&#39;d like to quickly roll your own kit using Docker, I&#39;ve prepared an image you can use. It might not be the best long-term solution, but it should be great if you want to quickly get rolling and experiment.</p><p>在本节之后，我们&#39；我将介绍WebRTC Star和电路继电器的功能，以及如何设置它们。然而，如果你&#39；我想用Docker，I&#39；我准备了一张你可以使用的图片。这可能不是最好的长期解决方案，但如果你想快速开始并进行实验，这应该是很好的。</p><p>         You need a domain and SSL to use this kit with browser nodes. There are two options below: One will run certbot and automatically grab a certificate for the provided domain name. The other option won&#39;t handle SSL for you, and instead you&#39;ll have to reverse proxy port 9091 to 9090 (SSL), and port 4011 to 4430 (SSL).</p><p>您需要一个域和SSL才能将此工具包与浏览器节点一起使用。下面有两个选项：一个将运行certbot并自动获取所提供域名的证书。另一个选项赢了&#39；我不能为你处理SSL，相反，你&#39；我们必须将代理端口9091反转为9090（SSL），将端口4011反转为4430（SSL）。</p><p>  When you execute either commands, your IPFS node will also be set up for the first time giving you information such as its  PeerID and circuit relay addresses. Take note of these — you&#39;ll want to edit them into the chat client so you can use your own node (see  WebRTC-Star Usage and  p2p-circuit Usage for usage examples, or edit  index.html and change my node&#39;s multiaddresses out for your own).</p><p>当您执行任一命令时，您的IPFS节点也将第一次被设置，为您提供其对等地址和电路中继地址等信息。注意这些——你&#39；I’我想将它们编辑到聊天客户端，这样你就可以使用自己的节点（参见WebRTC Star Usage和p2p circuit Usage了解用法示例，或者编辑index.html并将my node&#39；s multiaddresses更改为你自己的）。</p><p>    Ensure port 80 isn&#39;t being used, follow the checklist below, and then run the following command:</p><p>确保端口80为&#39；如果正在使用，请遵循下面的检查表，然后运行以下命令：</p><p>  docker run --mount  source =ipfs_bundle,destination =/root -p  9091:9091 -p  4011:4011 -p  9090:9090 -p  4430:4430 -p  80:80 -it trdiscordian/ipfsbundle certbot DOMAIN.COM</p><p>docker run——mount source=ipfs_bundle，destination=/root-p9091:9091-p4011:4011-p9090:9090-p4430:4430-p80:80-it trdiscordian/ipfsbundle certbot域。组件对象模型</p><p>   If you do this option, the container won&#39;t handle SSL at all, and you&#39;ll have to reverse proxy port 9091 to 9090 (SSL), and port 4011 to 4430 (SSL).</p><p>如果您选择此选项，则容器将赢得&#39；根本无法处理SSL，而您&#39；我们必须将代理端口9091反转为9090（SSL），将端口4011反转为4430（SSL）。</p><p>     Ensure the domain is correctly pointing to the machine you&#39;re running the container on (subdomains work fine too)</p><p>确保域正确地指向您的机器&#39；在上重新运行容器（子域也可以正常工作）</p><p>    Once you&#39;re configured, running the container is simple. Ensure that, at minimum, ports 4430 and 9090 are forwarded.</p><p>一旦你&#39；重新配置后，运行容器很简单。确保至少转发端口4430和9090。</p><p>   🎉 You should now be able to use this machine as both a WebRTC-Star node and a p2p-circuit node.</p><p>🎉 现在，您应该可以将该机器用作WebRTC星形节点和p2p电路节点。</p><p>    We can use  WebRTC-Star       (opens new window) nodes to help discover other peers we can connect with directly browser-to-browser. I find it easy to think of this as similar to  STUN       (opens new window), if you&#39;re already familiar with that concept. Effectively, each connecting node will be given a WebRTC-Star  multiaddress       (opens new window) that other nodes can use to discover and connect to your browser directly. This means that if you peer with someone using the star node, and the star node goes offline, you remain connected!</p><p>我们可以使用WebRTC Star（打开新窗口）节点来帮助发现我们可以直接通过浏览器到浏览器连接的其他节点。我发现很容易将其视为类似于STUN（打开新窗口），如果你&#39；我们已经熟悉这个概念了。实际上，每个连接节点都将获得一个WebRTC星形多地址（打开新窗口），其他节点可以使用该地址直接发现并连接到浏览器。这意味着，如果你与使用星型节点的人进行对等，而星型节点离线，你将保持连接！</p><p>      ipfs  =  await Ipfs . create ( { repo :  &#39;ok&#39;  + Math . random ( ) ,  // random so we get a new peerid every time, useful for testing config :  { Addresses :  { Swarm :  [  &#39;/dns4/star.thedisco.zone/tcp/9090/wss/p2p-webrtc-star&#39; ,  &#39;/dns6/star.thedisco.zone/tcp/9090/wss/p2p-webrtc-star&#39;  ]  } , } } ) ;</p><p>ipfs=等待ipfs。创建（{repo:&#39；ok&#39；+Math.random（），//random，这样我们每次都会得到一个新的peerid，用于测试配置：{Addresses:{Swarm:[&#39；/dns4/star.thedisco.zone/tcp/9090/wss/p2p webrtc star#39；&#39；/dns6/star thedisco.zone/tcp/9090/wss/p2p webrtc star 39；}，}）；</p><p>   Please note that this example uses my own star nodes — however, those won&#39;t necessarily always be accessible there. Currently it&#39;s important to either find a reliable star node or host your own. You can host your own quite simply by following the instructions  here       (opens new window) for a native setup and  here       (opens new window) for a Docker container which includes Nginx (for SSL). If you opt for the native setup, we cover the Nginx reverse proxy process and SSL cert retrieval later in this post.</p><p>请注意，这个例子使用了我自己的星型节点——然而，这些节点赢了&#39；在那里不一定总能找到。目前为&#39；重要的是找到一个可靠的星型节点或自己的主机。您只需按照此处的说明（打开新窗口）进行本机设置，并按照此处的说明（打开新窗口）进行Docker容器的托管，该容器包含Nginx（用于SSL）。如果您选择本机设置，我们将在本文后面介绍Nginx反向代理过程和SSL证书检索。</p><p>  🚀 This is a very clean and effective method of P2P communications; however, sometimes NATs get in the way. We use   p2p-circuit       (opens new window) to get around that.</p><p>🚀 这是一种非常干净有效的P2P通信方法；然而，有时NAT会碍事。我们使用p2p电路（打开新窗口）来解决这个问题。</p><p>    Using  p2p-circuit is really helpful for peers behind tricky NATs (or a VPN, or anything really). I find the relaying of  p2p-circuit to be similar to  TURN       (opens new window), so it&#39;s easy to think of it that way if you&#39;re already familiar with it.</p><p>使用p2p circuit对复杂的NAT（或VPN，或其他任何东西）背后的对等方来说真的很有帮助。我发现p2p电路的中继类似于TURN（打开新窗口），所以它&#39；如果你&#39；我们已经很熟悉了。</p><p>    Once all the services for  p2p-circuit are put together, connecting to the node can be achieved in a few different ways. First, to connect on startup to  only our node(s):</p><p>一旦p2p电路的所有服务都放在一起，就可以通过几种不同的方式连接到节点。首先，要在启动时仅连接到我们的节点：</p><p>      If you&#39;re looking to do your own client without copying the example, ensure you&#39;re also communicating with the announce channel, which is described under  Advertising. The relevant code in the chat demo is this (simplified):</p><p>如果你&#39；如果你希望在不复制示例的情况下开发自己的客户，请确保&#39；重新与公告频道进行沟通，详见广告部分。聊天演示中的相关代码如下（简化）：</p><p>  var ipfs ;  // store the IPFS node you&#39;re using in this variable // processes a circuit-relay announce over pubsub async  function  processAnnounce ( addr )  {  // get our peerid me  =  await ipfs . id ( ) ; me  = me .id ;  // not really an announcement if it&#39;s from us  if  (addr .from  == me )  {  return ;  }  // if we got a keep-alive, nothing to do  if  (addr  ==  &#34;keep-alive&#34; )  { console . log (addr ) ;  return ;  } peer  = addr . split ( &#34;/&#34; ) [ 9 ] ; console . log ( &#34;Peer: &#34;  + peer ) ; console . log ( &#34;Me: &#34;  + me ) ;  if  (peer  == me )  {  // return if the peer being announced is us  return ;  }  // get a list of peers peers  =  await ipfs .swarm . peers ( ) ;  for  (i  in peers )  {  // if we&#39;re already connected to the peer, don&#39;t bother doing a  // circuit connection  if  (peers [i ] .peer  == peer )  {  return ;  }  }  // log the address to console as we&#39;re about to attempt a connection console . log (addr ) ;  // connection almost always fails the first time, but almost always  // succeeds the second time, so we do this:  try  {  await ipfs .swarm . connect (addr ) ;  }  catch (err )  { console . log (err ) ;  await ipfs .swarm . connect (addr ) ;  } } // process announcements over the relay network, and publish our own // keep-alives to keep the channel alive await ipfs .pubsub . subscribe ( &#34;announce-circuit&#34; , processAnnounce ) ; setInterval ( function ( ) {ipfs .pubsub . publish ( &#34;announce-circuit&#34; ,  &#34;peer-alive&#34; ) ; } ,  15000 ) ;</p><p>var ipfs；//存储您需要的IPFS节点&#39；在这个变量中重新使用//通过pubsub异步函数processannound（addr）{//get our peerid me=await ipfs.id（）；me=me.id；//如果它是从我们这里发出的，那么它就不是真正的通告，如果（addr.from==me）{return；}如果我们有一个keep alive，如果（addr==&#34；keep alive&#34；）就没什么可做的了{console.log（addr）；return；}peer=addr。拆分（&#34；/&#34；）[ 9 ] ; 安慰日志（&#34；对等：&#34；+对等）；安慰日志（&#34；Me:&#34；+Me）；if（peer==me）{//return如果所宣布的peer是us return；}//获取对等点列表=等待IPF。一大群同龄人（）；对于（对等体中的i）{//如果我们已经连接到对等体，那么不要费心做//电路连接，如果（对等体[i].peer==peer）{return；}//在我们&#39；我们将尝试连接控制台。日志（地址）；//连接几乎总是第一次失败，但几乎总是//第二次成功，所以我们这样做：尝试{wait ipfs.swarm.connect（addr）；}catch（err）{console.log（err）；wait ipfs.swarm.connect（addr）；}}//通过中继网络处理公告，并发布我们自己的//keep alives以保持频道的活力，等待IPF。pubsub。订阅（&#34；公告电路&#34；，流程公告）；setInterval（函数（）{ipfs.pubsub.publish（&#34；公告电路&#34；，&#34；对等活动&#34；）；），15000 ) ;</p><p>   Like the star nodes, it&#39;ll be important to host your own things as the ones in this post could go offline at any moment.</p><p>与星形节点一样，它&#39；We’重要的是，你可以自己管理自己的东西，因为这篇文章中的东西随时都可能离线。</p><p>  For the purposes of this example, you&#39;ll need to do a few things on a server hosting your own  go-ipfs       (opens new window) node. You&#39;ll also need a working Nginx install setup, which will be used for SSL, which is a requirement for browsers.</p><p>在本例中，您&#39；我需要在托管自己的go ipfs（打开新窗口）节点的服务器上执行一些操作。你&#39；我还需要一个正常工作的Nginx安装程序，它将用于SSL，这是浏览器的一个要求。</p><p>  First configure the Go node, enabling  WebSocket       (opens new window) support, and designate it as a relay so we can communicate with it from a browser by editing  ~/.ipfs/config to add the following settings:</p><p>首先配置Go节点，启用WebSocket（打开新窗口）支持，并将其指定为中继，以便我们可以通过编辑~/从浏览器与它通信。ipfs/config以添加以下设置：</p><p>  {  &#34;Addresses&#34; :  {  &#34;Swarm&#34;  :  [  &#34;/ip4/0.0.0.0/tcp/4011/ws&#34; ,  &#34;/ip6/::/tcp/4011/ws&#34;  ]  } ,  &#34;Swarm&#34; :  {  &#34;EnableRelayHop&#34; :  true  } }</p><p>{&#34；地址&#34；：{&#34；Swarm&#34；：[&#34；/ip4/0.0.0/tcp/4011/ws&#34；，&#34；/ip6/：：/tcp/4011/ws&#34；]&#34;Swarm&#34；：{&#34；EnableRelayHop&#34；：true}</p><p> Restart your  go-ipfs node however you normally do (possibly  systemctl --user restart ipfs), and we&#39;re mostly set up! We&#39;ve enabled regular WebSockets with relaying support, however we need secure WebSockets (outlined in the SSL section below) — otherwise browsers won&#39;t be able to connect to us.</p><p>以正常方式重新启动go ipfs节点（可能是systemctl——用户重新启动ipfs），我们&#39；我们已经准备好了！我们&#39；我们已经启用了具有中继支持的常规WebSocket，但是我们需要安全的WebSocket（在下面的SSL部分中概述）——否则浏览器将赢得&#39；我无法与我们联系。</p><p>    Using  p2p-circuit can be a bit tricky. Once we connect to the relay from a browser, we&#39;re not advertising that we&#39;re able to be reached through it! For this purpose, I&#39;ve created a Python script that runs alongside  go-ipfs and advertises the browser  js-ipfs peers it encounters over  PubSub       (opens new window) with a  p2p-circuit  multiaddress       (opens new window).</p><p>使用p2p电路可能有点棘手。一旦我们从浏览器连接到中继，我们&#39；我们不是在宣传我们&#39；我们可以通过它联系到你！为此，我&#39；我创建了一个Python脚本，它与go ipfs一起运行，并用一个p2p回路多地址（打开新窗口）在PubSub（打开新窗口）上公布它遇到的浏览器js ipfs对等点。</p><p>  You can find the Python script  here       (opens new window). It can be run with a simple  python ipfs_peeradvertiser.py. However, ensure you first edit  CIRCUIT with your own node&#39;s information, or you won&#39;t announce the peers correctly, and they won&#39;t know how to use your relay to connect to other peers.</p><p>您可以在这里找到Python脚本（打开新窗口）。它可以用一个简单的python ipfs_peeradvertiser运行。皮耶。但是，请确保首先使用自己的节点编辑回路&#39；这是你的信息，否则你赢了&#39；没有正确地宣布同龄人，他们赢了&#39；我不知道如何使用中继连接到其他同龄人。</p><p>  You can retrieve your own circuit info quite easily. Simply run  ipfs id on your  go-ipfs node to get your PeerID, then form the circuit URL like so:</p><p>你可以很容易地检索自己的电路信息。只需在go ipfs节点上运行ipfs id即可获得PeerID，然后按如下方式形成回路URL：</p><p>   You should see here where you simply fill out your domain name you got the SSL cert for, as well as your node&#39;s PeerID. For the script, the leading and trailing slash are required, too.</p><p>你应该在这里看到，你只需填写你获得SSL证书的域名，以及你的节点&#39；这是皮利德。对于脚本，前导斜杠和尾随斜杠也是必需的。</p><p>    Ensure you specify DNS6 or DNS4, depending on if you&#39;re forming an IPv6 or IPv4 address.  It&#39;s important to ensure you use DNS, otherwise browser nodes likely won&#39;t be able to connect. Also note the port 4430; if you used a different one, you&#39;ll need to specify that.</p><p>确保指定DNS6或DNS4，具体取决于&#39；正在重新形成IPv6或IPv4地址。它&#39；确保使用DNS很重要，否则浏览器节点可能会赢#39；我无法连接。还要注意端口4430；如果你用了另一个，你&#39；我需要具体说明一下。</p><p>    So far we&#39;ve setup WebRTC-Star and  p2p-circuit without SSL (unless you used the WebRTC-Star docker setup). If you want to use your nodes over the Internet, with a browser, they need to support SSL. If you&#39;re using the defaults currently WebRTC-Star should be running on port 9090 (no-SSL) and p2p-circuit will be on port 4011 (no-SSL). We&#39;re going to put those on port 9091 (SSL) and port 4430 (SSL), respectively.</p><p>到目前为止，我们&#39；ve设置不带SSL的WebRTC Star和p2p电路（除非使用WebRTC Star docker设置）。如果你想在互联网上通过浏览器使用你的节点，它们需要支持SSL。如果你&#39；重新使用默认设置当前WebRTC Star应在端口9090（无SSL）上运行，p2p电路将在端口4011（无SSL）上运行。我们&#39；我们将把它们分别放在端口9091（SSL）和端口4430（SSL）上。</p><p>    We&#39;re going to create two files from templates below. Ensure you&#39;re editing entries like  YOURDOMAIN.COM with the full domain (including subdomain) you plan to use for your services.</p><p>我们&#39；我们将从下面的模板创建两个文件。确保你&#39；重新编辑像YOURDOMAIN这样的条目。COM与您计划用于服务的完整域（包括子域）进行通信。</p><p>    map  $http_upgrade  $connection_upgrade  {	default upgrade ;	 &#39;&#39; close ; } upstream ipfs  {	 server  127.0 .0 .1 : 4011 ; } server  {	 server_name YOURDOMAIN .COM ;	 listen  4430  ssl ;	 ssl_certificate  /etc /letsencrypt /live /YOURDOMAIN .COM /fullchain .pem ;	 ssl_certificate_key  /etc /letsencrypt /live /YOURDOMAIN .COM /privkey .pem ;	 location  /  {		 proxy_set_header X -Forwarded -For  $proxy_add_x_forwarded_for ;		 proxy_pass  http : / /ipfs ;		 proxy_http_version  1.1 ;		 proxy_set_header Upgrade  $http_upgrade ;		 proxy_set_header Connection  $connection_upgrade ;		 proxy_set_header Host  $host ;	 } }</p><p>map$http#u upgrade$connection#u upgrade{default upgrade；&#39；&#39；close；}上游ipfs{server127.0.0.1:4011；}服务器{server_name YOURDOMAIN.COM；listen 4430 ssl；ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pem；ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pem；位置/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_For；proxy_pass http://ipfs；proxy_http_version 1.1；proxy_set_header Upgrade$http_Upgrade；proxy_set_header Connection$Connection_Upgrade；proxy_set_header Host$Host；}</p><p>     map  $http_upgrade  $connection_upgrade  {	default upgrade ;	 &#39;&#39; close ; } upstream star  {	 server  127.0 .0 .1 : 9090 ; } server  {	 server_name YOURDOMAIN .COM ;	 listen  9091  ssl ;	 ssl_certificate  /etc /letsencrypt /live /YOURDOMAIN .COM /fullchain .pem ;	 ssl_certificate_key  /etc /letsencrypt /live /YOURDOMAIN .COM /privkey .pem ;	 location  /  {		 proxy_set_header X -Forwarded -For  $proxy_add_x_forwarded_for ;		 proxy_pass  http : / /star ;		 proxy_http_version  1.1 ;		 proxy_set_header Upgrade  $http_upgrade ;		 proxy_set_header Connection  $connection_upgrade ;		 proxy_set_header Host  $host ;	 } }</p><p>map$http#u upgrade$connection#u upgrade{default upgrade；&#39；&#39；close；}上游星型{Server127.0.0.1:9090；}服务器{server_name YOURDOMAIN.COM；listen 9091 ssl；ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pem；ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pem；位置/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_For；proxy_pass http://star；proxy_http_version 1.1；proxy_set_header Upgrade$http_Upgrade；proxy_set_header Connection$Connection_Upgrade；proxy_set_header Host$Host；}</p><p> So in this example you can see we&#39;re accepting SSL on port 4430 — this is our &#34;wss port&#34; (WebSocket Secure) — and then passing it to the unsecured port locally on 4011 — this is our &#34;ws port&#34;. So if we want to connect to this node from a browser, we&#39;d use port 4430.</p><p>在这个例子中，你可以看到我们&#39；重新接受端口4430上的SSL-这是我们的&#34；wss端口&#34；（WebSocket安全）-然后在4011本地将其传递到不安全的端口-这是我们的&#34；ws-port&#34；。所以如果我们想从浏览器连接到这个节点，我们&#39；d使用端口4430。</p><p>    sudo systemctl stop nginx sudo certbot -d YOURDOMAIN.COM --standalone  # Edit YOURDOMAIN.COM to the domain you want a cert for, if you need multiple, fill in multiple or run the command multiple times sudo  ln -s /etc/nginx/sites-available/ipfs /etc/nginx/sites-enabled/ipfs sudo  ln -s /etc/nginx/sites-available/star /etc/nginx/sites-enabled/star sudo systemctl start nginx</p><p>sudo systemctl stop nginx sudo certbot-d YOURDOMAIN。COM--独立#编辑你的域名。COM到您想要证书的域，如果需要多个，请填写多个或多次运行命令sudo ln-s/etc/nginx/sites available/ipfs/etc/nginx/sites enabled/ipfs sudo ln-s/etc/nginx/sites available/star/etc/nginx/sites enabled/star sudo systemctl start nginx</p><p>     Whew! Since you made it this far, you might be wondering &#34;what is communication like?&#34; Luckily the answer is that it&#39;s  very easy in comparison to finding the peers, with only minor pitfalls. We&#39;re going to simply cover how we&#39;re using  PubSub       (opens new window) in the chat example, and exactly what pitfalls were found while it was developed.</p><p>唷！既然你走了这么远，你可能会想&#34；沟通是什么样的&#34; 幸运的是，答案是&#39；与寻找同龄人相比，这很容易，只有一些小缺陷。我们&#39；我们将简单介绍一下我们&#39；在聊天示例中重新使用PubSub（打开新窗口），以及在开发过程中发现了哪些陷阱。</p><p>    Using PubSub, we&#39;re able to subscribe to topics and retrieve any messages posted to those topics. In  js-ipfs, we can set a callback function, which gets called whenever a message is received:</p><p>使用PubSub，我们&#39；我们可以订阅主题并检索发布到这些主题的任何消息。在js ipfs中，我们可以设置一个回调函数，在收到消息时调用该函数：</p><p>      This is effectively what the chat demo is doing. It&#39;s subscribing to a global topic (named &#34;discochat-global&#34;), and simply relaying the messages people type around over PubSub.</p><p>这实际上就是聊天演示所做的。它&#39；s订阅一个全球主题（名为&#34；discochat global&#34；），简单地传递人们在PubSub上键入的信息。</p><p>    So let&#39;s say you&#39;ve done everything correctly. You&#39;re able to find peers using WebRTC-Star and  p2p-circuit — awesome! However, you might find your connections expire, and you&#39;re unable to restore them. I&#39;m not completely sure what causes this behaviour (probably some browser policy); however, we can do our best to mitigate these issues!</p><p>所以让我们&#39；比如说你&#39；我一切都做对了。你&#39；我们可以使用WebRTC Star和p2p circuit找到同龄人——太棒了！然而，你可能会发现你的连接过期了，你&#39；我们无法恢复它们。我&#39；我不完全确定是什么导致了这种行为（可能是一些浏览器策略）；然而，我们可以尽最大努力缓解这些问题！</p><p>    We stay connected to peers in a couple of ways. The first way is more direct: by subscribing to and sending a &#34;keepalive&#34; announcement over  discochat-keepalive every 4 seconds:</p><p>我们通过几种方式与同龄人保持联系。第一种方式更直接：订阅并发送&#34；保持活力&#34；每4秒通过discochat keepalive发布一次公告：</p><p>   This should help ensure we give peers looking to chat a high priority. Additionally, we report over  announce-circuit every 15 seconds to make sure we keep a connection to the circuit relay so we can connect to peers stuck behind a NAT. That&#39;s accomplished like so:</p><p>这将有助于确保我们优先考虑希望聊天的同龄人。此外，我们每15秒报告一次电路，以确保我们与电路继电器保持连接，以便我们可以连接到NAT后面的对等方。那&#39；他是这样完成的：</p><p>  // process announcements over the relay network, and publish our own keep-alives to keep the channel alive await ipfs .pubsub . subscribe ( &#34;announce-circuit&#34; , processAnnounce ) ; setInterval ( function ( ) {ipfs .pubsub . publish ( &#34;announce-circuit&#34; ,  &#34;peer-alive&#34; ) ; } ,  15000 ) ;</p><p>//通过中继网络处理公告，并发布我们自己的keep alives，以保持频道的活力，等待IPF。pubsub。订阅（&#34；公告电路&#34；，流程公告）；setInterval（函数（）{ipfs.pubsub.publish（&#34；公告电路&#34；，&#34；对等活动&#34；）；），15000 ) ;</p><p>   The Python script on the circuit relay will report a keepalive every 4 seconds. You may have noticed we&#39;re reporting &#34;peer-alive&#34; instead of &#34;keep-alive&#34;; this is to separate peer requests from relay requests, making it easier to tell when we no longer see a relay.</p><p>电路继电器上的Python脚本将每4秒报告一次keepalive。你可能已经注意到我们&#39；重新报告&#34；活着的同伴&#34；而不是&#34；保持活力&#34；；这是为了将对等请求与中继请求分开，以便在我们不再看到中继时更容易判断。</p><p>    Outside of the simplified version of  processAnnounce, in the real version there are a few variables used for tracking keep-alive and peer-alive. These are  lastAlive and  lastPeer, respectively. We even track the last time we bootstrapped via  lastBootstrap. Using all this, we can display the yellow status when we&#39;re only connected to peers (tracked via  lastPeer), and if we don&#39;t see a keep-alive for 35 seconds (and we haven&#39;t attempted a bootstrap in 60 seconds), we can attempt to re-connect to the bootstrap relay (and display a red status). This is accomplished like so:</p><p>除了ProcessAnnound的简化版本外，在真实版本中，还有一些用于跟踪keep alive和peer alive的变量。它们分别是lastAlive和lastPeer。我们甚至通过lastBootstrap跟踪上次引导的时间。使用所有这些，我们可以在&#39；我们只连接到对等点（通过lastPeer跟踪），如果我们不连接&#39；在35秒内没有看到保持活动状态（我们在60秒内没有尝试过引导），我们可以尝试重新连接引导继电器（并显示红色状态）。这是这样完成的：</p><p>  const bootstraps  =  [  &#39;/dns6/ipfs.thedisco.zone/tcp/4430/wss/p2p/12D3KooWChhhfGdB9GJy1GbhghAAKCUR99oCymMEVS4eUcEy67nt&#39; ,  &#39;/dns4/ipfs.thedisco.zone/tcp/4430/wss/p2p/12D3KooWChhhfGdB9GJy1GbhghAAKCUR99oCymMEVS4eUcEy67nt&#39; ] ; var lastAlive  =  0 ;	 // last keep-alive we saw from a relay var lastPeer  =  0 ; 	 // last keep-alive we saw from another peer var lastBootstrap  =  0 ;  // used for tracking when we last attempted to bootstrap (likely to reconnect to a relay) // if reconnect is true, it&#39;ll first attempt to disconnect from the bootstrap nodes async  function  dobootstrap ( reconnect )  { now  =  new   ( ) . getTime ( ) ;  if  (now -lastBootstrap  &lt;  60000 )  {  // don&#39;t try to bootstrap again if we just tried within the last 60 seconds  return ;  } lastBootstrap  = now ;  for  (i  in bootstraps )  {  if  (reconnect )  {  try  {  await ipfs .swarm . disconnect (bootstraps [i ] ) ;  }  catch  (e )  { console . log (e ) ;  }  }  else  {  await ipfs .bootstrap . add (bootstraps [i ] ) ;  }  await ipfs .swarm . connect (bootstraps [i ] ) ;  } } // check if we&#39;re still connected to the circuit relay function  checkalive ( )  { now  =  new   ( ) . getTime ( ) ;  if  (now -lastAlive  &gt;=  35000 )  {  if  (now -lastPeer  &gt;=  35000 )  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;red&#34; ;  }  else  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;yellow&#34; ;  }  dobootstrap ( true ) ;  // let&#39;s try to reconnect  }  else  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;lime&#34; ;  } } setInterval (checkalive ,  1000 ) ;</p><p>const bootstraps=[&#39；/dns6/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gj1gbhghakcur99ocymmevs4eucey67nt&#39；&#39；/dns4/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gy1gbhghakcur99ocymmevs4eucey67nt&#39；]；var lastAlive=0；//我们从继电器var lastPeer=0看到的最后一个保持活动状态；//上次我们从另一个对等服务器上看到的保持活动var lastBootstrap=0；//用于跟踪上次尝试引导时（可能重新连接到继电器）//如果重新连接为真，则为&#39；ll首先尝试断开与引导节点异步函数dobootstrap（reconnect）{now=new（）.getTime（）；if（now-lastBootstrap&lt；60000）{//don&#39；如果我们在最后60秒内尝试，请不要再次尝试引导返回；}lastBootstrap=now；对于（引导中的i）{if（重新连接）{try{wait ipfs.swarm.disconnect（引导[i]）；}catch（e）{console.log（e）；}else{wait ipfs.bootstrap.add（bootstraps[i]）；}等待ipfs。一大群连接（引导[i]）；}}//检查我们是否&#39；re仍然连接到电路中继函数checkalive（）{now=new（）.getTime（）；if（now-lastAlive&gt；=35000）{if（now-lastPeer&gt；=35000）{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；红色&#34；；}else{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；黄色&#34；；}dobootstrap（正确）；//让&#39；让我们尝试重新连接}else{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；酸橙设置间隔（checkalive，1000）；</p><p> 🌟 The above should be used with the full version of  processAnnounce, as it relies on  lastAlive and  lastPeer, which aren&#39;t updated in the simplified version.</p><p>🌟 以上内容应与完整版本的ProcessAnnound一起使用，因为它依赖于lastAlive和lastPeer，这两个版本不是&#39；t在简化版本中更新。</p><p>    I hope this was informative enough to get rolling. If you were successful in following this entire guide, you now have the ability to deploy powerful IPFS apps that run entirely in the browser, and leverage decentralized p2p whenever you can! I&#39;ve selected some helpful resources and shared them below for further reading:</p><p>我希望这篇文章能提供足够的信息，让我们开始行动。如果你成功地遵循了整个指南，你现在就可以部署完全在浏览器中运行的强大IPFS应用程序，并尽可能利用分散的p2p！我&#39；我选择了一些有用的资源，并在下面分享它们，以供进一步阅读：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ipfs/">#ipfs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>