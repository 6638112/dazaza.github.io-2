<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>交叉熵损失VS原木损失VS原木损失总和</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">交叉熵损失VS原木损失VS原木损失总和</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-19 10:26:58</div><div class="page_narrow text-break page_content"><p>在我之前的一篇关于交叉熵、KL发散和最大似然估计的博客文章中，我已经展示了这三件事在优化中的“等价性”。交叉熵损失在大多数最先进的机器学习分类模型中得到了广泛的应用，主要是因为优化它等价于最大似然估计。然而，可能还有其他损失用于分类问题。</p><p>在这篇博客中，我想讨论用于Logistic回归的日志损失、用于多类分类的交叉熵损失以及用于多类分类的日志损失总和。</p><p>这篇博文的前提条件已经在我的其他博文中进行了深入的讨论。为了完整起见，我在这里复制了一份。</p><p>要检查莱布尼茨积分规则的快速证明，请查看我的一篇关于此的博客文章。</p><p>根据莱布尼茨积分规则，我们还可以将导数的位置移到期望值之内或期望值之外。例如,。</p><p>如果$\mathbb{E}_{(x，y)\sim P(x，y)}\BIG[\mathscr{L}_{\theta}(x，y)\BIG]$是损失函数，则要计算整个损失相对于参数$\theta$的导数，相当于计算每个数据点$\mathscr{L}_{\theta}(x，y)$相对于。Y)\sim P(x，y)}\BIG[\frac{\Partial}{\Partial\theta}\mathscr{L}_{\theta}(x，y)\BIG]$。假设所有数据$(x，y)$都是均匀分布的，则只需计算每个数据点$\mathscr{L}_{\theta}(x，y)$相对于参数$\theta$贡献的损失的导数，然后取其平均值。这也是现代深度学习框架(如TensorFlow和PyTorch)的工作方式。</p><p>原木损失用于Logistic回归已有很长一段时间了。给定$(x，y)$，其中$x$是输入，$y$是$x$的标签，我们的目标是开发一个模型$f_{\theta}$，其中$\theta$是模型参数。使得$\tilde{y}=f_{\theta}(X)$尽可能接近$y$。对于Logistic回归，通常为$y=0$或$1$。$y=1$表示$x$属于某个类，而$y=0$表示$x$不属于某个类。</p><p>通常，Logistic回归将计算输入$x$的logit$z$，其中$z=g{\theta}(X)$，然后计算$z$的Sigmoid激活，以得到$y$，$\tilde{y}$的估计值，范围为$(0，1)$。具体地说，</p><p>用于拟合的损失函数称为对数损失，稍后我们会看到，它实际上是二元交叉熵损失。</p><p>我们进一步计算该对数损失相对于logit$z$的导数。</p><p>解释很简单。如果$\tilde{y}&gt；y$，$\frac{\Partial}{\Partial z}\mathscr{L}_{\theta}(x，y)&gt；0$，则梯度下降要使$z$变小。一旦$z$变小，$\tilde{y}$就会变小，与$y$的偏差也会变小。同样，如果$\tilde{y}&lt；y$，$\frac{\Partial}{\Partial z}\mathscr{L}_{\theta}(x，y)&lt；0$，则梯度下降要使$z$更大。一旦$z$变大，$\tilde{y}$将变大，与$y$的偏差将变小。</p><p>要更新模型参数$\theta$，我们需要计算关于$\theta$的导数。</p><p>交叉熵损失已被广泛用于深度学习中的分类问题。给定$(x，\mathbf{y})$，其中$x$是输入，$\mathbf{y}$是$x$的标签。如果$\mathbf{y}$是一个大小为$n$的单热点向量，并且$\mathbf{y}_i=1$，我们的目标是开发一个模型$f_{\theta}$，其中$\theta$是模型参数，使得$\tilde{\mathbf{y}}_i=f_{\theta}(X)$尽可能接近$\mathbf{y}_i$。请注意，使用交叉熵损失背后的动机是最大似然估计，这可能看不出来。但我在上一篇博客中已经讨论过了。</p><p>通常，多类分类将计算输入$x$的logits$\mathbf{z}$，其中$\mathbf{z}=g_{\theta}(X)$，然后计算$\mathbf{z}$的Softmax激活，以获得$\mathbf{y}$，$\tilde{\mathbf{y}}$，其中$\sum_{i=1}^{n}\tilde{。1]$表示[1，n]$中的$i\。具体地说，</p><p>我们进一步计算交叉熵损失关于logits$\mathbf{z}$的导数。</p><p>解释也很简单。如果$\tilde{\mathbf{y}}_k&gt；\mathbf{y}_k$，$\frac{\part}{\part\mathbf{z}_k}\mathscr{L}_{\theta}(x，\mathbf{y})&gt；0$，则梯度下降会使$\mathbf{z}_k$变小。一旦$\mathbf{z}_k$变小，$\tilde{\mathbf{y}}_k$将变小，其与$\mathbf{y}_k$的偏差也将变小。同样，如果$\tilde{\mathbf{y}}_k&lt；\mathbf{y}_k$，$\frac{\part}{\part\mathbf{z}_k}\mathscr{L}_{\theta}(x，\mathbf{y})&lt；0$，则梯度下降要使$\mathbf{z}_k$更大。一旦$\mathbf{z}_k$变大，$\tilde{\mathbf{y}}_k$将变大，其与$\mathbf{y}_k$的偏差将变小。</p><p>要更新模型参数$\theta$，我们需要计算关于$\theta$的导数。</p><p>如果我们有$n=2$的交叉熵损失，并将其与原木损失进行比较，我们会立即看到，原木损失的形式与二元交叉熵损失完全相同，Logistic回归的原木损失是多类别分类的交叉熵损失的特例，其中$n=2$，负类别($y=0$)的logit$z$是固定值$0$。</p><p>那么，如果我们有一个二进制分类问题，假设学习率和其他超参数相同，使用Logistic回归的对数损失和用于二进制分类的交叉熵损失对其建模有什么不同？我们可以看到，两个模型关于正logit$z$的梯度总是相同的。但是，在更新模型参数$\theta$时，两个模型的梯度会不同，因为一个模型只有一个logit，而另一个模型有两个logit。因此，虽然这两个模型是相似的，但说这两个模型完全相同是不正确的。</p><p>人们可能会问，对于二进制分类问题，哪种模型更好。很难说。但可以肯定的是，二元交叉熵模型相对容易过度拟合。原因如下：</p><p>二元交叉熵模型试图同时调整正负对数，而Logistic回归模型只调整一个对数，而另一个隐藏的对数总是$0，导致二元交叉熵模型中两个对数之间的差远大于Logistic回归模型中的两个对数之间的差值。</p><p>为了防止过度拟合，我们可以使用标签平滑来进行交叉熵损失。我以前已经讨论过了，我不打算在这里详述了。</p><p>虽然这种情况可能很少见，但我们可以将多类分类问题视为多个一对一分类，每个分类都是Logistic回归。给定$(x，\mathbf{y})$，其中$x$是输入，$\mathbf{y}$是$x$的标签。我们的目标是开发一个模型$f_{\theta}$，其中$\theta$是模型参数，使得$\tilde{\mathbf{y}}_j=f_{\theta}(X)$对于[1，n]$中的所有$j\都尽可能接近$\mathbf{y}_j$。注意，这不同于多类分类的交叉熵损失。</p><p>通常，多类分类将计算输入$x$的logits$\mathbf{z}$，其中$\mathbf{z}=g_{\theta}(X)$，然后计算$\mathbf{z}$的每个logit的Sigmoid激活，以获得$\mathbf{y}$，$\tilde{\mathbf{y}}$的估计值。其中值得注意的是，$\sum_{i=1}^{n}\tilde{\mathbf{y}}_i$和$\sum_{i=1}^{n}\mathbf{y}_i$不必等于1，并且$\tilde{\mathbf{y}}_i\in[0，1]$for$i\in[1，n]$。具体地说，</p><p>用于拟合的损失函数称为原木损失之和。每一类的分类可以看作是相互排斥的。TensorFlow为这种损失提供了一个实现，他们也将其称为tf.nn.sigmoid_Cross_熵_with_logits。</p><p>我们进一步计算这个对数损失和关于logits$\mathbf{z}$的导数。由于它几乎与对数损失关于logits$z$的导数完全相同，所以我们跳过了一些细节。</p><p>对于多类分类，其解释与交叉熵损失相同。如果$\tilde{\mathbf{y}}_k&gt；\mathbf{y}_k$，$\frac{\part}{\part\mathbf{z}_k}\mathscr{L}_{\theta}(x，\mathbf{y})&gt；0$，则梯度下降会使$\mathbf{z}_k$变小。一旦$\mathbf{z}_k$变小，$\tilde{\mathbf{y}}_k$将变小，其与$\mathbf{y}_k$的偏差也将变小。同样，如果$\tilde{\mathbf{y}}_k&lt；\mathbf{y}_k$，$\frac{\part}{\part\mathbf{z}_k}\mathscr{L}_{\theta}(x，\mathbf{y})&lt；0$，则梯度下降要使$\mathbf{z}_k$更大。一旦$\mathbf{z}_k$变大，$\tilde{\mathbf{y}}_k$将变大，其与$\mathbf{y}_k$的偏差将变小。</p><p>要更新模型参数$\theta$，我们需要计算关于$\theta$的导数。</p><p>该公式与用于多类分类交叉熵损失的公式完全相同。</p><p>因为我们已经看到交叉熵损失的梯度公式和对数损失总和是完全相同的，所以我们想知道两者之间是否有什么不同。</p><p>答案是，这两个模型之间存在差异，即使两个模型都在进行多类分类，即一个输入只有一个标签。线索在于$\tilde{\mathbf{y}}$的值。</p><p>假设$\mathbf{y}$是一个单热点编码向量，则$\sum_{i=1}^{n}\mathbf{y}_i=1$。在交叉熵损失中，$\sum_{i=1}^{n}\tilde{\mathbf{y}}_i=1$，而在原木损失总和中，$\sum_{i=1}^{n}\tilde{\mathbf{y}}_i\neq1$。</p><p>我们进一步假设$\mathbf{z}$对于这两个模型是相同的。当[1，n]$中$i的$\mathbf{z}_i&gt；\log{\frac{1}{n-1}}$时，很容易看出，对于[1，n]$中的$i\，交叉熵损失模型中的$tide{\mathbf{y}}_i$小于原木损失模型中的$tilde{\mathbf{y}}_i$。</p><p>这意味着梯度更新比交叉熵损失模型从原木损失总和模型中获得了更多的激励。这进一步意味着什么呢？当输入只有一个标号时，假设$\mathbf{y}$是一个单热点编码向量，假设$n$较大，原木损失之和模型比交叉熵损失模型从负类得到更多的激励，这将削弱正类的学习。</p><p>因此，如果上述所有假设都成立，学习单标签多类分类时应该使用交叉熵损失，而不是使用日志损失总和。</p><p>如果多类分类有多个标签怎么办？在原木损失和模型中，我们可以准备标签$\mathbf{y}_i=1$，其中$i$属于标签类别。在交叉熵损失模型中，由于交叉熵模型的局限性，一种直观的方法是假设一个输入有$k$标签，设标签$\mathbf{y}_i=\frac{1}{k}$，其中$i$属于标签类别，且$\sum_{i=1}^{n}\mathbf{y}_i=1$不变。</p><p>这一次，与对数损失之和模型相比，交叉熵损失要差一些，因为该模型不能很好地学习预测，特别是当标签数$k$较大时。这主要受Softmax激活功能的限制。在原木损失总和模型中，学习正类的动机不变，就好像它仍然是学习单标签分类问题一样。</p><p>好的，这个怎么样。给定具有$k$标签的输入，而不是使用一个数据点，我们准备$k$个数据点，这些数据点的输入完全相同，并且标签是代表每个$k$标签的单热点标签。它实际上等价于有一个数据点，其标签$\mathbf{y}_i=\frac{1}{k}$，其中$i$属于标签分类。我会让用户自己去找出为什么会是这样。提示是使用衍生品的期望值。</p><p>因此，在学习多标签多类分类时，不能使用交叉熵损失，而应该使用原木损失总和。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://leimao.github.io/blog/Conventional-Classification-Loss-Functions/">https://leimao.github.io/blog/Conventional-Classification-Loss-Functions/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/损失/">#损失</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/loss/">#loss</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mathbf/">#mathbf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>