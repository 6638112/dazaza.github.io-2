<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>丢弃缓存没有下降缓存 Dropping cache didn’t drop cache</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dropping cache didn’t drop cache<br/>丢弃缓存没有下降缓存 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-10 07:41:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/ee775fb835227d1dc3ff4700017a2420.png"><img src="http://img2.diglog.com/img/2021/5/ee775fb835227d1dc3ff4700017a2420.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Recently, while investigating an OOM (out-of-memory) problem, Twitter engineers found that the slab cache was increasing consistently, but the page cache was decreasing consistently. A closer look showed that the highest consumption of the slab cache was the dentry cache, and the dentry caches were charged to one memory control group (cgroup). It seems that the Linux kernel’s memory reclaimer only reclaimed the page cache, but didn’t reclaim the dentry cache at all.</p><p>最近，在调查OOM（内记忆中）问题的同时，Twitter工程师发现板坯缓存始终增加，但页面缓存始终持续减少。仔细观察表明，板式缓存的最高消耗是凹陷高速缓存，并且将凹凸缓存充电到一个存储器控制组（CGROUP）。似乎Linux内核的内存再生家只回收了页面缓存，但根本没有回收凹陷缓存。</p><p>    By debugging the problem, we found that there was a rare race condition in the shrinker code.</p><p>    通过调试问题，我们发现收缩器代码中存在罕见的竞争条件。</p><p>    To fully understand what prevented the slab cache from being dropped, we need to take a closer look at the Linux kernel internals, particularly the following memory management subsystem:</p><p>    要完全理解可防止板块缓存的丢弃，我们需要仔细查看Linux内核内部，特别是以下内存管理子系统：</p><p>      The memory resource for a machine is not infinite.There might be more demand than supply for memory resources if we run multiple programs simultaneously or run a very big program. Once available memory is low, the memory reclaimer (aka kswapd or direct reclaim) tries to evict “old” memory to free enough space to satisfy the allocators. The reclaimer scans lists (most of which are least-recently-used lists, aka LRU) to evict the not-recently-used memory. The lists include anonymous memory lists, file memory lists, and slab caches (Figure 1).</p><p>      机器的内存资源不是无限的。如果我们同时运行多个程序或运行非常大的程序，则可能比内存资源提供更多的需求。一旦可用内存低，内存再生机（AKA KSWAPD或直接回收）试图撤销“旧”内存以使足够的空间释放足够的空间来满足分配器。回收器扫描列表（其中大多数最近使用的列表，AKA LRU）以驱动最近使用的内存。列表包括匿名存储器列表，文件存储器列表和板坯缓存（图1）。</p><p>    The reclaimer scans all the above lists, except the unevictable list. However, sometimes the reclaimer only scans a few of them. For example, the reclaimer does not scan the anonymous memory list if the swap partition is not available.</p><p>    除非不可检测的列表，回收器扫描上述所有列表。但是，有时候收集者只会扫描其中一些。例如，如果交换分区不可用，则回收器不会扫描匿名存储器列表。</p><p>    When the reclaimer is trying to reclaim slab caches, it needs to call shrinkers. Slab caches are memory objects with different sizes managed by different subsystems. For example, this includes the inode cache and dentry cache. Some slab caches are reclaimable.  Since these caches hold the data for specific subsystems and have specific states, they can be reclaimed by dedicated shrinkers that understand how the caches are managed.</p><p>    当回收家正试图回收平板缓存时，需要调用缩减器。板坯缓存是具有不同子系统管理的不同大小的内存对象。例如，这包括inode缓存和凹陷缓存。一些板坯缓存是可回收的。由于这些缓存保持了特定子系统的数据并具有特定状态，因此可以通过专用的缩减器来回收，了解如何管理缓存。</p><p>  Filesystem metadata caches have a dedicated shrinker for each segment of metadata. The reclaimable filesystem metadata caches are in memory cgroup-aware and non-uniform memory access (NUMA) aware LRU lists. The shrinker scans these lists to reclaim some of the caches  when memory pressure is hit.</p><p>  文件系统元数据缓存为每个元数据段具有专用收缩器。可重选文件系统元数据缓存处于内存中的CGROUP感知和非统一内存访问（NUMA）感知LRU列表。收缩器扫描这些列表以在击中内存压力时回收一些缓存。 </p><p>    For modern data centers, cgroups are usually used to manage resources and to achieve better resource isolation. The memory cgroup is used to manage memory resources.</p><p>对于现代数据中心，CGroup通常用于管理资源并实现更好的资源隔离。内存CGROUP用于管理内存资源。</p><p>  Before the memory cgroup is present the aforementioned LRU lists are attached to NUMA nodes.</p><p>  在存在内存CGroup之前，上述LRU列表附加到NUMA节点。</p><p>    When the memory cgroup is present, the LRU lists are at per-memory-cgroup and per-node level. Each memory cgroup has its own dedicated LRU lists for the memory reclaimer Figure 3.</p><p>    当存在内存CGroup时，LRU列表处于每个存储器 -  CGROUP和每个节点级别。每个内存cgroup都有自己的专用LRU列表，用于存储器回收器图3。</p><p>    When reclaiming memory, the memory reclaimer traverses all memory cgroups to scan the LRU lists.</p><p>    在回收内存时，内存再生器遍历所有内存CGroups以扫描LRU列表。</p><p>  For a typical production deployment, there may be around 40 shrinkers, including filesystem metadata shrinkers for each super block.</p><p>  对于典型的生产部署，可能存在大约40个收缩器，包括每个超级块的文件系统元数据收缩器。</p><p>  When there are many memory cgroups and many shrinkers, serious scalability problems may occur if all the shrinkers are called for all the memory cgroups. These problems happen even though there is not a reclaimable object for some shrinkers.</p><p>  当存在许多内存CGroups和许多收缩器时，如果调用所有收缩器，可能会出现严重的可扩展性问题，因为所有的收缩器都被调用所有存储器CGroups。即使某些收缩者没有一个可替代的对象，也会发生这些问题。</p><p>  The upstream kernel introduced  an optimization, called shrinker_maps. It is a bitmap that indicates which shrinkers have reclaimable objects so that they are called. The bitmap is set when a new object is added to the LRU, and is cleared when the LRU is empty. The optimization made the aforementioned scalability issue gone. When one memory cgroup is offlined (for example, when the directory is removed) its LRUs are spliced to its parent memory cgroup and the parent memory cgroup’s bitmap is set accordingly.</p><p>  上游内核引入了一个叫做Shrinker_maps的优化。它是一个位图，指示哪些收缩器具有可回收物体，以便调用它们。当新对象添加到LRU时，将设置位图，并在LRU为空时清除。优化使上述可​​扩展性问题消失了。当一个存储器CGROUP被剥离时（例如，当目录被删除时）其LRU被拼接到其父存储器CGROUP并且相应地设置父存储器CGROUP的位图。 </p><p>  The following command traverses all LRU lists, from all memory cgroups, to shrink all reclaimable objects.</p><p>以下命令遍历所有LRU列表，从所有内存cgroups缩小所有可替换对象。</p><p>    By checking memory related statistics (for example, /proc/meminfo and /proc/slabinfo) exported by the kernel and checking slab usage using slabtop, it seems that dentry caches consume around 2GB memory under one memory cgroup. This means there should be around 10 million dentry objects since typically the dentry object size is 192 bytes. The dropping cache should be able to shrink most of them.</p><p>    通过检查内存相关的统计信息（例如，使用Slabtop导出的内核和检查板坯使用的/ proc / meminfo和/ proc / slabinfo），似乎凹陷缓存在一个存储器cgroup下围绕2gb内存消耗。这意味着应该有大约1000万个凹陷对象，因为通常凹陷对象大小是192个字节。丢弃缓存应该能够缩小大部分时间。</p><p>  However, there might be a couple of reasons that the dropping cache doesn’t drop slab caches. For example, the LRU list might be short or the objects might be referencing or locked when scanning and therefore temporarily unreclaimable.The next step is to get some insight about what is going on with the shrinkers.</p><p>  但是，可能存在丢弃缓存不会丢弃平板缓存的几个原因。例如，LRU列表可能是短暂的，或者对象可能是在扫描时引用或锁定，因此暂时无法激起。下一步是对收缩者进行一些洞察力。</p><p>  The Linux kernel provides plenty of ways to observe how the kernel runs. The built-in tracepoints are one of the most used ones. There are two tracepoints about shrinker:</p><p>  Linux内核提供了大量的方法来观察内核运行方式。内置跟踪点是最常用的trakepoints之一。关于收缩员有两个Tracepoints：</p><p>    There are a couple of different tools to enable tracepoints and get tracing logs. For example, directly manipulating the files under debugfs, perf, or trace-cmd. We personally prefer  trace-cmd, which is a package that supports plenty of commands for kernel tracing. The package is also supported by almost all distros. For the usage of trace-cmd, please refer to the  manpage.</p><p>    有几种不同的工具可以启用跟踪点并获取跟踪日志。例如，直接在DebugFS，PERF或Trace-CMD下操作文件。我们个人更喜欢Trace-CMD，这是一个支持大量命令的内核跟踪命令的包。该包装也支持几乎所有的发行版。有关Trace-CMD的使用，请参阅该操作。</p><p>          kswapd1-474 [066] .... 508610.111172: mm_shrink_slab_start: super_cache_scan+0x0/0x1a0 000000000043230d: nid: 1 objects to shrink 0 gfp_flags GFP_KERNEL cache items 38084993 delta 18596 total_scan 18596 priority 12 kswapd1-474 [066] .... 508610.139951: mm_shrink_slab_end: super_cache_scan+0x0/0x1a0 000000000043230d: nid: 1 unused scan count 0 new scan count 164 total_scan 164 last shrinker return val 18432</p><p>          KSWAPD1-474 [066] .... 508610.111172：mm_shrink_slab_start：super_cacHe_scan + 0x0 / 0x1a0 000000000043230d：n：n：n：n：1缩小0 gfp_flags gfp_kernel缓存项38084993 delta 18596 total_scan 18596优先级 KSWAPD1-474 [066] .... 508610.139951：mm_shrink_slab_end：super_cache_can + 0x0 / 0x1a0 000000000043230d：n：1：1未使用扫描计数0新扫描计数164 TOLL_SCAN 164最后收缩器返回VAL 18432</p><p>  By analyzing the tracing log, it seems that the dentry caches under some cgroups which consume the most dentry caches were not scanned at all. This means that the shrinker was even not called. It definitely looks odd!</p><p>  通过分析跟踪日志，似乎在一些消耗最凹陷的缓存中的凹凸缓存根本没有扫描。这意味着收缩率甚至没有被称为。它肯定看起来很奇怪！ </p><p>  As aforementioned, the only way that the shrinkers can be prevented from being called is if the shrinker_map bitmap is cleared. But the LRU list must be empty. Is it possible that the shrinker bitmap is cleared, even though there are still objects on the LRU list? We need to inspect shrinker-related kernel data structures to find out what was going on.</p><p>如上所述，如果已清除Shrinker_Map位图，则可以防止收缩器被调用的唯一方法是。但LRU列表必须是空的。即使LRU列表上仍有对象，是否有可能清除收缩器位图可能？我们需要检查与收缩相关的内核数据结构，以了解正在发生的内容。</p><p>  We could inspect kernel data structures by a couple of tools, for example, the well-known  crash-utility. Here we used  drgn. Drgn supports programming with Python and live debugging.</p><p>  我们可以通过几个工具检查内核数据结构，例如众所周知的崩溃实用程序。在这里，我们使用了Drgn。 DRGN支持使用Python和Live调试的编程。</p><p>  With the Python script below, we can easily inspect the length of the LRU list and shrinker_map bitmap for a specific memory cgroup:</p><p>  使用下面的Python脚本，我们可以轻松检查LRU列表和Shrinker_Map位图的长度，用于特定内存cgroup：</p><p>  for user in css_for_each_child(prog[&#39;root_mem_cgroup&#39;].css): if (user.cgroup.kn.name.string_().decode() == &#34;user.slice&#34;): breakmemcg = container_of(user, &#39;struct mem_cgroup&#39;, &#39;css&#39;)nr_items=0for sb in list_for_each_entry(&#39;struct super_block&#39;, prog[&#39;super_blocks&#39;].address_of_(), &#39;s_list&#39;): nr_items += sb.s_dentry_lru.node.memcg_lrus.lru[9].nr_itemsbitmap = memcg.nodeinfo[0].shrinker_map.map[0]</p><p>  对于CSS_FOR_EACH_CHILD（PROG [＆＃39; root_mem_cgroup＆＃39;]。CSS）的用户： if（user.cgroup.kn.name.string _（）。解码（）==＆＃34; user.slice＆＃34;）： 休息memcg = container_of（用户，＆＃39; struct mem_cgroup＆＃39 ;,＆＃39; css＆＃39;）nr_items = 0.对于list_for_each_entry的sb（＆＃39; struct super_block＆＃39; prog [＆＃39; super_blocks＆＃39;]。地址_of_（），＆＃39; s_list＆＃39;）： nr_items + = sb.s_dentry_lru.node.memcg_lrus.lru [9] .nr_itemsBitmap = memcg.nodeinfo [0] .shrinker_map.map [0]</p><p>  The nr_items  shows the length of the dentry LRU lists and bitmap shows the shrinker_map bitmap.</p><p>  NR_ITEMS显示了DENTRY LRU列表的长度，位图显示了SHRINKER_MAP位图。</p><p>  The result shows that there were around 10 million dentry cache objects on the LRU list, and  that most of them were reclaimable. So, the LRU list is definitely not empty. But the shrinker_map bitmap shows the corresponding bit was cleared.</p><p>  结果表明，LRU列表中有大约1000万个凹陷缓存对象，大多数是可替代的。所以，LRU列表绝对不是空的。但是shrinker_map位图显示相应的位清除。</p><p>  It really seems weird that the bit was cleared even though there were abundant reclaimable caches. It smells like a kernel bug.</p><p>  即使有丰富的可替代的高速缓存，这真的很奇怪。它闻起来像仁虫。 </p><p>    By reading the kernel code, it seems that the kernel clears the bitmap if and only if the corresponding LRU list is empty. The kernel sets the bit when:</p><p>通过读取内核代码，似乎内核似乎且仅当相应的LRU列表为空时才清除位图。内核设置了以下位置：</p><p>    Since our use case creates and removes memory cgroups very frequently, reparenting happens very often. It seems like there might be some problems with reparenting.</p><p>    由于我们的用例非常频繁地创建和删除内存CGroups，因此通常经常发生重新处理。它似乎可能有一些重新定位问题。</p><p>    Once the race condition is located, the fix seems easy. It actually just has a couple of lines:</p><p>    一旦比赛条件所在，修复似乎很容易。它实际上只有几条线条：</p><p>  diff --git a/mm/list_lru.c b/mm/list_lru.cindex 8de5e37..1e61161 100644--- a/mm/list_lru.c+++ b/mm/list_lru.c@@ -534,7 +534,6 @@ static void memcg_drain_list_lru_node(struct list_lru *lru, int nid, 	struct list_lru_node *nlru = &amp;lru-&gt;node[nid]; 	int dst_idx = dst_memcg-&gt;kmemcg_id; 	struct list_lru_one *src, *dst;-	bool set;  	/* 	 * Since list_lru_{add,del} may be called under an IRQ-safe lock,@@ -546,11 +545,12 @@ static void memcg_drain_list_lru_node(struct list_lru *lru, int nid, 	dst = list_lru_from_memcg_idx(nlru, dst_idx);  	list_splice_init(&amp;src-&gt;list, &amp;dst-&gt;list);-	set = (!dst-&gt;nr_items &amp;&amp; src-&gt;nr_items);-	dst-&gt;nr_items += src-&gt;nr_items;-	if (set)++	if (src-&gt;nr_items) {+		dst-&gt;nr_items += src-&gt;nr_items; 		memcg_set_shrinker_bit(dst_memcg, nid, lru_shrinker_id(lru));-	src-&gt;nr_items = 0;+		src-&gt;nr_items = 0;+	}  	spin_unlock_irq(&amp;nlru-&gt;lock); }</p><p>  diff --git a / mm / list_lru.c b / mm / list_lrru.c索引8DE5E37..1E61161 100644--- a / mm / list_lru.c+++ b / mm / list_lru.c@@ -534,7 + 534,6 @@静态void memcg_drain_list_lru_node（struct list_lru * lru，int nid， struct list_lru_node * nlru =＆amp; lru-＆gt;节点[nid]; int dst_idx = dst_memcg-＆gt; kmemcg_id; struct list_lru_one * src，* dst; -  BOOL设置;  / * *由于List_lru_ {add，del}可以在IRQ安全锁下调用，@@ -546,11 + 545,12 @@静态void memcg_drain_list_lru_node（struct list_lru * lru，int nid， dst = list_lru_from_memcg_idx（nlru，dst_idx）;  list_splice_init（＆amp; src-＆gt; list，＆amp; dst-＆gt; list）; -  set =（！dst-＆gt; nr_items＆amp;＆amp; src-＆gt; nr_items）; -  dst-＆gt; nr_items + = src-＆gt; nr_items; - 如果（设置）++ if（src-＆gt; nr_items）{+ dst-＆gt; nr_items + = src-＆gt; nr_items; memcg_set_shrinker_bit（dst_memcg，nid，lru_shrinker_id（lru））; -  src-＆gt; nr_items = 0;+ src-＆gt; nr_items = 0;+}  spin_unlock_irq（＆amp; nlru-＆gt;锁定）; }</p><p>  We contributed the patch to the upstream kernel and it has been merged into the mainline kernel tree. See  commit on git.kernel.org.</p><p>  我们将修补程序源到上游内核，它已被合并到主线内核树中。请参阅git.kernel.org提交。</p><p>    To investigate the issue, we used the drill-down analysis method and USE method (Utilization, Saturation and Error). Our process was the following:,</p><p>    要调查该问题，我们使用了深入的分析方法和使用方法（利用率，饱和度和错误）。我们的过程如下：</p><p>        Monitoring: This is used for continually recording statistics over time. The historic data can be pulled so that time-based usage trends can be identified. Sometimes the data sources for monitoring overlaps with statistics tools.</p><p>        监控：这用于随着时间的推移不断记录统计数据。可以拉动历史数据，以便可以识别基于时间的使用趋势。有时数据源用于监视与统计工具的重叠。 </p><p>  Statistics tools: The kernel has a lot of built-in statistics which can be examined by reading /proc, /sys, or 3rd party tools such as, iostat. They are usually used to check resource utilization. Typically, examining these statistics is the first step to analyzing a performance problem or kernel bug.</p><p>统计工具：内核有很多内置统计数据，可以通过读取/ proc，/ sys或第三方工具（如iostat）进行检查。它们通常用于检查资源利用率。通常，检查这些统计数据是分析性能问题或内核错误的第一步。</p><p>  Tracepoints: The kernel is also equipped with plenty of built-in tracepoints. They can be turned on or off on the fly using various means. Tracing is quite powerful and can show tons of details about kernel internal activities. It is suitable for deeper inspection. But the tracepoints are definitely not available everywhere. Dynamic tracing could be used where tracepoints are not available.</p><p>  trapepoints：内核也配有大量内置的trapepoints。它们可以使用各种手段打开或熄灭。跟踪是非常强大的，可以显示有关内部内部活动的大量细节。它适用于更深层次的检查。但是Trapepoints绝对不在任何地方使用。可以使用动态跟踪，其中Trapepoints不可用。</p><p>  Kernel data structures inspectors: Sometimes even tracepoints and dynamic tracing doesn’t reveal enough information to figure out the root causes. In this case, the kernel developers have to inspect the kernel data structures. Usually such inspectors provide built-in commands and advanced language programming interfaces to make the inspection much easier. However, a developer must have deep knowledge about kernel internals to use them.</p><p>  内核数据结构检查员：有时甚至跟踪点和动态跟踪都没有透露足够的信息来弄清楚根本原因。在这种情况下，内核开发人员必须检查内核数据结构。通常，这种检查员提供内置命令和高级语言编程接口，以使检查更容易。但是，开发人员必须深入了解内核internals来使用它们。</p><p>  Inspection of code: To locate exactly where the bug is and to come up with an appropriate fix, code inspection is necessary.</p><p>  检查代码：要确定错误的位置并提出适当的修复，是必要的代码检查。</p><p>    Memory reclamation is one of the most complicated parts of the Linux kernel. It is full of heuristic algorithms, complex corner cases, complicated data structures, and convoluted interaction with other subsystems. Memory reclamation is the core part of the Linux kernel and is relied upon by other subsystems. However, the bugs or suboptimal behaviors of memory reclamation may take a long time to get discovered. The fixes may be quite subtle and the validation may take substantial efforts to guarantee no regressions.</p><p>    内存填充是Linux内核最复杂的部分之一。它充满了启发式算法，复杂的角落案例，复杂的数据结构和与其他子系统的复杂交互。内存填写是Linux内核的核心部分，并由其他子系统依赖于此。但是，内存填海的错误或次优行为可能需要很长时间才能发现。修复程序可能非常微妙，验证可能需要实质性的努力来保证没有回归。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.twitter.com/engineering/en_us/topics/open-source/2021/dropping-cache-didnt-drop-cache.html">https://blog.twitter.com/engineering/en_us/topics/open-source/2021/dropping-cache-didnt-drop-cache.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cache/">#cache</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>