<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Bash中安全地做事 How to do things safely in Bash</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to do things safely in Bash<br/>如何在Bash中安全地做事 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 01:17:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/c8b8aea0c672bfdf58ebfc370066e086.png"><img src="http://img2.diglog.com/img/2021/4/c8b8aea0c672bfdf58ebfc370066e086.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Permalink       Like programming in C or driving a car,contemporary shellscript languages require some knowledge and discipline to use safely,but that&#39;s not to say it can&#39;t be done.</p><p>永久性链接，如C或驾驶汽车，当代壳牌语言需要一些知识和纪律来安全使用，但不是说它可以＆＃39; t完成。</p><p>   Shellharden suggests, and can apply, changes to remove brittleness in shellscripts. This is in accordance with  ShellCheck and  BashPitfalls – Shellharden shall not disagree with these.</p><p>   Shellharden建议，并且可以应用，以删除壳牌中的脆性。这符合Shellcheck和Bashpitfalls  -  Shellharden不同意这些。</p><p> The problem is that not all scripts will work with their brittleness simply removed, because  that was their working principle, and must be rewritten quite differently.Thus the need for a human in the loop and a holistic methodology.</p><p> 问题是，并非所有脚本都将只是删除他们的脆性，因为这是他们的工作原理，并且必须相当不同。这些循环中的人类的需要和整体方法。</p><p>   It is the goal and realization of this methodology thatall bash scripts are possible to rewrite into wellformedness,a representation free of those idiomatic bugs that the language otherwise practically imposes.This is because the set of bad language features is finite, and each has a substitute.</p><p>   这是这种方法的目标和实现，即将Bash脚本可以重写成伟大的脚本，这是一种没有那些语言实际上施加的惯用错误的表示。这是因为糟糕的语言特征是有限的，每个都有一个替代品。</p><p> Unfortunately,  it is hard to defend the correct way of doing something when it isn&#39;t also the seemingly simplest.With this in mind, the python manifesto ( python3 -c &#39;import this&#39;),which says that there should only be one obvious way to do things, and that &#34;explicit is better than implicit&#34;,makes a lot of sense.While that says something about the impossibility of convincing the vast number of users to adopt a safe methodology,it is nevertheless possible for those who care.</p><p> 不幸的是，当它不是看似简单的时，很难捍卫做某事的正确方法。在这态度，Python宣言（Python3 -c＆＃39;导入这个＆＃39;），说应该只有一个明显的做事方式，而且＃34;显式比隐含的和＃34更好;，发挥了很多意义。这说明了一些不可能让广大用户采用的人采用的东西安全方法，仍然可以为那些关心的人。</p><p>  Fish is a relief – easy to use correctly, but (still) lacks a strict mode. → Disqualified.</p><p>  鱼是一种缓解 - 易于使用，但（仍然）缺乏严格的模式。 →取消资格。</p><p>  That is in principle the wrong question. Always use the right tool for the job™.Shellscript languages are languages for running programs, and for using that as a building block.That is a domain of its own.</p><p>  这原本原则上是错误的问题。始终使用Job™.shellscript语言的正确工具是用于运行程序的语言，并且使用该块作为构建块。这是一个自己的域。 </p><p> This is by no means a defense of shellscripting.Shellscripts keep getting written, and this is how to do it safely.However, there is one greater sin than writing something that is obviously a shellscript.When you know you have a shellscript, you know what to worry about, you can bring in the right expertise, and you have the full arsenal of shell linters.Not so much if  implicitly invoking the shell with improper quoting.</p><p>这绝不是Shellscripting.shellscripts继续写入，这就是如何安全地完成。然而，有一个更大的罪，而不是写出显而易见的东西。当你知道你有一个shellscript，你知道担心的是，您可以带来正确的专业知识，并且您拥有shell linters的完整阿森纳。如果隐含地调用Quoting不正确地调用shell，那么不多。</p><p>  If there is anything like a driver&#39;s license for safe bash coding,it must be rule zero of  BashPitfalls: Always use quotes.</p><p>  如果有类似驾驶员和＃39;安全性Bash编码的许可证，它必须是Bashpitfalls的规则零：始终使用引号。</p><p> An unquoted variable is to be treated as an armed bomb: It explodes upon contact with whitespace and wildcards. Yes, &#34;explode&#34; as in  splitting a string into an array. Specifically, variable expansions, like  $var, and also command substitutions, like  $(cmd), undergo  word splitting, whereby the string is split on any of the characters in the special  $IFS variable, which is whitespace by default. Furthermore, any wildcard characters ( *?) in the resulting words are used to expand those words to match files on your filesystem ( indirect pathname expansion). This is mostly invisible, because most of the time, the result is a 1-element array, which is indistinguishable from the original string value.</p><p> 一个未引发的变量将被视为武装炸弹：它在与空格和通配符联系后爆炸。是的，＆＃34;爆炸＆＃34;与将字符串分成阵列一样。具体而言，像$ var一样的可变扩展，也像$（cmd）一样，以$（cmd）相同的命令替换，其中字符串在特殊$ ifs变量中的任何字符上拆分，默认情况下是空格。此外，生成单词中的任何通配符（*）用于扩展这些单词以匹配文件系统上的文件（间接路径名扩展）。这大多是隐形的，因为大多数情况下，结果是一个1元素数组，它与原始字符串值无法区分。</p><p>      There are exceptions where quoting is not necessary, but because it never hurts to quote, and the general rule is to be scared when you see an unquoted variable, pursuing the non-obvious exceptions is, for the sake of your readers, questionable. It looks wrong, and the wrong practice is common enough to raise suspicion: Enough scripts are being written with broken handling of filenames that whitespace in filenames is often avoided…</p><p>      引用不需要例外情况，但由于引用永远不会伤害，并且当您看到一个未引用的变量时，一般规则是害怕的，因为为了读者，追求非明显的例外是值得怀疑的。它看起来不对，错误的做法足以提出怀疑：用损坏的文件处理频繁处理文件名常常避免的空格来写入足够的脚本...</p><p> The exceptions only matter in discussions of style – feel welcome to ignore them. For the sake of style neutrality, Shellharden does honor a few exceptions:</p><p> 只有在讨论风格中的例外情况 - 欢迎忽略它们。为了风格中立，Shellharden确实尊重一些例外：</p><p> the magical context between double-brackets ( [[ and  ]]) – this is a language of its own.</p><p> 双括号之间的神奇背景（[[和]） - 这是自己的语言。</p><p>    While it is possible to use this style correctly, it is harder:  Backticks require escaping when nested, and examples in the wild are improperly quoted more often than not.</p><p>    虽然可以正确使用此样式，但它更难：反击需要在嵌套时逃逸，并且野外的示例比不是不正确的报价。 </p><p>     It does not hurt to always use braces, in theory, but in your author&#39;s experience, there is a strong negative correlation between unnecessary use of braces and proper use of quotes – nearly everyone chooses the &#34;bad and verbose&#34; instead of &#34;good but verbose&#34; form!</p><p>总是在理论上始终使用大括号，但在您的作者中没有受伤，但在您的经验中，不必要使用括号和正确使用引号之间存在强烈的负相关性 - 几乎每个人都选择＆＃34;坏和兼容＃34;而不是＆＃34;好但冗长＆＃34;形式！</p><p>  Fear of the wrong thing: Instead of worrying about the real danger (missing quotes), a beginner might worry that a variable named  $prefix would influence the expansion of  &#34;$prefix_postfix&#34; – this is simply not how it works.</p><p>  害怕错误的事情：而不是担心真正的危险（丢失的报价），初学者可能担心命名为$前缀的变量会影响＆＃34; $ prefix_postfix＆＃34的扩展; - 这根本不是它的工作原理。</p><p> The decision was made to ban unnecessary use of braces: Shellharden will rewrite all these variants into the simplest good form.</p><p> 该决定是为了禁止不必要的括号使用：Shellharden将把所有这些变体重写为最简单的良好形式。</p><p>    Because Shellharden is not a style formatter, it is not supposed to change correct code. This is true of the &#34;good (concatenation)&#34; example: As far as shellharden is concerned, this is the holy (canonically correct) form.</p><p>    因为shellharden不是风格格式化器，因为它不应该改变正确的代码。这是＆＃34;好（串联）＆＃34的真实;示例：就贝拉图界而言，这是圣洁（规范纠正）的形式。</p><p> Shellharden currently adds and removes braces on an as-needed basis: In the bad example, var1 becomes interpolated with braces, but braces are not accepted on var2 even in the good (interpolation) case, since they are never needed at the end of a string. The latter requirement may well be lifted.</p><p> Shellharden目前根据需要添加和删除括号：在错误的例子中，Var1与括号内插，但即使在良好（插值）案例中也不会在Var2上接受括号，因为它们永远不会在A结束时所需的细绳。后一种要求可能会被提升。</p><p>  Unlike normal  identifier variable names (in regex:  [_a-zA-Z][_a-zA-Z0-9]*), numbered arguments require braces (string interpolation or not). ShellCheck says:</p><p>  与普通标识符变量名称不同（在Regex中：[_A-ZA-Z] [_ A-ZA-Z0-9] *），编号参数需要大括号（字符串插值或不）。 Shellcheck说：</p><p>  This was deemed too subtle to either fix or ignore: Shellharden will print a big error message and bail if it sees this.</p><p>  这被视为太微妙地修复或忽略：如果看到这一点，贝拉德将打印大错误消息和保释。 </p><p>   In order to be able to quote all variables, you must use real arrays when that&#39;s what you need, not whitespace delimited strings.</p><p>为了能够引用所有变量，您必须使用真实数组，当您需要的东西时，而不是空白分隔字符串。</p><p> The syntax is verbose, but get over it. This bashism single-handedly disqualifies the POSIX shell for the purpose of this guide.</p><p> 语法是冗长的，但克服它。此Bashism单手中取消了POSIX Shell以获取本指南的目的。</p><p>  files=( a b)duplicates=()for f in &#34;${files[@]}&#34;; do if cmp -- &#34;$f&#34; other/&#34;$f&#34;; then duplicates+=(&#34;$f&#34;) fidoneif [ &#34;${#duplicates[@]}&#34; -gt 0 ]; then rm -- &#34;${duplicates[@]}&#34;fi</p><p>  files =（a b）flocicates =（）for f中的＆＃34; $ {files [@]}＆＃34 ;;如果cmp  - ＆＃34; $ f＆＃34;其他/＆＃34; $ f＆＃34 ;;然后重复+ =（＆＃34; $ f＆＃34;）fidoneif [＆＃34; $ {＃duplicates [@]}＆＃34; -gt 0];然后rm  - ＆＃34; $ {副本[@]}＆＃34; fi</p><p>  files=&#34; \ a \ b \&#34;duplicates=for f in $files; do if cmp -- &#34;$f&#34; other/&#34;$f&#34;; then duplicates+=&#34; $f&#34; fidoneif ! [ &#34;$duplicates&#34; = &#39;&#39; ]; then rm -- $duplicatesfi</p><p>  文件=＆＃34; \ a \ b \＆＃34;重复= f for f f for $文件;如果cmp  - ＆＃34; $ f＆＃34;其他/＆＃34; $ f＆＃34 ;;然后重复+ =＆＃34; $ f＆＃34; fidoneif！ [＆＃34; $副本＆＃34; =＆＃39;＆＃39; ];然后rm  -  $ duplicatesfi</p><p> Look how similar the two examples are: There is no algorithmical difference between using real arrays instead of strings as a (bad) substitute.A bonus point goes to the array syntax for not needing line continuations, making those lines possible to comment.They are not equivalent, of course, as the &#34;bad&#34; example uses a whitespace delimited string,which breaks down as soon as a filename contains whitespace, and risks deleting the wrong files.</p><p> 看看这两个例子是多么相似：使用真实阵列而不是字符串之间没有算法差异，因为（坏）替换为（坏）替换物。对于不需要的行持续，将奖励点转到阵列语法，使得这些行成为评论。它们是可能的当然不是等同的，作为＆＃34;坏＆＃34;示例使用空白分隔的字符串，一旦文件名包含空格，并且删除错误文件的风险就会删除。</p><p> Is the second example fixable? In theory, yes; in practice, no.While it is  possible to represent a list in a string,even approachable if a suitable delimiter is known,it becomes hairy (escaping and unescaping the delimiter) to do 100% generically correct.Worse, getting it back into array form can not be abstracted away (try  set -- a b c in a function).The final blow is that fighting such an abstraction failure of the language is pointless if you can choose a different language.</p><p> 是第二个例子可固定吗？理论上，是的;在实践中，编号是可以在字符串中表示列表，即使是已知合适的分隔符，也可以转移，它变为毛茸茸（逃逸和未分隔的分隔符），以便掌握100％.worse，将其恢复到数组中表格无法抽出（尝试设置 -  ABC在功能中）。最终的打击是，如果您可以选择不同的语言，那么毫无意义地争取这种抽象失败。</p><p> Arrays is the feature that becomes absurdly impractical to program correctly without. Here is why:</p><p> 阵列是没有正确编程的荒谬不切实际的功能。这就是为什么： </p><p> You need  some datastructure, that can take zero or more values, for passing zero or more values around cleanly.</p><p>您需要一些数据结构，可以采用零个或多个值，以便干净地传递零个或多个值。</p><p> In particular,  command arguments are fundamentally arrays. Hint: Shell scripting is all about commands and arguments.</p><p> 特别是，命令参数基本上是数组。提示：shell脚本是关于命令和参数的。</p><p> All POSIX shells secretly support arrays anyway, in the form of the argument list  &#34;$@&#34;.</p><p> 无论如何，所有POSIX Shell都暗中支持阵列，以参数列表＆＃34; $ @＆＃34;</p><p> The recommendation of this guide must therefore be to not give POSIX compatibility a second thought.The POSIX shell standard is hereby declared unfit for our purposes.Likewise, sadly, for minimalistic POSIX compatible shells like  Dash and Ash that don&#39;t support arrays either.As for Zsh, it supports a superset of Bash&#39;s array syntax, so it is good.</p><p> 因此，本指南的建议必须是第一个思想的Posix兼容性。特此声明Posix Shell标准宣布不适合我们的目的。很可悲的是，对于Don＆＃39; t支持阵列的划线和灰烬的简约Posix兼容壳。 zsh，它支持zh，它支持zhash＆＃39; s阵列语法的超集，所以它很好。</p><p> The lack of a minimalistic shell with array support is a bummer for embedded computuers, where shipping another language is cost sensitive, yet expectations for safety are high. Busybox is impressive for what you get in a small size, but as part of it, you get Ash, which is a hair puller.</p><p> 缺乏阵列支持的简约外壳是嵌入式计算机的虚拟机，其中发货另一种语言是成本敏感的，但对安全的期望很高。 Busybox对你的小尺寸令人印象深刻，而是作为它的一部分，你得到灰烬，这是头发拉皮。</p><p>       This works for any separator byte (no UTF-8 or multi-character separator string) except NUL. To make it work for NUL, hardcode the literal  $&#39;\0&#39; in place of  $sep.</p><p>       这适用于除NUL之外的任何分隔字节（无UTF-8或多字符分隔符串）。为了使其在NUL工作，纠正文字$＆＃39; \ 0＆＃39;代替$ SEP。</p><p> The reason for appending the separator to the end is that the field separator is really a field  terminator (postfix, not infix). The distinction matters to the notion of an empty field at the end. Skip this if your input is already field terminated.</p><p> 将分隔符附加到结束的原因是字段分隔符真的是字段终止者（Postfix，而不是infix）。区分对最终空场的概念很重要。如果您的输入已终止，请跳过此操作。 </p><p>     Readarray gets a small minus point for only working with ASCII separators (still no UTF-8).</p><p>ReadArray获得了一个小的减号，仅用于使用ASCII分隔符（仍然没有UTF-8）。</p><p> If the separator consists of multiple bytes, it is also possible to do this correctly by string processing (such as by  parameter substitution).</p><p> 如果分隔符由多个字节组成，则可以通过字符串处理（例如通过参数替换）正确地执行此操作。</p><p>  The otherwise evil IFS variable has a legitimate use in the  read command, where it can be used as another way to separate fields without invoking indirect pathname expansion.IFS is brought into significance by requesting either multiple variables or using the array option to  read.By disabling the delimiter  -d &#39;&#39;, we read all the way to the end.Because read returns nonzero when it encounters the end, it must be guarded against errexit ( || true) if that is enabled.</p><p>  否则邪恶的ifs变量在read命令中有一个合法用途，在没有调用间接路径名扩展的情况下，它可以用作另一种方式来分隔字段。通过请求多个变量或使用阵列选项来读取的间接路径名扩展。禁用分隔符-D＆＃39;＆＃39;我们一直阅读到底。因为读取返回nonzero遇到结尾时，如果启用了，它必须防范错误（|| true）。</p><p>     The 3 corner cases are tab, newline and space – when IFS is set to one of these as above,  read drops empty fields!Because this is often useful though, this method makes the bottom of the recommendation list instead of disqualification.</p><p>     Tab，NewLine和Space  - 当IFS设置为其中一个时，3个角案例 - 读取丢弃空字段！因为这通常很有用，但此方法使推荐列表的底部而不是取消资格。</p><p>    The intuitive fix – piping into the loop – is not always cool,because the pipe operator&#39;s right operand becomes a subshell.Not that it matters for this silly example, but it would surprise manyto find that this loop can&#39;t manipulate outside variables:</p><p>    直观的修复 - 管道进入循环 - 并不总是很酷，因为管道运营商＆＃39; s的右操作数成为一个子shell.not这对这个愚蠢的例子很重要，但它会惊讶地发现这个循环可以＆＃39; T操纵外部变量：</p><p>  To avoid future surprises, the bulk of the code should typically not be the subshell.This is all right:</p><p>  为避免未来的惊喜，大部分代码通常不应该是子屏幕。这是正确的：</p><p>    #!/usr/bin/env bashif test &#34;$BASH&#34; = &#34;&#34; || &#34;$BASH&#34; -uc &#34;a=();true \&#34;\${a[@]}\&#34;&#34; 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefailelse # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefailfishopt -s nullglob globstarrequire(){ hash &#34;$@&#34; || exit 127; }require …require …require …</p><p>    ＃！/ usr / bin / env bashif test＆＃34; $ bash＆＃34; =＆＃34;＆＃34; || ＆＃34; $ bash＆＃34; -uc＆＃34; a =（）;真\＆＃34; \ $ {a [@]} \＆＃34;＆＃34; 2＆gt; / dev / null;然后#bash 4.4，zsh set -euo pipefailelse＃bash 4.3和旧扼流圈与set -u的空阵列上。 set -eo pipefailfishopt -s nullglob globstarrequire（）{哈希＆＃34; $ @＆＃34; ||退出127;要求......要求......要求...... </p><p>  The hashbang: Portability consideration: The absolute path to  env is likely more portable than the absolute path to  bash. Case in point:  NixOS. POSIX mandates  the existence of  env, but bash is not a posix thing.</p><p>Hashbang：可移植性考虑：Env的绝对路径可能比Bash的绝对路径更便携。案例在点：nixos。 POSIX任务是env的存在，但Bash不是POSIX的事情。</p><p> Safety consideration: No language flavor options like  -euo pipefail here! It is not actually possible when using the  env redirection, but even if your hashbang begins with  #!/bin/bash, it is not the right place for options that influence the meaning of the script, because it can be overridden, which would make it possible to run your script the wrong way. However, options that don&#39;t influence the meaning of the script, such as  set -x would be a bonus to make overridable (if used).</p><p> 安全考虑：在这里，没有语言味道选项 - 这里！在使用ENV重定向时实际上并不是可能的，但即使您的哈希班始于＃！/ bin / bash，它不是影响脚本含义的选项的正确位置，因为它可以被覆盖，这将是有可能以错误的方式运行脚本。但是，Don＆＃39; t影响脚本的含义的选项，例如set-x将是一个奖励，以便更过度地（如果使用）。</p><p> What we need from  Bash&#39;s unofficial strict mode, with  set -u behind a feature check. We don&#39;t need all of Bash&#39;s strict mode because being shellcheck/shellharden compliant means quoting everything, which is a level beyond strict mode. Furthermore,  set -u  must not be used in Bash 4.3 and earlier. Because that option, in those versions,  treats empty arrays as unset, which makes arrays unusable for the purposes described herein. With arrays being the second most imporant advice in this guide (after quoting), and the sole reason we&#39;re sacrificing POSIX compatibility, that&#39;s of course unacceptable: If using  set -u at all, use Bash 4.4 or another sane shell like Zsh. This is easier said than done if there is a possibility that someone might run your script with an obsolete version of Bash. Fortunately, what works with  set -u will also work without (unlike  set -e). Thus why putting it behind a feature check is sane at all. Beware of the presupposition that testing and development happens with a Bash 4.4 compatible shell (so the  set -u aspect of the script gets tested). If this concerns you, your other options are to give up compatibility (by failing if the feature check fails) or to give up  set -u.</p><p> 我们需要从Bash＆＃39; s的非官方严格模式，set -u后面的特征检查。我们不需要所有的bash＆＃39; s严格的模式，因为符合shellcheck / shellharden兼容的意味着引用一切，这是一个超出严格模式的级别。此外，SET -U不得在BASH 4.3及更早版本中使用。因为在这些版本中，在这些版本中将空阵列视为未设置，这使得对于本文描述的目的来说是不可用的阵列。随着阵列是本指南中的第二个最具不风化的建议（引用）和我们＆＃39的唯一原因;重新牺牲POSIX兼容性，即当然是不可接受的：如果使用SET -U，请使用BASH 4.4或使用BASH 4.4或另一个Sane壳牌ZSH。如果有可能有人可以用过时的Bash运行脚本，则这比完成这一点更容易。幸运的是，与set -u的适用也将在没有（与set -e不同）工作。因此，为什么将其放在一个特征检查后面是SANE。请注意，使用Bash 4.4兼容shell发生测试和开发（因此脚本的SET -U方面进行了测试）。如果此问题涉及您，您的其他选项将放弃兼容性（如果特征检查失败，则通过失败）或放弃SET -U。</p><p> shopt -s nullglob is what makes  for f in *.txt work correctly when  *.txt matches zero files. The default behavior (aka.  passglob) – pass the pattern as-is if it happens to match nothing – is dangerous for several reasons. As for  globstar, that enables recursive globbing. Globbing is easier to use correctly than  find. So use it.</p><p> shopt -s nullglob是在* .txt与零文件匹配时正确工作的f in * .txt。默认行为（aka。passglob） - 通过模式，如果它发生匹配是什么 - 由于几个原因是危险的。至于Globstar，可以实现递归的Globbing。 Globbing比找到的更容易使用。所以用它。</p><p> Assert that command dependencies are installed.  Declaring your dependencies has many benefits, but until this becomes statically verifiable, concentrate on uncommon commands here. Your motivation should be to prevent long running scripts from failing right at the end, as well as preventing misbehavior such as  make -j&#34;$(nproc)&#34; becoming a fork bomb. Benefits of using  hash for this purpose are its low overhead and that it gives you an error message in the failure case. What it doesn&#39;t check is indirect dependencies and compatibility level, but at that point, we want package management.</p><p> 断言命令依赖项已安装。声明您的依赖关系有很多好处，但直到这变得静止验证，在此处集中在罕见的命令。您的动机应该是防止最终失败的长期运行脚本，以及预防Make -J＆＃34; $（nproc）＆＃34等不端行为成为一枚叉子炸弹。为此目的使用HASH的好处是它的低开销，并且它在故障情况下为您提供错误消息。它不做什么＆＃39; t检查是间接依赖关系和兼容性级别，但在那时，我们想要包管理。</p><p>   Setting the  internal field separator to the empty string disables word splitting. Sounds like the holy grail. Sadly, this is no complete replacement for quoting variables and command substitutions, and given that you are going to use quotes, this gives you nothing. The reason you must still use quotes is that otherwise, empty strings become empty arrays (as in  test $x = &#34;&#34;), and indirect pathname expansion is still active. Furthermore, messing with this variable also messes with commands like  read that use it, breaking constructs like  cat /etc/fstab | while read -r dev mnt fs opt dump pass; do printf &#39;%s\n&#39; &#34;$fs&#34;; done&#39;.</p><p>   将内部字段分隔符设置为空字符串禁用Word Splitting。听起来像圣杯。可悲的是，这是引用变量和命令替换的完全替代，并且鉴于您将使用引号，这会给您带来任何引号。您必须使用引号的原因是，否则，空字符串变为空数组（如测试$ x =＆＃34;＆＃34;），间接路径扩展仍处于活动状态。此外，使用此变量的搞乱也会使用像读取的命令使用它，打破Cat / etc / fstab等构造读取-r dev mnt fs opt dump pass; printf＆＃39;％s \ n＆＃39; ＆＃34; $ fs＆＃34 ;;完成＆＃39;</p><p> Disabling wildcard expansion: Not just the notorious indirect one, but also the unproblematic direct one, that I&#39;m saying you should want to use. So this is a hard sell. And this too should be completely unnecessary for a script that is shellcheck/shellharden conformant.</p><p> 禁用通配符扩展：不仅仅是一个臭名昭着的间接，而且也是未解决的直接的一个，那我说你应该想要使用。所以这是一个艰难的卖。而这也应该完全不必要地掌握shellcheck / shellharden符合物的脚本。 </p><p> As an alternative to  nullglob,  failglob fails if there are zero matches. While this makes sense for most commands, for example  rm -- *.txt (because most commands that take file arguments don&#39;t expect to be called with zero of them anyway), obviously,  failglob can only be used when you are able to assume that zero matches won&#39;t happen. That just means you mostly won&#39;t be putting wildcards in command arguments unless you can assume the same. But what can always be done, is to use  nullglob and let the pattern expand to zero arguments in a construct that can take zero arguments, such as a  for loop or array assignment ( txt_files=(*.txt)).</p><p>作为nullglob的替代方案，如果匹配零匹配，则vereglob失败。虽然这对大多数命令进行了意义，例如RM  -  * .txt（因为大多数采用文件参数的命令Don＆＃39;当然，无论如何都会被零呼叫，但显然，只有在您的情况下只能使用FAILGLOB能够假设零匹配胜利＆＃39; t发生。这只是意味着您大多数人赢得了＆＃39;除非您可以假设相同，否则将在命令参数中放置通配符。但是总是可以完成的，是使用nullglob，让模式扩展到一个可以采用零参数的构造中的零参数，例如for循环或数组分配（txt_files =（*。txt））。</p><p>    There is a wrong way to end a bash script:Letting a command used as a condition be the last command executed, so that the script &#34;fails&#34; iff the last condition is false.While that might happen to be correct for a script, it is a way to encode the exit status that looks accidental and is easily broken by adding or removing code to the end.</p><p>    有一种错误的方法来结束一个bash脚本：让用作条件的命令是执行的最后一个命令，使脚本＆＃34;失败＆＃34; IFF最后一个条件是假的。这可能遇到脚本可能是正确的，它是一种编码看起来意外的退出状态的方法，并且通过添加或删除代码来易于破坏到结尾。</p><p> The rightness criterion here is that the last statement follows the &#34;Errexit basics&#34; below. When in doubt, end the script with an explicit exit status:</p><p> 这里的正确标准是最后一个陈述遵循＆＃34; errexit基础＆＃34;以下。在疑问时，以显式退出状态结束脚本：</p><p>     Background: If a command that is not used as a condition returns nonzero, the interpreter exits at that point.</p><p>     背景：如果未使用的命令作为条件返回非零，则解释器在该点退出。</p><p>   Don&#39;t skimp on if-statements. You can&#39;t use  &amp;&amp; as a shorthand if-statement without always using  || as an else-branch. Otherwise, the script terminates if the condition is false.</p><p>   Don＆＃39; t shimp上的if-stand。你可以＆＃39;＆amp;＆amp;作为没有总是使用的速记IF-陈述||作为别人分支。否则，脚本如果条件为false则终止。</p><p>         To capture a command&#39;s output while using it as a condition, use an assignment as the condition (but see below on not using  local on assignments):</p><p>         要在使用它作为条件时捕获命令＆＃39; s输出，请使用赋值作为条件（但在下面请在不使用当地的作业上）：</p><p>  If at all using the exit status variable  $? with errexit, it is of course no substitute for the direct check for command success (otherwise, your script won&#39;t live to see this variable whenever it is nonzero). Corollary: The failure case is the only place it makes sense to expand the exit status variable  $? (because success only has one exit status, which we are checking). A second pitfall is that if we negate the command as part of the check, the exit status will be that of the negated command – a boolean with precisely the useful information removed.</p><p>  如果在所有使用退出状态变量$ $？使用errexit，当然没有替代指挥成功的直接检查（否则，您的脚本在非零时直播，以查看此变量）。推论：失败的情况是扩展退出状态变量$唯一有意义的地方吗？ （因为成功只有一个退出状态，我们正在检查）。第二个陷阱是，如果我们将命令作为检查的一部分否定命令，则退出状态将是否定命令的，这是一个删除的有用信息的布尔值。 </p><p>          In case errexit does its thing, use this to set up any necessary cleanup to happen at exit.</p><p>如果errexit执行它的事情，请使用它来设置任何必要的清理以在退出时发生。</p><p>   Here is a nice underhanded fork bomb that I learnt the hard way – my build script worked fine on various developer machines, but brought my company&#39;s buildserver to its knees:</p><p>   这是一个很好的被削弱的叉子炸弹，我学到了艰难的方式 - 我的构建脚本在各种开发人员机器上工作了很好，但带来了我的公司＆＃39; s buildserver到膝盖：</p><p>          Sometimes, POSIX is cruel. Errexit is ignored in functions, group commands and even subshells if the caller is checking its success. These examples all print  Unreachable and  Great success, despite all sanity.</p><p>          有时，Posix是残酷的。如果呼叫者正在检查其成功，则在函数，组命令甚至子屏幕中忽略errexit。尽管所有的理智，这些例子都印刷了不可达和巨大的成功。</p><p>       This makes bash with errexit practically incomposable – it is  possible to wrap your errexit functions so that they still work, but the effort it saves (over explicit error handling) becomes questionable. Consider splitting into completely standalone scripts instead.</p><p>       这使得Bash与errexit实际上是无法分散的 - 可以包装errexit函数，以便他们仍然工作，但它可以节省的努力（超出显式错误处理）变得可疑。请考虑拆分成完全独立的脚本。</p><p>      Inside double brackets  [[ ]], unquoted variables and command substitutions are safe (from word splitting and indirect pathname expansion). That&#39;s a partial solution to a problem we don&#39;t have – following this guide implies not doing that anywhere to begin with. If you are, you aren&#39;t after shellhardening your scripts.</p><p>      在双括号内部[[]]，未引入的变量和命令替换是安全的（来自字分离和间接路径名扩展）。 ＆＃39;我们是一个问题的部分解决方案，我们在本指南之后遵循本指南，暗示在任何地方都没有开始。如果你是，你在攻击你的脚本之后，你应该ann＆＃39; t。</p><p>   Let&#39;s get that myth out of the way. When in doubt, ask the  type command:</p><p>   让＆＃39;脱离了这个神话。如有疑问，请询问类型命令：</p><p> &gt; type testtest is a shell builtin&gt; type [[ is a shell builtin&gt; type [[[[ is a shell keyword</p><p> ＆gt; type testtest是一个shell内置＆gt;类型[[[是shell内置＆gt;类型[[[[[[是shell关键字 </p><p>  This argument goes both ways:  [[ has a more forgiving syntax because it  is syntax, not a command.  Quoting is required everywhere else. The fewer exceptions, the lesser confusion. If you want to be pedagogical, use the  test command – it is honest about being a command, not syntax.</p><p>此参数两种方式：[[有更宽容的语法，因为它是语法，而不是命令。其他地方需要引用。较少的例外，令人震惊的混乱。如果要进行教育，请使用测试命令 - 它是诚实的是命令，而不是语法。</p><p>   Pattern matching ( [[ $path == *.png || $path == *.gif ]]): This is what  case is for.</p><p>   模式匹配（[[$ path == * .png || $ path == * .gif]]）：这是什么情况。</p><p> Logical operators: The usual suspects  &amp;&amp; and  || work just fine – outside commands – and can be grouped with group commands:  if { true || false; } &amp;&amp; true; then echo 1; else echo 0; fi.</p><p> 逻辑运营商：通常的嫌疑人和amp;＆amp;和||工作只是精细 - 外部命令 - 并且可以与组命令分组：如果{true ||错误的; }＆amp;＆amp;真的;然后回声1;否则回声0; FI。</p><p> Checking if a variable exists ( [[ -v varname ]]): Yes, this is possibly a killer argument, but consider the programming style of always setting variables, so you don&#39;t need to check if they exist.</p><p> 检查是否存在变量（[-varName]]）：是的，这可能是一个杀手争论，但考虑始终设置变量的编程样式，所以您需要检查它们是否存在。</p><p>  A correct way to do this is not a feature of idiomatic POSIX/Bash scripting. Consider avoiding the problem when possible by always setting variables, so you don&#39;t need to check if they exist.</p><p>  正确的方法是不是惯用POSIX / BASH脚本的特征。考虑始终设置变量尽可能避免问题，因此您需要检查它们是否存在。</p><p> You can get a long way by giving variables default values. This works even in busybox:</p><p> 通过给出变量默认值，您可以获得长路。这甚至在BusyBox中运行：</p><p>  But if you must know, the correct way to check if a variable exists came with Bash 4.2 (also verified for zsh 5.6.2):</p><p>  但是，如果您必须知道，则Bash 4.2（也验证了ZSH 5.6.2）的正确方法是否存在了检查变量是否存在。 </p><p>  If using this and there is any chance someone might try to run your script with an earlier Bash version, remember to fail early. The feature test approach would be to test, in the beginning of the script, for a variable that we know exists, and terminate if the result is wrong. In this case, we get a syntax error in earlier versions, and termination for free, so it suffices to add this to the beginning section:</p><p>如果使用此问题，有人可能会尝试使用早期的BASH版本运行脚本，请记住早期失败。特征测试方法将在脚本的开头进行测试，对于我们所知道的变量，并且如果结果是错误的，则终止。在这种情况下，我们在早期版本中获得语法错误，并免费终止，因此可以将其添加到开头部分以下：</p><p>  Lastly, don&#39;t ever use constructs like  [ -n $var ] or  [ -z $var ]. They are fundamentally string comparisons against the empty string, only less readable. However, what matters in this section, is their functional critique:</p><p>  最后，不要使用像[-n $ var]或[-z $ var]这样的构造。它们基本上与空字符串的串串比较，只能更少可读。但是，本节的重要事项是他们的功能批评：</p><p> A string comparison can&#39;t distinguish an unset variable from an empty one. Let alone distinguish the ways it can be empty: Environment variables are just strings, so they may be empty strings, but normal shell variables are really arrays – they can be empty arrays or arrays of empty strings (what you think of as the empty string is indistinguishable from a one-element array).</p><p> 字符串比较可以＆＃39; t区分从空的一个未命令变量。更不用说辨别它可以为空的方式：环境变量只是字符串，因此它们可能是空字符串，但正常的shell变量是真正的数组 - 它们可以是空字符串或空字符串的空阵列（您认为是空字符串与一个元素阵列无法区分）。</p><p>   As with any command, there must be a way to control its option parsing to prevent it from interpreting data as options.The standard way to signify the end of options is with a double-dash  -- argument.</p><p>   与任何命令一样，必须有一种方法来控制其选项解析以防止它将其解释为选项。标准的方式来表示选项结束的标准方法是具有双重划线的。</p><p>   As such, the GNU versio</p><p>   因此，GNU VERSIO</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md">https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/安全/">#安全</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/safely/">#safely</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>