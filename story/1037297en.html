<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ARM和无锁编程ARM and Lock-Free Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ARM and Lock-Free Programming<br/>ARM和无锁编程</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 23:04:57</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/76ba0cf839abf34dc57c5d761c44d69d.png"><img src="http://img2.diglog.com/img/2020/11/76ba0cf839abf34dc57c5d761c44d69d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I was inspired by the release of Apple’s M1 ARM processor to  tweet about the perils of lock-free programming which led to some robust discussion. The discussion went pretty well given the inanity of trying to discuss something as complicated as CPU memory models in the constraints of tweets, but it still left me wanting to expand slightly on the topic in blog form.</p><p>苹果M1 ARM处理器的发布启发了我，他在推特上谈到了无锁编程的危险，这引发了激烈的讨论。考虑到在推特的约束下试图讨论像CPU内存模型这样复杂的事情的讨论进行得非常顺利，但是这仍然让我想以博客形式稍微扩展一下这个话题。</p><p> This is intended to be a casual introduction to the perils of lock-free programming (which I  last wrote about some fifteen years ago), but also some explanation of why ARM’s weak memory model breaks some code, and why that code was probably broken already. I also want to explain why C++11 made the lock-free situation strictly better ( objections to the contrary notwithstanding).</p><p> 这旨在作为对无锁编程的危险的偶然介绍（我上次写它大约是在15年前），而且还解释了为什么ARM的弱内存模型会破坏某些代码，以及为什么该代码可能已经被破坏了。我也想解释为什么C ++ 11严格地改善了无锁情况（尽管有相反的反对）。</p><p>  Mandatory disclaimer: if your code always uses locks   when sharing data between threads then you don’t need to worry about any of this – properly implemented locks avoid all of these data races (unlike the horrible lock in  this video).</p><p>  强制性免责声明：如果您的代码在线程之间共享数据时始终使用锁，那么您就不必担心这些-正确实现的锁可以避免所有这些数据争用（不同于此视频中的可怕锁）。</p><p> The basic problems of  lock-free programming are best explained through the example of a lock-free producer/consumer pattern, with the producer thread looking like this (C++ pseudo-code with data/function boundaries omitted):</p><p> 无锁编程的基本问题最好通过无锁生产者/消费者模式示例来解释，生产者线程如下所示（省略了数据/函数边界的C ++伪代码）：</p><p> g_data1 = calc1(); g_data2 = calc2(); g_data3 = calc3(); g_flag = true; // Indicate that the data is ready for consumption</p><p> g_data1 = calc1（）; g_data2 = calc2（）; g_data3 = calc3（）; g_flag = true; //表示数据已准备好使用</p><p>   This omits a ton of details (when does g_flag get cleared? How do the threads avoid spinning?) but it suffices for my purposes. The question is, what is wrong with this code, in particular the producer thread?</p><p>   这省略了大量细节（什么时候清除g_flag？线程如何避免旋转？），但足以满足我的目的。问题是，此代码（特别是生产者线程）有什么问题？</p><p> The basic problem is that the code relies on the three data variables being written to before the flag, but it does not enforce that. If the compiler rearranges the writes then g_flag may be set to true before all of the data is written and the consumer thread may see incorrect values.</p><p> 基本的问题是代码依赖于在标志之前写入的三个数据变量，但是并没有强制执行该操作。如果编译器重新安排了写操作，则在写入所有数据之前，可以将g_flag设置为true，并且使用者线程可能会看到不正确的值。</p><p> Optimizing compilers can be very aggressive about rearranging operations – it’s one of the ways they make their generated code run fast. They may do this in order to reduce the use of registers, to improve the use of CPU pipelines, or just because of some random heuristic added to make Office XP load slightly faster. It’s not worth thinking too much about why a compiler might rearrange things, it’s just important to realize that they can and do.</p><p>优化编译器在重新安排操作方面会非常激进，这是使生成的代码快速运行的方式之一。他们这样做可能是为了减少寄存器的使用，提高CPU管道的使用率，或者仅仅是因为添加了一些随机启发法以使Office XP加载速度更快。编译器为什么要重新安排事情是没有必要考虑太多的，重要的是要意识到它们可以并且可以做。</p><p> Compilers are “allowed” to rearrange the writes because of the  “as-if” rule which says that they have done their job as long as the program that they generate behaves “as-if” they hadn’t optimized it. Since the C/C++ abstract machine has long assumed a single-thread of execution – with no external observers – all this rearrangement of writes has been correct and reasonable, and has been done for decades.</p><p> 编译器被“允许”重新排列写入内容，因为“按原样”规则表明，只要生成的程序在没有优化的情况下“按原样”运行，它们就可以完成工作。由于C / C ++抽象机长期以来一直假定执行线程为单线程-没有外部观察者-所有这些写入重新安排都是正确和合理的，并且已经进行了数十年。</p><p> The question then, is what must be done to stop the compiler from breaking our beautiful code? Let’s pretend for a moment that we are a circa 2005 programmer trying to make this work. Here are some bad ideas:</p><p> 那么问题是，必须采取什么措施才能阻止编译器破坏我们漂亮的代码？让我们假设一下，我们是一名大约2005年的程序员，正在努力实现这一目标。这里有一些坏主意：</p><p> Declare g_flag as volatile. That prevents the compiler from omitting the reads/writes of g_flag but, to the surprise of many, it does not prevent the problematic rearrangement. Compilers are not allowed to reorder volatile reads/writes with respect to  each other, but they are allowed to rearrange them relative to “normal” reads/writes. Adding volatile does nothing to solve our reordering problem  (/volatile:ms on VC++ does, but it is a non-standard extension to the language that may generate slower code).</p><p> 将g_flag声明为volatile。这可以防止编译器省略对g_flag的读/写操作，但是，令很多人惊讶的是，它不能防止问题重排。不允许编译器相对于易失性读/写重新排序，但允许编译器相对于“正常”读/写重新排列它们。添加volatile并不能解决我们的重新排序问题（VC ++上的/ volatile：ms可以解决，但它是该语言的非标准扩展，可能会生成较慢的代码）。</p><p> If declaring g_flag as volatile is insufficient then let’s try declaring all four variables as volatile! Then the compiler can’t rearrange the writes and our code will work… on some computers.</p><p> 如果将g_flag声明为volatile还不够，那么请尝试将所有四个变量声明为volatile！然后，编译器无法重新排列写入内容，我们的代码将可以在某些计算机上工作。</p><p> It turns out that compilers aren’t the only things that like to rearrange reads and writes. CPUs like to do this as well. This is separate from out-of-order execution (always invisible to your code), and in fact there are in-order CPUs that reorder reads/writes (Xbox 360 CPU) and there are out-of-order CPUs that mostly do not reorder reads/writes (x86/x64 CPUs).</p><p> 事实证明，编译器并不是唯一需要重新安排读写的事情。 CPU也喜欢这样做。这与乱序执行（代码始终不可见）是分开的，实际上，有序CPU会对读/写进行重新排序（Xbox 360 CPU），而乱序CPU大多不会重新排序读取/写入（x86 / x64 CPU）。</p><p> So, if you declare all four variables as volatile then you have code that will only run correctly on x86/x64. And, this code is potentially inefficient because no reads/writes to those variables can be optimized away, potentially leading to redundant work (as when g_data1 is passed twice to  DoSomething).</p><p> 因此，如果将所有四个变量声明为volatile，那么您的代码将只能在x86 / x64上正确运行。而且，此代码可能效率很低，因为无法优化对这些变量的读/写操作，从而可能导致多余的工作（例如，当g_data1两次传递给DoSomething时）。</p><p> If you are satisfied with inefficient non-portable code then feel free to stop here, but I think we can do better. But let’s continue to constrain ourselves to the options available in 2005. We now have to make use of… memory barriers.</p><p>如果您对效率低下的不可移植代码感到满意，请随时在此处停止，但我认为我们可以做得更好。但是，让我们继续将自己限制在2005年可用的选项中。我们现在必须利用…内存障碍。</p><p> On x86/x64 we need a compiler memory barrier to prevent reordering. This does the trick:</p><p> 在x86 / x64上，我们需要一个编译器内存屏障来防止重新排序。这可以解决问题：</p><p> g_data1 = calc1(); g_data2 = calc2(); g_data3 = calc3(); _ReadWriteBarrier(); // VC++ only and deprecated, but okay in 2005 g_flag = true; // Indicate that the data is ready for consumption.</p><p> g_data1 = calc1（）; g_data2 = calc2（）; g_data3 = calc3（）; _ReadWriteBarrier（）; //仅适用于VC ++并且已弃用，但在2005年还可以g_flag = true; //表示数据已准备就绪，可以使用。</p><p> This tells the compiler not to rearrange the writes across that barrier which is exactly what we need. Another barrier may be needed after the write to g_flag to ensure that value gets written but the details are too uncertain for me to want to discuss. A similar barrier should be used in the consumer thread, but I’m ignoring that thread for now to keep things simple.</p><p> 这告诉编译器不要重新布置跨越该障碍的写入，这正是我们所需要的。在写入g_flag之后可能需要另一个障碍，以确保值被写入，但是细节太不确定了，以至于我不想讨论。在使用者线程中应使用类似的屏障，但为了使事情保持简单，我现在暂时忽略该线程。</p><p> The problem is that this code is still broken on CPUs with a  weak memory model. A “weak” memory model indicates CPUs that can reorder reads and writes (for greater efficiency or simplicity of implementation) and this includes ARM, PowerPC, MIPS, and basically every in-use CPU except for x86/x64. The solution to this is also a memory barrier, but this time it needs to be a CPU instruction which tells the  CPU not to reorder. Something like this:</p><p> 问题是该代码在内存模型较弱的CPU上仍然被破坏。 “弱”内存模型表示可以对读和写进行重新排序（以提高效率或简化实现）的CPU，其中包括ARM，PowerPC，MIPS，除x86 / x64以外，基本上每个使用中的CPU。解决该问题的方法也是内存障碍，但这一次它需要是一条CPU指令，该指令告诉CPU不要重新排序。像这样：</p><p> g_data1 = calc1(); g_data2 = calc2(); g_data3 = calc3(); MemoryBarrier(); // Windows only, and an expensive full memory barrier. g_flag = true; // Indicate that the data is ready for consumption.</p><p> g_data1 = calc1（）; g_data2 = calc2（）; g_data3 = calc3（）; MemoryBarrier（）; //仅Windows，以及昂贵的完整内存屏障。 g_flag = true; //表示数据已准备就绪，可以使用。</p><p> The actual implementation of MemoryBarrier depends on the CPU. In fact, as the comment suggests, MemoryBarrier is not really the ideal choice here because we just want a write/write barrier instead of a much more expensive full memory barrier (which makes reads wait for writes to fully complete) but this is good enough for our purposes today.</p><p> MemoryBarrier的实际实现取决于CPU。实际上，正如评论所暗示的那样，MemoryBarrier并不是真正的理想选择，因为我们只需要写/写屏障，而不是昂贵得多的完整内存屏障（这会使读取等待写入完全完成），但这已经足够了为了我们今天的目的。</p><p> I assume that the MemoryBarrier intrinsic is also a compiler memory barrier, so we only need one or the other, so our awesome/efficient producer thread now becomes:</p><p>我假设MemoryBarrier内在函数也是编译器的内存障碍，因此我们只需要一个，另一个，因此我们出色/高效的生产者线程现在变为：</p><p> #ifdef X86_OR_X64 #define GenericBarrier _ReadWriteBarrier #else #define GenericBarrier MemoryBarrier #endif g_data1 = calc1(); g_data2 = calc2(); g_data3 = calc3(); GenericBarrier(); // Why did I have to define this myself? g_flag = true; // Indicate that the data is ready for consumption.</p><p> #ifdef X86_OR_X64 #define GenericBarrier _ReadWriteBarrier #else #define GenericBarrier MemoryBarrier #endif g_data1 = calc1（）; g_data2 = calc2（）; g_data3 = calc3（）; GenericBarrier（）; //为什么我必须自己定义这个？ g_flag = true; //表示数据已准备就绪，可以使用。</p><p> If you have circa-2005 code without these memory barriers then your code is broken, and has always been broken, on all CPUs, because compilers have always been allowed to rearrange writes. With these memory barriers (implemented as needed for different compilers and platforms) your code is beautiful and portable.</p><p> 如果您的2005年前后代码没有这些内存障碍，那么您的代码在所有CPU上都将被破坏，并且一直被破坏，因为始终允许编译器重新排列写入。有了这些内存屏障（根据不同的编译器和平台的需要实现），您的代码就变得美观且可移植。</p><p> It turns out that ARM’s weak memory model really doesn’t make things any more complicated. If you are writing lock-free code and not using any sort of memory barriers then your code is potentially broken everywhere due to compiler reordering. If you  are using memory barriers then it should be easy to extend them to include hardware memory barriers.</p><p> 事实证明，ARM的内存不足模型并没有使事情变得更加复杂。如果您正在编写无锁代码且未使用任何类型的内存屏障，则由于编译器重新排序，您的代码可能会在任何地方损坏。如果您使用内存屏障，则应该很容易地将它们扩展为包括硬件内存屏障。</p><p> The code above is error prone (where do the barriers go?), verbose, and inefficient. Luckily when C++11 came along we got better options. Prior to C++11 the language didn’t really have a memory model, there was just the implicit assumption that all code was single threaded and if you touched shared data outside of locks then god have mercy on your soul. C++ 11 added a memory model that acknowledged the existence of threads. This made it more explicit that the no-barrier code above was broken, but also gave new options to fix it, like this:</p><p> 上面的代码容易出错（障碍会去哪里？），冗长且效率低下。幸运的是，当C ++ 11出现时，我们有了更好的选择。在C ++ 11之前，该语言并没有真正的内存模型，只是隐含的假设是所有代码都是单线程的，如果您触摸了锁之外的共享数据，那么上帝会怜悯您的灵魂。 C ++ 11添加了一个内存模型，该内存模型承认线程的存在。这使上面的无障碍代码更明确地被破坏了，但是还提供了修复它的新选项，如下所示：</p><p> g_data1 = calc1(); g_data2 = calc2(); g_data3 = calc3(); g_flag = true; // Indicate that the data is ready for consumption.</p><p> g_data1 = calc1（）; g_data2 = calc2（）; g_data3 = calc3（）; g_flag = true; //表示数据已准备就绪，可以使用。</p><p> The change is subtle and easy to miss. All I did was change the type of g_flag from bool to std::atomic&lt;bool&gt;. This tells the compiler not to elide reads and writes of this variable, not to rearrange reads and writes across reads and writes to this variable, and to add appropriate CPU memory barriers as needed.</p><p> 更改是微妙的，容易错过。我所做的只是将g_flag的类型从bool更改为std :: atomic 。这告诉编译器不要忽略该变量的读写，不要在对该变量的读写之间重新安排读写，并根据需要添加适当的CPU内存屏障。</p><p>   By using memory_order_release we are telling the compiler exactly what we are doing so that it can use the appropriate (cheaper) type of memory barrier instruction, or no memory barrier instruction in the case of x86/x64. Our code is now relatively clean and perfectly efficient.</p><p>通过使用memory_order_release，我们可以告诉编译器确切的操作，以便它可以使用适当（便宜）类型的内存屏障指令，或者对于x86 / x64，可以不使用内存屏障指令。现在，我们的代码相对干净并且完全有效。</p><p> At this point writing the consumer thread is easy. In fact, with the new declaration of g_flag the original version of the consumer thread is now correct! But, we can optimize it slightly:</p><p> 此时，编写使用者线程很容易。实际上，使用新的g_flag声明，使用者线程的原始版本现在是正确的！但是，我们可以对其进行一些优化：</p><p>  The std::memory_order_acquire flag tells the compiler that we don’t need a full memory barrier – a read-acquire barrier just ensures that the data values don’t come from shared storage before g_flag without blocking other reordering.</p><p>  std :: memory_order_acquire标志告诉编译器我们不需要完整的内存屏障–读取-获取屏障仅可确保g_flag之前的数据值不来自共享存储，而不会阻止其他重新排序。</p><p> Finishing the code so that the threads can avoid busy-waits and other problems is left as an exercise for the reader.</p><p> 整理代码以使线程可以避免繁忙等待和其他问题留给读者练习。</p><p> If you want to learn these techniques then start by carefully reading  Jeff Preshing’s introduction to lock-free programming or  This is Why They Call It a Weakly-Ordered CPU, and then consider joining a monastery or nunnery instead. Lock-free programming is the most dangerous hammer in the C++ toolkit and that is saying a lot, and it is rarely appropriate.</p><p> 如果您想学习这些技术，请先仔细阅读Jeff Preshing关于无锁编程的介绍，或者这就是为什么他们称其为弱指令CPU，然后考虑加入修道院或女修道院。无锁编程是C ++工具箱中最危险的锤子，也就是说很多，而且很少适用。</p><p>  Jeff Preshing’s more  modern take on lock-free programming (and thanks for the pre-release suggestions on this post)</p><p>  Jeff Preshing对无锁编程进行了更现代的介绍（并感谢本文中的预发布建议）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://randomascii.wordpress.com/2020/11/29/arm-and-lock-free-programming/">https://randomascii.wordpress.com/2020/11/29/arm-and-lock-free-programming/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/无锁/">#无锁</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lock/">#lock</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>