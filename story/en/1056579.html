<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TypeScript 4.3 Beta. TypeScript 4.3 Beta</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TypeScript 4.3 Beta<br/>TypeScript 4.3 Beta. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-07 03:11:19</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/065a3a9a06a786d7328a931d00589001.png"><img src="http://img2.diglog.com/img/2021/4/065a3a9a06a786d7328a931d00589001.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>To get started using the beta, you can get it  through NuGet, or use npm with the following command:</p><p>要使用测试版开始，您可以通过Nuget获取它，或使用以下命令使用NPM：</p><p>      In JavaScript, it’s pretty common for APIs to convert values that are passed in before storing them. This often happens with getters and setters too. For example, let’s imagine we’ve got a class with a setter that always converts a value into a  number before saving it in a private field.</p><p>      在JavaScript中，API将在存储之前转换在存储之前传递的值非常常见。这通常会发生气体和定居者。例如，让我们想象一下，我们有一个带有Setter的类，始终将值转换为一个数字，然后在私有字段中保存它。</p><p> class  Thing  { # size  =  0 ;  get  size ( )  {  return  this .# size ;  }  set  size ( value )  {  let  num  =  Number ( value ) ;  // Don&#39;t allow NaN and stuff.  if  ( ! Number . isFinite ( num ) )  {  this .# size  =  0 ;  return ;  }  this .# size  =  num ;  } }</p><p> 班级{＃size = 0; get size（）{返回此。＃尺寸;设置大小（值）{假设num = number（值）; // don＆＃39; t允许南和东西。 if（！号码。Isfinite（num））{这个。＃size = 0;返回 ;这个。＃size = num; }}</p><p> How would we type this JavaScript code in TypeScript? Well, technically we don’t have to do anything special here – TypeScript can look at this with no explicit types and can figure out that  size is a number.</p><p> 我们如何在键入键中键入此JavaScript代码？好吧，技术上我们不必在这里做任何特别的事情 - 打字可以看出这个没有显式类型，可以弄清楚大小是一个数字。</p><p> The problem is that  size allows you to assign more than just  numbers to it. We could get around this by saying that  size has the type  unknown or  any like in this snippet:</p><p> 问题是大小允许您为其分配超过数字。我们可以通过说大小具有未知类型或在此代码段中的任何类似：</p><p>  But that’s no good –  unknown forces people reading  size to do a type assertion, and  any won’t catch any mistakes. If we really want to model APIs that convert values, previous versions of TypeScript forced us to pick between being precise (which makes reading values easier, and writing harder) and being permissive (which makes writing values easier, and reading harder).</p><p>  但那没有好的 - 未知的力量人们阅读大小要做一个类型的断言，任何都不会捕获任何错误。如果我们真的想要建模转换值的API，那么先前版本的类型迫使我们选择精确（使读取值更容易，并编写更难）并且是允许的（这使得写入值更容易，并更容易地读取）。</p><p> That’s why TypeScript 4.3 allows you to specify types for reading and writing to properties.</p><p> 这就是为什么打字4.3允许您指定用于读取和写入属性的类型。 </p><p> class  Thing  { # size  =  0 ;  get  size ( ):  number  {  return  this .# size ;  }  set  size ( value:  string  |  number  |  boolean )  {  let  num  =  Number ( value ) ;  // Don&#39;t allow NaN and stuff.  if  ( ! Number . isFinite ( num ) )  {  this .# size  =  0 ;  return ;  }  this .# size  =  num ;  } }</p><p>班级{＃size = 0; get size（）：number {返回此。＃尺寸;设置大小（值：字符串|编号|布尔值）{假设num = number（值）; // don＆＃39; t允许南和东西。 if（！号码。Isfinite（num））{这个。＃size = 0;返回 ;这个。＃size = num; }}</p><p> In the above example, our  set accessor takes a broader set of types ( strings,  booleans, and  numbers), but our  get accessor always guarantees it will be a  number. Now we can finally assign other types to these properties with no errors!</p><p> 在上面的示例中，我们的设置访问器采用更广泛的类型（字符串，布尔值和数字），但我们的获取访问器始终保证它将是一个数字。现在我们最终可以将其他类型分配给这些属性，没有错误！</p><p> let  thing  =  new  Thing ( ) ; // Assigning other types to `thing.size` works! thing . size  =  &#34;hello&#34; ; thing . size  =  true ; thing . size  =  42 ; // Reading `thing.size` always produces a number! let  mySize:  number  =  thing . size ;</p><p> 让事情=新事物（）; //将其他类型分配给`thing.size`作品！事物 。 size =＆＃34;你好＆＃34; ;事物 。 size = true;事物 。尺寸= 42; //读取“thing.size`总是产生一个数字！让mysize：号码=的东西。尺寸 ;</p><p> When considering how two properties with the same name relate to each other, TypeScript will only use the “reading” type (e.g. the type on the  get accessor above). “Writing” types are only considered when directly writing to a property.</p><p> 在考虑彼此相同的两个属性有两个属性时，打字签名只会使用“读取”类型（例如，上面的GET访问器上的类型）。直接编写到属性时，仅考虑“写入”类型。</p><p> Keep in mind, this isn’t a pattern that’s limited to classes. You can write getters and setters with different types in object literals.</p><p> 请记住，这不是一个限于课程的模式。您可以在对象文字中编写带有不同类型的Getters和Setter。</p><p> function  makeThing ( ):  Thing  {  let  size  =  0 ;  return  {  get  size ( ):  number  {  return  size ;  } ,  set  size ( value:  string  |  number  |  boolean )  {  let  num  =  Number ( value ) ;  // Don&#39;t allow NaN and stuff.  if  ( ! Number . isFinite ( num ) )  {  size  =  0 ;  return ;  }  size  =  num ;  }  } }</p><p> 函数makething（）：thing {让size = 0;返回{get size（）：number {return size; }，设置大小（值：字符串|编号|布尔值）{假设num = number（值）; // don＆＃39; t允许南和东西。 if（！号码。Isfinite（num））{size = 0;返回 ; }大小= num; }}}</p><p> In fact, we’ve added syntax to interfaces/object types to support different reading/writing types on properties.</p><p> 实际上，我们已将语法添加到接口/对象类型以支持属性上的不同读/写入类型。 </p><p> // Now valid! interface  Thing  {  get  size ( ):  number  set  size ( value:  number  |  string  |  boolean ) ; }</p><p>//现在有效！界面{get size（）：number set size（值：number | string | boolean）; }</p><p> One limitation of using different types for reading and writing properties is that the type for reading a property has to be assignable to the type that you’re writing. In other words, the getter type has to be assignable to the setter. This ensures some level of consistency, so that a property is always assignable to itself.</p><p> 使用不同类型读取和编写属性的一个限制是读取属性的类型必须可分配给您正在编写的类型。换句话说，getter类型必须可分配给Setter。这可确保某些级别的一致性，以便属性始终为自己分配。</p><p>   When extending classes in JavaScript, the language makes it super easy (pun intended) to override methods – but unfortunately, there are some mistakes that you can run into.</p><p>   在JavaScript中扩展课程时，该语言使其超级容易（双关语）来覆盖方法 - 但不幸的是，您可以遇到一些错误。</p><p>  class  SomeComponent  {  show ( )  {  // ...  }  hide ( )  {  // ...  } } class  SpecializedComponent  extends  SomeComponent  {  show ( )  {  // ...  }  hide ( )  {  // ...  } }</p><p>  class someComponent {show（）{// ...} hide（）{// ...} {// ...}} class specialedComponent扩展了SomeComponent {show（）{// ...} hide（）{// ...}}</p><p> SpecializedComponent subclasses  SomeComponent, and overrides the  show and  hide methods. What happens if someone decides to rip out  show and  hide and replace them with a single method?</p><p> 专门的组合子类别一组分数，并覆盖显示和隐藏方法。如果有人决定用单一方法撕掉并将它们替换并替换它们，会发生什么？</p><p> class SomeComponent { - show() { - // ... - } - hide() { - // ... - } + setVisible(value: boolean) { + // ... + } } class SpecializedComponent extends SomeComponent { show() { // ... } hide() { // ... } }</p><p> class someComponent { -  show（）{ -  // ...  - }  -  hide（）{ -  // ...  - } + setvisible（value：boolean）{+ // ... +}} class specialedcomponent扩展了一组组合{ 显示隐藏（） { // ... } }</p><p> Oh no! Our  SpecializedComponent didn’t get updated. Now it’s just adding these two useless  show and  hide methods that probably won’t get called.</p><p> 不好了！我们的专业营养不良没有更新。现在它只是添加了这两个无用的展示和隐藏的方法，可能不会被称为。 </p><p> Part of the issue here is that a user can’t make it clear whether they meant to add a new method, or to override an existing one. That’s why TypeScript 4.3 adds the  override keyword.</p><p>这里的部分问题是用户无法清楚地清楚他们是否意味着添加新方法，或覆盖现有方法。这就是为什么打字4.3添加override关键字。</p><p> class  SpecializedComponent  extends  SomeComponent  {  override  show ( )  {  // ...  }  override  hide ( )  {  // ...  } }</p><p> Class SpecialedComponent扩展了SomeComponent {override show（）{// ...} override hide（）{// ...}}</p><p> When a method is marked with  override, TypeScript will always make sure that a method with the same name exists in a the base class.</p><p> 当用覆盖标记方法时，键盘将始终确保基类中存在具有相同名称的方法。</p><p> class  SomeComponent  {  setVisible ( value:  boolean )  {  // ...  } } class  SpecializedComponent  extends  SomeComponent  {  override  show ( )  { // ~~~~~~~~ // Error! This method can&#39;t be marked with &#39;override&#39; because it&#39;s not declared in &#39;SomeComponent&#39;.  // ...  }  // ... }</p><p> class someComponent {setvisible（value：boolean）{// ...}}类专门普通符号扩展了someComponent {override show（）{// ~~~~~~~~ //错误！这种方法可以＆＃39; t＆＃39;覆盖＆＃39;因为它没有宣布在＆＃39;单体组分和＃39; // ...} // ......}</p><p> This is a big improvement, but it doesn’t help if you  forget to write  override on a method – and that’s a big mistake users can run into also.</p><p> 这是一个很大的改进，但如果您忘记在方法上写覆盖，则没有帮助 - 这是用户也可以遇到的大错误。</p><p> For example, you might accidentally “trample over” a method that exists in a base class without realizing it.</p><p> 例如，您可能会意外地“践踏”一个在基本类中存在的方法，而不实现它。</p><p> class  Base  {  someHelperMethod ( )  {  // ...  } } class  Derived  extends  Base  {  // Oops! We weren&#39;t trying to override here,  // we just needed to write a local helper method.  someHelperMethod ( )  {  // ...  } }</p><p> Class Base {yeyhelpermethod（）{// ...}}派生扩展基础{// oops！我们试图覆盖这里，//我们只需要编写本地辅助方法。 yeuhelpermethod（）{// ...}} </p><p> That’s why TypeScript 4.3  also provides a new  --noImplicitOverride flag. When this option is turned on, it becomes an error to override any method from a superclass unless you explicitly use an  override keyword. In that last example, TypeScript would error under  --noImplicitOverride, and give us a clue that we probably need to rename our method inside of  Derived.</p><p>这就是为什么打字4.3还提供了一个新的--noimplicodoverride标志。打开此选项后，除非您显式使用覆盖关键字，否则它将从超类中覆盖任何方法。在该最后一个示例中，打字签名将在--noimplicatoverride错误，并给我们一个线索，我们可能需要重命名我们的方法。</p><p> We’d like to extend our thanks to our community for the implementation here. The work for these items was implemented in  a pull request by  Wenlu Wang, though an earlier pull request implementing only the  override keyword by  Paul Cody Johnston served as a basis for direction and discussion. We extend our gratitude for putting in the time for these features.</p><p> 我们谨此感谢我们的社区在此处实现。这些物品的工作是在Wenlu Wang的拉拉请求中实施，尽管早期的拉请求仅由Paul Cody Johnston实现覆盖关键字作为方向和讨论的基础。我们欣慰我们对这些功能的时间来说。</p><p>  In recent versions, TypeScript introduced a new type construct: template string types. These are types that either construct new string-like types by concatenating…</p><p>  在最近的版本中，TypeScript推出了一个新型构造：模板字符串类型。这些是通过连接构建新的字符串状类型的类型......</p><p> type  Color  =  &#34;red&#34;  |  &#34;blue&#34; ; type  Quantity  =  &#34;one&#34;  |  &#34;two&#34; ; type  SeussFish  =  `  ${ Quantity  |  Color } fish` ; // same as // type SeussFish = &#34;one fish&#34; | &#34;two fish&#34; // | &#34;red fish&#34; | &#34;blue fish&#34;;</p><p> 键入color =＆＃34;红色＆＃34; | ＆＃34;蓝色＆＃34; ;类型数量=＆＃34;一个＆＃34; | ＆＃34;两个＆＃34; ;键入seussfish =`$ {数量|颜色}鱼类; //与//键入seussfish =＆＃34;一条鱼＆＃34; | ＆＃34;两条鱼＆＃34; // | ＆＃34;红色鱼＆＃34; | ＆＃34;蓝色鱼＆＃34 ;;</p><p>   The first change we made is just in when TypeScript will infer a template string type. When a template string is  contextually typed by a string-literal-like type (i.e. when TypeScript sees we’re passing a template string to something that takes a literal type) it will try to give that expression a template type.</p><p>   我们所做的第一个更改就在打字机将推断模板字符串类型时。当由字符串文字类型中上下文键入模板字符串时（即，当CyperScript看到我们将模板字符串传递给采用文字类型时）时，它将尝试为该表达式提供模板类型。</p><p> function  bar ( s:  string ):  `hello   ${string }`  {  // Previously an error, now works!  return  `hello   ${s }` ; }</p><p> 功能栏（s：string）：`hello $ {string}`{//以前的错误，现在有效！返回“你好$ {s}`; }</p><p>  declare  let  s:  string ; declare  function  f &lt; T  extends  string &gt; ( x:  T ):  T ; // Previously: string // Now : `hello-${string}` let  x2  =  f ( `hello   ${s }` ) ;</p><p>  声明s：string;声明函数f＆lt; T延伸弦＆gt; （x：t）：t; //以前：string //现在：`hello  -  $ {string}`设x2 = f（`hello $ {s}`）; </p><p> The second major change here is that TypeScript can now better-relate, and  infer between, different template string types.</p><p>这里的第二个主要变更是TypeScript现在可以更好地相关，并在不同的模板字符串类型之间推断。</p><p>   When checking against a string literal type like on  s2, TypeScript could match against the string contents and figure out that  s2 was compatible with  s1 in the first assignment; however, as soon as it saw another template string, it just gave up. As a result, assignments like  s3 to  s1 just didn’t work.</p><p>   当以S2上的像字符串文字类型检查时，打字标注可以匹配字符串内容并弄清楚S2在第一个分配中与S1兼容;但是，一旦看到另一个模板字符串，它就会放弃。因此，S3到S1等分配只是不起作用。</p><p> TypeScript now actually does the work to prove whether or not each part of a template string can successfully match. You can now mix and match template strings with different substitutions and TypeScript will do a good job to figure out whether they’re really compatible.</p><p> TypeScript现在实际上是为了证明模板字符串的每个部分是否可以成功匹配。您现在可以混合和匹配具有不同替换的模板字符串，并且打字签字将做好弄清楚他们是否真的兼容。</p><p> declare  let  s1:  `  ${number }-  ${number }-  ${number }` ; declare  let  s2:  `1-2-3` ; declare  let  s3:  `  ${number }-2-3` ; declare  let  s4:  `1-  ${number }-3` ; declare  let  s5:  `1-2-  ${number }` ; declare  let  s6:  `  ${number }-2-  ${number }` ; // Now *all of these* work! s1  =  s2 ; s1  =  s3 ; s1  =  s4 ; s1  =  s5 ; s1  =  s6 ;</p><p> 声明Let S1：`$ {number}  -  $ {number}  -  $ {number}`;宣布让S2：`1-2-3`;声明让S3：“$ {number} -2-3`;声明Let S4：`1- $ {node} -3`;声明让S5：`1-2- $ {node }`;声明Let S6：`$ {number} -2- $ {number}`; //现在*所有这些*工作！ S1 = S2; s1 = s3; S1 = S4; s1 = s5; S1 = S6;</p><p> In doing this work, we were also sure to add better inference capabilities. You can see an example of these in action:</p><p> 在进行这项工作时，我们也肯定会增加更好的推理能力。您可以在操作中看到这些示例：</p><p> declare  function  foo &lt; V  extends  string &gt; ( arg: ` *${ V } *` ):  V ; function  test &lt; T  extends  string &gt; ( s:  string ,  n:  number ,  b:  boolean ,  t:  T )  {  let  x1  =  foo ( &#34;*hello*&#34; ) ;  // &#34;hello&#34;  let  x2  =  foo ( &#34;**hello**&#34; ) ;  // &#34;*hello*&#34;  let  x3  =  foo ( `*  ${s }*`  as  const ) ;  // string  let  x4  =  foo ( `*  ${n }*`  as  const ) ;  // `${number}`  let  x5  =  foo ( `*  ${b }*`  as  const ) ;  // &#34;true&#34; | &#34;false&#34;  let  x6  =  foo ( `*  ${t }*`  as  const ) ;  // `${T}`  let  x7  =  foo ( `**  ${s }**`  as  const ) ;  // `*${string}*` }</p><p> 声明功能foo＆lt; v延长字符串＆gt; （arg：`* $ {v} *`）：v;功能测试＆lt; T延伸弦＆gt; （s：string，n：number，b：boolean，t：t）{let x1 = foo（＆＃34; * hello *＆＃34;）; //＃34;你好＆＃34;让x2 = foo（＆＃34; **你好**＆＃34;）; //＃34; *你好*＆＃34;让x3 = foo（`* $ {s} *`为const）; //字符串让x4 = foo（`* $ {n} *`为const）; //` $ {number}`设x5 = foo（`* $ {b} *`为const）; //＃34;真＆＃34; | ＆＃34;假＆＃34;让x6 = foo（`* $ {t} *`为const）; //` $ {t}`设x7 = foo（`** $ {s} **`为const）; //` * $ {string} *`}</p><p>   TypeScript 4.3 expands which elements in a class can be given  #private  #names to make them truly private at run-time. In addition to properties, methods and accessors can also be given private names.</p><p>   TypeScript 4.3展开了可以给出类中的哪个元素#private #names，使其在运行时真正私有。除属性外，还可以给出私有名称的方法和访问器。 </p><p> class  Foo  { # someMethod ( )  {  //...  }  get # someValue ( )  {  return  100 ;  }  publicMethod ( )  {  // These work.  // We can access private-named members inside this class.  this .# someMethod ( ) ;  return  this .# someValue ;  } } new  Foo ( ) .# someMethod ( ) ; // ~~~~~~~~~~~ // error! // Property &#39;#someMethod&#39; is not accessible // outside class &#39;Foo&#39; because it has a private identifier. new  Foo ( ) .# someValue ; // ~~~~~~~~~~ // error! // Property &#39;#someValue&#39; is not accessible // outside class &#39;Foo&#39; because it has a private identifier.</p><p>class foo {＃somemethod（）{// ...} get＃somevalue（）{return 100; publicmethod（）{//这些工作。 //我们可以访问此类中的私有名为成员。这个。＃somemethod（）;返回这个。＃somevalue; new foo（）。＃somemethod（）; // ~~~~~~~~~~~ //错误！ //属性＆＃39;＃somemethod＆＃39;不可访问//外部类＆＃39; foo＆＃39;因为它具有私有标识符。新foo（）。＃somevalue; // ~~~~~~~~~~ //错误！ //属性＆＃39;＃somevalue＆＃39;不可访问//外部类＆＃39; foo＆＃39;因为它具有私有标识符。</p><p>  class  Foo  {  static # someMethod ( )  {  // ...  } } Foo .# someMethod ( ) ; // ~~~~~~~~~~~ // error! // Property &#39;#someMethod&#39; is not accessible // outside class &#39;Foo&#39; because it has a private identifier.</p><p>  class foo {static＃somemethod（）{// ...}} foo。＃somemethod（）; // ~~~~~~~~~~~ //错误！ //属性＆＃39;＃somemethod＆＃39;不可访问//外部类＆＃39; foo＆＃39;因为它具有私有标识符。</p><p> This feature was authored  in a pull request from our friends at Bloomberg – written by  Titian Cernicova-Dragomirand  Kubilay Kahveci, with support and expertise from  Joey Watts,  Rob Palmer, and  Tim McClure. We’d like to extend our thanks to all of them!</p><p> 此功能均撰写于彭博（Bloomberg）的朋友的提取请求 - 由Titian Cernicova-Dragomirand Kubilay Kahveci撰写，提供Joey Watts，Rob Palmer和Tim McClure的支持和专业知识。我们谨此感谢所有人！</p><p>  Under  strictNullChecks, checking whether a  Promise is “truthy” in a conditional will trigger an error.</p><p>  在StrickNullChecks下，检查有条件中的承诺是否是“真的”将触发错误。</p><p> async  function  foo ( ):  Promise &lt; boolean &gt;  {  return  false ; } async  function  bar ( ):  Promise &lt; string &gt;  {  if  ( foo ( ) )  {  // ~~~~~  // Error!  // This condition will always return true since  // this &#39;Promise&lt;boolean&gt;&#39; appears to always be defined.  // Did you forget to use &#39;await&#39;?  return  &#34;true&#34; ;  }  return  &#34;false&#34; ; }</p><p> 异步函数foo（）：promise＆lt;布尔＆gt; {返回false; }异步函数栏（）：promise＆lt;字符串＆gt; {if（foo（））{// ~~~~~ //错误！ //这种情况总是返回truit以来//这个＆＃39; promise＆lt; boolean＆gt;＆＃39;似乎始终定义。 //你忘了使用＆＃39;等待＆＃39 ;?返回＆＃34;真实＆＃34; ; }返回＆＃34;假＆＃34; ; }</p><p>   Index signatures allow us set more properties on a value than a type explicitly declares.</p><p>   索引签名允许我们在比明确声明的类型上设置更多属性。</p><p> class  Foo  {  hello  =  &#34;hello&#34; ;  world  =  1234 ;  // This is an index signature:  [ propName:  string ]:  string  |  number  |  undefined ; } let  instance  =  new  Foo ( ) ; // Valid assigment instance [ &#34;whatever&#34; ]  =  42 ; // Has type &#39;string | number | undefined&#39;. let  x  =  instance [ &#34;something&#34; ] ;</p><p> 班级foo {hello =＆＃34;你好＆＃34; ;世界= 1234; //这是一个索引签名：[propname：string]：String |号码|不明确的 ; lever insioft = new foo（）; //有效的挖掘实例[＆＃34;无论如何＆＃34; ] = 42; //有类型＆＃39; string |号码| undefined＆＃39;让x =实例[＆＃34;某事＆＃34; ]; </p><p> Up until now, an index signature could only be declared on the instance side of a class. Thanks to  a pull request from  Wenlu Wang, index signatures can now be declared as  static.</p><p>到目前为止，索引签名只能在类的实例侧声明。由于来自Wenlu Wang的拉拔请求，现在可以将索引签名声明为静态。</p><p> class  Foo  {  static  hello  =  &#34;hello&#34; ;  static  world  =  1234 ;  static  [ propName:  string ]:  string  |  number  |  undefined ; } // Valid. Foo [ &#34;whatever&#34; ]  =  42 ; // Has type &#39;string | number | undefined&#39; let  x  =  Foo [ &#34;something&#34; ] ;</p><p> Class Foo {静态Hello =＆＃34;你好＆＃34; ;静态世界= 1234;静态[propname：string]：String |号码|不明确的 ; } // 有效的。 foo [＆＃34;无论如何＆＃34; ] = 42; //有类型＆＃39; string |号码| undefined＆＃39;让x = foo [＆＃34;某事＆＃34; ];</p><p> The same sorts of rules apply for index signatures on the static side of a class as they do for the instance side – namely, that every other static property has to be compatible with the index signature.</p><p> 相同类型的规则适用于类的静态侧面上的索引签名，因为它们为实例侧面执行了 - 即，每个其他静态属性都必须与索引签名兼容。</p><p> class  Foo  {  static  prop  =  true ;  // ~~~~  // Error! Property &#39;prop&#39; of type &#39;boolean&#39;  // is not assignable to string index type  // &#39;string | number | undefined&#39;.  static  [ propName:  string ]:  string  |  number  |  undefined ; }</p><p> 类foo {静态prop = true; // ~~~~ //错误！物业＆＃39; prop＆＃39;类型＆＃39;布尔＆＃39; //未分配给字符串索引类型///＃39;字符串|号码| undefined＆＃39;静态[propname：string]：String |号码|不明确的 ; }</p><p>  One of the biggest pain-points users run into with import and export statements in JavaScript is the order – specifically that imports are written as</p><p>  在JavaScript中使用导入和导出语句遇到的最大痛苦点之一是订单 - 特别是导入是写入的</p><p>    This causes some pain when writing out a full import statement from scratch because auto-complete wasn’t able to work correctly. For example, if you start writing something like  import {, TypeScript has no idea what module you’re planning on importing from, so it couldn’t provide any scoped-down completions.</p><p>    当从头开始写出完整的导入语句时，这会导致一些疼痛，因为自动完成无法正常工作。例如，如果您开始编写导入{，打字签名不知道您正在计划导入哪些模块，因此它无法提供任何击尾完成。</p><p> To alleviate this, we’ve leveraged the power of auto-imports! Auto-imports already deal with the issue of not being able to narrow down completions from a specific module – their whole point is to provide every possible export and automatically insert an import statement at the top of your file.</p><p> 为了减轻这一点，我们利用自动进口的力量！自动导入已经处理了无法从特定模块缩小完成的问题 - 他们的整个点是提供各种可能的导出，并自动在文件顶部插入导入语句。 </p><p> So when you now start writing an  import statement that doesn’t have a path, we’ll provide you with a list of possible imports. When you commit a completion, we’ll complete the full import statement, including the path that you were going to write.</p><p>因此，当您现在开始编写没有路径的导入语句时，我们将为您提供可能导入的列表。完成完成后，我们将完成完整的导入语句，包括您要写的路径。</p><p>  This work requires editors that specifically support the feature. You’ll be able to try this out by using the latest  Insiders versions of Visual Studio Code.</p><p>  这项工作要求专门支持该功能的编辑器。您将能够使用最新的Insiders版本的Visual Studio代码来试用这一点。</p><p>   TypeScript can now understand  @link tags, and will try to resolve declarations that they link to. What this means is that you’ll be able to hover over names within  @link tags and get quick information, or use commands like go-to-definition or find-all-references.</p><p>   TypeScript现在可以了解@Link标签，并尝试解决链接到的声明。这意味着你可以在@Link标签中悬停在@Link标签中的名称上，并获取快速信息，或使用像Go-to定义或查找所有引用的命令。</p><p> For example, you’ll be able to go-to-definition on  bar in  @link bar in the example below and a TypeScript-supported editor will jump to  bar‘s function declaration.</p><p> 例如，您可以在下面的示例中在@Link栏中的BAR上的定义，并跳转到栏的函数声明。</p><p>     As with every TypeScript version, declarations for  lib.d.ts (especially the declarations generated for web contexts), have changed.In this release, we leveraged  Mozilla’s browser-compat-data to remove APIs that no browser implements.While it is unlike that you are using them, APIs such as  Account,  AssertionOptions,  RTCStatsEventInit,  MSGestureEvent,  DeviceLightEvent,  MSPointerEvent,  ServiceWorkerMessageEvent, and  WebAuthentication have all been removed from  lib.d.ts.This is discussed  in some detail here.</p><p>     与每个类型的版本版本一样，lib.d.ts的声明（尤其是Web上下文生成的声明）已更改。在此版本中，我们利用Mozilla的浏览器 - 兼容数据来删除没有浏览器实现的API。它与之不同您正在使用它们，如帐户，断言，rtcstatsevent，msporefentvent，deviceLightevent，mspointerevent，serviceworkermessevent和webauthentication的API，都已从lib.ts中删除。这是在这里的一些细节中讨论的。</p><p>  Under  strictNullChecks, using a  Promise that always appears to be defined within a condition check is now considered an error.</p><p>  在StrickNullChecks下，使用始终似乎在条件检查中定义的承诺现在被视为错误。</p><p> declare  var  p:  Promise &lt; number &gt; ; if  ( p )  { // ~ // Error! // This condition will always return true since // this &#39;Promise&lt;number&gt;&#39; appears to always be defined. // // Did you forget to use &#39;await&#39;? }</p><p> 声明var p：promise＆lt;号码＆gt; ; if（p）{//〜//错误！ //这种情况总是返回true以来// this＆＃39; promise＆lt; number＆gt;＆＃39;似乎始终定义。 // //你忘了使用＆＃39;等待＆＃39 ;? } </p><p>   Certain  enums are considered  union  enums when their members are either automatically filled in, or trivially written. In those cases, an enum can recall each value that it potentially represents.</p><p>当他们的成员自动填写或琐碎地写入时，某些枚举被认为是Union枚举。在这些情况下，枚举可以调用它可能代表的每个值。</p><p> In TypeScript 4.3, if a value with a union  enum type is compared with a numeric literal that it could never be equal to, then the type-checker will issue an error.</p><p> 在键盘4.3中，如果将具有Union枚举类型的值与数字文字相比，它永远不会等于，则Type-Checker将发出错误。</p><p> enum  E  {  A  =  0 ,  B  =  1 , } function  doSomething ( x:  E )  {  // Error! This condition will always return &#39;false&#39; since the types &#39;E&#39; and &#39;-1&#39; have no overlap.  if  ( x  ===  - 1 )  {  // ...  } }</p><p> enum e {a = 0，b = 1，}函数dosomething（x：e）{//错误！这种情况总是返回＆＃39;假＆＃39;自从类型＆＃39; E＆＃39;和＃39; -1＆＃39;没有重叠。 if（x ===  -  1）{// ...}}</p><p>  enum  E  {  A  =  0 ,  B  =  1 , } // Include -1 in the type, if we&#39;re really certain that -1 can come through. function  doSomething ( x:  E  |  - 1 )  {  if  ( x  ===  - 1 )  {  // ...  } }</p><p>  enum e {a = 0，b = 1，} //在类型中包含-1，如果我们＆＃39;重新确认-1可以通过。功能dosomething（x：e |  -  1）{if（x ===  -  1）{// ...}}</p><p>  enum  E  {  A  =  0 ,  B  =  1 , } function  doSomething ( x:  E )  {  // Use a type asertion on &#39;x&#39; because we know we&#39;re not actually just dealing with values from &#39;E&#39;.  if  ( ( x  as  number )  ===  - 1 )  {  // ...  } }</p><p>  enum e {a = 0，b = 1，}函数dosomething（x：e）{//使用＆＃39的类型asertion; x＆＃39;因为我们知道我们＆＃39;重复实际上只是处理来自＆＃39; E＆＃39; if（（x as number）===  -  1）{// ...}}</p><p> Alternatively, you can re-declare your enum to have a non-trivial initializer so that any number is both assignable and comparable to that enum. This may be useful if the intent is for the enum to specify a few well-known values.</p><p> 或者，您可以重新声明您的枚举具有非普通初始化程序，以便任何数字都分配和与该枚举相媲美。如果意图是枚举指定少数名众所周知的值，则这可能是有用的。</p><p> enum  E  {  // the leading + on 0 opts TypeScript out of inferring a union enum.  A  =  + 0 ,  B  =  1 , }</p><p> Enum E {//前导+ ON 0选择推断出Union枚举的类型。 a = + 0，b = 1，} </p><p>   You can keep track of the upcoming release candidate and stable releases by checking up on the  TypeScript 4.3 Iteration Plan. We’re looking to get feedback on this beta (or better yet,  our nightly releases), so give it a shot today!</p><p>您可以通过检查TypeScript 4.3迭代计划来跟踪即将发布的候选人和稳定版本。 我们希望在这个测试版（或者更好，我们的夜间版本）获得反馈，所以今天给它一个拍摄！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-3-beta/">https://devblogs.microsoft.com/typescript/announcing-typescript-4-3-beta/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>