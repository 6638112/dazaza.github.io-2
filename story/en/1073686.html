<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>深入介绍TypeScript中的类装饰器Deep introduction to class decorators in TypeScript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Deep introduction to class decorators in TypeScript<br/>深入介绍TypeScript中的类装饰器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 03:57:53</div><div class="page_narrow text-break page_content"><p>Decorators allow us to add additional information to classes or methods in TypeScript, and are similar to annotations such as in Java. Class decorators are applied to class definitions in TypeScript, and can observe, modify, or replace the class definition.</p><p>decorator允许我们向TypeScript中的类或方法添加额外的信息，类似于Java中的注释。类装饰器应用于TypeScript中的类定义，可以观察、修改或替换类定义。</p><p>      This article takes a deep dive into defining and using TypeScript class decorators. To use decorators, they must be enabled in TypeScript, so be sure to  review the introduction to decorators article in this series. Primarily class decorators are used to add metadata to the class, which will be used by other decorators. But, class decorators can also return a new constructor to override or replace the existing constructor, or class, adding new methods or other behavior.</p><p>本文深入探讨了TypeScript类装饰器的定义和使用。要使用decorators，必须在TypeScript中启用它们，所以一定要查看本系列中的decorators简介文章。类装饰器主要用于向类添加元数据，其他装饰器将使用元数据。但是，类装饰器也可以返回一个新的构造函数来覆盖或替换现有的构造函数或类，从而添加新方法或其他行为。</p><p>   That is, you immediately precede the  class keyword with one or more decorators. With some decorators the parameters configure its behavior. Other decorators do not require parameters, which will be explained in the documentation.</p><p>也就是说，在class关键字前面立即加上一个或多个decorator。通过一些装饰器，参数可以配置其行为。其他装饰师不需要参数，这将在文档中解释。</p><p>        Let&#39;s try a simple example of a class decorator, which simply prints the data it is given.</p><p>让&#39；让我们尝试一个简单的类装饰器示例，它只打印给定的数据。</p><p> function  ( constructor:  Function) {  const ret = { constructor,  :  . (constructor),  :  . (constructor),  :  . (constructor),  :  . (constructor),  :  . (constructor),  : {} };  for ( const key  of  . (constructor.  prototype)) { ret. members[key] = constructor.  prototype[key]; }  console. ( `ClassDecoratorExample `, ret);}  class   {  ( x:  number, y:  number) {  console. ( `ClassDecoratorExample( ${x},  ${y})`); }  ( ) {  console. ( `method called`); }} new  ( 3,  4). ()</p><p>函数（构造函数：函数）{const ret={constructor，：（构造函数），：（构造函数），：（构造函数），：（构造函数），：（构造函数），：{}；for（const key of.（constructor.prototype））{ret.members[key]=constructor.prototype[key]；}安慰（'classdecoreExample'，ret）；]类{（x:number，y:number）{console（`classdecoreExample（${x}，${y}）`；}（）{console.（`method called`）；}新的（3,4）。()</p><p> The  logConstructor is the decorator function for the  @logConstructor decorator, and it implements the prescribed method signature for class decorators. This decorator does not use any parameters, and due to its implementation no parentheses are required.</p><p>logConstructor是@logConstructor decorator的decorator函数，它为类decorators实现指定的方法签名。此装饰器不使用任何参数，并且由于其实现，不需要括号。</p><p> It simply prints out available information about the constructor function. For most we used methods in the  Object class to query data about the class being decorated. In a couple cases the query was against  constructor.prototype, because that object contains implementation details of methods attached to the class.</p><p>它只是打印出有关构造函数的可用信息。对于大多数情况，我们使用对象类中的方法来查询有关被修饰类的数据。在一些情况下，查询是针对构造函数的。原型，因为该对象包含附加到类的方法的实现细节。</p><p> The     decorator-inspectors package in the repository contains a more comprehensive decorator,  LogClassInspector, with a similar purpose.</p><p>存储库中的decorator-inspector包包含一个更全面的decorator LogClassInspector，具有类似的用途。</p><p>  $ npx ts-node lib/classes/first.ts ClassDecoratorExample { constructor: [ class  ClassDecoratorExample],  extensible:  false,  frozen:  false,  sealed:  false,  values: [],  properties: { length: { value:  2, writable:  false, enumerable:  false, configurable:  false }, name: { value:  &#39;ClassDecoratorExample&#39;, writable:  false, enumerable:  false, configurable:  false }, prototype: { value: {}, writable:  false, enumerable:  false, configurable:  false } }, members: { constructor: [ class  ClassDecoratorExample],  method: [ Function:  method] }} ClassDecoratorExample( 3,  4) method  called</p><p>$npx ts node lib/classes/first。ts ClassDecoratorExample{constructor:[class ClassDecoratorExample]，可扩展：false，冻结：false，密封：false，值：[]，属性：{length:{value:2，可写：false，可枚举：false，可配置：false}，名称：{value:&#39；ClassDecoratorExample&#39；，可写：false，可枚举：false，可配置：false}，原型：{value:{}，可写：false，可枚举：false，可配置：false}，成员：{constructor:[classdecorexample]，method:[Function:method]}classdecorexample（3，4）调用的方法</p><p> The values in  properties are  PropertyDescriptor objects which we&#39;ll see again and again. Most of us do not need to delve this deeply behind the scenes of JavaScript. But, to implement decorators we will need to know a few things.</p><p>属性中的值是PropertyDescriptor对象，我们&#39；我会再三看的。我们大多数人不需要在JavaScript的幕后深入研究这一点。但是，要实现decorators，我们需要知道一些事情。</p><p> For example, did you know about the  sealed or  frozen settings on Objects? Now that I know about them, it&#39;s sure looks useful to be able to turn on either of those settings. This decorator makes it easy:</p><p>例如，您知道对象上的密封或冻结设置吗？现在我了解了他们，它&#39；It’启用这两种设置看起来都很有用。这个装饰师让它变得简单：</p><p>     We can easily add multiple decorators to any decoratable thing. There is an execution order for multiple decorators, in which they execute from the bottom upwards. Hence, the output will now say  sealed: true because  @sealed will have executed first. If you place  @sealed above  logConstructor it will still say  sealed: false because  @sealed will have executed second.</p><p>我们可以轻松地为任何可装饰的东西添加多个装饰器。多个装饰器有一个执行顺序，它们从下往上执行。因此，输出现在将显示sealed:true，因为@sealed将首先执行。如果你把@sealed放在logConstructor上面，它仍然会说sealed:false，因为@sealed将在第二个执行。</p><p>  Decorators can also take arguments.  As we said in the introduction, this requires following a different pattern called the decorator factory.</p><p>装饰师也可以接受参数。正如我们在介绍中所说，这需要遵循一种不同的模式，称为装饰工厂。</p><p> Here is a simple class decorator example that not only shows how to pass in parameters, but helps us understand the order of execution when using multiple decorators.</p><p>下面是一个简单的类装饰器示例，它不仅展示了如何传入参数，还帮助我们理解使用多个装饰器时的执行顺序。</p><p> function  ( path:  string) {  console. ( `outer withParam  ${path}`);  return  ( target:  Function) =&gt; {  console. ( `inner withParam  ${path}`); };} ( &#39;first&#39;) ( &#39;middle&#39;) ( &#39;last&#39;) class   {}</p><p>函数（路径：字符串）{console（`outer with param${path}`）；返回（目标：函数）=&gt；{console.（`internal withParam${path}`）；}；}（&#39；第一&#39；）（&#39；中&#39；）（&#39；最后&#39；）类{}</p><p> The outer function,  withParam, takes the argument list to be used with the decorator. The inner function is the decorator function, and is where the required signature is to be implemented. It is the inner function that will contain the actual decorator implementation.</p><p>外部函数withParam获取要与装饰器一起使用的参数列表。内部函数是decorator函数，是实现所需签名的地方。它是包含实际装饰器实现的内部函数。</p><p> What happens is  withParam(parameter) is an expression which returns a function with the correct signature to be a class decorator. That makes the inner function the decorator function, and the outer function is a factory that generates that function.</p><p>withParam（parameter）是一个表达式，它返回一个具有正确签名的函数作为类装饰器。这使得内部函数成为装饰函数，而外部函数是生成该函数的工厂。</p><p> In this example we&#39;ve attached  withParam three times so we can learn a bit more about the execution order.</p><p>在这个例子中，我们&#39；我已经三次附上param，这样我们可以了解更多关于执行顺序的信息。</p><p> $ npx ts -node lib /classes /constructors.ts  outer withParam  first outer withParam middle outer withParam  last inner withParam  last inner withParam middle inner withParam  first</p><p>$npx ts-节点库/类/构造函数。ts outer with param first outer with param middle outer with param last inner with param last inner with param middle inner with param first</p><p> We discussed this in detail  in the introduction. Remember that the factory functions execute from top to bottom, and after that the decorator functions execute from bottom to top.</p><p>我们在引言中详细讨论了这一点。请记住，工厂函数从上到下执行，之后装饰函数从下到上执行。</p><p>  Let&#39;s examine one possible practical use for a class decorator. Namely, a framework might keep lists of classes of certain kinds. For this example we&#39;ll mimic a web app framework where certain classes hold URL routing functions. Each router class handles routes for a certain URL prefix, along with specific configuration for that route.</p><p>让&#39；让我们来研究一下类装饰器的一个可能的实际用途。也就是说，一个框架可能会保存某些类型的类的列表。对于这个例子，我们&#39；我们将模拟一个web应用程序框架，其中某些类具有URL路由功能。每个路由器类处理特定URL前缀的路由，以及该路由的特定配置。</p><p> const registeredClasses = []; function  ( path:  string, options ?:  object) {  return  ( constructor:  Function) =&gt; { registeredClasses. ({ constructor, path, options }); };} ( &#39;/&#39;) class   {  // routing functions} ( &#39;/blog&#39;, {  :  &#39;/blog/rss.xml&#39;}) class   {  // routing functions} console. (registeredClasses);</p><p>常量注册类=[]；函数（路径：字符串，选项？：对象）{return（构造函数：函数）=&gt；{registeredClasses.（{constructor，path，options}）；}；}( &#39;/&#39;) 类{//routing functions}（&#39；/blog&#39；，{：&#39；/blog/rss.xml&#39；}）类{//路由函数}控制台。（注册类别）；</p><p> Router is a factory function producing a class decorator that adds classes to the  registeredClasses array. The function takes two options, where  path is the URL path prefix, and  options is an optional configuraton object.</p><p>Router是一个工厂函数，它生成一个类装饰器，将类添加到RegisteredClass数组中。该函数有两个选项，其中path是URL路径前缀，options是可选的configuraton对象。</p><p> Because class decorators run last, there&#39;s an option for the class decorator do something in regard to any methods or properties contained within the class. Also, the more common approach to storing data is not an array like this, but to use the  Reflection Metadata API, which we talk about later.</p><p>因为班级装饰师排在最后，所以&#39；对于类中包含的任何方法或属性，类装饰器可以选择做些什么。此外，更常见的存储数据的方法不是这样的数组，而是使用反射元数据API，我们将在后面讨论。</p><p>  $ npx ts-node lib /classes/register.ts [ { constructor: [ class HomePageRouter], path:  &#39;/&#39;,  options: undefined }, { constructor: [ class BlogRouter], path:  &#39;/blog&#39;,  options: { rss:  &#39;/blog/rss.xml&#39; } }]</p><p>$npx ts节点库/类/寄存器。ts[{constructor:[class HomePageRouter]，路径：&#39；/&#39；，选项：未定义，{constructor:[class BlogRouter]，路径：&#39；/blog&#39；，选项：{rss:&#39；/blog/rss.xml&#39；}]</p><p> It is up to the hypothetical framework to do something with this data. As we saw earlier, there is quite a lot of additional data that is available by starting with the  constructor object.</p><p>这取决于假设的框架来处理这些数据。正如我们前面看到的，从构造函数对象开始，有很多额外的数据可用。</p><p>  This simple examples were interesting, but let&#39;s try doing something interesting. It&#39;s promised that we can modify or replace the class definition. This will require a bit of wizardry, so let&#39;s take a look.</p><p>这个简单的例子很有趣，但让我们来看看&#39；让我们尝试做一些有趣的事情。它&#39；s承诺我们可以修改或替换类定义。这需要一些魔法，所以让&#39；让我们看看。</p><p> Before we start, take a half a step back and think about this - The class decorator function receives the class object. It does not receive the instance that is being created. We can add properties using  Object.defineProperty(target, ...), but that property is added to the class, and not to any instance which is generated.</p><p>在开始之前，请后退半步，考虑一下这个问题——类装饰器函数接收类对象。它不接收正在创建的实例。我们可以使用Object添加属性。定义属性（目标，…），但该属性被添加到类中，而不是添加到生成的任何实例中。</p><p> To grab onto a random concept, consider an application for recording events during the day of an employee. The employee first clocks in, then after their shift they clock out. Let&#39;s create two classes to record these events, and use a decorator to automatically add a time stamp and unique identifier.</p><p>为了抓住一个随机的概念，考虑一个应用程序记录事件在员工的一天。员工先打卡上班，下班后再打卡下班。让&#39；s创建两个类来记录这些事件，并使用装饰器自动添加时间戳和唯一标识符。</p><p> import { v4  as uuidv4 }  from  &#39;uuid&#39;; function  &lt;T  extends {  (... :  any[]): {}}&gt;( : T) {  return  class   target { uuid =  (); created =  new  (). ( &#34;en-US&#34;);  ( msg:  string) {  console. ( `Extended  ${msg}`); } }}  class   {  // methods and properties}  class   {  // methods and properties}</p><p>从&#39导入{v4 as uuidv4}；uuid&#39；；功能&lt；T扩展{（…：any[]）：{}&gt；（：T）{return class target{uuid=（）；created=new（）。（&#34；en-US&#34；）；（msg:string）{console.（`Extended${msg}`）；}}类{//方法和属性}类{//方法和属性}</p><p> The  TimeStamp decorator has a curious declaration, but this does work, it comes out of the official TypeScript documentation, and does match the required signature for class decorator functions. It appears the  extends clause has something to do with extending a generic class, and therefore T in this case matches any class definition.</p><p>时间戳装饰器有一个奇怪的声明，但这确实有效，它来自正式的TypeScript文档，并且与类装饰器函数所需的签名匹配。extends子句似乎与扩展泛型类有关，因此在本例中，T匹配任何类定义。</p><p> The part with  &lt;T extends { new(...args: any[]): {}}&gt; is a Generic, where  T is defined as something which extends any class. This syntax comes directly from the TypeScript documentation, and is perhaps a more precise way of declaring a class decorator.</p><p>带有&lt；T扩展{new（…args:any[]）：{}}&gt；是泛型，其中T被定义为扩展任何类的东西。这种语法直接来自TypeScript文档，可能是声明类装饰器的更精确的方法。</p><p> The part with  return class extends target is a class operation, and will create a new class that extends the class being decorated. To this new class we&#39;ve added two fields, and a function. The  uuid field is meant to be a unique identifier, and the  created field is a time stamp.</p><p>返回类extends target的部分是一个类操作，它将创建一个新类来扩展被修饰的类。对于这个新班级，我们&#39；我们添加了两个字段和一个函数。uuid字段是一个唯一标识符，创建的字段是一个时间戳。</p><p>    We&#39;re generating two instances of  ClockIn to verify that each instance gets a unique identifier. We then print out some pieces of data.</p><p>我们&#39；重新生成ClockIn的两个实例，以验证每个实例是否获得唯一标识符。然后我们打印出一些数据。</p><p>  $ npx ts-node lib/classes/timestamp.ts  ClockIn {  uuid:  &#39;bc3e6f35-c85d-491d-82c0-c906deacc774&#39;, created:  &#39;2/10/2022, 6:11:53 PM&#39;} ClockIn {  uuid:  &#39;13eb2df6-b9e7-4735-9130-a7ee13182d33&#39;, created:  &#39;2/10/2022, 6:11:53 PM&#39;} ClockOut {  uuid:  &#39;31ce8e88-90e0-40d7-9eb2-cbba5c879b5d&#39;, created:  &#39;2/10/2022, 6:11:53 PM&#39;} true bc3e6f35-c85d-491d-82c0-c906deacc774bc3e6f35-c85d-491d-82c0-c906deacc774Extended WorldExtended World  #2</p><p>$npx ts节点库/类/时间戳。ts时钟{uuid:&#39；bc3e6f35-c85d-491d-82c0-c906deacc774&#39；，创建：&#39；2022年2月10日，下午6:11:53&#39；}时钟{uuid:&#39；13eb2df6-b9e7-4735-9130-a7ee13182d33&#39；，创建：&#39；2022年2月10日，下午6:11:53&#39；}时钟输出{uuid:&#39；31ce8e88-90e0-40d7-9eb2-cbba5c879b5d&#39；，创建：&#39；2022年2月10日，下午6:11:53&#39；}真正的bc3e6f35-c85d-491d-82c0-c906deacc774bc3e6f35-c85d-491d-82c0-c906deacc774Extended WorldExtended World#2</p><p> Our objects do have the added fields, and the two ClockIn instances have different identifiers.</p><p>我们的对象确实有添加的字段，两个时钟实例有不同的标识符。</p><p> Where the code became interesting was trying to directly access a field, such as  ci.uuid. The compiler gives us an error saying the named field does not exist on the type, presumably because the ClockIn class does not have a field named  uuid. But we learn by calling  hasOwnProperty that the added properties do exist, and we can access the properties using  ci[&#39;uuid&#39;] or by casting  ci to  any as in  (&lt;any&gt;ci).uuid.</p><p>代码变得有趣的地方是试图直接访问一个字段，比如ci。乌伊德。编译器给出了一个错误，表示类型上不存在命名字段，可能是因为ClockIn类没有名为uuid的字段。但是我们通过调用hasOwnProperty了解到添加的属性确实存在，并且我们可以使用ci[&#39；uuid&#39；]访问这些属性或者通过在（&lt；any&gt；ci）中对任何ci进行强制转换。乌伊德。</p><p> While we managed to modify the class using a decorator, the result is on the tricky side. Accessing the added properties is unnatural, in this case, making it unattractive to use.</p><p>虽然我们使用装饰器成功地修改了这个类，但结果有点棘手。访问添加的属性是不自然的，在本例中，这使其使用起来没有吸引力。</p><p> The TypeScript documentation demonstrates the same issue. Their example shows adding a field,  reportingURL, via the same mechanism. But an attempt to access that property throws an error,  Property &#39;reportingURL&#39; does not exist on type &#39;BugReport&#39;. It&#39;s explained that because the TypeScript type has not changed, the type system does not know about the added properties. As we&#39;ve demonstrated, those properties are there, and the properties are available by jumping through a hoop.</p><p>TypeScript文档演示了同样的问题。他们的示例显示通过相同的机制添加一个字段reportingURL。但是试图访问该属性会抛出一个错误，property&#39；第39号报告；类型&#39上不存在；BugReport&#39；。它&#39；s解释说，因为TypeScript类型没有更改，所以类型系统不知道添加的属性。正如我们&#39；我已经演示过，这些属性就在那里，而且这些属性可以通过跳环获得。</p><p> But, what happens if we instead override a field defined in the class. Consider this:</p><p>但是，如果我们重写类中定义的字段，会发生什么呢。考虑一下：</p><p> function  &lt;T  extends {  (... :  any[]): {} }&gt;( : T) {  return  class   target {  ( w:  number, h:  number) {  return { w, h,  : w * h }; } }}  class   {  ( w:  number, h:  number) {  return w * h; }} console. ( new  (). ( 5,  6)); console. ( new  (). ( 6,  7));</p><p>功能&lt；T扩展{（…：any[]）：{}&gt；（：T）{return class target{（w:number，h:number）{return{w，h，：w*h}；}}类{（w:number，h:number）{返回w*h；}安慰（新的（）。( 5,  6)); 安慰（新的（）。( 6,  7));</p><p> We have a class,  Overridden, and a decorator named  Override. The class has a function named  area which simply returns the obvious value, the result of multiplying  width and  height. The overridden version returns an anonymous object containing.</p><p>我们有一个名为Override的类和一个名为Override的装饰器。该类有一个名为area的函数，它只返回明显的值，即宽度和高度相乘的结果。被重写的版本返回一个匿名对象，其中包含。</p><p>   Clearly, this did successfully replace the original function with the new one. Further, we did not have to jump through any hoops to access the overriding functionality.</p><p>显然，这确实成功地用新功能取代了原来的功能。此外，我们不需要跳过任何障碍就可以访问最重要的功能。</p><p> What happens if you override a class constructor in the anonymous subclass inside a class decorator?</p><p>如果在类装饰器中重写匿名子类中的类构造函数，会发生什么？</p><p> For example, there are many decorator libraries in the npm/yarn repository focused on logging object creation, method calls, and property accesses. To learn a little how that works, let&#39;s look at one way to print a log message when an instance of a class is created.</p><p>例如，npm/Thread存储库中有许多decorator库专注于记录对象创建、方法调用和属性访问。要了解这一点，让&#39；让我们来看一种在创建类实例时打印日志消息的方法。</p><p> import *  as util  from  &#39;util&#39;; function  &lt;T  extends {  (... :  any[]): {}}&gt;( : T) {  return  class   target {  ( ...args:  any[]) {  super(...args);  console. ( `Create  ${util.inspect(target)} with args=`, args); } }}  class   {  :  number;  :  number;  ( width:  number, height:  number) {  this. height = height;  this. width = width; }  ( ) {  return  this. width *  this. height; }}  class   {  :  number;  ( diameter:  number) {  this. diameter = diameter; }  ( ) {  return (( this. diameter /  2) **  2) * ( . PI); }} const rect1 =  new  ( 3,  5); console. ( `area rect1  ${rect1.area()}`); const rect2 =  new  ( 5,  8); console. ( `area rect2  ${rect2.area()}`); const rect3 =  new  ( 8,  13); console. ( `area rect3  ${rect3.area()}`); const circ1 =  new  ( 20); console. ( `area circ1  ${circ1.area()}`);</p><p>从&#39导入*作为util；util&#39；；功能&lt；T扩展{（…：any[]）：{}&gt；（：T）{return class target{（…args:any[]）{super（…args）；console（`Create${util.inspect（target）}with args=`，args）；}}类{this.height=height；this.width=width；}（）{返回this.width*this.height；}类{：数；（直径：数）{this.diameter=diameter；}（）{return（（this.diameter/2）**2）*（.PI）；}const rect1=new（3,5）；安慰（`area rect1${rect1.area（）}`）；const rect2=新的（5,8）；安慰（`area rect2${rect2.area（）}`）；const rect3=new（8,13）；安慰（`area rect3${rect3.area（）}`）；const circ1=新的（20）；安慰（`area circ1${circ1.area（）}`）；</p><p> We have two simple classes, Rectangle and Circle. The  LogClassCreate decorator extends the class to give it a custom  constructor method. Because this method uses  ...any it can be used with any constructor with any number of arguments.</p><p>我们有两个简单的类，矩形和圆形。LogClassCreate装饰器扩展该类，为其提供一个自定义构造函数方法。因为这个方法使用。。。any它可以与具有任意数量参数的任何构造函数一起使用。</p><p> While the class decorator is invoked when the program launches, the constructor for the anonymous subclass is executed when class instances are created.</p><p>当程序启动时调用类装饰器时，在创建类实例时执行匿名子类的构造函数。</p><p>  $ npx ts-node lib/classes/override2.ts  Create [  class  ]  with   [ 3, 5 ]area rect1  15 Create [  class  ]  with   [ 5, 8 ]area rect2  40 Create [  class  ]  with   [ 8, 13 ]area rect3  104 Create [  class  ]  with   [ 20 ]area circ1  314.1592653589793</p><p>$npx ts node lib/classes/override2。ts Create[class]with[3,5]area rect1 15 Create[class]with[5,8]area rect2 40 Create[class]with[8,13]area rect3 104 Create[class]with[20]area circ1 314.1592653589793</p><p> The messages starting with  Create come from inside the constructor in the anonymous subclass. Indeed, this is decorator code which is executing when instantiating a class instance.</p><p>以Create开头的消息来自匿名子类中的构造函数内部。实际上，这是在实例化类实例时执行的装饰器代码。</p><p> Notice that it correctly records the parameters to the constructor, and that each object is correctly initialized, and produces the correct results. Well, the last one is correct within the limits of JavaScript mathematics, since  Math.PI is a rough estimate.</p><p>请注意，它正确地将参数记录到构造函数中，并且每个对象都已正确初始化，并生成正确的结果。最后一个在JavaScript数学的范围内是正确的，因为数学。PI是一个粗略的估计。</p><p>     error TS1329: &#39;Decorator&#39; accepts too few arguments to be used as a decorator here. Did you mean to call it first and write &#39;@Decorator()&#39;?</p><p>错误TS1329:&#39；装饰师&#39；这里接受的参数太少，无法用作装饰器。你是不是打算先打电话写&#39@Decorator（）&#39；？</p><p> The issue in this case is that class decorators are, as said above, required to take one argument, which is the constructor for a class. We left off that required parameter, and the error messages kinda-sorta-maybe-possibly is telling us so.</p><p>本例中的问题是，如上所述，类装饰器需要接受一个参数，即类的构造函数。我们省略了那个必需的参数，错误消息可能会告诉我们这一点。</p><p>  We have learned quite a bit about class decorators. The decorator receives the class object, and from it we can access quite a lot of data.</p><p>我们已经了解了很多关于课堂装饰师的知识。装饰器接收类对象，我们可以从中访问大量数据。</p><p> The decorator function executes when the class object is created, rather than when class instances are constructed. It means to directly influence anything about generated instances, we must create an anonymous subclass.</p><p>decorator函数在创建类对象时执行，而不是在构造类实例时执行。这意味着要直接影响生成的实例，我们必须创建一个匿名子类。</p><p> Working with the anonymous subclass can be tricky. Accessing any added methods or properties requires jumping through hoops, where overridden methods or properties execute transparently.</p><p>使用匿名子类可能很棘手。访问任何添加的方法或属性都需要跳转，被重写的方法或属性将透明地执行。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/介绍/">#介绍</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>