<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一个看起来如何在git中工作 A look how branches work in Git</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A look how branches work in Git<br/>一个看起来如何在git中工作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 06:38:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/392d8baf2cd63283478d798cb8288330.jpg"><img src="http://img2.diglog.com/img/2021/4/392d8baf2cd63283478d798cb8288330.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Git has won the race for the most popular version control system. But why exactly is it so popular? The answer, at least in my opinion, is pretty clear:  branches! They allow you to keep different versions of your code cleanly separated—ideal when collaborating in a team with other people, but also for yourself when you begin working on a new feature.</p><p>Git赢得了最受欢迎的版本控制系统的比赛。但为什么这么受欢迎？至少在我看来，答案很清楚：分支机构！它们允许您在与其他人的团队合作时，保持不同版本的代码，而且在与其他人一起合作时，还可以在您开始工作的新功能时。</p><p> Although other version control systems also offer some form of branching, Git’s concept and implementation are just stunning. It has made working with branches so quick and easy that many developers have adopted the concept for their daily work.</p><p> 虽然其他版本控制系统还提供某种形式的分支，但Git的概念和实施只是令人惊叹。它使分支机构合作，如此快速，简单地使许多开发人员采用了日常工作的概念。</p><p> In this post, I’d like to explore and explain the what, why, and how of branches:</p><p> 在这篇文章中，我想探索和解释什么，为什么和分支机构：</p><p>  We’ll be looking at the concept of branches in Git from a high-level perspective—with the ultimate goal of better understanding what they are and how they should be used so that you and your team can get the most benefit out of them.</p><p>  我们将从高级观点来看Git中分支机构的概念 - 与更好地理解它们是什么以及应如何使用它们，以便您和您的团队可以获得最大的利益。</p><p>  Put simply, a code base is a collection of files. Any meaningful change (e.g. when developing a new feature or fixing a problem) will most likely involve a couple of those files.</p><p>  简单地，代码库是文件集合。任何有意义的变化（例如，在开发新功能或修复问题时）将很可能涉及几个文件。</p><p> Just for a moment, let’s pretend that version control and especially its concept of “branches” didn’t exist. In such a situation you would have to be very careful when making changes—because you couldn’t easily undo them and you would risk breaking the current, working version. But there’s an easy way to mitigate these risks: you could simply  duplicate the whole project folder! In this copy, you could then make any changes you like, without worrying about breaking something.</p><p> 只是片刻，让我们假装版本控制，特别是其“分支机构”的概念。在这种情况下，在进行更改时，您必须非常小心 - 因为您无法轻易撤消它们，并且您将冒出突破当前工作版本的风险。但是有一种缓解这些风险的简单方法：您可以简单地复制整个项目文件夹！在此副本中，您可以在不担心打破某些内容的情况下进行任何更改。</p><p> Branches in Git have the exact same effect and purpose: they provide developers with separate workspaces for their code. Of course, they are much more clever than our simple “copy folder” strategy. For example, they don’t waste disk space (which a simple file system copy would do) and they are much more capable when it comes to collaborating with other developers in the same project.</p><p> git中的分支具有完全相同的效果和目的：它们为其代码提供了具有单独工作空间的开发人员。当然，它们比我们简单的“复制文件夹”策略更聪明。例如，它们不会浪费磁盘空间（简单的文件系统副本将是这样），并且在与同一项目中的其他开发人员合作时，它们更有能力。 </p><p>   Branching’s value becomes clear if you think about your workflow without them: imagine that a team of 10 or 20 developers all work in the same “folder,” so to speak. All of them simultaneously editing the same source code files. Suddenly, their code is now your code.  Some may be implementing brand new features, which could introduce bugs in the beginning. Every experiment that a developer has to perform in order to make progress and every bug that is unavoidable in that process will affect all of their teammates. A handful of people working together in such a way is enough to bring the whole development process to a halt.</p><p>如果你考虑没有它们的工作流程，分支的价值变得清楚：想象一下10或20个开发人员的团队都在同一个“文件夹”中，所以说话。所有这些都同时编辑相同的源代码文件。突然，他们的代码现在是你的代码。有些人可能正在实现全新的功能，这可能会在开始时引入错误。开发人员必须执行的每个实验，以便进行进度和每个过程中不可避免的错误都会影响其所有队友。少数人以这种方式工作的人足以让整个发展过程停止。</p><p> When only one context exists that all teammates and all features have to share, commit history looks something like this:</p><p> 只有一个上下文都存在所有队友和所有功能必须分享，提交历史看起来如此如此：</p><p>  As the (quite confusing) dotted red lines show, working without branches quickly results in chaos: it becomes hard to understand which commits belong to which feature! In the distant past, where a powerful branching model had not been available, version control was—quite frankly—less useful because a major structural element was not available.</p><p>  作为（相当令人困惑）点缀红线显示，没有分支机构的工作会很快导致混乱：很难理解哪个提交属于哪种功能！在遥远的过去，如果尚未获得强大的分支模型，版本控制是 - 非常有用，因为没有主要的结构元素。</p><p> Let’s imagine the same scenario  with branches in mind. Every experiment, every new feature, every bug fix gets its own branch, its own context that is completely separate from all the other development contexts. “Separate” in this regard also means “safe”: if a bug occurs in one context, none of the other contexts are affected by that. Branches, in other words, are convenient containers that make developing in multiple, simultaneous contexts safe (and possible in the first place).</p><p> 让我们想象与思想的分支相同的情景。每个实验，每个新功能，每个Bug修复都获取自己的分支，它自己的上下文与所有其他开发上下文完全分开。在这方面“单独”也意味着“安全”：如果在一个上下文中发生错误，则其他上下文都没有受到影响。换句话说，分支是一种方便的容器，使得在多个同步的上下文中能够安全（并且可以首先是可能的）。</p><p> Features and bug fixes are clearly separated from each other, and so are their commits and their code:</p><p> 功能和错误修复程序显然彼此分开，他们的提交及其代码也是如此：</p><p>  In the above example, the changes in “FAQ Content” and “New Design #1” don’t get in each other’s way.</p><p>  在上面的示例中，“常见问题内容”和“新设计”和“新设计”的变化不会彼此相处。</p><p> To make a long story short: the main benefit of using branches is that  they make software development safe. They prevent bugs and problems from leaking from one context into another and help you undo mistakes more easily.</p><p> 要短篇小说：使用分支机构的主要好处是他们使软件开发安全。他们防止错误和问题从一个上下文泄漏到另一个上下文中，并帮助您更容易地撤消错误。 </p><p>  As said, branches are not exclusive to Git. Many other version control systems offer branches as part of their toolsets. But there are a couple of advantages that set Git’s branching model apart:</p><p>如上所述，分支不是git排他性。许多其他版本控制系统提供分支作为工具集的一部分。但是有几个优点将Git的分支模型分开：</p><p> Simplicity: Using branches in Git is really easy. Beginners sometimes hesitate before creating a new branch and ask themselves if a particular situation justifies creating a new branch. Such hesitation is unnecessary: creating new branches in Git is so simple, and it doesn’t come with any drawbacks. Just take disk space as an example: creating a new branch in Git does  not copy around files, possibly creating a large amount of duplicate files; instead, Git’s file management makes sure that nothing has to be copied!</p><p> 简单性：在git中使用分支真的很容易。初学者有时会在创建一个新分支之前犹豫，如果特定情况证明创建一个新分支，请询问自己。这种犹豫是不必要的：在git中创建新的分支是如此简单，它没有任何缺点。只需占用磁盘空间“示例：在GIT中创建新分支不会复制文件，可能会创建大量重复文件;相反，Git的文件管理确保没有任何东西可以复制！</p><p> Speed: In Git, all operations around working with branches are very quick. While some version control systems, for example, create copies of files when a new branch is created, Git’s internal management does not need this. As a result, there’s no waiting time involved when creating new branches or working with existing ones.</p><p> 速度：在Git中，与分支机构一起使用的所有操作都非常快。虽然某些版本控制系统，例如，在创建新分支时创建文件的副本，但Git的内部管理不需要此。因此，在创建新分支或使用现有的分支时，没有等待时间。</p><p> Merging: Creating safe separate contexts using branches is one thing. But integrating (or “merging”) branches back into other contexts is the other part of the game. In many other version control systems, merging can be a complicated business: you might be asked to provide the exact revisions or select specific changesets. Git, on the other hand, makes it very simple and user-friendly. In most cases, it just works without any user intervention.</p><p> 合并：使用分支创建安全的单独上下文是一件事。但是将（或“合并”）分支返回到其他上下文是游戏的另一部分。在许多其他版本控制系统中，合并可以是一个复杂的业务：可能会要求您提供确切的修改或选择特定的变更集。另一方面，Git使它非常简单和用户友好。在大多数情况下，它只是没有任何用户干预的作品。</p><p> Git was built with the concept of branches in mind. It was neither an afterthought nor a “nice to have” feature, but instead one of the core requirements from the start.</p><p> Git以思想的概念为基础。它既不是事后的外临良好，也不是“很好”的功能，而是从一开始就是核心要求之一。</p><p>  The general idea remains the same: branches provide a safe, separate context for the many different kinds of work that happen in any project at any time. In practice, this takes a number of different forms.</p><p>  一般思想保持不变：分支机构为任何时候为任何项目发生的许多不同的工作提供了安全，独立的背景。在实践中，这需要一些不同的形式。</p><p>  Whenever you start “something new” in your project, it makes sense to create a new, separate branch for that. It doesn’t matter if it’s just a little experiment or a full-blown new feature: you want to protect the mainline of code and your coworkers from all the small and big bugs that inevitably happen when new code is being produced.</p><p>  每当您在项目中启动“新建”时，为此创建一个新的单独分支是有意义的。如果它只是一个实验或全面的新功能 </p><p> Having a separate context has the additional benefit that it’s easy to get rid of—if your experiment doesn’t yield anything or your new feature doesn’t work out. Again, just think about a situation like that without branches: your new experimental commits would have been mingled with other features or even the mainline of code, making them difficult to get rid of later.</p><p>具有单独的上下文具有额外的好处，即易于摆脱 - 如果您的实验不会产生任何东西，或者您的新功能无法解决。同样，只要考虑这样的情况，就没有分支机构：你的新实验犯罪将与其他功能甚至是代码的主线混合，使他们难以摆脱以后。</p><p>  Even for bug fixes (if they require more than a single line of code), a new separate branch very often makes sense. One advantage, again, is that the relatively untested new code that you are producing won’t interfere with the work of others. But the more important advantage, in this case, is about organization: by having the bug fix in its own branch, it’s easier to integrate it both  when and  where you want. Maybe you want to integrate the fix only at a certain point in time or into certain other contexts—all of which is easily possible with branches.</p><p>  即使对于错误修复（如果它们需要多行代码），则新的单独分支通常会有意义。一个优点，再次，您正在生产的相对未经测试的新代码不会干扰他人的工作。但在这种情况下，更重要的优势是关于组织：通过在自己的分支中拥有错误，更容易集成它何时何地在哪里。也许您只想在某个时间点或某些其他上下文中集成修复程序 - 所有这些上下文都可以使用分支机构轻松实现。</p><p>  Both of the previous examples—experiments/new features and bug fixes—belong to what are known as short-lived branches. As the name implies, these branches aren’t meant to live forever. Instead, they were created for certain well-defined purposes (e.g. implementing a new feature idea) and can then be deleted once they have been integrated into a long-running branch.</p><p>  前面的例子 - 实验/新功能和错误修复 - 属于所谓的短期分支。顾名思义，这些分支并不意味着永远活着。相反，它们是为某些明确的目的而创建的（例如实现一个新的功能思想），然后一旦被集成到长期运行的分支中，就可以删除。</p><p>   Unlike their short-lived colleagues, long-running branches typically remain in a project during its complete lifetime. These branches are not tied to specific features or topics. Instead, they represent states or stages in a project:</p><p>   与他们的短暂的同事不同，在完整的一生中，长期的分支通常留在项目中。这些分支没有与特定功能或主题相关联。相反，它们代表项目中的状态或阶段：</p><p> the typical “main” branch for the project’s mainline or production code</p><p> 项目的主线或生产代码的典型“主要”分支机构</p><p>  sometimes also branches like “staging” or “production” that represent certain stages or environments</p><p>  有时也是代表某些阶段或环境的“阶段”或“生产”等分支机构</p><p> Along with this distinction between short-lived and long-running branches, there’s also often a golden rule:  never directly commit on a long-running branch; code should only land on these branches through deliberate integration (via merge or rebase).</p><p> 随着短期和长期跑步的这种区分，也经常是一个黄金法则：永远不会直接提交长期的分支;代码只能通过刻意集成（通过合并或rebase）来降落这些分支机构。 </p><p>   When trying to imagine how branches work, it’s tempting to use the concept of “folders.” After all, creating a new branch feels very much like copying the project’s current state and pasting it into a new, separate folder.</p><p>当试图想象分支机构如何工作时，使用“文件夹”的概念很诱人。毕竟，创建一个新分支的感觉非常像复制项目的当前状态并将其粘贴到一个新的单独文件夹中。</p><p> But part of the genius behind Git is that it doesn’t just “copy all contents” of your project, which would make things slow and use up lots of disk space. It’s much smarter than that!</p><p> 但是Git背后的一部分天才是它不仅仅是“复制所有内容”，这将使事情缓慢并使用大量的磁盘空间。它比这更聪明！</p><p>  If branches aren’t copies of the file system, what are they? To answer this, it’s important to know that commits in Git are incredibly safe and efficient at storing data:</p><p>  如果分支不是文件系统的副本，它们是什么？要回答这个问题，重要的是要知道Git的提交在存储数据时非常安全，有效：</p><p> Safety: A commit’s contents and metadata are run through an SHA-1 hash algorithm, which makes it very hard to manipulate data after the fact.</p><p> 安全性：提交的内容和元数据通过SHA-1哈希算法进行，这使得在事实之后很难操纵数据。</p><p> Efficiency: Commits don’t store data again if it has  already been stored previously. This means that files that have NOT been changed between commits aren’t taking up unnecessary disk space.</p><p> 效率：如果已先存储，则提交不再存储数据。这意味着在提交之间未更改的文件不占用不必要的磁盘空间。</p><p> Keeping this in mind, would there be any need to “invent” something on top of this? No, of course not! That’s why branches in Git are an extremely lightweight concept – far from heavy “copies of the filesystem”.</p><p> 请记住这一点，会有任何需要“发明”的东西？不，当然不！这就是为什么Git的分支是一个极其轻量级的概念 - 远非沉重的“文件系统副本”。</p><p>   This pointer is automatically moved every time you add a new commit on top. Very practical!</p><p>   每次添加新提交时，此指针都会自动移动。非常实用！ </p><p>  Let’s look at this fact again, from another angle: commits in Git are identified by their SHA-1 hash, those 40-character long, cryptic strings. These commit hashes are static and immutable. Branches, on the other hand, are highly flexible, always changing to the commit hash of the latest commit anytime you create a new commit in that branch.</p><p>让我们再次来看待这个事实，从另一个角度：Git中的提交由他们的SHA-1哈希识别，那些40个字符的长，密码串。这些犯罪散列是静态和不可变的。另一方面，分支是非常灵活的，始终更改为最新提交的提交散列随时您在该分支中创建新的提交。</p><p>  But what do those mystical pointers look like, and where do they live? To answer this one, we’ll have to take a quick journey into the inner workings of Git: the hidden “.git” directory, located in the root of your project. In here, you’ll find a subdirectory named “refs” and another subfolder named “heads”: it’s here that each branch is represented by a file named after that branch.</p><p>  但那些神秘的指针看起来像什么，他们住在哪里？要回答这一点，我们必须快速进入Git的内部工作：隐藏的“.git”目录，位于您项目的根目录中。在这里，您会发现名为“refs”的子目录和另一个名为“heads”的子文件夹：它在此处，每个分支由在该分支之后名为的文件表示。</p><p>  When you create a new branch, e.g. with a command like “git branch my-new-branch”, you’ll find a new physical file in here, named “my-new-branch”.</p><p>  当您创建一个新分支时，例如使用“git分支My-new-branch”这样的命令，您将在此处找到一个新的物理文件，名为“my-new-branch”。</p><p> And if you were to look at the  contents of such a file in a text editor, you’d find that it only contains a single piece of information: the SHA-1 hash of the commit it currently points to!</p><p> 如果您要在文本编辑器中查看此类文件的内容，您发现它只包含单一信息：它目前指向的提交的SHA-1哈希哈希！</p><p>  The image above shows the contents of such a “pointer file”: the branch named “main” currently points to the commit with the SHA-1 hash “bf88ef73c”.</p><p>  上面的图像显示了这种“指针文件”的内容：命名为“main”的分支当前指向SHA-1 HASH“BF88EF73C”的提交。</p><p>  But how does Git know which of your local branches is currently active? What is the branch that new commits are added to and that moves its pointer along when this happens?</p><p>  但是，Git如何知道您的本地分支机构的哪些目前处于活动状态？什么是添加新的提交的分支，并在发生这种情况时移动指针？</p><p> Git keeps another, special pointer named “HEAD”. The sole purpose of HEAD is to point to the currently active (or “checked out”) branch:</p><p> git保留另一个名为“head”的特殊指针。头部的唯一目的是指出目前活跃的（或“检查出”）分支机构： </p><p>  In the local .git repository folder, you’ll find this information saved in a file appropriately named “HEAD”. And the content of that file typically looks something like this:</p><p>在本地.git存储库文件夹中，您将发现在适当命名为“head”的文件中保存的此信息。该文件的内容通常如下所示：</p><p>   Finally, let’s take a look at what happens when you  switch the currently active branch—e.g. with a command like  git checkout other-branch or  git switch other-branch.</p><p>   最后，让我们来看看切换当前活动的分支时会发生什么。使用Git Checkout其他分支或Git Switch其他分支的命令。</p><p>  b) The files in your working copy are swapped and now represent the state from the latest commit in that branch.</p><p>  b）工作副本中的文件已交换，现在代表该分支机构中的最新提交的状态。</p><p>  I hope that this post gave you a better understanding of how branches—one of the core tools in Git—really work.</p><p>  我希望这篇文章能够更好地了解分支机构 -  Git-Birt的核心工具之一。</p><p> Like in many other areas, it’s only when you deeply understand something that you can really reap its benefits. This is especially true for Git, in my opinion: advanced tools like interactive rebase, submodules, or the reflog have the power to make you a better software developer—but you’ll have to take a bit of time to properly learn and understand them.</p><p> 就像在许多其他领域一样，它只是当你深深地了解你可以真正收获的好处。在我看来，这尤其如此：在我看来：互动rebase，子模块等高级工具，或者回流有能力让你成为一个更好的软件开发人员 - 但你必须需要一点时间来正确学习和理解它们。</p><p> If you want to up your Git game, I put together the “ First Aid Kit for Git“—a free collection of short videos that explain lots of helpful tools like the reflog, interactive rebase and others that can help you avoid or repair mistakes.</p><p> 如果您想上升您的GIT游戏，我将“Git的急救箱”放在一起 - 是免费收集的短视频，解释了许多有用的工具，如Rhallog，Interactive Rebase和其他可以帮助您避免或修复错误的其他人。</p><p>  Tags:  branches,  git,  source control</p><p>  标签：分支机构，git，源控制 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stackoverflow.blog/2021/04/05/a-look-under-the-hood-how-branches-work-in-git">https://stackoverflow.blog/2021/04/05/a-look-under-the-hood-how-branches-work-in-git</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/work/">#work</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分支/">#分支</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>