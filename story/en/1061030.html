<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ARM与RISC-V矢量扩展 ARM vs. RISC-V Vector Extensions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ARM vs. RISC-V Vector Extensions<br/>ARM与RISC-V矢量扩展 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-06 23:40:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/0988df8556f24d1bffdfba3bf3d70189.jpeg"><img src="http://img2.diglog.com/img/2021/5/0988df8556f24d1bffdfba3bf3d70189.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Microprocessor with vector instructions is going to be the big thing for the future. Why? Because self-driving, speech recognition, image recognition are all based on machine learning and machine learning is all about matrices and vectors.</p><p>带有矢量指令的微处理器将成为未来的大事。为什么？因为自动驾驶，语音识别，图像识别都基于机器学习和机器学习都是关于矩阵和向量。</p><p> But that is not the only reason. We have been banging our heads  in the wall trying to eek out more performance for years ever since we semi-officially declared Moore’s laws to be over. In the golden old days of microprocessor design, we could simply double the clock frequency of the CPU each year and boom everybody was happy. That wonderful old trick is over.</p><p> 但这不是唯一的原因。自从我们半正式宣布的摩尔法律结束以来，我们一直在墙上敲打着墙上的脑袋，试图为多年来一直进行更多的表现。在微处理器设计的黄金时期，我们每年可以简单地加倍CPU的时钟频率，每个人都开心。那个美妙的老伎俩结束了。</p><p>  Today we play a thousand different clever games to eek out more performance whether that is through adding more CPU cores, adding out-of-order execution, more advance branch predictors or SIMD instructions.</p><p>  今天我们玩了一千个不同的聪明游戏，以便在加上更多的性能，无论是通过添加更多的CPU内核，增加订单超出次数，更多的预先分支预测器或SIMD指令。</p><p> All of these tricks really boil down to one central idea: Trying to find ways of doing work in parallel. Whenever you loop over an array of elements and do some computation on each of these elements, you have an opportunity for data-parallelism. This loop could with clever compilers be turned into a bunch of SIMD or vector instructions.</p><p> 所有这些技巧都归结为一个中心的想法：试图找到并行工作的方法。无论何时何时何时循环多个元素并对每个元素进行一些计算，您都有机会进行数据并行性。此循环可以与巧妙的编译器变成一堆SIMD或矢量说明。</p><p>  SIMD instructions such as Neon, MMX, SSE2 and AVX have worked great in multimedia applications. Doing things like video-encoding e.g. But we need to to squeeze out more performance in more areas. Vector instructions offer a lot more flexibility in taking almost any loop and turning it into vector instructions. However there are lots of different ways of going about this.</p><p>  SIMD指令，如霓虹灯，MMX，SSE2和AVX在多媒体应用中工作得很好。做像视频编码的东西e.g.但我们需要在更多领域挤出更多的性能。矢量说明在采取几乎任何循环并将其转换为向量指令提供了更多的灵活性。然而，有很多不同的方式。</p><p>   While writing this last article I struggled. Nothing seemed to work the way I had been taught. I thought I sort of knew vector instructions from having researched them for my first article. Thus after finishing the last story, I began comparing notes.</p><p>   在写这篇文章时，我挣扎着。似乎没有任何教导的方式工作。我以为我有点知道矢量指令为我的第一篇文章进行了研究。因此，在完成最后一个故事后，我开始比较了笔记。</p><p> This made me realize that ARM and RISC-V actually follow a profoundly different strategy. This is worth covering, in particular because it touches upon some of my cherished topics. I love simple and elegant and efficient technology:  The Value of Simplicity.</p><p> 这让我意识到ARM和RISC-V实际上遵循了一种深刻的不同策略。这值得覆盖，特别是因为它涉及我珍惜的一些主题。我喜欢简单而优雅，高效的技术：简单的价值。 </p><p> The RISC-V vector extensions when contrasted with ARM SVE is a study in elegant simplicity.</p><p>risc-v矢量延伸与ARM安全性对比时是一种优雅简洁的研究。</p><p>  While researching SVE, it was not obvious to me why I struggled to grasp it, but when picking up my RISC-V book and re-reading the vector-extensions chapter it became clear.</p><p>  在研究方案时，对我来说，为什么我努力掌握它并不明显，但是在拿起我的RISC-V书并重新读取矢量扩展章节，它变得清晰。</p><p> To be fair, ARM is a huge advancement over the complex mess that is Intel x86 assembly code. Let us not loose sight of that. Yet we cannot get past the fact that ARM is not that young either and has built up quite some legacy. When dealing with ARM, you basically have three different instruction-sets to relate to: ARM Thumb2, ARM32 and ARM64. When you google tutorials and try to read up, this presents a number of roadblocks. People are not always upfront about what instruction-set they are covering.</p><p> 要公平，ARM是对英特尔X86汇编代码的复杂混乱的巨大进步。让我们看不到那个。然而，我们无法通过它的事实，即手臂不是那么年轻，并建立了很多遗产。在处理ARM时，您基本上有三种不同的指令集，以涉及：ARM Thumb2，ARM32和ARM64。当您谷歌教程并尝试阅读时，这呈现了许多障碍。人们并不总是提前到他们正在覆盖的指令。</p><p> The Neon SIMD instructions basically come in two flavors: 32-bit and 64-bit. No, the bit length is not the issue here but rather that for 64-bit architecture ARM actually redesigned their whole instruction-set and changed quite a number of things. Even things like naming conventions for CPU registers.</p><p> 霓虹灯SIMD指令基本上有两个味道：32位和64位。不，位长度不是这里的问题，而是对于64位架构手臂实际上重新设计了他们的整个指令集并改变了相当多的东西。甚至是CPU寄存器的命名约定的东西。</p><p> The second problem is that ARM is simply large. There are over 1000 ARM instructions. Contrast this with the base RISC-V instruction-set of a measly 48 instructions. This means reading ARM assembly code is not that easy. Look at the SVE instruction below:</p><p> 第二个问题是，手臂很大。有超过1000个手臂指示。将其与MOSE 48指令的基础RISC-V指令集进行了对比。这意味着阅读ARM汇编代码并不容易。查看下面的SVE指令：</p><p>  There is a  lot going on there. With some experience with assembly, you can guess that the  LD prefix means  LoaD. But what does  1D mean? You got to look that up. Next you got odd suffixes on the register names such as  .D and  /Z. What do those mean? More to read up on. Then you got the brackets  []. You can probably guess that is to compose an address, but it has odd stuff like  LSL #3 inside which means  Logic Shift Left three times. But what is shifted? The whole thing? Just content of register  x3? More stuff to look up.</p><p>  那里有很多。通过组装的一些经验，您可以猜测LD前缀意味着加载。但是1D是什么意思？你必须看起来。接下来，您在寄存器名称上获得奇怪的后缀，例如.d和/ z。那些人的意思是什么？更多要阅读。然后你有括号[]。您可能猜测这是要撰写地址，但它具有像LSL＃3中的奇怪的东西，这意味着留下三次逻辑移位。但是转移了什么？整个东西？只是寄存器x3的内容？更多的东西要查找。</p><p> ARM SVE instructions simply have a lot of concepts which are not very obvious which takes time to wrap your head around. We are going to have a deeper comparison, but let me say a few words about RISC-V first.</p><p> ARM SWE说明简单有很多概念，这不太明显需要时间来包裹头部。我们将有更深入的比较，但让我说risc-v的几句话。 </p><p>  An overview of all the RISC-V Vector extensions instructions (RVV) fit on one book page. There are not many of them, and unlike ARM SVE, the have a pretty simple syntax. Here is a vector load instruction for RISC-V:</p><p>所有RISC-V矢量扩展指令（RVV）的概述适合一本书页面。他们中没有多少，而且与ARM SVE不同，有一个非常简单的语法。以下是RISC-V的矢量负载指令：</p><p>  This loads the vector register  v0 with the data found at the memory addressed stored in the regular integer register  x10. But how much is loaded? With a SIMD instruction-set such as ARM Neon this is decided by the name of the vector register.</p><p>  这将向矢量寄存器V0加载，其中数据存储在常规整数寄存器X10中的存储器上找到的数据。但加载了多少钱？使用SIMD指令集，如ARM NEON，这由矢量寄存器的名称决定。</p><p>  There are other ways of doing this. I think this is also a way of achieving similar result:</p><p>  还有其他方式做到这一点。我认为这也是实现类似结果的一种方式：</p><p>  This will load the lower 64-bit part of the 128-bit  v0 register. For SVE2 this we got another variant:</p><p>  这将加载128位V0寄存器的较低的64位部分。对于SVE2，我们得到另一个变体：</p><p> LD1D z0.b, p0/z, [x10] # Load ? number of byte elements LD1D z0.d, p0/z, [x10] # Load double word (64-bit) elements</p><p> ld1d z0.b，p0 / z，[x10]＃负载？字节元素数LD1D z0.d，p0 / z，[x10]＃加载双字（64位）元素</p><p> In this case the predicate register  p0 determined exactly how many elements we are loading. If  p0 = 1110000 e.g. then we are loading three elements.  v0 is the 128-bit lower part of  z0.</p><p> 在这种情况下，谓词寄存器P0确切地确定了我们加载多少元素。如果p0 = 1110000例如然后我们正在加载三个元素。 V0是Z0的128位下部。</p><p>  The reason for that is that the  d and  v and  z registers are in the same spot. Let me clarify. You got a block of memory called a  register file inside every CPU. Or to be more specific, you can have multiple register files in a CPU. The  register file is the memory holding the registers. So you don&#39;t access memory cells in the  register file like regular main memory. Instead you refer to sections of it using register names.</p><p>  其原因是D和V和Z寄存器位于同一位置。让我澄清。您在每个CPU中有一个名为寄存器文件的内存块。或者更具体地，您可以在CPU中拥有多个寄存器文件。寄存器文件是包含寄存器的内存。所以你不要像常规主内存一样＆＃39; t访问寄存器文件中的存储器单元。相反，您将使用寄存器名称引用它的部分。 </p><p>  Different registers can map to areas of the same  register file. Thus when using scalar floating point operations, you are actually using parts of the vector registers. So let us consider the 4th vector register, to see how all of this related:</p><p>不同的寄存器可以映射到相同寄存器文件的区域。因此，在使用标量浮点操作时，您实际上使用了矢量寄存器的部分。所以让我们考虑第四个向量寄存器，看看所有这些相关的内容如何相关：</p><p>  RISC-V however does  not work like this. The RISC-V vector registers are in a separate  register file not shared with the scalar floating point registers.</p><p>  RISC-V但不像这样工作。 RISC-V向量寄存器位于未与标量浮点寄存器共享的单独寄存器文件中。</p><p>   I can only scratch the surface of the ARM vector instructions because there is a ton of them. Just locating what is a typical load instruction for Neon and SVE2 was actually quite time consuming. I looked through a lot of ARM documentation and blog entries. Doing the same for RISC-V was trivial. Almost all RISC-V instructions fit on a double sided sheet of paper. There are only three vector load instructions:  VLD,  VLDS and  VLDX.</p><p>   我只能划伤手臂矢量指令的表面，因为它们有很多。只是定位霓虹灯和SVE2的典型负载指令实际上非常耗时。我看了很多ARM文件和博客条目。对RISC-V来做同样的事情是微不足道的。几乎所有RISC-V指令都适合双面纸张。只有三个矢量负载指令：VLD，VLD和VLDX。</p><p> I simply gave up figuring out how many ARM has. There seems to be a tonne of them and I have no plans on becoming a professional ARM assembly code developer.</p><p> 我只是放弃了弄清楚多少臂。他们似乎有一个吨，我没有成为专业的ARM汇编代码开发人员的计划。</p><p>  This is quite an interesting part, because ARM and RISC-V use very different approach and I think the simplicity and flexibility of the RISC-V solution really shines.</p><p>  这是一个非常有趣的部分，因为ARM和RISC-V使用非常不同的方法，我认为RISC-V解决方案的简单性和灵活性真的闪耀。</p><p>   VSETDCFG - Vector SET Data ConFiGuration. This sets the bit size for each element. The type, whether floating point, signed or unsigned integer. It also specifies how many vector registers to enable.</p><p>   vsetdcfg  - 向量设置数据配置。这为每个元素设置了位大小。类型，是否浮点，签名或无符号整数。它还指定启用有多少矢量寄存器。</p><p> SETVL - SET Vector Length. Say how many elements you want. There is a max number of elements  MVL (max vector length), which you can not exceed.</p><p> setvl  - 设置矢量长度。说你想要多少元素。有一个MVL（最大向量长度）的最大数量，您无法超过。 </p><p>  This is where it gets interesting. Unlike ARM SVE, I can partition the  vector register file in pretty much whatever way I want. Say the  register file has 512 bytes of memory. I can then say I want just two vector register. That gives me 256 bytes for each. Next I can say that I want to use 32-bit elements. Each element is in other words 4-bytes. That gives me:</p><p>这是它变得有趣的地方。与ARM SVE不同，我可以以几乎无论我想要的方式分区矢量寄存器文件。说寄存器文件有512个字节的内存。然后我可以说我只想要两个矢量寄存器。这为我提供了256个字节。接下来我可以说我想使用32位元素。每个元素换句话说为4字节。这给了我：</p><p> Two registers: 512 bytes / 2 = 256 bytes per register 256 bytes / 4 bytes per element = 128 elements</p><p> 两个寄存器：每寄存器512字节/ 2 = 256字节256字节/ 4个字节每个元素= 128个元素</p><p> That means I could add or multiple a whooping 128 elements with just a single instruction. With ARM SVE you cannot do this. The number of registers is fixed, and the memory allocated for each register if fixed. Both RISC-V and ARM allow you to use a maximum of 32 vector registers, but RISC-V allow you to disable registers and give the memory those registers would have used to the remaining ones, thus growing them in size.</p><p> 这意味着我可以只使用单个指令添加或多个128个元素。带着胳膊窗扇，你不能这样做。寄存器的数量是固定的，并且如果固定，则为每个寄存器分配的内存。 RISC-V和ARM都允许您使用最多32个向量寄存器，但RISC-V允许您禁用寄存器并给出那些寄存器将习惯剩余的寄存器，从而将它们置于大小。</p><p>  Let us look a bit at how this works in practice. The CPU knows of course how large its  register file is. The programmer doesn’t know this and is not supposed to either.</p><p>  让我们看起来有点在实践中有效。 CPU知道其寄存器文件的课程是多大的。程序员不知道这一点，也不应该是它。</p><p> When the programmer uses  VSETDCFG to set element type and number of enabled registers, the CPU will use this info to calculate Max Vector Length (MVL).</p><p> 当程序员使用vsetdcfg来设置元素类型和启用寄存器的数量时，CPU将使用此信息计算最大矢量长度（MVL）。</p><p> LI x5, 2&lt;&lt;25 # Load register x5 with 2&lt;&lt;25 VSETDCFG x5 # Set data configuration to x5</p><p> Li x5,2＆lt;＆lt; 25＃加载寄存器x5，其中2＆lt;＆lt; 25 vsetdcfg x5＃设置数据配置到x5</p><p>   Let us compare this to ARM Neon, where each register is 128-bit. That means with Neon you could have computed two of these values in parallel. But with RISC-V the memory of 16 of those registers would be merged into one register. Thus you can instead compute 32 values in parallel.</p><p>   让我们将此与ARM NEON进行比较，每个寄存器为128位。这意味着与霓虹灯，您可以并行计算两个这些值。但是对于RISC-V来说，这些寄存器中的16个记忆将合并为一个寄存器。因此，您可以通过并行计算32个值。 </p><p> Actually that is not entirely true. Behind the scenes there will be some max number of floating point multipliers, arithmetic logic units etc which limited how many lanes of calculations you can perform in parallel. However that will be an implementation detail.</p><p>实际上这并不完全正确。在场景后面将有一些最大数量的浮点乘法器，算术逻辑单元等有限有多少路线，您可以并行执行。但这将是一个实施细节。</p><p> Anyway, this would result in an  MVL value of 32. However as a developer you don&#39;t directly deal with this value. The  SETVL instruction works like this:</p><p> 无论如何，这将导致MVL值为32.然而，作为开发人员，您可以直接处理此值。 setvl指令如下所示：</p><p>  Thus if you try to set  Vector Length (VL) to 5, then that works. However if you try to set it to 60, you will get 32 instead. So this is important to get about  Max Vector Length (MVL), it is not hardwired to one number when the CPU is made. Rather it is calculated by the CPU based on your  data configuration (element type and enabled registers).</p><p>  因此，如果您尝试将向量长度（VL）设置为5，则将其工作。但是，如果您尝试将其设置为60，则会获得32。因此，达到最大矢量长度（MVL）很重要，当CPU进行CPU时，它不硬连线。相反，它由CPU基于数据配置（元素类型和启用寄存器）计算。</p><p>  With ARM you don’t specifically set vector length. Instead you sort of indirectly set the vector length by using predicate registers. These are bit-masks, which you use to enable and disable elements in a vector register. Predicate registers also exist on RISC-V but don’t have the same central role as on ARM.</p><p>  用胳膊你没有特别设置矢量长度。相反，通过使用谓词寄存器，您可以间接设置向量长度。这些是位掩码，您可以在向量寄存器中启用和禁用元素。 RISC-V上也存在谓词寄存器，但没有与ARM上相同的中心作用。</p><p> To do the equivalent of  SETVL on ARM you instead use an instruction called  WHILELT which is short for  While Less Than:</p><p> 要在ARM上执行相当于SETVL，而是使用一个名为WHILETT的指令，而不是小于：</p><p>  This instruction is a bit hard to explain purely in writing, so I will use some Julia pseudo code to demonstrate it.</p><p>  这个指令有点难以纯粹以书面解释，所以我将使用一些朱莉娅伪代码来展示它。</p><p> i = 0  while i &lt; M   if x1 &lt; x4  p3[i] = 1   else  p3[i] = 0   end  i += 1  x1 += 1  end</p><p> i = 0，而我＆lt; m如果x1＆lt; x4 p3 [i] = 1其他p3 [i] = 0结束i + = 1 x1 + = 1结束 </p><p> Conceptually we are flipping bits in the predicate register  p3 depending on whether register  x1 is less than  x4. Thus in this case  x4 basically contains the vector length. If  p3 looks like this, then the vector length could be though of as 3.</p><p>概念上，我们在谓词寄存器P3中翻转位，具体取决于寄存器X1是否小于X4。因此，在这种情况下，X4基本上包含矢量长度。如果p3看起来像这样，则传染媒介长度可以是3。</p><p>  Thus the way we deal with variable vector length is through the fact that all the operations use a predicate. Consider this add operation. You can think of  v0[p0] as picking only the elements from  v0 where  p0 is true.</p><p>  因此，我们处理变量向量长度的方式是通过所有操作使用谓词的事实。考虑此添加操作。您可以认为v0 [p0]只能挑选v0的元素，其中p0为true。</p><p>  Okay now what we have given a bit intro. Let us look at a bit more complete code example for how these instruction-sets work in practice.</p><p>  好的，现在我们有点介绍了什么。让我们看看这些指令集在实践中的工作方式更完整的代码示例。</p><p>  We are going to to look at how this C-function would end up with different vector instructions:</p><p>  我们将查看该C函数如何最终以不同的向量指令：</p><p> void daxpy(size_t n, double a, double x[], double y[]) {   for (int64_t i = 0; i &lt; n; ++i) {  y[i] = x[i] * a + y[i];  } }</p><p> void daxpy（size_t n，double a，double x []，double y []）{for（int64_t i = 0; i＆lt; n; ++ i）{y [i] = x [i] * a + y [一世]; }}</p><p> Why the oddball  daxpy name? This is a simple function in the BLAS linear algebra library, popular in scientific work. For some BLAS has named this function  daxpy and this happens to be very popular to demonstrate the implementation of in all sorts of SIMD and vector instruction examples. It is an implementation of this math equation:</p><p> 为什么古怪的达蓬名字？这是Blas线性代数库中的一个简单功能，在科学工作中流行。对于一些Blas命名为此函数Daxpy，这恰好非常受欢迎，以演示在各种SIMD和Vector指令示例中的实现。这是此数学方程式的实现：</p><p>  Where  a is a scalar and  X and  Y are vectors. Without vector instructions we would have to loop for every element processed. But with a smart compiler, this can be  vectorized to code looking like this on RISC-V. Here is a comment that explains what register corresponds to what variable:</p><p>  其中a是标量并且x和y是向量。没有矢量指令，我们必须为处理的每个元素循环。但是通过智能编译器，这可以矢量化到RISC-v上的代码。这是一个注释，它解释了什么寄存器对应于什么变量： </p><p> daxpy(size_t n, double a, double x[], double y[])  n - a0 int register (alias for x10)  a - fa0 float register (alias for f10)   x - a1 (alias for x11)   y - a2 (alias for x12</p><p>daxpy（size_t n，double a，double x []，双y []）n  -  a0 int寄存器（x10的别名）a  -  fa0浮动寄存器（f10的别名）x  -  a1（x11的别名）y  -  a2（ X12的别名</p><p>  LI t0, 2&lt;&lt;25  VSETDCFG t0 # enable two 64-bit float regs loop:  SETVL t0, a0 # t0 ← min(mvl, a0), vl ← t0  VLD v0, a1 # load vector x  SLLI t1, t0, 3 # t1 ← vl * 2³ (in bytes)  VLD v1, a2 # load vector y  ADD a1, a1, t1 # increment pointer to x by vl*8  VFMADD v1, v0, fa0, v1 # v1 += v0 * fa0 (y = a * x + y)  SUB a0, a0, t0 # n -= vl (t0)  VST v1, a2 # store Y  ADD a2, a2, t1 # increment pointer to y by vl*8  BNEZ a0, loop # repeat if n != 0  RET # return</p><p>  Li T0,2 <2＆lt;＆lt;＆lt; 25 VsetDCFG T0＃启用两个64位浮动regs循环：SETVL T0，A0＃T0←MIN（MVL，A0），VL←T0 VLD V0，A1＃LOAD VECTOR X SLLI T1，T0， 3＃T1←VL *2³（以字节为单位）VLD v1，A2＃加载向量Y添加A1，A1，T1＃增量指针到X by vl * 8 Vfmadd v1，v0，fa0，v1＃v1 + = v0 * fa0（ y = a * x + y）sub a0，a0，t0＃n  -  = vl（t0）vst v1，a2＃store y添加a2，a2，t1＃增量指针到y通过vl * 8 bnez a0，循环＃重复如果n！= 0 RET＃返回</p><p> This is example code I have copied. Notice we are not using  f, and  x names for floating point and integer registers. To help developers better remember conventions, a RISC-V assembler defines a number of aliases. E.g. for a function the arguments get passed in the registers  x10 to  x17. But not not have to remember arbitrary numbers like that, we got aliases  a0 to  a7 for function arguments.</p><p> 这是我复制的示例代码。请注意，我们不使用f，以及浮点和整数寄存器的x名称。为了帮助开发人员更好地记住约定，RISC-V汇编程序定义了许多别名。例如。对于函数，参数通过寄存器x10到x17传递。但不必记住这样的任意数字，我们将A0到A7的别名进行函数参数。</p><p> t0 to  t6 are aliases for registers which are temporary. Meaning they don&#39;t get saved between function calls.</p><p> T0至T6是寄存器的寄存器的别名。意思是他们不在函数调用之间保存。</p><p> For comparison we got the ARM SVE code below. Let me just give an overview of what register stores what variable.</p><p> 为了比较，我们得到了下面的ARM SVE代码。让我概述寄存器存储什么变量。</p><p> daxpy(size_t n, double a, double x[], double y[])  n - x0 register  a - d0 float register  x - x1 register   y - x2 register   i - x3 register for the loop counter</p><p> Daxpy（size_t n，double a，double x []，double y []）n  -  x0寄存器a  -  d0浮动寄存器x  -  x1寄存器y  -  x2寄存器i  -  x3寄存器循环计数器</p><p>  daxpy:  MOV z2.d, d0 // a  MOV x3, #0 // i  WHILELT p0.d, x3, x0 // i, n loop:  LD1D z1.d, p0/z, [x1, x3, LSL #3] // load x  LD1D z0.d, p0/z, [x2, x3, LSL #3] // load y  FMLA z0.d, p0/m, z1.d, z2.d  ST1D z0.d, p0, [x2, x3, LSL #3]  INCD x3 // i  WHILELT p0.d, x3, x0 // i, n  B.ANY loop  RET</p><p>  daxpy：mov z2.d，d0 // mov x3，＃0 //i whilelt p0.d，x3，x0 //i，n循环：ld1d z1.d，p0 / z，[x1，x3，lsl＃ 3] // load x ld1d z0.d，p0 / z，[x2，x3，lsl＃3] // load y fmla z0.d，p0 / m，z1.d，z2.d st1d z0.d，p0 ，[x2，x3，lsl＃3] Incd x3 //i i whilelt p0.d，x3，x0 //i，n b.any循环ret </p><p> The ARM code is slightly shorter, as may ARM instruction do a lot more than one thing. This is one thing I think makes RISC-V code a lot easier to read. Instructions tend to just do one thing. There is not a lot of special syntax to deal with. Just notice something simple like loading the vector registers how complex that is with ARM:</p><p>ARM代码略短，因为ARM指令可以多于一件事。这是我认为使RISC-V的一件事更易于阅读。指示往往只是做一件事。处理没有很多特殊的语法。只是注意到类似于加载矢量的简单寄存器，寄存器是如何复杂的手臂：</p><p>    So you can see  x1 represent the base address of the  x variable.  x3 is the  i counter. By doing a 3-left shift we get eight, which is the number of bytes in a 64-bit floating point number.</p><p>    所以你可以看到x1表示x变量的基地址。 x3是我柜台。通过执行3左移，我们得到八个，这是64位浮点数中的字节数。</p><p>  As a beginner to vector coding, I must say that ARM is just way too complicated. Not because ARM is bad. I have also looked at Intel AVX instructions and that looks 10x worse. I am most definitely not going to spend time understanding AVX, given the efforts required to grasp SVE and Neon.</p><p>  作为向量编码的初学者，我必须说手臂刚得太复杂。不是因为手臂很糟糕。我也看了Intel AVX的说明，看起来更糟。鉴于掌握SVE和霓虹灯所需的努力，我绝对不会花时间理解AVX。</p><p> To me it is pretty clear that for anyone who want to learn assembly coding, you should really start with RISC-V. For beginners it is just magnitudes easier to follow. And that isn’t surprising. It was specifically designed to be taught at universities.</p><p> 对我来说，很明显，对于想要学习装配编码的人来说，你应该真正从RISC-v开始。对于初学者，它只是更容易遵循的大小。这并不令人惊讶。它专门设计用于在大学教授。</p><p> Architectures like Intel x86 is complex for legacy reasons. It has been around for decades and attempted to maintain backwards compatibility. ARM in contrast is a cleaner design but made complicated simply because industry is what primarily dictates design and not teachability or beginner friendliness.</p><p> 与英特尔X86这样的架构以遗留原因很复杂。它已经存在几十年，并试图保持向后兼容性。相比之下，手臂是一种更清洁的设计，但简单地制造了复杂的是，因为行业是主要决定设计，而不是教养或初学者友好。</p><p> If you are a hobbyist like me, who just wants to keep up to date with how technology is evolving and what things like vector processing is, then safe yourself a lot of trouble and just read a RISC-V book.</p><p> 如果你是像我这样的爱好者，那些只是想及时了解技术如何发展以及矢量处理的东西，然后安全自己有很多麻烦，只读了一个risc-v书。</p><p> People may argue that ARM or Intel or whatever is easier because there are more books, and more resources. No fricken way! I can tell you from my own experience over the last couple of days, that all that documentation is frequently more of an obstacle than help. It means you need to dig through way more material. You got a lot of contradictory stuff based on old ways of doing things.</p><p> 人们可能会争辩说，武器或英特尔或其他任何更容易，因为有更多的书籍，更多的资源。没有人的方式！我可以在过去几天中从自己的经验中告诉你，所有这些文件的经常都是障碍而不是帮助。这意味着您需要更多地挖掘更多材料。你得到了很多矛盾的东西，基于旧的做事方式。 </p><p> If you want to get into assembly coding, you can read some of my articles and tutorials:</p><p>如果要进入装配编码，您可以阅读我的一些文章和教程： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://erik-engheim.medium.com/arm-vs-risc-v-vector-extensions-992f201f402f">https://erik-engheim.medium.com/arm-vs-risc-v-vector-extensions-992f201f402f</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vector/">#vector</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>