<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>VGPU_UNLOCK：为消费者级GPU解锁VGPU功能 Vgpu_unlock: Unlock vGPU functionality for consumer grade GPUs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Vgpu_unlock: Unlock vGPU functionality for consumer grade GPUs<br/>VGPU_UNLOCK：为消费者级GPU解锁VGPU功能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-10 03:29:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/d8e5309a7ea0ea17c8b9568f5ebe84cb.png"><img src="http://img2.diglog.com/img/2021/4/d8e5309a7ea0ea17c8b9568f5ebe84cb.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This tool enables the use of Geforce and Quadro GPUs with the NVIDIA vGPUsoftware. NVIDIA vGPU normally only supports a few Tesla GPUs but since someGeforce and Quadro GPUs share the same physical chip as the Tesla this is onlya software limitation for those GPUs. This tool aims to remove this limitation.</p><p>该工具可以使用GeForce和Quadro GPU与NVIDIA VGPUSoftWare。 NVIDIA VGPU通常只支持几个Tesla GPU，但由于某人的Force和Quadro GPU共享与Tesla相同的物理芯片，这是对这些GPU的软件限制。该工具旨在删除此限制。</p><p>    In the following instructions  &lt;path_to_vgpu_unlock&gt; need to be replaced withthe path to this repository on the target system and  &lt;version&gt; need to bereplaced with the version of the NVIDIA GRID vGPU driver.</p><p>    在以下说明中＆lt; path_to_vgpu_unlock＆gt;需要在目标系统上用该存储库的路径替换为此存储库，并＆lt;版本＆gt;需要与NVIDIA网格VGPU驱动程序的版本进行偏移。</p><p> Install the NVIDIA GRID vGPU driver, make sure to install it as a dkms module.</p><p> 安装NVIDIA网格VGPU驱动程序，确保将其安装为DKMS模块。</p><p>  Modify the line begining with  ExecStart= in  /lib/systemd/system/nvidia-vgpud.serviceand  /lib/systemd/system/nvidia-vgpu-mgr.service to use  vgpu_unlock asexecutable and pass the original executable as the first argument. Ex:</p><p>  修改execstart =中的行开头=在/lib/systemd/system/nvidia-vgpud.serviceand /lib/systemd/system/nvidia-vgpu-mgr.service使用vgpu_unlock asexecutable并将原始可执行文件作为第一个参数传递。前任：</p><p>    Modify the file  /usr/src/nvidia-&lt;version&gt;/nvidia/os-interface.c and add thefollowing line after the lines begining with  #include at the start of thefile.</p><p>    修改文件/usr/src/nvidia-&lt ;version& gt ;/nvidia/os-Interface.c。然后在行开头的行开始后添加义目行。</p><p>           This script will only work if there exists a vGPU compatible Tesla GPU thatuses the same physical chip as the actual GPU being used.</p><p>           如果存在VGPU兼容的TESLA GPU，则此脚本只能在使用与所使用的实际GPU相同的物理芯片。</p><p>    In order to determine if a certain GPU supports the vGPU functionality thedriver looks at the PCI device ID. This identifier together with the PCI vendorID is unique for each type of PCI device. In order to enable vGPU support weneed to tell the driver that the PCI device ID of the installed GPU is one ofthe device IDs used by a vGPU capable GPU.</p><p>    为了确定某个GPU是否支持VGPU功能，ThedRiver查看PCI设备ID。此标识符与PCI VendorID一起对每种类型的PCI设备都是唯一的。为了使VGPU支持WENED告诉驱动程序，即安装GPU的PCI设备ID是VGPU能够的GPU使用的设备ID之一。 </p><p>  The userspace services nvidia-vgpud and nvidia-vgpu-mgr uses the ioctl syscallto communicate with the kernel module. Specifically they read the PCI device IDand determines if the installed GPU is vGPU capable.</p><p>Userspace Services NVIDIA-VGPUD和NVIDIA-VGPU-MGR使用IOCTL SYSCALLTO与内核模块进行通信。具体而言，他们读取了PCI设备idand确定已安装的GPU是否是VGPU的能力。</p><p> The python script vgpu_unlock intercepts all ioctl syscalls between theexecutable specified as the first argument and the kernel. The script thenmodifies the kernel responses to indicate a PCI device ID with vGPU supportand a vGPU capable GPU.</p><p> Python脚本vgpu_unlock拦截作为第一个参数和内核的标识到的外部安全性之间的所有IOCTL SYSCALL。该脚本将修改内核响应以指示具有VGPU的PCI设备ID，并启用VGPU的GPU。</p><p>  In order to exchange data with the GPU the kernel module maps the physicaladdress space of the PCI bus into its own virtual address space. This is doneusing the ioremap* kernel functions. The kernel module then reads and writesdata into that mapped address space. This is done using the memcpy kernelfunction.</p><p>  为了与GPU交换数据，内核模块将PCI总线的ProvindationAddress空间映射到自己的虚拟地址空间。这是IORemap *内核函数的代替。然后内核模块读取和写入该映射地址空间。这是使用memcpy kernelfunction完成的。</p><p> By including the vgpu_unlock_hooks.c file into the os-interface.c file we canuse C preprocessor macros to replace and intercept calls to the iormeap andmemcpy functions. Doing this allows us to maintain a view of what is mappedwhere and what data that is being accessed.</p><p> 通过将vgpu_unlock_hooks.c文件包括在OS-Interface.c文件中，我们可以为C preprocessor宏替换和拦截对Iormeap和Memcpy函数的调用。执行此操作允许我们维护映射的内容以及正在访问的数据。</p><p>  This is a modified version of the default linker script provided by gcc. Thescript is modified to place the .rodata section of nv-kernel.o into .datasection instead of .rodata, making it writable. The script also provide thesymbols  vgpu_unlock_nv_kern_rodata_beg and  vgpu_unlock_nv_kern_rodata_endto let us know where that section begins and ends.</p><p>  这是GCC提供的默认链接器脚本的修改版本。修改标记将nv-kernel.o的.rodata部分放入.dataSection而不是.rodata，使其可写。该脚本还提供TheSymbols vgpu_unlock_nv_kern_rodata_beg和vgpu_unlock_nv_kern_rodata_endto让我们知道该部分开始和结束的位置。</p><p>  After boot the nvidia-vgpud service queries the kernel for all installed GPUsand checks for vGPU capability. This call is intercepted by the vgpu_unlockpython script and the GPU is made vGPU capable. If a vGPU capable GPU is foundthen nvidia-vgpu creates an MDEV device and the /sys/class/mdev_bus directoryis created by the system.</p><p>  启动后NVIDIA-VGPUD服务查询所有已安装的GPUSAND的内核，检查VGPU功能。此呼叫由VGPU_UNLORKPYTHON脚本拦截，GPU是VGPU的能力。如果FOREDHEN-VGPU的VGPU能够获得GPU，则NVIDIA-VGPU创建了系统创建的MDEV设备和/ sys / class / mdev_bus目录。</p><p> vGPU devices can now be created by echoing UUIDs into the  create files in themdev bus representation. This will create additional structures representingthe new vGPU device on the MDEV bus. These devices can then be assigned to VMs,and when the VM starts it will open the MDEV device. This causes nvidia-vgpu-mgrto start communicating with the kernel using ioctl. Again these calls areintercepted by the vgpu_unlock python script and when nvidia-vgpu-mgr asks ifthe GPU is vGPU capable the answer is changed to yes. After that check itattempts to initialize the vGPU device instance.</p><p> 现在可以通过将UUID呼应到HIMDEV总线表示中的“创建文件”中创建VGPU设备。这将创建代表MDEV总线上的新VGPU设备的其他结构。然后可以将这些设备分配给VM，并且当VM启动时，它将打开MDEV设备。这会导致NVIDIA-VGPU-MGRTO使用IOCTL开始与内核通信。再次由VGPU_unlock Python脚本中的这些调用，当NVIDIA-VGPU-MGR询问GPU是否是VGPU时，答案更改为YES。在此之后，请检查iTattemps以初始化VGPU设备实例。 </p><p> Initialization of the vGPU device is handled by the kernel module and itperforms its own check for vGPU capability, this one is a bit more complicated.</p><p>VGPU设备的初始化由内核模块处理，并且其自身检查对VGPU功能的检查，这一个是更复杂的。</p><p> The kernel module maps the physical PCI address range 0xf0000000-0xf1000000 intoits virtual address space, it then performs some magical operations which wedon&#39;t really know what they do. What we do know is that after these operationsit accesses a 128 bit value at physical address 0xf0029624, which we call themagic value. The kernel module also accessses a 128 bit value at physicaladdress 0xf0029634, which we call the key value.</p><p> 内核模块映射物理PCI地址范围0xF0000000-0XF1000000进入虚拟地址空间，然后执行一些神奇的操作，该操作＆＃39; t真正知道他们的所作所为。我们所知道的是，在这些操作项访问0xF0029624的物理地址0xF0029624之前，我们调用了主题值。内核模块还访问ProvinessAddress 0xF0029634的128位值，我们调用键值。</p><p> The kernel module then has a couple of lookup tables for the magic value, onefor vGPU capable GPUs and one for the others. So the kernel module looks for themagic value in both of these lookup tables, and if it is found that table entryalso contains a set of AES-128 encrypted data blocks and a HMAC-SHA256signature.</p><p> 然后，内核模块具有一些查找表，用于魔法值，一个VGPU能够支持GPU，一个用于其他GPU。因此，内核模块在这两个查找表中寻找主题值，如果发现表张开表中包含一组AES-128加密数据块和HMAC-SHA256Signature。</p><p> The signature is then validated by using the key value mentioned earlier tocalculate the HMAC-SHA256 signature over the encrypted data blocks. If thesignature is correct, then the blocks are decrypted using AES-128 and the samekey.</p><p> 然后通过使用前面提到的键值来验证签名，然后通过加密数据块将HMAC-SHA256签名括起来。如果thesignature是正确的，则使用AES-128和诸如诸如诸如诸例解密块。</p><p>  So in order for the kernel module to accept the GPU as vGPU capable the magicvalue will have to be in the table of vGPU capable magic values, the key hasto generate a valid HMAC-SHA256 signature and the AES-128 decrypted data blockshas to contain a vGPU capable PCI device ID. If any of these checks fail, thenthe error code 0x56 &#34;Call not supported&#34; is returned.</p><p>  因此，为了让内核模块接受GPU作为VGPU的魔术瓦斯必须在VGPU的表格中的魔法值中，密钥Hasto生成有效的HMAC-SHA256签名，AES-128解密的数据块粗量包含一个VGPU有能力的PCI设备ID。如果这些检查中的任何一个失败，则错误代码0x56＆＃34;呼叫不支持＆＃34;被退回。</p><p> In order to make these checks pass the hooks in vgpu_unlock_hooks.c will lookfor a ioremap call that maps the physical address range that contain the magicand key values, recalculate the addresses of those values into the virtualaddress space of the kernel module, monitor memcpy operations reading at thoseaddresses, and if such an operation occurs, keep a copy of the value until bothare known, locate the lookup tables in the .rodata section of nv-kernel.o, findthe signature and data bocks, validate the signature, decrypt the blocks, editthe PCI device ID in the decrypted data, reencrypt the blocks, regenerate thesignature and insert the magic, blocks and signature into the table of vGPUcapable magic values. And that&#39;s what they do.</p><p> 为了使这些检查传递VGPU_UNLOCK_HOKS.C中的钩子将查找映射包含MAGICAND键值的物理地址范围的IOREMAP调用，将这些值的地址重新计算到内核模块的VirtualAddress空间中，监控Memcpy Operations Reading在ThoseDdresses中，如果发生这种操作，请保持值的副本，直到彼此已知，找到NV-Kernel.o的.rodata部分中的查找表，找到签名和数据Bocks，验证签名，解密块，解密块，在解密的数据中编辑PCI设备ID，reencrypt块，再生thesignature并将魔法，块和签名插入VGPucapable魔术值的表中。那个＆＃39;他们所做的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/DualCoder/vgpu_unlock">https://github.com/DualCoder/vgpu_unlock</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/vgpu/">#vgpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/grade/">#grade</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>