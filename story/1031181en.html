<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>两个随机选择的力量</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">两个随机选择的力量</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 10:57:17</div><div class="page_narrow text-break page_content"><p>In many large-scale web services, multiple layers of stateless and stateful services are seperated by load balancers. Load balancing can be done with dedicated hardware, with dedicated software load balancers, using DNS trickery or through a load-balancing mechanism in the client. In large systems, the resources and constraints at each layer can vary widely. Some layers are stateless, and easily scale horizontally to many machines. Other layers may be more constrained, either due to the need to access state or contention for some other shared resource.</p><p>在许多大型Web服务中，多层无状态和有状态服务由负载均衡器分隔。负载平衡可以使用专用硬件、使用专用软件负载平衡器、使用DNS技巧或通过客户端中的负载平衡机制来实现。在大型系统中，每一层的资源和约束可能差别很大。有些层是无状态的，可以很容易地水平扩展到许多机器。由于需要访问状态或争用某些其他共享资源，其他层可能会受到更多限制。</p><p> Centralized load balancing solutions can distribute load over a fleet of machines very well. They track the amount of load they are sending to each machine (usually based on a simple measurement like connection count). Because they are centralized, load balancers typically don&#39;t need to worry about load sent from other sources. They have complete control over the distribution of load.</p><p>集中式负载平衡解决方案可以很好地将负载分布在一组机器上。它们跟踪它们发送到每台机器的负载量(通常基于简单的测量，如连接计数)。因为它们是集中式的，所以负载平衡器通常不需要担心从其他来源发送的负载。他们完全控制着荷载的分配。</p><p> Despite this advantage, dediced load balancers are often undesirable. They add cost, latency, complexity, and may introduce a single point of failure. Handing the task of load balancing to each upstream client is also possible, but introduces the challenge of fairly balancing the load from multiple places. In large systems with large numbers of clients and fairly homogeneous calls, a purely random system like DNS round robin can work very well. In smaller systems, systems where each downstream service can only handle a small number or concurrent requests, and systems where requests are heterogeneous it&#39;s often desirable to load balance better than random.</p><p>尽管有这一优势，专用负载均衡器通常是不受欢迎的。它们增加了成本、延迟和复杂性，并可能引入单点故障。将负载平衡任务交给每个上游客户端也是可能的，但会带来从多个地方公平平衡负载的挑战。在具有大量客户端和相当同类调用的大型系统中，纯随机系统(如DNS循环调度)可以非常好地工作。在较小的系统中，在每个下游服务只能处理少量或并发请求的系统中，以及在请求是异构的系统中，负载平衡通常比随机负载平衡更好。</p><p> Perfect distributed load balancing could be done, at least in the happy case, by distributing information about system load across all the clients. The overhead of constantly sharing the exact load information between different sources can be high, so it&#39;s tempting to have each source work off a cached copy. This data can periodically be refreshed from downstream, or from other clients.</p><p>通过跨所有客户端分发有关系统负载的信息，可以实现完美的分布式负载平衡，至少在令人满意的情况下是这样。在不同的源之间不断共享准确的负载信息的开销可能很高，因此让每个源在一个缓存副本中工作是很有诱惑力的。此数据可以从下游或其他客户端定期刷新。</p><p>  In  The Power of Two Random Choices: A Survey of Techniques and Results, Mitzenmacher et. al. survey some research very relevant to this problem. The entire survey is good reading, but one of the most interesting results is about the effects of delayed data (like the cached load results mentioned above) on load balancing. The results are fairly logical in retrospect, but probably don&#39;t match most engineers&#39; first expectations.</p><p>“两个随机选择的力量：技术和结果的调查”，Mitzenmacher et。艾尔。调查了一些与这个问题非常相关的研究。整个调查都很好读，但最有趣的结果之一是关于延迟数据(如上面提到的缓存负载结果)对负载平衡的影响。回想起来，结果相当合乎逻辑，但可能与大多数工程师的最初预期不符。</p><p> Using stale data for load balancing leads to a herd behavior, where requests will herd toward a previously quiet host for much longer than it takes to make that host very busy indeed. The next refresh of the cached load data will put the server high up the load list, and it will become quiet again. Then busy again as the next herd sees that it&#39;s quiet. Busy. Quiet. Busy. Quiet. And so on.</p><p>使用陈旧数据进行负载平衡会导致群组行为，在这种情况下，请求将向以前安静的主机聚集的时间比使该主机真正变得非常繁忙所需的时间长得多。下一次刷新缓存的加载数据将把服务器放在负载列表的最前面，并且它将再次变得安静。然后又忙碌起来，因为下一群牛群看到这里很安静。忙着呢。安静。忙着呢。安静。诸若此类。</p><p> One possible solution would be to give up on load balancing entirely, and just pick a host at random. Depending on the load factor, that can be a good approach. With many typical loads, though, picking a random host degrades latency and reduces throughput by wasting resources on servers which end up unlucky and quiet.</p><p>一种可能的解决方案是完全放弃负载平衡，只需随机选择一台主机。根据负载率的不同，这可能是一个很好的方法。然而，对于许多典型的负载，选择随机主机会降低延迟并减少吞吐量，因为这会浪费服务器上的资源，而这些资源最终会以不幸和安静告终。</p><p> The approach taken by the studies surveyed by Mitzenmacher is to try two hosts, and pick the one with the least load. This can be done directly (by querying the hosts) but also works surprisingly well on cached load data.</p><p>Mitzenmacher调查的研究采取的方法是尝试两个主机，然后选择负载最小的一个。这可以直接完成(通过查询主机)，但在缓存的加载数据上也运行得出奇地好。</p><p> To illustrate how well this works, I ran a simulation of a very simplistic system. Every second one request arrives at a system with 10 servers. Every 8 seconds the oldest request (if any) is removed from the queue on the servers. Load balancing is done with a cached copy of the server queue lengths, updated every N seconds. I considered four approaches: chose a random server, chose the best server, best of two random choices and best of three random choices.</p><p>为了说明这是如何工作的，我对一个非常简单的系统进行了模拟。每隔一秒就有一个请求到达具有10台服务器的系统。每8秒从服务器上的队列中删除最早的请求(如果有)。负载平衡是使用服务器队列长度的缓存副本完成的，每N秒更新一次。我考虑了四种方法：选择一个随机服务器，选择最好的服务器，两个随机选择中最好的和三个随机选择中最好的。</p><p>  As you can expect, the  pick the best approach worked best when perfect undelayed information was available. In the same case, the random pick approach worked poorly, leading to the worst queue times of any of the approaches. As the age of the data increases, the  pick the best approach becomes worse and worse because of herding and soon overtakes the random approach as the worst one.</p><p>正如您所预期的那样，当有完美的、未延迟的信息可用时，选择最好的方法效果最好。在相同的情况下，随机挑选方法的效果很差，导致了所有方法中最糟糕的排队时间。随着数据年龄的增加，挑选最好的方法会因为羊群效应而变得越来越差，很快就会超过随机方法成为最差的方法。</p><p> Best of 3 starts in second place, and puts in a good performance. It gains first place, only to cede it to  best of 2 as the delay increases. Clearly, the behavior for  best of k will approach the behavior of  best as k approaches the number of servers.  Best of 2 remains the strong leader all the way to the end of this simulation. Given these parameters it would start losing to the random approach around a refresh interval of 70. It is the clear leader for intervals over the range from 10 to 70, which is an impressive performance for such a simple approach.</p><p>三局四胜排在第二位，表现不错。它获得了第一名，但随着延迟的增加，它被让给了2胜2负的结果。显然，当k接近服务器数量时，k中最佳的行为将接近Best的行为。在此模拟结束的过程中，2胜2取始终是强有力的引导者。在给定这些参数的情况下，它将在刷新间隔70左右开始输给随机方法。它在从10到70的区间内是明显的领先者，对于这样一个简单的方法来说，这是一个令人印象深刻的表现。</p><p> Best of 2 is good because it combines the best of both worlds: it uses real information about load to pick a host (unlike random), but rejects herd behavior much more strongly than the other two approaches.</p><p>二选一是好的，因为它结合了两种方法的优点：它使用关于负载的真实信息来选择主机(与随机不同)，但比其他两种方法更强烈地拒绝羊群行为。</p><p> Take a look at  The Power of Two Random Choices for a much stronger mathematical argument, and some more surprising places this algorithm works really well.</p><p>看看两个随机选择的力量，以获得更有力的数学论证，以及一些更令人惊讶的地方，这个算法真的工作得很好。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://brooker.co.za/blog/2012/01/17/two-random.html">https://brooker.co.za/blog/2012/01/17/two-random.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/选择/">#选择</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/random/">#random</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/负载/">#负载</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>