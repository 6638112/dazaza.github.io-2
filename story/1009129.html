<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于Modelica：一种基于方程的物理系统建模语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于Modelica：一种基于方程的物理系统建模语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-01 03:07:29</div><div class="page_narrow text-break page_content"><p>在我职业生涯的早期，当ML和AI不那么酷的时候，我爱上了建模和模拟。正如Joel Spolsky最近所说，有时你正在做的事情太复杂了，无法用简单的数学推理，你甚至无法开始猜测输入对输出的影响。在这种情况下，仿真模型将帮助您更好地理解复杂问题。</p><p>在从事建模和仿真工作时，我发现了Modelica，一种用于开发仿真模型的语言。我在攻读博士期间以及在劳伦斯伯克利国家实验室的第一份工作中都与Modelica进行了广泛的合作。Modelica是对网络物理系统进行建模的一个很好的工具，例如，研究混合动力汽车的燃油效率，或者评估可再生能源与电网之间的相互作用。</p><p>在这篇文章中，我将提供Modelica的一般概述，并展示它的一些主要功能。</p><p>顾名思义，Modelica是一种建模语言。哪种类型的模型？数学模型Modelica并不专注于特定的应用领域，它允许您自由地对各种问题建模，从汽车或航空航天应用的机电系统到银行的金融模型。</p><p>您可以使用该语言通过以下形式的任意组合来创建数学模型。</p><p>正如你可以想象的那样，这种灵活性使得解决许多不同和有趣的工程问题变得更容易，包括网络物理系统。这类系统的典型例子是汽车。汽车的特点是机械部件与电子和液压系统相互作用，都在多个控制系统的监督下。因此，如果你想知道一辆汽车的实际表现，你需要模拟整个过程。</p><p>忽视组件之间的相互作用--这在模拟界是个新手错误--会导致对系统的理解很差。</p><p>不难找到其他网络物理系统的例子，它们无处不在：</p><p>我们的家庭，这要归功于越来越多的人采用光伏电池板、电池、电动汽车和物联网设备。</p><p>因此，在这一点上，你应该相信网络物理系统是日常生活中很重要的一部分。Modelica允许工程师和科学家对这些系统进行精确建模，让我们有机会提高它们的性能。这就是为什么Modelica很重要。</p><p>问任何一位工程师，他们都会告诉你--“为真实世界建模很难！”工程师们在创建复杂物理系统的模型时会采取平衡行动，既要建立详细的模拟，又要努力应对压倒性的复杂性或不相干的细节。</p><p>Modelica建模语言有几个特性，使其成为建模复杂工程系统的正确选择。Modelica不是被现代工业忽视的抽象学术玩具。事实上，在过去的几年里，Modelica已经被世界上一些最大的汽车公司采用-奥迪、宝马、戴姆勒、福特、丰田和大众。这些公司使用Modelica设计节能汽车，改进空调系统。他们的法拉利F1车队也使用Modelica设计他们的赛车！汽车行业只是发现这种语言有效的众多公司之一。航空航天和能源行业越来越多地采用Modelica，美国能源部一直在稳步投资于这项技术，用于建筑建模和提高能源效率。</p><p>如Modelica协会网站所述，Modelica是一种非专有的、面向对象的、基于方程的语言，可方便地对复杂的物理系统建模，包括各种不同的方面，包括机械、电气、电子、液压、热能、控制、电力或面向过程的子组件。</p><p>一位工程师/科学家编写了一个Modelica模型，该模型将一个想法表示为一系列方程，</p><p>Modelica工具分析模型并验证其正确性-模型是否具有相同数量的变量和方程式？有打字错误吗？</p><p>在深入研究Modelica的一些核心概念之前，让我们先从一个例子开始，这是一种微分方程的HelloWorld。我们将使用你能想象到的最简单的微分方程</p><p>1模型HelloWorld&#34；有史以来最简单的微分方程&#34；2//在这里定义变量和参数……。3实数x 4&#34；未知变量&#34；；5常数Real a=-2.0 6&#34；常数&#34；；7参数Real x_start=5.0 8&#34；变量x&#34；；9初始方程10//在此定义初始条件.。11 x=x_start；12方程式13//将方程式写在这里.。14 der(X)=a*x；15 End HelloWorld；</p><p>关键字model定义了名为HelloWorld的模型的开头。模型分为三个部分：声明、初始化和方程。模型从声明变量、常量和参数开始。变量表示预期随时间变化的量。同时，常数是固定不变的量，永远不会改变。在这种情况下，参数x_start、常量a和变量x具有相同的类型，而Real类型表示浮点数。</p><p>关键字初始方程介绍了我们模型的第二部分，这里我们定义了系统的初始条件，例如我们模型模拟时间开始时的x值。</p><p>关键字方程介绍了程序的第三部分，也是最后一部分，在这里我们最终开始编写系统的方程。在本例中，有一个变量x和一个微分方程der(X)=a*x。</p><p>需要注意的一点是DER(.)。表示括号内表达式的时间导数的运算符。在处理数学模型时，能够以如此简洁的方式表示导数是非常有帮助的。</p><p>为了熟悉Modelica，我们已经完成了一个简单的示例。现在，让我们来看看它最有趣的一些特性。正如我在文章开头提到的，Modelica是一种面向对象的、基于方程的建模语言。这些词到底是什么意思？让我们来看看，在数学建模的背景下。</p><p>计算机程序只不过是一套聪明的指令，让计算机为我们解决特定的问题(如果这听起来耳熟，请耐心听我说。我将区分赋值和您可能不熟悉的等式)。让我们考虑以下问题：给定两个数字，计算它们的和。下面的代码片断显示了用C++实现的问题的解决方案。</p><p>int main(Void){int a，b，c；a=4；b=3；c=a+b；return 0；}</p><p>当程序执行时，这里发生的是，值4被插入到与变量a相关联的存储空间中，值3被插入到与变量b相关联的存储空间中，然后它们的总和被分配给与变量c相关联的存储空间。</p><p>在给定初始问题的情况下，此程序实现了对其的特定解决方案。而且，大多数时候，当我们编写算法时，我们编写的是针对某些问题的特定解决方案。在这种情况下，问题及其算法解决方案非常简单！</p><p>现在关键是：在处理数学建模时，情况完全不同。通常从描述要建模的系统的一般理解的一组方程开始。</p><p>然后，您可以收集有关该系统的数据，并将其输入到这些方程式中，以开始为您的问题生成一些有趣的答案。通常有多个问题要回答，因此模型应该尽可能通用，以便易于操作来回答所有问题。</p><p>让我们回到我们的问题上：给定两个数字，计算它们的和。以下是解决该问题的Modelica模型示例。</p><p>1模型求和2整数a，b，c；3方程4c-(a+b)=0；5a=4；6b-3=0；</p><p>第4行的内容是基于方程的建模的精髓。这一切都可以归结为两个概念：</p><p>c-(a+b)=0是一个方程式，不像我们用C、Java、Python等编写的方程式是赋值的。</p><p>a=4和b-3=0位于第5行和第6行。这两行都在第一个方程式之后，由于方程式不是赋值的，因此它们的顺序无关紧要。唯一重要的是模型具有相同数量的变量和方程式。</p><p>因此，事实证明，基于方程的建模完全是用代码编写方程。所选的Modelica工具将知道如何对模型进行符号分析、提取方程、替换方程中的变量、对它们进行排序并应用适当的数值方法来求解。</p><p>在集中讨论a-因果关系的含义和含义之前，让我们先看一个基于牛顿第二定律的例子。</p><p>由净力产生的物体加速度与净力的大小成正比，方向与净力相同，与物体的质量成反比。</p><p>牛顿第二定律描述了以下几个量之间的关系：作用在物体上的力、物体的质量和加速度。</p><p>下面的示例显示了一个系统，其中一个只能沿一个方向移动的物体受到两个力的作用。</p><p>有了这个系统，我们可以找出一些需要解决的问题。识别问题并找到解决方案需要我们遵循特定的心理过程：</p><p>改写牛顿第二定律，找出所需的量(如加速度、力、质量等)。</p><p>下面是一个用框图表示的问题及其解决方案的小列表；每个图都直观地描述了信息如何从输入(即已知变量)流向输出(即问题的答案)。</p><p>给定物体的位置、质量和一种力，就可以计算另一种力。</p><p>重新排列牛顿第二定律，以便找到一条从一个通向另一个的路径。</p><p>我们刚刚看到的是所谓的因果方法：显式地描述变量之间的因果关系，并将它们硬编码到计算解决方案的算法中。即使物理系统总是相同的，关于系统的稍微不同的问题也可能需要完全重写解决问题的算法。上面的框图很好地说明了这一概念。即使底层系统总是相同的，对数据执行的操作类型和操作顺序也在不断变化，这是相当不方便的，特别是在处理比单个物体和多个力耦合力更复杂的系统时！</p><p>此外，设计复杂系统是一个迭代的过程。随着过程的发展，新的问题不断涌现，如果算法只能回答一个问题，并且需要重写以回答稍有不同的问题，那就没有多大用处了。</p><p>Modelica基于方程的性质使得所谓的a-因果建模方法成为可能：建立数学模型时不需要假设变量之间的先验因果关系。让我们试着在Modelica中对相同的单体系统建模，看看它是什么样子。</p><p>1模型SingleBodySystem 2实数M&#34；；3实数x&#34；车身位置&#34；；4实数v&#34；车身速度&#34；；5实数a&#34；车身加速度&#34；；6实数F1，F2&#34；作用在车身上的力&#34；7初始条件8//初始条件9 x=0&#34；当时间=0&#34；10v=0&#34；；11方程12//系统的动态行为13v=der(X)；14a=der(V)；15M*a=F1-F2；1617//其他&#34；边界&#34；条件18F1=1.2；19F2=2.0；20M=5.0；21End SingleBodySystem；</p><p>方程式部分分为两部分。第一部分描述牛顿第二定律，即系统的动力学。除非身体开始以光速运动，否则这部分是不会改变的！</p><p>第二部分包含其他“边界”条件。这些条件是了解系统的完整结构所必需的，它们可能会根据所提出的问题而变化。</p><p>当这些条件发生变化时，Modelica工具会尽一切努力找出变量之间的因果关系。一旦Modelica工具找到输入和输出之间的关系，它就会生成一个解决问题的可执行文件。</p><p>这种方法利用计算机进行枯燥且容易出错的重写和排序方程的工作。在这方面，计算机绝对比人类做得更好！</p><p>a-因果关系的一个双重产物是用Modelica编写的模型更具可读性和可维护性，该模型包含对系统及其边界条件的描述，而不是特定问题的解决方案。大多数熟悉软件工程最佳实践的读者都知道这一点非常重要，特别是在处理复杂和大型模型时。</p><p>在简要讨论了a-因果关系之后，我希望您相信，编写问题的临时解决方案类似于编写汇编代码，而不是使用高级语言和编译器。</p><p>正如我已经提到的，Modelica变量可以有类型。Modelica提供了将单位与变量相关联的能力。此功能非常简单，但对代码质量有显著影响。向变量/参数/常量添加单位可以提高在方程中出错的能力，并使代码更具可读性。Real v和Modelica.SIunits.Volume v哪个更清楚？！</p><p>Modelica标准库(在Github上提供的MSL)提供了一个包含单位并扩展原始类型Real的广泛类型列表。此摘录自MSL显示，显示定义了热力学温度、温度和规格热容量类型。每种类型都有一个名为单位的属性，用于检查公式的有效性。</p><p>1类型热力学温度=实型(2个最终数量=&#34；热力学温度&#34；，3个最终单位=&#34；K&#34；，4分钟=0.0，5开始=288.15，6公称=300，7显示单位=&#34；°C&#34；8)；9 10类型温度=热力学温度；11 12类型规格热容=实型(13最终数量=&#34；规格热容&#。J/(kg.k)&#34；15)；</p><p>单位可以是简单的，如开尔文，由字符串K表示，也可以从其他单位导出，如比热容，表示为J/(kg.K)，即导致温度变化1开尔文的单位质量的能量。Modelica工具使用有关类型系统和单位的信息来检查模型是否有效。例如，以下模型。</p><p>1个模型TestSIUnits 2个Modelica。小单元。温度T；3Modelica。小单元。能量E；4参数Modelica。小单元。指定HeatCapacity cp=1000；5参数Modelica。小单元。质量m=1；6方程式7 T=300；8 E=cp*T；//忘记添加m*.9 End TestSIUnits；</p><p>无效，因为公式E=cp*T中的单位不匹配。左边是能量，单位是焦耳J，右边的单位是焦耳/开尔文J/kg。当工具分析和分析模型时，在方程E=cp*T，J！=J/kg中产生以下误差单位误差。这样的错误信息很容易理解，我们忘记了质量，正确的方程式应该是E=m*cp*T。</p><p>到目前为止，我们已经看到了变量很少、方程很简单的示例。现实世界的系统要比这复杂得多。A-因果关系和类型有助于保持代码的可读性，并减少错误。这只是冰山一角，为了对复杂的系统建模，我们需要一些额外的功能。</p><p>下一个例子是这个电路，一个电压源、一个电阻器和一个电容器的串联(如果你对我的电路不熟悉，你无论如何都会明白这些概念的)。</p><p>如果我们使用基尔霍夫电路定律来分析电路，我们最终会用以下公式编写一个Modelica模型。</p><p>1型号RC_v1&#34；RC型号版本1.0&#34；2 Modelica。小单元。电压E3&#34；电压源&#34；；4Modelica。小单元。电压VC5&#34；电容器的电压6Modelica。小单元。电流流经电路8参数Modelica的电流。小单元。容量C=1e-3 9&#34；容量&#34；；10参数Modelica。小单元。电阻R=1e3 11&#34；；12初始方程13VC=0.0；14方程15E=10.0；16C*DER(VC)=i；17R*i=E-VC；18结束RC_v1；</p><p>该模型以一种“扁平”的方式表示物理系统，作为电路一部分的电子元件之间没有明显的区别。我们没有利用Modelica提供的a-因果关系，我们最终得到了一个代表这个特定电路的模型。</p><p>把电路想象成由相互连接的元件组成的网络会更方便。</p><p>上图显示了线路及其构件的分解视图。包含在灰色矩形中的每个组件代表一件实际的硬件(例如，电阻器、电容器、电缆等)。</p><p>如果有一个虚拟电子元件库不是更好吗？这些虚拟电子元件库可以连接在一起来生成各种虚拟电路，难道不是更好吗？是的，Modelica允许创建模块模型，这些模块模型可以像构造块一样组装，这要归功于连接器。</p><p>Modelica连接器是一种允许连接模型并让它们交换信息的结构。连接器的灵感来自真实世界的物理交互。让我们来看看实际的电子组件是如何工作的，以获得一些见解。</p><p>上面的图片显示了一个电阻器和一个电容器。它们是非常不同的物体，根据不同的规律工作，但是它们有一个共同的特点：它们都有两根导线(也称为端子引脚)。</p><p>电阻器和电容器并不关心电路的哪一部分，它们的行为取决于提供给其端子的电压和电流。电阻器和电容器通过它们的终端看到世界--它们工作得很好。</p><p>当工程师设计电阻器和电容器相互作用的电路时，它们的端子是焊接的。焊接电端子施加了两个物理约束，它们的结点上的电压变得相同，从一个组件流出的电流进入另一个组件。</p><p>在电学领域，表征元件(如电阻器或电容器)行为的边界条件是电压和电流。这意味着电气元件的Modelica连接器将如下所示</p><p>用于电气系统的1个连接器端子连接器/接口2型号。小单元。电压v 3&#34；端子电压&#34；；4流量模型。小单元。电流I 5&34；流过端子&#34；6&#34；(正进入模型)&#34；；7端子的电流；</p><p>到目前为止，我们已经看到可以使用连接器来定义边界条件。现在，我们将了解如何使用连接器来构建表示电阻的自包含模型。</p><p>1个型号电阻器2个端子A、B；3个参数Modelica。小单元。电阻R=1e3 4&#34；；5公式6//连接器变量之间的约束7//即进入8//连接器A的电流离开连接。</p><p>..</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://marcobonvini.com/modelica/2020/06/29/all-about-modelica.html">https://marcobonvini.com/modelica/2020/06/29/all-about-modelica.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/物理/">#物理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/equation/">#equation</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/modelica/">#modelica</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/game_intelligence_476177.html"><img src="http://img.diglog.com/img/2011/8/thumb_e3627e6352794491b774504925817bd8.gif" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/game_intelligence_476177.html">划线接糖(Sugar,Sugar)</a></div><span class="my_story_list_date">2011-8-13 18:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/game_intelligence_471869.html"><img src="http://img.diglog.com/img/2011/8/thumb_86f7064a496d4e28904bd8e2b2578a5a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/game_intelligence_471869.html">吸血鬼物理学(Vampire Physics)</a></div><span class="my_story_list_date">2011-8-6 11:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/game_intelligence_410133.html"><img src="http://img.diglog.com/img/2011/4/thumb_e21264d53d2f43aab56230f8cdf8900f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/game_intelligence_410133.html">怪物找眼睛(The eye)</a></div><span class="my_story_list_date">2011-4-9 13:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/technology_games_127241.html"><img src="http://img.diglog.com/img/2009/2/thumb_84f7a8a451c14c2895e6126d77676328.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/technology_games_127241.html">[组图]15个最佳Flash物理游戏</a></div><span class="my_story_list_date">2009-2-27 14:19</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>