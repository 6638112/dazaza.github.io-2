<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>失控 Out of Control</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Out of Control<br/>失控 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 15:43:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/38e6267575afbe2f8bdee47fe39797a0.png"><img src="http://img2.diglog.com/img/2021/1/38e6267575afbe2f8bdee47fe39797a0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>An essay on paradigms, refactoring, control flow, data, code, dualism and what Roman numerals ever did for us</p><p>关于范式，重构，控制流，数据，代码，二元性以及罗马数字曾经为我们做什么的文章</p><p> Looking at something from a different point of view can reveal a hidden side. With physical objects this hidden side can be literal, hence why technical drawings of three-dimensional objects are often made using a  multi-view projection, such as a plan view and elevation views. With abstract concepts the hidden side is more figurative. In software architecture, for example, view models, such as  4+1 or  ODP viewpoints, can be used to bring different concerns of a system into focus, such as user interaction, governance, behaviour, code structure, information model, physical distribution, infrastructure, etc.</p><p> 从不同的角度看事物可以揭示隐藏的一面。对于物理对象，此隐藏面可以是字面的，因此，为什么通常使用多视图投影（例如平面图和立面图）制作三维对象的技术图纸。对于抽象概念，隐藏的一面更具象征意义。例如，在软件架构中，可以使用视图模型（例如4 + 1或ODP视点）来关注系统的不同问题，例如用户交互，治理，行为，代码结构，信息模型，物理分布，基础设施等</p><p> Numeral  systems also have this quality. Changing how numbers are represented doesn’t change the numbers represented, but it does change how we think about them. Thinking about integers in binary, for example, reveals different patterns (and failures) than when we think about them in decimal. Binary also chunks more easily into hexadecimal. Thinking about RGB triplets makes more sense in hex than in decimal. And so on.  Changing base can reveal new possibilities.</p><p> 数字系统也具有这种质量。改变数字的表示方式不会改变数字的表示方式，但是会改变我们对数字的看法。例如，考虑二进制中的整数，会发现与十进制中的整数（和失败）不同的模式（和失败）。二进制也更容易将其分块为十六进制。考虑到RGB三元组，十六进制比十进制更有意义。等等。不断变化的基础可以揭示新的可能性。</p><p> The same shift in perspective is also possible moving from a positional system, such as the common  Hindu–Arabic system for decimals, to one based on abbreviations of values of different magnitudes, a  sign–value system ( sign in the semiotic sense of  symbol rather than as a positive/negative indicator), such as  Roman numerals. And somewhere between these two numeral systems — and more globally — we find the abacus, a  bi-quinary coded decimal system (like Roman numerals), built on a simpler sign system, but organised positionally (like the Hindu–Arabic system) to enable rapid arithmetic.</p><p> 从位置系统（例如常见的印度－阿拉伯小数系统）到基于不同幅度值缩写的符号系统（符号在符号的符号意义上更确切地说是符号）而不是作为正/负指示符），例如罗马数字。在这两个数字系统之间的某个位置（乃至更广泛的范围内），我们发现算盘是一个双五进制编码的十进制系统（例如罗马数字），建立在一个更简单的符号系统上，但是在位置上进行组织（例如印度-阿拉伯系统）以实现快速算术。</p><p> The Roman numeral system was used across Europe before the widespread adoption of the Hindu–Arabic system. It was perhaps more uniformly standardised following the fall of the Western Empire than during the heyday of Roman rule.</p><p> 在印度－阿拉伯系统广泛采用之前，罗马数字系统已在整个欧洲使用。与西罗马帝国统治时期相比，西方帝国陷落后的情况可能更加统一。</p><p> That would be the end of the history lesson if it were not for the persistence of the numeral system long after the Renaissance and into the modern day. The most likely places you will encounter Roman numerals these days include old buildings, analogue clock faces, sundials, chords in music, copyright years for BBC programmes and  coding katas for programmers.</p><p> 如果不是为了在文艺复兴之后到现代很长时间内坚持数字系统，那将是历史课的结束。这些天，您最可能会遇到罗马数字的地方包括老建筑，模拟钟面，日di，音乐和弦，BBC程序的版权年和程序员的编码katas。</p><p>  The standard form can comfortably represent 1 to 3999 (I to MMMCMXCIX), although sometimes 4000 and beyond can be expressed (with 4000 as MMMM); numbers beyond this range would typically have been written as words, and would often be approximated. There was no notation for zero — or even a concept of zero as a number — so in medieval texts this would have been written as  nulla or abbreviated to  N. And, without zero, there were certainly no negative numbers.</p><p>  标准格式可以舒适地表示1到3999（I到MMMCMXCIX），尽管有时可以表示4000或更高（MMMM为4000）。超出此范围的数字通常会被写为单词，并且通常会被近似。没有表示零的符号，甚至没有表示零的数字的概念，因此在中世纪的文字中，该数字将被写为nulla或缩写为N。而且，如果没有零，则肯定没有负数。 </p><p>  The following Python code shows one way of converting a number to a corresponding string of Roman numerals:</p><p>以下Python代码显示了一种将数字转换为相应的罗马数字字符串的方法：</p><p> def roman(number):  result = &#34;&#34;  while number &gt;= 1000:  result += &#34;M&#34;  number -= 1000  if number &gt;= 900:  result += &#34;CM&#34;  number -= 900  if number &gt;= 500:  result += &#34;D&#34;  number -= 500  if number &gt;= 400:  result += &#34;CD&#34;  number -= 400  while number &gt;= 100:  result += &#34;C&#34;  number -= 100  if number &gt;= 90:  result += &#34;XC&#34;  number -= 90  if number &gt;= 50:  result += &#34;L&#34;  number -= 50  if number &gt;= 40:  result += &#34;XL&#34;  number -= 40  while number &gt;= 10:  result += &#34;X&#34;  number -= 10  if number &gt;= 9:  result += &#34;IX&#34;  number -= 9  if number &gt;= 5:  result += &#34;V&#34;  number -= 5  if number &gt;= 4:  result += &#34;IV&#34;  number -= 4  while number &gt;= 1:  result += &#34;I&#34;  number -= 1  return result</p><p> def roman（number）：结果=＆＃34;＆＃34;而数字＆gt; = 1000：结果+ =＆＃34; M＆＃34;如果数字＆=; = 900，则数字-= 1000：结果+ =＆＃34; CM＆＃34;如果数字＆=; = 500，则数字-= 900：结果+ =＆＃34; D＆＃34;如果数字＆=; = 400，则数字-= 500：结果+ =＆＃34; CD＆＃34;数字-= 400，而数字＆gt; = 100：结果+ =＆＃34; C＆＃34;如果数字＆gt; = 90，则数字-= 100：结果+ =＆＃34; XC＆＃34;数字-= 90（如果数字＆gt; = 50：结果+ =＆＃34; L＆＃34;数字-= 50（如果数字＆gt; = 40：结果+ =＆＃34; XL＆＃34;数字-= 40，而数字＆gt; = 10：结果+ =＆＃34; X＆＃34;数字-= 10（如果数字＆gt; = 9：结果+ =＆＃34; IX＆＃34;数字-= 9（如果数字＆gt; = 5：结果+ =＆＃34; V＆＃34;数字-= 5（如果数字＆gt; = 4：结果+ =＆＃34; IV＆＃34;数字-= 4，而数字＆gt; = 1：结果+ =＆＃34; I＆＃34;数字-= 1返回结果</p><p> Leaving aside questions of type and range validation, this code works. We can find support for this claim through reasoning, review and running against the following sample of test cases:</p><p> 抛开类型和范围验证的问题，此代码有效。我们可以通过推理，检查并针对以下测试用例样本找到对此主张的支持：</p><p> cases = [   # Decimal positions correspond to numerals   [1, &#34;I&#34;], [10, &#34;X&#34;], [100, &#34;C&#34;], [1000, &#34;M&#34;],   # Quinary intervals correspond to numerals   [5, &#34;V&#34;], [50, &#34;L&#34;], [500, &#34;D&#34;],   # Multiples of decimal numerals concatenate   [2, &#34;II&#34;], [30, &#34;XXX&#34;], [200, &#34;CC&#34;], [3000, &#34;MMM&#34;],   # Non-multiples of decimals concatenate in descending magnitude   [6, &#34;VI&#34;], [23, &#34;XXIII&#34;], [273, &#34;CCLXXIII&#34;], [1500, &#34;MD&#34;],   # Numeral predecessors are subtractive   [4, &#34;IV&#34;], [9, &#34;IX&#34;], [40, &#34;XL&#34;], [90, &#34;XC&#34;], [400, &#34;CD&#34;],   # Subtractive predecessors concatenate   [14, &#34;XIV&#34;], [42, &#34;XLII&#34;], [97, &#34;XCVII&#34;], [1999, &#34;MCMXCIX&#34;] ] failures = [  [number, expected, roman(number)]  for number, expected in cases if expected != roman(number) ] assert failures == [], str(failures)</p><p> case = [＃小数位对应于数字[1，＆＃34; I＆＃34;]，[10，＆＃34; X＆＃34;]，[100，＆＃34; C＆＃34;]，[1000 ，＆＃34; M＆＃34;]，＃五进制间隔对应于数字[5，＆＃34; V＆＃34;]，[50，＆＃34; L＆＃34;]，[500，＆＃34; D＆＃34;]，＃个十进制数字的整数连接[2，＆＃34; II＆＃34;]，[30，＆＃34; XXX＆＃34;]，[200，＆＃34; CC＆＃34;] ，[3000，＆＃34; MMM＆＃34;]，＃非十进制小数以降序连接[6，＆＃34; VI＆＃34;]，[23，＆＃34; XXIII＆＃34;]， [273，＆＃34; CCLXXIII＆＃34;]，[1500，＆＃34; MD＆＃34;]，＃数个前任是减法的[4，＆＃34; IV＆＃34;]，[9，＆＃34 ; IX＆＃34;]，[40，＆＃34; XL＆＃34;]，[90，＆＃34; XC＆＃34;]，[400，＆＃34; CD＆＃34;]，＃个相减的前任串联在一起[14，＆＃34; XIV＆＃34;]，[42，＆＃34; XLII＆＃34;]，[97，＆＃34; XCVII＆＃34;]，[1999，＆＃34; MCMXCIX＆＃34; ]] failures = [[数字，期望，罗马（数字）]，如果期望的话，则期望！= roman（number）]断言失败== []，str（失败）</p><p> So, sure, the function works, but it ain’t pretty. It’s the kind of code only an enterprise programmer could love. Or, perhaps, a Pascal programmer: this control-flow–heavy approach was used in  Pascal: User Manual and Report by Kathleen Jensen and Niklaus Wirth. Given that Pascal was often held up as a language from which and in which to learn good practice this might be considered ironic.</p><p> 因此，可以肯定的是，该功能有效，但效果并不理想。这是只有企业程序员才能喜欢的代码。或者，也许是Pascal程序员：Kathleen Jensen和Niklaus Wirth在《 Pascal：用户手册和报告》中使用了这种繁琐的控制流方法。鉴于Pascal通常被视为一种学习良好实践的语言，因此可以认为这是具有讽刺意味的。</p><p> The code for the  roman function is very procedural in that it is relentlessly imperative and control-flow oriented. Even as a procedural solution, however, it is not a particularly good one. It is repetitive, clumsy and lacking in abstraction.</p><p> 罗马函数的代码具有很高的过程性，因为它是无懈可击的命令，并且面向控制流。但是，即使作为一种程序解决方案，也不是一个特别好的解决方案。它是重复的，笨拙的并且缺乏抽象性。</p><p> If, however, we look at this code as a stepping stone rather than as an end state, it becomes an example and opportunity — especially in the presence of tests — rather than a counterexample and dead end. This latitude is perhaps a generosity we should extend to most code. Unless, like Romans chiselling words and numerals onto buildings, you are setting your code into stone, it may always be best to consider code a work in progress.</p><p> 但是，如果我们将此代码视为垫脚石，而不是最终状态，那么它将成为一个示例和机会（尤其是在存在测试的情况下），而不是一个反例和死胡同。这种宽容也许是我们应该扩展到大多数代码的慷慨之举。除非像罗马人在建筑物上凿凿单词和数字一样，将代码固定在石头上，否则最好将代码视为正在进行中的工作。 </p><p> In the eyes of those who anxiously seek perfection, a work is never truly completed — a word that for them has no sense — but abandoned; and this abandonment, of the book to the fire or to the public, whether due to weariness or to a need to deliver it for publication, is a sort of accident, comparable to the letting-go of an idea that has become so tiring or annoying that one has lost all interest in it.</p><p>在渴望追求完美的人们的眼中，一项工作从未真正完成过-对他们来说这是没有道理的-而是被放弃了。而且，由于厌倦或需要将其交付出版而将书抛向火中或向公众公开，是一种偶然的事件，相当于松散了已经很累的想法或令人讨厌的是，人们对此失去了所有兴趣。</p><p>  Recurrent structure is often a good starting point for seeing what can be abstracted. At first glance, the rhythmic stanza of a  while followed by three  if statements looks like a good fulcrum from which to lever a refactoring:</p><p>  循环结构通常是了解可以抽象的内容的良好起点。乍一看，一段有节奏的节，然后是三个if语句，看起来像是一个很好的支点，可以用来重构：</p><p> while number &gt;= 1000:  result += &#34;M&#34;  number -= 1000 if number &gt;= 900:  result += &#34;CM&#34;  number -= 900 if number &gt;= 500:  result += &#34;D&#34;  number -= 500 if number &gt;= 400:  result += &#34;CD&#34;  number -= 400</p><p> 而数字＆gt; = 1000：结果+ =＆＃34; M＆＃34;如果数字＆=; = 900，则数字-= 1000：结果+ =＆＃34; CM＆＃34;如果数字＆=; = 500，则数字-= 900：结果+ =＆＃34; D＆＃34;如果数字＆=; = 400，则数字-= 500：结果+ =＆＃34; CD＆＃34;数-= 400</p><p> The structure of this fragment for 1000, 900, 500 and 400 is repeated for 100, 90, 50 and 40 and then again for 10, 9, 5 and 4. But refactoring based on this recurrence misses a deeper duplication and, therefore, unification.</p><p> 此片段在1000、900、500和400中的结构在100、90、50和40中重复，然后在10、9、5和4中重复。但是，基于这种重复进行的重构错过了更深的重复，因此无法统一。</p><p> Consider, first, what is a  while statement? It is a statement that, governed by a condition, executes zero to many times. What, then, is an  if statement? It is a statement that, governed by a condition, executes zero times or once. Squinted at just right, an  if can be considered a bounded case of a  while.</p><p> 首先考虑一下什么是while语句？这是一条由条件控制的语句，执行次数为零到很多次。那么，if语句是什么？这是一条由条件控制的语句，执行零次或一次。恰到好处地斜着看，一个if可以看作是一段时间的有限情况。</p><p> Looking at the specific numbers and operations involved, we see the following  while-only code is equivalent to the previous mix of  while and  if code:</p><p> 查看所涉及的特定数字和操作，我们看到以下仅while代码等效于while和if代码的先前混合：</p><p> while number &gt;= 1000:  result += &#34;M&#34;  number -= 1000 while number &gt;= 900:  result += &#34;CM&#34;  number -= 900 while number &gt;= 500:  result += &#34;D&#34;  number -= 500 while number &gt;= 400:  result += &#34;CD&#34;  number -= 400</p><p> 而数字＆gt; = 1000：结果+ =＆＃34; M＆＃34;数字-= 1000，而数字＆gt; = 900：结果+ =＆＃34; CM＆＃34;数字-= 900，而数字＆gt; = 500：结果+ =＆＃34; D＆＃34;数字-= 500，而数字＆gt; = 400：结果+ =＆＃34; CD＆＃34;数-= 400 </p><p> The newly minted  while statements will execute zero times or once, just like their  if antecedents. There is no change in behaviour, but there is a huge change in how we perceive the problem and the shape and nature of what we want to refactor. We now have thirteen loops that look like</p><p>新创建的while语句将执行零次或一次，就像它们的前提一样。行为没有改变，但是我们对问题的理解以及我们要重构的事物的形状和性质发生了巨大变化。现在我们有十三个循环，看起来像</p><p>  What matters most to the solution is the series of threshold values and their corresponding letters. This is not a control-flow problem: it is a data problem. We need data structure, not control structure:</p><p>  对解决方案最重要的是一系列阈值及其对应的字母。这不是控制流问题：它是数据问题。我们需要数据结构，而不是控制结构：</p><p> def roman(number):  numerals = [  [1000, &#34;M&#34;], [900, &#34;CM&#34;],  [500, &#34;D&#34;], [400, &#34;CD&#34;],  [100, &#34;C&#34;], [90, &#34;XC&#34;],  [50, &#34;L&#34;], [40, &#34;XL&#34;],  [10, &#34;X&#34;], [9, &#34;IX&#34;],  [5, &#34;V&#34;], [4, &#34;IV&#34;],  [1, &#34;I&#34;]  ]  result = &#34;&#34;  for divisor, letters in numerals:  result += (number // divisor) * letters  number %= divisor  return result</p><p> def roman（number）：数字= [[1000，＆＃34; M＆＃34;]，[900，＆＃34; CM＆＃34;]，[500，＆＃34; D＆＃34;]，[400 ，＆＃34; CD＆＃34;]，[100，＆＃34; C＆＃34;]，[90，＆＃34; XC＆＃34;]，[50，＆＃34; L＆＃34;]， [40，＆＃34; XL＆＃34;]，[10，＆＃34; X＆＃34;]，[9，＆＃34; IX＆＃34;]，[5，＆＃34; V＆＃34; ]，[4，＆＃34; IV＆＃34;]，[1，＆＃34; I＆＃34;]]结果=＆＃34;＆＃34;对于除数，数字中的字母：result + =（数字//除数）*字母数字％=除数返回结果</p><p> This version still qualifies as procedural, but it is more declarative than the first version, which was strictly imperative.</p><p> 此版本仍然符合程序性要求，但比起绝对必要的第一个版本更具声明性。</p><p> Data-driven approaches separate data from the code that is driven by the data, with the effect of making both intent and structure clearer.  Niklaus Wirth stated that  Algorithms + Data Structures = Programs, but algorithm and data structure are not necessarily equal partners. As Fred Brooks noted, in  The Mythical Man Month under the heading  Representation Is the Essence of Programming:</p><p> 数据驱动方法将数据与由数据驱动的代码分开，从而使意图和结构都更加清晰。 Niklaus Wirth指出算法+数据结构=程序，但是算法和数据结构不一定是平等的伙伴。正如弗雷德·布鲁克斯（Fred Brooks）所指出的那样，在“神话人物月”中，在“表示形式”标题下是编程的本质：</p><p> Sometimes the strategic breakthrough will be a new algorithm […]. Much more often, strategic breakthrough will come from redoing the representation of the data or tables. This is where the heart of the program lies. Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.</p><p> 有时，战略突破将是一种新算法[…]。通常，战略突破将来自重做数据或表的表示。这就是程序的核心所在。告诉我您的流程图并隐藏您的表格，我将继续感到困惑。告诉我您的表格，通常不需要您的流程图；他们很明显。</p><p> We are more likely to code control flow directly than chart it, but that serves to highlight that while some things in the world of programming change, there is nothing new in letting the data do the talking. This family of approaches, from lookup tables to table-driven code, finds expression across many paradigms and contexts — the data-driven tests for  roman already shown, for example — but is often overlooked. This way of thinking is either not taught fully and explicitly or, in the case of less capable languages like Pascal, cannot always be expressed conveniently.</p><p> 我们更可能直接对控制流进行编码，而不是对其进行图表处理，但这可以凸显出，尽管编程领域的某些事情发生了变化，但让数据进行交流并没有什么新意。从查找表到表驱动的代码，这一系列方法可以在许多范式和上下文中找到表达式-例如，已经显示了针对罗马的数据驱动测试-但常常被忽略。这种思维方式要么没有被完全明确地讲授，要么在诸如Pascal之类的能力较弱的语言中，总是不能方便地表达出来。 </p><p>  There’s (a lot) more that we could do to explore the algorithmic space and paradigm shapes of the Roman numerals problem, such as transforming the loop into a fold operation ( reduce in Python) or eliminating the arithmetic and expressing the solution using term rewriting (converting to  unary and then using  replace), but for now we’ll leave the control flow in place so we can take off in a different direction to explore the organisation of the code elements.</p><p>我们还可以做更多的工作来探索罗马数字问题的算法空间和范式形状，例如将循环转换为折叠操作（在Python中简化），或者消除算术并使用术语重写表示解决方案（转换为一元代码，然后使用replace），但现在我们将控制流保留在原处，以便我们可以从另一个方向出发探索代码元素的组织。</p><p> Because the  numerals table doesn’t change and is independent of the  number parameter, we can implement invariant code motion to hoist it out of the function:</p><p> 由于数字表不变，并且与number参数无关，因此我们可以实现不变的代码运动以将其提升到函数之外：</p><p> numerals = [  [1000, &#34;M&#34;], [900, &#34;CM&#34;],  [500, &#34;D&#34;], [400, &#34;CD&#34;],  [100, &#34;C&#34;], [90, &#34;XC&#34;],  [50, &#34;L&#34;], [40, &#34;XL&#34;],  [10, &#34;X&#34;], [9, &#34;IX&#34;],  [5, &#34;V&#34;], [4, &#34;IV&#34;],  [1, &#34;I&#34;] ]  def roman(number):  result = &#34;&#34;  for divisor, letters in numerals:  result += (number // divisor) * letters  number %= divisor  return result</p><p> 数字= [[1000，＆＃34;]，[900，＆＃34; CM＆＃34;]，[500，＆＃34; D＆＃34;]，[400，＆＃34; CD＆ ＃34;]，[100，＆＃34; C＆＃34;]，[90，＆＃34; XC＆＃34;]，[50，＆＃34; L＆＃34;]，[40，＆＃34 ; XL＆＃34;]，[10，＆＃34; X＆＃34;]，[9，＆＃34; IX＆＃34;]，[5，＆＃34; V＆＃34;]，[4，＆ ＃34; IV＆＃34;]，[1，＆＃34; I＆＃34;]] def roman（number）：结果=＆＃34;＆＃34;对于除数，数字中的字母：result + =（数字//除数）*字母数字％=除数返回结果</p><p> We can add further distance to this separation by placing the definition of  numerals into another source file,  numerals.py:</p><p> 我们可以通过将数字的定义放入另一个源文件digits.py中来进一步增加这种距离：</p><p> numerals = [  [1000, &#34;M&#34;], [900, &#34;CM&#34;],  [500, &#34;D&#34;], [400, &#34;CD&#34;],  [100, &#34;C&#34;], [90, &#34;XC&#34;],  [50, &#34;L&#34;], [40, &#34;XL&#34;],  [10, &#34;X&#34;], [9, &#34;IX&#34;],  [5, &#34;V&#34;], [4, &#34;IV&#34;],  [1, &#34;I&#34;] ]</p><p> 数字= [[1000，＆＃34;]，[900，＆＃34; CM＆＃34;]，[500，＆＃34; D＆＃34;]，[400，＆＃34; CD＆ ＃34;]，[100，＆＃34; C＆＃34;]，[90，＆＃34; XC＆＃34;]，[50，＆＃34; L＆＃34;]，[40，＆＃34 ; XL＆＃34;]，[10，＆＃34; X＆＃34;]，[9，＆＃34; IX＆＃34;]，[5，＆＃34; V＆＃34;]，[4，＆ ＃34; IV＆＃34;]，[1，＆＃34; I＆＃34;]]</p><p>  from numerals import numerals  def roman(number):  result = &#34;&#34;  for divisor, letters in numerals:  result += (number // divisor) * letters  number %= divisor  return result</p><p>  从数字导入数字def roman（数字）：结果=＆＃34;＆＃34;对于除数，数字中的字母：result + =（数字//除数）*字母数字％=除数返回结果</p><p> Perhaps not for this particular problem, but this is an interesting decoupling because — as long as the data’s structure is consistent — it allows us to change the actual data independently of the algorithm. We are using the Python in  numerals.py as a data language, which, in effect, makes  numerals.py a native database. Another way of looking at the separation is that the code in  roman.py implements an interpreter for the highly domain-specific data language of  numerals.py.</p><p> 也许不是针对这个特定问题，但这是一个有趣的解耦，因为-只要数据的结构是一致的-它使我们能够独立于算法来更改实际数据。我们正在使用numerics.py中的Python作为数据语言，实际上，它使digits.py成为本机数据库。另一种看待这种分离的方式是roman.py中的代码实现了针对digits.py的高度特定于域的数据语言的解释器。 </p><p>  This leads us to ponder — and not for either the first or the last time in the history of computer science — the distinction between code and data. We stumble across this question even in the simplest cases. How would you describe the refactoring transformations above? Many would describe them in terms of separating the data from the code. Does that mean, then, that  numerals.py contains data but not code? It’s a valid Python module that initialises a variable to a list of string–integer pairs. Sounds like code. Nothing says an essential qualification for something to be considered code is the presence of control flow.</p><p>这导致我们要思考代码和数据之间的区别，而不是计算机科学历史上的第一次或最后一次。即使在最简单的情况下，我们也遇到了这个问题。您如何描述上面的重构转换？许多人将数据与代码分离来描述它们。那么，这是否意味着digits.py包含数据但不包含代码？这是一个有效的Python模块，可将变量初始化为字符串-整数对的列表。听起来像代码。没有什么说要被认为是代码的必要条件是控制流的存在。</p><p> We use the word  code freely, referring both to anything written in a programming language and, more specifically, to code (sic) whose primary concern is algorithm and operation rather than data structure and definition. Natural language is messy like that, filled with ambiguity, synecdoche and context dependency.</p><p> 我们自由地使用“代码”一词，既指用编程语言编写的任何内容，更具体地说，指的是主要关注算法和运算而不是数据结构和定义的代码（原文如此）。自然语言是如此混乱，充满了歧义，句法和上下文依赖。</p><p> If we want to be more rigorous, we could say that we have separated the code into code that abstracts operation and code that abstracts data. In other words, we are saying that  Programs = Code and, given that  Algorithms + Data Structures = Programs, therefore  Algorithms + Data Structures = Code. This can be convenient and clear way to frame our thinking and describe what we have done. We also need to recognise, however, that it is just that: it is a thinking tool, a way of looking at things and reasoning about them rather than necessarily a comment on the intrinsic nature of those things; it is a tool for description, a way of rendering abstract concepts more concretely into conversation.</p><p> 如果我们想更加严格，可以说我们已经将代码分为抽象化操作的代码和抽象化数据的代码。换句话说，我们说的是程序=代码，并且假设算法+数据结构=程序，因此算法+数据结构=代码。这可能是方便而清晰的方式来构架我们的思想并描述我们所做的事情。但是，我们还需要认识到，仅仅是这样：它是一种思维工具，一种看待事物并对其进行推理的方式，而不必评论这些事物的内在本质。它是一种描述工具，是一种将抽象概念更具体地呈现到对话中的方法。</p><p> If we confuse a point of view for the nature of things we will end up with a dichotomy that feels like Cartesian dualism. Just as Descartes claimed there were two distinct kinds of substance, physical and mental, we could end up claiming there are two distinct kinds of code — code that is data and code that is operation.</p><p> 如果我们将事物的本质的观点弄混了，我们最终会感到二分法，就像笛卡尔二元论。正如笛卡尔声称存在两种不同的物质，即物理的和精神的，我们最终可以声称存在两种截然不同的代码，即数据代码和操作代码。</p><p> When we look to hardware, compilers or the foundations of computer science, such as Turing machines, we will not find clear support or a strict boundary for such separation. The indistinction runs deep. Although we have code and data segments in a process address, these enforce negotiable matters of convention and protection (e.g., the code or text segment is often read-only). Both code and data segments contain data, but the data in the code segment is intended to be understood through a filter of predefined expectations and an instruction set. On the other hand, it is also possible to treat data in the data segment as something to execute.</p><p> 当我们关注硬件，编译器或计算机科学的基础（例如图灵机）时，我们不会为此类分离找到明确的支持或严格的界限。歧义深入。尽管我们在过程地址中有代码段和数据段，但这些段强制执行约定和保护的可商谈事项（例如，代码段或文本段通常是只读的）。代码段和数据段都包含数据，但是代码段中的数据旨在通过预定义期望和指令集的过滤器来理解。另一方面，也可以将数据段中的数据视为要执行的内容。</p><p> The fundamental conceit of the Lisp programming language is that everything can be represented and manipulated as lists, including code. The Lisp perspective can be summarised as  Data Structures = Programs. For some languages, source code is data for a compiler, that in turn generates data for a machine — physical or virtual — to execute. For other languages, such as Python, source code is a string that can be interpreted and executed more directly. We can blur that code–data boundary explicitly in our example as follows:</p><p> Lisp编程语言的基本思想是，所有内容都可以表示为列表，包括代码在内都可以作为列表进行操作。 Lisp的观点可以概括为“数据结构=程序”。对于某些语言，源代码是供编译器使用的数据，而编译器又会为物理或虚拟机生成数据以供执行。对于其他语言，例如Python，源代码是可以更直接地解释和执行的字符串。在示例中，我们可以明确地模糊代码-数据边界，如下所示：</p><p> source = &#34;&#34;&#34;[  [1000, &#34;M&#34;], [900, &#34;CM&#34;],  [500, &#34;D&#34;], [400, &#34;CD&#34;],  [100, &#34;C&#34;], [90, &#34;XC&#34;],  [50, &#34;L&#34;], [40, &#34;XL&#34;],  [10, &#34;X&#34;], [9, &#34;IX&#34;],  [5, &#34;V&#34;], [4, &#34;IV&#34;],  [1, &#34;I&#34;] ]&#34;&#34;&#34;  numerals = eval(source)</p><p> 来源=＆＃34;＆＃34;＆＃34; [[1000，＆＃34; M＆＃34;]，[900，＆＃34; CM＆＃34;]，[500，＆＃34; D＆＃ 34;]，[400，＆＃34; CD＆＃34;]，[100，＆＃34; C＆＃34;]，[90，＆＃34; XC＆＃34;]，[50，＆＃34; L＆＃34;]，[40，＆＃34; XL＆＃34;]，[10，＆＃34; X＆＃34;]，[9，＆＃34; IX＆＃34;]，[5，＆＃ 34; V＆＃34;]，[4，＆＃34; IV＆＃34;]，[1，＆＃34; I＆＃34;]]＆＃34;＆＃34;数字= eval（源） </p><p> The dualism we are grappling with here is not the strict categorisation of things that are intrinsically separate, but the dualism of things that are innately bound together. A yin and yang of complementary perspectives that we are forcing into competition, but that exist in a  cat state as easily resolved one way as the other. Which one we see or chose is a question of observation and of desire and of the moment rather than one of artefact.</p><p>我们在这里要解决的二元论不是对本质上分离的事物的严格分类，而是对本来就捆绑在一起的事物的二元论。我们强迫竞争的阴阳互补的观点，但它们以猫的状态存在，并且容易以另一种方式解决。我们看到或选择的是观察问题，欲望和当前问题，而不是人工制品。</p><p>   Instead of involving intermediate variables and conversions, we could simply replace  numerals.py with a file that contains just the data expression, no statements:</p><p>   不用涉及中间变量和转换，我们可以简单地用一个仅包含数据表达式而不包含语句的文件替换digits.py：</p><p> [  [1000, &#34;M&#34;], [900, &#34;CM&#34;],  [500, &#34;D&#34;], [400, &#34;CD&#34;],  [100, &#34;C&#34;], [90, &#34;XC&#34;],  [50, &#34;L&#34;], [40, &#34;XL&#34;],  [10, &#34;X&#34;], [9, &#34;IX&#34;],  [5, &#34;V&#34;], [4, &#34;IV&#34;],  [1, &#34;I&#34;] ]</p><p> [[1000，＆＃34;]，[900，＆＃34; CM＆＃34;]，[500，＆＃34; D＆＃34;]，[400，＆＃34; CD＆＃34 ;]，[100，＆＃34; C＆＃34;]，[90，＆＃34; XC＆＃34;]，[50，＆＃34; L＆＃34;]，[40，＆＃34; XL＆ ＃34;]，[10，＆＃34; X＆＃34;]，[9，＆＃34; IX＆＃34;]，[5，＆＃34; V＆＃34;]，[4，＆＃34 ; IV＆＃34;]，[1，＆＃34; I＆＃34;]]</p><p> Although a valid Python expression, this is no longer a useful Python module. The data is not bound to a variable that can be referenced elsewhere. It does, however, bear a striking resemblance to a more widely recognised data language: JSON.</p><p> 尽管是有效的Python表达式，但它不再是有用的Python模块。数据未绑定到可在其他位置引用的变量。但是，它确实与更广泛认可的数据语言JSON非常相似。</p><p> with open(&#34;numerals.json&#34;) as source:  numerals = eval(source.read())  def roman(number):  result = &#34;&#34;  for divisor, letters in numerals:  result += (number // divisor) * letters  number %= divisor  return result</p><p> 使用open（＆＃34; numerals.json＆＃34;）作为源：数字= eval（source.read（））def罗马（数字）：result =＆＃34;＆＃34;对于除数，数字中的字母：result + =（数字//除数）*字母数字％=除数返回结果</p><p> If you had wondered why I’d avoided using tuples and single-quoted strings in the code so far, you now have your answer: looked at the right way, JSON is almost a proper subset of Python. (If you hadn’t, no worries. As you were.) The relationship becomes closer and the observation truer if you replace the previous  eval expression with the following:</p><p> 如果您想知道到目前为止为什么我在代码中避免使用元组和单引号字符串，那么您将得到答案：以正确的方式看，JSON几乎是Python的适当子集。 （如果没有，就不用担心。就像以前一样。）如果用以下内容替换以前的eval表达式，则关系会更紧密，观察更真实：</p><p>  Of course, this lets more through than just valid JSON, which may make you feel — justifiably — a little uncomfortable. We can more fully acknowledge and safeguard the transformation by replacing the permissive and general  eval with something more constrained and specific:</p><p>  当然，这不仅使有效的JSON通过，还可以使您感到有理由感到不舒服。我们可以通过使用更受约束和更具体的内容来代替许可的和普遍的评估，从而更充分地认识和维护这种转变： </p><p>   Looking at the progression of code above, evolving from the first tabular version to the final JSON version, at what point in the transformation did the table stop being code and start becoming configuration?</p><p>查看上面代码的进展，从第一个表格版本发展到最终的JSON版本，在转换的什么时候该表停止成为代码并开始成为配置？</p><p> This is, to some extent, a trick question, but that is also the point. We’re not done with dualism, ambiguity and perspective. The question serves to highlight a common blind spot and oversight: configuration is code. Treating configuration as disjoint from the concept of code steers us in the wrong direction. Treating it as something other often leads to it being treated as something lesser.</p><p> 从某种程度上讲，这是一个棘手的问题，但这也是重点。我们没有二元论，歧义和观点。该问题旨在突出一个常见的盲点和监督：配置就是代码。将配置与代码概念脱节，将我们引向错误的方向。将其视为其他事物通常会导致将其视为次要事物。</p><p> What, then, is configuration? It is a formal structure for specifying how some aspect of software should run. Sounds like code. It doesn’t matter whether configuration is defined in key–value pairs or a Turing-complete language, whether it uses an ad hoc proprietary binary format or a widely used and recognised text-based one, if a software system does not behave as expected, we consider it a problem. Whether that problem originated in a JSON payload, a registry setting, a database, an environment variable or the source code is not relevant: the software is seen as not working — there is a bug to be fixed.</p><p> 那么，配置是什么？它是一个正式的结构，用于指定软件应如何运行。听起来像代码。如果软件系统的运行不符合预期，则配置是以键值对还是图灵完备的语言定义，使用临时专有二进制格式还是使用广泛使用且公认的基于文本的格式都无所谓，我们认为这是一个问题。该问题是否源于JSON有效负载，注册表设置，数据库，环境变量或源代码均无关紧要：该软件被视为无法正常工作-有一个错误需要修复。</p><p> The consequences of incorrect configuration range from the personal inconvenience of having your settings trashed when an app updates to the more costly  failure of a rocket launch. Configuration is no less a detail than any other aspect of a software system. Its common second-class citizenship, however, causes it to be accorded less respect and visibility, leading to a high incidence of  latent configuration errors. If we consider it as code we are more likely to consider version control, testing, reviewing, design, validation, maintainability and other qualities and practices we normally confer on other parts of our codebase but may overlook for configuration.</p><p> 错误配置的后果包括因个人不便而导致的不便，即在应用程序更新时浪费您的设置，以及因火箭发射失败而造成的损失更大。配置不亚于软件系统的任何其他方面。但是，其常见的二等公民身份使其受到的尊重和可见度降低，从而导致大量潜在的配置错误。如果我们将其视为代码，则我们更有可能考虑版本控制，测试，审阅，设计，验证，可维护性以及我们通常在代码库其他部分授予的其他质量和实践，但可能会忽略配置。</p><p>  Whether you find yourself exploring TDD with Roman numerals, playing with the  Gilded Rose refactoring kata, casting an intricate set of constraints into code or trying to crack the code of a legacy logic tangle, inverting the problem with resp</p><p>  无论您是发现自己使用罗马数字探索TDD，还是使用Gilded Rose重构套件，将复杂的约束条件转换为代码，还是试图破解传统逻辑缠结的代码，从而通过resp来解决问题</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kevlinhenney.medium.com/out-of-control-97ed6efa2818">https://kevlinhenney.medium.com/out-of-control-97ed6efa2818</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/失控/">#失控</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/control/">#control</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>