<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>React的UseRef深潜 React's UseRef Deep Dive</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">React's UseRef Deep Dive<br/>React的UseRef深潜 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-17 20:04:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/4bbf342baf8d1f08f73dd1ea979bc82a.png"><img src="http://img2.diglog.com/img/2020/12/4bbf342baf8d1f08f73dd1ea979bc82a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>useRef allows you to keep a mutable value within a component, similar to  useState or instance variables on a class, without triggering re-renders.</p><p>useRef允许您在组件内保留可变值，类似于useState或类中的实例变量，而无需触发重新渲染。</p><p>  function  RefButton  ( )  {  const clicks  =  useRef ( 0 )  return  (    Clicks:  {clicks .current }     ) }</p><p>  函数RefButton（）{const clicks = useRef（0）return（点击数：{clicks .current}）}</p><p> This is how this component looks like (I added a re-render button so you canactually test it out 😄):</p><p> 这是该组件的外观（我添加了一个重新渲染按钮，以便您可以实际测试它test）：</p><p> The example below is completely interactive, try clicking the &#34;Clicks&#34; button and then click on &#34;Re-render&#34;.</p><p> 下面的示例是完全交互式的，请尝试点击＆＃34; Clicks＆＃34;按钮，然后单击＆＃34;重新渲染＆＃34;。</p><p> As you can see, if you click the &#34;Clicks&#34; button it doesn&#39;t do anything. However, after click on &#34;Re-render&#34;, it gets updated with the number of clicks we did previously.</p><p> 如您所见，如果您单击＆＃34; Clicks＆＃34;按钮，它什么也不做。但是，点击“重新渲染”后，它会根据我们之前的点击次数进行更新。</p><p>   let clicks  =  0 ; function  OutsideVariableButton ( )  {  return  (    Clicks:  {clicks }     ) }</p><p>   让点击= 0;函数OutsideVariableButton（）{return（点击数：{clicks}）}</p><p>   The button works the same way that our previous example. However, the problem arises when you have multiple instances of the same component like the example below. Try clicking just one of the buttons and then click on re-render to see the result.</p><p>   该按钮的工作方式与前面的示例相同。但是，当您具有同一组件的多个实例时，就会出现问题，如下例所示。尝试仅单击按钮之一，然后单击“重新渲染”以查看结果。 </p><p>  As you were able to see, the clicks are not isolated. In fact, all the examplesfrom this article uses the same button component, so if you click the buttonfrom the first example and then click on &#34;re-render&#34; on the second example, the count it is gonna beincremented! What a bug 🐛.</p><p>如您所见，点击并不是孤立的。实际上，本文中的所有示例都使用相同的按钮组件，因此，如果您单击第一个示例中的按钮，然后单击“重新渲染”。在第二个示例中，计数将增加！真是个臭虫🐛。</p><p>    The main difference between useState and useRef, is that useState triggers are-render and useRef doesn&#39;t.</p><p>    useState和useRef之间的主要区别是useState触发器是render，而useRef没有。</p><p> In the following example I added two buttons: one that updates its count with  useRef and the other one with  useState. I added some labels so you can identify them easily.</p><p> 在以下示例中，我添加了两个按钮：一个按钮使用useRef更新其计数，另一个按钮使用useState更新。我添加了一些标签，以便您可以轻松识别它们。</p><p>  You&#39;ll notice that clicking on the button with  useRef doesn&#39;t trigger a re-render and thus, the view isn&#39;t updated. On the other side, when you click on the button that uses  useState, it will update its clicks count immediately.</p><p>  您会注意到，单击带有useRef的按钮不会触发重新渲染，因此视图不会更新。另一方面，当您单击使用useState的按钮时，它将立即更新其点击计数。</p><p>  To perform imperative actions on DOM nodes, React provides a way to get areference to them via refs. All you have to do is to assign a  ref property toa node with a ref object like this:</p><p>  为了在DOM节点上执行命令性动作，React提供了一种通过ref获取对它们的引用的方法。您需要做的就是将ref属性分配给具有ref对象的节点，如下所示：</p><p>  The way to get a DOM reference using refs works (informally 😅) as follows:</p><p>  使用refs获取DOM引用的方法如下（非正式地称为😅）：</p><p>  On the first render,  inputRef&#39;s value will be  { current: null } and in thefollowing renders it will have its  current property assigned to the specified DOMnode:</p><p>  在第一个渲染中，inputRef的值将为{current：null}，在随后的渲染中，它将其current属性分配给指定的DOMnode： </p><p> // First render: { current: undefined } // Second render: { current: &lt;input /&gt; } // Third render: { current: &lt;input /&gt; } /// ...and so onconsole . log (inputRef )</p><p>//第一个渲染：{当前：未定义} //第二个渲染：{当前：＆lt; input /＆gt; } //第三次渲染：{当前：＆lt; input /＆gt; } /// ...等等onconsole。日志（inputRef）</p><p> However, if you only reference  inputRef inside  useEffect then it&#39;ll alwaysreference the DOM node so you don&#39;t need to worry about it being undefined.</p><p> 但是，如果仅在useEffect内引用inputRef，则它将始终引用DOM节点，因此您不必担心其未定义。</p><p>  function  AttachingToDomExample ( )  {  const inputRef  =  useRef ( ) console . log ( &#34;Render inputRef value:&#34; , inputRef )  useEffect ( ( )  =&gt; console . log ( &#34;useEffect inputRef value:&#34; , inputRef ) )  return   }</p><p>  函数AttachingToDomExample（）{const inputRef = useRef（）控制台。 log（＆＃34; Render inputRef value：＆＃34;，inputRef）useEffect（（）=＆gt; console。log（＆＃34; useEffect inputRef value：＆＃34;，inputRef））return}</p><p>   As you can see, if you access the  inputRef inside  useEffect then you don&#39;tneed to worry about it being  undefined because React will assign itautomatically for you.</p><p>   如您所见，如果您在useEffect中访问inputRef，则不必担心它是未定义的，因为React会自动为您分配它。</p><p>  Let&#39;s start with a simple real-world application for refs:  usePrevious. Thishook stores the previous value for a given state variable. It is even referenced on React&#39;s docs as a way to &#34;get the previous props or state&#34;. Let&#39;s see it inaction first:</p><p>  让我们从一个简单的引用现实应用开始：usePrevious。此钩子存储给定状态变量的先前值。它甚至在React的文档中被引用为获取先前道具或状态的一种方式。让我们首先看看它无所作为：</p><p> function  UsePreviousExample ( )  {  const  [clicks , setClicks ]  =  useState ( 0 )  // usePrevious is the important part here ✨  const previousClicks  =  usePrevious (clicks )  return  (       Clicks:  {clicks }  - Before:  {previousClicks }        ) }</p><p> 函数UsePreviousExample（）{const [clicks，setClicks] = useState（0）// usePrevious是此处的重要部分</p><p>   You can notice that the  previousClicks variable stores the value for the previous renderfor a given variable. Here&#39;s its implementation:</p><p>   您会注意到，previousClicks变量为给定变量存储了先前渲染的值。这是其实现： </p><p> function  usePrevious ( value )  {  const ref  =  useRef ( )  useEffect ( ( )  =&gt;  { ref .current  = value  } )  return ref .current }</p><p>函数usePrevious（value）{const ref = useRef（）useEffect（（）=> {ref .current = value}）返回ref .current}</p><p>  Let&#39;s simulate what happens on the first render. We can remove the call to useEffect since it doesn&#39;t affect the return value on the first render:</p><p>  让我们模拟一下第一次渲染时发生的情况。我们可以删除对useEffect的调用，因为它不会影响第一个渲染的返回值：</p><p>     // First render function  usePrevious ( value )  {  const ref  =  useRef ( )  return ref .current  // No assignment, so it&#39;s undefined }</p><p>     //第一个渲染函数usePrevious（value）{const ref = useRef（）return ref .current //没有赋值，因此未定义}</p><p>          Callback Refs are a different way to set refs. It gives you a fine-grain controlover when refs are attached and detached because you provide a function insteadof a ref variable. This function gets called every time the component mounts andunmounts.</p><p>          回调引用是设置引用的另一种方法。当附加和分离引用时，它可以为您提供细粒度的控制，因为您提供的是函数而不是引用变量。每次安装和卸载组件时都会调用此函数。</p><p> Here&#39;s an example that shows/hides an emoji every time you click its button.The important thing here is the  ref prop that we added. We use a function to logthe provided ref:</p><p> 这是一个示例，每单击一次它就会显示/隐藏一个表情符号。这里重要的是我们添加的ref prop。我们使用一个函数来记录提供的参考：</p><p> const  callback  =  ( ref )  =&gt; console . log ( &#34;callback:&#34; , ref ) function  App  ( )  {  const  [rerenders , setRerenders ]  =  useState ( 0 ) ;  return  (        {show  ?  &#34;Hide&#34;  :  &#34;Show&#34; }      {show  &amp;&amp;   👋  }     ) ; }</p><p> const callback =（ref）=＆gt;安慰 。 log（＆＃34; callback：＆＃34;，ref）函数App（）{const [rerenders，setRerenders] = useState（0）; return（{显示？＆＃34;隐藏＆＃34;：＆＃34; Show＆＃34;} {显示＆amp;＆amp ;;}）; }</p><p> Here&#39;s an interactive version of the previous code (you can check the output inthe console to see that I&#39;m not lying 🙃):</p><p> 这是先前代码的交互式版本（您可以在控制台中检查输出以查看我没有说谎🙃）： </p><p>  Note: If you use callback refs as inline functions, it will be calledtwice: one with  null and another one with the DOM element.This is because React needs to clear the previous ref every time the function iscreated. A workaround for this is to use a class method.</p><p>注意：如果将回调引用用作内联函数，则将其称为两次：一个为null，另一个为DOM元素，这是因为React每次创建函数时都需要清除以前的引用。一种解决方法是使用类方法。</p><p>  String refs are a legacy feature and they are likely to be removed in future React versions.</p><p>  字符串引用是一项传统功能，将来的React版本中可能会删除它们。</p><p> The way it works is that you provide a string as a ref value like  ref=&#34;exampleRef&#34; and it automatically gets assigned to  this.refs.</p><p> 它的工作方式是提供一个字符串作为ref值，例如ref =＆＃34; exampleRef＆＃34;。并自动将其分配给this.refs。</p><p>   export  default  class    extends    {  render ( )  { console . log ( this .refs ) ;  return  (      Re-render      ) ;  } }</p><p>   导出默认类扩展{render（）{控制台。日志（this .refs）;返回（重新渲染）; }}</p><p>   As you can see, on the first render  this.refs.exampleRef will be undefined andon the following renders it will point out to the specified DOM node.</p><p>   如您所见，在第一个渲染中，this.refs.exampleRef将是未定义的，在随后的渲染中，它将指向指定的DOM节点。</p><p>  We saw what  useRef is, how it differentiates with a plain old variable andstate variables, and we saw real world examples that uses it. I hope that mostof the content makes sense to you!</p><p>  我们看到了useRef是什么，它如何与普通的旧变量和状态变量区分开，并且看到了使用它的实际示例。希望大多数内容对您有意义！</p><p> I&#39;d love to hear your feedback. You can  reach out to me onTwitter at any time :-)</p><p> 我很想听听您的意见。您可以随时在Twitter上与我联系：-) </p><p>  Written by  Giovanni Benussi a frontend developer interested in React, Open Source, and writing good plain HTML and CSS.  You can follow him on Twitter.</p><p>由前端开发人员Giovanni Benussi撰写，他对React，Open Source感兴趣，并编写了很好的普通HTML和CSS。 您可以在Twitter上关注他。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.giovannibenussi.com/blog/a-complete-guide-to-useref/?id=1">https://www.giovannibenussi.com/blog/a-complete-guide-to-useref/?id=1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/useref/">#useref</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ref/">#ref</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>