<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>当过多的并发性降低您的速度时(Golang)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">当过多的并发性降低您的速度时(Golang)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 09:37:04</div><div class="page_narrow text-break page_content"><p>Merge Sort is one of those classic “divide and conquer” algorithms you study in your freshman year in CS, and for me it was one of the best tools for developing an intuitive sense for recursion and O(nlog(n)) complexity.</p><p>合并排序是您在CS课程大一学习的经典“分而治之”算法之一，对我来说，它是培养对递归和O(nlog(N))复杂性的直观感觉的最佳工具之一。</p><p> In this writeup we’re going to check out a naive concurrent version of MergeSort in Go, and then using Go’s easy benchmarking tools, we’re going to see what’s wrong with it, and then apply a simple fix.</p><p>在这篇文章中，我们将检查Go中MergeSort的一个简单的并发版本，然后使用Go的简单基准测试工具，我们将查看它的问题所在，然后应用一个简单的修复。</p><p> In case you are not familiar with the algorithm, here’s a great explanation in Harvard’s CS50.tv channel:</p><p>如果你不熟悉这个算法，在哈佛的CS50.tv频道上有一个很好的解释：</p><p>  The bas ic idea is this: first, like every recursive idea, we assume we have the solution in hand and we apply it to smaller subsets of the input. In our case a function called “MergeSort”. We then apply MergeSort to a subset of the input: we split the original slice in half, and we feed the left and the right parts to the same function.</p><p>基本思想是这样的：首先，像每个递归思想一样，我们假设我们手头有解决方案，并将其应用于输入的较小子集。在我们的例子中，有一个名为“MergeSort”的函数。然后，我们将MergeSort应用于输入的子集：我们将原始切片一分为二，并将左侧和右侧部分提供给相同的函数。</p><p> Now we assume that we have in hand two sorted slices, the left part and the right one, and we need to merge them (the fun part).</p><p>现在我们假设手中有两个排序的切片，左边和右边，我们需要合并它们(有趣的部分)。</p><p>  The merge function therefore acts to merge two sorted slices: the idea here is to compare the first element from the left to the one on the right. Then, depending on the desired sort order (asc or desc), we take the larger (or smaller) of the two and append it to the result. Every time we do that, we truncate the section from which we took the element we appended (so if we took the element from the left, the left slice now has one less element), until we are left with 0 elements there.</p><p>因此，Merge函数用于合并两个排序的切片：这里的想法是将左侧的第一个元素与右侧的第一个元素进行比较。然后，根据所需的排序顺序(asc或desc)，我们取两者中较大(或较小)的一个，并将其附加到结果中。每次这样做时，我们都会截断从中获取附加元素的部分(因此，如果我们从左侧获取元素，那么左边的片段现在少了一个元素)，直到那里只剩下0个元素。</p><p>   The MergeSort function above can be easily introduced with some concurrency goodness. On lines 13–14, we have:</p><p>上面的MergeSort函数可以很容易地引入，并且具有一定的并发性。在第13-14行，我们有：</p><p>  What’s this? synchronous computes? This calls for some goroutines! Let’s rewrite MergeSort with some concurrency, call it MergeSortMulti:</p><p>这是什么？同步计算？这需要一些大猩猩程序！让我们用某种并发性重写MergeSort，称之为MergeSortMulti：</p><p>  Simple enough. For every step of the recursion, we’re going to fire up a goroutine to handle the computation asynchronously. We then wait for the computation to finish on both parts of the slice (this happens concurrently) and merge the result.</p><p>很简单。对于递归的每一步，我们都将启动一个Goroutine来异步处理计算。然后，我们等待切片的两个部分的计算完成(这是同时进行的)，并合并结果。</p><p> Surely this is faster, right? We don’t have to wait for the first recursion to end before we begin with the second one.  Wrong!</p><p>这样肯定会更快，对吧？我们不必等到第一次递归结束后才开始第二次递归。不对!。</p><p>  Benchmarking MergeSort vs MegeSortMulti reveals that the former, synchronous version, performs about 14 times faster than the concurrent one. Here’s the benchmarking code for a million elements in the slice:</p><p>基准测试MergeSort与MegeSortMulti显示，前者，即同步版本，执行速度大约是并发版本的14倍。以下是切片中一百万个元素的基准测试代码：</p><p>  It reveals that the concurrent version is a lot slower than the normal synchronous version:</p><p>它显示并发版本比正常同步版本慢得多：</p><p>  What’s going on? Well, it looks like in our quest to make the computation concurrent, we are firing goroutines like crazy. For each step of the recursion, we fire two goroutines. This ends up generating millions of goroutines fighting over the CPU with go’s goroutine queueing mechanism. The result is slower code.</p><p>到底怎么回事？看起来，在我们寻求使计算并发的过程中，我们正在疯狂地激发大猩猩程序。对于递归的每一步，我们触发两个Goroutine。这最终会产生数百万个使用GO的Goroutine排队机制争夺CPU的Goroutine。结果是代码变慢了。</p><p>  So how can we gain the performance benefits of concurrent code without setting up a shower of goroutines? Well, one nice way to limit concurrency in go is by using a  Buffered Channel Semaphore. Buffered channels in go are a nice and easy way to block execution based on the number of concurrent units of actions we want to have.</p><p>那么，我们如何才能在不设置大量Goroutine的情况下获得并发代码的性能优势呢？嗯，在GO中限制并发性的一个很好的方法是使用缓冲的通道信号量。Go中的缓冲通道是根据我们希望拥有的并发操作单元的数量来阻止执行的一种很好且简单的方法。</p><p> We set a buffered channel with a capacity of 100, and when we spawn the goroutines to perform the asynchronous computation, we revert to using the synchronous version of MergeSort if there are already 100 workers (goroutines) busy with the computation:</p><p>我们设置一个容量为100的缓冲通道，当我们产生goroutines以执行异步计算时，如果已经有100个工作者(Goroutines)忙于计算，我们将恢复使用MergeSort的同步版本：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/@_orcaman/when-too-much-concurrency-slows-you-down-golang-9c144ca305a">https://medium.com/@_orcaman/when-too-much-concurrency-slows-you-down-golang-9c144ca305a</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/降低/">#降低</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/slows/">#slows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>