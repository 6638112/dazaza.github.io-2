<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于编译时函数评估和类型系统的思考 Thoughts on Compile-Time Function Evaluation and Type Systems</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Thoughts on Compile-Time Function Evaluation and Type Systems<br/>关于编译时函数评估和类型系统的思考 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-13 06:12:48</div><div class="page_narrow text-break page_content"><p>For some time now (since the 1.26 release, to be precise), Rust has a  very powerful machinery for CTFE, or compile-time function evaluation.Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE.This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view.Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.</p><p>从现在的1.26版本开始，Rust拥有了非常强大的CTFE或编译时函数评估机制，从那时起，人们就CTFE期间应允许哪些操作进行了各种讨论，哪些检查编译器应该做什么，这与促销有什么关系，以及我们在CTFE方面可以期望得到什么样的保证。这篇文章是我对这些主题的看法，而我将采用这样的类型也就不足为奇了：以系统为中心的视图：期望像结构化的人才转移之类的东西，所以在最后也有一些未解决的问题。</p><p>  CTFE is the mechanism used by the compiler, primarily, to evaluate items like  const x: T = ...;.The  ... here is going to be Rust code that must be “run” at compile-time, because it can be used as a constant in the code – for example, it can be used for array lengths.</p><p>  CTFE是编译器用来评估诸如const x：T = ...;之类的项目的机制。这里的...将是Rust代码，必须在编译时“运行”，因为它可以在代码中用作常量–例如，可以用于数组长度。</p><p> Notice that CTFE is  not the same as constant propagation: Constant propagation is an optimization pass done by compilers like LLVM that will opportunistically change code like  3 + 4 into  7 to avoid run-time work.Being an optimization, constant propagation must, by definition, not change program behavior and will not be observable at all (other than performance).CTFE, on the other hand, is about code that  must be executed at compile-time because the compiler needs to know its result to proceed – for example, it needs to know the size of an array to compute how to lay out data in memory.You can statically see, just from the syntax of the code, whether CTFE applies to some piece of code or not:CTFE is only used in places like the value of a  const or the length of an array.</p><p> 注意CTFE与常量传播不同：常量传播是由LLVM之类的编译器完成的优化过程，它将机会性地将3 + 4之类的代码更改为7，以避免运行时工作。 ，而不改变程序的行为，并且根本无法观察到（性能除外）。另一方面，CTFE涉及必须在编译时执行的代码，因为编译器需要知道其结果才能继续执行-例如，它需要知道数组的大小来计算如何在内存中布置数据。仅从代码的语法就可以静态地看到CTFE是否适用于某些代码：CTFE仅用于类似const的值或数组的长度。</p><p> fn  demo ()  {  const  X :  u32  =  3  +  4 ;  // CTFE  let  x :  u32  =  4  +  3 ;  // no CTFE (but maybe constant propagation) }</p><p> fn demo（）{const X：u32 = 3 + 4; // CTFE让x：u32 = 4 + 3; //没有CTFE（但可能会不断传播）}</p><p> We say that the  3 + 4 above is in  const context and hence subject to CTFE, but the  4 + 3 is not.</p><p> 我们说上面的3 + 4是在const上下文中，因此受CTFE的约束，但是4 + 3则不受此。</p><p>  Not all operations can be used in const context.For example, it makes no sense to compute your array length as “please go read that file from disk and compute something” – we can’t know what will be on the disk when the program actually runs.We could use the disk of the machine compiling the program, but that does not sound very appealing either.Things get even worse when you consider letting the program send information to the network.Clearly, we don’t want CTFE to have actually observable side-effects outside of compilation.</p><p>  并非所有操作都可以在const上下文中使用。例如，计算数组长度是没有意义的，因为“请从磁盘中读取该文件并计算一些内容” –我们不知道程序运行时磁盘上的内容实际上可以运行。我们可以使用编译程序的计算机磁盘，但这听起来也不是很吸引人。当您考虑让程序将信息发送到网络时，情况变得更加糟糕。显然，我们不希望CTFE具有在编译之外实际上可以观察到的副作用。</p><p> In fact, just naively letting programs read files would also be grossly unsafe:When computing the length of an array twice, it is important that we obtain the same result. Update: As @eddyb points out, things get even worse once you consider const generics, traits, and coherence: At that point, you have to  rely on evaluating the same expression in different crates to produce the same result.  /Update</p><p> 实际上，仅仅天真地让程序读取文件也是非常不安全的：当计算数组长度两次时，获得相同的结果很重要。更新：正如@eddyb指出的，一旦考虑const泛型，特征和连贯性，情况会变得更糟：那时，您必须依靠在不同包装箱中评估相同的表达式来产生相同的结果。 /更新 </p><p>  If not, the compiler could end up thinking that two arrays have the same length, but then later compute different layouts.That would be a disaster.So, any kind of external input and any kind of non-determinism is a complete no-go for CTFE.This does not just concern I/O, even converting a reference to a  usize is not deterministic.</p><p>如果不是这样，编译器可能最终会认为两个数组具有相同的长度，但后来又计算出不同的布局，那将是一场灾难，因此，任何类型的外部输入和任何类型的不确定性都是完全不可行的对于CTFE，这不仅涉及I / O，即使将引用转换为usize也是不确定的。</p><p> The compiler will throw a CTFE error if such an operation is ever attempted to be executed.Those programs that  are executable in const context are called  const safe:</p><p> 如果试图执行这样的操作，编译器将抛出CTFE错误。那些在const上下文中可执行的程序称为const safe：</p><p> A program is const safe if it can be executed by CTFE without hitting an error (panics are allowed).</p><p> 如果程序可以由CTFE执行而不会出错，则该程序是const安全的（允许出现紧急情况）。</p><p> This is very much in analogy with the idea that a  safe (or  run-time safe, to distinguish it from const safe) program is a program that does not cause any memory errors or data races.In fact, we will see that this analogy between “programs that are well-behaved under CTFE” (const safety) and “programs that do not cause UB” (run-time safety) can carry us very far.</p><p> 这与安全（或运行时安全，以区别于const安全）程序是一种不会引起任何内存错误或数据争用的程序非常相似。实际上，我们将看到这种比喻。在“在CTFE下表现良好的程序”（常量安全性）和“不会导致UB的程序”（运行时安全性）之间的距离可以带给我们很大的帮助。</p><p> One very interesting question now is whether some given function  foo should be allowed to be called in const context.We could just always say “yes”, and rely on the fact that CTFE will throw an error when  foo does anything fishy.The problem with this approach is that, if  foo is in a library, updating the library might change  foo in a way that makes it no longer const-safe.In other words, making  any function not const-safe any more would be a semver violation because it could break downstream crates.</p><p> 现在，一个非常有趣的问题是是否应允许在const上下文中调用某些给定的函数foo。我们可以总是说“是”，并依赖于这样的事实，即当foo进行任何操作时，CTFE会抛出错误。这种方法是，如果foo在库中，则更新库可能会以使其不再是const安全的方式更改foo。换句话说，使任何函数不再是const-safe将不再是semver，因为可能会破坏下游的板条箱。</p><p> The typical mechanism to solve that problem is to have an annotation that explicitly marks a function as “usable in const context”.In Rust, the proposed mechanism for this purpose is   const fn; in C++ it is called  constexpr.The compiler can now reject calling non- const functions in const context, so library authors can add non-const-safe operations without breaking semver.</p><p> 解决该问题的典型机制是具有一个将函数明确标记为“可在const上下文中使用”的注释。在Rust中，为此目的建议的机制为const fn；在C ++中，它称为constexpr。编译器现在可以拒绝在const上下文中调用非const函数，因此库作者可以添加非const安全的操作而不会破坏semver。</p><p>  This leads us to the interesting situation that the compiler will reject code in const context that it would accept just fine outside of const context.In particular, the body of a  const fn is  also considered to be in const context – otherwise, if we allowed calling arbitrary functions, we would have the same problem again.One useful way to think about this is that we have a second type system, a “const type system”, that is used to type-check code in const context.This type system does not allow calls to non- const functions.</p><p>  这导致我们产生一种有趣的情况，即编译器将在const上下文中拒绝代码，因为它只接受const上下文之外的内容。特别是，const fn的主体也被视为在const上下文中；否则，如果我们允许调用任意函数，我们将再次遇到相同的问题。对此进行考虑的一种有用方法是，我们有第二种类型的系统，即“ const类型系统”，用于在const上下文中对代码进行类型检查。不允许调用非const函数。 </p><p> It should probably also not allow casting a reference to an integer, because (as discussed above) that is a non-deterministic operation which cannot be performed during CTFE.What else?</p><p>它可能也应该不允许转换对整数的引用，因为（如上所述）这是一种不确定的运算，在CTFE期间无法执行。还有什么？</p><p> Before we go on and add random additional checks, let us step back and think about what our goals are here.Typically, the purpose of a type system is to establish some sort of guarantee for a well-typed program.For Rust’s “main” (“run-time”) type system, that guarantee is “no undefined behavior”, which means no memory errors and no data races.What is the guarantee for our new const type system?We have already talked about it above: It’s const safety!This leads us to the definition of const soundness:</p><p> 在继续进行随机附加检查之前，让我们退后一步，思考一下我们的目标是什么。通常，类型系统的目的是为类型良好的程序建立某种保证。对于Rust的“主要” （“运行时”）类型的系统，保证是“没有未定义的行为”，这意味着没有内存错误和数据竞争。新的const类型系统的保证是什么？我们上面已经讨论过：const安全！这导致我们对const健全性的定义：</p><p>  Again, notice how this is very similar to the correctness statement for the run-time type system, which guarantees run-time safety.</p><p>  再次注意，这与运行时类型系统的正确性声明非常相似，后者保证了运行时的安全性。</p><p>   We will definitely want to allow this code.Why should  == or  % not be const-safe?Well, we could call our function as follows:</p><p>   我们肯定会允许这段代码，为什么==或％不应该是const安全的呢？</p><p>  That statement is certainly  not const-safe as the result depends on where exactly the allocator puts our   Box.However, we want to blame the  as usize for this issue, not the  is_eight_mod_256.</p><p>  该语句当然不是const安全的，因为结果取决于分配器将Box放在哪里的位置，但是我们要将此问题归咎于usize，而不是is_eight_mod_256。</p><p> The solution is for the const type system to not just have separate rules about which operations are allowed, we also must change our notion of which values are “valid” for a given type.An integer obtained from a pointer is valid for  usize at run-time, but it is  not valid for  usize in const mode!After all, there are basic arithmetic operations that we expect all  usize to support, that CTFE cannot support for pointers.</p><p> 解决方案是，对于const类型系统，不仅要有关于允许哪些操作的单独规则，我们还必须更改对给定类型哪些值“有效”的概念。从指针获取的整数对于运行时的usize有效。 -time，但是对于const模式下的usize无效！毕竟，我们希望所有usize都支持一些基本的算术运算，而CTFE无法支持指针。</p><p> A function is const-safe if, when executed with const-valid arguments, it does not trigger a CTFE error and returns a const-valid result (if it returns at all).</p><p> 如果函数在使用const有效参数执行时未触发CTFE错误并返回const有效结果（如果它完全返回），则该函数是const安全的。 </p><p> Under this definition,  is_eight_mod_256 is const-safe because whenever  x is an actual integer, it will evaluate without any error.At the same time, this shows that converting a reference into  usize is  not const-safe, because the input of this operation is const-valid, but the output is not!This provides a solid justification for rejecting such casts in const context.</p><p>在此定义下，is_eight_mod_256是const安全的，因为只要x是实际整数，它的赋值就不会有任何错误，同时这表明将引用转换为usize并不是const安全的，因为此操作的输入是const有效，但输出不是！这为在const上下文中拒绝此类强制转换提供了坚实的理由。</p><p>  In Rust, CTFE is performed by miri, a MIR interpreter that used to be a  separate project but whose core engine has been integrated into rustc.miri will execute the code in const context step-by-step and just complain and fail with an error when an operation cannot be performed.This does not just concern non-determinism; miri does not support everything it could support because @oli-obk is  super careful about not accidentally stabilizing behavior that should undergo an RFC.</p><p>  在Rust中，CTFE由miri解释器执行，miri解释器曾经是一个单独的项目，但其核心引擎已集成到rustc.miri将逐步在const上下文中执行代码，并且只会抱怨并因错误而失败当无法执行操作时，这不仅涉及不确定性; miri不支持它可能支持的所有内容，因为@ oli-obk非常谨慎，不会意外稳定应该接受RFC的行为。</p><p> In fact, right now miri will reject all operations on raw pointers.They all raise a CTFE error and hence must all be rejected by the const type system.The plan is to change miri so that it can support more operations, but we have to be careful in doing so.I have already mentioned that miri must be deterministic, but there is another point to consider that you might have expected to play a much more prominent role:CTFE, at least if it succeeds, should match run-time behavior!</p><p> 实际上，现在miri将拒绝所有对原始指针的操作，它们都会引发CTFE错误，因此必须全部由const类型系统拒绝。计划是更改miri，以便它可以支持更多操作，但是我们必须我已经提到过miri必须是确定性的，但还有另一点要考虑的是，您可能期望扮演更重要的角色：CTFE（至少如果成功的话）应该与运行时行为匹配！</p><p> CTFE is correct if, when it loops forever, completes with a result, or panics, that behavior matches the run-time behavior of the same code.</p><p> 如果CTFE永远循环，结果结束或出现紧急情况，而该行为与同一代码的运行时行为匹配，则CTFE是正确的。</p><p> We clearly do not want code to behave differently when it lives in const context and is run by CTFE, and when it is compiled to machine-code and executed “for real”.</p><p> 当代码驻留在const上下文中并由CTFE运行时，以及将其编译为机器代码并“真正”执行时，我们显然不希望代码的行为有所不同。</p><p> Or, do we?Don’t get me wrong, I am not advocating for deliberately breaking that property, but it sure is worth considering what would go wrong if miri was  not CTFE-correct.Maybe surprisingly, it turns out that this would not be a soundness issue!All we care about for the purpose of soundness is for CTFE to be deterministic, as already discussed.We don’t re-run the same code at run-time and rely on it still doing the same, so nothing actually breaks if CTFE behavior diverges from run-time behavior.</p><p> 还是我们？不要误会我的意思，我不是提倡故意破坏该财产，但是如果miri不是CTFE正确的话，那肯定会引起问题的，这也许值得考虑，也许令人惊讶的是，事实证明这不会正如我们已经讨论过的那样，我们关心的仅是为了确保CTFE具有确定性，我们不会在运行时重新运行相同的代码，而是依靠它仍在执行相同的操作，因此没有任何问题如果CTFE行为与运行时行为不同，则实际上会中断。</p><p> That said, not being CTFE correct is surely very surprising and we should avoid it best we can.However, I am told that actually predicting the result of floating-point operations deterministically  is extremely hard and  LLVM isn’t exactly helping.So, we will likely have to live with either considering floating point operations to be const-unsafe (raising a CTFE error), or not having CTFE correctness when floating point operations are involved.I think it is possible to achieve CTFE correctness for all other operations, and I think we should strive to do so.</p><p> 话虽如此，但CTFE的正确性无疑是非常令人惊讶的，我们应该尽力避免这种情况。然而，我被告知，要确定地实际预测浮点运算的结果非常困难，而LLVM并不能提供任何帮助。我可能不得不考虑将浮点运算视为const不安全（引发CTFE错误），或者在涉及浮点运算时不具有CTFE正确性。我认为可以为所有其他运算实现CTFE正确性，并且我认为我们应该努力做到这一点。 </p><p> Before we go on, notice that CTFE correctness as defined above does not say anything about the case where CTFE fails with an error, e.g. because of an unsupported operation.CTFE would be trivially correct (in the above sense) if it just always immediately returned an error.However, since const-safe programs cannot error during CTFE, we know from CTFE correctness that  those programs  do in fact behave exactly the same at compile-time and at run-time.</p><p>在继续之前，请注意，上面定义的CTFE正确性并没有说明CTFE因错误而失败的情况，例如由于操作不受支持，如果CTFE总是立即返回错误，则CTFE将完全正确（按上述意义）。但是，由于const安全程序在CTFE期间不会出错，因此我们从CTFE的正确性中知道这些程序实际上的行为在编译时和运行时完全相同。</p><p>  Let’s say we want to extend miri to support more operations on raw pointers.We know we have to be careful about keeping miri deterministic, and about maintaining CTFE correctness.Which operations will we be able to support?</p><p>  假设我们要扩展miri以支持对原始指针的更多操作。我们知道在保持miri确定性和保持CTFE正确性方面必须格外小心。我们可以支持哪些操作？</p><p> Notice that at this point, const soundness and the related const safety are  not a concern yet.Those ideas come into play when we are changing the const type system to allow more operations.CTFE determinism and correctness, however, are properties of the CTFE engine (miri) itself.</p><p> 请注意，此时尚未考虑const的健全性和相关的const安全性。当我们更改const类型系统以允许更多操作时，这些想法开始发挥作用，但是CTFE的确定性和正确性是CTFE引擎的特性。 （miri）本身。</p><p>  const  fn  make_a_bool ()  -&gt;  bool  {  let  x  =  Box :: new ( 0 );  let  x_ptr  =  &amp;* x  as  * const  i32 ;  drop ( x );  let  y  =  Box :: new ( 0 );  let  y_ptr  =  &amp;* y  as  * const  i32 ;  x_ptr  ==  y_ptr }</p><p>  const fn make_a_bool（）->布尔{让x = Box :: new（0）;让x_ptr =＆amp; * x as * const i32;下降（x）;令y = Box :: new（0）;让y_ptr =＆amp; * y作为* const i32; x_ptr == y_ptr}</p><p> At run-time, whether this function returns  true or  false depends on whether or not the allocator re-used the space for  x when allocating  y.However, due to CTFE being deterministic, we have to pick  one concrete answer at compile-time, and that may not be the right answer.Hence we cannot allow this program to execute under CTFE if we want to maintain CTFE correctness.Supporting memory allocation in a deterministic way is perfectly feasible (in fact, miri already has that implemented), and casting a reference to a raw pointer changes nothing but the type.The only actually problematic operation here is testing two raw pointers for equality:Because one of the pointers is dangling, we can not deterministically predict the result of this comparison!</p><p> 在运行时，此函数返回true还是false取决于分配器在分配y时是否重用了x的空间。但是，由于CTFE是确定性的，我们必须在编译时选择一个具体答案，这可能不是正确的答案。因此，如果我们要保持CTFE的正确性，就不能允许该程序在CTFE下执行。以确定性的方式支持内存分配是完全可行的（实际上，miri已经实现了），并且进行了强制转换对原始指针的引用只会改变类型，这里唯一真正有问题的操作是测试两个原始指针是否相等：由于其中一个指针悬空了，我们无法确定地预测此比较的结果！</p><p> In other words, if/when miri learns how to compare pointers, we must make it raise a CTFE error if one of the pointers is dangling (points to unallocated memory), or else we would violate CTFE correctness.</p><p> 换句话说，如果/当miri学习如何比较指针时，如果其中一个指针悬空（指向未分配的内存），我们必须使其引发CTFE错误，否则我们将违反CTFE正确性。</p><p> Now, let us go one level up and look at the const type system.We have seen that comparing raw pointers can raise a CTFE error, so this is actually not a const-safe operation.Similar to casting pointers to integers, we have to make the const type system reject code that compares raw pointers.However, it seems like a shame to not even allow comparing two  references for equality, after converting them to raw pointers!After all, references never dangle, so this is a perfectly const-safe operation.</p><p> 现在，让我们向上看一下const类型系统，我们已经看到比较原始指针会产生CTFE错误，因此这实际上不是const安全操作，类似于将指针转换为整数一样，我们必须使const类型系统拒绝比较原始指针的代码，但是，将它们转换为原始指针后，甚至不允许比较两个引用是否相等似乎很可惜！毕竟，引用永远不会晃晃，所以这是一个完美的const-安全操作。 </p><p> Lucky enough, Rust  already has an answer to the need to side-step the type system in controlled ways:  unsafe blocks.Comparing raw pointers is not allowed by the const type system because it is not const-safe, but just like we allow run-time-unsafe operations to be performed in unsafe blocks, we can allow const-unsafe operations as well.So, we should be able to write the following:</p><p>幸运的是，Rust已经满足了以受控方式绕过类型系统的需求的答案：不安全的块。const类型系统不允许比较原始指针，因为它不是const安全的，但是就像我们允许运行一样-time-unsafe操作要在不安全的块中执行，我们也可以允许const-unsafe操作。因此，我们应该能够编写以下内容：</p><p> const  fn  ptr_eq &lt; T &gt; ( x :  &amp; T ,  y :  &amp; T )  -&gt;  bool  {  unsafe  {  x  as  * const  _  ==  y  as  * const  _  } }</p><p> const fn ptr_eq＆lt; ＆ （x：＆amp; T，y：＆amp; T）-＆gt;布尔{不安全{x为* const _ == y为* const _}}</p><p> As usual when writing  unsafe code, we have to be careful not to violate the safety guarantees that are usually upheld by the type system.We have to manually ensure that,  if our inputs are const-valid, then we will not trigger a CTFE error and return a const-valid result.For this example, the reason no CTFE error can arise is that references cannot dangle.We can thus provide  ptr_eq as an abstraction that is entirely safe to use in const context, even though it contains a potentially const-unsafe operation.This is, again, in perfect analogy with types like   Vec being entirely safe to use from safe Rust even though  Vec internally uses plenty of potentially unsafe operations.</p><p> 像往常一样，编写不安全的代码时，我们必须注意不要违反类型系统通常会维护的安全保证。我们必须手动确保，如果我们的输入是const有效的，那么我们将不会触发CTFE错误并返回一个const有效结果。在此示例中，不会出现CTFE错误的原因是引用无法悬挂，因此我们可以提供ptr_eq作为抽象，在const上下文中使用是完全安全的，即使它包含潜在的const -不安全的操作。这再次非常类似于Vec这样的类型，即使Vec在内部使用了大量潜在的不安全操作，也可以从安全的Rust中完全安全地使用它。</p><p> Whenever I said above that some operation must be rejected by the const type system, what that really means is that the operation should be unsafe in const context.Even pointer-to-integer casts can be used internally in const-safe code, for example to pack additional bits into the aligned part of a pointer in a perfectly deterministic way.</p><p> 每当我在上面说过const类型系统必须拒绝某些操作时，这实际上意味着该操作在const上下文中应该是不安全的。例如，即使指针到整数的强制转换也可以在const安全代码内部使用以完全确定的方式将其他位打包到指针的对齐部分中。</p><p>  There is one more aspect to CTFE in Rust that I have not yet touched on: Promotion of static values.This is the mechanism that makes the following code well-typed:</p><p>  我还没有涉及到Rust中CTFE的另一个方面：静态值的提升。这是使以下代码的类型正确的机制：</p><p>  This may look like it should be rejected because we are returning a reference to a locally created value with lifetime  &#39;static, but instead, Magic (TM) is happening.The compiler determines that  3 is a static value that can be computed at compile-time and put into static memory (like a  static variable), and hence  &amp;3 can have lifetime  &#39;static.This also works with e.g.  &amp;(3+4).Static variables, like  const, are computed at compile time and hence CTFE comes into play.</p><p>  这看起来似乎应该被拒绝，因为我们返回的是对生命周期为＆＃39; static的本地创建值的引用，但发生了Magic（TM）。编译器确定3是可以计算的静态值。在编译时放入静态内存（例如静态变量），因此＆amp; 3可以具有生命周期＆＃39; static。这也适用于例如＆amp;（3 + 4）。静态变量（如const）是在编译时计算的，因此CTFE发挥了作用。</p><p> The fundamentally new aspect to this is that  the user did not ask for the value to be promoted.That means we have to be really careful when deciding which values to promote: If we promote something that miri cannot evaluate, there will be a CTFE error and we have just broken compilation for no good reason.We better make sure that we only promote values that we can expect miri to actually be able to compute – i.e., we should only promote the results of const-safe code.You probably already guessed it, but what I am proposing is to use the const type system for that purpose.Const soundness already says that this is a way to ensure const safety.</p><p> 根本上新的方面是用户没有要求提升价值，这意味着我们在决定提升价值时必须格外小心：如果我们推广miri无法评估的内容，则会出现CTFE错误并且我们没有充分的理由就破坏了编译。我们最好确保只推广我们期望miri能够实际计算的值，即，我们只应推广const安全代码的结果。您可能已经猜到了它，但是我建议的是使用const类型系统。Const健全性已经说过，这是确保const安全的一种方式。 </p><p> I propose to only ever promote values that are  safely const-well-typed.(So, we will not promote values involving const-unsafe operations even when we are in an unsafe block.)When there are function calls, the function must be a safe  const fn and all arguments, again, const-well-typed.For example,  &amp;is_eight_mod_256(13) would be promoted but  &amp;is_eight_mod_256(Box::into_raw(Box::new(0)) as usize) would not.As usual for type systems, this is an entirely local analysis that does not look into other functions’ bodies.Assuming our const type system is sound, the only way we could possibly have a CTFE error from promotion is when there is a safe  const fn with an unsound  unsafe block.</p><p>我建议只推广安全使用const-well类型的值（因此，即使我们处于不安全的块中，我们也不会推广涉及const-unsafe操作的值）。当有函数调用时，该函数必须是一个安全const fn和所有参数都再次进行const-well-typed。例如，＆amp; is_eight_mod_256（13）将被升级，而＆amp; is_eight_mod_256（Box :: into_raw（Box :: new（0））会被提升）与类型系统通常一样，这是一个完全局部的分析，不会研究其他函数的主体。假设我们的const类型系统是健全的，那么从提升中可能会出现CTFE错误的唯一方法是当存在安全的const时fn带有不安全的声音。</p><p> Notably, we are relying on library authors properly writing  unsafe const fn even for private functions whenever there is a chance that this function might cause a CTFE error for const-valid inputs.If there is a  const fn that is actually unsafe, arguing “but it is private and hence that’s fine” will not help because the compiler might decide to promote the result of that function.However, this can only break code within the same crate and can be fixed locally, so it seems like a reasonable compromise to me.</p><p> 值得注意的是，只要有可能该函数可能导致const有效输入的CTFE错误，我们甚至都依赖库作者正确地为私有函数编写不安全的const fn。如果存在实际上不安全的const fn，则认为“但是它是私有的，因此很好”将无济于事，因为编译器可能会决定提升该函数的结果。但是，这只能在同一包装箱内破坏代码，并且可以在本地固定，因此对我来说似乎是一个合理的折衷。</p><p> Another interesting point to consider is that we probably care much more about CTFE correctness when thinking about promotion.After all, the user asked for the run-time behavior; if they are getting a completely different behavior from CTFE, that would lead to problems.If miri is CTFE-correct except for obscure floating point issues, that means “only” people relying on specific behavior of floating point operations could be affected, and likely LLVM will already violate whatever assumptions those people are making.(miri’s floating point implementation is perfectly sane and should be standards compliant, LLVM and the particularities of x87 rounding are the sources of uncertainty here.)I am not sure which effect that should or will have for promotion.</p><p> 需要考虑的另一个有趣的观点是，在考虑升级时，我们可能会更加关心CTFE的正确性。毕竟，用户要求运行时行为；如果miri是CTFE正确的，除了模糊的浮点问题之外，这意味着依赖浮点运算特定行为的“唯一”人员可能会受到影响，并且可能LLVM已经违反了人们所做的任何假设。（miri的浮点实现完全理智，应该符合标准，LLVM和x87舍入的特殊性在这里是不确定性的来源。）有晋升。</p><p>  I have discussed the notions of CTFE determinism and CTFE correctness (which are properties of a CTFE engine like miri), as well as const safety (property of a piece of code) and const soundness (property of a type system).In particular, I propose that  when type-checking safe code in const context, we guarantee that this code is const-safe, i.e., that it will not hit a CTFE error (though panics are allowed, just like they are in “run-time” Rust code).</p><p>  我已经讨论了CTFE确定性和CTFE正确性（这是像miri这样的CTFE引擎的属性）以及const安全性（一段代码的属性）和const健全性（类型系统的属性）的概念。我建议在const上下文中对安全代码进行类型检查时，我们保证该代码是const安全的，即，它不会遇到CTFE错误（尽管允许恐慌，就像它们在“运行时” Rust中一样）码）。</p><p> There are still plenty of open questions, in particular around the interaction of   const fn and traits, but I hope this terminology is useful when having those discussions.Let the type systems guide us :)</p><p> 仍然有很多悬而未决的问题，特别是关于const fn和traits交互的问题，但是我希望在进行这些讨论时可以使用该术语，让类型系统指导我们:)</p><p> Thanks to @oli-obk for feedback on a draft of this post, and to @centril for interesting discussion in #rust-lang that triggered me into developing these ideas and terminology.If you have feedback or questions,  let’s discuss in the internals forum!</p><p> 感谢@ oli-obk对本文的草稿提供反馈，感谢@centril在＃rust-lang中进行了有趣的讨论，这些讨论促使我发展了这些想法和术语。如果您有反馈或问题，请在内部论坛中进行讨论！</p><p> Posted on  Ralf&#39;s Ramblings on Jul 19, 2018.   Comments?  Drop me a mail or  leave a note in the forum!</p><p> 发表于Ralf＆＃39; s Ramblings on 2018年7月19日。评论？给我发邮件或在论坛中留言！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.ralfj.de/blog/2018/07/19/const.html">https://www.ralfj.de/blog/2018/07/19/const.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>