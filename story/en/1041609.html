<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>建立我自己的国际象棋引擎 Building My Own Chess Engine</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building My Own Chess Engine<br/>建立我自己的国际象棋引擎 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:46:34</div><div class="page_narrow text-break page_content"><p>I have been learning chess (again) and how to program a chess engine (for the first time) over the last month. After skimming some introductory texts, I was convinced that building a simple chess engine — one that would put up a fair fight against a casual player — would take no more than a few days.</p><p>上个月，我一直在学习国际象棋，以及如何编程象棋引擎（第一次）。在浏览了一些介绍性文字后，我坚信构建一个简单的象棋引擎（一个可以与休闲玩家进行公平竞争的引擎）将只需要几天。</p><p>  But I made it there in the end and created a toy chess engine ( healeycodes/andoma) that I am proud of. It can play a game of chess and solve simple chess puzzles like mate-in-two or mate-in-three. It has a slim UCI interface which means it can be hooked up to lichess.org via  lichess-bot — a bridge between the lichess API and chess bots.</p><p>  但是我最终做到了这一点，并创建了一个令我感到骄傲的玩具国际象棋引擎（healeycodes / andoma）。它可以玩国际象棋游戏，并解决简单的象棋难题，例如二人伴侣或三人伴侣。它具有纤巧的UCI界面，这意味着可以通过lichess-bot（lichess API和国际象棋bot之间的桥梁）将其连接到lichess.org。</p><p> The first speed bump in its development was grasping the computational the complexity of chess — how fast, and wide, the search tree grows. When a chess game starts, white can open in twenty different ways and black can respond in twenty different ways also. After the first full turn, there are 400 variations possible. After the third full turn, there are  over 119 million.</p><p> 其发展的第一个减速是要掌握国际象棋的计算复杂性-搜索树的增长速度和宽度。开始下象棋游戏时，白色可以以二十种不同的方式打开，黑色可以以二十种不同的方式响应。第一个完整回合后，可能有400种变化。在第三个完整回合之后，超过了1.19亿。</p><p> Claude Shannon calculated that there are around  10^120 possible games of chess in his seminal paper  Programming a Computer for Playing Chess in 1950. In  Rage Against the Machines, Nate Silver  quotes Diego Rasskin-Gutman, who said:</p><p> 克劳德·香农（Claude Shannon）在其开创性的论文《为计算机下象棋编程计算机》（1950年，他的开创性论文）中计算出大约有10 ^ 120种可能的国际象棋。内特·西尔夫（Nate Silver）引用迭戈·拉斯金·古特曼（Diego Rasskin-Gutman）的话：</p><p>  Given unlimited resources, it actually doesn’t take many lines of code to calculate every legal variation of chess. Here, the Python package  python-chess is used for board representation and legal move generation.</p><p>  有了无限的资源，实际上并不需要很多代码来计算国际象棋的每个合法变化。在这里，Python包python-chess用于董事会代表和合法举动的产生。</p><p> from chess  import Board , Move , STARTING_FEN # an adjacency listpositions  =  { } # depth-first search from a FEN string def  generate_tree (fen ) : board  = Board (fen ) legal_moves  =  list (board .legal_moves )  if fen  in positions : positions [fen ]  += legal_moves  else : positions [fen ]  = legal_moves  for move  in legal_moves : board .push (move ) next_fen  = board .fen ( ) board .pop ( ) generate_tree (next_fen ) try : generate_tree (STARTING_FEN ) except RecursionError :  print ( len (positions )  +  sum ( len (p )  for p  in positions ) )</p><p> 从国际象棋导入板，移动，STARTING_FEN＃邻接列表位置= {}＃从FEN字符串进行深度优先搜索def generate_tree（fen）：板=板（fen）Legal_moves =列表（board .legal_moves），如果fen在位置：position [fen] + = legal_moves else：位置[fen] =合法移动中的legal_moves：board .push（move）next_fen = board .fen（）board .pop（）generate_tree（next_fen）try：generate_tree（STARTING_FEN），除了RecursionError之外：打印（len（位置）+和（len（p）表示p在位置））</p><p> This program throws a  RecursionError and prints  59691 — the number of different positions the search tree contained when it crashed. All we need to fix this, is another universe to run the program in.</p><p> 该程序引发RecursionError并打印59691 —搜索树崩溃时所包含的不同位置数。我们需要解决的是另一个在其中运行程序的世界。 </p><p> Given that there are computational limits to abide by, as well as the time control rules of chess, improvements over a naive brute force search must be made.</p><p>考虑到要遵守的计算限制以及国际象棋的时间控制规则，必须对天真的暴力搜索进行改进。</p><p>  In order to search for good positions, it is necessary to understand what makes a good position  good. The most simplistic way of describing a position’s strength is to compare the total value material of each side.</p><p>  为了寻找良好的职位，有必要了解使良好的职位变好的原因。描述位置强度的最简单方法是比较每一侧的总价值材料。</p><p> Tomasz Michniewski, author of the  Simplified Evaluation Function, defined some values that are “designed specifically to compensate for the lack of any other chess knowledge”. This is perfect for me — a beginner chess player.</p><p> 简化评估函数的作者Tomasz Michniewski定义了一些“专门为补偿缺乏其他国际象棋知识而设计的”值。这对我来说是完美的-初学者棋手。</p><p> This snippet sums the material on the initial board using Michniewski’s piece values.</p><p> 此代码段使用Michniewski的件值汇总了初始板上的材料。</p><p> import chesspiece_values  =  { chess .PAWN :  100 , chess .ROOK :  500 , chess .KNIGHT :  320 , chess .BISHOP :  330 , chess .QUEEN :  900 , chess .KING :  20000 }board  = chess .Board (chess .STARTING_FEN )white_material  =  0black_material  =  0 for square  in chess .SQUARES : piece  = board .piece_at (square )  if  not piece :  continue  if piece .color  == chess .WHITE : white_material  += piece_values [piece .piece_type ]  else : black_material  += piece_values [piece .piece_type ]</p><p> 进口国际象棋=象棋.PAWN：100，象棋.ROOK：500，象棋.KNIGHT：320，象棋.BISHOP：330，象棋.QUEEN：900，象棋.KING：20000} board =象棋.Board（chess .STARTING_FEN） white_material = 0 black_material = 0，表示国际象棋中的正方形。SQUARES：件=棋盘.piece_at（正方形），如果不是件：如果件.color ==国际象棋，则继续。白色：white_material + =件值[piece .piece_type]否则：black_material + =件值[件.piece_type]</p><p> Michniewski also provides  piece-square tables, which alter the value of a piece depending on which square it sits on. For example, it’s better for pawns to progress up the board and it’s better for knights to be near the center of the board.</p><p> Michniewski还提供了一块正方形表，该块表根据其所在的正方形来改变一块的值。例如，典当最好沿着棋盘前进，骑士最好靠近棋盘中心。</p><p> The bonus of a square may be positive, neutral, or negative. The piece-square tables are presented from White’s POV and must be mirrored for Black.</p><p> 平方的奖励可能是正数，中性或负数。平方尺表是由White的POV呈现的，必须与Black镜像。 </p><p> # a knight&#39;s bonuses depending on square-50,-40,-30,-30,-30,-30,-40,-50,-40,-20, 0, 0, 0, 0,-20,-40,-30, 0, 10, 15, 15, 10, 0,-30,-30, 5, 15, 20, 20, 15, 5,-30,-30, 0, 15, 20, 20, 15, 0,-30,-30, 5, 10, 15, 15, 10, 5,-30,-40,-20, 0, 5, 5, 0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50,</p><p>＃骑士奖金取决于50，-40，-30，-30，-30，-40，-50，-40，-20、0、0、0，-， 20，-40，-30、0、10、15、15、10、0，-30，-30、5、15、20、20、15、5，-30，-30、0、15、20， 20、15、0，-30，-30、5、10、15、15、10、5，-30，-40，-20、0、5、5、0，-20，-40，-50， -40，-30，-30，-30，-30，-40，-50，</p><p> For the king, Michniewski provides two tables — one for the middle game and one for the end game. He defines the end game as being either if:</p><p> 对于国王，Michniewski提供了两张桌子-一张用于中间游戏，一张用于结束游戏。他将结束游戏定义为：</p><p>  Every side which has a queen has additionally no other pieces or one minorpiece maximum.</p><p>  具有女王/王后的每一侧都没有其他碎片或最多一个未成年人。</p><p>  The evaluation of a chess board is one of the things that’s kept me interested in chess engines. Evaluation rules are easy to add and take away. I refactored the code from Go to Python to be able to prototype different rules faster.</p><p>  对棋盘的评估是使我一直对棋引擎感兴趣的原因之一。评估规则易于添加和删除。我将代码从Go重构为Python，以便能够更快地原型化不同的规则。</p><p> After piece-square tables, one might look at pawn structure, mobility, center control, connectivity, trapped pieces, king safety, space, tempo, and other patterns (this list is taken from the Chess Programming Wiki’s  Evaluation page).</p><p> 在棋子方桌之后，人们可能会查看棋子的结构，移动性，中心控制，连通性，被困棋子，国王安全性，空间，节奏和其他样式（此列表摘自国际象棋编程维基的“评估”页面）。</p><p>  Minimax is a search algorithm that finds the next optimal move by minimizing the potential loss in a worst case scenario. Chess is a game of perfect information — by looking at the board it’s possible to know exactly what an opponent is capable of. However, this search for moves is limited by the evaluation function and the depth that computing resources are able to reach.</p><p>  Minimax是一种搜索算法，它通过在最坏情况下将潜在损失最小化来找到下一个最佳移动。国际象棋是一种完美的信息游戏-通过观察棋盘，可以确切地知道对手的能力。但是，这种对移动的搜索受到评估功能和计算资源能够达到的深度的限制。</p><p> The search space is a tree of legal moves which grows exponentially at every level (the average branching factor is around 35). By the time the tree is explored, the path to many future boards is known as well as which path restricts the opponent’s possible gains the most.</p><p> 搜索空间是一棵合法举动的树，它在每个级别都呈指数增长（平均分支因子约为35）。在探索树时，已知通往许多未来棋盘的路径，以及该路径最大程度地限制了对手的可能收益。 </p><p> The leaf nodes of the tree return the evaluation of their current state. Non-leaf nodes inherit their value from a descendant node. Eventually, the recursive function reduces down to a value for the given board.</p><p>树的叶节点返回其当前状态的评估。非叶节点从后代节点继承其值。最终，递归函数将减小到给定板的值。</p><p> This function can be used to pick the next best move by calling it on every legal move available in the current turn. A great visual resource for this algorithm is Sebastian Lague’s  Algorithms Explained – minimax and alpha-beta pruning.</p><p> 通过在当前回合中可用的每个合法移动上调用此功能，可以使用它来选择下一个最佳移动。塞巴斯蒂安·拉格（Sebastian Lague）的“算法介绍”（该算法非常有用）是最小的视觉资源-minimax和alpha-beta修剪。</p><p> def  minimax (board , depth , maximizing_player ) :  if depth  ==  0  or board .is_game_over ( ) :  return evaluate (board )  if maximizing_player : value  =  - float ( &#39;inf&#39; )  for move  in board .legal_moves : board .push (move ) value  =  max (value , minimax (board , depth  -  1 ,  False ) ) board .pop ( )	  return value  else : value  =  float ( &#39;inf&#39; )  for move  in board .legal_moves : board .push (move ) value  =  min (value , minimax (board , depth  -  1 ,  True ) ) board .pop ( )  return value</p><p> def minimax（board，depth，maximizing_player）：如果depth == 0或board .is_game_over（）：如果maximizing_player：value =-float（＆＃39; inf＆＃39;）返回评估（board）进行棋盘移动。 ：board .push（move）value = max（value，minimax（board，depth-1，False））board .pop（）返回值else：value = float（＆＃39; inf＆＃39;）用于在木板中移动.legal_moves：板.push（move）值=最小值（值，最小最大（板，depth-1，True））板.pop（）返回值</p><p>  My chess engine uses  alpha-beta pruning as an improvement over the naive minimax algorithm — which does not fare well against the exponential nature of chess. Branches of the search tree can be eliminated when it is clear that another branch shows more promise. This significantly reduces the number of moves required to be generated.</p><p>  我的国际象棋引擎使用alpha-beta修剪作为对朴素的minimax算法的改进-与国际象棋的指数性质相去甚远。当很明显另一个分支显示出更多的承诺时，可以消除搜索树的分支。这大大减少了需要产生的移动次数。</p><p>  By reducing the depth of branches that will not bear fruit we can search deeper down the better parts of the tree.</p><p>  通过减少无法开花结果的树枝的深度，我们可以更深地搜索树的更好部分。</p><p> The speed of alpha-beta pruning can be increased by applying  move ordering. This is where the more promising branches of the search tree are searched first — which means less time is spent in the worst branches as they will be cut off early.</p><p> 可以通过应用移动顺序来提高alpha-beta修剪的速度。这是首先搜索搜索树中较有希望的分支的地方-这意味着在最差的分支上花费的时间更少，因为它们将尽早被切断。</p><p>  In  my engine, a cheap (but not perfect)  move_value function is used to sort the initial legal move nodes from best to worst. The logic of this function is capture in its docstring:</p><p>  在我的引擎中，便宜的（但不是完美的）move_value函数用于对初始合法移动节点从最佳到最坏的排序。该函数的逻辑是在其文档字符串中捕获的： </p><p> &#39;&#39;&#39;How good is a move?A promotion is great.A weaker piece taking a stronger piece is good.A stronger piece taking a weaker piece is bad.Also consider the position change via piece-square table.&#39;&#39;&#39;</p><p>＆＃39;＆＃39;举动有多好？晋升很棒;较弱的人拿走更强的棋子是好事;较强的人拿走较弱的棋子是不好的;还考虑通过棋子改变位置-方桌。＆＃39;＆＃39;＆＃39;</p><p>  The  Universal Chess Interface (UCI) is a open protocol to hook up chess engines to user interfaces. The communication is done through standard input and standard output and messages end with  \n. The move format is long algebraic notation — like  e2e4, or  e1g1 for white short castling, and an example of a promotion to queen is  a7a8q.</p><p>  通用国际象棋界面（UCI）是一种开放协议，可将国际象棋引擎连接到用户界面。通信通过标准输入和标准输出完成，消息以\ n结尾。移动格式是长代数符号-如e2e4或e1g1表示白色短整形，而提升为皇后的一个例子是a7a8q。</p><p> There are many configuration commands in the specification and it initially seemed overwhelming. After debugging, I found that not many were required to get a chess engine to the  Hello World stage.</p><p> 规范中有许多配置命令，乍一看似乎不胜枚举。调试之后，我发现将象棋引擎转到Hello World阶段并不需要很多。</p><p> In order to hook my chess engine up to lichess via  lichess-bot, I implemented the following. These commands are send to the engine from lichess-bot:</p><p> 为了使我的国际象棋引擎通过lichess-bot连接到lichess，我实现了以下内容。这些命令从lichess-bot发送到引擎：</p><p> position startpos moves e2e4 - the engine sets it’s internal state to match the list of moves</p><p> 位置起始位置动作e2e4-引擎将其内部状态设置为与动作列表匹配</p><p> go - the engine should now calculate and respond with the next best move, like  g8f6</p><p> go-引擎现在应该计算并做出下一个最佳移动，例如g8f6</p><p>  I have found a great joy interacting with the chess community over the last month. Lichess is a fantastic resource and endlessly fun to play on. The UI is slick and light — and the post-match analysis is revealing and simple to use. It’s  open source and relies on donations and sponsorships.</p><p>  在过去的一个月中，我与国际象棋社区互动感到非常高兴。 Lichess是一个了不起的资源，并且可以无休止地玩乐。用户界面光滑轻巧-赛后分析显示出来且易于使用。它是开源的，并依赖捐赠和赞助。 </p><p> I took breaks from writing this article to play chess against Dad on a real board. We’re missing a white rook and use a pencil sharpener as a replacement piece. He has been telling me stories about playing chess decades ago — before IBM’s  Deep Blue emerged and beat Garry Kasparov, the reigning world champion, on its second attempt in 1997.</p><p>我在写这篇文章时休息了一下，以便在真正的棋盘上与爸爸下棋。我们缺少白色的白嘴鸦，并使用削笔器作为替换件。几十年前，他一直在告诉我有关下棋的故事-在IBM的“深蓝”游戏问世之前，在1997年的第二次尝试中击败了卫冕世界冠军加里·卡斯帕罗夫。</p><p> If you are within my social circle, you will have experienced me evangelizing chess and chess engines over the last month — now that I have published this, I promise to chill out a little bit ♟️</p><p> 如果您属于我的社交圈，那么在过去的一个月中，您将经历过我对国际象棋和国际象棋引擎进行宣传的经历-既然我已经出版了此书，我保证会放松一点</p><p>   Chess Programming Wiki — an incredible wealth of knowledge exists here. I spent hours reading through intermediate and advanced concepts just for fun</p><p>   国际象棋编程维基-这里蕴藏着难以置信的丰富知识。我花了几个小时阅读中级和高级概念，只是为了好玩</p><p> Algorithms Explained – minimax and alpha-beta pruning — Sebastian Lague’s breakdowns of algorithms are very approachable and this one is no different</p><p> 解释了算法–最小最大和alpha-beta修剪–塞巴斯蒂安·拉格（Sebastian Lague）的算法细分非常容易实现，这一点没有什么不同</p><p> A step-by-step guide to building a simple chess AI — this JavaScript-based tutorial introduces concepts with explicit code snippets. The source code of the final solution is quite readable too</p><p> 构建简单的国际象棋AI的分步指南-该基于JavaScript的教程介绍了带有显式代码段的概念。最终解决方案的源代码也很可读</p><p>  Comments or questions? I enjoy talking with readers over  email. I write about code. Get my posts, projects, and personal updates straight to your inbox!</p><p>  评论或问题？我喜欢通过电子邮件与读者交谈。我写代码。将我的帖子，项目和个人更新直接发送到您的收件箱！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://healeycodes.com/building-my-own-chess-engine/">https://healeycodes.com/building-my-own-chess-engine/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/国际象棋/">#国际象棋</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/chess/">#chess</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>