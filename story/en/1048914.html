<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重新创建真实世界的地形，反应，三个.js和webgl着色器 Recreating Real-World Terrain with React, Three.js and WebGL Shaders</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Recreating Real-World Terrain with React, Three.js and WebGL Shaders<br/>重新创建真实世界的地形，反应，三个.js和webgl着色器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:44:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/0ae4749c6188f7de7a8a3fb52bd16cb1.png"><img src="http://img2.diglog.com/img/2021/2/0ae4749c6188f7de7a8a3fb52bd16cb1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You might know about Microsoft&#39;s Flight Simulator release in August last year and like me, if you&#39;re interested in flight simulators or photorealistic recreations of real life places, you might have spent a lot of time staring in awe at the amazing detail crammed into the  latest iteration of the series.</p><p>您可能会了解关于Microsoft＆＃39;去年8月的航班模拟器发布，如我，如果您＆＃39;对飞行模拟器感兴趣或对现实生活的照片娱乐场所感兴趣，您可能已经花了很多时间盯着敬畏令人惊叹的细节填充到该系列的最新迭代中。</p><p>  Flight Simulator uses satellite scans and terrain data from Bing maps to generate the terrain in real time. I won&#39;t go into the details but you can get  a gist of what&#39;s going on here, but it is safe to say that the results are some of the most accurate recreations of real life places, with some people saying that they could even spot their house if they flew over to their town.</p><p>  飞行模拟器使用卫星扫描和地形数据从Bing Maps实时生成地形。我赢得了详细信息，但你可以获得一个想法的想法，但是可以安全地说结果是现实生活中最准确的地方的一些娱乐活动如果他们飞向他们的城镇，他们甚至可以发现他们的房子。</p><p> This article is going to help you recreate something similar, albeit in much lower detail and on a much, much smaller scale. However, I think you&#39;ll find it&#39;s exciting nonetheless.</p><p> 本文将帮助您重新创建类似的东西，尽管更低的细节，并且在大多数更小的范围内。但是，我认为你＆＃39; ll找到它＆＃39;仍然令人兴奋。</p><p>   Ever since  WebGL brought the immense capabilities of OpenGL to the Web, it made developing 3D environments with complex textures and lighting more accessible via the web, which is arguably the most accessible platform. It gave developers a way to showcase their work on any platform that came with a web browser and supported WebGL. Today, the list of platforms that support WebGL is pretty large and covers a huge proportion of the user base.</p><p>   自WebGL以来将OpenGL的巨大能力带到了Web，它使3D环境具有复杂的纹理和光线，通过Web更可访问，可以说是最可访问的平台。它给开发人员提供了一种方法来展示他们在网浏览器和支持WebGL的任何平台上的工作。今天，支持WebGL的平台列表非常大，涵盖了大量用户群。</p><p> Three.js made things even easier for developers by allowing them to write their code in JavaScript and interact with browser APIs like the  DOM,  audio APIs and  WebSockets just to name a few. Three.js still allows you to drop down into the WebGL layer by directly calling its APIs.</p><p> Three.js通过允许它们在JavaScript中写入代码并与DOM，Audio API和WebSockets与浏览器API交互来说，更轻松地使开发人员更容易成为开发人员。 Three.js仍然可以通过直接调用其API来删除进入WebGL层。</p><p> More recently, a library called  react-three-fiber took this one step further, by providing React developers with a reconciler that would allow them to effortlessly write their Three.js code declaratively using JSX.</p><p> 最近，通过向与协调转符提供反应开发人员来说，一个名为React-Three-Fible的库进一步逐步逐步允许它们毫不费力地使用JSX声明地毫不费力地编写三个.js代码。</p><p>  We&#39;re going to try and recreate a piece of terrain in Three.js and try and make it as photorealistic as possible.</p><p>  我们将尝试在Three.js中尝试和重新创建一块地形，并尽可能地尝试作为光电态度。 </p><p> But first, let&#39;s get a minimum working app set up so that we have something tangible.</p><p>但首先，让＆＃39; s得到一个最低工作的应用程序设置，以便我们有形。</p><p>  One single square plane in 3d space, that will eventually turn into a piece of terrain.</p><p>  3D空间中的一个平面平面，最终会变成一块地形。</p><p>  For a more complete guide to how this code works, you should check out  Vikrant&#39;s article on our old blog explaining the basics of  react-three-fiber.</p><p>  有关该代码如何工作的更多指南，您应该在我们的旧博客上查看Vikrant＆＃39;旧博客解释反应三纤维的基础知识。</p><p> The &#34;terrain&#34; is just a green square right now. So, our next steps are going to involve getting the data we need to make it look more earthly.</p><p> ＆＃34;地形＆＃34;现在只是一个绿色广场。因此，我们的下一步将涉及获取我们需要使它看起来更近地的数据。</p><p>   For this article, I&#39;ll be using a real life location.  Uluru (also known as Ayers Rock) is a natural rock formation and UNESCO World Heritage Site in central Australia. It is made of sandstone, has a distinctive red-brown color and is surrounded by the arid landscape of the  Uluṟu-Kata Tjuṯa National Park. A perfect test location.</p><p>   对于这篇文章，我会使用现实生活的位置。 Uluru（也称为Ayers Rock）是澳大利亚中部的天然岩层和联合国教科文组织世界遗产。它由砂岩制成，具有独特的红棕色，并被Uluōu-kataTjuğa国家公园的干旱景观所包围。一个完美的测试地点。</p><p>   Beautiful, isn&#39;t it? Almost like the surface of Mars. I chose this spot because the terrain has some prominent features that would be interesting to recreate and the variations in terrain height are distinct.</p><p>   美丽，isn＆＃39; t呢？几乎就像火星的表面。我选择了这个地方，因为地形具有一些突出的特征，这将是有趣的，并且地形高度的变化是截然不同的。</p><p>  First, we&#39;ll modify the flat plane we drew earlier so that it has the shape of the terrain.</p><p>  首先，我们＆＃39; ll修改了我们之前德鲁的平面，以便它具有地形的形状。 </p><p> For both steps, we&#39;ll need different kinds of data, so we&#39;ll get those before each step.</p><p>对于两个步骤，我们＆＃39; ll需要不同种类的数据，所以我们＆＃39; ll在每一步之前得到那些。</p><p>  In many cases, the easiest way to describe something is with a picture. In the case of computer graphics, images can be one of the most efficient forms of encoding data, with the added advantage of allowing humans to easily perceive that data.</p><p>  在许多情况下，描述某事的最简单方法是用图片。在计算机图形学的情况下，图像可以是最有效的编码数据之一，具有允许人类容易地认为数据的额外优势。</p><p> The first data we need is the height or altitude mapping of each point on the terrain. One way to do this is to map points on the Earth&#39;s surface to pixels in an image, with each pixel representing some data about a point or region on the surface.</p><p> 我们需要的第一个数据是地形上每个点的高度或高度映射。这样做的一种方法是将地球＆＃39; s表面上的点映射到图像中的像素，每个像素表示关于表面上的点或区域的一些数据。</p><p> The most natural mapping one could think of is: the lighter the pixel, the higher up the point is on the Earth.</p><p> 最自然的映射可以想到是：像素较轻，越高的点在地球上。</p><p>  Lucky for us, there&#39;s a few tools that can give us exactly this. One pretty popular example is   terrain.party, which is used by the  Cities: Skylines community to generate terrains in-game.</p><p>  幸运的是我们，有几个可以给我们的工具。一个漂亮的流行例子是地形。帕蒂，这是城市使用的：地平线社区在游戏中产生地形。</p><p>    We need a specific part of Australia. So, I did the work of zooming into the coordinates for Uluru:</p><p>    我们需要澳大利亚的特定部分。所以，我做了放大乌鲁鲁坐标的工作：</p><p>  The white part is Uluru, which is higher up while the surroundings, which are almost black, are the ground around the rock formation.</p><p>  白色部分是uluru，uluru在距离岩层周围的周围环境较高时。 </p><p> Tangrams does the hard work of making sure that the lowest level (~500m above sea level) is black (#000), while the peak of Uluru (~800m above sea level) is white (#fff), and the rest is linearly mapped in between the two.</p><p>七巧板努力确保最低的水位（海拔约500m）是黑色的（＃000），而乌鲁鲁的山峰（海拔约800m）是白色的（#fff），其余部分呈线性映射在两者之间。</p><p> After exporting an adequate range of the terrain to a PNG, I scaled and cropped it into a 1024x1024 format using  GIMP. It&#39;s important for later that the height and width be a power of two.</p><p> 将适当范围的地形导出为PNG后，我缩放并使用GIMP将其裁剪为1024x1024格式。稍后高度和宽度必须为2的幂，这一点很重要。</p><p>   Now we need to add this to the Three.js scene so that our plane starts to take the form of the final terrain.</p><p>   现在，我们需要将其添加到Three.js场景中，以便我们的飞机开始采用最终地形的形式。</p><p>   A  shader is a sort of a function that decides what a pixel looks like based on several parameters. In WebGL, there are two types of shaders:</p><p>   着色器是一种功能，可根据多个参数来确定像素的外观。在WebGL中，有两种类型的着色器：</p><p>  Let&#39;s talk about these in the context of 3D objects. The surface of any 3D object can be represented as a bunch of polygons. Usually, we use triangles, because they are simple and planar.</p><p>  让我们在3D对象的上下文中讨论这些问题。任何3D对象的表面都可以表示为一堆多边形。通常，我们使用三角形，因为它们既简单又平坦。</p><p> In a simplified sense, the  vertex shader decides where the vertices of these polygons are rendered in the 3D space, while the  fragment shader decides what the space between those vertices will look like.</p><p> 在简化意义上，顶点着色器确定这些多边形的顶点在3D空间中的渲染位置，而片段着色器确定这些顶点之间的空间是什么样。</p><p>  So the vertex shader will help us use the heightmap to shape our terrain, while the fragment shader will be useful when we need to apply textures.</p><p>  因此，顶点着色器将帮助我们使用高度图来塑造地形，而片段着色器在需要应用纹理时将非常有用。 </p><p> To do this, we will need to modify our earlier code, since we won&#39;t be able to use the same material, ( MeshBasicMaterial), that we used in the first sandbox with the green square. Instead, we&#39;ll need a special material called   ShaderMaterial that will let us pass in our hand crafted shaders.</p><p>为此，我们将需要修改之前的代码，因为我们将无法使用与第一个带有绿色正方形的沙箱中使用的材料（MeshBasicMaterial）相同的材料。相反，我们将需要一种称为ShaderMaterial的特殊材料，该材料将使我们能够通过手工制作的着色器。</p><p>  WebGL shaders are written in a language called GLSL, which is similar to C++ in some ways, but gets compiled to run directly on the GPU. Each shader can have a main function. The code in this main function is applied to each pixel in the framebuffer on the GPU.</p><p>  WebGL着色器使用称为GLSL的语言编写，该语言在某些方面类似于C ++，但经过编译后可以直接在GPU上运行。每个着色器可以具有一个主要功能。此主要功能中的代码适用于GPU上帧缓冲区中的每个像素。</p><p> In Three.js, these shaders can be passed into the  ShaderMaterial as a string. As long as the string is a valid GLSL program, everything will work.</p><p> 在Three.js中，这些着色器可以作为字符串传递到ShaderMaterial中。只要该字符串是有效的GLSL程序，一切都将起作用。</p><p> We&#39;ll make a vertex shader that takes the red component (the R in RGBA) of each pixel of the heightmap and combines it with a scaling factor to decide the height of each point above the X-Z plane (the plane our terrain lies in).</p><p> 我们将制作一个顶点着色器，该着色器采用高度图的每个像素的红色分量（RGBA中的R），并将其与比例因子结合起来，以确定XZ平面（我们的地形所在的平面）上方每个点的高度在）。</p><p> We could have used the blue and green components too, but since everything is in grayscale, those values will be identical to the red component in our heightmap.</p><p> 我们也可以使用蓝色和绿色分量，但是由于所有内容均为灰度，因此这些值将与高度图中的红色分量相同。</p><p> We&#39;ll also create a rudimentary fragment shader that just makes points that are higher up a lighter shade of green, so that we can see the results rather easily.</p><p> 我们还将创建一个基本的片段着色器，该片段着色器仅使更高的点位于较浅的绿色阴影上，以便我们可以很容易地看到结果。</p><p>  // Uniforms are data that are shared between shaders // The contain data that are uniform across the entire frame. // The heightmap and scaling constant for each point are uniforms in this respect. // A uniform to contain the heightmap imageuniform sampler2D bumpTexture; // A uniform to contain the scaling constantuniform  float bumpScale; // Varyings are variables whose values are decided in the vertext shader // But whose values are then needed in the fragment shader // A variable to store the height of the pointvarying  float vAmount; // The UV mapping coordinates of a vertexvarying vec2 vUV;  void   (){  // The &#34;coordinates&#34; in UV mapping representation vUV = uv;  // The heightmap data at those coordinates vec4 bumpData = texture2D(bumpTexture, uv);  // height map is grayscale, so it doesn&#39;t matter if you use r, g, or b. vAmount = bumpData.r;  // move the position along the normal vec3 newPosition = position + normal * bumpScale * vAmount;  // Compute the position of the vertex using a standard formula gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,  1.0);}</p><p>  //统一是在着色器之间共享的数据//包含在整个帧中统一的数据。 //在这方面，每个点的高度图和缩放常数都是统一的。 //包含高度图的制服imageuniform sampler2D bumpTexture; //包含缩放常数的制服。 //变量是变量，其值是在vertext着色器中确定的//但是，然后在片段着色器中需要它们的值//一个用于存储点变量float vAmount的高度的变量； //顶点变化vec2 vUV的UV映射坐标； void（）{//坐标＆＃34;在UV映射表示中vUV = uv; //在这些坐标处的高度图数据vec4 bumpData = texture2D（bumpTexture，uv）; //高度图是灰度的，因此使用r，g或b都没有关系。 vAmount = bumpData.r; //沿普通vec3位置移动newPosition =位置+普通* umpScale * vAmount; //使用标准公式gl_Position = projectionMatrix * modelViewMatrix * vec4（newPosition，1.0）;}计算顶点的位置 </p><p>     So we&#39;ve mapped the terrain height to our ShaderMaterial using a height map and careful use of a vertex shader. But it doesn&#39;t look like terrain yet.</p><p>所以我们使用高度图映射到我们的Shadmarial的地形高度，并仔细使用顶点着色器。但它没有看起来像地形。</p><p>   We need real textures if we need our terrain to look anything like the real thing.</p><p>   如果我们需要我们的地形，我们需要真实的纹理看起来像真实的东西。</p><p> One of the easiest ways to get photorealistic textures is to get your hands on satellite images.</p><p> 获得光电型纹理的最简单方法之一是掌握卫星图像。</p><p> I took the easy way out and used  Mapbox to get a bunch of screenshots of the area around Uluru and merged them into a single image using GIMP.</p><p> 我采取了简单的方法，使用Mapbox获得乌鲁鲁周围地区的一堆屏幕截图，并使用gimp将它们合并到单个图像中。</p><p>  This was actually pretty time consuming since I needed to be careful that the images were at the right zoom level and that everything would line up with the heightmap.</p><p>  这实际上非常耗时，因为我需要注意图像处于正确的缩放级别，并且一切都将与高度图排行。</p><p> Since the heightmap and the textures were from different sources, I needed to resize the texture to match the heightmap&#39;s zoom level. To help with the positioning, I also needed to use tricks like adding thresholding to the heightmap so that the features would stand out in the heightmap and help me with the positioning.</p><p> 由于高度图和纹理来自不同的来源，因此我需要调整纹理的大小以匹配高度图＆＃39; s缩放级别。为了帮助定位，我还需要使用诀窍，如将阈值平衡添加到高度图，以便该功能在高度图中脱颖而出，并帮助我定位。</p><p>    So, we&#39;ve mapped the terrain height to our  ShaderMaterial using a heightmap and careful use of a vertex shader.</p><p>    所以，我们使用高度图和仔细使用顶点着色器，将地形高度映射到我们的Shadmarial。 </p><p> We&#39;ve also gotten hold of a texture map which is the exact same size and zoom level, and of the same location as the heightmap.</p><p>我们也有一个纹理映射的持有，它是完全相同的大小和缩放级别，以及与高度图相同的位置。</p><p> Now we need to create a fragment shader that can map the terrain texture onto our  ShaderMaterial.</p><p> 现在我们需要创建一个可以将地形纹理映射到我们的Shadermaterial上的片段着色器。</p><p> In our case, this is surprisingly simple. We just need to read the texture map image and set the color of the corresponding pixel using the fragment shader.</p><p> 在我们的情况下，这令人惊讶地简单。我们只需要读取纹理地图图像并使用片段着色器设置相应像素的颜色。</p><p>  // A uniform fot the terrain texture imageuniform sampler2D terrainTexture; // Get the varyings from the vertex shadervarying vec2 vUV; // vAmount isn&#39;t really used, but could be if necessaryvarying  float vAmount;  void   (){  // Get the color of the fragment from the texture map  // at that coordinate in the UV mapping gl_FragColor = texture2D(terrainTexture, vUV);}</p><p>  //一个统一的地形纹理Imageuniform Sampler2d Trintainture; //从顶点Shaderving Vec2 Vuv获取变化; // vamount isn＆＃39; t真正使用过，但可以是必要的浮动vamount; void（）{//从uv映射gl_fragcolor = texture2d（terraintexture，Vuv）中的坐标上获取片段的颜色。</p><p>    In this article, we&#39;ve managed to set up a basic scene, learned about two types of materials ( MeshBasicMaterial and  ShaderMaterial), shaders, how to customise  ShaderMaterial using shaders and recreate a piece of real world terrain using Three.js and React.</p><p>    在本文中，我们设法设置了一个基本场景，了解了两种类型的材料（MeshbasicMaterial和Sharematerial），着色器，如何使用着色器定制着色剂，并使用三个，使用三个现实世界地形使用三个。反应。</p><p> The results are pretty good. There are a few more things we could do, but I&#39;ll leave them for another time.</p><p> 结果非常好。我们可以做的更多事情，但我＆＃39; ll离开它们了另一个时间。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://techblog.geekyants.com/recreating-real-world-terrain-with-react-threejs-and-webgl-shaders-1">https://techblog.geekyants.com/recreating-real-world-terrain-with-react-threejs-and-webgl-shaders-1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/webgl/">#webgl</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>