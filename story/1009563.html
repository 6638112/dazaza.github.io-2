<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>x86处理器上的单机JIT性能</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">x86处理器上的单机JIT性能</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-03 04:28:07</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/7/26fdee2c448461ddf132a6d952b03710.png"><img src="http://img.diglog.com/img/2020/7/26fdee2c448461ddf132a6d952b03710.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>PermalLink GitHub是5000多万开发人员的家园，他们一起工作，共同托管和审查代码、管理项目和构建软件。</p><p>报名。</p><p>这本质上是一个JIT，其中代码只被使用一次，然后被覆盖并再次使用。(请注意，此代码在实施W^X安全性的操作系统上不起作用。目前，x86上使用最广泛的操作系统不强制执行W^X，因此上述技术在大多数计算机上都是可行的。对于此调查，我将假设没有强制执行W^X)。</p><p>x86处理器完全支持自修改代码(SMC)，不需要程序向处理器发出任何信号(例如，不需要刷新指令)，这意味着x86处理器需要自动检测对指令数据的写入并立即处理它们。</p><p>上述代码虽然不是真正的SMC方案，但由于JIT代码在需要写入时驻留在指令高速缓存中，因此通常会检测到它。此类写入通常涉及使缓存无效和刷新管道，这会导致严重的性能损失。</p><p>我在研究类似于上面的执行GF(216)乘法的算法时遇到了这个问题，并注意到有一些技术可以减轻这种性能损失。</p><p>然而，我一直无法找到更多关于这方面的信息，更不用说实际的测试结果了。因此，此存储库托管一些测试代码和实验结果，旨在研究减少此类代码开销的方法。</p><p>我试着想出一些可能对上述行为有影响的场景，并将它们实现到此测试应用程序中。</p><p>最好查看代码以查看正在运行的测试，但是下面列出了所尝试的想法的摘要：</p><p>显而易见的方法-即，只需编写代码并执行它，如本页面顶部所示(在结果中标记为jit_Plain)。还会测试反向编写代码，以查看这是否有任何效果(标记为jit_verse)。</p><p>参考：JIT-TO并执行单独的位置。这并没有达到上面的目的，因为它实际上并没有执行JIT代码，而是用来演示没有代价的理想情况(标记为jit_only)，以及计算处理器上的SMC代价。</p><p>将代码写入不可执行内存(临时位置)，然后使用包括memcpy(标记为jit_memcpy*)在内的一系列技术将其复制到分配的可执行内存。如果内存复制意味着命中可执行内存的写操作较少，则可能意味着需要较少的同步/刷新。</p><p>在编写代码之前‘清除’可执行内存，即使用Memset用空字节覆盖区域，或者通过向每个64字节缓存线(标记为jit_clr*)写入一次来采取快捷方式。也许这有助于在JIT进程缓慢执行之前快速使缓存失效？</p><p>在编写代码之前/之后刷新缓存线(标记为jit_clflush*)。也许这有助于提前将数据从单独的L1指令/数据高速缓存中推送出来？</p><p>将代码预取到二级缓存，带/不带写提示(标记为jit_prefetch*)。L1缓存单独的数据和指令，但L2是共享的，因此对指令数据的任何更改在到达指令缓存之前都必须经过L2。预取通常用于将数据提升到较低级别的高速缓存，而不是降级到较高级别，但也许某些处理器可以注意到写入提示并相应地执行操作。</p><p>在可执行代码的开头保留一条UD2指令，直到JIT过程完成(标记为jit_ud2)。也许这有助于防止处理器在写入代码时预取代码</p><p>在多个预先分配的页面(标记为jit_*region)之间交替。这可能有助于降低JIT写入触及缓存以供执行的内存的可能性，但是，就缓存使用而言，这是相当昂贵的。</p><p>尝试通过跳过大量缓存行(标记为jit_jmp*)来清除指令缓存。但是，可能会颠簸指令缓存。</p><p>查看在编写和执行代码之间是应用内存围栏(MFENCE指令)还是序列化操作(CPUID指令)会有什么不同(标记为jit_mfigure和jit_Serialize)。</p><p>向映射到同一物理页的不同虚拟地址写入和执行(标记为jit_DUAL_MAPPING)。英特尔手册建议，在执行编写的代码之前，此类行为需要序列化指令，这可能意味着无需调用自修改代码行为即可编写代码。</p><p>请注意，JIT例程本身会逐个写出指令，并且不会尝试将多条指令批处理到一次写入中。</p><p>使用RDTSC指令测试性能。为了减少可变性，在多次迭代中对其进行测量，并执行多次试验以找到最快的度量。</p><p>下面列出的结果在不同的处理器微体系结构中差异很大。测试在各种系统上执行，包括在虚拟机上执行。所有代码都是用GCC为x86-64编译的。</p><p>在足以超过一级缓存大小的多个区域之间交替似乎是最有效的技术(Jit_16region)，但是这可能会影响其他代码的性能。</p><p>在编写代码之前清除目标是第二有效的方法(比上面略差)，特别是在每个缓存行只清除一个字节(Jit_Clr_1byte)的情况下。</p><p>在Haswell及更高版本(Jit_Jmp32k_Unalign)中，使用触及所有缓存线的跳转清除指令缓存似乎也是有效的。这可能会影响其他代码的性能，因为它会有效地清除指令高速缓存。</p><p>Silvermont(原始结果)拷贝似乎是最有效的，特别是在拷贝中使用非临时写入时(Jit_Memcpy_SsE2_Nt)。</p><p>在该区域发出CLFLUSH(Jit_Clflush)或PREFETCHW(Jit_Prefetchw)似乎也有效(我以为Silvermont不支持Broadwell中添加的PREFETCHW指令，但事实证明，它支持来自3DNow的PREFETCHW指令！)。</p><p>Goldmont(原始结果)最有效的技术似乎是使用非临时写入进行复制(Jit_Memcpy_Sse2_Nt)，使用非临时写入清除内存(Jit_Clr_SsE2_Nt)，或者在写入之前在可执行区域上发出CLFLUSHOPT(Jit_Clflushopt)。</p><p>使用非临时写入(Jit_Memcpy_Sse2_Nt)进行拷贝似乎比直接方法略有优势。</p><p>Zen1(原始结果)复制似乎是唯一有效的方法(jit_memcpy*)。与此处的其他CPU不同，非临时写入的性能较差。</p><p>与英特尔酷睿CPU不同，在英特尔酷睿CPU上，覆盖指令代码似乎会使指令缓存中的数据无效，而Zen1似乎保持了两者之间的某种同步。这意味着，重复覆盖指令高速缓存中存在的相同代码可能会产生减慢效果，即使该代码以后永远不会执行也是如此</p><p>piledriver(原始结果)复制(jit_memcpy*)和清除(jit_clr*)以及发出PREFETCHW指令(Jit_Prefetchw)都是有效的。</p><p>尽管根据英特尔的文档，如果x86处理器位于不同的虚拟地址，则它们不需要同步代码/指令数据，但我发现，如果这些处理器指向相同的物理地址，则它们无论如何都会同步代码/指令数据。我发现，即使删除了同步指令，代码仍然可以工作。</p><p>在这里的结果中没有显示，但是我确实使用4KB的代码而不是1KB的代码进行了测试，并且发现测量到的时间也大约是原来的四倍。这表明SMC损失与编写的代码量成正比，因此在执行任何函数之前编写多个函数的想法似乎没有太大帮助(除非它足以超过一级指令高速缓存，并且处理器是Intel Core处理器)。</p><p>为了使本页不只是文本，这里有一个图表向您展示了一些可视化的东西，将SMC惩罚与上面指出的显而易见的解决方案和最佳解决方案进行了比较：</p><p>请注意，所测试的处理器/系统之间存在显著差异，因此可能不应该比较处理器之间的测量结果，但它仍然可以显示使用上面找到的技术可以进行多大程度的改进。</p><p>通过应用上面列出的一些技术，可以提高本文档顶部显示的示例的性能，通常会有相当大的提高。不幸的是，没有单一的“最佳解决方案”，因为它随底层微体系结构的不同而不同。</p><p>从我已有的结果(以及我对我没有的结果的猜测)来看，最好的解决方案是：</p><p>如果CPU是Intel Core(Nehalem或更高版本)：在内存区域(足以大于一级缓存大小)之间交替，即JIT到位置1，执行位置1，JIT到位置2，等等，并循环(Jit_16region)</p><p>如果上述情况不可能实现，或者缓存命中不可接受，则在实际写入指令(Jit_Clr_1byte)之前，清除要写入的区域中的每64字节缓存行1个字节。</p><p>否则，如果CPU是英特尔凌动、英特尔酷睿2、AMD系列15h或AMD K10：将代码写入临时位置，然后使用非临时写入(Jit_Memcpy_Sse2_Nt)复制到目标。SSE1/2写入就足够了，因为这些CPU都没有256位加载/存储端口。</p><p>否则，如果CPU是AMD系列17h、18h或更新的AMD：将代码编写到临时位置，然后复制到目标位置(rep mov似乎是最佳选择(Jit_Memcpy_Movsb)，但memcpy也可能工作得很好(Jit_Memcpy))。</p><p>可能没有得到足够的重视，但我要强调的是，这里的结果特定于这里检查的测试用例。如果您实施单次使用的JIT算法，结果可能会因编写的代码量和写入方式的不同而有所不同(例如，较少的写入操作将比大量较小的写入执行得更好)。</p><p>欢迎对此处未列出的处理器进行测试，以及任何其他发现、更正和建议。</p><p>该代码当前未实现动态运行时调度，因此应在运行该代码的计算机上使用带有-MARCH=NATIVE标志的GCC/Clang进行编译。可使用以下命令编译此测试：</p><p>注意，在某些Linux发行版上，您可能还需要在末尾添加-lrt。</p><p>在运行测试时，我注意到结果有很大的变异性。代码确实尝试通过运行多个试验和运行速度最快的方式来满足这一要求，但是在运行测试之前将CPU调控器/电源配置文件设置为性能并禁用turbo Boost可能是有益的。请注意，虽然我没有针对任何结果执行此操作。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/animetosho/jit_smc_test/blob/master/README.md">https://github.com/animetosho/jit_smc_test/blob/master/README.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jit/">#jit</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1009523.html"><img src="http://img.diglog.com/img/2020/7/thumb_004ecd63b6b98209690443323b8e26bb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1009523.html">在极端压力下保持性能</a></div><span class="my_story_list_date">2020-7-3 1:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1009452.html"><img src="http://img.diglog.com/img/2020/7/thumb_26fdee2c448461ddf132a6d952b03710.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1009452.html">x86处理器上的单机JIT性能</a></div><span class="my_story_list_date">2020-7-2 18:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1008644.html"><img src="http://img.diglog.com/img/2020/6/thumb_b37af4f24ba713f8155fd205563e941a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008644.html">针对电池续航时间和性能优化Linux笔记本电脑的广泛指南</a></div><span class="my_story_list_date">2020-6-28 3:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1008022.html"><img src="http://img.diglog.com/img/2020/6/thumb_3672abea6447c64aa1164dbf005e43a6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008022.html">WIFF代码中的C编译器性能迷惑</a></div><span class="my_story_list_date">2020-6-25 5:12</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>