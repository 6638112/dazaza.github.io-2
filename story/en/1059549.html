<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将厄运移植到速度无服务器平台 Porting Doom to the Fastly edge serverless platform</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Porting Doom to the Fastly edge serverless platform<br/>将厄运移植到速度无服务器平台 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 11:38:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/d28efc7b0852e5e4f4b490d9c0f778b2.png"><img src="http://img2.diglog.com/img/2021/4/d28efc7b0852e5e4f4b490d9c0f778b2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Due to its approachable codebase and clean abstractions,   id Software’s DOOM has become one of the most ported games in history. It felt like a perfect project to port to Compute@Edge, built on our serverless compute environment, to experiment with different applications of the product.</p><p>由于其可接近的Codebase和清洁抽象，ID软件的厄运已成为历史上最往返的游戏之一。它感觉像是一个完美的项目到occumpute @ Edge，基于无服务器计算环境，以试验产品的不同应用。</p><p> Showing that DOOM could run interactively on Compute@Edge would be a way to push the boundaries of performance on the product and have a tangible demo that we could point to as a stake in the ground — showcasing the exciting possibilities Compute@Edge presents. Let’s explore how we did it.</p><p> 显示厄运可以在计算@边缘交互地运行，这将是推动产品上性能界限的方式，并且有一个有形的演示，我们可以指向地面的股份 - 展示令人兴奋的可能性@ Edge Presents Compute @ Edge礼物。让我们探索我们如何做到。</p><p>  DOOM was a game developed in 1993 by id software and released in December of that year. Id software had made a living developing high-quality 2D games, but with Wolfenstein in 1992 and then DOOM the following year, they made a historic leap into 3D, taking advantage of the quickly evolving PC hardware landscape to push the boundaries of the industry.</p><p>  厄运是1993年由ID软件开发的游戏，并于当年12月发布。 ID软件已成为开发高质量的2D游戏的生活，但是在1992年的Wolfenstein，然后举行了次年，他们将历史悠久的飞跃进入3D，利用了快速发展的PC硬件景观来推动行业的边界。</p><p> DOOM was open sourced in 1997 with the README carrying the words, “Port it to your favorite operating system”. Many fans did just that, with DOOM being ported to hundreds of platforms, from the obvious to the obscure. As both a fan of DOOM and an employee of Fastly, I wanted to test the potential of Compute@Edge. Here’s how I brought this iconic video game to Compute@Edge.</p><p> 1997年，厄运是在1997年开放的，自述人员携带这些词，“将其移到您最喜欢的操作系统”。许多粉丝只是这样做，厄运被移植到数百个平台，从显而易见的是模糊的。作为厄运和员工速度的粉丝，我想测试计算@ Edge的潜力。以下是我将这种标志性的视频游戏带来计算@ Edge的方式。</p><p> Worth noting: the “  Game Engine Black Book” by Fabien Sanglard is a fantastic resource that was referred to frequently during this project. This, and his other book about   Wolfenstein, are well-researched deep dives into key moments of game development history and are entertaining and educational.</p><p> 值得注意的是：Fabien Sanglard的“游戏发动机黑书”是这个项目中经常被称为奇妙的资源。这是关于沃尔芬斯坦的另一本关于Wolfenstein的书，很深远地进入游戏开发历史的关键时刻，并正在娱乐和教育。</p><p>   Get the platform-independent code (i.e. code not relying on any specific architecture/platform syscalls or SDKs) compiling and running. This is the bulk of what most would consider the “gameplay.”</p><p>   获取独立于平台的代码（即代码不依赖于任何特定的体系结构/平台SYSCALL或SDK）编译和运行。这是大多数人都将考虑“游戏玩法”。</p><p> Replace platform-specific API calls as necessary for the target platform. This is code that mainly deals with input and output, including rendering and audio.</p><p> 根据目标平台替换特定于平台的API呼叫。这是主要处理输入和输出的代码，包括渲染和音频。 </p><p> There is no official public interface for C bindings, so to try at home, you’ll have to deduce the C APIs from the fastly-sys crate.</p><p>对于C绑定没有官方公共接口，因此在家中尝试，您将必须从速度 -  SYS箱中推断C API。</p><p>  Getting DOOM running without rendering or audio on Compute@Edge was fairly straight forward. The codebase has prefixes on every function name, and it conveniently uses “I_” for all the implementation specific functions, so it was easy enough to go through the codebase and remove these from compilation. Once that was done, I used   wasi-sdk to target a Wasm binary. WebAssembly is designed to compile native code without much fuss, so this change was very straight forward.</p><p>  在没有渲染或音频上播放的厄运运行或在Compute @ Edge上相当直截了当。 CodeBase在每个函数名称上都有前缀，方便地使用“i_”来实现所有实现特定功能，因此易于通过CodeBase并从编译中删除这些功能。一旦完成了，我使用WASI-SDK来定位母乳二进制。 WebAssAseMbly旨在编译本机代码而无需大惊小怪，因此这种变化非常直接。</p><p> The fixes I needed to make to get the game running as a WebAssembly binary were related to DOOM being developed in a time of 32-bit computing. There are a number of places where the code assumes pointers were 4 bytes, which, at the time, was a perfectly reasonable choice to make. Data in DOOM is loaded from a file that contains all the assets created by the development team and bundled together at release time. This data is loaded directly into memory and cast to the in-game C structure that it represents. If there are any pointers involved in these structures, loading the data in a 64-bit environment would result in the data not overlaying properly on the structure, thus resulting in unexpected behaviour. These were fairly straightforward to track down, and would result in fairly obvious crashes initially.</p><p> 我需要使游戏作为网上装配二进制文件所需的修复与在32位计算时开发的厄运有关。代码假定指针的一些地方是4个字节，当时是一个完全合理的制作的选择。厄运中的数据从包含开发团队创建的所有资产的文件加载，并在发布时间内捆绑在一起。该数据直接加载到内存中并投用到它代表的游戏内C结构。如果这些结构中涉及任何涉及的指针，请在64位环境中加载数据将导致数据在结构上正确覆盖，从而导致意外行为。这些相当简单地追踪，并且最初会导致相当明显的撞车。</p><p>  In order to get the common code running on Compute@Edge, I had to refactor the traditional game loop that DOOM employed. A typical game will initialize and then run in an endless loop, doing an input-&gt;simulation-&gt;output tick over and over at the desired frequency, taking inputs from the local input devices such as a keyboard, mouse, or controller, and outputting video and audio. On Compute@Edge, however, a process like this will eventually be evicted by the platform, since the intent is for the instance to start up, do some work, and then return to the caller. I thus removed the loop entirely and changed the instance to only run a single frame of the game.</p><p>  为了获得在Compute @ Edge上运行的公共代码，我必须重构厄运使用的传统游戏循环。典型的游戏将初始化，然后在无限循环中运行，进行输入和gt;仿真 - ＆gt;以所需的频率逐渐滴定，从键盘，鼠标或控制器等局部输入设备上取消输入，并输出视频和音频。然而，在Compute @ Edge中，平台最终将释放这样的过程，因为意图是为了启动实例，请执行一些工作，然后返回调用者。因此，我完全删除了循环并将实例更改为仅运行单个游戏帧。</p><p>   In the following sections, I will go into more detail about each of these steps.</p><p>   在以下部分中，我将详细了解每个步骤。</p><p>  In video games, the memory that holds the final image that is displayed to the player is called the  framebuffer. In modern games, the framebuffer is often constructed in specialized GPU hardware, as the final image is often the result of running a number of pipeline steps on the GPU. In 1993, however, rendering was done in software, and in DOOM, the final buffer was available to the programmer in a basic C array. This design made porting DOOM to new platforms relatively painless, as it gave porting developers a simple, understandable starting point to work from.</p><p>  在视频游戏中，保存到播放器的最终图像的内存称为帧缓冲。在现代游戏中，帧缓冲器通常在专业的GPU硬件中构建，因为最终图像通常是在GPU上运行多个管道步骤的结果。但是，1993年，渲染是在软件中完成的，并且在厄运中，将在基本C阵列中的程序员中使用最终缓冲区。这种设计使厄运移植到新的平台相对无痛，因为它给开发人员提供了一个简单，可以理解的起点来工作。</p><p> In the case of Compute@Edge, I wanted to return the framebuffer to the player’s browser where it could be displayed. This was as simple as using the C API to write the framebuffer to a response body and then send that body downstream:</p><p> 在Compute @ Edge的情况下，我想将帧缓冲返回到播放器的浏览器，在那里可以显示它。这与使用C API写入响应机身的CAPI时一样简单，然后在下游发送该正文： </p><p>  When the client running in the browser receives the http response from Compute@Edge, it will parse out the framebuffer and render it in the browser.</p><p>当浏览器中运行的客户端从Compute @ Edge接收HTTP响应时，它将解析帧缓冲并在浏览器中渲染它。</p><p>  Replicating the game loop in this new model requires us to save state somewhere, so that when we call Compute@Edge for subsequent frames, we can tell the new instance where we were in the game. I was able to take advantage of the save-load functionality present in the game, which originally provided the player the ability to save the state of the game to disk, and then later reload the game and continue playing where they left off.</p><p>  在这个新模型中复制游戏循环要求我们在某处保存状态，以便当我们调用Compute @ Edge供后续帧时，我们可以告诉我们在游戏中的新实例。我能够利用游戏中存在的节省负载功能，最初提供了将游戏节省游戏状态的磁盘，然后重新加载游戏并继续在他们离开的地方进行播放。</p><p> I used the same mechanism for state as for the framebuffer: at the end of the game frame, I called into the save system to get a buffer representing the game state, and then I piggybacked that onto the framebuffer when returning the http response to the caller.</p><p> 我使用与帧缓冲区的状态相同的机制：在游戏框架的末尾，我调用了保存系统以获取代表游戏状态的缓冲区，然后我返回到帧缓冲区时返回HTTP响应时返回到帧缓冲区呼叫者。</p><p> // gets a pointer to the framebuffer byte* resp = GetFramebuffer(&amp;framebuffer_size); // gets the gamestate, appends it to the framebuffer resp+fb_size = GetGameState(&amp;state_size);  BodyWrite(bodyhandle, framebuffer, framebuffer_size + state_size,...); SendDownStream(handle, bodyhandle, 0);</p><p> //获取到FrameBuffer字节* Resp = GetFrameBuffer（＆amp; FrameBuffer_size）的指针; //获取GameState，将其附加到帧缓冲区resp + fb_size = getgamestate（＆amp; endy_size）; Bodywrite（BodyHandle，FrameBuffer，FrameBuffer_Size + State_size，......）; senddownstream（手柄，bodyhandle，0）;</p><p> Accompanying this change, the client was modified to separate the framebuffer and state and keep the state stored locally, while displaying the framebuffer in the browser. The next time it issues a request to Compute@Edge, it will pass the state in the request body, which the Compute@Edge instance can then read from the request body and pass into game like so:</p><p> 随附此更改，修改客户端以分离帧缓冲和状态并保持本地存储的状态，同时在浏览器中显示帧缓冲区。下次发出计算@ Edge的请求时，它将在请求主体中传递该状态，然后将计算@ Edge实例从请求身体读取并进入游戏，如下所示：</p><p>  At this point, if we run our game frame, it will occur as if it happened the tick after the game state was saved.</p><p>  此时，如果我们运行我们的游戏框架，它将发生，好像它在保存游戏状态后发生勾号。</p><p>  The next thing we need is user input so the player can actually play the game! DOOM’s input system is abstracted over the concept of input events. For example, “the player pressed key ‘W,’” or “the player moved the mouse X distance.” We can generate input events in the browser that map to what DOOM expects fairly easily using standard Javascript event listeners:</p><p>  我们需要的下一件事是用户输入，所以玩家实际上可以播放游戏！厄运的输入系统是用输入事件的概念抽象的。例如，“播放器按下键”w，'或“播放器移动鼠标x距离。”我们可以使用标准的JavaScript事件侦听器在浏览器中生成浏览器中的输入事件，该浏览器将使用标准的JavaScript事件侦听器更轻松地预期： </p><p> document.addEventListener(‘keydown’, (event) =&gt; {	 // save event.keyCode in a form we can send later});</p><p>document.addeventListener（'keydown'，（事件）=＆gt; {//保存事件。{//保存事件以稍后的表格中的表单}）;</p><p> I send these input events along with the state when making the http request to Compute@Edge. The instance then parses them into a form we can pass into the game engine before running the frame.</p><p> 我在使HTTP请求计算@ EDGE时，请将这些输入事件与状态一起发送。然后，实例将它们解析为我们可以在运行帧之前传入游戏引擎的表单。</p><p>  The first working version of this demo ran at ~200ms per round trip. This is not acceptable for an interactive game. Typical games run at 33ms which translates to 30FPS, or 16ms, which translates to 60FPS. Given that latency would be a non-trivial part of our update frequency, I decided that 50ms was a good target to aim for, which is a 4x improvement over the base version.</p><p>  这个演示的第一个工作版本在每轮旅行中达到〜200ms。互动游戏是不可接受的。典型的游戏在33毫秒运行，它转换为30fps或16ms，转换为60fps。鉴于延迟将是我们更新频率的非平凡部分，我决定瞄准50毫秒，这是对基本版本的4倍改善。</p><p> A number of optimizations I managed to implement were centered around the change from running a continuous game loop to running a single frame. A lot of game systems are designed around the notion that each tick is a delta of the previous frame. The game keeps state that is not captured in the save game but that is used each frame to make decisions. A number of these systems needed tweaking both to ensure functionality worked properly and for performance reasons. A lot of these systems worked best if they were working as if they were not the first frame, at which time a lot of variables and state were initialized.</p><p> 我设法实现实现的许多优化在运行连续游戏循环到运行单个帧时居中居中。许多游戏系统围绕每个刻度为前一帧的三角洲的概念设计。游戏保持状态不会在保存游戏中捕获，但是使用每个帧进行决策。许多这些系统需要调整，以确保功能正常工作并出于性能原因。如果他们正在工作好像不是第一帧，那么许多这些系统都可以获得最佳，此时初始化了大量变量和状态。</p><p> The game did a number of precomputation on startup, mostly involving trigonometry for doing view space to world space calculations. These precomputed tables also required knowing the screen resolution of the game, which is why they were done at runtime. For my purposes, I was keeping the rendering resolution fixed, and I could just embed the tables into the compiled binary and avoid doing this startup computation every frame.</p><p> 该游戏在启动时做了许多预测，主要涉及三角形，用于对世界空间计算进行视图空间。这些预先计算的表也需要了解游戏的屏幕分辨率，这就是他们在运行时完成的原因。出于我的目的，我正在保持渲染分辨率修复，我可以嵌入表格到编译的二进制文件，并避免每帧执行此启动计算。</p><p> I managed to get the game running at 50-75ms per tick. There is still work that could be done to bring this closer to what DOOM shipped with, but this proved that we could iterate on a project like this on Compute@Edge.</p><p> 我设法让游戏每次刻度为50-75毫秒运行。仍然可以做到这一点，可以将这种越来越靠近博览会，但这证明我们可以在Compute @ Edge上迭代这样的项目。</p><p>  This was my first foray into Compute@Edge, and I wasn’t sure what to expect in terms of debugging and iterating. The platform is being actively and continuously improved, and throughout the three weeks I worked on this, I saw improvements take shape, improving deployment reliability and debuggability. Specifically, I want to call out   Log Tailing, which allowed me to see prints coming out of DOOM in near real time. When iterating on a fairly opaque C program, especially before I had rendering working, seeing these prints was imperative for debugging problems. Overall, deploying to Compute@Edge was similar to working on a traditional video game console, for example.</p><p>  这是我第一次进入Compute @ Edge，并且我不确定在调试和迭代方面如何期待。该平台正在积极和不断改进，并且在整个三周内工作，我看到了改进，成形，提高了部署可靠性和调试性。具体而言，我想调用日志尾拖，这让我可以在近实时看到厄运出来的印刷品。在相当不透明的C程序迭代时，特别是在我有渲染工作之前，看到这些印刷品对调试问题势在必行。总的来说，部署到计算@ Edge类似于在传统的视频游戏控制台上工作。 </p><p> To be clear, this would not be an ideal solution for running a real-time game requiring game updates at a timely frequency. There are no real advantages to be gained by running a game of this sort in this manner. The purpose of this experiment was to push the boundaries of the platform, to create a compelling demo to discover and showcase possibilities, and to provide inspiration and excitement for the platform. There are surely use cases for video games utilizing this platform, and we are excited to continue investigating ways to make Compute@Edge a compelling product for more industries going forward.</p><p>要清楚，这不是运行实时游戏需要在及时频率的实时游戏的理想解决方案。通过以这种方式运行这种排序游戏，没有真正的优势。该实验的目的是推动平台的界限，创造一个引人注目的演示，以发现和展示的可能性，并为平台提供灵感和兴奋。利用这个平台的视频游戏肯定使用案例，我们很高兴继续调查为更多行业进行推动的产品来调查计算@ Edge。</p><p> If you want to try the demo yourself, we have it running on our Developer Hub.   Check it out.</p><p> 如果您想自己尝试演示，我们将在我们的开发人员中心运行。一探究竟。</p><p>  We send emails from time to time about upcoming events, new products, &amp; the latest industry trends, but only if you want them. Check the box to consent to receive these messages.</p><p>  我们不时向即将到来的活动，新产品，＆amp发送电子邮件;最新的行业趋势，但只有你想要他们。选中该框以同意接收这些消息。</p><p>  By submitting your request, you consent to your information being transmitted to Fastly in the United States for processing consistent with our  Privacy Policy.</p><p>  通过提交您的请求，您同意您在美国迅速传输的信息，以便处理与我们的隐私政策一致。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.fastly.com/blog/compute-edge-porting-the-iconic-video-game-doom">https://www.fastly.com/blog/compute-edge-porting-the-iconic-video-game-doom</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/移植/">#移植</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/doom/">#doom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>