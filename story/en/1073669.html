<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用同步中断修复脆弱的dbt测试Fixing flaky dbt tests with a sync cutoff</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fixing flaky dbt tests with a sync cutoff<br/>用同步中断修复脆弱的dbt测试</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 02:42:58</div><div class="page_narrow text-break page_content"><p>I work at  incident.io, a start-up in London that just built our first data stack using  Fivetran for ETL and dbt for transformations.</p><p>我在事故现场工作。io是伦敦的一家初创公司，它刚刚使用Fivetran进行ETL，使用dbt进行转换，构建了我们的第一个数据堆栈。</p><p> While we built the pipeline for internal use only, we soon realised Metabase could provide much better dashboards for our internalproduct than our  scrappy  basic Javascript graphs.</p><p>虽然我们构建的管道仅供内部使用，但我们很快意识到，Metabase可以为我们的内部产品提供比我们零碎的基本Javascript图形更好的仪表盘。</p><p>   This would be fine, except we’d accepted some compromises while building forourselves that we couldn’t if we were to provide this data to our customers.Namely, our dbt tests were flaky, and there was no way we’d ship a data productwhere our tests would regularly fail.</p><p>这很好，但我们在为自己建设时接受了一些妥协，如果我们向客户提供这些数据，我们就无法做到这一点。也就是说，我们的dbt测试是脆弱的，我们不可能发布一个测试经常失败的数据产品。</p><p>   --- version :  2 models :  -  name :  actions  description :  Incident actions  columns :  -  name :  organisation_id  description :  &#34; Organisation   ID&#34;  tests :  -  not_null  -  relationships :  to :  ref(&#39;organisations&#39;)  field :  organisation_id</p><p>---版本：2个模型：-名称：行动描述：事件行动列：-名称：组织id描述：&#34；组织ID&#34；测试：-非空-关系：to:ref（&#39；组织&#39；）字段：组织id</p><p> This test gets dbt to confirm all  organisation_id values in the actions table appear in  organisations. Put simply,have we screwed something up in our join, or does the data look good?</p><p>该测试让dbt确认行动表中的所有组织id值都出现在组织中。简单地说，我们是不是在加入时搞砸了什么，还是数据看起来不错？</p><p> According to our test suite, the data  did not look good. But only on someruns, where about once every three runs of the test suite we’d see an error likethis:</p><p>根据我们的测试套件，数据看起来不太好。但只有在某些情况下，测试套件每三次运行一次，我们就会看到如下错误：</p><p> Failure in test relationships_incident_actions_organisation_id__ref_organisations_ (models/staging/product/stg_product.yml)Got 1 result, configured to fail if != 0compiled SQL at target/compiled/analytics/models/staging/product/stg_product.yml/relationships_inc_e2d88f3fd5bd723431990564532e121c.sql</p><p>测试关系失败_事件_行动_组织_id u参考u组织uu（models/staging/product/stg_product.yml）得到1个结果，如果！=0目标/已编译/分析/模型/登台/产品/stg_产品的完整SQL。yml/relationships_inc_e2d88f3fd5bd723431990564532e121c。sql</p><p> This isn’t the clearest output, but it can understood as “there wereorganisation IDs in the actions table that had no match in the organisationstable”.</p><p>这不是最清晰的输出，但可以理解为“actions表中的Organization ID与Organization Stable中的ID不匹配”。</p><p>   We use Fivetran to pull data from our Postgres database, the source of theorganisation and incident actions, into our BigQuery data warehouse.</p><p>我们使用Fivetran将Postgres数据库中的数据（组织和事件行动的来源）拉入BigQuery数据仓库。</p><p> In Postgres-land, you can expect to be running with a (mostly) consistent viewof data across all tables. Even with respect to individual queries, data isinserted and updated atomically, so it would be very strange for you to find aresource that references something in another table where that reference doesnot exist.</p><p>在Postgres land中，您可以期望在所有表中以（基本上）一致的数据视图运行。即使对于单个查询，数据也是以原子方式插入和更新的，因此，如果您在另一个表中找到一个引用了不存在该引用的内容的源，那将是非常奇怪的。</p><p> That begs the question: if we’re sourcing our data from Postgres, which isconsistent, what gives with these broken relations?</p><p>这就引出了一个问题：如果我们从Postgres获取数据，这是一致的，那么这些断裂的关系会带来什么？</p><p> Well, while Postgres might be consistent, the resulting BigQuery data warehouseis not. The syncing process for Fivetran can be reduced to this psuedo-code:</p><p>虽然Postgres可能是一致的，但由此产生的BigQuery数据仓库却不一致。Fivetran的同步过程可以简化为以下psuedo代码：</p><p> every 15 minutes: for table in database.all_tables: changes_since_last_sync = table.get_changes_since(table.last_synced) table.last_synced = now() warehouse.insert(table, changed_since_last_sync)</p><p>每15分钟：用于数据库中的表。所有表格：自上次同步以来的更改。获取自（table.last_Synched）表以来的更改。last_synced=now（）仓库。插入（表格，自上次同步以来已更改）</p><p> BigQuery does not provide consistency across multiple tables, so we end upproducing a ‘jagged’ dataset, where each table is synced to a different point intime.</p><p>BigQuery不提供跨多个表的一致性，因此我们最终生成了一个“锯齿”数据集，其中每个表在同一时间同步到不同的点。</p><p>     If after t0, but before t2, we add an organisation and some incident actionsthat relate to it, then our sync will have skipped the organisation but includedthe actions.</p><p>如果在t0之后，但在t2之前，我们添加了一个组织和一些与之相关的事件操作，那么我们的同步将跳过该组织，但包含这些操作。</p><p> That’s the cause of our failing tests, and why they fail randomly (flake): itentirely depends on when Fivetran has performed a sync and what data may havebeen missed on whether the test fails.</p><p>这就是我们测试失败的原因，也是它们随机失败的原因（flake）：这完全取决于Fivetran何时执行了同步，以及测试是否失败可能遗漏了哪些数据。</p><p>  In an ideal world, our BigQuery warehouse would have tables that contain updatesup-to a consistent cutoff, applied equally across all tables. That would avoidus having patchy relations, and allow us to lean on our tests.</p><p>在理想情况下，我们的BigQuery仓库中的表包含一致截止的更新，在所有表中应用相同。这将避免我们的关系不协调，并允许我们依靠我们的测试。</p><p>  First, we create a dbt model  sync_watermarks that estimates a timestamp thatis safely before the start of the last Fivetran run.</p><p>首先，我们创建一个dbt模型sync_水印，该模型估计在最后一次Fivetran运行开始之前安全的时间戳。</p><p>  -- models/sync_watermarks.sql {{  config (  materialized  =  &#34;table&#34; ,  ) }} -- This table marks the point at which we&#39;ve run dbt. The -- cutoff is used to filter any very recent changes from each -- database table, allowing us to ensure each table in the -- dataset is consistent, even when syncs happen at different -- periods. --  -- 20m is chosen as Fivetran attempts to sync every 15m, which -- should complete in &lt;1m. Going back 20m ensures we cutoff -- safely after the start of the last complete sync, meaning -- each table will be consistent. select  timestamp_sub ( current_timestamp (),  interval  20  minute )  as  cutoff_at</p><p>--模型/同步_水印。sql{config（物化=&#34；表&#34；，）}——这个表标记了我们&#39；我运行dbt。--cutoff用于过滤每个--database表中最近的任何更改，使我们能够确保--dataset中的每个表是一致的，即使同步发生在不同的--period。---当Fivetran每15米尝试同步一次时，选择20米，这应该在&lt；100万。返回20米可以确保我们在最后一次完整同步开始后安全地切断，这意味着每个表都是一致的。选择时间戳_sub（当前时间戳（），间隔20分钟）作为截止时间</p><p> As our Fivetran syncs every 15m, and each sync completes in ~1m, we know alltables will have completed a sync &lt;20m ago, at which point it will contain alldata up-to and beyond that cutoff.</p><p>由于我们的Fivetran每15米同步一次，并且每次同步在大约1米的时间内完成，我们知道所有表都将完成一次同步&lt；2000万年前，届时它将包含截止日期之前和之后的所有数据。</p><p> This means we can apply the cutoff to all tables, ignoring any inconsistent syncprogress beyond that point.</p><p>这意味着我们可以将截止应用于所有表，忽略超出该点的任何不一致的同步进度。</p><p> Note that we’ve materialised this table so it gets calculated just once, at thestart of our dbt run. This is as opposed to a view, where any time we query thetable, the value of  current_timestamp() would change.</p><p>请注意，我们已经将这个表具体化，所以在dbt运行开始时只计算一次。这与视图相反，在视图中，每当我们查询表时，current_timestamp（）的值都会改变。</p><p> Then for each of our table models, we apply the cutoff against the row createdat:</p><p>然后，对于每个表模型，我们对createdat行应用截止值：</p><p> with source  as  (  select  *  from  {{  source ( &#39;core_production_public&#39; ,  &#39;organisations&#39; )  }} ,  {{  ref ( &#39;sync_watermarks&#39; )  }}  sync_watermarks  where  _fivetran_deleted  is  null  and  created_at  &lt;  sync_watermarks . cutoff_at ), renamed  as  (  select  /* ... */  from  source ) select  *  from  renamed</p><p>源代码为（从{source（&#39；core#u production#u public&#39；，&#39；organizations&#39；）}中选择*，{{ref（&#39；sync#u水印&#39；）}同步_水印，其中_fivetran _deleted为空，并在&lt；同步水印。截止时间），重命名为（选择/*…*/从源代码）选择*从重命名</p><p> Using  ref(&#39;sync_watermarks&#39;) means dbt will know to build thewatermark before our model, as it will track the dependency in dbt’s graph.</p><p>使用ref（&#39；sync#u水印&#39；）这意味着dbt将知道在我们的模型之前构建水印，因为它将跟踪dbt图形中的依赖关系。</p><p> We apply the same pattern to the rest of our database tables, ensuring eachtable has a consistent cutoff.</p><p>我们对其余的数据库表应用相同的模式，确保每个表都有一个一致的截止点。</p><p>   We don’t just sync data from our Postgres database: we pull it from a variety ofsources, such as Segment or social media, all of which might reference corePostgres resources.</p><p>我们不只是从我们的Postgres数据库同步数据：我们从各种资源中提取数据，比如细分市场或社交媒体，所有这些都可能引用corePostgres资源。</p><p> If we see similar flaky test issues, we can reuse the cutoff on these modelstoo. We do just that for our BigQuery event tables which are written to inrealtime from the product.</p><p>如果我们看到类似的片状测试问题，我们可以在这些ModelsTo上重复使用截止。我们对BigQuery事件表就是这样做的，这些表是从产品实时写入的。</p><p>   There’s many ways to solve this problem, but this is simple and quick, and hasthe advantage of saving the cutoff into your data warehouse if you ever need toreference or check it.</p><p>有很多方法可以解决这个问题，但这是简单而快速的，并且如果需要引用或检查数据仓库，可以将中断保存到数据仓库中。</p><p> Whether you use this or something else, it’s important to avoid flaky tests.When first applying the cutoff, I was unsurprised to discover failures that wereunrelated to the cutoff, and were legitimate bugs.</p><p>不管你是用这个还是别的什么，避免不可靠的测试都很重要。当我第一次应用中断时，我发现与中断无关的故障是合法的错误，这并不奇怪。</p><p> While it was the right decision to ignore these failures when prototyping, I’mglad we sorted it before exposing this data to our customers.</p><p>虽然在原型设计时忽略这些失败是正确的决定，但我建议在向客户公开这些数据之前先对其进行分类。</p><p> Life is just less stress when you have a test suite you can depend on!</p><p>当你有一套可以依赖的测试套件时，生活的压力就更小了！</p><p>  Discuss this post on  Hackernews. If you liked this post and want to see more, follow me at  @lawrjones.</p><p>在Hackernews上讨论这篇帖子。如果你喜欢这篇文章，想看到更多，请点击@lawrjones跟我来。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/中断/">#中断</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/flaky/">#flaky</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>