<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Pure Bash Bible–外部进程的纯Bash替代方案的集合</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pure Bash Bible–外部进程的纯Bash替代方案的集合</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 16:15:30</div><div class="page_narrow text-break page_content"><p>本书的目标是记录只使用内置bash特性来完成各种任务的常见方法和鲜为人知的方法。使用本《圣经》中的片段有助于从脚本中删除不必要的依赖项，并且在大多数情况下使它们更快。我在开发neofetch、pxltrm和其他较小的项目时遇到了这些技巧，并发现了一些。</p><p>下面的代码片段是使用shellcheck编写的，并在适用的情况下编写了测试。想要贡献吗？阅读投稿。它概述了单元测试是如何工作的，以及在圣经中添加代码片段时需要做什么。</p><p>看到一些描述错误的东西了吗，有问题还是完全错了？打开问题或发送请求。如果圣经遗漏了什么，打开一个问题，就会找到解决办法。</p><p>纯bash替代外部进程和程序的集合。bash脚本语言比人们意识到的强大，大多数任务都可以在不依赖外部程序的情况下完成。</p><p>在bash中调用外部进程代价高昂，过度使用会导致明显的速度减慢。使用内置方法（如果适用）编写的脚本和程序将更快，需要更少的依赖性，并更好地理解语言本身。</p><p>本书的内容为解决在bash中编写程序和脚本时遇到的问题提供了参考。函数格式的示例展示了如何将这些解决方案合并到代码中。</p><p>这是sed、awk、perl和其他工具的替代品。下面的函数通过查找所有前导和尾随空格，并将其从字符串的开头和结尾移动来工作。：内置变量用于替代临时变量。</p><p>trim#string（）{#用法：trim#string&#34；示例string&#34；：&#34；${1#&#34；${1%[！[：space:]*}&#34；}&#34;  :   &#34; ${{uz%&#34；${u##*[！[：空格：]}&#34；}&#34;  printf&#39；%s\n和#39&#34; $_ &#34;}</p><p>这是sed、awk、perl和其他工具的替代品。下面的函数通过滥用分词来创建一个没有前导/尾随空格和截断空格的新字符串。</p><p>#shellcheck disable=SC2086，SC2048 trim#all（）{用法：trim#all&#34；示例字符串&#34；set-f set--$*printf&#39；%s\n&#39；&#34；$*&#34；set+f}</p><p>$trim_all&#34；你好，世界&#34；你好，World$name=&#34；约翰·布莱克是我的名字&#34;$ 修剪全部&#34$姓名&#34；约翰·布莱克是我的名字。</p><p>bash的结果&#39；s regex匹配可以用于替换大量用例中的sed。</p><p>警告：这是少数依赖于平台的bash特性之一。bash将使用用户安装的任何regex引擎&#39；s系统。如果以兼容性为目标，请坚持使用POSIX正则表达式功能。</p><p>注意：本例仅打印第一个匹配组。当使用多个捕获组时，需要进行一些修改。</p><p>regex（）{#用法：regex&#34；string&#34；&#34；regex&#34；[$1=~$2]]和printf&#39；%s\n&#39；&#34；${BASH#u重新匹配[1]&#34；}</p><p>$#修剪前导空白。$正则表达式&#39；你好&#39&#39;^\s*（*）和#39；你好$#验证十六进制颜色。$正则表达式&#34#FFFFFF&#34&#39;^（#？（[a-fA-F0-9]{6}|[a-fA-F0-9]{3}））$&#39#FFFFFF$#验证十六进制颜色（无效）。$正则表达式&#34；红色和#34&#39;^（#？（[a-fA-F0-9]{6}|[a-fA-F0-9]{3}））$&#39；#无输出（无效）</p><p>是_hex_color（）{if[$1=~^（#？（[a-fA-F0-9]{6}}|[a-fA-F0-9]{3}]）$]；然后printf&#39；%s\n和#39&#34; ${BASH_重赛[1]}&#34；else printf&#39；%s\n和#39&#34;错误：$1是无效颜色&#34;  返回1 fi}read-r coloris_hex_color&#34$颜色&#34；|124;颜色=&#34#FFFFFF&#34；#做事。</p><p>split（）{#用法：split&#34；string&#34；delimiter&#34；IFS=$&#39；\n&#39；read-d&#34；&ra arr&lt；&lt；&lt；&lt；&gt；&34；$1/$2/$&39；\n&#39；]&#34;  printf&#39；%s\n和#39&#34; ${arr[@]}&#34；}</p><p>$split和#34；苹果、橙子、梨、葡萄和#34&#34;, &#34;AppleSRangeSpearsgraps$split和#34；1, 2, 3, 4, 5 &#34;   &#34;,  &#34;12345#多字符分隔符也有效！$分裂和#34；你好---世界---我的---名字---是---约翰&#34&#34;--- &#34;我的名字是约翰</p><p>$strip#all&#34；敏捷的棕色狐狸&#34&#34;[aeiou]和#34；Th Qck Brwn外汇$strip#u all和#34；敏捷的棕色狐狸&#34&#34;[：空格：][]和#34；QuickBrownFox$strip#all&#34；敏捷的棕色狐狸&#34&#34;快&#34；棕色狐狸</p><p>$strip&#34；敏捷的棕色狐狸&#34&#34;[aeiou]和#34；第四快棕色狐狸$strip&#34；敏捷的棕色狐狸&#34&#34;[：空格：][]和#34；敏捷的棕色狐狸</p><p>urlencode（）{#用法：urlencode&#34；string&#34；local LC#u ALL=C for（（i=0；i&lt；${#1}；i++）；do:&#34${1:i:1}&#34；案例&#34；$#&#34;  在[a-zA-Z0-9.~-]）printf和#39；%s&#39&#34; $_ &#34; ;;  *)  printf&#39；%%02X和#39&#34;&#39; $_ &#34; ;;  esac完成了打印F和#39；\n&#39；}</p><p>如果[[$var==*sub_string*]；然后printf&#39；%s\n和#39&#34;子字符串在变量和34中；fi#逆（子字符串不在字符串中）。如果[$var！=*sub_string*]；然后printf&#39；%s\n和#39&#34;子#u字符串不在变量&#34中；fi#这也适用于阵列！如果[${arr[*]}==*子字符串*]；然后printf&#39；%s\n和#39&#34;子字符串在数组中&#34; 菲</p><p>34例$var&#34；在*sub_string*）#做事*sub_string2*）#做更多的事；*）#其他的以撒</p><p>如果[[$var==sub_string*]；然后printf&#39；%s\n和#39&#34;var以sub_字符串开头&#34; fi#逆（var不以sub#u字符串开头）。如果[[$var！=sub_string*]；然后printf&#39；%s\n和#39&#34;var不以sub_字符串开头&#34; 菲</p><p>如果[$var==*sub_string]]；然后printf&#39；%s\n和#39&#34;var以sub_字符串结尾&#34; fi#逆（var不以sub_字符串结尾）。如果[$var！=*子字符串]]；然后printf&#39；%s\n和#39&#34;var不以sub_字符串结尾&#34; 菲</p><p>启用extdebug允许访问BASH_ARGV数组，该数组反向存储当前函数的参数。</p><p>reverse#array（）{#用法：reverse#array&#34；array&#34；shopt-s extdebug f（）（printf&#39；%s\n&#39；&#34；${BASH#ARGV[@]&#34；）；f&#34；$@&#34;  shopt-u extdebug}</p><p>创建临时关联数组。当设置关联ArrayValue并发生重复赋值时，bash会覆盖该键。这使我们能够有效地删除重复的阵列。</p><p>remove_array_dups（）{#用法：remove_array_dups&#34；array&#34；declare-tmp_array for i in&#34；$@&#34；do[$i]]和IFS=&#34；&#34；tmp#u array[&#=1完成打印F&#39；%s\n和#39&#34; ${！tmp_数组[@]}&#34；}</p><p>$remove_array_dups 1 1 2 2 3 3 3 3 3 4 4 5 5 5 5 512345$arr=（红-红-绿-蓝）$remove_array_dups和#34${arr[@]}&#34；红绿蓝</p><p>$array=（红绿蓝黄棕色）$random_array_element&#34${array[@]}&#34；黄色#也可以传递多个参数。$随机数组元素12345673</p><p>每次调用printf时，都会打印下一个数组元素。当打印到达最后一个数组元素时，它会再次从第一个元素开始。</p><p>arr=（苹果橙子番茄）#元素和索引。因为我在&#34${！啊[@]}&#34；打印F&#39；%s\n和#39&#34; ${arr[i]}&#34；完成#替代方法。对于（（i=0；i&lt；${#arr[@]}；i++）；打印F&#39；%s\n和#39&#34; ${arr[i]}&#34；完成</p><p>#贪婪的例子。存档*；打印F&#39；%s\n和#39&#34; $文件&#34；完成#在dir中保存PNG文件。用于~/Pictures/*中的文件。巴布亚新几内亚；打印F&#39；%s\n和#39&#34; $文件&#34；完成#遍历目录。对于~/Downloads/*/中的dir；打印F&#39；%s\n和#39&#34; $署长&#34；完成#支架扩展。对于/path/to/parentdir/{file1，file2，subdir/file3}中的文件；打印F&#39；%s\n和#39&#34; $文件&#34；完成#递归迭代。shopt-s globstar用于~/Pictures/***中的文件；打印F&#39；%s\n和#39&#34; $文件&#34；完成shopt-u globstar</p><p>#Bash&lt；4（丢弃空行）。IFS=$和#39；\n&#39；阅读-d&#34&#34; -ra文件_数据&lt&#34;文件&#34；#Bash&lt；4（保留空行）。而read-r行；do file_data+=（&#34；$line&#34；）完成&lt&#34;文件&#34；#Bash 4+mapfile-t file_data&lt&#34;文件&#34；</p><p>head（）{用法：head&#34；n&#34；file&#34；mapfile-tn&#34；$1&#34；line&lt；&#34；$2&#34；printf&#39；%s\n&#39；&#34$#line[@]</p><p>tail（）{用法：tail&#34；n&#34；&#34；file&#34；mapfile-tn 0行&lt；&#34；$2&#34；printf&#39；%s\n&#39；&#34；${line[@]：$1&#34；]</p><p>$tail 2~/。bashrc#启用tmux。#[-z&#34；$TMUX&#34；]]&amp&amp；exec tmux$tail 1~/。bashrc#[-z&#34；$TMUX&#34；]]&amp&amp；执行官tmux</p><p>lines（）{用法：lines&#34；file&#34；mapfile-tn 0 lines&lt；&#34；$1&#34；printf&#39；%s\n&#39；&#34；${#lines[@]}&#34；}</p><p>该方法使用的内存比mapfile方法少，在bash 3中也可以使用，但对于较大的文件，它的速度较慢。</p><p>lines_loop（）{用法：lines_loop&#34；file&#34；count=0，而IFS=read-r#do（（count++）done&lt；&#34；$1&#34；printf&#39；%s\n&#39；&#34；$count 34；}</p><p>其工作原理是将glob的输出传递给函数，然后计算参数的数量。</p><p>#计算目录中的所有文件。$count~/Downloads/*232#计算目录中的所有目录。$count~/Downloads/*/45#计算目录中的所有jpg文件。$计数~/Pictures/*。jpg64</p><p>extract（）{用法：extract file&#34；opening marker&#34；&#34；closing marker&#34；而IFS=$&#39；\n&#39；read-r line；do[$extract&amp；$line！=&#34；$3&#34；]&amp&amp；printf&#39；%s\n和#39&#34; $第34行；[$line==&#34；$2&#34；]&amp&amp；摘录=1[$line==&#34；$3&#34；]]&amp&amp；提取=完成&lt&#34; $1 &#34;}</p><p>dirname（）{#用法：dirname&#34；path&#34；local tmp=${1:-.}[[$tmp！=*[！/]*]&amp&amp；{printf&#39；/\n&#39；return}tmp=${tmp%%&#34；${tmp###*[！/]}&#34；}[$tmp！=*/*]&amp&amp；{printf&#39；\n&#39；return}tmp=${tmp%/*}tmp=${tmp%&#34；${tmp###*[！/]}&#34；}printf&#39；%s\n和#39&#34; ${tmp:-/}&#34；}</p><p>basename（）{用法：basename&#34；path&#34；[&#34；后缀&#34；]本地tmp tmp=${1%&#34；${1##*[！/]}&#34；}tmp=${tmp##*/}tmp=${tmp%&#34；${2/&#34；$tmp&#34；}&#34;}  printf&#39；%s\n和#39&#34; ${tmp:-/}&#34；}</p><p>$hello_world=&#34；价值&#34；#创建变量名。$var=&#34；世界&#34；美元ref=&#34；你好，$var&#34；#打印存储在&#39中的变量名的值；你好$var&#39；$printf&#39；%s\n和#39&#34; ${！ref}&#34；价值</p><p>与普遍的看法相反，利用原始逃逸序列没有问题。使用tput提取与手动打印相同的ANSI序列。更糟糕的是，tput实际上并不便携。有很多tput变体，每个都有不同的命令和语法（在FreeBSD系统上尝试tput setaf 3）。原始序列很好。</p><p>注意：在下面任何代码前加上2，将其变成&#39；s效果关闭（示例：21=粗体文本关闭，22=模糊文本关闭，23=斜体文本关闭）。</p><p>展开到以VAR开头的变量名的IFS分隔列表。如果双引号，每个变量名将展开到一个单独的单词。</p><p>从N个字符到N个字符获取子字符串。（${VAR:10:10}：从char 10到char 20获取子字符串）</p><p>#语法：{&lt；开始&gt；.&lt；结束&gt；}打印数字1-100。echo{1..100}#打印浮动范围。回声1。{1..9}#打印字符a-z.echo{a..z}echo{a..z}#嵌套。echo{A..Z}{0..9}#打印零填充数字。#警告：bash4+echo{01..100}#更改增量金额。#语法：{&lt；开始&gt；.&lt；结束&gt；&lt；递增&gt；}警告：bash4+echo{1..10..2}#增加2。</p><p>如果文件比文件2新（使用修改时间），或者文件存在而文件2不存在。</p><p>如果文件早于文件2（使用修改时间），或者文件2存在而文件不存在。</p><p>#如果var2大于var，则将var的值设置为var2。#var:要设置的变量。#var2&gt；var：要测试的条件。#？var2：如果测试成功。#如果测试失败。（（var=var 2&gt；var？var 2:var））</p><p>陷阱允许脚本在各种信号上执行代码。在pxltrm（一个用bash编写的像素艺术编辑器）中，陷阱用于在调整窗口大小时重新绘制用户界面。另一个用例是在脚本退出时清理临时文件。</p><p>应该在脚本开始附近添加陷阱，以便捕获任何早期错误。</p><p>如果不需要unicode，可以禁用它以提高性能。结果可能会有所不同，但是neofetch和其他程序已经有了明显的改进。</p><p>注意：有时人们可能有充分的理由使用#/bin/bash或二进制文件的另一个直接路径。</p><p>&#34; $主机名&#34；#注意：此变量可能为空。#（可选）将回退设置为hostname命令&#34; ${HOSTNAME:-$（HOSTNAME）}&#34；</p><p>这可以用于为不同的操作系统添加条件支持，而无需调用uname。</p><p>每次使用$RANDOM时，都会返回一个介于0和32767之间的不同整数。此变量不应用于任何与安全性相关的内容（包括加密密钥等）。</p><p>在纯bash和stty/tput中编写脚本时，这很方便。</p><p>get_term_size（）{#用法：get_term_size#（：：）是一个微睡眠，以确保变量立即导出。shopt-s checkwinsize；（：：：）printf&#39；%s\n&#39；&#34；$LINES$COLUMNS&#34；}</p><p>用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：获取窗户尺寸图尺寸印刷F和39；%b和39；b和[35；39；b和[35；34；b和39；b和39；阅读-t-t-t-t 0.05-sra术语t t t-t-t 0.05-sra术语t-t-0.05-sra术语（sra术语）t-t-t-sra术语）t-t-t-t-0.05-sra术语（sra术语）t-t-t-t-t）t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-#34；}</p><p>get_cursor_pos（）{#用法：get_cursor_pos IFS=&#39；[#&#39；read-p$&#39；\e[6n&#39；-dr-rs y x#printf 39；%s\n&#39；&#34；$x$y&#34；]</p><p>hex_to_rgb（）{用法：hex_to_rgb&#34；#FFFFFF&#34；#hex_to_rgb&#34；000000&#34；：&#34；${1/\\\\}34；（r=16#${0:2}，g=16#${2:2}，b=16#${4:2}）printf&#39；%s\n和#39&#34; $r$g$b&#34；}</p><p>#小C风格。对于（；i++&lt；10；））{echo&#34；$i&#34；}未记录的方法。因为{1..10}中的i；{echo&#34；$i&#34；}膨胀因为{1..10}中的i；做回声&#34$我&#34；完成#C风格。（i=0；i&lt；=10；i++）；做回声&#34$我&#34；完成</p><p>#正规方法f（）{echo hi；}#使用子shell f（）（echo hi）#使用算术#这可以用来分配整数值。#示例：fa=1 35; fa++f（）（$1））#使用测试、循环等#注意：'while'、'until'、'case'、'（（））'、'[[]）也可以使用。f（）如果为真；然后是回声&#34$1 &#34; ;  fi f（）代表i in&#34；$@&#34;;  做回声&#34$我&#34；完成</p><p>#一行#注意：第三条语句可能会在第一条语句为真时运行[$var==hello]]&amp&amp；echo hi | | echo bye[$var==你好]]&amp&amp；{echo hi；echo那里；}||echo bye#多行（无其他，单语句）#注意：退出状态可能与if语句[[$var==hello]]不同&amp&amp；echo hi#多行（无其他）[$var==hello]]&amp&amp；{echo hi#..}</p><p>：内置可用于避免在case语句中重复变量=。$变量存储最后一个命令的最后一个参数：始终成功，以便可以使用它存储变量值。</p><p>#修改了Neofetch中的代码片段。34例$OSTYPE&#34；在&#34；达尔文&#34；*）：&#34;马科斯&#34&#34;linux&#34；*）：&#34;Linux&#34；；*&#34;bsd&#34；*|&#34;蜻蜓&#34；|&#34;比特瑞格（bitrig&#34；）：&#34;BSD&#34&#34;西格温&#34；|&#34;msys&#34；|&#34;win32&#34；）：&#34;窗户&#34；；*）printf&#39；%s\n和#39&#34;检测到未知操作系统，正在中止&#34;  &gt&amp；2.出口1；；esac#最后，设置变量。os=&#34；$\U&#34;</p><p>read#u sleep（）{#用法：read#u sleep 1#read#u sleep 0.2 read-rt&#34；$1&#34；&lt；&gt；&lt；（：）|：}</p><p>对于性能关键的情况，如果打开和关闭过多的文件描述符是不经济的，那么对于所有读取调用，文件描述符的分配只能进行一次：</p><p>执行{sleep_fd}&lt&gt&书信电报；（：）而一些快速测试；do#相当于sleep 0.001 read-t0.001-u$sleep#u fd done</p><p>#有三种方法可以做到这一点，任何一种都可以使用。类型-p可执行文件名称&amp&gt/dev/null哈希可执行文件\u name&amp&gt/dev/null命令-v可执行文件名称&amp&gt/dev/null#作为测试。如果类型为-p可执行文件名称&amp&gt/dev/null；然后#程序进入路径。fi#逆。如果类型-p可执行文件名称&amp&gt/dev/null；那么#程序不在路径中。fi#示例（如果未安装程序，请提前退出）。如果类型-p转换&amp&gt/dev/null；然后printf&#39；%s\n和#39&#34;错误：未安装转换，正在退出&#34;  1号出口</p><p>Bash的printf有一个获取日期的内置方法，可以用来代替date命令。</p><p>date（）{用法：date&#34；format&#34；#参见：&#39；man strftime&#39；获取format.printf&#34；（$1）T\\n&#34；&#34；-1&#34；}</p><p>#使用上述功能。$日期&#34；%a%d%b-%l:%M%p&#34；6月15日星期五上午10:00#直接使用printf。$printf&#39；%（%a%d%b-%l:%M%p）T\n和#39&#34;-1 &#34;6月15日星期五上午10:00#使用printf分配变量。$printf-v日期和#39；%（%a%d%b-%l:%M%p）T\n和#39&#39;-1 &#39;$  printf&#39；%s\n和#39&#34; $日期&#34；6月15日星期五上午10:00</p><p>$：\\u#展开参数，就像它是一个提示字符串一样。$printf&#39；%s\n和#39&#34; ${@P}&#34；黑色</p><p>（N=0；N&lt；16；N&lt；16；N；N&lt；16；N；N&lt；16；N；N；N&lt；16；N+N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N（N）34；N）34；N（N（N（N（N（N（N）N；N）N（N）N；N）N；N；N）N；N；N；N；N；N）N）N）N）N；N）N）N）N）N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N）34；N）%${#C}:1}&#34&#34;  $（（B%16））和#34；；3 | 5 | 7 | 9）打印和#39；%02x-#39&#34; $B&#34；；*）printf&#39；%02x和#39&#34; $B&#34；；esac完成了打印F和#39；\n&#39；}</p><p>这是一种绘制进度条的简单方法，无需函数本身中的for循环。</p><p>bar（）{#用法：bar 1 10#^--经过的百分比（0-100）。#^--以字符为单位的总长度。（（经过的=$1*$2/100））#用空格创建条形图；printf-v总计和#34；%$（（$2-已逝））s和#34；printf&#39；%s\r&#39&#34;[${prog//-}${total}]&#34；}</p><p>（i=0；i&lt；=100；i++）；do#Pure bash micro sleeps（例如）。（：；：）&amp&amp；（：；：）&amp&amp；（：；：）&amp&amp；（：；：）&amp&amp；打印条。酒吧&#34$我&#34&#34;10 &#34; 完成打印F和#39；\n&#39；</p><p>get#u functions（）{#用法：get#u functions IFS=$&#39；\n&#39；read-d&#34；&#34；&#ra functions&lt；；（declare-F）printf&#39；%s\n&#39；&#34；${functions[@]//declare-F}&#34；}</p><p>这将运行给定的命令并保持其运行，即使在终端或SSH连接终止后也是如此。所有输出都被忽略。</p><p>bkr（）{（nohup&#34；$@&#34；&amp；&gt；/dev/null&amp；）}bkr/一些剧本。sh#一些脚本。sh现在正在后台运行</p><p>它使用本地namerefs来避免使用var=$（some_func）样式的命令替换函数输出captu</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用法/">#用法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>