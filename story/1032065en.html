<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对于复杂的应用，铁锈与Kotlin一样高效</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">对于复杂的应用，铁锈与Kotlin一样高效</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 01:06:04</div><div class="page_narrow text-break page_content"><p>In this article, we will compare one apple (IntelliJ Rust) to one orange (rust-analyzer) to reach general and sweeping conclusions.Specifically, I want to present a case study supporting the following claim:</p><p>在这篇文章中，我们将一个苹果(IntelliJ锈菌)与一个橙子(锈菌分析仪)进行比较，以得出普遍而全面的结论。具体地说，我想给出一个支持以下说法的案例研究：</p><p>  For me, this is an unusual claim to argue: I always thought exactly the opposite, but I am not so sure now.I came to Rust from C++.I was of the opinion that this is a brilliant low-level language and always felt puzzled at people writing higher-level things in Rust.Clearly, choosing Rust means taking a productivity hit, and using Kotlin, C# or Go just makes much more sense if you can afford GC.My  list of Rust criticisms starts with this objection.</p><p>对我来说，这是一个不同寻常的主张：我总是想着完全相反的想法，但现在我不太确定了。我是从C++来到Rust的。我认为这是一种出色的低级语言，总是对人们用Rust编写更高级别的东西感到困惑。很明显，选择Rust意味着要降低生产率，如果你负担得起的话，使用Kotlin、C#或Go就更有意义了。我的Rust批评清单就是从这个反对开始的。</p><p> What moved my position in the other direction was my experience as the lead developer of rust-analyzer and IntelliJ Rust.Let me introduce the two projects.</p><p>把我的位置移向另一个方向的是我作为铁锈分析仪和IntelliJ Rust的首席开发人员的经验。让我介绍一下这两个项目。</p><p> IntelliJ Rust is the plugin for IntelliJ Platform, providing Rust support.In effect, it is a Rust compiler front-end, written in Kotlin and making use of language-support features of the platform.These features include lossless syntax trees, a parser generator, persistence and indexing infrastructure, among others.Nonetheless, as programming languages differ lot, the bulk of logic for analyzing Rust is implemented in the plugin itself.Presentational features like completion list come from the platform, but most of the language semantics is hand-written.IntelliJ Rust also includes a bit of a Swing GUI.</p><p>IntelliJ Rust是IntelliJ平台的插件，提供对Rust的支持。实际上，它是一个Rust编译器前端，使用Kotlin编写，并利用平台的语言支持功能。这些功能包括无损语法树、解析器生成器、持久化和索引基础设施等。然而，由于编程语言的差异很大，分析Rust的大部分逻辑都是在插件中实现的。完成列表等表示功能来自平台，但大多数语言语义都是手写的。IntelliJ Rust还包括一些Swing GUI。</p><p> rust-analyzer is an implementation of Language Server Protocol for Rust.It is a Rust compiler front-end written from scratch with an eye towards IDE support.It makes heavy use of  salsa library for incremental computations.Beyond the compiler itself, rust-analyzer includes code for managing long-lived multithreaded process of the language server itself.</p><p>RUST分析器是RUST语言服务器协议的一个实现，它是一个着眼于IDE支持而从头编写的RUST编译器前端，它大量使用SALSA库进行增量计算，除了编译器本身之外，RUST分析器还包含用于管理语言服务器本身的长寿命多线程进程的代码。</p><p> The projects are essentially equivalent in scope — rust compiler front-ends suitable for IDEs.The two biggest differences are:</p><p>这两个项目在适用于IDE的 - RUST编译器前端的范围上基本上是等价的。最大的两个区别是：</p><p> IntelliJ Rust is a plugin, so it can re-use code and design patterns of the surrounding platform.</p><p>IntelliJ Rust是一个插件，因此它可以重用周围平台的代码和设计模式。</p><p> rust-analyzer is the second system, so it leverages experience of IntelliJ Rust for a from-scratch design.</p><p>铁锈分析仪是第二个系统，因此它利用IntelliJ Rust的经验进行从头开始的设计。</p><p> The internal architecture of the two projects also differs a lot.In terms of  Three Architectures, IntelliJ Rust is map-reduce, and rust-analyzer is query-based.</p><p>这两个项目的内部架构也有很大的不同，在三种架构上，IntelliJ Rust是MAP-Reduce，Rust-Analyzer是基于查询的。</p><p> Writing an IDE-ready compiler is a high-level task.You don’t need to talk to the operating system directly.There are some fancy data structures and concurrency here and there, but they are also high-level.It’s not about implementing crazy lock-free schemes, it’s about maintaining application state and sanity in the multithreaded world.The bulk of the compiler is symbolic manipulation, arguably best suited for lisp.Picking a VM-based language for such task (for example, OCaml), doesn’t have any intrinsic downsides.</p><p>编写支持IDE的编译器是一项高级任务。您不需要直接与操作系统对话。这里和那里有一些奇特的数据结构和并发性，但它们也是高级的。它不是关于实现疯狂的无锁方案，而是关于在多线程世界中维护应用程序状态和健全性。编译器的大部分是符号操作，可以说是最适合LISP的。选择基于VM的语言(例如OCaml)来完成这类任务，没有任何内在的缺点。</p><p> At the same time, the task is pretty complex and unique.The ratio of “your code” vs “framework code” when implementing features is much higher than in a typical CRUD backend.</p><p>同时，这项任务相当复杂和独特，在实现特性时，“您的代码”与“框架代码”的比率比典型的CRUD后端要高得多。</p><p>   Both are about 2 years old, with 1-1.5 developers working full time and vibrant and thriving community of open-source contributors.There are 52k lines of Kotlin and 66k lines of Rust.</p><p>这两家公司都有大约2年的历史，有1-1.5名开发人员全职工作，拥有充满活力和蓬勃发展的开源贡献者社区，有52k行的Kotlin和66k行的Rust。</p><p> Both delivered roughly equivalent feature sets at that time.To be honest, I still don’t really believe this :)rust-analyzer started from zero, it didn’t have a decade worth of Java classes to bootstrap from, and the productivity drop between Kotlin and Rust is supposed to be huge.But it’s hard to argue with reality.Instead, let me try to reflect on my experience building both, and to try to explain Rust’s surprising productivity.</p><p>老实说，当时两者都提供了大致相同的功能集。老实说，我仍然不太相信这一点：)Ruust-Analyzer从零开始，它没有十年的Java类可供引导，Kotlin和Rust之间的生产率下降应该很大。但这很难与现实争辩。相反，让我试着反思一下我构建两者的经验，并试图解释Rust令人惊讶的生产率。</p><p> It’s easy to characterize Kotlin’s learning curve — it is nearly zero.I’ve started IntelliJ Rust without Kotlin experience and never felt that I need to specifically learn Kotlin.</p><p>很容易描述科特林的学习曲线， - ，它几乎为零。我在没有科特林经验的情况下创办了“智能锈蚀”，从来没有觉得我需要专门学习科特林。</p><p> When I switched to rust-analyzer, I was pretty experienced with Rust.I would say that one definitely needs to deliberately learn Rust, it’s hard to pick it up on the go.Ownership and aliasing control are novel concepts (even if you come from C++), and taking holistic approach to learning them pays off.After the initial learning step the ride is generally smooth.</p><p>当我转到铁锈分析器时，我对铁锈相当有经验。我想说，一个人肯定需要刻意学习铁锈，很难在路上学会它。所有权和别名控制是新概念(即使你来自C++)，采取整体的方法学习它们是有回报的。经过最初的学习步骤，总体来说是顺利的。</p><p> By the way, this is the perfect place to plug our Rust courses and tailor-made  trainings :-)The next  introduction to Rust is happening this December!</p><p>顺便说一句，这里是宣传我们的铁锈课程和量身定做培训的完美地方：-)下一次铁锈介绍将在今年12月进行！</p><p> This I think is the biggest factor.Both projects are moderately large in terms of scope as well as in terms of amount of source code.I believe that the only way to ship big things is to split them in independent-ish chunks and implement the chunks separately.</p><p>我认为这是最大的因素，这两个项目在范围和源代码数量上都是中等大的，我相信唯一的办法是将大型的东西拆分成独立的块，分别实现这些块。</p><p> I also find most of the languages I am familiar with to be pretty horrible with respect to modularity.More generally, I am amused with FP vs OO debate, as it seems that “why no one does modules right?” is a more salient issue.</p><p>我还发现我熟悉的大多数语言在模块性方面都相当糟糕，更普遍的是，我对FP和OO的争论很感兴趣，因为似乎“为什么没有人把模块做对呢？”是一个更突出的问题。</p><p> Rust is one of the few languages which has first-class concept of libraries.Rust code is organized on two levels:</p><p>Rust是为数不多的具有一流库概念的语言之一，Rust代码分为两个层次：</p><p>  Cyclic dependencies are allowed between the modules, but not between the crates.Crates are units of reuse and privacy: only crate’s public API matters, and it is crystal clear what crate’s public API is.Moreover, crates are anonymous, so you don’t get name conflicts and dependency hell when mixing several versions of the same crate in a single crate graph.</p><p>模块之间允许循环依赖，但机箱之间不允许循环依赖。机箱是重用和隐私的单位：只有机箱的公共API很重要，什么是机箱的公共API是非常清楚的。此外，机箱是匿名的，所以在单个机箱图中混合同一机箱的几个版本时，不会出现名称冲突和依赖地狱。</p><p> This makes it very easy to make two pieces of code  not depend on each other (non-dependencies are the essence of modularity): just put them in separate crates.During code review, only changes to Cargo.tomls need to be monitored carefully.</p><p>这使得使两段代码不相互依赖(非依赖性是模块性的本质)变得非常容易：只需将它们放在单独的craters中。在代码审查期间，只需仔细监视对Cargo.tomls的更改。</p><p> At the time of comparison, rust-analyzer is split into 23 internal crates, with a handful general-purposed ones released on crates.io.In contrast, IntelliJ Rust is a single Kotlin module, where everything can depend on everything else.Although internal organization of IntelliJ Rust is pretty clean, it’s not reflected in the file system layout and build system, and needs constant maintenance.</p><p>相比之下，IntelliJ Rust是一个单独的Kotlin模块，所有的一切都可以依赖于其他所有东西。虽然IntelliJ Rust的内部组织非常干净，但它没有反映在文件系统布局和构建系统中，需要持续维护。</p><p> Managing project’s build takes significant amount of times, and has multiplicative effect on everything else.</p><p>管理项目的构建需要大量的时间，并且会对其他所有事情产生倍增的影响。</p><p> Rust’s build system,  Cargo, is very good.It’s not perfect, but it is a breath of fresh air after Java’s  Gradle.</p><p>铁锈的构建系统CARADE非常好，虽然不完美，但它是继Java‘s Gradle之后的一股新鲜空气。</p><p> Cargo’s trick is that it doesn’t try to be a general purpose build system.It can only build Rust projects, and it has rigid expectation about the project structure.It’s impossible to opt out of the core assumptions.Configuration is a static non-extensible TOML file.</p><p>Cargo的诀窍在于它没有试图成为一个通用的构建系统，它只能构建Rust项目，并且对项目结构有严格的期望，不可能选择退出核心假设，Configuration是一个静态的、不可扩展的TOML文件。</p><p> In contrast, Gradle allows free-form project structure, and is configured via a Turing complete language.I feel like I’ve spend more time learning Gradle than learning Rust!Running  wc -w gives 182_817 words for Rust book, and 280_506 for Gradle’s user guide.</p><p>相比之下，Gradle允许自由格式的项目结构，并通过图灵完全语言进行配置。我觉得我学习Gradle的时间比学习Rust的时间还多！运行WC-w会给出182_817个单词用于Rust图书，280_506个单词用于Gradle的用户指南。</p><p>  Of course, the biggest downside is that custom build logic is not expressible in Cargo.Both projects needs substantial amount of logic beyond mere compilation to deliver the final result to the user.For rust-analyzer, this is handled by hand-written Rust script, which works perfectly at this scale.</p><p>当然，最大的缺点是自定义构建逻辑不能用Cargo表达。这两个项目都需要大量的逻辑，而不仅仅是编译，才能将最终结果交付给用户。对于锈蚀分析器来说，这是由手写的锈蚀脚本处理的，在这种规模下工作得很好。</p><p> Language-level support for libraries and top-notch build system/package manager allow for a thriving ecosystem.rust-analyzer relies on third-party libraries much more than IntelliJ Rust.Some parts of rust-analyzer are also published to crates.io for other projects to reuse.</p><p>对库的语言级支持和一流的构建系统/包管理器使生态系统蓬勃发展。锈检分析器比IntelliJ Rust更依赖第三方库。锈检分析器的某些部分也发布到crates.io以供其他项目重用。</p><p> Additionally, low-level nature of the Rust programming language often allows for “perfect” library interfaces.Interfaces which exactly reflect the underlying problem, without imposing intermediate language-level abstractions.</p><p>此外，Rust编程语言的低级特性通常允许“完美的”库接口，这些接口准确地反映了潜在的问题，而不会强加中间语言级别的抽象。</p><p> I feel that Rust is significantly more productive when it comes to basic language nuts and bolts — structs, enums, functions, etc.This is not specific to Rust — any ML-family language has them.However, Rust is the first industrial language which wraps these features in a nice package, not constrained by backwards compatibility.I want to list specific features which I think allow producing maintainable code faster in Rust</p><p>我觉得当涉及到基本语言的细节时，RUST的效率要高得多。 - 结构、枚举、函数等。这并不是RUST所特有的，任何ML系列语言都有它们。但是，RUST是第一种将这些特性封装在一个很好的包中的工业语言，不受向后兼容性的限制。我想列出一些我认为可以在RUST中更快地生成可维护代码的具体特性。但是，RUST是第一种将这些特性封装在一个很好的包中的工业语言。我想列出一些我认为可以在RUST中更快地生成可维护代码的具体特性。</p><p> Emphasis on data over behavior.Aka, Rust is not an OOP language.The core idea of OOP is that of dynamic dispatch — which code is invoked by a function call is decided at runtime (late binding).This is a powerful pattern which allows for flexible and extensible system.The problem is, extensibility is costly!It’s better only to apply it in certain designated areas.Designing for extensibility by default is not cost effective.Rust puts static dispatch front and center: it is mostly clear whats going on by just reading the code, as it is independent of runtime types of the objects.</p><p>强调数据重于行为。也就是说，RUST不是一种OOP语言。OOP的核心思想是动态分派 - ，由函数调用调用的代码是在运行时决定的(后期绑定)。这是一个强大的模式，允许灵活和可扩展的系统。问题是，可扩展性是昂贵的！最好只在某些指定的领域应用它。默认情况下设计可扩展性是不划算的。Rust将静态分派放在最前面和中心：只需读取代码就可以很清楚地知道发生了什么，因为它独立于对象的运行时类型。</p><p> One small syntactic thing I enjoy about Rust is how it puts fields and methods into different blocks syntactically:</p><p>我喜欢Rust的一个小语法方面是它如何在语法上将字段和方法放到不同的块中：</p><p> struct  Person  {  first_name :  String ,  last_name :  String , } impl  Person  {  fn  full_name ( &amp; self )  -&gt;  String  {  ...  } }</p><p>Struct Person{First_Name：String，Last_Name：String，}Impll Person{fn Full_Name(&amp；Self)-&gt；String{...}}。</p><p> Being able to see at a glance all the fields makes understanding the code much simpler.Fields convey much more information than methods.</p><p>能够一目了然地看到所有字段使得理解代码变得简单得多，字段传达的信息比方法多得多。</p><p> Sum types.Rust’s humbly named enums are full algebraic data types.This means that you can express the idea of disjoint union:</p><p>SUM类型。Rust的简单命名枚举是全代数数据类型。这意味着您可以表达不相交并集的概念：</p><p>  This is hugely useful in day-to-day programming in the small, and some times during programming in the large as well.To give one example, one of the core concepts for an IDE are references and definitions.A definition a like  let foo = 92; assigns a name to an entity which can be used down a line.A reference like  foo + 90  refers to some definition.When you ctrl-click on reference, you go to the definition.</p><p>这在小的日常编程中非常有用，有时在大的编程中也是如此。举个例子，IDE的核心概念之一是引用和定义。像let foo=92；这样的定义为可以在一行中使用的实体指定一个名称。像foo+90这样的引用指的是一些定义。当你按住ctrl键单击引用时，就会转到定义。</p><p> Natural way to model that in Kotlin is by adding  interface Definition and  interface Reference.The problem is, some things are both!</p><p>在Kotlin中建模的自然方法是添加接口定义和接口引用。问题是，有些东西两者都有！</p><p> struct  S  {  field :  i32  } fn  process ( s :  S )  {  match  s  {  S  {  field  }  =&gt;  println! ( &#34;{}&#34; ,  field  +  2 )  } }</p><p>Struct S{field：I32}fn进程{匹配s{S{field}=&gt；println！(&#34；{}&#34；，field+2)}}。</p><p> In this example, the second  field is both a reference to the  field: i32 definition, as well as a definition of a local variable with the name  field!Similarly, in</p><p>在本例中，第二个字段既是对field：i32定义的引用，也是名称为field的局部变量的定义！类似地，在。</p><p>  field conceptually holds two references — one reference to a local variable, and one reference to a field definition.</p><p>字段在概念上包含两个 - 引用，一个是对局部变量的引用，另一个是对字段定义的引用。</p><p> In IntelliJ Rust, this is generally handled by downcasting special cases.In rust-analyzer, this is handled by an enumwhich lists all of the special cases.</p><p>在IntelliJ Rust中，这通常是通过向下预测特殊情况来处理的。在锈蚀分析器中，这是由列出所有特殊情况的枚举来处理的。</p><p> rust-analyzer is very enum-heavy, and there’s a lot of code which boringly matches over N variants and does almost the same thing.This code is more verbose then IntelliJ Rust alternative of special-casing specific odd cases, but is much easier to understand and support.You don’t need to keep broader context in your head to understand what special cases  might be possible.</p><p>防锈分析器是非常繁重的，有很多代码枯燥地匹配N个变量，并且做几乎相同的事情。这段代码比特殊外壳特定奇怪情况的IntelliJ Rust替代方案更冗长，但更容易理解和支持。您不需要在头脑中保持更广泛的上下文来理解哪些特殊情况可能是可能的。</p><p> Error Handling.When it comes to null safety, Kotlin and Rust are mostly equivalent in practice.There are some finer distinctions here between union types vs sum types, but they are irrelevant in real code in my experience.Syntactically, Kotlin’s take on  ? and  ?: feels a little more convenient more often.</p><p>错误处理。当谈到空安全性时，Kotlin和Rust在实践中基本上是等价的。联合类型和SUM类型之间有一些更细微的区别，但根据我的经验，它们在实际代码中是无关的。从语法上讲，Kotlin的？还有？：经常感觉更方便一些。</p><p> However, when it comes to error handling ( Result&lt;T, E&gt; rather than  Option&lt;T&gt;), Rust wins hands down.Having  ? annotating error paths on the call site is very valuable.Encoding errors in function’s return type, in a way which works with high-order functions, makes for robust code.I dread calling external processes in Kotlin and Python, because it is exactly the place where exceptions are common, and where I forget to handle at least one case every single time.</p><p>然而，当谈到错误处理(Result&lt；T，E&gt；而不是Option&lt；T&gt；)时，Rust轻松取胜。在调用点上注释错误路径是非常有价值的。以一种使用高阶函数的方式对函数返回类型中的错误进行编码有助于获得健壮的代码。我害怕用Kotlin和Python调用外部进程，因为这正是常见异常的地方，而且我每次都忘记至少处理一种情况。</p><p> Although Rust’s types and expressions usually allow one to state precisely what one wants, there are still cases when the borrow checker gets in a way.For example, here we can’t return an iterator which wants to borrow from a temporary: utils.rs.</p><p>尽管Rust的类型和表达式通常允许您准确地声明您想要什么，但是仍然存在借用检查器遇到障碍的情况。例如，在这里，我们不能返回想要从临时的：utils.rs借用的迭代器。</p><p> When learning Rust problems of this kind are very frequent.This is primarily because applying the traditional “soup of pointers” design to Rust doesn’t work.With experience, design-related borrow checker errors tend to fade away — building software as a tree of components works, and it is almost always a good design.The residual borrow checker limitations are annoying, but don’t matter in the grand scheme of things.</p><p>在学习时，这类锈蚀问题非常频繁。这主要是因为将传统的“指针汤”设计应用于锈蚀是不起作用的。根据经验，与设计相关的借用检查器错误往往会随着组件树的运行而逐渐消失，而且几乎总是一个好的设计。剩余的借用检查器限制是恼人的，但在总体规划中无关紧要。</p><p> IntelliJ Rust and rust-analyzer use similar approach to concurrency.There’s a global reader-write lock guarding the base application state and a large number of thread safe caches for derived data.</p><p>IntelliJ Rust和Rust-Analyzer使用类似的并发方法，有一个全局读写锁来保护基本应用程序状态，还有大量用于派生数据的线程安全缓存。</p><p> Managing this in Kotlin is hard.More that once I asked myself “should I mark this as volatile?” without a clear way to get the answer.The way to figure out if something is supposed to be thread safe in Kotlin is to read the docs and hunt for all usages.</p><p>在科特林管理这件事很难。更重要的是，我曾经问自己“我应该把这件事标记为不稳定吗？”在没有明确的方法得到答案的情况下，要确定某个东西在Kotlin中是否应该是线程安全的，方法是阅读文档并查找所有用法。</p><p> In contrast, “is this type thread-safe?” is a property which is reflected in Rust’s type system (via  Send and  Sync traits).Compiler automatically derives thread-safeness, and checks that non thread-safe types are not accidentally shared.</p><p>相反，“该类型是线程安全的吗？”是反映在Rust的类型系统中的属性(通过Send和Sync特征)。编译器自动派生线程安全性，并检查非线程安全类型是否被意外共享。</p><p> A bug which happened in both IntelliJ Rust and rust-analyzer is a good case study here.Recall that both make use of caches shared between the threads.In both projects, I once devised a smart optimization which unfortunately involved placing (unintentionally) thread unsafe data into this shared cache.In IntelliJ Rust, it took us a long while to notice that something is wrong in the first place, and even more investigation to pin down the root cause.In rust-analyzer, I only wasted the time for implementing the optimization itself.After I fixed what I though would be the last compilation error, compiler somberly noted that putting  A which contains  B which contains  C which contains non thread-safe  D into a structure which is shared across threads might not be the best idea!</p><p>在IntelliJ Rust和Rust-Analyzer中都发生了一个bug，这是一个很好的案例。在这两个项目中，我都利用了线程之间共享的缓存。在这两个项目中，我曾经设计了一个智能优化，不幸的是(无意中)将线程不安全的数据放到了这个共享的Cache中。在IntelliJ Rust中，我们花了很长时间才发现有问题，并进行了更多的调查来确定根本原因。在Ruust-Analyzer中，我只是浪费了时间来实现优化本身。在我修复了我认为是最后一个编译错误之后，我发现了一个错误。在IntelliJ Rust中，我们首先发现了一些问题，然后进行了更多的调查来找出根本原因。在Ruust-Analyzer中，我只浪费了时间来实现优化本身。在我修复了我认为是最后一个编译错误之后，编译器严肃地指出，将包含B的A和包含非线程安全D的C放入跨线程共享的结构中可能不是最好的主意！</p><p> My general experience with developing IntelliJ Rust is “no mater what I do, it is not as fast as I’d like it to be”.My experience with rust-analyzer is exactly the opposite “no matter what I do, it is fast enough”.</p><p>我开发IntelliJ Rust的一般经验是“无论我做什么，它都不像我希望的那样快”，而我使用铁锈分析仪的经验正好相反，“无论我做什么，它都足够快”。</p><p> As an anecdote, in the early days I was implementing fixed-point iteration name resolution algorithm in rust-analyzer.This is an IDE hostile bit.It requires to redo quite a bit of work on every keystroke, if done naively.When I build rust-analyzer with this change, I finally saw completion to noticeably lag.“This is it”, thought I, “I should stop just using naive algorithms and start applying some optimizations”.Well, turns out I took a debug version of rust-analyzer for a test drive!Rebuilding with  --release fixed the issue.</p><p>作为一则轶事，我早期在锈蚀分析器中实现定点迭代名称解析算法。这是一个IDE的敌意之处。它需要在每一次击键上重做相当多的工作，如果做得很天真的话。当我用这个更改构建锈蚀分析器时，我终于看到完成明显滞后。“就是这样”，我想，“我应该停止只使用幼稚的算法，开始应用一些优化”。好了，原来我拿了一个调试版本的锈蚀分析器作为测试驱动！用-发布-重建解决了这个问题。</p><p> Aside: the fact that debug builds often are unusably slow is a big issue for Rust.</p><p>旁白：对于Rust来说，调试构建通常非常慢的事实是一个大问题。</p><p> Having baseline good performance definitely helps with productivity — optimizing code for performance usually makes it harder to refactor.The longer you can punt on the low-level performance optimizations (as opposed to the architecture-level performance work), the less total work you’ll do.</p><p>拥有基准良好的性能绝对有助于提高生产力 - 针对性能优化代码通常会使重构变得更加困难。您可以在低级别的性能优化上投入的时间越长(与体系结构级别的性能工作相反)，您需要做的总工作就会越少。</p><p> What is more important is that Rust’s performance is predictable.Generally, running a program N times gives more-or-less the same result.This is in sharp contrast to JVM, where you need to do a lot of warm-up to stabilize even microbenchmarks.I’ve never succeeded with reproducible macro benchmarks in IntelliJ Rust.</p><p>更重要的是，Rust的性能是可预测的。通常，运行一个程序N次会得到大致相同的结果。这与JVM形成鲜明对比，在JVM中，您需要做大量热身才能稳定甚至是微基准测试。在IntelliJ Rust中，我从未成功地进行过可重现的宏基准测试。</p><p> More generally, without runtime there’s much less variation in the behavior of the program.This makes chasing regressions much more effective.</p><p>更广泛地说，没有运行时，程序行为的变化要小得多，这使得追逐回归更加有效。</p><p> Just to be clear, one thing which was  not different is memory safety: there were no segfaults or heap corruptions in either project.Similarly, null pointer dereferences weren’t an issue.</p><p>需要说明的是，有一件事没有什么不同，那就是内存安全：两个项目都没有段错误或堆损坏，同样，空指针取消引用也不是问题。</p><p> These are the most significant benefits of Rust over other systems languages, but for the applications at hand they were irrelevant.</p><p>与其他系统语言相比，这些是Rust最重要的优点，但是对于手头的应用程序来说，它们是无关紧要的。</p><p> I think the unifying topic of many discussed points is “programming in the large”.Modularity, build process, predictability only start to matter once the code grows in volume, age, and the amount of contributors.I like  Titus Winters formulation that “software engineering is programming integrated over time”.Rust excels at this kind of work, it is a scalable language.</p><p>我认为许多讨论点的统一主题是“大规模编程”。模块化、构建过程、可预测性只有在代码的数量、年龄和贡献者的数量增长时才开始重要。我喜欢Ttes Winters的表述，即“软件工程是随着时间的推移进行集成的编程”。Rust擅长这类工作，它是一种可伸缩的语言。</p><p> Another thing I’ve come to appreciate more is that Rust might be a plausible candidate for a nearly universal language.To throw in another great quote (by  John Carmack), “the right tool for the job is often the tool you are already using”.Context switching and bridging different technologies takes a lot of effort.With Rust, you often don’t need to!It naturally scales down to the bare metal.As this post explores, it works fine for application-level programming as well.Rust even works for scripting to some extent!rust-analyzer’s build infra is in theory better suited for bash and Python, but, in practice,  Rust works just fine, and is delightfully cross platform.</p><p>我更欣赏的另一件事是，Rust可能是一种几乎通用的语言的一个看似合理的候选者。引用另一句很棒的话(John Carmack)：“适合这项工作的正确工具通常是你已经在使用的工具”。上下文切换和连接不同技术需要很多Effort。使用Rust，你通常不需要！它自然可以缩减到裸金属。正如本文所探索的，它也可以很好地用于应用程序级编程。Rust甚至在某种程度上也适用于脚本编写！Rust-Analyzer的构建基础在理论上更适合bash和Python，但在实践中，它可以很自然地缩减到裸露的金属。正如本文所探索的那样，它也可以很好地用于应用程序级编程。在某种程度上，Rust甚至还可以用于脚本编写！Rust-Analyzer的构建基础在理论上更适合bash和Python，但在实践中，铁锈可以很好地工作，并且可以很好地跨平台。</p><p> Finally, I want to re-iterate that the present case study concerns only two projects which are similar, but not twins.The context is also important: not relying on third-party libraries for core functionality is a bit unusual for application programming.So, while I think that this experience and analysis point in the qualitatively right direction, you quantitative results may vary greatly!</p><p>最后，我想重申，本案例研究只涉及两个相似但不是孪生的项目。上下文也很重要：核心功能不依赖第三方库对于应用程序编程来说有点不寻常。因此，虽然我认为这种经验和分析指向了定性正确的方向，但您的定量结果可能会有很大差异！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ferrous-systems.com/blog/rust-as-productive-as-kotlin/">https://ferrous-systems.com/blog/rust-as-productive-as-kotlin/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/铁锈/">#铁锈</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031806.html"><img src="http://img2.diglog.com/img/2020/10/thumb_26bcb0bc85f464453de16206c6403500.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031806.html">在IAB意大利提出申诉后，意大利反垄断机构调查谷歌涉嫌滥用其在在线展示广告市场的主导地位</a></div><span class="my_story_list_date">2020-10-29 9:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031754.html"><img src="http://img2.diglog.com/img/2020/10/thumb_0627a7b97f6fe46deae88895cfb775a3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031754.html">
谷歌展示广告业务在意大利接受反垄断调查</a></div><span class="my_story_list_date">2020-10-28 20:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031702.html"><img src="http://img2.diglog.com/img/2020/10/thumb_778b5ac5f0146f57a7ec6f42afda2e57.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031702.html">Visa计划收购格子布面临司法部反垄断审查</a></div><span class="my_story_list_date">2020-10-28 12:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031534.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7a527ab23589b887728e38a147756505.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031534.html">谷歌搜索竞争对手敦促欧盟重新审查Android反垄断案</a></div><span class="my_story_list_date">2020-10-28 0:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>