<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用VHDL编写的第四款SoC Forth SoC Written in VHDL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Forth SoC Written in VHDL<br/>用VHDL编写的第四款SoC </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 02:31:55</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/3fa05b2ea1d548250be9cabd986b3d67.jpeg"><img src="http://img2.diglog.com/img/2021/2/3fa05b2ea1d548250be9cabd986b3d67.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This project implements a small stack computer tailored to executing Forthbased on the  J1 CPU. The processor has been rewritten in  VHDL from Verilog, and extended slightly.</p><p>该项目实现了一个小型堆栈计算机，该计算机专门为基于J1 CPU执行Forth而设计。该处理器已从Verilog用VHDL重写，并进行了少许扩展。</p><p>  Create a  FORTH for the processor which can take its input either from a UART or a USB keyboard and a  VGA adapter.</p><p>  为处理器创建一个FORTH，可以从UART或USB键盘和VGA适配器获取其输入。</p><p>  The H2 processor, like the  J1, is a stack based processor that executes aninstruction set especially suited for  FORTH.</p><p>  与J1一样，H2处理器也是基于堆栈的处理器，它执行特别适合FORTH的指令集。</p><p> The current target is the  Nexys3 board, with a  Xilinx Spartan-6 XC6LX16-CS324 FPGA, new boards will be targeted in the future as this board is reaching it&#39;send of life. The  VHDL is written in a generic way, with hardware componentsbeing inferred instead of explicitly instantiated, this should make the codefairly portable, although the interfaces to the  Nexys3 board components arespecific to the peripherals on that board.</p><p> 当前的目标是采用Xilinx Spartan-6 XC6LX16-CS324 FPGA的Nexys3板，随着该板即将达到其使用寿命，未来将以新板为目标。 VHDL是用通用的方式编写的，可以推断出硬件组件，而不是显式实例化硬件组件，尽管与Nexys3电路板组件的接口特定于该电路板上的外围设备，但这应该使代码具有可移植性。</p><p>    The SoC can also be simulated with a simulator written in C, as shown below:</p><p>    SoC也可以使用用C编写的仿真器进行仿真，如下所示：</p><p>     The licenses used by the project are mixed and are on a per file basis. For mycode I use the  MIT license - so feel free to use it as you wish. The otherlicenses used are the  LGPL and the  Apache 2.0 license, they are confinedto single modules so could be removed if you have some aversion to  LGPL code.</p><p>     项目使用的许可证是混合使用的，并且基于每个文件。对于mycode，我使用MIT许可证-请随意使用它。使用的其他许可证是LGPL和Apache 2.0许可证，它们仅限于单个模块，因此，如果您对LGPL代码有某种厌恶，可以将其删除。</p><p>  The only target board available at the moment is the  Nexys3, this shouldchange in the future as the board is currently at it&#39;s End Of Life. The nextboards I am looking to support are it&#39;s successor, the Nexys 4, and the myStormBlackIce ( https://mystorm.uk/). The myStorm board uses a completely opensource toolchain for synthesis, place and route and bit file generation.</p><p>  目前唯一可用的目标板是Nexys3，这种情况应该在将来改变，因为该板目前正处于生命周期的尽头。我希望支持的下一个板是它的继任者Nexys 4和myStormBlackIce（https://mystorm.uk/）。 myStorm板使用完整的开源工具链进行合成，放置和布线以及位文件生成。 </p><p>      Nexys3 development board (if communication via UART only isdesired, the VGA Monitor and USB and Keyboard are not needed).</p><p>Nexys3开发板（如果仅需要通过UART进行通讯，则不需要VGA监视器以及USB和键盘）。</p><p> Xilinx ISE can (or could be) downloaded for free, but requiresregistration. ISE needs to be on your path:</p><p> Xilinx ISE可以（或可以免费）下载，但需要注册。 ISE必须顺其自然：</p><p>             Which will assemble the H2 Forth source file  embed.fth, and run the assembledobject file under the H2 simulator with the debugger activated. A graphicalsimulator can be run with:</p><p>             它将汇编H2 Forth源文件embed.fth，并在调试器激活的情况下在H2模拟器下运行assembledobject文件。图形仿真器可以与以下程序一起运行：</p><p>      This project targets the original  J1 core and provides a eForthimplementation (written using  Gforth as for meta-compilation/crosscompilation to the  J1 core). It also provides a simulator for the systemwritten in  C.</p><p>      该项目针对原始的J1内核，并提供了eForthimplementation（使用Gforth编写，用于对J1内核的元编译/交叉编译）。它还为用C语言编写的系统提供了一个模拟器。</p><p>     The H2 processor and associated peripherals are now quite stable, however thesource is always the definitive guide as to how instructions and peripheralsbehave, as well as the register map.</p><p>     H2处理器和相关的外围设备现在非常稳定，但是该资源始终是有关指令和外围设备的行为以及寄存器映射的权威指南。</p><p>  A CPU hold line which keeps the processor in the same state so long as it ishigh.</p><p>  CPU保持线，只要处理器处于高电平，它就将处理器保持在相同状态。</p><p>  The H2 CPU behaves very similarly to the  J1 CPU, and the  J1 PDF can beread in order to better understand this processor. The processor is 16-bit withinstructions taking a single clock cycle. Most of the primitive Forth words canalso be executed in a single cycle as well, one notable exception is store (&#34;!&#34;),which is split into two instructions.</p><p>  H2 CPU的行为与J1 CPU非常相似，可以阅读J1 PDF以更好地了解该处理器。处理器为16位指令，占用单个时钟周期。大部分原始的Forth单词也可以在一个周期内执行，其中一个值得注意的例外是store（＆＃34;！＆＃34;），它被分为两条指令。 </p><p>   Loads and stores into the block RAM that holds the H2 program discard thelowest bit, every other memory operation uses the lower bit (such as jumpsand loads and stores to Input/Output peripherals). This is so applications canuse the lowest bit for character operations when accessing the program RAM.</p><p>加载并存储到保存H2程序的Block RAM中，丢弃最低位，其他每一次存储操作都使用该低位（例如，跳转并加载并存储到Input / Output外设）。因此，应用程序可以在访问程序RAM时使用最低位进行字符操作。</p><p>  +---------------------------------------------------------------+| F | E | D | C | B | A | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+---------------------------------------------------------------+| 1 | LITERAL VALUE |+---------------------------------------------------------------+| 0 | 0 | 0 | BRANCH TARGET ADDRESS |+---------------------------------------------------------------+| 0 | 0 | 1 | CONDITIONAL BRANCH TARGET ADDRESS |+---------------------------------------------------------------+| 0 | 1 | 0 | CALL TARGET ADDRESS |+---------------------------------------------------------------+| 0 | 1 | 1 | ALU OPERATION |T2N|T2R|N2A|R2P| RSTACK| DSTACK|+---------------------------------------------------------------+| F | E | D | C | B | A | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+---------------------------------------------------------------+T : Top of data stackN : Next on data stackPC : Program CounterLITERAL VALUES : push a value onto the data stackCONDITIONAL : BRANCHS pop and test the TCALLS : PC+1 onto the return stackT2N : Move T to NT2R : Move T to top of return stackN2A : STORE T to memory location addressed by NR2P : Move top of return stack to PCRSTACK and DSTACK are signed values (twos compliment) that arethe stack delta (the amount to increment or decrement the stackby for their respective stacks: return and data)</p><p>  + ------------------------------------------------- -------------- + | F | E | D | C | B | A | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- ---------------- + | 1 |文学价值| + ---------------------------------------------- ----------------- + | 0 | 0 | 0 |分支目标地址| + --------------------------------------------- ------------------ + | 0 | 0 | 1 |有条件的分支目标地址| + -------------------------------------------- ------------------- + | 0 | 1 | 0 |致电目标地址| + --------------------------------------------- ------------------ + | 0 | 1 | 1 | ALU操作| T2N | T2R | N2A | R2P | RSTACK | DSTACK | + ----------------------------------------------- ---------------- + | F | E | D | C | B | A | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- ---------------- + T：数据堆栈的顶部N：数据堆栈的下一个PC：程序计数器的文字值：将一个值压入数据堆栈条件：分支弹出并测试TCALLS：PC + 1到返回堆栈T2N：将T移至NT2R：将T移至返回堆栈的顶部N2A：将T存储到NR2P寻址的内存位置：将返回堆栈的顶部移至PCRSTACK和DSTACK是带符号的值（二进制补码），其为堆栈增量（用于增加或减少各自堆栈的堆栈的数量：返回和数据）</p><p>     Registers marked prefixed with an &#39;o&#39; are output registers, those with an &#39;i&#39;prefix are input registers. Registers are divided into an input and outputsection of registers and the addresses of the input and output registers do notcorrespond to each other in all cases.</p><p>     标记有前缀＆＃39; o＆＃39;的寄存器是输出寄存器，带有＆i前缀的是输入寄存器。寄存器被分为寄存器的输入和输出部分，并且输入和输出寄存器的地址在所有情况下都不相互对应。</p><p> The following peripherals have been implemented in the  VHDL SoC tointerface with devices on the  Nexys3 board:</p><p> VHDL SoC中已实现以下外围设备，以与Nexys3板上的设备接口：</p><p> VGA output device, text mode only, 80 by 40 characters from http://www.javiervalcarce.eu/html/vhdl-vga80x40-en.html. This hasbeen heavily modified from the original, which now implements most of a VT100 terminal emulator. This has two fonts available to it:</p><p> VGA输出设备，仅文本模式，来自http://www.javiervalcarce.eu/html/vhdl-vga80x40-en.html的80 x 40字符。与原始版本相比，该版本已进行了重大修改，现在已实现了大多数VT100终端仿真器。它有两种可用的字体：</p><p>      The following description of the registers should be read in order and describehow the peripherals work as well.</p><p>      应按顺序阅读以下对寄存器的描述，并描述外设如何工作。</p><p>  A UART with a fixed baud rate and format (115200, 8 bits, 1 stop bit) ispresent on the SoC. The UART has a FIFO of depth 8 on both the RX and TXchannels. The control of the UART is split across oUart and iUart.</p><p>  SoC上具有一个具有固定波特率和格式（115200、8位，1个停止位）的UART。 UART在RX和TX通道上均具有深度为8的FIFO。 UART的控制权分为oUart和iUart。 </p><p> To write a value to the UART assert TXWE along with putting the data in TXDO.The FIFO state can be analyzed by looking at the iUart register.</p><p>为了将一个值写入UART断言TXWE以及将数据放入TXDO。可以通过查看iUart寄存器来分析FIFO状态。</p><p> To read a value from the UART: iUart can be checked to see if data is presentin the FIFO, if it is assert RXRE in the oUart register, on the next clockcycle the data will be present in the iUart register.</p><p> 要从UART读取值：可以检查iUart以查看FIFO中是否存在数据，如果在oUart寄存器中将RXRE置为有效，则在下一个时钟周期，数据将在iUart寄存器中显示。</p><p> The baud rate of the UART can be changed by rebuilding the VHDL project, bitlength, parity bits and stop bits can only be changed with modifications to uart.vhd</p><p> 可以通过重建VHDL项目来更改UART的波特率，只能通过修改uart.vhd来更改位长，奇偶校验位和停止位</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X |TXWE| X | X |RXRE| X | X | TXDO |+-------------------------------------------------------------------------------+TXWE: UART TX Write EnableRXRE: UART RX Read EnableTXDO: UART TX Data Output</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | TXWE | X | X | RXRE | X | X | TXDO | + ----------------------------------------------- -------------------------------- + TXWE：UART TX写入使能RXRE：UART RX读取使能TXDO：UART TX数据输出</p><p>  The VGA Text device emulates a terminal which the user can talk to by writingto the oVT100 register. It supports a subset of the  VT100 terminalfunctionality. The interface behaves much like writing to a UART with the samebusy and control signals. The input is taken from a  PS/2 keyboard availableon the board, this behaves like the RX mechanism of the UART.</p><p>  VGA文本设备模拟一个终端，用户可以通过写入oVT100寄存器与之对话。它支持VT100终端功能的子集。该接口的行为非常类似于使用相同的繁忙和控制信号写入UART。输入来自板上的PS / 2键盘，其行为类似于UART的RX机制。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X |TXWE| X | X |RXRE| X | X | TXDO |+-------------------------------------------------------------------------------+TXWE: VT100 TX Write EnableRXRE: UART RX Read EnableTXDO: UART TX Data Output</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | TXWE | X | X | RXRE | X | X | TXDO | + ----------------------------------------------- -------------------------------- + TXWE：VT100 TX写EnableRXRE：UART RX读EnableTXDO：UART TX数据输出</p><p>  On the  Nexys3 board there is a bank of LEDs that are situated next to theswitches, these LEDs can be turned on (1) or off (0) by writing to LEDO. EachLED here corresponds to the switch it is next to.</p><p>  Nexys3板上的开关旁边有一组LED，可通过写入LEDO来打开（1）或关闭（0）这些LED。这里的每个LED对应于其旁边的开关。 </p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X | X | X | X | X | X | LEDO |+-------------------------------------------------------------------------------+LEDO: LED Output</p><p>+ ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | X | X | X | X | X | LEDO | + ----------------------------------------------- -------------------------------- + LEDO：LED输出</p><p>  The timer is controllable by the oTimerCtrl register, it is a 13-bit timerrunning at 100MHz, it can optionally generate interrupts and the current timersinternal count can be read back in with the iTimerDin register.</p><p>  计时器可由oTimerCtrl寄存器控制，它是一个13位的计时器，运行频率为100MHz，可以选择生成中断，并且可以使用iTimerDin寄存器读回当前的计时器内部计数。</p><p> The timer counts once the TE bit is asserted, once the timer reaches TCMP valueit wraps around and can optionally generate an interrupt by asserting INTE.This also toggles the Q and NQ lines that come out of the timer and are routedto pins on the board (see the constraints file  top.ucf for the pins).</p><p> 一旦TE位被置位，定时器就会计数，一旦定时器达到TCMP值，它就会回绕，并可以通过置位INTE产生中断（也可以切换从定时器出来的Q和NQ线，并路由到板上的引脚（请参见约束文件top.ucf中的引脚）。</p><p>  +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| TE | RST|INTE| TCMP |+-------------------------------------------------------------------------------+TE: Timer EnableRST: Timer ResetINTE: Interrupt EnableTCMP: Timer Compare Value</p><p>  + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | TE | RST | INTE | TCMP | + ----------------------------------------------- -------------------------------- + TE：定时器使能RST：定时器复位INTE：中断使能TCMP：定时器比较值</p><p>  The H2 core has a mechanism for interrupts, interrupts have to be enabled ordisabled with an instruction. Each interrupt can be masked off with a bit inIMSK to enable that specific interrupt. A &#39;1&#39; in a bit of IMSK enables thatspecific interrupt, which will be delivered to the CPU if interrupts areenabled within it.</p><p>  H2内核具有中断机制，必须通过指令启用或禁用中断。每个中断都可以用inIMSK位屏蔽以启用该特定中断。 ＆＃39; 1＆＃39;如果将IMSK中的某个位使能，则会启用该特定的中断，如果在其中启用了中断，则会将其发送到CPU。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X | X | X | X | X | X | IMSK |+-------------------------------------------------------------------------------+IMSK: Interrupt Mask</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | X | X | X | X | X | IMSK | + ----------------------------------------------- -------------------------------- + IMSK：中断屏蔽</p><p>   +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| BTXC |+-------------------------------------------------------------------------------+BTXC: Baud Clock Settings</p><p>   + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | BTXC | + ----------------------------------------------- -------------------------------- + BTXC：波特率时钟设置 </p><p>   +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| BRXC |+-------------------------------------------------------------------------------+BRXC: Baud Clock Settings</p><p>+ ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | BRXC | + ----------------------------------------------- -------------------------------- + BRXC：波特率时钟设置</p><p>   +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| Data Ouput |+-------------------------------------------------------------------------------+</p><p>   + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + |数据输出| + ---------------------------------------------- --------------------------------- +</p><p>  This register contains the control registers for the onboard memory on the Nexys3 board. The board contains three memory devices, two non-volatilememory devices and a volatile RAM based device. The two devices accessible by asimple SRAM interface (one volatile M45W8MW16, one non-volatile - aNP8P128A13T1760E) are both accessible, the third is an SPI based memory device,NP5Q128A13ESFC0E) and is currently not accessible.</p><p>  该寄存器包含Nexys3板上板载存储器的控制寄存器。该板包含三个存储设备，两个非易失性存储设备和一个基于易失性RAM的设备。可通过asimple SRAM接口访问的两个设备（一个易失性M45W8MW16，一个非易失性-aNP8P128A13T1760E）都可以访问，第三个是基于SPI的存储设备，NP5Q128A13ESFC0E），目前无法访问。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| OE | WE | RST|WAIT| RCS| FCS| Address Hi |+-------------------------------------------------------------------------------+OE: Output Enable - enable reading from current address into iMemDinWE: Write Enable - enable writing oMemDout into ram at current addressRST: Reset the Flash memory controllerRCS: RAM Chip Select, Enable Volatile MemoryFCS: Flash Chip Select, Enable Non-Volatile MemoryAddress Hi: High Bits of RAM address</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | OE |我们| RST |等待| RCS | FCS |地址嗨| + ---------------------------------------------- --------------------------------- + OE：输出启用-启用从当前地址读取到iMemDinWE：写入启用-启用将oMemDout写入当前地址的ram RST：重置闪存控制器RCS：RAM芯片选择，启用易失性存储器FCS：闪存芯片选择，启用非易失性MemoryAddress高：RAM地址的高位</p><p> OE and WE are mutually exclusive, if both are set then there is no effect.</p><p> OE和WE是互斥的，如果同时设置，则无效。</p><p>    +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| Address Lo |+-------------------------------------------------------------------------------+</p><p>    + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + |地址Lo | + ---------------------------------------------- --------------------------------- +</p><p>  On the  Nexys3 board there is a bank of 7 segment displays, with a decimalpoint (8-segment really), which can be used for numeric output. The LED segmentscannot be directly addressed. Instead the value stored in L8SD is mappedto a hexadecimal display value (or a BCD value, but this requires regenerationof the SoC and modification of a generic in the VHDL).</p><p>  在Nexys3板上，有一排7段显示器，带有小数点（实际上是8段），可用于数字输出。 LED段无法直接寻址。而是将存储在L8SD中的值映射到十六进制显示值（或BCD值，但这需要重新生成SoC并修改VHDL中的泛型）。 </p><p> The value &#39;0&#39; corresponds to a zero displayed on the LED segment, &#39;15&#39; to an&#39;F&#39;, etcetera.</p><p>值＆＃39; 0＆＃39;对应于在LED段上显示的零，＆＃39; 15＆＃39;到F＆＃39;等。</p><p>  +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| L7SD0 | L7SD1 | L7SD2 | L7SD3 |+-------------------------------------------------------------------------------+L7SD0: LED 7 Segment Display (leftmost display)L7SD1: LED 7 Segment DisplayL7SD2: LED 7 Segment DisplayL7SD3: LED 7 Segment Display (right most display)</p><p>  + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | L7SD0 | L7SD1 | L7SD2 | L7SD3 | + ----------------------------------------------- -------------------------------- + L7SD0：LED 7段显示（最左侧显示）L7SD1：LED 7段显示L7SD2： LED 7段显示器L7SD3：LED 7段显示器（最右边的显示器）</p><p>  The iUart register works in conjunction with the oUart register. The status ofthe FIFO that buffers both transmission and reception of bytes is available inthe iUart register, as well as any received bytes.</p><p>  iUart寄存器与oUart寄存器结合使用。缓冲字节发送和接收的FIFO的状态在iUart寄存器中以及任何接收到的字节中都可用。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X |TFFL|TFEM| X |RFFL|RFEM| RXDI |+-------------------------------------------------------------------------------+TFFL: UART TX FIFO FullTFEM: UART TX FIFO EmptyRFFL: UART RX FIFO FullRFEM: UART RX FIFO EmptyRXDI: UART RX Data Input</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | TFFL | TFEM | X | RFFL | RFEM | RXDI | + ----------------------------------------------- -------------------------------- + TFFL：UART TX FIFO FullTFEM：UART TX FIFO空RFFL：UART RX FIFO FullRFEM： UART RX FIFO空RXDI：UART RX数据输入</p><p>  The iVT100 register works in conjunction with the oVT100 register. The status ofthe FIFO that buffers both transmission and reception of bytes is available inthe iVT100 register, as well as any received bytes. It works the same as theiUart/oUart registers.</p><p>  iVT100寄存器与oVT100寄存器配合使用。 iVT100寄存器以及任何接收到的字节都可以缓存用于字节发送和接收的FIFO的状态。它与theUUart / oUart寄存器的工作方式相同。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X |TFFL|TFEM| X |RFFL|RFEM| 0 | ACHR |+-------------------------------------------------------------------------------+TFFL: VGA VT100 TX FIFO FullTFEM: VGA VT100 TX FIFO EmptyRFFL: PS2 VT100 RX FIFO FullRFEM: PS2 VT100 RX FIFO EmptyACHR: New character available on PS2 Keyboard</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | TFFL | TFEM | X | RFFL | RFEM | 0 | ACHR | + ----------------------------------------------- -------------------------------- + TFFL：VGA VT100 TX FIFO FullTFEM：VGA VT100 TX FIFO空RFFL：PS2 VT100 RX FIFO FullRFEM：PS2 VT100 RX FIFO空ACHR：PS2键盘上有新字符</p><p>   +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X | TCNT |+-------------------------------------------------------------------------------+TCNT: Timer Counter Value</p><p>   + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | TCNT | + ----------------------------------------------- -------------------------------- + TCNT：计时器计数器值 </p><p>  iSwitches contains input lines from multiple sources. The buttons(BUP, BDWN, BLFT, BRGH, and BCNT) correspond to a  D-Pad on the  Nexys3board. The switches (TSWI) are the ones mentioned in oLeds, each have an LEDnext to them.</p><p>iSwitches包含来自多个来源的输入线。按钮（BUP，BDWN，BLFT，BRGH和BCNT）对应于Nexys3板上的D-Pad。开关（TSWI）是本手册中提到的开关，每个开关旁边都有一个LEDnext。</p><p> The switches and the buttons are already debounced in hardware so they do nothave to be further processed once read in from these registers.</p><p> 开关和按钮已经在硬件中进行了防抖动处理，因此一旦从这些寄存器中读取它们就无需进一步处理。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| X | X | X | BUP|BDWN|BLFT|BRGH|BCNT| TSWI |+-------------------------------------------------------------------------------+BUP: Button UpBDWN: Button DownBLFT: Button LeftBRGH: Button RightBCNT: Button CenterTSWI: Two Position Switches</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + | X | X | X | BUP | BDWN | BLFT | BRGH | BCNT | TSWI | + ----------------------------------------------- -------------------------------- + BUP：按钮向上BDWN：按钮向下BLFT：按钮向左BRGH：按钮向右BCNT：按钮向中TSWI：两个位置开关</p><p>  Memory input, either from the SRAM or Flash, indexed by oMemControl andoMemAddrLow. When reading from flash this might actually be status informationor information from the query table.</p><p>  来自SRAM或闪存的存储器输入，由oMemControl和oMemAddrLow索引。从闪存读取时，这实际上可能是状态信息或来自查询表的信息。</p><p> +-------------------------------------------------------------------------------+| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |+-------------------------------------------------------------------------------+| Data Input |+-------------------------------------------------------------------------------+</p><p> + ------------------------------------------------- ------------------------------ + | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | + ----------------------------------------------- -------------------------------- + |数据输入| + ---------------------------------------------- --------------------------------- +</p><p>    When an interrupt occurs, and interrupts are enabled within the processor, thena call to the location in memory is performed - the location is the same as theISR number. An ISR with a number of &#39;4&#39; will perform a call (not a jump) to thelocation &#39;4&#39; within memory, for example.</p><p>    当发生中断并在处理器中启用了中断时，将对内存中的位置进行调用-该位置与ISR号相同。 ISR的数量为＆＃39; 4＆＃39;将会对位置＆＃39; 4＆＃39;进行调用（而不是跳转）例如在内存中。</p><p> Interrupts have a latency of at least 4-5 cycles before they are acted on, thereis a two to three cycle delay in the interrupt request handler, then the callto the ISR location in memory has to be done, then the call to the word thatimplements the ISR itself.</p><p> 采取措施之前，中断的延迟至少为4-5个周期，在中断请求处理程序中存在2至3个周期的延迟，然后必须执行对内存中ISR位置的调用，然后调用对实现字的调用ISR本身。 </p><p> If two interrupts occur at the same time they are processed from the lowestinterrupt number to the highest.</p><p>如果两个中断同时发生，则从最小的中断号到最大的中断号进行处理。</p><p> Interrupts are lost when an interrupt with the same number occurs that has notbeen processed.</p><p> 当发生相同编号的中断但尚未处理时，中断将丢失。</p><p>  The Disassembler and  C based simulator for the H2 is in a singleprogram (see  h2.c). This simulator complements the  VHDL test bench tb.vhd and is not a replacement for it. The meta-compiler runs on top of aneForth interpreter and it contained within the files  embed.c and embed.blk. The meta-compiler (Forth parlance for a cross-compiler) is aForth program which is used to create the eForth image that runs on the target.</p><p>  H2的基于Disassembler和C的模拟器在单个程序中（请参阅h2.c）。该模拟器是VHDL测试平台tb.vhd的补充，不能替代它。元编译器在aneForth解释器的顶部运行，它包含在embed.c和embed.blk文件中。元编译器（Forth交叉编译器的用语）是一个Forth程序，用于创建在目标上运行的eForth映像。</p><p> The toolchain is currently in flux, going forward there is liable to moreintegration between  h2.c and  embed.c, along with changing the EmbedVirtual Machine into one that more closely resembles the H2 CPU with the longterm goal of creating a self hosting system.</p><p> 该工具链目前处于不断发展的过程中，因此，h2.c和embed.c之间可能会进行更多集成，同时将EmbedVirtual Machine更改为更类似于H2 CPU的目标，其长期目标是创建自托管系统。</p><p> To build both, a  C compiler is needed, the build target &#34;h2&#34; will build theexecutable, h2, and &#34;embed&#34; will build the meta-compiler:</p><p> 要同时构建两者，需要使用C编译器，构建目标为＆＃34; h2＆＃34;。将构建可执行文件，h2和＆embedded＆＃34;将构建元编译器：</p><p>     Linux:cc -std=c99 h2.c -o h2 # To build the h2 executablecc -std=c99 embed.c -o embed # To build the embed VM executable./embed embed.blk embed.hex embed.fth # Create the target eForth image./h2 -h # For a list of options./h2 -r embed.hex # Run the assembled fileWindows:gcc -std=c99 h2.c -o h2.exe # Builds the h2.exe executablegcc -std=c99 embed.c -o embed.exe # Builds the embed.exe executableembed.exe embed.blk embed.hex embed.fth # Create the target eForth iamgeh2.exe -h # For a list of optionsh2.exe -r embed.hex # Run the assembled file</p><p>     Linux：cc -std = c99 h2.c -o h2＃生成h2可执行文件cc -std = c99 embed.c -o embed＃生成embed VM可执行文件./embed embed.blk embed.hex embed.fth＃创建/ h2 -h＃获取选项列表./h2 -r embed.hex＃运行汇编文件Windows：gcc -std = c99 h2.c -o h2.exe＃构建h2.exe可执行文件gcc- std = c99 embed.c -o embed.exe＃构建embed.exe可执行文件embed.exe embed.blk embed.hex embed.fth＃创建目标eForth iamgeh2.exe -h＃获取选项列表h2.exe -r embed .hex＃运行汇编文件</p><p>  - stop processing options, following arguments are files -h print a help message and exit -v increase logging level -d disassemble input files (default) -D full disassembly of input files -T Enter debug mode when running simulation -r run hex file -L # load symbol file -s # number of steps to run simulation (0 = forever)-n # specify NVRAM block file (default is nvram.blk) file* file to process</p><p>  -停止处理选项，以下参数为文件-h打印帮助消息并退出-v增加日志记录级别-d分解输入文件（默认）-D完全分解输入文件-T运行仿真时进入调试模式-r运行十六进制文件-L＃加载符号文件-s＃运行模拟的步骤数（0 =永久）-n＃指定要处理的NVRAM块文件（默认为nvram.blk）文件* </p><p> This program is released under the  MIT license, feel free to use it andmodify it as you please. With minimal modification it should be able toassemble programs for the original  J1 core.</p><p>该程序是根据MIT许可发布的，可以随意使用并根据需要进行修改。通过最少的修改，它应该能够为原始J1内核汇编程序。</p><p>  The meta-compiler runs on top of the  embed virtual machine, it is a 16-bitvirtual machine that originally descended from the H2 CPU. The project includesa meta-compilation scheme that allows an eForth image to generate a new eForthimage with modifications. That system has been adapted for use with the H2,which replaced the cross compiler written in C, which allowed the first imagefor the H2 to be created.</p><p>  元编译器在嵌入式虚拟机上运行，​​它是最初从H2 CPU派生的16位虚拟机。该项目包括一个元编译方案，该方案允许eForth图像生成经过修改的新eForthimage。该系统适用于H2，它取代了用C编写的交叉编译器，从而允许创建H2的第一个映像。</p><p> The meta-compiler is an ordinary Forth program, it is contained within embed.fth. The meta-compiler Forth program is then used to build up aneForth image capable of running on the H2 target.</p><p> 元编译器是一个普通的Forth程序，它包含在embed.fth中。然后，使用元编译器Forth程序来构建能够在H2目标上运行的aneForth映像。</p><p>    The disassembler takes a text file containing the assembled program, whichconsists of 16-bit hexadecimal numbers. It then attempts to disassemble theinstructions. It can also be fed a symbols file which can be generated by theassembler and attempt to find the locations jumps and calls point to.</p><p>    反汇编程序获取包含已汇编程序的文本文件，该文件由16位十六进制数字组成。然后，它尝试反汇编指令。也可以向它提供一个符号文件，该文件可以由汇编器生成，并尝试查找跳转和调用指向的位置。</p><p> The disassembler is used by a  tcl script called by  GTKwave, itturns the instruction trace of the H2 from a series </p><p> 反汇编程序由GTKwave调用的tcl脚本使用，它将来自系列的H2的指令跟踪</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/howerj/forth-cpu">https://github.com/howerj/forth-cpu</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/vhdl/">#vhdl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/written/">#written</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/h2/">#h2</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>