<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PyInstrument-关注慢速部分的统计Python配置文件</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PyInstrument-关注慢速部分的统计Python配置文件</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 22:46:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/ebba69f4297e762af60b8f98f2e4d95d.png"><img src="http://img2.diglog.com/img/2020/10/ebba69f4297e762af60b8f98f2e4d95d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Pyinstrument is a Python profiler. A profiler is a tool to help you &#39;optimize&#39;your code - make it faster. It sounds obvious, but to get the biggest speedincrease you should  focus on the slowest part of your program.Pyinstrument helps you find it!</p><p>PyInstrument是一个Python分析器。分析器是一种工具，可以帮助您优化代码-使其速度更快。这听起来很明显，但是要获得最大的速度提升，您应该专注于程序中最慢的部分。PyInstrument会帮助您找到它！</p><p>      To run Pyinstrument from a git checkout, there&#39;s a build step.Take a look at  Contributing for more info.</p><p>要从GIT签出运行PyInstrument，有一个构建步骤。看看如何贡献更多信息。</p><p>   Call Pyinstrument directly from the command line. Instead of writing python script.py, type  pyinstrument script.py. Your script will run asnormal, and at the end (or when you press  ^C), Pyinstrument will output acolored summary showing where most of the time was spent.</p><p>直接从命令行调用PyInstrument。不是编写python script.py，而是输入pyInstrument script.py。您的脚本将正常运行，并且在结束时(或者当您按^C时)，PyInstrument将输出彩色摘要，显示大部分时间都花在哪里。</p><p>  Usage: pyinstrument [options] scriptfile [arg] ...Options: --version show program&#39;s version number and exit -h, --help show this help message and exit --load-prev=ID Instead of running a script, load a previous report -m MODULE_NAME run library module as a script, like &#39;python -m module&#39; -o OUTFILE, --outfile=OUTFILE save to &lt;outfile&gt; -r RENDERER, --renderer=RENDERER how the report should be rendered. One of: &#39;text&#39;, &#39;html&#39;, &#39;json&#39;, or python import path to a renderer class -t, --timeline render as a timeline - preserve ordering and don&#39;t condense repeated calls --hide=EXPR glob-style pattern matching the file paths whose frames to hide. Defaults to &#39;*/lib/*&#39;. --hide-regex=REGEX regex matching the file paths whose frames to hide. Useful if --hide doesn&#39;t give enough control. --show-all (text renderer only) show external library code --unicode (text renderer only) force unicode text output --no-unicode (text renderer only) force ascii text output --color (text renderer only) force ansi color text output --no-color (text renderer only) force no color text output</p><p>用法：pyInstrument[选项]scriptfile[arg]...选项：--version show program的版本号和exit-h，--help显示此帮助消息并退出--load-prev=ID如果不运行脚本，请加载以前的报表-m module_name将库模块作为脚本运行，如&#39；python-m module&#39；-o OUTFILE，--outfile=OUTFILE save to&lt；outfile&gt；-r渲染器，--renender=渲染器应如何呈现报表。以下内容之一：text&39；、html&39；、&#39；json&39；或到渲染器类的python导入路径-t、--timeline呈现为时间线-保留顺序，并且不压缩重复调用--ide=expr glob样式模式，匹配要隐藏其帧的文件路径。默认为&#39；*/lib/*&#39；。--Hide-regex=与要隐藏其帧的文件路径匹配的REGEX regex。如果--HIDE没有给予足够的控制，那就有用了。--show-all(仅限文本渲染器)显示外部库代码--unicode(仅限文本渲染器)强制Unicode文本输出--no-unicode(仅限文本渲染器)强制ascii文本输出--color(仅限文本渲染器)强制ansi彩色文本输出--no-color(仅限文本渲染器)强制不输出彩色文本。</p><p> Protip:  -r html will give you a interactive profile report as HTML - youcan really explore this way!</p><p>ProTip：-r html会给你一个HTML格式的交互式个人资料报告--你真的可以通过这种方式来探索！</p><p>        Once installed, add  ?profile to the end of a request URL to activate theprofiler. Your request will run as normal, but instead of getting the response,you&#39;ll get pyinstrument&#39;s analysis of the request in a web page.</p><p>安装后，将？PROFILE添加到请求URL的末尾以激活探查器。您的请求将照常运行，但您不会得到响应，而是会在网页中获得pyInstrument对请求的分析。</p><p> If you&#39;re writing an API, it&#39;s not easy to change the URL when you want toprofile something. In this case, add  PYINSTRUMENT_PROFILE_DIR = &#39;profiles&#39;to your  settings.py. Pyinstrument will profile every request and save theHTML output to the folder  profiles in your working directory.</p><p>如果您正在编写API，当您想要分析某些内容时，更改URL并非易事。在这种情况下，将PYINSTRUMENT_PROFILE_DIR=&#39；PROFILES=#39；添加到settings.py。PyInstrument将分析每个请求，并将HTML输出保存到您工作目录中的文件夹配置文件中。</p><p> If you want to show the profiling page depending on the request you can define PYINSTRUMENT_SHOW_CALLBACK as dotted path to a function used for determiningwhether the page should show or not.You can provide your own function callback(request) which returns True or Falsein your settings.py.</p><p>如果要根据请求显示分析页面，可以将PYINSTRUMENT_SHOW_CALLBACK定义为函数的虚线路径，该函数用于确定是否应该显示页面。您可以提供自己的函数回调(Request)，它在settings.py中返回True或False。</p><p>    from  flask  import  Flask,  g,  make_response,  request app  =  Flask( __name__) @ app. before_request def  before_request():  if  &#34;profile&#34;  in  request. args:  g. profiler  =  Profiler()  g. profiler. start() @ app. after_request def  after_request( response):  if  not  hasattr( g,  &#34;profiler&#34;):  return  response  g. profiler. stop()  output_html  =  g. profiler. output_html()  return  make_response( output_html)</p><p>从flask import Flask，g，make_response，请求app=flask(__Name__)@app。BEFORE_REQUEST定义BEFORE_REQUEST()：如果请求中的&#34；配置文件&#34；。参数：g.profiler=profiler()g.profiler。Start()@app。AFTER_REQUEST定义AFTER_REQUEST(Response)：如果没有hasattr(g，&#34；profiler&#34；)：返回响应g.profiler。Stop()output_html=g.profiler。Output_html()返回make_response(Output_Html)。</p><p> This will check for the  ?profile query param on each request and if found,it starts profiling. After each request where the profiler was running itcreates the html output and returns that instead of the actual response.</p><p>这将检查每个请求上的？Profile查询参数，如果找到，则开始分析。在分析器运行的每个请求之后，它创建html输出并返回该输出，而不是实际的响应。</p><p>  I&#39;d love to have more ways to profile using Pyinstrument - e.g. otherweb frameworks. PRs are encouraged!</p><p>我希望有更多的方式使用PyInstrument进行分析--例如其他Web框架。鼓励使用PRS！</p><p>   Pyinstrument is a statistical profiler - it doesn&#39;t track everyfunction call that your program makes. Instead, it&#39;s recording the call stackevery 1ms.</p><p>PyInstrument是一个统计分析器-它不会跟踪您的程序进行的每个函数调用。取而代之的是，它每1ms记录一次呼叫堆栈。</p><p> That gives some advantages over other profilers. Firstly, statisticalprofilers are much lower-overhead than tracing profilers.</p><p>与其他分析器相比，这提供了一些优势。首先，统计分析器比跟踪分析器开销低得多。</p><p> ████████████████  0.33s</p><p>█0.33s。</p><p>  ████████████████████  0.43s</p><p>█0.43s。</p><p> █████████████████████████████  0.61s</p><p>██0.61s</p><p> ██████████████████████████████████...██ 6.79s</p><p>██...██6.79s。</p><p> But low overhead is also important because it can distort the results. Whenusing a tracing profiler, code that makes a lot of Python function callsinvokes the profiler a lot, making it slower. This distorts theresults, and might lead you to optimise the wrong part of your program!</p><p>但低开销也很重要，因为它会扭曲结果。当使用跟踪探查器时，进行大量Python函数调用的代码会大量调用探查器，从而使其速度变慢。这会扭曲结果，并可能导致您优化程序的错误部分！</p><p>  The standard Python profilers   profile and   cProfile show you abig list of functions, ordered by the time spent in each function.This is great, but it can be difficult to interpret  why those functions aregetting called. It&#39;s more helpful to know why those functions are called, andwhich parts of user code were involved.</p><p>标准的Python分析器配置文件和cProfile向您显示一个函数列表，按每个函数花费的时间排序。这很好，但是很难解释为什么调用这些函数。了解调用这些函数的原因以及涉及到用户代码的哪些部分会更有帮助。</p><p> For example, let&#39;s say I want to figure out why a web request in Django isslow. If I use cProfile, I might get this:</p><p>例如，假设我想弄清楚为什么Django中的Web请求速度很慢。如果我使用cProfile，我可能会得到这样的结果：</p><p> 151940 function calls (147672 primitive calls) in 1.696 seconds Ordered by: cumulative time ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 1.696 1.696 profile:0(&lt;code object &lt;module&gt; at 0x1053d6a30, file &#34;./manage.py&#34;, line 2&gt;) 1 0.001 0.001 1.693 1.693 manage.py:2(&lt;module&gt;) 1 0.000 0.000 1.586 1.586 __init__.py:394(execute_from_command_line) 1 0.000 0.000 1.586 1.586 __init__.py:350(execute) 1 0.000 0.000 1.142 1.142 __init__.py:254(fetch_command) 43 0.013 0.000 1.124 0.026 __init__.py:1(&lt;module&gt;) 388 0.008 0.000 1.062 0.003 re.py:226(_compile) 158 0.005 0.000 1.048 0.007 sre_compile.py:496(compile) 1 0.001 0.001 1.042 1.042 __init__.py:78(get_commands) 153 0.001 0.000 1.036 0.007 re.py:188(compile) 106/102 0.001 0.000 1.030 0.010 __init__.py:52(__getattr__) 1 0.000 0.000 1.029 1.029 __init__.py:31(_setup) 1 0.000 0.000 1.021 1.021 __init__.py:57(_configure_logging) 2 0.002 0.001 1.011 0.505 log.py:1(&lt;module&gt;)</p><p>151940个函数调用(147672个基元调用)，按以下顺序排序：累计时间n调用总时间每次调用累计时间每次调用文件名：lineno(函数)1 0.000 0.000 1.696 1.696配置文件：0(&lt；代码对象&lt；模块&gt；位于0x1053d6a30，文件&#34；./Manage.py&#34；，行2&gt；)1 0.001 0.001 1.693 1.693 manage.py：2(&lt；模块&gt；)1 0.000 0.000 1.586 1.586__init__.py：394(EXECUTE_FROM_COMMAND_LINE)1 0.000 0.000 1.586 1.586__INIT__.py：350(执行)1 0.000 0.000 1.142 1.142__INIT__.py：254(获取命令)430.013 0.000 1.124 0.026__INIT__.py：1(&lt；模块&&gt;；)0.008 0.000 0.000 1.062 0.003 re.py：226(_COMPILE)158 0.005 0.000 1.048 0.007 SRE_COMPILLE.py：496(编译)1 0.001 0.001 1.0421.042__init__.py：78(Get_Commands)1530.001 0.000 1.0360.007re.py：188(编译)106/1020.000.000 1.0300.010_init_.py：52(_。_getattr__)1 0.000 0.000 1.029 1.029__init__.py：31(_Setup)1 0.000 0.000 1.021 1.021__init__.py：57(_CONFIGURE_LOGGING)2 0.002 0.001 1.011 0.505log.py：1(&lt；模块&gt；)。</p><p>  Pyinstrument records the entire stack, so tracking expensive calls is mucheasier. It also hides library frames by default, letting you focus on yourapp/module is affecting performance.</p><p>PyInstrument记录整个堆栈，因此跟踪昂贵的呼叫要方便得多。默认情况下，它还隐藏库框架，让您专注于影响性能的应用程序/模块。</p><p> _ ._ __/__ _ _ _ _ _/_ Recorded: 14:53:35 Samples: 131 /_//_/// /_\ / //_// / //_&#39;/ // Duration: 3.131 CPU time: 0.195/ _/ v3.0.0b3Program: examples/django_example/manage.py runserver --nothreading --noreload3.131 &lt;module&gt; manage.py:2└─ 3.118 execute_from_command_line django/core/management/__init__.py:378 [473 frames hidden] django, socketserver, selectors, wsgi... 2.836 select selectors.py:365 0.126 _get_response django/core/handlers/base.py:96 └─ 0.126 hello_world django_example/views.py:4</p><p>_._/_/记录：14：53：35样本：13/_//_/\/_/&#39；/持续时间：3.131 CPU时间：0.195/_/v3.0.0b3程序：示例/django_example/manage.py runserver--无线程--noreload3.131&lt；模块&gt；Py：2└─3.118 EXECUTE_FROM_COMMAND_LINE Django/CORE/MANAGEMENT/__INIT__.py：378[473帧隐藏]Django，socketserver，选择器，wsgi...。2.836选择选择器.py：365 0.126_GET_RESPONSE Django/CORE/Handler/base.py：96└─0.126 HELLO_WORLD Django_Example/Views.py：4。</p><p>  Pyinstrument records duration using &#39;wall-clock&#39; time. When you&#39;re writing aprogram that downloads data, reads files, and talks to databases, all thattime is  included in the tracked time by pyinstrument.</p><p>PyInstrument使用挂钟时间记录持续时间。当您正在编写下载数据、读取文件和与数据库对话的程序时，所有这些时间都包含在pyInstrument跟踪的时间中。</p><p> That&#39;s really important when debugging performance problems, since Python isoften used as a &#39;glue&#39; language between other services. The problem might notbe in your program, but you should still be able to find why it&#39;s slow.</p><p>这在调试性能问题时非常重要，因为Python经常被用作其他服务之间的粘合剂语言。问题可能不在您的程序中，但您应该仍然能够找到程序运行缓慢的原因。</p><p>  Pyinstrument interrupts the program every 1ms and records the entire stack atthat point. It does this using a C extension and  PyEval_SetProfile, but onlytaking readings every 1ms. Check out  this blog post for more info.</p><p>PyInstrument每1ms中断一次程序，并在该点记录整个堆栈。它使用C扩展和PyEval_SetProfile来实现这一点，但是每1ms只读取一次读数。有关更多信息，请查看此博客帖子。</p><p> You might be surprised at how few samples make up a report, but don&#39;t worry,it won&#39;t decrease accuracy. The default interval of 1ms is a lower bound forrecording a stackframe, but if there is a long time spent in a single functioncall, it will be recorded at the end of that call. So effectively thosesamples were &#39;bunched up&#39; and recorded at the end.</p><p>你可能会对组成一份报告的样本如此之少感到惊讶，但别担心，这不会降低准确性。默认间隔1ms是记录堆栈帧的下限，但如果在单个函数调用中花费的时间较长，则会在该调用结束时记录。因此，这些样本实际上被捆绑在一起，并在最后录制下来。</p><p>   Added the ability to track time in C functions. Minor note - Pyinstrumentwill record time spent C functions as &#39;leaf&#39; functions, due to a limitationin how Python records frames.  Python -&gt; C -&gt; Python is recorded as Python -&gt; Python, but  Python -&gt; Python -&gt; C will be attributed correctly.(#103)</p><p>添加了在C函数中跟踪时间的功能。次要注意-由于Python记录帧的方式有限制，PyInstrument将C函数记录为叶子函数所花费的时间。Python-&gt；C-&gt；Python记录为Python-&gt；Python，但Python-&gt；Python-&gt；C的属性将正确。(#103)。</p><p>      Added PYINSTRUMENT_SHOW_CALLBACK option on the Django middleware toadd a condition to showing the profile (could be used to run pyinstrumenton a live server!)</p><p>在Django中间件上添加了PYINSTRUMENT_SHOW_CALLBACK选项，以添加显示配置文件的条件(可用于在实时服务器上运行pyInstrument！)。</p><p> Fixed bug in the Django middleware where file would not be written becauseof a unicode error</p><p>修复了Django中间件中由于Unicode错误而无法写入文件的错误。</p><p>  Fixed bug with the Django middleware on Windows where profiling would failbecause we were trying to put an illegal character &#39;?&#39; in the profile path.(#66)</p><p>修复了Windows上Django中间件的错误，在该错误中，由于我们试图在配置文件路径中放置非法字符&#39；？&#39；，所以配置文件将失败。(#66)。</p><p>  Add  --show and  --show-regex options, to mark certain files to bedisplayed. This helps to profile inside specific modules, while hidingothers. For example,  pyinstrument --show &#39;*/sympy/*&#39; script.py.</p><p>添加--show和--show-regex选项，以标记要显示的某些文件。这有助于分析特定模块内部的情况，而不是隐藏。例如，pyInstrument--show&#39；*/symmy/*&39；script.py。</p><p>    Pyinstrument will now hide traces through libraries that you&#39;re using by default. So instead of showing you loads of frames going through the internals of something external e.g. urllib, it lets you focus on your code.</p><p>PyInstrument现在将通过您默认使用的库隐藏跟踪。因此，它不会向您展示通过外部内容(如urllib)内部的大量框架，而是让您专注于您的代码。</p><p> &#39;Entry&#39; frames of hidden groups are shown, so you know which call is the problem</p><p>&#39；条目&#39；会显示隐藏组的框架，这样您就可以知道问题出在哪个呼叫上。</p><p> Really slow frames in the groups are shown too, e.g. the &#39;read&#39; call on the socket</p><p>组中非常慢的帧也会显示出来，例如套接字上的Read调用。</p><p>  Additional metrics are shown at the top of the trace - timestamp, number of samples, duration, CPU time</p><p>其他指标显示在跟踪顶部-时间戳、样本数、持续时间、CPU时间。</p><p> Hidden code is controlled by the  --hide or  --hide-regex options - matching on the path of the code files.</p><p>隐藏代码由代码文件路径上的--HIDE或--HIDE-regex选项控制。</p><p> --hide=EXPR glob-style pattern matching the file paths whose frames to hide. Defaults to &#39;*/lib/*&#39;. --hide-regex=REGEX regex matching the file paths whose frames to hide. Useful if --hide doesn&#39;t give enough control.</p><p>--HIDE=expr glob样式模式，匹配要隐藏其帧的文件路径。默认为&#39；*/lib/*&#39；。--Hide-regex=与要隐藏其帧的文件路径匹配的REGEX regex。如果--HIDE没有给予足够的控制，那就有用了。</p><p>  Because there are a few rendering options now, you can load a previous profiling session using  --load-prev - pyinstrument keeps the last 10 sessions.</p><p>因为现在有几个呈现选项，所以您可以使用--load-prev-pyInstrument加载前一个性能分析会话来保存最后10个会话。</p><p>  (internal) When recording timelines, frame trees are completely linear now, allowingfor the creation of super-accurate frame charts.</p><p>(内部)当记录时间线时，框架树现在完全是线性的，允许创建超精确的框架图。</p><p> (internal) The HTML renderer has been rewritten as a Vue.js app. All the console improvements apply to the HTML output too, plus it&#39;s interactive.</p><p>(内部)HTML渲染器已被重写为Vue.js应用程序。所有控制台的改进也适用于HTML输出，另外它还具有交互性。</p><p>   Big refactor! Recorders have been removed. The frame recording is now internal to the  Profiler object.This means the &#39;frame&#39; objects are more general-purpose, which paves the way for...</p><p>大重构！录音机已被移除。帧录制现在是Profiler对象的内部。这意味着帧对象更加通用，这为……铺平了道路。</p><p> Processors! These are functions that mutate the tree to sculpt the output.They are used by the renderers to filter the output to the correct form. Now, instead ofa time-aggregating recorder, the profiler just uses timeline-style recording (this islower-overhead anyway) and the aggregation is done as a processing step.</p><p>处理器！这些是改变树以雕刻输出的函数，渲染器使用它们将输出过滤成正确的形式。现在，分析器不是时间聚合记录器，而是只使用时间线样式的记录(这无论如何开销更低)，并且聚合是作为一个处理步骤来完成的。</p><p> The upshot of this is that it&#39;s now way easier to alter the tree to filter stuff out, anddo more advanced things like combining frames that we don&#39;t care about. More features tocome that use this in v3.0!</p><p>这样做的结果是，现在可以更容易地更改树来过滤掉东西，并做一些更高级的事情，比如组合我们不关心的框架。在v3.0中还会有更多使用此功能的功能！</p><p> Importlib frames are removed - you won&#39;t see them at all. Their children are retained, soimports are just transparent.</p><p>Importlib框架被移除-您将根本看不到它们。他们的孩子被保留下来，所以进口只是透明的。</p><p>    When running  pyinstrument --html and you don&#39;t pipe the output to a file, pyinstrument will write the console output to a temp file and open that in a browser.</p><p>当运行pyInstrument--html并且您没有将输出通过管道传输到文件时，pyInstrument会将控制台输出写入一个临时文件，然后在浏览器中打开该文件。</p><p>  Added support for running modules with pyinstrument via the command line. The new syntaxis the  -m flag e.g.  pyinstrument -m module_name!  PR</p><p>添加了对通过命令行使用pyInstrument运行模块的支持。新的语法是-m标志，例如pyInstrument-m模块名称！普瑞。</p><p>  Fix crashes due to multi-threaded use of pyinstrument. The fix is in the C extension,over at  https://github.com/joerick/pyinstrument_cext/pull/3</p><p>修复由于多线程使用pyInstrument而导致的崩溃。修复程序位于C扩展中，位于https://github.com/joerick/pyinstrument_cext/pull/3</p><p>    Fix for max recursion error when used to profile programs with a lot of frames on the stack.</p><p>修复了用于分析堆栈上有大量帧的程序时的最大递归错误。</p><p>    Pyinstrument uses a new profiling mode. Rather than usingsignals, pyintrument uses a new statistical profiler built onPyEval_SetProfile. This means no more main thread restriction, no moreIO errors when using Pyinstrument, and no need for a separate more&#39;setprofile&#39; mode!</p><p>PyInstrument使用一种新的剖析模式。Pyinterument不使用信号，而是使用基于PyEval_SetProfile的新统计分析器。这意味着在使用PyInstrument时不再有主线程限制，不再有IO错误，也不需要单独的More&#39；setprofile&#39；模式！</p><p> Renderers. Users can customize Pyinstrument to use alternative rendererswith the  renderer argument on  Profiler.output(), or using the  --rendererargument on the command line.</p><p>渲染器。用户可以通过Profiler.output()上的renender参数或命令行上的--renderer参数自定义PyInstrument以使用替代渲染器。</p><p> Recorders. To support other use cases of Pyinstrument (e.g. flame charts),pyinstrument now has a &#39;timeline&#39; recorder mode. This mode records capturedframes in a linear way, so the program execution can be viewed on atimeline.</p><p>录音机。为了支持PyInstrument的其他使用案例(例如火焰图表)，PyInstrument现在有一个时间线记录器模式。此模式以线性方式记录捕获的帧，因此可以在atimeline上查看程序执行情况。</p><p>  pyinstrument command. You can now profile python scripts from the shellby running  $ pyinstrument script.py. This is now equivalent to python -m pyinstrument. Thanks @asmeurer!</p><p>PyInstrument命令。现在可以通过运行$pyInstrument script.py从Shell分析python脚本。这现在等同于python-m pyInstrument。谢谢@asmeurer！</p><p>  Added  PYINSTRUMENT_PROFILE_DIR option to the Django interface, whichwill log profiles of all requests to a file the specified folder. Usefulfor profiling API calls.</p><p>向Django界面添加了PYINSTRUMENT_PROFILE_DIR选项，该选项会将所有请求的配置文件记录到指定文件夹中的文件。用于分析API调用。</p><p>  To run pyinstrument from the git repo or a source checkout, you must first run</p><p>要从git存储库或源代码签出运行pyInstrument，必须先运行。</p><p>  This compiles the Javascript code needed for the HTML output. You will need node installed (Node isn&#39;t required for the pipinstall as the Javascript is already pre-built in the wheel).</p><p>这将编译HTML输出所需的Javascript代码。您将需要安装节点(管道安装不需要节点，因为控制盘中已经预置了Javascript)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/joerick/pyinstrument">https://github.com/joerick/pyinstrument</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/统计/">#统计</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030062.html"><img src="http://img2.diglog.com/img/2020/10/thumb_febd33768c5e817e34a81b0bd750e291.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030062.html">CPython提速实施方案</a></div><span class="my_story_list_date">2020-10-20 22:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030052.html"><img src="http://img2.diglog.com/img/2020/10/thumb_8e77f040d37fd76761e6b57f203fb02c.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030052.html">Python中的模式匹配</a></div><span class="my_story_list_date">2020-10-20 22:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029860.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ef60e0e0abc843c004ccaf10b95ea086.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029860.html">为Ruby、Python、Elixir、Go等提供更好的Git diff输出</a></div><span class="my_story_list_date">2020-10-20 1:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029821.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7f70d9555707141de03eda7009b9ad08.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029821.html">剧情片巨蟒奖</a></div><span class="my_story_list_date">2020-10-19 23:21</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>