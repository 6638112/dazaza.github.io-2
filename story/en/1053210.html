<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>推断这一点 Deducing This</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Deducing This<br/>推断这一点 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 17:50:53</div><div class="page_narrow text-break page_content"><p>We propose a new mechanism for specifying or deducing the value category of the expression that a member-function is invoked on. In other words, a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the expression’s type.</p><p>我们提出了一种新机制，用于指定或致电成员函数被调用的表达式的值类别。换句话说，从成员内函数函数的方式函数是否载于它的表达式是偏僻的或rvalue;无论是常数还是挥发性;和表达式的类型。</p><p>   Re-added section with the history of other syntaxes we considered (for posterity) and a discussion of reflection, explicit   static,   virtual, and coroutines. Rebased wording after Davis’ paper. Re-worded so that explicit object member functions are  non-static member functions rather than static member functions.</p><p>   重新添加的部分与我们考虑的其他语法的历史（用于后面）以及对反射，显式静态，虚拟和金属版的讨论。在戴维斯纸上重新撰写的措辞。重新触及以便显式对象成员函数是非静态成员函数而不是静态成员函数。</p><p>    The feedback from Belfast in EWG was “This looks good, come back with wording and implementation”. This version adds wording, the implementation is in the works.</p><p>    贝尔法斯特在ewg的反馈是“这看起来不错，回到措辞和实施”。此版本添加措辞，实现在于作品中。</p><p>    An FAQ entry for  computed deduction, an orthogonal feature that EWGI asked for in Kona.</p><p>    计算扣除的常见问题解答条目，EWGI在科纳要求的正交功能。</p><p>  [ P0847R1] was presented in San Diego in November 2018 with a wide array of syntaxes and name lookup options. Discussion there revealed some potential issues with regards to lambdas that needed to be ironed out. This revision zeroes in on one specific syntax and name lookup semantic which solves all the use-cases.</p><p>  [P0847R1]于2018年11月在San Diego提供了各种语法和名称查找选项。讨论揭示了对Lambdas的一些潜在问题，需要熨烫。此修订Zeroes在一个特定语法和名称查找语义上，解决了所有使用情况。</p><p>  [ P0847R0] was presented in Rapperswil in June 2018 using a syntax adjusted from the one used in that paper, using   this Self &amp;&amp; self to indicate the explicit object parameter rather than the  Self &amp;&amp;  this self that appeared in r0 of our paper.</p><p>  [P0847R0]在2018年6月在rapperswil中介绍了使用该自我和amp中使用的那篇文章中使用的语法。自我表明显式对象参数而不是自我和amp;＆amp;这种出现在纸张R0中的自我。</p><p>  a different syntax, placing the object parameter’s type after the member function’s parameter declarations (where the  cv-ref qualifiers are today)</p><p>  不同的语法，将对象参数的类型的类型放置在成员函数的参数声明（CV-Ref Pretifiers今天）之后 </p><p> a different name lookup scheme, which could prevent implicit/unqualified access from within new-style member functions that have an explicit self-type annotation, regardless of syntax.</p><p>不同的名称查找方案，可以防止来自具有显式自型注释的新型成员函数中的隐式/不合格访问，无论语法如何。</p><p> This revision carefully explores both of these directions, presents different syntaxes and lookup schemes, and discusses in depth multiple use cases and how each syntax can or cannot address them.</p><p> 此修订仔细探讨了这两个方向，呈现了不同的语法和查找方案，并在深度多用例中讨论以及每个语法如何或无法解决它们。</p><p>  In C++03, member functions could have  cv-qualifications, so it was possible to have scenarios where a particular class would want both a   const and non-  const overload of a particular member. (Note that it was also possible to want   volatile overloads, but those are less common and thus are not examined here.) In these cases, both overloads do the same thing — the only difference is in the types being accessed and used. This was handled by either duplicating the function while adjusting types and qualifications as necessary, or having one overload delegate to the other. An example of the latter can be found in Scott Meyers’s “Effective C++”  [ EffCpp], Item 3:</p><p>  在C ++ 03中，成员函数可以具有CV-restification，因此可以具有特定类想要特定成员的Const和非Const重载的场景。 （请注意，也可以希望易失性过载，但是那些不太常见，因此在此处没有检查。）在这些情况下，两个过载都执行相同的事情 - 唯一的区别在于被访问和使用的类型。这是通过重复函数来处理，同时根据需要调整类型和资格，或者将一个过载委托给另一个重载委托。后者的一个例子可以在Scott Meyers的“有效的C ++”[Effcpp]中找到，第3项：</p><p> class TextBlock  {   public :    char  const &amp;  operator []( size_t position )  const  {    // ...    return text [position ];    }      char &amp;  operator []( size_t position )  {    return  const_cast &lt; char &amp;&gt;(    static_cast &lt;TextBlock  const &amp;&gt;(* this )[position ]    );    }    // ...   };</p><p> Class TextBlock {Public：Char Const＆amp;操作员[]（size_t位置）const {// ...返回文本[位置]; } char＆amp;运算符[]（size_t位置）{return const_cast＆lt; char＆amp;＆gt;（static_cast＆lt; textblock const＆amp;（*这个）[位置]）; } // ......};</p><p>  In C++11, member functions acquired a new axis to specialize on: ref-qualifiers. Now, instead of potentially needing two overloads of a single member function, we might need four:   &amp;,   const &amp;,   &amp;&amp;, or   const &amp;&amp;. We have three approaches to deal with this:</p><p>  在C ++ 11中，成员函数获取了新轴来专门执行：Ref-Pretifiers。现在，而不是潜在地需要两个成员函数的过载，而不是四个：＆amp;，const＆amp;＆amp;或const＆amp;＆amp ;.我们有三种方法来处理这一点：</p><p> We have all four overloads delegate to a helper in the form of a private static member function.</p><p> 我们所有四个重载都以私有静态成员函数的形式委托给助手。</p><p>  template  &lt; typename T &gt;   class optional  {    // ...    constexpr T &amp; value ()  &amp;  {    if  (has_value ())  {    return  this -&gt;m_value;    }    throw bad_optional_access ();    }      constexpr T  const &amp; value ()  const &amp;  {    if  (has_value ())  {    return  this -&gt;m_value;    }    throw bad_optional_access ();    }      constexpr T &amp;&amp; value ()  &amp;&amp;  {    if  (has_value ())  {    return move ( this -&gt;m_value );    }    throw bad_optional_access ();    }      constexpr T  const &amp;&amp;   value ()  const &amp;&amp;  {    if  (has_value ())  {    return move ( this -&gt;m_value );    }    throw bad_optional_access ();    }    // ...   };</p><p>  模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t const＆amp;价值（）const＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {if（has_value（））{返回移动（这个 - ＆gt; m_value）; }掷bad_optional_access（）; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {if（has_value（））{返回移动（这个 - ＆gt; m_value）; }掷bad_optional_access（）; } // ......}; </p><p> template  &lt; typename T &gt;   class optional  {    // ...    constexpr T &amp; value ()  &amp;  {    return  const_cast &lt;T &amp;&gt;(    static_cast &lt;optional  const &amp;&gt;(    * this ).value ());    }      constexpr T  const &amp; value ()  const &amp;  {    if  (has_value ())  {    return  this -&gt;m_value;    }    throw bad_optional_access ();    }      constexpr T &amp;&amp; value ()  &amp;&amp;  {    return  const_cast &lt;T &amp;&amp;&gt;(    static_cast &lt;optional  const &amp;&gt;(    * this ).value ());    }      constexpr T  const &amp;&amp;   value ()  const &amp;&amp;  {    return  static_cast &lt;T  const &amp;&amp;&gt;(   value ());    }    // ...   };</p><p>模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {return const_cast＆lt; t＆gt;（static_cast＆lt; oleasting const＆amp;（*这个）.value（））; } constexpr t const＆amp;价值（）const＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {返回const_cast＆lt; t＆amp;＆amp;（static_cast＆lt;＆gt;＆gt;（*这个）.value（））; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {return static_cast＆lt; t const＆amp;＆gt;（value（））; } // ......};</p><p> template  &lt; typename T &gt;   class optional  {    // ...    constexpr T &amp; value ()  &amp;  {    return value_impl (* this );    }      constexpr T  const &amp; value ()  const &amp;  {    return value_impl (* this );    }      constexpr T &amp;&amp; value ()  &amp;&amp;  {    return value_impl (move (* this ));    }      constexpr T  const &amp;&amp;   value ()  const &amp;&amp;  {    return value_impl (move (* this ));    }     private :    template  &lt; typename Opt &gt;    static  decltype ( auto )   value_impl (Opt &amp;&amp; opt )  {    if  (!opt .has_value ())  {    throw bad_optional_access ();    }    return forward &lt;Opt &gt;(opt ).m_value;    }    // ...   };</p><p> 模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {return value_impl（*这）; } constexpr t const＆amp;价值（）const＆amp; {return value_impl（*这）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {return value_impl（移动（*此））; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {return value_impl（移动（*此））;私人：模板＆lt; typename opt＆gt;静态Declitype（Auto）value_impl（OPT＆amp;＆amp; opt）{if（！opt .has_value（））{opt bad_optional_access（）;返回前进＆lt;选择＆gt;（选择）.m_value; } // ......};</p><p> This is far from a complicated function, but essentially repeating the same code four times — or using artificial delegation to avoid doing so — begs a rewrite. Unfortunately, it’s impossible to improve; we  must implement it this way. It seems we should be able to abstract away the qualifiers as we can for non-member functions, where we simply don’t have this problem:</p><p> 这远非复杂的功能，但基本上重复相同的代码四次 - 或者使用人工代表团避免这样做 - 乞求重写。不幸的是，不可能改善;我们必须以这种方式实现它。似乎我们应该能够向非成员职能摘要摘要限定员，在那里我们根本没有这个问题：</p><p> template  &lt; typename T &gt;   class optional  {    // ...    template  &lt; typename Opt &gt;    friend  decltype ( auto ) value (Opt &amp;&amp; o )  {    if  (o .has_value ())  {    return forward &lt;Opt &gt;(o ).m_value;    }    throw bad_optional_access ();    }    // ...   };</p><p> 模板＆lt; typename t＆gt; class可选{// ...模板＆lt; typename opt＆gt;朋友Decltype（Auto）值（OPT＆amp; o）{if（o .has_value（））{返回前进＆lt; opt＆gt;（o）.m_value; }掷bad_optional_access（）; } // ......};</p><p> All four cases are now handled with just one function… except it’s a non-member function, not a member function. Different semantics, different syntax, doesn’t help.</p><p> 所有四个案例都以一个函数处理......除了它是非成员函数，而不是成员函数。不同的语义，语法不同，没有帮助。</p><p> There are many cases where we need two or four overloads of the same member function for different   const- or ref-qualifiers. More than that, there are likely additional cases where a class should have four overloads of a particular member function but, due to developer laziness, doesn’t. We think that there are enough such cases to merit a better solution than simply “write it, write it again, then write it two more times.”</p><p> 我们需要许多情况下我们需要两个或四个相同的成员函数的过载，用于不同的const  - 或ref-pretifiers。不仅如此，可能有额外的情况，其中一个类应该有四个特定成员函数的过载，但由于开发人员懒惰，没有。我们认为有足够的这种情况来优于更好的解决方案，而不是简单地“写它，再次写作，然后再写两次。”</p><p>  We propose a new way of declaring non-static member functions that will allow for deducing the type and value category of the class instance parameter while still being invocable with regular member function syntax. This is a strict extension to the language.</p><p>  我们提出了一种新的方式来声明非静态成员函数，该函数将允许在仍然具有常规成员函数语法中仍可接受的同时进行类实例参数的类型和值类别。这是对语言的严格扩展。 </p><p> We believe that the ability to write  cv-ref qualifier-aware member function templates without duplication will improve code maintainability, decrease the likelihood of bugs, and make fast, correct code easier to write.</p><p>我们认为，在没有重复的情况下写入CV-REF限定符感知的成员函数模板的能力将提高代码可维护性，降低错误的可能性，并快速制作，更正的代码更易于写入。</p><p> The proposal is sufficiently general and orthogonal to allow for several new exciting features and design patterns for C++:</p><p> 该提案足够一般，正交，以允许用于C ++的几个新令人兴奋的功能和设计模式：</p><p>   This proposal assumes the existence of two library additions, though it does not propose them:</p><p>   该提案假定存在两个图书馆的添加，但它不提出它们：</p><p> like_t, a metafunction that applies the  cv- and  ref-qualifiers of the first type onto the second (e.g.  like_t &lt; int &amp;,  double &gt; is   double &amp;,  like_t &lt;X  const &amp;&amp;, Y &gt; is  Y  const &amp;&amp;, etc.)</p><p> like_t，将第一类型的cv和ref-letifiers应用到第二个（例如lick_t＆lt; int＆amp;，double＆gt;是双倍＆amp;，＆lt; x const＆amp;＆amp;，x const＆＆amp;是y const＆amp;＆amp;等）</p><p> forward_like, a version of  forward that is intended to forward a variable not based on its own type but instead based on some other type.  forward_like &lt;T &gt;(u ) is short-hand for  forward &lt;like_t &lt;T, decltype (u )&gt;&gt;(u ).</p><p> forward_like，forward的版本旨在转发不基于其自己的类型的变量，而是基于其他类型的类型。 Forward_like＆lt; t＆gt;（u）是前进的短手＆lt; late_t＆lt; d，decltype（u）＆gt;＆gt;（u）。</p><p>   A non-static member function can be declared to take as its first parameter an  explicit object parameter, denoted with the prefixed keyword   this. Once we elevate the object parameter to a proper function parameter, it can be deduced following normal function template deduction rules:</p><p>   可以声明非静态成员函数作为其第一个参数进行一个显式对象参数，用前缀关键字表示。一旦我们将对象参数提升到适当的功能参数，就可以在正常函数模板扣除规则下推导出来：</p><p> struct X  {    void foo ( this X  const &amp; self,  int i );      template  &lt; typename Self &gt;    void bar ( this Self &amp;&amp; self );   };     struct D  : X  {  };     void ex (X &amp; x, D  const &amp; d )  {   x .foo ( 42 );  // &#39;self&#39; is bound to &#39;x&#39;, &#39;i&#39; is 42   x .bar ();  // deduces Self as X&amp;, calls X::bar&lt;X&amp;&gt;   move (x ).bar ();  // deduces Self as X, calls X::bar&lt;X&gt;     d .foo ( 17 );  // &#39;self&#39; is bound to &#39;d&#39;   d .bar ();  // deduces Self as D const&amp;, calls X::bar&lt;D const&amp;&gt;   }</p><p> struct x {void foo（这个x const＆amp; self，int i）;模板＆lt;类型自我和gt; void bar（这个自我和amp; self）; }; struct d：x {}; void ex（x＆amp; x，d const＆amp; d）{x .foo（42）; //＃39;自我＆＃39;符合＆＃39; x＆＃39 ;,＆＃39; i＆＃39;是42 x .bar（）; //将Self授予x＆amp;，呼叫x :: bar＆lt; x＆gt;＆gt;移动（x）.bar（）; //将Self授予X，呼叫X :: Bar＆lt; x＆gt; d .foo（17）; //＃39;自我＆＃39;必将＆＃39; d＆＃39; d .bar（）; //将Self as d const＆amp;，呼叫x :: bar＆lt; d const＆amp;＆gt; } </p><p> Member functions with an explicit object parameter cannot be   static or   virtual and they cannot have  cv- or  ref-qualifiers. We will discuss the restriction on   static and   virtual in followup sections.</p><p>具有显式对象参数的成员函数不能是静态的或虚拟的，并且它们不能具有CV-或REF  - 限定符。我们将讨论跟踪部分中的静态和虚拟的限制。</p><p> A call to a member function will interpret the object argument as the first (  this-annotated) parameter to it; the first argument in the parenthesized expression list is then interpreted as the second parameter, and so forth.</p><p> 对成员函数的调用将将对象参数解释为它的第一个（本 - 注释）参数;然后将括号表达式列表中的第一个参数解释为第二个参数等。</p><p> Following normal deduction rules, the template parameter corresponding to the explicit object parameter can deduce to a type derived from the class in which the member function is declared, as in the example above for  d .bar ()).</p><p> 在正常扣除规则之后，对应于显式对象参数的模板参数可以推导到从声明成员函数被声明的类的类型，如上面的d .bar（））。</p><p> We can use this syntax to implement  optional ::value () and  optional :: operator -&gt;() in just two functions instead of the current six:</p><p> 我们可以使用此语法来实现可选的:: value（）和可选::运算符 - ＆gt;（）只有两个函数而不是当前六：</p><p> template  &lt; typename T &gt;   struct optional  {    template  &lt; typename Self &gt;    constexpr  auto &amp;&amp; value ( this Self &amp;&amp; self )  {    if  (!self .has_value ())  {    throw bad_optional_access ();    }      return forward &lt;Self &gt;(self ).m_value;    }      template  &lt; typename Self &gt;    constexpr  auto  operator -&gt;( this Self &amp;&amp; self )  {    return addressof (self .m_value );    }   };</p><p> 模板＆lt; typename t＆gt;结构可选{模板＆lt;类型自我和gt; Constexpr Auto＆amp;＆amp;价值（这个自我和amp;＆amp; self）{if（！self .has_value（））{oppl bad_optional_access（）;返回前进＆lt; self＆gt;（self）.m_value;模板＆lt;类型自我和gt; Constexpr自动运营商 - ＆gt;（这个自我和amp; self）{返回地址（self .m_value）; }};</p><p> This syntax can be used in lambdas as well, with the   this-annotated parameter exposing a way to refer to the lambda itself in its body:</p><p> 此语法也可以在Lambdas中使用，并且此注释参数揭示了在其身体中引用Lambda本身的方式：</p><p> vector captured  =  { 1,  2,  3,  4 };   [captured ]( this  auto &amp;&amp; self )  -&gt;  decltype ( auto )  {    return forward_like &lt; decltype (self )&gt;(captured );   }     [captured ]&lt; class Self &gt;( this Self &amp;&amp; self )  -&gt;  decltype ( auto )  {    return forward_like &lt;Self &gt;(captured );   }</p><p> 矢量捕获= {1,2,3,4}; [捕获]（此汽车＆amp;自我） - ＆gt; Decltype（Auto）{返回转发_like＆lt; DECLTYPE（自我）＆gt;（抓获）; [捕获]＆lt;阶级自我＆gt;（这个自我和amp;自我） - ＆gt; Decltype（Auto）{返回转发＆lt; self＆gt;（捕获）; } </p><p> The lambdas can either move or copy from the capture, depending on whether the lambda is an lvalue or an rvalue.</p><p>Lambdas可以从捕获中移动或复制，具体取决于Lambda是否是偏航或rvalue。</p><p>  What follows is a description of how deducing   this affects all important language constructs — name lookup, type deduction, overload resolution, and so forth.</p><p>  以下是描述如何挖掘这一切影响所有重要语言构造 - 名称查找，键入扣除，过载解决方案等。</p><p>  In C++17, name lookup includes both static and non-static member functions found by regular class lookup when invoking a named function or an operator, including the call operator, on an object of class type. Non-static member functions are treated as if there were an implicit object parameter whose type is an lvalue or rvalue reference to  cv  X (where the reference and  cv qualifiers are determined based on the function’s own qualifiers) which binds to the object on which the function was invoked.</p><p>  在C ++ 17中，名称查找包括在调用名称函数或呼叫运算符，在类类型的对象上时，常规类查找中发现的静态和非静态成员函数。非静态成员函数被视为有一个隐式对象参数，其类型是LVALUE或RVALUE参考对CV x（其中参考和CV限定符是基于函数自己的限定符确定的，它绑定到其上的对象函数被调用。</p><p> For non-static member functions using an explicit object parameter, lookup will work the same way as other member functions in C++17, with one exception: rather than implicitly determining the type of the object parameter based on the  cv- and  ref-qualifiers of the member function, these are now explicitly determined by the provided type of the explicit object parameter. The following examples illustrate this concept.</p><p> 对于使用显式对象参数的非静态成员函数，查找将与C ++ 17中的其他成员函数相同的方式，其中一个例外：而不是基于CV和Ref隐含地确定对象参数的类型成员函数的限定符，现在通过提供的显式对象参数的类型明确确定。以下示例说明了这一概念。</p><p> struct X  {    // implicit object has type X&amp;    void foo ()  &amp;;      // implicit object has type X const&amp;    void foo ()  const &amp;;      // implicit object has type X&amp;&amp;    void bar ()  &amp;&amp;;   };</p><p> struct x {//隐式对象具有类型x＆amp; Void foo（）＆amp ;; //隐式对象具有类型x const＆amp; Void foo（）const＆amp ;; //隐式对象具有类型x＆amp;＆amp; Void Bar（）＆amp;＆amp ;; };</p><p> struct X  {    // explicit object has type X&amp;    void foo ( this X &amp;);      // explicit object has type X const&amp;    void foo ( this X  const &amp;);      // explicit object has type X&amp;&amp;    void bar ( this X &amp;&amp;);   };</p><p> struct x {// explicit对象具有类型x＆amp; void foo（这个x＆amp;）; //显式对象具有X Const＆amp; void foo（这个x const＆amp;）; //显式对象有类型x＆amp;＆amp;禁止栏（此x＆amp;）; };</p><p> Name lookup on an expression like  obj .foo () in C++17 would find both overloads of  foo in the first column, with the non-const overload discarded should  obj be const.</p><p> 在C ++ 17中的表达式上的表达式上的名称查找将在第一列中找到FOO的两个过载，因此丢弃的非Const过载应该是Const。 </p><p> With the proposed syntax,  obj .foo () would continue to find both overloads of  foo, with identical behaviour to C++17.</p><p>使用所提出的语法，obj .foo（）将继续找到foo的过载，具有相同的行为到C ++ 17。</p><p> The only change in how we look up candidate functions is in the case of an explicit object parameter, where the argument list is shifted by one. The first listed parameter is bound to the object argument, and the second listed parameter corresponds to the first argument of the call expression.</p><p> 我们查找候选函数的唯一变更是在一个显式对象参数的情况下，参数列表由一个转移。第一个列出的参数绑定到对象参数，第二个列出的参数对应于调用表达式的第一个参数。</p><p> This paper does not propose any changes to overload  resolution but merely suggests extending the candidate set to include non-static member functions and member function templates written in a new syntax. Therefore, given a call to  x .foo (), overload resolution would still select the first  foo () overload if  x is not   const and the second if it is.</p><p> 本文并未提出过载解决方案的任何更改，但仅建议将候选集扩展为包括以新语法编写的非静态成员函数和成员函数模板。因此，鉴于呼叫x .foo（），如果x不是const，如果x不是const，则过载解析仍将选择第一个foo（）过载。</p><p>  The only change as far as candidates are concerned is that the proposal allows for deduction of the object parameter, which is new for the language.</p><p>  唯一候选人的唯一变革涉及，该提案允许扣除对象参数，这是语言的新功能。</p><p> Since in some cases there are multiple ways to declare the same function, it would be ill-formed to declare two functions with the same parameters and the same qualifiers for the object parameter. This is:</p><p> 由于在某些情况下有多种方式来声明相同的函数，因此它将不成本，以声明具有相同参数的两个函数和对象参数相同的限定符。这是：</p><p> struct X  {    void bar ()  &amp;&amp;;    void bar ( this X &amp;&amp;);  // error: same this parameter type       static  void f ();    void f ( this X  const &amp;);  // error: two functions taking no parameters   };</p><p> struct x {void bar（）＆amp ;;禁止栏（此x＆amp;）; //错误：相同的此参数类型静态void f（）; void f（这个x const＆amp;）; //错误：两个函数没有参数};</p><p>     One of the main motivations of this proposal is to deduce the  cv-qualifiers and value category of the class object, which requires that the explicit member object or type be deducible from the object on which the member function is invoked.</p><p>     此提议的主要动机之一是推断为类对象的CV  - 限定符和价值类别，这要求从调用成员函数的对象中缝合显式成员对象或类型。 </p><p> If the type of the object parameter is a template parameter, all of the usual template deduction rules apply as expected:</p><p>如果对象参数的类型是模板参数，则所有通常的模板扣除规则都适用于预期：</p><p> struct X  {    template  &lt; typename Self &gt;    void foo ( this Self &amp;&amp;,  int );   };     struct D  : X  {  };     void ex (X &amp; x, D &amp; d )  {   x .foo ( 1 );  // Self=X&amp;   move (x ).foo ( 2 );  // Self=X   d .foo ( 3 );  // Self=D&amp;   }</p><p> 结构x {模板＆lt;类型自我和gt;空白foo（这个自我和amp;＆amp;，int）; }; struct d：x {}; void ex（x＆amp; x，d＆amp; d）{x .foo（1）; // self = x＆amp;移动（x）.foo（2）; // self = x d .foo（3）; // self = d＆amp; }</p><p> It’s important to stress that deduction is able to deduce a derived type, which is extremely powerful. In the last line, regardless of syntax,  Self deduces as  D &amp;. This has implications for  name lookup within member functions, and leads to a potential  template argument deduction extension.</p><p> 重要的是要强调扣除能够推断出一种极其强大的衍生类型。在最后一行中，无论语法如何，都将作为D＆amp;这对成员函数中的名称查找有影响，并导致潜在的模板参数推导扩展。</p><p>  But what if the explicit type does not have reference type? What should this mean?</p><p>  但如果显式类型没有参考类型，该怎么办？这应该是什么意思？</p><p> struct less_than  {    template  &lt; typename T,  typename U &gt;    bool  operator ()( this less_than, T  const &amp; lhs, U  const &amp; rhs )  {    return lhs  &lt; rhs;    }   };    less_than {}( 4,  5 );</p><p> struct less_than {模板＆lt; typename t，typename u＆gt; BOOL运算符（）（此LIST_THAN，T CONST＆amp; LHS，U CONTER＆amp; RHS）{返回LHS＆lt; RHS; }}; less_than {}（4,5）;</p><p> Clearly, the parameter specification should not lie, and the first parameter ( less_than {}) is passed by value.</p><p> 显然，参数规范不应划分，第一个参数（less_than {}）通过值传递。</p><p> Following the proposed rules for candidate lookup, the call operator here would be a candidate, with the object parameter binding to the (empty) object and the other two parameters binding to the arguments. Having a value parameter is nothing new in the language at all — it has a clear and obvious meaning, but we’ve never been able to take an object parameter by value before. For cases in which this might be desirable, see  by-value member functions.</p><p> 在候选查找的提议规则之后，呼叫运算符在这里是候选者，对象参数绑定到（空）对象和其他两个参数绑定到参数。具有一个值参数，所有语言都不是新的 - 它具有清晰明显的含义，但我们从未能够以前的价值拍摄对象参数。对于这可能是可取的，请参阅副价率成员函数。 </p><p>  So far, we’ve only considered how member functions with explicit object parameters are found with name lookup and how they deduce that parameter. Now we move on to how the bodies of these functions actually behave.</p><p>到目前为止，我们只考虑了使用名称查找以及它们如何推断该参数的成员函数如何找到具有显式对象参数的成员函数。现在我们继续如何如何表现出这些职能的机构。</p><p> Since the explicit object parameter is deduced from the object on which the function is called, this has the possible effect of deducing  derived types. We must carefully consider how name lookup works in this context.</p><p> 由于从调用函数的对象推断出显式对象参数，因此这具有挖掘派生类型的可能效果。我们必须仔细考虑在此上下文中如何查找名称。</p><p> struct B  {    int i  =  0;      template  &lt; typename Self &gt;  auto &amp;&amp; f1 ( this Self &amp;&amp;)  {  return i;  }    template  &lt; typename Self &gt;  auto &amp;&amp; f2 ( this Self &amp;&amp;)  {  return  this -&gt;i;  }    template  &lt; typename Self &gt;  auto &amp;&amp; f3 ( this Self &amp;&amp;)  {  return forward_like &lt;Self &gt;(* this ).i;  }    template  &lt; typename Self &gt;  auto &amp;&amp; f4 ( this Self &amp;&amp;)  {  return forward &lt;Self &gt;(* this ).i;  }    template  &lt; typename Self &gt;  auto &amp;&amp; f5 ( this Self &amp;&amp; self )  {  return forward &lt;Self &gt;(self ).i;  }   };     struct D  : B  {    // shadows B::i    double i  =  3.14;   };</p><p> struct b {int i = 0;模板＆lt;类型自我和gt;自动＆amp;＆amp; F1（这个自我和amp;）{返回我;模板＆lt;类型自我和gt;自动＆amp;＆amp; F2（这个自我和amp;＆amp;）{返回这个 - ＆gt;我;模板＆lt;类型自我和gt;自动＆amp;＆amp; F3（这个自我＆amp;＆amp;）{返回forward_like＆lt; self＆gt;（*这）.i;模板＆lt;类型自我和gt;自动＆amp;＆amp; F4（这个自我和amp;＆amp;）{返回前进＆lt; self＆gt;（*这）.i;模板＆lt;类型自我和gt;自动＆amp;＆amp; F5（这个自我和amp;＆amp; self）{返回前进＆lt; self＆gt;（self）.i; }}; struct d：b {//阴影b :::我加倍i = 3.14; };</p><p> The question is, what do each of these five functions do? Should any of them be ill-formed? What is the safest option?</p><p> 问题是，这五个职能中的每一个有什么作用？他们应该是不均成的吗？什么是最安全的选择？</p><p>  If there is an explicit object parameter,   this is inaccessible, and each access must be through  self. There is no implicit lookup of members through   this. This makes  f1 through  f4 ill-formed and only  f5 well-formed. However, while  B ().f5 () returns a reference to  B ::i,  D ().f5 () returns a reference to  D ::i, since  self is a reference to  D.</p><p>  如果有一个显式对象参数，则无法访问，每个访问必须通过自我。通过此内容没有隐性查找。这使得F1通过F4不良而且仅形成F5良好的F5。但是，虽然b（）.f5（）返回对b :: i的引用，而d（）.f5（）返回对d :: i的引用，因为自我是对D的引用。</p><p> If there is an explicit object parameter,   this is accessible and points to the base subobject. There is no implicit lookup of members; all access must be through   this or  self explicitly. This makes  f1 ill-formed.  f2 would be well-formed and always return a reference to  B ::i. Most importantly,   this would be  dependent if the explicit object parameter was deduced.   this -&gt;i is always going to be an   int but it could be either an   int or an   int  const depending on whether the  B object is const.  f3 would always be well-formed and would be the correct way to return a forwarding reference to  B ::i.  f4 would be well-formed when invoked on  B but ill-formed if invoked on  D because of the requested implicit downcast. As before,  f5 would be well-formed.</p><p> 如果有一个显式对象参数，可以访问它，并指向基本子object。成员没有隐性查询;所有访问必须通过此或自我明确。这使得F1形成不良。 F2将是良好的，始终回到B :: i的参考。最重要的是，如果推断出显式对象参数，这将是依赖的。这个 - ＆gt;我总是是一个int，但它可以是int或int const const，具体取决于b对象是const的。 F3将始终是良好的，并且是返回B :: i的转发参考的正确方法。如果由于所请求的隐式衰落，则在B上调用而单独的B但是不成集的F4将是良好的。如前所述，F5将是良好的。</p><p> this is always accessible and points to the base subobject; we allow implicit lookup as in C++17. This is mostly the same as the previous choice, except that now  f1 is well-formed and exactly equivalent to  f2.</p><p> 始终可以访问，并指向基本子object;我们允许隐式查找为C ++ 17。这与前一个选择相同，除了现在F1是良好的，并且与F2完全相同。 </p><p> Following discussion in San Diego, the option we are proposing is #1. This allows for the clearest model of what a   this-annotated function is: it is a   static member function that offers a more convenient function call syntax. There is no implicit   this in such functions, the only mention of   this would be the annotation on the object parameter. All member access must be done directly through the object parameter.</p><p>在San Diego讨论之后，我们提出的选项是＃1。这允许最清晰的模型是这种注释功能的：它是一个静态成员函数，提供更方便的功能调用语法。此类功能中没有隐含的这一点，唯一提到这将是对象参数的注释。必须通过对象参数直接完成所有成员访问。</p><p> The consequence of such a choice is that we will need to defend against the object parameter being deduced to a derived type. To ensure that  f5 () above is always returning a reference to  B ::i, we would need to write one of the following:</p><p> 这种选择的结果是我们需要防止被推导到派生类型的对象参数。要确保上面的F5（）始终返回对B :: I的引用，我们需要编写以下其中一个：</p><p> template  &lt; typename Self &gt;   auto &amp;&amp; f5 ( this Self &amp;&amp; self )  {    // explicitly cast self to the appropriately qualified B    // note that we have to cast self, not self.i    return  static_cast &lt;like_t &lt;Self, B &gt;&amp;&amp;&gt;(self ).i;      // use the explicit subobject syntax. Note that this is always    // an lvalue reference - not a forwarding reference    return self .B ::i;      // use the explicit subobject syntax to get a forwarding reference    return forward &lt;Self &gt;(self ).B ::i;   }</p><p> 模板＆lt;类型自我和gt;自动＆amp;＆amp; F5（这种自我和amp;＆amp; self）{//明确地向自我施加到适当的b //注意，我们必须投入自我，而不是自我.i返回static_cast＆lt; lime_t＆lt; self，b＆gt;＆amp;＆amp;＆ ;＆gt;（self）.i; //使用显式子object语法。请注意，这始终是//偏僻的参考 - 不是转发参考返回自我.b :: i; //使用显式子object语法获取转发参考返回前进返回＆lt; self＆gt;（self）.b :: i; }</p><p>  The worst case for this proposal is the case where we do  not intend on deducing a derived object - we only mean to deduce the qualifiers - but that derived type inherits from us privately and shadows one of our members:</p><p>  此提议的最坏情况是我们不打算致力于授予派生对象的情况 - 我们只意味着推断资格级别 - 但是从我们私下继承的派生类型是我们的成员之一 - </p><p> class B  {    int i;   public :    template  &lt; typename Self &gt;    auto &amp;&amp; get ( this Self &amp;&amp; self )  {    // see above: we need to mitigate against shadowing    return forward &lt;Self &gt;(self ).B ::i;    }   };     class D  :  private B  {    double i;   public :    using B ::get;   };    D ().get ();  // error</p><p> B级{int i;公共：模板＆lt;类型自我和gt;自动＆amp;＆amp;得到（这个Self＆amp;＆amp; self）{//查看了上面的：我们需要减轻阴影返回转发＆lt; self＆gt;（self）.b :: i; }}; D级：私人B {双我;公众：使用B :: GET; }; d（）.get（）; // 错误</p><p> In this example,  Self deduces as  D (not  B), but our choice of shadowing mitigation will not work - we can</p><p> 在这个例子中，自我推断为d（不是b），但我们选择的阴影缓解将不起作用 - 我们可以</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/推断/">#推断</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deducing/">#deducing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/参数/">#参数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>