<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>善良和糟糕的酏剂 Good and Bad Elixir</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Good and Bad Elixir<br/>善良和糟糕的酏剂 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-11 03:02:30</div><div class="page_narrow text-break page_content"><p>I’ve seen a lot of elixir at this point, both good and bad. Through all of that code, I’ve seen similar patterns that tend to lead to worse code. So I thought I would document some of them as well as better alternatives to these patterns.</p><p>我此时见过很多酏剂，两者都很好。通过所有代码，我已经看到类似的模式，往往会导致更糟糕的代码。所以我以为我会把其中一些文件和这些模式的更好的替代品。</p><p>  Map.get/2 and  Keyword.get/2 lock you into using a specific data structure. This means that if you want to change the type of structure, you now need to update all of the call sites. Instead of these functions, you should prefer using Access:</p><p>  map.get / 2和关键字.get / 2锁定您使用特定的数据结构。这意味着如果要更改结构类型，您现在需要更新所有呼叫站点。而不是这些函数，您应该更喜欢使用访问：</p><p>   Side-effecting functions tend to return “results” like  {:ok, term()} | {:error, term()}. If your dealing with side-effecting functions, don’t pipe the results into the next function. It’s always better to deal with the results directly using either  case or  with.</p><p>   侧面实现的功能倾向于返回“结果”，如{：OK，术语（）} | | {：错误，术语（）}。如果您处理副作用函数，请不要将结果送入下一个功能。使用任一情况或与之直接处理结果总是更好。</p><p> # Don&#39;t do... def  main  do  data  |&gt;  call_service  |&gt;  parse_response  |&gt;  handle_result end defp  call_service ( data )  do # ... end defp  parse_response ({ :ok ,  result },  do :  Jason . decode ( result ) defp  parse_response ( error ,  do :  error ) defp  handle_result ({ :ok ,  decoded }),  do :  decoded defp  handle_result ({ :error ,  error }),  do :  raise  error # Do... def  main  do  with  { :ok ,  response }  &lt;-  call_service ( data ),  { :ok ,  decoded }  &lt;-  parse_response ( response )  do  decoded  end end</p><p> ＃don＆＃39; t do ... def main do数据|＆gt; call_service |＆gt; parse_response |＆gt; handle_result结束defp call_service（data）do＃...结束defp parse_response（{：确定，结果}，do：jason。解码（结果）defp parse_response（错误，do：错误）defp handle_result（{：确定，解码}） ，做：解码defp handle_result（{：错误，错误}），do：提出错误＃do ... def main与{：确定，响应}＆lt;  -  call_service（data），{：确定，解码}＆lt; -  PARSE_RESPONSE（响应）进行解码结束结束</p><p> Using pipes forces our functions to handle the previous function’s results, spreading error handling throughout our various function calls. The core problem here is subtle, but it’s essential to internalize. Each of these functions has to know too much information about how it is being called. Good software design is mainly about building reusable bits that can be arbitrarily composed. In the pipeline example, the functions know how they’re used, how they’re called, and what order they’re composed.</p><p> 使用管道强制我们的功能来处理以前的函数的结果，在整个各种函数调用中传播错误处理。这里的核心问题是微妙的，但内化至关重要。这些功能中的每一个都必须了解有关如何调用的太多信息。良好的软件设计主要是关于构建可任意组成的可重用位。在管道示例中，该功能知道它们是如何使用的，它们是如何调用的，以及他们组成的顺序。</p><p> Another problem with the pipeline approach is that it tends to assume that errors can be handled generically. This assumption is often incorrect.</p><p> 管道方法的另一个问题是它倾向于假设可以易于处理错误。这个假设通常不正确。</p><p> When dealing with side-effects, the only function with enough information to decide what to do with an error is the calling function. In many systems, the error cases are just as important - if not more important - than the “happy path” case. The error cases are where you’re going to have to perform fallbacks or graceful degradation.</p><p> 处理副作用时，唯一有足够信息的函数来决定与错误有关的是调用函数。在许多系统中，错误情况同样重要 - 如果不是更重要的 - 而不是比“快乐的路径”案例。错误情况是您必须必须执行后备或优雅的退化。 </p><p> If your in a situation where errors are a vital part of your functions control flow, then it’s best to keep all of the error handling in the calling function using  case statements.</p><p>如果您在错误的情况下是函数控制流的重要组成部分，那么最好地使用案例语句保持调用函数中的所有错误处理。</p><p> # Do... def  main ( id )  do  case  :fuse . check ( :service )  do  :ok  -&gt;  case  call_service ( id )  do  { :ok ,  result }  -&gt;  :ok  =  Cache . put ( id ,  result )  { :ok ,  result }  { :error ,  error }  -&gt;  :fuse . melt ( :service )  { :error ,  error }  end  :blown  -&gt;  cached  =  Cache . get ( id )  if  cached  do  { :ok ,  result }  else  { :error ,  error }  end  end end</p><p> ＃do ... def main（id）do case：保险丝。检查（：服务）DO：OK  - ＆gt; case call_service（id）do {：确定，结果}  - ＆gt; ：好的=缓存。放（ID，结果）{：确定，结果} {：错误，错误}  - ＆gt; ：保险丝。熔化（：服务）{：错误，错误}结束：吹 - ＆gt;缓存=缓存。获取（id）如果缓存do {：确定，结果} else {：错误，错误}结束结束</p><p> This increases the size of the calling function, but the benefit is that you can read this entire function and understand each control flow.</p><p> 这增加了调用函数的大小，但是您可以阅读整个函数并理解每个控制流程。</p><p>  I used to be on the fence about piping into case statements, but I’ve seen this pattern abused too many times. Seriously y’all, put down the pipe operator and show a little restraint. If you find yourself piping into  case, it’s almost always better to assign intermediate steps to a variable instead.</p><p>  我曾经在围栏上围绕管道进入案例陈述，但我已经看到这种模式滥用太多次数。严重的是，放下管道操作员并显示有点克制。如果您发现自己的管道进入案例，它几乎总是最好分配到变量的中间步骤。</p><p> # Don&#39;t do... build_post ( attrs ) |&gt;  store_post () |&gt;  case  do  { :ok ,  post }  -&gt;  # ...  { :error ,  _ }  -&gt;  # ... end # Do... changeset  =  build_post ( attrs ) case  store_post ( changeset )  do  { :ok ,  post }  -&gt;  # ...  { :error ,  _ }  -&gt;  # ... end</p><p> ＃don＆＃39; t do ... build_post（attrs）|＆gt; store_post（）|＆gt;案例do {：好的，发布}  - ＆gt; ＃... {：错误，_}  - ＆gt; ＃...结束＃do ... chankinget = build_post（attrs）case store_post（chanceset）do {：好的，post}  - ＆gt; ＃... {：错误，_}  - ＆gt; ＃ ... 结尾</p><p>  Higher-order functions are great, so try not to hide them away. If you’re working with collections, you should prefer to write functions that operate on a single entity rather than the collection itself. Then you can use higher-order functions directly in your pipeline.</p><p>  高阶函数很棒，所以尽量不要将它们隐藏起来。如果您正在使用集合，则应更喜欢编写在单个实体而不是集合本身上运行的功能。然后，您可以直接在管道中使用高阶函数。</p><p> # Don&#39;t do... def  main  do  collection  |&gt;  parse_items  |&gt;  add_items end def  parse_items ( list )  do  Enum . map ( list ,  &amp; String . to_integer / 1 ) end def  add_items ( list )  do  Enum . reduce ( list ,  0 ,  &amp;  &amp;1  +  &amp;2 ) end # Do... def  main  do  collection  |&gt;  Enum . map ( &amp; parse_item / 1 )  |&gt;  Enum . reduce ( 0 ,  &amp; add_item / 2 ) end defp  parse_item ( item ),  do :  String . to_integer ( item ) defp  add_item ( num ,  acc ),  do :  num  +  acc</p><p> ＃don＆＃39; t do ... def main do collection |＆gt; Parse_Items |＆gt; add_items结尾parse_items（list）do枚举。地图（列表，＆amp; String。to_integer / 1）结束def add_items（list）do枚举。减少（列表，0，＆amp;＆amp; 1 +＆amp; 2）结束＃do ... def main do collection |＆gt;枚举。地图（＆amp; parse_item / 1）|＆gt;枚举。减少（0，＆amp; add_item / 2）结束defp parse_item（项目），do：string。 to_integer（项目）defp add_item（num，acc），do：num + acc </p><p> With this change, our  parse_item and  add_item functions become reusable in the broader set of contexts. These functions can now be used on a single item or can be lifted into the context of  Stream,  Enum,  Task, or any number of other uses. Hiding this logic away from the caller is a worse design because it couples the function to its call site and makes it less reusable. Ideally, our APIs are reusable in a wide range of contexts.</p><p>通过此更改，我们的PARSE_ITEM和ADD_ITEM功能在更广泛的上下文集中可重复使用。现在可以在单个项目上使用这些功能，或者可以升到流，枚举，任务或任意数量的其他用途的上下文中。隐藏此逻辑远离呼叫者是一种更糟糕的设计，因为它将函数耦合到其呼叫站点，并使它不太可重复使用。理想情况下，我们的API在广泛的背景下可重复使用。</p><p> Another benefit of this change is that better solutions may reveal themselves. In this case, we may decide that we don’t need the named functions and can use anonymous functions instead. We realize that we don’t need the  reduce and can use  sum.</p><p> 这种变化的另一个好处是更好的解决方案可能会揭示自己。在这种情况下，我们可以决定我们不需要命名功能，可以使用匿名功能。我们意识到我们不需要减少和可以使用总和。</p><p>  This final step may not always be the right choice. It depends on how much work your functions are doing. But, as a general rule, you should strive to eliminate functions that only have a single call site. Even though there are no dedicated names for these functions, the final version is no less “readable” than when we started. An Elixir programmer can still look at this series of steps and understand that the goal is to convert a collection of strings into integers and then sum those integers. And, they can realize this without needing to read any other functions along the way.</p><p>  最后一步可能并不总是正确的选择。这取决于您的功能在做多少工作。但是，作为一般规则，您应该努力消除只有单个呼叫站点的功能。即使这些函数没有专用名称，最终版本也不少于启动时的“可读”。 Elixir程序员仍然可以查看这一系列步骤，并了解目标是将字符串集合转换为整数，然后将这些整数进行总计。并且，他们可以在不需要沿途读取任何其他功能的情况下实现这一点。</p><p>  else can be helpful if you need to perform an operation that is generic across  all error values being returned. You should not use  else to handle all potential errors (or even a large number of errors).</p><p>  如果您需要执行返回所有错误值的操作，则可以有帮助。您不应该用别人来处理所有潜在的错误（甚至是大量错误）。</p><p> # Don&#39;t do... with  { :ok ,  response }  &lt;-  call_service ( data ),  { :ok ,  decoded }  &lt;-  Jason . decode ( response ),  { :ok ,  result }  &lt;-  store_in_db ( decoded )  do  :ok else  { :error ,  % Jason . Error {} = error }  -&gt;  # Do something with json error  { :error ,  % ServiceError {} = error }  -&gt;  # Do something with service error  { :error ,  % DBError {}}  -&gt;  # Do something with db error end</p><p> ＃don＆＃39; t do ...使用{：确定，响应}＆lt;  -  call_service（data），{：确定，解码}＆lt;  -  jason。解码（响应），{：确定，结果}＆lt;  -  store_in_db（解码）do：确定{：错误，％jason。错误{} =错误}  - ＆gt; ＃用json错误做点什么{：错误，％serviceError {} =错误}  - ＆gt; ＃使用服务错误{：错误，％dberror {}}  - ＆gt; ＃用db错误结束做点什么</p><p> For the same reason, under no circumstances should you annotate your function calls with a name just so you can differentiate between them.</p><p> 出于同样的原因，在任何情况下，您都应该用名称注释您的函数调用，以便您可以区分它们。</p><p> with  { :service ,  { :ok ,  resp }}  &lt;-  { :service ,  call_service ( data )},  { :decode ,  { :ok ,  decoded }}  &lt;-  { :decode ,  Jason . decode ( resp )},  { :db ,  { :ok ,  result }}  &lt;-  { :db ,  store_in_db ( decoded )}  do  :ok else  { :service ,  { :error ,  error }}  -&gt;  # Do something with service error  { :decode ,  { :error ,  error }}  -&gt;  # Do something with json error  { :db ,  { :error ,  error }}  -&gt;  # Do something with db error end</p><p> 使用{：service，{：确定，resp}}＆lt;  -  {：service，call_service（data）}，{：解码，{：确定，解码}}＆lt;  -  {：decode，jason。解码（RESP）}，{：db，{：确定，结果}}＆lt;  -  {：db，store_in_db（解码）} do：确定{：service，{：错误，错误}}  - ＆gt; ＃用服务错误做点什么{：解码，{：错误，错误}}  - ＆gt; ＃用JSON错误做点什么{：db，{：错误，错误}}  - ＆gt; ＃用db错误结束做点什么 </p><p> If you find yourself doing this, it means that the error conditions matter. Which means that you don’t want  with at all. You want  case.</p><p>如果您发现自己这样做，这意味着错误条件很重要。这意味着你根本不想要。你想要案例。</p><p> with is best used when you can fall through at any point without worrying about the specific error or contrary pattern. A good way to create a more unified way to deal with errors is to build a common error type like so:</p><p> 在不担心特定错误或相反模式的情况下，您可以在任何时候都可以掉落。创建更统一的方式来处理错误的好方法是构建一个常见的错误类型：</p><p> defmodule  MyApp . Error  do  defexception  [ :code ,  :msg ,  :meta ]  def  new ( code ,  msg ,  meta )  when  is_binary ( msg )  do  % __MODULE__ { code:  code ,  msg:  msg ,  meta:  Map . new ( meta )}  end  def  not_found ( msg ,  meta  \\  %{})  do  new ( :not_found ,  msg ,  meta )  end  def  internal ( msg ,  meta  \\  %{})  do  new ( :internal ,  msg ,  meta )  end end def  main  do  with  { :ok ,  response }  &lt;-  call_service ( data ),  { :ok ,  decoded }  &lt;-  decode ( response ),  { :ok ,  result }  &lt;-  store_in_db ( decoded )  do  :ok  end end # We wrap the result of Jason.decode in our own custom error type defp  decode ( resp )  do  with  { :error ,  e }  &lt;-  Jason . decode ( resp )  do  { :error ,  Error . internal ( &#34;could not decode:  #{ inspect  resp } &#34; )}  end end</p><p> defmodule myapp。错误de defexception [：代码，：meta：meta] def新建（代码，消息，meta）在is_binary（msg）do％__module__ {code：code，msg：msg，meta：map。 New（Meta）}}结束def not_found（msg，meta \\％{}）做新的（：not_found，msg，meta）结束def内部dem（msg，meta \\％{}）do new（：msg，msg，meta ）结束结束DEF主要与{：OK，响应}＆lt;  -  call_service（数据），{：确定，解码}＆lt;  - 解码（响应），{：确定，结果}＆lt;  -  store_in_db（解码）do：好的结束＃我们将jason.decode的结果包装在我们自己的自定义错误类型defp解码（RESP）与{：错误，e}＆lt;  -  jason。解码（resp）do {：错误，错误。内部（＆＃34;无法解码：＃{inspect resp}＆＃34;）}结束结束</p><p> This error struct provides a unified way to surface all of the errors in your application. The struct can render errors in a phoenix controller or be returned from an RPC handler. Because the struct your using is an exception, the caller can also choose to raise the error, and you’ll get well-formatted error messages.</p><p> 此错误结构提供了统一的方式来浏览应用程序中的所有错误。结构可以在Phoenix控制器中呈现错误，也可以从RPC处理程序返回。由于Surruct您的使用是一个例外，所以来电也可以选择提出错误，并且您将获得格式化的错误消息。</p><p>   You should be intentional about your function’s requirements. Don’t bother checking that a value is not  nil if what you expect it to be is a string:</p><p>   您应该有意地了解您的功能的要求。不要打扰检查一个值不是nil如果你期望它是一个字符串：</p><p> # Don&#39;t do... def  call_service (%{ req:  req })  when  not  is_nil ( req )  do  # ... end # Do... def  call_service (%{ req:  req })  when  is_binary ( req )  do  # ... end</p><p> ＃don＆＃39; t do ... def call_service（％{req：req}），当不是is_nil（req）do＃...结束＃do ... def call_service（％{req：req}）ins_binary（ req）do＃...结束</p><p> The same is true for  case statements and  if statements. Be more explicit about what it is you expect. You’d prefer to raise or crash if you receive arguments that would violate your expectations.</p><p> 对于案例陈述以及IF语句也是如此。更明确地了解您的期望。如果您收到违反您期望的论据，您更愿意提高或崩溃。 </p><p>  You should only force your user to deal with errors that they can do something about. If your API can error, and there’s nothing the caller can do about it, then raise an exception or throw. Don’t bother making your callers deal with result tuples when there’s nothing they can do.</p><p>您应该只强制您的用户处理他们可以做点什么的错误。如果您的API可能会出现错误，并且呼叫者无法对此进行任何事情，然后提出异常或抛出。当他们无能为力时，不要打扰你的呼叫者处理结果元组。</p><p> # Don&#39;t do... def  get ( table  \\  __MODULE__ ,  id )  do  # If the table doesn&#39;t exist ets will throw an error. Catch that and return  # an error tuple  try  do  :ets . lookup ( table ,  id )  catch  _ ,  _  -&gt;  { :error ,  &#34;Table is not available&#34; }  end end # Do... def  get ( table  \\  __MODULE__ ,  id )  do  # If the table doesn&#39;t exist, there&#39;s nothing the caller can do  # about it, so just throw.  :ets . lookup ( table ,  id ) end</p><p> ＃don＆＃39; t do ... def get（table \\ __module__，ID）do＃，如果表没有，则存在ETS会抛出错误。捕获并返回＃错误元组尝试执行以下操作：ETS。查找（表，ID）捕获_，_  - ＆gt; {：错误，＆＃34;表格不可用＆＃34; }结束＃do ... def get（表\\ __module__，ID）do＃如果表没有存在，那里的＆＃39;没有呼叫者可以做＃关于它，所以刚刚扔。 ：ETES。查找（表，ID）结束</p><p>  You should not be afraid of just raising exceptions if a return value or piece of data has violated your expectations.If you’re calling a downstream service that should always return JSON, use  Jason.decode! and avoid writing additional error handling logic.</p><p>  如果返回值或数据违反了您的期望，您不应该害怕仅提高异常。如果您调用了应该始终返回JSON的下游服务，请使用Jason.decode！并避免编写额外的错误处理逻辑。</p><p> # Don&#39;t do... def  main  do  { :ok ,  resp }  =  call_service ( id )  case  Jason . decode ( resp )  do  { :ok ,  decoded }  -&gt;  decoded  { :error ,  e }  -&gt;  # Now what?...  end end # Do... def  main  do  { :ok ,  resp }  =  call_service ( id )  decoded  =  Jason . decode! ( resp ) end</p><p> ＃don＆＃39; t do ... def main do {：好的，resp} = call_service（id）case jason。解码（RESP）DO {：OK，解码}  - ＆gt;解码{：错误，e}  - ＆gt; ＃现在是什么？...结束＃do ... def main do {：好的，resp} = call_service（id）解码= jason。解码！ （resh）结束</p><p> This allows us to crash the process (which is good) and removes the useless error handling logic from the function.</p><p> 这允许我们崩溃该过程（这是好的），并从功能中删除无用的错误处理逻辑。</p><p>   # Don&#39;t do... assert  Enum . all? ( posts ,  fn  post  -&gt;  % Post {}  ==  post  end ) # Do... for  post  &lt;-  posts ,  do :  assert  % Post {}  ==  post</p><p>   ＃don＆＃39; t do ...断言枚举。全部？ （帖子，fn后＆gt;％post {} ==帖子结束）＃do ...对于post＆lt; posts，do：senert％post {} == post </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://keathley.io/blog/good-and-bad-elixir.html">https://keathley.io/blog/good-and-bad-elixir.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bad/">#bad</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>