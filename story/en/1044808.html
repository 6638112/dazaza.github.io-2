<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么服务网格应逐渐消失 Why the Service Mesh Should Fade Out of Sight</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why the Service Mesh Should Fade Out of Sight<br/>为什么服务网格应逐渐消失 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-18 07:51:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/af861bfb20f1eb7c8c089ef1b8eabbad.jpg"><img src="http://img2.diglog.com/img/2021/1/af861bfb20f1eb7c8c089ef1b8eabbad.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>With rising interest in service meshes, many application development and delivery pros’ first encounter with one leaves them wondering how they differ from API gateways. Are service meshes their own product category? Or are they part of broader API management? These questions miss the point: Service meshes need to fade away into the background of development platforms. To understand why, one must first understand the quiet revolution happening with Kubernetes.</p><p>随着对服务网格的兴趣日益浓厚，许多应用程序开发和交付专家首次与之接触时，使他们想知道它们与API网关有何不同。服务网格是他们自己的产品类别吗？还是它们是更广泛的API管理的一部分？这些问题没有抓住重点：服务网格需要逐渐淡入开发平台的后台。要了解原因，首先必须了解Kubernetes所发生的悄悄变革。</p><p>  Legacy operating systems manage the resources of a computer and provide higher levels of abstractions for programmers to interact with the complex underlying hardware. They arose to address the challenges of hand-coding direct interactions with hardware.</p><p>  传统操作系统管理计算机的资源，并为程序员提供更高级别的抽象，以使其与复杂的基础硬件进行交互。他们开始解决手工编码与硬件的直接交互的挑战。</p><p> Kubernetes manages the resources of a cluster of computers and provides higher levels of abstractions for programmers to interact with complex underlying hardware and unstable, insecure networks. It arose to address the challenges of hand-coding direct interactions with clustered hardware. Although primitive by OS standards, it will make legacy OSes like Linux and Windows more and more irrelevant as it matures.</p><p> Kubernetes管理计算机集群的资源，并为程序员提供更高级别的抽象，以使其与复杂的基础硬件和不稳定，不安全的网络进行交互。它开始解决与集群硬件进行手动编码直接交互的挑战。尽管按操作系统标准是原始的，但随着它的成熟，它将使诸如Linux和Windows之类的旧操作系统变得越来越不相关。</p><p>  A service mesh is the modern-day dynamic linker for distributed computing. With traditional programming, including another module involves importing a library into your integrated development environment (IDE). Upon deployment, the operating system’s dynamic linker connects your program with the library at runtime. It also handles discovering the library, validating security to invoke the library, and establishing a connection to it. With a microservices architecture, your “library” is a network hop to another microservice. Finding that “library” and establishing a secure connection is the job of the service mesh.</p><p>  服务网格是用于分布式计算的现代动态链接器。在传统编程中，包括另一个模块在内涉及将库导入到集成开发环境（IDE）中。部署后，操作系统的动态链接器会在运行时将程序与库连接。它还处理发现库，验证调用库的安全性以及建立与它的连接。使用微服务架构，您的“库”就是到另一个微服务的网络跳转。查找该“库”并建立安全连接是服务网格的工作。</p><p> Just as it makes no sense for development and operations teams to have to think about a dynamic linker, much less care and feed for one, modern-day teams should not have to care and feed for a complicated service mesh. The situation we see today of service meshes being first-class infrastructure is an important step forward, but they have a problem: They are too visible.</p><p> 正如开发和运营团队不必考虑一个动态链接器一样，少了一个人的关心和提要，现代的团队就不必关心和提要一个复杂的服务网格。我们今天看到的服务网格成为一流基础架构的情况是向前迈出的重要一步，但是它们存在一个问题：它们太明显了。</p><p> Installing a typical service mesh requires several manual steps. Infrastructure teams must coordinate with AppDev teams to ensure that connection configurations are compatible with what was coded. Many service meshes are too complicated to stand up at scale and require solid operational support talent to configure and keep them healthy. You may even need to understand the service mesh’s internal architecture to debug it when things go wrong. This must change.</p><p> 安装典型的服务网格需要几个手动步骤。基础架构团队必须与AppDev团队协调，以确保连接配置与编码内容兼容。许多服务网格过于复杂，无法大规模扩展，需要强大的运营支持人才来配置和保持健康。您甚至可能需要了解服务网格的内部体系结构，以便在出现问题时进行调试。这必须改变。</p><p>  Imagine a developer experience in which importing a JAR or DLL library required all the installation, configuration, and operational support a service mesh entails. What if it also required understanding the internal architecture of the operating system’s dynamic linker to diagnose runtime problems? I hear you responding, “That’d be insane!”</p><p>  想象一下开发人员的经验，其中导入JAR或DLL库需要服务网格所需要的所有安装，配置和操作支持。如果还需要了解操作系统动态链接器的内部体系结构以诊断运行时问题怎么办？我听到你在回答，“那太疯狂了！” </p><p> Contrast this to the real experience of linking to a library: You reference the library from your IDE, build, and deploy. Done. That should be the gold standard for service mesh.</p><p>将此与链接到库的真实体验进行对比：您可以从IDE中引用该库，然后进行构建和部署。做完了那应该是服务网格的黄金标准。</p><p> Obviously, that is unattainable. A network call is more complicated than an in-memory library link. The point is that a service mesh should become as invisible as possible to the DevOps team. It should  strive toward that gold standard, even if it can never quite get there 100%.</p><p> 显然，这是无法实现的。网络调用比内存库链接更复杂。关键是，服务网格对DevOps团队应尽可能不可见。即使它不可能永远达到100％，它也应该朝着那个金标准努力。</p><p> Imagine a cloud-native development environment that enables developers to link microservices at build time. It then pushes the configurations of these connections into Kubernetes as part of the build process. Kubernetes then takes care of the rest, with the service mesh just being an implementation detail of your Kubernetes distribution that you rarely have to think about.</p><p> 想象一下一个云原生开发环境，使开发人员能够在构建时链接微服务。然后，在构建过程中，将这些连接的配置推送到Kubernetes中。然后，Kubernetes负责其余的工作，而服务网格只是您很少考虑的Kubernetes发行版的实现细节。</p><p> Vendors that believe service mesh is merely about connectivity miss the point. The fundamental value of microservices (and cloud in general) is greater agility and scalability from smaller deployable units running on serverless, yet the programming constructs we’ve needed for decades haven’t gone away. Many advancements in cloud technology are filling in the constructs we lost when migrating from monoliths to cloud-native. Vendors that make the microservice developer’s experience more on par with that of traditional software development, without sacrificing the benefits of microservices, will have the winning products.</p><p> 那些相信服务网格仅仅是关于连通性的供应商会忽略这一点。微服务（通常是云）的基本价值在于，在无服务器上运行的较小的可部署单元具有更大的敏捷性和可伸缩性，但数十年来我们一直需要的编程结构并未消失。云技术的许多进步填补了我们从整体式迁移到云原生时失去的结构。使微服务开发人员的体验与传统软件开发更加类似的供应商，而又不牺牲微服务的利益，将获得成功的产品。</p><p> In sum, the service mesh should be a platform feature, not a product category — as far out of sight and mind from the DevOps team as possible.</p><p> 总而言之，服务网格应该是平台功能，而不是产品类别，这应尽可能远离DevOps团队。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://go.forrester.com/blogs/why-the-service-mesh-should-fade-out-of-sight/">https://go.forrester.com/blogs/why-the-service-mesh-should-fade-out-of-sight/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/网格/">#网格</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mesh/">#mesh</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>