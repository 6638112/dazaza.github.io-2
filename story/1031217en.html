<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使用Docker图像、容器和Dockerfile</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何使用Docker图像、容器和Dockerfile</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 21:49:55</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/683f76973c3deabfab3d9be9c2e0a460.png"><img src="http://img2.diglog.com/img/2020/10/683f76973c3deabfab3d9be9c2e0a460.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>D ocker can be confusing when you’re getting started. Even after you watch a few tutorials, its terminology can still be unclear. This article is intended for people who have installed Docker and played around a bit, but could use some clarification. We’re going to make all three core pieces of Docker and give some helpful other commands. It’s going to cover a lot,  be sure to click the links.</p><p>当你刚开始的时候，Docker可能会让你感到困惑。即使您看了几个教程，它的术语仍然可能不清楚。本文的目标读者是那些安装过Docker并有过一些经验的人，但可能需要澄清一下。我们将制作Docker的所有三个核心部分，并提供一些有用的其他命令。它将涵盖很多内容，一定要点击链接。</p><p>   We’re going to step through eve ry piece of this graphic, but it’s helpful to see the three main stages upfront as a roadmap. In short,  Dockerfiles are used to  build  images. Images are used to  create  containers. You then have to  start and  attach to the  containers. The  run  command allows you to combine the  create ,  start , and  attach  commands all at once.</p><p>我们将逐步介绍这张图的每一个部分，但将前面的三个主要阶段看作路线图会很有帮助。简而言之，Dockerfile用于构建镜像。图像用于创建容器。然后，您必须启动并连接到容器上。Run命令允许您一次组合所有创建、启动和附加命令。</p><p>   In order for our project to do something, we’re going to make a  server.js file that sends a simple text response.  This is the only Node code in the tutorial.   You do not need to know Node.</p><p>为了让我们的项目有所作为，我们将创建一个server.js文件，该文件发送一个简单的文本响应。这是本教程中唯一的节点代码。您不需要知道Node。</p><p> const  http = require(&#34; http&#34;);  const  app = (req,  res) =&gt; {   console.log( &#34;ping!&#34;);   res.end(&#34; Hello there.&#34;, &#34; utf-8&#34;); }  http.createServer(app).listen(3000);  console.log(&#34; server started&#34;);</p><p>Const http=Required(&#34；http&#34；)；const app=(req，res)=&gt；{console.log(&#34；ping！&#34；)；res.end(&#34；Hello here.&#34；，&#34；utf-8&#34；)；}http.createServer(App).listen(3000)；console.log(&#34；server started&#34；)；</p><p>  A Dockerfile is simply a text file with instructions that Docker will interpret to make an image. It is relatively short most of the time and primarily consists of individual lines that build on one another. It is expected to be called  Dockerfile (case sensitive) and does not have a file extension. Here is a simple example:</p><p>Dockerfile只是一个文本文件，其中包含Docker将解释以生成图像的指令。它大部分时间相对较短，主要由相互构建的单独线路组成。它应该称为Dockerfile(区分大小写)，并且没有文件扩展名。下面是一个简单的示例：</p><p>  This isn’t a tutorial on  how to write Dockerfiles, but let’s talk about this for a second. What our Dockerfile is doing is pulling down the Node image  called node:12-slim  FROM  DockerHub (or your machine) so we can build our custom image on top of it. DockerHub is an online repository of images; kind of like NPM or Pip. Then we’re  COPYing our  server.js into the environment so our eventual container will have access to it. The last thing in a Dockerfile is usually a  CMD (command) for the container to run once it’s made. In our case it’s going to start our  server.js.</p><p>这不是关于如何编写Dockerfile的教程，但是让我们花一点时间来讨论一下。我们的Dockerfile所做的是从DockerHub(或您的机器)拉下名为node：12-slm的节点映像，以便我们可以在其上构建自定义映像。DockerHub是一个在线图片库；有点像NPM或Pip。然后，我们将server.js复制到环境中，以便最终的容器可以访问它。Dockerfile中的最后一件事通常是容器创建后要运行的CMD(命令)。在我们的示例中，它将启动我们的server.js。</p><p> NOTE: It is crucial that each piece the   CMD  array is surrounded by   double quotes or else it won’t work properly .</p><p>注意：CMD数组的每一段都要用双引号括起来，这一点很重要，否则它将无法正常工作。</p><p>  The way to build an image from a Dockerfile is to run  build on the command line. The following command assumes we’re in the same directory as our  server.js and  Dockerfile:</p><p>从Dockerfile构建映像的方法是在命令行上运行build。以下命令假定我们与server.js和Dockerfile位于同一目录中：</p><p>  The  . tells Docker to build from the  Dockerfile in the current directory. As a bonus, we gave our image a tag of  my-node-img. This will help us specify which image we are using without having to use an id. Here’s a  guide on image tags.  You should know that you can use image and container IDs instead of tags and names, but words are easier to remember. Building can take a minute, but once done, we will have our image! See it by running:</p><p>那个。告诉Docker从当前目录中的Dockerfile构建。作为额外奖励，我们为我们的图像添加了my-node-img标记。这将帮助我们指定正在使用的图像，而不必使用ID。这里有一个关于图像标签的指南。您应该知道，您可以使用图像和容器ID代替标记和名称，但是单词更容易记住。建造可能需要一分钟，但一旦完成，我们就会有自己的形象！通过运行以下命令查看它：</p><p>   If a Dockerfile is a set of instructions used to create an image, it’s helpful to think that an image is just a template used to create a container. An image is responsible for setting up the application and environment that will exist inside the container. The important thing to understand is that  images are read-only. You do not make edits to an image, you make edits to the Dockerfile and then build a  new image.</p><p>如果Dockerfile是用于创建镜像的一组指令，那么将镜像看作是用于创建容器的模板会很有帮助。映像负责设置容器内将存在的应用程序和环境。需要了解的重要一点是，图像是只读的。您不需要对图像进行编辑，而是对Dockerfile进行编辑，然后构建新的图像。</p><p> One of the features that makes Docker so powerful is that images can be layered. In every Dockerfile, you’ll be pulling down a base image to start from. And those base images are probably built from others, it’s images all the way down. This layering effect helps with things like  caching for CI/CD purposes. But anyway, images aren’t good for much besides creating containers, so let’s do that!</p><p>使Docker如此强大的功能之一是图像可以分层。在每个Dockerfile中，您将从一个基础映像开始。而那些基础图像可能是从其他图像构建而来的，它一直都是图像。这种分层效果有助于实现用于CI/CD目的的缓存等功能。但不管怎样，除了创建容器之外，图像也没什么好处，所以我们就这么做吧！</p><p>  Finally, we’re getting to the good stuff. This is technically all you need to do to  create a container:</p><p>最后，我们要说到好东西了。从技术上讲，您需要做的就是创建容器：</p><p>  However, for our server example, that’s kind of useless. We’ll need to add some flags:</p><p>但是，对于我们的服务器示例来说，这是无用的。我们需要添加一些标志：</p><p>  The  --name lets us assign our own name. Docker will autogenerate a name for the container if we don’t, but they’re long and  terrible. The  --init means we’re using the  Tini package that comes built in with Docker. It handles  ctrl-C and keeps us from getting stuck in our container. Next up is  -p, which connects our host machine’s port 3000 to the Docker container’s port 3000. Without this, we wouldn’t be able to connect to our server. The last argument is the actual  image tag that will create our container.</p><p>--name允许我们指定自己的名称。如果我们不这样做，Docker会自动为容器生成一个名称，但它们又长又可怕。Init表示我们使用的是Docker内置的Tini包。它处理ctrl-C，使我们不会被困在容器中。接下来是-p，它将主机的端口3000连接到Docker容器的端口3000。没有它，我们将无法连接到我们的服务器。最后一个参数是将创建容器的实际图像标记。</p><p>  The container is what actually  runs our app. Think of the container like an isolated Linux box. It’s essentially a  lighter weight virtual machine. The  point of having a container is standardization. An application only has to care about the container it’s run in. No more, “But it works on my machine!” If an app runs in a container, it will work the same way  no matter where the container itself is hosted. This makes both local development and production deployments much,  much easier.</p><p>容器是实际运行我们的应用程序的东西。可以将容器想象成一个孤立的Linux盒子。它本质上是一个重量更轻的虚拟机。拥有集装箱的意义在于标准化。应用程序只需关心它在其中运行的容器。不会再说了，“但它能在我的机器上工作！”如果应用程序在容器中运行，则无论容器本身驻留在何处，它都将以相同的方式工作。这使得本地开发和生产部署都变得非常非常容易。</p><p>  All  create did was  create the container, it didn’t  start it. You can still see that it  exists with   docker ps and some extra filters:</p><p>Create所做的只是创建容器，而不是启动它。您仍然可以看到它与坞站PS和一些额外的过滤器一起存在：</p><p>  But, if you go to localhost:3000, nothing happens. Our container still isn’t active,  it just…exists; its  status is merely “created.”  start it by running:</p><p>但是，如果您转到localhost：3000，则什么也不会发生。我们的集装箱仍然不活动，它只是…。存在；其状态仅为“已创建”。通过运行以下命令启动它：</p><p>  Now when you go to localhost:3000, it responds! Since our container is officially “running” we can also see it with a regular  docker ps, which by default only shows running containers.</p><p>现在，当您转到localhost：3000时，它会响应！因为我们的容器正式“运行”了，所以我们也可以使用常规的docker ps来查看它，默认情况下，它只显示正在运行的容器。</p><p>  How do we see our container’s outputs and logs? Well, there’s  technically a command you  can run, but hang on before typing it:</p><p>我们如何查看容器的输出和日志？从技术上讲，您可以运行一个命令，但在键入它之前请稍候：</p><p>  Be warned: if you run   attach, your terminal is going to get stuck displaying the container logs. Worse, if you attach and then  ctrl-C to get out, it will actually  stop the container on exit. Or worse, it will just ignore the ctrl-C and trap your terminal. If that ever happens to you, you’ll have to open a new terminal and stop the container (more on that later). That’s why in your applications you should handle the SIGTERM or use the Tini package like we have in our example. A  better way to see output is the Docker  logs command:</p><p>请注意：如果您运行ATTACH，您的终端将在显示容器日志时停滞。更糟糕的是，如果您连接然后按ctrl-C组合键退出，它实际上会在退出时停止容器。或者更糟的是，它将忽略ctrl-C并捕获您的终端。如果这种情况发生在您身上，您将不得不打开一个新的终端并停止容器(稍后将详细介绍)。这就是在您的应用程序中应该处理SIGTERM或使用TINI包的原因，就像我们在示例中所做的那样。查看输出的更好方法是Docker logs命令：</p><p>  That will show you the logs as they print from your container.  ctrl-C to get out of this with no interruptions to your container. If you just want the logs print out statically, omit the  -f flag.</p><p>这将显示从您的容器打印的日志。按Ctrl-C组合键可以在不中断容器的情况下离开这里。如果您只想静态打印日志，那么可以省略-f标志。</p><p>  If you want to go into the container to explore the file system, you’d want to run this:</p><p>如果您想要进入容器来浏览文件系统，则需要运行以下命令：</p><p>  exec  executes any command on a  running container. If it’s going to be an interactive one, like opening a  bash shell, you must  include the   -it  flags. Also, heads up that some containers may not have  bash installed, so you might need to try  sh or  ash if it doesn’t work.</p><p>EXEC在运行的容器上执行任何命令。如果它是交互式的，比如打开bash shell，则必须包括-it标志。另外，请注意某些容器可能没有安装bash，因此如果不起作用，您可能需要尝试使用sh或ash。</p><p>  As you remember with the infographic,  run is a shortcut that takes care of  create,  start, and  attach all at once:</p><p>正如您在信息图中所记得的那样，Run是一种快捷方式，可以一次完成创建、启动和附加操作：</p><p>  However, like we talked about, attaching takes up the terminal, which is probably not what you want. Run the command with the  -d flag (detached mode) so the container goes in the background:</p><p>但是，正如我们所说的，连接会占用终端，这可能不是您想要的。运行带有-d标志的命令(分离模式)，以便容器进入后台：</p><p>  All the options are still doing the same thing they were doing with  create, with the exception of the new  --rm flag. This simply removes our container from our machine when we stop the container. That will allow you to run the same command without name space issues; it’s mainly for practicing.</p><p>除了新的--rm标志之外，所有选项仍在执行与create相同的操作。这只是在我们停止容器时将容器从机器中删除。这将允许您运行相同的命令，而不会出现名称空间问题；它主要用于练习。</p><p>  Of course, you will want to stop and remove old/stuck containers, and that’s luckily straightforward:</p><p>当然，您会想要停下来移走旧的/卡住的容器，幸运的是这很简单：</p><p>    The  subshell is using the  -q (quiet) flag to only return the container ids, which are then fed into the  stop command.</p><p>子shell使用-q(安静)标志仅返回容器ID，然后将其提供给停止命令。</p><p>  run doesn’t actually need the image to be on the host machine. If Docker can’t find the specified image locally, it will try to find it on DockerHub. This is useful when paired with another feature of  run: it can execute a command on the newly created container. For example, you could spin up a Node image and then start it in bash instead of the default Node repl:</p><p>Run实际上不需要映像位于主机上。如果Docker在本地找不到指定的镜像，会尝试在DockerHub上找到。这在与Run的另一个特性配合使用时非常有用：它可以在新创建的容器上执行命令。例如，您可以启动一个节点映像，然后在bash中启动它，而不是默认的Node repl：</p><p>  The command to run just goes after the image tag. Remember, you only need the  -it flags if the command is interactive. If you just wanted to see the Linux version for example, no flags are necessary:</p><p>要运行的命令紧跟在图像标记之后。请记住，如果命令是交互式的，则只需要-it标志。例如，如果您只想查看Linux版本，则不需要任何标志：</p><p>   We’ve had one container yes, but what about a second container? That’s another powerful feature of Docker: you can easily network containers together. But once you have 2 or more containers to manage, I wouldn’t recommended that you try to control them from the command line. No, what you’ll want to start using is a  container orchestration system, usually it’ll be Docker Compose for local development and Kubernetes for actual production. I recommend watching this video to pick up  the basics of Compose and this  series to take a deeper dive with Kubernetes.</p><p>我们有一个集装箱，是的，但是第二个集装箱呢？这是Docker的另一个强大特性：您可以轻松地将容器联网在一起。但是，一旦您有2个或更多的容器需要管理，我不建议您尝试从命令行控制它们。不，您需要开始使用的是容器编排系统，通常是用于本地开发的Docker和用于实际生产的Kubernetes。我推荐看这个视频来学习作曲的基础知识，这个系列可以让你更深入地了解Kubernetes。</p><p>    # Build your image   docker  build  -t my-node-img . # Show specific image   docker  image  ls my-node-img # to see all images on your machine  docker  image  ls # Create a container with the tiny package, a name, and port  docker  create  --init --name my-app  -p 3000:3000 my-node-img # Show newly created container  docker  ps  -a  --filter &#34;name=my-app&#34; # Start your container  docker  start my-app # Attach to container (not recommended)   docker  attach my-app # See containers logs (recommended)  docker  logs  -f my-app # access container&#39;s system   docker  exec  -it my-app bash # using the run shortcut   docker  run  --name my-app  -p 3000:3000  -d  --init  --rm my-node-img # Stop a running container  docker  stop my-app # Remove a non-running container  docker  rm my-app # see all running containers   docker  ps # stop all running containers  docker  stop $( docker  ps  -q) # Check version of linux for container  docker  run node:12-slim  cat /etc/issue</p><p>#构建您的镜像docker build-t my-node-img。#show Specific image docker image ls my-node-img#要查看机器docker映像ls上的所有图像，请使用微包、名称和端口docker创建容器--init--name my-app-p 3000：3000 my-node-img#show new create容器docker ps-a--filter&#34；name=my-app&#34；#启动您的集装箱码头启动my-app#连接到容器(不推荐)docker连接my-app#查看容器日志(推荐)码头日志-f my-app#访问容器&#39；S system docker exec-it my-app bash#使用运行快捷方式docker run--name my-app-p 3000：3000-d--init--rm my-node-img#停止正在运行的容器docker stop my-app#删除非正在运行的容器docker rm my-app#查看所有正在运行的容器docker ps#停止所有正在运行的容器docker stop$(docker ps-q)#检查容器docker运行节点的Linux版本：12-slm cat/etc/Issue</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/@mostlyfocusedmike/how-to-use-docker-images-containers-and-dockerfiles-39e4e8fc181a">https://medium.com/@mostlyfocusedmike/how-to-use-docker-images-containers-and-dockerfiles-39e4e8fc181a</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/images/">#images</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/容器/">#容器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>