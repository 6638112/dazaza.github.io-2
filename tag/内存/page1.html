<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#内存</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#内存</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042086.html">华硕确认拥有20GB内存的3080 Ti显卡 </a></div><div class="item_title_en"><a target="_blank" href="https://videocardz.com/newz/asus-confirms-rog-strix-geforce-rtx-3080-ti-graphics-card-with-20gb-memory">Asus confirms 3080 Ti graphics card with 20GB memory</a><span>(videocardz.com)</span></div><span class="my_story_list_date">2020-12-28 4:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042086.html"><img src="http://img2.diglog.com/img/2020/12/thumb_4ec2b608f5c1023c671ffee7fa5098af.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">华硕服务和支持网站已经列出了即将面世的GeForce RTX 3080 Ti显卡。
  制造商将首先确认这种NVIDIA SKU的存在。清单显示正在开发两种ROG STRIX图形卡：ROG-STRIX-RTX3080TI-O20G-GAMING（具有工厂超频功能）和ROG-STRIX-RTX3080TI-20G-GA......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/显卡/">#显卡</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/确认/">#确认</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphics/">#graphics</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/具有/">#具有</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041879.html">Dev-C ++是内置于Delphi中的低内存Windows Native C ++ IDE </a></div><div class="item_title_en"><a target="_blank" href="https://blogs.embarcadero.com/dev-c-is-a-low-memory-windows-native-c-ide-built-in-delphi/">Dev-C++ Is a Low Memory Windows Native C++ IDE Built in Delphi</a><span>(blogs.embarcadero.com)</span></div><span class="my_story_list_date">2020-12-26 10:33</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041879.html"><img src="http://img2.diglog.com/img/2020/12/thumb_6aa94bd50df08daa9373a24000494d15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Embarcadero Dev-C ++是Bloodshed Dev-C ++和Orwell Dev-C ++的新改进版（由Embarcadero赞助）。 它是功能齐全的集成开发环境（IDE）和C / C ++编程语言的代码编辑器。 它使用TDM-GCC 9.2.0中GCC的Mingw端口（GNU编译器集合）作为具有......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/delphi/">#delphi</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041321.html">硬件安全机制保护移动设备上的物理内存 </a></div><div class="item_title_en"><a target="_blank" href="https://corellium.com/blog/mobile-physical-memory-security">Hardware security mechanisms protecting physical memory on mobile devices</a><span>(corellium.com)</span></div><span class="my_story_list_date">2020-12-23 2:53</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041321.html"><img src="http://img2.diglog.com/img/2020/12/thumb_70490453d8abbe0eef836c517808b892.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters
Warning: Can only detect less than 5000 characters</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/机制/">#机制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/security/">#security</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/warning/">#warning</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040874.html">V编译时内存管理：在8MB文件上运行Ved编辑器，泄漏为0 </a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=gmB8ea8uLsM">V compile time memory management:Running the Ved-editor on 8MB file with 0 leaks</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-12-20 20:17</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040874.html"><img src="http://img2.diglog.com/img/2020/12/thumb_58bd56e4706e11b4979021072ce689af.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">很抱歉背景CPU风扇的噪音，它是一台旧笔记本电脑。支持V的开发：https：//github.com/sponsors/medvednikov </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ved/">#ved</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/file/">#file</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/https/">#https</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040759.html">苹果的8GB M1硅并不是魔术，而是魔术 </a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/macoclock/apples-8gb-m1-silicon-isn-t-magic-but-it-is-magical-6da7bb14fc52">Apple’s 8GB M1 Silicon Isn’t Magic, but It Is Magical</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-12-20 0:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040759.html"><img src="http://img2.diglog.com/img/2020/12/thumb_0153447972de5e198248f2e6d40368d1.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在我的故事《谁的确在他们的M1 Mac中真正需要16GB？》中，我反对瑞妮·里奇（Renee Ritchie）的主张，即任何有能力在购买M1 Mac时升级到16GB的人都应该这样做。我的观点是，大量Mac用户不会从购买升级中获得重大收益。我不知道为什么会为此感到不安，但以下是对此说法有疑问的人的简要总结：
 8GB可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/m1/">#m1</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039379.html">编写内存分配器 </a></div><div class="item_title_en"><a target="_blank" href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/">Writing a Memory Allocator</a><span>(dmitrysoshnikov.com)</span></div><span class="my_story_list_date">2020-12-13 8:49</span><div class="my_story_list_item_desc">这是“垃圾回收算法”类的第六个讲座，专门讨论自动内存管理。
 在讨论收集垃圾的算法之前，我们需要了解如何将这些对象（最终成为垃圾）分配到堆上。在今天的讲座中，我们将讨论内存分配机制。
           如果您喜欢这项工作并觉得有用，请考虑捐赠以支持无广告的高质量教育。
  注意：另请参阅有关编写池分配器和编写标记......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039310.html">现代存储系统的线程每核缓冲区管理 </a></div><div class="item_title_en"><a target="_blank" href="https://vectorized.io/blog/tpc-buffers/">Thread-Per-Core Buffer Management for a modern storage system</a><span>(vectorized.io)</span></div><span class="my_story_list_date">2020-12-13 3:12</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039310.html"><img src="http://img2.diglog.com/img/2020/12/thumb_f84a708f828fff14f092a76e6ba324d4.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">正如我之前所观察到的，软件不是基于类别理论运行的，而是在具有宽通道，多通道GB / s存储单元和NVMe SSD访问时间约为10-100微秒的超标量CPU上运行。十年前在不同的硬件平台上编写的某些软件感到缓慢的原因是因为它无法利用现代硬件的进步。
 存储系统中的新瓶颈是CPU。 SSD设备比旋转磁盘快100-1000......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储系统/">#存储系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038571.html">ORC – Nim的新内存管理 </a></div><div class="item_title_en"><a target="_blank" href="https://nim-lang.org/blog/2020/12/08/introducing-orc.html">ORC – Nim's new memory managment</a><span>(nim-lang.org)</span></div><span class="my_story_list_date">2020-12-9 19:48</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038571.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">1.4版附带了所谓的ORC内存管理算法.ORC是现有的ARC算法（1.2版中首次提供）以及acycle收集器。这也是名称的由来-“ O”代表循环，“ RC”代表“引用计数”，这是算法的基础。
 循环收集器基于Lins和其他人众所周知的“尝试删除”算法。在这里，我不会描述该算法的工作原理-您可以阅读该论文以获得很好的描......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nim/">#nim</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/orc/">#orc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038554.html">内存处理的现代入门 </a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2012.03112">A Modern Primer on Processing in Memory</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-12-9 19:40</span><div class="my_story_list_item_desc">下载PDF摘要：绝大多数设计用于将数据移至计算的现代计算系统。这种设计选择直接与至少三个导致性能，可伸缩性和能源瓶颈的计算关键趋势背道而驰：（1）数据访问是一个关键瓶颈，因为许多重要的应用程序都越来越密集地使用数据，并且内存带宽和能源无法很好地扩展，（ 2）能耗是几乎所有计算平台（尤其是服务器和移动系统）中的关键限制......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/处理/">#处理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/primer/">#primer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038291.html">FuzzOS –专为模糊测试而设计的操作系统 </a></div><div class="item_title_en"><a target="_blank" href="https://gamozolabs.github.io/fuzzing/2020/12/06/fuzzos.html">FuzzOS – an operating system which is designed specifically for fuzzing</a><span>(gamozolabs.github.io)</span></div><span class="my_story_list_date">2020-12-8 4:13</span><div class="my_story_list_item_desc">我们将使用专门为模糊测试设计的操作系统！这将是12月大部分时间的流媒体系列，内容包括制作一个新的操作系统，重点是模糊测试。这意味着诸如内存管理器，确定性和可伸缩性之类的东西将是操作系统最重要的部分，并且要花很多精力才能使其变得超快！
  直播将在12月10日（星期四）世界标准时间18:00左右的某个时间开始，但直播将......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/operating/">#operating</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038241.html">Ravenbrook的内存池系统 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Ravenbrook/mps">Memory Pool System by Ravenbrook</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-8 0:35</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038241.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a90ea9ff3fc140e0c5bd347ff464c83d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pool/">#pool</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/warning/">#warning</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037140.html">安装了多少物理内存？</a></div><div class="item_title_en"><a target="_blank" href="https://toroid.org/linux-physical-memory">How much physical memory is installed?</a><span>(toroid.org)</span></div><span class="my_story_list_date">2020-11-29 22:35</span><div class="my_story_list_item_desc">我经常想计算安装在运行Linux的系统中的物理内存的确切数量，今天我终于偶然发现了令人满意的解决方案：在/ sys / devices / system / memory下查看。我知道我已经在该系统中安装了16GB（或者如果您愿意，可以选择GiB）的内存。我一直觉得令free -greport之类的命令只有15GB作......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/物理/">#物理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036693.html">Piuma：可编程集成统一内存架构</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2010.06277">Piuma: Programmable Integrated Unified Memory Architecture</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-11-26 18:21</span><div class="my_story_list_item_desc">下载PDF摘要：高性能大规模图形分析对于及时在大数据集中进行分析至关重要。常规处理器体系结构的资源使用效率低下，并且图工作负载的缩放比例很差。为了实现高效且可扩展的图形分析，英特尔开发了ProgrammableIntegrated统一内存体系结构（PIUMA）。 PIUMA由许多多线程核心，细粒度的内存和网络访问，全......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可编程/">#可编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/piuma/">#piuma</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036250.html">VSCode内存泄漏问题标记为“超出范围”</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/microsoft/vscode/issues/107999">VSCode memory leak issue marked “out-of-scope”</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-24 13:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036250.html"><img src="http://img2.diglog.com/img/2020/11/thumb_4b7d9ecba1881eda1176c27aaa7da297.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我想指出的是，自从我上个月进行测试（几个月前）以来，这似乎是一种回归，因为vscode的泄漏和非泄漏版本都使用相同的电子版本。但是，很抱歉，我没有做笔记，无法真正记住，也没有资源和时间将这种“回归”一分为二。我至少可以说的是，我仍然可以可靠地重现此内存泄漏。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036137.html">量子内存里程碑推动了量子互联网的未来</a></div><div class="item_title_en"><a target="_blank" href="https://spectrum.ieee.org/tech-talk/telecom/internet/milestone-for-quantum-memory-efficiency-makes-quantum-internet-possible">Quantum Memory Milestone Boosts Quantum Internet Future</a><span>(spectrum.ieee.org)</span></div><span class="my_story_list_date">2020-11-24 5:20</span><div class="my_story_list_item_desc">创建帐户</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/量子/">#量子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/quantum/">#quantum</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/创建/">#创建</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035987.html">内存，磁盘，CPU：35年如何改变了权衡</a></div><div class="item_title_en"><a target="_blank" href="https://cartesianproduct.wordpress.com/2020/11/15/updating-the-five-minute-and-the-5-byte-rules/">Memory vs. Disk vs. CPU:  How 35 Years Has Changed the Trade-Offs</a><span>(cartesianproduct.wordpress.com)</span></div><span class="my_story_list_date">2020-11-23 4:49</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035987.html"><img src="http://img2.diglog.com/img/2020/11/thumb_cb2239f4a014a5d570989bf344b77983.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">本文（用于磁盘访问的内存交易的5分钟规则和用于CPU时间的内存交易的5字节规则）研究了1980年代初/中期大型铁数据库系统的内存和磁盘空间的经济性，并得出结论：磁盘空间（然后每千字节大约花费20,000美元）和（易失性）内存（每千字节大约5美元）之间的权衡取舍有利于拥有足够的内存来保持您需要每五分钟访问一次的数据。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/磁盘/">#磁盘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/changed/">#changed</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035817.html">使用jemalloc在Go中手动进行内存管理</a></div><div class="item_title_en"><a target="_blank" href="https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/?repost=1">Manual Memory Management in Go using jemalloc</a><span>(dgraph.io)</span></div><span class="my_story_list_date">2020-11-22 6:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035817.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b245f67c3b3cbeea18876c89a1c8070.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">自2015年成立以来，Dgraph Labs一直是Go语言的用户。五年后，Go代码达到20万行，我们很高兴地报告，我们仍然坚信Go过去并且仍然是正确的选择。我们对Go的兴奋已经超出了构建系统的范围，甚至使我们甚至可以使用Go编写脚本，而这些脚本通常是用Bash或Python编写的。我们发现使用Go可以帮助我们构建干净......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jemalloc/">#jemalloc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035025.html">M1内存和性能</a></div><div class="item_title_en"><a target="_blank" href="https://blog.metaobject.com/2020/11/m1-memory-and-performance.html">M1 Memory and Performance</a><span>(blog.metaobject.com)</span></div><span class="my_story_list_date">2020-11-14 9:4</span><div class="my_story_list_item_desc">M1 Mac现在已经上市了，苹果不仅声称它们绝对是在冒烟，早期的基准测试似乎也证实了这些说法。我并不觉得这令人惊讶，自从Tiger以来，苹果一直高度关注性能，据我所知，从那以后就没有松懈过。M1的一个可能有点令人惊讶的方面是，它只有16G的内存限制。作为一个购买了16千字节的语言卡以在他的苹果上运行Merlin650......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034410.html">ARM内存模型工具：Morello(和一些内存标记)</a></div><div class="item_title_en"><a target="_blank" href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/memory-model-tool-morello-and-some-memory-tagging">ARM Memory Model Tool: Morello (and Some Memory Tagging)</a><span>(community.arm.com)</span></div><span class="my_story_list_date">2020-11-11 5:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034410.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c3c9efae39d7ebcf5fe1d3f84f835c39.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇文章介绍了Morello在内存模型工具中的实现。读者应该对该工具有一些了解，该工具已在前面的文章中介绍：如何使用herd7 Memory Model工具以及如何使用diy7工具自动生成石蕊测试的工作示例。
Morello是ARM开发的基于功能硬件增强型RISC指令(CHERI)的安全架构。更多信息可以在ARM M......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/morello/">#morello</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034386.html">IBM推出7纳米POWER10 CPU</a></div><div class="item_title_en"><a target="_blank" href="https://insidehpc.com/2020/08/ibms-announces-7nm-power10-cpu/">IBM launches 7nm POWER10 CPU</a><span>(insidehpc.com)</span></div><span class="my_story_list_date">2020-11-11 4:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034386.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f13ced149f78b76cda9d92768fa2feb1.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">IBM今天宣布推出新的IBM POWER10 CPU系列，这是该公司与三星合作打造的首个7纳米外形尺寸的平台，专为企业混合云计算而设计，处理器能效、工作负载容量和容器密度都比其前身高出3倍。
通过一项名为Memory Inception的新技术支持数PB内存群集，该技术旨在为SAP、SAS Institute和大型A......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ibm/">#ibm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/power10/">#power10</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034359.html">苹果发布了配备M1的最新Mac Mini，CPU速度提高了3倍，GPU速度提高了6倍，内存高达16 GB，存储容量为2TB，起价699美元</a></div><div class="item_title_en"><a target="_blank" href="https://9to5mac.com/2020/11/10/apple-announces-new-mac-mini-featuring-apple-m1-chip/">Apple announces an updated Mac Mini with M1, giving 3x faster CPU and 6x faster GPU, up to 16GB RAM and 2TB storage, starting at $699</a><span>(9to5mac.com)</span></div><span class="my_story_list_date">2020-11-11 3:0</span><div class="my_story_list_item_desc">苹果公司今天发布了一款采用苹果M1芯片的新Mac mini。苹果公司表示，与上一代Mac mini相比，新芯片的CPU性能提高了3倍，显卡性能提高了6倍。
新的Mac mini采用了相同的工业设计，但由于M1芯片，性能得到了极大的提升。苹果也降低了价格，现在起价为699美元。
苹果公司表示，Mac mini的速度是最......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/速度/">#速度</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034358.html">苹果首次推出搭载M1的13.3英寸MacBook Pro，电池续航时间长达20小时，CPU速度提高2.8倍，ML速度提高11倍，GPU速度提高5倍，内存容量从1,299美元起，最高可达16 GB</a></div><div class="item_title_en"><a target="_blank" href="https://9to5mac.com/2020/11/10/apple-announces-13-inch-macbook-pro-with-faster-performance-thanks-to-m1-chip/">Apple debuts 13.3" MacBook Pro with M1, up to 20 hours battery life, up to 2.8x faster CPU, 11x faster ML, and 5x faster GPU, and up to 16GB RAM, from $1,299</a><span>(9to5mac.com)</span></div><span class="my_story_list_date">2020-11-11 3:0</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034358.html"><img src="http://img2.diglog.com/img/2020/11/thumb_95d8f744f0afb6d711b9929ffe863c9a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">苹果公司今天发布了一款采用苹果M1芯片的13英寸MacBook Pro，取代了之前的英特尔x86机型。苹果保留了这款笔记本1299美元的价位不变。
与之前的13英寸MacBook Pro相比，8核CPU的性能提升了2.8倍。得益于M1芯片的效率，新款MacBook Pro一次充电可提供长达20小时的视频播放，是之前报......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/macbook/">#macbook</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033813.html">充分利用Linux上的英特尔集成GPU</a></div><div class="item_title_en"><a target="_blank" href="http://jason-blog.jlekstrand.net/2020/05/getting-most-out-of-your-intel.html">Getting the most out of your Intel integrated GPU on Linux</a><span>(jason-blog.jlekstrand.net)</span></div><span class="my_story_list_date">2020-11-8 13:27</span><div class="my_story_list_item_desc">大约一年前，我买了一台新笔记本电脑：2019年末的Razer Blade Stealth 13。它配备了英特尔i7-1065G7，配备了英特尔最好的Ice Lake显卡，以及NVIDIA GeForce GTX 1650。除了需要ACPI盖子和这里描述的电源管理问题外，它到目前为止还是一款很棒的笔记本电脑，Linux......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/英特尔/">#英特尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/集成/">#集成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033606.html">使用jemalloc在围棋中进行手动内存管理</a></div><div class="item_title_en"><a target="_blank" href="https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/">Manual Memory Management in Go using jemalloc</a><span>(dgraph.io)</span></div><span class="my_story_list_date">2020-11-7 11:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1033606.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b245f67c3b3cbeea18876c89a1c8070.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Dgraph Labs自2015年成立以来一直是围棋语言的用户。五年来，我们用了20万行围棋代码，我们很高兴地告诉大家，我们仍然坚信围棋是正确的选择，无论是现在还是现在，我们都坚信围棋是正确的选择。我们对围棋的兴奋已经超越了构建系统，甚至让我们用围棋编写了脚本，这些脚本通常是用Bash或Python编写的。我们发现，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jemalloc/">#jemalloc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032431.html">现代Kafka-API存储系统的每核线程缓存管理</a></div><div class="item_title_en"><a target="_blank" href="https://vectorized.io/tpc-buffers/">Thread-per-Core Buffer Management for a Modern Kafka-API Storage System</a><span>(vectorized.io)</span></div><span class="my_story_list_date">2020-10-31 9:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032431.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f84a708f828fff14f092a76e6ba324d4.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">超标量CPU具有宽GB/s内存，NVMe访问时间在10-100微秒量级，这就需要为低延迟存储系统进行新的缓冲区管理。
正如我之前观察到的，软件不是基于类别理论运行的，它运行在超标量CPU上，具有宽的多通道Gb/s存储单元和10-100微秒量级的NVMe固态硬盘访问时间。十年前在不同的硬件平台上编写的一些软件感觉很慢的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/kafka/">#kafka</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032085.html">Gem5中的ARM事务性内存扩展支持</a></div><div class="item_title_en"><a target="_blank" href="https://community.arm.com/developer/research/b/articles/posts/arms-transactional-memory-extension-support-">Arm’s Transactional Memory Extension support in gem5</a><span>(community.arm.com)</span></div><span class="my_story_list_date">2020-10-30 2:0</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032085.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7b3f9021ea7798c4df33855ddbc4f79f.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">2005年，Herb Sutter发表了他的开创性文章“免费午餐结束了”(Sutter，2005)。他概述说，微处理器的顺序性能将很快停滞不前，业界将通过增加内核数量来提供更高性能的处理器作为回应。这种范式转换的结果是从编写软件的纯顺序编程模型转向具有多个执行线程的并发编程模型。当应用程序固有地表现出并行性时，当线程......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/事务性/">#事务性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/事务/">#事务</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031649.html">教程：使用GO进行内存中Git克隆、提交和推送</a></div><div class="item_title_en"><a target="_blank" href="https://ish-ar.io/tutorial-go-git/">Tutorial: In-memory Git clone, commit and push using GO</a><span>(ish-ar.io)</span></div><span class="my_story_list_date">2020-10-28 7:16</span><div class="my_story_list_item_desc">今天的文章是关于如何设置和使用Go-Git库来克隆和更新具有内存文件系统的存储库的教程。如果您希望推送或克隆存储库，而不接触操作系统文件系统并处理权限或临时文件，则此过程非常有用。尽管有关于Git-Go的文档，但我发现由于库的版本和名称不同，所以不是很清楚，有时还会产生误导。基于这个原因，我决定分享这篇教程，希望能对......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031631.html">Linus Torvalds欢呼“历史性的”Linux5.10抛弃了废弃的地址artef</a></div><div class="item_title_en"><a target="_blank" href="https://www.theregister.com/2020/10/25/linux_5_10_rc1/">Linus Torvalds hails 'historic' Linux 5.10 for ditching defunct addressing artef</a><span>(www.theregister.com)</span></div><span class="my_story_list_date">2020-10-28 6:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1031631.html"><img src="http://img2.diglog.com/img/2020/10/thumb_444d759ef07609563082147df13a7e22.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">从286年代开始，内存处理的奇特之处就一直存在于Linux的最初发行版中。
莱纳斯·托瓦尔兹(Linus Torvalds)为世界提供了第一个Linux内核5.10版本的候选版本，并称这是他所称的历史性变化--移除了一个似乎已存在近30年的寻址工具，该工具在10年前引发了一个令人讨厌的漏洞，但后来被芯片制造商裁员。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地址/">#地址</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030601.html">让我们用GPU构建一个高性能的模糊器</a></div><div class="item_title_en"><a target="_blank" href="https://blog.trailofbits.com/2020/10/22/lets-build-a-high-performance-fuzzer-with-gpus/">Let’s build a high-performance fuzzer with GPUs</a><span>(blog.trailofbits.com)</span></div><span class="my_story_list_date">2020-10-23 0:41</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030601.html"><img src="http://img2.diglog.com/img/2020/10/thumb_af62daf8ef2bb0719075fe04e35ad4e0.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">TL；DR：在云中模糊化嵌入式软件时，我们是否可以使用GPU获得10倍的性能/美元？根据我们的初步工作，我们认为答案是肯定的！
模糊是一种软件测试技术，它为程序提供许多随机化的输入，试图导致意想不到的行为。它是一项重要的行业标准技术，负责发现许多安全漏洞并预防更多漏洞。然而，很好地模糊化需要时间，并且模糊化嵌入式软件......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/high/">#high</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029759.html">Linux中的ARM64内存标记扩展</a></div><div class="item_title_en"><a target="_blank" href="https://lwn.net/SubscriberLink/834289/a8f6c7c67ccca2c3/">The Arm64 memory tagging extension in Linux</a><span>(lwn.net)</span></div><span class="my_story_list_date">2020-10-19 17:57</span><div class="my_story_list_item_desc">LWN订户已向您提供以下仅限订阅的内容。数以千计的用户依赖LWN获取来自Linux和自由软件社区的最好消息。如果您喜欢这篇文章，请考虑接受右边的试用报价。感谢您访问LWN.net！
免费试用LWN 1个月：无需付款或信用卡。现在激活您的试用订阅，看看为什么成千上万的读者订阅LWN.net。
5.10内核开发周期合并的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lwn/">#lwn</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/内存/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/内存/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>