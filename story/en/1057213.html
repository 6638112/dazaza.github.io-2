<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>没有码头的码头 Docker Without Docker</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Docker Without Docker<br/>没有码头的码头 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 12:11:11</div><div class="page_narrow text-break page_content"><p>We’re Fly.io. We take container images and run them on our hardware around the world. It’s pretty neat, and you  should check it out; with an already-working Docker container, you can be up and running on Fly in well under 10 minutes.</p><p>我们是fly.io.我们采取集装箱图像并在世界各地的硬件上运行它们。它很整洁，你应该看看;使用已有工作的Docker容器，您可以在10分钟内运行。</p><p>  Even though most of our users deliver software to us as Docker containers, we don’t use Docker to run them. Docker is great, but we’re high-density multitenant, and despite strides, Docker’s isolation isn’t strong enough for that. So, instead, we transmogrify container images into  Firecracker micro-VMs.</p><p>  尽管我们的大多数用户将软件传递给我们作为Docker容器，但我们不使用Docker运行它们。 Docker是很棒的，但我们是高密度的多助词，尽管步幅，Docker的隔离不够强大。因此，我们将容器图像转移到鞭炮微VM中。</p><p>     They do their best to make it look a lot more complicated, but OCI images — OCI is  the standardized container format used by Docker — are pretty simple. An OCI image is just a stack of tarballs.</p><p>     他们尽最大努力使它看起来更加复杂，但OCI图像 -  OCI是Docker使用的标准化容器格式 - 非常简单。 OCI图像只是一堆塔尔巴尔。</p><p>  Backing up: most people build images from Dockerfiles. A useful way to look at a Dockerfile is as a series of shell commands, each generating a tarball; we call these “layers”. To rehydrate a container from its image, we just start the the first layer and unpack one on top of the next.</p><p>  备份：大多数人从Dockerfiles构建图像。查看Dockerfile的有用方法是作为一系列shell命令，每个都会产生一个tarball;我们称之为这些“层”。为了将容器从其图像中水进行再水化，我们刚刚启动第一层并在下一个顶部打开一个。</p><p>  You can write a shell script to pull a Docker container from its registry, and that might clarify. Start with some configuration; by default, we’ll grab the base image for  golang:</p><p>  您可以编写一个shell脚本来从其注册表中提取Docker容器，这可能会澄清。从某种配置开始;默认情况下，我们将抓住Golang的基础图像：</p><p>   We need to authenticate to pull public images from a Docker registry – this is boring but relevant to the next section – and that’s easy:</p><p>   我们需要进行身份验证以从Docker注册表中取出公共图像 - 这是无聊但与下一节相关 - 这很简单：</p><p>   That token will allow us to grab the “manifest” for the container, which is a JSON index of the parts of a container.</p><p>   该令牌将允许我们抓住容器的“清单”，这是容器部分的JSON指数。 </p><p>  function manifest  {  token = &#34; $1 &#34; image = &#34; $2 &#34; digest = &#34; ${ 3 :- latest } &#34;curl  -fsSL  \  -H  &#34;Authorization: Bearer  $token &#34;  \  -H  &#39;Accept: application/vnd.docker.distribution.manifest.list.v2+json&#39;  \  -H  &#39;Accept: application/vnd.docker.distribution.manifest.v1+json&#39;  \  -H  &#39;Accept: application/vnd.docker.distribution.manifest.v2+json&#39;  \  &#34; ${ registry_url } /v2/library/ ${ image } /manifests/ ${ digest } &#34; }</p><p>函数幻帆{token =＆＃34; 1美元＆＃34;图像=＆＃34; $ 2＆＃34; DIGEST =＆＃34; $ {3： - 最新}＆＃34; curl -fssl \ -h＆＃34;授权：持票人$令牌＆＃34; \ -h＆＃39;接受：application / vnd.docker.distribution.manifest.list.v2 + Json＆＃39; \ -h＆＃39;接受：application / vnd.docker.distribution.manifest.v1 + JSON＆＃39; \ -h＆＃39;接受：application / vnd.docker.distribution.manifest.v2 + JSON＆＃39; \＆＃34; $ {registry_url} / v2 / library / $ {image} / manifests / $ {digest}＆＃34; }</p><p> The first query we make gives us the “manifest list”, which gives us pointers to images for each supported architecture:</p><p> 我们制作的第一个查询为我们提供了“清单列表”，这使我们指向每个受支持的架构的图像：</p><p>   Pull the  digest out of the matching architecture entry and perform the same fetch again with it as an argument, and we get the manifest: JSON pointers to each of the layer tarballs:</p><p>   将摘要从匹配的架构条目中拉出，并将其再次执行相同的获取作为参数，我们得到了清单：json指针到每个图层tarballs：</p><p>   It’s as easy to grab the actual data associated with these entries as you’d hope:</p><p>   抓取与这些条目相关的实际数据如您希望的实际数据很容易：</p><p>     function layers  {  echo  &#34; $1 &#34; | jq  --raw-output  &#39;.layers[].digest&#39; } token = $(auth_token  &#34; $image &#34; ) amd64 = $(linux_version  $(manifest  &#34; $token &#34;  &#34; $image &#34; )) mf = $(manifest  &#34; $token &#34;  &#34; $image &#34;  &#34; $amd64 &#34; ) i =0 for L  in  $(layers  &#34; $mf &#34; ) ;  doblob  &#34; $token &#34;  &#34; $image &#34;  &#34; $L &#34;  &#34;layer_ ${ i } .tgz&#34; i = $((i  +  1  )) done</p><p>     功能图层{echo＆＃34; 1美元＆＃34; | JQ  - 输出＆＃39; .Layers []。摘要＆＃39; }令牌= $（auth_token＆＃34; $ image＆＃34;）amd64 = $（linux_version $（manifest＆＃34; $令牌＆＃34;＆＃34; $ image＆＃34;）mf = $ （明文＆＃34; $令牌＆＃34;＆＃34; $ image＆＃34;＆＃34; $ amd64＆＃34;）i = 0以$（图层＆＃34; $ mf＆＃34; $ mf＆＃ 34;）; Doblob＆＃34; $令牌＆＃34; ＆＃34; $图片＆＃34; ＆＃34; $ l＆＃34; ＆＃34; layer_ $ {i} .tgz＆＃34;我= $（（i + 1））完成</p><p> Unpack the tarballs in order and you’ve got the filesystem layout the container expects to run in. Pull the “config” JSON and you’ve got the entrypoint to run for the container; you could, I guess, pull and run a Docker container with nothing but a shell script, which I’m probably the  1,000th person to point out. At any rate,  here’s the whole thing.</p><p> 按顺序解压缩Tarballs，您已有文件系统布局容器期望运行。拉动“Config”JSON，并且您已获得用于容器的entrypoint;我猜，你可以拉扯和运行一个码头容器，除了一个壳牌脚本，我可能是1,000人指出的人。无论如何，这是整件事。</p><p>    You’re likely of one of two mindsets about this: (1) that it’s extremely Unixy and thus excellent, or (2) that it’s extremely Unixy and thus horrifying.</p><p>    你可能是一个关于这个的两种心态之一：（1）这是非常愚蠢的，因此非常好，或者（2）这是非常愚蠢的，因此可怕。 </p><p>  Unix  tar is problematic. Summing up  Aleksa Sarai:  tar isn’t well standardized, can be unpredictable, and is bad at random access and incremental updates. Tiny changes to large files between layers pointlessly duplicate those files; the poor job  tar does managing container storage is part of why people burn so much time optimizing container image sizes.</p><p>UNIX TAR是有问题的。总结Aleksa Sarai：Tar并不充分标准化，可能是不可预测的，并且在随机访问和增量更新时不好。在图层之间的大文件的变化无意中复制这些文件;糟糕的作业tar管理容器存储是人们燃烧这么多时间优化容器图像大小的一部分。</p><p>  Another fun detail is that OCI containers share a security footgun with git repositories: it’s easy to accidentally build a secret into a public container, and then inadvertently hide it with an update in a later image.</p><p>  另一个有趣的细节是OCI容器与Git存储库共享一个安全性脚步：很容易意外构建一个秘密，然后在稍后的图像中无意中隐藏它。</p><p> We’re of a third mindset regarding OCI images, which is that they are horrifying, and that’s liberating. They work pretty well in practice! Look how far they’ve taken us! Relax and make crappier designs; they’re all you probably need.</p><p> 我们是关于OCI图像的第三个心态，这是他们令人恐惧，这是解放。他们在练习中很好地工作！看看他们带来了多远！放松并制作疯狂的设计;他们是你可能需要的。</p><p>     Back to Fly.io. Our users need to give us OCI containers, so that we can unpack and run them. There’s standard Docker tooling to do that, and we use it: we host a  Docker registry our users push to.</p><p>     回到fly.io.我们的用户需要为我们提供OCI容器，以便我们可以解压缩并运行它们。有标准的Docker工具做到这一点，我们使用它：我们托管Docker注册表我们的用户推送。</p><p>  Running an instance of the Docker registry is very easy. You can do it right now;  docker pull registry &amp;&amp; docker run registry. But our needs are a little more complicated than the standard Docker registry: we need multi-tenancy, and authorization that wraps around our API. This turns out not to be hard, and we can walk you through it.</p><p>  运行Docker注册表的实例非常容易。你现在可以做到这一点; Docker Lift Registry＆amp;＆amp; Docker运行注册表。但是我们的需求比标准的Docker注册表更复杂：我们需要多租赁，并授权围绕我们的API。这结果并不难，我们可以走过它。</p><p>  A thing to know off the bat: our users drive Fly.io with a command line utility called  flyctl.  flyctl is a Go program (with  public source) that runs on Linux, macOS, and Windows. A nice thing about working in Go in a container environment is that the whole ecosystem is built in the same language, and you can get a lot of stuff working quickly just by importing it. So, for instance, we can drive our Docker repository clientside from  flyctl just by calling into Docker’s clientside library.</p><p>  要了解蝙蝠的事物：我们的用户使用名为Flyctl的命令行实用程序驾驶Fly.io。 Flyctl是一个在Linux，MacoS和Windows上运行的Go程序（具有公共来源）。在集装箱环境中工作的一件好事是整个生态系统以相同的语言建立，你可以通过导入它来快速工作。因此，例如，我们可以通过调用Docker的客户端库从Flyctl驱动我们的Docker存储库客户端。</p><p>  If you&#39;re building your own platform and you have the means, I highly recommend the CLI-first tack we took. It is so choice.  flyctl made it very easy to add new features, like  databases,  private networks,  volumes, and our  bonkers SSH access system.</p><p>  如果你＆＃39;重新建立自己的平台，你有手段，我强烈推荐我们采取的Cli-First Tack。它是如此选择。 Flyctl使添加新功能，如数据库，专用网络，卷和我们的Bonkers SSH访问系统非常容易。 </p><p> On the serverside, we started out simple: we ran an instance of the standard Docker registry with an authorizing proxy in front of it.  flyctl manages a bearer token and uses the Docker APIs to initiate Docker pushes that pass that token; the token authorizes repositories serverside using calls into our API.</p><p>在Serversife上，我们开始简单：我们用它的授权代理运行标准Docker注册表的实例。 Flyctl管理持票人令牌，并使用Docker API启动Docker推送该令牌的推动;令牌授权使用调用进入我们的API的存储库服务器。</p><p>  What we do now isn’t much more complicated than that. Instead of running a vanilla Docker registry, we built a custom repository server. As with the client, we get a Docker registry implementation just by importing Docker’s registry code as a Go dependency.</p><p>  我们现在所做的并不比这更复杂。我们构建了一个自定义存储库服务器而不是运行vanilla docker注册表。与客户一样，我们只需将Docker的注册码作为Go依赖项导入Docker的注册码即可获得Docker注册表实现。</p><p>  We’ve extracted and simplified some of the Go code we used to build this here, just in case anyone wants to play around with the same idea. This isn’t our production code (in particular, all the actual authentication is ripped out), but it’s not far from it, and as you can see, there’s not much to it.</p><p>  我们已经提取并简化了我们在此处建立的一些GO代码，以防任何人想要与同样的想法一起游戏。这不是我们的生产代码（特别是，所有实际身份验证都被删除），但它离IT不远，就像你可以看到的那样，它没有太多的。</p><p>  Our custom server isn’t architecturally that different from the vanilla registry/proxy system we had before. We wrap the Docker registry API handlers with authorizer middleware that checks tokens, references, and rewrites repository names. There are some very minor gotchas:</p><p>  我们的自定义服务器不与我们之前的vanilla注册表/代理系统不同的架构。我们将Docker Registry API处理程序用授权器中间件检查令牌，引用和重写存储库名称。有一些非常少数的托克斯：</p><p>  Docker is content-addressed, with blobs “named” for their SHA256 hashes, and attempts to reuse blobs shared between different repositories. You need to catch those cross-repository mounts and rewrite them.</p><p>  Docker是满足的，对于他们的SHA256哈希，并尝试重用不同存储库之间共享的Blobs的“命名为”。您需要捕获这些交叉存储库安装架并重写它们。</p><p> Docker’s registry code generates URLs with  _state parameters that embed references to repositories; those need to get rewritten too.  _state is HMAC-tagged; our code just shares the HMAC key between the registry and the authorizer.</p><p> Docker的注册表代码生成带有_state参数的URL，用于嵌入对存储库的引用;那些需要改写。 _State是HMAC标记的;我们的代码只在注册表和授权器之间共享HMAC密钥。</p><p>  In both cases, the source of truth for who has which repositories and where is the database that backs our API server. Your push carries a bearer token that we resolve to an organization ID, and the name of the repository you’re pushing to, and, well, our design is what you’d probably come up with to make that work. I suppose my point here is that it’s pretty easy to slide into the Docker ecosystem.</p><p>  在这两种情况下，谁有谁有储存库以及返回我们API服务器的数据库在哪里。您的推送载有持票人令牌，我们解析为组织ID，以及您推动的存储库的名称，以及我们的设计是您可能会提出的才能提出这项工作。我想我的意思是，它很容易滑入Docker生态系统。 </p><p>       What we need to do now is arrange those pieces so that we can run containers as Firecracker VMs.</p><p>我们现在需要做的是安排这些棋子，以便我们可以将容器运行为鞭炮VM。</p><p>  As far as we&#39;re concerned, a container image is just a stack of tarballs and a blob of configuration (we layer additional configuration in as well). The tarballs expand to a directory tree for the VM to run in, and the configuration tells us what binary in that filesystem to run when the VM starts.</p><p>  据我们＆＃39;重新关注，容器图像只是一堆tarballs和一堆配置（我们也在层上附加配置）。 tarballs展开到VM运行的VM目录树，并且配置告诉我们该文件系统中的二进制文件以在VM启动时运行。</p><p>  Meanwhile, what Firecracker wants is a set of block devices that Linux will mount as it boots up.</p><p>  同时，鞭炮想要的是一组块设备，即Linux将在靴子上安装。</p><p>  There&#39;s an easy way on Linux to take a directory tree and turn it into a block device: create a file-backed  loop device, and copy the directory tree into it. And that&#39;s how we used to do things. When our orchestrator asked to boot up a VM on one of our servers, we would:</p><p>  在Linux上有一个简单的方法来拍摄目录树并将其转换为块设备：创建一个文件备份的循环设备，并将目录树复制到其中。那个＆＃39;我们如何努力做事。当我们的Orchestrator要求在我们的一个服务器上启动VM时，我们会：</p><p>  Unpack the container (in this case, using Docker&#39;s Go libraries) into the mounted loop device.</p><p>  打开容器（在这种情况下，使用Docker＆＃39; s go库）进入安装的循环设备。</p><p> Create a second block device and inject our init, kernel, configuration, and other goop into.</p><p> 创建第二个块设备并注入我们的init，内核，配置和其他goop。</p><p> Track down any  persistent volumes attached to the application, unlock them with LUKS, and collect their unlocked block devices.</p><p> 追踪附加到应用程序的任何持久卷，用luks解锁它们，并收集其解锁块设备。 </p><p> Create a  TAP device, configure it for our network, and  attach BPF code to it.</p><p>创建一个点击设备，为我们的网络配置它，并将BPF代码附加到它。</p><p>    This system worked, but wasn&#39;t especially fast. Part of  the point of Firecracker is to boot so quickly that you (or AWS) can host Lambda functions in it and not just long-running programs. A big problem for us was caching; a server in, say, Dallas that&#39;s asked to run a VM for a customer is very likely to be asked to run more instances of that server (Fly.io apps scale trivially; if you&#39;ve got 1 of something running and would be happier with 10 of them, you just run  flyctl scale count 10). We did some caching to try to make this faster, but it was of dubious effectiveness.</p><p>    这个系统工作，但尚未诞生。 Firecracker的一部分是为了播放您（或AWS）可以在其中托管Lambda函数而不是长时间运行的程序启动。我们的大问题是缓存;一个服务器，例如，达拉斯＆＃39; s要求为客户运行一个VM，很可能被要求提供更多该服务器的实例（Fly.io应用程序规模琐碎;如果你＆＃39; ve得到了1个运行的东西，并将与其中10个更快乐，您只需运行Flyctl Scale 10）。我们尽一点缓存试图使这种更快，但它具有可疑的效果。</p><p>  The system we&#39;d been running was, as far as container filesystems are concerned, not a whole lot more sophisticated than the shell script at the top of this post. So Jerome replaced it.</p><p>  与集装件文件系统所关注的情况，我们正在运行的系统，而不是这篇文章顶部的shell脚本更复杂。所以杰罗姆取代了它。</p><p>  What we do now is run, on each of our servers, an instance of   containerd.  containerd does a whole bunch of stuff, but we use it as as a cache.</p><p>  我们现在所做的是，在我们的每一个服务器上运行，一个容器的一个实例。 Containerd做了一堆东西，但我们用它作为缓存。</p><p>  If you&#39;re a Unix person from the 1990s like I am, and you just recently started paying attention to how Linux storage works again, you&#39;ve probably noticed that  a lot has changed. Sometime over the last 20 years, the block device layer in Linux got interesting. LVM2 can pool raw block devices and create synthetic block devices on top of them. It can treat block device sizes as an abstraction, chopping a 1TB block device into 1,000 5GB synthetic devices (so long as you don&#39;t actually use 5GB on all those devices!). And it can create snapshots, preserving the blocks on a device in another synthetic device, and sharing those blocks among related devices with copy-on-write semantics.</p><p>  如果你和20世纪90年代的UNIX人物，就像我一样，你最近就开始关注Linux存储如何再次运作，你可能注意到很多改变了很多。在过去20年的某个时间，Linux中的块设备层很有意思。 LVM2可以池池原始块设备，并在其中创建合成块设备。它可以将块设备尺寸视为抽象，将1TB块设备切成1,000个5GB的合成器件（只要您在所有这些设备上实际使用5GB）。它可以创建快照，在另一个合成设备中保留设备上的块，并在具有编写复制的语义中与相关设备共享这些块。</p><p>  containerd knows how to drive all this LVM2 stuff, and while I guess it&#39;s out of fashion to use the  devmapper backend these days, it works beautifully for our purposes. So now, to get an image, we pull it from the registry into our server-local  containerd, configured to run on an LVM2 thin pool.  containerd manages snapshots for every instance of a VM/container that we run. Its API provides a simple &#34;lease&#34;-based garbage collection scheme; when we boot a VM, we take out a lease on a container snapshot (which synthesizes a new block device based on the image, which containerd unpacks for us); LVM2 COW means multiple containers don&#39;t step on each other. When a VM terminates, we surrender the lease, and containerd eventually GCs.</p><p>  Containerd知道如何推动所有这些LVM2的东西，而虽然我猜它的＆＃39;在现在使用DevMapper后端使用DevMapper，它适用于我们的目的。所以现在，要获取图像，我们将其从注册表中拉到我们的服务器本地Containerd，配置为在LVM2薄池上运行。 ContainTD管理我们运行的VM /容器的每个实例的快照。它的API提供了一个简单的＆＃34;租赁＆＃34;基于垃圾收集计划;当我们引导VM时，我们在集装箱快照上租赁租赁（基于图像合成新的块设备，其中包含我们的Containerd Unpacks）; LVM2母牛意味着多个容器彼此互相跳跃＆＃39;当VM终止时，我们会投降租约，最终会租约。</p><p>  The first deployment of a VM/container on one of our servers does some lifting, but subsequent deployments are lightning fast (the VM build-and-boot process on a second deployment is faster than the logging that we do).</p><p>  我们的一个服务器上的VM /容器的第一次部署有一些提升，但随后的部署快速闪电（第二部部署的VM Build-and-Boot进程比我们所做的日志更快）。 </p><p>    Jerome wrote our  init in Rust, and, after being cajoled by Josh Triplett,  we released the code, which you can go read.</p><p>Jerome在Rust中写了我们的init，而且，在Josh Triplett的Cajoled之后，我们发布了您可以阅读的代码。</p><p>  The filesystem that Firecracker is mounting on the snapshot checkout we create is pretty raw. The first job our  init has is to fill in the blanks to fully populate the root filesystem with the mounts that Linux needs to run normal programs.</p><p>  闪光灯在快照结账上安装的文件系统，我们创建非常原始。我们init的第一份职位是填写空白，以完全填充根文件系统，其中Linux需要运行正常程序。</p><p>  We inject a configuration file into each VM that carries the user, network, and entrypoint information needed to run the image.  init reads that and configures the system. We use our own DNS server for private networking, so  init overrides  resolv.conf. We run a tiny SSH server for user logins over WireGuard;  init spawns and monitors that process. We spawn and monitor the entry point program. That’s it; that’s an init.</p><p>  我们将配置文件注入携带用户，网络和运行图像所需的入口信息的每个VM中。 init读取它并配置系统。我们使用自己的DNS服务器进行私人网络，因此Init覆盖Resolv.conf。我们为Uriguard的用户登录运行一个小小的SSH服务器; Init Spawns和监视该过程。我们产卵并监控入口点计划。就是这样;这是初步。</p><p>   So, that&#39;s about half the idea behind Fly.io. We run server hardware in racks around the world; those servers are tied together with an orchestration system that plugs into our API. Our CLI,  flyctl, uses Docker&#39;s tooling to push OCI images to us. Our orchestration system sends messages to servers to convert those OCI images to VMs. It&#39;s all pretty neato, but I hope also kind of easy to get your head wrapped around.</p><p>   所以，＆＃39;大约是飞蝇背后的一半想法。我们在世界各地的机架中运行服务器硬件;这些服务器与插入我们API的编排系统一起绑定。我们的CLI，Flyctl，使用Docker＆＃39;工具将OCI图像推向我们。我们的编排系统向服务器发送消息以将那些OCI图像转换为VM。它＆＃39;所有漂亮的neato，但我希望也有点容易让你的头包裹着。</p><p>  The other &#34;half&#34; of Fly is our Anycast network, which is a CDN built in Rust that uses BGP4 Anycast routing to direct traffic to the nearest instance of your application. About which: more later.</p><p>  另一个＆＃34;半＆＃34;飞行是我们的任何Accast网络，它是一个内置生锈的CDN，它使用BGP4 yourcast路由将流量直接到最近的应用程序实例。关于哪个：更稍后。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fly.io/blog/docker-without-docker/">https://fly.io/blog/docker-without-docker/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/码头/">#码头</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>