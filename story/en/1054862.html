<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一个“更好的C”基准 A “Better C” Benchmark</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A “Better C” Benchmark<br/>一个“更好的C”基准 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-28 18:14:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/3cd67f8c773c5df13d60d9d2e7f8918c.png"><img src="http://img2.diglog.com/img/2021/3/3cd67f8c773c5df13d60d9d2e7f8918c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>C is almost 50 years old. A great age for a bottle of wine, not so great for a programming language in the fast-moving industry. Over the past 10 years many new languages have emerged, with different flavours, all trying to become a C replacement to some extent.</p><p>C差不多50岁。一瓶葡萄酒的一个伟大的年龄，在快速移动行业中的编程语言不太伟大。在过去的10年里，许多新语言已经出现了不同的口味，所有人都试图在一定程度上成为C替代品。</p><p> When a new language becomes more or less popular – developers start writing benchmarks, showing how performant the software in this language is, how much CPU power and how much memory is uses, how big are the binaries and so on.</p><p> 当新语言变得或多或少受欢迎的流行开发人员开始编写基准时，显示这种语言中的软件是多么表现，CPU功率和多少内存是多少，二进制文件有多大。</p><p> Here I would like to carry a little experiment in a different plane - UX of the programming languages, how  productive the developer is when using this or that language, how easy it is to use them, what common frustrations there are, how people feel when they read the code. I believe that UX of the programming language is as important as their technical characteristics and it contributes a lot to a success of a language.</p><p> 在这里，我想在不同的飞机上进行一点实验 -  UX的编程语言，开发人员的效率如何是使用这个或那种语言，使用它们是多么容易，有什么常见的挫折，人们如何感受他们读了代码。我认为，编程语言的UX与他们的技术特征一样重要，并且它有很大贡献了一种语言的成功。</p><p>   Let’s write an app that scans all files recursively in the current directory and prints those lines in the files that match a given wildcard. Something like  ag or  grep, but using wildcards rather than regular expressions. Binary files should be ignored.</p><p>   让我们写一个应用程序，该应用程序在当前目录中递归递归播放，并在与给定通配符匹配的文件中打印这些行。像AG或Grep这样的东西，但使用通配符而不是正则表达式。应该忽略二进制文件。</p><p> I find this problem to be a good exercise, because it shows how to implement a very simple wildcard matching algorithm (which works with pure data such as strings and numbers, no need to learn any libraries or APIs). This algorithm should pass a few very simple tests. Then it requires some very common, yet low-level APIs, such as scanning the directory recursively or reading files line by line. All parts of the problem are very simple, small and well-scoped. I assumed that such utility should be easy to implement in any language, even if there was no previous experience with it.</p><p> 我发现这个问题是一个很好的练习，因为它显示了如何实现一个非常简单的通配符匹配算法（它适用于纯数据，如字符串和数字，无需学习任何库或API）。该算法应通过一些非常简单的测试。然后它需要一些非常常见的，但低级的API，例如递归扫描目录或按行读取文件行。问题的所有部分都非常简单，小而且很好。我认为，即使没有以前的经验，这种实用程序应该容易地实施任何语言。</p><p> I wanted to test how “friendly” the language is to a regular “write-compile-run-debug” loop, how easy it is to write tests for the matching algorithm, how easy it is to find required APIs to work with the file system and basic I/O, how friendly is the compiler when pointing out errors, how “intuitive” is the language and so on.</p><p> 我想测试如何“友好”的语言是常规的“写入编译运行调试”循环，为匹配算法编写测试是多么容易，您可以在查找所需的API与文件一起使用的情况系统和基本I / O，编译器指出错误时有多么友好，如何“直观”是语言等。</p><p> My sample size was rather humble - just myself. But to avoid bias you are encouraged to do the same on your own (it should not take too long) and compare the results. After the utility has been written in different languages – I asked my peer developers (~20 people) to read it and tell what it does, what lines are unclear, what feels “easier” to read and to understand. These developers had no experience with either of the languages, but have been coding a lot in other languages, such as Java, C#, JavaScript, Kotlin, Swift etc.</p><p> 我的样本大小相当谦虚 - 只是我自己。但是为了避免偏见，鼓励你自己做同样的（它不应该花太长）并比较结果。在用不同语言写作的实用程序之后 - 我问我的同行开发人员（〜20人）阅读并告诉它所做的事情，哪条线尚不清楚，读取和理解的是什么“更容易”。这些开发人员没有任何语言的经验，但是已经在其他语言中编码了很多，例如Java，C＃，JavaScript，Kotlin，Swift等。 </p><p> The languages I tested here are C++, Go, Rust and Zig. The resulting programs I got are available at  github.com/zserge/glob-grep, feel free to criticise.</p><p>这里测试的语言是C ++，Go，Rust和Zig。我获得的结果是在Github.com/zserge/Glob-Grep上获得的，随时批评。</p><p>  It all started because I wanted to see what kind of a language Zig is. I never used it, but heard some good feedback. With no previous experience I opened vim and started coding.</p><p>  这一切都开始了，因为我想看看什么样的语言之曲。我从未使用过它，但听到了一些良好的反馈。没有以前的经验，我打开了Vim并开始编码。</p><p> It took me ~1 hour to finish the program. The wildcard matching algorithm (which I knew before, and only had to implement in Zig) took me ~20 minutes. The rest was looking for the APIs to do the directory scanning and the file reading.</p><p> 完成该计划需要我〜1小时。通配符匹配算法（我以前知道，并且只有在Zig中只能实施）花了我〜20分钟。其余的正在寻找API来执行目录扫描和文件读取。</p><p>  What I liked: the language is surprisingly intuitive to a C coder. Feels very simple, the documentation about the  language (but not the stdlib) is very clear and friendly.</p><p>  我喜欢的是什么：语言对C编码者令人惊讶的是直观。感觉非常简单，关于语言的文档（但不是STDLIB）非常清晰友好。</p><p> Vim integration was also pretty good, for a young language (before I enabled vim plugin - I was annoyed with formatting errors, which are compiler errors).</p><p> Vim Integation也非常好，对于一种年轻的语言（在我启用了Vim插件之前 - 我对格式化错误感到恼火，这是编译错误的错误）。</p><p> I liked the error handling approach. Liked that test harness comes with the language. Even liked that strings are just the arrays of bytes, like in C.</p><p> 我喜欢错误处理方法。喜欢测试线束附带语言。甚至喜欢字符串只是字节数，就像在C.中一样</p><p> My first reaction to carrying the allocator around was a shock, but in practice it was not even noticeable. It gives a feel of minimalism that the core of the language is so simple that it does not even use dynamic memory. Again, very close to C.</p><p> 我对携带分配者周围的第一次反应是一个震惊，但实际上它甚至不明显。它给出了一种极简主义，即语言的核心如此简单，甚至没有使用动态内存。再次，非常接近C. </p><p> I had to read lot of the Zig compiler and stdlib sources while writing this, and the code was very clear and concise.</p><p>我不得不在写这篇文章时阅读很多Zig编译器和stdlib源，并且代码非常清晰简洁。</p><p> What I disliked: the stdlib documentation is terrible. Everything I learned about directory scanning and file I/O – I got from github search results, which are also pretty scarce.</p><p> 我不喜欢的是：stdlib文件是可怕的。我从目录扫描和文件I / O学到的一切 - 我从Github搜索结果中获得，这也是非常稀缺的。</p><p> Compiler messages are also far from being friendly, but to the one who is familiar with C it’s not a big deal.</p><p> 编译器消息也远非友好，而是熟悉C的人并不是一项大问题。</p><p> The lack of string handling routines in the stdlib was unexpected, to concatenate strings one has to do everything manually - allocate the buffer, put strings there. Or use formatter and an allocator to print both strings side by side and free the buffer afterwards. It’s still very different from  s1+s2.</p><p> 在stdlib中缺少字符串处理例程是意外的，要使串行串一个人必须手动执行所有操作 - 分配缓冲区，将字符串放在那里。或使用格式化器和分配器以并排打印两个字符串并之后释放缓冲区。与S1 + S2仍然非常不同。</p><p> Overall, the core language is simple and I enjoyed it, but the stdlib is even more limited than libc. I hope that this is just a sign of an early age of the language.</p><p> 总的来说，核心语言很简单，我喜欢它，但STDLIB比LIBC更受限制。我希望这只是语言的早期时代的标志。</p><p> People who read the resulting Zig code actually mentioned that is was the one that made them realise what the program does. It is a bit verbose, but explicit, predictable and easy to understand. Not surprising, as the language was designed with readability in mind (no hidden control flow, no hidden allocations, no macros, no operator overloading, no metaprogramming etc).</p><p> 读取生成的Zig代码的人实际上提到了这是一个让他们实现程序所做的内容。这有点冗长，但明确，可预测和易于理解。并不令人惊讶，因为语言是以可读性的设计（没有隐藏的控制流，没有隐藏的分配，没有宏，没有运算符重载，没有成分谱图等）。</p><p>  I had a few failed attempts to learn Rust. It took me over 2 hours to finish this program and I felt frustrated after I finished.</p><p>  我有一些失败的尝试试图学习生锈。完成这个程序需要我超过2个小时，在完成后，我感到沮丧。 </p><p>  What I liked: the compiler messages are nice. The documentation to the language is also good. But that’s probably it. At least I didn’t have to fight too much with lifetime errors this time. The tooling around the language is modern and nice.</p><p>我喜欢什么：编译器消息很好。语言的文档也很好。但那可能是它。至少我这次没有终生错误的终身错误。语言周围的工具是现代而漂亮的。</p><p> What I disliked: compiler messages are too verbose and take the whole screen. No, I don’t want to run  rustc --explain for every mistake. Please, don’t punish me. Documentation is also sometimes too verbose. I mean, it’s better have more docs than less, but having a TLDR version first would be even better. Same for stdlib, having a brief list of functions and what they do in one sentence would be easier to skim through as a reader. Having  &amp;str,  Str and  [u8] in obviously necessary, but surprises a newcomer.</p><p> 我不喜欢的是：编译器消息太冗长并拍摄整个屏幕。不，我不想为每一个错误运行rustc  - 索引。拜托，不要惩罚我。文档有时也太冗长了。我的意思是，它更好地拥有更多的文档，但首先拥有TLDR版本会更好。对于stdlib来说，具有简短的功能列表以及他们在一句话中所做的事情将更容易浏览作为读者。在明显的必要时，＆amp; str，str和[u8]明显，但为新人感到惊讶。</p><p> Overall, coding in Rust feels like puzzle solving to me. Could be fun and exciting, especially when using Rust as a hobby language, but for most tasks I would rather prefer an “ergonomic” language that would be a barely noticeable tool.</p><p> 总的来说，在锈病中编码感觉像拼图解决我。可能很有趣和令人兴奋，特别是在用生锈作为爱好语言时，但对于大多数任务来说，我宁愿更喜欢“符合人体工程学”的语言，这是一个勉强明显的工具。</p><p> People who read the resulting Rust code often raise at least a couple of “wtf” questions in process. They often complain the syntax is unclear and requires paying attention to details. Also, pattern matching is still an unfamiliar thing to the “mainstream” developers.</p><p> 阅读所产生的生锈代码的人经​​常在过程中培养至少几个“WTF”问题。他们经常抱怨语法尚不清楚，需要注意细节。此外，模式匹配仍然是“主流”开发人员的不熟悉的事情。</p><p>  This was cheating. I obviously had some previous experience with Go, but nevertheless I wanted to try it in this experiment. It took me ~15 minutes to make my complete “glob” utility work, just as I expected.</p><p>  这是作弊。我显然有一些以前的经历，但我想在这个实验中尝试。我花了〜15分钟来制作完整的“glob”实用程序，就像我预期的那样。</p><p>  What I liked: it feels very productive, docs are amazing to my taste - brief, but useful, one can immediately open the related stdlib function sources and investigate further. From the past experience, while writing the app I already envisioned how to make it multithreaded and boost the performance (simple fan-out).</p><p>  我喜欢的是什么：感觉非常富有成效，Docs对我的口味令人惊叹 - 简要介绍，但有用，可以立即打开相关的STDLIB函数来源并进一步调查。从过去的经验中，在编写应用程序时，我已经设想了如何使其多线程并提高性能（简单的粉丝）。</p><p> What I disliked: too many things are under the hood (buffered I/O, GC). You don’t feel like you are in control of everything (like in Zig). Too opinionated – this was the only language on the list that required me to create 3 separate files to make it work. It is still possible to make silly mistakes, like accidental variable shadowing, or using defer inside a loop.</p><p> 我不喜欢的是：太多的东西都在引擎盖下（缓冲I / O，GC）。你不觉得你控制着一切（如Zig）。太为自以为是 - 这是列表中唯一需要我创建3个单独文件以使其工作的语言。仍然可以使愚蠢的错误，如意外变色的阴影，或者在循环内使用Defer。 </p><p> People who read the resulting Go code found it clear, some wondered about the inline walker function (which does not have to be inline, they were right). Some wondered about the multiple assignment, i.e.  a, b = c, d, which also was not needed there and made things more confusing. Ironically, if I was new to Go - I would have written even more straightforward Go code.</p><p>阅读结果的Go代码的人发现它清楚，有些人想知道内联的Walker函数（不必加内联，他们是对的）。有些人想知道多个分配，即a，b = c，d，它也不需要那里并使事情变得更加困惑。具有讽刺意味的是，如果我是新的去 - 我会写得更加简单的去代码。</p><p>  Although I have some C experience, I am rather distant from the modern C++, so I decided to give it a try. It took me ~20 minutes to finish, and that was unexpected.</p><p>  虽然我有一些c体验，但我与现代c ++相比，我决定试一试。花了我〜20分钟完成，这是出乎意料的。</p><p>  What I liked: feels familiar, like meeting an old friend from the past. I enjoyed the docs, with lots of examples and good readability. I was surprised to see how powerful stdlib is nowadays. Support in text editors and IDEs is also very solid.</p><p>  我喜欢的是什么：感觉熟悉，就像从过去遇到一位老朋友一样。我喜欢文档，有很多例子和良好的可读性。我惊讶地看到了现在的stdlib是多么强大。在文本编辑器和IDE中的支持也非常稳固。</p><p> What I disliked: poor tooling – no build system, no test harness, no linter. We are used to it from the past, but that’s not what a modern developer expects. Too powerful – for this very task C++ felt very productive, but I can imagine myself with a decision paralysis at some point when there are many different ways to do something and all are equally good (or bad).</p><p> 我不喜欢的是：工具不好 - 没有建立系统，没有测试线束，没有兰特。我们习惯于过去，但这不是一种现代开发人员所期望的。太强大 - 对于这个非常任务C ++感到非常富有成效，但我可以想象在某些时候有许多不同的方法做某事并且所有人同样好（或坏），我可以想象自己在某些时候瘫痪。</p><p> People who read the resulting C++ code actually have read C or C++ in the past, at least as part of their university classes. Many complained about the use of  ::, so I should properly use the namespaces, I guess. Overall, as I don’t have a “taste” in C++ code – I’m sure it could have been written more clearly, but I also see how it could have been written much worse without even noticing.</p><p> 读取生成的C ++代码的人实际上是过去读取的C或C ++，至少作为大学课程的一部分。许多人抱怨使用::，所以我猜我应该妥善使用命名空间。总的来说，因为在C ++代码中没有“品味” - 我相信它可能已经更清楚地写得很清楚，但我也看到了在没有甚至注意到的情况下如何写得多。</p><p>  All languages produced static executables, all about the same size (2..5MB). The smallest one was Zig, the largest one was Rust. All had about the same performance when scanning through my whole  /usr/include file tree. That’s why I wanted to highlight that technical characteristics are often not as important as the developer experience.</p><p>  所有语言都产生了静态可执行文件，所有大小（2..5MB）都大致相同。最小的是Zig，最大的一个是生锈的。扫描整个/ usr / include文件树时，所有这些都具有大致相同的性能。这就是为什么我想强调技术特征通常与开发人员经历那么重要。</p><p> I would like to mention separately the build times. I ran the whole build+test+clean loop a hundred of times. Go comes the fastest (as expected), the other three are LLVM-based and are ~3x-4x slower.</p><p> 我想单独提一下建设时间。我跑了整个构建+测试+清洁循环一百次。去速度最快（如预期），另外三个是基于LLVM的，并且是〜3x-4x较慢。 </p><p> What does it all mean? The results are not surprising and often follow the cliches about the languages: Go is simple to read, Rust is complicated, C++ is familiar, Zig looks promising but is too young to judge.</p><p>这是什么意思呢？结果并不令人惊讶，往往遵循陈词滥调的语言：GO易于阅读，Rust复杂，C ++很熟悉，Zig看起来很有希望，但太年轻了，判断太小。</p><p> If I had to write a new service/utility that does not have to interact with C code a lot - I would definitely choose Go. If I had to call some C or C++ libraries - I would stick to C++ (unfortunately). What place would Rust and Zig take in the modern programming world - only time will tell. I wish Zig had a better documentation to gain popularity before it becomes too niche and obscured. I will definitely pay a closer attention to it, so far it’s the first real C replacement I’ve met, especially when it comes to the low-level coding.</p><p> 如果我必须编写一个不必与C代码交互的新服务/实用程序 - 我肯定会选择Go。如果我不得不打电话给一些c或c ++库 - 我会坚持c ++（不幸的是）。什么地方生锈和Zig在现代的编程世界中占据了什么 - 只有时间会告诉。我希望Zig在它变得过于利润之前获得更好的文档来获得人气。我肯定会仔细注意它，到目前为止，这是我遇到的第一个真实的替换，特别是在涉及到低级编码时。</p><p> But of course, C is here to stay despite its age. There are still too many areas where C is the only real choice. And I’m glad that C exists.</p><p> 但当然，C在这里仍然是它的年龄。仍有太多区域，其中c是唯一真正的选择。而且我很高兴C存在。</p><p> I hope you’ve enjoyed this article. You can follow – and contribute to – on  Github,  Twitter or subscribe via  rss.</p><p> 我希望你很喜欢这篇文章。您可以遵循 - 并贡献 - 在Github，Twitter或通过RSS订阅。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://zserge.com/posts/better-c-benchmark/">https://zserge.com/posts/better-c-benchmark/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/基准/">#基准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/benchmark/">#benchmark</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>