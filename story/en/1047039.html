<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Clang 2.7如何在2021年成立？ How does Clang 2.7 hold up in 2021?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How does Clang 2.7 hold up in 2021?<br/>Clang 2.7如何在2021年成立？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-31 17:27:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2021/1/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A friend recently learned about Proebsting&#39;s law and mentioned it to me off hand.I knew about the law&#39;s existence but I never really asked myself - do I believe in it?</p><p>最近有一个朋友了解了Proebsting的法律，并立即向我提及。我知道法律的存在，但我从未真正问过自己-我相信吗？</p><p>   Which is to say, if you upgrade your compiler every 18 years, you would expect on average your code to double in performance on the same hardware.</p><p>   也就是说，如果每18年升级一次编译器，则平均而言，您期望代码在相同硬件上的性能提高一倍。</p><p>  It occurred to me that I could try to do an experiment.I could take a modern compiler and compare performance of generated code - along with perhaps a few other metrics - vs a 20-year-old one.</p><p>  在我看来，我可以尝试做一个实验。我可以使用一个现代的编译器，并比较生成的代码的性能-也许还有其他一些指标-与20岁的代码相比。</p><p> At least this was my initial intention; however I&#39;ve long wanted to do  another experiment which is to figure out how LLVM has changed over the years.To combine these two I wanted to get an old version of LLVM and test it against a modern version.</p><p> 至少这是我最初的意图；但是，我一直很想做另一个实验，以弄清楚LLVM在过去几年中是如何变化的。为了将这两者结合起来，我想得到一个旧版本的LLVM并在一个现代版本中进行测试。</p><p> To make this experiment a bit more interesting, I was going to test LLVM 1.0 - unfortunately, it only comes with 32-bit Linux binaries that I wasn&#39;t able to get to work fully due to lack of 32-bit system headers, and it segfaulted when compiling one of the source files. So we&#39;re going to test two versions of LLVM:</p><p> 为了使该实验更加有趣，我将测试LLVM 1.0-不幸的是，由于缺少32位系统标头，它仅带有32位Linux二进制文件，使我无法完全工作，并且在编译源文件之一时出现段错误。因此，我们将测试LLVM的两个版本：</p><p> LLVM 2.7. This is the first release of LLVM that contains a version of Clang that can compile C++ code.</p><p> LLVM 2.7。这是LLVM的第一个版本，其中包含可以编译C ++代码的Clang版本。</p><p> LLVM 11. This is the latest stable release of LLVM that I happen to have available.</p><p> LLVM 11.这是我碰巧可用的LLVM的最新稳定版本。 </p><p> LLVM 2.7 was released in April 2010, which was 11 years ago. So we wouldn&#39;t quite expect a 2x speedup according to Proebsting&#39;s law - only a 1.5x one.</p><p>LLVM 2.7于11年前于2010年4月发布。因此，根据Proebsting的定律，我们不会期望将速度提高2倍-仅为1.5倍。</p><p> We&#39;re going to compare these compilers on compile time and run time axis as follows:</p><p> 我们将在编译时和运行时轴上比较这些编译器，如下所示：</p><p> Using an amalgamated version of  https://github.com/zeux/meshoptimizer library, we&#39;re going to build  libmeshoptimizer.o several times for each compiler, with and without optimizations (-O0 through -O3), and note the build time.</p><p> 使用https://github.com/zeux/meshoptimizer库的合并版本，我们将为每个编译器多次构建libmeshoptimizer.o，并带有和不带有优化（-O0至-O3），并注意建立时间。</p><p> Using the resulting optimized .o file we&#39;re going to compile the meshoptimized demo program using modern clang, run it on a Stanford dragon mesh and compare timings for various algorithms.</p><p> 使用生成的优化后的.o文件，我们将使用现代clang编译经过网格优化的演示程序，在Stanford Dragon Mesh上运行它，并比较各种算法的时序。</p><p> The reason why we&#39;re going to compile the demo program separately is that demo program uses STL and I don&#39;t want to find versions of STL that are compatible with these older compilers.</p><p> 我们将单独编译演示程序的原因是，演示程序使用STL，而我不想查找与这些较早的编译器兼容的STL版本。</p><p> Note: I&#39;m aware that this is not a rigorous or a scientific way to analyze the law; the law itself is also a bit tongue in cheek so who cares? Don&#39;t read too much into the results.</p><p> 注意：我知道这不是分析法律的严格或科学方法；法律本身也有些面目，那么谁在乎呢？不要过多地阅读结果。</p><p>   I&#39;ve downloaded a binary release of LLVM 2.7 from  https://releases.llvm.org/; LLVM 11 comes with Ubuntu 20. I&#39;m running everything using WSL2 on a Linux partition to make sure the performance numbers are representative of real hardware.</p><p>   我已经从https://releases.llvm.org/下载了LLVM 2.7的二进制版本。 LLVM 11随Ubuntu 20一起提供。我正在Linux分区上使用WSL2运行所有程序，以确保性能数字代表真实的硬件。 </p><p> Each compiler is used to build all meshoptimizer source (8.5 KLOC) as a single translation unit to simplify the build process, in four configurations:  -O0,  -Os -DNDEBUG,  -O2 -DNDEBUG and  -O3 -DNDEBUG.</p><p>每个编译器都用于以四种转换方式将所有meshoptimizer源（8.5 KLOC）作为单个转换单元进行构建，以简化构建过程：-O0，-Os -DNDEBUG，-O2 -DNDEBUG和-O3 -DNDEBUG。</p><p>     Based on this analysis we can observe that the debug compilation throughput was not impacted very significantly - over 10 years of development time clang+llvm got 15% slower in debug builds, which is not surprising and not particularly alarming. Release mode, however, is noticeably slower - 2.2x slower in O2/O3.</p><p>     基于此分析，我们可以看到调试编译吞吐量没有受到很大的影响-在10多年的开发时间中，clang + llvm的调试版本速度降低了15％，这不足为奇，也并不特别令人震惊。但是，释放模式明显较慢-O2 / O3的速度要慢2.2倍。</p><p> In terms of output size, the numbers look healthy - O2/O3 builds got ~25-30% larger but that by itself isn&#39;t a problem as long as we see matching performance increases - in  Os, where size is important, the binary got 8% smaller.</p><p> 就输出大小而言，数字看起来很健康-O2 / O3的构建增加了约25-30％，但只要我们看到匹配的性能提高，它本身就不是问题-在OS中，大小很重要，二进制文件缩小了8％。</p><p>  The problem when comparing runtime is that it&#39;s not clear what specific build we need to compare, and what code we need to benchmark.meshoptimizer comes with lots of algorithms that have various performance characteristics. It would be interesting to analyze all of them, but since this article doesn&#39;t promise to be scientific, we&#39;re going to pick a few algorithms and measure them in all build configurations, and then select one configuration to dig into Proebsting&#39;s law further.</p><p>  比较运行时的问题在于，尚不清楚我们需要比较哪些特定的构建，以及我们需要进行基准测试的代码。meshoptimizer附带了许多具有各种性能特征的算法。对所有这些进行分析将很有趣，但是由于本文并不承诺是科学的，因此我们将选择一些算法并在所有构建配置中对其进行度量，然后选择一种配置进行挖掘进一步纳入Proebsting法律。</p><p> To get a basic understanding, let&#39;s pick just three algorithms - vertex cache optimization, simplification and index decompression. We&#39;re going to look closer into performance of other algorithms later, but it would be good to get a sense of the differences between the versions on a small set.</p><p> 为了获得基本的了解，我们仅选择三种算法-顶点缓存优化，简化和索引解压缩。稍后，我们将进一步研究其他算法的性能，但是最好能了解较小集合上版本之间的差异。</p><p>       The picture that is beginning to emerge here seems rather grim. We see speedups in the 10-15% range in optimized builds, with an exception of index decompress in Os that seems more like an outlier, where likely  -Os inlining heuristics in LLVM 11 result in the same code across different optimization levels; we also see speedups in the 5% range in unoptimized builds.</p><p>       在这里开始出现的画面似乎相当严峻。我们看到优化构建中的速度提高了10％至15％，但Os中的索引解压缩似乎更像是一个异常值，在LLVM 11中，-Os内联启发式算法可能会在不同的优化级别上产生相同的代码。在未优化的版本中，我们还会看到速度提高了5％。</p><p> Now, it&#39;s important that in addition to the disclaimer about the comparison not being particularly scientific the reader also understands one extra detail - all algorithms in meshoptimizer are carefully optimized. This isn&#39;t a run-of-the-mill C++ code - this is the code that was studied under various profilers and tweaked until, while it remained reasonably concise, the performance was deemed worthy.</p><p> 现在，重要的是，除了关于比较不是特别科学的免责声明之外，读者还应该了解一个额外的细节-Meshoptimizer中的所有算法均经过仔细优化。这不是普通的C ++代码-这是在各种探查器下研究并经过调整的代码，直到在保持合理简洁的前提下，才认为该性能值得。 </p><p> It is possible in theory that code that&#39;s less carefully optimized exhibits different behavior, or that the benchmarks chosen here are simply not as amenable to compiler optimization as they could be - the lack of prominent difference between different optimization levels is also noteworthy (although O3 in particular has been stufied before in academic research and the value of that mode was inconclusive).</p><p>从理论上讲，不太仔细优化的代码可能表现出不同的行为，或者此处选择的基准根本无法像其可能那样适合编译器优化-不同优化级别之间缺乏显着差异也很值得注意（尽管以前在学术研究中特别研究过O3，但这种模式的价值尚无定论）。</p><p> To try to get a more complete picture, let&#39;s now look at more algorithms and compare them in O2 build only.</p><p> 为了获得更完整的图像，我们现在看一下更多算法，并仅在O2构建中对它们进行比较。</p><p>  We&#39;re going to first take a look at a more complete set of algorithms from meshoptimizer library; this isn&#39;t every single algorithm in existence as some of the algorithms have performance characteristics that aren&#39;t very distinct compared to other algorithms already presented here. This also excludes vertex decompression which is going to be mentioned separately.</p><p>  我们将首先查看meshoptimizer库中一套更完整的算法；这并不是现有的每个算法，因为某些算法的性能特征与此处已经介绍的其他算法相比并没有很大区别。这也排除了将要单独提及的顶点减压。</p><p>  Overall the picture here is not very different from what we&#39;ve already established - LLVM 11 seems to produce code that&#39;s 10-15% faster on most benchmarks. There are a couple outliers where the performance gain is more substantial, up to 25%, and a couple benchmarks where LLVM 11 actually generates consistently  slower code, up to 5% - this is not a measurement error.</p><p>  总体而言，这里的图片与我们已经建立的图片并没有太大不同-LLVM 11似乎生成的代码在大多数基准测试中的速度提高了10-15％。在几个离群值中，性能提升更为可观，最高可达25％；在几个基准测试中，LLVM 11实际上生成始终较慢的代码，最高可达5％，这不是测量误差。</p><p> I&#39;ve reran the outliers using -O3 with the following results, that made the gap a bit less wide but still substantial:</p><p> 我使用-O3重新测试了异常值，得出以下结果，该差距虽然不大但仍然很大：</p><p>  These gains are certainly welcome, although it is unfortunate that they seem to come at the cost of 2x slower compilation. This takes me back to &#34;The death of optimizing compilers&#34; by David J. Bernstein - I wonder if there&#39;s a happier middle ground that can be found, one where the compiler gives more control over optimization decisions to the developer and allows tuning the code to reach gains that can be seen here at a lower complexity and compilation performance cost.</p><p>  这些收益当然是受欢迎的，尽管不幸的是，它们似乎是以较慢的2倍编译速度为代价的。这使我回到＆＃34;优化编译器的死亡＆＃34;作者：David J. Bernstein，我不知道是否可以找到一个更幸福的中间立场，在这个中间立场，编译器将更多的优化决策控制权交给开发人员，并允许调整代码以达到在此处可以看到的收益。降低复杂度和编译性能成本。</p><p>  All of the algorithms presented before were scalar, implemented using portable C++. While portions of some of these can be vectorized in theory, in practice clang 11 even at -O3 struggles with generating efficient SIMD code for most/all of them.</p><p>  之前介绍的所有算法都是标量，使用可移植的C ++实现。尽管其中的某些部分可以在理论上进行矢量化处理，但实际上，即使在-O3时，clang 11仍难以为大多数/全部生成有效的SIMD代码。 </p><p> meshoptimizer does have several algorithms that have first-class SIMD versions, implemented using SSE/NEON/Wasm intrinsics. Their performance was compared using  codecbench, a utility that comes with meshoptimizer and outputs performance in GB/sec - so the numbers in the following tables are reversed, larger is better.</p><p>meshoptimizer确实有几种具有一流SIMD版本的算法，这些算法使用SSE / NEON / Wasm内部函数实现。使用codecbench比较了它们的性能，codecbench是meshoptimizer附带的实用程序，输出性能以GB / sec为单位-因此下表中的数字是相反的，越大越好。</p><p>  All of the filters are typical SIMD streaming kernels - there&#39;s no branches or complex data dependencies. Perhaps unsurprisingly, the delta in performance of the compiled code is thus not very significant. The vertex decode is substantially more complicated - it contains function calls, branches, mix of scalar and vector instructions and in general can be more challenging for the optimizer.</p><p>  所有过滤器都是典型的SIMD流内核-没有分支或复杂的数据依存关系。也许不足为奇的是，编译后的代码的性能差异并不是很大。顶点解码实际上要复杂得多-它包含函数调用，分支，标量和矢量指令的混合，并且通常对优化器而言更具挑战性。</p><p> It&#39;s worth noting that on this particular example, using  -O3 with LLVM 2.7 brings the performance up from 2.3 GB/s to 2.7 GB/s, while having no effect on LLVM 11 - bringing the delta between LLVM 11 and LLVM 2.7 back to ~10% range.</p><p> 值得注意的是，在此特定示例上，将-O3与LLVM 2.7一起使用可将性能从2.3 GB / s提高到2.7 GB / s，而对LLVM 11没有影响-使LLVM 11和LLVM之间的增量2.7回到〜10％范围。</p><p> It&#39;s undoubtedly possible to find examples of loops that LLVM 2.7 couldn&#39;t vectorize (by virtue of not having an autovectorizer) and LLVM 11 can - unfortunately, my experience even on streamlined kernels like the aforementioned filters force me to maintain a deep distrust towards the auto-vectorizer (out of the 4 filter kernels above, clang 11 can not vectorize even a single one, and gcc 10 can only vectorize &#39;exp&#39; - one out of 4). I would claim that any gains due to auto-vectorization can&#39;t be counted as significant until programmers are given better tools to make these optimizations more predictable and reliable.</p><p> 毫无疑问，可以找到LLVM 2.7不能进行矢量化的循环的示例（由于没有自动矢量化器），而LLVM 11可以-不幸的是，我的经验即使是在上述过滤器之类的简化内核上也使我不得不保持对自动向量化器的高度不信任（在上述4个过滤器内核中，clang 11甚至不能对一个向量进行向量化，而gcc 10只能对＆exp;＃4进行向量化）。我要说的是，除非为程序员提供了更好的工具以使这些优化更可预测和更可靠，否则自动矢量化带来的任何收益都不能算是重大的。</p><p>   LLVM 11 tends to take 2x longer to compile code with optimizations, and as a result produces code that runs 10-20% faster (with occasional outliers in either direction), compared to LLVM 2.7 which is more than 10 years old. This may be a general rule, something specific to highly tuned code, or something specific to meshoptimizer algorithms.</p><p>   与10年前的LLVM 2.7相比，LLVM 11进行优化的代码往往花费2倍的时间来编译代码，因此生成的代码运行速度提高了10-20％（在任一方向上都有异常值）。这可能是一条通用规则，某些特定于高度调整的代码，某些特定于Meshoptimizer算法。</p><p> Without spending more than an evening it&#39;s hard to disambiguate the reasons. And this post definitely doesn&#39;t pretend to be a thorough research - it&#39;s just a fun little study of how competitive clang 2.7 looks like in 2021. Without a doubt, the amazing community behind LLVM didn&#39;t spend the last decade for naught - but if you still believe in the sufficiently smart optimizing compiler, it may be time to reconsider the extent to which you can rely on the compiler to make your code faster year after year, as if anything Proebsting&#39;s law should probably be reformulated as:</p><p> 如果不花一个多晚上的时间，就很难消除其原因。这篇文章绝对不假装是一项详尽的研究-只是关于有趣的2.7 c语在2021年的样子的有趣的小研究。毫无疑问，LLVM背后的惊人社区没有花了过去的十年时间-但如果您仍然相信足够聪明的优化编译器，那么也许是时候重新考虑可以依靠编译器使您的代码年复一年地更快的程度了，就像任何有前途的东西一样＃39的法律可能应重新制定为：</p><p>  It&#39;s important to recognize that there are many forces that together define the rate at which software performance changes - between hardware getting faster (yes, even in the last 10 years, despite what Herb Sutter&#39;s &#34;Free Lunch Is Over&#34; would make you believe), compilers getting better, software development practices frequently getting out of hand and a large discrepancy between the expertise of the software developers wrt optimization, compiler advances are just one, rather small, piece of the puzzle. Perhaps David Bernstein was right after all.</p><p>  重要的是要认识到，有很多因素共同决定了软件性能变化的速度-硬件之间的速度越来越快（是的，即使是在最近的10年中，尽管Herb Sutter是什么）。免费午餐结束了（会让您相信），编译器变得越来越好，软件开发实践经常失控，并且软件开发人员的专业知识与优化之间存在巨大差异，编译器的进步只是其中的一小部分，难题。也许大卫·伯恩斯坦毕竟是对的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/zeux/3ce4fcc3a43072b4315abde95319ecb6">https://gist.github.com/zeux/3ce4fcc3a43072b4315abde95319ecb6</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/clang/">#clang</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>