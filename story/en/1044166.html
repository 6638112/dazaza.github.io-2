<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>没有数学库的Donut.c Donut.c Without a Math Library</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Donut.c Without a Math Library<br/>没有数学库的Donut.c </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 20:28:43</div><div class="page_narrow text-break page_content"><p>My little  donut.c has been making the roundsagain, after being featured in a couple YouTube videos (e.g.,  LexFridman and  JomaTech). If I had known how muchattention this code would get over the years, I would have spent more time onit.</p><p>在几个YouTube视频（例如LexFridman和JomaTech）中亮相之后，我的小甜甜圈c就一直在反复进行。如果我知道这些年来这些代码会引起多大的关注，那么我会花更多的时间进行编写。</p><p> One thing that’s always been sort of unfortunate is the heavy use of  sin and cos – both because it necessitates linking the math library ( -lm), butalso because it makes it much more CPU-intensive than it really needs to be.This is especially apparent if you try to port it to an  olderCPU or an  embeddeddevice.</p><p> 一直很不幸的一件事是大量使用sin和cos –既因为它需要链接数学库（-lm），又因为它使CPU占用的资源比实际需要的多得多。这尤其是如果您尝试将其移植到较旧的CPU或嵌入式设备，则很明显。</p><p> So, here’s a revised version with no use of  sin,  cos, and no need forlinking the math library (though this version still does use  float types).</p><p> 因此，这是一个修订版，其中没有使用sin，cos，也不需要链接数学库（尽管此版本仍使用浮点类型）。</p><p> i,j,k,x,y,o,N; main(){float z[1760],a #define R(t,x,y) f=x;x-=t*y\ ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f; =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char b[1760];for(;;){memset(b,32,1760);g=0,h=1;memset(z,0,7040);for(j=0;j&lt;90;j++){G=0,H=1;for(i=0;i&lt;314;i++){A=h+2,D=1/(G*A*a+g*e+5);t=G*A *e-g*a;x=40+30*D*(H*A*d-t*c);y= 12+15*D*(H*A*c+t*d);o=x+80*y;N =8*((g*a-G*h*e)*d-G*h*a-g*e-H*h *c);if(22&gt;y&amp;&amp;y&gt; 0&amp;&amp;x&gt;0&amp;&amp;80&gt;x&amp;&amp;D&gt;z[o]){z[o]=D;b[o]=(N&gt;0 ?N:0)[&#34;.,-~:;=!*#$@&#34;];}R(.02,H,G);}R( .07,h,g);}for(k=0;1761&gt;k;k++)putchar (k%80?b[k]:10);R(.04,e,a);R(.02,d, c);usleep(15000);printf(&#39;\n&#39;+( &#34; donut.c! \x1b[23A&#34;));}} /*no math lib needed .@a1k0n 2021.*/</p><p> i，j，k，x，y，o，N; main（）{float z [1760]，＃define R（t，x，y）f = x; x- = t * y \; y + = t * f; f =（3-x * xy * y） / 2; x * = f; y * = f; = 0，e = 1，c = 1，d = 0，f，g，h，G，H，A，t，D; char b [1760]; for（;;）{memset（b，32,1760 ）; g = 0，h = 1; memset（z，0,7040）; for（j = 0; j＆lt; 90; j ++）{G = 0，H = 1; for（i = 0; i＆lt; 314; i ++）{A = h + 2，D = 1 /（G * A * a + g * e + 5）; t = G * A * eg * a; x = 40 + 30 * D *（H * A * dt * c）; y = 12 + 15 * D *（H * A * c + t * d）; o = x + 80 * y; N = 8 *（（g * aG * h * e）* dG * h * ag * eH * h * c）; if（22 y＆amp; y＆gt; 0 amp＆amp; x＆gt; 0＆amp; 80 80 x＆amp; D＆gt; z [o]）{z [o] = D; b [o] =（N> 0？N：0）[＆＃34;。，-〜：; =！*＃$ @＆＃34;];} R（.02，H，G）; } R（.07，h，g）;} for（k = 0; 1761＆gt; k; k ++）putchar（k％80？b [k]：10）; R（.04，e，a）; R（ .02，d，c）; usleep（15000）; printf（＆＃39; \ n＆＃39; +（＆＃34; donut.c！\ x1b [23A＆＃34;））;}} / *无数学运算lib需要。@ a1k0n 2021。* /</p><p> It’s a little misshapen and still has comments at the bottom. I used the firstframe of its output as a template and there’s  slightly less code than filledpixels – oh well. Output is pretty much the same as before:</p><p> 它有些变形，但在底部仍然有评论。我将其输出的第一帧用作模板，并且代码比filledpixels略少-哦，很好。输出与以前几乎相同：</p><p>    So, how do we get sines and cosines without using  sin and  cos? Well, thecode doesn’t really  need sine and cosine  per se; what it actually does isrotate a point around the origin in two nested loops, and also rotate twoangles just for the animation. If you’ll recall from the other article, theinner loop is just plotting dots in a circle, which goes around another, largercircle. In each loop, the sine/cosine terms are just moving by a small, fixedangle.</p><p>    那么，如何在不使用正弦和余弦的情况下得到正弦和余弦呢？嗯，代码本身并不需要真正的正弦和余弦。它实际上所做的是在两个嵌套循环中绕原点旋转一个点，并且还仅为动画旋转了两个角度。如果您还记得另一篇文章，那么内部循环就是在一个圆上绘制点，该圆围绕另一个更大的圆。在每个循环中，正弦/余弦项仅以一个小的固定角度移动。</p><p> So we don’t need to track the  angle at all, we only need to start at cos=1,sin=0 and rotate a circle around the origin to generate all the sines andcosines we need. We just have to repeatedly apply a fixed rotation matrix:</p><p> 因此，我们根本不需要跟踪角度，只需要从cos = 1，sin = 0开始，然后绕原点旋转一个圆，即可生成所需的所有正弦和余弦。我们只需要重复应用固定的旋转矩阵： </p><p>\[\begin{bmatrix}c&#39; \\s&#39;\end{bmatrix} = \begin{bmatrix}\cos \theta &amp; -\sin \theta \\\sin \theta &amp; \cos \theta\end{bmatrix} \begin{bmatrix} c \\ s \end{bmatrix}\] So for example, if we were to use an angle of .02 radians in our inner loop, it would look something like:</p><p>\ [\ begin {bmatrix} c＆＃39; \\ s＆＃39; end {bmatrix} = \ begin {bmatrix} \ cos \ theta＆amp; -\ sin \ theta \\\ sin \ theta＆amp; \ cos \ theta \ end {bmatrix} \ begin {bmatrix} c \\ s \ end {bmatrix} \]因此，例如，如果我们在内部循环中使用.02弧度的角度，则看起来像：</p><p> float  c = 1 ,  s = 0 ;  // c for cos, s for sin for  ( int  i  =  0 ;  i  &lt;  314 ;  i ++ )  {  // 314 * .02 ~= 2π  // (use c, s in code)  float  newc  =  0 . 9998 * c  -  0 . 01 9998666 * s ;  s  =  0 . 01 9998666 * c  +  0 . 9998 * s ;  c  =  newc ; }</p><p> 浮点c = 1，s = 0; // c表示cos，s表示sin（int i = 0; i＆lt; 314; i ++）{// 314 * .02〜=2π//（在代码中使用c，s）float newc = 0。 9998 * c-0。 01 9998666 * s; s = 0。 01 9998666 * c + 0。 9998 * s; c = newc; }</p><p>  That works, but there’s a problem: no matter how precisely we define ourconstants, after repeated iteration of this procedure, the magnitude of our \(\left(c, s\right)\) vector will exponentially grow or shrink over time. If weonly need to make one pass around the loop, maybe we can get away with that,but if we have to make several (for the rotating animation, we do), we need tofix that.</p><p>  那行得通，但是存在一个问题：无论我们定义常量的精度如何，在重复执行此过程之后，\（\ left（c，s \ right）\）向量的大小都会随着时间呈指数增长或缩小。如果只需要在循环中绕过一遍，也许我们可以避免这种情况，但是如果我们必须绕过一遍（对于旋转动画，则需要这样做），则需要修复该问题。</p><p>  The simplest way to do that would be to multiply \(c\) and \(s\) by \(1/\sqrt{c^2 + s^2}\), but then we’re back to using the math library again. Instead, we can takeadvantage of the fact that our magnitude starts out very close to 1, and we’regoing to be iterating this procedure: we can do a  Newtonstep after each rotation, andthat will be enough to keep the magnitude “close enough” to 1 over time.</p><p>  最简单的方法是将\（c \）和\（s \）乘以\（1 / \ sqrt {c ^ 2 + s ^ 2} \），但是我们回到使用数学再次图书馆。取而代之的是，我们可以利用这样一个事实，即我们的幅度开始时非常接近1，并且我们要迭代此过程：我们可以在每次旋转之后执行一个牛顿步，这足以使幅度“足够接近”到1随着时间的流逝。</p><p> Our goal is to find the reciprocal square root ( soundfamiliar?) of \(a =c^2 + s^2\), our \(\left(c, s\right)\) vector magnitude. Say we define afunction \(f(x) = \frac{1}{x^2} - a\). The function is 0 when \(x =\frac{1}{\sqrt{a}}\). We can start with an initial guess of 1 for  x,perform a Newton iteration to obtain  x’, which will be “closer to”\(\frac{1}{\sqrt{a}}\), the correct value to scale  c and  s by so that theirmagnitude \(c^2 + s^2\) is “close to” 1 again.</p><p> 我们的目标是找到\（a = c ^ 2 + s ^ 2 \），我们的\（\ left（c，s \ right）\）向量幅值的倒数平方根（soundfamiliar？）。假设我们定义了一个函数\（f（x）= \ frac {1} {x ^ 2}-a \）。当\（x = \ frac {1} {\ sqrt {a}} \）时，该函数为0。我们可以从x的初始猜测为1开始，执行牛顿迭代以获得x'，它将“更接近” \（\ frac {1} {\ sqrt {a}} \），即要缩放的正确值c和s乘以使其幅度\（c ^ 2 + s ^ 2 \）再次“接近” 1。</p><p> A Newton step is defined as \(x&#39; = x - \frac{f(x)}{f&#39;(x)}\). I used SymPy to do the derivative and simplification andcame up with \(x&#39; = \frac{x\left(3 - a x^2\right)}{2}\). Since we’re only doingone step, we can plug in our initial guess of 1 for \(x\) and back-substitute\(c^2 + s^2\) for \(a\) to finally get our adjustment: \(x&#39; = (3 - c^2 - s^2)/2\).</p><p> 牛顿步骤定义为\（x＆＃39; = x-\ frac {f（x）} {f＆＃39;（x）} \）。我使用SymPy进行导数和简化，并得出\（x＆＃39; = \ frac {x \ left（3-a x ^ 2 \ right）} {2} \）。由于只执行了一步，因此我们可以为\（x \）插入初始猜测值1，为\（a \）插入后替换\（c ^ 2 + s ^ 2 \）最终得到调整： \（x＆＃39; =（3-c ^ 2-s ^ 2）/ 2 \）。</p><p>  But now that we don’t have to worry so much about the magnitude of our result(within limits), we can take another shortcut (I got this idea studying old CORDIC algorithms). If we divide outthe cosines from our original rotation matrix, we get</p><p>  但是，既然我们不必太担心结果的大小（在限定范围内），我们可以采取另一个捷径（我有了研究旧的CORDIC算法的想法）。如果我们从原始旋转矩阵中除掉余弦，我们得到 </p><p>\[\begin{bmatrix}c&#39; \\s&#39;\end{bmatrix} = \frac{1}{\cos \theta}\begin{bmatrix}1 &amp; -\tan \theta \\\tan \theta &amp; 1\end{bmatrix} \begin{bmatrix} c \\ s \end{bmatrix}\] using the trig identity \(\tan \theta = \frac{\sin \theta}{\cos \theta}\).Since we’re only dealing with small angles, the leading \(\frac{1}{\cos\theta}\) term is close enough to 1 that we can ignore it and have our Newtonstep take care of it.</p><p>\ [\ begin {bmatrix} c＆＃39; \\ s＆＃39; \ end {bmatrix} = \ frac {1} {\ cos \ theta} \ begin {bmatrix} 1＆amp; -\ tan \ theta \\\ tan \ theta＆amp; 1 \ end {bmatrix} \ begin {bmatrix} c \\ s \ end {bmatrix} \]使用触发身份\（\ tan \ theta = \ frac {\ sin \ theta} {\ cos \ theta} \）。由于我们仅处理小角度，因此前导\（\ frac {1} {\ cos \ theta} \）足够接近1，因此我们可以忽略它并让我们的Newtonstep来处理。</p><p> And now we can finally understand how the rotation is done in the code. Towardsthe top of the donut code is this #define, which I’ve reindented:</p><p> 现在，我们终于可以理解代码中的旋转方式了。在＃甜甜圈代码的最上方，是我重新定义的#define：</p><p> #define R(t,x,y) \   f  =  x ; \  x  -=  t * y ; \  y  +=  t * f ; \  f  =  ( 3 - x * x - y * y ) / 2 ; \  x  *=  f ; \  y  *=  f ;</p><p> ＃定义R（t，x，y）\ f = x; \ x-= t * y; \ y + = t * f; \ f =（3-x * x-y * y）/ 2; \ x * = f; \ y * = f;</p><p> This does an in-place rotation of a unit vector  x, y where  t is \(\tan\theta\).  f is a temporary variable; the first three lines do the “matrixmultiplication” on  x, y.  f is then re-used to get the magnitude adjustment,and then finally  x and  y are multiplied by  f which moves them back ontothe unit circle.</p><p> 这将对单位矢量x，y进行就地旋转，其中t是\（\ tan \ theta \）。 f是一个临时变量；前三行在x，y上执行“矩阵乘法”。然后重新使用f进行幅度调整，最后将x和y乘以f，将它们移回到单位圆上。</p><p> With that operation in hand, I just replaced all the angles with their sinesand cosines and ran the rotation operator  R() instead of calling  sin/ cos.The code is otherwise identical.</p><p> 进行完该操作后，我只用它们的正弦和余弦替换了所有角度，然后运行旋转运算符R（）而不是调用sin / cos，否则代码是相同的。</p><p>  We can use exactly the same ideas with integer fixed-point arithmetic, and notuse any  float math whatsoever. I’ve redone all the math with 10-bit precisionand produced the following C code which runs well on embedded devices which cando 32-bit multiplications and have ~4k of available RAM:</p><p>  我们可以对整数定点算法使用完全相同的想法，而不使用任何浮点数学。我已经以10位精度重做了所有数学运算，并产生了以下C代码，这些代码在嵌入式设备上可以很好地运行，这些设备可以进行32位乘法并具有约4k的可用RAM：</p><p> #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; #define R(mul,shift,x,y) \ _=x; \ x -= mul*y&gt;&gt;shift; \ y += mul*_&gt;&gt;shift; \ _ = 3145728-x*x-y*y&gt;&gt;11; \ x = x*_&gt;&gt;10; \ y = y*_&gt;&gt;10; char  b [ 1760 ],  z [ 1760 ]; void  main ()  {  int  sA = 1024 , cA = 0 , sB = 1024 , cB = 0 , _ ;  for  (;;)  {  memset ( b ,  32 ,  1760 );  // text buffer  memset ( z ,  127 ,  1760 );  // z buffer  int  sj = 0 ,  cj = 1024 ;  for  ( int  j  =  0 ;  j  &lt;  90 ;  j ++ )  {  int  si  =  0 ,  ci  =  1024 ;  // sine and cosine of angle i  for  ( int  i  =  0 ;  i  &lt;  324 ;  i ++ )  {  int  R1  =  1 ,  R2  =  2048 ,  K2  =  5120 * 1024 ;  int  x0  =  R1 * cj  +  R2 ,  x1  =  ci * x0  &gt;&gt;  10 ,  x2  =  cA * sj  &gt;&gt;  10 ,  x3  =  si * x0  &gt;&gt;  10 ,  x4  =  R1 * x2  -  ( sA * x3  &gt;&gt;  10 ),  x5  =  sA * sj  &gt;&gt;  10 ,  x6  =  K2  +  R1 * 1024 * x5  +  cA * x3 ,  x7  =  cj * si  &gt;&gt;  10 ,  x  =  40  +  30 * ( cB * x1  -  sB * x4 ) / x6 ,  y  =  12  +  15 * ( cB * x4  +  sB * x1 ) / x6 ,  N  =  ( - cA * x7  -  cB * (( - sA * x7 &gt;&gt; 10 )  +  x2 )  -  ci * ( cj * sB  &gt;&gt;  10 )  &gt;&gt;  10 )  -  x5  &gt;&gt;  7 ;  int  o  =  x  +  80  *  y ;  char  zz  =  ( x6 - K2 ) &gt;&gt; 15 ;  if  ( 22  &gt;  y  &amp;&amp;  y  &gt;  0  &amp;&amp;  x  &gt;  0  &amp;&amp;  80  &gt;  x  &amp;&amp;  zz  &lt;  z [ o ])  {  z [ o ]  =  zz ;  b [ o ]  =  &#34;.,-~:;=!*#$@&#34; [ N  &gt;  0  ?  N  :  0 ];  }  R ( 5 ,  8 ,  ci ,  si )  // rotate i  }  R ( 9 ,  7 ,  cj ,  sj )  // rotate j  }  for  ( int  k  =  0 ;  1761  &gt;  k ;  k ++ )  putchar ( k  %  80  ?  b [ k ]  :  10 );  R ( 5 ,  7 ,  cA ,  sA );  R ( 5 ,  8 ,  cB ,  sB );  usleep ( 15000 );  printf ( &#34; \x1b [23A&#34; );  } }</p><p> #include＆lt; stdio.h＆gt; #include＆lt; string.h＆gt; #include＆lt; unistd.h＆gt; ＃定义R（mul，shift，x，y）\ _ = x; \ x-= mul * y＆gt;＆gt; shift; \ y + = mul * _＆gt;＆gt; shift; \ _ = 3145728-x * x-y * y＆gt;＆gt; 11; \ x = x * _＆gt;＆gt; 10; \ y = y * _＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt; 10;字符b [1760]，z [1760]； void main（）{int sA = 1024，cA = 0，sB = 1024，cB = 0，_; for（;;）{memset（b，32，1760）; //文本缓冲区memset（z，127，1760）; // z buffer int sj = 0，cj = 1024;对于（int j = 0; j  10）+ x2）-ci *（cj * sB＆gt; 10）＆gt; 10）-x5＆gt; 7； int o = x + 80 * y; char zz =（x6-K2）＆gt; 15； if（22＆gt; y＆amp; y＆gt; 0＆amp; x＆gt; 0＆amp;＆amp; 80＆gt; x＆amp; zz＆lt; z＆lt; z [o]）{z [o] = zz; b [o] =＆＃34;。，-〜：; =！*＃$ @＆＃34; [N＆gt; 0？ N：0]； } R（5，8，ci，si）//旋转i} R（9，7，cj，sj）//旋转j} for（int k = 0; 1761> k; k ++）putchar（k ％80？b [k]：10）; R（5，7，cA，sA）; R（5，8，cB，sB）;睡着了（15000）; printf（＆＃34; \ x1b [23A＆＃34;）; }} </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.a1k0n.net/2021/01/13/optimizing-donut.html">https://www.a1k0n.net/2021/01/13/optimizing-donut.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数学/">#数学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/math/">#math</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>