<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>文件系统和数据库无法减少问题空间Filesystem and Database are not cutting the problem space right</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Filesystem and Database are not cutting the problem space right<br/>文件系统和数据库无法减少问题空间</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-27 02:10:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1a976fd7a0b41eb4748e9896151b134c.png"><img src="http://img2.diglog.com/img/2020/11/1a976fd7a0b41eb4748e9896151b134c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This blog post explains the problems with using traditional filesystems and databases for  web development and shows a better approach.</p><p>这篇博客文章解释了使用传统文件系统和数据库进行Web开发的问题，并展示了一种更好的方法。</p><p>  Traditional filesystems and databases have very different properties. Traditional filesystems are best suited for storing large objects while databases for structured data. Traditional filesystems have hierarchy (folders), databases have transactions.</p><p>  传统文件系统和数据库具有非常不同的属性。传统文件系统最适合存储大型对象，而用于结构化数据的数据库则最适合。传统文件系统具有层次结构（文件夹），数据库具有事务。</p><p> This makes web development way more complex than it should be. Let&#39;s look at just one issue.</p><p> 这使得Web开发方式比应有的方式复杂。让我们只看一个问题。</p><p>   As we are talking about an image  file, it comes natural to store it on the traditional  filesystem. Unfortunately, traditional filesystems don&#39;t support transactions. Getting the security aspects right is hard. It&#39;s a challenge to make consistent backups given that you can&#39;t just stop the world. Inevitably, a traditional filesystem will be modified while you are working on the backup. Sooner or later this will cause problems.</p><p>   当我们谈论图像文件时，将其存储在传统文件系统中是很自然的。不幸的是，传统文件系统不支持事务。正确解决安全问题非常困难。鉴于您不能止步不前，因此要进行一致的备份是一个挑战。不可避免地，在进行备份时，将修改传统文件系统。迟早会导致问题。</p><p> Databases can solve all of the above. They have transactions. If you do a backup, it will likely be consistent by default. The problem is, databases are bad with large objects. They are a bad choice if you want to serve lots of users.</p><p> 数据库可以解决以上所有问题。他们有交易。如果进行备份，则默认情况下可能会保持一致。问题是，数据库对大型对象不利。如果您想为很多用户提供服务，那么它们是一个不好的选择。</p><p> This is really frustrating. Why can&#39;t we have a storage system that combines the best of both worlds?</p><p> 这真令人沮丧。为什么我们不能拥有结合了两全其美的存储系统？</p><p>  Let&#39;s take a step back and look at the big picture. This is how the problem space for storing data is currently divided:</p><p>  让我们退后一步，看看大局。当前如何划分存储数据的问题空间：</p><p>  For  example, storing ice cream and fruits have conflicting requirements. Ice cream has to be frozen while freezing directly harms fruits. Ice cream requires below zero temperatures while fruits require above zero temperatures. That&#39;s a hard conflict.  They require different storage solutions.</p><p>例如，存储冰淇淋和水果有冲突的要求。冰淇淋必须冷冻，而冷冻直接损害水果。冰淇淋需要低于零温度，而水果需要高于零温度。那是一场艰苦的冲突。他们需要不同的存储解决方案。</p><p> The thing is, traditional filesystem and database features have no conflicts. Or tell me a single feature that requires:</p><p> 事实是，传统的文件系统和数据库功能没有冲突。或告诉我一个需要以下功能的功能：</p><p>   Some data of the website must be controlled, that is, only changed by the website&#39;s owners. This includes the codebase, the page structure, blog post contents, some assets like images and videos or even highly structured data like product features. Such data shall not be changing in the production environment  1 as that would mean your visitors see work-in-progress changes that may even break the website temporarily.</p><p>   网站的某些数据必须受到控制，即只能由网站所有者更改。这包括代码库，页面结构，博客文章内容，一些资产（例如图像和视频），甚至是高度结构化的数据（例如产品功能）。此类数据在生产环境1中不得更改，因为这将意味着您的访问者看到正在进行的更改，甚至可能暂时中断网站。</p><p> Controlled data shall be edited in  development environments which shall be clone-able from the production environment. It often requires  version control and  non-linear development (branching and merging). Upon shipping a new version of the codebase to the production environment, the new state should  replace the old state.</p><p> 受控数据应在开发环境中进行编辑，该开发环境应可从生产环境中克隆。它通常需要版本控制和非线性开发（分支和合并）。在将新版本的代码库交付到生产环境后，新状态应替换旧状态。</p><p>  On the other hand, there are changes that simply  can not be controlled. This includes user contributions like comments and webshop orders. It includes changes made by automatically executed scripts, for example one that resets counters at midnight. It shall include logs generated while serving requests.</p><p>  另一方面，有些变化是无法控制的。这包括评论和网上商店订单之类的用户贡献。它包括自动执行的脚本所做的更改，例如，在午夜重置计数器的脚本。它应包括在处理请求时生成的日志。</p><p> Uncontrolled data consists of  linear, sequential changes thus it requires linear snapshots not non-linear feature branches. When cloning the production environment for development purposes, uncontrolled data will typically need to be cloned as well thereby giving you complete freedom to try anything without a complex setup process. This also helps reproducing bugs in minimal time. Upon shipping a new version of the codebase to the production environment, the new state of uncontrolled data shall be typically  dropped to prevent accidentally overwriting changes made in production.</p><p> 不受控制的数据由线性的顺序变化组成，因此需要线性快照而不是非线性特征分支。当出于开发目的而克隆生产环境时，通常还需要克隆不受控制的数据，从而使您可以完全自由地尝试任何事情，而无需复杂的设置过程。这也有助于在最短的时间内重现错误。在将新版本的代码库交付到生产环境后，通常应删除不受控制的数据的新状态，以防止意外覆盖生产中所做的更改。</p><p> Most websites and web apps need both a controlled and an uncontrolled storage area. Traditional filesystems and databases are used to store both due to the differences in their capabilities.</p><p> 大多数网站和Web应用程序都需要受控区域和不受控制区域。由于功能不同，传统文件系统和数据库都用于存储两者。</p><p> Boomla provides a radically simpler web development experience by cutting the problem space along real conflicting requirements, thereby eliminating accidental complexity:</p><p>Boomla通过沿着实际冲突的需求削减问题空间，从而提供了从根本上更简单的Web开发体验，从而消除了意外的复杂性：</p><p> Boomla provides separate filesystems based on different storage requirements, one for controlled changes and one for uncontrolled changes.</p><p> Boomla根据不同的存储需求提供了单独的文件系统，一个用于受控更改，另一个用于非受控更改。</p><p>   The Boomla Filesystem has a  tree structure like a traditional filesystem having files. As expected, Boomla files can store  large objects, like images and videos. To store  structured data, Boomla files have file attributes to store custom anything in a key-value format, similar to database rows having fields. Finally, the Boomla Filesystem is  transactional.</p><p>   Boomla文件系统具有类似于具有文件的传统文件系统的树形结构。正如预期的那样，Boomla文件可以存储较大的对象，例如图像和视频。为了存储结构化数据，Boomla文件具有文件属性，可以按键值格式存储自定义的任何内容，类似于具有字段的数据库行。最后，Boomla文件系统是事务性的。</p><p>  We have addressed how to have a hierarchy of objects everywhere, even on the dynamic filesystem but if we store it as a separate filesystem tree, we are back to square one: a global shared namespace. Instead, what we need is the ability to  attach dynamic volumes anywhere on the static filesystem, like so:</p><p>  我们已经解决了如何在任何地方都具有对象层次结构，即使在动态文件系统上也是如此，但是如果将其存储为单独的文件系统树，我们将回到平方：全局共享名称空间。相反，我们需要的是能够在静态文件系统上的任意位置附加动态卷的能力，如下所示：</p><p>  The  existence of these dynamic volumes must be version controlled but their contents must not be as they are constantly changing. They must be somehow stored on the dynamic filesystem instead.</p><p>  这些动态卷的存在必须受版本控制，但它们的内容不能保持不变，因为它们在不断变化。它们必须以某种方式存储在动态文件系统中。</p><p> Let&#39;s see an  example. Imagine a comments element embedded into a page. It shall have its own dynamic volume with its own schema. The existence of the comments element must be version controlled but not the actual comments. They can&#39;t be: they would cause continuous merging issues.</p><p> 让我们来看一个例子。想象一下嵌入页面的注释元素。它应具有自己的具有自己模式的动态卷。评论元素的存在必须是版本控制的，而不是实际的评论。它们不可能是：它们会引起持续的合并问题。</p><p> Removing either the comments element itself (or even the page it is embedded in) must remove the comments element itself with all associated user comments. In the traditional setup, you would have to write lots of code yourself to figure out what data needs to be removed. This takes time (money) and may be non-trivial when there are several 3rd party plugins installed. With proper encapsulation, the system can automatically do this for you.</p><p> 删除comment元素本身（或什至是其嵌入的页面）必须删除带有所有相关用户注释的comment元素本身。在传统设置中，您必须自己编写许多代码才能确定需要删除哪些数据。这需要花费时间（金钱），并且在安装了多个第三方插件时可能并不简单。使用正确的封装，系统可以自动为您完成此操作。</p><p>  So here is how this works. Boomla files have a  link property. You can attach a dynamic volume anywhere on your website&#39;s filesystem by simply setting the file&#39;s link property to  dynamic.</p><p>这就是它的工作原理。 Boomla文件具有链接属性。您只需将文件的link属性设置为dynamic即可在网站文件系统上的任何位置附加动态卷。</p><p>  By doing so, the system will create a new volume on the hidden dynamic filesystem and map it to the linking file. (Using the linking file&#39;s file ID.) From that point on, you will be able to write the dynamic subtree as usual. It will appear as if it was part of your website&#39;s filesystem tree.</p><p>  这样，系统将在隐藏的动态文件系统上创建一个新卷并将其映射到链接文件。 （使用链接文件的文件ID。）从那时起，您将能够照常编写动态子树。它看起来就像是您网站的文件系统树的一部分。</p><p> That way, in Boomla, deleting the page holding the comments will  also remove the actual comments.</p><p> 这样，在Boomla中，删除包含评论的页面也将删除实际评论。</p><p> The root volume of the dynamic filesystem is hidden by design, it&#39;s not directly accessible. If you are interested, see the  dynamic link docs for more details.</p><p> 动态文件系统的根卷在设计上是隐藏的，无法直接访问。如果您有兴趣，请参阅动态链接文档以获取更多详细信息。</p><p> One of the really powerful features of the Boomla Filesystem is that undo/redo is available for the entire website. It  makes us experiment. We can try things, we can fail and we can always undo. It&#39;s a huge boost to  dare to try.</p><p> Boomla文件系统真正强大的功能之一是整个网站都可以撤消/重做。这让我们尝试。我们可以尝试，我们可以失败，我们可以永远撤销。敢于尝试的巨大动力。</p><p>  There is a little caveat though. In the  production environment you may have multiple users making changes. You definitely don&#39;t want to accidentally undo a comment or an order made by someone else. Plus in production, the static filesystem is read-only as you probably don&#39;t want your visitors to see your work-in-progress. Because of this, undo/redo is not available in the production environment (master branch).</p><p>  不过有一点警告。在生产环境中，您可能有多个用户进行更改。您绝对不想意外撤消其他人的评论或命令。在生产中加上静态文件系统是只读的，因为您可能不希望访问者看到正在进行的工作。因此，撤消/重做在生产环境（主分支）中不可用。</p><p> Once you clone the production environment and thus create a  development branch, undo/redo will be available for your entire website. Changes made to the static and dynamic filesystems are bundled in a single atomic transaction, creating a single undo point. That way, whatever changes you make, you will be able to use undo/redo.</p><p> 克隆生产环境并创建开发分支后，撤消/重做将可用于整个网站。对静态和动态文件系统所做的更改捆绑在单个原子事务中，从而创建单个撤消点。这样，无论您进行什么更改，您都可以使用撤消/重做。</p><p> To rephrase, you either don&#39;t have undo/redo at all (master branch) or you have undo/redo for your entire website (secondary branches).</p><p>换个说法，您根本没有撤消/重做（主分支），或者整个网站都具有撤消/重做（二级分支）。</p><p> Access control can only be enforced in a layer that has access to both users and data. It&#39;s just impossible otherwise. Websites and web apps introduce their own user concepts. As a result, they should take over all access control responsibilities. Data access should only happen through a single, well defined layer.</p><p> 访问控制只能在可以访问用户和数据的层中实施。否则是不可能的。网站和Web应用程序介绍了自己的用户概念。因此，他们应该承担所有访问控制职责。数据访问应仅通过单个定义良好的层进行。</p><p> Unfortunately, that didn&#39;t happen. Both databases and the underlying OS have their own user concepts with their own means of doing access control. Plus your chosen CMS or framework has its own user concept and access control mechanisms. Application developers have access to all of them. They have to call all the right functions themselves to make sure everything is secure. Every application developer has to be a security expert and not make mistakes.</p><p> 不幸的是，那没有发生。数据库和底层OS都有自己的用户概念，以及自己的访问控制方法。另外，您选择的CMS或框架也有其自己的用户概念和访问控制机制。应用程序开发人员可以访问所有这些程序。他们必须自己调用所有正确的函数以确保所有内容都是安全的。每个应用程序开发人员都必须是安全专家，并且不能犯错误。</p><p> If you are wondering how this could possibly be secure - don&#39;t worry, it isn&#39;t.  It&#39;s a complete disaster. (Pro tip: make your competitors use this.)</p><p> 如果您想知道这怎么可能是安全的-不用担心，事实并非如此。这是一场彻底的灾难。 （专业提示：让您的竞争对手使用它。）</p><p>  By providing a single storage solution in a single layer with website users,  Boomla can do access control centrally. Most importantly, it can be enforced so application developers don&#39;t need to do extra work to get it right. They don&#39;t need to be security experts.</p><p>  通过与网站用户一起在单层中提供单个存储解决方案，Boomla可以集中进行访问控制。最重要的是，它可以强制执行，因此应用程序开发人员无需做额外的工作就可以正确实现。他们不需要成为安全专家。</p><p> Additionally, this new approach for separating data into static and dynamic filesystems gives us new opportunities at enforcing security. The static filesystem can be  read-only in production, preventing malware from injecting any code. At the same time, we can prevent  code execution on the dynamic filesystem as it is a non-trusted storage area. As we are using a filesystem not a database,  SQL-injection type attacks are also eliminated.</p><p> 此外，这种将数据分为静态和动态文件系统的新方法为我们提供了执行安全性的新机会。静态文件系统在生产中可以是只读的，从而可以防止恶意软件注入任何代码。同时，由于动态文件系统是不可信的存储区域，因此可以防止代码在动态文件系统上执行。由于我们使用的是文件系统而不是数据库，因此也消除了SQL注入类型的攻击。</p><p> The static workflow does not allow collaboration, you can not attach dynamic volumes to your static filesystem.</p><p> 静态工作流不允许协作，您不能将动态卷附加到静态文件系统。</p><p> On the other hand, the master branch (production environment) of your website will be writable and undo/redo will be available. That&#39;s the old workflow thus we will keep it to not disrupt existing users/websites.</p><p>另一方面，您网站的主分支（生产环境）将是可写的，并且撤消/重做将可用。那是旧的工作流程，因此我们将保持它不会破坏现有的用户/网站。</p><p>  To use the dynamic filesystem, you will have to enable the collaborative workflow. Let&#39;s see how it&#39;s different.</p><p>  要使用动态文件系统，您将必须启用协作工作流程。让我们看看它有何不同。</p><p> Say you want to implement a new feature or add a new blog post. You can&#39;t do that on the master branch (production environment) so you will create a new development branch. You do this by cloning your master branch which includes both the static filesystem and the dynamic filesystem. That way, you have complete freedom to try anything. If you spot a bug on the live website, it will still be there after creating a feature branch. The only change will be that you are now in a safe playground.</p><p> 假设您要实施新功能或添加新博客文章。您不能在master分支（生产环境）上执行此操作，因此您将创建一个新的开发分支。为此，您可以克隆包含静态文件系统和动态文件系统的master分支。这样，您就可以完全自由地尝试任何东西。如果您在实时网站上发现错误，那么在创建功能分支后该错误仍然存​​在。唯一的变化是您现在在安全的操场上。</p><p>   Once you are done and happy with your changes, you can  publish the static filesystem of your development branch. The dynamic filesystem will not be published, it will be dropped. That way, you are free to implement a new shopping cart system and even test drive it a couple of times without worrying that your changes will affect the live inventory.</p><p>   完成修改并满意之后，您可以发布开发分支的静态文件系统。动态文件系统将不会被发布，而是将被删除。这样，您可以自由地实施新的购物车系统，甚至可以试驾几次，而不必担心更改会影响实时库存。</p><p>  Today, many developers end up with the worst possible setup: only have a production  database and run migration scripts directly on that. That&#39;s because the current tools we have to live with make it way more complex to set up a full clone environment than it should be.</p><p>  如今，许多开发人员最终都遇到了最糟糕的设置：仅拥有生产数据库并直接在其上运行迁移脚本。这是因为我们必须使用的当前工具使建立完整克隆环境的方式比应该的复杂得多。</p><p> The Dynamic Filesystem is currently in public beta. We will still need to figure out how to price it as using it will result in more resource hungry websites.</p><p> 动态文件系统目前处于公开测试阶段。我们仍然需要弄清楚如何定价，因为使用它会导致更多的资源匮乏的网站。</p><p> Traditional filesystems and databases are cutting the problem space along the wrong dimensions, introducing lots of accidental complexity, breaking security and making web development a lot harder than it should be.</p><p> 传统的文件系统和数据库在错误的维度上缩减了问题空间，带来了许多意外的复杂性，破坏了安全性，并使Web开发变得比原本困难得多。</p><p> The problem space should be cut along conflicting requirements. In the case of web development, this doesn&#39;t mean storage system features but the requirement for controlled changes: some data must be controlled while other data simply can not be.</p><p>问题空间应沿着相互矛盾的需求进行切割。对于Web开发，这并不意味着存储系统具有功能，而是对受控更改的要求：必须控制某些数据，而不能完全控制其他数据。</p><p> I&#39;m working on a tutorial with several examples on how this approach can be used to create simple collaborative applications. For example, how to store comments, user votes and session data.</p><p> 我正在编写一个教程，其中包含几个示例，说明如何使用这种方法来创建简单的协作应用程序。例如，如何存储评论，用户投票和会话数据。</p><p> Subscribe to the newsletter at the bottom of this page if you want to be notified about it.</p><p> 如果您想收到通知，请订阅此页面底部的新闻通讯。</p><p> Boomla is a stable, production ready web development platform as a service. You can follow the project on  Twitter or subscribe to the newsletter at the bottom of this page. You can also just sign up and explore it. There is lots of  documentation including  onboarding videos. I&#39;m also happy to help, feel free to reach out!</p><p> Boomla是一个稳定的，可立即投入生产的Web开发平台，即服务。您可以在Twitter上关注该项目，也可以订阅本页底部的新闻通讯。您也可以注册并浏览它。有很多文档，包括入门视频。我也很乐意提供帮助，随时与您联系！</p><p>    1)  production environment: the public version of your website, also called the  master branch. Typically, it is accessible on a domain like example.com or www.example.com. The other environments are called  secondary branches or  development branches.</p><p>    1）生产环境：您网站的公共版本，也称为master分支。通常，可以在诸如example.com或www.example.com之类的域上访问它。其他环境称为辅助分支或开发分支。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://boomla.com/blog/filesystem-and-database-are-not-cutting-the-problem-space-right">https://boomla.com/blog/filesystem-and-database-are-not-cutting-the-problem-space-right</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件系统/">#文件系统</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>