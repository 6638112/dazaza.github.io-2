<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Buzzword.engineering技术堆栈 The Buzzword.engineering Tech Stack</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Buzzword.engineering Tech Stack<br/>Buzzword.engineering技术堆栈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-28 15:42:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/50e6e2d1a70575df78f8746f54480405.jpg"><img src="http://img2.diglog.com/img/2020/12/50e6e2d1a70575df78f8746f54480405.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I&#39;ve been meaning to get around to setting up a blog for a long time. In the past, I&#39;ve gotten as far as getting halfway through trying out different static site generators before getting depressed about my lack of frontend design chops and given up.</p><p>很长时间以来，我一直想建立一个博客。过去，在尝试使用不同的静态站点生成器之前，我已经走了一半，直到对我缺乏前端设计的想法感到沮丧并放弃了。</p><p>  I took  two weeks off. After recharging my batteries for a few days, I was ready for a little side project.</p><p>  我休了两个星期。给电池充电几天后，我就可以开始进行一些小型项目了。</p><p>  I&#39;ve tried a decent number of static site generators to build documentation for various projects and wanted to take a deeper dive into  Gatsby.</p><p>  我已经尝试了许多静态站点生成器来为各种项目构建文档，并希望更深入地研究盖茨比。</p><p> I wanted to see if i could use Obsidian as a  content management system (CMS) for a tech blog and Pipedream to automate tweeting out new blog posts.</p><p> 我想看看我是否可以将Obsidian用作技术博客的内容管理系统（CMS），并使用Pipedream自动发布新博客文章。</p><p>  Anyway, here&#39;s Buzzword Engineering&#39;s inaugural blog post. If you like it, go give me a github star on the  blog repo or something. It&#39;s a nice dopamine boost and fuels my self-worth.</p><p>  无论如何，这是Buzzword Engineering的首篇博客文章。如果您喜欢，请在博客存储库上给我一个github star或类似的东西。这是多巴胺的有益补充，助长了我的自我价值。</p><p>    If you haven&#39;t heard of it, stop reading this and go play with  Excalidraw and then come back. It&#39;s the tool I used to sketch out this diagram.</p><p>    如果您还没听说过，请停止阅读并继续使用Excalidraw，然后再回来。这是我用来绘制此图的工具。</p><p>  I&#39;ll keep this short. Maybe a future blog post will talk about Obsidian in a lot more detail. For now, let me just say that I&#39;ve tried to get into taking notes for... a long time. I could never do it in college. I struggle to do it for work. I&#39;ve always found that taking notes takes away from my ability to absorb the content in the moment and make meaningful contributions.</p><p>  我会尽量简短。也许将来的博客文章会更详细地讨论黑曜石。现在，我只想说我已经尝试做笔记很长时间了。我上大学永远做不到。我为工作而努力。我一直发现做笔记会失去我吸收当下内容并做出有意义贡献的能力。 </p><p> Obsidian was the first app that actually made me  want to take notes. The general idea is that all your notes are written in markdown. Jumping around is super easy with  CMD + O (which also will create pages for you if they don&#39;t exist). Linking between pages to build connections is really easy as can be with a syntax like  [[this]]. Obsidian builds a visual graph of the relationships between pages (I&#39;m a sucker for graphs). And finally, you can build templates and insert them with  CMD + T. Templates dramatically simplified the boiler plate needed to capture who&#39;s attending a meeting, agenda, the date, etc.</p><p>黑曜石是第一个真正让我想做笔记的应用程序。通常的想法是，所有笔记都以降价书写。使用CMD + O（在不存在的情况下，还会为您创建页面）来回跳转非常容易。页面之间的链接以建立连接真的很容易，就像使用[[this]]这样的语法一样。黑曜石建立页面之间关系的可视图形（我是图形的傻瓜）。最后，您可以构建模板并将其插入CMD +T。模板极大地简化了捕获谁参加会议，议程，日期等所需的样板。</p><p> Long story short, try it out. (Or don&#39;t, whatever.) I&#39;m a fan and thought that maybe if I can use it as the interface for writing blog posts that I might  actually write some.</p><p> 长话短说，尝试一下。 （或者什么也不要。）我是一个粉丝，认为如果我可以将其用作撰写博客文章的界面，我可能会写一些。</p><p>  Obsidian has some 3rd-party plugins that do nifty things. One of these plugins is called  Obsidian Git which can automatically backup your notes to a Git repository.</p><p>  黑曜石有一些第三方的插件，可以做一些漂亮的事情。这些插件之一称为Obsidian Git，它可以自动将您的笔记备份到Git存储库。</p><p> I figured that had to be a way to fetch markdown content from a remote github repository and use it as a content source for Gatsby. There was.</p><p> 我认为这必须是一种从远程github存储库中获取markdown内容并将其用作Gatsby的内容源的方法。有。</p><p>  Blog post information is defined through the markdown frontmatter. For example, the frontmatter for this blog post:</p><p>  博客文章信息是通过markdown前置事项定义的。例如，此博客文章的主要内容：</p><p> --- title : The buzzword.engineering Tech Stack date :  &#34;12/26/2020&#34; publish :  true template :  &#34;post&#34; slug : blog -tech -stack description :  &#34;I finally got around to putting a blog together that uses Obsidian, Gatsby, and automates tweeting out new posts with Pipedream.&#34; ---</p><p> ---标题：buzzword.engineering Tech Stack日期：＆＃34; 12/26/2020＆＃34;发布：真正的模板：＆＃34; post＆＃34; slug：blog -tech -stack description：＆＃34;我终于开始整理一个使用Obsidian，Gatsby的博客，并使用Pipedream自动发推新帖子。 ---</p><p>  I think it&#39;s important to start here by saying that I&#39;m  not a frontend developer. Well, let&#39;s rephrase that. I&#39;m writing a blog post that has Gatsby in it. So it&#39;s probably more accurate to say that I&#39;m a  very junior frontend developer.</p><p>  我认为从这里开始我不是前端开发人员很重要。好吧，我们重新表述一下。我正在写一篇包含盖茨比的博客文章。所以说我是一个非常初级的前端开发人员可能更准确。 </p><p> My mental model for Gatsby so far is that it&#39;s a framework for building static site generators. There might be a couple frontend purists or gatsby enthusiasts out there who take issue with that definition, please let me know if you&#39;ve got a better one down in the comments.</p><p>到目前为止，我对盖茨比（Gatsby）的想法是，它是一个用于构建静态网站生成器的框架。可能会有一对前端纯粹主义者或gatsby爱好者对这个定义有疑问，请让我知道您的评论中是否有更好的定义。</p><p>  It uses  React, which is a lot more powerful to me over something like  handlebars or go-based html templating.</p><p>  它使用React，对我来说，它比诸如把手或基于Go的html模板等功能强大得多。</p><p> Gatsby is extensible with a rich plugin ecosystem that contribute to a shared  GraphQL data layer. When developing your site, you can query the data layer to fetch content for particular pages/components.</p><p> Gatsby可通过丰富的插件生态系统进行扩展，这些生态系统有助于共享的GraphQL数据层。开发网站时，您可以查询数据层以获取特定页面/组件的内容。</p><p> I like React and I think Gatsby&#39;s extensibility framework and GraphQL data layer is  brilliant.</p><p> 我喜欢React，我认为Gatsby的可扩展性框架和GraphQL数据层非常出色。</p><p>  Another great thing about Gatsby is their concept of Starters. For this blog, I kicked things off with the  gatsby-starter-lumen.</p><p>  关于盖茨比的另一件事是他们的初学者概念。对于这个博客，我从gatsby-starter-lumen开始了。</p><p>  The first thing I had to customize was content sources. The Lumen starter fetches content from the same repository as the blog itself. Thankfully, there&#39;s a Gatsby plugin called   gatsby-source-git that allows you to fetch content from a remote Git repository.</p><p>  我必须自定义的第一件事是内容源。 Lumen入门程序从与博客本身相同的存储库中获取内容。值得庆幸的是，有一个名为gatsby-source-git的Gatsby插件，可让您从远程Git存储库中获取内容。</p><p> During development, I wanted to be able to fetch content from the local copy of the Obsidian backup repository. Gatsby plugins are done by exporting a javascript object from a file called  gatsby-config.js.</p><p> 在开发过程中，我希望能够从Obsidian备份存储库的本地副本中获取内容。通过从名为gatsby-config.js的文件中导出javascript对象来完成Gatsby插件。 </p><p> Here, I toggle between using the  gatsby-source-git plugin and the [ gatsby-source-filesystem] based on whether a  GATSBY_PREVIEW environment variable is set.</p><p>在这里，我根据是否设置了GATSBY_PREVIEW环境变量，在使用gatsby-source-git插件和[gatsby-source-filesystem]之间切换。</p><p> if (process .env . GATSBY_PREVIEW  ==  &#34;true&#34; ) { console . log (  ` using local vault path:   ${siteConfig .obsidian .vaultPath } ` ) config .plugins . unshift ( { resolve :  &#39;gatsby-source-filesystem&#39; , options :  { path : siteConfig .obsidian .vaultPath , name :  &#39;local_obsidian&#39; , ignore :  [  &#34;**/.git/**/*&#34; ,  &#34;**/.obsidian/**/*&#34; ,  &#34;**/Templates/**/*&#34;  ]  }  } ) }  else { console . log ( &#34;fetching from remote repo: &#34; , siteConfig .obsidian .repo ) config .plugins . unshift ( { resolve :   ` gatsby-source-git ` , options :  { name :   ` obsidian ` , remote : siteConfig .obsidian .repo , patterns :  [  &#34;!**/Templates/**/*&#34; ,  &#34;**/*&#34;  ]  }  } ) }</p><p> if（process .env。GATSBY_PREVIEW ==＆＃34; true＆＃34;）{控制台。日志（`使用本地文件路径：$ {siteConfig .obsidian .vaultPath}`）配置.plugins。取消移位（{解析：＆＃39; gatsby-source-filesystem＆＃39;，选项：{路径：siteConfig .obsidian .vaultPath，名称：＆＃39; local_obsidian＆＃39;，忽略：[＆＃34; ** / .git / ** / *＆＃34;，＆＃34; ** /。obsidian / ** / *＆＃34;，＆＃34; ** / Templates / ** / *＆＃34;]} }}}}其他{控制台。日志（＆＃34;从远程仓库获取：＆＃34;，siteConfig .obsidian .repo）配置.plugins。 unshift（{解析：`gatsby-source-git`，选项：{名称：`obsidian`，远程：siteConfig .obsidian .repo，pattern：[＆＃34;！** / Templates / ** / *＆＃34 ;，＆＃34; ** / *＆＃34;]}}）}</p><p>  Comments on blog posts are made possible through a nifty tool called  utteranc.es. It&#39;s a GitHub Application that uses GitHub Issue threads per blog post to track comments.</p><p>  通过称为utteranc.es的漂亮工具，可以对博客文章进行评论。它是一个GitHub应用程序，每个博客帖子使用GitHub Issue线程来跟踪评论。</p><p>  In the spirit of premature optimization, I wanted to integrate a way to filter blog posts with fuzzy-searching. To accomplish this, I integrated  Fuse.js and added a new  Filter component to the blog.</p><p>  本着过早优化的精神，我想集成一种使用模糊搜索过滤博客帖子的方法。为此，我集成了Fuse.js并在博客中添加了一个新的Filter组件。</p><p> Most of the logic for how this was accomplished can be seen in the  Index Template.</p><p> 如何完成此操作的大多数逻辑可以在索引模板中看到。</p><p> I wanted to insert a gif of the filtering taking place. Apparently that&#39;s easier said than done with Gatsby and gatsby-transform-remark. I&#39;ll update this post once I get gifs working 🙄.</p><p> 我想插入一个正在进行过滤的gif文件。显然，这比使用Gatsby和gatsby-transform-remark来说容易。一旦gif可用，我将更新此帖子。</p><p>  With the site actually working how I wanted it to, I got to focus on the side of things I&#39;m actually good at: digital duct tape. The goal is for changes in markdown content in the Obsidian backup repository to trigger a deployment of the site and if there is a new blog post, to send out a tweet letting you all know about it.</p><p>  在网站按照我希望的方式实际工作时，我必须专注于我实际上擅长的方面：数字胶带。目标是更改Obsidian备份存储库中的markdown内容，以触发站点的部署，如果有新博客，则发送一条推文，让大家都知道。 </p><p>  First things first, the content repository needs to trigger a deployment of the site. The easiest way I could think to accomplish this would be to a GitHub Action on the blog post repository that does the build/deploy logic.</p><p>首先，内容存储库需要触发站点的部署。我想到的最简单的方法是在博客帖子存储库上执行一个GitHub Action，它执行构建/部署逻辑。</p><p> This meant that I needed a way to invoke a GitHub Action on one repository as part of the execution of an Action on another repository. This is where the   repository_dispatch event comes in handy. Basically, it means that you can use the GitHub API to trigger an Action.</p><p> 这意味着我需要一种在一个存储库上调用GitHub Action的方法，作为在另一个存储库上执行Action的一部分。这是repository_dispatch事件派上用场的地方。基本上，这意味着您可以使用GitHub API触发操作​​。</p><p>  name : Trigger Build on :  # trigger this action on changes to the main branch  push :  branches :  [ main  ]  # Allows you to run this workflow manually from the Actions tab  workflow_dispatch : jobs :  trigger :  runs-on : ubuntu -latest  steps :  -  name : Trigger Upstream Blog Action  run :  |  curl -XPOST \ -u &#34;${{ secrets.PAT_USERNAME}}:${{secrets.PAT_TOKEN}}&#34; \ -H &#34;Accept: application/vnd.github.everest-preview+json&#34; \ -H &#34;Content-Type: application/json&#34; \ https://api.github.com/repos/steven-terrana/steven-terrana.github.io/dispatches \ --data &#39;{&#34;event_type&#34;: &#34;blog&#34;}&#39;</p><p>  名称：触发构建于：＃在主分支推送更改时触发此操作push：分支：[main]＃允许您从“操作”选项卡中手动运行此工作流程workflow_dispatch：Jobs：触发器：运行于：ubuntu-最新步骤： -名称：触发上游博客操作运行：| curl -XPOST \ -u＆＃34; $ {{secrets.PAT_USERNAME}}：$ {{secrets.PAT_TOKEN}}＆＃34; \ -H＆＃34;接受：application / vnd.github.everest-preview + json＆＃34; \ -H＆＃34; Content-Type：application / json＆＃34; \ https://api.github.com/repos/steven-terrana/steven-terrana.github.io/dispatches \ --data＆＃39; {＆＃34; event_type＆＃34 ;:＆＃34; blog＆＃ 34;}＆＃39;</p><p>  Sweet. Now commits to the Obsidian backup repository will trigger actions on the blog repository.</p><p>  甜。现在提交到Obsidian备份存储库将触发对博客存储库的操作。</p><p> The next step was to automate the build and deployment steps using a GitHub Action on the blog repository. Here&#39;s what that action looks like:</p><p> 下一步是使用博客库上的GitHub Action自动执行构建和部署步骤。该操作如下所示：</p><p> name : Build and Publish on :  repository_dispatch :  workflow_dispatch : jobs :  build-deploy-notify :  runs-on : ubuntu -latest  steps :  # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it  -  name : Checkout Code 🛎  uses : actions/checkout@v2  with :  persist-credentials :  false  -  name : Install &amp; Build 🔧  run :  |  npm ci npm run build echo &#34;buzzword.engineering&#34; &gt; public/CNAME  env :  PAT_USER : $ { { secrets.PAT_USER  } }  PAT_TOKEN : $ { { secrets.PAT_TOKEN  } }  -  uses : peaceiris/actions -gh -pages@v3  with :  github_token : $ { { secrets.GITHUB_TOKEN  } }  publish_dir : public  force_orphan :  true</p><p> 名称：在以下资源上构建和发布：repository_dispatch：workflow_dispatch：jobs：build-deploy-notify：runs-on：ubuntu-最新步骤：＃在$ GITHUB_WORKSPACE下签出您的资源库，以便您的工作可以访问它-name：结帐代码🛎使用：actions / checkout @ v2以及：persistent-credentials：false-名称：Install＆amp;生成🔧运行：| npm ci npm run build echo＆＃34; buzzword.engineering＆＃34; ＆gt; public / CNAME env：PAT_USER：$ {{secrets.PAT_USER}} PAT_TOKEN：$ {{secrets.PAT_TOKEN}}-使用：peaceiris / actions -gh -pages @ v3，其中：github_token：$ {{secrets.GITHUB_TOKEN}} publish_dir ：public force_orphan：是</p><p>  I add a custom  CNAME file to the  public directory so that GitHub Pages knows the custom domain for this blog. (I should definitely incorporate this into an inherit part of the build of the site using the  onPostBuild Gatsby Node API method or something).</p><p>  我将自定义CNAME文件添加到公共目录，以便GitHub Pages知道此博客的自定义域。 （我绝对应该使用onPostBuild Gatsby Node API方法或其他方法将其合并到网站构建的继承部分中）。 </p><p>   So at this point, we&#39;ve got content changes automatically getting deployed to GitHub Pages. The whole process takes about  three minutes from commit to publish.</p><p>因此，在这一点上，我们已经自动将内容更改部署到GitHub Pages。从提交到发布，整个过程大约需要三分钟。</p><p> The last piece was to automate letting all of you know about the whatever new insightful thing I had to say!</p><p> 最后一步是自动化，让所有人都知道我要说的任何新的有见地的事情！</p><p> I had stumbled on  Pipedream before through targeted ads and sort of ignored it until I saw  David McKay talk about how much he loves it on  rawkode.live. Here&#39;s a  link to the stream!</p><p> 之前，我通过定向广告偶然发现了Pipedream，直到被戴维·麦凯（David McKay）在rawkode.live上谈论他有多喜欢它时，才忽略了它。这是流的链接！</p><p> I went into this adventure thinking I was going to have to do all kinds of fancy logic and scripting to make this possible. I was wrong.</p><p> 我进入了这个冒险之旅，以为我将不得不做各种花哨的逻辑和脚本来使其成为可能。我错了。</p><p> After setting up a Pipedream account, starting looking at what event sources were available to trigger a workflow. Well, the Lumen gatsby starter had already integrated an  RSS feed using the   gatsby-plugin-feed plugin. Pipedream had an event source for monitoring RSS feeds. Done.</p><p> 设置Pipedream帐户后，开始查看哪些事件源可用于触发工作流。好吧，Lumen gatsby入门程序已经使用gatsby-plugin-feed插件集成了RSS feed。 Pipedream有一个事件源，用于监视RSS提要。做完了</p><p> That was easy enough. Next up was automating how to send the tweet. I figured that would mean doing some research on a Twitter Rest API or SDK.</p><p> 那很容易。接下来是自动发送推文。我认为这意味着要对Twitter Rest API或SDK进行一些研究。</p><p> Nope! Pipedream also had a step for automating the sending off a tweet and even made it really simple to query the event that triggered the workflow to template the tweet content with the new blog post information. Here&#39;s what this whole setup looks like in Pipedream:</p><p> 不！ Pipedream还具有自动发送tweet的步骤，甚至使查询触发事件的工作流非常简单，该事件触发了工作流以新的博客文章信息为tweet内容提供模板。这是Pipedream中整个设置的样子： </p><p>  This whole workflow took about 1 minute to figure out and configure. I was almost disappointed in how easy it was. In the end, it was pretty boring. And that&#39;s probably the best compliment I can give Pipedream.</p><p>整个工作流程花费了大约1分钟的时间来确定和配置。 我对它的简单程度感到几乎失望。 最后，这很无聊。 那可能是我可以给Pipedream最好的赞美。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://buzzword.engineering/post/blog-tech-stack">https://buzzword.engineering/post/blog-tech-stack</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/技术/">#技术</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tech/">#tech</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gatsby/">#gatsby</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>