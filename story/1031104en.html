<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>没有IDE的嵌入式编程</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">没有IDE的嵌入式编程</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 23:05:07</div><div class="page_narrow text-break page_content"><p>Unfortunately, for most of my programming education, I believed that statements3 and 4 were mutually exclusive. Every embedded project I had worked onrequired the use of Keil uVision, Code Composer, Eclipse... the usualsuspects. There is nothing inherently wrong with any of these programs, and infact, they significantly lower the barrier to entry for embedded development.They&#39;re widely used for a reason!</p><p>不幸的是，在我接受的大部分编程教育中，我认为语句3和4是相互排斥的。我工作过的每个嵌入式项目都需要使用Keil uVision、Code Composer、Eclipse……。通常的嫌疑犯。这些程序本身没有什么问题，事实上，它们大大降低了嵌入式开发的门槛。它们被广泛使用是有原因的！</p><p> That said, I was always slightly frustrated when Istarted a project by clicking through a wizard, selecting &#34;Project Template&#34;,and seeing a bunch of mysterious files and directories pop up in my workspace.What did all that stuff do? Why couldn&#39;t I see what was going on? What was allthis boilerplate code doing in my project, and was all that complexity reallynecessary? When I would express this frustration to teammates, I would oftenget replies like, &#34;Well you can just read the datasheet and program all theregisters manually if you want. Be my guest!&#34; Teams can be snarky sometimes.</p><p>也就是说，当我开始一个项目时，当我在向导中单击，选择项目模板，并看到工作区中弹出一堆神秘的文件和目录时，我总是有点沮丧。这些东西都做了什么？为什么我看不见发生了什么事？这些样板代码在我的项目中做了什么，所有这些复杂性真的有必要吗？当我向队友表达这种挫折感时，我经常会得到这样的回复：嗯，如果你愿意，你可以阅读数据表，手动编写所有的注册表。请便！&34；球队有时也会尖刻。</p><p> And so, when I began working on FreePulse, I began researching to see if therewas a better way. Just before I had given up hope, I came across  thiswonderful blog post detailing how the author had builta Makefile for a project on the STM32F4 Discovery board. Seeing as I wasstarting my redesign of FreePulse using the same chip, I decided to jump in andtry to drop Eclipse entirely. I&#39;m really pleased with the result, and hopefullythis blog post can guide other people who want to develop for embeddedplatforms independent of an IDE.</p><p>因此，当我开始研究FreePulse时，我开始研究是否有更好的方法。就在我放弃希望之前，我偶然看到了这篇精彩的博客文章，详细描述了作者是如何为STM32F4发现板上的一个项目构建Makefile的。当我开始使用相同的芯片重新设计FreePulse时，我决定加入进来，试着完全放弃Eclipse。我对这个结果非常满意，希望这篇博客文章能指导其他想要独立于IDE开发嵌入式平台的人。</p><p> I&#39;m going to do a brief overview of  make, go through some specifics of how touse  make to perform most of the useful IDE compilation functions, and showhow you can integrate that into a very smooth development workflow using only vim and the command line. Feel free to skip around if you feel like you&#39;vegot a good handle on how  make works!</p><p>我将对make做一个简要的概述，详细介绍如何使用make来执行大多数有用的IDE编译功能，然后简单介绍如何将其集成到一个非常流畅的开发工作流中，只使用VIM和命令行即可。如果你觉得你已经很好地掌握了Make的工作原理，那就随便跳过吧！</p><p>  When starting out any coding project, one of the first things I do is try todetermine the layout of the program in a  Makefile. From the people at the Free Software Foundation:</p><p>当开始任何编码项目时，我要做的第一件事就是尝试确定Makefile中程序的布局。来自自由软件基金会的人：</p><p> GNU Make is a tool which controls the generation of executables and other non-source files of a program from the program&#39;s source files.  1</p><p>GNU make是一个控制从程序的源文件生成程序的可执行文件和其他非源文件的工具。1个。</p><p> make is pretty awesome. While I&#39;m not going to do an exhaustive tutorial oneverything you can do with  make (partly because that would take too long, andpartly because I&#39;m still learning more all the time), I&#39;ll use it as a tool tooutline the structure of an embedded program.</p><p>Make是相当棒的。虽然我不打算对make所能做的一切做一个详尽的教程(部分原因是那样会花费太长时间，部分原因是我还在不断地学习更多内容)，但我会把它作为勾勒嵌入式程序结构的工具。</p><p>  # Source Files (all *.c or *.cpp files) SRCS  = path/to/my/first/source/file.c SRCS  += path/to/my/second/source/file.c # ...etc # Directories containing your header files (all *.h files) INC_DIRS  = first/library/with/inc INC_DIRS  += second/library/with/inc # ...etc INCLUDE  =  $(addprefix -I, $(INC_DIRS )) # Any compiler options you need to set CFLAGS  = -Wall  CFLAGS  += -std =c++11  # ...etc  # Linker Files (all *.ld files) LFLAGS  = -Tfirstfile.ld -Tsecondfile.ld # Tell make how to compile your *.c files into *.o files  %.o : %. c gcc -c -o  $@  $&lt;  $(CFLAGS ) # Finally, tell make how to build the whole project final_binary.elf :  $( SRCS ) gcc  $(INCLUDE )  $(CFLAGS  $(LFLAGS )  $^ -o  $@</p><p>#源文件(所有*.c或*.cpp文件)SRCS=path/to/my/first/source/file.c SRCS+=path/to/my/Second/source/file.c#...etc#包含您的头文件(所有*.h文件)的目录INC_DIRS=first/library/with/Inc_Dir+=Second/library/with/Inc#...etc include=$(addprefix-i，$(INC_DIRS)#设置CFLAGS=-WALL CFLAGS+=-STD=c++11#...etc#链接器文件(所有*.ld文件)LFLAGS=-Tfirstfile.ld-Tond dfile.ld#Tell Make如何将*.c文件编译为*.o文件%.o：%所需的任何编译器选项。C GCC-c-o$@$&lt；$(CFLAGS)#最后，告诉make如何构建整个项目最终_binary.elf：$(SRCS)GCC$(INCLUDE)$(CFLAGS$(LFLAGS)$^-o$@</p><p> Woah. While that may seem like a lot to take in, I promise that it&#39;s actuallyvery simple to understand! To break it down:</p><p>哇哦。虽然这看起来似乎很难理解，但我保证它实际上非常容易理解！要分解它，请执行以下操作：</p><p> We declare our source files, indicated by the .c or .cpp file extensions. These hold all the code that makes our awesome application, and it also holds anysource files required by the device libraries.</p><p>我们声明由.c或.cpp文件扩展名表示的源文件。它们包含制作我们出色的应用程序的所有代码，还包含设备库所需的AnySource文件。</p><p> We declare the folders that are holding all of our include files, indicatedby the .h file extension. Include files let our separate C/C++ files useeach others functions by holding function declarations, and you tell thecompiler what functions you want by the  #include &#34;somefile.h&#34; directive.It&#39;s really important to note (and easy to forget) that  your differentsource files don&#39;t automagically know what each other contain. If it isn&#39;tdeclared in the header file and the header file isn&#39;t  #included in thetarget file, it won&#39;t compile. The  addprefix function at the end does justwhat you&#39;d expect, since our compiler needs the little  -I flags in front ofour include directories to know to look there for our stuff.</p><p>我们声明包含所有包含文件的文件夹，用.h文件扩展名表示。Include文件通过保存函数声明让我们单独的C/C++文件使用彼此的函数，您可以通过#include；ome efile.h&#34；指令告诉编译器您想要什么函数。注意(也很容易忘记)您的不同源文件不会自动知道彼此包含什么，这一点非常重要。如果它未在头文件中声明，而头文件未包含在目标文件中，则它将不会编译。末尾的addprefix函数做的正是您所期望的，因为我们的编译器需要知道我们前面的include目录前面的小-i标志来查找我们的内容。</p><p> We declare any compiler options, or flags, that are necessary to make thefinal binary file that will be saved in the microcontroller memory. I&#39;ll gointo exactly what flags you should use a little later in this post.</p><p>我们声明任何编译器选项或标志，它们是生成将保存在微控制器存储器中的最终二进制文件所必需的。稍后我将详细介绍你应该在这篇文章中使用哪些旗帜。</p><p> We declare all of the linker files, indicated by the .ld file extension, thatwe need to use. Linker files are actually for another program by the peopleat the Free Software Foundation, appropriately called  ld (now the fileextension makes sense).  ld is automatically called by  gcc or  g++, thetwo primary C/C++ compilers, so we don&#39;t have to worry about the nittygritty. Basically though,  ld helps tell the compiler  how our program isaligned when it&#39;s finally compiled. More on this later.</p><p>我们声明我们需要使用的所有链接器文件(由.ld文件扩展名指示)。链接器文件实际上是由自由软件基金会(Free Software Foundation)的人为另一个程序编写的，恰当地称为ld(现在文件扩展名是有意义的)。LD是由GCC或g++这两个主要的C/C++编译器自动调用的，因此我们不必担心细节问题。不过，本质上说，ld帮助编译器告诉编译器，当我们的程序最终编译时，它是如何对齐的。稍后会详细介绍这一点。</p><p> The last two blocks of this  Makefile snippet is where the magic happens. These are rules, which  make will use to compile your program. The syntax ofa rule is:</p><p>这段Makefile代码的最后两个块是魔术发生的地方。这些是规则，make将用来编译您的程序。规则的语法为：</p><p>  The first rule is a special kind of rule in  make called a  patternrule. This rule tells  make that if we ever want to makean object file (i.e.  target = %.o) out of a source file (i.e.  dependencies =%.c), we should use the commands specified below by the four-spaceindentation. But what on earth was that command given in the example above?</p><p>第一条规则是make中的一种特殊规则，称为模式规则。这条规则告诉make，如果我们想从源文件(即依赖关系=%.c)生成目标文件(即target=%.o)，我们应该使用下面由四个空格缩进指定的命令。但是，上面示例中给出的命令究竟是什么呢？</p><p>  As we&#39;ve mentioned before,  gcc is a compiler; the  -c flag specifies that wewant to compile a source file, and the  -o flag says that the next argumentwill be the name of the output file. And that name is...  $@?</p><p>正如我们前面提到的，GCC是一名编译器；-c标志指定我们要编译源文件，-o标志说明下一个参数将是输出文件的名称。那个名字就是..。$@？</p><p> Turns out, there&#39;s one last little thing about  make we need to learn: automatic variables. You can read the doc page about all thedifferent automatic variables that  make provides you, but we&#39;re going tofocus on the two that we just used here:</p><p>事实证明，关于make，我们还需要学习最后一件小事：自动变量。您可以阅读有关Make提供给您的所有不同自动变量的文档页面，但我们将重点介绍这里刚刚使用的两个变量：</p><p> $&lt; represents the  first dependency to the right of the colon. In thiscase, since only one dependency is listed,  $&lt; == %.c.</p><p>$&lt；表示冒号右侧的第一个依赖项。在本例中，由于只列出了一个依赖项，因此$&lt；==%.c。</p><p> So, after doing a little translation, we see that the pattern rule is telling make that for every source file ( %.c) that we want to turn into an objectfile ( %.o), it should call our compiler ( gcc), tell it to compile ( -c)our source file ( $&lt;) into the output file ( -o $@) with some compileroptions that we specify ( $(CFLAGS)). Not too bad! You&#39;re already on your wayto [groking][grok_article]  make.</p><p>因此，在做了一些转换之后，我们看到模式规则告诉我们，对于我们想要转换为对象文件(%.o)的每个源文件(%.c)，它应该调用我们的编译器(GCC)，告诉它使用我们指定的一些编译器选项($(CFLAGS))将源文件($&lt；)编译(-c)到输出文件(-o$@)。还不错！你已经在去[摸索][摸索文章]的路上了。</p><p>   We&#39;ve pretty much covered everything in this rule except for the  $^ variable,which is just another  automatic variable.  $^ stands for every file in the dependencies list, as opposed to  $&lt;, which onlyrepresents the  first. A cheesy way to remember that is to look at thedirection of the arrow! And armed with that last little bit of knowledge, wecan confidently translate this last rule:</p><p>我们几乎涵盖了这条规则中的所有内容，除了$^变量，它只是另一个自动变量。$^代表依赖项列表中的每个文件，而$&lt；只代表第一个文件。记住这一点的一种俗气的方法是看箭头的方向！有了最后一点知识，我们可以自信地解释最后这条规则：</p><p> Take all our source files ( $(SRCS)), and make them into a final output binarycalled  final_binary.elf. To do that, call our compiler ( gcc), tell it whereour include directories are ( $(INCLUDE)), specify our compiler options( $(CFLAGS)) and our linker files ( $(LFLAGS)), and finally give it all oursource files ( $^) and tell it what we want the output to be ( -o $@).</p><p>获取我们所有的源文件($(SRCS))，并将它们转换为最终的输出二进制文件，名为finalbinary.elf。为此，请调用我们的编译器(GCC)，告诉它我们的包含目录在哪里($(INCLUDE))，指定我们的编译器选项($(CFLAGS))和链接器文件($(LFLAGS))，最后给它所有的源文件($^)，并告诉它我们希望输出是什么(-o$@)。</p><p>   Because of some of the unique aspects of programming for a microcontroller, weneed to be a little more explicit with  make about some things. This is where Liviu&#39;s blog post really gave me some crucialguidance; also, this is where we can see how building a  Makefile lets us peekinto the mystery of what happens when we hit the &#34;compile and run&#34; button on anIDE.</p><p>由于微控制器编程的一些独特方面，我们需要在一些事情上更明确一些。这就是Liviu的博客文章真正给了我一些至关重要的指导的地方；同时，这也是我们可以看到构建Makefile如何让我们窥探当我们点击IDE上的编译和运行按钮时会发生什么的神秘之处。</p><p> Firstly, we need to specify what kind of compiler we&#39;ll use. While you may have gcc or  g++ installed on you machine, they are built to compile programs on your computer architecture. We&#39;ll need a special version of  gcc, called a cross-compiler, so that we can compile across architectures to the ARMarchitecture. You can download it from  this site mirror, orlook for it in a package manager like  homebrew (OSX),  apt-get (Ubuntu),  pacman (for Arch Linux), or similar for your distro.</p><p>首先，我们需要指定我们将使用哪种编译器。虽然您的计算机上可能安装了GCC或g++，但它们是为在您的计算机体系结构上编译程序而构建的。我们需要GCC的一个特殊版本，称为交叉编译器，这样我们就可以跨体系结构编译成ARMarchitecture。你可以从这个镜像站点下载它，或者在软件包管理器中寻找它，比如HOMEBREW(OSX)、APT-GET(Ubuntu)、Pacman(适用于Arch Linux)，或者与您的发行版类似的包管理器。</p><p> Once you&#39;ve got the cross-compiler toolset installed, the programs will probably have really long names ( arm-none-eabi-g++, for example). That&#39;sgoing to be a pain to type all over your  Makefile, so you can make variablesto hold the path to your tools. I used  TOOLS_DIR to hold the path to theexecutables directory in the cross-compiler toolset, and then specifiedthe tools I&#39;d be using:</p><p>一旦安装了交叉编译器工具集，程序可能会有很长的名称(例如，arm-one-eabi-g++)。在你的Makefile中打字会很麻烦，所以你可以制作变量来保存你工具的路径。我使用TOOLS_DIR保存交叉编译器工具集中可执行文件目录的路径，然后指定我将使用的工具：</p><p>  Next, we need to specify the  CFLAGS that will help us to compile our program.Liviu&#39;s  Makefile was extremely helpful in that it logically grouped theflags, so we can get a better idea of what&#39;s going on. I&#39;m not going to give anexact description of each flag (you can look up the linked docs for that), but Iwill give an overview of each group:</p><p>接下来，我们需要指定帮助我们编译程序的CFLAGS。Liviu的Makefile非常有用，因为它对标志进行了逻辑分组，因此我们可以更好地了解正在发生的事情。我不会给出每个标志的确切描述(您可以在链接的文档中查找)，但我会给出每个组的概述：</p><p> CFLAGS = -ggdb sets  debugging options so that the compiler will sendinformation in a format that  gdb, the debugging program we&#39;ll be usinglater, can understand.</p><p>Cflags=-ggdb设置调试选项，以便编译器以我们稍后将使用的调试程序gdb可以理解的格式发送信息。</p><p> CFLAGS += -O0 tells the compiler to  perform no optimizations on the code.This is important for using the debugging program  gdb. You can increasethis number later on, but only do so with thorough testing and once you areready to stop using  gdb.</p><p>CFLAGS+=-O0告诉编译器不要对代码执行优化，这对于使用调试程序gdb很重要。您可以稍后增加这个数字，但只有在进行彻底测试并准备停止使用gdb时才能这样做。</p><p> CFLAGS += -Wall -Wextra -Warray-bounds all set  warning optionsso that the compiler will yell at you when certain conditions aren&#39;t met byyour code. Great for catching errors before runtime!</p><p>CFLAGS+=-WALL-WEXTRA-WARRAY-BILDES全部设置警告选项，以便当您的代码不满足某些条件时，编译器会对您大喊大叫。非常适合在运行前捕获错误！</p><p> CFLAGS += -mlittle-endian -mthumb -mcpu=cortex-m4 -mthumb-interwork alltell the compiler  machine-dependent options. This isinformation about the ARM processor (i.e. little endian, THUMB ISA, cortex-m4cpu, etc.).</p><p>CFLAGS+=-mLittle-endian-mhumb-mcpu=corest-m4-mhumb-interwork都告诉编译器机器相关的选项。这是关于ARM处理器的信息(例如，Little endian、Thumb ISA、corlet-m4cpu等)。</p><p> CFLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16 tell the compiler moremachine-dependent options, but these specifically relate to the handling offloating point numbers.</p><p>CFLAGS+=-mflol-abi=hard-mfpu=fpv4-sp-d16告诉编译器更多与机器相关的选项，但这些选项特别涉及处理偏移点编号。</p><p> CFLAGS += -felide-constructors -std=c++0x all specify  C++ languageoptions. These are rules about C++ that the compiler will enforce,allowing it to selectively allow or restrict whether some language featurewill compile. It isn&#39;t obvious at first glance what the  -felide-constructorsflag does; however, it allows for a memory optimization during the use ofcopy constructors in C++ (read docs for more info).</p><p>CFLAGS+=-Felide-structors-std=c++0x都指定了C++语言选项。这些是编译器将强制执行的关于C++的规则，允许它有选择地允许或限制某些语言功能是否将编译。乍一看，-Felide-structorsflag的作用并不明显；但是，在C++中使用Copy构造函数时，它允许优化内存(有关更多信息，请阅读文档)。</p><p> Now that we&#39;ve gotten the  CFLAGS straightened out, we can turn our focus tomaking our life easier when we need to configure the project. The first thingwe&#39;ll want to do is specify our  SRC_DIRS, much in the same way we specifiedour  INC_DIRS. The benefit to this is that we can then add the followingcommands to our  Makefile:</p><p>现在我们已经理顺了CFLAGS，当我们需要配置项目时，我们可以将重点转向让我们的生活变得更容易。我们要做的第一件事是指定我们的SRC_DIR，很大程度上与我们指定INC_DIR的方式相同。这样做的好处是，然后我们可以将以下命令添加到Makefile：</p><p>  These commands will tell  make to look in these source directories to find anysource file that it can&#39;t find in the current directory. Now, when we specifythe  SRCS variable, we don&#39;t have to type out the full path to every sourcefile. Instead, we can just list the file name with no path:</p><p>这些命令将告诉make在这些源目录中查找在当前目录中找不到的AnySource文件。现在，当我们指定SRCS变量时，我们不必键入每个源文件的完整路径。相反，我们可以只列出不带路径的文件名：</p><p>  Finally, we&#39;re going to put all this  make knowledge to good use and puttogether a few more rules. Now that we have this great  Makefile structure,making new rules is a breeze:</p><p>最后，我们将把所有这些知识很好地利用起来，并整理出更多的规则。既然我们有了这个很棒的Makefile结构，那么制定新规则就轻而易举了：</p><p> .PHONY :  $( PROJ_NAME ) $(PROJ_NAME) :  $( PROJ_NAME ). elf %.o : %. c  $(CC ) -c -o  $@  $&lt;  $(CFLAGS ) $(PROJ_NAME).elf :  $( SRCS )  $(CC )  $(INCLUDE )  $(DEFS )  $(CFLAGS )  $(LFLAGS )  $^ -o  $@  $(OBJCOPY ) -O ihex  $(PROJ_NAME ).elf  $(PROJ_NAME ).hex  $(OBJCOPY ) -O binary  $(PROJ_NAME ).elf  $(PROJ_NAME ).bin clean : rm -f *.o  $(PROJ_NAME ).elf  $(PROJ_NAME ).hex  $(PROJ_NAME ).bin flash : st-flash write  $(PROJ_NAME ).bin 0x8000000</p><p>.PHONY：$(PROJ_NAME)$(PROJ_NAME)：$(PROJ_NAME)。精灵%.O：%。C$(Cc)-c-o$@$&lt；$(CFLAGS)$(PROJ_NAME).elf：$(SRCS)$(CC)$(INCLUDE)$(DEFS)$(CFLAGS)$(LFLAGS)$^-o$@$(OBJCOPY)-O ihex$(PROJ_NAME).elf$(PROJ_NAME).hex$(OBJCOPY)-O BINARY$(PROJ_NAME).elf$(PROJ_NAME).bin CLEAN：RM-f*.O$(PROJ_NAME).elf$(PROJ_NAME)。).hex$(PROJ_NAME).bin FLASH：ST-FLASH WRITE$(PROJ_NAME).bin 0x8000000。</p><p> Awesome! Now we&#39;ve got a powerful suite of  make rules. Let&#39;s see what we cando now:</p><p>太棒了！现在我们有了一套强大的制定规则。让我们看看我们现在能做些什么：</p><p> make: Just calling  make by itself will trigger the first rule in thefile. In this case, it just calls our project name, which depends on thefinal binary  .elf file. How does  make create that file? It looks up arule for it, and a match is found at rule 3! And thus, our program binary isbuilt using the compiler options and files we specified previously.</p><p>Make：仅调用make本身就会触发文件中的第一个规则。在本例中，它只调用我们的项目名称，这取决于最终的二进制.elf文件。Make如何创建该文件？它查找规则以查找它，并且在规则3处找到了匹配项！因此，我们的程序二进制文件是使用前面指定的编译器选项和文件构建的。</p><p> make clean: This will delete all relevant output files from our workspace.Great for making sure you have a clean start when you&#39;re rebuilding yourproject.</p><p>清理：这将从我们的工作区中删除所有相关的输出文件。这对于确保您在重新生成项目时有一个干净的开始非常有用。</p><p> make flash: This will call an external program  st-flash to flash a copyof the .elf file with a .bin extension into the microcontroller.  0x8000000is a STM32F4-specific address where user code is supposed to be loaded.</p><p>制作闪存：这将调用外部程序st-flash将扩展名为.bin的.elf文件的副本闪存到微控制器中。0x8000000是STM32F4特定的地址，用户代码应该加载到该地址。</p><p> Using these tools, we have made a master  Makefile that does all the heavylifting of getting our sources, include paths, and configurations for ARM straightened out. Now we can focus on coding! Check out the  FreePulserepository for a real-world example of the Makefile we just outlined.</p><p>使用这些工具，我们已经创建了一个主Makefile，它完成了获取源代码、包括路径和ARM配置的所有繁重工作。现在我们可以专注于编码了！查看FreePulserepository，获取我们刚才概述的Makefile的真实示例。</p><p>  In my next blog post, I&#39;m going to cover how you can use  vim and the youcompleteme autocompletion engine and syntax checker to build a light andpowerful coding workspace. Later in that post, I&#39;ll also cover how to build a simple command line console logger using the USART interface on the STM32F4.</p><p>在我的下一篇博客文章中，我将介绍如何使用VIM和You Complete自动完成引擎和语法检查器来构建一个轻便而强大的编码工作空间。在那篇文章的后面，我还将介绍如何在STM32F4上使用USART接口构建一个简单的命令行控制台记录器。</p><p> Hopefully these posts will serve as useful references for how to begin anembedded development project independent of an IDE! Feel free to check out the FreePulse repository to see code examples of how this is implemented in a project.</p><p>希望这些帖子能作为如何开始独立于IDE的嵌入式开发项目的有用参考！您可以随时查看FreePulse存储库，查看如何在项目中实现此功能的代码示例。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://reecestevens.me/blog/2016/07/08/embedded-programming-without-ide/">http://reecestevens.me/blog/2016/07/08/embedded-programming-without-ide/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ide/">#ide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031098.html"><img src="http://img2.diglog.com/img/2020/10/thumb_cc2953afaaa8b4e0287395dbd7e10605.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031098.html">您一直错过的反应式编程入门</a></div><span class="my_story_list_date">2020-10-25 23:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030894.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c95c6640c04b0b64f58812e5c40b98fc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030894.html">安全系统编程为何生锈</a></div><span class="my_story_list_date">2020-10-24 8:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030555.html"><img src="http://img2.diglog.com/img/2020/10/thumb_66677dbb1fb90331051acf350be81b57.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030555.html">循序渐进：增量编程</a></div><span class="my_story_list_date">2020-10-22 22:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030394.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2c2bdfa2dc7529c1988bef213a9e80ef.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030394.html">Kite将其AI代码完成从2种扩展到13种编程语言</a></div><span class="my_story_list_date">2020-10-22 9:12</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>