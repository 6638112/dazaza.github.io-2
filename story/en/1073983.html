<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>了解AIX Power SMT系统上的CPUUnderstanding CPU on AIX Power SMT Systems</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Understanding CPU on AIX Power SMT Systems<br/>了解AIX Power SMT系统上的CPU</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 01:41:56</div><div class="page_narrow text-break page_content"><p>This month I worked with a chicagoland company to improve performance for eBusiness Suite on AIX. I’ve worked with databases running on AIX a number of times over the years now. Nevertheless, I got thrown for a loop this week.</p><p>本月，我与芝加哥的一家公司合作，以提高AIX上电子商务套件的性能。多年来，我已经多次使用AIX上运行的数据库。尽管如此，这周我还是陷入了困境。</p><p> TLDR: In the end, it came down to a fundamental change in resource accounting that IBM introduced with the POWER7 processor in 2010. The bottom line is twofold:</p><p>TLDR：归根结底，这是IBM在2010年推出POWER7处理器时对资源计费的一个根本性改变。底线有两个：</p><p> if SMT is enabled then the meaning of CPU utilization numbers is changed.  the CPU utilization numbers for individual processes mean something completely new.</p><p>如果启用了SMT，那么CPU利用率数字的含义就会改变。单个进程的CPU利用率数字意味着一些全新的东西。</p><p> oracle database 11.2.0.3 (I haven’t tested newer versions but they might also be affected) is not aware of this change. as a result,  all CPU time values captured in AWR reports and extended SQL traces are wrong and misleading if it’s running on AIX/POWER7/SMT. (I haven’t tested CPU time values at other places in the database but they might also be wrong.)</p><p>oracle database 11.2.0.3（我没有测试新版本，但它们可能也会受到影响）没有意识到这一变化。因此，如果在AIX/POWER7/SMT上运行，AWR报告和扩展SQL跟踪中捕获的所有CPU时间值都是错误的和误导性的。（我没有在数据库的其他地方测试CPU时间值，但它们也可能是错误的。）</p><p> On other unix operating systems (for example Linux with Intel Hyper-Threading), the CPU numbers for an individual process reflect the  time that the process spent on the CPU. It’s pretty straightforward: 100% means that the process is spending 100% of its time on the logical CPU (a.k.a. thread – each hardware thread context on a hyper-threaded core appears as a CPU in Linux). However AIX with SMT is different. On AIX, when you look at an individual process, the CPU utilization numbers reflect IBM’s opinion about what  percentage of physical capacity is being used.</p><p>在其他unix操作系统（例如带有英特尔超线程的Linux）上，单个进程的CPU数反映了该进程在CPU上花费的时间。这很简单：100%意味着进程在逻辑CPU上花费了100%的时间（也称为线程——超线程内核上的每个硬件线程上下文在Linux中都显示为CPU）。然而，使用SMT的AIX则不同。在AIX上，当您查看单个进程时，CPU利用率数字反映了IBM对物理容量使用百分比的看法。</p><p> Why did IBM do this? I think that their overall goal was to help us in system-wide monitoring and capacity planning – however it came at the expense of tuning individual processes. They are trying to address real shortcomings inherent to SMT – but as someone who does a lot of performance optimization, I find that their changes made my life a lot more difficult!</p><p>IBM为什么这么做？我认为他们的总体目标是帮助我们进行全系统的监控和能力规划——但这是以调整单个流程为代价的。他们试图解决SMT固有的真正缺点——但作为一个做了大量性能优化的人，我发现他们的改变让我的生活更加困难！</p><p>  Ls Cheng started a  conversation in November 2012 on the Oracle-L mailing list about his database on AIX with SMT enabled, where the CPU numbers in the AWR report didn’t even come close to adding up correctly. Jonathan Lewis argued that double-counting was the simplest explanation while Karl Arao made the case for time in the CPU run queue. A final resolution as never posted to the list – but in hindsight it was almost certainly the same problem I’m investigating in this article. It fooled all of us.  CPU intensive workloads on AIX/Power7/SMT will frequently mislead performance experts into thinking there is a CPU runqueue problem at the OS level. In fact, after researching for this article I went back and looked at my own final report from a consulting engagement with an AIX/SMT client back in August 2011 and realized that I made this mistake myself!</p><p>Ls Cheng于2012年11月在Oracle-L邮件列表上开始了一次对话，讨论了他在启用了SMT的AIX上的数据库，AWR报告中的CPU数甚至没有正确相加。乔纳森·刘易斯（Jonathan Lewis）认为重复计算是最简单的解释，而卡尔·阿拉奥（Karl Arao）则提出了CPU运行队列中的时间的理由。最终的解决方案从未公布在清单上——但事后看来，这几乎肯定与我在本文中研究的问题相同。它愚弄了我们所有人。AIX/Power7/SMT上的CPU密集型工作负载经常会误导性能专家，让他们认为操作系统级别存在CPU运行队列问题。事实上，在为本文做了研究之后，我回去查看了我自己在2011年8月与AIX/SMT客户进行咨询时的最终报告，并意识到我自己犯了这个错误！</p><p> As far as I’m aware, Marcin Przepiorowski was the first person to really “crack” the case when and he researched and published a detailed explanation back in  February 2013 with his article  Oracle on AIX – where’s my cpu time?. Marcin was tipped off by Steve Pittman’s detailed explanation published in a  December 2012 article  Understanding Processor Utilization on Power Systems – AIX. Karl Arao was also researching it back in 2013 and  published a lot of information on his  tricky cpu aix stuff tiddlywiki page. Finally, Graham Wood was digging into it at the same time and contributed to several conversations amongst oak table members. Just to be clear that I’m not posting any kind of new discovery! :)</p><p>据我所知，Marcin Przepiorowski是第一个真正“破解”这个案子的人，他在2013年2月研究并发表了一篇详细的解释，文章是《AIX上的Oracle——我的cpu时间在哪里？》？。史蒂夫·皮特曼（Steve Pittman）在2012年12月的一篇文章《理解电力系统（AIX）上的处理器利用率》（Understanding Processor Utilization on Power Systems）中发表了详细的解释，马辛从中得到了消息。Karl Arao也在2013年对其进行了研究，并在其复杂的cpu aix工具tiddlywiki页面上发布了大量信息。最后，格雷厄姆·伍德（Graham Wood）同时也在深入研究，并为橡木桌成员之间的几次对话做出了贡献。我只是想明确一点，我没有发布任何新的发现！：）</p><p> However – despite the fact that it’s been in the public for a few years – most people don’t understand just how significant this is, or even understand exactly what the problem is in technical terms. So this is where I think I can make a contribution: by giving a few simple demonstrations of the behavior which Steve, Marcin and Karl have documented.</p><p>然而——尽管它已经公开了几年——大多数人都不知道这有多重要，甚至不知道技术上的问题到底是什么。这就是我认为我可以做出贡献的地方：通过对史蒂夫、马辛和卡尔记录的行为进行一些简单的演示。</p><p>  I recently spent a few years leading database operations for a cloud/SaaS company. Perhaps one of the most striking aspects of this job was that I had crossed over… from being one of the “young guys” to being one of the “old guys”! I certainly wasn’t the oldest guy at the company but more than half my co-workers were younger than me!</p><p>我最近花了几年时间为一家云/SaaS公司领导数据库操作。也许这份工作最引人注目的一个方面就是我从“年轻人”变成了“老家伙”！我当然不是公司里年龄最大的人，但有一半以上的同事比我年轻！</p><p> Well my generation might be the last one to remember owning personal computers that didn’t multitask. Ok… I know that I’m still working alongside plenty of folks who learned to program on punch-cards. But at the other end of the spectrum, I think that DOS was already obsolete when many of my younger coworkers starting using technology! Some of you younger devs started with Windows 95. You’ve always had computers that could run two programs in different windows at the same time.</p><p>嗯，我这一代人可能是最后一个记得拥有没有多任务的个人电脑的人。好吧……我知道我仍然和很多学会用穿孔卡片编程的人一起工作。但另一方面，当我的许多年轻同事开始使用技术时，我认为DOS已经过时了！你们中的一些年轻开发人员是从Windows 95开始的。你的电脑总是可以在不同的窗口同时运行两个程序。</p><p> Sometimes you take a little more notice of tech advancements you personally experience and appreciate. I remember it being a big deal when my family got our first computer that could do more than one thing at a time! Multitasking (or time sharing) is not a complicated concept. But it’s important and foundational.</p><p>有时你会对自己亲身经历和欣赏的科技进步多加注意。我记得当我们家有了第一台一次可以做不止一件事的电脑时，这是一件大事！多任务（或分时）不是一个复杂的概念。但这很重要，也是基础性的。</p><p>  So obviously (I hope), if there are multiple processes and only a single CPU then the processes will take turns running. There are some nuances around if, when and how the operating system might force a process to get off the CPU but the most important thing to understand is just the timeline pictured above. Because for the rest of this blog post we will be talking about performance and time.</p><p>所以很明显（我希望），如果有多个进程，只有一个CPU，那么这些进程将轮流运行。关于操作系统是否、何时以及如何强制某个进程脱离CPU，存在一些细微差别，但最重要的是要理解上面所示的时间线。因为在这篇博文的其余部分，我们将讨论性能和时间。</p><p> Here is a concrete example of the illustration above: one core in my laptop CPU can copy 13GB of data through memory in about 4-5 seconds:</p><p>下面是一个具体的例子：我的笔记本电脑CPU的一个核心可以在大约4-5秒内通过内存复制13GB的数据：</p><p> $ time -p taskset 2 dd if=/dev/zero of=/dev/null bs=64k count=200k204800+0 records in204800+0 records out13421772800 bytes (13 GB) copied, 4.73811 s, 2.8 GB/sreal 4.74user 0.13sys 4.54</p><p>$time-p任务集2 dd if=/dev/zero of=/dev/null bs=64k count=200k</p><p>  The “taskset” command on linux pins a command on a specific CPU #2 – so “dd” is only allowed to execute on that CPU. This way, my example runs exactly like the illustration above, with just a single CPU.</p><p>linux上的“taskset”命令将命令固定在特定的CPU#2上，因此“dd”只能在该CPU上执行。这样，我的示例运行起来与上图完全相同，只有一个CPU。</p><p>  $ time -p taskset 2 dd if=/dev/zero of=/dev/null bs=64k count=200k &amp;[1] 18740$ time -p taskset 2 dd if=/dev/zero of=/dev/null bs=64k count=200k &amp;[2] 18742204800+0 records in204800+0 records out13421772800 bytes (13 GB) copied, 9.25034 s, 1.5 GB/sreal 9.25user 0.09sys 4.57204800+0 records in204800+0 records out13421772800 bytes (13 GB) copied, 9.22493 s, 1.5 GB/sreal 9.24user 0.12sys 4.54[1]- Done time -p taskset 2 dd if=/dev/zero of=/dev/null bs=64k count=200k[2]+ Done time -p taskset 2 dd if=/dev/zero of=/dev/null bs=64k count=200k</p><p>$time-p任务集2 dd if=/dev/zero of=/dev/null bs=64k count=200k&amp；</p><p> Naturally, it takes twice as long – 9-10 seconds. I ran these commands on my linux laptop but the same results could be observed on any platform. By the way, notice that the “sys” number was still 4-5 seconds. This means that each process was actually executing on the CPU for 4-5 seconds even though it took 9-10 seconds of wall clock time.</p><p>当然，这需要两倍的时间——9-10秒。我在linux笔记本电脑上运行了这些命令，但在任何平台上都可以观察到相同的结果。顺便说一句，请注意“sys”数字仍然是4-5秒。这意味着每个进程实际上在CPU上执行了4-5秒，尽管它需要9-10秒的挂钟时间。</p><p> The “time” command above provides a summary of how much real (wall-clock) time has elapsed and how much time the process was executing on the CPU in both user and system modes. This time is tracked and accounted for by the operating system kernel. The linux “time” command uses the wait4() system call to retrieve the CPU accounting information. This can be verified with strace:</p><p>上面的“time”命令提供了实际（挂钟）时间的摘要，以及进程在用户和系统模式下在CPU上执行的时间。这段时间由操作系统内核进行跟踪和说明。linux“time”命令使用wait4（）系统调用来检索CPU记帐信息。这可以通过strace进行验证：</p><p> $ strace -t time -p dd if=/dev/zero of=/dev/null bs=64k count=200k10:07:06 execve(&#34;/usr/bin/time&#34;, [&#34;time&#34;, &#34;-p&#34;, &#34;dd&#34;, &#34;if=/dev/zero&#34;, &#34;of=/dev/null&#34;, \ &#34;bs=64k&#34;, &#34;count=200k&#34;], [/* 48 vars */]) = 0...10:07:06 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, \ child_tidptr=0x7f8f841589d0) = 1285110:07:06 rt_sigaction(SIGINT, {SIG_IGN, [INT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, \ {SIG_DFL, [], 0}, 8) = 010:07:06 rt_sigaction(SIGQUIT, {SIG_IGN, [QUIT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, \ {SIG_IGN, [], 0}, 8) = 0 10:07:06 wait4(-1, 204800+0 records in204800+0 records out13421772800 bytes (13 GB) copied, 4.66168 s, 2.9 GB/s [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], 0, {ru_utime={0, 108000}, \ ru_stime={4, 524000}, ...}) = 1285110:07:11 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=12851, si_uid=1000, \ si_status=0, si_utime=10, si_stime=454} ---10:07:11 rt_sigaction(SIGINT, {SIG_DFL, [INT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, \ {SIG_IGN, [INT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, 8) = 010:07:11 rt_sigaction(SIGQUIT, {SIG_IGN, [QUIT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, \ {SIG_IGN, [QUIT], SA_RESTORER|SA_RESTART, 0x7f8f83be90e0}, 8) = 010:07:11 write(2, &#34;r&#34;, 1r) = 110:07:11 ...</p><p>$strace-t time-p dd if=/dev/zero of=/dev/null bs=64k count=200k</p><p> Two notes about this. First, you’ll see from the timestamps that there’s a 5 second pause during the wait4() syscall and the output from “dd” interrupts its output. Clearly this is when “dd” is running. Second, you’ll see that the wait4() call is returning two variables called  ru_utime and ru_stime. The man page on wait4() clarifies that this return parameter is the  rusage struct which is defined in the POSIX spec. The structure is defined in time.h and is the same structure returned by getrusage() and times(). This is how the operating system kernel returns the timing information to “time” for display on the output.</p><p>关于这一点，有两个注释。首先，您将从时间戳中看到，在wait4（）系统调用期间有5秒的暂停，“dd”的输出会中断其输出。显然，这是“dd”运行的时候。其次，您将看到wait4（）调用返回两个变量，分别为ru_utime和ru_stime。wait4（）上的手册页阐明了该返回参数是POSIX规范中定义的rusage结构。该结构是及时定义的。h和是getrusage（）和times（）返回的相同结构。这就是操作系统内核如何将计时信息返回到“time”以便在输出上显示的方式。</p><p>  Since many people are familiar with Linux, it will be helpful to provide a side-by-side comparison of Linux/Intel/Hyper-Threading with AIX/Power7/SMT. This will also help clarify exactly what AIX is doing that’s so unusual.</p><p>由于许多人都熟悉Linux，因此提供Linux/Intel/Hyper-Threading与AIX/Power7/SMT的并行比较将很有帮助。这也将有助于明确AIX到底在做什么，这很不寻常。</p><p> For this comparison, we will switch to  Amos Waterland’s useful stress utility for CPU load generation. This program is readily available for all major unix flavors and cleanly loads a CPU by spinning on the sqrt() function. I found a copy at  perzl.org already ported and packaged for AIX on POWER.</p><p>为了进行比较，我们将切换到Amos Waterland的有用的压力实用程序来生成CPU负载。该程序可用于所有主要的unix版本，并通过旋转sqrt（）函数干净地加载CPU。我在佩兹找到了一份。org已经为POWER上的AIX进行了移植和打包。</p><p> For our comparison, we will load a single idle CPU for 100 seconds of wall-clock time. We know that the process will spin on the CPU for all 100 seconds, but lets see how the operating system kernel reports it.</p><p>为了进行比较，我们将加载一个空闲CPU 100秒的挂钟时间。我们知道进程将在CPU上旋转100秒，但让我们看看操作系统内核如何报告它。</p><p>  user@debian:~$ lscpu | egrep &#39;(per|name)&#39; Thread(s) per core: 2Core(s) per socket: 2Model name: Intel(R) Core(TM) i3-4005U CPU @ 1.70GHz</p><p>user@debian：~$lscpu |白鹭#39；（姓名）和#39；</p><p> Next lets run our stress test (pinned to a single CPU) and see what the kernel reports for CPU usage:</p><p>接下来，让我们运行我们的压力测试（固定在单个CPU上），并查看内核报告的CPU使用情况：</p><p> user@debian:~$ time -p taskset 2 stress -c 1 -t 100stress: info: [20875] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hddstress: info: [20875] successful run completed in 100sreal 100.00user 100.03sys 0.00</p><p>user@debian：~$time-p任务集2压力-c1-t100</p><p> Just what we would expect – the system is idle, and the process was on the CPU for all 100 seconds.</p><p>正如我们所料，系统处于空闲状态，进程在CPU上持续了100秒。</p><p> Now lets use mpstat to look at the utilization of CPU #2 in a second window:</p><p>现在，让我们使用mpstat在第二个窗口中查看CPU#2的利用率：</p><p> user@debian:~$ mpstat -P 1 10 12Linux 3.16.0-4-amd64 (debian) 	06/30/2016 	_x86_64_	(4 CPU)01:58:07 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle01:58:17 AM 1 0.00 0.00 0.10 0.00 0.00 0.00 0.00 0.00 0.00 99.9001:58:27 AM 1 17.44 0.00 0.10 0.00 0.00 0.00 0.00 0.00 0.00 82.4501:58:37 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:58:47 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:58:57 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:07 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:17 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:27 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:37 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:47 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:59:57 AM 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0002:00:07 AM 1 82.88 0.00 0.10 0.00 0.00 0.00 0.00 0.00 0.00 17.02Average: 1 83.52 0.00 0.03 0.00 0.00 0.00 0.00 0.00 0.00 16.45</p><p>user@debian：~$mpstat-P1010 12页</p><p> Again, no surprises here. We see that the CPU was running at 100% for the duration of our stress test.</p><p>同样，这里没有什么意外。我们看到，在压力测试期间，CPU以100%的速度运行。</p><p> Next lets check the system-wide view. On linux, most people use the  top command to see what’s happening system-wide. Top shows a list of processes and estimates how much time each spends on the CPU. Note that the “top” utility is using the /proc/&lt;PID&gt;/stat file to get kernel-tracked CPU time rather than libc calls – but this still returns the same data as the “time” command. It then divides by wall-clock time to express the CPU time as a percentage. If two processes are running on one CPU, then each process will report 50% CPU utilization (in the default Irix mode).</p><p>接下来，让我们检查系统范围的视图。在linux上，大多数人使用top命令来查看系统范围内发生了什么。顶部显示进程列表，并估计每个进程在CPU上花费的时间。请注意，“top”实用程序使用的是/proc/&lt；PID&gt/stat文件来获取内核跟踪的CPU时间，而不是libc调用——但这仍然会返回与“time”命令相同的数据。然后除以墙上的时钟时间，以百分比的形式表示CPU时间。如果两个进程在一个CPU上运行，那么每个进程将报告50%的CPU利用率（在默认的Irix模式下）。</p><p> We will run top in a third window while the stress and mpstat programs are running to get the system-wide view:</p><p>我们将在第三个窗口中运行top，同时运行stress和mpstat程序以获得系统范围的视图：</p><p>  Linux top (in Irix mode) reports that the “stress” program is using 100% of a single CPU and that 26.3% of my total CPU capacity is used by the system.</p><p>LinuxTop（在Irix模式下）报告说，“压力”程序使用了100%的单个CPU，系统使用了我总CPU容量的26.3%。</p><p> This is wrong. Did you spot the problem with my statement above? If you have any linux servers with hyper-threading enabled then I really hope you understand this!</p><p>这是错误的。你发现我上述陈述的问题了吗？如果你有任何支持超线程的linux服务器，那么我真的希望你能理解这一点！</p><p> The problem is with the second statement – that 26% of my total CPU capacity is used. In reality, a “hardware thread” is nothing like a “real core”. (For  Oracle specific details about Hyper-Threading and CPU Capacity,  Karl Arao might be one of the best sources of information.) Linux kernel developers represent each hardware thread as a logical CPU. As a result (and this is counter-intuitive) it’s very misleading to look at that “total CPU utilization” number as something related to total CPU capacity.</p><p>问题在于第二种说法——我总CPU容量的26%被使用了。实际上，“硬件线程”与“真正的核心”完全不同。（对于Oracle有关超线程和CPU容量的详细信息，Karl Arao可能是最好的信息来源之一。）Linux内核开发人员将每个硬件线程表示为一个逻辑CPU。因此（这是违反直觉的）将“总CPU利用率”视为与总CPU容量相关的数字是非常误导的。</p><p> What does this mean for you?  You must set your CPU monitoring thresholds on Linux/Hyper-Threading very low. You might set your critical threshold for paging at 70%. Personally, I like to keep utilization on transactional systems under 50%. If your hyper-threaded linux system has 70% CPU utilization, then you are going to run out of CPU very soon!</p><p>这对你意味着什么？必须将Linux/超线程上的CPU监控阈值设置得非常低。您可以将分页的临界阈值设置为70%。就个人而言，我喜欢将事务系统的利用率保持在50%以下。如果你的超线程linux系统有70%的CPU利用率，那么你很快就会耗尽CPU！</p><p> Why is this important?  This is exactly the problem that IBM’s AIX team aimed to solve with SMT on POWER. But there is a catch: the source data used by standard tools to calculate system-level CPU usage is the POSIX-defined “rusage” process accounting information. IBM tweaked the meaning of rusage to fix our system-level CPU reporting problem – and they introduced a new problem at the individual process level. Lets take a look.</p><p>为什么这很重要？这正是IBM的AIX团队使用SMT on POWER解决的问题。但有一个问题：标准工具用于计算系统级CPU使用率的源数据是POSIX定义的“rusage”进程会计信息。IBM调整了rusage的含义，以解决我们的系统级CPU报告问题，并在单个进程级别引入了一个新问题。我们来看看。</p><p>   # prtconf|grep ProcessorProcessor Type: PowerPC_POWER7Processor Implementation Mode: POWER 7Processor Version: PV_7_CompatNumber Of Processors: 4Processor Clock Speed: 3000 MHz Model Implementation: Multiple Processor, PCI bus+ proc0 Processor+ proc4 Processor+ proc8 Processor+ proc12 Processor# lparstat -i|egrep &#39;(Type|Capacity )&#39; Type : Shared-SMT-4Entitled Capacity : 2.00Minimum Capacity : 2.00Maximum Capacity : 4.00</p><p>#prtconf | grep处理器</p><p> So you can see that we’re working with 2 to 4 POWER7 processors in SMT4 mode, which will appear as 8 to 16 logical processors.</p><p>所以你可以看到，我们在SMT4模式下使用2到4个POWER7处理器，这将显示为8到16个逻辑处理器。</p><p>  # ps -o THREAD USER PID PPID TID ST CP PRI SC WCHAN F TT BND COMMANDjschneid 13238466 28704946 - A 0 60 1 - 240001 pts/0 - -kshjschneid 9044322 13238466 - A 3 61 1 - 200001 pts/0 - ps -o THREAD# bindprocessor 13238466 4# /usr/bin/time -p ./stress -c 1 -t 100stress: info: [19398818] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hddstress: info: [19398818] successful run completed in 100sReal 100.00User 65.01System 0.00</p><p>#ps-o螺纹</p><p> Wait… where did my CPU time go?! (This is one of the first things Marcin noticed too!) The AIX kernel reported that my process ran for 100 seconds of wall-clock time, but it was only running on the CPU for 65 seconds of that time!</p><p>等等…我的CPU时间到哪里去了？！（这也是马辛最先注意到的事情之一！）AIX内核报告我的进程运行了100秒的挂钟时间，但它只在CPU上运行了65秒！</p><p> On unix flavors such as Linux, this means that the  operating system was not trying to put the process on the CPU during the missing time. Maybe the process was waiting for a disk operation or a signal from another process. But our stress test only executes the sqrt() function – so we know that it was not waiting for anything.</p><p>在unix版本（如Linux）上，这意味着操作系统没有在丢失的时间内尝试将进程放在CPU上。可能进程正在等待磁盘操作或来自另一进程的信号。但是我们的压力测试只执行sqrt（）函数，所以我们知道它没有等待任何东西。</p><p> When you know the process was not waiting, there is only other reason the operating system wouldn’t put the process on the CPU. Look again at our very first demo in this article: two (or more) processes needed to share the CPU. And notice that the user+system time was lower than wall-clock time, exactly like our output here on AIX!</p><p>当您知道进程没有等待时，操作系统不会将进程放在CPU上的唯一原因是。再看看本文中的第一个演示：共享CPU需要两个（或更多）进程。请注意，用户+系统时间低于挂钟时间，与我们在AIX上的输出完全相同！</p><p> So lets take a look at the system-wide view with the “nmon” utility in a second window. (topas reports CPU usage solaris-style while nmon reports irix-style, so nmon will be more suitable for this test. they are actually the same binary anyway, just invoked differently.)</p><p>因此，让我们在第二个窗口中使用“nmon”实用程序来查看系统范围的视图。（topas报告的是solaris风格的CPU使用情况，而nmon报告的是irix风格的CPU使用情况，因此nmon更适合此测试。它们实际上是相同的二进制文件，只是调用方式不同而已。）</p><p>  Wait… this doesn’t seem right! Our “stress” process is the only process running on the system, and we know that it is just spinning CPU with the sqrt() call. The “nmon” tool seems to verify the output of the time command – that the process is only on the CPU for 65% of the time! Why isn’t AIX letting my process run on the CPU?!</p><p>等等…这好像不对！我们的“压力”进程是系统上运行的唯一进程，我们知道它只是通过sqrt（）调用来旋转CPU。“nmon”工具似乎验证了time命令的输出——进程只有65%的时间在CPU上！为什么AIX不让我的进程在CPU上运行？！</p><p> Lets take a look at the output of the mpstat command, which we are running in our third window:</p><p>让我们看看mpstat命令的输出，我们在第三个窗口中运行该命令：</p><p> # mpstat 10 12|egrep &#39;(cpu|^ 4)&#39;System configuration: lcpu=16 ent=2.0 mode=Uncapped cpu min maj mpc int cs ics rq mig lpa sysc us sy wa id pc %ec lcs 4 0 0 0 2 0 0 0 1 100 0 0 49 0 51 0.00 0.0 1 4 19 0 40 143 7 7 1 1 100 19 100 0 0 0 0.61 30.7 7 4 0 0 0 117 2 2 1 1 100 0 100 0 0 0 0.65 32.6 4 4 0 0 0 99 1 1 1 1 100 0 100 0 0 0 0.65 32.6 3 4 0 0 0 107 3 3 1 3 100 0 100 0 0 0 0.65 32.6 6 4 0 0 0 145 5 5 1 3 100 0 100 0 0 0 0.65 32.6 9 4 0 0 0 113 2 2 1 1 100 0 100 0 0 0 0.65 32.6 3 4 0 0 0 115 1 1 1 1 100 0 100 0 0 0 0.65 32.6 7 4 0 0 0 106 1 1 1 1 100 0 100 0 0 0 0.65 32.6 2 4 0 0 0 113 1 1 1 1 100 0 100 0 0 0 0.65 32.6 5 4 0 0 41 152 2 2 1 1 100 0 100 0 0 0 0.65 32.6 3 4 5 0 0 6 0 0 0 1 100 4 100 0 0 0 0.04 1.8 1</p><p>#mpstat 10 12 |白鹭和#39；（cpu |^4）和#39；</p><p> Processor 4 is running at 100%. Right away you should realize something is wrong with how we are interpreting the nmon output – because our “stress” process is the only thing running on this processor. The mpstat utility is not using the kernel’s rusage process accounting data and it shows that our process is running on the CPU for the full time.</p><p>处理器4正在100%运行。您应该马上意识到，我们解释nmon输出的方式有问题，因为我们的“压力”进程是这个处理器上唯一运行的东西。mpstat实用程序没有使用内核的rusage进程记帐数据，它表明我们的进程是在CPU上全职运行的。</p><p> So… what in the world did IBM do? The answer – which  Steve and  Marcin published a few years ago – starts with the little mpstat column called “pc”. This stands for “physical consumption”. (It’s called “physc” in sar -P output and in topas/nmon.) This leads us to the heart of IBM’s solution to the system-wide CPU reporting problem.</p><p>那么，IBM到底做了什么？答案——史蒂夫和马辛几年前发表的——从名为“pc”的mpstat小专栏开始。这代表“物质消费”。（在sar-P输出和topas/nmon中称为“physc”。）这就引出了IBM解决全系统CPU报告问题的核心。</p><p> IBM is thinking about everything in terms of capacity rather than time. The pc number is a fraction that scales down utilization numbers to reflect utilization of the core (physical cpu) rather than the hardware thread (logical cpu). And in doing this, they don’t just divide by four on an SMT-4 chip. The fraction is dynamically computed by the POWER processor hardware in real time and exposed through a new register called PURR. IBM did a lot of testing and then – starting with POWER7 – they built the intelligence in to the POWER processor hardware.</p><p>IBM从容量而不是时间的角度来考虑一切。pc号是一个分数，它可以缩小利用率，以反映核心（物理cpu）而不是硬件线程（逻辑cpu）的利用率。在SMT-4芯片上，它们不只是除以4。功率处理器硬件实时动态计算分数，并通过名为PURR的新寄存器公开分数。IBM做了很多测试，然后——从POWER7开始——他们将智能内置到POWER处理器硬件中。</p><p> In our example, we are using one SMT hardware thread at 100% in SMT-4 mode. The POWER processor reports through the PURR register that this represents 65% of the processor’s capacity, exposed to us through the pc scale-down factor of 0.65 in mpstat.  My POWER7 processor claims it is only 65% busy when one if its four threads is running at 100%.</p><p>在我们的示例中，我们在SMT-4模式下100%使用一个SMT硬件线程。POWER处理器通过PURR寄存器报告，这代表处理器容量的65%，通过mpstat中的pc缩小系数0.65暴露给我们。我的POWER7处理器声称，如果一个处理器的四个线程以100%的速度运行，那么它只有65%的忙。</p><p> I also  ran the test using two SMT hardware threads at 100% on the same processor in SMT-4 mode. The processor scaled both threads down to 45% so that when you add them together, the processor is claiming that it’s 90% busy – though nmon &amp; topas will show each of the two processes running at only 45% of a CPU! When  all four threads are being used at 100% in SMT-4 mode then of course the processor will scale all four processes down to 25% – and the processor will finally show that it is 100% busy.</p><p>我还以SMT-4模式在同一个处理器上以100%的速度使用两个SMT硬件线程运行了测试。处理器将两个线程的规模缩小到45%，这样当你把它们加在一起时，处理器就声称它有90%的忙——尽管nmon&amp；topas将显示两个进程中的每一个仅以45%的CPU运行！当所有四个线程在SMT-4模式下以100%的速度使用时，处理器当然会将所有四个进程的规模缩小到25%——处理器最终会显示它是100%忙碌的。</p><p> On a side note, the %ec column is showing the physical consumption as a percentage of entitled capacity (2 processors). My supposed 65% utilization of a processor equates to 32.6% of my system-wide entitled capacity. Not coincidentally, topas shows the “stress” process running at 32.6% (like I said, solaris-style).</p><p>在旁注中，%ec列显示了实际消耗量占授权容量（2个处理器）的百分比。我假设的65%的处理器利用率相当于我整个系统容量的32.6%。并非巧合，topas显示的“压力”过程以32.6%的速度运行（就像我说的，solaris风格）。</p><p> So AIX is factoring in the PURR ratio when it populates the POSIX rusage process accounting structure. What is the benefit? Topas and other monitoring tools calculate system load by adding up the processor and/or process utilization numbers. By changing the meaning from time </p><p>因此，当AIX填充POSIX rusage进程记帐结构时，它会考虑PURR比率。好处是什么？Topas和其他监控工具通过计算处理器和/或进程利用率来计算系统负载。通过不断改变意思</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/aix/">#aix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpu/">#cpu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>