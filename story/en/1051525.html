<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Hybrid Apache arrow / numpy dataframe与vaex版本4.0 A Hybrid Apache Arrow/Numpy DataFrame with Vaex Version 4.0</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Hybrid Apache Arrow/Numpy DataFrame with Vaex Version 4.0<br/>Hybrid Apache arrow / numpy dataframe与vaex版本4.0 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 02:38:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/ea41118676f8c8f35635e79099b8a897.jpeg"><img src="http://img2.diglog.com/img/2021/3/ea41118676f8c8f35635e79099b8a897.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The Vaex DataFrame has always been very fast. Built from the ground up to be out of core (the size of your disk is the limit), it pushes the limits of what single machines can do in the context of big data analysis.Starting from version 2, we added better support for string data, giving an almost 1000x speedup compared to Pandas at the time. To support this seemingly trivial datatype, we had to choose a disk and memory format and did not want to reinvent the wheel. Apache Arrow was an obvious choice but did not meet the requirements at that time. However, we still added string support in Vaex, but in a future compatible way so that when the time arrives (now!), we can adopt Apache Arrow without rendering data from the past obsolete, or requiring data conversions. For compatibility with Apache Arrow, we developed the  vaex-arrow package, which made interoperability with Vaex smooth, at the cost of a possible memory copy here and there.</p><p>VAEX DataFrame一直非常快。从地面上构建的核心（磁盘的大小是限制），它推动了在大数据分析的上下文中可以做的单个机器的限制。从版本2开始，我们为字符串添加了更好的支持数据，与熊猫相比，近1000倍的加速。为了支持这一看似微不足道的数据类型，我们必须选择磁盘和内存格式，并且不想重新发明轮子。 Apache arrow是一个明显的选择，但没有达到当时的要求。但是，我们仍然在VAEX中添加了字符串支持，但是以未来的兼容方式，使时间到达（现在！），我们可以采用Apache箭头而不从过去过时的数据呈现数据，或者需要数据转换。为了与Apache arrow兼容，我们开发了Vaex-arrow包，它以vaex平滑为互操作性，以可能的内存复制在此处和那里。</p><p>  With Apache Arrow version 3.0 the time has come to integrate Arrow support into the core of Vaex (the Python package  vaex-core), deprecating the  vaex-arrow package. While all versions of Vaex support the same string data on disk (either in HDF5 or Apache Arrow format), what is different in version 4.0 of Vaex, is that we now pass these around as Arrow arrays.</p><p>  使用Apache arrow版本3.0该时间已经到来将箭头支持集成到Vaex的核心（Python包vaex-core），弃用了Vaex-arrow包。虽然所有版本的VAEX都支持磁盘上的相同字符串数据（在HDF5或Apache arrow格式中），VAEX版本4.0中的不同之处在于我们现在将这些传递为箭头阵列。</p><p> import vaexdf = vaex.from_arrays(library=[&#39;Vaex&#39;, &#39;NumPy&#39;, &#39;Apache Arrow&#39;])print(df)## # library## 0 &#39;Vaex&#39;## 1 &#39;NumPy&#39;## 2 &#39;Apache Arrow&#39;print(repr(df[&#39;library&#39;].values))##&amp;ampltpyarrow.lib.StringArray object at 0x7f631c1a1360&amp;ampgt##[## &#34;Vaex&#34;,## &#34;NumPy&#34;,## &#34;Apache Arrow&#34;##]</p><p> 导入vaexdf = vaex.from_arrays（库= [＆＃39; vaex＆＃39; numpy＆＃39 ;,＆＃39; apache arrow＆＃39;]）打印（df）#####198 ＆＃39; vaex＆＃39; ## 1＆＃39; numpy＆＃39; ## 2＆＃39; Apache arrow＆＃39;打印（DF [＆＃39;图书馆＆＃39;价值观）） ##＆amp; ampltpyarrow.lib.stringArray对象在0x7f631c1a1360＆amp; ampgt ## [##＆＃34; vaex＆＃34; numpy＆＃34;，##＆＃34; Apache arrow＆＃34; ##]</p><p>  import vaeximport numpy as npimport pyarrow as pax = np.arange(4)y = pa.array([42, 12, 144, 1024])df = vaex.from_arrays(x=x, y=y)df[&#39;y&#39;] = df.x * df.yprint(repr(df.y))##Expression = y##Length: 4 dtype: object (column)##--------------------------------##0 0##1 12##2 288##3 3072</p><p>  导入vaeximport numpy作为npimport pyarrow作为pax = np.arange（4）y = pa.array（[42,12,144,1024]）df = vaex.from_arrays（x = x，y = y）df [＆＃39 ; y＆＃39;] = df.x * df.yprint（Rep（df.y））##表达式= y ##长度：4 dtype：对象（列）## ---------- ---------------------- ## 0 0 ## 1 12 ## 2 288 ## 3072</p><p> And while by default, Arrow takes a Pandas-like approach of converting missing values to  NaN when mixing with NumPy, in Vaex we ensure your missing values stay missing values, and your arrays do not get upcasted to floats because of that.</p><p> 虽然默认情况而言，arrow采用熊猫样方法将缺失值转换为Num，在Numpy中混合时，在VAEX中，我们确保您的缺失值保持缺失值，并且由于此，您的阵列不会浮动到浮动。</p><p> import vaeximport numpy as npimport pyarrow as pax = np.ma.array(np.arange(4), mask=[0, 1, 0, 0], dtype=&#39;i4&#39;)y = pa.array([42, 12, 144, None], type=pa.int32())# Now we get NaN (not a number)print(x*y)##[0.0 -- 288.0 nan]df = vaex.from_arrays(x=x, y=y)df[&#39;y&#39;] = df.x * df.y# vaex propagates missing valuesprint(repr(df.y))##Expression = y##Length: 4 dtype: int64 (column)##-------------------------------##0 0##1 --##2 288##3 --</p><p> 导入vaeximport numpy作为npimport pyarrow作为pax = np.ma.array（np.arange（4），mask = [0,1,0,0]，dtype =＆＃39; i4＆＃39;）y = pa.array （[42,12,144，无]，type = pa.int32（））＃现在我们得到naN（不是一个数字）打印（x * y）## [0.0  -  288.0 naN] df = vaex.from_arrays（ x = x，y = y）df [＆＃39; y＆＃39;] = df.x * df.y＃vaex传播缺少的值图（'df.y））##表达式= Y ##长度：4 dtype：int64（列）## --------------------------- ## 0 0 ## 1  -  ## 2 288 ## 3  - </p><p> Not only have we adopted Apache Arrow in the core library of Vaex, but we are also moving the fast string algorithms from Vaex to  arrow.compute. As a result we have not only interoperability of data, but also the same semantics for operations on string data. This means that Vaex, Pandas, Dask DataFrame can all operate on the same data, in the same way. This work is sponsored by the  Chan Zuckerberg Initiative, and we thank  Tom Augspurger for organizing this.</p><p> 我们不仅在vaex的核心库中采用了apache arrow，但我们也是从vaex到arrow.compute的快速字符串算法。结果，我们不仅具有数据的互操作性，而且对字符串数据的操作也是相同的语义。这意味着VAEX，PANDAS，DASK DataFrame都可以以相同的方式运行相同的数据。这项工作由Chan Zuckerberg计划赞助，我们感谢汤姆Aupspulger组织这一点。 </p><p>  While support for numerical and string data gets most of the work done, Apache Arrow has support for much more interesting data structures.For instance, splitting a string results in a list-of-strings.This data structure is ideal in memory layout for high performance (contiguous layout versus many small buffers)and still allows us to operate on it like a regular string array. This means we can  split/tokenize strings, and applyoperations like  strip on it without having to go through join and split each time:</p><p>虽然对数值和字符串数据的支持获取了大多数工作，但Apache arrow都支持更有趣的数据结构。对于实例，拆分字符串会导致字符串中的结果。该数据结构非常适合高位性能（连续布局与许多小缓冲区），仍然允许我们像常规字符串阵列一样操作。这意味着我们可以拆分/令授权字符串，并且像条带上的扫描程序，而无需通过加入并拆分，每次：</p><p> import vaexdf = vaex.from_arrays(text=[&#39;So, can you split this?&#39;, &#39;And this.&#39;, None])df.text.str.split(&#34; &#34;)##Expression = str_split(text, &#39; &#39;)##Length: 3 dtype: list&amp;ampltitem: string&amp;ampgt (expression)##------------------------------------------------##0 [&#39;So,&#39;, &#39;can&#39;, &#39;you&#39;, &#39;split&#39;, &#39;this?&#39;]##1 [&#39;And&#39;, &#39;this.&#39;]##2 --# apply string operations to each string in the listdf.text.str.split(&#34; &#34;).str.strip(&#39; ,?.&#39;))##Expression = str_strip(str_split(text, &#39; &#39;), &#39; ,?.&#39;)##Length: 3 dtype: list&amp;ampltitem: string&amp;ampgt (expression)##------------------------------------------------##0 [&#39;So&#39;, &#39;can&#39;, &#39;you&#39;, &#39;split&#39;, &#39;this&#39;]##1 [&#39;And&#39;, &#39;this&#39;]##2 --</p><p> 导入vaexdf = vaex.from_arrays（text = [＆＃39;所以，你可以分开这个吗？＆＃39 ;,＆＃39;＆＃39;，none] df.text.split（＆ ＃34;＆＃34;）##表达式= str_split（文本，＆＃39;＆＃39;）##长度：3 dtype：list＆amp; solltitem：string＆amp; ampgt（表达式）## ------ ----------------------------------- ## 0 [＆＃39;所以，＆＃39 ;,＆＃39;可以＆＃39 ;,＆＃39;你＆＃39 ;,＆＃39; split＆＃39;，＆＃39;这个？＆＃39;] ## 1 [＆ ＃39;和＆＃39;＆＃39;这个。＆＃39;] ## 2  - ＃将字符串操作应用于listdf.text.split中的每个字符串（＆＃34;＆＃34;） .str.strip（＆＃39;，？。＆＃39;））##表达式= str_strip（str_split（文本，＆＃39;＆＃39;），＆＃39;，？。＆＃39;） ##长度：3 dtype：list＆amp; solltitem：string＆amp; ampgt（表达式）## ---------------------------- ---------------- ## 0 [＆＃39; SO＆＃39 ;,＆＃39;可以＆＃39;你＆＃39;你＆＃39 ;,＆＃ 39;拆分＆＃39;＆＃39;这个＆＃39;] ## 1 [＆＃39;和＆＃39;＆＃39;这个＆＃39;] ## 2  - </p><p> String splitting can even be done multiple times creating a nested list without any performance loss.</p><p> String Splitting甚至可以多次创建嵌套列表而没有任何性能损失。</p><p> df.text.str.split(&#34; &#34;).str.strip(&#39; ,?.&#39;).str.split(&#39;a&#39;)##Expression = str_split(str_strip(str_split(text, &#39; &#39;), &#39; ,?.&#39;), &#39;a&#39;)##Length: 3 dtype: list&amp;ampltitem: list&amp;ampltitem: string&amp;ampgt&amp;ampgt (expression)##------------------------------------------------------------##0 [[&#39;So&#39;], [&#39;c&#39;, &#39;n&#39;], [&#39;you&#39;], [&#39;split&#39;], [&#39;this&#39;]]##1 [[&#39;And&#39;], [&#39;this&#39;]]##2 --</p><p> df.text.stlit（＆＃34;＆＃34;）。str.strip（＆＃39;，？。＆＃39;）。str.split（＆＃39; a＆＃39;）##表达= str_split（str_split（str_split（文本，＆＃39;＆＃39;），＆＃39;，？。＆＃39;），＆＃39; a＆＃39;）##长度：3 dtype：list＆amp ; AmplTitem：List＆amp; SollTitem：String＆amp; Ampgt＆amp; Ampgt（表达）## ---------------------------------- ------------------------- ## 0 [[＆＃39; SO＆＃39;]，[＆＃39; C＆＃39 ;，＆＃39; n＆＃39;]，[＆＃39;你＆＃39;]，[＆＃39; split＆＃39;]，[＆＃39;这个＆＃39;]] ## 1 [[ ＆＃39;和＆＃39;]，[＆＃39;这个＆＃39;]] ## 2  - </p><p>  Apache Arrow will bring a lot of good to the whole data analytics world, and not only to Python. It&#39;s growing fast, and moving fast, and we believe will be the future of analytics in Python, supplementing or substituting NumPy in many areas.However, adoption will take time, and most people are probably more comfortable seeing NumPy arrays. Therefore a Vaex version 4 a DataFrame can hold both NumPy arrays and Apache Arrow arrays to make the transition period easier.If the data comes from an HDF5 file or from external NumPy arrays we keep it as a NumPy array, except for strings.If the data comes from an Arrow file or external Arrow arrays we keep them as Arrow arrays.</p><p>  Apache arrow将为整个数据分析世界带来很多好的，而不仅仅是Python。它速度快速增长，快速移动，我们相信将成为Python的分析的未来，补充或替代许多领域的Numpy。但是，采用将需要时间，大多数人可能更舒适地看到Numpy阵列。因此，VAEX版本4 DataFrame可以按住NumPy阵列和Apache箭头阵列，以使转换周期更轻松。如果数据来自HDF5文件或从外部NumPy阵列中，我们将其保留为Numpy数组，但字符串除外数据来自箭头文件或外部箭头阵列，我们将它们保留为箭头阵列。</p><p> If you happen to have an Arrow file, but prefer to work with NumPy arrays (because of the computational semantics) you can lazily convert all data, with the exception of string data.</p><p> 如果您碰巧有箭头文件，但更喜欢使用Numpy阵列（由于计算语义），您可以懒惰地转换所有数据，但字符串数据除外。</p><p>  With Apache Arrow comes out of core Parquet support, a very much requested feature. Although previous versions of vaex-arrow provided some Parquet support, we now support lazy loading, allowing you to scan through parquet datasets larger than memory. Although Parquet will come at the cost of some CPU, its size reduction makes it an attractive format for cloud storage, where network bandwidth is often a limiting factor.</p><p>  使用Apache arrow出来的核心镶木地板支持，是一个非常好的要求。虽然以前版本的Vaex-arrow提供了一些镶木地板支持，但我们现在支持延迟加载，允许您通过比内存大的镶木数据集扫描。虽然木地板将以某些CPU的成本来，但其尺寸减少使其成为云存储的有吸引力的格式，其中网络带宽通常是限制因素。 </p><p> An additional benefit of using Apache Arrow is the support for reading partitioned parquet files. This is quite handy since files generated from the Spark/Hadoop world often come in this format, making ingestion from these platforms easier.</p><p>使用Apache arrow的额外好处是支持读取分区的地形文件。这非常方便，因为从火花/ Hadoop世界生成的文件经常以这种格式出现，因此从这些平台更轻松地摄取。</p><p>  We also support creating partitioned files, it may not be the most performant part of vaex, but we use it for testing, and thought it would be good to share.</p><p>  我们还支持创建分区文件，可能不是VAEX最表现的部分，但我们使用它进行测试，并认为分享将是好的。</p><p> import vaexcountries = [&#39;US&#39;, &#39;US&#39;, &#39;NL&#39;, &#39;FR&#39;, &#39;NL&#39;, &#39;NL&#39;]years = [2020, 2021, 2020, 2020, 2019, 2020]values = [1, 2, 3, 4, 5, 6]df = vaex.from_dict({ &#39;country&#39;: countries, &#39;year&#39;: years, &#39;value&#39;: values,})df.export_partitioned(&#39;./partitioned&#39;, by=[&#39;country&#39;, &#39;year&#39;])#### $ ls -R ./partitioned/##./partitioned/:##&#39;country=FR&#39; &#39;country=NL&#39; &#39;country=US&#39;####&#39;./partitioned/country=FR&#39;:##&#39;year=2020&#39;####&#39;./partitioned/country=FR/year=2020&#39;:##db5f59db-f207-4dca-8999-e405436c3a88.parquet####&#39;./partitioned/country=NL&#39;:##&#39;year=2019&#39; &#39;year=2020&#39;####&#39;./partitioned/country=NL/year=2019&#39;:##ee1b5558-e1c7-4d49-a899-a0b6c29ace00.parquet####&#39;./partitioned/country=NL/year=2020&#39;:##3908d92f-d280-4c83-9e51-bead619d470b.parquet####&#39;./partitioned/country=US&#39;:##&#39;year=2020&#39; &#39;year=2021&#39;####&#39;./partitioned/country=US/year=2020&#39;:##8be82725-c46d-40ad-b2e4-bd3962469394.parquet####&#39;./partitioned/country=US/year=2021&#39;:##f4743b01-9783-4ef1-8bff-e892c050a50a.parquet</p><p> 导入vaexcountries = [＆＃39;美国＆＃39;我们＆＃39;我们＆＃39; nl＆＃39 ;,＆＃39; fr＆＃39 ;,＆＃39; nl＆＃39;，＆＃39; nl＆＃39 ;, ＃39; nl＆＃39;]年= [2020,2021,2020,2020,2021,2020，2020,2019,2020]值= [1,2,3,4,5,6] df = vaex.from_dict（{＆＃39;国家＆ ＃39 ;:国家，＆＃39;年＆＃39 ;:岁，＆＃39; value＆＃39;值，}）df.export_partitioned（＆＃39; ./ partitioned＆＃39;，by = [＆＃ 39;国家＆＃39;，＆＃39;年＆＃39;]）#### $ ls -r ./partitioned/##./partitioned/::##&#39; vountry=fr&#39; ＆＃39;国家= nl＆＃39; ＆＃39;国家=美国＆＃39; ####＆＃39; ./分区/国家= fr＆＃39;：##＆＃39;年= 2020＆＃39; ####＆＃39; / partitioned/country=fr/year=2020&#39; :###db5f59db-f207-4dca-8999-e405436c3a88.parquet####&#39 ;;/partitioned/country=nl&#39 ;:##&# 39;年= 2019年＆＃39; ＆＃39;年= 2020＆＃39; ####＆＃39; ./分区/国家/地区= NL /年= 2019＆＃39;：## EE1B5558-E1C7-4D49-A899-A0B6C29ACE00.PARQUET #### ＆＃39; ./ partented / country = nl /年= 2020＆＃39;：## 3908d92f-d280-4c83-9e51-bead619d470b.parquet ####＆＃39; ./ partitioned / country =美国＆＃39; ：##＆＃39;年= 2020＆＃39; ＆＃39;年= 2021＆＃39; ####＆＃39; ./分区/国家=美国/年= 2020＆＃39;：## 8be82725-C46D-40AD-B2E4-BD3962469394.Parquet #### ＆＃39; ./分区/国家=美国/年= 2021＆＃39;：## F4743B01-9783-4EF1-8BFF-E892C050A50A.PARQUET</p><p>  If the partitioning is in Hive format, you are good to go, just open the directory:</p><p>  如果分区以Hive格式为以蜂巢格式，则很好，只需打开目录：</p><p> import vaexdf = vaex.open(&#39;./partitioned/&#39;)print(df)## # value country year## 0 4 &#39;FR&#39; 2020## 1 5 &#39;NL&#39; 2019## 2 3 &#39;NL&#39; 2020## 3 6 &#39;NL&#39; 2020## 4 1 &#39;US&#39; 2020## 5 2 &#39;US&#39; 2021</p><p> 导入vaexdf = vaex.open（＆＃39; ./分区/＆＃39;）打印（df）##％国家年## 0 4＆＃39; fr＆＃39; 2020 ## 1 5＆＃39; nl＆＃39; 2019 ## 2 3＆＃39; nl＆＃39; 2020 ## 3 6＆＃39; nl＆＃39; 2020 ## 4 1＆＃39;我们＆＃39; 2020 ## 5 2＆＃39;美国＆＃39; 2021.</p><p>  import vaexdf.export_partitioned(&#39;./partitioned_directory/&#39;, by=[&#39;country&#39;, &#39;year&#39;], directory_format=&#39;{value}&#39;)vaex.open(&#39;./partitioned_directory/&#39;, partitioning=[&#39;country&#39;, &#39;year&#39;])print(df)## # value country year## 0 4 &#39;FR&#39; 2020## 1 5 &#39;NL&#39; 2019## 2 3 &#39;NL&#39; 2020## 3 6 &#39;NL&#39; 2020## 4 1 &#39;US&#39; 2020## 5 2 &#39;US&#39; 2021</p><p>  导入vaexdf.export_partitioned（＆＃39; ./ partitioned_directory /＆＃39; by = [＆＃39;国家＆＃39;＆＃39;年和＃39;]，directory_format =＆＃39; {value}＆ ＃39;）vaex.open（＆＃39; ./ partitioned_directory /＆＃39;，partitioning = [＆＃39;国家/地区＆＃39;年和＃39;]）打印（df）###价值国家一年## 0 4＆＃39; fr＆＃39; 2020 ## 1 5＆＃39; nl＆＃39; 2019 ## 2 3＆＃39; nl＆＃39; 2020 ## 3 6＆＃39; nl＆＃39; 2020 ## 4 1＆＃39;我们＆＃39; 2020 ## 5 2＆＃39;美国＆＃39; 2021.</p><p>  In version 4.0, Vaex supports pickling of DataFrames which makes integration with Dask, Ray or Python&#39;s multiprocessing library significantly easier.</p><p>  在版本4.0中，VAEX支持与DASK，RAY或PYTHON＆＃39; S多处理库进行集成的酸洗，显着更轻松。 </p><p> While you may be used to pickling being a non-efficient way or storing data, in many cases Vaex does not pickle the data itself. When we do:</p><p>虽然您可能用于酸洗是一种非有效的方式或存储数据，但在许多情况下，VAEX不会纠正数据本身。当我们做的时候：</p><p> import vaeximport pickledf = vaex.open(&#39;s3://vaex/taxi/nyc_taxi_2015_mini.parquet&#39;)df[&#39;tip_percentage&#39;] = df.tip_amount / df.total_amountN = len(df)print(f&#39;{N:,} rows&#39;)##300,000 rowswith open(&#39;mydataframe.pickle&#39;, &#39;wb&#39;) as f: pickle.dump(df, f)## $ ls -alh ./mydataframe.pickle## -rw-rw-r-- 1 maartenbreddels maartenbreddels 907 dec 1 16:24 ./mydataframe.pickle</p><p> 导入vaeximport pickledf = vaex.open（＆＃39; s3：//vaex/taxi/nyc_taxi_2015_mini.parquet& n39;）df [＆＃39; tip_percentage＆＃39;] = df.tip_amount / df.total_amountn = len（df ）打印（f＆＃39; {n：，}行＆＃39;）## 300,000 Rowswith打开（＆＃39; mydataframe.pickle＆＃39; wb＆＃39;）作为f：pickle.dump（ df，f）## $ ls -alh ./mydataframe.pickle## -rw-rw-r-- 1 maartenbreddels maartenbreddels 907 12月1日16:24 ./mydataframe.pickle</p><p> You might be surprised that this is only 907 bytes!. If you inspect the file, you will notice that we pickle the path, and the internal state (such as the virtual column  df.tip_amount / df.total_amount).</p><p> 你可能会惊讶的是，这只是907字节！如果您检查文件，您会注意到我们纠正了路径和内部状态（例如虚拟列DF.TIP_AMOUNT / DF.Total_AMOUNT）。</p><p> This can be very useful when you want to store your whole dataframe to disk, or send it over a wire. Instead of copying 1 terabyte of data, we simply pickle the original file location and all operations you have done to it (transformations and filtering). Note that this works particularly well with cloud storage, since the file location will be the same for all computers.</p><p> 当您希望将整个Dataframe存储到磁盘时，这可能非常有用，或通过电线发送它。我们只需纠正原始文件位置和您所做的所有操作（转换和过滤），而不是复制1大字节。请注意，这对云存储特别好，因为所有计算机的文件位置都是相同的。</p><p> Although with Vaex we primarily focus on getting the maximum performance out of a single powerful machine, this paves the way for optimized distributed computations, for those situations in which you really need a cluster.</p><p> 虽然VAEX我们主要专注于获得一个强大的机器的最大性能，但这为您真正需要群集的那些情况铺平了优化的分布式计算的方式。</p><p>  Recognizing that  df.apply is an escape hatch that is necessary to get stuff done, we also had to recognize that this was painfully slow compared to the rest of Vaex, dropping to 100% CPU Usage. The bottleneck here is caused by the Global Interpreter Lock (GIL) and not Vaex directly. Nonetheless, we felt we should try and find a way to improve the performance of the apply method.</p><p>  认识到df.apply是一个逃生舱口，这是必要的完成物品，我们也必须认识到与其他vaex相比，这是痛苦的缓慢，降至100％的CPU使用率。这里的瓶颈是由全球翻译锁（GIL）造成的，而不是直接vaex造成的。尽管如此，我们觉得我们应该尝试找到一种提高应用方法性能的方法。</p><p>  import vaexdef is_prime(x): return x &gt; 1 and all((x % i) != 0 for i in range(2, x))df = vaex.from_arrays(x=vaex.vrange(0, 100_000, dtype=&#39;i4&#39;))# you need to explicitly specify which arguments you needdf[&#39;is_prime&#39;] = df.apply(is_prime, arguments=[df.x])df.head(10)## # x is_prime## 0 0 False## 1 1 False## 2 2 True## 3 3 True## 4 4 False## 5 5 True## 6 6 False## 7 7 True## 8 8 False## 9 9 False</p><p>  导入vaexdef is_prime（x）：返回x＆gt; 1和全部（（x％i）！= 0在范围内（2，x））df = vaex.from_arrays（x = vaex.vrange（0,100_000，dtype =＆＃39; i4＆＃39;）） ＃您需要明确地指定您需要的参数[＆＃39; is_prime＆＃39;] = df.apply（aramimes = [df.x]）df.head（10）##＃x is_prime ## 0 0 false ## 1 1 false ## 2 2真实## 3 3真## 4 4假## 5 5真## 6 6假## 7 7真## 8 8假## 9 9 false </p><p>  While S3 support for HDF5 was present in earlier Vaex versions, with version 4.0 we further improve on this thanks to both the Apache Arrow and FSSpec projects. Vaex can read and write most file formats to many cloud storage systems, with the most performant being S3. For S3 and Google Cloud Storage, we natively support their file paths, e.g  &#34;s3://vaex/testing/xys.hdf5&#34;, or  &#34;gc://vaex/testing/xys.hdf5&#34;. In all other cases, one can specify a FileSystem object via either Apache Arrow or FSSpec.</p><p>虽然在早期的VAEX版本中存在对HDF5的S3支持，但由于Apache Arrow和FSSPEC项目，我们进一步改进了这一点。 VAEX可以读取并将大多数文件格式读到许多云存储系统，最表现为S3。对于S3和Google云存储，我们本身支持他们的文件路径，例如＆＃34; s3：//vaex/testing/xys.hdf5&#34;，或＆＃34; gc：//vaex/testing/xys.hdf5& ＃34;在所有其他情况下，可以通过Apache箭头或FSSpec指定文件系统对象。</p><p> import vaexdf = vaex.open(&#39;s3://vaex/testing/xys.hdf5&#39;)df = vaex.open(&#39;gc://vaex/testing/xys.hdf5&#39;)# Using Apache Arrow to connect to a Hadoop File Systemimport pyarrow.fs as fshdfs = fs.HadoopFileSystem(host, port)df = vaex.open(&#39;myfile.parquet&#39;, fs=hdfs)# Or FSSpec to use HTTPimport fsspechttps = fsspec.filesystem(&#39;https&#39;)df = vaex.open(&#39;https://cdn.gea.esac.esa.int/Gaia/gedr3/gaia_source/GaiaSource_000000-003111.csv.gz&#39;, fs=http)</p><p> 导入vaexdf = vaex.open（＆＃39; s3：//vaex/testing/xys.hdf5&#39;）df = vaex.open（＆＃39; gc：//vaex/testing/xys.hdf5&#39; ）＃使用apache arrow连接到Hadoop文件systemimport pyarrow.fs作为fshdfs = fs.hadoopfilesystem（host，port）df = vaex.open（＆＃39; myfile.parquet＆＃39; fs = hdfs）＃或fsspec使用httpimport fsspechttps = fsspec.filesystem（＆＃39; https＆＃39; https＆＃39;）df = vaex.open（＆＃39; https：//cdn.gea.esac.esa.int/gaia/gedr3/gaia_source/gaiasource_000000- 003111.csv.gz＆＃39;，fs = http）</p><p>  We hope you are as excited as we are with the 4.0 release of Vaex. Unifying Apache Arrow and NumPy in a single DataFrame librarygives us rich data structures (e.g. list of strings), compatibility with NumPy, interoperability (zero-copy data sharing), and an overall bright future.The out-of-core Parquet support together with much-improved cloud storage support makes working with and on the cloud much more transparent. Improved pickle support and default parallel apply allow for better performance when you need to resort to pure Python code.</p><p>  我们希望您对4.0张vaex发布时感到兴奋。统一Apache箭头和Numpy在单个DataFrame库中，我们丰富的数据结构（例如字符串列表），与Numpy，互操作性（零复制数据共享）和整体光明的未来兼容。核心外的木质支撑在一起大量改进的云存储支持使得与云一起使用并更透明。改进的泡沫支持和默认并行应用允许在需要诉诸纯Python代码时更好的性能。</p><p>  # Want to install?$ pip install &#34;vaex==4.*&#34;# Just want to core functionality?$ pip install &#34;vaex-core==4.*&#34;# Using conda or mamba?$ conda install -c conda-forge vaex=4</p><p>  ＃想要安装？$ pip安装＆＃34; vaex == 4。*＆＃34;＃只想核心功能？$ pip安装＆＃34; vaex-core == 4。*＆＃34;＃使用公园或曼巴（Mamba）？$ Conda安装-c conda-forge vaex = 4</p><p>  Join us on GitHub at  https://github.com/vaexio/vaex if you want to contribute or find issues, or  https://github.com/vaexio/vaex/discussions for more general questions.</p><p>  在HTTPS://github.com/vaexio/vaex上加入我们的GitHub，如果要为更多常规问题提供贡献或查找问题，或查找问题，或https://github.com/vaexio/vaex/discussions。</p><p> Do you need help accelerating you data processing or data analytics?  Reach out to us to see if we can help you.</p><p> 您需要帮助加速您的数据处理或数据分析吗？联系我们看看我们是否可以帮助您。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vaex.io/blog/a-hybrid-apache-arrow-numpy-dataframe-with-vaex-version-4">https://vaex.io/blog/a-hybrid-apache-arrow-numpy-dataframe-with-vaex-version-4</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/apache/">#apache</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vaex/">#vaex</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>