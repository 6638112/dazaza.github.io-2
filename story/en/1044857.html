<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>跟踪突然开始发生的段错误 Tracking down a segfault that suddenly started happening</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Tracking down a segfault that suddenly started happening<br/>跟踪突然开始发生的段错误 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-18 15:54:15</div><div class="page_narrow text-break page_content"><p>I wanted to share a story of a segmentation fault I helped track down this weekend. I thought the final root cause of the segfault was interesting because of how unrelated it was to the code I was trying to debug.</p><p>我想分享一个有关本周末帮助追踪的细分错误的故事。我认为segfault的最终根本原因很有趣，因为它与我要调试的代码无关。</p><p> I’ve been maintaining a  Linux fork of  obs-ios-camera-source, which is an  OBS plugin that allows you to use an iPhone or iPad’s camera and microphone as a video and audio source in OBS. It works in conjunction with the “ Camera for OBS Studio” app in the App Store. This kind of thing is useful for online streamers who want to use their phone’s camera instead of buying a separate camera. For those of you who don’t know, OBS is short for Open Broadcaster Software. A lot of streamers use it to handle broadcasting their stream. It allows you to capture audio and video, mix it all together, do all kinds of cool things with it, and then record the final result and/or stream it to sites such as YouTube and Twitch.</p><p> 我一直在维护obs-ios-camera-source的Linux分支，这是一个OBS插件，可让您将iPhone或iPad的摄像头和麦克风用作OBS中的视频和音频源。它与App Store中的“ Camera for OBS Studio”应用程序配合使用。对于想使用手机的摄像头而不是购买单独的摄像头的在线直播者来说，这种方法非常有用。对于不认识的人，OBS是Open Broadcaster Software的缩写。许多流媒体使用它来处理广播他们的流。它使您可以捕获音频和视频，将它们混合在一起，用它做各种很酷的事情，然后记录最终结果和/或将其流式传输到YouTube和Twitch等网站。</p><p> Getting this plugin working on Linux wasn’t really complicated, because it was already well-written without much platform-specific code. After all, the existing codebase was already operational on both macOS and Windows. It mostly just required tweaking a few compile/link options to make the code run happily on Linux.</p><p> 使这个插件在Linux上运行并不是很复杂，因为它已经写得很好，没有太多平台特定的代码。毕竟，现有的代码库已经在macOS和Windows上运行。它只是需要调整一些编译/链接选项，以使代码在Linux上愉快地运行。</p><p> Anyway, I’m pretty sure a good number of people have been using my Linux port of this plugin without issues. I know it works fine for me when I test with it in Ubuntu 18.04 or 20.04. I’ve helped people on other distros get it working too. I don’t really do any streaming myself — maybe someday though!</p><p> 无论如何，我敢肯定，有很多人一直在使用我的此插件的Linux端口而没有任何问题。我知道当我在Ubuntu 18.04或20.04中对其进行测试时，它对我来说很好用。我已经帮助其他发行版的人使其正常工作。我本人实际上并没有做任何流式传输-也许有一天！</p><p> On Friday, GitHub user rrondeau  reported an issue: after a half a year of the obs-ios-camera-source plugin working without a problem, it suddenly started causing OBS to segfault on his computer (currently running Fedora 33). He provided a stack trace that showed that the segfault was happening because of something initiated by the plugin. Afterward, he used GDB to get a better stack trace that provided more info about the functions being called and the parameters being passed:</p><p> 星期五，GitHub用户rrondeau报告了一个问题：obs-ios-camera-source插件运行半年后没有出现问题，它突然开始导致OBS在他的计算机上进行段错误（当前运行Fedora 33）。他提供了堆栈跟踪，该跟踪表明段错误正在发生，原因是该插件启动了某些操作。之后，他使用GDB获得了更好的堆栈跟踪，该跟踪提供了有关调用函数和传递参数的更多信息：</p><p>  The actual segfault was happening inside of a function called “socket_send” in libsamba-sockets-samba4.so, which was being called by a function in libusbmuxd, which is bundled as part of the obs-ios-camera-source plugin source code and is used for communicating with iOS devices over USB. When I first saw this in the stack trace, my mind thought “Huh…that’s weird. Why does libusbmuxd use Samba’s library for its socket code instead of providing its own?” ( Samba is an implementation of the Windows file sharing protocol used by pretty much every Linux distribution)</p><p>  实际的段错误发生在libsamba-sockets-samba4.so中一个名为“ socket_send”的函数内部，该函数由libusbmuxd中的一个函数调用，该函数作为obs-ios-camera-source插件源代码和用于通过USB与iOS设备通信。当我第一次在堆栈跟踪中看到此消息时，我的脑子想：“嗯……那很奇怪。为什么libusbmuxd不使用Samba的套接字代码而使用Samba的库呢？” （Samba是几乎每个Linux发行版都使用的Windows文件共享协议的实现）</p><p> I tested and couldn’t reproduce the issue in Ubuntu. I know basically nothing about Fedora, but I faked my way through grabbing a Fedora 33 virtual machine, installing OBS, and compiling the plugin. I ran into the exact same issue that he was seeing.</p><p> 我经过测试，无法在Ubuntu中重现该问题。我对Fedora基本上一无所知，但是我通过获取Fedora 33虚拟机，安装OBS以及编译插件来伪装自己的方式。我碰到了他所看到的完全相同的问题。 </p><p> Before I had a chance to look deeper and understand what was going on, rrondeau beat me to the correct conclusion: code in Samba’s library was mistakenly being called.  libusbmuxd has a function called socket_send, but clearly  libsamba-sockets-samba4’s function that is also named socket_send was accidentally being called instead.</p><p>在我有机会深入了解并了解发生了什么之前，rrondeau击败了我一个正确的结论：Samba库中的代码被错误地调用了。 libusbmuxd有一个名为socket_send的函数，但是显然libsamba-sockets-samba4的函数（也称为socket_send）被意外地调用了。</p><p> Honestly, that’s all we really needed to know. Renaming libusbmuxd’s socket_send function to something else, and updating all references to it to use the new name, fixed the issue. I still wanted to understand why this suddenly became an issue when it had been working fine prior to that. Why were we calling into Samba libraries? Why does an iOS USB multiplexing library even consider talking to a library associated with Windows file sharing?</p><p> 老实说，这就是我们真正需要知道的。将libusbmuxd的socket_send函数重命名为其他函数，并更新对它的所有引用以使用新名称，从而解决了此问题。我仍然想了解为什么在此之前一切正常，却突然变成一个问题。我们为什么要调用Samba库？为什么iOS USB多路复用库甚至考虑与与Windows文件共享关联的库进行对话？</p><p> Not knowing the answer to that question bothered me. I decided to dig deeper and understand exactly what was going on. I started by using  ldd, which lists all dynamic libraries used by a program or library:</p><p> 不知道该问题的答案令我感到困扰。我决定更深入地挖掘并确切地了解发生了什么。我从使用ldd开始，它列出了程序或库使用的所有动态库：</p><p>  I truncated the output because it spit out a very long list of libraries. As we can see from ldd’s output, obs-ios-camera-source.so depends on libsamba-sockets-samba4.so. ldd lists all recursive dependencies as well, and I couldn’t find any references to “samba” in the plugin source code, so this was likely an indirect dependency instead. I confirmed this by using  readelf to show only the direct dependencies:</p><p>  我截断了输出，因为它吐出了很长的库列表。从ldd的输出中可以看到，obs-ios-camera-source.so取决于libsamba-sockets-samba4.so。 ldd还会列出所有递归依赖项，并且我在插件源代码中找不到对“ samba”的任何引用，因此这可能是间接依赖项。我通过使用readelf仅显示直接依赖项来确认这一点：</p><p>  At this point I used ldd and readelf to walk through the tree of dependencies and figure out what was actually linking against the Samba libraries. I later learned that I could have installed lddtree (part of the pax-utils package) to do this automatically. Either way, this led me to discover that the Samba libraries were being included through libsmbclient, which was a dependency of libavformat (part of FFmpeg). libavformat is a dependency of libobs.</p><p>  在这一点上，我使用了ldd和readelf遍历了依赖树，并找出了与Samba库实际链接的内容。后来我知道我可以安装lddtree（pax-utils软件包的一部分）来自动执行此操作。无论哪种方式，这都使我发现通过libsmbclient包含了Samba库，而libsmbclient是libavformat（FFmpeg的一部分）的依赖项。 libavformat是libobs的依赖项。</p><p> Repeating this experiment on Ubuntu showed that libavformat on Ubuntu does not depend on libsmbclient. This explains why I couldn’t reproduce the issue on Ubuntu. So why does Fedora’s (well,  RPM Fusion‘s) version of libavformat depend on libsmbclient?</p><p> 在Ubuntu上重复该实验表明，Ubuntu上的libavformat不依赖libsmbclient。这解释了为什么我无法在Ubuntu上重现该问题。那么，为什么Fedora的（以及RPM Fusion的）libavformat版本依赖于libsmbclient？</p><p> It turns out that it’s a compile-time option for FFmpeg.  libavformat contains code for talking with Windows servers using libsmbclient, but it’s an optional thing that you can choose to enable at compile time. Clearly Ubuntu chooses not to enable it, but RPM Fusion does.  Actually, I found the exact post on RPM Fusion’s commits mailing list where the patch was added for enabling SMB support in FFmpeg. This patch is what led to the whole issue happening. If Ubuntu’s version of FFmpeg was being built with SMB support, we would have seen this a long time ago. This commit to RPM Fusion was made on December 31, 2020, which explains why rrondeau had only recently begun seeing the problem.</p><p> 事实证明，这是FFmpeg的编译时选项。 libavformat包含用于使用libsmbclient与Windows服务器通信的代码，但是您可以选择在编译时启用该选项。显然，Ubuntu选择不启用它，但RPM Fusion可以。实际上，我在RPM Fusion的提交邮件列表中找到了确切的帖子，其中添加了补丁以在FFmpeg中启用SMB支持。该补丁导致了整个问题的发生。如果Ubuntu的FFmpeg版本是在具有SMB支持的情况下构建的，那么我们早就已经看到了。对RPM Fusion的承诺是在2020年12月31日做出的，这解释了为什么rrondeau直到最近才开始发现该问题。 </p><p> The root cause here is that the obs-ios-camera-source plugin was linking against two libraries that both provided a function named socket_send: libsamba-sockets-samba4 (indirectly through libobs) and libusbmuxd. libusbmuxd was being linked statically, but  that doesn’t prevent functions in it from being resolved through dynamic linking rules anyway. So even though libusbmuxd was a static library with its own internal implementation of socket_send, it was using libsamba-sockets-samba4’s implementation instead.</p><p>根本原因是，obs-ios-camera-source插件链接到两个都提供了名为socket_send函数的库：libsamba-sockets-samba4（通过libobs间接）和libusbmuxd。 libusbmuxd是静态链接的，但这并不能阻止其中的功能通过动态链接规则解析。因此，即使libusbmuxd是具有自己的socket_send内部实现的静态库，它仍在使用libsamba-sockets-samba4的实现。</p><p> rrondeau and I settled on changing what we had control over: the libusbmuxd source code embedded inside of the plugin’s source code.  We went with simply adding a “usbmuxd_” prefix before all of the socket_ functions. There may be a more complex way of forcing it to use its own internal version of socket_send through linker options, but I feel that this is probably the simplest solution. It’s easy to implement, and it gets the job done.</p><p> 我和rrondeau决定改变我们的控制权：嵌入在插件源代码中的libusbmuxd源代码。我们只需要在所有socket_函数之前添加一个“ usbmuxd_”前缀即可。可能有更复杂的方法通过链接器选项强制它使用自己的内部版本的socket_send，但我认为这可能是最简单的解决方案。它易于实施，并且可以完成工作。</p><p> This segfault turned out to be a pretty simple issue to solve and diagnose. Is it really worthy of a blog post? Maybe, maybe not. I could definitely foresee someone else running into this issue with another combination of libraries. socket_create, socket_close, socket_send, etc. are such generic names that it may happen again. This is a great opportunity to remind everyone: don’t use generic function names like this in your shared libraries, at least not in your exported symbols! You could easily run into a situation similar to this one. In my opinion, prefixes are definitely a good idea for your library’s exported symbols. In this case, both libusbmuxd and Samba were breaking that guideline.</p><p> 事实证明，此段错误是一个非常简单的问题，需要解决和诊断。真的值得写博客文章吗？也许吧，也许不是。我绝对可以预见会有其他库组合出现此问题。 socket_create，socket_close，socket_send等是此类通用名称，可能会再次发生。这是一个提醒大家的好机会：不要在共享库中使用这样的通用函数名称，至少不要在导出的符号中使用！您很容易遇到类似这种情况。我认为，对于图书馆的导出符号而言，前缀绝对是个好主意。在这种情况下，libusbmuxd和Samba都违反了该准则。</p><p> This can be tricky because dynamic libraries on Linux export all symbols by default unless you specify otherwise. This is backwards from how Windows works with DLLs. Windows DLLs require you to specify which functions are being exported. I actually like that approach better!  Here’s an interesting reference on how to customize the visibility of your Linux dynamic library’s symbols.</p><p> 这可能很棘手，因为默认情况下，除非另行指定，否则Linux上的动态库默认情况下会导出所有符号。这与Windows使用DLL的方式相反。 Windows DLL要求您指定要导出的功能。我实际上更喜欢这种方法！这是有关如何自定义Linux动态库符号的可见性的有趣参考。</p><p> libusbmuxd already fixed this on their end quite a while ago — they now only export functions intended to be public, which have a usbmuxd_ or libusbmuxd_ prefix. I think the version included with the plugin’s source code is quite a bit older. For fun, I tried applying the visibility fixes from the linked patch to the plugin’s embedded libusbmuxd source code. The patches don’t apply cleanly because the embedded libusbmuxd code is actually built using CMake, so I have to add the compiler flags to CMakeLists.txt. After doing that, it does indeed cause libusbmuxd’s internal socket_send function to be called instead, and thus fixes the segfault.</p><p> libusbmuxd已经很早就解决了这个问题-它们现在仅导出打算公开的函数，这些函数具有usbmuxd_或libusbmuxd_前缀。我认为该插件的源代码中包含的版本要旧很多。为了娱乐，我尝试将链接修补程序中的可见性修补程序应用于插件的嵌入式libusbmuxd源代码。这些补丁不能完全适用，因为嵌入式libusbmuxd代码实际上是使用CMake构建的，因此我必须将编译器标志添加到CMakeLists.txt。之后，确实确实会导致libusbmuxd内部的socket_send函数被调用，从而修复了段错误。</p><p> What do you think? Would it make sense to try to convince the Samba project to rename their exported socket functions, or would I be barking up the wrong tree? I suspect that Samba’s socket library is actually intentionally exporting these functions so that other Samba libraries can call the socket functions. Would renaming Samba’s exported socket functions to give them less generic names cause a ton of incompatibilities given how long those function names have existed? Is it too late at this point? Am I wrong to think that Samba’s exported socket functions should have a “samba_” prefix or something like that?</p><p> 你怎么看？试图说服Samba项目重命名其导出的套接字函数是否有意义，还是我会选择错误的树？我怀疑Samba的套接字库实际上是有意导出这些函数，以便其他Samba库可以调用套接字函数。重命名Samba导出的套接字函数以减少通用名称会导致大量不兼容，因为这些名称已经存在了多久？现在太晚了吗？我以为Samba导出的套接字函数应该带有“ samba_”前缀或类似名称是我错了吗？ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.downtowndougbrown.com/2021/01/tracking-down-a-segfault-that-suddenly-started-happening/">https://www.downtowndougbrown.com/2021/01/tracking-down-a-segfault-that-suddenly-started-happening/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/跟踪/">#跟踪</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/segfault/">#segfault</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>