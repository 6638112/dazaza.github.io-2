<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重新排序论点 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">重新排序论点 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-25 02:01:51</div><div class="page_narrow text-break page_content"><p>当C程序运行时，它通常通过参数ARGC（参数计数）和argv（参数向量）接收任何命令行参数。该程序是解释该字符串数组的内容。</p><p> 有很多方法可以这样做，其中一个更简单的解决方案是getoptfunction（以下，getopt将引用getopt和getopt_long）.one扩展一些getopt实现优惠，它们在处理它时重新排序Argv的argnectents，导致数组首先出现所有选项，然后是非活动。</p><p> 此重新排序分区数组。并且我们想要一个稳定的分区，所以所有选项的相关顺序，并且所有的非活动都是相同的。</p><p> 去年我发布了Parg，一个简单的解析器，用于argv，它与getopt类似。它有一个单独的函数parg_reorder（），它执行此功能。我使用了一个简单的算法 - 分配临时数组的argv大小，解析参数，并从新阵列的末尾填写startand非活动的选项。然后将它们复制回来，将非活动倒在过程中的原始订单中。在后威尔，我可以立即将期权移入argv的最后一个地方。</p><p> 这及时运行，但也需要额外的空间。条件要求可能是一个问题（例如嵌入式系统），索勒格看看我们是否可以做得更好。</p><p> 以下代码示例是伪代码，并浏览一天。有关工作C ++代码，请参阅GitHub上的示例。</p><p> 我们注意，如果我们已经分区了数组的两半，我们可以通过交换和来计算两者的分区。在阵列中交换相邻块有时旋转，并且可以在线性时间完成，例如使用反转（观察）。 </p><p>所以我们可以使用鸿沟和征服。使用递归函数，该函数将在中间的阵列中进行，这会及时运行并需要堆栈空间。</p><p> stable_partition_recuraive（第一，n，pred）{if（n == 1）{return pred（first）？第一+ 1：第一; left = stable_partition_rocuraive（第一，n / 2，pred）;中间=第一+ n / 2;右= stable_partition_rocuraive（中间，n  -  n / 2，pred）;旋转（左，中，右）;返回左+（右中间）; }</p><p> 更好，但理想情况下，我们希望只使用恒定的额外空间。要实现这一点，我们可以使用与自下而上的合并排序相同的技术。我们首先在尺寸2的块中处理阵列，然后在大小4的块中（其大小2的两半是alereaparted的两半），等等，直到我们处理整个阵列作为一个块。</p><p> stable_partition_bottomup（first，n，pred）{for（width = 1;宽度<n;宽度* = 2）{next =首先; for（i = 0; i＆lt; n; i + = 2 *宽）{limit = n  -  i＆lt; 2 *宽？ n  -  I：2 *宽; if（限制＆gt;宽度）{中间=下一个+宽度; left = std :: find_f_not（下一个，中间，pred）; next = leid + width right = std :: find_if_not（中间，下一个，pred）;旋转（左，中，右）;返回左+（右中间）; }</p><p>  从某种意义上说，我们支付的价格避免递归是我们不记得两半的分区点，需要再次找到它们。易于使用谓词时间而不是。</p><p> 但是，由于两半已经分区，我们可以使用二进制搜索来查找分区点。这减少了谓词ApplicationSto（自从）的数量，我们具有与递归算法的相同时间复杂性，但使用恒定的额外空间。</p><p> stable_partition_bsearch（first，n，pred）{for（宽度= 1;宽度<n;宽度* = 2）{next =首先; for（i = 0; i＆lt; n; i + = 2 *宽）{limit = n  -  i＆lt; 2 *宽？ n  -  I：2 *宽; if（限制＆gt;宽度）{中间=下一个+宽度; left = std :: partition_point（下一个，中间，pred）; Next = leid + width right = std :: partition_point（中间，下一个，pred）;旋转（左，中，右）;返回左+（右中间）; } </p><p>如果数组几乎分区，则这些算法仍然通过EveryStep。我们可以做一些类似于自然合并排序的东西，并重复需要旋转的下一个地方，如果我们发现没有，则停止。虽然必须小心，但如果我们只是寻找区域并旋转它们，我们会在交替上获得二次时间模式。相反，我们可以寻找并旋转中间两个，就像上面一样。</p><p> stable_partition_natural（首先，最后一个，pred）{do {next = first;变化= false; do {left = std :: find_f_not（下一个，最后一个，pred）;中间= std :: find_if（左，最后，pred）;右= std :: find_f_not（中间，最后一个，pred）; next = std :: find_if（右，最后，pred）;如果（左！=中间＆amp;中间！=右）{旋转（左，中，右）;变化=真; }} while（下一个！=最后）; } while（改变）; }</p><p> 尽可能在此过程中，虽然最坏的情况复杂性是相同的自下而上版本。由于宽度不再是固定的大小，因此我们对分区点的线性搜索拓扑进行了拓扑搜索，因此备注的数量返回。此外，我们必须使用predicateo找到中间和下一个起点，所以我们可能会使用比自下而上的版本更多的档案。</p><p> 有一种算法可以在使用Conforstant额外空间（PDF）中执行稳定的分区，但它有些涉及，并且给定特定任务的约束不实际。</p><p> 让我们回到重新排序的论点问题。这里有一个问题是WeCannot判断任何给定的元素是否是一个选项，选项参数或anonoption，而无需将整个数组解析到该点（即，我们不能随机访问）。</p><p> 这是因为任何给定的元素都可以通过使用它的选项来之前，它选项参数（查看前一个元素是不够的，真的可能是一个选项参数而不是一个选项）。或者可能存在 - 某个地方，这意味着剩下的元素是非选择（除非该剩余元素实际上是前一个选项的选项参数）。</p><p> 这使得自然算法具有良好的契合，因为它在每个循环中从左到右施加雷尼比。 </p><p>那么这一切如何与Getopt实现进行比较？ 通过扫描来自ChiCurrent位置的任何非活动，然后将其扫描到每个呼叫中的两个呼叫中的重新排序，然后将它们旋转到阵列的末尾。 此效率地构建了最后的非活动阵列，同时向下移动尚未处理的部分。  这需要恒定的额外空间，但需要最坏的情况。这可能理论上可以在算法复杂性攻击中使用，大多数系统以某种方式限制命令行参数的大小。 作为最坏情况行为的一个例子，下行使用200,000nOnOptions运行LS（重定向缺少文件的错误消息），需要大约0.3秒（Fedora 24在VM中运行）：  而这一行以相同数量的参数运行LS，但allowaneNonOptions和选项（-a选项启用启动句点的文件，并且在这种情况下没有效果），并且需要11秒： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://hardtoc.com/2016/11/07/reordering-arguments.html">http://hardtoc.com/2016/11/07/reordering-arguments.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/排序/">#排序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>