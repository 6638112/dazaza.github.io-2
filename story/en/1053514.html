<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>去声明被认为有害（2018） Go Statement Considered Harmful (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Go Statement Considered Harmful (2018)<br/>去声明被认为有害（2018） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 09:03:46</div><div class="page_narrow text-break page_content"><p>Every concurrency API needs a way to run code concurrently. Here&#39;ssome examples of what that looks like using different APIs:</p><p>每个并发API都需要一种方法并发运行代码。这里＆＃39; SSOME示例看起来像使用不同的API：</p><p> go myfunc(); // Golangpthread_create(&amp;thread_id, NULL, &amp;myfunc); /* C with POSIX threads */spawn(modulename, myfuncname, []) % Erlangthreading.Thread(target=myfunc).start() # Python with threadsasyncio.create_task(myfunc()) # Python with asyncio</p><p> go myfunc（）; // golangpthread_create（＆amp; thread_id，null，＆amp; myfunc）; / * c用posix线程* / spawn（moduleename，myfuncname，[]）％erlangthreading.thread（target = myfunc）.start（）＃python与threadsasyncio.create_task（myfunc（）＃python与asyncio</p><p> There are lots of variations in the notation and terminology, but thesemantics are the same: these all arrange for  myfunc to startrunning concurrently to the rest of the program, and then returnimmediately so that the parent can do other things.</p><p> 符号和术语有很多变化，但是andics是相同的：这些都将MyFunc同时安排到术语的其余部分，然后返回父母可以做其他事情。</p><p>  QObject::connect(&amp;emitter, SIGNAL(event()), // C++ with Qt &amp;receiver, SLOT(myfunc()))g_signal_connect(emitter, &#34;event&#34;, myfunc, NULL) /* C with GObject */document.getElementById(&#34;myid&#34;).onclick = myfunc; // Javascriptpromise.then(myfunc, errorhandler) // Javascript with Promisesdeferred.addCallback(myfunc) # Python with Twistedfuture.add_done_callback(myfunc) # Python with asyncio</p><p>  qobject :: connect（＆amp;发射器，信号（事件（）），// c ++带有qt＆amp;接收器，插槽（myfunc（））g_signal_connect（发射器，＆＃34;事件＆＃34;，myfunc，null）/ * c使用gobject * / document.getelementbyid（＆＃34; myid＆＃34;）。onclick = myfunc; // javascriptpromise.then（myfunc，errorhandler）// javascript与promisesdeferred.addcallback（myfunc）＃python with twistedfuture.add_done_callback（myfunc）＃python与asyncio</p><p> Again, the notation varies, but these all accomplish the same thing:they arrange that from now on, if and when a certain event occurs,then  myfunc will run. Then once they&#39;ve set that up, theyimmediately return so the caller can do other things. (Sometimescallbacks get dressed up with fancy helpers like  promise combinators,or  Twisted-style protocols/transports,but the core idea is the same.)</p><p> 同样，符号变化，但这些都完成了同样的事情：它们排列从现在开始，如果发生某个事件，则MyFunc将运行。然后一旦他们＆＃39; ve设置了，他们会返回，所以呼叫者可以做其他事情。 （有时候戴着花哨的助手，如promise组合者，或扭曲式协议/运输，但核心想法是相同的。）</p><p> And... that&#39;s it. Take any real-world, general-purpose concurrencyAPI, and you&#39;ll probably find that it falls into one or the other ofthose buckets (or sometimes both, like asyncio).</p><p> 而......那＆＃39;它。采用任何现实世界，通用的ConcurrencyAPI，你＆＃39; ll可能会发现它落入一个或另一个桶（或有时都像异步）。</p><p> But my new library  Trio is weird. Itdoesn&#39;t use either approach. Instead, if we want to run  myfunc and anotherfunc concurrently, we write something like:</p><p> 但我的新图书馆三重奏是奇怪的。它使用任何一种方法都使用它。相反，如果我们想同时运行myfunc和另一个职位，我们会写一些如： </p><p>  When people first encounter this &#34;nursery&#34; construct, they tend tofind it confusing. Why is there an indented block? What&#39;s this nursery object, and why do I need one before I can spawn a task?Then they realize that it prevents them from using patterns they&#39;vegotten used to in other frameworks, and they get really annoyed. Itfeels quirky and idiosyncratic and too high-level to be a basicprimitive. These are understandable reactions! But bear with me.</p><p>当人们第一次遇到这个＆＃34;托儿所＆＃34;构建，他们倾向于混淆。为什么有一个缩进的块？什么＆＃39;这个托儿所对象，以及在我可以产生任务之前，为什么我需要一个？然后他们意识到它可以防止他们使用它们＆＃39; vegotten习惯于其他框架，他们真的很生气。 ITFEELS QUIRKY和特质，过高的级别是基本的。这些是可理解的反应！但与我忍受。</p><p> In this post, I want to convince you that nurseries aren&#39;t quirky oridiosyncratic at all, but rather a new control flow primitive that&#39;sjust as fundamental as for loops or function calls. And furthermore,the other approaches we saw above – thread spawning and callbackregistration – should be removed entirely and replaced withnurseries.</p><p> 在这篇文章中，我想说服你的苗圃＆＃39; t古怪的oridiosyncratic根本，而是一个新的控制流原子，即＆＃39;调整为循环或函数呼叫的基本。此外，我们看到上面的其他方法 - 螺纹产卵和呼叫重复 - 应完全删除并替换含有持疗。</p><p> Sound unlikely? Something similar has actually happened before: the goto statement was once the king of control flow. Now it&#39;s a punchline. A few languages still havesomething they call  goto, but it&#39;s different and far weaker thanthe original  goto. And most languages don&#39;t even have that. Whathappened? This was so long ago that most people aren&#39;t familiar withthe story anymore, but it turns out to be surprisingly relevant. Sowe&#39;ll start by reminding ourselves what a  goto was, exactly, andthen see what it can teach us about concurrency APIs.</p><p> 听起来不太可能？之前发生了类似的东西：Goto声明曾经是控制流的王。现在它＆＃39; s一个妙语。几种语言仍然是他们称之为Goto，但它的不同和较弱的Thanthe原始Goto＆＃39;而且大多数语言Don＆＃39; t甚至有那个。发生了什么？很久以前那么大多数人都不再熟悉这个故事，但事实证得令人惊讶地相关。 SOWE＆＃39; LL首先提醒自己，完全是什么，安直看到它可以教我们关于并发性API的内容。</p><p>  Let&#39;s review some history: Early computers were programmed using assembly language, or other evenmore primitive mechanisms. This kinda sucked. So in the 1950s, peoplelike  John Backus atIBM and  Grace Hopperat Remington Rand started to develop languages like  FORTRAN and  FLOW-MATIC (better known for itsdirect successor  COBOL).</p><p>  让＆＃39;查看一些历史记录：使用汇编语言或其他甚至更多的原始机制编程早期计算机。这有点吸了。因此，在20世纪50年代，Peoplelike John Backus Atibm和Grace Hopperat Remington Rand开始开发像Fortran和Flow-Matic这样的语言（因为它为其直接继任Cobol而闻名）。</p><p> FLOW-MATIC was very ambitious for its time. You can think of it asPython&#39;s great-great-great-...-grandparent: the first language thatwas designed for humans first, and computers second. Here&#39;s someFLOW-MATIC code to give you a taste of what it looked like:</p><p> 流动matic是雄心勃勃的时间。你可以想到它aspython＆＃39; s伟大的大伟大 -  ...  - 祖父母：第一语言为人类设计，电脑为第二种语言。在这里＆＃39; s某种流动的代码，让您品尝它看起来像的东西：</p><p>  You&#39;ll notice that unlike modern languages, there&#39;s no  if blocks,loop blocks, or function calls here – in fact there&#39;s no blockdelimiters or indentation at all. It&#39;s just a flat list of statements.That&#39;s not because this program happens to be too short to use fanciercontrol syntax – it&#39;s because block syntax wasn&#39;t invented yet!</p><p>  你＆＃39;请注意，与现代语言不同，在这里，如果块，循环块或函数呼叫，实际上是那里的块，循环块或函数根本没有块状物或缩进。它只是一个平面的陈述列表.That＆＃39; s不是因为这个程序恰好太短暂，无法使用fanciercontrol语法 - 它＆＃39; s，因为块语法＆＃39; t尚未发明！</p><p> Sequential flow represented as a vertical arrow pointingdown, and goto flow represented as an arrow that startspointing down and then leaps off to the side.</p><p> 序列流量表示为垂直箭头指向，并且GOTO流量表示为箭头，起步下来，然后跳到侧面。 </p><p> Instead, FLOW-MATIC had two options for flow control. Normally, it wassequential, just like you&#39;d expect: start at the top and movedownwards, one statement at a time. But if you execute a specialstatement like  JUMP TO, then it could directly transfer controlsomewhere else. For example, statement (13) jumps back to statement(2):</p><p>相反，流动MINT有两个用于流量控制的选项。通常情况下，它是顺序的，就像你一样＆＃39; D期望：从顶部和移动，一次一个陈述。但是，如果执行像跳转一样的专业名称，那么它可以直接转移控制器其他地方。例如，语句（13）跳回声明（2）：</p><p>  Just like for our concurrency primitives at the beginning, there wassome disagreement about what to call this &#34;do a one-way jump&#34;operation. Here it&#39;s  JUMP TO, but the name that stuck was  goto(like &#34;go to&#34;, get it?), so that&#39;s what I&#39;ll use here.</p><p>  就像我们开始的并发原语一样，有关于将此称之为何种方式的大量分歧＆＃34;做单向跳跃＆＃34;操作。它跳转到，但跳到了，但困住的名字是转到的（比如＆＃34;去＆＃34;得到它？），所以和＃39; s什么我＆＃39; ll在这里使用。</p><p>   If you think this looks confusing, you&#39;re not alone! This style ofjump-based programming is something that FLOW-MATIC inherited prettymuch directly from assembly language. It&#39;s powerful, and a good fit tohow computer hardware actually works, but it&#39;s super confusing to workwith directly. That tangle of arrows is why the term &#34;spaghetti code&#34;was invented. Clearly, we needed something better.</p><p>   如果你认为这看起来很困惑，你＆＃39;不孤单！这种基于jump的编程的样式是流动 -  matic incontited pastymuch直接从汇编语言。它＆＃39;强大，良好的拟合电脑硬件实际上是有效的，但它的超级混淆直接工作。箭头的纠结是为什么这个词和＃34;意大利面条代码＆＃34;是发明的。显然，我们需要更好的东西。</p><p> But... what is it about  goto that causes all these problems? Whyare some control structures OK, and some not? How do we pick the goodones? At the time, this was really unclear, and it&#39;s hard to fix aproblem if you don&#39;t understand it.</p><p> 但是...... Goto是什么导致所有这些问题？ Whyare一些控制结构好，有些不是？我们如何挑着套对？当时，如果你不了解它，这真的不清楚，＆＃39;如果你不理解它，难以解决一个问题。</p><p> But let&#39;s hit pause on the history for a moment – everyone knows goto was bad. What does this have to do with concurrency? Well,consider Golang&#39;s famous  go statement, used to spawn a new&#34;goroutine&#34; (lightweight thread):</p><p> 但是，让＆＃39;在历史上暂停暂停一会儿 - 每个人都知道转到很糟糕。这与并发性有什么关系？好吧，考虑Golang＆＃39;着名的Go声明，习惯了一个新的＆＃34; Goroutine＆＃34; （轻质线程）：</p><p>  Can we draw a diagram of its control flow? Well, it&#39;s a littledifferent from either of the ones we saw above, because controlactually splits. We might draw it like:</p><p>  我们可以绘制其控制流程图吗？好吧，它＆＃39;从我们看过的任何一个都是一个小型的东西，因为控制暂停了分裂。我们可能会像：</p><p> &#34;Go&#34; flow represented as two arrows: a green arrow pointingdown, and a lavender arrow that starts pointing down and thenleaps off to the side.</p><p> ＆＃34;去＆＃34;流量表示为两个箭头：绿色箭头指向，以及开始指向侧面的薰衣草箭头，然后向侧面向上。 </p><p> Here the colors are intended to indicate that  both paths are taken.From the perspective of the parent goroutine (green line), controlflows sequentially: it comes in the top, and then immediately comesout the bottom. Meanwhile, from the perspective of the child (lavenderline), control comes in the top, and then jumps over to the body of myfunc. Unlike a regular function call, this jump is one-way: whenrunning  myfunc we switch to a whole new stack, and the runtimeimmediately forgets where we came from.</p><p>这里的颜色旨在指示两条路径。从父goroutine（绿线）的角度来看，控制流程顺序：它进入顶部，然后立即汇出底部。同时，从孩子的角度（Lavenderline），控制进入顶部，然后跳到MyFunc的身体。与常规函数调用不同，此跳转是单向的：当Running MyFunc我们切换到一个全新的堆栈，并且运行立场终止忘记我们来自哪里。</p><p> But this doesn&#39;t just apply to Golang. This is the flow controldiagram for  all of the primitives we listed at the beginning of thispost:</p><p> 但这并不是申请戈兰。这是我们在本柱开始时列出的所有基元的流量兼容兼容性：</p><p> Threading libraries usually provide some sort of handle object thatlets you  join the thread later – but this is an independentoperation that the language doesn&#39;t know anything about. The actualthread spawning primitive has the control flow shown above.</p><p> 线程库通常提供某种您稍后加入线程的句柄对象 - 但这是一种独立的语言，语言没有知道。实际产卵原语具有上述控制流程。</p><p> Registering a callback is semantically equivalent to starting abackground thread that (a) blocks until some event occurs, andthen (b) runs the callback. (Though obviously the implementation isdifferent.) So in terms of high-level control flow, registering acallback is essentially a  go statement.</p><p> 注册回调是语义上等同于启动abackground线程（a）块，直到发生一些事件，并且然后（b）运行回调。 （虽然显然，实施是有关的。）因此，在高级控制流程方面，注册acallback基本上是一个go语句。</p><p> Futures and promises are the same too: when you call a function andit returns a promise, that means it&#39;s scheduled the work to happenin the background, and then given you a handle object to join thework later (if you want). In terms of control flow semantics, thisis just like spawning a thread. Then you register callbacks on thepromise, so see the previous bullet point.</p><p> 期货和承诺也是一样的：当你召唤函数并返回一个承诺，这意味着它＆＃39; s计划发生在后台的工作，然后给你一个句柄对象以稍后加入Thework的句柄对象（如果需要）。在控制流程语义方面，此目的就像产卵一个线程一样。然后，您注册了摘要的回调，因此请参阅上一个项目符号。</p><p> This same exact pattern shows up in many, many forms: the keysimilarity is that in all these cases, control flow splits, with oneside doing a one-way jump and the other side returning to the caller.Once you know what to look for, you&#39;ll start seeing it all over theplace – it&#39;s a fun game!  [1]</p><p> 这种相同的明确模式在许多情况下显示出多种形式：keysiemillity在所有这些情况下，控制流量拆分，其中一个单向跳转和另一侧返回给呼叫者。您知道要查找的内容，你＆＃39; ll开始在地球上看到它 - 它＆＃39; sa fun game！ [1]</p><p> Annoyingly, though, there is no standard name for this category ofcontrol flow constructs. So just like &#34; goto statement&#34; became theumbrella term for all the different  goto-like constructs, I&#39;mgoing to use &#34; go statement&#34; as a umbrella term for these. Why go? One reason is that Golang gives us a particularly pure exampleof the form. And the other is... well, you&#39;ve probably guessed whereI&#39;m going with all this. Look at these two diagrams. Notice anysimilarities?</p><p> 但是，令人讨厌的是，这个类别的Constrol Flow构造没有标准名称。所以就像＆＃34; goto声明＆＃34;成为所有不同的Goto的构建体，I＆＃39的题柱术语;使用＆＃34; Go声明＆＃34;作为这些伞术语。为什么要去？一个原因是戈兰给我们一个特别纯粹的例子。而另一个是......好吧，你可能猜到了所有的猜测。看看这两个图。通知任何激励吗？ </p><p> Repeat of earlier diagrams: goto flow represented as an arrowthat starts pointing down and then leaps off to the side, and&#34;go&#34; flow represented as two arrows: a green arrow pointingdown, and a lavender arrow that starts pointing down and thenleaps off to the side.</p><p>重复较早的图：转到的流量表示为箭头，开始指向向下，然后跳到侧面，和＃34; Go＆＃34;流量表示为两个箭头：绿色箭头指向，以及开始指向侧面的薰衣草箭头，然后向侧面向上。</p><p>  Concurrent programs are notoriously difficult to write and reasonabout. So are  goto-based programs. Is it possible that this mightbe for some of the same reasons? In modern languages, the problemscaused by  goto are largely solved. If we study how they fixed goto, will it teach us how to make more usable concurrency APIs?Let&#39;s find out.</p><p>  并发计划尚不难以编写和原理。所以基于GOTO的程序。是否有可能出于一些同样的原因？在现代语言中，Goto的问题很大程度上得到了解决。如果我们研究他们如何修复到达，它会教我们如何制作更具可用的并发性API？让＆＃39;发现。</p><p> So what is it about  goto that makes it cause so many problems? Inthe late 1960s,  Edsger W. Dijkstra wrote a pair ofnow-famous papers that helped make this much clearer:  Go to statementconsidered harmful,and  Notes on structured programming (PDF).</p><p> 那么Goto是什么意思，这使得它导致这么多问题？ 20世纪60年代末期，Edsger W. Dijkstra写了一对非法着名的论文，帮助让这更清楚：转到陈述的有害，以及结构化编程（PDF）的注意事项。</p><p> In these papers, Dijkstra was worried about the problem of how youwrite non-trivial software and get it correct. I can&#39;t give them duejustice here; there&#39;s all kinds of fascinating insights. For example,you may have heard this quote:</p><p> 在这些论文中，Dijkstra担心Hywrite非琐碎软件的问题并获得正确的问题。我可以＆＃39;在这里给予他们的职责;有各种迷人的见解。例如，您可能已经听过此报价：</p><p>  Yep, that&#39;s from  Notes on structured programming. But his majorconcern was  abstraction. He wanted to write programs that are toobig to hold in your head all at once. To do this, you need to treatparts of the program like a black box – like when you see a Pythonprogram do:</p><p>  是的，从结构化编程的笔记中，＆＃39。但他的主持人是抽象的。他想写一下Toobig的程序一次。为此，您需要像黑匣子一样对待该程序 - 就像你看到PythonProgram一样：</p><p>  then you don&#39;t need to know all the details of how  print isimplemented (string formatting, buffering, cross-platform differences,...). You just need to know that it will somehow print the text yougive it, and then you can spend your energy thinking about whetherthat&#39;s what you want to have happen at this point in your code.Dijkstra wanted languages to support this kind of abstraction.</p><p>  然后你不需要了解如何打印Isimplemented的所有细节（字符串格式，缓冲，跨平台差异，......）。您只需要知道它会以某种方式打印文本yougive它，然后您可以花费你的能量思考这一点，在您的代码中您想要发生的情况.Dijkstra想要的语言来支持这种情况抽象。</p><p> By this point, block syntax had been invented, and languages likeALGOL had accumulated ~5 distinct types of control structure: theystill had sequential flow and  goto:</p><p> 到目前为止，已经发明了块语法，语言LikeAlgol积累了〜5种不同类型的控制结构：它们有顺序流量和转到： </p><p>    You can implement these higher-level constructs using  goto, andearly on, that&#39;s how people thought of them: as a convenientshorthand. But what Dijkstra pointed out is that if you look at thesediagrams, there&#39;s a big difference between  goto and the rest. Foreverything except  goto, flow control comes in the top → [stuffhappens] → flow control comes out the bottom. We might call this the&#34;black box rule&#34;: if a control structure has this shape, then incontexts where you don&#39;t care about the details of what happensinternally, you can ignore the [stuff happens] part, and treat thewhole thing as regular sequential flow. And even better, this is alsotrue of any code that&#39;s  composed out of those pieces. When I look atthis code:</p><p>您可以使用GOTO，ANDEARLY on，＆＃39;人们如何想到它们：作为一个促进者，可以实现这些更高级别的构造但是Dijkstra指出的是，如果你看看奇异图，那么Goto和其他人之间有很大的区别。 Foreverything除了GOTO，流量控制进入顶部→[stamphappens]→流量控制出来底部。我们可能会致电这个＆＃34;黑匣子规则＆＃34 ;:如果控制结构有这种形状，那么无论你在哪里都在哪里＆＃39; t关心幸福的内容的细节，你可以忽略[东西发生]部分，并以定期顺序流量对待换取的东西。甚至更好，这是任何代码的alsotrue＆＃39; s由这些碎片组成。当我看这个代码时：</p><p>  I don&#39;t have to go read the definition of  print and all itstransitive dependencies just to figure out how the control flow works.Maybe inside  print there&#39;s a loop, and inside the loop there&#39;s anif/else, and inside the if/else there&#39;s another function call... ormaybe it&#39;s something else. It doesn&#39;t really matter: I know controlwill flow into  print, the function will do its thing, and theneventually control will come back to the code I&#39;m reading.</p><p>  我不得不阅读打印和所有意外依赖性的定义，只是为了弄清楚控制流程的方法.Meybe内部打印那里＆＃39; SA循环，以及在那里的循环内部，在If / ides中，在那里的另一个函数调用...... ormaybe它＆＃39; s别的东西。它并不是重视：我知道控制势力进入打印，这个功能会做它的东西，然后文本控制将回到代码i＆＃39;读。</p><p> It may seem like this is obvious, but if you have a language with goto – a language where functions and everything else are built ontop of  goto, and  goto can jump anywhere, at any time – thenthese control structures aren&#39;t black boxes at all! If you have afunction, and inside the function there&#39;s a loop, and inside the loopthere&#39;s an if/else, and inside the if/else there&#39;s a  goto... thenthat  goto could send the control anywhere it wants. Maybe controlwill suddenly return from another function entirely, one you haven&#39;teven called yet. You don&#39;t know!</p><p> 它看起来很明显，但如果你有一个goto的语言 - 一种函数和其他一切都建立了到达的东西的语言，并且转到可以随时随地跳跃 -  Thenthese控制结构aren＆＃39; t黑色盒子！！如果您有一定功能，并且在其中的功能内部＆＃39; sa循环，以及在Loopthere＆＃39; s中的一个，以及在If / else中，在If / else中有＃39; sa got ... thenthat goto可以发送控件它想要的任何地方。也许控制器完全突然从另一个函数返回，一个你没有＆＃39; Teven叫做。你不知道！</p><p> And this breaks abstraction: it means that  every function call ispotentially a  goto  statement in disguise, and the only way toknow is to keep the entire source code of your system in your head atonce. As soon as  goto is in your language, you stop being able dolocal reasoning about flow control. That&#39;s  why  goto leads tospaghetti code.</p><p> 并且这突破了抽象：这意味着每个函数调用伪装中的GOTO语句，唯一的方式是要将系统的整个源代码保持在头部atonce。只要转到了你的语言，你就可以停止能够关于流量控制的Dolocal推理。这＆＃39;为什么转到罗h t h。</p><p> And now that Dijkstra understood the problem, he was able to solve it.Here&#39;s his revolutionary proposal: we should stop thinking ofif/loops/function calls as shorthands for  goto, but rather asfundamental primitives in their own rights – and we should remove goto entirely from our languages.</p><p> 现在Dijkstra了解这个问题，他能够解决它。他的革命性提案：我们应该停止思考off /循环/函数调用作为转到的速记，而是在他们自己的权利中的非法原语 - 我们应该完全从语言中删除Goto。</p><p> From here in 2018, this seems obvious enough. But have you seen howprogrammers react when you try to take away their toys because they&#39;renot smart enough to use them safely? Yeah, some things never change.In 1969, this proposal was  incredibly controversial.  Donald Knuth  defended goto. People who had become experts on writing code with  gotoquite reasonably resented having to basically learn how to programagain in order to express their ideas using the newer, moreconstraining constructs. And of course it required building a wholenew set of languages.</p><p> 从2018年开始，这似乎很明显。但是你看过如何在你试图带走玩具时如何做出反应，因为它们＆＃39; renot smart足够聪明地安全使用它们？是的，有些事情永远不会改变。1969年，这个提议是令人难以置信的争议。 Donald Knuth捍卫了转达。已成为书面代码专家的人合理地憎恨，必须基本上学习如何将他们的想法表达使用较新的潮流构建构建。当然，它需要构建一套背包的语言。</p><p>  In the end, modern languages are a bit less strict about this thanDijkstra&#39;s original formulation. They&#39;ll let you break out of multiplenested structures at once using constructs like  break, continue, or  return. But fundamentally, they&#39;re all designedaround Dijkstra&#39;s idea; even these constructs that push the boundariesdo so only in strictly limited ways. In particular, functions – whichare the fundamental tool for wrapping up control flow inside a blackbox – are considered inviolate. You can&#39;t  break out of onefunction and into another, and a  return can take you out of thecurrent function, but no further. Whatever control flow shenanigans afunction gets up to internally, other functions don&#39;t have to care.</p><p>  最终，现代语言对此Thandijkstra＆＃39的原始制定有点严格。它们＆＃39; LL让您使用像休息，继续或返回等构造，让您立即突出多平台结构。但从根本上讲，他们＆＃39;重新设计所有设计的dijkstra＆＃39;我们的想法;即使这些构造也只按照严格限制的方式推动界限。特别是，函数 - 围绕黑箱内包装控制流的基本工具 - 被认为是不可侵入的。你可以＆＃39; t and tonefunction和另一个人分手，返回可以把你带出你的函数，但没有进一步。无论控制流动的行流，Shenanigans一定是在内部启动，其他功能不得不关心。 </p><p> This even extends to  goto itself. You&#39;ll find a few languages thatstill have something they call  goto, like C, C#, Golang, ... butthey&#39;ve added heavy restrictions. At the very least, they won&#39;t letyou jump out of one function body and into another. Unless you&#39;reworking in assembly  [2], the classic, unrestricted  goto is gone.Dijkstra won.</p><p>这甚至延伸到Goto本身。你＆＃39; ll找到几种语言，instill有一些他们称之为的东西，就像c，c＃，golang，... butthey＆＃39; ve增加了严重的限制。至少，他们赢得了＆＃39;那么让你跳出一个功能体并进入另一个功能。除非你＆＃39;在装配[2]中重新加工[2]，经典，不受限制的转到走了.dijkstra赢了。</p><p> And once  goto disappeared, something interesting happened:language designers were able to start adding features that depend oncontrol flow being structured.</p><p> 一旦转到消失了，发生了一些有趣的事情：语言设计师能够开始添加依赖于结构化的功能的功能。</p><p> For example, Python has some nice syntax for resource cleanup: the with statement. You can write things like:</p><p> 例如，Python具有一些很好的资源清理语法：使用语句。你可以写这样的东西：</p><p>  and it guarantees that the file will be open during the  ... code,but then closed immediately afterward. Most modern languages have someequivalent (RAII,  using, try-with-resource,  defer, ...). Andthey all assume that control flows in an orderly, structured way. Ifwe used  goto to jump into the middle of our  with block... whatwould that even do? Is the file open or not? What if we jumped outagain, instead of exiting normally? Would the file get closed? Thisfeature just doesn&#39;t work in any coherent way if your language has goto in it.</p><p>  并且它保证了文件在...代码期间将打开，但之后立即关闭。大多数现代语言都有SomeeQuivalent（Raii，使用，尝试资源，推迟，......）。并所有人都假定控制有序，结构化的方式流动。如果我们使用goto跳入我们的块中间......甚至会做什么？文件是否打开？如果我们跳过外面，而不是正常退出怎么办？文件会关闭吗？如果您的语言在其中格式化，这只事图就在任何连贯的方式工作。</p><p> Error handling has a similar problem: when something goes wrong, whatshould your code do? Often the answer is to pass the buck up the stackto your code&#39;s caller, let them figure out how to deal with it. Modernlanguages have constructs specifically to make this easier, likeexceptions, or other forms of  automatic error propagation.But your language can only provide this help if it  has a stack, anda reliable concept of &#34;caller&#34;. Look again at the control-flowspaghetti in our FLOW-MATIC program and imagine that in the middle ofthat it tried to raise an exception. Where would it even go?</p><p> 错误处理有类似的问题：当出现问题时，你的代码是什么？答案通常是将COUNK上调到代码＆＃39;呼叫者，让他们弄清楚如何处理它。现代语言具有专门的构造，以便使这更容易，更像，或其他形式的自动错误传播。但是如果它有一个堆栈，并且可靠的概念，你的语言只能提供这个帮助。呼叫者＆＃34;在我们的流动模拟中再次查看控制弗洛伊盖章，并想象在它中间，它试图提出异常。它甚至会去哪里？</p><p> So  goto – the traditional kind that ignores function boundaries –isn&#39;t just the regular kind of bad feature, the kind that&#39;s hard touse correctly. If it were, it might have survived – lots of badfeatures have. But it&#39;s much worse.</p><p> 所以转到 - 传统的形式，忽略了函数边界 - 是常规类型的坏功能，那种＆＃39; s坚硬的速度正确。如果是，它可能会幸存下来 - 很多糟糕的成果。但它＆＃39;更糟糕。</p><p>  Even if you don&#39;t use  goto yourself, merely having it as an optionin your language makes  everything harder to use. Whenever you startusing a third-party library, you can&#39;t treat it as a black box – youhave to go read through it all to find out which functions are regularfunctions, and which ones are idiosyncratic flow control constructs indisguise. This is a serious obstacle to local reasoning. And you losepowerful language features like reliable resource cleanup andautomatic error propagation. Better to remove  goto entirely, infavor of control flow constructs that follow the &#34;black box&#34; rule.</p><p>  即使你不使用goto自己，也只是把它作为一种选择，你的语言使一切难以使用。每当你开始第三方库时，你就可以＆＃39把它视为一个黑匣子 - 你读到一切都知道哪些功能是规范功能，哪些功能是特殊流量控制构造的结构。这是当地推理的严重障碍。而且您的Losepower语言功能如可靠的资源清理和自动错误传播。更好地完全去除Goto，介绍＆＃34;黑匣子＆＃34的控制流量构造规则。 </p><p> So that&#39;s the history of  goto. Now, how much of this applies to go statements? Well... basically, all of it! The analogy turns outto be shockingly exact.</p><p>所以＆＃39; soto的历史。现在，这有多少适用于陈述？好吧......基本上，所有的！比喻变得令人震惊的精确。</p><p> Go statements break abstraction. Remember how we said that if ourlanguage allows  goto, then any function might be a  goto indisguise? In most concurrency frameworks,  go statements cause theexact same problem: whenever you call a function, it might or mightnot spawn some background task. The function seemed to return, but isit still running in the background? There&#39;s no way to know withoutreading all its source code, transitively. When will it finish? Hardto say. If you have  go statements, then functions are no longerblack boxes with respect to control flow. In my  first post onconcurrency APIs,I called this &#34;violating causality&#34;, and found that it was the rootcause of many common, real-world issues in programs using asyncio andTwisted, like problems with backpressure, problems with shutting downproperly, and so forth.</p><p> GO陈述中断抽象。还记得我们如何说，如果我们的语言允许转到，那么任何功能都可能是Goto IndisGuise？在大多数并发框架中，Go语句会导致此操作相同的问题：每当您调用函数时，它可能会或可能会产生一些后台任务。这个函数似乎返回，但仍然在后台运行？没有办法知道没有其源代码过境的所有源代码。什么时候结束？很难说。如果您有Go陈述，则函数不受控制流程的长框。在我的第一个发布帖子onconcurrency apis中，我打电话给这个＆＃34;违反了因果关系＆＃34;，发现它是使用Asyncio Andtwisted的程序中许多常见的现实世界问题的rootiaause，就像背压一样，关闭问题的问题等等。</p><p>   Before, we said that we were &#34;guaranteed&#34; that the file will be openwhile the  ... code is running, and then closed afterwards. Butwhat if the  ... code spawns a background task? Then our guaranteeis lost: the operations that  look like they&#39;re inside the  withblock might actually keep running  after the  with block ends, andthen crash because the file gets closed while they&#39;re still using it.And again, you can&#39;t tell from local inspection; to know if this ishappening you have to go read the source code to all the functionscalled inside the  ... code.</p><p>   之前，我们说我们是＆＃34;保证＆＃34;该文件将是openwhile ...代码正在运行，然后之后关闭。但是如果...代码产生后台任务？然后我们的保证丢失了，看起来像它们的操作＆＃39;在用块结束后，re在with块内部可能会继续运行，因为文件在它们仍然使用它时关闭。再次，您可以＆从本地检​​查中＃39;要知道这个Ishappening是否必须将源代码读到...代码内的所有功能。</p><p> If we want this code to work properly, we need to somehow keep trackof any background tasks, and manually arrange for the file to beclosed only when they&#39;re finished. It&#39;s doable – unless we&#39;re usingsome library that doesn&#39;t provide any way to get notified when thetask is finished, which is distressingly common (e.g. because itdoesn&#39;t expose any task handle that you can join on). But even in thebest case, the unstructured control flow means the language can&#39;t helpus. We&#39;re back to implementing resource cleanup by hand, like in thebad old days.</p><p> 如果我们希望这段代码正常工作，我们需要以某种方式跟踪任何后台任务，并手动安排文件仅在他们完成时才成为唯一的文件。它＆＃39;除非我们＆＃39; refumentsome图书馆，除非＆＃39; t，它没有提供任何方法在完成时收到通知，这是令人作呕的常见（例如，因为它是它揭露了您的任何任务处理可以加入）。但即使在最明白的情况下，非结构化控制流程也意味着语言可以＆＃39; t HOLKUS。我们＆＃39;重新返回手用手实施资源清理，就像在过去的日子里一样。</p><p> Go statements break error handling. Like we discussed above,modern languages provide powerful tools like exceptions to help usmake sure that errors are detected and propagated to the right place.But these tools depend on having a reliable concept of &#34;the currentcode&#39;s caller&#34;. As soon as you spawn a task or register a callback,that concept is broken. As a result, every mainstream concurrencyframework I know of simply gives up. If an error occurs in abackground task, and you don&#39;t handle it manually, then the runtimejust... drops it on the floor and crosses its fingers that it wasn&#39;ttoo important. If you&#39;re lucky it might print something on theconsole. (The only other software I&#39;ve used that thinks &#34;printsomething and keep going&#34; is a good error handling strategy is grottyold Fortran libraries, but here we are.) Even Rust – the languagevoted Most Obses</p><p> Go陈述中断错误处理。与上面讨论的那样，现代语言提供了强大的工具，如例外情况，以帮助解除错误检测到错误并将其传播到正确的位置。但这些工具依赖于具有可靠的＆＃34的概念;当前代码＆＃39;呼叫者＆＃34 ;。只要你产生任务或注册回调，那个概念就被打破了。因此，我知道的每个主流康复框架都只是放弃。如果在Abackground任务中发生错误，并且您手动处理它，那么运行时会将其放在地板上，并将其手指交叉，它是＆＃39; ttoo重要。如果你＆＃39;重新幸运，它可能会在TheConsole上打印一些东西。 （唯一的其他软件i＆＃39; ve使用它的想法＆＃34; printsomething并继续前进＆＃34;是一个很好的错误处理策略是Glottyold Fortran图书馆，但在这里我们是。）甚至生锈 - 大多数象牙</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/声明/">#声明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>