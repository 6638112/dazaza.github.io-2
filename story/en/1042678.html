<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Docker镜像是如何构建的？ 覆盖文件系统研究 How are Docker images built? A look into overlay file-systems</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How are Docker images built? A look into overlay file-systems<br/>Docker镜像是如何构建的？ 覆盖文件系统研究 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:11:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/26b3e9030429f9a4c499b485c9120b57.jpg"><img src="http://img2.diglog.com/img/2021/1/26b3e9030429f9a4c499b485c9120b57.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It’s impossible to work with docker containers without docker images. In this post I want to talk about what makes docker images possible: the  overlay filesystems.   I’ll start with a brief description of overlay filesystems. Then we will see how it applies to docker images and how docker builds an image from a dockerfile. I’ll conclude with layers cache and OCI format for container images.</p><p>没有docker镜像的docker容器是不可能的。在这篇文章中，我想谈谈使docker映像成为可能的原因：覆盖文件系统。我将从覆盖文件系统的简要说明开始。然后，我们将了解它如何应用于docker映像以及docker如何从dockerfile生成映像。我将以容器图像的图层缓存和OCI格式结束。</p><p> As usual I’ll try to make the blog post as practical as possible.</p><p> 像往常一样，我将尽量使该博客文章实用。</p><p>  Overlay filesystems (a  lso called union filesystems) allow creating a union of two or more directories: a list of  lower directories and an  upper directory. The lower directories of the filesystem are read only, whereas the upper directory can be used for both reads and writes.</p><p>  覆盖文件系统（也称为联合文件系统）允许创建两个或更多目录的联合：下层目录列表和上层目录。文件系统的下部目录是只读的，而上部目录可用于读取和写入。</p><p>   Let’s create a few folders and combine them.   First I’ll create a folder called “mount” which will contain the union of all the other folders. Then I’ll create a bunch of folders called “layer-1”, “layer-2”, “layer-3”, “layer-4”. Finally a folder called “workdir” which is needed by the overlay filesystem, well, to work properly. You can call any of the folders as you wish, but calling them “layer-1”, “layer-2”, etc. will make easier to understand the parallel with docker images as we shall see. cd /tmp &amp;&amp; mkdir overlay-example &amp;&amp; cd overlay-example</p><p>   让我们创建一些文件夹并将其合并。首先，我将创建一个名为“ mount”的文件夹，其中将包含所有其他文件夹的并集。然后，我将创建一堆名为“ layer-1”，“ layer-2”，“ layer-3”，“ layer-4”的文件夹。最后，覆盖文件系统需要一个名为“ workdir”的文件夹才能正常工作。您可以随意调用任何文件夹，但是将它们称为“ layer-1”，“ layer-2”等将使我们更容易理解与docker镜像的相似之处。 cd / tmp＆amp;＆amp; mkdir overlay-example＆amp;＆amp; cd overlay-example</p><p> [2020-04-19 16:02:35] [ubuntu] [/tmp/overlay-example]  &gt; mkdir mount layer-1 layer-2 layer-3 layer-4 workdir [2020-04-19 16:02:38] [ubuntu] [/tmp/overlay-example]  &gt; ls layer-1 layer-2 layer-3 layer-4 mount workdir</p><p> [2020-04-19 16:02:35] [ubuntu] [/ tmp / overlay-example]＆gt; mkdir挂载第1层第2层第3层第4层工作目录[2020-04-19 16:02:38] [ubuntu] [/ tmp / overlay-example]＆gt; ls 1层2层3 3层4挂载工作目录</p><p> Let’s also create some files into layer-1, layer-2 and layer-3 folders.  We will leave the layer-4 (our upper folder) empty. Again, that’s not necessary, it will just make easier our parallel with docker images.</p><p> 我们还要在1层，2层和3层文件夹中创建一些文件。我们将第4层（我们的上层文件夹）留空。同样，这不是必须的，这只会使我们与docker镜像的并行变得更容易。</p><p> [2020-04-19 16:02:40] [ubuntu] [/tmp/overlay-example]  &gt; echo &#34;Layer-1 file&#34; &gt; ./layer-1/some-file-in-layer-1 [2020-04-19 16:03:36] [ubuntu] [/tmp/overlay-example]  &gt; echo &#34;Layer-2 file&#34; &gt; ./layer-2/some-file-in-layer-2 [2020-04-19 16:03:53] [ubuntu] [/tmp/overlay-example]  &gt; echo &#34;Layer-3 file&#34; &gt; ./layer-3/some-file-in-layer-3</p><p> [2020-04-19 16:02:40] [ubuntu] [/ tmp / overlay-example]＆gt;回显＆＃34;第1层文件＆＃34; ＆gt; ./layer-1/some-file-in-layer-1 [2020-04-19 16:03:36] [ubuntu] [/ tmp / overlay-example]＆gt;回显＆＃34;第2层文件＆＃34; ＆gt; ./layer-2/some-file-in-layer-2 [2020-04-19 16:03:53] [ubuntu] [/ tmp / overlay-example]＆gt;回显＆＃34;第3层文件＆＃34; ＆gt; ./layer-3/some-file-in-layer-3 </p><p>    As expected the content of the folders layer-1, layer-2 and layer-3 have been mounted/combined in the mount folder.  Sure enough if we look at the content of the files, we’ll find what we have written in the previous step.</p><p>与预期的一样，第1层，第2层和第3层文件夹的内容已被安装/合并在mount文件夹中。当然，如果我们查看文件的内容，就会发现我们在上一步中编写的内容。</p><p>   [2020-04-19 16:23:31] [ubuntu] [/tmp/overlay-example/mount]   &gt; echo &#34;new content&#34; &gt; new-file   [2020-04-19 16:27:33] [ubuntu] [/tmp/overlay-example/mount]  &gt; ls new-file some-file-in-layer-1 some-file-in-layer-2 some-file-in-layer-3</p><p>   [2020-04-19 16:23:31] [ubuntu] [/ tmp / overlay-example / mount]＆gt;回显＆＃34;新内容＆＃34; ＆gt;新文件[2020-04-19 16:27:33] [ubuntu] [/ tmp / overlay-example / mount]＆gt; ls新文件一些文件在第1层一些文件在第2层一些文件在第3层</p><p> Where should the new file be? In the upper layer, which in our case is the folder called “layer-4”:</p><p> 新文件应该在哪里？在上层，在我们的例子中是名为“ layer-4”的文件夹：</p><p> [2020-04-19 16:23:49] [ubuntu] [/tmp/overlay-example]   pactvm &gt; tree . ├── layer-1 │ └── some-file-in-layer-1 ├── layer-2 │ └── some-file-in-layer-2 ├── layer-3 │ └── some-file-in-layer-3 ├── layer-4 │ └── new-file ├── mount │ ├── new-file │ ├── some-file-in-layer-1 │ ├── some-file-in-layer-2 │ └── some-file-in-layer-3 └── workdir  └── work [error opening dir] 7 directories, 8 files</p><p> [2020-04-19 16:23:49] [ubuntu] [/ tmp / overlay-example] pactvm＆gt;树。 ├──第1层│└──第1层有文件├──第2层│└──第2层有文件├──第3层│└──某些-第3层文件├──第4层│└──新文件├──安装│├──新文件│├──某些文件在第1层│├──某些-文件层2│└──某些文件层3└──workdir└──work [错误打开目录] 7个目录，8个文件</p><p>  [2020-04-19 16:27:33] [ubuntu] [/tmp/overlay-example/mount] &gt; rm some-file-in-layer-2  [2020-04-19 16:28:58] [ubuntu] [/tmp/overlay-example/mount] &gt; ls  new-file some-file-in-layer-1 some-file-in-layer-3</p><p>  [2020-04-19 16:27:33] [ubuntu] [/ tmp / overlay-example / mount]＆gt; rm some-file-in-layer-2 [2020-04-19 16:28:58] [ubuntu] [/ tmp / overlay-example / mount]＆gt; ls新文件第1层的某些文件第3层的一些文件</p><p> What do you think happened to the original file in the “layer-2” folder?</p><p> 您认为“ layer-2”文件夹中的原始文件发生了什么？</p><p> [2020-04-19 16:29:57] [ubuntu] [/tmp/overlay-example]   pactvm &gt; tree . ├── layer-1 │ └── some-file-in-layer-1 ├── layer-2 │ └── some-file-in-layer-2 ├── layer-3 │ └── some-file-in-layer-3 ├── layer-4 │ ├── new-file │ └── some-file-in-layer-2 ├── mount │ ├── new-file │ ├── some-file-in-layer-1 │ └── some-file-in-layer-3 └── workdir  └── work [error opening dir] 7 directories, 8 files</p><p> [2020-04-19 16:29:57] [ubuntu] [/ tmp / overlay-example] pactvm＆gt;树。 ├──第1层│└──第1层有文件├──第2层│└──第2层有文件├──第3层│└──某些-第3层文件├──第4层│├──新文件│└──某些文件在第2层├──挂载│├──新文件│├──某些-文件层1│└──某些文件层3└──workdir└──work [错误打开目录] 7个目录，8个文件 </p><p> A new file called “some-file-in-layer-2” was created in “the layer-4”. The weird thing is that the file is a character file. These kinds of files are called “whiteout” files and are how the overlay filesystem represents a file being deleted:</p><p>在“第4层”中创建了一个名为“ some-file-in-layer-2”的新文件。奇怪的是文件是字符文件。这些类型的文件称为“白化”文件，它们是覆盖文件系统表示要删除的文件的方式：</p><p> [2020-04-19 16:31:09] [ubuntu] [/tmp/overlay-example/layer-4]   pactvm &gt; ls -la total 12 drwxr-xr-x 2 napicell domain^users 4096 Apr 19 16:28 . drwxr-xr-x 8 napicell domain^users 4096 Apr 19 16:07 .. -rw-r--r-- 1 napicell domain^users 12 Apr 19 16:23 new-file c--------- 1 root root 0, 0 Apr 19 16:28 some-file-in-layer-2</p><p> [2020-04-19 16:31:09] [ubuntu] [/ tmp / overlay-example / layer-4] pactvm＆gt; ls -la总共12个drwxr-xr-x 2个napicell domain ^ users 4096 Apr 19 16:28。 drwxr-xr-x 8个napicell域^用户4096 Apr 19 16:07 .. -rw-r--r-- 1个napicell域^用户19 Apr 19 16:23新文件c -------- -1 root root 0，0 Apr 19 16:28 some-file-in-layer-2</p><p> Now that we have finished with it, let’s unmount the filesystem and remove the folder we created:</p><p> 现在我们已经完成了它，让我们卸载文件系统并删除我们创建的文件夹：</p><p>   As we said at the beginning, the overlay filesystem allows to create a union of directories. In our case the union was created in the “mount” folder and it was the result of combining the “layer-{1, 2, 3, 4}” folders. Changes to files, deletion or creation will be stored in the upper dir, which in our case is “layer-4”. This is why this layer is also called “diff” layer.  Files from upper layer shadow the ones in lower layers, i.e. if you have a file with the same name and relative path in layer-1 and layer-2, the layer-2 file is going to end up in the “mount” folder.</p><p>   正如我们在一开始所说的，覆盖文件系统允许创建目录的并集。在我们的例子中，联合是在“ mount”文件夹中创建的，这是合并“ layer- {1、2、3、4}”文件夹的结果。对文件的更改，删除或创建将存储在上层目录中，在本例中为“第4层”。这就是为什么该层也称为“差异”层的原因。较高层的文件会遮盖较低层的文件，即，如果您在第1层和第2层中具有相同名称和相对路径的文件，则第2层文件将最终位于“ mount”文件夹中。</p><p>  A docker image is essentially a tar file with a root file system and some metadata. You might have heard of the expression image layer and that every line in a docker file creates a new layer. For example in the following snippet we will end up with an image with three layers.</p><p>  泊坞窗映像本质上是一个具有根文件系统和一些元数据的tar文件。您可能已经听说过表达式图像层，并且docker文件中的每一行都会创建一个新层。例如，在下面的代码片段中，我们将获得一个包含三层的图像。</p><p> So what happens when you type “docker run”. A lot of things really, but for the purpose of this article we are only interested in the bits concerning the image.   At high level, docker downloads the tarballs for the image, it unpacks each layer into a separate directory and then tells the overlay filesystem to combine them all together together with an empty upper directory that the container will write its changes to it.  When you change, create or delete files in the container, the changes are going to be stored in this empty directory. When the container exits, docker cleans up the folder — that is why the changes you make in the container do not persist.</p><p> 因此，当您键入“ docker run”时会发生什么。确实有很多事情，但是出于本文的目的，我们只对与图像有关的位感兴趣。在较高级别上，docker下载该映像的tarball，将每个层解压缩到一个单独的目录中，然后告诉覆盖文件系统将它们全部组合在一起，并在一个空的上层目录中，容器将对其进行更改。当您更改，创建或删除容器中的文件时，更改将存储在此空目录中。当容器退出时，docker会清理文件夹-这就是为什么您在容器中所做的更改不会持久的原因。</p><p>  This way to use the overlay filesystem allows hosts to cache docker images effectively. For example, if you define two images, they can both use the same layers. No need to download multiple times or to have many copies on the disk!</p><p>  这种使用覆盖文件系统的方式使主机可以有效地缓存docker映像。例如，如果定义两个图像，则它们都可以使用相同的图层。无需多次下载或在磁盘上拥有许多副本！ </p><p>  Running a container at high level can be seen as a two steps process: building the image and running a container from the image. The popularity of docker has convinced people to standardize both steps — allowing the two pieces to evolve separately. The Open Container Initiative (OCI) is the governance which has been working with the industry to these standards.</p><p>高级别运行容器可以看成两个步骤：构建映像和从映像运行容器。 docker的流行使人们说服人们将这两个步骤标准化–允许两个部分分别发展。开放容器倡议（OCI）是一直与业界合作达到这些标准的治理。</p><p> The OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec). The Runtime Specification outlines how to run a “filesystem bundle” that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.</p><p> OCI当前包含两个规范：运行时规范（runtime-spec）和映像规范（image-spec）。运行时规范概述了如何运行在磁盘上解压缩的“文件系统包”。在较高级别上，OCI实现将下载OCI映像，然后将该映像解压缩为OCI运行时文件系统包。此时，OCI运行时捆绑包将由OCI运行时运行。</p><p> The standardization allows other people to develop custom container builders and runtimes. For example, jessfraz/img, buildah and Skopeo are all tools that allow you to build container images without using docker. Similarly, many tools to run containers (so called container runtimes) have emerged, for example runc (used by docker) and rkt.</p><p> 标准化允许其他人开发自定义容器构建器和运行时。例如，jessfraz / img，buildah和Skopeo都是使您无需使用docker即可构建容器映像的工具。同样，出现了许多运行容器的工具（所谓的容器运行时），例如runc（由docker使用）和rkt。</p><p>  Overlay is not the only union file system that docker can use. Any file system that allows union like features and diff layer could potentially be used. For example docker can use overlay as we have seen, but also aufs, btrfs, zfs and devicemapper.</p><p>  覆盖不是docker可以使用的唯一联合文件系统。允许使用类似联合功能和差异层的任何文件系统都可以使用。例如，泊坞窗可以使用我们已经看到的覆盖，还可以使用aufs，btrfs，zfs和devicemapper。</p><p>  Let’s assume we have the following dockerfile we want to use to build an image from:</p><p>  假设我们要使用以下dockerfile来构建映像：</p><p>  Docker downloads the tarball for the image specified in the “FROM” and unpacks it. This is the first layer of the image.</p><p>  Docker下载“ FROM”中指定的映像的压缩包并解压缩。这是图像的第一层。</p><p> Mounts a union file system, with the lower dir being the one just downloaded. The upper dir is an empty folder</p><p> 挂载一个联合文件系统，其较低的目录为刚刚下载的目录。上层目录是一个空文件夹 </p><p> Starts bash in a chroot and runs the command specified in RUN: chroot . /bin/bash -c “apt get update”</p><p>在chroot中启动bash并运行RUN中指定的命令：chroot。 / bin / bash -c“易于获取更新”</p><p> When the command is over, it zips the upper layer. This is the new layer of the image we are building</p><p> 命令结束后，它将压缩上一层。这是我们正在构建的图像的新层</p><p> If the dockerfile contains other commands, repeat the process from the second step using as lower dir all the layers we have got so far. Otherwise exit.</p><p> 如果dockerfile包含其他命令，请从第二步开始使用到目前为止到目前为止所有已使用的层作为下层目录重复该过程。否则退出。</p><p> Of course this is a simplified workflow which does not take into account different type of commands like “ENV”, “ENTRYPOINT”, etc. Those things are stored in the metadatafile which is going to be bundled together with the layers.</p><p> 当然，这是简化的工作流程，它没有考虑不同类型的命令，例如“ ENV”，“ ENTRYPOINT”等。这些内容存储在元数据文件中，该文件将与图层捆绑在一起。</p><p>  The idea of zipping a whole root file system in a tar and keeping a tar for each diff-layer turned out to be very powerful. It did not just enabled docker, but turns out to be a concept that can be used in other context as well. I guess, we will see more tools taking advantage of that in the future.</p><p>  事实证明，将整个根文件系统压缩在tar中并为每个diff层保留tar的想法非常强大。它不仅启用了docker，而且事实证明它是可以在其他上下文中使用的概念。我想，将来我们会看到更多利用此工具的工具。</p><p> Follow me on  Twitter to get new posts in your feed. Credit for the cover image to  unsplash-logo frank mckenna .</p><p> 在Twitter上关注我，以在您的供稿中获取新帖子。封面图片应归功于unsplash-logo坦率的mckenna。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://napicella.medium.com/how-are-docker-images-built-a-look-into-the-linux-overlay-file-systems-and-the-oci-specification-51d65c73c416">https://napicella.medium.com/how-are-docker-images-built-a-look-into-the-linux-overlay-file-systems-and-the-oci-specification-51d65c73c416</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/镜像/">#镜像</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/images/">#images</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>