<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>模型检查和模型评估中的似然原理 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">模型检查和模型评估中的似然原理 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-23 21:30:20</div><div class="page_narrow text-break page_content"><p>（本文由Yuling撰写）在贝叶斯统计中，似然原理通常被表述为公理。当我们（仅）对估计未知参数感兴趣，并且有两个涉及数据生成实验的实验，每个实验都有可观察到的结果和，可能性和时，它适用。如果结果-实验对满足（作为函数），则这两个实验和两个观察将提供关于的相同推断信息。</p><p> 考虑一个经典的例子。有人正在进行AB测试，只对治疗效果感兴趣，他告诉经理说，在所有n = 10的受访者中，y = 9看到了改善（假设度量是二进制）。通过独立的伯努利试验可能性估计改善概率是很自然的：可以提供其他有用的先验信息，但与我们此处的讨论无关。</p><p> 与此相关的是，经理后来发现该实验未正确完成。代替独立的数据收集，该实验旨在按顺序继续招募更多的受访者，直到获得肯定为止。实际的随机结果是n，而y是固定的。因此正确的模型是负二项式。</p><p> 幸运的是，似然性原则适用于binomial_lpmf neg_binomial_lpmf +常数的事实。无论实验如何进行，推论都保持不变。</p><p> 在抽象层次上，似然原理表示只能通过似然来提取参数信息，而不能从可能已经完成的实验中提取。</p><p>  在贝叶斯推断中，这种可能性是双重目的的。为了进行推断，它只是未归一化密度的一个组成部分。但是对于模型检查和模型评估，似然函数使生成模型能够生成y的后验预测。</p><p> 在二项式/负二项式示例中，可以停止对的推断。但是，只要我们要检查模型，就需要区分两种可能的采样分布以及哪个变量（n或y）是随机的。 </p><p>考虑我们在n = 10个试验中观察到y = 9个阳性病例，估计的二项式和阴性二项式模型的可能性为</p><p>  并不完全相同。但是似然原理并不需要它们相同。需要的是恒定的密度比，并且很容易验证：</p><p>        显然，使用贝叶斯后验不能解决问题。问题是可能性确保一定的比率，而不是比率。</p><p>  与似然原理中的未归一化似然不同，模型评估中的边际似然性需要归一化。</p><p> 在前面的AB测试示例中，给定数据，如果我们知道运行了二项式或负二项式实验中的一个且只有一个，则我们可能希望基于边际似然进行模型选择。为简单起见，我们考虑一个点估计。然后我们获得似然比检验，比率为0.9，略微偏爱二项式模型。实际上，该边际似然比是恒定的y / n，与的后验分布无关。如果为，则得到支持二项式模型的贝叶斯因子1000。</p><p> 除非是错误的。比较y的可能性和n的可能性是不明智的。</p><p>  CV需要一些损失函数，并且相同的预测密度并不意味着相同的损失（L2损失，区间损失等）。为了保持一致，我们现在采用对数预测密度。 </p><p>CV还需要交换部分数据，这取决于采样分布。</p><p> 另一方面，计算的对数预测密度的LOO-CV似乎仅取决于似然性的数据。考虑两个模型数据对，我们计算LOOCV并将2中的所有1替换为。</p><p> 似然原理确实是这样说的，如果有某种广义似然原理可以保证那样，那么。</p><p> 当然可以，但这是一个额外的假设。逐点似然原理可以说是一个很强的假设，除了玩具示例之外几乎没有用。</p><p> 似然原理的基本形式没有符号。样本大小可能会有所不同：请考虑使用具有多个民意测验的元轮询。每个民意调查都是具有的二项式模型。如果我有100个民意测验，则我有100个数据点。或者，我可以查看来自伯努利试验的数据，样本大小变为。</p><p> 最后，就像边际可能性中的情况一样，即使以上所有条件都成立，无论身份如何，在概念上进行比较都是错误的。它们是在两个不同空间（分别是和上的概率测度）上的评分规则，不应直接进行比较。</p><p>  尽管这是一个不好的做法，但出于模型比较的目的，有时我们会比较两个模型的PPC p值。在y = 9，n = 10的情况下，我们可以计算两侧的p值：二项式的min（Pr（y_ {sim}＆lt; y），Pr（y_ {sim}＆lt; y））模型，以及NB模型的min（Pr（n_ {sim}＆gt; n），Pr（n_ {sim}＆lt; n））。在边际似然和对数得分的情况下，我们知道当它们在两个采样空间上时，我们无法直接比较两个似然或两个对数得分。在此，p值自然归一化。这是否意味着我们在二项式模型通过PPC时拒绝了NB模型？ </p><p>为了避免在两个采样空间中对边际可能性和对数得分进行不公平的比较，一种补救措施是考虑乘积空间：y和n现在都被视为随机变量。</p><p>  这两个密度的比率仅允许三个值：0，无穷大或常数y / n。</p><p> 如果我们观察的几个巴黎，我们可以轻松地确定哪个边距是固定的。较难的问题是我们只观察一个。根据前面几节中的边际可能性和对数得分的比较，似乎两个度量标准仍会更喜欢二项式模型（现在它被视为产品空间上的抽样分布）。</p><p> 好吧，几乎正确的预期是：1）如果只有一个观察值，样本对数得分就没有意义； 2）我们需要先验模型才能将边际似然性转化为贝叶斯因子。毕竟，在任一采样模型下，允许非平凡密度比的事件的度量均为零。在产品空间上进行模型选择/比较是合法的，但是我们可以在这一点上做任何想要的事情，而几乎不会肯定地影响任何属性。</p><p>  简而言之，基于似然原理的推论不变性的便利性也使得难以进行模型选择和模型评估。后两个模块除了似然性外，还依赖于采样分布。</p><p> 为了使本博文更加混乱，我想与因果推理建立一些远程联系。</p><p> 假设我们有已知模型M1的数据（二进制处理：z，结果y，协变量：x）：y = b0 + b1 z + b2 x + iid噪声。如果模型正确，并且没有其他未观察到的混杂因素，我们可以通过b1估算z的治疗效果。 </p><p>无混杂假设要求y（z = 0）和y（z = 1）与给定x的z无关。 该假设只是因果解释的描述，绝不会出现在抽样分布或可能性中。 假设确实存在一个混杂因子c，且真实DG为M2： （x，z，c）= b0 + b1 z + b2 x + c + iid噪声，并且z | c = c +另一个iid噪声。 然后边际化c（因为我们无法在数据收集中观察到它），M2变成y |。 x，z = b0 + b1 z + b2 x + iid噪声 因此，（M1，（x，y，z））和（M2，（x，y，z））接受一个似然原理成立的实验数据对。 恰恰是本来可爱的似然性原则排除了测试无混淆性假设的任何方法。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://statmodeling.stat.columbia.edu/2020/12/18/the-likelihood-principle-in-model-check-and-model-evaluation/">https://statmodeling.stat.columbia.edu/2020/12/18/the-likelihood-principle-in-model-check-and-model-evaluation/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/模型/">#模型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/model/">#model</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1040930.html"><img src="http://img2.diglog.com/img/2020/12/thumb_713f0300c1a480ec0fee996256b44f10.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1040930.html">将照片转为素描DL模型 </a></div><span class="my_story_list_date">2020-12-21 4:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1040509.html"><img src="http://img2.diglog.com/img/2020/12/thumb_7b750992d1c4b52352138a949ce03ab8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1040509.html">新的机器学习模型揭穿了“贫困线”概念 </a></div><span class="my_story_list_date">2020-12-18 20:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039805.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b3328aa40a604c9230f718e79694aa16.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039805.html">提供用于流程自动化的企业AI工具的Indico筹集了2200万美元的B轮融资，使其总融资额达到3600万美元 </a></div><span class="my_story_list_date">2020-12-15 18:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039484.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a5edf6482f240e8b079899a64941e16a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039484.html">干净的体系结构：域驱动的设计，第1部分 </a></div><span class="my_story_list_date">2020-12-14 22:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>