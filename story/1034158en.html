<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>论Python的ExitStack之美</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">论Python的ExitStack之美</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 06:31:14</div><div class="page_narrow text-break page_content"><p>I believe Python&#39;s  ExitStack feature does not get the recognitionit deserves. I think part of the reason for this is that itsdocumentation is somewhere deep down in the (already obscure) contextlib module because formally ExitStack is just one of manyavailable context managers for Python&#39;s  with statement. ButExitStack deserves far more prominent notice than that. This post willhopefully help with that.</p><p>我认为，Python的ExitStack功能没有得到应有的认可。我认为部分原因是因为它的文档位于(已经很模糊的)contextlib模块的深处，因为正式的ExitStack只是Python的with语句的众多可用上下文管理器之一。但ExitStack值得关注的远不止这些。这篇文章有望对此有所帮助。</p><p> So what makes ExitStack so important? In short, it&#39;s the best way tohandle allocation and release of external resources in Python.</p><p>那么，是什么让ExitStack如此重要呢？简而言之，这是在Python中处理外部资源分配和释放的最佳方式。</p><p> The main challenge with external resources is that you have to releasethem when you don&#39;t need them anymore -- and in particular you mustnot forget to do so in all the alternate execution paths that may beentered in case of error conditions.</p><p>外部资源的主要挑战是，当您不再需要它们时，您必须释放它们--尤其是，您不能忘记在出现错误的情况下可能输入的所有备用执行路径中这样做。</p><p> Most languages implement error conditions as &#34;exceptions&#34; that can be&#34;caught&#34; and handled (Python, Java, C++), or as special return valuesthat you need to check to determine if an error occured (C, Rust,Go). Typically, code that needs to acquire and release externalresources then looks like this:</p><p>大多数语言将错误条件实现为异常，可以捕获并处理(Python、Java、C++)，或者作为需要检查以确定是否发生错误(C、Rust、Go)的特殊返回值。通常，需要获取和释放外部资源的代码如下所示：</p><p> res1  =  acquire_resource_one () try :  # do stuff with res1  res2  =  acquire_resource_two ()  try :  # do stuff with res1 and res2  finally :  release_resource ( res2 ) finally :  release_resource ( res1 )</p><p>Res1=Acquisition_resource_one()try：#用res1做数据res2=Acquisition_resource_Two()try：#用res1和res2做数据最后：Release_resource(Res2)最后：Release_resource(Res1)。</p><p>  res1  =  acquire_resource_one (); if ( res  ==  - 1 )  {  retval  =  - 1 ;  goto  error_out1 ; } // do stuff with res1 res2  =  acquire_resource_two (); if ( res  ==  - 1 )  {  retval  =  - 2 ;  goto  error_out2 ; } // do stuff with res1 and res2 retval  =  0 ;  // ok error_out2 :  release_resource ( res2 ); error_out1 :  release_resource ( res1 ); return  retval ;</p><p>Res1=Acquisition_resource_one()；if(res==-1){retval=-1；goto error_out1；}//使用res1填充res2=获取资源_2()；if(res==-1){retval=-2；goto error_out2；}//使用res1和res2填充retval=0；//ok error_out2：Release_resource(Res2)；error_out1：Release_resource(Res1)；返回。</p><p>  When the number of resources increases, indentation levels (or jumplabels) accumulate, making things hard to read.</p><p>当资源数量增加时，缩进级别(或跳转标签)会累积，使内容难以阅读。</p><p>  @contextlib.contextmanager  def  my_resource ( id_ ):  res  =  acquire_resource ( id_ )  try :  yield  res  finally :  release_source ( res ) with  my_resource ( RES_ONE )  as  res1 , \  my_resource ( RES_TWO )  as  res2 :  # do stuff with res1  # do stuff with res1 and res2</p><p>@contextlib.contextmanager def my_resource(Id_)：res=Acquisition_resource(Id_)try：放弃res：Release_source(Res)，my_resource(Res_One)为res1，\my_resource(Res_Two)为res2：#用res1做东西#用res1和res2做东西</p><p> However, this solution is far from optimal: you need to implementresource-specific context managers (note that in the above example wesilently assumed that both resources can be acquired by the samefunction), you can get rid of extra indentation only if you allocateall the resources at the same time and live with an ugly continuationline (no parenthesis allowed in this context), and you still need toknow the number of required resources ahead of time.</p><p>然而，这个解决方案远非最佳：您需要实现特定于资源的上下文管理器(请注意，在上面的示例中，我们默默假设两个资源都可以由相同的函数获取)，只有当您同时分配所有资源并与丑陋的延续线共存时，您才能消除额外的缩进(在此上下文中不允许使用圆括号)，并且您仍然需要提前知道所需资源的数量。</p><p> Over in the world of exception-less programming languages (no punintended),  Go has developed a different remedy: the  defer statementdefers execution of an expression until the enclosingfunction returns. Using  defer, the above example can be writtenas:</p><p>在无异常编程语言的世界里(没有恶意)，Go开发了一种不同的补救方法：DEFER语句将表达式的执行推迟到封闭函数返回。使用DEFER，上面的示例可以写成：</p><p> res1  =  acquire_resource_one () if ( res  ==  NULL )  {  return  - 1 } defer  release_resource ( res1 ) // do stuff with res1 res2  =  acquire_resource_two () if ( res  ==  NULL )  {  return  - 2 } defer  release_resource ( res2 ) // do stuff with res1 and res2 return  0</p><p>Res1=Acquisition_resource_one()if(res==NULL){return-1}推迟RELEASE_RESOURCE(Res1)//使用res1填充res2=Acquisition_resource_Two()if(res==NULL){return-2}推迟RELEASE_RESOURCE(Res2)//使用res1执行填充，res2返回0。</p><p> This is pretty nice: allocation and cleanup are kept close together,no extra indentation or jump labels are required, and converting thisto a loop that dynamically acquires multiple resources would bestraightforward. But there are still some drawbacks:</p><p>这很好：分配和清理保持在一起，不需要额外的缩进或跳转标签，并且将其转换为动态获取多个资源的循环将非常简单。但仍有一些缺点：</p><p> To control when exactly a group of resources is getting released youhave to factor out into separate functions all parts of code thataccess the respective resources.</p><p>要控制一组资源的确切释放时间，必须将访问相应资源的代码的所有部分分解到单独的函数中。</p><p> You cannot &#34;cancel&#34; a deferred expression, so there is no way toe.g. return a resource to the caller if no error occured.</p><p>您不能取消延迟表达式，因此无法取消。如果没有发生错误，则将资源返回给调用方。</p><p> ExitStack fixes all of the above issues, and adds some benefits ontop of it. An ExitStack is (as the name suggests) a stack of clean-upfunctions. Adding a callback to the stack is the equivalent of callingGo&#39;s  defer statement. However, clean-up functions are not executedwhen the function returns, but when execution leaves the  withblock - and until then, the stack can also be emptied again.</p><p>ExitStack修复了所有上述问题，并在此基础上增加了一些好处。ExitStack(顾名思义)是一堆清理函数。向堆栈添加回调相当于CallingGo；的DEFER语句。然而，清理函数不会在函数返回时执行，但当执行离开With块时-在此之前，堆栈也可以再次清空。</p><p> Finally, clean-up functions itself may raise exceptions withoutaffecting execution of other clean-up functions. Even if multipleclean-ups raise exceptions, you are will get a usable stacktrace.</p><p>最后，清理函数本身可能会引发异常，而不会影响其他清理函数的执行。即使多重清理引发异常，您也会得到可用的堆栈跟踪。</p><p>  with  ExitStack ()  as  cm :  res1  =  acquire_resource_one ()  cm . callback ( release_resource ,  res1 )  # do stuff with res1  res2  =  acquire_resource_two ()  cm . callback ( release_resource ,  res2 )  # do stuff with res1 and res2</p><p>其中ExitStack()为cm：res1=Acquisition_resource_one()cm。回调(RELEASE_RESOURCE，res1)#使用res1 res2=Acquisition_resource_Two()cm进行操作。回调(RELEASE_RESOURCE，res2)#使用res1和res2执行操作。</p><p>  the pattern and it easily scales up to many resources (including adynamic number that&#39;s acquired in a loop)</p><p>该模式很容易扩展到许多资源(包括在循环中获取的动态数字)。</p><p>  with  ExitStack ()  as  cm :  res1  =  cm . enter ( open ( &#39;first_file&#39; ,  &#39;r&#39; ))  # do stuff with res1  res2  =  cm . enter ( open ( &#39;second_file&#39; ,  &#39;r&#39; ))  # do stuff with res1 and res2</p><p>ExitStack()为cm：res1=cm。输入(open(&#39；first_file&#39；，&#39；r&#39；))#用res1 res2=cm做东西。输入(open(&#39；Second_file&#39；，&#39；r&#39；))#用res1和res2做东西。</p><p> To open a bunch of files and return them to the caller (withoutleaking already opened files if a subsequent open fails):</p><p>要打开一组文件并将其返回给调用方(如果后续打开失败，则不会泄漏已打开的文件)：</p><p> def  open_files ( filelist ):  fhs  =  []  with  ExitStack ()  as  cm :  for  name  in  filelist :  fhs . append ( cm . enter ( open ( name ,  &#39;r&#39; )))  cm . pop_all ()  return  fhs</p><p>定义OPEN_FILES(文件列表)：FHS=[]，将ExitStack()设置为cm：作为文件列表中的名称：FHS。追加(厘米。输入(open(name，&#39；r&#39；)cm。POP_ALL()返回FHS</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.rath.org/on-the-beauty-of-pythons-exitstack.html">https://www.rath.org/on-the-beauty-of-pythons-exitstack.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/exitstack/">#exitstack</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/执行/">#执行</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034012.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a270829c58d97b90ea892ae979fa861b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034012.html">重头开始的Python并发性(2015)[视频]</a></div><span class="my_story_list_date">2020-11-9 20:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033930.html"><img src="http://img2.diglog.com/img/2020/11/thumb_3a1be40609f8294f8c760a1e36d336a5.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033930.html">避免Bash受挫-将Python用于Shell脚本</a></div><span class="my_story_list_date">2020-11-9 4:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033316.html"><img src="http://img2.diglog.com/img/2020/11/thumb_21f8be35cef4397449ea9dd55e0aa657.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033316.html">Python取代Java成为第二大最受欢迎的编程语言</a></div><span class="my_story_list_date">2020-11-5 20:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032893.html"><img src="http://img2.diglog.com/img/2020/11/thumb_64d2ec6863c7815afccdaaa0cf416c51.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032893.html">使用VizTracer可视化Python代码执行</a></div><span class="my_story_list_date">2020-11-3 10:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>