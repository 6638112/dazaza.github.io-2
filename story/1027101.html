<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用于深部序列预测重建的多变量时域自动编码器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">用于深部序列预测重建的多变量时域自动编码器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-30 02:34:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/43ff31ed2383742d120ac4e1258f46c9.jpg"><img src="http://img2.diglog.com/img/2020/9/43ff31ed2383742d120ac4e1258f46c9.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>本文通过使用递归自动编码器和预测模型对数据窗口的潜在状态矢量表示进行建模，从而展示了一种解决多变量时间序列预测问题的多分支深度神经网络方法。</p><p>几个世纪以来，人们一直在使用更复杂的方法研究时间序列预测问题，目的是捕捉内部隐藏的模式，并预测未来的这些模式。任何时态过程都有决定其行为的驱动因素，理论上，在给定关于该过程的时间点的足够数据和足够复杂的模型的情况下，可以对任何和所有这些驱动因素进行建模-然而，由于各种原因，这在实践中目前是不可行的，这些原因主要是捕获数据、计算捕获的数据维度以及对以各种相关方式交互的许多维度的复杂交互进行建模。</p><p>这类问题的复杂性的一个例子可能是雨滴从窗户上落下的看似随机的路径。从各个方面来看，这颗雨滴看起来都像是随意地从窗玻璃上走下来，左右的运动似乎无法确定或建模。然而，考虑到每个水分子、每个玻璃分子的位置、它们各自的温度以及它们与每个其他分子的历史相互作用图，这些都可以作为每个颗粒时间点的数据。有了这些信息，就可以合理地假设存在一个可以创建的模型，该模型能够准确地指定雨滴下一步的去向，并通过外推，当雨滴到达窗玻璃底部时，它将在哪里结束。</p><p>当然，上述例子的问题是，目前还不存在这样的方法来捕捉宇宙在某个时间点上的每一个可观察到的方面。因此，目前我们所能做的最好的事情就是创建一个模型，在我们能收集到的最佳数据的情况下，近似显示雨滴隐藏的驱动因素。</p><p>虽然这对于示例雨滴问题来说并不是最优的，但好消息是，有大量的问题可以在非常精细的时间点收集大量数据，因此可以创建一个模型来预测问题的过程。</p><p>具有影响其行为的潜在驱动因素的小而封闭的宇宙的过程更容易预测前面更大的顺序步骤，而暴露于各种影响因素的过程屈服于通过混沌而导致的精确度的指数衰减，因此只能在非常短的顺序步骤之前建模。然而，一个系统的影响因素可以加入到模型中的因素越多，预测过程就会越准确。</p><p>本研究致力于建立一个能够处理多变量时间序列数据的模型，该模型在现实世界的数据问题中充当过程的影响驱动因素，并学习以无监督的方式建立驱动因素和过程的多维近似表示。该训练的超维隐藏表示然后用于训练二级预测模型分支以预测前面的顺序步骤。该模型是使用多分支深度神经网络方法创建的，该方法利用自动编码原理并建立在Sutskever等人创建的序列到序列方法的基础上。用于创建超维隐藏状态表示。该模型此后被称为多变量时域自动编码器(MvTAe)。</p><p>本研究中使用的数据集被创建为玩具数据集性质，用于在简单但功能齐全的环境中演示MvTAe模型。这项研究并不涉及现实世界中关于观察、测量和数据处理的另一个主要挑战。</p><p>为了训练和测试我们的多变量时间自动编码器模型，我们创建了一个包含几个特定维度的合成玩具数据集：</p><p>正弦_1：周期为100个时间步、振幅为1的正弦波。</p><p>正弦_2：周期为1000个时间步，振幅为5的正弦波。</p><p>COMMANED_SIGNAL：SINE_1和SINE_2之和。它将用作我们要预测的Y目标变量，不会包含在MvTAe的自动编码器分支看到的X训练数据中。</p><p>以这种方式创建数据集是为了提供一种方法来测试我们的自动编码器模型的几个重要属性。第一个正弦波是一个随时间重复的模式，这将测试我们的模型捕获该模式的顺序过程的能力。第二个正弦波创建了一个较长期的周期序列模式，我们的模型将不能完全看到每个训练示例，因此它测试了模型捕获周期趋势的能力。噪声维度增加了额外的冗余信息维度，以测试模型识别和忽略与数据的潜在驱动因素无关的维度的能力。最后，组合信号将测试MvTAe的预测分支将来自两个可见维度的信号组合到第三个隐藏目标维度的能力。</p><p>在模型的自动编码器分支中，该组合信号维度不用作输入，因为在此阶段的目的是创建数据集的可见X维度的潜在矢量表示。在第二级预测分支中，组合信号被用作未来预测的Y目标。</p><p>为了给我们的模型提供支持，数据集被分成长度为N的滑动窗口，每个窗口之间的步长为S。该方法允许训练我们的自动编码器分支来回顾N个时间步骤，以确定时间序列内的关系模式。我们的第一级自动编码器分支的Y目标是沿时间轴的输入的逆。我们的第二阶段预测分支的Y目标将是的每个窗口的COMMANED_SIGNAL维度。</p><p>创建跨维度的标准化滑动窗口和附带的目标变量的代码如下</p><p>IDX_FORENT=0IDX_REAR=窗口大小FEATURES_x=[&#39；SINE_1&#39；，&#39；SINE_2&#39；，&#39；噪波&#39；]FEATURE_Y=&#39；组合&#39；TR_DATA_WINDOWS_SIZE=int(np.ceil((DATA[&#39；SINE_1&#39；][：idx_val_split].shape[0]-window_size-1)/step_size))TR_DATA_WINDOWS=np.空((TR_DATA_WINDOWS_SIZE，len(FEATURES_X)，WINDOW_SIZE))TR_DATA_WINDOWS_y=np.zeros(TR_DATA_WINDOWS_SIZE)I=0Pbar=tqdm(总数=TR_DATA_WINDOWS_SIZE-1，首字母=i)而IDX_REAR+1&lt；数据[&#39；SINE_1&#39；][：IDX_VAL_SPLIT].Shape[0]：#创建x个数据窗口对于j，枚举中的要素(Feature_X)：_DATA_WINDOW，_HI，_LO=NORM(DATA[FEATURE][IDX_FORWART：IDX_REAR])TR_DATA_WINDOWS[i][j]=_DATA_WINDOWS#沿相同的规格化比例创建y_，hi，lo=NORM(DATA[FEATURE_y][IDX_FORWART：IDX_REAR])_y=NORM(DATA[FEATURE_Y][IDX_REAR]，hi，LO)[0]TR_DATA_WINDOWS_y[i]=_yIDX_FORENT=IDX_FORENT+STEP_SIZEIDX_READER=IDX_FORWARD+WINDOW_SIZEI+=1Pbar.update(1)Pbar.close()#重塑[采样、时间步长、要素]中的输入TR_DATA_SIZE=TR_DATA_Windows.Shape[0]TR_INPUT_SEQ=TR_Data_windows.swapaxes(1，2)。</p><p>作为训练深度神经网络以获得最佳收敛性能的标准实践，我们将数据归一化。当我们沿着多个维度处理时态数据窗口时，我们将每个窗口和窗口内的每个维度视为在归一化方面是独立的。这意味着对于维度k的每个窗口W，我们独立于该窗口内的所有其他k个维度对数据进行归一化。对于归一化过程本身，我们使用标准的MinMax归一化。因此，归一化过程可以总结为每个等式n。1.。</p><p>Def Norm(数据，hi=无，lo=无)：Hi=np.max(数据)，如果不是hi则为hi hiLO=np.min(数据)，如果不是LO，则为其他日志如果hi-lo==0：返回0，嗨，您好Y=(DATA-LO)/(Hi-LO)返回y，嗨，您好。</p><p>此外，当在真实世界预测应用中使用时，模型的最终预测输出在输入数据的绝对尺度上通常是有利的。因此，需要进行反标准化过程才能将数据带回输入刻度。对于最小最大归一化，我们使用数据窗口的最小(Lo)和最大(Hi)值来归一化数据，因此在归一化过程中创建的这些值对于去归一化过程是必需的。我们将该反规格化过程定义为根据等式n。2.。</p><p>使用X窗口中的hi、lo值归一化的归一化数据窗口尺寸和Y目标。</p><p>我们的预测问题的第一阶段是以优化的向量格式表示我们的多维时间序列，以这种方式表示多变量序列的特征，从而可以捕获完整的序列动态。这个过程通常被称为特征工程，通常是在构建潜在驱动因素的近似时需要领域知识和手动特征创建过程的步骤。</p><p>MvTAe模型以无监督的方式将序列压缩成隐藏状态向量表示，本质上找到序列内的潜在特征并在该状态向量内表示它们。</p><p>MvTAe模型的组成类似于第一分支上的Sequence-2-Sequence模型。然而，几个关键的差异使得MvTAe模型对于多变量时间序列能够更好地工作。</p><p>MvTAe模型的第一个分支由两部分组成：编码器，其将输入序列转换为隐藏状态向量；解码器，其获取隐藏状态向量，并将其转换回原始序列，尽管是相反的。我们将模型的这个分支称为EncoderDecoder分支。</p><p>编码器部分将表示归一化数据的多维窗口序列的张量作为其输入。该张量用作长短期记忆(LSTM)单元层的输入。这里的LSTM单元将输入序列的维度作为输入维度，并且对于每个连续步骤返回固定指定维度的上下文向量。取最终序列步长LSTM单元的上下文向量并将其标记为我们的隐藏状态向量。当正确训练编码器时，该隐藏状态向量可被视为构成整个输入序列的全部维度的驱动器的高维近似--本质上，这是传统特征工程旨在创建的特征向量，然后与模型的第二分支一起用于预测未来的序列步骤，然而，该特征向量/隐藏状态向量的创建是由解码器以无监督的方式完成的。</p><p>解码器结构在其由与序列长度相等的相同层的LSTM信元组成的意义上与编码器相似。这些单元中的每一个的输入是从最后一个编码器LSTM单元的最终上下文矢量创建的隐藏状态矢量，其被复制到每个解码器单元中。注意，虽然隐藏状态向量是LSTM上下文输出，但我们不将其视为解码器LSTM单元的上下文输入，而是将其视为常规输入，并且随机初始化解码器的初始小区上下文。</p><p>解码器结构还包含在LSTM单元输出和最终输出之间的附加线性完全连接的神经层。该完全连接层使得反向传播训练过程能够捕获数据内的高维线性函数，并且因此允许LSTM解码器层集中于捕获数据内的非线性顺序函数。</p><p>Self.decder=nn.LSTM(INPUT_SIZE=self.encoder.HIDDED_SIZE，HIDDEN_SIZE=self.encoder.HIDDED_SIZE，BATCH_FIRST=FALSE)Self.decder_output=nn.线性(self.encoder.HIDDEN_SIZE，self.out_data_dims)ENCODER_HIDDED_DROPOUT=self.dropout(HIDDED_STATE_VECTOR)DECODER_OUT，DECODER_HIDDEN=self.decoder(encoder_hidden_dropout.repeat(self.seq_len，1，1))解码器_OUTPUT=self.decoder_output(decoder_out.transpose(0，1))。</p><p>解码器的输出-以及使此过程不受监督的原因-与编码器的输入相同，因此该模型以自动编码器的方式映射。但是，需要注意的是，因此解码器输出目标是X()的反向输入。正如Sutskever等人所做的那样。发现反转解码器目标显著提高了建模精度，这可能是由于序列内的短期依赖性比长期模式的影响更大。</p><p>输入维度的解码器重建的可视化。注意，随机噪声维度没有可重现性，因此信号进行平均预测以使误差最小化。</p><p>MvTAe模型的第二个分支充当预测分支-我们将其称为Alpha分支，因为它会生成预测Alpha信号作为其输出。它的输入是编码器的输出-隐藏状态向量，其在被充分训练时表示数据集的底层上下文和驱动因素，因此可以用于训练用于数据集的前瞻预测的预测阿尔法分支。</p><p>阿尔法分支的结构是一个传统的深度完全连接的结构，因此存在两个完全连接的隐层神经元。为了允许建模非线性，这是大多数复杂的顺序问题所需要的，两个隐层中的神经元的激活函数被制成校正的线性单元(REU)。这里选择RELU函数是因为它们代表了表示非线性的最稳定的函数，如Zeiler等人所示。其中RELU函数帮助减轻反向传播过程中梯度消失/爆炸的问题。</p><p>Alpha分支的PyTorch代码。在每次正向传递时，都会计算并返回所有三个变量的输出：HIDDEN_STATE_VECTOR、DECODER_OUTPUT和Alpha_Output。</p><p>Self.alpha_HIDDED_1=nn.线性(self.encoder.HIDDEN_SIZE，HIDDED_Alpha_SIZE)Self.alpha_Hidden_2=nn.线性(HIDDED_Alpha_Size，HIDDED_Alpha_Size)Self.alpha_out=nn.线性(Hidden_Alpha_Size，1)ALPHA_HIDDED_1=F.relu(self.alpha_hidden_1(hidden_state_vector))Alpha_Hidden_1_Dropout=self.dropout(Alpha_Hidden_1)ALPHA_HIDDEN_2=F.relu(self.alpha_hidden_2(alpha_hidden_1_dropout))ALPHA_OUTPUT=self.alpha_out(Alpha_HIDDED_1).Squeeze()。</p><p>Alpha分支的目标输出是我们要为特定数据窗口建模的维度的规范化前一步数据点，因此，对于数据窗口，我们将目标定义为。</p><p>因此，这是我们第一次在模型中使用数据集的组合信号维度，这最终是我们试图预测的维度。但是，重要的是要注意，在归一化过程中，在初始归一化计算中不包括提前一步的目标，因为这将导致不想要的信息泄漏。同样地，当将目标数据点归一化时，我们相对于从相应数据窗口归一化获得的HI和L0值独立地归一化该点。</p><p>模型拟合过程的PyTorch代码。请注意，每个分支机构的单个损失被汇总为一般损失，然后向后传播。</p><p>对于tqdm中的i(range(start_pech，pechs)，DISABLE=非详细)：Self.Train()#将model设置为训练模式对于Data_loader中的x_Batch、y_Batch：X=x_batch.to(self.device)X_inv=x.flip(1)#在所有维度上重建的x的反转序列(dim 1Y=y_batch.to(self.device)Self.Optimizer.zero_grad()隐藏状态矢量、解码器输出。ALPHA_OUTPUT=SELF(X)LOSS_DECODER=self.oss_decder(DECODER_OUTPUT，x_inv)Loss_Alpha=self.oss_alpha(Alpha_Output，y)Loss=Loss_解码器+Loss_AlphaLoss.backward()Torch.nn.utils.clip_grad_norm_(self.parameters()，1.5)Self.Optimizer.step()。</p><p>与编解码器分支一样，使用标准反向传播算法并相对于均方误差(MSE)损失函数来训练Alpha分支。MSE损失被用作两个问题分支(编解码器和Alpha分支)处理连续目标的回归预测，而不是任何分类问题。对于这个特定的模型，由于使用ADAM函数证明了回归问题的最佳收敛性，因此采用了ADAM优化器函数。</p><p>非规格化预测与目标，使用存储的每个数据窗口的HI、L0值进行非规格化。</p><p>沿着原始参考数据尺度产生非规格化预测的过程总结在下面的代码中，该代码在运行中创建数据窗口，存储该规格化数据窗口的HI，L0值，并使用这些HI，L0值来对最终预测输出进行非规格化，以对照原始非规格化数据窗口进行绘制。这种对目标的预测可以在上图中看到。</p><p>TRUE=[]PRED=[]对于tqdm(range(data.Shape[0]))中的i：如果I&lt；窗口大小(_SIZE)：继续DATA_WINDOW=DATA[i-Window_Size：i]Input_seq=np.zeros((1，window_size，len(Feature_X)对于j，枚举中的要素(Feature_X)：_DATA_WINDOW，_，_=规范(DATA_WINDOW[FEATURE])Input_seq[0，：，j]=_data_window_，hi，lo=规范(Data_Window[Feature_y])X_HIDDEN_VECTOR、DECODER_OUTPUT、。Alpha_output=model(from_numpy(Input_Seq).floate())Abs_pred=reverse_norm(alpha_output.squeeze().detach().cpu().numpy()，嗨，低)True.append(data[Feature_y][i])Pred.append(Abs_Pred)。</p><p>结果精度用均方误差(MSE)、平均绝对误差(MAE)和R2值来衡量预测与目标之间的相关性。在每个MSE和MAE中，我们希望通过调整模型的三个主要驱动因素来最小化第一个实例中的误差，并在第二个实例中最大化R2值：批量大小、隐藏向量大小和数据窗口大小。还可以探索许多其他超参数，如学习率、激活函数值和神经层大小，但在这些实验中，我们只显示了上述三个对精度影响最大的驱动因素，其他超参数总体上处于优化状态。</p><p>我们沿着上面提到的三个主要超参数执行以下有限参数搜索，每个搜索点的模型运行时间为100个时期。</p><p>这项工作展示了具有递归自动编码器功能的深层多分支神经网络的结构和使用，该网络能够通过创建时间数据驱动器的隐藏状态向量表示来成功地对多变量时间数据序列建模。</p><p>通过一个合成数据玩具的例子说明了这一点，该合成数据玩具将不同频率和幅度的正弦波组合成一个隐藏的目标信号，该模型能够成功地重建并预测到未来的时间步长，并且具有很高的精度。</p><p>实验结果表明，通过对批次大小、隐向量大小和数据窗口大小三个主要超参数进行100个历元的短参数搜索，这些参数中最优的是：批次大小=8，隐藏向量大小=128，窗口大小=100。可以观察到，存在这些最优参数状态，低于这些状态不能捕获数据的完整表示，高于这些状态表示过于复杂，从而导致精度不稳定。</p><p>有趣的是，可以从隐藏向量大小变化实验中观察到，即使隐藏向量大小非常有限，也可以创建相当准确的数据窗口表示。我们看到，尽管目标信号由多维的100个连续步骤组成，但是。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://altumintelligence.com/articles/a/Multivariate-Temporal-Autoencoder-for-Predictive-Reconstruction-of-Deep-Sequences">https://altumintelligence.com/articles/a/Multivariate-Temporal-Autoencoder-for-Predictive-Reconstruction-of-Deep-Sequences</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/深部/">#深部</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/temporal/">#temporal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>