<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>终端多路复用器 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">终端多路复用器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 22:25:53</div><div class="page_narrow text-break page_content"><p>将终端视为理所当然很容易。毕竟，现代终端模拟器（例如gnome-terminal，konsole和Linux桌面环境附带的其他终端模拟器）是功能丰富的应用程序，可以满足我们的大多数需求。但是有时候我们需要更多。我们需要在单个终端上运行多个Shell会话。我们需要在一个终端中显示多个应用程序。我们需要将正在运行的终端会话从一台计算机移动到另一台计算机。简而言之，我们需要一个终端多路复用器。</p><p> 终端多路复用器是可以执行这些惊人功能的程序。在这次冒险中，我们将看三个示例：GNU屏幕，tmux和byobu。</p><p>  如果我们回想一下1980年代中期，我们可能会发现自己盯着计算机终端。一个具有80列宽，24行高显示屏的盒子，以及一个通过RS-232串行连接（可能还有声耦合器调制解调器和电话听筒）连接到共享的中央Unix计算机的键盘。在显示屏幕上，可能会有一个shell提示符，与我们今天在Linux终端会话期间看到的提示符不同。但是，与今天不同，1980年代的计算机终端没有多个窗口或选项卡来显示多个应用程序或Shell会话。我们只有一个屏幕，仅此而已。终端多路复用器最初是为了帮助解决此问题而开发的。终端多路复用器允许在单个屏幕上显示和管理多个会话和应用程序。尽管现代的桌面环境和终端仿真器程序支持多个窗口和选项卡式终端会话，这减轻了出于某些目的对终端多路复用器的需求，但终端多路复用器仍提供了一些功能，这些功能将大大增强我们的命令行体验。</p><p>  GNU屏幕回去了。屏幕最早于1987年开发，似乎是该类型的第一个程序，它定义了所有后续终端多路复用器中发现的基本功能集。</p><p>  顾名思义，GNU屏幕是GNU工程的一部分。尽管默认情况下很少安装它，但它在大多数发行版本存储库中均以＆＃34; screen＆＃34;软件包的形式提供。</p><p>  我们只需在shell提示符下输入screen命令即可开始使用GNU屏幕。启动命令后，将显示一个shell提示。</p><p>  此时，屏幕正在运行并创建了它的第一个窗口。屏幕使用的术语有些混乱。最好这样考虑：屏幕管理一个由一个或多个窗口组成的会话，每个窗口都包含一个外壳程序或其他程序。此外，屏幕可以将终端显示分为多个区域，每个区域显示一个窗口的内容。 </p><p>无论如何，我们现在正在运行屏幕，并且正在显示其第一个窗口。让我们在当前窗口中输入命令：</p><p>   到现在为止还挺好。现在，让我们创建另一个窗口。为此，我们键入Ctrl-a，后跟字符＆＃34; c＆＃34;。我们的终端屏幕应该清除，并且我们应该看到一个新的shell提示。那么，第一个运行了top的窗口刚刚发生了什么？它仍在后台运行。我们可以通过输入Ctrl-a p返回到第一个窗口（对于上一个＆p34; p认为＆p34; p）。</p><p> 在继续之前，我们先来谈谈键盘。控制屏幕非常简单。每个命令由Ctrl-a（称为＆＃34;命令前缀＆＃34;或＆＃34;转义序列＆＃34;）组成，后跟另一个字符。我们已经看到了两个这样的命令：Ctrl-a c创建一个新窗口，以及Ctrl-a p从当前窗口切换到上一个窗口。键入命令Ctrl-a吗？将显示所有命令的列表。</p><p> GNU屏幕具有几个命​​令，可从一个窗口切换到另一个窗口。就像上一个命令，有一个＆next＆＃34;命令Ctrl-a n。窗口从0开始编号，可以直接输入Ctrl-a，然后输入0到9进行选择。也可以通过键入Ctrl-a＆＃34;列出所有窗口。该命令将显示窗口列表，我们可以在其中选择一个窗口。</p><p>  如我们所见，窗口具有名称。窗口的默认名称是该窗口在创建时正在运行的程序的名称，因此我们两个窗口都被命名为＆＃34; bash＆＃34;。让我们改变一下。由于我们在第一个窗口中位于顶部，因此让其名称反映出来。使用我们讨论的任何方法切换到第一个窗口，然后键入命令Ctrl-a A，系统将提示您输入窗口名称。简单。</p><p> 好的，所以我们创建了一些窗口，如何销毁它们？只要我们终止在其中运行的程序，就会破坏一个窗口。销毁所有窗口后，屏幕本身将终止。由于我们两个窗口都运行bash，因此我们只需要退出每个相应的shell即可结束屏幕会话。如果程序拒绝正常终止，则Ctrl-a k可以解决问题。</p><p> 让我们通过键入q退出top来终止shell运行，然后输入exit终止bash，从而破坏第一个窗口。现在，我们被带到仍然运行其自己的bash副本的其余窗口。我们可以通过输入Ctrl-a＆＃34;来确认这一点。再次查看窗口列表。 </p><p>无需基础外壳即可创建窗口和运行程序。为此，我们输入屏幕，然后输入要运行的程序的名称，例如：</p><p>  我们甚至可以在屏幕窗口中执行此操作。在屏幕窗口中发出屏幕命令不会调用屏幕的新副本。它告诉屏幕的现有实例执行诸如创建新窗口之类的操作。</p><p>  鉴于GNU屏幕是为既没有图形用户界面又没有鼠标的系统开发的，因此有意义的是该屏幕将提供一种将文本从一个屏幕窗口复制到另一个窗口的方式。它通过进入所谓的回滚模式来做到这一点。在这种模式下，屏幕允许文本光标在当前窗口中以及在包含窗口先前内容的回滚缓冲区的内容之间自由移动。</p><p> 我们通过输入Ctrl-a [开始滚动模式。在回滚模式下，我们可以使用箭头键以及Page Up和Page Down键来导航回滚缓冲区。要复制文本，我们首先需要标记要复制的文本的开头和结尾。这是通过将文本光标移动到所需文本的开头并按空格键来完成的。接下来，将光标移动到所需文本的结尾（在移动光标时突出显示），然后再次按空格键以标记要复制的文本的结尾。标记文本退出回滚模式，并将标记的文本复制到屏幕的内部缓冲区中。现在，我们可以将文本粘贴到任何屏幕窗口中。为此，我们转到所需的窗口并键入Ctrl-a]。</p><p>   GNU屏幕还可以将终端显示划分为单独的区域，每个区域提供屏幕窗口的视图。这使我们可以同时查看2个或更多窗口。要水平拆分终端，请键入命令Ctrl-a S，垂直拆分终端，请按Ctrl-a |。新创建的区域为空（即，它们未与窗口关联）。要显示区域中的窗口，请首先通过按Ctrl-a Tab将焦点移至新区域，然后创建一个新窗口，或使用我们已经讨论过的任何窗口选择命令选择一个现有窗口来显示。区域可以进一步细分为较小的区域，我们甚至可以在多个区域中显示相同的窗口。</p><p>  当使用大型终端显示器时，使用多个区域非常方便。例如，如果将显示分为两个水平区域，则可以在一个区域中编辑脚本，而在另一个区域中对脚本进行测试。或者，我们可以在一个区域中阅读手册页，然后在另一个区域中尝试命令。</p><p> 有两个删除区域的命令：Ctrl-a Q删除当前区域以外的所有区域，而Ctrl-a X删除当前区域。请注意，删除区域不会删除其关联的窗口。 Windows一直存在直到被销毁。 </p><p>屏幕可能最有趣的功能是它可以将会话与终端本身分离。正如它可以在终端的任何区域上显示其窗口一样，屏幕也可以在任何终端或根本没有终端上显示其窗口。</p><p> 例如，我们可以在一台计算机上启动一次屏幕会话，例如在办公室，将会话与本地终端分离，回家并远程登录我们的办公室计算机，然后将屏幕会话重新连接到我们的家用计算机终端。在此期间，我们办公室计算机上的所有作业均继续执行。</p><p>  screen -list列出系统上运行的屏幕会话。如果有多个会话在运行，可以将清单中显示的pid.tty.host字符串附加到下面的-d / -D和-r / -R选项中，以指定特定的会话。</p><p> screen -d -r将屏幕会话与上一个终端分离，并将其重新附加到当前终端。</p><p> screen -D -R从先前的终端分离屏幕会话，使用户退出旧终端，并将该会话附加到新终端，如果不存在任何会话，则创建新会话。根据屏幕文档，这是作者的最爱。</p><p> -d / -D和-r / -R选项可以单独使用，但是最常一起使用，它们可以在一个步骤中分离和重新连接现有的屏幕会话。</p><p> 我们可以通过打开两个终端来演示此过程。在第一个终端上启动屏幕并创建一些窗口。现在，转到第二个终端并进入命令屏幕-D -R。这将导致第一终端消失（用户已注销），并且屏幕会话完全完整地移至第二终端。 </p><p>像许多交互式GNU实用程序一样，屏幕是非常可定制的。在调用过程中，screen会读取/ etc / screenrc和〜/ .screenrc文件（如果存在）。尽管可定制功能的列表非常广泛（许多与各种Unix和类似Unix的平台上的终端显示控制有关），但由于它们是最常用的，因此我们将关注按键绑定和启动会话配置。</p><p>  ＃这是一个注释＃设置一些键绑定bin k＃取消绑定＆＃34; k＆＃34;键（将其设置为不执行任何操作）bind K kill＃使`Ctrl-a K`破坏当前windowbind}历史记录＃使`Ctrl-a}`复制并粘贴当前＃命令行＃定义窗口7、8和9在启动屏幕上-t＆＃34; mdnght cmdr＆＃34; 7 mcscreen -t htop 8 htopscreen -t syslog 9 tailf / var / log / syslog</p><p> 如我们所见，格式非常简单。 bind指令后跟按键和要绑定到的屏幕命令。屏幕命令的完整列表可以在屏幕手册页中找到。到目前为止，我们讨论的所有屏幕命令都是简单的按键绑定，如上面的示例中所示。我们可以随意重新定义它们。</p><p> 示例screenrc文件末尾的三行代码在启动时创建窗口。这些命令设置窗口标题（-t选项），窗口编号以及要包含的窗口的命令。这样，我们可以设置一个在启动屏幕时自动构建的屏幕会话，该屏幕会话包含一个运行所有我们喜欢的程序的完整的多窗口命令行环境。</p><p>  尽管GNU屏幕一直很受欢迎，但由于其代码复杂性（以至于被称为“不可维护”）和资源消耗而受到批评。另外，据报道，不再积极开发屏幕。针对这些问题，新的程序tmux引起了广泛关注。</p><p> tmux是现代的，更友好的，更高效的，并且在大多数方面都优于屏幕。从概念上讲，tmux与屏幕非常相似，因为它还支持会话，窗口和区域（在tmux中称为窗格）的概念。实际上，它甚至与屏幕共享一些键盘命令。</p><p>  tmux可以广泛使用，尽管不如屏幕广泛。它在大多数发行版本存储库中都可用，但是奇怪的是，它在Red Hat / CentOS（从版本6开始）中不存在。软件包名称是＆＃34; tmux＆＃34;。 </p><p>使用命令tmux new调用该程序以创建新会话。我们可以选择添加-s＆lt; session_name＆gt;为新会话分配名称，然后-n＆lt; window_name＆gt;为第一个窗口分配名称。如果没有为新命令提供选项，则可以省略新命令本身；将被假定。这是一个例子：</p><p>  程序启动后，在窗口底部将显示一个shell提示和一个漂亮的状态栏。</p><p>   tmux使用键盘的方式类似于屏幕，但是tmux使用Ctrl-b而不是使用Ctrl-a作为命令前缀。这很好，因为在bash中编辑命令行以将光标移动到行首时使用Ctrl-a。</p><p>    像屏幕一样，tmux可以将终端显示分为几部分，称为窗格。但是，与在屏幕中实现区域不同，tmux中的窗格不仅仅为各种窗口提供视口。在tmux中，它们是与窗口关联的完整伪终端。因此，单个tmux窗口可以包含多个终端。</p><p>  我们可以通过创建一个会话和几个窗口来演示窗格的行为。首先，我们将创建一个会话，命名它​​，并命名初始窗口：</p><p>    我们可以使用Ctrl-b命令完成第二步，但是看到命令行方法可以使我们为以后的工作做好准备。</p><p> 假设一切顺利，我们现在处于名为＆＃34; PaneDemo＆＃34;的tmux会话中。和一个名为＆＃34; Window1＆＃34;的窗口。现在，我们将通过按Ctrl-b＆＃34;将窗口水平分成两部分。我们仍然只有两个窗口（Window0和Window1），但是Window1上现在有两个shell提示。我们可以在两个窗格之间来回切换，方法是按Ctrl-b，然后按向上箭头或向下箭头。 </p><p>只是为了好玩，让我们输入Ctrl-b t，数字时钟出现在当前窗格中。这是tmux可以做的一件可爱的事。</p><p>  我们可以通过输入q来终止时钟显示。如果我们通过输入Ctrl-b 0移到第一个窗口，我们会看到窗格仍与Window1关联，并且对Window0没有影响。</p><p> 返回Window1，我们调整窗格的大小。我们可以通过按Ctrl-b Alt-arrow将边界向上或向下移动5行来实现。键入Ctrl-b Ctrl-箭头会将边界移动1行。</p><p> 可以将窗格拆分成自己的新窗口。这是通过按Ctrl-b！来完成的。</p><p> Ctrl-b x用于破坏窗格。请注意，与屏幕不同，销毁tmux中的窗格还会销毁其中运行的伪终端以及任何关联程序。</p><p>  像屏幕一样，tmux具有复制模式。通过键入Ctrl-b [来调用它。在复制模式下，我们可以在回滚缓冲区内自由移动光标。要标记要复制的文本，我们首先输入Ctrl-space开始选择，然后移动光标进行选择。最后，我们输入Alt-w复制所选文本。</p><p>  与数字时钟一样，我们通过键入＆＃34; q＆＃34;返回正常模式。现在，我们可以通过按Ctrl-b]粘贴复制的文本。 </p><p>使用tmux，比使用屏幕更容易管理多个会话。首先，我们可以在创建过程中为会话提供描述性名称，就像我们在＆＃34; PaneDemo＆＃34;中看到的那样。上面的示例，或者使用Ctrl-b $重命名现有会话。其次，通过键入Ctrl-b并从显示的列表中选择一个会话，可以轻松地即时切换会话。</p><p> 在会话中时，我们可以输入Ctrl-b d来分离它，并实质上将tmux放入后台。如果我们想通过输入tmux new命令来创建新会话，这将很有用。</p><p> 如果启动新终端（或从远程终端登录）并希望将现有会话附加到该终端，则可以发出命令tmux ls以显示可用会话的列表。要附加会话，我们输入命令tmux attach -d -t＆lt; session_name＆gt;。 ＆＃34; -d＆＃34;选项导致会话与其上一个终端分离。没有此选项，会话将同时附加到其先前的终端和新的终端。</p><p>  正如我们期望的那样，tmux是非常可配置的。当tmux启动时，它将读取文件/etc/tmux.conf和〜./。tmux.conf（如果存在）。也可以使用-f选项启动tmux并指定备用配置文件。这样，我们可以拥有任意数量的自定义配置。</p><p> 就像在屏幕上一样，配置命令的数量也很多。有关完整列表，请参见tmux手册页。</p><p> 例如，这是一个示例配置文件，该文件将命令前缀键从Ctrl-b更改为Ctrl-a，并使用4个窗口创建一个新会话：</p><p> ＃示例tmux.conf文件＃将命令前缀从Ctrl-b更改为Ctrl-unbind-key C-bset-option -g前缀C-abind-key Ca发送前缀######创建带有4个窗口的会话＃ #####创建会话和第一个窗口new-session -d -s MySession＃创建第二个窗口并垂直分割它new-windowsplit-window -d -h＃创建运行Midnight Commander的第三个窗口new-window -d- n MdnghtCmdr mc＃创建运行htopnew-window -d -n -htop htop＃的第四个窗口（并命名为它）将焦点移至sessionselect-window -t 0中的第一个窗口 </p><p>由于此配置创建了新会话，因此我们应该通过输入命令tmux attach启动tmux，以避免自动创建新会话的默认行为。否则，我们将导致额外的不必要的会话。</p><p>  byobu（发音为BEE-oh-boo＆＃34;），日语为“折叠，装饰性多面板屏风”本身不是终端多路复用器，而是GNU屏幕或tmux（默认为tmux）的包装。它旨在创建一个简化的用户界面，重点是在状态栏上显示有用的系统信息。</p><p>  byobu最初是由Canonical员工Dustin Kirkland开发的，因此通常可以在Ubuntu和其他基于Debian的发行版中找到。最新版本比初始版本具有更高的可移植性，并且开始出现在更广泛的发行版中。它作为包＆＃34; byobu＆＃34;分发。</p><p>  只需输入命令byobu，然后可选地输入要传递到后端终端多路复用器（即tmux或screen）的任何选项和命令，即可简单地启动byobu。对于这次冒险，我们将讨论局限于tmux后端，因为它支持更大的功能集。</p><p>   与screen和tmux不同，byobu不会使用Ctrl-a之类的命令前缀来启动命令。 byobu广泛依赖于功能键。这使得byobu较容易学习，但是作为交换，它放弃了底层终端多路复用器的某些功能和灵活性。也就是说，byobu仍为最有用的功能提供了易于使用的界面，并且还提供了用作tmux命令的命令前缀的键（F12）。以下是使用tmux作为后端时byobu随附的帮助文件的摘录：</p><p> F1 *由X11使用* Shift-F1显示此帮助F2创建一个新窗口Shift-F2创建一个水平拆分Ctrl-F2创建一个垂直拆分Ctrl-Shift-F2创建一个新会话F3 / F4在窗口之间移动焦点Shift-F3 / F4在拆分之间移动焦点Ctrl-F3 / F4移动拆分Ctrl-Shift-F3 / F4移动窗口Alt-Up / Down在会话之间移动焦点Shift-左/右/上/下在拆分之间移动焦点Ctrl-Shift-在窗口中向左/向右移动焦点Ctrl-向左/向右/上/下调整大小F5重新加载配置文件，刷新状态Shift-F5切换状态行Ctrl-F5重新连接ssh / gpg / dbus套接字Ctrl-Shift-F5更改状态栏＃39; s随机上色F6分离会话，然后注销Shift-F6分离会话，但不注销Ctrl-F6取消焦点集中的拆分F7输入滚动历史记录Alt-</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.linuxcommand.org/lc3_adv_termmux.php">https://www.linuxcommand.org/lc3_adv_termmux.php</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/多路复用/">#多路复用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/terminal/">#terminal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/屏幕/">#屏幕</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>