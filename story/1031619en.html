<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-28 05:07:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/99f2142c0124e0d0a756ac05f1257d4d.png"><img src="http://img2.diglog.com/img/2020/10/99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is not magic: It&#39;s just an S-expression encoding of the  estree ASTformat. The macros are ordinary JS functions that return objects, which justexist at compile-time. This means macros can be put on  npm to distributeyour own language features,  like this.</p><p>这并不神奇：它只是estree AST格式的S表达式编码。宏是返回对象的普通JS函数，这些对象只在编译时存在。这意味着宏可以放在NPM上来分发您自己的语言特性，如下所示。</p><p>   Small core, close to JS. This core eslisp corresponds closely with the estree abstract syntax tree format, and hence matches output JSclearly. It&#39;s purely a syntax adapter unless you use macros.</p><p>岩心小，靠近JS。此核心eslisp与estree抽象语法树格式紧密对应，因此与输出JSP清晰匹配。除非您使用宏，否则它纯粹是一个语法适配器。</p><p> Maximum user control. Users must be able to easily extend the languageto their needs, and to publish their features independently of the corelanguage.</p><p>最大用户控制。用户必须能够轻松地扩展语言以满足他们的需要，并且能够独立于核心语言发布他们的功能。</p><p> User-defined macros must be treated like built-in ones, and are justordinary JS functions. This means you can write them in anything thatcompiles to JavaScript, put them on  npm, and  require them.</p><p>用户定义的宏必须像对待内置宏一样对待，并且只是普通的JS函数。这意味着您可以用编译成JavaScript的任何语言编写它们，将它们放在NPM上并需要它们。</p><p>   ; Macros are functions bound to names, which operate on code. This one; checks whether the `$DEBUG` environment variable is set, and if so,; returns a call to `console.log` that also includes a string of the code; that was passed in.(macro debug (lambda (expression) (if (. process env DEBUG) (return `((. console log) ; Compile the input expression to JavaScript, and convert ; that to a string. ,((. this string) ((. this compileToJs) ((. this compile) expression))) &#34;=&#34; ,expression)) (return null))))(var fib ; Fibonacci number sequence (lambda (x) ; Conditionally compile logging code (debug x) ; Basic Fibonacci algorithm (switch x (0 (return 0)) (1 (return 1)) (default (return (+ (fib (- x 1)) (fib (- x 2))))))))</p><p>；宏是绑定到名称的函数，在代码上操作。这个；检查是否设置了`$DEBUG`环境变量，如果设置了，；返回对`console.log`的调用，该调用还包括传入的代码字符串。(MACRO DEBUG(lambda(Expression)(if(.。进程环境调试)(返回`((.。控制台日志)；将输入表达式编译为JavaScript，并将其转换为字符串。、(、(.。此字符串)((.。此编译程序为ToJs)((.。此编译)表达式)&#34；=&#34；，表达式))(返回NULL)(var fib；斐波那契数序列(lambda(X)；有条件编译日志记录代码(Debug X)；基本斐波那契算法(开关x(0(返回0))(1(返回1))(默认(return(+(fib(-x 1))(fib(-x 2)。</p><p>  var fib = function (x) { console.log(&#39;x&#39;, &#39;=&#39;, x); switch (x) { case 0: return 0; case 1: return 1; default: return fib(x - 1) + fib(x - 2); }};</p><p>Var fib=function(X){console.log(&#39；x&#39；，&#39；=&#39；，x)；开关(X){案例0：返回0；案例1：返回1；默认：返回fib(x-1)+fib(x-2)；}}；</p><p> Note how the generated  console.log also has  the name of the variable  x asa string. Try changing the  debug call to  (debug ((. Math pow) (+ x 1) 2)and watch the logging code change to say  Math.pow(x + 1, 2) also inside thefirst string. (You can edit it in your browser  on runkithere.)</p><p>请注意，生成的console.log还具有变量x ASA字符串的名称。尝试将调试调用更改为(DEBUG((.。Math.power)(+x1)2)，并观察日志记录代码更改为Math.pow(x+1，2)也在第一个字符串中。(您可以在runkihere上的浏览器中对其进行编辑。)。</p><p>  var fib = function (x) { switch (x) { case 0: return 0; case 1: return 1; default: return fib(x - 1) + fib(x - 2); }};</p><p>Var fib=function(X){switch(X){case 0：return 0；case 1：return 1；default：return fib(x-1)+fib(x-2)；}}；</p><p>  Your output code is smaller, compared to the usual technique of hiding yourdebug code behind a boolean flag.</p><p>与通常将调试代码隐藏在布尔标志后面的技术相比，您的输出代码更小。</p><p> This actually logs the expression that produced the result. Can&#39;t do thatin JS without writing it manually every time, because you can&#39;t invoke thecompiler at compile-time.</p><p>这实际上记录了产生结果的表达式。在JS中，如果不每次都手动编写，就不能做到这一点，因为您不能在编译时调用编译器。</p><p>  I wanted JavaScript to be  homoiconic and have modular macros written inthe same language. I feel like this is the  adjacent possible in thatdirection.  Sweet.js exists for macros, but theyre awkward to write andaren&#39;t JavaScript.  Various JavaScript lisps exist, but most havefeaturitis from trying too hard to be Lisp (rather than just being a JSsyntax), and none have macros that are just JS functions.</p><p>我希望JavaScript是同形的，并且用相同的语言编写模块宏。我觉得这是那个方向可能的相邻位置。Sweet.js是为宏而存在的，但是它们编写起来很笨拙，而且不是JavaScript。存在各种JavaScript lisp，但大多数都具有过于努力地成为Lisp(而不仅仅是一种JS语法)的特性，并且没有一个具有仅仅是JS函数的宏。</p><p> I want a language that I can adapt. When I need  anaphoric conditionals,or  conditional compilation or file content inlining (like  brfs), ora  domain-specific language for my favourite library, or something insanethat hacks NASA and runs all my while-loops through  grep during compilationfor some freak reason, I want to be able to create that language feature myselfor  require it from npm if it exists, and hence make the language better forthat job, and for others doing it in the future.</p><p>我想要一种我能适应的语言。当我需要回指条件，或者条件编译或者文件内容内联(如BRF)，或者我最喜欢的库的特定于领域的语言，或者出于某种奇怪的原因，在编译期间黑客攻击NASA并通过grep运行我所有的While循环的疯狂事情时，我希望能够自己创建该语言功能，如果它存在，则需要从NPM获得它，从而使该语言更适用于这项工作，并在将来为其他人做得更好。</p><p>  S-expressions are also quite conceptually beautiful; they&#39;re just nested lists,minimally representing the  abstract syntax tree, and it&#39;s widely knownthat  they rock, so let&#39;s use what works.</p><p>S表达式在概念上也相当漂亮；它们只是嵌套列表，最小限度地表示抽象语法树，众所周知它们很棒，所以让我们使用有效的。</p><p> This has great  hack value too of course.  Lisp macros are thecoolest thing since mint ice cream. Do I even need to say that?</p><p>当然，这也有很大的黑客价值。LISP宏是继薄荷冰淇淋之后最酷的东西。我还需要这么说吗？</p><p>    This is a quick overview of the core language. See  the basics referenceor the  test suite for a more complete document.</p><p>这是核心语言的快速概述。有关更完整的文档，请参阅基本参考或测试套件。</p><p>   ; Everything from a semicolon to the end of a line is a comment.hello ; This is an atom.&#34;hello&#34; ; This is a string.(hello &#34;hello&#34;) ; This is a list containing an atom and a string.() ; This is an empty list.</p><p>；从分号到行尾的所有内容都是注释。hello；这是一个原子。&#34；hello&#34；；这是一个字符串。(Hello&#34；hello&#34；)；这是一个包含原子和字符串的列表。()；这是一个空列表。</p><p>   All eslisp code is constructed by calling macros at compile-time. There arebuilt-in macros to generate JavaScript operators, loop structures, expressions,statements… everything needed to write arbitrary JavaScript.</p><p>所有的eslisp代码都是通过在编译时调用宏来构造的。有内置的宏来生成javascript运算符、循环结构、表达式、语句…。编写任意JavaScript所需的一切。</p><p>  A macro is called by writing a list with its name as the first element and itsarguments as the rest:</p><p>通过编写一个列表来调用宏，该列表将其名称作为第一个元素，并将其参数作为其余元素：</p><p> ; The &#34;.&#34; macro compiles to property access.(. a b)(. a b 5 c &#34;yo&#34;); The &#34;+&#34; macro compiles to addition.(+ 1 2); ... and similarly for &#34;-&#34;, &#34;*&#34;, &#34;/&#34; and &#34;%&#34; as you&#39;d expect from JS.</p><p>；&#34；.&#34；宏编译为属性访问。A)(B)(.。A b5c&#34；yo&34；)；宏编译为加法。(+12)；...。对于您从JS期望的&#34；-&#34；、&#34；*&#34；和&#34；%#34；也是如此。</p><p>  If the  (. a b) syntax feels tedious, you might like the  eslisp-propertify transform macro, which lets you write  a.b instead.</p><p>如果(.。A)语法感觉单调乏味，您可能喜欢eslisp-Propertify转换宏，它允许您编写a.b。</p><p> If the first element of a list isn&#39;t the name of a macro which is in scope, itcompiles to a function call:</p><p>如果列表的第一个元素不是作用域中的宏名称，它将编译为函数调用：</p><p>    ; The &#34;=&#34; macro compiles to a variable declaration.(var x (+ 1 (* 2 3))); Calling the result of a property access expression((. console log) &#34;hi&#34;)</p><p>；&#34；=&#34；宏编译为变量声明。(var x(+1(*23)；调用属性访问表达式的结果((.。控制台日志)&#34；嗨&#34；)。</p><p>    ; The &#34;if&#34; macro compiles to an if-statement(if lunchtime ; argument 1 becomes the conditional (block (var lunch (find food)) ; argument 2 the consequent (lunch)) (writeMoreCode)) ; argument 3 (optional) the alternate</p><p>；&#34；IF&#34；宏编译为IF语句(如果午餐时间；参数1成为条件(BLOCK(var Lunch(Find Food))；参数2为后件(午餐))(WriteMoreCode))；参数3(可选)为替代。</p><p>  Note how the block statement ( (block ...)) has to be made explicit. Becauseit&#39;s so common, other macros that accept a block statement as their lastargument have sugar for this: they just assume you meant the rest to be in ablock.</p><p>注意BLOCK语句((BLOCK...))。必须说得很清楚。因为它太常见了，其他接受BLOCK语句作为最后一条语句的宏对此也有好处：它们只是假设您的意思是其余的都处于阻塞状态。</p><p> For example. the  lambda macro (which creates function expressions) treats itsfirst argument as a list of the function&#39;s argument names, and the rest asstatements in the body.</p><p>例如。Lambda宏(创建函数表达式)将其第一个参数视为函数的参数名列表，其余参数视为正文中的语句。</p><p>    (var n 10)(while (-- n) ; first argument is loop conditional (hello n) ; the rest are loop-body statements (hello (- n 1)))</p><p>(Var N 10)(WHILE(--n)；第一个参数是有循环条件的(Hello N)；其余参数是循环体语句(hello(-n 1)。</p><p>  You  can use an explicit block statements ( (block ...)) wherever implicitones are allowed, if you want to.</p><p>您可以使用显式BLOCK语句((BLOCK...))。任何允许含蓄的地方，如果你想的话。</p><p>     Macros are functions that run at compile-time. Whatever they return becomespart of the compiled code. User-defined macros and pre-defined compiler onesare treated equivalently.</p><p>宏是在编译时运行的函数。无论它们返回什么，都会成为编译代码的一部分。用户定义的宏和预定义的编译器宏被同等对待。</p><p> There&#39;s a  fuller tutorial to eslisp macros in the  doc/ directory.These are just some highlights.</p><p>在文档/目录中有一个更全面的教程来介绍eslisp宏。这些只是一些亮点。</p><p> You can alias macros to names you find convenient, or mask any you don&#39;t wantto use.</p><p>您可以将宏的别名命名为您认为方便的名称，或者屏蔽任何您不想使用的名称。</p><p> (macro a array)(a 1)(array 1) ; The original still works though...(macro array) ; ...unless we deliberately mask it(array 1)</p><p>(宏a数组)(A 1)(数组1)；原始文件仍然有效...(宏数组)；...除非我们故意屏蔽它(数组1)。</p><p>     The macro function is called with a  this context containing methods handy forworking with macro arguments, such as  this.evaluate, which compiles and runsthe argument and returns the result, and  this.atom which creates a newS-expression atom.</p><p>使用this上下文调用宏函数，该上下文包含便于使用宏参数的方法，例如this.valuate(编译并运行参数并返回结果)和this.atom(创建新闻表达式原子)。</p><p> (macro add2 (lambda (x) (var xPlusTwo (+ ((. this evaluate) x) 2)) (return ((. this atom) xPlusTwo))))((. console log) (add2 40))</p><p>(宏add2(lambda(X)(var xPlusTwo(+(.。此评估)x)2)(RETURN((.。这个原子)xPlusTwo)(。控制台日志)(Add240)。</p><p>   (macro log-and-delete (lambda (varName) (return (array `((. console log) ((. JSON stringify) ,varName)) `(delete ,varName)))))(log-and-delete someVariable)</p><p>(宏LOG-AND-DELETE(lambda(VarName)(return(array`(.。控制台日志)(.。Json stringify)，varName))`(delete，varName)(日志删除某些变量)。</p><p>  Returning  null from a macro just means nothing. This is handy forcompilation side-effects and conditional compilation.</p><p>从宏返回NULL没有任何意义。这对于编译副作用和条件编译非常方便。</p><p> ; Only include statement if `$DEBUG` environment variable is set(macro debug (lambda (statement) (return (?: (. process env DEBUG) statement null))))(debug ((. console log) &#34;debug output&#34;))(yep)</p><p>；如果设置了`$DEBUG`环境变量(宏调试(lambda(Statement)(Return(？：(.。Process env debug)语句NULL)(DEBUG((.。控制台日志)&#34；调试输出&#34；))(是)。</p><p>  Because macros are JS functions and JS functions can be closures, you can evenmake macros that share state. One way is to put them in an immediately-invoked function expression (IIFE), return them in an object,and pass that to  macro. Each property of the object is imported as a macro,and the variables in the IIFE are shared between them.</p><p>因为宏是JS函数，而JS函数可以是闭包，所以您甚至可以创建共享状态的宏。一种方法是将它们放入立即调用的函数表达式(LIFE)中，在对象中返回它们，然后将其传递给宏。对象的每个属性都作为宏导入，并且生命周期中的变量在它们之间共享。</p><p> (macro ((lambda () (var x 0) ; visible to all of the macro functions (return (object increment (lambda () (return ((. this atom) (++ x)))) decrement (lambda () (return ((. this atom) (-- x)))) get (lambda () (return ((. this atom) x))))))))(increment)(increment)(increment)(decrement)(get)</p><p>(宏((lambda()(Var X 0)；对所有宏函数(Return(对象增量(lambda()(Return((.。这个原子)(++x)递减(lambda()()(return((.。这个原子)(--x)get(lambda()(return((.。这个原子)x)(increment)(decrement)(get)。</p><p>   The second argument to  macro needs to evaluate to a function, but it can bewhatever, so you can put the macro function in a separate file and do—</p><p>宏的第二个参数需要计算为函数，但它可以是任意的，因此您可以将宏函数放在单独的文件中并执行以下操作-。</p><p>   This means you can publish eslisp macros on  npm. The name prefix eslisp- and keyword  eslisp-macro are recommended.  Some existalready.</p><p>这意味着您可以在NPM上发布eslisp宏。建议使用名称前缀eslisp-和关键字eslisp-宏。有些已经存在了。</p><p>  When running  eslc from the command line, to apply a transformation macro toan eslisp file during compilation, supply the  --transform &lt;macro-name&gt;argument ( -t for short). For example,</p><p>从命令行运行ESLC时，要在编译期间将转换宏应用于eslisp文件，请提供--Transform&lt；宏名称&gt；参数(缩写为-t；)。例如,。</p><p>  uses  eslisp-propertify to convert all atoms containg dots into memberexpressions. The flag can be specified multiple times.</p><p>使用eslisp-Propertify将所有包含点的原子转换为成员表达式。可以多次指定该标志。</p><p>   If you want  eslc in your   $PATH,  npm install --global eslisp. (Youmight need  sudo.) Then  eslc program takes eslisp code as input and outputsJavaScript.</p><p>如果需要在$PATH中使用ESLC，请安装NPM--global eslisp。(您可能需要sudo。)。然后ESLC程序将eslisp代码作为输入输出JavaScript。</p><p> If run interactively without arguments, the compiler loads a  REPL thatyou can type commands into to test them.</p><p>如果在没有参数的情况下交互运行，编译器将加载一个REPL，您可以在该REPL中键入命令以对其进行测试。</p><p>       You can also use eslisp as a module: it exports a function that takes a stringof eslisp code as input and outputs a string of JavaScript, throwing errors ifit sees them.</p><p>您还可以将eslisp用作模块：它导出一个函数，该函数接受一串eslisp代码作为输入，并输出一串JavaScript，如果发现错误，就会抛出错误。</p><p>  In brief: A table of predefined macros is used to turn S-expressions into SpiderMonkey AST, which is fed to  escodegen, which outputs JS.Some of those macros allow defining further macros, which get added to thetable and work from then on like the predefined ones.</p><p>简而言之：使用一个预定义宏表将S表达式转换为SpiderMonkey AST，然后将其提供给escodegen，由escodegen输出JS。其中一些宏允许定义更多宏，这些宏被添加到表中，从那时起就像预定义的宏一样工作。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/anko/eslisp">https://github.com/anko/eslisp</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031253.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3135a88f5c95852430c2739231b50a1f.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031253.html">我们选择Java作为高频交易应用程序</a></div><span class="my_story_list_date">2020-10-26 23:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030931.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b6d2f44664370d45e7761c500cdb97d3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030931.html">对159个国家的17K名开发人员的调查：JavaScript是最受欢迎的语言，有1240万活跃开发人员，紧随其后的是Python，有900万，然后是Java，有820万</a></div><span class="my_story_list_date">2020-10-24 14:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030341.html"><img src="http://img2.diglog.com/img/2020/10/thumb_733063352387ad74429fbef6e0502443.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030341.html">Java版正在搬家</a></div><span class="my_story_list_date">2020-10-22 8:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030251.html"><img src="http://img2.diglog.com/img/2020/10/thumb_54a6207715e32873cfcce2d6c085fa72.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030251.html">使用const/let而不是var可以使Webkit中的JavaScript代码运行速度降低10倍</a></div><span class="my_story_list_date">2020-10-21 12:31</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>