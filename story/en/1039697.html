<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>组织和抽象层 Organizations and Layers of Abstraction</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Organizations and Layers of Abstraction<br/>组织和抽象层 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 05:43:54</div><div class="page_narrow text-break page_content"><p>This post is a reflection on being part of making a maturing infrastructure organization for nearly five years.</p><p>这篇文章反映了成为将近五年的基础架构成熟的一部分。</p><p> When I joined Production Engineering at Shopify, it was barely 30 people. We went for a team dinner around that time and I remember how my manager paid for it with his credit card because points. Now we are at &gt;200 people, and at the last pre-pandemic offsite we had a huge ballroom booked for the dinner. Clearly it wasn’t billed to an individual’s credit card.</p><p> 当我加入Shopify的生产工程部门时，当时只有30人。我们在那段时间去参加团队晚宴，我记得我的经理是如何用他的信用卡付款的，因为积分。现在我们有200多人，在大流行前的最后一个场外，我们预定了一个宽敞的宴会厅来准备晚餐。显然，这并没有从个人的信用卡上计费。</p><p> Through my there years there, I’ve seen how we’ve solved scalability and growth by introducing boundaries and new levels of abstraction.</p><p> 在那的那几年里，我看到了如何通过引入边界和新的抽象级别来解决可伸缩性和增长的问题。</p><p> Now that I’m noticing this pattern at other companies too, I believe that managing layers of abstraction is the key tool to solving scalability problems.</p><p> 现在，我也注意到了其他公司的这种模式，我相信管理抽象层是解决可伸缩性问题的关键工具。</p><p>  As the most of other Ruby on Rails shops, we’ve been running job queues on Redis with the  Resque gem (you might have also worked with Sidekiq which is Resque’s successor). Both of those libraries are built on top of Redis, a key-value database written in C that also provides primitives like List and Hash. As a database, Redis keeps those lists/queues in memory for you, and dumps them to the disk every once in a while if you have persistence enabled.</p><p>  与大多数Ruby on Rails商店一样，我们一直在Redis上使用Resque gem运行作业队列（您可能还与Resque的后继者Sidekiq一起工作）。这两个库都建立在Redis之上，Redis是用C编写的键值数据库，还提供了诸如List和Hash之类的原语。作为数据库，Redis将这些列表/队列保存在内存中，如果启用了持久性，则每隔一段时间将它们转储到磁盘中。</p><p> The way how Resque (or Sidekiq) API is designed, you can grab Redis client by calling  Resque.redis and query that Redis directly for any other operations. This is convenient, and having hundreds of developers at Shopify at that point, it was easy for everyone to start dumping non-jobs data to Redis, thanks to the ease of access to  Resque.redis in the Rails app.</p><p> Resque（或Sidekiq）API的设计方式，您可以通过调用Resque.redis来获取Redis客户端，并直接向Redis查询任何其他操作。这很方便，并且到那时Shopify拥有数百名开发人员，所有人都可以轻松地将非工作数据转储到Redis，这归功于Rails应用程序中对Resque.redis的轻松访问。</p><p> The side effect of this easy-to-use API was that Redis became overloaded not only by the throughput of background jobs, but also by all arbitrary features where people have plugged  Resque.redis to store ephemeral keys like throttles or inventory data.</p><p> 这种易于使用的API的副作用是，Redis不仅因后台作业的吞吐量而超载，而且由于人们插入Resque.redis以存储临时键（例如油门或清单数据）的所有任意功能而变得超载。 </p><p> Lesson #1: easy to access APIs can get harmful, especially when it’s designed for a smaller scale and misused at a larger scale.</p><p>第1课：易于访问的API可能会造成危害，特别是在较小规模的API设计且大规模滥用的情况下。</p><p> We introduced separate Redis instances for all non-jobs features, and for a while  Resque.redis was only used for jobs.</p><p> 我们为所有非作业功能引入了单独的Redis实例，有一段时间，Resque.redis仅用于作业。</p><p>  But because  Resque.redis didn’t go away as a public API (even though its use was verbally discouraged), a new pile of features have developed that were writing to  Resque.redis, mostly because that was a developer habit.</p><p>  但是由于Resque.redis并没有作为公共API消失（即使不鼓励在口头上使用它），因此开发了许多新功能写入Resque.redis，主要是因为这是开发人员的习惯。</p><p> It took us significant amount of efforts to completely remove  Resque.redis as a public accessor (see  shitlist driven development) and move to not exposing Redis clients directly anywhere. Instead of giving Redis access directly, we provide a few Ruby classes that wrap Redis access, like  ActiveJob,  Throttle or  DisposableCounter.</p><p> 我们花费了大量的精力来完全将Resque.redis删除为公共访问器（请参阅shitlist驱动的开发），并采取行动避免直接在任何地方公开Redis客户。我们没有提供直接给Redis访问的权限，而是提供了一些包装Redis访问权限的Ruby类，例如ActiveJob，Throttle或DisposableCounter。</p><p> Lesson #2: it’s going to be much easier to scale a data store when the subset of operations is limited and its clients are not exposed directly to developers.</p><p> 第2课：在操作的子集受到限制且其客户未直接向开发人员了解的情况下，扩展数据存储将变得更加容易。</p><p>  It’s important to say that  Redis is single-threaded, which means that it doesn’t employ more than a single CPU. Its authors recommend scaling by introducing more Redis instances running on other CPUs and making your app somehow shard the data across multiple Redis instances - or by using  Redis Cluster.</p><p>  务必要指出的是，Redis是单线程的，这意味着它使用的CPU不会超过一个。它的作者建议通过引入更多在其他CPU上运行的Redis实例，并使您的应用以某种方式将数据分片到多个Redis实例中（或使用Redis Cluster）来进行扩展。</p><p> Also, the more client connections are open to Redis, the busier will be that single CPU. We started to notice that connection limits and CPU load were coming to be the two biggest bottlenecks in keeping the platform up.</p><p> 而且，更多客户端连接对Redis开放时，最忙的将是单个CPU。我们开始注意到，连接限制和CPU负载将成为保持平台正常运行的两个最大瓶颈。 </p><p> As we  did for the rest of stores like MySQL and memcached, we went with introducing a TCP proxy in front of Redis that would  multiplex client &lt;-&gt; backend connections and reduce the pressure on Redis’ CPU. It’s incredible how much room you can buy for scalability by putting a proxy in front of Redis/MySQL/memcached.</p><p>正如我们对其他商店（例如MySQL和memcached）所做的那样，我们在Redis之前引入了TCP代理，该代理将多路复用客户端＆lt;后端连接并减轻Redis CPU的压力。通过在Redis / MySQL / memcached前​​面放置一个代理，您可以为扩展性购买多少空间，这是令人难以置信的。</p><p>   Now all operations to Redis went through a proxy and every feature like jobs or throttles had its own Redis. But every Redis was still single-threaded, and once we had extra load on jobs or on throttles, that Redis would max out on CPU and some operations would get queued and time out. We had to horizontally scale Redis for each feature.</p><p>   现在，对Redis的所有操作都通过代理进行，并且作业或节流阀等每个功能都有其自己的Redis。但是每个Redis仍然是单线程的，一旦我们在工作或节流阀上增加了额外的负载，该Redis就会在CPU上达到极限，并且某些操作会排队并超时。我们必须为每个功能水平缩放Redis。</p><p> The beauty of having a proxy in front of a database is that you now you can make changes to the backend without having to change clients. Thanks to  Envoy proxy, we’ve been able to swap a single Redis behind the proxy with a pool of multiple Redis instances, and partitioning operations by a key.</p><p> 在数据库前放置代理的好处在于，您现在可以更改后端而无需更改客户端。多亏了Envoy代理，我们才能将代理后面的单个Redis与多个Redis实例池进行交换，并可以通过键进行分区操作。</p><p>   We’ve had no abstractions at first and developers used to call the Redis client directly for any operations.  We went away from giving the Redis client to providing primitives that work with Redis underneath.</p><p>   最初我们没有抽象，开发人员习惯于直接调用Redis客户端进行任何操作。我们从提供Redis客户端到提供在下面与Redis一起使用的原语，已经脱离了以往。</p><p> Later we  moved away from making the application connect to Redis directly to giving them something that looks like Redis, but is actually a proxy that forwards commands to multiple Redis instances managed by infrastructure teams. That abstraction will also allow us to swap those backends on the proxy with another database like  KeyDB in we wanted to.</p><p> 后来，我们不再将应用程序直接连接到Redis，而是给它们提供了类似于Redis的东西，但实际上它是将命令转发到基础架构团队管理的多个Redis实例的代理。这种抽象还将使我们能够将代理上的这些后端与我们想要的另一个数据库（例如KeyDB）交换。</p><p> These two steps have abstracted Redis access from the application code and decoupled code from the infrastructure, which was the key to making something scale for both the load and the number of developers.</p><p> 这两个步骤从应用程序代码中提取了Redis访问权限，并从基础架构中分离了代码，这是对负载和开发人员数量进行适当调整的关键。</p><p> You can see the similar pattern with  Vitess, which makes the client believe that it’s speaking to MySQL while it’s actually speaking to a Go service that applies certain logic and forwards those MySQL queries elsewhere. Used by YouTube, Github and Slack, Vitess is gaining its popularity as a way to horizontally scaling database access without increasing the complexity on the client.</p><p> 您可以看到与Vitess类似的模式，这使客户端相信它正在与MySQL对话，而实际上是在与应用某些逻辑并将这些MySQL查询转发到其他地方的Go服务对话。 Vitess已被YouTube，Github和Slack所使用，作为一种在不增加客户端复杂性的情况下水平扩展数据库访问的方式而受到欢迎。 </p><p> I believe that the increasing amount of abstractions is the reasonable price to pay for scalability.  It works the other way around too: if some parts of your stack are abstracted and some are not, those that are not abstracted will be the first to become a scalability bottleneck.</p><p>我相信，越来越多的抽象是为可伸缩性付出的合理代价。 它也以另一种方式起作用：如果堆栈的某些部分是抽象的，而某些部分不是抽象的，则那些未抽象的部分将首先成为可伸缩性瓶颈。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://kirshatrov.com/2020/11/15/org-layers-of-abstraction/">http://kirshatrov.com/2020/11/15/org-layers-of-abstraction/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/组织/">#组织</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/layers/">#layers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/redis/">#redis</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>