<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>监测前体的TRNGS的健康 Monitoring the Health of Precursor’s TRNGs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Monitoring the Health of Precursor’s TRNGs<br/>监测前体的TRNGS的健康 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-15 02:39:06</div><div class="page_narrow text-break page_content"><p>This post is an abridged version of a  longer-form narrative on implementing health monitoring for Precursor/Betrusted’s TRNGs. It’s the first of a series of two posts; the second, on implementing a CSPRNG conditioner for the TRNG, will go up later.</p><p>这篇文章是关于前体/德堡TRNG的健康监测的更长形式叙事的销请。这是两个帖子的第一个;第二，关于为TRNG实施CSPRNG调节器，将在以后上升。</p><p>  Online health monitors are simple statistical tests that give users an indication of the quality of the entropy being produced. On-line health tests are like a tachometer on an engine: they give an indication of overall health, and can detect when something fails spectacularly; but they can’t tell you if an engine is designed correctly. Thus, they are complimentary to longer-running, rigorous diagnostic tests. We cover some of these tests  at our wiki, plus we have a CI bench which generates gigabytes of raw entropy, over runtimes measured in months, that is run through a series of proofing tools, such as the Dieharder test suite and the NIST STS test suite.</p><p>  在线健康监视器是简单的统计测试，使用户能够指示正在生产的熵的质量。在线健康测试就像发动机上的转速表：它们会呈现整体健康状况，并可以检测某些东西何时闻名;但是他们不能告诉你发动机是否正确设计。因此，它们是互惠互动，严谨的诊断测试。我们涵盖了我们的维基上的一些测试，加上我们有一个CI替补脚，它产生了巨大的原始熵，在数月中测量的运行时间，这是一系列打样工具，如Dieharder测试套件和NIST STS测试套房。</p><p> It’s important that the health monitoring happens before any conditioning or mixing of the raw data happens, and significantly, there is no one-size-fits-all health monitor for a TRNG: it’s even advised by the ( NIST SP 800-90B sec 4.4) specification to have tests that are tailored to the noise source.</p><p> 重要的是，在原始数据发生的任何调理或混合之前，都会发生健康监测，并且显着地，没有一个人的健康监视器对于TRNG：它甚至建议（NIST SP 800-90B SEC 4.4规范要具有对噪声源量身定制的测试。</p><p>  The first thing I do before doing any changes is some book research. As my graduate advisor,  Tom Knight, used to say, “Did you know you could save a whole afternoon in the library by spending two weeks at the lab bench?”</p><p>  我在做任何更改之前的第一件事是一些书籍研究。作为我的研究生顾问，古骑士，曾经说过，“你知道你可以通过在实验室长凳上支出两个星期的图书馆在图书馆中拯救整个下午吗？”</p><p> NIST SP 800-90B section 4.4 specifies some health tests. The NIST spec seems to be fairly well regarded, so I’ll use this as a starting point for our tests. The tests come with the caveat that they only detect catastrophic failures in the TRNGs; they are no substitute for a very detailed, long-run statistical analysis of the TRNG outputs at the design phase (which we have already done). NIST recommends two tests: a repetition count test, and an adaptive proportion test.</p><p> NIST SP 800-90B第4.4节规定了一些健康测试。 NIST规范似乎相当好，所以我将用它作为测试的起点。该测试具有警告，即他们只检测TRNGS中的灾难性失败;它们不替代对设计阶段的TRNG产出的非常详细，长期的统计分析（我们已经完成了）。 NIST建议进行两次测试：重复计数测试和自适应比例测试。</p><p>         OK, so now we know the tests. What do these even  mean in the context of our TRNGs?</p><p>         好的，所以现在我们知道测试。在我们的TRNGS的背景下，这些甚至是什么意思？</p><p>  Our Ring Oscillator architecture consists of 33 independent ring oscillators that operate in two phases. In the first phase, the rings oscillate independently of each other to collect phase noise; the state of each ring is XOR’d into a state bit through snapshots taken at regular intervals. In a second phase, they are merged into a single large ring oscillator, where they then have to reach a consensus. A single bit is taken from the consensus oscillator, and progressively shifted into the state of the ring oscillator.</p><p>  我们的环形振荡器架构由33个独立环形振荡器组成，可分两看。在第一阶段中，环振荡地彼此独立地收集相位噪声;每个环的状态通过定期拍摄的快照进入状态位。在第二阶段，它们被合并到单个大环振荡器中，然后它们必须达到共识。从共识振荡器拍摄单个比特，并逐渐移动到环形振荡器的状态。 </p><p>  Above is a simplified “two bit” version of the generator, where instead of 33 oscillators we have 3, and instead of 32 bits of entropy we get 2. The red arrow is the flow of entropy in the first phase, and the green arrow is the flow of entropy in the second phase. The two phases are repeated N+1 bit times (33 times in the full implementation, 3 times in the simplified diagram above).</p><p>上面是一个简化的“两位”版本的发电机，而不是33个振荡器我们有3个，而不是32位我们得到2.红色箭头是第一阶段的熵流，而绿色箭头是熵的流动是第二阶段的熵流。两阶段重复n + 1位次数（在完整实施的33次，上图中的简化图中的3次）。</p><p>  Random phase accumulated in the smaller ring oscillators due to the accumulation of phase noise during a “dwell” phase that can be set by software (nominally 1000 ns)</p><p>  由于在可以由软件设定的“停留”阶段，累积相位噪声的较小环振荡器中累积的随机相位（名义上1000ns）</p><p> Decision noise associated with the sampling jitter of the smaller ring oscillators with an initial sampling flip-flop. Note that the ring oscillators operate at a higher frequency (~300-500MHz) than the sampling rate of the flip flops (100 MHz).</p><p> 与较小环振荡器的采样抖动相关联的决策噪声，具有初始采样触发器。请注意，环形振荡器以比触发器（100MHz）的采样率更高的频率（〜300-500MHz）操作。</p><p> Global phase accumulated during the consensus process of the larger ring oscillator. The time to achieve consensus is set by a “delay” parameter that is set by software (nominally 40ns)</p><p> 全局阶段在较大环振荡器的共识过程中累积。实现共识的时间由软件设置的“延迟”参数设置（名义上是40ns）</p><p> Cross-element mixing through the continuous shifting of bits to the right, and further XOR’ing of phase</p><p> 通过对右侧的连续移位的交叉元件混合，以及相位的进一步xor</p><p> The global phase consensus and cross-element mixing is quite important because ring oscillators have a tendency to couple and phase-lock due to crosstalk side-channels on both signal and power. In this architecture, each ring’s local noise conditions, including its crosstalk, is applied across each of the 32 output bits; and each ring’s oscillation is “reset” with an arbitrary starting value between each cross-element phase.</p><p> 全局阶段共识和交叉元件混合非常重要，因为环振荡器由于信号和功率上的串扰侧通道而具有耦合和相位锁的趋势。在这种架构中，每个环的局部噪声条件（包括其串扰）应用于32个输出位中的每一个;每个环的振荡都是“复位”，每个交叉元素阶段之间具有任意起始值。</p><p> A higher rate of aggregate entropy is achieved by running four instances of the core described above in parallel, and XOR’ing their result together. In addition, the actual delay/dwell parameters are dynamically adjusted at run-time by picking some of the generated entropy and adding it to the base dwell/delay parameters.</p><p> 通过在并行描述上述核心的四个实例，将它们的结果一起运行，实现了更高的聚集熵率。此外，通过挑选一些生成的熵并将其添加到基本停留/延迟参数，在运行时动态调整实际延迟/停留参数。 </p><p> Thus, when looking at this architecture and comparing it against the NIST spec, the question is, how do we apply the Repetition Count test and the Adaptive Proportion tests? The Repetition Count test is probably not sensitive enough to apply on the 32-bit aggregate output. It’s probably best to apply the Repetition Count and Adaptive Proportion test a bit upstream of the final generated number, at the sampled output of the ring oscillators, just to confirm that no constituent ring oscillator is “stuck” for any reason. However, the amount of logic resources consumed by adding this must be considered, since we have (33 * 4) = 132 separate oscillators to consider. Thus, for practical reasons, it’s only feasible to instrument one output from each of the four cores that is indicative of the health of the entire bank of oscillators.</p><p>于是，在看这个架构并将其与NIST规范相比，问题是，我们如何应用重复计数测试和自适应比例测试？重复计数测试可能不足以应用于32位聚合输出。在环形振荡器的采样输出，最佳地应用重复计数和自适应比例测试的重复计数和自适应比例测试，只是为了确认没有任何构成环振荡器是任何原因的“卡住”。但是，必须考虑添加这一点的逻辑资源的量，因为我们有（33 * 4）= 132个单独的振荡器来考虑。因此，出于实际原因，它对于从四个核心的每个核心仪器仪器的输出仅是可行的，该输出指示整个振荡器的整个振荡器的健康状况。</p><p> Picking the right spot to instrument is tricky. The “large” ring oscillator is actually low-quality entropy, because it has a period of about 30MHz but is oversampled at 100MHz. Thus the majority of the entropy is contributed from the repeated undersampling of the “small” rings. The final sampling point chosen is the output of the sampling register after it’s “soaked up” enough entropy from the combination of a small ring and a large ring to result in a useful measurement.</p><p> 选择正确的仪器是棘手的。 “大”环形振荡器实际上是低质量的熵，因为它的时间约为30MHz，但在100MHz上过采样。因此，大多数熵是从“小”环的重复欠采样中的贡献。所选择的最终采样点是从小环和大环的组合“浸泡”足够的熵之后的采样寄存器的输出，以导致有用的测量。</p><p>  Originally, I had tried looking at the “large” oscillator only to try to find something more “raw”, under the hypothesis that we would be more likely to catch problems in the system at a less refined stage; the problem is that it was so “raw” that all we caught was problems. However, we do use this tap as a “true negative” test, to ensure that the health tests are capable of flagging an entropy source that is less than perfect.</p><p>  最初，我试图看看“大”振荡器，只试图找到更多“RAW”，在假设下，我们更有可能在系统中捕获不太精致的阶段的问题;问题是，它是如此“生”，我们所捕获的只是问题。但是，我们确实使用此抽头作为“真正的否定”测试，以确保健康测试能够标记熵源，该熵源小于完美。</p><p> I’m also going to introduce an extra test that’s inspired by the Runs Test in the STS suite, that I call “MiniRuns”. This test records the frequency of continuous runs of bits: 0/1, 00/11, 000/111, 0000/1111, etc. This test will offer more insight into the dominant projected failure mode of the ring oscillator, namely, it oscillating as a perfectly synchronized square wave — a condition that neither of the recommended NIST tests are capable of capturing. However, if the oscillator becomes too deterministic, we should see a shift in the distribution of run lengths out of the MiniRuns test.</p><p> 我还将推出一个额外的测试，它受到STS套件的运行测试的启发，我称之为“MINIRUN”。该测试记录了连续运行的频率：0/1,00/11,000/111,111,0000 / 1111等。该测试将提供更多地洞察环形振荡器的主导投影失效模式，即它振荡作为一个完美同步的方波 - 一种推荐的NIST测试能够捕获的条件。但是，如果振荡器也变得过于确定性，我们应该看到在MiniRuns测试中的运行长度分布的转变。</p><p>  The avalanche generator consists of two avalanche diodes biased from a shared power supply, sampled by a pair of op-amps with a slight bit of gain; see our page on its  theory of operation for details on the physics and electronic design. Here, we focus on its system integration. The outputs of each of the op-amps are sampled with a 12-bit ADC at a rate of ~1MSPS, and XOR’d together. As this sampling rate is close to the effective noise bandwidth of the diodes, we reduce the sampling rate by repeatedly shifting-by-5 and XOR’ing the results a number of times that can be set by software, nominally, 32 times into a 32-bit holding register, which forms the final entropy output. This 32x oversampling reduces the rate of the system to 31.25kHz.</p><p>  雪崩发电机由两台雪崩二极管组成，由共用电源偏置，由一对OP-AMPS采样，具有轻微的增益;有关物理和电子设计的详细信息，请参阅其运行理论的页面。在这里，我们专注于其系统集成。每个运算放大器的输出以12位ADC以〜1msps的速率进行采样，并在一起XOR。由于这种采样率接近二极管的有效噪声带宽，我们通过反复转换 -  5和XOR的结果来降低采样率，并且可以通过软件，名义上，32次可以设置的次数。 32位保持寄存器，形成最终的熵输出。该32倍过采样降低了系统的速率至31.25kHz。</p><p>   The avalanche properties of two individual diodes. These are considered to be high-quality properties derived from the amplification of true thermal noise.</p><p>   两个单独二极管的雪崩特性。这些被认为是从真正热噪声的放大来源的高质量特性。</p><p>   Note that the two diodes do share a bias supply, so there is an opportunity for some cross-correlation from supply noise, but we have not seen this in practice.</p><p>   请注意，两个二极管确实共享偏置电源，因此有机会与电源噪音的一些互相关，但我们在实践中没有看到这一点。 </p><p> Because we are oversampling the avalanche waveform and folding it onto itself, what we are typically measuring is the projected slope of the avalanche waveform plus the noise of the ADC. Significantly, the SNR of the Xilinx 7-series “12-bit” ADC integrated into our FPGA is 60dB. This means we actually have only 10 “good” bits, implying that the bottom two bits are typically too noisy to be used for signal measurements. The XADC primitive compensates for this noise by offering automatic averaging over 16 samples; we turn this off when sampling the avalanche noise generators, because we actually *want* this noise, but turn it on for all the other duties of the XADC.</p><p>因为我们将雪崩波形和将其折叠起来，我们通常测量的是雪崩波形的预计斜率加上ADC的噪声。值得注意的是，Xilinx 7系列“12位”ADC集成到我们的FPGA中的SNR为60dB。这意味着我们实际上只有10个“良好”位，暗示底部两位通常太吵以用于信号测量。 XADC原始通过提供超过16个样本的自动平均来补偿这种噪声;当采样雪崩噪声发生器时，我们会关闭这一点，因为我们实际上*想要*这种噪音，而是为了Xadc的所有其他职责来打开它。</p><p>  It’s also important to consider the nature of sampling this analog waveform with an ADC. The actual waveform itself can have a DC offset, or some total amplitude variation, so naturally the LSBs will be dense in entropy, while the MSBs may be virtually constant. By focusing on the bottom 5 bits out of 12 with the 5-bit sliding window, we are effectively ignoring the top 7 bits. What does this do to the effective waveform? It’s a bit easier to show graphically:</p><p>  考虑使用ADC采样此模拟波形的性质也很重要。实际波形本身可以具有DC偏移，或一些总幅度变化，因此自然地LSB将在熵中密集，而MSB可以是几乎恒定的。通过使用5位滑动窗口聚焦在12个中的底部5位，我们有效地忽略了前7位。这对有效波形做了什么？以图形方式显示它有点易于：</p><p>   If we were to only consider 11 bits out of the 12, we effectively take half the graph and “wrap it over itself”, as shown below:</p><p>   如果我们只考虑在12中只考虑11位，我们有效地花了一半的图形，并将“包装自身”，如下所示：</p><p>      And so forth. By the time we are down to just considering 5 bits, we’ve now taken the effective DC offset and amplitude variations and turned them into just another random variable that helps add to the entropy pool. Now take two of these, XOR them together, and add in the effective noise of the ADC itself, and you’ve arrived at the starting point for the ADC entropy pool.</p><p>      等等。当我们遵循的时间考虑到5位，我们现在拍摄了有效的DC偏移和幅度变化，并将它们转换为另一个随机变量，有助于添加到熵池。现在将其中的两个中有两个，XOR它们在一起，并在ADC本身的有效噪声中添加，并且您已到达ADC熵池的起点。</p><p> In terms of on-line entropy tests, it probably makes the most sense to apply the Repetition Count test and the Adaptive Proportion tests to the bottom 5 bits of the raw ADC feed from each avalanche diode (as opposed to the full 12-bit output of the ADC). We don’t expect to hit “perfect entropy” with the raw ADC feed, but these tests should be able to at least isolate situations where e.g. the bias voltage goes too low and the avalanche effect ceases to work.</p><p> 就在线熵测试而言，将重复计数测试和自适应比例测试应用于从每个雪崩二极管（与完整的12位输出相反的原始ADC进料的底部5位，它可能是最有意义的ADC）。我们不希望使用原始ADC饲料击中“完美熵”，但这些测试应该能够至少隔离例如例如时的情况。偏置电压过低，雪崩效果停止工作。</p><p> In addition to these tests, it’s probably good to have an “absolute excursion” test, where the min/max of the raw avalanche waveforms are recorded over a time window, to detect a diode that is flat-lining due to aging effects, or a bias voltage source that is otherwise malfunctioning. This test is not suitable for catching if an attacker is maliciously injecting a deterministic waveform on top of the avalanche diodes, but is well-suited as a basic health check of the TRNG’s core mechanisms under nominal environmental conditions.</p><p> 除了这些测试之外，拥有“绝对偏移”测试可能很好，其中原始雪崩波形的Min / Max在时间窗口中记录，以检测由于老化效果导致的平坦衬里的二极管，或者偏置电压源，否则是故障的。如果攻击者在雪崩二极管顶部恶意地注入确定性波形，但如果攻击者在雪崩二极管的顶部的确定性波形中，则该测试不适合捕获，但是在标称环境条件下是TRNG的核心机制的基本健康检查。</p><p>  After installing the tooling necessary to build a  Precursor/Betrusted SoC, I started writing the code.</p><p>  安装在构建前体/漂亮的Soc所需的工具后，我开始编写代码。 </p><p>  Think about what I’m trying to do. See the first section of this article.</p><p>想想我想做什么。请参阅本文的第一部分。</p><p>  Wrap the smaller modules into a simulation framework that shakes most of the skeletons out of the closet.</p><p>  将较小的模块包装成模拟框架，使大部分骷髅从壁橱中弹出。</p><p> Repeat 1-3, working your way up the chain until you arrive at your full solution.</p><p> 重复1-3，向上工作，直到您到达完整的解决方案。</p><p>    Continuously integrate, if possible, either by re-running your sim against every repo change or better yet recompiling and re-running your test on actual hardware.</p><p>    如果可能的话，通过重新运行SIM，通过重新运行您的SIM，或者更好地重新编译并重新运行您在实际硬件上的测试。</p><p> The key to this loop is the simulation. The better your simulation, the better your outcome. By “better simulation”, I mean, the less assumptions and approximations made in the test bench. For example, one could simulate a module by hooking it up to a hand-rolled set of Verilog vectors that exercises a couple read and write cycles and verifies nothing explodes; or, one could simulate a module by hooking it up to a fully simulated CPU, complete with power-on reset and multiple clock phases, and using a Rust-based framework to exercise the same reads and writes. The two test benches ostensibly achieve the same outcome, but the latter checks much more of the hairy corner cases.</p><p> 此循环的关键是模拟。你的模拟越好，结果越好。通过“更好的仿真”，我的意思是，测试台中的假设和近似值越少。例如，可以通过将其挂钩到一卷的Verilog向量集中模拟模块，该卷滚动读取和写入周期并验证任何爆炸;或者，可以通过将其挂钩到完全模拟的CPU的模块来模拟模块，使用电源复位和多个时钟阶段，并使用基于RUST的框架来锻炼相同的读取和写入。这两个测试台表面上达到了相同的结果，但后者检查了更多的毛茸茸的角落案例。</p><p> For Betrusted/Precursor, we developed a comprehensive simulation framework that achieves the latter scenario as much as possible. We simulate a full, gate-level Vex CPU, running a Rust-built BIOS, employing as many of the Xilinx-provided hardware models as we can for things like the PLL and global power-on reset.</p><p> 对于薄饼/前体，我们开发了一个综合性仿真框架，尽可能地实现了后一种情况。我们模拟了一个完整的门级vex cpu，运行了一个生锈构建的BIOS，就像许多Xilinx提供的硬件模型一样，我们可以为PLL和全球上电复位的东西。</p><p>  This is the point in the cooking show at which we put the turkey into an oven, say something to the effect of “…and in about five hours, your bird should be done…” yet somehow magically pull out a finished turkey for carving and presentation by the time we finish the sentence.</p><p>  这是我们把火鸡放入烤箱的烹饪秀的重点，对“......和大约五个小时内的效果来说，你应该完成的东西......”但是，以某种方式神奇地拉出一个成品的土耳其雕刻和雕刻当我们完成句子时呈现。 </p><p> So: after a bunch more driver-writing and breaking out signals to gain visibility into the various metrics and failure modes, we can see the on-line health tests in action.</p><p>所以：经过更多的驾驶员写作和破坏信号以获得各种度量和故障模式的可见性，我们可以看到在线运行中的操作。</p><p>  Above is an example of the trng test data output on Precursor, set where `RO 0` is connected to the “large” oscillator that runs too slowly (serving as a “true negative” test), and the others are connected to the final output tap for the test (serving as a “true positive”). In the output, you can see the four ring oscillators (numbered 0-3) with the frequency of each of five run lengths printed out. `RO 0` has a significant depression in the count for the run-length 1 bin, compared to the other oscillators (440 vs 515, 540, and 508).</p><p>  以上是前体上的TRNG测试数据输出的示例，设置为`RO 0`连接到“大”振荡器的位置，该振荡器运行过于缓慢（用作“真正的否定”测试），其他人连接到最终状态用于测试的输出水龙头（用作“真正的正面”）。在输出中，您可以看到四个环形振荡器（编号为0-3），其中每个五个运行长度中的每一个都打印出来。与其他振荡器相比，“RO 0”在跑步长1箱的计数中具有显着的抑郁症（440 VS 515,540和508）。</p><p> One final detail is implementing an automated decision mechanism for the MiniRuns test. Since the MiniRuns test wasn’t from the NIST suite, I couldn’t simply read a manual to derive a threshold. Instead, I had to consult with my perlfriend, who also happens to be an expert at statistics, to help me understand what I was doing and derive a model that could help me set limits. Originally, she suggested a chi-square test. This would be great, but the math for it would be too complicated for an automated quick power-on test. So, we downgraded the test to simple max/min thresholds on the counts for each “bin” of runs. I used a similar criteria to that suggested in the NIST test, that is, 𝛂 = 2^-20, to set the thresholds, and baked that into the hardware code. Here’s a  link to the original spreadsheet that she used to compute both the chi-square and the final, simpler min/max tests. One future upgrade could be to implement some recurring process in Xous that collects updated results from the MiniRuns test and does the more sophisticated chi-square tests on it; but that’s definitely a “one for the road” feature.</p><p> 最后一个细节正在实施miniruns测试的自动决策机制。由于MiniRuns测试不是来自NIST套件，因此我无法简单地阅读手动来导出阈值。相反，我不得不咨询我的Perlfriend，他也恰好成为统计数据的专家，帮助我了解我正在做的事情并导出一个可以帮助我设定限制的模型。最初，她建议了Chi-Square测试。这将是很大的，但是对于自动的快速上电测试来说，数学将太复杂。因此，我们将测试降级为运行的每个“垃圾箱”的计数上的简单最大/最小阈值。我对NIST测试中建议的类似标准，即α= 2 ^ -20，设置阈值，并将其烘焙到硬件代码中。这是一种与原始电子表格的链接，她用于计算Chi-Square和最终，最简单的最小/最大测试。一个未来的升级可以是在XOUS中实施一些重复过程，从Miniruns测试中收集更新的结果，并对其中更复杂的Chi-Square测试;但这绝对是“道路的一个”功能。</p><p>  The upshot is that we now have all the mandatory NIST tests plus one each “tailored” tests for each type of TRNG. Adding the MiniRuns automated criteria increased utilization to 56.5% — raising the total space used by the tests from about 2% of the FPGA to a bit over 4%. The MiniRuns test is expensive because it is currently configured to check for runs ranging from length 1 to 5 over 4 banks of ring oscillators — so that’s 5 * 4 * (registers/run ~30?) = ~600 registers just for the core logic, not counting the status readout or config inputs.</p><p>  结果是我们现在拥有所有强制性NIST测试以及每种类型的TRNG每次“量身定制”测试。添加Miniruns自动化标准将利用率提高到56.5％ - 将测试使用的总空间从约2％的FPGA从约2％提高到4％以上。 MiniRuns测试是昂贵的，因为它目前配置为在长度1到5个环振荡器中检查运行范围 - 所以这是5 * 4 *（寄存器/运行〜30？）=〜600寄存器仅用于核心逻辑，不计算状态读数或配置输入。</p><p> Later on, if I start running out of space, cutting back on some of the instrumentation or the depth of the runs measured might be a reasonable thing to do. I would suggest disposing of some of the less effective NIST tests entirely in favor of the home-grown tests, but in the end I may have to kick out the more effective supplemental tests. The reality is that it’s much easier to defend keeping inferior-but-spec-compliant tests in the system, rather than opting for superior tests at the expense of the specification tests.</p><p> 后来，如果我开始空间耗尽，削减一些仪器或测量的运行的深度可能是合理的事情。我建议处理完全有利于家庭成长的测试的一些效率测试，但最终我可能必须踢出更有效的补充测试。现实是，捍卫在系统中保持较低的符合规范的测试是更容易的，而不是以规范测试为代价为卓越的测试进行卓越的测试。</p><p> That’s it for part 1. If you’re super-eager to read more, you can read the full  wiki entry on data conditioning for the TRNG at the  Precursor/Betrusted documentation wiki. Or, you can just wait until I get around to chopping the page down to size and repackaging it into a more bite-side blog entry.</p><p> 这是第1部分。如果您超级渴望阅读更多，您可以阅读前体/ Betrusted文档Wiki的TRNG数据调节的完整Wiki条目。或者，您只需等到我绕过将页面砍下到尺寸并将其重新包装成一个更吻合的博客条目。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.bunniestudios.com/blog/?p=6097">https://www.bunniestudios.com/blog/?p=6097</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/前体/">#前体</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/health/">#health</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>