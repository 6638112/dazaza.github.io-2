<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>LTE上行链路的解调Demodulation of the LTE uplink</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Demodulation of the LTE uplink<br/>LTE上行链路的解调</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 16:33:21</div><div class="page_narrow text-break page_content"><p>I have been playing with some LTE recordings to brush up my knowledge, since it isn’t a protocol I’m very familiar with. I’m specially interested in understanding the structure and properties of all the pilot signals. Textbooks and documentation are great, but nothing beats getting your hands dirty with some IQ recordings to be sure you understand all the details.</p><p>我一直在播放一些LTE录音来复习我的知识，因为这不是一个我非常熟悉的协议。我对理解所有导频信号的结构和特性特别感兴趣。教科书和文档都很棒，但没有什么比用一些IQ记录弄脏你的手更能确保你理解所有细节了。</p><p> To have something to work with, I have done some recordings of my phone by holding it near a USRP B205mini without an antenna. While recording, I was playing a Youtube video or browsing the web, to have some traffic. A waterfall of one of the recordings can be seen below. In this post we will be looking at how to demodulate the highlighted section, which contains 7 ms of PUSCH (physical uplink shared channel) occupying 15 resource blocks, together with the corresponding DMRS (demodulation reference signal) symbols. The post assumes some familiarity with OFDM, but doesn’t require any previous knowledge of LTE, so it can be useful to people interested in a hands-on introduction to LTE.</p><p>为了解决这个问题，我把手机放在一个没有天线的USRP B205mini旁边，录制了一些视频。录制时，我在播放Youtube视频或浏览网页，以获得一些流量。下面可以看到其中一段录音的瀑布。在本文中，我们将了解如何解调突出显示的部分，该部分包含占用15个资源块的7 ms PUSCH（物理上行链路共享信道）以及相应的DMRS（解调参考信号）符号。这篇文章假设读者对OFDM有一定的了解，但不需要了解LTE的任何知识，因此对于那些对LTE有兴趣的人来说，这篇文章非常有用。</p><p>   The recording can be found  here. It is the  SigMF file  LTE_uplink_847MHz_2022-01-30_30720ksps. This contains 886 ms of data recorded at 30.72 Msps, and has much more than what we will be looking at here (in fact there is a PRACH right at the beginning). In this recording, my phone happens to be using Band 20. Specifically, a 10 MHz channel at 847 MHz. The demodulation is done in  a Jupyter notebook using NumPy.</p><p>录音可以在这里找到。它是SigMF文件LTE_上行链路_847MHz_2022-01-30_30720ksps。它包含以30.72毫秒每秒记录的886毫秒数据，比我们将在这里看到的要多得多（事实上，一开始就有一个PRACH）。在这段录音中，我的手机恰好使用了20波段。具体来说，是847 MHz的10 MHz通道。解调是在使用NumPy的Jupyter笔记本中完成的。</p><p> The documentation that describes how the LTE signals are modulated is  3GPP TS 36.211. I find this document a bit hard to read, because it often treats many special cases at once (which depend on a good number of parameters), and it isn’t obvious which is the case that is used most of the time. There are other online references that make a good job at summarizing the material, and have some very helpful diagrams. For instance,  this one from Keysight. However, these are often not detailed enough, so a read through the 3GPP documents is needed.</p><p>描述LTE信号如何被调制的文档是3GPP TS 36.211。我觉得这篇文档有点难读，因为它经常一次处理许多特殊情况（这取决于大量参数），并且不清楚大多数情况下使用的是哪种情况。还有其他一些在线参考资料可以很好地总结材料，并且有一些非常有用的图表。例如，这是来自Keysight的。然而，这些通常不够详细，因此需要通读3GPP文档。</p><p>  Except in some special cases, the LTE signal is an OFDM modulation using a carrier spacing of 15 kHz. LTE is intended to work with a 30.72 Msps sampling clock for a 20 MHz bandwidth signal, so the timing parameters are defined in terms of samples at this clock rate. The useful time of a symbol is ~66.666 us (the reciprocal of 15 kHz), or 2048 samples (so that the OFDM DFTs can be implemented as an FFT of this size, which is a power of two).</p><p>除某些特殊情况外，LTE信号是使用15khz载波间隔的OFDM调制。LTE打算使用20 MHz带宽信号的30.72 Msps采样时钟，因此根据该时钟速率下的采样定义定时参数。一个符号的有效时间约为66.666 us（15 kHz的倒数），或2048个样本（因此，OFDM DFT可以实现为这种大小的FFT，即二的幂）。</p><p> The basic unit of duration is a slot, which lasts for 0.5 ms and consists of 7 OFDM symbols. The first symbol uses a cyclic prefix of 160 samples (~5.2 us), while the remaining symbols use a cyclic prefix of 144 samples (~4.7 us). We can check that the math adds up, because 7*2048 + 160 + 6*144 gives 15360 samples, which is exactly 0.5 ms. In time-frequency, allocations are done in terms of resource blocks, which have a time duration of one slot and a frequency span of 12 subcarriers.</p><p>持续时间的基本单位是一个时隙，持续时间为0.5毫秒，由7个OFDM符号组成。第一个符号使用160个样本（约5.2 us）的循环前缀，而其余符号使用144个样本（约4.7 us）的循环前缀。我们可以检查计算结果，因为7*2048+160+6*144给出15360个样本，正好是0.5毫秒。在时频方面，分配是根据资源块完成的，资源块的持续时间为一个时隙，频率跨度为12个子载波。</p><p> The main channel in the uplink is the PUSCH (physical uplink shared channel), which is used to send data from the user equipment (phone) to the eNodeB (base station). In a slot of PUSCH, the first 3 symbols carry data using QPSK, 16QAM or 64QAM, the symbol in the middle is the DMRS (demodulation reference signal), which is a pilot signal for synchronization and equalization, and the last 3 symbols also carry data.</p><p>上行链路中的主信道是PUSCH（物理上行链路共享信道），用于将数据从用户设备（电话）发送到eNodeB（基站）。在PUSCH的一个时隙中，前3个符号使用QPSK、16QAM或64 QAM来携带数据，中间的符号是DMRS（解调参考信号），它是用于同步和均衡的导频信号，最后3个符号也携带数据。</p><p> The data symbols of the PUSCH use SC-FDMA, while the DMRS uses regular OFDMA. The SC-FDMA modulation is often explained in terms of a precoder. If we have \(M\) continguous subcarriers allocated to our UE (user equipment), in OFDMA we would take \(M\) QPSK (or QAM) symbols and compute their inverse Fourier transform to obtain the corresponding time-domain OFDM symbol (taking into account that the OFDM subcarriers not allocated to our UE should be zero). This is often done by zero-padding the \(M\) symbols to obtain a vector of 2048 elements (zero-padding is done according to which \(M\) subcarriers are allocated), and then performing the 2048-point inverse DFT. In SC-FDMA, before doing this step, we use a precoder, which is simply an \(M\)-point DFT. This means that we compute the \(M\)-point DFT of our QPSK (or QAM) symbols, and then use that output to produce an OFDM symbol using an inverse Fourier transform in the same way as with OFDMA. The receiver will use an \(M\)-point inverse DFT to undo the action of the precoder.</p><p>PUSCH的数据符号使用SC-FDMA，而DMRS使用常规OFDMA。SC-FDMA调制通常用预编码器来解释。如果我们将\（M \）个连续子载波分配给我们的UE（用户设备），在OFDMA中，我们将采用\（M \）个QPSK（或QAM）符号，并计算它们的逆傅里叶变换以获得相应的时域OFDM符号（考虑到未分配给我们的UE的OFDM子载波应为零）。这通常是通过对\（M\）符号进行零填充来获得2048个元素的向量（根据分配的\（M\）子载波进行零填充），然后执行2048点逆DFT。在SC-FDMA中，在执行此步骤之前，我们使用一个预编码器，它只是一个\（M \）点DFT。这意味着我们计算QPSK（或QAM）符号的\（M \）点DFT，然后使用该输出以与OFDMA相同的方式使用逆傅里叶变换生成OFDM符号。接收器将使用\（M \）点反向DFT撤销预编码器的操作。</p><p> An alternative way to explain SC-FDMA which I think makes more clear what is going on and why it is useful is the following. An SC-FDMA symbol consists essentially of \(M\) time-domain QPSK (or QAM) symbols being transmitted one after each other as a PAM waveform, at a rate of \(15 M\) kbaud. The pulse shape used for these symbols is such that they occupy the spectrum of the OFDMA subcarriers allocated to our UE, and, more importantly, such that these symbols are orthogonal to symbols transmitted by other UEs, which have other disjoint sets of OFDMA subcarriers allocated. As any OFDM symbol, an SC-FDMA symbol has a cyclic prefix, which can be used for channel equalization in the usual way. This cyclic prefix consists of the last few of our \(M\) QPSK (or QAM) time-domain symbols being sent before the first ones.</p><p>下面是解释SC-FDMA的另一种方式，我认为它更清楚地说明了发生了什么以及它为什么有用。SC-FDMA符号基本上由\（M \）个时域QPSK（或QAM）符号组成，它们以\（15 M \）kbaud的速率作为PAM波形一个接一个地传输。用于这些符号的脉冲形状使得它们占据分配给我们的UE的OFDMA子载波的频谱，并且更重要的是，使得这些符号与由其他UE发送的符号正交，这些UE具有分配的其他不相交的OFDMA子载波集。与任何OFDM符号一样，SC-FDMA符号具有循环前缀，可以以通常的方式用于信道均衡。这个循环前缀由在第一个符号之前发送的最后几个（M）QPSK（或QAM）时域符号组成。</p><p> The advantage of SC-FDMA in comparison with OFDMA is that its PAPR (peak-to-average power ratio) is much smaller. The reason is that SC-FDMA is essentially a time-domain PAM waveform, so its PAPR is moderate. On the other hand, plain OFDM has huge peaks when many subcarriers happen to align in phase by chance. For this reason, SC-FDMA is used in the LTE uplink, since it is easier to amplify it efficiently, which is important for battery-powered UEs, as they have energy constraints.</p><p>与OFDMA相比，SC-FDMA的优势在于其PAPR（峰均功率比）小得多。原因是SC-FDMA本质上是一种时域PAM波形，因此其PAPR适中。另一方面，当许多子载波碰巧在相位上对齐时，普通OFDM会出现巨大的峰值。因此，在LTE上行链路中使用SC-FDMA，因为它更容易有效地放大，这对于电池供电的UE很重要，因为它们有能量限制。</p><p> With the appropriate time-frequency resolution, it is possible to tell the SC-FDMA PUSCH symbols and the OFDMA DMRS symbols apart due to their different texture in the waterfall. The figure below shows an example of this, using cursors to delineate the 7 symbols in the first slot. The symbol in the middle is the DMRS, and it is possible to see that its texture is more regular, almost looking like a pattern. This contrast can also be seen in the next slots.</p><p>通过适当的时频分辨率，可以区分SC-FDMA PUSCH符号和OFDMA DMRS符号，因为它们在瀑布中的纹理不同。下图显示了一个示例，使用光标描绘第一个插槽中的7个符号。中间的符号是DMRS，可以看到它的纹理更规则，看起来几乎像一个图案。这种对比也可以在接下来的时段中看到。</p><p>   Usually, the first step in demodulating OFDM is to achieve some coarse time synchronization with the symbols. Otherwise the FFTs we do might take up the last half of one symbol and the first half of the next symbol, and the result will be garbage.</p><p>通常，解调OFDM的第一步是实现与符号的粗时间同步。否则，我们所做的FFT可能会占用一个符号的后半部分和下一个符号的前半部分，结果将是垃圾。</p><p> Here I’m assuming that we already have coarse frequency synchronization, to within a fraction of the subcarrier spacing. If not, we will also need to find a way to estimate the carrier frequency offset. In our case this is not really needed, because at 847 MHz the frequency error will be a few kHz for devices having references accurate to a few ppm. The LTE subcarrier spacing of 15 kHz will typically be much larger than this.</p><p>这里我假设我们已经有了粗略的频率同步，在子载波间隔的一小部分之内。如果没有，我们还需要找到一种方法来估计载波频率偏移。在我们的例子中，这并不是真正需要的，因为在847 MHz下，对于参考值精确到几ppm的设备，频率误差将为几kHz。15 kHz的LTE子载波间隔通常会比这个大得多。</p><p> However, we need to take into account that the subcarriers of the LTE uplink are laid so that there is no subcarrier at DC. The central subcarriers are at +7.5 kHz and at -7.5 kHz. More formally, the uplink subcarriers are at \((n+1/2)\Delta f\) for integer \(n\), where \(\Delta f = 15\) kHz is the subcarrier spacing. The usual demodulation of OFDM using an FFT has a subcarrier at DC, or in other terms, assumes that the subcarriers are at \(n \Delta f\) for integer \(n\). Therefore, to account for this difference we shift up our IQ recording by 7.5 kHz so that the subcarrier at -7.5 kHz is now placed at DC. Equivalently, we assume that our signal has a carrier frequency offset of -7.5 kHz to begin with.</p><p>然而，我们需要考虑LTE上行链路的子载波的铺设，以便在DC处没有子载波。中心副载波为+7.5 kHz和-7.5 kHz。更正式地说，对于整数\（n \），上行链路子载波处于\（（n+1/2）\Delta f\），其中\（\Delta f=15 \）kHz是子载波间隔。通常使用FFT的OFDM解调在DC处有一个子载波，或者换句话说，假设子载波在整数处为\（n \δf \）。因此，为了解释这种差异，我们将我们的IQ记录向上移动了7.5 kHz，因此-7.5 kHz的子载波现在被置于DC。等效地，我们假设我们的信号从-7.5 kHz的载波频率偏移开始。</p><p> Since we are analysing by hand a recording of the uplink, we need to do things somewhat differently from what an eNodeB receiving the uplink would do. In fact, UEs are responsible for their transmissions so that they arrive to the eNodeB at the correct moment, taking into account propagation delay. In this sense, the LTE uplink is synchronized in terms of the downlink. The eNodeB doesn’t need to perform coarse time synchronization. The symbols must already arrive synchronized to the eNodeB. Because of this, the LTE uplink doesn’t really have structures intended for coarse symbol synchronization, so we need to be a bit creative.</p><p>由于我们正在手动分析上行链路的记录，我们需要做一些与接收上行链路的eNodeB有所不同的事情。事实上，考虑到传播延迟，ue负责它们的传输，以便它们在正确的时刻到达eNodeB。在这个意义上，LTE上行链路在下行链路方面是同步的。eNodeB不需要执行粗略的时间同步。符号必须已经同步到eNodeB。正因为如此，LTE上行链路实际上没有用于粗符号同步的结构，所以我们需要有点创造性。</p><p> In this case coarse synchronization is easy, because we are attempting to synchronize to the beginning of a PUSCH transmission. There is no signal immediately before, so we could power-detect this beginning. An alternative idea is to use the fact that the DMRS symbols can be seen in the waterfall, so by looking at it we can have a rough idea of when the DMRS symbols start, which gives us the timing for all the other symbols. In fact, that is how I have aligned the markers in the figure above. This technique can be used even in the middle of a PUSCH transmission.</p><p>在这种情况下，粗同步很容易，因为我们试图同步到PUSCH传输的开始。之前没有信号，所以我们可以检测到这个开始。另一种方法是利用瀑布中可以看到DMRS符号的事实，因此通过观察它，我们可以大致了解DMRS符号何时开始，这为我们提供了所有其他符号的时间。事实上，这就是我在上图中对齐标记的方式。这种技术甚至可以在PUSCH传输的中间使用。</p><p> However, the technique I will use is what I call a poor-man’s  Schmidl &amp; Cox algorithm. The Schmidl &amp; Cox algorithm requires specially crafted “preamble” OFDM symbols such that, in the time domain, the first half of the useful symbol is equal to the second half of the useful symbol. This property is achieved by only using even subcarriers, since all even subcarriers have this periodic property. When we have such a “preamble” symbol, we can compute the correlation\[C(t) = \int_0^{T_u/2} x(t + s) \overline{x(t + T_u/2 + s)}\,ds,\]where \(T_u\) denotes the useful symbol length and \(x(t)\) is the received waveform. This correlation will peak when \(t\) is equal to the start of the useful symbol of each of these “preamble” symbols. The way it works is by attempting to correlate the first half of a symbol with its second half, which gives a large value when these two halves are equal.</p><p>然而，我将使用的技术是我所说的穷人的施密德尔&amp；考克斯算法。施密德尔和；Cox算法需要精心编制的“前导”OFDM符号，以便在时域中，有用符号的前半部分等于有用符号的后半部分。由于所有偶数子载波都具有此周期性，因此仅使用偶数子载波即可实现此特性。当我们有这样一个“前导”符号时，我们可以计算相关\[C（t）=\int_0^{t_/2}x（t+s）\overline{x（t+t_/2+s）}，ds，\]，其中\（t_\）表示有用的符号长度，\（x（t）\）表示接收到的波形。当\（t\）等于每个“前导”符号的有用符号的开始时，这种相关性将达到峰值。它的工作方式是尝试将符号的前半部分与其后半部分相关联，当这两部分相等时，这会给出一个很大的值。</p><p> If our OFDM waveform doesn’t have these periodic “preamble” symbols, we can still use the same idea by relying on the cyclic prefix. This doesn’t work so well regarding sensitivity, because the cyclic prefix is usually much shorter than \(T_u/2)\), but can still be made to work with good SNR. The correlation we compute is\[\widetilde{C}(t) = \int_0^{T_{cp}} x(t+s)\overline{x(t+T_u+s)}\,ds,\]where \(T_{cp}\) denotes the length of the cyclic prefix. Since the cyclic prefix repeats exactly what happens at the end of the symbol, this correlation will peak when \(t\) is equal to the start of the cyclic prefix of each symbol.</p><p>如果我们的OFDM波形没有这些周期性的“前导”符号，我们仍然可以通过依赖循环前缀来使用相同的想法。这在灵敏度方面效果不太好，因为循环前缀通常比\（t_/2）\）短得多，但仍然可以在良好的信噪比下工作。我们计算的相关性是\[\widetilde{C}（t）=\int_0^{t_{cp}}x（t+s）\overline{x（t+t_u+s）}，ds，\]，其中\（t_{cp}）表示循环前缀的长度。由于循环前缀完全重复符号末尾发生的事情，因此当\（t\）等于每个符号循环前缀的开头时，这种相关性将达到峰值。</p><p> The result of applying this technique to our PUSCH transmission can be seen below. The waveform \(x(t)\) starts somewhat before the first PUSCH symbol, so that we don’t miss its beginning.</p><p>将此技术应用于我们的PUSCH传输的结果如下所示。波形\（x（t）\）在第一个PUSCH符号之前开始，所以我们不会错过它的开始。</p><p>  We can actually see three different amplitude levels in the figure. At the beginning the amplitude is very small, because both \(x(t)\) and \(x(t+T_u)\) are before the start of the PUSCH transmission, so they only contain noise of small amplitude. Then we can see a small increase in amplitude, which happens when \(x(t+T_u)\) reaches the first symbol but \(x(t)\) is still small amplitude noise. Finally, \(x(t)\) reaches the first symbol and we can see the peak produced by the cyclic prefix. The amplitude of the correlation is now larger even when there is no peak, since both \(x(t)\) and \(x(t+T_u)\) contain pieces of the OFDM signal.</p><p>我们实际上可以在图中看到三种不同的振幅水平。开始时，振幅非常小，因为\（x（t）\）和\（x（t+t_）\）都在脉冲传输开始之前，所以它们只包含小振幅的噪声。然后我们可以看到振幅的小幅度增加，当\（x（t+t_）\）到达第一个符号，但\（x（t）\）仍然是小振幅噪声时，就会发生这种情况。最后，\（x（t）\）到达第一个符号，我们可以看到循环前缀产生的峰值。由于\（x（t）\）和\（x（t+tu）\）都包含OFDM信号的片段，因此即使没有峰值，相关性的振幅现在也更大。</p><p> The peaks we see in the figure correspond to the start of each cyclic prefix, so we can use them to count symbols. With some effort we could even be able to tell that the first out of every 7 symbols is slightly longer (due to its slightly longer cyclic prefix).</p><p>我们在图中看到的峰值对应于每个循环前缀的开头，因此我们可以使用它们来计数符号。通过一些努力，我们甚至可以分辨出每7个符号中的第一个符号稍长（因为它的循环前缀稍长）。</p><p> The figure above has been obtained with no carrier frequency error, so in some sense we’re still using the textbook’s trick of “assume that the signal is synchronized”. What happens when we have some carrier frequency error? If we replace \(x(t)\) by \(e^{2\pi i f t}x(t)\), we see that \(\widetilde{C}(t)\) simply gets multiplied by a factor \(e^{-2\pi i f T_u}\). Thus, we still get correlation peaks of the same amplitude, but they are no longer real and positive. Their phase indicates the frequency error (modulo the carrier frequency separation \(1/T_u\)), so as a bonus, this poor man’s Schmidl &amp; Cox can also be used to achieve a rather precise frequency synchronization (the same is true of the usual Schmidl &amp; Cox algorithm).</p><p>上面的数字是在没有载波频率误差的情况下得到的，所以在某种意义上，我们仍然在使用教科书中的“假设信号是同步的”技巧。当我们有载波频率错误时会发生什么？如果我们将\（x（t）\）替换为\（e^{2\pi i f t}x（t）\），我们会看到\（\widetilde{C}（t）\）简单地乘以一个因子\（e^{-2\pi i f t}）。因此，我们仍然可以得到相同振幅的相关峰，但它们不再是真实的正相关峰。它们的相位表示频率误差（以载波频率间隔（1/T_）为模），所以作为奖励，这个可怜的人的施密德&amp；Cox还可以用于实现相当精确的频率同步（通常的Schmidl&amp；Cox算法也是如此）。</p><p> The next figure shows how the correlation looks like in the presence of a frequency error of 2 kHz. The phase of the correlation peaks now should have an angle of -48 degrees, but we can still easily detect the peaks if we take the complex modulus of the correlation.</p><p>下图显示了在存在2 kHz频率误差的情况下相关性的样子。现在，相关峰的相位应该是-48度角，但如果我们采用相关的复模，我们仍然可以很容易地检测到峰值。</p><p>  A detailed look at the first correlation peak (coming back to the case of no frequency error), shows that it is not easy to locate the vertex of the peak precisely, due to the noise. Therefore, the synchronization that we can achieve with this method is not very accurate. Perhaps we will have an error of a few microseconds. The same problem happens with the regular Schmidl &amp; Cox algorithm.</p><p>对第一个相关峰的详细观察（回到没有频率误差的情况）表明，由于噪声，精确定位峰值顶点并不容易。因此，我们用这种方法实现的同步不是很精确。也许我们会有几微秒的误差。同样的问题也发生在普通的Schmidl&amp；考克斯算法。</p><p>   From the coarse time synchronization obtained with the poor man’s Schmidl &amp; Cox, we can now attempt to demodulate the SC-FDMA PUSCH symbols. Demodulation of an SC-FDMA symbol starts in the same way as with any regular OFDM symbol. We take the 2048 samples that we believe are best aligned with the useful time of our symbol, and perform a 2048-point FFT. Now we need to select the \(M\) FFT bins corresponding to the subcarriers occupied by the SC-FDMA symbol and perform an \(M\)-point IFFT. This will give us the \(M\) QPSK (or QAM) symbols carrier in this SC-FDMA symbol.</p><p>从穷人的施密德尔&amp；考克斯，我们现在可以尝试解调SC-FDMA PUSCH符号。SC-FDMA符号的解调以与任何常规OFDM符号相同的方式开始。我们采集2048个样本，我们认为这些样本与符号的有效时间最吻合，并执行2048点FFT。现在我们需要选择对应于SC-FDMA符号占用的子载波的\（M \）FFT单元，并执行\（M \）点IFFT。这将为我们提供SC-FDMA符号中的\（M \）QPSK（或QAM）符号载体。</p><p> This all works well when the symbol is perfectly synchronized. However, it doesn’t when there are synchronization errors, so it pays off to invest some time in thinking how these errors affect an SC-FDMA symbol. Roughly speaking, it’s the other way around compared to regular OFDM, due to the extra DFT.</p><p>当符号完全同步时，这一切都很好。然而，当存在同步错误时，情况并非如此，因此花一些时间思考这些错误如何影响SC-FDMA符号是值得的。粗略地说，由于额外的DFT，与常规OFDM相比，情况正好相反。</p><p> First off, a remark is that it’s impossible to judge synchronization before performing the \(M\)-point IFFT that undoes the precoder action. In fact, if we think about what the precoder does, it takes \(M\) symbols from a QPSK (or QAM) constellation (we can assume that the symbol are randomly chosen), and computes their DFT. The result is close to \(M\) samples taken from uncorrelated complex Gaussian distributions. In this sense, the precoder output looks like AWGN. The figure below demonstrates this by showing the consellation of our first PUSCH symbol before performing the \(M\)-point IFFT. The symbol is in fact perfectly synchronized, but it’s impossible to tell from this plot.</p><p>首先，需要说明的是，在执行撤销预编码操作的\（M \）点IFFT之前，不可能判断同步。事实上，如果我们考虑预编码器的功能，它会从QPSK（或QAM）星座中提取\（M \）个符号（我们可以假设符号是随机选择的），并计算它们的DFT。结果接近于从不相关的复杂高斯分布中提取的\（M \）个样本。从这个意义上讲，预编码器输出看起来像AWGN。下图显示了在执行\（M \）点IFFT之前，我们的第一个PUSCH符号的组合。事实上，这个符号是完全同步的，但从这个情节中不可能分辨出来。</p><p>  The “hard” way to see how synchronization errors affect SC-FDMA uses the definition in terms of the precoder, and goes like this. First assume we have an STO (symbol time offset). After demodulation of the OFDM symbol, we get a phase vs. frequency slope. Now we perform the \(M\)-point IFFT. This transforms the phase vs. frequency slope into a circular shift of its output. In general, the amount that is shifted will not be an integer number of samples. This means that each QPSK (or QAM) symbol gets mixed with one of its neighbours (actually with all of them, due to how a fractional delay works). This is ISI (inter-symbol interference), and we get a constellation that looks like garbage.</p><p>了解同步错误如何影响SC-FDMA的“硬”方法使用了预编码器的定义，如下所示。首先假设我们有一个STO（符号时间偏移）。在解调OFDM符号后，我们得到了相位与频率的斜率。现在我们执行\（M \）点IFFT。这将相位与频率的斜率转换为其输出的循环移位。通常，移位量不是整数个采样数。这意味着每个QPSK（或QAM）符号都会与它的一个相邻符号混合（实际上是与所有相邻符号混合，这是由于分数延迟的工作原理）。这是ISI（符号间干扰），我们得到了一个看起来像垃圾的星座。</p><p> On the other hand, assume that we have a CFO (carrier frequency offset). This means that our demodulation FFT is not well aligned with the OFDM subcarriers. If this were a regular OFDM symbol, the contents of neighbouring subcarriers (which carry different QPSK or QAM symbols) would get mixed by the FFT, and we would get ISI. We can understand the CFO as a fractional shift in the frequency domain, that mixes neighbouring carriers. For an SC-FDMA symbol, this shift in the frequency domain almost gets transformed into a modulation in the time domain after doing the \(M\)-point FFT (the “almost” is because the shift is not cyclic). This modulation is a phase vs. time slope in our final QPSK (or QAM) symbols. This is not as bad as having ISI, and moreover we can measure this slope and use it to estimate and correct the CFO.</p><p>另一方面，假设我们有一个CFO（载波频率偏移）。这意味着我们的解调FFT与OFDM子载波没有很好地对齐。如果这是一个常规的OFDM符号，相邻子载波（携带不同的QPSK或QAM符号）的内容将通过FFT混合，我们将得到ISI。我们可以将CFO理解为频域中的分数偏移，即混合相邻载波。对于SC-FDMA符号，在进行\（M \）点FFT后，频域中的这种偏移几乎转化为时域中的调制（“几乎”是因为偏移不是循环的）。这种调制是最终QPSK（或QAM）符号中的相位与时间斜率。这并不像ISI那么糟糕，而且我们可以测量这个斜率，并用它来估计和修正首席财务官。</p><p> I find much easier to arrive at the same conclusions by thinking of SC-FDMA as a time-domain PAM modulation. If we have an STO, then we are going to get ISI unless our STO happens to be close to an integer number of time-domain symbols. Note that the time-domain symbols are rather short, since their duration is \(T_u/M\). In our case, as we will see, the PUSCH signal occupies \(M = 180\) subcarriers, so the time-domain symbol duration is ~0.37 us, or 11.37 samples. If we have a CFO, then the phase of our time domain-symbols PAM symbols changes as we advance in time, so we get a phase vs. time slope from which we can estimate the CFO.</p><p>我发现，将SC-FDMA视为时域PAM调制，更容易得出相同的结论。如果我们有一个STO，那么我们将得到ISI，除非我们的STO恰好接近整数个时域符号。请注意，时域符号相当短，因为它们的持续时间是\（T_/M\）。在我们的例子中，正如我们将看到的，PUSCH信号占用\（M=180\）子载波，因此时域符号持续时间约为0.37 us，或11.37个样本。如果我们有一个CFO，那么时域符号的相位PAM符号会随着时间的推移而变化，因此我们可以得到一个相位与时间的斜率，从中我们可以估计CFO。</p><p> Achieving accurate enough time synchronization by looking at the SC-FDMA PUSCH symbols alone is quite hard. The reason is that while it is easy to ensure that the STO is close to an integer multiple of the time-domain PAM symbol length \(T_u/M\), for otherwise the constellation will have severe ISI and look really bad, it is difficult to ensure that the STO is indeed close to zero, or in other words, that we haven’t slid our synchronization by a few time-domain symbols.</p><p>仅通过查看SC-FDMA PUSCH符号就很难实现足够精确的时间同步。原因是，虽然很容易确保STO接近时域PAM符号长度\（T_/M \）的整数倍，否则星座将有严重的ISI，看起来非常糟糕，但很难确保STO确实接近零，或者换句话说，我们没有通过几个时域符号来滑动我们的同步。</p><p> In fact, here the presence of a cyclic prefix doesn’t help. If we slide the synchronization one symbol backwards, we will take the last time-domain symbol of the cyclic prefix as our first symbol. The constellation will be correct and everything will look great except that the QPSK (or QAM) symbols will be circularly shifted by one place. This will be disastrous when we try to interpret the data. If, on the other hand, we slide the synchronization one symbol forwards, then we are dropping the first time-domain symbol and taking the start of the cyclic prefix of the next OFDM symbol as our last time-domain symbol. What happens depends on whether the cyclic prefix length is close to an integer number of time domain symbols (i.e., whether \(T_{cp}M/T_u\) is close to an integer), and whether the next OFDM symbol is actually a PUSCH symbol using the same subcarriers (as it could be a DMRS symbol, for instance). All this will determine whether this last time-domain symbol will be a perfectly valid QPSK (or QAM) symbol extracted from the next PUSCH symbol, an ISI mixture of two QPSK (or QAM) symbols from the next PUSCH symbol, or just garbage.</p><p>事实上，在这里，循环前缀的存在并没有帮助。如果我们向后滑动同步一个符号，我们将把循环前缀的最后一个时域符号作为第一个符号。星座将是正确的，除了QPSK（或QAM）符号将被循环移位一个位置之外，一切都将看起来很棒。当我们试图解释数据时，这将是灾难性的。另一方面，如果我们向前滑动同步一个符号，那么我们将丢弃第一个时域符号，并将下一个OFDM符号的循环前缀的开头作为最后一个时域符号。发生的情况取决于循环前缀长度是否接近整数个时域符号（即\（T_{cp}M/T_ \）是否接近整数），以及下一个OFDM符号是否实际上是使用相同子载波的PUSCH符号（例如，它可能是DMRS符号）。所有这些都将确定最后一个时域符号是从下一个PUSCH符号提取的完全有效的QPSK（或QAM）符号，是来自下一个PUSCH符号的两个QPSK（或QAM）符号的ISI混合，还是仅仅是垃圾。</p><p> For these reasons, it is advisable to use the DMRS symbols for fine time synchronization. We will do so below. Otherwise, it is not difficult to get a clean QPSK (or QAM) constellation out of the SC-FDMA PUSCH symbols, but the data could be garbled.</p><p>出于这些原因，建议使用DMRS符号进行精细时间同步。我们将在下面这样做。否则，从SC-FDMA PUSCH符号中获得干净的QPSK（或QAM）星座并不困难，但数据可能会被篡改。</p><p> As a demonstration of this discussion on synchronization, the figure below shows the constellation of our first PUSCH symbol when everything is well synchronized. We have also adjusted the amplitude and phase of the signal to get the QPSK symbols in their expected locations.</p><p>作为对同步讨论的演示，下图显示了当所有东西都同步良好时，我们的第一个PUSCH符号的星座。我们还调整了信号的振幅和相位，以使QPSK符号位于其预期位置。</p><p>  The next figures shows what happens when we introduce just one sample (~0.033 us) of time offset. This is very noticeable, as we start to get significant ISI.</p><p>下面的数字显示了当我们只引入一个时间偏移样本（~0.033 us）时会发生什么。这是非常明显的，因为我们开始获得重大的ISI。</p><p>  With just 3 samples (~0.098 us) of time offset the ISI is so severe that the constellation is garbage. Recall that time-domain PAM symbols are 11.37 samples long in our case, so here we are looking at a synchronization error of 26% of a time-domain symbol.</p><p>只有3个样本（~0.098 us）的时间偏移，ISI是如此严重，以至于星座是垃圾。回想一下，在我们的例子中，时域PAM符号的长度是11.37个样本，所以这里我们要看的是时域符号的26%的同步错误。</p><p>  However, if we keep increasing the STO, when we arrive to an offset of 11 samples, which is close to a time-domain PAM symbol, the constellation looks good again. The phase of the constellation has rotated, because the allocation for our subcarriers is not centred at DC, so a time delay also gives us a phase rotation. However, since we do not know the phase of the signal, we can’t use this phase rotation to detect that we’re a time-domain PAM symbol off. This shows clearly that just by looking at the PUSCH symbols we can get a clean QPSK constellation, but not ensure correct time synchronization.</p><p>然而，如果我们继续增加STO，当我们到达11个样本的偏移量，接近时域PAM符号时，星座看起来又好了。星座的相位发生了旋转，因为子载波的分配不以DC为中心，所以延时也会给我们带来相位旋转。然而，由于我们不知道信号的相位，我们不能使用这个相位旋转来检测我们是时域PAM符号关闭。这清楚地表明，仅仅通过查看PUSCH符号，我们就可以得到一个干净的QPSK星座，但不能确保正确的时间同步。</p><p>  Note that in this case a sample is a relatively small fraction of a time-domain PAM symbol (8.8%), so we are able to obtain good synchronization by using a delay which is an integer number of samples. If the PU</p><p>请注意，在这种情况下，样本是时域PAM符号（8.8%）中相对较小的一部分，因此我们可以通过使用样本数为整数的延迟来获得良好的同步。如果PU</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/上行/">#上行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lte/">#lte</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/符号/">#符号</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>