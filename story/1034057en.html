<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>《时间环路软件》(2013)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">《时间环路软件》(2013)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 00:10:03</div><div class="page_narrow text-break page_content"><p>What if it were possible to write software capable of time travel? What if we could write software that was able to retrieve results from a computation solved sometime in the near future? What would this software look like? What problems could be solved?</p><p>如果有可能写出能够进行时间旅行的软件呢？如果我们可以编写能够在不久的将来某个时候从计算中检索结果的软件，会怎么样？这款软件会是什么样子呢？有哪些问题可以解决？</p><p> Time loop logic is a hypothetical system of computation that exploits the  Novikov self-consistency principle. In this system the computer is able to send the result of a computation backwards through time and rely upon the self-consistency principle to force the sent result to be correct. This futuristic concept might seem impossible now but I&#39;d imagine trying to explain nuclear fission to a 3rd century blacksmith would seem equally impossible.</p><p>时间循环逻辑是一种假想的计算系统，它利用了诺维科夫自洽原理。在这个系统中，计算机能够通过时间向后发送计算结果，并依靠自洽原理强制发送的结果是正确的。这个未来主义的概念现在看起来可能是不可能的，但我可以想象，试图向一个3世纪的铁匠解释核裂变似乎也是不可能的。</p><p>  Building on the concept of time loop logic we are able to implement theoretical programming constructs to help better understand the concept of time travel in software. In the following examples we demonstrate what a time loop logic program might look like.</p><p>基于时间循环逻辑的概念，我们能够实现理论编程构造，以帮助更好地理解软件中的时间旅行概念。在下面的例子中，我们演示了时间循环逻辑程序可能是什么样子。</p><p>  In the follow examples we&#39;ll be using the JavaScript programing language. JavaScript provides a single thread of execution for code to run in. The JavaScript virtual machine is constantly running an event loop. Each tick of this event loop represents a single cycle of code execution. Once this cycle is completed the next tick in the event loop will occur. In the popular  Node.js framework  an API is provided to defer the execution of a block of code until the nextTick of the event loop occurs.</p><p>在下面的例子中，我们将使用JavaScript编程语言。JavaScript为代码的运行提供了单一的执行线程。JavaScript虚拟机一直在运行事件循环。此事件循环的每个滴答都代表代码执行的单个周期。一旦这个循环完成，事件循环中的下一个滴答就会出现。在流行的Node.js框架中，提供了一个API来延迟代码块的执行，直到事件循环的nextTick发生。</p><p>        Now let&#39;s imagine that instead of deferring a line of code until the next tick of the event loop we could instead push that code  backwards to the  previous tick of the event loop.</p><p>现在，让我们设想一下，不是将一行代码推迟到事件循环的下一个滴答器，而是将该代码向后推到事件循环的前一个滴答器。</p><p>    The same effect of  process.prevTick can also be achieved using setTimeout with a negative value</p><p>使用带负值的setTimeout也可以达到同样的处理效果。</p><p>  Since all we are doing is logging a simple string to the console, this is a contrived example. However; building on the concept of  process.prevTick we can begin to implement more complex time loop programs.</p><p>因为我们所做的只是将一个简单的字符串记录到控制台，所以这是一个人为的例子。然而，基于进程的概念，我们可以开始实现更复杂的时间循环程序。</p><p>  Let&#39;s assume a simple  brute-force search password cracking scenario. Imagine there is a login function which expects a password. We have access to a very large word dictionary in which our cracking software will sequentially attempt logins using every word in the dictionary as a password until a match is found.</p><p>让我们假设一个简单的暴力搜索密码破解场景。假设有一个需要输入密码的登录函数。我们可以访问一个非常大的单词词典，我们的破解软件将使用词典中的每个单词作为密码顺序尝试登录，直到找到匹配项。</p><p>  Note: It&#39;s important to remember that Novikov&#39;s self-consistency principle guarantees that the sequence of events generating the paradox in the following code has zero probability.</p><p>注意：重要的是要记住，诺维科夫的自洽原理保证了以下代码中产生悖论的事件序列的概率为零。</p><p>    The theoretical application of time-loop logic is endless. Imagine a time-loop based communication protocol. This would mean zero millisecond latency. Imagine gaming, video broadcasting, and file sharing with instantaneous transfer and zero lag. Through exploiting self-consistency we know that data will be sent in the immediate future ( since the data has begun transferring from the source ) and that eventually the transmission will arrive at it&#39;s destination. As long as the data will eventually be received, we are able to send the result back from the future into the immediate present, removing the notion of latency or lag.</p><p>时间循环逻辑在理论上的应用是无穷无尽的。设想一种基于时间循环的通信协议。这将意味着零毫秒延迟。想象一下，游戏、视频广播和文件共享可以实现即时传输和零延迟。通过利用自我一致性，我们知道数据将在不久的将来被发送(因为数据已经开始从源传输)，并且最终传输将到达它的目的地。只要数据最终会被接收到，我们就能够将结果从未来发送回当前，消除了延迟或滞后的概念。</p><p>  How is it actually possible to program a time loop? Based on the self-consistency principle and continuing advancements in quantum entanglement these types of mind-bending constructs are not very far away. It&#39;s very possible we&#39;ll see this type of software actively being developed within the next hundred years.</p><p>实际上，如何才能对时间循环进行编程呢？基于自洽原理和量子纠缠的不断进步，这类令人费解的构造并不遥远。在接下来的一百年里，我们很可能会看到这种类型的软件被积极开发出来。</p><p> Time loop logic was first written about by  Hans Moravec who is best known for his work in robotics and artificial intelligence at Carnegie Mellon University. You can find Hans&#39; original paper from 1991, &#34;Time Travel and Computing&#34;, here:  https://frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html. I recommend reading the entire paper.</p><p>时间循环逻辑最早是由汉斯·莫拉维克(Hans Moravec)撰写的，他因在卡内基梅隆大学(Carnegie Mellon University)从事机器人学和人工智能方面的工作而闻名。你可以找到1991年汉斯的原创论文，《时间旅行与计算》，这里：https://frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html.。我建议你通读整篇文章。</p><p> What we know from  general relativity is that at a quantum level backwards time-travel is mathematically possible in certain solutions containing  closed timelike curves. A closed timelike curve is a  world-line in a  Lorentzian manifold.</p><p>我们从广义相对论中知道的是，在量子水平上，在包含封闭的类时间曲线的某些解中，反向时间旅行在数学上是可能的。闭合类时曲线是洛伦兹流形中的一条世界线。</p><p> Closed timelike curves ( CTCs ) pose a problem for physicists. The existence of CTCs introduces the notion of time travel being possible. If time travel is possible, we have now introduced the notion of  time travel paradoxes which can violate  causality. Since it&#39;s generally accepted that we cannot violate causality in our universe we must be able to explain how closed time-like curves can exist.</p><p>封闭的类时间曲线(CTC)给物理学家带来了一个问题。CTC的存在引入了时间旅行成为可能的概念。如果时间旅行是可能的，我们现在引入了时间旅行悖论的概念，这可能违反因果关系。既然人们普遍认为我们不能违反宇宙中的因果关系，我们就必须能够解释封闭的类时间曲线是如何存在的。</p><p> In his self-consistency principle Novikov asserts that if an event exists that would give rise to a paradox, or to any &#34;change&#34; to the past whatsoever, then the probability of that event is zero. In short, it says that it is impossible to create time travel paradoxes. You can find the original paper here:  http://authors.library.caltech.edu/3737. I recommend starting with reading the  history of the principle.</p><p>在他的自洽原理中，诺维科夫断言，如果存在一个会引起悖论的事件，或者任何改变过去的事件，那么该事件发生的概率为零。简而言之，它说不可能创造时间旅行悖论。你可以在这里找到原文：http://authors.library.caltech.edu/3737.。我建议从阅读这一原则的历史开始。</p><p>  In order for time loop logic to return an answer instantaneously, we  must ensure that the problem will run long enough into the future to  actually calculate the result. If a problem takes sixty seconds to solve, the program must run for at least sixty seconds. Time-loop logic does  not violate causality. We are able to retrieve the answer instantly because we have committed to spending sixty seconds in the future calculating the answer and sending it back.</p><p>为了让时间循环逻辑即时返回答案，我们必须确保问题在未来运行足够长的时间来实际计算结果。如果一个问题需要60秒才能解决，程序必须运行至少60秒。时间循环逻辑并不违反因果关系。我们能够立即检索到答案，因为我们承诺在未来花费60秒计算答案并将其发回。</p><p> This turns debugging time-loop logic into somewhat of an impossibility. Any bugs in a time loop indicate that sometime in the future a problem has occurred.  This event may or may not be related to software.</p><p>这使得调试时间循环逻辑变得有点不可能。时间循环中的任何错误都表示将来某个时候发生了问题。此事件可能与软件有关，也可能与软件无关。</p><p> Imagine a computer that utilized a time loop to brute force crack passwords ( as our code posted above did). I turn the machine on and request it cracks the password. The program doesn&#39;t work. Frustrated, I turn off the machine and complain to my co-worker Josh.</p><p>想象一下，一台利用时间循环暴力破解密码的计算机(就像我们上面发布的代码所做的那样)。我打开机器，要求它破解密码。这个程序不起作用。沮丧之余，我关掉了机器，向同事乔什抱怨。</p><p> Josh turns on the machine and requests the password. The software works instantly cracking the password in under 1ms.</p><p>乔什打开机器，要求提供密码。该软件可以在不到1ms的时间内立即破解密码。</p><p>  Josh replies, &#34;It&#39;s actually quite simple. Using that computer it&#39;s going to take approximately 400 hours to brute force the password. After that 400 hours the CPU must recursively return the cracked password back in time until it reaches right now. I was able to get the answer instantly because I have decided to not turn this computer off for another 399 hours and 59 minutes. Simply put, you turned off the computer too quickly&#34;</p><p>乔希回答说，其实很简单。使用这台计算机，暴力破解密码大约需要400小时。在这400小时之后，CPU必须递归地将破解的密码及时返回，直到它到达现在为止。我能够立即得到答案，因为我已经决定在399小时59分钟内不关闭这台电脑。简而言之，你关机太快了。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://marak.com/blog/2013-05-13-time-loop-software">https://marak.com/blog/2013-05-13-time-loop-software</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/环路/">#环路</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/loop/">#loop</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033937.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b54472e1e5d5e37abc0afc79a98cd2a3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033937.html">我们为软件付费</a></div><span class="my_story_list_date">2020-11-9 6:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033905.html"><img src="http://img2.diglog.com/img/2020/11/thumb_52611f4495398127bbeb7f5795d9169b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033905.html">Clear-Show是一个软件套件，可以在一个网络上操作多个四轴飞行器</a></div><span class="my_story_list_date">2020-11-9 2:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033783.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f4b8833e3b825bd4551ccc396c17bcf7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033783.html">网络攻击者现在还制作他们的勒索软件的Linux版本</a></div><span class="my_story_list_date">2020-11-8 9:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033671.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1c19b0ca7f1369bf80759cbfeb62c237.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033671.html">总部位于蒙特利尔的支付软件公司LightSpeed POS同意以4.4亿美元现金和股票收购总部位于纽约的ShopKeep，后者提供基于云的POS系统</a></div><span class="my_story_list_date">2020-11-7 14:20</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>