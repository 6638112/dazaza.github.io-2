<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>了解静态单一分配表单</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">了解静态单一分配表单</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 07:24:44</div><div class="page_narrow text-break page_content"><p>By  popular demand, I’m doing anotherLLVM post. This time, it’s  single static assignment (or SSA) form, a common featurein the intermediate representations of optimizing compilers.</p><p>应大众要求，我正在做另一篇LLVM帖子。这一次，它是单一静态赋值(或SSA)形式，这是优化编译器的中间表示中的一个常见特性。</p><p> Like  the last one, SSA is atopic in compiler and IR design that I  mostly understand but could benefit from some self-guidededucation on. So here we are.</p><p>就像上一个一样，SSA是编译器和IR设计的主题，我大部分都能理解，但可以从一些自我指导的学习中受益。我们到了。</p><p>  At the highest level, a compiler’s job is singular: to turn some source language  inputinto some machine language  output. Internally, this breaks down into a sequence of clearlydelineated  1 tasks:</p><p>在最高级别，编译器的工作是单一的：将一些源语言输入转换成一些机器语言输出。在内部，这可以分解为一系列清晰描述的任务：</p><p> Validating the AST (e.g., ensuring that all uses of identifiers are consistent with thesource language’s scoping and definition rules)  3</p><p>验证AST(例如，确保标识符的所有使用都与源语言的作用域和定义规则一致)3。</p><p>  Translating the AST into machine code, with all of its complexities (instruction selection,register allocation, frame generation, &amp;c)</p><p>将AST翻译成机器码，及其所有复杂性(指令选择、寄存器分配、帧生成&amp；c)。</p><p> In a  single-pass compiler, (4) is monolithic: machine code is generated as the compiler walksthe AST, with no revisiting of previously generated code. This is extremely fast (in terms ofcompiler performance) in exchange for some a few significant limitations:</p><p>在单遍编译器中，(4)是整体式的：机器代码是在编译器遍历AST时生成的，不会重新访问以前生成的代码。这是非常快的(就编译器性能而言)，但有一些重要的限制：</p><p> Optimization potential: because machine code is generated in a single pass, it can’t be revisitedfor optimizations. Single-pass compilers tend to generate extremely slow and  conservativemachine code.</p><p>优化潜力：因为机器代码是在一次遍历中生成的，所以不能对其进行修改以进行优化。单遍编译器倾向于生成极其缓慢和保守的机器代码。</p><p>  By way of example: the  System V ABI (used by Linux and macOS) defines  a special 128-byte region beyond the current stack pointer ( %rsp) that can be used by leaf functions whose stack frames fit within it. This, in turn, saves a few stack management instructions in the function prologue and epilogue.</p><p>举个例子：system V ABI(由Linux和MacOS使用)在当前堆栈指针(%rsp)之外定义了一个特殊的128字节区域，其堆栈帧可以放入其中的叶函数可以使用该区域。这又节省了函数序言和结束语中的一些堆栈管理指令。</p><p>  A single-pass compiler will struggle to take advantage of this ABI-supplied optimization: it needs to emit a stack slot for each automatic variable as they’re visited, and cannot revisit its function prologue for erasure if all variables fit within the red zone.</p><p>单遍编译器将很难利用ABI提供的这种优化：它需要在每个自动变量被访问时为它们发出一个堆栈槽，并且如果所有变量都位于红色区域内，则不能重新访问其函数序言以进行擦除。</p><p>  Language limitations: single-pass compilers struggle with common language design decisions, likeallowing use of identifiers before their declaration or definition. For example, the followingis valid C++:</p><p>语言限制：单遍编译器很难做出公共语言设计决策，比如允许在声明或定义之前使用标识符。例如，下面的代码是有效的C++：</p><p>  class  Rect  {  public:  int  area ()  {  return  width ()  *  height ();  }  int  width ()  {  return  5 ;  }  int  height ()  {  return  5 ;  }  };</p><p>Class rect{public：int area(){return width()*Height()；}int width(){return 5；}int high(){return 5；}}；</p><p>  C and C++  generally require pre-declaration and/or definition for identifiers, but member function bodies may reference the entire class scope. This will frustrate a single-pass compiler, which expects  Rect::width and  Rect::height to already exist in some symbol lookup table for call generation.</p><p>C和C++通常要求预先声明和/或定义标识符，但成员函数体可以引用整个类范围。这将使单遍编译器感到沮丧，因为它希望RECT：：WIDTH和RECT：：HEIGHT已经存在于某些用于调用生成的符号查找表中。</p><p>    Analyses (or passes) are performed on the IR, refining it according to some optimizationprofile (code size, performance, &amp;c)</p><p>对IR执行分析(或通道)，并根据某些优化配置文件(代码大小、性能&amp；c)对其进行优化。</p><p>  The IR is either translated to machine code  or lowered to  another IR, for further targetspecialization or optimization  4</p><p>该IR或者被翻译成机器代码，或者被降低到另一个IR，用于进一步的目标专门化或优化4。</p><p> So, we want an IR that’s easy to  correctly transform and that’s amenable to optimization. Let’stalk about why IRs that have the  static single assignment property fill that niche.</p><p>因此，我们需要一个易于正确转换且易于优化的IR。让我们深入了解一下为什么具有静态单一赋值属性的IRS会填补这个空白。</p><p>  At its core, the SSA form of any program source program introduces only one new constraint:all variables are assigned (i.e., stored to)  exactly once.</p><p>在其核心，任何程序源程序的SSA形式只引入了一个新的约束：所有变量恰好赋值(即，存储到)一次。</p><p> By way of example: the following (not actually very helpful) function is  not in a valid SSA formwith respect to the  flags variable:</p><p>举个例子：关于FLAGS变量，以下函数(实际上不是非常有用的)不是有效的SSA形式：</p><p> int  helpful_open ( char  * fname )  {  int  flags  =  O_RDWR ;  if  ( ! access ( fname ,  F_OK ))  {  flags  |=  O_CREAT ;  }  int  fd  =  open ( fname ,  flags ,  0644 );  return  fd ; }</p><p>INT HELPUP_OPEN(char*fname){INT FLAGS=O_RDWR；IF(！Access(fname，F_OK)){FLAGS|=O_CREAT；}int fd=open(fname，flag，0644)；返回fd；}。</p><p> Why? Because  flags is stored to twice: once for initialization, and (potentially) again insidethe conditional body.</p><p>为什么？因为标志被存储为两次：一次用于初始化，以及(可能)在条件主体内再次存储。</p><p> As programmers, we could rewrite  helpful_open to only ever store once to each automatic variable:</p><p>作为程序员，我们可以重写HELPUP_OPEN，使每个自动变量只存储一次：</p><p> int  helpful_open ( char  * fname )  {  if  ( ! access ( fname ,  F_OK ))  {  int  flags  =  O_RDWR  |  O_CREAT ;  return  open ( fname ,  flags ,  0644 );  }  else  {  int  flags  =  O_RDWR ;  return  open ( fname ,  flags ,  0644 );  } }</p><p>Int help_open(char*fname){if(！Access(fname，F_OK)){INT标志=O_RDWR|O_CREAT；返回OPEN(fNAME，FLAGS，0644)；}ELSE{INT FLAGS=O_RDWR；RETURN OPEN(fname，FLAGS，0644)；}}。</p><p> But this is clumsy and repetitive: we essentially need to duplicate every chain of uses thatfollow any variable that is stored to more than once. That’s not great for readability,maintainability, or code size.</p><p>但这是笨拙和重复的：我们基本上需要复制任何变量后面的每一条使用链，这些变量被存储到不止一次。这不利于可读性、可维护性或代码大小。</p><p> So, we do what we always do: make the compiler do the hard work for us. Fortunately there existsa transformation from every valid program into an equivalent SSA form, conditioned on two simplerules.</p><p>因此，我们做我们一贯做的事情：让编译器为我们做繁重的工作。幸运的是，在两个简单规则的条件下，存在从每个有效程序到等价SSA形式的转换。</p><p> Rule #1: Whenever we see a store to an already-stored variable, we replace it with a brandnew “version” of that variable.</p><p>规则1：每当我们看到存储到已经存储的变量的存储时，我们就用该变量的全新“版本”替换它。</p><p> Using rule #1 and the example above, we can rewrite  flags using  _N suffixes to indicate versions:</p><p>使用规则#1和上面的示例，我们可以使用_N后缀重写标志以指示版本：</p><p> int  helpful_open ( char  * fname )  {  int  flags_0  =  O_RDWR ;  // Declared up here to avoid dealing with C scopes.  int  flags_1 ;  if  ( ! access ( fname ,  F_OK ))  {  flags_1  =  flags_0  |  O_CREAT ;  }  int  fd  =  open ( fname ,  flags_1 ,  0644 );  return  fd ; }</p><p>INT HELPUP_OPEN(char*fname){INT FLAGS_0=O_RDWR；//在此声明以避免处理C作用域。INT FLAGS_1；如果(！Access(fname，F_OK)){FLAGS_1=FLAGS_0|O_CREAT；}int FD=OPEN(fname，FLAGS_1,0644)；返回FD；}。</p><p>  open(..., flags_1, ...) is incorrect: it unconditionally assigns  O_CREAT, which wasn’t in theoriginal function semantics.</p><p>打开(...，FLAGS_1，...)。是不正确的：它无条件地赋值O_CREATT，这不在原始函数语义中。</p><p>  open(..., flags_0, ...) is  also incorrect: it  never assigns  O_CREAT, and thusis wrong for the same reason.</p><p>打开(...，FLAGS_0，...)。也是不正确的：它从不赋值O_CREAT，出于同样的原因，这也是错误的。</p><p>  Rule #2: Whenever we need to  choose a variable based on control flow, we use the Phi function(φ) to introduce a  new variable based on our choice.</p><p>规则2：每当我们需要根据控制流选择一个变量时，我们都会使用φ函数(φ)根据我们的选择引入一个新的变量。</p><p>  int  helpful_open ( char  * fname )  {  int  flags_0  =  O_RDWR ;  // Declared up here to avoid dealing with C scopes.  int  flags_1 ;  if  ( ! access ( fname ,  F_OK ))  {  flags_1  =  flags_0  |  O_CREAT ;  }  int  flags_2  =  φ ( flags_0 ,  flags_1 );  int  fd  =  open ( fname ,  flags_2 ,  0644 );  return  fd ; }</p><p>INT HELPUP_OPEN(char*fname){INT FLAGS_0=O_RDWR；//在此声明以避免处理C作用域。INT FLAGS_1；如果(！Access(FNAME，F_OK)){FLAGS_1=FLAGS_0|O_CREAT；}INT FLAGS_2=φ(FLAGS_0，FLAGS_1)；INT FD=OPEN(FNAME，FLAGS_2,0644)；返回FD；}。</p><p> Our quandary is resolved:  open  always takes  flags_2, where  flags_2 is a fresh SSA variableproduced applying φ to  flags_0 and  flags_1.</p><p>我们的困境解决了：OPEN始终接受FLAGS_2，其中FLAGS_2是将φ应用于FLAGS_0和FLAGS_1而生成的新的ssa变量。</p><p> Observe, too, that φ is a  symbolic function: compilers that use SSA forms internally do notemit real φ functions in generated code  5. φ exists  solely to reconcile rule #1 with theexistence of control flow.</p><p>还要注意，φ是一个符号函数：在内部使用SSAForm的编译器不会在生成的代码5中调用真正的φ函数。φ的存在只是为了协调规则#1和控制流的存在。</p><p> As such, it’s a little bit silly to talk about SSA forms with C examples (since C and otherhigh-level languages are what we’re translating from in the first place). Let’s dive into howLLVM’s IR actually represents them.</p><p>因此，用C示例谈论SSA表单有点愚蠢(因为我们首先要翻译的是C和其他高级语言)。让我们深入了解LLVM的IR实际上是如何表示它们的。</p><p>  First of all, let’s see what happens when we run our very first  helpful_open through  clangwith no optimizations:</p><p>首先，让我们看看当我们在没有优化的情况下通过clang运行我们的第一个help_open时会发生什么：</p><p> define  dso_local  i32  @helpful_open ( i8 *  %fname )  #0  { entry:  %fname.addr  =  alloca  i8 *,  align  8  %flags  =  alloca  i32 ,  align  4  %fd  =  alloca  i32 ,  align  4  store  i8 *  %fname ,  i8 **  %fname.addr ,  align  8  store  i32  2 ,  i32 *  %flags ,  align  4  %0  =  load  i8 *,  i8 **  %fname.addr ,  align  8  %call  =  call  i32  @access ( i8 *  %0 ,  i32  0 )  #4  %tobool  =  icmp  ne  i32  %call ,  0  br  i1  %tobool ,  label  %if.end ,  label  %if.then if.then:  ; preds = %entry  %1  =  load  i32 ,  i32 *  %flags ,  align  4  %or  =  or  i32  %1 ,  64  store  i32  %or ,  i32 *  %flags ,  align  4  br  label  %if.end if.end:  ; preds = %if.then, %entry  %2  =  load  i8 *,  i8 **  %fname.addr ,  align  8  %3  =  load  i32 ,  i32 *  %flags ,  align  4  %call1  =  call  i32  ( i8 *,  i32 ,  ...)  @open ( i8 *  %2 ,  i32  %3 ,  i32  420 )  store  i32  %call1 ,  i32 *  %fd ,  align  4  %4  =  load  i32 ,  i32 *  %fd ,  align  4  ret  i32  %4 }</p><p>定义DSO_LOCAL I32@HELPUP_OPEN(i8*%fname)#0{entry：%fname.addr=alloca i8*，ALIGN 8%FLAGS=ALLOCAI32，ALIGN 4%FD=ALLOCAI32，ALIGN 4存储I8*%fname，I8**%fname.addr，ALIGN 8存储I32 2，I32*%标志，ALIGN 4%0=加载i8*，i8**%fname.addr，ALIGN 8%CALL=Call I32@Access(i8*%0，I32 0)#4%tobool=ICMP ne I32%呼叫，0 br i1%tobool，标签%if.end，标签%if.Then：；Preds=%Entry%1=加载I32、I32*%标志，对齐4%或=或I32%1，64存储I32%或I32*%标志，对齐4 br标签%if.end if.end：；Preds=%if.Then，%Entry%2=加载I8*，I8**%fname.addr，Align 8%3=加载I32，I32*%标志，Align 4%Call1=Call I32(I8*，I32，...)@OPEN(I8*%2，I32%3，I32 420)存储I32%Call1，I32*%FD，Align 4%4=加载I32，I32*%FD，Align 4 ret I32%4}。</p><p>  So, we call  open with  %3, which comes from…a  load from an  i32* named  %flags?Where’s the φ?</p><p>因此，我们使用来自…的%3调用OPEN。来自名为%FLAGS的I32*的加载？φ在哪里？</p><p> This is something that  consistently slips me up when reading LLVM’s IR: only  values, not memory, are in SSA form. Because we’ve compiled with optimizations disabled,  %flags isjust a stack slot that we can  store into as many times as we please, and that’s  exactly whatLLVM has elected to do above.</p><p>这是我在阅读LLVM的IR时经常犯的错误：只有值，而不是内存，才是SSA形式。因为我们在编译时禁用了优化，所以%FLAGS只是一个堆栈槽，我们可以在其中存储任意多次，这正是LLVM在上面选择做的。</p><p> As such, LLVM’s SSA-based optimizations aren’t all that useful when passed IR that makes directuse of stack slots. We want to  maximize our use of SSA variables, whenever possible, to makefuture optimization passes as effective as possible.</p><p>因此，当传递直接使用堆栈插槽的IR时，LLVM基于SSA的优化没有那么有用。我们希望尽可能最大限度地使用SSA变量，以使未来的优化过程尽可能有效。</p><p>  This file (optimization pass) promotes memory references to be register references. It promotesalloca instructions which only have loads and stores as uses. An alloca is transformed by usingdominator frontiers to place phi nodes, then traversing the function in depth-first order torewrite loads and stores as appropriate. This is just the standard SSA construction algorithm toconstruct “pruned” SSA form.</p><p>此文件(优化过程)将内存引用提升为寄存器引用。它推广只有装入和存储作为用途的分配指令。通过使用主控器边界放置φ节点，然后按深度优先顺序遍历函数以适当地重写加载和存储来转换分配。这只是构建“修剪的”SSA表单的标准SSA构建算法。</p><p>   define  dso_local  i32  @helpful_open ( i8 *  nocapture  readonly  %fname )  local_unnamed_addr  #0  { entry:  %call  =  call  i32  @access ( i8 *  %fname ,  i32  0 )  #4  %tobool.not  =  icmp  eq  i32  %call ,  0  %spec.select  =  select  i1  %tobool.not ,  i32  66 ,  i32  2  %call1  =  call  i32  ( i8 *,  i32 ,  ...)  @open ( i8 *  %fname ,  i32  %spec.select ,  i32  420 )  #4 ,  !dbg  !22  ret  i32  %call1 ,  !dbg  !23 }</p><p>定义DSO_LOCAL I32@HELPUP_OPEN(I8*nocatch readonly%fname)local_unname_addr#0{entry：%call=call I32@access(i8*%fname，I32 0)#4%tobool.not=ICMP eq I32%call，0%spec.select=select i1%tobool.not，I32 66，I32 2%Call1=call I32(i8*，I32，...)@open(i8*%fname，I32%spec.select，I32 420)#4，！dbg！22 ret I32%Call1，！dbg！23}</p><p> Foiled again! Our stack slots are gone thanks to  mem2reg, but LLVM has actually optimized too far: it figured out that our flags value is wholly dependent on the return value of our access call and erased the conditional entirely.</p><p>又被挫败了！多亏了mem2reg，我们的堆栈槽消失了，但是LLVM实际上优化得太多了：它认为我们的标志值完全依赖于我们的访问调用的返回值，并完全删除了条件。</p><p>    The ‘select’ instruction is used to choose one value based on a condition, without IR-level branching.</p><p>“SELECT”指令用于根据条件选择一个值，而不需要IR级分支。</p><p> So we need a better example. Let’s do something that LLVM can’t trivially optimize into a select (or sequence of  selects), like adding an  else if with a function that we’ve onlyprovided the declaration for:</p><p>所以我们需要一个更好的例子。让我们做一些LLVM不能简单地优化为SELECT(或SELECT序列)的事情，比如使用我们只提供了声明的函数添加Else IF：</p><p> size_t  filesize ( char  * ); int  helpful_open ( char  * fname )  {  int  flags  =  O_RDWR ;  if  ( ! access ( fname ,  F_OK ))  {  flags  |=  O_CREAT ;  }  else  if  ( filesize ( fname )  &gt;  0 )  {  flags  |=  O_TRUNC ;  }  int  fd  =  open ( fname ,  flags ,  0644 );  return  fd ; }</p><p>Size_t文件大小(char*)；int help_open(char*fname){int flag=O_RDWR；if(！Access(fname，F_OK)){FLAGS|=O_CREAT；}ELSE IF(fileSize(Fname)&gt；0){FLAGS|=O_TRUNC；}int fd=open(fname，flag，0644)；返回fd；}。</p><p>  define  dso_local  i32  @helpful_open ( i8 *  %fname )  local_unnamed_addr  #0  { entry:  %call  =  call  i32  @access ( i8 *  %fname ,  i32  0 )  #5  %tobool.not  =  icmp  eq  i32  %call ,  0  br  i1  %tobool.not ,  label  %if.end4 ,  label  %if.else if.else:  ; preds = %entry  %call1  =  call  i64  @filesize ( i8 *  %fname )  #5  %cmp.not  =  icmp  eq  i64  %call1 ,  0  %spec.select  =  select  i1  %cmp.not ,  i32  2 ,  i32  514  br  label  %if.end4 if.end4:  ; preds = %if.else, %entry  %flags.0  =  phi  i32  [  66 ,  %entry  ],  [  %spec.select ,  %if.else  ]  %call5  =  call  i32  ( i8 *,  i32 ,  ...)  @open ( i8 *  %fname ,  i32  %flags.0 ,  i32  420 )  #5  ret  i32  %call5 }</p><p>定义DSO_LOCAL I32@HELPUP_OPEN(I8*%fname)LOCAL_UNNAME_ADDR#0{entry：%call=call I32@access(i8*%fname，I32 0)#5%tobool.not=ICMP eq I32%call，0 br i1%tobool.not，Label%if.end4，Label%if.Else if.Else：；Preds=%entry%Call1=call i64@filesize(i8*%fname)#5%cmp.not=ICMP eq i64%Call1，0%spec.select=select i1%cmp.not，i32 2，i32 514 br标签%if.end4 if.end4：；Preds=%if.Else，%Entry%Flags.0=Phi I32[66，%Entry]，[%spec.select，%if.Else]%call5=call I32(i8*，I32，...)@open(i8*%fname，I32%flag s.0，I32 420)#5 ret I32%call5}。</p><p>    LLVM’s  phi is slightly more complicated than the  φ(flags_0, flags_1) that I made up before, butnot by much: it takes a list of pairs (two, in this case), with each pair containing a possiblevalue and that value’s originating basic block (which, by construction, is always a predecessorblock in the context of the φ node).</p><p>Llvm的phi比我之前构造的φ(FLAGS_0，FLAGS_1)稍微复杂一些，但并不复杂：它接受一个配对列表(在本例中是两个)，每个配对包含一个可能的值以及该值的原始基本块(通过构造，它始终是φ节点上下文中的前导块)。</p><p>   The type of the incoming values is specified with the first type field. After this, the ‘phi’instruction takes a list of pairs as arguments, with one pair for each predecessor basic blockof the current block. Only values of first class type may be used as the value arguments to thePHI node. Only labels may be used as the label arguments.</p><p>输入值的类型由第一个类型字段指定。在此之后，‘phi’指令将一组对作为参数，当前块的每个前置基本块都有一个对。只有第一类类型的值可以用作PHI节点的值参数。只有标签可以用作标签参数。</p><p>  There must be no non-phi instructions between the start of a basic block and the PHIinstructions: i.e. PHI instructions must be first in a basic block.</p><p>在基本块的开始和PHI指令之间不能有非PHI指令：即PHI指令必须是基本块中的第一个。</p><p> Observe, too, that LLVM is  still being clever: one of our φ choices is a computed select ( %spec.select), so LLVM  still managed to partially erase the original control flow.</p><p>还可以看到，LLVM仍然很聪明：我们的φ选择之一是计算的SELECT(%spec.select)，因此LLVM仍然设法部分擦除了原始控制流。</p><p> So that’s cool. But there’s a piece of control flow that we’ve conspicuously ignored.</p><p>所以这很酷。但是有一个控制流我们明显忽略了。</p><p>  int  do_math ( int  count ,  int  base )  {  for  ( int  i  =  0 ;  i  &lt;  count ;  i ++ )  {  base  +=  base ;  }  return  base ; }</p><p>Int do_ath(int count，int base){for(int i=0；i&lt；count；i++){base+=base；}return base；}。</p><p>  define  dso_local  i32  @do_math ( i32  %count ,  i32  %base )  local_unnamed_addr  #0  { entry:  %cmp5  =  icmp  sgt  i32  %count ,  0  br  i1  %cmp5 ,  label  %for.body ,  label  %for.cond.cleanup for.cond.cleanup:  ; preds = %for.body, %entry  %base.addr.0.lcssa  =  phi  i32  [  %base ,  %entry  ],  [  %add ,  %for.body  ]  ret  i32  %base.addr.0.lcssa for.body:  ; preds = %entry, %for.body  %i.07  =  phi  i32  [  %inc ,  %for.body  ],  [  0 ,  %entry  ]  %base.addr.06  =  phi  i32  [  %add ,  %for.body  ],  [  %base ,  %entry  ]  %add  =  shl  nsw  i32  %base.addr.06 ,  1  %inc  =  add  nuw  nsw  i32  %i.07 ,  1  %exitcond.not  =  icmp  eq  i32  %inc ,  %count  br  i1  %exitcond.not ,  label  %for.cond.cleanup ,  label  %for.body ,  !llvm.loop  !26 }</p><p>定义DSO_LOCAL I32@do_ath(I32%count，I32%base)LOCAL_UNNAME_ADDR#0{entry：%cmp5=ICMP SGT I32%count，0 br i1%cmp5，LABEL%for.body，LABEL%for.cond.leanup for.cond.leanup：；Preds=%for.body，%entry%base.addr.0.lcssa=phi I32[%base，%entry]，[%add，%for.body]ret I32%base.addr.0.lcssa for.body：；Preds=%entry，%for.body%i.07=phi I32[%Inc，%for.body]，[0，%entry]%base.addr.06=Phi I32[%add，%for.body]，[%base，%entry]%add=shl NSW I32%base.addr.06，1%Inc=添加NUW NSW I32%i.07，1%exitcond.not=ICMP eq I32%Inc，%count br i1%exitcond.not，标签%for.cond.leanup，标签%for.body，！llvm.loop！26}。</p><p>  Because we supply the loop bounds via  count, LLVM has no way to ensure that we  actually enterthe loop body. Consequently, our very first φ selects between the initial  %base and  %add.LLVM’s  phi syntax helpfully tells us that  %base comes from the entry block and  %add fromthe loop, just as we expect. I have no idea why LLVM selected such a hideous name for the resultingvalue ( %base.addr.0.lcssa).</p><p>因为我们通过COUNT提供循环界限，所以LLVM无法确保我们真正进入循环体。因此，我们的第一个φ在初始的%base和%add.LLVM的PHI语法之间进行选择。LLVM的PHI语法很有帮助地告诉我们，%base来自Entry块，%add来自循环，正如我们预期的那样。我不知道为什么LLVM为结果值选择了如此可怕的名称(%base.addr.0.lcssa)。</p><p>  Our index variable is initialized once and then updated with each  for iteration, so it alsoneeds a φ. Our selections here are  %inc (which each body computes from  %i.07) and the  0literal (i.e., our initialization value).</p><p>我们的索引变量初始化一次，然后使用每次for迭代进行更新，因此它还需要一个φ。我们在这里的选择是%Inc(每个主体从%i.07计算)和0文本(即我们的初始化值)。</p><p>  Finally, the heart of our loop body: we need to get  base, where  base is either the initialbase value ( %base) or the value computed as part of the prior loop ( %add). One last φ getsus there.</p><p>最后，循环体的核心：我们需要获取base，其中base是initialbase值(%base)，或者是作为前一个循环的一部分计算的值(%add)。最后一次φ到达那里。</p><p> The rest of the IR is bookkeeping: we need separate SSA variables to compute the addition ( %add),increment ( %inc), and exit check ( %exitcond.not) with each loop iteration.</p><p>IR的其余部分是簿记：我们需要单独的SSA变量来计算每次循环迭代的加法(%add)、增量(%Inc)和退出检查(%exitcond.not)。</p><p>   So now we know what an SSA form  is, and how LLVM represents them  6. Why should we care?</p><p>现在我们知道了什么是SSA表单，以及LLVM如何表示它们6.我们为什么要关心呢？</p><p> As I briefly alluded to early in the post, it comes down to optimization potential: the SSA formsof programs are  particularly suited to a number of effective optimizations.</p><p>正如我在文章前面简要提到的，归根结底是优化潜力：SSA形式的程序特别适合于许多有效的优化。</p><p>   One of the simplest things that an optimizing compiler can do is  remove code that  cannot possiblybe executed. This makes the resulting binary smaller (and usually faster, since more of it canfit in the instruction cache).</p><p>优化编译器可以做的最简单的事情之一就是删除可能无法执行的代码。这使得生成的二进制文件更小(而且通常更快，因为指令高速缓存中可以容纳更多的文件)。</p><p> “Dead” code falls into several categories  7, but a common one is assignments that cannotaffect program behavior, like redundant initialization:</p><p>“死”代码分为几类7，但常见的一类是不能影响程序行为的赋值，如冗余初始化：</p><p> int  main ( void )  {  int  x  =  100 ;  if  ( rand ()  %  2 )  {  x  =  200 ;  }  else  if  ( rand ()  %  2 )  {  x  =  300 ;  }  else  {  x  =  400 ;  }  return  x ; }</p><p>Int main(Void){int x=100；if(rand()%2){x=200；}Else if(rand()%2){x=300；}Else{x=400；}返回x；}。</p><p> Without an SSA form, an optimizing compiler would need to check whether any  use of  x  reachesits original definition ( x = 100). Tedious. In SSA form, the impossibility of that is obvious:</p><p>如果没有SSA表单，优化编译器将需要检查x的任何使用是否达到其原始定义(x=100)。单调乏味。在SSA形式中，这显然是不可能的：</p><p> int  main ( void )  {  int  x_0  =  100 ;  // Just ignore the scoping. Computers aren&#39;t real life.  if  ( rand ()  %  2 )  {  int  x_1  =  200 ;  }  else  if  ( rand ()  %  2 )  {  int  x_2  =  300 ;  }  else  {  int  x_3  =  400 ;  }  return  φ ( x_1 ,  x_2 ,  x_3 ); }</p><p>Int main(Void){int x_0=100；//忽略作用域。计算机不是真实生活。If(rand()%2){int x_1=200；}Else if(rand()%2){int x_2=300；}Else{int x_3=400；}返回φ(x_1，x_2，x_3)；}。</p><p>  define  dso_local  i32  @main ()  local_unnamed_addr  #0  { entry:  %call  =  call  i32  @rand ()  #3  %0  =  and  i32  %call ,  1  %tobool.not  =  icmp  eq  i32  %0 ,  0  br  i1  %tobool.not ,  label  %if.else ,  label  %if.end6 if.else:  ; preds = %entry  %call1  =  call  i32  @rand ()  #3  %1  =  and  i32  %call1 ,  1  %tobool3.not  =  icmp  eq  i32  %1 ,  0  %.  =  select  i1  %tobool3.not ,  i32  400 ,  i32  300  br  label  %if.end6 if.end6:  ; preds = %if.else, %entry  %x.0  =  phi  i32  [  200 ,  %entry  ],  [  %. ,  %if.else  ]  ret  i32  %x.0 }</p><p>定义DSO_LOCAL I32@main()local_unname_addr#0{entry：%call=call I32@rand()#3%0=and I32%call，1%tobool.not=ICMP eq I32%0，0 br i1%tobool.not，Label%if.Else，Label%if.end6 if.Else：；Preds=%Entry%Call1=call I32@rand()#3%1=and I32%Call1，1%tobool3.not=ICMP eq I32%1，0%.。=SELECT i1%tobool3.not，I32 400，I32 300 br标签%if.end6 if.end6：；Preds=%if.Else，%Entry%x.0=Phi I32[200，%Entry]，[%。，%if.Else]ret I32%x.0}</p><p>   Compilers can also optimize a program by  substituting uses of a constant variable for the constantvalue itself. Let’s take a look at another blob of C:</p><p>编译器还可以通过使用常量变量代替常量值本身来优化程序。让我们看一下C的另一个斑点：</p><p> int  some_math ( int  x )  {  int  y  =  7 ;  int  z  =  10 ;  int  a ;  if  ( rand ()  %  2 )  {  a  =  y  +  z ;  }  else  if  ( rand ()  %  2 )  {  a  =  y  +  z ;  }  else  {  a  =  y  -  z ;  }  return  x  +  a ; }</p><p>Int SOME_MATH(Int X){int y=7；int z=10；int a；if(rand()%2){a=y+z；}Else if(rand()%2){a=y+z；}Else{a=y-z；}return x+a；}。</p><p> As humans, we can see that  y and  z are trivially assigned and never modified  8. For the compiler,however, this is a variant of the  reaching definition problem from above: before it canreplace  y and  z with  7 and  10 respectively, it needs to make sure that  y and  z are neverassigned a  different value.</p><p>作为人类，我们可以看到y和z被赋予了微不足道的值，并且从未修改过8。然而，对于编译器来说，这是从上面得到的定义问题的一个变体：在它可以分别用7和10替换y和z之前，它需要确保y和z永远不会被赋予不同的值。</p><p>  int  some_math ( int  x )  {  int  y_0  =  7 ;  int  z_0  =  10 ;  int  a_0 ;  if  ( rand ()  %  2 )  {  int  a_1  =  y_0  +  z_0 ;  }  else  if  ( rand ()  %  2 )  {  int  a_2  =  y_0  +  z_0 ;  }  else  {  int  a_3  =  y_0  -  z_0 ;  }  int  a_4  =  φ ( a_1 ,  a_2 ,  a_3 );  return  x  +  a_4 ; }</p><p>Int SOME_MATH(Int X){int y_0=7；int z_0=10；int a_0；if(rand()%2){int a_1=y_0+z_0；}Else if(rand()%2){int a_2=y_0+z_0；}Else{int a_3=y_0-z_0；}int a_4=φ(a_1，a_2，a_3)；返回x+a_4；}。</p><p> This is virtually identical to our original form, but with one critical difference:the compiler can now see that  every load of  y and  z is the original assignment. In otherwords, they’re all safe to replace!</p><p>这实际上与我们的原始形式相同，但有一个关键的区别：编译器现在可以看到y和z的每一个加载都是原始赋值。换句话说，它们都是可以安全更换的！</p><p> int  some_math ( int  x )  {  int  y  =  7 ;  int  z  =  10 ;  int  a_0 ;  if  ( rand ()  %  2 )  {  int  a_1  =  7  +  10 ;  }  else  if  ( rand ()  %  2 )  {  int  a_2  =  7  +  10 ;  }  else  {  int  a_3  =  7  -  10 ;  }  int  a_4  =  φ ( a_1 ,  a_2 ,  a_3 );  return  x  +  a_4 ; }</p><p>Int SOME_MATH(Int X){int y=7；int z=10；int a_0；if(rand()%2){int a_1=7+10；}Else if(rand()%2){int a_2=7+10；}Else{int a_3=7-10；}int a_4=φ(a_1，a_2，a_3)；return x+a_4；}。</p><p> So we’ve gotten rid of a few potential register operations, which is nice. But here’s the  reallycritical part: we’ve set ourselves up for  several other optimizations:</p><p>所以我们去掉了几个潜在的注册操作，这很好。但这里是真正关键的部分：我们已经为其他几个优化做好了准备：</p><p> Now that we’ve propagated some of our constants, we can do some trivial constant folding:  7 + 10 becomes  17, and soforth.</p><p>现在我们已经传播了一些常量，我们可以做一些微不足道的常量折叠：7+10变成17，以此类推。</p><p>  In SSA form, it’s trivial to observe that only  x and  a_{1..4} can affect the program’s behavior.So we can apply our  dead code elimination from above and delete  y and  z entirely!</p><p>在SSA形式中，观察到只有x和a_{1..4}可以影响程序的行为是微不足道的，所以我们可以应用上面的死代码消除，并完全删除y和z！</p><p> This is the  real magic of an optimizing compiler: each individual optimization is simple andlargely independent, but together they produce a  virtuous cycle that can be repeated untilgains diminish.</p><p>这才是优化编译器的真正魔力：每个单独的优化都很简单，而且很大程度上是独立的，但它们一起产生了一个良性循环，可以重复进行，直到收益减少。</p><p>   Register allocation (alternatively: register scheduling) is less of an optimization  itself, andmore of an unavoidable problem in compiler engineering: it’s fun to pretend to have access to aninfinite number of addressable variables, but the compiler  eventually insists that we boil ouroperations down to a  small, fixed set of CPU registers.</p><p>寄存器分配(或者：寄存器调度)本身并不是一种优化，更多的是编译器工程中不可避免的问题：假装可以访问无限数量的可寻址变量很有趣，但编译器最终坚持将运算归结为一小部分固定的CPU寄存器。</p><p> The constraints and complexities of register allocation vary by architecture: x86 (prior to AMD64)is notoriously starved for registers  9 (only 8 full general purpose registers, of which 6 might beusable within a function’s scope  10), while RISC architectures typically employ larger numbersof registers to compensate for the lack of register-memory operations.</p><p>寄存器分配的约束和复杂性因体系结构而异：众所周知，x86(AMD64之前的版本)需要寄存器9(只有8个完整的通用寄存器，其中6个可能在函数的作用域10内可用)，而RISC体系结构通常使用更多数量的寄存器来弥补缺少寄存器-内存操作。</p><p> Just as above, reductions to SSA form have both indirect and direct advantages for the registerallocator:</p><p>如上所述，减少到SSA形式对寄存器分配器既有间接的好处，也有直接的好处：</p><p> Indirectly: Eliminations of redundant loads and stores reduces the overall  pressure on theregister allocator, allowing it to avoid expensive  spills (i.e., having to temporarily transfer alive register to main memory to accommodate another instruction).</p><p>间接地：消除冗余加载和存储减少了寄存器分配器的总体压力，使其能够避免昂贵的溢出(即，必须临时将有效寄存器转移到主存储器以容纳另一条指令)。</p><p>  Directly: Compilers have historically lowered φs into copies before register allocation,meaning that register allocators traditionally haven’t benefited from the SSA form  itself  11.There is, however, (semi-)recent research on direct application of SSA forms to both linearand coloring allocators  12  13.</p><p>直接：在历史上，编译器在寄存器分配之前将φ降低为副本，这意味着寄存器分配器传统上没有从SSA表本身中受益。然而，(半)最近有关于将SSA表直接应用于线性和着色分配器的(半)近期研究。</p><p>  A concrete example: modern JavaScript engines use JITs toaccelerate program evaluation. These JITs frequently use  linear register allocators for theiracceptable tradeoff between register selection speed (linear, as the name suggests) andacceptable register scheduling. Converting out of SSA form is a timely operation of its own, solinear allocation on the SSA representation  itself is appealing in JITs and other contexts wherecompile time is part of execution time.</p><p>一个具体的例子是：现代JavaScript引擎使用JIT来加速程序评估。这些JIT经常使用线性寄存器分配器，在寄存器选择速度(顾名思义，线性)和可接受的寄存器调度之间进行可接受的折衷。从SSA格式转换出来本身就是一种及时的操作，在编译时间是执行时间一部分的JIT和其他上下文中，对SSA表示本身的线性分配很有吸引力。</p><p>  There are  many things about SSA that I didn’t cover in this post: dominance frontiers, tradeoffsbetween “pruned” and less optimal SSA forms, and feedback mechanisms between the SSA form of aprogram and the compiler’s decision to cease optimizing, among others. Each of these could beits own blog post, and maybe will be in the future!</p><p>关于SSA，我在这篇文章中没有涉及到很多事情：优势边界、“修剪”的SSA形式和不太优化的SSA形式之间的权衡，以及程序的SSA形式和编译器停止优化的决定之间的反馈机制等等。每一篇都可以是自己的博客帖子，也可能是将来的帖子！</p><p> In the sense that each task is conceptually isolated and has well-defined inputs and outputs. Individual compilers have  some flexibility with respect to whether they combine or further split the tasks.  ↩</p><p>从这个意义上说，每个任务在概念上都是独立的，并且都有定义良好的输入和输出。个别编译器在合并或进一步拆分任务方面具有一定的灵活性。-↩。</p><p>  The distinction between an AST and an intermediate representation is hazy: Rust converts their AST to  HIR early in the compilation process, and languages can be designed to have ASTs that are amendable to analyses that would otherwise be best on an IR.  ↩</p><p>AST和中间表示之间的区别很模糊：Rust在编译过程的早期将它们的AST转换为HIR，并且语言可以被设计为具有可修改的AST，以进行分析，否则在IR上是最好的。-↩。</p><p>  This can be broken up into  lexical validation (e.g. use of an undeclared identifier) and  semantic validation (e.g. incorrect initializa</p><p>这可以分为词法验证(例如，使用未声明的标识符)和语义验证(例如，错误的初始化。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.yossarian.net/2020/10/23/Understanding-static-single-assignment-forms">https://blog.yossarian.net/2020/10/23/Understanding-static-single-assignment-forms</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/static/">#static</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>