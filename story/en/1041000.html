<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>水星，在幕后 Mercurial, Behind the Scenes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mercurial, Behind the Scenes<br/>水星，在幕后 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-21 15:55:46</div><div class="page_narrow text-break page_content"><p>Unlike many revision control systems, the concepts upon which Mercurial is built are simple enough that it&#39;s easy to understand how the software really works. Knowing these details certainly isn&#39;t necessary, so it is certainly safe to skip this chapter. However, I think you will get more out of the software with a “ mental model” of what&#39;s going on.</p><p>与许多版本控制系统不同，Mercurial构建于其上的概念非常简单，因此很容易理解该软件的实际工作原理。当然不必知道这些细节，因此跳过本章当然是安全的。但是，我认为您将通过发生的事的“心理模型”从软件中获得更多收益。</p><p> Being able to understand what&#39;s going on behind the scenes gives me confidence that Mercurial has been carefully designed to be both   safe and   efficient. And just as importantly, if it&#39;s easy for me to retain a good idea of what the software is doing when I perform a revision control task, I&#39;m less likely to be surprised by its behavior.</p><p> 能够了解幕后发生的事情使我充满信心，Mercurial的设计经过精心设计，既安全又高效。同样重要的是，如果当我执行修订控制任务时很容易就可以很好地了解软件的功能，那么它的行为就不会让我感到惊讶。</p><p> In this chapter, we&#39;ll initially cover the core concepts behind Mercurial&#39;s design, then continue to discuss some of the interesting details of its implementation.</p><p> 在本章中，我们将首先介绍Mercurial设计背后的核心概念，然后继续讨论其实现的一些有趣细节。</p><p> When Mercurial tracks modifications to a file, it stores	the history of that file in a metadata object called a	  filelog. Each entry in the filelog	contains enough information to reconstruct one revision of the	file that is being tracked. Filelogs are stored as files in	the   directory. A	filelog contains two kinds of information: revision data, and	an index to help Mercurial to find a revision	efficiently.</p><p> 当Mercurial跟踪对文件的修改时，它将该文件的历史记录存储在称为Filelog的元数据对象中。文件日志中的每个条目都包含足够的信息，以重建所跟踪文件的一个修订版本。 Filelogs作为文件存储在目录中。文件日志包含两种信息：修订数据和帮助Mercurial有效查找修订的索引。</p><p> A file that is large, or has a lot of history, has its	filelog stored in separate data	(“  .d” suffix) and index	(“  .i” suffix) files. For	small files without much history, the revision data and index	are combined in a single “  .i”	file. The correspondence between a file in the working	directory and the filelog that tracks its history in the	repository is illustrated in  Figure 4.1, “Relationships between files in working directory and	 filelogs in repository”.</p><p> 一个很大的文件或具有很多历史记录的文件，其日志记录存储在单独的数据（“ .d”后缀）和索引（“ .i”后缀）文件中。对于没有太多历史记录的小文件，修订数据和索引合并在单个“ .i”文件中。图4.1``工作目录中的文件与存储库中的文件日志之间的关系''说明了工作目录中的文件与跟踪存储库中的文件历史的文件日志之间的对应关系。</p><p> Mercurial uses a structure called a	  manifest to collect together information	about the files that it tracks. Each entry in the manifest	contains information about the files present in a single	changeset. An entry records which files are present in the	changeset, the revision of each file, and a few other pieces	of file metadata.</p><p> Mercurial使用一种称为清单的结构来收集有关其跟踪文件的信息。清单中的每个条目都包含有关单个变更集中存在的文件的信息。一个条目记录更改集中存在哪些文件，每个文件的修订版以及其他一些文件元数据。</p><p> The   changelog contains information	about each changeset. Each revision records who committed a	change, the changeset comment, other pieces of	changeset-related information, and the revision of the	manifest to use.</p><p> 变更日志包含有关每个变更集的信息。每个修订记录谁提交了变更，变更集注释，与变更集相关的其他信息以及要使用的清单的修订。 </p><p> Within a changelog, a manifest, or a filelog, each	revision stores a pointer to its immediate parent (or to its	two parents, if it&#39;s a merge revision). As I mentioned above,	there are also relationships between revisions	  across these structures, and they are	hierarchical in nature.</p><p>在修订日志，清单或文件日志中，每个修订版都存储一个指向其直接父级的指针（如果是合并修订版，则指向其两个父级）。如上所述，这些结构的修订版之间也存在关系，并且它们本质上是分层的。</p><p> For every changeset in a repository, there is exactly one	revision stored in the changelog. Each revision of the	changelog contains a pointer to a single revision of the	manifest. A revision of the manifest stores a pointer to a	single revision of each filelog tracked when that changeset	was created. These relationships are illustrated in	 Figure 4.2, “Metadata relationships”.</p><p> 对于存储库中的每个变更集，变更日志中仅存储一个修订。变更日志的每个修订版都包含一个指向清单的单个修订版的指针。清单的修订版存储指向创建变更集时跟踪的每个文件日志的单个修订版的指针。这些关系在图4.2“元数据关系”中进行了说明。</p><p>   As the illustration shows, there is	  not a “ one to one”	relationship between revisions in the changelog, manifest, or	filelog. If a file that	Mercurial tracks hasn&#39;t changed between two changesets, the	entry for that file in the two revisions of the manifest will	point to the same revision of its filelog [ 3].</p><p>   如图所示，变更日志，清单或文件日志中的修订之间没有“一对一”的关系。如果Mercurial跟踪的文件在两个变更集之间没有更改，则清单的两个修订版中该文件的条目将指向其文件日志的相同修订版[3]。</p><p> The underpinnings of changelogs, manifests, and filelogs are provided by a single structure called the   revlog.</p><p> 变更日志，清单和文件日志的基础由称为revlog的单个结构提供。</p><p> The revlog provides efficient storage of revisions using a	  delta mechanism. Instead of storing a	complete copy of a file for each revision, it stores the	changes needed to transform an older revision into the new	revision. For many kinds of file data, these deltas are	typically a fraction of a percent of the size of a full copy	of a file.</p><p> 修订日志使用增量机制提供了有效的修订存储。它没有存储每个修订版本的文件的完整副本，而是存储了将旧修订版本转换为新修订版本所需的更改。对于许多类型的文件数据，这些增量通常仅占文件完整副本大小的百分之几。</p><p> Some obsolete revision control systems can only work with	deltas of text files. They must either store binary files as	complete snapshots or encoded into a text representation, both	of which are wasteful approaches. Mercurial can efficiently	handle deltas of files with arbitrary binary contents; it	doesn&#39;t need to treat text as special.</p><p> 一些过时的修订控制系统只能使用增量文本文件。他们必须将二进制文件存储为完整的快照或编码为文本表示形式，这两种方法都是浪费的方法。 Mercurial可以有效地处理具有任意二进制内容的文件增量；它不需要将文本视为特殊字符。</p><p> Mercurial only ever   appends data to	the end of a revlog file. It never modifies a section of a	file after it has written it. This is both more robust and	efficient than schemes that need to modify or rewrite	data.</p><p> Mercurial仅将数据附加到修订日志文件的末尾。写入文件后，它绝不会修改文件的一部分。与需要修改或重写数据的方案相比，这既健壮又高效。 </p><p> In addition, Mercurial treats every write as part of a	  transaction that can span a number of	files. A transaction is   atomic: either	the entire transaction succeeds and its effects are all	visible to readers in one go, or the whole thing is undone.	This guarantee of atomicity means that if you&#39;re running two	copies of Mercurial, where one is reading data and one is	writing it, the reader will never see a partially written	result that might confuse it.</p><p>此外，Mercurial将每次写入都视为可跨越多个文件的事务的一部分。事务是原子性的：要么整个事务成功，而且其效果一目了然，但读者却看不见，要么整个事务都被撤消。这种原子性保证意味着，如果您运行的是Mercurial的两个副本，其中一个正在读取数据，一个正在写入数据，那么读者将永远不会看到可能会混淆它的部分写入结果。</p><p> The fact that Mercurial only appends to files makes it	easier to provide this transactional guarantee. The easier it	is to do stuff like this, the more confident you should be	that it&#39;s done correctly.</p><p> Mercurial仅附加到文件这一事实使得提供此事务保证更加容易。做这样的事情越容易，就应该对完成正确的事情更有信心。</p><p> Mercurial cleverly avoids a pitfall common to	all earlier revision control systems: the problem of	  inefficient retrieval. Most revision	control systems store the contents of a revision as an	incremental series of modifications against a	“ snapshot”. (Some base the snapshot on the	oldest revision, others on the newest.) To reconstruct a	specific revision, you must first read the snapshot, and then	every one of the revisions between the snapshot and your	target revision. The more history that a file accumulates,	the more revisions you must read, hence the longer it takes to	reconstruct a particular revision.</p><p> Mercurial巧妙地避免了所有早期版本控制系统都存在的陷阱：检索效率低下的问题。大多数修订控制系统将修订的内容存储为针对“快照”的一系列增量修订。 （某些快照基于最早的修订版本，其他快照基于最新的修订版本。）要重建特定的修订版本，必须首先读取快照，然后读取快照与目标修订版本之间的每个修订版本。文件累积的历史记录越多，您必须阅读的修订版越多，因此重建特定修订版所花费的时间越长。</p><p>   The innovation that Mercurial applies to this problem is	simple but effective. Once the cumulative amount of delta	information stored since the last snapshot exceeds a fixed	threshold, it stores a new snapshot (compressed, of course),	instead of another delta. This makes it possible to	reconstruct   any revision of a file	quickly. This approach works so well that it has since been	copied by several other revision control systems.</p><p>   Mercurial应用于此问题的创新很简单但有效。自上次快照以来存储的增量信息的累积量超过固定阈值后，它将存储新的快照（当然是压缩的），而不是另一个增量。这样就可以快速重建文件的任何修订版。这种方法效果很好，以至于它已经被其他几个版本控制系统所复制。</p><p> Figure 4.3, “Snapshot of a revlog, with incremental deltas” illustrates	the idea. In an entry in a revlog&#39;s index file, Mercurial	stores the range of entries from the data file that it must	read to reconstruct a particular revision.</p><p> 图4.3``带有增量增量的修订日志快照''说明了这一想法。在revlog索引文件的条目中，Mercurial存储了数据文件中它必须读取以重建特定修订版本的条目范围。</p><p> If you&#39;re familiar with video compression or	 have ever watched a TV feed through a digital cable or	 satellite service, you may know that most video compression	 schemes store each frame of video as a delta against its	 predecessor frame.</p><p> 如果您熟悉视频压缩，或者曾经通过数字电缆或卫星服务收看过电视节目，则可能会知道大多数视频压缩方案会将视频的每一帧存储为相对于其前一帧的增量。</p><p> Mercurial borrows this idea to make it	 possible to reconstruct a revision from a snapshot and a	 small number of deltas.</p><p> Mercurial借用了这个想法，从而可以从快照和少量增量重建修订版本。 </p><p> Along with delta or snapshot information, a revlog entry	contains a cryptographic hash of the data that it represents.	This makes it difficult to forge the contents of a revision,	and easy to detect accidental corruption.</p><p>除了增量或快照信息外，修订日志条目还包含其表示的数据的加密哈希。这使得难以伪造修订的内容，并且易于检测意外损坏。</p><p> Hashes provide more than a mere check against corruption;	they are used as the identifiers for revisions. The changeset	identification hashes that you see as an end user are from	revisions of the changelog. Although filelogs and the	manifest also use hashes, Mercurial only uses these behind the	scenes.</p><p> 哈希不仅可以防止腐败；它们用作修订的标识符。您作为最终用户看到的变更集标识哈希来自变更日志的修订版。尽管文件日志和清单也使用哈希，但Mercurial仅在后台使用这些。</p><p> Mercurial verifies that hashes are correct when it	retrieves file revisions and when it pulls changes from	another repository. If it encounters an integrity problem, it	will complain and stop whatever it&#39;s doing.</p><p> 当Mercurial检索文件修订以及从另一个存储库中提取更改时，它们会验证哈希是否正确。如果遇到完整性问题，它将抱怨并停止所做的任何事情。</p><p> In addition to the effect it has on retrieval efficiency,	Mercurial&#39;s use of periodic snapshots makes it more robust	against partial data corruption. If a revlog becomes partly	corrupted due to a hardware error or system bug, it&#39;s often	possible to reconstruct some or most revisions from the	uncorrupted sections of the revlog, both before and after the	corrupted section. This would not be possible with a	delta-only storage model.</p><p> 除了对检索效率有影响外，Mercurial对定期快照的使用使它对于部分数据损坏也更加健壮。如果某个修订日志由于硬件错误或系统错误而部分损坏，则通常可以在损坏的部分之前和之后，从该修订日志的未损坏部分中重建一些或大多数修订。对于仅增量存储模型，这是不可能的。</p><p> Every entry in a Mercurial revlog knows the identity of its immediate ancestor revision, usually referred to as its   parent. In fact, a revision contains room for not one parent, but two. Mercurial uses a special hash, called the “ null ID”, to represent the idea “ there is no parent here”. This hash is simply a string of zeroes.</p><p> Mercurial修订日志中的每个条目都知道其直接祖先修订版本的身份，通常称为其父版本。实际上，修订版包含的空间不是一个父母，而是两个父母。 Mercurial使用一种特殊的哈希（称为“空ID”）来表示“此处没有父母”的想法。此哈希只是一串零。</p><p> In  Figure 4.4, “The conceptual structure of a revlog”, you can see an example of the conceptual structure of a revlog. Filelogs, manifests, and changelogs all have this same structure; they differ only in the kind of data stored in each delta or snapshot.</p><p> 在图4.4``修订日志的概念结构''中，您可以看到修订日志的概念结构的示例。文件日志，清单和更改日志都具有相同的结构；它们仅在每个增量或快照中存储的数据类型不同。</p><p> The first revision in a revlog (at the bottom of the image) has the null ID in both of its parent slots. For a “ normal” revision, its first parent slot contains the ID of its parent revision, and its second contains the null ID, indicating that the revision has only one real parent. Any two revisions that have the same parent ID are branches. A revision that represents a merge between branches has two normal revision IDs in its parent slots.</p><p> 修订日志中的第一个修订版（在图像的底部）在其两个父插槽中均具有空ID。对于“普通”修订版，其第一个父级插槽包含其父修订版的ID，第二个父级插槽包含空ID，表示该修订版只有一个真实的父级。具有相同父ID的任何两个修订版都是分支。代表分支之间合并的修订版本在其父级插槽中具有两个常规修订版本ID。 </p><p> In the working directory, Mercurial stores a snapshot of the files from the repository as of a particular changeset.</p><p>在工作目录中，Mercurial存储来自特定更改集的存储库中文件的快照。</p><p> The working directory “ knows” which changeset it contains. When you update the working directory to contain a particular changeset, Mercurial looks up the appropriate revision of the manifest to find out which files it was tracking at the time that changeset was committed, and which revision of each file was then current. It then recreates a copy of each of those files, with the same contents it had when the changeset was committed.</p><p> 工作目录“知道”它包含哪个变更集。当您更新工作目录以包含特定的变更集时，Mercurial会查找清单的适当修订版，以找出提交变更集时正在跟踪的文件，以及每个文件的最新版本。然后，它将重新创建每个文件的副本，其内容与提交变更集时的内容相同。</p><p> The   dirstate is a special structure that contains Mercurial&#39;s knowledge of the working directory. It is maintained as a file named   inside a repository. The dirstate details which changeset the working directory is updated to, and all of the files that Mercurial is tracking in the working directory. It also lets Mercurial quickly notice changed files, by recording their checkout times and sizes.</p><p> dirstate是一个特殊的结构，其中包含Mercurial对工作目录的了解。它被维护为在存储库中命名的文件。工作目录更新到哪个目录详细信息，以及Mercurial在工作目录中跟踪的所有文件。通过记录签出时间和大小，Mercurial还可以使Mercurial快速注意到已更改的文件。</p><p> Just as a revision of a revlog has room for two parents, so that it can represent either a normal revision (with one parent) or a merge of two earlier revisions, the dirstate has slots for two parents. When you use the   hg	update command, the changeset that you update to is stored in the “ first parent” slot, and the null ID in the second. When you   hg	merge with another changeset, the first parent remains unchanged, and the second parent is filled in with the changeset you&#39;re merging with. The   hg	parents command tells you what the parents of the dirstate are.</p><p> 正如修订日志的修订版可以容纳两个父级，以便它可以代表一个普通修订版（具有一个父级）或两个较早修订版的合并一样，dirstate可以容纳两个父级。使用hg update命令时，更新到的变更集存储在“第一个父级”插槽中，而空ID存储在第二个中。 hg与另一个变更集合并时，第一个父级保持不变，而第二个父级将填充您要与之合并的变更集。 hg父母命令告诉你dirstate的父母是什么。</p><p> The dirstate stores parent information for more than just	book-keeping purposes. Mercurial uses the parents of the	dirstate as   the parents of a new	 changeset when you perform a commit.</p><p> dirstate存储父信息不仅用于簿记目的。执行提交时，Mercurial将dirstate的父级用作新变更集的父级。</p><p>   Figure 4.5, “The working directory can have two parents” shows the	normal state of the working directory, where it has a single	changeset as parent. That changeset is the	  tip, the newest changeset in the	repository that has no children.</p><p>   图4.5``工作目录可以有两个父目录''显示了工作目录的正常状态，其中有一个变更集作为父目录。该变更集是技巧，这是存储库中没有子级的最新变更集。</p><p>   It&#39;s useful to think of the working directory as	“ the changeset I&#39;m about to commit”. Any files	that you tell Mercurial that you&#39;ve added, removed, renamed,	or copied will be reflected in that changeset, as will	modifications to any files that Mercurial is already tracking;	the new changeset will have the parents of the working	directory as its parents.</p><p>   将工作目录视为“即将提交的变更集I”很有用。您告诉Mercurial您已添加，删除，重命名或复制的任何文件，将反映在该变更集中，以及对Mercurial已经在跟踪的任何文件的修改；新变更集将工作目录的父级作为其父级。 </p><p> After a commit, Mercurial will update the	parents of the working directory, so that the first parent is	the ID of the new changeset, and the second is the null ID.	This is shown in  Figure 4.6, “The working directory gains new parents after a	 commit”. Mercurial	doesn&#39;t touch any of the files in the working directory when	you commit; it just modifies the dirstate to note its new	parents.</p><p>提交后，Mercurial将更新工作目录的父级，以便第一个父级是新变更集的ID，第二个是空ID。如图4.6``工作目录在提交后获得新的父母''所示。提交时，Mercurial不会触摸工作目录中的任何文件；它只是修改目录以记录其新父母。</p><p> It&#39;s perfectly normal to update the working directory to a	changeset other than the current tip. For example, you might	want to know what your project looked like last Tuesday, or	you could be looking through changesets to see which one	introduced a bug. In cases like this, the natural thing to do	is update the working directory to the changeset you&#39;re	interested in, and then examine the files in the working	directory directly to see their contents as they were when you	committed that changeset. The effect of this is shown in	 Figure 4.7, “The working directory, updated to an older	 changeset”.</p><p> 将工作目录更新为当前提示以外的变更集是完全正常的。例如，您可能想知道上周二您的项目的样子，或者您可能正在浏览变更集以查看哪个项目引入了错误。在这种情况下，自然的做法是将工作目录更新为您感兴趣的变更集，然后直接检查工作目录中的文件以查看其内容，即提交该变更集时的内容。图4.7``工作目录已更新到较旧的变更集''中显示了此操作的效果。</p><p>   Having updated the working directory to an	older changeset, what happens if you make some changes, and	then commit? Mercurial behaves in the same way as I outlined	above. The parents of the working directory become the	parents of the new changeset. This new changeset has no	children, so it becomes the new tip. And the repository now	contains two changesets that have no children; we call these	  heads. You can see the structure that	this creates in  Figure 4.8, “After a commit made while synced to an older	 changeset”.</p><p>   将工作目录更新为较旧的变更集后，如果进行一些更改然后提交，会发生什么？水星的行为与我上面概述的相同。工作目录的父级将成为新变更集的父级。这个新的变更集没有子代，因此成为新的技巧。现在，存储库包含两个没有子代的变更集。我们称这些为首长。您可以在图4.8``同步到较早的变更集的提交之后''中看到此创建的结构。</p><p>   If you&#39;re new to Mercurial, you should keep	 in mind a common “ error”, which is to use the	   hg pull command without any	 options. By default, the   hg	 pull command   does not	 update the working directory, so you&#39;ll bring new changesets	 into your repository, but the working directory will stay	 synced at the same changeset as before the pull. If you	 make some changes and commit afterwards, you&#39;ll thus create	 a new head, because your working directory isn&#39;t synced to	 whatever the current tip is. To combine the operation of a	 pull, followed by an update, run   hg pull	 -u.</p><p>   如果您是Mercurial的新手，则应记住一个常见的“错误”，即使用hg pull命令时不带任何选项。默认情况下，hg pull命令不会更新工作目录，因此您会将新的变更集引入到存储库中，但是工作目录将与拉取之前的相同变更集保持同步。如果您进行了一些更改并随后提交，则将创建一个新的头，因为您的工作目录不会同步到当前提示。要结合拉动操作和更新操作，请运行hg pull -u。</p><p> I put the word “ error” in quotes	 because all that you need to do to rectify the situation	 where you created a new head by accident is	   hg merge, then   hg commit. In other words, this	 almost never has negative consequences; it&#39;s just something	 of a surprise for newcomers. I&#39;ll discuss other ways to	 avoid this behavior, and why Mercurial behaves in this	 initially surprising way, later on.</p><p> 我将“错误”一词用引号引起来，因为要纠正偶然创建新头的情况，您需要做的所有事情就是hg merge，然后是hg commit。换句话说，这几乎不会带来负面影响；对于新来者来说，这只是一个惊喜。稍后，我将讨论避免这种行为的其他方法，以及为何Mercurial会以这种最初令人惊讶的方式表现。</p><p> When you run the   hg	 merge command, Mercurial leaves the first parent	of the working directory unchanged, and sets the second parent	to the changeset you&#39;re merging with, as shown in  Figure 4.9, “Merging two heads”.</p><p> 运行hg merge命令时，Mercurial会保持工作目录的第一个父级不变，并将第二个父级设置为您要与之合并的变更集，如图4.9“合并两个头”所示。</p><p>   Mercurial also has to modify the working directory, to	merge the files managed in the two changesets. Simplified a	little, the merging process goes like this, for every file in	the manifests of both changesets.</p><p>   Mercurial还必须修改工作目录，以合并两个变更集中管理的文件。对于两个变更集清单中的每个文件，合并过程都进行了一些简化。 </p><p> If one changeset has modified a file, and the	 other hasn&#39;t, create the modified copy of the file in the	 working directory.</p><p>如果一个变更集修改了文件，而另一个变更集修改了文件，则在工作目录中创建文件的修改后的副本。</p><p> If one changeset has removed a file, and the	 other hasn&#39;t (or has also deleted it), delete the file	 from the working directory.</p><p> 如果一个变更集删除了一个文件，而另一个变更集删除了（或也删除了它），则从工作目录中删除该文件。</p><p> If one changeset has removed a file, but the	 other has modified the file, ask the user what to do: keep	 the modified file, or remove it?</p><p> 如果一个变更集已删除文件，而另一个变更集已删除文件，请询问用户该怎么做：保留已修改的文件还是将其删除？</p><p> If both changesets have modified a file,	 invoke an external merge program to choose the new	 contents for the merged file. This may require input from	 the user.</p><p> 如果两个变更集都修改了文件，则调用外部合并程序以选择合并文件的新内容。这可能需要用户输入。</p><p> If one changeset has modified a file, and the	 other has renamed or copied the file, make sure that the	 changes follow the new name of the file.</p><p> 如果一个变更集已修改文件，而另一个变更集已重命名或复制了文件，请确保更改遵循文件的新名称。</p><p> There are more details—merging has plenty of corner	cases—but these are the most common choices that are	involved in a merge. As you can see, most cases are	completely automatic, and indeed most merges finish	automatically, without requiring your input to resolve any	conflicts.</p><p> 有更多细节（合并有很多极端情况），但这是合并中最常见的选择。如您所见，大多数情况是完全自动的，并且实际上大多数合并都是自动完成的，而无需您输入解决任何冲突的方法。</p><p> When you&#39;re thinking about what happens when you commit	after a merge, once again the working directory is “ the	 changeset I&#39;m about to commit”. After the   hg merge command completes, the	working directory has two parents; these will become the	parents of the new changeset.</p><p> 当您考虑合并后提交时会发生什么情况时，工作目录再次是“即将提交的变更集I”。 hg merge命令完成后，工作目录具有两个父目录；这些将成为新变更集的父项。 </p><p> Mercurial lets you perform multiple merges, but	you must commit the results of each individual merge as you	go. This is necessary because Mercurial only tracks two	parents for both revisions and the working directory. While	it would be technically feasible to merge multiple changesets	at once, Mercurial avoids this for simplicity. With multi-way	merges, the risks of user confusion, nasty conflict	resolution, and making a terrible mess of a merge would grow	intolerable.</p><p>Mercurial允许您执行多个合并，但是您必须在进行过程中提交每个合并的结果。这是必需的，因为Mercurial仅跟踪两个父版本和工作目录。尽管在技术上一次合并多个变更集是可行的，但Mercurial为简单起见避免了这一点。使用多路合并，用户混乱，麻烦的冲突解决以及合并的可怕混乱的风险将变得无法忍受。</p><p> A surprising number of revision control systems pay little	or no attention to a file&#39;s   name over	time. For instance, it used to be common that if a file got	renamed on one side of a merge, the changes from the other	side would be silently dropped.</p><p> 随着时间的推移，数量惊人的修订控制系统很少或根本不关注文件名。例如，通常，如果在合并的一侧对文件进行了重命名，则来自另一侧的更改将被静默删除。</p><p> Mercurial records metadata when you tell it to perform a	rename or copy. It uses this metadata during a merge to do the	right thing in the case of a merge. For instance, if I rename	a file, and you edit it without renaming it, when we merge our	work the file will be renamed and have your edits	applied.</p><p> 当您告诉Mercurial执行重命名或复制操作时，它会记录元数据。在合并过程中，它会在合并过程中使用此元数据来执行正确的操作。例如，如果我重命名文件，而您在不重命名的情况下对其进行编辑，则在我们合并工作时，该文件将被重命名并应用您的编辑。</p><p> In the sections above, I&#39;ve tried to highlight some of the most important aspects of Mercurial&#39;s design, to illustrate that it pays careful attention to reliability and performance. However, the attention to detail doesn&#39;t stop there. There are a number of other aspects of Mercurial&#39;s construction that I personally find interesting. I&#39;ll detail a few of them here, separate from the “ big ticket” items above, so that if you&#39;re interested, you can gain a better idea of the amount of thinking that goes into a well-designed system.</p><p> 在以上各节中，我试图突出显示Mercurial设计的一些最重要方面，以说明它对可靠性和性能非常关注。但是，对细节的关注不止于此。我个人认为Mercurial的构造还有许多其他方面。我将在此处详细说明其中的一些，与上面的“大门票”项目分开，以便您感兴趣时，可以更好地了解设计周密的设计思路系统。</p><p> When appropriate, Mercurial will store both snapshots and	deltas in compressed form. It does this by always	  trying to compress a snapshot or delta,	but only storing the compressed version if it&#39;s smaller than	the uncompressed version.</p><p> 在适当的时候，Mercurial将以压缩形式存储快照和增量。为此，它总是尝试压缩快照或增量，但仅在压缩版本小于未压缩版本时才存储压缩版本。</p><p> This means that Mercurial does “ the right	 thing” when storing a file whose native form is	compressed, such as a  zip archive or a JPEG	image. When these types of files are compressed a second	time, the resulting file is usually bigger than the	once-compressed form, and so Mercurial will store the plain	 zip or JPEG.</p><p> 这意味着，Mercurial在存储压缩了本机格式的文件（例如zip存档或JPEG图像）时会做“正确的事情”。再次压缩这些类型的文件时，生成的文件通常比一次压缩后的文件大，因此Mercurial将存储纯zip或JPEG。</p><p> Deltas between revisions of a compressed file are usually	larger than snapshots of the file, and Mercurial again does	“ the right thing” in these cases. It finds that	such a delta exceeds the threshold at which it should store a	complete snapshot of the file, so it stores the snapshot,	again saving space compared to a naive delta-only	approach.</p><p> 压缩文件的修订版之间的增量通常大于文件快照的增量，在这种情况下，Mercurial再次“正确”。它发现此类增量超出了应存储文件完整快照的阈值，因此它存储了快照，与仅采用纯增量方式相比，又节省了空间。 </p><p> When storing revisions on disk, Mercurial uses the	 “ deflate” compression algorithm (the same one	 used by the popular  zip archive format),	 which balances good speed with a respectable compression	 ratio. However, when transmitting revision data over a	 network connection, Mercurial uncompresses the compressed	 revision data.</p><p>在磁盘上存储修订时，Mercurial使用“ deflate”压缩算法（流行的zip存档格式使用相同的压缩算法），该算法在良好的速度与可观的压缩比之间取得了平衡。但是，通过网络连接发送修订数据时，Mercurial会解压缩压缩的修订数据。</p><p> If the connection is over HTTP, Mercurial recompresses	 the entire stream of data using a compression algorithm that	 gives a better compression ratio (the Burrows-Wheeler	 algorithm from the widely used  bzip2	 compression package). This combination of algorithm and	 compression of the entire stream (instead of a revision at a	 time) substantially reduces the number of bytes to be	 transferred, yielding better network performance over most	 kinds of network.</p><p> 如果连接是通过HTTP进行的，那么Mercurial会使用提供更好压缩率的压缩算法（来自广泛使用的bzip2压缩包的Burrows-Wheeler算法）来重新压缩整个数据流。算法和整个流的压缩（而不是一次修订）的这种结合大大减少了要传输的字节数，从而在大多数类型的网络上产生了更好的网络性能。</p><p> If the connection is over	   ssh, Mercurial	   doesn&#39;t recompress the stream, because	   ssh can already do this itself. You can	 tell Mercurial to always use   ssh&#39;s	 compression feature by editing the	   file in your home directory as	 follows.</p><p> 如果连接是通过ssh进行的，则Mercurial不会重新压缩流，因为ssh本身已经可以执行此操作。您可以按照以下说明编辑主目录中的文件，以指示Mercurial始终使用ssh的压缩功能。</p><p> Appending to files isn&#39;t the whole story when	it comes to guaranteeing that a reader won&#39;t see a partial	write. If you recall  Figure 4.2, “Metadata relationships”,	revisions in the changelog point to revisions in the manifest,	and revisions in the manifest point to revisions in filelogs.	This hierarchy is deliberate.</p><p> 关于保证读者不会看到部分写入的内容，附加到文件并不是全部。如果您回想起图4.2``元数据关系''，则变更日志中的修订指向清单中的修订，清单中的修订指向文件日志中的修订。此层次结构是有意的。</p><p> A writer starts a transaction by writing filelog and	manifest data, and doesn&#39;t write any changelog data until	those are finished. A reader starts by reading changelog	data, then manifest data, followed by filelog data.</p><p> 编写者通过写入文件日志和清单数据来启动事务，并且在完成这些变更日志数据之前不写入任何变更日志数据。读取器首先读取变更日志数据，然后读取清单数据，然后读取文件日志数据。</p><p> Since the writer has always finished writing filelog and	manifest data before it writes to the changelog, a reader will	never read a pointer to a partially written manifest revision	from the changelog, and it will never read a pointer to a	partially written filelog revision from the manifest.</p><p> 由于编写者在写入变更日志之前始终完成文件日志和清单数据的写入，因此读者将永远不会从变更日志中读取指向部分写入的清单修订的指针，也永远不会从变更日志中读取指向部分写入的文件日志修订的指针。表现。</p><p> The read/write ordering and atomicity guarantees mean that	Mercurial never needs to</p><p> 读/写顺序和原子性保证意味着Mercurial永远不需要 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://hgbook.red-bean.com/read/behind-the-scenes.html">http://hgbook.red-bean.com/read/behind-the-scenes.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/水星/">#水星</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mercurial/">#mercurial</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>