<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用白头蛇克隆蛇</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">用白头蛇克隆蛇</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-06 07:10:03</div><div class="page_narrow text-break page_content"><p>Bevy has seen rapid adoption recently, but thelearning resources are still fairly scarce. This is an attempt to provide a nextstep after the Bevy book. The final product looks like this:</p><p>Bevy最近被迅速采用，但学习资源仍然相当稀缺。这是一种尝试，试图提供继Bevy Book之后的NextStep。最终产品如下所示：</p><p>  It’s about 300 lines of Rust, so buckle in; this is a lengthy walkthrough. Ifyou want to fast-forward to the finished code, the code lives here. For eachsection there’s a diff at the top, which should make it easier to determinewhere to place snippets of code, when it’s not clear.</p><p>它大约有300行锈迹，所以系好安全带；这是一段很长的路程。如果你想快进到完成的代码，代码就在这里。每个部分的顶部都有不同之处，这应该可以更容易地确定在不清楚的情况下将代码片段放在哪里。</p><p>   We’ll start how the bevy book starts, with an app that does nothing. Run  cargo new bevy-snake, then put the following in your  main.rs:</p><p>我们将从一款什么都不做的应用程序开始，从Bevy Book开始。运行Cargo New Bevy-Snake，然后将以下内容放入您的主机中。rs：</p><p>  We’ll need to add bevy as a dependency in our  Cargo.toml, and because I havethe ability to predict the future of this tutorial, let’s go ahead and add rand in there too so we have it when the time comes.</p><p>我们需要将bevy作为依赖项添加到Cargo.toml中，而且因为我能够预测本教程的未来，所以让我们继续在其中添加rand，这样当时间到来时我们就可以使用它了。</p><p>    We’re going to be creating a 2D game, which requires a lot of different systems;one to create a window, one to do a render loop, one to handle input, one tohandle sprites, etc. Luckily Bevy’s default plugins give us all of that:</p><p>我们将创建一个2D游戏，它需要很多不同的系统；一个用于创建窗口，一个用于执行渲染循环，一个用于处理输入，一个用于处理精灵等等。幸运的是，Bevy的默认插件为我们提供了所有这些功能：</p><p>  Bevy’s default plugins don’t include a camera though, so let’s insert a 2dcamera, which we’ll set up by creating our first system:</p><p>不过，Bevy的默认插件不包括摄像头，所以让我们插入一个2d摄像头，我们将通过创建第一个系统来设置它：</p><p>  Commands isused to queue up commands to mutate the world and resources. In this case, we’respawning a new entity, with 2D camera components. Prepare for some bevy magic:</p><p>命令用于排队命令，以改变世界和资源。在这种情况下，我们正在生成一个新的实体，包含2D摄像机组件。准备好迎接一些迷人的魔力吧：</p><p>  All we have to do is call  .system() on our function, and Bevy willauto-magically call it at startup with the  commands param. Run the app again,and you should get an empty window like this:</p><p>我们所要做的就是在我们的函数上调用.system()，而bevy将在启动时使用命令param自动神奇地调用它。再次运行该应用程序，您应该会看到一个空窗口，如下所示：</p><p>    Let’s try to get a snake head in there. We’ll define a couple structs:</p><p>让我们试着把蛇头放进去。我们将定义两个结构：</p><p>  SnakeHead is just an empty struct that we’ll use as a component, it’s sort oflike a tag, we’ll put on an entity, and then we can find that entity later byquerying for entities with the  SnakeHead component. Empty structs like theseare a common pattern in Bevy, components often don’t need any state of theirown.  Materials is going to be a resource, which stores the material thatwe’ll use for the snake head for now, and eventually for the snake segments andthe food.</p><p>蛇头只是一个空的结构，我们将把它用作一个组件，它有点像一个标签，我们将放在一个实体上，然后我们可以在稍后通过查询带有蛇头组件的实体来找到那个实体。像这样的空结构是bevy中的常见模式，组件通常不需要它们的任何运行状态。材料将成为一种资源，储存我们现在将用来制作蛇头的材料，并最终用于蛇段和食物。</p><p> That  head_material handle should be created when the game gets set up, so let’sdo that next, by modifying our  setup function:</p><p>Head_Material句柄应该在游戏设置时创建，所以接下来让我们通过修改设置函数来执行此操作：</p><p> fn  setup( mut commands:  Commands,  mut materials:  ResMut &lt;Assets &lt;ColorMaterial &gt;&gt;) { commands.spawn(Camera2dComponents::default()); commands.insert_resource(Materials { head_material:  materials.add(Color::rgb( 0.7,  0.7,  0.7).into()), });}</p><p>FN Setup(MUT Commands：Commands，MUT Material：ResMut&lt；Assets&lt；ColorMaterial&gt；&gt；){commands.spawn(Camera2dComponents：：default())；命令.INSERT_RESOURCE(材质{Head_Material：Material s.add(颜色：：rgb(0.70.7，0.7).into())，})；}。</p><p> Bevy requires a specific ordering to the params when registeringsystems. Commands → Resources → Components/Queries. If you get a mysteriouscompile-time error after messing with a system, check your order.</p><p>BEVY在注册系统时需要对参数进行特定排序。命令→资源→组件/查询。如果在扰乱系统后出现神秘的编译时错误，请检查您的订单。</p><p> materials.add will return a  Handle&lt;ColorMaterial&gt;. We create a Materials struct using this new handle. Later, when we try to access aresource with the type of  Materials, Bevy will find this struct we’vecreated. We’ll now create our snake head entity in a new system, and you can seewhat using that resource looks like:</p><p>Materials.add将返回一个句柄&lt；ColorMaterial&gt；。我们使用这个新句柄创建一个Materials结构。稍后，当我们尝试访问具有材料类型的资源时，bevy会发现我们创建的这个结构。现在，我们将在一个新系统中创建蛇头实体，您可以看到使用该资源是什么样子：</p><p> fn  game_setup( mut commands:  Commands, materials:  Res &lt;Materials &gt;) { commands .spawn(SpriteComponents { material:  materials.head_material.clone(), sprite:  Sprite::new(Vec2::new( 10.0,  10.0)), ..Default::default() }) .with(SnakeHead);}</p><p>FN GAME_SETUP(mut Commands：Commands，Material：res&lt；Materials&gt；){Commands.spwn(SpriteComponents{Material：Materals.head_Material al.clone()，Sprite：Sprite：：New(vec2：：New(10.0，10.0))，.Default：：Default()}).with(Snakehead)；}。</p><p> Here we’ve got a new system, which will look for a resource of type Materials. It will then spawn a new entity, with  SpriteComponents and SnakeHead as components. To create the  SpriteComponents, we pass in thehandle to the color material we created earlier, and give the sprite a sizeof (10,10). Let’s just add that system into our app builder:</p><p>这里我们有一个新系统，它将查找材料类型的资源。然后，它将生成一个新实体，将SpriteComponents和Snakehead作为组件。为了创建SpriteComponents，我们将句柄传递给前面创建的颜色材质，并为Sprite赋予大小(10，10)。让我们将该系统添加到我们的应用程序构建器中：</p><p>  The reason we need a new stage instead of just calling  add_startup_systemagain, is that we need to use the material that gets inserted in the  setupfunction. After running this, you should see a snake head in the middle of thescreen:</p><p>我们需要一个新的阶段，而不是再次调用add_startup_system，原因是我们需要使用在setupfunction中插入的材料。运行此命令后，您应该会在屏幕中央看到一个蛇头：</p><p>  Okay maybe calling it a snake head is a stretch, you’ll see a 10x10 white sprite.</p><p>好吧，也许叫它蛇头有点夸张，你会看到一个10x10的白色精灵。</p><p>   Snake isn’t much of a game without movement, so let’s get that head moving.We’ll worry about input later, for now our goal is just to get the head tomove. So let’s create a system that will move all snake heads up:</p><p>蛇并不是一个没有运动的游戏，所以让我们移动一下头部。我们稍后会担心输入的问题，因为现在我们的目标只是让头部移动。因此，让我们创建一个系统，让所有的蛇头都向上移动：</p><p> fn  snake_movement( mut head_positions:  Query &lt;( &amp;SnakeHead,  &amp; mut Transform) &gt;) {  for (_head,  mut transform)  in head_positions.iter_mut() {  *transform.translation.y_mut()  +=  2.; }}</p><p>Fn Snake_Move(mut head_position：查询&lt；(&amp；蛇头，&amp；mut转换)&gt；){for(_head，mut转换)in head_postions.iter_mut(){*Transform.Translation.y_mut()+=2。；}}。</p><p> The main new concept here is that  Query type. We can use it to iterate throughall entities that have both the  SnakeHead component and the  Transformcomponent. We don’t have to worry about actually creating that query, bevy willtake care of creating it and calling our function with it, part of the ECSmagic. So let’s add that system in and see what happens:</p><p>这里的主要新概念是查询类型。我们可以使用它来遍历同时具有蛇头组件和Transform组件的所有实体。我们不必担心实际创建该查询，bevy将负责创建它并使用它调用我们的函数，这是ECSMagic的一部分。因此，让我们将该系统添加进来，看看会发生什么：</p><p>    You may be wondering about that Transform component. When we spawned the SnakeHead, we didn’t give it a  Transform, so how come we’re able to find anentity that has a  SnakeHead and a  Transform component? What’s going on thereis that  SpriteComponents is a  Bundle ofcomponents. For  SpriteComponents, that means we get a  Transform component,among a bunch of others ( Sprite,  Mesh,  Draw,  Rotation,  Scale, etc).</p><p>您可能会对该转换组件感到疑惑。当我们产生蛇头的时候，我们没有给它一个变换，那么为什么我们能够找到一个有蛇头和变换组件的实体呢？实际上，SpriteComponents是一个组件捆绑包。对于SpriteComponents，这意味着我们在一系列其他组件(Sprite、网格、绘制、旋转、缩放等)中获得了一个变换组件。</p><p>   Let’s modify our snake movement system to actually allow us to direct the snake:</p><p>让我们修改蛇的移动系统，以实际允许我们引导蛇：</p><p> fn  snake_movement( keyboard_input:  Res &lt;Input &lt;KeyCode &gt;&gt;,  mut head_positions:  Query &lt;( &amp;SnakeHead,  &amp; mut Transform) &gt;,) {  for (_head,  mut transform)  in head_positions.iter_mut() {  if keyboard_input.pressed(KeyCode::Left) {  *transform.translation.x_mut()  -=  2.; }  if keyboard_input.pressed(KeyCode::Right) {  *transform.translation.x_mut()  +=  2.; }  if keyboard_input.pressed(KeyCode::Down) {  *transform.translation.y_mut()  -=  2.; }  if keyboard_input.pressed(KeyCode::Up) {  *transform.translation.y_mut()  +=  2.; } }}</p><p>Fn Snake_Move(keyboard_input：res&lt；input；keycode&gt；，mut head_Positions：Query&lt；(&amp；Snakehead，&amp；mut Transform)&gt；，){for(_head，mut Transform)in head_postions.iter_mut(){if keyboard_input.press(keycode：Left){*Transform.Translation.x_mut()-=2；}if keyboard_input.press(keycode：：right){*Transform.Translation.x_mut()+=2.；}if keyboard_input.press(keycode：：down){*Transform.Translation.y_mut()-=2.；}if keyboard_input.press(keycode：：up){*Transform.Translation.y_mut()+=2.；}</p><p>     So far we’ve been using window coordinates, and the way that works is that (0,0)is the middle, and the units are pixels. Snake games generally use grids, so ifwe made our snake game 10x10, our window would be  really small. Let’s make ourlives a bit easier by using our own positioning and sizing. Then we can usesystems that deal with transforming these to window coordinates.</p><p>到目前为止，我们一直使用窗口坐标，其工作方式是(0，0)是中间，单位是像素。蛇游戏一般使用网格，所以如果我们的蛇游戏是10x10，我们的窗口将会非常小。让我们通过使用自己的定位和大小来让我们的生活更轻松一些。然后我们就可以使用处理这些数据到窗口坐标转换的系统了。</p><p> We’ll make our grid 10x10. We’ll define those as constants up at the top of thefile:</p><p>我们会把我们的网格设为10x10。我们将这些定义为文件顶部的常量：</p><p>   #[derive(Default, Copy, Clone, Eq, PartialEq, Hash)] struct  Position { x:  i32, y:  i32,} struct  Size { width:  f32, height:  f32,} impl Size {  pub  fn  square(x:  f32) -&gt;  Self { Self { width:  x, height:  x, } }}</p><p>#[Derive(Default，Copy，Clone，Eq，PartialEq，Hash)]结构位置{x：i32，y：i32，}结构大小{宽度：f32，高度：f32，}实施大小{pub fn square(x：f32)-&gt；self{self{width：x，Height：x，}。</p><p> Fairly straightforward, with a helper method to get a  Size with equal widthand height. Position derives some traits that will be useful later, so we don’thave to keep going back to it.  Size could really just have one float, sinceall objects will end up having equal width and height, but it feels wrong so I’mgiving it a width and a height. Let’s add those components to the snake head wespawn:</p><p>非常简单，使用辅助方法可以获得等宽等高的尺寸。位置衍生出了一些以后会有用的特征，所以我们不必一直回到位置上来。大小可能只有一个浮点，因为所有物体最终都会有相同的宽度和高度，但感觉不对，所以我给它一个宽度和一个高度。让我们将这些组件添加到蛇头木卒中：</p><p> commands .spawn(SpriteComponents { material:  materials.head_material.clone(), sprite:  Sprite::new(Vec2::new( 10.0,  10.0)), ..Default::default() }) .with(SnakeHead) .with(Position { x:  3, y:  3 })  // &lt;--  .with(Size::square( 0.8));  // &lt;--</p><p>命令.spwn(SpriteComponents{Material：Material：Materials.head_Material al.clone()，Sprite：Sprite：：New(vec2：：New(10.0，10.0))，.Default：：Default()}).with(蛇头).with(Position{x：3，y：3})//&lt；--.with(Size：Square(0.8))；//&lt；--。</p><p> These components aren’t doing anything currently, let’s start with transformingour sizes into sprite sizes:</p><p>这些组件目前没有任何作用，让我们从将我们的大小转换为精灵大小开始：</p><p> fn  size_scaling(windows:  Res &lt;Windows &gt;,  mut q:  Query &lt;( &amp;Size,  &amp; mut Sprite) &gt;) {  for (size,  mut sprite)  in q.iter_mut() {  let window  = windows.get_primary().unwrap(); sprite.size  = Vec2::new( size.width  as  f32  / ARENA_WIDTH  as  f32  * window.width()  as  f32, size.height  as  f32  / ARENA_HEIGHT  as  f32  * window.height()  as  f32, ); }}</p><p>Fn Size_Scaling(windows：res&lt；Windows&gt；，mut q：Query&lt；(&amp；Size，&amp；mut Sprite)&gt；){for(size，mut Sprite)in q.iter_mut(){let Window=windows.get_Primary().unwire()；Sprite.size=ve2：：new(size.width as F32/Arena_width as F32*window.width()as F32，size.high as F32*window.high()as F32，)；}}。</p><p> The sizing logic goes like so: if something has a width of 1 in a grid of 40,and the window is 400px across, then it should have a width of 10. Next we cando the positioning system:</p><p>调整大小的逻辑是这样的：如果某个对象在40个网格中的宽度为1，而窗口的宽度为400px，则它的宽度应该为10。接下来，我们可以执行定位系统：</p><p> fn  position_translation(windows:  Res &lt;Windows &gt;,  mut q:  Query &lt;( &amp;Position,  &amp; mut Transform) &gt;) {  fn  convert(p:  f32, bound_window:  f32, bound_game:  f32) -&gt;  f32 { p  / bound_game  * bound_window  - (bound_window  /  2.)  + (bound_window  / bound_game  /  2.) }  let window  = windows.get_primary().unwrap();  for (pos,  mut transform)  in q.iter_mut() { transform.translation  = Vec3::new( convert(pos.x  as  f32, window.width()  as  f32, ARENA_WIDTH  as  f32), convert(pos.y  as  f32, window.height()  as  f32, ARENA_HEIGHT  as  f32),  0.0, ); }}</p><p>Fn Position_Translate(Windows：res&lt；Windows&gt；，mut q：Query&lt；(&amp；position，&amp；mut Transform)&gt；){fn Convert(p：F32，Bound_Window：F32，Bound_Game：f32)-&gt；F32{p/Bound_Game*Bound_Window-(Bound_Window/2.)+(Bound_Window/Bound_Game/2.)}let Window=windows.get_Primary().unwire()；对于q.iter_mut()中的(pos，mut变换){转换=ve3：：new(Convert(pos.x as F32，window.width()as F32，Arena_width as F32)，Convert(pos.y as F32，window.high()as F32，Arena_Height as F32)，0.0，)；}。</p><p> The position translation: if an item’s x coordinate is at 5 in our system,the width in our system is 10, and the window width is 200, then the coordinateshould be  5 / 10 * 200 - 200 / 2. We subtract half the window width becauseour coordinate system starts at the bottom left, and Translation starts from thecenter. We then add half the size of a single tile, because we want our spritesbototm left corner to be at the bottom left of a tile, not the center.</p><p>位置平移：如果一个项目的x坐标在我们的系统中是5，我们系统中的宽度是10，窗口宽度是200，那么坐标应该是5/10*200-200/2。我们减去窗口宽度的一半，因为我们的坐标系是从左下角开始的，而平移是从中心开始的。然后我们添加一个瓷砖大小的一半，因为我们希望精灵的左下角位于瓷砖的左下角，而不是中心。</p><p>   Now when you run it, you should get a squished little snake in the bottom left:</p><p>现在当你运行它的时候，你应该在左下角看到一条被压扁的小蛇：</p><p>  The most obvious issue here is the snake is squished. Anotherissue is that we&#39;ve broken our input handling. We&#39;ll fix the input handlingfirst, but rest assured we&#39;re coming back to our squished little snake to gethim back to the right proportions.</p><p>这里最明显的问题是蛇被压扁了。另一个问题是我们破坏了输入处理。我们将首先修复输入处理，但请放心，我们会回到我们被压扁的小蛇身上，让它恢复到正确的比例。</p><p>   Now that we’ve got our grid setup, we need to update our  snake_movementsystem. Where we were using  Transform before, we use  Position now:</p><p>现在我们已经设置了网格，我们需要更新Snake_movementsystem。我们以前使用的是变换，现在使用的是位置：</p><p> fn  snake_movement( keyboard_input:  Res &lt;Input &lt;KeyCode &gt;&gt;,  mut head_positions:  Query &lt;( &amp;SnakeHead,  &amp; mut Position) &gt;,) {  for (_head,  mut pos)  in  &amp; mut head_positions.iter() {  if keyboard_input.pressed(KeyCode::Left) { pos.x  -=  1; }  if keyboard_input.pressed(KeyCode::Right) { pos.x  +=  1; }  if keyboard_input.pressed(KeyCode::Down) { pos.y  -=  1; }  if keyboard_input.pressed(KeyCode::Up) { pos.y  +=  1; } }}</p><p>Fn Snake_Move(键盘_输入：分辨率&lt；输入&lt；keycode&gt；，mut head_Position：查询&lt；(&amp；蛇头，&amp；mut位置)&gt；，){for(_head，mut pos)in&amp；mut head_position tions.iter(){if keyboard_input.press(keycode：：Left){pos.x-=1；}if keyboard_input.press。}if keyboard_input.press(keycode：：down){pos.y-=1；}if keyboard_input.press(keycode：：up){pos.y+=1；}}。</p><p>     The reason you get a squished snake in the previous step is because the defaultwindow size isn’t square but our grid is, so each coordinate in our grid iswider than it is tall. There’s a simple fix for that, and that’s creating a WindowDescriptor resource when we build the app:</p><p>在上一步中你会看到一条被压扁的蛇，是因为默认的双窗口大小不是正方形，但是我们的网格是正方形的，所以我们网格中的每个坐标都比它的高要宽。有一个简单的解决办法，那就是在构建应用程序时创建一个WindowDescriptor资源：</p><p> App::build() .add_resource(WindowDescriptor {  // &lt;--  title:  &#34;Snake!&#34;.to_string(),  // &lt;--  width:  2000,  // &lt;--  height:  2000,  // &lt;--  ..Default::default()  // &lt;--  }) .add_startup_system(setup.system())</p><p>App：：build().add_resource(WindowDescriptor{//&lt；--Title：&#34；.to_string()，//&lt；--width：2000，//&lt；--Height：2000，//&lt；--..Default：：Default()//&lt；--}).add_start_system(setup.system())</p><p> While we’re at it, let’s change the clear color (aka background color), just tomake it look a bit nicer, insert this  use statement to get the  ClearColorstruct:</p><p>现在，让我们更改清晰的颜色(也就是背景色)，让它看起来更漂亮一些，插入以下USE语句以获得ClearColorstruct：</p><p>    Now we’re back to having a square, and now with a darker background:</p><p>现在我们又回到了正方形，现在背景更暗了：</p><p>    Now that we’ve got our snake moving around a bit, let’s give it something toeat. We’ll add a new  food_material field to our  Materials struct first:</p><p>现在我们已经让蛇动了一会儿，让我们给它吃点东西吧。我们将首先在Materials结构中添加一个新的Food_Material字段：</p><p>    We’ll need  Duration for the timer we’ll create, and we’ll need  random so wecan place food in random spots, so let’s  use those in advance:</p><p>我们需要创建计时器的持续时间，我们需要随机性，这样我们就可以在随机的地点放置食物，所以让我们提前使用这些：</p><p>  Then we’ll introduce two new structs; a  Food component so we know whichentities are food, and a timer that will fire intermittently to tell us to spawnsome food:</p><p>然后，我们将引入两个新的结构；一个Food组件，它让我们知道哪些实体是食物；另一个定时器会间歇性地触发，告诉我们产生一些食物：</p><p> struct  Food; struct  FoodSpawnTimer(Timer); impl Default  for FoodSpawnTimer {  fn  default() -&gt;  Self { Self(Timer::new(Duration::from_millis( 1000),  true)) }}</p><p>Struct Food；struct FoodSpawnTimer(Timer)；Iml Default for FoodSpawnTimer{fn Default()-&gt；self{self(Timer：：New(Duration：：From_Millis(1000)，true))}}。</p><p> The reason for creating a  Default will become clear (hopefully), when Iexplain the following new system:</p><p>当我解释以下新系统时，创建默认设置的原因将变得清晰(希望如此)：</p><p> fn  food_spawner(  mut commands:  Commands, materials:  Res &lt;Materials &gt;, time:  Res &lt;Time &gt;,  mut timer:  Local &lt;FoodSpawnTimer &gt;,) { timer. 0.tick(time.delta_seconds);  if timer. 0.finished { commands .spawn(SpriteComponents { material:  materials.food_material.clone(), ..Default::default() }) .with(Food) .with(Position { x: (random:: &lt; f32 &gt;()  * ARENA_WIDTH  as  f32)  as  i32, y: (random:: &lt; f32 &gt;()  * ARENA_HEIGHT  as  f32)  as  i32, }) .with(Size::square( 0.8)); }}</p><p>Fn Food_spawner(mut Commands：Commands，Material：res&lt；Materials&gt；，time：res&lt；time&gt；，mut Timer：Local&lt；FoodSpawnTimer&gt；，){Timer。0.tick(time.Delta_sec)；如果计时器。0.fined{Commands.spwn(SpriteComponents{Material：Material_Material()，.Default：：Default()}).with(Food).with(Position{x：(Random：：&lt；F32&gt；()*Arena_Width as F32)as I32，y：(Random：：&lt；F32&gt；()*Arena_Height as F32)as I32，}).with(Size：：Square()*Arena_Height as F32)as I32，}).with(Size：：Square()*Arena_Height as F32)as I32，}</p><p> We’re introducing the concept of local resources, with the  timer param. Bevywill see this param and instantiate a value of type  FoodSpawnTimer using our Default implementation. This will happen on the first run of the system, afterthat it will reuse the same timer. Using local resources in this way can be moreergonomic than registering resources manually. The timer is repeating, so wejust keep calling  tick and whenever the system runs when it has finished, wespawn some food randomly. Here’s what that looks like now:</p><p>我们通过定时器参数引入了本地资源的概念。Bevy将看到这个参数，并使用我们的默认实现实例化FoodSpawnTimer类型的值。这将在系统第一次运行时发生，之后它将重复使用相同的计时器。以这种方式使用本地资源可能比手动注册资源更符合人体工程学。计时器在重复，所以我们只要不停地呼叫Tick，每当系统运行完毕时，我们就会随机地典当一些食物。以下是现在的情况：</p><p>    We’re going to tackle the snake movement. Specifically, wewant the snake to move regardless of whether we’re currently pressing down anykeys, and we want it to move every X seconds, not every frame. We’ll be makingchanges in quite a few areas, so if you’re not sure where something goes, checkout the diff button above.</p><p>我们要解决蛇的运动问题。具体地说，无论我们当前是否按下任何键，我们都希望蛇移动，并且我们希望它每X秒移动一次，而不是每帧移动一次。我们将在相当多的领域进行更改，因此，如果您不确定某些内容的发展方向，请选中上面的比较按钮。</p><p>  #[derive(PartialEq, Copy, Clone)] enum  Direction { Left, Up, Right, Down,} impl Direction {  fn  opposite(self) -&gt;  Self {  match self { Self::Left  =&gt; Self::Right, Self::Right  =&gt; Self::Left, Self::Up  =&gt; Self::Down, Self::Down  =&gt; Self::Up, } }}</p><p>#[派生(PartialEq，Copy，Clone)]枚举方向{Left，Up，Right，Down，}实施方向{fn Reverse(Self)-&gt；Self{匹配Self{Self：：Left=&gt；Self：：Right，Self：：Right=&gt；Self：：Left，Self：：Up=&gt；Self：：Down，Self：：Down=&gt；Self：：Up，}。</p><p> We’ll add this direction to our  SnakeHead struct, so it knows which way it’sgoing:</p><p>我们将把这个方向添加到蛇头结构中，这样它就知道它在往哪个方向走：</p><p>  We’ll have to instantiate the  SnakeHead component with a directionnow, let’s say it starts going up:</p><p>我们现在必须用方向实例化蛇头组件，假设它开始上升：</p><p>  Snake generally isn’t smooth, it’s a step-wise sort of motion. Just like forspawning food, we’re going to be using timers to get systems to run every Xseconds/milliseconds. We’re going to create a struct to hold a timer:</p><p>蛇一般不是平滑的，它是一种循序渐进的运动。就像繁殖食物一样，我们将使用计时器让系统每隔X秒/毫秒运行一次。我们将创建一个结构来保存计时器：</p><p>    The reason we’re not doing this timer as a local resource like with the foodspawning, is because we’re going to use it in a few systems, so I’ll save youthe refactoring work. Since we’re using it in a few systems, we’re going tocreate a new system just to tick the timer:</p><p>我们之所以不把这个计时器作为本地资源来使用，就像食物产卵一样，是因为我们将在几个系统中使用它，所以我将为您省去重构工作。因为我们在几个系统中使用它，所以我们将创建一个新系统来计时：</p><p>  We could just put this ticking logic in the  snake_movement system, but I likethe cleanliness of having a separate system for it, since the timer will be usedin multiple places. Let’s just add that system to the app:</p><p>我们可以把这个定时器逻辑放在蛇形移动系统中，但我喜欢有一个单独的系统的简洁，因为计时器将在多个地方使用。我们只需将该系统添加到应用程序中：</p><p>  Now we can get to the meat of the direction logic, which is the  snake_movementsystem, here’s the updated version:</p><p>现在，我们可以进入方向逻辑的核心部分，即Snake_movementsystem，以下是更新版本：</p><p> fn  snake_movement( keyboard_input:  Res &lt;Input &lt;KeyCode &gt;&gt;, snake_timer:  ResMut &lt;SnakeMoveTimer &gt;,  mut heads:  Query &lt;(Entity,  &amp; mut SnakeHead) &gt;,  mut positions:  Query &lt;&amp; mut Position &gt;,) {  if  !snake_timer. 0.finished {  return; }  for (head_entity,  mut head)  in heads.iter_mut() {  let  mut head_pos  = positions.get_mut(head_entity).unwrap();  let dir:  Direction  =  if keyboard_input.pressed(KeyCode::Left) { Direction::Left }  else  if keyboard_input.pressed(KeyCode::Down) { Direction::Down }  else  if keyboard_input.pressed(KeyCode::Up) { Direction::Up }  else  if keyboard_input.pressed(KeyCode::Right) { Direction::Right }  else { head.direction };  if dir  != head.direction.opposite() { head.direction  = dir; }  match  &amp;head.direction { Direction::Left  =&gt; { head_pos.x  -=  1; } Direction::Right  =&gt; { head_pos.x  +=  1; } Direction::Up  =&gt; { head_pos.y  +=  1; } Direction::Down  =&gt; { head_pos.y  -=  1; } }; }}</p><p>Fn Snake_Move(键盘_输入：分辨率&lt；输入&lt；keycode&gt；，SnakeMoveTimer&gt；，MUT头：查询&lt；(实体，&amp；MUT蛇头)&gt；，MUT位置：查询&lt；&amp；MUT位置&gt；，){if！Snake_Timer；。0.heads.iter_mut(){let mut head_pos=position tions.get_mut(Head_Entity).unwire()中的(head_entity，mut head)的{return；}；让dir：Direction=if keyboard_input.press(keycode：：Left){Direction：：Left}Else if keyboard_input.press(keycode：：down){Direction：：down}Else if keyboard_input.press(keycode：：up){Direction：：Up}Else if keyboard_input.press(keycode：：right){Direction：：right}Else{head.Direction.dir}；if dir！=head.direction.对立面(){head.Direction=dir。方向{方向：：左=&gt；{head_pos.x-=1；}方向：：right=&gt；{head_pos.x+=1；}方向：：up=&gt；{head_pos.y+=1；}方向：：down=&gt；{head_pos.y-=1；}}。</p><p> There’s not much in the way of new concepts here, just game logic. After thisyou’ll have a snake head that moves a bit more… snake-like:</p><p>这里没有太多的新概念，只是游戏逻辑。在这之后，你会有一个蛇头，它移动得更多一点…。蛇形的：</p><p>    The tail of the snake is somewhat complex. For each segment, we need to knowwhere it needs to go next. The way we’re going to approach this is to put thesnake segments in a  Vec, and store that as a resource. That way, when we’reupdating the position of a segment, we can iterate through all the segments andset the position of each to the position of the segment before it.</p><p>蛇的尾巴有点复杂。对于每个细分市场，我们都需要知道它下一步需要去哪里。我们处理这一问题的方法是将这些蛇片段放在VEC中，并将其作为资源存储。这样，当我们更新线段的位置时，我们可以遍历所有的线段，并将每个线段的位置设置为它之前的线段的位置。</p><p>    commands.insert_resource(Materials { head_material:  materials.add(Color::rgb( 0.7,  0.7,  0.7).into()), segment_material:  materials.add(Color::rgb( 0.3,  0.3,  0.3).into()),  // &lt;--  food_material:  materials.add(Color::rgb( 1.0,  0.0,  1.0).into()),});</p><p>命令.INSERT_RESOURCE(Materials{head_Material：Material s.add(Color：：RGB(0.7，0.7，0.7).into())，Segment_Material：Material s.add(Color：：RGB(0.3，0.3，0.3).into())，//&lt；--Food_Material：Material s.add(Color：：RGB(1.0，0.0，1.0).into()，})；</p><p>       Since we’re going to be spawning segments from a couple places (when you eatfood and when you initialize the snake), we’ll create a helper function:</p><p>由于我们将从几个地方(当您吃食物和初始化蛇时)生成片段，因此我们将创建一个辅助函数：</p><p> fn  spawn_segment( commands:  &amp; mut Commands, material:  &amp; Handle &lt;ColorMaterial &gt;, position:  Position,) -&gt;  Entity { commands .spawn(SpriteComponents { material:  material.clone(), ..SpriteComponents::default() }) .with(SnakeSegment) .with(position) .with(Size::square( 0.65)); commands.current_entity().unwrap()}</p><p>FN SPOWN_SEGMENT(命令：&amp；mut Commands，Material：&amp；Handle&lt；ColorMaterial&gt；，Position：Position)-&gt；Entity{Commands.spwn(SpriteComponents{Material：Material.clone()，..SpriteComponents：：Default()}).with(SnakeSegment).with(Position).with(Size：：Square(0.65))；Commands.Current_Entity().unWrap。</p><p> This should look very similar to the spawning of the  SnakeHead, but instead ofa  SnakeHead component, it’s got a  SnakeSegment component. Something new hereis that we’re then getting that  Entity (which is really just an id), by usingthe  current_entity function, and returning it so that callers can use it. Now,we’ll need to modify our game setup function. Instead of just a head, it’s alsogoing to spawn… a snake segment (shocked pikachu meme):</p><p>这看起来应该与蛇头的产卵非常相似，但它有一个SnakeSegment组件，而不是蛇头组件。这里的一些新功能是，我们通过使用CURRENT_ENTITY函数获取该实体(实际上只是一个id)，并返回它以便调用者可以使用它。现在，我们需要修改我们的游戏设置功能。它不只是一个头，它还会产卵出…。一段蛇片段(震惊的皮卡丘表情包)：</p><p> fn  game_setup(  mut commands:  Commands, materials:  Res &lt;Materials &gt;,  mut segments:  ResMut &lt;SnakeSegments &gt;,) {  let first_segment  = spawn_segment(  &amp; mut commands,  &amp;materials.segment_material, Position { x:  3, y:  2 }, ); segments. 0  = vec ![first_segment]; commands .spawn(SpriteComponents { material:  materials.head_material.clone(), sprite:  Sprite::new(Vec2::new( 10.0,  10.0)), ..Default::default() }) .with(SnakeHead { direction:  Direction::Up, }) .with(Position { x:  3, y:  3 }) .with(Size::square( 0.8));}</p><p>FN GAME_SETUP(mut Commands：Commands，Material：res&lt；Materials&gt；，mut Segments：ResMut；SnakeSegments&gt；，){let First_Segment=SPOWN_SEGMENT(&amp；mut命令，&amp；Material。Segment_Material，Position{x：3，y：2}，)；Segments(&amp；mut Commands，&amp；Material，Position{x：3，y：2}，)；Segments。0=vec！[First_Segment]；Commands.spwn(SpriteComponents{Material：Materials.head_Material al.clone()，Sprite：Sprite：：New(ve2：：New(10.0，10.0))，.Default：：Default()}).with(蛇头{Direction：Direction：：Up，}).with(Position{x：3，y：3}).with(大小：正方形(0.8))；}。</p><p> We’re using our  spawn_segment function to create an entity with a SnakeSegment component. We then take the returned entity and set our SnakeSegments resource as a vector with a single element, that newlycreated segment. And voila, we’ve got a detached little “tail”:</p><p>我们使用SPOWN_SEGMENT函数创建一个带有SnakeSegment组件的实体。然后，我们获取返回的实体，并将SnakeSegments资源设置为具有单个元素的向量，即新创建的片段。瞧，我们有一条分离的小“尾巴”：</p><p>    One essential part of the game of snake as I remember it is that the head didn’timmediately detach from the tail. Let’s see how we can modify our snake_movement function to be more true to the original game. The first thingwe need to do is add our  SnakeSegments resource to the  snake_movementfunction:</p><p>在我的记忆中，蛇游戏的一个重要部分是头部不会立即从尾巴上分离出来。让我们看看如何修改Snake_Move函数，使其更贴近原始游戏。我们需要做的第一件事是将SnakeSegments资源添加到Snake_movement函数：</p><p> fn  snake_movement( keyboard_input:  Res &lt;Input &lt;KeyCode &gt;&gt;, snake_timer:  ResMut &lt;SnakeMoveTimer &gt;, segments:  ResMut &lt;SnakeSegments &gt;,  // &lt;--   mut heads:  Query &lt;(Entity,  &amp; mut SnakeHead) &gt;,  mut positions:  Query &lt;&amp; mut Position &gt;,</p><p>Fn Snake_Move(键盘_输入：分辨率&lt；输入&lt；keycode&gt；，SnakeMoveTimer&gt；，段：ResMut；SnakeSegments&gt；，//&lt；--MUT头：查询&lt；(实体，&amp；MUT蛇头)&gt；，MUT位置：查询&lt；&amp；</p><p> Now, directly before the  match, we’re going to copy the  head_pos variable,because we need to know where the head was before it moved:</p><p>现在，就在比赛之前，我们将复制head_pos变量，因为我们需要知道头部移动之前的位置：</p><p>    The reason we need to do this is because our query for  Position componentsreturns a mutable  Position. Bevy stops us from mutably borrowing multiple ofthe same component, because funky things would happen if you could mutate thesame position in two places. Right after that  drop, we’ll add our logic toupdate the segment positions:</p><p>我们需要这样做的原因是，我们对位置组件的查询返回一个可变位置。Bevy阻止我们随意借用相同成分的倍数，因为如果你能在两个地方变异相同的位置，就会发生时髦的事情。在下降之后，我们将添加我们的逻辑更新细分市场位置：</p><p> let  mut segment_positions: Vec &lt;Position &gt;  = segments . 0 .iter() .map( |e |  *positions.get_mut( *e).unwrap()) .collect:: &lt;Vec &lt;Position &gt;&gt;();segment_positions.insert( 0, last_head_pos);segment_positions .iter() .zip(segments. 0.iter()) .for_each( |(pos, segment) | {  *positions.get_mut( *segment).unwrap()  =  *pos; });</p><p>让mut Segment_Position：VEC&lt；Position&gt；=Segments。0.iter().map(|e|*position tions.get_mut(*e).unwire()).Collect：：&lt；vec&lt；position&gt；&gt；()；Segment_Positions.Insert(0，last_head_pos)；Segment_Positions.iter().zip(段。0.iter().for_each(|(pos，Segment)|{*position tions.get_mut(*Segment).unwire()=*pos；})；</p><p> Basically we get the current segment positions, then add the previous headposition. Now we’ve got a list of where the segments should go. The firstsegment will go to the position of the head, the second segment will go to theposition of the first segment, the third segment will go to the position of thesecond segment, etc.</p><p>基本上，我们得到当前的部门位置，然后添加之前的头部位置。现在我们已经有了分段应该到达的位置的列表。第一个片段将到达头部的位置，第二个片段将到达第一个片段的位置，第三个片段将到达第二个片段的位置，依此类推。</p><p>     The snake’s been taunted by inedible food for long enough. We’re going to add anew system that lets the snake eat food:</p><p>这条蛇被不能吃的食物嘲弄已经够久了。我们将增加一个让蛇吃东西的新系统：</p><p> fn  snake_eating(  mut commands:  Commands, snake_timer:  ResMut &lt;SnakeMoveTimer &gt;,  mut growth_events:  ResMut &lt;Events &lt;GrowthEvent &gt;&gt;, food_positions:  Query &lt;With &lt;Food, (Entity,  &amp;Position) &gt;&gt;, head_positions:  Query &lt;With &lt;SnakeHead,  &amp;Position &gt;&gt;,) {  if  !snake_timer. 0.finished {  return; }  for head_pos  in head_positions.iter() {  for (ent, food_pos)  in food_positions.iter() {  if food_pos  == head_pos { commands.despawn(ent); growth_events.send(GrowthEvent); } } }}</p><p>Fn Snake_Eating(MUT命令：命令，SnakeTimer：ResMut&lt；SnakeMoveTimer&&gt;，MUT Growth_Events：ResMut&lt；Events&lt；GrowthEvent&gt；，Food_Position：Query&lt；with&lt；Food，(Entity，&amp；Position)&gt；，Head_Position：Query&lt；with&lt；Snakehead，&。0.head_position tions.iter(){for(ent，Food_pos)in Food_postions.iter(){if Food_pos==head_pos{Commands.despawn(Ent)；growth_events.end(GrowthEvent)；}。</p><p> Just iterating through all food positions and seeing if they share a positionwith the head of the snake. If they do, we remove them using the h</p><p>只需重复所有的食物位置，看看它们是否与蛇头的位置相同。如果有，我们使用h删除它们。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mbuffett.com/posts/bevy-snake-tutorial/">https://mbuffett.com/posts/bevy-snake-tutorial/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/白头/">#白头</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/snake/">#snake</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>