<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通往HTTP/3的漫漫长路</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">通往HTTP/3的漫漫长路</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 16:21:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/deee7c290cf9b3edd3aa1948719f4fd6.png"><img src="http://img2.diglog.com/img/2020/10/deee7c290cf9b3edd3aa1948719f4fd6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>While HTTP/3 specification is still in the draft stage, the latest version of the Chrome browser already  supports it by default. With Chrome holding around 70% of browser market share, you could say HTTP/3 has gone mainstream.</p><p>虽然HTTP/3规范还在起草阶段，但最新版本的Chrome浏览器已经默认支持它。Chrome占据了大约70%的浏览器市场份额，可以说HTTP/3已经成为主流。</p><p>  The new revision of this foundational protocol aims to make the web more efficient, secure, and shorten the content-delivery latencies. In some ways, it’s a braver take of HTTP2: similar goals addressed by replacing the underlying TCP protocol with a new, purpose-built protocol QUIC. The best way to explain the benefits of QUIC is to illustrate where TCP falls short as a transport for HTTP requests. And to do that, we’ll start at the very beginning.</p><p>这一基本协议的新修订旨在使网络更高效、更安全，并缩短内容交付延迟。在某些方面，这是对HTTP2的大胆尝试：通过用新的、专门构建的协议Quic替换底层TCP协议来实现类似的目标。解释Quic好处的最好方法是说明TCP作为HTTP请求传输的不足之处。要做到这一点，我们将从头开始。</p><p>  When Sir Tim Berners-Lee formalized the design of a simple  one-line hyper-text-exchange protocolin 1991, TCP was already an old, reliable protocol. The original definition document of what later became known as HTTP 0.9 specifically mentions TCP as a preferred, albeit not exclusive, transport protocol:</p><p>1991年，当Tim Berners-Lee爵士正式设计了一个简单的单行超文本交换协议时，TCP已经是一个古老、可靠的协议。后来被称为HTTP 0.9的原始定义文档特别提到TCP是首选的(尽管不是唯一的)传输协议：</p><p>  Of course, this proof-of-concept version of HTTP had very few similarities to HTTP we now know and love today. There were no headers and no status codes. The typical request was as simple as  GET /path. The response contained only HTML and ended with the closing of the TCP connection.Since browsers were not yet a thing, user was supposed to read HTML directly. It was possible to link to other resources, but none of the tags present in this early version of HTML requested additional resources asynchronously. A single HTTP request delivered a complete, self-sufficient page.</p><p>当然，这个概念验证版本的HTTP与我们今天所了解和喜爱的HTTP几乎没有相似之处。没有标头，也没有状态代码。典型的请求就像GET/PATH一样简单。响应只包含HTML，并以关闭TCP连接结束，因为浏览器还没有出现，用户应该直接阅读HTML。可以链接到其他资源，但是这个早期版本的HTML中没有一个标记异步请求额外的资源。单个HTTP请求提供了一个完整的、自给自足的页面。</p><p>  In subsequent years the internet has exploded, and HTTP evolved to be an extendable and flexible general-purpose protocol, although transporting HTML remained its chief specialty. There are three critical updates to HTTP that enabled this evolution:</p><p>在接下来的几年里，互联网呈爆炸式增长，HTTP发展成为一种可扩展和灵活的通用协议，尽管传输HTML仍然是它的主要专长。HTTP有三个关键更新实现了这一演变：</p><p> introduction of methods allowed the client to identify the type of action it wants to perform. For example, POST was created to allow client sending data to the server to process and store</p><p>方法的引入允许客户端识别它想要执行的操作类型。例如，创建POST是为了允许客户端将数据发送到服务器进行处理和存储。</p><p> status codes provided a way for client to confirm that the server has processed the request successfully, and if not - to understand what kind of error has occured</p><p>状态代码为客户端提供了一种方式，用于确认服务器已成功处理请求，如果未成功，则可了解发生了哪种错误。</p><p> headers added an ability to attach structured textual metadata to requests and responses that could modify the behavior of the client or server. Encoding and content-type headers, for example, allowed HTTP to transfer not just HTML, but any type of payload. “Compression” header allowed the client and server to negotiate supported compression formats, thus reducing the amount of data to transfer over the connection</p><p>Header添加了将结构化文本元数据附加到请求和响应的功能，这些请求和响应可能会修改客户端或服务器的行为。例如，编码和内容类型的报头不仅允许HTTP传输HTML，还允许传输任何类型的有效负载。“Compression”标头允许客户端和服务器协商支持的压缩格式，从而减少通过连接传输的数据量</p><p> At the same time, HTML advanced to support images, styles, and other linked resources. Browsers were now forced to perfrom multiple requests to display a single web page, which the original connection-per-request architecture was not designed to handle. Establishing and ending a TCP connection involves a lot of back-and-forth packet exchange, so it is relatively expensive in terms of latency overhead. It didn’t matter much when a web-page consisted of a single text file, but as the number of requests per page increased, so did the latency.</p><p>同时，HTML高级支持图像、样式和其他链接资源。浏览器现在被迫执行多个请求才能显示单个网页，而最初的按请求连接架构不能处理这一点。建立和结束TCP连接涉及大量来回分组交换，因此延迟开销相对较高。当网页由单个文本文件组成时，这并不重要，但是随着每页请求数量的增加，延迟也随之增加。</p><p> The picture below illustrates how much overhead was involved in establishing a new TCP connection per request.</p><p>下图说明了为每个请求建立新的TCP连接所涉及的开销。</p><p>  A “connection” header was created to address this problem. Client sends a request with “connection: keep-alive” header to signal intent to keep the TCP connection open for subsequent requests. If server understands this header and agrees to respect it, its response will also contain the “connection: keep-alive” header. This way, both parties maintain TCP channel open and use it for subsequent communication until either party decides to close it. This became even more important with the spread of SSL/TLS encryption, because negotianting an encryption algorithm and exchanging cryptographic keys requires an additional request/response cycle on each connection.</p><p>创建了一个“Connection”标头来解决此问题。客户端发送带有“Connection：Keep-Alive”报头的请求，以表示有意保持TCP连接打开以供后续请求使用。如果服务器理解此标头并同意尊重它，则其响应也将包含“Connection：Keep-Alive”标头。这样，双方都保持TCP通道打开，并将其用于后续通信，直到任何一方决定关闭它。随着SSL/TLS加密的普及，这一点变得更加重要，因为协商加密算法和交换密钥需要在每个连接上进行额外的请求/响应周期。</p><p>  At the time, many of the HTTP improvements appeared spontaneously. When a popular browser or a server app saw a need for a new HTTP feature, they would simply implement it themselves and hoped that other parties would follow the suit. Ironically, a decentralized web needed a centralized governing body to avoid fragmentation into incompatible pieces. Tim Berners-Lee, the original creator of the protocol, recognized the danger and founded the World Wide Web Consortium (W3C) in 1994, which together with the Internet Engineering Task Force (IETF) worked on formalizing stack of internet technologies. As the initial step to bring more structure to the existing environment, they documented the most common features used in HTTP at the time and named the resulting protocol HTTP/1.0. However, because this “specification” described varied, often inconsistent techniques as seen “in the wild”, it never received a status of a standard. Instead, the work on the new version of the HTTP protocol has begun.</p><p>当时，许多HTTP改进都是自发出现的。当流行的浏览器或服务器应用程序发现需要新的HTTP功能时，他们会简单地自己实现，并希望其他方也能效仿。具有讽刺意味的是，一个分散的网络需要一个集中的管理机构，以避免分裂成不兼容的部分。该协议的最初创建者Tim Berners-Lee认识到了这种危险，并在1994年成立了万维网联盟(W3C)，该联盟与互联网工程任务组(IETF)一起致力于使互联网技术栈正规化。作为给现有环境带来更多结构的第一步，他们记录了当时在HTTP中使用的最常见的特性，并将产生的协议命名为HTTP/1.0。然而，因为这个“规范”描述了各种各样的、经常不一致的技术，就像“在野外”看到的那样，它从未获得过标准的地位。相反，新版本的HTTP协议的工作已经开始。</p><p>  HTTP/1.1 fixed inconsistencies of HTTP/1.0 and adjusted the protocol to be more performant in the new web ecosystem. Two of the most critical changes introduced were the use of persistent TCP connections (keep-alive’s) by default and HTTP pipelining.</p><p>HTTP/1.1修复了HTTP/1.0的不一致性，并调整了协议，使其在新的Web生态系统中性能更佳。引入的两个最关键的更改是默认情况下使用持久TCP连接(Keep-Alive)和HTTP管道。</p><p> HTTP pipelining simply means that client does not need to wait for the server to respond to a request before sending subsequent HTTP requests. This feature resulted in even more efficient use of bandwidth and reduced latencies, but it could be improved even more. HTTP pipelining still requires from server to respond in the order of requests received, so if a single request in a pipeline is slow to fulfill, all subsequent responses to a client will be delayed accordingly. This problem is known as head-of-the-line blocking.</p><p>HTTP管道只是意味着客户端在发送后续HTTP请求之前不需要等待服务器响应请求。此功能可以更高效地使用带宽并减少延迟，但还可以进一步改进。HTTP流水线仍然要求服务器按照接收到的请求顺序进行响应，因此如果流水线中的单个请求完成速度较慢，则对客户端的所有后续响应都将相应延迟。此问题称为队头阻塞。</p><p>  At this point in time, the web is gaining more and more interactive capabilities. Web 2.0 is just around the corner, some webpages include dozens or even hundreds of external resources. To work around the head-of-the-line blocking, and to decrease page loading speeds, clients establish multiple TCP connections per host. Of course, the connection overhead never went anywhere. In reality, it got worse, since more and more applications encrypt HTTP traffic with SSL/TLS. So most browsers set the limit of maximal possible simultaneous connections in an attempt to strike a delicate balance.</p><p>在这个时间点上，网络获得了越来越多的交互功能。Web2.0即将到来，一些网页包含数十甚至数百个外部资源。为了避免队头阻塞并降低页面加载速度，客户端需要在每个主机上建立多个TCP连接。当然，连接开销从未发挥作用。实际上，情况变得更糟了，因为越来越多的应用程序使用SSL/TLS加密HTTP流量。因此，大多数浏览器都设置了最大可能同时连接的限制，试图达到微妙的平衡。</p><p> Many of the larger web-services have recognized that existing limitations are too restricting for their exceptionally heavy interactive web-applications, so they “gamed the system” by distributing their app through multiple domain names. It all worked, somehow, but the solution has been far from elegant.</p><p>许多较大的网络服务已经认识到，现有的限制对于它们异常繁重的交互式网络应用程序来说太有限了，所以他们通过通过多个域名分发应用程序来“玩弄系统”。不知何故，这一切都奏效了，但解决方案远非完美。</p><p> Despite a few shortcomings, the simplicity of HTTP/1.0 and HTTP/1.1 has made them widely successful, and for over a decade no one has made a serious attempt to change them.</p><p>尽管有一些缺点，但HTTP/1.0和HTTP/1.1的简单性使它们获得了广泛的成功，十多年来没有人认真尝试改变它们。</p><p>  In 2008 Google released the Chrome browser, which rapidly gained popularity for being quick and innovative. It has given Google a strong vote on matters of internet technologies. In the early 2010s, Google adds support for its web protocol SPDY to Chrome.</p><p>2008年，谷歌发布了Chrome浏览器，这款浏览器因其快速和创新而迅速流行起来。它让谷歌在互联网技术问题上投下了强有力的一票。在2010年代初，谷歌在Chrome上增加了对其网络协议SPDY的支持。</p><p> HTTP/2 standard was based on SPDY with some improvements. HTTP/2 solved the head-of-the-line blocking problem by multiplexing the HTTP requests over a single open TCP connection. This allowed server to answer requests in any order, client could then re-assemble the responses as it received them, making the whole exchange faster within a single connection.</p><p>HTTP/2标准是在SPDY的基础上做了一些改进。HTTP/2通过在单个开放的TCP连接上多路复用HTTP请求，解决了队头阻塞问题。这允许服务器以任何顺序响应请求，然后客户端可以在接收到响应时重新组装响应，从而在单个连接中使整个交换速度更快。</p><p>  In fact, with HTTP/2 server can serve the resources to a client before it even asked for it! To give an example, if the server knows that client will most likely need a stylesheet to display an HTML page, it can “push” the CSS to the client without waiting for a corresponding request. While beneficial in theory, this feature rarely seen in practice, since it requires a server to understand the structure of the HTML it serves, which is rarely the case.</p><p>事实上，使用HTTP/2，服务器甚至可以在客户端请求资源之前就将资源提供给客户端！举个例子，如果服务器知道客户端很可能需要样式表来显示HTML页面，它可以将CSS“推送”到客户端，而无需等待相应的请求。虽然在理论上是有益的，但这一特性在实践中很少见，因为它需要服务器理解它所服务的HTML的结构，而这种情况很少发生。</p><p> HTTP/2 also allows compressing request headers in addition to the request body, which further reduces the amount of data transferred over the wire.</p><p>除了请求正文之外，HTTP/2还允许压缩请求头，这进一步减少了通过线路传输的数据量。</p><p> HTTP/2 solved a lot of problems for the web, but not all of them. A similar type of head-of-the-line problem is still present on the level of TCP protocol, which remains a foundational building block of the web. When a TCP packet gets lost in transit, the receiver can’t acknowledge incoming packages until the lost package is re-sent by a server. Since TCP is by design oblivious to higher-level protocols like HTTP, a single lost packet will block the stream for all in-flight HTTP requests until the missing data is re-sent. This problem is especially prominent on an unreliable connection, which is not rare in the age of ubiquitous mobile devices.</p><p>HTTP/2为Web解决了很多问题，但不是全部。TCP协议层仍然存在类似类型的队头问题，它仍然是Web的基础构建块。当TCP数据包在传输过程中丢失时，在服务器重新发送丢失的数据包之前，接收方无法确认传入的数据包。由于TCP在设计上不受更高级别的协议(如HTTP)的影响，因此单个丢失的数据包将阻塞所有正在传输的HTTP请求的流，直到丢失的数据被重新发送。这个问题在不可靠的连接上尤为突出，在移动设备无处不在的时代，这并不罕见。</p><p>  Since issues with HTTP/2 can not be resolved purely on the application layer a new iteration of the protocol must update the transport layer. However, creating a new transport-layer protocol is not an easy task. Transport protocols need to be supported by hardware vendors and deployed by the majority of network operators, which are reluctant to update because of the costs and efforts involved. Take IPv6 as an example: it was introduced 24 years ago and is still far from being universally supported.</p><p>由于HTTP/2的问题不能完全在应用层解决，因此协议的新迭代必须更新传输层。但是，创建新的传输层协议并非易事。传输协议需要得到硬件供应商的支持，并由大多数网络运营商部署，但由于涉及的成本和努力，这些运营商不愿更新。以IPv6为例：它是24年前推出的，还远远没有得到普遍支持。</p><p> Fortunately, there is another option. UDP protocol is as widely supported as TCP but is simple enough to serve as a building block for custom protocols running on top of it. UDP packets are fire-and-forget: there are no handshakes, persistent connections, or error-correction. The primary idea behind HTTP3 is to abandon TCP in favor of a UDP-based QUIC protocol. QUIC adds the necessary features (those that were previously provided by TCP, and more) in a way that makes sense for the web environment.</p><p>幸运的是，还有另一个选择。UDP协议与TCP一样受到广泛支持，但它足够简单，可以作为在其上运行的自定义协议的构建块。UDP数据包是即发即忘：没有握手、持久连接或纠错。HTTP3背后的主要思想是放弃TCP，转而采用基于UDP的Quic协议。Quic以一种对Web环境有意义的方式添加了必要的功能(那些以前由TCP提供的功能，以及更多)。</p><p> Unlike HTTP2, which technically allowed an unencrypted communication, QUIC strictly requires encryption to establish a connection. Additionally, encryption is applied to all data flowing through the connection, not just the HTTP payload, which protects from the whole class of security issues. Establishing a persistent connection, negotiating an encryption protocol, and even sending the first batch of data are all merged into a single request/response cycle in QUIC, which reduces the connection latency dramatically. A connection to a known host can be re-established with a simplified handshake (0-RTT) if the client has cryptographical parameters cached locally.</p><p>与HTTP2不同，HTTP2在技术上允许未加密的通信，而Quic严格要求加密才能建立连接。此外，加密应用于流经该连接的所有数据，而不仅仅是HTTP有效负载，从而避免了整个类别的安全问题。在Quic中，建立持久连接、协商加密协议，甚至发送第一批数据都合并到单个请求/响应周期中，从而显著降低了连接延迟。如果客户端具有本地缓存的加密参数，则可以使用简化的握手(0-RTT)重新建立到已知主机的连接。</p><p> To address the transport-level head-of-the-line blocking issue, data transferred through QUIC connection is divided into streams. Streams are short-lived, independent “sub connections” within a persistent QUIC connection. Each stream handles its own error-correction and delivery guarantees but uses connection-global compression and encryption properties. Each client-initiated HTTP request operates on a separate stream, so losing a packet won’t affect data transfer for other streams/requests.</p><p>为了解决传输级的队头阻塞问题，通过Quic连接传输的数据被分成多个流。流是持久的Quic连接中短暂的、独立的“子连接”。每个流处理其自己的纠错和传送保证，但使用连接全局压缩和加密属性。每个客户端发起的HTTP请求都在单独的流上操作，因此丢失一个数据包不会影响其他流/请求的数据传输。</p><p>  UDP being a stateless protocol (a persistent connection is just an abstraction on top of it) enables QUIC to support features that largely ignore the intricacies of packet delivery. For example, the client changing its IP address mid-connection (like smartphone jumping from a mobile network to home wifi) should not, theoretically, disrupt a connection, because the protocol allows migrating between different IP addresses without reconnection.</p><p>UDP是一种无状态协议(持久连接只是其上的抽象)，使Quic能够支持在很大程度上忽略了数据包传递复杂性的功能。例如，客户端在连接过程中更改其IP地址(就像智能手机从移动网络跳到家庭WiFi一样)理论上不应该中断连接，因为该协议允许在不同IP地址之间迁移，而无需重新连接。</p><p> All existing implementations of the QUIC protocol currently run in userspace instead of OS kernel. Since both clients (e.g. browsers) and servers are typically updated more frequently than OS kernels, this will hopefully lead to faster adoption of new features.</p><p>目前，Quic协议的所有现有实现都运行在用户空间中，而不是操作系统内核中。由于客户端(例如浏览器)和服务器的更新通常都比操作系统内核更频繁，因此这有望更快地采用新功能。</p><p>  While HTTP/3 standard, in my opinion, is a big step ahead to faster and more secure internet, it’s not perfect. Some of its issues are caused by its novelty, while others seem to be inherent to the protocol.</p><p>虽然HTTP/3标准，在我看来，是迈向更快更安全的互联网的一大步，但它并不完美。它的一些问题是由其新颖性引起的，而另一些问题似乎是该议定书固有的。</p><p> TCP protocol has been around forever and it is very simple for routers to understand. It has clear unencrypted markers for setting up and closing down connections, which can be used to track and control existing sessions. Until networking hardware learns to understand the new protocol, it will see QUIC traffic simply as a stream of independent UDP packets, which will make networking configuration much trickier.</p><p>TCP协议由来已久，路由器很容易理解。它具有清晰的未加密标记，用于建立和关闭连接，可用于跟踪和控制现有会话。在网络硬件学会理解新协议之前，它将把Quic流量简单地视为独立的UDP数据包流，这将使网络配置变得复杂得多。</p><p> The ability to “revive” connections from a client-side cache opens the protocol to a replay attack: in certain situations, a malicious attacker can re-send previously captured packets that will be interpreted by a server as valid and coming from a victim. Many web servers, like those serving static content, would not be harmed by such an attack. Applications for which the attack scenario is valid must remember to disable the 0-RTT feature.</p><p>从客户端缓存“恢复”连接的能力使协议容易受到重播攻击：在某些情况下，恶意攻击者可以重新发送以前捕获的数据包，这些数据包将被服务器解释为有效的，并且来自受害者。许多Web服务器，就像那些提供静态内容的服务器一样，不会受到这样的攻击的损害。攻击场景有效的应用程序必须记住禁用0-RTT功能。</p><p> So that’s the story of HTTP so far. I see HTTP/3 as a huge step forward and certainly hope HTTP/3 will gain a wide adoption in the near future.</p><p>到目前为止，这就是HTTP的故事。我认为HTTP/3是向前迈出的一大步，当然希望HTTP/3能在不久的将来得到广泛采用。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://scorpil.com/post/the-long-road-to-http3/">https://scorpil.com/post/the-long-road-to-http3/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/http/">#http</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/road/">#road</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>