<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>作为计算的类型检查Type Checking as Calculation</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Type Checking as Calculation<br/>作为计算的类型检查</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 12:12:35</div><div class="page_narrow text-break page_content"><p>As I’ve said before, PyFL is functional programming for the rest of us. (It’s available at  pyflang.com.)</p><p>正如我之前所说，PyFL是我们其他人的函数式编程。（可在pyflang.com上找到。）</p><p> PyFL now has type checking – without type declarations. Instead the type is produced by evaluating the program over the domain of types.</p><p>PyFL现在有类型检查功能——没有类型声明。相反，类型是通过在类型域上评估程序而生成的。</p><p>   In PyFL gone are all the things that ordinary people find difficult or downright weird: monads, mandatory currying, post- or prefix notation, pattern matching, etc. Instead infix notation and  f(x,y,z) syntax for function application. The weird stuff has it’s proponents but PyFL proves it’s not inherently part of functional programming.</p><p>在PyFL中，所有普通人觉得困难或完全奇怪的事情都消失了：单子、强制咖喱、后置或前缀符号、模式匹配等，而不是函数应用的中缀符号和f（x，y，z）语法。这种奇怪的东西有它的支持者，但PyFL证明它并不是函数式编程的固有组成部分。</p><p> Gone in particular are cumbersome, verbose type declarations. In most examples of programming in Haskell it all begins with these declarations. In PyFL you skip this stage.</p><p>尤其是繁琐、冗长的类型声明。在Haskell的大多数编程示例中，都是从这些声明开始的。在PyFL中，你跳过了这个阶段。</p><p> That doesn’t mean you can e.g. multiply strings without hearing about it. PyFL is dynamically typed and checks at runtime if calculations make sense.</p><p>这并不意味着你可以在没有听说的情况下对字符串进行乘法。PyFL是动态类型的，并在运行时检查计算是否合理。</p><p> However runtime calculations mean you have to actually run the program to find these type errors – and be lucky enough to encounter them. They won’t necessarily reveal themselves every time out.</p><p>然而，运行时计算意味着您必须实际运行程序才能找到这些类型的错误——并且幸运地遇到它们。他们不一定每次都会暴露自己。</p><p> As one retired professional pointed out, you may release the software and then have tens of thousands of users running afoul of the dynamic type checker.</p><p>正如一位退休的专业人士所指出的，你可能会发布该软件，然后会有成千上万的用户与动态类型检查器发生冲突。</p><p> So there’s still a need for static analysis to avoid runtime errors. A need for compile time type checking.</p><p>因此，仍然需要进行静态分析以避免运行时错误。需要编译时类型检查。</p><p> But how do you type check a language with no type declarations? I really don’t want to add them – that would be a big retreat from the “for the rest of us” principle.</p><p>但是如何在没有类型声明的语言中进行类型检查呢？我真的不想再加上它们——那将是对“为我们其余人”原则的一次大倒退。</p><p> Fortunately there’s a solution – type inference. That means analyzing the program and deducing at least some of the types, without bothering the programmer.</p><p>幸运的是，有一个解决方案——类型推断。这意味着在不打扰程序员的情况下，分析程序并推断出至少一些类型。</p><p>  a + f(b) where a = 4; b = a+9; f(n) = if n&lt;2 then 1 else 3*f(n-1)+1 fi; end</p><p>a+f（b），其中a=4；b=a+9；f（n）=如果n&lt；2然后1其他3*f（n-1）+1 fi；终止</p><p> it’s obvious that  a is an integer, and from that that  b is as well. These facts follow from the basic type rule that the sum of two integers is an integer. There is no need for a declaration  b:int.</p><p>很明显，a是一个整数，因此b也是。这些事实源于两个整数之和是整数的基本类型规则。不需要声明b:int。</p><p> It also appears that  f(b) is an integer although at this stage it’s not clear how you would formally justify it. That’s the problem we’ll solve.</p><p>f（b）似乎也是一个整数，尽管在这个阶段还不清楚你将如何正式证明它。这就是我们要解决的问题。</p><p> Inferring a type is like calculation except you discard the actual data and combine types instead. Using rules like</p><p>推断类型与计算类似，只是放弃了实际数据，而是合并了类型。使用这样的规则</p><p> int + int = intnum + int = numint * int = intint / int = numnum &lt; num = boolif bool then int else int fi = int</p><p>int+int=intnum+int=numint*int=intint/int=numnum&lt；num=boolif bool然后int else int fi=int</p><p> Of course you lose information; in particular, you don’t know which arm of a conditional will be selected. This means evaluating recursive programs is problematic because they use conditionals to trigger termination.</p><p>当然你会失去信息；特别是，您不知道将选择条件的哪一个分支。这意味着计算递归程序是有问题的，因为它们使用条件来触发终止。</p><p>  Notice that this type scheme has both  int (integer) and  num (numeric). And notice that  int is also numeric, e..g.  num+int=num. Here  int is a subtype of  num. There are two other subtypes:  intlist is a subtype of  numlist which in turn is a subtype of  list. The head of an  intlist is an  int, the tail of a  numlist is a  numlist, and so on.</p><p>请注意，此类型方案同时包含int（整数）和num（数字）。注意int也是数字，例如。。g、 num+int=num。这里int是num的子类型。还有两个其他子类型：intlist是numlist的子类型，而numlist又是list的子类型。intlist的头是int，numlist的尾是numlist，依此类推。</p><p> Implementing this partial order required a lot of coding and I skipped having separate  stringlist and  wordlist types, not to mention  listlist. I wrote a function  sb(p,q) which tests if  p is a subtype of  q, and a function  lub(p,q) which gives the least upper bound of  p and  q.</p><p>实现这种偏序需要大量的编码，我没有使用单独的stringlist和wordlist类型，更不用说listlist了。我写了一个函数sb（p，q）来测试p是否是q的一个子类型，以及一个函数lub（p，q）来给出p和q的最小上界。</p><p> Clearly my domain falls far short of that necessary to imitate the fine distinctions of Haskell type declarations. For example, in Haskell you can declare a variable to be a list of lists of integers. I’d need an infinite partial order. But it works on a broad range of programs and catches a broad range of errors.</p><p>显然，我的领域远远没有达到模仿Haskell类型声明的细微差别所必需的水平。例如，在Haskell中，可以将变量声明为整数列表。我需要一个无限偏序。但它适用于范围广泛的程序，并捕捉到范围广泛的错误。</p><p>  So the plan I came up with is to take the PyFL evaluator and modify it so that instead of producing the actual data output by a program, it outputs the types produced by ‘running’ the program over the abstract domain of types. This is the basic idea of abstract interpretation and is hardly original with me.</p><p>因此，我提出的计划是使用PyFL计算器并对其进行修改，这样它就不会产生程序输出的实际数据，而是输出通过在抽象类型域上“运行”程序而产生的类型。这是抽象解释的基本思想，对我来说很难有独创性。</p><p> One of the advantages of this scheme is that not only does it avoid programmer type declarations, it avoids function types. Here is a higher order variant of the program given above</p><p>该方案的优点之一是，它不仅避免了程序员类型声明，还避免了函数类型。这是上面给出的程序的高阶变体</p><p> a + f(b)where db(g) = lambda (x) g(g(x)) end; inc(u) = u+2; f = db(inc); a = 4; b = 5;end</p><p>a+f（b），其中db（g）=λ（x）g（g（x））结束；inc（u）=u+2；f=db（公司）；a=4；b=5；终止</p><p> It evaluates to  int, in spite of the involvement of the second order function  db.</p><p>它的计算结果为int，尽管涉及二阶函数db。</p><p>  The problem with recursion is that the evaluation doesn’t terminate. This stumped me for a while.</p><p>递归的问题在于，计算不会终止。这让我有一段时间感到困惑。</p><p>   When run with the usual evaluator, it quickly gives the correct answer, 5040. The recursion terminated when the  if-then-else-fi finally selected the first alternative. But when running with the type evaluator, the  if condition was merely  bool and both alternatives had to be explored. This resulted in an infinite recursion, the python runtime stack overflowed, there was a segmentation fault and python crashed. Needless to say, no type information was produced</p><p>当使用通常的计算器运行时，它会迅速给出正确的答案5040。当if-then-else fi最终选择第一个备选方案时，递归终止。但是当使用类型计算器运行时，if条件仅仅是bool，必须探索这两种选择。这导致无限递归，python运行时堆栈溢出，出现分段错误，python崩溃。不用说，没有生成类型信息</p><p> In the meantime I’d added metrics to the evaluator, to see how much computation was generated. One of these metrics was the number of calls to the evaluation function. These additions were carried over to the alternate types-only evaluator.</p><p>与此同时，我向evaluator添加了度量，以查看生成了多少计算。其中一个指标是调用评估函数的次数。这些添加内容被转移到仅适用于替代类型的评估器中。</p><p> Finally it dawned on me that I could force termination by putting a cap on this metric – say, 30. I could see what the result was, then increase the cap, look at the new result, increase the cap again, until everything settled down.</p><p>最后，我意识到，我可以通过在这个指标上设置一个上限来强制终止——比如30。我可以看到结果是什么，然后增加上限，看看新的结果，再次增加上限，直到一切都安定下来。</p><p> This worked even better than I expected. I tried it on a similar scheme for  computing dimensionalities in pylucid and it turned out even small values of the cap gave correct answers.</p><p>这比我预想的还要好。我在pylucid中计算维度的类似方案上进行了尝试，结果发现即使是cap的小值也给出了正确的答案。</p><p> The puzzle here is that this scheme seems obvious yet I’ve never seen it in print. Or any discussion of how you avoid nontermination while evaluating over an alternate domain. Yet evaluating over an alternate domain is the basic idea of abstract interpretation. If anyone has any insight, please share with me.</p><p>这里的难题是，这个方案似乎显而易见，但我从未在印刷品中见过。或者任何关于如何在替代域上求值时避免非终止的讨论。然而，在另一个领域进行评估是抽象解释的基本思想。如果有人有任何见解，请与我分享。</p><p> So what I did was set a cap of 30 on the number of calls to the evaluate function. It turned out that 30 is a lot and I could have gotten away with a much smaller cap, but so what?</p><p>所以我把evaluate函数的调用次数设为30次。结果证明30是一个很大的数字，我本来可以用一个小得多的帽子逃脱，但那又怎样？</p><p> Now, when I run the type evaluator, it quickly halts and produces …  int, correct. It has succeeded in deducing that the factorial of an integer is an integer. Without programmer input.</p><p>现在，当我运行类型计算器时，它会快速停止并生成…int，正确。它成功地推断出整数的阶乘是整数。没有程序员的输入。</p><p>  The question arose, what does an evaluation return when it’s throttled? I guessed that it should return the bottom element of the type domain. Since there wasn’t a bottom element (yet) I added one: the type  none. The type  none is not the type of any data object. If you think of a type as a set (the set of all objects of that type), then  none is the empty set.</p><p>问题是，当一个评估被限制时，它会返回什么？我猜它应该返回类型域的底部元素。由于还没有一个底层元素，我添加了一个：类型none。类型none不是任何数据对象的类型。如果将一个类型视为一个集合（该类型的所有对象的集合），则“无”是空集。</p><p> I had to work out the rules for calculating with  none. Since  none is a subtype of, say,  num, it can function as a  num, so we have the rule  none+num=num. (And  none+none=none.)</p><p>我必须制定出无条件计算的规则。由于none是num的子类型，它可以作为num，所以我们有规则none+num=num（以及none+none=none）</p><p> Also if we are evaluating  f(x,y) and  f evaluates to  none, the result should be  none. I admit this was guesswork but it gives the right answers.</p><p>同样，如果我们计算f（x，y）并且f计算为无，结果应该是无。我承认这是猜测，但它给出了正确的答案。</p><p> This required rewriting  sb and  lub, which got fairly complex. If I want to expand my domain I’ll have to come up with something more systematic.</p><p>这需要重写sb和lub，这变得相当复杂。如果我想扩展我的领域，我必须想出更系统的方法。</p><p>  The factorial program works because recursion is built in to PyFL (and Haskell), the evaluator evaluates the definition of  fac in the same environment that it’s defined. But what if recursion wasn’t built in?Could we still define factorial? This was the problem facing the developers of the lambda calculus (which doesn’t have built-in recursion).</p><p>阶乘程序之所以有效，是因为PyFL（和Haskell）内置了递归，计算器在定义fac的相同环境中评估fac的定义。但如果递归不是内置的呢？我们还能定义阶乘吗？这就是lambda演算（没有内置递归）开发人员面临的问题。</p><p> At first it seemed unlikely. But then Curry invented the Y combinator. Here it is</p><p>起初，这似乎不太可能。但后来库里发明了Y组合器。给你</p><p>  It’s just a small \-expression with the magic property that Yf reduces to f(Yf). It has a rather nice definition in PyFL notation, namely</p><p>它只是一个小的表达式，具有神奇的性质，Yf减少到f（Yf）。它在PyFL符号中有一个很好的定义，即</p><p>  In this form it’s easy to see that it works. We substitute g for x in the equation and get g(g) = f(g(g)).</p><p>在这种形式下，很容易看出它是有效的。我们用g代替方程中的x，得到g（g）=f（g（g））。</p><p>  fac(7) where Y(f) = g(g) where g(x) = f(x(x)) end; a(f) = lambda (n) if n&lt;2 then 1 else n*f(n-1) fi end; fac = Y(a); end</p><p>式中Y（f）=g（g），其中g（x）=f（x（x））结束；a（f）=λ（n）如果n&lt；2然后1否则n*f（n-1）fi结束；fac=Y（a）；终止</p><p>  Note that this program is nonrecursive: no variable is defined directly or indirectly in terms of itself.</p><p>请注意，这个程序是非递归的：没有直接或间接地定义变量本身。</p><p> This program cannot be written in Haskell. It uses self application which can’t be typed. Obviously we can write factorial in Haskell, but not this way. We have to resort to Haskell’s built-in recursion, say with the definition  Y(f) = f(Y(f)).</p><p>这个程序不能用Haskell编写。它使用无法键入的自我应用程序。显然，我们可以用Haskell编写阶乘，但不是这样。我们必须求助于Haskell的内置递归，比如定义Y（f）=f（Y（f））。</p><p> Then the question arises, what about PyFL’s type checking? What happens when we evaluate the type of this program?</p><p>然后问题出现了，PyFL的类型检查呢？当我们评估这个项目的类型时会发生什么？</p><p>  To be honest, I wasn’t sure this would work. But in retrospect, if PyFL can handle the definition of Y over the integers, why not over types?</p><p>说实话，我不确定这是否管用。但是现在回想起来，如果PyFL可以处理Y在整数上的定义，为什么不能在类型上呢？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/checking/">#checking</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>