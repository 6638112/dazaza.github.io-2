<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>生锈速度与c Speed of Rust vs. C</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Speed of Rust vs. C<br/>生锈速度与c </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-13 12:33:54</div><div class="page_narrow text-break page_content"><p>The run-time speed and memory usage of programs written in Rust should about the same as of programs written in C, but overall programming style of these languages is different enough that it&#39;s hard to generalize their speed. This is a summary of where they&#39;re the same, where C is faster, and where Rust is faster.</p><p>用RURE编写的程序的运行时速度和内存使用应该与在C中编写的程序相同，但这些语言的整体编程风格足够多于它且难以概括其速度。这是它们的摘要＆＃39;重复，其中c更快，rust更快。</p><p> Disclaimer: It&#39;s not meant to be an objective benchmark uncovering indisputable truths about these languages. There&#39;s a significant difference between what these languages can achieve in theory, and how they&#39;re used in practice. This particular comparison is based on my own subjective experience that includes having deadlines, writing bugs, and being lazy. I&#39;ve been using Rust as my main language for over 4 years, and C for a decade before that. I&#39;m specifically comparing to just C here, as a comparison with C++ would have many more &#34;ifs&#34; and &#34;buts&#34; that I don&#39;t want to get into.</p><p> 免责声明：它并不意味着成为一个客观的基准，揭示了关于这些语言的无可争议的真理。这些语言在理论上实现的效果有什么显着差异，以及它们如何在实践中使用。这种特殊的比较是基于我自己的主观体验，包括截止日期，写作错误和懒惰。我一直在使用Rust作为我的主要语言超过4年，并且在此之前十年。我在这里特别比较了与c ++的比较，与c ++的比较将有更多＆＃34; ifs＆＃34;和＃34; BUTS＆＃34;我不想进入。</p><p>  Rust&#39;s abstractions are a double-edged sword. They can hide suboptimal code, but also make it easier to make algorithmic improvements and take advantage of highly optimized libraries.</p><p>  Rust＆＃39;抽象是一把双刃剑。它们可以隐藏次优代码，但也使得更容易进行算法改进并利用高度优化的库。</p><p> I&#39;m never worried that I&#39;m going to hit a performance dead-end with Rust. There&#39;s always the  unsafe escape hatch that allows very low-level optimizations (and it&#39;s not needed often).</p><p> 我从来没有担心我将用锈病击中表演死胡同。始终是不安全的逃生舱口，允许非常低级别的优化（并且它不需要经常需要）。</p><p> Fearless concurrency is real. The occasional awkwardness of the borrow checker pays off in making parallel programming  practical.</p><p> 无所畏惧的并发是真实的。借款检查员的偶尔尴尬地支付了并行编程实用。</p><p> My overall feeling is that if I could spend infinite time and effort, my C programs would be as fast or faster than Rust, because theoretically there&#39;s nothing C can&#39;t do that Rust can. But in practice C has less abstractions, primitive standard library, dreadful dependency situation, and I just don&#39;t have the time to reinvent the wheel, optimally, every time.</p><p> 我的整体感觉是，如果我能花无限的时间和努力，我的C程序就会比铁锈快或更快，因为理论上没有，没有C可以＆＃39; t做那种生锈可以。但在实践中，C具有更少的抽象，原始标准库，可怕的依赖情况，我只是没有时间在每次重塑车轮时重新发明。</p><p>  Both Rust and C give control over the layout of data structures, integer sizes, stack vs heap memory allocation, pointer indirections, and generally translate to understandable machine code with little &#34;magic&#34; inserted by the compiler. Rust even admits that bytes have 8 bits and signed numbers can overflow!</p><p>  rust和c都控制了数据结构的布局，整数大小，堆栈与堆内存分配，指针间接，并且通常转换为具有Little＆＃34的可理解机代码;魔术＆＃34;由编译器插入。 Rust甚至承认字节有8位，签名数字可以溢出！ </p><p> Even though Rust has higher-level constructs such as iterators, traits and other &#34;zero-cost abstractions&#34;, they&#39;re designed to predictably optimize to straightforward machine code. Memory layout of Rust&#39;s types is simple, e.g. growable strings and vectors are exactly  {data*, capacity, length}. Rust doesn&#39;t have any concept like move or copy constructors, so passing of objects is guaranteed to be no more complicated than passing a pointer or  memcpy.</p><p>尽管Rust具有更高级别的构造，如迭代器，特征和其他＆＃34;零成本抽象和＃34;它们＆＃39; Re设计用于可预见地优化直接的机器代码。 Rust＆＃39;类型的内存布局很简单，例如，可延长的字符串和矢量正是{数据*，容量，长度}。 RUDEN＆＃39; t有任何概念，如移动或复制构造函数，因此保证对象的传递比传递指针或memcpy更复杂。</p><p> Borrow-checking is only a compile-time static analysis. It doesn&#39;t  do anything, and lifetime information is even completely stripped out before code generation. There&#39;s no autoboxing or anything clever like that.</p><p> 借款只是一个编译时静态分析。它没有做任何事情，并且在代码生成之前甚至完全剥离了一生信息。没有自动拨射或任何类似的东西。</p><p> One case where Rust falls short of being &#34;dumb&#34; code generator is unwinding. While Rust doesn&#39;t use exceptions for normal error handling, a panic (unhandled fatal error) may optionally behave like a C++ exception. It can be disabled at compilation time (panic = abort), but even then Rust doesn&#39;t want other code to throw a C++ exceptions or use  longjmp over Rust&#39;s stack frames.</p><p> 一个尸体缺乏存在的一个案例＆＃34;愚蠢的＆＃34;代码生成器正在解除。虽然Rustn＆＃39; t使用例外用于正常误差处理，但恐慌（未处理的致命错误）可以选择类似于C ++异常。它可以在编译时间（Panic = abort）禁用，但即使是RURRN和＃39; T希望其他代码抛出C ++异常或使用LONGJMP＆＃39; s堆栈帧。</p><p>  Rust has a good integration with LLVM, so it supports Link-Time Optimization, including ThinLTO and even inlining across C/C++/Rust language boundaries. There&#39;s profile-guided optimization, too. Even though  rustc generates more verbose LLVM IR than  clang, the optimizer can still deal with it pretty well.</p><p>  Rust与LLVM具有良好的集成，因此它支持链路时间优化，包括跨越C / C ++ / Rust语言边界的ToLto甚至内联。在那里＆＃39; S简介者引导优化。尽管RustC产生了更详细的LLVM IR，但优化器仍然可以很好地处理它。</p><p> Some of my C code is a bit faster when compiled with GCC than LLVM, and there&#39;s no Rust front-end for GCC, so Rust misses out on that.</p><p> 当用GCC编译时，我的一些C代码比LLVM在内，而且没有用于GCC的铁锈前端，因此锈病错失了。</p><p> In theory, Rust allows even better optimizations than C thanks to stricter immutability and aliasing rules, but in practice this doesn&#39;t happen yet. Optimizations beyond what C does are an under-tested and under-developed in LLVM, so Rust always keeps waiting for one more bugfix to land in LLVM to reach its full potential.</p><p> 从理论上讲，由于更严格的不可变节和混叠规则，Rust甚至比C更好地优化，但在实践中，这并未发生。除了C的优化是在LLVM中的过度测试和开发的，因此RUDE始终继续等待更多的错误修正以达到LLVM以达到其全部潜力。</p><p>  Rust code is low-level and predictable enough that I can hand-tune what assembly it will optimize to. Rust supports SIMD intrinsics, gives control over inlining, calling conventions, etc. Rust is similar enough to C that C profilers usually work with Rust out of the box (e.g. I can use Xcode&#39;s Instruments on a program that&#39;s a Rust-C-Swift sandwich).</p><p>  RUDE代码是低级，可预测的足以我可以手术调整它将优化的装配。 RUTR支持SIMD内在机构，给予联系，呼叫约定等控制，锈病与C的C型分析仪通常与盒子中的RUST一起使用（例如，我可以使用Xcode＆＃39;＆＃39上的xcode＆＃39; SA Rust-C-Swift三明治）。 </p><p> In general, where the performance is absolutely critical and needs to be hand-optimized to the last bit, optimizing Rust isn&#39;t much different from C.</p><p>一般来说，在表现绝对关键的情况下，需要对最后一点进行手工优化，优化生锈ISN＆＃39; t与C不同。</p><p>  computed goto.  Sensible uses of regular  goto can be emulated with  loop {break} in Rust. A lot of uses of  goto in C are for cleanup, which Rust doesn&#39;t need. However, but there&#39;s a non-standard  goto extension that&#39;s very useful for interpreters. Rust can&#39;t do it (you can write a  match and  hope it&#39;ll optimize), but if I needed an interpreter, I&#39;d try to leverage  Cranelift JIT instead.</p><p>  计算到了。可以在RUDE中使用循环{断裂}仿真定期转到的明智使用。 CO中的大量用途是用于清理，其中RUDEN＆＃39; T需要。但是，但是在有一个非标准的GOTO延伸的非标准转移。＆＃39;非常有用的口译员。锈病＆＃39; t做它（你可以写一场比赛并希望它＆＃39; ll优化），但如果我需要翻译，我试图利用Cranelift Jit。</p><p> alloca and C99 variable-length arrays. These are controversial even in C, so Rust stays away from them.</p><p> AlloCa和C99可变长度阵列。即使在C中，这些是争议的，因此Rust远离他们。</p><p> It&#39;s worth noting that Rust currently supports only one 16-bit architecture. The  tier 1 support is focused on 32-bit and 64-bit platforms.</p><p> 值得注意的是，生锈目前只支持一个16位架构。第1层支持专注于32位和64位平台。</p><p>   Rust strongly prefers register-sized  usize rather than 32-bit  int. While Rust can use  i32 just as C can use  size_t, the defaults affect how the typical code is written.  usize is easier to optimize on 64-bit platforms without relying on undefined behavior, but the extra bits may put more pressure on registers and memory.</p><p>   RUDE强烈更喜欢注册大小的使用而不是32位INT。虽然Rust可以使用I32就像C可以使用size_t，但默认值会影响典型代码的写入方式。 Usize更容易在64位平台上优化，而无需依赖未定义的行为，但额外的位可能会对寄存器和内存进行更多压力。</p><p> Idiomatic Rust always passes pointer  and size for strings and slices. It wasn&#39;t until I ported a couple codebases from C to Rust, that I realized just how many C functions only take a pointer to memory, without a size, and hope for the best (the size is either known indirectly from the context, or just assumed to be large enough for the task).</p><p> 惯用锈蚀始终通过指针和串和切片的指针和大小。它是n＆＃39; t，直到我从c从c移植到生锈，我意识到只有多少c函数只拍摄到内存的指针，没有大小，并且希望最好的（大小是间接着图的背景，或者只是假设足够大的任务）。</p><p> Not all bounds checks are optimized out.  for item in arr or  arr.iter().for_each(…) are as efficient as they can be, but if the form  for i in 0..len {arr[i]} is needed, then performance depends on the LLVM optimizer being able to prove the length matches. Sometimes it can&#39;t, and the bound checks inhibit autovectorization. Of course, there are various workarounds for this, both safe and unsafe.</p><p> 并非所有绑定检查都经过优化。对于Arr或Arr.iter（）中的项目。for_each（...）与它们一样高效，但如果需要0的表单{arr [i]}，则性能取决于llvm优化器能够证明长度匹配。有时它可以＆＃39; t，绑定检查禁止自动侵入。当然，这是安全和不安全的各种解决方法。 </p><p> &#34;Clever&#34; memory use is frowned upon in Rust. In C, anything goes. For example, in C I&#39;d be tempted to reuse a buffer allocated for one purpose for another purpose later (a technique known as HEARTBLEED). It&#39;s convenient to have fixed-size buffers for variable-size data (e.g.  PATH_MAX) to avoid (re)allocation of growing buffers. Idiomatic Rust still gives a lot control over memory allocation, and can do basics like memory pools, combining multiple allocations into one, preallocating space, etc., but in general it steers users towards &#34;boring&#34; use or memory.</p><p>＆＃34;聪明＆＃34;内存用途是锈的。在c中，任何事情都会去。例如，在C i＆＃39中; d被诱惑重复使用分配的缓冲器，以便以后的另一个目的（一种称为Heartbleed的技术）。它与可变大小的数据（例如path_max）具有固定大小缓冲区的方便，以避免（重新）种植缓冲区的分配。惯用锈病仍然可以控制内存分配的批次，并且可以像内存池一样做基础，将多个分配与一个，预期空间等相结合，但通常它使用户朝向＆＃34;无聊＆＃34;使用或记忆。</p><p> In cases where borrow checking rules make things hard, the easy way out is to do extra copying or use reference counting. Over time I&#39;ve learned a bunch of borrow-checker tricks, and adjusted my coding style to be borrow-checker friendly, so this doesn&#39;t come up often any more. This never becomes a  major problem, because if necessary, there&#39;s always a fallback to &#34;raw&#34; pointers.</p><p> 在借用检查规则的情况下使事情变得艰难，简单的出路是做额外的复制或使用参考计数。随着时间的推移，我学到了一堆借款检查伎俩，并调整了我的编码风格来借来借阅 - 检查器友好，所以这不再有更多。这从来没有成为一个主要问题，因为如有必要，那里往返于＆＃34;生＆＃34;指针。</p><p> Rust&#39;s borrow checker is infamous for hating doubly-linked lists, but luckily it happens that linked lists are slow on 21st-century hardware anyway (poor cache locality, no vectorization). Rust&#39;s standard library has linked lists, as well as faster and borrow-checker-friendly containers to choose from.</p><p> Rust＆＃39;借用检查员是讨厌的，用于讨厌讨厌双链列表，但幸运的是，连接的列表在21世纪的硬件上慢慢（糟糕的缓存局部，没有矢量化）。 Rust＆＃39; S标准库有链表列表，以及更快，借阅验频友好的集装箱。</p><p> There are two more cases that the borrow checker can&#39;t tolerate: memory-mapped files (magical changes from outside of the process violate immutable^exclusive semantics of references) and self-referential structs (passing of the struct by value would make its inner pointers dangle). These cases are solved either with raw pointers that are as safe as every pointer in C, or mental gymnastics to make safe abstractions around them.</p><p> 借用检查员可以＆＃39; t容忍：内存映射的文件（从进程外部的神奇变更违反引用的独占语义）和自我参照结构（通过价值的传递将制作它的内部指针摇晃）。这些案件与原始指针一起解决，该指针与C或精神体操一样安全，以使它们保持安全的抽象。</p><p> To Rust, single-threaded programs just don&#39;t exist as a concept. Rust allows individual data structures to be non-thread-safe for performance, but anything that is allowed to be shared between threads (including global variables) has to be synchronized or marked as  unsafe.</p><p> 生锈，单线程程序只是不存在于概念。 RUST允许单个数据结构对性能无线安全，但允许在线程（包括全局变量）之间共享的任何内容必须同步或标记为不安全。</p><p> I keep forgetting that Rust&#39;s strings support some cheap in-place operations, such as  make_ascii_lowercase() (a direct equivalent of what I&#39;d do in C), and unnecessarily use Unicode-aware, copying  .to_lowercase(). Speaking of strings, the UTF-8 encoding is not as big of a problem as it may seem, because strings have  .as_bytes() view, so they can be processed in Unicode-ignorant way if needed.</p><p> 我一直忘记生锈＆＃39; s字符串支持一些廉价的地置操作，如make_ascii_lowercase（）（直接等同于我的直接等同于c），并且不必要地使用Unicode-Aware，复制.to_lowercase（ ）。谈到字符串，UTF-8编码并不像它看起来那么大的问题，因为字符串具有.as_bytes（）视图，因此如果需要，可以以Unicode忽略的方式处理它们。</p><p> libc bends over backwards to make  stdout and  putc reasonably fast. Rust&#39;s libstd has less magic, so I/O isn&#39;t buffered unless wrapped in a  BufWriter. I&#39;ve seen people complain that their Rust is slower than Python, and it was because Rust spent 99% of the time flushing the result byte by byte, exactly as told.</p><p> libc倒后来弯腰，使STDOUT和PUTC相当快。生锈＆＃39; S Libstd的魔法较少，所以我/ o isn＆＃39; t缓冲，除非包裹在bufwriter中。我看到的人抱怨他们的生锈比Python慢​​，它是因为逃避了99％的时间按字节冲洗结果字节，完全如此。 </p><p>  Every operating system ships some built-in standard C library that is ~30MB of code that C executables get for &#34;free&#34;, e.g. a &#34;Hello World&#34; C executable can&#39;t actually print anything, it only calls the  printf shipped with the OS. Rust can&#39;t count on OSes having  Rust&#39;s standard library built-in, so Rust executables bundle bits of the Rust&#39;s standard library (300KB or more). Fortunately, it&#39;s a one-time overhead. For embedded development, the standard library can be turned off and Rust will generate &#34;bare&#34; code.</p><p>每种操作系统都会填写一些内置的标准C库，即C可执行文件所获得的＆＃34;免费＆＃34 ;,,,,,,,, A＆＃34;你好世界＆＃34; C可执行可以＆＃39; t实际上打印任何内容，它只将打印机呼叫与操作系统一起发布。 Rust Can＆＃39; t计数含有Rust＆＃39; Salds标准图书馆内置的iS，所以Rust可执行文件束位的生锈＆＃39; S标准库（300kb或更高）。幸运的是，它是一次性开销。对于嵌入式开发，标准库可以关闭，生锈将生成＆＃34;裸＆＃34;代码。</p><p> On per-function basis Rust code is about the same size as C, but there&#39;s a problem of &#34;generics bloat&#34;. Generic functions get optimized versions for each type they&#39;re used with, so it&#39;s possible to end up with 8 versions of the same function.   cargo-bloat helps finding these.</p><p> 在每函数基础生锈代码上大小与C大小相同，但是在那里的一个问题＆＃34;泛型膨胀＆＃34;通用功能为每个类型的类型获取优化版本，它们与它们一起使用，所以它可能最终有8个版本的相同功能。货物膨胀有助于找到这些。</p><p> It&#39;s super easy to use dependencies in Rust. Similarly to JS/npm, there&#39;s a culture of making small single-purpose libraries, but they do add up. Eventually all my executables end up containing Unicode normalization tables, 7 different random number generators, and an HTTP/2 client with Brotli support.   cargo-tree is useful for deduping and culling them.</p><p> 它＆＃39; S超级易于使用锈蚀剂。与JS / NPM同样，在那里＆＃39;是制作小型单一目的库的文化，但他们会加起来。最终，所有可执行文件最终包含Unicode归一化表，7个不同的随机数生成器，以及带有Brotli支持的HTTP / 2客户端。货物树对复制和剔除它们是有用的。</p><p>  I&#39;ve talked a lot about overheads, but Rust also has places where it ends up more efficient and faster:</p><p>  我＆＃39;谈到了很多关于开销的大量，但Rust也有最终更高效和更快的地方：</p><p> C libraries typically return opaque pointers to their data structures, to hide implementation details and ensure there&#39;s only one copy of each instance of the struct. This costs heap allocations and pointer indirections. Rust&#39;s built-in privacy, unique ownership rules, and coding conventions let libraries expose their objects by value, so that library users decide whether to put them on the heap or on the stack. Objects on the stack can can be optimized very aggressively, and even optimized out entirely.</p><p> C库通常将不透明指针返回到其数据结构，以隐藏实现细节并确保只有一个结构实例的一个副本。此费用堆分配和指针间接。 Rust＆＃39;内置隐私，独特的所有权规则和编码约定让库按值暴露它们的对象，以便图书馆用户决定是否将它们放在堆上或堆栈上。堆栈上的对象可以非常积极地优化，甚至完全优化。</p><p> Rust by default can inline functions from the standard library, dependencies, and other compilation units. In C I&#39;m sometimes reluctant to split files or use libraries, because it affects inlining and requires micromanagement of headers and symbol visibility.</p><p> 默认生锈可以从标准库，依赖项和其他编译单位的内联函数。在C i＆＃39; m有时不愿意拆分文件或使用库，因为它会影响内嵌，并且需要标题和符号可见度的微单位。</p><p> Struct fields are reordered to minimize padding. Compiling C with  -Wpadding shows how often I forget about this detail.</p><p> struct字段重新排序以最小化填充。编译C与-WPadding显示我多久忘记此细节。 </p><p> Strings have their size encoded in their &#34;fat&#34; pointer. This makes length checks fast, eliminates risk of accidental O(n²) string loops, and allows making substrings in-place (e.g. splitting a string into tokens) without modifying memory or copying to add the  \0 terminator.</p><p>字符串在他们的＆＃34中编码了它们的尺寸;脂肪＆＃34;指针。这使得长度检查快速，消除了意外O（n²）串循环的风险，并允许在不修改内存或复制以添加\ 0终止器的情况下使子字符串放置（例如，将字符串拆分为令牌）。</p><p> Like C++ templates, Rust generates copies of generic code for each type they&#39;re used with, so functions like  sort() and containers like hash tables are always optimized for their type. In C I have to choose between hacks with macros or less efficient functions that work on  void* and variable sizes.</p><p> 与C ++模板一样，RUST为每个类型的副本生成通用代码的副本;重新使用，因此诸如SORT（）和像哈希表相同的容器等功能始终针对其类型进行优化。在C中，我必须在带有宏或较低的高效功能之间选择Hacks，这些功能在void *和可变大小上工作。</p><p> Rust iterators can be combined into chains that get optimized together as one unit. So instead of a series of calls  buy(it); use(it); break(it); change(it); mail(upgrade(it)); that may end up rewriting the same buffer many times, I can call  it.buy().use().break().change().upgrade().mail() that compiles to one  buy_use_break_change_mail_upgrade(it) optimized to do all of that in a single combined pass.  (0..1000).map(|x| x*2).sum() compiles to  return 999000.</p><p> 防锈迭代器可以组合成链式以单位优化的链接。所以而不是一系列电话购买（它）;用它）;打破它）;更改）;邮件（升级（IT））;最终可能最终重写相同的缓冲区，我可以称之为。所有这一切都在一个组合通过。 （0..1000）.map（| x | x * 2）.sum（）编译返回999000。</p><p> Similarly, there are  Read and  Write interfaces that allow functions to stream unbuffered data. They combine nicely, so I can write data to a stream that calculates CRC of the data on the fly, adds framing/escaping if needed, compresses it, and writes it to the network, all in one call. And I can pass such combined stream as an output stream to my HTML templating engine, so now each HTML tag will be smart enough to send itself compressed. The underlying mechanism is just a pyramid of plain  next_stream.write(bytes) calls, so technically nothing stops me from doing the same in C, except the lack of traits and generics in C means it&#39;s very hard to actually do that in practice, other than with callbacks set up at run time, which isn&#39;t as efficient.</p><p> 同样，读取和编写接口允许函数流传输无缓冲的数据。它们很好地组合，因此我可以将数据写入一条流，从而在飞行中计算数据的CRC，如果需要，将框架/逃逸添加，压缩它，并将其写入网络，所有在一个呼叫中。并且我可以将这样的组合流作为输出流传递给我的HTML模板引擎，因此现在每个HTML标记都将足够智能地发送自身压缩。底层机制只是普通的金字塔旁边的lead_stream.write（字节）呼叫，所以技术上没有什么能阻止我在c中做同样的事情，除了缺乏特征和泛型的c意味着它＆＃39;非常难以实际做到这一点在实践中，除了在运行时建立回调，哪个是高效的。</p><p> In C it&#39;s perfectly rational to use linear search most of the time, because who&#39;s going to maintain a billionth half-assed implementation of hash table? There are no built-in containers, dependencies are a pain, so I write ad-hoc linked lists and cut corners all the time. Unless absolutely necessary, I won&#39;t bother to write a sophisticated implementation of a B-tree. I&#39;ll use  qsort +  bisect and call it a day. OTOH in Rust it takes only 1 or 2 lines of code to get very high quality implementations all kinds of containers. This means that my Rust programs can afford to use proper, incredibly well-optimized data structures  every time.</p><p> 在C它中，大多数时候都非常合理地使用线性搜索，因为谁将保持哈希表的十亿分半例行实施？没有内置容器，依赖关系是一种痛苦，所以我写下ad-hoc链接列表并一直剪切角落。除非绝对必要，否则我赢得了＆＃39; t and and tring写一个复杂的b树的实现。我＆＃39; ll使用qsort + bisect并调用一天。 OTOH在Rust中只需要1或2行代码来获得非常高质量的实现各种容器。这意味着我的生锈程序每次都可以使用适当，令人难以置信的优化数据结构。</p><p> These days everything seems to require JSON. Rust&#39;s  serde is one of the fastest JSON parsers in the world, and it parses directly into Rust structs, so use of the parsed data is very fast and efficient, too.</p><p> 这几天似乎一切都需要JSON。 Rust＆＃39; serde是世界上最快的JSOS解析器之一，它将直接解析为锈迹，因此使用解析的数据也非常快速，有效。</p><p>  Rust enforces thread-safety of all code and data, even in 3rd party libraries, even if authors of that code didn&#39;t pay attention to thread safety. Everything either upholds specific thread-safety guarantees, or won&#39;t be allowed to be used across threads. If I write any code that is not thread safe, the compiler will point out exactly where it is unsafe.</p><p>  Rust强制执行所有代码和数据的线程安全，即使在第三方库中，即使该代码的作者没有注意螺纹安全性。一切都是坚持特定的线程安全保证，或者允许跨线使用＆＃39;如果我编写任何没有线程安全的代码，则编译器将指向它不安全的位置。 </p><p> That&#39;s a dramatically different situation than C. Usually no library functions can be trusted to be thread-safe unless they&#39;re clearly documented otherwise. It&#39;s up to the programmer to ensure all of the code is correct, and the compiler generally can&#39;t help with any of this. Multi-threaded C code carries a lot more responsibility, a lot more risk, so it&#39;s appealing to pretend multi-core CPUs are just a fad, and imagine users have better things to do with the remaining 7 or 15 cores.</p><p>那个＆＃39;■显着不同的情况。通常没有库函数可以信任线程安全，除非它们＆＃39;否则清楚地记录。它＆＃39; s到程序员，以确保所有代码都是正确的，并且编译器通常可以＆＃39; t帮助任何一个。多线程C代码承担了更多的责任，风险更多，所以它的吸引力假装多核CPU只是一个FAD，想象用户与剩下的7或15个核心有更好的事情。</p><p> Rust guarantees freedom from data races and memory unsafety (e.g. use-after-free bugs, even across threads). Not just some races that could be found with heuristics or at runtime in instrumented builds, but  all data races everywhere. This is life-saving, because the data races are the worst kind of concurrency bugs. They&#39;ll happen on my users&#39; machines, but not in my debugger. There are other kinds of concurrency bugs, such as poor use of locking primitives causing higher-level logical race conditions or deadlocks, and Rust can&#39;t eliminate them, but they&#39;re usually easier to diagnose and fix.</p><p> RUDR保证自由于数据种族和记忆不安全（例如，使用欠缺的错误，即使是线程）。不仅仅是一些可以用启发式或在instressed构建的运行时找到的种族，但所有数据都在任何地方种族。这是救命，因为数据竞争是最糟糕的并发错误。他们＆＃39; ll在我的用户身上发生＆＃39;机器，但不是在我的调试器中。还有其他种类的并发虫子，如使用锁定原语的差，导致更高级别的逻辑竞争条件或死锁，而且生锈可以消除它们，但它们通常更容易诊断和修复。</p><p> In C I won&#39;t dare to do more than a couple of OpenMP pragmas on simple  for loops. I&#39;ve tried being more adventurous with tasks and threads, and ended up regretting it every time.</p><p> 在C我赢得了＆＃39;敢于在简单的循环上做几个以上的OpenMP Pragmas。我试着用任务和线程更加冒险，并最终每次后悔后悔。</p><p> Rust has has good libraries for data parallelism, thread pools, queues, tasks, lock-free data structures, etc. With the help of such building blocks, and the strong safety net of the type system, I can parallelize Rust programs quite easily. In some cases it&#39;s sufficient to replace  iter() with  par_iter(), and if it compiles, it works! It&#39;s not always a linear speed-up (Amdahl&#39;s law is brutal), but it&#39;s often a 2×-3× speed-up for relatively little work.</p><p> rust有很好的数据并行，线程池，队列，任务，无锁数据结构等。在这种构建块的帮助下，以及类型系统的强大安全网，我可以很容易地平行锈迹。在某些情况下，它有足以用par_iter（）替换erter（），如果它编译，它可以工作！它并不总是一个线性加速（Amdahl＆＃39;法律是残酷的），但它往往是2×-3×速度相对较少的工作。</p><p> There&#39;s an interesting difference how Rust and C libraries document thread-safety. Rust has a vocabulary for specific aspects of thread-safety, such as  Send and  Sync, guards and cells. In C, there&#39;s no word for &#34;you can allocate it on one thread, and free it on another thread, but you can&#39;t use it from two threads at once&#34;. Rust describes thread-safety in terms of data types, which generalizes to all functions using them. In C thread-safety is talked about in the context of individual functions and flags. Rust&#39;s guarantees tend to be compile-time, or at least unconditional. In C it&#39;s common to find &#34;this is thread safe only when the turboblub option is set to 7&#34;.</p><p> 有一个有趣的差异，如何生锈和C图书馆文件线程安全。 Rust有一个词汇表，用于线程安全的具体方面，例如发送和同步，防护和细胞。在C，有没有任何词＆＃34;你可以在一个线程上分配它，并在另一个线程上释放它，但是你可以＆＃39; t一次使用两个线程＆＃34; RUTR描述了在数据类型方面的线程安全，这概括了使用它们的所有功能。在C线程中，在各个函数和标志的上下文中讨论了谈论。生锈＆＃39; s保证往往是编制的，或至少无条件。在c它中，＆＃39;常见的是查找＆＃34;这只是当涡轮喷油尺寸设置为7＆＃34时的线程安全。</p><p>  Rust is low-level enough that if necessary, it can be optimized for maximum performance just as well as C. Higher-level abstractions, easy memory management, and abundance of available libraries tend to make Rust programs have more code, do more, and if left unchecked, can add up to bloat. However, Rust programs also optimize quite well, sometimes better than C. While C is good for writing minimal code on byte-by-byte pointer-by-pointer level, Rust has powerful features for efficiently combining multiple functions or even whole libraries together.</p><p>  Rust是低水平的，如有必要，可以针对最大性能优化，以及C.高级抽象，简单的内存管理和可用库的丰富，往往会使Rust程序有更多的代码，做更多，做更多的措施如果未选中，可以加起来膨胀。然而，Rust程序也很好地优化，有时优于C.虽然C对于在Byte-Byte指针逐个级别写入最小代码，但RURR具有强大的功能，可有效地将多个功能或甚至整个库结合在一起。</p><p> But the biggest potential is in ability to fearlessly parallelize majority of Rust code, even when the equivalent C code would be too risky to parallelize. In this aspect Rust is a much more mature language than C.</p><p> 但是，即使当量的C代码过于冒险，最大的潜力也能够无所畏惧地并行化大多数生锈代码。在这个方面，Rust是一种比C更成熟的语言。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kornel.ski/rust-c-speed">https://kornel.ski/rust-c-speed</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/speed/">#speed</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>