<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Riak中CRDT的模糊指南(2013)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Riak中CRDT的模糊指南(2013)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 22:42:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2020/10/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Riak 1.4 included counters. This was a break from the norm inRiak. We’ve always said: “Your data is opaque to Riak”, but withcounters that isn’t true. Riak knows what you’re storing against acounter key, and how to increment it and decrement it. You tell Riakthis with the counter API. You never fetch, mutate and put a counter,you just say:  increment by 5 or  decrement by 100. You never send avclock and most importantly, Riak knows how to merge concurrent writesto a counter. You never see siblings for a counter, you always see asingle value. No writes are lost and eventually, the counter willreflect all writes and reach a consistent value.</p><p>Riak1.4包括计数器。这是里亚克打破常规的一次突破。我们总是说：“你的数据对Riak来说是不透明的”，但反驳说这不是真的。Riak知道您针对Counter Key存储的内容，以及如何递增和递减。你用计数器API告诉Riakthis。您永远不会获取、变异和放置计数器，您只需说：递增5或递减100。您从不发送avlock，最重要的是，Riak知道如何将并发写入合并到计数器。你永远不会看到计数器的兄弟姐妹，你总是看到一个单一的值。不会丢失任何写入，最终，计数器将反映所有写入并达到一致的值。</p><p>  Counters are OK, but you can’t build many application on justcounters. For Riak 2.0 we’ve add some more data types. We believe withthe addition of these data types you can model many applications’ datastorage needs with greater simplicity, and never have to write siblingmerge functions again.</p><p>计数器是可以的，但是您不能仅仅在计数器上构建很多应用程序。对于Riak2.0，我们添加了一些更多的数据类型。我们相信，通过添加这些数据类型，您可以更加简单地对许多应用程序的数据存储需求进行建模，而不必再编写兄弟合并函数。</p><p>  When we’ve talked in the past about adding data types to Riak we’vespoken about  CRDTs. CRDT stands for (variously) Conflict-freeReplicated Data Type, Convergent Replicated Data Type, CommutativeReplicated Data Type, and maybe others. The key, repeated phrase showsthat we’re dealing with Replicated Data Types.</p><p>当我们在过去讨论向Riak添加数据类型时，我们谈到了CRDT。CRDT代表(不同的)无冲突复制数据类型、收敛复制数据类型、交换复制数据类型等。关键的、重复的短语表明，我们正在处理复制的数据类型。</p><p> Replication is normal for Riak. It is what the N-Value defines. DataTypes are pretty common in computing. Sets, Bags, Lists, Registers,Maps, Counters…etc. That leaves us with the C to deal with.</p><p>复制对于Riak来说是正常的。它是N值定义的。数据类型在计算中相当常见。集合、袋子、列表、寄存器、地图、计数器…。等等。这样我们就只剩下C来处理了。</p><p>  State based, or Convergent CRDTs were thought up 15 years ago byCarlos Baquero and Franciso Moura[1] as an application of somethingcalled a Join Semi-Lattice: A triple of a Partially Ordered Set, aLeast Element (Bottom hehehehehe) and a function that produces a LeastUpper Bound. This function must be idempotent, associative, andcommutative and when applied to two Sets returns a merged, or leastupper bound Set that is also an instance of the Partially Ordered Set.</p><p>15年前，卡洛斯·巴奎罗(Carlos Baquero)和弗朗西索·穆拉(Franciso Moura)提出了基于状态(或收敛CRDT)的CRDT，作为一种称为连接半格的东西的应用：偏序集合的三元组、最小元素(底层呵呵)和一个产生最小上界的函数。此函数必须是幂等、结合和可交换的，并且当应用于两个集合时，返回一个合并的或至少上界的集合，该集合也是偏序集合的实例。</p><p>   Riak is an eventually consistent system. It leans very much toward theAP end of the CAP spectrum. We achieve this Availability with thingslike sloppy quorum writes to fallback nodes. However, even withoutpartitions and many nodes, interleaved or concurrent writes can leadto conflicts. Traditionally Riak keeps all values and presents them tothe user to resolve. The client application must have a deterministicway to resolve conflicts. It might be to pick the highest timestamp,or union all the values in a list, or something more complex. Whatever it does, it is ad hoc, and created specifically for the datamodel and application at hand. But it must look just like that LUBfunction of the Join Semi-Lattice: It must be idempotent, commutative,and associative.</p><p>Riak是一个最终一致的系统。它非常倾向于CAP频谱的AP端。我们通过向备用节点执行草率仲裁写入之类的操作来实现此可用性。但是，即使没有分区和许多节点，交叉或并发写入也可能导致冲突。传统上，Riak保留所有值并将它们呈现给用户进行解析。客户端应用程序必须具有解决冲突的确定性方法。它可能是选择最高的时间戳，或者联合列表中的所有值，或者执行更复杂的操作。无论它做什么，它都是临时的，并且是专门为手头的数据模型和应用程序创建的。但是它必须看起来就像JOIN半格的LUB函数：它必须是幂等的、可交换的和结合的。</p><p>  In Riak, the Conflict-free C is kind of a lie. There’s still conflict,it is just that the resolution is part of the data types&#39; design. Ofall the C’s above, Convergent is the one that matters to us. The datatypes we’ve created for Riak converge automatically, at write and readtime, on the server. If a client application can model its data usingthe data types we provide, they will never see sibling values or needto write ad hoc, custom merge functions.</p><p>在Riak中，没有冲突的C是一种谎言。仍然存在冲突，只是解决方案是数据类型设计的一部分。在所有以上的C中，Convergent对我们来说才是最重要的。我们为Riak创建的数据类型在写入和读取时在服务器上自动收敛。如果客户端应用程序可以使用我们提供的数据类型对其数据进行建模，它们将永远不会看到兄弟关系值，也不需要编写特殊的自定义合并函数。</p><p>  If you’re storing data in Riak, and you have  allow_mult set to true, then you need to handle conflicting writes. If you have tohandle it in your code you have to either simplify your data model orcode complex merge functions.</p><p>如果您在Riak中存储数据，并且将ALLOW_MULT设置为TRUE，那么您需要处理冲突的写入。如果您必须在代码中处理它，则必须简化数据模型或编写复杂的合并函数。</p><p>  The classic example from the dynamo paper[2] is the Amazon shoppingcart. A single user adds two items to their cart, both adds hitdifferent partitioned servers. There are now two carts one with item A and one with item  B. The merge logic is simple: union the cartsto get a single correct value. But what of removes? How can you tellif item  A is absent from cart two because it was added by  A andnot yet seen, or removed from cart two and cart one was unaware?</p><p>“发电机报”[2]中的经典例子是亚马逊购物车。单个用户向购物车添加两个项目，这两个项目都添加了不同分区的服务器。现在有两个购物车，一个装有物品A，另一个装有物品B。合并逻辑很简单：联合购物车以获得单个正确的值。但是去掉的又是什么呢？如果物品A是由A添加的而还没有看到，或者是从第二车和第一车中移走而没有意识到，你怎么能说它不在第二车中呢？</p><p> Maybe your application is slightly more complex, you need to add acount of how  many of each item are in the cart. Now your mergefunction has to decide when presented with 6 instances of “hairbrush”in one sibling and 4 in another if the user added 6 and then removed 2or added 4 and then added 2 more. Maybe you start to addtombstones. Or record operations (like StateBox.) But quickly it getscomplex. And what if you need to record more information, or evolveyour data model, your merge function must grow, adapt, work ondifferent versions of your data? It becomes very complex very quickly.</p><p>也许您的应用程序稍微复杂一些，您需要添加购物车中每件商品的数量。现在，您的合并函数必须决定何时在一个同级中显示6个“发刷”实例，在另一个同级中显示4个实例，如果用户添加了6个，然后删除了2个，或者添加了4个，然后又添加了2个。也许你开始添加墓碑了。或记录操作(如StateBox。)。但很快就变得复杂起来。如果您需要记录更多信息，或者需要改进您的数据模型，那么您的合并功能必须扩展、调整和处理不同版本的数据，该怎么办呢？它很快就会变得非常复杂。</p><p> And every new data model needs new ad hoc merge functions And when youcome to store some other data in Riak, say user profiles, you need tostart from scratch building up your data model and merge logic.</p><p>而且每个新的数据模型都需要新的即席合并功能，当您要在Riak中存储一些其他数据时，比如用户配置文件，您需要从头开始构建您的数据模型和合并逻辑。</p><p>  When modeling an application’s domain in a programming languagedevelopers are used to composing state from a few primitive datatypes, like Sets, Maps, Registers, Integers, Booleans etc. Data Typesin Riak give the developer back that power and expressivity, andrelieve them of the burden of designing and testing deterministicmerge functions. The key is that the data is no longer opaque toRiak. When you use the Data Types API Riak “knows” what type of thingyou are storing and is able to perform that semantic merge foryou. Riak already detects conflicts, with Data Types it is able tomerge them too.</p><p>当用编程语言建模应用程序的领域时，开发人员习惯于从一些原始数据类型(如集合、映射、寄存器、整数、布尔值等)组成状态。Riak中的数据类型使开发人员恢复了这种能力和表现力，并减轻了他们设计和测试确定性合并函数的负担。关键是数据对于Riak来说不再是不透明的。当您使用数据类型时，API Riak“知道”您存储的是什么类型的数据，并且能够为您执行语义合并。Riak已经检测到了冲突，它也能够利用数据类型来处理冲突。</p><p> When reading a Data Type value you will only ever see a singlevalue. That value is still Eventually Consistent, but it will be ascorrect as it can be given the amount of entropy in the database, andwhen the system is quiescent, all values will converge on a single,deterministic, correct value.</p><p>读取数据类型值时，您将只看到单个值。该值最终仍然是一致的，但它将是正确的，因为它可以被赋予数据库中的熵量，并且当系统处于静止状态时，所有的值都将收敛到单一的、确定的、正确的值。</p><p>  We have some Data Types that you can store against a Key in Riak, thatwe’re calling Top Level Types.</p><p>我们有一些数据类型可以根据Riak中的键存储，我们称之为顶级类型。</p><p>  Sets: Which are collections of things. In Riak we expect you tostore binaries, which is how we encode Strings of text in Erlang. Thekind of thing you’d store in a Set might be the members of a team ordepartment, followers on social network, or maybe objects in some realworld collection.</p><p>集合：它们是事物的集合。在Riak中，我们希望您存储二进制文件，这就是我们在Erlang中编码文本字符串的方式。你存储在集合中的东西可能是团队或部门的成员，社交网络上的追随者，也可能是现实世界收藏中的物品。</p><p> Maps. A Map is way to compose Data Types into a richer, more complexstructure. A Map is a collection of fields. A field is a name and DataType pair. This is so that we don’t have to deal with merging fieldsof a different type. If two fields with the same name but differenttypes are added to a Map, then they’re two different fields. You mayonly store Data Types in a Map.</p><p>地图。映射是将数据类型组合成更丰富、更复杂结构的方法。映射是字段的集合。字段是名称和数据类型对。这样我们就不必处理合并不同类型的字段。如果将两个同名但类型不同的字段添加到地图中，则它们是两个不同的字段。您只能在地图中存储数据类型。</p><p>  You can store any of the top level types in a field in a Map,including a Map. And we’ve also added:-</p><p>您可以将任何顶级类型存储在Map的字段中，包括Map。我们还增加了：</p><p>   The semantics for each of these data types differs from their regular,linear counterparts. Though we think the semantics we have chosen arethe most intuitive and useful, and least surprising.</p><p>这些数据类型中的每一种的语义都不同于它们的常规线性对应类型。虽然我们认为我们选择的语义是最直观、最有用的，也是最不令人惊讶的。</p><p>  Since we’re storing our data types in Riak, (in riak_objects even) allthe trade offs of Eventual Consistency apply (except of courseconflict resolution.) That means that the Counters are not forcreating unique, ordered IDs. And Sets and Maps do not have the atomicand blocking operations of their Redis counterparts.</p><p>因为我们将数据类型存储在Riak中(甚至在riak_Objects中)，所以最终一致性的所有权衡都适用(当然，第二次解析除外)。这意味着计数器不用于创建唯一的有序ID。而且Set和Map没有Redis对应物的原子和阻塞操作。</p><p>  Nothing has changed for counters. They’re still not idempotent. IfRiak returns an Error for a counter operation, it may have onlypartially failed, and a retry may lead to a double count. However,adding an element to a Set, or a Field to a Map is idempotent.</p><p>柜台没有任何变化。它们仍然不是幂等的。如果Riak为计数器操作返回错误，则可能只是部分失败，重试可能导致重复计数。但是，将元素添加到集合或将字段添加到映射是幂等的。</p><p>  The semantic we’ve chosen for the Set and Map is “Add Wins”. Theliterature also calls this “Observed Remove” but that is animplementation detail of how the Add Wins (and I’ll cover it below.)</p><p>我们为Set和Map选择的语义是“add wins”。本文也将此称为“观察到的移除”，但这是Add如何取胜的实现细节(我将在下面介绍它)。</p><p>  When any pair of operations on a Set are concurrent, and one adds anelement, while the other removes it, the add wins. If the removecausally follows the Add, then the Remove is effective. Concurrentoperations on different elements work as you’d expect.</p><p>当集合上的任何一对操作是并发的，其中一对添加元素，而另一对删除元素时，添加操作获胜。如果删除操作紧跟在添加操作之后，则删除操作有效。不同元素上的并发操作的工作方式与您的预期不谋而合。</p><p>  The Map borrows its behaviour directly from the Set. Except that everytime you update the contents of a field (say increment the counter inthe “likes” field, or add a buddy to the “follows” field) then thatcounts as “adding” the field. This way a concurrent removal of a fieldwith an update to a field will see the update winning. Add wins again.</p><p>地图直接从集合中借用其行为。除了每次更新字段的内容(比如，在“Like”字段中增加计数器，或者在“Folders”字段中添加好友)，这将被视为“添加”该字段。这样，同时删除字段和更新字段将使更新获胜。再加一次赢。</p><p> The difficult to answer question is what should the value of a fieldbe when it is concurrently updated and removed. The answer is that theupdate wins, and the field remains, and it’s value is that of allsurviving replicas’ merged.</p><p>难以回答的问题是，当字段同时更新和删除时，它的值应该是什么。答案是更新获胜，字段保留，它的值是所有幸存的副本合并后的值。</p><p> Say a counter in a Map field is incremented to 5 at replica A andreplicated to B and C. Concurrently the counter field is removed fromA and incremented by 3 at C, the merged value will be 8. That is tosay the remove at A does not reverse all A’s previous actions.</p><p>假设Map字段中的计数器在副本A处递增到5，并复制到B和C。同时，计数器字段从A中移除并在C处递增3，合并值将为8。也就是说，在A处移除不会逆转A之前的所有操作。</p><p> There is something surprising and imperfect about this semantic. If Ahad incremented the counter by 2 after it was partitioned from C butbefore it removed the counter field, that update is lost. Only thevalues that B and C have seen for A will remain. Removes are tricky.</p><p>这个语义有一些令人惊讶和不完善的地方。如果AHAD在从C分区之后但在删除计数器字段之前将计数器递增2，则更新将丢失。只有B和C看到的A的值将保持不变。删除是很棘手的。</p><p> There is another odd edge from removes that may also besurprising. Imagine that concurrently Replica A coordinates a removalof a Set Field from a Map while Replica B coordinates the removal ofall elements from that same Set. As per the rules above, field updatescount as “Adds” (for the add wins semantic) so the Field remains inthe Map, albeit as an empty Set.</p><p>从撤军中还有另一个奇怪的优势，可能也会令人望而生畏。想象一下，副本A同时协调从地图中删除集合字段，而副本B协调删除同一集合中的所有元素。根据上面的规则，字段updatescount为“add”(对于add wins语义)，因此该字段仍然保留在Map中，尽管它是一个空集。</p><p>  These Map only types have simple semantics. The Register is Last WriteWins, using a timestamp on the node handling the write. All thecaveats about clock synchronization therefore apply. Flags start outOff, and you can turn them On. For any pair of concurrent, conflictingoperations (On | Off) On wins. Again, that same Add Wins semantic.</p><p>这些仅映射类型具有简单的语义。寄存器是Last WriteWins，使用处理写入的节点上的时间戳。因此，所有关于时钟同步的声明都适用。旗帜开始关闭，您可以将其打开。对于WINS上的任何一对并发的、冲突的操作(ON|OFF)。同样，同样的添加赢得了语义。</p><p>   More on this later, but all additive operations (that is everythingexcept Set member and Map field removal) can be performed by simplysending operations to Riak. Not the usual Get, Modify, Updatecycle. This “action at a distance” was introduced in Riak 1.4 withcounters and extends to the new data types.</p><p>稍后将详细介绍这一点，但是所有的加法操作(即除了集合成员和映射字段删除之外的所有操作)都可以通过简单地向Riak发送操作来执行。不是通常的GET、MODIFY、UPDATECYCLE。这种“远程操作”是在Riak1.4中引入的，带有计数器，并扩展到新的数据类型。</p><p>  There are two APIs as ever, PB and HTTP. As of time of writing theHTTP API is unfinished so I’ll talk about the PB API. Assume thatthere will be parity.</p><p>仍然有两个接口，PB和HTTP。在撰写本文时，http API尚未完成，因此我将讨论PBAPI。假设会有平价。</p><p> The API allows you to specify operations to be performed on Data Typesat a replica in Riak. For counters you may only send a singleoperation, “increment” with an amount (negative for decrement.)</p><p>API允许您指定要在Riak中复制副本的数据类型上执行的操作。对于计数器，您只能发送带有金额的单个操作“增量”(如果是减量，则为负数)。</p><p>  You may send a list of operations. The list may contain both  Add ElementX and  Remove ElementY operations. If you are removingelements we strongly recommend that you first fetch the Set and it’s context, and send the context with the remove operation(s.)</p><p>您可以发送一份操作清单。该列表可以同时包含添加元素X和删除元素Y操作。如果您要删除元素，我们强烈建议您首先获取集合及其上下文，然后将上下文与删除操作一起发送。</p><p>  All operations are executed atomically at the coordinating replica. Ifany operation in the list fails (only removes can fail!) then none ofthe operations are applied.</p><p>所有操作都在协调副本处自动执行。如果列表中的任何操作失败(只有删除可以失败！)。则不会应用任何操作。</p><p>  You may send a list of operations. These are either  field operations,or  field update operations. Field operations Add or Remove fields fromthe Map. I find it helps to think of the Map as a schema for a (JSONlike?) document. Field operations alter the schema of the Map.</p><p>您可以发送一份操作清单。这些操作要么是现场操作，要么是现场更新操作。外业操作在地图中添加或删除字段。我发现将Map看作是(JSONlike？)。文件。现场操作会更改地图的模式。</p><p> Field Update Operations act on the data stored in the Map. You maysend any number of operations batched together. You may mix FieldOperations and Field Update Operations.</p><p>字段更新操作作用于存储在地图中的数据。您可以将任意数量的操作分批发送到一起。您可以混合使用FieldOperations和Field Update Operations。</p><p> For example, if you model Game State as a Map for a particular userand game. You could send an operation when the user starts a game thatcreates a Map, adds fields of  Counters for points and lives, a  Setfor achievements unlocked, and a  Map for inventory that contains two Sets (armor and weapons) and a  Counter for Hit Points.</p><p>例如，如果您将“游戏状态”建模为特定用户和游戏的“地图”。您可以在用户开始游戏时发送操作，创建地图，添加点数和生命值计数器字段，解锁成就集，以及包含两套(盔甲和武器)和生命值计数器的库存地图。</p><p> As the game is played operations that update multiple Counters, addand remove elements from Sets and so on can be sent as batches thatexecute atomically at the coordinating replica. This does not suggestthat you can enforce co-invariants between values in the Map.</p><p>随着游戏的进行，更新多个计数器、从集合中添加和删除元素等操作可以作为批处理发送，这些批处理在协调复制品处自动执行。这并不意味着您可以强制执行映射中的值之间的协不变量。</p><p> What counts for Sets counts for Maps, we  strongly recommend you send acontext with any batch of operations that contain a Field or Setelement Remove, no matter how deeply nested in the Map.</p><p>对于Map，强烈建议您使用任何一批包含Field或SetElement Remove的操作发送上下文文本，无论Map中嵌套得有多深。</p><p> If you are only updating Fields in the Map then you do not need tofetch first, and you do not need a context, you may just sendoperations.</p><p>如果您只更新映射中的字段，则不需要首先获取，也不需要上下文，您只需发送操作即可。</p><p> You do not need to explicitly create a field. Updating a field that isnot present at the coordinating replica will create and update thefield. For example,  adding 10 to the  Counter in Field  &lt;&lt;”gold”&gt;&gt;in the Map at key  Game1 will create the field if it is not present,and then increment by 10.</p><p>您不需要显式创建字段。更新协调复制品中不存在的字段将创建并更新该字段。例如，在Map at Key Game1的Field&lt；&lt；“gold”&gt；中的计数器上加10，如果该字段不存在，则会创建该字段，然后递增10。</p><p>   We don’t allow you to remove something from a Set / Map that is notthere. Since there is no guarantee that the replica coordinating yourremove operation(s) contains the value(s) you want to remove (imaginean empty fallback spun up to accept the request) the context “seeds”the handling replica with the values you’ve seen. If you don’t sendthe context, and the replica doesn’t have the value(s) you want toremove, the operations fails with “precondition failure” error. Aprecondition of removing an element or Field is that it is present.</p><p>我们不允许您从不在那里的集合/地图中删除某些内容。由于不能保证协调您的删除操作的副本包含您想要删除的值(想象一个空的后备以接受请求)，上下文用您看到的值“播种”处理副本。如果您没有发送上下文，并且副本没有您想要删除的值，则操作会失败，并出现“Predition Failure”错误。删除元素或字段的前提条件是它存在。</p><p> The second reason is more subtle and is going to need someimplementation specifics, which I’ll cover later, to reallyunderstand. At this point it is enough to say that without a contextfor a remove, you may remove more than you planned to. The “Add Wins”semantic is based on “Observed Remove”, which means only remove thatwhich you have seen. The context tells the replica handling theoperation what you’ve seen. If an “Add” for the element you want toremove was handled or seen by the replica after you sent your remove,and there was no context, the remove would win over the concurrentadd. There maybe times you want this, but in general, use the contextfor removes.</p><p>第二个原因更为微妙，需要一些实现细节(稍后我将介绍)才能真正理解。在这一点上，只要说没有删除的上下文就足够了，您可能会删除比计划更多的内容。“添加成功”语义基于“观察到的删除”，这意味着只删除您看到的内容。上下文告诉处理操作的副本您所看到的内容。如果要删除的元素的“Add”在您发送Remove之后由副本处理或看到，并且没有上下文，则Remove将赢得并发Add的支持。有时您可能需要这样做，但一般情况下，请使用上下文for removes。</p><p> The context is a compact binary encoding of the Set or Map. We hope tominimize it further in future releases.</p><p>上下文是集合或映射的紧凑二进制编码。我们希望在将来的版本中进一步简化它。</p><p>  The main cost is that the Data Types take up space. There is somecomputational cost to the merge functions, that will be performed onyour Riak servers, rather than in your client application. We have yetto measure this.</p><p>主要成本是数据类型占用空间。合并功能有一些计算性开销，这些功能将在您的Riak服务器上执行，而不是在您的客户端应用程序中执行。我们还需要测量这一点。</p><p>  We store the Data Types is  riak_objects. This is so they play nicewith all Riak’s systems, like AAE, Enterprise Multi Data CenterReplication, read repair etc. So off the bat, we have the overhead ofa riak_object.</p><p>我们存储的数据类型是riak_Objects。因此，他们可以很好地处理Riak的所有系统，如AAE、企业多数据中心复制、读取修复等。因此，我们马上就有了Riak_Object的开销。</p><p> The Data Types themselves are at least as big as what they contain,plus a version vector, plus some  Dots (see below.) We’ve tried tokeep them small with an efficient binary representation (and we’llkeep improving on that), but they are larger than one might firstimagine.</p><p>数据类型本身至少和它们包含的内容一样大，再加上一个版本向量，再加上一些圆点(见下文)。我们试图用有效的二进制表示来保持它们小(我们会在这方面不断改进)，但它们比人们最初想象的要大。</p><p>   IRL: A version vector with two integers per actor that has coordinatedan increment. Each actor is 8 bytes. Expect at least  N-val actors.</p><p>IRL：一个版本向量，每个参与者有两个整数，它协调了一个增量。每个参与者为8个字节。至少需要N-Val演员。</p><p>   IRL: The sum of the size of its members, plus a version vector, and aminimal version vector (at most the size of the Set vector, typicallyone  {actor, count} pair) per member. The size of the version vectordepends on N-Val, MDC, Cluster Churn etc. Again, 8 bytes per actor,though we only store each actor once.</p><p>IRL：每个成员的成员大小之和加上一个版本向量和小数版本向量(最多为集合向量的大小，通常为一对{参与者，计数})。版本向量的大小取决于N-val、MDC、集群流失等。同样，每个参与者8个字节，尽管我们只存储每个参与者一次。</p><p>  Expect: The sum of the size of the keys plus the sum of the size ofthe values.</p><p>期望值：键的大小之和加上值的大小之和。</p><p> IRL: Each key is a pair of  {name, int} where int maps to a modulethat implements the Data Type of the field. Each member also has aminimal clock (as for the Set.)</p><p>IRL：每个键都是一对{name，int}，其中int映射到实现字段数据类型的模块。每个成员也有十进制时钟(与集合一样)。</p><p>     You know enough to use Riak&#39;s Data Types now. If you really want toknow how the sausage is made, read on.</p><p>您现在已经足够了解Riak的数据类型了。如果你真的想知道香肠是怎么做的，那就往下看。</p><p>  It is worth remembering at this point that  Vnodes are the unit ofconcurrency in Riak. Whenever I say  Actor I mean  Vnode and  Vnode Id. Correctness in Riak depends on individual Actors acting serially.</p><p>在这一点上值得记住的是，Vnode是Riak中的并发单位。每当我说Actor时，我指的是Vnode和Vnode ID。Riak中的正确性取决于单个演员的连续操作。</p><p>  The Counter is a CRDT called a PN-Counter, where P is Positive and Nis Negative. It is a list of triples of  {actor, positive, negative}where the value is the difference between the sum of all positives andthe sum of all negatives. An actor may only update its own entry inthe list. When two counters merge we take the maximum of positive andnegative for each actor. When an actor is only in one counter, we justkeep its value in the merged counter.</p><p>计数器是称为PN计数器的CRDT，其中P为正，N为负。它是{参与者，正，负}的三元组的列表，其中值是所有正的和与所有负的和之间的差值。参与者只能更新列表中自己的条目。当两个计数器合并时，我们取每个参与者的正值和负值的最大值。当参与者只在一个计数器中时，我们只将其值保留在合并的计数器中。</p><p>  Flags are logically equivalent to a Set that can only contain oneelement. Whether the element is present or absent is equivalent towhether the flag is On or Off, respectively. The same “Add Wins” /“Observed Remove” behavior applies, except with Flags we call it“Observed Disable”. To the user Flags look like Boolean values.</p><p>标志在逻辑上等同于只能包含一个元素的集合。元素的存在或不存在分别等同于标志是否打开或关闭。同样的“添加WINS”/“观察到的删除”行为也适用，除了我们称之为“观察到的禁用”的标志。对于用户来说，标志看起来像布尔值。</p><p>  Registers are a pair of  {value, timestamp}. They converge on thehighest timestamp. Much like a value in Cassandra. They require wellsynchronized clocks. When two registers merge, the pair with thehighest timestamp is the merged value.</p><p>寄存器是一对{值，时间戳}。它们在最高的时间戳上汇聚。就像卡桑德拉的价值一样。它们需要精确同步的时钟。当两个寄存器合并时，具有最高时间戳的对是合并值。</p><p>  The crucial part of any convergent, or state based CRDT is its mergefunction. The merge function is the LUB of the Join-Semi-Lattice, andit is what defines the semantic of the data type, as well as being ageneralization of all those ad hoc conflict resolutions customersmight have had to write.</p><p>任何收敛的或基于状态的CRDT的关键部分是它的合并功能。合并函数是JOIN-Semi-Lattice的Lub，它定义了数据类型的语义，以及客户可能不得不编写的所有临时冲突解决方案的泛化。</p><p> The merge function for an optimized OR-Set[3] is pretty simple forany elements in both sets: they’re in the set. The difficulties arisewhen an element is only in one of the two Sets being merged.</p><p>对于两个集合中的任何元素，优化OR集合[3]的合并函数都非常简单：它们都在集合中。当一个元素只在要合并的两个集合中的一个集合中时，困难就出现了。</p><p>  When two replicas merge, and one contains an element in its Set thatthe other does not, why is it there? It can either be:</p><p>当两个副本合并时，其中一个在其集合中包含一个元素，而另一个没有，为什么它会在那里？它可以是：</p><p> The element was added to one replica and the other is yet to see it</p><p>元素已添加到一个复本，而另一个复本尚未看到它。</p><p> We need to know why an element is only in one set to arrive at acorrect merged value. As ever in these things, causality to therescue. It stands to reason that if the element was once in Set A butis no longer, it was removed. We could store a tombstone value for theremoved item, but that means our sets never get smaller. A Set withone member that once had 100 members, would be the same size as a Setwith 100 members.</p><p>我们需要知道为什么一个元素只在一个集合中才能得到正确的合并值。一如既往，在这些事情上，因果关系导致了这一结果。合乎情理的是，如果该元素曾经在集合A中，但不再存在，那么它将被移除。我们可以存储移动物品的墓碑值，但这意味着我们的集合永远不会变小。有一个成员的集合曾经有100个成员，其大小将与有100个成员的集合的大小相同。</p><p> Instead what we do is attach a  version vector to the Set, and everytime an element is added to the Set, we increment the entry in theversion vector for the replica that added the element. We also storethe  {actor, count} pair that results from the increment against theelement (which I’m going to call the  Dot[4] from now on.) If thereis already a Dot associated with the element we keep that too. What weend up with looks like [{actor1, count}=Dot1, {actor2, count}=Dot2,…], which is a versionvector, but it is a minimal clock, that stores only the Dots or events when the element was added. Note that the version vectorattached to the whole set will always dominate all the minimal clocksfor all elements.</p><p>相反，我们所做的是将一个版本矢量附加到集合中，并且每次将元素添加到集合中时，我们都会为添加该元素的副本递增版本矢量中的条目。我们还存储了对元素(从现在开始我将称之为Dot[4])的增量所产生的{actioner，count}对。如果已经有一个与元素相关联的点，我们也会保留它。我们最终得到的结果如下[{actor1，count}=dot1，{actor2，count}=do2，…]。，它是一个版本向量，但它是一个最小时钟，在添加元素时只存储点或事件。请注意，附加到整个集合的版本向量将始终控制所有元素的所有最小时钟。</p><p> When an element is removed from the set we simply remove the Elementand its minimal clock.</p><p>当从集合中删除一个元素时，我们只需删除该元素及其最小时钟。</p><p> Now, when a merge occurs we compare the two sets. We take all theelements that are in  Set A and not in  Set B and compare theirminimal clocks to Set B’s set version vector. Every element whoseminimal clock is dominated has been removed from Set B, and does notmake it into the merged set. As a slight optimization, we also dropany dots from the minimal clock that are dominated by Set B’sclock. This keeps the minimal clock  minimal. You can think of it assubtracting the minimal clock from Set B’s set version vector, if anyDots are left, the element is in the merged set with those remainingDots as the new minimal clock.</p><p>现在，当合并发生时，我们比较这两个集合。我们获取集合A中的所有元素和不在集合B中的所有元素，并将它们的最小时钟与集合B的集合版本向量进行比较。每个最小时钟占主导地位的元素都已从集合B中移除，并且不会进入合并的集合。作为一种轻微的优化，我们还从由集合B‘sclock支配的最小时钟中丢弃了任何点。这使最小时钟保持最小。您可以将其视为从集合B的集合版本向量中减去最小时钟，如果留下任何点，则元素在合并的集合中，剩余的点作为新的最小时钟。</p><p> We repeat the process the other way, comparing all Set B’s elementsthat are not in Set A to Set A’s set version vector.</p><p>我们以另一种方式重复该过程，将不在集合A中的所有集合B的元素与集合A的集合版本向量进行比较。</p><p> We keep all elements that are in both Sets, merging their minimalclocks. Finally we merge the two set version vectors to ensure theproperty that the Set version vector always dominates all minimalclocks is maintained.</p><p>我们保留两个集合中的所有元素，合并它们的最小时钟。最后，我们将两个集合版本向量合并，以保证集合版本向量始终支配所有最小时钟的属性。</p><p>  Sets are implemented as a version vector, and a dictionary of mappingsfrom  element -&gt; minimal clock.</p><p>集合被实现为版本向量和来自元素-&gt；最小时钟的映射字典。</p><p>  As far as implementation goes, Maps are just like the Set describedabove. They use the same Map version vector, and a minimal clock perentry to decide what to do with a Field that is only on one side of amerge.</p><p>就实现而言，Map就像上面描述的集合一样。它们使用相同的Map版本矢量和每个条目的最小时钟来决定如何处理仅位于amerge一侧的Field。</p><p> The main difference is of course when an element is in both Maps: wecall the Data Type’s merge function to get a single, convergentvalue. Conceptually merging two Maps is the same as merging two Setsof Fields, and then calling merge on all common Fields&#39; values.</p><p>当然，主要区别在于当一个元素同时位于两个Map中时：我们调用数据类型的合并函数来获得单个收敛的值。从概念上讲，合并两个映射等同于合并两组字段，然后对所有公共字段值调用Merge。</p><p>    [4] Dotted Version Vectors: Logical Clocks for Optimistic ReplicationNuno Preguiça, Carlos Baquero, Paulo Sérgio Almeida, Victor Fonte,Ricardo Gonçalves  http://arxiv.org/abs/1011.5808</p><p>[4]点状版本矢量：乐观复制的逻辑时钟努诺·普雷奎萨、卡洛斯·巴奎罗、保罗·塞尔吉奥·阿尔梅达、维克多·方特、里卡多·贡萨尔维斯·http://arxiv.org/abs/1011.5808</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/russelldb/f92f44bdfb619e089a4d">https://gist.github.com/russelldb/f92f44bdfb619e089a4d</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/riak/">#riak</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guide/">#guide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/操作/">#操作</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>