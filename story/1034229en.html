<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数字声音处理教程</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">数字声音处理教程</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 18:23:02</div><div class="page_narrow text-break page_content"><p>In 1998, I had some extra time while others were reading for final exams of the senior high school, and got into digital signal processing. I wrote as I learned, and here is the result. It is not entirely accurate in places but may serve as a nice tutorial into the world of audio DSP. Previously this document was called Yehar&#39;s digital sound processing tutorial for the braindead, but I have kinda grown out of my scene identity over the years. Enjoy the ASCII art!</p><p>1998年，我在其他人准备高中期末考试的时候有了一些额外的时间，进入了数字信号处理领域。我是按照我所学的方式写的，结果是这样的。它在某些方面并不完全准确，但可以作为了解音频DSP世界的很好的教程。以前这份文件被称为耶哈尔的数字声音处理教程的脑筋急转弯，但我已经长大了几年，我的场景身份。享受ASCII艺术！</p><p>      This is written for the audio digital signal processing enthusiasts (as the title suggests ;) and others who need practical information on the subject. If you don&#39;t have this as a &#34;linear reading experience&#34; and encounter difficulties, check if there&#39;s something to help you out in the previous chapters.</p><p>这是为音频数字信号处理发烧友(如标题所示)和其他需要该主题实用信息的人编写的。如果你没有这方面的线性阅读经验，并且遇到了困难，看看前面几章有没有什么可以帮你的。</p><p> In filter frequency response plots, linear frequency and magnitude scales are used. Page changes are designed for 60+ lines/page printers.</p><p>在滤波器频率响应图中，使用线性频率和幅度尺度。换页功能专为60多行/页打印机设计。</p><p> Chapter &#34;Shuffling IIR equations&#34; is written by my big brother Kalle. And, thanks to Timo Tossavainen for sharing his DSP knowledge!</p><p>《洗牌方程式》一章是我哥哥卡勒写的。同时，感谢蒂莫·托萨瓦宁分享他的数字信号处理器知识！</p><p>     Sampled sound data is a pile of samples, amplitude values taken from the actual sound wave. Sampling rate is the frequency of the &#34;shots&#34;. For example, if the frequency is 44100, 44100 samples have been taken in one second.</p><p>采样的声音数据是一堆样本，即取自实际声波的幅值。采样率是拍摄镜头的频率。例如，如果频率为44100，则在1秒内已采集了44100个样本。</p><p>  _0---0_ _/ --0__ 0_ __0---0__ _0 -0---0___ \_ _-0- -0-- 0-__ +---0==-+--=0---+---+---+---+---+---+---+---+---+---+---+---0==-+---+ -0-- -0_ --0 &lt;---&gt; 1/Samplerate</p><p>_0-0__/--0__0_0-0__0-0-0_\__-0--0--0-__+---0==-+--=0---+---0==-+-。--+-0-0_--0&lt；-&gt；1/采样率。</p><p> The original sound is the curve, and &#34;0&#34;s are the sampled points. The horizontal straight line is the zero level.</p><p>原始声音是曲线，而‘s’是采样点。水平直线是零水准。</p><p> A sampled sound can only represent frequencies up to half the samplerate. This is called the Nyquist frequency. An easy proof: You need to have stored at least two samplepoints per wave cycle, the top and the bottom of the wave to be able to reconstruct it later on:</p><p>采样声音只能表示采样率的一半以下的频率。这就是奈奎斯特频率。一个简单的证明是：每个波浪周期需要至少存储两个采样点，即波浪的顶部和底部，以便稍后能够重建它：</p><p> 0\ /0\ /0\ /0\ /0\ /0\ /0\ /0\ /0\ | | | | | | | | | | | | | | | | | +-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+-|-+ | | | | | | | | | | | | | | | | | \0/ \0/ \0/ \0/ \0/ \0/ \0/ \0/ \0</p><p>0\/0\/0\/0\/0\/0\/0\/0\/0\|+-|-。+|\0/\0/\0/\0/\0/\0/\0/\0/\0。</p><p> If you try to include above Nyquist frequencies in your sampled sound, all you get is extra distortion as they appear as lower frequencies.</p><p>如果您尝试在采样声音中包含高于奈奎斯特频率的频率，您得到的只是额外的失真，因为它们显示为较低的频率。</p><p>  A Sound consists of frequency components. They all look exactly like sine waves, but they have different frequencies, phases and amplitudes. Let&#39;s look at a single frequency:</p><p>声音由频率成分组成。它们看起来都和正弦波一模一样，但它们的频率、相位和振幅不同。让我们来看看一个频率：</p><p> | __ __ __ __ | |/ \ / \ / \ / \ | /----\----/----\----/----\----/----\----/ | \__/ \__/ \__/ \__/| | |</p><p>_/\/\/-\\__/\__/我想说的是。</p><p> Now, we take the same frequency from another sound and notice that it has the same amplitude, but the opposite (rotated 180 degrees) phase.</p><p>现在，我们从另一个声音中提取相同的频率，并注意到它具有相同的振幅，但相位相反(旋转180度)。</p><p> | __ __ __ __ | | / \ / \ / \ / \| \----/----\----/----\----/----\----/----\ |\__/ \__/ \__/ \__/ | | |</p><p>_/\/\\-/\__/\__/我想说的是。</p><p> Merging two signals is done simply by adding them together. If we do the same with these two sine waves, the result will be:</p><p>合并两个信号只需将它们相加即可。如果我们对这两个正弦波执行相同的操作，结果将是：</p><p>  It gets silent. If we think of other cases, where the phase difference is less than 180 degrees, we get sine waves that all have different amplitudes and phases, but the same frequency.</p><p>它就会安静下来。如果我们考虑其他情况，在相位差小于180度的情况下，我们得到的正弦波都具有不同的幅度和相位，但频率相同。</p><p> Here&#39;s the way to calculate the phase and the amplitude of the resulting sinewave... Convert the amplitude and phase into one complex number, where angle is the phase, and absolute value the amplitude.</p><p>下面是计算产生的正弦波的相位和振幅的方法。将振幅和相位转换为一个复数，其中角度是相位，绝对值是振幅。</p><p>  If you do this to both of the sinewaves, you can add them together as complex numbers.</p><p>如果你对这两个弦波都这样做，你可以把它们加在一起作为复数。</p><p>  (Wave A) amplitude 1, phase 0, (Wave B) amplitude 1, phase 90 degrees _---|---_ _---0---_ _---|---_ 0 / | \ / | \ / | \ | | | | | | | | | -|-----+-----0- + -|-----+-----|- = -|-----+-----|- | | | | | | | | | \_ | _/ \_ | _/ \_ | _/ ---|--- ---|--- ---|---</p><p>(A波)幅度1，相位0，(B波)幅度1，90度阶段_-|-__-0-__-|-0/|\/|\/|\|-|-+-0-+-|-|--=--||\_|_/\_|。_/\_|_/-|。</p><p> As you see, the phase of the new sine wave is 45 degrees and the amplitude sqrt(1^2+1^2) = sqrt(2) = about 1.4</p><p>如您所见，新正弦波的相位为45度，振幅SQRT(1^2+1^2)=SQRT(2)=约1.4。</p><p> It is very important that you understand this, because in many cases, it is more practical to present the amplitude and the phase of a frequency as a complex number.</p><p>理解这一点非常重要，因为在许多情况下，将频率的振幅和相位表示为复数更为实用。</p><p> When adding two sampled sounds together, you may actually wipe out some frequencies, those that had opposite phases and equal amplitudes. The average amplitude of the resulting sound is (for independent originals) sqrt(a^2+b^2) where a and b are the amplitudes of the original signals.</p><p>当把两个采样的声音加在一起时，你实际上可能会抹去一些频率，那些具有相反相位和相等幅度的频率。产生的声音的平均振幅是(对于独立的原声)SQRT(a^2+b^2)，其中a和b是原始信号的振幅。</p><p>  The main use of a filter is to scale the amplitudes of the frequency components in a sound. For example, a &#34;lowpass filter&#34; mutes all frequency components above the &#34;cutoff frequency&#34;, in other words, multiplies the amplitudes by 0. It lets through all the frequencies below the cutoff frequency unattenuated.</p><p>滤波器的主要用途是缩放声音中频率分量的幅度。例如，低通滤波器会将截止频率以上的所有频率分量静音，换句话说，就是将幅度乘以0。它让所有低于截止频率的频率不受衰减地通过。</p><p>  If you investigate the behaviour of a lowpass filter by driving various sinewaves of different frequencies through it, and measure the amplifications, you get the &#34;magnitude frequency response&#34;. Here&#39;s a plot of the magnitude frequency response curve of a lowpass filter:</p><p>如果你通过驱动不同频率的正弦波来研究低通滤波器的性能，并测量放大器，你就会得到幅值频率响应。下面是一个低通滤波器的幅频响应曲线曲线图：</p><p> 1-+----------------------_ | | \ | | Audible | Inaudible | | | | | | | | \_ | 0-+---------------------------=========================== | | | 0Hz Cutoff frequency max</p><p>1-+\\Audible|听不到||||\_0-+--==||0 HZ最大截止频率。</p><p> Frequency is on the &#34;-&#34; axis and amplification on the &#34;|&#34; axis. As you see, the amplification (= scaling) of the frequencies below the cutoff frequency is 1. So, their amplitudes are not affected in any way. But the amplitudes of frequencies above the cutoff frequency get multiplied by zero so they vanish.</p><p>频率在轴上，放大在轴上。如你所见，低于截止频率的频率的放大倍数是1。因此，它们的幅度不会受到任何影响。但是高于截止频率的频率的幅度被乘以零，所以它们就消失了。</p><p> Filters never add any new frequency components to the sound. They can only scale the amplitudes of already existing frequencies. For example, if you have a completely quiet sample, you can&#39;t get any sound out of it by filtering. Also, if you have a sine wave sample and filter it, the result will still be the same sine wave, only maybe with different amplitude and phase - no other frequencies can appear.</p><p>过滤器从来不会给声音添加任何新的频率成分。他们只能调整已经存在的频率的幅度。例如，如果你有一个完全安静的样品，你不能通过过滤得到任何声音。此外，如果你有一个正弦波样本，并对其进行滤波，结果仍然是相同的正弦波，只是幅度和相位可能不同--不会出现其他频率。</p><p>  Professionals never get tired of reminding us how important it is not to forget the phase. The frequency components in a sound have their amplitudes and... phases. If we take a sine wave and a cosine wave, we see that they look alike, but they have a phase difference of pi/2, one fourth of a full cycle. Also, when you play them, they sound alike. But, try wearing a headset and play the sinewave on the left channel and the cosine wave on the right channel. Now you hear the difference!</p><p>专业人士不厌其烦地提醒我们，不要忘记阶段是多么重要。声音中的频率分量有它们的振幅和……。阶段。如果我们取一个正弦波和一个余弦波，我们看到它们看起来很相似，但是它们的相位差是π/2，一个完整周期的四分之一。而且，当你播放它们的时候，它们听起来很像。但是，试着戴上耳机，在左声道播放正弦波，在右声道播放余弦波。现在你听到区别了吧！</p><p> Phase itself doesn&#39;t contain important information for us so it&#39;s not heard, but the phase difference, of a frequency, between the two ears can be used in estimating the position of the origin of the sound so it&#39;s heard.</p><p>相位本身并不包含重要的信息，所以我们听不到它，但是两只耳朵之间的频率的相位差可以用来估计声音来源的位置，这样它就可以被听到了。</p><p> Filters have a magnitude frequency response, but they also have a phase frequency response. Here&#39;s an example curve that could be from a lowpass filter:</p><p>滤波器有幅度频率响应，但也有相位频率响应。下面是一个可能来自低通滤波器的曲线示例：</p><p> +pi-+-----------------------------------------------------+ | ___ | | _________----- \ | 0-+======------------------|---------==================== | \___----- | | | -pi-+-----------------------------------------------------+ | | | 0Hz Cutoff frequency max</p><p>+pi-+---+__-\0-+=-|-=|\_--。--|我想说的是-pi-+---+||0 HZ最大截止频率。</p><p> If you filter a sound, the values from the phase frequency response are added to the phases of the frequencies of the original sound.</p><p>如果过滤声音，来自相位频率响应的值将被加到原始声音的频率的相位上。</p><p> Linear (straight line) phase is the same thing as a plain delay, although it may look wild in the plot if it goes around several times. If your, for example, lowpass filter doesn&#39;t have a linear phase frequency response, you can&#39;t turn it into a highpass filter by simply subtracting its output from the original with equal delay.</p><p>线性(直线)相位与普通延迟是一样的，尽管它在情节中可能看起来很疯狂，如果它绕几圈的话。例如，如果你的低通滤波器没有线性相位频率响应，你不能通过简单地以相等的延迟从原始输出中减去它的输出来将其变成高通滤波器。</p><p>  The response of a filter for a single frequency can be expressed as a complex number, where the angle is the phase response of the filter and the absolute value the magnitude response. When you apply the filter to a sound, you actually do a complex multiplication of all the frequency components in the sound by the corresponding filter response values. (Read chapter &#34;Adding two sinewaves together&#34; if you find this hard to understand.) Example: The response of a filter is (0,1) at 1000Hz. You filter a sine wave, with the phase &amp; amplitude information presented as the complex number (0,1), of the same frequency with it:</p><p>滤波器对单个频率的响应可以表示为复数，其中角度是滤波器的相位响应，绝对值是幅值响应。当您将过滤器应用于声音时，实际上是将声音中的所有频率分量与相应的过滤器响应值进行复数乘法。(如果你觉得这很难理解，请阅读《把两条弦波加在一起》一章。)。例如：在1000赫兹时，滤波器的响应为(0，1)。您可以过滤一个正弦波，其相位和幅值信息显示为与其频率相同的复数(0，1)：</p><p> Sine wave: Filter: Result: _---0---_ _---0---_ _---|---_ / | \ / | \ / | \ | | | | | | | | | -|-----+-----|- * -|-----+-----|- = -0-----+-----|- | | | | | | | | | \_ | _/ \_ | _/ \_ | _/ ---|--- ---|--- ---|---</p><p>正弦波：过滤器：结果：_-0-__-0-_-|-_/|\/|\/|\|-||-+-|--*-|-+-|--=-0|\_。|_/\_|_/\_|_/-|。</p><p> The phase of the sine wave got rotated 90 degrees. No change in the amplitude.</p><p>正弦波的相位旋转了90度。振幅没有变化。</p><p>   The combined response of these two filters put in serial is the response of A multiplied by the response of B (Complex numbers as always!). If you only need to know the magnitude response, you could as well multiply the absolute values.</p><p>串联的这两个滤波器的组合响应是A的响应乘以B的响应(复数总是！)。如果你只需要知道震级响应，你也可以乘以绝对值。</p><p>  In the figure, both filters get their inputs from the same source. Their outputs are then added back together, forming the final output. Now you need to use addition in solving the combined response.</p><p>在图中，这两个过滤器的输入来自相同的来源。然后将它们的输出加在一起，形成最终输出。现在，您需要使用加法来求解组合响应。</p><p>   FIR filter is more straightforward, and easier to understand. Finite impulse response means that when the filter input has remained zero for a certain time, the filter output also becomes zero. An Infinite impulse response filter never fully &#34;settles down&#34; after turning off the input, but it does get quieter and quieter though.</p><p>FIR滤波器更直观，更容易理解。有限脉冲响应是指当滤波器输入保持为零一段时间后，滤波器输出也变为零。无限脉冲响应滤波器在关闭输入后永远不会完全稳定下来，但它确实会变得越来越安静。</p><p>      It&#39;s up to the coefficients (a0, a1, a2) what this filter will do to the sound. Choosing the coefficient values is the hardest part, and we&#39;ll get to that later. To design your own filters, you need to understand some of the math behind and know the right methods.</p><p>这个过滤器对声音的影响取决于系数(a0，a1，a2)。选择系数值是最困难的部分，我们稍后会讨论这一点。要设计自己的过滤器，您需要了解背后的一些数学知识，并知道正确的方法。</p><p> In the above filter example, only past input values are used. In realtime filters, this is a requirement, because you don&#39;t know the future inputs. In sample editors and such, you don&#39;t have this limitation, because you have the whole input data ready when you begin.</p><p>在上面的筛选器示例中，只使用过去的输入值。在实时过滤器中，这是一个要求，因为你不知道未来的输入。在样例编辑器之类的地方，您没有这个限制，因为您在开始时就已经准备好了全部输入数据。</p><p>       Unlike FIR filters, IIR filters also use their previous output values in creating their present output. Here&#39;s a simple example:</p><p>与FIR滤波器不同，IIR滤波器还使用其先前的输出值来创建其当前输出。下面是一个简单的例子：</p><p>    There can be several ways of implementing the same IIR filter. Some may be faster than the usual input-output-and-coefficients way. Anyhow, every IIR filter can be written in this form, and it must be used in filter design and examining calculations.</p><p>可以有多种方法来实现相同的IIR滤波器。有些可能比通常的输入-输出-系数方式更快。无论如何，每个IIR滤波器都可以用这种形式编写，并且必须在滤波器设计和检查计算中使用。</p><p> An impulse response (= What the filter will do to a one samplepoint impulse) of an IIR filter often looks more or less like this in the sampledata:</p><p>在样本数据中，IIR滤波器的脉冲响应(=滤波器对一个采样点脉冲的响应)通常大致如下所示：</p><p>  Some badly designed IIR filters are unstable. This results in ouput getting louder and louder instead of quieter and quieter. A simple example of this is: output(t) = input(t) + 2*output(t-1). As soon as it gets input data, it gets crazy.</p><p>一些设计糟糕的IIR滤光片是不稳定的。这会导致输出的声音越来越大，而不是越来越安静。一个简单的例子是：Output(T)=Input(T)+2*Output(t-1)。一旦它获得输入数据，它就会变得疯狂。</p><p>  The above described filter types process the data sample by sample. Not so, if you implement your filter using FFT, Fast Fourier Transformation. FFT usually operates on chunks of length 2^n. First, you should have your planned filter impulse response ready. Then convert it, using FFT, to spectral information  - complex numbers representing the phases and amplitudes of the frequency components. These components are called bins, because their frequencies are fixed and evenly distributed, and if the original data contained any in-between frequencies, then most of the &#34;energy&#34; of such a frequency will be distributed amongst the nearby bins. Now, you FFT also the sample data you want to filter, and multiply the resulting frequency bins with those from the filter. Then IFFT (Inverse FFT) is used to convert the information into a chunk of filtered sample data.</p><p>上述过滤器类型逐个样本地处理数据。如果你使用快速傅立叶变换(FFT)来实现你的滤波器，情况就不是这样了。FFT通常操作长度为2^n的块。首先，你应该准备好你计划的滤波器脉冲响应。然后，使用FFT将其转换为频谱信息，即代表频率分量的相位和幅度的复数。这些分量被称为桶，因为它们的频率是固定且均匀分布的，如果原始数据包含任何中间频率，那么这种频率的大部分能量将分布在附近的桶中。现在，您还需要对要过滤的样本数据进行快速傅立叶变换，并将得到的频率段与过滤器中的频率段相乘。然后使用IFFT(逆FFT)将信息转换成经过滤波的样本数据块。</p><p> So, multiplication of the two frequency domain data resulted in convolution of the two time domain data. However, there&#39;s a catch: FFT operates on periodic signals, that is, if you have a filter impulse response as long as the FFT chunk then any non-zero sample data in the middle of the FFT chunk will result with the convolution wrapping the tail of the filter around the FFT boundary. In order to avoid this problem, you can use FFT twice as long as the filter impulse response, and when doing FFT on the sample data, only fill up the FFT input buffer to half way and set rest of the input to zero. For longer inputs, you would process the data in chunks like that and then add the resulting filtered chunks together. This is called the overlap-add method. Another option is overlap-save (look it up if you like).</p><p>因此，两个频域数据的相乘导致了两个时域数据的卷积。然而，这里有一个问题：FFT对周期信号进行操作，也就是说，如果你有一个与FFT块一样长的滤波器脉冲响应，那么FFT块中间的任何非零样本数据都将产生卷积，使滤波器的尾部绕过FFT边界。为了避免这个问题，您可以使用两倍于滤波器脉冲响应时间的FFT，并且在对采样数据执行FFT时，只需将FFT输入缓冲器填满一半，并将其余输入设置为零。对于较长的输入，您可以像这样处理块中的数据，然后将得到的过滤后的块相加在一起。这称为重叠添加方法。另一个选项是重叠保存(如果你愿意的话可以查一下)。</p><p> FFT can also be used to analyze the frequency content of sample data, for whatever reason. If you just take a chunk of sample data, it has sharp edges, which is bad for FFT.  Windowing functions are used to smoothen these edges. &#34;Raised cosine&#34;, cos(x pi/2)^2, is one possible windowing function. Here you see what happens when you apply that windowing function to a chunk of sample data:</p><p>无论出于何种原因，FFT也可以用来分析样本数据的频率成分。如果你只取一大块样本数据，它有尖锐的边缘，这对FFT不利。我们使用窗口函数来平滑这些边缘。升余弦，cos(x pi/2)^2是一个可能的窗口函数。下面您将看到当您将窗口函数应用于一大块样本数据时会发生什么：</p><p> Sample data chunk: Windowing function: Result: (square wave) (raised cosine) 1 -|-- --- --- | | _---_ | | _-- | | | | / \ | | | | | | _/ \_ | | \_ | 0 -| | * |-- --| = |--_ --| | | | | | \ | | | | | | \ _/ | -1 -| --- --- -| | | | - |</p><p>示例数据块：窗口函数：结果：(方波)(升余弦)1-|-||_-_||_--|||/\|||_/\_||\_0-||*|-|=|--_--||\|\_/-1-|-|--。</p><p>  Sometimes (resampling, precisely defined delay) you need to get samplevalues from between the known samplepoints. That&#39;s when you need interpolation. If you don&#39;t interpolate, and just throw away the fractional part of your sampleoffset, you get a lot of high frequency distortion:</p><p>有时(重新采样，精确定义的延迟)，您需要从已知采样点之间获取采样值。这就是你需要插补的时候。如果你不插补，只是扔掉样本偏移量的小数部分，你就会得到很多高频失真：</p><p> 0--- 0---0--- 0--- | | | | 0--- 0--- 0--- 0--- | | | | 0---0--- 0---0---</p><p>0-0-0-0|||0-0-0-0|||0-0-0-0。</p><p> In the example, the original samplepoints try to represent a sine wave. The closer the interpolated curve is to a sine wave, the better the interpolation algorithm is. The simpliest interpolation method is linear interpolation. Straight lines are drawn between two adjacent samplepoints:</p><p>在本例中，原始采样点尝试表示正弦波。插补曲线越接近正弦波，插补算法越好。最简单的插补方法是线性插补。在两个相邻采样点之间绘制直线：</p><p> 0_ _0---0_ _0 -_ _- -_ _- 0_ _0 0_ _0 -_ _- -_ _- 0---0 0---0</p><p>0__0-0__0-__--__-0__0 0__0-__--__-0-0 0-0。</p><p> Still looks quite &#34;edgy&#34; to be a sine wave. However, the improvement to uninterpolated is significant. There&#39;s also a drawback - the frequencies just below the Nyquist frequency get attenuated, even more than without interpolation. Here&#39;s the formula for linear interpolation: new = old(int)+(old(int+1)-old(int))*fract, where int means the integer part of sample offset and fract the fractional part.</p><p>它看起来仍然是一个非常前卫的正弦波。然而，对非插值的改进是显著的。这也有一个缺点--略低于奈奎斯特频率的频率会受到衰减，甚至比没有插补的情况下还要严重。这里是线性插值的公式：new=old(Int)+(old(int+1)-old(Int))*FRACT，其中int表示样本偏移量的整数部分，FRACT表示小数部分。</p><p> Next step could be Hermite curve, which gives in every way better quality than linear interpolation:</p><p>下一步可能是Hermite曲线，它在各个方面都比线性插值提供更好的质量：</p><p> ___ 0 _-0 0-_ 0 _ _ 0_ _0 0_ _0 _ _ _ _ -0___0- -0___0-</p><p>___0_-0 0-_0__0__0 0__0_-0_0--0__0-</p><p> With linear interpolation, you needed to know 2 samplepoints at time to be able to draw the line. With Hermite curve, the number is 4. The interpolation curve goes through the two middle points, and the points 1 and 4 are used in shaping the curve. The formula is a cubic:</p><p>使用线性插值法，你需要一次知道2个采样点才能画出这条线。对于Hermite曲线，其数值为4。插值曲线穿过两个中间点，1点和4点用于曲线的整形。公式是立方的：</p><p> new = a*fract^3 + b*fract^2 + c*fract + old(int+0), where: 3 ( old(int) - old(int+1) ) - old(int-1) + old(int+2) a = ----------------------------------------------------- 2 5 old(int) + old(int+2) b = 2 old(int+1) + old(int-1) - ----------------------- 2 old(int+1) - old(int-1) c = ----------------------- 2</p><p>NEW=a*FRACT^3+b*FRACT^2+c*FRACT+old(int+0)，在哪里：3(old(Int)-old(int+1))-old(int-1)+old(int+2)A=---2个5旧(整型)+旧(整型+2)B=2旧(int+1)+旧(int-1)。2个旧(int+1)-旧(int-1)C=2个。</p><p>  f(x) = ax^3 + bx^2 + cx + d / f(0) = y(0) | | f(1) = y(1) &lt; | f&#39;(0) = (y(1) - y(-1)) / 2 | \ f&#39;(1) = (y(2) - y(0)) / 2</p><p>F(X)=ax^3+bx^2+cx+d/f(0)=y(0)||f(1)=y(1)&lt；|f&#39；(0)=(y(1)-y(-1))/2|\F&#39；(1)=(y(2)-y(0))/2。</p><p> A perfect interpolation also exists. By replacing all the sample points with correctly scaled sinc curves, sin(pi x)/(pi x), and by adding them together, you get exact, perfect interpolation. Here is one of the samplepoints replaced with a scaled sinc curve:</p><p>一个完美的插值法也是存在的。通过用正确缩放的sinc曲线sin(Pi X)/(Pi X)替换所有采样点，并将它们相加，就可以得到精确、完美的插值。以下是用缩放的正弦曲线替换的采样点之一：</p><p> _--0--_ 0 0 _/ \_ _/ \_ _/ \_ __-----__ ---------/---------+---------\---------/---------\---------/========= \__ __/ \__ __/ --------- --- 0 --- 0 0</p><p>_--0--_00_/\__/\__/\_-__-/-+-\-/-\-/=\_/\_/。---0-00。</p><p> Sinc curve is endlessly long, so you&#39;d have to use all the samplepoints in calculation of one interpolated value. A practical solution would be to limit the number of samples to say 1000. It will still be too slow for a realtime application, but it&#39;ll give great accuracy. If you insist to use sinc in a realtime interpolation algorithm, try using a windowing function and a low number (at least 6) of sinc curves.</p><p>正弦曲线是无限长的，所以你必须使用所有的采样点来计算一个插值值。一个实际的解决方案是将样本数量限制在1000个以内。对于实时应用程序来说，它仍然太慢了，但它会提供很高的精确度。如果您坚持在实时插值算法中使用sinc，请尝试使用窗口函数和较少的sinc曲线(至少6条)。</p><p>  If you want to downsample (decrease the samplerate), you must first filter away the above Nyquist frequencies, or they will appear as distortion in the downsampled sample.</p><p>如果要下采样(降低采样率)，必须首先过滤掉上述奈奎斯特频率，否则它们将在下采样的样本中显示为失真。</p><p>  In the process of filter design, you often need to make compromises. To have sharp edges or steep slopes in the magnitude response, you will need a big, and therefore slow filter. In other words, filters with low number of taps practically always have gently sloping magnitude responses.</p><p>在滤波器设计过程中，往往需要做出妥协。要在幅值响应中具有锐利的边缘或陡峭的斜坡，您将需要一个大的、因此速度较慢的滤镜。换言之，抽头数较少的滤光器实际上总是具有平缓倾斜的幅度响应。</p><p> In the case of IIR filters, sharp edges in magnitude often mean an ugly (very nonlinear) phase frequency response, and close-to-linear phase response a gently sloping magnitude response. With FIR filters, an attempt to create very sharp edges may cause waving in the magnitudes of nearby frequencies.</p><p>在IIR滤波器的情况下，幅度的尖锐边缘通常意味着丑陋(非常非线性)的相位频率响应，而接近线性的相位响应意味着幅度响应的平缓倾斜。使用FIR滤波器，试图创建非常锐利的边缘可能会导致附近频率的幅度波动。</p><p> IIR filters are great for a realtime routine, because they are fast, their properties (for example cutoff frequency) can be quickly changed in the middle of action, and, they sound like real analog filters. :) The nonlinear phase response of IIR filters usually doesn&#39;t matter.</p><p>IIR滤波器非常适合实时程序，因为它们速度快，它们的特性(例如截止频率)可以在动作过程中快速改变，而且它们听起来像真正的模拟滤波器。：)IIR滤光片的非线性相位响应通常无关紧要。</p><p> FIR filters could be used where the quality and linear phase are important, for example, in a sample editor. People who filter other signals than sound, often desire linear phase frequency response.</p><p>FIR滤波器可以在质量和线性相位很重要的地方使用，例如，在样本编辑器中。对声音以外的其他信号进行滤波的人往往希望获得线性相频响应。</p><p> With stereo signal, it is important to have identical phase changes on left and right channels.</p><p>对于立体声信号，在左声道和右声道上具有相同的相位变化是很重要的。</p><p>  Lowpass: __________________ |__________________ Highpass: __________________ __________________| Bandpass or peak: _ _________________| |_________________ Notch, bandreject or bandstop: _________________ _________________ |_| Allpass: _____________________________________ (Changes in phase only)</p><p>低通行证：__________________|_海帕斯：___________________带通或峰值：__||_开槽，带阻或带阻：__所有通行证：_(仅限相变)。</p><p> If you have a symbolic calculation program, i strongly recommend you to use it in the mechanical calculations, just to make your life easier. &#34;Derive&#34; is an old DOS program, but still very useful.</p><p>如果你有一个符号计算程序，我强烈建议你在机械计算中使用它，只是为了让你的生活更容易。派生是一个旧的DOS程序，但仍然非常有用。</p><p>  White noise means the sort of noise that has flat spectrum. You can easily create it by using random numbers as samplevalues. If you want to know the magnitude frequency response of a filter, apply it on a long sample of white noise and then run a spectrum analysis on the output. What you see is the magnitude frequency response of the filter.</p><p>白噪声指的是频谱平坦的那种噪声。通过使用随机数作为样本值，可以很容易地创建它。如果你想知道滤波器的幅频响应，把它应用到白噪声的长样本上，然后对输出进行频谱分析。你看到的是滤波器的幅频响应。</p><p> Another way is to send a one-sample impulse, which originally has a flat spectrum. An impulse looks like this in the sampledata: 0, 0, 0, 0, 1, 0, 0, 0, 0 - where the impulse is the &#34;1&#34; in the middle.</p><p>另一种方式是发送一个样本脉冲，该脉冲最初具有平坦的频谱。在样本数据中，脉冲看起来是这样的：0，0，0，0，1，0，0，0，0-其中脉冲是中间的&#34；1&#34；。</p><p> From the two, the impulse thingy is faster, but using white noise can give cleaner-looking results, because errors will be less visible. For much the same reasons, when you are watching videos, a still picture will look more snowy than the running picture. Taking a spectrum analysis on a long sample is usually done by dividing it to smaller pieces, analyzing them separately and then taking the average of all the analyses. My personal choice here would be the program &#34;Cool Edit 96&#34;, which is for Windows.</p><p>两者相比，脉冲处理速度更快，但使用白噪声可以得到看起来更干净的结果，因为错误将不那么明显。出于大致相同的原因，当你在看视频时，静止的图片看起来会比运行的图片看起来更多的雪。对长样本进行光谱分析通常是将其分成小块，分别进行分析，然后取所有分析的平均值。在这里，我个人选择的是Windows版的Cool Edited96。</p><p>  Pole-zero method is the easiest way of designing fast and simple IIR filters. When you have learned it, you will be able to design filters by yourself.</p><p>零极点方法是设计快速、简单的IIR滤波器的最简单的方法。当你学会了它，你就能自己设计过滤器了。</p><p>  pi/2 &#34;|&#34; axis: imaginary __---|---__ &#34;-&#34; axis: real _/ | \_ (as always!) / | \ | | | pi -|--------+--------|- 0 | | | \_ | _/ \__ | __/ ---|--- 3/2 pi</p><p>PI/2&#34；|&#34；轴：虚数__-|-_&#34；-&#34；轴：实数_/|\_(一如既往！)/|\||PI-|-+-|-0||\_|_/\__|__/-|3/2圆周。</p><p> Imagine the frequencies to be wrapped around the unit circle. At angle 0 we have 0Hz, at pi/2 we have samplerate/4, at pi we have samplerate/2, the Nyquist frequency. You shouldn&#39;t care about higher frequencies, since they will never appear in the signal, but anyway, at 2pi (full cycle) we have the sampling frequency.</p><p>想象一下围绕单位圆包裹的频率。在角度0，我们有0赫兹，在pi/2我们有采样率/4，在pi我们有采样率/2，奈奎斯特频率。你不应该关心更高的频率，因为它们永远不会出现在信号中，但不管怎样，在2pi(完整周期)，我们有采样频率。</p><p> So if you used sampling frequency 44100 Hz, 0 Hz would be at (1,0), 11025 Hz at (0,1) and 22050 Hz at (-1,0).</p><p>因此，如果使用44100赫兹的采样频率，0赫兹将在(1，0)处，11025赫兹在(0，1)处，22050赫兹在(-1，0)处。</p><p>   __---|---__ o x = pole _/ o | \_ o = zero / | x \ | | x | -|-o------+--------|- | | x | \_ | x _/ \__o | __/ ---|--- o</p><p>__-|-__o x=极_/o|\_o=零/|x\|x-|-o-+-|--|x\_|x_/\__o|__/-|-o。</p><p> There are some rules you have to remember. Poles must always be inside the unit circle, never outside or on it. Zeros can be put anywhere. You can use any number of poles and zeros, but they must all have &#34;conjugate pairs&#34;, if they are not positioned on the &#34;-&#34; axis. Conjugate pairs means that if you put for example a zero to (0.6, 0.3), you must put another zero to the conjugate coordinate, (0.6,-0.3). And the same thing with poles.</p><p>有些规则你必须记住。杆子必须始终在单位圆的内部，不能在单位圆的外面或上面。零可以放在任何地方。您可以使用任意数量的极点和零点，但如果它们不位于&#34；-&#34；轴上，则它们必须都有共轭对。共轭对意味着，例如，如果您将一个零设置为(0.6，0.3)，则必须将另一个零设置为共轭坐标(0.6，-0.3)。杆子也是如此。</p><p>  Poles amplify frequencies, zeros attenuate.</p><p>极点放大频率，零点衰减。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://yehar.com/blog/?p=121">http://yehar.com/blog/?p=121</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/声音/">#声音</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sound/">#sound</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/滤波器/">#滤波器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>