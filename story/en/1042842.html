<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不透明：永远不会离开设备的密码 Opaque: Passwords That Never Leave Your Device</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Opaque: Passwords That Never Leave Your Device<br/>不透明：永远不会离开设备的密码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-02 08:16:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/d9a0f458f57a62760a9d0610393ae696.png"><img src="http://img2.diglog.com/img/2021/1/d9a0f458f57a62760a9d0610393ae696.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Passwords are a problem. They are a problem for reasons that are familiar to most readers. For us at Cloudflare, the problem lies much deeper and broader. Most readers will immediately acknowledge that passwords are hard to remember and manage, especially as password requirements grow increasingly complex. Luckily there are great software packages and browser add-ons to help manage passwords. Unfortunately, the greater underlying problem is beyond the reaches of software to solve.</p><p>密码是个问题。由于大多数读者所熟悉的原因，它们是一个问题。对于我们Cloudflare而言，问题更加深远和广泛。大多数读者会立即意识到，难以记住和管理密码，尤其是随着密码要求变得越来越复杂。幸运的是，有很棒的软件包和浏览器附加组件可帮助您管理密码。不幸的是，更大的潜在问题超出了软件解决的范围。</p><p> The fundamental password problem is simple to explain, but hard to solve: A password that leaves your possession is guaranteed to sacrifice security, no matter its complexity or how hard it may be to guess. Passwords are insecure by their very existence.</p><p> 基本的密码问题很容易解释，但很难解决：保证离开您的密码的安全性，无论它的复杂性或猜测的难度有多大，都可以保证。密码因其本身而不安全。</p><p> You might say, “but passwords are always stored in encrypted format!” That would be great. More accurately, they are likely stored as a salted hash, as explained below. Even worse is that there is no way to verify the way that passwords are stored, and so we can assume that on some servers passwords are stored in cleartext. The truth is that even responsibly stored passwords can be leaked and broken, albeit (and thankfully) with enormous effort. An increasingly pressing problem stems from the nature of passwords themselves: any direct use of a password, today, means that the password must be handled in the clear.</p><p> 您可能会说：“但是密码始终以加密格式存储！”那很好啊。更准确地说，它们很可能存储为盐腌哈希，如下所述。更糟糕的是，无法验证密码的存储方式，因此我们可以假设在某些服务器上密码以明文形式存储。事实是，即使（负责任地）付出了巨大的努力，即使负责任地存储的密码也可能被泄露和破坏。日益迫切的问题源于密码本身的性质：如今，任何直接使用密码的行为都意味着必须以明文形式处理密码。</p><p> You say, “but my password is transmitted securely over HTTPS!” This is true.</p><p> 您说：“但是我的密码是通过HTTPS安全传输的！”这是真的。</p><p> You say, “but I know the server stores my password in hashed form, secure so no one can access it!” Well, this puts a lot of faith in the server. Even so, let’s just say that yes, this may be true, too.</p><p> 您说，“但是我知道服务器以安全的哈希表形式存储我的密码，因此没有人可以访问它！”好吧，这使人们对服务器充满信心。即便如此，我们只能说是，这也可能是对的。</p><p> There remains, however, an important caveat — a gap in the end-to-end use of passwords. Consider that once a server receives a password, between being securely transmitted and securely stored, the password has to be read and processed. Yes, as cleartext!</p><p> 但是，还有一个重要的警告-端到端使用密码方面的差距。考虑一下，一旦服务器接收到密码（介于安全传输和安全存储之间），就必须读取并处理该密码。是的，作为明文！</p><p> And it gets worse — because so many are used to thinking in software, it’s easy to forget about the vulnerability of hardware. This means that even if the software is somehow trusted, the password must at some point reside in memory. The password must at some point be transmitted over a shared bus to the CPU. These provide vectors of attack to on-lookers in many forms. Of course, these attack vectors are far less likely than those presented by transmission and permanent storage, but they are no less severe (recent CPU vulnerabilities such as Spectre and Meltdown should serve as a stark reminder.)</p><p> 而且情况变得更糟–由于有太多人习惯于使用软件进行思考，因此很容易忘记硬件的漏洞。这意味着即使软件受到某种程度的信任，密码也必须在某个时候驻留在内存中。密码必须在某个时刻通过共享总线传输到CPU。这些以多种形式向旁观者提供了攻击的载体。当然，这些攻击媒介的可能性远小于传输和永久存储所呈现的那些，但它们的危害程度也同样如此（最近的CPU漏洞，如Spectre和Meltdown应当作为一个明显的提醒）。 </p><p> The only way to fix this problem is to get rid of passwords altogether. There is hope! Research and private sector communities are working hard to do just that. New standards are emerging and growing mature. Unfortunately, passwords are so ubiquitous that it will take a long time to agree on and supplant passwords with new standards and technology.</p><p>解决此问题的唯一方法是完全删除密码。还有希望！研究和私营部门社区正为此而努力。新标准正在涌现并日趋成熟。不幸的是，密码无处不在，以至于要花很多时间才能同意并用新的标准和技术取代密码。</p><p> At Cloudflare, we’ve been asking if there is something that can be done now, imminently. Today’s deep-dive into OPAQUE is one possible answer. OPAQUE is one among many examples of systems that enable a password to be useful without it ever leaving your possession. No one likes passwords, but as long they’re in use, at least we can ensure they are never given away.</p><p> 在Cloudflare，我们一直在询问是否有可以立即完成的工作。今天深入探讨OPAQUE是一个可能的答案。 OPAQUE是众多系统示例中的一种，它使密码在不离开您的财产的情况下就变得有用。没有人喜欢密码，但是只要使用了密码，至少我们可以确保永远不会丢失密码。</p><p> I’ll be the first to admit that password-based authentication is annoying. Passwords are hard to remember, tedious to type, and notoriously insecure. Initiatives to reduce or replace passwords are promising. For example,  WebAuthn is a standard for web authentication based primarily on public key cryptography using hardware  (or software) tokens. Even so, passwords are frustratingly persistent as an authentication mechanism. Whether their persistence is due to their ease of implementation, familiarity to users, or simple ubiquity on the web and elsewhere, we’d like to make password-based authentication as secure as possible while they persist.</p><p> 我将第一个承认基于密码的身份验证令人讨厌。密码难以记住，输入乏味且非常不安全。减少或替换密码的举措很有希望。例如，WebAuthn是主要用于使用硬件（或软件）令牌的公钥密码术的Web身份验证的标准。即便如此，密码还是作为身份验证机制而令人沮丧的持久性。无论他们的持久性是由于其易于实施，对用户的熟悉还是在网络上和其他地方的普遍存在，我们都希望在他们持久存在的同时，尽可能确保基于密码的身份验证的安全性。</p><p> My internship at Cloudflare focused on OPAQUE, a cryptographic protocol that solves one of the most glaring security issues with password-based authentication on the web: though passwords are typically protected in transit by HTTPS,  servers  handle them in plaintext to check their correctness. Handling plaintext passwords is dangerous, as accidentally logging or caching them could lead to a catastrophic breach. The goal of the project, rather than to advocate for adoption of any particular protocol, is to show that OPAQUE is a viable option among many for authentication. Because the web case is most familiar to me, and likely many readers, I will use the web as my main example.</p><p> 我在Cloudflare的实习重点是OPAQUE，这是一种加密协议，可以解决基于Web的基于密码的身份验证中最明显的安全问题之一：尽管密码通常在传输过程中受到HTTPS的保护，但服务器会以纯文本格式对其进行处理以检查其正确性。处理纯文本密码很危险，因为不小心记录或缓存它们可能会导致灾难性的破坏。该项目的目标不是证明主张采用任何特定协议，而是表明OPAQUE是许多认证中的可行选择。因为网络案例是我最熟悉的，并且可能有很多读者，所以我将以网络为主要示例。</p><p>  When you type in a password on the web, what happens? The website must check that the password you typed is the same as the one you originally registered with the site. But how does this check work?</p><p>  当您在网络上输入密码时，会发生什么？网站必须检查您输入的密码是否与您最初在网站上注册的密码相同。但是该检查如何工作？</p><p> Usually, your username and password are sent to a server. The server then checks if the registered password associated with your username matches the password you provided. Of course, to prevent an attacker eavesdropping on your Internet traffic from stealing your password, your connection to the server should be encrypted via HTTPS (HTTP-over-TLS).</p><p> 通常，您的用户名和密码会发送到服务器。然后，服务器检查与您的用户名关联的注册密码是否​​与您提供的密码匹配。当然，为了防止窃听您的Internet流量的攻击者窃取您的密码，您与服务器的连接应通过HTTPS（TLS上的HTTP）进行加密。</p><p> Despite use of HTTPS, there still remains a glaring problem in this flow: the server must store a representation of your password somewhere. Servers are hard to secure, and breaches are all too common. Leaking this representation can cause catastrophic security problems. (For records of the latest breaches, check out  https://haveibeenpwned.com/).</p><p> 尽管使用了HTTPS，但在此流程中仍然存在一个明显的问题：服务器必须将您的密码表示存储在某个地方。服务器很难保护，而且违反行为也很常见。泄漏此表示可能会导致灾难性的安全问题。 （有关最新违规记录，请访问https://haveibeenpwned.com/）。 </p><p> To make these leaks less devastating, servers often apply a  hash function to user passwords. A hash function maps each password to a unique, random-looking value. It’s easy to apply the hash to a password, but almost impossible to reverse the function and retrieve the password. (That said, anyone can guess a password, apply the hash function, and check if the result is the same.)</p><p>为了减少这些泄漏的破坏性，服务器通常将哈希函数应用于用户密码。哈希函数将每个密码映射到一个唯一的，看起来随机的值。将哈希值应用到密码很容易，但是几乎不可能撤消该功能并检索密码。 （也就是说，任何人都可以猜出密码，应用哈希函数并检查结果是否相同。）</p><p> With password hashing, plaintext passwords are no longer stored on servers.  An attacker who steals a password database no longer has direct access to passwords. Instead, the attacker must apply the hash to many possible passwords and compare the results with the leaked hashes.</p><p> 使用密码散列，纯文本密码不再存储在服务器上。窃取密码数据库的攻击者不再可以直接访问密码。相反，攻击者必须将哈希应用于许多可能的密码，并将结果与​​泄漏的哈希进行比较。</p><p> Unfortunately, if a server hashes only the passwords, attackers can download precomputed  rainbow tables containing hashes of trillions of possible passwords and almost instantly retrieve the plaintext passwords. (See  https://project-rainbowcrack.com/table.htm for a list of some rainbow tables).</p><p> 不幸的是，如果服务器仅对密码进行哈希处理，则攻击者可以下载包含数万亿个可能的哈希值的哈希表，并且几乎可以立即检索纯文本密码。 （有关一些彩虹表的列表，请参见https://project-rainbowcrack.com/table.htm）。</p><p> With this in mind, a good defense-in-depth strategy is to use  salted hashing, where the server hashes your password appended to a random, per-user value called a  salt. The server also saves the salt alongside the username, so the user never sees or needs to submit it. When the user submits a password, the server re-computes this hash function using the salt. An attacker who steals password data, i.e., the password representations and salt values, must then guess common passwords one by one and apply the (salted) hash function to each guessed password. Existing rainbow tables won’t help because they don’t take the salts into account, so the attacker needs to make a new rainbow table for each user!</p><p> 考虑到这一点，一个很好的纵深防御策略是使用加盐哈希，即服务器将您的密码散列到每个用户的随机随机值salt中。服务器还将盐与用户名一起保存，因此用户永远不会看到或不需要提交它。当用户提交密码时，服务器将使用salt重新计算此哈希函数。然后，窃取密码数据（即密码表示形式和盐值）的攻击者必须一个一个地猜出通用密码，并将（加盐的）哈希函数应用于每个猜出的密码。现有的彩虹表没有帮助，因为它们没有考虑到盐分，因此攻击者需要为每个用户创建一个新的彩虹表！</p><p> This (hopefully) slows down the attack enough for the service to inform users of a breach, so they can change their passwords. In addition, the salted hashes should be  hardened by applying a hash many times to further slow attacks. (See  https://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/ for a more detailed discussion).</p><p> （希望）这样可以充分降低攻击速度，使服务可以通知用户安全漏洞，以便他们可以更改密码。此外，应通过多次应用哈希来进一步加慢攻击速度，以强化盐渍的哈希值。 （有关更详细的讨论，请参见https://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/）。</p><p> These two mitigation strategies — encrypting the password in transit and storing salted, hardened hashes — are the current best practices.</p><p> 这两种缓解策略是在传输过程中对密码进行加密，以及存储腌制，硬化的哈希值，这是当前的最佳做法。</p><p> A large security hole remains open.  Password-over-TLS (as we will call it) requires users to  send plaintext passwords to servers during login, because servers must see these passwords to match against registered passwords on file. Even a well-meaning server could accidentally cache or log your password attempt(s), or become corrupted in the course of checking passwords. (For example, Facebook detected in 2019 that it had  accidentally been storing hundreds of millions of plaintext user passwords). Ideally, servers should never see a plaintext password at all.</p><p> 仍然有一个较大的安全孔。基于TLS的密码（我们将其称为）要求用户在登录期间向服务器发送纯文本密码，因为服务器必须看到这些密码才能与文件中已注册的密码匹配。甚至是信誉良好的服务器也可能会意外缓存或记录您的密码尝试，或者在检查密码的过程中损坏。 （例如，Facebook在2019年检测到它不小心存储了数亿纯文本用户密码）。理想情况下，服务器根本不应该看到纯文本密码。 </p><p> But that’s quite a conundrum: how can you check a password if you never see the password? Enter OPAQUE: a Password-Authenticated Key Exchange (PAKE) protocol that simultaneously proves knowledge of a password and derives a secret key. Before describing OPAQUE in detail, we’ll first summarize PAKE functionalities in general.</p><p>但这是一个很大的难题：如果您从未看到密码，如何检查密码？输入OPAQUE：密码认证密钥交换（PAKE）协议，该协议同时证明密码知识并导出秘密密钥。在详细描述OPAQUE之前，我们首先将概述一下PAKE的功能。</p><p>  Password-Authenticated Key Exchange (PAKE) was proposed by Bellovin and Merrit [1] in 1992, with an initial motivation of allowing password-authentication without the possibility of dictionary attacks based on data transmitted over an insecure channel.</p><p>  密码验证密钥交换（PAKE）由Bellovin和Merrit [1]在1992年提出，其最初的动机是允许密码验证，而不会基于通过不安全通道传输的数据进行字典攻击。</p><p> Essentially, a plain, or  symmetric, PAKE is a cryptographic protocol that allows two parties who share only a password to establish a strong shared secret key. The goals of PAKE are:</p><p> 本质上，简单或对称的PAKE是一种加密协议，它允许仅共享密码的两个方建立强共享密钥。 PAKE的目标是：</p><p>  2) Participants do not need to trust third parties (in particular, no Public Key Infrastructure),</p><p>  2）参与者无需信任第三方（尤其是无需公钥基础设施），</p><p> 3) The resulting secret key is not learned by anyone not participating in the protocol - including those who know the password.</p><p> 3）不参与协议的任何人（包括知道密码的人）都不会学习到生成的密钥。</p><p> 4) The protocol does not reveal either parties’ password to each other (unless the passwords match), or to eavesdroppers.</p><p> 4）该协议不会透露彼此的密码（除非密码匹配），也不会透露给窃听者。</p><p> In sum, the only way to successfully attack the protocol is to guess the password correctly while participating in the protocol. (Luckily, such attacks can be mostly thwarted by rate-limiting, i.e, blocking a user from logging in after a certain number of incorrect password attempts).</p><p> 总之，成功攻击协议的唯一方法是在参与协议时正确猜测密码。 （幸运的是，此类攻击通常可以通过限制速率来阻止，即在一定数量的错误密码尝试后阻止用户登录）。 </p><p>  It relies on WebPKI, which places trust in third-parties called Certificate Authorities (see  https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/ for an in-depth explanation of WebPKI and some of its shortcomings).</p><p>它依赖于WebPKI，WebPKI信任称为证书颁发机构的第三方（请参阅https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/，以获取有关WebPKI及其某些缺点的深入说明）。</p><p>  Password-over-TLS provides the user no assurance that the server knows their password or a derivative of it — a server could accept any input from the user with no checks whatsoever.</p><p>  TLS上的密码无法为用户提供任何保证，让其知道服务器是否知道其密码或密码的派生产品-服务器可以接受用户的任何输入而无需任何检查。</p><p> That said, plain PAKE is still worse than Password-over-TLS, simply because it requires the server to  store plaintext passwords. We need a PAKE that lets the server store salted hashes if we want to beat the current practice.</p><p> 就是说，简单的PAKE仍然比TLS上的密码差，只是因为它要求服务器存储明文密码。如果我们想击败当前的做法，我们需要一个PAKE来让服务器存储盐腌的哈希。</p><p> An improvement over plain PAKE is what’s called an  asymmetric PAKE (aPAKE), because only the client knows the password, and the server knows a  hashed password. An aPAKE has the four properties of PAKE, plus one more:</p><p> 相对于普通PAKE的改进就是所谓的非对称PAKE（aPAKE），因为只有客户端知道密码，而服务器才知道哈希密码。一个aPAKE具有PAKE的四个属性，以及另外一个：</p><p> 5) An attacker who steals password data stored on the server must perform a dictionary attack to retrieve the password.</p><p> 5）窃取服务器上存储的密码数据的攻击者必须执行字典攻击才能检索密码。</p><p> The issue with most existing aPAKE protocols, however, is that they do not allow for a  salted hash (or if they do, they require that salt to be transmitted to the user, which means the attacker has access to the salt beforehand and can begin computing a rainbow table for the user before stealing any data). We’d like, therefore, to upgrade the security property as follows:</p><p> 但是，大多数现有的aPAKE协议存在的问题是，它们不允许加盐散列（否则，它们要求将盐传输给用户，这意味着攻击者可以事先访问盐并可以开始在窃取任何数据之前为用户计算彩虹表）。因此，我们希望按以下方式升级安全性属性：</p><p> 5*) An attacker who steals password data stored on the server must perform a  per-user dictionary attack to retrieve the password  after the data is compromised.</p><p> 5 *）窃取服务器上存储的密码数据的攻击者必须对每个用户进行字典攻击，以在数据遭到破坏后检索密码。 </p><p> OPAQUE is the first aPAKE protocol with a formal security proof that has this property: it allows for a completely secret salt.</p><p>OPAQUE是第一个具有正式安全证明的aPAKE协议，该协议具有此属性：它允许完全保密的盐。</p><p>   OPAQUE is what’s referred to as a  strong aPAKE, which simply means that it resists these pre-computation attacks by using a secretly salted hash on the server. OPAQUE was proposed and formally analyzed by Stanislaw Jarecki, Hugo Krawcyzk and Jiayu Xu in 2018 (full disclosure: Stanislaw Jarecki is my academic advisor). The name OPAQUE is a combination of the names of two cryptographic protocols: OPRF and PAKE. We already know PAKE, but what is an OPRF? OPRF stands for Oblivious Pseudo-Random Function, which is a protocol by which two parties compute a function  F(key, x) that is deterministic but outputs random-looking values. One party inputs the value  x, and another party inputs the key - the party who inputs  x learns the result  F(key, x) but not the key, and the party providing the key learns nothing.  (You can dive into the math of OPRFs here:  https://blog.cloudflare.com/privacy-pass-the-math/).</p><p>   OPAQUE是一种强大的aPAKE，它简单地意味着它通过在服务器上使用秘密加盐的哈希来抵御这些预先计算的攻击。 OPAQUE由Stanislaw Jarecki，Hugo Krawcyzk和Xujiayu于2018年提出并进行了正式分析（全部披露：Stanislaw Jarecki是我的学术顾问）。名称OPAQUE是两个密码协议名称的组合：OPRF和PAKE。我们已经知道PAKE，但是什么是OPRF？ OPRF代表“遗忘伪随机函数”，这是一种协议，通过该协议，双方可以计算确定性的函数F（key，x），但输出看似随机的值。一方输入值x，另一方输入键-输入x的一方学习结果F（key，x），但不学习键，提供键的一方学不到任何东西。 （您可以在此处深入了解OPRF的数学方法：https：//blog.cloudflare.com/privacy-pass-the-math/）。</p><p> The core of OPAQUE is a method to store user secrets for safekeeping on a server, without giving the server access to those secrets. Instead of storing a traditional salted password hash, the server stores a secret envelope for you that is “locked” by two pieces of information: your password known only by you, and a random secret key (like a salt) known only by the server. To log in, the client initiates a cryptographic exchange that reveals the envelope key to the client, but, importantly, not to the server.</p><p> OPAQUE的核心是一种将用户机密存储在服务器上的安全方法，而无需授予服务器访问这些机密的权限。服务器没有存储传统的加盐密码哈希，而是为您存储了一个秘密信封，该信封被两个信息“锁定”：只有您自己知道的密码和只有服务器才知道的随机秘密密钥（如盐） 。要登录，客户端将启动一个加密交换，该交换将信封密钥显示给客户端，但重要的是，不会显示给服务器。</p><p> The server then sends the envelope to the user, who now can retrieve the encrypted keys. (The keys included in the envelope are a private-public key pair for the user, and a public key for the server.) These keys, once unlocked, will be the inputs to an Authenticated Key Exchange (AKE) protocol, which allows the user and server to establish a secret key which can be used to encrypt their future communication.</p><p> 然后，服务器将信封发送给用户，该用户现在可以检索加密的密钥。 （信封中包含的密钥是用于用户的私钥-公共密钥对，以及用于服务器的公共密钥。）这些密钥一旦解锁，将成为Authenticated Key Exchange（AKE）协议的输入，该协议允许用户和服务器建立一个秘密密钥，该密钥可用于加密他们未来的通信。</p><p>   Before registration, the user first signs up for a service and picks a username and password. Registration begins with the OPRF flow we just described: Alice (the user) and Bob (the server) do an OPRF exchange. The result is that Alice has a random key   rwd,  derived from the OPRF output  F(key, pwd), where key is a server-owned OPRF key specific to Alice and  pwd is Alice’s password.</p><p>   在注册之前，用户首先注册服务并选择用户名和密码。注册从我们刚刚描述的OPRF流程开始：Alice（用户）和Bob（服务器）进行OPRF交换。结果是Alice具有一个随机密钥rwd，该随机密钥是从OPRF输出F（key，pwd）导出的，其中key是特定于Alice的服务器拥有的OPRF密钥，而pwd是Alice的密码。</p><p> Within his OPRF message, Bob sends the public key for his OPAQUE identity. Alice then generates a new private/public key pair, which will be her persistent OPAQUE identity for Bob’s service, and encrypts  her private key along with  Bob’s public key with the  rwd (we will call the result an  encrypted envelope). She sends this encrypted envelope along with her public key (unencrypted) to Bob, who stores the data she provided, along with Alice’s specific OPRF keysecret, in a database indexed by her username.</p><p> 在他的OPRF消息中，鲍勃发送其OPAQUE身份的公共密钥。然后，爱丽丝会生成一个新的私钥/公钥对，这将是她对鲍勃服务的永久OPAQUE身份，并使用rwd加密她的私钥以及鲍勃的公钥（我们将结果称为加密信封）。她将这个加密的信封连同她的公共密钥（未加密）一起发送给Bob，后者将她提供的数据以及Alice的特定OPRF密钥秘密存储在由她的用户名索引的数据库中。</p><p>   The login phase is very similar. It starts the same way as registration — with an OPRF flow. However, on the server side, instead of generating a new OPRF key, Bob instead looks up the one he created during Alice’s registration. He does this by looking up Alice’s username (which she provides in the first message), and retrieving his record of her. This record contains her public key, her encrypted envelope, and Bob’s OPRF key for Alice.</p><p>   登录阶段非常相似。它以与注册相同的方式开始-带有OPRF流程。但是，在服务器端，鲍勃没有生成新的OPRF密钥，而是查找了他在爱丽丝注册期间创建的密钥。为此，他查找了爱丽丝的用户名（她在第一条消息中提供的用户名），并检索了他的记录。该记录包含她的公钥，她的加密信封以及鲍勃（Bob）对爱丽丝（Alice）的OPRF密钥。 </p><p> He also sends over the encrypted envelope which Alice can decrypt with the output of the OPRF flow. (If decryption fails, she aborts the protocol — this likely indicates that she typed her password incorrectly, or Bob isn’t who he says he is). If decryption succeeds, she now has her own secret key and Bob’s public key. She inputs these into an AKE protocol with Bob, who, in turn, inputs his private key and her public key, which gives them both a fresh shared secret key.</p><p>他还发送了加密的信封，爱丽丝可以使用OPRF流的输出对其进行解密。 （如果解密失败，她将中止该协议-这很可能表明她输入了错误的密码，或者Bob不是他说的那样）。如果解密成功，她现在将拥有自己的秘密密钥和鲍勃的公共密钥。她与Bob一起将它们输入到AKE协议中，Bob依次输入了他的私钥和她的公钥，这给了他们两个新的共享密钥。</p><p>   An important question to ask here is: what AKE is suitable for OPAQUE? The  emerging CFRG specification outlines several options, including 3DH and SIGMA-I. However, on the web, we already have an AKE at our disposal: TLS!</p><p>   这里要问的一个重要问题是：哪种AKE适合不透明？新兴的CFRG规范概述了几种选择，包括3DH和SIGMA-I。但是，在网络上，我们已经可以使用AKE：TLS！</p><p> Recall that TLS is an AKE because it provides unilateral (and mutual) authentication with shared secret derivation. The core of TLS is a Diffie-Hellman key exchange, which by itself is  unauthenticated, meaning that the parties running it have no way to verify who they are running it with. (This is a problem because when you log into your bank, or any other website that stores your private data, you want to be sure that they are who they say they are). Authentication primarily uses certificates, which are issued by trusted entities through a system called  Public Key Infrastructure (PKI). Each certificate is associated with a secret key. To prove its identity, the server presents its certificate to the client, and signs the TLS handshake with its secret key.</p><p> 回想一下，TLS是一个AKE，因为它提供了具有共享秘密派生的单边（和相互）身份验证。 TLS的核心是Diffie-Hellman密钥交换，该密钥交换本身未经身份验证，这意味着运行它的各方无法验证与谁一起运行。 （这是一个问题，因为当您登录银行或存储您的私人数据的任何其他网站时，您需要确保他们是他们所说的人）。身份验证主要使用证书，这些证书由受信实体通过称为公钥基础结构（PKI）的系统颁发。每个证书都与一个密钥相关联。为了证明其身份，服务器将其证书提供给客户端，并使用其私钥对TLS握手进行签名。</p><p> Modifying this ubiquitous certificate-based authentication on the web is perhaps not the best place to start. Instead, an improvement would be to authenticate the TLS shared secret,  using OPAQUE, after the TLS handshake completes. In other words, once a server is authenticated with its typical WebPKI certificate, clients could subsequently authenticate to the server. This authentication could take place “post handshake” in the TLS connection using OPAQUE.</p><p> 在网络上修改这种无处不在的基于证书的身份验证可能不是最佳的起点。相反，一种改进将是在TLS握手完成之后使用OPAQUE对TLS共享机密进行身份验证。换句话说，一旦使用其典型的WebPKI证书对服务器进行身份验证，客户端便可以随后对该服务器进行身份验证。可以使用OPAQUE在TLS连接中进行“后握手”身份验证。</p><p> Exported Authenticators are one mechanism for “post-handshake” authentication in TLS. They allow a server or client to provide proof of an identity without setting up a new TLS connection. Recall that in the standard web case, the server establishes their identity with a certificate (proving, for example, that they are “cloudflare.com”). But if the same server also holds alternate identities, they must run TLS again to prove who they are.</p><p> 导出的身份验证器是TLS中“握手后”身份验证的一种机制。它们允许服务器或客户端提供身份证明，而无需设置新的TLS连接。回想一下，在标准的Web案例中，服务器使用证书来建立其身份（例如，证明它们是“ cloudflare.com”）。但是，如果同一服务器还拥有备用身份，则它们必须再次运行TLS以证明自己是谁。</p><p> The basic Exported Authenticator flow works resembles a classical challenge-response protocol, and works as follows. (We’ll consider the server authentication case only, as the client case is symmetric).</p><p> 导出的身份验证器基本流程的工作类似于经典的质询-响应协议，其工作方式如下。 （我们将仅考虑服务器身份验证的情况，因为客户端的情况是对称的）。</p><p>  At any point after a TLS connection is established, Alice (the client) sends an  authenticator request to indicate that she would like Bob (the server) to prove an additional identity. This request includes a context (an unpredictable string — think of this as a challenge), and extensions which include information about what identity the client wants to be provided. For example, the client could include the SNI extension to ask the server for a certificate associated with a certain domain name other than the one initially used in the TLS connection.</p><p>  建立TLS连接后的任何时候，Alice（客户端）都会发送身份验证器请求，以表明她希望Bob（服务器）证明其他身份。该请求包括上下文（不可预测的字符串-将此视为挑战），以及扩展，包括有关要提供客户端身份的信息。例如，客户端可以包括SNI扩展名，以向服务器请求与某个域名相关联的证书，而不是最初用于TLS连接的域名。 </p><p> On receipt of the client message, if the server has a valid certificate corresponding to the request, it sends back an  exported authenticator which proves that it has the secret key for the certificate. (This message has the same format as an Auth message from the client in TLS 1.3 handshake - it contains a Certificate, a CertificateVerify and a Finished message). If the server cannot or does not wish to authenticate with the requested certificate, it replies with an empty authenticator which contains only a well formed Finished message.</p><p>在接收到客户端消息后，如果服务器具有与该请求相对应的有效证书，则它将发回一个导出的身份验证器，以证明它具有该证书的密钥。 （此消息与TLS 1.3握手中来自客户端的Auth消息具有相同的格式-它包含一个证书，一个CertificateVerify和一个Finished消息）。如果服务器不能或不希望通过请求的证书进行身份验证，它将以空身份验证器答复，该身份验证器仅包含格式正确的“完成”消息。</p><p> The client then checks that the Exported Authenticator it receives is well-formed, and then verifies that the certificate presented is valid, and if so, accepts the new identity.</p><p> 然后，客户端检查其收到的导出的身份验证器格式正确，然后验证所提供的证书是否有效，如果是，则接受新的身份。</p><p> In sum, Exported Authenticators provide authentication in a higher layer (such as the application layer) safely by leveraging the well-vetted cryptography and message formats of TLS. Furthermore, it is tied to the TLS session so that authentication messages can&#39;t be copied and pasted from one TLS connection into another. In other words, Exported Authenticators provide exactly the right hooks needed to add OPAQUE-based authentication into TLS.</p><p> 总之，通过使用经过严格审查的TLS加密和消息格式，导出的身份验证器可以在更高的层（例如应用程序层）中安全地提供身份验证。此外，它与TLS会话相关联，因此无法将身份验证消息从一个TLS连接复制并粘贴到另一个TLS连接中。换句话说，导出的身份验证器提供了将基于OPAQUE的身份验证添加到TLS所需的正确钩子。</p><p>   OPAQUE-EA allows OPAQUE to run at any point after a TLS connection has already been set up. Recall that Bob (the server) will store his OPAQUE identity, in this case a signing key and verification key, and Alice will store her identity — encrypted — on Bob’s server. (The registration flow where Alice stores her encrypted keys is the same as in regular OPAQUE, except she stores a signing key, so we will skip straight to the login flow). Alice and Bob run two request-authenticate EA flows, one for each party, and OPAQUE protocol messages ride along in the extensions section of the EAs. Let’s look in detail how this works.</p><p>   OPAQUE-EA允许OPAQUE在已建立TLS连接之后的任何时间运行。回想一下Bob（服务器）将存储他的OPAQUE身份（在这种情况下为签名密钥和验证密钥），而Alice将其身份（已加密）存储在Bob的服务器上。 （Alice存储她的加密密钥的注册流程与常规OPAQUE中的相同，只是她存储了签名密钥，因此我们将直接跳至登录流程）。爱丽丝（Alice）和鲍勃（Bob）运行两个请求身份验证的EA流，每一方一个，并且OPAQUE协议消息随即出现在EA的扩展部分中。让我们详细看看它是如何工作的。</p><p> First, Alice generates her OPRF message based on her password. She creates an Authenticator Request asking for Bob’s OPAQUE identity, and includes (in the extensions field) her username and her OPRF message, and sends this to Bob over their established TLS connection.</p><p> 首先，爱丽丝根据她的密码生成她的OPRF消息。她创建了一个身份验证器请求，询问鲍勃的OPAQUE身份，并在扩展名字段中包含了她的用户名和OPRF消息，并将其通过已建立的TLS连接发送给鲍勃。</p><p> Bob receives the message and looks up Alice’s username in his database. He retrieves her OPAQUE record containing her verification key and encrypted envelope, and his OPRF key. He uses the OPRF key on the OPRF message, and creates an Exported Authenticator proving ownership of his OPAQUE signing key, wit</p><p> 鲍勃收到消息并在他的数据库中查找爱丽丝的用户名。他检索了包含验证密钥和加密信封以及OPRF密钥的OPAQUE记录。他在OPRF消息上使用OPRF密钥，并创建一个Exported Authenticator，以证明其OPAQUE签名密钥的机密。</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudflare.com/opaque-oblivious-passwords">https://blog.cloudflare.com/opaque-oblivious-passwords</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/密码/">#密码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/passwords/">#passwords</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>