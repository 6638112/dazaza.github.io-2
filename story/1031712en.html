<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>软件体系结构的大统一理论</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">软件体系结构的大统一理论</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-28 13:51:13</div><div class="page_narrow text-break page_content"><p>Take  Uncle Bob&#39;s Clean Architecture and map its correspondences with  Gary Bernhardt&#39;s thin imperative shell around a functional core, and you get an understanding of how to cheaply maintain and scale software!</p><p>以Bob叔叔的Clean Architecture为例，将其对应关系与Gary Bernhardt围绕功能核心的薄命令性外壳进行映射，您就会了解如何以较低的成本维护和扩展软件！</p><p> This is what  Mr. Brandon Rhodes did. It&#39;s not every day that I find such clear insight.</p><p>这就是布兰登·罗兹先生所做的。我并不是每天都能找到如此清晰的洞察力。</p><p> I am honored to have found his  presentation and  slides explaining  Uncle Bob&#39;s Clean Architecture and Gary Bernhardt&#39;s PyCon talks of  2011,  2012, and  2013.</p><p>我很荣幸能找到他的演示文稿和幻灯片，解释鲍勃大叔2011年、2012年和2013年的清洁建筑和加里·伯恩哈特的PyCon演讲。</p><p> Mr. Rhodes offers such a distilled view, that he can show you these crucial concepts in 3 slides of code. I will go ahead and summarize what he said and add a tiny bit of my insight.</p><p>Rhodes先生提供了如此精炼的视图，以至于他可以用3张代码幻灯片向您展示这些关键概念。我将继续总结他所说的话，并补充一点我的见解。</p><p> Copyright of all Python code on this page belongs to  Mr. Brandon Rhodes, and copyright of the diagram belongs to  Robert C. Martin (Uncle Bob). I use these under (hopefully) fair use (nonprofit and educational).</p><p>本页上所有Python代码的版权属于Brandon Rhodes先生，图表的版权属于Robert C.Martin(Bob叔叔)。我在(希望)合理使用的情况下使用这些(非营利和教育性的)。</p><p>   First of all, we need to be on the same page, in order to be able to understand each other. Here are the words I&#39;ll use:</p><p>首先，我们需要达成一致，才能相互理解。以下是我将使用的词语：</p><p> Function: I use &#34;function&#34; or &#34;pure function&#34; to refer to a Python &#34;function&#34; that only uses its parameters for input, returns a result as output, and does not cause any other side-effects (such as I/O).  A pure function may be called any number of times without changing the system state - it should have no influence on DB, UI, other functions or classes.</p><p>函数：我使用&#34；函数&34；或&#34；纯函数&#34；来引用一个Python&#34；函数&#34；，该函数只将其参数用于输入，返回结果作为输出，并且不会导致任何其他副作用(如I/O)。纯函数可以在不更改系统状态的情况下被调用任意次-它不应该影响DB、UI、其他函数或类。</p><p> This is very similar to a mathematical function: takes you from  x to  y and nothing else happens.</p><p>这非常类似于数学函数：将您从x带到y，不会发生任何其他事情。</p><p> Procedure, Routine, or Subroutine: A piece of code that executes, that may or may not have side effects. This is a &#34;function&#34; in Python, but might not be a &#34;pure function&#34;.</p><p>过程、例程或子例程：执行的一段代码，它可能有副作用，也可能没有副作用。这是Python中的&#34；函数&#34；，但可能不是纯函数&#34；。</p><p> Tests: automated unit tests. By &#34;unit&#34; I mean not necessarily just a class, but a behavior. If you want, see more details in  the coupling chapter of my previous post.</p><p>测试：自动化单元测试。我所说的单元不一定只是一个类，而是一种行为。如果您愿意，请在我上一篇文章的耦合一章中查看更多详细信息。</p><p>  import  requests  # Listing 1 from  urllib  import  urlencode def  find_definition ( word ):  q  =  &#39;define &#39;  +  word  url  =  &#39;http://api.duckduckgo.com/?&#39;  url  +=  urlencode ({ &#39;q&#39; :  q ,  &#39;format&#39; :  &#39;json&#39; })  response  =  requests . get ( url )  # I/O  data  =  response . json ()  # I/O  definition  =  data [ u &#39;Definition&#39; ]  if  definition  ==  u &#39;&#39; :  raise  ValueError ( &#39;that is not a word&#39; )  return  definition</p><p>Import request#list1 from urllib import urlencode def Find_Definition(Word)：q=&#39；定义&#39；+word url=&#39；http://api.duckduckgo.com/？&#39；url+=urlencode({&#39；q&#39；：q，#39；format&#39；：&#39；json&#39；})Response=Requests。Get(Url)#I/O数据=响应。Json()#I/O定义=数据[u&#39；定义&#39；]如果定义==u&#39；&#39；：提高ValueError(&#39；这不是一个单词&#39；)返回定义。</p><p> Here, we have a piece of code that prepares a URL, then gets some data over the network (I/O), then validates the result (a word definition) and returns it.</p><p>在这里，我们有一段代码，它准备一个URL，然后通过网络获取一些数据(I/O)，然后验证结果(单词定义)并返回它。</p><p> This is a bit much: a procedure should ideally do one thing only. While this small-ish procedure is quite readable still, it is a metaphor for a more developed system - where it could be arbitrarily long.</p><p>这有点过头了：理想情况下，一个过程应该只做一件事。虽然这个小的过程仍然具有相当的可读性，但它是对一个更发达的系统的隐喻-在那里它可能是任意长的。</p><p> The current knee-jerk reaction is to  hide the I/O operations somewhere far away. Here is the same code after extracting the I/O lines:</p><p>当前的下意识反应是将I/O操作隐藏在遥远的地方。以下是提取I/O行后的相同代码：</p><p>  def  find_definition ( word ):  # Listing 2  q  =  &#39;define &#39;  +  word  url  =  &#39;http://api.duckduckgo.com/?&#39;  url  +=  urlencode ({ &#39;q&#39; :  q ,  &#39;format&#39; :  &#39;json&#39; })  data  =  call_json_api ( url )  definition  =  data [ u &#39;Definition&#39; ]  if  definition  ==  u &#39;&#39; :  raise  ValueError ( &#39;that is not a word&#39; )  return  definition def  call_json_api ( url ):  response  =  requests . get ( url )  # I/O  data  =  response . json ()  # I/O  return  data</p><p>Def Find_Definition(Word)：#清单2q=&#39；定义&#39；+word url=&#39；http://api.duckduckgo.com/？&#39；url+=urlencode({&#39；q&#39；：q，&#39；格式&#39；：&#39；json&#39；})data=call_json_api(Url)定义=数据[u&#39；定义&#39；]如果定义==u&#39；&#39；：raise ValueError(&#39；这不是一个单词&#39；)返回定义def call_json_api(Url)：Response=Requests。Get(Url)#I/O数据=响应。Json()#I/O返回数据。</p><p>  The problem is, the code is still  coupled -  call_json_api is called whenever you want to test anything - even the building of the URL or the parsing of the result.</p><p>问题是，代码仍然是耦合的-只要您想测试任何东西-即使是URL的构建或结果的解析，都会调用call_json_api。</p><p>  A good rule of thumb to spot coupling is this: Can you test a piece of code without having to mock or dependency inject like Frankenstein?</p><p>发现耦合的一个很好的经验法则是：您可以在不像Frankenstein那样模拟或注入依赖项的情况下测试一段代码吗？</p><p> Here, we can&#39;t test  find_definition without somehow replacing  call_json_api from inside it, in order to avoid making HTTP requests.</p><p>在这里，我们可以在不从内部替换call_json_API的情况下测试find_Definition，以避免发出HTTP请求。</p><p>   def  find_definition ( word ):  # Listing 3  url  =  build_url ( word )  data  =  requests . get ( url ) . json ()  # I/O  return  pluck_definition ( data ) def  build_url ( word ):  q  =  &#39;define &#39;  +  word  url  =  &#39;http://api.duckduckgo.com/?&#39;  url  +=  urlencode ({ &#39;q&#39; :  q ,  &#39;format&#39; :  &#39;json&#39; })  return  url def  pluck_definition ( data ):  definition  =  data [ u &#39;Definition&#39; ]  if  definition  ==  u &#39;&#39; :  raise  ValueError ( &#39;that is not a word&#39; )  return  definition</p><p>Def find_Definition(Word)：#list3url=build_url(Word)data=requests。获取(Url)。Json()#I/O return Pluuck_Definition(Data)def build_url(Word)：q=&#39；定义&#39；+word url=&#39；http://api.duckduckgo.com/？&#39；url+=urlencode({&#39；q&#39；：q，&#39；Format&#39；：&#39；json&#39；})返回url def Pluuck_Definition(Data)：Definition=Data[u&#39；定义&#39；]如果定义==u&#39；&#39；：提高值错误(&#39；那不是一个单词&#39；)返回定义。</p><p> Here, the procedure at the top (aka. the   imperative shell of the program) is handling the I/O, and everything else is moved to   pure functions ( build_url,  pluck_definition). The   pure functions are easily testable by just calling them on made-up data structures; no Frankenstein needed.</p><p>这里，顶部的程序(又名。程序的命令性shell)正在处理I/O，其他所有内容都移到纯函数(build_url、pluck_ition)。只需在合成的数据结构上调用纯函数，就可以很容易地测试它们；不需要科学怪人。</p><p> This separation into an   imperative shell and   functional core is an encouraged idea by Functional Programming.</p><p>这种分离为命令性外壳和功能核心是函数式编程鼓励的想法。</p><p> Ideally, though, in a real system, you wouldn&#39;t test elements as small as these routines, but integrate more of the system. See  the coupling chapter of my previous post to understand the trade-offs.</p><p>不过，理想情况下，在真实的系统中，您不会测试像这些例程这样小的元素，而是集成更多的系统。请参阅我上一篇文章的耦合章节，以了解其中的权衡。</p><p>  Look at  Uncle Bob&#39;s Clean Architecture chart (Copyright Robert C. Martin aka. Uncle Bob) :</p><p>看看鲍勃叔叔的清洁建筑图表(版权所有罗伯特·C·马丁，又名。鲍勃叔叔)：</p><p> Uncle Bob&#39;s   Use Cases and   Entities (red and yellow circles of the chart) map to the   pure functions we saw earlier -  build_url and  pluck_definition from Listing 3.</p><p>Bob叔叔的用例和实体(图表的红色和黄色圆圈)映射到我们前面看到的纯函数--清单3中的build_url和pluck_ition。</p><p> Uncle Bob&#39;s   Interface Adapters (green circle) map to the top-level   imperative shell from earlier -  find_definition from Listing 3, handling only I/O to the outside (Web, DB, UI, other frameworks).</p><p>Bob&#39；叔叔的接口适配器(绿色圆圈)映射到清单3中前面的-find_Definition中的顶级命令性shell，只处理到外部(Web、DB、UI和其他框架)的I/O。</p><p> Notice the arrows on the left side of the circles, pointing inwards to more and more abstract parts. These are procedure or function calls. Our code is called by the outside.</p><p>请注意圆圈左侧的箭头，它们向内指向越来越多的抽象部分。这些是过程或函数调用。我们的代码是由外部调用的。</p><p>   This lets us easily test the functional core. Ideally, most of a production system should be pure-functional.</p><p>这使我们可以轻松地测试功能核心。理想情况下，生产系统的大部分应该是纯功能的。</p><p>  If you reduce the   imperative shell and move code into the   functional core, each test can verify almost the entire (now-functional) stack, but stopping short of actually performing external actions.</p><p>如果减少命令性shell并将代码移到功能核心中，则每个测试都可以验证几乎整个(现在可以正常工作的)堆栈，但不能实际执行外部操作。</p><p> You can then test the imperative shell using  fewer integration tests: you only need to check that it is  correctly connected to the functional core.</p><p>然后，您可以使用较少的集成测试来测试命令性shell：您只需要检查它是否正确连接到功能核心。</p><p> Having two users for the system - the real user and the unit tests - and listening to both, lets you guide your architecture so as to  minimize coupling and build a more  flexible system.</p><p>让系统有两个用户-真正的用户和单元测试-并听取这两个用户的意见，可以让您指导您的体系结构，从而最大限度地减少耦合，并构建更灵活的系统。</p><p> Having a flexible system lets you implement new features and change existing ones  quickly and cheaply, in order to  stay competitive as a business.</p><p>拥有灵活的系统可以让您快速且廉价地实施新功能和更改现有功能，以保持企业竞争力。</p><p> Comments are much appreciated. I am yet to apply these insights, and I may be missing something!</p><p>我们非常感谢您的意见。我还没有应用这些洞察力，我可能遗漏了一些东西！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danuker.go.ro/the-grand-unified-theory-of-software-architecture.html">https://danuker.go.ro/the-grand-unified-theory-of-software-architecture.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/统一/">#统一</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/unified/">#unified</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/url/">#url</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031642.html"><img src="http://img2.diglog.com/img/2020/10/thumb_10c2eb52ef6dd8706b0bb5c9498d7a93.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031642.html">我们永远不会有足够的软件开发人员</a></div><span class="my_story_list_date">2020-10-28 6:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031598.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ca53241672ace6561f8ad80dc615dfd3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031598.html">特斯拉突破：全速行驶</a></div><span class="my_story_list_date">2020-10-28 4:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031521.html"><img src="http://img2.diglog.com/img/2020/10/thumb_01c477e43ff90f2fe57ab1da9d6df48f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031521.html">
洛杉矶在筹集2500万美元后，希望增加运营管理软件的研发和招聘</a></div><span class="my_story_list_date">2020-10-28 0:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031311.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ca21841d42e8781869636fa985a428f8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031311.html">交付高质量软件的心智模型</a></div><span class="my_story_list_date">2020-10-27 2:42</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>