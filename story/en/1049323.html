<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>常见的Nginx错误配置使您的Web服务器容易受到攻击 Common Nginx misconfigurations that leave your web server open to attack</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Common Nginx misconfigurations that leave your web server open to attack<br/>常见的Nginx错误配置使您的Web服务器容易受到攻击 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 15:35:56</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/7861fb9f365b3c986c52e9288280e5af.png"><img src="http://img2.diglog.com/img/2021/2/7861fb9f365b3c986c52e9288280e5af.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Nginx is the web server powering one-third of all websites in the world.  Detectify Crowdsource has detected some common Nginx misconfigurations that, if left unchecked, leave your web site vulnerable to attack. Here’s how to find some of the most common misconfigurations before an attacker exploits them.</p><p>Nginx是支持世界上所有网站三分之一的Web服务器。 Detectify Crowdsource已检测到一些常见的Nginx错误配置，如果不进行检查，将使您的网站容易受到攻击。以下是在攻击者利用它们之前发现一些最常见的错误配置的方法。</p><p>  Nginx is one of the  most commonly used web servers on the Internet due to it being lightweight, modular, and having a user-friendly configuration format. At  Detectify, we scan for misconfigurations and security vulnerabilities in Nginx for thousands of customers. Our Crowdsource network regularly submits new and interesting vulnerabilities affecting Nginx that we then later implement as a security test into our web application scanner.</p><p>  Nginx是Internet上最常用的Web服务器之一，因为它轻巧，模块化并且具有用户友好的配置格式。在Detectify，我们为成千上万的客户扫描Nginx中的配置错误和安全漏洞。我们的Crowdsource网络会定期提交影响Nginx的新的有趣漏洞，然后将其作为安全性测试实施到我们的Web应用程序扫描程序中。</p><p> We analyzed almost 50,000 unique Nginx configuration files downloaded from GitHub with Google BigQuery. With this data, we could find out how common different misconfigurations are.</p><p> 我们使用Google BigQuery分析了从GitHub下载的近50,000个唯一的Nginx配置文件。有了这些数据，我们可以发现不同配置错误的普遍程度。</p><p>    server {         root /etc/nginx;        location /hello.txt {                try_files $uri $uri/ =404;                proxy_pass http://127.0.0.1:8080/;        }}</p><p>    服务器 { 根/ etc / nginx; 位置/hello.txt { try_files $ uri $ uri / = 404; proxy_pass http://127.0.0.1:8080/; }}</p><p> The  root  directive specifies the root folder for Nginx. In the above example, the root folder is  /etc/nginx which means that we can reach files within that folder. The above configuration does not have a location for  / (location / {...}), only for  /hello.txt. Because of this, the  root directive will be globally set, meaning that requests to  / will take you to the local path  /etc/nginx.</p><p> root指令指定Nginx的根文件夹。在上面的示例中，根文件夹是/ etc / nginx，这意味着我们可以访问该文件夹中的文件。上面的配置没有/的位置（location / {...}），只有/hello.txt的位置。因此，将对root指令进行全局设置，这意味着对/的请求会将您带到本地路径/ etc / nginx。</p><p> A request as simple as  GET /nginx.conf would reveal the contents of the Nginx configuration file stored in  /etc/nginx/nginx.conf. If the root is set to  /etc, a  GET request to  /nginx/nginx.conf would reveal the configuration file. In some cases it is possible to reach other configuration files, access-logs and even encrypted credentials for HTTP basic authentication.  Of the nearly 50,000 Nginx configuration files we collected, the most common root paths were the following:</p><p> 像GET /nginx.conf这样简单的请求将显示存储在/etc/nginx/nginx.conf中的Nginx配置文件的内容。如果将根设置为/ etc，则对/nginx/nginx.conf的GET请求将显示配置文件。在某些情况下，可以访问其他配置文件，访问日志，甚至可以进行HTTP基本身份验证的加密凭据。在我们收集的近50,000个Nginx配置文件中，最常见的根路径如下：</p><p>   server {        listen 80 default_server;        server_name _;        location /static {                alias /usr/share/nginx/static/;        }        location /api { proxy_pass http://apiserver/v1/;        }}</p><p>   服务器 { 监听80 default_server;服务器名称 _;位置/ static { 别名/ usr / share / nginx / static /; }位置/ api { proxy_pass http：// apiserver / v1 /; }} </p><p> With the Off-by-slash misconfiguration, it is possible to traverse one step up the path due to a missing slash. Orange Tsai made this technique well known in his Blackhat talk  “Breaking Parser Logic!”  In this talk he showed how a missing trailing slash in the  location directive combined with the  alias directive can make it possible to read the source code of the web application. What is less well known is that this also works with other directives like  proxy_pass. Let’s break down what is happening and why this works.</p><p>借助斜杠偏移配置错误，由于缺少斜杠，因此有可能沿路径上移一步。 Orange Tsai在Blackhat的演讲“ Breaking Parser Logic！”中使这项技术广为人知。在本次演讲中，他展示了location指令与alias指令结合使用的缺失斜杠如何使读取Web应用程序的源代码成为可能。鲜为人知的是，它还可以与其他指令（例如proxy_pass）一起使用。让我们来分解一下正在发生的事情以及它为什么起作用。</p><p>  With an Nginx server running the following configuration that is reachable at  server, it might be assumed that only paths under  http://apiserver/v1/ can be accessed.</p><p>  如果Nginx服务器运行服务器可以访问的以下配置，则可以假定只能访问http：// apiserver / v1 /下的路径。</p><p>  When  http://server/api/user is requested, Nginx will first normalize the URL. It then looks to see if the prefix  /api matches the URL, which it does in this case. The prefix is then removed from the URL so the path  /user is left. This path is then added to the  proxy_pass URL which results in the final URL  http://apiserver/v1//user. Note that there is a double slash in the URL since the location directive does not end in a slash and the  proxy_pass URL path ends with a slash. Most web servers will normalize  http://apiserver/v1//user to  http://apiserver/v1/user, which means that even with this misconfiguration everything will work as expected and it could go unnoticed.</p><p>  当请求http：// server / api / user时，Nginx将首先规范化URL。然后，它查看前缀/ api是否与URL匹配，在这种情况下，URL会匹配。然后，从URL中删除该前缀，以便保留路径/ user。然后将此路径添加到proxy_pass URL中，从而得到最终URL http：// apiserver / v1 // user。请注意，URL中存在双斜杠，因为location指令不以斜杠结尾，并且proxy_pass URL路径以斜杠结尾。大多数Web服务器会将http：// apiserver / v1 // user标准化为http：// apiserver / v1 / user，这意味着即使配置错误，所有内容仍将按预期运行，并且可能不会引起注意。</p><p> This misconfiguration can be exploited by requesting  http://server/api../ which will result in Nginx requesting the URL  http://apiserver/v1/../ that is normalized to  http://apiserver/. The impact that this can have depends on what can be reached when this misconfiguration is exploited. It could for example lead to the Apache server-status being exposed with the URL  http://server/api../server-status, or it could make paths accessible that were not intended to be publicly accessible.</p><p> 通过请求http：//server/api../可以利用这种错误配置，这将导致Nginx请求标准化为http：// apiserver /的URL http：//apiserver/v1/../。这可能产生的影响取决于利用这种错误配置可以达到的效果。例如，这可能导致Apache服务器状态通过URL http：//server/api../server-status公开，或者可以使那些不打算公开访问的路径可访问。</p><p> One sign that a Nginx server has this misconfiguration is the server still returns the same response when a slash in the URL is removed. For example, if both  http://server/api/user and  http://server/apiuser return the same response, the server might be vulnerable. This would lead to the following requests being sent:</p><p> Nginx服务器配置错误的一个迹象是，当URL中的斜杠被删除时，服务器仍然返回相同的响应。例如，如果http：// server / api / user和http：// server / apiuser返回相同的响应，则服务器可能容易受到攻击。这将导致发送以下请求：</p><p>   Some frameworks, scripts and Nginx configurations unsafely use the variables stored by Nginx. This can lead to issues such as XSS, bypassing HttpOnly-protection, information disclosure and in some cases even RCE.</p><p>   一些框架，脚本和Nginx配置不安全地使用Nginx存储的变量。这可能会导致诸如XSS，绕过HttpOnly保护，信息泄露甚至在某些情况下甚至是RCE之类的问题。</p><p>    The main issue will be that Nginx will send any URL to the PHP interpreter ending in  .php even if the file doesn’t exist on disc. This is a common mistake in many Nginx configurations, as outlined in the “  Pitfalls and Common Mistakes ” document created by Nginx.</p><p>    主要问题是Nginx会将所有URL发送到以.php结尾的PHP解释器，即使该文件在光盘上不存在。正如Nginx创建的“陷阱和常见错误”文档中概述的那样，这是许多Nginx配置中的常见错误。 </p><p> An XSS will occur if the PHP-script tries to define a base URL based on  SCRIPT_NAME;</p><p>如果PHP脚本试图基于SCRIPT_NAME定义基本URL，则将发生XSS。</p><p>   Another misconfiguration related to Nginx variables is to use  $uri or  $document_uri instead of  $request_uri.  $uri and  $document_uri contain the normalized URI whereas the  normalization in Nginx includes URL decoding the URI.   Volema found that  $uri is commonly used when creating redirects in the Nginx configuration which results in a CRLF injection.</p><p>   与Nginx变量有关的另一个错误配置是使用$ uri或$ document_uri而不是$ request_uri。 $ uri和$ document_uri包含规范化的URI，而Nginx中的规范化包括URL解码URI。 Volema发现，在Nginx配置中创建重定向会导致CRLF注入时，通常使用$ uri。</p><p>   The new line characters for HTTP requests are \r (Carriage Return) and \n (Line Feed). URL-encoding the new line characters results in the following representation of the characters  %0d%0a. When these characters are included in a request like  http://localhost/%0d%0aDetectify:%20clrf to a server with the misconfiguration, the server will respond with a new header named  Detectify since the $uri variable contains the URL-decoded new line characters.</p><p>   HTTP请求的新行字符为\ r（回车）和\ n（换行）。对新行字符进行URL编码将导致以下字符％0d％0a的表示形式。如果将这些字符包含在对服务器的配置错误的请求（例如http：// localhost /％0d％0aDetectify：％20clrf）中，由于$ uri变量包含URL解码的new行字符。</p><p> HTTP/1.1 302 Moved TemporarilyServer: nginx/1.19.3Content-Type: text/htmlContent-Length: 145Connection: keep-aliveLocation: https://example.com/ Detectify: clrf</p><p> HTTP / 1.1 302临时移动伺服器：nginx / 1.19.3内容类型：text / html内容长度：145连接：保持活动状态位置：https：//example.com/ 检测：clrf</p><p>   In some cases, user-supplied data can be treated as an Nginx variable. It’s unclear why this may be happening, but it’s not that uncommon or easy to test for as seen in this   H1 report. If we search for the error message, we can see that it is found in the   SSI filter module, thus revealing that this is due to SSI.</p><p>   在某些情况下，用户提供的数据可以视为Nginx变量。目前尚不清楚为什么会发生这种情况，但是如本H1报告所示，这种情况并不罕见或不容易测试。如果搜索错误消息，我们可以看到它是在SSI过滤器模块中找到的，从而表明这是由于SSI引起的。</p><p>   We scanned for this misconfiguration and found several instances where a user could print the value of Nginx variables. The number of found vulnerable instances has declined which could indicate that this was patched.</p><p>   我们扫描了这种错误配置，发现了几个实例，用户可以在其中打印Nginx变量的值。发现的易受攻击实例的数量有所下降，这可能表明已对其进行了修补。</p><p>  With Nginx’s  proxy_pass, there’s the possibility to intercept errors and HTTP headers created by the backend. This is very useful if you want to hide internal error messages and headers so they are instead handled by Nginx. Nginx will automatically serve a custom error page if the backend answers with one. But what if Nginx does not understand that it’s an HTTP response?</p><p>  使用Nginx的proxy_pass，可以拦截后端创建的错误和HTTP标头。如果要隐藏内部错误消息和标头，以便由Nginx处理，则这非常有用。如果后端回答一个，Nginx将自动提供自定义错误页面。但是，如果Nginx不理解这是HTTP响应怎么办？ </p><p> If a client sends an invalid HTTP request to Nginx, that request will be forwarded as-is to the backend, and the backend will answer with its raw content. Then, Nginx won’t understand the invalid HTTP response and just forward it to the client. Imagine a uWSGI application like this:</p><p>如果客户端向Nginx发送了无效的HTTP请求，则该请求将按原样转发到后端，后端将使用其原始内容进行应答。然后，Nginx将无法理解无效的HTTP响应，而会将其转发给客户端。想象这样的uWSGI应用程序：</p><p>    proxy_intercept_errors  will serve a custom response if the backend has a response status greater than 300. In our uWSGI application above, we will send a  500 Error which would be intercepted by Nginx.</p><p>    如果后端的响应状态大于300，proxy_intercept_errors将提供自定义响应。在上面的uWSGI应用程序中，我们将发送500错误，Nginx将拦截该错误。</p><p> proxy_hide_header is pretty much self explanatory; it will hide any specified HTTP header from the client.</p><p> proxy_hide_header几乎可以自我解释；它将从客户端隐藏任何指定的HTTP标头。</p><p>        The   merge_slashes  directive is set to “on” by default which is a mechanism to compress two or more forward slashes into one, so  /// would become  /. If Nginx is used as a reverse-proxy and the application that’s being proxied is vulnerable to local file inclusion, using extra slashes in the request could leave room for exploit it. This is described in detail by  Danny Robinson and Rotem Bar.</p><p>        默认情况下，merge_slashes指令设置为“ on”，这是一种将两个或多个正斜杠压缩为一个的机制，因此///将变为/。如果Nginx用作反向代理，并且被代理的应用程序容易受到本地文件包含的影响，则在请求中使用多余的斜杠可能会留出利用空间。 Danny Robinson和Rotem Bar对此进行了详细描述。</p><p>   We have created a GitHub repository where you can use Docker to set up your own vulnerable Nginx test server with some of the misconfigurations discussed in this article and try finding them yourself!</p><p>   我们已经创建了一个GitHub存储库，您可以在其中使用Docker来设置您自己的易受攻击的Nginx测试服务器，以及本文中讨论的一些错误配置，然后尝试自己找到它们！</p><p>   Nginx is a very powerful web server platform and it is easy to understand why it is widely used. But with flexible configuration, you enable the ability to make mistakes that may have a security impact. Don’t make it too easy for an attacker to hack your site by leaving these common misconfigurations unchecked. Detectify can detect all of these misconfigurations and help you secure your site from would-be attackers if you don’t have time to manually check yourself.  Sign up for a free 2-week trial today to get started!</p><p>   Nginx是一个非常强大的Web服务器平台，很容易理解为什么它被广泛使用。但是，通过灵活的配置，您可以犯错误，从而可能会对安全产生影响。请勿勾选这些常见的错误配置，以免让攻击者轻易地入侵您的网站。 Detectify可以检测所有这些错误配置，如果您没有时间手动检查自己，则可以帮助您保护网站免受潜在攻击者的侵害。立即注册免费的2周试用版，开始使用！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/">https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nginx/">#nginx</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>