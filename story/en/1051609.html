<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SQLite R *树模块 The SQLite R*Tree Module</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The SQLite R*Tree Module<br/>SQLite R *树模块 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 06:11:58</div><div class="page_narrow text-break page_content"><p>An  R-Tree is a specialindex that is designed for doing range queries. R-Trees are most commonlyused in geospatial systems where each entry is a rectangle with minimum andmaximum X and Y coordinates. Given a query rectangle, an R-Tree is ableto quickly find all entries that are contained within the query rectangleor which overlap the query rectangle. This idea is easily extended tothree dimensions for use in CAD systems. R-Trees also find use in time-domainrange look-ups. For example, suppose a database records the starting andending times for a large number of events. A R-Tree is able to quicklyfind all events that were active at any time during a giventime interval, or all events that started during a particular time interval,or all events that both started and ended within a given time interval.And so forth.</p><p>R树是一个专业的专用，用于执行范围查询。 R树最常见于地理空间系统中，其中每个条目是具有最小和最大X和Y坐标的矩形。鉴于查询矩形，R树是Ableto快速查找包含在查询矩形中包含的所有条目，该条目与查询矩形重叠。此思想很容易扩展Tothree尺寸以用于CAD系统。 R-Trous还可以在时间 -  domainrange查找中找到使用。例如，假设数据库记录大量事件的启动安宁时间。 R树能够在Giventime间隔期间的任何时间都能快速查询，或者在特定时间间隔期间启动的所有事件，或者在给定的时间间隔内启动和结束的所有事件。等等。</p><p> The R-Tree concept originated with  Toni Guttman:  R-Trees: A Dynamic Index Structure for Spatial Searching,Proc. 1984 ACM SIGMOD International Conference on Management of Data,pp. 47-57.The implementation found in SQLite is a refinement of Guttman&#39;s originalidea, commonly called &#34;R*Trees&#34;, that was described byNorbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: The R*-Tree: An Efficient and Robust Access Method for Pointsand Rectangles. SIGMOD Conference 1990: 322-331.</p><p> R树概念起源于Toni Guttman：R树：用于空间搜索的动态索引结构，proc。 1984年ACM SIGMOD关于数据管理国际会议，PP。 47-57。SQLITE中发现的实施是Guttman＆＃39; S ImericiDea的改进，通常称为＆＃34; r *树和＃34;那个描述了Bynorbert Beckmann，Hans-Peter Kriegel，Ralf Schneider，Bernhard Seeger： R * -tree：一个有效且强大的矩形的访问方法。 Sigmod大会1990：322-331。</p><p>  The source code to the SQLite R*Tree module is included as partof the  amalgamation but is disabled by default. To enable theR*Tree module, simply compile with the  SQLITE_ENABLE_RTREE C-preprocessor macro defined. With many compilers, this is accomplishedby adding the option &#34;-DSQLITE_ENABLE_RTREE=1&#34; to the compilercommand-line.</p><p>  将SQLite R *树模块的源代码包含在默认情况下作为禁用但禁用。要启用*树模块，只需使用SQLite_Enable_Rtree C-Preprocessor宏定义的编译。通过许多编译器，可以添加选项＆＃34; -dsqlite_enable_rtree = 1＆＃34;到了编译器中线。</p><p>  The SQLite R*Tree module is implemented as a virtual table. Each R*Tree index is avirtual table with an odd number of columns between 3 and 11.The first column is always a 64-bit signed integer primary key.The other columns are pairs, one pair per dimension, containing theminimum and maximum values for that dimension, respectively.A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns.A 3-dimensional R*Tree has 7 columns.A 4-dimensional R*Tree has 9 columns.And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementationdoes not support R*Trees wider than 5 dimensions.</p><p>  SQLite R * Tree模块以虚拟表实现。每个R *树索引是具有奇数列之间的虚拟表，3到11之间。第一列始终为64位符号整数主键。其他列是对，每维一对，包含最大值和最大值该维度分别为1维r *树有3列。二维r *树有5列。3维r *树有7列。4维r *树有9列。5维r *树有11列。 SQLite R *树实施不支持宽于5维度的R *树。</p><p> The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signedinteger value. Inserting a NULL value into this column causes SQLiteto automatically generate a new unique primary key value. If an attemptis made to insert any other non-integer value into this column,the r-tree module silently converts it to an integer before writing itinto the database.</p><p> SQLite R *树的第一列类似于正常SQLite表的整数主键列。它可能只存储64位签名的值。将空值插入此列导致SQLITETO自动生成一个新的唯一主键值。如果尝试将任何其他非整数值插入此列，则R树模块在编写ITINTO数据库之前静默将其转换为整数。</p><p> The min/max-value pair columns are stored as 32-bit floating point values for&#34;rtree&#34; virtual tables or as 32-bit signed integers in &#34;rtree_i32&#34; virtualtables. Unlike regular SQLite tables which can store data in a variety ofdatatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-treemodule silently converts it to the required type before writing thenew record to the database.</p><p> min / max-value对列作为＆＃34的32位浮点值存储为＆＃34; rtree＆＃34;虚拟表或＆＃34中的32位符号整数; rtree_i32＆＃34;虚拟Tables。与可以在各种odataTypes和格式存储数据的常规SQLite表不同，R *树刚刚强制执行这些存储类型。如果将任何其他类型的值插入这样的列中，则R-Traemodule在将那录制到数据库中的记录写入然后写入数据库之前静默将其转换为所需类型。</p><p>    The  &lt;name&gt; is the name your application chooses for theR*Tree index and  &lt;column-names&gt; is a comma separated listof between 3 and 11 columns.The virtual &lt;name&gt; table creates three  shadow tables to actuallystore its content. The names of these shadow tables are:</p><p>    ＆lt;名称＆gt;您的应用程序是否选择了*树索引和＆lt;列名称＆gt;是3到11列之间的逗号分隔列表。虚拟＆lt; name＆gt;表创建了三个阴影表以实际才能实现其内容。这些影子表的名称是： </p><p>  The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularlyuseful. And you can  UPDATE,  DELETE,  INSERT or even  DROP the shadow tables, though doing so will corrupt your R*Tree index.So it is best to simply ignore the shadow tables. Recognize that theyhold your R*Tree index information and let it go as that.</p><p>影子表是普通的SQLite数据表。如果您愿意，您可以直接查询它们，虽然这不太可能揭示任何更有的东西。并且您可以更新，删除，插入甚至丢弃影子表，但这样做会损坏您的r *树index.so，最好只忽略影子表。认识到他们的r *树索引信息，并让它如此。</p><p>  CREATE VIRTUAL TABLE demo_index USING rtree( id, -- Integer primary key minX, maxX, -- Minimum and maximum X coordinate minY, maxY -- Minimum and maximum Y coordinate);</p><p>  使用Rtree（ID， - 整数主键MINX，MAXX，MAXX，最大x坐标MINY，MAXY  - 最小和最大坐标）创建虚拟表DEMO_INDEX;</p><p>  In the argments to &#34;rtree&#34; in the CREATE VIRTUAL TABLE statement, thenames of the columns are taken from the first token of each argument.All subsequent tokens within each argument are silently ignored.This means, for example, that if you try to give a column a type affinity or add a constraint such as UNIQUE or NOT NULL or DEFAULT toa column, those extra tokens are accepted as valid, but they do not changethe behavior of the rtree.In an RTREE virtual table, the first column always has a type affinity of INTEGER and all other data columns have a type affinity of NUMERIC.</p><p>  在＆＃34; rtree＆＃34;在“创建虚拟表”语句中，列的Amess从每个参数的第一个令牌中获取。静默地忽略每个参数中的后续令牌。例如，如果您尝试提供列的类型关联或添加诸如唯一或非null或默认toa列的约束，那些额外的令牌被接受为有效，但它们不会改变rtree的行为。在rtree虚拟表中，第一列始终具有整数的类型和所有其他类型数据列具有数字的类型亲和力。</p><p> Recommended practice is to omit any extra tokens in the rtree specification.Let each argument to &#34;rtree&#34; be a single ordinary label that is the name ofthe corresponding column, and omit all other tokens from the argument list.</p><p> 推荐的做法是省略rtree规范中的任何额外令牌。将每个参数到＆＃34; rtree＆＃34;是一个单个普通标签，即相应列的名称，并省略参数列表中的所有其他令牌。</p><p>  The usual  INSERT,  UPDATE, and  DELETE commands work on an R*Treeindex just like on regular tables. So to insert some data into our sampleR*Tree index, we can do something like this:</p><p>  通常的插入，更新和删除命令在r * treeindex上工作，就像在常规表上一样。因此要将一些数据插入我们的采样器*树索引，我们可以做到这样的事情：</p><p> INSERT INTO demo_index VALUES( 1, -- Primary key -- SQLite.org headquarters -80.7749, -80.7747, -- Longitude range 35.3776, 35.3778 -- Latitude range);INSERT INTO demo_index VALUES( 2, -- NC 12th Congressional District in 2010 -81.0, -79.6, 35.0, 36.2);</p><p> 插入demo_index值（1， - 主键 -  Sqlite.org总部-80.7749，-80.7747， - 经度范围35.3776,35.3778  - 纬度范围）;插入Demo_Index值（2， -  NC第12届国会区2010 -81.0，-79.6,35.0,36.2）;</p><p> The entries above might represent (for example) a bounding box aroundthe main office for SQLite.org and bounding box around the12th Congressional District of North Carolina (prior to the 2011redistricting) in which SQLite.org was located.</p><p> 上面的条目可能代表（例如）围绕SQLite.org的主办公室的边界框和北卡罗来纳州北卡罗来纳州第12届北卡罗来纳州（2011年之前）的边界框中，其中Sqlite.org位于其中。 </p><p>  Any valid query will work against an R*Tree index. But the R*Treeimplementation is designed to make two kinds of queries especiallyefficient. First, queries against the primary key are efficient:</p><p>任何有效的查询都将针对R *树索引工作。但是R * TreeMoMentation旨在使两种询问尤其良好。首先，针对主键的查询是有效的：</p><p>  Of course, an ordinary SQLite table will also do a query against itsinteger primary key efficiently, so the previous is no big deal.The real reason for using an R*Tree is so thatyou can efficiently do inequality queries against the coordinateranges. To find all elements of the index that are contained withinthe vicinity of Charlotte, North Carolina, one might do:</p><p>  当然，普通的SQLite表也将有效地针对ITSInteger主键进行查询，因此前面没有大不了的问题。使用R *树的真正原因是因为您可以有效地对协调角度有效查询。要查找北卡罗来纳州夏洛特附近所包含的索引的所有元素可能会做：</p><p>  The query above would very quickly locate the id of 1 even if theR*Tree contained millions of entries. The previous is an exampleof a &#34;contained-within&#34; query. The R*Tree also supports &#34;overlapping&#34;queries. For example, to find all bounding boxes that overlap theCharlotte area:</p><p>  即使*树包含数百万条目，上面的查询也非常快速地定位1的ID。以前是A＆＃34的一个例子;包含在内的＆＃34;询问。 R *树也支持＆＃34;重叠＆＃34;查询。例如，要查找重叠的所有边界框，其中</p><p>  This second query would find both entry 1 (the SQLite.org office) whichis entirely contained within the query box and alsothe 12th Congressional District which extends well outside thequery box but still overlaps the query box.</p><p>  该第二查询将找到输入1（SQLite.org Office）的内容，其中包含在查询框和Alsothe第12个国会区内延伸，但仍然与查询框重叠。</p><p> Note that it is not necessary for all coordinates in an R*Tree indexto be constrained in order for the index search to be efficient.One might, for example, want to query all objects that overlap withthe 35th parallel:</p><p> 请注意，R *树Indexto中的所有坐标都不需要约束，以便为索引搜索是高效的。</p><p>  But, generally speaking, the more constraints that the R*Tree modulehas to work with, and the smaller the bounding box, the faster theresults will come back.</p><p>  但是，一般来说，R *树模块以及边界框越小的约束，越突出的结果将越快。</p><p>  By default, coordinates are stored in an R*Tree using 32-bit floatingpoint values. When a coordinate cannot be exactly represented by a32-bit floating point number, the lower-bound coordinates are rounded downand the upper-bound coordinates are rounded up. Thus, bounding boxes mightbe slightly larger than specified, but will never be any smaller. Thisis exactly what is desired for doing the more common &#34;overlapping&#34; querieswhere the application wants to find every entry in the R*Tree that overlapsa query bounding box. Rounding the entry bounding boxes outward might cause afew extra entries to appears in an overlapping query if the edge of theentry bounding box corresponds to an edge of the query bounding box. Butthe overlapping query will never miss a valid table entry.</p><p>  默认情况下，坐标使用32位浮点值存储在R *树中。当坐标由A32位浮点数完全表示时，较大的坐标是圆形的，上限坐标圆形。因此，边界框可能略大于指定，但永远不会更小。这恰恰是做出更常见的＆＃34所需的内容;重叠＆＃34;查询应用程序希望在RableA查询边界框中找到R *树中的每个条目。如果前门边界框的边缘对应于查询边界框的边缘，则舍入向外若要导致Avew额外条目出现在重叠查询中。但重叠查询永远不会错过有效的表格条目。 </p><p> However, for a &#34;contained-within&#34; style query, rounding the boundingboxes outward might cause some entries to be excluded from the result setif the edge of the entry bounding box corresponds to the edge of the querybounding box. To guard against this, applications should expand theircontained-within query boxes slightly (by 0.000012%) by rounding down thelower coordinates and rounding up the top coordinates, in each dimension.</p><p>但是，对于A＆＃34;包含 - 内部＆＃34;样式查询，向外舍入边界框可能会导致从结果模板中排除的一些条目，条目边界框的边缘对应于查询框的边缘。为了防范此，应用应该在每个维度中舍入到距离坐标并舍入顶部坐标，稍微略微扩展到查询框中（0.000012％）。</p><p>  It is the nature of the Guttman R-Tree algorithm that any write mightradically restructure the tree, and in the process change the scan orderof the nodes. For this reason, it is not generally possible to modifythe R-Tree in the middle of a query of the R-Tree. Attempts to do sowill fail with a  SQLITE_LOCKED &#34;database table is locked&#34; error.</p><p>  它是Guttman R-Tree算法的性质，任何写入Mightrady地重构树，并且在过程中更改节点的扫描顺序。因此，通常不可能在R树的查询中间修改R树。尝试使用sqlite_locked＆＃34进行播出失败;数据库表被锁定＆＃34;错误。</p><p>   Then for each &#34;id&#34; value returned, suppose the application creates an UPDATE statement like the following and binds the &#34;id&#34; value returned againstthe &#34;?1&#34; parameter:</p><p>   然后为每个＆＃34; id＆＃34;返回的值，假设应用程序创建如下的更新语句，并绑定＆＃34; id＆＃34;返回＆＃34;？1＆＃34;范围：</p><p>  Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is thatthe initial query has not run to completion. It is remembering its placein the middle of a scan of the R-Tree. So an update to the R-Tree cannotbe tolerated as this would disrupt the scan.</p><p>  然后，更新可能会失败，使用SQLite_Locked错误。原因是初始查询尚未完成完成。它正在记住它的扫描扫描的中间。因此，R-Tree的更新无法容忍，因为这会破坏扫描。</p><p> It is also possible to express this kind of simultaneous read and writeon an R-Tree within a single query, for example if an UPDATE statementtries to change the value of one row of the R-Tree based on a complicatedquery from another row of the same R-Tree, perhaps something like this:</p><p> 还可以在单​​个查询中表达此类同时读取和写入R树，例如，如果更新语句基于从另一行的复杂Query改变R-TRE的一行值的值r树，也许是这样的：</p><p> UPDATE demo_index SET maxY = (SELECT max(maxX) FROM demo_index AS x2 WHERE x2.maxY&gt;demo_index.x2) WHERE maxY&gt;=35.0 AND minY&lt;=35.0;</p><p> 更新demo_index set maxy =（从demo_index中选择max（maxx）作为x2，其中maxy＆gt; = 35.0和miny＆lt; = 35.0;</p><p> This is a limitation of the R-Tree extension only. Ordinary tables inSQLite are able to read and write at the same time. Other virtual tablesmight (or might not) also that capability. And R-Tree can appear to readand write at the same time in some circumstances, if it can figure out howto reliably run the query to completion before starting the update. Butyou shouldn&#39;t count on that for every query. Generally speaking, it isbest to avoid running queries and updates to the same R-Tree at the sametime.</p><p> 这是仅限R树扩展的限制。普通表Insqlite能够同时读取和写入。其他虚拟表格（或可能不会）也是那种能力。在某些情况下，R-Tree可以在某些情况下同时写入，如果它可以在开始更新之前可靠地运行查询以便完成。 Butyou＆＃39;对于每个查询都指望。一般而言，它是最避免在Sametime上运行查询和更新到相同的R树。 </p><p> If you really need to update an R-Tree based on complex queries againstthe same R-Tree, it is best to run the complex queries first and storethe results in a temporary table, then update the R-Tree based on the valuesstored in the temporary table.</p><p>如果您真的需要基于对同一R树的复杂查询更新R-Tree，最好先运行复杂的查询并在临时表中存储结果，然后基于临时虚拟价值进行r-tree更新r树桌子。</p><p>  For SQLite versions prior to 3.24.0 (2018-06-04),the only information that an R*Tree index stores about an object isits integer ID and its bounding box. Additional information needs tobe stored in separate tables and related to the R*Tree index usingthe primary key. For the example above, one might create an auxiliarytable as follows:</p><p>  对于3.24.0之前的SQLite版本（2018-06-04），R *树索引存储对象的唯一信息是整数ID及其边界框。其他信息需要存储在单独的表中并使用主键与R *树索引相关。对于上面的示例，可以创建一个辅助表，如下所示：</p><p> CREATE TABLE demo_data( id INTEGER PRIMARY KEY, -- primary key objname TEXT, -- name of the object objtype TEXT, -- object type boundary BLOB -- detailed boundary of object);</p><p> 创建表Demo_data（ID Integer主键， - 主键objname文本， - 对象objtype文本的名称， - 对象类型边界Blob  - 对象的详细边界）;</p><p> In this example, the demo_data.boundary field is intended to hold somekind of binary representation of the precise boundaries of the object.The R*Tree index only holds an axis-aligned rectangular boundary for theobject. The R*Tree boundary is just an approximation of the true objectboundary. So what typically happens is that the R*Tree index is used tonarrow a search down to a list of candidate objects and then more detailedand expensive computations are done on each candidate to find if thecandidate truly meets the search criteria.</p><p> 在此示例中，demo_data.boundary字段旨在抓住对象的精确边界的二进制表示。R *树索引仅保存对对象的轴对齐的矩形边界。 R *树边界只是真正的ObjectBoundary的近似值。因此，通常发生的是，R *树索引用于将TONARROW A搜索到候选对象列表中，然后在每个候选人上完成更具详细的计算，以查找Chandidate是否真正符合搜索条件。</p><p> Key Point:An R*Tree index does not normally provide the exact answer but merelyreduces the set of potential answers from millions to dozens.</p><p> 关键点：R *树索引通常不提供确切的答案，而是仅从数百万到数十个的潜在答案集。</p><p> Suppose the demo_data.boundary field holds some proprietary data descriptionof a complex two-dimensional boundary for an object and suppose that theapplication has used the  sqlite3_create_function() interface tocreated application-defined functions &#34;contained_in&#34; and&#34;overlaps&#34; accepting two demo_data.boundary objects and return true or false.One may assume that &#34;contained_in&#34; and &#34;overlaps&#34; are relatively slowfunctions that we do not want to invoke too frequently.Then an efficient way to find the name of all objects located withinthe North Carolina 12th District, one may be to run a query like this:</p><p> 假设demo_data.boundary字段为对象保存一些专有的数据说明，用于对象的复杂二维边界，并假设TheApplication使用了SQLite3_Create_Function（）接口被创建的应用程序定义的函数＆＃34; conted_in＆＃34;和＃34;重叠＆＃34;接受两个demo_data.boundary对象并返回true或false.one可能会假设它＆＃34; contedated_in＆＃34;和＃34;重叠＆＃34;我们不想过于频繁地调用的相对速度。然后，一个有效的方法来查找位于Carolina 12th District的所有对象的名称，可能是这样的查询：</p><p>  SELECT objname FROM demo_data, demo_index WHERE demo_data.id=demo_index.id AND contained_in(demo_data.boundary, :boundary) AND minX&gt;=-81.0 AND maxX&lt;=-79.6 AND minY&gt;=35.0 AND maxY&lt;=36.2;</p><p>  从demo_data，demo_index中选择objname，其中demo_data.id = demo_index.id和conted_in（demo_data.boundary，：边界）和minx＆gt; =  -  81.0和maxx＆lt;  -  79.6和miny＆gt; = 35.0和maxy＆lt; = 36.2; </p><p> In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the&#34;:boundary&#34; parameter.</p><p>在上面的查询中，一个人可能会绑定第12区的精确边界的二进制Blob描述到＆＃34;：边界＆＃34;范围。</p><p> Notice how the query above works: The R*Tree index runs in the outerloop to find entries that are contained within the bounding boxof longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks upthe corresponding entry in the demo_data table. It then uses the boundaryfield from the demo_data table as a parameter to the contained_in()function and if that function returns true, the objname field fromthe demo_data table is returned as the next row of query result.</p><p> 请注意，上面的查询如何工作：R *树索引在SuperLoop中运行，以查找包含在界限框中包含的条目-81 ..- 79.6和Latitude 35.0..36.2。对于找到的每个对象标识符，SQLite在demo_data表中查找相应的条目。然后，它将边界场从demo_data表中作为参数到CONTAINT_IN（）函数，如果该函数返回true，则emo_data表中的objname字段将作为下一行查询结果返回。</p><p> One would get the same answer without the use of the R*Tree indexusing the following simpler query:</p><p> 在不使用R *树索引以下更简单的查询的情况下，可以获得相同的答案：</p><p>  The problem with this latter query is that it must apply thecontained_in() function to millions of entries in the demo_data table.The use of the R*Tree in the penultimate query reduces the number ofcalls to contained_in() function to a small subset of the entire table.The R*Tree index did not find the exact answer itself, it merelylimited the search space.</p><p>  此后一查询的问题是它必须将Thecontained_in（）函数应用于Memo_Data表中数百万条目。倒倒数查询中的R *树将函数的数量减少到Conted_in（）函数中的一个小子集整个表.R *树索引没有找到确切的答案本身，它仅限于搜索空间。</p><p>   Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tablescan have auxiliary columns that store arbitrary data.Auxiliary columns can be used in place ofsecondary tables such as &#34;demo_data&#34;.</p><p>   从SQLite版本3.24.0（2018-06-04）开始，R-Tree TableScan具有存储任意数据的辅助列.Auxiliary列可以用于诸如＆＃34; demo_data＆＃34等中的桌子。</p><p> Auxiliary columns are marked with a &#34;+&#34; symbol before the column name.Auxiliary columns must come after all of the coordinate boundary columns.There is a limit of no more than 100 auxiliary columns.The following example shows an r-tree table with auxiliary columns thatis equivalent to the two tables &#34;demo_index&#34; and &#34;demo_data&#34; above:</p><p> 辅助列标有A＆＃34; +＆＃34;符号在列名称之前。突出所有坐标边界列之前必须出现。以下示例显示了一个不超过100个辅助列的限制。与辅助列的R树表相当于两个表＆＃ 34; demo_index＆＃34;和＃34; demo_data＆＃34;以上：</p><p> CREATE VIRTUAL TABLE demo_index2 USING rtree( id, -- Integer primary key minX, maxX, -- Minimum and maximum X coordinate minY, maxY, -- Minimum and maximum Y coordinate +objname TEXT, -- name of the object +objtype TEXT, -- object type +boundary BLOB -- detailed boundary of object);</p><p> 使用Rtree（ID， - 整数主键MINX，MAXX，MAXX，MAXX）创建虚拟表DEMO_INDEX2 CON CONERY，MAXY， - 最小和最大y坐标+ objname文本， - 对象+ objtype文本的名称， - 对象类型+边界BLOB  - 对象的详细边界）; </p><p> By combining location data and related information into the sametable, auxiliary columns can provide a cleaner modeland reduce the need to joins.For example, the earlier join between demo_index and demo_data can nowbe written as a simple query, like this:</p><p>通过将位置数据和相关信息组合到可打个信息中，辅助列可以提供更清晰的模型，减少需要加入的需要。例如，demo_index和demo_data之间的早期连接可以写成一个简单的查询，如下所示：</p><p> SELECT objname FROM demo_index2 WHERE contained_in(boundary, :boundary) AND minX&gt;=-81.0 AND maxX&lt;=-79.6 AND minY&gt;=35.0 AND maxY&gt;=36.2;</p><p> 从demo_index2中选择objname，其中conted_in（边界，：边界）和minx＆gt; =  -  81.0和maxx＆lt;  -  79.6和miny＆gt; = 35.0和maxy＆gt; = 36.2;</p><p>  For auxiliary columns, only the name of the column matters.The  type affinity is ignored.Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECKare also ignored. However, future versionsof SQLite might start paying attention to the type affinity andconstraints, so users of auxiliary columns are advised to leaveboth blank, to avoid future compatibility problems.</p><p>  对于辅助列，仅禁止列的名称。忽略类型的关联。忽略无效，唯一，参考或核心等。但是，SQLite的未来版本可能会开始关注类型的关联和控制，因此建议辅助列的用户离开空白，以避免将来的兼容性问题。</p><p>  The default virtual table (&#34;rtree&#34;) normally stores coordinates assingle-precision (4-byte) floating point numbers. If integer coordinatesare desired, declare the table using &#34;rtree_i32&#34; instead:</p><p>  默认虚拟表（＆＃34; rtree＆＃34;）通常存储坐标查询 - 精度（4字节）浮点数。如果所需的整数协调，请使用＆＃34声明表格; rtree_i32＆＃34;反而：</p><p>  An rtree_i32 stores coordinates as 32-bit signed integers. But it stillusing floating point computations internally as part of the r-tree algorithm.</p><p>  rtree_i32存储坐标作为32位符号整数。但它是静止的浮点计算作为R树算法的一部分。</p><p>  By using standard SQL expressions in the WHERE clause of a SELECT query,a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box.Custom R*Tree queries, using the MATCHoperator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</p><p>  通过在SELECT查询的WHERE子句中使用标准SQL表达式，程序员可以查询与WHERE子句中的匹配机构中的与特定边界-COSTOM R *树查询中相交或包含在特定边界框中的所有R *树条目选择，允许程序员查询与任何任意区域或形状相交的R *树条目的集合，而不仅仅是一个框。例如，此功能是有用的，例如，在从位于3-D空间中的相机中可见的R *树中的对象子集。</p><p> Regions for custom R*Tree queries are defined by R*Tree geometry callbacksimplemented by the application and registered with SQLite via a call to oneof the following two APIs:</p><p> 自定义R *树查询的区域由应用程序的R *树几何呼叫定义，并通过呼叫对以下两个API的呼叫注册了SQLite： </p><p> int sqlite3_rtree_query_callback( sqlite3 *db, const char *zQueryFunc, int (*xQueryFunc)(sqlite3_rtree_query_info*), void *pContext, void (*xDestructor)(void*));int sqlite3_rtree_geometry_callback( sqlite3 *db, const char *zGeom, int (*xGeom)(sqlite3_rtree_geometry *, int nCoord, double *aCoord, int *pRes), void *pContext);</p><p>int sqlite3_rtree_query_callback（sqlite3 * db，const char * zqueryfunc，int（* xqueryfunc）（sqlite3_rtree_query_info *），void * pcontext，void（* xdestructor）（void *））; int sqlite3_rtree_geometry_callback（sqlite3 * db，const char * zgeom，int （* XWEOM）（SQLite3_RTREE_GEOMETRY *，INT NCOORD，DOUBLE * ACOORD，INT * PRES），VOID * PContext）;</p><p> The sqlite3_rtree_query_callback() became available with SQLite version 3.8.5 (2014-06-04) and is the preferred interface.The sqlite3_rtree_geometry_callback() is an older and less flexibleinterface that is supported for backwards compatibility.</p><p> SQLite3_Rtree_Query_CallBack（）已使用SQLite版本3.8.5（2014-06-04）可用，并且是首选界面。SQLite3_Rtree_Geometry_callback（）是向后兼容性支持的较旧的且较少的灵活性接口。</p><p> A call to one of the above APIs creates a new SQL function named by thesecond parameter (zQueryFunc or zGeom). When that SQL function appearson the right-hand side of the MATCH operator and the left-hand side of theMATCH operator is any column in the R*Tree virtual table, then the callback defined by the third argument (xQueryFunc or xGeom) is invoked to determineif a particular object or subtree overlaps the desired region.</p><p> 对上述一个API的调用创建一个由theSecond参数（zqueryfunc或zgeom）命名的新SQL函数。当SQL函数出现匹配操作员的右侧和Thematch运算符的左侧是R *树虚拟表中的任何列，那么由第三个参数（XQueryFunc或XGeOM）定义的回调确定特定对象或子树与所需区域重叠。</p><p> For example, a query like the following might be used to find allR*Tree entries that overlap with a circle centered a 45.3,22.9 with aradius of 5.0:</p><p> 例如，如下所示的查询可用于查找与圆圈重叠的Allr *树条目以5.0的Aradius为中心为45.3,22.9：</p><p>  The SQL syntax for custom queries is the same regardless of whichinterface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(),is used to register the SQL function. However, the newer query-stylecallbacks give the application greater control over how the query proceeds.</p><p>  无论哪个interface，sqlite3_rtree_geometry_callback（）或sqlite3_rtree_query_callback（）用于注册SQL函数，SQL语法是相同的。但是，较新的查询-DequeryEcallbacks为应用程序提供了更好地控制查询所需的操作。</p><p>  The legacy xGeom callback is invoked with four arguments. The firstargument is a pointer to an sqlite3_rtree_geometry structure which providesinformation about how the SQL function was invoked. The second argumentis the number of coordinates in each r-tree entry, and is always the samefor any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree,4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth.The third argument, aCoord[], is an array of nCoord coordinates that definesa bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zeroif the bounding-box defined by aCoord[] is completely outsidethe region defined by the xGeom callback and the result is non-zero ifthe bounding-box is inside or overlaps with the xGeom region. The xGeomcallback should normally return SQLITE_OK. If xGeom returns anything otherthan SQLITE_OK, then the r-tree query will abort with an error.</p><p>  使用四个参数调用传统XWEOM回调。 FirstRgument是指向SQLite3_Rtree_Geometry结构的指针，它提供了关于如何调用SQL函数的方式。第二个Aructionis每个R树条目中的坐标的数量，并且始终是任何给定的R *树的同伴。坐标的数量为1维r *树，4为2维r *树，为3维r *树的6，等等。第三个参数，Acoord []，是一个数组NCOORD坐标定义要测试的边界框。最后一个参数是应该写回调结果的指针。结果是ZEROIF由XWEOM回调定义的ACOORS []定义的边界框，如果边界框在内部或与XGEOM区域重叠的情况下，结果是非零的。 XGeomcallback通常应返回SQLite_ok。如果XWEOM返回其他以其他方式SQLITE_OK，则R树查询将中止错误。</p><p> The sqlite3_rtree_geometry structure that the first argument to thexGeom callback points to has a structure shown below. The exact samesqlite3_rtree_geometrystructure is used for every callback for same MATCH operator in the samequery. The contents of the sqlite3_rtree_geometrystructure are initialized by SQLite but arenot subsequently modified. The callback is free to make changes to thepUser and xDelUser elements of the structure if desired.</p><p> sqlite3_rtree_geometry结构是thexGeom回调点的第一个参数具有下面显示的结构。确切的SameSQlite3_Rtree_GeometryStructure用于同一匹配操作员的每个回调。 SQLite3_Rtree_GeometryStructure的内容由SQLite初始化，但随后修改了arenot。如果需要，回调是可以自由地对结构的Xdeluser元素进行更改。 </p><p> typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;struct sqlite3_rtree_geometry { void *pContext; /* Copy of pContext passed to s_r_g_c() */ int nParam; /* Size of array aParam */ double *aParam; /* Parameters passed to SQL geom function */ void *pUser; /* Callback implementation user data */ void (*xDelUser)(void *); /* Called by SQLite to clean up pUser */};</p><p>typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry; struct sqlite3_rtree_geometry {void * pcontext; / * pcontext的副本传递给s_r_g_c（）* / int nparam; / *阵列的大小aparam * / double * aparam; / *传递给SQL GeoM功能的参数* / void * puser; / *回调实现用户数据* / void（* xdeluser）（void *）; / *由SQLite调用以清理PUSER * /};</p><p> The pContext member of the sqlite3_rtree_geometrystructure is always set to a copy of the pContextargument passed to sqlite3_rtree_geometry_callback() when thecallback is registered. The aParam[] array (size nParam) contains the parametervalues passed to the SQL function on the right-hand side of the MATCH operator.In the example &#34;circle&#34; query above, nParam would be set to 3 and the aParam[]array would contain the three values 45.3, 22.9 and 5.0.</p><p> SQLite3_Rtree_Geometryrystructure的PContext成员始终设置为PContextAlgument的副本，当注册了Thecallback时传递给SQLite3_Rtree_geometry_callback（）。 aparam [] array（size nparam）包含传递给匹配运算符的右侧的SQL函数的参数服务。在示例＆＃34;圆圈＆＃34;上面查询，NPARAM将设置为3，APARAM []数组将包含三个值45.3,22.9和5.0。</p><p> The pUser and xDelUser members of the sqlite3_rtree_geometry structure areinitially set to NULL. The pUser variable may be set by the callbackimplementation to a</p><p> SQLite3_Rtree_Geometry结构的PUSER和XDELUSER成员全部设置为NULL。 PUSER变量可以由响铃算法设置为a</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.sqlite.org/rtree.html">https://www.sqlite.org/rtree.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tree/">#tree</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>