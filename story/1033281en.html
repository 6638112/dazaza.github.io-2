<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Bddisasm：BitDefender x86反汇编程序</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bddisasm：BitDefender x86反汇编程序</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-05 20:10:22</div><div class="page_narrow text-break page_content"><p>Hypervisor Memory Introspection (HVMI) relies on analyzing memory accesses in order to determine whether they are legitimate or not. For example, by analyzing the old memory value and the newly stored value, HVMI can decide whether to allow the modification or not. This, however, introduces the complication of needing to do an in-depth analysis of each instruction that modifies protected memory. Unlike a RISC architecture, x86 has a large number of instructions that may access memory in a complicated, read-modify-write (RMW) manner, and using complicated addressing schemes.In order to simplify instruction decoding and analysis, a dedicated x86 instruction decoder has been created, capable of providing full instruction information, and thus alleviating the HVMI module from needing to know x86 instructions format. This blog post will detail some bddisasm internals, how to work with it, while highlighting why it is a critical part of HVMI. In addition, we will go through some particularities of x86 instruction encoding. The main bddisasm project is located  here, and the documentation can be accessed  here.</p><p>管理程序内存自省(HVMI)依赖于分析内存访问以确定它们是否合法。例如，通过分析旧的存储值和新存储的值，HVMI可以决定是否允许修改。然而，这带来了需要对修改受保护内存的每条指令进行深入分析的复杂性。与RISC体系结构不同，x86有大量的指令可以通过复杂的读-修改-写(RMW)方式访问存储器，并使用复杂的寻址方案。为了简化指令解码和分析，我们创建了一个专用的x86指令解码器，能够提供完整的指令信息，从而减轻了HVMI模块对x86指令格式的需要。这篇博客文章将详细介绍一些bddisasm内部机制，以及如何使用它，同时强调为什么它是HVMI的关键部分。此外，我们还将介绍x86指令编码的一些特殊性。主要的bddisasm项目位于此处，可以在此处访问文档。</p><p>  bddisasm is a standalone library, written in C, with some Python used for internal decoder-tables generation. The library is built to be fast, while providing as much information about the decoded instructions as possible - this is important, because other projects using bddisasm can rely on it to provide complete and accurate information about instructions. When considering other decoding libraries, there are only some which are similar in features:</p><p>Bddisasm是一个用C编写的独立库，使用一些Python生成内部解码表。该库构建得很快，同时提供尽可能多的关于已解码指令的信息-这一点很重要，因为其他使用bddisasm的项目可以依赖它来提供关于指令的完整而准确的信息。在考虑其他解码库时，只有一些功能相似：</p><p> Intel Xed, which is written and maintained by Intel, thus somehow making it the standard x86 decoder; while not the fastest, it provides rich information about the decoded instructions;</p><p>Intel Xed是由Intel编写和维护的，因此以某种方式使其成为标准的x86解码器；虽然它不是最快的，但它提供了关于解码指令的丰富信息；</p><p>    ZyDis, which is comparable to Xed as far as features go, and lightweight (however, when bddisasm was created internally, ZyDis did not exist yet);</p><p>Zydis，就功能而言可以与Xed相媲美，而且轻量级(然而，在内部创建bddisasm时，Zydis还不存在)；</p><p> Other decoders written in other languages, such as Rust or C#, or disassembler (which only provide a textual output of the instruction, without providing actual decoded instruction information) were not considered. Given that Xed and Capstone seemed rather difficult to work with at that time, we decided to create a lightweight decoder of our own, with the following objectives in mind:</p><p>用其他语言(如Rust或C#)编写的其他解码器或反汇编程序(只提供指令的文本输出，而不提供实际解码的指令信息)不被考虑。考虑到当时Xed和Capstone似乎很难合作，我们决定创建自己的轻量级解码器，考虑到以下目标：</p><p> Lightweight - written entirely in C, with no external dependencies, no memory allocated, and thread-safe by design;</p><p>轻量级-完全用C语言编写，没有外部依赖，没有分配内存，设计上是线程安全的；</p><p>  Fast - while we needed a decoder capable of providing as much information as possible about instructions, we still considered speed an important factor;</p><p>速度--虽然我们需要一个能够提供尽可能多的指令信息的解码器，但我们仍然认为速度是一个重要因素；</p><p>  Resilient - the decoder should be able to handle all kinds of malformed instructions, as well as valid instructions containing redundant prefixes, or encodings which are not typical;</p><p>弹性-解码器应该能够处理各种格式错误的指令，以及包含冗余前缀或非典型编码的有效指令；</p><p>  Complete - the decoder must support all existing x86 instructions, including AVX; moreover, extending the support to new instructions should be as simple as possible;</p><p>完整-解码器必须支持所有现有的x86指令，包括AVX；此外，扩展对新指令的支持应该尽可能简单；</p><p>  Easy to work with - single-header file, single-API library, which provides all possible information in the output decoded instruction, without the need to call additional functions in order to extract information from the decoded instruction;</p><p>易于使用-单头文件，单API库，它提供了输出解码指令中所有可能的信息，而不需要调用额外的函数来从解码指令中提取信息；</p><p> We will not get into a comparison between bddisasm and other decoding libraries, and we will keep the focus of this blog post on how to work with bddisasm and how useful it is in HVMI.</p><p>我们不会对bddisasm和其他解码库进行比较，我们将把这篇博客的重点放在如何使用bddisasm以及它在HVMI中的用处。</p><p>  Working with the decoding library is easy: include the  bddisasm.h header file, link with the  bddisasm.lib (Windows) or  libbddisasm.a (Linux), and call the decoding API! bddisasm uses a single-API decoding scheme, where the  NdDecode APIs provide an output  INSTRUX structure containing all the possible information about the instruction. The only thing not included in the  INSTRUX structure is the textual disassembly of the instruction, which has to be generated separately using the  NdToText API. A typical usage scenario might be the following:</p><p>使用解码库很容易：包括bddisasm.h头文件，链接到bddisasm.lib(Windows)或libbddisasm.a(Linux)，然后调用解码API！Bddisasm使用单一API解码方案，其中NdDecode API提供一个包含有关指令的所有可能信息的输出INSTRUX结构。INSTRUX结构中唯一没有包括的是指令的文本反汇编，它必须使用NdToText API单独生成。典型的使用场景可能如下所示：</p><p> #include &#34;bddisasm/bddisasm.h&#34; int  main () {  INSTRUX  ix ;  unsigned  char  ins [ 2 ]  =  {  0x33 ,  0xC0  };  NDSTATUS  status ;  status  =  NdDecodeEx ( &amp; ix ,  ins ,  sizeof ( ins ),  ND_CODE_64 ,  ND_DATA_64 );  if  ( ! ND_SUCCESS ( status ))  {  printf ( &#34;Decoding failed with error 0x%08x! \n &#34; ,  status );  return  - 1 ;  }  printf ( &#34;Decoded instruction with length %d! \n &#34; ,  ix . Length ); }</p><p>#INCLUDE&#34；bddisasm/bddisasm.h&#34；int main(){INSTRUX ix；unsign char ins[2]={0x33，0xC0}；NDSTATUS Status；Status=NdDecodeEx(&amp；ix，ins，sizeof(Ins)，ND_CODE_64，ND_DATA_64)；如果(！ND_SUCCESS(状态)){printf(&#34；解码失败，错误0x%08x！\n&#34；，状态)；return-1；}printf(&#34；解码的指令长度为%d！\n&#34；，ix。长度)；}。</p><p>  Note that the output  INSTRUX ix structure will contain  all the information about the decoded instruction. A comprehensive list about what kind of information you can find:</p><p>请注意，输出INSTRUX ix结构将包含有关已解码指令的所有信息。有关您可以找到的信息类型的综合列表：</p><p> Decoded prefix information, such as whether the instruction uses lock, is repeated, is xacquire/xrelease enabled or CET tracked;</p><p>重复解码的前缀信息，例如指令是否使用锁定，是否启用xAcquisition/xRelease或跟踪CET；</p><p>  Length information, including about the instruction itself and different fields of the instruction, such as immediate fields or displacement;</p><p>长度信息，包括关于指令本身和指令的不同字段的信息，例如立即字段或移位；</p><p>  Offset information about each constituent field of the instruction (position of each field inside the instruction);</p><p>关于指令的每个构成字段的偏移量信息(指令中每个字段的位置)；</p><p>            CPUID feature flag, which indicates the leaf and subleaf that must be queried, together with the register and bit which indicates support for that particular instruction;</p><p>CPUID特征标志，其指示必须查询的叶和子叶，以及指示对该特定指令的支持的寄存器和位；</p><p>          Operand information, including: operand type, size, access (read, conditional read, write, conditional write) and details;</p><p>操作数信息，包括：操作数类型、大小、访问(读、条件读、写、条件写)和详细信息；</p><p>  Full memory operand details: segment, base, index, scale, compressed displacement, stack, string, bitbase, VSIB, etc.);</p><p>全内存操作数详细信息：段、基数、索引、小数位数、压缩位移、堆栈、字符串、位库、VSIB等)；</p><p> Examples on how different kind if info can be extracted from  INSTRUX can be found on the  official documentation page.</p><p>关于如何从INSTRUX中提取不同类型的信息的例子可以在官方文档页面上找到。</p><p>  Using the  NdToText function, one can convert a decoded  INSTRUX to a textual disassembly that can be printed. The  NdToText function only supports Intel style syntax, so the following instruction  33C0 would be decoded as  XOR eax, eax, and  4833C0 would be decoded as  XOR rax, rax. Typical usage of the  NdToText function is:</p><p>使用NdToText函数，可以将解码的INSTRUX转换为可以打印的文本反汇编。NdToText函数仅支持英特尔风格的语法，因此以下指令33C0将被解码为XOR eax，eax，而4833C0将被解码为XOR rax，rax。NdToText函数的典型用法是：</p><p> // Create the text disassembly for this instruction.  char  text [ ND_MIN_BUF_SIZE ];  NdToText ( &amp; ix ,  0 ,  sizeof ( text ),  text );  printf ( &#34;Instruction: %s \n &#34; ,  text );</p><p>//为该指令创建文本反汇编。字符文本[ND_MIN_BUF_SIZE]；NdToText(&amp；ix，0，sizeof(Text)，text)；printf(&#34；说明：%s\n&#34；，text)；</p><p>  bddisasm is a critical part of the HVMI technology. As mentioned, decoding and analyzing instructions is important, since the vast majority of events HVMI is dealing with are EPT violations (memory-referencing instructions).</p><p>分流是HVMI技术的关键部分。如前所述，解码和分析指令非常重要，因为HVMI处理的绝大多数事件都违反了EPT(内存引用指令)。</p><p> One of the first things HVMI does when an EPT violation takes place is to decode the offending instruction. Since accessing guest memory is usually slow (as it involves translating the guest linear address to a guest physical address, and mapping each physical page in the process - both page-tables and the actual page), once an instruction is decoded, it gets cached internally. Subsequent accesses from the same instruction pointer would yield an already decoded, cached instruction, thus speeding up this process (of course, caching instructions also implies that the pages containing them have to be monitored for modifications, in order to invalidate the cache if an instruction is modified).</p><p>当EPT违规发生时，HVMI做的第一件事就是对违规指令进行解码。由于访问客户内存通常很慢(因为它涉及将客户线性地址转换为客户物理地址，并映射进程中的每个物理页面-页表和实际页面)，因此一旦指令被解码，它就会被内部缓存。来自同一指令指针的后续访问将产生已解码的高速缓存指令，从而加速这一过程(当然，高速缓存指令还意味着必须监视包含它们的页的修改，以便在指令被修改时使高速缓存无效)。</p><p> Once the instruction has been decoded, HVMI will dissect it in order to determine each memory location accessed. This is important, because one instruction may directly, or indirectly, access multiple memory locations, and we have to analyze each access before allowing the instruction to continue. Since bddisasm provides full operand information (including implicit operands), HVMI will basically iterate through all the instruction operands, and check if they’re memory. For each memory operand, it would then make sure that it accesses a region of memory that is not monitored by HVMI. Examples of instructions that access multiple addresses might include:</p><p>一旦指令被解码，HVMI将对其进行剖析，以确定所访问的每个存储器位置。这一点很重要，因为一条指令可以直接或间接访问多个内存位置，在允许指令继续之前，我们必须分析每次访问。因为bddisasm提供了完整的操作数信息(包括隐式操作数)，所以HVMI基本上会遍历所有指令操作数，并检查它们是否为内存。然后，对于每个内存操作数，它将确保它访问不受HVMI监视的内存区域。访问多个地址的指令示例可能包括：</p><p> CALL [mem] - it reads the  [mem] operand, and it writes the stack; it may also access the shadow stack, if CET Shadow Stack is enabled;</p><p>调用[mem]-它读取[mem]操作数，并写入堆栈；如果启用了CET影子堆栈，它还可以访问影子堆栈；</p><p>    AVX instruction using VSIB addressing - multiple addresses may be accessed by a VSIB operand such as  [rax+xmm0*8];</p><p>使用VSIB寻址的AVX指令-多个地址可由VSIB操作数访问，例如[rax+xmm0*8]；</p><p> There are also some events (mostly asynchronous) which may cause EPT violations, even if the current instruction does not do any kind of memory access; such events include:</p><p>还有一些事件(主要是异步事件)可能会导致EPT冲突，即使当前指令不执行任何类型的内存访问也是如此；此类事件包括：</p><p> Delivery of interrupts or exceptions, which will read the Interrupt Descriptor Table (IDT), and will write the interrupt frame on the stack;</p><p>发送中断或异常，该中断或异常将读取中断描述符表(IDT)，并将中断帧写入堆栈；</p><p>    Access inside the Task State Segment (TSS) as part of a task switch or interrupt delivery;</p><p>作为任务切换或中断传送的一部分的任务状态段(TSS)内的访问；</p><p>  Accesses inside page-tables, as part of page-walks (although these are distinctively indicated using a dedicated bit inside the VMCS EPT violation exit qualification);</p><p>页表内的访问，作为页面遍历的一部分(尽管这些访问是使用VMCS EPT违规退出资格内的专用位明确表示的)；</p><p> These types of events are not included in the  INSTRUX structure, as they may occur in an asynchronous manner, during normal instruction execution.</p><p>这些类型的事件不包括在INSTRUX结构中，因为它们可能在正常指令执行期间以异步方式发生。</p><p> Once the faulting instruction has been decoded, it gets analyzed by multiple modules inside Introcore, in order to determine whether it is a legitimate modification (this is used together with other kinds of information extracted, such as what module the instruction belongs to). A typical validation is comparing the old memory value with the new value that is about to be stored - if they are the same, it is generally safe to allow the instruction to execute. Extracting the old value can be done by doing a simple emulation of the instruction - since bddisasm already provides all the necessary information, the new value can be computed fairly easy (and since this is not a full-blown emulation, there’s no need to do checks at this point).</p><p>一旦错误指令被解码，Introcore内部的多个模块就会对其进行分析，以确定它是否为合法修改(这与提取的其他类型的信息一起使用，例如指令属于哪个模块)。典型的验证是将旧内存值与即将存储的新值进行比较-如果它们相同，则允许指令执行通常是安全的。提取旧值可以通过对指令进行简单的模拟来完成-因为bddisasm已经提供了所有必要的信息，所以可以相当容易地计算出新值(而且由于这不是一个全面的模拟，所以在这一点上不需要进行检查)。</p><p> Another common task done to instructions which access memory is to compute the guest linear address accessed by an explicit memory operand. For a typical modrm encoded memory operand, steps needed in order to compute this value include:</p><p>对访问内存的指令执行的另一个常见任务是计算显式内存操作数访问的客户线性地址。对于典型的modrm编码内存操作数，计算该值所需的步骤包括：</p><p> Querying the segment registers, and fetching the base of the segment used in the addressing; the resulting linear address can be initialized to this segment-base value, or 0, of no segment is used;</p><p>查询段寄存器，并获取寻址中使用的段的基址；所得到的线性地址可以被初始化为该段基值，或者不使用段的0；</p><p>  If the memory operand is direct (such as in  A01111111111111111, which decodes to  MOV al, byte ptr [0x1111111111111111]), the address can be added to the linear address, and no further processing is needed;</p><p>如果内存操作数是直接的(例如在A01111111111111111中，其解码为MOVAL，字节PTR[0x11111111111111])，则可以将地址添加到线性地址，并且不需要进一步处理；</p><p>  If the memory operand uses a base register, add its value to the linear address;</p><p>如果内存操作数使用基址寄存器，则将其值与线性地址相加；</p><p>  If the memory operand uses an index register, scale it and add it to the linear address;</p><p>如果内存操作数使用索引寄存器，则对其进行缩放并将其添加到线性地址；</p><p>    If the memory oprand is RIP-relative, add the length of the current instruction, followed by the current RIP;</p><p>如果内存操作是RIP相关的，则添加当前指令的长度，后跟当前RIP；</p><p>  If the memory operand uses bitbase addressing ( BT,  BTS,  BTR,  BTC instructions), compute the bit offset from the source operand, and add it to the resulting linear address;</p><p>如果内存操作数使用位基寻址(BT、BTS、BTR、BTC指令)，则计算源操作数的位偏移量，并将其与结果线性地址相加；</p><p>  If the operation is a stack push, subtract the size of the stack operation from the resulting linear address;</p><p>如果操作是堆栈推送，则从得到的线性地址减去堆栈操作的大小；</p><p> The steps listed above will yield the linear address used by the instruction operand, which can be further processed to extract more information.</p><p>上面列出的步骤将产生指令操作数使用的线性地址，可以对其进行进一步处理以提取更多信息。</p><p>  bddisasm has been created in an extensible way, making the addition of new instructions trivial, as long as they don’t use a new encoding scheme, or new registers. The instructions database is contained in several  .dat files located inside the  isagenerator/instructions project of the bddisasm repo. While sufficient information about this project is already provided in the  readme, we will only show a quick demonstration about adding new instructions to bddisasm.</p><p>Bddisasm是以可扩展的方式创建的，这使得添加新指令变得微不足道，只要它们不使用新的编码方案或新的寄存器。说明数据库包含在bddisasm repo的isagenerator/Instructions项目内的几个.dat文件中。虽然自述文件中已经提供了关于该项目的足够信息，但我们将只演示如何向bddisasm添加新的说明。</p><p> Let’s first pick up an encoding that is not currently used by any instruction -  0F04 (although it should be noted that it was used on 286 by  LOADALL). If we try to decode this instruction, we will see that bddisasm fails:</p><p>让我们首先选择一个当前没有被任何指令0F04使用的编码(尽管应该注意，它是由LoadAll在286上使用的)。如果我们尝试解码此指令，我们将看到bddisasm失败：</p><p>  Looking inside  disasmstatus.h, we see that error code  0x80000002 means  ND_STATUS_INVALID_ENCODING - so there is no valid encoding for it, which is good, since we want to create our own.</p><p>查看disasmstatus.h内部，我们看到错误代码0x80000002表示ND_STATUS_INVALID_ENCODING-因此没有有效的编码，这很好，因为我们想创建自己的编码。</p><p> Let’s now assume that the instruction we want to create is a simple, modrm encoded instruction, with two operands - the first one is a general purpose register, while the second one is either general purpose register, or memory. Let’s call this instruction  BDDISASM, and let’s see a couple of possible forms:</p><p>现在让我们假设我们要创建的指令是一个简单的模编码指令，有两个操作数-第一个是通用寄存器，第二个是通用寄存器或内存。让我们将此指令称为BDDISASM，让我们看看几种可能的形式：</p><p>  As already mentioned, the opcode for this instruction will be (the currently unassigned)  0F04. The first operand will be a 16, 32 or 64 bit general purpose register, depending on operand size. The second operand will be a 16, 32 or 64 bit general purpose register or memory location, depending on modrm.mod and operand size. The first operand is read-write, while the second one is only read. There are no implicit operands. We can now describe the basic instruction in  table_0F.dat:</p><p>如前所述，该指令的操作码将是(当前未分配的)0F04。第一个操作数将是16位、32位或64位通用寄存器，具体取决于操作数大小。第二个操作数将是16、32或64位通用寄存器或内存位置，具体取决于modrm.mod和操作数大小。第一个操作数是读写的，而第二个操作数是只读的。没有隐式操作数。现在我们可以在TABLE_0F.dat中描述基本指令：</p><p>   The second element,  Gv, indicates that the first operand is a general purpose register encoded in modrm.reg ( G), and is 16, 32 or 64 bit in size, depending on operand size ( v);</p><p>第二个元素GV表示第一个操作数是以modrm.reg(G)编码的通用寄存器，其大小取决于操作数大小(V)，大小为16、32或64位；</p><p>  The third element,  Ev, indicates that the second operand is a general purpose register or memory encoded in modrm.rm ( E), and is 16, 32 or 64 bit in size, depending on operand size ( v);</p><p>第三个元素ev表示第二操作数是以modrm.rm(E)编码的通用寄存器或存储器，其大小取决于操作数大小(V)，大小为16、32或64位；</p><p>  The next element describes the implicit operands accessed by the instruction; since we have none, we specify  nil;</p><p>下一个元素描述指令访问的隐式操作数；因为我们没有任何操作数，所以我们指定为nil；</p><p>  The next element is the most important, and it describes the encoding; it enumerates all the opcode bytes -  0F and  04, followed by  /r, indicating that the instruction uses modrm encoding;</p><p>下一个元素是最重要的，它描述了编码；它列举了所有操作码字节-0F和04，后跟/r，表明指令使用modrm编码；</p><p>  The last element is the access map for each instruction operand, and is specified using the keyword  w:. The first operand is read-write ( RW), while the second one is read ( R).</p><p>最后一个元素是每个指令操作数的访问映射，并使用关键字w：指定。第一个操作数是读写(RW)，而第二个操作数是读(R)。</p><p> Let’s now rebuild the decoding tree by building the  isagenerator project in VisualStudio, or by running  make, followed by rebuilding the  bddisasm library and the  disasmtool. Let’s now try to decode the instruction again:</p><p>现在，让我们通过在VisualStudio中构建isagenerator项目，或者运行make，然后重建bddisasm库和disasmtool来重建解码树。现在让我们再次尝试对指令进行解码：</p><p>  We now get a different error:  0x80000001 which means  ND_STATUS_BUFFER_TOO_SMALL - this indicates that there is a valid instruction for this encoding, but we didn’t supply enough bytes to decode it. Indeed, we did not, as we only specified the opcode, without the modrm byte. Let’s try again, using the modrm byte as well this time:</p><p>现在我们得到一个不同的错误：0x80000001，表示ND_STATUS_BUFFER_TOO_SMALL-这表明存在用于此编码的有效指令，但我们没有提供足够的字节来解码它。事实上，我们没有这样做，因为我们只指定了操作码，而没有modrm字节。让我们再试一次，这次也使用modrm字节：</p><p>  As you can see, the instruction has been successfully decoded! Playing with different encodings yield the expected instruction:</p><p>如您所见，指令已被成功解码！使用不同的编码会产生预期的指令：</p><p> C:\&gt;disasm -b64 -h 0F0400660F0400480F0400670F0400F30F04000000000000000000 0f0400 BDDISASM eax, dword ptr [rax]0000000000000003 660f0400 BDDISASM ax, word ptr [rax]0000000000000007 480f0400 BDDISASM rax, qword ptr [rax]000000000000000B 670f0400 BDDISASM eax, dword ptr [eax]000000000000000F f30f0400 BDDISASM eax, dword ptr [rax]</p><p>C：\&gt；disasm-b64-h 0F0400660F0400480F0400670F0400F30F04000000000000000000 0f0400 BDDISASM eax，双字PTR[rax]0000000000000003 660f0400 BDDISASM ax，word PTr[rax]0000000000000007 480f0400 BDDISASM rax，qword PTR[rax]000000000000000B 670f0400 BDDISASM eax，dword PTR[eax]000000000000000F f30f0400 BAX。</p><p> If we want, we can add more information to our instruction. For example, we can now assume that the instruction modifies the flags - it always sets the carry-flag ( CF). In order to specify this, we have to first indicate that the instruction uses the implicit operand  Fv, which stands for the flags register, and then we have to tell it what flags it modifies, using the  f: keyword:</p><p>如果我们愿意，我们可以在我们的指导中添加更多的信息。例如，我们现在可以假设指令修改了标志-它总是设置进位标志(CF)。为了指定这一点，我们必须首先指示指令使用隐式操作数fv，它代表标志寄存器，然后我们必须使用f：关键字告诉它它修改了哪些标志：</p><p>   C:\&gt;disasm -b64 -h 0F0400 -exi0000000000000000 0f0400 BDDISASM eax, dword ptr [rax] DSIZE: 32, ASIZE: 64, VLEN: - ISA Set: UNKNOWN, Ins cat: UNKNOWN, CET tracked: no FLAGS access CF: 1, Valid modes R0: yes, R1: yes, R2: yes, R3: yes Real: yes, V8086: yes, Prot: yes, Compat: yes, Long: yes SMM on: yes, SMM off: yes, SGX on: yes, SGX off: yes, TSX on: yes, TSX off: yes VMXRoot: yes, VMXNonRoot: yes, VMXRoot SEAM: yes, VMXNonRoot SEAM: yes, VMX off: yes Valid prefixes REP: no, REPcc: no, LOCK: no HLE: no, XACQUIRE only: no, XRELEASE only: no BND: no, BHINT: no, DNT: no Operand: 0, Acc: RW, Type: Register, Size: 4, RawSize: 4, Encoding: R, RegType: General Purpose, RegSize: 4, RegId: 0, RegCount: 1 Operand: 1, Acc: R-, Type: Memory, Size: 4, RawSize: 4, Encoding: M, Segment: 3, Base: 0, Operand: 2, Acc: -W, Type: Register, Size: 4, RawSize: 4, Encoding: S, RegType: Flags, RegSize: 4, RegId: 0, RegCount: 1</p><p>C：\&gt；Disasm-b64-h 0F0400-exi0000000000000000 0f0400 BDDISASM eax，双字PTR[rax]DSIZE：32，ASIZE：64，Vlen：-ISA Set：UNKNOWN，INS CAT：UNKNOWN，CET TRACKED：无标志访问CF：1，有效模式R0：YES，R1：YES，R2：YES，R3：YES REAL：YES，V8086：YES，PROT：YES，COMPAT：YES，VMX OFF：YES有效前缀rep：no，REPcc：no，lock：no，HLE：no，仅XACQUIRE：no，仅XRELEASE：no BND：no，BHINT：no，DNT：no Operand：0，ACC：RW，Type：Register，Size：4，RawSize：4，Ending：R，RegType：General Purpose，RegSize：4，RegID：0，RegCount：1 Operand：1。原始大小：4，编码：s，RegType：标志，RegSize：4，RegID：0，RegCount：1。</p><p> You can see that in the  FLAGS access section,  CF: 1 is listed, meaning that it is always set to  1. Other possible values for flags include  m, which means that the flag is modified according to the result,  0, which means that the flag is cleared,  t which means the flag is tested, and  u, which means the flag is undefined. Flags which are missing from the  FLAGS access section are not touched at all.</p><p>您可以看到，在标志访问部分中列出了CF：1，这意味着它始终设置为1。标志的其他可能值包括m(表示根据结果修改标志)、0(表示标志已清除)、t(表示标志已测试)和u(表示标志未定义)。标志访问部分中缺失的标志根本不会被触及。</p><p>  Finally, let’s discuss some not-so-well-known cases when dealing with instruction encodings. Of course, all of them are documented, but finding this information in the SDM can take some time, so here is a quick list of the most relevant ones:</p><p>最后，让我们讨论一下在处理指令编码时一些不太为人所知的情况。当然，所有这些信息都有文档记录，但在SDM中查找这些信息可能需要一些时间，因此以下是最相关信息的快速列表：</p><p> It is possible to encode seemingly valid instructions which are longer than the maximum limit of 15 bytes, but the CPU would generate #GP on them anyway;</p><p>可以对看似有效的指令进行编码，这些指令的长度超过15字节的最大限制，但CPU无论如何都会在这些指令上生成#GP；</p><p>  The REX prefix must always be the last byte before the opcode bytes, otherwise it’s ignored:  48F333C0 will decode to  xor eax, eax, NOT  xor rax, rax, because  F3 prefix comes after the REX  48 prefix;</p><p>REX前缀必须始终是操作码字节之前的最后一个字节，否则将被忽略：48F333C0将解码为XOR eax，eax，而不是XOR rax，rax，因为F3前缀在REX 48前缀之后；</p><p>  If both  F2 and  F3 prefixes are present in an instruction, the CPU will consider the last occurring prefix:  F2F2F2F3A6 will decode to  repz cmpsb, since  F3 is the last occurring prefix, and all of the  F2 prefixes will be ignored ;</p><p>如果指令中同时存在F2和F3前缀，则CPU将考虑最后出现的前缀：F2F2F2F3A6将解码为REPZ cmpsb，因为F3是最后出现的前缀，并且所有的F2前缀都将被忽略；</p><p>  Likewise, the last occurring segment prefix is considered, but note that in 64 bit mode, only  fs and  gs overrides are accepted:  65642e2e3300 will decode to  xor eax, dword ptr cs:[eax] in 32 bit mode, but it will decode to  xor eax, dword ptr fs:[rax] in 64 bit mode;</p><p>同样，考虑最后出现的段前缀，但请注意，在64位模式下，只接受fs和gs覆盖：65642e2e3300将在32位模式下解码为XOR eax，dword PTR cs：[EAX]，但在64位模式下，它将解码为xor eax，dword PTR fs：[rax]；</p><p>  Ignored and redundant prefixes are part of the instruction, so they are counted to the instruction length:  F2F2F2F2F2F2F2F2F2F2F2F2F2F290 is decoded &amp; executed as a  NOP, but adding one more  F2 prefix will make the instruction 16 bytes long, thus generating a #GP, and causing a decode error;</p><p>被忽略和冗余的前缀是指令的一部分，因此它们被计入指令长度：F2F2F2F2F2F2F2F2F2F2F2F2F2F290作为NOP被解码和执行，但是再增加一个F2前缀将使指令16字节长，从而产生#GP，并导致解码错误；</p><p>  RSP cannot be used as an index with SIB addressing, and it will be ignored:  3304E0 will decode to  xor eax, dword ptr [rax] instead of  xor eax, dword ptr [rax+rsp*8];</p><p>RSP不能用作SIB寻址的索引，它将被忽略：3304E0将解码为XOR eax，dword PTR[rax]而不是xor eax，dword ptr[rax+rsp*8]；</p><p>  When using  modrm.mod == 0 (memory) and  modrm.rm == 5 (rbp) in 64 bit mode, RIP relative addressing is used instead of direct addressing; however, by using SIB addressing with  modrm.mod == 0 (memory),  modrm.rm == 4 (rsp, SIB),  SIB.base == 5 (rbp), and  SIB.index == 4 (rsp), one ca still do direct addressing to an absolute 32 bit address even in 64 bit mode:  33042544444444 will decode to  xor eax, dword ptr [0x44444444];</p><p>在64位模式下使用modrm.mod==0(内存)和modrm.rm==5(RBP)时，将使用RIP相对寻址而不是直接寻址；但是，通过使用带有modrm.mod==0(内存)、modrm.rm==4(RSP、SIB)、SIB.base==5(RBP)和SIB.index==4(RSP)的SIB寻址，即使使用SIB寻址，也可以直接寻址到绝对32位地址。</p><p>  In 64 bit mode, stack operations use 64 bit operands by default (even without REX.W prefix); however, this means that encoding a PUSH/POP with a 32 bit operand is impossible, although you can still encode PUSH/POP with 16 bit operands:  6650 will decode to  push ax even in 64 bit mode, with no way to encode  push eax;</p><p>在64位模式下，堆栈操作默认使用64位操作数(即使没有REX.W前缀)；然而，这意味着使用32位操作数编码PUSH/POP是不可能的，尽管您仍然可以使用16位操作数编码PUSH/POP：6650即使在64位模式下也将解码为PUSH AX，无法编码PUSH EAX；</p><p>  In 64 bit mode, on Intel CPUs, indirect branches always use 64 bit operands:  FF20,  48FF20,  66FF20 will all decode to  jmp qword ptr [rax] in 64 bit mode;</p><p>在64位模式下，在Intel CPU上，间接分支总是使用64位操作数：FF20、48FF20、66FF20都将在64位模式下解码为JMP qword PTR[rax]；</p><p>  Moves to/from control/debug registers will always use modrm.mod == 3, even if the actual modrm.mod is 0, 1 or 2:  0F2000 will decode to  mov rax, cr0, not  mov [rax], cr0;</p><p>移入/移出控制/调试寄存器将始终使用modrm.mod==3，即使实际modrm.mod为0、1或2：0F2000将解码为mov rax，CR0，而不是mov[rax]，cr0；</p><p>  Moves to/from control/debug registers with modrm.mod == 1 or modrm.mod == 2 (with displacement), will ignore the displacement:  0F2040 will decode to  mov rax, cr0, even if normally modrm.mod == 1 would require a 1 byte displacement;</p><p>移入/移出modrm.mod==1或modrm.mod==2的控制/调试寄存器(带位移)，将忽略位移：0F2040将解码为mov rax，CR0，即使正常情况下modrm.mod==1需要1个字节的位移；</p><p>  On AMD, one can use the  LOCK prefix  F0 with  mov cr instruction to access the cr8 registers:  F00F22C0 decodes to  mov cr8, eax;</p><p>在AMD上，可以使用带mov cr指令的锁定前缀F0来访问cr8寄存器：F00F22C0解码为mov cr8，eax；</p><p>  We presented in this blog-post how a comprehensive, well written instruction decoder can greatly improve the life of a developer when working with instructions. Surely, bddisasm is a very important part of HVMI, as much of the introspection logic revolves around analyzing instructions, and having the option of doing this with a simple, fast and accurate decoder greately improves code quality.</p><p>在这篇博客文章中，我们展示了一个全面的、编写良好的指令解码器如何在处理指令时极大地改善开发人员的生活。当然，bddisasm是HVMI的一个非常重要的部分，因为很多自省逻辑都围绕着分析指令，并且可以选择使用简单、快速和准确的解码器来实现这一点，从而极大地提高了代码质量。</p><p> We will see in a future blog-post how bddisasm can also help create simple instruction emulators, when we will dig into another important project - the Bitdefender Shellcode Emulator - bdshemu.</p><p>我们将在未来的一篇博客文章中看到bddisasm如何帮助创建简单的指令模拟器，届时我们将深入研究另一个重要的项目-BitDefender Shellcode Emulator-bdshemu。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hvmi.github.io/blog/2020/11/04/bddisasm.html">https://hvmi.github.io/blog/2020/11/04/bddisasm.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033174.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b1db87a8aa18f25398c18443eb064347.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033174.html">异步/等待在编程中的优势</a></div><span class="my_story_list_date">2020-11-4 22:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033004.html"><img src="http://img2.diglog.com/img/2020/11/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033004.html">使用Haskell以本机速度编程R</a></div><span class="my_story_list_date">2020-11-4 1:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032935.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032935.html">大流行将如何影响软件编程工作？</a></div><span class="my_story_list_date">2020-11-3 15:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032918.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0cc89c062fa51d7ddb60a4c7ab23abb9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032918.html">信号量(编程)</a></div><span class="my_story_list_date">2020-11-3 13:55</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>