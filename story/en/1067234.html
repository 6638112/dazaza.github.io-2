<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>自动发布您的构建工件 Automatically publishing your build artifacts</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Automatically publishing your build artifacts<br/>自动发布您的构建工件 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-22 00:49:35</div><div class="page_narrow text-break page_content"><p>The idea: whenever your CI builds the code from your main branch, do not ditch the build results: publish them instead. This makes it easy to provide QA engineers or bug reporters with new builds to try.</p><p>这个想法：只要你的CI从主分支构建代码，请不要抛弃构建结果：改为发布。这使得QA工程师或错误记者提供新的构建来易于尝试。</p><p>  I first experienced this setup at work, where we use Jenkins. Jenkins is  not my preferred CI system, but to its credit, it makes it super easy to implement this feature: add a step to archive artifacts, either using the GUI or using the  archiveArtifacts pipeline command.</p><p>  我第一次在工作中经历了这个设置，我们使用Jenkins。 Jenkins不是我首选的CI系统，而是为了获得信用，它使其超级易于实现此功能：添加步骤来归档工件，或者使用ArchiveARtifacts Pipeline命令。</p><p> We actually do this for all builds at work, not only master branch builds. It makes the life of our QA engineers much easier. Our workflow looks like this:</p><p> 我们实际上为所有在工作中的构建执行此操作，不仅是主分支构建。它使我们的QA工程师的生活更容易。我们的工作流程如下所示：</p><p> when developers consider it ready to QA, QA engineers download the artifacts produced by the PR build and use them to validate the work.</p><p> 当开发人员考虑它准备QA时，QA工程师下载PR构建生成的工件并使用它们来验证工作。</p><p>  I thought it would be a good idea to setup something similar for my own projects, which are hosted on GitHub and use GitHub CI.</p><p>  我认为将类似于我自己的项目的东西是一个很好的想法，这些项目在Github上托管并使用Gi​​tHub CI。</p><p> I expected a feature like this to be readily available, but I could not find exactly what I wanted. GitHub provides a way to download artifacts from a build but it&#39;s not ideal:</p><p> 我预计这样的功能可以随时可用，但我找不到我想要的东西。 GitHub提供了一种从建筑物中下载文物的方法，但它并不理想：</p><p> Artifacts are all bundled together in a big zip, which is inconvenient when building multi-platform apps: no-one wants to download a single archive containing the same application for macOS, Windows and Linux.</p><p> 伪像在一个大的zip中捆绑在一起，在构建多平台应用时，这是不方便的：没有人想要下载一个包含相同应用程序的acos，windows和linux应用程序。 </p><p> Some projects use tags to produce main branch builds, but I don&#39;t like this idea. Call me a purist, but using tags that way feels like subverting the concept to compensate for a missing GitHub feature.</p><p>一些项目使用标签来生产主分支构建，但我不喜欢这个想法。叫我一个纯票，但是使用标签，这种方式感觉像对概念来补偿丢失的github功能。</p><p> Since I host my blog on a VPS, what I ended up doing is setting up a subdomain for builds on the VPS ( builds.agateau.com) and making GitHub upload artifacts to my server over SSH.</p><p> 由于我托管vps上的博客，我最终做了什么正在vps上建立一个子域（builds.agateau.com），并将github上传到我的服务器上的ssh。</p><p>  The first thing I set up was the HTTP server to serve the files. After adding the subdomain on my registrar, I created a directory on my VPS and configured Nginx so that users visiting &#34;builds.agateau.com&#34; would be able to browse and download the content of this directory, using the  Nginx Fancy Index module.</p><p>  我设置的第一件事是HTTP服务器提供文件。在我的注册商上添加子域后，我在我的vps上创建了一个目录，并配置了nginx，以便访问＆＃34; builds.agateau.com＆＃34;可以使用nginx花式索引模块浏览和下载此目录的内容。</p><p>   I then created a  build user on the VPS, created one directory per project in  /srv/builds.agateau.com/html and made the  build user the owner of these directories so that it can write to them.</p><p>   然后我在vps上创建了一个构建用户，在/srv/builds.agateau.com/html中创建了一个目录，并使构建用户成为这些目录的所有者，以便它可以写入它们。</p><p> Finally I created an SSH key for this user, so that the GitHub builder can connect to it.</p><p> 最后，我为此用户创建了一个SSH键，以便GitHub Builder可以连接到它。</p><p>  I looked into existing GitHub actions for SSH uploads but it all felt overkill for just an  scp call. Instead I decided to keep it simple: my build is going to call a shell script to do the upload. I prefer keeping dependencies with the CI to a minimum anyway, it makes it easier to test build scripts locally instead of using the commit-push-and-pray &#34;workflow&#34;.</p><p>  我研究了SSH上传的现有GitHub操作，但它只对SCP呼叫感到过度矫枉过正。相反，我决定保持简单：我的构建将调用shell脚本来进行上传。无论如何，我更喜欢将依赖关系保持在最小，这使得在本地测试构建脚本，而不是使用Commit-Push-and-and-34;工作流程＆＃34;</p><p>  #!/bin/bash set -euo pipefail PROGNAME = $(basename  $0 )die ()  {  echo  &#34; $PROGNAME :  $* &#34; &gt; &amp; 2  exit  1 } # Check $1 is defined and not emptycheck_var ()  {  local  name = $1  if ! env  | grep -q  &#34;^ $name =..*&#34;  ;  then die  &#34;Environment variable  $name  is not set or is empty&#34;  fi }usage ()  {  if  [  &#34; $* &#34; ! =  &#34;&#34;  ]  ;  then  echo  &#34;Error:  $* &#34;  echo  fi cat  &lt;&lt; EOF Usage: $PROGNAME [OPTION ...] &lt;project&gt; &lt;build_file&gt; [build_file...] Uploads build artifacts to a server using scp. Files are upload to builds/&lt;project&gt;/. Expects the following environment variables to be set: - UPLOAD_USERNAME - UPLOAD_PRIVATE_KEY - UPLOAD_HOSTNAME Options:  -h, --help display this usage message and exit EOF  exit  1 } project = &#34;&#34; build_files = &#34;&#34; while  [  $# -gt  0  ]  ;  do  case  &#34; $1 &#34; in -h |--help ) usage  ;; -* ) usage  &#34;Unknown option &#39; $1 &#39;&#34;  ;; * )  if  [ -z  &#34; $project &#34;  ]  ;  then  project = &#34; $1 &#34;  else  build_files = &#34; $build_files   $1 &#34;  fi  ;;  esac  shift done if  [ -z  &#34; $build_files &#34;  ]  ;  then usage  &#34;Not enough arguments&#34; ficheck_var UPLOAD_USERNAMEcheck_var UPLOAD_PRIVATE_KEYcheck_var UPLOAD_HOSTNAME echo  &#34;Uploading&#34; eval  $(ssh-agent ) echo  &#34; $UPLOAD_PRIVATE_KEY &#34;  | ssh-add -scp -o  &#34;StrictHostKeyChecking off&#34;  $build_files  &#34; $UPLOAD_USERNAME @ $UPLOAD_HOSTNAME :builds/ $project /&#34;</p><p>  ＃！/ bin / bash set -euo pipefail progname = $（basename $ 0）die（）{echo＆＃34; $ progname：$ *＆＃34; ＆gt; ＆amp; 2出口1}＃检查$ 1是定义的，而不是emptycheck_var（）{local name = $ 1如果！ env | Grep -Q＆＃34; ^ $名称= .. *＆＃34; ;然后死亡＆＃34;环境变量$名称未设置或为空＆＃34; fi}用法（）{如果[＆＃34; $ *＆＃34; ！！ =＆＃34;＆＃34; ];然后回声＆＃34;错误：$ *＆＃34;回声FI猫＆lt;＆lt; EOF使用率：$ progname [选项...]＆lt; project＆gt; ＆lt; build_file＆gt; [build_file ...]上载使用scp构建一个器件到服务器。文件是上载到构建/＆lt; project＆gt; /。期望设置以下环境变量： -  Upload_Username  -  Upload_Private_Key  -  Upload_Hostname选项：-h，--help显示此用法消息和退出EOF Exit 1} Project =＆＃34;＆＃34;＆＃34; build_files =＆＃34;＆＃34;虽然[$＃-gt 0];案例＆＃34; 1美元＆＃34;在-h |  -  help）使用; -  *）使用＆＃34;未知选项＆＃39; $ 1＆＃39;＆＃34; ;; *）如果[-Z＆＃34; $项目＆＃34; ];然后项目=＆＃34; 1美元＆＃34; else build_files =＆＃34; $ build_files $ 1＆＃34; fi ;;如果[-z＆＃34; $ build_files＆＃34; ];然后用法＆＃34;没有足够的争论＆＃34; ficheck_var upload_usernamecheck_var upload_private_keycheck_var upload_hostname echo＆＃34;上传＆＃34; eval $（SSH-代理）回声＆＃34; $ upload_private_key＆＃34; | ssh-add -scp -o＆＃34; stricthostkeychecking＆＃34; $ build_files＆＃34; $ upload_username @ $ upload_hostname：builds / $ project /＆＃34; </p><p> Admittedly, it&#39;s a bit long for a simple  scp call, but that&#39;s because I prefer adding at least a minimum amount of doc, argument parsing and error handling to such scripts. I find that it helps when revisiting them 6 months later (I wrote about my  shell script template some time ago if you are interested).</p><p>不可否认，它＆＃39;对于简单的SCP呼叫有点久，但是，它是因为我更喜欢至少添加至少一定量的doc，参数解析和处理到此类脚本。我发现它有助于在6个月后重新审视它们时（我前段时间在我的shell脚本模板中写道，如果您有兴趣）。</p><p> This script takes the name of the project, which matches the directory created on the server for it, and the files to upload. Sensitive information (username, host name and private key) is provided through environment variables.</p><p> 此脚本获取项目的名称，该项目与服务器上创建的目录匹配，以及上传文件。通过环境变量提供敏感信息（用户名，主机名和私钥）。</p><p> Note: I had to disable host-key checking (the  -o &#34;StrictHostKeyChecking off&#34; option in the  scp call) because I could not figure out how to pass the host key as an argument or environment variable. I believe in that case it won&#39;t be too bad, the worse that could happen is someone managing to steal the account public key and uploading builds to their server instead of mine. Still I&#39;d prefer to be able to pass the host key. If you know how to do this, I would love to hear from you!</p><p> 注意：我不得不禁用主机键检查（-o＆＃34; stricthostkeychecking＆＃34; scp调用中的选项），因为我无法弄清楚如何将主机键作为参数或环境变量传递。我相信这种情况，它赢得了＆＃39; t太糟糕了，可能发生的情况是，有人管理窃取帐户公钥并上传到他们的服务器而不是我的服务器。仍然是我喜欢能够通过主机键。如果你知道如何做到这一点，我很乐意收到你的来信！</p><p>  I connected to the project GitHub admin page and declared the username, host name and private keys as  GitHub encrypted secrets.</p><p>  我连接到项目github管理页面，并将用户名，主机名和私钥声明为github加密的秘密。</p><p> Now all that was left to do was to call the  upload-build script from the GitHub build workflow.</p><p> 现在所做的一切都是从Github构建工作流程调用上传构建脚本。</p><p> Here is  Git Bonsai build workflow, showing how to call  upload-build after each push to the master branch.</p><p> 以下是Git Bonsai构建工作流程，显示如何在每个推送到主分支后调用上传 - 构建。</p><p> name :  Build on :  [ push ,  pull_request ] jobs :  build :  strategy :  fail-fast :  false  matrix :  os :  -  ubuntu-18.04  -  macos-10.15  -  windows-2019  runs-on :  ${{ matrix.os }}  defaults :  run :  shell :  bash  steps :  -  uses :  actions/ [email protected]  -  name :  Build  run :  ci/build-app  -  name :  Run static checks  run :  ci/run-static-checks  -  name :  Run tests  run :  ci/run-tests  -  name :  Create archive  run :  ci/create-archive  -  name :  Upload  if :  github.ref == &#39;refs/heads/master&#39;  run :  ci/upload-build git-bonsai artifacts/*.bz2  env :  UPLOAD_USERNAME :  ${{ secrets.UPLOAD_USERNAME }}  UPLOAD_PRIVATE_KEY :  ${{ secrets.UPLOAD_PRIVATE_KEY }}  UPLOAD_HOSTNAME :  ${{ secrets.UPLOAD_HOSTNAME }}</p><p> 名称：版本：[推，pull_request]作业：构建：策略：Fail-Fast：False Matrix：OS： -  Ubuntu-18.04  -  MacOS-10.15  -  Windows-2019 runs-on：$ {{romix.oS}}默认值：shell：bash步骤： - 用途：操作/ [电子邮件保护]  - 名称：build运行：ci / build-app  - 名称：运行静态检查运行：ci / run-static-checks  -  name：运行测试运行： CI / Run-Tests  - 名称：Create Archive Run：CI / Create-Archive  - 名称：上传IF：GitHub.ref ==＆＃39; refs / heads / master＆＃39;运行：CI / Upload-Build Git-Bonsai Artifacts / *。BZ2 ENV：Upload_Username：$ {{secrets.upload_eusername}} upload_private_key：$ {{secrets.upload_private_key}} upload_hostname：$ {{secrets.upload_hostname}} </p><p>  One last thing was required on the server side: to ensure the server disk does not get filled with builds and the build list page does not become too long to load, I added a cleanup script to keep only the latest 30 builds for each project. This script runs every day.</p><p>服务器端需要最后一件事：为确保服务器磁盘没有充满构建，并且构建列表页面不会变得太长，我添加了一个清理脚本，以保持每个项目的最新30个构建。此脚本每天都运行。</p><p> Here it is, once again it&#39;s a bit longer than what one would expect because of argument parsing:</p><p> 在这里，它再次它＆＃39;因为参数解析而比人们所期望的时间长一点：</p><p> #!/bin/bash set -euo pipefail PROGNAME = $(basename  $0 ) ROOT_DIR =/srv/builds.agateau.com/html MAX_BUILDS = 30 # Verbose command by default CMD = &#34;rm -v&#34; QUIET_CMD = &#34;rm&#34; DRY_RUN_CMD = &#34;echo Would delete &#34;clean_project_dir ()  {  local  project_dir = &#34; $1 &#34; ls --sort  time --reverse  &#34; $project_dir &#34;  \  | awk  &#39;NR &gt; &#39; $MAX_BUILDS &#39; { print $1 }&#39;  \  |  while  read name  do  $CMD  &#34; $project_dir / $name &#34;  done }usage ()  {  if  [  &#34; $* &#34; ! =  &#34;&#34;  ]  ;  then  echo  &#34;Error:  $* &#34;  echo  fi cat  &lt;&lt; EOF Usage: $PROGNAME [OPTION ...] Delete old builds artifacts. Options: -h, --help display this usage message and exit -q, --quiet work silently --dry-run print what would be deleted instead of deleting anything EOF  exit  1 } while  [  $# -gt  0  ]  ;  do  case  &#34; $1 &#34; in -h |--help ) usage  ;; -q |--quiet )  CMD = &#34; $QUIET_CMD &#34;  shift  ;; --dry-run )  CMD = &#34; $DRY_RUN_CMD &#34;  shift  ;; -* ) usage  &#34;Unknown option &#39; $1 &#39;&#34;  ;; * ) usage  &#34;Too many arguments&#34;  ;;  esac done for project_dir in  $ROOT_DIR/*/  ;  do clean_project_dir  &#34; $project_dir &#34; done</p><p> ＃！/ bin / bash set -euo pipefail progname = $（basename $ 0）root_dir = / srv / builds.agateau.com / html max_builds = 30＃verbose命令默认cmd =＆＃34; rm -v＆＃34; quiet_cmd =＆＃34; rm＆＃34; dry_run_cmd =＆＃34;回声将删除＆＃34; clean_project_dir（）{local project_dir =＆＃34; 1美元＆＃34; ls  -  ssort time --reverse＆＃34; $ project_dir＆＃34; \ | awk＆＃39; nr＆gt; ＆＃39; $ max_builds＆＃39; {打印$ 1}＆＃39; \ |虽然读名称为$ cmd＆＃34; $ project_dir / $ name＆＃34;完成}用法（）{如果[＆＃34; $ *＆＃34; ！！ =＆＃34;＆＃34; ];然后回声＆＃34;错误：$ *＆＃34;回声FI猫＆lt;＆lt; EOF使用率：$ progname [选项...]删除旧构建工件。选项：-h，--help显示此用法消息和退出-q，--quiet工作静默 - 运行打印将被删除，而不是删除任何EOF退出1}而[$＃-gt 0];案例＆＃34; 1美元＆＃34;在-h |  -  help）使用; -q | --quiet）cmd =＆＃34; $ quiet_cmd＆＃34;转移  ;; - 运行）cmd =＆＃34; $ dry_run_cmd＆＃34;转移  ;; -  *）使用＆＃34;未知选项＆＃39; $ 1＆＃39;＆＃34; ;; *）使用＆＃34;太多争论＆＃34; ;;在$ root_dir / * /中为project_dir完成esac; do clean_project_dir＆＃34; $ project_dir＆＃34;完毕</p><p>  To make the builds site look a bit nicer, I configured the Fancy Index module to use the  Flat theme. I also made it list builds in descending date order, so that the latest builds are always at the top of the page.</p><p>  要使构建网站看起来有点漂亮，我配置了花式索引模块来使用平面主题。我还在降序订单中制作了它列表构建，以便最新版本始终位于页面的顶部。</p><p> That&#39;s it, you can have a look at it here:  https://builds.agateau.com/. There are only two projects for now, I plan to add more in the future.</p><p> 它，你可以看看它：https://builds.agateau.com/。现在只有两个项目，我计划将来增加更多。</p><p>  I am happy I spent some time setting up this artifact upload system as it has proved useful to let bug reporters confirm a fix after they reported an issue. Let me know if this was useful to you, or if you know of simpler solutions to publish build artifacts.</p><p>  我很高兴我花了一些时间设置这个神器上传系统，因为它已经证明了让错误记者在报告问题后确认修复。让我知道这是否对您有用，或者您是否知道发布构建工件的更简单的解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://agateau.com/2021/automatically-publishing-your-build-artifacts/">https://agateau.com/2021/automatically-publishing-your-build-artifacts/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>