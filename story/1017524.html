<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Rust的单页应用程序</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Rust的单页应用程序</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-11 23:01:54</div><div class="page_narrow text-break page_content"><p>WebAssembly(Wasm)允许用JavaScript以外的语言编写的代码在浏览器上运行。如果你没有注意到，所有主流浏览器都支持wasm，全球超过90%的用户都有可以运行wasm的浏览器。</p><p>由于Rust编译为wasm，是否有可能完全用Rust构建SPA(单页应用程序)，而无需编写任何JavaScript行？简短的回答是肯定的！请继续阅读了解更多信息，如果您无法抑制您的兴奋，请访问演示站点！</p><p>我们将建立一个简单的电子商务网站，名为“RustMart”，将有2个页面：</p><p>我使用此示例测试构建现代SPA所需的最小功能集：</p><p>$Cargo安装wasm-pack#将Rust编译为Wasm并生成JS互操作代码$Cargo Install Cargo-make#Task Runner$Cargo Install Simple-http-SERVER#SIMPLE SERVER为资产提供服务。</p><p>我们将使用Yew库来构建UI组件。让我们将此依赖项和wasm依赖项添加到Cargo.toml：</p><p>[tasks.build]command=&#34；wasm-pack&#34；args=[&#34；build&#34；，&#34；--dev&#34；，&#34；--target&#34；，&#34；web&#34；，&#34；--out-name&#34；，&#34；wasm&#34；，&#34；--out-dir&#34；，&#34；/static&#34；]Watch={Ignore_Pattern=&#34；static/*&#34；}[tasks.serve]command=&#34；Simple-http-server&#34；args=[&#34；-i&#34；，&#34；，&#34；-p&#34；，&#34；3000&#34；，&#34；--nocache&#34；，&#34；--try-file&#34；，&#34。./static/index.html&#34；]。</p><p>如果你是Rust的新手，我为初学者写了一些指南，它们会帮助你更好地阅读这篇文章。</p><p>//src/lib.rs将wasm_bindgen：：prelude：：*；use yew：：prelude：：*；struct Hello{}Impl组件用于Hello{type message=()；type Properties=()；fn create(_：self：：properties，_：ComponentLink&lt；self&gt；)-&gt；self{self{}}fn update(&amp；MUT Self，_：Self：：Message)-&gt；ShouldRender{true}FN Change(&amp；MUT Self，_：Self：：Properties)-&gt；ShouldRender{true}FN视图(&amp；Self)-&gt；HTML{html！{&lt；span&gt；{&#34；Hello World！&#34；}&lt；/span&gt；}pub fn run_app(){App：：&lt；Hello&gt；：：new()。Mount_to_body()；}。</p><p>发生了很多事情，但是您可以看到，我们正在创建一个名为“Hello”的新组件，该组件将&lt；span&gt；Hello World！/span&gt；呈现到DOM中。稍后我们将了解更多有关紫杉组件的信息。</p><p>它起作用了！！这只是“hello world”，但这是用铁锈写的。</p><p>通过组合组件并以单向方式传递数据来构建UI是前端世界中的一种范式转变。这是我们对UI推理方式的一个巨大改进，一旦您习惯了这一点，就很难回到命令式DOM操作上来。</p><p>收听生命周期事件，如“实例化”、“挂载在DOM中”等。</p><p>因此，我们不是在用户交互、网络请求等发生时强制更新UI，而是更新数据(Props、State、AppState)，并基于此数据更新UI。当有人说“UI是状态的函数”时，这就是他们的意思。</p><p>确切的细节在不同的库中有所不同，但这应该会让您大致了解。如果您是新手，这种思维方式可能需要一段时间才能“点击”并习惯。</p><p>让我们先建立主页。我们将把主页构建为一个整体组件，然后将其分解成更小的可重用组件。</p><p>//src/ages/home.rs将yew：：prelude：：*；pub struct Home{}Impl组件用于Home{type message=()；type properties=()；fn create(_：self：：properties，_：ComponentLink&lt；self&gt；)-&gt；self{self{}}fn update(&amp；mut self，_：self：：message)-&gt；ShouldRender{true}FN Change(&amp；mut Self，_：Self：：Properties)-&gt；ShouldRender{true}FN视图(&amp；Self)-&gt；HTML{html！{&lt；span&gt；{&#34；Home Sweet Home！&#34；}&lt；/span&gt；}。</p><p>//src/lib.rs+mod页面；+使用页面：：home；使用wasm_bindgen：：prelude：：*；使用yew：：prelude：：*；-struct Hello{}-Iml组件for Hello{-type message=()；-type Properties=()；-fn create(_：self：：properties，_：ComponentLink&lt；self&gt；)-&gt；self{-self{}-}-fn。ShouldRender{-true-}-FN Change(&amp；mut self，_：self：：properties)-&gt；ShouldRender{-true-}-FN视图(&amp；self)-&gt；HTML{-html！{&lt；span&gt；{&#34；Hello World！&#34；}&lt；/span&gt；}-}-}#[wasm_bindgen(Start)]pub FN run_。Hello&gt；：：New().mount_to_body()；+App：：&lt；Home&gt；：：new().mount_to_body()；}。</p><p>现在，你应该看到“家，甜蜜的家！”而不是“你好，世界！”在您的浏览器中呈现。</p><p>然后，我们使用名为Products的字段创建一个新的struct State，以保存来自服务器的产品：</p><p>使用yew：：prelude：：*；+struct Product{+id：I32，+name：string，+description：string，+image：string，+Price：f64，+}+struct State{+products：VEC&lt；Product&gt；，+}-pub struct Home{}+pub struct Home{+state：state，+}Iml Component for Home{type message=()；type Properties=()；FN Create(_：self：：properties，_。Product&gt；=vec！[+Product{+id：1，+name：&#34；Apple&#34；.to_string()，+Description：&#34；.to_string()，+image：&#34；/products/apple.png&#34；.to_string()，+product：3.65，+}，+Product{+id：2，+name：&#34；香蕉&#34；.to_string()，+描述：&#34；一片老香蕉叶曾经是嫩绿的&#34；.to_string()，+image：&#34；/products/banana.png&#34；.to_string()，+Price：7.99，+}，+]；-self{}+self{+state：state{+products，+}，+}}FN更新(&amp；mut self，_：self：：message)-&gt；应该。MUT Self，_：Self：：properties)-&gt；ShouldRender{true}FN视图(&amp；Self)-&gt；HTML{+let Products：VEC&lt；HTML&gt；=Self+.State+.products+.iter()+.map(|product：&amp；Product|{+html！{+&lt；div&gt；+&lt；img src={&amp；Product.image}/&gt；Div&gt；{&#34；$&#34；}{&amp；product.price}&lt；/div&gt；+&lt；/div&&gt;；+}+})+.Collect()；++html！{&lt；span&gt；{Products}&lt；/span&gt；}-html！{&lt；span&gt；{&#34；主页！}&lt；/span&gt；}。</p><p>创建组件时会调用创建生命周期方法，这是我们设置初始状态的位置。目前，我们已经创建了一个产品模拟列表，并将其作为初始值分配给该州内的产品。稍后，我们将使用网络请求获取此列表。</p><p>视图生命周期方法在呈现组件时调用。在这里，我们迭代了州内的产品以生成产品卡。如果您熟悉Reaction，这与Render方法和html是一样的！宏类似于JSX。</p><p>将一些随机图像保存为static/products/apple.png和static/products/banana.png，您将获得此UI：</p><p>我们在一个名为Cart_Products的新状态字段中跟踪添加到购物车中的所有产品。</p><p>添加逻辑以在单击“add to cart”按钮时更新CART_PRODUCTS状态。</p><p>使用yew：：prelude：：*；+#[派生(克隆)]struct Product{id：I32，Name：String，Description：String，image：String，Price：f64，}+struct CartProduct{+product：product，+Quantity：I32，+}struct State{products：VEC&lt；Product&gt；，+Cart_Products：VEC&lt；CartProduct&gt；，}pub struct Home{state：state，+link：，}+pub enum MSG{+AddToCart(I32)，+}家庭实施组件{-type Message=()；+type Message=MSg；type Properties=()；-FN Create(_：Self：：Properties，_：ComponentLink&lt；Self&gt；)-&gt；Self{+FN Create(_：Self：：Properties，Link：ComponentLink&lt；Self&gt；)-&gt；Self{let Products。Apple&#34；.to_string()，描述：&#34；一天一个苹果远离医生&#34；.to_string()，image：&#34；/products/apple.png&#34；.to_string()，价格：3.65，}，产品{id：2，名称：&#34；香蕉&#34；.to_string()，描述：&#34；.to_string()，/products/banana.png&#34；.to_string()，价格：7.99，}，]；+let cart_products=vec！[]；self{state：state{products，+cart_products，}，+link，}}-fn update(&amp；mut self，_：self：：message)-&gt；ShouldRender{+fn update(&amp；mut self，message：self：：message)-&gt；ShouldRender。{+let product=self+.state+.products+.iter()+.find(|p：&amp；&amp；Product|p.id==product_id)+.unwire()；+let cart_product=self+.state+.cart_products+.iter_mut()+.find(|cp：&amp；&amp；mut CartProduct|cp.duct.id==product_id)；++if let(Cp)=cart_product{+。+}Else{+self.state.cart_Products.ush(CartProduct{+product：Product.clone()，+Quantity：1，+})+}+true+}+}-true}fn change(&amp；mut self，_：self：：properties)-&gt；ShouldRender{true}fn视图(&amp；self)-&gt；HTML{let products：VEC&lt；HTML&gt；=self.State.products.iter(。Html！{&lt；div&&gt;；&lt；img源={&amp；Product.image}/&gt；&lt；div&gt；{&amp；Product.name}&lt；/div&gt；&lt；div&gt；{&#34；$&#34；}{&amp；product.price}&lt；/div&gt；+&lt；按钮onClick=self.link.callback(Move|_|msg：：AddToCart(Product_Id))&gt；{&#34；添加到购物车&#34；}&lt；/button&gt；&lt；/div&gt；}}).Collect()；+let cart_value=self+.state+.cart_products+.iter()+.fold(0.0，|acc，cp|acc+(cp.Quantity as f64*cp.products t.price))；-html！{&lt；span&gt；{products}&lt；/span&gt；}+html！{+&lt；{format！(&#34；Cart Value：{：.2}&#34；，Cart_Value)}&lt；/span&gt；+&lt；span&gt；{products}&lt；/span&gt；+&lt；/div&gt；+}。</p><p>克隆-我们在Product struct中派生了Clone特征，因此每当用户将克隆的Product添加到购物车时，我们都可以将其保存到CartProduct中。</p><p>更新-此方法是更新组件状态或执行副作用(如网络请求)的逻辑所在的位置。它是使用包含组件支持的所有操作的消息枚举调用的。当我们从此方法返回true时，组件将重新呈现。在上面的代码中，当用户单击“add to cart”按钮时，我们将发送一条msg：：AddToCart消息进行更新。在update内部，这要么将产品添加到cart_product(如果它不存在)，要么增加数量。</p><p>链接-这允许我们注册可以触发我们的更新生命周期方法的回调。</p><p>如果你以前使用过Redux，更新类似于Reducer(用于状态更新)和Action Creator(用于副作用)，Message类似于Action，LINK类似于Dispatch。</p><p>以下是UI的外观，尝试单击“添加到购物车”按钮，然后查看“购物车值”中的更改：</p><p>我们将产品数据从CREATE函数移动到static/products/products ts.json，并使用FETCH API进行查询。</p><p>[{&#34；id&#34；：1，&#34；名称&#34；：&#34；苹果&#34；，&#34；说明&#34；：&#34；，&#34；image&#34；：&#34；/products/apple.png&#34；，&#34；价格&#34；：3.65}，{&#34；ID&#34；：2，&#34；名称&#34；：&#34；香蕉&#34；，&#34；描述&#34；：&#34；一片古老的香蕉叶曾经是嫩绿的&#34；，&#34；image&#34；：：&#34；/products/banana.png&#34；，&#34；价格&#34；：：7.99}]。</p><p>Yew通过称为“服务”的东西公开了常见的浏览器API，如FETCH、LOCALSTORAGE等。我们可以使用FetchService发出网络请求。不管怎么说，它需要一些板条箱，我们来安装它们吧：</p><p>[Package]name=&#34；rustmart&#34；version=&#34；0.1.0&#34；Authors=[&#34；sheshbabu&lt；sheshbabu@gmail.com&gt；&#34；]版本=&#34；2018&#34；[lib]crate-type=[&#34；cdylib&#34；，&#34；rlib&#34；][依赖项]yew=&#34；+无论如何=&#34；1.0.32&#34；+serde={版本=&#34；1.0&#34；，功能=[&#34；派生&#34；]}。</p><p>让我们将Product和CartProduct解压缩到src/tyes.rs，以便可以跨多个文件共享它：</p><p>使用serde：：{Desialize，Serialize}；pub struct Product{pub id：I32，pub name：string，pub description：string，pub image：string，pub Price：F64，}pub struct CartProduct{pub product：product，pub Quantity：I32，}。</p><p>我们已经使结构和它们的字段都是公共的，并且已经派生了反序列化和序列化特征。</p><p>我们将使用API模块模式并创建一个名为src/api.rs的单独模块来保存我们的获取逻辑：</p><p>//src/api.rs Use crate：：Types：：Product；Use Anyhow：：Error；Use Yew：：Callback：：Callback；Use Yew：：Format：：{json，Nothing}；Use Yew：：Services：：Fetch：：{FetchService，FetchTask，Request，Response}；pub type FetchResponse&lt；T&gt；=Response&lt；Json&lt；Result&lt；T，Error&。FetchResponse&lt；T&gt；&gt；；pub FN get_products(回调：FetchCallback&lt；Vec&lt；Product&gt；)-&gt；FetchTask{let req=request：：get(&#34；/products/products ts.json&34；)。正文(无)。UnWrap()；FetchService：：Fetch(req，callback)。展开()}。</p><p>FetchService API有点笨拙-它接受一个请求对象和回调作为参数，并返回一个称为“FetchTask”的东西。这里一个令人惊讶的问题是，如果这个“FetchTask”被删除，网络请求就会中止。所以我们返回它并将其存储在我们的组件中。</p><p>//src/lib.rs+mod api；+mod类型；mod页面；使用Pages：：Home；使用wasm_bindgen：：prelude：：*；use yew：：prelude：：*；#[wasm_bindgen(Start)]pub FN run_app(){App：：&lt；Home&gt；：：new().mount_to_body()；}。</p><p>+Use Crate：：API；+Use Crate：：Types：：{CartProduct，Product}；+Use Anyhow：：Error；+Use Yew：：Format：：Json；+Use Yew：：Services：：Fetch：：FetchTask；Use Yew：：Prelude：：*；-#[派生(克隆)]-struct Product{-id：I32，-Name：String，-Description：String，-image：String，-Price：f64，-}-struct CartProduct{-product：product，-Quantity：I32，-}struct State{products：VEC&lt；Product&gt；，Cart_Products：VEC&lt；CartProduct&gt；，+Get_Products_Error：Option&lt；Error&gt；，+Get_Products_Load：Bool，}pub struct Home{state：state，link：ComponentLink&lt；self&&gt;；，+task：option&lt；FetchTask&&gt;，}pub枚举消息{AddToCart(I32)，+GetProducts，+GetProductsSuccess(VEC&lt；Product&gt；)，+GetProductsError(Error)，}Impl Home组件。Product&gt；=vec！[-Product{-id：1，-name：&#34；Apple&#34；.to_string()，-description：&#34；.to_string()，-image：&#34；/products/apple.png&#34；.to_string()，-Price：3.65，-}，-Product{-id：2，-name：&#34；香蕉&#34；.to_string()，-description：&#34；一片老香蕉叶曾经嫩绿&#34；.to_string()，-image：&#34；/products/banana.png&#34；.to_string()，-price：7.99，-}，-]；+let products=vec！[]；let cart_products=vec！[]；+link.send_message(msg：：GetProducts)；Self{state：state{Products，Cart_Products，+Get_Products_Error：NONE，+GET_PRODUCTS_LOADED：FALSE，}，LINK，+TASK：NONE，}}FN UPDATE(&amp；mut Self，Message：Self：：Message)-&gt；ShouldRender{Match Message{+msg：：GetProducts=&gt；{+self.state.get_products_loaded=false；+let Handler=+self.link+.callback(Move|。|{+let(_，json(Data))=response.into_part()；+匹配数据{+OK(Products)=&gt；msg：：GetProductsSuccess(Products)，+err(Err)=&gt；msg：：GetProductsError(Err)，+}+})；+self.task=Some(API：：Get_Products(Handler))；+true+}+msg：：GetProducts。+true+}+msg：：GetProductsError(Error)=&gt；{+self.state.get_products_error=ome(Error)；+self.state.get_products_loaded=true；+true+}msg：：AddToCart(Product_Id)=&gt；{let product=sel.state.products.iter().find(|p：&amp；&amp；Product|p.id==product_id).unwork()；让cart_product=sel.State.cart_products.iter_mut().find(|cp：&amp；&amp；amp；mut CartProduct|cp.duct.id==product_id)；如果让Some(Cp)=cart_product{cp.Quantity+=1；}Else{self.state.cart_Products.ush(CartProduct{product：products t.clone()，Quantity：1，})}fn change(&amp；mut。Self)-&gt；HTML{let products：VEC&lt；HTML&gt；=self.State.products.iter().map(|product：&amp；Product|{let product_id=duct.id；html！{&lt；div&gt；&lt；img src={&amp；products t.image}/&gt；&lt；div&gt；{&amp；products t.name}&lt；/div&gt；&。Products t.price}&lt；/div&gt；&lt；button onclick=self.link.callback(Move|_|msg：：AddToCart(Product_Id))&gt；{&#34；添加到购物车&#34；}&lt；/button&gt；&lt；/div&gt；}).Collect()；let cart_value=sel.state.cart_products.iter().fold(0.0，|。+if！self.state.get_products_loaded{+html！{+&lt；div&gt；{&#34；正在加载...&#34；}&lt；/div&gt；+}+}如果让某些(_)=self.state.get_products_error{+html！{+&lt；div&gt；+&lt；span&lt；{&#34；}&lt；加载产品时出错！+}+}Else{html！{&lt；div&gt；&lt；span&gt；{format！(&#34；cart value：{：.2}&#34；，cart_value)}&lt；/span&&gt;；&lt；&lt；{products}&lt；/span&&gt;；&lt；/div&gt；}+}。</p><p>退出</p><p>在view方法中，我们使用条件呈现来根据组件的状态呈现加载视图、错误视图或产品视图。</p><p>让我们将“产品卡”组件提取到它自己的模块中，这样我们就可以在其他页面中重用它。</p><p>//src/Components/product_card.rs为ProductCard使用crate：：type：：product；use yew：：prelude：：*；pub struct ProductCard{props：props，}pub struct props{pub product：product，pub on_add_to_cart：callback&lt；()&gt；，}为ProductCard实施组件{type message=()；type Properties=props；fn create(props：self：)-&gt；Self{Self{props}}FN更新(&amp；mut Self，_msg：Self：：Message)-&gt；ShouldRender{true}FN更改(&amp；MUT Self，_Props：Self：：Properties)-&gt；ShouldRender{true}FN视图(&amp；Self)-&gt；HTML{let onclick=self.props.on_add_to_cart。REGATE(|_|())；html！{&lt；div&gt；&lt；img src={&amp；sel.props.product.image}/&gt；&lt；div&gt；{&amp；sel.props.product.name}&lt；/div&gt；&lt；div&gt；{&#34；$&34；}{&amp；sel.props.product.price}&lt。&lt；button onclick=onclick&gt；{&#34；添加到购物车&#34；}&lt；/button&gt；&lt；/div&gt；}。</p><p>//src/ages/home.rs Use Crate：：api；+Use Crate：：Components：：ProductCard；Use Crate：：Types：：{CartProduct，Product}；Use Anyhow：：Error；Use Yew：：Format：：Json；Use Yew：：Prelude：：*；Use Yew：：Services：：Fetch：：FetchTask；//不更改主页的IMPL组件{//不更改FN视图(&amp；self)-&。=self.State.products.iter().map(|product：&amp；Product|{let product_id=duct.id；html！{-&lt；div。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/">http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/page/">#page</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1017513.html"><img src="http://img.diglog.com/img/2020/8/thumb_abb89d9c0059c9a8bdb00630b29f1fc9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017513.html">
谷歌针对视障人士的Lookout应用程序现在可以扫描食品标签和长文档</a></div><span class="my_story_list_date">2020-8-11 21:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017483.html"><img src="http://img.diglog.com/img/2020/8/thumb_59d4b2b17bdb5f912190876565e22342.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017483.html">支持WebView/Lorca、WASM和Bazel的Golang桌面应用程序</a></div><span class="my_story_list_date">2020-8-11 15:35</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017479.html"><img src="http://img.diglog.com/img/2020/8/thumb_ba2d047e09528fb8babddfb099886bad.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017479.html">治疗应用程序Talkspace据称对患者与治疗师的对话进行了数据挖掘-内部人士表示，挖掘数据是为了帮助营销，并推动治疗师偏爱企业患者而不是其他人</a></div><span class="my_story_list_date">2020-8-11 14:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017418.html"><img src="http://img.diglog.com/img/2020/8/thumb_6ce8bdf79ebc4af1d4c72e7b3d70e952.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017418.html">
DoubleVerify表示，广告欺诈者正在使用公共领域内容创建假电视应用程序</a></div><span class="my_story_list_date">2020-8-11 4:17</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>