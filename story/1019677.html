<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>F(2006)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">F(2006)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-22 05:30:13</div><div class="page_narrow text-break page_content"><p>F是纯功能连词。最初设计为假的延伸的语言。F包含K3和DIP合并器的列表操作乔伊的名字。支持浮点和符号数据类型。一次性分配是在语法中强制执行的。概述了函数价电荷理论。F还包含一个一般的延续原语$，以及XY的模式子语言。G是F的变体，其中K3副词被实现为原语。</p><p>这种语言是串联的。F个代币是单词，单词表示功能，单词的拼接表示函数的组合。在古典连词中语言，从堆栈到堆栈，一切都是一个函数。在F中，一切都是从三元数开始的函数(环境；堆栈；队列)到三倍(环境；堆栈；队列)。</p><p>这种语言纯粹是功能性的。没有副作用。F有赋值，但没有重新赋值。这意味着您不能使用变量来存储动态状态。F赋值将名称与环境中的值相关联，该环境作为参数传递并作为值返回。F也有用于与运行时环境交互的命令和文件系统，但这些操作在符号上是不同的来自F：&#34；h&34；、&#34；r&34；、&amp；c.它们仅用作调试辅助工具。</p><p>实现了所有的K个动词。一些K动词是实现为基元，有些是在F前奏曲中派生的。例如，K的原子原语@定义为[#int~]；即形状与空整数向量匹配。其中K提供一对函数，其中一个很容易在对于另一种情况，F将其中一个实现为基元，并派生其他的。例如，AND是基元(&amp；)和或都是派生出来的。划分相关对的标准很简单这一点：派生的定义不能是非常低效的与原始人相比，它取代了原始人。</p><p>所有基元都由单个符号表示。虽然支持列表表示法([x y z])，但任何列表都可以在功能上由&#39；(引号)和，(联接)构成。</p><p>原始符号尽可能好记。那里函数到符号的映射有五种方式助记符：</p><p>符号被映射到K中的该函数(例如？Find)或FALSE(例如！用于报价)。</p><p>符号的名称是映射的函数(例如&#39；用于报价)</p><p>一对相关函数(倒数、或近逆)映射到一对相关的符号(例如/和\表示接受和丢弃)。</p><p>在将几个K个基元映射到一个码元的情况下，基元应该形成一个容易记忆的组基于某些共同属性；例如，两者都升级和枚举返回索引，这些索引基于升序关系，因此两者都映射到&lt；。</p><p>解释器的初始状态由一个环境中含有F字的序曲，一句空话结果堆栈和要计算的字符串(字符向量)。对输入字符串进行标记化和解析，以获得初始排队。</p><p>输入队列是K列表，可能包含整数，浮点数、符号、NULL、函数和列表(&#34；引语&#34；)。结果堆栈最初为空。环境是一本K字典。F处理环境，堆栈，并重复排队，直到队列为空。</p><p>如果队列中的第一项是整数、浮点数、NULL原型符号`或列表，则将该项推送到堆叠。</p><p>如果第一个项目是未定义的符号，那么如果它是一个洗牌它已应用；否则，将(在环境中)创建一个变量将堆栈的顶部作为值。</p><p>如果第一项是定义的符号，则其值为(从环境中)检索并推送到堆栈上。</p><p>如果第一项是函数，则将其应用于环境、堆栈和队列以产生新环境，堆栈和队列。</p><p>注意到结果堆栈的域是一个适当的子集输入队列域的。在排队的时候我们可能会发现字符原子(如&#34；r&34；)和字符串(如胡言乱语。但是，当字符原子被执行时，它们就会被执行都会求值，并且没有F基元会生成一个，并且字符串是不处理的注释。</p><p>Trace命令显示以下项的堆栈和队列跟踪列表T中的选定对象：</p><p>F&gt；[fac]&#34；t&#34；F&GT；3面！3♦Face！3 2♦面！*3 2 1♦面！**6个F&GT；F&gt；[fac cond]&#34；t&#34；F&GT；3面！3♦Face！3[1=][][重复！普雷德！FAC！*]♦Cond！3 2♦面！*3 2[1=][][重复！普雷德！FAC！*]♦Cond！*3 2 1♦面！**3 2 1[1=][][重复！普雷德！Fac！*]♦条件！**6个F&GT；F&gt；[]；t&#34；F&GT；3面！6个。</p><p>09*-INT 123-&gt；12309*.09*-浮动123.45-&gt；123.45Az.AZ*name myName-&gt；值或空AZ*-AZ*洗牌10 20 ab-ba-&gt；20 10[..]列表[10+[3 a]]-&gt；[10+[3 a]]+添加1 2+-&gt；3-SUB 2 3--&gt；1*3 4*-&gt；12%div 5.3%-&gt；1.666667^幂2 3^-&gt；8个_3.2层_-&gt；3=等于2 2=-&gt；1&gt；更多4 6&gt；-&gt；0&amp；和/min 4 3&amp；-&gt；3~Match[1 2][1 2]~-&gt；1#Shape[1 2 3]#-&gt；[3]|反转[1 2 3]|-&gt；[3 2 1]@WHERE[0 1 1 0 1]@-&gt；[1 2 4]@Flip[[1 2 3][4 5 6]]@-&gt；[[1 4][2 5][3 6]]/Take 2[1 2 3]/-&gt；[1 2]/RESHAPE[3 2][1 2 3]/-&gt；[[1 2][3 1][2 3]]\DROP 2[1 2 3]\-&gt；[3]\Cut[0 2][1 2 3]\-&gt；[[1 2][3]]\Rotate[1 2 3 4]2\-&gt；[3 4 1 2]？找到[10 20 30]20？-&gt；1？模数2[3 4 5]？-&gt；[1 0 1]；唯一[10 20 10 10 30]；-&gt；[10 20 30]：Group[10 20 10 10 30]：-&gt；[[0 2 3][1][4]]&lt；枚举3&lt；-&gt；[0 1 2]&lt；升级[10 30 20]&lt；-&gt；[0 2 1]。下部1 2[[2 3+]]。3 4-&gt；1 2[5]3 4。索引[[1 2 3][[1 0]。-&gt；[2 1]。Monad[[1 2 3][[1 0]][-1*]]。-&gt；[-1-2 3]。DYAD[[1 2 3][[1 0]]+[3 8]]。-&gt；[9 53]好了！无引号2[3+]！-&gt；5`DIP 2 3 4[+]`-&gt；5 4&#39；报价&#39；+-&gt；[+]，JOIN[1][2 3]，-&gt；[1 2 3]$STATE%1 2 3&#39；\$4 5 6-&gt；4 5 6 1 2 3)s-&gt;；的堆栈-&&gt;堆栈模式(S-&&gt;；Q堆栈-&gt；队列模式}Q-&gt;；的队列-&&gt;堆栈模式{Q-&&gt;；Q队列-&gt；队列模式。</p><p>类型(4：：)对数表达式abs sqr sqrt楼层点多个inv LSq在丹新堂有一件事，就是一件事，一件事。画在林彬的dv dvl di vs sv中。</p><p>NaN分钟(0n)信息最大值(0i)南南(0n)无限大(0i)NULL NULL(_N)Sym原型sym(`)整数空整数向量(！0)浮点空的浮点向量(0#0.)Syms空sym向量(0#`)。</p><p>&#34；..&#34；注释1&#34；跳过&#34；2注释未处理&#34；b&#34；中断&#39；x&#34；b&#34；信号错误(&#39；x)清除1 2；c#34；c#34；3 4清除，加载f，序曲&#34；d&#34；定义了&#39；foo&#34；d&#34；是否定义了foo？&#34；e&#34；错误0&#34；e&#34；设置/取消设置错误陷阱(\e)&#34；f&#34；2个单元！设置F语义，清除&#34；j&#34；Joy&#34；j&#34；2单元集Joy语义，清晰&#34；k&#34；k 1 2&#34；k&#34；3 4出口到K&#34；l&#34；加载&#39；x&#34；l&#34；加载f/x.f|x.j&#34；m&#34；测量[10&lt；]&#34；m&34；测量时间(毫秒)&#34；o&#34；word&#39；map&#34；o&#34；显示单词形式&#34；p&#34；精度3&#34；p&#34；打印精度(\p)&#34；r&#34；读取1 2&#34；r&#34；3 4读取、解析、求值&#34；s&#34；存储y&#39；x&#34；商店f/x.f|x.j&#34；t&#34；跟踪空&#34；t&#34；3 4设置跟踪列表(T)&#34；u&#34；取消定义x&#34；u&#34；取消定义x中的变量&#34；v&#34；变量1 2&#34；v&#34；3 4显示变量(！Environment)&#34；x&#34；出口1 2&#34；x&#34；3 4_出口0&#34；w&#34；写入1 2&#34；w&#34；3 4格式，写入&#34；z&#34；停止1 2&#34；z&#34；3 4：继续。</p><p>空格(空格、制表符、回车)是有必要把名字和名字分开，把数字和数字分开，但不是数字中的名字。</p><p>名称必须以字母开头，并且可以包含字母、.、或者是一张单人票。包含-的名称是洗牌符号。</p><p>数字表达式必须以数字或-开头后跟数字，并且必须以数字结尾。一个浮点数数值表达式必须正好包含一个。哪一个两侧必须有数字。</p><p>整型枚举(&L；E)~ATOM&lt；升级&lt；x原子现时值(&lt；nonce)INT/INTS@WHERE&amp；x列表@翻转+x随机数原子y？Mod y！x~原子y？查找x？y列出ATOM\旋转y！x原子列表\Drop x_y原子\滴x_()，y列表列表\剪切x_y1=#x。下文X。指数/一元/二元。X。</p><p>错误的组合子如果和WHILE已经被已消除，以及条件、如果和同时都被定义为序曲中的词语。F的真值比K更一般：0为FALSE，任何其他值为真。</p><p>使用指定的名称(变量)会将指定的值对堆栈上的它执行以下操作：</p><p>无引号的合并者！是乔伊的我！vbl.采取堆栈上的顶部项x，并将X到队列：</p><p>DIP组合器的定义与其在Joy中的定义相同。#^LAu#^LAu获取堆栈上最上面的两个项目x，y，并在队列前面加上y，，x。例如，在启用跟踪的情况下，输入队列显示在菱形的右侧，左侧的结果堆栈：</p><p>F&gt；10 2 3 4 20[+*]`♦10 2 3 4 20[+*]`10♦2 3 4 20[+*]`10 2♦3 4 20[+*]`10 2 3♦4 20[+*]`10 2 3 4♦20[+*]`10 2 3 4 20♦[+*]`10 2 3 4 20[+*]♦`10 2 3 4♦+*2010 2 7♦*2010 14♦2010 14 20♦F&GT；</p><p>堆栈将堆栈推送到堆栈上取消堆栈将堆栈设置到堆栈的顶部队列将堆栈顶部移动到队列退出队列将队列末尾移动到堆栈。</p><p>$期望堆栈顶部有一个程序。该计划预计它下面有两个引语：当前队列和它下面的当前堆栈。F期望程序返回两个报价：新队列，其下是新列表。</p><p>F&GT；12个缺点！[1 2]F&GT；F&gt；[1 2]uncons！1[2]F&GT；F&gt；[1]uncons！1个整数F&GT；F&gt；[]uncons！空[]F&GT；F&GT；2个无名氏！2个整数。</p><p>F堆栈堆栈价大于堆栈大小。F队列队列价数大于队列大小。F模式堆栈大小大于模式方案大小。F字符：&lt；x&gt；x是非法字符。F现时值：&lt；x&gt；没有为提供的参数定义基元x。</p><p>J0(F语义)1(Joy语义)。O操作员字符、操作员查询表I.X是一种交互式(或解释器)命令。LL.x是表示为x的文字。K K.x是K系统函数Cci是词汇范畴I的字符向量。V一串州名称。W一串最终州名称。V中的X，我读到Cj中的一个字符，转到X[i；j]。T 0(无踪迹)1(踪迹)。E全球环境。的全局堆栈。Z(状态x 256)转移矩阵。</p><p>F F口译员。N解释模式。Q解释洗牌符号。我转换字典列表。J转换列表-&gt；字典。L加载并解释.f脚本。S格式化F值并将其保存为.f脚本。U更新堆栈(S)和环境(E)。P对输入字符串进行标记化和解析以创建队列。V评估令牌。R从(&#34；[&#34；；...；&#34；]&#34；]&#34；递归构造列表。)。下标、索引、一元修正、二元修正。E评估环境(X)中堆栈(Y)上的队列(Z)。A将队列顶部应用于环境中的堆栈。B评估符号。K在环境中创建一个变量。C处理已定义符号的值(J敏感)。X应用n-ad f，将征募结果附加到堆栈。Y应用n-ad f，将结果追加到堆栈。Z应用n-ad f，将结果预先添加到队列中。W将n-ad f应用于堆栈、队列、返回新堆栈，新队列。T如果T是非空列表，则跟踪即将到来的步骤。D显示轨迹。F格式化堆栈。G格式化堆栈上的元素。H漂亮的打印机O将符号转化为名称。</p><p>如果在.f或.j脚本中，解释器遇到单个未匹配&#34；，则对该脚本的评估终止。(类比到.K脚本中的\。)。</p><p>要退出到K，或退出当前跟踪或停止，请输入单个空格。通过使用按&lt；Return&gt；清除堆栈空输入。</p><p>为Joy改编的序曲和阶乘函数的版本语义学在这里和这里。</p><p>在Joy中，使用名称会导致与要对堆栈执行的名称：</p><p>在F中，使用名称会导致与该名称相关联的值放在堆叠上：</p><p>在Joy中，相邻名称必须用空格分隔，否则等价物。对应的F码具有更大的视觉密度，但也几乎同样简明扼要。例如，Reduce合并器为：</p><p>有人可能会说，F处于乔伊和乔伊之间的中间位置，它会积极地计算名称，而false则会破坏将名称求值的语义分解为更小的步骤：</p><p>在false中，名称将其自身留在堆栈中。；拿到一个名称，并将名称的值保留在堆栈上。好了！执行价值观。</p><p>此外，F语义使得一个程序可以轻松地修改另一个的代码：按名称调用程序，该程序在堆栈上保留报价，修改报价，执行。</p><p>无论如何，应该注意的是，将F切换到Joy语义学是一件微不足道的事情。C函数接受定义的符号z的值、堆栈x和队列y，并将其附加到堆栈：</p><p>其将z的内容预先添加到队列中。后续处理将评估值的元素一个接一个。</p><p>值得注意的是，在这两种方言中，有些原语有名字的。例如，in是一个原始系统函数，因此：</p><p>注意：此开关已在F的脚本中实现，即。J对于F语义是0，对于Joy语义是1。</p><p>F&gt；&#39；MAP&#34；o&#34；[[DUP COUNT[]TOP]DIP SWAP[报价Uncons DUP顶部[CONS UNIT EVER FIRST SWONS]DIPD]Do POP POP REV]。</p><p>可以用这种方式编写程序，使用单词在f脚本中定义。</p><p>在Joy中，报价既是一个列表，也是一个节目。所有程序是列表，反之亦然。凭直觉，似乎确实有一个[1 2 3]和[2+]之间的差异。不可能是前者包含数据元素，后者包含数据元素和函数，因为数字就是同样多的函数作为+运算符。2和+都是从堆栈到堆栈。</p><p>以清单形式报价和以清单形式报价之间的区别报价单-即程序归结为：报价单类似于列表当我们想要检查或操纵其部件或结构时；以及当想要执行报价时，它就像程序一样。所以都是一样的对象在某些上下文中可以显示为列表形式，在某些情况下可以显示为程序形式在其他人身上。事实上，如果我们仅仅是将其推送到堆栈上，而不考虑其结构或执行属性，或者两者兼而有之，如果我们首先操作内容和结构，然后执行它。</p><p>程序的价是一对整数。这个该对中的第一个元素是堆叠价。这个程序的堆栈价是它所使用的元素的数量从堆栈中取出。第二个要素是排队价。队列价数是它从排队。</p><p>引用操作符&#39；是唯一具有非零队列价：它期望在队列，它登记该队列并将其推送到堆栈上。因此，引用堆叠价为1。</p><p>+运算符的堆栈价为2。它从堆栈，并将总和推送到堆栈上。</p><p>程序的费用也是一对整数。第一个元素是电堆电荷，第二个元素是排队收费。</p><p>+有堆栈电荷1(它将单个元素推到堆栈)和队列收费为0。DUP具有堆叠价1和堆叠费2.交换有堆叠价2和堆叠充电2。</p><p>！(无引号)具有堆叠价1和无限Queue-Charge：它将报价从堆栈中取出并推送为将许多元素放到队列中，就像报价中的元素一样。</p><p>`(DIP)的堆叠价为2，无穷大队列收费：它从堆栈中去掉了两件事：报价和元素X，并将第一个X推入，然后将引号推到排队。</p><p>所有的基元都有非负电荷和价。一个负值表示程序在底部运行堆栈或队列的。</p><p>如果堆栈的元素少于(的绝对值堆栈价)，则发信号通知F堆栈错误。如果队列的元素少于(的绝对值)队列效价，则发信号通知F队列错误。</p><p>出栈程序期望在以下位置获得报价Q堆栈的顶部，并将堆栈设置为q：</p><p>队列程序期望在以下位置的顶部有一个引号堆栈，并将其附加到队列的末尾：</p><p>1 2 3[4 5 6]个队列7 8 91 2 3 7 8 9[4 5 6]。</p><p>出列程序要求在队列，并将其推送到堆栈上：</p><p>1 2 3出队4 5 6[7 89]1 2 3[7 8 9]4 5 6。</p><p>运算符堆栈-价堆栈-费用队列-价队列-费用堆栈信息%1%0%0取消堆栈%1信息%0%0队列1 0 0-1退出队列0 1-1 0。</p><p>$的实现是以下两个原语之一，这两个原语递归调用F赋值器e。$是K函数取x，环境，y，堆栈，和z，即队列，定义为：</p><p>的实施。是另一个基元，该基元递归调用F赋值器e。</p><p>M：{：[1=#y；e[x；()；*y]1/下文2=#y；(*y)。E[x；()；y 1]1/索引(4：*y)_in 4 6；&#39；&#34；G随机数：.&#34；/无分配3=#y；.@[y；2；{{*-1#e[*x；y，()；x 1]1}[(x；y)]}[x]]/monad.@[y；2；{{*-1#e[*x；y，，z；x 1]1}[(x；Y)]}[x]}/DYAD。</p><p>其中y是堆栈顶部的报价，x就是环境。</p><p>则y的计数为2。Y的第一个元素，即10 20 30，乘以第二个元素的值环境x中y的元素，即0 1。</p><p>模式是一个列表，它的头部是一个方案，其尾巴是一个模板。</p><p>方案是方案的名称或列表。案例名字的第一个字母很重要。如果为小写，则名称与单个元素匹配。如果为大写，则名称必须出现作为方案列表中的最后一个元素，并将匹配零或更多的元素，即。列表的其余部分，其初始元素由端子名称前面的方案匹配。</p><p>模板是一个列表。如果%s是中的符号方案中也出现的模板，值匹配用%s替换模板中的%s。</p><p>)将模式应用于堆栈，并将结果推送到堆栈上。(将模式应用于堆栈，并将结果放在队列前面。}将模式应用于队列并将结果推送到堆栈上。{将模式应用于队列，并将结果放在队列前面。</p><p>尽管F支持DIP组合器作为基元，可以将其定义为模式：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.nsl.com/k/f/f.htm">http://www.nsl.com/k/f/f.htm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1019195.html"><img src="http://img.diglog.com/img/2020/8/thumb_5d49aac98e3f14badacb7ab3fb8fb43d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019195.html">破解D-Link DIR3060固件加密-侦测-第1部分</a></div><span class="my_story_list_date">2020-8-20 2:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1018383.html"><img src="http://img.diglog.com/img/2020/8/thumb_690889dc1ebe5a0fd57856ae8756238e.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018383.html">“无钱首付百万美元技术堆栈”(The No Money-Down百万美元Tech Stack)</a></div><span class="my_story_list_date">2020-8-16 3:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1014711.html"><img src="http://img.diglog.com/img/2020/7/thumb_b6b6ca73f583def9ffad68937c1579c5.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1014711.html">堆栈溢出以8500万美元获得E系列资金</a></div><span class="my_story_list_date">2020-7-29 0:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005608.html"><img src="http://img.diglog.com/img/2020/6/thumb_bff2a714cd7081340512131d66996508.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005608.html">为什么8008后的CPU没有保留片上堆栈的想法？</a></div><span class="my_story_list_date">2020-6-8 3:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>