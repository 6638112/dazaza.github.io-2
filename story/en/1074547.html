<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么学球拍？学生的观点Why learn Racket? A student's perspective</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why learn Racket? A student's perspective<br/>为什么学球拍？学生的观点</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 03:29:48</div><div class="page_narrow text-break page_content"><p>~/blog/why-learn-racket      I&#39;m a student at Grinnell College, a small liberal arts school in Iowa. Here, the computer science department uses Racket in its intro course, which focuses on functional programming and is aimed at all students (majors, non-majors, and those with and without prior programming experience.) After taking the course myself last fall, this semester I am working as a student mentor for the course, where I help students during in-class labs and hold weekly review sessions.</p><p>~/blog/为什么要学球拍I&#39；我是爱荷华州一所小型文科学校格林内尔学院的学生。在这里，计算机科学系在其入门课程中使用Racket，该课程侧重于函数式编程，面向所有学生（专业、非专业，以及有或没有编程经验的学生）去年秋天我自己修完这门课后，这学期我作为这门课的学生导师，在课堂上帮助学生做实验，并每周举行复习课。</p><p> Grinnell is far from alone in its choice to use Racket or Scheme in its introductory CS course. Perhaps the most well known Scheme course is MIT&#39;s 6.001, which began in 1980 and taught computer science using the book  Structure and Interpretation of Computer Programs. MIT replaced their Scheme curriculum with a Python course in 2008, but other universities like Brown, Northeastern, and Indiana maintain Scheme or Racket in their first courses. Still, perhaps following MIT&#39;s lead, the use of Racket for an intro course is still relatively rare among CS undergraduate programs.</p><p>格林内尔并不是唯一一个选择在CS入门课程中使用Racket或Scheme的人。也许最著名的计划课程是麻省理工学院&#39；s 6.001开始于1980年，使用《计算机程序的结构和解释》一书教授计算机科学。2008年，麻省理工学院用Python课程取代了他们的Scheme课程，但布朗大学、东北大学和印第安纳大学等其他大学在第一门课程中保留Scheme或Racket。不过，也许是在麻省理工学院之后&#39；因此，在CS本科生项目中，在入门课程中使用球拍的情况仍然相对少见。</p><p> Given that Racket isn&#39;t a widely popular language, several students at Grinnell, often those who enter the class with prior experience in more popular languages like Python or Java, ask why it&#39;s chosen for Grinnell&#39;s first course. I&#39;ve also heard frustrated students wonder why they&#39;re wasting their time on a &#34;useless&#34; language, when they could learn a language that will help them get a job instead. Our professor gives an answer to those who ask, and there are other resources I&#39;ve seen such as Matthew Butterick&#39;s excellent piece,  Why Racket? Why Lisp?, but here I&#39;d like to share my own opinion on why I think learning Racket is worthwhile.</p><p>考虑到球拍是&#39；Grinnell的几名学生，通常是那些有过Python或Java等更流行语言经验的学生，在上课时会问为什么会使用它&#39；她被选为格林内尔&#39；这是第一道菜。我&#39；我也听到过沮丧的学生想知道为什么他们&#39；你把时间浪费在&#34；无用的&#34；语言，当他们可以学习一门语言，这将帮助他们找到一份工作。我们的教授给出了问题的答案，我还有其他资源&#39；我见过马修·巴特里克&#39；这首曲子很棒，为什么要拍？为什么口齿不清？，但在这里我&#39；I’我想就为什么我认为学习球拍是值得的这一点分享我自己的看法。</p><p> I think Racket is a great first language to learn, but in this post, I&#39;d like to concentrate on programmers, college-bound or otherwise, who have some experience in a mainstream language like Python, JavaScript, or Java, but are hesitant or unsure of the value in learning a functional programming language like Racket.</p><p>我认为球拍是一门很好的第一语言，但在这篇文章中，我&#39；I’我想把重点放在程序员身上，不管是大学毕业还是其他，他们对Python、JavaScript或Java等主流语言有一定的经验，但对学习Racket等函数式编程语言的价值犹豫不决或不确定。</p><p>  Racket, and Lisps more generally, are often touted as languages with the simplest syntax. In Racket, every form is an expression, which is either an atomic value like a string or number, or a list beginning with a procedure or a special form. This syntax stands in contrast to a language like Python, which has strict rules for which forms may be used as expressions and which must be statements.</p><p>Racket和Lisp通常被吹捧为语法最简单的语言。在Racket中，每种形式都是一个表达式，它要么是一个原子值，比如字符串或数字，要么是一个以过程或特殊形式开头的列表。这种语法与Python这样的语言形成了对比，Python有严格的规则，规定哪些形式可以用作表达式，哪些形式必须是语句。</p><p> I think this advantage is sometimes overstated by Lisp enthusiasts. Although Python&#39;s syntax may not be as simple, it does have its own kind of elegance once a user learns its syntactic rules. Where Lisp-style syntax does have an advantage, however, is in the power of its mental evaluation model. When evaluating Racket code, we always evaluate the innermost parentheses first, replacing procedure calls with their appropriate body, except for a few special forms.</p><p>我认为Lisp爱好者有时夸大了这一优势。虽然蟒蛇&#39；s的语法可能不那么简单，一旦用户学会了它的语法规则，它确实有自己的优雅。然而，Lisp风格语法的优势在于它的心理评估模型。在计算Racket代码时，我们总是首先计算最里面的括号，用适当的主体替换过程调用，除了一些特殊形式。</p><p>   To evaluate this, we replace  map with the body of its definition, substituting the arguments in place, and then continue with normal evaluation. We can trace an abbreviated version like this:</p><p>为了评估这一点，我们将map替换为其定义的主体，替换适当的参数，然后继续正常评估。我们可以这样追踪一个缩写版本：</p><p> (map sqr &#39;( 2 4 8 ))-&gt; ( if  (null? &#39;( 2 4 8 ))  null  (cons (sqr (car &#39;( 2 4 8 ))) (map sqr (cdr &#39;( 2 4 8 )))))-&gt; (cons  4  (map sqr &#39;( 4 8 )))-&gt; ...-&gt; (cons  4  (cons  16  (cons  64 null )))-&gt; &#39;( 4 16 64 )</p><p>（地图sqr和#39；（2 4 8））-&gt；（如果（空？&#39；（2 4 8））空（cons（sqr（car&#39；（2 4 8））））（地图sqr（cdr&#39；（2 4 8）###）-&gt；（cons 4（地图sqr和#39；（4 8））-&gt-&gt；（cons 4（cons 16（cons 64 null））-&gt&#39;( 4 16 64 )</p><p> Following the trace, we an see that there is nothing magical about  map, it&#39;s just a procedure that evaluates like any other. Compare that now to the equivalent list comprehension in Python:</p><p>沿着这条轨迹，我们看到地图并没有什么神奇之处，它&#39；这只是一个像其他程序一样进行评估的程序。现在将其与Python中的等效列表理解进行比较：</p><p>  How can we mentally evaluate this? For that we need remember the specific &#34;magical&#34; syntax and semantics for evaluating Python&#39;s for-comprehension expressions, which look similar yet act completely differently than for-loop statements.</p><p>我们如何在心理上评估这一点？为此，我们需要记住具体的#34；神奇的&#34；用于评估Python的语法和语义&#39；s表示理解表达式，它看起来相似，但与循环语句的行为完全不同。</p><p> Racket has special forms too like  let and  if for which evaluation strategies must be learned, but these are generally more limited and intuitive than the syntax found in Python or Java.</p><p>Racket也有一些特殊的形式，比如let和if，必须学习它们的评估策略，但它们通常比Python或Java中的语法更加有限和直观。</p><p>   In just a few simple lines of Java&#39;s canonical &#34;hello world&#34; example, we&#39;ve made several declarations with special rules for evaluation ( public,  class,  static, the dot operator, etc.) These all must be understood before a Java programmer can know much of anything about what their program is actually doing.</p><p>只需几行简单的Java&#39；s规范&#34；你好世界&#34；例如，我们&#39；我已经用特殊的求值规则（public、class、static、dot操作符等）做了几个声明。在Java程序员了解他们的程序实际执行的大部分内容之前，必须理解这些规则。</p><p> Java was the first programming language that I learned, so I know from first-hand experience that the result is that beginners to the language usually just accept that they can&#39;t fully understand how even a simple program like this is evaluated. They&#39;re forced to accept that learning to program involves memorizing seemingly arbitrary rules for structuring their code. Beginner Racket programmers face no such imposition, as its evaluation is much more intuitive, which I see as a clear advantage in its use as a teaching language.</p><p>Java是我学习的第一种编程语言，因此我从第一手经验中知道，其结果是该语言的初学者通常只接受他们可以&#39；我无法完全理解这样一个简单的程序是如何评估的。他们&#39；我们不得不接受，学习编程需要记住看似任意的规则来构建代码。初学者Racket程序员不会面临这样的压力，因为它的评估更加直观，我认为这在作为教学语言使用时是一个明显的优势。</p><p> Even if you are an experienced Python or Java programmer that knows exactly how every part of the language can be evaluated, I still think that exposure to Racket&#39;s evaluation model is worthwhile. Modeling how Racket code is transformed builds your intuition as a programmer for how different pieces of code decompose and fit together in a way that users of other languages usually don&#39;t directly consider. I think that strengthening these fundamentals builds intuition for quickly grasping evaluation in other languages.</p><p>即使你是一个经验丰富的Python或Java程序员，确切地知道如何评估语言的每个部分，我仍然认为接触Racket#39；s的评估模式是值得的。对Racket代码的转换进行建模，可以帮助程序员了解不同代码片段如何以其他语言的用户通常不知道的方式分解和组合在一起；t直接考虑。我认为，加强这些基础知识可以建立直觉，从而快速掌握其他语言的评估。</p><p>  Learning Racket often involves working with a more limited set of tools than the ones offered in other languages. Loops and mutation, for instance, which are core features in other languages, are usually off-limits to beginners in Racket</p><p>学习Racket通常需要使用比其他语言提供的工具更有限的工具。例如，循环和变异是其他语言的核心功能，对于初学者来说通常是不允许的</p><p> While there are genuine aesthetic advantages to a language built with a small core, namely in how it can be concisely defined and implemented, I think it&#39;s important not to overstate these in comparison to the material advantages of a small language as well.</p><p>虽然一门以小核心构建的语言有真正的美学优势，即如何简洁地定义和实现它，但我认为它&#39；与小型语言的物质优势相比，不要夸大这些优势也很重要。</p><p> The focus on minimalism in Racket initially forces even experienced programmers to step out of their comfort zone in how they structure their code, and ultimately, how they solve problems. For experienced programmers, I think there is great value in learning fundamentally different ways to approach a problem. This kind of experience pushes the bounds of one&#39;s knowledge and adds to a &#34;bag of tricks&#34; that allow one to solve more difficult or novel problems.</p><p>Racket中对极简主义的关注最初甚至迫使有经验的程序员在如何构造代码以及最终如何解决问题上走出他们的舒适区。对于经验丰富的程序员来说，我认为学习解决问题的根本不同方法是非常有价值的。这种经历使你的人生达到了极限&#39；s的知识，增加了a&#34；一袋把戏&#34；使人能够解决更困难或更新奇的问题。</p><p>  Let&#39;s talk about recursion, because I think that learning to use recursion as a general-purpose control structure is one of the most important consequences of gaining fluency in Racket.</p><p>让&#39；让我们来谈谈递归，因为我认为学习使用递归作为一种通用的控制结构是获得球拍流畅性的最重要的结果之一。</p><p> When programmers in other languages are introduced to recursion, it&#39;s usually to display an alternative and niche solution to some problems. Canonical examples like calculating a factorial or the nth Fibonacci number are given, even though these toy examples seem useless to programming at large. Additionally, programmers are often warned not to use recursion at all because of stack overflow concerns.</p><p>当其他语言的程序员被引入递归时，它&#39；这通常是为了展示一些问题的替代和小众解决方案。给出了计算阶乘数或第n个斐波那契数等典型例子，尽管这些玩具例子对一般编程来说似乎毫无用处。此外，由于堆栈溢出问题，程序员经常被警告不要使用递归。</p><p> Recursion, however, is a much more powerful tool than these beginner tutorials let on. Indeed, without loops and mutation, recursion is the main tool employed in Racket to manage repetition and state, and learning to use it as such is one of the most challenging aspects of learning the language for beginner and experienced programmers alike.</p><p>然而，递归是一个比这些入门教程功能强大得多的工具。事实上，在没有循环和变异的情况下，递归是Racket中用来管理重复和状态的主要工具，对于初学者和经验丰富的程序员来说，学习如何使用递归是学习该语言最具挑战性的方面之一。</p><p> The key to programming with recursion isn&#39;t that it can be used to implement recursive mathematical definitions, but instead that it&#39;s a general tool for breaking down a single difficult problem into several easier ones. This decomposition into sub-problems is, in fact, what allows recursion to work at all.</p><p>使用递归编程的关键在于&#39；它可以用来实现递归数学定义，但是它&#39；It’这是把一个难题分解成几个简单问题的通用工具。事实上，这种分解成子问题的方法是允许递归工作的。</p><p> Let&#39;s look at an example, comparing an iterative and recursive design of a  sum procedure. Here is a standard iterative approach in Python:</p><p>让&#39；让我们看一个例子，比较求和过程的迭代和递归设计。以下是Python中的标准迭代方法：</p><p>  This approach follows directly from how most people would answer the question  &#34;how do you sum a list of numbers?&#34; Well, start with zero, then add each value to the total until we reach the end.</p><p>这种方法直接源于大多数人会如何回答这个问题#34；你如何对一系列数字求和&#34; 好的，从零开始，然后将每个值加到总数中，直到我们到达终点。</p><p> Implementing  sum recursively, however, requires a different mindset. Instead, our strategy will be to ask two questions: First,  &#34;what&#39;s the sum of an empty list?&#34; Okay, obviously zero. Next,  &#34;if we know the sum of all but the first element in a list, what&#39;s the total sum?&#34; Here we can find this by adding the value of the first element to the sum of the rest.</p><p>然而，递归地实现sum需要不同的思维方式。相反，我们的策略是提出两个问题：第一，34；什么&#39；一张空名单的总和是多少&#34; 好吧，显然是零。其次是&#34；如果我们知道列表中除了第一个元素以外的所有元素的总和，那么&#39；总数是多少&#34; 在这里，我们可以通过将第一个元素的值与其余元素的和相加来找到这一点。</p><p>   This line of thinking is certainly not intuitive to someone unfamiliar with recursive design. However, it importantly forces us to split our design into two sub-problems: first solving the base case, and then breaking down the recursive step into what can be handled by the recursive call, and what we must do at each stage.</p><p>对于不熟悉递归设计的人来说，这种思路肯定不是直观的。然而，它重要地迫使我们将设计分成两个子问题：首先解决基本情况，然后将递归步骤分解为递归调用可以处理的内容，以及我们在每个阶段必须做的事情。</p><p> Recognizing the value to thinking recursively can be difficult, since it&#39;s not obvious why adopting an inherently less intuitive strategy to problem solving is helpful. But the beauty of recursion lies how it allows us to solve difficult problems and manage state with inherently less powerful tools (no mutation or loops), and how that simplicity rewards experienced programmers with the ability to quickly break down difficult problems.</p><p>认识到递归思维的价值可能很难，因为它&#39；为什么采用一种天生不那么直观的策略来解决问题是有帮助的，这并不明显。但递归的美妙之处在于，它让我们能够用本来就不那么强大的工具（没有变异或循环）来解决难题和管理状态，以及这种简单性如何奖励有经验的程序员快速解决难题的能力。</p><p> Recursion isn&#39;t a silver-bullet, but it&#39;s a fundamental tool that&#39;s worth understanding, even if functional programmers usually prefer to use more specific and safer tools built on top of recursion like higher-order procedures or comprehensions.</p><p>递归不是&#39；不是银弹，但它&#39；这是一个基本的工具&#39；这是值得理解的，即使函数式程序员通常更喜欢使用基于递归的更具体、更安全的工具，比如高阶过程或理解。</p><p>  Even if all this waxing about recursion is true, one may still wonder why to choose Racket when recursion is available in every other programming language as well. The answer is that Racket, like most other functional languages, is designed to make recursive design more ergonomic and natural.</p><p>即使所有关于递归的说法都是真的，人们可能仍然想知道，当递归在其他所有编程语言中都可用时，为什么要选择Racket。答案是，Racket和大多数其他函数式语言一样，旨在使递归设计更符合人体工程学和自然。</p><p> First, every Racket procedure implicitly returns the final expression, so there is no possibility of writing a foot-gun recursive procedure that doesn&#39;t return a value. Additionally, core forms in the language are designed to discourage imperative programming. For example, an  if expression must include truthy and false branches, so it&#39;s more difficult for one to forget to include a base case.</p><p>首先，每个Racket过程隐式返回最终表达式，因此不可能编写一个不&#39；t返回一个值。此外，该语言中的核心表单旨在阻止命令式编程。例如，if表达式必须包含truthy和false分支，因此它&#39；对一个人来说，忘记包含一个基本案例更难。</p><p> Perhaps most important, however, is the core placement of the list data structure. Lists are an inherently recursive data structure, as they&#39;re either  null or  cons of some value and another list. Recursive design over  cons lists is natural, so their central placement in Racket makes using recursion a natural choice.</p><p>然而，也许最重要的是列表数据结构的核心位置。列表是一种固有的递归数据结构，因为它们&#39；re要么为空，要么为某个值的cons，再加上另一个列表。对cons列表进行递归设计是很自然的，所以它们在球拍中的中心位置使得使用递归成为一种自然选择。</p><p> Compare that to using recursion in a language like Python. There the primary list data structure is an indexed dynamic array. Although one can translate the same recursive algorithms one would write with  cons and  cdr in Racket to Python, doing so would not only be unnatural, but also goes against the ethos of Python. And really, the same would go for a translation to other popular imperative languages.</p><p>将其与在Python等语言中使用递归进行比较。在那里，主列表数据结构是一个索引动态数组。尽管人们可以将使用Racket中的cons和cdr编写的递归算法翻译成Python，但这样做不仅不自然，而且违背Python的精神。事实上，翻译成其他流行的命令式语言也是如此。</p><p> Racket is advantageous for recursive design from the perspective of performance, rather than just pedagogy, too. Importantly, Racket guarantees  tail call optimization, which means that recursive functions designed to exploit tail recursion won&#39;t explode the memory on the stack as they would in imperative languages like Python and Java.</p><p>从性能的角度来看，Racket对递归设计是有利的，而不仅仅是教学法。重要的是，Racket保证了尾部调用优化，这意味着设计用于利用尾部递归的递归函数将赢得&#39；不要像在Python和Java等命令式语言中那样在堆栈上爆炸内存。</p><p>  Now that I have extolled the virtues of learning Racket, I want to add that the choice of a programming language is less important than you might think. One of the main areas of frustration I see from fellow students essentially boils down to the following question:  &#34;Why should I learn Racket when I could spend that time learning a language that people actually use?&#34; On the surface, this question makes some sense. Time and effort are scarce resources that should be allocated wisely, but I think asking this question misses a vital point: that  programming is much more difficult to learn than a  programming language.</p><p>既然我已经赞扬了学习Racket的优点，我想补充一点，编程语言的选择没有你想象的那么重要。我从同学们身上看到的挫折感主要集中在以下问题上：&#34；既然我可以花时间学习一门人们实际使用的语言，为什么我要学习Racket呢&#34; 从表面上看，这个问题有些道理。时间和精力是稀缺的资源，应该合理分配，但我认为提出这个问题忽略了一个关键点：编程比编程语言更难学。</p><p> I don&#39;t want to trivialize the effort needed to learn a new language, especially one like Racket that looks so different than popular C-like languages. But the syntax and specific features of a given language still only make up a small part of the knowledge required to master programming in general, in that language or any other. Indeed, experienced programmers can learn a new language much faster than novices, since they already know most of the concepts that underlie the new language, so they can focus on picking up the syntax or learning language-specific features instead.</p><p>我不&#39；I don’我不想贬低学习一门新语言所需的努力，尤其是像Racket这样看起来与流行的C语言截然不同的语言。但是，给定语言的语法和特定功能仍然只是掌握该语言或任何其他语言的一般编程所需知识的一小部分。事实上，经验丰富的程序员学习一门新语言的速度比新手快得多，因为他们已经知道构成新语言基础的大部分概念，所以他们可以专注于学习语法或学习特定于语言的功能。</p><p> When a Racket programmer picks up JavaScript for the first time, they already know how to use anonymous functions, closures and higher-order functions, so they only need to map their existing knowledge onto JavaScript&#39;s syntax and focus on its distinct features. This advantage only increases over time, since the more languages that one learns, the more knowledge bases one has to draw on when picking up a new language.</p><p>当Racket程序员第一次学习JavaScript时，他们已经知道如何使用匿名函数、闭包和高阶函数，所以他们只需要将现有知识映射到JavaScript&#39；并关注其独特的功能。这种优势只会随着时间的推移而增加，因为一个人学习的语言越多，他在学习一门新语言时需要利用的知识基础就越多。</p><p> So yes, you will have to invest time into learning the specifics of Racket, but the reward for that effort is that most of the knowledge obtained will pay dividends when you do move on to other languages. And because the core of Racket is so small and so expressive, it allows users to quickly dive into those more difficult yet ultimately more valuable aspects of programming, rather than getting bogged down in the heavy syntax and quirkiness found in languages like Java.</p><p>因此，是的，你将不得不投入时间学习Racket的细节，但这一努力的回报是，当你转到其他语言时，所获得的大部分知识将产生回报。而且，由于Racket的核心非常小，表达能力也非常强，因此它允许用户快速深入到编程中那些更困难但最终更有价值的方面，而不是陷入Java等语言中繁重的语法和古怪之处。</p><p>  The benefits of functional programming are often extolled from an intellectual point-of-view. The story goes that functional programming&#39;s focus on purity and statelessness will carry over to produce better results in imperative programming languages that de-emphasize those aspects. I agree with this sentiment, since I feel as though programming in a near-functional style is a useful default in any language, while still reaching for mutation and state when they&#39;re needed.</p><p>函数式编程的好处通常是从智力的角度来赞美的。故事是这样的：函数式编程#39；s对纯粹性和无状态性的关注将继续下去，以便在不强调这些方面的命令式编程语言中产生更好的结果。我同意这种观点，因为我觉得在任何语言中，近乎函数式的编程风格都是一种有用的默认设置，而当它们&#39；我们需要。</p><p> That being said, even if the large majority of programmers and engineers in industry use non-functional languages, to say that functional programming by itself is entirely useless in practice is inaccurate.</p><p>尽管如此，即使工业界的绝大多数程序员和工程师使用非函数式语言，说函数式编程本身在实践中完全无用也是不准确的。</p><p> This summer, for instance, I will be working as a software engineer intern for a company that uses Clojure in its back end, an opportunity that I only could have gotten because of my experience with Racket. I say this not to brag, but to point out that if you want to work with functional programming professionally, you may be able to get by even if Racket is the only language on your resume.</p><p>例如，今年夏天，我将在一家在后端使用Clojure的公司担任软件工程师实习生，这是一个只有在Racket方面有经验的机会。我这样说不是为了吹嘘，而是为了指出，如果你想专业地使用函数式编程，即使你的简历上只有Racket一种语言，你也可以勉强应付。</p><p> The functional programming community is certainly smaller than others in software engineering, but that&#39;s not entirely a bad thing. In my (albeit limited) experience, smaller opportunities can often be more accessible and more rewarding than flagship job or internship programmers that attract a massive amount of applications. In the end, every applicant needs something that makes them stand out, and if functional programming is their passion, that could be it.</p><p>函数式编程社区当然比软件工程中的其他社区小，但这&#39；这不完全是件坏事。根据我（尽管有限）的经验，与吸引大量申请的旗舰工作或实习程序员相比，较小的机会往往更容易获得，也更有回报。最后，每个申请者都需要一些能让他们脱颖而出的东西，如果函数式编程是他们的激情所在，那可能就是。</p><p> Additionally, and perhaps more importantly, even if the functional programming community within software engineering is relatively small, the importance of functional tools and techniques in almost every modern language has recently grown considerably.</p><p>此外，也许更重要的是，即使软件工程中的函数式编程社区相对较小，但函数式工具和技术在几乎所有现代语言中的重要性最近都有了相当大的增长。</p><p> In the last few years, bastions of object-oriented programming like  Java and  C# have added support for lambda expressions, and  Python introduced structural pattern matching -- both important tools lifted from functional languages.</p><p>在过去几年中，Java和C#等面向对象编程的堡垒增加了对lambda表达式的支持，Python引入了结构模式匹配——这两种重要工具都是从函数式语言中衍生出来的。</p><p> Not only that, but  React, and its functional approach to managing state with hooks, has become the de-facto JavaScript UI library in the frontend web development community. Even if functional programming languages lag behind imperative or object-oriented ones in adoption, their techniques and features have increasingly bled over to the point that they&#39;re now unavoidable.</p><p>不仅如此，React及其使用钩子管理状态的功能性方法已经成为前端web开发社区中事实上的JavaScript UI库。即使函数式编程语言在采用上落后于命令式或面向对象的语言，它们的技术和特性也越来越丰富，以至于它们&#39；你现在不可避免了。</p><p>  Racket is above all, an excellent programming language, and in my view, a valuable learning tool for novice and experienced programmers alike. That&#39;s why it frustrates me when my peers complain about the language for what I see as irrational reasons. Not everyone needs to love or prefer functional programming in Racket, but I hope this post at least helps some of those people appreciate its value.</p><p>最重要的是，Racket是一种优秀的编程语言，在我看来，对于新手和经验丰富的程序员来说都是一种很有价值的学习工具。那&#39；这就是为什么当我的同龄人因为我认为是非理性的原因而抱怨这种语言时，我会感到沮丧。不是每个人都需要喜欢或更喜欢Racket中的函数式编程，但我希望这篇文章至少能帮助其中一些人欣赏它的价值。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/球拍/">#球拍</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learn/">#learn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>