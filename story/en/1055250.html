<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何靠近卷曲 How to Backdoor Curl</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Backdoor Curl<br/>如何靠近卷曲 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 18:56:04</div><div class="page_narrow text-break page_content"><p>I’ve previously blogged about the possible  backdoor threat to  curl. This post might be a little repeat but also a refresh and renewed take on the subject several years later, in the shadow of the recent  PHP backdoor commits of March 28, 2021. Nowadays, “supply chain attacks” is a hot topic.</p><p>我之前曾博客关于可能的后门威胁来卷曲。这篇文章可能有点重复，但几年后，刷新和更新对象，在近期PHP后门犯下的影子2021年3月28日。现在，“供应链攻击”是一个热门话题。</p><p> Since you didn’t read that PHP link: an unknown project outsider managed to push a commit into the PHP master source code repository with a change (made to look as if done by two project regulars) that obviously inserted a backdoor that could execute custom code when a client tickled a modified server the right way.</p><p> 由于您没有读取PHP链接：一个未知的项目outsider成功地将提交推进到PHP主源代码存储库中，更改（使看起来像两个项目常客所做的）显然插入了可以执行自定义的后门代码当客户端签订修改后的服务器正确的方式。</p><p>  The commits were apparently detected very quickly. I haven’t seen any proper analysis on exactly how they were performed, but to me that’s not the ultimate question. I rather talk and think about this threat in a curl perspective.</p><p>  显然是很快检测到的提交。我没有看到任何正确的分析，完全是如何进行的，而是对我来说这不是最终的问题。我宁愿以卷曲的角度谈论这种威胁。</p><p> PHP is extremely well used and so is curl, but where PHP is (mostly) server-side running code, curl is client-side.</p><p> PHP非常良好使用，因此卷曲也是如此卷曲，但其中PHP是（大多数）服务器端运行代码，卷曲是客户端。</p><p>  I’d like to think about this problem from an attacker’s point of view. There are but two things an attacker need to do to get a backdoor in and a third adjacent step that needs to happen:</p><p>  我想从攻击者的角度来看这个问题。还有两件事需要攻击者，以获得需要发生的后门和第三个相邻的步骤：</p><p> Make a backdoor change that is hard to detect and appears innocent to a casual observer, while actually still being able to do its “job”</p><p> 做出一个难以检测的后门变化，并且对休闲观察者似乎无辜，而实际上仍然能够做到其“工作”</p><p>  The code needs to be included in a curl release that is used by the victim/target</p><p>  代码需要包含在受害者/目标使用的卷曲版本中 </p><p> These are not simple steps. The third step, getting into a release, is not strictly  always necessary because there are sometimes people and organizations that run code off the bleeding edge master repository (against our advice I should add).</p><p>这些不是简单的步骤。进入释放的第三步并不严格始终是必要的，因为有时有时候人员和组织可以从出血边缘主存储库中运行代码（针对我们应该添加的建议）。</p><p>   As was seen in this PHP attack, it failed rather miserably at step 1, making the attack code look innocuous, although we can suspect that maybe that was done so on purpose. In 2010 there was a  lengthy discussion about an alleged backdoor in OpenBSD’s IPSEC stack that presumably had been in place for years and even while that particular backdoor was never proven to be real, the idea that it can be done certainly is.</p><p>   如在这个PHP攻击中所见，它在第1步失败了相当糟糕的是，使攻击代码看起来无害，尽管我们可以怀疑这可能是故意这样做的。在2010年，关于OpenBSD的IPSec堆栈中的一个令人冗长的讨论可能已经到达了多年甚至没有被证明是真实的，所以肯定是真实的，所以可以肯定的想法是。</p><p> Every time we fix a security problem in curl there’s that latent nagging question in the back of our collective minds:  was this flaw placed here deliberately? Historically, we’ve not seen any such attacks against curl. I can tell this with a high degree of certainty since almost all of the existing security problems detected and reported in curl was done by me…!</p><p> 每次我们在卷曲中修复安全问题时，我们集体思想的背面都会潜在的唠叨问题：这个缺陷是故意的吗？从历史上看，我们没有看到任何对卷曲的攻击。我可以通过几乎所有检测到的现有安全问题和在卷曲中报告的安全问题所做的很高的确定性。</p><p> The best attack code would probably do something minor that would have a huge impact in a special context for which the attacker has planned to use it. I mean minor as in doing a NULL-pointer dereference or doing a use-after-free or something. This, because doing a full-fledged generic stack based buffer overflow is much harder to land undetected. Maybe going with a  single-byte overwrite outside of a malloc could be the way, like it was back in 2016 when such a flaw in c-ares was used as the first step in a multi-flaw exploit sequence to execute remote code as root on ChromeOS…</p><p> 最好的攻击代码可能会对攻击者计划使用它的特殊背景产生巨大影响。我的意思是少见的，因为做了零指针取消引用，或者做了一个不惯性的或什么。这是，因为执行基于全面的通用堆栈的缓冲区溢出更难降落未被发现。也许在Malloc之外的单字节覆盖可能是这样的方式，就像2016年回到2016年时，当C-ARES这样的缺陷用作多漏洞利用序列中的第一步时以root身份执行远程代码在Chromeos ...</p><p> Ideally, the commit should also include an actual bug-fix that would be the public facing motivation for it.</p><p> 理想情况下，提交还应包含实际的错误 - 修复，这将是公众面临的动机。</p><p>   Okay let’s imagine that you have produced code that actually is a useful bug-fix or feature addition but with an added evil twist, and you want that landed in curl. I can imagine several different theoretical ways to do it:</p><p>   好吧，让我们想象你已经生产了实际上是一个有用的错误 - 修复或补充添加的代码，但是有一个添加的邪恶扭曲，而且你希望在卷曲中降落。我可以想象几种不同的理论方法来做这件事：</p><p> Use a weakness somewhere and land the code directly without involving existing curl team members</p><p> 在某处使用弱点并直接登陆代码而不涉及现有的卷曲团队成员 </p><p>  I’ve never seen this attempted. Submit the pull-request to the project the usual means and argue that the commit fixes a bug – which could be true.</p><p>我从未见过这个尝试。将Lift-Request提交给项目通常的手段并争辩说，提交修复了一个错误 - 这可能是真的。</p><p> This makes the backdoor patch to have to go through all testing and reviews with flying colors to get merged. I’m not saying this is impossible, but I will claim that it is very hard and also a very big gamble by an attacker. Presumably it is a fairly big job just to get the code for this attack to work, so maybe going with a less risky way to land the code is then preferable? But then which way is likely to have the most reliable outcome?</p><p> 这使得后门补丁必须通过飞行颜色进行所有测试和评论以获得合并。我不是说这是不可能的，但我会声称它非常努力，也是攻击者非常大的赌博。可能是一个相当大的工作，只是为了获得这个攻击的代码，所以也许使用更少的风险危险来降落代码，然后是优选的？但那么哪种方式可能具有最可靠的结果？</p><p>  Social engineering is very powerful. I can’t claim that our team is immune to that so maybe there’s a way an outsider could sneak in behind our imaginary personal walls and make us take a shortcut for a made up reason that then would circumvent the project’s review process.</p><p>  社会工程非常强大。我不能声称我们的团队对此免疫，所以也许有办法局外人可以在我们想象中的个人墙壁后面潜行，并使我们拿出一个弥补的原因，然后将该项目的审查过程规避。</p><p> We can even include more forced “convincing” such as direct threats against persons or their families: “push this code or else…”. This way of course cannot be protected against using 2fa, better passwords or things like that. Forcing a users to do it is also likely to eventually get known and then immediately make the commit reverted.</p><p> 我们甚至可以包括更强迫的“令人信服的”，例如对人士或其家人的直接威胁：“推动这段代码或其他......”。这种方式无法使用2FA，更好的密码或类似的东西来保护。强制使用用户可能最终会知道，然后立即使提交恢复。</p><p> Tricking a user doesn’t make the commit avoid testing and scrutinizing after the fact. When the code has landed, it will be scanned and tested in a hundred CI jobs that include a handful of static code analyzers and memory/address sanitizers.</p><p> 欺骗用户不会使提交避免在事实之后进行测试和仔细检查。当代码已降落时，将在包含少数静态代码分析仪和内存/地址消毒器的百种CI作业中扫描和测试。</p><p> Tricking a user could land the code, but it can’t make it stick unless the code is written as the perfect stealth change. It really needs to be that good attack code to work out. Additionally: circumventing the regular pull-request + review procedure is unusual so I believe it is likely that such commit will be reviewed and commented on after the fact, and there might then be questions about it and even likely follow-up actions.</p><p> 欺骗用户可以降落代码，但除非代码被写入完美的隐形变化，否则它不能粘。它真的需要成为锻炼的良好攻击代码。此外：规避常规拉动请求+审查程序是不寻常的，所以我相信此事实后可能会审查和评论此类提交，然后可能有关于它甚至可能的后续行动的问题。</p><p>  A weakness in this context could be a security problem in the hosting software or even a rogue admin in the company that hosts the main source code git repo.  Something that allows code to get pushed into the code repository without it being the result of one of the existing team members. This seems to be the method that the PHP attack was done through.</p><p>  在此上下文中的弱点可能是托管软件中的安全问题，甚至可以在托管主要源代码Git Repo的公司中的rogue管理员。允许代码被推入代码存储库的内容，而无需它是现有团队成员之一的结果。这似乎是PHP攻击完成的方法。 </p><p> This is a hard method as well. Not only does it shortcut reviews, it is also done in the name of someone on the team who knows for sure that they didn’t do the commit, and again, the commit will be tested and poked at anyway.</p><p>这也是一种硬的方法。它不仅是捷径评论，它也是以人员的名义，肯定没有做到他们没有做出提交，并再次进行，并在任何道路上都会进行测试和戳。</p><p> For all of us who sign our git commits, detecting such a forged commit is easy and quickly done. In the curl project we don’t have mandatory signed commits so the lack of a signature won’t actually block it. And who knows, a weakness somewhere could even possibly find a way to bypass such a requirement.</p><p> 对于所有签署Git提交的我们所有人，检测到这种伪造的提交很容易和快速完成。在卷曲项目中，我们没有强制性签名的罪行，因此缺乏签名实际上不会阻止它。谁知道，某处的弱点甚至可能找到一种绕过这样的要求的方法。</p><p>  As I’ve described above, it is really hard even for a skilled developer to write a backdoor and have that landed in the curl git repository and stick there for longer than just a very brief period.</p><p>  正如我上面描述的那样，即使是熟练的开发人员来说，它也非常努力地写一个后门，并将其降落在卷曲GIT存储库中，并粘在那里比仅仅是一个非常短暂的时期。</p><p> If the attacker instead can just sneak the code directly into a release archive then it won’t appear in git, it won’t get tested and it won’t get easily noticed by team members!</p><p> 如果攻击者可以将代码直接潜入一个版本存档，那么它不会出现在Git中，它不会被测试，并且团队成员不会轻易注意到！</p><p> curl release tarballs are made by me, locally on my machine. After I’ve built the tarballs I sign them with my GPG key and upload them to the  curl.se origin server for the world to download. (Web users don’t actually hit my server when downloading curl. The user visible web site and downloads are hosted by Fastly servers.)</p><p> 卷发释放塔尔巴球由我在我的机器上发布。在我构建了Tarball后，我用我的GPG键签名并将其上传到卷曲.SE Origin Server为世界下载。 （Web用户在下载卷曲时实际上没有击中我的服务器。用户可见的网站和下载乘坐速度服务器。）</p><p> An attacker that would infect my release scripts (which btw are also in the git repository) or do something to my machine could get something into the tarball and then have me sign it and then create the “perfect backdoor” that isn’t detectable in git and requires someone to diff the release with git in order to detect – which usually isn’t done by anyone that I know of.</p><p> 一个攻击者，它会感染我的发布脚本（BTW也在Git存储库中）或对我的机器做点什么可以在Tarball中获取一些东西，然后让我签署它，然后创建“完美的后门” Git并要求某人用Git释放释放，以便检测 - 通常不是我所知道的任何人都完成的。</p><p> But such an attacker would not only have to breach my development machine, such an infection of the release scripts would be awfully hard to pull through. Not impossible of course. I of course do my best to maintain proper login sanitation, updated operating systems and use of safe passwords and encrypted communications everywhere. But I’m also a human so I’m bound to do occasional mistakes.</p><p> 但这样的攻击者不仅要违反我的开发机器，这种释放脚本的感染就会非常难以拉开。当然不是不可能的。我当然尽力维持适当的登录卫生，更新的操作系统和使用安全密码和使用安全密码和加密通信。但我也是一个人，所以我必然会偶尔犯错误。 </p><p> Another way could be for the attacker to breach the origin download server and replace one of the tarballs there with an infected version, and hope that people skip verifying the signature when they download it or otherwise notice that the tarball has been modified. I do my best at maintaining server security to keep that risk to a minimum. Most people download the latest release, and then it’s enough if a subset checks the signature for the attack to get revealed sooner rather than later.</p><p>另一种方法可以是攻击者违反原点下载服务器并用感染的版本替换那里的Tarball，并希望人们在下载或以其他方式注意到Tarball被修改时跳过签名。我在维护服务器安全性时尽力保持风险最低。大多数人下载最新版本，然后如果一个子集检查攻击的签名，则足够了，以便更快地揭示。</p><p>  As an attacker, get into the supply chain somewhere else: find a weaker link in the chain between the curl release tarball and the target system for your attack . If you can trick or social engineer maybe someone else along the way to get  your evil curl tarball to get used there instead of the actual upstream tarball, that might be easier and give you more bang for your buck. Perhaps you target your particular distribution’s or Operating System’s release engineers and pretend to be from the curl project, make up a story and send over a tarball to help them out…</p><p>  作为攻击者，进入其他地方的供应链：在卷曲发布tarball和目标系统之间找到一个较弱的链接，为您的攻击。如果你可以欺骗或社会工程师也许沿途的别人可以让你的邪恶卷曲tarball以在那里使用而不是实际的上游tarball，这可能更容易，让你更加爆炸你的巴克。也许你定位你的特定分发或操作系统的发布工程师，假装从卷曲项目中，弥补一个故事并送到一个tarball来帮助他们......</p><p> Fake a security advisory and send out a bad patch directly to someone you know build their own curl/libcurl binaries?</p><p> 假设安全咨询，直接向您知道自己的卷曲/ libcurl二进制文件发出一个坏补丁吗？</p><p>  If you can think of other/better ways to get malicious code via curl code into a victim’s machine, let me know! If you find a security problem,  we will reward you for it!</p><p>  如果你能想到通过卷曲代码将恶意代码的其他/更好的方法纳入受害者的机器，请告诉我！如果您发现安全问题，我们将为您奖励！</p><p> Similarly, if you can think of ways or practices on how we can improve the project to further increase our security I’ll be very interested. It is an ever-moving process.</p><p> 同样，如果您能够考虑如何改进项目的方式或做法，以进一步增加我们的安全，我将非常感兴趣。这是一项永远搬家的过程。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://daniel.haxx.se/blog/2021/03/30/howto-backdoor-curl/">https://daniel.haxx.se/blog/2021/03/30/howto-backdoor-curl/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/靠近/">#靠近</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/backdoor/">#backdoor</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/卷曲/">#卷曲</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>