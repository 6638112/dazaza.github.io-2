<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>理解分布式共识(2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">理解分布式共识(2018)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 18:11:57</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/da4972a06ab6e39fef37b4cc5fb1841e.jpg"><img src="http://img2.diglog.com/img/2020/11/da4972a06ab6e39fef37b4cc5fb1841e.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Distributed systems can be difficult to understand, mainly because the knowledge surrounding them  is distributed. But don’t worry, I’m well aware of the irony. While teaching myself distributed computing, I fell flat on my face many times. Now, after many trials and tribulations, I’m finally ready to explain the basics of distributed systems to you.</p><p>分布式系统可能很难理解，主要是因为它们周围的知识是分布式的。但别担心，我很清楚其中的讽刺意味。在自学分布式计算时，我多次摔倒在地。现在，在经历了许多考验和磨难之后，我终于准备好向你们解释分布式系统的基础知识了。</p><p> Blockchains have forced engineers and scientists to re-examine and question firmly entrenched paradigms in distributed computing.</p><p>区块链迫使工程师和科学家重新审视和质疑分布式计算中根深蒂固的范式。</p><p> I also want to discuss the profound effect that blockchain technology has had on the field. Blockchains have forced engineers and scientists to re-examine and question firmly entrenched paradigms in distributed computing. Perhaps no other technology has catalyzed progress faster in this area of study than blockchain.</p><p>我还想讨论一下区块链技术对该领域产生的深刻影响。区块链迫使工程师和科学家重新审视和质疑分布式计算中根深蒂固的范式。也许没有其他技术比区块链更快地推动了这一研究领域的进步。</p><p> Distributed systems are by no means new. Scientists and engineers have spent decades researching the subject. But what does blockchain have to do with them? Well, all the contributions that blockchain has made wouldn’t have been possible if distributed systems hadn’t existed first.</p><p>分布式系统绝不是什么新鲜事。科学家和工程师花了几十年的时间来研究这个课题。但是区块链和他们有什么关系呢？嗯，如果没有分布式系统，区块链做出的所有贡献都是不可能的。</p><p> Essentially, a blockchain is a new type of distributed system. It started with the advent of  Bitcoin and has since made a lasting impact in the field of distributed computing. So, if you want to really know how blockchains work, a great grasp of the principles of distributed systems is essential.</p><p>从本质上讲，区块链是一种新型的分布式系统。它始于比特币的出现，此后在分布式计算领域产生了持久的影响。因此，如果你想真正了解区块链是如何工作的，对分布式系统原理的深刻把握是必不可少的。</p><p> Unfortunately, much of the literature on distributed computing is either difficult to comprehend or dispersed across way too many academic papers. To make matters more complex, there are hundreds of architectures, all of which serve different needs. Boiling this down into a simple-to-understand framework is quite difficult.</p><p>不幸的是，许多关于分布式计算的文献要么难以理解，要么分散在太多的学术论文中。更复杂的是，有数百种架构，所有这些架构都服务于不同的需求。将其归结为一个简单易懂的框架是相当困难的。</p><p> Because the field is vast, I had to carefully choose what I could cover. I also had to make generalizations to mask some of the complexity. Please note, my goal is not to make you an expert in the field. Instead, I want to give you enough knowledge to jump-start your journey into distributed systems and consensus.</p><p>因为这个领域很广阔，我不得不谨慎地选择我能覆盖的领域。我还不得不做一些概括，以掩盖一些复杂性。请注意，我的目标不是让你成为该领域的专家。相反，我想给你足够的知识来启动你的分布式系统和共识之旅。</p><p>     A distributed system involves a set of distinct processes (e.g., computers) passing messages to one another and coordinating to accomplish a common objective (i.e., solving a computational problem).</p><p>分布式系统涉及一组不同的进程(例如，计算机)彼此传递消息并协调以实现共同目标(即，解决计算问题)。</p><p> A distributed system is a group of computers working together to achieve a unified goal.</p><p>分布式系统是一组协同工作以实现统一目标的计算机。</p><p> Simply put, a distributed system is a group of computers working together to achieve a unified goal. And although the processes are separate, the system appears as a single computer to end-user(s).</p><p>简单地说，分布式系统就是一组计算机为了实现统一的目标而协同工作。虽然这两个过程是分开的，但对于最终用户来说，系统看起来就像一台计算机。</p><p> As I mentioned, there are hundreds of architectures for a distributed system. For example, a single computer can also be viewed as a distributed system: the central control unit, memory units, and input-output channels are separate processes collaborating to complete an objective.</p><p>正如我提到的，分布式系统有数百种架构。例如，一台计算机也可以看作是一个分布式系统：中央控制单元、存储单元和输入输出通道是相互协作以完成某一目标的独立进程。</p><p> In the case of an airplane, these discrete units work together to get you from Point A to Point B:</p><p>在飞机的情况下，这些独立的单元协同工作，将您从A点带到B点：</p><p>  In this post, we’ll focus on distributed systems in which processes are spatially-separated computers.</p><p>在这篇文章中，我们将重点介绍分布式系统，在分布式系统中，进程是空间上分离的计算机。</p><p>  Note: I may use the terms “node,” “peer,” “computer,” or “component” interchangeably with “process.” They all mean the same thing for the purposes of this post. Similarly, I may use the term “network” interchangeably with “system.”</p><p>注意：我可以将术语“节点”、“对等”、“计算机”或“组件”与“进程”互换使用。对于这篇文章来说，它们的意思都是一样的。同样，我可以将术语“网络”与“系统”互换使用。</p><p>    The processes in the system operate concurrently, meaning multiple events occur simultaneously. In other words, each computer in the network executes events independently at the same time as other computers in the network.</p><p>系统中的进程同时运行，这意味着多个事件同时发生。换句话说，网络中的每台计算机与网络中的其他计算机同时独立地执行事件。</p><p>    For a distributed system to work, we need a way to determine the order of events. However, in a set of computers operating concurrently, it is sometimes impossible to say that one of two events occurred first, as computers are spatially separated. In other words, there is no single global clock that determines the sequence of events happening across all computers in the network.</p><p>要让分布式系统正常工作，我们需要一种方法来确定事件的顺序。然而，在同时运行的一组计算机中，有时不可能说两个事件中的一个首先发生，因为计算机在空间上是分开的。换句话说，不存在单一的全局时钟来决定网络中所有计算机上发生的事件的顺序。</p><p> In the paper “ Time, Clocks and Ordering of Events in a Distributed System,” Leslie Lamport shows how we can deduce whether one event happens before another by remembering the following factors:</p><p>在《分布式系统中的时间、时钟和事件顺序》一文中，Leslie Lamport展示了我们如何通过记住以下因素来推断一个事件是否发生在另一个事件之前：</p><p>  By determining which event happens before another, we can get a  partial ordering of events in the system. Lamport’s paper describes an algorithm which requires each computer to hear from every other computer in the system. In this way, events can be  totally ordered based on this partial ordering.</p><p>通过确定哪个事件在另一个事件之前发生，我们可以获得系统中事件的部分排序。兰波特的论文描述了一种算法，该算法要求每台计算机都能监听系统中所有其他计算机的信息。通过这种方式，可以基于这种部分排序对事件进行完全排序。</p><p> However, if we base the order entirely upon events heard by each individual computer, we can run into situations where this order differs from what a user external to the system perceives. Thus, the paper shows that the algorithm can still allow for anomalous behavior.</p><p>但是，如果我们将顺序完全基于每台计算机听到的事件，我们可能会遇到这样的情况：该顺序与系统外部的用户所感知的不同。因此，本文表明，该算法仍然可以允许异常行为。</p><p> Finally, Lamport discusses how such anomalies can be prevented by using properly synchronized physical clocks.</p><p>最后，兰波特讨论了如何通过使用适当同步的物理时钟来防止此类异常。</p><p> But wait — there’s a huge caveat: coordinating otherwise independent clocks is a very complex computer science problem. Even if you initially set a bunch of clocks accurately, the clocks will begin to differ after some amount of time. This is due to “ clock drift,” a phenomenon in which clocks count time at slightly different rates.</p><p>但等等， - ，有一个很大的警告：协调原本独立的时钟是一个非常复杂的计算机科学问题。即使您最初精确地设置了一组时钟，时钟在一段时间后也会开始不同。这是由于“时钟漂移”现象造成的，即时钟以略有不同的速率计时。</p><p> Essentially, Lamport’s paper demonstrates that time and order of events are fundamental obstacles in a system of distributed computers that are spatially separated.</p><p>从本质上讲，兰波特的论文证明，在空间上分散的分布式计算机系统中，事件的时间和顺序是根本的障碍。</p><p>  A critical aspect of understanding distributed systems is acknowledging that components in a distributed system are faulty. This is why it’s called “fault-tolerant distributed computing.”</p><p>理解分布式系统的一个关键方面是承认分布式系统中的组件有故障。这就是为什么它被称为“容错分布式计算”。</p><p> It’s impossible to have a system free of faults. Real systems are subject to a number of possible flaws or defects, whether that’s a process crashing; messages being lost, distorted, or duplicated; a network partition delaying or dropping messages; or even a process going completely haywire and sending messages according to some malevolent plan.</p><p>一个没有故障的系统是不可能的。真正的系统可能存在许多缺陷或缺陷，无论是进程崩溃；消息丢失、扭曲或重复；网络分区延迟或丢弃消息；甚至是进程完全混乱并根据某种恶意计划发送消息。</p><p>   Omission: The component sends a message but it is not received by the other nodes (e.g., the message was dropped).</p><p>省略：该组件发送一条消息，但其他节点没有接收到该消息(例如，该消息被丢弃)。</p><p> Byzantine: The component behaves arbitrarily. This type of fault is irrelevant in controlled environments (e.g., Google or Amazon data centers) where there is presumably no malicious behavior. Instead, these faults occur in what’s known as an “adversarial context.” Basically, when a decentralized set of independent actors serve as nodes in the network, these actors may choose to act in a “Byzantine” manner. This means they maliciously choose to alter, block, or not send messages at all.</p><p>拜占庭：组件的行为是任意的。这种类型的故障在可能没有恶意行为的受控环境(例如Google或Amazon数据中心)中是无关紧要的。相反，这些错误发生在所谓的“对抗性环境”中。基本上，当一组分散的独立行为者充当网络中的节点时，这些行为者可能会选择以“拜占庭式”的方式行事。这意味着他们恶意选择更改、阻止或根本不发送消息。</p><p> With this in mind, the aim is to design protocols that allow a system with faulty components to still achieve the common goal and provide a useful service.</p><p>考虑到这一点，我们的目标是设计协议，使具有故障组件的系统仍能实现共同目标并提供有用的服务。</p><p> Given that every system has faults, a core consideration we must make when building a distributed system is whether it can survive even when its parts deviate from normal behavior, whether that’s due to non-malicious behaviors (i.e., crash-fail or omission faults) or malicious behavior (i.e., Byzantine faults).</p><p>鉴于每个系统都有故障，在构建分布式系统时，我们必须考虑的一个核心问题是，无论是由于非恶意行为(即崩溃失败或遗漏故障)还是恶意行为(即拜占庭故障)，在构建分布式系统时，即使其部分偏离正常行为，它是否仍能存活。</p><p> Broadly speaking, there are two types of models to consider when making a distributed system:</p><p>一般而言，在构建分布式系统时有两种类型的模型需要考虑：</p><p>  In a simple fault-tolerant system, we assume that all parts of the system do one of two things: they either follow the protocol exactly or they fail. This type of system should definitely be able to handle nodes going offline or failing. But it doesn’t have to worry about nodes exhibiting arbitrary or malicious behavior.</p><p>在一个简单的容错系统中，我们假设系统的所有部分执行以下两种操作之一：它们要么完全遵循协议，要么失败。这种类型的系统应该绝对能够处理节点脱机或故障。但它不必担心节点表现出任意或恶意行为。</p><p>  A simple fault-tolerant system is not very useful in an uncontrolled environment. In a decentralized system that has nodes controlled by independent actors communicating on the open, permissionless internet, we also need to design for nodes that choose to be malicious or “Byzantine.” Therefore, in a Byzantine fault-tolerant system, we assume nodes can fail or be malicious.</p><p>简单的容错系统在不受控制的环境中用处不大。在一个分散的系统中，节点由在开放、未经许可的互联网上通信的独立参与者控制，我们还需要为选择恶意或“拜占庭”的节点进行设计。因此，在拜占庭容错系统中，我们假设节点可能出现故障或恶意。</p><p>  Despite the fact that most real systems are designed to withstand Byzantine failures,  some experts argue that these designs are too general and don’t take into account “rational” failures, wherein nodes can deviate if it is in their self-interest to do so. In other words, nodes can be both honest and dishonest, depending on incentives. If the incentives are high enough, then even the majority of nodes might act dishonestly.</p><p>尽管大多数真实系统的设计都是为了承受拜占庭式的故障，但一些专家认为，这些设计过于笼统，没有考虑到“理性”故障，即节点如果这样做符合自身利益，就可能出现偏差。换句话说，节点可以是诚实的，也可以是不诚实的，这取决于激励。如果激励足够高，那么即使大多数节点也可能会做出不诚实的行为。</p><p> More formally, this is defined as the BAR model — one that specifies for both Byzantine and rational failures. The BAR model assumes three types of actors:</p><p>更正式地说，这被定义为酒吧模型 - ，它同时规定了拜占庭式和理性式的失败。酒吧模型假定有三种类型的参与者：</p><p>   As I noted earlier, computers in a distributed system communicate and coordinate by “message passing” between one or more other computers. Messages can be passed using any messaging protocol, whether that’s HTTP, RPC, or a custom protocol built for the specific implementation. There are two types of message-passing environments:</p><p>正如我前面提到的，分布式系统中的计算机通过一台或多台其他计算机之间的“消息传递”进行通信和协调。可以使用任何消息传递协议传递消息，无论是HTTP、RPC还是为特定实现构建的自定义协议。有两种类型的消息传递环境：</p><p>  In a synchronous system, it is assumed that messages will be delivered within some fixed, known amount of time.</p><p>在同步系统中，假定消息将在一段固定的已知时间内传递。</p><p> Synchronous message passing is conceptually less complex because users have a guarantee: when they send a message, the receiving component will get it within a certain time frame. This allows users to model their protocol with a fixed upper bound of how long the message will take to reach its destination.</p><p>同步消息传递在概念上不那么复杂，因为用户有一个保证：当他们发送消息时，接收组件将在特定的时间范围内收到该消息。这允许用户用消息到达目的地所需时间的固定上限来建模他们的协议。</p><p> However, this type of environment is not very practical in a real-world distributed system where computers can crash or go offline and messages can be dropped, duplicated, delayed, or received out of order.</p><p>然而，这种类型的环境在现实世界的分布式系统中并不是很实用，在现实世界中，计算机可能会崩溃或脱机，消息可能会被丢弃、复制、延迟或无序接收。</p><p>  In an asynchronous message-passing system, it is assumed that a network may delay messages infinitely, duplicate them, or deliver them out of order. In other words, there is no fixed upper bound on how long a message will take to be received.</p><p>在异步消息传递系统中，假设网络可能无限延迟消息、复制消息或无序发送消息。换句话说，接收一条消息需要多长时间没有固定的上限。</p><p>    Next, we’ll focus on understanding what it means to achieve “consensus” in a distributed system. But first, it’s important to reiterate what we alluded to earlier: there are hundreds of hardware and software architectures used for distributed computing.</p><p>接下来，我们将重点了解在分布式系统中达成“共识”意味着什么。但首先，重要的是要重申我们前面提到的：用于分布式计算的硬件和软件体系结构有数百种。</p><p>   A replicated state machine is a deterministic state machine that is replicated across many computers but functions as a single state machine. Any of these computers may be faulty, but the state machine will still function.</p><p>复制状态机是确定性状态机，可跨多台计算机复制，但充当单个状态机。这些计算机中的任何一个都可能出现故障，但状态机仍将运行。</p><p>  In a replicated state machine, if a transaction is valid, a set of inputs will cause the state of the system to transition to the next state. A transaction is an atomic operation on a database. This means the operations either complete in full or never complete at all. The set of transactions maintained in a replicated state machine is known as a “transaction log.”</p><p>在复制状态机中，如果事务有效，一组输入将导致系统状态转换到下一个状态。事务是对数据库的原子操作。这意味着这些操作要么完全完成，要么永远不会完成。在复制状态机中维护的一组事务称为“事务日志”。</p><p> The logic for transitioning from one valid state to the next is called the “state transition logic.”</p><p>从一个有效状态转换到下一个有效状态的逻辑称为“状态转换逻辑”。</p><p>  In other words, a replicated state machine is a set of distributed computers that all start with the same initial value. For each state transition, each of the processes decides on the next value. Reaching “consensus” means that all the computers must collectively agree on the output of this value.</p><p>换句话说，复制状态机是一组分布式计算机，它们都以相同的初始值开始。对于每个状态转换，每个进程都决定下一个值。达成“共识”意味着所有的计算机必须集体同意这个值的输出。</p><p> In turn, this maintains a consistent transaction log across  every computer in the system (i.e., they “achieve a common goal”). The replicated state machine must continually accept new transactions into this log (i.e., “provide a useful service”). It must do so despite the fact that:</p><p>反过来，这会在系统中的每台计算机上维护一致的事务日志(即，它们“实现了共同的目标”)。复制的状态机必须不断地将新事务接收到该日志中(即，“提供有用的服务”)。它必须这样做，尽管事实是：</p><p> The network is not reliable and messages may fail to deliver, be delayed, or be out of order.</p><p>网络不可靠，消息可能无法传递、延迟或出现故障。</p><p>      Note: Different algorithms have different variations of the conditions above. For example, some divide the   Agreement  property into   Consistency  and   Totality . Some have a concept of   Validity  or   Integrity  or   Efficiency . However, such nuances are beyond the scope of this post.</p><p>注：不同的算法对上述条件有不同的变化。例如，有些人将协议属性分为一致性和整体性。有些人有有效性、完整性或效率的概念。然而，这些细微差别超出了本文的讨论范围。</p><p>  Learners, other processes in the system which learn the final values that are decided upon.</p><p>学习者，系统中学习最终决定值的其他过程。</p><p>     The non-faulty processes listen to the value being proposed by the leader, validate it, and propose it as the next valid value.</p><p>无故障流程监听领导提出的值，对其进行验证，并将其作为下一个有效值提出。</p><p>  The non-faulty processes must come to a consensus on a single correct output value. If it receives a threshold number of identical votes which satisfy some criteria, then the processes will decide on that value.</p><p>非故障流程必须就单个正确的输出值达成共识。如果它收到满足某些标准的相同选票的阈值数量，则进程将决定该值。</p><p>        Nonetheless, if we can use this generic process to build an algorithm that guarantees the general conditions defined above, then we have a distributed system which is able to achieve consensus.</p><p>尽管如此，如果我们能够使用这个通用过程来构建一个算法来保证上面定义的一般条件，那么我们就拥有了一个能够达成共识的分布式系统。</p><p>       Reaching consensus in a synchronous environment is possible because we can make assumptions about the maximum time it takes for messages to get delivered. Thus, in this type of system, we can allow the different nodes in the system to take turns proposing new transactions, poll for a majority vote, and skip any node if it doesn’t offer a proposal within the maximum time limit.</p><p>在同步环境中达成共识是可能的，因为我们可以假设消息传递所需的最长时间。因此，在这种类型的系统中，我们可以允许系统中的不同节点轮流提出新的事务，轮询多数票，并跳过任何在最大时间限制内没有提出建议的节点。</p><p> But, as noted earlier, assuming we are operating in synchronous environments is not practical outside of controlled environments where message latency is predictable, such as data centers which have synchronized atomic clocks.</p><p>但是，如前所述，假设我们在同步环境中操作，在消息延迟可预测的受控环境之外是不现实的，例如具有同步原子时钟的数据中心。</p><p> In reality, most environments don’t allow us to make the synchronous assumption. So we must design for asynchronous environments.</p><p>实际上，大多数环境都不允许我们做出同步假设。因此，我们必须针对异步环境进行设计。</p><p> If we cannot assume a maximum message delivery time in an asynchronous environment, then achieving termination is much harder, if not impossible. Remember, one of the conditions that must be met to achieve consensus is “termination,” which means every non-faulty node  must decide on some output value.</p><p>如果我们不能假设异步环境中的最大消息传递时间，那么实现终止就会困难得多，如果不是不可能的话。请记住，要达成共识，必须满足的条件之一是“终止”，这意味着每个未出错的节点都必须决定某个输出值。</p><p> This is formally known as the “FLP impossibility result.” How did it get this name? Well, I’m glad you asked!</p><p>这被正式称为“FLP不可能结果”。它是怎么得名的？嗯，我很高兴你这么问！</p><p> Even a single faulty process makes it impossible to reach consensus among deterministic asynchronous processes.</p><p>即使是一个单一的故障流程，也不可能在确定性的异步流程之间达成共识。</p><p> In their 1985 paper “ Impossibility of Distributed Consensus with One Faulty Process,” researchers Fischer, Lynch, and Paterson (aka FLP) show how even a single faulty process makes it impossible to reach consensus among deterministic asynchronous processes. Basically, because processes can fail at unpredictable times, it’s also possible for them to fail at the exact opportune time that prevents consensus from occurring.</p><p>研究人员Fischer、Lynch和Paterson(又名FLP)在1985年的论文《一个有故障的过程中不可能达成分布式共识》中展示了，即使是一个有故障的过程也不可能在确定性的异步过程中达成共识。基本上，因为流程可能在不可预测的时间失败，所以它们也有可能在阻止达成共识的确切时间失败。</p><p>  This result was a huge bummer for the distributed computing space. Nonetheless, scientists continued to push forward to find ways to circumvent FLP impossibility.</p><p>这一结果对分布式计算空间来说是一个巨大的挫折。尽管如此，科学家们仍在继续努力寻找绕过FLP不可能的方法。</p><p>      Let’s revisit our impossibility result. Here’s another way to think about it: the FLP impossibility result essentially shows that, if we cannot make progress in a system, then we cannot reach consensus. In other words, if messages are asynchronously delivered, termination cannot be guaranteed. Recall that termination is a required condition that means every non-faulty node must eventually decide on some output value.</p><p>让我们重新审视一下我们不可能的结果。这里有另一种思考方式：FLP不可能的结果本质上表明，如果我们不能在一个体系中取得进展，那么我们就不能达成共识。换句话说，如果消息是异步传递的，则无法保证终止。回想一下，终止是必需的条件，这意味着每个非故障节点最终都必须决定某个输出值。</p><p> But how can we guarantee every non-faulty process will decide on a value if we don’t know when a message will be delivered due to asynchronous networks?</p><p>但是，如果我们不知道消息将在何时由于异步网络传递，我们如何保证每个没有错误的进程都会决定一个值呢？</p><p> To be clear, the finding does not state that consensus is unreachable. Rather, due to asynchrony, consensus cannot be reached in a fixed time. Saying that consensus is “impossible” simply means that consensus is “not always possible.” It’s a subtle but crucial detail.</p><p>需要明确的是，这一发现并不是说无法达成共识。相反，由于不同步，不可能在固定的时间内达成共识。说共识是“不可能的”，只是意味着共识“并不总是可能的”。这是一个微妙但至关重要的细节。</p><p> One way to circumvent this is to use timeouts. If no progress is being made on deciding the next value, we wait until a timeout, then start the steps all over again. As we’re about to see, this is what consensus algorithms like Paxos and Raft essentially did.</p><p>规避此问题的一种方法是使用超时。如果在决定下一个值方面没有取得任何进展，我们将等到超时，然后重新开始这些步骤。正如我们即将看到的，这就是像Paxos和RAFT这样的共识算法所做的事情。</p><p>  Introduced in the 1990s,  Paxos was the first real-world, practical, fault-tolerant consensus algorithm. It’s one of the first widely adopted consensus algorithms to be proven correct by Leslie Lamport and has been used by global internet companies like Google and Amazon to build distributed services.</p><p>Paxos于20世纪90年代推出，是第一个现实世界中实用的容错一致性算法。这是莱斯利·兰波特(Leslie Lamport)证明是正确的首批被广泛采用的共识算法之一，并已被谷歌(Google)和亚马逊(Amazon)等全球互联网公司用来构建分布式服务。</p><p>   The proposer chooses a new proposal version number (n) and sends a “prepare request” to the acceptors.</p><p>提出者选择新的提案版本号(N)，并向接受者发送“准备请求”。</p><p> If acceptors receive a prepare request (“prepare,” n) with n greater than that of any prepare request they had already responded to, the acceptors send out (“ack,” n, n’, v’) or (“ack,” n, ^ , ^).</p><p>如果接受者接收到比他们已经响应的任何准备请求的n大的准备请求(“PREPARE，”n)，接受者就发出(“ack，”n，n‘，v’)或(“ack，”n，^，^)。</p><p> Acceptors respond with a promise not to accept any more proposals numbered less than n.</p><p>接受者的回应是承诺不再接受任何编号小于n的提案。</p><p> Acceptors suggest the value (v) of the highest-number proposal that they have accepted, if any. Or else, they respond with ^.</p><p>接受者建议他们所接受的最高编号提案的值(V)(如果有的话)。否则，他们会回复^。</p><p>  If the proposer receives responses from a majority of the acceptors, then it can issue an accept request (“accept,” n, v) with number n and value v.</p><p>如果提出者收到来自大多数接受者的响应，则它可以发出数字为n、值为v的接受请求(“Accept”，n，v)。</p><p>   If the acceptor receives an accept request (“accept,” n, v), it accepts the proposal unless it has already responded to a prepare request with a number greater than n.</p><p>如果接受者接收到接受请求(“Accept，”n，v)，则它接受该提议，除非它已经用大于n的数字响应了准备请求。</p><p>  Whenever an acceptor accepts a proposal, it responds to all learners (“accept,” n, v).</p><p>当接受者接受一个提议时，它会回应所有的学习者(“接受”，n，v)。</p><p> Learners receive (“accept,” n, v) from a majority of acceptors, decide v, and send (“decide,” v) to all other learners.</p><p>学习者从大多数接受者那里接收(“接受”，n，v)，决定v，然后发送(“决定，”v)给所有其他学习者。</p><p>  Phew! Confused yet? I know that was a quite a lot of information to digest.</p><p>哟！困惑了吗？我知道这是一个相当多的信息需要消化。</p><p>  As we now know, every distributed system has faults. In this algorithm, if a proposer failed (e.g., because there was an omission fault), then decisions could be delayed. Paxos dealt with this by starting with a new version number in Phase 1, even if previous attempts never ended.</p><p>正如我们现在所知道的，每个分布式系统都有故障。在该算法中，如果提议者失败(例如，因为存在遗漏错误)，那么决策可能会被推迟。Paxos通过在第一阶段使用一个新的版本号来解决这个问题，即使之前的尝试从未结束。</p><p> I won’t go into details, but the process to get back to normal operations in such cases was quite complex since processes were expected to step in and drive the resolution process forward.</p><p>我不会详细介绍，但在这种情况下恢复正常操作的过程相当复杂，因为预计过程会介入并推动解决过程向前发展。</p><p> The main reason Paxos is so hard to understand is that many of its implementation details are left open to the reader’s interpretation: How do we know when a proposer is failing? Do we use synchronous clocks to set a timeout period for deciding when a proposer is failing and we need to move on to the next rank? 🤷‍</p><p>Paxos如此难以理解的主要原因是，它的许多实现细节都有待读者的解读：我们如何知道提案何时失败？我们是否使用同步时钟来设置超时时段，以决定何时提案失败，我们需要进入下一个级别？🤷‍。</p><p> In favor of offering flexibility in implementation, several specifications in key areas are left open-ended. Things like leader election, failure detection, and log management are vaguely or  completely undefined.</p><p>为了在实现上提供灵活性，关键领域中的几个规范是不限成员名额的。领导人选举、故障检测和日志管理等内容模糊或完全没有定义。</p><p> This design choice ended up becoming one of the biggest downsides of Paxos. It’s not only incredibly difficult to understand but difficult to implement as well. In turn, this made the field of distributed systems incredibly hard to navigate.</p><p>这种设计选择最终成为Paxos最大的缺点之一。它不仅令人难以置信地难以理解，而且也难以实现。反过来，这使得分布式系统领域的导航变得异常困难。</p><p>  In Paxos, although timeouts are not explicit in the algorithm, when it comes to the actual implementation, electing a new proposer after some timeout period is necessary to achieve termination. Otherwise, we couldn’t guarantee that acceptors would output the next value, and the system could come to a halt.</p><p>在Paxos中，虽然超时在算法中并不明确，但当涉及到实际实现时，需要在超时一段时间后选举新的提名人来实现终止。否则，我们不能保证接受者会输出下一个值，系统可能会停止。</p><p>  In 2013, Ongaro and Ousterhout published a new consensus algorithm for a replicated state machine called  Raft, where the core goal was understandability (unlike Paxos).</p><p>2013年，Ongaro和Ousterhout发布了一种名为RAFT的复制状态机的新共识算法，其核心目标是可理解性(与Paxos不同)。</p><p> One important new thing we learned from Raft is the concept of using a shared timeout to deal with termination. In Raft, if you crash and restart, you wait at least one timeout period before trying to get yourself declared a leader, and you are guaranteed to make progress.</p><p>我们从RAFT学到的一个重要的新东西是使用共享超时来处理终止的概念。在RAFT中，如果你崩溃并重新启动，你至少要等待一段暂停时间，然后才能试图让自己被宣布为领导者，你肯定会取得进展。</p><p>  While traditional consensus algorithms (such as Paxos and Raft) are able to thrive in asynchronous environments using some level of synchrony assumptions (i.e. timeouts), they are not Byzantine fault-tolerant. They are only crash fault-tolerant.</p><p>虽然传统的一致性算法(如Paxos和RAFT)能够在使用某种程度的同步假设(即超时)的异步环境中茁壮成长，但它们并不具有拜占庭式的容错能力。它们只具有崩溃容错能力。</p><p> Crash-faults are easier to handle because we can model the process as either working or crashed — 0 or 1. The processes can’t act maliciously and lie. Therefore, in a crash fault-tolerant system, a distributed system can be built where a simple majority is enough to reach a consensus.</p><p>崩溃故障更容易处理，因为我们可以将进程建模为正在工作或崩溃的 - 0或1。进程不能恶意操作和撒谎。因此，在崩溃容错系统中，可以构建一个简单多数就足以达成共识的分布式系统。</p><p> In an open and decentralized system (such as public blockchains), users have no control over the nodes in the network. Instead, each node makes decisions toward its individual goals, which may conflict with those of other nodes.</p><p>在开放去中心化的系统(如公共区块链)中，用户对网络中的节点没有控制权。取而代之的是，每个节点针对其各自的目标做出决策，这可能与其他节点的决策相冲突。</p><p> In a Byzantine system where nodes have different incentives and can lie, coordinate, or act arbitrarily, you cannot assume a simple majority is enough to reach consensus. Half or more of the supposedly honest nodes can coordinate with each other to lie.</p><p>在拜占庭式的系统中，节点有不同的动机，可以任意撒谎、协调或行动，你不能假设简单的多数就足以达成共识。一半或更多被认为诚实的节点可以相互协调以撒谎。</p><p> For example, if an elected leader is Byzantine and maintains strong network connections to other nodes, it can compromise the system. Recall how we said we must model our system to either tolerate simple faults or Byzantine faults. Raft and Paxos are simple fault-tolerant but not Byzantine fault-tolerant. They are not designed to tolerate malicious behavior.</p><p>例如，如果一位当选的领导人是拜占庭式的，并且与其他节点保持着强大的网络连接，这可能会危及系统。回想一下，我们曾说过，我们必须对我们的系统进行建模，要么容忍简单的错误，要么容忍拜占庭式的错误。RAFT和Paxos是简单的容错，但不是拜占庭式的容错。它们的设计不是为了容忍恶意行为。</p><p>  Trying to build a reliable computer system that can handle processes that provide conflicting information is formally known as the “ Byzantine General’s Proble</p><p>试图建立一个可靠的计算机系统来处理提供相互冲突的信息的过程被正式地称为“拜占庭将军的问题”</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.preethikasireddy.com/post/lets-take-a-crack-at-understanding-distributed-consensus">https://www.preethikasireddy.com/post/lets-take-a-crack-at-understanding-distributed-consensus</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/分布式/">#分布式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>