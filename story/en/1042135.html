<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>世界性Libc：可在任何地方运行一次构建C库 Cosmopolitan Libc: build-once run-anywhere C library</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cosmopolitan Libc: build-once run-anywhere C library<br/>世界性Libc：可在任何地方运行一次构建C库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-28 12:14:44</div><div class="page_narrow text-break page_content"><p>In other words the compiler assumes that, in calling the function, fifteen separate registers and all memory will be overwritten. See the  System V ABI for further details. This can be problematic for frequently-called functions such as memcpy, since it inhibits many optimizations and it tosses a wrench in the compiler register allocation algorithm, thus causing stack spillage which further degrades performance while bloating the output binary size. So what Cosmopolitan does for memcpy() and many other frequently-called core library leaf functions, is defining a simple macro wrapper, which tells the compiler the correct subset of the abi that&#39;s actually needed, e.g. #define memcpy(DEST, SRC, N) ({ \ void *Dest = (DEST); \ void *Src = (SRC); \ size_t Size = (N); \  asm( &#34;call memcpy&#34; \ :  &#34;=m&#34;(*( char(*)[Size])(Dest)) \ :  &#34;D&#34;(Dest),  &#34;S&#34;(Src),  &#34;d&#34;(n), \  &#34;m&#34;(*( char(*)[Size])(Src)) \ :  &#34;rcx&#34;,  &#34;xmm3&#34;,  &#34;xmm4&#34;,  &#34;cc&#34;); \ Dest; \ })</p><p>换句话说，编译器假设在调用函数时， 15个单独的寄存器，所有存储器将被覆盖。看到 系统V 有关更多详细信息，请参见ABI。这可能是有问题的 常用功能，例如memcpy，因为它禁止许多 优化，它在编译器寄存器中丢了一把扳手 分配算法，从而导致堆栈溢出，从而进一步 在降低输出二进制大小的同时降低性能。 那么Cosmopolitan为memcpy（）和其他许多项目做了什么 经常被称为核心库叶子函数，正在定义一个简单的 宏包装程序，它告诉编译器abi的正确子集 实际需要的，例如 ＃定义memcpy（DEST，SRC，N）（{\ 无效*目标=（目标）; \ 无效* Src =（SRC）; \ size_t大小=（N）; \  asm（＆amp; call memcpy＆＃34; \ ：＆＃34; = m＆＃34;（*（char（*）[Size]）（Dest））\ ：＆＃34; D＆＃34;（Dest），＆＃34; S＆＃34;（Src），＆＃34; d＆＃34;（n），\  ＆＃34; m＆＃34;（*（char（*）[Size]）（Src））\ ：＆＃34; rcx＆＃34 ;、＆＃34; xmm3＆＃34 ;、＆＃34; xmm4＆＃34 ;、＆＃34; cc＆＃34;）； \ 目的地\ }）</p><p>  What this means, is that Cosmopolitan memcpy() is not simply fast, it also makes unrelated code in the functions that call it faster too as a side-effect. When this technique was first implemented for memcpy() alone, many of the functions in the Cosmopolitan codebase had their generated code size reduced by a third. For an example of one such function, consider  strlcpy, which is the BSD way of saying  strcpy: /** * Copies string, the BSD way. * *  @param d is buffer which needn&#39;t be initialized *  @param s is a NUL-terminated string *  @param n is byte capacity of d *  @return strlen(s) *  @note d and s can&#39;t overlap *  @note we prefer memccpy() */ size_t strlcpy( char *d,  const  char *s,  size_t n) {  size_t slen, actual; slen = strlen(s); if (n) { actual = MIN(n, slen); memcpy(d, s, actual); d[actual] =  &#39;\0&#39;; }  return slen;}</p><p>  这意味着世界性memcpy（）不仅速度很快，而且 也使不相关的代码在调用它的函数中也更快 副作用。首次为memcpy（）实现此技术时 仅世界性代码库中的许多功能都有 生成的代码大小减少了三分之一。 有关此类功能的示例，请考虑使用strlcpy， 这是BSD说strcpy的方式： / ** *复制字符串，BSD方式。 * * @parad d是不需要初始化的缓冲区 * @param s是NUL终止的字符串 * @param n是d的字节容量 * @return strlen（s） * @note d和s不能重叠 * @note我们更喜欢memccpy（） * / size_t strlcpy（char * d，const char * s，size_t n）{  size_t slen，实际； slen = strlen（s）; 如果（n）{ 实际= MIN（n，slen）; memcpy（d，s，实际的）; d [actual] =＆＃39; \ 0＆＃39 ;; }  返回slen;}</p><p>  If we compile our  strlcpy function, then here&#39;s the assembly code that the compiler outputs: / compiled with traditional libc strlcpy:	 push	 %rbp	 mov	 %rsp, %rbp	 push	 %r14	 mov	 %rsi, %r14	 push	 %r13	 mov	 %rdi, %r13	 mov	 %rsi, %rdi	 push	 %r12	 push	 %rbx	 mov	 %rdx, %rbx	 call	strlen	 mov	 %rax, %r12	 test	 %rbx, %rbx	 jne	1f	 pop	 %rbx	 mov	 %r12, %rax	 pop	 %r12	 pop	 %r13	 pop	 %r14	 pop	 %rbp	 ret1:	 cmp	 %rbx, %rax	 mov	 %r14, %rsi	 mov	 %r13, %rdi	 cmovbe	 %rax, %rbx	 mov	 %rbx, %rdx	 call	memcpy	 movb	$ 0,0( %r13, %rbx)	 mov	 %r12, %rax	 pop	 %rbx	 pop	 %r12	 pop	 %r13	 pop	 %r14	 pop	 %rbp	 ret	 .endfn	strlcpy,globl</p><p>  如果我们编译strlcpy函数，则这里是 编译器输出的汇编代码： /用传统的libc编译 strlcpy：推送％rbpmov％rsp，％rbp推％r14mov％rsi，％r14推％r13mov％rdi，％r13mov％rsi，％rdi推％r12推送％rbxmov％rdx，％rbx召唤mov％rax，％r12测试％rbx，％rbx1月1日弹出％rbxmov％r12，％rax弹出％r12弹出％r13弹出％r14弹出％rbp退回1：cmp％rbx，％raxmov％r14，％rsimov％r13，％rdicmovbe％rax，％rbxmov％rbx，％rdx打电话给memcpymovb $ 0,0（％r13，％rbx）mov％r12，％rax弹出％rbx弹出％r12弹出％r13弹出％r14弹出％rbp退回.endfn strlcpy，globl</p><p>  / compiled with cosmopolitan libc strlcpy:	 mov	 %rdx, %r8	 mov	 %rdi, %r9	 mov	 %rsi, %rdi	 call	strlen	 test	 %r8, %r8	 je	1f	 cmp	 %r8, %rax	 mov	 %r8, %rdx	 mov	 %r9, %rdi	 cmovbe	 %rax, %rdx	 call	MemCpy	 movb	$ 0,( %r9, %rdx)1:	 ret	 .endfn	strlcpy,globl</p><p>  /用国际化libc编译 strlcpy：mov％rdx，％r8mov％rdi，％r9mov％rsi，％rdi召唤测试％r8，％r8je 1fcmp％r8，％raxmov％r8，％rdxmov％r9，％rdicmovbe％rax，％rdx致电MemCpymovb $ 0，（％r9，％rdx）1：退.endfn strlcpy，globl</p><p>  That&#39;s a huge improvement in generated code size. The above two compiles used the same gcc flags and no changes to the code needed to be made. All that changed was we used cosmopolitan.h (instead of the platform c library string.h) which contains ABI specialization macros for  memcpy and  strlen. It&#39;s a great example of how merely choosing a better C library can systemically eliminate bloat throughout your entire codebase.</p><p>  这是生成代码大小的巨大改进。以上两个 编译使用相同的gcc标志，并且无需更改代码即可 被制造。更改的只是我们使用了cosmopolitan.h（而不是 平台c库string.h），其中包含ABI专业化宏 对于memcpy和strlen。这是一个很好的例子 仅选择更好的C库可以如何系统地消除 在整个代码库中膨胀。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://justine.lol/cosmopolitan/index.html">https://justine.lol/cosmopolitan/index.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/libc/">#libc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memcpy/">#memcpy</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>