<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您的CPU可能会在星期三放慢速度 Your CPU May Have Slowed Down on Wednesday</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Your CPU May Have Slowed Down on Wednesday<br/>您的CPU可能会在星期三放慢速度 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-22 15:00:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/8b5a626f61a1e6a3c2ee5dc6c6c9ae34.jpg"><img src="http://img2.diglog.com/img/2021/6/8b5a626f61a1e6a3c2ee5dc6c6c9ae34.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The plot below shows the throughput of filling a region of the given size (varying on the x-axis) with zeros  1 on Skylake (and Ice Lake in the second tab).</p><p>下图显示了填充给定尺寸（在X轴上变化）的区域的吞吐量，在Skylake（和第二个标签中的冰湖）上的零1。</p><p> The two series were generated under apparently identical conditions: the same binary on the same machine. Only the date the benchmark was run varies. That is, on Tuesday (June 7th) filling with zeros is substantially faster than the same benchmark on Wednesday, at least when the region no longer fits in the L2 cache  2.</p><p> 这两个系列在显然相同的条件下产生：同一台机器上的相同二进制文件。只有基准运行的日期都会有所不同。也就是说，在星期二（6月7日）填充零的填充基本上比周三相同的基准更快，至少当区域不再适合L2高速缓存2时。</p><p>   What’s going on here? Are my Skylake and Ice Lake hosts simply work-weary by Wednesday and don’t put in as much effort? Is there a new crypto-coin based on who can store the most zeros and this is a countermeasure to avoid ballooning CPU prices in the face of this new workload?</p><p>   这里发生了什么？我的天窗和冰湖主持人只是在周三工作，并没有尽可能多地努力吗？是否有一个新的加密硬币基于谁可以存储最大的零，这是一个对策，以避免在这种新工作负载面前的膨胀CPU价格？</p><p>  These hosts run Ubuntu 20.04 and on Wednesday June 8th an update to the  intel- microcode OS package was released. After a reboot  3, this loads the CPU with new   microcode that causes the behavior shown above. Specifically, this  microcode  4 disables the  hardware zero store optimization we discussed in a previous post. It was disabled to mitigate  CVE-2020-24512 further described  5 in Intel security advisory  INTEL-SA-00464.</p><p>  这些主机运行Ubuntu 20.04，并在6月8日星期三发布了对Intel-Microdode OS包的更新。重新启动3后，这将CPU加载新的微代码，导致上面显示的行为。具体而言，该微码4禁用我们在先前帖子中讨论的硬件零存储优化。在英特尔安全咨询英特尔-A-00464中，将CVE-2020-24512进一步描述了CVE-2020-24512。</p><p> To be clear, I don’t know  for sure that the  microcode disables the zero store optimization – but the evidence is rather overwhelming. After the update, performance is the same when filling zeros as for any other value, and the performance counters tracking L2 evictions suggestion that substantially all evictions are now non-silent (recall from the previous posts that silent evictions were a hallmark of the optimization).</p><p> 要清楚，我不确定确定微码是否禁用零存储优化 - 但证据相当压倒性。更新后，在将零作为任何其他值填充零时，性能是相同的，并且跟踪L2的性能计数器驱逐的建议，即现在所有驱逐的建议现在是非沉默（从先前的帖子中召回沉默的驱逐是优化的标志） 。</p><p> Although I suspect the performance impact will be minuscule on average  6, this surprise still serves as a reminder that raw CPU performance can  silently change due to  microcode updates and most Linux distributions and modern Windows have these updates enabled by default. We’ve  seen this before. If you are trying to run reproducible benchmarks, you should always re-run your  entire suite in order to make accurate comparisons, even on the same hardware, rather than just running the stuff you think has changed.</p><p> 虽然我怀疑性能影响将平均划分为6，但这意外仍然是提醒，原始CPU性能可以由于微码更新而默默地更改，并且大多数Linux发行版和现代窗口默认启用了这些更新。我们以前见过这个。如果您正在尝试运行可重复的基准，您应该始终重新运行整个套件，以便进行准确的比较，即使在相同的硬件上，也不仅仅是运行您认为已更改的内容。</p><p>  In writing the earlier blog entries on this topic, I was interested in the  performance aspects of this optimization, not its potential as an attack vector. However, merely by observing (and publishing) the results, the optimization was affected:  the system under measurement changed as a result of the observation. I can’t be sure that the optimization wouldn’t have eventually been disabled anyway, but it does seem that the proximate cause this change to the  microcode was my earlier post.</p><p>  在撰写本主题的早期博客条目时，我对这种优化的性能方面感兴趣，而不是其作为攻击矢量的潜力。但是，仅通过观察（和发布）结果，优化受到影响：由于观察结果，测量下的系统发生变化。我无法确保优化最终不禁用，但似乎近似原因这对微码的变化是我的早期帖子。 </p><p> I am not convinced that removing any optimization which can be used in a timing-based side channel is sustainable. I am not sure this is a thread you want to keep pulling on: practically  every aspect of a modern CPU can vary in performance and timing based on internal state  7. Trying to draw the security boundaries tightly around co-located entities (e.g., processes on the same CPU, especially on the same core), without allowing any leaks seems destined to fail without a complete overhaul of CPU design, likely at the cost of a large amount of performance. There are just too many holes to plug.</p><p>我不相信去除可以在基于时刻的侧通道中使用的任何优化是可持续的。我不确定这是一个要继续拉动的线程：实际上，现代CPU的各个方面都可以在基于内部状态7的性能和时序中变化。试图围绕共同位于实体紧密绘制安全范围（例如，进程在同一CPU，特别是在同一核心上），在没有完全大修CPU设计的情况下，没有允许任何泄漏似乎无法进行故障，可能是大量性能的成本。插头只有太多孔。</p><p> I hope that once the wave of vulnerabilities and disclosures that started with Meltdown and Spectre beings to recede, we can start to work on a measured approach to classifying and mitigating timing and other side-channel attacks. This could start by enumerating which performance characteristics are reasonable guaranteed to hold, and which aren’t. For example, it could be specified whether memory access timing may vary based on the  value accessed. If it is allowed to vary, the zero store optimization would be allowed.</p><p> 我希望一旦漏洞的漏洞和披露的浪潮，令人遗憾地登出，我们就可以开始使用测量的方法来分类和减轻时机和其他侧频攻击。这可以首先枚举哪些性能特征是合理保证的，并且不是。例如，可以指定内存访问定时是否可以基于访问的值而变化。如果允许变化，则允许零存储优化。</p><p> In any case, I still plan to write about performance-related microarchitectural details. I just hope this outcome does not repeat itself.</p><p> 在任何情况下，我仍然计划写下与性能相关的微架立细节。我只是希望这一结果不再重复。</p><p>     If you have a question or any type of feedback, you can leave a  comment below.</p><p>     如果您有问题或任何类型的反馈，您可以在下面发表评论。</p><p>    Specifically, it uses   std::fill with a zero argument, with some inlining prevention, which ultimately results in a fill which uses a series of 32-byte vector loads and stores to store 256 bytes per unrolled iteration, with a loop body like this:</p><p>    具体来说，它使用STD ::填充零参数，其中包含一些内联的预防，这最终导致使用一系列32字节向量的填充物，存储器和存储存储256个字节，每个展开的迭代将256个字节存储在一起，具有这样的循环体：</p><p>  vmovdqu  YMMWORD  PTR  [ rax ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0x20 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0x40 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0x60 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0x80 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0xa0 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0xc0 ], ymm1 vmovdqu  YMMWORD  PTR  [ rax + 0xe0 ], ymm1</p><p>  vmovdqu ymmword ptr [rax]，ymm1 vmovdqu ymmword ptr [rax + 0x20]，ymm1 vmovdqu ymmword ptr [rax + 0x40]，ymm1 vmovdqu ymmword ptr [rax + 0x60]，ymm1 vmovdqu ymmword ptr [rax + 0x80]，ymm1 vmovdqu ymmword ptr [rax + 0xa0]，ymm1 vmovdqu ymmword ptr [rax + 0xc0]，ymm1 vmovdqu ymmword ptr [rax + 0xe0]，ymm1</p><p>  So the compiler does a good job: you can’t ask for much better than that.  ↩</p><p>  所以编译器做得很好：你不能要求比这更好。 ↩ </p><p>  I’m doing a bit of a retcon here. The effect is present as described based on the date, and I observed and benchmarked it “on Wednesday”, but the specific data series used for the plot were generated a week later when I had time to collect the data properly in a relatively noise free environment. So the two series were collected back-to-back on the same day, varying only the hidden parameter you’ll learn about two paragraphs from now.  ↩</p><p>我在这里做了一点retcon。根据日期描述的效果，我观察并在星期三开始标记并基准，但是当我有时间在相对噪声中正确地收集数据时，将生成一周的图情节的具体数据系列环境。因此，这两个系列在同一天重新收集，只有隐藏参数，您将从现在开始学习两个段落。 ↩</p><p>  To be clear, the  microcode is not persistent, so it needs to be loaded on  every boot. If you remove or downgrade the  intel-microcode package, you’ll be back to an older  microcode after the next boot. That is, unless you also update your BIOS which can  also come with a  microcode update: this will be persistent unless you downgrade your BIOS.  ↩</p><p>  要清除，微码不是持久的，因此需要在每个启动时加载。如果删除或降级Intel-Microcode包，您将返回下一个引导后的较旧的微代码。也就是说，除非您还更新您的BIOS，除非您的Microdode更新，否则这将是持久的，除非您降级BIOS。 ↩</p><p>  The new June 8th  microcode versions are  0xea for Skylake (versus  0xe2 previously) and  0xa6 for Ice Lake (versus  0xa0 previously).  ↩</p><p>  新的6月8日微码版本是SkyLake（先前与0xe2）的0xea，冰湖（先前与0xA0）的0xA6）。 ↩</p><p>    The performance regression shown in the plots is close to a worst case: the benchmark only fills zeros and nothing else. Real code doesn’t spend  that much time filling zeros, although zero  is no doubt the dominant value in large block fills, at least because the OS must zero pages before returning them to user processes and memory-safe languages like Java will zero some objects and array types in bulk.  ↩</p><p>    图中所示的性能回归靠近最坏的情况：基准仅填充零，而不是别的。实际代码不花那么多的时间填充零，虽然零是毫无疑问的大块填充中的主导价值，至少因为操作系统必须归零页面，然后将其进程返回给用户进程和Java等内存安全语言将零一些物体和批量中的数组类型。 ↩</p><p>  This observation becomes almost universal once you consider that the  values involved in any operation affect power use (see e.g.  Schöne et al or  Cornebize and Legrand). Since power use can be directly (e.g., RAPL or external measurements) or indirectly (e.g., because of heat-dependent frequency changes) observed, it means that in theory  any operation, even those widely considered to be constant-time, may leak information.  ↩</p><p>  一旦考虑任何操作涉及的值影响功率使用，这种观察将变为几乎是普遍的（参见例如Schöne等人或Cornebize和Legrand）。由于电力使用可以直接（例如，Rapl或外部测量）或间接地（例如，由于热依赖性频率变化）观察到，这意味着理论上任何操作，即使是那些被广泛认为是恒定时间的操作，也可能泄漏信息。 ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://travisdowns.github.io/blog/2021/06/17/rip-zero-opt.html">https://travisdowns.github.io/blog/2021/06/17/rip-zero-opt.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/slowed/">#slowed</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1067323.html"><img src="http://img2.diglog.com/img/2021/6/thumb_489e28a36a4ba4414c3aba6f8adbda24.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067323.html">科学家可能在金星内发现了构造活动 </a></div><span class="my_story_list_date">2021-6-22 8:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067263.html"><img src="http://img2.diglog.com/img/2021/6/thumb_f30835290feb985eb94b92448b74fe98.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067263.html">被赎金瓶帮派嵌入？ 付款可能是免税的 </a></div><span class="my_story_list_date">2021-6-22 2:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067239.html"><img src="http://img2.diglog.com/img/2021/6/thumb_27dac31ace458d4e4a7fab7a8e1106db.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067239.html">新的线索建议人们在30k年前大约到达美洲 </a></div><span class="my_story_list_date">2021-6-22 1:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067193.html"><img src="http://img2.diglog.com/img/2021/6/thumb_b9276b06c4dc9200ad8b21cc7eb2fac0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067193.html">人类比许多其他哺乳动物更依赖于水 </a></div><span class="my_story_list_date">2021-6-21 20:33</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>