<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重新考虑二元搜索（2018） Binary Search Reconsidered (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Binary Search Reconsidered (2018)<br/>重新考虑二元搜索（2018） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-26 00:34:48</div><div class="page_narrow text-break page_content"><p>There is a simpler invariant and simpler code that together have a few advantages: On the downside it still does log(size) comparisons evenif it finds the desired key on the first comparison.</p><p>有一个更简单的不变代码和一个更简单的代码，它们共同具有一些优点：不利的一面是，即使它在第一次比较中找到了所需的键，它仍然会进行log（size）比较。</p><p> The first version of this code - writtenwithout reference to Mike&#39;s code - had   n forthe size of the array. That was because it getschanged, and so no longer represents the size ofthe array, but instead represents the size of thesection still under consideration. I&#39;ve changedit to   n at Mike&#39;s suggestion to allow easiercomparison between my routine and his.</p><p> 该代码的第一个版本（未参考Mike的代码编写）的数组大小为n。那是因为它被更改了，因此不再代表数组的大小，而是代表仍在考虑中的节的大小。我已根据Mike的建议将其更改为n，以使我的日常工作与他的工作更容易进行比较。</p><p>    So here is the invariant I had in mind - it&#39;s verysimilar to Mike&#39;s: Note that I&#39;ve specified a half-open interval. int find(int a[], int size, int val) { int lower = 0; if (size&lt;=0) return -1; while (1) { if (size==1) return (val==a[lower]) ? lower : -1; int m = size/2; if (val&lt;a[lower+m]) size = m; else size -= m, lower += m; } return -1; /* Never used */ }</p><p>    因此，这里是我牢记的不变式-与Mike极为相似：请注意，我指定了一个半开区间。 int find（int a []，int size，int val）{int lower = 0;如果（size <= 0）返回-1;而（1）{if（size == 1）return（val == a [lower]）吗？较低：-1； int m =大小/ 2； if（val ＜a [lower + m]）size = m;否则大小-= m，下边+ = m; } return -1; /* 没用过 */ }</p><p> When we enter the   while loop we know   size is at least 1.After the test, size is at least 2, so 1&lt;=m&lt;=size. Thereforeit&#39;s valid to probe that location, and we can see that   sizeconstantly gets smaller, and so the test eventually succeeds andthe routine returns. We can check the invariant like this: In the first case we reduce the range of elements we&#39;re searchingover simply by reducing the value of   size. In the other casewe move up the lower bound by some amount and reduce the size bythe same amount. This can all equivalently be written using explicit upper and lowerbounds. Some people find this a retrograde step in simplicity andclarity, but it serves as a stepping stone. int find(int a[], int size, int val) { int lower = 0, upper=size; if (upper&lt;=0) return -1; while (1) { if (upper-lower==1) return (val==a[lower]) ? lower : -1; int m = (upper-lower)/2; if (val&lt;a[lower+m]) upper = m; else lower = m; } return -1; /* Never used */ }</p><p> 当我们进入while循环时，我们知道大小至少为1。测试后，大小至少为2，所以1 <= m <=大小。因此，探测该位置是有效的，并且我们可以看到大小不断减小，因此测试最终成功并且例程返回。我们可以这样检查不变量：在第一种情况下，我们只是通过减小size的值来减小搜索元素的范围。在另一种情况下，我们将下限上移一定量，并将大小减小相同量。所有这些都可以使用明确的上限和下限等效地编写。有人认为这是简单明了的逆行步骤，但却是垫脚石。 int find（int a []，int size，int val）{int lower = 0，upper = size;如果（upper＆lt; = 0）返回-1; while（1）{if（upper-lower == 1）return（val == a [lower]）吗？较低：-1； int m =（上下）/ 2; if（val ＜a [lower + m]）upper = m;否则更低= m; } return -1; /* 没用过 */ }</p><p> Here   size has been replaced by   upper-lower everywhere,with appropriate algebraic simplifications. We can now movethe return statement outside the   while loop: int find(int a[], int size, int val) { if (size&lt;=0) return -1; int lower = 0, upper=size; while (upper-lower&gt;1) { int m = lower+(upper-lower)/2; if (val&lt;a[m]) upper = m; else lower = m; } return (val==a[lower]) ? lower : -1; }</p><p> 在这里，大小已被适当的代数简化所取代。现在我们可以将return语句移到while循环之外：int find（int a []，int size，int val）{if（size＆lt; = 0）return -1; int lower = 0，upper = size; while（upper-lower＆gt; 1）{int m = lower +（upper-lower）/ 2; if（val ＜a [m]）upper = m;否则更低= m;返回（val == a [lower]）？较低：-1； }</p><p> Brief side point - sometimes we need to makecode messier in order to facilitate a re-write thatbecomes clearer than the original. This is perhapssomewhat akin to climbing down from a local maximumin hill-climbing so we can get to a higher - possiblyhighest - maximum the other side of the valley.</p><p> 简短的观点-有时我们需要使代码更混乱，以便于进行比原始代码更清晰的重写。这也许有点像从局部最大的山坡上爬下来，所以我们可以到达山谷另一侧的更高（可能最高）的最大值。</p><p> This version is even shorter and cleaner. The invariant saysthat   i - if it exists at all - is in the half-open interval  [lower,upper). That means that it&#39;s either in   [lower,m)or   [m,upper) and the code simply picks the correct one. There are other things to check. The arithmetic can neveroverflow, and we never access the array outside of the boundsthat the parameters guarantee exist. The value of   size (or its equivalent   upper-lower ) is strictly decreasing andpositive, so the loop terminates when it gets to 1. It looks pretty bullet-proof. (Famous last words) Note that I don&#39;t need to worry about signedness of variablesor possible overflow conditions, regardless of the languagevariant being used, because the structure of the code ensuresthat I never go outside the boundaries guaranteed by thevalues passed in. So let&#39;s think about the differences between this and theversion in the blog post. One difference is that this never terminates early. Italways takes   log(n) steps, and if there are equalkeys, it always returns the last one. That&#39;s aninteresting change in behaviour, and should be kept inmind. It makes the time behaviour consistent, but itmeans you don&#39;t get a quick result if you happen to belucky on an early guess. But looking at the code, we can see that we don&#39;t setone of the bounds (   lower and   lower+n ) to be outsidethe potential permitted probe locations. Mike&#39;s codesets   lower to   i+1, and you might need to worryabout whether that overflows. All this is quite &#34;fluffy&#34; and perhaps deservesexpansion, but I&#39;m reluctant to get drawn into theflame-wars that have often erupted around this issue.</p><p> 这个版本更短更干净。不变量说，i-如果存在，则处于半开区间[lower，upper]。这意味着它可以是[lower，m）或[m，upper），并且代码只是选择了正确的代码。还有其他要检查的事情。该算法永远不会溢出，并且我们绝不会在参数保证存在的边界之外访问数组。 size的值（或其等效的upper-lower）严格减小且为正值，因此该循环在达到1时终止。它看起来很防弹。 （著名的遗言）请注意，无论使用哪种语言变量，我都不必担心变量的符号性或可能的溢出条件，因为代码的结构确保了我永远不会超出传入值所保证的范围。因此，让我们考虑一下这与博客文章中的版本之间的区别。一个区别是，它永远不会尽早终止。 Italways始终执行log（n）步骤，并且如果有equalkeys，则始终返回最后一个。这是一个有趣的行为变化，应引起注意。它可以使时间行为保持一致，但是这意味着，如果您碰巧很早就猜中了，就不会很快得到结果。但是看一下代码，我们可以发现我们没有将边界范围（Lower和Lower + n）设置在潜在的允许探针位置之外。迈克（Mike）的密码集降低到i + 1，您可能需要担心它是否溢出。这一切都相当蓬松。也许值得扩展，但是我不愿意陷入围绕该问题经常爆发的火焰战争。 </p><p> Actually it doesn&#39;t, but the correctness of the secondroutine under potential overflow conditions is easierto reason about. In particular, reasoning as to whyMike&#39;s routine doesn&#39;t have a problem with overflow orunderflow requires reasoning about the specific flavourof C being used. My feeling is that somehow that meansthe reasoning is more &#34;brittle&#34; in some sense. I freelyagree that sometimes knowing such things is crucial, butif it can be avoided, then it brings under one&#39;s owncontrol issues that otherwise are pushed out to theimplementation. But none of that is conclusive. Is it simpler? Personally, I find the detailed reasoning from thisinvariant easier than in Mike&#39;s case, but perhaps that&#39;sjust selection bias. After all, I wrote this code, andMike wrote his, so perhaps the code reflects ourrespective ways of thinking.</p><p>实际上并没有，但是更容易推断出在潜在溢出条件下第二例程的正确性。 特别是，要对迈克的例程为什么没有上溢或下溢问题进行推理，需要对所使用的C的特定风味进行推理。 我的感觉是，这某种程度上意味着推理更加“脆弱”。 在某种意义上。 我自由地同意，有时知道这些事情是至关重要的，但是如果可以避免，那么它将带来一个自己的控制问题，否则这些问题将被推到实现上。 但是，这些都不是结论性的。 更简单吗？ 就个人而言，我发现从此不变式进行的详细推理比在Mike的情况下容易，但也许这只是选择偏见。 毕竟，我编写了这段代码，而迈克则编写了他的代码，所以也许该代码反映了我们各自的思维方式。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.solipsys.co.uk/new/BinarySearchReconsidered.html?TwoEqualsFour">https://www.solipsys.co.uk/new/BinarySearchReconsidered.html?TwoEqualsFour</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/重新考虑/">#重新考虑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/search/">#search</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>