<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>集合数据结构将我从痛苦的世界中解救出来</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">集合数据结构将我从痛苦的世界中解救出来</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 23:09:40</div><div class="page_narrow text-break page_content"><p>When we were taught the Set theory at school, I wondered why they dedicated an entire chapter in math to teach us about how to group items into categories. Isn’t it obvious that entities that have similar properties get clubbed together?</p><p>当我们在学校里被教授集合论时，我想知道为什么他们用了整整一章的数学来教我们如何将项目分类。具有相似属性的实体组合在一起不是很明显吗？</p><p> More than a decade later I realised that when they teach you something, maybe the entire topic is not as important as that one small nugget of information about this topic that might come in handy down the line.</p><p>十多年后，我意识到，当他们教给你一些东西时，也许整个主题并不重要，重要的是关于这个主题的一小部分信息，这些信息将来可能会派上用场。</p><p>     Why did this seemingly insignificant fact become the key to my mental sanity? And more importantly how did it help me prevent my codebase from turning into spaghetti?  ‍</p><p>为什么这个看似微不足道的事实会成为我精神健全的关键呢？更重要的是，它如何帮助我防止代码库变成意大利面？‍。</p><p>  I am building a  customer support tool where the CS agent can solve customer queries raised from multiple channels of communication.</p><p>我正在构建一个客户支持工具，CS工程师可以在其中解决从多个沟通渠道提出的客户问题。</p><p> So by its very design we required a UI element which indicated how many conversations are left unattended for each of the channels.</p><p>因此，根据其设计，我们需要一个UI元素来指示每个通道有多少对话处于无人值守状态。</p><p>    As you may have guessed, this information is being retrieved on every refresh of the browser page and therefore running a count query through the conversation database for each support channel on every refresh is not very efficient.</p><p>正如您可能已经猜到的那样，浏览器页面的每次刷新都会检索此信息，因此在每次刷新时通过对话数据库为每个支持渠道运行计数查询效率不是很高。</p><p> Sure, it may not be a big deal at first but if we scale to even half of what we plan to hit with this product, a query like this will bite me in the rear sooner than I would want it to.</p><p>当然，一开始这可能不是什么大事，但如果我们将规模扩大到我们计划使用该产品的一半，这样的查询将比我希望的更快地在背后咬我一口。</p><p>  The solution that occurred to me was to cache the count of open conversations for each support channel. This made sense at first but it quickly turned into a nightmare when I gave it a little more thought.</p><p>我想到的解决方案是缓存每个支持渠道的打开对话计数。起初这是有道理的，但当我再想一想时，它很快就变成了一场噩梦。</p><p> Okay so I plan to save a count of the open conversations in the cache, which means every time a conversation is opened I increment the count and every time a conversation is closed, I decrement the count?</p><p>好的，我计划在缓存中保存打开的对话的计数，这意味着每次打开对话时，我会递增计数，而每次关闭对话时，我会递减计数，这是不是意味着，每次打开对话时，我都会递增计数，而每次关闭对话时，我会递减计数？</p><p> Alright that doesn’t sound so bad but how do I trigger this increment/decrement operation? I suppose I could do it whenever a conversation gets updated in the database.</p><p>好的，这听起来不是很糟糕，但是我如何触发这个递增/递减操作呢？我想每当数据库中的会话更新时，我都可以这样做。</p><p>  But wait, I can’t trigger it every single time a conversation is updated, what if a conversation is open but some other data in the conversation gets updated while the status is still open?</p><p>但是等等，我不能在每次更新对话时都触发它，如果对话是打开的，但对话中的一些其他数据在状态仍为打开时被更新，该怎么办？</p><p> Do I have to write an if-else condition to run the increment/decrement operation only when status changes from open to closed or from closed to open?</p><p>只有当状态从打开更改为关闭或从关闭更改为打开时，我是否必须编写IF-ELSE条件才能运行递增/递减操作？</p><p> What happens if a conversation update finished running but the increment/decrement operation failed for some reason or vice versa? How do I re-run an update without corrupting the data?</p><p>如果会话更新完成运行，但递增/递减操作由于某种原因失败，或反之亦然，会发生什么情况？如何在不损坏数据的情况下重新运行更新？</p><p> In case you haven’t guessed where I was heading with this, here is a nice visual aid.</p><p>如果您还没有猜到我带着这篇文章要去哪里，这里有一个很好的视觉帮助。</p><p>     So how did Set theory get me out of this mess? What if I maintained a Set of IDs that belong to open conversations for each support channel?</p><p>那么集合论是如何让我走出困境的呢？如果我为每个支持渠道维护一组属于开放对话的ID，会怎么样？</p><p> All I have to do now is this: On every conversation update, if status is open, I add that conversation ID to the Set and I remove it from the Set if status is closed.</p><p>现在我要做的就是：在每次会话更新时，如果状态为打开，则将该会话ID添加到集合中，如果状态为关闭，则将其从集合中删除。</p><p> This Set would be stored on the RAM of course and yes it would take up more memory than storing just a single count for every support channel but all we are doing is storing IDs and not the entire data object so it would hardly cost much in terms of memory.</p><p>当然，该集合将存储在RAM上，是的，与仅为每个支持通道存储单个计数相比，它将占用更多内存，但我们所做的只是存储ID，而不是整个数据对象，因此它在内存方面几乎不会花费太多成本。</p><p> How does this help with the problem? Well, if you want the count of open conversations just get the number of elements in the Set, the cardinal number of the Set if you will.</p><p>这对解决问题有什么帮助呢？如果你想要打开对话的数量，只要得到集合中元素的数量，如果你愿意的话，就是集合的基数。</p><p>  Because a Set cannot have duplicates. It does not matter how many times I add an item to a Set, a unique conversation ID can be added to it only once and similarly once a remove operation is performed, subsequent remove operations on the same conversation ID won’t have an affect on the data. The data has become idempotent.</p><p>因为一个集合不能有重复项。无论我将一个项目添加到集合中多少次，唯一的对话ID只能添加一次，同样，一旦执行了删除操作，对同一对话ID的后续删除操作也不会对数据产生影响。数据已经变成了幂等项。</p><p> This means that I don’t need an if-else condition when a conversation update operation is performed. All I need to do is perform an add/remove operation based on the status of the conversation post update.</p><p>这意味着在执行会话更新操作时不需要if-Else条件。我所需要做的就是根据更新后对话的状态执行添加/删除操作。</p><p> It doesn’t matter if there is an explicit status update or not. Every update can trigger this logic and the data remains incorrupt. If any of the operations fail midway, the conversation update can just be re-run.</p><p>是否有显式状态更新并不重要。每次更新都可以触发此逻辑，并且数据保持不损坏。如果任何操作中途失败，只需重新运行会话更新即可。</p><p>     The most obvious way to do this is to use a JSON dictionary data structure like this for every support channel.</p><p>要做到这一点，最明显的方法是对每个支持通道使用类似这样的JSON字典数据结构。</p><p>    If a conversation needs to be added to the Set, update the dictionary with the key as the conversation id and value as true or 1. For remove operations first check if the conversation id is already in the dictionary and remove It from the dictionary. Do nothing if it’s not already present.</p><p>如果需要将会话添加到集合中，请使用关键字作为会话ID更新字典，并将值设置为true或1。对于删除操作，请首先检查会话ID是否已在字典中，然后将其从字典中删除。如果它还不存在，请不要执行任何操作。</p><p> This dictionary can now be stored in a variable in memory and used throughout the application. To get the count of open conversations for a support channel, just get the number of keys present in the dictionary.</p><p>该字典现在可以存储在内存中的变量中，并在整个应用程序中使用。要获取支持频道的打开对话计数，只需获取字典中存在的关键字数量即可。</p><p>  Clearly somebody else figured out the importance of a Set as a data structure way before I did, because  Redis - an elegant In memory database used for caching data already offers the Set data structure along with operations that let you add, remove and find number of items in a Set.</p><p>显然，其他人在我之前就意识到了集合作为数据结构的重要性，因为Redis-一个用于缓存数据的优雅的内存数据库-已经提供了集合数据结构以及允许您在集合中添加、删除和查找项目数量的操作。</p><p> I would highly recommend using this in your application instead of maintaining a dictionary in a variable because the good folks at Redis already solve a host of other problems that might occur as a result of maintaining an in-memory cache.</p><p>我强烈建议在您的应用程序中使用它，而不是在变量中维护字典，因为Redis的优秀人员已经解决了由于维护内存缓存而可能出现的许多其他问题。</p><p>     Perhaps there is some merit in revisiting some of the concepts we learnt as children and see if they are still relevant and can somehow be applied to the real world.</p><p>也许重温我们小时候学到的一些概念是有价值的，看看它们是否仍然相关，是否能以某种方式应用于现实世界。</p><p> At the very least this would give us closure and instil hope that maybe everything we were taught that seemed useless at the time has a certain aspect to it that might come in handy at some point or the other in our lives and we just have to keep our eyes, ears and most importantly our minds open.</p><p>至少，这会给我们一个了结，给我们灌输希望，也许我们学到的一切在当时看起来毫无用处，但在我们的生活中，可能会有某些方面派上用场，我们只需要保持我们的眼睛，耳朵，最重要的是我们的思想开放。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.sankalpjonna.com/posts/the-set-data-structure-saved-me-from-a-world-of-pain">https://www.sankalpjonna.com/posts/the-set-data-structure-saved-me-from-a-world-of-pain</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据结构/">#数据结构</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/集合/">#集合</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>