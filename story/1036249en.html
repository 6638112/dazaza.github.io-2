<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>与Nagle的算法和延迟的ACK有关的TCP性能问题（2005年）TCP Performance problems related to Nagle’s Algorithm and Delayed ACK (2005)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TCP Performance problems related to Nagle’s Algorithm and Delayed ACK (2005)<br/>与Nagle的算法和延迟的ACK有关的TCP性能问题（2005年）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 13:05:58</div><div class="page_narrow text-break page_content"><p>This page describes a TCP performance problem resulting from a little-known interaction between Nagle’s Algorithm and Delayed ACK. At least, I believe it’s not well known: I haven’t seen it documented elsewhere, yet in the course of my career at Apple I  have run into the performance problem it causes over and over again (the first time being the in the PPCToolbox over TCP code I wrote back in 1999), so I think it’s about time it was documented.</p><p>本页描述了由于Nagle的算法与延迟的ACK之间鲜为人知的相互作用而导致的TCP性能问题。至少，我认为它并不为人所知：我在其他地方都没有看到它的记载，但是在我的苹果职业生涯中，我一再遇到它引起的性能问题（第一次是在PPCToolbox中早在1999年我就写过TCP代码），所以我认为现在是时候对其进行记录了。</p><p> The overall summary is that many of the mechanisms that make TCP so great, like  fast retransmit, work best when there’s a continuous flow of data for the TCP state machine to work on. If you send a block of data and then stop and wait for an application-layer acknowledgment from the other end, the state machine can falter. It’s a bit like a water pump losing its prime — as long as the whole pipeline is full of water the pump works well and the water flows, but if you have a bit of water followed by a bunch of air, the pump flails because the impeller has nothing substantial to push against.</p><p> 总的来说，当TCP状态机需要持续不断的数据流运行时，使TCP如此出色的许多机制（例如快速重传）都将发挥最佳作用。如果发送数据块，然后停止并等待另一端的应用程序层确认，则状态机可能会失败。这有点像一台水泵失去了它的主要动力—只要整个管道都充满水，水泵就会运转良好并且水会流动，但是如果您有少量的水和一束空气，水泵就会发生故障，因为叶轮没有什么可推崇的。</p><p> If you’re writing a request/response application-layer protocol over TCP, the implication of this is you will want to make your implementation at least double-buffered: Send your first request, and while you’re still waiting for the response, generate and send your second. Then when you get the response for the first, generate and send your third request. This way you always have two requests outstanding. While you’re waiting for the response for request  n, request  n+1 is behind it in the return pipeline, conceptually pushing the data along.</p><p> 如果您要通过TCP编写请求/响应应用层协议，则这意味着您需要使实现至少具有双缓冲：发送第一个请求，而您仍在等待响应，生成并发送您的第二个。然后，当您获得第一个请求的响应时，生成并发送您的第三个请求。这样，您始终会有两个未完成的请求。在等待请求n的响应时，请求n + 1在返回管道中位于请求的后面，从概念上讲会推动数据的传递。</p><p> Interestingly, the performance benefit you get from going from single-buffering to double, triple, quadruple, etc., is not a linear slope. Implementing double-buffering usually yields almost all of the performance improvement that’s there to be had; going to triple, quadruple, or n-way buffered usually yields little more. This is because what matters is not the sheer quantity of data in the pipeline, but the fact that there is  something in the pipeline following the packet you’re currently waiting for. As long as there’s at least a packet’s worth of data following the response you’re waiting for, that’s enough to avoid the pathological slowdown described here. As long as there’s at least four or five packet’s worth of data, that’s enough to trigger a  fast retransmit should the the packet you’re waiting for be lost.</p><p> 有趣的是，从单缓冲变为两倍，三倍，四倍等等所获得的性能收益不是线性斜率。实施双缓冲通常可以带来几乎所有的性能提升；进行三倍，四倍或n路缓冲通常会产生更多的收益。这是因为重要的不是流水线中的大量数据，而是在您当前正在等待的数据包之后流水线中有东西的事实。只要您等待的响应中至少有一个数据包的数据价值，就足以避免此处所述的病态变慢。只要至少有四五个数据包的数据价值，就足以在您正在等待的数据包丢失时触发快速重传。</p><p>  In this document I describe my latest encounter with this bad interaction between Nagle’s Algorithm and Delayed ACK: a testing program used in WiFi conformance testing. This program tests the speed of a WiFi implementation by repeatedly sending 100,000 bytes of data over TCP and then waiting for an application-layer ack from the other to confirm its reception. Windows achieved the 3.5Mb/s required to pass the test; Mac OS X got just 2.7Mb/s and failed. The naive (and wrong) conclusion would be that Windows is fast, and Mac OS X is slow, and that’s that. The truth is not so simple. The true explanation was that the test was flawed, and Mac OS X happened to expose the problem, while Windows, basically through luck, did not.</p><p>  在本文档中，我描述了Nagle算法与“延迟的ACK”（WiFi一致性测试中使用的测试程序）之间的这种不良互动，最近遇到的情况。该程序通过在TCP上重复发送100,000字节的数据，然后等待对方的应用程序层确认以确认其接收，来测试WiFi实施的速度。 Windows达到了通过测试所需的3.5Mb / s； Mac OS X仅获得2.7Mb / s的故障。天真的（错误的）结论是Windows速度快，而Mac OS X速度慢，仅此而已。事实并非如此简单。真正的解释是测试存在缺陷，而Mac OS X恰好暴露了问题，而Windows靠运气却没有。</p><p> Engineers found that reducing the buffer size from 100,000 bytes to 99,912 bytes made the measured speed jump to 5.2Mb/s, easily passing the test. At 99,913 bytes the test got 2.7Mb/s and failed. Clearly what’s going on here is more interesting than just a slow wireless card and/or driver.</p><p> 工程师发现，将缓冲区大小从100,000字节减少到99,912字节，使测量的速度跃升至5.2Mb / s，轻松通过了测试。在99,913字节处，测试速度为2.7Mb / s，但失败了。显然，这里发生的事情不仅比慢速的无线网卡和/或驱动程序更有趣。</p><p> The diagram below shows a TCP packet trace of the failing transfer, which achieves only 2.7Mb/s, generated using  tcptrace and jPlot:</p><p> 下图显示了使用tcptrace和jPlot生成的失败传输的TCP数据包跟踪，仅达到2.7Mb / s：</p><p>  This diagram shows a TCP packet trace of the transfer using 99912-byte blocks, which achieves 5.2Mb/s and passes:</p><p>下图显示了使用99912字节块进行传输的TCP数据包跟踪，该跟踪达到5.2Mb / s并通过：</p><p>  In the failing case the code is clearly sending data successfully from 0-200ms, then doing nothing from 200-400ms, then sending again from 400-600ms, then nothing again from 600-800ms. Why does it keep pausing? To understand that we need to understand Delayed ACK and Nagle’s Algorithm:</p><p>  在失败的情况下，代码显然是在0-200ms内成功发送数据，然后在200-400ms内不执行任何操作，然后在400-600ms内再次发送，然后在600-800ms内不再执行任何操作。为什么一直停下来？要了解我们需要了解Delayed ACK和Nagle的算法：</p><p>  Delayed ACK means TCP doesn’t immediately ack every single received TCP segment. (When reading the following, think about an interactive ssh session, not bulk transfer.) If you receive a single lone TCP segment, you wait 100-200ms, on the assumption that the receiving application will probably generate a response of some kind. (E.g., every time sshd receives a keystroke, it typically generates a character echo in response.) You don’t want the TCP stack to send an empty ACK followed by a TCP data packet 1ms later, every time, so you delay a little, so you can combine the ACK and data packet into one. So far so good. But what if the application doesn’t generate any response data? Well, in that case, what difference can a little delay make? If there’s no response data, then the client can’t be waiting for anything, can it? Well, the application-layer client can’t be waiting for anything, but the TCP stack at the end  can be waiting: This is where Nagle’s Algorithm enters the story:</p><p>  延迟的ACK表示TCP不会立即确认收到的每个TCP段。 （阅读以下内容时，请考虑交互式ssh会话，而不是批量传输。）如果接收到一个单独的TCP段，则假设接收应用程序可能会生成某种响应，则等待100-200ms。 （例如，每次sshd每次收到击键，它通常都会在响应中生成一个字符回显。）您不希望TCP协议栈每次在1ms之后发送一个空ACK和一个TCP数据包，因此您要延迟一点，因此您可以将ACK和数据包合并为一个。到现在为止还挺好。但是，如果应用程序不生成任何响应数据怎么办？那么，在那种情况下，稍稍延迟会带来什么变化？如果没有响应数据，那么客户端将无法等待，可以吗？嗯，应用程序层客户端什么都不能等待，但是最后的TCP堆栈可以等待：这是Nagle的算法输入故事的地方：</p><p>  For efficiency you want to send full-sized TCP data packets. Nagle’s Algorithm says that if you have a few bytes to send, but not a full packet’s worth, and you already have some unacknowledged data in flight, then you wait, until either the application gives you more data, enough to make another full-sized TCP data packet, or the other end acknowledges all your outstanding data, so you no longer have any data in flight.</p><p>  为了提高效率，您希望发送完整尺寸的TCP数据包。 Nagle的算法表示，如果您要发送的字节数少，但没有完整的数据包的价值，并且您已经有一些未确认的数据在传输中，则请等待，直到应用程序为您提供了更多的数据，足以制作另一个完整的数据。 TCP数据包或另一端会确认您的所有未清数据，因此您不再有任何数据在传输中。</p><p> Usually this is a good idea. Nagle’s Algorithm is to protect the network from stupid apps that do things like this, where a naive TCP stack might end up sending 100,000 one-byte packets.</p><p> 通常这是一个好主意。 Nagle的算法旨在保护网络免受愚蠢的应用程序的攻击，这些愚蠢的应用程序会执行此类操作，因为一个幼稚的TCP堆栈可能最终会发送100,000个1字节数据包。</p><p>  The bad interaction is that now there  is something at the sending end waiting for that response from the server. That something is Nagle’s Algorithm, waiting for its in-flight data to be acknowledged before sending more.</p><p>  不良的交互是，现在发送端有些东西在等待服务器的响应。那就是Nagle的算法，它在发送之前等待其飞行中的数据被确认。</p><p> The next thing to know is that Delayed ACK applies to a single packet.If a second packet arrives, an ACK is generated immediately. So TCP will ACK every  second packet immediately. Send two packets, and you get an immediate ACK. Send three packets, and you’ll get an immediate ACK covering the first two, then a 200ms pause before the ACK for the third.</p><p> 接下来要知道的是，延迟ACK适用于单个数据包，如果第二个数据包到达，则会立即生成ACK。因此，TCP将立即对第二个数据包进行ACK。发送两个数据包，您将立即收到ACK。发送三个数据包，您将获得覆盖前两个数据包的即时ACK，然后在第三个数据包之前暂停200毫秒。</p><p> Armed with this information, we can now understand what’s going on. Let’s look at the numbers:</p><p>有了这些信息，我们现在可以了解发生了什么。让我们看一下数字：</p><p> 99,900 bytes = 68 full-sized 1448-byte packets, plus 1436 bytes extra100,000 bytes = 69 full-sized 1448-byte packets, plus 88 bytes extra</p><p> 99,900字节= 68个完整的1448字节数据包，外加1436字节100,000个字节= 69个完整的1448字节数据包，外加88个字节</p><p> With 99,900 bytes, you send 68 full-sized packets. Nagle holds onto the last 1436 bytes. Then:</p><p> 使用99,900字节，您发送68个全尺寸数据包。 Nagle保留最后1436个字节。然后：</p><p> Delayed ACK combines that one byte with its pending ACK packet, sends the combined TCP ACK+data packet promptly,</p><p> 延迟的ACK将一个字节与其待处理的ACK数据包结合在一起，并立即发送合并的TCP ACK +数据包，</p><p>  Now consider the 100,000-byte case. You send a stream of 69 full-sized packets. Nagle holds onto the last 88 bytes. Then:</p><p>  现在考虑100,000字节的情况。您发送69个全尺寸数据包的流。 Nagle保留最后88个字节。然后：</p><p> Delayed ACK means that the receiver won’t ACK this packet until it gets (a) some response data from the local process, or (b) another packet from the sender.</p><p> 延迟的ACK表示，接收者在收到（a）来自本地进程的某些响应数据，或（b）来自发送者的另一个数据包之前，不会对该数据包进行ACK。</p><p> The local process won’t generate any response data (a) because it hasn’t got the full 100,000 bytes yet.</p><p> 本地进程不会生成任何响应数据（a），因为它还没有完整的100,000字节。</p><p> The sender won’t send the last packet (b) because Nagle won’t let it until it gets an ACK from the receiver.</p><p>发送者将不会发送最后一个数据包（b），因为Nagle直到收到来自接收者的ACK才会允许它。</p><p>  Nagle won’t send the last bit of data until it gets an ACK</p><p>  Nagle在收到ACK之前不会发送最后一点数据</p><p> So, at the end of each 100,000-byte transfer we get this little awkward pause. Finally the delayed ack timer goes off and the deadlock un-wedges, until next time. On a gigabit network, all these huge 200ms pauses can be devastating to an application protocol that runs into this problem. These pauses can limit a request/response application-layer protocol to at most five transactions per second, on a network link where it should be capable of a thousand transactions per second or more. In the case of this specific attempt at a performance test, it should have been able to, in principle, transfer each 100,000-bytes chunk over a local gigabit Ethernet link in as little as 1ms. Instead, because it stops and waits after each chunk, instead of double-buffering as recommended above, sending each 100,000-byte chunk takes 1ms + 200ms pause = 201ms, making the test run roughly  two hundred times slower than it should.</p><p> 因此，在每100,000字节传输结束时，我们会得到一个尴尬的暂停。最终，延迟的ack定时器关闭，死锁解除，直到下一次。在千兆网络上，所有这些巨大的200ms暂停可能会对遇到此问题的应用程序协议造成毁灭性的破坏。这些暂停可以将请求/响应应用程序层协议限制为每秒最多5个事务，而该网络链路应该每秒可以处理1000个事务或更多。在进行性能测试的这种特定尝试的情况下，原则上应该能够在短至1ms的时间内通过本地千兆位以太网链路传输每个100,000字节的块。相反，因为它停止并在每个块之后等待，而不是按照上面的建议进行双缓冲，所以发送每个100,000字节的块需要1毫秒+ 200毫秒的暂停= 201毫秒，这使测试的运行速度比实际运行速度慢了大约200倍。</p><p>  On Windows the TCP segment size is 1460 bytes. On Mac OS X and other operating systems that add a TCP time-stamp option, the TCP segment size is twelve bytes smaller: 1448 bytes.</p><p>  在Windows上，TCP段大小为1460个字节。在Mac OS X和其他添加了TCP时间戳选项的操作系统上，TCP段大小减小了十二个字节：1448个字节。</p><p> What this means is that on Windows, 100,000 bytes is 68 full-sized 1460-byte packets plus 720 extra bytes. Because 68 is an even number, by pure luck the application avoids the Nagle/Delayed ACK interaction.</p><p> 这意味着在Windows上，100,000个字节是68个全尺寸的1460个字节的数据包加上720个额外的字节。由于68是偶数，因此，靠运气，应用程序避免了Nagle / Delayed ACK交互。</p><p> On Mac OS X, 100,000 bytes is 69 full-sized 1448-byte packets, plus 88 bytes extra. Because 69 is an odd number, Mac OS X exposes the application problem.</p><p> 在Mac OS X上，100,000个字节是69个完整的1448字节数据包，外加88个字节。由于69是奇数，因此Mac OS X暴露了应用程序问题。</p><p> A crude way to solve the problem, though still not as efficient as the double-buffering approach, is to make sure the application sends each semantic message using a single large write (either by copying the message data into a contiguous buffer, or by using a scatter/gather-type write operation like sendmsg) and set the TCP_NODELAY socket option, thereby disabling Nagle’s algorithm. This avoids this particular problem, though it can still suffer other problems inherent in not using double buffering — like, if the last packet of a response gets lost, there are no packets following it to trigger a  fast retransmit.</p><p> 解决该问题的一种粗略方法（尽管仍不如双缓冲方法有效），是确保应用程序使用单个大写操作发送每个语义消息（通过将消息数据复制到连续缓冲区中，或通过使用分散/聚集类型的写操作（如sendmsg），并设置TCP_NODELAY套接字选项，从而禁用Nagle的算法。这避免了这个特殊问题，尽管它仍然会遭受不使用双重缓冲的其他固有问题，例如，如果响应的最后一个数据包丢失，则紧随其后的数据包将不会触发快速重传。</p><p>  While the double-buffering approach advocated here (keep making forward progress instead of blocking and waiting until each individual operation completes one at a time) remains the best solution, advances in networking code have now mitigated this specific Nagle’s algorithm deadlock.</p><p>尽管这里提倡的双缓冲方法（保持进步而不是阻塞并等待每个操作一次完成）仍然是最好的解决方案，但是网络代码的进步现已缓解了这一特定的Nagle算法死锁。</p><p> Mac OS X v10.5 “Leopard”, released October 2007, and later updates, including iOS, implement Greg Minshall’s “Proposed Modification to Nagle’s Algorithm”, which he documented back in December 1998. I do not know the implementation status in other operating systems.</p><p> Mac OS X v10.5“ Leopard”（于2007年10月发布）以及后来的更新（包括iOS）实现了Greg Minshall的“ Nagle's Algorithm的拟议修改”，他于1998年12月记录了该文件。我不知道其他操作系统的实现状态系统。</p><p> Nagle’s algorithm says that if you have any unacknowledged data outstanding, then you can’t send a runt packet. Minshall’s Modification softens this rule a little to say that if you already have an unacknowledged  runt packet outstanding, then you can’t send another. In other words, you’re allowed one free pass. You’re allowed to have one runt packet in flight at a time, but only one. Multiple runt packets still not allowed because of the harm that would do to the network. A badly-written application that’s doing lots of small writes back-to-back will still have those writes coalesced into more efficient large packets, but an application that does a single large write will not have the tail end of that write delayed. The single runt packet at the end of a large write doesn’t get delayed, because the preceding outstanding packets are all full-sized packets.</p><p> Nagle的算法说，如果您有未确认的任何未完成数据，则无法发送欠缺数据包。 Minshall的Modification修改了此规则，只是说如果您已经有未确认的欠缺数据包，那么您将无法再发送。换句话说，您可以免费获得一张通行证。您一次只能飞行一个矮子包，但只能一个。由于会对网络造成危害，因此仍然不允许多个欠缺数据包。一个写得不好的应用程序会接连执行大量小写操作，这些写操作仍会合并到更有效的大数据包中，但是执行单个大写操作的应用程序将不会延迟该写操作的结尾。大写末尾的单个欠幅数据包不会延迟，因为前面的未完成数据包都是全尺寸数据包。</p><p> The importance of not disabling Nagle’s algorithm was spelled out in  Greg Minshall’s email:</p><p> Greg Minshall的电子邮件阐明了不禁用Nagle算法的重要性：</p><p> Please note that while, in certain cases, the current Nagle algorithm can have a negative performance impact for certain applications, turning OFF the Nagle algorithm can have a very serious negative impact on the internet. Thus, nothing in this e-mail message, or in the enclosed draft, should be taken as advice to any application developer to disable the Nagle algorithm. The current Nagle algorithm is very important in protecting the health of the internet; the proposed modification [hopefully] provides the same level of protection.</p><p> 请注意，尽管在某些情况下，当前的Nagle算法可能会对某些应用程序产生负面的性能影响，但关闭Nagle算法可能会对互联网造成非常严重的负面影响。因此，此电子邮件消息或随附的草稿中的任何内容均不应作为建议，禁止任何应用程序开发人员禁用Nagle算法。当前的Nagle算法对于保护互联网的健康非常重要。提出的修改（希望）提供相同级别的保护。</p><p>  Page maintained by  Stuart Cheshire</p><p>  页面由Stuart Cheshire维护</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.stuartcheshire.org/papers/NagleDelayedAck/">http://www.stuartcheshire.org/papers/NagleDelayedAck/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据包/">#数据包</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>