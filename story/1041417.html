<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>高级TypeScript类型技巧 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">高级TypeScript类型技巧 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-23 21:12:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/ec0ad71bc573ec8f829afc5858c2bb69.jpg"><img src="http://img2.diglog.com/img/2020/12/ec0ad71bc573ec8f829afc5858c2bb69.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>在TypeScript中花了一些时间之后，您可能会开始渴望生活中到处的类型安全。 JavaScript本质上是一种不安全的语言，几乎在每个框架中到处都有龙。大多数框架已被充分介绍，但是如果您在内部设计一个漂亮的API，那么它需要具有令人难以置信的功能丰富和令人难以置信的安全性，但仍需要最好的JavaScript习惯用法，该怎么办。那么到那时，您可能不得不投入一些漂亮的粗糙类型的编写。</p><p> 通常，这里有许多TypeScript TYPE库，例如ts-toolbelt，实用程序类型，type-fest等。这些库很棒，并且包含大量信息，但是在描述它们创建实用程序类型的方式时，它们通常很少。</p><p> 有很多很棒的类型库，但是没有很好的关于它们如何构建的文档</p><p> 这篇文章的目的不仅是公开一些出色的实用程序类型，而且还包括我在开发过程中意识到的一些技巧。不幸的是，这篇文章需要对TypeScript类型和技巧有相对深入的了解。高级类型是潜水之前开始的好地方！</p><p>  其中许多解决方案（和问题）可能会让人感到深奥，这是因为坦率地说它们确实如此。它们不是为胆小者准备的，不需要为日常使用TypeScript而闻名。这是为难以置信的复杂或不确定的JavaScript问题编写类型库的现实。</p><p> 这些类型中的大多数来自一些正在使用的TypeScript库，即安全模式和mongo-safe，我打算在以后对这两种类型进行冗长的博客文章。</p><p> 我已尝试通过用法示例以及问题或解决方案新颖或有趣的原因来组织这些工作。它们没有特定的顺序。 </p><p>//优质鞋类＆lt; ＆ =花式＆lt;亮度＜深深地＆lt;嵌套＆ ＆gt;＆gt;＆gt;扩展推断TItem吗？ {item：TItem} | TItem | [TItem，TItem] | [TItem]：不可能；类型Impossible = never；</p><p>  有时，您将需要在类型定义中反复使用相同的类型。每次TypeScript遇到您的类型时，都必须再次对其进行评估。使用推断技巧，您可以将变量存储在类型中，以便在其余所有变量中使用。</p><p> 您将在几个地方看到此扩展推断技巧。推断具有一些有趣的属性，使其在定义复杂类型时很有用。</p><p> 注意此处使用Impossible。我们永远无法到达“不可能”分支，因此通常我们在这里不会指定“永不分支”，但我发现，将来再次查看这些类型时，只要再考虑“永不分支”，就永远不要把“永不存在”混淆。使用可解析为基本类型的显式类型别名是在定义中显式的一种好方法。</p><p> 注意：如果您输入的结果永远不会，则此方法将无效。如果T或Fancy＆lt; Shumancy＆lt; Dested＆lt; Nested＆lt;＆gt;。永远不会，整个表达式将永远不会。</p><p>    //错误类型的鞋子＆lt; ＆ = T永远不会延伸？ 1：0；类型Test1 =鞋子＆lt; ＆＃39; hi＆＃39; ＆gt ;; // 0 type Test2 = Shoes＆lt;永不＆gt ;; //从不</p><p> //优质鞋类＆lt; ＆ = [T]延伸[从不]？ 1：0； // ^ ^ ^ ^ ^类型Test1 =鞋子＆lt; ＆＃39; hi＆＃39; ＆gt ;; // 0 type Test2 = Shoes＆lt;永不＆gt ;; // 1 </p><p>要永远测试都不容易。一旦表达式中的一种类型从不存在，它将毒化表达式的其余部分，使其评估为永不。通常，这是一个有用的功能，但是当您实际上不需要检查时，可以将表达式包装在元组中。这将使TypeScript编译器欺骗苹果，而不是扩展从不。</p><p> 它通过将元组T与永不比较元组来工作。我们在许多地方都使用了这个元组把戏。除了元组使TypeScript在评估时不太贪婪之外，我不确定它为什么起作用。</p><p>     //错误类型的鞋子＆lt; T1，T2，T3＞ = T1扩展了{}？ （T2扩展数字？（T3扩展字符串？1：0）：0）：0；</p><p> //优质鞋类＆lt; T1，T2，T3＞ = [T1延伸{}？ 1：0，T2扩展号码？ 1：0，T3扩展了什么？ 1：0]扩展[1，1，1]？ 1：0;</p><p>  您将经常需要深入检查一些事情，并且仅在所有值都是确定值时才执行一些逻辑。这可能会导致令人讨厌的深层嵌套结构。</p><p> 一个干净的解决方案是在一个元组中预先检查所有这些对象，并将其与每个对象的预期结果进行比较。现在您的树只有一层深，您的意图更加清晰了！</p><p>    //错误的类型StringToObject＆lt; ＆ = T延伸字符串？ {[T中的键]：布尔值}：从不；类型UnionToObject＆lt; ＆ = StringToObject＆lt; T＆gt ;;类型Nested＆lt; ＆ = {[T的键]：UnionToObject＆lt; T [key]＆gt;}; const value：嵌套＆lt; {thing：＆＃39; a＆＃39; | ＆＃39; b＆＃39; | ＆＃39; c＆＃39;}＆gt; { //没有错误 </p><p>//好的类型StringToObject＆lt; ＆ = [T]扩展[字符串]？ {[T中的键]：布尔值}：从不； //类型^ UnionToObject＆lt; ＆ = StringToObject＆lt; T＆gt ;;类型Nested＆lt; ＆ = {[T的键]：UnionToObject＆lt; T [key]＆gt;}; const value：嵌套＆lt; {thing：＆＃39; a＆＃39; | ＆＃39; b＆＃39; | ＆＃39; c＆＃39;}＆gt; { //错误缺少＆＃39; b＆＃39;</p><p>  有时您会非常深地通过工会，以至于工会到达其最终目的地时，工会已被分发。如上所述，这可能导致意外的行为。由于联合已经分发，因此第一个示例中的value将导致类型</p><p>   解决方案是将T封装在一个元组中，以强制TypeScript不在后续表达式中分配联合。</p><p>    // Bad type Bad = {shoes：never;其他：布尔值}常量值：错误= {鞋子：1，其他：true}； //在鞋子上抛出错误，但智能感知和类型误导</p><p> //良好的导出类型ExcludeNever＆lt; ＆ = {[T中的key作为T [key]永远不会扩展？从不：key]：T [key];}; const值：ExcludeNever＆lt;不好= {鞋：1，其他：true} //引发完全错误并且没有智能提示</p><p>  有时，您将处理Record中的某些类型并将值设置为Never。这是完全有效的，并且当用户尝试在其中输入值时会抛出错误。</p><p> 问题是，intellisense不会将此键从结果列表中排除。确保类型永远不会，但是由于键仍然存在，因此您可以在其中放置一个值。 </p><p>解决方案是使用新的TypeScript作为语法，在适当的时候将密钥设置为never，这样用户将无法使用它。</p><p> 注意：最终结果是相同的，您不能为鞋子添加值，但是第二种情况下DX有了显着改进。</p><p>       现在，这一点有点难以解释，但是很容易成为本文中最强大的技巧之一。它节省了我的培根太多次了。</p><p> 上面的示例是故意稀疏的，因为很难找到真实的示例。在需要时，您会知道的。</p><p> 在使一个复杂的库完全具有类型安全性的过程中，不可避免地会创建一个潜在地无限嵌套的类型。</p><p> 有一点背景：TypeScript的规则是，在举起手来解决可怕的“类型实例化过深甚至可能无限”之前，它通常不会深入到大约50个级别的类型检查。这意味着您的类型过于复杂，需要花费很长时间进行评估，因此不会。</p><p> 我会说这90％的时间是由于您的代码中的一个问题可以解决的，而无需使用欺骗手段。通常，您在某个地方搞砸了。但是，在极少数情况下，您可以正确地进行所有操作，可以对类型进行适当的优化，但是实际上，您的库要求确实可以解决问题，您可以使用上述技巧。 </p><p>它的工作方式对我来说还是个谜。这是我从令人难以置信的ts-toolbelt库中学到的技巧。我能说的最好的是，它推迟了对类型T的求值，直到真正需要它为止。这意味着只是因为您的类型可以无限嵌套，所以将根据用法而不是总括语句来测试此结果。</p><p> 也就是说，如果您传递的T确实耗尽了50个上限，那么TypeScript一定会让您知道，但是在此之前，所有表现良好的T都将继续起作用。</p><p> 我不知道上面的解释是否正确，不希望被更正！根据我的经验和研究，这就是它的工作原理。</p><p>     类型深度= 1 | 2 | 3 | 4 | 5;输入NextDepth＆lt; TDepth扩展深度。 = TDepth扩展1？ 2：TDepth扩展2？ 3：TDepth扩展3？ 4：TDepth扩展4？ 5：从不；导出类型SafeTypes =数字|字符串布尔|日期导出类型DeepKeys＆lt; T扩展{}，TDepth扩展深度＝ 1＆gt;。 = TDepth扩展5？ // ^^这是要检查的＆＃39;＆＃39; ：{{[keyof T中的键]：键扩展字符串？ T [key]扩展SafeTypes吗？ `$ {key}`：T [key]扩展{}？ `$ {key}`| | `$ {key}。 $ {DeepKeys＆lt; T [key]，NextDepth＆lt; TDepth＆gt; ＆gt; }`：// ^^这就是魔法never：never; };</p><p>  这是一个现实的例子，说明这个问题可能并不常见，但我遇到了多次。使用新的TypeScript 4.1字符串模板语法（这是令人难以置信的），您现在可以生成代表深层嵌套对象的字符串联合。</p><p> 问题是TypeScript中的并集只能有这么多成员，因此根据对象的复杂程度和深度嵌套，您可能会浪费掉这个数量。</p><p> 上面提出的解决方案远非理想，随着使用量的增加最终会中断，但是对于如何构建类型系统，这是值得思考的更多内容。 </p><p>我在这里选择的折衷办法只是限制嵌套。我决定，开发人员必须自己决定，我最多只能保持5级安全。这适用于我的一个项目的一个用例，但是您的工作量可能会有所不同！</p><p>    / *设置* /类型SomeType = / ** /;函数doThing＆lt; TTable，TLookupKey＆gt;（参数：{tableName：字符串，键：TLookupKey}）：TTable； / *烦人* / doThing＆lt; SomeType，＆＃39;鞋子（{key：＆＃39; shoes＆＃39 ;, tableName：＆＃39; Shoe＆＃39;}）; // // ^ ^必须同时指定:-( / *理想* / doThing＆lt; SomeType＆gt;（{key：＆＃39; shoes＆＃39 ;, tableName：＆＃39; Shoe＆＃39;}）; //仅^ / * Magical Compromise * /类型TableName＆lt; TTable＆gt; =字符串＆amp; {__table：TTable};导出函数tableName＆lt; TTable扩展{}＆gt;（tableName：string）：TableName＆lt; TTable＆gt; {返回tableName作为TableName＆lt; TTable＆gt ;;}函数doThing＆lt; TTable，TLookupKey＆gt;（参数：{tableName：TableName＆lt; TTable＆gt ;,键：TLookupKey}）：TTable; doThing（{key：＆＃39; shoes＆＃39 ;, tableName：tableName＆lt; SomeType＆gt; （＆＃39; Shoes＆＃39;）}）; // ^均不指定！</p><p>  好吧，也许这是一个延伸，但我个人认为这是这里最酷的把戏，当我意识到自己的潜力正在陷入僵局时。</p><p>  请参阅，TypeScript将根据使用情况推断通用类型，但仅当可以推断所有类型时。如果不能，则必须自己提供所有类型。充其量这可能是一件繁琐的事情，更糟的是这是不可能的。</p><p> 我们这里的解决方案是使用一个实际上只是一个字符串的不透明类型，但使用它来携带一些额外的类型数据，然后我们将这些数据作为tableName参数传递。这使TypeScript具有足够的类型信息来正确地推断TTable，而不会迫使我们手动提供类型！</p><p>     在此过程中，我创建或策划了一些我很少看到的有用类型，或者至少解释了它们为何有用。</p><p>   尽管它看起来很明显且人为设计，但有时您还是想在一个您有信心的类型上查找一个键，即使TypeScript不确定。解决方案是检查该键是否在您的类型中存在，但这需要您再嵌套一次表达式，这充其量会让您感到烦恼，最糟糕的是可能会使您的50个输入深度变大。解决方案是使用简单的Lookup类型，该类型在其无效时从不返回。 </p><p>与上述相同，当您拥有一个知道可以扩展另一种类型的类型，但是您不在TypeScript同意而无需断言的地方时，Cast将为您完成工作而不嵌套您的表达式。</p><p>   类型DiscriminateUnion＆lt; T，TField扩展T的键，TValue扩展T [TField] = T扩展了{[TField中的字段]：TValue}？ T：从不；类型Query = {类型：＆＃39; a＆＃39 ;，数字：1} | {类型：＆＃39; b＆＃39;字符串：＆＃39; 1＆＃39; };类型OnlyTypeA = DiscriminateUnion＆lt;查询，类型＆＃39; a＆＃39;＆gt;</p><p> 这是另一种典型的方法，您需要时才需要。传统观点认为，仅将联合的每个部分存储为单独的类型然后从那里去，但这并不总是很方便或不可能的。这种类型将使您仅拥有一部分工会的具体版本。</p><p>   类型LinkedList＆lt; T，Last = never＆gt; = T扩展为只读[推断头，...推断尾巴]？ {Item：头；下一个：LinkedList＆lt;尾巴，头＆gt;}：从不；类型LinkedListReverse＆lt; T扩展了只读unknown []，Last = never＆gt; = T扩展为只读[推断头，...推断尾巴]？ LinkedListReverse＆lt;尾巴，{项目：头部； Last：Last}＆gt; ：{Last：Last;项目：从不}；</p><p> 类型LinkedListResult = LinkedList＆lt; [{{$ match：{someId：＆＃39; ah＆＃39;}}，{$ project：{someValue：＆＃39; $ someId＆＃39;}}，{$ group：{_id ：＆＃39; $ someValue＆＃39;}}，{$ sort：{someValue：1}}]＆gt ;; / * {项目：{$ match：{someId：＆＃39; ah＆＃39 ;; }; };下一步：{项目：{$ project：{someValue：＆＃39; $ someId＆＃39 ;; }; };下一个：{项目：{$ group：{_id：＆＃39; $ someValue＆＃39 ;; }; };下一步：{项目：{$ sort：{someValue：1； }; };下一步：永不； }; }; }; } * / //现在，您可以像这样遍历链接列表：键入Process＆lt; T，TValue＞ = / *？* /类型TraverseLinkedList＆lt; T，LNL下一个> = [LookupKey＆lt; LNLNext，＆＃39; [Next]扩展[从不]？处理＆lt;查找键＆lt; LNLNext，＆＃39;项目＆＃39;＆gt; ＆gt; ：TraverseLinkedList＆lt; T，LookupKey＆lt; LNLNext，＆＃39;下一个＆gt;扩展推断J？处理＆lt; J，LookupKey＆lt; LNLNext，＆＃39;项目＆＃39;＆gt; ＆gt; ：不可能；类型Result = TraverseLinkedList＆lt; {}，LinkedListResult;</p><p> 从前，我需要将元组转换为LinkedList，以简化元组数组的处理。我不希望这对任何人都有用，但这是一个不错的练习，可能会迫使您以稍微不同的方式考虑构建类型。</p><p> 这有一个问题，即您的元组中可能限制为大约30个项目（50个限制减去TraverseLinkedList中的嵌套）。结果，我没有将它用于解决方案，因为我不想限制用户。 </p><p>我希望这些提示和技巧对您有所帮助。 我希望这会引起更多的类型工程师来记录构建复杂的TypeScript类型的令人费解的难题。 我希望在以后的文章中记录一些调试复杂类型的方法，并深入探讨如何使MongoDB聚合类型安全。  如果您有任何疑问或意见，请随时在Twitter上与我联系！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://casualdeveloper.net/post/2020-12-21-advanced-typescript-type-tricks/">https://casualdeveloper.net/post/2020-12-21-advanced-typescript-type-tricks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1041133.html"><img src="http://img2.diglog.com/img/2020/12/thumb_da2f3d93ae3232f1c6fa29c3029b2eb1.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041133.html">龙虾编程语言 </a></div><span class="my_story_list_date">2020-12-22 5:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1040019.html"><img src="http://img2.diglog.com/img/2020/12/thumb_7aa7350e7964a3de12bc7988c038a9dd.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1040019.html">Foo to Bar：Haskell中的命名约定 </a></div><span class="my_story_list_date">2020-12-16 14:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039796.html"><img src="http://img2.diglog.com/img/2020/12/thumb_4fd512bb8fa4e1811cf790f0e93b230e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039796.html">Nexus 1.0：类型安全，代码优先GraphQL API的主要版本 </a></div><span class="my_story_list_date">2020-12-15 16:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039356.html"><img src="http://img2.diglog.com/img/2020/12/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039356.html">瞄准类型的正确性 </a></div><span class="my_story_list_date">2020-12-13 6:32</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>