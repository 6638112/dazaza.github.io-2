<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Spry错误处理 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Spry错误处理 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-23 13:53:50</div><div class="page_narrow text-break page_content"><p>在Spry工作继续......小刺激。 :)我在我前面推迟的一件事太长了是错误处理。对SPRY感兴趣的人一直在询问它，是的，我决定开始掌握它。</p><p> 事实上，我去年写了这篇文章，但忘了完成并发布！</p><p> 错误处理是一个有趣的话题，早些时候在它周围争论并不是很大的争议，而是新技术（可选地等）的出现与制作的语言组合......“有趣”选择（我看着你去）公平地使这个主题成为了这个主题热的。所以我们想要什么样的气味？</p><p>  例外，错误等只是“不那么经常是预期的执行路径”。如果vanilla码路径为所有这些预期路径的杂波清洁，通常可以提高代码的清晰度。在某种形式中实现这一形式的一个共同机制当然是尝试捕获的术语处理方式。</p><p> 我希望大多数spry代码毫不陈醒。我也不想要语言中的概念太多，因为Spry本质上是简约的。</p><p> 有一件事已经添加了，我称之为捕获机制。基于呼叫堆栈的其余机制的大多数，该想法是将其作为基础。对于更高级的堆栈操作，堆栈逐渐被逐渐被弥合，但是在制作第一个SPRY调试器时将探讨更多。</p><p>  抛出错误并在适当的水平上捕获它们升高堆叠，从而避免了样板只是通过它们。还避免了代码的问题，期待适当的结果突然在他们手中遇到错误。 </p><p>多个返回，以便函数可以返回一个值和潜在错误，通常是独占的。  选项，将错误的想法和值填充到“结构”中，以便我们仍然返回“只是单一的东西”，但它可以包含适当的值或错误。  延期和errdefer，安装处理程序的想法始终在返回之前或仅在返回错误等之前返回。  如果函数可以返回错误，并且可能完全返回的错误，则显示开发人员的声明。  rebol将错误作为一种特定的基本价值类型，但几种语言将错误视为值（Go等）。  rebol使用“炸弹”诀窍，以便它可以返回适当的值，或者错误（如果在评估的情况下会爆炸）。  Smalltalk和Dylan（也许是clos）的有条件投掷捕获系统，表示堆栈未在执行处理程序搜索时展开。 这意味着在抛出后恢复。 </p><p>erlang是根本没有尝试从错误中恢复的想法，只需重新启动。这是一个很好的想法。</p><p> Smalltalk在控制结构上使用块，并且在卓越的处理中，例如：ifabsent：等。</p><p>   在SPRY中，我们现在有一个基本的捕获机制到位，这对于拨打电话来拨打“堆栈”是有用的，而不仅仅是错误。我开始使用sttcpw，所以...在名为“捕捉器”的激活记录中添加了一个插槽。将此插槽设置为代码块/ FUNC安装一个“GUARD”，如果在此激活中执行抛出，或在下面的激活中执行抛出，则会调用该“警卫”。这很简单，实现并充当错误处理的合理原始。</p><p>  foo = func [激活捕手：[回声（＆＃34;捕获了一个＆＃34;：香蕉）]回声＆＃34;扔一个香蕉...＆＃34;投掷＆＃34;香蕉＆＃34;] foo</p><p>   如果激活记录没有处理程序，则抛出将继续搜索，如果没有发现，它当前将进行硬进程退出1。</p><p> 通常，顶级激活记录应该捕获所有处理程序并进行合理的事情。</p><p> 与SmallTalk（和一些其他语言）抛出异常不会放松呼叫堆栈，所以处理正常回报的处理程序将返回到扔回到扔回去！除非它首先调用激活，否则如果是，返回将转到安装处理程序（尚未实现）的记录的调用者。事实上，最不令人惊讶的原则可能意味着我们应该交换这些行为:) </p><p>......所以这是什么？这是一种方法，所以它左侧需要一个接收器块。当我们运行方法时，我们处于新的激活状态，我们将捕集器设置为给定的处理程序块作为参数传递，然后我们执行自拍以执行可能抛出的接收器块。</p><p> 这使得能够从大多数语言中熟悉“范围”。下面我们看到它是行动：</p><p> foo = func [##这是一个激活级别捕手，只是为了显示我们从未到达IT激活捕手：[echo＆＃34;我们从未到达这个＆＃34;]＃在这里我们呼叫`捕获：`在带有处理器的街区块作为论据。 ＃这是多种语言中发现的经典尝试样式。 [回声＆＃34;投掷香蕉...＆＃34;投掷＆＃34;香蕉＆＃34; ]抓住：[回声（＆＃34;抓住了一个＆＃34;：香蕉）]] foo</p><p> ......它应该像以前一样打印，永远不会在foo中到达捕手:)</p><p>  如果err！= nil {...}不是我喜欢的话，那么返回款式多返回和吨。我可以了解哲学，但对不起，不喜欢它。特别是在SPRY尝试坚持的简约风格中。</p><p> 只有像Smalltalk这样的尝试条件系统有点无聊。它也可以相当令人困惑地调试，例如用空捕捉条款试用“吞下”沉默的错误，嵌套呼叫得到毛茸茸。它也可以模糊“香草案”很多。然而，它可以与其他机制组合形成“基础”。</p><p> 与更简单和不同的东西会很有趣！ Spry是一个实验！但不确定这将是什么...... </p><p>SPRY分享rebol的评估模型（有点ish），所以想法rebol拥有一个特殊的“炸弹”的简单性诱人，特别是在写Vanilla代码开始！</p><p> Spry有标记，我们应该能够以某种方式使用它，例如标记Funcs和方法。</p><p> 我希望尽可能长地编写香草代码，然后逐渐加强，例如单位测试结果。但我不希望硬化在香草代码中引入杂乱！因此，不知何故，我希望能够将错误处理作为“侧轨道”添加在vanilla代码中。</p><p> 在vanilla代码中没有内向处理“在侧面”的错误。 DEFER和ERRDEFER正在进行这种方向，它们是仅在满足某些规则时执行的代码块，但它们显然是分开的。</p><p> 我们可以抛出或返回。但我们也可以“信号”。信号是信号传导条件的中性方式，它并不意味着下一步，我们可以难以退出过程:)，或者我们总是可以记录它，然后扔掉，或者我们总是把它作为炸弹等。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://goran.krampe.se/2021/04/21/spry-error-handling/">http://goran.krampe.se/2021/04/21/spry-error-handling/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/spry/">#spry</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/error/">#error</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>