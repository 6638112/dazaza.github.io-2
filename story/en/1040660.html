<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>了解系统解析的DNS，拆分DNS和VPN配置 Understanding systemd-resolved, split DNS, and VPN configuration</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Understanding systemd-resolved, split DNS, and VPN configuration<br/>了解系统解析的DNS，拆分DNS和VPN配置 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-19 08:09:46</div><div class="page_narrow text-break page_content"><p>So,  systemd-resolved is enabled by default in Fedora 33. Most users won’t notice the difference, but if you use VPNs — or depend on DNSSEC, more on that at the bottom of this post — then systemd-resolved  might be big deal for you. When testing Fedora 33, we found  one bug report where a user discovered that systemd-resolved broke his VPN configuration. After this bug was fixed, and nobody reported any further issues, I was pretty confident that migration to systemd-resolved would go smoothly. Then Fedora 33 was released, and I noticed a significant number of users on Ask Fedora and Reddit asking for help with broken VPNs, problems that Fedora 33 beta testers had failed to detect. This was especially surprising to me because Ubuntu has enabled systemd-resolved by default since Ubuntu 16.10, so we were four full years behind Ubuntu here, which should have been plenty of time for any problems to be ironed out. So what went wrong?</p><p>因此，在Fedora 33中默认启用了systemd-resolved。大多数用户不会注意到其中的区别，但是如果您使用VPN-或依赖DNSSEC，则更多内容将在本文的底部-然后systemd-resolved可能会很大为您交易。在测试Fedora 33时，我们发现了一个错误报告，其中用户发现systemd-resolved破坏了他的VPN配置。修复此错误之后，没有人报告任何其他问题，我非常有信心向systemd-resolved的迁移将顺利进行。然后Fedora 33发布了，我注意到Ask Fedora和Reddit上有大量用户要求断开VPN的帮助，这些问题是Fedora 33 beta测试人员未能检测到的。自从Ubuntu 16.10起，Ubuntu就默认启用了systemd-resolved，这让我感到特别惊讶，因此我们在这里比Ubuntu落后了整整四年，这对于解决任何问题应该有足够的时间。那么出了什么问题？</p><p> First, let’s talk about how things worked before systemd-resolved, so we can see what was wrong and why we needed change. We’ll see how split DNS with systemd-resolved is different than traditional DNS. Finally, we’ll learn how custom VPN software must configure systemd-resolved to avoid problems that result in broken DNS.</p><p> 首先，让我们谈谈在systemd解决之前事情是如何进行的，以便我们可以找出问题所在以及为什么需要进行更改。我们将看到具有systemd-resolved的拆分DNS与传统DNS有何不同。最后，我们将学习自定义VPN软件如何配置systemd-resolved以避免导致DNS损坏的问题。</p><p> I want to note that, although I wrote the Fedora change proposal and have done some evangelism on behalf of systemd-resolved, I’m not a systemd developer and haven’t contributed any code to systemd-resolved.</p><p> 我想指出的是，尽管我写了Fedora变更建议并代表systemd-resolved进行了一些布道，但我不是systemd开发人员，也没有为systemd-resolved提供任何代码。</p><p>  Let’s first see how things worked before systemd-resolved. There are two important configuration files to discuss. The first is  /etc/nsswitch.conf, which controls which NSS modules are invoked by glibc when performing name resolution. Note these are glibc Name Service Switch modules, which are totally unrelated to Firefox’s NSS, Network Security Services, which unfortunately uses the same acronym. Also note that, in Fedora (and also Red Hat Enterprise Linux),  /etc/nsswitch.conf is managed by authselect and must not be edited directly. If you want to change it, you need to edit  /etc/authselect/user-nsswitch.conf instead, then run  sudo authselect apply-changes.</p><p>  首先，我们来看看在systemd-resolved之前事情是如何工作的。有两个重要的配置文件需要讨论。第一个是/etc/nsswitch.conf，它控制执行名称解析时glibc调用哪些NSS模块。请注意，这些是glibc名称服务交换模块，它们与Firefox的NSS网络安全服务完全无关，不幸的是，它们使用相同的首字母缩写。还要注意，在Fedora（以及Red Hat Enterprise Linux）中，/etc/nsswitch.conf由authselect管理，并且不能直接编辑。如果要更改它，则需要编辑/etc/authselect/user-nsswitch.conf，然后运行sudo authselect apply-changes。</p><p>   That means: first invoke nss-files, which looks at  /etc/hosts to see if the hostname is hardcoded there. If it’s not, then invoke nss-mdns4_minimal, which uses avahi to implement mDNS resolution.   [NOTFOUND=return] means it’s OK for avahi to not be installed; in that case, it just gets ignored. (Edit: this was wrong. Mantas mentioned in the comment below that this is to allow returning early for queries to .local domains, which should never go to the remaining nss modules.) Then most DNS resolution is performed by nss-dns. And finally, we have nss-myhostname, which is just there to guarantee that your own local hostname is always resolvable. Anyway, nss-dns is the key part here. nss-dns is what reads  /etc/resolv.conf.</p><p>   这意味着：首先调用nss-files，它查看/ etc / hosts以查看主机名是否在此处进行了硬编码。如果不是，请调用nss-mdns4_minimal，后者使用avahi实现mDNS解析。 [NOTFOUND = return]表示可以不安装avahi。在这种情况下，它只会被忽略。 （编辑：这是错误的。在下面的注释中提到的Mantas是为了允许尽早返回对.local域的查询，该查询永远都不应返回到其余的nss模块。）然后，大多数DNS解析都是由nss-dns执行的。最后，我们有nss-myhostname，用于确保您自己的本地主机名始终是可解析的。无论如何，nss-dns是这里的关键部分。 nss-dns读取/etc/resolv.conf。</p><p> Next, let’s look at  /etc/resolv.conf. This file contains a list of up to three DNS servers to use. The servers are attempted in order.  If the first server in the list is broken, then the second server will be used. If the second server is broken, the third server will be used. If the third server is also broken, then everything fails, because no matter how many servers you list here, all except the first three are ignored. In Fedora 32,  /etc/resolv.conf was, by default, a plain file managed by NetworkManager. It might look like this:</p><p> 接下来，让我们看一下/etc/resolv.conf。该文件包含最多三个要使用的DNS服务器的列表。按顺序尝试服务器。如果列表中的第一台服务器损坏，则将使用第二台服务器。如果第二台服务器损坏，将使用第三台服务器。如果第三台服务器也坏了，那么一切都会失败，因为无论您在此处列出多少台服务器，前三台服务器都将被忽略。在Fedora 32中，默认情况下/etc/resolv.conf是由NetworkManager管理的纯文件。它可能看起来像这样：</p><p>  That’s a pretty common example. It means that all DNS requests should be sent to my router. My router must have configured this via DHCP, causing NetworkManager to dutifully add it to  /etc/resolv.conf.</p><p>  这是一个很常见的例子。这意味着所有DNS请求都应发送到我的路由器。我的路由器必须已经通过DHCP进行了配置，这导致NetworkManager将其忠实地添加到/etc/resolv.conf中。 </p><p>  Traditional DNS is all well and good for a simple case like we had above, but turns out it’s really broken once you start adding VPNs to the mix. Let’s consider two types of VPNs: a privacy VPN that is always enabled and which is the default route for all web traffic, and a corporate VPN that only receives traffic for internal company resources. (To switch between these two different types of VPN configuration, use the checkbox “Use this connection only for resources on its network” at the bottom of the IPv4 and IPv6 tabs of your VPN’s configuration in System Settings.)</p><p>传统的DNS对于像我们上面这样的简单情况来说都是很好的，但是事实证明，一旦您开始向组合中添加VPN，它就真的被打破了。让我们考虑两种类型的VPN：一种始终启用且是所有网络流量的默认路由的隐私VPN，以及一种仅接收内部公司资源流量的公司VPN。 （要在这两种不同类型的VPN配置之间切换，请使用“系统设置”中VPN配置的“ IPv4”和“ IPv6”标签底部的“仅将此连接用于其网络上的资源”复选框。）</p><p> Now, what happens if we connect to both VPNs? The VPN that you connect to first gets listed first in  /etc/resolv.conf, followed by the VPN that you connect to second, followed by your local DNS server. Assuming the DNS servers are all working properly, that means:</p><p> 现在，如果我们同时连接两个VPN会怎样？您首先连接的VPN在/etc/resolv.conf中首先列出，其次是您连接的VPN，然后是本地DNS服务器。假设DNS服务器都正常运行，这意味着：</p><p> If you connect to your privacy VPN first and your corporate VPN second, all DNS requests will be sent to your privacy VPN, and you won’t be able to visit internal corporate websites. (This scenario is exactly why I become interested in systemd-resolved. After joining Red Hat, I discovered that I couldn’t access various redhat.com websites if I connected to my VPNs in the wrong order.)</p><p> 如果您先连接到隐私VPN，然后再连接到公司VPN，则所有DNS请求都将发送到您的隐私VPN，您将无法访问内部公司网站。 （这种情况正是我对systemd-resolve感兴趣的原因。加入Red Hat之后，我发现如果我以错误的顺序连接到我的VPN，就无法访​​问各种redhat.com网站。）</p><p> If you connect to your corporate VPN first and your privacy VPN second, then all your DNS goes to your corporate VPN, and none to your privacy VPN. As that defeats the point of using the privacy VPN, we can be confident it’s not what users expect to happen.</p><p> 如果您先连接到公司VPN，然后再连接到隐私VPN，则所有DNS都将转到公司VPN，而所有DNS都将不转到您的隐私VPN。由于这打破了使用隐私VPN的观点，因此我们可以确信，这不是用户期望发生的事情。</p><p> If you ever connect the VPNs in the opposite order — say, if your connection to one temporarily drops, and you need to reconnect — then you’ll get the opposite behavior. If you don’t notice this pattern behind the failures, it can make problems difficult to reproduce.</p><p> 如果您以相反的顺序连接VPN（例如，如果您的连接暂时断开，并且需要重新连接），那么您将获得相反的行为。如果您没有注意到故障背后的这种模式，则可能使问题难以重现。</p><p> You don’t need two VPNs for this to be a problem, of course. Let’s say you have no privacy VPN, only a corporate VPN.  Well, your employer may fire you if it notices DNS requests it doesn’t like. If you’re making 30 requests per hour to facebook.com, youtube.com, or more salacious websites, that sure looks like you’re not doing very much work. It’s really never in the employee’s best interests to send more DNS than necessary to an employer.</p><p> 当然，您不需要两个VPN就是一个问题。假设您没有隐私VPN，只有公司VPN。好吧，如果您的雇主发现DNS请求不受欢迎，可能会解雇您。如果您每小时要向facebook.com，youtube.com或其他色情网站提出30个请求，那么看来您做的工作并不多。向员工发送过多的DNS绝对不是员工的最大利益。</p><p> If you use only a privacy VPN, the failure case is arguably even more severe. Let’s say your privacy VPN’s DNS server temporarily goes offline. Then, because  /etc/resolv.conf is a list, glibc will fall back to using your normal DNS, probably either your ISP’s DNS server, or your router that forwards everything to your ISP. And now your DNS query has gone to your ISP. If you’re making the wrong sort of DNS requests in the wrong sort of countries — say, if you’re visiting websites opposed to your government — this could get you imprisoned or executed.</p><p> 如果仅使用隐私VPN，则故障情况可能会更加严重。假设您的隐私VPN的DNS服务器暂时离线。然后，由于/etc/resolv.conf是列表，因此glibc将退回到使用常规DNS的状态，可能是ISP的DNS服务器，或者是将所有内容转发到ISP的路由器。现在，您的DNS查询已转到您的ISP。如果您在错误的国家/地区提出错误的DNS请求-例如，如果您访问的政府网站与政府对立-这可能会使您入狱或被处决。 </p><p> Finally, either type of VPN will break resolution of local domains, e.g. fritz.box, because only your router can resolve that properly, but you’re sending your DNS query to your VPN’s DNS server. So local resources will be broken for as long as you’re connected to a VPN.</p><p>最后，任何一种VPN都会破坏本地域的解析，例如fritz.box，因为只有您的路由器才能正确解决该问题，但是您要将DNS查询发送到VPN的DNS服务器。因此，只要您连接到VPN，本地资源就会中断。</p><p> All things considered, the status quo prior to systemd-resolved was pretty terrible. The need for something better should be clear. Now let’s look at how systemd-resolved fixes this.</p><p> 考虑所有因素，systemd-resolve之前的现状非常糟糕。明确需要更好的东西。现在让我们看看systemd-resolved如何解决此问题。</p><p>  First, let’s look at  /etc/nsswitch.conf, which looks a bit different in Fedora 33:</p><p>  首先，让我们看一下/etc/nsswitch.conf，它在Fedora 33中看起来有点不同：</p><p>  nss-myhostname and nss-dns have switched places, but that’s just a minor change that ensures your local hostname is always local even if your DNS server thinks otherwise. The important change here is the addition of  resolve [!UNAVAIL=return]. nss-resolve uses systemd-resolved to resolve hostnames, via either its varlink API (with systemd 247) or its D-Bus API (with older versions of systemd). If systemd-resolved is running, glibc will stop there, and refuse to continue on to nss-myhostname or nss-dns even if nss-resolve doesn’t return a result, since both nss-myhostname and nss-dns are obsoleted by nss-resolve. But if systemd-resolved is not running, then it continues on (and, if resolving something other than the local hostname, will up using nss-dns and reading  /etc/resolv.conf, as before).</p><p>  nss-myhostname和nss-dns切换了位置，但这只是一个很小的更改，即使您的DNS服务器认为不是，也可以确保您的本地主机名始终是本地主机名。此处的重要更改是添加了解析[！UNAVAIL = return]。 nss-resolve通过其varlink API（与systemd 247一起使用）或D-Bus API（与systemd的旧版本一起使用）使用systemd-resolved解析主机名。如果systemd-resolved正在运行，则glibc将在那里停止，并且即使nss-resolve不返回结果，也拒绝继续使用nss-myhostname或nss-dns，因为nss已淘汰了nss-myhostname和nss-dns -解决。但是，如果systemd-resolved没有运行，则它将继续运行（并且，如果解析的不是本地主机名，则将像以前一样使用nss-dns并读取/etc/resolv.conf）。</p><p> Importantly, when nss-resolve is used, glibc does not read  /etc/resolv.conf when performing name resolution, so any configuration that you put there is totally ignored. That means any script or program that writes to  /etc/resolv.conf is probably broken.  /etc/resolv.conf still exists, though: it’s managed by systemd-resolved to maintain compatibility with programs that manually read  /etc/resolv.confand do their own name resolution, bypassing glibc.  Although systemd-resolved supports several different modes for managing  /etc/resolv.conf, the default mode, and the mode used in both Fedora and Ubuntu, is for  /etc/resolv.conf to be a symlink to  /run/systemd/resolve/stub-resolv.conf, which now looks like this:</p><p> 重要的是，使用nss-resolve时，glibc在执行名称解析时不会读取/etc/resolv.conf，因此您放置在此处的任何配置都将被完全忽略。这意味着写入/etc/resolv.conf的任何脚本或程序都可能已损坏。 /etc/resolv.conf仍然存在：它由systemd-resolved管理，以保持与手动读取/etc/resolv.conf并绕过glibc进行名称解析的程序的兼容性。尽管systemd-resolved支持几种不同的模式来管理/etc/resolv.conf，但默认模式以及Fedora和Ubuntu中使用的模式都是/etc/resolv.conf的符号链接，它是/ run / systemd / resolve的符号链接/stub-resolv.conf，现在看起来像这样：</p><p> # This file is managed by man:systemd-resolved(8). Do not edit.## This is a dynamic resolv.conf file for connecting local clients to the# internal DNS stub resolver of systemd-resolved. This file lists all# configured search domains.## Run &#34;resolvectl status&#34; to see details about the uplink DNS servers# currently in use.## Third party programs should typically not access this file directly, but only# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a# different way, replace this symlink by a static file or a different symlink.## See man:systemd-resolved.service(8) for details about the supported modes of# operation for /etc/resolv.conf.nameserver 127.0.0.53options edns0 trust-adsearch redhat.com lan</p><p> ＃此文件由man：systemd-resolved（8）管理。不要编辑。＃＃这是一个动态的resolv.conf文件，用于将本地客户端连接到＃systemd-resolved的内部DNS存根解析器。此文件列出了所有＃个配置的搜索域。＃＃运行＆＃34; resolvectl状态＆＃34;查看有关上行DNS服务器的详细信息＃当前正在使用。＃＃第三方程序通常不应直接访问此文件，而只能＃通过/etc/resolv.conf中的符号链接。要管理man：resolv.conf（5）＃以不同的方式，用静态文件或其他符号链接替换此符号链接。＃＃有关支持的以下模式的详细信息，请参见man：systemd-resolved.service（8）。＃/etc/resolv.conf的操作。域名服务器127.0.0.53选项edns0 trust-ad搜索redhat.com局域网</p><p> The redhat.com search domain is coming from my corporate VPN, but the rest of this  /etc/resolv.conf should look like yours. Notably, 127.0.0.53 is systemd-resolved’s local stub responder.  This allows programs that manually read  /etc/resolv.conf to continue to work without changes: they will just wind up talking to systemd-resolved on 127.0.0.53 rather than directly connecting to your real DNS server, as before.</p><p> redhat.com搜索域来自我的公司VPN，但是/etc/resolv.conf的其余部分应该看起来像您的。值得注意的是，127.0.0.53是systemd解析的本地存根响应器。这允许手动读取/etc/resolv.conf的程序无需更改即可继续运行：它们只会在127.0.0.53上与systemd-resolved对话，而不是像以前一样直接连接到真实的DNS服务器。 </p><p>  Although Ubuntu has used systemd-resolved for four years now, it has  not switched from nss-dns to nss-resolve, contrary to upstream recommendations. This means that on Ubuntu, glibc still reads  /etc/resolv.conf, finds 127.0.0.53 listed there, and then makes an IP connection to systemd-resolved rather than talking to it via varlink or D-Bus, as occurs on Fedora. The practical effect is that, on Ubuntu, you can still manually edit  /etc/resolv.conf and applications will respond to those changes, unlike Fedora. Of course, that would be a disaster, since it would cause all of your DNS configuration in systemd-resolved to be completely ignored. But it’s still possible on Ubuntu. On Fedora, that won’t work at all.</p><p>尽管Ubuntu已经使用systemd-resolve四年了，但它并未从nss-dns切换到nss-resolve，与上游建议相反。这意味着在Ubuntu上，glibc仍会读取/etc/resolv.conf，找到在那里列出的127.0.0.53，然后与systemd-resolved建立IP连接，而不是像Fedora那样通过varlink或D-Bus与之对话。实际的效果是，在Ubuntu上，您仍然可以手动编辑/etc/resolv.conf，与Fedora不同，应用程序将响应这些更改。当然，那将是一场灾难，因为这将导致systemd-resolved中的所有DNS配置都被完全忽略。但是在Ubuntu上仍然有可能。在Fedora上，这根本不起作用。</p><p> If you’re using custom VPN software that doesn’t work with systemd-resolved, chances are it probably tries to write to  /etc/resolv.conf.</p><p> 如果您使用的系统不支持systemd-resolved的自定义VPN软件，则很可能会尝试写入/etc/resolv.conf。</p><p>  OK, so now we’ve looked at how  /etc/nsswitch.conf and  /etc/resolve.conf have changed, but we haven’t actually explained how split DNS is configured. Instead of sending all your DNS requests to the first server listed in  /etc/resolv.conf, systemd-resolved is able to split your DNS on the basis of  DNS routing domains.</p><p>  好的，现在我们来看一下/etc/nsswitch.conf和/etc/resolve.conf的变化方式，但是我们实际上没有解释如何配置拆分DNS。无需将您所有的DNS请求发送到/etc/resolv.conf中列出的第一台服务器，systemd-resolved能够基于DNS路由域拆分DNS。</p><p>  systemd-resolved works with DNS routing domains and DNS search domains. A DNS routing domain determines only which DNS server your DNS query goes to.   It doesn’t determine where IP traffic goes to: that would be an IP routing domain. Normally, when people talk about “routing domains,” they probably mean IP routing domains, not DNS routing domains, so be careful not to confuse these two concepts. For the rest of this article, I will use “routing domain” or “DNS domain” to mean DNS routing domain.</p><p>  systemd-resolved与DNS路由域和DNS搜索域一起使用。 DNS路由域仅确定您的DNS查询转到哪个DNS服务器。它无法确定IP流量去往何方：这将是IP路由域。通常，当人们谈论“路由域”时，它们可能是指IP路由域，而不是DNS路由域，因此请注意不要混淆这两个概念。对于本文的其余部分，我将使用“路由域”或“ DNS域”来表示DNS路由域。</p><p> A DNS search domain is also different. When you query a name that is only a single label — a domain without any dots — a search domain gets appended to your query. For example, because I’m currently connected to my Red Hat VPN, I have a search domain configured for  redhat.com. This means that if I make a query to a domain that is only a single label,  redhat.com will be appended to the query. For example, I can query  bugzilla and this will be treated as a query for  bugzilla.redhat.com. This probably won’t work in your web browser, because web browsers like to convert single-label domains into web searches, but it does work at the DNS level.qt</p><p> DNS搜索域也不同。当您查询的名称仅是一个标签（一个没有点的域）时，搜索域将附加到您的查询中。例如，由于我当前已连接到Red Hat VPN，因此我为redhat.com配置了搜索域。这意味着如果我对仅一个标签的域进行查询，则redhat.com将被附加到查询中。例如，我可以查询bugzilla，这将被视为对bugzilla.redhat.com的查询。这可能无法在您的网络浏览器中使用，因为网络浏览器喜欢将单标签域转换为网络搜索，但确实可以在DNS级别使用。</p><p> In systemd-resolved, each DNS routing domain may or may not be used as a search domain. By default, systemd-resolved will add search domains for every configured routing domain that is not prefixed by a tilde. For example, ~example.com is a routing domain only, while example.com is both a routing domain and a search domain. There is also a global routing domain,  ~.</p><p> 在systemd解析中，每个DNS路由域都可以或可以不用作搜索域。默认情况下，systemd-resolved将为每个没有波浪号前缀的已配置路由域添加搜索域。例如，〜example.com仅是路由域，而example.com既是路由域又是搜索域。还有一个全局路由域〜。</p><p>   $ resolvectlGlobalProtocols: LLMNR=resolve -mDNS -DNSOverTLS DNSSEC=no/unsupportedresolv.conf mode: stubLink 2 (enp4s0)Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6 Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupportedCurrent DNS Server: 192.168.1.1 DNS Servers: 192.168.1.1 DNS Domain: lanLink 5 (tun0)Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6 Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupportedCurrent DNS Server: 10.8.0.1 DNS Servers: 10.8.0.1 DNS Domain: ~.Link 9 (tun1)Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6 Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupportedCurrent DNS Server: 10.9.0.1 DNS Servers: 10.9.0.1 10.9.0.2DNS Domain: example.com</p><p>   $ resolvectl全球协议：LLMNR = resolve -mDNS -DNSOverTLS DNSSEC =否/不受支持resolv.conf模式：存根链接2（enp4s0）当前范围：DNS LLMNR / IPv4 LLMNR / IPv6协议：+ DefaultRoute + LLMNR -mDNS -DNSOverTLS DNSSEC =否/不受支持当前的DNS服务器：192.168.1.1DNS服务器：192.168.1.1DNS域：lan连结5（tun0）当前范围：DNS LLMNR / IPv4 LLMNR / IPv6协议：+ DefaultRoute + LLMNR -mDNS -DNSOverTLS DNSSEC =否/不受支持当前的DNS服务器：10.8.0.1DNS服务器：10.8.0.1DNS域：〜。链接9（tun1）当前范围：DNS LLMNR / IPv4 LLMNR / IPv6协议：-DefaultRoute + LLMNR -mDNS -DNSOverTLS DNSSEC =否/不受支持当前的DNS服务器：10.9.0.1DNS服务器：10.9.0.1 10.9.0.2DNS域：example.com </p><p> To simplify this example, I’ve removed several uninteresting network interfaces from the output above: my unused second Ethernet interface, my unused Wi-Fi interface wlp5s0, and two virtual network interfaces that I presume are used by libvirt. This means we only have three interfaces to consider: normal Ethernet enp4s0, the privacy VPN tun0, and the corporate VPN tun1. I’m currently running NetworkManager 1.26.4, so I have also fudged the output a bit to make it look like it would if I were using NetworkManager 1.26.6 — I’ll discuss the difference below — so that this example will be good for the future. Let’s look at a few points of note:</p><p>为了简化此示例，我从上面的输出中删除了几个不有趣的网络接口：我未使用的第二个以太网接口，我未使用的Wi-Fi接口wlp5s0和我假定为libvirt使用的两个虚拟网络接口。这意味着我们只需要考虑三个接口：普通以太网enp4s0，隐私VPN tun0和公司VPN tun1。我当前正在运行NetworkManager 1.26.4，因此我也对输出进行了一些调整，使其看起来就像我在使用NetworkManager 1.26.6时一样（我将在下面讨论区别），因此该示例将是不错的选择为将来。让我们看一下几点注意事项：</p><p> tun1 is configured with -DefaultRoute and a routing domain for example.com. (It also has a search domain for example.com, because it doesn’t start with a tilde.)</p><p> tun1配置了-DefaultRoute和example.com的路由域。 （它也有example.com的搜索域，因为它不是以波浪号开头。）</p><p> systemd-resolved first decides which network interface is most appropriate for your DNS query based on the domain name you are querying, then sends your query to the DNS server associated with that interface. In this case, queries for example.com, foo.example.com, etc. will be sent to 10.9.0.1, since that is the DNS server configured for tun1, which is associated with the domain example.com. All other requests go to 10.8.0.1, since tun0 has the global domain ~. Nothing ever goes to 192.168.1.1, because a privacy VPN is enabled, and that would be a privacy disaster. Very simple, right?</p><p> systemd-resolved首先根据要查询的域名来确定哪个网络接口最适合您的DNS查询，然后将查询发送到与该接口关联的DNS服务器。在这种情况下，对example.com，foo.example.com等的查询将发送到10.9.0.1，因为这是为tun1配置的DNS服务器，该服务器与域example.com相关联。由于tun0具有全局域〜，因此所有其他请求都发送到10.8.0.1。由于启用了隐私VPN，因此什么也不会到达192.168.1.1，那将是一场隐私灾难。很简单，对吧？</p><p> If you do not use a privacy VPN, you will not have any ~. domain configured. In this case, your query will go to all interfaces that have +DefaultRoute. For example, if tun0 were removed from the above configuration, then queries not for example.com would be sent to 192.168.1.1, my router, which is good because tun1 is my corporate VPN and should only receive DNS queries corresponding to its own DNS domains.</p><p> 如果您不使用隐私VPN，则不会有任何〜。域配置。在这种情况下，您的查询将转到具有+ DefaultRoute的所有接口。例如，如果从上述配置中删除了tun0，则不会将例如example.com的查询发送到我的路由器192.168.1.1，这很好，因为tun1是我的公司VPN，并且应该只接收与其自己的DNS相对应的DNS查询域。</p><p>  How does systemd-resolved come up with the above configuration? It doesn’t. Everything I wrote in the previous section assumes that you are using NetworkManager, because systemd-resolved doesn’t actually make any decisions about where to send your DNS. That is all the responsibility of higher-level network management software, typically NetworkManager. If you use custom VPN software — anything that’s not a NetworkManager VPN plugin — then that software is also responsible for configuring systemd-resolved and playing nice with NetworkManager.</p><p>  systemd-resolved如何提出上述配置？没错我在上一节中写的所有内容均假定您使用的是NetworkManager，因为systemd-resolved实际上并未决定将DNS发送至何处。这是高级网络管理软件（通常是NetworkManager）的全部责任。如果您使用自定义VPN软件（不是NetworkManager VPN插件的任何软件），则该软件还负责配置systemd-resolved并与NetworkManager配合使用。</p><p> NetworkManager normally does a very good job of configuring systemd-resolved to work as you would expect, so most users should not need to make any changes. But if your DNS isn’t working as you expect, and you run  resolvectl and find that systemd-resolved’s configuration is not what you want,  do not report a bug against systemd-resolved! Report a bug against NetworkManager instead (if you’re confident there is a real bug).</p><p> NetworkManager通常在配置systemd-resolved使其正常工作方面表现出色，因此大多数用户不需要进行任何更改。但是，如果您的DNS无法正常运行，并且您运行resolvectl并发现systemd-resolved的配置不是您想要的，请不要报告针对systemd-resolved的错误！而是针对NetworkManager报告一个错误（如果您确信确实存在错误）。</p><p> If you don’t use NetworkManager, you can still make systemd-resolved do what you want, but you’re on your own. It will not configure itself for you.</p><p> 如果您不使用NetworkManager，仍可以使systemd-resolved随心所欲，但您自己一个人。它不会为您自己配置。 </p><p>  If you’re reading this in December 2020, you’re probably using NetworkManager 1.26.4 or earlier. Things are slightly different here, because NetworkManager recently landed a  major behavior change. Previously, NetworkManager would always configure a ~. domain for exactly one network interface. This means that the value of systemd-resolved’s DefaultRoute settings was always ignored, since ~. takes precedence. Accordingly, NetworkManager did not bother to configure DefaultRoute at all. I told you that I fudged the output of the example above a little. In actuality, NetworkManager 1.26.4 has configured +DefaultRoute on my tun1 corporate VPN. That doesn’t make sense, because it should only receive DNS for example.com, but it previously did not matter, because there was previously always a ~. domain on some interface. If you’re not using any VPNs, then your Ethernet or Wi-Fi interface would receive the ~. domain. But since 1.26.6, NetworkManager now only ever configures a ~. domain when you are using a privacy VPN, so the DefaultRoute setting now matters.</p><p>如果您在2020年12月阅读此书，则可能使用的是NetworkManager 1.26.4或更早版本。这里的情况略有不同，因为NetworkManager最近实现了主要的行为更改。以前，NetworkManager始终会配置〜。一个网络接口的域。这意味着systemd解析的DefaultRoute设置的值始终会被忽略，因为〜。优先。因此，NetworkManager完全不用理会DefaultRoute。我告诉过您，我在上面的示例中对输出进行了一些改动。实际上，NetworkManager 1.26.4已在我的tun1公司VPN上配置了+ DefaultRoute。这没有任何意义，因为它只应接收example.com的DNS，但以前没关系，因为以前总是〜。域在某些接口上。如果您不使用任何VPN，则您的以太网或Wi-Fi接口将收到〜。域。但是从1.26.6开始，NetworkManager现在仅配置〜。当您使用隐私VPN时，您可以选择“域”，因此DefaultRoute设置现在很重要。</p><p> Prior to NetworkManager 1.26.6, you could rely on  resolvectl domain alone to see where your DNS goes, because there was always a ~. domain. Since NetworkManager 1.26.6 no longer always creates a ~. domain, that no longer works. You’ll need to use look at the full output of  resolvectl instead, since that will show you the DefaultRoute settings, which are now important.</p><p> 在NetworkManager 1.26.6之前，您可以单独依靠resolvectl域查看DNS的去向，因为总会有〜。域。由于NetworkManager 1.26.6不再总是创建〜。域，将不再起作用。您需要改用resolvectl的完整输出，因为这将显示DefaultRoute设置，这一点现在很重要。</p><p>  Say your corporate VPN is example.com. You want all requests for example.com to be resolved by the VPN, and they are, because NetworkManager creates an appropriate routing domain for it. But you also want requests for some other domain, say example.org, to be resolved by the VPN as well. What do you do?</p><p>  假设您的公司VPN是example.com。您希望对example.com的所有请求都可以由VPN来解决，因为NetworkManager会为其创建适当的路由域。但是您还希望VPN也可以解决对其他域（例如example.org）的请求。你是做什么？</p><p> Most VPN protocols allow the VPN to tell NetworkManager which domains should be resolved by the VPN. Others allow specifying this in the connection profile that you import into NetworkManager. Sadly, not all VPNs actually do this properly, since it doesn’t matter for traditional non-split DNS. Worse, there is no graphical configuration in GNOME System Settings to fix this. There really should be. But for now, you’ll have to use  nmcli to set the  ipv4.dns-search and  ipv6.dns-search properties of your VPN connection profile. Confusingly, even though that setting says “search,” it also creates a routing domain. Hopefully you never have to mess with this. If you do this, consider contacting your IT department to ask them to fix your VPN configuration to properly declare its DNS routing domains, so you don’t have to fix it manually. (This actually sometimes works!) You might have to do this more than once, if you discover additional domains that need to be resolved by the corporate VPN.</p><p> 大多数VPN协议都允许VPN告诉NetworkManager VPN应该解析哪些域。其他允许在导入到NetworkManager的连接配置文件中指定此设置。遗憾的是，并不是所有的VPN都能正确地做到这一点，因为对于传统的非拆分DNS而言，这无关紧要。更糟糕的是，GNOME系统设置中没有图形配置可解决此问题。确实应该有。但是现在，您必须使用nmcli来设置VPN连接配置文件的ipv4.dns-search和ipv6.dns-search属性。令人困惑的是，即使该设置显示为“搜索”，它也会创建一个路由域。希望您永远不必为此烦恼。如果这样做，请考虑与您的IT部门联系，要求他们修复VPN配置以正确声明其DNS路由域，因此您无需手动对其进行修复。 （有时这确实可行！）如果您发现需要公司VPN解决的其他域，则可能必须执行多次。</p><p>  By “custom VPN software,” I mean any VPN that is not a NetworkManager plugin. That includes proprietary VPN applications offered by VPN services, and also packaged software like  openvpn or  wg-quick, when invoked by something other than NetworkManager.</p><p>  所谓“自定义VPN软件”，是指不是NetworkManager插件的任何VPN。这包括由VPN服务提供的专有VPN应用程序，以及由NetworkManager以外的其他程序调用时的打包软件，如openvpn或wg-quick。</p><p> If your custom VPN software is broken, you could report a bug against your VPN software to ask for support for systemd-resolved, but it’s really best to ditch your custom software and configure your VPN using NetworkManager instead, if possible. There are really only two good reasons to use custom VPN software: if NetworkManager doesn’t have a plugin appropriate for your corporate VPN, or if you need to use Wireguard and your desktop doesn’t support Wireguard yet. (NetworkManager itself supports Wireguard, but GNOME does not yet, because Wireguard is special and not treated the same as other VPNs.  Help  welcome.)</p><p> 如果您的自定义VPN软件损坏了，您可以报告VPN软件的错误，以寻求对systemd-resolved的支持，但是，如果可能的话，最好抛弃自定义软件并改为使用NetworkManager配置VPN。使用自定义VPN软件的确只有两个很好的理由：如果NetworkManager没有适合您公司VPN的插件，或者您需要使用Wireguard，而您的桌面尚不支持Wireguard。 （NetworkManager本身支持Wireguard，但GNOME尚不支持，因为Wireguard是特殊的，与其他VPN区别对待。欢迎您提供帮助。）</p><p> If you use NetworkManager to configure your VPN, as desktop developers intend for you to do, then NetworkManager will take care of configuring systemd-resolved appropriately. Fedora ships with several NetworkManager VPN plugins installed by default, so the vast majority of VPN users should be able to configure your VPN</p><p> 如果您使用NetworkManager来配置VPN（如桌面开发人员所希望的那样），则NetworkManager将负责配置systemd-resolved。 Fedora出厂时默认安装了多个NetworkManager VPN插件，因此绝大多数VPN用户都应该能够配置您的VPN </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blogs.gnome.org/mcatanzaro/2020/12/17/understanding-systemd-resolved-split-dns-and-vpn-configuration/">https://blogs.gnome.org/mcatanzaro/2020/12/17/understanding-systemd-resolved-split-dns-and-vpn-configuration/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/dns/">#dns</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/systemd/">#systemd</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>