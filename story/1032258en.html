<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>古物鉴定师的铁锈</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">古物鉴定师的铁锈</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 19:30:55</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2020/10/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You already write software in Clojure. It pays your bills. You enjoy it. You&#39;re in an industry reaping disproportionate benefit from loose money policies, leading to a trend-chasing culture of overpaid nerds making web apps. You feel guilty about this, but there is nothing you can do about it because you have no other talents that a rational person would pay you for.</p><p>您已经用Clojure编写了软件。它可以支付你的账单。你好好享受吧。你所在的行业从宽松的货币政策中获得了不成比例的好处，导致了一种追逐潮流的文化，即高薪书呆子制作网络应用程序。你对此感到内疚，但你对此无能为力，因为你没有其他能力是理性的人会付钱给你的。</p><p> Learning Rust will probably not do much to solve that problem for you. It won&#39;t assist you in making the ontological leap from a tired stereotype into something sentient and real. You will remain a replaceable silhouette with no discernible identity. It might even exacerbate the problem. However, it will give you a useful tool for writing low-level software.</p><p>学习“生锈”可能不会对你解决这个问题有多大帮助。它不会帮助你将本体论上的飞跃从疲惫的刻板印象转变为有知觉和真实的东西。你将仍然是一个没有可辨别身份的可替换的剪影。这甚至可能会加剧问题。但是，它将为您提供编写低级软件的有用工具。</p><p>     Rust’s strengths are Clojure’s weaknesses, and vice-versa. Rust isn’t as expressive or interoperable, and its concurrency story isn’t as complete. That said, it’s much better for performance or safety critical needs, and it can be embedded inside other programs or on very limited hardware.</p><p>铁锈的长处就是Clojure的短处，反之亦然。Ruust没有那么强的表现力和互操作性，它的并发故事也不够完整。也就是说，它可以更好地满足性能或安全方面的关键需求，并且可以嵌入到其他程序中或非常有限的硬件上。</p><p> Many people try to compare Rust to Go, but this is flawed. Go is an ancient board game that emphasizes strategy. Rust is more appropriately compared to Chess, a board game focused on low-level tactics. Clojure, with its high-level purview, is a better analogy to the enduring game of stones.</p><p>许多人试图将铁锈比作Go，但这是有缺陷的。围棋是一种古老的棋类游戏，强调策略。与国际象棋相比，铁锈更合适，国际象棋是一种专注于低级战术的棋盘游戏。Clojure具有高级权限，是对持久的石头游戏的更好类比。</p><p>  With Clojure, we typically start by installing  Leiningen, which builds projects and deploys libraries to  clojars.org. The  project.clj file at the root of a project specifies metadata like dependencies. One elegant aspect of Clojure we take for granted is that it is just a library, so projects can specify in this file what version of Clojure to use just like any other library.</p><p>对于Clojure，我们通常从安装Leiningen开始，它构建项目并将库部署到clojars.org。项目根目录下的project.clj文件指定类似于依赖项的元数据。我们理所当然地认为Clojure的一个优雅方面是它只是一个库，因此项目可以在该文件中指定使用哪个版本的Clojure，就像使用任何其他库一样。</p><p> With Rust, we start by installing  Cargo, which builds projects and deploys libraries to  crates.io. The  Cargo.toml file at the root of a project specifies metadata like dependencies. Rust takes the more traditional approach of being bundled with its build tool; it isn&#39;t a library and its compiler can&#39;t be embedded into programs for REPL-driven development.</p><p>对于Rust，我们从安装Cargo开始，它构建项目并将库部署到crates.io。项目根目录下的Cargo.toml文件指定依赖项等元数据。Rust采用了更传统的方法，即与其构建工具捆绑在一起；它不是一个库，它的编译器不能嵌入到REPL驱动的开发程序中。</p><p>  With Clojure, we start an app with  lein new app hello-world, which creates a project containing this:</p><p>使用Clojure，我们使用lein新应用hello-world启动一个应用，该应用创建一个包含以下内容的项目：</p><p> ( ns  hello_world.core ( :gen-class))( defn  -main   &#34;I don&#39;t do a whole lot ... yet. &#34; [&amp; args] ( println   &#34;Hello, World! &#34;))</p><p>(NS hello_world.core(：gen-class))(Defn-main&34；我不会做很多事情...。现在还不行。&#34；[&amp；args](println&#34；Hello，World！&#34；)</p><p> With Rust, we start an app with  cargo new hello_world --bin, which creates a project containing this:</p><p>使用Rust，我们启动了一个应用程序，其中包含新的hello_world--bin，它创建了一个包含以下内容的项目：</p><p>  As you can see, the process is basically identical, and apart from syntactic differences, they both start you off with the same main function. With Cargo, if you leave out the &#34;--bin&#34;, it will create a library instead. Either way, be sure to think hard about your project&#39;s name. A name like &#34;Rust&#34; ensures many opportunities for clever puns that will surely never get tiresome or old.</p><p>正如您所看到的，这个过程基本上是相同的，除了语法差异之外，它们都是从相同的主要功能开始的。对于Cargo，如果省略&#34；--bin&#34；，它将创建一个库。无论哪种方式，一定要认真考虑你的项目的名字。像“铁锈”这样的名字确保了许多巧妙的双关语出现的机会，这些双关语肯定不会令人厌烦或陈旧。</p><p>  While the Rust project doesn&#39;t start off with any equivalent to Clojure&#39;s namespace declaration, once you move beyond a single source file you&#39;ll need to use it. This isn&#39;t C or C++, where you just include files like a caveman. Rust separates code into modules, and each source file is automatically given one based on the file name. We can make a functions in a separate file like this:</p><p>虽然Rust项目并不是从任何与Clojure的名称空间声明等价的地方开始的，但是一旦您超越了单个源文件，您将需要使用它。这不是C或C++，您只需像山顶洞人一样包含文件。Ruust将代码分成模块，并且根据文件名自动为每个源文件分配一个模块。我们可以在单独的文件中创建函数，如下所示：</p><p>   Rust&#39;s  mod is similar to Clojure&#39;s  ns in that it creates a module, but they all go at the top of  main.rs instead of in the files that the modules come from. From there, we can just prepend  utils:: to the function names to use them. Note that they are declared with  pub. Unlike Clojure, Rust makes functions private by default.</p><p>Rust的mod类似于Clojure的ns，因为它创建了一个模块，但它们都放在main.rs的顶部，而不是模块来自的文件中。在此基础上，我们只需在函数名前面加上utils：：即可使用它们。请注意，它们是用pub声明的。与Clojure不同，Rust默认将函数设为私有函数。</p><p> Rust&#39;s  use is similar to Clojure&#39;s  require in that it brings in an existing module. Here&#39;s a slightly modified  main.rs, where we are bringing in symbols explicitly so we don&#39;t need to alias it, much like Clojure&#39;s  require does with the  :refer keyword:</p><p>铁锈的使用类似于Clojure的要求，因为它带来了一个现有的模块。这里稍微修改了一下main.rs，我们显式地引入了符号，这样就不需要给它取别名，就像Clojure的Required对关键字：refer所做的那样：</p><p>    As you know, languages with their own package managers usually have a special format for their libraries with their own unique name. Python has its &#34;eggs&#34; and Ruby has its &#34;gems&#34;. Clojure has the disadvantage of being on an existing ecosystem, so it couldn&#39;t invent its own format; it uses the same boring &#34;jars&#34; as other JVM languages.</p><p>正如您所知道的，具有自己的包管理器的语言通常有一种特殊格式的库，它们有自己唯一的名称。Python有它的鸡蛋，Ruby有它的宝石。Clojure的缺点是在现有的生态系统上，所以它不能发明自己的格式；它使用与其他JVM语言相同的乏味的JAR。</p><p> Thankfully, Rust does not have this problem, and it chose to call its format &#34;crates&#34;. This reflects the language&#39;s industrial roots and the humble, blue collar town of its sponsor: Mountain View, California. To use a crate, you add it to  Cargo.toml much like you would with  project.clj. Here&#39;s what mine looks like after adding the  time crate:</p><p>谢天谢地，Rust没有这个问题，它选择将其格式命名为crates&#34；。这反映了这种语言的工业根源，也反映了它的赞助商--加利福尼亚州山景城--一个简陋的蓝领小镇。要使用板条箱，可以将其添加到Cargo.toml，就像使用project.clj一样。这是我的时间箱加进去后的样子：</p><p>  To use it, we first need to declare the crate at the top of  main.rs:</p><p>要使用它，我们首先需要在Main顶部声明板条箱。rs：</p><p>  Then, in the file we want to use it in, we&#39;ll bring it in with  use:</p><p>然后，在我们要在其中使用它的文件中，我们将使用以下命令将其引入：</p><p> // utils.rs use time; pub  fn  say_hello() {  println!( &#34;Hello, world at {}!&#34;, time :: now(). asctime());} pub  fn  say_goodbye() {  println!( &#34;Goodbye, world at {}!&#34;, time :: now(). asctime());}</p><p>//utils.rs使用time；pub fn say_hello(){println！(&#34；hello，world at{}！&#34；，time：：now()。Asctime()；}pub fn say_再见(){println！(&#34；再见，世界在{}！&#34；，time：：now()。Asctime())；}。</p><p>   Until now, we&#39;ve avoided seeing types because none of our functions take arguments. Rust is statically typed. The upside is, you will curse it at compile-time instead of at runtime. The downside is, &#34;exploratory programming&#34; means exploring how to convince the compiler to let you try an idea. Let&#39;s modify our functions so we pass the &#34;Hello&#34; or &#34;Goodbye&#34; as an argument:</p><p>到目前为止，我们一直避免看到类型，因为我们的函数都不带参数。铁锈是静态打字的。好处是，您将在编译时而不是在运行时诅咒它。缺点是，探索性编程意味着探索如何说服编译器让您尝试一个想法。让我们修改我们的函数，以便将&#34；Hello&34；或&#34；Goodbai&34；作为参数传递：</p><p>  // utils.rs use time; pub  fn  say_something(word:  &amp; str) {  let t  = time :: now();  println!( &#34;{}, world at {}!&#34;, word, t. asctime());}</p><p>//utils.rs use time；pub fn say_thing(word：&amp；str){let t=time：：now()；println！(&#34；{}，world at{}！&#34；，word，T.asctime())；}。</p><p> So, the syntax for arguments is similar to ML, where the name comes first, followed by a colon and then the type. In Rust, statically-allocated strings have the type of  &amp;str, which is pronounced as &#34;string slice&#34;. Heap-allocated strings have the type of  String. This is a distinction you don&#39;t find in Clojure or other high-level languages. Read  Strings to learn more.</p><p>因此，参数的语法类似于ML，首先是名称，然后是冒号，然后是类型。在Rust中，静态分配的字符串的类型为&amp；str，发音为&#34；string Slice&#34；。堆分配的字符串具有字符串类型。这是您在Clojure或其他高级语言中找不到的区别。阅读字符串以了解更多信息。</p><p> Note that in this latest revision, we also moved the time object into a local variable using  let, which should be familiar to a Clojure user. In Rust, you are required to specify the types of top-level functions, but almost never for local variables. Rust has type inference, so it can figure out the type of  t on its own. It happens to be  Tm.</p><p>请注意，在这个最新版本中，我们还使用let将Time对象移动到本地变量中，这对Clojure用户来说应该很熟悉。在Rust中，您需要指定顶级函数的类型，但几乎从不指定局部变量的类型。Rust具有类型推理功能，因此它可以自己计算出t的类型。碰巧是TM。</p><p> As the Tm docs indicate, the  asctime function returns a  TmFmt. Although  println! has no idea what that is, it doesn&#39;t matter. It implements a trait -- similar to a Clojure protocol -- called  Display, which is all that  println! needs. This mechanism is used pervasively in Rust. Read  Traits to learn more.</p><p>正如TM文档指出的那样，asctime函数返回TmFmt。虽然是Printtln！我不知道那是什么，这无关紧要。它实现了一个特征--类似于Clojure协议--称为display，这就是println！需要。这一机制在铁锈中得到了广泛的应用。阅读特征以了解更多信息。</p><p>  The distinction in the previous section between stack and heap allocation is worth focusing on. In high-level languages, you can&#39;t control which is used, so you never think about it. In C and C++, you have complete control over it, but only at the price of being more error-prone. Rust promises to give you that control while being as safe as high-level languages.</p><p>上一节中堆栈和堆分配之间的区别值得关注。在高级语言中，您无法控制使用哪种语言，因此您从不考虑它。在C和C++中，您可以完全控制它，但代价是更容易出错。Rust承诺让您在与高级语言一样安全的同时实现这种控制。</p><p> When you have direct control over memory allocation, you also have control over how values are passed to functions. In high-level languages, you normally just pass a value to a function and the language will decide whether to only pass a reference to the value or to pass an entire copy of the value. In Rust you explicitly pass references to values.</p><p>当您直接控制内存分配时，您还可以控制如何将值传递给函数。在高级语言中，通常只需将值传递给函数，该语言将决定是只传递对值的引用，还是传递值的整个副本。在Rust中，您显式传递对值的引用。</p><p> That is what the  &amp; means in  &amp;str. Literal strings are automatically represented as a references, but under normal circumstances things will start their life as a value, and to pass them as a reference you will need to prepend them with  &amp;. For example, let&#39;s pass the  Tm object to the  say_something function:</p><p>这就是&amp；在&amp；str中的意思。文字字符串自动表示为引用，但在正常情况下，它们将作为值开始其生命，要将它们作为引用传递，您需要在它们前面加上&amp；。例如，让&#39；将TM对象传递给Say_Something函数：</p><p> // main.rs extern  crate time; use utils ::say_something; mod utils; fn  main() {  let t  = time :: now();  say_something( &#34;Hello&#34;,  &amp;t);  say_something( &#34;Goodbye&#34;,  &amp;t);}</p><p>//main.rs外部装箱时间；使用utils：：say_omething；mod utils；fn main(){let t=time：：now()；say_omething(&#34；Hello&#34；，&amp；t)；say_omething(&#34；再见&34；，&amp；t)；}。</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  &amp;time::Tm) {  println!( &#34;{}, world at {}!&#34;, word, t. asctime());}</p><p>//utils.rs Use Time；pub FN Say_Something(Word：&amp；str，t：&amp；Time：：TM){println！(&#34；{}，world at{}！&#34；，word，T.asctime())；}。</p><p> What would happen if we just did  say_something(&#34;Hello&#34;, t);, and change the argument&#39;s type to  t: time::Tm? The value  t will be &#34;moved&#34; into the function, and will no longer be available outside of it. Since  say_something(&#34;Goodbye&#34;, t); is called after, it will throw an error. Read  References and Borrowing to learn more.</p><p>如果我们只说_Something(&#34；Hello&#34；，t)；并将参数的类型更改为t：time：：tm，会发生什么情况？值t将被&#34；移到函数中，并且在函数之外将不再可用。由于调用Say_Something(&#34；再见&#34；，t)；，它将抛出一个错误。阅读参考资料和借阅以了解更多信息。</p><p>  A Clojure programmer will be pleased to find that Rust shares a belief in data being immutable by default. The  Tm object in the previous section cannot be mutated -- you&#39;ll get a compile error. For example, because it implements the  Clone trait, it has a function called  clone_from, which lets you replace it with a completely new  Tm object. This is obviously a mutation, so if we want to use it, we must declare it with  let mut:</p><p>Clojure程序员会很高兴地发现Rust也相信数据在缺省情况下是不可变的。上一节中的TM对象不能改变--您会得到一个编译错误。例如，因为它实现了Clone特征，所以它有一个名为CLONE_FROM的函数，允许您用一个全新的TM对象替换它。这显然是一个突变，所以如果我们想要使用它，我们必须用let mut声明它：</p><p> // main.rs extern  crate time; use utils ::say_something; mod utils; fn  main() {  let  mut t  = time :: now(); t. clone_from( &amp;time :: now_utc());  say_something( &#34;Hello&#34;,  &amp;t);  say_something( &#34;Goodbye&#34;,  &amp;t);}</p><p>//main.rs外部装箱时间；使用utils：：say_thing；mod utils；fn main(){let mut=time：：now()；t.clone_from(&amp；time：：now_utc())；say_omething(&#34；Hello&34；，&amp；t)；say_omething(&#34；再见&34；，&amp；t)；}。</p><p> In that example, the  t object is being completely replaced by a new one that uses UTC time instead of local time. Interestingly, the  say_something function still cannot mutate it, because references are immutable by default as well. If we wanted to run the  clone_from function there, we would have to use a mutable reference:</p><p>在该示例中，测试对象被使用UTC时间而不是本地时间新对象完全替换。有趣的是，Say_Something函数仍然不能对其进行变异，因为引用在缺省情况下也是不可变的。如果要在那里运行CLONE_FROM函数，则必须使用可变引用：</p><p> // main.rs extern  crate time; use utils ::say_something; mod utils; fn  main() {  let  mut t  = time :: now();  say_something( &#34;Hello&#34;,  &amp; mut t);  say_something( &#34;Goodbye&#34;,  &amp; mut t);}</p><p>//main.rs外部装箱时间；使用utils：：say_thing；mod utils；fn main(){let mut=time：：now()；say_omething(&#34；Hello&#34；，&amp；mut)；say_omething(&#34；再见&34；，&amp；mut)；}。</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  &amp; mut time::Tm) { t. clone_from( &amp;time :: now_utc());  println!( &#34;{}, world at {}!&#34;, word, t. asctime());}</p><p>//utils.rs Use Time；pub FN Say_Something(Word：&amp；str，t：&amp；mut time：：TM){T.clone_from(&amp；time：：now_utc())；println！(&#34；{}，world at{}！&#34；，word，T.asctime())；}。</p><p> The neat thing about this is that you can tell when a function is mutating an argument by simply looking at its type signature. If you don&#39;t see  &amp;mut, it can&#39;t do so (unless it&#39;s  internally mutable). It could still perform I/O like writing to the disk or requesting a network resource, so it&#39;s not necessarily pure in that sense, but at least we know that it&#39;s pure vis-à-vis its own arguments.</p><p>这样做的巧妙之处在于，您只需查看函数的类型签名，就可以知道函数何时会改变参数。如果您没有看到&amp；mut，则它不能这样做(除非它是内部可变的)。它仍然可以执行I/O操作，比如写入磁盘或请求网络资源，因此它在这个意义上不一定是纯粹的，但至少我们知道它相对于它自己的参数来说是纯粹的。</p><p>  In Clojure, we have the concept of  nil to represent the lack of a value. It is convenient, but if we forget to check for it, we get the dreaded  NullPointerException. Rust follows in the footsteps of languages like Haskell by doing the same thing it does with mutability: making it explicitly part of the type.</p><p>在Clojure中，我们有nil的概念来表示缺少值。这很方便，但是如果我们忘记检查它，就会得到可怕的NullPointerException。Rust追随Haskell等语言的脚步，做了与可变性相同的事情：使其显式地成为类型的一部分。</p><p> For example, let&#39;s say we want the  say_something function to let you pass a  Tm reference  or nothing at all. If you do the latter, it will just create its own  Tm object using  time::now_utc(). To express this, we have to make it an optional type. That means changing the type to  Option&lt;&amp;time::Tm&gt; and changing the value we pass to it like this:</p><p>例如，假设我们希望SAY_SOURCE函数允许您传递TM引用或什么都不传递。如果执行后一种操作，它将只使用time：：now_utc()创建自己的TM对象。要表达这一点，我们必须将其设置为可选类型。这意味着将类型更改为Option&lt；&amp；Time：：TM&gt；，并更改我们传递给它的值，如下所示：</p><p> // main.rs extern  crate time; use utils ::say_something; mod utils; fn  main() {  let t  = time :: now();  say_something( &#34;Hello&#34;,  Some( &amp;t));  say_something( &#34;Goodbye&#34;,  None);}</p><p>//main.rs外部装箱时间；使用utils：：Say_Something；mod utils；fn main(){let t=time：：now()；Say_Something(&#34；Hello&#34；，Some(&amp；t))；Say_Something(&#34；再见&34；，无)；}。</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  Option&lt; &amp;time::Tm&gt;) {  if t. is_some() {  println!( &#34;{}, world at {}!&#34;, word, t. unwrap(). asctime()); }  else {  println!( &#34;{}, world at {}!&#34;, word, time :: now_utc(). asctime()); }}</p><p>//utils.rs use time；pub fn say_thing(Word：&amp；str，t：option&lt；&amp；time：：TM&gt；){if T.is_ome(){println！(&#34；{}，world at{}！&#34；，word，t.unrapp()。Asctime()；}Else{println！(&#34；{}，world at{}！&#34；，word，time：：now_utc()。Asctime())；}}。</p><p> So, if we actually want to pass a value, we surround it with  Some(...), and if we want to pass the equivalent of Clojure&#39;s  nil, we pass in  None. Then, in  say_something, we can check if  t contains a value using the  is_some function, and if so, we call  unwrap on it to get its value.</p><p>因此，如果我们实际上想要传递一个值，我们会用一些(...)将其括起来，如果我们想要传递等价的Clojure‘s nil，我们就不会传入任何值。然后，在SAYSOME中，我们可以使用IS_SOME函数检查t是否包含值，如果包含，则对其调用UnWrap以获得它的值。</p><p> This may seem like a lot of work compared to just using  nil, but the advantage is that  NullPointerExceptions are impossible. We are forced by the compiler to check if it contains a value. Additionally, it has the same advantage that  &amp;mut has in the previous section; just by looking its type signature, we know which arguments allow no value to be passed.</p><p>与仅使用nil相比，这看起来似乎工作量很大，但好处是NullPointerExceptions是不可能的。编译器强制我们检查它是否包含值。此外，它与&amp；mut在上一节中具有相同的优势；只需查看它的类型签名，我们就知道哪些参数不允许传递任何值。</p><p>  In Clojure, we can get very powerful pattern matching capabilities using the  core.match library. Rust has a similar mechanism baked into the language. This can be used to simplify complicated conditional statements using the  match keyword. Read  Match to learn more.</p><p>在Clojure中，我们可以使用core.match库获得非常强大的模式匹配功能。铁锈在语言中也有类似的机制。这可用于简化使用MATCH关键字的复杂条件语句。阅读Match以了解更多信息。</p><p> For our purposes, pattern matching can help us make our  if statement safer. In the previous section,  say_something is not very idiomatic, because it manually checks  t.is_some() and calls  t.unwrap(). It is much better to use the  if let syntax like this:</p><p>就我们的目的而言，模式匹配可以帮助我们使if语句更安全。在前一节中，say_omething不是很惯用，因为它手动检查t.is_ome()并调用t.unwire()。使用If let语法要好得多，如下所示：</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  Option&lt; &amp;time::Tm&gt;) {  if  let  Some(t_ptr)  = t {  println!( &#34;{}, world at {}!&#34;, word, t_ptr. asctime()); }  else {  println!( &#34;{}, world at {}!&#34;, word, time :: now_utc(). asctime()); }}</p><p>//utils.rs use time；pub fn say_thing(word：&amp；str，t：option&lt；&amp；time：：tm&gt；){if let ome(T_Ptr)=t{println！(&#34；{}，world at{}！&#34；，word，t_ptr；)。Asctime()；}Else{println！(&#34；{}，world at{}！&#34；，word，time：：now_utc()。Asctime())；}}。</p><p> Clojure, of course, has its own  if-let, and the concept is very similar. The only difference is that we must use pattern matching to pull the value out of the option type. That&#39;s what  Some(t_ptr) = t is doing. Pattern matching is used pervasively in Rust for everything from error handling to destructuring. Read  Patterns to learn more.</p><p>当然，Clojure有自己的if-let，概念非常相似。唯一的区别是，我们必须使用模式匹配来提取选项类型中的值。这就是一些人(T_Ptr)=t正在做的事情。模式匹配在Rust中被广泛使用，用于从错误处理到析构的所有事情。阅读模式以了解更多信息。</p><p>  In Clojure, everything is an expression, which means we can embed code inside of code without any restriction. In Rust, it&#39;s not  quite as pervasive, but nonetheless almost everything is an expression. The only things you&#39;ve run into that can&#39;t be expressions are declarations, such as  mod,  use,  fn, and  let.</p><p>在Clojure中，一切都是表达式，这意味着我们可以不受任何限制地将代码嵌入到代码中。在“锈”一书中，它不是很普遍，但几乎所有的东西都是一种表达方式。您遇到的唯一不能是表达式的东西是声明，如mod、use、fn和let。</p><p> What about  if statements? In the previous section,  say_something is deliberately verbose. There is clearly no benefit to writing redundant code like the calls to  println! beyond ensuring one&#39;s own job security. In Rust,  if statements are expressions, so we can just embed it into a  let statement like this:</p><p>如果语句呢？在前一节中，SAYSE_Something故意冗长。编写冗余代码(如调用println)显然没有任何好处！不仅仅是确保自己的工作安全。在Rust中，if语句是表达式，所以我们可以将其嵌入到let语句中，如下所示：</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  Option&lt; &amp;time::Tm&gt;) {  let t_val  =  if  let  Some(t_ptr)  = t {  *t_ptr }  else { time :: now_utc() };  println!( &#34;{}, world at {}!&#34;, word, t_val. asctime());}</p><p>//utils.rs use time；pub fn say_thing(Word：&amp；str，t：option&lt；&amp；time：：TM&gt；){let t_val=if let ome(T_Ptr)=t{*t_ptr}Else{time：：now_utc()}；println！(&#34；{}，world at{}！&#34；，word，t_val。Asctime())；}</p><p> Here, we are making the local variable  t_val, which will contain either the value inside  t, or a new object if  t is  None. Notice the  * before  t_ptr. This is doing the opposite of  &amp; by grabbing the value that the reference is referring to. We need to do this because  time::now_utc() returns a value, and we need to make sure both return the same type.</p><p>在这里，我们创建局部变量t_val，它将包含t内部的值，或者如果t为NONE，则包含一个新对象。请注意t_ptr之前的*。这与&amp；相反，是通过获取引用所引用的值来实现的。我们需要这样做，因为time：：now_utc()返回一个值，并且我们需要确保两者返回相同的类型。</p><p> Also notice that neither expression in our  if statement ends with a semicolon. Semicolons are used to demarcate statements. To return a value, we just write an expression without a semicolon. This is similar to what we do in Clojure. When we want to return a value, we simply put it at the end. Read  Expressions vs. Statements to learn more.</p><p>还要注意，if语句中的两个表达式都没有以分号结尾。分号用于分隔语句。要返回值，我们只需编写一个不带分号的表达式。这与我们在Clojure中所做的类似。当我们想要返回值时，我们只需将其放在末尾。阅读表达式与语句以了解更多信息。</p><p> Note that the same thing is done to return a value at the end of a function. If we wanted  say_something to return our  Tm object, all we need to do is indicate that in the type signature and then put  t_val at the end of the function:</p><p>请注意，在函数末尾返回值时也会执行相同的操作。如果我们想要Say_Something返回我们的TM对象，我们所需要做的就是在类型签名中指明这一点，然后将t_val放在函数的末尾：</p><p> // utils.rs use time; pub  fn  say_something(word:  &amp; str, t:  Option&lt; &amp;time::Tm&gt;) -&gt; time::Tm {  let t_val  =  if  let  Some(t_ptr)  = t {  *t_ptr }  else { time :: now_utc() };  println!( &#34;{}, world at {}!&#34;, word, t_val. asctime()); t_val}</p><p>//utils.rs use time；pub fn say_thing(Word：&amp；str，t：option&lt；&amp；time：：tm&gt；)-&gt；time：：tm{let t_val=if let ome(T_Ptr)=t{*t_ptr}Else{time：：now_utc()}；println！(&#34；{}，world at{}！&34；，word，t_val。Asctime()；t_val}。</p><p>  You may have wondered this entire time why  println! ends with a bang. In Clojure, it is idiomatic to do this for functions that are side-effecting. In Rust, it is the compiler-enforced syntax for macros. Users of Lisp dialects like Clojure are certainly fond of their macros, as there is a tremendous power, simplicity, and hubristic feeling of personal superiority they afford due to their homoiconic syntax.</p><p>你可能一直在想，为什么是println！以一声巨响结束。在Clojure中，对副作用较大的函数执行此操作是惯用的做法。在Rust中，它是宏的编译器强制语法。像Clojure这样的Lisp方言的用户肯定喜欢他们的宏，因为他们的同形图标语法提供了一种巨大的威力、简单性和傲慢的个人优越感。</p><p> Rust is not homoiconic, and unsurprisingly the macro system isn&#39;t as powerful. Their primary purpose is similar to that of C macros: to reduce code duplication through symbol replacement. Unlike C macros, however, they are hygenic. Read  Macros to learn more. If you are looking for the ability to run arbitrary code at compile-time, you may need to write a  compiler plugin instead.</p><p>铁锈并不是同性恋，不出所料，宏观系统也没有那么强大。它们的主要用途类似于C宏：通过符号替换减少代码重复。然而，与C宏不同的是，它们是卫生的。阅读宏以了解更多信息。如果您正在寻找在编译时运行任意代码的功能，则可能需要编写编译器插件。</p><p>  There is much more to learn about Rust from here. We haven&#39;t touched on lifetimes, the mechanism for achieving memory safety without garbage collection. We haven&#39;t looked at FFI, the mechanism for introducing segfaults and stack corruption into your program. The  Rust Book, which I&#39;ve been linking to all along, is a great next step for the reader.</p><p>从这里可以学到更多关于铁锈的知识。我们还没有触及生命周期，也就是在没有垃圾收集的情况下实现内存安全的机制。我们还没有看过FFI，它是将段错误和堆栈损坏引入您的程序的机制。我一直链接的“铁锈之书”对读者来说是很棒的下一步。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/oakes/4af1023b6c5162c6f8f0">https://gist.github.com/oakes/4af1023b6c5162c6f8f0</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/古物/">#古物</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032252.html"><img src="http://img2.diglog.com/img/2020/10/thumb_32a6a18f6a7b3db994451021b6994b68.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032252.html">铁锈网到了吗？是的，而且它跑得太快了</a></div><span class="my_story_list_date">2020-10-30 18:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031806.html"><img src="http://img2.diglog.com/img/2020/10/thumb_26bcb0bc85f464453de16206c6403500.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031806.html">在IAB意大利提出申诉后，意大利反垄断机构调查谷歌涉嫌滥用其在在线展示广告市场的主导地位</a></div><span class="my_story_list_date">2020-10-29 9:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031754.html"><img src="http://img2.diglog.com/img/2020/10/thumb_0627a7b97f6fe46deae88895cfb775a3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031754.html">
谷歌展示广告业务在意大利接受反垄断调查</a></div><span class="my_story_list_date">2020-10-28 20:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031702.html"><img src="http://img2.diglog.com/img/2020/10/thumb_778b5ac5f0146f57a7ec6f42afda2e57.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031702.html">Visa计划收购格子布面临司法部反垄断审查</a></div><span class="my_story_list_date">2020-10-28 12:27</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>