<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>技术面试方法与某人玩其他因素相比苍白 Technical interview methods pale in comparison to playing Factorio with someone</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Technical interview methods pale in comparison to playing Factorio with someone<br/>技术面试方法与某人玩其他因素相比苍白 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-27 08:57:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/9560c6aceaf355c0a8aedc3f8c894677.png"><img src="http://img2.diglog.com/img/2021/3/9560c6aceaf355c0a8aedc3f8c894677.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There&#39;s been a lot of hand-wringing over The Technical Interview lately. Many people realize that inverting a binary tree on a whiteboard has basically zero correlation to whether or not someone is actually a good software developer. The most effective programming test anyone&#39;s come up with is still  Fizzbuzz. One consequence of this has been an increased emphasis on Open Source Contributions, but it turns out  these aren&#39;t a very good metric either, because most people don&#39;t have that kind of time.</p><p>最近有很多手工犯规技术面试。许多人意识到在白板上反转二叉树基本上与某人是否实际上是一个好的软件开发人员相关。最有效的编程测试任何人＆＃39;仍然是fizzbuzz。这一点的后果一直在强调开源贡献，但事实证明了这一点，也是一个非常好的度量，因为大多数人都没有那种时间。</p><p> The most effective programming interview we have now is usually some kind of take-home project, where a candidate is asked to fix a bug or implement a small feature within a few days. This isn&#39;t great because it takes up a lot of time, and they could recieve outside help (or, if the feature is sufficiently common, google it). On the other hand, some large companies have instead doubled-down on whiteboard style interviews by subjecting prospective engineers to multiple hour-long online coding assessments, with varying levels of invasive surveillience.</p><p> 我们现在拥有的最有效的编程面试通常是某种带家庭项目，其中候选人被要求在几天内修复错误或实施小功能。这是＆＃39; t伟大的，因为它需要很多时间，他们可以接受外部帮助（或者，如果该功能足够普遍，谷歌它）。另一方面，一些大型公司通过对前瞻性工程师进行多小时的在线编码评估，相反，一些大公司在白板风格的面试中取得了一倍的​​加倍，具有不同程度的侵入性监视。</p><p> All these interviewing methods pale in comparison to a very simple metric:  playing Factorio with someone. Going through an entire run of Factorio is almost the best possible indication of how well someone deals with common technical problems. You can even tweak the playthrough based on the seniority of the position you&#39;re hiring for to get a better sense of how they&#39;ll function in that role.</p><p> 所有这些面试方法与一个非常简单的指标相比，与某人玩过。经历整个因子的过程几乎是最好的可能迹象表明某人如何处理普通技术问题。您甚至可以根据您的位置的资历来调整游戏，＆＃39;重新招聘，以获得更好的感觉。在该角色中，LL功能如何。</p><p>  Factorio is a game about automation. The best introduction is probably  this trailer, but in essence, your job is to build an automated factory capable of launching a rocket into space.</p><p>  因子是关于自动化的游戏。最好的介绍可能是这个拖车，但实质上，你的工作是建造一个能够将火箭发射到太空的自动化工厂。</p><p> You begin with nothing. You mine stone manually to craft a smelter that can smelt iron ore you mined into iron plates, which you then use to build a coal-driven automatic miner. You could grab the iron ore from the miner and put it in the smelter yourself, but it&#39;s more efficient to use an inserter to do the inserting for you. Then you can use the iron this gives you to make another miner, which automates coal mining. Then you can use belts to take the coal and use an inserter to put it in the iron miner. Then you use the iron plates this tiny factory produces to make a third miner to start gathering copper, which then lets you craft copper wire, which lets you craft a circuit, which lets you build a water pump. Combined with a boiler and a steam engine, you can then build produce power, and use this power to run a research facility to unlock new technology, like assembly machines. Once you&#39;ve unlocked assembly machines, you can use your circuits to craft an assembly machine that can craft copper wire for you, and insert this into an assembly machine that crafts circuits for you.</p><p> 你什么都不开始。你手动挖掘石头可以制作一个可以熔炼铁矿石的冶炼厂，你开采了铁板，然后你用来建造煤炭驱动的自动矿工。你可以从矿工上抓住铁矿石，把它放在冶炼厂自己，但它更有效地使用一个插入者来为您进行插入。然后你可以用铁让你能够制作另一个矿工，这是自动化煤矿。然后，您可以使用带拿煤炭并使用插入者将其放入铁矿工中。然后你使用铁板这个小型工厂生产制作第三次矿工开始收集铜，然后让你乘坐铜线，这让你制作一个电路，这让你打造水泵。然后与锅炉和蒸汽机结合使用，然后您可以构建生产力，并使用此电源运行研究设施以解锁新技术，如装配机。一旦你＆＃39; Ve Unlocked装配机器，您可以使用电路来制作一个装配机，可以为您制作铜线，并将其插入装配机器，为您提供工艺电路。</p><p> Eventually you unlock trains and robots and logistic systems which help you deal with the increasing logistic complexity the game demands, until you finally manage to launch a rocket into space.</p><p> 最终，您可以解锁火车和机器人和物流系统，帮助您处理游戏所需的历时的物流复杂性，直到您最终设法将火箭发射到太空中。</p><p>  The beginning of the game starts with no goals and barely any direction. A senior developer should be able to explore the UI and figure out a goal, then establish a plan for accomplishing that goal. A junior developer should be able to perform a task that a senior developer has provided for them. An intern is expected to require quite a bit of mentoring, but a junior developer should be able to troubleshoot basic problems with their own code before requiring assistance from the senior developer. An intermediate developer should be able to operate independently once given a task, but is not expected to do any architecture design.</p><p>  游戏的开头从没有任何目标，几乎没有任何方向。高级开发人员应该能够探索UI并找出目标，然后建立一个实现这个目标的计划。初级开发人员应该能够执行一项高级开发人员为他们提供的任务。预计实习生需要需要相当多的指导，但初级开发人员应该能够在需要高级开发人员的帮助之前对自己的代码进行故障排除。一旦任务，中间开发人员应该能够独立运行，但预计不会做任何架构设计。 </p><p>  An  Intern is generally expected to be able to fill in a pre-placed blueprint, and use belts to hook up their blueprint with something else, like an ore patch.</p><p>通常预计实习生将能够填充预先放置的蓝图，并使用皮带将其蓝图与其他东西挂钩，如矿石贴片。</p><p> A  Junior Developer should be able to build a production line by themselves, although it probably won&#39;t be very optimal. They may need assistance from the senior developer on how to route the belts properly to all of the intermediate assembly machines.</p><p> 初级开发人员应该能够自己建造生产线，虽然它可能会赢得＆＃39; t非常优惠。他们可能需要高级开发人员的帮助，了解如何将皮带妥善送到所有中间装配机器。</p><p> An  Intermediate Developer should be capable of designing a near-optimal production line (without beacons) once given direction, with minimal oversight.</p><p> 中间显影剂应该能够在给定方向上设计近最佳的生产线（没有信标），具有最小的监督。</p><p> The  Senior Developer needs no direction, and is capable of determining what goals need to happen and designing a plan of action, then delegating these tasks to other coders.</p><p> 高级开发人员无需方向，并且能够确定要发生和设计行动计划的目标，然后将这些任务委派给其他编码器。</p><p>  A critical aspect of software development is the ability to work on a team. This means coordinating your efforts with other people, accomadating the needs of other people&#39;s designs and cooperating with the team, instead of simply running off on your own and refusing to adjust your design to help integrate it with someone else&#39;s work. This, naturally, arises all the time in Factorio, because base layout designs are limited by physical space. As a result, you need to carefully consider what other people are doing, and sometimes adjust your design to fit in size constraints or deal with someone else&#39;s design that took more room than anticipated.</p><p>  软件开发的一个关键方面是能够在团队上工作。这意味着与其他人协调您的努力，加强其他人的需求和与团队合作，而不是您自己的与团队合作，而不是拒绝调整您的设计，以帮助将其与其他人与其他人一起集成。工作。当然，这一切都是在因子中的所有时间，因为基础布局设计受到物理空间的限制。因此，您需要仔细考虑其他人在做什么，有时调整您的设计，以适应尺寸限制或与其他人交易，从预期上占用更多空间的设计。</p><p> Anyone who simply runs off and starts doing things themselves or fixing problems without telling people is going to quickly earn the ire of their fellow players, for the exact same reasons cowboy programmers do. Luckily, Factorio includes a built-in equivelent to  git blame, by showing you the last player that modified any entity. Thus, when people duct tape temporary solutions and don&#39;t inform the team about the problem they were fixing, when their temporary solution finally blows up, people will find out. If people want to win they game, they&#39;ll have to learn to cooperate well with their teammates.</p><p> 任何简单地耗尽并开始做事或修复问题的人没有告诉人们会迅速赢得他们的同伴参与者，因为牛仔程序员所做的完全相同。幸运的是，因子包括一个内置的Git Chinough，通过向您展示修改任何实体的最后一个播放器来归咎于责任。因此，当人们临时解决方案和Don＆＃39; t＆＃39; t＆＃39; t＆＃39;当他们临时解决的问题最终爆发时，人们会发现。如果人们想赢得他们的游戏，他们就会学会与队友一起努力合作。</p><p>  One of the most important skills for any programmer is their ability to debug problems. This is perhaps the most obvious parallel between Factorio and real software engineering. Something can go wrong very far away from the actual source of the problem. Being able to rapidly hone in on the real problem is a critical skill, and the thinking process is almost identical to tracing the cause of a crash in an actual program. If an assembly machine has stopped working, first you have to see if there are multiple outputs that got backed up. Then you have to check what ingredient it&#39;s missing. Then you have to trace the ingredient back through your factory to find out where you&#39;re making it, and repeat ad nauseum.</p><p>  任何程序员最重要的技能是他们调试问题的能力。这可能是因子和真实软件工程之间最明显的平行。有些东西可以出错，远离问题的实际来源。能够在真正的问题上迅速磨练是一个关键技能，并且思维过程几乎与追查实际程序中的崩溃原因相同。如果装配机已停止工作，首先您必须查看是否有多个备份的输出。然后你必须检查它缺少的成分。然后你必须通过你的工厂追溯成分，找出你的位置＆＃39;重新制作它，并重复ad nustum。 </p><p> Factorio&#39;s debugging gets fairly complicated quite quickly. As soon as you start working on oil processing you&#39;ll be dealing with cracking, where you&#39;re dealing with 3 different outputs and if any of them get backed up for any reason, the entire thing stops. There are cases where your entire factory can grind to a halt because you started researching something that doesn&#39;t require yellow science, which stopped using up robot frames, which stopped using up electric engines, which stopped using lubricant, which stopped consuming heavy oil, which backed up and stopped oil production, which made you run out of petroleum, which broke plastic, which broke red circuits, which broke the rest of the factory. Seasoned players will anticipate scenarios like this and use circuits to construct self-balancing oil cracking to ensure the system is balanced and will only back up if petroleum backs up. A new player who is a good programmer, when presented with a factory that has collapsed, will usually be able to trace the issue back to the source, realize what&#39;s happened, and promptly attempt to figure out a solution. On the other hand, if someone simply plops down a few storage tanks, unless they can provide a good reason (they are very confident we will never stop consuming lubricant in the future), then this is a red flag for how they approach problem solving in their programs.</p><p>因子和＃39;调试相当迅速复杂。一旦你开始努力加油处理你＆＃39; ll正在处理破解，你在哪里＆＃39;重新处理3种不同的产出，如果其中任何一个都以任何原因备份，整个事情都停止了。有些情况下，整个工厂可以努力停止，因为你开始研究一个人不需要黄色科学的东西，这阻止了使用Up机器人框架，这阻止了使用润滑剂停止的电动发动机，这阻止了消耗沉重的备份和停止石油生产的石油，这使得你用完了石油，这破坏了塑料，这打破了红色电路，这突破了工厂的其余部分。经验丰富的玩家将预测这样的场景，并使用电路来构建自平衡的油裂，以确保系统平衡，如果石油备份，则只会备份。一个新的球员是一个很好的程序员，当呈现一个折叠的工厂时，通常能够将问题追溯到源，实现发生了什么＆＃39;发生了什么，并立即尝试弄清楚解决方案。另一方面，如果有人只是溅出几个储罐，否则他们可以提供一个充分的原因（他们非常自信我们将来不会在将来消耗润滑剂），那么这是他们如何接近解决问题的红旗在他们的计划中。</p><p> Situations like these allow Factorio to closely mimic the complex interdependencies that programmers routinely deal with, and the complexity simply increases the more gameplay concepts are added. This closely follows the increased complexity that additional layers of abstraction introduce when attempting to debug a crash that could have potentially occured deep inside one of the frameworks you use.</p><p> 这样的情况允许因子密切模仿程序员经常处理的复杂的相互依赖性，并且复杂性简单地增加了更多的游戏概念。这密切遵循增加复杂性，即在尝试调试可能在您使用的框架之一内可能发生的崩溃时介绍额外的抽象层。</p><p>  Often, initial designs need to be tweaked for performance or throughput. Good programmers will not only accept critique of their designs, but incorporate that feedback into their future work. If they disagree with a proposed change, they will provide a concrete reason for why they disagree so that the team can more accurately weigh the pros and cons of the proposed change.</p><p>  通常，需要为性能或吞吐量调整初始设计。良好的程序员不仅会接受对他们的设计批评，而是将这一反馈纳入他们未来的工作。如果他们不同意拟议的变化，他们将提供一个具体的理由，为什么他们不同意，以便团队更准确地衡量拟议变革的利弊。</p><p> Resisting feedback without providing good reasons is a well-known red flag, but what can also be problematic is a programmer who begrudgingly accepts proposed changes, but refuses to adjust future designs accordingly. They end up requiring constant reminders to adhere to some standard way of solving a problem while giving no reason for why they don&#39;t seem to like the way the team is doing things. These can be ticking time-bombs in organizations, because when left unsupervised they can rapidly accumulate technical debt for other team members. This kind of problem is almost impossible to catch in a traditional interview, unless it&#39;s an internship.</p><p> 抵制反馈而没有提供充分的理由是一个着名的红旗，但是也有问题是一个程序员，他们吝啬地接受提出的改变，但拒绝相应地调整未来的设计。他们最终需要持续的提醒来坚持解决问题的标准方法，同时没有理由为什么他们不喜欢球队正在做事的方式。这些可以在组织中勾选时间炸弹，因为当左侧无监督时，他们可以迅速积累其他团队成员的技术债务。除非实习，否则这种问题几乎是不可能捕获的传统访谈。</p><p>  Refusing to incorporate feedback is often just a slice of a much larger problem, where someone is unable to integrate properly into an existing framework being used. There are many ways to build a factory in Factorio, and each one requires standard methods of building pieces. Failing to adhere to standards can very quickly jam up an entire factory, often in subtle ways that aren&#39;t necessarily obvious to a careless developer.</p><p>  拒绝合并反馈通常只是一个较大的问题，其中某人无法正常集成到正在使用的现有框架中。有很多方法可以在因子中构建工厂，每个方法都需要建筑物的标准方法。未能坚持标准可以非常迅速地堵塞整个工厂，通常以微妙的方式争夺＆＃39; t必须对一个粗心的开发商显而易见。</p><p> In the Main Belt design, a set of 4-8 chunk of belts, divided by 2 spaces to allow for underground belts, are placed in the center of the factory, and all production happens perpendicular to the belt. This design relies on several rules that can wreck havoc if not followed correctly. One, players must always use a splitter to pull items off of a belt, never redirecting the entire belt, otherwise using the empty space for a different belt of items means you&#39;ll have permanently lost one entire belt of resources, even after upgrading belts. Two, all factories must be scalable in a direction perpendicular to the main belt. Failing to do this will rapidly result in either a massive waste of space, or a production line that cannot be scaled up because it&#39;s surrounded by other production lines.</p><p> 在主皮带设计中，一套4-8块皮带，除以2个空格，允许地下带放置在工厂的中心，所有生产都发生在腰带上。这种设计依赖于若干规则，如果没有正确遵循损坏的规则。一个，玩家必须始终使用分离器将物品从皮带上拉，从不重定向整个皮带，否则使用空间用于不同的物品带的空间意味着你甚至永久地失去了整个资源腰带升级带。二，所有工厂必须在垂直于主带的方向上可伸缩。未能做到这一点将迅速导致大规模的空间浪费，或者不能缩放的生产线，因为它被其他生产线包围的＆＃39;</p><p> There are also different ways of building logistic networks. The simplest method is with passive provider chests, but another method uses a storage chest with a filter, which is used to solve the trashed item problem. Both of these methods require properly setting limiters in the right location. Passive provider chests generally are limited by chest space. Storage chests require hooking the inserter for the chest up to the logistics network and ensuring that less than N of an item exists before inserting it. Forgetting to perform these limiting steps is a massive waste of resources.  Consistently forgetting to put limiters on outputs is a red flag for someone who is careless about performance in real-world applications.</p><p> 还有不同的建筑物流网络方式。最简单的方法是具有被动提供者的箱子，但另一种方法使用带有过滤器的存储箱，用于解决垃圾项目问题。这两种方法都需要正确设置正确位置的限制器。被动提供者箱通常受到胸部空间的限制。储存箱需要将插入器连接到物流网络上，确保在插入之前的物品中的少于N.忘记执行这些限制步骤是一种大规模的资源浪费。始终忘记将LIMETS放在输出上是一个关于在现实世界应用中表现的人的红旗。 </p><p> In other cases, the team may be using some pre-designed blueprints, like a nuclear reactor design, or a bot factory. These can be extremely complex, but as long as people are willing to learn how to use them, they can be huge time-savers. Beware of candidates who don&#39;t want to learn how to set up a new item in the bot factory simply because they can&#39;t debug the complex logic that drives it, or ones that get frustrated learning how to use a bot factory despite the clear and obvious benefits.</p><p>在其他情况下，该团队可能使用一些预先设计的蓝图，如核反应堆设计，或机器人厂。这些可能是非常复杂的，但只要人们愿意学习如何使用它们，他们就可以是巨大的节省时间。谨防候选人，谁想知道如何在机器人工厂中学习如何在机器人工厂中设置新项目，因为它们可以＆＃39; t调试驱动它的复杂逻辑，或者沮丧地学习如何使用机器人工厂尽管有明显和明显的好处。</p><p>  Trains in Factorio are a direct analogue to multithreading: one train is one thread of execution, and each train intersection or train stop is a place in memory where two threads could potentially write at the same time. Train signals are locks, or mutexes. All bugs in train networks manifest in exactly the same way software race conditions do, because they&#39;re literally physical race conditions. All of the tradeoffs apply here as well - if you make a lock too large, it slows down your throughput, because now the intersection is blocked for a longer period of time. Incorrectly signaled tracks routinely cause train deadlocks that are exactly the same as a software deadlock, because you end up with a circular lock dependency. The most common deadlock is when a train is too long and unexpectedly blocks a second intersection while waiting to enter one. This second intersection then prevents another train from leaving, preventing the first intersection from ever being unblocked.</p><p>  因子中的列车是多线程的直接模拟：一列火车是一个执行线程，每个列车交叉口或火车站都是内存中的一个地方，其中两个线程可能同时写入。火车信号是锁或互斥锁。列车网络中的所有错误都表现在软件比赛条件的完全相同的方式，因为它们＆＃39;重新实际竞争条件。所有权衡都适用于这里 - 如果您锁定太大，它会减慢吞吐量，因为现在交叉点被阻止了更长的时间。错误地发信号通知轨道常规导致培训死锁与软件死锁完全相同，因为您最终符合循环锁定依赖性。最常见的死锁是当火车太长时，在等待进入一个时意外地阻挡第二个交叉点。然后，第二个交叉点防止另一个火车离开，防止了第一交叉口被畅通无阻。</p><p> The number of lanes of track in your network is equivilent to the number of cores available in your CPU. A single rail line is difficult to scale beyond a few threads because the entire system gets throughput limited very quickly, even with wait areas. The most common design is a two-lane design where each lane is a single direction, but this will eventually suffer from throughput issues when you need trains constantly being unloaded. Thus, large bases tend to have at least 4 lanes, with two outer lanes acting as bypasses to avoid the intersection whenever possible.</p><p> 网络中的轨道的车道数量等于CPU中可用的核心数量。单个轨道线难以扩展超出几个线程，因为整个系统都会非常快速地获得吞吐量，即使使用等待区域也很快。最常见的设计是一个双车道设计，其中每个车道是一个方向，但是当您需要不断卸载的列车时，这最终会遭受吞吐量问题。因此，大碱基倾向于具有至少4个泳道，其两个外部车道作用为绕过以避免尽可能避免交叉口。</p><p> Missing signal problems in these systems can take a ridiculous amount of time to actually show up. A single missing signal in one rail network once caused a deadlock after functioning correctly for  two weeks. This is remniscient of difficult to pin down race conditions in software that only occur once a month or so when under high contention.</p><p> 这些系统中缺少的信号问题可以披着荒谬的时间来实际出现。一个轨道网络中的单个缺失信号曾经在正常运行后造成僵局两周。这是难以在高度争用下每月左右发生一次竞争的竞争条件。</p><p>  Just like in software, scaling up production in Factorio introduces new problems with initial designs, and often require complete redesigns that can pipe resources into factories as fast as possible, while taking advange of production modules and speed module beacons. Belt limits become problematic even at the fastest belt speed, forcing players to find ways to split designs up so that more belts can be put in later down the line, or split up their factories into modules.</p><p>  就像在软件中一样，因子中的缩放生产引入了初始设计的新问题，并且通常需要完全重新设计，可以尽可能快地将资源管制到工厂中，同时采取生产模块和速度模块信标。即使在最快的皮带速度下，皮带限制也变得有问题，强迫玩家找到分裂设计的方法，以便在以后的线路上放置更多的带，或将工厂分成模块。</p><p> Handling your logistics network itself becomes a logistics problem in the late game because of how problematic expansive bot networks are. You generally need to start segmenting the logistics network and either using trains to transport items between them, or build a requester chest/provider chest that propagates items across bounderies.</p><p> 处理物流网络本身成为后期游戏中的物流问题，因为膨胀机器人网络有效了。您通常需要开始分割物流网络，并使用列车来运输它们之间的物品，或者构建跨边界跨越项目的请求者胸部/提供者胸部。</p><p> Managing trains in the late game necessitates switching to a pull architecture from a push architecture, because the push architecture can&#39;t function in high throughput. This inevitably requires taking advantage of the Train Limits feature and learning how circuit networks can be used to encode basic logic, such that a station only requests a train when it is actually ready to completely fill the train with resources, instead of the common early game tactic of simply telling a bunch of trains to go to stations named “Iron Pickup”. This minimizes the number of trains you need while making sure all stops are served on the network.</p><p> 在后期游戏中管理列车需要从推送架构切换到拉动架构，因为推送架构可以＆＃39; t功能高吞吐量。这不可避免地需要利用列车限制特征，并学习如何使用电路网络来编码基本逻辑，使得站仅在其实际准备好与资源完全填充列车时请求火车，而不是常见的早期游戏简单地讲述一束火车的策略去找名为“铁拾音器”的站。这最大限度地减少了所需的列车数，同时确保在网络上提供所有停止。 </p><p> Often times, limitations in the number of possible inputs to an assembly machine and inserter speed require redesigning factories around them, just like how high-speed computing requires being aware of subtle bottlenecks in how your CPU works. These bottlenecks are almost never a problem until you reach a certain scale, at which point they begin to dominate your efficiency.</p><p>通常，对装配机器和插入器速度的可能输入数量的限制需要重新设计它们的工厂，就像高速计算如何需要了解CPU如何工作的微妙瓶颈。在达到一定的规模之前，这些瓶颈几乎从来都不是一个问题，此时他们开始主导你的效率。</p><p>  Eventually, factories get so enormous they must abandon a simple main belt or spaghetti design and use a more scalable framework instead. To reach Megabase-scale, factories generally either use a train system or a module system, which corresponds roughly to microservices or a plugin-architecture.</p><p>  最终，工厂非常巨大，他们必须放弃一个简单的主腰带或意大利面设计，并使用更可扩展的框架。为了达到兆级规模，工厂通常使用火车系统或模块系统，它大致对应于微服务或插件架构。</p><p> A train-based megabase is sometimes referred to a “city-block” design, where trains surrounded factory blocks and control all input and output. Thus, each individual city-block is isolated from all other city-blocks, since all their input is “pure” in that it comes from the train network. This is almost identical to a micro-services architecture (over HTTP) or a multi-process design (using IPC), and has similar potential issues with input and output latency, because results cannot be continually provided, they must be emitted in “packets”, or trains along the network.</p><p> 一列基于火车的兆赛有时被称为“城市块”设计，其中列车包围了工厂块并控制所有输入和输出。因此，每个独立的城市块都是从所有其他城市块隔离的，因为它们的所有输入都是“纯粹的”，因为它来自火车网络。这与微服务架构（通过HTTP）或多流程设计（使用IPC）几乎完全相同，并且具有输入和输出延迟的潜在问题，因为无法不断提供结果，它们必须在“数据包中” “或沿网络列车。</p><p> The plugin architecture seeks to maintain some semblence of a main-belt, but instead splits belts off through the factory and uses modular blocks that take standard inputs and standard outputs. Sometimes this can be achieved entirely through bots, but materials usually need to be belted over long distances. This closely resembles a plugin system for a monolithic application, and has similar tradeoffs.</p><p> 插件架构旨在维护主带的一些序列，而是通过工厂拆除带带的腰带，并使用采用标准输入和标准输出的模块化块。有时这可以完全通过机器人实现，但是通常需要长距离束缚。这与单片应用的插件系统非常相似，并且具有类似的权衡。</p><p> These megabases mark the extreme upper end of a vanilla Factorio server. However, there are plenty of mods to make things much more complex.</p><p> 这些兆页标记了vanilla figursio服务器的极端上端。但是，有大量的模式使事情更复杂。</p><p>  Space Exploration is an overhaul of Factorio that adds an entire space segment of the game, and makes planets have limited resources, requiring players to colonize other planets and use rockets to transfer resources between planets. Because of the enormous latency involved with shipping materials between planets, coordinating these different bases winds up having similar problems to a globally distributed database system. Even the circuit network has to contend with latency, because an automatic request system loses track of items that have been launched but haven&#39;t yet reached the target planet. Not accounting for this will result in a  double-request for all the items you wanted, which is the  exact same problem that distributed systems have when trying to ensure consistency.</p><p>  太空探索是对基础的整体空间探测，增加了游戏的整个空间段，并使行星具有有限的资源，要求玩家在其他行星中殖民，并使用火箭来转移行星之间的资源。由于行星之间的运输材料所涉及的巨大延迟，协调这些不同的基础在全球分布式数据库系统上具有类似的问题。即使是电路网络也必须与延迟争辩，因为自动请求系统丢失了已经发射但没有哈登的物品曲目.T＆＃39; T但到达目标星球。没有考虑到这将导致您想要的所有项目的双重请求，这是分布式系统在尝试确保一致性时具有的完全相同的问题。</p><p>  Collectively, the software industry simply has no idea how to hire software developers. Factorio is probably the best technical interview we have right now, and  that&#39;s embarassing. It is also wildly impractical, taking over 20 hours in an initial multiplayer playthrough, or 8 hours if you have a lot of people and know what you&#39;re doing. What&#39;s the takeaway from this? I don&#39;t know. We certainly can&#39;t switch to using Factorio as an interviewing method - you might as well just give a candidate a take-home assignment.</p><p>  集体，软件行业根本不知道如何聘请软件开发人员。因子可能是我们现在拥有的最好的技术面试，而且柔化。它也是非常不切实际的，在初始多人游戏中超过20小时，或者如果你有很多人，并且知道你和＃39;重新做什么。什么＆＃39;从此外带？我不知道。我们肯定可以＆＃39; t切换到使用因子作为面试方法 - 您可以刚刚给出一个家庭分配。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://erikmcclure.com/blog/factorio-is-best-interview-we-have/">https://erikmcclure.com/blog/factorio-is-best-interview-we-have/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/面试/">#面试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/interview/">#interview</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>