<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在150行Python代码中构建全文搜索引擎 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在150行Python代码中构建全文搜索引擎 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 20:04:31</div><div class="page_narrow text-break page_content"><p>全文搜索到处都是。从Scribd找到一本书，在Netflix上的一部电影，亚马逊上的卫生纸，或通过谷歌的网站上的任何其他东西（如如何完成您的工作作为软件工程师），您今天多次搜索了大量的非结构化数据。更令人惊叹的是，即使您搜索了数百万（或数十亿）的记录，您也有一个响应以毫秒为单位。在这篇文章中，我们将探讨全文搜索引擎的基本组件，并使用它们构建一个可以在数百万个文档上搜索的组件，并根据其相关性以毫秒为单位的相关性排名，不到150行Python代码！</p><p>   您在GitHub上可以找到此博客文章中的所有代码。我将在这里提供与代码片段的链接，所以您可以自己尝试自己运行。您可以通过安装要求（pip install-resure.txt）来运行完整的示例并运行Python Run.py.这将下载所有数据并在没有排名的情况下执行示例查询。</p><p> 在我们跳到构建搜索引擎之前，我们首先需要一些全文，非结构化数据来搜索。我们将搜索英国维基百科的文章的摘要，目前是大约785MB的谷拓XML文件，包含约627万摘要1.我写了一个简单的功能来下载谷拓的XML，但你也可以手动下载文件。</p><p>  该文件是包含所有摘要的一个大XML文件。此文件中的一个摘要包含一个＆lt; doc＆gt;元素，看起来大致如此（我省略了我们不感兴趣的元素）：</p><p> ＆lt; doc＆gt; ＆lt; title＆gt;维基百科：伦敦啤酒洪水＆lt; / title＆gt; ＆lt; url＆gt; https：//en.wikipedia.org/wiki/london_beer_flood＆lt; / url＆gt; ＆lt;摘要＆gt;伦敦啤酒洪水是Meux＆amp的事故; 1814年10月17日，伦敦的CO＆＃39; S Horse Shoe Brewery。当其中一个发酵搬运工爆裂的木桶之桶发生了。 ＆lt; / abstract＆gt; ...＆lt; / doc＆gt;</p><p> 这些位对标题，URL和抽象文本本身感兴趣。我们将表示具有Python DataClass的文档，以便方便数据访问。我们将添加一个连接标题和摘要内容的属性。您可以在此处找到代码。</p><p> 来自Dataclasses导入DataClass @DataClass类摘要：＆＃34;＆＃34;＆＃34;维基百科抽象＆＃34;＆＃34;＆＃34; ID：int标题：str摘要：str url：str @property def fulltext（self）：返回＆＃39; ＆＃39; .join（[自我.title，self .abstract]） </p><p>然后，我们希望从XML中提取抽象数据并解析它，以便我们可以创建抽象对象的实例。我们将通过Gzipped XML进行流，而不将整个文件加载到内存中。我们将按加载顺序分配每个文件ID（即，第一文档将具有ID = 1，第二个将具有ID = 2 ，等等）。您可以在此处找到代码。</p><p> 从LXML导入Etree导入GZIP从Search.Documents导入抽象Def Load_Documents（）：＃使用Gzip .open（＆＃39; data / enw​​iki.latest-abstract.xml.gz＆＃39; ＆＃39; rb＆＃39;）作为f：doc_id = 1＃iterparse将产生整个`doc`元素一旦找到＃closing`＆lt; / doc＆gt; _，Element in Etree .iterparse（f， Events =（＆＃39;结束＆＃39 ;,），tag =＆＃39; doc＆＃39;）：title =元素.findtext（＆＃39; ./ title＆＃39;）url =元素.findtext（＆ ＃39; ./ URL＆＃39;）Abstract =元素.findText（＆＃39; ./ abstract＆＃39;）产量摘要（id = doc_id，title = title = title，url = url，abstract = abstract）doc_id + = 1 #`urement.clear（）`call将显式释放Memory＃用于存储元素元素.clear（）</p><p>  我们将在称为“倒索引”或“帖子列表”的数据结构中将其存储在一起。将其视为一本书背面的索引，其中有一个字母化的相关单词和概念列表，以及读者可以找到的页面编号。</p><p>  实际上，这意味着我们要创建一个字典，我们将语料库中的所有单词映射到他们发生的文档的ID。这将看起来像这样：</p><p> {...＆＃34;伦敦＆＃34 ;: [5245250,2623812,133455,6672401，...]，＆＃34;啤酒＆＃34 ;: [1921376,4111744,684389,2019685，...]， ＆＃34;洪水＆＃34 ;: [3772355,2895814,3461065,5132238，...]，...}</p><p> 请注意，在上面的示例中，将重新核实字典中的单词;在构建索引之前，我们将分解或分析原始文本到单词或令牌列表中。这个想法是我们首先分解或授权文本中的文字，然后在每个令牌上申请零或更多滤波器（例如较低的或茎干），以提高与文本的匹配查询的几率。</p><p>   我们将申请非常简单的象征化，只需在空白上拆分文本。然后，我们将在每个令牌上应用一些过滤器：我们将小写每个令牌，删除任何标点符号，删除英语中的25个最常见的单词（以及“wikipedia”这个词，因为它发生在每个摘要中的每个标题）并将源头施用于每个单词（确保单词映射的不同形式映射到同一个杆，如啤酒厂和啤酒厂3）。 </p><p>导入stemmerstemmer = sewmer .stemmer（＆＃39;英文＆＃39;）def tokenize（文本）：return text .split（）def depard case_filter（text）：返回令牌中令牌的令牌] def stem_filter（令牌）：返回stemmer .stemwords（令牌）</p><p>  导入重新导入stringpunctumy = re .compile（＆＃39; [％s]＆＃39;％re .cape（string .punctumy）def点击_filter（令牌）：返回[标点符号.sub（＆＃39;＆＃39 ;，令牌在令牌中令牌]</p><p> StopWords是非常普遍的单词，我们希望在语料库中（几乎）每个文档中的Occcur。因此，当我们搜索它们时，它们不会有多贡献（即（差不多）当我们搜索这些条款时，每个文档都会匹配）并且只需占用空间，因此我们将在索引时间内过滤它们。 Wikipedia摘要语料库包括每个标题中的“维基百科”这个词，所以我们也会将该单词添加到Stopword列表中。我们用英语删除了25个最常见的单词。</p><p> ＃前25个英文中最常见的单词和＃34; wikipedia＆＃34 ;:＃https://en.wikipedia.org/wiki/most_common_words_in_englishstopwords = set（[＆＃39;＆＃39;＆＃39;是＆＃39; ＃39 ;,＆＃39;＆＃39 ;,＆＃39;＆＃39;和＃39;和＃39;一个＆＃39;一个＆＃39;在＆＃39;＆＃39; ＃39;那个＆＃39 ;,＆＃39;＆＃39;我＆＃39 ;,＆＃39;它＆＃39;＆＃39;＆＃39;，＆＃39;。，＆＃39;。，＆＃39; 39;，＆＃39;＆＃39;和＃39;与＃39 ;,＆＃39;他＆＃39;和＃39 ;,＆＃39;你＆＃39;你＆＃39 ;,＆＃39;你＆＃39;。 39;做＆＃39;＆＃39;＆＃39;这个＆＃39;这个＆＃39 ;,＃39;但＆＃39;他＆＃39;＆＃39; by＃39; by＆＃39; by＆＃39; ;，＆＃39;来自＆＃39 ;,＆＃39; wikipedia＆＃39;]）def stop word_filter（令牌）：如果令牌不在停止词，则返回令牌中的令牌令牌，如果不是在stopwords中，则返回</p><p> 将所有这些过滤器一起带到一起，我们将构建一个分析功能，该函数将在每个摘要中的文本上运行;它会将文本授予单独的单词（或相反，令牌），然后连续将每个过滤器应用于令牌列表。订单很重要，因为我们使用一个非倾斜的stopword列表，因此我们应该在Stef_filter之前应用StopWord_Filter。</p><p> def分析（文本）：tokens = tokenize（texkens）= dightcase_filter（令牌）令牌= punctudate_filter（令牌）令牌= stopword_filter（令牌）令牌= step_filter（令牌）返回[令牌中的令牌，如果令牌，则repkens返回</p><p>  我们将创建一个将存储索引和文档的索引类。文档字典通过ID存储DataClasses，索引键将是令牌，其中值是令牌发生的文档ID的值： </p><p>Warning: Can only detect less than 5000 characters</p><p>让我们展开我们的抽象DataClass来计算并存储它在索引时的术语频率。这样，当我们想要对我们的无序文件列表批准的文件列表时，我们将轻松访问这些数字：</p><p> ＃在文件中从集合中的文件。从.Analysy导入计数器.Analysy导入分析@dataClass类摘要：#snip def分析（self）：＃计数器将创建一个字典计算数组中的唯一值的字典：＃{＆＃39;伦敦＆＃39 ; 12，＆＃39;啤酒＆＃39 ;: 3，...} self .term_frequence =计数器（分析（self .fulltext））def term_fricency（self，term）：返回self .term_frequences .get（术语，0 ）</p><p> 当我们索引数据时，我们需要确保生成这些频率计数：</p><p> ＃在index.py中我们添加`document.analyze（）def index_document（self，document）：if文件.id.id不在self .documents：self。文件箱[document .id] = document文档.Analyze（）</p><p> 我们将修改我们的搜索功能，以便我们可以将排名对我们的结果集应用于文档。我们将使用索引和文档存储中使用相同的布尔查询来获取文档，然后我们将为每个结果集中的每个文档进行获取，我们将简单地总结在该文档中每个术语发生的频率</p><p> def search（self，查询，search_type =＆＃39;和＃39;和＃39;，等级= true）：#snip if等级：返回self .rank（分析_query，document）返回文档def等级（self，synalzed_query，文件）：结果= []如果不是文档：在文档中返回文档的结果：score = sum（分析中令牌的令牌文档_query]））结果.append（（文档，分数））返回排序（结果，key = lambda doc ：doc [1]，反向= true）</p><p>  这已经更好了，但有一些明显的短暂录。在评估查询的相关性时，我们将考虑所有查询术语是等效的值。然而，在确定相关性时，某些术语可能很少没有区分力量;例如，有许多关于啤酒的文件的集合将有几乎在几乎所有文件中出现了“啤酒”一词（事实上，我们已经试图通过删除来自索引中的25个最常见的英语单词来解决这个问题）。在这种情况下搜索“啤酒”这个词基本上是另一种随机排序的。 </p><p>为了解决这个问题，我们将为我们的评分算法添加另一个组件，这将减少索引中经常发生的术语的贡献。我们可以使用术语的收集频率（即，此术语在所有文档中发生一次），但在实践中使用文档频率（即索引中的文档中的许多文档）。我们毕竟正在尝试排名文件，因此有一个文档级别统计有意义。</p><p> 我们将通过将索引中的文档数（n）除以包含该术语的文档的数量来计算逆文档频率，并采用该术语的数量。</p><p>  然后我们将在排名期间简单地使用逆文档频率的术语频率，因此匹配语料库中罕见的术语将有助于相关性分数5.我们可以轻松计算来自可用数据的逆文档频率我们的指数：</p><p> #ind.py.py import math def document_frequency（self，token）：return len（self .index .get（令牌，set（）））def inverse_document_frequency（self，token）：＃manning，hinrich和schütze使用log10，所以我们这样做也是，即使它＃＆＃39; t真的很重要我们使用哪个日志我们使用＃https://nlp.stanford.edu/ir-book/html/htmledition/inverse-document-frequency-1.html return math .log10 （Len（Self.Documents）/ self .document_fricuency（令牌））def等级（self，synationzed_query，documents）：结果= []如果不是文档：在Documents中的文档返回结果：令牌中的令牌= 0.0在分析中：TF =文档.TERM_FREQUENCY（令牌）IDF = SELF .INVERSE_DOCUMENT_FREQUCY（令牌）得分+ = TF * IDF结果.APPEND（（文档，分数））返回排序（结果，key = lambda doc：doc [1]，反向= true）</p><p>  这是一个基本的搜索引擎，只有几行Python代码！您可以在GitHub上找到所有代码，我提供了一个Utility功能，将下载Wikipedia摘要并构建索引。安装要求，在您的Python控制台中运行它，并与数据结构和搜索搞乱。</p><p> 现在，显然这是一个项目来说明搜索概念以及它如何如此快（即使是排名，我也可以在我的笔记本电脑上搜索和排名6.27M文档，与Python这样的“慢”语言）而不是生产级软件。它完全在我的笔记本电脑上运行，而Lucene这样的库利用超高效的数据结构，甚至优化磁盘试图，以及Elasticsearch和Solr Scale Lucene，如果不是数千台机器，则为数百个。</p><p> 这并不意味着我们无法考虑在这种基本功能上有趣的扩展;例如，我们假设文档中的每个字段都对相关性具有相同的贡献，而标题中的查询术语匹配可能应该比描述中的匹配更强烈地重量。另一个有趣的项目可以扩展查询解析;没有理由为什么所有或只是一个术语需要匹配。为什么不排除某些术语，或者在各个条款之间或之间进行？我们可以将索引持续到磁盘，并使其缩放超出我的笔记本电脑RAM的范围吗？ </p><p>摘要通常是维基百科文章的第一段或第一个句子。整个数据集目前约为±796MB的Gzipped XML。如果您想自行尝试和混淆代码，则可以使用较小的转储具有可用的文章的子集;解析XML和索引需要一段时间，需要大量的内存。 ↩︎</p><p> 我们也将在内存中拥有整个数据集和索引，因此我们可能会跳过内存中的原始数据。 ↩︎</p><p> 无论是疑惑是否是一个好主意就是辩论的主题。它将减少您的索引的总大小（即较少的独特单词），但源于启发式;我们抛弃了非常有价值的信息。例如，思考大学，普遍，大学和宇宙所倾向于大风的宇宙。我们正在失去区分这些词的含义，这会对相关性产生负面影响。有关源（和lemmatization）的更详细文章，请阅读这篇优秀的文章。 ↩︎</p><p> 我们显然只需使用笔记本电脑的RAM，但它是一个非常常见的做法，无法在索引中存储实际数据。 Elasticsearch将其数据存储在磁盘上的普通旧JSON，并且仅在Lucene（底层搜索和索引库）本身中存储索引数据</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bart.degoe.de/building-a-full-text-search-engine-150-lines-of-code/">https://bart.degoe.de/building-a-full-text-search-engine-150-lines-of-code/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1054177.html"><img src="http://img2.diglog.com/img/2021/3/thumb_b5159c86efb7506da638eb9e2322fd33.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054177.html">3,100个网站的分析表明，医院使用代码来隐藏包含搜索引擎爬行的定价数据的页面，违反了美国联邦法律 </a></div><span class="my_story_list_date">2021-3-23 18:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1053950.html"><img src="http://img2.diglog.com/img/2021/3/thumb_48aeae9c39e0eb4679ad868bed7d3502.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1053950.html">没有代码商业智能服务Y42募集了29万美元种子 </a></div><span class="my_story_list_date">2021-3-22 21:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1053543.html"><img src="http://img2.diglog.com/img/2021/3/thumb_2091f93d1c3b1d6b4f20529e22609b4c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1053543.html">codetour：与录制和播放CodeBases的引导演练的vs代码扩展 </a></div><span class="my_story_list_date">2021-3-20 9:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1053479.html"><img src="http://img2.diglog.com/img/2021/3/thumb_72690d210d8d8119edfa8897d210076b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1053479.html">额外的retunch roundup：ai吃Fintech，筹款签证，没有代码过渡技巧，更多 </a></div><span class="my_story_list_date">2021-3-20 6:17</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>