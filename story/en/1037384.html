<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>功能语言中的对象Objects in Functional Languages</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Objects in Functional Languages<br/>功能语言中的对象</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-01 04:45:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/69e7604edbe2639b85b75d79d1d2e948.png"><img src="http://img2.diglog.com/img/2020/12/69e7604edbe2639b85b75d79d1d2e948.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This could be a sticking point, so I&#39;ll get this out of the way up-front: I find arguments over whether such-and-such a thing is “really” functional or “really” imperative or “really” object-oriented to be for the most part frustrating and useless. A lot of these arguments boil down to value judgments in disguise (a thing I&#39;ve touched on in the past when  talking about the rhetorical emphasis placed on math in programming) and many of the rest turn out to be based on informal definitions where &#39;functional&#39; means &#39;like my favorite or first functional language&#39;.  1 I prefer to think about these concept less in terms of necessary criteria and hard lines, and more in terms of influence and approach and focus.</p><p>这可能是一个棘手的问题，所以我会先解决这个问题：我发现某某事物是“真正”功能还是“真正”命令式还是“真正”面向对象的争论在大多数情况下是令人沮丧和无用的。这些论点中很多都归结为变相的价值判断（我过去在谈到编程中对数学的强调修辞时曾谈到过这一点），而其他许多则基于非正式定义，其中“ “功能性”是指“就像我最喜欢的语言或第一种功能性语言”。 1我宁愿从必要的标准和强硬的角度来考虑这些概念，而从影响力，方法和重点方面来考虑。</p><p> The paper   On Understanding Data Abstraction Revisited by William Cook (itself a paper that revisits   On understanding data types, data abstraction, and polymorphism by Luca Cardelli and Peter Wegner) lays out simple definitions of the often-used concepts of “abstract data type” and “object”. His definition of “object” is, of course, not the only one, but I think it&#39;s a useful one. Importantly, Cook&#39;s definition is based on abstract criteria that can apply even when the language itself does not have an explicit concept of an “object”. To emphasize this, I&#39;m going to use Haskell in this blog post to demonstrate a pure functional variation on “object-oriented programming”  2.</p><p> 威廉·库克（William Cook）重访的“了解数据抽象”一文（本身是Luca Cardelli和Peter Wegner的“关于理解数据类型，数据抽象和多态性的文章”）对常用的“抽象数据类型”概念进行了简单定义， “目的”。当然，他对“对象”的定义并不是唯一的定义，但我认为这是一个有用的定义。重要的是，库克的定义基于抽象标准，即使该语言本身没有明确的“对象”概念，该标准也可以适用。为了强调这一点，我将在此博客文章中使用Haskell来演示“面向对象编程” 2的纯函数变体。</p><p> Beyond being a useful definition, Cook&#39;s formulation is also a valuable design pattern, one which has both advantages and disadvantages when designing programs. Consequently, the goal of this blog post is twofold: first, to show how “objects” can (under some definition) exist in a language like Haskell which has no built-in notion of “object-oriented programming”, and secondly, to show the advantages and disadvantages of code written in this style.</p><p> 库克的公式不仅是有用的定义，而且还是一种有价值的设计模式，在设计程序时既有优点也有缺点。因此，此博客文章的目标是双重的：首先，说明“对象”如何（在某种定义下）存在于Haskell之类的语言中，而该语言没有内置的“面向对象程序设计”概念；其次，说明以这种方式编写的代码的优缺点。</p><p>   […] has a public name, a hidden representation, and operations to create, combine, and observe values of the abstraction.</p><p>   […]具有公用名称，隐藏的表示形式以及创建，组合和观察抽象值的操作。</p><p> To use a simplified version of his example, here&#39;s a (not terribly efficient) way of defining a “set of integers” in Haskell as an abstract data type. In this case, we&#39;ve got an  IntSet type whose representation can be easily hidden, because the operations that a consumer of this library cares about about have been defined in terms of that abstract representation.</p><p> 为了使用他的示例的简化版本，这是一种在Haskell中将“整数集”定义为抽象数据类型的方法（效率不高）。在这种情况下，我们有一个IntSet类型，该类型的表示可以很容易地隐藏，因为该库的使用者关心的操作已经根据该抽象表示进行了定义。</p><p> -- we&#39;ll export `IntSet` but not the constructorsdata IntSet = SetEmpty | SetInsert Int IntSetempty :: IntSetempty = SetEmptyisEmpty :: IntSet -&gt; BoolisEmpty SetEmpty = TrueisEmpty _ = Falseinsert :: Int -&gt; IntSet -&gt; IntSetinsert x set | contains set x = set | otherwise = SetInsert x setcontains :: IntSet -&gt; Int -&gt; Boolcontains SetEmpty x = Falsecontains (SetInsert y rest) x | x == y = True | otherwise = contains rest x</p><p> -我们将导出“ IntSet”，而不是构造函数。data IntSet = SetEmpty | SetInsert Int IntSetempty :: IntSetempty = SetEmptyisEmpty :: IntSet-> BoolisEmpty SetEmpty = TrueisEmpty _ = Falseinsert :: Int-> IntSet-> IntSetinsert x set |包含集合x =集合|否则= SetInsert x setcontains :: IntSet-> Int-> Boolcontains SetEmpty x = Falsecontains（SetInsert和rest）x | x == y =真|否则=包含剩余x</p><p> This is probably not a terribly controversial definition or design: it&#39;s a pretty typical one for most functional languages! …well, it might be controversial to  use since it&#39;s got awful algorithmic performance, but it&#39;s fairly unobjectionable as a teaching tool, at least.</p><p> 这可能不是一个有争议的定义或设计：对于大多数功能语言来说，这是非常典型的！ …嗯，由于它具有糟糕的算法性能，因此使用该方法可能会引起争议，但至少作为一种教学工具，它是毫无争议的。</p><p> What would a user see when looking at the documentation for this module? Since we&#39;re not exporting the constructors for  IntSet, it&#39;ll look something like this:</p><p>用户在查看此模块的文档时会看到什么？由于我们没有导出IntSet的构造函数，因此它看起来像这样：</p><p> data IntSetempty :: IntSetisEmpty :: IntSet -&gt; Boolinsert :: Int -&gt; IntSet -&gt; IntSetcontains :: Int -&gt; IntSet -&gt; Bool</p><p> 数据IntSetempty :: IntSetisEmpty :: IntSet-> Boolinsert :: Int-> IntSet-> IntSetcontains :: Int-> IntSet-> Bool</p><p> The ability to hide the definition of  IntSet is the thing that makes this an abstract data type. A user of the library doesn&#39;t care—and ideally doesn&#39;t  need to care—what constructors hide behind that  IntSet.</p><p> 隐藏IntSet定义的能力使它成为抽象数据类型。库的用户不在乎-理想情况下也不需要在乎-构造函数隐藏在该IntSet的后面。</p><p>  Cook then goes on to describe “objects”. Here&#39;s another (equally inefficient) implementation of  IntSet, which I&#39;ll define as  OIntSet so I can easily refer to both:</p><p>  然后，库克继续描述“对象”。这是IntSet的另一个（同样效率不高的）实现，我将其定义为OIntSet，这样我就可以轻松地引用这两者：</p><p> data OIntSet = OIntSet { oIsEmpty :: Bool , oContains :: Int -&gt; Bool }oEmpty :: OIntSetoEmpty = OIntSet { oIsEmpty = True , oContains = \_ -&gt; False }oInsert :: Int -&gt; OIntSet -&gt; OIntSetoInsert x set | oContains set x = set | otherwise = OIntSet { oIsEmpty = False , oContains = \i -&gt; i == x || oContains set i }</p><p> 数据OIntSet = OIntSet {oIsEmpty :: Bool，oContains :: Int-> Bool} oEmpty :: OIntSetoEmpty = OIntSet {oIsEmpty = True，oContains = \ _-> False} oInsert :: Int-> OIntSet-> OIntSetoInsert x set o包含set x = set |否则= OIntSet {oIsEmpty = False，oContains = \ i-> i == x || o包含i}</p><p> It&#39;s possible that we can choose our export list carefully so that this implementation of  OIntSet reveals the exact same set of operations as the previous one. However, there&#39;s a major difference here:  OIntSet is not actually hiding a specific type. Instead, it just bundles the relevant set of operations inside of a record of functions, which acts like an interface type. In both the ADT-based approach and the “object”-based approach, a user does not know about the internal representation of  OIntSet, but in the ADT approach, this is because there exists a single representation which is non-public, while in the “object”-based approach, there may be multiple separate implementations that are indistinguishable.</p><p> 我们可能会仔细选择导出列表，以便OIntSet的此实现可以显示与上一个完全相同的一组操作。但是，这里有一个主要区别：OIntSet实际上并不隐藏特定类型。取而代之的是，它只是将一组相关的操作捆绑在功能记录中，功能记录的作用类似于接口类型。在基于ADT的方法和基于“对象”的方法中，用户都不知道OIntSet的内部表示，但是在ADT方法中，这是因为存在一个非公开的单一表示，而在在基于“对象”的方法中，可能存在无法区分的多个独立实现。</p><p>  An “object”-like representation allows for a vast amount of flexibility. Because a consumer of an  OIntSet can use any value as long as the value has provided implementations of the relevant “methods”, we can easily and conveniently define new instances of  OIntSet that have radically different internal representations. For example, we can define infinite sets that use simple numerical computations to define their  oContains method, like this set of all even numbers:</p><p>  类似于“对象”的表示形式具有极大的灵活性。因为OIntSet的使用者可以使用任何值，只要该值提供了相关“方法”的实现，我们就可以轻松方便地定义具有完全不同的内部表示形式的OIntSet的新实例。例如，我们可以定义使用简单数值计算来定义其oContains方法的无限集，例如所有偶数的集合：</p><p> oEvenNumbers :: OIntSetoEvenNumbers = OIntSet { oIsEmpty = False , oContains = \i -&gt; i `mod` 2 == 0 }</p><p>oEvenNumbers :: OIntSetoEvenNumbers = OIntSet {oIsEmpty = False，oContains = \ i-> i`mod` 2 == 0}</p><p> Or we could construct  OIntSet values that use a different data representation, such as a list, to store the members of the set:</p><p> 或者我们可以构造OIntSet值，该值使用其他数据表示形式（例如列表）来存储集合的成员：</p><p> oFromList :: [Int] -&gt; OIntSetoFromList list = OIntSet { oIsEmpty = null list , oContains = \i -&gt; i `elem` list }</p><p> oFromList :: [Int]-> OIntSetoFromList list = OIntSet {oIsEmpty =空列表，oContains = \ i-> i`elem`列表}</p><p> But even though these  OIntSet definitions use different underlying data representations, they expose the same interface, so we can use the same operations to manipulate them. For example, we can define an  oUnion operation which computes the union of two  OIntSet objects, since that operation is easily expressible in terms of  oIsEmpty and  oContains:</p><p> 但是，即使这些OIntSet定义使用不同的基础数据表示形式，它们也暴露了相同的接口，因此我们可以使用相同的操作来操作它们。例如，我们可以定义一个oUnion操作，该操作计算两个OIntSet对象的并集，因为该操作很容易用oIsEmpty和oContains表示：</p><p> oUnion :: OIntSet -&gt; OIntSet -&gt; OIntSetoUnion set set&#39; = OIntSet { oIsEmpty = oIsEmpty set &amp;&amp; oIsEmpty set&#39; , oContains = \i -&gt; oContains set i || oContains set&#39; i }</p><p> oUnion :: OIntSet-> OIntSet-> OIntSetoUnion set set'= OIntSet {oIsEmpty = oIsEmpty set && oIsEmpty set'，oContains = \ i-> oContains set i || o包含设置的“ i”</p><p> Our  oUnion operation—indeed, any operation we define—can work on any two  OIntSets even if they have wildly different internal representations. We can even use this to combine all of our previously-defined  OIntSet constructors into one expression, to create a set that uses a combination of Haskell lists, numeric predicates, and closures to represent a set:</p><p> 我们的oUnion操作（实际上是我们定义的任何操作）都可以在任何两个OIntSet上使用，即使它们的内部表示形式完全不同。我们甚至可以使用它来将所有先前定义的OIntSet构造函数组合到一个表达式中，以创建使用Haskell列表，数字谓词和闭包的组合来表示一个集合的集合：</p><p>  This is a very convenient way of building certain abstractions. By building around external interfaces, you can include varying data representations that easily work together.</p><p>  这是构建某些抽象的非常方便的方法。通过围绕外部接口构建，您可以包括易于协同工作的各种数据表示形式。</p><p> This example is clearly a little bit contrived, so it&#39;s probably worth giving some other “real-world” examples where this design approach is useful. Object-oriented programming is generally cited as a good fit for a particular style of user interface programming, because it allows you to define classes of “widgets” that expose a common interface but have different internal representations. You could build a Haskell GUI library in this style by defining  Widgets as “objects” with a common interface, something like this:</p><p>该示例显然是人为设计的，因此可能值得给出一些其他使用该设计方法的“实际”示例。通常认为面向对象编程非常适合特定样式的用户界面编程，因为它允许您定义暴露共同界面但具有不同内部表示形式的“窗口小部件”类。您可以通过将小部件定义为具有公共界面的“对象”，来构建这种风格的Haskell GUI库，如下所示：</p><p> data Widget = Widget { drawWidget :: Ctx -&gt; Position -&gt; IO () , handleEvent :: Event -&gt; IO () }</p><p> 数据Widget = Widget {drawWidget :: Ctx-> Position-> IO（），handleEvent :: Event-> IO（）}</p><p> This is similar to the approach taken by the  Brick TUI library, which has  its own  Widget record.</p><p> 这类似于Brick TUI库采用的方法，该库具有自己的Widget记录。</p><p>  One major concern with this style of data representation is performance and optimization. Consider our original ADT representation for  IntSet: it&#39;s inefficient, yes, but we can make it more efficient in a number of ways. For example, we could modify it so that, instead of always inserting new elements “at the front”, we can instead insert them in such a way that the internal representation of the set is always sorted lowest-to-highest. This means that we may no longer have to traverse the entire list to check for element membership. Even better, we might swap out the list-like representation for a binary tree representation, maybe doing some rebalancing in certain cases.</p><p>  这种数据表示方式的主要关注点是性能和优化。考虑我们对IntSet的原始ADT表示形式：效率低下，是的，但是我们可以通过多种方式提高效率。例如，我们可以对其进行修改，以使与其始终在“最前面”插入新元素，而不必总是以最低到最高的顺序对集合进行内部插入。这意味着我们可能不再需要遍历整个列表来检查元素成员身份。更好的是，我们可以将列表式表示形式换成二叉树表示形式，在某些情况下可能需要重新平衡。</p><p> There is no way  in general to apply these optimizations to the  OIntSet-style program. You could define an  OIntSet that sits in front of a balanced tree and therefore has faster lookup and insertion, but once it&#39;s sitting behind the interface, you no longer have access to those internals. You cannot, for example, write an  oUnion operation that rebalances the binary trees behind the two sets it&#39;s operating on: it doesn&#39;t even know if both sets  are backed by trees!</p><p> 通常没有办法将这些优化应用于OIntSet风格的程序。您可以定义一个OIntSet，它位于一棵平衡树的前面，因此具有更快的查找和插入速度，但是一旦它位于接口的后面，您就无法再访问这些内部组件。例如，您不能编写一个oUnion操作来重新平衡它所操作的两个集合后面的二叉树：它甚至不知道两个集合是否都受树支持！</p><p> In effect, the major selling point of the “object”-style design here is also a major downside: you don&#39;t have guarantees about the specific representation of data, which means your programs can easily mix-and-match different representations, but it also means that your program can&#39;t make use of representation-specific knowledge in ways that are advantageous.</p><p> 实际上，“对象”样式设计的主要卖点也是主要缺点：您无法保证数据的特定表示形式，这意味着您的程序可以轻松混合并匹配不同的表示形式，但是这也意味着您的程序无法以有利的方式利用特定于表示的知识。</p><p> There&#39;s another major concern as well, and that&#39;s that the specific choice of “object” representation can make a big difference in terms of what operations you can and cannot support. Look back at  OIntSet—I was able to define  oUnion, but what about  oIntersection? It turns out that it&#39;s not actually possible using the specific representation I&#39;ve chosen  3:</p><p> 还有另一个主要问题，那就是“对象”表示的特定选择在可以支持和不能支持的操作方面会产生很大的不同。回顾一下OIntSet，我能够定义oUnion，但是oIntersection呢？事实证明，使用我选择的特定表示形式实际上是不可能的：</p><p> oIntersection :: OIntSet -&gt; OIntSet -&gt; OIntSetoIntersection set set&#39; = OIntSet { oIsEmpty = {- ??? -} , oIntersection = \i -&gt; oContains set i &amp;&amp; oContains set&#39; i }</p><p>oIntersection :: OIntSet-> OIntSet-> OIntSetoIntersection集set'= OIntSet {oIsEmpty = {-??? -}，oIntersection = \ i-> o包含集合i && o包含集合'i}</p><p> How do I implement  oIsEmpty? I might naïvely try to write the inverse of  oUnion and define it as  oIsEmpty set || oIsEmpty set&#39;, but that&#39;s not at all what I want: the intersection of the set of even numbers and the set of odd numbers is an empty set, but neither the even nor the odd numbers are empty, so this would incorrectly compute their intersection as non-empty.</p><p> 如何实现oIsEmpty？我可能天真地尝试写oUnion的逆并将其定义为oIsEmpty set ||。 oIsEmpty集”，但这根本不是我想要的：偶数集和奇数集的交集是一个空集，但是偶数和奇数集都不为空，因此这会错误地计算出它们的交集为非空。</p><p> This is an artifact of the specific interface chosen for the set. I could modify the interface and be able to recapture this behavior, but almost any choice I make is going to have different repercussions: for example, I could add a method to enumerate all the values contained in the set, at which point I now have a convenient way to find out whether the intersection of two sets is indeed empty… but now I have made infinite sets significantly more difficult to define!</p><p> 这是为集合选择的特定接口的构件。我可以修改接口并能够重新捕获此行为，但是我所做的几乎任何选择都会产生不同的影响：例如，我可以添加一种方法来枚举集合中包含的所有值，此时我有了一种方便的方法来找出两个集合的交集是否确实是空的……但是现在，我使无限集的定义变得更加困难！</p><p> This is another face of the performance problem: the specific interface chosen is going to have far-reaching ramifications not only on what operations are efficient or inefficient, but on what operations are  possible to write at all.</p><p> 这是性能问题的另一面：所选的特定接口不仅会对有效的操作或无效的操作产生影响，而且对可能编写的操作也将产生深远的影响。</p><p>  A lot of definitions of “objects” in the sense of “object-oriented programming” go back to Alan Kay. Kay was a major force behind the SmallTalk programming language, and he  once gave this definition of OOP:</p><p>  在“面向对象编程”的意义上，许多“对象”的定义都可以追溯到艾伦·凯。 Kay是SmallTalk编程语言背后的主要力量，他曾经对OOP进行了以下定义：</p><p> OOP to me means only messaging, local retention, and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I&#39;m not aware of them.</p><p> 对我而言，OOP意味着仅消息传递，本地保留，状态过程的保护和隐藏以及所有事物的极端后期绑定。可以在Smalltalk和LISP中完成。可能还有其他系统可以做到这一点，但我不知道它们。</p><p> Our treatment of “objects” here does not fit in this definition, but neither do most languages that are typically called “object-oriented”. In particular, “late-binding” here means that methods are not looked up until runtime: in a proper SmallTalk-like system, this would be done  by name, meaning that even virtual dispatch in a language like C++ or Java does not count. You  can use languages like Ruby or Python in a way that matches this definition, but they&#39;re not typically used this way. Many object-oriented languages are also somewhat lax with respect to protection of local information: Python is a big offender here, as its instance variables are typically made private by convention rather than a language mechanism! And of course, almost none of the modern OOP languages are built  strictly around messaging.</p><p> 这里我们对“对象”的处理不符合该定义，但是大多数通常称为“面向对象”的语言也不适用。特别地，这里的“后期绑定”意味着直到运行时才查找方法：在适当的类似SmallTalk的系统中，这将通过名称来完成，这意味着即使使用C ++或Java之类的虚拟调度也不会计算在内。您可以使用符合该定义的方式来使用Ruby或Python之类的语言，但通常不会以这种方式使用它们。在保护本地信息方面，许多面向对象的语言也有些松懈：Python在这里是一个大罪犯，因为它的实例变量通常是通过约定而不是一种语言机制来私有的！当然，几乎没有现代的OOP语言是严格围绕消息传递构建的。</p><p> However, many of these languages are considered “object-oriented” because they try to capture the advantages of these features while not adhering strictly to them. Late-binding and all-you-can-do-is-send-a-message systems require some complicated machinery in order to implement efficiently, because otherwise the pervasive lookup of methods can become a source of slowdown, so many systems use virtual dispatch instead of extreme late-binding. Similarly, many systems do not adhere to strict information-hiding, but allow some public information for various conveniences (e.g. non- private variables in C++ or Java). In many ways, these are design decisions which help sandbag against the problems with “objects” described above. If we&#39;re being sticklers about the Alan Kay definition, we might call these languages “object-oriented-ish”.</p><p>但是，这些语言中有许多被认为是“面向对象的”，因为它们试图抓住这些功能的优势而又不严格遵守这些功能。后期绑定和所有您可以发送的消息系统需要一些复杂的机制才能有效实施，因为否则方法的普遍查找可能会导致速度变慢，因此许多系统都使用虚拟调度而不是极端的后期绑定。类似地，许多系统不遵守严格的信息隐藏，但为了各种便利而允许一些公共信息（例如，C ++或Java中的非私有变量）。从许多方面来看，这些都是有助于沙袋克服上述“对象”问题的设计决策。如果我们对Alan Kay的定义持保留态度，我们可以将这些语言称为“面向对象的语言”。</p><p> The Cook definition is something of a distillation of several of the properties which are used by these “object-oriented-ish” languages. It encodes virtual dispatch: all operations here are higher-order functions, so you cannot know which you are calling until you are passed a function to call. It encodes hiding of local information in a way that&#39;s arguably stricter than Java or C++: an external consumer of this code cannot depend on anything but the provided functions, so any “local” information is necessarily hidden. If used appropriately, it can encode protection of state-process: the above example is pure, but if our “methods” had a type like  IO (), we could include methods which update internal state (perhaps contained in an  IORef) in response to other operations.</p><p> Cook的定义是对这些“面向对象的”语言所使用的若干属性的提炼。它对虚拟调度进行编码：这里的所有操作都是高阶函数，因此，除非您传递了要调用的函数，否则您无法知道正在调用的对象。它以比Java或C ++更严格的方式对本地信息的隐藏进行编码：此代码的外部使用者只能依赖提供的功能，而不能依赖任何东西，因此任何“本地”信息都必须被隐藏。如果使用得当，它可以对状态过程的保护进行编码：上面的示例是纯净的，但是如果我们的“方法”具有类似IO（）的类型，则我们可以包括用于响应时更新内部状态（可能包含在IORef中）的方法。进行其他操作。</p><p> Alan Kay&#39;s definition is valuable, not just because it describes a powerful approach to programming as implemented in object-oriented languages like SmallTalk and  IO, but also because because it describes the behavior of a number of  systems that are not programming languages while also capturing what makes those systems powerful: for example, Microsoft&#39;s  Component Object Model, Plan 9&#39;s  9P file system protocol, and arguably even  HTTP itself are, from a certain point of view, systems based around doing extremely late-bound message-passing. But I would argue that Cook&#39;s definition is also valuable, because it describes both languages in wide use  as well as pattern of data modeling in other systems.</p><p> 艾伦·凯（Alan Kay）的定义很有价值，不仅因为它描述了一种强大的编程方法，该方法以诸如SmallTalk和IO之类的面向对象语言实现，而且还因为它描述了许多非编程语言的系统的行为，同时还捕获了使这些系统变得强大：例如，从某些角度来看，Microsoft的Component Object Model，Plan 9的9P文件系统协议，甚至可以说HTTP本身都是基于进行极晚绑定消息传递的系统。但是我认为Cook的定义也很有价值，因为它描述了广泛使用的两种语言以及其他系统中的数据建模模式。</p><p> I once read a blog post that complained about zippers—a pure functional interface to certain data structures, one that&#39;s not even embedded in a monad or some other side-effect-ey abstraction—by claiming that they were “imperative”. Nonsense! This was clearly an example of a value judgment masquerading as some kind of technical truth, and a pretty shallow one at that. I&#39;d be interested in an analysis of the advantages and disadvantages of using zippers, but “I think this abstraction is imperative, therefore it is bad,” is not that!</p><p> 我曾经读过一篇博客文章，抱怨拉链是对某些数据结构的纯功能接口，甚至没有嵌入到monad或其他副作用抽象中，它们声称它们是“命令性的”。废话！显然，这是一个价值判断伪装成某种技术真理的例子，而与此同时还很肤浅。我会对使用拉链的优缺点进行分析，但“我认为这种抽象是必须的，因此很糟糕，”不是那样！</p><p> Cook&#39;s paper uses an ML-like pseudocode for these examples, and also includes more detail: I&#39;ve pared them down a bit.</p><p> 对于这些示例，Cook的论文使用类似于ML的伪代码，并且还包括更多详细信息：我已经对它们进行了简化。</p><p> Actually, if you look closely at my representation, it  is possible, just not practical: in Haskell,  Int is a machine integer with a finite number of values, so we could enumerate every possible  Int value and check whether it&#39;s present in both sets. That means I could implement this operation as  oIsEmpty = or [ oContains set i &amp;&amp; oContains set&#39; i | i &lt;- [minBound..maxBound]], which just needs to check  2^64 possible values on most modern processor architectures!</p><p> 实际上，如果您仔细观察一下我的表示形式，那是有可能的，只是不切实际：在Haskell中，Int是具有有限数量值的机器整数，因此我们可以枚举每个可能的Int值并检查它是否在两个集合中都存在。这意味着我可以将该操作实现为oIsEmpty =或[o包含集合i && o包含集合'i | i <-[minBound..maxBound]]，仅需检查大多数现代处理器体系结构上2 ^ 64个可能的值！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/功能/">#功能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/定义/">#定义</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>