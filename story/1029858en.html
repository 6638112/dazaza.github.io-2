<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>纯sh圣经-POSIX sh外部进程的替代方案</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">纯sh圣经-POSIX sh外部进程的替代方案</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 01:42:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/f9209b8d015ff9dceea14eb69a3d47f2.png"><img src="http://img2.diglog.com/img/2020/10/f9209b8d015ff9dceea14eb69a3d47f2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The goal of this book is to document commonly-known and lesser-known methods of doing various tasks using only built-in POSIX  sh features. Using the snippets from this bible can help remove unneeded dependencies from scripts and in most cases make them faster. I came across these tips and discovered a few while developing  KISS Linux and other smaller projects.</p><p>本书的目标是记录仅使用内置POSIX sh功能执行各种任务的常见和不太知名的方法。使用这本“圣经”中的代码片段可以帮助从脚本中移除不需要的依赖关系，并且在大多数情况下可以使脚本运行得更快。在开发KiSS Linux和其他较小的项目时，我偶然发现了这些技巧，并发现了一些技巧。</p><p>  See something incorrectly described, buggy or outright wrong? Open an issue or send a pull request. If the bible is missing something, open an issue and a solution will be found.</p><p>看到一些描述错误、错误或完全错误的东西吗？打开问题或发送拉式请求。如果圣经遗漏了什么，打开一个问题，就会找到解决方案。</p><p>                 This is an alternative to  sed,  awk,  perl and other tools. Thefunction below works by finding all leading and trailing white-space andremoving it from the start and end of the string.</p><p>这是sed、awk、perl和其他工具的替代工具。下面的函数通过查找所有前导和尾随空格并将其从字符串的开头和结尾处删除来实现。</p><p>  trim_string() {   # Usage: trim_string &#34; example string &#34;   # Remove all leading white-space.   # &#39;${1%%[![:space:]]*}&#39;: Strip everything but leading white-space.   # &#39;${1#${XXX}}&#39;: Remove the white-space from the start of the string. trim= ${1 # ${1 %%[![:space:]] *}}   # Remove all trailing white-space.   # &#39;${trim##*[![:space:]]}&#39;: Strip everything but trailing white-space.   # &#39;${trim#${XXX}}&#39;: Remove the white-space from the end of the string. trim= ${trim % ${trim ##*[![:space:]]}}  printf   &#39;%s\n &#39;   &#34; $trim &#34;}</p><p>TRIM_STRING(){#用法：TRIM_STRING&#34；示例字符串&#34；#删除所有前导空格。#&#39；${1%%[！[：space：]]*}&#39；：删除除前导空格以外的所有内容。#&#39；${1#${XXX}}&#39；：删除字符串开头的空格。Trim=${1#${1%%[！[：space：]]*}}#删除所有尾随空格。#&#39；${trim##*[！[：space：]]}&#39；：除去尾随空格以外的所有内容。#&#39；${trim#${XXX}}&#39；：从字符串末尾删除空格。Trim=${trim%${trim##*[！[：space：]]}}printf&#39；%s\n&#39；&#34；$trim&#34；}。</p><p>    This is an alternative to  sed,  awk,  perl and other tools. Thefunction below works by abusing word splitting to create a new stringwithout leading/trailing white-space and with truncated spaces.</p><p>这是sed、awk、perl和其他工具的替代工具。下面的函数通过滥用拆分单词来创建没有前导/尾随空格和截断空格的新字符串。</p><p>  # shellcheck disable=SC2086,SC2048 trim_all() {   # Usage: trim_all &#34; example string &#34;   # Disable globbing to make the word-splitting below safe.  set -f   # Set the argument list to the word-splitted string.   # This removes all leading/trailing white-space and reduces   # all instances of multiple spaces to a single (&#34; &#34; -&gt; &#34; &#34;).  set --  $*   # Print the argument list as a string.  printf   &#39;%s\n &#39;   &#34; $* &#34;   # Re-enable globbing.  set +f}</p><p>#shellcheck DISABLE=SC2086，SC2048 TRIM_ALL(){#用法：TRIM_ALL&#34；示例字符串&#34；#DISABLE GLOBING以确保下面的分词是安全的。Set-f#将参数列表设置为单词拆分的字符串。#这将删除所有前导/尾随空格，并将#多个空格的所有实例减少为一个(&#34；&#34；-&&gt；&#34；&#34；)。Set--$*#将参数列表打印为字符串。Printf&#39；%s\n&#39；&#34；$*&#34；#重新启用全局绑定。设置+f}。</p><p>  $ trim_all   &#34; Hello, World  &#34;Hello, World$ name=  &#34; John Black is my name.  &#34;$ trim_all   &#34; $name &#34;John Black is my name.</p><p>$Trim_all&#34；Hello，World&#34；Hello，World$name=&#34；John Black是我的名字。&#34；$TRIM_ALL&#34；$NAME&#34；约翰·布莱克是我的名字。</p><p>   case  $var  in  *sub_string1 *)   # Do stuff ;;  *sub_string2 *)   # Do other stuff ;;  *)   # Else ;; esac</p><p>在*SUB_STRIN1*)#执行任务；；*SUB_STRIN2*)#执行其他任务；；*)#其他；；esac中的case$var；；esac</p><p>   case  $var  in sub_string1 *)   # Do stuff ;; sub_string2 *)   # Do other stuff ;;  *)   # Else ;; esac</p><p>SUB_STRIN1*)中的case$var#执行任务；；SUB_String2*)#执行其他任务；；*)#Else；；esac。</p><p>   case  $var  in  *sub_string1)   # Do stuff ;;  *sub_string2)   # Do other stuff ;;  *)   # Else ;; esac</p><p>*SUB_STRIN1)#执行任务；；*SUB_STRIN2)#执行其他任务；；*)#ELSE；；ESAC中的case$var。</p><p>    split() {   # Disable globbing.   # This ensures that the word-splitting is safe.  set -f   # Store the current value of &#39;IFS&#39; so we   # can restore it later. old_ifs= $IFS   # Change the field separator to what we&#39;re   # splitting on. IFS= $2   # Create an argument list splitting at each   # occurance of &#39;$2&#39;.   #   # This is safe to disable as it just warns against   # word-splitting which is the behavior we expect.   # shellcheck disable=2086  set --  $1   # Print each list value on its own line.  printf   &#39;%s\n &#39;   &#34; $@ &#34;   # Restore the value of &#39;IFS&#39;. IFS= $old_ifs   # Re-enable globbing.  set +f}</p><p>Split(){#禁用全局绑定。#这样可以确保分词是安全的。Set-f#存储&#39；IFS&#39；的当前值，以便我们#可以在以后恢复它。Old_ifs=$IFS#将字段分隔符更改为我们重新#拆分的位置。IFS=$2#在每个#次出现&#39；$2&#39；时创建一个参数列表拆分。##禁用此功能是安全的，因为它只是警告#分词，这是我们预期的行为。#shellcheck Disable=2086 set--$1#在各自的行上打印每个列表值。Printf&#39；%s\n&#39；&#34；$@&#34；#还原&#39；IFS&#39；的值。Ifs=$old_ifs#重新启用全局绑定。设置+f}。</p><p>     trim_quotes() {   # Usage: trim_quotes &#34;string&#34;   # Disable globbing.   # This makes the word-splitting below safe.  set -f   # Store the current value of &#39;IFS&#39; so we   # can restore it later. old_ifs= $IFS   # Set &#39;IFS&#39; to [&#34;&#39;]. IFS= \&#34;\&#39;   # Create an argument list, splitting the   # string at [&#34;&#39;].   #   # Disable this shellcheck error as it only   # warns about word-splitting which we expect.   # shellcheck disable=2086  set --  $1   # Set &#39;IFS&#39; to blank to remove spaces left   # by the removal of [&#34;&#39;]. IFS=   # Print the quote-less string.  printf   &#39;%s\n &#39;   &#34; $* &#34;   # Restore the value of &#39;IFS&#39;. IFS= $old_ifs   # Re-enable globbing.  set +f}</p><p>TRIM_QUOTES(){#用法：TRIM_QUOTES&#34；STRING&#34；#禁用全局绑定。#这使得下面的分词是安全的。Set-f#存储&#39；IFS&#39；的当前值，以便我们#可以在以后恢复它。Old_ifs=$IFS#将IFS#设置为[&#34；&#39；]。IFS=\&#34；\&#39；#创建参数列表，在[&#34；&#39；]处拆分#字符串。##禁用此外壳检查错误，因为它只警告我们预期的分词问题。#shellcheck DISABLE=2086将--$1#Set&#39；IFS&#39；设置为空白，以删除[&#34；&#39；]留下的#空格。Ifs=#打印不带引号的字符串。Printf&#39；%s\n&#39；&#34；$*&#34；#还原&#39；IFS&#39；的值。Ifs=$old_ifs#重新启用全局绑定。设置+f}。</p><p>      # Setting &#39;IFS&#39; tells &#39;read&#39; where to split the string. while IFS=  &#39;= &#39;  read -r key val ;  do   # Skip over lines containing comments.   # (Lines starting with &#39;#&#39;). [   &#34; ${key ## \# *} &#34; ]  ||  continue   # &#39;$key&#39; stores the key.   # &#39;$val&#39; stores the value.  printf   &#39;%s: %s\n &#39;   &#34; $key &#34;   &#34; $val &#34;   # Alternatively replacing &#39;printf&#39; with the following   # populates variables called &#39;$key&#39; with the value of &#39;$val&#39;.   #   # NOTE: I would extend this with a check to ensure &#39;key&#39; is   # a valid variable name.   # export &#34;$key=$val&#34;   #   # Example with error handling:   # export &#34;$key=$val&#34; 2&gt;/dev/null ||   # printf &#39;warning %s is not a valid variable name\n&#39; &#34;$key&#34; done  &lt;   &#34;file &#34;</p><p>#Setting&#39；IFS&#39；告诉&#39；Read&#39；在哪里拆分字符串。而IFS==&#39；=&#39；读取-r键val；do#跳过包含注释的行。#(以&#39；#&#39；开头的行)。[&#34；${key##\#*}&#34；]||Continue#&#39；$key&#39；存储密钥。#&#39；$val&#39；存储值。Printf&#39；%s：%s\n&#39；&#34；$key&#34；&#34；$val&#34；#或者用以下#替换&#39；printf&#39；用&#39；$val&#39；值填充称为&#39；$key&#39；的变量。##注意：我将通过检查来扩展这一点，以确保&#39；key&#39；是一个有效的变量名。#export&#34；$key=$val&#34；##错误处理示例：#export&#34；$key=$val&#34；2&gt；/dev/null||#printf&#39；警告%s不是有效的变量名\n&#39；&#34；$key&#34；完成&lt；&#34；文件&#34；</p><p>    head() {   # Usage: head &#34;n&#34; &#34;file&#34;  while IFS=  read -r line ;  do  printf   &#39;%s\n &#39;   &#34; $line &#34; i=  $((i + 1 )) [   &#34; $i &#34;  =   &#34; $1 &#34; ]  &amp;&amp;  return  done  &lt;   &#34; $2 &#34;   # &#39;read&#39; used in a loop will skip over   # the last line of a file if it does not contain   # a newline and instead contains EOF.   #   # The final line iteration is skipped as &#39;read&#39;   # exits with &#39;1&#39; when it hits EOF. &#39;read&#39; however,   # still populates the variable.   #   # This ensures that the final line is always printed   # if applicable. [  -n   &#34; $line &#34; ]  &amp;&amp;  printf %s   &#34; $line &#34;}</p><p>Head(){#用法：head&#34；n&#34；&#34；file&#34；while IFS=read-r line；do printf&#39；%s\n&#39；&#34；$line&#34；i=$((i+1))[&#34；$i&#34；=&#34；$1&#34；]&amp；&amp；Return&lt；&#34；$2&#34；循环中使用的#&#39；read&#39；如果不包含#a换行符，而是包含EOF，则会跳过文件的最后一行。##最后一行迭代将被跳过，因为当&#39；Read&#39；#命中EOF时，它将以&#39；1&#39；退出。&#39；READ&#39；但是，#仍然填充变量。##这可确保始终打印最后一行#(如果适用)。[-n&#34；$line&#34；]&amp；&amp；printf%s&#34；$line&#34；}。</p><p>      lines() {   # Usage: lines &#34;file&#34;   # &#39;|| [ -n &#34;$line&#34; ]&#39;: This ensures that lines   # ending with EOL instead of a newline are still   # operated on in the loop.   #   # &#39;read&#39; exits with &#39;1&#39; when it sees EOL and   # without the added test, the line isn&#39;t sent   # to the loop.  while IFS=  read -r line  || [  -n   &#34; $line &#34; ] ;  do lines=  $((lines + 1 ))  done  &lt;   &#34; $1 &#34;  printf   &#39;%s\n &#39;   &#34; $lines &#34;}</p><p>LINES(){#用法：LINES&#34；FILE&#34；#&#39；||[-n&#34；$LINE&#34；]&#39；：这样可以确保循环中仍对以EOL结尾的行#而不是换行行进行#操作。当##&#39；READ&#39；看到EOL和#时，它会退出&#1&#39；，没有添加测试，则该行不会将#发送到循环。而IFS=读取-r行||[-n&#34；$line&#34；]；DO LINES=$((LINES+1))Done&lt；&#34；$1&#34；printf&#39；%s\n&#39；&#34；$LINES&#34；}。</p><p>    This works by passing the output of the glob to the function and then counting the number of arguments.</p><p>这是通过将glob的输出传递给函数，然后计算参数的数量来实现的。</p><p>  count() {   # Usage: count /path/to/dir/*   # count /path/to/dir/*/ [  -e   &#34; $1 &#34; ] \  &amp;&amp;  printf   &#39;%s\n &#39;   &#34; $# &#34; \  ||  printf   &#39;%s\n &#39; 0}</p><p>Count(){#用法：count/path/to/dir/*#count/path/to/dir/*/[-e&#34；$1&#34；]\&amp；&amp；&amp；printf&#39；%s\n&#39；&#34；$#&#34；\||printf&#39；%s\n&#39；0}。</p><p>  # Count all files in dir.$ count  ~/Downloads/ *232  # Count all dirs in dir.$ count  ~/Downloads/ */45  # Count all jpg files in dir.$ count  ~/Pictures/ *.jpg64</p><p>#计数目录$count~/downloads/*232#计数目录$count~/downloads/*/45#统计目录$count~/Pictures/*.jpg64中的所有jpg文件。</p><p>        dirname() {   # Usage: dirname &#34;path&#34;   # If &#39;$1&#39; is empty set &#39;dir&#39; to &#39;.&#39;, else &#39;$1&#39;. dir= ${1 :-.}   # Strip all trailing forward-slashes &#39;/&#39; from   # the end of the string.   #   # &#34;${dir##*[!/]}&#34;: Remove all non-forward-slashes   # from the start of the string, leaving us with only   # the trailing slashes.   # &#34;${dir%%&#34;${}&#34;}&#34;: Remove the result of the above   # substitution (a string of forward slashes) from the   # end of the original string. dir= ${dir %%  &#34; ${dir ##*[!/]} &#34;}   # If the variable *does not* contain any forward slashes   # set its value to &#39;.&#39;. [   &#34; ${dir ##*/*} &#34; ]  &amp;&amp; dir=.   # Remove everything *after* the last forward-slash &#39;/&#39;. dir= ${dir %/*}   # Again, strip all trailing forward-slashes &#39;/&#39; from   # the end of the string (see above). dir= ${dir %%  &#34; ${dir ##*[!/]} &#34;}   # Print the resulting string and if it is empty,   # print &#39;/&#39;.  printf   &#39;%s\n &#39;   &#34; ${dir :-/} &#34;}</p><p>Dirname(){#用法：dirname&#34；path&#34；#if&#39；$1&#39；is null set&#39；dir&#39；to&#39；.&#39；，Else&#39；$1&#39；。Dir=${1：-.}#从#字符串末尾去掉所有尾随正斜杠&#39；/&#39；。##&#34；${dir##*[！/]}&#34；：从字符串开头删除所有非正斜杠#，只留下#尾部斜杠。#&#34；${dir%%&#34；${}&#34；}&#34；：从原始字符串的#末尾删除上述#替换的结果(一串正斜杠)。Dir=${dir%%&#34；${dir##*[！/]}&#34；}#如果变量*不*包含任何正斜杠#将其值设置为&#39；.&#39；。[&#34；${dir#**/*}&#34；]&amp；&amp；dir=。#删除*最后一个正斜杠&#39；/&#39；之后的所有*内容。Dir=${dir%/*}#再次删除字符串末尾#中的所有尾随正斜杠&#39；/&#39；(见上文)。Dir=${dir%%&#34；${dir##*[！/]}&#34；}#打印结果字符串，如果为空，则#print&#39；/&#39；。Printf&#39；%s\n&#39；&#34；${dir：-/}&#34；}。</p><p>      basename() {   # Usage: basename &#34;path&#34; [&#34;suffix&#34;]   # Strip all trailing forward-slashes &#39;/&#39; from   # the end of the string.   #   # &#34;${1##*[!/]}&#34;: Remove all non-forward-slashes   # from the start of the string, leaving us with only   # the trailing slashes.   # &#34;${1%%&#34;${}&#34;}: Remove the result of the above   # substitution (a string of forward slashes) from the   # end of the original string. dir= ${1 % ${1 ##*[!/]}}   # Remove everything before the final forward-slash &#39;/&#39;. dir= ${dir ##*/}   # If a suffix was passed to the function, remove it from   # the end of the resulting string. dir= ${dir %  &#34; $2 &#34;}   # Print the resulting string and if it is empty,   # print &#39;/&#39;.  printf   &#39;%s\n &#39;   &#34; ${dir :-/} &#34;}</p><p>Basename(){#用法：basename&#34；path&#34；[&#34；Suffix&#34；]#从#字符串末尾删除所有尾随正斜杠&#39；/&#39；。##&#34；${1##*[！/]}&#34；：从字符串开头删除所有非正斜杠#，只留下#尾部斜杠。#&#34；${1%%&#34；${}&#34；}：从原始字符串的#末尾删除上述#替换的结果(一串正斜杠)。Dir=${1%${1##*[！/]}}#删除最后一个正斜杠&#39；/&#39；之前的所有内容。Dir=${dir##*/}#如果向函数传递了后缀，请将其从结果字符串末尾的#中删除。Dir=${dir%&#34；$2&#34；}#打印结果字符串，如果为空，则#print&#39；/&#39；。Printf&#39；%s\n&#39；&#34；${dir：-/}&#34；}。</p><p>     Alternative to  seq and only suitable for small and static number ranges. The number list can also be replaced with a list of words, variables etc.</p><p>可替代SEQ，仅适用于较小的静态数字范围。数字列表还可以替换为单词、变量等的列表。</p><p> # Loop from 0-10. for  i  in 0 1 2 3 4 5 6 7 8 9 10 ;  do  printf   &#39;%s\n &#39;   &#34; $i &#34; done</p><p>#从0到10循环。对于0 1 2 3 4 5 6 7 8 9 10；中的I，执行打印操作&#39；%s\n&#39；&#34；$I&#34；完成。</p><p>     while IFS=  read -r line  || [  -n   &#34; $line &#34; ] ;  do  printf   &#39;%s\n &#39;   &#34; $line &#34; done  &lt;   &#34;file &#34;</p><p>而IFS=读取-r行||[-n&#34；$line&#34；]；执行打印f&#39；%s\n&#39；&#34；$line&#34；完成&lt；&#34；文件&#34；</p><p>   CAVEAT: When the glob does not match anything (empty directory or no matching files) the variable will contain the unexpanded glob. To avoid working on unexpanded globs check the existence of the file contained in the variable using the appropriate  file conditional. Be aware that symbolic links are resolved.</p><p>警告：当glob不匹配任何内容(空目录或没有匹配的文件)时，该变量将包含未展开的glob。要避免使用未展开的GLOB，请使用适当的文件条件检查变量中包含的文件是否存在。请注意，符号链接已解析。</p><p> # Greedy example. for  file  in  * ;  do [  -e   &#34; $file &#34; ]  || [  -L   &#34; $file &#34; ]  ||  continue  printf   &#39;%s\n &#39;   &#34; $file &#34; done  # PNG files in dir. for  file  in  ~/Pictures/ *.png ;  do [  -f   &#34; $file &#34; ]  ||  continue  printf   &#39;%s\n &#39;   &#34; $file &#34; done  # Iterate over directories. for  dir  in  ~/Downloads/ */ ;  do [  -d   &#34; $dir &#34; ]  ||  continue  printf   &#39;%s\n &#39;   &#34; $dir &#34; done</p><p>#贪婪的例子。对于*；DO[-e&#34；$FILE&#34；]||[-L&#34；$FILE&#34；]||继续打印目录中的#个PNG文件。对于~/Pictures/*.png；中的文件，执行[-f&#34；$FILE&#34；]||继续打印f&#39；%s\n&#39；&#34；$FILE&#34；Done#迭代目录。对于~/Downloads/*/中的目录，执行[-d&#34；$dir&#34；]||继续打印&#39；%s\n&#39；&#34；$dir&#34；完成。</p><p>     Contrary to popular belief, there is no issue in utilizing raw escape sequences. Using  tput abstracts the same ANSI sequences as if printed manually. Worse still,  tput is not actually portable. There are a number of  tput variants each with different commands and syntaxes ( try  tput setaf 3 on a FreeBSD system). Raw sequences are fine.</p><p>与人们普遍认为的相反，利用原始转义序列是没有问题的。使用tput提取相同的ANSI序列，就像手动打印一样。更糟糕的是，tput实际上不是可移植的。有许多tput变体，每个都有不同的命令和语法(在FreeBSD系统上尝试tput setaf 3)。原始序列没问题。</p><p>                                      # Set the value of var to var2 if var2 is greater than var.  # &#39;var2 &gt; var&#39;: Condition to test.  # &#39;? var2&#39;: If the test succeeds.  # &#39;: var&#39;: If the test fails.var=  $((var 2  &gt; var  ? var 2  : var ))</p><p>#如果var2大于var，则将var的值设置为var2。#&#39；var2&gt；var&#39；：要测试的条件。#&#39；？Var2&#39；：如果测试成功。#&#39；：var&#39；：如果测试失败。var=$((var 2&&gt;var？Var 2：var))。</p><p>   is_float() {   # Usage: is_float &#34;number&#34;   # The test checks to see that the input contains   # a &#39;.&#39;. This filters out whole numbers. [  -z   &#34; ${1 ##*. *} &#34; ]  &amp;&amp;  printf %f   &#34; $1 &#34;  &gt;/dev/null  2&gt;&amp;1}</p><p>IS_FLOAT(){#用法：IS_FLOAT&#34；number&#34；#测试检查输入是否包含#a&#39；.&#39；。这会过滤出整数。[-z&#34；${1##*.。*}&#34；]&amp；&amp；printf%f&#34；$1&#34；&gt；/dev/null 2&gt；&amp；1}。</p><p>         Traps allow a script to execute code on various signals. In  pxltrm ( a pixel art editor written in bash) traps are used to redraw the user interface on window resize. Another use case is cleaning up temporary files on script exit.</p><p>陷阱允许脚本对各种信号执行代码。在pxltrm(用bash编写的像素艺术编辑器)中，陷阱用于在调整窗口大小时重新绘制用户界面。另一个用例是在脚本退出时清理临时文件。</p><p> Traps should be added near the start of scripts so any early errors are also caught.</p><p>应在脚本开头附近添加陷阱，以便也能捕获任何早期错误。</p><p>  # Clear screen on script exit. trap   &#39;printf \\033[2J\\033[H\\033[m &#39; EXIT  # Run a function on script exit.  # &#39;clean_up&#39; is the name of a function. trap clean_up EXIT</p><p>#在脚本退出时清除屏幕。陷阱&#39；printf\\033[2J\\033[H\\033[m&#；exit#]在脚本退出时运行函数。#&#39；CLEAN_UP&#39；是函数的名称。陷阱清理出口。</p><p>                  Thanks for reading! If this bible helped you in any way and you&#39;d like to give back, consider donating. Donations give me the time to make this the best resource possible. Can&#39;t donate? That&#39;s OK, star the repo and share it with your friends!</p><p>谢谢你的阅读！如果这本“圣经”以任何方式帮助了你，而你又想回馈社会，那就考虑捐献吧。捐款给了我时间让它成为最好的资源。不能捐献吗？这是好的，启动回购，并与您的朋友分享！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/dylanaraps/pure-sh-bible">https://github.com/dylanaraps/pure-sh-bible</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/替代/">#替代</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sh/">#sh</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>