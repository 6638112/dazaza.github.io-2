<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java enumset的成本 - 对生态系统的批评 The cost of Java's EnumSet – A criticism of the ecosystem</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The cost of Java's EnumSet – A criticism of the ecosystem<br/>Java enumset的成本 - 对生态系统的批评 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 07:44:44</div><div class="page_narrow text-break page_content"><p>It’s been about a decade since I last worked in Java and much has changed.I thought I’d brush up by re-reading  Effective Java by Joshua Blochwhich has since received a new edition. It was once my guiding star forJava. However, after an additional decade of experience in a variety oflanguages and platforms, this book frequently made me shake my head. Istrongly disagreed with 20% of  its items. One conflictingtopic was enumerations, particularly item 36: “Use EnumSet instead of bitfields.”</p><p>自从我上次在Java工作以来，已经大约十年了，很多已经改变了。我以为Joshua Blochwhoich以来，我认为我已经收到了一个新版本。曾经是我的指导星星队。然而，在各种语言和平台的额外经验之后，这本书经常让我摇头。不同意其20％的物品。一个冲突oppic是枚举，特别是第36项：“使用enumset而不是位字段。”</p><p> This is not to say Bloch is necessarily wrong to make this recommendation,or any of the others I don’t like. The book is conservative, playing itsafe by always erring on the side of Java idiom whether or not it makessense. The problem lies in Java idiom more than the book. To write yourJava like everyone else, do exactly as the book says. When in Rome, do asthe Romans do.</p><p> 这并不是说Bloch必然是错误的，或者我不喜欢的任何其他建议。这本书是保守的，在java成语的一侧跳动而不是java成语，无论是mainessense的何种误乱，都在玩itsafe。问题在于Java Idiom而不是这本书。写下你的大家都像其他人一样，正如书所说的那样。在罗马做到入乡随俗。</p><p> On the other hand, EnumSet is perhaps the most pointless class in the Javastandard library. It has two goals, but fails at both.</p><p> 另一方面，enumset可能是javastandard库中最无意义的类。它有两个目标，但两者都失败了。</p><p>  Back in the old days Java programmers would build enumerations much like Cprogrammers. For example, here’s a C-style bitfield enumeration (theseRomans  love their keywords):</p><p>  返回旧时代Java程序员将像Cprogramer一样建立枚举。例如，这是一个C样式位阵容（TheSeromans爱他们的关键字）：</p><p> public  final  class  Color  {  public  static  final  int  R  =  1  &lt;&lt;  0 ;  public  static  final  int  G  =  1  &lt;&lt;  1 ;  public  static  final  int  B  =  1  &lt;&lt;  2 ; }</p><p> 公共最终类颜色{公共静态Final int r = 1＆lt;＆lt; 0;公共静态Final int g = 1＆lt;＆lt; 1;公共静态Final int B = 1＆lt;＆lt;＆lt; 2; }</p><p> To build a  set of these items, use the OR ( |) operator, just like C:</p><p> 要构建一组这些项目，请使用或（|）运算符，就像C：</p><p>  The downside is lack of type safety. These are plain old integers, not adedicated type, and getting your integers and bitfields crossed won’t bechecked by the compiler. To solve this, early Java gained an enumerationreference type:</p><p>  缺点是缺乏类型的安全性。这些是普通的旧整数，而不是暗示的类型，并且越过越过的整数和位字段不会被编译器接受。要解决此问题，早期的Java获得了枚举型式： </p><p>  Thankfully this is only slightly more verbose than the same syntax for a Cenumeration. While it would have been useful, these types don’t supportthe OR operator. Instead you’re supposed to build a Set. Romans also loveceremony:</p><p>值得庆幸的是，这只是比狭衰减的同样的语法稍微冗长。虽然它是有用的，但这些类型不支持或运营商。相反，你应该建立一套。罗马人也喜欢：</p><p>  As you might guess, compared to the original integer operation, thisHashSet is incredibly slow and inefficient. The type safety comes at aserious cost. Attempting to mitigate this, Java provides a special Setimplementation for enumerations:</p><p>  与您可能猜到的一样，与原始整数操作相比，ThisHashSet非常慢，效率效率令人难以置信。类型的安全性具有成本的成本。 Java尝试缓解此项，为枚举提供特殊的SetImplationation：</p><p>  Not as syntactically lean as the OR operator, but less ceremony and moreefficient than a HashSet. The efficiency comes from using a bitfieldinternally just like the original pre-enumeration example.  But how muchmore efficient is it?</p><p>  没有像或操作员那样句法倾斜，而是比哈希集更少的仪式和莫雷夫特。效率来自使用BitFieldInternally，就像原始预枚举示例一样。但是有多么高效？</p><p>  The original C-style bitfield was a primitive  int: fast, efficient, noallocations, and easy to optimize. Except for the lack of type safety it’sessentially the best possible case. Since an EnumSet uses a bitfieldinternally, isn’t it basically the same? Unfortunately not.</p><p>  原始的C型位菲尔德是一个原始的INT：快速，高效，清除，易于优化。除了缺乏类型的安全性之外，它是最好的案例。由于enumset使用BitFieldInternally，因此它不是基本相同的吗？不幸的是没有。</p><p>   It’s the essence of   individual element thinking. There’s littlereason to think an EnumSet is going to be efficient.</p><p>   这是个人元素思考的本质。有Littlereason认为忠诚将是高效的。</p><p> Wanting to get a feel for the relative costs, I put together some crudebenchmarks. In the benchmark I construct a set of values, then constructthe same set many more times and compare it to the original set. Here’sthe EnumSet benchmark:</p><p> 想要了解相对成本的感觉，我汇集了一些粗壮的标志。在基准时，我构建一组值，然后构造相同的集合了多次并将其与原始集进行比较。这是enumset基准：</p><p> enum  Flag  {  A ,  B ,  C ,  D ,  E ,  F ,  G  } // ... static  void  benchmarkEnumSet ()  {  System . gc ();  long  beg  =  System . nanoTime ();  Set &lt; Flag &gt;  a  =  EnumSet . of ( Flag . A ,  Flag . B ,  Flag . G );  for  ( int  i  =  0 ;  i  &lt;  1_000_000_000 ;  i ++)  {  Set &lt; Flag &gt;  b  =  EnumSet . of ( Flag . A ,  Flag . B ,  Flag . G );  assert  a . equals ( b );  }  long  end  =  System . nanoTime ();  System . out . println ( &#34;EnumSet\t&#34;  +  ( end  -  beg )/ 1 e9 ); }</p><p> 枚举标志{a，b，c，d，e，f，g} // ...静态void benchcharkenumset（）{system。 GC （）;长乞求=系统。 nanotime（）;设置＆lt;旗帜＆gt; a = enumset。 （旗帜。一个，国旗。B，旗帜。G）; for（int i = 0; i＆lt; 1_000_000_000; i ++）{set＆lt;旗帜＆gt; b = enumset。 （旗帜。一个，国旗。B，旗帜。G）;断言一个。等于（b）;长尾=系统。 nanotime（）;系统 。出去 。 println（＆＃34; enumset \ t＆＃34; +（最终 - 乞讨）/ 1 e9）; } </p><p>  static  final  int  A  =  1  &lt;&lt;  0 ; static  final  int  B  =  1  &lt;&lt;  1 ; static  final  int  C  =  1  &lt;&lt;  2 ; static  final  int  D  =  1  &lt;&lt;  3 ; static  final  int  E  =  1  &lt;&lt;  4 ; static  final  int  F  =  1  &lt;&lt;  5 ; static  final  int  G  =  1  &lt;&lt;  6 ; // ... static  void  benchmarkBitfield ()  {  System . gc ();  long  beg  =  System . nanoTime ();  int  a  =  A  |  B  |  G ;  for  ( int  i  =  0 ;  i  &lt;  1_000_000_000 ;  i ++)  {  int  b  =  A  |  B  |  G ;  assert  a  ==  b ;  }  long  end  =  System . nanoTime ();  System . out . println ( &#34;bitfield\t&#34;  +  ( end  -  beg )/ 1 e9 ); }</p><p>静态int a = 1＆lt;＆lt; 0;静态最终int b = 1＆lt;＆lt; 1;静态最终int c = 1 <＆lt;＆lt; 2;静态最终int d = 1＆lt;＆lt; 3;静态int e = 1＆lt;＆lt; 4;静态最终int f = 1＆lt;＆lt;＆lt; 5;静态Final int g = 1 <＆lt;＆lt;＆lt; 6; // ...静态void benchmarkbitfield（）{system。 GC （）;长乞求=系统。 nanotime（）; int a = a | B | G ; for（int i = 0; i＆lt; 1_000_000_000; i ++）{int b = a | B | G ;断言A == B;长尾=系统。 nanotime（）;系统 。出去 。 println（＆＃34;位菲尔德\ t＆＃34; +（最终 - 乞讨）/ 1 e9）; }</p><p> There’s also a HashSet benchmark, but it’s just a slight variation of theEnumSet benchmark so I won’t show it here. Due to JIT warm-up costs, thebenchmark runs three times in a row in the same process ( for loop). The -ea option enables the assertions in the test:</p><p> 还有一个散列基准，但它只是Theenumset基准的略有变化，所以我不会在这里展示。由于JIT预热成本，在相同的过程中，Benchmark在相同的过程中连续运行三次（for循环）。 -ea选项使测试中的断言是：</p><p>   The results on x86-64 Debian Buster with its OpenJDK 11 (the most recentlong-term support release of OpenJDK):</p><p>   X86-64 Debian Buster的结果及其OpenJDK 11（OpenJDK最新的支持版本）：</p><p>  An EnumSet is two orders of magnitude faster than a HashSet. This soundspretty good until the next result: At their worst, bitfields are  threeorders of magnitude faster than an EnumSet.</p><p>  enumset是比哈希集快的两个数量级。这个Soundspretty直到下一个结果：在他们最糟糕的情况下，比特菲尔德比enumset更快的速度率快。</p><p> What’s even more interesting is that third run. It looks like a benchmarkfailure, and in another context I might agree. Obviously the JIT compilerwised up and optimized away the entire benchmark. Normally this is auseless result, but it’s telling in contrast with the other twobenchmarks. The compiler failed to realize this same optimization withboth the HashSet and EnumSet benchmarks.  Once warmed up, bitfields are more than 1000x faster because they won’t inhibit optimizations.</p><p> 第三次运行更有趣的是更有趣的。它看起来像个基准文件，在另一个背景下，我可能会同意。显然，JIT编译并优化了整个基准。通常这是不可避免的结果，但它与其他TwoBenchmark相比之下。编译器未能实现相同的优化，其中哈希集和enumset基准测试。一旦加热，位菲尔德将超过1000倍，因为它们不会抑制优化。</p><p>  So what’s the point of an EnumSet? I mentioned that it doesn’t accomplisheither of its two goals.</p><p>  那么enumset的点是什么？我提到它并没有实现其两个目标。</p><p> The usual Set implementation, HashSet, is far less efficient than abitfield. An EnumSet attempts to bring this back in line with abitfield.</p><p> 通常的设置实现，散列效率远远低于Abitfield。 enumset试图将其与abitfield一起键入。 </p><p> An EnumSet is unnecessary for type safety since that’s already a propertyof Set. We already have a more general Set implementation: HashSet.Relative to a bitfield, an EnumSet isn’t meaningfully faster than aHashSet. A hare isn’t meaningfully faster than a turtle in the context ofrockets.</p><p>由于已经是一组Propertyof，因此不需要枚举。我们已经有一个更常规的设置实现：hashset.Relive对位域，enumset比ahashset更快地有意义。一个野兔没有比乌龟在上下文中的乌龟更快。</p><p> The usual argument against bitfields is that “speed isn’t important” orthat it’s “premature optimization.” If that’s true, then what was wrongwith a HashSet? If speed  is important, then you use a bitfield. Where’sthe need for an EnumSet? It’s extra API surface area for a non-existentuse case.</p><p> 对位菲尔德的常见争论是“速度并不重要”，否则它是“过早优化”。如果这是真的，那么哈希集是什么？如果速度很重要，那么你使用位域。在哪里需要枚举？它是非态度的额外API表面积。</p><p> It’s also at odds with “Item 6: Avoid creating unnecessary objects.”Unlike a Set, a bitfield is a primitive and doesn’t create an object. Perthe benchmark, the type safety of a Set comes at a high cost. The Cprogrammer within me cringes at that cost even where it truly doesn’tmatter.</p><p> 它也与“第6项：避免创建不必要的对象。”与集合不同，位域是一个原始的，没有创建对象。截至基准，一套的类型安全性高成本。我内心的CPRIGHMAGMER甚至在那里的成本中畏缩，即使它真正没有经过。</p><p> This isn’t to say you should change the way you write Java. This is acriticism of the ecosystem — its design and idioms — and one of the (many)reasons why I haven’t missed it.</p><p> 这并不是说你应该改变你写Java的方式。这是生态系统的班班主义 - 它的设计和习语 - 以及我没有错过的（多种）原因之一。</p><p>      Have a comment on this article? Start a discussion in my  public inbox by sending an email to   ~skeeto/public-inbox@lists.sr.ht    [ mailing list etiquette] , or see  existing discussions.</p><p>      对这篇文章有评论吗？通过向~skeeto/public-inbox@lists.sr.ht [邮件列表礼仪]发送电子邮件，或查看现有讨论，在我的公共收件箱中开始讨论。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nullprogram.com/blog/2021/04/23/">https://nullprogram.com/blog/2021/04/23/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/enumset/">#enumset</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>