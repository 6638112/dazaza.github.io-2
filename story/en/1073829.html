<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不要使用文本像素来编辑敏感信息Don't use text pixelation to redact sensitive information</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Don't use text pixelation to redact sensitive information<br/>不要使用文本像素来编辑敏感信息</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 13:19:43</div><div class="page_narrow text-break page_content"><p>We write a lot of reports at Bishop Fox (it’s what happens when you hack all the things). This frequently results in needing to redact certain text. We have a long-standing policy that when you redact text, the  onlyway to do it securely is to use black bars. Sometimes, people like to be clever and try some other redaction techniques like blurring, swirling, or pixelation. But this is a mistake.</p><p>我们在Bishop Fox写了很多报道（这是当你破解所有东西时发生的事情）。这经常导致需要对某些文本进行编辑。我们有一个长期的政策，当你编辑文本时，唯一安全的方法就是使用黑条。有时，人们喜欢变得聪明，尝试其他一些编辑技术，比如模糊、旋转或像素化。但这是一个错误。</p><p> Today, we’re focusing on one such technique – pixelation – and will show you why it’s a no-good, bad, insecure, surefire way to get your sensitive data leaked. To show you why, I wrote a tool called  Unredacter that takes redacted pixelized text and reverses it back into its unredacted form. There’s plenty of real-world examples of this in the wild to redact sensitive information, but I won’t name names here. Watch my video for a quick recap of the importance of NEVER using pixelation to redact text, as well as how I unredact Jumpseclabs&#39;s Challenge in real-time.</p><p>今天，我们将重点介绍一种这样的技术——像素化，并将向您展示为什么这是一种不好、不好、不安全、肯定会泄露敏感数据的方法。为了说明原因，我编写了一个名为Unredacter的工具，它将经过编辑的像素化文本还原为未经编辑的形式。在现实世界中，有很多这样的例子可以用来编辑敏感信息，但我不想在这里指名道姓。观看我的视频，快速回顾从不使用像素编辑文本的重要性，以及我如何取消Jumpseclabs&#39；这是一个实时的挑战。</p><p>  So there’s an  existing tool called Depix that tries to do exactly this through a really clever process of looking up what permutations of pixels could have resulted in certain pixelated blocks, given a  De Bruijn sequenceof the correct font. I like the theory of this tool a lot, but a  researcher at Jumpsec pointed out that perhaps it doesn’t work as well in practice as you’d like. In real-world examples you’re likely to get minor variations and noise that throws a wrench into the gears. They then issued a challenge to anyone, offering a prize if you could un-redact the following image:</p><p>因此，有一个名为Depix的现有工具，它试图通过一个非常聪明的过程来实现这一点，即在给定正确字体的De Bruijn序列的情况下，查找像素排列可能会导致某些像素化块。我非常喜欢这个工具的理论，但Jumpsec的一位研究人员指出，也许它在实践中没有你想要的那么好。在现实世界中的例子中，你很可能会得到一些微小的变化和噪音，这会让你的齿轮扭动。然后，他们向任何人发出了挑战，如果你能取消对以下图片的编辑，他们将提供奖励：</p><p> The algorithm is pretty simple; you divide up your image into a grid of a given block size (the example above is 8x8). Then for each block, you set the redacted image’s color equal to the average color of the original for that same area. That’s it – just a rolling pixel average for each block.</p><p>算法非常简单；将图像分割为给定块大小的网格（上面的示例是8x8）。然后，对于每个块，将经过编辑的图像的颜色设置为相同区域原始图像的平均颜色。就是这样——每个块的滚动像素平均值。</p><p>  The effect sort of “smears” the information of the image out across each block. But while some information is lost in the process, it absolutely leaks plenty through. And it’s this leaked information that we’ll be using to our advantage.</p><p>这种效果有点“涂抹”了每个块的图像信息。但是，尽管在这个过程中有些信息丢失了，但它绝对会大量泄露出去。我们将利用这些泄露的信息为自己谋利。</p><p> Notably, this algorithm is widely standardized since it’s so simple. So, no matter whether you do this redacting in GiMP, Photoshop, or basically any other tool, the redaction will turn out the same.</p><p>值得注意的是，由于该算法非常简单，因此被广泛标准化。所以，不管你是在GiMP、Photoshop还是其他工具中进行编辑，编辑结果都是一样的。</p><p>   These are fairly reasonable assumptions, I would assert, since the attacker in a realistic scenario would likely have received a full report, with just one piece redacted out. In our challenge text, you can see a few words right above the pixelated text that give us this information.</p><p>我认为，这些都是相当合理的假设，因为在现实场景中，攻击者可能会收到一份完整的报告，其中只有一份经过编辑。在我们的挑战文本中，你可以在像素文本的正上方看到一些单词，它们为我们提供了这些信息。</p><p> The key thing we’re focusing on is that the redaction process is inherently local. In cryptographic terms, we’d say it has  no diffusion. A change of one pixel somewhere in the original image ONLY impacts the redacted block it belongs to, meaning that we can (mostly) guess the image character by character. We’ll do a recursive depth-first search on each character, scoring each guess by how well it marginally matches up to the redacted text.</p><p>我们关注的关键是编校过程本质上是局部的。在密码学方面，我们可以说它没有扩散。在原始图像的某个地方改变一个像素只会影响它所属的编辑块，这意味着我们可以（大部分）逐个字符地猜测图像。我们将对每个字符进行递归深度优先搜索，根据其与编辑文本的匹配程度对每个猜测进行评分。</p><p> Basically, we guess the letter “a”, pixelate that letter, and see how well it matches up to our redacted image. Then we guess the letter “b”, and so on. Doesn’t sound so hard, right? Well, there’s still a  bunch of logistical issues to overcome that might not be so obvious at first! Let’s dig into those further.</p><p>基本上，我们猜测字母“a”，对该字母进行像素化，然后查看它与我们编辑的图像的匹配程度。然后我们猜字母“b”，以此类推。听起来没那么难吧？嗯，还有一大堆后勤问题需要克服，这在一开始可能并不那么明显！让我们进一步深入研究这些问题。</p><p>  The first problem we immediately encountered is that the characters of our text don’t line up 1:1 with the blocks of the redaction. This means that a given correct guess might actually have some wrong blocks on the right-most edge. To see what I mean, check out this example:</p><p>我们立即遇到的第一个问题是，文本中的字符与编辑块的比例不是1:1。这意味着一个给定的正确猜测可能在最右边有一些错误的块。要了解我的意思，请查看以下示例：</p><p>  You can see that the letters “t” and “h” share a column of blocks. So, if we try to make a guess for the letter “t”, the left-most column of blocks turns out correct, but the right-most ones are a bit wrong.</p><p>可以看到字母“t”和“h”共享一列块。所以，如果我们试着猜测字母“t”，最左边的一列结果是正确的，但最右边的一列有点错误。</p><p>   The reason the second column is wrong is because the letter “h” is there messing things up. If we just looked at this alone, you might conclude that the letter “t” was an incorrect first letter, since it gets almost half of the blocks totally wrong.</p><p>第二栏是错误的，因为字母“h”把事情搞砸了。如果我们只看这一点，你可能会得出结论，字母“t”是一个不正确的第一个字母，因为它得到了几乎一半的区块完全错误。</p><p> The first thing we tried was to avoid counting the right-most block of any guess. It’s the column that will have the most bleed-over and can have quite a bit of error. The problem with this was that, in practice, it reduced the total size of our guess by so much that you start receiving false positives. There’s always a chance that your letter will accidentally line up and produce a match by pure chance, and this chance goes way up when there’s fewer blocks to consider.</p><p>我们尝试的第一件事是避免计算任何猜测中最右边的区块。这是最容易出错的专栏。问题是，在实践中，它减少了我们猜测的总大小，以至于你开始收到误报。总是有机会，你的信会意外排队，并产生一个纯粹的机会比赛，这个机会走上去，当有更少的块考虑。</p><p> So instead, what we did was to chop off the comparison block at the boundary of the letter itself. Thus, our diff would look like this:</p><p>因此，我们所做的是在字母本身的边界处切掉比较块。因此，我们的差异如下所示：</p><p>  You can see the quality of our match went way up, since we’re including less of that incorrect area on the right. This is because we chop the comparison off at the edge of where the “t” ends:</p><p>你可以看到我们比赛的质量有了很大的提高，因为我们在右边的错误区域减少了。这是因为我们在“t”结束的边缘处切掉比较：</p><p>  The benefit to doing it this way is that the more our guess character extends into the block, the more likely the block is to be a good guess, and so we keep more of the block. So, it will automatically chop off most of the block when the guess is bad and keep most of the block when it’s good.</p><p>这样做的好处是，我们的猜测字符越多地延伸到块中，块就越有可能是一个好的猜测，因此我们保留了更多的块。因此，当猜测错误时，它会自动切掉大部分块，当猜测正确时，它会保留大部分块。</p><p> A specific subset of the character bleed-over problem is that whitespace tends to break a few of our assumptions on how character guessing works. Inherent to this whole problem is the assumption that when we guess a correct character, we expect the resulting pixelated version of it to mostly resemble the challenge image.</p><p>角色溢出问题的一个具体子集是，空白往往会打破我们对角色猜测工作原理的一些假设。这个问题的本质是这样一种假设：当我们猜到一个正确的角色时，我们期望得到的像素化版本的角色与挑战图像基本相似。</p><p> However, this isn’t always true when the character we guess is whitespace. When that happens, the pixelated blocks will be completely overtaken by the next character. Take this example, making the guess “this is ” (with a trailing space):</p><p>然而，当我们猜测的字符是空白时，这并不总是正确的。当这种情况发生时，像素块将被下一个角色完全取代。举个例子，猜测“this is”（后面有空格）：</p><p>  This is then pixelated like below, with a trailing blank column as you’d expect:</p><p>然后将其像素化，如下图所示，后面有一个空白列：</p><p>  The problem is that in the solution image, there is another character after the space. It bleeds over so badly that our correct guess looks to be completely wrong!</p><p>问题是，在解决方案图像中，空格后面还有另一个字符。它流了这么多血，以至于我们正确的猜测看起来是完全错误的！</p><p>  There’s more than one way to tackle this problem. The most obvious is to never make whitespace guesses on its own, and instead pair it up with some other non-whitespace character. That way we can control the character that bleeds over. While this “works”, it effectively doubles the available character set. This slows the whole process down to a crawl.</p><p>解决这个问题的方法不止一种。最明显的是永远不要自己猜测空格，而是将其与其他非空格字符配对。这样我们就可以控制流血的角色。虽然这种方法“有效”，但它有效地将可用字符集增加了一倍。这会让整个过程变得缓慢。</p><p> Instead, what we can do is make a special carveout for whitespace guesses that give them more leniency in what is considered a “good” guess. In testing, it seemed that the bleed-over is never so bad that it’s beyond a lower threshold. It’s a bit kludge-y, I’ll grant you, but it seems to work.</p><p>相反，我们可以做的是为空白猜测做一个特殊的划分，让他们在被认为是“好”猜测的情况下更加宽容。在测试中，似乎溢出从未如此严重，以至于超过了一个较低的阈值。我承认这有点笨拙，但似乎管用。</p><p> Most fonts that people write with are variable width. This means that the amount of horizontal space that each letter takes depends on the letter itself. For instance, a “w” takes up more space than an “i”. This is in contrast to monospace fonts, which deliberately space letters such that each one takes up the same amount of horizontal space.</p><p>人们书写的大多数字体都是可变宽度的。这意味着每个字母占用的水平空间量取决于字母本身。例如，“w”比“i”占用更多空间。这与单空格字体形成对比，单空格字体故意将字母隔开，使每个字母占据相同的水平空间。</p><p>      What this means for our attack (which is assumed to be in a variable-width font) is that each guessed letter has a cascading effect to the right of it. If you make the guess:</p><p>这对我们的攻击（假定为可变宽度字体）意味着，每个猜测的字母在其右侧都有级联效应。如果你猜：</p><p>  Then all future letters will be off, even if the letters are otherwise “correct”.</p><p>然后，所有未来的字母都将关闭，即使这些字母在其他方面是“正确的”。</p><p> This sounds like a big deal, but it’s actually not so bad. It just means that we have to stick with a recursive depth-first search and not treat letters like individual and independent artifacts. Recursive depth-first search works well here because it naturally takes that ordering into account. It works the following way:</p><p>这听起来很重要，但实际上并不是那么糟糕。这只是意味着我们必须坚持递归深度优先搜索，而不是将字母视为独立的工件。递归深度优先搜索在这里效果很好，因为它自然会考虑这种排序。它的工作原理如下：</p><p>   What we do is try out each character for the next letter and see which ones match up reasonably well with the redacted image. We’ll wind up with some subset of “good” guesses, perhaps “p” and “q” since p is correct and q resembles it pretty closely. We’ll then begin this whole process of guessing again for the new string of “this is sup” down the chain until we hit a dead end with no good guesses. At which point, the function call stack will naturally back up to try our other guess q.</p><p>我们要做的是尝试下一个字母的每个字符，看看哪些字符与经过编辑的图像匹配得相当好。我们将得到一些“好”猜测的子集，可能是“p”和“q”，因为p是正确的，q与它非常相似。然后，我们将再次开始猜测新字符串“this is sup”的整个过程，直到我们遇到一个没有好猜测的死胡同。在这一点上，函数调用堆栈将自然备份，以尝试我们的另一个猜测q。</p><p> And so on, until we’ve exhausted every “good” guess there is.</p><p>等等，直到我们用尽所有的“好”猜测。</p><p> As it happens, different rendering engines produce slightly different images even for what should be the exact same font. Look at these two captures of the same text. On top is GiMP’s rendering in Sans Serif and on bottom is FireFox:</p><p>碰巧的是，不同的渲染引擎生成的图像略有不同，即使是应该完全相同的字体。看看这两个相同文本的截图。顶部是GiMP的无衬线渲染，底部是FireFox：</p><p>  They’re  almost identical, but not quite. There are two things that stand out; one is the length. You can see that the top image is just a LITTLE longer. For long enough strings, this can have a cascading effect that will throw the whole thing off. The other difference is how the text is rasterized; the bottom line is just a little bit bolder than the top one. This one we can mostly handle by adjusting for brightness, but it’s a total pain.</p><p>它们几乎一模一样，但并不完全相同。有两件事很突出；一是长度。你可以看到上面的图片只是稍微长一点。对于足够长的字符串，这可能会产生一种级联效应，将整个事情抛诸脑后。另一个区别是文本如何光栅化；底线只是比最上面的要大胆一点。我们可以通过调整亮度来处理这个问题，但这是一个非常痛苦的问题。</p><p> For Unredacter, we’re using Electron to take screenshots of a local headless HTML window. So, the renderer will essentially be Chrome. Most of the time, this is not a problem. But if your redacted text was rendered using some really wonky program that doesn’t adhere to standards, then it might wind up veering off course quite a bit. Keep that in mind.</p><p>对于Undeacter，我们使用Electron拍摄本地无头HTML窗口的屏幕截图。因此，渲染器基本上是Chrome。大多数时候，这不是问题。但是，如果你的编辑文本是使用一些不符合标准的非常不可靠的程序来呈现的，那么它可能会偏离正常的方向。记住这一点。</p><p> If someone out there wants to write a wrapper for Unredacter that generates guesses using MS Word through some Rube Goldberg machine of wrappers and macros, you’re welcome to give it a go.</p><p>如果有人想通过Rube Goldberg的包装器和宏机器为Unredacter编写一个包装器，使用MS Word生成猜测，欢迎您试一试。</p><p> When pixelating an image, there’s two degrees of freedom that have to be accounted for: the x and y offset coordinates. But what the heck are those?</p><p>对图像进行像素化时，必须考虑两个自由度：x和y偏移坐标。但这些到底是什么？</p><p>   If you think of this as a static grid, then there’s 64 distinct locations for you to place the text on that grid. We call this the x and y “offset”. Depending on the offset you choose, it can produce dramatically different images:</p><p>如果你认为这是一个静态网格，那么有64个不同的位置供你放置文本在该网格上。我们称之为x和y“偏移”。根据您选择的偏移量，它可以生成截然不同的图像：</p><p>   Furthermore, there’s no way for the attacker to know what these offsets were. (Unlike the font and font-size). The offset is determined in most editors like GiMP by the mostly random process of where the user happened to have clicked when making a bounding box. If they had clicked a single pixel up or down, the pixelation would have made a fairly different image!</p><p>此外，攻击者无法知道这些偏移量是什么。（与字体和字号不同）。在大多数编辑器（如GiMP）中，偏移量是由用户在创建边界框时碰巧单击的位置的随机过程确定的。如果他们向上或向下点击一个像素，像素化会产生一个完全不同的图像！</p><p> The good news here is that there’s not THAT many possibilities for offsets. There’s blocksize 2 permutations. For a block size of 8, that makes 64 offsets to try. In our challenge text, the block size is 5, meaning there’s only 25 offsets to test.</p><p>好消息是，补偿的可能性并不多。有块大小2的排列。如果块大小为8，则需要尝试64个偏移。在我们的挑战文本中，块大小是5，这意味着只有25个偏移需要测试。</p><p>  So, step one of Unredacter is to discover what offset was used. We do this by trying each offset in a loop and see if  ANY letter comes up with a good first-letter guess. We take all the offsets that have good first-letter guesses and add them to a list to then try proper guesses.</p><p>所以，Unredacter的第一步是发现使用了什么偏移量。我们通过在循环中尝试每个偏移量来实现这一点，并查看是否有任何字母给出了一个好的首字母猜测。我们将所有第一个字母猜测正确的偏移量添加到列表中，然后尝试正确的猜测。</p><p> Okay! Armed with this knowledge, and a tool to exploit it, let’s take a look at Jumpsec’s challenge image again:</p><p>可以有了这些知识和利用这些知识的工具，我们再来看看Jumpsec的挑战图：</p><p>  One of the first things you might notice is that it has a curious bit of coloring in it. What gives? Shouldn’t it just be black and white since the text is black? Are they trolling us with colored letters?</p><p>你可能会注意到的第一件事是它有一点奇怪的颜色。有什么好处？既然文本是黑色的，就不应该是黑白的吗？他们在用彩色字母拖拽我们吗？</p><p> I’m actually not 100% sure why this happens (and sometimes doesn’t), but it’s an artifact of the rasterization process when text is rendered to screen. Just look at what happens when you zoom in to text typed out in Notepad:</p><p>实际上，我并不完全确定为什么会发生这种情况（有时不会），但当文本呈现到屏幕上时，这是光栅化过程的产物。只需看看放大记事本中键入的文本时会发生什么：</p><p>  When Unredacter renders the letters to a headless Chrome window, no colorized artifacts appear, so we’ll need to convert the image to greyscale. This will lose some information, but it’s fine. Unredacter doesn’t need exact matches, just for guesses to be “mostly right”. Once converted down, our challenge image looks like this:</p><p>当Undercater将字母渲染到无头Chrome窗口时，不会出现彩色瑕疵，因此我们需要将图像转换为灰度。这会丢失一些信息，但没关系。Unredacter不需要精确匹配，只需要猜测“基本正确”。一旦向下转换，我们的挑战图像如下所示：</p><p>  There’s one last adjustment I had to make, and it’s on the bottom row:</p><p>我必须做最后一个调整，它在最底层：</p><p>  It’s too small! The rest of the blocks are 5x5, but that bottom row is 5x3. After a few hours of trial and error, I also noticed that these blocks are too dark. Check out what a guess of the letter “g” looks like, versus the challenge image:</p><p>太小了！其余的块是5x5，但最下面一行是5x3。经过几个小时的反复试验，我还注意到这些积木太暗了。查看字母“g”的猜测与挑战图：</p><p>   See how that bottom row is  way too dark? It’s because when the image was pixelated, they must have selected a bounding box that wasn’t a size with multiple of 5. So, when the algorithm determined the average, it was an average over a smaller area. (Thus darker) No matter, we can fix it up by just lightening that last row. This gives us our final challenge image of:</p><p>看到最下面一排怎么太暗了吗？这是因为当图像被像素化时，他们一定选择了一个大小不是5倍的边界框。因此，当算法确定平均值时，它是一个较小区域的平均值。（因此更暗）没关系，我们可以通过点亮最后一排来修复它。这给了我们最后一个挑战的形象：</p><p>  Next up is to figure out the correct font and font size. Luckily this wasn’t too hard, the image was taken in MS Notepad with the default font of Consolas. After a bit of trial and error, I found that the font size is 24px. (I did this by just trying font sizes over and over until the height of capital M matched up.) The only tricky part of this wound up being that Notepad apparently has a default letter-spacing of -0.2px. If you try rendering text in Chrome in Consolas, it’s much too long. But -0.2px letter-spacing matches up  exactly.</p><p>下一步是找出正确的字体和字号。幸运的是，这并不难，这张图片是在MS Notepad中拍摄的，默认字体为Consoleas。经过一点尝试和错误，我发现字体大小是24px。（我只是反复尝试字体大小，直到大写字母M的高度匹配。）唯一棘手的是，记事本的默认字母间距为-0.2px。如果你试着在控制台中用Chrome渲染文本，那就太长了。但是-0.2px的字母间距正好匹配。</p><p>   If you look closely, the “s”, “e”, and “c” has a little more of a curve in Notepad’s rendering. But it’s fine. Again, we don’t need to be 100% exact. This pretty close!</p><p>如果仔细观察，“s”、“e”和“c”在记事本的渲染中有更多的曲线。但没关系。再说一遍，我们不需要100%准确。很接近！</p><p> Unredacter pretty quickly homes in on an offset of [3, 1], so let’s see how it does!</p><p>Unredacter很快就以[3,1]的偏移量进驻，所以让我们看看它是如何做到的！</p><p>       So I reached out to Caleb Herbert at Jumpsec, and they confirmed that my guess was correct!</p><p>所以我联系了Jumpsec的Caleb Herbert，他们确认了我的猜测是正确的！</p><p>  Caleb also asked me to not disclose the solution, so you reading this can have a go at it yourself. (It’s blurred out above, and there’s no way you can read blurred text, right?) Huge shoutout to Jumpsec for issuing this challenge, it was a lot of fun. Was a great way to test out a new tool, too!</p><p>Caleb还要求我不要透露解决方案，所以你可以自己尝试一下。（上面的文字模糊了，你根本看不懂模糊的文字，对吧？）向Jumpsec发出了巨大的欢呼声，这是一个很大的挑战。也是测试新工具的好方法！</p><p> If you want to check out the proof-of-concept source code to Unredacter, it’s  available on our GitHub right here.</p><p>如果你想查看Unredacter的概念验证源代码，可以在我们的GitHub上找到。</p><p> The bottom line is that when you need to redact text, use black bars covering the whole text. Never use anything else. No pixelization, no blurring, no fuzzing, no swirling. Oh, and be sure to actually edit the text as an image. Don’t make the mistake of changing your Word document so that it has black background with black text. (You can still read that just by highlighting  it like this.)</p><p>底线是，当你需要编辑文本时，用黑条覆盖整个文本。别用别的东西。没有像素化，没有模糊，没有模糊，没有漩涡。哦，一定要把文本编辑成图像。不要错误地更改Word文档，使其具有黑色背景和黑色文本。（你仍然可以通过这样突出显示来阅读。）</p><p> The last thing you need after making a great technical document is to accidentally leak sensitive information because of an insecure redaction technique.</p><p>在制作一份优秀的技术文档之后，你最不需要做的事情就是由于不安全的编辑技术而意外地泄露敏感信息。</p><p>  Dan Petro is a Lead Researcher at Bishop Fox and focuses on application penetration testing (static and dynamic), product security reviews, network penetration testing (external and internal), and cryptographic analysis. Dan has presented at several  Black Hats and DEF CONs on topics such as  hacking smart safes,  hijacking Google Chromecasts, and  weaponizing AI. He has developed several open-source tools including  Untwister, which breaks pseudorandom number generators. Additionally, Dan has been quoted in Wired, The Guardian, Business Insider, and Mashable. Dan holds both a Bachelor of Science and a Master of Science in Computer Science from  Arizona State University.</p><p>Dan Petro是Bishop Fox的首席研究员，专注于应用程序渗透测试（静态和动态）、产品安全审查、网络渗透测试（外部和内部）以及密码分析。Dan曾在多个黑帽子和DEF CONs上展示过黑客智能保险箱、劫持谷歌Chromecast和人工智能武器化等主题。他开发了几个开源工具，包括Untwister，它可以分解伪随机数生成器。此外，《连线》、《卫报》、《商业内幕》和《Mashable》都引用了丹的话。Dan拥有亚利桑那州立大学计算机科学学士和硕士学位。</p><p> More by Dan</p><p>丹的更多</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文本/">#文本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字母/">#字母</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>