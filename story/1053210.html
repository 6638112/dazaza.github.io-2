<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>推断这一点 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">推断这一点 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 17:50:53</div><div class="page_narrow text-break page_content"><p>我们提出了一种新机制，用于指定或致电成员函数被调用的表达式的值类别。换句话说，从成员内函数函数的方式函数是否载于它的表达式是偏僻的或rvalue;无论是常数还是挥发性;和表达式的类型。</p><p>   重新添加的部分与我们考虑的其他语法的历史（用于后面）以及对反射，显式静态，虚拟和金属版的讨论。在戴维斯纸上重新撰写的措辞。重新触及以便显式对象成员函数是非静态成员函数而不是静态成员函数。</p><p>    贝尔法斯特在ewg的反馈是“这看起来不错，回到措辞和实施”。此版本添加措辞，实现在于作品中。</p><p>    计算扣除的常见问题解答条目，EWGI在科纳要求的正交功能。</p><p>  [P0847R1]于2018年11月在San Diego提供了各种语法和名称查找选项。讨论揭示了对Lambdas的一些潜在问题，需要熨烫。此修订Zeroes在一个特定语法和名称查找语义上，解决了所有使用情况。</p><p>  [P0847R0]在2018年6月在rapperswil中介绍了使用该自我和amp中使用的那篇文章中使用的语法。自我表明显式对象参数而不是自我和amp;＆amp;这种出现在纸张R0中的自我。</p><p>  不同的语法，将对象参数的类型的类型放置在成员函数的参数声明（CV-Ref Pretifiers今天）之后 </p><p>不同的名称查找方案，可以防止来自具有显式自型注释的新型成员函数中的隐式/不合格访问，无论语法如何。</p><p> 此修订仔细探讨了这两个方向，呈现了不同的语法和查找方案，并在深度多用例中讨论以及每个语法如何或无法解决它们。</p><p>  在C ++ 03中，成员函数可以具有CV-restification，因此可以具有特定类想要特定成员的Const和非Const重载的场景。 （请注意，也可以希望易失性过载，但是那些不太常见，因此在此处没有检查。）在这些情况下，两个过载都执行相同的事情 - 唯一的区别在于被访问和使用的类型。这是通过重复函数来处理，同时根据需要调整类型和资格，或者将一个过载委托给另一个重载委托。后者的一个例子可以在Scott Meyers的“有效的C ++”[Effcpp]中找到，第3项：</p><p> Class TextBlock {Public：Char Const＆amp;操作员[]（size_t位置）const {// ...返回文本[位置]; } char＆amp;运算符[]（size_t位置）{return const_cast＆lt; char＆amp;＆gt;（static_cast＆lt; textblock const＆amp;（*这个）[位置]）; } // ......};</p><p>  在C ++ 11中，成员函数获取了新轴来专门执行：Ref-Pretifiers。现在，而不是潜在地需要两个成员函数的过载，而不是四个：＆amp;，const＆amp;＆amp;或const＆amp;＆amp ;.我们有三种方法来处理这一点：</p><p> 我们所有四个重载都以私有静态成员函数的形式委托给助手。</p><p>  模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t const＆amp;价值（）const＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {if（has_value（））{返回移动（这个 - ＆gt; m_value）; }掷bad_optional_access（）; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {if（has_value（））{返回移动（这个 - ＆gt; m_value）; }掷bad_optional_access（）; } // ......}; </p><p>模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {return const_cast＆lt; t＆gt;（static_cast＆lt; oleasting const＆amp;（*这个）.value（））; } constexpr t const＆amp;价值（）const＆amp; {if（has_value（））{返回它 - ＆gt; m_value; }掷bad_optional_access（）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {返回const_cast＆lt; t＆amp;＆amp;（static_cast＆lt;＆gt;＆gt;（*这个）.value（））; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {return static_cast＆lt; t const＆amp;＆gt;（value（））; } // ......};</p><p> 模板＆lt; typename t＆gt; class可选{// ... constexpr t＆amp;价值（）＆amp; {return value_impl（*这）; } constexpr t const＆amp;价值（）const＆amp; {return value_impl（*这）; } constexpr t＆amp;＆amp;价值（）＆amp;＆amp; {return value_impl（移动（*此））; } Constexpr t const＆amp;＆amp;价值（）const＆amp;＆amp; {return value_impl（移动（*此））;私人：模板＆lt; typename opt＆gt;静态Declitype（Auto）value_impl（OPT＆amp;＆amp; opt）{if（！opt .has_value（））{opt bad_optional_access（）;返回前进＆lt;选择＆gt;（选择）.m_value; } // ......};</p><p> 这远非复杂的功能，但基本上重复相同的代码四次 - 或者使用人工代表团避免这样做 - 乞求重写。不幸的是，不可能改善;我们必须以这种方式实现它。似乎我们应该能够向非成员职能摘要摘要限定员，在那里我们根本没有这个问题：</p><p> 模板＆lt; typename t＆gt; class可选{// ...模板＆lt; typename opt＆gt;朋友Decltype（Auto）值（OPT＆amp; o）{if（o .has_value（））{返回前进＆lt; opt＆gt;（o）.m_value; }掷bad_optional_access（）; } // ......};</p><p> 所有四个案例都以一个函数处理......除了它是非成员函数，而不是成员函数。不同的语义，语法不同，没有帮助。</p><p> 我们需要许多情况下我们需要两个或四个相同的成员函数的过载，用于不同的const  - 或ref-pretifiers。不仅如此，可能有额外的情况，其中一个类应该有四个特定成员函数的过载，但由于开发人员懒惰，没有。我们认为有足够的这种情况来优于更好的解决方案，而不是简单地“写它，再次写作，然后再写两次。”</p><p>  我们提出了一种新的方式来声明非静态成员函数，该函数将允许在仍然具有常规成员函数语法中仍可接受的同时进行类实例参数的类型和值类别。这是对语言的严格扩展。 </p><p>我们认为，在没有重复的情况下写入CV-REF限定符感知的成员函数模板的能力将提高代码可维护性，降低错误的可能性，并快速制作，更正的代码更易于写入。</p><p> 该提案足够一般，正交，以允许用于C ++的几个新令人兴奋的功能和设计模式：</p><p>   该提案假定存在两个图书馆的添加，但它不提出它们：</p><p> like_t，将第一类型的cv和ref-letifiers应用到第二个（例如lick_t＆lt; int＆amp;，double＆gt;是双倍＆amp;，＆lt; x const＆amp;＆amp;，x const＆＆amp;是y const＆amp;＆amp;等）</p><p> forward_like，forward的版本旨在转发不基于其自己的类型的变量，而是基于其他类型的类型。 Forward_like＆lt; t＆gt;（u）是前进的短手＆lt; late_t＆lt; d，decltype（u）＆gt;＆gt;（u）。</p><p>   可以声明非静态成员函数作为其第一个参数进行一个显式对象参数，用前缀关键字表示。一旦我们将对象参数提升到适当的功能参数，就可以在正常函数模板扣除规则下推导出来：</p><p> struct x {void foo（这个x const＆amp; self，int i）;模板＆lt;类型自我和gt; void bar（这个自我和amp; self）; }; struct d：x {}; void ex（x＆amp; x，d const＆amp; d）{x .foo（42）; //＃39;自我＆＃39;符合＆＃39; x＆＃39 ;,＆＃39; i＆＃39;是42 x .bar（）; //将Self授予x＆amp;，呼叫x :: bar＆lt; x＆gt;＆gt;移动（x）.bar（）; //将Self授予X，呼叫X :: Bar＆lt; x＆gt; d .foo（17）; //＃39;自我＆＃39;必将＆＃39; d＆＃39; d .bar（）; //将Self as d const＆amp;，呼叫x :: bar＆lt; d const＆amp;＆gt; } </p><p>具有显式对象参数的成员函数不能是静态的或虚拟的，并且它们不能具有CV-或REF  - 限定符。我们将讨论跟踪部分中的静态和虚拟的限制。</p><p> 对成员函数的调用将将对象参数解释为它的第一个（本 - 注释）参数;然后将括号表达式列表中的第一个参数解释为第二个参数等。</p><p> 在正常扣除规则之后，对应于显式对象参数的模板参数可以推导到从声明成员函数被声明的类的类型，如上面的d .bar（））。</p><p> 我们可以使用此语法来实现可选的:: value（）和可选::运算符 - ＆gt;（）只有两个函数而不是当前六：</p><p> 模板＆lt; typename t＆gt;结构可选{模板＆lt;类型自我和gt; Constexpr Auto＆amp;＆amp;价值（这个自我和amp;＆amp; self）{if（！self .has_value（））{oppl bad_optional_access（）;返回前进＆lt; self＆gt;（self）.m_value;模板＆lt;类型自我和gt; Constexpr自动运营商 - ＆gt;（这个自我和amp; self）{返回地址（self .m_value）; }};</p><p> 此语法也可以在Lambdas中使用，并且此注释参数揭示了在其身体中引用Lambda本身的方式：</p><p> 矢量捕获= {1,2,3,4}; [捕获]（此汽车＆amp;自我） - ＆gt; Decltype（Auto）{返回转发_like＆lt; DECLTYPE（自我）＆gt;（抓获）; [捕获]＆lt;阶级自我＆gt;（这个自我和amp;自我） - ＆gt; Decltype（Auto）{返回转发＆lt; self＆gt;（捕获）; } </p><p>Lambdas可以从捕获中移动或复制，具体取决于Lambda是否是偏航或rvalue。</p><p>  以下是描述如何挖掘这一切影响所有重要语言构造 - 名称查找，键入扣除，过载解决方案等。</p><p>  在C ++ 17中，名称查找包括在调用名称函数或呼叫运算符，在类类型的对象上时，常规类查找中发现的静态和非静态成员函数。非静态成员函数被视为有一个隐式对象参数，其类型是LVALUE或RVALUE参考对CV x（其中参考和CV限定符是基于函数自己的限定符确定的，它绑定到其上的对象函数被调用。</p><p> 对于使用显式对象参数的非静态成员函数，查找将与C ++ 17中的其他成员函数相同的方式，其中一个例外：而不是基于CV和Ref隐含地确定对象参数的类型成员函数的限定符，现在通过提供的显式对象参数的类型明确确定。以下示例说明了这一概念。</p><p> struct x {//隐式对象具有类型x＆amp; Void foo（）＆amp ;; //隐式对象具有类型x const＆amp; Void foo（）const＆amp ;; //隐式对象具有类型x＆amp;＆amp; Void Bar（）＆amp;＆amp ;; };</p><p> struct x {// explicit对象具有类型x＆amp; void foo（这个x＆amp;）; //显式对象具有X Const＆amp; void foo（这个x const＆amp;）; //显式对象有类型x＆amp;＆amp;禁止栏（此x＆amp;）; };</p><p> 在C ++ 17中的表达式上的表达式上的名称查找将在第一列中找到FOO的两个过载，因此丢弃的非Const过载应该是Const。 </p><p>使用所提出的语法，obj .foo（）将继续找到foo的过载，具有相同的行为到C ++ 17。</p><p> 我们查找候选函数的唯一变更是在一个显式对象参数的情况下，参数列表由一个转移。第一个列出的参数绑定到对象参数，第二个列出的参数对应于调用表达式的第一个参数。</p><p> 本文并未提出过载解决方案的任何更改，但仅建议将候选集扩展为包括以新语法编写的非静态成员函数和成员函数模板。因此，鉴于呼叫x .foo（），如果x不是const，如果x不是const，则过载解析仍将选择第一个foo（）过载。</p><p>  唯一候选人的唯一变革涉及，该提案允许扣除对象参数，这是语言的新功能。</p><p> 由于在某些情况下有多种方式来声明相同的函数，因此它将不成本，以声明具有相同参数的两个函数和对象参数相同的限定符。这是：</p><p> struct x {void bar（）＆amp ;;禁止栏（此x＆amp;）; //错误：相同的此参数类型静态void f（）; void f（这个x const＆amp;）; //错误：两个函数没有参数};</p><p>     此提议的主要动机之一是推断为类对象的CV  - 限定符和价值类别，这要求从调用成员函数的对象中缝合显式成员对象或类型。 </p><p>如果对象参数的类型是模板参数，则所有通常的模板扣除规则都适用于预期：</p><p> 结构x {模板＆lt;类型自我和gt;空白foo（这个自我和amp;＆amp;，int）; }; struct d：x {}; void ex（x＆amp; x，d＆amp; d）{x .foo（1）; // self = x＆amp;移动（x）.foo（2）; // self = x d .foo（3）; // self = d＆amp; }</p><p> 重要的是要强调扣除能够推断出一种极其强大的衍生类型。在最后一行中，无论语法如何，都将作为D＆amp;这对成员函数中的名称查找有影响，并导致潜在的模板参数推导扩展。</p><p>  但如果显式类型没有参考类型，该怎么办？这应该是什么意思？</p><p> struct less_than {模板＆lt; typename t，typename u＆gt; BOOL运算符（）（此LIST_THAN，T CONST＆amp; LHS，U CONTER＆amp; RHS）{返回LHS＆lt; RHS; }}; less_than {}（4,5）;</p><p> 显然，参数规范不应划分，第一个参数（less_than {}）通过值传递。</p><p> 在候选查找的提议规则之后，呼叫运算符在这里是候选者，对象参数绑定到（空）对象和其他两个参数绑定到参数。具有一个值参数，所有语言都不是新的 - 它具有清晰明显的含义，但我们从未能够以前的价值拍摄对象参数。对于这可能是可取的，请参阅副价率成员函数。 </p><p>到目前为止，我们只考虑了使用名称查找以及它们如何推断该参数的成员函数如何找到具有显式对象参数的成员函数。现在我们继续如何如何表现出这些职能的机构。</p><p> 由于从调用函数的对象推断出显式对象参数，因此这具有挖掘派生类型的可能效果。我们必须仔细考虑在此上下文中如何查找名称。</p><p> struct b {int i = 0;模板＆lt;类型自我和gt;自动＆amp;＆amp; F1（这个自我和amp;）{返回我;模板＆lt;类型自我和gt;自动＆amp;＆amp; F2（这个自我和amp;＆amp;）{返回这个 - ＆gt;我;模板＆lt;类型自我和gt;自动＆amp;＆amp; F3（这个自我＆amp;＆amp;）{返回forward_like＆lt; self＆gt;（*这）.i;模板＆lt;类型自我和gt;自动＆amp;＆amp; F4（这个自我和amp;＆amp;）{返回前进＆lt; self＆gt;（*这）.i;模板＆lt;类型自我和gt;自动＆amp;＆amp; F5（这个自我和amp;＆amp; self）{返回前进＆lt; self＆gt;（self）.i; }}; struct d：b {//阴影b :::我加倍i = 3.14; };</p><p> 问题是，这五个职能中的每一个有什么作用？他们应该是不均成的吗？什么是最安全的选择？</p><p>  如果有一个显式对象参数，则无法访问，每个访问必须通过自我。通过此内容没有隐性查找。这使得F1通过F4不良而且仅形成F5良好的F5。但是，虽然b（）.f5（）返回对b :: i的引用，而d（）.f5（）返回对d :: i的引用，因为自我是对D的引用。</p><p> 如果有一个显式对象参数，可以访问它，并指向基本子object。成员没有隐性查询;所有访问必须通过此或自我明确。这使得F1形成不良。 F2将是良好的，始终回到B :: i的参考。最重要的是，如果推断出显式对象参数，这将是依赖的。这个 - ＆gt;我总是是一个int，但它可以是int或int const const，具体取决于b对象是const的。 F3将始终是良好的，并且是返回B :: i的转发参考的正确方法。如果由于所请求的隐式衰落，则在B上调用而单独的B但是不成集的F4将是良好的。如前所述，F5将是良好的。</p><p> 始终可以访问，并指向基本子object;我们允许隐式查找为C ++ 17。这与前一个选择相同，除了现在F1是良好的，并且与F2完全相同。 </p><p>在San Diego讨论之后，我们提出的选项是＃1。这允许最清晰的模型是这种注释功能的：它是一个静态成员函数，提供更方便的功能调用语法。此类功能中没有隐含的这一点，唯一提到这将是对象参数的注释。必须通过对象参数直接完成所有成员访问。</p><p> 这种选择的结果是我们需要防止被推导到派生类型的对象参数。要确保上面的F5（）始终返回对B :: I的引用，我们需要编写以下其中一个：</p><p> 模板＆lt;类型自我和gt;自动＆amp;＆amp; F5（这种自我和amp;＆amp; self）{//明确地向自我施加到适当的b //注意，我们必须投入自我，而不是自我.i返回static_cast＆lt; lime_t＆lt; self，b＆gt;＆amp;＆amp;＆ ;＆gt;（self）.i; //使用显式子object语法。请注意，这始终是//偏僻的参考 - 不是转发参考返回自我.b :: i; //使用显式子object语法获取转发参考返回前进返回＆lt; self＆gt;（self）.b :: i; }</p><p>  此提议的最坏情况是我们不打算致力于授予派生对象的情况 - 我们只意味着推断资格级别 - 但是从我们私下继承的派生类型是我们的成员之一 - </p><p> B级{int i;公共：模板＆lt;类型自我和gt;自动＆amp;＆amp;得到（这个Self＆amp;＆amp; self）{//查看了上面的：我们需要减轻阴影返回转发＆lt; self＆gt;（self）.b :: i; }}; D级：私人B {双我;公众：使用B :: GET; }; d（）.get（）; // 错误</p><p> 在这个例子中，自我推断为d（不是b），但我们选择的阴影缓解将不起作用 - 我们可以</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/推断/">#推断</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deducing/">#deducing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/参数/">#参数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>