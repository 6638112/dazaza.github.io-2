<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>高尔夫推杆的层次模型Hierarchical Model of Golf Putting</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hierarchical Model of Golf Putting<br/>高尔夫推杆的层次模型</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 03:39:20</div><div class="page_narrow text-break page_content"><p>My earlier modeling was mostly a success—it’s a popular example, it’s a Stan case study, and it’s in our workflow article. We had an initial dataset that we can fit with a simple one-parameter geometry-based model:</p><p>我之前的建模基本上是成功的，这是一个流行的例子，这是一个斯坦案例研究，在我们的工作流文章中。我们有一个初始数据集，可以与一个简单的单参数几何模型相匹配：</p><p>  Then we got new data where the first model doesn’t fit but we can fix by following Mark Broadie’s suggestion and adding just one more parameter to capture a little bit more of the geometry of the problem:</p><p>然后，我们得到了第一个模型不适合的新数据，但我们可以按照Mark Broadie的建议进行修复，只需再添加一个参数，以捕捉问题的更多几何图形：</p><p>  That was all good but we had convergence problems fitting this model in Stan, and the only way I could get it to fit smoothly was to add a fudge factor, an independent error term at each distance. Including this extra error did not bother me—after all, we would not expect an simple model to fit real data perfectly—but I was annoyed that, to add this error term, I needed to approximate the binomial likelihood with a normal distribution. Such an approximation would give problems going forward if we wanted to model the probability of success given players, golf courses, and weather conditions, in which case we’d have lots of cells with just 1 or 2 observations so the normal approximation wouldn’t work.</p><p>这一切都很好，但我们在用斯坦拟合这个模型时遇到了收敛问题，我能让它平滑拟合的唯一方法是在每个距离处添加一个模糊因子，一个独立的误差项。包括这个额外的误差并没有困扰我，毕竟，我们不会期望一个简单的模型完美地拟合真实数据，但我很恼火，要添加这个误差项，我需要用正态分布近似二项可能性。如果我们想在给定的球员、高尔夫球场和天气条件下对成功的概率进行建模，这种近似会给未来带来问题，在这种情况下，我们会有很多单元格，只有1或2个观测值，因此正常近似将不起作用。</p><p> So I tried a direct approach, adding an error term to the modeled probability of success—but that couldn’t be done on the probability scale because then the probability could go below 0 or above 1, so I tried an additive error on the logistic scale; in Stan:</p><p>所以我尝试了一种直接的方法，在建模成功的概率中加入一个误差项，但这不能在概率尺度上完成，因为这样概率可能会低于0或高于1，所以我尝试了逻辑尺度上的加性误差；在斯坦：</p><p>  Here, p_angle .* p_distance is the predicted probability of success (the probability of getting both the shot angle and the shot distance within tolerance), and sigma_eta*eta is the vector of errors (with eta given a normal(0,1) prior and sigma_eta representing the scale of the errors). The logistic and inverse logistic transformations keep the probabilities bounded between 0 and 1.</p><p>这里，p_angle。*p_distance是预测的成功概率（使射程角度和射程都在公差范围内的概率），sigma_eta*eta是误差向量（给定正常（0,1）先验的eta和代表误差范围的sigma_eta）。logistic和逆logistic变换将概率限制在0和1之间。</p><p>  And that’s where we were a few days ago. Stuck! Stuck stuck stuck.</p><p>几天前我们就在这里。卡住了！卡住了。</p><p> There were various suggestions in comments, but none were directly helpful, until  this came from Kj:</p><p>评论中有各种各样的建议，但没有一个是直接有用的，直到Kj提出了以下建议：</p><p> The problem seems rooted in the model needing the shortest putts probability to be very close to 1 in order to fit the rest of the data. Before the normal hack, the (poorly sampled) model estimates the probability of the shortest putts to be 10^9 in logit space.</p><p>这个问题似乎源于一个模型，该模型需要最短推杆概率非常接近1，以便拟合其余数据。在普通黑客攻击之前，（抽样较差）模型估计在logit空间中最短推杆的概率为10^9。</p><p> The normal hack applies to probability space, and there the error is tiny, so it works fine. But if you look at the error in logit space, the fit remains really bad.</p><p>普通的黑客攻击适用于概率空间，在那里，误差很小，所以工作正常。但如果你看看logit空间中的错误，拟合仍然非常糟糕。</p><p> And I was like, Aha! Here’s a solution: a three-parameter model that scales all the probabilities down from 1:</p><p>我就想，啊哈！这里有一个解决方案：一个三参数模型，将所有概率从1降到1：</p><p> data { int J; array[J] int n; vector[J] x; array[J] int y; real r; real R; real overshot; real distance_tolerance;}transformed data { vector[J] threshold_angle = asin((R-r) ./ x);}parameters { real&lt;lower=0&gt; sigma_angle; real&lt;lower=0&gt; sigma_distance; real&lt;lower=0, upper=1&gt; epsilon;}model { vector[J] p_angle = 2*Phi(threshold_angle / sigma_angle) - 1; vector[J] p_distance = Phi((distance_tolerance - overshot) ./ ((x + overshot)*sigma_distance)) - Phi((- overshot) ./ ((x + overshot)*sigma_distance)); vector[J] p = p_angle .* p_distance * (1 - epsilon); y ~ binomial(n, p); [sigma_angle, sigma_distance] ~ normal(0, 1);}</p><p>数据{</p><p> The key is to make it a multiplier that has to be less than 1. This eliminates the problem with the boundary and the need for the logit.</p><p>关键是使其成为一个必须小于1的乘数。这就消除了边界问题和对logit的需求。</p><p>  variable mean median sd mad q5 q95 rhat ess_bulk ess_tail lp__ -363841.724 -363841.000 1.311 1.483 -363844.000 -363840.000 1.000 1636 NA sigma_angle 0.018 0.018 0.000 0.000 0.018 0.018 1.002 1905 2165 sigma_distance 0.080 0.080 0.001 0.001 0.079 0.081 1.002 1659 1859 epsilon 0.001 0.001 0.000 0.000 0.001 0.001 1.002 1545 1493</p><p>可变平均中位数sd mad q5 q95 rhat ess_散装ess_尾</p><p> I’m not sure what’s going on with the tail effective sample size; we’ll have to look into this. I suspect it’s caused by some rounding error. Doesn’t really matter, though.</p><p>我不确定尾部有效样本量是怎么回事；我们得调查一下。我怀疑这是由舍入误差引起的。不过这并不重要。</p><p> The above model fits the data in the sense of going through the data points, but it’s still just a three-parameter model so to really do things right we might still want to add an error term. We can do this, using the same principle of making the errors multiplicative and constraining them to fall between 0 and 1:</p><p>上面的模型在遍历数据点的意义上符合数据，但它仍然只是一个三参数模型，所以为了真正做正确的事情，我们可能仍然需要添加一个错误项。我们可以这样做，使用相同的原理，使错误成倍增加，并将其限制在0到1之间：</p><p> data { int J; array[J] int n; vector[J] x; array[J] int y; real r; real R; real overshot; real distance_tolerance;}transformed data { vector[J] threshold_angle = asin((R-r) ./ x);}parameters { real&lt;lower=0&gt; sigma_angle; real&lt;lower=0&gt; sigma_distance; real&lt;lower=0&gt; sigma_epsilon; vector&lt;lower=0, upper=1&gt;[J] epsilon;}model { vector[J] p_angle = 2*Phi(threshold_angle / sigma_angle) - 1; vector[J] p_distance = Phi((distance_tolerance - overshot) ./ ((x + overshot)*sigma_distance)) - Phi((- overshot) ./ ((x + overshot)*sigma_distance)); vector[J] p = p_angle .* p_distance .* (1 - epsilon); epsilon ~ exponential(1/sigma_epsilon); y ~ binomial(n, p); [sigma_angle, sigma_distance] ~ normal(0, 1);}</p><p>数据{</p><p> This is a little bit hacky because we’re using the exponential density for the epsilons and then constraining to be no more than 1, but in practice it will be fine. The scale parameter sigma_epsilon keeps the errors under control. (I tried epsilon ~ normal(0, sigma_epsilon); model and it gave essentially the same results.) We can also augment the model so it computes residuals:</p><p>这有点不妥，因为我们对ε使用指数密度，然后将其限制为不大于1，但在实践中可以。标度参数sigma_epsilon可控制误差。（我尝试了ε~normal（0，sigma_ε）；模型和它给出的结果基本相同。）我们还可以扩展模型，以便计算残差：</p><p> data { int J; array[J] int n; vector[J] x; array[J] int y; real r; real R; real overshot; real distance_tolerance;}transformed data { vector[J] threshold_angle = asin((R-r) ./ x); vector[J] raw_proportion = to_vector(y) ./ to_vector(n);}parameters { real&lt;lower=0&gt; sigma_angle; real&lt;lower=0&gt; sigma_distance; real&lt;lower=0&gt; sigma_epsilon; vector&lt;lower=0, upper=1&gt;[J] epsilon;}transformed parameters { vector[J] p_angle = 2*Phi(threshold_angle / sigma_angle) - 1; vector[J] p_distance = Phi((distance_tolerance - overshot) ./ ((x + overshot)*sigma_distance)) - Phi((- overshot) ./ ((x + overshot)*sigma_distance)); vector[J] p = p_angle .* p_distance .* (1 - epsilon);}model { epsilon ~ exponential(1/sigma_epsilon); y ~ binomial(n, p); [sigma_angle, sigma_distance] ~ normal(0, 1);}generated quantities { vector[J] residual = raw_proportion - p_angle .* p_distance;}</p><p>数据{</p><p> We needed to move some things into the transformed parameters block so they’d be accessible in the generated quantities calculation. Also, we compute residual relative to p_angle .* p_distance, not relative to p, because the whole point is to look at the fit of two-parameter model fits. The error term epsilon is not part of the prediction, in this sense, even though it would appear to be so in the usual framework of the Bayesian model, for example when computing  elpd etc.</p><p>我们需要将一些东西移动到转换参数块中，以便在生成的数量计算中可以访问它们。此外，我们还计算了相对于p_角的残差。*p_距离，与p无关，因为整个问题是看两参数模型拟合的拟合。从这个意义上讲，误差项epsilon不是预测的一部分，尽管在贝叶斯模型的通常框架中，例如在计算elpd等时，它似乎是如此。</p><p> Anyway, here’s a plot of the fitted model and the posterior mean of its residuals:</p><p>不管怎样，下面是拟合模型的曲线图及其残差的后验平均值：</p><p>    Our new plot looks a little bit worse, actually! But I guess it’s a price I’m willing to pay to have a model that is more mathematically coherent.</p><p>实际上，我们的新情节看起来有点糟糕！但我想这是我愿意付出的代价，让模型在数学上更加连贯。</p><p> Hmmm, this gets me wondering . . . What are the residuals from our three-parameter model above, the one where p = p_angle .* p_distance .* (1 – epsilon);, so that there’s a fixed downward multiplier? Let’s take a look:</p><p>嗯，这让我想知道。以上三参数模型的残差是多少，其中p=p_角。*p_距离。*（1–ε）；，所以有一个固定的下行乘数？我们来看看：</p><p>  Hey! This looks fine. So I’m inclined to just stop here for now and not bother with that model with the separate epsilon for each distance.</p><p>嘿这看起来不错。所以我倾向于现在就停在这里，而不必为每个距离都有独立的ε而烦恼。</p><p> As has been discussed in the comment thread, there are lots of ways this model could be improved, but now we have a simple three-parameter model that fits the data without that normal-approximation hack, so this is what I’d start with going forward, then allowing these parameters to vary by golfer, hole, and weather condition.</p><p>正如评论帖子中所讨论的，有很多方法可以改进这个模型，但现在我们有了一个简单的三参数模型，可以在没有正常近似的情况下拟合数据，所以这就是我要从下一步开始的，然后允许这些参数随高尔夫球手、洞和天气条件而变化。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/推杆/">#推杆</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/model/">#model</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模型/">#模型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>