<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Clojure中模拟RAM</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在Clojure中模拟RAM</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:54:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/431e2b990983268b5d9ef9eecaa335d6.png"><img src="http://img2.diglog.com/img/2020/11/431e2b990983268b5d9ef9eecaa335d6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>“Computers are all made out of logic gates”. We’ve heard that saying before. We also have a sense that logic gates are very simple machines, analogous to light switches even. This raises the question:  how exactly do kind-of-light-switches come together to form computers? How does “storing a variable” or “calling a function” translate into logic gates going on or off?</p><p>“计算机都是由逻辑门组成的。”我们以前听过这句话。我们也有一种感觉，逻辑门是非常简单的机器，甚至类似于电灯开关。这就提出了一个问题：这种光开关究竟是如何组合在一起形成计算机的？“存储变量”或“调用函数”如何转换为逻辑门打开或关闭？</p><p> On a journey to answer that question, I discovered J Clark Scott’s excellent book  “How do It Know?”. He starts with NAND gates and takes you on a journey to build a computer using them.</p><p>在回答这个问题的旅途中，我发现了J·克拉克·斯科特(J Clark Scott)的杰作“它是如何知道的？”他从与非门开始，带你踏上用它们建造计算机的旅程。</p><p> I liked his book so much that I took his schematic for RAM, and simulated it in Clojure. In this essay, I’ll guide you through doing just that: we’ll simulate NAND gates, and use about  14 thousand of them to build 256 bytes of RAM.</p><p>我非常喜欢他的书，所以我拿了他的RAM示意图，并用Clojure进行了模拟。在本文中，我将指导您完成这项工作：我们将模拟NAND门，并使用大约14,000个NAND门来构建256字节的RAM。</p><p> Going through this simulation ingrained an “aha” feeling in me: watching 14 thousand little machines chug away makes you feel that whoever uses a computer is a wizard. A wizard with an army of millions of machine servants doing billions of little jobs for them every second. I hope it gives you the same feeling. 🙂</p><p>通过这次模拟，我有一种“啊哈”的感觉：看着14000台小机器嗡嗡作响，你会觉得无论是谁使用计算机，都是一个巫师。一个拥有数以百万计的机器仆人的巫师，每秒都在为他们做数十亿件小事。我希望它能给你同样的感觉。🙂。</p><p>    This describes a NAND gate. A NAND gate is a machine that has two input wires. If both input wires have a “high” charge (represented as 1), the output charge is “low” (represented as zero). With any other combination of input charges, the output charge is high.</p><p>这描述了与非门。与非门是一种有两条输入线的机器。如果两根输入线都有“高”电荷(表示为1)，则输出电荷为“低”(表示为零)。输入电荷的任何其他组合，输出电荷都很高。</p><p> Notice that the wires carry a charge, but we choose to interpret  meaning in the charge. “high charge” means 1, and “low charge” means 0. Nothing changes in the machine, this is just something we decided as humans (1).</p><p>请注意，导线带有电荷，但我们选择解释电荷的含义。“高电荷量”表示1，“低电荷量”表示0。这台机器没有什么变化，这只是我们作为人类决定的事情(1)。</p><p> On the left you see a circuit diagram. You can read it as input wires  a and  b carrying charges into the  NAND gate. The  NAND gate has a wire  c, carrying the output charge. For all the circuit diagrams we’ll draw, you can read them as electricity “flowing” from left to right, or top to bottom.</p><p>在左边你可以看到一张电路图。您可以将其理解为将电荷带入与非门的输入线a和b。与非门有一根导线c，携带输出电荷。对于我们将要绘制的所有电路图，您可以将其理解为电流从左到右或从上到下“流动”。</p><p> On the right is a “truth” table for a NAND gate. This is just a fancy name for summarizing every state a  NAND gate can be, based on the input wires.</p><p>右边是一个“与非”门的“真”表。这只是一个奇特的名字，用来根据输入线总结NAND门可能达到的每一种状态。</p><p> Now, we can start even lower than a  NAND gate, but this machine is simple enough. It can’t be so hard to build something that turns off when two inputs are turned on. You don’t have to take my word for it though, you can search up “building a NAND gate with transistors”, and come back when you’re convinced.</p><p>现在，我们可以从比NAND门更低的位置开始，但这台机器非常简单。当两个输入接通时，构建一个可以关闭的东西不会那么难。不过你不必相信我的话，你可以搜索“用晶体管建造与非门”，当你确信的时候再回来。</p><p>   First things first, we need some way to represent the state of our circuit. We know that our RAM will be built completely from  NAND gates, so let’s take inspiration from one:</p><p>首先，我们需要一些方法来表示我们赛道的状态。我们知道我们的RAM将完全由NAND门构建，所以让我们从其中一个中获得灵感：</p><p>    Here’s one way we can map that to a data structure in Clojure:</p><p>以下是我们可以将其映射到Clojure中的数据结构的一种方法：</p><p> ( def  ex-state-v0 { :charge-map  { :a   1   :b   1   :c   0 }   :nand-gates  [{ :ins  [ :a   :b ]   :out   :c }]})</p><p>(def ex-state-v0{：Charge-Map{：A 1：B 1：C 0}：NAND-GATES[{：INS[：A：B]：OUT：C}]})。</p><p> We can use keywords to represent our wires. We can also keep a map that tells us the charges of our wires. Finally, we can keep a list of NAND gates, which tell us how these wires connect.</p><p>我们可以使用关键字来表示我们的电线。我们还可以保存一张地图，告诉我们电线的电荷。最后，我们可以保存NAND门的列表，它告诉我们这些线是如何连接的。</p><p> Fine enough way to represent our circuit for now! Let’s create a few functions that can help us manage this representation:</p><p>就目前而言，这足以代表我们的赛道！让我们创建几个函数来帮助我们管理这个表示：</p><p> ; update state v0 ; --------------- ( def  empty-state { :charge-map  {}  :nand-gates  []}) ( defn  charge [state wire]  ( get-in  state [ :charge-map  wire])) ( defn  charges [state wires]  ( map  ( partial  charge state) wires)) ( defn  set-charge [state wire charge]  ( assoc-in  state [ :charge-map  wire] charge)) ( defn  wire-nand-gate [state a b o]  ( update  state  :nand-gates  conj { :ins  [a b]  :out  o}))</p><p>；更新状态V0；-(def Empty-State{：Charge-MAP{}：NAND-GATES[]})(Defn Charge[State wire](Get-in State[：Charge-Map wire]))(Defn Chards[State wire](MAP(部分电荷状态)wire))(Defn Set-Charge[State wire](Assoc-In State[：Charge-Map wire]Charge)(Defn wire-NAND-。GATE[STATE a b o](更新状态：NAND-GATES conj{：ins[a b]：out o})。</p><p> These are all the basic tools we need to “connect” a NAND gate into our circuit. Let’s try them out in the REPL:</p><p>这些都是我们将与非门“连接”到电路中所需的基本工具。让我们在REPL中尝试一下：</p><p> ( charges  ( -&gt;  empty-state  ( set-charge   :a   1 )  ( set-charge   :b   0 ))  [ :a   :b ]) ; =&gt; (1 0) ( wire-nand-gate  empty-state  :a   :b   :c ) ; =&gt; {:charge-map {}, :nand-gates [{:ins [:a :b], :out :c}]}</p><p>(电荷(-&gt；空状态(Set-Charge：A1)(Set-Charge：B 0))[：A：B])；=&gt；(1 0)(Wire-NAND-GATE空状态：A：B：C)；=&gt；{：电荷映射{}，：NAND-GATES[{：INS[：A：B]，：OUT：C}]}。</p><p> Nice! We can now “wire” up a circuit. Let’s run some electricity through it.</p><p>好的!。我们现在可以“接线”一条线路。让我们通电通过它。</p><p>  To figure out how to simulate electricity into our circuit, let’s remember our diagram again:</p><p>为了弄清楚如何将电流模拟到我们的电路中，让我们再次记住我们的图：</p><p>  One way we can model this is to imagine that electricity is like water: It “flows” from sources into wires, and “triggers” all the devices that are connected to those wires.</p><p>我们可以模拟这种情况的一种方式是把电想象成水：它从源头“流”到电线，并“触发”所有连接到这些电线上的设备。</p><p> With a model like that, here’s what would happen if a charge was “triggered” on  a:</p><p>对于这样的模型，如果在以下情况下“触发”一项收费，将会发生什么情况：</p><p> After that  a ‘s charge would transfer to all the NAND gates that are connected to it. In this case, it would be our one NAND gate above.</p><p>此后，A的电荷将转移到与其连接的所有与非门。在这种情况下，它将是我们上面的一个与非门。</p><p> Each NAND gate would then recompute its charge, and if it changed, trigger its output wire in turn. In our case that’s  c</p><p>然后，每个与非门将重新计算其电荷，如果电荷改变，则依次触发其输出线。在我们的例子中，这是c。</p><p> If  c was connected to other  NAND gates, those gates would trigger, and the process would continue.</p><p>如果c连接到其他NAND门，这些门将被触发，该过程将继续。</p><p> Now, this is a very naive view of how electricity works (2), but it’s good enough for us to model RAM!</p><p>现在，这是一个关于电是如何工作的非常天真的观点(2)，但它足以让我们为RAM建模！</p><p>     Our  nand-output function takes two input charges, and produces the output charge that a  NAND gate would produce.</p><p>我们的与非输出函数接受两个输入电荷，并产生与非门将产生的输出电荷。</p><p> Next, we need a function to find all the  NAND gates that are connected to a specific wire:</p><p>接下来，我们需要一个函数来查找连接到特定导线的所有与非门：</p><p>   This searches all of our  NAND gates in our circuit, and finds the ones which are connected to a specific wire.</p><p>这将搜索电路中的所有NAND门，并找到连接到特定导线的那些门。</p><p>  ( declare  trigger-nand-gate) ( defn  trigger  ([state wire new-v]  ( let  [old-charge ( charge  state wire)  state&#39; ( set-charge  state wire new-v)  new-charge ( charge  state&#39; wire)]  ( if  ( =  old-charge new-charge)  state&#39;  ( reduce  ( fn  [acc-state out] ( trigger-nand-gate  acc-state out))  state&#39;  ( dependent-nand-gates  state&#39; wire))))))</p><p>(声明Trigger-NAND-GATE)(Defn Trigger([STATE WIRE NEW-V](LET[OLD-Charge(Charge State Wire)State&#39；(Set-Charge State Wire NEW-v)new-Charge(Charge State)](IF(=Old-Charge New-Charge)STATE&#39；(Reduce(FN[Acc-State Out](Trigger-NAND-Gate Acc-State Out)STATE&#39；(Dependent-NAND-GATES STATE&#)(Dependent-NAND-GATES STATE&#)。电线)。</p><p>   What’s left is to implement what a  NAND gate does when it is triggered:</p><p>剩下的就是实现NAND门在被触发时所做的事情：</p><p> ( defn  trigger-nand-gate  [state { :keys  [ins out]}]  ( let  [new-charge ( apply  nand-output ( charges  state ins))]  ( trigger  state out new-charge)))</p><p>(定义触发器与非门[STATE{：KEYS[INS OUT]}](LET[NEW-CHAGE(应用NAND-OUT(电荷状态INS))]](触发状态OUT NEW-CHAGE))。</p><p> This calculates the new charge of a  NAND gate, and triggers the  output wire with that charge.</p><p>这会计算与非门的新电荷，并用该电荷触发输出线。</p><p>  One final helper function: let’s create something that will will let us “trigger” many wires:</p><p>最后一个辅助函数：让我们创建一些可以让我们“触发”多条线路的东西：</p><p> ( defn  trigger-many [state wires charges]  ( reduce  ( fn  [acc-state [wire charge]]  ( trigger  acc-state wire charge))  state  ( map  vector wires charges)))</p><p>(Defn触发器-多个[状态导线电荷](Reduce(fn[acc-state[导线电荷]](触发acc状态导线电荷))状态(映射向量导线电荷)。</p><p> We’ll want to do this so much that it’s good to have around.</p><p>我们非常想做这件事，所以有这样的人在身边是很好的。</p><p>  We have what we need to simulate a simple charge flowing through a NAND gate. Let’s write a test for that:</p><p>我们已经有了模拟通过NAND门的简单电荷所需的东西。让我们为此编写一个测试：</p><p> ( deftest  test-nand-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-nand-gate   :a   :b   :o )  ( trigger-many  [ :a   :b ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :b   1 ))]  ( testing   &#34;just a is on&#34;  ( is  ( =  &#39;( 1   0   1 ) ( charges  s1 [ :a   :b   :o ]))))  ( testing   &#34;both a and b are on&#34;  ( is  ( =  &#39;( 1   1   0 ) ( charges  s2 [ :a   :b   :o ]))))))</p><p>(Deftest-NAND-GATE(设[S1(-&gt;；EMPTY-STATE(Wire-NAND-GATE：A：B：O))(Trigger-My[：A：B][1 0]))S2(-&&gt;S1(Trigger：B1))](Testing&#34；Just a is on&#34；(is(=&#39；(1 0 1)(费用s1[：a：b：o])(测试&#34；a和b都在&#34；(is(=&#39；(1 1 0)(费用s2[：a：b：o])。</p><p>    What would happen, if we took a NAND gate, and fed the  same wire in both inputs?</p><p>如果我们取一个NAND门，并在两个输入端馈入相同的导线，会发生什么情况？</p><p>  Well, the output would end up being the opposite of its input. When  a is zero,  c is 1, when  a is 1,  c is 0. Boom, that happens to be a  NOT gate. Here’s how that looks:</p><p>那么，输出将最终与其输入相反。当a为零时，c为1，当a为1时，c为0。砰的一声，那正好是一扇“非门”。这看起来是这样的：</p><p>  To implement our  NOT gate, we can do exactly as our diagram described: Feed the same wire to  both inputs of a  NAND gate:</p><p>要实现我们的NOT门，我们可以完全按照图中描述的那样做：将相同的导线馈送到NAND门的两个输入端：</p><p>   ( deftest  test-not-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-not-gate   :a   :o )  ( trigger   :a   0 ))  s2 ( -&gt;  s1  ( trigger   :a   1 ))]  ( testing   &#34;a is off&#34;  ( is  ( =  &#39;( 0   1 ) ( charges  s1 [ :a   :o ]))))  ( testing   &#34;a is on&#34;  ( is  ( =  &#39;( 1   0 ) ( charges  s2 [ :a   :o ]))))))</p><p>(Deftest-NOT-GATE(设[S1(-&&gt;；EMPTY-STATE(Wire-NOT-GATE：A：O))(Trigger：A0))S2(-&gt；S1(Trigger：A1))](测试&#34；a关闭&#34；(is(=&#39；(0 1)(费用S1[：A：O])(测试&#34；a打开&#34；(is(=&#39；(1 0)(费用s2[：A：O])。</p><p>    What if we plugged the output of one  NAND as the input of a  NOT gate?</p><p>如果我们插入一个NAND的输出作为NOT门的输入，会怎么样？</p><p>  Well, it would be opposite of a  NAND gate:  d would only be 1 when  both  a and  b are 1. That’s the  AND gate:</p><p>它与NAND门相反：只有当a和b都是1时，d才会是1。这就是AND门：</p><p>   ( defn  wire-and-gate [state a b o]  ( let  [nand-o  :c ]  ( -&gt;  state  ( wire-nand-gate  a b nand-o)  ( wire-not-gate  nand-o o))))</p><p>(Defn Wire-and-Gate[State a b o](设[NAND-o：c](-&gt；State(Wire-NAND-Gate a b NAND-o)(Wire-Not-Gate NAND-o)。</p><p> This would work…almost. The tricky thing here is that inside the function we have an “intermediary” wire  c, which connects the  NAND gate and  NOT gate. If we made  two  AND gates for example, then they would share the same wire  :c!</p><p>这会奏效的，…。差不多了。这里的棘手之处在于，在函数内部，我们有一个“中间”导线c，它连接与非门和非门。例如，如果我们制作了两个AND门，那么它们将共享同一根导线：C！</p><p>  ( def  _u ( atom  {})) ( defn  uniq-n [k]  ( swap!  _u update k ( fn  [i] ( inc  ( or  i  0 ))))  ( get  @_u k)) ( defn  kw [&amp; args]  ( -&gt;&gt;  args  ( map  ( fn  [x] ( if  (( some-fn  keyword? symbol?) x)  ( name  x)  x)))  ( apply  str)  keyword)) ( defn  wire  ([n]  ( let  [i ( uniq-n  n)]  ( if  ( &gt;  i  1 ) ( kw  n  &#34;#&#34;  i) n))))</p><p>(def_u(atom{}))(Defn uniq-n[k](SWAP！_u UPDATE k(FN[i](Inc(Or I 0)(get@_u k)(Defn kw[&amp；args](-&&gt;；&&gt;args(MAP(fn[x])(if((某些-fn关键字？符号？)。X)(名称x)(应用字符串关键字))(Defn wire([n](let[i(uniq-n n)](if(&gt；i 1)(kw n&#34；#&#34；i)n)。</p><p>   Now if we create a wire with a name that already exists, it’ll add a nice little “#2” beside it.</p><p>现在，如果我们用已经存在的名称创建一条线，它会在它的旁边添加一个漂亮的小“#2”。</p><p>  ( defn  wire-and-gate [state a b o]  ( let  [nand-o ( wire  ( kw  a b  :and-nand-o ))]  ( -&gt;  state  ( wire-nand-gate  a b nand-o)  ( wire-not-gate  nand-o o))))</p><p>(Defn Wire-and-Gate[State a b o](let[NAND-o(wire(kw a b：and-nAND-o))](-&gt；state(wire-NAND-gate a b NAND-o)(Wire-NOT-GATE NAND-o)</p><p>  ( deftest  test-and-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-and-gate   :a   :b   :o )  ( trigger-many  [ :a   :b ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :b   1 ))]  ( testing   &#34;just a is on&#34;  ( is  ( =  &#39;( 1   0   0 ) ( charges  s1 [ :a   :b   :o ]))))  ( testing   &#34;a and b on&#34;  ( is  ( =  &#39;( 1   1   1 ) ( charges  s2 [ :a   :b   :o ]))))))</p><p>(Deftest-and-gate(设[S1(-&gt;；Empty-State(Wire-and-Gate：A：B：O)(Trigger-My[：A：B][1 0])S2(-&gt；S1(Trigger：B1))](Testing&#34；Just a is on&#34；(is(=&#39；(1 0 0)(费用s1[：a：b：o])(测试&#34；a和b&#34；(is(=&#39；(111)(费用s2[：a：b：o])。</p><p>    Now comes one of the hardest and most important circuits we’ll need to understand. Let’s start by describing our goal:</p><p>现在是我们需要了解的最难也是最重要的赛道之一。让我们从描述我们的目标开始：</p><p>  Notice the interesting thing here. When the  s wire is “1”, the value of  i is transferred to  o. When it is “0”, the value of  o is  no longer affected by i.  o&#39;s charge is  whatever it was before.</p><p>请注意这里的有趣之处。当s线为“1”时，i的值被转移到o。当它为“0”时，o的值不再受i的影响，o的电荷保持不变。</p><p> If we can make something like this, that would mean that the charge on “o” is  stored.  Since it can be either 1 or 0, we can in effect “store” 1 bit of data.</p><p>如果我们能做出这样的东西，那就意味着“o”上的电荷被储存起来了。因为它可以是1也可以是0，我们实际上可以“存储”1位数据。</p><p>   The trick with this circuit is the way  o and  c are connected together. This intertwining thing is called a “latch”, because once a charge gets set in a certain way, these gates will find an equilibrium that causes  o to be stored. Pretty cool!</p><p>这个电路的诀窍在于o和c连接在一起的方式。这种缠绕在一起的东西被称为“锁存”，因为一旦以某种方式设置了电荷，这些门就会找到一个平衡点，从而导致o被储存起来。相当酷！</p><p> This circuit is pretty complicated and a bit  hard to understand (3), but we’ve got the power of simulation at our fingertips! Let’s try building it and test it out:</p><p>这个电路相当复杂，有点难懂(3)，但我们对模拟能力了如指掌！让我们尝试构建它并对其进行测试：</p><p> ( defn  wire-memory-bit   &#34;To understand the variables in this circuit,  follow along with the diagram in the tutorial&#34;  ([state s i o]  ( let  [a ( wire   :a )  b ( wire   :b )  c ( wire   :c )]  ( -&gt;  state  ( wire-nand-gate  i s a)  ( wire-nand-gate  a s b)  ( wire-nand-gate  a c o)  ( wire-nand-gate  b o c)))))</p><p>(要理解本电路中的变量，请按照教程中的图表进行操作&#34；([STATE s I o](设[a(wire：a)b(wire：b)c(wire：c)](-&gt；state(wire-NAND-gate i s a)(wire-NAND-gate a s b)(wire-NAND-gate a c)(wire-NAND-gate b o c)。</p><p> Looks so pretty for such a complicated machine. Now the ultimate question…will it work?!</p><p>对于这样一台复杂的机器来说，它看起来真漂亮。现在是终极问题…。它会起作用吗？！</p><p> ( deftest  test-memory-bit  ( let  [s1 ( -&gt;  empty-state  ( wire-memory-bit   :s   :i   :o )  ( trigger-many  [ :i   :s ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :s   1 ))  s3 ( -&gt;  s2  ( trigger-many  [ :s   :i ] [ 0   0 ]))]  ( testing   &#34;turning i on does not affect the rest&#34;  ( is  ( =  &#39;( 0   1   0 ) ( charges  s1 [ :s   :i   :o ]))))  ( testing   &#34;enabling set transfers i to o&#34;  ( is  ( =  &#39;( 1   1   1 )  ( charges  s2 [ :s   :i   :o ]))))  ( testing   &#34;disabling set, removes further effects on o&#34;  ( is  ( =  &#39;( 0   0   1 )  ( charges  s3 [ :s   :i   :o ]))))))</p><p>(Deftest-Memory-Bit(设[S1(-&gt;；Empty-State(Wire-Memory-bit：S：I：O)(Trigger-Memory[：I：S][1 0])S2(-&&gt;S1(Trigger：S 1))S3(-&&gt;S2(Trigger-Many[：S：I][0 0]))](Testing&#34；打开I不会影响其余&#34；(IS(=&#39；(0 1 0)(费用S1[：S：I：O])(测试&#34；启用SET传输I到O&#34；(IS(=&#39；(11 1)(费用S2[：S：I：O])(测试&#34；禁用SET，消除对O&#34；的进一步影响；(IS(=&#39；(001)(费用S3[：S：I：O])。</p><p>    Now that we have a bit, we can take one  s wire and tie 8 memory bits together with it. That would let us  set 8 bits together, which means we can “store” 8 bits of data…which gives us a byte! (5). Here’s how that would look:</p><p>现在我们有了位，我们可以用一根导线将8个内存位捆绑在一起。这将允许我们一起设置8位，这意味着我们可以“存储”8位数据…。这给了我们一个字节！(5)。这看起来是这样的：</p><p>  Note that in our diagram now “two wires together” is short-hand for writing  8 wires.</p><p>请注意，在我们的图表中，“两条导线在一起”是书写8条导线的缩写。</p><p>  ( defn  wire-byte [state s ins outs]  ( reduce  ( fn  [acc-state [i o]]  ( wire-memory-bit  acc-state s i o))  state  ( map  vector ins outs)))</p><p>(定义线字节[状态s INS OUTS](Reduce(fn[acc-state[i o]](Wire-Memory-bit acc-state s i o))状态(映射向量INS OUTS)。</p><p>  To test this out though, we’re going to need a way to “create” a bunch of names for wires. Let’s write a few helper functions that make this easy:</p><p>不过，要测试这一点，我们需要一种方法来为导线“创建”一组名称。让我们编写几个帮助器函数来简化这一过程：</p><p> ( defn  names [n r]  ( mapv  ( fn  [i] ( kw  n  &#34;-&#34;  i)) ( range  r))) ( def  wires ( comp  ( partial  mapv wire) names))</p><p>(定义名称[n r](mapv(fn[i](kw n&#34；-&#34；i))(范围r))(定义焊线(元件(部分mapv焊线)名称))。</p><p>    ( deftest  test-byte  ( let  [ii ( wires   :i   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-byte   :s  ii os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s   0 ))  s2 ( -&gt;  s1  ( trigger   :s   1 ))  s3 ( -&gt;  s2  ( trigger   :s   0 )  ( trigger-many  ii [ 0   0   0   0   0   0   0   1 ]))]  ( testing   &#34;disabling set, removes further effects on o&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;set s, so os become 1 1 1&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;freeze by disabling s. see that further changes to i do nothing to o&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))))</p><p>(Deftest-byte(let[II(wire：I 8)os(wire：O 8)S1(-&gt；Empty-State(wire-byte：S II os)(Trigger-Many II[1 1 0 0 0])(Trigger：S 0))S2(-&gt；S1(Trigger：S 1))S3(-&gt；S2(TRIGGER：S 0)(TRIGGER-MANY II[0 0 0 1])](测试&#34；禁用设置，消除对O&#34；(IS(=&#39；(1 1 0 0 0)(费用S1 II)(IS(=&#39；(0 0 0)(费用s1 os)(测试&#34；设置s，因此os变为1 11&#34；(is(=&#39；(1 1 0 0 0)(费用s2 II)(is(=&#39；(1 1 1 0 0 0)(费用s2 os)(测试&#34；通过禁用S来冻结。请参见对i的进一步更改不会对o&#34；(is(=&#39；(0 0 0 1)(费用S3 II)(is(=&#39；(1 1 1 0 0 0)(费用s2 os)。</p><p>       Notice how the output wires are  shared between  B1 and  B2. If  B1 had a charge of “11110000”, and  B2 had a charge of “0001111”, what would happen to the output wires? It would carry a charge of “1111111”! Say we wanted to make sure  only one of the bytes sent their output charge into  output wires. How could we do that?</p><p>请注意B1和B2之间的输出线是如何共享的。如果B1的电荷是“11110000”，而B2的电荷是“0001111”，那么输出线会发生什么情况？它将携带“1111111”的费用！假设我们想要确保只有一个字节将其输出电荷发送到输出线。我们怎么能这么做呢？</p><p> We’ll need a new machine. Let’s consider what would happen if we took a bunch of  AND gates, and connected them together like this:</p><p>我们需要一台新机器。让我们来考虑一下，如果我们把一串AND门连接在一起会发生什么，就像这样：</p><p>  Now, if the “e” wire is “on”, the output wires are charged with whatever the input wires are. Buut, if the “e” wire is “off”, the output  zeroes out. This machine is called the “enabler”. If we put this together right, we could control what charge gets sent to  output wires!</p><p>现在，如果“e”线是“开”的，那么无论输入线是什么，输出线都会被充电。但是，如果“e”线是“OFF”，则输出为零。这台机器被称为“启动器”。如果我们把这些放在一起，我们就能控制送到输出线的电荷！</p><p>  ( defn  wire-enabler  [state e ins outs]  ( reduce  ( fn  [acc-state [in out]]  ( wire-and-gate  acc-state e in out))  state  ( map  vector ins outs)))</p><p>(Defn Wire-Enabler[State e Ins Out](Reduce(fn[acc-state[In Out]](线栅Acc-State e In Out)状态(贴图向量Ins Out))。</p><p>  ( deftest  test-enabler  ( let  [ii ( wires   :i   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-enabler   :e  ii os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :e   0 ))  s2 ( trigger  s1  :e   1 )  s3 ( trigger  s2  :e   0 )]  ( testing   &#34;is should be set, but os should be 0&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;os should pass if enabled&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;os should revert if disabled&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s3 os))))))</p><p>(Deftest-Enabler(让[II(wire：I 8)os(wire：O 8)S1(-&gt;；Empty-State(wire-Enabler：E II os)(Trigger-Many II[1 1 0 0 0])(Trigger：E 0))S2(Trigger S1：E 1)S3(Trigger S2：E 0)](Testing&#34；is应该设置，但OS应该是0&#34；(IS(=&#39；(1 1 1 0 0 0)(费用S1II)(IS(=&#39；(0 0 0)(费用S1 os)(测试&#34；OS如果启用&#34；((IS(=&#39；(1 1 1 0 0 0)(费用S2 II))(IS(=&#39；(1 1 0 0 0)(费用S2 OS)(测试&#34；OS如果禁用应恢复&#34；(IS(=&#39；(1 1 1 0 0 0)(费用S3 II)(IS(=&#39；(0 0 0)(收费S3 os)。</p><p>    Here’s how we could “fix” our problem with  B1 and  B2:</p><p>下面是我们如何“修复”B1和B2的问题：</p><p>  If we stuck an “enabler” in front of each byte, we could control what gets sent to  output wires. If we wanted to have  B1&#39;s charge, we would “enable  E1”, and make sure  E2 was disabled, and vice versa.</p><p>如果我们在每个字节前面加上一个“启用码”，我们就可以控制发送到输出线的内容。如果我们想让B1充电，我们会“启用E1”，并确保禁用E2，反之亦然。</p><p> This combination of byte and enabler is so common that we can build a machine for that:</p><p>字节和启用码的这种组合非常常见，我们可以为此构建一台机器：</p><p>  It’s called a register! Registers let us both control  what bytes are stored, and  when these bytes are exposed as output.</p><p>这叫收银机！寄存器让我们可以控制存储哪些字节，以及何时将这些字节公开为输出。</p><p> To set this up, all we need to do is to tie together a byte and an enabler:</p><p>要设置它，我们需要做的就是将一个字节和一个启用码绑定在一起：</p><p> ( defn  wire-register [state s e ins bits outs]  ( -&gt;  state  ( wire-byte  s ins bits)  ( wire-enabler  e bits outs)))</p><p>(Defn线寄存器[状态s e ins位输出](-&gt；state(线字节s ins位)(线启用器e位输出)。</p><p> Badabing, badaboom, it should work. This is a pretty important machine, so let’s make darn sure it works:</p><p>巴达宾，巴达博，应该行得通。这是一台非常重要的机器，所以让我们确保它能正常工作：</p><p> ( deftest  test-register  ( let  [ii ( wires   :i   8 )  bs ( wires   :b   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-register   :s   :e  ii bs os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s   0 )  ( trigger   :e   0 ))  s2 ( trigger  s1  :s   1 )  s3 ( trigger  s2  :e   1 )  s4 ( -&gt;  s3  ( trigger   :s   0 )  ( trigger-many  ii [ 0   0   0   0   0   0   0   1 ]))  s5 ( trigger  s4  :e   0 )]  ( testing   &#34;is should be set, but bs and os should be 0, b/c s &amp; e are 0&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;is &amp; bs should be set, as s is on. but os should be 0, b/c e is off&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;is &amp; bs should be set, as s is on. but os should be 0, b/c e is off&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 bs)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 os))))  ( testing   &#34;is should be new v, but bs and os should be the old value&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s4 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s4 bs)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s4 os))))  ( testing   &#34;os should 0 out again&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s5 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s5 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s5 os))))))</p><p>(Deftest-Register(设II(wire：I 8)bs(wire：B 8)os(wire：O 8)s1(-&gt；空状态(线寄存器：S：E II bs os)(触发器多II[1 1 0 0 0])(触发器：S 0)(触发器：E 0)S2(触发器S1：S 1)S3(触发器S2：E 1)S4(-&gt；S3(TRIGGER：S 0)(TRIGGER-MANY II[0 0 0 1])S5(TRIGGER S4：E 0)](测试应该设置，但是bs和os应该是0，b/c s&amp；e是0&#34；(is(=&#39；(1 1 0 0 0)(费用s1 II)(is(=&#39；(0 0 0)(费用s1 bs)(is(=&#39；(0 0 0)(费用s1 os)(测试&34；is&amp；bs应设置，因为s为ON。但操作系统应为0，b/c e为OFF&#34；(is(=&#39；(11 1 0 0 0)(费用S2 II)(is(=&#39；(1 1 0 0 0)(费用S2 bs)(is(=&#39；(1 1 0 0 0)(费用S2 bs)。(0 0 0)(充电s2 os)(测试&34；is&amp；bs应设置，因为s已打开。但操作系统应为0，b/c e为OFF&#34；(is(=&#39；(11 1 0 0 0)(费用S3 II)(is(=&#39；(1 1 0 0 0)(费用S3 bs)(is(=&#39；(1 1 0 0 0)(费用S3 bs))。(1110 000000)(费用S3os)(测试&#34；is应该是新的v，但是bs和os应该是旧值&#34；(is(=&#39；(0000000001)(费用S4ii)(is(=&#39；(0000000001)(费用S4ii)(。(1 1 1 0 0 0)(费用S4 bs))(IS(=&#39；(1 1 0 0 0)(费用S4 os)(测试&#34；OS应再次输出&#34；(IS(=&#39；(0 0 0 1)(费用S5 II)(IS(=&#39；(0 0 0 1)(费用S5 II)(。(1 1 1 0 0 0)(费用S5 bs))(is(=&#39；(0 0 0)(费用S5 os)。</p><p>    Okay, let’s continue our experiment, to an astounding result: what if we connected the inputs  and outputs of a bunch of registers to the  same wires?</p><p>好，让我们继续我们的实验，得出一个令人震惊的结果：如果我们将一组寄存器的输入和输出连接到相同的导线上会怎么样？</p><p>  Now, remember that  s allows us to decide what gets “stored” into a register, and “e” lets us “pass” the charge of a register’s byte  through to the output.</p><p>现在，请记住，s允许我们决定将什么“存储”到寄存器中，而“e”允许我们将寄存器字节的费用“传递”到输出。</p><p> What would happen in the following scenario. Say R1’s byte contains “111”, all  s and  e wires are 0.</p><p>在下面的场景中会发生什么。假设R1的字节包含“111”，所有的s和e线都是0。</p><p> “Charge  R1’s  e to 1”.  Now  R1 would enable, and the  bus wires would carry the same charge as  R1</p><p>“把R1的e充电到1”。现在R1将启用，母线将携带与R1相同的电荷</p><p> “Charge  R3’s  s to 1, then 0”.  This would set the value of  R3, to the current charge flowing in  bus.  This happens to be the output of  R1!</p><p>将R3充电为1，然后充电为0。这会将R3的值设置为流经母线的当前电荷。这恰好是R1的输出！</p><p> “Set  R1&#39;s  e to 0” Now the current in  bus would disappear again</p><p>“Set R1&#s e to 0”(将R1的e设置为0)，此时输入母线的电流将再次消失。</p><p> The result?  The byte in R1 would have been “copied” to R3. We’ve just created a  bus.</p><p>结果是什么呢？R1中的字节将被“复制”到R3。我们刚刚创造了一辆巴士。</p><p> To create a bus, all we need to do is to connect a register’s input and output to the same “bus” wires:</p><p>要创建总线，我们只需将寄存器的输入和输出连接到相同的“总线”导线：</p><p>  This is only a single line, but it’s pretty important to get right. It’s what lets us “copy” registers after all. Let’s see if it works:</p><p>这只是一行代码，但是正确使用是非常重要的。毕竟，这就是让我们“复制”寄存器的东西。让我们看看它是否有效：</p><p> ( deftest  test-wire-bus  ( let  [bw ( wires   :bw   8 )  r1-bits ( wires   :r1   8 )  r2-bits ( wires   :r2   8 )  r3-bits ( wires   :r2   8 )  s1 ( -&gt;  empty-state  ( wire-bus  bw  :s1   :e1  r1-bits)  ( wire-bus  bw  :s2   :e2  r2-bits)  ( wire-bus  bw  :s3   :e3  r3-bits)  ( trigger-many  bw [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s1   0 )  ( trigger   :e1   0 ))  s2 ( -&gt;  s1  ( trigger   :s1   1 )  ( trigger   :s1   0 )  ( trigger-many  bw [ 0   0   0   0   0   0   0   0 ]))  s3 ( -&gt;  s2  ( trigger   :e1   1 )  ( trigger   :s3   1 )  ( trigger   :s3   0 )  ( trigger   :e1   0 ))]  ( testing   &#34;only bus should have charge&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 bw)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r2-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r3-bits))))  ( testing   &#34;r1 should have the charge&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 bw)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r2-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r3-bits))))  ( testing   &#34;move r1 to r3&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s3 bw)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r2-bits)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 r3-bits))))))</p><p>(Deftest-wire-bus(让[BW(WIRES：BW 8)R1-BITS(WIRES：R1 8)R2-BITS(WIRES：R2 8)R3-BITS(WIRES：R2 8)S1(-&gt；空状态(有线总线BW：S1：E1 R1位)(有线总线BW：S2：E2 R2位)(有线总线BW：S3：E3 R3位)(触发器多个BW[1 1 0 0 0])(触发器：S1 0)(触发器：E1 0)S2(-&gt；S1(触发：s1 1)(触发：s1 0)(触发多个带宽[0 0 0]))s3(-&gt；s2(触发：e1 1)(触发：s3 1)(触发：s30)(触发：e1 0)](测试&#34；仅总线应该有电荷&#34；(IS(=&#39；(1 1 1 0 0 0)(电荷S1BW))(IS(=&#39；(0 0 0)(电荷S1 R1比特)(IS(=&#39；(0 0 0)(电荷S1 R2比特)(IS(=&#39；(0 0 0)(电荷S1 R2比特))。(0 0 0)(电荷S1R3比特)(测试&#34；R1应具有电荷&#34；(IS(=&#39；(0 0 0)(电荷S2 BW)(IS(=&#39；(1 1 1 0 0 0)(电荷S2 R1比特)(IS(=&#39；(0 0 0)(电荷S2 R1比特)。(0 0 0(充电S2 R2位)(IS(=&#39；(0 0 0(充电S2 R3位)(测试&#34；将R1移动到R3&34；(IS(=&#39；(0 0 0)(充电S3BW)(IS(=&#39；(1 1 1 0 0 0)(电荷S3 R1位))(IS(=&#39；(0 0 0)(电荷S2 R2位)(IS(=&#39；(1 1 1 0 0 0)(电荷S3 R3位)。</p><p>      Remember that the  bus wires can “receive” a charge now from the outputs of  R1 ,  R2, or  R3. Here’s how our  set-charge looked:</p><p>请记住，母线现在可以从R1、R2或R3的输出端“接收”电荷。我们的套装炸药看起来是这样的：</p><p>  Imagine if  R1 was enabled and a wire was charged to  1. What would happen if  R3 got triggered?</p><p>想象一下，如果R1被启用，一根电线充电为1。如果R3被触发，会发生什么情况？</p><p>  Time to to evolve our model. One way to think</p><p>是时候发展我们的模式了。一种思考方式。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/258">https://stopa.io/post/258</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/模拟/">#模拟</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ram/">#ram</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/电荷/">#电荷</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033976.html"><img src="http://img2.diglog.com/img/2020/11/thumb_95396440dfb0857f21b03a6688277eef.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033976.html">模拟流体的有趣网站</a></div><span class="my_story_list_date">2020-11-9 12:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031665.html"><img src="http://img2.diglog.com/img/2020/10/thumb_54170c7b87208396b2410f838de3120e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031665.html">我们生活在模拟中吗？几率大约是50%</a></div><span class="my_story_list_date">2020-10-28 8:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029958.html"><img src="http://img2.diglog.com/img/2020/10/thumb_29462690e0c5aab8f1750c80206ff0d1.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029958.html">模拟问题的增加</a></div><span class="my_story_list_date">2020-10-20 12:35</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028664.html"><img src="http://img2.diglog.com/img/2020/10/thumb_54170c7b87208396b2410f838de3120e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028664.html">我们生活在模拟中吗？几率大约是50%</a></div><span class="my_story_list_date">2020-10-14 8:24</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>