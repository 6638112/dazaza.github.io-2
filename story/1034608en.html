<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>铁锈编译程序的PGO探索</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">铁锈编译程序的PGO探索</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 02:30:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/10c030b2429f801a5aed8756bdece9d2.jpg"><img src="http://img2.diglog.com/img/2020/11/10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>TLDR -- PGO makes the compiler  faster but is  not straightforward to realize in CI.</p><p>TLDR--PGO使编译器速度更快，但在CI中实现起来并不简单。</p><p> For the last few months Mozilla has been using Profile-Guided Optimization (PGO) to build their own  optimized version of Clang, leading to an up to 9% reduction of Firefox compile times on their build infrastructure.Would the same be possible for the Rust compiler, that is, could we apply profile-guided optimization to  rustc itself in order to make it faster?This post explores exactly this question, detailing first the steps needed for generating a PGOed versions of  rustc (in two flavors), and then taking a look at the resulting performance implications.But before that let&#39;s have a little reminder what PGO even is and how it works in general.</p><p>在过去的几个月里，Mozilla一直在使用概要引导优化(PGO)来构建他们自己的优化版本Clang，这使得他们的构建基础设施上的Firefox编译时间减少了9%。Rust编译器是否也有同样的可能，也就是说，我们是否可以对rustc本身应用概要引导优化以使它更快呢？这篇文章正是探讨了这个问题，首先详细介绍了生成一个PGOed版本的rustc(有两种风格)所需的步骤，然后来看一下。</p><p>   The basic concept of PGO is to collect data about the typical execution of a program (e.g. which branches it is likely to take) and then use this data to inform optimizations such as inlining, machine-code layout, register allocation, etc.</p><p>PGO的基本概念是收集有关程序典型执行的数据(例如，它可能采用哪些分支)，然后使用这些数据通知优化，如内联、机器代码布局、寄存器分配等。</p><p> There are different ways of collecting data about a program&#39;s execution. One is to run the program inside a profiler (such as perf) and another is to create an instrumented binary, that is, a binary that has data collection built into it, and run that. The latter usually provides more accurate data and it is also what is supported by  rustc.</p><p>收集有关程序执行情况的数据有不同的方式。一种方法是在分析器(如perf)中运行程序，另一种方法是创建仪表化的二进制文件，即内置了数据收集的二进制文件，然后运行该程序。后者通常提供更准确的数据，也是rustc支持的。</p><p> In other words, we first generate a special, &#34;instrumented&#34; version of the program we want to optimize, and then use this instrumented version to generate an execution profile.This execution profile is then used by the compiler for better optimizing the actual, final version of the program.</p><p>换句话说，我们首先生成要优化的程序的一个特殊的指令插入版本，然后使用该指令插入版本生成执行配置文件。然后，编译器使用该执行配置文件来更好地优化程序的实际最终版本。</p><p>  Generating a PGOed version of  rustc involves the same basic steps as it does for any other kind of program:</p><p>生成pgoed版本的rustc所涉及的基本步骤与生成任何其他类型的程序相同：</p><p> Use the instrumented version of  rustc in order to collect profile data, i.e. compile a bunch of programs with it, ideally in a way that represents the typical use cases of the compiler.</p><p>使用Rustc的仪表化版本来收集配置文件数据，也就是用它编译一堆程序，最好是以一种代表编译器典型用例的方式。</p><p> Compile the final version of  rustc, this time pointing the build system to the profile data we generated in the previous step.</p><p>编译rustc的最终版本，这一次将构建系统指向我们在上一步中生成的概要数据。</p><p> However, as opposed to many other programs,  rustc is a bit of a special case because it consists of two very large chunks of code written in different programming languages: the LLVM backend (written in C++) and the front and middle parts of the compiler (written in Rust).Consequently, there are also two separate compilers involved in building  rustc -- both of which support their own version of PGO.This complicates things slightly but fortunately the PGO setup for each of the two components can be treated in isolation.Let&#39;s take a look at the LLVM part first, since that is slightly simpler.</p><p>然而，与许多其他程序不同的是，rustc是一个有点特殊的情况，因为它由两个用不同编程语言编写的非常大的代码块组成：LLVM后端(用C++编写)和编译器的前端和中间部分(用Rust编写)。因此，构建rustc还涉及两个独立的编译器--它们都支持各自版本的PGO。这使得事情稍微复杂一些，但幸运的是，这两个组件的PGO设置可以单独处理。</p><p>  PGO is a toolchain specific feature, so how it works might be different for different C++ compilers.In this article I will only go into how it works with Clang because (a) I have no experience with PGO in other compilers, and (b) Clang is what the Rust project actually uses in production.</p><p>PGO是一个特定于工具链的特性，因此对于不同的C++编译器，它的工作方式可能会有所不同。在本文中，我将只讨论它是如何使用Clang的，因为(A)我没有在其他编译器中使用PGO的经验，(B)Clang是Rust项目在生产中实际使用的。</p><p> In order to enable PGO for rustc&#39;s LLVM we basically follow the steps laid out in the previous section.</p><p>为了为Rustc的LLVM启用PGO，我们基本上遵循上一节中列出的步骤。</p><p> We make sure that our LLVM gets instrumented by applying the following changes to the  config.toml file in the root directory of our Rust checkout:</p><p>我们通过对Rust签出根目录中的config.toml文件应用以下更改来确保我们的LLVM得到检测：</p><p> [llvm]# Pass extra compiler and linker flags to the LLVM CMake build.# &lt;PROFDATA_DIR&gt; must be an absolute path to a writeable# directory, like for example /tmp/my-rustc-profdatacflags = &#34;-fprofile-generate=&lt;PROFDATA_DIR&gt;&#34;cxxflags = &#34;-fprofile-generate=&lt;PROFDATA_DIR&gt;&#34;# Make sure that LLVM is built as a dyliblink-shared = true# Make sure we use Clang for compiling LLVM# (assuming that we are building for x86_64 Linux in this case)[target.x86_64-unknown-linux-gnu]cc = &#34;clang&#34;cxx = &#34;clang++&#34;linker = &#34;clang&#34;</p><p>[llvm]#将额外的编译器和链接器标志传递给LLVM CMake内部版本。#&lt；PROFDATA_DIR&&gt;必须是指向可写目录的绝对路径，例如/tmp/my-rustc-Profdatacflag=&#34；-fprofile-generate=&lt；PROFDATA_DIR&gt；&#34；cxxflags=&#34；-fprofile-generate=&lt；PROFDATA_DIR&gt；&#34；#确保LLVM构建为dyliblink-Shared=true#确保我们使用Clang编译LLVM#(假设我们是为x86_64 Linux构建的)[target.x86_64-未知-Linux-gnu]cc=&#34；clang&#34；cxx=&#34；linker=&#34；clang&#34；clang&#34；</p><p> The  -fprofile-generate flag tells Clang to create an instrumented binary that will write any profile data it generates to the given directory.It is advisable to always use an absolute path here since we don&#39;t want things to depend on the working directory of the compiler.We also set  link-shared = true which makes sure that  rustc&#39;s linker does not have to deal with linking the instrumentation runtime into C++ code.It&#39;s possible to make that work but it&#39;s not worth the trouble.Now we just need to run  ./x.py build and wait until we have a working  rustc with an instrumented LLVM.</p><p>-fprofile-Generate标志告诉Clang创建一个检测的二进制文件，将其生成的任何配置文件数据写入给定的目录。建议始终使用绝对路径，因为我们不希望一切依赖于编译器的工作目录。我们还设置了link-Shared=TRUE，以确保Rustc的链接器不必处理将检测运行时链接到C++代码的问题。这是可以实现的，但是。现在我们只需要运行./x.py构建，并等待我们有一个带指令插入的LLVM的有效rustc。</p><p> Next we collect profile data by running the compiler we built in the previous step.This is straightforward because data collection happens completely transparently.Just run the compiler as you always would (e.g. via Cargo) and the profile data will show up in the  &lt;PROFDATA_DIR&gt; we specified in the  -fprofile-generate flag above.In order to make the collected data as useful as possible, we should try to exercise all the common code paths within the compiler.I typically use the &#34;standard&#34;  rustc-perf benchmark suite for this purpose, which includes debug builds, optimized builds, check builds, both incremental and non-incremental.After this is done, you will find a number of  .profraw files in  &lt;PROFDATA_DIR&gt;. As described in the Clang user manual these  .profraw files need to be merged into a single  .profdata file by using the  llvm-profdata tool that comes with your Clang installation:</p><p>接下来，我们通过运行在上一步中构建的编译器来收集配置文件数据。这很简单，因为数据收集是完全透明的。只需像往常一样运行该编译器(例如，通过货物)，配置文件数据就会显示在我们在上面的-fprofile-Generate标志中指定的&lt；PROFDATA_DIR&&gt;；中。为了使收集的数据尽可能有用，我们应该尝试执行编译器中的所有公共代码路径。I通常使用&#34；标准&#。用于此目的的rustc-perf基准测试套件，包括调试版本、优化版本、检查版本(增量和非增量版本)。完成此操作后，您将在&lt；PROFDATA_DIR&gt；中找到许多.profraw文件。如Clang用户手册中所述，需要使用Clang安装附带的llvm-Profdata工具将这些.profraw文件合并为一个.Profdata文件：</p><p> Now that the combined profile data from all  rustc invocations can be found in  &lt;PROFDATA_DIR&gt;/rustc-llvm.profdata it is time to re-compile LLVM and  rustc again, this time instructing Clang to make use of this valuable new information.To this end we modify  config.toml as follows:</p><p>现在可以在&lt；PROFDATA_DIR&gt；/rustc-llvm.Profdata中找到所有rustc调用的组合配置文件数据，是时候重新编译LLVM和rustc了，这一次指示Clang利用这个有价值的新信息。为此，我们修改了config.toml，如下所示：</p><p>  Now we make sure that LLVM is properly rebuilt by deleting the old version and build everything again:</p><p>现在，我们通过删除旧版本并重新构建所有内容来确保正确重建LLVM：</p><p>  As mentioned above Firefox build times have improved by up to 9% with a PGOed compiler.Clang&#39;s own documentation even  reports an up to 20% improvement.The best way we have for assessing the Rust compiler&#39;s performance is the  rustc-perf benchmark suite.Since compiling with PGO does not quite fit with how the Rust project&#39;s CI works, we cannot use the  perf.rust-lang.org version of the benchmark suite.Fortunately, thanks to  good documentation, running the benchmarks locally is straightforward enough.Here&#39;s a glance at the effect that a PGOed LLVM has on  rustc&#39;s performance:</p><p>如上所述，使用PGOed编译器，Firefox的构建时间缩短了9%。Clang自己的文档甚至报告了20%的改进。我们评估Rust编译器性能的最好方法是rustc-perf基准测试套件。由于使用PGO编译不太符合Rust项目的CI的工作方式，我们不能使用Perf.rust-lang.org版本的基准测试套件。幸好，由于性能良好，我们不能使用Perf.rust-lang.org版本的基准测试套件。由于性能良好，我们无法使用Perf.rust-lang.org版本的基准测试套件。幸运的是，由于性能良好，使用PGO进行编译与Rust项目的CI的工作方式不太匹配，所以我们不能使用Perf.rust-lang.org版本的基准测试套件。让我们来看一看PGOed LLVM对Rustc性能的影响：</p><p>  The results are not quite as spectacular as the anecdotal 20% improvement from Clang&#39;s documentation;but they are pretty encouraging and show no significant performance regressions.Diving more into details shows the expected profile:</p><p>这一结果并不像Clang文档中传闻的20%的改进那样惊人，但也相当鼓舞人心，也没有表现出明显的性能倒退。深入到更多的细节中可以看到预期的情况：</p><p>  Workloads that spend most of their time in LLVM (e.g. optimized builds) show the most improvement, while workloads that don&#39;t invoke LLVM at all (e.g. check builds) also don&#39;t profit from a faster LLVM.Let&#39;s take a look at how we can take things further by applying PGO to the other half of the compiler.</p><p>在LLVM中花费大部分时间的工作负载(例如优化的版本)会显示出最大的改进，而根本不调用LLVM的工作负载(例如检查版本)也不会从更快的LLVM中获益。让我们来看看如何通过将PGO应用到编译器的另一半来进一步提高性能。</p><p>  The basic principle stays the same:create an instrumented compiler, use it to collect profile data, use that data when compiling the final version of the compiler.The only difference is that this time we instrument a different part of the compiler&#39;s code, namely the part generated by  rustc itself.The compiler has had support for doing that  for a while now and, as can be seen in the  respective chapter of the rustc book, the command-line interface has been modeled after Clang&#39;s set of flags.Unfortunately, the compiler&#39;s build system does not support using PGO out of the box, so we have to directly modify  src/bootstrap/compile.rs in order to set the desired flags.We only want to instrument the compiler itself, not the other tools or the standard library, see we add the flags to  rustc_cargo_env():</p><p>基本原则保持不变：创建一个插装的编译器，使用它来收集配置文件数据，并在编译最终版本的编译器时使用这些数据。唯一的区别是，这次我们插装的是编译器代码的不同部分，即由Rustc本身生成的部分。现在，编译器已经支持这一点一段时间了，正如在Rustc书的相应章节中所看到的那样，命令行界面是仿照Clang的一组标志来设计的。不幸的是，该编译器已经支持这样做了一段时间了，正如在Rustc书的相应章节中所看到的那样，命令行界面是仿照Clang的一组标志来设计的。不幸的是，该编译器已经支持了这一点。的构建系统不支持开箱即用的pgo，因此我们必须直接修改src/bootstrap/pile.rs以设置所需的标志。我们只想检测编译器本身，而不是其他工具或标准库，请参见我们将标志添加到rustc_Cargo_env()：</p><p> pub fn rustc_cargo_env(builder: &amp;Builder&lt;&#39;_&gt;, cargo: &amp;mut Cargo, target: TargetSelection) { // ... omitted ... if builder.config.rustc_parallel { cargo.rustflag(&#34;--cfg=parallel_compiler&#34;); } if builder.config.rust_verify_llvm_ir { cargo.env(&#34;RUSTC_VERIFY_LLVM_IR&#34;, &#34;1&#34;); } // This is new: Hard code instrumentation in the // RUSTFLAGS of the Cargo invocation that builds // the compiler cargo.rustflag(&#34;-Cprofile-generate=&lt;PROFDATA_DIR&gt;&#34;); // ... omitted ...}</p><p>Pub FN rustc_Cargo_env(建筑商：&amp；Builder&lt；，货物：&amp；mut Cargo，目标：TargetSelection){//...。省略了..。If Builder.config.rustc_Parallel{cargo.rustflag(&#34；--cfg=parallel_compiler&#34；)；}if Builder.config.rust_Verify_llvm_ir{cargo.env(&#34；RUSTC_Verify_LLVM_IR&#34；，&#34；1&#34；)；}//这是新的：生成//编译器cargo.rustflag(&#34；-Cprofile-generate=&lt；PROFDATA_DIR&gt；&#34；)；的Cargo调用的//RUSTFLAGS中的硬编码指令插入。//...。省略...}。</p><p> As before  &lt;PROFDATA_DIR&gt; must be an actual, absolute path to a directory.Once we have collected enough profile data, we go back to  src/bootstrap/compile.rs and replace the  -Cprofile-generate flag with a  -Cprofile-use flag:</p><p>与前面一样，&lt；PROFDATA_DIR&gt；必须是指向目录的实际绝对路径。一旦我们收集了足够的配置文件数据，我们就返回到src/bootstrap/pile.rs，并将-Cprofile-Generate标志替换为-Cprofile-use标志：</p><p> pub fn rustc_cargo_env(builder: &amp;Builder&lt;&#39;_&gt;, cargo: &amp;mut Cargo, target: TargetSelection) { // ... omitted ... if builder.config.rustc_parallel { cargo.rustflag(&#34;--cfg=parallel_compiler&#34;); } if builder.config.rust_verify_llvm_ir { cargo.env(&#34;RUSTC_VERIFY_LLVM_IR&#34;, &#34;1&#34;); } // Replace `-Cprofile-generate` with `-Cprofile-use`, // assuming that we used the `llvm-profdata` tool to // merge the collected `&lt;PROFDATA_DIR&gt;/*.profraw` files // into a common file named // `&lt;PROFDATA_DIR&gt;/rustc-rust.profdata`. cargo.rustflag( &#34;-Cprofile-use=&lt;PROFDATA_DIR&gt;/rustc-rust.profdata&#34; ); // ... omitted ...}</p><p>Pub FN rustc_Cargo_env(建筑商：&amp；Builder&lt；，货物：&amp；mut Cargo，目标：TargetSelection){//...。省略了..。If builder.config.rustc_parally{cargo.rustflag(&#34；--cfg=parallel_compiler&#34；)；}if builder.config.rust_Verify_llvm_ir{cargo.env(&#34；RUSTC_Verify_LLVM_IR&#34；，&#34；1&#34；)；}//将`-CProfile-Generate`替换为`-CProfile-use`，//假设我们使用了`llvm-Profdata`工具对采集到的`&lt；PROFD`进行了//合并。/*.profraw`文件//放入名为//`&lt；PROFDATA_DIR&gt；/rustc-rust.Profdata`的公共文件中。Cargo.rustflag(&#34；-Cprofile-use=&lt；PROFDATA_DIR&gt；/rustc-rust.profdata&#34；)；//...。省略...}</p><p> Let&#39;s take a look at the effects PGO has on this portion of the compiler.</p><p>让我们来看看PGO对这部分编译器的影响。</p><p>  As expected the results are similar to when PGO was applied to LLVM: a reduction of instruction counts by roughly 5%. NOTE: These numbers show the improvement from applying PGO  exclusively to the Rust part of the compiler. The LLVM part was  not compiled with PGO here:</p><p>正如预期的那样，结果与将PGO应用于LLVM时类似：指令计数减少了大约5%。注意：这些数字显示了将PGO专门应用于编译器的Rust部分所带来的改进。LLVM部分不是使用PGO编译的，如下所示：</p><p>  Because different workloads execute different amounts of Rust code (vs C++/LLVM code), the total reduction can be a lot less for LLVM-heavy cases.For example, a full  webrender-opt build will spend more than 80% of its time in LLVM, so reducing the remaining 20% by 5% can only reduce the total number by 1%.On the other hand, a  check build or an  incr-unchanged build spends almost no time in LLVM, so the 5% Rust performance improvement translates almost entirely into a 5% instruction count reduction for these cases:</p><p>由于不同的工作负载执行不同数量的Rust代码(与C++/LLVM代码相比)，因此对于LLVM繁重的情况，总的减少可能要少得多。例如，完整的webrender-opt构建将在LLVM上花费超过80%的时间，因此将剩余20%的时间减少5%只能减少1%的总数。另一方面，检查构建或增量未改变的构建在LLVM中几乎不花费时间，因此5%的Rust性能改进可以转化为。</p><p>   The short answer is  yes.The longer answer is that we have to be careful about profile data incompatibilities.Both Clang and the Rust compiler use the same LLVM-based PGO mechanisms underneath.If both Clang and the Rust compiler use the exact same version of LLVM, we can even combine the two into a single  .profdata file.However, if the two LLVM versions are different, we better make sure that the two compilers don&#39;t get into each other&#39;s way.Luckily it&#39;s straightforward to facilitate that:</p><p>简而言之，答案是肯定的。更长远的答案是，我们必须注意配置文件数据的不兼容性。Clang和Rust编译器在底层都使用相同的基于LLVM的PGO机制。如果Clang和Rust编译器使用完全相同的LLVM版本，我们甚至可以将两者合并为一个.Profdata文件。但是，如果两个LLVM版本不同，我们最好确保这两个编译器不会互相干扰。</p><p> We need to specify different directories for the respective  -fprofile-generate and  -Cprofile-generate (and  *-use) flags.This way the instrumentation code coming from Clang will write into one directory and the code coming from  rustc will write into another.</p><p>我们需要为各自的-fprofile-Generate和-Cprofile-Generate(和*-use)标志指定不同的目录。这样，来自Clang的检测代码将写入一个目录，而来自rustc的代码将写入另一个目录。</p><p> We need to make sure that we use the right  llvm-profdata tool for each set of  .profraw files.Use the one coming with Clang for handling the files in the Clang directory and the one coming with the Rust compiler for the files in the Rust directory.</p><p>我们需要确保为每组.profraw文件使用正确的llvm-Profdata工具。使用Clang附带的工具处理Clang目录中的文件，使用Rust编译器附带的工具处理Rust目录中的文件。</p><p> If we do that, we get a compiler with both parts optimized via PGO, with the compile time reductions adding up nicely.</p><p>如果我们这样做，我们将得到一个通过PGO优化了这两个部分的编译器，编译时间的减少也很不错。</p><p>  When I looked at the  the final numbers, I was a bit underwhelmed.Sure, PGO seems to lead to a pretty solid 5% reduction of instruction counts across basically all real world workloads in the benchmark suite, for  check,  debug, and  opt builds alike.That is pretty nice -- but also far away from the 20% improvement mentioned in the Clang documentation.Given that PGO adds quite a few complications to the build process of the compiler itself (not to mention the almost tripled build times) I started to think that applying PGO to the compiler would probably not be worth the trouble.</p><p>当我看到最终的数字时，我有点失望。当然，PGO似乎导致基准测试套件中几乎所有实际工作负载的指令计数减少了5%，这与检查、调试和OPT构建类似。这相当不错--但与Clang文档中提到的20%的改进相去甚远。考虑到PGO给编译器本身的构建过程增加了相当多的复杂性(更不用说几乎三倍的构建时间)，我开始考虑应用</p><p> I then took a glance at the benchmarks&#39; wall time measurements (instead of the instruction count measurements) and saw quite a different picture:  webrender-opt minus 15%,  style-servo-opt minus 14%,  serde-check minus 15%?This looked decidedly better than for instruction counts.But wall time measurements can be very noisy (which is why most people only look at instruction counts on perf.rust-lang.org), and  rustc-perf only does a single iteration for each benchmark, so I was not prepared to trust these numbers just yet.I decided to try and reduce the noise by increasing the number of benchmark iterations from one to twenty.I only did &#34;full&#34; builds in this configuration as PGO&#39;s effect seemed to translate pretty predictably to incremental builds.After roughly eight hours to complete both the PGO and the non-PGO versions of the benchmarks these are the numbers I got:</p><p>然后，我扫了一眼基准&#39；墙时间测量(而不是指令计数测量)，看到的是完全不同的画面：webrender-opt减15%，style-servic-opt减14%，serde-check减15%？这看起来显然比指令计数要好。但是墙时间测量可能非常嘈杂(这就是为什么大多数人只在Perf.rust-lang.org上查看指令计数)，并且rustc-perf只对每个基准进行一次迭代。所以我还没有准备好相信这些数字。我决定试着把基准测试的迭代次数从1次增加到20次，以减少噪音。我只做了#34；由于PGO的影响，这种配置下的完整构建似乎可以很好地转化为增量构建。大约8小时后，我完成了PGO和非PGO版本的基准测试，以下是我得到的数据：</p><p>  As you can see we get a 10-16% reduction of build times almost across the board for real world test cases.This was more in line with what I had initially hoped to get from PGO.It is a bit surprising that the difference between instruction counts and wall time is so pronounced.One plausible explanation would be that PGO improves instruction cache utilization, something which makes a difference for execution time but would not be reflected in the amount of instructions executed.I also don&#39;t know how branch mispredictions factor into instruction counts -- branch prediction being another aspect explicitly targeted by PGO.</p><p>正如你所看到的，在真实世界的测试案例中，我们几乎全面减少了10%-16%的构建时间。这更符合我最初希望从PGO获得的结果。指令计数和挂起时间之间的差异如此明显，这有点令人惊讶。一个看似合理的解释是，PGO提高了指令高速缓存的利用率，这对执行时间有影响，但不会反映在执行的指令量上。我也不知道分支错误预测是如何影响指令计数-分支预测的。</p><p> As good as these numbers look, please keep in mind that they come from a single machine.It&#39;s possible that the Ryzen 1700X processor I used has some idiosyncrasies that favor the kind of optimizations that PGO does, and a different processor with a different caching system and branch predictor would generate quite different numbers.Nonetheless, the numbers undoubtedly are very encouraging and warrant further investigation.</p><p>尽管这些数字看起来不错，但请记住，它们来自同一台机器。我使用的Ryzen 1700X处理器可能具有一些特性，支持PGO所做的那种优化，而具有不同缓存系统和分支预测器的不同处理器将生成完全不同的数字。尽管如此，这些数字无疑是非常令人鼓舞的，值得进一步研究。</p><p>  The numbers above suggest that PGO can indeed provide noticeable compile time reductions.Unfortunately, bringing these improvements to end users is not as simple as adding a few compiler flags to our  dist builds.PGO is different from most other optimizations in that it</p><p>以上数字表明，PGO确实可以提供显著的编译时间减少。不幸的是，将这些改进带给最终用户并不像在dist构建中添加几个编译标志那么简单。PGO与大多数其他优化的不同之处在于它。</p><p> requires a different, extended build workflow due to the additional instrumentation and data collection phases, and</p><p>由于额外的检测和数据收集阶段，需要不同的、扩展的构建工作流，以及。</p><p> it incurs a sustained build time cost (a trait it shares with other automated optimizations like LTO).</p><p>它会带来持续的构建时间成本(这是它与其他自动化优化(如LTO)的共同特征)。</p><p> Both of these problems pose substantial hurdles for actually using PGO on the compiler itself.Rust&#39;s CI build times have always been too long and we already forgo some optimizations because of them(e.g. macOS still does not get the 10% performance boost from using a ThinLTOed LLVM because the build machines on that platform are especially slow).However, I think there&#39;s still a way forward. There&#39;s a tradeoff between the two obstacles mentioned above:</p><p>这两个问题都对在编译器本身上实际使用PGO造成了很大的障碍。Rust的CI构建时间一直太长，因此我们已经放弃了一些优化(例如，MacOS仍然不能从使用ThinLTOed LLVM中获得10%的性能提升，因为该平台上的构建机器特别慢)。但是，我认为仍有一条路要走。在上面提到的两个障碍之间有一个权衡：</p><p> If build times are not a problem, then the engineering effort for supporting PGO in the compiler&#39;s build system is quite low.That is, if it is OK for instrumentation, data collection, and final build to all occur as a single monolithic build on the same machine then it should be straightforward to extend the build system to support just that.</p><p>如果构建时间不是问题，那么在编译器的构建系统中支持PGO的工程工作量就相当低。也就是说，如果检测、数据收集和最终构建都作为单一的构建出现在同一台机器上，那么扩展构建系统来支持这一点应该是直截了当的。</p><p> If a lot of engineering effort is put into a more complicated build setup, with out-of-band instrumentation and caching of profile data, then the impact on build times can be kept quite low.</p><p>如果将大量工程工作投入到更复杂的构建设置中，使用带外检测和配置文件数据缓存，则对构建时间的影响可以保持在相当低的水平。</p><p> I estimate that the first approach is more fruitful, as it is always better to put more value on low engineering and maintenance costs than on low compute times.Having a straightforward way of obtaining a PGOed compiler (e.g. by adding a simple setting in  config.toml) would unblock the path to a couple of scenarios:</p><p>我估计第一种方法更有成效，因为低工程和维护成本总是比低计算时间更有价值。拥有一种获得PGOed编译器的直接方法(例如，通过在config.toml中添加一个简单的设置)将打开通向以下几个场景的道路：</p><p> Organizations and individuals who don&#39;t switch compiler versions too frequently can easily compile their own, optimized version of  rustc for internal use, like Mozilla is already doing with Clang.Letting a computer spend a couple of hours in order to get a 15% compile time reduction for the next couple of months seems like a good investment.</p><p>不频繁切换编译器版本的组织和个人可以很容易地编译自己的Rustc优化版本以供内部使用，就像Mozilla已经在使用Clang所做的那样。让一台计算机花费几个小时以便在接下来的几个月内减少15%的编译时间似乎是一项不错的投资。</p><p> The Rust project itself could start thinking about providing more optimized builds, at least on the beta and stable channels.Significantly increasing the compiler&#39;s build times on the official build infrastructure is a lot more viable if it only has to be done every six weeks instead of for every merged pull request.</p><p>Rust项目本身可以开始考虑提供更优化的构建，至少在测试版和稳定的渠道上是这样。如果只需要每六周完成一次，而不是针对每个合并的拉请求，那么显著增加编译器在官方构建基础设施上的构建时间将更加可行。</p><p> It&#39;s unlikely that I can spend a lot of time on this personally -- but my hope is that others will pick up the baton. I&#39;d be happy to provide guidance on how to use PGO specifically.</p><p>我不太可能在这件事上花很多时间--但我希望其他人能接过接力棒。我很乐意就如何具体使用PGO提供指导。</p><p> PS -- Special thanks to Mark Rousskov for uploading my local benchmarking data to  perf.rust-lang.org, which makes it much nicer to explore!</p><p>PS--特别感谢Mark Rousskov将我本地的基准测试数据上传到Perf.rust-lang.org，这使它更便于探索！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler">https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译程序/">#编译程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pgo/">#pgo</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034437.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d8a50e934080e1cb6b2fa8ece56296f9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034437.html">使用Rust为1100万并发用户扩展Elixir</a></div><span class="my_story_list_date">2020-11-11 8:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034383.html"><img src="http://img2.diglog.com/img/2020/11/thumb_13adc774d7220747f1b03cc994ede446.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034383.html">InfluxDB将赌注押在Rust和Apache Arrow的下一代数据存储上</a></div><span class="my_story_list_date">2020-11-11 4:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034269.html"><img src="http://img2.diglog.com/img/2020/11/thumb_524109d84e42d6e5e81376458a2dafa9.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034269.html">亚马逊因使用商家数据而面临欧盟反垄断指控：来源</a></div><span class="my_story_list_date">2020-11-10 22:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034264.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1eb6a76bdc96a6c7ea176671840feb7e.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034264.html">欧盟就亚马逊使用数据提起反垄断诉讼</a></div><span class="my_story_list_date">2020-11-10 22:20</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>