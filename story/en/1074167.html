<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>压缩SQLite的性能：解释虚拟机Squeezing Performance from SQLite: EXPLAINing the Virtual Machine</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Squeezing Performance from SQLite: EXPLAINing the Virtual Machine<br/>压缩SQLite的性能：解释虚拟机</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 11:25:10</div><div class="page_narrow text-break page_content"><p>The virtual machine? Yep, but not the Java Virtual Machine. In this post I will focus on providing you with a basic understanding SQLite’s “Virtual DataBase Engine” or VDBE.</p><p>虚拟机？是的，但不是Java虚拟机。在本文中，我将重点为您提供对SQLite的“虚拟数据库引擎”或VDBE的基本了解。</p><p>  My “Squeezing Performance from SQLite” series is primarily meant for Android engineers, but this post in particular will dive into SQLite itself and the topics discussed will hold true for all developers who use it.</p><p>我的“从SQLite挤压性能”系列主要是为Android工程师设计的，但这篇文章将特别深入到SQLite本身，讨论的主题对所有使用它的开发人员都适用。</p><p>  I used to be under the impression that SQLite parsed and ran statements like an interpreter, but it turns out that’s not quite the case. While looking for SQLite’s version of MySQL’s  EXPLAIN, I stumbled across documentation that described the way SQLite operates:</p><p>我以前的印象是SQLite像解释器一样解析和运行语句，但事实并非如此。在寻找SQLite版本的MySQL的EXPLAIN时，我偶然发现了描述SQLite操作方式的文档：</p><p> SQLite works by translating SQL statements into bytecode and then running that bytecode in a virtual machine. —  SQLite.org</p><p>SQLite的工作原理是将SQL语句转换为字节码，然后在虚拟机中运行该字节码。-SQLite。组织</p><p> The SQLite virtual machine is called the “Virtual DataBase Engine”, or the “VDBE” for short.</p><p>SQLite虚拟机被称为“虚拟数据库引擎”，简称“VDBE”。</p><p>  You might already know what a bytecode program in SQLite more commonly goes by: “prepared statement”. Also, just like most programs: prepared statements can take input ( ? variables).</p><p>您可能已经知道SQLite中字节码程序更常见的说法是：“prepared statement”。此外，就像大多数程序一样：准备好的语句可以接受输入（？变量）。</p><p> The bytecode program is a binary listing of instructions which each consist of an opcode and parameter values. Each opcode corresponds to a particular command that the VDBE knows how to process, and when being processed can operate on data contained within a bank of registers within the virtual machine. According to the official documentation, the number of registers is finite  but can be quite large and depends on how SQLite was configured at compile time.</p><p>字节码程序是一个二进制指令列表，每个指令由一个操作码和参数值组成。每个操作码对应于VDBE知道如何处理的特定命令，并且在处理时可以对虚拟机中寄存器组中包含的数据进行操作。根据官方文档，寄存器的数量是有限的，但可能相当大，这取决于SQLite在编译时的配置方式。</p><p> In the remainder of this article we’ll explore how SQL statements are processed by SQLite into bytecode programs, and then I’ll show you how you can examine the bytecode  your statements get compiled into.</p><p>在本文的剩余部分中，我们将探索SQLite如何将SQL语句处理成字节码程序，然后我将向您展示如何检查语句编译成的字节码。</p><p>  When you ask SQLite to prepare a statement, your painstakingly handcrafted SQL is dissected (parsed), analyzed (query planned), and boiled down (compiled) into a bytecode program SQLite’s VDBE is capable of executing.</p><p>当您要求SQLite准备一条语句时，您精心编制的SQL将被分解（解析）、分析（计划查询），并分解（编译）为SQLite的VDBE能够执行的字节码程序。</p><p>  Just like any programming language, SQL starts as a bunch of text. To get from a string of text into something SQLite can understand, that text needs to be broken down and understood. This is what we call parsing.</p><p>就像任何编程语言一样，SQL从一堆文本开始。要从一个文本字符串中获取SQLite可以理解的内容，需要对该文本进行分解和理解。这就是我们所说的解析。</p><p> SQLite’s parsing approach is made abundantly clear throughout the  official documentation. For example, if you’ve ever ended up at sqlite.org while looking for how you are supposed to write an INSERT statement — you’ve likely seen a diagram that explains a part of how SQLite’s parser works:</p><p>SQLite的解析方法在整个官方文档中都非常清楚。例如，如果你曾经在sqlite工作过。org在寻找如何编写INSERT语句时，您可能已经看到了一个图表，其中解释了SQLite解析器的部分工作原理：</p><p>  Diagrams like the one above are a way of  visualizing the  Backus-Naur Form (BNF) description of the SQL grammar that SQLite understands. Reading the syntax diagrams is a pretty straightforward process when you know what to look for:</p><p>像上面这样的图表是一种可视化SQLite理解的SQL语法的Backus Naur Form（BNF）描述的方法。当您知道要查找什么时，阅读语法图是一个非常简单的过程：</p><p> Ovals with  lower-case-and-hypenated text represent reusable grammar clauses (their syntax diagrams will be listed further down the page in the documentation).</p><p>带小写字母和加高字母的椭圆代表可重用的语法子句（它们的语法图将在文档中的页面下方进一步列出）。</p><p>  The arrows that connect the ovals tell you the order in which the keywords, clauses, and tokens need to appear to construct a valid statement.</p><p>连接椭圆的箭头告诉您构造有效语句所需的关键字、子句和标记的出现顺序。</p><p>  After the statement has been parsed into its component parts, SQLite needs to decide how to approach executing the statement.</p><p>在将语句解析为其组成部分后，SQLite需要决定如何执行该语句。</p><p> For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an AI that tries to pick the fastest and most efficient algorithm for each SQL statement. —  SQLite.org</p><p>对于任何给定的SQL语句，可能有数百、数千甚至数百万种不同的算法来执行该操作。所有这些算法都会得到正确的答案，尽管有些算法会比其他算法运行得更快。查询计划器是一种人工智能，它试图为每个SQL语句选择最快、最有效的算法。-SQLite。组织</p><p> Understanding how SQLite determines the best way to execute your statements is a big enough topic to warrant its own post. However, for this article it’s just important to know that there is an optimization step  between parsing and compilation.</p><p>理解SQLite如何决定执行语句的最佳方式是一个足够大的主题，足以证明它自己的观点是正确的。然而，对于本文来说，重要的是要知道在解析和编译之间有一个优化步骤。</p><p>  Finally: after SQLite has determined how to best approach running your statement, it puts together a list of low-level bytecode instructions that describe the whole operation. That list of instructions is, quite literally, a program which will be run on the VDBE. A more popular name for the program compiled by SQLite is “prepared statement”.</p><p>最后：在SQLite确定了如何以最佳方式运行语句后，它会列出一系列描述整个操作的低级字节码指令。从字面上看，这个指令列表是一个将在VDBE上运行的程序。SQLite编译的程序的一个更流行的名称是“prepared statement”。</p><p> Each bytecode instruction consists of an opcode (name of the instruction) and up to 5 parameters (input values or references to registers). In modern SQLite versions, there are over a hundred different types of instructions. They run the gamut between simple control-flow instructions like   Eq: “jump to an instruction if two registers have the same value” and more database-specific instructions like  ResultRow: which provides data to the database cursor at the current position, pointing at values which have been loaded into the VDBE’s registers.</p><p>每个字节码指令由一个操作码（指令名）和最多5个参数（输入值或寄存器引用）组成。在现代SQLite版本中，有100多种不同类型的指令。它们在简单的控制流指令（如Eq:“如果两个寄存器具有相同的值，则跳转到一条指令”）和更特定于数据库的指令（如ResultRow:）之间运行，后者在当前位置向数据库光标提供数据，指向已加载到VDBE寄存器中的值。</p><p> Once compiled into bytecode, a prepared statement does not need to be parsed or to go through the query planning process again. This is precisely what makes re-using prepared statements so fast when compared with opting not to re-use them.</p><p>一旦编译成字节码，一个准备好的语句就不需要被解析或再次执行查询计划过程。这正是为什么重复使用准备好的语句比不重复使用它们更快的原因。</p><p>  Now that you know how your  raw statement becomes a  prepared statement, you may be wondering if it’s possible to examine the bytecode program that was compiled.</p><p>现在您已经知道了原始语句是如何变成准备好的语句的，您可能想知道是否可以检查编译的字节码程序。</p><p> SQLite provides a mechanism you can use to inspect the bytecode it would generate for any statement. In order to see the bytecode, just prepend your statement with  EXPLAIN. From the documentation:</p><p>SQLite提供了一种机制，可以用来检查它为任何语句生成的字节码。为了查看字节码，只需在语句前面加上EXPLAIN。从文件中：</p><p> When the EXPLAIN keyword appears … it causes the statement to behave as a query that returns the sequence of  virtual machine instructions it would have used to execute the command had the EXPLAIN keyword not been present.  —  SQLite.org</p><p>当EXPLAIN关键字出现时，它会使语句表现为一个查询，返回如果EXPLAIN关键字不存在，它将用于执行命令的虚拟机指令序列。-SQLite。组织</p><p> EXPLAIN&#39;s output is a series of rows where each row is an instruction in the prepared statement bytecode and each has 8 columns:</p><p>解释&#39；s输出是一系列行，其中每行都是准备好的语句字节码中的一条指令，每行有8列：</p><p>  That last column:  comment will likely be empty unless you compile SQLite yourself and set the  -DSQLITE_ENABLE_EXPLAIN_COMMENTS  option.</p><p>最后一列：comment很可能是空的，除非您自己编译SQLite并设置-DSQLITE_ENABLE_EXPLAIN_COMMENTS选项。</p><p>  Let’s use  EXPLAIN to take a look at the bytecode for a few statements. Because my install didn’t have the comments turned on, I’ll leave that out. Each example starts with the output you receive when you use  EXPLAIN, followed by a  walk-through of the flow that the VDBE takes through the bytecode program.</p><p>让我们使用EXPLAIN来查看字节码中的一些语句。因为我的安装没有打开评论，所以我将不使用它。每个示例都从使用EXPLAIN时收到的输出开始，然后是VDBE在字节码程序中的流程介绍。</p><p> (Note: all bytecode shown here is from SQLite 3.16.2, and may not be the same in other versions.)</p><p>（注意：这里显示的所有字节码都来自SQLite 3.16.2，在其他版本中可能不相同。）</p><p>  sqlite&gt; EXPLAIN SELECT &#34;hello world&#34;; addr opcode p1 p2 p3 p4 p5 ---- ------------- ---- ---- ---- ------------- -- 0 Init 0 1 0 00 1 String8 0 1 0 hello world 00 2 ResultRow 1 1 0 00 3 Halt 0 0 0 00</p><p>sqlite&gt；解释选择&#34；你好，世界&#34；；地址操作码p1 p2 p3 p4 p5--------------------------0初始0 1 0 0 0 1字符串8 0 1 0 hello world 00 2结果1 0 0 0 0 3暂停0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</p><p>  Init 0 1 0 — Denotes the start of the program and moves to address 1.</p><p>Init 0 1 0-表示程序的开始，并移动到地址1。</p><p> String8 0 1 0 &#39;hello world&#39; — “hello world” is stored in register 1.</p><p>字符串8 0 1 0和#39；你好，世界&#39；-“hello world”存储在寄存器1中。</p><p> ResultRow 1 1 0 — Let the cursor know that the register 1 contains a row of output.</p><p>ResultRow 1 1 0-让光标知道寄存器1包含一行输出。</p><p>  sqlite&gt; EXPLAIN CREATE TABLE blog (  title TEXT NOT NULL,   author TEXT NOT NULL,   pub_date INTEGER,   body TEXT ); addr opcode p1 p2 p3 p4 p5 ---- ------------- ---- ---- ---- ------------- -- 0 Init 0 27 0 00 1 ReadCookie 0 3 2 00 2 If 3 5 0 00 3 SetCookie 0 2 4 00 4 SetCookie 0 5 1 00 5 CreateTable 0 2 0 00 6 OpenWrite 0 1 0 5 00 7 NewRowid 0 1 0 00 8 Blob 6 3 0 00 9 Insert 0 3 1 08 10 Close 0 0 0 00 11 Close 0 0 0 00 12 Null 0 4 5 00 13 OpenWrite 1 1 0 5 00 14 SeekRowid 1 16 1 00 15 Rowid 1 5 0 00 16 IsNull 5 24 0 00 17 String8 0 6 0 table 00 18 String8 0 7 0 blog 00 19 String8 0 8 0 blog 00 20 Copy 2 9 0 00 21 String8 0 10 0 CREATE TABLE blog (  title TEXT NOT NULL,  author TEXT NOT NULL,  pub_date INTEGER,  body TEXT ) 00 22 MakeRecord 6 5 11 BBBDB 00 23 Insert 1 11 5 00 24 SetCookie 0 1 1 00 25 ParseSchema 0 0 0 tbl_name=&#39;blog&#39; AND type!=... 26 Halt 0 0 0 00 27 Transaction 0 1 0 0 01 28 Goto 0 1 0 00</p><p>sqlite&gt；解释创建表博客（标题文本不为空、作者文本不为空、发布日期整数、正文文本）；地址操作码p1 p2 p3 p4 p5-------------------------0初始化0 27 0 0 0 0 0 0 0 0 1读Cookie 0 3 2 0 0 2如果3 5 0 0 0 0 0 3设置Cookie 0 2 4 0 0 4设置Cookie 0 5 1 0 0 5创建表0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9插入0 3 1 0 8 10关闭0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12空0 4 0 0 0 13打开写入1 0 5 0 0 0 0 0 0 0 0 0 0 0 014 SeeKrowid1 16 1 00 15 Rowid 1 5 0 0 0 16 IsNull 5 24 0 0 17 String8 0 6 0 table 00 18 String8 0 7 0 blog 00 19 String8 0 blog 00 20 Copy 2 9 0 00 21 String8 0 10 0 CREATE table blog（标题文本不为NULL，作者文本不为NULL，发布日期整数，正文）00 22 MakeRecord 6 11 BBBDB 00 23 Insert 1 11 5 00 24 SetCookie 0 1 00 25ParseSchema 0 tbl_name=&#39；博客&#39；还有打字。。。26暂停0 0 00 27事务处理0 1 0 0 01 28转到0 1 0 00</p><p> Transaction 0 1 0 0 01 — Start a write transaction on the current database and check that the database schema is the expected version.</p><p>事务0 1 0 01-在当前数据库上启动写事务，并检查数据库架构是否为预期版本。</p><p>  ReadCookie 0 3 2 — Read cookie #2 ( the database format) from the database and store its value in register 3.  What are “cookies”? Cookies are values that are present in the actual database file that SQLite is using.</p><p>ReadCookie 0 3 2-从数据库中读取cookie#2（数据库格式），并将其值存储在寄存器3中。什么是“饼干”？Cookie是SQLite使用的实际数据库文件中存在的值。</p><p> If 3 5 0 — Jump to address 5 if the value in register 3 is not zero.  Interpretation: we’re going to skip setting some cookies on the database if there is already a database format configured (let’s assume there isn’t one yet).</p><p>如果3 5 0-如果寄存器3中的值不为零，则跳转到地址5。解释：如果已经配置了数据库格式（假设还没有），我们将跳过在数据库上设置一些cookie。</p><p> SetCookie 0 2 4 — Write  4 to cookie number 2 for the current database. This sets the database file format to 4.</p><p>SetCookie 0 2 4-将4写入当前数据库的cookie编号2。这会将数据库文件格式设置为4。</p><p> SetCookie 0 5 1 — Write  1 to cookie number 5 for the current database. Cookie number 5 denotes the  database file’s text encoding format. By setting its value to  1, we are choosing UTF-8.</p><p>SetCookie 0 5 1-将1写入当前数据库的cookie编号5。Cookie数字5表示数据库文件的文本编码格式。通过将其值设置为1，我们选择UTF-8。</p><p> CreateTable 0 2 0 — Create a new table and place its location in the database file at register 2.</p><p>CreateTable 0 2 0-创建一个新表，并将其位置放在寄存器2的数据库文件中。</p><p> OpenWrite 0 1 0 5 — Open a read/write cursor called  0 with 5 columns on the table whose root page is  1.   Interpretation:  Page 1 contains the   sqlite_master  table, to which we’re going to add a record defining our  blog table.</p><p>OpenWrite 0 1 0 5-打开名为0的读/写游标，在根页为1的表上有5列。解释：第1页包含sqlite_主表，我们将向其中添加一条定义博客表的记录。</p><p> NewRowid 0 1 0 — Get a new rowid value and place it in register  1.</p><p>NewRowid 0 1 0-获取一个新的rowid值并将其放入寄存器1中。</p><p> Blob 6 3 0 _ — There is an empty blob of length  6-bytes that we are going to store in register  3.</p><p>Blob 6 3 0-有一个长度为6字节的空Blob，我们将存储在寄存器3中。</p><p> Insert 0 3 1 _ 08 — Using cursor  0, write the data in register  3 to the table using the value in register  1 as the key and increment the number of rows for the table.  Interpretation: We are writing the blob that was recently loaded into register 3 to the table as a new row and are using the rowid we constructed as its key.</p><p>插入0 3 1 08-使用光标0，使用寄存器1中的值作为键将寄存器3中的数据写入表中，并增加表的行数。解释：我们正在将最近加载到寄存器3中的blob作为新行写入表中，并使用我们构造的rowid作为其键。</p><p>    OpenWrite 1 1 0 5 — Open a read/write cursor called  1 with 5 columns on the table whose root page is  1.  Interpretation: Re-open a cursor into the  sqlite_master table.</p><p>OpenWrite 1 10 5-打开名为1的读/写游标，在根页面为1的表上有5列。解释：将光标重新打开到sqlite_主表中。</p><p> SeekRowid 1 16 1 — Using cursor  1, jump to address  16 if the cursor doesn’t contain a rowid of the value in register  1. Otherwise move along. (let’s move along, since we did just write something to the value in register 1)</p><p>请参阅克罗维德1 16 1-如果光标不包含寄存器1中值的rowid，请使用光标1跳转到地址16。否则继续前进。（让我们继续，因为我们刚刚对寄存器1中的值写入了一些内容）</p><p> Rowid 1 5 0 — Store the value of the rowid for cursor  1 in register  5.</p><p>Rowid 1 5 0-将光标1的Rowid值存储在寄存器5中。</p><p> IsNull 5 24 0 — Jump to address  24 if the value in register  5 is  NULL.  Interpretation: If, for some reason, the cursor isn’t pointing at a row in the  sqlite_master table, we are going to quit out by jumping to the end of the program. (let’s assume the value was not  NULL)</p><p>IsNull 5 24 0-如果寄存器5中的值为NULL，则跳转到地址24。解释：如果由于某种原因，光标没有指向sqlite_主表中的一行，我们将跳转到程序的末尾退出。（假设该值不是NULL）</p><p>    Copy 2 9 0 — Copy the value from register  2 to register  9.  Interpretation: we’re copying the database file page location of the new table we created way back during the instruction at address 5 from register 2 to 9 because we are about to use it in an insert into the  sqlite_master table.</p><p>复制2 9 0-将值从寄存器2复制到寄存器9。解释：我们将在地址5的指令中创建的新表的数据库文件页位置从寄存器2复制到9，因为我们将在sqlite_主表的插入中使用它。</p><p> String8 0 10 0 &#39;CREATE TABLE ....’ — Store the  CREATE TABLE statement into register  10.</p><p>字符串8 0 10 0和#39；创建表格……”将CREATE TABLE语句存储到寄存器10中。</p><p> MakeRecord 6 5 11 &#39;BBBDB&#39; — Create a table record using registers  6 through  10 (6 + (5–1)) and store a reference to that record in register  11. The  BBBDB string says that the first three columns and the last column in the record should have a type-affinity of “blob”, and the fourth should be a number.  Interpretation: We’re finally building the row in  sqlite_master for our  blog table.</p><p>记录6 5 11和#39；BBBDB&#39；-使用寄存器6到10（6+（5–1））创建一个表记录，并将对该记录的引用存储在寄存器11中。BBBDB字符串表示，记录中的前三列和最后一列的类型关联应为“blob”，第四列应为数字。解释：我们终于在sqlite_master中为我们的博客表构建了行。</p><p> Insert 1 11 5 —Using cursor  1, write the record data pointed to by register  11 using the rowid we’ve stored in register  5 as its key.</p><p>插入1115-使用游标1，使用我们存储在寄存器5中的rowid作为其键，写入寄存器11指向的记录数据。</p><p> SetCookie 0 1 1 — Set the value of  the schema cookie to  1. The schema cookie is cookie number 1, and it denotes the current version of the database schema.</p><p>SetCookie 0 1-将架构cookie的值设置为1。模式cookie是cookie编号1，它表示数据库模式的当前版本。</p><p> ParseSchema 0 0 0 &#34;tbl_name=&#39;blog&#39;...&#34; — Parse all schema entries in  sqlite_master using the p4 param value as a  WHERE clause. (this spawns another call into the VDBE)</p><p>语法模式0&#34；tbl_name=&#39；博客&#39&#34; — 使用p4 param值作为WHERE子句解析sqlite_master中的所有模式条目。（这会产生另一个对VDBE的调用）</p><p> Halt 0 0 0 — Terminate the program with an error code of  0 (success!).</p><p>暂停0-终止程序，错误代码为0（成功！）。</p><p>  Lastly, let’s see what it takes to add a row to our newly created  blog table.</p><p>最后，让我们看看向新创建的blog表添加一行需要什么。</p><p> sqlite&gt; EXPLAIN INSERT INTO blog (title, author, pub_date, body) VALUES (&#39;Winter is Coming&#39;, &#39;Ned Stark&#39;, date(&#39;now&#39;), &#39;It comes in season 7.&#39;); addr opcode p1 p2 p3 p4 p5 ---- ------------- ---- ---- ---- --------------------- -- 0 Init 0 12 0 00 1 OpenWrite 0 2 0 4 00 2 NewRowid 0 1 0 00 3 String8 0 2 0 Winter is Coming 00 4 String8 0 3 0 Ned Stark 00 5 Function0 1 6 4 date(-1) 01 6 String8 0 5 0 It comes in season 7. 00 7 HaltIfNull 1299 2 2 blog.title 01 8 HaltIfNull 1299 2 3 blog.author 01 9 MakeRecord 2 4 7 BBDB 00 10 Insert 0 7 1 blog 1b 11 Halt 0 0 0 00 12 Transaction 0 1 1 0 01 13 String8 0 6 0 now 00 14 Goto 0 1 0 00</p><p>sqlite&gt；解释在博客（标题、作者、发布日期、正文）中插入的价值观（&#39；冬天来了&#39；，&#39；奈德·斯塔克&#39；，日期（&#39；现在&#39；）&#39;第七季播出&#39;); 地址操作码p1 p2 p3 p4 p5--------------------------------------------------0初始0 12 0 00 1 OpenWrite 0 2 0 4 00 2 NewRowid 0 1 0 0 0 3 String8 0 0 2 0冬季即将到来00 4 String8 0 3 0 Ned Stark 0 0 0 0 5函数0 1 6 4日期（-1）01 6 String8 0 5它在第七季到来。00 7 HaltIfNull 12992博客。标题01 8 HaltIfNull 1299 2 3博客。作者01 9 MakeRecord 2 4 7 BBDB 00 10插入0 7 1博客1b 11暂停0 0 00 12事务0 1 0 01 13 String8 0 6 0 now 00 14 Goto 0 1 0 00</p><p> Transaction 0 1 1 0 01 — Start a write transaction on the current database and check that the database schema is the expected version.  Remember: at address 24 of the  CREATE TABLE bytecode program,  1 was stored as the schema version; in this instruction we’re just making sure that it is still  1.</p><p>事务0 1 1 0 01-在当前数据库上启动写事务，并检查数据库架构是否为预期版本。记住：在CREATE TABLE字节码程序的地址24处，1被存储为模式版本；在本说明中，我们只是确保它仍然是1。</p><p>   OpenWrite 0 2 0 4 — Open a read/write cursor called  0 with  4 columns on the table whose root is at page  2.  Remember: The  blog table was created on database page  2, and it has  4 columns.</p><p>OpenWrite 0 2 0 4-打开一个名为0的读/写游标，在根位于第2页的表上有4列。记住：blog表是在数据库第2页上创建的，它有4列。</p><p> NewRowid 0 1 0 — Get a new rowid for the table and store it in register  1.</p><p>NewRowid 0 1 0-获取表的新rowid并将其存储在寄存器1中。</p><p> String8 0 2 0 &#39;Winter is Coming&#39; — Store  &#39;Winter is Coming&#39; in register  2.</p><p>String8 0 2 0和#39；冬天来了&#39；-商店&#39；冬天来了&#39；在寄存器2中。</p><p>  Function0 1 6 4 date(-1) 01 — Invoke the  date function using the value at register  6 as its only argument and store the result in register  4.</p><p>Function0 1 6 4 date（-1）01-使用寄存器6处的值作为其唯一参数调用date函数，并将结果存储在寄存器4中。</p><p> String8 0 5 0 &#39;It comes in season 7.&#39; — Store  &#39;It comes in season 7.&#39; in register  5.</p><p>弦8 0 5 0和#39；第七季播出&#39; — 商店&#39；第七季播出&#39; 在登记册5中。</p><p> HaltIfNull 1299 2 2 &#39;blog.title&#39; 01 — If the value in register  2 is null, end the program with error code  1299.  Interpretation: The title column on the  blog was defined as  NOT NULL, so we need to verify that the value we’re about to store is, well, not null. If it is, we will error out with the  SQLITE_CONSTRAINT_NOTNULL code.</p><p>HaltIfNull 1299 2和#39；博客头衔和#39；01-如果寄存器2中的值为空，则以错误代码1299结束程序。解释：博客上的标题列被定义为NOTNULL，所以我们需要验证我们要存储的值是否为NOTNULL。如果是，我们将使用SQLITE_CONSTRAINT_NOTNULL代码出错。</p><p> HaltIfNull 1299 2 3 &#39;blog.author&#39; 01 — If the value in register  3 is null, end the program with error code  1299.  Interpretation: Just like the  title, the  author column was also defined as  NOT NULL.</p><p>HaltIfNull 1299 2 3和#39；博客作者&#39；01-如果寄存器3中的值为空，则以错误代码1299结束程序。解释：与标题一样，作者栏也被定义为非空。</p><p> MakeRecord 2 4 7 &#39;BBDB&#39; — Create a table record using registers  2 through  5 (2 + (4–1)) and store a reference to that record in register  7. The  BBDB string says that the record should consist of two blobs, a number, and a blob (in that order).</p><p>创纪录2 4 7&#39；BBDB&#39；-使用寄存器2到5（2+（4–1））创建一个表记录，并在寄存器7中存储对该记录的引用。BBDB字符串表示记录应该由两个blob、一个数字和一个blob（按顺序）组成。</p><p> Insert 0 7 1 &#39;blog&#39; 1b — Insert the record pointed to by register  7 with the key in register  1 into the  blog table. The  1b value for  p5 is a bit mask denotes among other things that the VDBE should count the number of rows changed, and store the newest inserted row’s id for access later.  Interpretation: This is where Ned Stark’s blog post is actually added to the table.</p><p>插入0 7 1和#39；博客&#39；1b-将寄存器7指向的记录以及寄存器1中的键插入blog表。p5的1b值是一个位掩码，表示VDBE应该计算更改的行数，并存储最新插入行的id以供以后访问。解读：这就是奈德·斯塔克的博客帖子被添加到表格中的地方。</p><p> Halt 0 0 0 — We’re done! Exit with error code of  0 (success).</p><p>停下，我们结束了！退出，错误代码为0（成功）。</p><p>  If you’re still with me, nice work! If you’d like to learn even more about SQLite’s VDBE and bytecode, try looking through the  EXPLAIN results for following on your own:</p><p>如果你还和我在一起，干得好！如果您想了解更多关于SQLite的VDBE和字节码的信息，请尝试自己查看以下解释结果：</p><p> Create another table, add data to it that relates to the data in the first table, and do a  SELECT query which  JOINs the two tables together.</p><p>创建另一个表，向其中添加与第一个表中的数据相关的数据，并执行SELECT查询，将两个表连接在一起。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟机/">#虚拟机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>