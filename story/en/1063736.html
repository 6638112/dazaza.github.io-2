<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实施严格的三点视角 Implementing strict three-point perspective</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing strict three-point perspective<br/>实施严格的三点视角 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 06:50:42</div><div class="page_narrow text-break page_content"><p>This might seem an odd article: every tutorial on the internet teaches you that three point perspective is just the art term for “regular 3D”, where you set up a camera, tweak its distance, FOV, and zoom, and you’re done. The vanishing points that you use when using pen and paper correspond to where the X, Y, and Z axes intersect your clipping plane, and that’s all she wrote… Except that’s not  “true” three point perspective. That’s the easy-for-computer-graphics version of three point perspective: the strict version is quite a bit trickier.</p><p>这可能似乎是一个奇怪的文章：互联网上的每个教程都教导你三点透视只是“普通3D”的艺术术语，你设置了相机，调整距离，fov和缩放，你已经完成了。使用笔和纸时使用的消失点对应于x，y和z轴与剪切平面相交的位置，这就是她写的一切......除了这不是“真实”的三点视角。这是三点视角的易于电脑图形版本：严格的版本有点棘手。</p><p> The thing that makes it tricky is that in a strict implementation of three point perspective, your vanishing points have to   literally be vanishing points: they don’t represent intersections of axes that run to infinity and a clipping plane somewhere off in the distance relative to your camera, the vanishing points are the exact points where all parallel lines to infinity converge. Which is a problem for computer graphics because that means we’re not dealing with linear space, which means we can’t use linear algebra to compute nice “3D world coordinates to 2D screen coordinates” using matrix operations. Which is a slight problem given that that’s the fundamental approach that allows efficient 3D computer graphics on pretty much any modern hardware.</p><p> 使它令人棘手的事情是，在严格实施三点的角度来看，您的消失点必须真实地消失点：它们不代表轴向无限远的轴和距离相对于距离的剪裁平面的交叉点。您的相机，消失点是所有平行线到Infinity收敛的精确点。这是计算机图形的问题，因为这意味着我们不处理线性空间，这意味着我们不能使用线性代数来计算使用矩阵操作来计算好的“3D世界坐标到2D屏幕坐标”。这是一个轻微的问题，因为这是允许高效3D计算机图形上的基本方法，这些方法几乎是任何现代硬件。</p><p> So let’s look at what makes this so crazy, and how we can implement it anyway.</p><p> 所以让我们看看这么疯狂的是什么，以及我们如何实现它。</p><p>   Before we continue, I want to make it very clear that you will almost  never need strict three point perspective: it is not “useful” so much as it is a rather strange 3D aesthetic. But it  is a programming challenge, and no one’s got a page up about this on the internet as I write this text, so that’s certainly challenge enough to work out what the heck is up with this crazy projection and explain the code we need to achieve it.</p><p>   在我们继续之前，我想简单地说明你几乎永远不需要严格的三点视角：这是“有用”，因为这是一个相当奇怪的3D审美。但它是一个编程挑战，只有在互联网上没有人在互联网上找到了这篇文章，所以这肯定足够挑战，以解决这个疯狂的投影并解释我们需要实现的代码它。</p><p>  Let’s have a look at the two point perspective, to get a feel for what we’re dealing with:</p><p>  让我们来看看两点观点，了解我们处理的内容：</p><p>  We have two vanishing points, labeled Z and X here, and some arbitrary “zero” point where we simply say “this is (0,0,0)” (using thee coordinates, because right now there’s an implied Y coordinate, but we’ll make it explicit soon enough). We also need some point to act as our “zero”: when you’re drawing on a piece of paper you can just decide where that is, but when working with computers we need to be explicit about where fixed points are. This actually makes “two point perspective” a three point perspective for computers, because you need to specify three points, but that’s neither here nor there. We then also need to say what the elevation is from our zero to the horizon, because (again) while you’re drawing you can just wing it, but computers need to know what that value is so that arbitrary coordinates can get mapped to the screen correctly. Make “two point perspective” actually “three points and a number” perspective. Let’s say that the height at the horizon for our perspective is simply one, then this will give us that following perspective:</p><p>  我们有两个消失点，标记为z和x，以及我们简单地说“这是（0,0,0）”的一些任意的“零”点，因为现在有一个隐含的y坐标，所以我们'LL很快就会明确）。我们还需要一些点作为我们的“零”：当你绘制一张纸时，你可以决定在哪里，但是当使用计算机时，我们需要明确地了解固定点。这实际上使“两点透视”是计算机的三点透视，因为你需要指定三个点，但这既不是这里也不在那里。我们还需要说出高度从我们的零到地平线，因为（再次）你画画你可以只是翅膀它，但是计算机需要知道该值是什么，使任意坐标可以映射到屏幕正确。制作“两点视角”实际上“三点和一个数字”的观点。假设我们的角度来看，以地平线的高度只是一个，那么这将告诉我们以下观点：</p><p>  And with that we have everything we need to construct pretty graphics in two point perspective. Except there’s one thing that you’ll almost certainly have noticed already, but might not have considered: the above “graph” isn’t a normal graph. We see the grid getting finer and finer, the closer we get to X, Z, as well as the horizon. Rather than a standard grid, more precisely know as a  Cartesian, and specifically  Euclidean, coordinate system like this:</p><p>  与我们有一切我们需要用两点透视构建漂亮的图形。除了有一件事，你几乎肯定已经注意到了，但可能没有考虑：上面的“图表”不是正常的图表。我们看到网格变得更好，更漂亮，我们越靠近x，z以及地平线。而不是标准电网，更精确地知道笛卡尔，具体地是欧几里德，坐标系： </p><p>    That is, rather than an infinite grid that we could never fit on any kind of finite size piece of paper, we have a bounded grid, where the distance between a  world coordinate at zero and at infinity is an  fixed distance in terms of  screen coordinates. As long as we understand the difference between world and screen coordinates: the screen coordinates are like a camera, it’s what we “see” given the projection we’ve told the camera to use, whereas the world coordinates are “the actual things themselves”. Even though our projection can turn an infinity into a fixed point, as far as the world coordinate system is concerned, there’s still no way for something to ever actually  be at infinity, let alone be  beyond infinity, even though our projection lets us put the mouse cursor exactly on, or even beyond, where infinity gets projected onto the screen.</p><p>也就是说，而不是无限的网格，我们不能适合任何类型的有限尺寸的纸张，我们有一个有界网格，其中世界坐标与无穷大之间的距离是屏幕坐标的固定距离。只要我们了解世界和屏幕协调之间的区别：屏幕坐标就像相机一样，它是我们“看到”给出了我们告诉相机使用的投影，而世界坐标是“实际的事情” 。即使我们的投影可以将无限远变为一个定点，就像世界坐标系所关注的那样，仍然没有办法才能实际上是无限的，更不用说超越无限，即使我们的投影让我们放弃了鼠标光标完全在，甚至超过，其中Infinity将投影到屏幕上。</p><p> This is an example of a Cartesian, but  non-Euclidean, coordinate system. That is: there  is a one-to-one mapping between the regular grid and this one, but we  can’t use  linear algebra to express that mapping.</p><p> 这是笛卡尔，但非欧几里德，坐标系的示例。也就是说：常规网格与此之间有一对一的映射，但我们不能使用线性代数来表达该映射。</p><p> However, the above illustration only exists to get us comfortable with the idea of mapping infinity, by looking at an illustration of mapping an infinite range to a fixed size. The actual projection we’re dealing in two point perspective is more complex than the one shown above still:</p><p> 然而，通过查看将无限范围映射到固定尺寸的图示，上述图形仅存在让我们对映射无穷大的想法感到舒服。我们以两点透视处理的实际投影比上面所示的更复杂：</p><p>  Not only is our grid not linear, it is not even Cartesian: while it might look like this triangle is the same as the above rectangular grid, but with the upper right corner moved inward so it forms a diagonal with the other two points, that’s not actually the case. If you look at the upper left and lower right points, you’ll see that our grid lines all converge. Using the labeling  Z and  X for the two points, you can see that all values x=…, z=∞ lie on the same point,  Z, which would not be the case if all we did was move our corner point in. If that had been the case, all those values would lie somewhere between  Z and the midpoint of the diagonal (with a similar case for  X) and our grid lines would not converge to single points. Instead, the  entire diagonal line represents the “point” (∞,∞). Even though in reality nothing can ever get there, once a point reaches infinity in either X, Z, or both dimensions, it would become spread out over the entire diagonal, whereas the lines (n,∞) and (∞,n) become the  points  Z and  X.</p><p>  我们的网格不仅是线性的，它甚至不是笛卡尔：虽然它看起来像这样的三角形与上述矩形网格相同，但是右上角向内移动，使其与其他两点形成对角线，即实际上不是这种情况。如果您查看左上角和右下角，您会看到我们的网格线都收敛。使用标签z和x为两点，您可以看到所有值x = ...，z =∞位于同一个点，z，如果我们所做的一切都在移动的情况下，这不是这种情况。如果就是如此，所有这些值都会在z和对角线的中点之间的某个位置（具有x的类似情况），我们的网格线不会收敛到单个点。相反，整个对角线表示“点”（∞，∞）。即使在现实中没有任何东西可以到达那里，一旦点在X，Z或两个尺寸中到达无穷大，它将变得在整个对角线上展开，而线（n，∞）和（∞，n）变得点z和x。</p><p> As a non-cartesian coordinate system, two point perspective is an example of a kind of projection that we’re going to have to evaluate the old fashioned way: mathematically  cannot achieve by using a transformation matrix to turn world coordinates into screen coordinates. The thing that all modern 3D graphics are based on, all the way from software down to the maths that gets performed by the physical chips on your GPU.</p><p> 作为一个非笛卡尔坐标系，两点透视是一种预测的一个例子，我们将需要评估旧的方式：通过使用转换矩阵将世界坐标转换为屏幕坐标来数学上无法实现。所有现代3D图形都是基于的，从软件到GPU上物理芯片执行的数学一切都从软件到达的数学。</p><p> So, that’s what we’re working with, we best get to figuring what code we need to write to work with it.</p><p> 所以，这就是我们正在使用的，我们最好地弄清楚我们需要写作的代码。</p><p>  So, let’s implement two point perspective, given our four points  Z,  X, and our zero point, which we’ll call  C.</p><p>  所以，让我们实施两点透视，鉴于我们的四个点z，x和我们的零点，我们将致电C. </p><p> First, let’s define our transform to turn a linear value into an exponential ratio. We want something that, given value of x=1 for example, yields the value “0.5” signifying that x=1 can be found midway on the X axis, x=2 yielding “0.75” (i.e. three quarters the distance from (0,0,0) along the X axis), and so forth.</p><p>首先，让我们定义我们的转换以将线性值变为指数比。我们想要一些东西，给定的x = 1的值，产生值“0.5”表示可以在X轴中间找到x = 1，x = 2产生“0.75”（即三个季度距离（0沿X轴），0,0），等等。</p><p> You may have spotted the pattern, where we’re just moving by halving the remaining interval for each whole step  s we’re taking, so that’s just exponential decay:</p><p> 您可能已经发现了模式，在那里我们只是通过将我们的整个步骤S的剩余时间间隔减半，所以这只是指数衰变：</p><p>  When s=0, this gives us f(s)=1, and if s=∞ (ignoring that practically speaking this is impossible of course), we get f(s)=0. That’s somewhat the opposite of what we actually want, namely have f(0) be 0 and f(∞) be 1, so we can force that:</p><p>  当s = 0时，这给出了我们f（s）= 1，如果s =∞（当然是不可能忽略这几乎不可能），我们得到f（s）= 0。这有点与我们实际想要的相反，即有f（0）是0，f（∞）是1，所以我们可以强迫：</p><p>  Now s=0 gives us f(s)=0, and s=∞ gives us f(s)=1. Perfect. And of course implementing this is essentially trivial:</p><p>  现在S = 0给出了我们f（s）= 0，并且s =∞给我们f（s）= 1。完美的。当然，实现这一目标是微不足道的：</p><p>  We can now define a function that turns a 3D world coordinate (with y=0 for now) into a 2D screen coordinate, by doing what you’d do on paper as well: find the coordinate’s distance along the X axis, do the same for the Z axis, and then our coordinate can be drawn as the intersection of the line from Z to the point on the X axis, and from X to the point on the Z axis. For example, drawing x=0.5, z=1 gives:</p><p>  我们现在可以定义一个函数，该函数将3D世界坐标（现在有Y = 0）进入2D屏幕坐标，通过做您在纸上进行的操作：找到坐标沿X轴的距离，请执行相同的距离对于Z轴，然后我们的坐标可以被绘制为从z到X轴上的点的线路，并且从x到z轴上的点。例如，绘制x = 0.5，z = 1给出：</p><p>   Vec2  get ( double  x ,  double  z )  {  if  ( x == 0  &amp;&amp;  z == 0 )  return  C ;  Vec2  px  =  lerp ( C ,  X ,  distanceToRatio ( x ));  Vec2  pz  =  lerp ( C ,  Z ,  distanceToRatio ( z ));  return  lli ( X ,  pz ,  Z ,  px ); }</p><p>   vec2获得（双x，double z）{if（x == 0＆amp;＆amp; z == 0）返回c; vec2 px = lerp（c，x，distancetoratio（x））; vec2 pz = lerp（c，z，distancetoratio（z））;返回lli（x，pz，z，px）; }</p><p> In this code,  lerp is the  linear interpolation function (for vectors rather than scalars in this case), and  lli computes the intersection point of two lines:</p><p> 在此代码中，LERP是线性插值函数（对于在这种情况下为矢量而不是标量），LLI计算两行的交点： </p><p> Vec2  lli ( Vec2  l1p1 ,  Vec2  l1p2 ,  Vec2  l2p1 ,  Vec2  l2p2 )  {  return  lli ( l1p1 . x ,  l1p1 . y ,  l1p2 . x ,  l1p2 . y ,  l2p1 . x ,  l2p1 . y ,  l2p2 . x ,  l2p2 . y ); } Vec2  lli ( double  x1 ,  double  y1 ,  double  x2 ,  double  y2 ,  double  x3 ,  double  y3 ,  double  x4 ,  double  y4 )  {  double  d  =  ( x1  -  x2 )  *  ( y3  -  y4 )  -  ( y1  -  y2 )  *  ( x3  -  x4 );  if  ( d  ==  0 )  return  null ;  double  f12  =  ( x1  *  y2  -  y1  *  x2 );  double  f34  =  ( x3  *  y4  -  y3  *  x4 );  double  nx  =  f12  *  ( x3  -  x4 )  -  f34  *  ( x1  -  x2 );  double  ny  =  f12  *  ( y3  -  y4 )  -  f34  *  ( y1  -  y2 );  return  new  Vec2 ( nx / d ,  ny / d ); }</p><p>VEC2 LLI（VEC2 L1P1，VEC2 L1P2，VEC2 L2P1，VEC2 L12）{返回LLI（L1P1。X，L1P1。Y，L1P2。x，L1P2。Y，L2P1。x，l2p1。y，l2p2. x，l2p2。y ）; vec2 lli（双x1，双y1，双x2，双y2，双x3，双y3，双x4，双y4）{双d =（x1-x2）*（y3  -  y4） - （y1  -  y2）* （x3  -  x4）; if（d == 0）返回null;双F12 =（X1 * Y2  -  Y1 * X2）;双F34 =（X3 * Y4  -  Y3 * X4）;双NX = F12 *（x3  -  x4） -  f34 *（x1  -  x2）;双NY = F12 *（Y3  -  Y4） -  F34 *（Y1  -  Y2）;返回新的vec2（nx / d，ny / d）; }</p><p> With the above code in place, we can now draw things on the y=0 plane:</p><p> 通过上面的代码到位，我们现在可以在y = 0平面上绘制东西：</p><p> void  drawSomeGeometry ()  {  beginShape ();  vertex ( 0 , 0 );  vertex ( 3 , 0 );  vertex ( 3 , 1 );  vertex ( 1 , 1 );  vertex ( 1 , 3 );  vertex ( o , 3 );  endShape ( CLOSE );  beginShape ();  vertex ( 2 , 2 );  vertex ( 2 , 3 );  vertex ( 3 , 3 );  vertex ( 3 , 2 );  endShape ( CLOSE );  } void  vertex ( double  x ,  double  z )  {  addShapeVertex ( get ( x , z )); }</p><p> void drawsomegeometry（）{beginshape（）;顶点（0,0）;顶点（3,0）;顶点（3,1）;顶点（1,1）;顶点（1,3）;顶点（o，3）; endshape（关闭）; beginshape（）;顶点（2,2）;顶点（2,3）;顶点（3,3）;顶点（3,2）; endshape（关闭）; void顶点（双x，double z）{addshapefertex（get（x，z））; }</p><p>   Of course, the whole point of two and three point perspective, is to draw  perspectives rather than flat projections, so so let’s extend our  get() function so that it takes elevation into account. This requires a few values specified/computed up front as part of specifying our vanishing points, so we can use them in our elevation-updated  get() function:</p><p>   当然，两点和三点的角度来看，就是绘制透视图而不是平面投影，所以让我们延长我们的get（）函数，以便考虑到高度。这需要少量指定/计算的值，作为指定我们的消失点的一部分，因此我们可以在我们的高度更新的Get（）函数中使用它们：</p><p> Vec2  HC  =  lli ( C ,  C . plus ( 0 , 10 ),  Z ,  X );  // C projected onto the horizon Z--X double  dyC  =  C . y  -  HC . y ;  // the y-distance in screen pixels between C and its projection double  yScale  =  5.0 ;  // this determines what height is drawn as &#34;level&#34; to the viewer double  yFactor  =  dyC  /  yScale ;  // by how much we need to scale world-y to get screen-y</p><p> vec2 hc = lli（c，c。加（0,10），z，x）; // c投射到地平线z  -  x双dyc = c。 y  -  hc。 y; //在C之间的屏幕像素中的Y距离及其投影双yscale = 5.0; //这决定了绘制的高度和＃34;级别＆＃34;观看者双母= DYC / YSCale; //我们需要缩放World-y以获得屏幕 -  y</p><p> We can set all of these at the same time we set the  X,  Z, and  C screen coordinates, meaning we’ll have all of this already available by the time we start drawing things.</p><p> 我们可以同时设置所有这些，我们设置x，z和c屏幕坐标，这意味着我们将在我们开始绘制事物的时间内拥有所有这些。</p><p>  Vec2  get ( double  x ,  double  y ,  double  z )  {  if  ( x == 0  &amp;&amp;  y == 0  &amp;&amp;  z == 0 )  return  C ;  // we start out the same as before, which covers y==0  Vec2  px  =  lerp ( C ,  X ,  stepToDistanceRatio ( x ));  Vec2  pz  =  lerp ( C ,  Z ,  stepToDistanceRatio ( z ));  Vec2  ground  =  lli ( X ,  pz ,  Z ,  px );  if  ( y == 0 )  return  ground ;  // if it&#39;s not, our elevation is a vertical offset from the ground plane,  // with the elevation scaled based on how close our ground plane point is  // to the horizon (X--Z), as well as how close it is our vanishing points.  // are we to the left, or to the right, of our center line?  boolean  inZ  =  ( ground . x  &lt;  C . x );  // determine our first height scaling factor, based on how  // close we are to Z, or X, depending on which side of the  // center line our ground plane coordinate is located.  double  rx  =  inZ  ?  ( ground . x  -  Z . x )  /  ( C . x  -  Z . x )  :  ( X . x  -  ground . x )  /  ( X . x  -  C . x );  // then, determine the second height scaling factor based on  // how close our ground plane coordinate is to the horizon.  Vec2  onAxis  =  lli ( inZ  ?  Z  :  X ,  C ,  ground ,  ground . plus ( 0 ,  10 ));  double  ry  =  ( ground . y  -  HC . y )  /  ( onAxis . y  -  HC . y );  // our final screen-height is the world height, times the  // yFactor (which is the elevation if the x/z coordinates  // were zero), times the two scaling factors.  return  ground . minus ( 0 ,  rx  *  ry  *  y  *  yFactor ); }</p><p>  vec2获得（双x，双y，double z）{if（x == 0＆amp; y == 0＆amp;＆amp; z == 0）返回c; //我们开始与之前相同，涵盖y == 0 vec2 px = lerp（c，x，steptodistanceratio（x））; vec2 pz = lerp（c，z，steptodistanceratio（z））; vec2 ground = lli（x，pz，z，px）;如果（y == 0）返回地面; //如果它没有，我们的高度是从地面平面的垂直偏移，//基于我们的地面平面点的接近//到地平线（X-Z）的接近程度缩放了高度缩放作为我们的消失点是多么近的。 //我们到左边，或我们的中心线的右边？布尔inz =（地面。x＆lt; c。x）; //基于What //关闭我们是Z，OR X的第一个高度缩放因子，具体取决于//中心线的哪一侧我们的接地平面坐标位于所在的//中心线。 Double Rx = inz？ （地面。x  -  z. x）/（c。x  -  z。x）:( x。x-ground。x）/（x。x  -  c。x）; //然后，基于//确定电平面坐标对地平线接近的第二高度缩放系数。 vec2 onaxis = lli（inz？z：x，c，地面，地面。加（0,10））;双RY =（接地。Y  -  HC。Y）/（onaxis。Y  -  HC。y）; //我们的最终屏幕高度是世界高度，时间// Yeactor（如果X / Z坐标//为零），这是两个缩放因子的倍数。返回地面。减去（0，Rx * Ry * Y * Yfactor）; } </p><p>  void  drawSomeGeometry ()  {  Vec2 []  p  =  {  get ( 0 , 0 , 0 ),  get ( 1 , 0 , 0 ),  get ( 1 , 0 , 2 ),  get ( 0 , 0 , 2 ),  get ( 0 , 7 , 2 ),  get ( 1 , 7 , 2 ),  get ( 1 , 7 , 0 ),  get ( 0 , 7 , 0 ),  }  // ...and then some lines between these corner points... }</p><p>void drawsomegeometry（）{vec2 [] p = {get（0,0,0），get（1,0,2），get（0,0,2），get（0 ，7,2），GET（1,7,2），GET（1,7,0），GET（0,7,0），} // ......然后在这些角点之间的某些行... }</p><p>   Looking pretty good! But that’s only two point perspective. Three point perspective ups the non-Euclidean-ness by also making the elevation a “fixed distance to infinity” axis. If you made it this far: things are about to get  really weird!</p><p>   看起来相当不错！但这只是两点的角度。三点透视通过也通过使升高成为“固定距离到无限”轴的非欧几里德的透视。如果你这样做了这一点：事情即将真正奇怪！</p><p>    We now have three vanishing points that can never be reached (except by pixel rounding) and where in two point perspective at least we have parallel lines for our verticals, that’s gone: all verticals now converges at Y. So, let’s write a  get3() function for computing screen coordinates using three point perspective.</p><p>    我们现在有三个消失的点，可以达到三个消失点（除了像素舍入之外），并且在两点透视中，至少我们的垂直线有平行线，所以已经消失了：所有垂直现在都在y孵化。所以，让我们写一个get3（ ）使用三点透视计算屏幕坐标的函数。</p><p> First off, let’s sketch out how to get our 3D point in this kind of space:</p><p> 首先，让我们勾勒出如何在这种空间中获得我们的3D点：</p><p>  We’re basically doing the same thing we did for the two point perspective, twice: we construct the point XY from its X and Y axis coordinate, and then we do the same for point YZ, and then we find the intersection between the line XY–Z and line X–YZ. And that’s it, we’re done. In code:</p><p>  我们基本上正在做同样的事情我们为两点的角度来看，两次：我们从其x和y轴坐标构造点xy，然后我们为点yz做同样的事情，然后我们找到了线之间的交叉点XY-Z和线X-YZ。就是这样，我们已经完成了。在代码：</p><p> Vec2  get3 ( double  x ,  double  y ,  double  z )  {  if  ( x == 0  &amp;&amp;  y == 0  &amp;&amp;  z == 0 )  return  C ;  Vec2  px  =  lerp ( C ,  X ,  stepToDistanceRatio ( x ));  Vec2  pz  =  lerp ( C ,  Z ,  stepToDistanceRatio ( z ));  if  ( y == 0 )  return  lli ( X ,  pz ,  Z ,  px );  Vec2  py  =  lerp ( C ,  Y ,  stepToDistanceRatio ( y ));  Vec2  YZ  =  lli ( Y ,  pz ,  Z ,  py );  Vec2  XY  =  lli ( Y ,  px ,  X ,  py );  return  lli ( XY ,  Z ,  X ,  YZ ); }</p><p> vec2 get3（双x，双y，double z）{if（x == 0＆amp; y == 0＆amp;＆amp; z == 0）返回c; vec2 px = lerp（c，x，steptodistanceratio（x））; vec2 pz = lerp（c，z，steptodistanceratio（z））; if（y == 0）返回lli（x，pz，z，px）; vec2 py = lerp（c，y，steptodistanceratio（y））; vec2 yz = lli（y，pz，z，py）; vec2 xy = lli（y，px，x，py）;返回lli（xy，z，x，yz）; }</p><p> So, what does this look like for the 1x7x2 beam we drew earlier, using two point perspective?</p><p> 那么，我们在之前浏览了1x7x2波束的这看起来像是什么样的，使用两点透视图？ </p><p>  That’s not great… it’s correct, but it’s also pretty horrible… The reason for this is that by using exponential decay with base 2 we approach Y  really quickly. However, we can control this by changing the value we use as exponential base.</p><p>那不是很好......这是正确的，但它也很可怕......这是一个原因是，通过使用基座2的指数衰减我们真正快速地接近y。但是，我们可以通过更改我们用作指数基础的值来控制此操作。</p><p> double  yBase  =  1.25 ; double  stepToDistanceRatio ( double  step )  {  return  stepToDistanceRatio ( 2.0 ,  step ); } double  stepToDistanceRatio ( double  base ,  double  step )  {  return  1.0  -  1.0  /  pow ( base ,  step ); } Vec2  get3 ( double  x ,  double  y ,  double  z )  {  if  ( x == 0  &amp;&amp;  y == 0  &amp;&amp;  z == 0 )  return  C ;  Vec2  px  =  lerp ( C ,  X ,  stepToDistanceRatio ( x ));  Vec2  pz  =  lerp ( C ,  Z ,  stepToDistanceRatio ( z ));  if  ( y == 0 )  return  lli ( X ,  pz ,  Z ,  px );  Vec2  py  =  lerp ( C ,  Y ,  stepToDistanceRatio ( yBase ,  y ));  Vec2  YZ  =  lli ( Y ,  pz ,  Z ,  py );  Vec2  XY  =  lli ( Y ,  px ,  X ,  py );  return  lli ( XY ,  Z ,  X ,  YZ ); }</p><p> 双YBase = 1.25;双台阶optodistanceratio（双步）{返回steptodistanceratio（2.0，步骤）;双台阶台原序（双基础，双步）{返回1.0  -  1.0 / POW（基础，步骤）; vec2 get3（双x，double y，double z）{if（x == 0＆amp; y == 0＆amp;＆amp; z == 0）返回c; vec2 px = lerp（c，x，steptodistanceratio（x））; vec2 pz = lerp（c，z，steptodistanceratio（z））; if（y == 0）返回lli（x，pz，z，px）; vec2 py = lerp（c，y，steptodistanceratio（ybase，y））; vec2 yz = lli（y，pz，z，py）; vec2 xy = lli（y，px，x，py）;返回lli（xy，z，x，yz）; }</p><p>     Hahaha, no we haven’t, we’ve actually been looking at an incredibly lucky edge case so far, where we’ve effectively been getting lucky with our choice of coordinates, giving us nice, clean, straight lines to work with. That’s not actually how exponential space works for the vast majority of lines between points, so let’s discover what shapes  actually look like most of the time.</p><p>     哈哈哈，不，我们没有，我们实际上一直在看一个令人难以置信的幸运的边缘案例，在那里我们有效地幸运地了解我们选择的坐标，让我们漂亮，干净，直线合作。这实际上并不是指数空间在积分之间绝大多数线路如何工作，因此让我们发现大部分时间实际上看起来像什么样的形状。</p><p>  So far we’ve been looking at drawing straight, axis-aligned lines, and that might trick you into thinking that exponential space is pretty similar to Euclidean space, which would be a huge mistake. There are in fact only two kinds of lines that look straight in strict two or three point perspective: axis-aligned lines, and perpendiculars to axes. Everything else is, in fact, a curve, which we can see if we try to connect some points that “should” lie on a straight line, if this was Euclidean space. For instance, let’s plot the line y=x/2 on the XY plane and see what happens:</p><p>  到目前为止，我们一直在看绘制直，轴对齐的线条，这可能会欺骗你认为指数空间与欧几里德空间相当相似，这将是一个巨大的错误。实际上只有两种线条在严格的两个或三点视角下直接看：轴对齐线，垂直于轴。事实上，其他一切都是一种曲线，我们可以看出我们是否试图连接一些“应该”在直线上躺在一条直线上，如果这是欧几里德空间。例如，让我们在XY平面上绘制y = x / 2，看看会发生什么：</p><p>  We’d expect this to be a straight line, possibly pointing in an unexpected direction, but…</p><p>  我们希望这可以是一条直线，可能指向意想不到的方向，但......</p><p>  …actually, we don’t get lines  at all most of the time. Instead, all these points that lie on a straight line in terms of world coordinates end up on curves in exponential space. Which means that when we’re working with strict two or three point perspective, we can’t draw edges between points using a standard  line primitive. We’ll need a curve primitive instead.</p><p>  ......实际上，我们大部分时间都没有得到线条。相反，在世界坐标方面躺在直线上的所有这些点都最终在指数空间中的曲线上升。这意味着当我们使用严格的两三点角度时，我们无法使用标准线原语绘制点之间的边缘。我们需要一个曲线原语。</p><p>  void  curve ( Vec3  p1 ,  Vec3  p2 )  {  double  steps  =  max ( 8.0 ,  p2 . minus ( p1 ). mag ());  // i.e. &#34;8 or more steps&#34;  beginShape ();  for ( double  i = 0 ;  i &lt;= 1 ;  i += 1.0 / steps )  {  vertex ( get ( lerp ( p1 ,  p2 ,  i )));  }  endShape (); }</p><p>  void曲线（Vec3 p1，vec3 p2）{双步= max（8.0，p2。减去（p1）。mag（））; // i.＆＃34; 8个或更多步骤＆＃34; beginshape（）; for（Double i = 0; i＆lt; = 1; i + = 1.0 /步骤）{顶点（get（lerp（lerp（p1，p2，i）））; } endshape（）; } </p><p>  void  drawCurveIllustration ()  {  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 20 ,  5 , 0 ));  // y = 0.25x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 20 , 10 , 0 ));  // y = 0.5x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 20 , 15 , 0 ));  // y = 0.75x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 20 , 20 , 0 ));  // y = x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 15 , 20 , 0 ));  // y = 1.33x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 ( 10 , 20 , 0 ));  // y = 2x  curve ( new  Vec3 ( 0 , 0 , 0 ),  new  Vec3 (  5 , 20 , 0 ));  // y = 4x}</p><p>void drawcurveillustration（）{曲线（新vec3（0,0,0），新vec3（20,5,0））; // y = 0.25x曲线（新vec3（0,0,0），新vec3（20,10,0））; // y = 0.5x曲线（新vec3（0,0,0），新vec3（20,15,0））; // y = 0.75x曲线（新vec3（0,0,0），新vec3（20,20,0））; // y = x曲线（新vec3（0,0,0），新vec3（15,20,0））; // y = 1.33x曲线（新vec3（0,0,0），新vec3（10,20,0））; // y = 2x曲线（新vec3（0,0,0），新vec3（5,20,0））; // y = 4x}</p><p>   We can now see just exactly how non-Euclidean this exponential space is: functions that are divergent straight lines in Euclidean space become  convergent curves (converging at our vanishing points), with the exception of axis-aligned and perpendicular-to-axes lines, which retain their straight line behaviour.</p><p>   我们现在可以看到非欧几里德的这种指数空间是：欧几里德空间中发散直线的功能成为收敛曲线（在我们的消失点处会聚），除了轴对齐和垂直于轴线，保留其直线行为。</p><p> Which means that even a simple cube is going to look “nothing like a cube” most of the time. Certainly, if we set up a simple cube with edge length 2 using axis-aligned coordinates, it’ll look like nothing’s different with respect to standard 3D projections:</p><p> 这意味着大多数时候即使是一个简单的立方体也会看起来“没有像多维数据集。当然，如果我们使用轴对齐的坐标设置具有边缘长度2的简单多维数据集，它将看起来与标准3D投影没有什么不同：</p><p>  But if we rotate that same cube just little over the three axes… well…</p><p>  但是，如果我们旋转同样的立方体，那么三个轴就没有......好...</p><p> void  draw ()  {  Vec3  center  =  new  Vec3 ( 1 , 1 , 1 );  drawRotatedCube ( 2 ,  center ,  0.15 ); } void  drawRotatedCube ( double  edge ,  Vec3  center ,  double  angle )  {  Vec3 []  pts  =  getCubePoints ( edge );  for ( Vec3  p  :  pts )  {  p . rotateX ( center ,  angle );  p . rotateY ( center ,  angle );  p . rotateZ ( center ,  angle );  }  drawCube ( pts ); }</p><p> void draw（）{vec3 center =新vec3（1,1,1,1）; TawrotatedCube（2，Center，0.15）; void drawrotatedcube（双边缘，vec3中心，双角度）{vec3 [] pts = getCubepoints（边缘）; for（vec3 p：pts）{p。 Rotatex（中心，角）; p。旋转（中心，角）; p。 Rotatez（中心，角）;绘制猜测（PTS）; }</p><p>   And remember: in world coordinates, none of these edges are actually curved, they’re all straight lines with perfectly straight angles between them. Exponential space just completely ignores that.</p><p>   并记住：在世界坐标中，这些边缘都没有实际弯曲，它们都是直线，它们之间的完全直角。指数空间完全忽略了这一点。</p><p>  It should be pretty obvious by now that strict three point perspective is  incredibly niche. The odds that you’re going to use this for anything, at any point in the future, are basically zero. But it does teach us some interesting things, and maybe those are good inspiration for a future project you don’t know you’ll be working on yet!</p><p>  现在应该非常明显，严格的三点透视是令人难以置信的利基。您将来要在未来任何一点的任何时候将用于任何东西的可能性基本上为零。但它确实教我们一些有趣的东西，也许这些对未来项目的良好灵感来说，你不知道你将在工作！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pomax.github.io/three-point-perspective/">https://pomax.github.io/three-point-perspective/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实施/">#实施</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/strict/">#strict</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>