<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在512字节中拟合第一个 Fitting a Forth in 512 Bytes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fitting a Forth in 512 Bytes<br/>在512字节中拟合第一个 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 04:45:49</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/bd841526d913338edca2b85694daf648.png"><img src="http://img2.diglog.com/img/2021/6/bd841526d913338edca2b85694daf648.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Software is full of circular dependencies if you look deep enough. Compilerswritten in the language they compile are the most obvious example, but not theonly one. To compile a kernel, you need a running kernel. Linkers, buildsystems, shells. Even text editors, if you want to write the code instead ofjust downloading it. How do you break this cycle?  1 Since the  bootstrappingproblem has first come to my attention, I&#39;ve been drawn tothis unique area of software engineering. Not out of fear that someone wouldtry to implement a  trusting trust attack, but simply as an interestingchallenge.</p><p>如果你足够深，软件充满了循环依赖关系。他们编译的语言编译是最明显的例子，而不是一个人。要编译内核，需要运行内核。链接器，构建系统，shell。即使是文本编辑器，如果要编写代码而不是下载它。你如何打破这个循环？ 1自引导问题首先引起我的注意，我已经被绘制了Tothis独特的软件工程领域。并非害怕有人会潜入信任的信任攻击，但只是作为一个有趣的一片。</p><p> 11 years ago,   vanjos72 described on Reddit what hecalls a thought experiment: what if you were locked in a room with an IBM PC,with no operating system on it? What would be the minimum amount of softwareyou&#39;d need to start out with to bootstrap back into comfort?</p><p> 11年前，vanjos72在Reddit上描述了什么HECALL一个思想实验：如果你被锁定在带有IBM PC的房间里，没有操作系统？什么是软件＆＃39的最小量; D需要从举起恢复舒适？</p><p> As it happens, I&#39;ve recently found myself with an abundance of free time on myhands, so I&#39;ve decided to make this more than a thought experiment. Alas, mycomputer didn&#39;t come equipped with front panel switches, so some software needs tobe present on the computer already...</p><p> 正如它所发生的那样，我最近发现自己有丰富的空闲时间，所以我决定使这个不仅仅是一个思想的实验。唉，我的计算机没有配备前面板开关，所以一些软件需要在电脑上存在......</p><p> The absolutely minimal option would be a simple program that accepts input fromthe keyboard, and then jumps to it. Since the keyboard input routines in theBIOS implement alt+numpad escape codes, you don&#39;t even need to write any baseconversion code.  2 Moreover, the loop doesn&#39;t even need an endcondition — just write to the buffer backwards until you run into the existingcode and overwrite the jump target. This approach takes a mere 14 bytes:</p><p> 绝对最小的选项将是一个接受键盘输入的简单程序，然后跳转到它。由于TheBIOS中的键盘输入例程实现ALT + NUMPAD转义代码，因此您甚至需要编写任何基础译码代码。 2此外，循环甚至需要一个endcondition  - 刚刚向后写入缓冲区，直到您运行到现有代码并覆盖跳转目标。这种方法仅占14个字节：</p><p> 6a00  push  word  0 07  pop  es fd  std bf1e7c  mov  di ,  buffer + 16  ; Adjust to taste. Beware of fenceposting.  input_loop: b400  mov  ah ,  0 cd16  int  0x16 aa  stosb ebf9  jmp  short input_loop buffer:</p><p> 6A00按下WORD 0 07 POP ES FD STD BF1E7C MOV DI，缓冲+ 16;调整味道。谨防围栏。 INPUT_LOOP：B400 MOV AH，0 CD16 INT 0x16 AA STOSB EBF9 JMP SHORT INPUT_LOOP缓冲区：</p><p> However, I do not find the prospect of entering code this way anywhere nearappealing. I&#39;ve decided that, since the BIOS loads an entire sector anyway, anybootstrap seed that fits into the bootsector is fair game.  3 Obviously,one would want to maximize the utility of the chosen program. What is the mostpowerful thing we can fit in 510 bytes?</p><p> 但是，我在任何地方都没有找到进入代码的前景。我决定，由于BIOS无论如何，BIOS加载整个扇区，适合Bootsector的AnyBootstrap种子是公平的游戏。 3显然，人们希望最大化所选程序的效用。我们可以适用于510字节的大多数动力是什么？</p><p> Many interesting sector-sized programs have been written by Oscar Toledo. Thisincludes many games, such as  a DooM-like raycasting game or a chess AI, as well as a basic  BASIC interpreter, butthe most perhaps the most relevant one for our usecase is  bootOS:</p><p> 许多有趣的部门大小的计划是由OSCAR TOLEDO编写的。这是许多游戏，例如厄运射线游戏或国际象棋AI，以及基本的基本解释器，但最多可能是我们的usecase最相关的游戏是bootos： </p><p> bootOS is a monolithic operating system that fits in one boot sector. It&#39;sable to load, execute, and save programs. Also keeps a filesystem.</p><p>BOOTOS是一个单片操作系统，适合一个引导扇区。它＆＃39;加载，执行和保存程序。还保留文件系统。</p><p> It exposes its filesystem routines with an interrupt interface, and includes abuiltin command that allows creating a file by typing in its hexdump. Very neat,but clearly mostly intended as a multiplexer between other sector-sizedprograms. What I would seek is a solution that minimizes typing inhand-assembled machine code. Ideally, it would be a programming language, butone that, unlike BASIC, can be extended at runtime. If you&#39;ve read the title ofthis post, you already know what I settled on — as it turns out, it&#39;s possibleto fit a barebones FORTH in a bootsector. You can see the code in the  Miniforthrepository on GitHub, but I will include most of it here.</p><p> 它通过中断接口公开其文件系统例程，并包括Abuiltin命令，允许通过在其hexdump中键入创建文件。非常整洁，但显然主要是在其他扇区规模的中编程之间作为多路复用器。我想寻求的是一种最小化in手中的机器代码的解决方案。理想情况下，它将是一个编程语言，武器，与基本不同，可以在运行时扩展。如果你＆＃39; ve阅读了这个帖子的标题，你已经知道我解决了什么 - 事实证明，它＆＃39; s possibleto在一个靴子中赤裸上身。您可以在GitHub上看到MiniforthRepository中的代码，但我将在此处包含大部分内容。</p><p> The entire FORTH takes, at this moment, 504 bytes. As you might expect, thedevelopment process involved being on a perpetual lookout for byte-savingopportunities. However, when I published what I thought was quite tightlyoptimized code,  Ilya Kurdyukov came along and managed to find 24 bytesto be saved! I promptly reinvested this saved space in new features.</p><p> 整个迫切需要，此时，504个字节。正如您所希望的那样，发育过程涉及到百分比储蓄零件的永久监视。但是，当我发布了我的想法是非常密切的代码时，伊利亚库尔德鲁克夫夫人来到并设法找到了24个Bytesto！我迅速将这一保存的空间迅速重新投资于新功能。</p><p>   FORTH is a stack-based language. For example, a number will push its value ontothe stack, while the  +  word will pop two numbers and push their sum. Acommon debugging utility, but one not included in Miniforth, is the .s word, which prints the contents of the stack.</p><p>   是基于堆栈的语言。例如，数字将推动其值Ontothe堆栈，而+ Word将弹出两个数字并推动其总和。 Acommon调试实用程序，但其中不包含在Miniforth中的是.s Word，它打印堆栈的内容。</p><p>    This defines the word  double, which does the same thing as  dup +.  dup, bythe way, is one of FORTH&#39;s stack manipulation words. It duplicates the topelement on the stack:</p><p>    这定义了双倍的单词，它与DUP +相同。顺便说一句，是堆栈的操纵词。它重复堆栈上的TopElement：</p><p>  This is basically the entire language. There are some standard facilities forconditionals and loops, but we don&#39;t need to concern ourselves with those fornow, as they can be built on top of Miniforth later on.</p><p>  这基本上是整个语言。有一些标准的设施，但我们不需要与那些正常的人关心自己，因为它们可以在Miniforth之后建造。</p><p> To talk about the effect a word has on the state of the stack, we use a notationlike this:</p><p> 要谈谈效果，请在堆栈的状态下，我们使用符号： </p><p>  The list before the  -- are the inputs, with the top of stack listed last.After the  --, we list the outputs, which start at the same stack depth.This lets us succintly describe the common aspects of a word.</p><p>在-S中的列表 - 是输入，其中包含堆栈的顶部last.After-，我们列出了同一堆栈深度的输出。这让我们翻译了一个单词的共同方面。</p><p>  While some FORTH systems do include full-blown, optimizing compilers similar tothose one&#39;d see in a typical programming language, there is a much simplerstrategy. After all, everything a FORTH word can do is execute other words, so asequence of  call instructions gets us very close:</p><p>  虽然一些第四种系统确实包括完全吹，优化编译器类似弄脏一个＆＃39; D以典型的编程语言看，有一个简单的策略。毕竟，一切顺义单词可以做的是执行其他单词，所以呼叫指令的序列非常接近：</p><p>  However, this ties up the hardware  x86 stack for the return stack, making ushandroll a separate stack for the actual user-level stack (known as the parameter stack). As accessing the parameter stack is much more common, we&#39;dlike to use the  push and  pop instructions for that, and instead handroll amechanism similar to  call. Firstly, let&#39;s simply store a list of pointers towords:</p><p>  但是，这与返回堆栈的硬件x86堆栈连接起来，使Uhandroll用于实际用户级堆栈的单独堆栈（称为参数堆栈）。访问参数堆栈更常见，我们＆＃39; dlike使用推送和流行指令，而是类似于呼叫的载体活动。首先，让＆＃39; s只是存储一张指针拖车列表：</p><p>  The way this comes to life is that each primitive word fetches the address ofthe next word from memory, and jumps to it. A pointer to this sequence ofpointers is kept in  SI, so that the  lodsw instruction allows for easyprocessing of this list:</p><p>  这方面的生活方式是每个原始词从内存中获取下一个单词的地址，并跳转到它。对此序列的指针保持在SI中，因此LODSW指令允许易于处理此列表：</p><p> DUP:  pop  ax  push  ax  push  ax  lodsw jmp  ax PLUS:  pop  ax  pop  bx  add  ax ,  bx  push  ax  lodsw jmp  ax</p><p> DUP：POP斧推动斧推动斧头LODSW JMP AX PLUS：POP AX POP BX添加AX，BX推轴LODSW JMP AX</p><p>   This mechanism, by the way, is known as  threaded code. No relation to the concurrencyprimitive.</p><p>   顺便问，这种机制被称为线程代码。与康乃馨不相关。</p><p> What happens if one compiled word calls another one, though? This is where thereturn stack comes in. It might feel natural to use the  BP register for thisstack pointer. However, in 16-bit x86, there isn&#39;t actually a  [bp] addressingmode. The closest you can get is  [bp+imm8], which means that accessing thememory at  bp wastes a byte to specify that you do not want an offset. This iswhy I use the  di register for the return stack instead. Overall, this choicesaves 4 bytes.</p><p> 但是，如果一个编译的单词呼叫另一个词，会发生什么？这是它堆栈进来的地方。使用本机指针的BP寄存器可能会自然。但是，在16位x86中，实际上存在一个[bp]寻址码。您最接近的是[BP + IMM8]，这意味着在BP中访问POMMEMORY浪费一个字节以指定您不想要偏移量。这是为什么我使用返回堆栈的DI寄存器。总的来说，这个选择4个字节。 </p><p> Anyway, here is how the return stack is used to handle compiled words calling eachother. Pushing onto the return stack is particularily nice, since it&#39;s just the stosw instruction.</p><p>无论如何，这里是返回堆栈如何用于处理调用彼此的编译单词。推动返回堆栈是很好的，因为它只是stosw教学。</p><p> DOUBLE:  call  DOCOL  dw  DUP  dw  PLUS  dw  EXITDOCOL:  ; short for &#34;do colon word&#34;  xchg  ax ,  si  ; used here as `mov ax, si`, but swaps with ; ax are only one byte, while `mov`s are two bytes  stosw pop  si  ; grab the pointer pushed by `call`  NEXTEXIT:  dec  di  dec  di  mov  si , [ di ]  NEXT</p><p> 双倍：呼叫Docol DW DUP DW Plus DW ExitDocol：; ＆＃34短暂;冒号字和＃34; XCHG AX，SI;在这里用作“Mov Ax，Si`”，但互换;斧头只有一个字节，而`mov`s是两个字节的stosw pop si;抓住由`call` nextexit推出的指针：dec di dec di mov si，[di]下一个</p><p> This is pretty much the execution strategy used by Miniforth, with one simple,but significant improvement — the value on top of the stack is stored in the BX register. This allows skipping a  push and  pop in many primitives:</p><p> 这几乎是Miniforth使用的执行策略，具有一个简单但重要的改进 - 堆栈顶部的值存储在BX寄存器中。这允许在许多原语中跳过推动和流行：</p><p>  One case is still unresolved, though. What happens if a word contains a number,such as  : DOUBLE 2 * ;? This is handled by  LIT, which will fetch the literalthat follows out of the pointer stream:</p><p>  但是，一个案例仍然是未解决的。如果一个单词包含一个数字，例如：double 2 *;？这是通过点亮处理的，这将取出引出指针流的Littleal：</p><p> DOUBLE:  call  DOCOL  dw  LIT ,  2  dw  MULT  dw  EXITLIT:  push  bx  lodsw xchg  bx ,  ax  NEXT</p><p> 双倍：呼叫DOCOL DW LIT，2 DW Mult DW ExitLit：推送BX Lodsw Xchg Bx，AX接下来</p><p>  FORTH needs a way to locate the implementation of the words the user types in.This is the role of the  dictionary. I use a structure similar to many othersmall-scale FORTHs — a singly linked list of word headers, directly prependedbefore the code of each word. Out of tradition, the head of the list is keptin a variable called  LATEST.</p><p>  第四，需要一种方法来定位用户类型的单词的实现。这是字典的作用。我使用类似于许多其他人的结构 -  SMACE  - 单独链接的单词标题列表，直接预先预先预期每个单词的代码。出于传统，列表的头部是keptin一个最新的变量。</p><p>    If a word is marked as  IMMEDIATE, it will be executed immediately, even ifwe&#39;re currently compiling a definition. For example, this is used to implement ;. If a word is marked as  HIDDEN, it is ignored when searching through thedictionary. Apart from being used as a rudimentary encapsulation mechanism, thiscan be used to implement the traditional FORTH semantics where a word definitioncan refer to the previous word with the same name (and  RECURSE is used whenyou want the definition currently being compiled). However, towards the end ofdevelopment, I have removed the code that actually does this from the defaultimplementation of  : and  ;.</p><p>    如果单词标记为立即，它将立即执行，即使是我们＆＃39; RE目前编译一个定义。例如，这用于实施;。如果一个单词被标记为隐藏，则在搜索目的时被忽略它。除了被用作基本的封装机制外，可以使用该方法来实现传统的语义，其中单词定义扫描是指当您希望当前正在编译的定义时使用相同名称（和重复使用的前一词）。但是，在终止的开发结束时，我删除了实际从DefaultImpling的代码：和;。 </p><p>  It is usually not worth it to use compression when both the decompressor and itspayload have to fit in merely 512 bytes. However, in a FORTH implementation, onething that&#39;s repeated very often is the implementation of  NEXT.</p><p>当解压缩器和其斑载荷必须仅适用于512字节时，通常不值得使用压缩。但是，在第四种实施情况下，＆＃39; s重复的常见是下一个的实现。</p><p>  We could try to save some bytes by replacing these with jumps to a shared copy.However, a short jump still takes two bytes — not a significant saving. As itturns out, a special compression scheme that can only handle this one repeatingpattern is worth it, as long as you combine it with the following observation: NEXT is almost always followed by the dictionary entry of the next primitive,of which the link field is predictable.</p><p>  我们可以通过替换这些与共享副本来替换这些字节来保存一些字节。但是，短跳仍然需要两个字节 - 而不是显着的保存。正如ITTURNS OUT，一个专用压缩方案只能处理这个重复型Pattern是值得的，只要您将其与以下观察结合起来，可预测的。</p><p> I chose to implement a compression scheme where every  0xff byte is replacedwith  NEXT, followed by a link field, which is computed based on the previousoccurence of an  0xff byte. This strategy saved 19 bytes when I introducedit.  4</p><p> 我选择实现一个压缩方案，其中每个0xFF字节是替换的，然后是基于0xFF字节的概要计算的链接字段。当我介绍时，此策略保存了19个字节。 4.</p><p> At first, I used a  0x90 byte for this — after all, it&#39;s the opcode of  nop,which I&#39;m definitely not going to be using. However, the byte can still occur inthe immediate bytes of an instruction. It wasn&#39;t a problem at first, but whenthe code was shifting around in memory, various addresses and offsets became 0x90 often enough to be a nuisance.  0xff doesn&#39;t seem to have this problem.</p><p> 起初，我用了一个0x90字节 - 毕竟，它的＆＃39;是nop的操作码，我＆＃39; m绝对不会使用。但是，字节仍然可以发生指令的Intehiate字节。它起初并不是一个问题，但代码在内存中转移，各种地址和偏移量变得0x90，通常足以是一种滋扰。 0xFF似乎有这个问题。</p><p> To create a link, we copy the value of  LATEST to the decompressor output, andupdate  LATEST to point to the word we&#39;ve just written. This can be done in avery compact sequence of instructions, but it still takes enough bytes that itis worthy it to factor it out as a subroutine — it is also used by theimplementation of  :, which creates dictionary entries at runtime.</p><p> 要创建一个链接，我们将最新的值复制到解压缩器输出，Andupdate最新点指向WORD WE＆＃39;刚才写的。这可以以Avery Comply的指令序列完成，但它仍然需要足够的字节，即ITIS值得将其作为子程序因子传输 - 它也被以下内部用于：，它在运行时创建字典条目。</p><p> ; Creates a dictionary linked list link at DI. MakeLink:  mov  ax ,  di  xchg  [ LATEST ],  ax  ; AX now points at the old entry, while ; LATEST and DI point at the new one.  stosw ret</p><p> ;在di创建字典链接列表链接。 Makelink：MOV AX，DI XCHG [最新]，AX;斧头现在在旧的入口点，而不是;新的最新和di点。 Stosw Ret.</p><p> The decompressor used to make use of an interesting trick, where instead of ashort forward jump, an opcode is placed so the immediate argument it requireseats the instructions we want to jump over. That is, instead of</p><p> Decompressor用于利用一个有趣的技巧，而不是ashort前进跳转，opcode被放置，所以它需要跳过的指令。也就是说，而不是 </p><p>   3c  db  0x3c  ; skip the stosb below by comparing its opcode with AL  .write:aa  stosb</p><p>3c db 0x3c;通过将其Opcode与Al .write进行比较：AA STOSB来跳过下面的STOSB</p><p> Thus, if some other code jumps to  .write, the  stosb executes, but thiscodepath just does  cmp al, 0xaa. At first, I didn&#39;t think of the  cmp alinstruction, and a  mov into a throwaway register instead. This  backfiredspectacularily because of my inability to actually picka register that can be safely overwritten.</p><p> 因此，如果某些其他代码跳转到.write，stosb执行，但是该软脚下只是cmp al，0xaa。起初，我想到了CMP alintruction，而是将一个转变为一次性寄存器。这是由于我无法实际选择可以安全地覆盖的寄存器的回收。</p><p> Ilya Kurdyukov then demonstrated  that the same bytecount can be achievedwithout this kind of &#34;magic&#34;. An analogous modification allowedme to remove the other occurence of this trick too. The essence is that insteadof trying to skip over the  stosb, we execute it unconditionally before thecodepaths branch, and then essentially undo it with  dec di if necessary:</p><p> 伊利亚·库尔德鲁科夫然后展示了相同的经历，可以实现这种＆＃34;魔法＆＃34;允许类似的修改，以消除此技巧的另一个发生。这本质是尝试跳过STOSB，我们在ThecodePaths分支机构之前无条件地执行它，然后在必要时基本上撤消Dec DiD：</p><p> SPECIAL_BYTE  equ  0xff  mov  si ,  CompressedData  mov  di ,  CompressedBegin  mov  cx ,  COMPRESSED_SIZE.decompress:  lodsb stosb cmp  al ,  SPECIAL_BYTE  jnz  short .not_special  dec  di  mov  ax ,  0xffad  ; lodsw / jmp ax  stosw mov  al ,  0xe0  stosb call  MakeLink.not_special:  loop  .decompress</p><p> special_byte equ 0xff mov si，compressdata mov di，compresstbegin mov cx，compress_size.decompress：lodsb stosb cmp al，special_byte jnz short .not_special dec di mov ax，0xffad; Lodsw / JMP AX STOSW MOV AL，0xE0 STOSB调用makelink.not_special：循环.decompress</p><p> Actually generating the compressed stream is more involved. Because I want jumpsbetween the compressed and uncompressed portions to work, the assembler needs tobelieve it is writing the code at the location it will actually run. I firstattempted to do this by adjusting the  org after each  SPECIAL_BYTE, butunfortunately, yasm didn&#39;t like that.</p><p> 实际上产生压缩流更涉及。因为我想要将压缩和未压缩的部分跳转到工作，所以汇编程序需要拍摄它正在将其实际运行的位置写入代码。我首次尝试通过调整每个特殊特性后的组织，九个幸福，Yasm ndn＆＃39; t那样。</p><p>  Clearly, a separate post-processing step is necessary. I wrote a macro to shimthe bytes the decompressor will insert:</p><p>  显然，需要单独的后处理步骤。我写了一个宏向垫片字节的解压缩器将插入：</p><p>  This has the added benefit of allowing a simple automated way to verify that no SPECIAL_BYTEs slipped in by accident.</p><p>  这具有允许简单的自动化方法来验证事故中没有滑动的特殊方法。 </p><p> I still had to allocate the space for the compressed data. I choose thefollowing layout:</p><p>我仍然不得不为压缩数据分配空间。我选择关注的布局：</p><p> The decompression buffer is allocated immediately after that, which is where yasm outputs the target contents.</p><p> 在此之后立即分配解压缩缓冲区，该缓冲缓冲区是YASM输出目标内容的位置。</p><p> To achieve this, I needed to know exactly how much space needs to be allocatedfor the compressed data. First, I calculate the exact number of bytes saved byincrementing a counter in the  compression_sentinel macro:</p><p> 为实现这一目标，我需要确切地知道需要为压缩数据分配多少空间。首先，我计算在Compression_sentinel宏中介入计数器保存的确切字节数：</p><p>     SPECIAL_BYTE  =  b &#39; \xff &#39; SENTINEL  =  SPECIAL_BYTE  +  b &#39; \xef\xbe\xad\xde &#39; with  open ( &#39;raw.bin&#39; ,  &#39;rb&#39; )  as  f: data  =  f.read()output_offset  =  data.index( b &#39; \xcc &#39;  *  20 )chunks  =  data[output_offset:].lstrip( b &#39; \xcc &#39; ).split(SENTINEL) assert  SPECIAL_BYTE  not in  chunks[ 0 ]compressed  =  bytearray (chunks[ 0 ]) for  chunk  in  chunks[ 1 :]:  assert  SPECIAL_BYTE  not in  chunk compressed.extend(SPECIAL_BYTE) compressed.extend(chunk) # Make sure that exactly the right amount of space is allocated# for the compressed data. assert  b &#39; \xcc &#39;  *  len (compressed)  in  data assert  b &#39; \xcc &#39;  *  ( len (compressed)  +  1 )  not in  dataoutput  =  data[:output_offset]  +  compressed print ( len (output),  &#39;bytes used&#39; )output  +=  b &#39; \x00 &#39;  *  ( 510  -  len (output))output  +=  b &#39; \x55\xaa &#39; with  open ( &#39;boot.bin&#39; ,  &#39;wb&#39; )  as  f: f.write(output)</p><p>     special_byte = B＆＃39; \ xff＆＃39; sentinel = special_byte + b＆＃39; \ xef \ xbe \ xad \ xde＆＃39;打开（＆＃39; raw.bin＆＃39;＆＃39; rb＆＃39;）作为f：data = f.read（）output_offset = data.index（b＆＃39; \ xcc＆＃39; * 20）Chunks = data [output_offset：]。lstrip（b＆＃39; \ xcc＆＃39;）.split（sentinel）ssuert special_byte不在块[0]压缩= bytearray（块[0]）块块[1：]：assert special_byte不在compress.extend（special_byte）comprettle.extend（chunk）#.确保准确地为压缩数据分配了正确的空间量＃。断言B＆＃39; \ xcc＆＃39; * len（压缩）在数据中断言B＆＃39; \ xcc＆＃39; *（len（压缩）+ 1）不在dataOutput = data [：output_offset] +压缩打印（len（输出），＆＃39;字节使用＆＃39;）输出+ = b＆＃39; \ x00＆＃39; *（510  -  Len（输出））输出+ = B＆＃39; \ x55 \ xaa＆＃39;打开（＆＃39; boot.bin＆＃39;，＆＃39; wb＆＃39;）作为f：f.write（产出）</p><p> The same script also generates an extended disk image, which contains somesmoke-testing code in block 1:</p><p> 相同的脚本还生成扩展磁盘映像，其中包含块1中的SomesMoke-Testing代码：</p><p> output  +=  b &#39; \x00 &#39;  *  512 output  +=  open ( &#39;test.fth&#39; ,  &#39;rb&#39; ).read().replace( b &#39; \n &#39; ,  b &#39; &#39; )output  +=  b &#39; &#39;  *  ( 2048  -  len (output)) with  open ( &#39;test.img&#39; ,  &#39;wb&#39; )  as  f: f.write(output)</p><p> 输出+ = B＆＃39; \ x00＆＃39; * 512输出+ =打开（＆＃39; test.fth＆＃39;，＆＃39; rb＆＃39;）.read（）。替换（b＆＃39; \ n＆＃39;，b＆＃39 ;＆＃39;）输出+ = B＆＃39; ＆＃39; *（2048  -  Len（输出））与开放（＆＃39; test.img＆＃39;＆＃39; wb＆＃39;）作为f：f.write（输出）</p><p> compression_sentinel is most often used by the  defcode macro, which createsthe dictionary entry for a primitive word. It takes a label (which can then beused to jump to the implementation of some word), the name of the word as a string,and optionally, some flags to be ORed into the length field:</p><p> Compression_sentinel最常被Defcode宏用于原始词的Createsthe字典条目。它需要一个标签（然后可以跳转到某些单词的实现），单词作为字符串的名称，以及可选的，要在长度字段中or的一些标志： </p><p> ; defcode PLUS, &#34;+&#34;; defcode SEMI, &#34;;&#34;, F_IMMEDIATE %macro  defcode  2 - 3 0  compression_sentinel %strlen  namelength % 2  db  % 3  | namelength ,  % 2 % 1 : %endmacro</p><p>; defcode plus，＆＃34; +＆＃34 ;; defcode semi，＆＃34 ;;＆＃34;，f_immediate％宏defcode 2  -  3 0 compression_sentinel％strlen nameLength％2 db％3 | NameLength，％2％1：％EndMacro</p><p>  defcode PLUS ,  &#34;+&#34;  pop  ax  add  bx ,  ax defcode MINUS ,  &#34;-&#34;  pop  ax  sub  ax ,  bx  xchg  bx ,  ax defcode PEEK ,  &#34;@&#34;  ; ...</p><p>  defcode plus，＆＃34; +＆＃34; POP AX添加BX，AX DEFCODE减去，＆＃34;  - ＆＃34; POP轴SUB AX，BX XCHG BX，AX DEFCODE PEEK，＆＃34; @＆＃34; ; ......</p><p> However,  DOCOL,  EXIT and  LIT also use the compression mechanism for their NEXTs. Since the link field is still written out, this essentially createsbogus dictionary entries. Fortunately, the first opcode of  EXIT and  LIT hasthe  F_HIDDEN bit set, so this is not a problem:</p><p> 但是，DOCOL，退出和点亮也适用于其下一步的压缩机制。由于链接字段仍然写出，因此基本上创建了CreatesBogus字典条目。幸运的是，退出的第一个操作码和点亮有f_橡钩设置，所以这不是问题：</p><p> CompressedBegin:DOCOL:  xchg  ax ,  si  stosw pop  si  ; grab the pointer pushed by `call`  compression_sentinelLIT:  push  bx  lodsw xchg  bx ,  ax  compression_sentinelEXIT:  dec  di  dec  di  mov  si , [ di ] defcode PLUS ,  &#34;+&#34;  ; ...</p><p> CompressageBegin：Docol：Xchg Ax，Si Stosw Pop Si;抓住由`call` compression_sentinellit推动的指针：推送bx lodsw xchg bx，ax compression_sentinelexit：dec di di mov si，[di] defcode plus，＆＃34; +＆＃34; ; ......</p><p>    This is why Miniforth stores most of its variables in the immediate fields ofinstructions. Of course, this means that the address of these variables willchange on every edit of the code, which is problematic, since we will be wantingto access these variables in FORTH code. The typical way of exposing a variableis to create a word that pushes its address. However, that&#39;s way too expensivewith our constraints. What I settled on is pushing the addresses onto the stackat startup. This can be done with only 2 bytes for each address, by simplydefining the initial contents of the stack as data:</p><p>    这就是为什么Miniforth将其大部分变量存储在Ifstructions的直接字段中。当然，这意味着这些变量的地址将在代码的每一个编辑中都会加速，这是有问题的，因为我们将希望在第四代码中访问这些变量。公开变量的典型方式创建推动其地址的单词。然而，这与我们的制约件有用过于昂贵。我解决了什么是将地址推到Stackat启动上。通过将堆栈的初始内容简单地确定为数据，可以为每个地址仅使用2个字节来完成2个字节：</p><p> org  0x7c00  jmp  0 :startstack:  dw  HERE  dw  BASE  dw  STATE  dw  LATESTstart:  ; ...  mov  sp ,  stack</p><p> ORG 0x7C00 JMP 0：StartStack：DW在此DW Base DW状态DW最新版本：; ... mov sp，堆栈</p><p> Even when a variable&#39;s address needs to be pushed onto the stack, thisself-modifying code strategy saves bytes if a variable needs to be initialized —the best way to initialize a variable is to simply allocate it within thebootsector and  dw the initial value there, which exactly evens out the stackdata, and keeps the advantage of the shorter instruction encoding.</p><p> 即使在堆栈中需要被推到堆栈中，如果需要初始化变量 - 初始化变量的最佳方式，即使需要初始化变量，那么初始化变量的最佳方式并将其分配在BootSector和DW中的最佳方式在那里的价值，它恰好介于堆栈数据，并保持更短的指令编码的优势。 </p><p>  The first thing done after booting is setting up the  segment registers andstack. The direction flag is also cleared, so that the string instructions workin the right direction.</p><p>启动后完成的第一件事正在设置段寄存器和击字机。方向标志也被清除，使字符串指令在正确的方向上工作。</p><p> jmp  0 :start  ; ... start:  push  cs  push  cs  push  cs  pop  ds  pop  es  pop  ss  mov  sp ,  stack  cld</p><p> JMP 0：开始; ......开始：推动CS推送CS推送CS POP DS POP ES POP SS MOV SP，堆栈CLD</p><p> There are a two notable things about this code. Firstly, segment registers areset through the stack. This is a byte-saving trick I&#39;ve picked up from bootBASIC — it allows having to initialize a general-purpose register to zero:</p><p> 这个代码有两个值得注意的事情。首先，段寄存器通过堆栈拍摄。这是一个字节保存的技巧i＆＃39;从bootbasic拾取 - 它允许必须将通用寄存器初始化为零：</p><p> 31c0  xor  ax ,  ax  ; through AX - 8 bytes8ed8  mov  ds ,  ax 8ec0  mov  es ,  ax 8ed0  mov  ss ,  ax 0e  push  cs  ; through the stack - 6 bytes0e  push  cs 0e  push  cs 1f  pop  ds 07  pop  es 17  pop  ss</p><p> 31C0 XOR AX，AX;通过AX-8 BYTES8ED8 MOV DS，AX 8EC0 MOVE ES，AX 8ED0 MOV SS，AX 0E推动CS;通过堆栈 -  6 Bytes0e推送CS 0E推送CS 1F POP DS 07 POP ES 17 POP SS</p><p> Secondly, one would think that, while the stack is being repointed, a small racecondition window occurs — if an interrupt happened between  pop ss and  mov sp,chaos could ensue if the previous value of SP was in an unlucky place in memory.Of course, I could just cross my fingers and hope this doesn&#39;t happen if the 2bytes required to wrap this in an  cli/ sti pair were too much. However, itturns out that this trade-off is not necessary due to an obscure corner of thex86 architecture. To quote the Volume 2B of the  x86 Software Developer&#39;s Manual:</p><p> 其次，有人会认为，虽然堆栈正在被牢固，但发生一个小的raceCondition窗口 - 如果Pop SS和MOV SP之间发生中断，则可以随之而来，如果SP的先前值在内存中的不幸位置，则可以随之而来。 ，我可以越过我的手指，希望这不发生这种情况，如果在CLI / STI对中包装的2Bytes太多了。但是，由于X86架构的晦涩角落，这是不需要这种权衡。引用X86软件开发人员的第2B卷＆＃39; S手册：</p><p> Loading the SS register with a POP instruction  5 suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (POP ESP)  6 before an event can be delivered.</p><p> 使用POP指令5加载SS寄存器抑制或禁止某些调试异常，并禁止以下指令边界上的中断。 （禁止在交付异常或执行下一个指令后结束。）此行为允许将堆栈指针加载到ESP寄存器中，并在可以传递事件之前将其加载到ESP寄存器中。</p><p> After the segments, stack and direction flag are set up, the decompressor isran. Crucially, it does not use the DL register, which contains the BIOS disknumber from which we were booted. It is then poked into the implementation of load (which is in the compressed segment), and pushed onto the stack for lateruse by user code:</p><p> 在分段后，设置堆栈和方向标志，解压缩器ISRAN。至关重要的是，它不使用DL寄存器，其中包含我们启动的BIOS DiskNumber。然后将其戳进入负载（其在压缩段中），并按用户代码被推到堆叠上，以供Loxuse： </p><p>   At this point, we reach the  outer interpreter - the part of a FORTH systemthat processes user input. The name &#34; outer interpreter&#34; distinguishes it fromthe  inner interpreter, which is the component that coordinates the executionwithin a defined word, and consists of  NEXT,  DOCOL,  EXIT, and  LIT.</p><p>此时，我们到达外部解释器 - 第四个系统的一部分处理用户输入。姓名＆＃34;外翻员＆＃34;将其与内部解释器区分开，这是协调所定义的单词的executionWithIn的组件，并且由下一个，docol，退出和点燃组成。</p><p> Normally, a FORTH would expose the building blocks of its outer interpreter aswords in the dictionary, such as</p><p> 通常，第一个将公开其外解释器ASWORD在字典中的构建块，例如</p><p>  In Miniforth, no attention is paid to this practice at all. Dictionary headerscost bytes, and so does communicating only through the stack. In fact,  WORDand  &gt;NUMBER are melded together into one routine that does the job of both —that way, the loop can be shared, which saves bytes.</p><p>  在Miniforth，根本没有注意这种做法。字典标题字节，因此只通过堆栈通信。事实上，Wordand＆gt;数字被融合到一个例程中，这两个例程都是 - 该方法，可以共享循环，保存字节。</p><p> This monolithic architecture also lets us decide that  BX and  DI are notreserved for the top of stack and the return stack pointer, respectively, whilethe outer interpreter is executing. This significantly helps with registerstarvation within these comparatively complex parts of the system. Theseregisters are set up just before jumping to a word, and saved after it returns.</p><p> 这种单片架构也让我们决定为堆栈顶部和返回堆栈指针的顶部并决定BX和DI，而外部解释器正在执行。这显着有助于在这些相对复杂的系统中的注册过程中的透析性。在跳转到一个单词之前，同学设置并在返回后保存。</p><p>  After initialization is completed, the code falls through to  ReadLine, theroutine for reading in an input line from the keyboard. We will also jump backhere later, when the current line of input is exhausted. The input buffer is at 0x500, directly after the  BDA. While the idiomatic string format for FORTHuses a separate length field, this buffer is NULL-terminated, as that is easierto handle when parsing. The pointer to the unparsed fragment of the input isstored in  InputPtr, which is the only variable which does  not use theself-modification technique, as it does not need to be explicitly initialized —it naturally gets written to before it is read.</p><p>  初始化完成后，代码通过读取线路，以便在从键盘中读取输入行。我们稍后还会跳回回路，当前输入线耗尽时。输入缓冲区在BDA之后直接在0x500。虽然惯用字符串格式为一个单独的长度字段，但此缓冲区为null终止，因为解析时是Easierto句柄。指向InputPTR中输入的输入的未降级片段，这是唯一不使用撰写撰写的变量，因为它不需要明确初始化 - 自然地写入读取之前。</p><p> InputBuf  equ  0x500 InputPtr  equ  0xa02  ; dw ReadLine:  mov  di ,  InputBuf  mov  [ InputPtr ],  di . loop :  mov  ah ,  0  int  0x16  cmp  al ,  0x0d  je  short . enter stosb cmp  a</p><p> INPUTBUF EQU 0x500 INPUTPTR EQU 0xA02; DW Readline：MOV DI，INPUTBUF MOV [INPUTPTR]，DI。循环：MOV AH，0 INT 0x16 CMP al，0x0d je short。输入stosb cmp a</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://niedzejkob.p4.team/bootstrap/miniforth/">https://niedzejkob.p4.team/bootstrap/miniforth/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字节/">#字节</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fitting/">#fitting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>