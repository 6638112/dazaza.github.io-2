<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>锈病时误差 - 深度潜水 Error Handling in Rust – A Deep Dive</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Error Handling in Rust – A Deep Dive<br/>锈病时误差 - 深度潜水 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 06:42:45</div><div class="page_narrow text-break page_content"><p>This article is a sample from   Zero To Production In Rust, a book on backend development in Rust. You can get a copy of the book on  zero2prod.com.  Subscribe to the newsletter to be notified when a new episode is published.</p><p>本文是零中的零生产中的一个样本，一本锈病的后端开发书。您可以在Zero2Prod.com上获取这本书的副本。订阅新闻稿发布时要通知的时事通知。</p><p>  To send a confirmation email you have to stitch together multiple operations: validation of user input, email dispatch, various database queries. They all have one thing in common: they may fail.</p><p>  要发送确认电子邮件，您必须拼接多个操作：用户输入验证，电子邮件调度，各种数据库查询。他们都有一个共同点：他们可能会失败。</p><p> In  Chapter 6 we discussed the building blocks of error handling in Rust -  Result and the  ? operator. We left many questions unanswered: how do errors fit within the broader architecture of our application? What does a  good error look like? Who are errors for? Should we use a library? Which one?</p><p> 在第6章中，我们讨论了锈病中误差处理的构建块 - 结果？操作员。我们留下了许多问题：错误如何适应我们申请的更广泛的架构中？良好的错误是什么样的？谁是错误的？我们应该使用图书馆吗？哪一个？</p><p> An in-depth analysis of error handling patterns in Rust will be the sole focus of this chapter.</p><p> 对Rust中的错误处理模式的深入分析将是本章的唯一重点。</p><p>     //! src/routes/subscriptions.rs// [...] pub  async  fn  store_token (  transaction : &amp; mut  Transaction&lt;&#39;_, Postgres&gt;,  subscriber_id : Uuid,  subscription_token : &amp; str ,) -&gt; Result&lt;(), sqlx::Error&gt; { sqlx::query!(  r #&#34;  INSERT INTO subscription_tokens (subscription_token, subscriber_id) VALUES ($1, $2)  &#34;#, subscription_token, subscriber_id ) . execute (transaction) .await . map_err (| e | { tracing::error!(&#34; Failed to execute query: {:?} &#34;, e); e })?; Ok(())}</p><p>     // src /路由/订阅.rs // [...] pub async fn store_token（事务：＆amp; mut事务＆lt; postgres＆gt;，subscriber_id：uuid，subscription_token：＆amp; str，） - ＆gt;结果＆lt;（），sqlx ::错误＆gt; {sqlx ::查询！（r＃＆＃34;插入subscription_tokens（subscription_token，subscriber_id）值（$ 1，$ 2）＆＃34;＃，subscription_token，subscriber_id）。执行（事务）.Await。 map_err（| e | {追踪::错误！（＆＃34;无法执行查询：{：？}＆＃34; e）; e}）？好的（（））}</p><p> We are trying to insert a row into the  subscription_tokens table in order to store a newly-generated token against a  subscriber_id.  execute is a fallible operation: we might have a network issue while talking to the database, the row we are trying to insert might violate some table constraints (e.g. uniqueness of the primary key), etc.</p><p> 我们正试图将行插入Subscription_Tokens表中，以便对Subscriber_ID存储新生成的令牌。 Execute是一个难以犯的操作：我们可能会在与数据库交谈时有一个网络问题，我们尝试插入的行可能会违反一些表约束（例如，主键的唯一性）。</p><p>   The caller of  execute most likely wants to be informed if a failure occurs -  they need to  react accordingly, e.g. retry the query or propagate the failure upstream using  ?, as in our example.</p><p>   如果发生故障，则执行的呼叫者最有可能被告知 - 他们需要相应地反应，例如，重试查询或传播上游的故障？，如在我们的示例中。 </p><p> Rust leverages the type system to communicate that an operation may not succeed: the return type of  execute is  Result, an enum.</p><p>Rust利用类型系统进行通信，操作可能不会成功：返回类型的执行是结果，枚举。</p><p>  The caller is then forced by the compiler to express how they plan to handle both scenarios - success and failure.</p><p>  然后，编译器强制调用者以表达他们计划如何处理这两种情况 - 成功和失败。</p><p> If our only goal was to communicate to the caller that an error happened, we could use a simpler definition for  Result:</p><p> 如果我们唯一的目标是与呼叫者沟通发生错误发生的错误，我们可以使用更简单的定义：</p><p>  There would be no need for a generic  Error type - we could just check that  execute returned the  Err variant, e.g.</p><p>  不需要通用错误类型 - 我们可以检查执行返回的ERR VAR，例如，</p><p> let  outcome = sqlx::query!( /* ... */ )	. execute (transaction)	.await; if  outcome == ResultSignal::Err { 	 // Do something if it failed }</p><p> 让结果= sqlx ::查询！（/ * ... * /）。执行（事务）.await;如果Outcome == CapeignAlal :: Err {//如果失败}</p><p> This works if there is only one failure mode.Truth is, operations can fail in  multiple ways and we might want to react  differently depending on what happened. Let&#39;s look at the skeleton of  sqlx::Error, the error type for  execute:</p><p> 这是有效的，如果只有一个失败模式.TRUTH是，操作可以以多种方式失败，我们可能希望根据发生的方式反应不同的反应。让＆＃39;查看SQLX ::错误的骨架，Execute的错误类型：</p><p> //! sqlx-core/src/error.rs  pub enum  Error { Configuration( /* */ ), Database( /* */ ), Io( /* */ ), Tls( /* */ ), Protocol( /* */ ), RowNotFound, TypeNotFound { /* */ }, ColumnIndexOutOfBounds { /* */ }, ColumnNotFound( /* */ ), ColumnDecode { /* */ }, Decode( /* */ ), PoolTimedOut, PoolClosed, WorkerCrashed, Migrate( /* */ ),}</p><p> // sqlx-core / src / error.rs pub枚举错误{configuration（/ * * /），数据库（/ * /），IO（/ * * /），TLS（/ * * /），协议（/ * * /），townotfound，typenotfound {/ * * /}，columentexoutofbounds {/ * * /}，columnnotfound（/ * * /），columndecode {/ * * /），解码（/ * * /），pooltimedout，poollosed，workercrashed ，迁移（/ * * /），} </p><p> Quite a list, ain&#39;t it?  sqlx::Error is implemented as an enum to allow users to match on the returned error and behave  differently depending on the underlying failure mode. For example, you might want to retry a  PoolTimedOut while you will probably give up on a  ColumnNotFound.</p><p>相当列表，AIN＆＃39; t呢？ SQLX ::错误实现为枚举，以允许用户在返回的错误上匹配，并根据底层的故障模式表现不同。例如，当您可能放弃ColumnNotFound时，您可能希望重试PoolTimedOut。</p><p>  What if an operation has a single failure mode - should we just use  () as error type?</p><p>  如果操作具有单个故障模式，那么什么 - 如果我们只是使用（）作为错误类型？</p><p> Err(()) might be enough for the caller to determine what to do - e.g. return a  500 Internal Server Error to the user.</p><p> err（（））可能足以让呼叫者确定该做什么 - 例如。向用户返回500个内部服务器错误。</p><p> But control flow is not the  only purpose of errors in an application. We expect errors to carry enough  context about the failure to produce a  report for an operator (e.g. the developer) that contains enough details to go and troubleshoot the issue.</p><p> 但是控制流不是应用程序中错误的唯一目的。我们希望错误对未能为运营商（例如开发人员）生成报告来带有足够的上下文，其中包含足够的细节以进行解决和排除问题。</p><p> What do we mean by report? In a backend API like ours it will usually be a log event. In a CLI it could be an error message shown in the terminal when a  --verbose flag is used.</p><p> 报告我们的意思是什么？在像我们这样的后端API中，它通常是日志事件。在CLI中，当使用verbose标志时，它可能是终端中显示的错误消息。</p><p> The implementation details may vary, the purpose stays the same: help a  human understand what is going wrong. That&#39;s exactly what we are doing in the initial code snippet:</p><p> 实施细节可能有所不同，目的保持不变：帮助人类了解出现问题。那个＆＃39;究竟在初始代码段中我们正在做什么：</p><p> //! src/routes/subscriptions.rs// [...] pub  async  fn  store_token ( /* */ ) -&gt; Result&lt;(), sqlx::Error&gt; { sqlx::query!( /* */ ) . execute (transaction) .await . map_err (| e | { tracing::error!(&#34; Failed to execute query: {:?} &#34;, e); e })?;	 // [...] }</p><p> // src /路线/订阅.rs // [...] pub async fn store_token（/ * * /） - ＆gt;结果＆lt;（），sqlx ::错误＆gt; {sqlx ::查询！（/ * * /）。执行（事务）.Await。 map_err（| e | {追踪::错误！（＆＃34;无法执行查询：{：？}＆＃34; e）; e}）？ // [...]} </p><p> If the query fails, we grab the error and emit a log event. We can then go and inspect the error logs when investigating the database issue.</p><p>如果查询失败，我们抓取错误并发出日志事件。然后，我们可以在调查数据库问题时转到并检查错误日志。</p><p>   So far we focused on the internals of our API - functions calling other functions and operators trying to make sense of the mess after it happened. What about users?</p><p>   到目前为止，我们专注于我们的API函数的内部，调用其他函数和运营商试图在发生之后感受到混乱。用户怎么样？</p><p> Just like operators, users expect the API to  signal when a failure mode is encountered.</p><p> 就像运营商一样，用户期望API在遇到故障模式时发出信号。</p><p> What does a user of our API see when  store_token fails? We can find out by looking at the request handler:</p><p> 我们的API用户是什么时候看到Store_Token失败的？我们可以通过查看请求处理程序来了解：</p><p> //! src/routes/subscriptions.rs// [...] pub  async  fn  subscribe ( /* */ ) -&gt; Result&lt;HttpResponse, HttpResponse&gt; {	 // [...]  store_token (&amp; mut  transaction, subscriber_id, &amp;subscription_token) .await . map_err (|_| HttpResponse::InternalServerError(). finish ())?;  // [...] }</p><p> // src /路线/订阅.rs // [...] pub异步fn订阅（/ * * /） - ＆gt;结果＆lt; httpresponse，httpresponse＆gt; {// [...] Store_Token（＆amp; mut事务，subscriber_id，＆amp; subscription_token）.await。 map_err（| _ | httpresponse :: internalservererror（）。完成（））？ // [...]}</p><p> They receive an HTTP response with no body and a  500 Internal Server Error status code.</p><p> 它们收到了HTTP响应，没有身体和500个内部服务器错误状态代码。</p><p> The status code fulfills the same purpose of the error type in  store_token: it is a machine-parsable piece of information that the caller (e.g. the browser) can use to determine what to do next (e.g. retry the request assuming it&#39;s a transient failure).</p><p> 状态代码符合Store_Token中错误类型的相同目的：它是调用者（例如浏览器）可以用于确定下一步的机器可解释的信息（例如，假设＆＃39重试请求＆＃39; sa瞬态失败）。 </p><p> What about the human behind the browser? What are we telling them? Not much, the response body is empty. That is actually a good implementation: the user should not have to care about the internals of the API they are calling - they have no mental model of it and no way to determine why it is failing. That&#39;s the realm of the operator. We are  omitting those details by design.</p><p>浏览器背后的人呢？我们在告诉他们什么？不多，响应体是空的。这实际上是一个良好的实现：用户不应该小心他们所呼叫的API的内部 - 它们没有它的心理模型，无法确定它失败的原因。那个＆＃39;是操作员的领域。我们通过设计省略这些细节。</p><p> In other circumstances, instead, we  need to convey additional information to the human user. Let&#39;s look at our input validation for the same endpoint:</p><p> 相反，在其他情况下，我们需要向人类用户传达其他信息。让＆＃39;查看我们同一端点的输入验证：</p><p> //! src/routes/subscriptions.rs #[ derive (serde::Deserialize)] pub struct  FormData {  email : String,  name : String,} impl  TryInto&lt;NewSubscriber&gt;  for  FormData {  type  Error = String;  fn  try_into ( self ) -&gt; Result&lt;NewSubscriber,  Self:: Error&gt; {  let  name = SubscriberName::parse( self .name)?;  let  email = SubscriberEmail::parse( self .email)?; Ok(NewSubscriber { email, name }) }}</p><p> // src /路由/订阅.rs＃[派生（serde :: deserialize）] pub struct formdata {email：string，name：string，} islich tryinto＆lt; needubscriber＆gt; for formdata {类型错误=字符串; fn try_into（self） - ＆gt;结果＆lt; needubscriber，self ::错误＆gt; {让name = subscribername :: parse（self .name）？让电子邮件= subscriberemail :: parse（self .email）？ OK（Newsubscriber {eament，name}）}}}</p><p> We received an email address and a name as data attached to the form submitted by the user. Both fields are going through an additional round of validation -  SubscriberName::parse and  SubscriberEmail::parse. Those two methods are fallible - they return a  String as error type to explain what has gone wrong:</p><p> 我们收到了电子邮件地址和名称，作为附加到用户提交的表单的数据。两个字段都经历了一轮验证 -  Subscribername :: Parse和SubscriberEmail :: Parse。这两种方法是缺乏缺乏的 - 它们将一个字符串作为错误类型返回，以解释出了什么问题：</p><p> //! src/domain/subscriber_email.rs// [...] impl  SubscriberEmail {  pub fn  parse ( s : String) -&gt; Result&lt;SubscriberEmail, String&gt; {  if  validate_email (&amp;s) { Ok( Self (s)) }  else  { Err(format!(&#34; {}  is not a valid subscriber email. &#34;, s)) } }}</p><p> // src / domain / subscriber_email.rs // [...] icluberifer email {pub fn parse（s：string） - ＆gt;结果＆lt; subscriberemail，string＆gt; {如果validate_email（＆amp; s）{好（self（s））} else {err（格式！（＆＃34; {}不是有效的订阅者电子邮件。＆＃34;，s））}}}}}}}}</p><p> It is, I must admit, not the most useful error message: we are telling the user that the email address they entered is wrong, but we are not helping them to determine  why. In the end, it doesn&#39;t matter: we are not sending any of that information to the user as part of the response of the API - they are getting a  400 Bad Request with no body.</p><p> 它是，我必须承认，不是最有用的错误消息：我们正在告诉用户他们输入的电子邮件地址是错误的，但我们没有帮助他们确定原因。最终，它不得不重要：我们没有将任何信息作为API的响应的一部分发送给用户 - 它们获得了一个400个不良请求，没有身体。</p><p> //! src/routes/subscription.rs// [...] pub  async  fn  subscribe ( /* */ ) -&gt; Result&lt;HttpResponse, HttpResponse&gt; {  let  new_subscriber = form . 0  . try_into () . map_err (|_| HttpResponse::BadRequest(). finish ())?;	 // [...]</p><p> // SRC /路由/订阅.s // [...] PUB Async Fn订阅（/ * * /） - ＆gt;结果＆lt; httpresponse，httpresponse＆gt; {让rem_subscriber =表单。 0。 try_into（）。 map_err（| _ | httpresponse :: badrequest（）。完成（））？ // [...] </p><p> This is a poor error: the user is left in the dark and cannot adapt their behaviour as required.</p><p>这是一个错误的错误：用户留在黑暗中，无法根据需要调整其行为。</p><p>      Control flow is scripted: all information required to take a decision on what to do next must be accessible to a  machine. We use types (e.g. enum variants), methods and fields for internal errors. We rely on status codes for errors at the edge.</p><p>      控制流程是脚本：在机器中可以访问接下来的要做的决定所需的所有信息。我们使用类型（例如枚举变体），用于内部错误的方法和字段。我们依赖于边缘处错的状态代码。</p><p> Error reports, instead, are primarily consumed by  humans. The content has to be tuned depending on the audience. An operator has access to the internals of the system - they should be provided with as much  context as possible on the failure mode. A user sits outside the boundary of the application  2: they should only be given the amount of information required to adjust  their behaviour if necessary (e.g. fix malformed inputs).</p><p> 相反，错误报告主要由人类消耗。必须根据受众调整内容。操作员可以访问系统的内部结构 - 它们应在故障模式下尽可能多地提供。用户坐在应用程序2的边界之外：如果需要，它们只能给出调整其行为所需的信息量（例如，修复格式错误的输入）。</p><p> We can visualise this mental model using a 2x2 table with  Location as columns and  Purpose as rows:</p><p> 我们可以使用2x2表可视化此心理模型，其中包含列和目的作为行：</p><p>  We will spend the rest of the chapter improving our error handling strategy for each of the cells in the table.</p><p>  我们将花费剩下的章节提高表中每一个单元格的错误处理策略。</p><p>  Let&#39;s start with error reporting for operators. Are we doing a good job with logging right now when it comes to errors?</p><p>  让＆＃39; s从错误报告开始运算符。在出现错误时，我们现在正在做好伐木工作吗？</p><p>  //! tests/api/subscriptions.rs// [...] #[ actix_rt :: test ]async  fn  subscribe_fails_if_there_is_a_fatal_database_error () {  // Arrange  let  app =  spawn_app ().await;  let  body = &#34; name=le%20guin&amp;email=ursula_le_guin%40gmail.com &#34;;  // Sabotage the database  sqlx::query!(&#34; ALTER TABLE subscription_tokens DROP COLUMN subscription_token; &#34;,) . execute (&amp;app.db_pool) .await . unwrap ();  // Act  let  response = app. post_subscriptions (body. into ()).await;  // Assert  assert_eq!(response. status (). as_u16 (),  500 );}</p><p>  //测试/ API /订阅.rs // [...]＃[ACTIX_RT :: TEST] ASYNC FN SUBSCRIBE_FAILS_IF_THERE_IS_A_FATAL_DATABASE_ERROR（）{//安排留言= spawn_app（）.await;让身体=＆＃34; name = le％20guin＆amp;电子邮件= ursula_le_guin％40gmail.com＆＃34 ;; // sabotage数据库sqlx ::查询！（＆＃34; alter表subscription_tokens drop列subscription_token;＆＃34 ;,）。执行（＆amp; app.db_pool）.aiawait。 unwrap（）; // act让response = app。 post_subscriptions（身体。进入（））。等待; // assert assert_eq！（响应。状态（）。as_u16（），500）;} </p><p> The test passes straight away - let&#39;s look at the log emitted by the application  3.</p><p>测试通过直接传递 - 让＆＃39;查看应用程序3发出的日志。</p><p>  # sqlx logs are a bit spammy, cutting them out to reduce noise export  RUST_LOG =&#34; sqlx=error,info &#34; export  TEST_LOG = enabled cargo  t subscribe_fails_if_there_is_a_fatal_database_error |  bunyan</p><p>  #sqlx日志有点斑点，将它们切割出来减少噪声出口rust_log =＆＃34; sqlx =错误，信息＆＃34; Export Test_log =已启用的Cargo T subscribut_fails_if_there_is_a_fatal_database_error |布尼安</p><p>  INFO: [HTTP REQUEST - START] INFO: [ADDING A NEW SUBSCRIBER - START] INFO: [SAVING NEW SUBSCRIBER DETAILS IN THE DATABASE - START] INFO: [SAVING NEW SUBSCRIBER DETAILS IN THE DATABASE - END] INFO: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - START]ERROR: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - EVENT] Failed to execute query: 		Database(PgDatabaseError { 		 severity: Error, 		 code: &#34;42703&#34;, 		 message: 		 	&#34;column &#39;subscription_token&#39; of relation		 	 &#39;subscription_tokens&#39; does not exist&#34;, 		 ...		})	target=zero2prod::routes::subscriptions INFO: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - END] INFO: [ADDING A NEW SUBSCRIBER - END]ERROR: [HTTP REQUEST - EVENT] Internal Server Error: &#34;&#34; 	log.target=actix_http::responseERROR: [HTTP REQUEST - EVENT] Error encountered while 		processing the incoming HTTP request: &#34;&#34; 	exception.details=&#34;&#34;,	exception.message=&#34;&#34;,	target=tracing_actix_web::middleware INFO: [HTTP REQUEST - END] exception.details=&#34;&#34;, exception.message=&#34;&#34;, target=tracing_actix_web::root_span_builder, http.status_code=500</p><p>  info：[http请求 - 开始]信息：[添加新的订阅者 -  start]信息：[在数据库中保存新的订户详细信息 -  start]信息：[在数据库中保存新订户详细信息 -  END] INFO：[商店订阅令牌在数据库 - 启动]错误：[数据库中的存储订阅令牌 - 事件 - 事件]无法执行查询：数据库（PGDatabaseError {severity：错误，代码：＆＃34; 42703＆＃34;，消息：＆＃34;列＆ ＃39; subscription_token＆＃39;关系＆＃39; subscription_tokens＆＃39;不存在＆＃34; ...}）target = zero2prod ::路由::订阅信息：[在数据库中存储订阅令牌 -  END]信息：[添加新的订户 -  end]错误：[HTTP请求 - 事件]内部服务器错误：＆＃34;＆＃34; log.target = Actix_http :: responseError：[HTTP请求 - 事件]在处理传入的HTTP请求时遇到的错误：＆＃34;＆＃34;例外.details =＆＃34;＆＃34 ;,例外..＆＃34;＆＃34;＆＃34;＆＃34;，tarting = tracing_actix_web :: middleware信息：[http请求 - 结束]例外.details =＆＃34;＆＃ 34;，例外..Message =＆＃34;＆＃34;，target = tracing_actix_web :: root_span_builder，http.status_code = 500</p><p> How do you read something like this? Ideally, you start from the outcome: the log record emitted at the end of request processing. In our case, that is:</p><p> 你如何阅读这样的东西？理想情况下，您从结果开始：在请求处理结束时发出的日志记录。在我们的情况下，即：</p><p>  What does that tell us? The request returned a  500 status code - it failed. We don&#39;t learn a lot more than that: both  exception.details and  exception.message are empty.</p><p>  这告诉我们什么？请求返回了500个状态代码 - 它失败了。我们不仅仅是学习了很多：异常和异常.Message是空的。</p><p> The situation does not get much better if we look at the next two error logs, one emitted by  actix_web itself (via  actix_http) and the other coming from  tracing_actix_web:</p><p> 如果我们查看接下来的两个错误日志，那么情况不会更好，由Actix_Web本身（通过ACTIX_HTTP）和其他来自Tracing_Actix_Web的另一个）发出：</p><p> ERROR: [HTTP REQUEST - EVENT] Internal Server Error: &#34;&#34; 	log.target=actix_http::responseERROR: [HTTP REQUEST - EVENT] Error encountered while 		processing the incoming HTTP request: &#34;&#34; 	exception.details=&#34;&#34;,	exception.message=&#34;&#34;,	target=tracing_actix_web::middleware</p><p> 错误：[http请求 - 事件]内部服务器错误：＆＃34;＆＃34; log.target = Actix_http :: responseError：[HTTP请求 - 事件]在处理传入的HTTP请求时遇到的错误：＆＃34;＆＃34;例外.details =＆＃34;＆＃34 ;,例外..＆＃34;＆＃34;，target = tracing_actix_web :: middleware </p><p> No actionable information whatsoever. Logging &#34;Oops! Something went wrong!&#34; would have been just as useful.</p><p>没有任何可操作的信息。记录＆＃34;哎呀！出了问题！＆＃34;本来就像有用。</p><p>  ERROR: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - EVENT] Failed to execute query: 		Database(PgDatabaseError { 		 severity: Error, 		 code: &#34;42703&#34;, 		 message: 		 	&#34;column &#39;subscription_token&#39; of relation		 	 &#39;subscription_tokens&#39; does not exist&#34;, 		 ...		})	target=zero2prod::routes::subscriptions</p><p>  错误：[数据库中存储订阅令牌 - 事件]无法执行查询：数据库（pgdatabaseError {severity：错误，代码：＆＃34; 42703＆＃34;，消息：＆＃34;列＆＃39; subscription_token＆＃39 ;关系＆＃39; subscription_tokens＆＃39;不存在＆＃34; ...}）target = Zero2Prod ::路由::订阅</p><p> Something went wrong when we tried talking to the database - we were expecting to see a  subscription_token column in the  subscription_tokens table but, for some reason, it was not there. This is actually useful!</p><p> 当我们尝试与数据库交谈时出现了出现问题 - 我们期待在订阅_Tokens表中看到一个订阅列，但由于某种原因，它不是在那里。这实际上是有用的！</p><p> Is it the cause of the  500 though? Difficult to say just by looking at the logs - a developer will have to clone the codebase, check where that log line is coming from and make sure that it&#39;s indeed the cause of the issue. It can be done, but it takes time: it would be much easier if the  [HTTP REQUEST - END] log record reported something useful about the  underlying root cause in  exception.details and  exception.message.</p><p> 这是500的原因吗？只需查看日志很难说 - 开发人员将不得不克隆代码库，检查日志线来自的地方，并确保它确实是问题的原因。它可以完成，但需要时间：如果[HTTP请求 - 结束]日志记录报告了关于底层根本原因的内容以及异常和异常的内容，则会更容易。</p><p>  To understand why the log records coming out  tracing_actix_web are so poor we need to inspect (again) our request handler and  store_token:</p><p>  要了解为什么出来的日志记录出来的tracing_actix_web是如此糟糕，我们需要检查（再次）我们的请求处理程序和Store_Token：</p><p> //! src/routes/subscriptions.rs// [...] pub  async  fn  subscribe ( /* */ ) -&gt; Result&lt;HttpResponse, HttpResponse&gt; {	 // [...]  store_token ( /* */ ) .await . map_err (|_| HttpResponse::InternalServerError(). finish ())?;	 // [...] } pub  async  fn  store_token ( /* */ ) -&gt; Result&lt;(), sqlx::Error&gt; { sqlx::query!( /* */ ) . execute (transaction) .await . map_err (| e | { tracing::error!(&#34; Failed to execute query: {:?} &#34;, e); e })?;	 // [...] }</p><p> // src /路线/订阅.rs // [...] pub异步fn订阅（/ * * /） - ＆gt;结果＆lt; httpresponse，httpresponse＆gt; {// [...] Store_Token（/ * * /）.await。 map_err（| _ | httpresponse :: internalservererror（）。完成（））？ // [...]} PUB Async Fn Store_Token（/ * * /） - ＆gt;结果＆lt;（），sqlx ::错误＆gt; {sqlx ::查询！（/ * * /）。执行（事务）.Await。 map_err（| e | {追踪::错误！（＆＃34;无法执行查询：{：？}＆＃34; e）; e}）？ // [...]}</p><p> The useful error log we found is indeed the one emitted by that  tracing::error call - the error message includes the  sqlx::Error returned by  execute. We propagate the error upwards using the  ? operator, but the chain breaks in  subscribe - we discard the error we received from  store_token ( .map_err(|_| /* */)) and build a bare  500 response that we return as  Err variant from  subscribe to the framework.</p><p> 我们找到的有用错误日志确实是该跟踪::错误调用发出的错误 - 错误消息包括返回的SQLX ::错误。我们使用该错误向上传播错误？操作员，但是链条中的休息 - 我们丢弃了从Store_Token（.map_err（| _ | / * * /）收到的错误，并建立一个裸500响应，以便从订阅框架中返回Err Variant。 </p><p> That  Err(HttpResponse::InternalServerError().finish()) is the only thing that  actix_web and  tracing_actix_web::TracingLogger get to access when they are about to emit their respective log records. The error does not contain any context about the  underlying root cause, therefore the log records are equally useless.</p><p>那个err（httpresponse :: internalservererror（）。finish（））是Actix_Web和Tracing_Actix_Web :: TracingLogger当他们即将发出各自的日志记录时访问的唯一方法。错误不包含关于底层根本原因的任何上下文，因此日志记录同样无用。</p><p>  We need to start leveraging the error handling machinery exposed by  actix_web - in particular,  actix_web::Error.According to the documentation:</p><p>  我们需要开始利用由Actix_Web曝光的错误处理机械 - 特别是Actix_Web :: Error.According到文档：</p><p>  It sounds exactly like what we are looking for.How do we build an instance of   actix_web::Error? The documentation states that</p><p>  它听起来与我们正在寻找的东西。我们是否建立了Actix_Web ::错误的实例？文件指出</p><p>  A bit indirect, but we can figure it out  4. The only  From/ Into implementation that we can use, browsing the ones listed in the documentation, seems to be this one:</p><p>  有点间接，但我们可以弄清楚4.我们可以使用的唯一/进入实施，浏览文档中列出的实施似乎是这个：</p><p> /// Build an `actix_web::Error` from any error that implements `ResponseError` impl &lt;T: ResponseError +  &#39;static &gt; From&lt;T&gt;  for  Error {  fn  from ( err : T) -&gt; Error { Error { cause: Box::new(err), } }}</p><p> ///从任何实现`responseError`的错误构建`contix_web :: serror`：responseError +＆＃39;静态＆gt;来自＆lt; t＆gt;对于错误{fn（err：t） - ＆gt;错误{错误{原因：box :: new（err），}}}</p><p>  /// Errors that can be converted to `Response`. pub trait  ResponseError: fmt::Debug + fmt::Display {  /// Response&#39;s status code. /// /// The default implementation returns an internal server error.  fn  status_code (&amp; self ) -&gt; StatusCode;  /// Create a response from the error. /// /// The default implementation returns an internal server error.  fn  error_response (&amp; self ) -&gt; Response;}</p><p>  ///可以转换为`响应的错误。 Pub Trait ResponseError：FMT :: Debug + FMT ::显示{///响应＆＃39; s状态代码。 /// ///默认实现返回内部服务器错误。 fn status_code（＆amp; self） - ＆gt; statuscode; ///从错误中创建响应。 /// ///默认实现返回内部服务器错误。 fn error_response（＆amp; self） - ＆gt;回复;}</p><p> We just need to implement it for our errors!  actix_web provides a default implementation for both methods that returns a  500 Internal Server Error - exactly what we need. Therefore it&#39;s enough to write:</p><p> 我们只需要为我们的错误实施它！ Actix_Web为两种方法提供默认实现，返回500个内部服务器错误 - 完全是我们所需要的。因此它足够写的＆＃39; </p><p>   error[E0117]:  only traits defined in the current crate 			  can  be implemented for arbitrary types  -- &gt; src/routes/subscriptions.rs:162:1 | 162  |  impl  ResponseError for sqlx::Error {} |  ^^^^^^^^^^^^^^^^^^^^^^^-----------  | | | | | ` sqlx::Error ` is not defined in the current crate |  impl  doesn&#39; t use only types from inside the current crate | = note: define and implement a trait or new type instead</p><p>错误[e0117]：只有当前箱子中定义的特征只能为任意类型实现 - ＆gt; SRC /路由/订阅.RS：162：1 | 162 | icharm responseerror for sqlx ::错误{} | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------- | | | | | `sqlx ::错误`未在当前的箱子中定义| ichildn＆＃39; T仅使用当前箱内内部的类型| =注意：定义和实现特征或新类型</p><p> We just bumped into  Rust&#39;s orphan rule: it is forbidden to implement a foreign trait for a foreign type, where foreign stands for &#34;from another crate&#34;. This restriction is meant to preserve coherence: imagine if you added a dependency that defined its own implementation of  ResponseError for  sqlx::Error - which one should the compiler use when the trait methods are invoked?</p><p> 我们刚刚碰到了生锈＆＃39;孤儿规则：禁止实施外国类型的外国特质，外国代表＆＃34;来自另一个箱子＆＃34;这种限制旨在保留一致性：如果您添加了为SQLX ::错误的responseerror的responseerror实现了依赖关系，则应在调用特性方法时使用编译器使用哪一个？</p><p> Orphan rule aside, it would still be a mistake for us to implement  ResponseError for  sqlx::Error. We want to return a  500 Internal Server Error when we run into a  sqlx::Error  while trying to persist a subscriber token. In another circumstance we might wish to handle a  sqlx::Error differently.</p><p> 孤儿规则一边，我们仍然是一个错误的SQLX ::错误来实现responseerror。当我们在尝试持有订户令牌时遇到SQLX ::错误时，我们希望返回500个内部服务器错误。在另一种情况下，我们可能希望以不同的方式处理SQLX ::错误。</p><p>  //! src/routes/subscriptions.rs// [...]// Using the new error type! pub  async  fn  store_token ( /* */ ) -&gt; Result&lt;(), StoreTokenError&gt; { sqlx::query!( /* */ ) . execute (transaction) .await . map_err (| e | {		 // [...]		// Wrapping the underlying error  StoreTokenError(e) })?;  // [...] } // A new error type, wrapping a sqlx::Error pub struct  StoreTokenError(sqlx::Error); impl  ResponseError  for  StoreTokenError {}</p><p>  // SRC /路由/订阅.rs // [...] //使用新的错误类型！ PUB Async Fn Store_Token（/ * * /） - ＆gt;结果＆lt;（），storetokenerror＆gt; {sqlx ::查询！（/ * * /）。执行（事务）.Await。 map_err（| e | {// [...] //包装底层错误StoreTokenError（e）}）？ // [...]} //一个新的错误类型，包装SQLX ::错误PUB struct StoreTokeError（SQLX ::错误）; ichar responseerror for storeTokenError {}</p><p>  error[E0277]:  ` StoreTokenError ` doesn&#39; t implement `std::fmt::Display` --&gt; src/routes/subscriptions.rs:164:6 |164 | impl ResponseError for StoreTokenError {} | ^^^^^^^^^^^^^ `StoreTokenError` cannot be formatted with the default formatter | |59 | pub trait ResponseError: fmt::Debug + fmt::Display { | ------------ |			required by this bound in `ResponseError` | = help: the trait `std::fmt::Display` is not implemented for `StoreTokenError`error[E0277]: `StoreTokenError` doesn &#39;t implement ` std::fmt::Debug `  -- &gt; src/routes/subscriptions.rs:164:6 | 164  |  impl  ResponseError for StoreTokenError {} |  ^^^^^^^^^^^^^  ` StoreTokenError ` cannot be formatted using ` {:? }` | | 59  |  pub  trait ResponseError: fmt::Debug + fmt::Display { | ---------- 			required by this bound in ` ResponseError ` | = help: the trait ` std::fmt::Debug ` is not implemented for ` StoreTokenError ` = note: add ` #[derive (Debug) ] ` or manually implement ` std::fmt::Debug `</p><p>  错误[e0277]：`storetokenerror`＆＃39; t实现`std :: fmt ::显示' - ＆gt; SRC /路线/订阅.RS：164：6 | 164 | icharmonatheryror for storeTokenError {} | ^^^^^^^^^^^^^^^菜单不能用默认格式化器格式化| | 59 | PUB TRAIT ReScumentError：FMT :: Debug + FMT ::显示{| | ------------- |在“响应形象”中的绑定需要= help：trait` std :: fmt ::展示：storetokenerror`error [e0277]：`storetokenerror`并不实现`std :: fmt :: debug`  - ＆gt; SRC /路由/订阅.RS：164：6 | 164 | icharmonatheryror for storeTokenError {} | ^^^^^^^^^^^^^^^^`StoreTokenError`无法使用`{：？ “| | | 59 | PUB TRAIT ReScumentError：FMT :: Debug + FMT ::显示{| | ---------在“响应形象”中的界限要求= help：trait` std :: fmt :: debug`未为`storeTokenerror` =注意：添加`＃[派生（debug）]`或手动实现`std :: fmt :: debug`</p><p> We are missing two trait implementations on  StoreTokenError:  Debug and  Display. Both traits are concerned with formatting, but they serve a different purpose.  Debug should return a programmer-facing representation, as faithful as possible to the underlying type structure, to help with debugging (as the name implies). Almost all public types should implement  Debug.  Display, instead, should return a user-facing representation of the underlying type. Most types do not implement  Display and it cannot be automatically implemented with a  #[derive(Display)] attribute.</p><p> 我们在StoreTokenError上缺少两个特质实施：调试和显示。这两个特质都涉及格式化，但它们提供了不同的目的。调试应返回将一个面向程序员的表示，作为潜在类型结构的忠实，以帮助调试（顾名思义）。几乎所有公共类型都应实施调试。相反，显示应返回基础类型的面向用户的表示。大多数类型都不实现显示，无法自动使用＃[派生（显示）]属性。</p><p> When working with errors, we can reason about the two traits as follows:  Debug returns as much informations possible while  Display gives us a brief description of the failure we encountered, with the essential amount of context.</p><p> 使用错误时，我们可以推理如下的两个特征：调试返回尽可能多的信息，同时显示我们遇到的故障，具有必要的上下文。 </p><p>  //! src/routes/subscriptions.rs// [...]// We derive `Debug`, easy and painless. #[ derive (Debug)] pub struct  StoreTokenError(sqlx::Error); impl  std::fmt::Display  for  StoreTokenError {  fn  fmt (&amp; self ,  f : &amp; mut  std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result { write!(			f,			&#34; A database error was encountered while \ trying to store a subscription token. &#34;		) }}</p><p>// src /路由/订阅.rs // [...] //我们派生`调试，容易和无痛。 ＃[派生（debug）] pub struct storetokenerror（sqlx ::ser错）; iclich std :: fmt :: for storetokenerror {fn fmt（＆amp; self，f：＆amp; mut std :: fmt :: formatter＆lt;＆gt;） - ＆gt; std :: fmt ::结果{写！（f，＆＃34;遇到数据库错误，而尝试存储订阅令牌。＆＃34;）}}</p><p>  //! src/routes/subscriptions.rs// [...] pub  async  fn  subscribe ( /* */ ) -&gt; Result&lt;HttpResponse, actix_web::Error&gt; {  // [...] // The `?` operator transparently invokes the `Into` trait // on our behalf - we don&#39;t need an explicit `map_err` anymore.  store_token ( /* */ ).await?;  // [...] }</p><p>  // src /路线/订阅.rs // [...] pub异步fn订阅（/ * * /） - ＆gt;结果＆lt; httpresponse，actix_web ::错误＆gt; {// [...] //“？`operator透明地调用我们代表我们的`to` trait //  - 我们不再需要一个明确的`map_err`。 Store_Token（/ * * /）.await ?; // [...]}</p><p>  # sqlx logs are a bit spammy, cutting them out to reduce noise export  RUST_LOG =&#34; sqlx=error,info &#34; export  TEST_LOG = enabled cargo  t subscribe_fails_if_there_is_a_fatal_database_error |  bunyan</p><p>  #sqlx日志有点斑点，将它们切割出来减少噪声出口rust_log =＆＃34; sqlx =错误，信息＆＃34; Export Test_log =已启用的Cargo T subscribut_fails_if_there_is_a_fatal_database_error |布尼安</p><p> ... INFO: [HTTP REQUEST - END] exception.details= StoreTokenError( Database( PgDatabaseError { severity: Error, code: &#34;42703&#34;, message: &#34;column &#39;subscription_token&#39; of relation &#39;subscription_tokens&#39; does not exist&#34;, ... } ) ) exception.message= &#34;A database failure was encountered while trying to s</p><p> ... info：[http请求 - 结束]例外.details = storetokenerror（pgdatabaseerror {severity：错误，代码：＆＃34; 42703＆＃34;消息：＆＃34;列＆＃39; subscription_token＆＃39 ;关系＆＃39; subscription_tokens＆＃39;不存在＆＃34;，...}））异常.Message =＆＃34;尝试时遇到了数据库故障</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lpalmieri.com/posts/error-handling-rust/">https://www.lpalmieri.com/posts/error-handling-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/深度/">#深度</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/handling/">#handling</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>