<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>InfluxDB将赌注押在Rust和Apache Arrow的下一代数据存储上</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">InfluxDB将赌注押在Rust和Apache Arrow的下一代数据存储上</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 04:09:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/13adc774d7220747f1b03cc994ede446.png"><img src="http://img2.diglog.com/img/2020/11/13adc774d7220747f1b03cc994ede446.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>On November 12, 2013, I gave the first public talk about InfluxDB titled: InfluxDB, an open source distributed time series database. In that talk I introduced InfluxDB and outlined what I meant when I talked about time series: specifically, it was any data that you might ask questions about over time. As examples I presented metrics (which is what people normally think of when you talk about time series), along with financial market data, user analytics data, log data, events, and even Twitter timelines. More broadly, I claimed that  all data you perform analytics on is time series data. Meaning, anytime you’re doing data analysis, you’re doing it either over time or as a snapshot in time.</p><p>2013年11月12日，我做了第一次关于InfluxDB的公开演讲，题目是：InfluxDB，一个开源的分布式时间序列数据库。在那次演讲中，我介绍了InfluxDB，并概述了我谈到时间序列时的意思：具体地说，它是您在一段时间内可能会问到的任何数据。作为例子，我提供了指标(这是人们在谈论时间序列时通常会想到的)，以及金融市场数据、用户分析数据、日志数据、事件，甚至Twitter时间线。更广泛地说，我声称你分析的所有数据都是时间序列数据。这意味着，任何时候你在做数据分析，你要么是随着时间的推移而做的，要么是作为时间的快照来做的。</p><p> In this post, I’m going to lay out a vision for the future of InfluxDB and introduce you to a new project that will form the basis of it: InfluxDB IOx ( pronounced eye-ox, short for iron oxide). As the title of the post says, this new project is written in  Rust (iron oxide, natch) with  Apache Arrow as the core. Before I do a deeper dive into the project and its underlying technology, I’d like to look at what the original goals of InfluxDB were and how things have changed since its introduction to the world seven years ago.</p><p>在这篇文章中，我将对InfluxDB的未来进行展望，并向您介绍一个将构成其基础的新项目：InfluxDB IOx(发音为Eye-ox，是氧化铁的缩写)。正如帖子的标题所说，这个新项目是以阿帕奇之箭为核心用铁锈(氧化铁，自然)写成的。在深入研究该项目及其底层技术之前，我想先了解一下InfluxDB最初的目标是什么，以及自七年前引入InfluxDB以来，情况发生了怎样的变化。</p><p> But first, here are answers to some questions you might have on reading the headline:</p><p>但首先，以下是你在阅读标题时可能会遇到的一些问题的答案：</p><p> InfluxDB IOx will support SQL (natively), InfluxQL, and Flux (via 2.0 and APIs with separate daemons).</p><p>InfluxDB IOx将支持SQL(本机)、InfluxQL和Flux(通过2.0和带有单独守护进程的API)。</p><p> InfluxDB IOx will become an optional storage backend for InfluxDB in a future point release.</p><p>在未来的单点版本中，InfluxDB IOx将成为InfluxDB的可选存储后端。</p><p> InfluxDB Cloud customers will have InfluxDB IOx as an optional backend for new buckets early next year.</p><p>InfluxDB Cloud客户将在明年初将InfluxDB IOx作为新存储桶的可选后端。</p><p> InfluxDB Cloud customers will have a seamless, zero-downtime transition to this new technology at some point in 2021.</p><p>InfluxDB Cloud客户将在2021年的某个时候无缝、零停机过渡到这项新技术。</p><p> InfluxDB Enterprise customers will have a commercially supported version of InfluxDB IOx and InfluxDB Enterprise in the latter half of 2021.</p><p>InfluxDB Enterprise客户将在2021年下半年拥有商业支持版本的InfluxDB IOx和InfluxDB Enterprise。</p><p> InfluxDB IOx will have its own builds and can be run separately from the rest of the platform.</p><p>InfluxDB IOx将拥有自己的版本，并且可以独立于平台的其余部分运行。</p><p> My original vision for InfluxDB was that it would be used for all kinds of analytic tasks, both real-time and larger scale. That it would be useful for server and application performance monitoring, sensor data applications and other analytics applications. The basic insight was that time series is a useful abstraction for building applications in these domains and InfluxDB would form the core infrastructure for those applications.</p><p>我对InfluxDB的最初设想是，它将用于所有类型的分析任务，既有实时的，也有更大规模的。它将用于服务器和应用程序性能监控、传感器数据应用程序和其他分析应用程序。基本的见解是，时间序列是在这些领域构建应用程序的有用抽象，而InfluxDB将形成这些应用程序的核心基础设施。</p><p> InfluxDB as it exists today is a great database for the metrics use case. It’s also quite good for analytics, with the caveat that you do not have data with significant cardinality. That is, the tags you have defined don’t have too many unique values. With the addition of Flux as a lightweight query and scripting language, you can now do complex analytics within the database and even interact with other third-party APIs and databases at query time.</p><p>目前的InfluxDB对于度量用例来说是一个很棒的数据库。它也非常适合分析，但需要注意的是，您没有重要的基数数据。也就是说，您定义的标记没有太多的唯一值。随着Flux作为一种轻量级查询和脚本语言的添加，您现在可以在数据库中执行复杂的分析，甚至可以在查询时与其他第三方API和数据库交互。</p><p> With users doing more in the database, the limitation on cardinality is something that is coming up more frequently as a blocker. For example, we’d like to be able to store and work with distributed tracing data, but this type of use case is out of reach for the current underlying InfluxDB architecture. We’d also like to be welcoming to a broader audience of users that might prefer to work in SQL and other scripting languages.</p><p>随着用户在数据库中执行的操作越来越多，对基数的限制作为拦截器出现的频率也越来越高。例如，我们希望能够存储和使用分布式跟踪数据，但这种类型的用例对于当前的底层InfluxDB架构来说是无法实现的。我们还希望欢迎更广泛的用户，他们可能更喜欢使用SQL和其他脚本语言工作。</p><p> On the distributed side of things, InfluxDB as it exists in open source today is not a distributed database and doesn’t give users tools to create a distributed operational environment with it. We held out that functionality for our commercial offerings in our Cloud and Enterprise products. From the perspective of our open source efforts, this was an unfortunate, but necessary limitation at the time since we needed to build a business to be able to support all of the open source work we do.</p><p>在分布式方面，目前存在于开放源码中的InfluxDB不是分布式数据库，也没有为用户提供使用它创建分布式操作环境的工具。我们在我们的云和企业产品中为我们的商业产品保留了这一功能。从我们的开源努力的角度来看，这在当时是一个不幸但必要的限制，因为我们需要建立一个能够支持我们所做的所有开源工作的企业。</p><p> In the intervening seven years since the introduction of InfluxDB, we’ve seen the addition of many other time series databases to the open and closed source landscape. We’ve also seen a significant change in the infrastructure software landscape with Kubernetes rising to prominence, the decline of Hadoop and the rise of more generic object storage with more flexible software computing stacks built on top.</p><p>在引入InfluxDB的七年中，我们看到许多其他时间序列数据库被添加到开放和封闭源代码环境中。我们还看到了基础设施软件领域的重大变化，Kubernetes的崛起，Hadoop的衰落，以及更通用的对象存储的兴起，在上面构建了更灵活的软件计算堆栈。</p><p>  With all these changes in the broader ecosystem and the increasing needs of our users, we deliberated over where InfluxDB should go and settled on a set of higher-level requirements to work towards.</p><p>随着更广泛的生态系统中的所有这些变化和我们用户日益增长的需求，我们仔细考虑了InfluxDB应该向何处发展，并确定了一组更高级别的需求来努力。</p><p> No limits on cardinality. Write any kind of event data and don’t worry about what a tag or field is.</p><p>没有基数限制。编写任何类型的事件数据，不用担心标记或字段是什么。</p><p>  Separate compute from storage and tiered data storage. The DB should use cheaper object storage as its long-term durable store.</p><p>将计算与存储和分层数据存储分开。数据库应该使用更便宜的对象存储作为其长期持久存储。</p><p> Operator control over memory usage. The operator should be able to define how much memory is used for each of buffering, caching, and query processing.</p><p>操作员控制内存使用。操作员应该能够定义缓冲、缓存和查询处理各自使用了多少内存。</p><p> Operator-controlled replication. The operator should be able to set fine-grained replication rules on each server.</p><p>操作员控制的复制。操作员应该能够在每台服务器上设置细粒度的复制规则。</p><p> Operator-controlled partitioning. The operator should be able to define how data is split up amongst many servers and on a per-server basis.</p><p>操作员控制的分区。操作员应该能够定义数据如何在多台服务器之间以每台服务器为基础进行拆分。</p><p> Operator control over topology including the ability to break up and decouple server tasks for write buffering and subscriptions, query processing, and sorting and indexing for long term storage.</p><p>操作员对拓扑的控制，包括拆分和分离服务器任务以进行写缓冲和订阅、查询处理，以及用于长期存储的排序和索引。</p><p> Designed to run in an ephemeral containerized environment. That is, it should be able to run with no locally attached storage.</p><p>设计用于在短暂的集装箱化环境中运行。也就是说，它应该能够在没有本地连接存储的情况下运行。</p><p>   Broader ecosystem compatibility. Where possible, we should aim to use and embrace emerging standards in the data and analytics ecosystem.</p><p>更广泛的生态系统兼容性。在可能的情况下，我们应该致力于使用和接受数据和分析生态系统中的新兴标准。</p><p> This is a fairly broad set of requirements. Also, requirements like the ones on replication and partitioning currently don’t fall under our open source umbrella. There are many ramifications to attempting to build towards these requirements. The first I’d like to talk about is licensing.</p><p>这是一组相当宽泛的要求。此外，像复制和分区这样的需求目前不属于我们的开源保护伞。尝试按照这些要求进行构建会产生许多后果。首先，我想谈一谈许可问题。</p><p>  The open source software we produce at InfluxData is licensed under the permissive MIT license. We’ve long held the view that our open source code should be truly open and our commercial code should be separate and closed. As I mentioned before, we’ve held back high availability and clustering features for our commercial offering. Given that our new requirements call out replication, data partitioning, and other distributed aspects, we had to revisit this decision again.</p><p>我们在InfluxData上生产的开源软件是按照麻省理工学院的许可许可使用的。我们一直认为，我们的开源代码应该是真正开放的，我们的商业代码应该是独立的和封闭的。正如我之前提到的，我们已经推迟了商业产品的高可用性和集群功能。鉴于我们的新需求涉及复制、数据分区和其他分布式方面，我们不得不重新考虑这一决定。</p><p> One of the reasons we created InfluxDB in the first place was because we saw many developers and organizations re-creating the same wheel when it came to distributed time series databases. We thought then, as we do now, that time series is a specific use case that benefits from a system designed for it explicitly.</p><p>我们首先创建InfluxDB的原因之一是，当涉及到分布式时间序列数据库时，我们看到许多开发人员和组织都在重新创建相同的轮子。我们当时认为，就像我们现在所做的那样，时间序列是一个特定的用例，它明确地受益于为它设计的系统。</p><p> This was my experience when building time series APIs on top of Cassandra, Redis and other systems. I ended up having to write a significant amount of application level code to enable the kind of functionality that I needed. I thought InfluxDB could be that shared infrastructure.</p><p>这是我在Cassandra、Redis和其他系统上构建时间序列API时的经验。最后，我不得不编写大量的应用程序级别代码来实现我需要的功能。我认为InfluxDB可以成为共享的基础设施。</p><p> However, without distributed features in the core open source project, this left a significant gap in the market. This is evidenced by the appearance of so many time series databases over the last few years. If we want InfluxDB to be the building block for future projects that need to work with and operate on time series at scale, we need to find a way to open source more, rather than less.</p><p>然而，在核心开源项目中没有分布式特性，这在市场上留下了很大的空白。过去几年出现了如此之多的时间序列数据库就证明了这一点。如果我们希望InfluxDB成为未来需要大规模使用和操作时间序列的项目的构建块，我们需要找到一种方法来更多地而不是更少地开放源代码。</p><p> Further, this work must be licensed under a true open source license that is permissive. If large companies can’t adopt it, they’ll end up inventing it themselves. If other companies can’t build their business on it and expose its API to their users, they’ll end up building it themselves. If cloud providers won’t host it, they’ll end up creating their own versions that may not be compatible and may not be built upon open APIs.</p><p>此外，这部作品必须在真正的开放源码许可下进行许可，这是允许的。如果大公司不能采用它，他们最终会自己发明它。如果其他公司不能在它的基础上建立自己的业务并将其API公开给他们的用户，他们最终将自己建立它。如果云提供商不愿意托管它，他们最终将创建自己的版本，这些版本可能不兼容，也可能不是基于开放API构建的。</p><p> Infrastructure projects that license under source available or restricted permissions are by their very nature evolutionary dead ends. A limited set of users can adopt the software, and an even more restricted set of users can actually build a product on top of it. They can often use restricted license projects for internal purposes, but often not for external customer-facing ones. These limitations mean that many developers have no choice but to build something else either from scratch or from other projects that are actually open source.</p><p>在可用源代码或受限许可下发放许可证的基础设施项目本质上是进化的死胡同。只有有限的一群用户可以采用该软件，而更有限的一群用户实际上可以在它的基础上开发一款产品。他们通常可以将受限许可项目用于内部目的，但通常不能用于外部面向客户的项目。这些限制意味着许多开发人员别无选择，只能从头开始或从其他实际开放源码的项目开始构建其他东西。</p><p> I understand why companies choose to go this route, but it’s severely limiting. It’s also a shame since many of them built from a core that was actually open source to begin with. Community and open source aren’t about how much value your individual company manages to capture. Open source is about creating a cambrian explosion in software that creates value that far outstrips what a single vendor manages to monetize. Open source is not a zero sum game. A larger community and ecosystem brings more opportunity to all vendors.</p><p>我理解公司为什么选择走这条路，但它的局限性很大。这也令人遗憾，因为他们中的许多人都是从一开始就是开源的核心构建起来的。社区和开源并不在于你的公司能获得多少价值。开源是关于创造寒武纪的软件爆炸，创造的价值远远超过单一供应商设法实现的货币化。开源不是零和游戏。更大的社区和生态系统为所有供应商带来更多机会。</p><p> We have a vision of InfluxDB becoming the basis for countless analytics, sensor, monitoring and data analysis projects and companies. The only way this might become a reality is if we come from a starting point that is extensible, adoptable and commercializable by anyone.</p><p>我们的愿景是，InfluxDB将成为无数分析、传感器、监控和数据分析项目和公司的基础。这可能成为现实的唯一途径是，如果我们从一个任何人都可以扩展、采用和商业化的起点出发。</p><p> In service of this larger goal, InfluxDB IOx will be dual-licensed under MIT &amp; Apache 2 with no restrictions.</p><p>为了实现这一更大的目标，InfluxDB IOx将在麻省理工学院和Apache2下不受限制地获得双重许可。</p><p> That being said, InfluxDB IOx is designed to run as a loosely federated shared-nothing architecture. The operator should have full control over the behavior of the individual servers. This also means that any production scenario involving multiple servers will likely need an additional piece of software for operations.</p><p>话虽如此，InfluxDB IOx被设计为作为松散联合的无共享架构运行。操作员应该完全控制各个服务器的行为。这也意味着，任何涉及多台服务器的生产场景都可能需要额外的软件来进行操作。</p><p> In the most basic scenarios, this could be as simple as some shell scripts and a cron job. In more complex scenarios involving ephemeral environments and many servers, this can be a complex piece of software. This operational tooling is where we will have our commercial offering. This will come first in our Cloud product and later as an on-premise offering as part of InfluxDB Enterprise.</p><p>在最基本的场景中，这可能与一些Shell脚本和cron作业一样简单。在涉及瞬息万变的环境和许多服务器的更复杂场景中，这可能是一款复杂的软件。这个可操作的工具就是我们将拥有商业产品的地方。这将首先出现在我们的云产品中，然后作为InfluxDB Enterprise的一部分作为内部部署产品。</p><p> The design of the system was deliberate in terms of how the architecture should work, but also how the commercialization should work. We want our Cloud product to run the exact same bits as the open source project, not a fork. We want the on-premise commercial offering to be complementary to the open source, not a replacement.</p><p>该系统的设计是经过深思熟虑的，既考虑了架构应该如何工作，也考虑了商业化应该如何工作。我们希望我们的云产品能够运行与开源项目完全相同的部分，而不是分支。我们希望内部商业服务是对开源的补充，而不是替代。</p><p> Conway’s Law says you ship your org chart. Dix’s maxim says your licensing strategy is your commercialization strategy, whether by accident or design. With InfluxDB IOx, ours is to have permissively licensed open source software that is maximally useful for its project goal paired with commercial software that is complementary to the open source.</p><p>康威定律说，你要把你的组织结构图寄给你。迪克斯的格言说，你的许可策略就是你的商业化策略，无论是出于偶然还是有意为之。有了InfluxDB IOx，我们的目标是拥有许可许可的开源软件，该软件对其项目目标最有用，并与补充开源的商业软件相结合。</p><p>  There are a few requirements that make this effort something that we’d be unable to build towards incrementally. In an ideal world, you can refactor and incrementally build on your existing code base to get to where you want to go. This is great for evolutionary improvement, but difficult for significant leaps forward.</p><p>有几个要求使这项工作成为我们无法逐步实现的目标。在理想情况下，您可以重构并在现有代码库的基础上逐步构建，以达到您想要的目标。这对于进化改进是很好的，但对于重大飞跃来说是困难的。</p><p> The toughest requirement to meet with how InfluxDB is currently built is for unlimited cardinality. Here’s how data is organized in InfluxDB. Data is sent via our Line Protocol and looks like this:</p><p>满足InfluxDB当前构建方式的最严格要求是无限基数。下面是InfluxDB中数据的组织方式。数据通过我们的线路协议发送，如下所示：</p><p>  This is data for the  cpu measurement with tags of  host and  region and two fields of  user and  system with a trailing nanosecond epoch timestamp. InfluxDB ingests this data and indexes it by:</p><p>这是用于CPU测量的数据，带有主机和区域的标记，以及用户和系统的两个字段，并带有尾随纳秒的纪元时间戳。InfluxDB接收此数据并通过以下方式对其进行索引：</p><p>  That is an individual time series where you have a time-ordered list of value, time pairs. Further, the measurement name, tag key and value, and field name are indexed in an inverted index. So the core of InfluxDB is actually two databases: an inverted index and time series runs. This makes it very fast to look up time series by measurement name, or filter them down by tag dimensions.</p><p>这是一个单独的时间序列，你有一个按时间顺序排列的值，时间对的列表。此外，在倒排索引中索引测量名称、标记键和值以及字段名。因此，InfluxDB的核心实际上是两个数据库：倒排索引和时间序列运行。这使得按测量名称查找时间序列或按标签维度过滤时间序列的速度非常快。</p><p> However, this means that any new tag value that comes in creates a new series and must be indexed in the inverted index. Over time this means that the higher your cardinality becomes, the bigger your inverted index is. In pathological cases like distributed tracing, you get unique IDs on every row. This means that your secondary index will be larger than the underlying time series data itself. You also spend a massive amount of CPU cycles and memory on this continuous indexing.</p><p>但是，这意味着传入的任何新标记值都会创建一个新系列，并且必须在倒排索引中进行索引。随着时间的推移，这意味着基数越高，倒排索引就越大。在像分布式跟踪这样的病态情况下，您在每一行上都会获得唯一的ID。这意味着您的二级索引将大于基础时间序列数据本身。您还会在这种持续索引上花费大量的CPU周期和内存。</p><p> One workaround for these use cases is to put this data into fields. However, that causes the user to have to think about tags vs. fields and in some cases limits what they can do at query time as fields are not indexed in any way.</p><p>这些用例的一种解决方法是将此数据放入字段中。然而，这导致用户不得不考虑标记和字段，在某些情况下限制了他们在查询时可以做的事情，因为没有以任何方式对字段进行索引。</p><p> If we want to handle unlimited cardinality, the split structure of inverted index and time series would need to change. However, this structure is core to how the database is designed.</p><p>如果我们想要处理无限基数，倒排索引和时间序列的分离结构将需要改变。然而，这种结构是数据库设计的核心。</p><p> Strict memory control requirements make a refactor difficult as well. This means we can’t use MMAP, which is how all data and index files are used in the current InfluxDB. MMAP is a great tool and many modern databases have been built with it. However, in containerized environments it is tricky to work with. Also, MMAP doesn’t align well with our requirement of being able to run without a locally attached disk.</p><p>严格的内存控制要求也使重构变得困难。这意味着我们不能使用MMAP，这是当前InfluxDB中所有数据和索引文件的使用方式。MMAP是一个很棒的工具，许多现代数据库都是用它建立的。然而，在集装箱化的环境中，使用它是很棘手的。此外，MMAP也不能很好地满足我们的要求，即在没有本地连接磁盘的情况下也能运行。</p><p> Finally, the requirements for object storage as the durability layer and bulk data import and export are difficult to deliver on with the underlying storage engine that we’ve built. The design fundamentally assumes a locally attached SSD and doesn’t lend itself to exporting some of those files to object storage and importing them later at query time. Bulk data import and export is difficult to realize with our bifurcated index and time series database structure.</p><p>最后，使用我们构建的底层存储引擎很难满足对象存储作为持久层和大容量数据导入和导出的需求。该设计基本上假设了本地连接的SSD，并且不适合将其中一些文件导出到对象存储，并在稍后查询时导入它们。我们的分叉索引和时间序列数据库结构很难实现海量数据的导入和导出。</p><p> These underlying changes conspire to create a situation where we’re unable to gradually bring the core of InfluxDB forward. We needed to radically rethink how the core of the database was organized.</p><p>这些潜在的变化共同造成了这样一种情况，即我们无法逐步推进InfluxDB的核心。我们需要从根本上重新思考数据库的核心是如何组织的。</p><p>  Once we realized that we’d need to rework a significant portion of the core, we started to think about what tools we could use to make this effort faster, more reliable, and more community oriented. It’s no secret that I’m a longtime fan of both  Rust as a systems language and  Apache Arrow as an in-memory analytics toolset. I think these two are the long-term future for systems software and OLAP and data analytics. They’ve both made tremendous progress over the last few years.</p><p>一旦我们意识到我们需要对核心的很大一部分进行返工，我们就开始思考我们可以使用什么工具来使这项工作更快、更可靠、更面向社区。作为系统语言的Rust和作为内存分析工具集的Apache Arrow，我都是它的忠实粉丝，这已经不是什么秘密了。我认为这两个是系统软件、OLAP和数据分析的长期未来。在过去的几年里，他们都取得了巨大的进步。</p><p> Rust gives us more fine grained control over runtime behavior and memory management. As an added bonus it makes concurrent programming easier and eliminates data races. Its packaging system, Crates.io, is fantastic and includes everything you need out of the box. With the addition of async/await last fall, I thought it was time to start seriously considering it.</p><p>Ruust为我们提供了对运行时行为和内存管理的更细粒度的控制。作为一个额外的好处，它使并发编程变得更容易，并消除了数据竞争。它的包装系统Crates.io非常棒，包括了你开箱即用的一切。随着去年秋天Aync/Await的加入，我认为是时候开始认真考虑它了。</p><p> Apache Arrow defines an in-memory format for columnar data along with Parquet, a durable persistence format, and Flight, a client/server framework and protocol for “ high performance transfer of large datasets over network interfaces”. As an added bonus, within the Rust set of Apache Arrow tools is  DataFusion, a Rust native SQL query engine for Apache Arrow. Given that we’re building with DataFusion as the core, this means that  InfluxDB IOx will support a subset of SQL out of the box with expanding functionality as the DataFusion project matures both for use in InfluxDB IOx and elsewhere through the development efforts of collaborators outside of InfluxData. However, InfluxDB IOx also supports InfluxQL and Flux. Once again, we’re taking backwards compatibility seriously.</p><p>Apache Arrow定义了列式数据的内存格式，以及持久持久化格式Parquet和客户端/服务器框架Flight，Flight是一种客户端/服务器框架和协议，用于“通过网络接口高性能传输大型数据集”。此外，Rust的Apache Arrow工具集中还有DataFusion，这是一个用于Apache Arrow的Rust原生SQL查询引擎。鉴于我们是以DataFusion为核心构建的，这意味着随着DataFusion项目的成熟，通过InfluxData之外的协作者的开发努力，InfluxDB IOx将通过扩展功能来支持SQL的一个开箱即用的子集，以便在InfluxDB IOx和其他地方使用。但是，InfluxDB IOx还支持InfluxQL和Flux。再一次，我们认真对待向后兼容性。</p><p> The last part of this architecture is the structure of the database. Our bet is that a columnar database optimized for time series can be used as the basis for future InfluxDB. This is the structure of Apache Arrow and DataFusion, and lines up well with our goal for broader ecosystem compatibility. Here’s how we’ve mapped InfluxDB’s data model onto a columnar database model:</p><p>该体系结构的最后一部分是数据库的结构。我们的赌注是，针对时间序列优化的列式数据库可以用作未来InfluxDB的基础。这就是Apache Arrow和DataFusion的结构，与我们实现更广泛的生态系统兼容性的目标非常一致。下面是我们如何将InfluxDB的数据模型映射到列式数据库模型：</p><p> Tags and fields become columns in those tables (so they’re scoped by measurement)</p><p>标记和字段成为这些表中的列(因此它们的作用域是按度量值划分的)。</p><p> In addition to this organization scheme, we’ve chosen Parquet as the long-term persistence format. Each Parquet file contains some of the data for a single table, which means each one contains the data for a single measurement. Through our research, we’ve found that we can achieve as good or better compression on real-world data with Parquet as the persistence format than we do with our own TSM engine.</p><p>除了这个组织方案，我们还选择了拼花作为长期持久化格式。每个Parquet文件包含单个表格的一些数据，这意味着每个文件都包含单个测量的数据。通过我们的研究，我们发现，与使用我们自己的TSM引擎相比，使用Parquet作为持久化格式可以实现与我们自己的TSM引擎一样好甚至更好的真实数据压缩。</p><p> Further, we break all of the data into partitions. How that data is split into partitions is defined by the operator or user when they create the database. The most common partitioning scheme will simply be based on time (for example: every 2 hours).</p><p>此外，我们将所有数据划分为分区。如何将数据分割为分区由操作员或用户在创建数据库时定义。最常见的分区方案将简单地基于时间(例如：每2小时)。</p><p> For each partition, we keep a summary of what it contains that can be kept in memory. This summary includes what tables exist, what their columns are, and what the min and max values of those columns are. This means that the query planner can rule out large portions of the data set before execution by simply looking at the partition metadata.</p><p>对于每个分区，我们都会汇总它可以保存在内存中的内容。此摘要包括存在哪些表、它们的列以及这些列的最小值和最大值。这意味着查询规划者只需查看分区元数据，就可以在执行之前排除数据集的大部分。</p><p> This partitioning scheme also makes it easier for us to use object storage as the long-term store and to manage the data lifecycle from memory to object storage to indexed Parquet files.</p><p>这种分区方案还使我们更容易使用对象存储作为长期存储，并管理从内存到对象存储再到索引的Parquet文件的数据生命周期。</p><p> Columnar databases aren’t new, so why are we building yet another one? We weren’t able to find one in open source that was optimized for time series. On the query side, we needed dictionary support and windowed aggregates to be first-class and optimized. On the persistence side, we needed something that was intended to separate compute from storage.</p><p>栏目数据库并不新鲜，那么为什么我们还要构建另一个数据库呢？我们在开放源码中找不到针对时间序列进行优化的。在查询方面，我们需要一流的字典支持和窗口聚合，并对其进行优化。在持久性方面，我们需要一些旨在将计算与存储分开的东西。</p><p> Nothing specific in this project is revolutionary. Columnar databases have been extensively researched over the last few decades or so. Separating compute from storage with object storage is another thing that has been gaining momentum over the last ten years.  Snowflake represents one of the more visible recent examples in the closed source realm.</p><p>这个项目没有任何具体的内容是革命性的。在过去几十年左右的时间里，柱状数据库得到了广泛的研究。使用对象存储将计算与存储分离是过去十年中发展势头不断增强的另一件事。Snowflake代表了封闭源码领域中最近比较明显的例子之一。</p><p> We think the combination and composition of these tools together, with Apache Arrow as the core in an open source server project, represents a new and interesting offering in the open source world. We think this is something that future analytics and monitoring projects both real-time and at scale might use as a building block.</p><p>我们认为，在开源服务器项目中，以Apache Arrow为核心的这些工具的组合和组合代表了开源世界中一种新的有趣的产品。我们认为这是未来实时和大规模的分析和监控项目可能会用到的东西。</p><p> We’re already contributing back to Arrow in the Rust and Go languages. This doubles down on our commitment there. However, some of our needs are outside the goals of Apache Arrow. For example, we need a system that can keep compressed data in memory and execute queries against it with late materialization. To that end, we’re creating extensions to DataFusion that will make InfluxDB IOx able to work with more time series data in-memory than we’d otherwise be able to handle.</p><p>我们已经回馈给《铁锈与围棋》中的箭了。这使我们在那里的承诺加倍。然而，我们的一些需求超出了阿帕奇之箭的目标。例如，我们需要一个可以将压缩数据保存在内存中并使用延迟物化对其执行查询的系统。为此，我们正在创建对DataFusion的扩展，它将使InfluxDB IOx能够处理内存中比我们原本能够处理的更多的时间序列数据。</p><p>  This project is still in its very early stages. We’re not currently producing builds, and there is no documentation beyond the  InfluxDB IOx project README. The team is a small focused group of senior engineers and our efforts are in parallel to all the efforts of our larger engineering organization on the rest of the platform. Our goal is to produce open source builds early next year along with offering it in alpha in InfluxDB Cloud.</p><p>这个项目还处于非常早期的阶段。我们目前没有生成版本，除了InfluxDB IOx项目自述文件之外，没有其他文档。该团队是一个由高级工程师组成的小而专注的团队，我们的努力与我们更大的工程组织在平台其余部分的所有努力是平行的。我们的目标是在明年初生产开源版本，并在InfluxDB Cloud中提供Alpha版本。</p><p> We’re talking about this now because we thought it was important to let the community know where we’re headed. We also want to open up the project so that others that take interest in it can follow along and even contribute.</p><p>我们现在谈论这件事是因为我们认为让社区知道我们的发展方向很重要。我们也想开放这个项目，这样其他对它感兴趣的人就可以跟随它，甚至做出贡献。</p><p>  For open source InfluxDB 2.0 users, this has no immediate impact. This work is still quite early and likely won’t be ready for production usage for a little while. You can expect that a future InfluxDB 2.x point release will be able to use InfluxDB IOx as an optional storage and query backend.</p><p>对于开源InfluxDB 2.0用户来说，这不会立即产生影响。这项工作还为时尚早，很可能在一段时间内还不能投入生产使用。可以预期，未来的InfluxDB 2.x点版本将能够使用InfluxDB IOx作为可选的存储和查询后端。</p><p> Work on the InfluxDB 2.x line will continue during and after the development of InfluxDB IOx. This represents no breaking change to the API. However, additional functionality in the 2.x API will be landing over time, and will be usable by the community as it becomes available. The development and adoption cycle of InfluxDB IOx should be incremental rather than all at once like the 1.x to 2.0 release cycle.</p><p>在InfluxDB IOx开发期间和之后，InfluxDB 2.x系列的工作将继续进行。这并不代表对API的重大更改。然而，随着时间的推移，2.xAPI中的附加功能将陆续落地，社区将在其可用时使用这些功能。InfluxDB IOx的开发和采用周期应该是增量的，而不是像从1.x到2.0的发布周期那样一次完成。</p><p>  For our InfluxDB Cloud customers, they will have an option to use this new technology as a backend for new buckets at some point in the first half of</p><p>对于我们的InfluxDB Cloud客户，他们将可以选择使用这项新技术作为新存储桶的后端。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.influxdata.com/blog/announcing-influxdb-iox/">https://www.influxdata.com/blog/announcing-influxdb-iox/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/赌注/">#赌注</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/betting/">#betting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034269.html"><img src="http://img2.diglog.com/img/2020/11/thumb_524109d84e42d6e5e81376458a2dafa9.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034269.html">亚马逊因使用商家数据而面临欧盟反垄断指控：来源</a></div><span class="my_story_list_date">2020-11-10 22:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034264.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1eb6a76bdc96a6c7ea176671840feb7e.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034264.html">欧盟就亚马逊使用数据提起反垄断诉讼</a></div><span class="my_story_list_date">2020-11-10 22:20</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034251.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c1dfc94501cbe88803516dad93e2d016.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034251.html">
欧洲对亚马逊使用大数据提起反垄断诉讼</a></div><span class="my_story_list_date">2020-11-10 21:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034206.html"><img src="http://img2.diglog.com/img/2020/11/thumb_87c2aec98acc420b812c1e05cf065c21.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034206.html">当地官员、教育工作者和倡导团体对互联网服务提供商拒绝提供他们通过低收入项目签约的客户数量的数据感到沮丧</a></div><span class="my_story_list_date">2020-11-10 13:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>