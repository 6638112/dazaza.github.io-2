<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>谷歌如何保持低位延续时间？ How does Google keep build times low?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How does Google keep build times low?<br/>谷歌如何保持低位延续时间？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 18:05:13</div><div class="page_narrow text-break page_content"><p>Monorepos have existed for a very long time. The basic idea behind them is to store the complete source code of your company or product,  including all of its dependencies, in a single source repository and have an integrated build and test process for the whole.</p><p>Monorepos已经存在了很长时间。它们背后的基本思想是存储公司或产品的完整源代码，包括其所有依赖项，在单个源存储库中，并为整体具有集成的构建和测试过程。</p><p> I like to think of the BSD systems as the canonical example of open-source monorepos, but these were never seen as good practice by many (c.f.  CatB). Monorepos have only become popular during the last decade because of Google’s engineering practices and their increasing desire to  share details with the public. Google’s monorepo is probably the largest in the world, and if works at their scale—the thinking goes—it must be good for everyone else, right? Not so fast.</p><p> 我喜欢将BSD系统视为开源Monorepos的规范示例，但这些从未被认为是许多（C.f.CATB）的良好实践。由于谷歌的工程实践及其日益愿望与公众分享详细信息，因此莫罗尔斯在过去十年中只变得流行。谷歌的Monorepo可能是世界上最大的，如果在他们的规模上工作 - 思考 - 它对其他人都必须有好处，对吧？不是那么快。</p><p> Monorepos are an interesting beast. If mended properly, they indeed enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable monsters of tangled dependencies, slow builds, and frustrating developer experiences. Whether you have a good or bad experience directly depends on the level of engineering support behind the monorepo. Simply put, monorepos require dedicated teams (plural)  and tools to run nicely (not just random engineers “volunteering” their efforts), and these cost a lot of time and money.</p><p> Monorepos是一个有趣的野兽。如果正确地修补，它们确实能够实现恰当的均匀性和代码质量，以其他方式难以实现。然而，如果无人看管，它们会成为纠结依赖性，缓慢的建造和令人沮丧的开发人员体验的无法管理怪物。无论您是良好还是不良经验，直接依赖于Monorepo背后的工程支持水平。简单地说，Monorepos需要专门的团队（复数）和工具来运行很好（不仅仅是随机工程师“志愿者”他们的努力），而且这些花费了很多时间和金钱。</p><p> As a consequence of this cost, you must be wary before adopting a monorepo model. You must have a good story around support upfront, or else you are in for long-term pain. And once you are in a monorepo, the “long term” is guaranteed because untangling the dependency mess that arises in such an environment can be next to impossible. The worst scenario is when you did not actively decide to implant a monorepo, but you end up in one due to organic or unexpected quick growth—in which case your tooling and practices are almost certainly not ready for it.</p><p> 由于这一成本，您必须在采用Monorepo模型之前谨慎态度。你必须有一个很好的故事，周边地支持，否则你是为了长期痛苦。一旦你进入MONOREPO，“长期”是保证的，因为在这种环境中产生的依赖性混乱是不可能的。最糟糕的情况是当你没有积极决定植入一个monorepo的时候，但由于有机或意外的快速增长，你最终结束 - 在这种情况下，您的工具和实践几乎肯定没有为此做好准备。</p><p> In this post, I will look at how Google is able to successfully run the world’s largest monorepo while keeping build times minimal. They can, for example, validate and merge most PRs on CI within minutes while having the almost-absolute confidence that they won’t break  anything—yet it’s impossible to build the whole repository in those few minutes. I’ll restrict this post to analyzing build times and will specifically avoid talking about test times. Both are crucially important but both have very different solutions. Maybe a follow-up post will cover tests 😉.</p><p> 在这篇文章中，我会看看谷歌如何能够在保持建立时间最小的同时成功运行世界上最大的Monorepo。例如，它们可以在几分钟内验证并合并大多数PI上的CI，同时具有几乎绝对的信心，以至于它们不会破坏任何东西 - 然而在几分钟内建立整个存储库是不可能的。我将限制这篇文章来分析构建时间，并将特别避免谈论测试时间。两者都很重要，但两者都有很不同的解决方案。也许后续帖子将覆盖测试😉。</p><p>  A key feature of a monorepo, as mentioned earlier, is to have a unified build process for the whole. In the common case, the repository has a single entry point at the top level, which means that the entire repository has to be built for every change to ensure the health of the tree. It might be possible for individual engineers to hand-pick which parts of the tree to build on their development machine (e.g. by running  make on a subdirectory), but CI environments will blindly do builds from the root.</p><p>  如前所述，Monorepo的一个关键特征是为整体拥有统一的构建过程。在常见的情况下，存储库在顶级处于单个入口点，这意味着必须为每种更改构建整个存储库以确保树的运行状况。各个工程师可能可以手动挑选树的哪些部分以在其开发机上构建（例如，通过在子目录中运行make），但CI环境将盲目地从根本中构建。</p><p> This approach, tied to the fact that monorepos grow unboundedly with the company or product they support, causes build times to balloon… until they grind the development processes to a halt. If you add to this that most build systems need occasional clean operations, frustration is guaranteed:</p><p> 这种方法与Monorepos与他们支持的公司或产品无束缚的事实相关联，导致建立时间到气球......直到他们将开发过程拖到停止。如果您添加了这一点，大多数构建系统需要偶尔干净的操作，请保证挫折： </p><p> Pull requests are almost impossible to manage as they need long validation times and might hit unpredicted merge conflicts.</p><p>拉出请求几乎无法管理，因为它们需要长期验证时间，并且可能会达到未预测的合并冲突。</p><p> Quality suffers because developers won’t want to pay the penalty of yet another CI run just to address nits raised in the final pass of a code review.</p><p> 质量遭受，因为开发人员不想支付另一个CI的惩罚，只是为了解决代码审查的最终通行证中提出的NITS。</p><p> Facing these circumstances, the natural temptation is to split the repository into smaller pieces and regain control of the build times. (This, by the way, is the specific project I’m involved in right now.) And, depending on the tooling you are subject to and the freedom (or lack thereof) you have in changing it, this may be the only possible/correct answer. But why? Why would moving to smaller repositories fix build times? The total amount of code won’t get smaller just by splitting it; if anything, it might  grow even more! The answer may be obvious:</p><p> 面对这些情况，自然诱惑是将存储库分成较小的碎片并重新获得对构建时的控制。 （顺便说一句，这是我现在参与的具体项目。）并且根据您所处的工具以及您在改变它的自由（或缺乏）的情况下，这可能是唯一可能的/正确答案。但为什么？为什么要移动到较小的存储库修复构建时间？通过拆分拆分时，代码总量不会变小;如果有的话，它可能会增加更多！答案可能是显而易见的：</p><p> Multiple repositories introduce synchronization points. Under such a model, the cross-repository dependencies are expressed as  binary package dependencies with specific version numbers. In essence, the smaller repositories leverage builds that  others have already done and thus bound their build times.</p><p> 多个存储库引入同步点。在这样的模型中，交叉存储库依赖关系被表示为具有特定版本号的二进制包依赖关系。从本质上讲，较小的存储库利用建立其他人已经完成并因此绑定了他们的构建时间。</p><p>  Yet… Google’s monorepo is known for  not using binary artifacts: they build  everything at head with the exception of the most basic C++ toolchain (known as crosstool in  Google Bazel parlance) for bootstrapping reasons. How do they pull this off? The answer is simple and is the exact same as given above: they leverage builds that others have already done. And the specific way they do this is by applying a common solution to performance problems: caching.</p><p>  然而......谷歌的MONOREPO是不使用二元工件的别名：它们在头部建立一切，除了最基本的C ++ Toolchain（谷歌Bazel Partrance中称为Crosstool），以便引导被引导原因。他们如何把它赶走？答案很简单，与上面给出的完全相同：他们利用其他人已经完成的建造。以及他们这样做的具体方式是通过对性能问题应用常见解决方案：缓存。</p><p> Google builds rely on a  cross-user (remote) massive artifact cache that stores the outputs of all build actions. This cache is what introduces the same “synchronization points” that multiple repositories benefit from. By leveraging this cache, the vast majority of dependencies needed for any given build will have already been compiled by someone or something else and will be reused.</p><p> Google构建依赖于跨用户（远程）的大规模工件缓存，该缓存存储所有构建操作的输出。此缓存是介绍多个存储库中受益的相同“同步点”。通过利用此缓存，任何给定构建所需的绝大多数依赖项都将由某人或其他某种构建编制，并且将被重用。</p><p> But… caching alone is insufficient to fix build times unless you get 90%+ cache hit rates overall. And that’s where the differences between awful build times in a monorepo and great build times lie. In the next sections, I’ll look into the specific mechanisms that lead to such high cache hit rates. And if Google can have them, so can you.  Bazel, from its inception, has been trying to spread these practices to the public—but you can apply these same concepts with other build tools too.</p><p> 但是......除非您整体获得90％+缓存命中率，否则单独缓存不足以修复构建时间。这就是Monorepo和伟大的建筑时间在Monorepo和伟大的建筑时间之间的差异。在下一节中，我将研究导致这种高速缓存命中率的具体机制。如果谷歌可以拥有它们，你也可以。从成立开始，Bazel一直试图向公众传播这些做法 - 但您也可以使用其他构建工具应用这些相同的概念。 </p><p>  First of all, we have to ensure that build actions (e.g. compiler invocations, resource bundling) are deterministic. Given a set of input files and tools to process them, the output must not be subject to environmental differences. In other words: build actions must be sufficiently-specified so that they don’t rely on hidden dependencies that could change their outputs.</p><p>首先，我们必须确保构建动作（例如编译器调用，资源捆绑）是确定性的。给定一组输入文件和工具处理它们，输出不得受到环境差异的影响。换句话说：必须充分指定构建操作，以便它们不依赖于可以更改其输出的隐藏依赖项。</p><p> I covered this topic in depth in the previous “ How does Google avoid clean builds?” post where I analyzed how this simple idea allows incremental builds to always work. I also glanced over some of the many other benefits that it brings, including how it can lead to optimal build times, which is what I’m covering here.</p><p> 我在上一个“Google如何避免干净的构建？”的深入了解了这一主题。发布我分析了这个简单的想法如何允许增量构建始终工作。我也瞥了一眼它带来的许多其他福利，包括如何导致最佳建设时间，这是我在这里覆盖的。</p><p> Deterministic actions are the foundation to reducing build times in a monorepo. So… you must sort this out before you can take advantage of any of the remaining points.</p><p> 确定性行动是在Monorepo中减少建筑时间的基础。所以......你必须在利用任何剩余点之前对此进行分类。</p><p>  Once build actions are deterministic, the next thing to worry about is increasing the chances of reusing previously-cached actions for any given build. This is generally only possible when builds use the exact same configuration, or else their outputs will differ and may be incompatible with each other. For example: a debug build will not be able to safely reuse the outputs of a release build. Which is kinda obvious, but there aren’t just two configurations. There tend to be more. Many more.</p><p>  一旦构建行动是确定性的，下一件事就是增加为任何给定的构建重复使用先前缓存的动作的机会。这通常只有在构建使用完全相同的配置时才可能，否则它们的输出将不同，并且可能与彼此不兼容。例如：调试版本将无法安全地重用发布构建的输出。这有点明显，但不仅有两种配置。往往会更多。还有很多。</p><p> In fact, the number of build configurations grows with the size of the project—and, paradoxically, the number of options grows to  reduce build times. You see: when engineers suffer from painfully slow builds, in the best of their intentions, they add knobs to conditionally compile certain parts of the project to speed things up. Which is great in single-user/single-machine builds, but it doesn’t scale and is an anti-pattern in a monorepo world where we must have almost-perfect caching across users.</p><p> 实际上，构建配置的数量随着项目的大小而增长 - 而且矛盾的是，选项数量增长以减少构建时间。你看：当工程师痛苦地缓慢建造时，他们在他们的意图中，他们可以在有条件地编制项目的某些部分来加速旋钮。在单用户/单机构建中很好，但它不会缩放，并且在Monorepo World中是一种反模式，我们必须在用户身上几乎完美的缓存。</p><p> Thus, for monorepo builds to be quick, we actually have to homogenize configurations so that most engineers and CI are running almost the same configuration. In practical terms, this means having debug builds for interactive development, and release builds for production usage. And that’s about it.</p><p> 因此，对于monorepo建立快速，我们实际上必须均匀化配置，以便大多数工程师和CI运行几乎相同的配置。实际上，这意味着具有用于交互式开发的调试构建，并释放生产使用。那就是关于它的。</p><p> As an anecdote, we encountered this specific issue while onboard a certain iOS team into remote builds. This team had been developing on laptops only, and because they had slow builds, the engineers had added many feature flags to make components optional. When we moved them to remote builds and remote caching, we saw very little benefit: these users were  still rebuilding everything and the reason was because they could not make use of previously-cached results due to different configurations. Once we removed most build-time conditionals, they started truly seeing the benefits of remote caching/execution and faster builds. Counterintuitive, isn’t it?</p><p> 作为一个轶事，我们遇到了这个特定的问题，同时在某个iOS团队陷入远程构建时。该团队仅在笔记本电脑上开发，因为它们具有缓慢的构建，工程师添加了许多功能标志来使组件可选。当我们将它们移动到远程构建和远程缓存时，我们看到了很少的好处：这些用户仍然重建一切，原因是因为由于不同的配置，他们无法利用以前缓存的结果。一旦我们删除了大多数构建条件，他们就开始真正看到远程缓存/执行和更快的构建的好处。违反直觉，不是吗？ </p><p>  By this point, we know that our actions are deterministic and that user builds have a chance to reuse the cache because we have made builds uniform. But here comes the question: how do we seed the cache?</p><p>到目前为止，我们知道我们的行为是确定性的，并且用户构建有机会重用缓存，因为我们制作了构造。但这是问题：我们如何种子缓存？</p><p>  A  cross-user cache of build artifacts must be populated only from trusted sources. We cannot have a developer’s workstation inject output artifacts that were built on their machine because the developer could have tampered with the outputs. This means that the cross-user remote cache can only be populated from machines that cannot be tampered with. (If the cache is not used across users, then no extra precautions are necessary.) These trusted sources come in two forms:</p><p>  必须仅从可信源填充构建工件的交叉用户缓存。我们不能拥有在其计算机上构建的开发人员的工作站注入输出工件，因为开发人员可能会篡改输出。这意味着跨用户远程缓存只能从无法篡改的机器填充。 （如果在用户身上未使用缓存，则无需额外的预防措施。）这些可信源有两种形式：</p><p> The first one, and the one that’s easy to apply almost in any case, are CI runs. CI runs happen on machines that are not (and should not be!) directly accessible by the larger engineering population, thus we can trust that the output they generate comes precisely from the code and tools that were fed to them.</p><p> 第一个，并且易于在任何情况下易于应用的那个是CI运行。 CI运行在没有（不应该是！）的机器上，通过较大的工程人口直接访问，因此我们可以信任他们生成的输出精确地从送到它们的代码和工具中。</p><p> The second one, and the one that’s more subtle, are user-initiated builds. When an engineer is building on their workstation, we  can cache their build outputs across users  if we generate those outputs using a trusted environment. Such a trusted environment comes in the form of  remote execution. Under a remote execution scenario, the build machine sends individual build actions to a remote service. This service, which is trusted too, runs actions on behalf of the user, but the user doesn’t have a chance to interfere with the outputs before they are saved into the cache.</p><p> 第二个，和更微妙的那个是用户启动的构建。当工程师在工作站上构建时，如果我们使用可信环境生成这些输出，我们可以通过用户缓存其构建输出。这种可信环境以远程执行的形式出现。在远程执行方案下，构建计算机将各个构建操作发送到远程服务。这项服务也是值得信赖的，代表用户运行操作，但用户在将输出保存到缓存之前，用户没有机会干扰输出。</p><p> You might think that a compromised compiler is an attack vector in this scenario: the engineer modifies the compiler, sends it to the remote CI machine or remote execution worker to build a piece of code, and the outputs that contain malicious code are injected into the cache. But that’s not the case. Remember: the compiler is also an  input to the action, just like the source files are. If you tamper with the compiler, then the action’s signature changes, which means the cache key changes, which means nobody will be able to address such cache entry unless they have the same compromised compiler.</p><p> 您可能会认为受损编译器是这种情况下的攻击矢量：工程师修改编译器，将其发送到远程CI机器或远程执行工作人员以构建一段代码，并将包含恶意代码的输出注入到其中缓存。但那不是这种情况。请记住：编译器也是一个对动作的输入，就像源文件一样。如果使用编译器篡改，则操作的签名更改，这意味着缓存密钥更改，这意味着除非它们具有相同的受损编译器，否则无人能够解决此类缓存条目。</p><p> In the end, you want to take both approaches. You want periodic CI runs to populate the cache as these ensure that the cache is frequently repopulated from HEAD. And you want to incrementally cache outputs that originate from interactive builds and PRs to keep up with drift and to keep up with possible divergences in the configurations that they use.</p><p> 最终，您想采取两种方法。您希望定期CI运行以填充缓存，因为这些缓存确保缓存经常从头重新填充。并且您希望逐步逐步源自交互式构建和PRS的缓存输出，以跟上漂移，并在其使用的配置中跟上可能的分歧。</p><p> As long as users stick to the blessed configurations discussed in the previous section, and as long as you have these sources of data to populate the cache, then you should start seeing high cache hit ratios and faster build times overall.</p><p> 只要用户坚持上一节中讨论的符合祝福的配置，只要您拥有这些数据来源来填充缓存，那么您应该开始看到高缓存命中比率并更快地构建时间。 </p><p>  Definitely. I’m a believer that they are good, and not only because of Google: the BSDs taught me this principle a very long time ago. That said, it’s true that they can be a poor choice unless your engineering practices and tools keep up, which as mentioned in the opening, can be extremely expensive. If you cannot afford the cost, it might be better to stay with multiple smaller repositories and let smaller groups of developers handle them in an ad-hoc manner. The whole won’t be as nice, but the overall experience might be less frustrating.</p><p>确实。我是一个信徒，他们很好，不仅因为谷歌：很久以前就教我这个原理。也就是说，除非您的工程实践和工具跟上，除非您的工程实践和工具跟上，这可能是较差的选择，这可以非常昂贵。如果您无法负担成本，则可以更好地留在多个较小的存储库中，并让较小的开发人员组以ad-hoc方式处理它们。整体不会那么好，但整体经验可能不那么令人沮丧。</p><p> In the end, monorepos are an “implementation detail” of bundling multiple separate components in one place. Having a monorepo should  not imply that you must build the whole thing every time you make a change. Having multiple repositories should not mean that they are isolated islands. And the latter is, precisely, what we are trying to prove in my current team: we want to see how well we can integrate smaller repositories without actually being a monorepo. Because, with suboptimal tooling… build times are not the only problem. Source control is another major one: Git, if you happen to use it, is not the greatest choice for monorepos.</p><p> 最后，Monorepos是一个“实施细节”，它在一个地方捆绑多个单独的组件。拥有一个monorepo不应暗示每次改变时都必须建立整个东西。拥有多个存储库不应该意味着它们是孤立的岛屿。后者恰恰是我们试图在我当前的团队中证明的东西：我们希望看到我们如何在没有实际作为monorepo的情况下集成较小的存储库。因为，具有次优工具...构建时间不是唯一的问题。源控制是另一个主要的一个：git，如果你碰巧使用它，不是monorepos的最大选择。</p><p>  If you enjoyed this post, subscribe to this blog to keep up with two upcoming, related topics! One will be on ensuring build times remain low once we have achieved them; and the other may be on how Google keeps test runs on CI fast.</p><p>  如果您喜欢这篇文章，请订阅此博客以跟上两个即将到来的相关主题！一旦我们达到了他们，就会确保建设时间仍然很低;另一个可能是Google如何在CI上保持测试运行。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jmmv.dev/2021/02/google-monorepos-and-caching.html">https://jmmv.dev/2021/02/google-monorepos-and-caching.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/保持/">#保持</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/build/">#build</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>