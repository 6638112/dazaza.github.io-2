<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使用Bash（2015）更快地导航目录 How to navigate directories faster with Bash (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to navigate directories faster with Bash (2015)<br/>如何使用Bash（2015）更快地导航目录 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 15:16:14</div><div class="page_narrow text-break page_content"><p>Changing directories is an extremely frequent activity during my everyday work as a knowledge worker running calculations, analyzing data, and developing code from the terminal. In fact, changing directories is the basic mode of operation to walk between different tasks, context, or work spaces.</p><p>更改目录是我的日常工作中的一个非常频繁的活动，作为运行计算，分析数据和从终端的开发代码的知识工作者。实际上，更改目录是在不同任务，上下文或工作空间之间行走的基本操作模式。</p><p> When I first started using the terminal the only command I knew was  cd but throughout the years I noticed that there is a lot more under the hood of bash that significantly reduces the time needed to change directories. Below I share five tricks I use frequently to jump between directories. They not only help me to move faster but also reduces the cognitive load of remembering long subdirectories.</p><p> 当我第一次开始使用终端时，我知道的唯一命令是CD，但在整个年内，我注意到，在Bash的引擎盖下有很多更多，显着减少了改变目录所需的时间。下面我分享了五个技巧我经常使用以在目录之间跳跃。它们不仅可以帮助我移动更快，而且还可以降低记住长子的认知负荷。</p><p> Furthermore, I use all tricks together for maximum efficiency and I hope they make you more productive, too.</p><p> 此外，我使用所有技巧以获得最高效率，我希望他们也能让你更加富有成效。</p><p>    This tip focuses solely on using all capabilities of the  cd command. The most common form of using  cd is</p><p>    此尖端仅侧重于使用CD命令的所有功能。使用CD最常见的形式是</p><p>  where  directory can be either a  ./relative or an  /absolute path. Also quite well-known is that  .. is an alias for the directory above the current directory,  ../.. the one above that and so on. Maybe less well-known is that  ~ is an alias for one’s home directory. However an even faster way to go there directly is to skip the  directory argument and just use</p><p>  其中目录可以是。/相关或/绝对路径。也是众所周知的是..是一个别名的目录上方的目录上方的别名../ ..是上面的目录上方等等。也许不太众所周知的是，是一个人的主目录的别名。但是，直接去那里的更快方式是跳过目录参数并刚使用</p><p>  Furthermore  - is an alias for the previous directory. So  cd - is like a back-button for  cd that works for exactly one step in the history. Using  cd - repeatedly toggles between two directories.</p><p>  此外 - 是上一个目录的别名。所以CD  - 就像CD的后退按钮，它适用于历史上的一步。使用CD  - 反复在两个目录之间切换。</p><p>    alias ..=&#34;cd ..&#34;alias ...=&#34;cd ../..&#34;alias ....=&#34;cd ../../..&#34;alias .....=&#34;cd ../../../..&#34;alias ......=&#34;cd ../../../../..&#34;alias .......=&#34;cd ../../../../../..&#34;alias ........=&#34;cd ../../../../../../..&#34;alias .........=&#34;cd ../../../../../../../..&#34;alias ..........=&#34;cd ../../../../../../../../..&#34;alias ...........=&#34;cd ../../../../../../../../../..&#34;alias ............=&#34;cd ../../../../../../../../../../..&#34;alias .............=&#34;cd ../../../../../../../../../../../..&#34;</p><p>    别名.. =＆＃34; CD ..＆＃34;别名... =＆＃34; CD ../&#34; alias .... =＆＃34; CD .. / ..&#34; alias ..... =＆＃34; cd ../../../..& l#34; alias ...... =＆＃34; CD ../ ../../../..& ... alias ....... =＆＃34; CD ../../../../../..&#34;别名........ =＆＃34; CD ../../../../../../&#34; alias ......... = ＆＃34; CD ../../../../../../../../../../../../../和...; alias .......... =＆＃34; cd。 ./ ...... / ...'alias ........... =＆＃34; cd ../ ../../../../../../../../../../../../../..&＃34; alias ............ =＆＃34; CD。 ./../../../../../../../../../../../../../../../..&#34; alias ............. = ＆＃34; CD ../../../../../../../../../../../../../../../../和... </p><p> can bring you up many more directories by just adding dots (…) :-).</p><p>只需添加点（...）:-)可以为您带来更多目录。</p><p> Another neat short hand is  !$ which is an alias for the last argument of the previous command. This can be handy if one creates a new directory and wants to change into it without typing the the directory again. So commands would be</p><p> 另一个简洁的短手是！$这是前一个命令的最后一个参数的别名。如果创建一个新目录并且想要再次键入目录，则这可以方便。所以命令将是</p><p>      The next tip is efficient use of the  CDPATH variable. Almost everyone using a shell is familiar with the importance of the  PATH variable. The  PATH variable means that whenever one enters a  command the shell will look up the directories listed in the  PATH, search for executable files and then executes the first executable it finds named  command in the order listed in  PATH.</p><p>      下一个提示是有效使用CDPath变量。几乎每个使用shell的每个人都熟悉路径变量的重要性。路径变量意味着只要一个输入命令，shell将查找路径中列出的目录，搜索可执行文件，然后执行第一个可执行文件，以便在路径中列出的顺序找到命令命令。</p><p> So there is a closely related variable named CDPATH which is the analog for  cd. When you enter</p><p> 因此，有一个名为CDPath的密切相关变量，它是CD的模拟。当你进入时</p><p>  cd will search all directories listed in  CDPATH and jump to the first directory it finds in the order listed in  CDPATH. The default setting is  CDPATH=., which means  cd only searches the current working directory. But there is no reason to stop where. My  ~/.bashrc contains export CDPATH=.:~:~/src:~/calculations:~/ssh_mounts</p><p>  CD将搜索CDPath中列出的所有目录，并跳转到它以CDPath中列出的顺序查找的第一个目录。默认设置为CDPath =。，这意味着CD仅搜索当前工作目录。但没有理由停止在哪里。我的〜/ .bashrc包含导出cdpath = .:〜：〜/ src：〜/ calculation：〜/ ssh_mounts</p><p> With this line I can always directly jump directly to any directory below the current directory, the home directory, a directory named  src for software projects, a directory for  calculations, and a directory named  ssh_mounts that may link to other servers linked via the  sshfs program.</p><p> 使用此行，我始终可以直接直接跳转到当前目录下面的任何目录，主目录，名为SRC的目录，用于软件项目，一个用于计算的目录，以及名为SSH_MOUNT的目录，可以链接到通过SSHFS程序链接的其他服务器。</p><p> This helps to keep directories for different types of activities apart while also allowing for quick changes between them. It is more powerful if one has only one  ~/.bashrc for all user accounts and synchronizes it using e.g.  git, and bash completion</p><p> 这有助于为不同类型的活动保持各种类型的目录，同时还允许它们之间的快速变化。如果所有用户帐户只有一个〜/ .bashrc，它更强大。 git和bash完成 </p><p> if [ -f /etc/bash_completion ]; then . /etc/bash_completionelif [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then . /opt/local/etc/profile.d/bash_completion.shfi</p><p>如果[-f / etc / bash_completion];然后 。 / etc / bash_completionelif [-f /opt/local/etc/profile.d/bash_completion.sh];然后 。 /opt/local/etc/profile.d/bash_completion.shfi.</p><p>   which automatically corrects small typos in directory names and jumps to the best guess of existing directories. Or</p><p>   它在目录名称中自动纠正小字母，并跳转到最佳猜测现有目录。或者</p><p>      Another command less well known than  cd is  pushd and  popd.  pushd stands for  push directory and it changes the current working directory but also  pushes the directory that one left onto a history stack.  popd on the other hand stands for  pop directory which  pops the last visited directory from the history stack. The command  dirs lists the directories currently stacked on the history. So for example</p><p>      另一个命令不太清楚CD是PUSHD和POPD。 PUSHD代表推送目录，它更改当前工作目录，但也会将左侧留在历史迹堆栈上的目录。另一方面，POPD代表POP目录，它弹出历史堆栈中上一个访问的目录。命令Dirs列出当前堆叠在历史记录上的目录。例如，</p><p>   pushd and  popd are two really great commands and they are hugely useful in scripts to cleanly enter and exit directories in shell-scripts. The only question is why there are so many characters to type and why  cd doesn’t have that feature built in. To fix this put the following two functions into your  ~/.bashrc which overrides  cd:</p><p>   PUSHD和POPD是两个非常伟大的命令，它们在脚本中非常有用，以便在shell脚本中干净地输入和退出目录。唯一的问题是为什么有这么多的字符类型，为什么CD内置的CD没有该功能。要修复以下两个功能，请将以下两个功能放入〜/ .bashrc哪个覆盖CD：</p><p> function cd() { if [ &#34;$#&#34; = &#34;0&#34; ] then pushd ${HOME} &gt; /dev/null elif [ -f &#34;${1}&#34; ] then ${EDITOR} ${1} else pushd &#34;$1&#34; &gt; /dev/null fi}function bd(){ if [ &#34;$#&#34; = &#34;0&#34; ] then popd &gt; /dev/null else for i in $(seq ${1}) do popd &gt; /dev/null done fi}</p><p> 函数cd（）{如果[＆＃34; $＃＆＃34; =＆＃34; 0＆＃34; ]然后按下$ {home}＆gt; / dev / null elif [-f＆＃34; $ {1}＆＃34; ]然后$ {编辑} $ {1} else pushd＆＃34; $ 1＆＃34; ＆gt; / dev / null fi}函数bd（）{如果[＆＃34; $＃＆＃34; =＆＃34; 0＆＃34; ]然后popd＆gt; / dev / null each i for i $（seq $ {1}）do popd＆gt; / dev / null完成fi}</p><p>  bd also accepts a number  n as an argument which let’s you step back  n directories at a time</p><p>  BD也接受一个数字n作为一个参数，让您一次退回N目录</p><p>  if the  cd argument is a file instead of a directory it will assume that you want to edit it as a text file and open it in you favorite editor.</p><p>  如果CD参数是文件而不是目录，它将假设您要将其编辑为文本文件并在您喜欢的编辑器中打开它。 </p><p> You can still use  dirs to list the history and adjust the function above to your taste.</p><p>您仍然可以使用Dirs列出历史记录并将上述功能调整到您的口味。</p><p>    When I type  ls to inspect to contents of the current directory and decideif want to move to one of the subdirectories: why do I have to type it again(or at least enough for Tab completion to work), even though the directory nameis already on the screen? This is the idea behind aliases like</p><p>    当我键入ls检查当前目录的内容并决定要移动到其中一个子目录：为什么我必须再次键入它（或者至少足够足以完成工作），即使目录名称已打开屏幕？这是别名背后的想法</p><p> alias lln=&#34;ls -lhtr --time-style long-iso | tac | cat -n | tac | sed -s &#39;s/^\s*\([0-9]*\)\s*\(.*\)/[\1] \2 [\1]/&#39;g &amp;&amp; pwd&#34;function lf() { if [ &#34;x${1}&#34; == &#34;x&#34; ] then n=1 else n=&#34;${1}&#34; fi ls -rt1 | tail -n ${n} | head -n 1}</p><p> 别名lln =＆＃34; ls -lhtr  - 时间式的long-iso | TAC |猫-N | TAC | sed -s＆＃39; s / ^ \ s * \（[0-9] * \）\ s * \（。* \）/ [\ 1] \ 2 [\ 1] /＆＃39; g＆amp ;＆amp; PWD＆＃34;函数lf（）{如果[＆＃34; x $ {1}＆＃34; ==＆＃34; x＆＃34;然后n = 1否则n =＆＃34; $ {1}＆＃34; fi ls -rt1 |尾巴 -  $ {n} | head-n 1}</p><p> Now, typing  lln will show the contents of the current directory orderedby time with the latest file at the bottom. But you will also notice thateach line is flanked by an index starting with the latest file at 1. Nowtyping</p><p> 现在，键入LLN将显示当前目录已订购的时间与底部的最新文件。但是，您还会注意到围绕以最新文件开始的索引侧翼的索引。</p><p>  or  lf (1 is the default argument) will produce the filename assignedto the index one. If this is a directory, I can issue  cd $(lf 1) to changeinto the latest directory. Of course, I can combine  lf with any othercommand, like e.g.</p><p>  或者lf（1是默认参数）将生成分配给索引的文件名。如果这是一个目录，我可以将CD $（LF 1）发出到ChangeInto最新目录。当然，我可以将LF与任何其他人合并，如例如。</p><p>        The last tip aims for faster retrieval of commands from history. Usually, the up-arrow jumps to the previous command in the history. However this quickly becomes very tedious if one jumps 5 or 10 or more commands back in history. Instead ifyou put</p><p>        最后一个提示旨在更快地检索历史记录的命令。通常，Up-arrow跳转到历史记录中的前一个命令。然而，如果一个跳跃在历史记录中的命令5或10个或更多命令，这很快就会变得非常乏味。相反，如果你放了</p><p>  into your  /.bashrc and start typing part of a command it will only jump to those commands in the history which start with the same fragment of a command. This is useful for any command line work and you may already know if from e.g.  IPython but it is also useful for  cd. So</p><p>  进入您的/.bashrc并开始键入命令的一部分，它只将跳转到历史记录中的命令，该命令以命令的相同片段开始。这对于任何命令行工作都很有用，并且您可能已经知道如果是从例如例如来自iPython，但它对CD也很有用。所以 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html">https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/目录/">#目录</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>