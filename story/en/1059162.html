<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何阅读着色器组件 How to Read Shader Assembly</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Read Shader Assembly<br/>如何阅读着色器组件 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 23:29:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/c95201c319e57e0b495cc0fbcfc98424.png"><img src="http://img2.diglog.com/img/2021/4/c95201c319e57e0b495cc0fbcfc98424.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When I started graphics programming, shading languages like HLSL and GLSL were not yet popular in game development and shaders were developed straight in assembly. When HLSL was introduced I remember us trying, for fun, to beat the compiler by producing shorter and more compact assembly code by hand, something that wasn’t that hard. Since then shader compiler technology has progressed immensely and nowadays, in most cases, it is pretty hard to produce better assembly code by hand (also the shaders have become so large and complicated that it is not cost effective any more anyway).</p><p>当我开始图形编程时，像HLSL和GLSL这样的着色语言在游戏开发中尚未流行，并在装配中直接开发着色器。当介绍HLSL时，我记得我们尝试乐趣，通过手工制作更短，更紧凑的汇编代码来击败编译器，这不是那么难的东西。从那时起，Shader编译器技术已经完全进展，在现在，在大多数情况下，它很难通过手工制作更好的装配码（也是着色器已经变得如此大而复杂的是，无论如何都没有成本效益）。</p><p> Even though no one writes shaders in assembly directly nowadays, it is still useful for a graphics programmer to be able to read and understand the shader assembly (ISA) code produced by the compiler. First, it helps one understand how is the compiler interpreting the high level shader instructions. Some instructions, for eg tan() or integer division don’t map directly to hardware and can expand into many assembly instructions. Second it can help understand how the GPU works, how requests data, performs branches, writes to the output etc. Third, it can help with shader debugging when the actual shader code is not available. And although we don’t typically hand tune shader assembly any more, understanding it can help us make better high-level shader authoring decisions which can lead to higher performance assembly code. Finally, for me personally, it is quite cathartic to sometimes read code without layers of abstraction, with a clear understanding of what it does and as close to the metal as possible.</p><p> 尽管现在没有人直接在组装中写入着色器，但是对于能够读取和理解编译器生成的着色器组件（ISA）代码仍然有用。首先，它有助于一个了解编译器如何解释高级着色器指令。某些指令，例如TAN（）或整数划分不会直接映射到硬件，并可以扩展到许多装配说明中。其次，它可以帮助了解GPU的工作原理，如何请求数据，执行分支，写入输出等。第三，它可以帮助着色器调试当实际着色器代码不可用时。虽然我们通常不再使用调整着色器组装，但了解它可以帮助我们做出更好的高级着色器创作决策，这可能导致更高的性能汇编代码。最后，对于我个人而言，它是相当于有时读取没有抽象层的代码的宣告，清楚地​​了解它尽可能靠近金属。</p><p> In this blog post we will discuss shader assembly a bit and provide some pointers on how to read it. This discussion focuses mainly on DirectX and HLSL, similar ideas would apply to other APIs/shading languages. Also in the examples I am using AMD’s shader assembly (ISA) as it is well documented and easy to access with tools like the excellent  Shader Playground even if one doesn’t have access to an AMD GPU.</p><p> 在此博客文章中，我们将讨论着色器组件一点并提供一些指针如何阅读它。该讨论主要集中在DirectX和HLSL上，类似的想法适用于其他API /着色语言。同样在我使用AMD的着色器组件（ISA）的示例中，因为它可以很好地记录并且易于使用像优秀的着色器游乐场等工具，即使一个人无法访问AMD GPU。</p><p> Before we start it is worth mentioning that shader compilation is done in 2 stages: first a tool like fxc or dxc compiles the HLSL code into a GPU agnostic format called Intermediate Language (IL). Then the GPU driver converts the IL into the final shader assembly (ISA) that can be executed on a specific GPU. We will be focusing on ISA, and not on IL, as it is more representative of the code that will actually be executed. In the following example,  an HLSL shader that multiplies two numbers produces the IL code on the left and the ISA code on the right. The IL code is still relatively high level and hides a lot of the implementation details.</p><p> 在我们开始之前，值得一提的是，着色器编译在2个阶段完成：首先是FXC或DXC等工具，将HLSL代码编译为称为中间语言（IL）的GPU无人物格式。然后GPU驱动程序将IL转换为可以在特定GPU上执行的最终着色器组件（ISA）。我们将重点关注ISA，而不是在IL上，因为它更具代表性的代表实际执行。在以下示例中，将两个数字乘以两个数字的HLSL着色器在右侧的IL代码和ISA代码中产生。 IL代码仍然比较高，并隐藏了很多实现细节。</p><p> s_mov_b32 m0, s8 s_buffer_load_dwordx4 s[0:3], s[4:7], 0x00 v_interp_p1_f32 v2, v0, attr0.x v_interp_p2_f32 v2, v1, attr0.x v_interp_p1_f32 v3, v0, attr0.y v_interp_p2_f32 v3, v1, attr0.y v_interp_p1_f32 v4, v0, attr0.z v_interp_p2_f32 v4, v1, attr0.z v_interp_p1_f32 v0, v0, attr0.w v_interp_p2_f32 v0, v1, attr0.w s_waitcnt lgkmcnt(0) v_mul_f32 v1, s0, v2 v_mul_f32 v2, s1, v3 v_mul_f32 v3, s2, v4 v_mul_f32 v0, s3, v0 v_cvt_pkrtz_f16_f32 v1, v1, v2 v_cvt_pkrtz_f16_f32 v0, v3, v0 exp mrt0, v1, v1, v0, v0 done compr vm s_endpgm end</p><p> S_MOV_B32 M0，S8 S_BUFFER_LOAD_DWORDX4 S [0：3]，S [4：7]，0x00 V_INTERP_P1_F32 V2，V0，attr0.x v_interp_p2_f32 v2，v1，attr0.x v_interp_p1_f32 v3，v0，attr0.y v_interp_p2_f32 v3，v1，attr0 .y v_interp_p1_f32 v4，v0，attr0.z v_interp_p2_f32 v4，v1，attr0.zv_interp_p1_f32 v0，v0，attr0.wv_interp_p2_f32 v0，v1，attr0.w s_waitcnt lgkmnt（0）v_mul_f32 v1，s0，v2 v_mul_f32 v2，s1， V3 v_mul_f32 v3，s2，v4 v_mul_f32 v0，s3，v0 v_cvt_pkrtz_f16_f32 v1，v1，v2 v_cvt_pkrtz_f16_f32 v0，v3，v0 exp mrt0，v1，v1，v0，v0完成了VM S_ENDPGM结束</p><p> Let’s consider this  fictional HLSL shader. Although it doesn’t do anything useful, it uses a lot of the language features one would use in more realistic scenarios, like attribute interpolation, constant buffers, texture reads, Maths operation and branches:</p><p> 让我们考虑这个虚构的HLSL着色器。虽然它没有做任何有用的事情，但它使用了许多语言功能，虽然是一个在更现实的方案中使用的语言功能，如属性插值，常量缓冲区，纹理读取，数学操作和分支：</p><p>  This is the shader assembly it produces, using Radeon GPU Analyser targeting AMD’s GCN GPU architecture:</p><p>  这是它产生的着色器组装，它使用Radeon GPU分析仪定位AMD的GCN GPU架构： </p><p>  At first glance it looks like a mess of cryptic instructions and numbers but let’s try first to colour code corresponding areas between the two shaders to get a rough feel of how HLSL translates to assembly.</p><p>乍一看，它看起来像是一系列的隐秘指令和数字，但是让我们先尝试两个着色器之间的彩色代码相应的区域，以获得HLSL如何转化为装配的粗略感觉。</p><p> float4 PSMain(PSInput input) : SV_TARGET{  float4 result = tex.Sample(samplerLinear, input.uv);   float factor = data.x * data.y;	  if( factor &gt; 0 ) 	 return  data.z * result; else 	 return  data.w * result; }</p><p> float4 psmain（psInput输入）：sv_target {float4结果= tex.sample（Samplerlinear，Input.uv）;浮动因子= data.x * data.y; if（因子＆gt; 0）返回data.z *结果;否则返回data.w *结果; }</p><p> s_mov_b32 m0, s20 s_mov_b64 s[22:23], exec s_wqm_b64 exec, exec v_interp_p1_f32 v2, v0, attr0.x v_interp_p2_f32 v2, v1, attr0.x v_interp_p1_f32 v3, v0, attr0.y v_interp_p2_f32 v3, v1, attr0.y s_and_b64 exec, exec, s[22:23]  image_sample v[0:3], v[2:4], s[4:11], s[12:15] dmask:0xf s_buffer_load_dwordx4 s[0:3], s[16:19], 0x00 s_waitcnt lgkmcnt(0)  v_mov_b32 v4, s1 v_mul_f32 v4, s0, v4   v_cmp_lt_f32 vcc, 0, v4 s_cbranch_vccz label_0017  s_waitcnt vmcnt(0)   v_mul_f32 v0, s2, v0 v_mul_f32 v1, s2, v1 v_mul_f32 v2, s2, v2 v_mul_f32 v3, s2, v3  s_branch label_001C label_0017: s_waitcnt vmcnt(0)  v_mul_f32 v0, s3, v0 v_mul_f32 v1, s3, v1 v_mul_f32 v2, s3, v2 v_mul_f32 v3, s3, v3  label_001C: s_mov_b64 exec, s[22:23] v_cvt_pkrtz_f16_f32 v0, v0, v1 v_cvt_pkrtz_f16_f32 v1, v2, v3  exp mrt0, v0, v0, v1, v1 done compr vm s_endpgm end</p><p> S_MOV_B32 M0，S20 S_MOV_B64 S [22:23]，EXEC S_WQM_B64 EXEC，EXEC v_interp_p1_f32 v2，v0，attr0.x v_interp_p2_f32 v2，v1，attr0.x v_interp_p1_f32 v3，v0，attr0.y v_interp_p2_f32 v3，v1，attr0.y s_and_b64 EXEC，EXEC，S [22:23] IMAGE_SAMPLE V [0：3]，V [2：4]，S [4:11]，S [12:15] DMASK：0xF S_BUFFER_LOAD_DWORDX4 S [0：3]，S [16:19]，0x00 S_WAITCNT LGKMCNT（0）V_MOV_B32 V4，S1 V_MUL_F32 V4，S0，V4 V_CMP_LT_F32 VCC，0，V4 S_CBRANCH_VCCZ标签_0017 S_WAITCNT VMCNT（0）V_MUL_F32 V0，S2，V0 V_MUL_F32 V1，S2，V1 V_MUL_F32 V2， S2，V2 V_MUL_F32 V3，S2，V3 S_BRANCH标签_001C LABET_0017：S_WAITCNT VMCNT（0）V_MUL_F32 V0，S3，V0 V_MUL_F32 V1，S3，V1 V_MUL_F32 V2，S3，V2 V_MUL_F32 V3，S3，V3 LABED_001C：S_MOV_B64 EXEC，S [22 ：23] v_cvt_pkrtz_f16_f32 v0，v0，v1 v_cvt_pkrtz_f16_f32 v1，v2，v3 exp mrt0，v0，v0，v1，v1完成了vm s_endpgm结束</p><p> The uncoloured parts correspond to code the GPU has to execute to setup the main instructions highlighted.</p><p> uncolourted部分对应于代码GPU必须执行以设置突出显示的主要指令。</p><p> A few things worth discussing before we start digging deeper into the code. First we notice almost all instructions start either with the prefix  v_ or the prefix  s_, eg  v_mul_f32 and  s_mov_b32. This gives us some information about the hardware itself: the GCN architecture batches work items (pixels, vertices etc) in batches of 64, called wavefronts, and executes each shader instruction on them in parallel, either operating on data unique to each thread (using the v_ prefix, from vector) or data common to all threads (the s_ prefix from scalar). Worth mentioning that a work item is also often called a “thread”. Multiplying a pixel’s colour by a value is an operation that uses data unique to each thread so the GPU would use a vector instruction. Reading a value from a constant buffer uses data common to all threads so the GPU would use a scalar instruction.</p><p> 在我们开始深入挖掘代码之前，一些值得讨论的事情。首先，我们注意到几乎所有指令都以前缀v_或前缀s_，例如v_mul_f32和s_mov_b32开始。这为我们提供了一些关于硬件本身的信息：GCN架构批量批量为64，称为Wavefronts的工作项（像素，顶点等），并并行执行每个着色器指令，无论是对每个线程唯一的数据运行（使用对所有线程共用的V_前缀，矢量）或数据共用（SCALAR的S_前缀）。值得一提的是工作项目也经常被称为“线程”。将像素的颜色乘以值是使用每个线程唯一的数据的操作，因此GPU将使用矢量指令。从常量缓冲区读取值使用所有线程共用的数据，因此GPU将使用标量指令。</p><p> This is a good opportunity to also briefly discuss the type of registers the vector and scalar instructions operate on. The shader code listed above is peppered with vector (vXX) and scalar (sXX) registers, eg  v_mul_f32  v1,  s3,  v1. Registers store data locally that the shader instructions use in operations. A vector register stores one 32 bit quantity per wavefront thread (64 in total) and a scalar register stores one 32 bit quantity common to all threads. I attempted a diagram showcasing a 64 thread wavefront and how a vector and scalar register maps to it to help clarify this.</p><p> 这是一个很好的机会，还简要讨论寄存器的类型矢量和标量指令的操作。上面列出的着色器代码用载体（Vxx）和标量（SXX）寄存器，例如v_mul_f32 v1，s3，v1。寄存在本地存储数据，即在操作中使用着色器指令。向量寄存器存储每个波前螺纹的32位数量（总共64个），标量寄存器存储所有线程共用的32位数量。我尝试了一个图表展示了64个线程波前以及矢量和标量寄存器如何映射到它来帮助澄清这一点。</p><p>  The mul instruction I mentioned above will multiply the per thread v1 vector register value with the, common to all threads, s3 scalar register value and store the result in the v1 vector register. Sometimes the register indices are presented in brackets for eg s[22:23]. This indicates a register range (scalar registers 22 and 23 in this example) that can be used to store quantities larger than 32 bits.</p><p>  上面提到的MUL指令将与所有线程，共同的所有线程，S3标量寄存器值乘以每个线程V1向量寄存器值，并将结果存储在V1向量寄存器中。有时寄存器指数以括号呈现为例如S [22:23]。这表示可用于存储大于32位的数量的寄存器范围（在该示例中的标量寄存器22和23。 </p><p> Finally, it is worth noticing that each instruction indicates the data type is operates on. For example v_mul _f32 operates on 32 bit floating point numbers, v_mov _b32 “copies” 32 bit (untyped) quantities between registers, v_cvt_pkrtz _f16_f32 converts a 32 bit floating point number to a 16 bit one. This is useful to understand the data type and size (16, 32, 64 bits) each instruction uses.</p><p>最后，值得注意的是，每个指令都指示数据类型是开启的。例如，v_mul _f32在32位浮点数上操作，v_mov _b32“副本”32位（非款待）寄存器之间的数量，v_cvt_pkrtz _f16_f32将32位浮点数转换为16位。这对于了解每个指令使用的数据类型和大小（16,32,64位）是有用的。</p><p> With that information at hand let’s start deciphering the assembly code one chunk at a time.</p><p> 通过该信息，让我们开始一次解码装配汇编代码一块。</p><p>  The shader starts with some setup code. Since we will be doing some interpolation later the compiler fills the M0 register (one per wavefront, 32 bits) with the Local Data Store (LDS) offset to the interpolation data (per vertex uv coordinates in this case). Next, it takes a copy of the  exec register into the scalar registers 22 and 23. The exec (Execute Mask) register stores a 64 bit mask, one bit per wavefront thread, which decides which threads are active and inactive at any moment. Because this register is common to all wavefront threads a scalar ( s_) instruction is used. Also, this is a good example of combining registers to store values larger then 32 bits. Finally, it executes a  s_wqm_b64 instruction to determine which threads in the wavefront belong to an active pixel quad. Pixel shaders always operate on groups of 2×2 pixels. If a pixel in that quad is active, which means that it covers a triangle, all pixels in the quad will be marked as active. This is done to allow the GPU to determine which quads are active for derivative calculations.</p><p>  着色器从某些设置代码开始。由于我们将在进行一些插值后，编译器将M0寄存器（每个波前，32位）与本地数据存储（LDS）偏移到插值数据（在这种情况下每个顶点UV坐标）。接下来，它将EXEC寄存器的副本到标量寄存器22和23。因为该寄存器对所有波前线程常见，所以使用标量（S_）指令。此外，这是组合寄存器来存储值较大的寄存器的一个很好的例子。最后，执行S_WQM_B64指令，以确定波前中的哪个线程属于活动像素四边形。像素着色器始终在2×2像素的组上运行。如果Quad中的像素处于活动状态，这意味着它覆盖三角形，则Quad中的所有像素将被标记为活动状态。这样做是为了允许GPU确定哪些四边形是有效的衍生计算。</p><p>  The next snippet  interpolates the float2 uv coordinates provided by the vertex shader via the local data store (LDS) memory, using the offset stored in M0 register above. We use vector instructions (prefix v_) in this case because each thread (pixel) will have its own uv value. We notice that the interpolation for each uv.x and uv.y component is done in two steps p1 and p2, two instructions per component. During those two steps the GPU reads 3 uv component values, one per vertex, along with the 2 barycentric coordinates and interpolates the final value. This provides us with another piece of knowledge about the GPU hardware, that interpolation is happening in the shader and that there is no dedicated hardware for it. The uv coordinates are now stored in vector registers v2 and v3.</p><p>  下一段代码段通过本地数据存储器（LDS）存储器插入由顶点着色器提供的FLOAT2 UV坐标，使用上面M0寄存器中存储的偏移量。在这种情况下，我们使用矢量指令（前缀v_），因为每个线程（像素）都有自己的UV值。我们注意到每个UV.X和UV.Y组件的插值都是在两个步骤P1和P2，每个组件的两个指令中完成。在这两个步骤中，GPU读取3个UV分量值，每个顶点一个，以及2个重心坐标，并插入最终值。这为我们提供了另一种关于GPU硬件的知识，即在着色器中发生插值，并且没有专用硬件。 UV坐标现在存储在向量寄存器V2和V3中。</p><p>  This instruction updates the execution mask for all the wavefront threads. If a thread doesn’t belong to an active pixel quad it gets deactivated.</p><p>  此指令更新所有波前线程的执行掩码。如果一个线程不属于活动像素Quad，则它会停用。</p><p>  This is a texture sample instruction. The _sample postfix implies that this operation can also filter data through a SamplerState object, which is what the HLSL code in the example uses. The first vector register range, v[0:3], indicates the 4 registers that will be used to store the result (v0-v3, 4 floating point values), the v[2:4] range contains the uv coordinates interpolated above (v2 and v3), the scalar register range [4:11] contains the 8 registers used to stored the texture descriptor (which points to the memory address of the texture) and the other scalar range [12:15] contains the 4 registers used to store the descriptor (memory address) of the sampler object used for the filtering of the texture samples (the SamplerState object defined in the HLSL shader). The final dmask (4-bit data mask) operand specifies how many components the texture read should process. A value of 0xf specifies all 4 components. Even though it doesn’t have the v_ prefix, image_sample is a vector instruction.</p><p>  这是纹理样本指令。 _Sample Postfix意味着该操作还可以通过Samplertate对象过滤数据，这是示例使用中的HLSL代码。第一个向量寄存器范围V [0：3]表示将用于存储结果的4寄存器（V0-V3,4浮点值），V [2：4]范围包含上述内插的UV坐标（v2和v3），标量寄存器范围[4:11]包含用于存储纹理描述符的8个寄存器（它指向纹理的内存地址），另一个标量范围[12:15]包含4个寄存器用于存储用于过滤纹理样本的采样器对象的描述符（内存地址）（HLSL着色器中定义的Samplertate对象）。最终的DMASK（4位数据掩码）操作数指定纹理读取应该处理的组件数量。 0xF的值指定所有4个组件。即使它没有v_前缀，image_sample也是向量指令。</p><p>  Next, we need to read the constant data from the constant buffer to multiply the texture colours by. Reading from a constant buffer is a scalar operation common to all wavefront threads, so an  s_buffer_load_dwordx4 is issued. The first scalar range specifies the scalar registers to store the results of the load (s0-s3, 4 fp32 values) and the second range specifies the descriptor of the constant buffer (points to the memory address it is stored). All memory loads have latency, which means that it takes a number of clock cycles (potentially large) from the time a load is issued with the s_buffer_load and when the returned value can be used in the subsequent  v_mov_b32 instruction, so the shader compiler adds a  s_waitcnt instruction between the two that will stall if the data are not ready to be used. The  lgkmcnt argument in a wait instruction signifies that the instruction waits for a constant buffer (or Local/Global data store) read to return. Once the data is here, the shader issues a move instruction to copy the value of s1 to the v4 register and subsequently an v_mul instruction to multiply it with the s0 register (effectively implementing the  float factor = data.x * data.y HLSL instruction.</p><p>  接下来，我们需要从常量缓冲区读取常量数据以将纹理颜色乘以。从恒定缓冲区读取是所有波前线程共有的标量操作，因此发出S_BUFFER_LOAD_DWORDX4。第一个标标量指定用于存储负载结果的标量寄存器（S0-S3，4 FP32值），第二范围指定恒定缓冲区的描述符（指向它存储的存储器地址）。所有内存负载都具有延迟，这意味着它需要多个时钟周期（潜在大）从带有S_buffer_load和返回的值可以在后续v_mov_b32指令中使用时，因此着色器编译器添加了一个S_WAITCNT指令在两者之间会停止，如果数据未准备好用于使用。等待指令中的LGKMCNT参数表示指令等待常常缓冲区（或本地/全局数据存储）读取返回。一旦数据在这里，着色器就会发出移动指令，将S1的值复制到V4寄存器，然后将v_mul指令与s0寄存器乘以（有效地实现浮动因子= data.x * data.y hlsl指令。 </p><p> This code exposes another bit of info about the hardware, that it doesn’t support direct multiplication of scalar values, it has to first copy one of the two to vector registers. Is this true for all data types? Apparently not, if I change the constant buffer data to be uint4 instead of float4, the shader will issue an integer multiplication instruction  s_mul_i32 to directly multiply the two scalar values:</p><p>此代码公开了关于硬件的另一个信息，即不支持标量值的直接乘法，必须首先将两个中的一个复制到向量寄存器。这对于所有数据类型都是如此？显然不是，如果我将常量缓冲区数据更改为UINT4而不是float4，那么着色器将发出一个整数乘法指​​令s_mul_i32，以直接乘以两个标量值：</p><p>    Now the shader has the result of the multiplication in v4 it can do a  v_cmp_lt_f32 instruction to determine if it is  less than zero. This instruction sets the Vector Condition Code register (VCC, bit value of 1 means that a thread passed, 0 failed the comparison). Remember that although it is vector comparison (i.e. a different one for each thread), v4 contains the same value for all threads so the result will be same for all threads. If the result of the comparison stored in VCC is zero ( s_cbranch_vccz), which means that the “less than” comparison failed, the shader will skip the following branch of the code and continue execution from label_0017.</p><p>    现在，着色器具有v4中乘法的结果，它可以执行v_cmp_lt_f32指令，以确定它是否小于零。该指令设置矢量条件代码寄存器（VCC，1表示通过的线程，0失败了比较）。请记住，虽然它是矢量比较（即每个线程的不同一个），但V4包含所有线程的相同值，因此结果将对所有线程相同。如果存储在VCC中的比较结果为零（S_CBRANCH_VCCZ），这意味着“小于”比较失败，则着色器将跳过以下代码的分支并继续从LABEL_0017执行。</p><p> Another bit of insight about the hardware here as well. Although the “comparison” instruction is vector (treats each thread in the wavefront differently), the actual branch instruction is scalar, i.e. the same for all threads. On GCN this is true for all type of branches, they are handled by the Scalar Unit. Also, the branch in this case is all or nothing, either all threads’ factor.x value is less than zero or all larger than zero because the compiler knows that that value originated as a scalar and is the the same for all threads, i.e. there is no divergence. If I changed the comparison value to vary per thread:</p><p> 另一点关于硬件的洞察力也是如此。虽然“比较”指令是矢量（以不同方式处理波前的每个线程），但实际的分支指令是标量，即所有线程都是相同的。在GCN上，对于所有类型的分支机构来说，它们是由标量单元处理的。此外，在这种情况下，分支是全部或全部，所有线程的因子编码值小于零或大于零，因为编译器知道该值源自标量，并且对所有线程都是相同的没有分歧。如果我将比较值更改为每个线程的变化：</p><p> float4 PSMain(PSInput input) : SV_TARGET{ float4 result = tex.Sample(samplerLinear, input.uv); 	 if( result.x &gt; 0 ) 	return data.z * result; else 	return data.w * result; }</p><p> float4 psmain（psInput输入）：sv_target {float4结果= tex.sample（Samplerlinear，Input.uv）; if（结果.x＆gt; 0）返回data.z *结果;否则返回data.w *结果; }</p><p>  image_sample v[0:3], v[2:4], s[4:11], s[12:15] dmask:0xf s_mov_b64 s[0:1], exec s_waitcnt vmcnt(0) v_cmpx_gt_f32 s[2:3], v0, 0 s_cbranch_execz label_0017</p><p>  image_sample v [0：3]，v [2：4]，s [4:11]，s [12:11] dmask：0xf s_mov_b64 s [0：1]，exec s_waitcnt vmcnt（0）v_cmpx_gt_f32 s [2： 3]，v0,0 s_cbranch_execz label_0017</p><p> Now the shader compiler puts the execution mask into use (which controls which thread is active or not), using the  v_cmpx_gt_f32 instruction to store the result of the per-thread comparison directly into it. Threads that fail the comparison will be “skipped over”, when the  s_cbranch_execz instruction (which branches using the execution mask and not the VCC register) is then executed.</p><p> 现在，着色器编译器将执行掩码放入使用（哪个控制哪个线程是活动的），使用v_cmpx_gt_f32指令将Per-Thread比较的结果直接存储到其中。当然后执行时，当S_CBRANCH_EXECZ指令（使用执行掩码而不是VCC寄存器的分支）时，将“跳过”的线程将“跳过”。</p><p>   This is the first branch of the if-statement to multiply the result of the texture read instruction by the constant value (data.z). Similarly to the constant buffer load above, now that texture read results are needed the GPU must ensure that they are here or undefined behaviour will happen. For this, the shader compiler adds another wait instruction,  s_waitcnt. This time the  vmcnt operant means that it is waiting for a vector memory return (as opposed to a scalar memory return in the case of the constant buffer read). At the end of the snippet the code will unconditionally jump to label_001C to avoid executing the second branch.</p><p>   这是if-stalal的第一个分支，以乘以常量值（data.z）乘以纹理读取指令的结果。与上面的恒定缓冲负载类似，现在需要纹理读取结果，GPU必须确保它们在此处或未定义的行为将发生。为此，着色器编译器添加了另一个待等待指令S_WAITCNT。这次VMCNT操作装置意味着它正在等待向量存储器返回（而不是在常量缓冲器读取的情况下的标量存储器返回）。在代码段的末尾，代码将无条件地跳转到标签_001c以避免执行第二个分支。 </p><p>  This is the second branch in the code, to multiply the result from the texture read by the other constant value (data.w). Focusing on the  v_mul_f32 instruction, it is worth calling out that it can multiply scalars with vectors directly, another bit of info about the underlying hardware. Also worth noticing is that although a float4 multiplication is seemingly one instruction in HLSL and Intermediate Language, it is actually 4 instructions in shader assembly, as dictated by GCN’s design (it has to do with it being a scalar architecture but I don’t want to confuse this with scalar instructions and registers, there is a lot of  material online that describe how it works for more details).</p><p>这是代码中的第二个分支，要将结果乘以其他常量值（data.w）读取的纹理。专注于v_mul_f32指令，值得呼唤它可以直接与矢量乘以矢量，另一个关于底层硬件的信息。值得注意的是，虽然Float4乘法是HLSL和中间语言的似乎是一个指令，但它实际上是着色器组件中的4个指令，如GCN的设计所示（它与标量架构有关，但我不想要要将其与标量指令和寄存器混为一谈，有很多材料在线描述了它如何为更多细节工作）。</p><p>  Shader execution is winding down now, all it remains to be done is write out the results. The snippet starts by restoring the value of the execution mask, stored in the scalars s22 and s23 at the start of the program, to make sure that all required threads will write out the result. The output (a float4 number) is currently stored in vector registers v0-v3. The  v_cvt_pkrtz_f16_f32 instruction will pack the float32 contents of 2 vector registers (eg v0 and v1) into one float32 vector register. This is done twice, for each of the two pairs (v0, v1 and v2, v3). In the end we have the 2 vector registers v0 and v1 that hold the original float4 output in compressed form, to reduce memory bandwidth. Finally, the  exp instruction triggers the copy of the output to the bound render target. The  mrt0 argument means that this instruction targets the first rendertarget in a possible multiple rendertarget configuration (a maximum of 8 rendertargets can be bound as an output to a pixel shader), next follow the vector registers that hold the compressed output values,  done means that this is the last export in the shader,  compr means that the data is in compressed form and  vm flag indicates that the execution mask can used to inform the color buffer which pixels are valid and which have been discarded. With that, the shader stops executing.</p><p>  Shader执行现在正在卷绕，所有它仍有待完成的是写出结果。通过恢复程序在程序的开始时恢复存储在Scalars S22和S23中的执行掩码的值，以确保所有必需的线程将写出结果。输出（FLOAT4号）当前存储在向量寄存器V0-V3中。 V_CVT_PKRTZ_F16_F32指令将将2个向量寄存器（例如，V0和V1）的FLOAT32内容包装到一个FLOAT32向量寄存器中。这是两次（V0，V1和V2，V3）中的每次完成两次。最后，我们有2个向量寄存器V0和V1，该寄存器V0和V1将原始FLOAT4以压缩形式输出，以减少内存带宽。最后，exp指令将输出的副本触发到绑定渲染目标。 MRT0参数意味着该指令以可能的多个Rendertarget配置（最多8个rendertargets绑定为输出到像素着色器），下一步遵循保存压缩输出值的向量寄存器，完成意味着这是着色器中的最后一个导出，CLIC表示数据处于压缩形式，并且VM标志表示执行掩码可以用于通知颜色缓冲器有效的颜色缓冲器有效并且已被丢弃。有了这个，着色器停止执行。</p><p> I mentioned earlier how reading and understanding shader assembly can help one make better decisions during shader authoring. Although the shader example I provided is trivial and not very useful, it is still difficult to see how it can be improved without having an insider knowledge of what the compiler will do with provided code. Tweaking the shader code slightly to take the  return; outside the if-statement branches for example we can see in the assembly that the compiler removes the branches entirely, using 4  v_cndmask_b32 to select the output value based on the result of the comparison instruction  v_cmp_lt_f32.</p><p> 我之前提到了如何阅读和理解着色器组件可以帮助在着色器创作期间做出更好的决定。虽然我提供的着色器示例是微不足道的，但不是很有用，但仍然很难看出，在没有内在知识的情况下，仍然可以改进它的编译器将与提供的代码有关。稍微调整着色器代码以获取返回; IF-Matchene Brankes之外，例如，我们可以在程序集中看到编译器完全删除分支，使用4 v_cndmask_b32基于比较指令v_cmp_lt_f32的结果选择输出值。</p><p>    Although in this case it may not make much performance difference because all threads will always follow one branch of the if-statement, and if anything it increases the number of vector registers used which may not be good, this is good knowledge to apply in other scenarios. The bottom line is that one can’t easily tell how HLSL shader changes will affect the final shader assembly without inspecting it.</p><p>    虽然在这种情况下，它可能不会产生太大的性能差异，因为所有线程都将始终遵循if-statege的一个分支，如果它增加了所使用的矢量寄存器的数量，这是良好的知识，适用于其他场景。底线是，一个人无法轻易判断HLSL着色器如何更改将如何影响最终的着色器组件而不检查它。</p><p> Most of the information I used in this shader assembly breakdown is documented in  Vega’s ISA reference documentation. There is also a large collection of  low-level GPU guides worth researching if you are interested in learning more, for other GPUs as well, and also Emil Persson’s  excellent  presentations on low level shader optimisation.</p><p> 我在此着色器装配故障中使用的大多数信息都记录在Vega的ISA参考文档中。如果您有兴趣了解更多GPU，还有一大批低级GPU指南值得研究，以及其他GPU，也是Emil Persson在低级着色器优化上的出色演示。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://interplayoflight.wordpress.com/2021/04/18/how-to-read-shader-assembly/">https://interplayoflight.wordpress.com/2021/04/18/how-to-read-shader-assembly/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/着色器/">#着色器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shader/">#shader</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>