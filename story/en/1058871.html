<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JavaScript类不是“只是句法糖” JavaScript classes are not “just syntactic sugar”</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">JavaScript classes are not “just syntactic sugar”<br/>JavaScript类不是“只是句法糖” </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-17 08:36:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/7e5168339370850bdff380b02250c1b6.jpeg"><img src="http://img2.diglog.com/img/2021/4/7e5168339370850bdff380b02250c1b6.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>After reading yet another blog post about JS classes being “ just sugar for prototypal inheritance”, I’ve decided to write this post to help clarifying, one more time, why this statement is misleading; a post that hopefully explains what’s the difference and why it matters to understand it.</p><p>阅读又一次博客帖子关于JS课程是“只是糖的原型继承”，我决定写这篇文章来帮助澄清，再一次，为什么这个陈述是误导;一个希望解释有什么区别的帖子以及理解它的原因。</p><p>  Using  &#34;use strict&#34; directive in ES5 won’t forbid constructors to be called without  new keyword.</p><p>  使用＆＃34;使用严格＆＃34;在ES5中的指令将不会禁止禁止胁迫函数，而无需新关键字。</p><p> // ES5 function Test() { &#34;use strict&#34;; } Test.call({}); // it&#39;s OK // ES6+ class Test {} Test.call({}); // it throws</p><p> // ES5功能测试（）{＆＃34;使用严格＆＃34 ;; test.call（{}）; //它＆＃39; s OK // ES6 +类测试{} test.call（{}）; //它抛出</p><p> The reason is that modern classes have a  new.target concept otherwise impossible to replicate in ES5, without using transpilers that simulate such behavior. Transpiler must use an  instanceof check too, resulting in slower, bloated, code.</p><p> 原因是现代类有一个新的概念否则无法在ES5中复制，而不使用模拟此类行为的转发器。 Transpiler也必须使用instanceof检查，导致较慢，膨胀，代码。</p><p>  Des pite  my personal attempts since 2004 to subclass Arrays and others, it’s not really possible to extend builtins in ES5 in a useful, or meaningful, way.</p><p>  自2004年以来，我的个人尝试到子类阵列和其他人，它并不是真的可以在ES5中以有用或有意义的方式扩展内置。</p><p> // ES5 epic fail function List() { &#34;use strict&#34;; } List.prototype = Object.create(Array.prototype); var list = new List; list.push(1, 2, 3); JSON.stringify(list); // {&#34;0&#34;:1,&#34;1&#34;:2,&#34;2&#34;:3,&#34;length&#34;:3} list.slice(0) instanceof List; // false</p><p> // eS5 epic失败函数列表（）{＆＃34;使用strict＆＃34 ;; list.prototype = Object.Create（array.Prototype）; var列表=新列表; list.push（1,2,3）; json.stringify（列表）; // {＆＃34; 0＆＃34;：1，＆＃34; 1＆＃34;：2，＆＃34; 2＆＃34;：3，＆＃34;长度＆＃34;：3} list.slice （0）instanceof列表; // 错误的</p><p> Let’s ignore the fact I am not even using  Array.apply(this, arguments) in the constructor, as that also will fail expectations, an ES5 Array extend is awkward no matter how you look at it, and so is every other builtin, including  String or others.</p><p> 让我们忽略我甚至不使用Array.apply（这，参数），因为它也将失败期望，无论您如何看待它，AS5阵列延伸都是笨拙的，也是其他所有内置的字符串或其他人。 </p><p> // ES5 epic fail v2 function Text(value) {  &#34;use strict&#34;;  String.call(this, value); } new Text(&#34;does this work?&#34;); // nope, it doesn&#39;t ... no way it can.</p><p>// ES5 EPIC失败V2函数文本（价值）{＆＃34;使用严格＆＃34 ;; string.call（此值）;新文本（＆＃34;这项工作吗？＆＃34;）; // nope，它并不......无能为力。</p><p> OK, I hear you, “ who’s gonna need to extend   String  mate?”, and you’re right: you might not need to do so, but the point here is that it’s impossible to do it with ES5, or better: the prototypal inheritance cannot do that, JS classes can.</p><p> 好的，我听到你的声音，“谁会需要延长字符串伙伴？”，你是对的：你可能不需要这样做，但这就是用ES5或更好地做到这一点，或者更好地是不可能的：原型是不可能的继承不能这样做，JS类可以。</p><p>  In case you’re wondering “ how come   list.slice(0)  is not instance of   List ?”, the answer is  Symbol.species.</p><p>  如果您想知道“如何list.slice（0）不是列表的实例？”，答案是符号。</p><p> // ES6+ class List extends Array {} (new List).slice(0) instanceof List; // true [].slice.call(new List) instanceof List; // true</p><p> // es6 +类列表扩展array {}（新列表）.slice（0）instanceof列表; // true [] .slice.call（new list）instanceof列表; // 真的</p><p> Accordingly, unless you are guarding every single method to return the initial kind of instance one would expect through all Array methods, ES5 here is just painful, unreliable, fragile, and not designed to work with species.</p><p> 因此，除非您保护每种方法来返回初始类型的方法，否则将期望通过所有阵列方法，但这里的ES5只是痛苦，不可靠，脆弱，而不是使用物种配合使用。</p><p>   In case you’re wondering “ how come   Array.apply(this, arguments)  in the constructor wouldn’t work in ES5?” the answer is that:</p><p>   如果您想知道“如何传达array.apply（这，参数）在构造函数中无法在ES5工作？”答案是：</p><p> Array builtin creates a new array, it doesn’t care at all about the context, and neither do other builtins</p><p> 数组内置创建一个新数组，它根本不关心上下文，也没有其他内产 </p><p> JS classes promote/upgrade instances, which is something impossible to do in ES5 without a transpiler and, even with the transpiler, it’s a mess when it comes to builtin extends</p><p>JS课程推广/升级实例，在没有转介机的情况下，在ES5中是不可能做的，即使与Transpiler一样，它在内置延伸时是一团糟</p><p>    And yes, the correct answer is the latter one, so that unless we write all sub-classes as such:</p><p>    是的，正确的答案是后者，所以除非我们编写所有子类别：</p><p> function MySubClass() {  var self = Class.apply(this, arguments) || this;  // do anything with the self  return self; }</p><p> 函数mysubclass（）{var self = class.apply（这，参数）||这; //用自我回归自我做任何事情; }</p><p>  if the super class is a Builtin, we might have a  self that points at a primitive instead</p><p>  如果超级级是一个内置的，我们可能会在一个原始的自我时代</p><p>  function MySubClass() {  var self = Class.apply(this, arguments);  if (self == null)  self = this;  else if (!(self instanceof MySubClass)) {  Object.setPrototypeOf(self, MySubClass.prototype);  // do things with self  return self; }</p><p>  函数mysubclass（）{var self = class.apply（这，参数）;如果（self == null）self = the;否则if（！（selficationof mysubclass））{object.setprototypeof（self，mysubclass.prototype）; //做自我回报的事情; }</p><p>  // ES6+ class Button {  constructor() {  return document.createElement(&#39;button&#39;);  } } class MyButton extends Button {  constructor(value) {  super();  this.textContent = value;  } } document.body.appendChild(new MyButton(&#34;hello&#34;));</p><p>  // es6 +类按钮{constructor（）{return document.createelement（＆＃39;按钮＆＃39;）; Class MyButton扩展了按钮{构造函数（值）{super（）; this.textContent = Value; Document.Body.AppendChild（新MyButton（＆＃34;你好＆＃34;））;</p><p>    This is not strictly some JS classes feature, but it’s something many don’t know: methods are not constructible, same as shorthand literal methods.</p><p>    这不是严格的一些JS类功能，但这是许多不知道的东西：方法不构成，与速记文字方法相同。 </p><p>  In ES5 all functions can be used as constructor, and there’s no way to avoid this unless we check the context brand each time.</p><p>在ES5中，所有功能都可以用作构造函数，除非每次检查上下文品牌，否则都无法避免这种情况。</p><p> // ES5 function Test() {} Test.prototype.method = function () {  if (!(this instanceof Test))  throw new TypeError(&#34;not a constructor&#34;); };</p><p> // ES5函数test（）{} test.prototype.method = function（）{if（！（这个实例测试））抛出新的typeerror（＆＃34;不是构造函数＆＃34;）; };</p><p> Do you see yourself writing code like this to assert JS classes are just sugar?</p><p> 你看到自己写作这样的代码是因为宣言课程只是糖吗？</p><p>  In JS classes both static and non static methods are not enumerable. Yes, we can do that with ES5 too, but the boilerplate is huge, slow, and awkward.</p><p>  在JS类中，静态和非静态方法都不是令人令人登应的。是的，我们也可以用ES5做到这一点，但是Boilerplate巨大，慢，尴尬。</p><p>  In JS classes we can specify arrows in the class definition. We can do the same in ES5 constructors, but we need again a lot of boilerplate to simulate the same:</p><p>  在JS类中，我们可以在类定义中指定箭头。我们可以在ES5构造函数中做同样的事情，但我们再次需要大量的样板来模拟相同的样板：</p><p> // ES5 function WithArrows() {  Object.defineProperties(this, {  method1: {  configurable: true,  writable: true,  value: () =&gt; &#34;arrow 1&#34;  }  }); } // ES6+ class WithArrows {  method1 = () =&gt; &#34;arrow 1&#34;; } // (new WithArrows).method1();</p><p> // es5函数witharrows（）{object.defineproperties（这，{method1：{可配置：true，写：true，value：（）=＆gt;＆＃34;箭头1＆＃34;}）; } // es6 +类与arrows {method1 =（）=＆gt; ＆＃34;箭头1＆＃34 ;; } //（新的witharrows）.method1（）;</p><p>   // ES6+ class WithPrivates {  #value;  #method(value) {  this.#value = value;  }  constructor(value) {  this.#method(value);  } }</p><p>   // es6 +类inprivates {#value; #method（价值）{这个。＃value = value;构造函数（值）{此。＃方法（值）; }} </p><p> Could we simulate privates in ES5? Not really, unless we use a transpiler and  WeakMap to trap each instance with specific privates that should never leak out there, with no guards in case such leak happens.</p><p>我们可以在ES5中模拟私人吗？不是真的，除非我们使用Transpiler和Dealmap来捕获每个实例，特定私有私有遗漏，不应该在那里泄漏，如果发生这种泄漏的情况下没有警卫。</p><p>  Yes, there are many things that could be simulated via ES5 and old prototypal inheritance, but none of these come out of the box, are as fast, or as safe, as using appropriate syntax for classes and, on top of that,  there are things that are just not possible with prototypal inheritance.</p><p>  是的，可以通过ES5和旧原型继承来模拟许多事情，但这些都不是出来的，并且与类的适当语法一样快，或者是安全的，并且在那里原型遗产不可能的事情。</p><p> Accordingly, let’s please stop saying that JS classes are just sugar, because the amount of details missing in such statement cannot be overlooked, or ignored, unless we decide that we don’t want to use modern classes features that could make OOP in JS much better than it’s been for the last 20, prototypal, years.</p><p> 因此，让我们停止说，JS类只是糖，因为除非我们决定不想使用可以在JS中制作OOP的现代类功能，否则不能被忽视或忽略这些陈述中缺少的细节数量比最后20个，原型，年好。</p><p> In such case though, the right statement would be more like: “ I don’t like JS classes hence I think we were just OK with prototypal inheritance”.</p><p> 在这种情况下，正确的陈述更像：“我不喜欢JS课程，因此我认为我们的原型继承了”。</p><p> Now that’s a much more honest, and correct, statement … while saying classes are “ just sugar” is a very poor idea of modern JS and its features.</p><p> 现在这是一个更诚实的，纠正，声明......说课程是“只是糖”是一个非常糟糕的现代JS及其特征。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://webreflection.medium.com/js-classes-are-not-just-syntactic-sugar-28690fedf078">https://webreflection.medium.com/js-classes-are-not-just-syntactic-sugar-28690fedf078</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/classes/">#classes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/es5/">#es5</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>