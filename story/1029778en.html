<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>兰姆达微积分的乐趣</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">兰姆达微积分的乐趣</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 20:31:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png"><img src="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In 1935, a gentleman called Alonzo Church came up with a simple scheme that could compute…just about anything. His scheme was called Lambda Calculus. It was a phenomenal innovation, given that there weren’t even computers for him to test out his ideas. Even cooler is that those very ideas affect us today: anytime you use a function, you owe a hat tip to Mr. Church.</p><p>1935年，一位名叫阿隆佐·丘奇的绅士想出了一个可以计算…的简单方案。几乎什么都行。他的方案被称为兰姆达微积分(Lambda Calculus)。这是一项非凡的创新，因为他甚至没有电脑来测试他的想法。更酷的是，这些想法在今天影响着我们：任何时候你使用一个函数，你都应该向丘奇先生致敬。</p><p> Lambda Calculus is so cool that many hackers use it as their secret handshake — a “discreet signal” if you will. The most famous, of course, is PG’s Y Combinator. In this essay, we’ll find out what it’s all about, and do things with functions that we’d never have imagined. In the end you’ll have built just about every programming concept: numbers, booleans, you name it…just with functions.</p><p>Lambda演算是如此酷，以至于许多黑客将其用作秘密握手--如果你愿意的话，这是一个“谨慎的信号”。当然，最著名的是PG的Y组合器。在这篇文章中，我们将找出它的全部内容，并用我们从未想象过的功能来做一些事情。最后，您将构建几乎所有的编程概念：数字、布尔值，您可以将其命名为…。只需使用函数即可。</p><p>  City dwellers who drive SUVs rarely consider their cars as ferocious machines that traverse rocky deserts and flooded rivers. It’s the same with programmers and functions. Here’s what we  think functions do:</p><p>开SUV的城市居民很少认为他们的汽车是穿越多岩石的沙漠和洪水泛滥的河流的凶猛机器。程序员和函数也是如此。下面是我们认为函数的作用：</p><p>  Safe, clean, and useful. We’re so accustomed that it would surprise us to find the myriad of ways we can bend functions to do just about anything.</p><p>安全、干净、有用。我们已经习以为常了，如果我们发现我们可以用无数种方法来弯曲函数来做任何事情，那会让我们大吃一惊。</p><p> Let’s step out into the wilderness a bit. Say you wanted to make a data structure for pairs:</p><p>让我们到荒野里走一走吧。假设您想为Pair创建一个数据结构：</p><p>  How would you do it? It’s sensible to use a map or a class or a record to represent a pair. But…you could use functions too.</p><p>你会怎么做呢？使用地图、类或记录来表示一对是明智的。但是…。您也可以使用函数。</p><p>     Now our  ex-pair takes a  selector argument. What if we ran ex-pair with this selector:</p><p>现在我们的前搭档接受一个选择器参数。如果我们用这个选择器运行前任配对会怎么样：</p><p>     That just gave us the  first value of our pair! We can use that to write a  church-first function:</p><p>这正好给我们带来了我们这双鞋的第一个价值！我们可以用它来编写教堂优先函数：</p><p>      We just used functions to represent pairs. Now, since the grammar for Lisp is just a bunch of pairs plopped together, that also means we can represent the grammar of Lisp…with just functions!</p><p>我们只是用函数来表示对。现在，由于Lisp的语法只是一堆组合在一起的对，这也意味着我们可以表示Lisp…的语法。功能齐全！</p><p>  What we just did was analogous to a city dweller driving their SUV…on a snowy day. It gets a  lot crazier.</p><p>我们刚才所做的类似于一个城市居民驾驶他们的越野车…。在一个下雪的日子里。它变得更疯狂了。</p><p>  Here’s what can do. Let’s take a function we know and love, and implement it from top-to-bottom in Lambda Calculus.</p><p>这就是我们能做的。让我们取一个我们熟悉和喜爱的函数，并在Lambda演算中自上而下地实现它。</p><p>    By the end of this essay, we’ll have built factorial, only with functions.</p><p>在本文结束时，我们将只使用函数构建阶乘。</p><p>  To do this, I want to come up front and say I am cheating a little bit. In Church’s Lambda Calculus, there is no  def, and all functions take one argument. Here’s all he says:</p><p>为了做到这一点，我想走到前面说我有一点作弊。在丘奇的Lambda演算中，没有定义，所有函数都有一个参数。以下是他所说的：</p><p>  In his rules, you define anonymous functions by popping a little  λ in front. What follows is the argument, following by a  . .After the  . is the application.</p><p>在他的规则中，您通过在前面弹出一个小λ来定义匿名函数。下面是参数，后面跟着一个。.在..之后。是应用程序。</p><p> This is very much akin to a single-argument anonymous function in Clojure:  λ x. x =&gt;  (fn [x] x)</p><p>这非常类似于clojure中的单参数匿名函数：λx.x=&gt；(fn[x]x)。</p><p> We could follow those rules, but writing factorial like that is going to get hard to reason about very quickly. Let’s tweak the rules just a little bit. The changes won’t affect the essence of Lambda Calculus but will make it easier for us to think about our code. Here it goes:</p><p>我们可以遵循这些规则，但是像那样编写阶乘将很难很快得到推理。让我们稍微调整一下规则。这些更改不会影响Lambda演算的本质，但会使我们更容易考虑代码。它是这样的：</p><p>  1) for a single argument function,  (fn [x] x) maps pretty well to Church’s encoding. We can go ahead and use it as is.</p><p>1)对于单参数函数，(fn[x]x)很好地映射到Church的编码。我们可以继续按原样使用它。</p><p> 2) Since Church’s lambdas only take one argument, For him to express a function with two arguments, he has to write  two anonymous functions:</p><p>2)由于Church的lambdas只接受一个参数，要用两个参数表示一个函数，他必须编写两个匿名函数：</p><p>    But, nesting our functions like this can get annoying in Clojure  1. To make life easier for us, we’ll allow for multi-argument functions:</p><p>但是，在Clojure 1中，像这样嵌套我们的函数可能会很烦人。为了让我们的工作更轻松，我们将允许使用多参数函数：</p><p>  3) Finally, Church has no concepts of variables outside of what’s provided by a function definition.</p><p>3)最后，除了函数定义提供的变量之外，Church没有变量的概念。</p><p>     To keep our code sane, we’ll allow for  def, but with one rule:</p><p>为了使我们的代码保持正常，我们将允许def，但有一条规则：</p><p> You can use   def  , as long as you can “replace” it with an anonymous function and nothing breaks.</p><p>您可以使用def，只要您可以用匿名函数“替换”它并且没有中断。</p><p>   This would break because if we replaced  (def make-pair …) with an anonymous function, there would be no variable called  make-pair anymore!</p><p>这将中断，因为如果我们替换(定义Make-Pair…)。使用匿名函数，将不再有名为Make-Pair的变量！</p><p> That’s it, these are our rules. With that, we’re ready to make factorial!</p><p>就是这样，这是我们的规矩。有了这些，我们就可以做阶乘了！</p><p>  The first thing we need is the concept of a number. How can we do that?</p><p>我们首先需要的是数字的概念。我们怎么能做到这一点呢？</p><p> Church thought of a pretty cool idea. What if “numbers”, where higher-order functions with two arguments: a function  f, and a value  v.</p><p>丘奇想到了一个很酷的主意。如果是“Numbers”，其中高阶函数有两个参数：函数f和值v，情况会怎样呢？</p><p> ( def  zero ( fn  [f v] v)) ( def  one ( fn  [f v]  ( f  ( zero  f v)))) ( def  two ( fn  [f v]  ( f  ( one  f v))))</p><p>(def零(fn[f v]v))(def one(fn[f v](f(零f v)(def Two(fn[f v](f(One F V)。</p><p> We can figure out what number each function represents by “counting” the number of times   f  was composed.</p><p>我们可以通过“计数”f被合成的次数来计算出每个函数代表的数字。</p><p> For example, 0 would compose  f zero times: it would just return  v. 1, would compose f once:  (f v). 2 would compose twice:  (f (f v)), and so on.</p><p>例如，0将合成f的次数为零：它只返回v。1，将合成f一次：(Fv)。2将组成两次：(F(f，v))，依此类推。</p><p> To help us see these numbers in our REPL, let’s create a quick converter function:</p><p>为了帮助我们在REPL中查看这些数字，让我们创建一个快速转换器函数：</p><p>  Since a church numeral composes  f the number of times it is called with  v as the first argument, all we need to see what number it is in Clojure, is to provide  inc as  f and  0 as  v! Now  2 would do  (inc (inc 0)) for example, and get us the corresponding Clojure number.</p><p>因为教堂数字由它被调用的次数组成，其中v是第一个参数，所以我们需要知道它在Clojure中是什么数字，只需提供Inc作为f，提供0作为v！例如，现在2将做(Inc(Inc0))，并为我们获得相应的Clojure编号。</p><p>      What we did here, is  delegate f’s composition to the numeral before (in this case  one ), and then just called  f  one more time.</p><p>我们在这里做的是委托f组成前面的数字(在本例中是1)，然后再调用f一次。</p><p>   Voila. Give this function a numeral, and it will return a new numeral that calls  f  one more time. We’ve just discovered  inc!</p><p>瞧啊。给这个函数一个数字，它将返回一个新的数字，并再次调用f。我们刚刚发现了Inc.！</p><p>   Now that we have this function, we can also write a quick helper to translate Clojure numbers to these numbers:</p><p>现在我们有了这个函数，我们还可以编写一个快速帮助器将Clojure数字转换为这些数字：</p><p>     Next up, we need a way to “decrement” a number. Well, with  inc we create a numeral that composes  f  one more time. If we can make some kind of function that composes  f  one less time, then we’d have  dec!</p><p>接下来，我们需要一种方法来“递减”一个数字。嗯，使用Inc，我们再一次创建一个组成f的数字。如果我们能少做一次组成f的函数，那么我们就有了dec！</p><p>   Remember our  pair data structure? Let’s create a function for it (we’ll use this in just a moment below):  shift-and-inc. All it would do, is take pair of numbers, and “shift” the pair forward by one:</p><p>还记得我们的配对数据结构吗？让我们为它创建一个函数(我们稍后会用到这个函数)：Shift-and-Inc。它所要做的就是取一对数字，并将这对数字“前移”一位：</p><p> For example, applying  shift-and-inc to  (0 1), would produce  (1 2). One more time, it would produce  (2 3), and so on.</p><p>例如，对(0 1)应用Shift-and-Inc将生成(1 2)。再一次，它将产生(2 3)，依此类推。</p><p>   Bam, we take a pair. The second item is shifted over to the first positions and is replaced with its  inced friend. Let’s try it out:</p><p>班姆，我们拿一双。第二件物品被移到第一个位置，并被它的刻痕朋友取代。让我们试试看：</p><p> ( let  [p ( shift-and-inc  ( church-pair  one two))]  ( map  church-numeral-&gt;int [( church-first  p) ( church-second  p)])) ; =&gt; (2 3)</p><p>(设[p(Shift-and-Inc(教堂对一二))](映射教堂数字-&gt；int[(教堂第一个p)(教堂第二个p)]))；=&gt；(23)。</p><p>     Remember that our  church-numeral would call  shift-and-inc N times, representing its numeral value. If we started with a pair  (0, 0), then what would the result b, if we composed  shift-and-inc  N times?</p><p>请记住，我们的教堂数字将调用Shift-and-Inc N次，表示其数值。如果我们从一个对(0，0)开始，那么如果我们将Shift-and-Inc.组合N次，那么结果b会是什么呢？</p><p> Our result would be the pair  (N-1, N). This means that if we take the first part of our pair, we have  dec!</p><p>我们的结果将是对(N-1，N)。这意味着如果我们把我们对的第一部分取走，我们就有了12月！</p><p>    Next up, multiplication. Say we multiply  a by  b. We’d need to produce a church numeral that composes  f,  a * b times. To do that, we can leverage the following idea:</p><p>接下来是乘法。假设我们用a乘以b，我们需要产生一个教会数字，组成f，a*b次。要做到这一点，我们可以利用以下想法：</p><p> Say we made a function  g, which composes  f  b times. If we fed that function to  a, it would call  g,  a times.</p><p>假设我们做了一个函数g，它组成了f，b次。如果我们把这个函数提供给a，它会调用g，a次。</p><p>  If  a was “2” and “b” was 3, how many times would  f get composed? Well,  g would be composed twice. Each time  g is composed,  f is composed 3 times. That comes out to a total of 6 times!</p><p>如果a是“2”，“b”是3，f会合成几次？嗯，g会组成两次。每次合成g，就合成f 3次。一共出了6次！</p><p>       We’ve got numbers, we’ve got  * and we’ve got  dec. Next up…booleans!</p><p>我们有数字，我们有*，我们有12月。Next Up…。布尔人！</p><p>    They take a “true” case and a “false” case. Our  church-true function would return the true case, and  church-false function would return the false case.</p><p>他们接受一个“真”案和一个“假”案。我们的chorge-true函数将返回true case，而chocket-false函数将返回false case。</p><p> That’s it. Surprisingly this is enough to handle booleans. Here’s how we could convert them to Clojure bools.</p><p>就这样。令人惊讶的是，这足以处理布尔值。下面是我们如何将它们转换为Clojure bools。</p><p>  Our  church-true would return the first argument (true), and our  church-false would return the second one!</p><p>我们的教堂-true将返回第一个参数(True)，而我们的教堂-false将返回第二个参数！</p><p>  Do they look familiar? Those are our  selector functions for  church-first and  church-second! We could interchange them if we wished 😮</p><p>他们看起来眼熟吗？这就是我们教会第一和教会第二的选择器功能！如果我们愿意，我们可以互换它们，😮。</p><p>  If you are like me, you were a bit suspicious of those booleans. Let’s put them to use and quiet our fears. Here’s how could create an  if construct:</p><p>如果你和我一样，你对那些布尔人有点怀疑。让我们好好利用它们，平息我们的恐惧吧。下面是如何创建If结构的方法：</p><p>  All we do to make  if, is to simply shuffle things around and provide the  when-true and  when-false cases to our boolean!  church-true would return the  when-true case, and  church-false would return the  when-false case.</p><p>我们要做的所有事情就是简单地将事物打乱，并向我们的布尔值提供When-True和When-False的情况！Church-true将返回When-True大小写，而Church-False将返回When-False大小写。</p><p>    We have almost  all the constructs we need to implement  factorial. One missing piece:  zero?. We need a way to tell when a numeral is zero.</p><p>我们几乎拥有实现阶乘所需的所有构造。少了一块：零块？我们需要一种方法来判断数字何时为零。</p><p>     If a number is greater than zero,  f would be called, which would replace  v with  church-false. Otherwise, we’d return the initial value of  v,  church-true.</p><p>如果一个数字大于零，则会调用f，这会将v替换为chocket-false。否则，我们将返回v的初始值，教堂为真。</p><p>      Well, we have  numerals, we have  if, we have  zero? we have  *, we have  dec. We could translate this:</p><p>嗯，我们有数字，我们有如果，我们有零？我们有*，我们有12月。我们可以这样翻译：</p><p> ( def  factorial-v0  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-v0  ( church-dec  church-numeral-n))))))))</p><p>(def阶乘-V0(Fn[教会数字-n](教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(阶乘-v0(教堂-十二月教堂-数字-n)。</p><p>  The only weird thing is that we wrapped the  when-true and  when-false cases in an anonymous function. This is because our  church-if is a little different than Clojure’s  if. Clojure’s if  only evaluates one of the  when-true and  when-false cases. Ours evaluates both cases, which triggers an infinite recursion. We avoid this by wrapping both cases in a lambda, which “delays” the evaluation for us.  2</p><p>唯一奇怪的是，我们将WHEN-TRUE和WHEN-FALSE案例包装在一个匿名函数中。这是因为我们的教会IF与Clojure的IF略有不同。Clojure的IF只评估WHEN-TRUE和WHEN-FALSE案例中的一个。我们的方法对这两种情况都求值，这会触发无限递归。我们通过将两种情况都包装在一个lambda中来避免这一点，这会“延迟”我们的评估。2个</p><p>     Okay, almost. We cheated. Remember our  Rule 3:  If we replace our variables with an anonymous function, everything should work well. What would happen if we wrote  factorial-v0 as an anonymous function?</p><p>好的，差不多了。我们作弊了。记住我们的规则3：如果我们用匿名函数替换变量，一切都应该正常工作。如果我们将阶乘-V0编写为匿名函数，会发生什么情况？</p><p> ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n   ; :&lt; :&lt; :&lt; :&lt; uh oh  ( factorial-v0  ( church-dec  church-numeral-n)))))))</p><p>(fn[教堂-数字-n]((教堂-IF(教堂-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n；：&lt；：&lt；呃oh(factorial-v0(教堂-12月教堂-数字-n)。</p><p>  Here’s one way we can fix it. We could update this so  factorial is  provided as an argument to itself.</p><p>这里有一种我们可以解决的方法。我们可以更新这一点，这样阶乘就可以作为参数提供给它自己。</p><p> ( fn  [factorial-cb]  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-cb  ( church-dec  church-numeral-n)))))))  ????)</p><p>(Fn[阶乘-Cb](Fn[教会数字-n])((教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(factorial-cb(教堂-12月教堂-数字-n)？)。</p><p> That  would work, but we only punt the problem down. What the heck would  ???? be? We need some way to pass a reference of  factorial to  itself!</p><p>那是可行的，但我们只是把问题轻描淡写。他妈的会怎么做？是吗？我们需要某种方式将阶乘的引用传递给它本身！</p><p>  Let’s see if we can do make this work. First, let’s write our factorial, that accepts some kind of “injectable” version of itself:</p><p>让我们看看我们能不能把这件事办好。首先，让我们编写阶乘，它接受自身的某种“可注入”版本：</p><p> ( def  injectable-factorial  ( fn  [factorial-cb]  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-cb  ( church-dec  church-numeral-n)))))))))</p><p>(def可注射-阶乘(Fn[阶乘-Cb](Fn[教会数字-n])((教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(阶乘-cb(教堂-十二月教堂-数字-n)。</p><p>    Okay, all we did now is move the problem into this  make-recursable function 😅. Bear with me.</p><p>好的，我们现在所做的就是将问题转移到这个Make-Recursable函数😅中。请耐心听我说。</p><p> Let’s imagine what the solution would need to look like. We’d want to call  injectable-f with some  factorial-cb function handles the “next call”.</p><p>让我们想象一下解决方案需要看起来是什么样子。我们希望使用某个阶乘cb函数调用injectable-f来处理“下一次调用”。</p><p>  That seems right. Note the comment  recursion-handler . This is in reference to this form:</p><p>这似乎是对的。请注意注释递归处理程序。这是针对此表单的：</p><p>  If we somehow had access to this form, we can use that in  ????! Well, let’s punt the problem down again:</p><p>如果我们以某种方式访问此表单，我们可以在？！中使用它。好吧，让我们把这个问题再说一遍：</p><p>  Here, we wrap our  recursion-handler into a function. If it could get a copy of itself, we’d be golden. But that means we’re back to the same problem: how could we give  recursion-handler a copy of itself?  Here’s one idea:</p><p>在这里，我们将递归处理程序包装到一个函数中。如果它能自己复制一份，我们就大功告成了。但这意味着我们又回到了同样的问题上：我们如何才能给递归处理程序一个自身的副本呢？这里有一个想法：</p><p> ( def  make-recursable  ( fn  [injectable-f]  (( fn  [recursion-handler] ( recursion-handler  recursion-handler))  ( fn  [recursion-handler]  ( injectable-f  ( fn  [next-arg]  (( recursion-handler  recursion-handler) next-arg)))))))</p><p>(def make-recursable(fn[Injectable-f]((fn[递归处理程序](递归处理程序递归处理程序)(fn[递归处理程序](Injectable-f(Fn[Next-Arg]((递归处理程序递归处理程序)Next-Arg)。</p><p>                      This would end up producing a new  factorial function that had a  factorial-cb. Then we would call that with  next-arg, and keep the party going!</p><p>这将最终产生一个具有阶乘CB的新阶乘函数。然后我们就用Next-Arg来称呼它，让派对继续进行下去！</p><p>     This  make-recursable function is also called the Y Combinator. You may have heard a lot of stuff about it, and this example may be hard to follow. If you want to learn more, I recommend  Jim’s keynote.</p><p>这个Make-Recursable函数也称为Y组合器。你可能听说过很多关于它的事情，这个例子可能很难效仿。如果你想了解更多，我推荐吉姆的主题演讲。</p><p>  Wow, we did it. We just wrote  factorial, and  all we used were anonymous functions. To prove the point, let’s remove some of our rules. Here’s how our code would end up looking without any variable definitions:</p><p>哇，我们做到了。我们刚刚编写了阶乘，所有我们使用的都是匿名函数。为了证明这一点，让我们删除一些规则。下面是我们的代码在没有任何变量定义的情况下将如何结束：</p><p> ( church-numeral-&gt;int  ((( fn  [injectable-f]  (( fn  [recursion-handler] ( recursion-handler  recursion-handler))  ( fn  [recursion-handler] ( injectable-f  ( fn  [next-arg] (( recursion-handler  recursion-handler) next-arg))))))  ( fn  [factorial-cb]  ( fn  [church-numeral-n]  ((( fn  [church-bool  when-true   when-false ] ( church-bool   when-true   when-false ))  (( fn  [church-numeral]  ( church-numeral  ( fn  [v] ( fn  [ when-true   when-false ]  when-false )) ( fn  [ when-true   when-false ]  when-true )))  church-numeral-n)  ( fn  [] ( fn  [f v] ( f  (( fn  [f v] v) f v))))  ( fn  []  (( fn  [num-a num-b] ( fn  [f v] ( num-a  ( partial  num-b f) v)))  church-numeral-n  ( factorial-cb  (( fn  [church-numeral]  (( fn  [pair] ( pair  ( fn  [a b] a)))  ( church-numeral  ( fn  [pair]  (( fn  [a b] ( fn  [selector] ( selector  a b)))  (( fn  [pair] ( pair  ( fn  [a b] b))) pair)  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v)))) (( fn  [pair] ( pair  ( fn  [a b] b))) pair))))  (( fn  [a b] ( fn  [selector] ( selector  a b))) ( fn  [f v] v) ( fn  [f v] v)))))  church-numeral-n)))))))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v)))) ( fn  [f v] ( f  (( fn  [f v] ( f  (( fn  [f v] v) f v))) f v))))))))</p><p>(教堂-数字-&gt；Int(Fn[Injectable-f]((Fn[递归处理程序](递归处理程序递归处理程序)(Fn[递归处理程序](Injectable-f(Injectable-f(Fn[Next-Arg]((递归处理程序递归处理程序)Next-Arg)(Fn[阶乘-Cb](Fn[教堂数字-n](Fn[教堂布尔When-true When-False](教堂布尔When-True-False)。TRUE WHEN-FALSE))((FN[教堂编号](教堂编号(FN[v](Fn[WHEN-TRUE WHEN-FALSE]WHEN-FALSE]WHEN-FALSE))(FN[WHEN-TRUE WHEN-FALSE]WHEN-TRUE)教堂编号-n)(FN[](Fn[](Fn[f v](f((Fn[f v]v)f v)(Fn[]((Fn。[num-a num-b](fn[fv](num-a(部分num-bf)v))教堂数字-n(阶乘-cb((fn[教堂数字]((fn[a b]a)(教堂数字(fn[对](fn[b]a))((fn[b]((fn[a b](fn[选择器](选择器a b)(fn[对。](Pair(Fn[a b]b))Pair)((Fn[教堂数字](Fn[f v](f(教堂数字f v)((Fn[Pair](Pair(Fn[a b]b)((Fn[a b](Fn[选择器](选择器a b)(Fn[f]v)(fn[f]v)(fn[f]。V)教堂编号-n)((fn[教堂编号](fn[f v](f(教堂编号f v)((fn[教堂编号](fn[f v](f(教堂编号f v)((fn[教堂编号](fn[f v](f(教堂编号f v)(fn。[fv](f((fn[fv](f((fn[fv]v)fv)。</p><p>    Well, we just took our functions through the Mojave desert! We made numbers, booleans, arithmetic, and recursion…all from anonymous functions. I hope you had fun! If you’d like to see the code in full, take a look at the  GH repo.</p><p>我们刚刚把我们的任务带过了莫哈韦沙漠！我们制作了数字、布尔值、算术和递归…。全部来自匿名函数。希望你玩得开心！如果您想查看完整的代码，请查看GH回购。</p><p>  I’ll leave with you with some Clojure macro fun. When the time came to “replace” all our  defs with anonymous functions, how did we do it?</p><p>我将带着一些Clojure宏观乐趣离开。当用匿名函数“替换”所有Deff的时候，我们是如何做到的呢？</p><p> In wimpier languages we might have needed to do some manual copy pastin  3. In lisp, we can use  macros.</p><p>在较弱的语言中，我们可能需要手动复制粘贴3。在LISP中，我们可以使用宏。</p><p> First, let’s rewrite  def. This version will “store” the source code of every  def as metadata:</p><p>首先，让我们重写def。此版本将每个def的源代码“存储”为元数据：</p><p> ( defmacro  def#   &#34;A light wrapper around `def`, that keeps track of the  _source code_ for each definition  This let&#39;s us _unwrap_ all the definitions later : &gt;&#34;  [name v]  `( do  ( def  ~name ~v)  ( alter-meta!  ( var  ~name) assoc  :source  { :name  &#39;~name  :v  &#39;~v})  ( var  ~name)))</p><p>(def宏def#&#34；`def`周围的轻型包装，用于跟踪此let的每个定义的_source code_后面的us_unwork_all定义：&gt；&#34；[name v]`(do(def~name~v)(alt-meta！(var~name)assoc：source{：name&#39；~name：v&#39；~v})(var~name))。</p><p> Then, we can create an  unwrap function, that recursively replaces all  def symbols with with their corresponding source code:</p><p>然后，我们可以创建一个展开函数，该函数递归地将所有def符号替换为其对应的源代码：</p><p> ( defn  expand   &#34;This takes a form like  (church-numeral-&gt;int (factorial-yc (int-&gt;church-numeral 5)))  And expands all the function definitions, to give  us the intuition for how our &#39;lambda calculus&#39; way would look!&#34;  [form]  ( cond  ( symbol?  form)  ( if-let  [source ( some-&gt;  ( str  *ns*  &#34;/&#34;  form)  symbol  find-var  meta   :source )]  ( expand  ( :v  source))  form)  ( seq?  form)  ( map  expand form)   :else  form))</p><p>(Defn Expand&#34；this采用类似于(chorge-numeral-&gt；int(factorial-yc(int-&gt；chetch-numeral 5)的形式，并展开所有函数定义，让我们直观地看到我们的lambda演算方法会是什么样子！&#34；[form](cond(Symbol？Form)(if-let[source(ome-&&gt;；(str*ns*&34；/&#34；form)符号find-var meta：source)](展开(：v source))form)(序号？表单)(地图展开表单)：ELSE表单))</p><p>     Thanks to Alex Reichert, Daniel Woelfel, Sean Grove, Irakli Safareli, Alex Kotliarskyi, Davit Magaltadze, Joe Averbukh for reviewing drafts of this essay</p><p>感谢Alex Reichert，Daniel Woelfel，Sean Grove，Irakli Safareli，Alex Kotliarskyi，Davit Magaltadze，Joe Averbukh审阅本文草稿</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/263">https://stopa.io/post/263</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/微积分/">#微积分</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>