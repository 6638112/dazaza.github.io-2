<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>内容感知图像在JavaScript中调整大小 Content-aware image resizing in JavaScript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Content-aware image resizing in JavaScript<br/>内容感知图像在JavaScript中调整大小 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-17 07:09:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/041f11a5660a588d1276059791764ec5.jpg"><img src="http://img2.diglog.com/img/2021/4/041f11a5660a588d1276059791764ec5.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There are many great articles written about the  Seam Carving algorithm already, but I couldn&#39;t resist the temptation to explore this elegant, powerful, and  yet simple algorithm on my own, and to write about my personal experience with it. Another point that drew my attention (as a creator of  javascript-algorithms repo) was the fact that  Dynamic Programming (DP) approach might be smoothly applied to solve it. And, if you&#39;re like me and still on your &#34;learning algorithms&#34; journey, this algorithmic solution may enrich your personal DP arsenal.</p><p>已经有许多关于接缝雕刻算法的伟大文章，但我无法抵制探索这种优雅，强大，更简单的算法的诱惑，并用它写下我的个人经历。引起了我注意的另一个点（作为JavaScript-Algorithms Repo的创造者）是动态编程（DP）方法可能会顺利地应用于解决它。而且，如果你＆＃39;像我一样，仍然在你的＆＃34;学习算法＆＃34;旅程，这种算法解决方案可以丰富您的个人DP阿森纳。</p><p>  Provide you with an interactive  content-aware resizer so that you could play around with resizing your own images</p><p>  为您提供交互式内容感知的Resizer，以便您可以使用调整您自己的图像大小进行播放</p><p>  Explain the  dynamic programming approach to implement the algorithm (we&#39;ll be using TypeScript for it)</p><p>  解释实现算法的动态编程方法（我们＆＃39; ll使用typescript）</p><p>  Content-aware image resizing might be applied when it comes to changing the image proportions (i.e. reducing the width while keeping the height) and when losing some parts of the image is not desirable. Doing the straightforward image scaling in this case would distort the objects in it. To preserve the proportions of the objects while changing the image proportions we may use the  Seam Carving algorithm that was introduced by  Shai Avidan and  Ariel Shamir.</p><p>  在改变图像比例方面，可以应用内容感知图像调整大小（即减少保持高度的宽度），并且当丢失图像的某些部分时是不可取的。在这种情况下，在这种情况下执行直接的图像缩放将扭曲其中的对象。为了保持对象的比例，同时改变图像比例，我们可以使用Shai Avidan和Ariel Shamir引入的缝雕算法。</p><p> The example below shows how the original image width was reduced by 50% using  content-aware resizing (left image) and  straightforward scaling (right image). In this particular case, the left image looks more natural since the proportions of the balloons were preserved.</p><p> 下面的示例显示了使用内容感知调整大小（左图像）和直接缩放（右图像）如何将原始图像宽度降低了50％。在这种特殊情况下，由于保留了气球的比例，因此左图像看起来更自然。</p><p>  The Seam Carving algorithm&#39;s idea is to find the  seam (continuous sequence of pixels) with the lowest contribution to the image content and then  carve (remove) it. This process repeats over and over again until we get the required image width or height. In the example below you may see that the hot air balloon pixels contribute more to the content of the image than the sky pixels. Thus, the sky pixels are being removed first.</p><p>  接缝雕刻算法＆＃39;思路是找到对图像内容的最低贡献的接缝（连续的像素序列），然后雕刻（删除）它。此过程一遍又一遍地重复，直到我们获得所需的图像宽度或高度。在下面的示例中，您可能会发现热气囊像素比天空像素更多地贡献图像的内容。因此，首先被去除天空像素。</p><p>  Finding the seam with the lowest energy is a computationally expensive task (especially for large images). To make the seam search faster the  dynamic programming approach might be applied (we will go through the implementation details below).</p><p>  找到具有最低能量的接缝是计算昂贵的任务（特别是对于大图像）。为了更快地进行接缝搜索，可以应用动态编程方法（我们将通过下面的实施细节）。 </p><p>  The importance of each pixel (so-called pixel&#39;s energy) is being calculated based on its color ( R,  G,  B,  A) difference between two neighbor pixels. Now, if we set the pixel energy to some really low level artificially (i.e. by drawing a mask on top of them), the Seam Carving algorithm would perform an  object removal for us for free.</p><p>基于其两个相邻像素之间的差异来计算每个像素（所谓的像素和＃39; s能量）的重要性。现在，如果我们人为地将像素能量设置为一些真正的低电平（即通过在它们的顶部绘制掩模），接缝雕刻算法将免费为我们执行对象。</p><p>   I&#39;ve created the  JS IMAGE CARVER web-app (and also  open-sourced it on GitHub) that you may use to play around with resizing of your custom images. You may also try its embed version below right away! This widget uses the Seam Carving algorithm that we&#39;re going to explore in this article.</p><p>   我创建了JS Image Carver Web-App（并且还在Github上开放它），您可以用来调整自定义图像的大小。您也可以立即尝试下面的嵌入版本！此小部件使用We＆＃39;重新在本文中探索的缝雕算法。</p><p>       The same goes for the ocean waves. The algorithm preserved the wave structure without distorting the surfers.</p><p>       海浪也是如此。该算法保留了波结构而不会扭曲冲浪器。</p><p>  We need to keep in mind that the Seam Carving algorithm is not a silver bullet, and it may fail to resize the images where  most of the pixels are edges (look important to the algorithm). In this case, it starts distorting even the important parts of the image. In the example below the content-aware image resizing looks pretty similar to a straightforward scaling since for the algorithm all the pixels look important, and it is hard for it to distinguish Van Gogh&#39;s face from the background.</p><p>  我们需要注意的是，接缝雕刻算法不是银子弹，并且它可能无法调整大多数像素是边缘的图像大小（对算法很重要）。在这种情况下，它即使是图像的重要部分也开始扭曲。在下面的例子中，内容感知的图像调整大小看起来非常类似于直接缩放，因为对于算法，所有像素看起来都很重要，并且它很难区分梵高＆＃39;从背景中脸部脸部的脸。</p><p>   Imagine we have a  1000 x 500 px picture, and we want to change its size to  500 x 500 px to make it square (let&#39;s say the square ratio would better fit the Instagram feed). We might want to set up several  requirements to the resizing process in this case:</p><p>   想象一下我们有一个1000 x 500 px的图片，我们希望将其大小缩小到500 x 500 px，使其正方形（设＆＃39; s说方比率更好地拟合Instagram进料）。在这种情况下，我们可能希望为调整大小的过程设置多个要求：</p><p> Preserve the important parts of the image (i.e. if there were 5 trees before the resizing we want to have 5 trees after resizing as well).</p><p> 保留图像的重要部分（即，如果在调整之前有5棵树，我们也希望在调整大小后有5棵树）。</p><p> Preserve the proportions of the important parts of the image (i.e. circle car wheels should not be squeezed to the ellipse wheels)</p><p> 保留图像的重要部分的比例（即圆形车轮不应挤到椭圆轮） </p><p> To avoid changing the important parts of the image we may find the  continuous sequence of pixels (the seam), that goes from top to bottom and has  the lowest contribution to the content of the image (avoids important parts) and then remove it. The seam removal will shrink the image by 1 pixel. We will then repeat this step until the image will get the desired width.</p><p>为避免更改图像的重要部分，我们可以找到从上到下的像素（接缝）的连续序列，并且对图像内容具有最低贡献（避免重要的部件），然后将其移除。接缝移除将按1像素缩小图像。然后，我们将重复此步骤，直到图像达到所需的宽度。</p><p> The question is how to define  the importance of the pixel and its contribution to the content (in the original paper the authors are using the term  energy of the pixel). One of the ways to do it is to treat all the pixels that form the edges as important ones. In case if a pixel is a part of the edge its color would have a greater difference between the neighbors (left and right pixels) than the pixel that isn&#39;t a part of the edge.</p><p> 问题是如何定义像素的重要性及其对内容的贡献（在原始纸中，作者正在使用像素的术语能量）。这样做的一种方法是将形成边缘的所有像素视为重要的。如果像素是边缘的一部分，其颜色将在邻居（左和右像素）之间具有比ISN＆＃39; T的一部分的像素之间的更大差异。</p><p>  Assuming that the color of a pixel is represented by  4 numbers ( R - red,  G - green,  B - blue,  A - alpha) we may use the following formula to calculate the color difference (the pixel energy):</p><p>  假设像素的颜色由4个数字表示（R  - 红色，G  -  Green，B  - 蓝，A-alpha），我们可以使用以下公式来计算颜色差（像素能量）：</p><p>    In the formula above we&#39;re omitting the alpha (transparency) channel, for now, assuming that there are no transparent pixels in the image. Later we will use the alpha channel for masking and for object removal.</p><p>    在上面的公式中，我们省略了alpha（透明度）信道，假设图像中没有透明像素。后来我们将使用Alpha通道进行屏蔽和对象删除。</p><p>  Now, since we know how to find the energy of one pixel, we can calculate, so-called,  energy map which will contain the energies of each pixel of the image. On each resizing step the energy map should be re-calculated (at least partially, more about it below) and would have the same size as the image.</p><p>  现在，由于我们知道如何找到一个像素的能量，我们可以计算，所谓的能量图，其将包含图像的每个像素的能量。在每个调整步骤上，应重新计算能量图（至少部分地，下面的内容，并且可以具有与图像相同的大小。</p><p> For example, on the 1st resizing step we will have a  1000 x 500 image and a  1000 x 500 energy map. On the 2nd resizing step we will remove the seam from the image and re-calculate the energy map based on the new shrunk image. Thus, we will get a  999 x 500 image and a  999 x 500 energy map.</p><p> 例如，在第一步的第一步，我们将拥有1000 x 500图像和1000 x 500的能量图。在第二调整步骤中，我们将从图像中删除接缝，并根据新的缩小图像重新计算能量图。因此，我们将获得999 x 500图像和999 x 500的能量图。</p><p> The higher the energy of the pixel the more likely it is a part of an edge, and it is important for the image content and the less likely that we need to remove it.</p><p> 像素的能量越高，它的边缘的一部分越多，对于图像内容而言，我们需要删除它的可能性越小。 </p><p> To visualize the energy map we may assign a brighter color to the pixels with the higher energy and darker colors to the pixels with the lower energy. Here is an artificial example of how the random part of the energy map might look like. You may see the bright line which represents the edge and which we want to preserve during the resizing.</p><p>为了可视化能量图，我们可以将更亮色的颜色分配给具有较高能量的像素和较较较低能量的像素。这是一个人为的例子，了解能量图的随机部分的样子。您可能会看到表示边缘的明亮线，我们希望在调整大小期间保留。</p><p>  Here is a real example of the energy map for the demo image you saw above (with hot air balloons).</p><p>  这是您在上面看到的演示图像的能量图的真实例子（具有热气球）。</p><p>  The widget below renders the energy map during resizing. You may play around with your custom images and see how the energy map would look like.</p><p>  以下小部件在调整大小期间使能量贴图呈现。您可以使用您的自定义图像进行游戏，看看能量图如何看起来像。</p><p>   We may use the energy map to find the seams (one after another) with the lowest energy and by doing this to decide which pixels should be ultimately deleted.</p><p>   我们可以使用能量图以找到具有最低能量的接缝（一个接一个），并通过执行此操作以确定应最终删除哪些像素。</p><p>  Finding the seam with the lowest energy is not a trivial task and requires exploring many possible pixel combinations before making the decision. We will apply the dynamic programming approach to speed it up.</p><p>  找到具有最低能量的接缝不是琐碎的任务，并且需要在做出决定之前探索许多可能的像素组合。我们将应用动态编程方法来加速它。</p><p> In the example below, you may see the energy map with the first lowest energy seam that was found for it.</p><p> 在下面的示例中，您可能会看到能量贴图，其中最低能量接缝为它。</p><p>  In the examples above we were reducing the width of the image. A similar approach may be taken to reduce the image height. We need to &#34;rotate&#34; the approach though:</p><p>  在上面的示例中，我们正在降低图像的宽度。可以采取类似的方法来降低图像高度。我们需要＆＃34;旋转＆＃34;但方法： </p><p> start using  top and  bottom pixel neighbors (instead of  left and  right ones) to calculate the pixel energy</p><p>从顶部和底部像素邻居（而不是左右和右侧）开始计算像素能量</p><p> when searching for a seam we need to move from  left to  right (instead of from  up to  bottom)</p><p> 在搜索接缝时，我们需要从左到右移动（而不是从最多底部移动）</p><p>  You may find the source code, and the functions mentioned below in the  js-image-carver repository.</p><p>  您可以在JS-Image-Carver存储库中找到源代码和下面提到的函数。</p><p> To implement the algorithm we will be using TypeScript. If you want a JavaScript version, you may ignore (remove) type definitions and their usages.</p><p> 要实现我们将使用类型签名的算法。如果您想要JavaScript版本，您可以忽略（删除）类型定义及其用法。</p><p> For simplicity reasons let&#39;s implement the seam carving algorithm only for the image  width reduction.</p><p> 出于简单原因，Let＆＃39; s仅为图像宽度降低实现SEAM雕算法。</p><p>  First, let&#39;s define some common types that we&#39;re going to use while implementing the algorithm.</p><p>  首先，让＆＃39; s定义了我们＆＃39;重新实现算法的重新使用的一些常见类型。</p><p> // Type that describes the image size (width and height). type    =  { w :  number , h :  number  } ; // The coordinate of the pixel. type    =  { x :  number , y :  number  } ; // The seam is a sequence of pixels (coordinates). type    = Coordinate [ ] ; // Energy map is a 2D array that has the same width and height // as the image the map is being calculated for. type    =  number [ ] [ ] ; // Type that describes the image pixel&#39;s RGBA color. type    =  [ r :  number ,  // Red g :  number ,  // Green b :  number ,  // Blue a :  number ,  // Alpha (transparency) ]  | Uint8ClampedArray ;</p><p> //描述图像大小（宽度和高度）的类型。 type = {w：number，h：number}; //像素的坐标。 type = {x：number，y：number}; //接缝是一系列像素（坐标）。 type =坐标[]; // Energy映射是一个2D阵列，其具有相同的宽度和高度//作为图像的图像进行计算。 type = number [] []; //描述图像像素＆＃39; s rgba颜色的类型。 type = [r：number，//红色g：number，// green b：number，//蓝色a：number，// alpha（透明度）] | UINT8CLAMPEDARRAY; </p><p>  Find the  seam with the lowest energy based on the energy map (this is where we will apply Dynamic Programming).</p><p>根据能量图找到具有最低能量的接缝（这是我们将应用动态编程的地方）。</p><p> type    =  { img : ImageData ,  // Image data we want to resize. toWidth :  number ,  // Final image width we want the image to shrink to. } ; type    =  { img : ImageData ,  // Resized image data. size : ImageSize ,  // Resized image size (w x h). } ; // Performs the content-aware image width resizing using the seam carving method. export  const resizeImageWidth  =  (  { img , toWidth  } : ResizeImageWidthArgs , ) : ResizeImageWidthResult  =&gt;  {  // For performance reasons we want to avoid changing the img data array size.  // Instead we&#39;ll just keep the record of the resized image width and height separately.  const size : ImageSize  =  { w : img .width , h : img .height  } ;  // Calculating the number of pixels to remove.  const pxToRemove  = img .width  - toWidth ;  if  (pxToRemove  &lt;  0 )  {  throw  new   ( &#39;Upsizing is not supported for now&#39; ) ;  }  let energyMap : EnergyMap  |  null  =  null ;  let seam : Seam  |  null  =  null ;  // Removing the lowest energy seams one by one.  for  ( let i  =  0 ; i  &lt; pxToRemove ; i  +=  1 )  {  // 1. Calculate the energy map for the current version of the image. energyMap  =  calculateEnergyMap (img , size ) ;  // 2. Find the seam with the lowest energy based on the energy map. seam  =  findLowEnergySeam (energyMap , size ) ;  // 3. Delete the seam with the lowest energy seam from the image.  deleteSeam (img , seam , size ) ;  // Reduce the image width, and continue iterations. size .w  -=  1 ;  }  // Returning the resized image and its final size.  // The img is actually a reference to the ImageData, so technically  // the caller of the function already has this pointer. But let&#39;s  // still return it for better code readability.  return  { img , size  } ; } ;</p><p> type = {img：imagedata，//我们要调整的图像数据。 Towidth：数字，//最终图像宽度我们希望图像缩小到。 }; type = {img：imagedata，//调整大小的图像数据。尺寸：图像化，//调整大小的图像尺寸（W x H）。 }; //执行使用Seam雕刻方法调整大小调整的内容感知图像宽度。 Export Const ResizeImageWidth =（{IMG，Towidth}：ResizeImageWidthargs，）：ResizeImageWidthresult =＆gt; {//出于性能原因，我们要避免更改IMG数据阵列大小。 //我们＆＃39; ll只是单独保持调整大小的图像宽度和高度的记录。 const大小：keepize = {w：img .width，h：img .height}; //计算要删除的像素数。 const pxtoremove = img .width  -  towidth; if（pxtoremove＆lt; 0）{投掷新（＆＃39;现在不支持upsizing＆＃39;）; }让Energymap：Energymap | null = null;让缝：接缝| null = null; //逐一取下最低能量接缝。 for（让i = 0; i＆lt; pxtoremove; i + = 1）{// 1.计算当前版本的图像的能量图。 Energymap = CalculateNergymap（IMG，尺寸）; // 2.找到基于能量图的最低能量的接缝。 Seam = FindLowEnergyseam（Energymap，尺寸）; // 3.从图像中删除具有最低能量接缝的接缝。 DeletEseam（IMG，Seam，Size）; //减少图像宽度，然后继续迭代。尺寸.w  -  = 1; } //返回调整大小的图像及其最终大小。 // IMG实际上是对IMAGEDATA的引用，所以从技术上//函数的来电已经具有这个指针。但是，Let＆＃39; s //仍然返回它以获得更好的代码可读性。返回{img，size}; };</p><p> The image that needs to be resized is being passed to the function in  ImageData format. You may draw the image on the canvas and then extract the ImageData from the canvas like this:</p><p> 需要调整大小的图像被传递到IMAGEDATA格式的函数。您可以在画布上绘制图像，然后从图中提取ImageData：</p><p>  The way of uploading and drawing images in JavaScript is out of scope for this article, but you may find the complete source code of how it may be done using React in  js-image-carver repo.</p><p>  在JavaScript中上传和绘制图像的方式超出了本文的范围，但您可能会找到如何在JS-Image-Carver Repo中使用React完成的完整源代码。</p><p> Let&#39;s break down each step ony be one and implement the  calculateEnergyMap(),  findLowEnergySeam() and  deleteSeam() functions.</p><p> 让＆＃39; s分解每个步骤ony是一个并实现compulateNergymap（），findlowenergyseam（）和deleteseam（）函数。</p><p>  Here we apply the color difference formula described above. For the left and right borders (when there are no left or right neighbors), we ignore the neighbors and don&#39;t take them into account during the energy calculation.</p><p>  在这里，我们应用上述色差公式。对于左右边框（当没有左或右邻居时），我们忽略邻居和Don＆＃39;在能量计算期间考虑到它们。</p><p> // Calculates the energy of a pixel. const getPixelEnergy  =  (left : Color  |  null , middle : Color , right : Color  |  null ) :  number  =&gt;  {  // Middle pixel is the pixel we&#39;re calculating the energy for.  const  [mR , mG , mB ]  = middle ;  // Energy from the left pixel (if it exists).  let lEnergy  =  0 ;  if  (left )  {  const  [lR , lG , lB ]  = left ; lEnergy  =  (lR  - mR )  **  2  +  (lG  - mG )  **  2  +  (lB  - mB )  **  2 ;  }  // Energy from the right pixel (if it exists).  let rEnergy  =  0 ;  if  (right )  {  const  [rR , rG , rB ]  = right ; rEnergy  =  (rR  - mR )  **  2  +  (rG  - mG )  **  2  +  (rB  - mB )  **  2 ;  }  // Resulting pixel energy.  return Math . sqrt (lEnergy  + rEnergy ) ; } ;</p><p> //计算像素的能量。 const getpixelenergy =（左：颜色| null，中间：颜色，右：颜色| null）：number =＆gt; {//中间像素是我们＆＃39的像素;重新计算能量。常数[MR，MG，MB] =中间; //来自左像素的能量（如果存在）。让Lenergy = 0; if（左）{const [lr，lg，lb] =左; Lenergy =（LR  -  MR）** 2 +（LG-MG）** 2 +（LB  -  MB）** 2; } //来自右像素的能量（如果存在）。让肾脏= 0; if（右）{const [rr，rg，rb] =右; renergy =（rr  -  mr）** 2 +（rg  -  mg）** 2 +（rb  -  mb）** 2; } //导致像素能量。返回数学。 SQRT（Lenergy +肾脏）; }; </p><p>  The image we&#39;re working with has the  ImageData format. It means that all the pixels (and their colors) are stored in a flat ( 1D)  Uint8ClampedArray array. For readability purposes let&#39;s introduce the couple of helper functions that will allow us to work with the Uint8ClampedArray array as with a  2D matrix instead.</p><p>图片我们＆＃39;重新使用ImageData格式。这意味着所有像素（和它们的颜色）都存储在扁平（1D）Uint8ClampedArray阵列中。可用于可读性目的，Let＆＃39; s介绍了这对辅助函数的耦合，允许我们与UINT8ClampedArray数组相反，而不是2D矩阵。</p><p> // Helper function that returns the color of the pixel. const getPixel  =  (img : ImageData ,  { x , y  } : Coordinate ) : Color  =&gt;  {  // The ImageData data array is a flat 1D array.  // Thus we need to convert x and y coordinates to the linear index.  const i  = y  * img .width  + x ;  const cellsPerColor  =  4 ;  // RGBA  // For better efficiency, instead of creating a new sub-array we return  // a pointer to the part of the ImageData array.  return img .data . subarray (i  * cellsPerColor , i  * cellsPerColor  + cellsPerColor ) ; } ; // Helper function that sets the color of the pixel. const setPixel  =  (img : ImageData ,  { x , y  } : Coordinate , color : Color ) :  void  =&gt;  {  // The ImageData data array is a flat 1D array.  // Thus we need to convert x and y coordinates to the linear index.  const i  = y  * img .width  + x ;  const cellsPerColor  =  4 ;  // RGBA img .data . set (color , i  * cellsPerColor ) ; } ;</p><p> //返回像素颜色的帮助函数。 const getpixel =（img：imagedata，{x，y}：坐标）：color =＆gt; {// imageData数据数组是一个扁平的1D阵列。因此，我们需要将X和Y坐标转换为线性索引。 const i = y * img .width + x; const cellerpercolor = 4; // RGBA //为了更好的效率，而不是创建新的子阵列，我们返回到Imagedata数组一部分的指针。返回img .data。子阵列（i * cellerpercolor，i * cellerpercolor + cellercolor）; }; //设置像素颜色的辅助函数。 const setpixel =（img：imagedata，{x，y}：坐标，颜色：颜色）：void =＆gt; {// imageData数据数组是一个扁平的1D阵列。因此，我们需要将X和Y坐标转换为线性索引。 const i = y * img .width + x; const cellerpercolor = 4; // rgba img .data。设置（颜色，i * cellerpercolor）; };</p><p> To calculate the energy map we go through each image pixel and call the previously described  getPixelEnergy() function against it.</p><p> 为了计算能量映射，我们通过每个图像像素，并调用先前描述的getPixelenergy（）函数。</p><p> // Helper function that creates a matrix (2D array) of specific // size (w x h) and fills it with specified value. const matrix  =  &lt; T &gt; (w :  number , h :  number , filler :  T ) :  T [ ] [ ]  =&gt;  {  return  new   (h )  . fill ( null )  . map ( ( )  =&gt;  {  return  new   (w ) . fill (filler ) ;  } ) ; } ; // Calculates the energy of each pixel of the image. const calculateEnergyMap  =  (img : ImageData ,  { w , h  } : ImageSize ) : EnergyMap  =&gt;  {  // Create an empty energy map where each pixel has infinitely high energy.  // We will update the energy of each pixel.  const energyMap :  number [ ] [ ]  =   matrix  (w , h ,  Infinity ) ;  for  ( let y  =  0 ; y  &lt; h ; y  +=  1 )  {  for  ( let x  =  0 ; x  &lt; w ; x  +=  1 )  {  // Left pixel might not exist if we&#39;re on the very left edge of the image.  const left  =  (x  -  1 )  &gt;=  0  ?  getPixel (img ,  { x : x  -  1 , y  } )  :  null ;  // The color of the middle pixel that we&#39;re calculating the energy for.  const middle  =  getPixel (img ,  { x , y  } ) ;  // Right pixel might not exist if we&#39;re on the very right edge of the image.  const right  =  (x  +  1 )  &lt; w  ?  getPixel (img ,  { x : x  +  1 , y  } )  :  null ; energyMap [y ] [x ]  =  getPixelEnergy (left , middle , right ) ;  }  }  return energyMap ; } ;</p><p> //辅助函数创建特定//大小（w x h）的矩阵（2d阵列），并以指定的值填充它。常数矩阵=＆lt; T＆gt; （W：号码，H：号码，填充物：T）：T [] [] =＆gt; {返回新（h）。填充（null）。地图（（）=＆gt; {返回新（w）。填充（填充物）;}）; }; //计算图像的每个像素的能量。 Const CalculateNegyMap =（IMG：ImageData，{W，H}：图像化）：Energymap =＆gt; {//创建一个空的能量图，其中每个像素具有无限的能量。 //我们将更新每个像素的能量。 Const Energymap：Number [] [] =矩阵（W，H，Infinity）; for（让y = 0; y＆lt; h; y + = 1）{for（设定x = 0; x＆lt; x + = 1）{//左像素可能不存在，如果我们＆＃39;重新开始图像的左边缘。 const左=（x  -  1）＆gt; = 0？ getpixel（img，{x：x  -  1，y}）：null; //我们＆＃39;重新计算能量的中间像素的颜色。 const中间= getpixel（img，{x，y}）;如果我们＆＃39;重新在图像的非常右边，可能不存在//右像素。 const右=（x + 1）＆lt; W？ getpixel（img，{x：x + 1，y}）：null; Energymap [Y] [x] = getpixelenergy（左，中，右）; }}返回Energymap; };</p><p> The energy map is going to be recalculated on every resize iteration. It means that it will be recalculated, let&#39;s say, 500 times if we need to shrink the image by 500 pixels which is not optimal. To speed up the energy map calculation on the 2nd, 3rd, and further steps, we may re-calculate the energy only for those pixels that are placed around the seam that is going to be removed. For simplicity reasons this optimization is omitted here, but you may find the example source-code in  js-image-carver repo.</p><p> 每个调整大小迭代都将重新计算能量图。这意味着它将被重新计算，让＆＃39; s说，如果我们需要将图像缩小500像素，那么500次是不可最佳的。为了加速第二，第3，第3和进一步的步骤的能量图计算，我们可以仅为将要移除的接缝围绕的那些像素重新计算能量。为简单原因，此处省略了这种优化，但您可以在JS-Image-Carver Repo中找到示例源代码。</p><p>  I&#39;ve described some Dynamic Programming basics in  Dynamic Programming vs Divide-and-Conquer article before. There is a DP example based on the minimum edit distance problem. You might want to check it out to get some more context.</p><p>  我以前描述了一些动态编程VS划分和征服文章中的一些动态编程基础。基于最小编辑距离问题存在DP示例。您可能想查看它以获得更多上下文。</p><p> The issue we need to solve now is to find the path (the seam) on the energy map that goes from top to bottom and has the minimum sum of pixel energies.</p><p> 我们现在需要解决的问题是找到从上到下的能量图上的路径（接缝），并且具有最小的像素能量。 </p><p>    Going from top to bottom, for each pixel, we have 3 options (↙︎ go down-left, ↓ go down, ↘︎ go down-right). This gives us the time complexity of  O(w * 3^h) or simply  O(3^h), where  w and  h are the width and the height of the image. This approach looks slow.</p><p>从上到下，对于每个像素，我们有3个选项（↙︎向左转，↓下降，↘︎右向右）。这为我们提供了O（W * 3 ^ H）或简单o（3 ^ h）的时间复杂性，其中w和h是图像的宽度和高度。这种方法看起来很慢。</p><p>  We may also try to choose the next pixel as a pixel with the lowest energy, hoping that the resulting seam energy will be the smallest one.</p><p>  我们还可以尝试选择下一个像素作为具有最低能量的像素，希望得到的缝能量是最小的。</p><p>  This approach gives not the worst solution, but it cannot guarantee that we will find the best available solution. On the image above you may see how the greedy approach chose  5 instead of  10 at first and missed the chain of optimal pixels.</p><p>  这种方法不是最糟糕的解决方案，但不能保证我们会找到最好的解决方案。在上面的图像上，您可能会看到贪婪的方法是如何先选择5而不是10，而是错过了最佳像素链。</p><p> The good part about this approach is that it is fast, and it has a time complexity of  O(w + h), where  w and  h are the width and the height of the image. In this case, the cost of the speed is the low quality of resizing. We need to find a minimum value in the first row (traversing  w cells) and then we explore only 3 neighbor pixels for each row (traversing  h rows).</p><p> 关于这种方法的良好部分是它快速，并且它具有O（W + H）的时间复杂性，其中W和H是图像的宽度和高度。在这种情况下，速度的成本是调整大小的低质量。我们需要在第一行中找到最小值（遍历W单元），然后我们只探索每行的3个邻居像素（遍历H行）。</p><p>  You might have noticed that in the naive approach we summed up the same pixel energies over and over again while calculating the resulting seams&#39; energy.</p><p>  您可能已经注意到，在天真的方法中，我们在计算得到的接缝＆＃39时又一次地概括了相同的像素能量。活力。</p><p>  In the example above you see that for the first two seams we are re-using the energy of the shorter seam (which has the energy of  235). Instead of doing just one operation  235 + 70 to calculate the energy of the 2nd seam we&#39;re doing four operations  (5 + 0 + 80 + 150) + 70.</p><p>  在上面的示例中，您认为，对于前两个接缝，我们重新使用较短接缝的能量（其能量为235）。而不是做一个操作235 + 70以计算第二接缝的能量＆＃39;重新做四个操作（5 + 0 + 80 + 150）+ 70。</p><p> This fact that we&#39;re re-using the energy of the previous seam to calculate the current seam&#39;s energy might be applied recursively to all the shorter seams up to the very top 1st row seam. When we have such overlapping sub-problems,  it is a sign that the general problem  might be optimized by dynamic programming approach.</p><p> 这一事实是，我们＆＃39;重新使用先前接缝的能量来计算电流接缝和＃39; S能量可以递归地递归地施以较短的接缝，直到一排缝。当我们有这样的重叠子问题时，它是一个符号，即一般问题可能通过动态编程方法优化。 </p><p> So, we may  save the energy of the current seam at the particular pixel in an additional  seamsEnergies table to make it re-usable for calculating the next seams faster (the  seamsEnergies table will have the same size as the energy map and the image itself).</p><p>因此，我们可以将当前接缝的能量节省在额外的接缝台中的特定像素中，以使其可重新使用，以便更快地计算下一个接缝（Seamsenergies表将具有与能量图和图像本身相同的大小） 。</p><p> Let&#39;s also keep in mind that for one particular pixel on the image (i.e. the bottom left one) we may have  several values of the previous seams energies.</p><p> 我们还要记住，对于图像上的一个特定像素（即左下一），我们可能有几个先前接缝能量的若干值。</p><p>  Since we&#39;re looking for a seam with the lowest resulting energy it would make sense to pick the previous seam with the lowest resulting energy as well.</p><p>  自从我们＆＃39;重新寻找具有最低结果能量的接缝，摘到最低的接缝也是最低的能量的有意义。</p><p>     The cell  [1][x]: contains the lowest possible energy of the seam that starts somewhere on the row  [0][?] and ends up at cell  [1][x]</p><p>     单元格[1] [x]：包含在行[0] [0] [0]的某处开始的接缝的最低能量，并于细胞[1] [x]。</p><p> The current cell  [2][3]: contains the lowest possible energy of the seam that starts somewhere on the row  [0][?] and ends up at cell  [2][3]. To calculate it we need to sum up the energy of the current pixel  [2][3] (from the energy map) with the  min(seam_energy_1_2, seam_energy_1_3, seam_energy_1_4)</p><p> 当前的单元[2] [3]：包含在行[0] [0] [0]的某处开始的接缝的最低能量，并最终在细胞[2] [3]。要计算它，我们需要总结当前像素[2] [3]的能量[2] [3]（从能量图），min（Seam_energy_1_2，Seam_energy_1_3，Seam_energy_1_4）</p><p> If we fill the  seamsEnergies table completely, then the minimum number in the lowest row would be the lowest possible seam energy.</p><p> 如果我们完全填充了Seamsenergies表，那么最低排中的最小数字将是尽可能低的缝能量。</p><p>   After filling out the  seamsEnergies table we may see that the lowest energy pixel has an energy of  50. For convenience, during the  seamsEnergies generation for each pixel, we may save not only the energy of the seam but also the coordinates of the previous lowest energy seam. This will give us the possibility to reconstruct the seam path from the bottom to the top easily.</p><p>   在填写后角接缝表后，我们可能会看到最低能量像素具有50的能量。为方便起见，在每个像素的Seamsenergies生成期间，我们可能不仅可以节省接缝的能量，而且还可以节省前一能量的坐标接缝。这将使我们能够容易地重建从底部到顶部的接缝路径。 </p><p> The time complexity of DP approach would be  O(w * h), where  w and  h are the width and the height of the image. We need to calculate energies for  every pixel of the image.</p><p>DP方法的时间复杂度将是O（W * H），其中W和H是图像的宽度和高度。我们需要计算图像的每个像素的能量。</p><p>  // The metadata for the pixels in the seam. type    =  { energy :  number ,  // The energy of the pixel. coordinate : Coordinate ,  // The coordinate of the pixel. previous : Coordinate  |  null ,  // The previous pixel in a seam. } ; // Finds the seam (the sequence of pixels from top to bottom) that has the // lowest resulting energy using the Dynamic Programming approach. const findLowEnergySeam  =  (energyMap : EnergyMap ,  { w , h  } : ImageSize ) : Seam  =&gt;  {  // The 2D array of the size of w and h, where each pixel contains the  // seam metadata (pixel energy, pixel coordinate and previous pixel from  // the lowest energy seam at this point).  const seamsEnergies :  (SeamPixelMeta  |  null ) [ ] [ ]  =   matrix  (w , h ,  null ) ;  // Populate the first row of the map by just copying the energies  // from the energy map.  for  ( let x  =  0 ; x  &lt; w ; x  +=  1 )  {  const y  =  0 ; seamsEnergies [y ] [x ]  =  { energy : energyMap </p><p>  //接缝中像素的元数据。 type = {Energy：Number，//像素的能量。坐标：坐标，//像素的坐标。上一篇：坐标| null，//接缝中的先前像素。 }; //使用动态编程方法查找具有//最低结果的接缝（从上到下的像素序列）。 const findlowenergyseam =（Energymap：Energymap，{W，H}：图像化）：Seam =＆gt; {//大小的W和H大小的数组，其中每个像素包含//缝元（像素能量，像素坐标和从//此时的最低能量接缝）。 Const Seamsenergies :( Seampixelmeta | Null）[] [] =矩阵（W，H，NULL）; //只需从能量映射复制能量//来填充地图的第一行。 for（设法x = 0; x＆lt; w; x + = 1）{const y = 0; Seamsenergies [Y] [x] = {Energy：Energymap</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/">https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/感知/">#感知</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aware/">#aware</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>