<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一名前ARM工程师批评RISC-V</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">一名前ARM工程师批评RISC-V</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 19:59:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2020/11/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This document was originally written several years ago. At the time I was working as an execution core verification engineer at Arm. The following points are coloured heavily by working in and around the execution cores of various processors. Apply a pinch of salt; points contain varying degrees of opinion.</p><p>这份文件最初是几年前写的。当时我在ARM担任执行核心验证工程师。通过在不同处理器的执行核心内和周围工作，以下几点被涂上了浓墨重彩的色彩。加一小撮盐；观点包含不同程度的意见。</p><p> It is still my opinion that RISC-V could be much better designed; though I will also say that if I was building a 32 or 64-bit CPU today I&#39;d likely implement the architecture to benefit from the existing tooling.</p><p>我仍然认为RISC-V可以设计得更好；尽管我也会说，如果我现在正在构建一个32位或64位的CPU，我很可能会实现该体系结构以受益于现有的工具。</p><p> Mostly based upon the RISC-V ISA spec v2.0. Some updates have been made for v2.2</p><p>主要基于RISC-V ISA规范v2.0。对v2.2进行了一些更新。</p><p>  The RISC-V ISA has pursued minimalism to a fault. There is a large emphasis on minimizing instruction count, normalizing encoding, etc. This pursuit of minimalism has resulted in false orthogonalities (such as reusing the same instruction for branches, calls and returns) and a requirement for superfluous instructions which impacts code density both in terms of size and number of instructions.</p><p>RISC-V ISA追求极简主义到了极致。对最小化指令计数、标准化编码等有很大的重视。这种对最小化的追求导致了错误的正交性(例如对分支、调用和返回重复使用相同的指令)，并且需要多余的指令，这在指令的大小和数量方面都会影响代码密度。</p><p>   This is a simple case of array indexing, a very common operation. Consider the compilation of this for x86_64:</p><p>这是一个简单的数组索引示例，这是一个非常常见的操作。请考虑x86_64的编译方式：</p><p>     # apologies for any syntax nits - there aren&#39;t any online risc-v# compilersslli a1, a1, 2add a0, a1, a1lw a0, a0, 0jalr r0, r1, 0 // return</p><p>#对任何语法错误表示歉意-没有任何在线RISC-v#编译器slli a1，a1，2添加a0，a1，a1lw a0，a0，0jalr r0，r1，0//return。</p><p> RISC-V&#39;s simplifications make the decoder (i.e. CPU frontend) easier, at the expense of executing more instructions. However, scaling the width of a pipeline is a hard problem, while the decoding of slightly (or highly) irregular instructions is well understood (the primary difficulty arises when determining the length of an instruction is nontrivial - x86 is a particularly bad case of this with its&#39; numerous prefixes).</p><p>RISC-V&V；的简化使解码器(即CPU前端)更容易，但代价是执行更多指令。然而，缩放流水线的宽度是一个难题，而对轻微(或高度)不规则指令的解码是很容易理解的(当确定指令的长度不是平凡的时候，主要的困难就出现了-x86在这种情况下尤其糟糕，因为它的前缀很多)。</p><p> The simplification of an instruction set should not be pursued to its&#39; limits. A register + shifted register memory operation is not a complicated instruction; it is a very common operation in programs, and very easy for a CPU to implement performantly. If a CPU is not capable of implementing the instruction directly, it can break it down into its&#39; constituent operations with relative ease; this is a much easier problem than fusing sequences of simple operations.</p><p>指令集的简化不应该追求到极限。寄存器+移位寄存器内存操作不是一条复杂的指令，它是程序中非常常见的操作，CPU很容易执行。如果CPU不能直接执行指令，它可以相对容易地将其分解为组成操作；这比融合简单操作序列要容易得多。</p><p> We should distinguish the &#34;Complex&#34; instructions of CISC CPUs - complicated, rarely used, and universally low performance, from the &#34;Featureful&#34; instructions common to both CISC and RISC CPUs, which combine a small sequence of operations, are commonly used, and high performance.</p><p>我们应该区分CISC CPU的复杂指令-复杂、很少使用和普遍低性能，与CISC和RISC CPU通用的功能丰富的指令(结合了较小的操作序列)是常用的，并且性能很高。</p><p>  Highly unconstrained extensibility. While this is a goal of RISC-V, it is also a recipe for a fragmented, incompatible ecosystem and will have to be managed with extreme care.</p><p>高度不受约束的可扩展性。虽然这是RISC-V的一个目标，但它也是一个支离破碎、不兼容的生态系统的配方，必须极其谨慎地管理。</p><p> Same instruction ( JALR) used for both calls, returns and register-indirect branches (requires extra decode for branch prediction)</p><p>用于调用、返回和寄存器间接分支的相同指令(JALR)(需要额外解码才能进行分支预测)。</p><p> Variable length encoding not self synchronizing (This is common - e.g x86 and Thumb-2 both have this issue - but it causes various problems both with implementation and security e.g. return-oriented-programming attacks)</p><p>可变长度编码不是自同步的(这很常见--例如x86和Thumb-2都有这个问题--但是它会在实现和安全性方面造成各种问题，例如面向返回的编程攻击)。</p><p> RV64I requires sign extension of all 32-bit values. This produces unnecessary top-half toggling or requires special accomodation of the upper half of registers. Zero extension is preferable (as it reduces toggling, and can generally be optimized by tracking an &#34;is zero&#34; bit once the upper half is known to be zero)</p><p>RV64I需要所有32位值的符号扩展。这会产生不必要的上半部分切换或需要寄存器上半部分的特殊调节。最好是零扩展(因为它减少了切换，并且一旦上半部分已知为零，通常可以通过跟踪为零的位来优化)。</p><p> Multiply is optional - while fast multipliers occupy non-negligible area on tiny implementations, small multipliers can be created which consume little area, and it is possible to make extensive re-use of the existing ALU for a multiple-cycle multiplications.</p><p>乘法是可选的-虽然快速乘法器在微型实现中占用不可忽略的面积，但可以创建占用面积很小的小乘法器，并且可以广泛重用现有的ALU进行多周期乘法。</p><p> LR/ SC has a strict eventual forward progress requirement for a limited subset of uses. While this constraint is quite tight, it does potentially pose some problems for small implementations (particularly those without cache)</p><p>LR/SC对有限的使用子集有严格的最终前进进度要求。虽然此约束相当严格，但对于小型实现(特别是那些没有缓存的实现)，它确实可能会带来一些问题。</p><p> FP sticky bits and rounding mode are in the same register. This requires serialization of the FP pipe if a RMW operation is performed to change rounding mode</p><p>FP粘滞位和舍入模式在同一寄存器中。如果执行RMW操作来更改舍入模式，这需要对FP管道进行序列化</p><p> FP Instructions are encoded for 32, 64 and 128-bit precision, but not 16-bit (which is significantly more common in hardware than 128-bit) Update: V2.2 has a  decimal FP extension placeholder, but no half-precision placeholder. The mind kinda boggles.</p><p>FP指令编码为32、64和128位精度，但不是16位(这在硬件中比128位要常见得多)更新：V2.2具有十进制FP扩展占位符，但没有半精度占位符。我的头脑有点不对劲。</p><p> How FP values are represented in the FP register file is unspecified but observable (by load/store)</p><p>FP值在FP寄存器文件中的表示方式未指定，但可以观察到(通过加载/存储)。</p><p>  No condition codes, instead compare-and-branch instructions. This is not problematic by itself, but rather in its&#39; implications: Decreased encoding space in conditional branches due to requirement to encode one or two register specifiers</p><p>没有条件代码，而是比较和分支指令。这本身并不是问题，而是它的含义：由于需要编码一个或两个寄存器说明符，减少了条件分支中的编码空间。</p><p>   (Note that this is still better than ISAs which write flags to a GPR and then branch upon the resulting flags)</p><p>(请注意，这仍然比ISA更好，后者将标志写入GPR，然后根据生成的标志进行分支)。</p><p> Highly precise counters seem to be  required by the user level ISA. In practice, exposing these to applications is a great vector for sidechannel attacks</p><p>用户级ISA似乎需要高精度计数器。在实践中，将这些应用程序暴露给应用程序是侧通道攻击的一个很好的载体。</p><p> Multiply and divide are part of the same extension, and it appears that if one is implemented the other must be also. Multiply is significantly simpler than divide, and common on most CPUs even where divide is not</p><p>乘法和除法是同一扩展的一部分，似乎如果一个实现了，另一个也必须实现。乘法比除法简单得多，在大多数CPU上都很常见，即使在除法不是这样的情况下也是如此。</p><p> No atomic instructions in the base ISA. Multi-core microcontrollers are increasingly common, and LL/SC type atomics inexpensive (only 1 bit of CPU state required for minimal single CPU implementations).</p><p>基本ISA中没有原子指令。多核微控制器越来越普遍，LL/SC型原子芯片价格低廉(最小的单CPU实现只需要1位CPU状态)。</p><p> LR/ SC are in the same extension as more complicated atomic instructions, which limits implementation flexibility for small implementations</p><p>LR/SC与更复杂的原子指令在同一扩展中，这限制了小型实现的实现灵活性</p><p> General (non  LR/ SC) atomics do not include a  CAS primitive The motivation is to avoid the need for an instruction which reads 5 registers ( Addr,  CmpHi:CmpLo,  SwapHi:SwapLo), but this is likely to impose less overhead on the implementation than the guaranteed-forward-progress LR/SC which is provided to replace it</p><p>通用(非LR/SC)原子不包括CAS原语动机是为了避免需要读取5个寄存器(addr、CmpHi：CmpLo、SwapHi：SwapLo)的指令，但这对实现造成的开销可能比为替换它而提供的有保证的转发进度LR/SC要少。</p><p> Atomic instructions are provided which operate on 32-bit and 64-bit quantities, but not 8 or 16-bit</p><p>提供了对32位和64位数量进行操作的原子指令，而不是对8位或16位数量进行操作的原子指令。</p><p> For RV32I, no way to tranfer a DP FP value between the integer and FP register files except through memory</p><p>对于RV32I，除非通过内存，否则无法在整数和FP寄存器堆之间传输DP FP值。</p><p> e.g. RV32I 32-bit  ADD and RV64I 64-bit  ADD share encodings, and RVI64 adds a different  ADD.W encoding. This is needless complication for a CPU which implements both instructions - it would have been preferable to add a new 64-bit encoding instead</p><p>例如，RV32I 32位添加和RV64I 64位添加共享编码，而RVI64添加了不同的ADD.W编码。对于同时实现这两条指令的CPU来说，这是不必要的复杂性-最好改为添加新的64位编码。</p><p> No  MOV instruction. The  MV assembler alias is implemted as  MV rD, rS -&gt;  ADDI rD, rS, 0.  MOV optimization is commonly performed by high-end processors (especially out-of-order); recognizing RISC-V&#39;s canonical  MV requires oring a 12-bit immediate Absent a  MOV instruction,  ADD rD, rS, r0 would actually be a preferable canonical  MOV as it is easier to decode and CPUs normally have special case logic for recognizing the zero register</p><p>无MOV说明。MV汇编器别名实现为MV RD，RS-&gt；Addi RD，RS，0。MOV优化通常由高端处理器执行(尤其是无序的)；识别RISC-V的规范MV需要在没有MOV指令的情况下或12位立即数，加上RD、RS、R0实际上是较佳的规范MOV，因为它更容易解码，并且CPU通常具有识别零寄存器的特殊情况逻辑。</p><p>  JAL wastes 5 bits encoding the link register, which will always be  R1 (or  R0 for branches) This means that RV32I has 21-bit branch displacements (insufficient for large applications - e.g. web browsers - without using multiple instruction sequences and/or branch islands)</p><p>JAL浪费5位对链接寄存器进行编码，它将始终为R1(或分支为R0)。这意味着RV32I具有21位的分支位移(不足以用于大型应用程序-例如Web浏览器-无需使用多个指令序列和/或分支孤岛)。</p><p> Despite great effort being expended on a uniform encoding, load/store instructions are encoded differently (register vs immediate fields swapped) It seems orthogonality of destination register encoding was preferred over orthogonality of encoding two highly related instructions. This choice seems a little odd given that address generation is the more timing critical operation.</p><p>尽管在统一编码上花费了大量精力，但加载/存储指令的编码方式不同(寄存器与立即字段交换)似乎首选目标寄存器编码的正交性，而不是编码两条高度相关指令的正交性。考虑到地址生成是计时更为关键的操作，这种选择似乎有点奇怪。</p><p>  FENCE.I implies full synchronization of instruction cache with all preceding stores, fenced or unfenced. Implementations will need to either flush entire I$ on fence, or snoop both D$ and the store buffer</p><p>FENCEI.表示指令缓存与所有前面的存储完全同步，无论是栅栏存储还是非栅栏存储。实现将需要刷新围栏上的整个I$，或者同时监听D$和存储缓冲区</p><p> In RV32I, reading the 64-bit counters requires reading upper half twice, comparing and branching in case a carry occurs between the lower and upper half during a read operation Normally 32-bit ISAs include a &#34;read pair of special registers&#34; instruction to avoid this issue</p><p>在RV32I中，读取64位计数器需要读取上半部分两次，比较和分支以防在读取操作期间在上半部分和下半部分之间发生进位。通常32位ISA包括一对特殊寄存器的读取指令，以避免此问题。</p><p> No architecturally defined &#34;hint&#34; encoding space. Hint encodings are those which execute as  NOPs on current processors but which have some behavior on later varients More complicated hints have also been implemented (i.e. those which have visible side effects on new processors; for example, the x86 bounds checking instructions are encoded in hint space so that binaries remain backwards compatible)</p><p>没有架构定义的提示编码空间。提示编码是那些在当前处理器上作为NOP执行，但在以后的变体上有一些行为的编码。还实现了更复杂的提示(即，那些对新处理器有明显副作用的提示；例如，x86边界检查指令在提示空间中编码，以便二进制保持向后兼容)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/erincandescent/8a10eeeea1918ee4f9d9982f7618ef68">https://gist.github.com/erincandescent/8a10eeeea1918ee4f9d9982f7618ef68</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/工程师/">#工程师</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/engineer/">#engineer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032098.html"><img src="http://img2.diglog.com/img/2020/10/thumb_61bd89dc48ced04ced994b6b48ed2f21.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032098.html">印度的工程师在硅谷茁壮成长。它的种姓制度也是如此</a></div><span class="my_story_list_date">2020-10-30 2:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031657.html"><img src="http://img2.diglog.com/img/2020/10/thumb_61bd89dc48ced04ced994b6b48ed2f21.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031657.html">印度的工程师在硅谷茁壮成长。它的种姓制度也是如此</a></div><span class="my_story_list_date">2020-10-28 7:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030730.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ab0eebe8c93685dada553b31efbfae20.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030730.html">软件工程师逆向工程麦当劳订购API以查找损坏的冰激凌机器的位置</a></div><span class="my_story_list_date">2020-10-23 12:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030141.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3cc6dea0ee3103731d11095eabacbe05.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030141.html">我做过工程师和招募员。招聘被打破了。原因如下</a></div><span class="my_story_list_date">2020-10-21 2:41</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>