<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Elixir是安全的 Elixir Is Safe</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Elixir Is Safe<br/>Elixir是安全的 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-10 03:28:41</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/f0072567e3982f89fc15e6b7878971c3.jpg"><img src="http://img2.diglog.com/img/2021/4/f0072567e3982f89fc15e6b7878971c3.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Some languages are risky.Take C for example.You can write very fast code in C.You can also write very serious bugs.</p><p>有些语言是风险的。例如，您可以在C中编写非常快的代码。您还可以编写非常严重的错误。</p><p> In 2019,  a Microsoft security engineer said that over the previous 12 years, about 70 percent of Microsoft’s security patches were fixes for memory safety bugs resulting from mistakes in C or C++ code.</p><p> 2019年，Microsoft Security Engineer表示，在过去的12年中，大约70％的Microsoft的安全补丁是用于C或C ++代码中的错误导致的内存安全错误的修复。</p><p> In open source, the infamous  Heartbleed bug, disclosed in 2014, allowed an attacker to read whatever happened to be in a server’s memory, which is about as bad as it gets.</p><p> 在开源中，2014年披露的臭臭虫错误允许攻击者阅读发生在服务器内存中的任何事情，这与它获得的那么糟糕。</p><p>  Mistakes of the type that caused Heartbleed have led to security problems since the 1970s. OpenSSL is written in a programming language called C, which also dates from the early 1970s. C is renowned for its speed and flexibility, but the trade-off is that it places all responsibility on programmers to avoid making precisely this kind of mistake.</p><p>  自20世纪70年代以来，造成令人情调的类型的错误导致了安全问题。 openssl是用一个名为C的编程语言编写的，该语言也从20世纪70年代初期出发。 C以其速度和灵活性而闻名，但权衡是它对程序员来说，避免恰好这种错误。</p><p> I want to stay as far as possible from bugs like that.So I’ve always used programming languages which manage memory for me.Since Elixir uses garbage collection (“GC”), it checks that box.</p><p> 我想尽可能地留出那样的错误。所以我始终使用编程语言，用于为ME管理内存.SINCE ELIXIR使用垃圾收集（“GC”），检查该框。</p><p> But here’s the thing:  what all GC languages do for memory safety, Elixir also does for safe concurrency.</p><p> 但这是事情：所有GC语言都为内存安全做了什么，Elixir也适用于安全并发。</p><p>  Thread safety is hard.A recent post on the GitHub blog,  How we found and fixed a rare race condition in our session handling, is a good illustration.</p><p>  线程安全性很难。在GitHub博客上最近的帖子，我们如何在会话处理中找到并修复了稀有种族条件，是一个很好的插图。 </p><p>  In summary, if an exception occurred at just the right time and if concurrent request processing happened in just the right sequence across multiple requests, we ended up replacing the session in one response with a session from an earlier response… This bug required very specific conditions: a background thread, shared exception context between the main thread and the background thread, callbacks in the exception context, reusing the  env object between requests, and our particular authentication system.</p><p>总之，如果仅在正确的时间内发生异常，并且如果在多个请求中只是正确的序列发生并发请求处理，则在较早响应的响应中以一个响应替换会话...此错误需要非常具体的条件：后台线程，主线程与后台线程之间的共享异常上下文，异常上下文中的回调，重用请求之间的env对象以及我们的特定身份验证系统。</p><p> So this was a rare but very serious bug,  created by one of the highest-profile development teams in the world, in which User A would accidentally be authenticated as User B.</p><p> 因此，这是一个罕见但非常严重的虫子，由世界上最高型的开发团队创造，其中用户A会因用户B而不小心被认证。</p><p>  Taking a step back, a bug such as this is not only challenging from a technical perspective in how to identify complex interactions between multiple threads, deferred callbacks, and object sharing, but it is also a test of an organization’s ability to respond to a problem with an ambiguous cause and risk. A well-developed product security incident response team and process combined with a collaborative team of subject matter experts across our support, security, and engineering teams enabled us to quickly triage, validate, and assess the potential risk of this issue and drive prioritization across the company. This prioritization accelerated our efforts in log analysis, review of recent changes across our code and infrastructure, and ultimately the identification of the underlying issues that led to the bug.</p><p>  返回退步，这是一个错误，如这种错误，这不仅是如何从如何识别多个线程，延迟回调和对象共享之间复杂的交互的技术角度来挑战，但它也是组织响应问题的能力的测试具有含糊不清的因果和风险。一项发达的产品安全事件响应团队和流程与我们的支持，安全和工程团队的主题专家的协作团队相结合，使我们能够快速分类，验证和评估本问题的潜在风险，并推动整个问题公司。此优先级排序加速了我们在日志分析中的努力，审查我们代码和基础设施的最新变化，并最终确定导致错误的潜在问题。</p><p> Does your organization have the tools and expertise required to fix a bug like this?</p><p> 您的组织是否具有修复这样的错误所需的工具和专业知识？</p><p>     Shared mutable state is a common source of bugs, which makes multi-threading risky in languages like Ruby.</p><p>     共享变形状态是一个常见的错误来源，这使得粗糙的语言具有多线程风险。</p><p> But if you’re running Ruby at GitHub’s scale, you have to make some trade offs for the sake of performance. This may be why the GitHub team is not abandoning threads but working “to make our code more robust for various threading contexts.”</p><p> 但是，如果您在Github的规模上运行Ruby，则必须为了性能进行一些折磨。这可能是为什么GitHub团队没有放弃线程，而是工作“，使我们的代码对各种线程上下文更加强大。”</p><p>   In  Elixir, we don’t use threads directly. Like garbage collection, thread management is the runtime’s responsibility.</p><p>   在Elixir中，我们不会直接使用线程。像垃圾收集一样，线程管理是运行时的责任。 </p><p> Instead, we use a special kind of lightweight process, provided by the Erlang runtime.Creating one is easy, as a tiny experiment will show.</p><p>相反，我们使用特殊的轻量级过程，由Erlang Runtime提供。创建一个很容易，因为一个微小的实验将显示。</p><p>    Item 3 is the killer one for safety.Like two people,  two processes cannot share memory; they can only communicate by sending each other messages.</p><p>    第3项是安全的杀手。有两个人，两个进程不能分享内存;他们只能通过发送互相邮件进行沟通。</p><p> And whether we spawn them directly or not, Elixir developers use processes all the time.</p><p> 无论我们是直接生成它们，Elixir开发人员是否一直使用流程。</p><p> When we use  Phoenix, every web request or web socket connection is a process.Every test we run with  ExUnit is a process.Every  background task, every  supervisor, every  file handle or  logger is a process.</p><p> 当我们使用Phoenix时，每个Web请求或Web套接字连接都是一个过程。每次测试都使用exunit运行是一个过程。每次背景任务，每个主管，每个文件句柄或记录器都是一个过程。</p><p> In Elixir, you’ll never have to wonder if your server library is leaking state across threads of execution.It isn’t.It can’t.</p><p> 在Elixir中，您永远不会想知道您的服务器库是否在执行线程中泄漏状态.it不是。不能。</p><p> And although it’s not impossible to write a concurrency bug in Elixir, you’re much less likely to do it.</p><p> 虽然在Elixir中编写并发臭体并非不可能，但你就不太可能这样做。</p><p>  I came from a background of doing massively parallel distributed systems, but all written in Python, and I was constantly worrying about race conditions.“Oh, what if I check this variable, but then something else comes and messes with it before I’m going to add a number to it?”When I finally internalized the guarantees of how processes work [in Elixir]… it made parallel programming so much easier, so much faster, so much simpler.</p><p>  我来自做大规模并行分布式系统的背景，但都写在Python，我一直在担心种族条件。“哦，如果我检查这个变量怎么办，但在我之前，那么别的东西会和它混淆要将一个数字添加到它？“当我终于内化了过程如何工作[在Elixir]的情况下...它使得并行编程如此简单，如此更快，更简单。 </p><p>  The concept of processes which don’t share memory and communicate only with messages has come to be known as the “Actor Model.”It has been implemented in many languages.But unlike bolted-on implementations, Elixir’s runtime guarantees that this contract is honored; one “actor” simply cannot mess with the memory of another.</p><p>不共享内存并仅与消息通信的过程的概念已被称为“演员模型”。它已经以许多语言实现。但与螺栓的实现不同，Elixir的运行时保证本合同荣获;一个“演员”根本无法弄乱另一个人的内存。</p><p> Also, remember garbage collection?Truly isolated processes make that better, too.When a process terminates, the runtime knows that nothing else is using its memory, so the GC algorithm is “everything goes.”Simple and fast.</p><p> 此外，记住垃圾收集？真正孤立的流程也使得更好。当一个进程终止时，运行时知道什么都没有别的东西使用它的内存，因此GC算法是“一切顺利。”</p><p> That covers most cases, since most processes are short-lived.For long-lived processes, GC is performed concurrently, one tiny heap at a time.So there’s never a  “stop the world” pause, where every thread of execution has to be paused while the garbage collector runs.</p><p> 涵盖大多数情况，因为大多数流程都是短暂的。对于长期的进程，GC同时执行，一堆一次。所以从来没有一个“停止世界”暂停，在那里每个执行的线程都不是垃圾收集器运行时暂停。</p><p>   Are you looking for a language where you can build something quickly?A language where, if you succeed, scaling up will be simple?</p><p>   您是否正在寻找一种可以快速构建的语言？一种语言，如果你成功，缩放将很简单？</p><p>   DockYard is a digital product agency offering custom software, mobile, and web application development consulting. We provide exceptional professional services in strategy, user experience, design, and full stack engineering using Ember.js, React.js, Elixir, Ruby, and other technologies. With staff nationwide, we’ve got consultants in key markets across the U.S., including Portland, San Francisco, Los Angeles, Salt Lake City, Minneapolis, Dallas, Miami, Washington D.C., and Boston.</p><p>   Dockyard是一个数字产品代理商，提供自定义软件，手机和Web应用程序开发咨询。我们在使用Ember.js，React.js，Elixir，Ruby等技术提供策略，用户体验，设计和完整堆栈工程中提供特殊的专业服务。与全国人员一起，我们在美国的主要市场顾问，包括波特兰，旧金山，洛杉矶，盐湖城，明尼阿波利斯，达拉斯，迈阿密，华盛顿州和波士顿。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://dockyard.com/blog/2021/03/30/elixir-is-safe">https://dockyard.com/blog/2021/03/30/elixir-is-safe</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>