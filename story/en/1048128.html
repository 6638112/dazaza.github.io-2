<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>QWaitCondition：解决不可避免的比赛（2014） QWaitCondition: Solving the Unavoidable Race (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">QWaitCondition: Solving the Unavoidable Race (2014)<br/>QWaitCondition：解决不可避免的比赛（2014） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-18 05:31:27</div><div class="page_narrow text-break page_content"><p>This is the story how I have (not) solved a race condition that impacts QWaitCondition and is also present on every other condition variable implementations (pthread, boost, std::condition_variable).</p><p>这是我如何（没有）解决影响QWaitCondition的竞争条件的故事，并且在所有其他条件变量实现（pthread，boost，std :: condition_variable）上也存在。</p><p> bool QWaitCondition::wait(int timeout) is supposed to return true if the condition variable was met and false if it timed out. The race is that it may return false (for timeout) even if it was actually woken up.</p><p> 如果满足条件变量，则bool QWaitCondition :: wait（int timeout）应该返回true，如果超时则返回false。比赛是即使它实际上被唤醒了，它也可能返回false（超时）。</p><p> The problem was  already reported in 2012. But I only came to look at it when David Faure was trying to fix  another bug in QThreadPool that was caused by this race.</p><p> 该问题已经在2012年报告过。但是，我只是在David Faure试图修复由该比赛引起的QThreadPool中的另一个错误时才开始研究它。</p><p>   QMutexLocker  locker (&amp; mutex); taskQueue. append( task);  // Place the task on the task queue if ( waitingThreads &gt;  0) {  // there are already running idle thread. They are waiting on the &#39;runnableReady&#39;   // QWaitCondition. Wake one up them up.  waitingThreads--;  runnableReady. wakeOne();}  else  if ( runningThreadCount &lt;  maxThreadCount) {  startNewThread( task);}</p><p>   QMutexLocker储物柜（＆amp;互斥锁）; taskQueue。 append（任务）; //（（waitingThreads＆gt; 0）{//已经有正在运行的空闲线程。他们正在等待＆＃39; runnableReady＆＃39; // QWaitCondition。叫醒他们一个。等待线程-; runnableReady。 awawOne（）;}否则if（runningThreadCount＆maxThreadCount）{startNewThread（task）;}</p><p>  void  QThreadPoolThread:: run(){  QMutexLocker  locker (&amp; manager-&gt; mutex);  while ( true) {  /* ... */  if ( manager-&gt; taskQueue. isEmpty()) {  // no pending task, wait for one.  bool  expired = ! manager-&gt; runnableReady. wait( locker. mutex(),  manager-&gt; expiryTimeout);  if ( expired) {  manager-&gt; runningThreadCount--;  return; }  else {  continue; } }  QRunnable * r =  manager-&gt; taskQueue. takeFirst();  // run the task  locker. unlock();  r-&gt; run();  locker. relock(); }}</p><p>  无效的QThreadPoolThread :: run（）{QMutexLocker更衣室（＆amp; manager-＆gt;互斥锁）; while（true）{/ * ... * / if（manager-＆gt; taskQueue。isEmpty（））{//没有待处理的任务，请等待一个。布尔已过期=！经理-＆gt; runnableReady。等待（更衣室。互斥（），管理器-> expiryTimeout）;如果（已过期）{manager-＆gt; runningThreadCount--;返回; }其他{继续； } QRunnable * r = manager-＆gt; taskQueue。 takeFirst（）; //运行任务柜。开锁（）; -跑（）;储物柜。 relock（）; }}</p><p> The idea is that the thread will wait for a given amount of second for a task, but if no task was added in a given amount of time, the thread expires and is terminated.The problem here is that we rely on the return value of  runnableReady. If there is a task that is scheduled at exactly the same time as the thread expires, then the thread will see false and will expire. But the main thread will not restart any other thread. That might let the application hang as the task will never be run.</p><p> 这个想法是线程将等待一个任务给定的秒数，但是如果在给定的时间内没有添加任何任务，则该线程将到期并终止。这里的问题是我们依赖于的返回值runnableReady。如果有一个任务计划在线程到期的同时进行，则该线程将看到false并将到期。但是主线程不会重新启动任何其他线程。这将使应用程序挂起，因为该任务将永远不会运行。</p><p>  Many of the implementations of a condition variable have the same issue. It is even documented in the  POSIX documentation:</p><p>  条件变量的许多实现都有相同的问题。它甚至记录在POSIX文档中： </p><p> [W]hen pthread_cond_timedwait() returns with the timeout error, the associated predicate may be true due to an unavoidable race between the expiration of the timeout and the predicate state change.</p><p>[W]当pthread_cond_timedwait（）返回超时错误时，由于超时到期和谓词状态更改之间不可避免的竞争，关联的谓词可能为true。</p><p> pthread documentation describes it as an unavoidable race. But is it so?The wait condition is associated with a mutex, which is locked by the user when calling  wake() and that is also passed locked to  wait(). The implementation is supposed to unlock and wait atomically.</p><p> pthread文档将其描述为不可避免的竞争。等待条件与互斥量相关联，该互斥量在调用wake（）时由用户锁定，并且也传递给了wait（）锁定状态。该实现应该解锁并自动进行等待。</p><p> The C++11 standard library&#39;s   condition_variable even has an enum (  cv_status) for the return code. The C++ standard does not document the race, but all the implementations I have tried suffer from the race. (No implementations are therefore conform.)</p><p> C ++ 11标准库的condition_variable甚至具有用于返回代码的枚举（cv_status）。 C ++标准没有记录比赛，但是我尝试过的所有实现都遭受了比赛的困扰。 （因此，没有实现符合要求。）</p><p> Let me try to explain the race better: this code show a typical use of QWaitCondition</p><p> 让我尝试更好地解释比赛：此代码显示了QWaitCondition的典型用法</p><p>  The race is that the wait condition in Thread2 timeout and returns false, but at the same time, Thread1 wakes the condition.One could expect that since everything is protected by a mutex, this should not happen. Internally, the wait conditionunlocks the internal mutex, but does not check that it has not been woken up once the user mutex is locked again.</p><p>  竞争是线程2中的等待条件超时并返回false，但与此同时，线程1唤醒了该条件。可以预料，由于所有内容均受互斥锁保护，因此不应发生这种情况。在内部，等待条件会解锁内部互斥锁，但不会在用户互斥锁再次锁定后检查是否尚未唤醒它。</p><p> QWaitCondition has internal state that counts the number of waiting QWaitCondition and the number of QWaitCondition that are waiting to be woken up. Let&#39;s review the actual code of QWaitCondition (edited for readability)</p><p> QWaitCondition具有内部状态，该状态对等待的QWaitCondition数量和等待被唤醒的QWaitCondition数量进行计数。让我们回顾一下QWaitCondition的实际代码（为便于阅读而进行了编辑）</p><p> bool  QWaitCondition:: wait( QMutex * mutex,  unsigned  long  ){  // [...]  pthread_mutex_lock(&amp; d-&gt; mutex); ++ d-&gt; waiters;  mutex-&gt; unlock();  // (simplified for briefty)  int  code =  0;  do {  code =  d-&gt; wait_relative( time);  // calls pthread_cond_timedwait }  while ( code ==  0 &amp;&amp;  d-&gt; wakeups ==  0); -- d-&gt; waiters;  if ( code ==  0) -- d-&gt; wakeups;  // [!!]  pthread_mutex_unlock(&amp; d-&gt; mutex);  mutex-&gt; lock();  return  code ==  0;} void  QWaitCondition:: wakeOne(){  pthread_mutex_lock(&amp; d-&gt; mutex);  d-&gt; wakeups =  qMin( d-&gt; wakeups +  1,  d-&gt; waiters);  pthread_cond_signal(&amp; d-&gt; cond);  pthread_mutex_unlock(&amp; d-&gt; mutex);}</p><p> bool QWaitCondition :: wait（QMutex * Mutex，unsigned long）{// [...] pthread_mutex_lock（＆amp; d-＆gt;互斥锁）; ++ d-＆gt;服务员;互斥锁->开锁（）; //（为简明起见）int code = 0;做{code = d-＆gt; wait_relative（时间）; //调用pthread_cond_timedwait}，同时（code == 0＆amp; d-＆gt;唤醒== 0）; -d-＆gt;服务员; if（code == 0）-d->唤醒； // [!!] pthread_mutex_unlock（＆amp; d-＆gt;互斥锁）;互斥锁->锁（）;返回代码== 0;} void QWaitCondition :: awakOne（）{pthread_mutex_lock（＆amp; d-＆gt;互斥体）; d-唤醒次数= qMin（d->唤醒次数+ 1，d->服务员）; pthread_cond_signal（＆amp; d-＆gt; cond）; pthread_mutex_unlock（＆amp; d-＆gt;互斥锁）;} </p><p> Notice that  d-&gt;mutex is a native pthread mutex, while the local variable  mutex is the user mutex.In the line marked with [!!] we effectively take the right to wake up.But we do that before locking the user&#39;s mutex. What if we checked again for waiters under the user&#39;s lock?</p><p>请注意，d-> mutex是本机pthread互斥量，而局部变量互斥量是用户互斥量。在标有[!!]的行中，我们有效地拥有唤醒权限，但是我们在锁定用户之前执行了此操作39; s互斥。如果我们再次检查用户锁下的服务员该怎么办？</p><p>  bool  QWaitCondition::  wait( QMutex * mutex,  unsigned  long  ){ // Same as before:  pthread_mutex_lock(&amp; d-&gt; mutex); ++ d-&gt; waiters;  mutex-&gt; unlock();  int  code =  0;  do {  code =  d-&gt; wait_relative( time);  // calls pthread_cond_timedwait }  while ( code ==  0 &amp;&amp;  d-&gt; wakeups ==  0); // --d-&gt;waiters; // Moved bellow  if ( code ==  0) -- d-&gt; wakeups;  pthread_mutex_unlock(&amp; d-&gt; mutex);  mutex-&gt; lock(); // Now check the wakeups again:  pthread_mutex_lock(&amp; d-&gt; mutex); -- d-&gt; waiters;  if ( code !=  0 &amp;&amp;  d-&gt; wakeups) {  // The race is detected, and corrected -- d-&gt; wakeups;  code =  0; }  pthread_mutex_unlock(&amp; d-&gt; mutex);  return  code ==  0;}</p><p>  bool QWaitCondition :: wait（QMutex * Mutex，unsigned long）{//与以前相同：pthread_mutex_lock（＆amp; d-＆gt; Mutex）; ++ d-＆gt;服务员;互斥锁->开锁（）;整数代码= 0;做{code = d-＆gt; wait_relative（时间）; //调用pthread_cond_timedwait}，同时（code == 0＆amp; d-＆gt;唤醒== 0）; // --d-＆gt;侍者; //如果（code == 0）-d-＆gt;唤醒； pthread_mutex_unlock（＆amp; d-＆gt;互斥锁）;互斥锁->锁（）; //现在再次检查唤醒：pthread_mutex_lock（＆amp; d-＆gt;互斥锁）; -d-＆gt;服务员; if（code！= 0＆amp; d-＆gt;唤醒）{//检测并纠正了种族-d-＆gt;唤醒；代码= 0; } pthread_mutex_unlock（＆amp; d-＆gt;互斥锁）;返回代码== 0;}</p><p> And there we have fixed the race! We just had to lock the internal mutex again because  d-&gt;waiters and  d-&gt;wakeups need to be protected by it. We needed to unlock it because locking the user&#39;s mutex with the internal mutex locked would potentially cause deadlock as lock order would not be respected.</p><p> 至此，我们已经解决了比赛！我们只需要再次锁定内部互斥锁，因为d-> waiters和d-> wakeups需要受到它的保护。我们需要解锁它，因为在锁定内部互斥锁的情况下锁定用户的互斥锁可能会导致死锁，因为不遵守锁定顺序。</p><p> However, we now have introduced another problem: If there are three threads, a thread may be woken up before</p><p> 但是，我们现在引入了另一个问题：如果有三个线程，则可能在一个线程被唤醒之前</p><p> // Thread 1 // Thread 2 // Thread 3mutex-&gt;lock()cond-&gt;wait(mutex); mutex-&gt;lock() cond-&gt;wake(); mutex-&gt;unlock() mutex-&gt;lock() cond-&gt;wait(mutex, 0);</p><p> //线程1 //线程2 //线程3mutex-＆gt; lock（）cond-＆gt; wait（mutex）;互斥锁-> lock（）cond-> wake（）;互斥锁-> unlock（）互斥锁-> lock（）cond-> wait（mutex，0）;</p><p> We don&#39;t want that the Thread 3 steal the signal from the Thread 1. But that can happen if the Thread 1 is sleeping a bit too long and do not manage to lock the internal mutex in time before Thread 3 expires.</p><p> 我们不希望线程3窃取线程1的信号。但是，如果线程1的睡眠时间太长并且在线程3到期之前没有设法及时锁定内部互斥锁，则可能会发生这种情况。</p><p> The only way to solve this problem would be if we could order the thread by the time they started to wait. Inspired by the bitcoin&#39;s blockchain, I created a linked list of nodes on the thread&#39;s stack that represent the order. When a thread is starting to wait, it adds itself at the end of the double linked list. When a thread is waking other thread, it marks the last node of the linked list. (by incrementing a  woken counter inside the node).When a thread is timing out, it checks if it was marked, or any other thread after him in the linked list. We only solve the race in that case, otherwise we consider it is a timeout.</p><p> 解决此问题的唯一方法是，如果我们可以在线程开始等待之前对其进行排序。受比特币区块链的启发，我在线程堆栈上创建了代表顺序的节点的链表。当线程开始等待时，它将自己添加到双链表的末尾。当一个线程唤醒其他线程时，它标记了链表的最后一个节点。 （通过增加节点内的唤醒计数器）。当线程超时时，它将检查该线程是否已被标记，或在链接列表中是否在该线程之后被标记。我们只在那种情况下解决比赛，否则我们认为这是超时。 </p><p>   This patch adds quite a bit of code to add and remove nodes in the linked list, and also to go over the list to check if we were indeed woken up. The linked list is bound by the number of waiting thread. I was expecting that this linked list handling would be negligible compared to the other cost of QWaitCondition</p><p>该补丁添加了很多代码，以添加和删除链表中的节点，并遍历该列表以检查我们是否确实被唤醒。链表由等待线程数限制。我期望与QWaitCondition的其他费用相比，此链表处理可以忽略不计</p><p> However, the results of the QWaitCondition benchmark show that, with 10 threads and high contention, we have a ~10% penalty.With 5 threads there is ~5% penalty.</p><p> 但是，QWaitCondition基准测试的结果表明，在10个线程和高竞争的情况下，我们要付出约10％的代价，在5个线程中要付出约5％的代价。</p><p> Is it worth it to pay this penalty to solve the race? So far, we decided not to merge the patch and keep the race.</p><p> 付出这笔罚款来解决比赛是否值得？到目前为止，我们决定不合并补丁并继续比赛。</p><p>  Fixing the race is possible, but has a small performance impact. None of the implementations attempt to fix the race. I wonder why there is even a returned status at all if you cannot rely on it.</p><p>  可以解决比赛，但是对性能的影响很小。这些实现均未尝试解决竞赛。我想知道如果您不能依靠它，为什么甚至根本没有返回状态。</p><p>  Woboq is a  software company that specializes in development and consulting around  Qt and C++.  Hire us!</p><p>  Woboq是一家软件公司，专门从事Qt和C ++的开发和咨询。雇用我们！</p><p>  If you like this blog and want to read similar articles, consider subscribing  via our RSS feed (Via Google Feedburner,  Privacy Policy), by e-mail (Via Google Feedburner,  Privacy Policy)or  follow us on twitteror  add us on G+.</p><p>  如果您喜欢此博客并希望阅读类似的文章，请考虑通过我们的RSS feed（通过Google Feedburner，隐私权政策）订阅，通过电子邮件订阅（通过Google Feedburner，隐私权政策），或者在twitter上关注我们，或者在G +上添加我们。</p><p>      Load Comments...   Loading comments embeds an external widget from disqus.com.  Check   disqus privacy policy for more information.</p><p>      加载评论...加载评论会嵌入来自disqus.com的外部小部件。查看Disqus隐私权政策以获取更多信息。 </p><p>   Get notified when we post a new interesting article!     Click to subscribe via RSS or e-mail on Google Feedburner. (external service).     Click for the privacy policy of Google Feedburner.</p><p>当我们发布新的有趣文章时，您将获得通知！ 单击以通过RSS或电子邮件在Google Feedburner上进行订阅。 （外部服务）。 单击以查看Google Feedburner的隐私权政策。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://woboq.com/blog/qwaitcondition-solving-unavoidable-race.html">https://woboq.com/blog/qwaitcondition-solving-unavoidable-race.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/解决/">#解决</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/solving/">#solving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>