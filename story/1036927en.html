<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>潜在的崇拜The Cult of Posits</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Cult of Posits<br/>潜在的崇拜</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-28 05:52:19</div><div class="page_narrow text-break page_content"><p>Computers are incapable of representing arbitrary real numbers exactly.This is due to two intractable facts of real numbers:</p><p>计算机无法精确地表示任意实数，这是由于以下两个难以理解的实数事实：</p><p>  Since computers use a finite number of bits, computer architects must settle on capturing a finite number of real numbers at a finite level of precision.This is done by fixing a mapping between bit patterns and real numbers called a  representation.A representation makes a tradeoff between the quantity of representable numbers and the level of precision.</p><p>  由于计算机使用有限数量的位，因此计算机架构师必须致力于以有限的精度捕获有限数量的实数，这是通过固定位模式与实数之间的映射（称为表示）来实现的。在可表示数字的数量和精度水平之间。</p><p>  The  floating point representation is the most widely used.Numbers are written in the form: $$(-1^s) * 1.m * 2^e$$</p><p>  浮点表示法是使用最广泛的表示形式，数字形式为$$（-1 ^ s）* 1.m * 2 ^ e $$</p><p>  The design tradeoff between quantity and precision is captured by the number of bits dedicated to the mantissa and exponent.</p><p>  数量和精度之间的设计折衷通过尾数和指数专用的位数来捕获。</p><p> In practice, however, the IEEE 754 floating point standard slightly modifies this scheme to account for two perceived limitations:</p><p> 但是，实际上，IEEE 754浮点标准对此方案进行了少许修改，以解决两个可感知的限制：</p><p> Small Number Gap: there is a relatively large gap between the representation of the largest negative number, and the smallest positive number. To account for this, the numbers with the smallest exponent are  denormalized. Denormalized values are spread out linearly, rather than exponentially.For floating points, denormalization occurs between the largest negative and smallest positive numbers raised to the second largest exponent.</p><p> Small Number Gap：最大负数和最小正数之间存在较大的差距。为了解决这个问题，指数最小的数字将被归一化。归一化的值线性分布，而不是呈指数分布。对于浮点数，归一化发生在最大负数和最小正数之间，升至第二大指数。</p><p>   Bogus Results: the result of overflow (e.g., dividing by a very small number) or partial functions applied to elements outside of their domains (e.g, division by zero) have no representation. The case of overflow is captured by the  positive and negative infinity values, each represented by the bit pattern corresponding to an all ones exponent and all zeros mantissa, and differentiated by the sign bit.</p><p>   虚假结果：溢出结果（例如，除以很小的数字）或应用于其域外元素的部分函数的结果（例如，除以零）没有结果。溢出的情况由正无穷大和负无穷大捕获，每个无穷大由对应于全1指数和全零尾数的位模式表示，并通过符号位进行微分。</p><p> The case of a non-result of a partial function is captured by the  NaN value (meaning, &#34;not a number&#34;), represented by the various bit patterns with an all ones exponent and non-zero mantissa.</p><p>部分结果不成立的情况由NaN值（即“非数字”）捕获，该值由具有全指数和非零尾数的各种位模式表示。</p><p>   The  posit representation  should be the most widely used representation.The numbers represented by posits are similar to floating points, but differ by the introduction of a so-called  regime term, as follows:</p><p>   posit表示应该是使用最广泛的表示。posits表示的数字类似于浮点，但由于引入了所谓的制度术语而有所不同，如下所示：</p><p>    The regime bits may seem like a weird and artificial construct, but they actually arise from a natural and elegant geometric mapping of binary integers to the projective real numbers on a circle.</p><p>    规范位可能看起来像是一种怪异的人工构造，但实际上它们来自二进制整数到圆上的投影实数的自然而优雅的几何映射。</p><p>      At the heavenly North of the circle, symbolizing the Alpha and Omega, Our Father to which we solemly pray, lies the glorious positive and negative infinity.At its opposite, the wicked, immoral South of the circle, lies nothing of value, the value $0$.Meanwhile, on the earthly plane, God&#39;s children enjoy free will, where they choose between positive one at the East and negative one at the West.</p><p>      在圆圆的北部，象征着我们的父神阿尔法和欧米茄，我们庄严地祈祷着它，光荣的正负无限;在圆圆的对面，邪恶，不道德的南面不存在任何有价值的东西$ 0 $。与此同时，在尘世间，上帝的孩子们享有自由意志，他们在东方的积极人与西方的消极人之间做出选择。</p><p> The quadrants induced by these points are then symmetrically populated by the rest of the points. The $useed$ determines where the &#34;center&#34; of these quadrants resides as follows:</p><p> 然后，由这些点引起的象限由其余的点对称地填充。 $ useed $确定这些象限的“中心”位于以下位置：</p><p> Much like Adam and Eve, the $useed$ determines how the quadrants in the circle are populated.Positive values lie at the right of the circle, while negative values lie at the left, and reciprocal values reflect across the equator.</p><p> 就像亚当和夏娃一样，$ useed $决定了圆中象限的填充方式。正值位于圆的右侧，负值位于圆的左侧，倒数在整个赤道上反映。</p><p>   Tragically, we live in a fallen world, full of non-believers and doubting Thomases.This necessitates effective proselytizing that speaks not only to broken spirits, but also to faithless minds.</p><p>   悲惨的是，我们生活在一个堕落的世界中，充满了非信徒和对托马斯的怀疑。</p><p>   Whereas there are two floating point representations of zero (both positive and negative), there is only one such posits representation: the all zero bit pattern.</p><p>尽管有两个零的浮点表示形式（正数和负数），但是只有一个这样的正数表示形式：全零位模式。</p><p> Whereas positive and negative infinity are distinctly represented as floating points, posits unite these values into one representation: the bit pattern with all zeros save for the first bit.</p><p> 正负无穷表示为浮点数，而正则将这些值组合成一个表示形式：全零的位模式保存在第一位。</p><p> Whereas floating point numbers are polluted with  NaN values, posits are cleansed of such unclean special values.</p><p> 浮点数会被NaN值污染，而正数会被清除掉这些不干净的特殊值。</p><p>   At other times, a more quantitive approach is called for;to this end, Gustafson proposes a variety of metric-based comparisons for numerical representation.First, he asks: how can we assess how accurately a number is represented in a given representation?To answer this, he proposes the  decimal accuracy metric: the number of significant bits of a real number on a logarithmic scale, as in the decibel system.</p><p>   在其他时候，需要一种更定量的方法;为此，古斯塔夫森提出了多种基于度量的数字表示比较。首先，他问道：我们如何评估给定表示形式中数字的精确度？回答这个问题，他提出了十进制精度度量：对数刻度上实数的有效位数，如分贝系统中那样。</p><p>  A “perfect spacing” of ten numbers between 1 and 10 in a real number system would be not the evenly-spaced counting numbers 1 through 10, but exponentially-spaced $1,10^{\frac{1}{10}},10^{\frac{2}{10}},...,10^{\frac{9}{10}},10$.</p><p>  实数系统中介于10和10之间的十个数字的“完美间隔”不是计数数字1到10的均匀间隔，而是指数间隔的$ 1,10 ^ {\ frac {1} {10}}，10 ^ {\ frac {2} {10}}，...，10 ^ {\ frac {9} {10}}，10 $。</p><p> Thus, the &#34;canonical position&#34; of a (positive, non-zero) real number $n$ is given by $p$, where $n = 10^{\frac{p}{10}}$,and so it follows that the distance, or representation error, between a real number $n$ and its representation $n&#39;$ is given by $| \log_{10}(\frac{n}{n&#39;}) | $.A straightforward adjustment adapts this scheme to negative numbers as well, and we ignore zero, since posits represents it exactly.The inverse of this error which yields the  perfect metric for accuracy.Equipped with this metric, we glean the significant digits of the representation, the  decimal accuracy, by taking its base 10 logarithm.</p><p> 因此，（正，非零）实数$ n $的“规范位置”由$ p $给出，其中$ n = 10 ^ {\ frac {p} {10}} $，因此遵循实数$ n $与其表示$ n'$之间的距离或表示误差由$ |给出\ log_ {10}（\ frac {n} {n'}）| $。直接调整也使该方案也适用于负数，由于正数表示正负号，因此我们忽略了零。此误差的倒数产生准确度的完美度量标准。配备此度量标准后，我们​​收集了有效位数以十进制为底的对数表示十进制精度。</p><p>   We make two observations from this plot:First, posits distribute decimal accuracy symmetrically across representations, while floating points fail to deliver at larger numbers, which are ignored in favor of  NaN.Furthermore, posits favor decimal accuracy at the meat of the number line, a sizable domain around 0, whereas floating points over-emphasizes the ends of the number line.Finally, posits represents more numbers: they cast the light of representation across a larger domain. In other words, the  dynamic range of posits, a further metric, exceeds that of floating points.</p><p>   我们从该图中得出两个观察结果：首先，posits在表示形式之间对称地分配小数精度，而浮点数不能在较大的数字处传递，而对于NaN则被忽略了;此外，posites赞成数字线处的小数精度最后，位置代表更多的数字：位置代表更大范围的显示。换句话说，位置的动态范围（另一个度量标准）超过了浮点数的范围。</p><p>  Besides raw representation error, there is the possibility of errors generated from primitive operations.Gustafson addressed this for basic arithmetic operations by means of &#34;closure plots&#34;.Such a plot visually depicts the accuracy of every combination of inputs.For instance, the multiplication closure plot below paints the input domain darker where more accurate results are achieved, as measured by decimal accuracy:</p><p>除了原始表示错误外，还有可能因原始运算而产生错误。Gustafson通过“闭合图”解决了基本算术运算的问题。这种图直观地描述了输入的每种组合的准确性。例如，乘法闭合下图以十进制精度表示，将输入域更暗，可获得更准确的结果：</p><p>  Accuracy of single argument operations between representations are compared by plotting sorted error.For instance, Gustafson compares accuracy of square root in the following plot:</p><p>  通过绘制排序误差比较表示形式之间单参数运算的精度，例如，古斯塔夫森（Gustafson）在以下图中比较平方根的精度：</p><p>   As part of our cultist duties, we compare the accuracy of 32-bit floating point and posit representation by comparing their accuracy under a variety of benchmarks.In each benchmark, we express real number calculations in terms of operations over 64-bit  doubles.In other words, the  double type serves as the &#34;oracle&#34; baseline from which we compute accuracy.Each  double benchmark is then compiled to LLVM IR, upon which we apply a  posit LLVM pass and a  float LLVM pass respectively to generate associated benchmarks.</p><p>   作为信使工作的一部分，我们通过比较各种基准下的32位浮点数和posit表示的精度来比较其准确性。在每个基准中，我们都以64位双精度以上的运算表示实数计算。换句话说，双精度类型用作计算精度的“ oracle”基准。然后，将每个双精度基准编译为LLVM IR，然后分别应用正向LLVM遍历和浮点LLVM遍历以生成关联的基准。</p><p> Finally, we compute percent error by comparing  float and  posit benchmark results to the  double baseline benchmark.We regard benchmark errors as arising from the inaccuracy that is characteristic of the particular 32-bit representation, compounded with successive operations.With our deepest apologies to Gustafson, we compute these errors on a linear scale, rather than a logarithmic one, and use these as metrics to compare the accuracy of the two representations.</p><p> 最后，我们通过将浮动基准和基准基准结果与双基准基准进行比较来计算误差百分比，我们认为基准误差是由特定32位表示形式所特有的不准确性所引起的，再加上连续的运算。我们向古斯塔夫森深表歉意，我们以线性标尺（而不是对数标尺）计算这些误差，并将它们用作度量标准以比较两种表示法的准确性。</p><p>  We aimed for our  float and  posit passes to insert as much representation-specific functionality as possible into our benchmarks.The case of  floats allows a full translation, since every  double operation can be cast as a  float operations.The case of  posits lacked full support, however: we did not provide implementations for all existing LLVM  double operations.</p><p>  我们的目标是通过float和posit传递将尽可能多的特定于表示的功能插入我们的基准测试.float的情况允许完整转换，因为每个双精度操作都可以转换为float操作。 ，但是：我们没有为所有现有的LLVM double操作提供实现。</p><p> To accommodate both cases under one pass implementation, we designed our pass such that it first lowers each supported  double operation and operands down to the target representation, subsequently lifting the result back to a  double.</p><p> 为了在一次通过实现中适应两种情况，我们设计了一次通过，以使其首先降低每个受支持的double运算并将操作数降低到目标表示，然后将结果提升为double。</p><p> Since each rewrite has a purely local effect, we can avoid reasoning about complex allocation and type casting scenarios.Though computationally inefficient, this approach immediately supports all programs and is easily extendible.</p><p> 由于每次重写都具有纯粹的局部效果，因此我们可以避免对复杂的分配和类型转换场景进行推理，尽管计算效率低下，但这种方法可立即支持所有程序并且易于扩展。</p><p> In pseduo-LLVM, the general structure of a pass to type  typ converts an arbitrary  double operation  op and its operands proceeds as follows:</p><p>在pseduo-LLVM中，类型为typ的传递的一般结构转换任意双精度运算op，其操作数如下所示：</p><p> x : double = ..y : double = ..result : double = op double x y</p><p> x：double = ..y：double = ..result：double = op double x y</p><p>  x : double = ..y : double = ..x_typ : typ = convert double x to typ;y_typ : typ = convert double y to typ;result_typ : typ = typ_op x_typ y_typ; result double = convert result_typ typ to double</p><p>  x：double = ..y：double = ..x_typ：typ =将double x转换为typ; y_typ：typ =将double y转换为typ; result_typ：typ = typ_op​​ x_typ y_typ;结果double =将result_typ类型转换为double</p><p>    LLVM&#39;s floating point operations with type parameter set to  float (e.g.,  fadd float x y)</p><p>    类型参数设置为float的LLVM浮点运算（例如fadd float x y）</p><p> The  posit pass draws these components from external C functions implemented in  Cerlane Leong&#39;s SoftPosit repository.In particular, we borrow the basic arithmetic operations ( +,  -,  *, and  /) over 32-bit posits.</p><p> posit传递从Cerlane Leong的SoftPosit存储库中实现的外部C函数提取这些组件，尤其是，我们借用32位posits的基本算术运算（+，-，*和/）。</p><p>   For each input, we calculate percent error for  float and  posit benchmark results, regarding the corresponding  double benchmark results as the correct, &#34;oracular&#34; values. We chose computationally feasible sample sizes for each benchmark approximately using the heuristic $20^{vars}$, where $vars$ denotes the number of input variables for the benchmark, reflecting the need for more samples over larger input spaces.Inputs were linearly sampled over the valid input ranges specified for each benchmark.This simple strategy ensured that test cases would also include the case of exactly representable integers, in which all of the error arises from operation error.We report the mean and standard deviation of the percent error over all examined inputs:</p><p>   对于每个输入，我们都将浮动基准和基准基准结果的误差百分比计算为正确的“随机”值，并将相应的双重基准结果作为基准。我们大约使用启发式$ 20 ^ {vars} $为每个基准选择计算上可行的样本大小，其中$ vars $表示基准的输入变量数量，反映出在较大的输入空间上需要更多样本。这个有效的输入范围是为每个基准测试指定的。这种简单的策略可以确保测试用例也包括可以精确表示的整数的情况，其中所有误差均源于运算误差。我们报告了所有误差百分比的平均值和标准偏差检查的输入：</p><p>       As prophesied by Gustafson, posits consistently outperform floating points by orders of magnitude.However, our LLVM  posit pass is grossly inefficient: it introduces loads and stores operations to convert between  double and  posit for each  double operation.We blame this sad state of affairs on ignorant, non-posit architectures, which necessitate such a pass in the first place.</p><p>       根据古斯塔夫森（Gustafson）的预言，假定位置始终优于浮点数个数量级，但是我们的LLVM确定位置效率极低：它引入了负载并存储了操作，以便为每个重复操作在double和posit之间进行转换。无知的，非确定性的体系结构，这首先需要通过这样的测试。</p><p>  A posit processing unit takes less circuitry than an IEEE float FPU. With lower power use and smaller silicon footprint, the posit operations per second (POPS) supported by a chip can be significantly higher than the FLOPS using similar hardware resources. GPU accelerators and Deep Learning processors, in particular,can do more per watt and per dollar with posits, yet deliver superior answer quality</p><p>位置处理单元比IEEE浮动FPU占用更少的电路。利用更低的功耗和更小的硅片占位面积，芯片所支持的每秒posit操作数（POPS）可能明显高于使用类似硬件资源的FLOPS。尤其是GPU加速器和深度学习处理器，每瓦特和每美元可以带来更多收益，同时提供卓越的答案质量</p><p> Indeed, we could be talking in terms of POPS instead of FLOPS.Nonetheless, our pass allows us to simulate and give thanks for posit accuracy.</p><p> 的确，我们可以用POPS代替FLOPS进行交谈。</p><p> Our approach relies on treating the  double type as the &#34;ground truth&#34; representation for benchmarks. Although this is an approximation, since no finite representation has perfect accuracy, we assume that the accumulated error in  double benchmarks will be truncated or rounded off when comparing with the less precise 32-bit representations.In other words, we assume that casting to a  double from a  float or 32-bit  posit can be done without loss of information.Although this assumption does not always hold, we found it to be sufficient for practical testing and justified the streamlined design of our LLVM pass.</p><p> 我们的方法依赖于将double类型视为基准的“基本事实”表示。尽管这是一个近似值，但由于没有有限的表示形式具有完美的准确性，因此我们假设与不太精确的32位表示形式进行比较时，双基准中的累积误差将被截断或四舍五入。浮点数或32位正数的两倍可以在不损失信息的情况下完成。尽管这种假设并不总是成立，但我们发现它足以进行实际测试，并证明了LLVM传递的精简设计是合理的。</p><p>   [posits] provide compelling advantages over floats, including larger dynamic range, higher accuracy, better closure, bitwise identical results across systems, simpler hardware, and simpler exception handling.</p><p>   [posits]提供了优于float的引人注目的优势，包括更大的动态范围，更高的精度，更好的闭包，系统中按位相同的结果，更简单的硬件以及更简单的异常处理。</p><p> Confess your use of floating points, repent, and be cleansed.Contact the authors for induction into the Cult of Posits.</p><p> 承认您使用浮点，pent悔并加以清洗。请与作者联系以归纳为“教派”。</p><p>  This is the course blog for  CS 6120, the PhD-level compilers course in the computer science department at Cornell.You can subscribe to  posts on the blog with  RSS.</p><p>  这是CS 6120的课程博客，这是康奈尔大学计算机科学系的博士学位级编译器课程。您可以使用RSS订阅博客上的帖子。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/posits/">https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/posits/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/潜在/">#潜在</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cult/">#cult</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/表示/">#表示</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>