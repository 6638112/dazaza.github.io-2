<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>整合UNIX和Mac OS环境的挑战（2000） The Challenges of Integrating the Unix and Mac OS Environments (2000)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Challenges of Integrating the Unix and Mac OS Environments (2000)<br/>整合UNIX和Mac OS环境的挑战（2000） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 01:07:34</div><div class="page_narrow text-break page_content"><p>Wilfredo Sanchez, Apple Computer Mac OS was developed in the early-1980s around the idea ofproviding the best possible user experience. Apple succeeded inmaking Mac OS a best-of-breed operating system for personal computers:Mac OS has set the standards against which modern graphical userinterfaces are now modeled. The primary alternative to Mac OS at thetime was Microsoft&#39;s DOS, which ran on IBM PCs. Mac OS was able toprovide the functionality that DOS provided via a visual model whichhas proven to be much easier for the lay user to understand than thecommand-driven interface employed by DOS and other systems such asAT&amp;T&#39;s Unix. Tight integration with the underlying hardware hasallowed the Macintosh platform to extend the experience beyond thesoftware and into the actual management of the machine, withplug-and-play device support and &#34;out of the box&#34; support for manydevices. The Macintosh led the way to such technologies as desktoppublishing.</p><p>Wilfredo Sanchez，Apple Computer Mac OS是在20世纪80年代初开发的，围绕着提供了最佳用户体验的想法。 Apple成功地修建了Mac OS，为个人计算机获得了最佳的操作系统：Mac OS设置了现代图形用户识别现在建模的标准。在轮胎上的Mac OS的主要替代品是Microsoft＆＃39; s dos，它在IBM PC上运行。 Mac OS能够将DOS通过视觉模型提供的功能进行拓扑，该功能对于Play用户更容易理解DOS和其他系统所采用的TheCommand驱动的接口，如asat＆＃39; s unix。与底层硬件紧密集成，允许麦金托斯平台扩展到TheSoftware的经验，并进入机器的实际管理，用力播放设备支持和＆＃34;从框中开箱和＃34;支持许多人。 Macintosh LED作为Desktoppublishing等技术的方式。</p><p> Unix has evolved from a different set of goals. Unix has beenpopular in academic and engineering environments, often used onhigh-end servers and workstations. Developers at U. C. Berkeley andother academic institutions have used Unix as a testbed for manyresearch endeavors which have resulted in important computingtechnologies such as TCP/IP. Unix machines were typically shared bymany users, requiring support for individual user accounts which couldbe utilized simultaneously on the same machine. Unix&#39;s early exposureto all of these advances lead to a deep understanding of how varioussubsystems interact, resulting in a relatively robust and modularsystem. Unix systems served as the basis and continue to support muchof the infrastructure for today&#39;s Internet.</p><p> Unix已经从不同的目标集中演变。 Unix在学术和工程环境中已经过分，通常使用onh-end服务器和工作站。 U. C. Berkeley和其他学术机构的开发人员已经使用UNIX作为许多研究的测试平台，这导致了TCP / IP等重要计算技术。 UNIX机器通常是由Manyy用户共享的，需要支持各个用户帐户，该用户帐户可以在同一台计算机上同时使用。 UNIX＆＃39; S早期exposureto所有这些进步导致深入了解各种系统如何互动，导致相对强大和模块化系统。 UNIX系统作为基础，并继续支持今天的基础设施。</p><p> Unix derivatives such as Sun&#39;s Solaris, Cal&#39;s BSD Unix, and laterLinux have grown to serve key roles as network servers. DOS waseventually replaced by Windows, which sports some of the userinterface features pioneered by Mac OS such the desktop, as well assome of the underlying ideas behind Unix such as preemptivemultitasking. While Unix systems remain in the lead for reliabilityand scalability, and Mac OS continues to push user interfaceinnovation forward, Windows has successfully narrowed the gap in bothareas.</p><p> unix衍生物如sun＆＃39; s solaris，cal＆＃39; s bsd unix和laterlinux已经生长为作为网络服务器的关键角色服务。 DOS是由Windows替换的，其中体育了一些由Mac OS这样的桌面开创的UserInterface的功能，以及unix背后的潜在想法，如PremptimeMultittitastastastastAstasking。虽然UNIX系统仍然是可靠性和可扩展性的领先优势，而Mac OS继续推送用户界面，Windows已成功缩小了Sputareas的差距。</p><p> Mac OS X is Apple&#39;s effort to create a best-of-both-breedsoperating system which directly leverages the advances and experienceApple has in the user experience arena and the well-established powerof BSD. Mac OS X begins with a BSD foundation called Darwin. OnDarwin we build the programming toolkits from Mac OS which we callCarbon, which in turn enables us to layer on the new user interfaceknown as Aqua. Carbon also provides a straightforward transitionstrategy for our existing application base. We also provide a toolkitcalled Cocoa, which is an object-oriented API derived from NeXT&#39;sOpenStep.</p><p> Mac OS X是苹果公司＆＃39;努力创建一个最佳的流产系统，该系统直接利用了用户体验竞技场和建立了良好的BSD的良好的进步和体验。 Mac OS X从名为Darwin的BSD基金会开始。 ondarwin我们从Mac OS构建了我们CallCarbon的编程工具包，这又使我们能够在新用户界面上层叠为Aqua。 Carbon还为我们现有的应用基础提供了直接的过渡族。我们还提供了一个工具包的可可，这是一个面向对象的API，它来自下一个＆＃39; sopenstep。</p><p> This makes for an interesting system architecture. The idealresult is a system that can be the sort of reliable server platform weuse today to host high-volume web sites, file services, networkgateways, and engineering computation services while also being thesimple to use home computer platform of choice. This is a dauntingtask, because the server platform goals mandate a certain level ofcomplexity (high security, performance tuning parameters, variousnetwork servers, etc.), while for most home users, simplicityoverrides other concerns.</p><p> 这使得有趣的系统架构。 DeedResult是一种系统，可以是今天的可靠服务器平台威士忌，以托管大批量网站，文件服务，网球道和工程计算服务，同时也可以使用家用计算机平台。这是一个dauntingtask，因为服务器平台目标规定了一定程度的复杂性（高安全性，性能调整参数，各种网络服务器等），而对于大多数家庭用户，SimpliciteOvers其他问题。</p><p> Unix and Mac OS have evolved independently of each other, and thereare fundamental assumptions made in one system which cause numerousfailures in the other. The capabilities of the available filesystems,the networking protocols, and the user/system model are profoundlyvaried, often in ways which cannot be rectified without changing thearchitecture of system components. Additionally, people use thesystems in very different ways and expect different behavior fromthem.</p><p> UNIX和Mac OS彼此独立地发展，并且在一个系统中制作的基本假设，导致另一个系统中的无数。可用文件系统，网络协议和用户/系统模型的功能是深刻的，通常以无法纠正的方式而不改变系统组件的分组。此外，人们以非常不同的方式使用和系统，并期望不同的行为。</p><p> This paper will discuss some of the issues which have arisen atApple in the process of combining these disparate environments andsome of the solutions that were used to make things work well in MacOS X. There have been many such issues, and in the interest ofbrevity, we will visit two key areas here: filesystems and multipleuser support. Examples given do not go into a great deal of detail,but enough information is provided to give the reader an idea of theproblems and our attempt at a solution.</p><p> 本文将讨论在组合这些不同环境的过程中出现的一些问题，这些问题和用于在麦斯科斯播放群体中运作良好的解决方案的过程中的一个问题。我们有许多这样的问题，以及您的兴趣，我们将访问以下两个关键区域：文件系统和多重支持。给出的例子不会进入大量细节，但提供了足够的信息，以使读者提出该问题的想法和我们在解决方案的尝试。 </p><p>  The use of filesystems demonstrates both implementation andsemantic problems between the Unix and Mac environments. We&#39;ll startwith the implementation issues, which is the obvious material.</p><p>文件系统的使用展示了UNIX和MAC环境之间的实现和许可问题。我们＆＃39; ll startwith实现问题，这是明显的材料。</p><p> The filesystems used in Mac OS are the Mac OS Extended filesystem,also known as HFS+ and its predecessor the Mac OS Standard filesystem, or HFS (Hierarchical File System). Both filesystems aresupported in Mac OS X, though HFS is support is only provided forcompatibility and users are encouraged to use HFS+ for newvolumes.</p><p> Mac OS中使用的文件系统是Mac OS扩展文件系统，也称为HFS +及其前任Mac OS标准文件系统或HFS（分层文件系统）。两个文件系统都在Mac OS X中播出，尽管HFS是支持，但仅提供了载体，并鼓励用户使用HFS + for NewVolumes。</p><p> The HFS+ volume format, unlike the HFS volume format, fortunatelyprovides storage for Unix-style meta-data (eg. owner and mode bits).This made it a lot easier to enable the use of HFS+ in the Darwinenvironment. However, a few incompatibilities still exist.</p><p> HFS +卷格式与HFS卷格式不同，幸运的是UNIX样式元数据的存储（例如，所有者和模式位）。这使得能够在Darwinen环境中使用HFS +更容易。但是，一些不兼容仍然存在。</p><p> HFS+ is a case preserving, but case insensitive, filesystem. Thatis, the case of file names is remembered, but access to file nameswith varying case will yield the same file, and file names which varyonly in case are not allowed in any given directory. Typical Unixfilesystems are, in contrast, case sensitive. At the start of theRhapsody project, which preceded the current Mac OS X work, we hadanticipated that this would be a big problem. Later, when we startedusing HFS+ as the primary filesystem in Darwin, we found surprisinglyfew problems resulting from this behavior, and those which we do findtend to be trivial to fix. We have yet to encounter a problem in thisarea which requires a complex solution.</p><p> HFS +是保留的案例，但不区分大小写的文件系统。 Chatis，记住文件名的情况，但是对不同案例的文件名称将产生相同的文件，并且在任何给定目录中不允许在任何情况下超越的文件名。相比之下，典型的UnixFilesystems的敏感性。在Proced Project开始的开始之前，它在当前的Mac OS X工作之前，我们陷入了困境，这将是一个大问题。后来，当我们在达尔文中的HFS +作为主要文件系统中，我们发现了这种行为产生的令人惊讶的问题，以及我们所做的那些才能微不足道的解决问题。我们尚未遇到该问题的问题，需要复杂的解决方案。</p><p> Another obvious problem is the different path separators betweenHFS+ (colon, &#39; :&#39;) and UFS (slash, &#39; /&#39;).This also means that HFS+ file names may contain the slash characterand not colons, while the opposite is true for UFS file names. Thiswas easy to address, though it involves transforming strings back andforth. The HFS+ implementation in the kernel&#39;s VFS layer convertscolon to slash and vice versa when reading from and writing to theon-disk format. So on disk, the separator is a colon, but at the VFSlayer (and therefore anything above it and the kernel, such as libc)it&#39;s a slash. However, the traditional Mac OS toolkits expect colons,so above the BSD layer, the core Carbon toolkit does yet anothertranslation. The result is that Carbon applications see colons, andeveryone else sees slashes. This can create a user-visibleschizophrenia in the rare cases of file names containing coloncharacters, which appear to Carbon applications as slash characters,but to BSD programs and Cocoa applications as colons.</p><p> 另一个显而易见的问题是HFS +（冒号，＆＃39;：＆＃39;）和UFS（斜线，＆＃39; / &#39 ;).这也意味着HFS +文件名可能包含斜杠字符没有冒号，而对相反的是UFS文件名。虽然它涉及转换弦乐而易于解决。内核中的HFS +实现在内核和＃39; S VFS层ConvertScolon中以抄袭和写入磁盘格式时的斜杠，反之亦然。所以在磁盘上，分隔符是一个冒号，但在vfslayer（因此，它以上的任何东西和内核，例如libc）它＆＃39; s斜线。但是，传统的Mac OS工具包期望冒号，所以在BSD层上方，核心碳工具包又是另一个传播。结果是碳应用看到冒号，否则无用的人看到斜线。这可以在包含Coloncharacters的文件名的罕见情况下创建一个用户粘性奇妙，该文件名称为碳应用程序作为斜杠字符，而是将BSD程序和Cocoa应用程序作为冒号。</p><p> HFS+ lacks support in the volume format for hard links, a standardfeature of UFS. Initially, the attempted creation of a link to a filewould yield a &#34;not supported&#34; error. We had discussed some &#34;80%&#34;solutions, such as creating symbolic links instead, but the semanticsof symbolic links are significantly different. For troubleshootingreasons it is preferable to fail at link creation time than at somelater time due to problems related to these semantic differences. Theproblem is that there is a significant amount of software which breaksif hard link creation fails, and some of that software needs to beredesigned if hard links cannot be used. In order to accommodate thissoftware, we now emulate hard links by creating a &#34;kernel-level&#34;symbolic link which is visible only to and interpreted by the HFS+filesystem. This was necessary due to the lack of support in thevolume format. The resulting behavior is very similar to that of hardlinks when viewed from above the kernel, though they are relativelyinefficient in comparison.</p><p> HFS +缺少硬链接的体积格式的支持，UFS的标准规范。最初，尝试创建一个文件的链接，从而产生A＆＃34;不支持和＃34;错误。我们讨论了一些＆＃34; 80％＆＃34;解决方案，例如创建符号链接，但符号链接的语义显着不同。对于故障排除，由于与这些语义差异有关的问题，因此优选在链接创建时间下失败。 TheProblear是有大量的软件，突破硬链接创建失败，如果不能使用硬链接，其中一些软件需要Beredesign。为了适应该软件，我们现在通过创建A＆＃34;内核级别＆＃34;符号链接只能由HFS +文件系统解释并解释的符号链接。由于缺乏以特定格式的支持，这是必要的。当从内核上方观看时，由此产生的行为与硬链接的行为非常相似，尽管它们相比相对相比。</p><p> UFS, on the other hand, does not support file IDs, which is afeature of HFS+. File IDs are persistent handles to a file, and canbe used to access a file in a manner similar to which one uses pathsin Unix. The nice thing about file IDs is that once the ID for a fileis obtained, the file can be renamed or moved anywhere on disk andstill be found and opened by the holder of the ID, and file access byID is faster than access by path, as it avoids the path lookups. MacOS aliases are similar to symbolic links, with the addition ofalternative means of finding the file. Because aliases include thetarget file&#39;s ID, moving the target file does not break the alias asit would a symbolic link.</p><p> 另一方面，UFS不支持文件ID，这是HFS +的非法。文件ID是对文件的持久句柄，可以用来以类似于其中使用Pathsin UNIX的方式访问文件。关于文件ID的好处是，一旦获得了Fileis的ID，可以将文件重命名或移动到磁盘ANDSTILL上的任何位置，并由ID的持有者打开，并且文件访问比路径的访问更快，如它避免了路径查找。 MacOS别名与符号链接类似，添加了找到文件的替代方法。因为别名包括Thetarget文件＆＃39; s ID，移动目标文件不会破坏别名，因为alit是一个符号链接。 </p><p> One of the biggest problems is the lack of complex file support inmost Unix filesystems. HFS+ allows for a file to have multiple datastreams: one, the data fork, contains the actual file data, andanother, the resource fork contains additional resource data. (At thefilesystem level, this is really just two files which happen to sharea name.) The volume format also allows for arbitrary named fileattributes (similar support is in UDF, NFSv4), though the neither MacOS 9 nor Mac OS X support the use of this feature in the fileformat.</p><p>最大的问题之一是缺少复杂的文件支持最重要的UNIX文件系统。 HFS +允许文件有多个数据汇流：一个，数据叉子包含实际文件数据，AndAnother，资源叉子包含其他资源数据。 （在Filesystem级别，这只是一个发生在Sharea名称的两个文件。）卷格式也允许任意名为FileAttributes（类似的支持是在UDF，NFSv4）中，尽管既不是MacOS 9也不是Mac OS X支持使用FileFormat中的此功能。</p><p> This has often been a source of compatibility issues between Mac OSand other platforms in the past. When transferring files via theInternet, they usually need to be encoded in a format such asMacBinary, which will combine both streams into one, so that it can beserved by a web or FTP server. (Servers which run on Mac OS can dothis as needed.)</p><p> 这通常是Mac Os和过去其他平台之间的兼容性问题的源。通过internet传输文件时，通常需要以诸如macbinary的格式编码，这将两个流组合成一个，以便它可以由Web或FTP服务器提供。 （根据需要在Mac OS上运行的服务器。）</p><p> There were several proposals for how to present complex files toBSD clients which  open() them. One was to combine thetwo streams into AppleDouble format. This has the advantage ofcontaining all of the data in the complex file, and programs like cp could work properly. The problem then is that if onewere to open a complex C source file in emacs they&#39;d see not only theprogram text, but also some weird encoding information and whateverresource data that was put there by a Carbon application. A fatalproblem with this scheme is that part of the file data (the encodinginfo) is creates by the filesystem, and isn&#39;t really part of the filedata, and should therefore not be editable. The non-lossy aspect ofthis solution is what drew us to is, but the complications turned outto be too substantial.</p><p> 有几个提案如何呈现复杂的文件ToBSD客户端，该客户端打开（）。一个是将Thetwo Streams合并为Appledouble格式。这具有涉及复杂文件中所有数据的优势，并且CP等程序可以正常工作。然后问题是，如果operwere在emacs中打开一个复杂的c源文件，它们不仅看到了Program文本，还看到了一些奇怪的编码信息，以及通过碳应用置于那里的源泉数据。具有此方案的FATALPROBRABRABROBRABROBROBE文件数据（ENCODINGINFO）由文件系统创建，而ISN＆＃39; t真正的FILEDATA的一部分，因此不可编辑。解决方案的非损失方面是吸引我们的是，但并发症变得太大了。</p><p> The present mechanism presents the data fork to the BSD client afile is opened by name. If the resource fork is desired, it can beread by appending a known string to the file path. For example&#34; foo/bar&#34; gets you the data for file bar, but&#34; foo/bar/.namedfork/resource&#34; will get you the resourcefork for bar. (The actual appended string may change.) Note that thefile is not somehow acting as a directory; it is not listable, and stat() calls still show it as a file. This mechanism canbe carried to other filesystems with complex files, such as UDF. (UDFalso has allows attributes for directories.)</p><p> 本机制将数据叉子呈现给BSD客户端的Afile按名称打开。如果需要资源叉程，它可以通过将已知字符串附加到文件路径来eread。例如和＃34; foo / bar＆＃34;为您提供文件栏的数据，但是＃34; foo / bar / .namedfork /资源＆＃34;将为您提供ResourceFork for Bar。 （实际附加的字符串可能会更改。）请注意，“文件”不某种方式作为目录;它不是lishable，stat（）调用仍然将其作为文件显示。此机制可以带到具有复杂文件的其他文件系统，例如UDF。 （Udfalso允许属性用于目录。）</p><p> The are flaws in this plan as well. Most Unix software will onlysee the data fork of a file, so &#34; cp foo bar&#34; will resultin a new file bar which is missing the resource data from foo (ifthere was any). Backup and archiving software may also lose data. Westill have the problem of sharing files with systems that don&#39;tsupport complex files. Mac OS X will continue to support complexfiles, but we are moving away from their use in order to increase ourability to operate in a heterogeneous environment.</p><p> 该计划中的缺陷也是如此。大多数UNIX软件都将仅对文件的数据叉，所以＆＃34; CP Foo Bar＆＃34;将导出一个新的文件栏，该栏缺少foo（ifthery的资源数据）。备份和存档软件也可能丢失数据。 WESTILL将文件与DON＆＃39; TSUPPORT复杂文件的系统共享问题。 Mac OS X将继续支持ComplexFiles，但我们正在远离其使用，以提高在异构环境中运行的无可能性。</p><p> A third option which we did not explore is to show the two forksare separate files altogether. This is similar to some AppleShareimplementations on Unix, which export a Unix filesystem as anAppleShare volume. When a file &#34; foo&#34;, written by a MacOS client is viewed from the Unix side, there is another file (usuallynamed in a convention similar to &#34; .foo.resource&#34; or&#34; .resources/foo&gt;&#34;) which contains the resource data. Ifthese servers are also serving Unix clients (including local access),which is often the case, files tend to get moved around in the Unixside, and the resource file is left in the old location. The resultis an effective loss of the resource data and a need somehow to manage(periodically clean up) these disassociate resource files. The HFS+filesystem can probably address this problem by magically moving theresource file along with the data, but strange behavior of this sorttends to produce bugs, and this approach didn&#39;t seem to offersignificant advantages over the alternatives, and it got dropped.</p><p> 我们没有探索的第三种选项是展示两个叉子完全单独的文件。这类似于UNIX上的某些AppleShareImplementation，它将Unix文件系统导出为Anappleshare卷。当文件＆＃34; Foo＆＃34;由麦克斯客户端写的，从UNIX方面看，还有另一个文件（通常在类似于＆＃34的公约中确定; .foo.resource＆＃34;或＆＃34; .resources / foo＆gt;＆＃ 34;）包含资源数据。如果服务器也是Unix客户端（包括本地访问），通常是这种情况，文件往往会在Unixside中移动，并且资源文件留在旧位置。结果是有效的资源数据丢失以及某种方式以某种方式管理（定期清理）这些解剖资源文件。 HFS +文件系统可以通过神奇地移动Theresource文件以及数据来解决这个问题，但是这种排序的奇怪行为来产生错误，而这种方法似乎可以提供优于替代方案的优势，但它被删除。</p><p> Interestingly, the Carbon team has run into exactly this problem onUFS, where there is no obvious place to store resource forks, thepresent implementation of Carbon uses a similar solution as the oneemployed by Unix AppleShare servers.</p><p> 有趣的是，碳团队已经陷入了恰好这个问题Onufs，在那里没有明显的存储资源叉子，炭的实际实施使用类似的解决方案作为UNIX Appleshare服务器的Ioneypaly。 </p><p> Other filesystem problems are more subtle, and are due to differentsemantic expectations made by Mac OS and Unix systems as well asimplementation details.</p><p>其他文件系统问题更加微妙，并且是由于Mac OS和UNIX系统所做的差异化的预期，以及兼容细节。</p><p> One example of this is the delete semantics of Mac OS as comparedto the unlink semantics of Unix. In Mac OS, if you try to delete afile which someone else has open, the delete fails. This ensures thatif another application is using your file, the file is not deletedfrom under that application. Unix achieves this by going ahead andremoving the link, but the file continues to exist while it it open(though there is no longer a way to open that file). There are goodarguments to be made for either method, and some Mac OS programs relyon the Mac OS behavior (files are sometimes used as a semaphores),while many Unix programs expect unlink to always succeed (one trick inthe Unix world is to open a file for writing and then unlinking it soas to obtain a private bit of filesystem-backed memory to scribbleon).</p><p> 其中一个示例是Mac OS的删除语义，与UNIX的不同链接语义相比。在Mac OS中，如果您尝试删除其他人已打开的Afile，则删除失败。这可确保其他应用程序使用您的文件，在该应用程序下不会删除该文件。 UNIX通过前进和播放链接来实现这一目标，但是在它打开时，文件将继续存在（尽管不再是打开该文件的方法）。有任何方法都有要为任一方法制作，一些Mac OS程序relyon Mac OS行为（有时使用文件用作信号量），而许多UNIX程序则希望取消链接始终成功（一个技巧Inthe Unix World是打开文件用于写作，然后将其解释为SOA以获取到Scribbleon的文件系统备份内存的私有位置。</p><p> It is worth noting that the difference is behavior is in part dueto the implementation of the respective filesystems. In UFS,meta-data is store with the file&#39;s inode, and inodes are storedseparately from file data. In HFS+, the file meta-data is stored withthe file data; there is no inode. Removal of the file in HFS+therefore means removal of all access to the file. The unlinkbehavior in UFS come naturally from the separation of data and inodes;you simply delete the file, but keep the inode around as long as it isin use. On the other hand, one can do really fast searching of avolume for files with a given name in HFS+ because of how its storageis layed out. What is interesting here is that implementation detailscan lead to ideas and extensions which may not have been part of theoriginal design.</p><p> 值得注意的是，差异是行为是部分Dueto相应文件系统的实现。在UFS中，Meta-Data与文件＆＃39; s inode存储，并且inodes从文件数据中储存。在HFS +中，文件元数据与文件数据一起存储;没有inode。因此，在HFS +中删除文件意味着删除对文件的所有访问。 UFS中的unlinkbehavior自然地来自数据和inodes的分离;只要它使用它，您只需删除文件即可保持inode。另一方面，由于其存储方式铺设出来，可以真正快速搜索具有给定名称的文件中的文件。这里有趣的是，实施细节扫描导致思想和延伸，这可能不是理论设计的一部分。</p><p> In order to handle the differing semantics, a  delete()system call was added to BSD so that we have both semantics available.Typically, Unix programs will call  unlink() and Carbonapplications will call  delete(). An unlink will alwayssucceed, so it is still possible for a Carbon application which has afile open to lose that file when it is closed, if a BSD programunlinked it. This is acceptable because the goal is to allow Carbonprograms to continue to cooperate with each other as designed, and BSDprograms don&#39;t usually delete files belonging to a Carbon program, sothe software tends to work as expected.</p><p> 为了处理不同的语义，将删除（）系统调用添加到BSD中，以便我们具有可用的两个语义。纯版，UNIX程序将调用Unlink（）和CarbalApplications将调用delete（）。如果一个BSD ProgramsUnlinked，则取消链接将始终为碳应用程序仍然可以在关闭时丢失该文件。这是可以接受的，因为目标是允许碳化碳编程继续彼此合作，并将BSDPrograms Don＆＃39; T通常删除属于碳计划的文件，索托软件往往会按预期工作。</p><p> We should also be aware that while the primary goal here is to getMac OS X to operate properly with these differing software stacks, westill have millions of Classic Mac OS users and these users need toshare files and media with our new Mac OS X users. One example oftrouble is Unix permissions on HFS+ volumes. Mac OS 9 will not reador write Unix meta-data; though HFS+ supports it, Mac OS 9 will ignorethose bits completely. That&#39;s acceptable until you start moving adisk between Mac OS 9 and Mac OS X systems (or if you dual boot yoursystem and also, to a lesser degree, if you run the Classicenvironment in Mac OS X).</p><p> 我们还应该意识到这里的主要目标是使用这些不同的软件堆栈正确运行，威尔威尔有数百万的Classic Mac OS用户，这些用户需要带有新Mac OS X用户的Toshare文件和媒体。权力的一个示例是HFS +卷上的UNIX权限。 Mac OS 9不会读写UNIX META数据;虽然HFS +支持它，Mac OS 9将完全无知位。它可以接受，直到您在Mac OS 9和Mac OS X Systems之间开始移动Adisk（或者如果您是双引导您的系统以及较小程度，则在Mac OS X中运行Classicen环境）。</p><p> This may be a problem if you expect permissions to be enforcedacross systems, but if you are handing someone your disk or bootinginto another OS, you are bound to get dissapointed eventually. A moreinteresting situation, however, occurs when files get created in MacOS 9 and are seen later by Mac OS X. The files have no Unix meta-dataset, and therefore no permissions or owner. User  0(root) and group  0 (wheel) are reasonable defaults, but afile mode of  0000 is almost certainly not what the userwants. Fortunately, we are able to distinguish between &#34;no meta-dataset&#34; and zero values for mode and owner info. What we do in this caseis present the owner, group, and mode as some reasonable default,which is determined by examining the permissions on the directory nodeon which the filesystem is mounted. Note that the actual permissionson disk remain unset unless someone sets them explicitly; an unmountand remount with a different default will effect the mode of suchfiles. This allows for a flexible administration of the default modesuch that some disk default to more open permissions than others, asdesired.</p><p> 如果您希望执行权限为强制划衡系统，则这可能是一个问题，但如果您正在移交某人的磁盘或BootingInto另一个操作系统，则会最终才能失望。但是，在MacOS 9中创建的文件时，会发生更容感的情况，并在Mac OS X中稍后在稍后看到。文件没有UNIX元数据集，因此没有权限或所有者。用户0（root）和组0（滚轮）是合理的默认值，但0000的一致模式几乎肯定不是用户愿望。幸运的是，我们能够区分＆＃34;没有元数据集＆＃34;模式和所有者信息的零值。我们在此案例中所做的是所有者，组和模式作为某种合理的默认值，这是通过检查文件系统已安装的目录上的目录上的权限来确定。请注意，除非有人明确设置它们，否则实际的Permissonson磁盘仍保持未设置;卸载具有不同默认值的卸载将实现MuchFiles的模式。这允许灵活管理某些磁盘默认的默认模块，而不是其他磁盘默认为比其他磁盘更新。</p><p> As mentioned before, HFS is also supported. This is primarily toallow for the transfer of data to and from removable media andexisting hard drive volumes which are formatted for HFS. Furtherconstraints are found here, but this is similar to DOS filesystemsupport in Linux, and for the file transfer, HFS presents fewproblems. Because HFS does not store mode bits, a default is used inthe same manner that we use for unset modes in HFS+ files. Thesignificant new problem here is that files transferred to and from anHFS volume will lose permission information.</p><p> 如前所述，也支持HFS。这主要是为了传输数据和从可移动媒体和来自格式化HFS格式化的硬盘驱动器卷的拖延。这里找到了进一步的帧生，但这类似于Linux中的DOS FileSystemSupport，并且对于文件传输，HFS呈现了几个问题。因为HFS不存储模式位，所以使用默认值，以便在HFS +文件中用于未命令模式的方式相同的方式。这里的重要新问题是传输到ANHFS卷的文件将失去权限信息。 </p><p>  Above the kernel, there are file name conventions in Unix whichhave manifested as limitations and bugs in various Unix software. UFSallows any printable character in a file name, but many Unix shellscripts and programs have problems with files that contain &#34;special&#34;characters such as whitespace and punctuation. In Mac OS, users havenot been subject to this limitation in the system and should not besubject to them in Mac OS X. One good example of this is the make command, which uses whitespace as a file namedelimiter, making it difficult to produce program output called, forexample,  Netscape Navigator®. There is no reason whythis has to be the case, but it is an unfortunate historical artifactof how Unix grew up.</p><p>在内核之上，UNIX中存在文件名约定，哪个讨论为各种UNIX软件中的限制和错误。 UFSallows文件名中的任何可打印字符，但许多UNIX shellscripts和程序都有包含＆＃34;特殊＆＃34;字符，如空格和标点符号的疑问。在Mac OS中，用户在系统中避免了此限制，并且不应在Mac OS X中向其中留下它们。一个很好的例子是make命令，它使用空格作为文件namedelimiter，使得难以生产程序输出叫做，forexample，NetscapeNavigator®。没有理由为什么是这种情况，但它是一个不幸的历史神节，Unix如何长大。</p><p> As mentioned above, Unix has a heavy reliance on file paths. Oneof many such examples is the Bourne shell: if the  shprogram does not exist in  /bin, the system won&#39;t evenboot properly. While Mac OS is not immune from such problems, it doesallow the user to relocate or rename even such important items as theSystem Folder. This is a particularly significant issue because,although we use BSD as the core system software, we do not want torequire our users to understand how BSD works. Ideally, the typicalMacintosh user does not even know that BSD is there. The verypresence of such folders as &#34; usr&#34; and &#34; etc&#34;on disk is therefore awkward, and we hide those directories and theircontents at the application level in order to avoid confusion as towhy they are there and cannot be moved or deleted. One idea is to putall system files into a Mac OS-style System Folder, and make thatfolder opaque to the user. This requires that there be other methodsfor managing the system software than allowing users to poke in therethemselves, and we still have the problem that standard Unix paths arerequired to exist at the root level of the boot volume. This is stillan area which we are actively working to improve upon.</p><p> 如上所述，UNIX对文件路径具有沉重的依赖。许多这样的例子是Bourne shell：如果Shprogram不存在/箱，系统赢得了＆＃39; terpoot。虽然Mac OS不受此类问题的免疫，但它允许用户重新定位或重命名为此重要的项目作为Th依此展示文件夹。这是一个特别重要的问题，因为我们使用BSD作为核心系统软件，但我们不希望我们的用户了解BSD如何工作。理想情况下，典型的macintosh用户甚至不知道BSD在那里。作为＆＃34这样的文件夹的徽章; USR＆＃34;和＃34; ETC＆＃34;在磁盘上是尴尬的，我们隐藏在应用程序级别的这些目录和他们的文本，以避免混淆，因为它们在那里并且无法移动或删除。一个想法是将系统文件插入到Mac OS样式系统文件夹中，并使该文件夹对用户不透明。这要求管理系统软件的其他方法，而不是允许用户在此处戳戳，我们仍然存在标准UNIX路径在引导卷的根级别存在的问题。这是我们积极努力改善的静脉内部。</p><p> The original Mac OS had a wonderful feature that applications werekept in one file (though both forks of that file were sometimes used).You could therefore drag one icon from your install floppy onto yourhard disk or another floppy, and you were done. You could drag theone icon to the trash, and get rid of that program. Over the years,we have gotten into a model where there are several files to dealwith. Most of the application files are kept in one folder, butapplications also put various files into parts</p><p> 原始Mac OS具有一个精彩的功能，即应用程序是一个文件中的应用程序（虽然有时使用该文件的两个叉子）。因此，您可以将一个图标从安装软盘上拖到您的磁盘或其他软盘上。您可以将图标拖到垃圾桶，并摆脱该程序。多年来，我们已经进入了一个有几个文件来处理的模型。大多数应用程序文件都保存在一个文件夹中，但是也将各种文件放入零件中</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.usenix.org/legacy/publications/library/proceedings/usenix2000/invitedtalks/sanchez_html/sanchez.html">https://www.usenix.org/legacy/publications/library/proceedings/usenix2000/invitedtalks/sanchez_html/sanchez.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/unix/">#unix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>