<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不可变化改变了一切 Immutability Changes Everything</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Immutability Changes Everything<br/>不可变化改变了一切 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 17:33:04</div><div class="page_narrow text-break page_content"><p>January 20, 2016   Volume 13, issue 9       There is an inexorable trend toward storing and sending immutable data. We  need immutability to coordinate at a distance, and we  can afford immutability as storage gets cheaper. This article is an  amuse-bouche sampling the repeated patterns of computing that leverage immutability. Climbing up and down the compute stack really does yield a sense of déjà vu all over again.</p><p>2016年1月20日第13卷，第9期有一个不可避免的趋势，可以存储和发送不可改变的数据。我们需要在远处协调不可变，我们可以负担不变，因为储存变得更便宜。本文是一种amuse-bouche采样，重复的计算模式可以利用不可变节性。上下爬上计算堆栈真的确实可以再次产生了一定程度的Déjàvu。</p><p> It wasn&#39;t that long ago that computation was expensive, disk storage was expensive, DRAM (dynamic random access memory) was expensive, but coordination with latches was cheap. Now all these have changed using cheap computation (with many-core), cheap commodity disks, and cheap DRAM and SSDs (solid-state drives), while coordination with latches has become harder because latch latency loses lots of instruction opportunities. Keeping immutable copies of lots of data is now affordable, and one payoff is reduced coordination challenges.</p><p> 它很久以前那很久以前那很昂贵，磁盘存储价格昂贵，DRAM（动态随机存取存储器）昂贵，但与闩锁的协调很便宜。现在所有这些都使用廉价计算（有许多核心），廉价的商品磁盘和廉价的DRAM和SSD（固态驱动器）发生了变化，而与锁存器的协调变得更加困难，因为锁存延迟失去了大量的指导机会。保持不变的副本，现在价格实惠，一个支付减少了协调挑战。</p><p>   Storage is increasing as the cost per terabyte of disk keeps dropping. This means a lot of data can be kept for a long time. Distribution is increasing as more and more data and work are spread across a great distance. Data within a data center seems &#34;far away.&#34; Data within a many-core chip may seem &#34;far away.&#34; Ambiguity is increasing when trying to coordinate with systems that are far away—more stuff has happened since you&#39;ve heard the news. Can you take action with incomplete knowledge? Can you wait for enough knowledge?</p><p>   由于磁盘的每磅成本，存储越来越多地增加。这意味着很多数据可以保持很长时间。随着越来越多的数据和工作越来越多，分布正在增加。数据中心内的数据似乎＆＃34;遥远。＆＃34;许多核心芯片内的数据可能看起来＆＃34;遥远。＆＃34;在尝试与远离远方的系统协调时，歧义正在增加 - 自从您听到新闻以来发生了更多的东西。你能采取不完整的知识吗？你能等到足够的知识吗？</p><p>   As various technological areas have evolved, they have responded to these trends of increasing storage, distribution, and ambiguity by using immutable data in some very fun ways. This article explores how apps use immutability in their ongoing work, how they generate immutable data sets for later offline analysis, how SQL can expose and process immutable snapshots, and how massively parallel big-data work relies on immutable data sets. This leads to looking at the ways in which semantically immutable data sets may be altered while remaining immutable.</p><p>   随着各种技术领域的发展，他们通过以一些非常有趣的方式使用不可变数据，回应了增加存储，分配和歧义的这些趋势。本文探讨了应用程序在持续的工作中使用不变性，如何为稍后的离线分析生成不可变数据集，SQL如何暴露和处理不可改变的快照，以及大规模并行的大数据工作如何依赖于不可变数据集。这导致在剩余不变的同时可以改变语义不可变数据集的方式。</p><p> Next, the article considers how updatability is layered atop the creation of new immutable files via techniques such as LSF (log-structured file system), COW (copy-on-write), and LSM (log-structured merge-tree). How do replicated and distributed file systems depend on immutability to eliminate anomalies? Hardware folks have joined the party by leveraging these tricks in SSDs and HDDs (hard-disk drives). Immutability is a key architectural concept at many layers of the stack, as shown in figure 1.</p><p> 接下来，该文章考虑了如何通过LSF（日志结构化文件系统），COW（编写写入）和LSM（Log-Structureed Merge-Tree）等技术在创建新的Upcutable文件中如何分层更新性。复制和分布式文件系统如何依赖于消除异常的不变性？硬件人士通过利用SSD和HDD（硬盘驱动器）利用这些技巧加入了派对。不变性是堆叠多层的关键建筑概念，如图1所示。</p><p>     Many kinds of computing are append-only. This section looks at some of the ways this is commonly accomplished.</p><p>     只有许多类型的计算都是附录的。本节看一些常用的方式。</p><p>   In append-only computing, observations are recorded forever (or for a long time). Derived results are calculated on demand (or periodically precalculated).</p><p>   在仅附加计算中，将永远录制观察（或长时间）。导出的结果按需计算（或定期预先计算）。 </p><p> This is similar to a DBMS (database management system) in which transaction logs record all the changes made to the database. High-speed appends are the only way to change the log. From this perspective, the contents of the database hold a caching of the latest record values in the logs. The truth is the log. The database is a cache of a subset of the log. That cached subset happens to be the latest value of each record and index value from the log.</p><p>这类似于DBMS（数据库管理系统），其中事务日志记录对数据库所做的所有更改。高速附录是更改日志的唯一方法。从这个角度来看，数据库的内容载有日志中最新记录值的缓存。事实是日志。数据库是日志子集的缓存。缓存的子集恰好是来自日志的每个记录和索引值的最新值。</p><p>   Accountants don&#39;t use erasers; otherwise they may go to jail. All entries in a ledger remain in the ledger. Corrections can be made but only by making new entries in the ledger. When a company&#39;s quarterly results are published, they include small corrections to the previous quarter. Small fixes are OK. They are append-only, too.</p><p>   会计师不使用橡皮擦;否则他们可能会入狱。分类帐中的所有条目都保留在分类帐中。可以通过在分类帐中制作新条目来进行更正。当一家公司＆＃39;季度结果发表时，它们包括对上一季度的小规则。小修复很好。他们也是附加的。</p><p> Some entries describe  observed facts. For example, receiving a debit or credit against a checking account is an observed fact. Some entries describe  derived facts, meaning that, based on the observations, something new can be calculated. For example, amortized capital expenses based upon a rate and a cost are derived facts. Another example is the current bank account balance with applied debits and credits.</p><p> 有些条目描述了观察到的事实。例如，接收借记或反对支票账户的信贷是观察到的事实。有些条目描述了派生事实，这意味着基于观察，可以计算新的东西。例如，基于速率和成本的摊销资本开支是导出的事实。另一个例子是当前银行账户余额与应用借记和信用。</p><p>   Single-master computing means changes are ordered somehow. The order can come from a centralized master or some Paxos-like 11 distributed protocol providing serial ordering. Changes are semantically applied one at a time and are layered over their predecessors. New values supersede old ones. The granularity of this may be a set of records in a relational store or a new version of a document. Distributed single-master computing means there is a space of data (relational records, documents, export files, and more) that emanates from one logical location with new versions over time.</p><p>   单程计算意味着以某种方式排序更改。订单可以来自集中式主站或一些类似PAXOS的11个分布式协议，提供串行排序。在语义上一次应用更改，并以其前辈分层。新价值取代旧的值。这方面的粒度可以是关系存储中的一组记录或文档的新版本。分布式的单主计算意味着存在一个数据（关系记录，文档，导出文件等），它从一个逻辑位置发出新版本随时间的新版本。</p><p>   Before telephones, people used messengers—often kids walking through town to deliver the message. Alternatively, the postal service delivered the messages, which took a long time. Sometimes people used fancy forms with many layers, each a different color. They had multiple sections on the page. Each participant filled out a section (pressing hard with the pen), then tore off the back page of the form and filed it. Each participant got the data needed and added more data to the form. Earlier sections could not be updated; data could only be appended to the end.</p><p>   在电话之前，人们使用的使者 - 经常孩子们走路穿过城镇交付信息。或者，邮政服务提供了很长时间的消息。有时人们使用幻想形式有许多层，每个颜色都有不同的颜色。页面上有多个部分。每个参与者都填写了一节（用笔按压），然后从表格的后页上撕下并提交它。每个参与者都有所需的数据并将更多的数据添加到表单中。早期的部分无法更新;数据只能附加到最后。</p><p> Before computers, workflow was frequently captured in paper forms with multiple parts on the form and multiple pages (e.g., &#34;Fill out Part 3 and keep the goldenrod page from the back&#34;). This &#34;distributed computing&#34; was append-only. New messages were new additions to the form—each was a version and each was immutable. You were never allowed to overwrite what had been written.</p><p> 在计算机之前，工作流程经常以纸张形式捕获，表单上的多个部分和多页（例如，＆＃34;填写第3部分，并从后面＆＃34保留GoldenRod页面;）。这个＆＃34;分布式计算＆＃34;仅限申请。新消息是表格的新消息 - 每个都是一个版本，每个都是不可变的。你永远不会被允许覆盖写的东西。</p><p>   Surprisingly (to database old-timers), not all data is kept in relational database systems. This section (based on an earlier paper 7) discusses some of the implications of unlocking data.</p><p>   令人惊讶的是（对于数据库旧计时器），并非所有数据都保存在关系数据库系统中。本节（基于早期文件7）讨论了解锁数据的一些含义。 </p><p>   Data on the inside refers to what is kept and managed by a classic relational database system and its surrounding application code. Sometimes this is referred to as a  service.</p><p>内部的数据是指由经典关系数据库系统及其周围的应用程序代码保存和管理的内容。有时这被称为服务。</p><p> Data on the inside lives in a transactional world with changes applied in a serializable fashion (or something close to that).</p><p> 内部的数据生活在交易世界中，以可序列化的方式应用的变化（或接近该问题）。</p><p>   Data on the outside is prepared as messages, files, documents, and/or Web pages. These are sent out from a service into the world. It is also possible that outside data has been created by some other mechanism than one using databases.</p><p>   外部的数据被准备为消息，文件，文档和/或网页。这些是从一个服务中发送到世界的服务。除了使用数据库之外，还可以由其他机制创建外部数据。</p><p>   * Is unlocked. It is not locked in the database. A copy is extracted and sent outside.</p><p>   *被解锁。它未锁定在数据库中。提取并发送外部副本。</p><p> * Has identity. When sent outside, these files, documents, and messages have a unique identity (perhaps a URL).</p><p> *有身份。在外面发送时，这些文件，文档和邮件具有唯一的标识（可能是URL）。</p><p> * May be versioned. Updates aren&#39;t updates but new versions with a new unique identifier.</p><p> *可能是版本的。更新Aren＆＃39; t更新但具有新唯一标识符的新版本。</p><p>   There are deep differences in the representation, meaning, and usage of inside data versus outside data. Increasingly, data is being kept as outside (immutable) data (see figure 2).</p><p>   内部数据与外部数据的表示，含义和使用情况存在深刻差异。越来越多地，数据被视为外部（不可变）数据（参见图2）。 </p><p>    The data set is a collection of data with a unique ID. Some data sets have structures that look like a number of tables with schema. How are these data sets referenced by a relational database, and how do relational operators span both the DBMS and data set?</p><p>数据集是具有唯一ID的数据集合。某些数据集具有与具有架构的多个表的结构。如何由关系数据库引用的这些数据集，以及关系运算符如何跨越DBMS和数据集？</p><p>   A data set is a fixed and immutable set of tables. The schema for each table is captured in the data set. The contents of each table are captured when the data set is created. Since the data set is immutable, it is created, may be consumed for reading, and then deleted. Data sets may be relational, or they may have some other representation such as a graph, a hierarchy such as JSON (JavaScript Object Notation), or any other representation (figure 3). A data set is a logical set of immutable tables along with its schema.</p><p>   数据集是一个固定和不可变的表组。在数据集中捕获每个表的模式。创建数据集时捕获每个表的内容。由于数据集是不可变的，因此创建它，可以消耗读取，然后删除。数据集可以是关系，或者它们可以具有一些其他表示，例如图形，诸如JSON（JavaScript对象符号）或任何其他表示的层次结构（图3）。数据集是一个逻辑集的不可变形表以及其模式。</p><p>    Data sets may be referenced by an RDBMS (relational DBMS). The metadata is visible to the DBMS. The data can be accessed for a read, even though it may not be updated. The data set may be semantically present within the relational system even if it is physically stored elsewhere. Because the data set is immutable, there&#39;s no need for locking and no worries about controlling updates.</p><p>    数据集可以由RDBMS（关系DBMS）引用。 DBMS可见元数据。即使可能无法更新，也可以访问数据。即使它物理存储在其他地方，也可以在关系系统内进行语义上存在数据集。因为数据集是不可变的，所以没有必要锁定，并且不担心控制更新。</p><p>   A functional calculation takes a set of inputs and predictably creates a set of outputs. This can happen with a query against locked or snapshot data in a relational database, and it can happen on a big-data MapReduce-style system. In both cases, there is still an unchanging collection of data. With snapshots or some form of isolation, database data becomes semantically immutable for the duration of the calculation. With big-data calculations, the inputs are typically stored in GFS (Google File System) or HDFS (Hadoop Distributed File System) files.</p><p>   功能计算需要一组输入，并且可预测地创建一组输出。这可能在关系数据库中的锁定或快照数据的查询发生，并且可以在大数据MapReduce风格系统上发生。在这两种情况下，仍然存在不变的数据集合。通过快照或某种形式的隔离，数据库数据对于计算持续时间来说是语义上的。通过大数据计算，输入通常存储在GFS（Google文件系统）或HDFS（Hadoop分布式文件系统）文件中。</p><p> There&#39;s no semantic obstacle to doing JOINs across data stored inside a relational database and data stored in external data sets. Locking (or snapshot isolation) provides a version of the relational database, which may be joined. Named and frozen data sets may be joined with relational data (see figure 4). You can meaningfully apply relational operations across data held in a DBMS and data held in immutable data sets.</p><p> 在那里没有语义障碍，可以在存储在关系数据库中的数据和存储在外部数据集中的数据中进行连接。锁定（或快照隔离）提供了可以加入的关系数据库的版本。命名和冻结数据集可以与关系数据加入（参见图4）。您可以将在DBMS中保存的数据和在不可变数据集中保存的数据中有意义地应用关系。</p><p>  In some ways, the ability to work across immutable data sets and relational databases is surprising. An immutable data set is defined with an identity and an optional version. Its schema, which describes the shape and form of the data set at the time of its creation, is descriptive, whereas the schema held in the RDBMS is prescriptive.</p><p>  在某些方面，在不可变数据集和关系数据库中工作的能力令人惊讶。使用标识和可选版本定义不可改变的数据集。它的架构，其描述了在创建时的数据集的形状和形式，是描述性的，而在RDBMS中保持的模式是规范性的。</p><p> This tailoring of the schema to meld the two connects the schema of the data set (describing its data when written) with the schema of the RDBMS (describing its data as of the snapshot). Also, the JOINs and other relational operators must necessarily combine the contents of the data set as interpreted as a set of relational tables. This sidesteps the notion of identity within the data set and focuses exclusively on the tables as interpreted as a set of values held within rows and columns.</p><p> 该图案剪裁为融合的模式，两个连接数据集的模式（写入时写入其数据）与RDBMS的架构（描述其作为快照的数据）。此外，联接和其他关系运算符必须必须将数据集的内容组合为解释为一组关系表。这一个申请数据集中的标识概念，并专注于表格，以解释为在行和列中保持的一组值。 </p><p>   A consumer may see data sets as immutable even if they change under the covers.</p><p>即使在封面下改变，消费者可能会将数据集视为不可变。</p><p>   A data set is semantically immutable. It has a set of tables, rows, and columns. It may also have semi-structured data (e.g., JSON). It may have application-specific data in a proprietary format.</p><p>   数据集是语义上不可变的。它有一组表，行和列。它也可能具有半结构化数据（例如，JSON）。它可能具有专有格式的特定于应用程序的数据。</p><p> Data sets may be defined as a SELECTION, PROJECTION, or JOIN over previously existing data sets. Semantically, all that data is now a part of the new data set.</p><p> 数据集可以被定义为选择，投影或加入以前现有的数据集。语义上，所有数据现在都是新数据集的一部分。</p><p> What&#39;s important about a data set is that it appears to be unchanging from the standpoint of the reader.</p><p> 什么＆＃39;对于数据集重要的是，从读者的角度看起来似乎不变。</p><p>   Data sets are semantically immutable but can be physically changed. You can add an index or two. It&#39;s OK to denormalize tables to optimize for read access. Data sets can be partitioned and the pieces placed close to their readers. A column-oriented representation of a data set may also make sense.</p><p>   数据集是语义上不可变的，但可以物理变化。您可以添加索引或两个。它可以为Denormalize表提供优化读取访问。数据集可以分区，并且靠近读者的部分。定向列的数据集表示也可能有意义。</p><p> You can make a copy of a table with far fewer columns to optimize for quick access (a skinny table). The column values can be left in both the skinny table and fat table.</p><p> 您可以制作一个表的副本，列较少，以优化快速访问（一个瘦桌）。列值可以留在瘦桌子和脂肪表中。</p><p> By watching and monitoring the read usage of a data set, you may realize that new optimizations (e.g., new indices) are possible.</p><p> 通过观察和监视数据集的读取使用，您可以意识到新的优化（例如，新索引）是可能的。 </p><p>   Immutability is the backbone of big data. Massively parallel computations are based on immutable inputs and functional calculations. MapReduce 3 and Dryad 9 both take immutable files as input. The work is cut into pieces, each with immutable input. This functional calculation (using immutable inputs) is idempotent, making it possible to fail and restart. Immutability is the backbone of big data. MapReduce performs functional computations over immutable data to create immutable outputs. Failure and restart, so essential to reliable big data, are based on the idempotent nature of functional computation over immutable inputs.</p><p>不变性是大数据的骨干。大规模并行计算基于不可变输入和功能计算。 MapReduce 3和Dryad 9都将不可变文件作为输入。将工作切成碎片，每个都具有不变的输入。此功能计算（使用不可变输入）是幂等的，使得可以失败并重新启动。不变性是大数据的骨干。 MapReduce通过不可变数据执行功能计算以创建不可变输出。失败并重新启动，这对于可靠的大数据至关重要，基于功能计算的幂等性质。</p><p>   Data sets show an immutable semantic prism, even if the underlying representation is augmented or completely replaced. The King James Bible is, character for character, immutable—even when it is printed in a different font; even when digitized; even when accompanied by different pictures.</p><p>   数据集显示了一个不可变的语义棱镜，即使基础表示是增强或完全替换的。国王詹姆斯圣经是，角色的性格，即使是在不同的字体上印刷;即使在数字化时;即使伴随着不同的图片。</p><p> Is a data set changed if there is a lossless transformation to a new schema representation? Can the new address field have more capacity? Can the enum values be mapped to a new underlying representation? Can the data be mapped from UTF-8 to UTF-16 encoding?</p><p> 如果对新架构表示有没有变换，则数据集是更改的吗？新地址字段是否可以具有更多容量？枚举值是否可以映射到新的底层表示？数据是否可以从UTF-8映射到UTF-16编码？</p><p> Having the right bits is not enough. You have to know how to interpret them. For example, &#34;President Bush&#34; had a different meaning in 1990 than in 2005. The word &#34;napkin&#34; is interpreted differently in the US and the UK.</p><p> 具有正确的位是不够的。你必须知道如何解释它们。例如，＆＃34;布什总统＆＃34; 1990年的含义不同于2005年。单词＆＃34;餐巾纸＆＃34;在美国和英国被解释不同。</p><p>   When an immutable data set is created, the semantics of the data may not be changed. The contents may only be described as they are at the time the data set is created.</p><p>   创建不可变数据集时，可能不会更改数据的语义。仅内容只能描述它们在创建数据集时。</p><p> Most programmers are used to SQL DDL (Data Definition Language) supporting dynamic changes in the metadata for their tables. This happens at a transaction boundary and can prescribe a new schema for the existing data. SQL DDL can be thought of as  prescriptive metadata since it is prescribing the representation (which may change). Immutable data sets have  descriptive metadata that explains what&#39;s there.</p><p> 大多数程序员用于SQL DDL（数据定义语言）支持其表的元数据中的动态变化。这发生在交易边界处，并且可以为现有数据规定新的架构。 SQL DDL可以被认为是规范性元数据，因为它是规定表示的（可能会改变）。不可变数据集具有描述性元数据，用于解释有哪些＆＃39;</p><p> Of course, it is possible to create new data sets that refer to one or more existing data sets in order to create a new representation of their data. Each new data set has a unique ID. There&#39;s nothing wrong with having a data set implemented by reference and not by value.</p><p> 当然，可以创建引用一个或多个现有数据集的新数据集，以便创建其数据的新表示。每个新的数据集都有一个唯一的ID。在其中通过引用实现的数据集而不是按值实现的数据集没有错。 </p><p>   The goal of normalization is to eliminate update anomalies. When the data is not stored in a normalized fashion, updates might yield unpleasant results. The classic example is an imperfectly normalized table in which each employee has his or her manager&#39;s name and phone number. This makes it very hard to update the manager&#39;s phone number since it is stored in many places. Normalization is very important in a database designed for updating.</p><p>标准化的目标是消除更新异常。当数据未以归一化方式存储时，更新可能会产生令人不快的结果。经典榜样是一个不完美的归一下表，其中每个员工都有他或她的经理＆＃39;姓名和电话号码。这使得更新管理员和＃39; S电话号码很难，因为它存储在许多地方。归一化在设计用于更新的数据库中非常重要。</p><p> Normalization is not necessary in an immutable data set, however. The only reason to normalize immutable data sets may be to reduce the storage necessary for them. On the other hand, denormalized data sets may be easier and faster to process as inputs to a computation.</p><p> 然而，在不可变数据集中不需要归一化。正常化不变数据集的唯一原因可能是减少它们所需的存储。另一方面，Denormized数据集可能更容易且更快地处理计算到计算的输入。</p><p>   Each version is immutable. This section looks first at multiversion concurrency control; then techniques such as LSM that provide a semantic of change within a transactional space while generating immutable data that describes the state of these changes; finally, it looks at the world through the lens of COW, in which high-performance updates are implemented by writing new immutable data.</p><p>   每个版本都是不可变的。本节首先在多边形并发控制中查看;然后，如LSM在事务空间内提供语义的技术，同时生成描述这些变化状态的不可变数据;最后，它通过母牛的镜头看世界，其中通过编写新的不可变数据来实现高性能更新。</p><p>   Versions should have immutable names. Other than the first version of something, a new version captures a replacement for or an augmentation of an earlier version. A  linear version history is sometimes referred to as being strongly consistent: one version replaces another; there&#39;s one parent and one child; each version is immutable; each version has an identity. The alternative to linear version history is a DAG (directed acyclic graph) of version history, in which there are many parents and/or many children. This is sometimes called eventual consistency.</p><p>   版本应该有不可变的名称。除了第一个版本的东西之外，一个新版本捕获了更替换的或增强早期版本的替代。线性版本历史有时被称为强烈一致：一个版本替换另一个版本;有一个父母和一个孩子在那里。每个版本都是不可变的;每个版本都有一个身份。线性版本历史的替代方案是版本历史的DAG（定向非循环图），其中有许多父母和/或许多孩子。这有时被称为最终的一致性。</p><p>   Strongly consistent, or ACID (atomicity, consistency, isolation, durability), transactions appear as if they run in a serial order. This is sometimes called serializability. 2</p><p>   强烈一致，或酸（原子学，一致性，隔离，耐用性），事务显示好像它们以串行顺序运行。这有时被称为序列化。 2</p><p> The database changes version by version. Transaction T1 is a version and later transaction T2 is a version. Transactions layer new versions of record and index changes atop earlier versions. The new versions can be captured as snapshots of the entire database (although this wouldn&#39;t result in high performance).</p><p> 数据库按版本更改版本。事务T1是一个版本，稍后的事务T2是一个版本。 TAXTALLELED的记录和索引的新版本和索引在早期版本上更改。新版本可以捕获为整个数据库的快照（虽然这不会导致高性能）。</p><p> Alternatively, the new version can be captured as changes to the previous version. In this way, a key-value store can be built, and a relational database can be built atop a key-value store. Records are deleted by adding tombstones. Changing the database is done by adding new records to the key-value store.</p><p> 或者，可以将新版本捕获为对以前版本的更改。以这种方式，可以构建密钥值存储，并且可以在键值存储器上构建关系数据库。通过添加Tombstones删除记录。更改数据库是通过向键值存储添加新记录来完成的。 </p><p> If a timestamp is added to each new version, it is possible to show the state of the database at a given point in time. This allows the user to navigate the state of the database to any older version. Ongoing work can see a stable snapshot of a version of the database.</p><p>如果将时间戳添加到每个新版本中，则可以在给定的时间点显示数据库的状态。这允许用户将数据库的状态导航到任何旧版本。正在进行的工作可以看到数据库版本的稳定快照。</p><p>   LSM presents a façade of change atop immutable files. With an LSM tree, 15 changes to the key-value store are accomplished by writing new versions of the affected records. These new versions are logged to an immutable file. Periodically, the new versions of the key values are sorted by key and written to an immutable file known as a Level 0 file within the LSM tree. Level 0 files are merged into a collection of Level 1 files (typically 10 Level 1 files, each containing one-tenth of the key range). Similarly, Level 1 files are merged with Level 2 files on a 10-to-1 basis. As you move down the LSM tree, each level has 10 times as many files. Reading a record typically involves searching one file per level. As the LSM files merge, new immutable files with new identities can be written.</p><p>   LSM在不可变档案上呈现了一个外观的变化。使用LSM树，通过编写新版本的受影响记录来完成对键值存储的15个更改。这些新版本记录到不可变的文件。定期，按键的新版本按键排序，并将其写入称为LSM树中的0个文件的不可变文件。级别0文件合并为级别1级别的集合（通常为10级文件，每个文件，每个文件包含第十个关键范围）。同样，级别1个文件与10到1个文件合并为2级文件。随着LSM树移动，每个级别都有10倍的文件。读取记录通常涉及搜索每个级别的文件。随着LSM文件合并，可以写入具有新标识的新的不可变文件。</p><p>   An LSM tree can create changeable data out of immutable files by performing a COW. The granularity of the copy is typically a key-value pair. For a relational database, this can be a key-value pair for each record or each index entry. The changes are copied into the log and then into the LSM tree (and copied a few more times for merges).</p><p>   LSM树可以通过执行牛来创建不可变形的文件。副本的粒度通常是键值对。对于关系数据库，这可以是每个记录或每个索引条目的键值对。将更改复制到日志中，然后复制到LSM树（并为合并复制几次）。</p><p> High-performance COW happens with logging and classic DBMS performance techniques. The new versions are captured in memory and logged for failure recovery. The identity of each log file is a unique ID, and the log files are immutable. Each new log file can record the history of its preceding log files and even the identity of upcoming log files. Having one of the recent log-file IDs means the entire LSM key-value store can be reconstructed.</p><p> 高性能牛与日志和经典的DBMS性能技术发生。新版本在内存中捕获并记录以进行故障恢复。每个日志文件的标识是唯一ID，日志文件是不可变的。每个新日志文件都可以记录其前面的日志文件的历史记录，甚至是即将到来的日志文件的标识。有一个最近的日志文件ID表示可以重建整个LSM键值存储。</p><p>   Many file systems keep immutable files consisting of immutable blocks. This section explores at a high level the implementation of GFS and HDFS and the implications of what can be done with these files. It discusses the vagaries of files that can be renamed and considers the value of storing immutable data within a consistent hash store.</p><p>   许多文件系统都会保留由不可变块组成的不可变文件。本节探讨了高水平的GFS和HDF的实现以及可以使用这些文件完成的内容的影响。它讨论了可以重命名的文件的变幻莫测，并考虑在一致的哈希商店中存储不可变数据的值。</p><p>   An early example of reifying change through immutability is the log-structured file system. 16 In this wonderful invention, file-system writes are always appended to the end of a circular buffer. Occasionally, enough metadata to reconstruct the file system is added to the circular buffer. Old data must be copied forward so it is not overwritten.</p><p>   通过不变性改变更改的早期示例是对数结构的文件系统。 16在这本精彩的发明中，文件系统写入总是附加到循环缓冲区的末尾。偶尔，要重建文件系统的足够重建的元数据被添加到循环缓冲区。必须向前复制旧数据，以便未被覆盖。</p><p> Log-structured file systems have some interesting performance characteristics, both good and bad. Today they are an important technique. As technology trends continue to move in the direction of recent years, they will become even more important.</p><p> 日志结构的文件系统具有一些有趣的性能特征，既好又坏。今天他们是一个重要的技术。随着技术趋势在近年来的方向上继续移动，它们将变得更加重要。 </p><p>   GFS, 5 HDFS, 1 and others offer highly available files. Each file is a bunch of blocks (also called  chunks). The file consists of a file name and a description of the blocks needed to provide a bytestream. Each block is replicated in the cluster for durability and high availability. They are typically replicated three times over different fault zones in the data center.</p><p>GFS，5个HDFS，1和其他提供高度可用的文件。每个文件都是一堆块（也称为块）。该文件由文件名和提供交叉流所需的块的描述组成。每个块都在群集中复制以进行耐用性和高可用性。通常在数据中心的不同故障区域上复制三次。</p><p> Each file is immutable and (typically) single-writer. The file is created, and one process can append to it. The file lives for a while and is eventually deleted. Multiwriters are difficult, and GFS had some challenges with this. 13</p><p> 每个文件都是不可变的，（通常）单个编写器。创建该文件，一个进程可以附加到它。文件生存了一段时间，并最终删除。多版本很难，GFS对此有一些挑战。 13.</p><p> Immutable files and immutable blocks empower this replication. The file system has no concept of a change to a complete file. Each block&#39;s immutability allows it to be easily replicated without any update anomalies because it doesn&#39;t get updated.</p><p> 不变的文件和不可变块授权此复制。文件系统对完整文件没有更改的概念。每个块＆＃39; s的不可动提器允许它在没有任何更新异常的情况下轻松复制，因为它没有更新。</p><p>   An immutable file has an identity and contents, neither of which can change. You can copy an immutable file whenever and wherever you want and share the immutable copies across users. As long as you manage reference counts (so you know when it&#39;s OK to delete it), you can use one copy of the file to share across many users. You can distribute immutable files wherever you want. With the same identity and same contents, the files are location independent.</p><p>   一个不可变的文件具有身份和内容，也不能改变。您可以随时随地复制不可变文件并在任何用户身边分享用户的不可变副本。只要您管理参考计数（所以您知道它何时何时删除它），您可以使用文件的一个副本来分享许多用户。您可以随时随地分发不可变的文件。使用相同的身份和相同的内容，文件是独立的。</p><p>   GFS and HDFS both provide immutable files. Immutable blocks (chunks) a</p><p>   GFS和HDFS都提供不变的文件。不可变块（块）a</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=2884038">https://queue.acm.org/detail.cfm?id=2884038</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/变化/">#变化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>