<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在GNU sed中模拟regexp查找环境</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在GNU sed中模拟regexp查找环境</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 20:00:51</div><div class="page_narrow text-break page_content"><p>This  stackoverflow Q&amp;A got me thinking about various ways to construct a solution in  GNU sed if lookarounds are needed.</p><p>这个堆栈溢出Q&amp；A让我思考在需要查找的情况下用GNU sed构建解决方案的各种方法。</p><p> Only single line (with newline as the line separator) processing is presented here. Equivalent lookaround syntax with  grep -P or  perl is also shown for comparison. Cases where multiple lines and/or ASCII NUL characters are present in the pattern space is left as an exercise.</p><p>这里只介绍单行(以换行符作为行分隔符)处理。还显示了使用grep-P或Perl的等效Lookround语法，以供比较。模式空间中存在多行和/或ASCII NUL字符的情况留作练习。</p><p>    Here, you only need to decide whether the input line has to be matched or not.  sed supports grouping commands inside  {} that should be executed only if a filtering condition is matched. The condition could be negated by adding a  ! character. In this way, you can emulate chaining of multiple positive and/or negative lookaround conditions.</p><p>在这里，您只需要决定是否必须匹配输入行。SED支持对{}中的命令进行分组，只有在匹配筛选条件时才应执行这些命令。条件可以通过添加！性格。通过这种方式，您可以模拟多个正向和/或负向环视条件的链接。</p><p> $ cat items.txt 1 , 2 , 3 , 4 apple= 50  ;per kga,b,c,d;foo xyz3 # filter lines containing a digit character followed by a ; character# lookaround isn&#39;t needed here# same as: grep &#39;[0-9].*;&#39; or grep -P &#39;\d(?=.*;)&#39; $ sed  - n  &#39;/[0-9].*;/p&#39;  items.txtapple= 50  ;per kg # filter lines containing both digit and ; characters in any order# same as: grep -P &#39;^(?=.*;).*\d&#39; $ sed  - n  &#39;/;/{ /[0-9]/p }&#39;  items.txtapple= 50  ;per kg;foo xyz3 # filter lines containing both digit and ; characters# but not if the line also contains character a# same as: grep -P &#39;^(?!.*a)(?=.*;).*\d&#39; $ sed  - n  &#39;/a/!{ /;/{ /[0-9]/p } }&#39;  items.txt;foo xyz3</p><p>$cat items.txt 1，2，3，4 apple=50；per KGA，b，c，d；foo xyz3#包含数字字符后跟a；character#Lookround isn&#39；此处不需要的字符的筛选行#与：grep&#39；[0-9].*；&#39；或grep-p&#39；\d(？=.*；)&#39；$sed-n&39；/[0-9]。*；/p&#39；items.txtapple=50；Per kg#筛选任意顺序同时包含数字和；字符的行#Same as：grep-P&#39；^(？=.*；).*\d&#39；$sed-n&#39；/；//{/[0-9]/p}&#39；items.txtapple=50；Per kg；foo xyz3#筛选同时包含数字和；字符的行#，但如果该行还包含字符a#Same as：grep-P&#39；^(？！.*a)(？=.*；).*\d&#39；$sed-n&#39；/a/！{/；/{/[0-9]/p}}&#39；items.txt；foo xyz3。</p><p> For some cases, multiple condition check like the previous examples is not enough. For example, filter a line if it contains  par as long as  cart isn&#39;t present later in the line. Presence of  cart earlier in the line shouldn&#39;t affect the outcome. In such cases, you can first change the input line to add a newline character wherever  cart is present and then construct a condition such that it depends on the newline character instead of  cart. If a match is found, delete all the newline characters and then print the line.</p><p>对于某些情况，像前面的示例那样的多个条件检查是不够的。例如，只要购物车不在后面的行中出现，就可以过滤包含PAR的行。出现在队伍前面的购物车应该不会影响结果。在这种情况下，您可以首先更改输入行，以便在出现Cart的地方添加换行符，然后构造一个条件，使其依赖于换行符，而不是Cart。如果找到匹配项，请删除所有换行符，然后打印该行。</p><p> $ s= &#39;par carted spare cart park city&#39; # same as: grep -P &#39;par(?!.*cart)&#39; $ echo  &#34;$s&#34;  |  sed  - n  &#39;s/cart/\n&amp;/g; /par[^\n]*$/{ s/\n//g; p }&#39; par carted spare cart park city</p><p>$s=&39；par购物车备用车公园城市#同：grep-p&39；par(？！.*cart)&#39；$ECHO&#34；$s&#34；|sed-n&39；s/cart/\n&amp；/g；/par[^\n]*$/{s/\n//g；p}&#39；par购物车备用购物车公园城市。</p><p> Newline is a safe character to choose for default line by line processing, as  sed removes it from the pattern space. If you are processing a pattern space that contains newline character (for example:  -z option,  N command, etc), then you can still perform this trick as long as you know a character that is guaranteed to be absent from the input data.</p><p>换行符是默认逐行处理的安全字符，因为sed会将其从模式空间中删除。如果您正在处理包含换行符的模式空间(例如：-z选项、N命令等)，那么只要您知道输入数据中不存在某个字符，您仍然可以执行此技巧。</p><p>  In previous section, you saw how to modify input line with newline character to make it easier to construct a lookaround condition. This trick comes in handy for substitution as well. However, for search and replace cases, you also need to emulate zero-width nature of lookarounds. To achieve this, you can make use of  t command to construct a loop that performs substitution as long as a match is found. See my chapter on  Control structures for more details about branching commands in  GNU sed.</p><p>在上一节中，您了解了如何使用换行符修改输入行，以便更容易地构造Lookround条件。这个小窍门在替换时也派上了用场。但是，对于搜索和替换情况，您还需要模拟环视的零宽度特性。要实现这一点，可以使用t命令构造一个循环，只要找到匹配项就执行替换。有关GNU sed中分支命令的更多详细信息，请参阅我关于控制结构的章节。</p><p> Here&#39;s an example of looping. Aim is to delete  fin from the given input recursively.</p><p>这里有一个循环的例子。目的是递归地从给定输入中删除FIN。</p><p> # manual repetition, assuming count is known $ echo  &#39;coffining&#39;  |  sed  &#39;s/fin//&#39; cofing$ echo  &#39;coffining&#39;  |  sed  &#39;s/fin//; s///&#39; cog # :loop marks the &#39;s&#39; command with label &#39;loop&#39;# tloop will jump to label &#39;loop&#39; as long as the substitution succeeds $ echo  &#39;coffining&#39;  |  sed  &#39;:loop s/fin//; tloop&#39; cog</p><p>#手动重复，假设计数已知$echo&#39；s/fin//#39；cofing$echo&#39；s/fin//#39；|sed&#39；s/fin//；s/&#39；cog#：只要替换成功，循环就会用标签&#39；loop&#39；#tloop跳转到标签&#39；loop&#39；s/fin&#39；cog&#39；s/fin&/；s//&#39；s/#39；cog#：LOOP用标签&#39；loop&#39；#tloop将跳到标签&#39；loop&#39；|sed&#39；：循环s/fin//；tloop&#39；齿轮。</p><p>  Some cases can be solved by performing substitution only if a condition is first satisfied. Note that  {} grouping is optional here.</p><p>有些情况只能在首先满足条件的情况下才能通过执行替换来解决。请注意，这里的{}分组是可选的。</p><p> # same as: perl -ne &#39;print if s/^(?!;).*?\K[ ,].*//&#39; $ sed  - n  &#39;/^;/! s/[ ,].*//p&#39;  items.txt 1 apple= 50 a</p><p>#与：perl-ne&#39；Print if s/^(？！；).*？\K[，].*//&#39；$sed-n&#39；/^；/！S/[，].*//p&#39；items.txt 1 Apple=50 a。</p><p> Change  foo to  [baz] only if it is not followed by a digit character. Note that  foo at the end of string also satisfies this assertion.  foofoo has two matches as the assertion is zero-width in nature, i.e. it doesn&#39;t consume characters. Here, the first step is inserting a newline character between  foo and a digit character. Then change all  foo to  [baz] as long as it is at the end of string or if it isn&#39;t followed by a newline character. Once the loop ends, remove all the newline characters.</p><p>仅当foo后面没有数字字符时，才将foo更改为[baz]。请注意，字符串末尾的foo也满足此断言。Foofoo有两个匹配项，因为断言本质上是零宽度的，即它不使用字符。这里，第一步是在foo和数字字符之间插入换行符。然后将所有foo更改为[baz]，只要它在字符串的末尾，或者如果它后面没有换行符。循环结束后，删除所有换行符。</p><p> $ s= &#39;hey food! foo42 foot5 foofoo&#39; # same as: perl -pe &#39;s/foo(?!\d)/[baz]/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;s/(foo)([0-9])/\1\n\2/g; :a s/foo([^\n]|$)/[baz]\1/; ta; s/\n//g&#39; hey [baz]d! foo42 [baz]t5 [baz][baz]</p><p>嘿，食物！Foo42 Foo5 foofoo&#39；#等同于：perl-pe&#39；s/foo(？！\d)/[baz]/g&#39；$echo&#34；$s&#34；|sed-E&#39；s/(Foo)([0-9])/\1\n\2/g；：a s/foo([^\n]|$)/[baz]\1/；ta；s/\n//g&#39；嘿[baz]d！FOO42[Baz]T5[Baz][Baz]。</p><p> Change  foo to  [baz] only if it is not preceded by  _ character.  foo at the start of string is matched as well.</p><p>仅当foo前面没有_CHARACTER时，才将foo更改为[baz]。字符串开头的foo也是匹配的。</p><p> $ s= &#39;foo _foo 42foofoo&#39; # same as: perl -pe &#39;s/(?&lt;!_)foo/[baz]/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;s/(_)(foo)/\1\n\2/g; :a s/(^|[^\n])foo/\1[baz]/; ta; s/\n//g&#39; [baz] _foo  42 [baz][baz]</p><p>$s=&#39；foo_foo 42foofoo&#39；#等同于：perl-pe&39；s/(？&lt；！_)foo/[baz]/g&#39；$echo&#34；$s&#34；|sed-E&#39；s/(_)(Foo)/\1\n\2/g；：a s/(^|[^\n])foo/\1[baz]/；ta；s/\n//g&#39；[Baz]_foo 42[Baz][Baz]</p><p> Replace  par with  [xyz] as long as  s character is not present later in the input. This assumes that the assertion doesn&#39;t conflict with the search pattern, for example  s will not conflict with  par but would affect if it was  r and  par.</p><p>只要s字符稍后不出现在输入中，就用[xyz]替换PAR。这假设断言不与搜索模式冲突，例如，s不会与PAR冲突，但如果它是r和PAR，则会受到影响。</p><p> $ s= &#39;par spare part party&#39; # same as: perl -pe &#39;s/par(?!.*s)/[xyz]/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;s/s/&amp;\n/g; :a s/par([^\n]*)$/[xyz]\1/; ta; s/\n//g&#39; par s[xyz]e [xyz]t [xyz]ty</p><p>$s=&#39；par备件方&#39；#等同于：perl-pe&#39；s/par(？！.*s)/[xyz]/g&#39；$echo&#34；$s&#34；|sed-E&#39；s/s/&amp；\n/g；：a s/par([^\n]*)$/[xyz]\1/；ta；s/\n//g&#39；par s[xyz]e[xyz]t[xyz]。</p><p> Replace all empty fields with  NA for csv input (assuming no embedded comma, newline characters, etc).</p><p>将CSV输入的所有空字段替换为NA(假设没有嵌入逗号、换行符等)。</p><p> $ s= &#39;,1,,,two,3,,,&#39; # same as: perl -lpe &#39;s/(?&lt;![^,])(?![^,])/NA/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;:a s/,,/,NA,/g; ta; s/^,/NA,/; s/,$/,NA/&#39; NA , 1 , NA , NA ,two, 3 , NA , NA , NA</p><p>$s=&#39；，1，2，3，#相同于：perl-lpe&#39；s/(？&lt；！[^，])(？！[^，])/na/g&#39；$echo&#34；$s&#34；|sed-E&39；：a s/，/，na，/g；ta；s/^，/na，/；S/，$/，NA/&#39；NA，1，NA，NA，2，3，NA，NA，NA。</p><p>    Surround fields with  [] except first and last fields for csv input (assuming no embedded comma, newline characters, etc). With positive lookaround emulation, the modified string may continue to satisfy the matching condition, resulting in infinite looping. In this example, the fields themselves may contain  [] characters, so you cannot use them to prevent infinite loop. The newline character trick comes in handy again.</p><p>使用[]将字段括起来，CSV输入的第一个和最后一个字段除外(假设没有嵌入逗号、换行符等)。使用正向环视仿真时，修改后的字符串可能会继续满足匹配条件，从而导致无限循环。在本例中，字段本身可能包含[]字符，因此不能使用它们来防止无限循环。换行符技巧又派上用场了。</p><p> $ s= &#39;1,t[w]o,[3],f[ou]r,5&#39; # same as: perl -pe &#39;s/(?&lt;=,)[^,]+(?=,)/[$&amp;]/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;:a s/,([^,\n]+),/,\n[\1],/g; ta; s/\n//g&#39; 1 ,[t[w]o],[[ 3 ]],[f[ou]r], 5</p><p>$s=&#39；1，t[w]o，[3]，f[ou]r，5&#39；#等同于：perl-pe&#39；s/(？&lt；=，)[^，]+(？=，)/[$&amp；]/g&#39；$echo&#34；$s&#34；|sed-E&39；：a s/，([^，\n]+)，/，\n[\1]，/g；ta；S/\n//g&#39；1，[t[w]o]，[[3]]，[f[ou]r]，5。</p><p> Add space at word boundaries, but not at the start or end of string. Also, don&#39;t add space if it is already present. Here, negated character class on space character is enough to emulate the assertion.</p><p>在单词边界处添加空格，但不能在字符串的开头或结尾处添加空格。此外，如果已经存在空格，请不要添加。在这里，空格字符上的被否定的字符类足以模拟断言。</p><p> $ s= &#39;total= num1+35*42/num2&#39; # same as: perl -lpe &#39;s/(?&lt;=[^ ])\b(?=[^ ])/ /g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;:a s/([^ ])\b([^ ])/\1 \2/; ta;&#39; total  =  num1  +  35  *  42  /  num2</p><p>$s=&#39；Total=num1+35*42/num2&#39；#等同于：perl-lpe&#39；s/(？&lt；=[^])\b(？=[^])//g&#39；$ECHO&#34；$s&#34；|sed-E&39；：a s/([^])\b([^])/\1\2/；ta；&#39；Total=num1+35*42/num2</p><p> Replace  par with  [xyz] as long as  part occurs as a whole word later in the line. Here, the nature of the modified string itself prevents the possibility of infinite loop.</p><p>只要部分在该行后面作为一个完整的单词出现，就用[xyz]替换par。这里，修改后的字符串本身的性质防止了无限循环的可能性。</p><p> $ s= &#39;par spare part party&#39; # same as: perl -pe &#39;s/par(?=.*\bpart\b)/[xyz]/g&#39; $ echo  &#34;$s&#34;  |  sed  - E  &#39;:a s/par(.*\bpart\b)/[xyz]\1/; ta&#39; [xyz] s[xyz]e part party</p><p>$s=&#39；PAR备件方&#39；#等同于：perl-pe&#39；s/par(？=.*\bpart\b)/[xyz]/g&#39；$echo&#34；$s&#34；|sed-E&39；：a s/par(.*\bpart\b)/[xyz]\1/；ta&#39；[xyz]s[xyz]e部件方。</p><p>  Branching commands and some creative preprocessing of the input can be combined to emulate lookaround assertions in  sed. Given that  Unix utility sed is Turing complete, it&#39;s perhaps not a big surprise. Now, please excuse me, I&#39;ll be busy reaping points on stackoverflow/unix.stackexchange for this edge case ;)</p><p>分支命令和输入的一些创造性预处理可以组合在一起，以模拟sed中的Lookround断言。考虑到Unix实用程序sed是完全图灵的，这也许并不令人惊讶。现在，请原谅，我将忙于在stackoverflow/unix上获取积分。此边缘案例的stackexchange；)</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://learnbyexample.github.io/sed-lookarounds/">https://learnbyexample.github.io/sed-lookarounds/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sed/">#sed</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/regexp/">#regexp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符/">#字符</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>