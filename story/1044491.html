<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SQL中用户定义的顺序非常困难的问题 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SQL中用户定义的顺序非常困难的问题 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-16 09:25:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/1acf2569a6c1f7ff51342162511c9b8f.png"><img src="http://img2.diglog.com/img/2021/1/1acf2569a6c1f7ff51342162511c9b8f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>某些应用程序（例如待办事项列表）需要维护用户定义的项目顺序。挑战在于顺序是任意的，并且在用户重新排列项目时可以更改：</p><p>  本文研究了在SQL中建模情况的最佳方法。我们将研究几种方法，并对每种方法评估三个属性：</p><p> 时空效率。在磁盘上存储行顺序应紧凑，重新排序项目应使用最少的CPU和I / O资源。</p><p> 坚固性。对可以重新订购商品的次数没有实际限制。</p><p> 优雅。该解决方案不需要复杂的PL / pgSQL函数或解析字符串中的数字列表。</p><p>  最自然的第一次尝试是添加一个自动递增的整数列以跟踪每个项目的位置：</p><p>   插入todo（任务）值（使用sql进行实验），（撰写文章），（放松），（重复＆＃ 39;）;从pos asc的todos订单中选择*； / *┌────────────────│任务│pos│├─────────── ────────┼──────┤│尝试sql│1││写文章│2││放松│3││重复│4│└────────── ──────────┴──────┘* / </p><p>更困难的是在列表中插入项目或对现有项目进行重新排序。假设我们要在第2项和第3项之间插入一个新的“编辑文章”任务，这需要将第3项和第一个位置向前移动，并将该项目插入位置3。但是，即使第一步也遇到了问题：</p><p> -将项目3和向前移动一个位置以更新待办事项集pos = pos + 1，其中pos＆gt; = 3; / *错误：23505：重复的键值违反了唯一约束＆＃34; todos_pos_key＆＃34;详细信息：密钥（pos）=（4）已存在。 * /</p><p> 唯一性约束使更新对每个表行的处理时间敏感。在我们的案例中，它尝试将项目3移动到位置4，而没有先将4移动到5。</p><p>  创建表待办事项（任务文本，pos序列，唯一（pos）可推迟的初始推迟-^^^添加此）; -现在我们可以移动列表并开始插入项目；更新待办事项集pos = pos + 1，其中pos＆gt; = 3;插入待办事项（位置，任务）值（3，编辑文章）。 -不要忘了增加序列选择nextval（＆＃39; todos_pos_seq＆＃39;）;承诺;</p><p>  强大的？是。它支持在其他项目之间可靠地插入/移动项目。此外，即使在“读取已提交”隔离级别，并发插入项目也不会导致不一致。 （至少在我的测试中。）</p><p> 优雅？否。该技术需要一系列脆弱的步骤，包括推迟约束和调整顺序。</p><p>  与其使用顺序整数，不如在它们之间留出空间？就像跳过BASIC编程语言中的行号一样，我们也可以跳过表中的位置值在它们之间留出空间。就像是： </p><p>要在其他两个项目之间插入项目，只需使用周围项目平均的位置即可。但是，通过在每个项目之间选择2 ^ 16个空格，我们可以在第一个和下一个项目之间支持不超过16个连续插入。达到此限制后，我们将恢复到以前将项目向前移动的方法。</p><p>  优雅？不，由于混合逻辑，它甚至比以前的方法还要糟糕。</p><p>  如果我们使用浮点或数值而不是int或bigint存储每一行​​的位置怎么办？这将允许在其他元素之间挤压新元素，而不是向前移动项目以腾出空间。这是个主意：</p><p> 创建序列todos_seq;创建表待办事项（任务文本，pos浮动不为null默认nextval（＆＃39; todos_seq＆＃39;），唯一（pos））;插入todo（任务）值（使用sql进行实验），（撰写文章），（放松），（重复＆＃ 39;）;</p><p>   似乎是一个完美的解决方案！但是，浮点数的精度有限。例如，如果我们重复插入1000和1001之间，每次都切成两半，那么到第38次迭代时，它将截断为正好1000：</p><p> i────┬──────────────┐│i│val│├────┼──────────── ────┤│25│1000.0000000298││26│1000.0000000149││27│1000.00000000745││28│1000.00000000373││29│1000.00000000186││30│1000.00000000093││31│1000.00000000047││32│1000.00000000023││33│1000.00000000012│ │34│1000.00000000006││35│1000.00000000003││36│1000.00000000001││37│1000.00000000001││38│1000││39│1000││40│1000│└────┴──────── ────────┘</p><p> 有效率吗？是。一个简单的64位列和一些算法使得将新元素快速插入列表中。 </p><p>好的，所以浮点类型最终会超出精度范围–在SQL中使用数字（又称十进制）类型会怎样？它具有可变大小，可以根据需要增长以存储精确数字。它有多大？让我们问一下数据库：</p><p> 从generate_series（1，21）中选择（1 / power（2，i））：：numeric作为val，pg_column_size（1 / power（2，i）：：numeric）作为sz从i_generate_series（1，21）中作为i; / *┌──────────────────┐│val│sz│├──────── ──────────────────┼│0.5│8││0.25│8││0.125│8││0.0625│8││0.03125│10││0.015625│10 ││0.0078125│10││0.00390625│10││0.001953125│12││0.0009765625│12││0.00048828125│12││0.000244140625│12││0.0001220703125│14││0.00006103515625│12││0.000525517 ││0.00000762939453125│14││0.000003814697265625│14││0.0000019073486328125│14││0.00000095367431640625│14││0.000000476837158203125│16│└────────── ──┴────┘* /</p><p> 它实际上很快达到了12个字节，而实际上最好在0到1之间切入。随着整数部分的增长，数字需要更多的字节。但是，除了磁盘使用以外，这是迄今为止最好的方法。</p><p> 有效率吗？是的，主要是。如果列表重新排列的次数不多，则数字类型超过128位的情况并不常见，并且该列上的大多数操作都是索引比较，而不是算术索引。</p><p> 强大的？是。在很长一段时间内，随着列表的重新排列，数值可能会继续占用更多空间，但是出于所有实际目的，您可以永久重新排列列表。</p><p>  由于我们使用平均值选择中点的方式，浮点型和数值型最终都受到限制。这些中点很快消耗了精度。浮点数根本无法处理，并且数字变得肿。但是，我们可以使用一个数学技巧来获取浮点数大小的数字类型的稳健性。</p><p> 在撰写本文的过程中，我为PostgreSQL创建了一个新的基本类型，称为Rational。可在此处作为数据库扩展名使用。它执行精确的小数运算，我设计为始终每小数精确使用64位，这与PostgreSQL的float类型大小相同。 （我从postgres Wiki获得了灵感。） </p><p>分数比在学校展示的分数有趣得多。非负分数实际上形成了一个二叉树，每个分数（最低限度）出现在一个唯一节点上。</p><p>  这棵“斯特罗科树”以1860年代的独立发现者命名：数学家和钟表匠。如果您想进一步了解该理论，请观看此youtube视频。</p><p> 这棵树可以这样帮助我们：如果您想在特定范围内找到一个分数（a＆lt; x＆lt; b），则遍历Stern-Brocot树-在二元搜索中随便构造它。一旦您击中边界内的节点，请停止。听起来可能很困难，但是pg_rational具有内置的逻辑。</p><p> -＆＃34;理性＆＃34;类型来自扩展名-https://github.com/begriffs/pg_rational创建扩展名pg_rational;创建序列todos_seq为整数；创建表待办事项（任务文本，pos有理不为null默认nextval（＆＃39; todos_seq＆＃39;）：：整数，唯一（pos））;插入todo（任务）值（使用sql进行实验），（撰写文章），（放松），（重复＆＃ 39;）;从pos asc的todos订单中选择*； / *┌────────────────│任务│pos│├─────────── ────────┼──────┤│尝试sql│1/1││写文章│2/1│││放松│3/1││重复│4/1│└─── ────────────────┴─────┘* /</p><p> 就像使用浮点数或整数一样简单！插入新值也很容易：</p><p> 在todo（pos，task）值中插入（rational_intermediate（2，3），＆＃39; edit article＆＃39;）;从pos asc的todos订单中选择*； / *┌────────────────│任务│pos│├─────────── ────────┼──────┤│用sql进行实验│1/1││写文章│2/1││编辑文章│5/2││放松│3/1││重复│ 4/1│└──────────────┴* /</p><p> 这些分数的术语以最低的术语表示，并在每次插入时缓慢增长。例如，您可以从树形图中更早地看到，在1和0之间插入0将生成1 / 2、1 / 3、1 / 4…，这可能会花费很长时间，因为pg_rational中的分子和分母每个都获得32位存储空间。 </p><p>强大的？是。通过重复的列表重新排序，实际上将永远耗尽空间。</p><p>   存储列表顺序的最后一种方法是使用有理类型进行计算，但将结果存储为浮点型。库中的理性可以来回转换：</p><p> -将float转换为有理数选择0.263157894737：：float：：rational; -=＆gt; 5/19-将有理数转换为浮点数select＆＃39; -1 / 2＆＃39 ;:：rational：：float; -=＆gt; -0.5</p><p>  创建序列todos_seq;创建表待办事项（任务文本，pos浮动不为null默认nextval（＆＃39; todos_seq＆＃39;），唯一（pos））;插入todo（任务）值（使用sql进行实验），（撰写文章），（放松），（重复＆＃ 39;）;</p><p> 但是现在使用有理数进行插入，将其保存到列中时将被强制浮动。</p><p> 在todo（pos，task）值中插入（rational_intermediate（2，3），＆＃39; edit article＆＃39;）;从pos asc的todos订单中选择*； / *┌────────────────│任务│pos│├─────────── ────────┼──────┤│尝试sql│1││写文章│2││编辑文章│2.5││放松│3││重复│4│└────── ──────────────┴──────┘* /</p><p> 由Rational_intermediate创建的浮动对象似乎并没有遇到像求平均值那样的精度问题。例如，采用从零到一的重复中间形式，将产生以下模式： </p><p>从generate_series（1，15）AS i中选择（i，i + 1）：：ratt：：rational AS fract，i：：float /（i + 1）：：float AS float / *┌──────┬──────────┐│fract│float│├───────┼───── ──────────────┤│1/2│0.5││2/3│0.666666666666667││3/4│0.75││4/5│0.8││5/6│0.833333333333333│ │6/7│0.857142857142857│││7/8│0.875││8/9│0.888888888888889│││9/10│0.9│││10/11│0.909090909090909││11/12│0.916666666666667││12/13│0.923076923076923││ 13/14│0.928571428571429││14/15│0.933333333333333│││15/16│0.9375│└───────┴──────────── /</p><p>  -多久才能浮起才能分辨出连续的分数？从generate_series（1，100000000）中选择min（i）作为i其中（i：：float /（i + 1.0））=（（i：：float + 1.0）/（i + 2.0））; -=＆gt; 94911150</p><p> 其他分数可能会对浮点表示法造成更大的困难，但是从我有限的实验来看，选择中点的这种方法似乎比取平均值更好。</p><p> 最终，与仅使用pg_rational相比，这种方法有其优点和缺点。磁盘上的空间是相同的。比较浮点数的速度比比较分数的速度快（单个CPU指令与整数项的额外交叉乘法）。但是要找到中间体，首先需要使用迭代算法将浮点数转换为分数。与简单地存储分数相比，这增加了开销。</p><p>     以下是一些额外的注释，可帮助您充分利用扩展程序。</p><p> 将第一项插入为1/1而不是0/1。查找中间值的算法永远不会低于零，因此从1开始将允许您在第一个项目之前插入将来的项目。您甚至可以向position列添加一个约束，以强制所有值严格大于零。</p><p> 将btree索引添加到position列。有理类型支持索引。您只需在列中添加唯一性约束即可自动获得索引。 </p><p>这是在给定项目之后立即插入新项目的最简单方法，它比任何现有的后续项目都要早切割：  -在项目2 INSERT INTO待办事项（位置，任务）之后立即添加项目。SELECT Rational_intermediate（2，min（pos）），＆＃39; edit article＆＃39; 从todos WHERE pos＆gt; 2;  即使项目是最大项目，此方法也有效，因为Rational_intermediate将第二个参数中的NULL视为无穷大。  您甚至可能不想使用序列来跟踪插入的最大项目。 您可以通过执行以下操作在列表末尾插入：  即使在空表上也可以使用。 我之前使用了一个序列，只是为了减少插入一批项目的代码。  尽管将其发送到客户端应用程序将阻止客户端知道真实位置，以要求数据库重新排列它们，所以重新标记可能应该在显示时发生。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://begriffs.com/posts/2018-03-20-user-defined-order.html">https://begriffs.com/posts/2018-03-20-user-defined-order.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/定义/">#定义</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/difficult/">#difficult</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/项目/">#项目</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1043262.html"><img src="http://img2.diglog.com/img/2021/1/thumb_1dfdab1f5289b0458ef8139cb4795318.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1043262.html">合成密码原语的按构造校正代码 </a></div><span class="my_story_list_date">2021-1-5 2:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037384.html"><img src="http://img2.diglog.com/img/2020/12/thumb_69e7604edbe2639b85b75d79d1d2e948.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037384.html">功能语言中的对象</a></div><span class="my_story_list_date">2020-12-1 4:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1010563.html"><img src="http://img.diglog.com/img/2020/7/thumb_c0459d02702a40101fd5b4f313481a52.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1010563.html">KAI：一个通用Lisp绘图库</a></div><span class="my_story_list_date">2020-7-8 23:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/technology_internet_163157.html"><img src="http://img.diglog.com/img/2009/6/thumb_b4f2ccb3b4fa4b8cbb3e7b5e6ac6eb1c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/technology_internet_163157.html">引领网络革命：Opera Unite</a></div><span class="my_story_list_date">2009-6-18 9:51</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>