<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>git电子邮件流程与github流程 Git email flow vs. GitHub flow</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Git email flow vs. GitHub flow<br/>git电子邮件流程与github流程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 08:40:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/3eb259d1a6f490d1478e0bd528bfb18d.png"><img src="http://img2.diglog.com/img/2021/3/3eb259d1a6f490d1478e0bd528bfb18d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>So I&#39;ve been using the Github flow for some years now from both the maintainer side and contributor side to open source projects. I&#39;ve also been using the email workflow for git from both sides for about a year now. Using email for git sounded quite horrible before I actually started using it. Now I prefer it so I thought I would document my experience here.</p><p>所以我＆＃39; Ve一直在使用GitHub流程，现在从维护者方面和贡献者方面到开源项目。我也一直在使用两侧的Git的电子邮件工作流程。在我实际开始使用它之前，使用电子邮件为git响起了很糟糕。现在我更倾向于，所以我以为我会在这里记录我的经验。</p><p>    Basically the same flow is also used on Gitlab and the other smaller git hosting services. This flow works reasonably well. It gets slightly more annoying after the first pull request because you actually have to keep your own local branch up to date.</p><p>    基本上相同的流量也用于Gitlab和其他较小的Git托管服务。这种流程合理地工作。在第一次拉拔请求后，它会稍微烦人，因为您实际上必须保持自己的本地分支到目前为止。</p><p> In theory this also gives some nice discoverability of people working on the project by looking at the forks of the project. In practice this is a bunch of outdated copies of the project by people who have mistaken the fork button for a like button.</p><p> 理论上，这也通过查看项目的叉子来说，在项目上工作的一些好的发现性。在实践中，这是一堆已经被误认为是像按钮的叉子按钮的人的过时的项目副本。</p><p> From a maintainer point of view this flow also works alright, unless your project starts to grow. For example when postmarketOS was still on Github we ran into the issue that the merge button isn&#39;t really useful. Once you have a reasonable volume of  pull requests the branches of those pull requests get outdated quickly meaning they have to be rebased before merging or every change will have an extra merge commit in the history.</p><p> 从维护者的角度来看，除非您的项目开始增长，否则此流程也可以正常工作。例如，当Postmarketos仍然在GitHub上时，我们遇到了合并按钮ISN＆＃39; t非常有用的问题。一旦您有合理的拉出请求，那些拉出请求的分支就会过时，这意味着它们必须在合并之前重建，或者每次更改都会在历史记录中有额外的合并提交。</p><p> In the postmarketOS case it was decided that merge commits are extra noise in the git history we&#39;d like to avoid so we&#39;d need to rebase things, and to properly rebase we have to do it from the command line because Github can&#39;t deal at all with conflicts. Rebasing from the command line also gives a lot more flexibility with squashing and having a nice commit message.</p><p> 在Postmarketos案例中，它决定合并犯历史上的额外噪音我们＆＃39; D喜欢避免所以我们需要rebase，并正确rebase我们必须从命令行执行它，因为GitHub可以与冲突交易。从命令行重新撤销也可以更有灵活性，挤压并具有很好的提交消息。</p><p> The only reason that merge button was used on Github was because Github can&#39;t seem to mark the pull request as merged if it isn&#39;t done by the button.</p><p> 合并按钮在Github上使用按钮的唯一原因是因为GitHub可以＆＃39; T似乎将拉杆标记为合并，如果它是由按钮完成的。</p><p>  The old workflow documentation postmarketOS had when Github was used can be read in the wiki history:  https://wiki.postmarketos.org/index.php?title=Merge_Workflow&amp;oldid=3441</p><p>  旧工作流文档PostmarketOS在使用GitHub时可以在Wiki历史记录中读取：https://wiki.postmarkettos.org/Index.php?title= merge_workflow& amp; oldid = 3441 </p><p> Now we&#39;ve moved to Gitlab we&#39;re basically dealing with the same issue, we have to mess with the commits before merging so we&#39;re always force-pushing to the git fork of the author of the pull request (which they have to enable on the merge request, if they don&#39;t we first have to tell them to enable that checkbox) and then finally merge them with the button in the web UI so Gitlab doesn&#39;t lose track of what happened.</p><p>现在我们又搬到了Gitlab We＆＃39; re基本上处理同样的问题，我们必须在合并之前乱搞犯罪，所以我们始终强制推动到拉的作者的git叉子请求（如果他们不得不在合并请求上启用它，如果他们不得不告诉他们启用该复选框），然后最后将它们与Web UI中的按钮合并，所以Gitlab and＃39; t丢失跟踪发生的事情。</p><p>  The flow for pull requests in github isn&#39;t the original way to make pull requests. Since git was originally written for the development of the Linux kernel it has been designed with the workflow of the kernel in mind. The kernel uses mailing lists.</p><p>  GitHub中的拉出请求的流量是制作拉出请求的原始方法。由于Git最初是为开发Linux内核的开发而设计，因此设计了内核的工作流程。内核使用邮件列表。</p><p>  The first patch I emailed was with the assistence of  https://git-send-email.io/, I needed to learn how to use the email flow because at the time I was working on my very first kernel patch. This was quite a daunting task involing triple-checking everything against the  patch submission documentation for Linux which describes the easy 16 step process.</p><p>  我通过电子邮件发送的第一个修补程序是https://git-send-email.io/io/，我需要了解如何使用电子邮件流，因为当我在我的第一个内核补丁时。这是一个令人生畏的任务，涉及三重检查所有针对Linux的补丁提交文档的一切，它描述了一个简单的16步进程。</p><p> Then after the final step the email gets sent out and you wait... for response emails.</p><p> 然后在最后一步之后，电子邮件被发送出去，等待...用于回复电子邮件。</p><p> Since then I&#39;ve made contributions to projects hosted on Sourcehut, which also uses the email workflow, and now I also maintain some projects on this platform. For example  Megapixels.</p><p> 从那以后，我＆＃39; Ve对Sourcehut上托管的项目做出了贡献，其中也使用了电子邮件工作流程，现在我还在这个平台上维护了一些项目。例如百万像素。</p><p> This is the workflow for submitting a patch to a project using the email flow:</p><p> 这是使用电子邮件流将修补程序提交给项目的工作流程：</p><p> Get comments as response to the patch as emails, mirrored on the webpage of the mailing list</p><p> 在邮件列表的网页上镜像时将评论作为电子邮件响应 </p><p> Fix up your previous mistakes, run  git send-email again with the  -v2 argument to send an updated version</p><p>修复您之前的错误，使用-v2参数再次运行git发送给发送更新的版本</p><p> As a maintainer getting the patches like this is quite nice since unless there&#39;s a conflict you don&#39;t have to merge branches or rebase things, the patches is just ... a patch, it only has the changes from the author, not the full git history.</p><p> 作为一种维护者，如此，除非有那些＆＃39，否则＆＃39; t必须合并分支机构或rebase的东西，否则＆＃39是非常好的。补丁只是......一个补丁，它只有来自的变化作者，不是完整的git历史记录。</p><p> Also, one thing to note about the process above is that, except for receiving the feedback, it will never touch your mail client. Git does SMTP itself and make sure the emails you send out are up-to-spec so maintainers can apply the changes directly by feeding the email into  git am</p><p> 此外，关于上述过程的一件事是，除了接收反馈之外，它将永远不会触摸您的邮件客户端。 Git是SMTP本身，并确保您发送的电子邮件是最新的，因此维护者可以通过将电子邮件送入Git AM来直接应用更改</p><p> If your main complaint is that email is horrible to work with, the issue is most likely not email, it&#39;s probably your mail client.</p><p> 如果您的主要投诉是，电子邮件可怕，问题很可能不会通过电子邮件发送电子邮件，它可能是您的邮件客户端。</p><p> One of the other main issues with the email workflow is that you can&#39;t just see the full state of the &#34;pull request&#34; because there&#39;s no nice pull request page to see what&#39;s happening. This is one of the main reasons I like the mailing lists on Sourcehut, the patch view fixes most of the visibility issues, for example this simple patch:  https://lists.sr.ht/~martijnbraam/public-inbox/patches/14382</p><p> 电子邮件工作流的其他主要问题之一是您可以＆＃39; t只看到＆＃34的完整状态;拉请求＆＃34;因为那里没有好的拉请求页面，看看＆＃39。这是我喜欢Sourcehut上的邮件列表的主要原因之一，修补程序视图修复了大多数可见性问题，例如这个简单的修补程序：https://lists.sr.ht/~martijnbraam/public-inbox/patches/ 14382</p><p>  There you see the patch description in the first block, which is in this case didn&#39;t have any extra text added in the  git send-email stage, so it only shows a summary of the changes in this patch.</p><p>  在那里，您在第一个块中看到了修补程序描述，这是在这种情况下，在Git发送电子邮件阶段中添加了任何额外的文本，因此它只显示了此修补程序的更改的摘要。</p><p> Below that is the actual patch, with the subject of the patch as header and then showing the full commit message below that if there were more lines and then the full diff. This patch can also be exported directly as a .patch file using the link right of the subject.</p><p> 下面的是实际补丁，修补程序的主题是标题，然后显示下面的完整提交消息，如果有更多的行，那么完整的差异。此修补程序也可以使用主题的链接右直接导出为.patch文件。 </p><p> Finally, below the diff is a comment from Eyal who applied this patch to the development branch and thanked the author; the mailing list will generate a nice threaded view here if there&#39;s more discussion.</p><p>最后，下面的差异是向发展分支应用此补丁的eyal的评论，并感谢作者;如果有更多的讨论，邮件列表将在此生成一个很好的线程视图。</p><p> The block on the right will show the status of the patch,  APPLIED in this case and gives some extra tools to get a copy of the full patchset that can be applied using  git am</p><p> 右侧的块将显示修补程序的状态，在这种情况下应用，并提供了一些额外的工具，以获取可以使用git上午应用应用的完整拼凑的副本</p><p>  I personally prefer the e-mail workflow now, it saves me from keeping branches/forks up to date as with this workflow only diffs are sent around. Also after working in Gitlab for most of the things I do on postmarketOS I really like how quickly sourcehut pages load and that I just can get all info from the patch without clicking on tabs to switch between comments, diffs and commit messages with loading times in between.</p><p>  我现在个人更喜欢电子邮件工作流程，它将我保存到迄今为止的分支/叉子，只有在此工作流程中只发送差异。此外，在Gitlab在Postmarketos上工作的大多数事情后，我真的很喜欢SourceHut页面加载的快速，而且我只能从补丁中获取所有信息，而无需单击选项卡在注释，diff和提交邮件之间切换加载时间之间。</p><p> Also one nice improvement is that instead of doing half the maintainer flow in the browser by clicking things and half by patching stuff up in my local git branch and force pushing that, it just lets me do everything in the shell and then just send an email back telling the author their patch got merged.</p><p> 还有一个很好的改进是，通过点击东西在我当地的git分支中，通过修补东西来制作浏览器中的维护者流程的一半，而不是在我的本地git分支中，它只是让我在shell中做所有事情，然后发送电子邮件返回告诉作者他们的补丁已合并。</p><p> All together people are most likely already used to having all the comments and info emailed to them as notifications, it&#39;s just that in the gitlab/hub case it will send you a link to continue on their website and in the sourcehut/email flow case the email is everything you need to continue without ever opening the browser.</p><p> 所有人都最有可能已经习惯了将所有的评论和信息发送给他们作为通知，它＆＃39;在Gitlab / Hub的情况下，它将向您发送一个链接以继续在他们的网站和Sourcehut中继续/电子邮件流箱如果您需要继续的所有内容，而无需打开浏览器。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.brixit.nl/git-email-flow-versus-github-flow/">https://blog.brixit.nl/git-email-flow-versus-github-flow/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/电子邮件/">#电子邮件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/email/">#email</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>