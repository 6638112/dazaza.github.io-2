<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我选择Emacs作为我的新文本编辑器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我选择Emacs作为我的新文本编辑器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 15:15:08</div><div class="page_narrow text-break page_content"><p>About  , I was changing jobs. I was leaving the walled garden of an  IDE  *						for a proprietary language that deployed to an  AS/400  *						.  								We wrote in  IBM RPG  *								and Cool Plex, which looked a lot of meta-code and what I now know to be  RDF Triples</p><p>关于，我在换工作。我即将离开IDE*的围墙花园，前往部署在AS/400*上的专有语言。我们用IBM RPG*和Cool Plex编写，它们看起来有很多元代码，我现在知道是RDFTriples。</p><p>  At my new job, I was writing web-facing applications using open source technology and deploying to Linux. I needed to find an editor to help me with the task.</p><p>在我的新工作中，我使用开源技术编写面向Web的应用程序，并部署到Linux上。我需要找一位编辑来帮我完成这项任务。</p><p>  I spent a bit of time exploring my options. During that exploration, I learned of  Emacs from  Carl Meyer.  								Carl is a friend of mine from high school, and has contributed a lot to the world.</p><p>我花了一些时间探索我的选择。在那次探索中，我从卡尔·迈耶那里了解到了Emacs。卡尔是我高中时的朋友，他为世界做出了很大贡献。</p><p>  At the time I had three young children, I had just changed jobs, changed programming languages, and couldn’t wrap my head around Emacs. I wanted my editor to behave like other  GUI  *						applications.</p><p>当时我有三个年幼的孩子，我刚刚换了工作，换了编程语言，还不能理解Emacs。我希望我的编辑器能像其他GUI*应用程序一样工作。</p><p>  I didn’t take the time to walk through the Emacs tutorial, and left Emacs behind.</p><p>我没有花时间浏览Emacs教程，而把Emacs抛在了后面。</p><p>  A few months into my new job, I switched languages and paradigms again. In  , my company hopped in a van and drove to Chicago to learn about  Django  *						and  Ruby on Rails  *						. Within a week, our organization adopted Ruby on Rails.</p><p>在我新工作的几个月里，我再次转换了语言和范式。我的公司跳上一辆面包车，开到芝加哥去了解Django*和Ruby on Rails*。不到一周，我们的组织就采用了Ruby on rails。</p><p>  At that time, I adopted  Textmate  *						as my editor. It had a beautiful user-interface and required little effort to learn.  								I wasn’t aware of how useful a shell environment could be; In the years I’d learn more. I had, during my professional life, often relied on GUI views into files, systems, and processes. So I didn’t have a mental model that would have further nudged me towards an integrated text editor. And in my hubris, I didn’t step through the Emacs tutorial.</p><p>当时，我采用了TextMate*作为我的编辑。它有一个漂亮的用户界面，不需要花多少功夫就能学会。我没有意识到shell环境的用处有多大；在以后的岁月里，我会学到更多。在我的职业生涯中，我经常依赖于文件、系统和流程的GUI视图。因此，我没有一个心理模型，可以进一步推动我走向一个集成的文本编辑器。在我的傲慢中，我没有一步步看完Emacs教程。</p><p>  At the time Textmate was closed source. I used it and loved it, but it began to lag.  								The search a project function started misbehaving and gridning projects to a halt.													I found  Sublime Text  *						and switched. At the time, Sublime was positioning as a Textmate replacement.</p><p>当时，TextMate是封闭源代码的。我用过它，也很喜欢它，但它开始滞后了。搜索项目功能开始行为不端，网格化项目陷入停顿。我找到了崇高的文字*然后换了。当时，Sublime的定位是TextMate的替代品。</p><p>  Then, as I engaged more and more in open source projects, I started wanting an open source text editor. I learned about Atom in 2015. It was open source and acted enough like Sublime, that I switched.  								During this time, I dabbled with  vim  *								. However, the modal nature of editing felt foreign. At times, I’d try out a tutorial, but it never stuck. I also thought about revising Textmate as the owner later released it as open source.</p><p>然后，随着我越来越多地参与开源项目，我开始想要一个开源文本编辑器。我是在2015年了解到Atom的。它是开源的，行为非常像Sublime，所以我改用了它。在此期间，我尝试了VIM*。然而，编辑的模态性质给人一种陌生的感觉。有时，我会尝试一个教程，但它从来没有坚持下来。我还考虑过修改TextMate，因为它的所有者后来将其作为开放源码发布。</p><p>  Forward to  . I had begun noticing more and more bugs and breaks in Atom. Not one to fear changing editors, I started looking.</p><p>转发到。我已经开始注意到Atom中越来越多的bug和漏洞。不是害怕更换编辑的人，我开始寻找。</p><p>  I also gave  VS Code  *						a spin, and found it disconcerting. First, it felt constraining and off-putting. The configuration ecosystem felt clunky. The plugins felt like an App Store. Everything felt like VS Code was trying to obfuscate it’s underlying systems.</p><p>我也给了VS Code*一个旋转，发现它令人不安。首先，它让人感到压抑和反感。配置生态系统感觉很笨重。这些插件给人的感觉就像是一个App Store。每件事都让人感觉VS代码试图混淆它的底层系统。</p><p>  Years ago, I started aspiring to write most of my commit messages following  Tim Pope’s guidance on commit messages. To this day, I try to write meaningful commit messages, knowing that these commit messages will most often be close to the code. 								Some may put that information in a pull request message on Github or Gitlab, but that information does not remain close to the code. However, that information is now inextricably tied to the details of Github. When I want to spelunk through my code, I don’t want to have to go to Github to get a view into what happened. I want my  git annotate and  git log to carry as much meaning as possible.</p><p>几年前，我开始渴望遵循Tim Pope关于提交消息的指导来编写我的大部分提交消息。直到今天，我还在尝试编写有意义的提交消息，因为我知道这些提交消息通常与代码非常接近。有些人可能会将信息放在Github或GitLab上Pull请求消息中，但该信息不会保持在代码附近。然而，这些信息现在与Github的细节密不可分。当我想要拼写我的代码时，我不想去Github查看发生了什么。我希望我的git注解和git日志能够承载尽可能多的意义。</p><p>  The proverbial last straw was the  git  *						prompt for commit messages. The prompt was a small input box; It didn’t encourage meaningful commit messages. Instead it encouraged terse commits. That feature alone told me that people using it will be encouraged to write bad commit messages. I didn’t want to be that guy with my text editor.</p><p>众所周知，最后一根稻草是要求提交消息的git*提示符。提示是一个很小的输入框；它不鼓励有意义的提交消息。相反，它鼓励简洁的承诺。仅这一功能就告诉我，使用它的人将被鼓励编写不好的提交消息。我不想成为那个有我的文本编辑器的人。</p><p>    I again tried  vim  *						but it felt off.  								I use Vim when I shell out to a server. I haven’t done it much recently, because I’d likely use Emacs’s  Tramp mode.</p><p>我又试了一次vim*但感觉不对劲。当我向服务器支付费用时，我使用Vim。我最近不经常这样做，因为我可能会使用Emacs的流浪汉模式。</p><p>  I tried Emacs, and worked my way through the Tutorial. It was the strong commitment to the Tutorial and honestly the writing of that tutorial that nudged me to dive further in. I spent some time fiddling with Doom or Spacemacs, but in the end settled on bare metal Emacs.</p><p>我尝试了Emacs，并按照自己的方式完成了教程。正是对该教程的坚定承诺，以及诚实地说，该教程的写作促使我进一步深入研究。我花了一些时间摆弄Doom或Spacemacs，但最终还是选择了裸机Emacs。</p><p>  This proved crucial. As someone that’s used text editors for 15+ years, I know the features I’ve used. What I chose to do in Emacs was to complete the tutorial and start coding.</p><p>事实证明，这一点至关重要。作为一个使用文本编辑器超过15年的人，我知道我使用过的功能。我选择在Emacs中做的是完成教程并开始编码。</p><p>  If I found myself wanting a feature, I took note of it. Then, I went and found the package or packages that implemented the feature.  								I spent quite a bit of time reading through  Melpa, looking for a package. What happened is that I have built up my own editor that meets my needs.</p><p>如果我发现自己想要一个功能，我就会注意到它。然后，我找到了实现该功能的一个或多个包。我花了相当多的时间通读梅尔帕，寻找一个包裹。发生的事情是，我已经建立了自己的编辑器，满足了我的需求。</p><p>  Now, 5 months or so in, I’m fully loving the experience. The community of Emacs developers seem to have a higher commitment to writing documentation.  								Many Emacs developers write their configuration files using the paradigm of  Literate Programming. In other words, they first write down their intentions for the software, then write the software.</p><p>现在，大约5个月过去了，我完全喜欢这段经历。Emacs开发人员社区似乎对编写文档有更高的承诺。许多Emacs开发人员使用识字编程范例编写配置文件。换句话说，他们首先写下他们对软件的意图，然后再编写软件。</p><p>    Org Mode is the missing piece for my past text editors.  Carstin Dominik took the time to build out functionality for organizing the non-coding tasks of software development, research, and writing.  								Were I to begin my blog anew, I’d leverage  org-mode and  ox-hugo for blogging.</p><p>组织模式是我以前的文本编辑器所缺少的部分。Carstin Dominik花时间构建了组织软件开发、研究和编写的非编码任务的功能。如果我重新开始我的博客，我会利用org-mode和ox-Hugo来写博客。</p><p>  Org Mode layers meaningful tools on top of plain text files; The syntax is close to Markdown, but different enough. The simplicity of structure makes the world of difference. With the plain text, I can run low-level Unix commands (e.g.  grep,  sed, etc.) but also have higher level programmatic access to the data.</p><p>组织模式将有意义的工具层叠在纯文本文件之上；语法接近Markdown，但差别很大。结构的简单性使世界与众不同。使用纯文本，我可以运行低级Unix命令(例如grep、sed等)。而且还具有对数据的更高级别的编程访问。</p><p>    Prior to  magit, I almost always used command line tools for  git  *						. My previous workflow would be to use Terminal to state my git commits, and then my text editor to write commit messages.  								Atom’s slowness to open as a commit message editor was another reason I left Atom. I don’t want to wait multiple seconds to start writing a commit message.</p><p>在使用magit之前，我几乎总是使用git*的命令行工具。我之前的工作流程是使用终端声明我的GIT提交，然后使用文本编辑器编写提交消息。作为提交消息编辑器打开Atom很慢，这是我离开Atom的另一个原因。我不想等待数秒才开始编写提交消息。</p><p>  Except for reading git logs, I now do most all git tasks with Magit. That includes an  amazing interactive  git rebase environment.</p><p>除了读取git日志之外，我现在使用Magit执行几乎所有的git任务。这包括一个令人惊叹的交互式git rebase环境。</p><p>      When Carl introduced me to Emacs, he showed me  fill-paragraph. That functionality stuck with me. It’s nothing fancy, but it shows that Emacs treats column-width as a first class citizen.</p><p>当卡尔把我介绍给Emacs的时候，他给我看了一整段话。这一功能让我印象深刻。这不是什么花哨的事，但它表明Emacs将列宽视为一等公民。</p><p>    Conforming to that structure helps ensure that your  git log excursions are not unduly messy. It also helps if you’re going to interact with the command-line. In other words, automatic word-wrapping is nice, but its not universal, nor does it work in all contexts.</p><p>遵循这种结构有助于确保您的GIT日志旅行不会过于混乱。如果您要与命令行交互，这也会有所帮助。换句话说，自动换行很好，但它不是通用的，也不是在所有上下文中都有效。</p><p>  I have used this command to quickly wrap documentation so as to not have it flow off the screen.  								For coding buffers, I disable word wrapping. I also aspire to 120 character line width for code and 80 character line width for comments. Why the variance? Comments should read more like prose, and long running lines make the paragraphs harder to read.</p><p>我已经使用此命令快速包装文档，以免它流出屏幕。对于编码缓冲区，我禁用了自动换行。我也渴望120字符线宽的代码和80字符线宽的评论。为什么会有这样的差异呢？评论应该读起来更像散文，长长的台词会使段落更难阅读。</p><p>  It ain’t much of a command, but I’ve held a candle for it since I learned about Emacs.</p><p>这不是什么命令，但自从我了解Emacs以来，我就一直对此持乐观态度。</p><p>    I never knew I wanted Swiper until I stumbled onto it. I now use it  all of the time; It’s even replaced my default Find behavior in Emacs.</p><p>直到我偶然发现它，我才知道我想要Swiper。我现在一直在使用它；它甚至取代了我在Emacs中的默认查找行为。</p><p>  What does it do? I type Control+S  								In Emacs parlance, that’s  C-s 						and start typing a word. In a mini-buffer at the bottom of the current buffer, I see the lines that include that word. It’s a bit like a find with context. Importantly, this doesn’t move my cursor in the main buffer.</p><p>是干什么的呢？我输入Control+S，用Emacs的话来说就是C-s，然后开始输入一个单词。在当前缓冲区底部的小型缓冲区中，我看到包含该单词的行。这有点像一个有上下文的发现。重要的是，这不会移动主缓冲区中的光标。</p><p>  So I end up quickly referencing something and get back to typing. Or, I can navigate through the mini-buffer and jump to that location in the main buffer. Quite slick.</p><p>所以我很快就引用了一些东西，然后继续打字。或者，我可以在迷你缓冲区中导航并跳转到主缓冲区中的该位置。相当圆滑。</p><p>    The  wgrep-ag package sort of blew my mind. It allows you to use  ag  *						with  wgrep to edit search results</p><p>Wgrep-ag套餐有点让我大吃一惊。它允许您使用ag*和wgrep编辑搜索结果。</p><p>    In Emacs, I search a project using  ag. Emacs renders the search results in a mini-buffer. In this case, the mini-buffer is a small set of rows at the bottom of Emacs that show a subset of the results.</p><p>在Emacs中，我使用ag搜索项目。Emacs在迷你缓冲区中呈现搜索结果。在本例中，小缓冲区是Emacs底部的一小部分行，显示结果的子集。</p><p>  With the mini-buffer active (e.g. I’ve been typing results there), I invoke  ivy-occur. That function opens all of the search results in a read-only buffer.  								While I was writing this example, I thought to myself “I wonder if I can use  ivy-occur from Swiper results? Yes I can. So I learned something while explaining something.</p><p>在小缓冲区处于活动状态(例如，我一直在那里键入结果)的情况下，我调用了Ivy-Octure。该函数在只读缓冲区中打开所有搜索结果。当我写这个例子的时候，我想“我想知道我是否可以使用常春藤-发生在Swiper结果中？是的我可以。所以我在解释的时候学到了一些东西。</p><p>  With this new buffer, I invoke the function  wgrep-change-to-wgrep-mode. This toggles  ivy-occur buffer into an edit mode. I begin editing the search results as though it were it’s own file.</p><p>使用这个新缓冲区，我调用函数wgrep-change-to-wgrep-mode。这会将常春藤发生缓冲区切换到编辑模式。我开始编辑搜索结果，就好像它是它自己的文件一样。</p><p>  Then I save the edits, and  wgrep-ag writes all of those changes back to the found results.</p><p>然后保存编辑，wgrep-ag将所有这些更改写回找到的结果。</p><p>  Another way to think of it,  wgrep-ag loads a semi-structured buffer. Each row has three fields: file name, line number, and line text. I can use  wgrep-ag to write those changes back to the originating file.</p><p>从另一种角度来看，wgrep-ag加载一个半结构化缓冲区。每行有三个字段：文件名、行号和行文本。我可以使用wgrep-ag将这些更改写回原始文件。</p><p>      Textmate first introduced me to this powerful concept. Since then, this functionality has been a mandatory feature of my editors.</p><p>TextMate首先向我介绍了这个强大的概念。从那时起，这个功能就成了我的编辑器的必备功能。</p><p>    iedit - by default, if I type Control+ ; (e.g.  C-;), the iedit package highlights each occurence of the word. I can now type and iedit updates all occurrences.</p><p>Iedit-默认情况下，如果我键入Control+；(例如C-；)，iedit包将突出显示该单词的每个匹配项。我现在可以输入，然后iedit会更新所有匹配项。</p><p>  multiple-cursors - this package provides finer grain control, and allows me to set a cursor on ten contiguous lines and start typing.</p><p>多光标-这个包提供了更精细的粒度控制，并允许我在10个连续行上设置光标并开始键入。</p><p>    I didn’t know what I was missing until I installed  expand-region. Now with Control+ = (e.g.  C-=) my cursor expands to the smallest logical region (e.g. highlighting a word), typing it again expands that region (e.g. highlighting the sentence), etc. And Control+Shift+ = (e.g.  C-+) contracts the region.</p><p>直到我安装了Expand-Region，我才知道我错过了什么。现在使用Control+=(例如C-=)，我的光标扩展到最小的逻辑区域(例如突出显示一个单词)，再次键入它会扩展该区域(例如突出显示句子)，依此类推。而Control+Shift+=(例如C-+)则收缩该区域。</p><p>      I’ve used this to write up campaign notes for my  New Vistas in the Thel Sector campaign. The bi-directional link and quick note capture tools make for a dream in information management.</p><p>我已经用它为我在行业竞选中的新远景写了竞选笔记。双向链接和快速笔记捕获工具成就了信息管理的梦想。</p><p>  In away, it creates a Wiki that I can use Emacs to edit and navigate.</p><p>在Away中，它创建了一个我可以使用Emacs编辑和导航的Wiki。</p><p>    This year, Emacs drew me in. As I’ve entered my 3rd decade of software development, I’ve grown to appreciate tutorials, documentation, and owning my tools. Emacs delivers on all of that.  								It’s even as old as I am.</p><p>今年，Emacs吸引了我。随着我进入软件开发的第三十年，我开始欣赏教程、文档和拥有自己的工具。Emacs做到了这一切。它甚至和我一样老。</p><p>  What I’ve found is I spend more and more time in Emacs, as it does more and more of what I want, all building from the basis of text files and directories.</p><p>我发现我花在Emacs上的时间越来越多，因为它做了越来越多我想要的事情，所有这些都是在文本文件和目录的基础上构建的。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://takeonrules.com/2020/10/18/why-i-chose-emacs-as-my-new-text-editor/">https://takeonrules.com/2020/10/18/why-i-chose-emacs-as-my-new-text-editor/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/emacs/">#emacs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>