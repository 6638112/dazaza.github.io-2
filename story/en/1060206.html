<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析protobuf在2 + gb / s：我如何学会爱尾呼叫 Parsing Protobuf at 2+GB/S: How I Learned to Love Tail Calls in C</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parsing Protobuf at 2+GB/S: How I Learned to Love Tail Calls in C<br/>解析protobuf在2 + gb / s：我如何学会爱尾呼叫 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-26 10:57:08</div><div class="page_narrow text-break page_content"><p>An exciting feature  just landed in the main branch of the Clangcompiler. Using the  [[clang::musttail]] or __attribute__((musttail)) statement attributes, you can now get guaranteedtail calls in C, C++, and Objective-C.</p><p>一个令人兴奋的功能，刚刚登陆克兰贩运者的主要分支机构。使用[[clang :: musttail]]或__Attribute __（（musttail））语句属性，您现在可以在C，C ++和Objective-C中获得保证标准呼叫。</p><p> While tail calls are usually associated with a functional programming style, Iam interested in them purely for performance reasons. It turns out that insome cases we can use tail calls to get better code out of the compiler thanwould otherwise be possible—at least given current compilertechnology—without dropping to assembly.</p><p> 虽然尾部呼叫通常与功能性编程风格相关联，但iam纯粹对它们的性能原因感兴趣。事实证明，我们可以使用尾部呼叫来使用尾部呼叫从编译器中获取更好的代码，否则可能 - 至少给出当前的CompilerteChnology  - 而不会丢弃到组装。</p><p> Applying this technique to protobuf parsing has yielded amazing results:  wehave managed to demonstrate protobuf parsing at over2GB/s, more than double theprevious state of the art. There are multiple techniques that contributed tothis speedup, so “tail calls == 2x speedup” is the wrong message to take away.But tail calls are a key part of what made that speedup possible.</p><p> 将这种技术应用于protobuf解析已经产生了惊人的结果：我们在超过2GB / s的Protobuf Parsings上展示了Protobuf，超过了本领域的双倍。有多种技巧贡献了Tothis Speedup，因此“尾呼叫== 2X加速”是错误的消息。但是尾部呼叫是使得这种加速的关键部分。</p><p> In this blog entry I will describe why tail calls are such a powerfultechnique, how we applied them to protobuf parsing, and how this techniquegeneralizes to interpreters. I think it’s likely that all of the major languageinterpreters written in C (Python, Ruby, PHP, Lua, etc.) could get significantperformance benefits by adopting this technique. The main downside isportability: currently  musttail is a nonstandard compiler extension, andwhile I hope it catches on it will be a while before it spreads widely enoughthat your system’s C compiler is likely to support it. That said, at buildtime you can compromise some efficiency for portability if you detect that musttail is not available.</p><p> 在这个博客条目中，我将描述为什么尾呼叫是这样的powerfultechnique，我们如何将它们应用于protobuf解析，以及这种技术如何给口译员解释。我认为，在C（Python，Ruby，PHP，Lua等中写的所有主要Ligulardergers都可能通过采用这种技术来获得重要的优势。主要的下行空位性：目前鼬是一个非标准的编译器扩展，我希望它能够捕获它将是一段时间，因为它的系统的C编译器可能支持它。也就是说，在Buildtime，如果您检测到不可用的情况，则可以损害可移植性的一些效率。</p><p>  A tail call is any function call that is in tail position, the final action tobe performed before a function returns. When  tail call optimization occurs,the compiler emits a  jmp instruction for the tail call instead of  call.This skips over the bookkeeping that would normally allow the callee  g() toreturn back to the caller  f(), like creating a new stack frame or pushing thereturn address. Instead  f() jumps directly to  g() as if it were part ofthe same function, and  g() returns directly to whatever function called f(). This optimization is safe because  f()’s stack frame is no longerneeded once the tail call has begun, since it is no longer possible to accessany of  f()’s local variables.</p><p>  尾呼叫是尾部位置的任何函数调用，在函数返回之前执行的最终动作。当发生尾呼叫优化时，编译器发出尾呼叫的JMP指令而不是呼叫。这跳过通常允许Callee G（）Toreturn返回调用者f（）的簿记，例如创建新的堆栈帧或推到身边。而是f（）直接跳转到g（），好像它是相同函数的一部分，而g（）则直接返回给名为f（）的任何功能。这一优化是安全的，因为一旦尾呼叫开始，F（）的堆栈帧就不会长时间化，因为它不再可能访问F（）的局部变量。</p><p> While this may seem like a run-of-the-mill optimization, it has two veryimportant properties unlock new possibilities in the kinds of algorithms we canwrite. First, it reduces the stack memory from from ++O(n)++ to ++O(1)++ whenmaking ++n++ consecutive tail calls, which is important because stack memory islimited and stack overflow will crash your program. This means that certainalgorithms are not actually safe to write unless this optimization isperformed. Secondly,  jmp eliminates the performance overhead of  call, suchthat a function call can be just as efficient as any other branch. These twoproperties enable us to use tail calls as an efficient alternative tonormal iterative control structures like  for or  while.</p><p> 虽然这似乎是一个磨坊优化，但它有两个非常重要的属性解锁我们在蜜饯的各种算法中的新可能性。首先，它将堆栈内存从++ O（n）++减少到++ O（1）++，当时++ n ++连续的尾呼叫，这很重要，因为堆栈内存islimited并且堆栈溢出将崩溃您的程序。这意味着除非这种优化缺乏表现，否则肯定的仪器实际上并不安全。其次，JMP消除了呼叫的性能开销，函数调用可以与任何其他分支一样高效。这些曲折使我们能够使用尾部呼叫作为一种有效的替代迭代控制结构，如偶然的替代控制结构。</p><p> This is by no means a new idea, indeed it goes back to at least 1977 when GuySteele wrote  an entire paperarguing that procedure calls make for cleaner designs than  GOTO, and thattail call optimization can make them just as fast. This was one of the  “LambdaPapers”written between 1975 and 1980 that developed many of the ideas underlying Lispand Scheme.</p><p> 这绝不是一个新的想法，确实它返回到至少1977年，当圭士座eele写了一个整个纸张，即过程调用比转到更清洁的设计，而且该特征呼叫优化可以像快速一样。这是1975年至1980年间编写的“Lambdapapers”之一，它开发出潜在的Lispand计划的许多想法。 </p><p> Tail call optimization is not even new to Clang: like GCC and many othercompilers, Clang was already capable of optimizing tail calls. In fact, the musttail attribute in our first example above did not change the output ofthe compiler at all: Clang would already have optimized the tail call under -O2.</p><p>尾部呼叫优化甚至不是铿cl的新内容：就像GCC和许多其他代办者一样，克朗已经能够优化尾呼叫。实际上，上面的第一个示例中的蜜饯属性并没有改变编译器的输出：克朗已经已经优化了-O2下的尾部呼叫。</p><p> What is new is the  guarantee. While compilers will often optimize tail callssuccessfully, this is best-effort, not something you can rely on. Inparticular, the optimization will most likely not happen in non-optimizedbuilds:</p><p> 什么是新的保证。虽然编译器经常会优化尾声Calluccescess，这是最好的努力，而不是你可以依赖的东西。 inparticular，优化很可能不会发生在非优化的建议中：</p><p> Here the tail call was compiled to an actual  call, so we are back to ++O(n)++stack space. This is why we need  musttail: unless we can get a guarantee fromthe compiler that our tail calls will  always be optimized, in all buildmodes, it isn’t safe to write algorithms that use tail calls for iteration. Itwould be a pretty severe limitation to have code that only works whenoptimizations are enabled.</p><p> 在这里，尾呼叫被编译为实际呼叫，因此我们返回++ o（n）++堆栈空间。这就是我们需要MustTail的原因：除非我们可以从编译器中获取保证，除非我们的尾部呼叫将始终优化，在所有构建设备中，写入使用尾部呼叫迭代的算法并不安全。对于仅启用Optimizations的代码，它可能是一个非常严重的限制。</p><p>  Compilers are incredible pieces of technology, but they are not perfect. MikePall, author of LuaJIT, decided to write LuaJIT 2.x’s interpreter in assemblyrather than C, and he cites this decision as a major factor that explains  whyLuaJIT’s interpreter is sofast.He later went into more detail about  why C compilers struggle with interpretermain loops. His twomost central points are:</p><p>  编译器是令人难以置信的技术，但它们并不完美。吕吉特的作者Mikepall决定在组装中写下Luajit 2.x的翻译，而他将此决定作为解释的主要因素，该决定解释了Whyluajit的翻译是Sofast的主要因素。他以后与C编译器与Tenderetermain循环斗争的原因有更多详细信息。他的双转体中心是：</p><p> The larger a function is, and the more complex and connected its controlflow, the harder it is for the compiler’s register allocator to keep the mostimportant data in registers.</p><p> 函数越大，并且更复杂并连接其控制流程，因此编译器的寄存器分配器难以保持寄存器中的大量数据。</p><p>  When fast paths and slow paths are intermixed in the same function, thepresence of the slow paths compromises the code quality of the fast paths.</p><p>  当快速路径和慢速路径混合在相同的函数中时，慢路径的假义会损害快速路径的代码质量。</p><p> These observations closely mirror our experiences optimizing protobuf parsing.The good news is that tail calls can help solve both of these problems.</p><p> 这些观察结果密切镜像我们的经历优化Protobuf解析。好消息是尾部呼叫可以帮助解决这两个问题。 </p><p> It may seem odd to compare interpreter loops to protobuf parsers, but thenature of the protobuf wire format makes them more similar than you mightexpect. The protobuf wire format is a series of tag/value pairs, where the tagcontains a field number and wire type. This tag acts similarly to aninterpreter opcode: it tells us what operation we need to perform to parse thisfield’s data. Like interpreter opcodes, protobuf field numbers can come in anyorder, so we have to be prepared to dispatch to any part of the code at anytime.</p><p>将解释器循环与Protobuf解析器进行比较可能看起来很奇怪，但是Protobuf线格式的那么使它们比你的强调更相似。 Protobuf Wire格式是一系列标签/值对，其中标签磁场号和线型。此标记与AnInterpretret Opcode类似：它告诉我们我们需要执行的操作以解析菲尔德的数据。与解释器操作码一样，Protobuf字段编号可以在任何时候进入，因此我们必须准备好随时派遣代码的任何部分。</p><p> The natural way to write such a parser is to have a  while loop surrounding a switch statement, and indeed this has been the state of the art in protobufparsing for basically as long as protobufs have existed. For example,  here issome parsing code from the current C++ version of protobuf. If we represent thecontrol flow graphically, we get something like this:</p><p> 写这样的解析器的自然方式是有一段时间循环围绕交换机语句，并且确实这一直是在Protobufparsing中基本上存在的技术状态，只要Protobufs存在。例如，这里来自当前C ++版本的Protobuf的解析代码。如果我们以图形方式表示T​​hecontrol流量，我们会得到这样的东西：</p><p>   But this is incomplete, because at almost every stage there are things thatcan go wrong. The wire type could be wrong, or we could see some corruptdata, or we could just hit the end of the current buffer. So the fullcontrol flow graph looks more like this.</p><p>   但这是不完整的，因为在几乎每个阶段都有那些东西的东西出错了。电线类型可能是错误的，或者我们可以看到一些腐败数据，或者我们可以击中当前缓冲区的末尾。所以全文流程图更像是这样的。</p><p>   We want to stay on the fast paths (in blue) as much as possible, but when wehit a hard case we have to execute some fallback code to handle it. Thesefallback paths are usually bigger and more complicated than the fast paths,touch more data, and often even make out-of-line calls to other functions tohandle the more complex cases.</p><p>   我们希望尽可能地留在快速路径（蓝色），但是当威特难以执行一些后退代码来处理它。这些PathaftBack路径通常比快速路径更大，更复杂，触摸更多数据，甚至甚至甚至对其他功能进行单线呼叫，才能处理更复杂的情况。</p><p> Theoretically, this control flow graph paired with a profile should give thecompiler all of the information it needs to generate the most optimal code. Inpractice, when a function is this big and connected, we often find ourselvesfighting the compiler. It spills an important variable when we want it to keepit in a register. It hoists stack frame manipulation that we want to shrinkwrap around a fallback function invocation. It merges identical code pathsthat we wanted to keep separate for branch prediction reasons. The experiencecan end up feeling like trying to play the piano while wearing mittens.</p><p> 从理论上讲，与配置文件配对的这种控制流程图应给出要生成最佳代码所需的所有信息。 inpractice，当一个函数很大并连接时，我们经常发现自己的编译器。当我们希望它留在寄存器中时，它会泄漏一个重要变量。它提升了堆栈框架操作，我们要围绕回退函数调用来收缩。它合并我们希望保持分支预测原因的相同代码路径。体验遗憾的是，戴手套时试图在试图踢钢琴。</p><p>  The analysis above is mainly just a rehash of of Mike’s  observations aboutinterpreter mainloops. But instead ofdropping to assembly, as Mike did with LuaJIT 2.x, we found that a tail calloriented design could give us the control we needed to get nearly optimal codefrom C. I worked on this together with my colleague Gerben Stavenga, who cameup with much of the design. Our approach is similar to the design of the wasm3 WebAssembly interpreter which describesthis pattern as a  “metamachine”.</p><p>  上面的分析主要只是迈克观察到接近interpreter mainloops的rehash。但是，随着迈克用Luajit 2.x做的，我们发现尾呼吁的设计可以给我们控制近乎最佳的Codefrom C.而不是汇集到大会。我与我的同事们一起努力工作大部分的设计。我们的方法类似于WASM3 WebasseMbly解释器的设计，它将图案描述为“Metamachine”。</p><p> The code for our 2+GB/s protobuf parser was submitted to upb, a small protobuf library writtenin C, in  pull/310. While itis fully working and passing all protobuf conformance tests, it is not rolledout anywhere yet, and the design has not been implemented in the C++ version ofprotobuf. But now that  musttail is available in Clang (and  upb has beenupdated to use it), one ofthe biggest barriers to fully productionizing the fast parser has been removed.</p><p> 我们的2 + GB / s Protobuf解析器的代码被提交给UPB，一个小型Protobuf库写入C，在拉/ 310中。虽然ITIS完全工作并通过所有Protobuf一致性测试，但它尚未滚展，并且设计尚未在C ++版本的普通话中实现。但是，现在Musttail在CLANG（和UPB已经使用它）中，完全生产快速解析器的最大壁垒之一已被删除。 </p><p> Our design does away with a single big parse function and instead gives eachoperation its own small function. Each function tail calls the next operationin sequence. For example here is a function to parse a single fixed-widthfield. (This code is simplified from the actual code in upb; there are manydetails of our design that I am leaving out of this article, but will hopefullycover in future articles).</p><p>我们的设计与单一大解析功能远离，而是给予每种术语。每个功能尾部都会调用下一个操作序列。例如，这里是解析单个固定范围域的函数。 （此代码是从UPB中的实际代码中简化的;我们设计的许多尾针我要离开这篇文章，但希望在未来的文章中持有潜望。</p><p> #include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;string.h&gt; typedef  void  * upb_msg ; struct  upb_decstate ; typedef  struct  upb_decstate  upb_decstate ; // The standard set of arguments passed to each parsing function. // Thanks to x86-64 calling conventions, these will be passed in registers. #define UPB_PARSE_PARAMS \ upb_decstate *d, const char *ptr, upb_msg *msg, intptr_t table, \ uint64_t hasbits, uint64_t data#define UPB_PARSE_ARGS d, ptr, msg, table, hasbits, data #define UNLIKELY(x) __builtin_expect(x, 0)#define MUSTTAIL __attribute__((musttail)) const  char  * fallback ( UPB_PARSE_PARAMS ); const  char  * dispatch ( UPB_PARSE_PARAMS ); // Code to parse a 4-byte fixed field that uses a 1-byte tag (field 1-15). const  char  * upb_pf32_1bt ( UPB_PARSE_PARAMS )  {  // Decode &#34;data&#34;, which contains information about this field.  uint8_t  hasbit_index  =  data  &gt;&gt;  24 ;  size_t  ofs  =  data  &gt;&gt;  48 ;  if  ( UNLIKELY ( data  &amp;  0xff ))  {  // Wire type mismatch (the dispatch function xor&#39;s the expected wire type  // with the actual wire type, so data &amp; 0xff == 0 indicates a match).  MUSTTAIL  return  fallback ( UPB_PARSE_ARGS );  }  ptr  +=  1 ;  // Advance past tag.  // Store data to message.  hasbits  |=  1ull  &lt;&lt;  hasbit_index ;  memcpy (( char * ) msg  +  ofs ,  ptr ,  4 );  ptr  +=  4 ;  // Advance past data.  // Call dispatch function, which will read the next tag and branch to the  // correct field parser function.  MUSTTAIL  return  dispatch ( UPB_PARSE_ARGS ); }</p><p> #include＆lt; stdint.h＆gt; #include＆lt; stddef.h＆gt; #include＆lt; string.h＆gt; typedef void * upb_msg; struct upb_decstate; typedef struct upb_decstate upb_decstate; //传递给每个解析功能的标准参数集。 //由于x86-64调用约定，这些将在寄存器中传递。 #define upb_parse_params \ upb_decstate * d，const char * ptr，upb_msg * msg，intptr_t表，\ uint64_t hasbits，uint64_t data＃define upb_parse_args d，ptr，msg，表，hasbits，data #define不可能（x）__builtin_expect（x， 0）#define musttail __attribute __（（musttail））const char * hextback（upb_parse_params）; const char * dispatch（upb_parse_params）; //解析使用1字节标记（字段1-15）的4字节固定字段的代码。 const char * upb_pf32_1bt（upb_parse_params）{//解码＆＃34;数据＆＃34;，其中包含有关此字段的信息。 uint8_t hasbit_index = data＆gt;＆gt; 24; size_t = data＆gt;＆gt; 48; if（不可能（数据＆amp; 0xff））{//线类型不匹配（调度函数xor＆＃39; s的预期电线类型//使用实际的电线类型，因此数据＆amp; 0xff == 0表示匹配）。 Mustttail退货后备（upb_parse_args）; PTR + = 1; //提前过去的标签。 //将数据存储到消息。 hasbits | = 1ull＆lt;＆lt; hasbit_index; memcpy（（char *）msg +，ptr，4）; PTR + = 4; //前进过去的数据。 //调用调度函数，它将读取下一个标记和分支到//正确的字段解析器函数。 Musttail返回调度（upb_parse_args）; }</p><p> For a function this small and simple, Clang gives us code that isbasically impossible to beat.</p><p> 对于这个小而简单的函数，Clang为我们的代码提供了不可能击败的代码。</p><p> upb_pf32_1bt: # @upb_pf32_1bt mov rax, r9 shr rax, 24 bts r8, rax test r9b, r9b jne .LBB0_1 mov r10, r9 shr r10, 48 mov eax, dword ptr [rsi + 1] mov dword ptr [rdx + r10], eax add rsi, 5 jmp dispatch # TAILCALL.LBB0_1: jmp fallback # TAILCALL</p><p> upb_pf32_1bt：＃@ upb_pf32_1bt mov rax，r9 shr rax，24 bts r8，rax testr9b，r9b jne .lbb0_1 mov r10，r9 shr r10,48 mov eax，dword ptr [RSI + 1] MOV DWORD PTR [RDX + R10] ，eax添加RSI，5 JMP调度＃tailcall.lbb0_1：jmp倒下＃tailcall</p><p> Note that there is no prologue or epilogue, no register spills, indeed there isno usage of the stack whatsoever. The only exits are  jmps from the two tailcalls, but no code is required to forward the parameters, because the argumentsare already sitting in the correct registers. Pretty much the only improvementwe could hope for is to get a conditional jump for the tail call,  jnefallback, instead of  jne followed by  jmp.</p><p> 请注意，没有序列或外表，没有登记泄漏，确实有没有任何堆栈。唯一的出口是来自两个尾随的JMPS，但没有代码转发参数，因为ArgumerSare已经坐在正确的寄存器中。几乎唯一的改进我们可以希望获得尾呼叫的条件跳跃，而不是jne，而不是JMP。</p><p> If you were looking at a disassembly of this code without symbol information,you would have no reason to know that this was an entire function. It couldjust as easily be a basic block from a larger function. And that, in essence,is exactly what we are doing. We are taking an interpreter loop that isconceptually a big complicated function and programming it block by block,transferring control flow from one to the next via tail calls. We have fullcontrol of the register allocation at every block boundary (well, for sixregisters at least), and as long as the function is simple enough to not spillthose six registers, we’ve achieved our goal of keeping our most importantstate in registers throughout all of the fast paths.</p><p> 如果您在没有符号信息的情况下查看此代码的拆卸，则无理由知道这是整个功能。它可以轻松成为来自更大功能的基本块。并且本质上讲，正是我们正在做的事情。我们正在拍摄一个解释员循环，即通过块将控制流传输到下一个尾部，通过块是一个扫视的函数和编程它块。我们在每个块边界处拥有寄存器分配的全文（嗯，对于第六晶体至少），只要该功能足够简单到不溢出六个寄存器，我们已经实现了我们在全部寄存器中保持最重要的状态快速的路径。</p><p> We can optimize every instruction sequence independently, and crucially, thecompiler will treat each sequence as independent too because they are inseparate functions (we can prevent inlining with  noinline if necessary).This solves the problem we described earlier where the code from fallback pathswould degrade the code quality for fast paths. If we put the slow paths inentirely separate functions from the fast paths, we can be guaranteed thatthe fast paths will not suffer. The nice assembly sequence we see above iseffectively frozen, unaffected by any changes we make to other parts of theparser.</p><p> 我们可以独立优化每个指令序列，并且至关重要地，Thecompiler也将每个序列视为独立的序列，因为它们是insepatate函数（如果需要，我们可以防止与诺伊林联线的内联）。这解决了我们之前描述的问题，从后退路径可以降级用于快速路径的代码质量。如果我们将慢速路径放在快速路径中，我们可以保证快速的路径不会受到影响。我们看到的漂亮装配序列是无效的冻结，不受我们对特变格人的其他部分的任何改变的影响。 </p><p>  #define PARAMS unsigned RA, void *table, unsigned inst, \ int *op_p, double *consts, double *regs#define ARGS RA, table, inst, op_p, consts, regstypedef void (*op_func)(PARAMS);void fallback(PARAMS);#define UNLIKELY(x) __builtin_expect(x, 0)#define MUSTTAIL __attribute__((musttail))void ADDVN(PARAMS) { op_func *op_table = table; unsigned RC = inst &amp; 0xff; unsigned RB = (inst &gt;&gt; 8) &amp; 0xff; unsigned type; memcpy(&amp;type, (char*)&amp;regs[RB] + 4, 4); if (UNLIKELY(type &gt; -13)) { return fallback(ARGS); } regs[RA] += consts[RC]; inst = *op_p++; unsigned op = inst &amp; 0xff; RA = (inst &gt;&gt; 8) &amp; 0xff; inst &gt;&gt;= 16; MUSTTAIL return op_table[op](ARGS);}</p><p>#define params unsigned ra，void *表，无符号Inst，\ int * op_p，double * consts，double * regs＃定义args ra，table，Inst，op_p，consts，regstypedef void（* op_func）（params）; void bexprack （params）;＃定义不太可能（x）__builtin_expect（x，0）#define musttail __attribute __（（musttail））void addvn（params）{op_func * op_table = table;无符号rc = inst＆amp; 0xff; unsigned rb =（Inst＆gt;＆gt; 8）＆amp; 0xFF;无符号类型; Memcpy（＆amp;类型，（char *）＆amp; regs [rb] + 4,4）; if（不太可能（类型＆gt; -13））{返回回退（args）; } Regs [Ra] + = Const [RC]; inst = * op_p ++; unsigned op = inst＆amp; 0xFF; ra =（＆gt; 8）＆amp; 0xff; ＆gt;＆gt; = 16; musttail返回op_table [op]（args）;}</p><p>  ADDVN: # @ADDVN movzx eax, dh cmp dword ptr [r9 + 8*rax + 4], -12 jae .LBB0_1 movzx eax, dl movsd xmm0, qword ptr [r8 + 8*rax] # xmm0 = mem[0],zero mov eax, edi addsd xmm0, qword ptr [r9 + 8*rax] movsd qword ptr [r9 + 8*rax], xmm0 mov edx, dword ptr [rcx] add rcx, 4 movzx eax, dl movzx edi, dh shr edx, 16 mov rax, qword ptr [rsi + 8*rax] jmp rax # TAILCALL.LBB0_1: jmp fallback</p><p>  addvn：＃@addvn movzx eax，dh cmp dword ptr [r9 + 8 * rax + 4]，-12 jae .lbb0_1 movzx eax，dl movsd xmm0，qword ptr [r8 + 8 * rax]＃xmm0 = mem [0] ，Zero Mov EAX，EDI ADDSD XMM0，QWORD PTR [R9 + 8 * RAX] MOVSD QWORD PTR [R9 + 8 * RAX]，XMM0 MOV EDX，DWORD PTR [RCX]添加RCX，4 MOVZX EAX，DL MOVZX EDI，DH SHR EDX，16 MOV RAX，QWORD PTR [RSI + 8 * RAX] JMP RAX＃TAYCALL.LBB0_1：JMP倒退</p><p> The only opportunity for improvement I see here, aside from the  jne fallbackissue mentioned before, is that for some reason the compiler doesn’t want togenerate  jmp qword ptr [rsi + 8*rax]. Instead it prefers to load into  raxand then follow with  jmp rax. These are minor code generation issues thatcould hopefully be fixed in Clang without too much work.</p><p> 我在这里看到的唯一改进的机会，除了之前提到的jne starkissues，是由于某种原因，编译器不希望JMP QWORD PTR [RSI + 8 * rax]。相反，它更喜欢加载到raxand中，然后用JMP rax遵循。这些是次要代码生成问题，可以在没有太多的工作中固定在铿cl中的问题。</p><p>  One of the biggest caveats with this approach is that these beautiful assemblysequences get catastrophically pessimized if any non tail calls are present.Any non tail call forces a stack frame to be created, and a lot of data spillsto the stack.</p><p>  这种方法的最大警告之一是，如果存在任何非尾部呼叫，这些美丽的汇编序列会遭到灾难性困扰。无尾呼叫强制卷起堆栈帧，并且很多数据溢出堆栈。</p><p> #define PARAMS unsigned RA, void *table, unsigned inst, \ int *op_p, double *consts, double *regs#define ARGS RA, table, inst, op_p, consts, regs typedef  void  ( * op_func )( PARAMS ); void  fallback ( PARAMS ); #define UNLIKELY(x) __builtin_expect(x, 0)#define MUSTTAIL __attribute__((musttail)) void  ADDVN ( PARAMS )  {  op_func  * op_table  =  table ;  unsigned  RC  =  inst  &amp;  0xff ;  unsigned  RB  =  ( inst  &gt;&gt;  8 )  &amp;  0xff ;  unsigned  type ;  memcpy ( &amp; type ,  ( char * ) &amp; regs [ RB ]  +  4 ,  4 );  if  ( UNLIKELY ( type  &gt;  - 13 ))  {  // When we leave off &#34;return&#34;, things get real bad.  fallback ( ARGS );  }  regs [ RA ]  +=  consts [ RC ];  inst  =  * op_p ++ ;  unsigned  op  =  inst  &amp;  0xff ;  RA  =  ( inst  &gt;&gt;  8 )  &amp;  0xff ;  inst  &gt;&gt;=  16 ;  MUSTTAIL  return  op_table [ op ]( ARGS ); }</p><p> #define params unsigned ra，void *表，无符号Inst，\ int * op_p，double * consts，double * regs＃定义args ra，table，Inst，op_p，const，regs typedef void（* op_func）（params）; void倒退（参数）; #define不可能（x）__builtin_expect（x，0）#define musttail __attribute __（（musttail））void addvn（params）{op_func * op_table = table;无符号rc = inst＆amp; 0xff; unsigned rb =（Inst＆gt;＆gt; 8）＆amp; 0xFF;无符号类型; Memcpy（＆amp;类型，（char *）＆amp; regs [rb] + 4,4）; if（不太可能（类型＆gt;  -  13））{//当我们离开时＆＃34;返回＆＃34;，事情变得非常糟糕。倒退（args）; } Regs [Ra] + = Const [RC]; inst = * op_p ++; unsigned op = inst＆amp; 0xFF; ra =（＆gt; 8）＆amp; 0xFF; ＆gt;＆gt; = 16; musttail返回op_table [op]（args）; }</p><p>  ADDVN: # @ADDVN push rbp push r15 push r14 push r13 push r12 push rbx push rax mov r15, r9 mov r14, r8 mov rbx, rcx mov r12, rsi mov ebp, edi movzx eax, dh cmp dword ptr [r9 + 8*rax + 4], -12 jae .LBB0_1.LBB0_2: movzx eax, dl movsd xmm0, qword ptr [r14 + 8*rax] # xmm0 = mem[0],zero mov eax, ebp addsd xmm0, qword ptr [r15 + 8*rax] movsd qword ptr [r15 + 8*rax], xmm0 mov edx, dword ptr [rbx] add rbx, 4 movzx eax, dl movzx edi, dh shr edx, 16 mov rax, qword ptr [r12 + 8*rax] mov rsi, r12 mov rcx, rbx mov r8, r14 mov r9, r15 add rsp, 8 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp jmp rax # TAILCALL.LBB0_1: mov edi, ebp mov rsi, r12 mov r13d, edx mov rcx, rbx mov r8, r14 mov r9, r15 call fallback mov edx, r13d jmp .LBB0_2</p><p>  addvn：＃@addvn推送RBP推送R15推拉力推送R13推动R12推拉RBX推送RAX MOV R15，R9VOV R14，R8 MOV RBX，RCX MOV R12，RSI MOV EBP，EDI MOVZX EAX，DH CMP DWORD PTR [R9 + 8 * rax + 4]，-12 jae .lbb0_1.lb0_2：movzx eax，dl movsd xmm0，qword ptr [r14 + 8 * rax]＃xmm0 = mem [0]，zero mov eax，ebp addsd xmm0，qword ptr [r15 + 8 * rax] MOVSD QWORD PTR [R15 + 8 * rax]，XMM0 MOV EDX，DWORD PTR [RBX]添加RBX，4 MOVZX EAX，DL MOVZX EDI，DH SHR EDX，16 MOV RAX，QWORD PTR [R12 + 8 * rax] Mov RSI，R12 MOV RCX，RBX MOV R8，R14 MOV R9，R15添加RSP，8 Pop RBX Pop R12 Pop R13 Pop R14 Pop R15 Pop RBP JMP Rax＃TailAll.LBB0_1：Mov EDI，EBP MOV RSI，R12 MOV R13D，​​EDX MOV RCX，RBX MOV R8，R14 MOV R9，R15呼叫后退MOV EDX，R13D JMP .LBB0_2</p><p> To avoid this, we tried to follow a discipline of only calling other functionsvia inlining or tail calls. This can get annoying if an operation has multiplepoints at which an unusual case can occur that is not an error. For example,when we are parsing protobufs, the fast and common case is that varints areonly one byte long, but longer varints are not an error. Handling the unusualcase inline can compromise the quality of the fast path if the fallback code istoo complicated. But tail calling to a fallback function gives no way ofeasily resuming the operation once the unusual case is handled, so the fallbackfunction must be capable of pushing forward and completing the operation. Thisleads to code duplication and complexity.</p><p> 为了避免这种情况，我们试图遵循只呼吁其他职能VIA内联或尾呼叫的学科。如果操作具有多平面点，则这可能会令人讨厌，在此情况可能出现不寻常的情况并非错误。例如，当我们解析Protobuf时，快速和常见的情况是Varints很长，但较长的Varints不是错误。如果倒退代码istoo复杂，则处理不动画的内联危险可能会损害快速路径的质量。但是，一旦处理不寻常的情况，尾部呼叫返回函数就没有易于恢复操作，因此返回功能必须能够推动和完成操作。这表明是代码重复和复杂性。 </p><p> Ideally this issue could be solved by adding  __attribute__((preserve_most))to the fallback functions and then calling them normally, without tail calls.The  preserve_most attribute makes the callee responsible for preservingnearly all registers, which moves the cost of the register spills to thefallback functions where we want it. We experimented some with this attributebut ran into some mysterious problems that we were not able to get to thebottom of. It may have been an error on our part; revisiting this is futurework.</p><p>理想情况下，可以通过将__Attribute __（（preserve_most_most））添加到后退函数来解决这个问题，然后通常在没有尾部呼叫的情况下调用它们。Preserve_most属性使得Callee负责保存的所有寄存器，这将登记泄漏的成本移动到FableBack上我们想要的功能。我们尝试了一些attnumebut ran遇到了一些我们无法达到的神秘问题。这可能是我们的错误;重新审视这是蒙太作业。</p><p> The other major limitation is that  musttail is not portable. I very muchhope that the attribute will catch on, spreading to GCC, Visual C++, and otherpopular compilers, and even get standardized someday. But that day is far off,so what to do in the meantime?</p><p> 其他重大限制是Musttail不便携。我很多很多，属性将捕获，传播到GCC，Visual C ++和其他程序编制者，甚至有一天能够标准化。但那一天离现在，所以在此处怎么做？</p><p> When  musttail is not available, we need to perform at least one true return, without a tail call, for every conceptual loop iteration. We havenot yet implemented this fallback in upb, but I expect it will involve a macrothat either tail calls to dispatch or just returns, based on the availabilityof musttail.</p><p> 当不可用的时候，我们需要至少执行一个真正的返回，而无需尾呼叫，对于每个概念循环迭代。我们在upb中实现了这一倒退，但我希望它将涉及尾部呼叫派遣或只是返回的邮件，根据Musttail的可用性。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learned/">#learned</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>