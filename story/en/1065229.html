<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>行和列主要订单 Row- and Column-Major Order</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Row- and Column-Major Order<br/>行和列主要订单 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 07:43:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/71edac1303d5db5d6e53b1876007f220.png"><img src="http://img2.diglog.com/img/2021/6/71edac1303d5db5d6e53b1876007f220.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  In computing,  row-major order and  column-major order are methods for storing  multidimensional arrays in linear storage such as  random access memory.</p><p>跳转到导航跳转以搜索计算，行主要订单和列 - 主要订单是用于在线存储中存储多维阵列的方法，例如随机存取存储器。</p><p> The difference between the orders lies in which elements of an array are contiguous in memory. In row-major order, the consecutive elements of a row reside next to each other, whereas the same holds true for consecutive elements of a column in column-major order. While the terms allude to the rows and columns of a two-dimensional array, i.e. a  matrix, the orders can be generalized to arrays of any dimension by noting that the terms row-major and column-major are equivalent to  lexicographic and colexicographic orders, respectively.</p><p> 订单之间的差异在于，数组的元素在内存中连续。在行主要顺序中，行的连续元素彼此彼此驻留，而相同的是列在列主要订单中的连续元素中的连续元素。虽然术语暗示到二维阵列的行和列，即矩阵，但是订单可以通过注意到术语行 - 主要和列专业等同于词典和追加阶数，但是订单可以推广到任何维度的阵列。分别。</p><p> Data layout is critical for correctly passing arrays between programs written in different programming languages. It is also important for performance when traversing an array because modern CPUs process sequential data more efficiently than nonsequential data. This is primarily due to  CPU caching which exploits  spatial locality of reference.  [1] In addition, contiguous access makes it possible to use  SIMD instructions that operate on vectors of data. In some media such as tape or NAND  flash memory, accessing sequentially is  orders of magnitude faster than nonsequential access. [   citation needed]</p><p> 数据布局对于正确地传递以不同编程语言编写的程序之间的阵列至关重要。在遍历阵列时，由于现代CPU更有效地比非顺序数据更有效地进行阵列，它也很重要。这主要是由于CPU缓存，该CPU缓存利用了相应的空间局部。 [1]此外，连续访问使得可以使用在数据向量上运行的SIMD指令。在诸如磁带或NAND闪存之类的一些媒体中，顺序访问是比非顺序访问更快的数量级。 [所需的引用]</p><p>   The terms row-major and column-major stem from the terminology related to ordering objects. A general way to order objects with many attributes is to first group and order them by one attribute, and then, within each such group, group and order them by another attribute, etc. If more than one attribute participates in ordering, the first would be called  major and the last  minor. If two attributes participate in ordering, it is sufficient to name only the major attribute.</p><p>   术语行主要和列 - 主要茎与订购对象有关的术语。使用许多属性订购对象的一般方法是第一个组，然后按一个属性订购，然后，在每个这样的组中，组并通过另一个属性等命令。如果多于一个属性参与排序，则首先将被称为专业和最后一个未成年人。如果两个属性参与排序，则只有名称只有主要属性就足够了。</p><p> In the case of arrays, the attributes are the indices along each dimension. For  matrices in mathematical notation, the first index indicates the  row, and the second indicates the  column, e.g., given a matrix            A    {\displaystyle A}  ,              a    1  ,  2      {\displaystyle a_{1,2}}   is in its first row and second column. This convention is carried over to the syntax in programming languages,  [2] although often with  indexes starting at 0 instead of 1.  [3]</p><p> 在阵列的情况下，属性是每个维度的索引。对于数学符号中的矩阵，第一索引指示该行，第二个索引指示列，例如，给定矩阵A {\ DisplayStyle a}，1,2 {\ displaystyle a_ {1,2}}是它的第一个行和第二列。该公约在编程语言中进行到语法，[2]虽然通常以0而不是1. [3]开始索引而不是1. [3]</p><p> Even though the row is indicated by the  first index and the column by the  second index, no grouping order between the dimensions is implied by this. The choice of how to group and order the indices, either by row-major or column-major methods, is thus a matter of convention. The same terminology can be applied to even higher dimensional arrays. Row-major grouping starts from the  leftmost index and column-major from the  rightmost index, leading to  lexicographic and colexicographic (or colex) orders, respectively.</p><p> 即使行由第一个索引和第二索引表示第一个索引和列，它也没有暗示尺寸之间的分组顺序。因此，如何通过划线或列主要方法进行组和订购索引，因此是一个惯例。相同的术语可以应用于甚至更高的维数阵列。行主要分组从最右边指数的最左边的指数和列专业开始，分别导致词典和粘性（或Colex）订单。</p><p>  A  =      [          a    11         a    12         a    13            a    21         a    22         a    23       ]      {\displaystyle A={\begin{bmatrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\end{bmatrix}}}</p><p>  a = [a 11a 12 a 13a 22a 22a 22a 23] {\ displaystyle a = {\ begin {bmatrix} a_ {11}＆amp; a_ {12}＆amp; a_ {13} \\ a_ {21}＆amp ; a_ {22}＆amp; a_ {23} \ end {bmatrix}}} </p><p>   Different programming languages handle this in different ways. In  C, multidimensional arrays are stored in row-major order, and the array indexes are written row-first (lexicographical access order):</p><p>不同的编程语言以不同的方式处理此方法。在C中，多维阵列以行主要顺序存储，并且数组索引是写入行第一（词典接入顺序）：</p><p>  On the other hand, in  Fortran, arrays are stored in column-major order, while the array indexes are still written row-first (colexicographical access order):</p><p>  另一方面，在Fortran中，数组以列 - 主要顺序存储，而数组索引仍然写入行第一（Colexicographic Access Order）：</p><p>  Note how the use of  A[i][j] with multi-step indexing as in C, as opposed to a neutral notation like  A(i,j) as in Fortran, almost inevitably implies row-major order for syntactic reasons, so to speak, because it can be rewritten as  (A[i])[j], and the  A[i] row part can even be assigned to an intermediate variable that is then indexed in a separate expression. (No other implications should be assumed, e.g., Fortran is not column-major simply  because of its notation, and even the above implication could intentionally be circumvented in a new language.)</p><p>  注意如何使用[i] [j]与多步索引，如c中的多步索引，而不是像fortran中的（i，j）这样的中性符号，几乎不可避免地意味着句法原因，所以要说，因为它可以被重写为（[i]）[j]，并且甚至可以将A [i]行部件分配给中间变量，然后在单独的表达式中索引。 （不应假设其他影响，例如，Fortran不仅仅是因为它的符号而不是列，甚至可以用新语言故意规避上述含义。）</p><p> To use column-major order in a row-major environment, or vice versa, for whatever reason, one workaround is to assign non-conventional roles to the indexes (using the first index for the column and the second index for the row), and another is to bypass language syntax by explicitly computing positions in a one-dimensional array. Of course, deviating from convention probably incurs a cost that increases with the degree of necessary interaction with conventional language features and other code, not only in the form of increased vulnerability to mistakes (forgetting to also invert matrix multiplication order, reverting to convention during code maintenance, etc.), but also in the form of having to actively rearrange elements, all of which have to be weighed against any original purpose such as increasing performance. Running the loop row-wise is preferred in row-major languages like C and vice-versa for column-major languages.</p><p> 要在行主要环境中使用列主要订单，反之亦然，无论如何，一个解决方法是将非传统角色分配给索引（使用列的第一个索引和行的第二个索引），另一个是通过在一维数组中明确计算位置来绕过语言语法。当然，偏离了“公约”可能会产生与传统语言特征和其他代码的必要互动程度增加的成本，不仅以增加漏洞的增加的形式（忘记还反转矩阵乘法顺序，在代码期间恢复惯例）维护等），但也以必须主动重新排列元件的形式，所有这些都必须根据任何原始目的进行称重，例如越来越多的性能。运行循环行，是C的行主要语言，如C的行主要语言是优选的，反之亦为列主要语言。</p><p>  Programming languages or their standard libraries that support multi-dimensional arrays typically have a native row-major or column-major storage order for these arrays.</p><p>  支持多维阵列的编程语言或其标准库通常具有用于这些数组的本机行 - 主要或列主要存储顺序。</p><p> Row-major order is used in  C/ C++/ Objective-C (for C-style arrays),  PL/I,  [4]  Pascal,  [5]  Speakeasy, [   citation needed]  SAS,  [6] and  Rasdaman.  [7]</p><p> 行主要订单用于C / C ++ / Objective-C（对于C型阵列），PL / I，[4] Pascal，[5]宣传，[引用] SAS，[6]和Rasdaman。 [7]</p><p>   A typical alternative for dense array storage is to use  Iliffe vectors, which typically store elements in the same row contiguously (like row-major order), but not the rows themselves. They are used in (ordered by age):  Java,  [13]  C#/ CLI/ .Net,  Scala,  [14] and  Swift.</p><p>   密集阵列存储的典型替代方案是使用ILIFFE矢量，该载体通常连续地存储同一行中的元素（如行主要顺序），但不是行本身。它们用于（按年龄订购）：Java，[13] C＃/ CLI / .NET，SCALA，[14]和SWIFT。 </p><p> Even less dense is to use lists of lists, e.g., in  Python,  [15] and in the  Wolfram Language of  Wolfram Mathematica.  [16]</p><p>甚至更少的密度是使用列表，例如，在Python，[15]和Wolfram Mathematica的Wolfram语言中。 [16]</p><p>   Support for multi-dimensional arrays may also be provided by external libraries, which may even support arbitrary orderings, where each dimension has a stride value, and row-major or column-major are just two possible resulting interpretations.</p><p>   对于多维阵列的支持也可以由外部库提供，其甚至可以支持任意排序，其中每个维度具有步幅值，并且行 - 主要或列 - 主要只是两个可能的结果的解释。</p><p>   A special case would be  OpenGL (and  OpenGL ES) for graphics processing. Since &#34;recent mathematical treatments of linear algebra and related fields invariably treat vectors as columns,&#34; designer Mark Segal decided to substitute this for the convention in predecessor  IRIS GL, which was to write vectors as rows; for compatibility, transformation matrices would still be stored in vector-major (=row-major) rather than coordinate-major (=column-major) order, and he then used the trick &#34;[to] say that matrices in OpenGL are stored in column-major order&#34;.  [20] This was really only relevant for presentation, because matrix multiplication was stack-based and could still be interpreted as post-multiplication, but, worse, reality leaked through the C-based  API because individual elements would be accessed as  M[vector][coordinate] or, effectively,  M[column][row], which unfortunately muddled the convention that the designer sought to adopt, and this was even preserved in the  OpenGL Shading Language that was later added (although this also makes it possible to access coordinates by name instead, e.g.,  M[vector].y). As a result, many developers will now simply declare that having the column as the first index is the definition of column-major, even though this is clearly not the case with a real column-major language like Fortran.</p><p>   一个特殊情况将是用于图形处理的OpenGL（和OpenGL ES）。自从＆＃34;最近的线性代数和相关领域的数学处理总是将载体视为列，＆＃34;设计师Mark Segal决定在前任IRIS GL中替换为“公约”，这是将载体写为行;为了兼容性，转换矩阵仍将存储在Vector-major（=行 - 主要）中而不是坐标 - 主要（=列 - 主要）顺序中，然后他使用诀窍＆＃34; [to]说OpenGL中的矩阵存储在列主要订单中＆＃34; [20]这实际上只与演示文稿相关，因为矩阵乘法是基于堆栈的，并且仍然可以被解释为乘法后，但更糟糕的是，由于单个元素将被访问为M [矢量[坐标]或有效地，M [列] [行]，这不幸的是，这使得设计师所寻求采用的惯例，并且这甚至在后来添加的OpenGL着色语言中保存（尽管这也可以实现按名称访问坐标，例如，m [向量] .y）。因此，许多开发人员现在将简单地声明将列作为第一个索引的定义是列专业的定义，即使这显然不是像Fortran这样的真实列主要语言的情况。</p><p>   As exchanging the indices of an array is the essence of  array transposition, an array stored as row-major but read as column-major (or vice versa) will appear transposed. As actually performing this  rearrangement in memory is typically an expensive operation, some systems provide options to specify individual matrices as being stored transposed. The programmer must then decide whether or not to rearrange the elements in memory, based on the actual usage (including the number of times that the array is reused in a computation).</p><p>   作为交换阵列的指标是阵列转换的本质，将作为row-mark存储但读取为列 - 主要（或反之亦然）的数组将出现转换。由于在存储器中实际执行该重新排列通常是昂贵的操作，一些系统提供了将单个矩阵指定存储转置的选项。然后，程序员必须根据实际使用（包括阵列在计算中重用的次数）来决定是否重新排列内存中的元素。</p><p> For example, the  Basic Linear Algebra Subprograms functions are passed flags indicating which arrays are transposed.  [23]</p><p> 例如，基本的线性代数子程序函数是通过指示转置的阵列的标志。 [23]</p><p>   For a  d-dimensional              N    1    ×    N    2    ×  ⋯  ×    N    d      {\displaystyle N_{1}\times N_{2}\times \cdots \times N_{d}}   array with dimensions  N  k ( k=1... d), a given element of this array is specified by a  tuple            (    n    1    ,    n    2    ,  …  ,    n    d    )    {\displaystyle (n_{1},n_{2},\ldots ,n_{d})}   of  d (zero-based) indices              n    k    ∈  [  0  ,    N    k    −  1  ]    {\displaystyle n_{k}\in [0,N_{k}-1]}  .</p><p>   对于D维N 1×N 2×⋯×n d {\ displaystyle n_ {1} \ times n_ {2} \ times \ cdots \ times n_ {d}} vileions n k（k = 1 .. .D），该阵列的给定元素由元组（n 1，n 2，...，nd）指定{\ displaystyle（n_ {1}，n_ {2}，\ ldots，n_ {d}）} D（零基）索引NK [0，n k  -  1] {\ displaystyle n_ {k} \在[0，n_ {k} -1]}中。</p><p> In row-major order, the  last dimension is contiguous, so that the memory-offset of this element is given by:</p><p> 在行主要顺序中，最后一个维度是连续的，因此此元素的内存偏移量由以下给出： </p><p> n    d    +    N    d    ⋅  (    n    d  −  1    +    N    d  −  1    ⋅  (    n    d  −  2    +    N    d  −  2    ⋅  (  ⋯  +    N    2      n    1    )  ⋯  )  )  )  =    ∑    k  =  1     d      (      ∏    ℓ  =  k  +  1     d      N    ℓ     )     n    k      {\displaystyle n_{d}+N_{d}\cdot (n_{d-1}+N_{d-1}\cdot (n_{d-2}+N_{d-2}\cdot (\cdots +N_{2}n_{1})\cdots )))=\sum _{k=1}^{d}\left(\prod _{\ell =k+1}^{d}N_{\ell }\right)n_{k}}</p><p>nd + n d⋅（nd  -  1 + n d-1⋅（nd  -  2 + n d-2⋅（⋯+ n 2 n 1）⋯））））=σk= 1 d（π= k + 1 d nℓ）nk {\ displaystyle n_ {d} + n_ {d} \ cdot（n_ {d-1} + n_ {d-1} \ cdot（n_ {d-2} + n_ {d-2} \ CDOT（\ cdots + n_ {2} n_ {1}）\ cdots）））= \ sum _ {k = 1} ^ {d} \ left（\ prod _ {\ ell = k + 1} ^ {d} n _ {\ ell} \右）n_ {k}}</p><p> In column-major order, the  first dimension is contiguous, so that the memory-offset of this element is given by:</p><p> 在列主要顺序中，第一维度是连续的，因此该元素的内存偏移量由以下给出：</p><p> n    1    +    N    1    ⋅  (    n    2    +    N    2    ⋅  (    n    3    +    N    3    ⋅  (  ⋯  +    N    d  −  1      n    d    )  ⋯  )  )  )  =    ∑    k  =  1     d      (      ∏    ℓ  =  1     k  −  1      N    ℓ     )     n    k      {\displaystyle n_{1}+N_{1}\cdot (n_{2}+N_{2}\cdot (n_{3}+N_{3}\cdot (\cdots +N_{d-1}n_{d})\cdots )))=\sum _{k=1}^{d}\left(\prod _{\ell =1}^{k-1}N_{\ell }\right)n_{k}}</p><p> n 1 + n 1⋅（n 2 + n 2⋅（n 3 + n 3⋅（⋯+ n d-1 nd）⋯）））=σk= 1d（π= 1 k  -  1 n =） nk {\ displaystyle n_ {1} + n_ {1} \ cdot（n_ {2} + n_ {2} \ cdot（n_ {3} + n_ {3} \ cdot（\ cdots + n_ {d-1} n_ {d}）\ cdots））））= \ sum _ {k = 1} ^ {d} \ left（\ prod _ {\ ell = 1} ^ {k-1} n _ {\ ell} \ revaly）n_ { k}}</p><p> where the  empty product is the multiplicative  identity element, i.e.,              ∏    ℓ  =  1     0      N    ℓ    =    ∏    ℓ  =  d  +  1     d      N    ℓ    =  1    {\displaystyle \prod _{\ell =1}^{0}N_{\ell }=\prod _{\ell =d+1}^{d}N_{\ell }=1}  .</p><p> 其中空产品是乘法标识元素，即π= 1 0n≥=π= d + 1 dn∈= 1 {\ displaystyle \ prod _ {\ ell = 1} ^ {0} n _ {\ ell} = \ prod _ {\ ell = d + 1} ^ {d} n _ {\ ell} = 1}。</p><p> For a given order, the  stride in dimension  k is given by the multiplication value in parentheses before index  n  k in the right hand-side summations above.</p><p> 对于给定的顺序，尺寸k中的步幅被递送值在上面的右手侧求和中的索引n k之前的括号中给出。</p><p> More generally, there are  d! possible orders for a given array, one for each  permutation of dimensions (with row-major and column-order just 2 special cases), although the lists of stride values are not necessarily permutations of each other, e.g., in the 2-by-3 example above, the strides are (3,1) for row-major and (1,2) for column-major.</p><p> 更一般地，有D！对于给定阵列的可能订单，一个用于每个尺寸的允许（带有行 - 主要和列 - 订单只有2个特殊情况），但步幅值的列表不一定彼此置换，例如，在2逐个中3上面的一个例子，行长的寿命是（3,1），用于柱专业的（1,2）。</p><p>  Morton order, another way of mapping multidimensional data to a one-dimensional index, useful in tree data structures</p><p>  Morton命令，将多维数据映射到一维索引的另一种方式，可用于树数据结构 </p><p>  ^     &#34;Language Reference Version 4 Release 3&#34;  (PDF). IBM .  Initial values specified for an array are assigned to successive elements of the array in row-major order (final subscript varying most rapidly).</p><p>^＆＃34;语言参考版本4版本3＆＃34; （PDF）。 IBM。为数组指定的初始值被分配给阵列的连续元素，以行主要订单（最终下标变化最快）。</p><p> ^     &#34;ISO/IEC 7185:1990(E)&#34;  (PDF).  An array-type that specifies a sequence of two or more index-types shall be an abbreviated notation for an array-type specified to have as its index-type the first index-type in the sequence and to have a component-type that is an array-type specifying the sequence of index-types without the first index-type in the sequence and specifying the same component-type as the original specification.</p><p> ^＆＃34; ISO / IEC 7185：1990（E）＆＃34; （PDF）。指定两个或多个索引类型序列的数组类型应是指定的数组类型的缩写符号，以序列中的索引类型键入第一个索引类型，并且具有符号类型一个数组类型，指定序列中的第一个索引类型的索引类型序列，并指定与原始规范相同的组件类型。</p><p> ^     &#34;SAS® 9.4 Language Reference: Concepts, Sixth Edition&#34;  (PDF). SAS Institute Inc. September 6, 2017. p. 573 .  From right to left, the rightmost dimension represents columns; the next dimension represents rows. [...] SAS places variables into a multidimensional array by filling all rows in order, beginning at the upper left corner of the array (known as row-major order).</p><p> ^＆＃34;SAS®9.4语言参考：概念，第六版＆＃34; （PDF）。 SAS Institute Inc. 2017年9月6日.. p。 573。从右到左，最右边的维度代表列;下一个维度代表行。 [...] SAS通过按顺序填充所有行，从阵列的左上角开始（称为行主要订单），将变量放置到多维数组中。</p><p>   ^   Spiegelhalter et al. (2003, p. 17):    Spiegelhalter, David; Thomas, Andrew;  Best, Nicky; Lunn, Dave (January 2003), &#34;Formatting of data: S-Plus format&#34;,   WinBUGS User Manual  (PDF) (Version 1.4 ed.), Cambridge, UK: MRC Biostatistics Unit, Institute of Public Health, archived from  the original  (PDF) on 2003-05-18</p><p>   ^ spiegelhalter等。 （2003，第17页）：斯皮格尔哈尔特，大卫;托马斯，安德鲁;最好的，尼基; Lunn，Dave（2003年1月），＆＃34;数据的格式：S-Plus格式＆＃34;，Winbugs用户手册（PDF）（1.4版），剑桥，英国：MRC生物卫生学单位，公共卫生研究所，从2003-05-18上存档（PDF）</p><p>   ^     &#34;FFTs with multidimensional data&#34;.  Scilab Wiki .  Because Scilab stores arrays in column major format, the elements of a column are adjacent (i.e. a separation of 1) in linear format.</p><p>   ^＆＃34; FFT与多维数据＆＃34; Scilab Wiki。由于Scilab以列主要格式存储数组，所以列的元素是线性格式的相邻（即分离1）。</p><p>       ^     &#34;Eigen: Storage orders&#34;.  eigen.tuxfamily.org .  If the storage order is not specified, then Eigen defaults to storing the entry in column-major.</p><p>       ^＆＃34; eigen：存储订单和＃34; eigen.tuxfamily.org。如果未指定存储顺序，则egen默认为存储列中的条目。</p><p>  Donald E. Knuth,   The Art of Computer Programming Volume 1: Fundamental Algorithms, third edition, section 2.2.6 (Addison-Wesley: New York, 1997).</p><p>  Donald E. Knuth，计算机编程艺术1：基础算法，第三版，第2.2.6节（Addison-Wesley：纽约，1997）。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">https://en.wikipedia.org/wiki/Row-_and_column-major_order</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/行和列/">#行和列</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/column/">#column</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>