<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在戈兰尼尔兔洞下来 Down the Golang Nil Rabbit Hole</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Down the Golang Nil Rabbit Hole<br/>在戈兰尼尔兔洞下来 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 12:04:50</div><div class="page_narrow text-break page_content"><p>I’m not sure I have another Rust &amp; Postgres blog post in me right now, solet’s learn something about Go instead.</p><p>我不确定我还有另一个生锈＆amp; Postgres在我身上博客帖子现在，唯一的学习了一些关于去的东西。</p><p> Recently I decided I wanted to add a  --unique flag to omegasort. Wait, what’somegasort?</p><p> 最近我决定我想向Omegasort添加一个 -  unique标志。等等，有什么看法？</p><p> It’s a text file sorting tool that supports lots of different sortingmethods. For example, in addition a standard text sort, it can sort numberedlines, date-prefixed lines, paths (including Windows paths with and withoutdrive letters), IP addresses, and IP networks. It also supports Unicodelocales, reverse sorting, and locale-aware case insensitive sorting.</p><p> 这是一个文本文件排序工具，支持许多不同的排序方法。例如，此外，另外一个标准文本排序，它可以对NumberEedLines，日期前缀行，路径（包括Windows Paths包含Windows路径），IP地址和IP网络。它还支持Unicodelocales，反向排序和语言环境感知差点分类。</p><p> I use it together with  preciousto sort things like  .gitignore files, spellchecker allowlists, and things ofthat nature.</p><p> 我将它与preciouso排序的东西一起使用，如.gitignore文件，拼写检查程序alletlists和thatthatthatthat的东西。</p><p> I realized that I really wanted a  --unique flag for all of this. While Icould just pipe its output to  uniq on a *nix system, this doesn’t work sowell on Windows. Plus with tools like precious it’s easier if I can use onebinary for a given task. If I want to pipe things I have to put that in ashell script that precious calls.</p><p> 我意识到我真的想要一个 - 所有这一切的国旗。虽然Icould在* nix系统上将其输出输出到Uniq，但这在Windows上不起作用。此外，如果我可以为特定任务使用一个单一的任务，那么用工具可以更容易。如果我想用管东西在阿什尔脚本中掌握那种宝贵的电话。</p><p> But my rabbit hole experience didn’t happen with omegasort directly. Instead,it happened when I tried to add some integration tests.</p><p> 但我的兔子洞经验没有直接用omegasort发生。相反，它发生在我尝试添加一些集成测试时发生。</p><p> While writing those integration tests, I was using  github.com/houseabsolute/detest. Thisis a Golang package I created that offers a test assertion interface inspiredby   Test2-Suite in Perl.</p><p> 在编写这些集成测试时，我使用github.com/houseabsolute/detest。 ITINIS I创建的Golang软件包，提供了一个测试断言界面，它在Perl中的Test2-Suite启发。 </p><p>  use  Test2::Suite ; object  Subtest  =&gt;  sub  {  call  name  =&gt;  &#39;TestsFor::Basic&#39; ;  call  pass  =&gt;  T ();  call  subevents  =&gt;  array  {  object  Plan  =&gt;  sub  {  call  max  =&gt;  4 ;  call  trace  =&gt;  object  {  call  package  =&gt;  &#39;Test::Class::Moose::Role::Executor&#39; ;  call  subname  =&gt;  &#39;Test::Class::Moose::Util::context_do&#39; ;  };  };  ... }</p><p>使用test2 ::套房;对象subtest =＆gt;子{呼叫名称=＆gt; ＆＃39; testsfor :: basic＆＃39; ;呼叫通行证=＆gt; T（）;呼叫子宫=＆gt;数组{对象计划=＆gt;子{呼叫max =＆gt; 4;呼叫跟踪=＆gt;对象{呼叫包=＆gt; ＆＃39; test :: class :: moose ::角色:: executor＆＃39; ;呼叫子名称=＆gt; ＆＃39; test :: class :: moose :: util :: context_do＆＃39; ; }; }; ...}</p><p> I think this is pretty self-explanatory, except for  T(), which means “true”.</p><p> 除了T（）外，我认为这是非常自我解释的，这意味着“真实”。</p><p>  import  (	 &#34;testing&#34;	 &#34;github.com/houseabsolute/detest/pkg/detest&#34; ) func  TestSomething ( t  * testing . T )  {	 d  :=  detest . New ( t )	 d . Is (		 someStruct ,		 d . Struct ( func ( st  * detest . StructTester )  {			 st . Field ( &#34;size&#34; ,  43 )			 st . Field ( &#34;Name&#34; ,  &#34;Douglas&#34; )			 d . Map ( func ( mt  * detest . MapTester )  {				 mt . Key ( &#34;foo&#34; ,  d . Slice ( func ( st  * detest . SliceTester )  {					 st . Idx ( 0 ,  d . Map ( func ( mt  * detest . MapTester )  {						 mt . Key ( &#34;bar&#34; ,  d . Slice ( func ( st  * detest . SliceTester )  {							 st . Idx ( 1 ,  &#34;buz&#34; )							 st . Idx ( 2 ,  &#34;not quux&#34; )						 }))					 }))					 st . Idx ( 1 ,  d . Map ( func ( mt  * detest . MapTester )  {						 mt . Key ( &#34;nosuchkey&#34; ,  d . Slice ( func ( st  * detest . SliceTester )  {							 st . Idx ( 1 ,  &#34;buz&#34; )							 st . Idx ( 2 ,  &#34;not quux&#34; )						 }))					 }))				 }))			 })		 }),	 ) }</p><p>  进口（＆＃34;测试＆＃34;＆＃34; github.com/houseabsolute/detest/pkg/detest& lap34;）func testsomething（t * testing。t）{d：=讨厌。新（t）d。是（somestuct，d。struct（stecc（st * detest。Structtester）{st。字段（＆＃34; size＆＃34; 43）st。字段（＆＃34;名称＆＃34;和＃34;道格拉斯＆ ＃34;）d。地图（Func（MT *抢劫）{Mt。钥匙（＆＃34; foo＆＃34; d。切片（Func（st * dibestess）{st。Idx（0，d 。地图（Func（MT *抢劫）{MT.键（＆＃34;酒吧＆＃34;，d。切片（Func（st *抢劫）{st。idx（1，＆＃34; buz＆＃ 34;）ST。IDX（2，＆＃34;不是QUUX＆＃34;）}）））））}））ST。IDX（1，D. MAP（FUNC（MT *讨论）MAPTESTER）{MT。键（＆＃ 34; Nosuchkey＆＃34;，d。切片（Func（ST *抢劫。Slicetester）{ST。IDX（1，＆＃34; Buz＆＃34; Buz＆＃34;）st。Idx（2，＆＃34;不是QUUX＆＃34; ）}））}））}）}）}），）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）}）。</p><p> It’s not as nice as the Perl version because it gets quite verbose, but thiswas the closest I could come. Go’s type system, combined with a lack ofsyntactic flexibility, means a whole lot of func calls, braces, and parens.</p><p> 它不像Perl版本那么好，因为它变得非常冗长，但是我可以来的最接近的。 Go的类型系统，结合缺乏个性的灵活性，意味着整个努力呼叫，牙套和柱子。</p><p> Under the hood, this is implemented with a metric fork ton of runtimereflection using the stdlib’s   reflectpackage. I don’t love this, but absent generics,there’s no other way to implement this sort of API except with codegeneration. And that codegen would have to be fed by a sort-of-Go languagethat was translated to real Go, which seems like a terrible idea.</p><p> 在引擎盖下，这是使用STDLIB的反射包装的公制叉吨RuntimeReflection实现。我不喜欢这个，但缺乏泛型，除了Codegeneration之外，没有其他方法可以实现这种API。那据，该代码必须由一个anabagethat被翻译成真实的and，这似乎是一个可怕的想法。</p><p>  So while I was writing those omegasort integration tests using detest, Imanaged to find a whole lot of bugs in detest.</p><p>  因此，虽然我正在使用讨论者编写那些omegasort集成测试，但致命地发现讨论了很多错误。</p><p>  So here’s a fun fact, Go has multiple “types” of  nil. Specifically, thereare both typed and untyped  nil variables. This surprised me at first, but itmakes sense when you think about it.</p><p>  所以这是一个有趣的事实，Go有多种“类型”的零。具体而言，身体既可键入和没有型号的零变量。这首先惊讶了我，但是当你想到它时它就会感觉到。 </p><p>  package  main import  (	 &#34;fmt&#34;	 &#34;reflect&#34; ) func  main ()  {	 v1  :=  reflect . ValueOf ( nil )	 var  uninit  [] int	 v2  :=  reflect . ValueOf ( uninit )	 logValue ( &#34;nil&#34; ,  v1 )	 logValue ( &#34;[]int&#34; ,  v2 )	 fmt . Printf ( &#34;[]int == nil? %v\n&#34; ,  uninit  ==  nil ) } func  logValue ( what  string ,  v  reflect . Value )  {	 fmt . Printf ( &#34;%s is valid? %v\n&#34; ,  what ,  v . IsValid ())	 if  v . IsValid ()  {		 fmt . Printf ( &#34;%s is nil? %v\n&#34; ,  what ,  v . IsNil ())		 fmt . Printf ( &#34;%s type = %v\n&#34; ,  what ,  v . Type ())	 } }</p><p>包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{v1：=反映。 valueof（nil）var uninit [] int v2：=反射。 valueof（uninit）logvalue（＆＃34; nil＆＃34;，v1）logvalue（＆＃34; [] int＆＃34;，v2）fmt。 printf（＆＃34; [] int == nil？％v \ n＆＃34;，uninit == nil）} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}}</p><p>  nil is valid? false[]int is valid? true[]int is nil? true[]int type = []int[]int == nil? true</p><p>  nil有效？假[] int有效？真实[] int是nil？ true [] int type = [] int [] int == nil？真的</p><p> So a bare  nil and a variable that has a type but no value are equal, but ifyou try to get a  reflect.Value for  nil, it’s not valid. If you try to callother methods like  v.IsNil() or  v.Type() on an invalid  2  reflect.Value,you will get a panic.</p><p> 所以一个裸露的nil和一个有一个类型但没有值的变量是相等的，但如果你试图得到一个反射。对于nil，它无效。如果您尝试在无效的2 reflex.value上调用V.Isnil（）或v.type（）这样的其他方法.Value，您将获得恐慌。</p><p> I encountered this when trying to test that an  error returned by a func callwas  nil.</p><p> 我在尝试测试Func Callwas Nil返回的错误时遇到过这一点。</p><p> This led to a flurry of   detestreleases as I realized howmany parts of the  detest code this impacted. In most places where it uses reflect, I have to guard against a bare  nil being passed in.</p><p> 这导致了一系列的拆除术，因为我意识到这种受影响的遗弃代码的HowMany部分。在它使用的大多数地方，我必须防范裸露的零。</p><p> But wait, it gets even more confusing. Sometimes the Go compiler will turn anuntyped  nil into a typed  nil. Here’s an example  3:</p><p> 但等等，它变得更加令人困惑。有时，Go编译器将将AnUnty Nil转换为键入的NIL。这是一个例子3：</p><p> package  main import  (	 &#34;fmt&#34;	 &#34;reflect&#34; ) func  main ()  {	 takesSlice ( &#34;nil&#34; ,  nil )	 var  uninit  [] int	 takesSlice ( &#34;[]int&#34; ,  uninit ) } func  takesSlice ( what  string ,  s  [] int )  {	 logValue ( what ,  reflect . ValueOf ( s )) } func  logValue ( what  string ,  v  reflect . Value )  {	 fmt . Printf ( &#34;%s is valid? %v\n&#34; ,  what ,  v . IsValid ())	 if  v . IsValid ()  {		 fmt . Printf ( &#34;%s is nil? %v\n&#34; ,  what ,  v . IsNil ())		 fmt . Printf ( &#34;%s type = %v\n&#34; ,  what ,  v . Type ())	 } }</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{ta​​kesslice（＆＃34; nil＆＃34;，nil）var uninit [] int tapesslice（＆＃34; [] int＆＃34;，uninit）} func takesslice（什么字符串，s [] int）{logvalue（什么，反映。valyof（s））} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}} </p><p>  nil is valid? truenil is nil? truenil type = []int[]int is valid? true[]int is nil? true[]int type = []int</p><p>nil有效？ Truenil是零吗？ truenil type = [] int [] int有效？真实[] int是nil？ true [] int type = [] int</p><p> So when I pass a bare  nil to  takesSlice, it gets typed as whatever typethe function’s signature says it should be.</p><p> 因此，当我裸露的零才能传递给Taklice时，它会被打字，就像典型的函数的签名所说应该是。</p><p> But wait, it gets even more confusing yet again! Sometimes the Go compiler won’t turn an untyped  nil into a typed  nil. Here’s an example  4:</p><p> 但等等，它又更加困惑！有时，Go编译器不会将一个没有型号的NIL转换为键入的NIL。这是一个例子4：</p><p> package  main import  (	 &#34;fmt&#34;	 &#34;reflect&#34; ) func  main ()  {	 takesError ( &#34;nil&#34; ,  nil )	 var  uninit  error	 takesError ( &#34;error&#34; ,  uninit ) } func  takesError ( what  string ,  e  error )  {	 logValue ( what ,  reflect . ValueOf ( e )) } func  logValue ( what  string ,  v  reflect . Value )  {	 fmt . Printf ( &#34;%s is valid? %v\n&#34; ,  what ,  v . IsValid ())	 if  v . IsValid ()  {		 fmt . Printf ( &#34;%s is nil? %v\n&#34; ,  what ,  v . IsNil ())		 fmt . Printf ( &#34;%s type = %v\n&#34; ,  what ,  v . Type ())	 } }</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34;反映＆＃34;）func main（）{ta​​keerror（＆＃34; nil＆＃34;，nil）var uninit retererror（＆＃34;错误＆＃ 34;，UNINIT）} FUNC TAKERROR（什么字符串，E错误）{LOGVALUE（什么，反映。value（e））} func logvalue（什么字符串，v反映。值）{fmt。 printf（＆＃34;％s有效？％v \ n＆＃34;，什么，v。isvalid（））如果v。 isvalid（）{fmt。 printf（＆＃34;％s是nil？％v \ n＆＃34;，什么，v。isnil（））fmt。 printf（＆＃34;％s type =％v \ n＆＃34;，什么，v. type（））}}</p><p> If the type of the argument in the function signature is any type ofinterface, including  interface{}, then the underlying value is still untypedand not valid. This &amp;mldr sort of makes sense? I think the way this works isthat anything typed as an interface also has a  real underlying type. So an error can be an  errors.errorString or an  exec.ExitError or a mypackage.DogError. But if we pass a bare  nil or an uninitializedvariable, there’s no underlying type.</p><p> 如果函数签名中的参数的类型是任何类型的接口，包括接口{}，那么底层值仍然是untypedand而无效。这个＆amp; mldr有意义吗？我认为这项工作的方法是作为界面键入的东西也有一个真正的底层类型。所以错误可以是错误.Errorring或exec.exitError或mypackage.dogError。但如果我们通过裸露的零或未初始化的Variable，那么没有底层类型。</p><p> This came up with detest when I wanted to test that I  didn’t get an errorfrom a call.</p><p> 当我想测试我没有收到错误时，这提出了困难。</p><p>  Under the hood, the signature for  d.Is() uses  interface{} for the twoarguments being compared. So bare  nil as the second argument will  never bevalid. And the first argument might be valid or it might not be. If doThing()’s return type is just  error and it returns a  nil, then thevalue in  err has no type.</p><p>  在引擎盖下，D.is（）的签名使用界面{}进行比较的双轨。如此裸露的，因为第二个论点永远不会是无效的。第一个参数可能有效或可能不是。如果dothing（）的返回类型只是错误，并且它返回一个nil，那么Err中的Value没有类型。 </p><p> All of this led to a fair bit more code in the  detest guts to handlethis. For example, just because two variables don’t have the same type doesn’tmean they’re not equal (from Go’s perspective). A bare  nil and anuninitialized slice are equal when compared with  ==, which is what  d.Is()emulates using  reflect.</p><p>所有这一切都导致了讨论的比特在讨论的肠道中的代码。例如，因为两个变量没有相同的类型，但它们不等于（从Go的角度来看）。与==相比，裸零和anuninitialized切片相等，这是D.IS（）使用反射模拟的。</p><p> So there’s quite a few cases around one or both arguments being invalid thatneed handling. And there are MANY other methods with the same issues toconsider, including things like  d.Map() and  d.Struct, all of which shouldhandle an invalid value properly.</p><p> 因此，在一个或两个参数上存在相当多的案例无效的处理。还有许多具有同一问题的其他方法，包括D.Cap（）和d.struct等内容，所有这些都应该正确处理无效值。</p><p>  Well, I don’t know  that many other languages. In Perl this isn’t really athing, because it has a pretty minimal type system. Perl’s  undef can becoerced to lots of things, although under strict trying to use an  undef in certainways is an error, like writing this:</p><p>  好吧，我不知道很多其他语言。在Perl中，这并不是真正的阴沉，因为它具有一个非常最小的系统。 Perl的Undef可以因为在严格试图在特定的时候在严格尝试时是一个错误，就像写这一点一样：</p><p>  This will blow up with  Can&#39;t use an undefined value as an ARRAY reference ... at line 2.</p><p>  这将爆炸罐＆＃39; t在第2行使用未定义的值作为数组参考。</p><p> Rust (at least safe Rust  5) doesn’t have any notion of  nil or undefinedvalues. Instead, you have the  Option&lt;T&gt; type,which always has a type. For example  6:</p><p> RUDE（至少安全生锈5）没有任何缺陷或未定义的valiues。相反，您有选项＆lt; t＆gt;始终具有类型的类型。例如6：</p><p> pub   fn  main ()   {    let   a:  Option &lt; String &gt;   =   None ;    let   b:  Option &lt; i32 &gt;   =   None ;    println ! ( &#34;a == b? {}&#34; ,   a   ==   b );   }</p><p> PUB FN MAIN（）{让答：选项＆lt;字符串＆gt; =没有;让B：选项＆lt; I32＆gt; =没有; println！ （＆＃34; a == b？{}}＆＃34;，a == b）; }</p><p> This just won’t compile. While both  a and  b are  None, they’re not the same type of  None so you can’t just compare them with  ==. The compilersays:</p><p> 这将无法编译。虽然A和B都没有，但它们不是相同的无，所以你不能用==比较它们。编译： </p><p> error[E0308]: mismatched types --&gt; src/main.rs:4:33 |4 | println!(&#34;a == b? {}&#34;, a == b); | ^ expected struct `String`, found `i32` | = note: expected enum `Option&lt;String&gt;` found enum `Option&lt;i32&gt;`</p><p>错误[E0308]：不匹配类型 - ＆gt; src / main.rs：4：33 | 4 | println！（＆＃34; a == b？{}}}}}}} == b）; | ^预期的struct` string`，发现`i32` =注意：预期enum`选项＆lt; string＆gt;'找到enum`选项＆lt; i32＆gt;`</p><p> By the way, aren’t these Rust compiler errors nice? The only other languageI’ve seen with this type of extremely detailed compiler errors is Raku.</p><p> 顺便问一下，不是这些生锈编译器错误很好吗？使用此类极其详细的编译器错误的唯一其他语言是Raku。</p><p>  It’s tempting to pick on Go and complain about it. I certainly do that a lotat work. But to be fair, this really isn’t an issue for most Go code. It’sonly because I’m trying to do weird stuff with  reflect that I’m learningabout this internal weirdness. In day to day Go code, the compiler’s handlingof various types of  nil “just works” the way you’d expect it to. And beingable to use a bare  nil is quite handy.</p><p>  选择Go并抱怨它很诱人。我当然会做那么棒。但要公平，这真的不是最多的代码问题。它，因为我正在尝试做奇怪的东西，反映我正在学习这种内心怪异。在日常之路代码中，编译器的处理方式“只是作品”的方式，就像你期望的那样。使用裸零是非常方便的。</p><p> But I still prefer how Rust does it, using a parameterized  Option&lt;T&gt;type. That way I can easily check if something is  None without any specialcases. Everything is using the same type system, though that type system ismuch more complex than Go’s.</p><p> 但我仍然喜欢使用参数化选项＆lt; t＆gt;类型。这样我可以轻松检查某些东西是否没有任何特殊套件。一切都在使用相同类型的系统，虽然那种系统是比Go的更复杂。</p><p> Note that an “invalid” value in the context of  reflect is not invalidin the context of a Go program. You can use an invalid value everywhereyou can use the corresponding valid but uninitialized  nil value.  ↩︎</p><p> 请注意，反映的上下文中的“无效”值不是无效的Go程序的上下文。您可以使用无效的值，每一个地都可以使用相应的有效但未初始化的nil值。 ↩︎</p><p>   I know very little about unsafe Rust which is why I’m hedging.  ↩︎</p><p>   我对不安全的生锈很少，这就是我对冲的原因。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.urth.org/2021/03/27/down-the-golang-nil-rabbit-hole/">https://blog.urth.org/2021/03/27/down-the-golang-nil-rabbit-hole/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/兔洞/">#兔洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nil/">#nil</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>