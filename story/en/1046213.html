<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>固定端子 Fix Terminals</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fix Terminals<br/>固定端子 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-28 22:23:40</div><div class="page_narrow text-break page_content"><p>Keyboard input on Terminals has many deficiencies to it. I want them all fixed. I have a plan on how to do it but it Needs Your Help</p><p>终端上的键盘输入有很多不足之处。我希望它们都固定。我有一个计划，但需要您的帮助</p><p> I want terminal keypresses to Just Work. What do I mean Just Work? I mean programs in a simple orthogonal way, can determine the key that was pressed, and this model should easily map to the user&#39;s expectation.</p><p> 我希望终端按键能够正常工作。我是什么意思？我的意思是程序可以通过简单的正交方式确定按下的键，并且该模型应该可以轻松映射到用户的期望。</p><p> Why doesn&#39;t it currently? Currently, there are a number of classes of physically-distinct key presses that terminals encode using the same bytes. Special names for some ASCII characters collide with  Ctrl-modified letters. For example,  Tab is  Ctrl-I.</p><p> 为什么现在不行？当前，终端使用相同的字节编码的物理上按键区分的类别很多。某些ASCII字符的特殊名称与Ctrl修改的字母冲突。例如，Tab是Ctrl-I。</p><p>  UTF-8 collides with 8bit-high characters; e.g.  Alt-C might be encoded as  0xc3, which is the first UTF-8 byte of many Unicode characters, such as é.</p><p>  UTF-8与8位高字符碰撞；例如Alt-C可能被编码为0xc3，它是许多Unicode字符（例如é）的第一个UTF-8字节。</p><p> Sometimes programs rely on timing information to distinguish, for example,  Alt-C from the two separate keypresses of  Escape followed by  C. This results in delays to recognise a plain  Escape key if the time is too long, or erroneously recognising  Escape followed by a letter as an  Alt-modified letter if typed too quickly, or if the time limit is too short.</p><p> 有时程序会依赖时序信息来区分（例如，Alt-C与两次单独的Escape键，然后再按下C键）。如果时间太长，则会导致延迟识别纯Escape键的时间，或者错误地识别Escape键，然后再按一次。如果输入速度太快或时间限制太短，则将字母作为Alt修改字母。</p><p>Even when keys produce unique unambiguous byte sequences, it may be that some programs cannot recognise them. The way terminals encode modified keypresses is an extension to the original methods used in the 1970s, and some older code cannot parse them correctly. Press  Ctrl-Up on a modern xterm and watch a program fail and die in all sorts of interesting ways because they don&#39;t have real CSI parsers.</p><p>即使密钥产生唯一的明确字节序列，也可能是某些程序无法识别它们。终端对修改后的按键进行编码的方式是对1970年代使用的原始方法的扩展，并且一些较旧的代码无法正确解析它们。在现代的xterm上按Ctrl-Up并观看程序以各种有趣的方式失败并死亡，因为它们没有真正的CSI解析器。</p><p>  By having a sane and sensible model on BOTH ends of the terminal interaction, and a well-defined way of communicating.How exactly we go about this really depends who you are:</p><p>  通过在终端交互的两端都建立一个理智而明智的模型，以及一种明确定义的沟通方式，我们如何做到这一点实际上取决于您是谁： </p><p>  The simplest way to go about this is to use the key input handling features of my terminal UI library,  libtickit.Failing this, if you&#39;re using some existing system of keyboard input, such as GNU Readline, I suggest you apply pressure to the maintainers of that system until they adopt this method of reading extended keypresses.</p><p>解决此问题的最简单方法是使用我的终端UI库libtickit的键输入处理功能，如果您使用的是某些现有的键盘输入系统（例如GNU Readline），则失败，建议您施加压力直到该系统的维护人员采用这种读取扩展按键的方法。</p><p>  Making a terminal send the correct key encodings should be a relatively easy task, given the encoding scheme already splits modifiers and keysyms in a way likely to be similar to the underlying input system at work, such as X11 or Win32.</p><p>  考虑到编码方案已经以可能类似于工作中的基础输入系统（例如X11或Win32）的方式拆分修饰符和键符号，使终端发送正确的键编码应该是相对容易的任务。</p><p>  Even if you&#39;re not the author of a program like this, you can still help fix the situation. Write to the maintainer of your program, report a bug. Explain that you wanted to use such a keybinding, or whatever the problem was. Explain that, because their program doesn&#39;t correctly handle these cases, it wasn&#39;t possible, but if they were to adopt this scheme, then it would be and your problem would be solved. With enough voices, even the most stubbon developer who believes it&#39;s 1970 and everyone lives behind a green-phosphor glass teletype on a 9,600 baud modem, can still change his ways.</p><p>  即使您不是这样的程序的作者，您仍然可以帮助解决这种情况。编写程序的维护者，报告错误。说明您要使用这样的键绑定，或者出现任何问题。向他们说明，因为他们的程序无法正确处理这些情况，所以不可能，但是如果他们采用这种方案，那么它将可以解决您的问题。有了足够的声音，即使是最坚决的开发者，他们相信1970年左右，每个人都住在9600波特调制解调器上的绿磷玻璃电传打字机后面，仍然可以改变他的方式。</p><p>  The primary motivation of this scheme is to encode any possible keypress uniquely; that a keypress maps to one possible sequence of bytes, and a valid sequence of bytes encodes only one keypress. For backward compability, it is also required that any keypress that can be represented without this scheme is also represented by the same bytes within it; that is, this scheme is an  extension of existing encodings, not a replacement of.</p><p>  该方案的主要动机是对任何可能的按键进行唯一编码。按键映射到一个可能的字节序列，而有效的字节序列仅编码一次按键。为了向后兼容，还要求在不使用此方案的情况下可以表示的任何按键也必须由其中的相同字节表示；例如，也就是说，此方案是现有编码的扩展，而不是替代。</p><p> The two encoding forms used by this specification to encode modifiers both put a number as their second parameter whose value is 1 + a bitmask encoding the modifiers. We add 1 because by convention, a missing CSI parameter is equivalent to 1, so in the &#34;unmodified&#34; state the modifier field would be 1 - we must add 1 to it so that no-bits-set (unmodified) is encoded as 1 (though, in practice, we rarely use the 1 form explicitly).  Thus, the various encoding forms using these modifiers will look like: These various forms are explained more below.</p><p> 本规范用于编码修饰符的两种编码形式均以数字作为其第二个参数，其值为1 +编码修饰符的位掩码。我们加1是因为按照惯例，缺少的CSI参数等于1，因此在＆＃34; unmodified＆＃34;中，声明修饰符字段为1-我们必须向其添加1，以便无位集（未修改）被编码为1（尽管实际上，我们很少明确使用1形式）。因此，使用这些修饰符的各种编码形式将如下所示：这些各种形式将在下面进行详细说明。</p><p>  When unmodified, just send UTF-8 bytes as normal. No UTF-8 sequence of a regular character starts with a  C0 or  C1 byte, so these will be unique. The  Shift key should not be considered as a modifier for Unicode characters, because it is most likely used to obtain the character in the first place (e.g. the shift key is often required to obtain the  ! symbol). Certain key presses have special behaviours with modifiers.  Alt tends to prefix  Escape.  Ctrl tends to mask with  0x1f. When the simplest form of these keys are pressed, they should be encoded as previously.Existing schemes lack a way to encode more general modifiers with Unicode codepoints at present, so we are at liberty to invent something new for these. The CSI  u command lies in the private-use area, so has no fixed meaning at present. We can use this to represent the problematic combinations of keys; for example variations on the letter &#34;A&#34; (ASCII decimal value 65) and &#34;a&#34;: This same pattern is continued for the other letters, except for the awkward cases of We can now represent the usual problematic keys unambiguously: Because other  C0 bytes do not have usual alternative names or keypresses, these can continue to be sent using the simple single-byte encoding. This is essential to ensuring that legacy systems continue to interpret them correctly (e.g.  termios still sends  SIGINT on Ctrl-C).The  Space key is unique among the printing Unicode keys in that its behaviour doesn&#39;t normally change as a result of the  Shift modifier. We can capture this by encoding it using CSIu - uniquely, the only printing Unicode key for which we use this:</p><p>  未修改时，只需照常发送UTF-8字节即可。常规字符的UTF-8序列都不以C0或C1字节开头，因此它们将是唯一的。 Shift键不应被视为Unicode字符的修饰符，因为它很可能首先用于获取字符（例如，经常需要使用Shift键才能获得！符号）。某些按键具有修饰键的特殊行为。 Alt往往以Escape作为前缀。 Ctrl倾向于用0x1f遮罩。当按下这些键的最简单形式时，它们应该按照以前的方式进行编码。现有的方案目前缺乏一种使用Unicode代码点对更通用的修饰符进行编码的方法，因此我们可以自由地为这些键发明一些新的东西。 CSI u命令位于专用区域中，因此目前没有固定的含义。我们可以用它来表示有问题的键组合。例如字母＆＃34; A＆＃34;的变体（ASCII十进制值65）和＆＃34; a＆＃34 ;：其他字母继续相同的模式，除了的尴尬情况我们现在可以明确表示常见的有问题的键：因为其他C0字节没有普通的备用名称或按键，可以继续使用简单的单字节编码发送。这对于确保遗留系统继续正确地解释它们至关重要（例如termios仍在Ctrl-C上发送SIGINT）。Space键在打印Unicode键中是唯一的，因为它的行为通常不会由于以下原因而改变： Shift修饰符。我们可以通过使用CSIu对其进行编码来捕获它-唯一地，这是我们唯一使用它的印刷Unicode密钥：</p><p>  The problematic keys listed above plus  Backspace can be represented using the  CSI u encoding when any modifiers are present. Because these symbols are almost universally found on their own physical keycap, there is no problem with encoding the  Shift modifier as well, with the value 1. We encode these keys using their normal  ASCII codepoint values. The  Space key is trickier, because it&#39;s traditionally used with the  Ctrl modifier to obtain the  NUL byte encoding. Since most terminals repesent  Shift-Tab as  CSI Z, that needs handling specially as well.</p><p>  如果存在任何修饰符，可以使用CSI u编码来表示上面列出的有问题的键以及Backspace。由于这些符号几乎都可以在其自身的物理键帽上找到，因此对Shift修饰符的值1进行编码也没有问题。我们使用它们的常规ASCII码点值对这些键进行编码。空格键比较棘手，因为它通常与Ctrl修饰符一起使用，以获取NUL字节编码。由于大多数终端都将Shift-Tab用作CSI Z，因此也需要特别处理。 </p><p>  Existing schemes usually use  CSI ~ to encode special (i.e. non-Unicode) keypresses. XTerm and other terminals use the second CSI parameter to pass encoding the set of modifiers in effect. If the modifier value is 1; i.e. there are no modifiers, then for backward-compatibility to send the same bytes as previously, it should be omitted, sending simply   (*): Note that some terminals prefer to encode  Home,  End and the  F1 to  F4 function keys using shorter  CSI letter encodings. Parsers or other receiving programs should accept either encoding identically. (**): Note also the discontinuity of numbered function keys. After every group of 5 F keys there is a missing number; so every 6th number is not used by an F key (10, 16, 22, 28,...). This is purely for historic reasons; the numbered F keys on the original VTxx keyboards had physical gaps in these locations.</p><p>现有方案通常使用CSI〜来编码特殊的（即非Unicode）按键。 XTerm和其他终端使用第二个CSI参数传递对有效的修饰符集进行编码。如果修饰符值为1；也就是说，没有修饰符，则为了向后兼容发送与以前相同的字节，应省略它，仅发送（*）：请注意，某些终端更喜欢使用较短的CSI编码Home，End和F1至F4功能键字母编码。解析器或其他接收程序应接受相同的编码。 （**）：还请注意编号的功能键的间断性。在每组5个F键之后，缺少一个数字。因此F键不会使用每6个数字（10、16、22、28等）。这纯粹是出于历史原因；原始VTxx键盘上编号的F键在这些位置上存在物理间隙。</p><p>  Some terminals encode certain keys outside of the  CSI ~ encoding, instead picking a different CSI command. This too can accomodate the modifier in its second position.  As before, if the modifier is 1 then the modifier parameter should be omitted. Since the leading number is also implied, this can be omitted too.</p><p>  一些终端在CSI〜编码之外对某些密钥进行编码，而不是选择其他CSI命令。这也可以使修饰符处于第二位置。和以前一样，如果修改器为1，则应省略修改器参数。由于还暗示了前导数字，因此也可以省略。</p><p> Advantages: solves above problems.  Can be fitted into existing programs with a minimum of fuss and without breaking back-compat.</p><p> 优点：解决了以上问题。可以花最少的钱就可以安装到现有程序中，而又不会破坏反向兼容。</p><p> Extension: We can take it one step further, and require CSI to be sent as the single 8bit code  0x9b and never as 7bit multibyte  0x1b 0x4b (Escape [). This reserves the single  0x1b byte exclusively for the Escape key. If this is known to be in effect, then it is no longer required to use timing information to recover accurate keypress information, as every possible keypress now has a unique encoding. Even if this is not known to be in effect, programs ought to accept the single  0x9b byte encoding of CSI anyway, in anticipation of a time when terminals may send it encoded this way by default.</p><p> 扩展：我们可以更进一步，要求将CSI作为单个8位代码0x9b发送，而绝不作为7bit多字​​节0x1b 0x4b发送（Escape [）。这将仅将0x1b字节保留给Escape键。如果已知这是有效的，则不再需要使用时间信息来恢复准确的按键信息，因为每个可能的按键现在都具有唯一的编码。即使不知道这是有效的，程序也应该无论如何都要接受CSI的0x9b字节编码，因为终端可能会默认以这种方式发送它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.leonerd.org.uk/hacks/fixterms/">http://www.leonerd.org.uk/hacks/fixterms/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/端子/">#端子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fix/">#fix</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>