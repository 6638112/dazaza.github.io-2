<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>但是，数据库究竟如何使用mmap？ </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">但是，数据库究竟如何使用mmap？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 21:44:46</div><div class="page_narrow text-break page_content"><p>在上一篇使用Go发现和探索mmap的文章中，我们讨论了数据库如何解决一个主要问题，即：如何处理大于可用内存的磁盘中存储的数据。我们讨论了多少数据库使用内存映射文件解决了此问题，并探讨了mmap功能。</p><p> 仅仅知道数据库使用内存映射文件来解决问题还不够。它解决了部分谜团，但仍然存在一个问题：数据库究竟如何使用mmap从磁盘读取和写入数据？</p><p> 我决定深入研究数据库源代码以回答该问题。有很多使用mmap的数据库。他们中的一些人决定不再使用。一些示例：SQLite可以选择使用内存映射的I / O直接访问磁盘内容[1]，似乎曾经使用过LevelDB，但它进行了更改[2]，Lucene可以使用MMapDirectory [3]，LMDB使用mm​​ap [4]，来自Counchbase的一个简单的键/值内存数据库moss使用mmap来实现内存数据的持久性[5]，而MongoDB为WiredTiger [6]删除了mmap存储引擎。</p><p> 为此，我选择了bolt，它是由Ben Johnson在LMDB项目的启发下在Go中实现的简单键/值存储。主要是因为源代码简单和我对Go语言的熟悉。我知道，简单的键/值存储可能不是学习有关将数据读/写到磁盘的所有详细信息的最完整的源代码，但是正如我所发现的那样，足够理解它了。</p><p> 原始的螺栓存储库不再维护。 etcd维护并使用了称为bbolt的螺栓叉。如果您不熟悉Bolt，我建议您阅读BoltDB简介：无痛执行者持久性和Bolt — Go的嵌入式键/值数据库。</p><p>  我将代码下载到我的机器上，并在编辑器中将其打开。我认为开始挖掘的一个好地方是找出数据库的初始化位置，并在那里查找mmap的任何引用。像大多数嵌入式数据库一样，bolt具有Open方法，用于打开数据库或创建新数据库（如果不存在）。在其中，我找到了对私有mmap函数的引用。这是一个好的开始。</p><p> //内存映射数据文件。if err：= db.mmap（options.InitialMmapSize）; err！= nil {_ = db.close（）return nil，err} </p><p>专用mmap负责打开内存映射文件。为了做到这一点，它需要弄清楚要分配多少内存。此任务通过另一种称为mmapSize的方法来完成。给定数据库的大小，此方法可以计算应分配多少字节的内存。</p><p> 首先将大小从32KB翻倍到1GB。但是，如果数据库大于1GB，则一次增加1GB。</p><p> //对于i：= uint（15）;，将大小从32KB增加到1GB。我＆lt; = 30; i ++ {如果大小＆lt; = 1＆lt;＆lt; i {返回1＆lt;＆lt; i，nil}} ... //如果大于1GB，则一次增加1GB。sz：= int64（size），如果剩余：= sz％int64（maxMmapStep）;余数＆gt; 0 {sz + = int64（maxMmapStep）-余数}</p><p> 现在一切都很好。那就是螺栓计算出多少分配量的方式。但是现在有一个难题，当我们谈论数据库存储布局时，这将非常重要。在确定分配多少之后，需要确保分配的大小是页面大小的倍数。如果您不熟悉数据库存储并且不知道页面是什么，请不用担心，我们将回到此状态。</p><p> // //确保mmap大小是页面大小的倍数。//这应该始终为true，因为我们以MBs.pageSize递增：= int64（db.pageSize）if（sz％pageSize）！= 0 {sz =（（sz / pageSize）+1）* pageSize}</p><p> 它不应该检查我们分配的资源是否超过可用的资源？那是mmapSize方法的最后一部分。</p><p> //如果我们超过了最大大小，则只会增长到最大大小。如果sz＆gt; maxMapSize {sz = maxMapSize} </p><p>AMD64体系结构定义了一种64位虚拟地址格式，当前实现中使用其低阶48位。这允许最多256 TiB（2 48字节）的虚拟地址空间。 -x86-64 Wiki</p><p>   现在，螺栓知道应该分配多少，然后调用系统调用mmap。这是类Unix环境的完整代码：</p><p> // mmap内存映射数据库的数据文件。func mmap（db * DB，sz int）error {//将数据文件映射到内存。 b，err：= syscall.Mmap（int（db.file.Fd（）），0，sz，syscall.PROT_READ，syscall.MAP_SHARED | db.MmapFlags）if err！= nil {return err} //通知内核mmap是随机访问的。如果err：= madvise（b，syscall.MADV_RANDOM）; err！= nil {return fmt.Errorf（＆＃34; madvise：％s＆＃34 ;, err）} //保存原始字节片并转换为字节数组指针。 db.dataref = b db.data =（* [maxMapSize] byte）（unsafe.Pointer（＆amp; b [0]））db.datasz = sz return nil}</p><p> 这是一个非常简单的代码。我对syscall.PROT_READ有一些看法，但是我将继续进行下一个会话。很高兴看到有人呼吁在那里疯狂，尽管我不知道这样做有什么好处。我想知道该调用的重要性，它可以提高性能，或者可以设置另一个标志来针对不同的用例从OS获得不同的行为。</p><p>   我想知道跟踪两个变量的重要性。我无法掌握db.data转换中发生了什么。但是无论如何，我们要记住的是，通过这些变量，bolt将从磁盘读取数据。</p><p>  浏览源代码时，我寻找了如何在读取和写入中使用mmap的证据。我挖了Get和Put方法。我找不到对db.dataref或db.data的引用进行更新的任何地方。我发现在对事务调用Commit时会发生磁盘写操作。但是在那里我只能找到对WriteAt的调用。因此，我放弃了尝试了解mmap如何用于写入的搜索。</p><p> 然后，突然，当回头看mmap的调用时，我注意到syscall.PROT_READ标志，这是我第一次查看代码时没有注意到的。因此，mmap仅用于读取螺栓。另一个表明这一点的地方是在DB结构的定义中： </p><p>这对我来说很有意义。由于使用mmap时很难控制刷新到磁盘，因此这可能是最安全的方法。螺栓如何写作是另一篇文章的主题。</p><p>  我们知道bolt如何以及何时分配内存，并且mmap不用于写入。但是，bolt究竟如何才能找到键的值？要了解这一点，我们必须了解数据库通常如何构造其文件。我不会在这里做深。主要是因为我不够深入。只是要尝试一眼正在发生的事情。</p><p> 文件只是字节数组。我们必须对此字节数组应用某种推理才能有效地使用它。数据库将磁盘中的文件结构化为称为页的块（字节块）。螺栓没有什么不同。数据库文件可以看作是</p><p>  每个页面都有固定的字节长度，通常与OS页面大小相同（通常为4096字节）。这是设置pageSize的螺栓部分。</p><p> // db的默认页面大小设置为OS页面大小。var defaultPageSize = os.Getpagesize（）</p><p> 每个数据库都有其自己的页面布局。螺栓的页面布局在page.go中定义为</p><p> const（branchPageFlag = 0x01 leafPageFlag = 0x02 metaPageFlag = 0x04 freelistPageFlag = 0x10）const（bucketLeafFlag = 0x01）type pgid uint64type page struct {id pgid标志uint16计数uint16溢出uint32 ptr uintptr} </p><p>id：是用于索引页面的页面标识符。给定一个页面ID，我可以通过mmap在磁盘中找到它，因为磁盘文件只是一个连续固定长度页面的列表。</p><p> 标志：告诉页面类型。页面有四种类型：meta，freeList，leaf和branch；</p><p>   ptr：表示页面标题的末尾和页面数据的开始。这是键和值要存储的地方。</p><p>   考虑到这一点，我们可以看看在给定页面ID的情况下检索页面的代码。</p><p> //页面根据当前页面大小从mmap检索页面引用。func（db * DB）page（id pgid）* page {pos：= id * pgid（db.pageSize）return（* page）（不安全。指针（＆amp; db.data [pos]））}</p><p>  我们知道数据库文件在磁盘中的结构，并且我们知道如何从磁盘检索页面。但是bucket.Get（[] byte（＆＃34; key＆＃34;））搜索如何工作？我们在这里不会做太多的细节。我希望我创建的抽象足以了解正在发生的事情。</p><p> 如果页面本身在数据部分中包含对其他页面的引用怎么办？如果这些引用形成了B + Tree，该怎么办？ </p><p>这正是螺栓的作用。将页面视为B + Tree的节点。在B + Tree中，我们有内部节点和叶子。这就是使用“ flags”属性来指示该页面属于哪种节点的原因。</p><p>  因此，要执行键的搜索，请从根节点开始，在映射的磁盘页面上进行B + Tree遍历。因此，bolt是内存映射的B + Tree文件。您拥有的内存越多，它的行为就越类似于存储键/值存储。</p><p> 有关此过程的更多详细信息。我大部分都不了解自己。因此，让我们在此抽象级别上保持简单。</p><p>  当我开始查看源代码时，我搜索了mmap的所有调用。如开头所述，第一个在Open方法中找到。第二个是在分配方法中找到的。</p><p> 在写入bolt时，需要确保它没有消耗所有分配的内存。如果发现它将超出数据库大小，则会调整内存大小。</p><p> //如果最后要调整mmap（）的大小。p.id = db.rwtx.meta.pgidvar minsz = int（（p.id + pgid（count））+ 1）* db.pageSizeif minsz＆gt ; = db.datasz {如果err：= db.mmap（minsz）; err！= nil {返回nil，fmt.Errorf（＆＃34; mmap分配错误：％s＆＃34 ;, err）}}</p><p>  阅读螺栓源代码是理解数据库内部结构的一种非常不错的方法。并不是我想的那样吓人。我们忽略了它的大部分源代码，仅着眼于如何使用mmap有效地从磁盘检索数据。我们可以从螺栓中学习更多的概念，例如事务，原子，隔离，并发控制，但我将继续发表其他文章。 </p><p>重要的是要提醒您，螺栓使用的策略只是多种策略之一。 其他数据库使用不同的页面布局和不同的数据结构。 但是，在更高层次上，我猜想映射数据库的逻辑应该是相同的。  我正在探索关于数据库的更多信息。 如果您有兴趣，可以在Twitter上关注我，在这里我分享更多相关内容。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://brunocalza.me/but-how-exactly-databases-use-mmap/">https://brunocalza.me/but-how-exactly-databases-use-mmap/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/databases/">#databases</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mmap/">#mmap</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1045807.html"><img src="http://img2.diglog.com/img/2021/1/thumb_f14f749b704163853612f5a235e479e7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045807.html">Rqlite：基于SQLite的轻量级分布式关系数据库 </a></div><span class="my_story_list_date">2021-1-22 23:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045246.html"><img src="http://img2.diglog.com/img/2021/1/thumb_05f92363634dbdd9582dc29ff8762ea1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045246.html">Podchaser筹集了400万美元用于建立一个全面的播客数据库 </a></div><span class="my_story_list_date">2021-1-20 7:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044165.html"><img src="http://img2.diglog.com/img/2021/1/thumb_8ee9c0041aa14b50b61ca807e50ef0eb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044165.html">光芒–虚拟现实艺术数据库 </a></div><span class="my_story_list_date">2021-1-15 20:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044060.html"><img src="http://img2.diglog.com/img/2021/1/thumb_f60ab32f0e4a82c00c7f32f6b1d09492.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044060.html">不太可能的数据库迁移 </a></div><span class="my_story_list_date">2021-1-15 19:55</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>