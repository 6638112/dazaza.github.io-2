<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Authz：Carta的高度可扩展权限系统 AuthZ: Carta’s highly scalable permissions system</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AuthZ: Carta’s highly scalable permissions system<br/>Authz：Carta的高度可扩展权限系统 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-25 01:08:09</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/c9af7d1452decce2856ce93906c7ea86.png"><img src="http://img2.diglog.com/img/2021/6/c9af7d1452decce2856ce93906c7ea86.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Permissions, also known as authorization, is the process of granting access to resources in your system. For any team, it’s crucial to get permissions right. At Carta, where we are working with financial data all day, it’s the  most important thing.</p><p>权限，也称为授权，是授予系统中资源的访问的过程。对于任何团队，对获得权限至关重要。在Carta，我们整天都在使用财务数据，这是最重要的事情。</p><p> But we had a problem. Instead of maintaining one legacy system, we were maintaining  five. The permissions could conflict — and they were impossible to extend. Our business needs were growing, and we had several new products in the funnel.</p><p> 但我们有一个问题。我们不是维持一个遗留系统，我们保持五个。权限可能会发生冲突 - 他们无法扩展。我们的业务需求正在增长，我们在漏斗中有几种新产品。</p><p> It was obvious we had to build a new authorization system to create leverage for engineering and product. We knew we needed it to be three things:</p><p> 很明显，我们必须建立一个新的授权系统，以创造工程和产品的杠杆。我们知道我们需要它是三件事：</p><p>  Sounds simple enough, but in reality it’s not that easy. In my career, I’ve seen permission systems that are too simple. They lack the features to support fine-grained access on single resources. I’ve also seen them too complex. One small change might unravel a whole policy of attribute-based permissions.</p><p>  听起来很简单，但实际上它并不容易。在我的职业生涯中，我已经看到了太简单的权限系统。它们缺乏支持单一资源的细粒度访问的功能。我也看到他们太复杂了。一个小型更改可能会解开基于属性的权限的整个策略。</p><p> In this article, we’ll look at how my team — Identity and Access Management — took a creative approach to avoid those pitfalls by rebuilding Carta’s permissions system based on Google Zanzibar.</p><p> 在本文中，我们将研究我的团队 - 身份和访问管理 - 采用创造性的方法来避免通过基于Google Zanzibar的基于Carta的权限系统来避免那些陷阱。</p><p>  Our work began in mid-2019 when we started decomposing our monolithic application. Engineers were developing decomposed services and needed a way to authorize incoming requests. Permission data was still coupled to the legacy permission system in the monolith.</p><p>  我们的工作开始于2019年中期，我们开始分解我们的单片申请。工程师正在开发腐败的服务，并需要一种授权传入请求的方法。许可数据仍然耦合到整料中的传统许可系统。</p><p> Our first experiment was a distributed, token-based access control system. We passed user permission data between services with an encoded  JWT token. Distributed tokens made access checks fast, but there was a huge cost to build them. Token build times had a very long tail and caused performance issues for power users with large permission sets.</p><p> 我们的第一个实验是分布式的基于令牌的访问控制系统。我们通过编码的JWT令牌在服务之间传递了用户权限数据。分布式令牌使得进入快速检查，但建立巨大的成本。令牌建设时间具有很长的尾部，并对具有大型权限集的电力用户造成性能问题。 </p><p>  Some tokens reached almost 1mb (!!) in size. Almost every request payload had an embedded token and response times would suffer as large tokens passed between services.</p><p>一些令牌的大小达到了近1MB（!!）。几乎每个请求有效载荷都有一个嵌入式令牌和响应时间将在服务之间传递的大令牌受到影响。</p><p> Additionally, the authorization token was not extendable. Service owners had to build their own system for new permission sets. We decided to scrap the authorization token and investigate other options.</p><p> 此外，授权令牌不可扩展。服务所有者必须为新的权限集构建自己的系统。我们决定废除授权令牌并调查其他选项。</p><p>  During our discovery process, we evaluated both open source and vendor products. Many of the projects we evaluated were not granular enough to handle our use cases, so we ruled them out. Then we turned our focus on avoiding vendor lock-in.</p><p>  在我们发现过程中，我们评估了开源和供应商产品。我们评估的许多项目都不足够粒度，可以处理我们的用例，所以我们统治了它们。然后我们重点关注避免供应商锁定。</p><p> We identified a promising project named  Open Policy Agent (OPA). OPA is a framework that provides a single interface for authorization checks.</p><p> 我们确定了一个名为Open Policy Agent（OPA）的有前途的项目。 OPA是一个提供用于授权检查的单个接口的框架。</p><p> OPA serves as a system of record for authorization policies. Domain services push code-defined permission policies to OPA. Network traffic passes through OPA and policies are used to either authorize or deny incoming requests. OPA is built for distributed systems, so it scales well across a cluster.</p><p> opa用作授权策略的记录系统。域服务将代码定义的权限策略推送给OPA。网络流量通过OPA，策略用于授权或拒绝传入请求。 OPA是为分布式系统而构建的，因此它会跨群集缩放。</p><p> OPA has some downsides. It requires a large set of self-managed infrastructures. Permission checks are also slow. With OPA, the consumer controls the underlying data source. You store policy code in OPA, but policies query domain-level data for access checks. This worked fine for simple permissions, but complex ones caused major issues for us.</p><p> opa有一些缺点。它需要一大集的自我管理基础设施。许可检查也很慢。使用OPA，消费者控制底层数据源。您在OPA中存储策略代码，但策略查询域级数据进行访问检查。这适用于简单的权限，但复杂的是对我们引起的重大问题。</p><p> Complex permissions often queried several data models and added hundreds of milliseconds to response times. That wasn’t going to work for us.</p><p> 复杂的权限通常会查询几个数据模型，并添加了数百毫秒的响应时间。这不会为我们工作。 </p><p>  Other projects failed to meet the requirements for our data because they operated on role-based access control (RBAC). RBAC grants access to users via permissive roles. Roles break down with large data sets due to a phenomenon called “role explosion.”</p><p>其他项目未能满足数据的要求，因为它们在基于角色的访问控制（RBAC）上运行。 RBAC通过允许角色授予对用户的访问权限。由于一个名为“角色爆炸”的现象，角色与大数据集打破。</p><p>  Role explosion is caused when users have many roles for several different system entities. (For example, if a user has four roles for 10 different entities, the user has 40 managed roles.) This number has no upper bound and can become millions of managed roles if there are thousands of entities in the system.</p><p>  当用户对几个不同的系统实体有许多角色时，会导致角色爆炸。 （例如，如果用户有10个不同实体的角色，则用户具有40个托管角色。）如果系统中存在数千个实体，则此数字没有上限，并且可以成为数百万个托管角色。</p><p> At Carta, user permissions are complex because they’re scoped to portfolio assets. A user has access to their individual portfolio for a set of shares they own. They also may access securities through a fund that is invested in the company. Or the fund might even invest in another fund which owns shares in the company. On top of all that, the company might have access to your portfolio so they can administer securities.</p><p> 在CartA中，用户权限很复杂，因为它们是否遵守投资组合资产。用户可以访问他们拥有的一组共享的个人组合。他们还可以通过投资公司的基金来获得证券。或该基金甚至可能投资于本公司拥有股份的另一个基金。最重要的是，公司可能可以访问您的投资组合，以便他们可以管理证券。</p><p> Users have permission on each portfolio they can access. With millions of portfolios and securities on the platform, our permissions system has to manage a large amount of individual roles.</p><p> 用户在每个投资组合中都有权限。拥有数百万的平台上的投资组合和证券，我们的权限系统必须管理大量的个性角色。</p><p>  Mid-2019, Google released a white-paper titled “ Zanzibar: Google’s Consistent, Global Authorization System.”</p><p>  2019年中期，谷歌发布了一篇名为“Zanzibar：谷歌的一贯，全球授权制度”的白纸。</p><p> Google uses Zanzibar to service millions of authorization requests per second. Several high-traffic products, including YouTube and Drive, use Zanzibar for authorization. Zanzibar is powerful because it is scalable, flexible, and fast.</p><p> 谷歌使用桑给巴尔为每秒提供数百万授权请求。几种高流量产品，包括YouTube和Drive，使用桑给巴尔授权。桑给巴尔是强大的，因为它是可扩展，灵活，快速的。</p><p> One of Zanzibar’s core features is a uniform language that is used to define permissions. Zanzibar consumers use the uniform language to build Access Control Lists (ACLs). ACLs are like unix file permissions. They give users access to individual resources in the system.</p><p> 桑给巴尔的核心功能之一是一种统一的语言，用于定义权限。桑给巴尔消费者使用统一的语言来构建访问控制列表（ACL）。 ACL就像Unix文件权限。他们为用户提供系统中的各个资源。 </p><p> With Zanzibar, services compose abstractions for user permission groups. User permission groups can compose each other. They also grant access to low-level resource ACLs.</p><p>使用Zanzibar，服务为用户权限组撰写抽象。用户权限组可以互相组成。他们还授予对低级资源ACL的访问权限。</p><p> Unlike OPA, Zanzibar is the source of truth for the data. Consumers simply add permissions without thinking about how to implement fast lookups.</p><p> 与OPA不同，桑给巴尔是数据的真理来源。消费者只是在不考虑如何实现快速查找的情况下添加权限。</p><p>  But we had a problem: There weren’t any open source implementations available. We decided to build our own system, adding several of our own modifications to make it an even better fit for Carta.</p><p>  但我们有一个问题：没有任何开源实现。我们决定建立自己的系统，添加了几个自己的修改，使其更适合Carta。</p><p>  At this point, I’ll start referring to our next-gen authorization system as AuthZ. AuthZ stands for authorization.</p><p>  此时，我将从Authz提到我们的下一代授权系统。 Authz代表授权。</p><p> AuthZ configures permissions by adding and removing RelationTuples. A RelationTuple is a tuple consisting of an actor, relation, and object.</p><p> authz通过添加和删除相关性来配置权限。关系是一个由演员，关系和对象组成的元组。</p><p> Actor: The entity performing the action (e.g. User:Bob). An actor can also be a grouping of entities (e.g. Group:7 Members). It can even be a non-user (e.g. Service:Notification-Service).</p><p> 演员：执行动作的实体（例如用户：Bob）。演员也可以是实体的分组（例如，组：7名成员）。它甚至可以是非用户（例如服务：通知服务）。</p><p>  Each part of the RelationTuple is freeform, so we don’t limit the type of permissions that you can set with AuthZ. For example, “read” and “issue_certificates” are both valid permissions.</p><p>  关系的每个部分都是自由形式，因此我们不会限制您可以使用Authz设置的权限类型。例如，“读取”和“问题_Certificates”都是有效权限。 </p><p> Consumers combine RelationTuples using a domain-specific language. RelationTuples create direct access between actors and objects. RelationTuples automatically imply indirect access between actors and objects. I’ll explain later how this makes AuthZ so powerful.</p><p>消费者使用特定于域的语言来组合关系。关系策略在演员和对象之间创建直接访问。相关性自动暗示Actors和对象之间的间接访问。我稍后会解释一下这使Authz如此强大。</p><p> Direct Relation: A row in the database that has been explicitly set by a client</p><p> 直接关系：数据库中的一行已被客户端明确设置</p><p> Indirect Relation: A row that does not exist in the database, but the graph gives access to the actor through an indirect relation.</p><p> 间接关系：数据库中不存在的行，但图表通过间接关系提供对actor的访问。</p><p>  RelationTuples construct a permission graph. Consumers query the permission graph to determine if an actor has access to an object. An actor has access to an object if there is either a direct or indirect relationship between the actor and the object. (A good mnemonic for this process: “Actors act on Objects.”)</p><p>  关系构建权限图。消费者查询权限图以确定Actor是否可以访问对象。如果actor和对象之间存在直接或间接关系，则演员可以访问对象。 （这个过程的一个很好的助学版：“演员在物体上行动。”）</p><p> Traversing the graph is expensive, so AuthZ maintains a custom secondary index. The secondary index responds to access checks on the permissions graph in sub-10ms response times.</p><p> 遍历图形是昂贵的，因此Authz维护了自定义二级索引。辅助索引响应在子10ms响应时间中对权限图的访问检查。</p><p> The architecture of this system is out of the scope of this article. We’ll post about it later, so follow Building Carta for updates.</p><p> 该系统的体系结构超出了本文的范围。我们稍后会发布关于它的信息，因此请按照构建CartA进行更新。</p><p>  At Carta, we start every new project by building a minimum viable product (MVP). Internal services are no exception. MVPs help your team collect valuable early feedback. Early feedback prevents your team from spending time building the wrong features.</p><p>  在Carta，我们通过建立最低可行的产品（MVP）启动每个新项目。内部服务也不例外。 MVPS帮助您的团队收集有价值的早期反馈。早期反馈可以防止您的团队在花时间建立错误的功能。 </p><p>   Our team started by aggregating several requirements from our consumers. At that time our authentication token was still used by most domain services to query legacy permissions. Most teams wanted a way to build new permissions.</p><p>我们的团队开始从消费者中汇总了几个要求。此时，我们的身份验证令牌仍然被大多数域服务用于查询遗留权限。大多数团队都希望成为建立新权限的方法。</p><p> We started implementing a basic version of the index algorithm from Zanzibar. Our first goal was to test this system on new permissions.</p><p> 我们开始从Zanzibar实现索引算法的基本版本。我们的第一个目标是在新权限上测试这个系统。</p><p>  Speed was one of the primary requirements for AuthZ. We built a prototype of the Zanzibar index to verify that we could achieve a similar level of performance.</p><p>  速度是Authz的主要要求之一。我们构建了Zanzibar指数的原型，以验证我们可以实现类似的性能水平。</p><p> Once we built the prototype, we began testing. We conducted several tests with our version of the Zanzibar index. We compared AuthZ’s custom index to a couple alternatives for a baseline metric.</p><p> 我们建造了原型后，我们开始进行测试。我们与我们的Zanzibar指数版本进行了多次测试。我们将Authz的自定义指数与基线度量的替代品进行比较。</p><p>  The lookup time using the Zanzibar custom index is very fast. Checks on dense graphs aren’t much slower than checks on sparse graphs and the index is an order of magnitude faster than an alternative optimized caching strategy.</p><p>  使用Zanzibar自定义索引的查找时间非常快。关于密集图的检查并没有比对稀疏图的检查的速度慢得多，并且索引比替代优化的缓存策略快。</p><p> There is an initial cost for building the custom index as seen by the higher average time to add an edge.</p><p> 通过较高的平均时间才能添加边缘，构建自定义索引的初始成本。</p><p> Eventually, this became a non-issue since AuthZ builds the index with an asynchronous pipeline. Consumers don’t have to wait for the index updates to propagate through the system. To reduce load, index updates are also distributed among several workers. As the number of consumers increases, we can scale up workers to process index events faster.</p><p> 最终，这成为一个非问题，因为Authz使用异步管道构建索引。消费者不必等待索引更新以通过系统传播。为了减少负载，索引更新也分布在几个工人之间。随着消费者人数的增加，我们可以扩大工人以更快地处理索引事件。 </p><p>    AuthZ’s Check endpoint performance impressed our consumers, but they felt like the API lacked features. Most use cases added several RelationTuples. Consumers called AuthZ tens of times during an update. Each call would add an individual RelationTuple.</p><p>Authz的检查端点表现给我们的消费者印象深刻，但他们觉得API缺乏功能。大多数用例都添加了多个关系。在更新期间消费者称为Authz。每个呼叫都会添加个人关系。</p><p> There were also some concerns around scalability. At this point the index was not built asynchronously. Thus, updates were slow. Since permissions were added individually, a full update could take several seconds.</p><p> 围绕可扩展性也有一些担忧。此时，索引不是异步构建的。因此，更新很慢。由于单独添加权限，因此完整更新可能需要几秒钟。</p><p> Finally, one of the biggest concerns was lack of visibility into the system. There was no way to inspect permissions once they were pushing into AuthZ. It was impossible to migrate an existing permission model without this feature.</p><p> 最后，最大的担忧之一缺乏对系统的可见性。一旦他们推入authz，就无法检查权限。在没有此功能的情况下迁移现有许可模型是不可能的。</p><p>  This was hard feedback to hear. But this is why Carta works iteratively. They weren’t saying “No.” They were saying “Not right now.”</p><p>  这是听到的很难反馈。但这就是为什么Carta迭代地工作。他们没有说“不。”他们正在说“现在不对”。</p><p> We knew that if we added a couple of features (to our MVP, which was already deployed), we could get the adoption we wanted.</p><p> 我们知道如果我们添加了几个功能（对于已经部署的MVP），我们可以获得我们想要的采用。</p><p>    This feedback was a positive indicator for our initial requirements. The MVP addressed most of the problems that we set out to solve. The scaling issues weren’t a big deal. We could solve those by implementing more features from the Zanzibar document.</p><p>    此反馈是我们初始要求的正指标。 MVP解决了我们旨在解决的大多数问题。缩放问题并不大笔交易。我们可以通过实施来自桑给巴尔文档的更多功能来解决这些问题。</p><p> The MVP identified something we did not predict: Our consumers wanted tooling. They preferred software which helps them use the system, not features on the system itself. We quickly prioritized tooling due to the demand coming from our consumers.</p><p> MVP确定了我们没有预测的东西：我们的消费者想要的工具。它们优先的软件，帮助它们使用系统，而不是系统本身的功能。由于来自消费者的需求，我们快速优先考虑了工具。 </p><p> Our consumers also had issues adding RelationTuples. They didn’t want to make 50 separate requests to bootstrap permissions. Rather they wanted to add multiple permissions in a single call. This customer request became the Template feature.</p><p>我们的消费者也有问题添加相关性。他们不想为引导权限进行50个单独的请求。相反，他们希望在单个呼叫中添加多个权限。此客户请求成为模板功能。</p><p>  During our initial tests, we built some tools to debug issues with the index. One of the tools was a simple graph visualizer. Given a set of RelationTuples, it was able to generate a JPEG image of the graph.</p><p>  在我们的初始测试期间，我们构建了一些工具来调试索引的问题。其中一个工具是一个简单的图形可视化器。给定一组关系，它能够生成图形的JPEG图像。</p><p>  We thought about creating an endpoint to serve this image to our consumers, but quickly decided it was a bad idea. We decided to build query APIs that let consumers view portions of the graph. These APIs acted as our backend. We then created Concord, a web app that acted as our presentation layer to visualize nodes in the graph.</p><p>  我们考虑了创建一个端点，为消费者提供这张照片，但很快就会决定这是一个坏主意。我们决定构建查询API，让消费者查看图形的部分。这些API充当了我们的后端。然后，我们创建了一个Concord，一个用作呈现图层的Web应用程序，以可视化图表中的节点。</p><p>  This feature alone addressed most of the concerns around discoverability, with the ability to identify and inspect permissions previously added.</p><p>  此功能仅解决了可发现性的大部分问题，具有识别和检查先前添加的权限的能力。</p><p>   During our test sessions, we noticed some services botched other services’ permissions. This happens when two services apply updates to the same permission type.</p><p>   在我们的测试期间，我们注意到一些服务拙劣的其他服务权限。当两个服务应用于相同的权限类型时，会发生这种情况。</p><p> For instance, one service might add a permission for a bank account. Another might add a permission for a user account. Both might try to write a permission with the actor type: “Account.” One service could overwrite another service’s change.</p><p> 例如，一个服务可能会增加银行帐户的权限。另一个可能会增加用户帐户的权限。两者都可以尝试用演员类型写入：“帐户”。一个服务可以覆盖另一个服务的变化。</p><p>  We introduced namespaces to separate domain-level permissions. Namespaces prevent permission overwrites, but promote cross-domain queries. Services write to one or many namespaces where they have write access. If a service attempts to write to a namespace they do not have access to, AuthZ rejects the update and throws an error.</p><p>  我们引入了名称空间以分隔域级权限。命名空间阻止权限覆盖，但促进跨域查询。服务写入他们具有写入访问的一个或多个名称空间。如果服务尝试写入名称空间，则无权访问，Authz拒绝更新并抛出错误。 </p><p>  Carta uses shared namespaces for a few use cases. For instance, user permissions are in one namespace; document permissions are in another. AuthZ grants the document service access for the Identity public namespace. Document service can give a user access to a document permission.</p><p>CartA使用共享名称空间，以实现一些用例。例如，用户权限在一个名称空间中;文档权限在另一个。 Authz授予身份公共命名空间的文档服务访问权限。文档服务可以为用户提供对文档权限的访问权限。</p><p>   We solved the bulk update problem (add multiple permissions) by introducing RelationTuple templates. Templates allow consumers to predefine a set of changes that are applied in AuthZ. Templates make updates explicit and repeatable.</p><p>   通过引入相关性的模板，我们解决了批量更新问题（添加多个权限）。模板允许消费者预定定义在Authz中应用的一组更改。模板使更新明确和可重复。</p><p> Consumers construct templates using  Mustache templating language and pass templates to AuthZ with a set of data when a change occurs. AuthZ injects data into the template and executes a bulk update event.</p><p> 消费者使用Mustache模板语言构造模板，并在发生更改时将模板传递给Authz。 Authz将数据注入模板并执行批量更新事件。</p><p>   # Set admins for this namespace {{#admin}} authz_service:{{service_id}}, admin, authz_namespace:{{namespace_id}} {{/admin}} # Give other services write access if they need it {{#write}} authz_service:{{service_id}}, create_any_relation, authz_namespace:{{namespace_id}} {{/write}}</p><p>   ＃这名命名空间设置管理员{{#admin}} authz_service：{{service_id}}，admin，authz_namespace：{{namespace_id}} {{/ adminace_id}} {{/ admin}}＃如果需要它，则提供其他服务写访问{{#write} } authz_service：{{service_id}}，create_any_relation，authz_namespace：{{namespace_id}} {{/ write}}</p><p> AuthZ uses this template to add permissions for a new namespace. AuthZ injects data for the change event. In this case, the namespace ID and any services that have access to the namespace. The template applies a bulk update to the permissions graph. Future AuthZ calls will include the RelationTuples applied by the template.</p><p> Authz使用此模板来为新命名空间添加权限。 Authz注入更改事件的数据。在这种情况下，命名空间ID和可以访问命名空间的任何服务。该模板将批量更新应用于权限图。未来的Authz调用将包括模板应用的关系。</p><p>  In some use cases, services display a list of resources that a user has access to (i.e., a search page).</p><p>  在一些用例中，服务显示用户可以访问的资源列表（即搜索页面）。</p><p> Traversing the graph with our query API returns the correct data, but it’s expensive. Deep graphs can take seconds to retrieve a results set, as opposed to tens of milliseconds when using the custom index.</p><p> 使用我们的查询API遍历图表返回正确的数据，但它很昂贵。深图可能需要几秒钟来检索设置的结果，而使用自定义索引时的数十毫秒。 </p><p> We determined we could repurpose the custom index to retrieve a flat list of resources for an actor. Since consumers effectively flatten the graph, we called this API “Flatten.”</p><p>我们确定我们可以重新定制自定义索引来检索演员的平面资源列表。由于消费者有效地平衡了图形，我们称之为这个API“扁平”。</p><p>  The index uses special filters to reduce the results returned to the consumer. Consumers use the output of Flatten to query their database for resources to show to the user.</p><p>  该索引使用特殊过滤器来减少返回消费者的结果。消费者使用扁平的输出来查询其数据库以获取资源以向用户展示。</p><p> List lookups were much faster with the index, but slowed down when consumers used filters.</p><p> 列表查找随着索引的速度要快得多，但是当消费者使用过滤器时减慢了。</p><p> We built a  trigram index on top of the custom index to support faster lookups with filters. All these optimizations reduced lookup times to 50ms for the 95th percentile.</p><p> 我们在自定义索引之上构建了一个TrIgram指数，以支持更快的过滤器查找。所有这些优化将查找时间降低到95百分位的50ms。</p><p>  A constant “build, measure, learn” feedback loop enabled our team to deliver immediate value. New features drove adoption across the company. Teams gravitated towards AuthZ because it was performant and easy to use.</p><p>  持续的“构建，衡量，学习”反馈循环使我们的团队能够提供立即值。新功能推动了整个公司的采用。竞争验证的团队是因为它是表演且易于使用的。</p><p> But it wasn’t enough—yet. People wanted to use the new system to query old permissions. To drive further adoption, we implemented a legacy permissions proxy.</p><p> 但这不是很多。人们希望使用新系统查询旧权限。为了进一步采用，我们实施了遗留权限代理。</p><p> The proxy enables teams to call AuthZ for legacy permissions instead of using the JWT token. Legacy permission checks are slower than AuthZ calls. But the proxy encouraged a single interface. It is much easier to migrate customers on a single interface than it is on two disparate systems.</p><p> 代理使团队能够调用Authz for Leavency权限，而不是使用JWT令牌。遗留许可检查比Authz呼叫慢。但代理鼓励一个接口。在单个界面上迁移客户比在两个不同的系统上更容易。 </p><p> Currently, AuthZ services seven different applications in our production environment for about 130 new, unique permission types. We have an average load rate of about 15 requests per second. Our metrics are growing quickly.</p><p>目前，Authz服务我们的生产环境中的七种不同应用程序约为130个新的，独特的许可类型。我们的平均负载率为每秒约15个请求。我们的指标正在快速增长。</p><p> We’re working to replace the legacy permissions proxy with native AuthZ calls. Native AuthZ calls will make checks an order of magnitude faster on average than the proxy. The 95th percentile is more than two orders of magnitude faster.</p><p> 我们正在努力用本机Authz调用替换遗留权限代理。本机Authz调用将比代理程序平均更快地检查数量级。第95百分位数速度超过两个数量级。</p><p> AuthZ has made it easier for teams to manage permissions. Developers can build new products without having to build underlying authorization infrastructure.</p><p> Authz使团队更容易管理权限。开发人员可以建立新产品，而无需构建潜在的授权基础架构。</p><p>  When building something new — be it an internal service or external product — don’t be afraid to experiment. Our team had several failures until we built something that our consumers wanted to use. Ultimately, early release was key for us.</p><p>  在建立新的东西时 - 成为内部服务或外部产品 - 不要害怕实验。在我们建立了我们的消费者想要使用的东西之前，我们的团队有几个故障。最终，早期发布是我们的关键。</p><p> I challenge you to use this process in your own work. Is there a broken system at your company? Can you launch a simple experiment to help build something useful?</p><p> 我挑战你在自己的工作中使用这个过程。贵公司是否有破碎的系统？你能推出一个简单的实验，帮助建立有用的东西吗？</p><p> We’ll be covering the architecture of AuthZ in future articles. Leave a comment if you have questions about AuthZ or our development process. And if you’d like to help us build the next version of Carta,  we’re hiring.</p><p> 我们将在未来文章中涵盖Authz的架构。如果您对Authz或我们的开发过程有疑问，请留下评论。如果您想帮助我们建立下一个版本的Carta，我们正在招聘。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/building-carta/authz-cartas-highly-scalable-permissions-system-782a7f2c840f">https://medium.com/building-carta/authz-cartas-highly-scalable-permissions-system-782a7f2c840f</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/carta/">#carta</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/authz/">#authz</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>