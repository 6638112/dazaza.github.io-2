<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>等距块 IsometricBlocks</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">IsometricBlocks<br/>等距块 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-26 10:16:52</div><div class="page_narrow text-break page_content"><p>In an  isometricdisplay, it can be tricky to draw boxes of various sizes in the correct orderto keep them appropriately in front of or behind one another. The figure belowshows an example. The blue box should be drawn first, then green, then red.</p><p>在等轴测显示器中，以正确的顺序绘制各种大小的框以使其彼此正确地放置在前面或后面是很棘手的。下图显示了一个示例。应该先绘制蓝色框，然后绘制绿色，然后绘制红色。</p><p>    We will explore a simple solution for determining the correct order to draw agiven set of boxes. But first, we must define what we mean by  boxes.</p><p>    我们将探索一种简单的解决方案，用于确定绘制给定框的正确顺序。但是首先，我们必须定义盒子的含义。</p><p>    We define boxes as  axis-aligned and  non-intersectingrectangular prisms. Take a look at the above Figure 1 again. Each box isparallel to the  x,  y, and  z axis (i.e.axis-aligned). Also, note that the boxes are next to each other but do notintersect.</p><p>    我们将框定义为轴对齐和不相交的矩形棱柱。再次看一下上面的图1。每个框都平行于x，y和z轴（即轴对齐）。另外，请注意，这些框彼此相邻但不相交。</p><p>    First of all, if two boxes do not overlap on the screen, then we do not have toworry about which one is drawn first. This is the first test we must perform,which we explore in this section.</p><p>    首先，如果屏幕上没有两个框重叠，那么我们不必担心首先绘制哪个框。这是我们必须执行的第一个测试，我们将在本节中进行探讨。</p><p>    The silhouettes of the 3D boxes become 2D hexagons in the isometric view, as seen below. We use theoutline of these silhouettes to test for overlap.</p><p>    3D框的轮廓在等轴测图中变成2D六边形，如下所示。我们使用这些轮廓的轮廓来测试重叠。</p><p>    We take advantage of the fact that the hexagon sides are always parallel tosome axis. This allows us to easily determine if the hexagons overlap bychecking for intersection of their regions on each axis. We add an  h(horizontal) axis to help.</p><p>    我们利用了六角形边始终平行于某个轴这一事实。这使我们可以通过检查每个轴上区域的交点来轻松确定六边形是否重叠。我们添加了一个水平轴来提供帮助。</p><p>    Now that we have outlined our concept for  determining if two boxes overlapon the screen, we will fill in the details necessary for implementing it.</p><p>    既然我们已经概述了确定两个框是否在屏幕上重叠的概念，我们将填写实现它的必要细节。 </p><p>  The act of flattening the 3D box into a 2D hexagon involves getting rid of theZ coordinate. Notice that increasing a point&#39;s Z coordinate by 1 is the sameas incrementing both X and Y coordinates by 1. Thus, we can add Z to both Xand Y and drop Z completely. Shown below is the source code for a functionthat performs this conversion.</p><p>将3D框展平为2D六角形的操作涉及摆脱Z坐标。注意，将一个点的Z坐标增加1等同于将X和Y坐标都增加1。因此，我们可以将Z分别添加到X和Y并完全删除Z。下面显示的是执行此转换的功能的源代码。</p><p>  // Convert a 3D space position to a 2D isometric position. function spaceToIso(spacePos)  {  // New XY position simply adds Z to X and Y.  var isoX = spacePos.x + spacePos.z;  var isoY = spacePos.y + spacePos.z;  return  { x: isoX, y: isoY,  // Compute horizontal distance from origin. h: (isoX - isoY) * Math.cos(Math.PI/6),  // Compute vertical distance from origin. v: (isoX + isoY) / 2;  }; }  And finally, after determining the bounds of each hexagon, we can determine ifthey overlap by using the source code below.</p><p>  //将3D空间位置转换为2D等距位置。 function spaceToIso（spacePos）{//新的XY位置仅将Z添加到X和Y。var isoX = spacePos.x + spacePos.z; var isoY = spacePos.y + spacePos.z; return {x：isoX，y：isoY，//计算距原点的水平距离。 h：（isoX-isoY）* Math.cos（Math.PI / 6），//计算距原点的垂直距离。 v：（isoX + isoY）/ 2; }; }最后，在确定每个六边形的边界之后，我们可以使用下面的源代码确定它们是否重叠。</p><p>  function doHexagonsOverlap(hex1, hex2)  {  // Hexagons overlap if and only if all axis regions overlap.  return (  // test if x regions intersect. !(hex1.xmin &gt;= hex2.xmax || hex2.xmin &gt;= hex1.xmax) &amp;&amp;  // test if y regions intersect. !(hex1.ymin &gt;= hex2.ymax || hex2.ymin &gt;= hex1.ymax) &amp;&amp;  // test if h regions intersect. !(hex1.hmin &gt;= hex2.hmax || hex2.hmin &gt;= hex1.hmax)); }  Now that we have determined if two boxes overlap on the screen, we can begin exploring how to determine which box is in front of the other.</p><p>  函数doHexagonsOverlap（hex1，hex2）{//当且仅当所有轴区域都重叠时，六边形才重叠。 return（//测试x个区域是否相交！（hex1.xmin＆gt; = hex2.xmax || hex2.xmin＆gt; = hex1.xmax）＆amp;＆amp; //测试y个区域是否相交！（hex1.ymin ＆gt; = hex2.ymax || hex2.ymin＆gt; = hex1.ymax）＆amp;＆amp; //测试h区域是否相交！（hex1.hmin＆gt; = hex2.hmax || hex2.hmin＆gt; = hex1 .hmax））； }现在，我们已经确定了两个框在屏幕上是否重叠，我们可以开始研究如何确定哪个框在另一个框的前面。</p><p>    Recall that our boxes do not intersect each other. we can visualize their separationas a thin plane between them (see Figure 5 below). After identifying thisplane, we can determine which box is in front by selecting the one on thecorrect side of this plane.</p><p>    回想一下，我们的盒子彼此不相交。我们可以将它们的分离可视化为它们之间的一个薄平面（请参见下面的图5）。识别此平面后，我们可以通过选择该平面正确一侧的框来确定哪个框在前面。</p><p>    We can find this plane of separation by looking at each axis individually. Inparticular, we look for an axis which has non-intersecting box ranges (seeFigure 6 below).</p><p>    我们可以通过分别查看每个轴来找到分离平面。特别是，我们寻找的轴具有不相交的框范围（请参见下面的图6）。</p><p>    In Figure 6 above, we have chosen a coordinate system which make lesser valuesof  x and  y to be closer to the camera. Though not shown, the z axis is positive in the up direction, so a greater value makes itcloser to the camera.</p><p>    在上面的图6中，我们选择了一个坐标系，该坐标系使x和y的值较小，以更接近相机。尽管未显示，但z轴在向上方向上为正，因此较大的值使其更接近于相机。</p><p>  The following is a javascript function for determining if the first block is infront of the second:</p><p>  以下是用于确定第一个块是否位于第二个块前面的javascript函数： </p><p>   function isBoxInFront(box1, box2)  {  // test for intersection x-axis  // (lower x value is in front)  if (box1.xmin &gt;= box2.xmax)  {  return  false;  }  else  if (box2.xmin &gt;= box1.xmax)  {  return  true;  }  // test for intersection y-axis  // (lower y value is in front)  if (box1.ymin &gt;= box2.ymax)  {  return  false;  }  else  if (box2.ymin &gt;= box1.ymax)  {  return  true;  }  // test for intersection z-axis  // (higher z value is in front)  if (box1.zmin &gt;= box2.zmax)  {  return  true;  }  else  if (box2.zmin &gt;= box1.zmax)  {  return  false;  } }    In general,  a box should not be drawn until all the ones behind it aredrawn. Thus, we begin by drawing the boxes that have nothing behind them.Then, we can draw the boxes that are only in front of those that are alreadydrawn. This process continues until all boxes are drawn. (See Figure 4 belowfor an example.)</p><p>函数isBoxInFront（box1，box2）{//测试交点x轴//（x的下限值在前面）if（box1.xmin＆gt; = box2.xmax）{返回false; }否则，如果（box2.xmin＆gt; = box1.xmax）{返回true； } //测试交点y轴//（y的下限值在前面）if（box1.ymin＆gt; = box2.ymax）{返回false; }否则，如果（box2.ymin＆gt; = box1.ymax）{返回true； } //测试相交的z轴// //（更高的z值在前面）if（box1.zmin＆gt; = box2.zmax）{返回true; }否则，如果（box2.zmin＆gt; = box1.zmax）{返回false；通常，在绘制框后面的所有框之前，都不应绘制框。因此，我们首先绘制在其后面没有任何框的框，然后我们可以绘制仅在已绘制框之前的框。此过程将继续进行，直到绘制了所有框。 （有关示例，请参见下面的图4。）</p><p>    To implement this algorithm, each box must know exactly which boxes are behindit. We have already determined how to do this in the last section. A searchmust be implemented so that each box has a list of boxes behind it.</p><p>    要实现此算法，每个盒子都必须确切知道背后有哪些盒子。在上一节中，我们已经确定了如何执行此操作。必须实施搜索，以便每个框后面都有一个框列表。</p><p>  You are now armed with everything you need to know to render isometric boxes inthe correct order.</p><p>  现在，您已经掌握了以正确的顺序渲染等轴测框所需的全部知识。</p><p>    It is possible to have a situation seen in the figure below. The aforementioned drawingmethods dictate that we first draw the box with nothing behind it, but this example illustratesa case where this cannot be done.</p><p>    下图可能会出现这种情况。前面提到的绘制方法要求我们首先绘制没有任何框的框，但是此示例说明了无法执行此操作的情况。</p><p>    The figure above cheats by segmenting the orange box into two.This is one method of breaking this type of cycle.</p><p>    上图通过将橙色框分成两部分作弊，这是打破这种循环的一种方法。</p><p>  There are formal methods used for detectingsuch cycles mentioned in the appendix. After detection of a cycle, the blocks in that cyclecould be drawn with special clipping regions to respect front boxes or to segment a block or blocksthat will break the cycle. These are solutions that I will be exploring and updating this article asmy experiments progress.</p><p>  附录中提到了用于检测此类循环的正式方法。在检测到一个周期后，可以在该周期中的块上绘制特殊的剪切区域，以尊重前框或分割一个或多个会破坏该周期的块。这些是随着我的实验进展将探索和更新本文的解决方案。</p><p>          For those who are interested, our method for determining if hexagons and boxesare overlapping is a result of the  hyperplane separation theorem.</p><p>          对于那些感兴趣的人，我们确定六边形和盒子是否重叠的方法是超平面分离定理的结果。 </p><p>  Also, the way in which we determined the drawing order of the boxes is known in graph theory as a  topological sort</p><p>同样，我们确定盒子的绘制顺序的方法在图论中也被称为拓扑排序 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://shaunlebron.github.io/IsometricBlocks/">http://shaunlebron.github.io/IsometricBlocks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/等距/">#等距</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/绘制/">#绘制</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>