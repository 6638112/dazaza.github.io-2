<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Swift如何实现Rust无法实现的动态链接（2019） How Swift achieved dynamic linking where Rust couldn't (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Swift achieved dynamic linking where Rust couldn't (2019)<br/>Swift如何实现Rust无法实现的动态链接（2019） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-21 07:48:40</div><div class="page_narrow text-break page_content"><p>For those who don&#39;t follow Swift&#39;s development, ABI stability has been one of its most ambitious projects and possibly it&#39;s defining feature,  and it finally shipped in Swift 5. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.</p><p>对于那些不关注Swift开发的人来说，ABI稳定性一直是其最雄心勃勃的项目之一，并且可能是其定义功能，它最终在Swift 5中发布了。结果是我发现无休止地令人着迷，因为我认为Swift在没有太多妥协的情况下将ABI稳定性的概念推到了比任何一种语言都更高的水平。</p><p> So I decided to write up a bunch of the interesting high-level details of Swift&#39;s ABI. This  is not a complete reference for Swift&#39;s ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.</p><p> 因此，我决定写一堆Swift ABI有趣的高级细节。这不是Swift的ABI的完整参考，而是对其实现策略的抽象介绍。如果您真的想确切知道它如何分配寄存器或名称，请查看其他地方。</p><p> Also for context on why I&#39;m writing this, I&#39;m just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn&#39;t bother with ABI stability, and I think looking at how Swift  does helps elucidate why that is.</p><p> 同样，出于我为什么要编写此书的上下文，我自然倾向于将Swift和Rust的设计进行比较，因为这是我帮助开发的两种语言。还有一些人喜欢抱怨Rust不会打扰到ABI稳定性，而且我认为研究Swift的功能有助于阐明原因。</p><p> This article is broken up into two sections: background and details. Feel free to skip to the details if you&#39;re very comfortable with the problems inherent to producing a robust dynamically linked system interface.</p><p> 本文分为两个部分：背景和详细信息。如果您对产生健壮的动态链接的系统界面所固有的问题非常满意，请随时跳到细节。</p><p> If you aren&#39;t comfortable with the basic concepts of type layouts, ABIs, and calling conventions, I recommend reading the article I wrote on  the basic concepts of type layout and ABI as they pertain to Rust.</p><p> 如果您不熟悉类型布局，ABI和调用约定的基本概念，建议阅读我撰写的有关类型布局和ABI与Rust相关的基本概念的文章。</p><p> Also huge thanks to the Swift devs for answering all of the questions I had and correcting my misunderstandings!</p><p> 同样感谢Swift开发人员回答了我所有的问题并纠正了我的误解！</p><p>   I know a lot of people don&#39;t really follow Swift, and it can be hard to understand what they&#39;ve really accomplished without some context of what the language is like, so here&#39;s a TL;DR of the language&#39;s shape:</p><p>   我知道很多人并不真正遵循Swift，并且如果没有语言背景的某些背景知识，可能很难理解他们的真正成就，因此这里是TL的语言的形状： </p><p> An emphasis on &#34;value semantics&#34; classes are mutably shared and boxed (using ARC), undermining value semantics (can even cause data races)</p><p>强调＆＃34;值语义＆＃34;类被可变地共享和装箱（使用ARC），破坏了值的语义（甚至可能导致数据争用）</p><p> Don&#39;t worry about fully understanding all of these, we&#39;ll dig into the really important ones and their implications as we go on.</p><p> 不必担心完全理解所有这些内容，我们将继续研究真正重要的内容及其含义。</p><p>  When the Swift developers talk about &#34;ABI Stability&#34; they have exactly one thing in mind: they want native system APIs for MacOS and iOS to be written in Swift, and for you to dynamically link to them. This includes dynamically linking to a single system-wide copy of the Swift Standard Library.</p><p>  当Swift开发人员谈论＆＃34; ABI稳定性＆＃34;他们想到的只有一件事：他们希望MacOS和iOS的本机系统API用Swift编写，并让您动态链接到它们。这包括动态链接到Swift标准库的单个系统范围的副本。</p><p> Ok so what&#39;s dynamic linking? For our purposes it&#39;s a system where you can compile an application against some abstract  description of an interface without providing an actual implementation of it. This produces an application that on its own will not work properly, as part of its implementation is missing.</p><p> 好的，那么什么是动态链接？就我们的目的而言，它是一个系统，您可以根据接口的某些抽象描述来编译应用程序而无需提供接口的实际实现。这会产生一个应用程序，由于缺少其实现的一部分，它本身将无法正常运行。</p><p> To run properly, it must tell the system&#39;s  dynamic linker about all of the interfaces it needs implementations for, which we call  dynamic libraries (dylibs). Assuming everything goes right, those implementations get hooked up to the application and everything Just Works.</p><p> 为了正常运行，它必须告知系统动态链接器其需要实现的所有接口，我们称其为动态库（dylib）。假设一切正常，那么这些实现将与应用程序和“一切正常”挂钩。</p><p> Dynamic linking is very important to system APIs because it&#39;s what allows the system&#39;s implementation to be updated without also rebuilding all the applications that run on it. The applications don&#39;t care about what implementation they get, as long as it conforms to the interface they were built against.</p><p> 动态链接对系统API非常重要，因为它可以在不重新构建在其上运行的所有应用程序的情况下更新系统的实现。只要应用程序符合针对其构建的接口，应用程序就不会在乎它们将获得何种实现。</p><p> It can also significantly reduce a system&#39;s memory footprint by making every application share the same implementation of a library (Apple cares about this a lot on its mobile devices).</p><p> 通过使每个应用程序共享相同的库实现，Apple还可以显着减少系统的内存占用（Apple在其移动设备上非常在乎这一点）。 </p><p> Since Swift is AOT compiled, the application and the dylib both have to make a bunch of assumptions on how to communicate with the other side long before they&#39;re linked together. These assumptions are what we call ABI (an Application&#39;s  Binary Interface), and since it needs to be consistent over a long period of time, that ABI better be stable.</p><p>由于Swift是AOT编译的，因此应用程序和dylib都必须在将它们链接在一起之前很长时间就如何与另一方进行通信做出一系列假设。这些假设就是我们所谓的ABI（应用程序的二进制接口），并且由于它需要在很长一段时间内保持一致，因此ABI最好是稳定的。</p><p> So dynamic linking is our goal, and ABI stability is just a means to that end.</p><p> 因此，动态链接是我们的目标，而ABI稳定性只是达到此目的的一种手段。</p><p>   If you can define these details and never break them, you have a stable ABI, and dynamic linking can be performed. (Ignoring trivial cases where both the dylib and application were built together and ABI stability is irrelevant.)</p><p>   如果您可以定义这些详细信息并且永不破坏它们，那么您将拥有稳定的ABI，并且可以执行动态链接。 （忽略将dylib和应用程序同时构建且与ABI稳定性无关的琐碎情况。）</p><p> Now to be clear, ABI stability isn&#39;t technically a property of a programming language. It&#39;s really a property of a system and its toolchain. To understand this, let&#39;s look at history&#39;s greatest champion of ABI stability and dynamic linking: C.</p><p> 现在要弄清楚，从技术上讲ABI稳定性不是编程语言的特性。它实际上是系统及其工具链的属性。为了理解这一点，让我们看一下历史上ABI稳定性和动态链接的最大拥护者：C。</p><p> All the major OSes make use of C for their dynamically linked system APIs. From this we can conclude that C &#34;has&#34; a stable ABI. But here&#39;s the catch: if you compile some C code for dynamic linking on Ubuntu, that compiled artifact won&#39;t work on MacOS or Windows. Heck, even if you compile it for 64-bit Windows it won&#39;t work on 32-bit Windows!</p><p> 所有主要的OS都将C用于其动态链接的系统API。由此我们可以得出结论，C具有稳定的ABI。但是这里有个问题：如果您在Ubuntu上编译一些用于动态链接的C代码，那么编译后的工件就无法在MacOS或Windows上运行。哎呀，即使您针对64位Windows进行编译，它也无法在32位Windows上运行！</p><p> Why? Because ABI is something defined by the  platform. It&#39;s not even something that necessarily needs to be documented. The platform vendor can just require you to use a particular compiler toolchain that happens to implement their stable ABI.</p><p> 为什么？因为ABI是平台定义的。甚至没有必要将其记录下来。平台供应商可能只要求您使用恰好实现其稳定ABI的特定编译器工具链。</p><p> (As it turns out, this is actually the reality of Swift&#39;s Stabilized ABIs on Apple platforms. They&#39;re not actually properly documented, xcode just implements it and the devs will do their best not to break it. They&#39;re not opposed to documenting it, it&#39;s just a lot of work and shipping was understandably higher-priority. Thankfully I don&#39;t really care about the details, or the difference between the ABIs on MacOS and iOS, or implementations other than Apple&#39;s, so I can keep saying &#34;Swift&#39;s ABI&#34; and it won&#39;t be a problem.)</p><p> （事实证明，这实际上是Apple平台上Swift的稳定化ABI的现实。它们并没有得到适当的记录，xcode只是实现了它，开发人员将尽最大努力不破坏它。 ＃39;不反对记录文档，它只是很多工作，并且可以优先考虑运输。幸运的是，我并不真正关心细节，也不关心MacOS和Windows上的ABI之间的区别。 iOS或Apple以外的其他实现，因此我可以继续说一下Swift的ABI，这不会有问题。） </p><p> But if that&#39;s the case, why don&#39;t platform vendors provide stable ABIs for lots of other languages? Well it turns out that the language isn&#39;t completely irrelevant here. Although ABI isn&#39;t &#34;part&#34; of C itself, it  is relatively friendly to the concept. Many other languages aren&#39;t.</p><p>但是，既然如此，为什么平台供应商不为许多其他语言提供稳定的ABI？事实证明，这里的语言并非完全无关。尽管ABI不是该部分对于C本身，它对这个概念相对友好。不是很多其他语言。</p><p> To understand why C is friendly to ABI stability, let&#39;s look at its much less friendly big brother, C++.</p><p> 为了理解C为什么对ABI稳定性友好，让我们看一下C不太友好的老大哥。</p><p> Templated C++ functions cannot have their implementations dynamically linked. If I provide you with a system header that provides the following declaration, you simply can&#39;t use it:</p><p> 模板化的C ++函数无法动态链接其实现。如果我为您提供了提供以下声明的系统头，则您将无法使用它：</p><p>  This is because  it has no symbol. C++ templates are monomorphically compiled, which is a fancy way of saying that the way to use them is to copy-paste the implementation with all the templates replaced with a particular value.</p><p>  这是因为它没有符号。 C ++模板是经过单态编译的，这是一种奇特的说法，即使用它们的方法是将所有模板替换为特定值，然后复制粘贴实现。</p><p> So if I want to call  process&lt;int&gt;(0), I need to have the implementation available to copy-paste it with  int replacing  T. Needing to have the implementation available at compile-time completely undermines the concept of dynamic linking.</p><p> 因此，如果我想调用process＆lt; int＆gt;（0），则需要有可用int替换T进行复制粘贴的实现。需要在编译时实现的实现完全破坏了动态链接的概念。</p><p> Now perhaps the platform could make a promise that it has precompiled several monomorphic instances, so say symbols for  process&lt;int&gt; and  process&lt;bool&gt; are available. You could make that work, but then the function wouldn&#39;t really be meaningfully templated anymore, as only those two explicitly blessed substitutions would be valid.</p><p> 现在，也许平台可以保证它已经预编译了几个单态实例，所以可以说process int的符号。和处理＆lt; bool＆gt;可用。您可以进行这项工作，但是实际上该函数将不再具有意义上的模板化，因为只有这两个明确祝福的替换才有效。</p><p>   Now a header  could just include the template&#39;s implementation, but what that would really be guaranteeing is that that particular implementation will  always be valid. Future versions of the header could introduce new implementations, but a robust system would have to assume applications could using either, or perhaps even both at the same time.</p><p>   现在，标头可能只包含模板的实现，但真正要保证的是该特定实现将始终有效。头文件的未来版本可能会引入新的实现，但是一个健壮的系统将必须假定应用程序可以同时使用其中之一，甚至可以同时使用两者。 </p><p> This is no different from a C macro or  inline function, but I think it&#39;s fair to say that templates are a little more important in C++.</p><p>这与C宏或内联函数没有什么不同，但我认为它＆＃39;博览会说，模板在C ++中有点重要。</p><p> For comparison, most platforms provide a dynamically linked version of the C standard library, and everyone uses it. On the other hand, C++&#39;s standard library isn&#39;t very useful to dynamically link to; it&#39;s literally called the Standard  Template Library!</p><p> 例如，大多数平台提供了C标准库的动态链接版本，每个人都使用它。另一方面，C ++＆＃39; S标准库ISN＆＃39;动态链接非常有用;它＆＃39;字面上称为标准模板库！</p><p> In spite of this issue (and many others), C++  can be dynamically linked and used in an ABI-stable way! It&#39;s just that it ends up looking a lot more like a C interface due to the limitations.</p><p> 尽管有这个问题（以及许多其他人），C ++可以动态链接并以ABI稳定的方式使用！它＆＃39;它只是由于限制，它最终看起来更像是C接口。</p><p> Idiomatic Rust is similarly hostile to dynamic linking (it also uses monomorphization), and so an ABI-stable Rust would also end up only really supporting C-like interfaces. Rust has largely just embraced that fact, focusing its attention on other concerns.</p><p> 惯用毒殖类似于动态链接（它也使用单数化），因此ABI稳定的锈病也将仅最终确切地支持C样界面。 Rust在很大程度上刚刚接受了这一事实，将其关注其他问题。</p><p>    The secret lies in where the two languages diverge: dynamism. Rust is a  very static and explicit language, reflecting the sensibilities of its developers and early adopters. Swift&#39;s developers preferred a much more dynamic and implicit design, and so that&#39;s what they made.</p><p>    秘密在于两种语言分歧的地方：活力。 Rust是一种非常静态和明确的语言，反映了其开发人员和早期采用者的敏感性。 Swift＆＃39;开发人员首选更具动态和隐含的设计，所以它们所做的更具动态和隐式的设计。</p><p> As it turns out, hiding implementation details and doing more work at runtime is  really friendly to dynamic linking. Who&#39;d&#39;ve thought dynamic linking was dynamic?</p><p> 事实证明，隐藏实施细节并在运行时执行更多工作对于动态链接非常友好。谁＆＃39; D＆＃39; VE IDS IDENT动态连接是动态的吗？</p><p>  It&#39;s actually fairly trivial to dynamically link a system where all the implementation details are hidden behind uniformity and dynamism. In the extreme case, we could make a system where everything is an opaque pointer and there&#39;s only one function that just sends things strings containing commands. Such a system would have a very simple ABI!</p><p>  它实际上是相当微不足道的，可以动态链接一个系统，其中所有实施细节隐藏在均匀性和动态之后。在极端情况下，我们可以制作一个系统，其中一切都是不透明的指针，而且只有一个函数，只需发送包含命令的字符串的函数。这样的系统会有一个非常简单的abi！ </p><p> And indeed, in the 90&#39;s there was a big push in this direction with Microsoft embracing  COM and Apple embracing  Objective-C as ways to build system interfaces with simple and robust ABIs.</p><p>的确，在90年代，随着Microsoft拥抱COM和Apple拥抱Objective-C作为使用简单而强大的ABI构建系统接口的方法，在这个方向上有了很大的推动。</p><p> But Swift didn&#39;t do this. Swift tries its hardest to generate code comparable to what you would expect from Rust or C++, and how it accomplishes that is what makes its ABI so interesting.</p><p> 但是Swift并没有这样做。 Swift尽最大努力来生成与Rust或C ++所期望的代码可比的代码，而它是如何实现的，才使得它的ABI如此有趣。</p><p> It&#39;s worth noting that the Swift devs disagree with the Rust and C++ codegen orthodoxy in one major way: they care much more about code sizes (as in the amount of executable code produced). More specifically, they care a lot more about making efficient usage of the cpu&#39;s instruction cache, because they believe it&#39;s better for system-wide power usage. Apple championing this concern makes a lot of sense, given their suite of battery-powered devices.</p><p> 值得注意的是，Swift开发人员在一个主要方面不同意Rust和C ++代码生成的正统观念：他们更在乎代码大小（如生成的可执行代码数量）。更具体地说，他们更关心有效利用cpu指令高速缓存的原因，因为他们认为这样对系统范围的电源使用效果更好。考虑到苹果公司使用电池供电的设备套件，支持这种担忧在很大程度上是有意义的。</p><p> It&#39;s harder for third party developers to care about this, as they will naturally only control some small part of the software running on a device, and typical benchmarking strategies don&#39;t really capture &#34;this change made your application run faster but is making some background services less responsive and hurting battery life&#34;. Hence C++ and Rust inevitably pushing towards &#34;more code, more fast&#34;.</p><p> 第三方开发人员更不必担心这一点，因为他们自然只会控制设备上运行的软件的一小部分，而典型的基准测试策略并不能真正抓住这一变化。您的应用程序运行速度更快，但使某些后台服务的响应速度降低，并损害了电池寿命。＆＃34;因此，C ++和Rust不可避免地向着“更多代码，更快”的方向发展。</p><p> This is all to say that some things which seem like compromises made for ABI stability&#39;s sake are genuinely just regarded as desirable.</p><p> 这就是说，为ABI稳定性着想而做出的一些妥协实际上只是被认为是可取的。</p><p> I never got any great concrete numbers on this concern from the Swift or Foundation folks, would definitely love to see some!  Waves at the Apple employees reading this.</p><p> 我从来没有从Swift或Foundation员工那里得到任何关于此问题的具体数字，一定会喜欢的！苹果公司员工在阅读这篇文章时大声疾呼。</p><p>  The Swift developers cover this topic fairly well in their documentation. I&#39;ll just be giving a simplified version, focusing on the basic motivation.</p><p>  Swift开发人员在其文档中很好地涵盖了这个主题。我只是给出一个简化的版本，重点放在基本动机上。 </p><p> Resilience is the core concept behind Swift&#39;s dynamic linking story. It means that things default to having ABIs that are  resilient to breaking when the implementation changes in an API-preserving way (nothing can save API-breaking changes). This allows developers to create dynamically linked and idiomatic-feeling libraries that can still easily evolve their implementations.</p><p>弹性是Swift动态链接故事背后的核心概念。这意味着默认情况下，当实现以保留API的方式更改时，ABI可以抵抗破坏（没有东西可以保存破坏API的更改）。这使开发人员可以创建动态链接的和习惯用法的库，这些库仍然可以轻松地扩展其实现。</p><p> This is in contrast to C, which only makes it  possible to create a stable ABI with proper vigilance and foresight. This is because C requires you to commit to many of the ABI details of your interface upfront, even if you&#39;re uncertain about them. If you don&#39;t want to commit to those details, you&#39;ll have to change the shape of your API to hide them.</p><p> 这与C相反，C仅使创建具有适当警惕性和远见的稳定ABI成为可能。这是因为C要求您预先确定接口的许多ABI详细信息，即使您不确定它们也是如此。如果您不想提交这些详细信息，则必须更改API的形状以隐藏它们。</p><p> When compiled as a dylib, Swift defaults to implicitly hiding as many details as possible, requiring you to opt into guarantees by adding annotations. Crucially, these annotations don&#39;t affect the shape of an API, they&#39;re &#34;only&#34; for optimizing the ABI, at the cost of resilience.</p><p> 当编译为dylib时，Swift默认默认隐式隐藏尽可能多的细节，要求您通过添加批注选择加入保证。至关重要的是，这些注释不会影响API的形状，它们只是“”。用于优化ABI，但要以弹性为代价。</p><p> Additionally,  some ABI annotations can be added after a library has been published without breaking the old ABI. Applications compiled against new annotations are able to use that information to run faster, at the cost of compatibility with older versions of the library.</p><p> 此外，可以在发布库后添加一些ABI批注，而不会破坏旧的ABI。使用新注释编译的应用程序能够使用该信息来更快地运行，但要以与旧版本库的兼容性为代价。</p><p> (It seems the Swift devs ran out of time/resources and quite reasonably cut a few corners in this department. Several annotations which plausibly could be done in a backwards-compatible way are ultimately breaking to add. Ah well, pobody&#39;s nerfect.)</p><p> （看来，Swift开发人员用完了时间/资源，并在这个部门相当合理地偷工减料。似乎可以以向后兼容的方式完成的一些注释最终被添加了。嗯，pobody nerfect。）</p><p>      Now let&#39;s say we realize that this function should also provide info on when it was last modified:</p><p>      现在让我们说我们意识到该函数还应该提供有关上次修改时间的信息：</p><p> // version 2 typedef  struct {  int64_t  last_modified_time;  // 64 bits CLEARLY enough...  int64_t  size;}  FileMetadata; bool  get_file_metadata( char *  path,  FileMetadata *  output);</p><p> //版本2 typedef struct {int64_t last_modified_time; // 64位足够清晰... int64_t size;} FileMetadata; bool get_file_metadata（char *路径，FileMetadata *输出）; </p><p> Oops, we&#39;ve messed up our ABI! Our hypothetical caller is stack allocating a FileMetadata, so they&#39;re assuming it has a particular size and alignment. Additionally, they&#39;re directly accessing the  size field, which they assume is at a particular offset in the struct.</p><p>糟糕，我们搞砸了我们的ABI！我们的假设调用者正在堆栈中分配FileMetadata，因此他们假设该文件具有特定的大小和对齐方式。此外，他们直接访问size字段，他们假定此字段位于结构中的特定偏移处。</p><p> Both of those assumptions were violated by our change. This didn&#39;t necessarily have to happen. There&#39;s a few common approaches we could have taken to allow for this change. For instance we could have:</p><p> 我们的变更违反了这两个假设。这不一定必须发生。我们可以采用几种常见的方法来进行此更改。例如，我们可以有：</p><p>  Unfortunately, all of these require us to have the foresight to do them while also changing the way users make use of our API. In some sense, the API becomes less &#34;idiomatic&#34; to accommodate future changes. Additionally, we will forever be burdened with this complexity even if we eventually determine that the API is complete enough to guarantee its details.</p><p>  不幸的是，所有这些都要求我们具有远见卓识，并且还必须改变用户使用我们的API的方式。从某种意义上说，该API变得越来越＆＃34;惯用＆＃34;。以适应未来的变化。此外，即使我们最终确定API足够完整以保证其详细信息，我们也将永远担负这种复杂性。</p><p>   // version 1 public  struct  FileMetadata {  public  var  size:  Int64} public  func  getFileMetadata( _  path:  String)  -&gt;  FileMetadata ?</p><p>   //版本1 public struct FileMetadata {public var size：Int64} public func getFileMetadata（_ path：String）-＆gt; FileMetadata？</p><p> // version 2 public  struct  FileMetadata {  public  var  lastModifiedTime:  Int64  // just add this field, that&#39;s it  public  var  size:  Int64} public  func  getFileMetadata( _  path:  String)  -&gt;  FileMetadata ?</p><p> //版本2 public struct FileMetadata {public var lastModifiedTime：Int64 //仅添加此字段，它就是public var size：Int64} public func getFileMetadata（_ path：String）-＆gt; FileMetadata？</p><p> Unfortunately, guaranteeing the layout of FileMetadata using the  @frozen attribute in future versions  would be an ABI breaking change under the current design. Hopefully it will be clear why by the end of this document.</p><p> 不幸的是，在当前版本中使用@frozen属性保证FileMetadata的布局将是ABI的重大突破。希望在本文末尾会很清楚。</p><p>  Ok! Now for the details, where I will in fact be ignoring the  actual details and instead discussing the high level ideas behind them.</p><p>  好的！现在，对于细节，我实际上将忽略实际细节，而是讨论其背后的高级想法。 </p><p> Once again, feel free to check out  Swift&#39;s documentation of the annotations that are used to manage abi resilience. That covers a lot of motivation and the fine-grain details of what you can and can&#39;t do.</p><p>再一次，请随时查看Swift的用于管理abi弹性的注释文档。这涵盖了很多动机以及可以做什么和不能做什么的细节。</p><p>  By default, a type that is defined by a dylib has a  resilient layout. This means that the size, alignment,  stride, and  extra inhabitants of that type aren&#39;t statically known to the application. To get that information, it must ask the dylib for that type&#39;s  value witness table at runtime.</p><p>  默认情况下，由dylib定义的类型具有弹性布局。这意味着该类型的大小，对齐方式，步幅和其他居民并不是应用程序静态知道的。要获取该信息，它必须在运行时向dylib询问该类型的值见证表。</p><p> &#34;Witness tables&#34; are Swift&#39;s term for what are ultimately vtables. The details of how these tables are acquired and laid out don&#39;t really interest me, so I won&#39;t discuss that.</p><p> ＆＃34;见证表＆＃34;是Swift的最终vtables术语。这些表的获取和布局方式的详细信息并不会引起我的兴趣，因此我将不进行讨论。</p><p> Ok actually it is Interesting that Swift needs to be able to generate witness tables at runtime to deal with the fact that generic type substitutions can&#39;t be statically predicted in the face of dynamic linking of generic code, but that&#39;s getting way ahead of ourselves.</p><p> 好的，实际上，有趣的是，Swift需要能够在运行时生成见证表来处理以下事实：面对通用代码的动态链接，无法静态地预测通用类型的替换，但是超越自己。</p><p> The  value witness table is just the &#34;vtable of basic stuff you might want to know about any type&#34;, much like how Java&#39;s  Object type is used. So it has all the stuff like size, alignment, stride, extra inhabitants, move/copy constructors (for ARC), and destructors.</p><p> 值见证人表只是您可能想知道的关于任何类型的基本内容的表格，就像使用Java的对象类型一样。因此，它具有所有内容，例如大小，对齐方式，步幅，额外的居民，移动/复制构造函数（用于ARC）和析构函数。</p><p> At this point those with experience in language design probably suspect this results in resilient types having to be boxed and passed around as a pointer. And those suspicions are indeed correct... but not quite.</p><p> 在这一点上，那些具有语言设计经验的人可能会怀疑这导致必须将弹性类型装箱并作为指针传递。这些怀疑确实是正确的……但并非完全如此。</p><p> See what&#39;s really interesting about resilient layout is that it&#39;s only something that the application is forced to deal with, and only in a very limited way. Inside the boundaries of the dylib where all of its own implementation details are statically known, the type is handled as if it wasn&#39;t resilient.</p><p> 看到弹性布局真正有趣的地方在于，它只是应用程序被迫处理的事情，而且处理方式非常有限。在dylib的边界内，所有它自己的实现细节都是静态已知的，该类型的处理就好像它没有弹性。 </p><p> Inside the dylib a resilient struct is stored inline, stored on the stack, passed around by value, and even scalarized. But once we move outside the dylib something else must be done.</p><p>在dylib内部，有弹性的结构被内联存储，存储在堆栈中，按值传递，甚至被标量化。但是，一旦我们离开了dylib，就必须做其他事情。</p><p> We could potentially accomplish this with expensive type layout conversion at the boundaries, but we don&#39;t! Type layouts are always the same on both sides of the resilience boundary!</p><p> 我们可以通过在边界进行昂贵的类型布局转换来实现此目标，但是我们不这样做！弹性边界的两侧的类型布局始终相同！</p><p>   The key insight here is that laying out things inline can actually be done dynamically with relative ease. Memory allocators and pointers don&#39;t care about static layouts, they just work with completely untyped sizes, alignments, and offsets. So as long as you have all the relevant value witness tables, everything works basically fine, just with more dynamic values than usual.</p><p>   此处的关键见解是实际上可以相对轻松地动态地进行内联布置。内存分配器和指针并不关心静态布局，它们只适用于完全无类型的大小，对齐方式和偏移量。因此，只要您具有所有相关的值见证人表，一切就可以正常工作，并且具有比平常更多的动态值。</p><p> The real major problem is stack allocations. llvm really doesn&#39;t like dynamic stack allocations. Yes,  alloca does exist, but it&#39;s a bit messy. I believe the Swift devs managed to get it working all the time for resilient layout, but not for some of its cousins we&#39;ll see in the next section. In the general case, local variables need to actually be boxed up onto the heap. For convenience, I&#39;ll just generically refer to these dynamic stack allocations as &#34;boxed&#34;.</p><p> 真正的主要问题是堆栈分配。 llvm确实不喜欢动态堆栈分配。是的，alloca确实存在，但是有点混乱。我相信Swift开发人员设法使其始终保持工作状态以实现灵活的布局，但是在下一节中我们不会看到它的一些表亲。在一般情况下，实际上需要将局部变量装箱到堆上。为方便起见，我将这些动态堆栈分配统称为“盒装”。</p><p> Crucially this boxing this doesn&#39;t change layouts, just where local variables are stored and how they&#39;re passed in the calling convention (more on that later). Also, once there is  some indirection everything is still stored inline. So types which already come with indirection like  Array&lt;MyResilientStruct&gt; or  MyResilientClass require  no additional allocation, and consequently no ABI changes.</p><p> 最重要的是，此框不会更改布局，仅更改局部变量的存储位置以及如何在调用约定中传递局部变量（稍后会详细介绍）。同样，一旦存在某种间接，所有内容仍将以内联方式存储。因此，诸如Array＆lt; MyResilientStruct＆gt;之类的已经附带了间接性的类型将被添加。或MyResilientClass不需要其他分配，因此不需要更改ABI。</p><p> I&#39;ve left out some key details, but let&#39;s address them while looking at polymorphic generics, since it turns out those are quite similar, but also more interesting!</p><p> 我遗漏了一些关键细节，但是让我们在查看多态泛型时解决了这些关键细节，因为事实证明它们非常相似，但是也更有趣！</p><p>  Unlike Rust and C++ which must monomorphize (copy+paste) implementations for each generic/template substitution, Swift is able to compile a generic function into a single implementation that can handle every substitution dynamically.</p><p>  与Rust和C ++不同，Rust和C ++必须对每个泛型/模板替换进行单一化（复制+粘贴）实现，Swift能够将泛型函数编译成一个可以动态处理每个替换的实现。 </p><p>   A polymorphic implementation can&#39;t be inlined or optimized as well as a monomorphic one (without a JIT), so the Swift compiler still monomorphizes things when it&#39;s possible and seems profitable. But we&#39;re making a dylib, so it&#39;s not possible for our public API.</p><p>多晶型实施可以＆＃39; t被系列或优化以及单数（没有JIT），所以Swift编译器仍然单一的东西，当它可能并且似乎有利可图。但是我们＆＃39;重新制作达达布，所以它的公共API不可能。</p><p> As it turns out, polymorphically compiled generic code is really quite similar to code that handles resilient types. In both cases the basic value-witnessy properties of the type aren&#39;t statically known, and so stack values need boxing. The generic code just needs to be able to find the generic type&#39;s protocol implementations too. We can get that from the type&#39;s  protocol witness tables which can be acquired using the same machinery we use for the value witness tables.</p><p> 事实证明，多态编译的通用代码与处理弹性类型的代码非常相似。在这两种情况下，AREN＆＃39; T静态名称的基本值 - 目击属性，静态堆叠值需要拳击。通常需要能够找到通用类型和＃39; S协议实现。我们可以从类型和＃39; S协议见表中获取，可以使用我们使用的相同机器获取的表格见表。</p><p>    The resilient/polymorphic type machinery solves a big chunk of  the Object Safety problem that heavily limits Rust&#39;s trait objects. Swift calls these  Protocols as Types or just  existentials, depending on who you ask. Generic code actually having symbols means there&#39;s no problem with it being stuffed in a vtable. Resilient layout eliminates the problems that come with dynamic &#34;by value&#34; manipulation of Self and any of its associated types.</p><p>    弹性/多晶型机械解决了对象安全问题的大块，这些问题严重限制了生锈＆＃39; Swift将这些协议称为类型或只是存在的，具体取决于您的要求谁。实际上具有符号的通用代码意味着它没有问题在vtable中填充。弹性布局消除了动态＆＃34的问题;按值＆＃34;操纵自我和任何相关类型。</p><p> Existentials are the really tricky case for stack allocations, because they can prevent the caller from knowing the size of the return value before making the call, and that really messes up alloca. So once existentials get involved, alloca goes out the window and actual boxing needs to happen.</p><p> 存在性是堆栈分配的真正棘手的案例，因为它们可以防止调用者在拨打呼叫之前了解返回值的大小，并且真的搞砸了AlloCa。因此，一旦存在涉及，AlloCa熄灭了窗户，需要发生实际拳击。</p><p> Also associated types in function signatures still prevent existentials from being created because that creates fundamental type system problems unrelated to ABI. Every instance of MyProtocol could have a different associated type, and you can&#39;t let them get mixed up. No I&#39;m not going to get into how Swift could </p><p> 函数签名中的关联类型仍然阻止所存在的存在，因为它会产生与ABI无关的基本类型系统问题。 MyProtocol的每个实例都可以具有不同的相关类型，您可以＆＃39; t让他们混淆。不，我不会进入如何迅速</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gankra.github.io/blah/swift-abi/">https://gankra.github.io/blah/swift-abi/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/achieved/">#achieved</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>