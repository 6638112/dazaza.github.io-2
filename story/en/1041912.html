<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可执行的PNG Executable PNGs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Executable PNGs<br/>可执行的PNG </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-26 21:27:52</div><div class="page_narrow text-break page_content"><p>A few weeks ago I was reading about  PICO-8, a fantasy games console with limited constraints. What really piqued my interest about it was the novel way games are distributed, you encode them into a PNG image. This includes the game code, assets, everything. The image can be whatever you want, screenshots from the game, cool artwork or just text. To load them you pass the image as input to the PICO-8 program and start playing.</p><p>几周前，我在阅读有关PICO-8的信息，PICO-8是一款受限限制的幻想游戏机。真正引起我兴趣的是新颖的游戏发行方式，您将其编码为PNG图像。这包括游戏代码，资产以及所有内容。图像可以是您想要的任何图像，游戏的屏幕截图，精美的艺术品或仅仅是文字。要加载它们，您将图像作为输入传递到PICO-8程序并开始播放。</p><p> This got me thinking, wouldn’t it be cool if you could do that for programs on Linux? No! I hear you cry, that’s a dumb idea, but whatever, herein lies an overview of possibly the dumbest things I’ve worked on this year.</p><p> 这让我开始思考，如果您可以为Linux上的程序做到这一点，这会很酷吗？没有！我听到你在哭，这是一个愚蠢的主意，但无论如何，这里概述了我今年从事的最愚蠢的工作。</p><p>  I’m not entirely sure what PICO-8 is actually doing, but at a guess it’s probably use  Steganography techniques to ‘hide’ the data within the raw bytes of the image. There are a lot of resources out there that explain how Steganography works, but the crux of it is quite simple, your image your want to hide data into is made up of bytes, an image is made up of pixels. Pixels are made up of 3 Red Green and Blue (RGB) values, represented as 3 bytes. To hide your data (the “payload”) you essentially “mix” the bytes from your payload with the bytes from the image.</p><p>  我不确定PICO-8到底在做什么，但据猜测它可能使用隐写术技术“隐藏”了图像原始字节中的数据。有很多资源可以解释隐写术的工作原理，但是其症结很简单，您要隐藏数据的图像由字节组成，图像由像素组成。像素由3个红色，绿色和蓝色（RGB）值组成，表示为3个字节。要隐藏数据（“有效负载”），您实际上是将“有效负载”中的字节与图像中的字节“混合”。</p><p> If you just replaced each byte in your cover image with the bytes from your payload, you would end up with sections of the image looking distorted as the colours probably wouldn’t match with what your original image was. The trick is to be as subtle as possible, or  hide in plain sight. This can be achieved by  spreading your payload bytes over the bytes of the cover image by using the  least significant bits to hide them in. In other words, make subtle adjustments to the byte values so the colour changes are not drastic enough to be perceptive by the human eye.</p><p> 如果您只是用有效负载中的字节替换了封面图像中的每个字节，那么最终图像的某些部分会看起来失真，因为颜色可能与原始图像不匹配。诀窍是要尽可能地微妙，或者隐藏在清晰的视线中。这可以通过以下方式实现：使用最低有效位将有效载荷字节散布在封面图像的字节上，以将其隐藏。换句话说，请对字节值进行细微调整，以使颜色变化不大得足以被人察觉。人眼。</p><p> For example if your payload was the letter  H, represented as  01001000 in binary (72), and your image contained a series of black pixels</p><p> 例如，如果您的有效载荷是字母H，以二进制（72）表示为01001000，并且您的图像包含一系列黑色像素</p><p>  The output is two-and-a-bit pixels that are slightly less black than before, but can you tell the difference?</p><p>  输出的是两位像素，其黑色比以前少了一点，但是您能分辨出区别吗？</p><p>  Well, an exceptionally trained colour connoisseur might be able to, but in reality these subtle shifts can really only be noticed by a machine. Retrieving your super secret  H is just a matter of reading 8 bytes from the resulting image and re-assembling them back into 1 byte. Obviously hiding a single letter is lame, but this can scale to anything you want, a super secret sentence, a copy of  War and Peace, a link to your soundcloud, the go compiler, the only limit is the amount of bytes available in your cover image as you’ll require at least 8x whatever your input is.</p><p>  好吧，一个受过专门训练的色彩鉴赏家也许可以，但是实际上，这些细微的变化实际上只能由一台机器注意到。检索超级机密H只需从生成的图像中读取8个字节，然后将它们重新组合为1个字节即可。显然，隐藏单个字母很la脚，但这可以扩展到任何您想要的东西，一个超级秘密的句子，《战争与和平》的副本，一个指向您的Soundcloud的链接，一个go编译器，唯一的限制是您的可用字节数封面图片，因为无论您输入什么内容，您都需要至少8倍的图像。 </p><p>  So, back to the whole linux-executables-in-an-image thing, that old chestnut. Well, seeing as executables are just bytes, they can be hidden in images. Just like in the PICO-8 thing.</p><p>因此，回到整个linux-executables-in-image的东西，那个古老的栗子。好吧，看到可执行文件只是字节，它们可以隐藏在图像中。就像在PICO-8中一样。</p><p> Before I could achieve this I decided to write my own  Steganography library and  tool to support encoding and decoding data into PNGs. Yes, there are lots of steganography libraries and tools out there but I learn better by building.</p><p> 在实现这一目标之前，我决定编写自己的隐写术库和工具以支持将数据编码和解码为PNG。是的，那里有许多隐写术库和工具，但是通过构建，我学得更好。</p><p> $ stegtool encode  \ --cover-image htop-logo.png  \ --input-data /usr/bin/htop  \ --output-image htop.png$$  echo  &#34;Super secret hidden message&#34; | stegtool encode  \ --cover-image image.png  \ --output-image image-with-hidden-message.png$ stegtool decode --image image-with-hidden-message.pngSuper secret hidden message</p><p> $ stegtool编码\ --cover-image htop-logo.png \ --input-data / usr / bin / htop \ --output-image htop.png $$ echo＆＃34;超级秘密隐藏消息＆＃34; | stegtool编码\ --cover-image image.png \-输出图像image-with-hidden-message.png $ stegtool解码--image image-with-hidden-message.png</p><p> As it’s all written in  Rust it wasn’t that difficult to compile to WASM, so feel free to play with it here:</p><p> 由于所有内容都是用Rust编写的，因此可以轻松地将其编译为WASM，因此可以在这里随意使用：</p><p>  Anyway, now that can embed data, including executables into an image, how do we run them?</p><p>  无论如何，现在可以将包括可执行文件在内的数据嵌入到映像中，我们如何运行它们？</p><p>  The simple option would be to just run the tool above,  decode the data into a new file,  chmod +x it and then run it. It works but that’s not fun enough. What I wanted was something similar to the PICO-8 experience, you pass something a PNG image and it takes care of the rest.</p><p>  简单的选择是只运行上面的工具，将数据解码为一个新文件，然后chmod + x然后运行它。可以，但是还不够有趣。我想要的是类似于PICO-8的体验，您传递了一个PNG图像，其余的都由它来处理。</p><p> However, as it turns out, you can’t just load some arbitrary set of bytes into memory and tell Linux to jump to it. Well, not in a direct way anyway, but you  can use some cheap tricks to fudge it.</p><p> 但是，事实证明，您不能只是将任意一组字节加载到内存中并告诉Linux跳转到它。好吧，无论如何都不是直接的，但是您可以使用一些廉价的技巧来捏造它。 </p><p>  After reading  this blogpost it became apparent to me you can create an in-memory file and mark it as executable</p><p>阅读此博客文章后，对我来说很明显，您可以创建一个内存文件并将其标记为可执行文件</p><p> Wouldn’t it be cool to just grab a chunk of memory, put our binary in there, and run it without monkey-patching the kernel, rewriting execve(2) in userland, or loading a library into another process?</p><p> 仅仅获取一块内存，将二进制文件放入其中，然后运行它而不用猴子修补内核，在用户区中重写exe​​cve（2）或将库加载到另一个进程中，这不是很酷吗？</p><p> This method uses the syscall  memfd_create(2) to create a file under the  /proc/self/fd namespace of your process and load any data you want in it using  write. I spent quite a while messing around with the  libc bindings for Rust to get this to work, and had a lot of trouble understanding the data types you pass around, the documentation for these Rust bindings doesn’t help much.</p><p> 此方法使用syscall memfd_create（2）在进程的/ proc / self / fd命名空间下创建一个文件，并使用write加载所需的任何数据。我花了相当长的时间弄乱Rust的libc绑定才能使其正常工作，并且在理解您传递的数据类型时遇到了很多麻烦，这些Rust绑定的文档并没有太大帮助。</p><p>  unsafe  {    let  write_mode   =   119;   // w    // create executable in-memory file    let  fd   =  syscall(libc::SYS_memfd_create,   &amp;write_mode,   1);    if  fd   ==   - 1  {    return   Err( String::from( &#34;memfd_create failed&#34;));   }     let  file   =  libc::fdopen(fd,   &amp;write_mode);      // write contents of our binary   libc::fwrite(   data.as_ptr()   as   * mut  libc::c_void,     8   as   usize,   data.len()   as   usize,   file,   );  }</p><p>  不安全{让write_mode = 119; // w //创建可执行的内存文件let fd = syscall（libc :: SYS_memfd_create，＆amp; write_mode，1）;如果fd ==-1 {return Err（String :: from（＆＃34; memfd_create failed＆＃34;））; } let file = libc :: fdopen（fd，＆amp; write_mode）; //将二进制libc :: fwrite（data.as_ptr（）的内容写为* mut libc :: c_void，8作为usize，data.len（）作为usize，file，）; }</p><p> Invoking  /proc/self/fd/&lt;fd&gt; as a child process from the parent that created it is enough to run your binary.</p><p> 调用/ proc / self / fd /＆lt; fd＆gt;作为创建它的父级的子进程，足以运行您的二进制文件。</p><p>   Accepts an image that has had our binary embedded in it from the steganography tool, and any arguments</p><p>   接受从隐写术工具中嵌入了二进制文件的图像以及任何参数</p><p>     It’s annoying having to type  pngrun every time though, so my last cheap trick to this pointless gimmick was to use  binfmt_misc, a system that allows you to “execute” files based on its file types. I think it was mainly designed for interpreters/virtual machines, like Java. So instead of typing  java -jar my-jar.jar you can just type  ./my-jar.jar and it will invoke the  java process to run your JAR. The caveat is your file  my-jar.jar needs to be marked as executable first.</p><p>     不过，每次都必须输入pngrun令人讨厌，因此，我对此毫无意义的last头的最后一个便宜招是使用binfmt_misc，该系统可让您根据文件类型“执行”文件。我认为它主要是为Java等解释器/虚拟机设计的。因此，您不必键入java -jar my-jar.jar，而只需键入./my-jar.jar，它将调用Java进程来运行您的JAR。需要注意的是，您的文件my-jar.jar首先需要标记为可执行文件。 </p><p> So adding an entry to binfmt_misc for  pngrun to attempt to run any  png files that have the  x flag set was as simple as</p><p>因此，向binfmt_misc添加一个条目以供pngrun尝试运行设置了x标志的所有png文件非常简单</p><p>   Well, there isn’t one really. I was seduced by the idea of making PNG images run programs and got a bit carried away with it, but it was fun none the less. There’s something amusing to me about distributing programs as an image, remember the ridiculous cardboard boxes PC software used to come in with artwork on the front, why not bring that back! (lets not)</p><p>   好吧，真的没有人。制作PNG图像运行程序的想法让我着迷，但让它有些失落，但这仍然很有趣。以图像的形式分发程序对我来说很有趣，请记住前面带有艺术品的荒谬纸箱PC软件，为什么不把它带回来！ （不要吧）</p><p> It’s really dumb though and comes with a lot of caveats that make it completely pointless and impractical, the main one being needing the stupid  pngrun program on your machine. But I also noticed some weird stuff around programs like  clang. I encoded it into this fun LLVM logo and while it runs OK, it fails when you try to compile something.</p><p> 不过，它确实很傻，并且有很多警告，使其完全没有意义和不切实际，主要是需要计算机上安装愚蠢的pngrun程序。但是我也注意到clang之类的程序有些奇怪的东西。我将其编码为这个有趣的LLVM徽标，当它运行正常时，当您尝试编译某些内容时会失败。</p><p>  $ ./clang.png --versionclang version  11.0.0  (Fedora  11.0.0-2.fc33 )Target: x86_64-unknown-linux-gnuThread model: posixInstalledDir: /proc/self/fd$ ./clang.png main.cerror: unable to execute command: Executable  &#34;&#34; doesn &#39;t exist!</p><p>  $ ./clang.png --versionclang版本11.0.0（Fedora 11.0.0-2.fc33）目标：x86_64-unknown-linux-gnuThread模型：posixInstalledDir：/ proc / self / fd $ ./clang.png main。错误：无法执行命令：可执行＆＃34;＆＃34;不存在！</p><p> This is probably a product of the anonymous file thing, which can probably be overcome if I could be bothered to investigate.</p><p> 这可能是匿名文件的产物，如果我不愿意调查的话，可以克服它。</p><p>  A lot of binaries are quite large, and given the constraints of needing to fit them into an image, sometimes these need to be  big, meaning you end up with comically large files.</p><p>  很多二进制文件都非常大，并且由于需要将它们放入图像中而受到限制，有时这些二进制文件必须很大，这意味着您最终得到了可笑的大文件。</p><p> Also most software isn’t just one executable so the dream of just distributing a PNG kinda falls flat for more complex software like games.</p><p> 同样，大多数软件不仅是一个可执行文件，因此对于像游戏这样的更复杂的软件，仅分发PNG的梦想就落空了。 </p><p>  This is probably the dumbest project I’ve worked on all year but it’s been fun, I’ve learned about Steganography,  memfd_create,  binfmt_misc and played a little more with Rust.</p><p>这可能是我一年四季从事的最愚蠢的项目，但它很有趣，我了解了Steganography，memfd_create，binfmt_misc，并与Rust一起玩了更多游戏。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://djharper.dev/post/2020/12/26/executable-pngs/">https://djharper.dev/post/2020/12/26/executable-pngs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/执行/">#执行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>