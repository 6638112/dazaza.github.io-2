<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>括号只是打字机 Parentheses Are Just Typechecking</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parentheses Are Just Typechecking<br/>括号只是打字机 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-25 06:00:12</div><div class="page_narrow text-break page_content"><p>How would we translate this to a stack language, like Forth? Stack languages area mirror image of Lisps, written in postfix rather than prefix notation. Soa Forth-like version of this expression would be the same words in reverse,without the parentheses:</p><p>我们如何将此转换为堆栈语言？堆栈语言区域镜像Lisps的镜像，用Postfix写作而不是前缀表示法。 SOA sturk的此表达式的版本在没有括号的情况下反转相同的单词：</p><p>  But why does this necessarily have to be written postfix? A Forth that evaluatesright-to-left would look almost identical to a prefix notation language, justwith no delimiters.</p><p>  但为什么这必然必须写入Postfix？评估右到左的第四次看起来几乎与前缀符号语言相同，没有分隔符。</p><p>  It&#39;s not exactly more readable than the original. But if you reverse the wordsand evaluate it as if it&#39;s Forth, the expression is the same, with or withoutthe parens.</p><p>  它不是比原来更可读的。但是，如果你扭转这个词，评价它就好像它一样，表达式是相同的，有或没有宫殿。</p><p> Here&#39;s one way to look at this: for simple expressions, parentheses are a formof static typechecking. If you model a Lisp as a stack language that evaluatesfrom right to left, each parenthesized block must push exactly one value ontothe stack, and must not consume any values. In Forth terms, each  ( ... )enforces that its contents are of the type  -- a.</p><p> 这里的一种方式来看：对于简单的表达式，括号是静态typechecking的形式。如果将LISP模拟为左侧评估的堆栈语言，则每个括号块必须恰好推动一个值ONTOTHE堆栈，并且不得使用任何值。在第四条术语中，每个（...）强制其内容是类型 -  a。</p><p> This equivalence makes some assumptions. For one, it&#39;s assuminga  Lisp-2 (even though Scheme isa Lisp-1), since a closure returned from a stack-language function would just bepushed onto the stack, so  ((compose a b) c) wouldn&#39;t work.</p><p> 这次等价作出了一些假设。对于一个，它＆＃39; s假设lisp-2（即使是方案是lisp-1），因为从堆栈语言函数返回的关闭时，只会靠在堆栈上，所以（（组成ab）c）worln＆＃39 ;工作。</p><p> I&#39;m also only talking about simple expressions here, ignoring the other moresignificant differences between Lisps and Forths, like lists and variadicfunctions (which would still need parentheses), as well as variable definitionsversus stack munging operators like  dup or  swap.</p><p> 我也只在这里谈论简单的表达式，忽略了Lisps和Forth之间的其他奇异性差异，如列表和variadicfunctions（它仍然需要括号），以及可变定义versus stack munging运算符，如dup或swap。</p><p> Even with these caveats, the equivalence is still fascinating. And it makes meaware of some gaps in the design space of stack languages and Lisps:</p><p> 即使是这些警告，等价仍在迷人。它使Meaware在堆栈语言和Lisps的设计空间中的一些空白： </p><p>  ...a stack language that evaluates right-to-left? Non-stack-basedlanguages evaluate right-to-left within individual expressions, so this couldbe surprisingly intuitive. Yes, we often  expect function arguments toevaluate left-to-right, but some mainstream languages (notably C) leaveargument evaluation order undefined.</p><p>...一种左右评估的堆栈语言？基于非堆栈的语言在单个表达式内评估左右，因此这可能令人惊讶直观。是的，我们经常期望函数参数向右左右，但一些主流语言（特别是c）leaveargument评估命令未定义。</p><p> ...a stack language that allows parentheses as a sanity check?  -- aexpressions are common, and allowing the programmer to wrap them inparentheses to enforce this type could make stack code much more readable. (Ihaven&#39;t actually used many stack languages, so this probably exists, I justhaven&#39;t seen it.)</p><p> ...允许括号作为理智检查的堆栈语言？ -  AExpressions是常见的，并且允许程序员将它们包装中的inparenthes来强制执行此类型可以使堆栈代码更可读。 （Ihaven＆＃39; t实际上使用了许多堆栈语言，所以这可能存在，我justhaven＆＃39; t看它。）</p><p> ...a Lisp that can drop nested parentheses when the meaning is clear fromcontext? This one takes some explanation.</p><p> ......当意义从Context清晰时，可以将嵌套括号丢弃的Lisp？这一点采取一些解释。</p><p> Consider a Lisp-2 where functions are written in  UpperCamelCase todistinguish them from values in  lower-kebab-case. Then an expression like (Foo bar (Baz qux)) could be rewritten as  (Foo bar Baz qux).</p><p> 考虑一个LISP-2，其中函数以uppercamelcase of oblow-kebab-case中的值写入。然后可以将表达式（Foo Bar（BAZ Qux））重写为（Foo Bar Baz Qux）。</p><p> The simplest version of this assumes each argument goes to the first functionto its left. That&#39;s already useful for saving parentheses, but it&#39;s not thereverse-Forth syntax I&#39;ve been talking about.</p><p> 最简单的版本，假设每个参数都转到左侧的第一个函数。那已经有用的，但它已经有用，但它并不依赖＆＃39;在谈论的情况下。</p><p> If we don&#39;t make this simplifying assumption, then expressions like  (A B C)are ambiguous. This would be  (A (B) (C)) if  B and  C take 0 argumentsand  A takes 2, but  (A (B (C))) if  A and  B both take 1 argument.Fixing this ambiguity requires a static type system. We could use a stackinstead, but then it&#39;s not really a Lisp anymore.</p><p> 如果我们不进行这种简化的假设，那么就像（a b c）一样模糊。这将是（a（b）（c））如果b和c取0 argumesand a需要2，但是（a（b 。我们可以使用StackInstead，但随后它并不是一个真正的Lisp了。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://adam.nels.onl/blog/parentheses-are-just-typechecking/">https://adam.nels.onl/blog/parentheses-are-just-typechecking/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/括号/">#括号</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>