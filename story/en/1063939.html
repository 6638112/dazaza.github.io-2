<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TCL中的序列符号 Sequence Notation in Tcl</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Sequence Notation in Tcl<br/>TCL中的序列符号 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-07 05:57:43</div><div class="page_narrow text-break page_content"><p>This is a small utility proc that can expand patterns of ranges or sets, it can be used to cross-product ranges or sets together using a compact notiation, e.g.</p><p>这是一个小实用程序，可以扩展范围或套件的图案，它可以用来使用紧凑的诠释来横跨产品范围或一起组合在一起，例如，</p><p>   0 foo-a 0 foo-b 1 foo-a 1 foo-b 2 foo-a 2 foo-b 3 foo-a 3 foo-b</p><p>   0 foo-a 0 foo-b 1 foo-a 1 foo-b 2 foo-a 2 foo-b 3 foo-a 3 foo-b</p><p> I think I have seen other utilities like this on this wiki, but I wasn&#39;t able to find them after a search. Maybe I couldn&#39;t pin down the right notation?  Pointers or comments are very welcome! I&#39;m sure this problem has been solved often. And the title can probably use some work too.</p><p> 我想我在这个wiki上看到了这样的其他实用程序，但我在搜索后找到它们。也许我可以＆＃39; t in右边的表示法？指针或评论非常欢迎！我确信经常解决了这个问题。标题可能也可以使用一些工作。</p><p>  I had a test program where I needed to run a large number of tests. Each of the test parameters in a series can be produced by expanding ranges or sets of values. E.g.</p><p>  我有一个测试程序，我需要运行大量的测试。串联中的每个测试参数都可以通过扩展范围或值集来产生。例如。</p><p> test -size 1 test -size 2 test -size 3 test -size 10 test -size 20 test -size 30 test -size 100 ... and so forth ...</p><p> 测试-size 1测试-size 2测试-size 3测试-size 10测试-size 20测试-size 30测试-size 100 ......</p><p> The pattern would need to proceed to 3000000. Let&#39;s define and solve a simpler problem first. What if I want to specify a simple contiguous range of integers? E.g, 1 2 3 4 5. For this type of simple range, we will use notation [1-5]. OK so far.</p><p> 模式需要进行3000000.让＆＃39; s定义并首先解决更简单的问题。如果我想指定一个简单的整数范围，该怎么办？例如，1 2 3 4 5.对于这种类型的简单范围，我们将使用符号[1-5]。到目前为止。</p><p> Next logical step: what if we wanted to increment by a number other than 1? E.g. odd numbers from 1 up to (and including) 7. Notation: [1-7~2].</p><p> 下一个逻辑步骤：如果我们想递增1以外的数字，怎么办？例如。奇数从1到（包括）7.表示法：[1-7〜2]。 </p><p>   But note in my test invocations above, I can&#39;t just use a simple range increment. I need to expand logarithmically. We can solve this by allowing multiple ranges in one pattern, plus TCL expr&#39;s idea of &#39;e&#39;. For simplicity, if there are multiple patterns, they will be expanded from left to right. If you like another order, I&#39;d suggest maybe change the code to take the LAST match on each pattern, or just lsort -dictionary the resulting list of expansions.</p><p>但是在上面的测试调用中，我可以＆＃39; t只使用简单的范围增量。我需要对数展开。我们可以通过在一个图案中允许多个范围，加上TCL expr＆＃39;＆＃39; e＆＃39;为简单起见，如果有多种模式，它们将从左右扩展。如果您喜欢其他订单，我＆＃39; d建议可能会更改每个模式上的最后一个匹配的代码，或者只是lsort -dictionary结果的扩展列表。</p><p>  1e1 = 10.0 2e1 = 20.0 3e1 = 30.0 1e2 = 100.0 2e2 = 200.0 3e2 = 300.0 ... 3e7 = 3000000</p><p>  1e1 = 10.0 2e1 = 20.0 3e1 = 30.0 1e2 = 100.0 2e2 = 200.0 3e2 = 300.0 ... 3e7 = 3000000</p><p> So far so good again. Now, a new requirement. Some parameters are  sets of letters or words, but otherwise should operate similarly to integer ranges as above. E.g. version numbers 1 to 3, with a suffix of a or b. New syntax: {a,b}. Pattern:  [1-3]{a,b} expands to:</p><p> 到目前为止再次好。现在，一个新的要求。一些参数是字母或单词的集，但否则应类似地操作到上面的整数范围。例如。版本号1到3，带有a或b的后缀。新语法：{A，B}。模式：[1-3] {a，b}展开：</p><p>  The order that this pattern produces, due to our policy of left-to-right expansion, may not be desired, eg., 2a follows 1a, where for some purposes it should be 1b that follows 1a. Let&#39;s save that problem for another day.</p><p>  由于我们的左右扩展的政策，这种模式产生的顺序可能不需要，例如，例如，2a遵循1a，其中一些目的应该是遵循1a的1b。让＆＃39; s保存另一天的问题。</p><p> Next, what if I want to have a few different sub-patterns inside one pattern, e.g. for software version 3, there should be suffixes a, b, and c, but for versions 1 and 2, there is only a. Pattern:  [1-2]a+3{a,b,c}</p><p> 接下来，如果我想在一个图案内有几个不同的子模式，例如，该怎么办，例如，对于软件版本3，应该有后缀A，B和C，但对于版本1和2，只有一个。模式：[1-2] A + 3 {A，B，C}</p><p>  OK, so now my problem is pretty much solved. For any test parameter where I used to just accept an integer, I now allow an expansion. So I can target a large parameter space with a short specification, e.g.</p><p>  好的，所以现在我的问题非常解决。对于我曾经接受整数的任何测试参数，我现在允许扩展。因此，我可以使用简短的规格来定位一个大的参数空间，例如，</p><p>  test -version 1a -size 1e1 test -version 2a -size 1e1 test -version 3a -size 1e1 ...</p><p>  测试 - 转化1A -SIZE 1E1测试 - 转化2A -SIZE 1E1测试 - 转化3A -SIZE1E1 ... </p><p>  ## seq_expand: Expand sequences, from ranges or sets.# Takes an pattern and returns a list of expansions.# version 1.2## range expansion# e.g.# [1-5] = 1 2 3 4 5# [1-9~2] = 1 3 5 7 9# [1-3]e[1-4] = 1 2 3 10 20 30 100 200 300## set expansion# e.g.# {1,2,3}05{3,2} = 1053 1052 2053 2052## alternate expansion# e.g.# {a,b}+[1-3] = a b 1 2 3## Caveats:# ranges don&#39;t support decimals#proc expand_seq {seqexpr} { set pat_l [list $seqexpr] set exp_l [] while {[llength $pat_l] &gt; 0} { set pat [lindex $pat_l 0] set pat_l [lrange $pat_l 1 end] # any expansion elements we produce for current pattern set cross_l [] # if any __word__ (contiguous non-WS) has a + in it, split it and prepend # each sub-pattern. # # good pattern: if {[regexp -indices {.*(?:\t| |^)([^ \t]*[^\\ ](\+)[^ ]+).*} $pat _ alt_group plus]} { # puts &#34;Found alt-group at $alt_group&#34; lassign $alt_group sub_b sub_e set alt_group [string range $pat $sub_b $sub_e] # puts &#34;Alt group is: &#39;$alt_group&#39;&#34; set prev 0 # split on any + that does not have a backslash before it. for {set i 0} {$i &lt; [string length $alt_group]} {incr i} { if {[string index $alt_group $i] == &#34;+&#34; &amp;&amp; [string index $alt_group $i-1] != &#34;\\&#34;} { # puts &#34;Found + at $i&#34; lappend cross_l [string range $alt_group $prev $i-1] set prev [expr $i + 1] } } # add everything past the last + to the end of $alt_group. if {$prev != 0} { lappend cross_l [string range $alt_group $prev end] } } if {$cross_l == [] &amp;&amp; [regexp {.*(\[([0-9]+)(-)([0-9]+)(~[0-9]+)?\]).*} $pat _ brackets d_b dash d_e d_s]} { set any_expansion 1 set sub_b [string first $brackets $pat] if {$sub_b == -1} { error &#34;Can&#39;t re-find bracket expr in pattern?&#34; } set sub_e [expr $sub_b + [string length $brackets] - 1] set d_s [string trimleft $d_s ~] if {$d_s == &#34;&#34;} { set d_s 1 } foreach int [list $d_b $d_e $d_s] { if {![string is integer $int]} { error &#34;In sequence expansion, can&#39;t parse &#39;$int&#39; as an integer&#34; } } if {$d_s == 0} { error &#34;In sequence expansion, step size can&#39;t be 0&#34; } for {set x $d_b} {$x &lt;= $d_e} {incr x $d_s} { lappend cross_l $x } } if {$cross_l == [] &amp;&amp; [regexp -indices {.*(?:[^\\]|^)({[^\}]+}).*} $pat _ brackets]} { lassign $brackets sub_b sub_e set inside [string range $pat $sub_b+1 $sub_e-1] foreach elem [split $inside ,] { lappend cross_l $elem } } if {$cross_l == []} { # puts &#34;no more expansion for &#39;$pat&#39; add to results&#34; lappend exp_l $pat } else { # this one is finished. foreach elem $cross_l { set npat [string replace $pat $sub_b $sub_e $elem] # puts &#34;pat $pat | $elem =&gt; $npat&#34; lappend pat_l $npat } } } # fix any escaped + [ ] { } that might be found # lmap is better, but for those on 8.5, a quick + dirty hack. set esc_map [list &#34;\\+&#34; &#34;+&#34; &#34;\\\{&#34; &#34;\{&#34; &#34;\\\}&#34; &#34;\}&#34; &#34;\\\[&#34; &#34;\[&#34; &#34;\\\]&#34; &#34;\]&#34;] set exp_l [string map $esc_map $exp_l] # puts &#34;result patterns: \n[join $exp_l &#34;\n&#34;]&#34; return $exp_l}</p><p>## seq_expand：展开序列，从范围或集合。＃拍摄模式并返回扩展列表。＃1.2 ##范围扩展＃eg＃[1-5] = 1 2 3 4 5＃[1-9〜 2] = 1 3 5 7 9＃[1-3] e [1-4] = 1 2 3 10 20 30 100 200 300 ##设置扩展＃EG＃{1,2,3} 05 {3,2} = 1053 1052 2053 2052 ##替代扩展＃eg＃{a，b} + [1-3] = ab 1 2 3 ## taveats：＃范围Don＆＃39; t支持小数＃proc expand_seq {seqexpr} {set pat_l [列出$ seqexpr] set exp_l [] {[llength $ pat_l]＆gt; 0} {set pat [lindex $ pat_l 0] set pat_l [lrange $ pat_l 1结束]＃任何扩展元素我们为当前模式设置为cross_l []＃如果有任何__word__（连续的非Ws）有一个+，则拆分它并加工＃每个子模式。 ##好的模式：如果{[regexp -indices {。*（？：\ t | | ^）（[^ \ t] * [^ \\]（\ +）[^] +）。*} $ PAT _ alt_group plus]} {＃puts＆＃34;在$ alt_group＆＃34找到alt-group; Lassign $ alt_group sub_b sub_e set alt_group [stringrangroup $ pat $ sub_b $ sub_e] #pls＆＃34; alt组是：＆＃39; $ alt_group＆＃39;＆＃34;设置prev 0＃在任何+上拆分，在它之前没有反斜杠。对于{SET I 0} {$ i <$ i＆lt; [字符串长度$ alt_group]} {incr i} {if {[字符串index $ alt_group $ i] ==＆＃34; +＆＃34; ＆amp;＆amp; [字符串索引$ alt_group $ i-1]！=＆＃34; \\＆＃34;} {#pls＆＃34;发现+在$ i＆＃34; Lappend Cross_L [String Range $ Alt_Group $ Prev $ I-1]设置prev [expr $ i + 1]}}＃将所有内容递过最后+到$ alt_group的末尾。如果{$ prev！= 0} {lappend cross_l [stringrange $ alt_group $ prev end]}}如果{$ cross_l == []＆amp;＆amp; [regexp {。*（\ [（[0-9] +）（ - ）（ - ）（〜[0-9] +）？\]）。*} $ PAT _括号D_B DASH D_E d_s]}} {set any_emansion 1 set sub_b [string first $括号$ pat]如果{$ sub_b == -1} {error＆＃34; can＆＃39; t重新找到模式的括号expr＆＃34; SEAS SUB_E [expr $ sub_b + [字符串长度$括号]  -  1]设置d_s [string trimleft $ d_s〜]如果{$ d_s ==＆＃34;＆＃34;} {set d_s 1} foreach int [list $ d_b $ d_e $ d_s] {if {！[string是整数$ int]} {错误＆＃34;在序列扩展中，可以＆＃39; t解析＆＃39; $ int＆＃39;作为整数＆＃34;如果{$ d_s == 0} {错误＆＃34;在序列扩展中，步长可以＆＃39; t be 0＆＃34; for {set x $ d_b} {$ x＆lt; $ d_e} {incr x $ d_s} {lappend cross_l $ x}}如果{$ cross_l == []＆amp;＆amp; [regexp-indices {。*（？：[^ \\] | ^）（{[^ \}] ^）。*} $ PAT _括号]} {Lassign $括号子_B SEAR中的SUB_E SEAR [String Range $ PAT $ sub_b + 1 $ sub_e-1] foreach elem [split $ sine，] {lappend cross_l $ elem}}如果{$ cross_l == []} {＃puts＆＃34;没有更多的扩展＆＃39; $ pat＆ ＃39;添加到结果＆＃34; lappend exp_l $ pat} else {＃这个完成了。 Foreach Elem $ cross_l {set npat [string replace $ pat $ sub_b $ sub_e $ elem] #pls＆＃34; pat $ pat | $ elem =＆gt; $ npat＆＃34; lappend pat_l $ npat}}}}}＃修复可能找到的任何转义+ [] {}＃lmap更好，但对于8.5的那些，一个快速+肮脏的黑客。设置ESC_MAP [列表＆＃34; \\ +＆＃34; ＆＃34; +＆＃34; ＆＃34; \\\ {＆＃34; ＆＃34; \ {＆＃34; ＆＃34; \\\}＆＃34; ＆＃34; \}＆＃34; ＆＃34; \\\ [＆＃34; ＆＃34; \ [＆＃34; ＆＃34; \\\]＆＃34; ＆＃34; \]＆＃34;] set exp_l [string map $ esc_map $ exp_l] #puts＆＃34;结果模式：\ n [加入$ exp_l＆＃34; \ n＆＃34;]＆＃34;返回$ exp_l}</p><p>  If you use this from a unix shell, note that shells often do glob expansion using [ ] and { }. So, if these patterns are to be given as command line input, users would need to quote the patterns to avoid the shell expanding them, e.g.</p><p>  如果从UNIX shell使用此功能，请注意Shell通常使用[]和{}进行Glob扩展。因此，如果要给出这些模式作为命令行输入，则用户需要引用模式以避免弹跳扩展它们，例如，</p><p>  Also, if you were to write the patterns as literals in TCL, you&#39;d want to enclose them with { and }, so that [ and ] are not expanded by TCL. Maybe a different syntax would be better.</p><p>  此外，如果您要将图案写为TCL中的文字，请＆＃39; d希望将它们用{和}封闭，因此TCL不会扩展[和]。也许不同的语法会更好。</p><p> You can certainly do a lot better if you attempted full parsing of the patterns. My code has problems with nested patterns. But nested patterns could be used (for example) so that &#39;+&#39; is not needed, eg.</p><p> 如果您尝试完全解析模式，您当然可以更好地完成。我的代码有嵌套模式的问题。但是可以使用嵌套模式（例如）这样＆＃39; +＆＃39;不需要，例如。</p><p>  However, I didn&#39;t take the time to count for balanced curly braces. If anyone would like to implement it in a reasonably parsimonious way, feel free!</p><p>  但是，我没有花时间来计算平衡的卷曲括号。如果有人希望以合理的方式实施它，请随时免费实现！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wiki.tcl-lang.org/page/Sequence+Notation">https://wiki.tcl-lang.org/page/Sequence+Notation</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/序列/">#序列</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notation/">#notation</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模式/">#模式</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>