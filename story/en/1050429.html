<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ClickHouse替代Elasticsearch进行日志存储和分析 ClickHouse as an alternative to Elasticsearch for log storage and analysis</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ClickHouse as an alternative to Elasticsearch for log storage and analysis<br/>ClickHouse替代Elasticsearch进行日志存储和分析 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-03 00:07:56</div><div class="page_narrow text-break page_content"><p>In 2018, I&#39;ve written an  article about Clickhouse, this piece of content is still pretty popular across the internet, and even was translated a few times. More than two years have passed since, and the pace of Clickhouse development  is not slowing down: 800 merged PRs just during last month! This didn&#39;t blow your mind? Check out the full changelog, for example for 2020:  https://clickhouse.tech/docs/en/whats-new/changelog/2020/ The description of just new features for each year may take an hour to go through.</p><p>在2018年，我写了一篇有关Clickhouse的文章，该内容在互联网上仍然很流行，甚至被翻译了几次。此后已经过去了两年多，而Clickhouse的开发速度并未放缓：仅在上个月就合并了800个PR！这没让你大吃一惊吗？查看完整的变更日志，例如2020年：https://clickhouse.tech/docs/en/whats-new/changelog/2020/每年仅对新功能的描述可能需要一个小时才能完成。</p><p> For the sake of honest comparison,  ElasticSearch repo has jaw-dropping 1076 PRs merged for the same month, and in terms of features, their pace is  very impressive, as well!</p><p> 为了进行诚实的比较，ElasticSearch回购在当月合并了1076个令人jaw目结舌的PR，就功能而言，它们的速度也非常令人印象深刻！</p><p> We are using Clickhouse for log storage and analytics in  ApiRoad.net project (which is  an API marketplace where developers sell their APIs, still in active development) and we are happy with the results so far. As an API developer myself, I know how important is the observability and analysis of HTTP request/response cycle to maintain the quality of service and quickly detect bugs, this is especially true for pure API service.</p><p> 我们正在将Clickhouse用于ApiRoad.net项目（这是一个API市场，开发人员出售其API，仍处于积极开发中）的日志存储和分析，到目前为止，我们对结果感到满意。作为一名API开发人员，我知道HTTP请求/响应周期的可观察性和分析对于维持服务质量并快速检测错误非常重要，对于纯API服务而言尤其如此。</p><p>  We are also using ELK (ElasticSearch, Logstash, filebeat, Kibana)  stack on other projects, for very similar purposes - getting http and mail logs, for later analysis and search via Kibana.</p><p>  我们还在其他项目上使用ELK（ElasticSearch，Logstash，filebeat，Kibana）堆栈，用于非常相似的目的-获取HTTP和邮件日志，以供以后通过Kibana分析和搜索。</p><p>  This post is about the major reasons why we chose Clickhouse and not ElasticSearch (or MySQL) as a storage solution for ApiRoad.net essential data - request logs (Important note: we still use MySQL there, for OLTP purposes).</p><p>  这篇文章是关于为什么我们选择Clickhouse而不是ElasticSearch（或MySQL）作为ApiRoad.net基本数据（请求日志）存储解决方案的主要原因（重要说明：出于OLTP的目的，我们仍在此处使用MySQL）。</p><p>  SQL is a perfect language for analytics. I love SQL query language and SQL schema is a perfect example of boring tech that I recommend to use as a source of truth for all the data in 99% of projects: if the project code is not perfect, you can improve it relatively easily if your database state is strongly structured. If your database state is a huge JSON blob (NoSQL) and no-one can fully grasp the structure of this data, this refactoring usually gets much more problematic.</p><p>  SQL是用于分析的理想语言。我喜欢SQL查询语言，SQL模式是无聊技术的完美示例，我建议将其用作99％项目中所有数据的真实来源：如果项目代码不完美，则可以相对轻松地对其进行改进您的数据库状态结构牢固。如果您的数据库状态是一个巨大的JSON Blob（NoSQL），并且没有人可以完全掌握此数据的结构，则这种重构通常会带来更多问题。</p><p> I saw this happening, especially in older projects with MongoDB, where every new analytics report and every new refactoring involving data migration is a big pain. Starting such projects is fun – as you don&#39;t need to spend your time carefully designing the complete project schema, just &#34;see how it goes&#34; – but maintaining them is not fun!</p><p> 我看到了这种情况，尤其是在MongoDB的旧项目中，每一个新的分析报告和每一个涉及数据迁移的新重构都是一个很大的难题。开始这样的项目很有趣–您无需花时间仔细设计完整的项目架构，只需了解其进展情况即可。 –但是维护它们并不有趣！ </p><p> But, it is important to note that this rule of thumb - &#34;use strict schema&#34; - is not that critical for log storage use cases. That&#39;s why ElasticSearch is so successful, it has many strong sides, and flexible schema.</p><p>但是，请务必注意，这条经验法则-“使用严格模式”。 -对于日志存储用例而言并不那么关键。这就是ElasticSearch如此成功的原因，它具有许多优势，而且架构灵活。</p><p> Back to JSON: traditional RDBMS are still catching up with NoSQL DBMS in terms of JSON querying and syntax, and we should admit JSON is a very convenient format for dynamic structures (like log storage).</p><p> 返回JSON：就JSON查询和语法而言，传统的RDBMS仍在赶上NoSQL DBMS，我们应该承认JSON是动态结构（如日志存储）非常方便的格式。</p><p> Clickhouse is a modern engine that was designed and built when JSON was already a thing (unlike MySQL and Postgres), and Clickhouse does not have to carry the luggage of backward compatibility and strict SQL standards of these super-popular RDBMS, so Clickhouse team can move fast in terms of features and improvements, and they indeed move fast. Developers of Clickhouse had more opportunities to hit a sweet balance between strict relative schemas and JSON flexibility, and I think they did a good job here. Clickhouse tries to compete with Google Big Query and other big players in the analytics field, so it got many improvements over &#34;standard&#34; SQL, which makes its syntax a killer combo and in a lot of cases much better than you get in traditional RDBMS, for analytics and various calculation purposes.</p><p> Clickhouse是一种现代引擎，是在JSON已经成为事物（不同于MySQL和Postgres）时设计和构建的，并且Clickhouse不必携带这些超级受欢迎的RDBMS的向后兼容性和严格的SQL标准，因此Clickhouse团队可以在功能和改进方面进展迅速，而且的确在快速发展。 Clickhouse的开发人员有更多机会在严格的相对架构和JSON灵活性之间达到最佳平衡，我认为他们在这里做得很好。 Clickhouse试图在分析领域与Google Big Query和其他大公司竞争，因此它在＆＃34; standard＆＃34;上获得了许多改进。 SQL，它的语法成为了杀手comb，在很多情况下都比传统的RDBMS更好，用于分析和各种计算目的。</p><p>  In MySQL, you can extract json fields, but complex JSON processing, like joining relational data on JSON data, became available only recently,  from version 8 with JSON_TABLE function. In PosgreSQL, the situation is even worse -  no direct JSON_TABLE alternative until PostgreSQL 12!</p><p>  在MySQL中，您可以提取JSON字段，但是复杂的JSON处理（例如将关系数据连接到JSON数据）仅在最近的版本（具有JSON_TABLE函数的版本8）中可用。在PosgreSQL中，情况甚至更糟-在PostgreSQL 12之前没有直接的JSON_TABLE替代方案！</p><p> Compare it to Clickhouse JSON and related arrays feature set - it is just miles ahead. Links:</p><p> 将它与Clickhouse JSON和相关的数组功能集进行比较-它仅领先几英里。链接：</p><p>  These are useful in a lot of cases where you would use  generate_series() in PostgreSQL. A concrete example from ApiRoad: we need to map requests amount on chart.js timeline. If you do regular  SELECT .. group by day, you will get gaps if some days did not have any queries. And we don&#39;t need gaps, we need zeros there, right? This is exactly where  generate_series() function is useful in PostgreSQL. In MySQL,  the recommendation is to create stub table with calendar and join on it... not too elegant, huh?</p><p>  在很多情况下，在PostgreSQL中使用generate_series（）时，这些功能很有用。来自ApiRoad的一个具体示例：我们需要在chart.js时间轴上映射请求数量。如果您每天进行常规的SELECT .. group，如果某些天没有任何查询，则会出现空白。而且我们不需要缺口，那里需要零，对吗？这正是在PostgreSQL中generate_series（）函数有用的地方。在MySQL中，建议使用日历创建存根表并在其中进行连接...不是太优雅了吧？</p><p>  Regarding the query language: I am still not comfortable with verbosity and approach of ElasticSearch Lucene syntax, HTTP API, and all these  json structures that you need to write to retrieve some data. SQL is my preferred choice.</p><p>  关于查询语言：我对ElasticSearch Lucene语法，HTTP API以及为检索某些数据而需要编写的所有这些json结构的详细程度和方法仍然不满意。 SQL是我的首选。 </p><p>  SELECT a.timePeriod as t, b.count as c from (	with (select toUInt32(dateDiff(&#39;day&#39;, [START_DATE], [END_DATE])) ) 		as diffInTimeUnits 	select arrayJoin(arrayMap(x -&gt; (toDate(addDays([START_DATE], x))), 			range(0, diffInTimeUnits+1))) as timePeriod ) a LEFT JOIN 	(select count(*) as count, toDate(toStartOfDay(started_at)) as timePeriod from logs WHERE 		[CONDITIONS]		GROUP BY toStartOfDay(started_at)) b on a.timePeriod=b.timePeriod</p><p>从（用（选择toUInt32（dateDiff（＆＃39; day＆＃39 ;, [START_DATE]，[END_DATE]）））选择diffInTimeUnits选择arrayJoin（arrayMap（x-＆gt; ;（toDate（addDays（[START_DATE]，x）），range（0，diffInTimeUnits + 1））））作为timePeriod）左联接（选择count（*）作为count，toDate（toStartOfDay（started_at））作为timePeriod从在a.timePeriod = b.timePeriod上记录WHERE [条件] GROUP BY到toStartOfDay（started_at））b</p><p> Here, we generate virtual table via lambda function and loop, and then left join it on  results from logs table grouped by day.</p><p> 在这里，我们通过lambda函数生成一个虚拟表并循环，然后将其按天分组的日志表中的结果保持连接状态。</p><p> I think  arrayJoin +  arrayMap +  range functions allow more flexibility than  generate_series() from Postgres or ElasticSearch approach. There is also   WITH FILL keyword available for a more concise syntax.</p><p> 我认为arrayJoin + arrayMap +范围函数比Postgres或ElasticSearch方法的generate_series（）具有更大的灵活性。还有一个WITH FILL关键字可用于更简洁的语法。</p><p>  For log storage tasks, the exact data schema often evolves during project lifetime, and ElasticSearch allows you to put huge JSON blob into index and later figure out the field types and indexing part. Clickhouse allows to use the same approach. You can put data to JSON field and filter it relatively quickly, though it won&#39;t be quick on terabyte scale. Then, when you see you often need fast query execution on specific data field, you add materialized columns to your logs table, and these columns extract values from existing JSON on-the-fly. This allows much faster queries on terabytes of data.</p><p>  对于日志存储任务，确切的数据模式通常会在项目生命周期内演变，ElasticSearch允许您将巨大的JSON blob放入索引中，然后找出字段类型和索引部分。 Clickhouse允许使用相同的方法。您可以将数据放入JSON字段并相对快速地进行过滤，尽管在TB级上并不会很快。然后，当您看到经常需要在特定数据字段上快速执行查询时，便将物化列添加到日志表中，这些列会即时从现有JSON中提取值。这样可以对TB级的数据进行更快的查询。</p><p> I recommend this video from Altinity on the topic of JSON vs Tabular schema for log data storage:</p><p> 我推荐来自Altinity的有关JSON与表格格式的主题的视频记录数据存储：</p><p>      There are no direct benchmarks, at least I could not find any, I believe because Clickhouse and ElasticSearch are very different in terms of query syntax, cache implementations, and their overall nature.</p><p>      我相信没有直接的基准测试，至少我找不到任何基准测试，因为Clickhouse和ElasticSearch在查询语法，缓存实现及其整体性质方面都非常不同。</p><p> If we talk about MySQL, any imperfect query, missing index, on a table with mere 100 million rows of log data can make your server crawl and swap, MySQL is not really suited for large-scale log queries. But, in terms of storage, compressed InnoDB tables are surprisingly not that bad. Of course, it&#39;s much worse in terms of compression comparing to Clickhouse (sorry, no URLs to benchmarks to support the claim this time), due to its row-based nature, but it still often manages to reduce cost significantly without a big performance hit. We use compressed InnoDB tables for some cases for small-scale log purposes.</p><p> 如果我们谈论MySQL，那么在只有1亿行日志数据的表上，任何不完善的查询，缺少索引都会使您的服务器爬行和交换，MySQL并不真正适合大型日志查询。但是，就存储而言，压缩的InnoDB表并没有那么糟糕。当然，由于其基于行的性质，与Clickhouse相比，压缩方面的情况要差得多（抱歉，这次没有支持基准的URL来支持该声明），但是在没有压缩的情况下，它仍然经常设法显着降低成本对性能的影响很大。在某些情况下，出于小型日志目的，我们使用压缩的InnoDB表。 </p><p>   SELECT count(*) as cnt, quantileTiming(0.5)(duration) as duration_median, quantileTiming(0.9)(duration) as duration_90th, quantileTiming(0.99)(duration) as duration_99th FROM logs WHERE status=404</p><p>从状态为404的日志中选择COUNT（*）为cnt，QuantileTiming（0.5）（duration）为duration_median，QuantileTiming（0.9）（duration）为duration_90th，QuantileTiming（0.99）（duration）为duration_99th</p><p> Notice usage of  quantileTiming function and how  currying is elegantly used here. Clickhouse has generic  quantile function! But  quantileTiming is  optimized for working with sequences which describe distributions like loading web pages times or backend response times.</p><p> 请注意QuantileTiming函数的用法以及此处如何优雅地使用currying。 Clickhouse具有通用分位数功能！但是QuantileTiming已针对与描述分布的序列进行了优化，这些序列描述了诸如加载网页时间或后端响应时间之类的分布。</p><p> There are more than that. Want weighted arithmetic mean? Want to calculate linear regression? this is easy, just use specialized function.</p><p> 还有更多。想要加权算术平均数吗？要计算线性回归吗？这很容易，只需使用专门的功能即可。</p><p>    ElasticSearch is much better in this than MySQL, it has both quantiles and weighted medians, but it still does not have linear regression.</p><p>    ElasticSearch在这方面比MySQL好得多，它既具有分位数又具有加权中位数，但是它仍然没有线性回归。</p><p>  MySQL and Clickhouse has integrations on multiple levels, which make it easy to use them together with minimum of data duplication:</p><p>  MySQL和Clickhouse具有多个级别的集成，这使它们易于使用，同时减少了数据重复：</p><p>  I can&#39;t say for sure how fast and stable dynamic database engines and table engines work on JOINs, this definitely requires benchmarks, but the concept is very appealing - you have full up-to-date clone of your MySQL tables on your Clickhouse database, and you don&#39;t have to deal with cache invalidation and reindexing.</p><p>  我不能肯定地说动态数据库引擎和表引擎在JOIN上有多快和稳定，这绝对需要基准测试，但是这个概念非常吸引人-您在自己的MySQL表中拥有完整的最新克隆版本Clickhouse数据库，您不必处理缓存失效和重新编制索引。</p><p> Regarding using MySQL with Elasticsearch, my limited experience says that these two techonologies are just too different and my impression is that they are speaking foreign languages, and do no play &#34;together&#34;, so what I usually did is just JSONify all my data that I needed to index in ElasticSearch, and send it to ElasticSearch.  Then, after some migration or any other UPDATE/REPLACE happen on MySQL data, I try to figure out the re-indexing part on Elasticseach side.  Here is an article of the Logstash powered approach to sync MySQL and ElasticSearch. I should say I don&#39;t really enjoy Logstash for it&#39;s mediocre performance, and RAM requirements, and since it is another moving part which can break. This syncing and re-indexing task is often a significant stop factor for us to use Elasticsearch in simple projects with MySQL.</p><p> 关于将MySQL与Elasticsearch结合使用，我有限的经验表明，这两种技术太不同了，我的印象是他们说的是外语，并且不会一起玩，所以我通常所做的只是JSONify我需要在ElasticSearch中建立索引的所有数据，并将其发送到ElasticSearch。然后，在对MySQL数据进行一些迁移或任何其他UPDATE / REPLACE之后，我尝试找出Elasticseach端的重新索引部分。这是Logstash支持的方法的文章，用于同步MySQL和ElasticSearch。我应该说我真的不喜欢Logstash，因为它的性能中等，并且对RAM的要求也很高，而且因为Logstash是另一个可能会损坏的动态部分。对于我们在带有MySQL的简单项目中使用Elasticsearch而言，此同步和重新索引编制任务通常是一个重要的停止因素。 </p><p>    Want to update or delete log rows to be compilant with GDPR? Now, this is easy!</p><p>是否要更新或删除日志行以符合GDPR？现在，这很容易！</p><p> There was no clean way to delete or update data in Clickhouse in 2018 when my first article was written, and it was a real downside. Now, it&#39;s not an issue anymore. Clickhouse leverages custom SQL syntax to delete rows:</p><p> 在撰写我的第一篇文章时，2018年Clickhouse中没有干净的方法来删除或更新数据，这是一个真正的弊端。现在，这不再是问题。 Clickhouse利用自定义SQL语法删除行：</p><p>  This is implemented like this to be explicit that deleting is still a pretty expensive operation for Clickhouse (and other columnar databases) and you should not do it every second on production.</p><p>  这样做的目的很明确，对于Clickhouse（和其他列式数据库）来说，删除仍然是一项相当昂贵的操作，因此您不应该在生产中每秒都这样做。</p><p>  There are cons for Clickhouse, comparing to ElasticSearch. First of all, if you build internal analytics for log storage, you do want to get the best GUI tool out there. And Kibana is good nowadays for this purpose when you compare it to Grafana (at least, this point of view is very popular on the Internet, Grafana UI is not that slick sometimes). And you have to stick to Grafana or Redash if you use Clickhouse.  (Metabase, which we adore, also got Clickhouse support!)</p><p>  与ElasticSearch相比，Clickhouse有缺点。首先，如果您构建用于日志存储的内部分析，那么您确实想获得最好的GUI工具。当您将其与Grafana进行比较时，Kibana现在对于此目的是很好的（至少，这种观点在Internet上非常流行，Grafana UI有时并不那么光滑）。如果您使用Clickhouse，则必须坚持使用Grafana或Redash。 （我们喜欢的元数据库也获得了Clickhouse的支持！）</p><p> But, in our case, in ApiRoad.net project, we are building customer-facing analytics, so we have to build analytics GUI from scratch, anyways (we are using a wonderful stack of Laravel, Inertia.js, Vue.js, and Charts.js to implement the customer portal, by the way).</p><p> 但是，在我们的案例中，在ApiRoad.net项目中，我们正在构建面向客户的分析，因此无论如何我们都必须从头开始构建分析GUI（我们使用了很棒的Laravel，Inertia.js，Vue.js和用Charts.js来实现客户门户）。</p><p> What I don&#39;t like in Clickhouse is also weird naming of some functions, which are there because Clickhouse was created for Yandex.Metrika (Google Analytics competitor), e.g. visitParamHas() is a function to check if a key exists in JSON. Generic purpose, bad non-generic name. I should mention that there is a bunch of fresh JSON functions with good names: e.g. JSONHas(), with one interesting detail: they are using  different JSON parsing engine, more standards-compliant but a bit slower, as far as I understand.</p><p> 我在Clickhouse中不喜欢的还有一些功能的奇怪名称，这些功能之所以出现是因为Clickhouse是为Yandex.Metrika（Google Analytics（分析）竞争对手）创建的。 visitParamHas（）是用于检查JSON中是否存在密钥的函数。通用，错误的非通用名称。我应该提到的是，有一堆名字不错的新JSON函数：例如JSONHas（），其中有一个有趣的细节：据我所知，它们使用不同的JSON解析引擎，更符合标准，但速度稍慢。</p><p>    ElasticSearch is a very powerful solution, but I think its strongest side is still huge setups with 10+ nodes, used for large-scale full-text search and facets, complex indexing, and score calculation – this is where ElasticSearch shines. When we talk about time-series and log storage, my feeling is there are better solutions, and Clickhouse is one of them. ElasticSearch API is enormous, and in a lot of cases it&#39;s hard to remember how to do one exact thing without copypasting the exact HTTP request from the documentation, it just feels &#34;enterprisy&#34; and &#34;Java-flavored&#34;. Both Clickhouse and ElasticSearch are memory hungry apps, but RAM requirements for minimal Clickhouse production installation is 4GB, and for ElasticSearch it is around 16GB. I also think Elastic team focus is getting pretty wide and blurred with  all the new amazing machine-learning features they deploy, my humble opinion is that, while these features sound very modern and trendy, this enormous feature set is just impossible to support and improve, no matter how many devs and money you have, so ElasticSearch more and more gets into &#34;Jack of all trades, master of none&#34; category for me. Maybe I am wrong.</p><p>    ElasticSearch是一个非常强大的解决方案，但我认为它最强大的方面仍然是具有10多个节点的庞大设置，用于大型全文本搜索和构面，复杂的索引编制和分数计算-这是ElasticSearch的亮点。当我们谈论时间序列和日志存储时，我的感觉是有更好的解决方案，而Clickhouse就是其中之一。 ElasticSearch API的功能非常强大，而且在许多情况下，如果不从文档中复制粘贴确切的HTTP请求，就很难记住如何做一件确切的事情，它只是一种“企业精神”。和＆＃34; Java风味的＆＃34;。 Clickhouse和ElasticSearch都是占用内存的应用程序，但最小的Clickhouse生产安装所需的RAM要求为4GB，而ElasticSearch的RAM要求约为16GB。我还认为弹性团队关注的重点是他们部署的所有新的惊人的机器学习功能都变得越来越模糊，我的愚见是，尽管这些功能听起来非常现代和新潮，但是无法支持和改进这一庞大的功能集，无论您拥有多少开发人员和金钱，因此ElasticSearch都会越来越多地进入“千篇一律，无所不包的大师”的行列。对我而言。也许我错了。 </p><p> Clickhouse just feels different. Setup is easy. SQL is easy. Console client is wonderful. Everything just feels so light and makes sense, even for smaller setups, but rich features, replicas, and shards for terabytes of data are there when you need it.</p><p>Clickhouse感觉与众不同。 设置很容易。 SQL很简单。 控制台客户端很棒。 即使对于较小的设置，一切都变得如此轻巧和有意义，但是当您需要时，就可以使用数十亿兆字节数据的丰富功能，副本和分片。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pixeljets.com/blog/clickhouse-vs-elasticsearch/">https://pixeljets.com/blog/clickhouse-vs-elasticsearch/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/替代/">#替代</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>