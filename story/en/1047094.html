<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通过Java 16 Unix域套接字通道与Postgres交谈 Talking to Postgres Through Java 16 Unix-Domain Socket Channels</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Talking to Postgres Through Java 16 Unix-Domain Socket Channels<br/>通过Java 16 Unix域套接字通道与Postgres交谈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 19:53:51</div><div class="page_narrow text-break page_content"><p>Reading a blog post about what’s  coming up in JDK 16 recently,I learned that one of the new features is support for Unix domain sockets ( JEP 380).Before Java 16, you’d have to resort to 3rd party libraries like  jnr-unixsocket in order to use them.If you haven’t heard about  Unix domain sockets before,they are &#34;data communications [endpoints] for exchanging data between processes executing on the same host operating system&#34;.Don’t be put off by the name btw.;Unix domain sockets are also supported by macOS and even Windows since  version 10.</p><p>在阅读有关最近JDK 16中即将发生的事情的博客文章时，我了解到新功能之一是对Unix域套接字（JEP 380）的支持。在Java 16之前，您必须诉诸于诸如jnr-unixsocket之类的第三方库为了使用它们。如果您以前从未听说过Unix域套接字，则它们是＆＃34;数据通信[端点]，用于在同一主机操作系统上执行的进程之间交换数据。从版本10开始关闭; macOS甚至Windows 10以后也支持Unix域套接字。</p><p> Databases such as Postgres or MySQL use them for offering an alternative to TCP/IP-based connections to client applications running on the same machine as the database.In such scenario,Unix domain sockets are both more secure(no remote access to the database is exposed at all; file system permissions can be used for access control),and also  more efficient than TCP/IP loopback connections.</p><p> 诸如Postgres或MySQL之类的数据库使用它们为与数据库在同一台机器上运行的客户端应用程序提供基于TCP / IP的连接的替代方法。在这种情况下，Unix域套接字都更安全（对数据库的远程访问是不安全的）。完全公开；文件系统权限可用于访问控制），并且比TCP / IP环回连接更有效。</p><p> A common use case are proxies for accessing Cloud-based databases,such as as the GCP  Cloud SQL Proxy.Running on the same machine as a client application(e.g. in a sidecar container in case of Kubernetes deployments),they provide secure access to a managed database, for instance taking care of the SSL handling.</p><p> 一个常见的用例是用于访问基于云的数据库的代理，例如GCP Cloud SQL Proxy。与客户端应用程序在同一台计算机上运行（例如，在Kubernetes部署中，在Sidecar容器中运行），它们提供对云数据库的安全访问。托管数据库，例如负责SSL处理。</p><p> My curiousity was piqued and I was wondering what it’d take to make use of the new Java 16 Unix domain socket for connecting to Postgres.It was your regular evening during the pandemic,without much to do, so I thought &#34;Let’s give this a try&#34;.To have a testing bed, I started with installing Postgres 13 on Fedora 33.Fedora might not always have the latest Postgres version packaged just yet,but following the official  Postgres instructions it is straight-forward to install newer versions.</p><p> 令我好奇的是，我想知道如何使用新的Java 16 Unix域套接字连接到Postgres。那是大流行期间的例行晚上，无事可做，所以我想＆＃34;让我们尝试一下。为了进行测试，我首先在Fedora 33上安装了Postgres13。Fedora可能并不总是已经打包了最新的Postgres版本，但是按照Postgres的官方说明，它很直接安装较新的版本。</p><p> In order to connect with user name and password via a Unix domain socket,one small adjustment to  /var/lib/pgsql/13/data/pg_hba.conf is needed:the access  method for the  local connection type must be switched from the default value  peer(which would try to authenticate using the operating system user name of the client process) to  md5.</p><p> 为了通过Unix域套接字与用户名和密码连接，需要对/var/lib/pgsql/13/data/pg_hba.conf进行一些小的调整：必须将本地连接类型的访问方法从默认值切换为将对等值（将尝试使用客户端进程的操作系统用户名进行身份验证）为md5。</p><p> ...# TYPE DATABASE USER ADDRESS METHOD# &#34;local&#34; is for Unix domain socket connections onlylocal all all md5...</p><p> ...＃类型数据库用户地址方法＃＆＃34;本地＆＃34;用于Unix域套接字连接onlylocal所有所有md5 ...</p><p> Make sure to apply the changed configuration by restarting the database( systemctl restart postgresql-13),and things are ready to go.</p><p> 确保通过重新启动数据库来应用更改的配置（systemctl restart postgresql-13），一切准备就绪。 </p><p> The first thing I looked into was the Postgres  JDBC driver.Since version  9.4-1208 (released in 2016) it allows you to configure custom socket factories,a feature which explicitly was added considering Unix domain sockets.The driver itself doesn’t come with a socket factory implementation that’d actually support Unix domain sockets,but a few external open-source implementations exist.Most notably junixsocket provides such  socket factory.</p><p>我研究的第一件事是Postgres JDBC驱动程序。自9.4-1208版本（2016年发布）以来，它允许您配置自定义套接字工厂，该功能明确考虑了Unix域套接字而添加。驱动程序本身不附带一个实际上支持Unix域套接字的套接字工厂实现，但是存在一些外部开源实现。最著名的junixsocket提供了这种套接字工厂。</p><p> Custom socket factories must extend  javax.net.SocketFactory,and their fully-qualified class name needs to be specified using the  socketFactory driver parameter.So it should be easy to create  SocketFactory implementation based on the new  UnixDomainSocketAddress class, right?</p><p> 自定义套接字工厂必须扩展javax.net.SocketFactory，并且必须使用socketFactory驱动程序参数指定其完全合格的类名称。因此，基于新的UnixDomainSocketAddress类创建SocketFactory实现应该很容易，对吗？</p><p> public  class  PostgresUnixDomainSocketFactory  extends  SocketFactory  {  @Override  public  Socket  createSocket ()  throws  IOException  {  var  socket  =  new  Socket ();  socket . connect ( UnixDomainSocketAddress . of (  &#34;/var/run/postgresql/.s.PGSQL.5432&#34; ));   (1)  return  socket ;  }  // other create methods ... }</p><p> 公共类PostgresUnixDomainSocketFactory扩展了SocketFactory {@Override public Socket createSocket（）throws IOException {var socket = new Socket（）;插座。连接（（＆＃34; /var/run/postgresql/.s.PGSQL.5432&#34;）的UnixDomainSocketAddress。）; （1）返回插座； } //其他创建方法...}</p><p> Create a Unix domain socket address for the default path of the socket on Fedora and related systems</p><p> 为Fedora和相关系统上的套接字的默认路径创建Unix域套接字地址</p><p> It compiles just fine;but it turns out not all socket addresses are equal,and  java.net.Socket only connects to addresses of type  InetSocketAddress(and the PG driver maintainers seem to sense some air of mystery around these &#34;unusual&#34; events, too):</p><p> 它可以很好地编译；但事实证明并非所有套接字地址都相等，并且java.net.Socket仅连接到InetSocketAddress类型的地址（并且PG驱动程序维护人员似乎对这些＆＃34;＆＃34;异常＆＃ 34；事件）：</p><p> org.postgresql.util.PSQLException: Something unusual has occurred to cause the driver to fail. Please report this exception. at org.postgresql.Driver.connect(Driver.java:285) ...Caused by:java.lang.IllegalArgumentException: Unsupported address type at java.base/java.net.Socket.connect(Socket.java:629) at java.base/java.net.Socket.connect(Socket.java:595) at dev.morling.demos.PostgresUnixDomainSocketFactory.createSocket(PostgresUnixDomainSocketFactory.java:19) ...</p><p> org.postgresql.util.PSQLException：发生某些异常情况导致驱动程序失败。请报告此异常。在org.postgresql.Driver.connect（Driver.java:285）...由...引起:: java.lang.IllegalArgumentException：java.base / java.net.Socket.connect（Socket.java:629）处的地址类型不受支持java.base / java.net.Socket.connect（Socket.java:595）在dev.morling.demos.PostgresUnixDomainSocketFactory.createSocket（PostgresUnixDomainSocketFactory.java:19）...</p><p> Now JEP 380 solely speaks about  SocketChannel and stays silent about  Socket;but perhaps obtaining a socket from a domain socket channel works?</p><p> 现在，JEP 380仅谈论SocketChannel，而对Socket保持沉默；但是也许从域套接字通道获取套接字是可行的吗？ </p><p>    Indeed it looks like JEP 380 is concerning itself only with the non-blocking  SocketChannel API,while users of the blocking  Socket API do not get to benefit from it.It should be possible to create a custom  Socket implementation based on the socket channel support of JEP 380,but that’s going beyond the scope of my little exploration.</p><p>实际上，看起来JEP 380仅与非阻塞SocketChannel API有关，而阻塞Socket API的用户却无法从中受益。应该有可能基于以下方面的套接字通道支持创建自定义Socket实现： JEP 380，但这超出了我的小探索范围。</p><p> If the Postgres JDBC driver doesn’t easily benefit from the JEP,what about other Java Postgres clients then?There are several non-blocking options,including the  Vert.x Postgres client and  R2DBC.The former is used to bring Reactive capabilities for Postgres into the Quarkus stack, too,so I turned my attention to it.</p><p> 如果Postgres JDBC驱动程序不能轻易地从JEP中受益，那么其他Java Postgres客户端呢？有几种非阻塞选项，包括Vert.x Postgres客户端和R2DBC。前者用于为Postgres带来Reactive功能。也进入了Quarkus堆栈，所以我将注意力转向了它。</p><p> Now the Vert.x Postgres Client already has support for Unix domain sockets,by means of adding the right Netty native transport dependency to your project.So purely from functionality perspective, there’s not that much to be gained here.But being able to use domain sockets also with the default NIO transport would still be nice,as it means one less dependency to take care of.So I dug a bit into the code of the Postgres client and Vert.x itself and figured out, that two things needed adjustment:</p><p> 现在，Vert.x Postgres Client已经通过向项目添加正确的Netty本机传输依赖项来支持Unix域套接字。因此从功能的角度来看，在这里并没有太多收获，但是能够使用域具有默认NIO传输的套接字仍然会很好，因为这意味着要减少一个依赖关系。因此，我对Postgres客户端和Vert.x本身的代码进行了深入研究，发现需要调整两件事：</p><p> The NIO-based   Transport class of Vert.x needs to learn about the fact that  SocketChannel now also supports Unix domain sockets (currently, an exception is raised when trying to use them without a Netty native transport)</p><p> Vert.x的基于NIO的Transport类需要了解一个事实，即SocketChannel现在还支持Unix域套接字（当前，当尝试在没有Netty本机传输的情况下使用它们时会引发异常）</p><p> Netty’s   NioSocketChannel needs some small changes, as it tries to obtain a  Socket from the underlying  SocketChannel, which doesn’t work for domain sockets as we’ve seen above</p><p> Netty的NioSocketChannel需要进行一些细微的更改，因为它试图从基础SocketChannel获取一个Socket，但如上所述，它不适用于域套接字</p><p> Step 1 was quickly done by creating a custom sub-class of the default  Transport class.Two methods needed changes: channelFactory() for obtaining a factory for the actual Netty transport channel,and  convert() for converting a Vert.x  SocketAddress into a NIO one:</p><p> 通过创建默认Transport类的自定义子类可以快速完成第1步。需要更改两个方法：channelFactory（）用于获取实际Netty传输通道的工厂，以及convert（）用于将Vert.x SocketAddress转换为NIO一：</p><p> public  class  UnixDomainTransport  extends  Transport  {  @Override  public  ChannelFactory &lt;?  extends  Channel &gt;  channelFactory (  boolean  domainSocket )  {  if  (! domainSocket )  {   (1)  return  super . channelFactory ( domainSocket );  }  else  {  return  ()  -&gt;  {  try  {  var  sc  =  SocketChannel . open ( StandardProtocolFamily . UNIX );   (2)  return  new  UnixDomainSocketChannel ( null ,  sc );  }  catch ( Exception  e )  {  throw  new  RuntimeException ( e );  }  };  }  }  @Override  public  SocketAddress  convert ( io . vertx . core . net . SocketAddress  address )  {  if  (! address . isDomainSocket ())  {   (3)  return  super . convert ( address );  }  else  {  return  UnixDomainSocketAddress . of ( address . path ());   (4)  }  } }</p><p> 公共类UnixDomainTransport扩展了传输{@Override public ChannelFactory＆lt ;?扩展频道＆gt; channelFactory（boolean domainSocket）{if（！domainSocket）{（1）返回super。 channelFactory（domainSocket）; } else {return（）-＆gt; {尝试{var sc = SocketChannel。打开（StandardProtocolFamily。UNIX）; （2）返回新的UnixDomainSocketChannel（null，sc）; } catch（Exception e）{抛出新的RuntimeException（e）; }; }} @Override public SocketAddress convert（io.vertx.core.net.SocketAddress address）{if（！address。isDomainSocket（））{（3）返回超级。转换（地址）; } else {返回UnixDomainSocketAddress。 of（address.path（））; （4）}}} </p><p> This channel factory returns instances of our own  UnixDomainSocketChannel type (see below), passing a socket channel based on the new  UNIX protocol family</p><p>该通道工厂返回我们自己的UnixDomainSocketChannel类型的实例（请参见下文），并基于新的UNIX协议家族传递套接字通道</p><p> Now let’s take a look at the  UnixDomainSocketChannel class.I was hoping to get away again with creating a sub-class of the NIO-based implementation, io.netty.channel.socket.nio.NioSocketChannel in this case.Unfortunately, though, the  NioSocketChannel constructor invokes the taboo  SocketChannel#socket() method.Of course that’d not be a problem when doing this change in Netty itself,but for my little exploration I ended up copying the class and doing the required adjustments in that copy.I ended up doing two small changes:</p><p> 现在让我们看一下UnixDomainSocketChannel类，我希望通过创建基于NIO的实现的子类io.netty.channel.socket.nio.NioSocketChannel再次摆脱这种情况。 NioSocketChannel构造函数调用禁忌SocketChannel＃socket（）方法。在Netty本身中进行此更改当然不是问题，但出于我的小探索，我最终复制了该类并在该副本中进行了所需的调整。最终做了两个小改动：</p><p> public  UnixDomainSocketChannel ( Channel  parent ,  SocketChannel  socket )  {  super ( parent ,  socket );  config  =  new  NioSocketChannelConfig ( this ,  new  Socket ());   (1) }</p><p> 公共UnixDomainSocketChannel（Channel parent，SocketChannel socket）{super（parent，socket）; config = new NioSocketChannelConfig（this，new Socket（））; （1）}</p><p> Passing a dummy socket instead of  socket.socket(), it shouldn’t be accessed in our case anyways</p><p> 传递虚拟套接字而不是socket.socket（），无论如何我们都不应该访问它</p><p> A few methods call the  Socket methods  isInputShutdown() and  isOutputShutdown();those should be possible to be by-passed by keeping track of the two shutdown flags ourselves</p><p> 一些方法调用Socket方法isInputShutdown（）和isOutputShutdown（）；应该可以通过自己跟踪两个关闭标志来绕过这些方法</p><p> As I was creating the  UnixDomainSocketChannel in my own namespace instead of Netty’s packages,a few references to the non-public method  NioChannelOption#getOptions() needed commenting out,which again shouldn’t be relevant for the domain socket case</p><p> 当我在自己的命名空间而不是Netty的包中创建UnixDomainSocketChannel时，需要注释掉一些对非公共方法NioChannelOption＃getOptions（）的引用，这再次与域套接字的情况无关</p><p> You can find the complete change in  this commit.All in all, not exactly an artisanal piece of software engineering,but the little hack seemed good enough at least for taking a quick glimpse at the new domain socket support.Of course a real implementation could be done much more properly within the Netty project itself.</p><p> 您可以在此提交中找到完整的更改。总而言之，这不完全是一个手工的软件工程，但是这个小技巧至少足以让我们快速了解新的域套接字支持。当然，真正的实现可以在Netty项目本身中可以更正确地完成。 </p><p> So it was time to give this thing a test ride.As we need to configure the custom  Transport implementation,retrieval of a  PgPool instance is a tad more verbose than usual:</p><p>因此，是时候对该产品进行测试了。由于我们需要配置自定义Transport实施，因此PgPool实例的检索比平时更为冗长：</p><p> PgConnectOptions  connectOptions  =  new  PgConnectOptions ()  . setPort ( 5432 )   (1)  . setHost ( &#34;/var/run/postgresql&#34; )  . setDatabase ( &#34;test_db&#34; )  . setUser ( &#34;test_user&#34; )  . setPassword ( &#34;topsecret!&#34; ); PoolOptions  poolOptions  =  new  PoolOptions ()  . setMaxSize ( 5 ); VertxFactory  fv  =  new  VertxFactory (); fv . transport ( new  UnixDomainTransport ());   (2) Vertx  v  =  fv . vertx (); PgPool  client  =  PgPool . pool ( v ,  connectOptions ,  poolOptions );   (3)</p><p> PgConnectOptions connectOptions =新的PgConnectOptions（）。 setPort（5432）（1）。 setHost（＆＃34; / var / run / postgresql＆＃34;）。 setDatabase（＆＃34; test_db＆＃34;）。 setUser（＆＃34; test_user＆＃34;）。 setPassword（＆＃34; topsecret！＆＃34;）; PoolOptions poolOptions =新的PoolOptions（）。 setMaxSize（5）; VertxFactory fv =新的VertxFactory（）; fv。传输（新的UnixDomainTransport（））； （2）顶点v = fv。顶点（）​​; PgPool客户端= PgPool。池（v，connectOptions，poolOptions）; （3）</p><p> The Vert.x Postgres client constructs the domain socket path from the given port and path (via  setHost());the full path will be  /var/run/postgresql/.s.PGSQL.5432, just as above</p><p> Vert.x Postgres客户端从给定的端口和路径（通过setHost（））构造域套接字路径；完整路径将是/var/run/postgresql/.s.PGSQL.5432，与上面相同</p><p> We then can can use the client instance as usual,only that it now will connect to Postgres using the domain socket instead of via TCP/IP.All this solely using the default NIO-based transports,without the need for adding any Netty native dependency, such as its epoll-based transport.</p><p> 然后我们可以照常使用客户端实例，只不过它现在将使用域套接字而不是通过TCP / IP连接到Postgres。所有这些仅使用默认的基于NIO的传输方式，而无需添加任何Netty本机依赖项，例如基于epoll的运输方式。</p><p> I haven’t done any real performance benchmark at this point;in a quick ad-hoc test of executing a trivial  SELECT query on a primay key 200,000 times,I observed a latency of ~0.11 ms when using Unix domain sockets — with both,  netty-transport-native-epoll and JDK 16 Unix domain sockets — and ~0.13 ms when connecting via TCP/IP.So definitely a significant improvement which can be a deciding factor for low-latency use cases,though in comparison to  other reports,the latency reduction of ~15% appears to be at the lower end of the spectrum.</p><p> 我目前还没有做过任何实际的性能基准测试；在对临时键执行琐碎的SELECT查询200,000次的快速即席测试中，我观察到使用Unix域套接字时的延迟约为0.11毫秒。 netty-transport-native-epoll和JDK 16 Unix域套接字（通过TCP / IP连接时）和〜0.13毫秒。因此，与其他报告相比，绝对有很大的改进，这绝对是低延迟用例的决定性因素，延迟降低约15％似乎在频谱的较低端。</p><p> Some more sincere performance evaluation should be done,for instance also examining the impact on garbage collection.And it goes without saying that you should only trust your own measurements,on your own hardware, based on your specific workloads,in order to decide whether you would benefit from domain sockets or not.</p><p> 应该进行一些更真诚的性能评估，例如还要检查对垃圾回收的影响。不用说，您应该仅基于自己的特定工作负载，在自己的硬件上信任自己的测量，以便确定是否是否会受益于域套接字。</p><p> Database connectivity is just one of the use cases for domain sockets;highly performant local inter-process communication comes in handy for all kinds of use cases.One which I find particularly intriguing is the creation of modular applications based on a multi-process architecture.</p><p> 数据库连接只是域套接字的用例之一；高性能的本地进程间通信可用于各种用例。我发现特别有趣的一个是基于多进程体系结构的模块化应用程序的创建。 </p><p> When thinking of classic  Java Jakarta EE application servers for instance,you could envision a model where both the application server and each deployment are separate processes,communicating through domain sockets.This would have some interesting advantages, such as stricter isolation(so for instance an  OutOfMemoryError in one deployed application won’t impact others) and re-deployments without any risk of classloader leaks, as the JVM of an deployment would be restarted.On the downside, you’d be facing a higher overall memory consumption(although that can at least partly be mitigated through  class data sharing, which also works across JVM boundaries) and more costly (remote) method invocations between deployments.</p><p>例如，当考虑经典的Java Jakarta EE应用服务器时，您可以设想一个模型，其中应用服务器和每个部署都是独立的进程，通过域套接字进行通信。这将具有一些有趣的优点，例如更严格的隔离（例如，一个已部署的应用程序中的OutOfMemoryError不会影响其他应用程序），并且重新部署不会造成类加载器泄漏的任何风险，因为部署的JVM将重新启动。不利的是，您将面临更高的整体内存消耗（尽管这样做可能会至少部分地通过类数据共享（这也可跨JVM边界工作）和部署之间更昂贵（远程）的方法调用来缓解。</p><p> Now the application server model has fallen out of favour for various reasons,but such multi-process design still is very interesting,for instance for building modular applications that should expose a single web endpoint,while being assembled from a set of processes which are developed and deployed by several, independent teams.Another use case would be desktop applications that are made up of a set of processes for isolation purposes,as it’s e.g. done by most web browsers noawadays with distinct processes for separate tabs.JEP 380 should facilitate this model when creating Java applications,e.g. considering rich clients built with JavaFX.</p><p> 现在，由于各种原因，应用服务器模型已不受欢迎，但是这种多进程设计仍然非常有趣，例如，用于构建模块化应用程序，该应用程序应公开单个Web端点，同时由一组已开发的进程组装而成由几个独立的团队部署。另一个用例是台式机应用程序，该程序由一组出于隔离目的的进程组成，例如如今，大多数Web浏览器都采用了针对不同标签的不同处理过程。JEP380在创建Java应用程序时应简化此模型，例如考虑使用JavaFX构建的富客户端。</p><p> Another, really interesting feature of Unix domain sockets is the ability to transfer open file descriptors from one process to another.This allows for  non-disruptive upgrades of server applications,without dropping any open TCP connections.This technique is used for instance by Envoy Proxy for  applying configuration changes:upon a configuration change,a second Envoy instance with the new configuration is started up,takes over the active sockets from the previous instance and after some &#34;draining period&#34; triggers a shutdown of the old instance.This approach enables a truly immutable application design within Envoy itself,with all its advantages,without the need for in-process configuration reloads.I highly recommend to read the two posts linked above, they are super-interesting.</p><p> Unix域套接字的另一个非常有趣的功能是能够将打开文件描述符从一个进程转移到另一个进程。这允许对服务器应用程序进行无中断升级，而不会丢失任何打开的TCP连接。例如，Envoy Proxy使用了此技术。用于应用配置更改的方法：配置更改后，启动具有新配置的第二个Envoy实例，并接管前一个实例的活动套接字，并且在“排水期”之后进行。触发旧实例的关闭。这种方法可实现Envoy本身的真正不变的应用程序设计，它具有所有优点，而无需重新加载进程内配置。我强烈建议阅读上面链接的两篇文章，它们非常适合-有趣。</p><p> Unfortunately, JEP 380  doesn’t seem to support file descriptor transfers.So for this kind of architecture, you’d still have to refrain to the aforementioned junixsocket library,which explicitly lists  file transcriptor transfer support as one of its features.While you  couldn’t take advantage of that using Java’s NIO API,it should be doable using alternative networking frameworks such as  Netty.Probably a topic for another blog post on another one of those pandemic weekends ;)</p><p> 不幸的是，JEP 380似乎不支持文件描述符传输。因此，对于这种架构，您仍然必须避免使用前面提到的junixsocket库，该库明确列出了文件转录器传输支持作为其功能之一。不能利用Java的NIO API来利用它，而应该使用Netty等替代网络框架来实现。可能是在那些大流行周末中另一个博客文章的主题;）</p><p> And that completes my small exploration of Java 16’s support for Unix domain sockets.If you want to do your own experiments of using them to connect to Postgres,make sure to install the latest JDK 16 EA build and grab the source code of my experimentation from  this GitHub repo.</p><p> 这样就完成了我对Java 16对Unix域套接字的支持的小型探索。如果您要进行使用它们连接到Postgres的实验，请确保安装最新的JDK 16 EA构建并从中获取实验的源代码。这个GitHub仓库。</p><p> It’d be my hope that frameworks like Netty and Vert.x make use of this JDK feature fairly quickly,as only a small amount of code changes is required,and users get to benefit from the higher performance of domain sockets without having to pull in any additional dependencies.In order to keep compatibility with Java versions prior to 16, multi-release JARs offer one avenue for integrating this feature.</p><p> 我希望像Netty和Vert.x这样的框架能够相当快地利用此JDK功能，因为只需要进行少量代码更改，并且用户就可以从域套接字的更高性能中受益，而不必拉扯为了保持与16之前的Java版本的兼容性，多发行版JAR提供了一种集成此功能的途径。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.morling.dev/blog/talking-to-postgres-through-java-16-unix-domain-socket-channels/">https://www.morling.dev/blog/talking-to-postgres-through-java-16-unix-domain-socket-channels/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/通道/">#通道</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/postgres/">#postgres</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>