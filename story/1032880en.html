<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>离开OCaml</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">离开OCaml</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 08:45:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/6603cd1fbee2c6b502f703ba5890e04f.jpg"><img src="http://img2.diglog.com/img/2020/11/6603cd1fbee2c6b502f703ba5890e04f.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I built the first demo of Dark in Python, in about two weeks. A few months later when I started productizing it, I rebuilt it in OCaml. Back in 2017, when I was considering the language and platform to use for Dark, OCaml was extremely compelling:</p><p>我在大约两周内构建了Python中的第一个Dark演示。几个月后，当我开始制作它时，我在OCaml中重建了它。早在2017年，当我在考虑Dark使用的语言和平台时，OCaml非常令人信服：</p><p> it&#39;s a high-level language with static types, so easy to make large scale changes as we figure out what the language/product was</p><p>它是一种具有静态类型的高级语言，因此当我们弄清楚语言/产品是什么时，很容易进行大规模更改。</p><p> you mostly model data with sum types, which in my mind are the best way to model data</p><p>您主要使用SUM类型对数据建模，在我看来，这是对数据建模的最佳方式。</p><p> it&#39;s very similar to the language I wanted to build (in particular, we could reuse built-in immutable data structures for Dark&#39;s values)</p><p>它与我想要构建的语言非常相似(特别是，我们可以对Dark的值重用内置的不可变数据结构)。</p><p> it had a reputation for being high-performance, which meant that we could write an interpreter for Dark and not have it be terribly slow (vs writing an interpreter in python, which might be too slow)</p><p>它有高性能的名声，这意味着我们可以为Dark编写一个解释器，而不会让它变得非常慢(而不是用Python编写解释器，后者可能太慢了)。</p><p> Unfortunately, as we&#39;ve built Dark we&#39;ve run into significant problems that have made it challenging to build in OCaml.</p><p>不幸的是，当我们建造黑暗的时候，我们遇到了严重的问题，这使得在OCaml中建造变得具有挑战性。</p><p>  When you bet on an off-mainstream language, one of the things you accept is that many libraries are not going to be available. When there is a small community, often there aren&#39;t enough people working in the language to make important libraries. This is especially true if few people are building business applications.</p><p>当您押注于一种非主流语言时，您接受的一件事是许多库将不会可用。当有一个很小的社区时，通常没有足够的人从事这种语言的工作，无法建立重要的库。如果很少有人构建业务应用程序，这一点尤其正确。</p><p> In OCaml there are many high quality libraries, especially for data structures and data manipulation. The annual  Jane Street code dump has been quite useful and very high quality. However, we really felt the lack of several libraries. The most obvious of these is that we had to build a  Unicode string library ourselves (built on top of the  very impressive OCaml Unicode libraries built by  Daniel Bünzli), but we needed many more libraries than that.</p><p>OCaml中有许多高质量的库，特别是用于数据结构和数据操作的库。一年一度的简街代码转储非常有用，而且质量非常高。然而，我们确实感觉到缺少几个图书馆。其中最明显的是，我们必须自己构建Unicode字符串库(构建在Daniel Bünzli构建的非常令人印象深刻的OCaml Unicode库之上)，但我们需要更多的库。</p><p> The lack of an SDK for Google Cloud has affected us greatly. When you&#39;re searching for product-market fit, you do the simplest, easiest thing. If you lack a good SDK for your cloud provider, the simplest, easiest thing is often a terrible architectural choice. We&#39;ve built our own queue on top of our database rather than using the production-quality cloud queues available on GCP. Similarly, we barely use the Cloud Storage (GCP&#39;s version of S3), because we initially put things in the database  because it was easier. We&#39;ve built 3 services, 2  in  Rust, and 1 in  Go, to workaround the challenges we&#39;ve faced.</p><p>缺少Google Cloud的SDK对我们影响很大。当你在寻找适合市场的产品时，你做的是最简单、最容易的事。如果您的云提供商缺少一个好的SDK，那么最简单、最容易的事情往往是糟糕的架构选择。我们已经在我们的数据库之上构建了我们自己的队列，而不是使用GCP上提供的生产质量的云队列。同样，我们几乎不使用云存储(GCP&#39；的S3版本)，因为我们最初将内容放入数据库是因为它更容易。我们已经构建了3个服务，2个在Rust中，1个在Go中，以解决我们所面临的挑战。</p><p> The biggest challenge here is our use of Postgres. Postgres is a great database and we&#39;re big fans, but Cloud SQL is not a great hosted database. GCP&#39;s position is that Cloud SQL is there to tick a box and we should be using Cloud Spanner. I would love to switch to Cloud Spanner, but we have no driver for it in OCaml. Given the Postgres driver in OCaml is not particularly mature, it&#39;s hard to expect that a Cloud Spanner driver would exist, and indeed it doesn&#39;t. We&#39;ve had to contribute to the  OCaml Postgres driver, and some parts of our codebase have been  well and truly mangled when working around features not supported in that driver.</p><p>这里最大的挑战是我们使用Postgres。Postgres是一个很棒的数据库，我们都是它的忠实粉丝，但是Cloud SQL不是一个很好的托管数据库。GCP的立场是，Cloud SQL是用来勾选的，我们应该使用Cloud Spanner。我很想换成云扳手，但我们OCaml没有驱动程序。考虑到OCaml中的Postgres驱动程序还不是特别成熟，很难指望会有Cloud Spanner驱动程序存在，而且确实没有。我们不得不为OCaml Postgres驱动程序做贡献，而且我们的代码库中的某些部分在处理该驱动程序不支持的功能时已经完全损坏了。</p><p> We&#39;ve also suffered from a lack of a high-level, production web stack (there are  low-level stacks with good reputations that I&#39;ve struggled to use, and a  few  new ones out there that look good), in particular lacking a user authentication module. We&#39;ve been using  Auth0 to work around this for now, which has more moving pieces than I&#39;d like, and a shockingly high cost (our 7000 users, most of whom never log in, costs us over $500/mo).</p><p>我们还面临着缺乏高级别的生产性Web堆栈的问题(有一些声誉良好的低级堆栈我一直在努力使用，还有一些新的堆栈看起来不错)，尤其是缺乏用户身份验证模块。我们现在一直在使用Auth0来解决这个问题，它有比我想要的更多的移动棋子，而且成本高得令人震惊(我们的7000名用户，其中大多数从未登录，花费我们超过500美元/月)。</p><p> We&#39;ve worked around other missing vendor SDKs by calling their HTTP endpoints directly and that&#39;s been mostly fine. However, for libraries like encryption we don&#39;t have that option - we  hacked around a missing encryption library, but decided not to ship it to production until we audited it for security (which was never actually worth the cost).</p><p>我们已经解决了其他缺失的供应商SDK，直接调用它们的HTTP端点，这基本上没什么问题。然而，对于像Encryption这样的库，我们没有这样的选择-我们破解了一个丢失的加密库，但决定在我们对其进行安全审计之前不将其交付生产(这实际上从来都不值这个成本)。</p><p> At CircleCI, we bet on Clojure. That was also a non-mainstream language, but its ability to call Java SDKs meant we had a mature cloud library, which was essential for building CircleCI. Of course, in OCaml we could call C libraries (and  even Rust libraries, perhaps), but it doesn&#39;t match having native libraries we can call directly.</p><p>在CircleCI，我们押注于Clojure。这也是一种非主流语言，但它调用JavaSDK的能力意味着我们拥有一个成熟的云库，这对于构建CircleCI至关重要。当然，在OCaml中，我们可以调用C库(甚至可能还有Rust库)，但它不能与我们可以直接调用的本地库相匹配。</p><p>  I&#39;m mostly in the camp that anyone can learn any language, but I saw a team struggle with OCaml, and for good reason. Language tutorials are extremely poor in OCaml compared to other languages; they&#39;re mostly lecture notes from academic courses.</p><p>我主要是支持任何人都可以学习任何语言的阵营，但我看到一个团队在与OCaml斗争，这是有充分理由的。与其他语言相比，OCaml中的语言教程非常差；它们大多是学术课程的课堂讲稿。</p><p> The compiler isn&#39;t particularly helpful, certainly compared to Rust or Elm (both of which have been in our stack at one point). Often it gives no information about an error. Syntax errors typically say &#34;Syntax error&#34;; though it will try to give a good error for a mismatched brace, often incorrectly. Type errors can be a real burden to read, even after 3 years of experience with it.</p><p>当然，与Rust或Elm(这两个都曾经在我们的堆栈中)相比，编译器并不是特别有帮助。通常，它不提供有关错误的信息。语法错误通常显示为语法错误，尽管它会尝试为不匹配的花括号(通常是不正确的)提供正确的错误。打字错误可能会成为阅读的真正负担，即使在使用了3年之后也是如此。</p><p> The docs in OCaml are often challenging to find. The  Jane Street docs have improved significantly in the last few years, but it can be a challenge to even figure out what functions are available in a particular module for most libraries. Compare to the excellent  docs.rs in Rust, which has comprehensive API docs for every package in Rust.</p><p>OCaml中的文档通常很难找到。在过去的几年中，Jane Street文档有了很大的改进，但即使是找出特定模块中的哪些功能对于大多数库都是可用的，这也可能是一个挑战。与Rust中优秀的docs.rs相比，Rust中的每个包都有全面的API文档。</p><p> One of the ways I personally struggled in OCaml is around  Lwt. Lwt is (one of!) OCaml&#39;s async implementations. I couldn&#39;t figure it out several years ago and so just built a single-threaded server. The amount of workarounds and downtime we&#39;ve suffered from that single decision is immense. A tutorial around building high-performance (or even medium performance!) web servers would be very valuable.</p><p>我个人在OCaml奋斗的方式之一就是围绕路易斯安那州立大学(LWT)。LWT是(其中之一！)。OCaml&39；的异步实现。几年前我想不出来，所以就构建了一个单线程服务器。我们因这一决定而遭受的变通和停机时间是巨大的。关于构建高性能(甚至中等性能！)的教程。Web服务器将非常有价值。</p><p>  Tooling is something I read would be good in OCaml. I remember reading there was a debugger that could go back in time! I don&#39;t know where that&#39;s gone but I&#39;ve never heard of anyone using it.</p><p>工具是我在OCaml中读到的很好的东西。我记得读到过有一个调试器可以回到过去！我不知道它到哪里去了，但我从来没有听说过有人用过它。</p><p> We have struggled to make editor tooling work for us. This is partially because we also use ReasonML and this seems to break things. Unfortunately, this is common in programming, but even more so in small communities: you might be the first person to ever try to use a particular configuration.</p><p>我们一直在努力让编辑器工具为我们工作。这在一定程度上是因为我们也使用了ReasonML，这似乎会破坏一些东西。不幸的是，这在编程中很常见，但在小型社区中更是如此：您可能是第一个尝试使用特定配置的人。</p><p> Finally, the disconnect between the various tools is immense. You need to understand Opam, Dune, and Esy, to be able to get something working (you could also do it without Esy and just rely on Opam, but that&#39;s much worse). I talked about a bunch of these challenges  here.</p><p>最后，各种工具之间的脱节是巨大的。你需要了解Opam，Dune和Esy，才能让一些东西正常工作(你也可以在没有Esy的情况下做到这一点，只依靠Opam，但那要糟糕得多)。我在这里谈到了一大堆这样的挑战。</p><p>  Multicore is coming Any Day Now™️, and while this wasn&#39;t a huge deal for us, it was annoying.</p><p>多核现在随时都会出现，™️，虽然这对我们来说不是什么大事，但它很烦人。</p><p>  One of my biggest annoyances was how often OCaml folks talk about Fancy Type System problems, instead of how to actually build products and applications. In other communities for similar languages (ReasonML, Elm, F#), people talk about building apps and solving their problems. In OCaml, it feels like people spend an awful lot of time discussing Functors. It&#39;s not quite at the level that I perceived in the Haskell world, but it pointed out that the people building the core of the ecosystem do not have the same problems that I do (which is building web-y stuff).</p><p>我最大的烦恼之一是OCaml的人们经常谈论Fancy Type系统问题，而不是如何实际构建产品和应用程序。在其他类似语言的社区(ReasonML、Elm、F#)，人们谈论构建应用程序和解决他们的问题。在OCaml中，感觉人们花了大量时间讨论函数器。这并不完全是我在哈斯克尔世界中感受到的水平，但它指出，构建生态系统核心的人并不存在与我相同的问题(即构建基于网络的东西)。</p><p>  I honestly think OCaml was a great choice at the start. Being able to quickly and safely make large-scale changes to your app is something that staticly-typed functional languages excel at. I&#39;m happy that we made the choice, and in retrospect, it still seems like the best choice of those we had at the time.</p><p>老实说，我认为OCaml在一开始就是一个很好的选择。能够快速、安全地对您的应用程序进行大规模更改是静态类型函数式语言所擅长的。我很高兴我们做出了这个选择，回想起来，这似乎仍然是我们当时拥有的最好的选择。</p><p>  I&#39;m working on building the next version of the backend. We have about 20k lines to be replaced, and they&#39;ll be rewritten in a new language while keeping the semantics the same. I plan to leave keep the frontend in ReasonML: it doesn&#39;t suffer from the same library problems as it can interface nicely to JS, and it&#39;s nearly 50k lines of code so it would be a much bigger undertaking.</p><p>我正在努力建立下一个版本的后端。我们大约有两万行要替换，它们将在保持语义不变的情况下用一种新的语言重写。我计划将前端保留在ReasonML中：它不会因为可以很好地与JS接口而遭受相同的库问题，而且它有近50000行代码，所以它将是一项更大的事业。</p><p>   You can sign up for Dark    here  . For more info on Dark, follow our    RSS  , follow    us   (or    me  ) on Twitter, join our    Slack Community  , or watch our    GitHub repo  .</p><p>你可以在这里报名参加“黑暗”。欲了解更多关于Dark的信息，请关注我们的RSS，在Twitter上关注我们(或我)，加入我们的松弛社区，或观看我们的GitHub回购。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.darklang.com/leaving-ocaml/">https://blog.darklang.com/leaving-ocaml/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/leaving/">#leaving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>