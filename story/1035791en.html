<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我应该在生产中使用SwiftUI吗？代码对代码的比较可帮助您确定Should I use SwiftUI in production? A code-to-code comparison to help you decide</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Should I use SwiftUI in production? A code-to-code comparison to help you decide<br/>我应该在生产中使用SwiftUI吗？代码对代码的比较可帮助您确定</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-22 03:30:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/bcbbb5ae6ea49fbb6a98ae1f01eab52b.png"><img src="http://img2.diglog.com/img/2020/11/bcbbb5ae6ea49fbb6a98ae1f01eab52b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>SwiftUI — Apple’s declarative UI framework that works across all its software platforms —  is young and full of problems, but it&#39;s also magically simple and crazy fast to build once you get the hang of it.</p><p>SwiftUI是Apple的声明式UI框架，可在其所有软件平台上运行，它虽然很年轻，但充满了问题，但是一旦掌握了它，魔术般的简单和疯狂的快速构建即可。</p><p> So we really shouldn&#39;t be asking whether it is or isn&#39;t flatly &#34;production-ready.&#34; Rather, we must evaluate whether it&#39;s a strategic choice depending on our specific circumstances and projects.</p><p> 因此，我们真的不应该问它是否完全是“准备生产”的。相反，我们必须根据我们的具体情况和项目评估这是否是一项战略选择。</p><p> Here&#39;s some variables you should weigh to decide whether to use SwiftUI in your production apps.</p><p> 您应权衡一些变量，以决定是否在生产应用程序中使用SwiftUI。</p><p>  If you&#39;ve never used SwiftUI before (or some other declarative UI framework), don&#39;t expect to hit the ground running. While you may have heard it&#39;s simpler and easier to use than traditional frameworks like UIKit, there&#39;s about a million caveats.</p><p>  如果您以前从未使用过SwiftUI（或其他声明性UI框架），请不要指望实际运行。尽管您可能已经听说过，它比UIKit等传统框架更易于使用，但仍有大约一百万个警告。</p><p> First of all, the declarative style that makes it so simple also has a steep learning curve. If you&#39;re used to UIKit (or programming in pretty much any other context), your habits are going to resist embracing the paradigm in ways you might not even expect.</p><p> 首先，如此简单的声明式风格也具有陡峭的学习曲线。如果您习惯了UIKit（或几乎在任何其他上下文中进行编程），您的习惯将以您甚至没有想到的方式抵制拥抱该范式。</p><p>    Seems pretty straightforward, right? You pass the title of the button in the initializer, and a closure for the button action. Great.</p><p>看起来很简单，对不对？您在初始化程序中传递按钮的标题，并传递按钮动作的结束符。大。</p><p> But now lets say you want to present a view modally on tap of the button, like so:</p><p> 但是现在让我们说您想在点击按钮时模态显示视图，如下所示：</p><p>    In other words, the button is performing the act of &#34;presenting&#34; the view controller. But in SwiftUI, everything is declared as a function of view state. There is no concept of &#34;doing something&#34; except as a modification of the universe of view state that has already been declared.  So first, we&#39;d need to add the button to our view:</p><p>    换句话说，按钮正在执行“呈现”视图控制器的动作。但是在SwiftUI中，所有内容都声明为视图状态的函数。除了作为已声明的视图状态范围的修改之外，没有“做某事”的概念。因此，首先，我们需要将按钮添加到视图中：</p><p> struct ParentView: View { var body: some View { Button(&#34;Present View&#34;) { /// Insert button action here } }}</p><p> struct ParentView：View {var body：some View {Button（“ Present View”）{///在此处插入按钮动作}}}</p><p> Then we&#39;d need a variable that tracks the state of the view being presented, and we&#39;d have to modify that variable in the button&#39;s closure.</p><p> 然后，我们需要一个变量来跟踪呈现的视图的状态，并且我们必须在按钮的闭合处修改该变量。</p><p> struct ParentView: View { @State private var isPresenting: Bool = false var body: some View { Button(&#34;Present View&#34;) { self.isPresenting = true } }}</p><p>struct ParentView：View {@State private var isPresenting：Bool = false var body：一些View {Button（“ Present View”）{self.isPresenting = true}}}</p><p> But where is the view actually being presented? We need to declare it in the body as well and attach it to our variable. SwiftUI uses the &#34;sheet&#34; modifier for modally presenting views:</p><p> 但是，视图实际显示在哪里？我们还需要在主体中声明它，并将其附加到我们的变量中。 SwiftUI使用“工作表”修饰符来模态呈现视图：</p><p> struct ParentView: View { @State private var isPresenting: Bool = false var body: some View { Button(&#34;Present View&#34;) { self.isPresenting = true } .sheet(isPresented: $isPresenting) { ChildView() } }}</p><p> struct ParentView：View {@State private var isPresenting：Bool = false var body：一些View {Button（“ Present View”）{self.isPresenting = true} .sheet（isPresented：$ isPresenting）{ChildView（）}}}</p><p> And the sheet modifier can actually be attached to multiple places in your view declaration — it has nothing to do with the button itself. Though not all of the following are preferable, they each function the same (at the time of writing this article):</p><p> 而且sheet修改器实际上可以附加到视图声明中的多个位置上，它与按钮本身无关。尽管并非所有以下选项都可取，但它们各自的功能相同（在撰写本文时）：</p><p> struct ParentView: View { @State private var isPresenting: Bool = false var body: some View { VStack { Spacer() Image(systemName: &#34;sunrise&#34;) Button(&#34;Present View&#34;) { self.isPresenting = true } Text(&#34;Tap to present a view modally&#34;) Spacer() } .sheet(isPresented: $isPresenting) { ChildView() } }}</p><p> struct ParentView：View {@State private var isPresenting：Bool = false var body：some View {VStack {Spacer（）Image（systemName：“ sunrise”）Button（“ Present View”）{self.isPresenting = true} Text（“轻按以模态显示视图。“）Spacer（）} .sheet（isPresented：$ isPresenting）{ChildView（）}}}</p><p> struct ParentView: View { @State private var isPresenting: Bool = false var body: some View { VStack { Spacer() Image(systemName: &#34;sunrise&#34;) .sheet(isPresented: $isPresenting) { ChildView() } Button(&#34;Present View&#34;) { self.isPresenting = true } Text(&#34;Tap to present a view modally&#34;) Spacer() } }}</p><p>struct ParentView：View {@State private var isPresenting：Bool = false var body：some View {VStack {Spacer（）Image（systemName：“ sunrise”）.sheet（isPresented：$ isPresenting）{ChildView（）} Button（“ Present View“）{self.isPresenting = true} Text（”点击以模态显示视图“）Spacer（）}}}</p><p>  The point is, if you&#39;re used to UIKit and other kinds of  imperative programming (as most of us are), presenting a view in this way feels pretty weird and unnatural.</p><p>  关键是，如果您习惯了UIKit和其他类型的命令式编程（就像我们大多数人一样），以这种方式呈现视图就感觉很奇怪和不自然。</p><p> And while this particular example might not seem like a huge deal,  thefeeling will compound as your app becomes more complicated and you find yourself attempting to implement less basic functionality.</p><p> 尽管这个特定示例可能看起来不算什么，但随着您的应用程序变得更加复杂，并且您发现自己尝试实现较少的基本功能，感觉会更加复杂。</p><p> I spent six months with SwiftUI on side projects before I considered using it in a production app. And I ran into all sorts of weird issues related to its declarative nature and beyond. It was only once I developed an intuition around it that I was able to take advantage of the gains in productivity it can offer.</p><p> 在考虑在生产应用程序中使用它之前，我在SwiftUI上进行了六个月的辅助项目。而且我遇到了各种与它的声明性及其他相关的怪异问题。直到我对它有了直觉，我才能够利用它所能提供的生产率提高。</p><p> If you&#39;re not there yet, you should avoid attempting to use SwiftUI on features or projects with significant time constraints. It can take many added hours to wrap your head around the paradigm shift necessary to implement non-trivial features. But once you do, it can allow you to blaze (for certain things) like never before.</p><p> 如果您还不在那里，则应避免尝试在时间紧张的功能或项目上使用SwiftUI。您可能需要花费更多的时间才能将头转向实现非平凡功能所需的范式转换。但是，一旦这样做，它就可以让您（在某些事情上）前所未有地燃烧。</p><p>  The other glaring problem with SwiftUI is that it&#39;s quite incomplete (and sometimes quirky), especially the version that supports iOS 13. So if you choose to use it in certain contexts, you&#39;re going to have to employ a number of workarounds to get some really basic UIKit functionality.</p><p>SwiftUI的另一个明显问题是它还很不完整（有时很古怪），特别是支持iOS 13的版本。因此，如果您选择在某些情况下使用它，则必须采用多种变通方法来获得。一些非常基本的UIKit功能。</p><p> Imagine you need to display a list of currencies in your app, for example. That&#39;s simple enough.</p><p> 假设您需要在应用程序中显示货币列表。这很简单。</p><p>  But what if you want the separator lines between rows to be inset so they start at the beginning of the text rather than the icon, as is the case in Settings and many other apps?  You can&#39;t. You also can&#39;t add a background image or color to the whole list, or other basics like custom swipe actions.  Well, strictly speaking you can, but you can&#39;t do so in a straightforward way. You&#39;ll need to employ workarounds using APIs like UIAppearance or a third-party tool like  Introspect that iterates the view hierarchy to find the UIKit view in question. And who knows what workarounds will break as iOS is updated.  On top of that, if you want a loading indicator ( UIActivityIndicatorView) or share sheet ( UIActivityViewController) or various other standard components, you&#39;ll need to port them yourself using  UIViewControllerRepresentable or  UIViewRepresentable. And that can get old after a while.  But with all that said, SwiftUI may still be a reasonable choice for your app. If you can bend on certain design requirements or are in a position you can take minor risks with some workarounds, the speed gains in development for certain kinds of apps might still outweigh all the quirks you&#39;ll run into. And if there&#39;s some view where you absolutely can&#39;t bend, you can still implement isolated views in UIKit and present them from SwiftUI. You&#39;re likely going to have to mix and match no matter what (e.g. for things like activity indicators), so it&#39;s not a stretch to have a handful of custom views that aren&#39;t purely SwiftUI anyway.</p><p>  但是，如果您希望插入行之间的分隔线，使它们从文本的开头而不是图标开始（在“设置”和许多其他应用中就是这种情况），该怎么办？你不能您也无法将背景图片或颜色添加到整个列表，也无法添加其他基本设置（例如自定义滑动操作）。好吧，严格来说，您可以，但是您不能直接做到这一点。您将需要使用诸如UIAppearance之类的API或诸如Introspect之类的第三方工具来采用变通方法，该工具会迭代视图层次结构以查找相关的UIKit视图。谁知道随着iOS更新，什么解决方法将失效。最重要的是，如果要加载指示器（UIActivityIndi​​catorView）或共享表（UIActivityViewController）或其他各种标准组件，则需要使用UIViewControllerRepresentable或UIViewRepresentable自己移植。一段时间后，它可能会变老。综上所述，SwiftUI仍然可能是您应用程序的合理选择。如果您可以满足某些设计要求，或者可以采取一些变通办法承担较小的风险，则某些类型的应用程序在开发方面的速度提升可能仍会超出您遇到的所有怪癖。而且，如果有某些视图您绝对不能弯曲，那么您仍然可以在UIKit中实现孤立的视图并从SwiftUI呈现它们。无论如何，您可能都不得不混合搭配（例如，对于活动指标之类的东西），因此拥有少量并非纯粹是SwiftUI的自定义视图并不是一件容易的事。</p><p>  In some cases, the views you build with SwiftUI will not be as performant as their UIKit counterparts. And this may or may not be ok depending on what you are trying to accomplish with your view.  For example, let&#39;s say you want to display a collection of items that scrolls horizontally like something you&#39;d see in Netflix or the Apple Music app:</p><p>  在某些情况下，使用SwiftUI构建的视图的性能将不如它们的UIKit。根据您要用视图完成的工作，这可能不行。例如，假设您要显示一组项目，这些项目可以像在Netflix或Apple Music应用程序中看到的那样水平滚动：</p><p>  You might consider a UICollectionView, which automatically recycles views that have moved off screen. But in order to do that, you&#39;d have to bring that to SwiftUI with UIViewRepresentable, which is doable but potentially time-consuming.  Alternatively, you can just use a scroll view with a horizontal stack as such:</p><p>  您可能会考虑使用UICollectionView，它会自动回收移出屏幕的视图。但是为了做到这一点，您必须使用UIViewRepresentable将其引入SwiftUI，这是可行的，但可能很耗时。或者，您可以仅使用带有水平堆栈的滚动视图，例如：</p><p> struct HorizontalCollection: View { /// The items to be displayed in the collection let items: [Item] var body: some View { ScrollView(.horizontal) { HStack { ForEach(items) { item in ItemView(item) } } } }}</p><p>struct Horizo​​ntalCollection：View {///要在集合中显示的项目让item：[Item] var body：一些View {ScrollView（.horizo​​ntal）{HStack {ForEach（items）{ItemView（item）中的项目}}}} }}</p><p> Unlike a collection view, all items will be loaded into memory at once. That means if you have 1k items, 1k views will live in memory upon load – which really sucks for performance. Even if you use a  LazyHStack, introduced in iOS 14, views will not be loaded until they appear, but they&#39;ll remain in memory thereafter.</p><p> 与收集视图不同，所有项目将立即加载到内存中。这意味着，如果您有1k项，则1k视图将在加载时驻留在内存中–确实会降低性能。即使您使用iOS 14中引入的LazyHStack，也不会在视图出现之前加载视图，但是此后它们将保留在内存中。</p><p> That said, if you only ever have a few, inexpensive items in your collection at a time, the simple SwiftUI approach may be totally justified. It may lead to no discernible impact on the UX or risk of iOS terminating your app due to memory overuse. On the other hand, if your collection is displaying a bunch of images or a large number of even seemingly inexpensive items, you may be obliged to rely on the out-of-the-box performance benefits of certain UIKit components.</p><p> 就是说，如果您一次只收集少量便宜的商品，那么简单的SwiftUI方法可能是完全合理的。它可能不会对UX产生明显影响，也不会由于内存使用过多而导致iOS终止应用程序的风险。另一方面，如果您的收藏集正在显示一堆图像或大量甚至看似便宜的物品，则您可能不得不依靠某些UIKit组件的开箱即用的性能优势。</p><p> The key is to be aware of the performance differences of the SwiftUI components you&#39;re considering using as early in your implementation as possible. If your app only has a few views that require something like a collection view, then the occasional UIViewRepresentable implementation may be the way to go. However, if most of your app requires lots of cell re-use and lazy loading with lots of nuanced customization, you may spend more time fighting SwiftUI than you would just using UIKit exclusively.</p><p> 关键是要意识到要尽早在实现中考虑使用的SwiftUI组件的性能差异。如果您的应用只有几个视图，需要像集合视图这样的视图，那么偶尔的UIViewRepresentable实现可能是可行的方法。但是，如果您的大多数应用程序需要大量的单元重用和延迟加载以及许多细微​​的自定义，则与专门使用UIKit相比，与SwiftUI战斗所花费的时间可能更多。</p><p>   There&#39;s always the risk that your implementation of some feature might break from one version of iOS to another. But with SwiftUI, the degree of such bugs seems to be a bit more dramatic.</p><p>   始终存在某些功能的实现可能会从一个版本的iOS中断到另一个版本的风险。但是，使用SwiftUI时，此类错误的程度似乎更加严重。</p><p> For example, I recently built one of my SwiftUI apps that was running perfectly on iOS 13 with Xcode 12, and a whole bunch of stuff broke, including two big items:</p><p>例如，我最近用Xcode 12构建了一个可以在iOS 13上完美运行的SwiftUI应用，其中一堆东西破了，其中包括两个大项目：</p><p> Modal views presented from the same screen were not correct. That is, the wrong view was being presented.</p><p> 从同一屏幕显示的模态视图不正确。也就是说，提出了错误的观点。</p><p> Turns out, SwiftUI re-implemented the way it presents and manages sheets. So the previous way of presenting and dismissing multiple modals from a single view no longer worked.</p><p> 事实证明，SwiftUI重新实现了其呈现和管理工作表的方式。因此，以前从单个视图呈现和消除多个模态的方法不再起作用。</p><p> struct ParentView: View { @State private var isPresenting: Bool = false @State private var current: PresentedViewOption var body: some View { VStack { Button(&#34;Present View 1&#34;) { self.current = .option1 self.isPresentingView = true } Button(&#34;Present View 2&#34;) { self.current = .option2 self.isPresentingView = true } Button(&#34;Present View 3&#34;) { self.current = .option3 self.isPresentingView = true } } .sheet(isPresented: $isPresentingView) { self.view(for: current) } } ... }</p><p> struct ParentView：视图{@State私有var isPresenting：Bool = false @State私有var当前：PresentedViewOption var主体：一些视图{VStack {Button（“ Present View 1”）{self.current = .option1 self.isPresentingView = true} Button（“ Present View 2”）{self.current = .option2 self.isPresentingView = true} Button（“ Present View 3”）{self.current = .option3 self.isPresentingView = true}} .sheet（isPresented：$ isPresentingView ）{self.view（for：current）}} ...}</p><p> With the above code, neither the &#34;isPresenting&#34; nor the &#34;selection&#34; state variables were being updated as expected, so I had to instead re-implement the code with a different sheet modifier and tweak the way I passed the state to the subviews.</p><p> 使用上面的代码，“ isPresenting”和“ selection”状态变量都没有按预期进行更新，因此我不得不改用另一个工作表修饰符重新实现代码，并调整将状态传递给子视图的方式。</p><p>  Because my app was relatively small, it only took me a few hours to go through and fix all the bugs for both iOS 13 and iOS 14. But if your app is large with a substantial number of views (and developers), the cost and complexity of these kinds of fixes might not be acceptable for your constraints (at least at this stage in the evolution of SwiftUI).</p><p>由于我的应用程序相对较小，因此只花了几个小时就解决了iOS 13和iOS 14的所有错误。但是，如果您的应用程序很大且具有大量视图（和开发人员），则成本和对于您的约束来说，这类修复程序的复杂性可能是不可接受的（至少在SwiftUI演变的这一阶段）。</p><p>  It almost goes without saying that SwiftUI supports only iOS 13 and above. So anything you integrate into your app that uses the framework will not run on users with older versions of iOS.</p><p>  毋庸置疑，SwiftUI仅支持iOS 13及更高版本。因此，使用该框架集成到您的应用程序中的任何内容都无法在使用旧版iOS的用户上运行。</p><p> As of June 2020,  Apple Reports that 92% of  devices introduced in the last 4 years use iOS 13, while 81% of  all devices (including the oldest) use iOS 13. Some businesses are not willing to part with that remaining 8%-19% of users.</p><p> 截至2020年6月，Apple报告称，过去4年内推出的设备中有92％使用iOS 13，而所有设备（包括最旧的设备）中有81％使用iOS 13。 19％的用户。</p><p> While this is fundamentally a business decision, it’s our job as developers to inform the stakeholders and product managers of the time and cost implications of choosing one option or another. While 8%-19% of users is absolutely significant, you need to compare that with the costs and time implications of supporting those users. There are many cases in which the added expense outweighs the benefit. For example, if you’re an early adopters with a small team and limited budget, getting to MVP for fewer users can vastly outweigh the importance of attracting every possible user early on, especially if choice of technology makes development materially faster.</p><p> 尽管这从根本上来说是一项商业决策，但作为开发人员，我们的职责是告知利益相关者和产品经理选择一个或多个选项所花费的时间和成本。虽然8％-19％的用户绝对重要，但您需要将其与支持这些用户的成本和时间影响进行比较。在许多情况下，增加的费用超过收益。例如，如果您是团队规模较小且预算有限的早期采用者，则以较少的用户获得MVP可能远远超过了尽早吸引每个可能的用户的重要性，尤其是在技术选择使开发速度大大提高的情况下。</p><p>  Finally, while this was mentioned throughout the above considerations, it’s worth addressing directly.</p><p>  最后，尽管以上考虑因素都提到了这一点，但值得直接解决。</p><p> ‍ You have control over how much SwiftUI you use in a given app, and you can always fall back to UIKit when needed. And your options fall into essentially two categories, each with their own risk profiles.</p><p>您可以控制在给定应用程序中使用多少SwiftUI，并且始终可以在需要时使用UIKit。您的选择权实际上分为两类，每类都有自己的风险特征。</p><p>  This is the lowest risk way to engage with SwiftUI in your production apps. UIHostingController allows you to layout individual views and view controllers in SwiftUI and present them back in UIKit just as you would any other view or view controller. This is a great way to take advantage of SwiftUI benefits without being subject to as many quirks as you would otherwise.</p><p>  这是在生产应用中使用SwiftUI的最低风险方法。 UIHostingController允许您在SwiftUI中布局各个视图和视图控制器，并像在任何其他视图或视图控制器中一样将它们呈现回UIKit。这是一种充分利用SwiftUI好处的好方法，而无需像以前那样受到许多怪癖的困扰。</p><p> The only caveat here is time constraints if you’re totally new to SwiftUI. Some items will take a long time to implement before you’ve internalized the declarative structure, and may lead to seemingly inexplicable bugs or crashes that will take more time to figure out. Work through things like this on your own time on projects where deadlines are loose. Until you’ve reached a certain level of familiarity, introducing it into even one feature might lead to unexpected setbacks.</p><p> 如果您是SwiftUI的新手，这里唯一需要注意的是时间限制。在内部化声明式结构之前，某些项目需要花费很长时间才能实施，并且可能导致看似莫名其妙的错误或崩溃，从而需要更多时间才能弄清。在期限有限的项目上，您可以自己按时完成类似的工作。在您达到一定程度的熟悉度之前，即使将其引入一项功能也可能会导致意外的挫折。</p><p> For example, let’s say you have a UITableView for which you’d like to use SwiftUI just for the cell layouts. This is technically doable, and SwiftUI makes the layout code way simpler than dealing with autolayout constraints. So you go ahead and implement it, and wrap your SwiftUI view in a UIHostingController to instantiate it from your UIKit code.  The problem is re-use. You only have programmatic access to the SwiftUI initializer and the view auto-generated by the UIHostingController. So how do you change the underlying view without instantiating it every time a cell is dequeued? Not sure you even can in a non-hacky way, so you might end up scrapping your SwiftUI view and using auto-layout anyway.</p><p> 例如，假设您有一个UITableView，您只想为其单元格布局使用SwiftUI。从技术上讲这是可行的，并且SwiftUI使布局代码比处理自动布局约束更简单。因此，您继续实现它，并将SwiftUI视图包装在UIHostingController中，以从UIKit代码中实例化它。问题是重用。您只能以编程方式访问SwiftUI初始化程序以及UIHostingController自动生成的视图。那么，如何在每次单元出队时不实例化基础视图而更改基础视图？不知道您是否可以以非骇客的方式使用它，因此您最终可能会废弃SwiftUI视图并仍然使用自动布局。</p><p> You want to run into problems like this in your free time, not when you have a deadline hanging over your head!</p><p> 您想在空闲时间遇到这样的问题，而不是在最后期限悬而未决的时候！</p><p>  Any app that is going to make it to production is likely going to need to reference UIKit at some point. As I mentioned before, native SwiftUI implementations of basics like a loading indicator and share sheet require referring to UIKit, and there may be times where performance-tuned components are needed for acceptable scrolling and memory usage. Unless your app is exceedingly simple, it’s unlikely to be purely SwiftUI no matter what.</p><p>任何将要投入生产的应用都可能在某个时候需要引用UIKit。如前所述，SwiftUI的基本实现（例如加载指示器和共享表）需要参考UIKit，并且有时可能需要性能优化的组件才能实现可接受的滚动和内存使用。除非您的应用程序非常简单，否则无论如何它都不可能纯粹是SwiftUI。</p><p> And because of  UIViewControllerRepresentable and  UIViewRepresentable you get to reap the benefits of UIKit as much as you need. But again, you should wait until you’ve reached a certain level of experience with SwiftUI before making it the basis of your app, and ensure your design requirements aren’t so nuanced that it wouldn’t be worth your time to deal with the quirks of SwiftUI at all. At this point, smaller apps with smaller teams are more likely to be ok using SwiftUI, while more complex, larger apps with rich design requirements are probably safer resting on a foundation of UIKit.</p><p> 而且由于有了UIViewControllerRepresentable和UIViewRepresentable，您可以根据需要获得UIKit的好处。但是同样，您应该等到对SwiftUI有了一定的经验，然后再将其作为应用程序的基础，并确保您的设计要求没有那么细微的差别，以致您不值得花时间来处理完全是SwiftUI的怪癖。在这一点上，具有较小团队的较小应用程序更可能使用SwiftUI，而更复杂，具有丰富设计要求的较大应用程序可能更安全地基于UIKit。</p><p>  I personally love using SwiftUI. The declarative style, easy composition of views, cross-platform reach, and various other features make the development of lots of types of views extremely simple, elegant, and fast. I like it so much that I’m willing to put up with what seems like a ton of quirks, even in some production apps, as the framework matures and the ongoing hiccups are reduced.</p><p>  我个人喜欢使用SwiftUI。声明式的样式，易于组合的视图，跨平台访问以及各种其他功能，使许多类型的视图的开发变得极为简单，优雅和快速。我非常喜欢它，以至于随着框架的成熟和不断减少的麻烦，即使在某些生产应用中，我也愿意忍受很多怪癖。</p><p> In a current production app pending release, nearly the entire app is written in SwiftUI. I’ve run into a number of the problems I mentioned above, but for me, as someone who has already undergone the mental paradigm shift, the productivity gains were worth the minor setbacks, which really weren’t so hard to fix. That said, this is for a relatively small app seeking early product-market fit. If you already have millions of users, elaborate features and a large team, adding SwiftUI in the mix might be more headache than it’s worth. You need to weigh the nuances for yourself and the risks your business can tolerate.</p><p> 在当前的生产应用程序即将发布的版本中，几乎整个应用程序都是用SwiftUI编写的。我遇到了上面提到的许多问题，但是对于我来说，作为一个已经经历了思维模式转变的人，生产率的提高值得一小笔挫折，而这实际上并不难解决。也就是说，这是针对寻求早期产品市场适应性的相对较小的应用程序。如果您已经拥有数百万的用户，精致的功能和庞大的团队，那么将SwiftUI添加到其中可能会比值得的事更加头痛。您需要权衡自己的细微差别和企业可以承受的风险。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://triplebyte.com/blog/should-i-use-swiftui-in-production-heres-how-to-decide?ref=hnpost">https://triplebyte.com/blog/should-i-use-swiftui-in-production-heres-how-to-decide?ref=hnpost</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应该/">#应该</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/视图/">#视图</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>