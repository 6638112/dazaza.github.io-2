<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你好，七种量子语言中的许多世界（2021年）Hello Many Worlds in Seven Quantum Languages (2021)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hello Many Worlds in Seven Quantum Languages (2021)<br/>你好，七种量子语言中的许多世界（2021年）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 14:42:31</div><div class="page_narrow text-break page_content"><p>The incredible promise of quantum computing—to revolutionize industry, to tackle humanity’s most complex problems—is increasingly a point of consensus across academia, commerce, and government. But so, too, is the appreciation of the distance between where we are today and where we aspire to be tomorrow.</p><p>量子计算给工业带来革命性变革、解决人类最复杂问题的惊人前景，正日益成为学术界、商业界和政府的共识。但同样重要的是，我们对我们今天所处的位置和我们希望明天所处的位置之间的距离的欣赏。</p><p>  To cross that distance, we have a choice: to build moats and walls around cutting-edge quantum computer resources, or to build bridges, to meet people where they are, to bring the world-changing potential of quantum computing to as many people as possible. At IonQ, we believe strongly in making sure that everyone that wants to work on advancing the state-of-the-art in our emerging field has the ability to access great hardware, using whatever tools they find best suited to their needs. We believe the paradigm-shattering quantum app is as likely to come from a kid in a garage as it is from a corporate research park.</p><p>要跨越这段距离，我们有一个选择：围绕尖端量子计算机资源建造护城河和围墙，或者建造桥梁，在人们所在的地方与他们见面，将量子计算改变世界的潜力带给尽可能多的人。在IonQ，我们坚信，要确保所有想要在我们新兴领域提升最先进水平的人都有能力使用最适合自己需求的工具，访问优秀的硬件。我们相信，打破范式的quantum应用程序很可能来自车库里的一个孩子，就像来自企业研究园一样。</p><p>  Just a few years ago, quantum computers only had two or three qubits, and programs for these machines were lovingly hand-crafted by physics graduate students in a lab in the basement of a university building. The only tools available to program these were patched-together code, handed down from grad student to grad student, that still treated these devices more as physics experiments than computational tools.</p><p>就在几年前，量子计算机只有两三个量子位，而这些机器的程序是由物理学研究生在一所大学大楼地下室的实验室里精心编制的。编程这些设备的唯一工具是拼凑起来的代码，由一个研究生传给另一个研究生，这些代码仍然把这些设备更多地视为物理实验，而不是计算工具。</p><p>  But today, as quantum computers with dozens of qubits are being built, and systems with hundreds or even thousands of qubits are on the horizon, the complexity of programming a quantum computer requires a more structured approach. This has led to the birth of a large number of quantum programming frameworks and languages, ranging from fully-fledged programming languages like Microsoft’s Q#, to Python frameworks like IBM’s Qiskit, to basic assembly languages like QASM.</p><p>但今天，随着数十个量子比特的量子计算机的建造，数百甚至数千个量子比特的系统即将问世，量子计算机编程的复杂性需要一种更结构化的方法。这导致了大量量子编程框架和语言的诞生，从微软的Q#等成熟的编程语言，到IBM的Qiskit等Python框架，再到QASM等基本汇编语言。</p><p>  Anyone can use these software packages to run simulations from their own computer, but the real value comes in using these languages to run quantum programs on actual quantum hardware.</p><p>任何人都可以使用这些软件包在自己的计算机上运行模拟，但真正的价值在于使用这些语言在实际的量子硬件上运行量子程序。</p><p>  To that end, we’re happy to announce that, with the addition of ProjectQ to our supported libraries, you can now access IonQ hardware using every major quantum framework and language. In celebration, here’s a basic quantum program the quantum version of a “Hello World” program — a ”Hello Many Worlds,” if you will —in seven of the platforms that enable remote execution on IonQ quantum computers.</p><p>为此，我们很高兴地宣布，随着ProjectQ加入到我们支持的库中，您现在可以使用每个主要的quantum框架和语言访问IonQ硬件。为了庆祝，这里有一个基本的量子程序——量子版的“Hello World”程序——“Hello Many Worlds”，如果你愿意的话——在七个平台上实现了IonQ quantum计算机上的远程执行。</p><p>  Harness the power of trapped-ion quantum computing, no matter what cloud, language or SDK you use.</p><p>利用量子计算的力量，无论你使用什么云、语言或SDK。</p><p>  Get started  Read the docs</p><p>开始阅读文档</p><p>    The basic quantum program we’ll write is simple. It creates a fully-entangled state between two qubits, and then measures this state. This state is sometimes called a   Bell State, or  Bell Pair, after physicist John Stewart Bell.</p><p>我们要写的基本量子程序很简单。它在两个量子位之间产生一个完全纠缠态，然后测量这个态。这种状态有时被称为钟态，或钟对，以物理学家约翰·斯图尔特·贝尔的名字命名。</p><p>  The measurement results for this program should give us 0 for both qubits or 1 for both qubits, in equal amounts. When running these, we’ll be able to tell that we’re running on real hardware because that’s not always what we get! These errors are what currently limit quantum computers, but the first steps to overcome this with quantum error correction have already begun.</p><p>这个程序的测量结果应该给出两个量子位的0或两个量子位的1，数量相等。当运行这些时，我们将能够分辨出我们是在真正的硬件上运行的，因为这并不总是我们得到的！这些错误是目前限制量子计算机的因素，但通过量子错误校正克服这一问题的第一步已经开始。</p><p>    IBM’s  Qiskit was one of the first frameworks for programming quantum computers. It provides robust tools for writing quantum programs in python, as well as a variety of additional packages for working with quantum hardware, running common algorithms, and more. Qiskit has a large body of educational materials for learning quantum computing, including an entire  textbook that is a great place for quantum beginners to start learning about this field.</p><p>IBM的Qiskit是最早的量子计算机编程框架之一。它提供了用python编写量子程序的强大工具，以及用于使用量子硬件、运行通用算法等的各种附加包。Qiskit有大量学习量子计算的教材，包括一整本教科书，这是量子初学者开始学习这个领域的好地方。</p><p>  Qiskit can be used to run quantum programs against IonQ’s trapped ion quantum computers using our recently announced integration with  Google Cloud Marketplace. If you haven’t signed up yet,  these instructions will walk you through that process, and  this guide will help you obtain an API key for accessing the IonQ service to run quantum programs. We call this API key  API_KEY below — if you’re following along with this guide, be sure to replace that with a real key, or the programs won’t run!</p><p>使用我们最近宣布的与Google Cloud Marketplace的集成，Qiskit可以用来运行针对IonQ被困离子量子计算机的量子程序。如果您尚未注册，这些说明将引导您完成该过程，本指南将帮助您获得访问IonQ服务以运行quantum程序的API密钥。下面我们将此API密钥称为API_密钥——如果您按照本指南进行操作，请确保使用真正的密钥替换它，否则程序将无法运行！</p><p>  First let’s create the quantum circuit that creates an entangled Bell pair and measures it in Qiskit — you’ll need the  qiskit and  qiskit_ionq python packages installed before you begin.</p><p>首先，让我们创建一个量子电路，创建一个纠缠钟形对，并在Qiskit中测量它——在开始之前，您需要安装Qiskit和Qiskit_ionq python包。</p><p>  from qiskit import QuantumCircuit# Create a basic Bell State.qc = QuantumCircuit(2, 2) # 2 qubits, 2 bitsqc.h(0)qc.cx(0, 1)# Measure and put the result into the two bits.qc.measure([0, 1], [0, 1])# Display circuit.print(qc)</p><p>从qiskit import QuantumCircuit#创建一个基本的钟形状态。qc=量子电路（2，2）#2个量子位，2个比特SQC。h（0）qc。cx（0，1）#测量并将结果放入两位。qc。测量（[0,1]，[0,1]）#显示电路。打印（qc）</p><p>    ┌───┐ ┌─┐ q_0: ┤ H ├──■──┤M├─── └───┘┌─┴─┐└╥┘┌─┐q_1: ─────┤ X ├─╫─┤M├ └───┘ ║ └╥┘c: 2/═══════════╩══╩═ 0 1</p><p>┌───┐ ┌─┐ 问题0：┤ H├──■──┤M├─── └───┘┌─┴─┐└╥┘┌─┐问题1：─────┤ 十、├─╫─┤M├ └───┘ ║ └╥┘c:2/═══════════╩══╩═ 0 1</p><p>  To run this circuit on an IonQ Quantum Processing Unit ( QPU for short), you need to first get the QPU backend from the IonQ Provider:</p><p>要在IonQ Quantum处理单元（简称QPU）上运行此电路，首先需要从IonQ提供程序获取QPU后端：</p><p>    Then one sends the job to run on the qubit and waits for the job to be run from the queue of jobs on the IonQ service.</p><p>然后，发送作业以在量子位上运行，并等待作业从IonQ服务上的作业队列中运行。</p><p>  from qiskit.providers.jobstatus import JobStatusimport time# Submit the job for execution.qpu_job = qpu.run(qc, shots=1000)# Check if the job is done.while qpu_job.status() is not JobStatus.DONE:print(&#34;Job status is&#34;, qpu_job.status() )time.sleep(60)# Grab a coffee! This can take up to a few minutes.print(&#34;Job status is&#34;, qpu_job.status() )print(qpu_job.get_counts())</p><p>来自qiskit。提供者。jobstatus导入jobstatus导入时间#提交作业以供执行。qpu_job=qpu。运行（qc，放炮次数=1000）#检查工作是否完成。而qpu_工作。status（）不是JobStatus。完成：打印（&#34；作业状态为&#34；，qpu#u Job.status（））时间。睡觉（60）#喝杯咖啡！这可能需要几分钟的时间。打印（&#34；作业状态为&#34；，qpu#u Job.status（））打印（qpu#u Job.get#u counts（））</p><p>  Job status is JobStatus.QUEUEDJob status is JobStatus.QUEUEDJob status is JobStatus.DONE{&#39;00&#39;: 513, &#39;01&#39;: 6, &#39;10&#39;: 4, &#39;11&#39;: 477}</p><p>Job status就是JobStatus。QUEUEDJob状态是JobStatus。QUEUEDJob状态是JobStatus。完成{&#39；00&#39；：513，&#39；01&#39；：6，&#39；10&#39；：4，&#39；11&#39；：477}</p><p>      Our ideal outcome is 00: 512, 11: 512. The results we got are mostly correct, but like we said earlier, they’re not all correct because of the computational noise that comes from running on real hardware.</p><p>我们的理想结果是00:512，11:512。我们得到的结果基本上是正确的，但正如我们之前所说的，由于在真实硬件上运行时产生的计算噪音，它们并不都是正确的。</p><p>    Microsoft has a long history of writing their own programming languages, a history they’ve continued with quantum. Their offering for running quantum computations comes is in the form of an entire language, called Q#.</p><p>微软在编写自己的编程语言方面有着悠久的历史，他们在quantum上延续了这段历史。他们提供的运行量子计算的服务是一种完整的语言，称为Q#。</p><p>  Using Q#, anyone with an account on Microsoft’s cloud service  Azure Quantum can run against IonQ’s quantum computers. See  these instructions for getting started on Azure Quantum. In this example we assume that you’ve already set up an Azure Quantum account and quantum workspace.</p><p>使用Q#，任何在微软云服务Azure Quantum上拥有帐户的人都可以与IonQ的Quantum计算机竞争。有关Azure Quantum的入门信息，请参阅以下说明。在本例中，我们假设您已经设置了Azure Quantum帐户和Quantum工作区。</p><p>  First let’s write the actual quantum program. Q# is written in a C-like dialect that should look familiar to anyone that’s written C# or similar:</p><p>首先，让我们编写实际的量子程序。Q#是用类似C的方言写的，任何写C#或类似语言的人都应该很熟悉：</p><p>  namespace Bell { open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; operation MeasureEntanglement() : Result[] { use qubits = Qubit[2]; H(qubits[0]); CNOT(qubits[0], qubits[1]); return MultiM(qubits); }}</p><p>名称空间Bell{open Microsoft.Quantum.infrant；open Microsoft.Quantum.Measurement；operation MeasureEntanglement（）：结果[]{use qubits=Qubit[2]；H（qubits[0]）；CNOT（qubits[0]，qubits[1]）；return multi（qubits）；}</p><p>  Save this in a file called  Operation.qs and then in the same directory, create a Python file to run this program. You can also use Azure’s  az command line interface to do this — see the above-linked guide for more details — but we find using python a little easier to set up for demo purposes.</p><p>将其保存在名为Operation的文件中。qs，然后在同一个目录中，创建一个Python文件来运行这个程序。您也可以使用Azure的az命令行界面来实现这一点——有关更多详细信息，请参阅上面的链接指南——但我们发现，出于演示目的，使用python更容易设置。</p><p>  import qsharpimport qsharp.azurefrom Bell import MeasureEntanglementqsharp.azure.connect( resourceId=&#34;the name of your quantum resource&#34;, location=&#34;East US&#34;,)qsharp.azure.target(&#34;ionq.qpu&#34;)result = qsharp.azure.execute(MeasureEntanglement, shots=1000, jobName=&#34;Bell&#34;)print(result)</p><p>导入qsharp导入qsharp。Azure来自Bell import MeasureEntanglementqsharp。蔚蓝色的连接（resourceId=&#34；量子资源的名称&#34；，位置=&#34；美国东部&#34；）qsharp。蔚蓝色的目标（&#34；ionq.qpu&#34；）结果=qsharp。蔚蓝色的执行（MeasureEntanglement，shots=1000，jobName=&#34；Bell&#34；）打印（结果）</p><p>  {‘[0, 0]’: 0.50, ‘[1, 1]’: 0.48, ‘[0, 1]’: 0.02}</p><p>{‘[0, 0]’: 0.50, ‘[1, 1]’: 0.48, ‘[0, 1]’: 0.02}</p><p>  Note that unlike the previous example, these are returned as a histogram of measurement  probabilities; the percentage of our 1000 shots that ended up as each state. This is the other common way you’ll see quantum circuit output represented.</p><p>请注意，与前一个示例不同，它们是作为测量概率直方图返回的；每一个州的1000次注射中的百分比。这是另一种常见的表示量子电路输出的方式。</p><p>    Braket is Amazon’s quantum computing service, which includes a python-based SDK for creating and submitting quantum programs. To run a job on Braket you will need an AWS account on, and have  installed the Amazon braket sdk. Additionally, you’ll need to have set up an s3 bucket to store your results. There are more Braket setup details in  our full Braket guide.</p><p>Braket是亚马逊的量子计算服务，包括一个基于python的SDK，用于创建和提交量子程序。要在Braket上运行作业，您需要在上安装AWS帐户，并已安装Amazon Braket sdk。此外，您还需要设置一个s3存储桶来存储结果。在我们完整的Braket指南中有更多的Braket设置细节。</p><p>      Which prints out our same friendly little quantum circuit — even though the formatting is different here, the circuit is the same!</p><p>它打印出了我们同样友好的小量子电路——尽管这里的格式不同，但电路是一样的！</p><p>    Now let’s get the ionq device and setup the our S3 bucket information:</p><p>现在，让我们获取ionq设备并设置S3存储桶信息：</p><p>  device = AwsDevice(&#34;arn:aws:braket:::device/qpu/ionq/ionQdevice&#34;)# Enter the name of S3 bucket you created earliermy_bucket = &#34;amazon-braket-Your-Bucket-Name&#34; # the name of the bucketmy_prefix = &#34;Your-Folder-Name&#34; # the name of the folder in the buckets3_folder = (my_bucket, my_prefix)</p><p>设备=AwsDevice（&#34；arn:aws:braket:：：设备/qpu/ionq/ionQdevice&#34；）#输入您之前创建的S3 bucket的名称my_bucket=&#34；亚马逊braket你的桶名&#34；#bucketmy_前缀的名称=&#34；你的文件夹名&#34；#buckets3_文件夹中文件夹的名称=（my_bucket，my_前缀）</p><p>          Cirq is an open source Python framework for quantum programming developed by a team at Google. Cirq can be used to run quantum programs against IonQ’s trapped ion quantum computers using our recently announced integration with Google Cloud Marketplace. And since Cirq is developed by Google, this is of course, the most synergistic way to run on GCM.</p><p>Cirq是一个开源Python框架，由谷歌的一个团队开发，用于量子编程。使用我们最近宣布的与Google Cloud Marketplace的集成，Cirq可以用来运行针对IonQ被困离子量子计算机的量子程序。由于Cirq是由谷歌开发的，这当然是在GCM上运行的最具协同性的方式。</p><p>  You can use  these instructions to get started on GCM, and  this guide will help you obtain an API key for accessing the IonQ service. Again, we call this API key  API_KEY below, but if you’re following along with this guide, be sure to replace that with a real key!</p><p>您可以使用这些说明开始使用GCM，本指南将帮助您获取访问IonQ服务的API密钥。同样，我们在下面将此API密钥称为API_密钥，但如果您遵循本指南，请务必用真正的密钥替换它！</p><p>  Again, we&#39;ll start by first creating the circuit for our Bell pair and printing it, which produces another nice ascii diagram:</p><p>再一次，我们&#39；我首先为我们的钟对创建电路并打印它，这会生成另一个漂亮的ascii图：</p><p>    0: ───H───@───M(&#39;b&#39;)─── │ │1: ───────X───M────────</p><p>0: ───H───@───M（&#39；b&#39；）─── │ │1: ───────十、───M────────</p><p>    To run on IonQ hardware, create a  ionq.Service object, authenticate with your API key, and run against the  Service:</p><p>要在IonQ硬件上运行，请创建一个IonQ。服务对象，使用API密钥进行身份验证，并针对服务运行：</p><p>  import cirq.ionq as ionq# Create a ionq.Service object.service = ionq.Service(api_key=API_KEY)# Run a program against the service.result = service.run(circuit=qc, repetitions=1000, target=&#39;qpu&#39;)# The return object of the ru is a cirq.Result object.# From this object you can get a histogram of results.histogram = result.histogram(key=&#39;b&#39;)print(f&#39;Histogram: {histogram}&#39;)</p><p>进口cirq。ionq as ionq#创建一个ionq。服务对象。服务=ionq。服务（api_key=api_key）#针对该服务运行程序。结果=服务。运行（电路=质量控制，重复次数=1000，目标=&#39；qpu&#39；）#ru的返回对象是cirq。结果对象从这个对象可以得到结果的直方图。直方图=结果。直方图（键=&#39；b&#39；）打印（f&#39；直方图：{Histogram}&#39；）</p><p>    Here we see another common output pattern in quantum languages and SDKs: our bitstrings are represented in their integer format, where  11 is represented as  3,  10 as  2, and so-on.</p><p>这里我们看到了量子语言和SDK中另一种常见的输出模式：我们的位字符串以整数格式表示，其中11表示为3，10表示为2，依此类推。</p><p>    Pennylane is a bit different from the previous frameworks, as it’s primarily focused on quantum machine learning, not just basic circuit synthesis. Still, we can use it in a form that allows us to create a Bell pair like in the previous examples.</p><p>Pennylane与之前的框架有些不同，因为它主要关注量子机器学习，而不仅仅是基本的电路合成。尽管如此，我们仍然可以使用它来创建一个钟形对，就像前面的例子一样。</p><p>  Start by using a terminal to create an environment variable called  IONQ_API_KEY with your API key — if you’re skimming around, the Cirq and Qiskit examples explain in more detail how to get a key.</p><p>首先，使用终端创建一个名为IONQ_API_KEY的环境变量，并使用您的API密钥——如果您正在浏览，Cirq和Qiskit示例将更详细地解释如何获取密钥。</p><p>  Once we’ve set our api key in the environment, the following short snippet of code creates and runs our Bell pair.</p><p>一旦我们在环境中设置了api密钥，下面的代码片段将创建并运行我们的Bell对。</p><p>  import collectionsimport pennylane as qmlfrom pennylane_ionq import opsdev = qml.device(&#34;ionq.qpu&#34;, wires=2, shots=1000)@qml.qnode(dev)def circuit(): qml.Hadamard(wires=0) qml.CNOT(wires=[0, 1]) return qml.probs(wires=[0, 1])results = collections.Counter(dict(enumerate(circuit().tolist())))print(results)</p><p>导入集合将pennylane作为qmlfrom pennylane_ionq import optsdev=qml导入。设备（&#34；ionq.qpu&#34；，连线=2，放炮=1000）@qml。qnode（dev）def circuit（）：qml。阿达玛（导线=0）qml。CNOT（连线=[0，1]）返回qml。probs（wires=[0,1]）results=集合。计数器（dict）枚举（circuit（）。打印（结果）</p><p>      ProjectQ is an open source quantum programming framework developed out of ETH Zurich. One cool thing about this framework is that it has many optimizations useful for  emulation: that is, mimicking the action of large  oracles in simulating quantum systems without needing to compile these to low level gates. More details on getting started with ProjectQ and IonQ  can be found here.</p><p>ProjectQ是一个开源量子编程框架，由苏黎世ETH开发。这个框架有一个很酷的地方，那就是它有许多对仿真有用的优化：也就是说，在模拟量子系统时模仿大型预言机的动作，而不需要将它们编译成低级门。更多关于ProjectQ和IonQ入门的详细信息可以在这里找到。</p><p>  Like our other SDKs, we can also use it to create and measure a Bell pair.</p><p>像我们的其他SDK一样，我们也可以使用它来创建和测量钟形对。</p><p>  First we need to create an  engine for executing circuits on IonQ hardware using our api key:</p><p>首先，我们需要创建一个引擎，使用api密钥在IonQ硬件上执行电路：</p><p>  import projectq.setups.ionqfrom projectq import MainEnginefrom projectq.backends import IonQBackend# Set your IonQ API tokentoken = API_KEY# Create and IonQ backend and respective compilers:device = &#39;ionq_qpu&#39;backend = IonQBackend( verbose=True, token=token, device=device, num_runs=1000,)compilers = projectq.setups.ionq.get_engine_list( token=token, device=device,)# Create the main engine:engine = MainEngine(backend, engine_list=compilers)</p><p>导入项目Q。设置。从projectq导入主引擎从projectq导入。后端导入IonQBackend#设置你的IonQ API tokentoken=API#密钥#创建和IonQ后端以及相应的编译器：device=&#39；ionq_qpu和#39；backend=IonQBackend（verbose=True，token=token，device=device，num_runs=1000，）compilers=projectq。设置。ionq。获取引擎列表（令牌=令牌，设备=设备，）#创建主引擎：引擎=主引擎（后端，引擎列表=编译器）</p><p>  Now let’s create our Bell pair. ProjectQ uses the pipe operator `|` to apply gates to qubits.</p><p>现在，让我们创建一对钟。ProjectQ使用管道操作符“|”将门应用于量子位。</p><p>  from projectq.ops import All, H, CNOT, Measure# Define a function to apply a bell state using a ProjectQ enginedef bell_state(eng): # Allocate two qubits circuit = eng.allocate_qureg(2) q0, q1 = circuit # Create a Bell pair and measure it. H | q0 CNOT | (q0, q1) All(Measure) | circuit # flushing submits the circuit to IonQ&#39;s API eng.flush() # Now, return the job results return eng.backend.get_probabilities(circuit)# Apply the bell state circuit to our engineprobs = bell_state(engine)print(probs)</p><p>来自projectq。ops import All，H，CNOT，Measure#定义一个函数，使用ProjectQ enginedef bell_state（eng）应用一个bell状态：#分配两个量子位circuit=eng.Allocate_qreg（2）q0，q1=circuit#创建一个bell对并测量它。H | q0 CNOT |（q0，q1）All（Measure）| circuit#flushing将电路提交给IonQ&#39；s API eng.flush（）#现在，返回作业结果return eng.backend。获取_概率（电路）#将钟形状态电路应用于我们的引擎probs=钟形状态（引擎）打印（probs）</p><p>        Pytket is a python toolkit for quantum programming developed by Cambridge Quantum Computing, an extension of their larger tket toolchain.</p><p>Pytket是剑桥量子计算公司（Cambridge quantum Computing）开发的用于量子编程的python工具包，是其更大的tket工具链的扩展。</p><p>        Once we have our circuit built, all that&#39;s left is to create a backend, compile the circuit for the backend, and then running it.</p><p>一旦我们的电路建成，所有这些&#39；左边是创建一个后端，为后端编译电路，然后运行它。</p><p>        Last but not least,  XACC is a framework for hybrid quantum / classical architectures. XACC was produced by a team at Oak Ridge National Lab, and has support for a large number of compilers, simulators, and quantum hardware. Let’s use it to create our now-familiar Bell pair.</p><p>最后但并非最不重要的一点是，XACC是一个混合量子/经典体系结构的框架。XACC由橡树岭国家实验室的一个团队生产，并支持大量编译器、模拟器和量子硬件。让我们用它来创建我们现在熟悉的钟对。</p><p>  import xaccionq = xacc.getAccelerator(&#39;ionq:qpu&#39;)compiler = xacc.getCompiler(&#34;xasm&#34;)ir = compiler.compile(r&#34;&#34;&#34;__qpu__ void hellobell(qbit q) { H(q[0]); CX(q[0], q[1]); Measure(q[0]); Measure(q[1]);} &#34;&#34;&#34;, ionq)buffer = xacc.qalloc(2)r = ionq.execute(buffer, ir.getComposite(&#34;hellobell&#34;))results = buffer.getMeasurementCounts()print(results)</p><p>导入xaccionq=xacc。getAccelerator（&#39；ionq:qpu&#39；）编译器=xacc。getCompiler（&#34；xasm&#34；）ir=编译器。编译（r&#34；&#34；&#34；#qpu__;void hellobell（qbit q）{H（q[0]）；CX（q[0]，q[1]）；度量（q[0]）；度量（q[1]）&#34;&#34;&#34;, ionq）buffer=xacc。qalloc（2）r=ionq。执行（buffer，ir.getComposite（&#34；hellobell&#34；）结果=缓冲区。getMeasurementCounts（）打印（结果）</p><p>        There you have it, seven ways to say “Hello Many Worlds” across seven quantum SDKs (and three cloud providers)!</p><p>这就是七个量子SDK（和三个云提供商）的七种“你好，许多世界”的方式！</p><p>  We’re proud to be able to provide hardware access to all of them — no matter what tools you want to use to come up with the next great breakthrough in quantum computing, you can use them with IonQ hardware.</p><p>我们很自豪能够提供对所有这些工具的硬件访问——无论你想使用什么工具来实现量子计算的下一个重大突破，你都可以将它们与IonQ硬件一起使用。</p><p>  If you&#39;re interested in working on your own tools to interact with the API, the full  API Reference has details on HTTP verbs and endpoints, expected response formats, and other features not covered in this guide. We’d also be happy to help if and when you run into any issues — reach out to us using  our contact form, our  twitter, or the  support center.</p><p>如果你&#39；如果您对使用自己的工具与API进行交互感兴趣，完整的API参考资料将详细介绍HTTP谓词和端点、预期的响应格式，以及本指南中未涉及的其他功能。如果您遇到任何问题，我们也很乐意提供帮助——使用我们的联系方式、twitter或支持中心联系我们。</p><p>  Also, if you’re building tools and work as part of work at an academic institution, consider applying for free time on our systems through our  research credits program.</p><p>此外，如果你正在建设工具和工作的一部分，在学术机构，考虑申请自由时间在我们的系统通过我们的研究信贷计划。</p><p>  We also have a full  docs and guides page with step-by-step quickstart guides that go into more detail about getting set up with the above languages and SDKs, and a  best practices page provides detailed instructions for getting the most out of our trapped-ion systems, and our  support center is always available to help you solve any problems you might run into.</p><p>我们还有一个完整的文档和指南页面，其中包含一步一步的快速入门指南，详细介绍了如何使用上述语言和SDK进行设置，还有一个最佳实践页面提供了充分利用我们的离子系统的详细说明，我们的支持中心随时可以帮助您解决任何可能遇到的问题。</p><p>  Harness the power of trapped-ion quantum computing, no matter what cloud, language or SDK you use.</p><p>利用量子计算的力量，无论你使用什么云、语言或SDK。</p><p>  Get started  Read the docs</p><p>开始阅读文档</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/量子/">#量子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/quantum/">#quantum</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>