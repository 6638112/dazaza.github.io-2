<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>批量装入PostgreSQL：选项和比较 Bulk loading into PostgreSQL: Options and comparison</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bulk loading into PostgreSQL: Options and comparison<br/>批量装入PostgreSQL：选项和比较 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-13 07:11:10</div><div class="page_narrow text-break page_content"><p>You have a file, possibly a huge CSV, and you want to import its content into your database. There are lots of options to do this but how would you decide which one to use. More often than not the question is how much time would the bulk load would take. I found my self doing the same few days back when I wanted to design a data ingestion process for PostgreSQL where we needed to bulk load around 250GB of data from CSV files every 24 hours.</p><p>您有一个文件，可能是一个很大的CSV，并且您想将其内容导入数据库。有很多选项可以执行此操作，但是您将如何决定使用哪个选项。问题经常是散装负载将花费多少时间。我几天前想为PostgreSQL设计数据提取过程时发现自己做了同样的事情，在那里我们需要每24小时从CSV文件批量加载大约250GB的数据。</p><p> Goto solution for bulk loading into PostgreSQL is the native copy command. But one limitation with the copy command is that it requires the CSV file to be placed on the server. So I decided to do a simple comparison of bulk loading options and techniques.</p><p> 用于将其批量加载到PostgreSQL的Goto解决方案是本机copy命令。但是copy命令的局限性在于它要求将CSV文件放置在服务器上。因此，我决定对批量加载选项和技术进行简单的比较。</p><p> In short I wanted to see the performance difference of loading the data into standard vs unlogged tables and want to compare the loading time difference between loading into table that has an index vs drop-index-&gt;load-&gt;recreate-index option.</p><p> 简而言之，我想了解将数据加载到标准表和未记录表中的性能差异，并希望比较加载到具有索引vs drop-index->​​ load-> recreate-index选项的表中的加载时间差异。</p><p> Moreover, I wanted to see the performance difference of COPY command, client-side copy command, loading through file_fdw, and pg_bulkload for each of the above options.</p><p> 此外，我想看看上述每个选项的COPY命令，客户端复制命令，通过file_fdw加载和pg_bulkload的性能差异。</p><p>  Since the intention was to do a relative performance comparison among different data loading techniques and options, so using the personal MacBook Pro running macOS Catalena with 16GB of RAM, 2.7 GHz Quad-Core Intel Core i7 processor, and 500 GB SSD disk was good enough to serve the purpose.</p><p>  由于打算在不同的数据加载技术和选项之间进行相对的性能比较，因此使用运行macOS Catalena，16GB RAM，2.7 GHz四核Intel Core i7处理器和500 GB SSD磁盘的个人MacBook Pro足够好达到目的。</p><p> For database I compiled PostgreSQL v12 from source code with default configure options. I left most of the configuration parameter to their default values and only changed the below mentioned settings.</p><p> 对于数据库，我使用默认配置选项从源代码编译了PostgreSQL v12。我将大多数配置参数保留为其默认值，仅更改了以下提到的设置。</p><p>   For the purpose of this exercise, I downloaded a sample CSV file from  http://eforexcel.com/wp/downloads-18-sample-csv-files-data-sets-for-testing-sales/ with 5million rows.</p><p>   出于此练习的目的，我从http://eforexcel.com/wp/downloads-18-sample-csv-files-data-sets-for-testing-sales/下载了一个CSV文件示例，其中包含500万行。 </p><p>    To keep things simple I created a sales_record table in PostgreSQL with one to one mapping with the CSV file</p><p>为简单起见，我在PostgreSQL中创建了一个sales_record表，并与CSV文件进行了一对一映射</p><p> CREATE TABLE sales_record (	region VARCHAR,	country VARCHAR,	item_type VARCHAR,	sales_channel VARCHAR,	order_priority CHAR,	order_date DATE,	order_id INT,	ship_date DATE,	unit_sold INT,	unit_price FLOAT,	unit_cost FLOAT,	total_revenue FLOAT,	total_cost FLOAT,	total_profit FLOAT);</p><p> 创建表sales_record（区域VARCHAR，国家VARCHAR，item_type VARCHAR，sales_channel VARCHAR，order_priority CHAR，order_date DATE，order_id INT，ship_date DATE，unit_sold INT，unit_price FLOAT，unit_cost FLOAT，total_revenue FLOAT，total_cost FLOAT，total_cost FLOAT，</p><p> Along with that I also wanted to see the impact of having an index on the bulk load performance, So for tests that require an INDEX, I created a  btree index on the  country column.</p><p> 除此之外，我还想了解拥有索引对大容量性能的影响，因此对于需要INDEX的测试，我在country列上创建了btree索引。</p><p>   COPY moves data between PostgreSQL tables and standard file-system files. The copy command comes in two variants, COPY TO and COPY FROM. The former copies the table content to the file, while we will use the latter to load data into the table from the file.</p><p>   COPY在PostgreSQL表和标准文件系统文件之间移动数据。复制命令有两个变体，COPY TO和COPY FROM。前者将表内容复制到文件中，而我们将使用后者将数据从文件加载到表中。</p><p>   ‘ \copy‘ is a  psql operation that runs an SQL  COPY command, but instead of the server reading or writing the specified file,  psql (client) reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</p><p>   ``\ copy''是运行SQL COPY命令的psql操作，但是psql（client）读取或写入文件并在服务器和本地文件系统之间路由数据，而不是服务器读取或写入指定的文件。这意味着文件可访问性和特权是本地用户（而不是服务器）的文件可访问性和特权，并且不需要SQL超级用户特权。</p><p>   The foreign-data wrapper  file_fdw, can be used to access data files in the server’s file system, or to execute programs on the server and read their output. We can also use the file_fdw to load data from CSV to PostgreSQL tables.</p><p>   外部数据包装器file_fdw可用于访问服务器文件系统中的数据文件，或在服务器上执行程序并读取其输出。我们还可以使用file_fdw将数据从CSV加载到PostgreSQL表中。</p><p> -- Create file_fdw extension and foreign serverCREATE EXTENSION file_fdw ;CREATE SERVER file_fdw_server FOREIGN DATA WRAPPER file_fdw; -- Define the foreign table that points to our CSV fileCREATE FOREIGN TABLE foreign_sales_record (	region VARCHAR,	country VARCHAR,	item_type VARCHAR,	sales_channel VARCHAR,	order_priority CHAR,	order_date DATE,	order_id INT,	ship_date DATE,	unit_sold INT,	unit_price FLOAT,	unit_cost FLOAT,	total_revenue FLOAT,	total_cost FLOAT,	total_profit FLOAT) SERVER file_fdw_server		OPTIONS (			format &#39;csv&#39;,			header &#39;false&#39; ,			filename &#39;/Users/muhammadusama/work/data/5m_Sales_Records.csv&#39;,			delimiter &#39;,&#39;,			null &#39;&#39;);-- Copy the data from foreign table to local tableINSERT INTO sales_record SELECT * from foreign_sales_record;</p><p> -创建file_fdw扩展名和外部服务器CREATE EXTENSION file_fdw;创建服务器file_fdw_server FOREIGN DATA WRAPPER file_fdw; -定义指向我们的CSV文件的外部表FLOAT，total_cost FLOAT，total_profit FLOAT）服务器file_fdw_server选项（格式＆＃39; csv＆＃39;标头＆＃39; false＆＃39;，文件名＆＃39; /Users/muhammadusama/work/data/5m_Sales_Records.csv&# 39 ;,定界符＆＃39 ;, null＆＃39;＆＃39;）;-将数据从外部表复制到本地表INSERT INTO sales_record SELECT * from foreign_sales_record; </p><p> Although  file_fdw is not expected to be as fast as COPY command when it comes to loading the data but it provides a lot of flexibility and options when it comes to pre-processing the data before loading.</p><p>尽管在加载数据时，file_fdw的预期速度不如COPY命令快，但在加载之前对数据进行预处理时，它提供了很多灵活性和选项。</p><p>  pg_bulkload is also a very interesting option when it comes to high speed data loading. Its an open-source tool that achieves its performance by skipping the shared buffers and WAL logging.</p><p>  当涉及到高速数据加载时，pg_bulkload也是一个非常有趣的选项。它是一个开放源代码工具，可通过跳过共享缓冲区和WAL日志记录来实现其性能。</p><p> -- CREATE pg_bulkload extension$ bin/psql -c &#34;CREATE EXTENSION pg_bulkload&#34; postgres-- Create control file with appropriate contents$ more sample_csv.ctl WRITER = PARALLELOUTPUT = public.sales_record # [&lt;schema_name&gt;.]table_nameINPUT = /Users/muhammadusama/work/data/5m_Sales_Records.csv # Input data location (absolute path)TYPE = CSV # Input file typeQUOTE = &#34;\&#34;&#34; # Quoting characterESCAPE = \ # Escape character for QuotingDELIMITER = &#34;,&#34; # Delimiter-- Execute pg_bulkload utility$ bin/pg_bulkload -d postgres -h localhost sample_csv.ctl</p><p> -创建pg_bulkload扩展$ bin / psql -c＆＃34;创建扩展pg_bulkload＆＃34; postgres--创建具有适当内容的控制文件）TYPE = CSV＃输入文件类型QUOTE =＆＃34; \＆＃34;＆＃34; ＃引用字符ESCAPE = \＃引用的转义字符DELIMITER =＆＃34;，＆＃34; ＃分隔符-执行pg_bulkload实用程序$ bin / pg_bulkload -d postgres -h localhost sample_csv.ctl</p><p>  Below chart shows the time taken by each tool/command to load 5 million rows from CSV file</p><p>  下图显示了每个工具/命令从CSV文件加载500万行所花费的时间</p><p>      Each method for data loading has its own pros and cons which may make one preferred choice over others for a particular use case. But when it comes to raw performance pg_bulkload is a clear winner with COPY and /copy line up behind while file_fdw stands at the last place.</p><p>      每种数据加载方法都有自己的优缺点，对于特定的用例，这可能是一个比其他方法更好的选择。但是在原始性能方面，pg_bulkload显然是赢家，COPY和/ copy排在后面，而file_fdw则排在最后。</p><p> While no matter which data loading method we use, loading into an indexed table is always slow, So do consider  drop-index-&gt;load-&gt;create-index when you have a huge data to be loaded.</p><p> 尽管无论我们使用哪种数据加载方法，加载到索引表中总是很慢，所以当要加载大量数据时，请务必考虑drop-index->​​ load-> create-index。</p><p> Comparison of all the tools was an apple to apple comparison with both client and server were running on the same machine. So, /copy had no network overhead. In the case of PostgreSQL server and client are on different  machines the /copy command may not perform as well as these above results.</p><p> 所有工具的比较是一次苹果对苹果的比较，客户端和服务器都在同一台机器上运行。因此，/ copy没有网络开销。如果PostgreSQL服务器和客户端在不同的计算机上，则/ copy命令的执行效果可能不及上述结果。 </p><p> Muhammad Usama is a database architect / PostgreSQL consultant at HighGo Software and also Pgpool-II core committer. Usama has been involved with database development (PostgreSQL) since 2006, he is the core committer for open source middleware project Pgpool-II and has played a pivotal role in driving and enhancing the product. Prior to coming to open source development, Usama was doing software design and development with the main focus on system-level embedded development. After joining the EnterpriseDB, an Enterprise PostgreSQL’s company in 2006 he started his career in open source development specifically in PostgreSQL and Pgpool-II. He is a major contributor to the Pgpool-II project and has contributed to many performance and high availability related features.</p><p>Muhammad Usama是HighGo Software的数据库架构师/ PostgreSQL顾问，也是Pgpool-II核心提交者。 Usama自2006年以来一直从事数据库开发（PostgreSQL），他是开源中间件项目Pgpool-II的核心提交者，并且在驱动和增强产品方面发挥了关键作用。在进行开源开发之前，Usama从事软件设计和开发，主要侧重于系统级嵌入式开发。加入EnterpriseDB（一家企业PostgreSQL的公司）后，他于2006年开始了他的开源事业，特别是在PostgreSQL和Pg​​pool-II中。他是Pgpool-II项目的主要贡献者，为许多性能和高可用性相关功能做出了贡献。</p><p>  […] post Bulk loading into PostgreSQL: Options and comparison appeared first on Highgo Software […]</p><p>  […]批量加载到PostgreSQL中：选项和比较首先出现在Highgo Software上[…]</p><p>  Nice article and comparison. Though the drop-index-&gt;load-&gt;create-index should not be suitable if you have to add data to the table every 24h. What do you think?</p><p>  不错的文章和比较。如果您必须每24小时将数据添加到表中，虽然drop-index->​​ load-> create-index应该不合适。你怎么看？</p><p>  Save my name, email, and website in this browser for the next time I comment.</p><p>  下次我评论时，请在此浏览器中保存我的姓名，电子邮件和网站。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.highgo.ca/2020/12/08/bulk-loading-into-postgresql-options-and-comparison/">https://www.highgo.ca/2020/12/08/bulk-loading-into-postgresql-options-and-comparison/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/装入/">#装入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/loading/">#loading</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>