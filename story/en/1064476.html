<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Solana上生锈编程的第一印象 First impressions of Rust programming on Solana</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">First impressions of Rust programming on Solana<br/>Solana上生锈编程的第一印象 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-09 13:23:34</div><div class="page_narrow text-break page_content"><p>Since trying out Rust programming on several other Rust blockchains, Aimee and I have been looking forward to test-driving Solana.And with Solana  hosting a hackathon during May,it was a good opportunity to give it a try.</p><p>自从尝试在其他几个Rust区块线上进行防锈编程，Aimee和我一直期待着测试驾驶索拉纳。在5月期间，Solana举办了一个Hackathon，这是一个努力尝试的好机会。</p><p> During the hackathon we attempted to create a “sync bot”,that would sync the data from our in-development web app, Treasure Tree,to the Solana blockchain.Though it has a web server and centralized storage backend,the app was developed with a simple data modelthat was intended to be blockchain-compatible,such that the whole thing could be implementedwithout a web server.</p><p> 在Hackathon期间，我们尝试创建一个“同步Bot”，它会将数据与我们开发的Web app，Travel树上的数据同步到Solana区块链。尽管它具有Web服务器和集中存储后端，该应用程序是用的简单的数据模型旨在兼容块状，使得整个事情可以实现Web服务器。</p><p>  This blog is long and meandering,but I’ve attempted to sum up useful observations here.</p><p>  这个博客很长而蜿蜒，但我试图在这里总结有用的观察。</p><p> In generalwe enjoyed the experience,and it presented relatively fewfrustrating obstacles to writing the code we wanted.We felt excited about the code we were writingand looked forward to writing more.</p><p> 一般来说，享受了这种经验，它呈现了写作我们想要的代码的乐观障碍。我们对我们写作的代码感到兴奋，期待着写作更多。</p><p>  The main documentation at  docs.solana.com is a good entry point formost Solana subjects, is up to date, and interesting to read.</p><p>  docs.solana.com的主要文档是一个良好的入学点甲板索兰人科目，是最新的，并有趣阅读。</p><p>  The  Solana Program Library is a great resource for learningSolana programming the hard way.It contains a bunch of production Solana code,but is also presented in a way that can be used as a learning tool.Smart use of resources.</p><p>  Solana程序库是Searchingsolana编程的伟大资源。它包含一堆生产索拉纳代码，但也以一种可以用作学习工具的方式呈现.Smart使用资源。</p><p>  The Solana toolset and custom toolchain installed easily anddidn’t cause us any grief.</p><p>  Solana工具集和自定义工具链轻松安装，不会导致我们任何悲伤。 </p><p>      The Solana programming model doesn’t impose typical smart contract abstractionson the implementation; it just gives you a low-level entry pointfunction, a buffer of data for your program to interpret,and an SDK full of tools. No DSLs here.</p><p>索拉纳编程模型不会强加典型的智能合同抽象，实施;它只是为您提供了一个低级的输入点，一个缓冲程序，用于解释的程序，以及满满工具的SDK。没有DSL在这里。</p><p>    Although at the time it  felt like a lot of the questions weasked in Discord went unanswered, in retrospect, many of themdid get some kind of answer. A healthy sign I think.</p><p>    虽然当时感到很多问题，但在不和谐中脱掉了很多问题，但回想起来，许多HomeDid都会得到一些答案。我想的一个健康标志。</p><p>  In general,you’ll be ripgrepping the  Solana Program Library a lotto figure out how things work.</p><p>  一般来说，你将重建索拉纳节目库，乐透弄清楚事情是如何工作的。</p><p>    For Rust RPC clients, of the seemingly multiple options in the  solana_clientcrate, use  RpcClient. That is the type used in the SPL. We initially tried to use ThinClient, but that doesn’t seem to be the right type to use.</p><p>    对于RUSTAN_CLIENTCRATE中看似多种选项的生锈RPC客户端，使用RPCCLIET。这是SPL中使用的类型。我们最初尝试使用瘦客户，但似乎似乎并不是正确的使用类型。</p><p>  The   solana_cli_config crate will help you read the contents of Solana’s config files.</p><p>  solana_cli_config crate将帮助您读取索拉纳的配置文件的内容。</p><p>  Call  solana_logger::setup_with(&#34;solana=debug&#34;); before your program starts,or set the envvar  RUST_LOG=solana_client=debug. This will show the logsfrom your program when it errors.</p><p>  呼叫solana_logger :: setup_with（＆＃34; solana = debug＆＃34;）;在程序开始之前，或设置envvar rust_log = solana_client = debug。这将在错误时显示LogsFrom您的程序。</p><p>  When your program succeeds the logs show up in the output of the  solana logscommand.</p><p>  当您的程序成功时，日志显示在Solana LogsCommand的输出中。 </p><p>  Use   try_from_slice_unchecked to deserialize from buffers that arelarger than the exact size of the serialized object.   try_from_slicepanics when the buffer is not exactly the right size.</p><p>使用try_from_slice_unchecked从缓冲区浏览，该缓冲区比序列化对象的确切大小为止。当缓冲区不完全正确尺寸时，请尝试_from_slicepanics。</p><p>  The instruction budget is very limited —we were not able to verify a single K-256 ECDSA signature on-chainwithin the limit, as such:</p><p>  指令预算非常有限 - 我们无法在限制下验证连锁的单个K-256 ECDSA签名，如下所示：</p><p>  Doing your own signature verification in-program is probably notthe way to use Solana. The Solana runtime can verify multiple account signaturesbefore your program ever runs, so a Solana program seemingly needs to be designedto leverage that capability when signature verification is needed.</p><p>  做自己的签名验证程序可能不是使用索拉纳的方式。 Solana Runtime可以验证多个帐户签名，您的程序曾经运行过，所以索拉纳程序似乎需要设计为在需要签名验证时利用这种能力。</p><p>  Solana programs have a pre-allocated and bounded storage size.This means it is probably an anti-pattern to store key-value mapsdirectly. What seems to be an intended pattern for key-value storageis to derive the keys as Solana accounts from a single base account,and store the values in those accounts.</p><p>  索拉纳程序具有预先分配和有界存储大小。这意味着它可能是存储键值MapsDirectly的反模式。似乎是用于键值存储的预期模式，以从单个基本帐户中派生键帐户，并将值存储在这些帐户中。</p><p>  Solana programs have access to the standard library,but it is a not-quite compatible version of the standard library.This was the source of multiple confusions, including:</p><p>  索拉纳程序可以访问标准库，但它是标准库的一个不相当兼容版本。这是多个混淆的源，包括：</p><p>  HashMap seems to just fail on any operation,which manifests as a mysterious access violation.We spent hours looking for our bug when we should have just notused  HashMap; and</p><p>  Hashmap似乎只在任何操作都失败了，这表明作为一个神秘的访问违规行为。我们在我们应该刚刚注意到HashMap时花了几个小时寻找我们的错误;和</p><p>  time and  anyhow don’t build against Solana’s  std. anyhow can be built with the  std feature off, but that losescompatibility with the  Error trait.</p><p>  时间和任何时候都不会对索拉纳的STD建立。无论如何都可以使用STD功能关闭，但随着错误性状的LOSScompatibility。 </p><p>  At least one function,  read_keypair_file, returned  Box&lt;dyn Error&gt;,which can’t be trivially converted to  anyhow::Error with the  ? operator.Errors in Rust really need to be  Error + Send + Sync + &#39;static unless thereis great reason not to.</p><p>至少一个函数，read_keypair_file，返回的box＆lt; dyn错误＆gt;，它不能术语转换为Anyhow ::错误？ Rust中的操作员真的需要出错+发送+同步+＆＃39;静态，除非有很大的原因。</p><p>  4K BPF stack frames means some crates don’t work,including  ed25519-dalek.Big stack frames trigger an access violation at runtime.First time I’ve ever encountered a limit like this.</p><p>  4K BPF堆栈框架意味着一些箱子不起作用，包括ED25519-Dalek.big堆栈帧触发运行时的访问违规。前一时间我曾经遇到过这样的限制。</p><p>  cargo build-bpf behaves differently than  cargo-build in several situations,including missing the  -p flag, and not working with librariescontaining hyphens in their name.</p><p>  Cargo Build-BPF在几种情况下的货物构建方式不同，包括缺少-P标志，而不与他们的名字一起使用图书馆。</p><p>  As with previous experiences, we found the online hackathon formatuninspiring, and mostly didn’t participate.</p><p>  与以前的经历一样，我们发现了在线Hackathon FormatiNinspiring，大多数没有参加。</p><p>  It felt like many questions on Discord went unanswered.This was annoying,but also understandable, and not out of the ordinary for anopen source project. Sometimes nobody steps up to help.It just happens, but is discouraging.</p><p>  它觉得很多关于不和谐的问题就没有了解。这很烦人，也是可以理解的，而不是普通的OPEN源项目。有时没有人介入帮助。就是恰好发生的，但却令人沮丧。</p><p>  What is  ThinClient in  solana_client for?We tried to use it but that seemed to be a wrong choice.</p><p>  什么是Solana_Client的薄鲸？我们试图使用它，但这似乎是一个错误的选择。</p><p>    What is the best pattern for initializing a Solana program’s state?We reserved a single byte at the beginning of our account datato use as an “initialized” flag.</p><p>    初始化Solana程序状态的最佳模式是什么？我们在我们的帐户日期开始时保留了一个字节，用作“初始化”标志。 </p><p>   We managed to create a “sync bot” that was able to mirrorthe state of our centralized web app on the blockchain,and set it up on a server at  treasuretree.org,running against a local devnet.</p><p>我们设法创建了一个能够在区块链上致电的“同步BOT”，并将其集成在区块链中的状态，并在TextReTree.org的服务器上设置，运行针对本地DevNet。</p><p> We did find that some of our assumptions about the types of codewe could run on-chain were wrong. In particular we:</p><p> 我们确实发现我们关于Codewe类型的一些假设可能会在链中运行错误。特别是我们：</p><p>  Neither of these are easy or proper to do on Solana:signature verification just requires too many CPU cycles;and programs have fixed storage space.</p><p>  这些都不是索拉纳（Solana）很容易或适当的：签名验证只需要太多的CPU周期;并且程序具有固定的存储空间。</p><p> As it stands our Solana program does not properly verify thesignatures it needs to —it just accepts its input as valid.To fix this we need to restructure our cryptographic code within the restof our application to do more Solana-specific signing operations.This is a bit of a bummer, as we were hoping to keepthe application logic blockchain-agnostic.</p><p> 因为它所代表我们的Solana程序没有正确验证它需要的重要性，只接受它的输入是有效的。解决此问题我们需要将我们的应用程序中的加密码重组为我们的应用程序更具特定于索拉纳特定的签名操作。这是一个我们希望保持应用程序逻辑块禁止的应用程序的钻头。</p><p> We also didn’t explore making our in-game “treasures” work as NFTs.Just ran out of time.</p><p> 我们也没有探索我们的游戏中的“宝藏”作为NFTS.just耗尽。</p><p>     Today is the 17th.The hackathon began on the 15th,but we’re just starting now after moving Airbnbs.</p><p>     今天是17岁。哈克松始于15日，但我们刚刚在移动Airbnbs后立即开始。</p><p> Our plan today is to join the Solana hackathon Discord channels,install the Solana SDK,and run some hello world example.</p><p> 我们今天的计划是加入Solana Hackathon Discord渠道，安装Solana SDK，并运行一些Hello World举例。 </p><p> While we get started,we open  one of the video sessions we missed,this one an intro to “the Solana programming model”.</p><p>虽然我们开始了，我们打开了我们错过的视频会话之一，这是一个介绍“索拉纳编程模型”。</p><p>  program-derived accounts don’t have a knowable private key,but can still sign transactions (or something).This sounds like it solves a problem I have been havingunderstanding how to build distributed applications,but I’ll have to investigate further.</p><p>  程序派生的帐户没有知识的私钥，但仍然可以签署交易（或其他东西）。这听起来像它解决了一个问题，我已经搞定了如何构建分布式应用程序，但我必须进一步调查。</p><p>  I want to install the Solana SDK, tools, or whatever I need.I assume there’s something SDK-like I need.</p><p>  我想安装Solana SDK，工具或我所需要的任何东西。我假设是我需要的SDK的东西。</p><p> The  hackathon docs contains some educational links,and I folow the first to the  Solana docs website.</p><p> Hackathon文档包含一些教育链接，我将第一个到索拉纳文档网站。</p><p>  This page says “To start developing immediately you can build, deploy, and run one of the examples.”That’s exactly what we want to do.</p><p>  此页面说“立即开始开发，您可以构建，部署和运行其中一个示例。”这正是我们想要做的。</p><p>     This flow is a bit confusing,as the “examples” page proceeds directly from “Helloworld”,to “Break”,which is an entirely different example.Though the instructions do say to continue to the Helloworld readme,Aimee succumbs to this confusion,and proceeds to try to follow “Break”.The correct thing to do is stop here,navigate to the Helloworld readme,and continue there.</p><p>     这种流程有点令人困惑，因为“例子”页面直接从“HelloWorld”，“打破”，这是一个完全不同的例子。虽然说明说要继续向HelloWorld Readme，Aimee Sucumbs对此混乱，并继续尝试遵循“休息”。正确的事情在这里停止，导航到HelloWorld Readme，并继续存在。</p><p> This example is so well documentedthat the README has a table of contents.I am encouraged by this.</p><p> 这个例子如此良好，记录了，那么README有一个目录。我鼓励这个问题。 </p><p> This example requires node &gt; 14.Aimee immediately runs into problems on mac:she seems to have node 10,tries to upgrade with brew,but brew complains because her node and yarnare not from brew.This happens all the time with her computer —she has forgotten how she installed node last time.We discover she has nvm installed and sort things out.We’re both on node v16.1.0.</p><p>此示例需要节点＆gt; 1.aimee立即在Mac上遇到问题：她似乎有节点10，尝试用酿造升级，但酿造抱怨，因为她的节点和yarnare不是从酿造的。这一直与她的电脑忘记了她的安装方式节点上次。我们发现她已经安装了NVM并在节点V16.1.0上进行了out.we。</p><p>   And now, “install Solana v1.6.6 or later”,the instructions for which are back on the Solana docs site.</p><p>   现在，“安装Solana v1.6.6或更高版本”，返回Solana Docs网站的说明。</p><p>       # Copyright 2016 The Rust Project Developers. See the COPYRIGHT # file at the top-level directory of this distribution and at # http://rust-lang.org/COPYRIGHT.</p><p>       ＃版权所有2016生锈项目开发人员。请参阅此分发的顶级目录的版权＃文件和#ttp://rust-lang.org/copyright。</p><p>  # This is just a little script that can be downloaded from the internet to # install solana-install. It just does platform detection, downloads the installer # and runs it.</p><p>  ＃这只是一个小脚本，可以从Internet下载到＃安装Solana-Install。它只是平台检测，下载安装程序＃并运行它。</p><p> This is a fork of  rustup’s install script,which I wrote,and which, as I discovered previously,Dfinity also uses.</p><p> 这是我写道的Rustup安装脚本的叉子，以及我以前发现的那样，DFINTY也使用。</p><p>   This isn’t in the  rustup-init.sh script.I haven’t seen this technique before of just throwing a setof braces around the entire shell script,and wonder how compatible it is.</p><p>   这不在Rustup-Init.sh脚本中。我在刚刚在整个shell脚本周围抛出一个setof括号之前没有看到这种技术，并怀疑它是多么兼容。</p><p> Scripts downloaded from the internet and immediately piped throughan interpreter need to guard against issues where the scriptfails to download fully and so is only partially executed.That’s what this brace is about.</p><p> 从互联网下载的脚本，并立即通过and解释器立即处理，以防止脚本文件完全下载的问题，因此只有部分地执行。这就是这个支撑的东西。 </p><p> rustup-init.sh attempts to achieve this by essentially not executingany code until a single function call at the end of the script.And so I am slightly afronted that somebody just threw bracesaround the whole thing,as though saying my original work was insufficient.Alas,I can imagine a scenario where the brace-around-everything techniquecould catch an error that  rustup-init.sh doesn`t,so this is something to consider if I ever find myself writinga shell script to be piped from the internet again;which I hope I never do.</p><p>Rustup-Init.sh尝试通过基本上不是执行的代码来实现这一目标，直到脚本末尾的单一函数调用。所以我稍微复发，有人只是在整个事情上扔了一切，好像说我的原始工作不够。唉，我可以想象一个场景，其中围绕一切技术应该捕获Rustup-init.sh的错误，所以如果我发现自己再次写作shell脚本，那么这就是要考虑的话。我希望我永远不会做。</p><p>     $ solana config set --url localhostConfig File: /home/brian/.config/solana/cli/config.ymlRPC URL: http://localhost:8899WebSocket URL: ws://localhost:8900/ (computed)Keypair Path: /home/brian/.config/solana/id.jsonCommitment: confirmed</p><p>     $ solana config set  -  url localhostconfig文件：/home/brian/.config/solana/cli/config.ymlrpc url：http：// localhost：8899websocket url：ws：// localhost：8900 /（computed）keypair路径： /home/brian/.config/solana/id.jsonCommitment：确认</p><p>  We have a global config file,for me it’s in the XDG-standard  ~/.config/solana directory,</p><p>  我们有一个全局配置文件，对我来说是在xdg标准〜/ .config / solana目录中，</p><p>      We have an account keypair set up for us,the exact purpose for which is not clear,but I assume is a dev keypair</p><p>      我们有一个账户keypair为我们设置，确切的目的是不明确的，但我认为是一个开发键</p><p> The next instruction is to create a keypair,but  solana config says I already have a keypair.I am guessing I have previously installed the Solana SDK,and it is an old keypair.I begin to generate a new one:</p><p> 下一个指令是创建一个keypair，但索拉纳配置说我已经有一个keypair.i我猜我以前安装了索拉纳sdk，它是一个旧的keypair.i开始生成一个新的keypair.i</p><p> $ solana-keygen newGenerating a new keypairFor added security, enter a BIP39 passphraseNOTE! This passphrase improves security of the recovery seed phrase NOT thekeypair file itself, which is stored as insecure plain textBIP39 Passphrase (empty for none):</p><p> $ solana-keygen newgenerating一个新的keypairfor额外的安全性，输入BIP39 PassphraseNote！此密码提高了恢复种子短语的安全性，而不是The TheyPair文件本身，它存储为不安全的纯TextBip39密码（无以为None）：</p><p> This is going to be a dev key and I don’t care about recovering it.I leave the passphrase blank and just hit “enter”.</p><p> 这将是一个开发钥匙，我不关心恢复它。我离开密码短语空白并刚刚点击“进入”。 </p><p> Wrote new keypair to /home/brian/.config/solana/id.json==================================================================================pubkey: C4NEJZc432PWEDvYR6LiBWCv7wvfdJWDppLscL42R3aD==================================================================================Save this seed phrase and your BIP39 passphrase to recover your new keypair:engage possible prison twin control language talk cactus hobby vehicle allow blush==================================================================================</p><p>写了新的凯内特至/home/brian/.config/solana/id.json================================= ================================================= pubkey. ：C4NEJZC432PWEDVYR6LIBWCV7WVFDJWDPPLSCL42R3AD =============================================== ==================================保存此种子短语和您的BIP39密码恢复您的新键盘：Engage可能监狱双床控制语言谈话仙人掌爱好车辆允许腮红======================================== ==========================================.</p><p> Again, this is a garbage dev key.I am fine printing the seed phrase on the internet.</p><p> 同样，这是一个垃圾dev关键。我很好地打印互联网上的种子短语。</p><p>  $ solana-test-validatorLedger location: test-ledgerLog: test-ledger/validator.logIdentity: GZr7zHFUxA7kjGgzUsUuRfQtNASBCGurynEg7yUDcfvPGenesis Hash: F945qQyeHDUXN58eUWuLHLogAZ7Qgkpucc7xe8LisQnRVersion: 1.6.9Shred Version: 54687Gossip Address: 127.0.0.1:1025TPU Address: 127.0.0.1:1027JSON RPC URL: http://127.0.0.1:8899⠒ 00:00:08 | Processed Slot: 16 | Confirmed Slot: 16 | Finalized Slot: 0 | Snapshot Slot: - | Transaction</p><p>  $索拉纳试验validatorLedger位置：测试ledgerLog：测试总账/ validator.logIdentity：GZr7zHFUxA7kjGgzUsUuRfQtNASBCGurynEg7yUDcfvPGenesis哈希：F945qQyeHDUXN58eUWuLHLogAZ7Qgkpucc7xe8LisQnRVersion：1.6.9Shred版本：54687Gossip地址：127.0.0.1:1025TPU地址：127.0.0.1:1027JSON RPC的URL：http： //127.0.0.1:8899�00:00:08 |加工插槽：16 |确认插槽：16 |最终插槽：0 | Snapshot插槽： -  |交易</p><p>     I like everything I’m seeing so far:the docs have directed me well,the tooling has worked cleanly.</p><p>     我喜欢到目前为止我看到的一切：Doc已经指导了我，这款工具已经干净了。</p><p>  After reading  about Solana’s use of BPF,I ask in their Discord a question that I have been wondering for a few weeks:</p><p>  在阅读索拉纳的使用BPF之后，我在他们不和谐的问题中，我一直在想几个星期：</p><p> Can somebody from Solana remind me why Solana uses BPF as its instruction set? I thought it was because BPF was not turing complete and programs could be verified to terminate, but I’ve recently been informed that is not the case</p><p> Solana的人可以提醒我为什么索拉纳用BPF作为其指令集？我以为是因为BPF没有完成完整，并且可以核实计划终止，但我最近被告知就没有这种情况</p><p>   What advantages does solana get from targeting eBPF, vs any other instruction set, for its VM? Been trying to get an answer to this for awhile.</p><p>   Solana从目标eBPF获得了哪些优势，与其VM为任何其他指令集？一段时间一直试图为此答案。 </p><p> Somebody responds by pinging “chase || solana”,and asking them to ask a Solana dev to explain,but that explanation never comes.</p><p>有人通过ping“chase ||索拉纳“，并要求他们问一个索拉纳开发来解释，但解释永远不会来。</p><p>       Are there any blogs or benchmarks about solana’s jit compiler I can check out?</p><p>       有关Solana的JIT编译器的任何博客或基准是否可以退房？</p><p>   After some shower-based ruminating,this answer though does jog a memory.I have spoken with Anatoly about this subject in the distant past,and I recall now that the BPF instruction set has a design that is easy to translate to x86.So it might be that simple JITting and performance is the reason for choosing BPF.</p><p>   经过一些基于淋浴的反光，虽然虽然在遥远的过去中慢慢地慢跑了内存。我现在回想起了BPF指令集的设计很容易翻译为x86.所以它可能是简单的杂交和性能是选择BPF的原因。</p><p> Interestingly,I believe this is also part of the reason  Nervosuses RISC-V —its simple register and instruction set is easy to map to x86.</p><p> 有趣的是，我相信这也是神经功能RISC-V-its简单寄存器的一部分的一部分，并且指令集很容易映射到x86。</p><p>  It’s 5/19 now. Next step in the Helloworld tutorial is to build and run the application.The build is driven by npm, but includes cargo components as well.</p><p>  现在是5/19。 HelloWorld教程中的下一步是构建和运行应用程序。构建由NPM驱动，但也包括货物组件。</p><p>  : ~/solana/example-helloworld$ npm installnpm WARN EBADENGINE Unsupported engine {npm WARN EBADENGINE package: &#39;helloworld@0.0.1&#39;,npm WARN EBADENGINE required: { node: &#39;12.x&#39; },npm WARN EBADENGINE current: { node: &#39;v15.10.0&#39;, npm: &#39;7.5.3&#39; }npm WARN EBADENGINE }</p><p>  ：〜/ solana / example-helloworld $ npm installnpm warn ebadengine不支持引擎{npm warn ebadengine包：＆＃39; helloworld@0.0.1&#39;，npm warn ebadengine所必需：{node：＆＃39; 12.x＆＃39; 12.x＆＃ 39; }，NPM Warn Ebadengine电流：{node：＆＃39; v15.10.0＆＃39;，npm：＆＃39; 7.5.3＆＃39; NPM Warn Ebadengine}</p><p> There is a problem here:I have node v15, and the build gives me a warning that v12 is required,but the readme for this demo says “v14 recommended”.So it appears that either the package should be updated to not warn on later versions,or the docs should say “v12 recommended”.</p><p> 这里有一个问题：我有节点v15，build给我一个警告，这是必需的，但是这个演示的自述文件说“v14推荐”。所谓的包应该更新，以后应该更新包裹版本或文档应该说“V12推荐”。 </p><p>    And as part of this,the build runs  cargo build-bpf.I am guessing the  build-bpf subcommand was installedduring  npm install,which ran a cargo build. cargo build-bpf downloads the Solana BPF SDK:</p><p>作为其中的一部分，Build运行Cargo Build-BPF.I我猜测Bubl-BPF子命令已经安装了NPM安装，这是一个货物构建。 Cargo Build-BPF下载Solana BPF SDK：</p><p>     ...Transaction executed in slot 2006: Signature: 2jP1sCQ2CVzizHzc7zgajwf2E8yU2x4RhSyeL59mvFio8UvkyS4rcxyVaNyan5w7UCm3cZBsYefoETBD7DuZbbBt Status: Ok Log Messages: Program 11111111111111111111111111111111 invoke [1] Program 11111111111111111111111111111111 success Program 11111111111111111111111111111111 invoke [2] Program 11111111111111111111111111111111 success Deployed program 2jW9jdWSwqkM2rznH5MwL65obzMoHUHZsxpUmjAULsmq</p><p>     签名：...交易在2006年执行插槽状态2jP1sCQ2CVzizHzc7zgajwf2E8yU2x4RhSyeL59mvFio8UvkyS4rcxyVaNyan5w7UCm3cZBsYefoETBD7DuZbbBt：好的日志消息：计划11111111111111111111111111111111调用[1]程序11111111111111111111111111111111成功计划11111111111111111111111111111111调用[2]程序11111111111111111111111111111111成功部署的程序2jW9jdWSwqkM2rznH5MwL65obzMoHUHZsxpUmjAULsmq</p><p>  $ npm run start&gt; helloworld@0.0.1 start&gt; ts-node src/client/main.tsnode:internal/modules/cjs/loader:926 throw err; ^Error: Cannot find module &#39;arg&#39;Require stack:- /home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js at Function.Module._resolveFilename (node:internal/modules/cjs/loader:923:15) at Function.Module._load (node:internal/modules/cjs/loader:768:27) at Module.require (node:internal/modules/cjs/loader:995:19) at require (node:internal/modules/cjs/helpers:92:18) at Object.&lt;anonymous&gt; (/home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js:8:13) at Module._compile (node:internal/modules/cjs/loader:1091:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1120:10) at Module.load (node:internal/modules/cjs/loader:971:32) at Function.Module._load (node:internal/modules/cjs/loader:812:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) { code: &#39;MODULE_NOT_FOUND&#39;, requireStack: [ &#39;/home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js&#39; ]}npm ERR! code 1npm ERR! path /home/brian/solana/example-helloworldnpm ERR! command failednpm ERR! command sh -c ts-node src/client/main.tsnpm ERR! A complete log of this run can be found in:npm ERR! /home/brian/.npm/_logs/2021-05-19T01_48_31_041Z-debug.log</p><p>  $ npm运行开始＆gt; helloWorld@0.0.1开始＆gt; TS-Node SRC / Client / Main.TsNode：内部/模块/ CJS / Loader：926抛出Err; ^错误：找不到模块＆＃39; arg＆＃39;需要堆栈： -  /home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js在function.module._resolvefilename（节点：内部/模块/ CJS / LOADER：923：15）AT函数.module._load（node：modules / cjs / loader：768：27）在module.require处（节点：内部/模块/ cjs / loader：995：19 ）根据要求（节点：内部/模块/ cjs / exervers：92：18）。＆lt;匿名和gt; （/home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js:8:13）在module._compile（节点：内部/模块/ cjs / loader：1091：14）在对象。 module._extensions..s（节点：内部/模块/ cjs / loader：1120：10）在module.load（node：modules / cjs / loader：971：32）函数.module._load（neget：内部/ modules / cjs / loader：812：14）在函数.executeuserentrypoint [作为runmain]（节点：内部/模块/ run_main：76：12）{code：＆＃39; module_not_found＆＃39 ;, quandestack：[＆＃39 ; /home/brian/solana/example-helloworld/node_modules/ts-node/dist/bin.js&#39; } npm错误！代码1NPM ERR！路径/主页/ Brian / solana / emaly-helloWorldnpm err！命令Failednpm错误！命令sh -c ts-node src / client / main.tsnpm err！可以找到完整的此运行日志：NPM ERR！ /home/brian/.npm/_logs/2021-05-19t01_48_31_041z-debug.log.</p><p>  I google “cannot find module arg”.Nothing.I run  git pull to check for bugfixes.Nothing.I see that I have some dirty files in my tree.So I decide to start over,run  git reset --hard origin/master &amp;&amp; rm node_modules &amp;&amp; rm dist.</p><p>  我谷歌“找不到模块arg”.nothing.i运行git pull以检查bugfixes.nothing.i看到我在树中有一些脏文件。所以我决定从git重置开始，运行git重置--hard orign / master ＆amp;＆amp; RM node_modules＆amp;＆amp; rm dist。</p><p> I go through the  npm install /  npm run build:program-rust /  solana program deploy /  npm run startsequence again.</p><p> 我经过NPM Install / NPM Run Build：程序 -  Rust / Solana程序Deploy / NPM再次运行StareSequence。</p><p>  $ npm run start&gt; helloworld@0.0.1 start&gt; ts-node src/client/main.tsLet&#39;s say hello to a Solana account...Connection to cluster established: http://localhost:8899 { &#39;feature-set&#39;: 2960423209, &#39;solana-core&#39;: &#39;1.6.9&#39; }Using account C4NEJZc432PWEDvYR6LiBWCv7wvfdJWDppLscL42R3aD containing 499999998.27048796 SOL to pay for feesUsing program 7NMkTRVNtBvuC68BVeamnXmuqcpiVeLQgNDGzQrPceTNCreating account 6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt to say hello toSaying hello to 6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt has been greeted 1 time(s)Success</p><p>  $ npm运行开始＆gt; helloWorld@0.0.1开始＆gt; ts-node src / client / main.tslet＆＃39; s向索拉纳账户发出你好...与群集的连接建立：http：// localhost：8899 {＆＃39;功能集＆＃39 ;: 2960423209，＆ ＃39; solana-core＆＃39 ;:＆＃39; 1.6.9＆＃39; }使用含499999998.27048796 SOL支付feesUsing程序7NMkTRVNtBvuC68BVeamnXmuqcpiVeLQgNDGzQrPceTNCreating帐户C4NEJZc432PWEDvYR6LiBWCv7wvfdJWDppLscL42R3aD帐户6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt打招呼toSaying招呼6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt6GeXM3KjbPJ7pXQoDri2f2YPzZXGts2ewHiVRFGuaZWt已经迎来1时间（s）成功</p><p> Ok.I’ll never know what I did wrong.Love it when that happens,but that’s hacking.</p><p> 好的。我永远不会知道我做错了什么。当它发生时，但这就是黑客攻击。 </p><p>  The Rust contract  is nice and short.Here’s the whole thing minus imports and tests:</p><p>铁锈合同很好，短缺。整件事是减去进口和测试：</p><p> // Declare and export the program&#39;s entrypoint entrypoint! ( process_instruction ); // Program entrypoint&#39;s implementation pub  fn  process_instruction (  program_id :  &amp; Pubkey ,  // Public key of the account the hello world program was loaded into  accounts :  &amp; [ AccountInfo ],  // The account to say hello to  _ instruction_data :  &amp; [ u8 ],  // Ignored, all helloworld instructions are hellos )  -&gt;  ProgramResult  {  msg! ( &#34;Hello World Rust program entrypoint&#34; );  // Iterating accounts is safer then indexing  let  accounts_iter  =  &amp; mut  accounts .iter ();  // Get the account to say hello to  let  account  =  next_account_info ( accounts_iter ) ? ;  // The account must be owned by the program in order to modify its data  if  account .owner  !=  program_id  {  msg! ( &#34;Greeted account does not have the correct program id&#34; );  return  Err ( ProgramError :: IncorrectProgramId );  }  // Increment and store the number of times the account has been greeted  let  mut  greeting_account  =  GreetingAccount :: try_from_slice ( &amp; account .data .borrow ()) ? ;  greeting_account .counter  +=  1 ;  greeting_account .serialize ( &amp; mut  &amp; mut  account .data .borrow_mut ()[ .. ]) ? ;  msg! ( &#34;Greeted {} time(s)!&#34; ,  greeting_account .counter );  Ok (()) }</p><p> //声明并导出程序＆＃39; s ententpoint entintpoint！ （process_instruction）; //程序输入点＆＃39; s实现pub fn process_instruction（program_id：＆amp; pubkey，//帐户的公钥，Hello World Program的帐户被加载到账户中：＆amp; [AccountInfo]，//表示Hello至_指令_Data：＆amp; [U8]，//忽略，所有HelloWorld指令都是Hellos） - ＆gt; programSresult {msg！ （＆＃34;你好世界生锈程序入口＆＃34;）; //迭代账户更安全，然后索引让帐户_Ters_Ter =＆amp; mut帐户.Ter（）; //获取帐户来说招呼才能让帐户= next_account_info（contains_iter）？ ; //该帐户必须由程序拥有，以便在帐户中修改其数据.OWNER！= program_id {msg！ （＆＃34;问候帐户没有正确的程序ID＆＃34;）; returner err（programError ::不正确）; } //递增和存储帐户已被打招呼的次数让mut greeting_account = greetingAccount :: try_from_slice（＆amp;帐户.data .borry .borry .borent（））？ ; greeting_account .counter + = 1;问候语_Account .serialize（＆amp; mut＆amp; mut帐户.data .borrow_mut（）[..]）？ ; msg！ （＆＃34;问候{}时间！＆＃34;，reduging_account .counter）;好的 （（）） }</p><p> I like this a lot:there’s very little magic here —you define an entry point,and you get a blob of instruction data,and its up to you to use the SDK to interpret it.</p><p> 我很喜欢这个：这里有很少的魔法 - 你定义了一个入口点，你得到了一个斑点的指令数据，它取决于你使用SDK解释它。</p><p>  #[macro_export] macro_rules!  entrypoint  {  ( $process_instruction:ident )  =&gt;  {  /// # Safety  #[no_mangle]  pub  unsafe  extern  &#34;C&#34;  fn  entrypoint ( input :  * mut  u8 )  -&gt;  u64  {  let  ( program_id ,  accounts ,  instruction_data )  =  unsafe  {  $crate :: entrypoint :: deserialize ( input )  };  match  $process_instruction ( &amp; program_id ,  &amp; accounts ,  &amp; instruction_data )  {  Ok (())  =&gt;  $crate :: entrypoint :: SUCCESS ,  Err ( error )  =&gt;  error .into (),  }  }  $crate :: custom_heap_default! ();  $crate :: custom_panic_default! ();  }; }</p><p>  ＃[宏_export] macro_rules！ entrypoint {（$ process_instruction：ident）=＆gt; {///＃安全＃[no_mangle] pub不安全extern＆＃34; c＆＃34; FN入口点（输入：* mut U8） - ＆gt; U64 {让（program_id，帐户，指令_data）=不安全{$ crate ::cestpoint :: deserialize（输入）};匹配$ process_instruction（＆amp; program_id，＆amp;帐户，＆amp; nighard_data）{ok（（））=＆gt; $ crate ::cestpoint ::成功，错误（错误）=＆gt;错误.into（），}} $ crate :: custom_heap_default！ （）; $ crate :: custom_panic_default！ （）; }; }</p><p> Personally, I like to understand what is happening under the hood,and dislike hiding magic in macros where reasonable,so I’m encouraged by this.</p><p> 就个人而言，我喜欢了解引擎盖下发生了什么，并且在合理的宏观中不喜欢隐藏的魔法，所以我鼓励这个。</p><p>   We spend some time reading through the Rust and TypeScript source code on GitHub,but I am not outlining our thoughts about it here.</p><p>   我们花了一段时间通过GitHub上的Rust和Cypersctific源代码进行阅读，但我并没有概述我们这里的想法。</p><p> All of the links to code in the “learn about the client” section of the readmelink to old commits,and it is a bit confusing.</p><p> 在“了解Readmelink的”了解“的代码中的所有链接，对旧的提交，并且有点令人困惑。 </p><p>  I also discover that part of the  npm install process runs  cargo update,which leaves my lockfile dirty.I submit  a PR to update the lockfile.</p><p>我还发现NPM安装过程的一部分运行Cargo更新，它离开了我的LockFile Dirty.i提交PR以更新LockFile。</p><p>  Now that we have the tools,and a basic understanding of how to set up a Solana program and client,let’s think about integrating Solana into our own project.</p><p>  既然我们有工具，以及如何建立索拉纳计划和客户的基本了解，让我们考虑将索拉纳集成到我们自己的项目中。</p><p> The project is called  Treasure Tree,and it is a real-world treasure hunt where the treasures are NFTs.In it,</p><p> 该项目被称为宝库，它是一个真正的宝藏狩猎，宝藏是NFTS.IN，</p><p> treasure  claimers find and scan those QR codes to claim them on the network, as NFTs.</p><p> 宝藏官器发现并扫描这些QR代码，以便在网络上索取它们，如NFTS。</p><p> As such, there are only two verbs in our app, plant, and  claim, and executing eitherinvolves the creation and verification of a few cryptographic signatures.</p><p> 因此，我们的应用程序，工厂和索赔中只有两个动词，并执行oinvolves创建和验证几个加密签名。</p><p> We have already prototyped the application as a conventional webapp using  Rocket.Our goal for this hackathon is to implement the two verbs, plant and claim,in a Solana program;make the treasures transactable as NFTs;and to create a service that syncs the state of these treasuresfrom the centralized service onto the blockchain.</p><p> 我们已经将应用程序原型为使用火箭的传统WebApp。此Hackathon的目标是在索拉纳计划中实施两种动词，工厂和索赔;使宝藏可转入NFTS;并创建一个同步状态的服务将这些宝藏从集中服务中的集体服务放在区块链上。</p><p> Note th</p><p> 注意 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://brson.github.io/2021/06/08/rust-on-solana">https://brson.github.io/2021/06/08/rust-on-solana</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/solana/">#solana</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>