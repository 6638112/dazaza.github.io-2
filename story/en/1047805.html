<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>内核编程语言（2010） The Kernel Programming Language (2010)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Kernel Programming Language (2010)<br/>内核编程语言（2010） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 18:35:11</div><div class="page_narrow text-break page_content"><p>This page is Copyright John N. Shutt2004–2012, 2015–2021.  Here&#39;s what you&#39;re allowed to do with it. Last modified: 24-Jan-21.</p><p>此页面版权所有John N.Shutt2004–2012、2015–2021。这是您可以使用的功能。上次修改时间：21年1月24日。</p><p>     I&#39;m developing a programming language called Kernel. Kernel is a conservative, Scheme-like dialect of Lisp in whicheverything is a first-class object. &#34;But,&#34; you may ask, &#34;aren&#39;t all objects first-class in Scheme?&#34; (I&#39;m glad you asked.)  No, they aren&#39;t. Special-form combiners are second-class objects. To borrow a phrase from the original descriptionof first- and second-class objects by Christopher Strachey,they have to appear in person under their own names. (There are also several other kinds of second-class objects in Scheme, but special-form combiners are the most commonplace.) The idea of first-class  operative combiners,i.e., first-class combiners whose operands are never evaluated,has been around a long time. Such creatures were supported by mainstream Lisps through the 1970s,under the traditional name  fexprs,but they made a mess out of the language semantics because they werenon-orthogonal to the ordinary variety of procedures constructed via lambda— and, more insidiously,because at that time the mainstream Lisps were dynamically scoped(a language feature that causes more problems for fexprs than it does for the less powerful  macros). Kernel eliminates the non-orthogonality problem by breaking the classical lambda constructor into two orthogonal parts,one of which is the Kernel constructor for first-class operatives. The primitive constructor of operatives is an operative called  $vau, which is almost the same as Scheme&#39;s  lambda in both syntax and semantics, except that the combiners it constructs are operative.  The primitive constructor of  applicatives, i.e., combiners whose operands are evaluated, is an applicative called  wrap.   wrap takes one argument, which must be a combiner, and constructs an applicative that passes its arguments (the results of evaluating its operands) to the specified combiner.  The underlying combiner of any applicative can be extracted using applicative  unwrap.  There is also an operative constructor of applicatives called  $lambda, that is almost exactly like Scheme&#39;s  lambda — but Kernel&#39;s  $lambda isn&#39;t primitive:  It can be implemented as a compound operative, using  $vau and  wrap.</p><p>     我正在开发一种称为内核的编程语言。内核是Lisp的一种保守的，类似于Scheme的方言，其中的一切都是一流的。 ＆＃34;但是，＆＃34;您可能会问，“不是所有在Scheme中都是一流的对象？” （很高兴你问到。）不，他们不是。特殊形式的组合器是第二类对象。要借用克里斯托弗·斯特拉奇（Christopher Strachey）对一等和二等物体的原始描述中的短语，它们必须亲自以自己的名字出现。 （Scheme中还有其他几种第二类对象，但是最常见的形式是组合器。）一流的可操作组合器（即，其操作数从未被求值的一流的组合器）的思想已经存在。很长时间。直到1970年代，主流Lisps一直以传统的fexprs命名这类生物，但由于它们与lambda构造的普通程序不正交，因此它们使语言的语义混乱不清。主流Lisps动态调整范围的时间（一种语言功能，对于fexpr造成的问题要比对功能较弱的宏造成的问题更多）。内核通过将经典的lambda构造函数分为两个正交部分来消除非正交性问题，其中一个是一流操作员的内核构造函数。运算符的原始构造函数是一个称为$ vau的运算符，它在语法和语义上与Scheme的lambda几乎相同，不同之处在于它构造的组合器是可运算的。应用程序的原始构造函数（即，其操作数被评估的组合器）是一个称为wrap的应用程序。 wrap接受一个参数，该参数必须是组合器，并构造一个应用程序，该应用程序将其参数（评估其操作数的结果）传递给指定的组合器。可以使用应用程序拆包来提取任何应用程序的基础组合器。还有一个名为$ lambda的运算符的构造函数构造函数，几乎与Scheme的lambda一样-但是内核的$ lambda不是原始的：它可以使用$实现为复合运算符打包。</p><p> First-class operatives aren&#39;t all there is to Kernel,just the most immediately obvious difference from most Lisps. The mandate of the Kernel language is to have a clean design,flowing from a broad design philosophyas refined by a series of more specific design guidelines—just one of which is that all manipulable entities should be first-class. Some other neat (IMHO) features of Kernel are uniform compound definiends.  (Eliminates the motive for multiple-value returns.) continuation guarding.  (Exception-handling &#34;done right&#34;.) keyed dynamic variables.  (Fluid variables &#34;done right&#34;.) encapsulation types.  (Enforced abstraction meets latent typing. Inspired by Morris&#39;s  seals. Gives Kernel&#39;s implementation of promises a fundamentally different flavor than those of  SRFI-45.)  uniform handling of cyclic lists. (Without this, cyclic lists wouldn&#39;t be entirely first-class, since they couldn&#39;t be used in ways one ordinarily expects of objects, such as testing via  equal?.)</p><p> 一流的操作人员并不是内核所能提供的，只是与大多数Lisps最为明显的区别。内核语言的任务是要有一个干净的设计，它源于广泛的设计理念，并通过一系列更具体的设计准则进行了完善-其中之一就是所有可操作的实体都应该是一流的。内核的其他一些简洁（IMHO）功能是统一的复合定义。 （消除了多值回报的动机。）持续保护。 （异常处理＆＃34;正确执行＆＃34;。）为动态变量设置了键。 （流体变量“正确完成”。）封装类型。 （强制抽象遇到潜在的输入。受Morris的印记启发。为Kernel的实现Promise提供了与SRFI-45根本不同的味道。）统一处理循环列表。 （否则，循环列表将不会完全是一流的，因为循环列表不能以人们通常期望的对象使用方式，例如通过均等测试。）</p><p>The  Revised  -1 Report on the Kernel Programming Language(revised 29 October 2009)is available in pdf and gzipped postscript. On the theoretical side, the primary resource is my doctoral dissertation,  Fexprs as the basis of Lisp function application; or,  $vau: the ultimate abstraction, which treats pure and impure vau-calculi. I gave a talk at NEPLS in fall 2007that described pure vau-calculi( abstract ;   script ;   slides (PDF,  not meant to be printed)). A pure vau-caluclus is also described (even more lightly)in Appendix C of the Kernel Report(&#34;De-trivializing the theory of fexprs&#34;).  The place to look for implementations of Kernel, these days, is a blog post The Kernel Underground,at Manuel Simoni&#39;s  The Axis of Eval. I did, upon a time, have my own pseudo-prototype implementation,called SINK (&#34;Scheme-based Interpreter for Not-quite Kernel&#34;),meant to be mostly compatible with unextended R5R Scheme;it didn&#39;t recognize some Kernel tokens, was slow as molasses...it ran, more than I could say for the Java-based interpreterI started years ago and never found time to finish. I used SINK to debug library implementations for the Kernel Report,and to play around with guarded continuations. I suspect it&#39;s suffered from bitrot, since. For whatever it&#39;s worth, here it is as a gzipped tarball: sink-01m10.tar.gz.</p><p>内核编程语言的修订版-1报告（2009年10月29日修订）以pdf和压缩后的脚本形式提供。从理论上讲，主要资源是我的博士学位论文，Fexprs作为Lisp函数应用的基础；或$ vau：最终的抽象，用于处理纯净和不纯净的vau-calculi。我在2007年秋季的NEPLS上发表了一个演讲，描述了纯vau-calculi（摘要;脚本;幻灯片（PDF，并非意在打印））。内核报告的附录C中也描述了一个纯vau-caluclus（甚至更浅）（“平凡的fexprs理论”）。如今，寻找内核实现的地方是博客文章《地下内核》，作者曼努埃尔·西蒙尼（Manuel Simoni）的《评估轴》。曾经有一段时间，我有自己的伪原型实现，称为SINK（基于方案的非内核解释器），主要与未扩展的R5R方案兼容；它并没有实现。 ; t不能识别某些内核令牌，因为糖蜜很慢...它的运行速度，比我几年前开始但从未发现完成时间的基于Java的解释器所能说的还要多。我使用SINK调试内核报告的库实现，并使用受保护的延续。从那以后，我怀疑它遭受了腐烂。无论它的价值如何，这里都是一个压缩的tarball：sink-01m10.tar.gz。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.cs.wpi.edu/~jshutt/kernel.html">https://web.cs.wpi.edu/~jshutt/kernel.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>