<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于这些矢量图标（2011） About those vector icons (2011)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">About those vector icons (2011)<br/>关于这些矢量图标（2011） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:48:49</div><div class="page_narrow text-break page_content"><p>Why can’t we just use vector-based icons in our application? This question, in a variety of reinterpretations, keeps on resurfacing in various forums, blogs and articles. It is asked in the context of desktop applications where the same icon is used in different ways, starting from very small 16*16 icons in file lists, up to 128*128 icons used on the dock and all the way to 512*512 icons that mostly serve to highlight the artistic capabilities of icon designers, at least until the computing world is taken over by 1200dpi desktop displays. It is also asked in the context of native mobile applications for the Android platform, where a single vector icon (in SVG format) is proposed as the replacement for multiple versions of the same icon, each optimized for the specific density bucket (usually medium and high).</p><p>为什么我们不能只在应用程序中使用基于矢量的图标？通过各种重新解释，这个问题在各种论坛，博客和文章中不断出现。在桌面应用程序的上下文中，要求以不同的方式使用相同的图标，从文件列表中的很小的16 * 16图标开始，到扩展坞上使用的128 * 128图标，一直到512 * 512的图标。至少在1200dpi桌面显示器取代计算世界之前，它主要是用来突出图标设计师的艺术能力。在Android平台的本机移动应用程序的上下文中，也有人提出要提出一个矢量图标（SVG格式）来代替同一图标的多个版本的建议，每个版本都针对特定密度桶（通常是中等和高）。</p><p> At first glance, both designers and developers only stand to gain from switching to creating their icons in vector format. A designer is going to create a single version of the icon in his tool of choice, hand it off to the developer to add to the project structure, and have the runtime scale the combined shapes of the icon to whatever context it is used in – be it the small icons for the action bar, or an extra large icon for the “about” page. In fact, a lot of comments on the articles and blog posts referenced later in this entry indicate that this approach works quite well. At least, technically. And so, to summarize the feeling of discontent, Y U NO SVG?</p><p> 乍一看，设计人员和开发人员都只能从切换到创建矢量格式的图标中受益。设计师将在他选择的工具中创建图标的单个版本，将其交给开发人员以添加到项目结构中，并使运行时将图标的组合形状缩放到所使用的任何上下文–是操作栏上的小图标，还是“关于”页面上的超大图标。实际上，在本条目后面引用的文章和博客文章中，有很多评论表明该方法效果很好。至少在技术上。因此，总结一下不满的感觉，是吗？</p><p> A few days ago I invited one of our visual designers to lunch and asked him about the general process of creating icons for multiple screen resolutions (for the core Android experience). The answer was, at least to me, quite surprising. The first stage happens in a sketchbook or on a whiteboard, where different ideas, shapes and combinations are explored to find the iconography that works well within the overall direction of the platform, while still providing a distinctive shape and form for the specific action or object represented by the icon. Then the flow transitions to the computer, with Adobe Illustrator and Fireworks being the most popular choices. There, the designers create the “master” version of the icon – in a vector format. This version is scaled down to all target resolutions (medium, high, sometimes low and, most recently, extra high), and this is where the fun begins. This is where the designer looks at the scaled down version of the icon, for each resolution, and begins a sometimes painstaking process of pixel-perfecting the visuals.</p><p> 几天前，我邀请我们的一名视觉设计师吃午餐，并问他关于为多种屏幕分辨率创建图标的一般过程（针对Android的核心体验）。答案至少对我来说是令人惊讶的。第一阶段发生在素描簿或白板上，在其中探索不同的想法，形状和组合，以找到在平台的整体方向上均能正常工作的图像，同时仍为特定动作或对象提供独特的形状和形式由图标表示。然后，流程转移到计算机，其中Adobe Illustrator和Fireworks是最受欢迎的选择。设计师在那里以矢量格式创建图标的``主版''版本。此版本按比例缩小到所有目标分辨率（中，高，有时低，最近是超高），这就是乐趣的开始。在这里，设计师可以针对每个分辨率查看按比例缩小的图标版本，并开始有时艰苦的像素完美视觉效果处理。</p><p> There’s a lot of art and a lot of craft involved in creating and maintaining a consistent visual iconography language within the specific application, and across the entire platform. Lines should be sharp, rounded corners should have consistent curvature, lighting and gradients should have consistent direction and amplitude. In addition, icons at smaller resolutions should not have too much visual detail, while icons at higher resolutions should not feel too sparse. This is illustrated in the “ Icon Design: Bitmap vs Vector” article by Firewheel design:</p><p> 在特定应用程序内以及整个平台上，创建和维护一致的视觉图标语言涉及很多艺术和工艺。线条应清晰，圆角应具有一致的曲率，照明和渐变应具有一致的方向和幅度。此外，分辨率较低的图标不应具有过多的视觉细节，而分辨率较高的图标不应感到过于稀疏。 Firewheel设计在“图标设计：位图与矢量”一文中对此进行了说明：</p><p>  The top row shows the hand-optimized versions of the same application icon at four different resolutions. The bottom row shows icons mathematically scaled from a single source. If you compare the relative sizes and detail complexity of various parts of the icons in the top row, you will see that they don’t scale at the same rate. Some parts grow linearly with the icon size, while some grow at a much slower rate. This is further illustrated in “ All the sizes of iOS app icons” by Neven Mrgan:</p><p>  第一行显示了四种不同分辨率下的同一应用程序图标的手动优化版本。底行显示了从单一来源数学上缩放的图标。如果您比较顶部各行图标各部分的相对大小和细节复杂程度，则会发现它们的缩放比例不同。有些部分随着图标大小线性增长，而另一些部分则以慢得多的速度增长。 Neven Mrgan在“ iOS应用程序图标的所有大小”中作了进一步说明：</p><p> It’s simply not possible to create excellent, detailed icons which can be arbitrarily scaled to very small dimensions while preserving clarity. Small icons are caricatures: they exaggerate some features, drop others, and align shapes to a sharp grid. Even if all icons could be executed as vectors, the largest size would never scale down well.</p><p> 根本不可能创建出色，详细的图标，而这些图标可以在保持清晰度的情况下任意缩放到很小的尺寸。小图标是讽刺漫画：它们夸大了某些功能，放下了其他功能，并将形状与清晰的网格对齐。即使所有图标都可以作为矢量执行，最大尺寸也永远不会缩小。</p><p>  Note that scaling down works to about 64 px; after that, shapes have to be redrawn, simpler and clearer, in order to read. The sidebar version of the icon is entirely different, in fact; since we know it will be shown in the sidebar, it’s not so important that it look like a folder, and other features can be emphasized instead. Creating the large icon as a vector shape –which, to be clear,  you should be doing! – won’t help where clarity is really needed: at small sizes. High-resolution displays will in fact make this problem more urgent because  today’s 64 px is tomorrow’s 128 px. We’ll have to refine ever larger icons.</p><p>  请注意，缩小比例约为64像素;之后，必须重新绘制形状，使其更简单，更清晰，以便阅读。实际上，图标的侧边栏版本完全不同。由于我们知道它会显示在侧边栏中，因此看起来像一个文件夹并不重要，可以强调其他功能。将大图标创建为矢量形状-显然，您应该这样做！ –在真正需要清晰度的地方无济于事：小尺寸。高分辨率显示器实际上将使这个问题更加紧急，因为今天的64像素是明天的128像素。我们必须优化更大的图标。 </p><p> Dave Shea takes a closer look at the mechanics of optimizing the original shapes and lines for smaller size in the “ Icon Design: Sizing“:</p><p>Dave Shea在“图标设计：大小调整”中仔细研究了优化原始形状和线条以减小尺寸的机制：</p><p> The solution is to start with the reduced version, and tweak it at the individual pixel level. Make the details fit within the pixel grid, remove extra detail that’s causing blur, or even  add extra detail if it helps you get to your end goal. Whatever it takes, the solution is to provide a critical eye to the problem and tweak until you get a result you’re happy with, which is why the size variations are so much extra work.</p><p> 解决方案是从缩小版本开始，然后在单个像素级别进行调整。使细节适合像素网格，删除会导致模糊的多余细节，或者如果可以帮助您达到最终目标，甚至添加额外细节。无论采取什么措施，解决方案都是认真研究问题并进行调整，直到获得满意的结果为止，这就是尺寸变化如此之多的原因。</p><p> In the calendar above, you’ll notice what I’ve tweaked the two different sizes so the inner boxes end up with whole pixel values on either side. To do this I’ve had to reduce the size of the boxes at 24×24, and actually create more boxes at 16×16. I couldn’t come up with a combination of 4 columns with a 1 pixel wide border that would fit within the space allotted at that smaller size, the only workable combination I found involved adding an extra column and dropping a row. The icon is a bit different than the 32×32 equivalent, but it’s clearly derived from the larger one and works as an acceptable size variation.</p><p> 在上面的日历中，您会注意到我对两种不同尺寸进行了调整，因此内部框最终在两侧均具有整个像素值。为此，我不得不将框的尺寸缩小为24×24，实际上创建了16×16的框。我无法提出4列具有1像素宽边框的组合，该边框将适合以较小尺寸分配的空间，我发现唯一可行的组合涉及添加额外的列并删除一行。该图标与32×32等效图标略有不同，但显然是从较大的图标衍生而来的，可以作为可接受的尺寸变化。</p><p> Additional examples of small icons moving shapes around and even “losing” some of them can be seen in a variety of modern applications and UI toolkits. Here is an example from the widely-lauded  iA Writer for Mac application:</p><p> 在各种现代应用程序和UI工具箱中，可以看到小图标移动形状甚至“丢失”其中一些图标的其他示例。这是广受好评的Mac版iA Writer应用程序的示例：</p><p>  While the central element – a slanted sky blue caret – preserves the overall shape, angle and gradient, the text next to it begins “losing” characters the closer you get to 32*32 size. The 16*16 icon is just the caret, with no characters next to it.</p><p>  尽管中心元素（倾斜的天蓝色插入符号）保留了整体形状，角度和渐变，但靠近32 * 32尺寸，其旁边的文本开始“丢失”字符。 16 * 16图标只是插入符号，旁边没有字符。</p><p> The same approach to simplifying the shapes, textures, perspective and density can be seen in the system icons  introduced in GNOME 3.0:</p><p> 在GNOME 3.0中引入的系统图标中可以看到用于简化形状，纹理，透视图和密度的相同方法：</p><p>    If you trace the progression of the transition to smaller icon sizes across these three icons (and additional icons on  the original entry), you will see a consistent approach that starts stripping away dimensionality, complexity, textures, gradients and density, preserving not only the overall shape and feel of the icon, but also the consistency of iconography language across all icons of the same size.</p><p>    如果您在这三个图标（以及原始条目上的其他图标）上跟踪过渡到较小图标大小的进度，则会看到一致的方法，该方法开始去除尺寸，复杂性，纹理，渐变和密度，不仅保留了图标的整体形状和感觉，以及在相同大小的所有图标上图标语言的一致性。 </p><p> If you do not wish to spend extra time to pixel-perfect your icons at smaller sizes, using a single-source vector format as the “master” and scaling down to any arbitrary size is a perfect fit for SVG. In this context,  the following quote from the self-titled “Graphics Ninja” Zack Rusin talking about SVG in KDE is quite illuminating:</p><p>如果您不希望花费更多的时间来以较小的尺寸完成图标的像素完美处理，则可以使用单一源矢量格式作为“主版”并缩小到任意大小，这非常适合SVG。在这种情况下，以下自引自名的“图形忍者” Zack Rusin引述了KDE中的SVG：</p><p> The loss of quality in vector graphics at small size is a severe problem. Rendering vector graphics primitives at low resolutions introduces a certain amount of blur into the output. This is mainly caused by horizontal and vertical primitives which happen to fall between pixel boundaries, which in turn makes the anti-aliasing algorithms try to cope with it by rasterizing two, instead of one rows/columns but at a lower color intensity. For primitives which are rendered at small sizes the goals of “resolution independence” and “preserving their good looks across resolutions” diverges a lot. We have the former, we need the latter.</p><p> 小尺寸矢量图形的质量损失是一个严重的问题。以低分辨率渲染矢量图形基元会在输出中引入一定量的模糊。这主要是由水平和垂直图元恰好落在像素边界之间引起的，这反过来又使反走样算法尝试通过光栅化两个而不是一个行/列，但以较低的颜色强度对其进行光栅化处理。对于以小尺寸渲染的图元，“分辨率独立性”和“在各种分辨率下保持其良好外观”的目标大相径庭。我们有前者，我们需要后者。</p><p> One of the ways of dealing with this problem is hinting. The problem of hinting vector graphics primitives has been extensively researched by the way of font technologies. Grid-fitting (aka. “font hinting”) is a crucial step on the way to produce legible output at small sizes for a lot of fonts. Hinting can be manual (e.g TrueType has a stack-based language for it, each glyph in the font contains its own little hint program and as a result of running that program control points for the outlines can be adjusted in any way the creator of the hints desired) or automatic (as used by FreeType). An interesting medium is described in “Example-Based Hinting of TrueType Fonts” paper, in which a method of reusing hints from one font for another are described. All in all it’s a very common problem for fonts.</p><p> 提示此问题的方法之一。提示矢量图形基元的问题已通过字体技术进行了广泛研究。网格拟合（又称“字体提示”）是为许多字体以小尺寸生成清晰的输出的关键步骤。提示可以是手动的（例如，TrueType具有基于堆栈的语言，字体中的每个字形都包含其自己的小提示程序，由于运行该结果，轮廓的程序控制点可以通过任何方式来调整。提示）或自动（由FreeType使用）。在“基于示例的TrueType字体提示中”中描述了一种有趣的媒介，其中描述了一种将一种字体的提示重用于另一种字体的方法。总而言之，这是字体非常普遍的问题。</p><p> The research the engineers from the FreeType project conducted on auto-hinting is outstanding. Right now the way KDE artists go around this problem is by producing certain SVG icons with different viewport sizes. This allows them to manually adjust the rendering for certain native resolutions.</p><p> 来自FreeType项目的工程师在自动提示方面的研究非常出色。目前，KDE艺术家解决此问题的方法是通过生成具有不同视口大小的某些SVG图标。这使他们可以为某些原始分辨率手动调整渲染。</p><p> The reality of the situation is that without very high DPI displays the quality of small SVG renderings is going to suffer. A solution would involve introduction of either an auto-hinting algorithm or adding a declarative approach of specifying the hints which the artists could easily utilize. It’s a problem which affects all SVG users and should be handled in the standard itself.</p><p> 这种情况的现实情况是，没有很高的DPI显示器，小型SVG渲染的质量将受到影响。一种解决方案将涉及引入自动提示算法或添加声明性方法来指定艺术家可以轻松利用的提示。这个问题会影响所有SVG用户，应在标准本身中解决。</p><p> There are a lot of similarities between pixel-perfecting vector graphics and auto-hinting of font glyphs. Both aim to address a very similar problem. Both operate in a flow where the master version is created under extremely high resolutions to look well in booklets, portfolios and promotional material, but versions scaled down to the “real world” use suffer from poor grid fitting, detail clutter, detail loss and blurriness. In fact, some designers go as far as proposing to forgo the standalone icons altogether and use the advanced capabilities of type engines instead. Proposed by  Wayne Helman last year, it was further expanded upon by P.J. Onori in his “ Font-Embedding Icons: This Is a Big Deal” article that goes on to say:</p><p> 像素完美的矢量图形和字体字形的自动提示之间有很多相似之处。两者都旨在解决一个非常相似的问题。两者的工作流程都是以极高的分辨率创建主版本，以便在小册子，公文包和促销材料中看起来都很好，但是按比例缩小到“真实世界”使用的版本会遇到网格拟合差，细节混乱，细节丢失和模糊的问题。 。实际上，一些设计师甚至建议完全放弃独立的图标，而改用类型引擎的高级功能。去年，由Wayne Helman提出，P.J。Onori在他的“字体嵌入图标：这是一件大事”中进一步加以扩展，并说：</p><p> The article was well-received, but I was honestly expecting more excitement around this idea. From my view, this now seems like  the way to set icons in a site. I feel strongly about the potential of this method, so I thought I would take the time to generate a font set for  Iconic and to talk about why we should all be using this method for displaying icons.</p><p> 这篇文章广受好评，但老实说，我希望这个想法会更加令人兴奋。在我看来，这现在似乎是在网站上设置图标的方式。我对这种方法的潜力深有感触，因此我想花点时间为Iconic生成字体集并讨论为什么我们都应该使用此方法来显示图标。 </p><p> Listing “one icon, infinite sizes” as one of the advantages, it seems to be a great solution, but only for duotone, or more precisely purely black and white, icons. In addition, it completely fails to address the giant elephant in the room – what to do for complex icons that do not scale well to small sizes? Type engines have two major approaches to solve this problem – embedding bitmaps and font hinting.</p><p>将“一个无限大小的图标”列为优势之一，这似乎是一个很好的解决方案，但仅适用于双色调或更确切地说是纯黑白图标。此外，它完全无法解决房间中的巨型大象-对于无法很好地缩放到小尺寸的复杂图标该怎么办？类型引擎有两种解决此问题的主要方法-嵌入位图和字体提示。</p><p> Embedding bitmaps is a rather straightforward approach. You start from a high-resolution master definition of the glyph, and identify those glyphs that do not scale down well past a certain point (lowercase ‘m’, ‘s’, ‘a’ and ‘g’ are usually among the prime suspects). For those glyphs, you hand-tweak the visuals for all target point sizes, export them as bitmaps and then embed the bitmaps as binary blobs in the font file. In fact, it can work the other way around,  as detailed by Simon Earshow, a typographer at Microsoft:</p><p> 嵌入位图是一种非常简单的方法。您从字形的高分辨率主定义开始，然后识别那些未在特定点之前缩小的字形（小写的“ m”，“ s”，“ a”和“ g”通常是主要可疑字符） ）。对于这些字形，您可以手动调整所有目标点大小的视觉效果，将它们导出为位图，然后将位图作为二进制斑点嵌入到字体文件中。实际上，它可以以其他方式工作，正如Microsoft的排版员Simon Earshow所详述的那样：</p><p> In the past I’ve been burned starting from outlines and trying to be extra clever in the hinting. So I finally deciding, ‘I’m better off grasping the nettle. What’s most important is to get the bitmaps right at the sizes people use most often.’   So instead of starting with outlines and then working to hint them for the screen, I started by simply making bitmap fonts. No outlines, just bitmaps.</p><p> 过去，我从大纲开始就精疲力尽，并在提示方面变得更加聪明。所以我最终决定，‘我最好先抓荨麻。最重要的是使位图正确地适应人们最常用的尺寸。’因此，我从简单地制作位图字体开始，而不是从轮廓开始，然后在屏幕上提示它们。没有轮廓，只有位图。</p><p> Bitmaps are relatively easy to make and they show exactly how the fonts will look on-screen. This allowed us to make decisions about sizes, weights, and distinctions between serif, sans, roman, italic, all viewed in context. Working this way we came up with a definition for a certain number of critical sizes and weights.</p><p> 位图相对容易制作，并且可以精确显示字体在屏幕上的外观。这使我们能够根据上下文来决定大小，权重以及衬线，无衬线，罗马字，斜体字之间的区别。通过这种方式，我们提出了一些关键尺寸和重量的定义。</p><p> Once the key bitmaps were done, I very carefully wrapped an outline around them. I always have in mind that this outline will then be given to the person responsible for hinting–and they’ll need to be able to hint outline to get back, pixel for pixel, to the bitmap faces where we started.</p><p> 关键位图完成后，我非常仔细地在它们周围包裹了轮廓。我始终牢记，然后将轮廓线交给负责提示的人-他们将需要能够提示轮廓线以逐像素地返回到我们开始的位图面。</p><p> Embedding bitmaps worked well on CRT monitors, but did not scale into the world of LCD monitors and subpixel rendering. This is where hinting comes into play, as summarized in  this great overview by Peter Bil’ak on Typotheque:</p><p> 嵌入位图在CRT显示器上效果很好，但无法扩展到LCD显示器和亚像素渲染的领域。正如彼得·比拉克（Peter Bil’ak）在Typotheque上的精彩概述所总结的，这就是提示的作用：</p><p> This is exactly what hinting is about: programming instructions that fine-tune a font’s rasterisation, the process by which its mathematically ideal outlines are mapped onto a monitor’s pixels. Hinting can control the heights and widths of a font’s uppercase and lowercase letters, the widths of its individual lines, the amount of white space around letters, the size at which uppercase letters start to use different stem-widths from lowercase letters, how the angle of italic characters changes to best fit the pixel grid, and many other extremely technical details, all on a pixel-by-pixel basis. If this sounds like a rather tedious, time-consuming activity, it is, (even for type designers, who are accustomed to tedious, time-consuming activities).</p><p> 这正是暗示的意义：对字体的光栅化进行微调的编程指令，将数学上理想的轮廓映射到显示器像素的过程。提示可以控制字体的大小写字母的高度和宽度，其各行的宽度，字母周围的空白量，大写字母开始使用与小写字母不同的词干宽度的大小，角度斜体字符的更改最适合像素网格，以及许多其他非常技术性的细节，所有这些都是逐像素进行的。如果这听起来像是一个相当繁琐且耗时的活动，那就是（即使对于习惯于乏味且耗时的活动的字体设计人员而言）。 </p><p> The complexities of type hinting are illustrated in “ The raster tragedy at low resolution” article by Beat Stamm that gives just a small taste of what it takes to hint a single glyph – not to mention the implementation complexity of the type engine itself.</p><p>Beat Stamm在“低分辨率栅格悲剧”一文中说明了类型提示的复杂性，该文章对暗示单个字形的含义仅作了一点介绍，更不用说类型引擎本身的实现复杂性了。</p><p>   Beat Stamm even followed up with  RasterTragedy.com, delving much deeper into anti-aliasing, hinting, layout and rendering across a wide spectrum of modern type engines.</p><p>   Beat Stamm甚至还通过RasterTragedy.com跟进，深入研究了各种现代引擎的抗锯齿，提示，布局和渲染。</p><p>  To further appreciate the complexities of creating a type-hinting program for a specific glyph, you can start with  this “Hello world” tutorial that hints the uppercase ‘L’,  follow up with  more complex examples for glyphs with curves, serifs and slanted stems, and finally revel in the  full TrueType instruction set, the complexity of which rivals, if not exceeds, that of SVG itself.</p><p>  为了进一步了解为特定字形创建类型提示程序的复杂性，您可以从本《 Hello world》教程开始，该教程提示大写的``L''，接着是带有曲线，衬线和倾斜茎的字形的更复杂示例，最后展示了完整的TrueType指令集，该指令集的复杂度甚至可以超过SVG本身。</p><p>  Throughout the article I stayed away from the complexity of the SVG format itself, and its full implementations. There’s a simple reason – if the format is powerful enough to address the needs and requirements of designers who pay special attention to pixel-level details, it will provide a natural push to have the full implementation of that format to be included in the UI toolkits and platforms. In its present state, however, SVG is not there. Furthermore, extending SVG with capabilities similar to those of TrueType hinting instructions will not only make the full implementation much more complex. A much more important question is whether it’s going to make it easier for icon designers to create a single vector-based version of their icons?</p><p>  在整篇文章中，我都避免了SVG格式本身及其完整实现的复杂性。原因很简单–如果格式足够强大，可以满足特别关注像素级细节的设计人员的需求，那么自然就会推动将这种格式的完整实现包含在UI工具包中和平台。但是，在目前状态下，SVG尚不存在。此外，以类似于TrueType提示指令的功能扩展SVG不仅会使完整实现更加复杂。一个更重要的问题是，这是否会使图标设计人员更轻松地创建基于矢量的单个图标版本？</p><p> If you’ve followed my reasoning up until now, the simple answer is no, it will not. When each icon line, each icon stroke, each icon shape need to be hinted for precise rendering under small sizes, when you need to go well beyond each individual layer to make sure that they are hinted as one collective assembly, when you need to learn an extra set of tools that will undoubtedly go beyond the current instruction set of type engines as it’ll need to support lighting, gradients, collapsing and hiding detail – this is just not a tenable solution.</p><p> 如果您一直遵循我的推理，那么简单的答案是“否”，不是。当需要学习每个图标行，每个图标笔划，每个图标形状时，需要在小尺寸下进行精确渲染，而当您需要远远超出每个单独的图层以确保将它们提示为一个整体时，毫无疑问，还有额外的工具集将超出类型引擎的当前指令集，因为它需要支持照明，渐变，折叠和隐藏细节–这不是一个可行的解决方案。</p><p> As to the process of pixel-perfecting icons? Once you scaled down the master version down to all the target sizes, you can do different things. You can start moving pixels directly, at the expense of redoing the same exact thing when you go back and change the master. Or you can go back to the master and create “secondary” masters, one for each target size. Each secondary master is not meant to be used at the highest resolution, but is instead optimized to create the best pixel-level version when it is scaled down to the target size. The down side is that once the original master is changed, you have many more tweaks to do.</p><p> 至于像素完美的图标的过程？将主版本缩小到所有目标大小后，您可以执行其他操作。您可以直接开始移动像素，但要以回去更换母板时重做相同的事情为代价。或者，您可以返回到母版并创建“辅助”母版，每个目标尺寸一个。每个次要母版并非旨在以最高分辨率使用，而是经过优化以缩小到目标尺寸时创建最佳像素级版本。不利的一面是，一旦更改了原始母版，您将需要进行更多调整。</p><p> A final thought about the high-resolution displays and the quote above from Neven Mrgan. Making a leap of faith, let’s say that in 50 years we’ll have screens with resolution of 1200dpi (which is “only” four times the resolution of iPhone 4 and Galaxy Nexus, but sixteen times as many pixels in a square inch). In such a world, a single grain of sand will cover four 16*16 pixel icons. In fact, all the mentions of small-size icons in this article refer to the physical scale of small – not the pixel scale. To maintain a usable touch interface, an interface that can be easily scanned with a human eye, you will want to maintain the current physical scale of the icons – making them much larger on the pixel scale. The smallest icon on such a device with the current UI building blocks will be around 128*128 pixels. However, it does not automatically mean that you can all of a sudden cram all the fine details from your (even higher resolution) master icon into the available pixel space. As each pixel gets smaller, it does not mean that you want to progressively increase the detail complexity and density.</p><p> 关于高分辨率显示器和Neven Mrgan的上述报价的最终思考。相信我们的飞跃，假设50年后我们将拥有分辨率为1200dpi的屏幕（“仅”是iPhone 4和Galaxy Nexus的分辨率的四倍，但像素的平方英寸却是它的十六倍）。在这样的世界中，单个沙粒将覆盖四个16 * 16像素的图标。实际上，本文中所有提到的小尺寸图标都是指小尺寸的物理比例，而不是像素比例。为了维护可用的触摸界面（可以用人眼轻松扫描的界面），您将需要保持图标的当前物理比例-使它们在像素比例上更大。在具有当前用户界面构建块的此类设备上，最小的图标约为128 * 128像素。但是，这并不意味着您可以突然将所有精细细节从（甚至更高分辨率的）主图标填充到可用的像素空间中。随着每个像素变小，这并不意味着您要逐渐增加细节的复杂性和密度。 </p><p> As Neven points out, clarity is king, and in such a future icon designers will have to hand-tweak even more icon sizes. And unless the future is a concept video where everybody is walking around with high-end devices that have seemingly unlimited battery life and connectivity, the feature gap between high-end and low-end devices will be even larger. And in such a future, icon designers will have to maintain multiple versions of the same pixel-size icons, each version pixel-perfected for use on a device with a specific density. But then again, in 50 years there may as well be a completely different way to present information and a completely different technology to interact with.</p><p>正如Neven指出的那样，清晰度是至上的，在这样的未来中，图标设计人员将不得不手动调整更多的图标尺寸。 而且，除非未来是一个概念视频，每个人都在使用似乎具有无限电池寿命和连接性的高端设备来回走动，否则高端和低端设备之间的功能差距将更大。 在这样的未来，图标设计人员将不得不维护相同像素大小的图标的多个版本，每个版本都可以完美像素化，以用于具有特定密度的设备。 但是话又说回来，在50年中，可能还存在一种完全不同的方式来呈现信息以及一种完全不同的技术来进行交互。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.pushing-pixels.org/2011/11/04/about-those-vector-icons.html">https://www.pushing-pixels.org/2011/11/04/about-those-vector-icons.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/矢量/">#矢量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vector/">#vector</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图标/">#图标</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>