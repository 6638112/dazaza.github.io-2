<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>核心战争Core War</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Core War<br/>核心战争</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 23:39:11</div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  Core War is a 1984  programming game created by D. G. Jones and  A. K. Dewdney in which two or more battle programs (called &#34;warriors&#34;) compete for control of a  virtual computer. These battle programs are written in an abstract  assembly language called  Redcode.</p><p>Jump to navigation Jump to search Core War是由D.G.Jones和a.K.Dewdney于1984年开发的一款编程游戏，其中包含两个或多个作战程序（称为&#34；勇士&#34；）争夺虚拟计算机的控制权。这些作战程序是用一种叫做Redcode的抽象汇编语言编写的。</p><p>   At the beginning of a game, each battle program is loaded into memory at a random location, after which each program executes one instruction in turn. The goal of the game is to cause the processes of opposing programs to terminate (which happens if they execute an invalid instruction), leaving the victorious program in sole possession of the machine.</p><p>在游戏开始时，每个作战程序都被随机加载到内存中，然后每个程序依次执行一条指令。游戏的目标是使对立程序的进程终止（如果它们执行无效的指令，就会发生这种情况），让获胜的程序完全掌握机器。</p><p> The earliest published version of Redcode defined only eight instructions. The ICWS-86 standard increased the number to 10 while the ICWS-88 standard increased it to 11. The currently used 1994 draft standard has 16 instructions. However, Redcode supports a number of different  addressing modes and (starting from the 1994 draft standard) instruction modifiers which increase the actual number of operations possible to 7168. The Redcode standard leaves the underlying instruction representation undefined and provides no means for programs to access it. Arithmetic operations may be done on the two address fields contained in each instruction, but the only operations supported on the instruction codes themselves are copying and comparing for equality.</p><p>最早发布的红码版本只定义了八条指令。ICWS-86标准将数字增加到10，而ICWS-88标准将数字增加到11。目前使用的1994年标准草案有16条说明。然而，Redcode支持多种不同的寻址模式和指令修饰符（从1994年的标准草案开始），这些修饰符将实际可能的操作数增加到7168。Redcode标准未定义底层指令表示，并且不提供程序访问它的方法。算术运算可以在每条指令中包含的两个地址字段上进行，但指令代码本身支持的唯一操作是复制和比较是否相等。</p><p> Each Redcode instruction occupies exactly one memory slot and takes exactly one cycle to execute. The rate at which a process executes instructions, however, depends on the number of other processes in the queue, as processing time is shared equally.</p><p>每个红码指令只占用一个内存插槽，执行周期正好为一个周期。然而，一个进程执行指令的速度取决于队列中其他进程的数量，因为处理时间是平均分配的。</p><p> The memory is addressed in units of one instruction. The memory space (or  core) is of finite size, but only  relative addressing is used, that is, address  0 always refers to the currently executing instruction, address  1 to the instruction after it, and so on. The maximum address value is set to equal one less than the number of memory locations, and will wrap around if necessary. As a result, there is a one-to-one correspondence between addresses and memory locations, but it is impossible for a Redcode program to determine any absolute address. A process that encounters no invalid or jump instructions will continue executing successive instructions endlessly, eventually returning to the instruction where it started.</p><p>内存以一条指令为单位寻址。内存空间（或内核）大小有限，但只使用相对寻址，也就是说，地址0总是指当前执行的指令，地址1指它后面的指令，依此类推。最大地址值设置为比内存位置数少一个，并在必要时环绕。因此，地址和内存位置之间存在一对一的对应关系，但红码程序不可能确定任何绝对地址。没有遇到无效或跳转指令的进程将继续无休止地执行连续的指令，最终返回到它开始的指令。</p><p> Instead of a single  instruction pointer a Redcode simulator has a  process queue for each program containing a variable number of instruction pointers which the simulator cycles through. Each program starts with only one process, but new processes may be added to the queue using the  SPL instruction. A process dies when it executes a  DAT instruction or performs a division by zero. A program is considered dead when it has no more processes left.</p><p>红码模拟器不是一个单一的指令指针，而是为每个程序提供一个进程队列，其中包含模拟器循环使用的数量可变的指令指针。每个程序只从一个进程开始，但可以使用SPL指令将新进程添加到队列中。一个进程在执行DAT指令或执行零除时死亡。当一个程序没有剩余的进程时，它被认为是死的。</p><p> Redcode and the MARS architecture provide no input or output functions. The simulator is a closed system, with the only input being the initial values of the memory and the process queues, and the only output being the outcome of the battle, i.e., which programs had surviving processes. Of course, the simulator may still allow external inspection and modification of the memory while the simulation is running.</p><p>Redcode和MARS架构不提供输入或输出功能。模拟器是一个封闭系统，唯一的输入是内存和进程队列的初始值，唯一的输出是战斗的结果，即哪些程序有幸存的进程。当然，在模拟运行时，模拟器仍然允许外部检查和修改内存。</p><p>  A number of versions of Redcode exist. The earliest version described by  A. K. Dewdney  [1] differs in many respects from the later standards established by the International Core War Society, and could be considered a different, albeit related, language. The form of Redcode most commonly used today is based on a draft standard submitted to the ICWS in 1994 that was never formally accepted, as the ICWS had become effectively defunct around that time. Development of Redcode, however, has continued in an informal manner, chiefly via online forums such as the  rec.games.corewar  [2]  newsgroup.</p><p>红码有很多版本。A.K.杜德尼[1]所描述的最早版本在许多方面与国际核心战争协会（International Core War Society）后来制定的标准不同，可以被视为一种不同的语言，尽管相关。如今最常用的红码形式基于1994年提交给ICWS的一份标准草案，该草案从未被正式接受，因为当时ICWS实际上已经失效。然而，红码的开发仍在以非正式的方式进行，主要是通过rec.games等在线论坛。corewar[2]新闻组。</p><p>  Warriors are commonly divided into a number of broad categories, although actual warriors may often combine the behavior of two or more of these. Three of the common strategies ( replicator,  scanner and  bomber) are also known as  paper, scissors and stone, since their performance against each other approximates that of their namesakes in the well-known playground game.  [3]</p><p>战士通常被分为许多大的类别，尽管实际的战士通常会结合其中两种或两种以上的行为。三种常见的策略（复制器、扫描仪和轰炸机）也被称为纸、剪刀和石头，因为它们在著名的游乐场游戏中彼此的表现接近同名者。[3]</p><p> A replicator makes repeated copies of itself and executes them in parallel, eventually filling the entire core with copies of its code. Replicators are hard to kill, but often have difficulty killing their opponents. Replicators therefore tend to score a lot of ties, particularly against other replicators.</p><p>复制器对自身进行重复复制并并行执行，最终用其代码的副本填充整个内核。复制者很难被杀死，但通常很难杀死对手。因此，复制因子往往会取得很多联系，尤其是与其他复制因子相比。</p><p> A  silk is a special type of very rapid replicator, named after  Silk Warrior  [4] by Juha Pohjalainen. Most modern replicators are of this type. Silk replicators use parallel execution to copy their entire code with one instruction, and begin execution of the copy before it is finished.  [5]</p><p>丝绸是一种特殊类型的快速复制体，以Juha Pohjalainen的《丝绸战士》命名。大多数现代复制子都是这种类型的。Silk Replicator使用并行执行，用一条指令复制整个代码，并在复制完成之前开始执行。[5]</p><p> A scanner is designed to beat replicators. A scanner does not attack blindly, but tries to locate its enemy before launching a targeted attack. This makes it more effective against hard-to-kill opponents like replicators, but also leaves it vulnerable to decoys. A scanner usually bombs memory with   SPL 0 instructions. This causes the enemy to create a huge number of processes which do nothing but create more processes, slowing down useful processes. When the enemy becomes so slow that it is unable to do anything useful, the memory is bombed with   DAT instructions. Scanners are also generally more complex, and therefore larger and more fragile, than other types of warriors.  [6]</p><p>扫描器是用来打败复制者的。扫描器不会盲目攻击，但会在发起目标攻击之前尝试定位敌人。这使得它能更有效地对付复制者等难以杀死的对手，但也使它容易受到诱饵的攻击。扫描仪通常用SPL 0指令轰炸内存。这会导致敌人创建大量进程，这些进程什么也不做，只会创建更多进程，从而降低有用进程的速度。当敌人变得如此缓慢以至于无法做任何有用的事情时，DAT指令会轰炸内存。扫描器通常也比其他类型的战士更复杂，因此更大、更脆弱。[6]</p><p> A  one-shot is a very simple scanner that only scans the core until it finds the first target, and then permanently switches to an attack strategy, usually a core clear.  Myrmidon  [7] by Roy van Rijn is an example of a oneshot.</p><p>一次性扫描器是一种非常简单的扫描器，它只扫描核心，直到找到第一个目标，然后永久切换到攻击策略，通常是核心清除。罗伊·范·里恩（Roy van Rijn）的《米尔米登》（Myrmidon[7]）就是一个单枪匹马的例子。</p><p> A bomber blindly copies a &#34;bomb&#34; at regular intervals in the core, hoping to hit the enemy. The bomb is often a   DAT instruction, although other instructions, or even multi-instruction bombs, may be used. A bomber can be small and fast, and they gain an extra edge over scanning opponents since the bombs also serve as convenient distractions. Bombers are often combined with imp spirals to gain extra resiliency against replicators.</p><p>轰炸机盲目复制&#34；炸弹&#34；每隔一段时间在核心，希望击中敌人。炸弹通常是DAT指令，但也可以使用其他指令，甚至多指令炸弹。轰炸机可以体积小、速度快，而且比扫描对手更有优势，因为炸弹也可以方便地分散注意力。轰炸机通常与imp螺旋机结合，以获得对抗复制机的额外弹性。</p><p> A vampire tries to make its opponent&#39;s processes jump into a piece of its own code called a &#34;pit&#34;. Vampires can be based on either bombers or scanners. A major weakness of vampires is that they can be easily attacked indirectly, since they must by necessity scatter pointers to their code all over the core. Their attacks are also slow, as it takes an extra round for the processes to reach the pit.  myVamp  [8] by Paulsson is an example of a vampire.</p><p>吸血鬼试图让它的对手#39；s进程跳转到一段自己的代码中，称为&#34；坑&#34；。吸血鬼可以基于轰炸机或扫描仪。吸血鬼的一个主要弱点是，他们很容易受到间接攻击，因为他们必须将指向代码的指针分散到整个核心。他们的攻击速度也很慢，因为过程需要额外一轮才能到达矿坑。保尔森的《我的鞋面》就是吸血鬼的一个例子。</p><p> Imps are named after the first ever published warrior,  Imp  [9] by  A. K. Dewdney, a trivial one-instruction mobile warrior that continually copies its sole instruction just ahead of its  instruction pointer. Imps are hard to kill but next to useless for offense. Their use lies in the fact that they can easily be spawned in large numbers, and may survive even if the rest of the warrior is killed.</p><p>Imp是以A.K.杜德尼（A.K.Dewdney）出版的第一本《勇士》（warrior，Imp[9]）命名的。A.K.杜德尼（A.K.Dewdney）是一个微不足道的单指令移动勇士，不断地在其指令指针之前复制其唯一的指令。小鬼很难被杀死，但在进攻上几乎毫无用处。它们的用途在于，它们很容易大量繁殖，即使其他战士被杀，它们也可能存活下来。</p><p> An  imp ring (or  imp spiral) consists of imps spaced at equal intervals around the core and executing alternately. The imps at each arm of the ring/spiral copy their instruction to the next arm, where it is immediately executed again. Rings and spirals are even harder to kill than simple imps, and they even have a (small) chance of killing warriors not protected against them. The number of arms in an imp ring or spiral must be  relatively prime with the size of the core.</p><p>imp环（或imp螺旋）由围绕堆芯等间距分布的imp组成，并交替执行。环/螺旋的每个臂上的IMP将其指令复制到下一个臂上，然后立即再次执行。环和螺旋比简单的小鬼更难杀死，它们甚至有（很小）机会杀死没有受到保护的战士。imp环或螺旋中的臂数必须与核心的大小相对最佳。</p><p> A quickscanner attempts to catch its opponent early by using a very fast unrolled scanning loop. Quickscanning is an early-game strategy, and always requires some other strategy as a backup. Adding a quickscanning component to a warrior can improve its score against long warriors such as other quickscanners. However, the unrolled scan can only target a limited number of locations, and is unlikely to catch a small opponent.</p><p>快速扫描器试图通过快速展开的扫描环尽早抓住对手。快速扫描是一种早期的游戏策略，总是需要一些其他策略作为备份。向战士添加快速扫描组件可以提高其在对抗其他快速扫描者等长战士时的得分。然而，展开扫描只能针对有限数量的位置，不太可能抓住一个小对手。</p><p> A core clear sequentially overwrites every instruction in the core, sometimes even including itself. Core clears are not very common as stand-alone warriors, but are often used as an end-game strategy by bombers and scanners.</p><p>核心清除按顺序覆盖核心中的每条指令，有时甚至包括其自身。核心清除作为独立战士并不常见，但通常被轰炸机和扫描器用作最终策略。</p><p>  With an understanding of  Core War strategies, a programmer can create a warrior to achieve certain goals. Revolutionary ideas come once in a while; most of the time, however, programmers base their programs on already published warriors. Using optimizers such as OptiMax or core-step optimizer tools, a more effective warrior can be created.</p><p>有了对核心战争策略的理解，程序员可以创造一个战士来实现特定的目标。革命思想时不时出现；然而，大多数时候，程序员的程序都是基于已经发布的勇士。使用OptiMax或core step optimizer工具等优化器，可以创建更有效的勇士。</p><p> Warriors can also be generated by  genetic algorithms or  genetic programming. Programs that integrate this evolutionary technique are known as  evolvers. Several evolvers were introduced by the  Core War community and tend to focus on generating warriors for smaller core settings. The latest evolver with significant success was  μGP  [10] which produced some of the most successful nano and tiny warriors. Nevertheless, evolutionary strategy still needs to prove its effectiveness on larger core settings.  [11]</p><p>战士也可以通过遗传算法或遗传编程生成。集成这种进化技术的程序称为进化程序。核心战争社区引入了几个进化者，他们倾向于为较小的核心环境生成战士。最新成功的进化者是μGP[10]，它产生了一些最成功的纳米和微型战士。然而，进化策略仍然需要在更大的核心环境中证明其有效性。[11]</p><p>  Core War was inspired by a  self-replicating program called  Creeper and a subsequent program called Reaper that destroyed copies of Creeper.  [12] Creeper was created by Bob Thomas at  BBN.  [13] Dewdney was not aware of the origin of Creeper and Reaper and refers to them as a rumor originating from  Darwin and the worm experiments of  Shoch and Hupp. The 1984   Scientific American article on  Core War  [12] nevertheless cites the game   Darwin, played by  Victor A. Vyssotsky,  Robert Morris, and  Douglas McIlroy at  Bell Labs in 1961. The word &#34;Core&#34; in the name comes from  magnetic-core memory, an obsolete  random-access memory technology.</p><p>核心战争的灵感来自一个名为“爬行者”的自我复制程序和一个名为“收割者”的后续程序，该程序销毁了爬行者的副本。[12] 爬行动物是由BBN的鲍勃·托马斯创作的。[13] 杜德尼不知道匍匐植物和收割者的起源，并将其称为源自达尔文以及肖赫和胡普的蠕虫实验的谣言。然而，1984年《科学美国人》关于核心战争的文章[12]引用了1961年贝尔实验室的维克多·A·维索茨基、罗伯特·莫里斯和道格拉斯·麦克罗伊玩的达尔文游戏。单词&#34；核心和#34；这个名字来自磁芯存储器，一种过时的随机存取存储器技术。</p><p> The first description of the Redcode language was published in March 1984, in  Core War Guidelines by D. G. Jones and  A. K. Dewdney.  [1] The game was introduced to the public in May 1984, in an article written by Dewdney in  Scientific American. Dewdney revisited  Core War in his &#34;Computer Recreations&#34; column in March 1985,  [14] and again in January 1987.  [15]</p><p>1984年3月，D·G·琼斯和A·K·杜德尼在《核心战争指南》中发表了对红码语言的首次描述。[1] 1984年5月，杜德尼在《科学美国人》杂志上发表文章，向公众介绍了这款游戏。杜德尼在&#34；电脑娱乐&#34；1985年3月[14]和1987年1月的专栏文章。[15]</p><p> The International Core Wars Society (ICWS) was founded in 1985, one year after Dewdney&#39;s original article. The ICWS published new standards for the Redcode language in 1986 and 1988, and proposed an update in 1994 that was never formally set as the new standard.  [16] Nonetheless, the 1994 draft was commonly adopted and extended, and forms the basis of the  de facto standard for Redcode today. The ICWS was directed by Mark Clarkson (1985–1987), William R. Buckley (1987–1992), and Jon Newman (1992–); currently the ICWS is defunct.  [17]</p><p>国际核心战争协会（ICWS）成立于1985年，比杜德尼39岁晚了一年；这是一篇原创文章。ICWS在1986年和1988年发布了红码语言的新标准，并在1994年提出了一个从未正式设定为新标准的更新。[16] 尽管如此，1994年的草案还是被普遍采纳和扩展，并形成了今天红字事实标准的基础。ICWS由马克·克拉克森（1985-1987）、威廉·R·巴克利（1987-1992）和乔恩·纽曼（1992-1992）执导；目前ICWS已经失效。[17]</p><p>  0000 :  ADD . AB  #  4 ,  $  3  0001 :  MOV . F  $  2 ,  @  2  0002 :  JMP . B  $  - 2 ,  $  0  0003 :  DAT . F  #  0 ,  #  0</p><p>0000：添加。AB#4，$30001:MOV。F$2，@2 0002:JMP。B$-2，$0 0003:DAT。F#0，#0</p><p> Assembled ICWS-94 style Redcode</p><p>组装ICWS-94型红色代码</p><p> Redcode is the  programming language used in  Core War. It is executed by a  virtual machine known as a  Memory Array Redcode Simulator, or  MARS. The design of Redcode is loosely based on actual  CISC  assembly languages of the early 1980s, but contains several features [   vague] not usually found in actual computer systems.</p><p>Redcode是核心战争中使用的编程语言。它由一个名为内存阵列红码模拟器（Memory Array Redcode Simulator，简称MARS）的虚拟机执行。红码的设计松散地基于20世纪80年代早期的实际CISC汇编语言，但包含一些在实际计算机系统中通常找不到的特性。</p><p> Both Redcode and the MARS environment are designed to provide a simple and abstract platform without the complexity of actual computers and processors. Although Redcode is meant to resemble an ordinary CISC assembly language, it is quite simplified relative to &#34;real&#34; assembly, and has no absolute memory addressing</p><p>Redcode和MARS环境都旨在提供一个简单而抽象的平台，而不需要实际计算机和处理器的复杂性。虽然Redcode与普通的CISC汇编语言类似，但相对于&#34，它相当简单；雷亚尔&#34；汇编，并且没有绝对内存寻址</p><p> The original 8 instructions are described as follows, later versions added NOP, multiply and more complex comparisons.  [18]</p><p>最初的8条指令描述如下，后来的版本添加了NOP、乘法和更复杂的比较。[18]</p><p> OPcode Mnemonic Argument(s) Action ------- --------- ----- ----- ---------------------------------- 0 DAT B Initialize location to value B. 1 MOV A B Move A into location B. 2 ADD A B Add operand A to contents of location B and store result in location B. 3 SUB A B Subtract operand A from contents of location B and store result in location B. 4 JMP B Jump to location B. 5 JMZ A B If operand A is 0, jump to location B; otherwise continue with next instruction. 6 DJZ A B Decrement contents of location A by 1. If location A now holds 0, jump to location B; otherwise continue with next instruction. 7 CMP A B Compare operand A with operand B. If they are not equal, skip next instruction; otherwise execute next instruction.</p><p>操作码助记符参数操作-------------------------0 DAT B初始化位置到值B。1 MOV A B将A移动到位置B。2添加A B将操作数A添加到位置B的内容中，并将结果存储在位置B。3 SUB A B将操作数A从位置B的内容中减去，并将结果存储在位置B。4JMP B跳转到位置B。5 JMZ A B如果操作数A为0，跳转到位置B；否则继续下一个指令。6 DJZ A B将位置A的内容减少1。如果位置A现在保持0，跳到位置B；否则继续下一个指令。7 CMP A B比较操作数A和操作数B。如果它们不相等，跳过下一条指令；否则执行下一条指令。</p><p> the ICWS &#39;94 standard draft added more addressing modes, mostly to deal with A-field indirection, to give a total of 8 address modes:</p><p>ICWS&#39；94标准草案增加了更多寻址模式，主要用于处理A字段间接寻址，总共提供了8种寻址模式：</p><p> # — immediate $ — direct (the $ may be omitted) * — A-field indirect @ — B-field indirect { — A-field indirect with predecrement &lt; — B-field indirect with predecrement } — A-field indirect with postincrement &gt; — B-field indirect with postincrement</p><p>#-立即$-直接（可省略$）-A-field indirect@-B-field indirect{-A-field indirect with predecrement&lt；-B-field indirect with predecrement}-A-field indirect with postincrement&gt；-B-带后增量的间接字段</p><p>  Development of implementations of the game continued over the years by several authors. There are multiple versions of the game available,  [19]  ported for several platforms. For instance  pMARS which is  open source software with  source code on  SourceForge,  [20] or the  SDL based  SDL pMARS for Windows.  [21] Recently a fully web based simulator has been created  https://www.corewar.io/ removing the need to download any platform specific tooling.</p><p>几位作者多年来一直在开发这款游戏的实现。这款游戏有多个版本，可移植到多个平台。例如，pMARS是一种开源软件，源代码位于SourceForge[20]或基于SDL的SDL pMARS For Windows。[21]最近，一个完全基于网络的模拟器被创建出来https://www.corewar.io/无需下载任何特定于平台的工具。</p><p> The common implementation pMars was downloaded over 35,000 times between 2000 and 2021 from  SourceForge.  [22]</p><p>在SooC锻炉2000到2021年间共下载了35000次PMAS。[22]</p><p>  ^     a     b   Jones, D. G.;  Dewdney, A. K. (March 1984).  &#34;Core War Guidelines&#34; .</p><p>^a·b·琼斯，D·G。；杜德尼，A.K.（1984年3月）&#34;核心战争指南&#34。</p><p>  ^    Wangsaw, Mintardjo.  &#34;Intro to Art in &#39;88: Paper - Stone - Scissors Trilogy&#34; .</p><p>^旺沙，明塔乔&#34;艺术入门&#39；88：纸-石-剪刀三部曲&#34。</p><p>        ^    Vowk, Barkley; Wait, Alexander; Schmidt, Christian.  &#34;An Evolutionary Approach Generates Human Competitive Corewar Programs&#34;  (PDF) .</p><p>^沃克，巴克利；等等，亚历山大；施密特，克里斯蒂安&#34;一种进化的方法产生了人类竞争的Corewar项目#34；（PDF）。</p><p>  ^     Shoch, J.; Hupp, J. (March 1982). &#34;The &#39;Worm&#39; Programs - Early Experience with a Distributed Computation&#34;.   Communications of the ACM.  25 (3): 172–180.  doi: 10.1145/358453.358455.  S2CID  1639205.</p><p>^肖赫，J。；Hupp，J.（1982年3月）&#34;第&#39；蠕虫&#39；程序-早期分布式计算经验&#34；。ACM的通讯。25 (3): 172–180.  内政部：10.1145/358453.358455。S2CID 1639205。</p><p> ^     Dewdney, A. K. (March 1985).  &#34;A Core War bestiary of viruses, worms and other threats to computer memories&#34;.  Scientific American .</p><p>^杜德尼，A.K.（1985年3月）&#34;病毒、蠕虫和其他对计算机内存的威胁的核心战争动物；。科学美国人。</p><p> ^     Dewdney, A. K. (January 1987).  &#34;A program called MICE nibbles its way to victory at the first Core War tournament&#34;.  Scientific American .</p><p>^杜德尼，A.K.（1987年1月）&#34;一个名为MICE的项目在第一届核心战争锦标赛上以微弱优势取胜&#34；。科学美国人。</p><p> ^    Doligez, Damien; Durham, Mark (8 November 1995).  &#34;Annotated Draft of the Proposed 1994 Core War Standard&#34; .</p><p>^达米恩·多利格斯；马克达勒姆（1995年11月8日）&#34;1994年拟议核心战争标准的注释草案&#34。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/核心/">#核心</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>