<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>哪里出错了：Rust中的错误处理和错误消息 Where Everything Went Wrong: Error Handling and Error Messages in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Where Everything Went Wrong: Error Handling and Error Messages in Rust<br/>哪里出错了：Rust中的错误处理和错误消息 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 17:04:27</div><div class="page_narrow text-break page_content"><p>This is so annoying. You’ve written a Rust crate and now that you want to test it for the very first time,  it doesn’t work!</p><p>这太烦人了。你已经写了一个铁锈箱，现在你想第一次测试它，它不起作用！</p><p> Come on, Rust! How dare you? You promised that once one gets past the compiler, it.  Just.  Works! And now this!</p><p> 来吧，生锈！你怎么敢？你答应过，一旦获得了编译器。只是。作品！现在这个！</p><p> Ok, ok. You calm yourself down. Lets start from the beginning. You want to create so called  minidumps. This is a file that contains information about a crashed program (like stacks of all threads, CPU registers, system info, etc.).The minidump consists of various sections, such as the minidump header (including time of day, versions and basically a table of contents), a thread section (including all threads of the process and their stacks), memory mappings and libraries, etc. [Just to give some context, as all of this is actually not really important.]</p><p> 好的好的。你让自己平静下来。让我们从头开始。你想创造所谓的minidumps。这是一个文件，包含有关崩溃程序的信息（如堆栈的所有线程，CPU寄存器，系统信息等）。MiniDump由各种部分组成，例如MiniDump标题（包括一天时间，版本，基本上是一个目录），一个线程部分（包括过程的所有线程及其堆栈），内存映射和库等。[只是为了给出一些上下文，因为所有这些都实际上并不重要。]</p><p> For this, you created a  crate. One section gets written after the other, while information about the targeted process is retrieved from the system. You even created a nice, simple API. You hand in a process ID and an open file, where the minidump should be written to. like this:</p><p> 为此，您创建了一个箱子。一个部分之后写入另一个部分，而从系统中检索有关目标进程的信息。你甚至创造了一个很好的简单API。您可以在进程ID和一个开放文件中携手，其中应该写入miniDump。像这样：</p><p>  You can also hand in user specified memory regions that should be included in the dump, like so:</p><p>  您还可以在用户中包含在转储中的用户指定的内存区域，如：</p><p> let  app_memory  =  AppMemory  {  ptr :  some_address ,  length :  memory_size ,  };  MinidumpWriter :: new ( pid ,  pid )  .set_app_memory ( vec! [ app_memory ])  .dump ( &amp; mut  tmpfile )  .expect ( &#34;Dumping failed&#34; );</p><p> 让app_memory = appmemory {ptr：some_address，length：memory_size，}; MiniDumpWriter :: New（PID，PID）.set_app_memory（Vec！[app_memory]）.dump（＆amp; mut tmpfile）.expect（＆＃34;倾倒失败＆＃34;）;</p><p>  But when you run your nice library code in an application, you get  &#39;Dumping failed: &#34;Failed in ptrace::read: Sys(EIO)&#34;&#39;.</p><p>  但是当您在应用程序中运行漂亮的库代码时，您将获得＆＃39;倾倒失败：＆＃34;在Ptrace中失败:: read：sys（Eio）＆＃34;＆＃39; </p><p>  Okay, maybe you could enhance your library error handling, a little. And by enhance, you mean “implement one in the first place”.</p><p>好的，也许您可​​以稍微增强一下库错误处理能力。通过增强，您的意思是“首先实现一个”。</p><p>    and using  Result&lt;T&gt; in all of your functions as the return value and handing all of them to the parent function using  ?. Thus the original error pierces through your callstack like a dart through….jelly (Yes, you are good with words and you know it.).</p><p>    并使用结果＆lt; T＆gt;在所有函数中作为返回值，并使用？将它们全部移交给父函数。这样，原始错误就像飞镖一样穿过….jelly刺穿了您的调用堆栈（是的，您擅长单词并且您知道它。）。</p><p>   Usually, you just bubble up errors from libraries you use, but for the rare errors you have to define yourself, you currently just do</p><p>   通常，您只是从使用的库中冒出错误，但是对于必须定义自己的罕见错误，您目前只是在做</p><p>  Well, now you know there is an error, at least. And that it has  something to do with your usage of  ptrace. But you have no idea where that happens. You use that functionality in various places. Is it during the init-phase? During one of the sections? And if so, which one? What are you trying to read? And from where? Or in short:  What is going on?!</p><p>  好吧，现在您至少知道存在错误。而且这与您使用ptrace有关。但是您不知道发生在哪里。您可以在各个地方使用该功能。是在初始化阶段吗？在其中一节中？如果是这样，哪一个呢？你想读什么？从哪里来的？或简而言之：这是怎么回事？</p><p>  Well, Rust has been around for quite some time now and they always boast about how error handling is a first class citizen and all that. So error handling should be a done deal, right? With a canonical way of dealing with errors, officially documented and all that should be right there, correct?</p><p>  好吧，Rust已经存在了很长一段时间了，他们总是吹嘘错误处理如何成为一流的公民。所以错误处理应该已经完成​​了，对吧？以规范的方式处理错误，已正式记录下来，所有正确的地方，对吗？</p><p>  Turns out, this is a very active field of…mh…experimentation, lets say. There has been  a survey recently, listing and quickly describing most the different libraries and ways for error handling that emerged, fallen out of favor, got forked, died anyways, got superseded, fallen out of favor again, etc.And the opinions seem to change frequently, if you should use  error-chain or  failure or  fehler or  snafu or  thiserror or  anyhow or  eyre or…</p><p>  事实证明，这是一个非常活跃的……嗯……实验领域。最近进行了一项调查，列出并快速描述了出现，失宠，分叉，无论如何死亡，被取代，再次失宠等各种错误处理库和错误处理的大多数方式。如果您应该使用错误链或失败，错误或失败，此错误或无论如何，或错误，则应经常更改</p><p>  Then you find  this gem and don’t know if you should laugh or cry. Almost six years after Rust hit 1.0 an error handling project group is formed. Six. Years.  (heavy breathing)</p><p>  然后，您找到了这颗宝石，不知道您应该笑还是哭。在Rust达到1.0版本将近六年之后，一个错误处理项目组就形成了。六。年。 （沉重的呼吸） </p><p> Well, okay. At least they are sorting it out now. Problem is, you need…. SIX YEARS? Are you serious?…ahem, sorry…Problem is, you need helpful error messages now.</p><p>哦，那好吧。至少他们现在正在解决它。问题是，您需要……。六年？您是认真的吗？……哎呀，抱歉……问题是，您现在需要有用的错误消息。</p><p> After reading a few decent blogs on the topic (like  this or  that), there seems to emerge a consensus, at least for libraries: Return something that derives from  std::error::Error. Either implement them by hand, or use a crate that does it for you, using macro magic. like  thiserror. Which method you use depends on your level of laziness plus your patience regarding compile times.</p><p> 在阅读了有关该主题的一些不错的博客之后（至少是这样），似乎已经形成了共识，至少对于库而言：返回源自std :: error :: Error的内容。使用宏魔术，可以手动实现它们，也可以使用为您完成任务的板条箱。像这个错误。使用哪种方法取决于您的懒惰程度以及您对编译时间的耐心。</p><p>   Unfortunately, all the articles have the understandable, but rather annoying tendency to use very simple example code for illustration purposes. Unrealistically simple, you might even say. They have callstacks of depth 1, return only three kinds of error in total in their API, and their errors are obvious and easily describable (e.g. “Input file XY not found in your ‘counting words’ program”).</p><p>   不幸的是，所有文章都倾向于使用非常简单的示例代码来进行说明，这是可以理解的，但很烦人。您甚至可能会说，不切实际的简单。他们具有深度为1的调用栈，其API中总共仅返回三种错误，并且它们的错误是显而易见的，并且易于描述（例如，“在“单词计数”程序中找不到输入文件XY”）。</p><p> You have a more complicated callstack, with tons of different errors and code reuse in different places. For example, the function you think is to blame for the above error is  copy_from_process(), which calls  ptrace::read(), which probably returns something like  Failed in ptrace::read: Sys(EIO).This function is used in multiple places in your code, e.g.:</p><p> 您有一个更复杂的调用栈，在不同的地方有成千上万种不同的错误和代码重用。例如，您认为造成上述错误的函数是copy_from_process（），该函数调用ptrace :: read（），该函数可能在ptrace :: read：Sys（EIO）中返回类似Failed的错误信息。代码中的多个位置，例如：</p><p> ├─ init()│ ├─ read_auxv()│ │ ├─ open(format!(&#34;/proc/{}/auxv&#34;, self.pid))│ │ └─ some_parsing()│ ├─ ...│ ├─ enumerate_mappings()│ │ ├─ open(format!(&#34;/proc/{}/maps&#34;, self.pid))│ │ └─ some_parsing()│ ││ └─ some_more_checks()│ └─ copy_from_process()│└─ dump() │ ├─ sections::header::write() │ ├─ sections::thread_list_stream::write() │ └─ copy_from_process() │ ├─ sections::mappings::write() │ └─ elf_identifier_for_mapping() │ └─ copy_from_process() │ ├─ sections::app_memory::write() │ └─ copy_from_process() │ └─ ...</p><p> ├─init（）│├─read_auxv（）││├─open（format！（＆＃34; / proc / {} / auxv＆＃34 ;, self.pid））││└─some_parsing（）│├─ ...│├─enumerate_mappings（）││├─open（format！（＆＃34; / proc / {} / maps＆＃34 ;, self.pid））││└─some_parsing（）│││└─ some_more_checks（）│└─copy_from_process（）│└─dump（）│├─节:: header :: write（）│├─节:: thread_list_stream :: write（）│└─copy_from_process（）│├─ ：mappings :: write（）│└─elf_identifier_for_mapping（）│└─copy_from_process（）│├─部分:: app_memory :: write（）│└─copy_from_process（）│└─...</p><p> Same goes for opening files, which happens in multiple places (two examples of which are shown in  init()), so getting  FileNotFound without context is going to be equally fun, and so on.</p><p> 打开文件的情况也是如此，它发生在多个地方（init（）中显示了两个示例），因此在没有上下文的情况下获取FileNotFound同样会很有趣，依此类推。</p><p>  Wrapping errors still sounds like a nice idea, but one layer alone is not going to  wrap it cut it.Going with  copy_from_process() as an example, you see a few possibilities:</p><p>  包裹错误听起来仍然是一个不错的主意，但是仅一层不会对其进行包裹。以copy_from_process（）为例，您看到了几种可能性： </p><p> Wrapping the  ptrace error into an  CopyFromProcessError, but that gives you nothing (except maybe some context, if you add some)</p><p>将ptrace错误包装到副本中，但这为您提供任何东西（可能是某些上下文除外，如果添加一些）</p><p>  With  InitErrors and  DumpingErrors that wrap the  ptrace errors, you will still not know which section failed and why, but know if it was during  init() or not.</p><p>  使用initerrors和dumpingerrors包装ptrace错误，您仍然不知道哪个部分失败，为什么，但知道它是否在init（）期间。</p><p> You might add context to option 2 as well (see below on how), but each section has a variety of reasons why it could fail. Some unique to the section, some shared among a few, some among all of them.</p><p> 您可能会将上下文添加到选项2（请参阅以下方法），但每个部分都有各种原因可能会失败。部分有些独一无二的部分，有些人在几个中分享，其中一些。</p><p>   Using  thiserror and the fabulous  #[from] macro, you quickly define a plethora of errors and wrappers, starting from the deepest, darkest places in your callstack, wrapping your way up:</p><p>   使用这架子和神话般的＃[来自]宏，您可以快速定义一个过多的错误和包装，从您的Callstack中的最深，最黑暗的地方开始，包裹起来：</p><p> #[derive(Debug,  Error)] pub  enum  PtraceDumperError  {  #[error( &#34;nix::ptrace() error&#34; )]  PtraceError ( #[from]  nix :: Error ),  ... } #[derive(Debug,  Error)] pub  enum  SectionAppMemoryError  {  #[error( &#34;Failed to copy memory from process&#34; )]  CopyFromProcessError ( #[from]  PtraceDumperError ),  ... } #[derive(Debug,  Error)] pub  enum  DumpError  {  #[error( &#34;Error during init phase&#34; )]  InitError ( #[from]  InitError ),  #[error(transparent)]  PtraceDumperError ( #[from]  PtraceDumperError ),  #[error( &#34;Failed when writing section AppMemory&#34; )]  SectionAppMemoryError ( #[from]  SectionAppMemoryError ),  ...</p><p> ＃[派生（调试，错误）] Pub枚举ptracedumpererror {＃[错误（＆＃34; nix :: ptrace（）错误＆＃34;）ptraceError（＃[来自] nix ::错误），...}＃ [派生（调试，错误）] pub enum sectionAppMemoryError {＃[错误（＆＃34;从进程中复制内存和＃34;来自process＆＃34;＃[来自] ptracedumpererror），...}＃[派生（调试，错误）] Pub枚举Dumperror {＃[错误（＆＃34; init阶段＆＃34期间的错误）] initerror（＃[from] initerror），＃[错误（透明）] ptracedumpererror（＃[from] ptracedumpererror），＃ [错误（＆＃34;写作部分appMemory＆＃34失败）] SectionAppMemoryError（＃[来自] SectionAppMemoryError），...</p><p> The fun part is: You have to touch very little of your existing code, thanks to the automatic conversion from one error to the other, conveniently provided by  #[from]:</p><p> 有趣的部分是：您必须触摸现有的代码很少，这归功于从一个错误到另一个错误的自动转换，方便地由＃[来自]提供：</p><p> - pub fn init(&amp;mut self) -&gt; Result&lt;()&gt; { + pub fn init(&amp;mut self) -&gt; Result&lt;(), InitError&gt; { self.read_auxv()?; self.enumerate_threads()?; self.enumerate_mappings()?; Ok(()) }</p><p>  -  PUB FN init（＆amp; mut self） - ＆gt;结果＆lt;（）＆gt; {+ PUB FN init（＆amp; mut self） - ＆gt;结果＆lt;（），initerror＆gt; {self.read_auxv（）？; self.enumerate_threads（）?; self.enumerate_mappings（）？好的（（）） } </p><p>  - pub fn get_stack_info(&amp;self, int_stack_pointer: usize) -&gt; Result&lt;(usize, usize)&gt; { + pub fn get_stack_info(&amp;self, int_stack_pointer: usize) -&gt; Result&lt;(usize, usize), DumperError&gt; { // snip let mapping = self .find_mapping(stack_pointer) - .ok_or(&#34;No mapping for stack pointer found&#34;)?; + .ok_or(DumperError::NoStackPointerMapping)?; let offset = stack_pointer - mapping.start_address; let distance_to_end = mapping.size - offset; // snip</p><p>-pub fn get_stack_info（＆amp; self，int_stack_pointer：usize）-＆gt;结果＆lt;（使用，使用）＆gt; {+ pub fn get_stack_info（＆amp; self，int_stack_pointer：usize）-＆gt;结果＆lt;（使用，使用），DumperError＆gt; {//剪接let映射= self .find_mapping（stack_pointer）-.ok_or（＆＃34;未找到堆栈指针的映射＆＃34;）？ + .ok_or（DumperError :: NoStackPointerMapping）?;让偏移量= stack_pointer-mapping.start_address;让distance_to_end = mapping.size-偏移量; //剪断</p><p>   which is…. (Throws a stack of papers from the desk)…short. Too short, and not that much more helpful, actually. Well, you know which section is failing. Thats good. But where are all the nice error messages you specified in your errors?</p><p>   是… （从桌子上扔出一堆纸）……简短。实际上太短了，没有什么帮助。好吧，您知道哪个部分失败了。那挺好的。但是，您在错误中指定的所有错误消息都在哪里？</p><p>   Aha! Now you are getting somewhere! Tiny, tiny, painfully  tiny steps, but you are getting somewhere! No error texts, but at least a chain!</p><p>   啊哈！现在您到了某个地方！微小，微小，痛苦的微小步骤，但是您到了某个地方！没有错误文本，但至少有一个链！</p><p> Normal printing doesn’t seem to recursively go through all the wrapped errors, but stop at the top most. For this, you need to either go through all the errors yourself by hand, or use a crate that does this for you. There are a number of them that provide this, but  anyhow will do (its by the same author as  thiserror, so interoperability shouldn’t be an issue).</p><p> 正常的打印似乎不会递归地解决所有错误，但会停在最顶端。为此，您需要自己亲自解决所有错误，或者使用可为您完成此任务的板条箱。有很多提供此功能的工具，但是无论如何都会做到这一点（与thiserror由同一作者撰写，因此互操作性不应该成为问题）。</p><p>   Failed when writing section AppMemory: Failed to copy memory from process: nix::ptrace() error: EIO: I/O error</p><p>   写入部分AppMemory时失败：无法从进程复制内存：nix :: ptrace（）错误：EIO：I / O错误</p><p>   With that sweet, sweet error chain and the resulting error message, you now know where everything goes wrong. Not really  why, though. You lack context. Luckily, you are not out of context (Note to yourself: You need a drum set for acoustically emphasizing your puns).</p><p>   有了那个甜美，甜美的错误链以及由此产生的错误消息，您现在知道了哪里出错了。不过，不是真的为什么。你缺乏背景。幸运的是，您不会脱离上下文（请注意：您需要一个鼓组，以声学方式突出双关语）。</p><p> You have plenty of context to add, and adding it is rather easy. Instead of using  #[from], you use  #[source], which will not implement an automatic conversion function anymore, but keep the error chain intact:</p><p> 您需要添加大量上下文，添加起来非常容易。而不是使用＃[from]，而是使用＃[source]，它将不再实现自动转换功能，但保持错误链完整： </p><p> #[derive(Debug,  Error)] pub  enum  PtraceDumperError  {  #[error( &#34;Copy from process {0} failed (source: 0x{1:x}, offset: {2}, length: {3})&#34; )]  PtraceError ( Pid ,  usize ,  usize ,  usize ,  #[source]  nix :: Error ),</p><p>＃[派生（调试，错误）] Pub枚举PtracedumpererRorRor {＃[错误（＆＃34;从过程{0}失败的副本（源：0x {1：x}，offset：{2}，长度：{3}） ＆＃34;）] PtraceError（PID，USIZIZE，USIZIZE，USIZIZE，＃[源] NIX :: ERROR），</p><p> This can be done on all layers of your error chain. For this example, we only do it at the last link.No matter where you do it, you have to map your error now ( eyre could do this a bit more ergonomically, but you want to keep your dependency list small):</p><p> 这可以在错误链的所有层上完成。对于这个例子，我们只在最后一个链接中执行它.NO，你现在做的地方，你现在必须映射你的错误（yse可以更加符合人体工程学，但你想要保持你的依赖列表小）：</p><p> let word = ptrace::read(pid, (src + idx) as *mut c_void) .map_err(|e| PtraceError(child, src, idx, num_of_bytes, e))?;</p><p> 让Word = ptrace :: read（pid，（src + idx）为* mut c_void）.map_err（| e | ptraceError（src，Idx，num_of_bytes，e）？</p><p>  Failed when writing section AppMemory: Failed to copy memory from process: Copy from process 12111 failed (source: 0x0, offset: 0, length: 4096): EIO: I/O error</p><p>  写入部分AppMemory时失败：无法从进程复制内存：从过程12111复制失败（源：0x0，偏移：0，长度：4096）：EIO：I / O错误</p><p>    Well, your error messages, including lots of context, is now a well of information for humans. Its perfect for logging (for example to put into a JSON-file accompanying your minidump). Is it any good to use programmatically by application developers, though?</p><p>    嗯，您的错误消息，包括许多上下文，现在是人类的信息。它非常适合记录（例如，放入伴随您的MiniDump的JSON文件）。但是，通过应用程序开发人员使用以编程方式使用吗？</p><p> You think it could be. You envision scenarios like “Can’t find file XY, because of not yet mounted filesystem” or the like. These can easily be matched for in the application code by using the last link in your error-chain, which  anyhow provides with the  root_cause() function.Or you could match only the top most error and redoing the minidump-section on your own, if the library code fails in it.</p><p> 你认为这可能是。您想要的方案，如“无法找到文件xy，因为尚未挂载文件系统”等。这些可以通过使用错误链中的最后一个链接在应用程序代码中轻松匹配，这无论如何都提供root_cause（）函数.Oor您只能匹配顶部最错误并根据自己的迷你型部分重做，如果库代码失败了。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://msirringhaus.github.io/Where-everything-went-wrong/">https://msirringhaus.github.io/Where-everything-went-wrong/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/error/">#error</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>