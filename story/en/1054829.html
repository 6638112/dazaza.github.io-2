<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>采访大卫哥们 Interview with David Madore</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Interview with David Madore<br/>采访大卫哥们 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-28 09:10:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/e9286b9e1e38b3a252ab6b6085e26115.png"><img src="http://img2.diglog.com/img/2021/3/e9286b9e1e38b3a252ab6b6085e26115.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>David Madore is responsible for one of the best-known and most-confounding esolangs of all time:  Unlambda. The language is based on the SKI combinator calculus, a super-minimalist computational system used in the mathematical analysis of algorithms, but considered impractical for coding. In Unlambda everything is a function that takes a single variable, so there are no indicators like ()s to take parameters. Like the SKI calculus, it entirely eschews variables and the lambda indicator, and so is described as lambda-without-the-lambda. If this is entirely new to you,  the second half of this post is a nice introduction. Madore, an accomplished mathematician, is also responsible for languages that play at the edges of infinity. His main web presence is  his webpage from his undergrad days thirty years ago, which remains a fascinating portrait of the sincerity, optimism, and banalities of the early Web. He is also  on Twitter with a handle derived from his engagement with  The Hackers&#39; Zen.</p><p>大卫·哥哥负责所有时间最着名，最混杂的esolang的负责：Unlambda。该语言基于滑雪组合器微积分，这是一种用于算法数学分析的超极简主义计算系统，但被认为是不切实际的编码。在UPLIMDA中，一切都是一个占用单个变量的函数，因此没有指示符（）是拍摄参数。与滑雪微积分一样，它完全避免了变量和λ指示器，因此被描述为Lambda-unt-lambda。如果这对你完全是新的，这篇文章的下半场是一个很好的介绍。一位成功的数学家哥们也负责在无限远处发挥的语言。他的主要网络存在是他从三十年前的本科的日子的网页，这仍然是令人着迷的诚意，乐观和早期网络的平庸肖像。他还在推特上，带有与黑客的参与者派生的把手＆＃39;禅。</p><p> In response to a flurry of questions about creating Unlambda, Madore gives us some notes:</p><p> 为了响应关于创建Unlambda的问题，麦德德给了我们一些笔记：</p><p> I think I came up with Unlambda in 1999. I knew very little about other esolangs at the time (and I still don&#39;t know much about them), that is to say, I knew a bunch of names but didn&#39;t try programming in any of them.</p><p> 我想我在1999年提出了Unlambda。我在那时候对其他Esolangs很少（而且我仍然不知道他们），也就是说，我知道一群名字，但并没有人和＃39 ; T尝试在其中任何一个编程。</p><p> I was reading a book on logic that mentioned the Hilbert-style axioms (S: (A⇒B⇒C)⇒(A⇒B)⇒A⇒C; K: A⇒B⇒A; and I: A⇒A) and I was simultaneously thinking about the Curry-Howard correspondence between proof systems and typing systems, so I thought about what these axioms meant in terms of functional programming and how we could use them to re-explain the lambda-calculus without lambdas: this is how I came up with Unlambda. The &#39;c&#39; function is because I was also fascinated by call/cc at the time (and still am, I guess), especially as it also has a nice interpretation in the Curry-Howard correspondence as Peirce&#39;s law (((A⇒B)⇒A)⇒A). The &#39;d&#39; is clearly an error of mine, I should never have included it, it&#39;s unnecessary (I thought it might be, but it was a misunderstanding on my part of how normalization proceeds) and it makes the language far less elegant (on the other hand, it makes the interpreter&#39;s job a bit more complex, which is maybe fair for an obfuscated programming language).</p><p> 我正在阅读一本关于逻辑的书，提到了Hilbert风格的公理（S：（a⇒bəc）⇒（a⇒b）⇒a⇒c; k：aəb⇒a;和我：a⇒a）我同时考虑了证明系统和键入系统之间的咖喱霍华德对应，因此我考虑了这些公理在功能规划方面意味着什么以及我们如何使用它们来重新解释没有兰布斯的λ-calculus：这是我如何提出Unlambda。 ＆＃39; c＆＃39;功能是因为当时的呼叫/ cc也很着迷（我猜），特别是因为它在咖喱霍华德函上作为Peirce＆＃39;法律（（a⇒b ⇒a）⇒a）。 ＆＃39; D＆＃39;显然是我的错误，我永远不应该包括它，它＆＃39;我不必要的（我认为可能是，但这是我对归一化的收益的一部分的误解），它使语言更优雅（开另一方面，它使口译员＆＃39;作业有点复杂，这可能是混淆的编程语言的公平）。</p><p> At the time, I was thinking about proposing another obfuscated programming language in a somewhat similar flavor, where everything would be written in continuation-passing-style (no function ever returns), but never got around to it.</p><p> 当时，我正在考虑提出另一种混淆的编程语言，有点类似的味道，一切都将以持续的方式写入（无功能），但从未到过它。</p><p> I think Unlambda got some attention from various teams writing compilers with multiple front-ends or stuff like that, or in compilation courses, because it can be an interesting test case, toy example or illustration.</p><p> 我认为Unlambda从各个团队写作编写编译器的一些前端或类似的东西，或者在汇编课程中，因为它可以是一个有趣的测试案例，玩具示例或插图。</p><p> I once had a page in Wikipedia because of Unlambda, but it was later decided that I wasn&#39;t notable enough. :-(</p><p> 我曾经在维基百科有一页，因为Unlambda，但后来决定我没有足够了解。 :-( </p><p>  » Thanks, this is a great intro to what you were thinking when you created the language! Does your work as a mathematician since then build on these ideas or relate to them in any specific way?</p><p>»谢谢，当您创建语言时，这是一个伟大的介绍！从那时起，您的工作是数学家，从而在这些想法上建立或以任何特定方式与他们联系起来？</p><p> Not really. I&#39;m (&#34;officially&#34;) in Algebraic Geometry, which is rather disconnected from such things as the lambda-calculus. But I do dabble in all sorts of domains of mathematics, including a lot of logic (and, for some reason, recently, a lot of epidemiology...).</p><p> 并不真地。在代数几何形状中，我（＆＃34;正式＆＃34;）在代数几何形状中，这与兰姆达微积分相当断开。但我在有很多逻辑中涉及各种数学领域（而且，由于某种原因，最近，很多流行病学......）。</p><p> » Has anyone written programs in Unlambda that surprised you (in terms of the strange direction they took or perhaps in what they were able to accomplish with it)?</p><p> »有没有人在Unlambda上写过的程序，让你感到惊讶（就他们所采取的奇怪方向或者他们能够与之完成的方式）？</p><p> After I wrote the language, I ran a mini-competition (on an internal newsgroup system at the ENS where I was a student) to write a quine in Unlambda (I offered a copy of the Abelson &amp; Sussman &#34;wizard book&#34; to whomever would write the first). I knew it was doable because I had written one myself, but mine was unwieldy, and I was amazed by how fast other people were able to write quines, and how small they could get them (the record, as far as I know, is 491 bytes, at  ftp.madore.org/pub/madore/unlambda/CUAN/quine/quine06.unl, or how efficient (in terms of data representation).</p><p> 在写完语言后，我跑了一个迷你竞赛（在INS中的内部新闻组系统上，在我是学生的内部），在Unlambda上写一个Quine（我提供了Abelson＆amp的副本; Sussman＆＃34;巫师书籍＃34;对于谁来说，第一个是写的）。我知道这是可行的，因为我自己写了一个，但我的笨重是笨拙的，我惊讶于其他人能够写真的速度，以及他们可以获得的速度（据我所知，他们有多小491字节，在ftp.madore.org/pub/madore/unlambda/cuan/quine/quine06.unl，或效率如何（在数据表示方面）。</p><p> Later on, someone was able to write an Unlambda interpreter in Unlambda, which also surprised me, and a couple of other fun programs. Of course, it&#39;s a bit of a cheat because what he actually did was write a translator for a subset of Scheme into Unlambda, and then used this translator to translate an Unlambda interpreter written in that subset of Scheme (as well as the translator itself) into Unlambda.</p><p> 后来，有人能够在Unlambda写一个Unlambda口译员，这也让我感到惊讶，以及一些其他有趣的节目。当然，它＆＃39; sa bit a作弊，因为他实际做的是将一个翻译器写成一个转换器，将一个转换器用于Ullmbda，然后使用此翻译器转换在该方案的那个子集中写入的Unlumbda解释器（以及翻译成本）进入Ullmbda。</p><p> » Unlambda has been described as &#34;easy to write, impossible to read&#34;—does that jibe with your experience with it?</p><p> »Unlumbda已被描述为＆＃34;易于写的，不可能阅读＆＃34;  - 与您的体验有关jibe吗？</p><p> Yes, quite. Once you have a translator as described in the previous paragraph, it becomes fairly easy to write lots of things in Unlambda, and not so impressive after all. But I would be very impressed if anyone were able to read non-trivial Unlambda programs without actually running them.</p><p> 是的，相当。一旦您在上一段中描述的翻译，在Unlambda中写出很多东西都会变得相当容易，并且毕竟没有那么令人印象深刻。但如果任何人能够在没有实际运行它们的情况下阅读非琐碎的Unlambda程序，我会留下深刻的印象。 </p><p> One particularly difficult program which rose to a certain degree of fame is this one:  ``r`ci`.*`ci, which prints an endless list of rows of asterisks, each with one more than the previous (i.e., it counts in unary using asterisks): the output isn&#39;t particularly impressive, but understanding how it works is definitely tricky! I stumbled upon this program by more or less randomly trying various stuff with call/cc, and I had a hard time figuring out how it did what it did. See  https://stackoverflow.com/questions/30409800/any-history-background-about-the-yin-yang-puzzle-in-detail and the links therein for various comments and translations of this weird program.</p><p>一个特别困难的程序，升到一定程度的名利，这是一个：``r`cl`。*`ci，它打印一个无休止的星号列列表，每个星号列表，每个字符列表都超过前一个（即，它计入一元使用星号）：输出是特别令人印象深刻的，但了解它的工作原理肯定是棘手的！我偶然发现了这个程序，或多或少随机尝试了各种各样的用呼叫/核武器，我很难弄清楚它是如何做的事情。请参阅https://stackoverflow.com/questions/30409800/any-history-background-about-the-yin-yang-puze-in-detail和其中的各种评论和翻译的链接。</p><p> » Considering the impact Unlambda has had on esoteric languages, I&#39;m curious if you ever connected with other esolangers after creating the language.</p><p> »考虑到Impact unctmda在宇宙语言上，我很好奇，如果您在创建语言后与其他Esolanger联系。</p><p> Not really, no. I was aware of the existence of esolangs.org but that&#39;s about as far as it goes.</p><p> 不是真的，没有。我知道Esolangs.org的存在，但它就在迄今为止。</p><p> » Apart from Unlambda, you&#39;ve created a few other esolangs, most notably Amicus, introduced (in 2015)  in this post; how did this come about, and how would you describe hyperarithmetic functions to the less-mathy of us? What is the central idea of the language, if it can be described in a few sentences?</p><p> »除了Unlambda，您＆＃39;在这篇文章中推出了一些其他Esolang，最符合的esolangs，特别是amicus，介绍（2015年）;这是怎么来的，以及如何描述对我们较少的数学算术函数？如果可以在几句话中描述的话，语言的核心思想是什么？</p><p> First of all, this definitely wasn&#39;t intended as an esolang... I wanted to give a formal definition of hyperarithmetic machines, it turned out to be a bit less workable than I had hoped for (I tried writing something non-trivial in it, and I realized it was quite tedious! see note #4½ in the blog post in question), and one of my blog readers decided it was interesting and gave it a name. Why not? In retrospect, it&#39;s true that it makes for a possibly interesting esolang, but its birth was entirely fortuitous.</p><p> 首先，这绝对是愿意为esolang ......我想给出一个正式的超级机器定义，结果表明比我希望（我试图写一些非琐碎的是，我意识到它是非常乏味的！在博客文章中看到注释＃4½，而我的一个博客读者决定它很有意思，并给了它一个名字。为什么不？回想起来，它是真实的，它是一个可能有趣的Esolang，但它的出生完全是偶然的。</p><p> A &#34;hyperarithmetic machine&#34; (note: the terminology is mine: the concept is standard in computability, but generally people speak of &#34;hyperarithmetic[al] functions&#34; for the functions they compute, and the devices doing the computation are left unnamed) is a model of higher computation, i.e., it is a kind of abstract computer that is strictly stronger than a Turing machine.</p><p> A＆＃34;超级算法机＆＃34; （注意：术语是我的：该概念是可计算性的标准，但通常人们谈论＆＃34;超级算法[al]函数＆＃34;对于它们计算的功能，并且留下所做计算的器件，留下unnamed的功能）是一个计算型号，即，它是一种严格强于图灵机的抽象计算机。</p><p> Basically, a hyperarithmetic machine can do everything that a Turing machine can do, with one additional capability: given a sequence of integers that is, itself, computed by a [program for a] hyperarithmetic machine, the machine can (in a single magical step, if you will) decide whether the sequence consists entirely of zeroes or whether there is a nonzero value somewhere down the line; note that the computation of every single one of these values has to terminate, but provided that this is the case, the machine has the ability to examine all of them and decide whether there is a nonzero value among them. The values in the examined sequence are themselves computed by hyperarithmetic machines (so they can themselves use the same ability): this makes it a bit subtle to define properly because you can&#39;t allow a program to examine its own behavior. But after it&#39;s properly defined, the machine in question is extremely powerful: it can not only solve the halting problem for ordinary Turing machines, but also the halting problem for Turing machines with access to a solution of the halting problem for ordinary Turing machines, &#34;and so on&#34;.</p><p> 基本上，一个额外的机器可以做一个额外的能力的超级算法机器可以做到的所有功能：给定一系列整数，这本身是由[程序用于A]超级机器，机器可以（在单个神奇的步骤中计算如果您愿意）决定序列是否完全由零或在线某处存在非零值;请注意，每个单个单个值的计算必须终止，但是提供了这种情况，机器能够检查所有这些，并决定它们之间是否存在非零值。检查序列中的值本身由超级机器计算（因此它们本身可以使用相同的能力）：这使得它可以正确定义一个细微，因为您可以＆＃39; t允许程序检查自己的行为。但是在它的正确定义后，所讨论的机器非常强大：它不仅可以解决普通图灵机的停止问题，而且可以为普通的停止问题解决的机器停止问题图灵机，＆＃34;＆＃34; </p><p> So anyway, my blog post was about defining this properly and explaining a few equivalent definitions; and since the definition is a bit tricky, I tried to give a precise formalization, and to make sure my formalization did what I thought it did, I wanted to make sure that if we removed the extra magical ability of hyperarithmetic machines we got (something equivalent to) ordinary Turing machines, and this is how I accidentally invented an esolang.</p><p>无论如何，我的博客文章是关于正确定义这个并解释几个等价定义;由于定义有点棘手，我试图给出精确的形式化，并确保我的形式化做到了我所想到的，我想确保如果我们删除了我们得到的超级机器的额外魔法能力（某事相当于普通的图灵机，这就是我意外地发明了Esolang的方式。</p><p> (But hyperarithmetic machines are not, in and of themselves, connected to esolangs any more than Turing machines are. One could imagine all sorts of programming languages to run on them just as there are many Turing-equivalent programming languages.)</p><p> （但是，超级机器不是在自己的内容中，与Esolangs相连的任何不仅仅是图灵的机器。人们可以想象各种编程语言，就像有许多图灵等效的编程语言一样。）</p><p>  One is that I invented a number of programming languages for transfinite computers (i.e., that are able to deal with and manipulate certain infinite ordinals). I didn&#39;t give them any specific names, and there are a few of them whose exact relation is, sadly, not entirely clear even theoretically, but  they are defined here. At least some variants of the languages in question should be equivalent to the aforementioned &#34;hyperarithmetic machines&#34;. The languages in question aren&#39;t supposed to be difficult to write, on the contrary, but they are definitely esoterical since they are meant for computers that (presumably!) cannot physically exist in this universe. (Also, I should make it clear that the theoretical concepts, like that of a hyperarithmetic machine/function, aren&#39;t new and aren&#39;t due to me: they are &#34;well known&#34; notions from higher computability that were developed in the 1950&#39;s to 1970&#39;s, but computability theorists never bothered to actually formulate them in the form of a programming language.)</p><p>  一个是我发明了许多用于Transfinite计算机的编程语言（即，能够处理和操纵某些无限序数）。我没有给他们任何特定的名字，并且有一些他们的确切关系是可悲的，甚至没有完全清楚，但它们在这里定义。至少有一些语言的变体应该相当于上述和＃34;超级机器＆＃34;问题中的语言＆＃39;它应该难以写作，相反，但它们绝对是深度的，因为它们意味着（大概是！）不能在这个宇宙中实际存在的计算机。 （也是，我应该明确说明理论概念，就像一个超级机器/功能，aren＆＃39; t new和aren＆＃39; t由于我：他们是＆＃34;众所周知＆＃34;概念从1950年开发的更高的可测量和＃39; S到1970＆＃39; S，但是计算性理论家从来没有困扰实际上以编程语言的形式制定它们。）</p><p> Another thing that I am reminded of is that, in 2012, I accidentally (i.e., without participating!) won a prize in the IOCCC competition. How it happened is a bit embarrassing for everyone involved: I  had written a program that was meant to be clear and readable and well-commented, and someone else (Aaron Grothe) reused my program, made it obfuscated and submitted it as an entry to the IOCCC (without telling me or telling the judges; which was legal because I had placed my program in the Public Domain, but perhaps a bit dishonest); the judges decided to award a prize to the program in question, and when he was asked to explain how it worked, he referred to my own work, so the judges (after consulting me) decided to make me co-winner. This is how I won the IOCCC without participating (I guess this makes me unique!), with a program that I thought was clear and well-written (which may or may not say something about my ability to write clear code :-).</p><p> 我提醒的另一件事是，在2012年，我不小心（即，不参加！）在国际联盟比赛中获奖。它是如何发生的，对于所涉及的每个人来说有点令人尴尬：我已经写了一个旨在清晰可读和评论的程序，别人（亚伦格罗切）重复使用了我的计划，使它被滥用并将其提交为进入IOCCC（没有告诉我或告诉法官;这是合法的，因为我把我的计划放在公共领域，但也许有点不诚实）;法官决定向有问题的方案颁发奖品，当他被要求解释它是如何工作的，他提到了自己的工作，所以法官（咨询我后）决定让我共同获胜。这就是我如何在没有参与的情况下赢得IOCCC（我猜这让我是独一无二的！），我认为是清楚和写的</p><p>    I said that it was not possible, in the base language (0), to write an interpreter for the language (0) itself; that is, there is no such thing as a &#34;universal&#34; function which takes two arguments, [the code of] a function    e   to execute and an argument    z   to pass to it, and which behaves like the execution of    e   (    z   ); it is also not possible, all the more so, to write in language (0) an interpreter for extended languages ​​(1), (2) and (3).</p><p>    我说，在基本语言（0）中是不可能的，为语言（0）本身写解释器;也就是说，没有像A＆＃34;普遍＆＃34;采用两个参数的函数，[代码]函数e要执行，并且参数z传递给它，表现类似于e（z）;它也是不可能的，更重要的是，用语言写入（0）扩展语言（1），（2）和（3）的解释器。</p><p> On the other hand, what    is   possible in language (0) is to write what I want to call an &#34;     essence interpreter    &#34;. It is about a function (recursive primitive, therefore) which takes    three   arguments: [the code of] a function    e   to execute, an argument    z   to pass to it, and a certain &#34;quantity of essence&#34;     t   which gives to the interpreter a time limit for the execution of    e   (    z   ) before failing: basically, the interpreter starts the execution of    e   (    z   ) for    t   execution steps (this    t  will therefore limit the main loop of the interpreter), and if the execution ends in the allotted time (less than    t   steps), the essence interpreter ends by returning the calculated value, otherwise, the essence interpreter ends with a special value &#34;lack of gasoline&#34; (in other words: I executed your program the time you told me, it did not finish in the allotted time, if you want, you can try again with more gasoline ). The gasoline interpreter, which is essentially  Kleene&#39;s    T   predicate  , even though it is tedious to write,    is   codable in my language (0), even if it is to interpret one of the more languages. rich (1), (2) or (3).</p><p> 另一方面，语言（0）中有可能是为了编写我想要打电话的内容＆＃34;精华翻译＆＃34;它是关于一个函数（递归原始，因此），它需要三个参数：[代码]函数e要执行，一个参数z传递给它，以及某个＆＃34;精华的数量＆＃34; t向解释器给出的时间限制在失败之前执行e（z）：基本上，解释器开始执行e（z）的执行步骤（这将限制解释器的主循环），如果执行在规定的时间（小于T步骤）结束，则本质解释器通过返回计算值来结束，否则，本质翻译将以特殊值＆＃34结束;缺乏汽油＆＃34; （换句话说：我在你告诉我的时候执行了你的节目，它没有在规定的时间内完成，如果你愿意，你可以再试一次更多的汽油）。汽油解释器，它基本上是Kleene＆＃39; S谓词，即使写入繁琐，也可以在我的语言（0）中是可编码的，即使是解释更多的语言。富人（1），（2）或（3）。</p><p> » Do you find (more mainstream) functional languages most appealing to work with? Do all of your esolangs build on the functional paradigm?</p><p> »你发现（更多主流）功能语言最吸引人的工作吗？所有的Esolang都在功能范式上建立吗？ </p><p> I don&#39;t program that much (and mostly in quite standard languages: C, Perl, Java, JavaScript, an occasional bit of Python), but I do enjoy the diversity of programming languages that exist, while simultaneously regretting that good ideas always end up being marred by bad decisions so the &#34;one language to rule them all&#34; is still completely elusive.</p><p>我不那么多（大多数标准语言：c，perl，java，javascript，偶尔的Python），但我确实享受了存在的分集，同时对那些好的想法感到敬意总是最终被错误的决定所造成的，所以＆＃34;一种统治它们的一种语言＆＃34;仍然完全难以捉摸。</p><p> Functional programming is definitely something natural and appealing to mathematicians: first, because we&#39;re used to dealing with functions as first-class citizens (and defining functions which take functions as input or return functions as output, to an arbitrary degree of complexity), and second, concerning purely functional (i.e., side-effect-free) languages, because the mathematical world is, largely speaking, conceived as unchanging. So Haskell in particular is a language whose ideas I, and I think many mathematicians, find extremely satisfactory (and the typing system relies on many mathematical ideas). However, I have to say that when I actually tried to use Haskell for practical stuff, I was disappointed, because you often face the dilemma of either doing things in a mathematically elegant way or having to break the elegance for efficiency&#39;s sake (maybe experienced Haskell programmers know how to avoid the dilemma, but for a beginner like myself it was something of a letdown).</p><p> 功能性编程绝对是自然和吸引数学家的吸引力：首先，因为我们曾经处理了作为一流公民的函数（以及定义将功能作为输入或返回函数的函数作为输出定义，以任意复杂程度）和第二，关于纯粹的功能（即无副作用的）语言，因为数学世界在很大程度上是说，构思不变。所以Haskell特别是一种语言，我的想法我和我认为很多数学家，发现非常令人满意（并且键入系统依赖于许多数学想法）。但是，我不得不说，当我实际试图为实际的东西使用Haskell时，我很失望，因为你经常面对以数学优雅的方式做事的困境或不得不打破效率的优雅＆＃39; （也许经验丰富的Haskell程序员知道如何避免困境，但是对于像我这样的初学者，这是一种放松的东西）。</p><p>  » Your site is a charming throwback to the &#39;90s personal webpage (complete with ~). While it has some newer content mixed into your info from 30 years back, you&#39;ve maintained both the look and the unguarded sensibility where everything is shared from the mundane to the very personal: favorite authors, the slightly  different shade of blue in your eyes, to more personal writing like the &#34; Petite autobiographie gaie&#34; with descriptions of loneliness and connection as a young gay man and  the long description of your personality. Is this a more open and honest Web that you seek out?</p><p>  »您的网站是＆＃39; 90s个人网页的迷人回归（完整〜）。虽然它有一些较新的内容从30年后收到您的信息，＆＃39;维护了一切的外观和无人防护的敏感性，所有内容都是从世俗的方式分享到非常个人：最喜欢的作者，略有不同的蓝色阴影你的眼睛，更加个人的写作像＆＃34;娇小自传盖和＃34;描述孤独和连接作为年轻同性恋者和你个性的长篇描述。这是一个更开放和诚实的网络，你寻找吗？</p><p> The state of my web site is mostly due to my lack of time and patience at keeping things up to date: I find that writing things once is easy but maintaining them afterwards requires a tremendous amount of work. This is why I now prefer to publish things in the form of (often very long) blog posts, which are clearly dated so there is clearly no promise that they will be updated later, in fact there is more of an assumption to the contrary. So pretty much everything else on my web site is in limbo (and in various different circles of limbo, since I changed my mind a number of times as to how to organize and style my web pages and never got around to uniformizing everything).</p><p> 我的网站的状态主要是由于我缺乏时间和耐心，保持迄今为止的事情：我发现写作曾经很容易，但之后维护它们需要巨大的工作。这就是为什么我现在更愿意以（通常是非常长）博客帖子的形式发布事物，这显然是如此明显没有承诺，他们将在以后更新，实际上是相反的假设。所以我的网站上的其他一切都在泥泞中（以及各种不同的Limbo圈子，因为我改变了多次如何组织和风格我的网页，从未彻底统一过一切）。</p><p> On the other hand, it&#39;s true that I also care greatly about things like URL longevity, and I try very hard not to break links once I&#39;ve published them. When I re-read my past blog entries, I&#39;m often upset by how many links have broken, often over a short span of time.</p><p> 另一方面，它＆＃39;真的，我也非常关心像URL LONGEVITY这样的事情，我很难一旦我发表了一旦发布了他们就会努力打破链接。当我重新阅读我过去的博客条目时，我常常在短时间内破坏了多少个链接，常常烦恼。</p><p> » Are there other esolangs of yours that I haven’t yet asked about?</p><p> »我还有其他esolang，我还没有问过吗？</p><p> I couldn&#39;t say. ;-) I mean, I had pretty much forgotten about &#34;Amicus&#34; which, as explained above, is something of an accident, so there may be others!</p><p> 我不能说。 ;-)我的意思是，我几乎忘记了关于＆＃34; amicus＆＃34;如上所述，这是一个事故的东西，所以可能有其他人！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://esoteric.codes/blog/david-madore">https://esoteric.codes/blog/david-madore</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/大卫/">#大卫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/david/">#david</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>