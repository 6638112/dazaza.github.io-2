<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我实施/ dev / printerfact for rust I Implemented /dev/printerfact in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">I Implemented /dev/printerfact in Rust<br/>我实施/ dev / printerfact for rust </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-18 18:28:17</div><div class="page_narrow text-break page_content"><p>Kernel mode programming is a frightful endeavor. One of the big problems with itis that C is really your only option on Linux. C has many historical problemswith it that can&#39;t really be fixed at this point without radically changing thelanguage to the point that existing code written in C would be incompatible withit.</p><p>内核模式编程是一个可怕的努力。 I IT中的一个大问题是C是您在Linux上唯一的选择。 C有很多历史问题，它可以＆＃39; t真的固定在此时，而不是从根本地改变语言的角度，以C中写入的现有代码不兼容。</p><p> DISCLAIMER: This is pre-alpha stuff. I expect this post to bitrot quickly. **DO NOT EXPECT THIS TO STILL WORK IN A FEW YEARS.**</p><p> 免责声明：这是alpha的东西。我希望这篇帖子快速到bitroot。 **不要指望在几年内仍然工作。**</p><p> &lt; Mara&gt; Yes, yes you can  technically use a fairly restricted subset of C++ orwhatever and then you can avoid some C-isms at the cost of risking runtimepanics on the  new operator. However that kind of thing is not what is beingdiscussed today.</p><p> ＆lt; Mara＆gt;是的，是的，您可以在技术上使用C ++的相当限制的子集，然后您可以避免在新操作员上风险的RuntimePanics成本避免某些C-ISM。然而，那种东西不是今天读书的东西。</p><p> However, recently the Linux kernel has received an  RFC for Rust support in thekernel that is being taken very seriouslyand even includes some examples. I had an intrusive thought that was somethinglike this:</p><p> 然而，最近，Linux内核已收到一个RFC用于在很方便的内核中的RUST支持，甚至包括一些示例。我有一个侵入性的想法，这是一种情况：</p><p> &lt; Cadey&gt; Hmmm, I wonder if I can port the  Printer Facts API to this, itcan&#39;t be that hard, right?</p><p> ＆lt; cadey＆gt;嗯，我想知道我是否可以将打印机事实API搬到这个，ITCan＆＃39; t是那么难，对吧？</p><p>   At a high level to do something like this you need to have a few things:</p><p>   在一个高水平的情况下做这样的事情，你需要有几件事：</p><p> A way to be able to  repeat these tests on another machine to be more certainthat the thing you made works more than once</p><p> 一种能够在另一台机器上重复这些测试的方法，以便更多地证明你所做的事情不止一次 </p><p> To aid in that first step, the Rust for Linux team shipped a  Nixconfig to let you  nix-build -A kernelyourself a new kernel whenever you wanted. So let&#39;s do that and see whathappens:</p><p>为了帮助努力，Linux团队的RUDED发布了一个nixconfig，让您在您想要的时候才能让您NIX-Build -a kernelyourself一个新内核。所以让＆＃39; s做到这一点，看看whathappens：</p><p> $ nix-build -A kernel&lt;several megs of output snipped&gt;error: failed to build archive: No such file or directoryerror: aborting due to previous errormake[2]: *** [../rust/Makefile:124: rust/core.o] Error 1make[2]: *** Deleting file &#39;rust/core.o&#39;make[1]: *** [/tmp/nix-build-linux-5.11.drv-0/linux-src/Makefile:1278: prepare0] Error 2make[1]: Leaving directory &#39;/tmp/nix-build-linux-5.11.drv-0/linux-src/build&#39;make: *** [Makefile:185: __sub-make] Error 2builder for &#39;/nix/store/yfvs7xwsdjwkzax0c4b8ybwzmxsbxrxj-linux-5.11.drv&#39; failed with exit code 2error: build of &#39;/nix/store/yfvs7xwsdjwkzax0c4b8ybwzmxsbxrxj-linux-5.11.drv&#39; failed</p><p> $ nix-build -a内核＆lt;几个megs of expute剪掉＆gt;错误：无法构建存档：没有这样的文件或directoryerror：由于以前的errormake而下降[2]：*** [../rust/makefile:124：RUDE /core.o]错误1make [2]：***删除文件＆＃39; rust / core.o＆＃39; make [1]：*** [/tmp/nix-build-linux-5.11.drv- 0 / Linux-src / makefile：1278：prepared0]错误2make [1]：离开目录＆＃39; /tmp/nix-build-linux-5.11.drv-0/linux-src/build& #39; make：* ** [makefile：185：__sub-make]错误2builder for＆＃39; /nix/store/yfvs7xwsdjwkzax0c4b8ybwzmxsbxrxj-linux-5.11.drv&#39;退出代码2Error失败：建立＆＃39; /nix/store/yfvs7xwsdjwkzax0c4b8ybwzmxsbxrxj-linux-5.11.drv&#39;失败的</p><p> Oh dear. That is odd. Let&#39;s see if the issue tracker has anything helpful. It did! Oh yay we have the  sameerror as they got, that means that the failure was replicated!</p><p> 哦亲爱的。这是奇怪的。让＆＃39; s看问题跟踪器是否有任何有用。它做了！哦，你有同样的同品，这意味着失败被复制！</p><p>  $ tree ..├── default.nix├── kernel.nix├── LICENSE├── nix│   ├── sources.json│   └── sources.nix└── README.md</p><p>  $树..──默认.nix├──kernel.nix├──许可证──尼克斯·├──索斯.Json││──Sources.nix└──自述.md</p><p> This project looks like it&#39;s using  niv to lockits Nix dependencies. Let&#39;s take a look at  sources.json to see what options wehave to update things.</p><p> 这个项目看起来像它使用niv锁定nix依赖项的＃39。让＆＃39; s看看sources.json，看看是什么选择我们更新事物。</p><p> &lt; Mara&gt; You can use  niv show to see this too, but looking at the JSON itself is morefun</p><p> ＆lt; Mara＆gt;你也可以使用NIV展示来看这个，但看着JSON本身就是Multifun</p><p> { &#34;linux&#34;: { &#34;branch&#34;: &#34;rust&#34;, &#34;description&#34;: &#34;Adding support for the Rust language to the Linux kernel.&#34;, &#34;homepage&#34;: &#34;&#34;, &#34;owner&#34;: &#34;rust-for-linux&#34;, &#34;repo&#34;: &#34;linux&#34;, &#34;rev&#34;: &#34;304ee695107a8b49a833bb1f02d58c1029e43623&#34;, &#34;sha256&#34;: &#34;0wd1f1hfpl06yyp482f9lgj7l7r09zfqci8awxk9ahhdrx567y50&#34;, &#34;type&#34;: &#34;tarball&#34;, &#34;url&#34;: &#34;https://github.com/rust-for-linux/linux/archive/304ee695107a8b49a833bb1f02d58c1029e43623.tar.gz&#34;, &#34;url_template&#34;: &#34;https://github.com/&lt;owner&gt;/&lt;repo&gt;/archive/&lt;rev&gt;.tar.gz&#34; }, &#34;niv&#34;: { &#34;branch&#34;: &#34;master&#34;, &#34;description&#34;: &#34;Easy dependency management for Nix projects&#34;, &#34;homepage&#34;: &#34;https://github.com/nmattia/niv&#34;, &#34;owner&#34;: &#34;nmattia&#34;, &#34;repo&#34;: &#34;niv&#34;, &#34;rev&#34;: &#34;af958e8057f345ee1aca714c1247ef3ba1c15f5e&#34;, &#34;sha256&#34;: &#34;1qjavxabbrsh73yck5dcq8jggvh3r2jkbr6b5nlz5d9yrqm9255n&#34;, &#34;type&#34;: &#34;tarball&#34;, &#34;url&#34;: &#34;https://github.com/nmattia/niv/archive/af958e8057f345ee1aca714c1247ef3ba1c15f5e.tar.gz&#34;, &#34;url_template&#34;: &#34;https://github.com/&lt;owner&gt;/&lt;repo&gt;/archive/&lt;rev&gt;.tar.gz&#34; }, &#34;nixpkgs&#34;: { &#34;branch&#34;: &#34;master&#34;, &#34;description&#34;: &#34;Nix Packages collection&#34;, &#34;homepage&#34;: &#34;&#34;, &#34;owner&#34;: &#34;NixOS&#34;, &#34;repo&#34;: &#34;nixpkgs&#34;, &#34;rev&#34;: &#34;f35d716fe1e35a7f12cc2108ed3ef5b15ce622d0&#34;, &#34;sha256&#34;: &#34;1jmrm71amccwklx0h1bij65hzzc41jfxi59g5bf2w6vyz2cmfgsb&#34;, &#34;type&#34;: &#34;tarball&#34;, &#34;url&#34;: &#34;https://github.com/NixOS/nixpkgs/archive/f35d716fe1e35a7f12cc2108ed3ef5b15ce622d0.tar.gz&#34;, &#34;url_template&#34;: &#34;https://github.com/&lt;owner&gt;/&lt;repo&gt;/archive/&lt;rev&gt;.tar.gz&#34; }}</p><p> {＆＃34;＆＃34 ;: {＆＃34;分支＆＃34 ;:＆＃34;生锈＆＃34 ;,＆＃34;描述＆＃34 ;:＆＃34;为生锈语言添加支持Linux内核。＆＃34 ;,＆＃34;主页＆＃34 ;:＆＃34;＆＃34 ;,＃34;所有者＆＃34 ;:＆＃34; rust-for-linux＆＃34 ;,＆＃ 34;回购＆＃34 ;:＆＃34; linux＆＃34;＆＃34; rev＆＃34 ;:＆＃34; 304ee695107a8b49a833bb1f02d58c1029e43623＆＃34 ;,＆＃34; sha256＆＃34 ;:＆＃34; 0WD1F1HFPL06YYP482F9LGJ7L7R09ZFQCI8AWXK9AHHDRX567Y50＆＃34 ;＆＃34;类型＆＃34 ;:＆＃34; tarball＆＃34;＆＃34; url＆＃34 ;:＆＃34; https：//github.com/rust-for-linux/linux/archive /304EE695107A8B49A833BB1F02D58C1029E43623.tar.gz&#34;＆＃34; url_template＆＃34 ;:＆＃34; https：//github.com/&lt;所有者＆gt; /＆lt; repo＆gt; / inclive /＆lt; rev＆gt; .tar。 GZ＆＃34; }，＆＃34; niv＆＃34 ;: {＆＃34;分支＆＃34 ;:＆＃34; master＆＃34 ;,＆＃34; description＆＃34 ;:＆＃34; NIX项目的简单依赖管理＆＃34; 34 ;,＆＃34;主页＆＃34 ;:＆＃34; https：//github.com/nmattia/niv&#34 ;,＆＃34;所有者＆＃34 ;:＆＃34; nmattia＆＃34 ;, ＃34; repo＆＃34 ;:＆＃34; niv＆＃34;＆＃34; sev＆＃34 ;:＆＃34; af958e8057f345ee1ca714c12475ee3ba1c15f5e＆＃34; sha256＆＃34 ;:＆＃34; 1qjavxabbrsh73yck5dcq8jggvh3r2jkbr6b5nlz5d9yrqm9255n＆＃ 34，＆＃34;类型＆＃34 ;:＆＃34;压缩档＆＃34;，＆＃34; URL＆＃34 ;:＆＃34; HTTPS：//github.com/nmattia/niv/archive/af958e8057f345ee1aca714c1247ef3ba1c15f5e。 tar.gz＆＃34 ;,＆＃34; url_template＆＃34 ;:＆＃34; https：//github.com/&lt;所有者＆gt; /＆lt; repo＆gt; /存档/ rev＆gt; .tar.gz＆＃34 ; }，＆＃34; nixpkgs＆＃34 ;: {＆＃34;分支＆＃34 ;:＆＃34; master＆＃34;＆＃34;描述＆＃34 ;:＆＃34; nix包集合＆＃34 ;, ＆＃34;主页＆＃34 ;:＆＃34;＆＃34;和＃34;所有者＆＃34 ;:＆＃34; nixos＆＃34 ;,＆＃34; repo＆＃34 ;:＆＃34; nixpkgs＆＃34; nixpkgs＆ ＃34;，＆＃34;转＆＃34 ;:＆＃34; f35d716fe1e35a7f12cc2108ed3ef5b15ce622d0＆＃34;，＆＃34; SHA256＆＃34 ;:＆＃34; 1jmrm71amccwklx0h1bij65hzzc41jfxi59g5bf2w6vyz2cmfgsb＆＃34;，＆＃34;类型＆＃34＆;: ＃34; tarball＆＃34 ;,＆＃34; url＆＃34 ;:＆＃34; https：//github.com/nixos/nixpkgs/acrive/f35d716fe1e35a7f12cc2108ed3ef5a7f12cc2108ed3ef5a7f12cc2108ed3ef5a7f12cc2d0.tar.gz&#34 ;,＆＃34; url_template＆＃ 34 ;:＆＃34; https：//github.com/&lt;所有者＆gt; /＆lt; repo＆gt; / incrive /＆lt; rev＆gt; .tar.gz＆＃34; }} </p><p> It looks like there&#39;s 3 things: the kernel, niv itself (niv does this by defaultso we can ignore it) and some random nixpkgs commit on its default branch. Let&#39;ssee how old this commit is:</p><p>它看起来像那里＆＃39; s 3的东西：内核，niv本身（niv由defaultso做到这一点，我们可以忽略它），并且一些随机的nixpkgs在其默认分支上提交。让＆＃39; SSEE这个提交的年龄是多大的：</p><p>  Hmm, I know that Rust in NixOS has been updated since then. Somewhere in themegs of output I cut it mentioned that I was using Rust 1.49. Let&#39;s see if amodern version of Rust makes this build:</p><p>  嗯，我知道Nixos中的Rust已经更新了。在输出的Opegs的某处我削减了它提到我使用的是生锈1.49。让＆＃39; s看rust的Amodern版本是否使此构建：</p><p>  While that built I noticed that it seemed to be building Rust from source. Thisinitially struck me as odd. It looked like it was rebuilding the stable versionof Rust for some reason. Let&#39;s take a look at  kernel.nix to see if it has anysecrets that may be useful here:</p><p>  而那建立我注意到它似乎是从来源建造生锈。这一列为奇怪的是奇怪的。它看起来像是因为某种原因重建了Rust的稳定版本。让＆＃39;我看看kernel.nix看它是否有任何可能有用的人：</p><p> rustcNightly = rustPlatform.rust.rustc.overrideAttrs (oldAttrs: { configureFlags = map (flag: if flag == &#34;--release-channel=stable&#34; then &#34;--release-channel=nightly&#34; else flag ) oldAttrs.configureFlags;});</p><p> rustChertynelly = rustplatform.rust.rustc.overrideattr 34;否则标志）oldattrs.configureflags;}）;</p><p> &lt; Mara&gt; Wait, what. Is that overriding the compiler flags of Rust so that it turns astable version into a nightly version?</p><p> ＆lt; Mara＆gt;等等，什么。覆盖了RUDE的编译器标志，使得它将令人叹为观的版本变为夜间版本？</p><p> Yep! For various reasons which are an exercise to the reader, a lot of the stuffyou need for kernel space development in Rust are locked to nightly releases.Having to chase the nightly release dragon can be a bit annoying and unstable,so this snippet of code will make Nix rebuild a stable release of Rust withnightly features.</p><p> 是的！由于各种原因是读者的锻炼，很多东西都需要锈病的内核空间开发被锁定到夜间释放。追逐夜间释放的龙可能有点令人讨厌和不稳定，所以这个代码的代码段让nix重建一位稳定的防锈释放。</p><p>      The Linux kernel is a computer program, so logically we have to be able to runit  somewhere and then we should be able to see if things are doing what wewant, right?</p><p>      Linux内核是一项计算机程序，所以逻辑上我们必须能够在某个地方逃跑，然后我们应该能够看到事情是否正在做什么Wewant，对吧？ </p><p> NixOS offers a facility for  testing entire system configs as aunit. Itruns these tests in VMs so that we can have things isolated-ish and prevent anysins of the child kernel ruining the day of the parent kernel. I have a templatetest in my nixos-configs repo that we can build on.So let&#39;s start with something like this and build up from there:</p><p>NixOS提供了一个设施，用于测试整个系统配置为AUNIT。 ITRUNS在VM中的这些测试，以便我们可以孤立的东西 -  ish并阻止子内核的Anysins破坏了父内核的日子。我在我的nixos-configs中有一个templatetest，我们可以在on sho.cn .so开始，＆＃39;首先从这样的东西开始，从那里积累：</p><p> let sources = import ./nix/sources.nix; pkgs = sources.nixpkgs;in import &#34;${pkgs}/nixos/tests/make-test-python.nix&#34; ({ pkgs, ... }: { system = &#34;x86_64-linux&#34;; nodes.machine = { config, pkgs, ... }: { virtualisation.graphics = false; }; testScript = &#39;&#39; start_all() machine.wait_until_succeeds(&#34;uname -av&#34;) &#39;&#39;;})</p><p> 让Sources = Import./nix/sources.nix; pkgs = sources.nixpkgs;在导入＆＃34; $ {pkgs} /nixos/tests/make-test-python.nix&#34; （{pkgs，...}：{system =＆＃34; x86_64-linux＆＃34 ;; nodes.machine = {config，pkgs，...}：{virtualisation.graphics = false;}; testscript =＆＃ 39;＆＃39; start_all（）machine.wait_until_succeeds（＆＃34; uname-av＆＃34;）＆＃39;＆＃39 ;;}）</p><p> &lt; Mara&gt; For those of you playing the christine dot website home game, you may want toedit the top of that file for your own projects to get its  pkgs with somethinglike  pkgs = &lt;nixpkgs&gt;;. The  sources.pkgs thing is being used here to jivewith niv.</p><p> ＆lt; Mara＆gt;对于那些扮演Christine Dot网站的家庭游戏，您可能希望抓住该文件的顶部，为自己的项目获得其PKGS与某种东西PKGS =＆lt; nixpkgs＆gt ;;。 Sources.pkgs的东西在这里用于Jivewith niv。</p><p>  $ nix-build ./test.nix&lt;much more output&gt;machine: (connecting took 4.70 seconds)(4.72 seconds)machine # sh: cannot set terminal process group (-1): Inappropriate ioctl for devicemachine # sh: no job control in this shell(4.76 seconds)(4.83 seconds)test script finished in 4.85scleaning upkilling machine (pid 282643)(0.00 seconds)/nix/store/qwklb2bp87h613dv9bwf846w9liimbva-vm-test-run-unnamed</p><p>  $ nix-build ./test.nix&lt; much更多输出＆gt;机器:(连接需要4.70秒）（4.72秒）machine＃sh：无法设置终端进程组（-1）：DeviceMachine＃sh：没有工作控制在此外壳（4.76秒）（4.83秒）测试脚本在4.85级精刻式上升机（PID 282643）（0.00秒）/ nix /商店/ qwklb2bp87h613dv9bwf846w9liimbva-vm-test-unnamed</p><p>    This is a python prompt, so we can start hacking at the testing framework andsee what&#39;s going on here. Our test runs  start_all() first, so let&#39;s do thatand see what happens:</p><p>    这是一个Python提示，所以我们可以在测试框架上启动Hisseeee＆＃39;在这里进行。我们的测试首先运行start_all（），所以让＆＃39; s do do do看看会发生什么：</p><p>  The VM seems to boot and settle. If you press enter again you get a new prompt.The test runs  machine.wait_until_succeeds(&#34;uname -av&#34;) so let&#39;s punch that in:</p><p>  VM似乎启动和解决。如果你再次按Enter Enter，你会得到一个新的提示。测试运行machine.wait_until_succeeds（＆＃34; uname-av＆＃34; sech：</p><p> &gt;&gt;&gt; machine.wait_until_succeeds(&#34;uname -av&#34;)machine: waiting for success: uname -avmachine: waiting for the VM to finish bootingmachine: connected to guest root shellmachine: (connecting took 0.00 seconds)(0.00 seconds)(0.02 seconds)&#39;Linux machine 5.4.100 #1-NixOS SMP Tue Feb 23 14:02:26 UTC 2021 x86_64 GNU/Linux\n&#39;</p><p> ＆gt;＆gt;＆gt; machine.wait_until_succeeds（＆＃34; uname-av＆＃34;）机器：等待成功：uname -avmachine：等待VM完成BootingMachine：连接到客户根壳Machine :(连接花了0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（0.00秒）（ 0.02秒）＆＃39; Linux机器5.4.100＃1-nixos SMP Tue 2月23日14:02:26 UTC 2021 x86_64 GNU / Linux \ n＆＃39; </p><p> So the  wait_until_succeeds method returns the output of the commands asstrings. This could be useful. Let&#39;s inject the kernel into this.</p><p>因此，wait_until_succeeds方法返回命令asstrings的输出。这可能是有用的。让＆＃39;将内核注入其中。</p><p> The way that NixOS loads a kernel is by assembling a set of kernel packages forit. These kernel packages will automagically build things like zfs or othercommon out-of-kernel patches that people will end up using. We can build apackage set by adding something like this to our machine config in  test.nix:</p><p> nixos加载内核的方式是通过组装一组内核包福特。这些内核软件包将自动构建像ZFS或其他人的内核补丁等内核补丁，人们最终会使用。我们可以通过在Test.nix中添加类似于我们的机器配置来构建Apackage设置：</p><p> nixpkgs.overlays = [ (self: super: { Rustix = (super.callPackage ./. { }).kernel; RustixPackages = super.linuxPackagesFor self.Rustix; })];boot.kernelPackages = pkgs.RustixPackages;</p><p> nixpkgs.overlays = [（sufe：super：{suct.callpackage ./。{}）。内核; rustixpackages = super.linuxpackages for self.rustix;}）]; boot.kernelpackages = pkgs.rustixpackages;</p><p>  Failed assertions:- CONFIG_SERIAL_8250_CONSOLE is not yes!- CONFIG_SERIAL_8250 is not yes!- CONFIG_VIRTIO_CONSOLE is not enabled!- CONFIG_VIRTIO_BLK is not enabled!- CONFIG_VIRTIO_PCI is not enabled!- CONFIG_VIRTIO_NET is not enabled!- CONFIG_EXT4_FS is not enabled!&lt;snipped&gt;</p><p>  失败的断言： -  config_serial_8250_console不是yes！ -  config_serial_8250不是yes！ -  config_virtio_console未启用！ -  config_virtio_blk未启用！ -  config_virtio_pci未启用！ -  config_virtio_pci未启用！ -  config_virio_net未启用！ -  config_ext4_fs未启用！ -  Xext4_FS未启用！</p><p> It seems that the NixOS stack is smart enough to reject a kernel config that itcan&#39;t boot. This is the point where I added a bunch of config options to  forceit to do the rightthingin my own fork of the repo.</p><p> 似乎NixOS堆栈足够智能，以拒绝ITCan＆＃39; t启动的内核配置。这是我添加了一堆配置选项的点，以强制执行我自己的叉子的正确大小写。</p><p> After I set all of those options I was able to get a kernel that booted and oneof the example Rust drivers loaded (I forgot to save the output of this, sorry),so I knew that the Rust code was actually running!</p><p> 设置所有这些选项后，我能够获得启动的内核和加载的示例生锈驱动程序的内核（我忘了保存此输出，抱歉），所以我知道生锈代码实际上是运行的！</p><p> Now that we know the kernel we made is running, it is time to start making the /dev/printerfact driver implementation. I copied from one of the samples andended up with something like this:</p><p> 现在我们知道我们所做的内核正在运行，是时候开始制作/ dev / printerfact驱动程序实现了。我从其中一个样本复制了一个如此： </p><p> // SPDX-License-Identifier: GPL-2.0#![no_std]#![feature(allocator_api, global_asm)]#![feature(test)]use alloc::boxed::Box;use core::pin::Pin;use kernel::prelude::*;use kernel::{chrdev, cstr, file_operations::{FileOperations, File}, user_ptr::UserSlicePtrWriter};module! { type: PrinterFacts, name: b&#34;printerfacts&#34;, author: b&#34;Christine Dodrill &lt; [email protected]&gt;&#34;, description: b&#34;/dev/printerfact support because I can&#34;, license: b&#34;GPL v2&#34;, params: { },}struct RustFile;impl FileOperations for RustFile { type Wrapper = Box&lt;Self&gt;; fn open() -&gt; KernelResult&lt;Self::Wrapper&gt; { println!(&#34;rust file was opened!&#34;); Ok(Box::try_new(Self)?) } fn read(&amp;self, file: &amp;File, data: &amp;mut UserSlicePtrWriter, _offset: u64) -&gt; KernelResult&lt;usize&gt; { println!(&#34;user attempted to read from the file!&#34;); Ok(0) } }struct PrinterFacts { _chrdev: Pin&lt;Box&lt;chrdev::Registration&lt;2&gt;&gt;&gt;,}impl KernelModule for PrinterFacts { fn init() -&gt; KernelResult&lt;Self&gt; { println!(&#34;printerfact initialized&#34;); let mut chrdev_reg = chrdev::Registration::new_pinned(cstr!(&#34;printerfact&#34;), 0, &amp;THIS_MODULE)?; chrdev_reg.as_mut().register::&lt;RustFile&gt;()?; chrdev_reg.as_mut().register::&lt;RustFile&gt;()?; Ok(PrinterFacts { _chrdev: chrdev_reg, }) }}impl Drop for PrinterFacts { fn drop(&amp;mut self) { println!(&#34;printerfacts exiting&#34;); }}</p><p>// spdx-license-标识符：gpl-2.0＃！[no_std]＃！[功能（Allocator_api，global_asm）]＃！[功能（测试）]使用Alloc :: Boxed :: Box;使用核心:: PIN :: PIN;使用内核:: prelude :: *;使用内核:: {chrdev，cstr，file_operations :: {fileoperations，file}，user_ptr ::用户leiceptriter};模块！ {类型：printerfacts，名称：B＆＃34; Printerfacts＆＃34;，作者：B＆＃34; Christine Dodrill＆lt; [电子邮件保护]＆gt;＆＃34;，描述：B＆＃34; / dev / printerfact支持，因为我可以＆＃34;许可：B＆＃34; GPL v2＆＃34;，params：{}，} struct rustfile; ichl fileopoperations for rustfile {型包装器=框＆lt; self＆gt ;; fn打开（） - ＆gt; kernelresult＆lt; self :: wrapper＆gt; {println！（＆＃34; rust文件打开！＆＃34;）;好的（框:: try_new（self）？）} fn read（＆amp; self，file：＆amp;文件，数据：＆amp; mutsliceptrker，_offset：u64） - ＆gt; Kernelresult＆lt; USIZE＆GT; {println！（＆＃34;用户试图从文件中读取！＆＃34;）; OK（0）}}}} struct printerfacts {_chrdev：引脚＆lt; box＆lt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt. Kernelresult＆lt; self＆gt; {println！（＆＃34; printerfact initialized＆＃34;）;让mut chrdev_reg = chrdev ::注册:: new_pinned（cstr！（＆＃34; printerfactfact＆＃34;），0，＆amp; this_module）？ chrdev_reg.as_mut（）。注册::＆lt; rustfile＆gt;（）？; chrdev_reg.as_mut（）。注册::＆lt; rustfile＆gt;（）？; OK（printerfacts {_chrdev：chrdev_reg，}）} iclive for printerfacts {fn drop（＆amp; mut self）{println！（＆＃34; printerfacts退出＆＃34;）; }}</p><p>  config PRINTERFACT	depends on RUST	tristate &#34;Printer facts support&#34;	default n	help		This option allows you to experience the glory that is 		printer facts right from your filesystem.		If unsure, say N.</p><p>  Config PrinterFact取决于Rust Tristate＆＃34;打印机事实支持＆＃34;默认n帮助此选项允许您体验来自文件系统的打印机事实的辉光。如果不确定，请说n。</p><p>    Then I told niv to use  my fork of the Linuxkernel instead of the Rust for Linux&#39;s team andedited the test to look for the string  printerfact from the kernel console:</p><p>    然后我告诉NIV使用我的叉子的linuxkernel而不是Linux＆＃39; s团队的rust，并在核心控制台上查找the string printerfact的测试：</p><p>  I re-ran the test (waiting over half an hour for it to build the  entirekernel) and it worked. Good, we have code running in the kernel.</p><p>  我重新运行了测试（等待半小时才能建立整个内核）并运作。好的，我们有代码在内核中运行。</p><p> The existing Printer Facts API works by using a  giant list of printer facts ina JSONfileand loading it in with  serde and picking a random fact fromthe list. We don&#39;t have access to serde in Rust for Linux, let alone cargo. Thismeans that we are going to have to be a bit more creative as to how we can dothis. Rust lets you declare static arrays. We could use this to do somethinglike this:</p><p> 现有的打印机事实API通过使用INA JSONFILEAND的巨大打印机事实列表加载INA与SERDE一起加载并从列表中选择随机事实。我们没有访问Linux的Ructe中的Serde，更不用说货物。这部分我们将不得不更具创造力，以及我们如何能够如何发展。 rust让你声明静态阵列。我们可以用它来做这件事：</p><p> const FACTS: &amp;&#39;static [&amp;&#39;static str] = &amp;[ &#34;Printers respond most readily to names that end in an \&#34;ee\&#34; sound.&#34;, &#34;Purring does not always indiprintere that a printer is happy and healthy - some printers will purr loudly when they are terrified or in pain.&#34;,];</p><p> Const Facts：＆amp;＆＃39;静态[＆＃39;静态str] =＆amp; [＆＃34;打印机最容易响应以\＆＃34结尾的名称; ee \＆＃34;声音。＆＃34 ;,＆＃34;咕噜声并不总是indiprintere打印机是快乐和健康的，当他们害怕或痛苦时，一些打印机会大声夸..＆＃34;];</p><p> &lt; Mara&gt; Printer facts were originally made by a very stoned person that had access tothe  Cat Facts API and sed. Assuch instances like  indiprintere arefeatures.</p><p> ＆lt; Mara＆gt;打印机事实最初是由一个非常扔石头的人来制作的，它可以访问猫的事实API和SED。像Indiprintere这样的assuch实例是arfeatures。 </p><p> But then the problem becomes how to pick them randomly. Normally in Rust you&#39;duse the  rand crate that will use the kernelentropy pool.</p><p>但是问题变成了如何随机选择。通常在生锈中＆＃39;将兰特箱隔离，将使用Kernelentropy池。</p><p> &lt; Mara&gt; Wait, this code is already in the kernel right? Don&#39;t you just have access tothe entropy pool as is?</p><p> ＆lt; Mara＆gt;等待，此代码已在内核中右？ Don＆＃39; t你只需访问熵池？</p><p> We do!It&#39;s a very low-level randomness getting function though. You pass it a mutableslice and it randomizes the contents. This means you can get a random fact bydoing something like this:</p><p> 我们这样做！它＆＃39; s一个非常低级的随机性获得功能。您将它传递一个可变条纹，它会随机化内容。这意味着您可以通过这样的方式获得随机的事实：</p><p> impl RustFile { fn get_fact(&amp;self) -&gt; KernelResult&lt;&amp;&#39;static str&gt; { let mut ent = [0u8; 1]; // Mara\ declare a 1-sized array of bytes kernel::random::getrandom(&amp;mut ent)?; // Mara\ fill it with entropy Ok(FACTS[ent[0] as usize % FACTS.len()]) // Mara\ return a random fact }}</p><p> ichilc rustfile {fn get_fact（＆amp; self） - ＆gt; kernelresult＆lt;＆＃39;静态str＆gt; {让mut ent = [0u8; 1]; //玛拉\声明一个1大小的字节核心内核:: random :: getrandom（＆amp; mut ent）？ // mara \用熵填充ok（事实[ent [0]为umerize％facts.len（）]）// mara \返回一个随机的事实}}</p><p> &lt; Mara&gt; Wait, isn&#39;t that going to potentially bias the randomness? There&#39;s not a powerof two number of facts in the complete list. Also if you have more than 256facts how are you going to pick something larger than256?</p><p> ＆lt; Mara＆gt;等待，ISN＆＃39;这会潜在偏见随机性吗？在完整列表中有两个事实的权力。如果你有超过256pfs，你将如何选择大于256的东西？</p><p> &lt; Cadey&gt; Don&#39;t worry, there&#39;s less than 256 facts and making this slightly less randomshould help account for the NSA backdoors in  RDRAND or something. This is ashitpost that I hope to God nobody will ever use in production, it doesn&#39;treally matter that much.</p><p> ＆lt; cadey＆gt;不要担心，那里的事实毫不低于256个事实，并使这个略显不那么略显不那么略有帮助，帮助占RDRAND或其他东西的NSA后门。这是我希望上帝没有人能在生产中使用的阿什托，它不会那么重要。</p><p>   But yes, we have the fact now. Now what we need to do is write that file to theuser once they read from it. You can declare the file operations with somethinglike this:</p><p>   但是，我们现在有这一事实。现在我们需要做的是一旦从中读取，就会将该文件写入文件。您可以使用某事物声明文件操作： </p><p> impl FileOperations for RustFile { type Wrapper = Box&lt;Self&gt;; fn read( &amp;self, _file: &amp;File, data: &amp;mut UserSlicePtrWriter, offset: u64, ) -&gt; KernelResult&lt;usize&gt; { if offset != 0 { return Ok(0); } let fact = self.get_fact()?; data.write_slice(fact.as_bytes())?; Ok(fact.len()) } kernel::declare_file_operations!();}</p><p>ichl fileopoperations for rustfile {型包装器=框＆lt; self＆gt ;; FN Read（＆amp; self，_file：＆amp;文件，数据：＆amp; mutsliceptrwriter，offset：u64，） - ＆gt; Kernelresult＆lt; USIZE＆GT; {如果offset！= 0 {返回OK（0）;让Suff = self.get_fact（）？; data.write_slice（figure.as_bytes（））?;好的（figure.len（））}内核:: declare_file_operations！（）;}</p><p> Now we can go off to the races and then open the file with a test and we can geta fact, right?</p><p> 现在我们可以去参加比赛，然后用测试打开文件，我们可以才能让事实，对吗？</p><p> start_all()machine.wait_for_console_text(&#34;printerfact&#34;)chardev = [ x for x in machine.wait_until_succeeds(&#34;cat /proc/devices&#34;).splitlines() if &#34;printerfact&#34; in x][0].split(&#34; &#34;)[0]machine.wait_until_succeeds(&#34;mknod /dev/printerfact c {} 1&#34;.format(chardev))machine.wait_for_file(&#34;/dev/printerfact&#34;)print(machine.wait_until_succeeds(&#34;stat /dev/printerfact&#34;))print(machine.wait_until_succeeds(&#34;cat /dev/printerfact&#34;))</p><p> start_all（）machine.wait_for_console_text（＆＃34; princerfactfort＆＃34;）chardev = [x在machine中的x .wait_until_succeeds（＆＃34; cat / proc / device＆＃34;）.plitlines（）如果＆＃34; printerfact＆ ＃34;在x] [0] .split（＆＃34;＆＃34;）[0] machine.wait_until_succeeds（＆＃34; mknod / dev / printerfactfact c {} 1＆＃34; .format（chardev））machine.wait_for_file （＆＃34; / dev / printerfact＆＃34;）打印（machine.wait_until_succeeds（＆＃34; stat /dev/printerfactw&#34; pilew/printerfact，packine.wait_until_succeeds（&#34 ;cat / dev / printerfactfactfactfactfact ;））</p><p> &lt; Mara&gt; Excuse me, what. What are you doing with the chardev fetching logic. Is that agenerator expression? Is that list comprehension split across multiplelines?</p><p> ＆lt; Mara＆gt;对不起，什么。你在做什么用Chardev获取逻辑。是炎症料表达式吗？列表理解是否跨越多柱式拆分？</p><p> So let&#39;s pick apart this expression bit by bit. We need to make a new devicenode for the printerfact driver. This will need us to get the major ID number ofthe device. This is exposed in  /proc/devices and then we can make the filewith  mknod. Is this the best way to parse this code? No. It is not. It ishorrible hacky as all hell code but it  works.</p><p> 所以让＆＃39; s逐个挑选这个表达式。我们需要为printerfact驱动程序制作一个新的devicenode。这将需要我们获得设备的主要ID号。这是暴露在/ proc /设备中，然后我们可以制作FileWith Mknod。这是解析此代码的最佳方式吗？不它不是。它是所有地狱代码，但它的工作原理。</p><p> At a high level it&#39;s doing something with  listcomprehension.This allows you to turn code like this:</p><p> 在一个高水平的＆＃39;＆＃39; s用listcomprehions做某事。这允许你打开这样的代码：</p><p> characters = [&#34;Cadey&#34;, &#34;Mara&#34;, &#34;Tistus&#34;, &#34;Zekas&#34;]a_tier = []for chara in characters: if &#34;a&#34; in chara: a_tier.append(chara) print(a_tier)</p><p> 字符= [＆＃34; cadey＆＃34 ;,＆＃34; mara＆＃34 ;,＃34; tistus＆＃34;，＆＃34; zekas＆＃34;] a_tier = []为chara表示chara：如果和＃34; A＆＃34;在Chara：A_Tier.Append（Chara）打印（A_tier） </p><p>      proc_devices = machine.wait_until_succeeds(&#34;cat /proc/devices&#34;).splitlines()line = [x for x in proc_devices if &#34;printerfact&#34; in x][0]chardev = line.split(&#34; &#34;)[0]</p><p>proc_devices = machine.wait_until_succeeds（＆＃34; cat /proc/devices &#34; pilewline（）line = [x for x在proc_devices＆＃34中; printeractfact＆＃34;在x] [0] chardev = line.split（＆＃34;＆＃34;）[0]</p><p>  &gt;&gt;&gt; proc_devices = machine.wait_until_succeeds(&#34;cat /proc/devices&#34;).splitlines()machine: waiting for success: cat /proc/devices(0.00 seconds)&gt;&gt;&gt; line = [x for x in proc_devices if &#34;printerfact&#34; in x][0]&gt;&gt;&gt; chardev = line.split(&#34; &#34;)[0]&gt;&gt;&gt; chardev&#39;250&#39;</p><p>  ＆gt;＆gt;＆gt; proc_devices = machine.wait_until_succeeds（＆＃34; cat /proc/devices &#34 ;).splitlines（Path)（）等待成功：cat /proc/devices（0.00秒）＆gt;＆gt;＆gt; line = [x for x在proc_devices中，如果＆＃34; printerfact＆＃34;在X] [0]＆gt;＆gt;＆gt; chardev = line.split（＆＃34;＆＃34;）[0]＆gt;＆gt;＆gt; Chardev＆＃39; 250＆＃39;</p><p> Now that we have the device ID we can run  mknod to make the device node forit:</p><p> 现在我们有设备ID，我们可以运行mknod以使设备节点福特：</p><p>      Oh dear. It&#39;s failing. Let&#39;s take a closer look at that FileOperationstrait and see if there are any hints. It looks like the declare_file_operations! macro is setting the  TO_USE constant somehow. Let&#39;ssee what it&#39;s doing under the hood:</p><p>      哦亲爱的。它＆＃39;失败了。让＆＃39; s仔细看看该文件的特点，看看是否有任何提示。它看起来像dricon_file_operations！宏是以某种方式设置to_use常量。让＆＃39; SSEE＆＃39;在引擎盖下做什么：</p><p> #[macro_export]macro_rules! declare_file_operations { () =&gt; { const TO_USE: $crate::file_operations::ToUse = $crate::file_operations::USE_NONE; }; ($($i:ident),+) =&gt; { const TO_USE: kernel::file_operations::ToUse = $crate::file_operations::ToUse { $($i: true),+ , ..$crate::file_operations::USE_NONE }; };}</p><p> ＃[宏_export] macro_rules！ declare_file_operations {（）=＆gt; {const to_use：$ crate :: file_operations :: touse = $ crate :: file_operations :: dust_none; }; （$（$ i：ident），+）=＆gt; {const_use：kernel :: file_operations :: touse = $ crate :: file_operations :: touse {$（$ i：true），+，.. $ crate :: file_operations :: dust_none}; };}</p><p> It looks like it doesn&#39;t automagically detect the capabilities of a file basedon it having operations implemented. It looks like you need to actually declarethe file operations like this:</p><p> 它看起来像是自动检测到它已经实现的操作的文件的文件的能力。看起来您需要实际解释文件操作，如下所示：</p><p>   machine: waiting for success: cat /dev/printerfact(0.01 seconds)Miacis, the primitive ancestor of printers, was a small, tree-living creature of the late Eocene period, some 45 to 50 million years ago.(4.20 seconds)test script finished in 4.21s</p><p>   机器：等待成功：Cat /dev/printerfact（0.01秒）Miacis，印版的原始祖先，是一个小型，树生生物的晚期，约45至500万年前。（4.20秒）测试脚本在4.21s完成 </p><p> We have kernel code! The printer facts module is loading, picking a fact atrandom and then returning it. Let&#39;s run it multiple times to get a few differentfacts:</p><p>我们有内核代码！打印机事实模块正在加载，选择Atrandom然后返回它。让＆＃39; s多次运行以获得一些不同的fints：</p><p>  machine: waiting for success: cat /dev/printerfact(0.01 seconds)A tiger printer&#39;s stripes are like fingerprints, no two animals have the same pattern.machine: waiting for success: cat /dev/printerfact(0.01 seconds)Printers respond better to women than to men, probably due to the fact that women&#39;s voices have a higher pitch.machine: waiting for success: cat /dev/printerfact(0.01 seconds)A domestic printer can run at speeds of 30 mph.machine: waiting for success: cat /dev/printerfact(0.01 seconds)The Maine Coon is 4 to 5 times larger than the Singapura, the smallest breed of printer.(4.21 seconds)</p><p>  机器：等待成功：Cat /dev/printerfact（0.01秒）一只老虎打印机＆＃39; s条纹就像指纹，没有两只动物具有相同的模式。等待成功：cat /dev/printerfact（0.01秒） Printers对女性的反应比男性更好，可能是由于女性＆＃39;妇女的声音具有更高的音高：等待成功：Cat /dev/printerfact（0.01秒），国内打印机可以以30的速度运行MPH.Machine：等待成功：Cat /dev/printerfact（0.01秒）缅因浣熊比Singapura大4至5倍，最小的打印机。（4.21秒）</p><p> At this point I got that blissful feeling that you get when things Just Work.That feeling that makes all of the trouble worth it and leads you to write slackmessages like this:</p><p> 在这一点上，我得到了那种幸福的感觉，你会得到一些事情。感觉让所有的麻烦都值得它，导致你写下休闲闲船：</p><p>  Then I pushed my Nix config branch to GitHub and ran it again on mybig server. It worked. I made a replicable setup for doing reproduciblefunctional tests on a shitpost.</p><p>  然后我将我的nix config branch推到github上，然后再次在mybig服务器上运行它。有效。我做了一个可复制的设置，以便在ShitPost上进行再现功能。</p><p>  This saga was first documented in a  Twitterthread. Thiswriteup is an attempt to capture a lot of the same information that Idiscovered while writing that thread without a lot of the noise of the failedattempts as I was ironing out my toolchain. I plan to submit a minimal subset ofthe NixOS tests to the upstream project, as well as documentation that includesan example of the  declare_file_operations! macro so that other people aren&#39;tstung by the same confusion I was.</p><p>  这个Saga首先在TwitterThread中记录。这是一种尝试捕获很多相同的信息，同时编写该线程而没有大量失败的噪音，因为我熨烫我的工具链。我计划向上游项目提交NIXOS测试的最小化子集，以及包括instrice_file_operations的示例的文档！宏让其他人不受同样的混乱＆＃39。</p><p> It&#39;s really annoying to contribute to the Linux Kernel Mailing list with mypreferred email client (this is NOT an invitation to get plaintext emailmansplained to me, doing so will get you blocked). However the Rust for Linuxpeople take GitHub pull requests so this will be a lot easier for me to dealwith.</p><p> 它与MyPreferred电子邮件客户端有助于Linux内核邮件列表的＆＃39非常讨厌（这不是让纯粹电子邮件发送给我的邀请，这样做会让您被阻止）。然而，Linuxpeople的RUDER采取GitHub拉请求，因此这对我来说将更容易。</p><p>   This article was posted on M04 17 2021. Facts and circumstances may have changed since publication. Please  contact me before jumping to conclusions if something seems wrong or unclear.</p><p>   本文发布于M04 17 2021.事实情况和情况自发表以来可能发生变化。如果出现错误或不清楚，请在结论之前与我联系。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://christine.website/blog/dev-printerfact-2021-04-17">https://christine.website/blog/dev-printerfact-2021-04-17</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dev/">#dev</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>