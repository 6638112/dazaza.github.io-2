<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>混合的谜团（2009） The Mystery of the Blend (2009)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Mystery of the Blend (2009)<br/>混合的谜团（2009） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-24 22:20:44</div><div class="page_narrow text-break page_content"><p>Jeroen (Amsterdam, the Netherlands, 33 years old) worked as coder in the demo scene. He is interested in open source and 3d animations. At the moment he is working on products supporting impact analysis and change management around a fully automated render pipeline.</p><p>Jeroen（阿姆斯特丹，荷兰，33岁）在演示场景中担任编码器。他对开源和3D动画感兴趣。目前，他正在研究支持影响分析和变更管理的产品围绕完全自动化的渲染管道。</p><p>    I&#39;m working on a product what integrates Blender in a render pipeline by using the Blender command line and blend-files (.blend). The command line is not a problem as it is commonly used, but using blend-files outside Blender is difficult, because it is not that well documented. On the Internet, I&#39;ve only found some clues about it on the Blender architecture pages [ref:  http://www.blender.org/development/architecture/]. These were not sufficient. To really understand the file format I had to go through Blender&#39;s source code. In this article I will describe the blend-file-format with a request to tool-makers to support blend-file.</p><p>    i＆＃39; m工作在产品上，通过使用Blender命令行和Blend-Files（.blend）集成了Blayende在渲染管道中的内容。命令行不是一个问题，因为它通常使用，但在搅拌机外的混合文件很难，因为它没有良好的记录。在互联网上，我只在搅拌机架构页面上发现了一些关于它的线索[ref：http：//www.blerder.org/development/architecture/]。这些是不够的。真正了解我必须经过搅拌机的文件格式＆＃39; s源代码。在本文中，我将描述融合文件格式，并请求刀具制作者来支持Blend文件。</p><p> First I&#39;ll describe how Blender works with blend-files. You&#39;ll notice why the blend-file-format is not that well documented, as from Blender&#39;s perspective this is not needed.We look at the global file-structure of a blend-file (the file-header and file-blocks).After this is explained, we go deeper to the core of the blend-file, the DNA-structures. They hold the blue-prints of the blend-file and the key asset of understanding blend-files.When that&#39;s done we can use these DNA-structures to read information from elsewhere in the blend-file.</p><p> 第一个i＆＃39; ll描述了搅拌器如何使用融合文件。您＆＃39; ll注意为什么Blend-File-Format没有记录，从Blender＆＃39;透视图不需要。我们查看Blend文件的全局文件结构（文件标题和文件块）。在此解释中，我们深入了解混合文件的核心，DNA结构。它们持有Blend-File的蓝图和了解Blend-Files的关键资产。当它完成时，我们可以使用这些DNA-Structures从Blend文件中的其他地方读取信息。</p><p> In this article we&#39;ll be using the default blend-file from Blender 2.48, with the goal to read the output resolution from the Scene. The article is written to be programming language independent and I&#39;ve setup a web-site for support.</p><p> 在本文中，我们＆＃39; ll使用Blender 2.48的默认混合文件，目标是从场景中读取输出分辨率。这篇文章是编写的编程语言，独立和我和＃39; VE设置了一个网站支持。</p><p>  Loading and saving in Blender is very fast and Blender is known to have excellent downward and upward compatibility. Ton Roosendaal demonstrated that in December 2008 by loading a 1.0 blend-file using Blender 2.48a [ref:  http://www.blendernation.com/2008/12/01/blender-dna-rna-and-backward-compatibility/].</p><p>  在搅拌机中加载和保存是非常快的，并且已知搅拌机具有出色的向下和向上兼容性。 Ton Roosendaal展示了2008年12月，使用Blender 2.48a加载1.0融合文件[ref：http：//www.blendernation.com/2008/12/01/blender-dna-rna-and -backward-compatibility/ 。</p><p> Saving complex scenes in Blender is done within seconds. Blender achieves this by saving data in memory to disk without any transformations or translations. Blender only adds file-block-headers to this data. A file-block-header contains clues on how to interpret the data. After the data, all internally Blender structures are stored. These structures will act as blue-prints when Blender loads the file. Blend-files can be different when stored on different hardware platforms or Blender releases. There is no effort taken to make blend-files binary the same. Blender creates the blend-files in this manner since release 1.0. Backward and upwards compatibility is not implemented when saving the file, this is done during loading.</p><p> 在几秒钟内完成搅拌机中的复杂场景。 Blender通过将内存中的数据保存到磁盘而没有任何转换或翻译。 Blender仅为此数据添加文件块标题。文件块标题包含有关如何解释数据的线索。数据后，存储所有内部搅拌机结构。当Blender加载文件时，这些结构将充当蓝色打印。在存储在不同的硬件平台或搅拌机版本上时，Blend文件可能不同。没有努力使融合文件二进制相同。 Blender自版本1.0以来以这种方式创建Blend文件。保存文件时未实现向后和向上兼容性，这在加载期间完成。</p><p> When Blender loads a blend-file, the DNA-structures are read first. Blender creates a catalog of these DNA-structures. Blender uses this catalog together with the data in the file, the internal Blender structures of the Blender release you&#39;re using and a lot of transformation and translation logic to implement the backward and upward compatibility. In the source code of blender there is actually logic which can transform and translate every structure used by a Blender release to the one of the release you&#39;re using [ref:  http://download.blender.org/source/blender-2.48a.tar.gz /blender-2.48a/source/blender/blenloader/intern/readfile.c lines 4946-7960]. The more difference between releases the more logic is executed.</p><p> 当Blender加载混合文件时，首先读取DNA结构。 Blender创建了这些DNA结构的目录。 Blender将此目录与文件中的数据一起使用，搅拌机的内部搅拌机结构释放您＆＃39;重新使用和大量的转换和翻译逻辑来实现向后和向上兼容性。在Blender的源代码中，实际上可以逻辑转换并转换搅拌机释放到释放的每个结构，并使用[ref：http：//download.blender.org/source/blender -2.48a.tar.gz /blender-2.48a/source/blender/blenloader/intern/readfile.c行4946-7960]。释放之间的差异越多，逻辑就越多。 </p><p> The blend-file-format is not well documented, as it does not differ from internally used structures and the file can really explain itself.</p><p>Blend-File-Format未妥善记录，因为它与内部使用的结构没有不同，并且该文件可以真正解释自己。</p><p>  Let us look at the global file-structure. A blend-file always start with the file-header followed by file-blocks. The default blend file of Blender 2.48 contains more than 400 of these file-blocks. Each file-block has a file-block-header and data. This section explains how the global file-structure can be read.</p><p>  让我们看看全局文件结构。 Blend-File始终以文件标题始终以文件块开头。 Blender 2.48的默认混合文件包含超过400个这些文件块。每个文件块都有一个文件块标题和数据。本节介绍如何读取全局文件结构。</p><p>  The first 12 bytes of every blend-file is the file-header. The file-header has information on Blender (version-number) and the PC the blend-file was saved on (pointer-size and endianness). This is required as all data inside the blend-file is ordered in that way, because no translation or transformation is done during saving. The next table describes the information in the file-header.</p><p>  每个混合文件的前12个字节是文件头。文件标题有关于Blender（版本号）的信息，并且Blend文件的PC保存（指针 - 大小和endianness）。这是必需的，因为融合文件中的所有数据都按此顺序排序，因为在保存期间没有进行翻译或转换。下表描述了文件标题中的信息。</p><p> Size of a pointer; all pointers in the file are stored in this format. &#39;_&#39; means 4 bytes or 32 bit and &#39;-&#39; means 8 bytes or 64 bits.</p><p> 指针的大小;文件中的所有指针都以此格式存储。 ＆＃39; _＆＃39;意味着4个字节或32位和＆＃39;  - ＆＃39;意味着8个字节或64位。</p><p> Endianness addresses the way values are ordered in a sequence of bytes [ref:  http://en.wikipedia.org/wiki/Endianness]. Blender supports little-endian and big-endian. In a big endian ordering, the largest part of the value is placed on the first byte and the lowest part of the value is placed on the last byte. In a little endian ordering, largest part of the value is placed on the last byte and the smallest part of the value is placed on the first byte. Example: writing the integer  0x4A3B2C1Dh, will be ordered in Big endian as  0x4Ah,  0x3Bh,  0x2Ch,  0x1Dh and be ordered in little endian as  0x1Dh,  0x2Ch,  0x3Bh,  0x4Ah.</p><p> Endianness地址以字节序列排序的方式处理值[ref：http：//en.wikipedia.org/wiki/endianness]。搅拌机支持小endian和Big-Endian。在一个大的endian排序中，值的最大部分被放置在第一个字节上，并且该值的最低部分放置在最后一个字节上。在一点endian排序中，值的最大部分放置在最后一个字节上，并且该值的最小部分放置在第一个字节上。示例：编写整数0x4a3b2c1dh，将在大endian排序为0x4ah，0x3bh，0x2ch，0x1dh，并在小endian中排序为0x1dh，0x2ch，0x3bh，0x4ah。</p><p> The endianness can be different between the blend-file and the PC your using. When these are different, Blender changes it to the byte ordering of your PC. Nowadays, little-endian is the most commonly used.</p><p> Endianness可以在Blend-File和PC之间存在不同。当这些不同时，搅拌机将其更改为PC的字节排序。如今，小endian是最常用的。</p><p> The next hex-dump describes a file-header created with blender 2.48 on little-endian hardware with a 32 bits pointer length.   pointer-size version-number0000 0000: [42 4C 45 4E 44 45 52] [5F] [76] [32 34 38] BLEN DER_ v248  identifier endianness</p><p> 下一个十六进制转储描述了在具有32位指针长度的小型硬件上使用Blender 2.48创建的文件标头。指针尺寸版本-150000 0000 0000：[42 4C 45 4e 44 45 52] [5f] [5f] [76] [32 34 38] blen der_v248标识符endianness </p><p>  File-blocks contain a file-block-header and data. The start of a file-block is always aligned at 4 bytes. The file-block-header describes the total length of the data, the type of information stored in the file-block, the number of items of this information and the old memory pointer at the moment the data was written to disk. Depending on the pointer-size stored in the file-header, a file-block-header can be 20 or 24 bytes long. The next table describes how a file-block-header is structured.</p><p>文件块包含文件块 - 标题和数据。文件块的开始始终以4个字节对齐。文件块标题描述了数据的总长度，存储在文件块中的信息类型，此信息的项目数量和数据的旧存储器指针写入磁盘。根据存储在文件头中的指针大小，文件块标题可以长20或24个字节。下一个表描述了如何构建文件块标题。</p><p>  Code describes different types of file-blocks. The code determines with what logic the data must be read. These codes also allows fast finding of data like Library, Scenes, Object or Materials as they all have a specific code.</p><p>  代码描述了不同类型的文件块。代码根据必须读取数据的逻辑确定。这些代码还允许快速查找库，场景，对象或材料等数据，因为它们都具有特定代码。</p><p> The size contains the total length of data after the file-block-header. After the data a new file-block starts. The last file-block in the file has code &#39;ENDB&#39;.</p><p> 大小包含文件块标题后的数据总长度。数据后，新文件块开始。文件中的最后一个文件块有代码＆＃39; endb＆＃39;</p><p> The old memory address contains the memory address when the structure was last stored. When loading the file the structures can be placed on different memory addresses. Blender updates pointers to these structures to the new memory addresses.</p><p> 旧内存地址包含上次存储时的内存地址。加载文件时，可以将结构放在不同的内存地址上。 Blender将指向这些结构的指针更新到新的内存地址。</p><p> SDNA index contains the index in the DNA structures to be used when reading this file-block-data. More information about this subject will be explained in the Reading scene information section.</p><p> SDNA索引包含在读取此文件块数据时要使用的DNA结构中的索引。关于此主题的更多信息将在读取场景信息部分中解释。</p><p> Count tells how many elements of the specific SDNA structure can be found in the data.</p><p> 计数告诉数据中可以找到特定SDNA结构的多少元素。</p><p> The next section is an example of a file-block-header. The code  &#39;SC&#39;+0x00h identifies that it is a Scene. Size of the data is 1376 bytes (0x05h X 256 + 0x60h = 1280 + 96); the old pointer is 0x0A042FA0h and the SDNA index is 139 (8 X 16 + 11). The section contains a single scene. Before we can interpreted the data of this file-block we first have to read the DNA structures in the file. The section structure DNA will show how to do that.  0000 4420: [53 43 00 00] [60 05 00 00] [A0 2F 04 0A] [8B 00 00 00] SC.. `... ./.. .... 0000 4430: [01 00 00 00] [xx xx xx xx xx xx xx xx xx xx xx xx .... xxxx xxxx xxxx</p><p> 下一节是文件块标题的示例。代码＆＃39; sc＆＃39; + 0x00h标识它是一个场景。数据的大小是1376字节（0x05H x 256 + 0x60h = 1280 + 96）;旧指针是0x0a042fa0h，SDNA索引为139（8 x 16 + 11）。该部分包含一个场景。在我们解释此文件块的数据之前，我们首先必须读取文件中的DNA结构。截面结构截号将显示如何做到这一点。 [53 43 00] [83 4 00 00] [8b 00 00] [8b 00 00 00] sc ..'.. .... .... 0000 4430：[01 00 00 00 ] [xx xx xx xx xx xx xx xx xx xx xx xx .... xxxx xxxx xxxx </p><p>  Structure DNA is stored in a file-block with code &#39;DNA1&#39;. It can be just before the &#39;ENDB&#39; file-block. It contains all internal structures of the Blender release the file was created in. The data in this file-block must be interpreted as described in the this section.In a blend-file created with Blender 2.48a this section is 43468 bytes long and contains 309 structures. These structure can be described as C-structures. They can hold fields, arrays and pointers to other structures, just like a normal C-structure.  structure Scene {	ID id; // 52 bytes long (ID is different a structure)	Object *camera; // 4 bytes long (pointer to an Object structure)	World *world; // 4 bytes long (pointer to a World structure)	...	float cursor[3]; // 12 bytes long (array of 3 floats)	...}</p><p>结构DNA与代码＆＃39; DNA1＆＃39; DNA1＆＃39;它可以只是在＆＃39之前; endb＆＃39;文件块。它包含文件中创建的Blender释放的所有内部结构。此文件块中的数据必须如本节中所述解释。在使用Blender 2.48a创建的Blend文件中，本节是43468字节长，包含43468字节309结构。这些结构可以描述为C结构。它们可以将字段，阵列和指针保持到其他结构，就像普通的C结构一样。结构场景{ID ID; // 52字节长（ID是不同的结构）对象*相机; // 4个字节长（指向对象结构）世界*世界; // 4个字节长（指向世界结构的指针）...浮动光标[3]; // 12字节长（3个浮点数）...}</p><p> The next section describes how this information is ordered in the data of the &#39;DNA1&#39; file-block.</p><p> 下一节介绍如何在＆＃39的数据中订购该信息; DNA1＆＃39;文件块。</p><p>  As you can see, the structures are stored in 4 arrays: names, types, lengths and structures. Every structure also contains an array of fields. A field is the combination of a type and a name. From this information a catalog of all structures can be constructed. The names are stored as how a C-developer defines them. This means that the name also defines pointers and arrays.(When a name starts with &#39;*&#39; it is used as a pointer. when the name contains for example &#39;[3]&#39; it is used as a array of 3 long.)In the types you&#39;ll find simple-types (like: &#39;integer&#39;, &#39;char&#39;, &#39;float&#39;), but also complex-types like &#39;Scene&#39; and &#39;MetaBall&#39;. &#39;TLEN&#39; part describes the length of the types. A &#39;char&#39; is 1 byte, an &#39;integer&#39; is 4 bytes and a &#39;Scene&#39; is 1376 bytes long.</p><p>  如您所见，结构存储在4个阵列中：名称，类型，长度和结构。每个结构也包含一系列字段。字段是类型和名称的组合。根据此信息，可以构建所有结构的目录。名称存储为C-Developer如何定义它们。这意味着该名称还定义了指针和数组。（当名称以＆＃39开头时; *＆＃39;它用作指针。当名称包含例如＃39; [3]＆＃39;它用作3个长的数组。）在您的类型中＆＃39; ll找到简单类型（如：＆＃39;整数＆＃39;，＆＃39; char＆＃39;＆＃39; float＆＃39;＆＃39; float＆＃39; 39;），但也像＆＃39一样复杂类型;场景＆＃39;和＃39; Metaball＆＃39; ＆＃39; tlen＆＃39;部分描述了类型的长度。 A＆＃39; char＆＃39;是1字节，一个＆＃39;整数＆＃39;是4个字节和A＆＃39;场景＆＃39;是1376字节长。</p><p> Note: While reading the DNA you&#39;ll will come across some strange names like &#39;(*doit)()&#39;. These are method pointers and Blender updates them to the correct methods.</p><p> 注意：读取DNA＆＃39; LL将遇到一些奇怪的名字，如＆＃39;（* doit）（）＆＃39;这些是方法指针和搅拌机将它们更新为正确的方法。</p><p>  Note: The fields &#39;type identifier&#39;, &#39;length identifier&#39; and &#39;structure identifier&#39; are aligned at 4 bytes.</p><p>  注意：字段＆＃39;类型标识符＆＃39 ;,＆＃39;长度标识符＆＃39;和＃39;结构标识符＆＃39;以4个字节对齐。</p><p> The DNA structures inside a Blender 2.48 blend-file can be found at  http://www.atmind.nl/blender/blender-sdna.html. If we understand the DNA part of the file it is now possible to read information from other parts file-blocks. The next section will tell us how.</p><p> Blender 2.48混合文件中的DNA结构可以在http://www.atmind.nl/blender/blender-sdna.html中找到。如果我们理解文件的DNA部分，现在可以从其他部件文件块中读取信息。下一节将告诉我们如何。</p><p>  Let us look at the file-block we have seen earlier. The code is  &#39;SC&#39;+0x00h and the SDNA index is 139. The 139th structure in the DNA is a structure of type &#39;Scene&#39;. The associated type (&#39;Scene&#39;) has the length of 1376 bytes. This is exact the same length as the data in the file-block. We can map the Scene-structure on the data of the file-blocks. But before we can do that, we have to flatten the Scene-structure.</p><p>  让我们看看我们之前见过的文件块。代码是＆＃39; sc＆＃39; + 0x00h和sdna索引是139. DNA中的139结构是类型＆＃39的结构;场景＆＃39;相关类型（＆＃39;场景＆＃39;）的长度为1376字节。这与文件块中的数据完全相同。我们可以在文件块的数据上映射场景结构。但在我们能做到之前，我们必须平息场景结构。 </p><p> The first field in the Scene-structure is of type &#39;ID&#39; with the name &#39;id&#39;. Inside the list of DNA structures there is a structure defined for type &#39;ID&#39; (structure index 17). The first field in this structure has type &#39;void&#39; and name &#39;*next&#39;. Looking in the structure list there is no structure defined for type &#39;void&#39;. It is a simple type and therefore the data should be read.	&#39;*next&#39; describes a pointer. the first 4 bytes of the data can be mapped to &#39;id.next&#39;.	 Using this method we&#39;ll map a structure to its data. If we want to read a specific field we know at what offset in the data it is located and how much space it takes.</p><p>场景结构中的第一个字段是类型＆＃39; ID＆＃39;名称＆＃39; id＆＃39;在DNA结构列表中，存在为类型＆＃39定义的结构; ID＆＃39; （结构指数17）。该结构中的第一个领域具有类型＆＃39;空隙＆＃39;和名字＆＃39; *下一个＆＃39;寻找结构列表，没有为类型＆＃39定义的结构;空隙＆＃39;这是一种简单类型，因此应该读取数据。 ＆＃39; *下一个＆＃39;描述一个指针。数据的前4个字节可以映射到＆＃39; id.next＆＃39;使用此方法我们＆＃39; LL将结构映射到其数据。如果我们想读取特定领域，我们知道它所在的数据中的偏移量以及需要多少空间。</p><p> The next table shows the output of this flattening process for some parts of the Scene-structure. Not all rows are described in the table as there is a lot of information in a Scene-structure.</p><p> 下表显示了场景结构某些部件的这种平坦过程的输出。并非所有行都在表格中描述，因为场景结构中存在很多信息。</p><p>  We can now read the X and Y resolution of the Scene. The X-resolution is located on offset 326 of the file-block-data and must be read as a short. The Y-resolution is located on offset 328 and is also a short.</p><p>  我们现在可以读取x和y分辨率的场景。 X分辨率位于文件块数据的偏移量326上，并且必须读取短。 Y分辨率位于偏移328上，也是短暂的。</p><p> Note: An array of chars can mean 2 things. The field contains readable text or it contains an array of flags (not humanly readable).</p><p> 注意：一系列字符可以指2件事。该字段包含可读文本，也包含一个标志数组（不是人性可读）。</p><p> Note: A file-block containing a list refers to the DNA structure and has a count larger than 1. For example Vertexes and Faces are stored in this way.</p><p> 注意：包含列表的文件块是指DNA结构，并且具有大于1的计数。例如，以这种方式存储顶点和面。</p><p>  The implementation of saving in Blender is easy, but loading is difficult. When implementing loading and saving blend-files in a custom tool the difficulty is the opposite. In a custom tool loading a blend-file is easy, and saving a blend-file is difficult. If you want to save blend-files I suggest to start with understanding the the global file structure and parsing the DNA section of the file.After this is done it should be easy to read information from existing blend files like scene data, materials and meshes. When you feel familiar with this you can start creating blend-libraries using the internal Blender structures of a specific release. If you don&#39;t want to dive into the Blender source code you can find them all at  http://www.atmind.nl/blender/blender-sdna.html.</p><p>  在搅拌机中的实施很容易，但加载很难。在自定义工具中实现加载和保存融合文件时，难度是相反的。在一个自定义工具中加载混合文件很容易，并且难以保存混合文件。如果要保存Blend-Files，我建议首先了解全局文件结构并解析文件的DNA部分。在此完成，应该很容易地从现有的混合文件等信息，如场景数据，材料和网格等现有混合文件。当您熟悉此时，您可以使用特定版本的内部搅拌机结构开始创建Blend-Libraries。如果你不想潜入搅拌机源代码，你可以在http://www.atmind.nl/blender/blender-sdna.html上找到它们。</p><p> There is a feature request on supporting an XML based import/export system in Blender. I dont support the request, but it is interesting to look at how this can be implemented. An XML export can be implemented with low effort as an XSD can be used as DNA structures and the data can be written into XML [see  http://www.atmind.nl/blender/blender-file.zip to download JAVA example including source code]. Implementing an XML import system uses a lot of memory and CPU. If you really want to implement it, I expect that the easiest way is to convert the XML-file back to a normal blend-file and then load it using the current implementation.One real drawback is that parsing a XML based blend-file uses a lot of memory and CPU and the files can become very large.</p><p> 有一个功能请求有关在Blender中支持基于XML的导入/导出系统。我不支持请求，但是要看可以实现如何实现这一点。 XML导出可以用力以低成本实现，因为XSD可以用作DNA结构，并且数据可以写入XML [查看http://www.atmind.nl/blender/blender-file.zip下载Java示例包括源代码]。实现XML导入系统使用很多内存和CPU。如果您真的想实现它，我希望最简单的方法是将XML文件转换回正常混合文件，然后使用当前实现加载它。一个实际缺点是解析基于XML的混合文件使用很多内存和CPU和文件都会变得非常大。 </p><p> At this moment I&#39;m using this information in an automated render pipeline. The render pipeline is build around a web-server and SVN. When an artist commits a new blend-file in SVN, it is picked up by the web-server and it will extract resolutions, frames scenes and libraries from the blend-file. This information is matched with the other files in SVN and the blend-file will be placed in the render pipeline.</p><p>此时，在自动渲染管道中使用此信息，我＆＃39; m使用此信息。 渲染管道围绕Web服务器和SVN构建。 当艺术家在SVN中提交一个新的Blend-File时，它被Web服务器拾取，它将提取分辨率，框架文件框架文件框架文件。 此信息与SVN中的其他文件匹配，并将Blend文件放在渲染管道中。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://web.archive.org/web/20160304093204/http://www.atmind.nl/blender/mystery_ot_blend.html">http://web.archive.org/web/20160304093204/http://www.atmind.nl/blender/mystery_ot_blend.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/混合/">#混合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mystery/">#mystery</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>