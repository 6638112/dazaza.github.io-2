<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>邪恶单元测试</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">邪恶单元测试</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-24 21:21:54</div><div class="page_narrow text-break page_content"><p>这个页面是由Paul Wheaton作为承包商从javaranch.com.jsp Evil Unit Testing迁移而来的，我现在已经出现在不少于六家不同的公司，他们自豪地微笑着单元测试，再加上这种巨大的自豪感，令人担忧的是，这一单元测试最终将成为一项麻烦了。其他人谈论单元测试有多棒，但这真的变得很痛苦。*测试需要45分钟运行几分钟，代码每做一点改动，我们就会破坏大约七个测试！&#34；</p><p>这些人拥有的是一大堆功能测试。他们落入了流行的陷阱，认为是因为它们使用JUnit运行测试，它们必须是单元测试。他们90%的问题本可以通过一个一点点词汇。</p><p>软件测试词汇单元测试：最少的可测试代码。通常是单个方法/函数，它不再使用其他方法或类。快！上千个单元测试可以在十秒甚至更短的时间内运行！*单元测试从不使用：简单的单元测试几乎总是回归套件的一部分。</p><p>回归套件：可以一次运行所有测试的集合。举个例子来说，可能放在某个目录中的所有测试都将由JUnit运行。*开发人员可以运行单元测试每天使用回归套件20次。或者，他们可能每月运行两次功能测试回归套件。</p><p>功能测试：大于一个单元，小于完整组件测试。通常一起执行几个方法/函数/类。它被允许享受它的甜蜜时光：数百项测试可能需要数小时才能运行。大多数功能测试都是功能测试回归套件的一部分。它通常从JUnit运行。</p><p>集成测试：测试一起工作的两个或多个组件。有时是回归套件的一部分。</p><p>组件测试：单独运行一个组件。QA、经理、这类测试不是回归套件的一部分，也不是由JUnit运行的。</p><p>组件验收测试(C.A.T.)：在一大群人面前进行的组件测试这是正式程序的一部分。房间里的人共同决定组件是否符合要求的标准。</p><p>系统验收测试(S.A.T.)：在一大群人面前运行的系统测试这是正式程序的一部分。房间里的人集体决定系统是否满足要求的标准。</p><p>压力测试：另一个程序加载一个组件、一些组件，或者可能加载整个组件这是一个新的系统。我看到一些小的压力测试在一些回归功能测试中起作用-这是一种相当聪明的测试方式下载一些并发代码！</p><p>模拟：在单元和功能测试中使用的脑死亡代码片段，以确保但是，您尝试测试的一段代码不会使用其他一些生产代码。*通常是模拟类将重写生产类中的所有公共方法，并将其插入可能尝试使用我们的制作班级。有时，Mock类实现接口并替换实现相同接口的产品代码它的界面。</p><p>分流：有点像扩展产品代码的模拟类，只是目的不是我可以重写所有的方法，但只要足够，您就可以练习一些生产方法，同时嘲笑其余的改变了生产方式。如果您要测试可能尝试使用I/O的类，则此功能尤其有用。您的分流器可以覆盖在测试非I/O方法的同时测试I/O方法。</p><p>现在让您有机会告诉作者，他是个笨蛋，对coderanch线程单元测试词汇表中的这些东西一无所知。</p><p>太多功能测试的麻烦不要误会我。这些功能测试具有很大的价值。*我认为经过良好测试的应用程序将拥有一套回归套件功能测试和非回归功能测试的集合。通常，对于每磅生产代码，我我希望看到大约两磅的单元测试和两盎司的功能测试(一点点就会有很长的路要走)。我在太多的商店里看到的问题就是零个单元测试和一磅功能测试。</p><p>下面两个图像演示了使用使用类的类的类。有一些功能测试可以锻炼这些班级一起工作。修复一个类中的错误会破坏许多功能测试……。</p><p>这种情况我已经看过很多次了。但在一个案例中，一个小小的变化就打破了47项测试。他们举行了几次会议，以决定是否BUG应该留在代码中！最后，决定关闭所有测试，直到可以留出时间为止来修复所有的测试。几个月过去了。事情变得非常臭气熏天…</p><p>通过只编写功能测试，我编写了更少的测试代码，而执行了更多的生产代码！&#34；是真的！但是在降低让你的项目变得脆弱的代价。此外，您的应用程序中有一些更好的地方将会很多在不使用单元测试的情况下更难进行测试。*最好的覆盖范围和灵活性只能通过混合使用单元和强调单元测试，轻功能测试的功能测试。</p><p>我的业务逻辑是所有这些类一起工作，所以只测试一个方法是没有意义的。&#34；我建议您可以单独测试所有的方法。此外，我并不是建议你没有功能测试-它们有它们的价值。</p><p>我不介意我的单元测试套件运行几分钟。但是你们团队中的其他人介意吗？你的团队是领头羊吗？你的经理呢？如果需要几分钟而不是几秒钟，你还会运行全套a套吗？一天十几次？什么时候人们会停止运行测试？</p><p>单元测试是由JUnit.&#34；运行的任何东西，在我们的行业中，单元测试这个术语确实是主观的。我认为这就是我在这里表达的是对单元测试这个术语最流行的解释。</p><p>查看Big Moose Saloon的论坛，了解关于功能测试与单元测试的帖子。这里的单元测试模拟基础是一种非常明显的单元测试形式。我在一种不依赖的方法上尝试各种古怪的东西其他方法。</p><p>Public void testLongize(){**assertEquals(&#34；-111.44&#34；，Normalize.经度(&#34；111.44w&#34；))；**assertEquals(&#34；-111.44&#34；，Normalize.经度(&#34；111.44W&#34；))；在AssertEquals(&#34；-111.44&34；，正规化经度(&#34；111.44 w&34；))；**AssertEquals(&#34；-111.44&#34；，Normalize.经度(&#34；111.44 W&34；))；**assertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；111.44；w&#34；))；**AssertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；-111.44w&#34；))；**assertEquals(&#34；-111.44&34；，Normalize.Length(&#34；-111.44W&#34；))；**AssertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；-111.44 w&#34；))；*assertEquals(&#34；-111.44&34；，标准经度(&#34；-111.44 W&#34；)；**AssertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；-111.44&#34；))；**AssertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；111.44-&#34；))；**AssertEquals(&#34；-111.44&#34；，Normalize.Length(&#34；111.44-&#34；))；**assertEquals(&#34；-111.44&#34；，Normalize.经度(&#34；111.44West&#34；))；*//……}。</p><p>当然，任何笨蛋都可以对这类东西进行单元测试。但大多数业务逻辑使用其他业务逻辑：</p><p>公共类FarmServlet扩展ActionServlet{**公共void doAction(ServletData ServletData)抛出异常{*字符串种=servletData.getParameter(&#34；种&#34；)；*字符串buildingID=servletData.getParameter(&#34；buildingID&#34；)；如果(Str.usable(物种)&amp；&amp；Str.usable(BuildingID)){*FarmEJBRemote Remote Remote=FarmEJBUtil.getHome().create()；*REMOTE.addAnimal(种，buildingID)；}}}</p><p>这不仅调用了其他业务逻辑，还调用了应用程序服务器！可能是通过网络！数以千计的这些将需要十多秒的时间。另外，EJB内容中的更改可能会破坏我这里的测试！因此需要引入模拟对象。</p><p>如果我能模拟出所有的EJB内容，我就会坐享其成了。嗯……。如果代码以某种方式如果不能拿到我的模拟农场，我就会在肥城。</p><p>首先，创建模拟。如果FarmEJBRemote是一个类，我会扩展它并覆盖所有方法。但自那以后如果它恰好是一个接口，我将只做一个新的类并实现所有的方法：</p><p>公共类MockRemote实现FarmEJBRemote{*字符串addAnimal_Species=NULL；*字符串addAnimal_buildingID=NULL；*int addAnimal_call=0；*public void addAnimal(String种，String buildingID){*addAnimal_Species=物种；*addAnimal_buildingID=buildingID；*addAnimal_Calls++；}}。</p><p>这个嘲弄是哑巴的。我真的很笨。它只是在我的单元测试和我试图运行的代码之间传输数据。</p><p>这门课是不是让你..。不舒服？应该是这样。关于这类课程，有两件事是令人烦恼的我第一次接触到它时：类属性不是私有的，并且它们在其中有下划线。我是第一个上次我看到这样的模拟物体我听说你的单元测试代码不会投入生产，所以可以偷工减料。但我不知道。我只想写头等舱。一直在写代码！甚至不到一个小时，我就需要模仿java.sql.Connection。40种方法！每种方法都有getter和setter是否有每个方法的参数、返回值和计数器？？嗯……。仔细考虑一下……我们将属性设为私有的原因是为了封装-隐藏在我在里面，这样我们以后就可以更改我们的业务逻辑，而不会破坏一堆决定进入我们的这是内脏。但这并不真的适用于模拟，不是吗？根据定义，模拟没有业务逻辑。更进一步，但是，它没有任何东西，它没有任何东西，只是从别人那里抄袭来的。任何地方的所有模拟对象都可以它可以很容易地在构建时100%生成！所以我有时仍然对此感到有点反胃，但最终我最后总是再次说服自己，这是最好的方法。所以它始终是第一类代码-它只是它闻起来有点异味。但是它闻起来比我用另一种方式做的味道要好。</p><p>现在，我需要获取代码来接收我的模拟对象，而不是启动某个应用程序服务器。“那么，这就是那段代码。”代码，我已经突出显示了我想要使用模拟的代码行。</p><p>公共类FarmServlet扩展ActionServlet{**公共void doAction(ServletData ServletData)抛出异常{*字符串种=servletData.getParameter(&#34；种&#34；)；*字符串buildingID=servletData.getParameter(&#34；buildingID&#34；)；*是否(Str.usable(物种)&amp；&amp；Str.usable(BuildingID)){*；font color=red&gt；FarmEJBRemote Remote=FarmEJBUtil.getHome().create()；&lt；/font&gt；*REMOTE.addAnimal(种，buildingID)；}}}</p><p>公共类FarmServlet扩展ActionServlet{*&lt；font color=red&gt；Private FarmEJBRemote getRemote(){*将返回FarmEJBUtil.getHome().create()；{##**$$}&lt；/font&gt；**公共void doAction(ServletData ServletData)抛出异常{*字符串种=servletData.getParameter(&#34；种&#34；)；*字符串buildingID=servletData.getParameter(&#34；buildingID&#34；)；*是否(Str.usable(物种)&amp；&amp；Str.usable(BuildingID)){*：&lt；font color=red&gt；FarmEJBRemote remote=getRemote()；&lt；/font&gt；*REMOTE.addAnimal(种，buildingID)；}}}。</p><p>这会有点疼的..。我现在将扩展我的生产类并重写getRemote()，这样我就可以强制模拟执行此操作。所以我需要做一个小小的改变…。</p><p>公共类FarmServlet扩展ActionServlet{*&lt；font color=red&gt；FarmEJBRemote getRemote()&lt；/font&gt；{*将返回FarmEJBUtil.getHome().create()；}**公共void doAction(ServletData ServletData)抛出异常{*字符串种=servletData.getParameter(&#34；种&#34；)；*字符串buildingID=servletData.getParameter(&#34；buildingID&#34；)；*是否(Str.usable(物种)&amp；&amp；Str.usable(BuildingID)){*FarmEJBRemote Remote Remote=getRemote()；*REMOTE.addAnimal(种，buildingID)；}}}。</p><p>如果你是一个好的面向对象工程师，你现在应该疯了！哦，当然，在单元中违反了封装测试代码让人非常不舒服，但是违反生产代码中的封装已经完成了！(如果您错过了它，*我去掉了关键字&#34；private&#34；，使方法&#34；package&#34；-现在，同一个包中的任何东西都可以(请看那个方法)再说一遍，冗长的解释可能会帮助事情平息一点。我要把它省下来对于java论坛，现在说：永远要警惕您的产品代码中的第一类封装。但是.。每隔一段时间..。您可以考虑用价值1美元的包装换取价值20美元的可测试性。然后，为了减轻你的痛苦/羞愧，你可以添加一条评论：</p><p>公共类FarmServlet扩展ActionServlet{*&lt；font color=red&gt；//仅用于单元测试目的！&lt；/font&gt；*FarmEJBRemote getRemote(){*将返回FarmEJBUtil.getHome().create()；}**公共void doAction(ServletData ServletData)抛出异常{*字符串种=servletData.getParameter(&#34；种&#34；)；*字符串buildingID=servletData.getParameter(&#34；buildingID&#34；)；*是否(Str.usable(物种)&amp；&amp；Str.usable(BuildingID)){*FarmEJBRemote Remote Remote=getRemote()；*REMOTE.addAnimal(种，buildingID)；}}}。</p><p>类FarmServletShut扩展了FarmServlet{**FarmEJBRemote getRemote_Return=NULL；*FarmEJBRemote getRemote(){*将返回getRemote_Return；}}。</p><p>注意这个奇怪的名字：“分流”。我不确定，但我想这个词来自电气工程/修修补补并且指的是使用导线临时完成电路。一开始对我来说听起来真的很愚蠢，但过了一段时间我已经习惯了。</p><p>分流有点像模拟，不同的是你不能覆盖所有的方法。这样一来，你就嘲笑了一些方法同时也在测试其他人。*单元测试可能会以几个分流结束，所有分流都覆盖同一个类，每个测试都不同班级的一部分。分流通常是内部类。</p><p>公共类TestFarmServlet扩展了TestCase{**静态类FarmServletShut扩展FarmServlet{*FarmEJBRemote getRemote_Return=NULL；*FarmEJBRemote getRemote(){*RETURN：getRemote_Return；}}*公共void testAddAnimal()引发异常{*MockRemote mockRemote=new MockRemote()；*FarmServletShun=new FarmServletShun()；*shunt.getRemote_return=mockRemote()；*//只是另一个要做的嘲弄*MockServletData mockServletData=new MockServletData()；*(mockServletData.getParameter_returns.put(&#34；species&#34；，&34；Dog；)；(mockServletData.getParameter_returns.put(&#34；buildingID&#34；，&34；27&34；)；*shunt.doAction(MockServletData)；*assertEquals(1，mockRemote.addAnimal_call)；*assertEquals(&#34；dog&#34；，mockRemote.addAnimal_Species)；*assertEquals(27，mockRemote.addAnimal_buildingID)；}}。</p><p>现在基本框架已经就位，我只需要添加大量断言。</p><p>TestFarmServlet vs FarmServletTest：你必须加入一个阵营或另一个阵营。如果来自后一个阵营的人这是一个非常好的观点：FarmServletTest听起来更像是一个名词，因此更多的是面向对象的。“我在前一个阵营。”我已经对IDE上瘾了，很享受它完成类名的方式对我来说。*当我有一套丰富的测试，并且我的测试类名都以&#34；Test&#34；结尾时，然后，我的IDE提出的建议是我希望的两倍。*当我的测试类名都以&#34；Test&#34；开头时，我的IDE提供的建议数量恰到好处。</p><p>在名为Creating Unit Tests(创建单元测试)的论坛帖子中讨论这个问题(带有模仿和分流！)。</p><p>要了解一个项目可能如何使所有这些东西保持整齐，请看一看。</p><p>示例目录结构项目名*/src*//生产来源*/java*/java来源。这里的第一个目录是&#34；com&#34；创建文件/db文件，创建文件文件，创建文件//数据库DDL(或.sql)文件。*/测试*/测试来源*/单位*//此目录中以以下开头的每个类*#34；Test&#34；作为单元测试运行*/Functional*//此目录中以以下字符开头的每个类*#34；Test&#34；作为功能测试运行*支持/非回归：支持//在开发过程中手动在此处运行内容*/lib*//jar文件等项目使用的类似文件*/生产*/需要复制到生产中的*//材料。*/开发**/仅在开发过程中使用的内容//*/。Build//此目录不在版本控制中。**/gen-src*//如果您的应用程序生成任何源代码，它放在这里**//编译好的生产类*/测试类：**//编译后的单元测试代码、功能测试代码、*。等。**文件通常是WAR文件、EAR文件或JAR文件。*build.xml*//ant构建文件。</p><p>人们将他们的单元测试内容放在与他们正在测试的产品代码相同的包中-但是！在一种不同的目录结构。*因此，如果您正在测试src/java/com/javaranch/Str.java中的com.javaranch.Str.java，您可以可能在test/unit/com/javaranch/TestStr.java中找到测试类com.javaranch.TestStr.java。</p><p>FIN这只是本主题的简要概述</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://coderanch.com/wiki/718795/Unit-Testing">https://coderanch.com/wiki/718795/Unit-Testing</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/单元测试/">#单元测试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/unit/">#unit</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>