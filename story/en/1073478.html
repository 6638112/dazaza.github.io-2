<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Solr迁移到Elasticsearch及其差异Migrating from Solr to Elasticsearch, and their differences</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Migrating from Solr to Elasticsearch, and their differences<br/>从Solr迁移到Elasticsearch及其差异</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 16:52:05</div><div class="page_narrow text-break page_content"><p>After realizing that it took a literal team of engineers to keep our self managed Solr infrastructure up to date and working, we are moving to a managed search solution — Elasticsearch!</p><p>在意识到需要一个由工程师组成的文字团队才能使我们的自我管理的Solr基础设施保持最新并正常工作后，我们正在转向一个托管搜索解决方案——Elasticsearch！</p><p> More specifically, we are migrating to Elasticsearch, which is hosted and managed by  Amazon Web Services (AWS). Both search engines have a lot of similarities, but do require some translation of terminology, patterns and thinking.</p><p>更具体地说，我们正在迁移到Elasticsearch，它由Amazon Web Services（AWS）托管和管理。这两个搜索引擎有很多相似之处，但确实需要一些术语、模式和思维的翻译。</p><p> Over 2021, we have migrated one of our smaller search indexes fully to Elasticsearch and are currently in the process of using Elasticsearch for some new search domains. The journey so far has taught us a lot about the key differences between Solr and Elastic, as well as the nuances that people may not be aware of unless they go through a similar migration.</p><p>超过2021，我们已经将一个较小的搜索索引完全迁移到弹性搜索，并且目前正在使用弹性搜索来搜索一些新的搜索域。迄今为止的旅程教会了我们很多Solr和Elastic之间的关键区别，以及人们可能不知道的细微差别，除非他们经历了类似的迁移。</p><p> We have put together this blog post to help others who are considering such an exercise.</p><p>我们把这篇博文放在一起是为了帮助其他正在考虑这样一个练习的人。</p><p>  We have been using Solr since 2014 at Canva when it was easily the most established option with the most active community. Now, in 2022, Elasticsearch is no longer the unexciting and somewhat unreliable new kid on the block, but has proven itself to be a reliable search engine with a strong developer community and support.</p><p>我们从2014年开始在Canva使用Solr，当时它是最活跃的社区中最成熟的选择。现在，在2022年，Elasticsearch不再是一个乏味且有点不可靠的新手，而是已经证明自己是一个可靠的搜索引擎，拥有强大的开发者社区和支持。</p><p>   It is now easier to hire engineers with Elasticsearch experience, and harder to hire people familiar with Solr.</p><p>现在，雇佣具有Elasticsearch经验的工程师变得更容易了，雇佣熟悉Solr的人也更难了。</p><p>  The following sections provide side by side comparisons of how we experienced Solr and Elasticsearch, what we like and struggle with from each, and the things we wish we knew about Elasticsearch before the migration. We hope it will benefit teams looking to do the same thing as we did.</p><p>以下各节并排比较了我们如何体验Solr和Elasticsearch，我们对它们的喜爱和挣扎，以及我们希望在迁移之前了解Elasticsearch的情况。我们希望这将有利于希望做同样事情的团队。</p><p>     A key difference in how we (as engineers) interact with the technologies is how the infrastructure is managed. Here are aspects to consider.</p><p>我们（作为工程师）与技术互动的关键区别在于基础设施的管理方式。以下是要考虑的方面。</p><p>        Must be managed separately to Solr. If you’re managing Solr, you must also manage  Zookeeper.</p><p>必须单独管理以解决问题。如果你在管理Solr，你还必须管理Zookeeper。</p><p>     Autoscaling can add nodes to maintain minimum replication, but does not support balancing across AZs (AWS availability zones).</p><p>自动缩放可以添加节点以保持最小复制，但不支持在AZs（AWS可用性区域）之间进行平衡。</p><p> The autoscaling does not balance replicas to prevent dangerous topologies. We observed several undesirable behaviours of the autoscaling.</p><p>自动缩放不会平衡副本以防止危险的拓扑。我们观察到自动缩放的几种不良行为。</p><p>  Two nodes being assigned as replicas of the same shard resulting in a large load on the survivor if one crash, often also taking out the survivor.</p><p>两个节点被指定为同一碎片的副本，如果其中一个崩溃，会给幸存者带来巨大的负载，通常还会导致幸存者死亡。</p><p> Adding multiple nodes as replicas to a single leader concurrently causing the leader to try and distribute its data to both new followers at once. This took down the leader occasionally.</p><p>将多个节点作为副本添加到单个领导者，同时导致领导者尝试将其数据同时分发给两个新的追随者。这偶尔会让领导倒台。</p><p> We have some self-managed scripts to ensure that replicas of a shard are in distinct nodes and across AZs, but this is not out of the box.</p><p>我们有一些自我管理的脚本，以确保碎片的副本位于不同的节点中并跨AZ，但这不是现成的。</p><p>  Shards are placed on nodes based on a replication value, defined on Index creation, or specified by an index template.</p><p>碎片根据复制值放置在节点上，复制值在索引创建时定义，或由索引模板指定。</p><p>    solrconfig.xml, which contains settings, such as custom default handers, zookeeper timeouts, and auto commit intervals.</p><p>solrconfig。xml，其中包含一些设置，例如自定义默认手持器、zookeeper超时和自动提交间隔。</p><p>  You can create indexes using an  index template with default values for these settings, but changing the template does not change the configuration of live indexes. To change the configuration of a live index, you must apply settings or mappings directly to that index.</p><p>可以使用具有这些设置默认值的索引模板创建索引，但更改模板不会更改活动索引的配置。要更改活动索引的配置，必须直接将设置或映射应用于该索引。</p><p>  The way Elasticsearch handles the configuration of an index is a big change from Solr. Understanding what  index templates are and how they can be used helps translate the Solr configuration files to the Elasticsearch context.</p><p>Elasticsearch处理索引配置的方式与Solr相比有很大变化。了解什么是索引模板以及如何使用它们有助于将Solr配置文件转换为Elasticsearch上下文。</p><p> Index Templates contain the settings and the mappings that define an index. They specify an index pattern (such as  test-*) that is applied to all new indexes matching this pattern.</p><p>索引模板包含定义索引的设置和映射。它们指定一个索引模式（例如test-*），该模式应用于与该模式匹配的所有新索引。</p><p> Mappings define fields and the analyzers/tokenizers they should use. Mappings can also be labeled as  &#34;dynamic&#34;: &#34;strict&#34;, which requires you to explicitly add fields that are to be indexed to the mapping (like most fields in Solr); if a document to be indexed contains a field that is not defined in the mapping, it will fail to be indexed.</p><p>映射定义字段以及它们应该使用的分析器/标记器。映射也可以标记为&#34；动态&#34；：&#34;严格的&#34；，这要求您显式地添加要为映射编制索引的字段（就像Solr中的大多数字段一样）；如果要编制索引的文档包含映射中未定义的字段，则无法编制索引。</p><p>  You can also create index templates using component templates. For example, different component templates might each define:</p><p>还可以使用组件模板创建索引模板。例如，不同的组件模板可能各自定义：</p><p>  You could then create an index template using these three templates, applying their combined configuration to new indexes.</p><p>然后，可以使用这三个模板创建索引模板，将它们的组合配置应用于新索引。</p><p>  Elasticsearch and Solr have similar tokenizers and analyzers but define the schema differently and have their own indexing behaviours.</p><p>Elasticsearch和Solr具有类似的标记化器和分析器，但对模式的定义不同，并且有自己的索引行为。</p><p>  &lt;field name=&#34;brand&#34; type=&#34;simple_text&#34; indexed=&#34;true&#34; stored=&#34;false&#34; required=&#34;false&#34; multiValued=&#34;true&#34;/&gt; ... &lt;fieldType name=&#34;simple_text&#34; class=&#34;solr.TextField&#34;  positionIncrementGap=&#34;100&#34;&gt;  &lt;analyzer&gt;  &lt;tokenizer class=&#34;solr.WhitespaceTokenizerFactory&#34;/&gt;  &lt;filter class=&#34;solr.LowerCaseFilterFactory&#34;/&gt;  &lt;filter class=&#34;solr.ASCIIFoldingFilterFactory&#34;/&gt;  &lt;/analyzer&gt;  &lt;/fieldType&gt;</p><p>&lt；字段名=&#34；品牌&#34；类型=&#34；简单的文字&#34；索引=&#34；正确&#34；存储=&#34；假&#34；必需=&#34；假&#34；多值=&#34；正确&#34/&gt&书信电报；字段类型名称=&#34；简单的文字&#34；等级=&#34；索尔。文本字段和#34；位置增量差距=&#34；100&#34;&gt&书信电报；分析仪&gt&书信电报；标记器类=&#34；索尔。WhitespaceTokenizerFactory&#34/&gt&书信电报；过滤等级=&#34；索尔。小写字母filterFactory&#34/&gt&书信电报；过滤等级=&#34；索尔。ASCIIFoldingFilterFactory&#34/&gt&lt/分析仪&gt&lt/fieldType&gt；</p><p>  {  &#34;settings&#34;: {  &#34;simple_text&#34;: {  &#34;tokenizer&#34;: &#34;standard&#34;,  &#34;filter&#34;: [  &#34;lowercase&#34;,  &#34;asciifolding&#34;  ]  } ...  },  &#34;mappings&#34;: {  &#34;dynamic&#34;: &#34;strict&#34;,  &#34;properties&#34;: {  &#34;brand&#34;: {  &#34;type&#34;: &#34;text&#34;,  }  } ...  } }</p><p>{&#34；设置&#34；：{&#34；简单文本&#34；{&#34；标记器&#34；：&#34；标准&#34；&#34；过滤器&#34；[&#34；小写&#34；&#34；&#&#34;映射&#34；：{&#34；动态&#34；：&#34；严格&#34；&#34；属性&#34；：{&#34；品牌&#34；{&#34；类型&#34；：&#34；文本&#34；}</p><p>   Requires fields to be explicitly defined by a field name, or as a dynamic field, eg.  title-*.</p><p>要求字段由字段名显式定义，或作为动态字段定义，例如title-*。</p><p>    For most queries, there are direct equivalents between Solr and Elasticsearch, but typically with different labels and query structure;</p><p>对于大多数查询，Solr和Elasticsearch之间有直接等价物，但通常具有不同的标签和查询结构；</p><p>                  GET /_search  {   &#34;query&#34;: {   &#34;bool&#34;: {   &#34;must&#34;: [   { &#34;match&#34;: { &#34;title&#34;: &#34;Search&#34;}},   { &#34;match&#34;: { &#34;content&#34;: &#34;Elasticsearch&#34; }}   ],   &#34;filter&#34;: [   { &#34;term&#34;: { &#34;status&#34;: &#34;published&#34; }},   { &#34;range&#34;: { &#34;publish_date&#34;: { &#34;gte&#34;: &#34;2015-01-01&#34;}}}   ]   }   }  }</p><p>获取/搜索{&#34；查询&#34；{&#34；布尔&#34；{&#34；必须&#34；[{&#34；匹配&#34；{&#34；头衔&#34；：&&#34；搜索&#34；}，{&#34；匹配&#34；：{&#34；内容&#34；：&#34；弹性搜索&#34；}]&#34;过滤器&#34；：[{&#34；任期&#34；：{&#34；状态&#34；：&#34；出版&#34；}，{&#34；范围&#34；：{&#34；出版日期&#34；：{&#34；gte&#34；：&#34；2015-01-01&#34；}</p><p>     GET /_search  {   &#34;_source&#34;: {   &#34;includes&#34;: [ &#34;name&#34;, &#34;id&#34; ]  },   &#34;query&#34; : {   &#34;term&#34; : { &#34;user&#34; : &#34;kimchy&#34; }   }  }</p><p>获取/搜索{&#34；#源&#34；：{&#34；包括&#34；：[&#34；名称&#34；&#34；id&#34；]&#34;查询&#34；：{&#34；术语&#34；：{&#34；用户&#34；：&#34；kimchy&#34；}</p><p>    Elasticsearch supports mapping object fields as  nested data types. Objects mapped this way capture structured data, and can be queried both individually or as a collection of fields.</p><p>Elasticsearch支持将对象字段映射为嵌套数据类型。以这种方式映射的对象捕获结构化数据，可以单独查询，也可以作为字段集合查询。</p><p>  PUT my-index-000001 {  &#34;mappings&#34;: {  &#34;properties&#34;: {  &#34;user&#34;: {  &#34;type&#34;: &#34;nested&#34;,  &#34;properties&#34;: {  &#34;first&#34;: {  &#34;type&#34;: &#34;text&#34;  },  &#34;last&#34;: {  &#34;type&#34;: &#34;text&#34;  }  }   },  &#34;group&#34;: {  &#34;type&#34;: &#34;keyword&#34;  }  }  } }</p><p>放置my-index-000001{&#34；映射&#34；{&#34；属性&#34；{&#34；用户&#34；{&#34；类型&#34；&#34；嵌套&#34；&#属性&#34；{&#34；第一&&&#34；#类型&&&#34；#&#34;最后&#34；：{&#34；类型&#34；：&#34；文本&#34；}&#34;第34组：{&#34；类型&#34；：&#34；关键字&#34；}}}</p><p>  PUT my-index-000001/_doc/1 {  &#34;group&#34; : &#34;fans&#34;,  &#34;user&#34; : [   {  &#34;first&#34; : &#34;John&#34;,  &#34;last&#34; : &#34;Smith&#34;  },  {  &#34;first&#34; : &#34;Alice&#34;,  &#34;last&#34; : &#34;White&#34;  }  ] }</p><p>把my-index-000001/#u doc/1{&#34；组&#34；&#34；粉丝&#34；&#34；用户&#34；[{&#34；第一&#34；&#34；约翰&&#34；&#34；&#最后&#34；&&#，{&#34；第一&#34；&#34；爱丽丝&#34；&#34；最后&#34；&#34；怀特&#34；}</p><p>  // match documents that have any user objects that match  // first or last of &#34;Robert&#34; GET my-index-000001/_search {  &#34;query&#34;: {  &#34;bool&#34;: {  &#34;must&#34;: [  { &#34;match&#34;: { &#34;user.*&#34;: &#34;Robert&#34; }}  ]  }  } } // match documents that have individual user objects that match  // first of &#34;Jane&#34; **and** last of &#34;Smith&#34; GET my-index-000001/_search {  &#34;query&#34;: {  &#34;bool&#34;: {  &#34;must&#34;: [  { &#34;match&#34;: { &#34;user.first&#34;: &#34;Jane&#34; }},  { &#34;match&#34;: { &#34;user.last&#34;: &#34;Smith&#34; }}  ]  }  } }</p><p>//匹配具有匹配//first或last of&#34的任何用户对象的文档；罗伯特&#34；获取my-index-000001/#u search{&#34；query&#34；{&#34；bool&#34；{&#34；must&#34；：[{&#34；match&#34；user.&&&#34；&&&#34；Robert&#34；}}匹配具有单个用户对象的文档，这些对象匹配//first of&#34；简&#34**和**第34项中的最后一项；史密斯和#34；获取my-index-000001/#u search{&#34；query&#34；{&#34；bool&#34；{&#34；must&#34；：[{&#34；match&#34；user.first&#34；&#Jane&#34；}，{&#34；匹配&#34；：{&#34；用户。最后&#34；：&#34；史密斯&#34；}}}</p><p>  Our migration to Elasticsearch unlocks some vector search options with the ability to map fields as dense and sparse vectors, by encoding vectors as binary doc_values. It is worth noting that  lucene (and hence both Elasticsearch and Solr) is adding features in this space, including  Solr’s recent support for HNSW Vector search.</p><p>我们向Elasticsearch的迁移解锁了一些向量搜索选项，通过将向量编码为二进制doc_值，可以将字段映射为密集和稀疏向量。值得注意的是，lucene（以及Elasticsearch和Solr）正在这一领域添加功能，包括Solr最近对HNSW向量搜索的支持。</p><p>  Maintained docs and API references, as well as an active online community. As much as we appreciate the Apache mailing lists for Solr and Zookeeper, having online forums is a win.</p><p>维护文档和API参考，以及活跃的在线社区。尽管我们非常感谢Solr和Zookeeper的Apache邮件列表，但拥有在线论坛是一种胜利。</p><p>   Dynamic fields are great if you want an unstructured search that lets you put anything into an index, but if you instead want a structured search with guaranteed fields, you must set this up before indexing.</p><p>如果您想要一个非结构化搜索，可以将任何内容放入索引中，那么动态字段是很好的选择，但是如果您想要一个有保证字段的结构化搜索，那么必须在索引之前设置它。</p><p> Elasticsearch doesn’t have a way to specify that all documents require a given field, or that a given field must have only one value, for that you would need an ingest pipeline with a fail processor.</p><p>Elasticsearch无法指定所有文档都需要一个给定的字段，或者一个给定的字段必须只有一个值，因为您需要一个带有故障处理器的摄取管道。</p><p>  This seems like a small thing (and it probably is) but when going from Solr’s  .xml schema to Elasticsearch&#39;s JSON templates, you must find a new home for all your insightful annotations, such as reasons why we don’t want to lowercase  username.</p><p>这似乎是一件小事（而且可能是），但从Solr的角度来看。xml模式到Elasticsearch&#39；在JSON模板中，您必须为所有有见地的注释找到一个新的家，比如我们不想使用小写用户名的原因。</p><p>  Another small thing, but coming from Solr, where it easy to get a graph and see which nodes are on which shard and their current status, Elasticsearch requires a different way of thinking to debug. If an Elasticsearch cluster is yellow, for example, you must debug this without the pretty picture.</p><p>另一件小事情，但来自Solr，在Solr中很容易获得一个图，并查看哪些节点在哪个碎片上以及它们的当前状态，Elasticsearch需要一种不同的思维方式来调试。例如，如果Elasticsearch集群为黄色，则必须在没有漂亮图片的情况下调试它。</p><p> The wonder of abstraction that makes the infra super easy to set up makes it  harder to work out which node or instances are failing. We, fortunately, have had success in setting up dashboard with metrics by node and by index so that outliers can be spotted.</p><p>抽象的奇妙之处使infra超级容易设置，这使得确定哪些节点或实例出现故障变得更加困难。幸运的是，我们已经成功地用节点和索引的度量设置了仪表板，以便能够发现异常值。</p><p>  You can upload extra files, such as those that contain synonyms, to a collection and reference them by  id. This  id, however, is set on upload and isn’t mutable, or specifiable.</p><p>您可以将额外的文件（例如包含同义词的文件）上载到集合，并按id引用它们。但是，此id是在上载时设置的，不可更改或指定。</p><p>  These are the lessons learnt from migrating the first of our search engines to the Elasticsearch framework. We are now tackling bringing our larger and more set up services, with their full 7 years of patterns, over to Elasticsearch!</p><p>这些是从我们的第一个搜索引擎迁移到Elasticsearch框架中吸取的经验教训。我们现在正在努力将我们规模更大、设置更完善的服务，以及它们整整7年的模式，转变为Elasticsearch！</p><p> From our initial migrations, we’re excited to not need to set up a zookeeper with careful logging settings. We also appreciate all the learnings that our migration journey has taught us.</p><p>从最初的迁移开始，我们很高兴不需要设置一个带有仔细记录设置的动物园管理员。我们也感谢移民之旅教会我们的所有知识。</p><p> The remaining big question surrounding our migration is the development and divergence of offerings from Elasticsearch and OpenSearch. We are currently on  Elasticsearch 7.10, with the ability to pursue either stream, and will continue to watch their respective offerings carefully with respect to search features and managed options with interest.</p><p>围绕我们迁移的另一个大问题是Elasticsearch和OpenSearch产品的发展和差异。我们目前使用的是Elasticsearch 7.10，能够追踪任何一个流，并将继续关注他们各自的搜索功能和托管选项。</p><p>   Brandon Janson,  Nic Laver,  Yiwei Han,  Stuart Cam: who worked on our search platform, migrating key search components.</p><p>Brandon Janson，Nic Laver，Yiwei Han，Stuart Cam：他在我们的搜索平台上工作，迁移关键的搜索组件。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/迁移/">#迁移</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/solr/">#solr</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>