<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用铁锈组装的温文尔雅的介绍</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">用铁锈组装的温文尔雅的介绍</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-04 03:15:21</div><div class="page_narrow text-break page_content"><p>我一段时间以来一直想做的事情之一就是真正深入到汇编中，深入了解程序实际是如何运行的。ASM宏的重新编写最近在每晚都会出现，所以现在看起来是个好时机。</p><p>与我尝试过的其他一些方法相比，如果我们只是在生锈的操场上做所有的重活，我们需要做的设置要少得多。</p><p>我弄清楚事情的过程非常简单，我写了一点生锈的代码，看看汇编输出，然后试着弄清楚发生了什么(通过大量的谷歌搜索)。我将向您介绍我做了什么，以及我弄明白了什么。</p><p>您可以通过单击Run旁边的三个点并从下拉菜单中选择ASM来获得此程序集的输出。您可能还想将汇编的风格(通常在其他地方称为语法)更改为英特尔(而不是at&amp；t)1(如果尚未更改)，方法是单击config菜单下的切换。</p><p>在调试模式下，这段代码的汇编输出比您预期的要大得多--我得到157行代码。而且大部分都不是我们的节目。不过，我们编写的代码应该很容易找到，因为编译器会很有帮助地用它们的箱名和函数名来标记所有的函数。在本例中，因为我们在操场上，所以create是隐式的操场，所以我们可以通过使用ctrl-f搜索PlayGround：：Main来找到我们的代码。这样做可以让我：</p><p>因此，即使这是一个调试版本，显然仍然有一些优化正在进行，因为没有数字或任何看起来像是将它们加在一起的东西。这里发生的所有事情就是我们返回(Ret)到调用playround：：main的函数。所有以#为前缀的内容都是注释，因此当我们运行此代码时会忽略这些内容。</p><p>唯一的另一个兴趣点是标签playround：：main：-任何带有：后缀的标签都可以用各种命令跳转到这个标签，实际上，如果我们继续搜索playround：：main，我们可以在main中找到对它的一个相当间接的调用。希望在本文结束时我们能理解这一点！</p><p>Playround：：add：#@playround：：add#%bb.0：mov eax，3 ret#--end函数playround：：main：#@playround：：main#%bb.0：Push rax call playround：：add#%bb.1：poprax ret#--end函数</p><p>因此，我们在这方面取得了更多进展。仍然在进行一些优化，因为我们在代码中没有看到1或2，只看到了3。我们可以看到被移动(Mov)到了playround：：add.中的eax寄存器中。这一定是我们将值返回到main的方式。</p><p>事实上，在main内部，我们可以看到将rax-将寄存器rax中的值保存到堆栈，然后调用我们的add函数，然后我们将rax弹出堆栈。推送调用弹出序列将保留ADD中使用的寄存器中的任何值。它还会丢弃我们在add中保存在eax中的值，因为eax和rax是同一个寄存器。下表显示了“较瘦”寄存器与“较宽”寄存器是如何重叠的。</p><p>那么我们如何才能让它真正做一些数学运算呢？我们再试一次：</p><p>Playround：：add：#@playround：：add#%bb.0：sub RSP，24 mov qword PTR[RSP+16]，RDI add RDI，1 set al test al，1 mov qword PTR[RSP+8]，RDI#8字节溢出jne.LBB8_2#%bb.1：MOV rax，qword PTR[RSP+8]#8字节重新加载添加RSP，24 ret.Lb.1：MOV rax，qword PTR[RSP+8]#8字节重新加载添加RSP，24 ret.Lb.1：MOV rax，qword PTR[RSP+8]#8字节重新加载添加RSP，24 ret.Lb.1。Qword PTR[RIP+CORE：：FARGING：：Panic@GOTPCREL]mov ESI，28调用rax ud2#--end函数playround：：main：#@playground：：main#%bb.0：Push rax mov edi，2 call playround：：add#%bb.1：poprax ret#--end函数。</p><p>我们实际上想要生产的东西终于出现在那里了！我们可以看到在输出中添加RDI，1，周围环绕着一堆其他的东西。那么这些其他的代码是什么呢？</p><p>让我们主要从调用堆栈的顶部开始。首先，我们可以看到，在调用PlayGround：：Add之前，2存储在EDI寄存器中，所以我们知道我们的参数必须在EDI寄存器中。同样，我们可以看到rax上的PUSH、POP，所以这一定是返回值。</p><p>现在，看看运动场：：ADD，我们首先看到的是SubRSP，24。RSP是保存堆栈指针的寄存器，因此这会增加堆栈(因为堆栈在x862中向下增长)。再往下我们可以看到，使用add rsp，24可以将堆栈缩小相应的量。</p><p>然后我们有mov qword ptr[rsp+16]，rdi。这是将值从RDI复制到RSP+16处的堆栈上，RSP+16是我们刚刚增长堆栈的区域的顶部。qword PTR(四字(即64位)指针)位是用来消除参数歧义的提示。为什么要把它推到堆栈上呢？我认为这只是为了使调试更容易，因为我们再也不会访问该值了。</p><p>在任何情况下，我们都会继续向RDI实际加1。值被存储回RDI中，重要的是，对于接下来要做的事情，我们可能会设置一些标志。</p><p>然后事情又变得复杂了-我们有了解决方案。所有的SET*指令都处理标志寄存器。标志寄存器可能是最神奇的寄存器，因为它是由一串指令作为副作用来操作的。</p><p>我们运行的最后一条指令是ADD，它设置了6个标志：进位、奇偶校验、调整(也称为辅助进位)、零、符号和溢出。</p><p>在本例中，我们检查进位位是否已设置，如果是，则将alregister设置为1。这实际上是在做什么呢？如果我们相加的两个数字有进位，进位位就被设置为1，这意味着得到的数字太大了，无法存储在寄存器中。在这种情况下，我们应该怎么做？让我们继续往下读，找出答案。</p><p>然后，在下一行(testal，1)中，我们检查al中的值是否等于1。(test对两个参数执行逐位AND操作-如rust中的&amp；。)这将设置更多标志，特别是零标志，然后由下面的jne指令读取。</p><p>Jne代表JUMP IF NOT EQUAL(同样，还有一系列其他j*指令)。因为它使用标志，所以它只需要一个参数：跳到哪里。</p><p>看一下它跳到哪里，我们就会对上面逻辑的意图有一个很大的提示：core：：Panching：：Panic@GOTPCREL。基本上，从setb到jne的所有汇编块都在检查我们是否溢出了寄存器，如果溢出，就会出现恐慌。</p><p>我们没有讨论的一位是mov qword PTR[RSP+8]，RDI#8字节溢出。由于注释暗示这是将值从RDI寄存器“溢出”到堆栈上，因为我们可能要跳转到改写该寄存器的代码-在jne之后，我们立即将值从堆栈加载回堆栈。</p><p>最后，我们将堆栈指针拖回其起点，并返回调用方。RET使用堆栈上的最后一个值(由调用推送)来确定要跳回的位置，因此将堆栈指针移回非常重要。</p><p>因此，也许在这一点上，我们已经看到了足够多的内容，可以尝试用ASM替换addfunction的核心了！宏。因为我们对性能感兴趣，所以我们将忽略那些烦人的溢出检查，并假设我们在U64的范围内。</p><p>这里我们要处理的最大的新问题是指定传入和传出寄存器。rfch是对这些寄存器的非常平易近人的解释，所以我建议您阅读它。如果您想自己尝试一下，这里有一个框架，您可以从这里开始。</p><p>我设计的版本如下所示。这可能是可能的“最新奇”版本，因为我们使用了尽可能多的ASM宏功能：</p><p>我们让RUST编译器挑选我们使用的寄存器，然后使用ASM宏的格式字符串行为编写它。</p><p>我们还使用inlateout来提示我们只能使用单个寄存器。</p><p>这似乎是一个合理的突破点。我们已经介绍了x64汇编中指令集的合理部分，并查看了大多数指令类的示例。我们可以探索的还有很多，比如：</p><p>希望我从这里链接到的资源足以让你继续挖掘，如果你想要的话，也许我会设法跟进这一点。</p><p>这是我发现关于组装最令人困惑的事情之一。(至少)有两种不同的主要语法，它们只是在语法上不同。因此指令是相同的(add、mov等)，但是它们以不同的顺序接受它们的参数。AT&amp；T风格的组件中也有一堆随机符号。由于Rusts ASM默认采用英特尔风格的组装，我们将坚持这样做。如果你真的开始在谷歌上搜索东西，你会得到什么样的组装，这是掷骰子决定的。美国电话电报公司(AT&amp；T)有很多%符号，所以这通常是免费的。</p><p>[返回]</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lfn3.net/2020/08/03/a-gentle-intro-to-assembly-with-rust/">https://lfn3.net/2020/08/03/a-gentle-intro-to-assembly-with-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组装/">#组装</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/intro/">#intro</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1015967.html"><img src="http://img.diglog.com/img/2020/8/thumb_10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015967.html">铁锈1.45.2</a></div><span class="my_story_list_date">2020-8-4 2:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015886.html"><img src="http://img.diglog.com/img/2020/8/thumb_16bbcd1cab07a0bf56a5572d0af2777c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015886.html">C++：Bjarne Stroustrup关注分布式系统、类型安全和锈蚀</a></div><span class="my_story_list_date">2020-8-3 20:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015707.html"><img src="http://img.diglog.com/img/2020/8/thumb_cdb41c5ca2e82352bb03252c8034acdb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015707.html">Python在新语言受欢迎程度排名中超过Java，Rust跻身前20名</a></div><span class="my_story_list_date">2020-8-2 9:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015706.html"><img src="http://img.diglog.com/img/2020/8/thumb_ffafaa979a0d827f9f20daa5316c78bc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015706.html">蓝色战队之锈：什么是“记忆安全”，真的吗？</a></div><span class="my_story_list_date">2020-8-2 9:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>