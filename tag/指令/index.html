<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#指令</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#指令</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1063706.html">6502“非法”操作码脱贱 </a></div><div class="item_title_en"><a target="_blank" href="https://www.masswerk.at/nowgobang/2021/6502-illegal-opcodes">6502 “Illegal” Opcodes Demystified</a><span>(www.masswerk.at)</span></div><span class="my_story_list_date">2021-6-5 23:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1063706.html"><img src="http://img2.diglog.com/img/2021/6/thumb_4781bd01f346254385c84b017344cb57.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">仔细看看“非法”操作系统和MOS 6502 MPU的未记录指令。
    MOS 6502 MPU的指令表由MOS技术设计并于1975年推出（CMOS版本，65C02由Western Design Center开发）具有一些明显的差距，只有56种IntrultIons以各种地址模式记录。这叶105无证的插槽 - 而6......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/操作码/">#操作码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/opcodes/">#opcodes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061861.html">x86上的意外指令 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/preames/public-notes/blob/master/unintended-instructions.rst">Unintended Instructions on x86</a><span>(github.com)</span></div><span class="my_story_list_date">2021-5-11 10:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1061861.html"><img src="http://img2.diglog.com/img/2021/5/thumb_035a267a65040792fa65f99cd8bdc728.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">永久链接当前是一个草稿。它可能是任意错误的。反馈非常欢迎。本文件（旨在最终）概述用于处理意外指令的技术，我的希望是这对他人有所帮助，但主要的目标是帮助我组织自己的思想并在文学中包装我的脑袋话题。我一直在为客户做这个话题的工作，并将在不久的将来在上游LLVM中进行一些相关的工作。完成后，此写作将作为该项目的背景。
  ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1059602.html">有多少x86指令？ （2016） </a></div><div class="item_title_en"><a target="_blank" href="https://fgiesen.wordpress.com/2016/08/25/how-many-x86-instructions-are-there/">How many x86 instructions are there? (2016)</a><span>(fgiesen.wordpress.com)</span></div><span class="my_story_list_date">2021-4-22 11:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1059602.html"><img src="http://img2.diglog.com/img/2021/4/thumb_7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">令人惊讶的是，给出一个很好的答案（在本文中提出的问题）。这取决于你的统计方式，细节很有趣（无论如何）。
 不要离开你挂起：英特尔有一个官方x86编码器/解码器库，名为xed。根据英特尔的XED，就像这种写作一样，有1503个定义的x86指令（“Xed Lingo的iClasses”），从AAA到XTest（这也包括A......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1054415.html">用一个奇怪的技巧猜测整个x86-64指令以秒为单位 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.can.ac/2021/03/22/speculating-x86-64-isa-with-one-weird-trick/">Speculating the entire x86-64 instruction set in seconds with one weird trick</a><span>(blog.can.ac)</span></div><span class="my_story_list_date">2021-3-26 20:6</span><div class="my_story_list_item_desc">Home x86内部结构猜测整个x86-64指令在几秒钟内使用这个奇怪的技巧
 作为俗气的标题声音，我保证无法击败技术的俗气，我会在这篇文章中告诉你。早上我看到Mark Ermolov的推文关于无证指导从/写入CRBUS，我手里有一点空闲时间，我知道我不得不找出OPCode，所以我立即开始理论制作。经过几个小时的数字......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/技巧/">#技巧</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/entire/">#entire</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1053495.html">设计RISC-V CPU，第2部分：成功执行（某些）说明 </a></div><div class="item_title_en"><a target="_blank" href="https://mcla.ug/blog/risc-v-cpu-part-2.html">Designing a RISC-V CPU, Part 2: Successfully executing (some) instructions</a><span>(mcla.ug)</span></div><span class="my_story_list_date">2021-3-20 8:56</span><div class="my_story_list_item_desc">此前的这一份额是＆＃34;基本上解释了FPGA和A＆＃39; Hello World＆＃39; nmigen例子。＆＃34; 1在这篇文章中，我将详细说明我的CPU目前的设计，并追溯到我沿途所做的各种错误。与上一篇文章一起，我主要针对软件工程师的旨在新的硬件设计 - 但我希望它对尼格珍，RISC-V或CPU设计中的任......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1051155.html">Apple M1微架构研究 </a></div><div class="item_title_en"><a target="_blank" href="https://dougallj.github.io/applecpu/firestorm.html">Apple M1 Microarchitecture Research</a><span>(dougallj.github.io)</span></div><span class="my_story_list_date">2021-3-7 23:27</span><div class="my_story_list_item_desc">这是在Apple M1中的CPU中的微型建筑文件的早期尝试，灵感来自Andreas Abel，Andrei Frumusanu，@Veedrac，Travis Downs，Henry Wongand Aganter Fog的惊人工作。本文档是我的最佳努力，但它基于黑匣子逆向工程，肯定会有错误。没有任何形式的保修（而不......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/m1/">#m1</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1049640.html">Uber如何处理大型iOS应用程序 </a></div><div class="item_title_en"><a target="_blank" href="https://eng.uber.com/how-uber-deals-with-large-ios-app-size/">How Uber Deals with Large iOS App Size</a><span>(eng.uber.com)</span></div><span class="my_story_list_date">2021-2-27 5:3</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1049640.html"><img src="http://img2.diglog.com/img/2021/2/thumb_8ba598fc2bf0364afa4be21508bba000.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Uber的适用于Rider，Driver和Eats的iOS移动应用程序很大。选择Swift作为我们的主要编程语言，快速的开发环境和功能添加，分层的软件及其依赖项以及静态链接的平台库会导致大型应用程序二进制文件。减小应用程序大小对于我们的客户体验至关重要。此外，苹果公司对应用程序下载大小的限制禁止通过空中下载大量应用程......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/uber/">#uber</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deals/">#deals</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048871.html">引导IBM 1401：1959年Punch卡计算机如何加载程序 </a></div><div class="item_title_en"><a target="_blank" href="https://www.righto.com/2021/02/an-ibm-1401-mainframe-computer-at.html">Booting the IBM 1401: How a 1959 punch-card computer loads a program</a><span>(www.righto.com)</span></div><span class="my_story_list_date">2021-2-24 21:23</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1048871.html"><img src="http://img2.diglog.com/img/2021/2/thumb_112e473e76ee2acf822050f49d60eace.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">当计算机没有操作系统而没有ROM时，如何从打卡中启动计算机？要使事情更糟糕，这台计算机需要特殊的元数据，称为＃34;字标记＆＃34;可以＆＃39; t在卡上代表。在这个博客文章中，我描述了复古IBM 1401计算机中使用的有趣硬件和软件技术，以从打卡甲板加载软件。（除其他内容中，每个人的一半卡包含读取每张卡时运行的加......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/加载/">#加载</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/card/">#card</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1043709.html">避免指令缓存未命中（2019） </a></div><div class="item_title_en"><a target="_blank" href="https://paweldziepak.dev/2019/06/21/avoiding-icache-misses/">Avoiding instruction cache misses (2019)</a><span>(paweldziepak.dev)</span></div><span class="my_story_list_date">2021-1-9 15:50</span><div class="my_story_list_item_desc">现代处理器非常复杂，许多部件都有可能成为瓶颈。短代码的性能相对容易推断，尤其是在将内存影响保持在最低水平的情况下。在这种情况下，静态分析工具（如LLVM MCA和微基准）都可以提供很多信息。但是，整个程序的行为不仅仅是这些小部分的总和。随着代码变大和越来越复杂，其他效果开始出现。这种潜在问题之一是过多的指令高速缓存未......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1043336.html">RISC-V向量指令与ARM和x86 SIMD的比较 </a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/swlh/risc-v-vector-instructions-vs-arm-and-x86-simd-8c9b17963a31">RISC-V Vector Instructions vs. ARM and x86 SIMD</a><span>(medium.com)</span></div><span class="my_story_list_date">2021-1-5 14:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1043336.html"><img src="http://img2.diglog.com/img/2021/1/thumb_4811dd26a06d13b1d219c524896a13e7.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">旧的Cray-1型矢量机还会回来吗？向量指令和现代SIMD指令之间到底有什么区别？
  在1980年代，超级计算机的外观如下图所示。 Cray的半圆形是80年代超级计算机的代名词。那就是一台超级计算机的样子。
  过去的超级计算时代与RISC-V有什么关系？您会看到Cray计算机，我们称之为矢量处理机。早已被视为过去......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/向量指令/">#向量指令</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vector/">#vector</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042671.html">LINK知道大约80x86处理器（1997） </a></div><div class="item_title_en"><a target="_blank" href="https://www.geoffchappell.com/notes/windows/archive/linkcpu.htm">Strange Things LINK Knows about 80x86 Processors (1997)</a><span>(www.geoffchappell.com)</span></div><span class="my_story_list_date">2021-1-1 8:8</span><div class="my_story_list_item_desc">专门为英特尔处理器设计的主流操作系统的历史使得有时要由不编写操作系统本身的程序员来开发旨在在操作系统级别或接近操作系统级别运行的软件。这些程序员意在为操作系统添加功能，并且可能是Microsoft以外的程序员的创造性添加为Microsoft操作系统在消费市场上的稳定性和成功做出了很大贡献。
 由于它们与处理器的协作更......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/link/">#link</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/strange/">#strange</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041546.html">C ++使用指令如何工作？ </a></div><div class="item_title_en"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/21/using-directive/">How do C++ using-directives work?</a><span>(quuxplusone.github.io)</span></div><span class="my_story_list_date">2020-12-24 21:18</span><div class="my_story_list_item_desc">使用声明在语义上类似于声明；它在当前范围内引入了名称的新含义。如果该名称已经具有来自外部作用域的一个或多个含义，则这些现有的含义将被新声明隐藏或遮盖。 Godbolt：
 命名空间AnimalUtils {int foo（Zoo :: Animal）;}命名空间Outer {int foo（Zoo :: Lion）;......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/foo/">#foo</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035517.html">RISC和CISC在2020年意味着什么？</a></div><div class="item_title_en"><a target="_blank" href="https://erik-engheim.medium.com/what-does-risc-and-cisc-mean-in-2020-7b4d42c9a9de">What do RISC and CISC mean in 2020?</a><span>(erik-engheim.medium.com)</span></div><span class="my_story_list_date">2020-11-21 12:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035517.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1933307081dac539de420c7564fded04.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">如今，许多人说RISC和CISC之间的区别变得无关紧要。真的吗？如果不是，那么现代RISC和CISC CPU之间到底有什么区别？
Apple现在已经发布了M1 Apple Silicon芯片，经过一番摸索，您可能想知道它与Intel或AMD处理器有何不同？您可能听说过M1被称为ARM处理器，而ARM是所谓的RISC处......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035440.html">从规范生成WebAssembly 6502仿真器的代码</a></div><div class="item_title_en"><a target="_blank" href="https://blog.scottlogic.com/2020/08/26/codegen-6502-webassembly.html">Code-generating a WebAssembly 6502 emulator from specifications</a><span>(blog.scottlogic.com)</span></div><span class="my_story_list_date">2020-11-16 21:29</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035440.html"><img src="http://img2.diglog.com/img/2020/11/thumb_58b04e074eebe65efe8bfe26ccb3dc08.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">编写仿真器使旧的计算机硬件起死回生是一种流行的爱好，我最近通过自己的目标--编写一款Atari 2600仿真器--一直在享受这一爱好。然而，编写CPU仿真器可能会有些重复和乏味，所以我想我应该探索一种不同的方法-从规范生成CPU仿真代码，而不是手动转换它。这篇博文分享了丰硕的成果。
雅达利2600在70年代末和80年......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生成/">#生成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033281.html">Bddisasm：BitDefender x86反汇编程序</a></div><div class="item_title_en"><a target="_blank" href="https://hvmi.github.io/blog/2020/11/04/bddisasm.html">Bddisasm: The Bitdefender x86 Disassembler</a><span>(hvmi.github.io)</span></div><span class="my_story_list_date">2020-11-5 20:10</span><div class="my_story_list_item_desc">管理程序内存自省(HVMI)依赖于分析内存访问以确定它们是否合法。例如，通过分析旧的存储值和新存储的值，HVMI可以决定是否允许修改。然而，这带来了需要对修改受保护内存的每条指令进行深入分析的复杂性。与RISC体系结构不同，x86有大量的指令可以通过复杂的读-修改-写(RMW)方式访问存储器，并使用复杂的寻址方案。为......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033191.html">JIT初见端倪</a></div><div class="item_title_en"><a target="_blank" href="https://blog.erlang.org/a-first-look-at-the-jit/">A First Look at the JIT</a><span>(blog.erlang.org)</span></div><span class="my_story_list_date">2020-11-5 2:6</span><div class="my_story_list_item_desc">这个问题在很大程度上是自己造成的，是由于编译器太慢(我们经常使用LLVM)造成的，而我们给它提供了大段代码来进行更多的优化，这让情况变得更糟。
通过限制自己一次只编译一条指令，我们在表上留下了一些性能，但极大地提高了编译速度。
这使得编译速度非常快，因为我们基本上只是在每次使用指令时复制-粘贴模板，仅根据其参数执行一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/jit/">#jit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032601.html">一名前ARM工程师批评RISC-V</a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/erincandescent/8a10eeeea1918ee4f9d9982f7618ef68">An ex-ARM engineer critiques RISC-V</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-11-1 19:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032601.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这份文件最初是几年前写的。当时我在ARM担任执行核心验证工程师。通过在不同处理器的执行核心内和周围工作，以下几点被涂上了浓墨重彩的色彩。加一小撮盐；观点包含不同程度的意见。
我仍然认为RISC-V可以设计得更好；尽管我也会说，如果我现在正在构建一个32位或64位的CPU，我很可能会实现该体系结构以受益于现有的工具。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/工程师/">#工程师</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/engineer/">#engineer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032155.html">伽罗华域仿射变换指令的带外使用</a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/animetosho/d3ca95da2131b5813e16b5bb1b137ca0#file-gf2p8affineqb-articles-md">Out-of-Band Uses for the Galois Field Affine Transformation Instruction</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-10-30 5:40</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032155.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">英特尔在其Sunny Cove和Tremont内核中添加了伽罗瓦域指令集(GFNI)扩展。特别有趣的是，GFNI是SSE和VEX/AVX编码附带的唯一新的SIMD扩展(除了EVEX/AVX512)，以允许它在所有未来的Intel内核上得到支持，包括那些不支持AVX512的内核(如Atom系列，以及赛扬/奔腾品牌的“大......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/仿射变换/">#仿射变换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/galois/">#galois</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031361.html">解析RISC-V程序集</a></div><div class="item_title_en"><a target="_blank" href="https://web.eecs.utk.edu/~azh/blog/parsingriscv.html">Parsing RISC-V assembly</a><span>(web.eecs.utk.edu)</span></div><span class="my_story_list_date">2020-10-27 6:26</span><div class="my_story_list_item_desc">最近，我需要为一个研究项目分析一些RISC-V汇编代码，然后计算一些基本指标，但我找不到合适的工具。好的，我将从一个较小的开放源码汇编器中获取一个解析器。这并不成功，因为我看到的那些使用粗糙的、基于正则表达式的解析器，这些解析器不维护有关结构的信息。
没问题，我会实现我自己的！让我查一下RISC-V汇编的语法...。......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030350.html">BEAM简介</a></div><div class="item_title_en"><a target="_blank" href="https://blog.erlang.org/a-brief-BEAM-primer/">A brief introduction to BEAM</a><span>(blog.erlang.org)</span></div><span class="my_story_list_date">2020-10-22 8:51</span><div class="my_story_list_item_desc">这篇文章是关于BEAM的简短入门读物，BEAM是在Erlang Runtime system(ERTS)中执行用户代码的虚拟机。它的目的是帮助那些BEAM新手关注OTP24中即将发布的关于JIT的一系列帖子，将实现细节留到后面。
BEAM经常与ERTS混淆，区分这两个很重要；BEAM只是虚拟机，它没有进程、端口、ET......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/beam/">#beam</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029716.html">编译Lisp：指令编码插曲</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-10/">Compiling a Lisp: Instruction encoding interlude</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-10-19 13:54</span><div class="my_story_list_item_desc">欢迎回到编译Lisp系列。在这个激动人心的新更新中，我们将学习更多关于x86-64指令编码的知识，而不是在堆上分配更多有趣的东西或添加过程调用。
我之所以写这段插曲，是因为我把编译器代码中的一个寄存器(krbp改成了krsp)，所有的地狱都崩溃了-结果程序崩溃了，rasm2/Cutter在给我的二进制文件时解码古怪的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029458.html">RISC-V组件讲座讲稿</a></div><div class="item_title_en"><a target="_blank" href="https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/">Lecture notes on RISC-V assembly</a><span>(web.eecs.utk.edu)</span></div><span class="my_story_list_date">2020-10-17 23:31</span><div class="my_story_list_item_desc">RISC-V组件与任何其他组件类似，与MIPS组件相似。就像任何程序集一样，我们有一个指令列表，它会逐渐使我们更接近我们的解决方案。
我们将使用riscv-g++编译器并将C++文件与汇编文件链接起来。您将编写程序集文件，而C++文件有助于简化实验。
部件文件以.S(大写S)结尾。编译器包括编译、汇编和链接的所有阶段......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notes/">#notes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028752.html">Z80 CPU用户手册(2016)</a></div><div class="item_title_en"><a target="_blank" href="https://zany80.github.io/documentation/Z80/UserManual.html">Z80 CPU User Manual (2016)</a><span>(zany80.github.io)</span></div><span class="my_story_list_date">2020-10-14 22:2</span><div class="my_story_list_item_desc">生命支持设备或系统是指(A)用于外科手术植入人体的设备，或(B)。
支持或维持生命，并且在按照以下说明正确使用时不能正常工作。
可以合理地预期标签中提供的使用会对使用者造成重大伤害。一个标准-。
校准组件是支持设备或系统中可能出现故障的任何组件-。
可能会导致生命支持设备或系统发生故障或影响其安全性或有效性。
或者所......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/cpu/">#cpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027997.html">起重机起重的新后端</a></div><div class="item_title_en"><a target="_blank" href="https://hacks.mozilla.org/2020/10/a-new-backend-for-cranelift-part-1-instruction-selection/">A New Back End for Cranelift</a><span>(hacks.mozilla.org)</span></div><span class="my_story_list_date">2020-10-11 16:19</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027997.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5045c6fcabed5bdc539abaaab482a6fb.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇文章将我最近在Cranelift上的工作描述为我在Mozilla的日常工作的一部分。在这篇文章中，我将设置一些上下文并描述指令选择问题。特别地，我将谈一谈指令选择器和后端框架的总体改造，这是我们在过去九个月左右一直致力于的工作。这项工作是与我杰出的同事朱利安·苏厄德(Julian Seward)和本杰明·布维尔(......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/起重机/">#起重机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cranelift/">#cranelift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025278.html">起重机械的新后端：指令选择</a></div><div class="item_title_en"><a target="_blank" href="https://cfallin.org/blog/2020/09/18/cranelift-isel-1/">A New Back End for Cranelift: Instruction Selection</a><span>(cfallin.org)</span></div><span class="my_story_list_date">2020-9-21 12:4</span><div class="my_story_list_item_desc">这篇文章是关于我在Mozilla的日常工作中最近在Cranelift上的工作的三部分系列中的第一部分。在第一篇文章中，我将设置一些上下文并描述指令选择问题。特别地，我将谈一谈指令选择器和后端框架的总体改进，这是我们在过去九个月左右一直在做的工作。这项工作是与我杰出的同事Julian Seward和Benjamin B......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022650.html">在没有SDL的情况下向GraphQL架构添加指令</a></div><div class="item_title_en"><a target="_blank" href="https://blog.logrocket.com/adding-directives-schema-code-first-graphql-servers/">Adding directives to the GraphQL schema when there's no SDL</a><span>(blog.logrocket.com)</span></div><span class="my_story_list_date">2020-9-8 11:16</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1022650.html"><img src="http://img2.diglog.com/img/2020/9/thumb_803b3b7a76e49ef4a7e6dc20afe81dae.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">创建GraphQL服务器有两种方法：SDL优先(模式定义语言)方法和代码优先方法，这两种方法各有优缺点。并且有两种类型的指令：通过SDL在模式上声明的模式类型指令(例如@Deposated)和添加到客户端查询中的查询类型指令(例如@Include和@Skip)。
代码优先方法的一个缺点是，因为它没有SDL，所以它不能......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sdl/">#sdl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020906.html">AMD Ryzen 3000中令人惊讶的新功能</a></div><div class="item_title_en"><a target="_blank" href="https://www.agner.org/forum/viewtopic.php?t=41">Surprising new feature in AMD Ryzen 3000</a><span>(www.agner.org)</span></div><span class="my_story_list_date">2020-8-28 20:17</span><div class="my_story_list_item_desc">我刚刚测试完AMD Zen2CPU。结果在我的微体系结构手册和我的指令表https://www.agner.org/optimize/#manuals.中。我发现Zen2有一个我们以前从未见过的新的令人惊讶的功能：它可以镜像CPU内部内存操作数的值，这样就可以零延迟地访问它。此汇编代码显示了一个示例：当CPU识别出所......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/amd/">#amd</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/feature/">#feature</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019237.html">冰湖AVX-512降频</a></div><div class="item_title_en"><a target="_blank" href="https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq.html">Ice Lake AVX-512 Downclocking</a><span>(travisdowns.github.io)</span></div><span class="my_story_list_date">2020-8-20 5:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1019237.html"><img src="http://img.diglog.com/img/2020/8/thumb_da0063552588576775f07f3371b9d08c.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是一篇简短的帖子，调查了英特尔最新的冰湖芯片上AVX2和AVX-512相关的基于许可证的降频行为。
基于许可证的降频1指的是当执行某些SIMD指令时，尤其是重浮点指令或512位宽指令时施加低于标称频率限制的半著名效应。
有关这种类型的降频的更多详细信息，请参阅StackOverflow解答，我们已经详细介绍了这些转......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/冰湖/">#冰湖</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lake/">#lake</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018851.html">让我们学习x86-64汇编第0部分-设置和第一步</a></div><div class="item_title_en"><a target="_blank" href="https://gpfault.net/posts/asm-tut-0.txt.html">Let's Learn x86-64 Assembly Part 0 – Setup and First Steps</a><span>(gpfault.net)</span></div><span class="my_story_list_date">2020-8-18 16:12</span><div class="my_story_list_item_desc">当我上第一节课的时候，大学里教我x86汇编的方式已经完全过时了很多年。那是在2008或2009年左右，64位处理器已经开始成为一种东西，甚至在我所处的环境中也是如此。与此同时，我们正在做DOS、实模式、内存分段和所有其他过去糟糕的事情。
尽管如此，我在课程期间(以及随后的几年)学到了足够多的代码，以便能够理解来自编译......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/part/">#part</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011753.html">Golang中的ARM64 Popcount及其汇编器</a></div><div class="item_title_en"><a target="_blank" href="https://barakmich.dev/posts/popcnt-arm64-go-asm/">ARM64 Popcount in Golang and Assembler</a><span>(barakmich.dev)</span></div><span class="my_story_list_date">2020-7-14 22:26</span><div class="my_story_list_item_desc">关于苹果ARM的发布，我想我可能会就我最近写的一段代码写一篇帖子，专门研究ARM64，以及它在各种硬件上的基准测试。
我一直在为一个项目实现一些紧凑的数据结构。该实现的CPU热点之一是需要对可能很大的内存位运行快速人口计数。
如果您以前从未见过人口计数，则它是一个字节(或字节列表)中设置为1的位数的计数，例如：
现在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/popcount/">#popcount</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item active"><a class="page-link" href="/tag/指令/">0</a></li><li class="page-item"><a class="page-link" href="/tag/指令/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>