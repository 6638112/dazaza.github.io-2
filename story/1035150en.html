<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>应用程序信任很难，但苹果做得很好</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">应用程序信任很难，但苹果做得很好</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-15 00:48:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1801319d968974cef0114edb73187c93.png"><img src="http://img2.diglog.com/img/2020/11/1801319d968974cef0114edb73187c93.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>On November 12, 2020 Apple released macOS Big Sur. In the hours after the release went live, somewhere in Apple&#39;s infrastructure an Online Certificate Status Protocol (OCSP) responder cried out in pain, dropping to its knees, begging for mercy as load increased beyond what it could handle. The OCSP responder slowing down, being a critical aspect of a modern public key infrastructure (PKI), makes it hard for clients of the PKI to verify the validity of identity documents. These documents, called X.509 Certificates, are attached to every verified application the user is launching on their Mac. Mayhem ensued, and after the issues were cleaned up, many questions remained about the implications of this failure. But first, let&#39;s take a look at the mechanisms involved in authenticating an application package, at the most fundamental level.</p><p>2020年11月12日，苹果发布MacOS Big Sur。在发布后的几个小时里，在苹果基础设施的某个地方，一个在线证书状态协议(OCSP)的响应者痛苦地喊叫着，跪在地上，乞求宽恕，因为负荷增加到了它无法承受的地步。OCSP响应器的速度变慢是现代公钥基础设施(PKI)的一个重要方面，这使得PKI的客户很难验证身份证件的有效性。这些被称为X.509证书的文档被附加到用户在Mac上启动的每个经过验证的应用程序上。混乱随之而来，在问题被清理后，关于这一失败的影响仍然存在许多问题。但首先，让我们看看在最基本的层面上认证应用程序包所涉及的机制。</p><p>  The X.509 is a ratified ITU specification that defines (among other things) a standard representation for documents that convey trust relationships between entities, known as Certificates. Certificates can be thought of as policy documents. Any X.509 certificate consists of</p><p>X.509是经批准的ITU规范，它定义了传递实体之间信任关系(称为证书)的文档的标准表示形式(以及其他内容)。证书可以被认为是策略文档。任何X.509证书都包含。</p><p> metadata about how to check if the certificate has been revoked (optional, but highly recommended),</p><p>有关如何检查证书是否已被吊销的元数据(可选，但强烈建议)，</p><p> By retrieving the authority certificate, one can verify the integrity of the issued certificate. In fact, most authority certificates were issued by an even higher authority. By verifying all the way up to the root entity certificate (the &#34;self-signed&#34; highest level authority), it is possible to get a high degree of confidence of the provenance of the end entity certificate. Oftentimes a certain set of policy requirements must be met for an authority to issue a certificate to an end entity, or any intermediate entity. A certificate can be viewed as an embodiment of the proof that the authorities involved performed the appropriate checks to make sure all these conditions were met. If you fail these checks, an authority should not issue you a certificate!</p><p>通过检索授权证书，可以验证颁发的证书的完整性。事实上，大多数权威证书都是由更高级别的机构颁发的。通过一直验证到根实体证书(自签名的最高级别权威机构)，可以高度信任最终实体证书的出处。通常，授权机构向终端实体或任何中间实体颁发证书时，必须满足一组特定的策略要求。证书可以被视为有关当局进行了适当检查以确保满足所有这些条件的证明的具体体现。如果你没有通过这些检查，权威机构就不应该给你颁发证书！</p><p> The ceremony of creating these documents, how to interpret the document, how to represent the hierarchy of business trust decisions are all encoded in a certificate chain. Certificate chains are powerful concepts: they can be used to verify an authority who generated a public key, and who verified it was done to a certain standard. By reducing the scope of public keys to only keys you trust by specifying only certain root authorities you will accept certificate chains originating from, you can make a policy to reject any public keys (and thus any certificates) that were issued by a different authority.</p><p>创建这些文档的仪式、如何解释文档、如何表示业务信任决策的层次结构都编码在证书链中。证书链是强大的概念：它们可用于验证生成公钥的机构，以及验证其是否符合特定标准的机构。通过将公钥的范围缩小到只信任您信任的密钥(只指定您将接受源自的某些根授权机构)，您可以制定一项策略，拒绝由其他授权机构颁发的任何公钥(以及任何证书)。</p><p>  But what if, after the date the certificate is issued and before the date the certificate expires, something goes wrong. Maybe the authority decides that the entity the certificate was issued to has committed some malfeasance, and revokes their certificate. Sometimes the private key for a certificate is stolen, and so the assertions about who the party is that the certificate represents are no longer true, since an entity with the stolen key could impersonate the legitimate original party. There are numerous reasons why a certificate could be revoked.</p><p>但是，如果在证书颁发日期之后、证书过期日期之前出现问题，该怎么办？也许当局认为颁发证书的实体犯了一些不法行为，并吊销了他们的证书。有时证书的私钥会被窃取，因此证书所代表的关于该方是谁的断言不再正确，因为具有被盗密钥的实体可能会冒充合法的原始方。证书可能被吊销的原因有很多。</p><p> One of the fantastic design attributes of X.509 is the fact that you should be able to perform X.509 certificate chain validation offline. So long as you have an accurate idea of what the current date is and what root entities you trust, it&#39;s (relatively) easy for a party to verify a certificate chain. The offline verification confers a great deal of resilience upon the system, which is fantastic. But this revocation problem remains a challenge - you need to be able to check back with the authority who issued the certificate and ask &#34;hey, is this assertion you made still valid?&#34;</p><p>X.509奇妙的设计属性之一是您应该能够离线执行X.509证书链验证。只要你对当前日期和你信任的根实体有一个准确的概念，一方就可以(相对)容易地验证证书链。离线验证给系统带来了极大的弹性，这是非常棒的。但这个吊销问题仍然是一个挑战--你需要能够向颁发证书的权威机构核实，并询问一下，嘿，你的断言仍然有效吗？</p><p> To solve this problem, there are three common mechanisms in use today. First, most authorities publish certificate revocation lists (CRLs). This list, signed by the issuing authority, can be periodically downloaded from a location specified in the certificate&#39;s metadata (say on a daily basis). When performing certificate validation, the locally downloaded copy of the CRL will provide a indication if a certificate has been revoked. These CRLs can get quite large though, and having to wait for the CRL to be refreshed for a revocation to take effect could be risky for certain applications. CRLs work for certain use cases, but the storage and update frequency trade-offs are significant.</p><p>为了解决这个问题，目前有三种常见的机制在使用。首先，大多数机构发布证书吊销列表(CRL)。该列表由颁发机构签署，可以从证书元数据中指定的位置(例如每天)定期下载。在执行证书验证时，本地下载的CRL副本将提供证书是否已被吊销的指示。不过，这些CRL可能会变得相当大，并且必须等待CRL刷新才能使吊销生效，这对某些应用程序来说可能是有风险的。CRL适用于某些用例，但存储和更新频率的权衡非常重要。</p><p> Enter OCSP. When an authority offers an OCSP responder, the URL for the responder is also encoded in the certificate. A certificate verifier can make a call to the OCSP responder, with the serial number of the certificate to be verified. The OCSP responder checks against its database of revoked certificates. The OCSP responder will then respond with a simple &#34;valid&#34; or &#34;revoked&#34; to the query, and the calling party can then decide what to do with that information. Of course, this means that the OCSP responder can log each and every one of these queries, and build a very useful paper trail to help monitor user behaviour. This risk, along with the systemic resiliency challenges, led to a search for a middle ground.</p><p>输入OCSP。当授权机构提供OCSP响应器时，该响应器的URL也会编码到证书中。证书验证者可以使用要验证的证书的序列号呼叫OCSP响应者。OCSP响应器对照其吊销证书数据库进行检查。然后，OCSP应答器将用一个简单的、有效的或已撤销的信息来响应该查询，然后呼叫方可以决定如何处理该信息。？当然，这意味着OCSP响应者可以记录每一个查询，并建立一个非常有用的书面记录来帮助监控用户行为。这种风险，加上系统性的弹性挑战，促使人们寻找中间立场。</p><p> The final mode is a variant on calling the OCSP responder. An OCSP responder can issue a short-lived, cryptographically signed document to a certificate holder. This document is &#34;stapled&#34; together with the certificate, and is sent to to the verifying party. So long as the time stamps match up, the recipient can assume (within some bounded risk) that the certificate is still valid, per the issuing authority. Of course, this approach only works for certain use cases (usually connectivity-oriented usage), but it does anonymize the certificate verifying parties.</p><p>最后一种模式是调用OCSP应答器的变体。OCSP响应者可以向证书持有者发布使用密码签名的短期文档。这份文件与证书一起被装订起来，并被发送给验证方。只要时间戳匹配，根据颁发机构，接收者就可以假定(在一定的风险范围内)证书仍然有效。当然，这种方法只适用于某些用例(通常是面向连接的用法)，但它确实将证书验证方匿名。</p><p> Apple chose the second revocation model for app certificate verification. This mode has its benefits - revocation can be performed in real-time. So, if Apple finds that an app they issued a certificate to is actually malware, they can rapidly revoke this certificate and prevent the malware from running, even on machines it has already installed itself on. This does put a lot of policy control in Apple&#39;s hands. This is where you have to make a business decision as to whether or not you trust Apple to be benevolent or not.</p><p>苹果选择了第二种吊销模式进行APP证书验证。这种模式有它的好处--撤销可以实时执行。因此，如果苹果发现他们颁发证书的应用程序实际上是恶意软件，他们可以迅速撤销该证书，并阻止恶意软件运行，即使是在它已经安装了自己的机器上也是如此。这确实将大量政策控制权交到了苹果手中。这是你必须做出商业决定的地方，你是否相信苹果是仁慈的。</p><p>  A signed application is an interesting corner case in certificate validation. Certificates are valid for a certain range of dates. Additionally, applications don&#39;t involve (at least at launch time) any sort of exchange between a server and a client that can perform an OCSP lookup on your behalf. This limits the options we have.</p><p>签名的应用程序是证书验证中一个有趣的角落案例。证书在一定日期范围内有效。此外，应用程序不涉及(至少在启动时)可以代表您执行OCSP查找的服务器和客户端之间的任何类型的交换。这限制了我们的选择。</p><p> The first problem is more nuanced than one might think. Should an application, signed a specific point in time, be only launchable between the validity start/end dates of the certificate issued to sign the application? Probably not - this puts an artificial horizon on the application being valid, and if this is an app you paid a lot of money for, this might be frustrating. Implementation details might vary, but there is a concept of a trusted timestamp server, where a timestamp with a nonce is signed by a trusted authority. By integrating a trusted timestamp into the bundle of attributes cryptographically verified by the application launcher, we can reduce this problem to only needing to verify the app signing certificate was valid  at the time the bundle was signed. So the current calendar date is irrelevant for determining this validity, but rather the date that has been bundled into the signed app is to be used.</p><p>第一个问题比人们想象的要微妙得多。签署了特定时间点的应用程序是否只能在为签署该应用程序而签发的证书的有效期开始/结束日期之间启动？可能不是--这给应用程序设置了一个有效的人工视界，如果这是一个你花了很多钱买的应用程序，这可能会令人沮丧。实现细节可能会有所不同，但存在可信时间戳服务器的概念，在该服务器中，带有现时值的时间戳由可信机构签名。通过将可信的时间戳集成到由应用程序启动器加密验证的属性包中，我们可以将这个问题减少到只需要验证应用程序签名证书在包签名时是有效的。因此，当前日历日期与确定有效性无关，而是要使用已绑定到签名应用程序中的日期。</p><p> The second problem limits your options for handling revocation. A CRL might be useful in a subset of cases - for example if large swaths of certificates are to be revoked. However, there are some concerns with this approach, beyond scalability and size of these revocation lists. One operational concern is that you could be leaking information about which certificates have been revoked, or providing insight into the revocation process. This could be exploited by malfeasant actors to game the certificate issuing process, or at least make it more obvious which certificates have been revoked and when, so malware developers could get more insight into the process, giving them an edge in &#34;gaming the system.&#34;</p><p>第二个问题限制了您处理吊销的选择。CRL在某些情况下可能很有用-例如，如果要吊销大量证书。然而，除了这些撤销列表的可伸缩性和大小之外，这种方法还存在一些问题。操作上的一个顾虑是，您可能会泄露有关哪些证书已被吊销的信息，或者提供有关吊销过程的详细信息。不法分子可能会利用这一点来玩弄证书颁发过程，或者至少让人们更清楚地知道哪些证书已经被吊销，以及何时被吊销，这样恶意软件开发者就可以更深入地了解这一过程，让他们在玩弄系统时占据优势。</p><p> Apple opted to solve this problem with an OCSP responder. So at every launch of an app (perhaps outside of some window where the OCSP response could be cached - I have not looked into this detail), macOS would dutifully check if the certificate used by the signer is still valid, per the OCSP responder. Of course, if macOS couldn&#39;t reach the OCSP responder, it would go about its merry way launching an app. After all, a computer needs to work offline, too.</p><p>苹果选择用OCSP响应器来解决这个问题。因此，每次启动应用程序时(可能是在某个可以缓存OCSP响应的窗口之外--我还没有查看这一细节)，MacOS会按照OCSP响应者的要求，尽职尽责地检查签名者使用的证书是否仍然有效。当然，如果MacOS不能联系到OCSP响应者，它就会顺其自然地推出一款应用程序。毕竟，计算机也需要离线工作。</p><p>  An OCSP responder certainly could generate logs, as we discussed before. Those logs could contain the serial numbers of certificates that users had requested be checked, as well as the IP address of the requestor. Apple certainly has a database that maps a serial number back to the actual X.509 certificate, which then can likely be used to identify what app(s) this certificate was used to sign. The metadata about the request could likely be mapped back to who you are (through the power of AppleID, perhaps), the and the attributes of the certificate could be tied to your app store purchases (or lack thereof). Theoretically, this could be used to clamp down on piracy, private software distribution and other free use of a device.</p><p>正如我们之前讨论的，OCSP响应器当然可以生成日志。这些日志可能包含用户要求检查的证书的序列号，以及请求者的IP地址。苹果当然有一个数据库，可以将序列号映射回实际的X.509证书，然后它很可能被用来识别这个证书被用来签名的应用程序。关于申请的元数据可能会被映射回你是谁(也许是通过AppleID的力量)，证书的属性可能与你的应用商店购买(或缺乏)绑定在一起。从理论上讲，这可以用来打击盗版、私人软件发行</p><p> But here is where we have to consider the user. I&#39;m knee-deep in systems security problems, day-in and day-out. But all these systems we interact with have become more complex than I can maintain a complete mental picture of what is going on. Malware is hiding in more places than I have creative brain cells to think of, and every executable package I run makes me wonder who I might be handing the keys to the kingdom over to, especially if there&#39;s no way to tie the package back to the original developer who built it. App signing is actually a very good thing, in my opinion. If anything, it gives me the confidence that the package wasn&#39;t tampered with between when the developer built it and when I installed it.</p><p>但这里是我们必须考虑用户的地方。我日复一日地深陷系统安全问题的泥潭中。但是，我们与之互动的所有这些系统都变得更加复杂，我无法对正在发生的事情保持一个完整的心理图景。恶意软件隐藏在比我能想到的创造性脑细胞更多的地方，我运行的每个可执行程序包都让我想知道我可能会把王国的钥匙交给谁，特别是如果没有办法将这个包与构建它的原始开发者联系起来的话。在我看来，应用程序签名实际上是一件非常好的事情。如果说有什么不同的话，那就是它让我相信，在开发人员构建它的时候和我安装它的时候，这个包没有被篡改。</p><p> I always advocate against opt-in security features like this, and if there is an opt-out to make opting out unpleasant for the user. Why? Because most users are not capable of evaluating the impact of opting out of a security process. A blanket switch that says &#34;Disable All Code Signing Checks&#34; is hard for many users to understand the implications of. And once that switch is set, how does a user (who has a hard enough time with remembering a password) remember that this setting has been changed? How does a user know the difference between a system that has controls enabled, versus one that has no controls enabled? How does a user even evaluate the difference between such states for their system?</p><p>我一直反对像这样的选入安全特性，如果有选择退出会让用户不愉快。为什么？因为大多数用户无法评估选择退出安全流程的影响。一个全面的开关上写着禁用所有代码签名检查，这对许多用户来说是很难理解的含义。一旦设置了该开关，用户(很难记住密码)如何记住该设置已被更改？用户如何知道启用了控件的系统和没有启用控件的系统之间的区别？用户如何评估他们系统的这些状态之间的差异呢？</p><p> Google took an interesting approach to this with the boot process for the Pixelbook. When you enabled booting signed images from sources other than Google, a very annoying pop-up at boot time (complete with sound effects, if memory serves) would remind you that you were booting untrusted code. This works for developers, but most users would be confused about what the implications of this message are, and searing the web for answers about it would mostly result in people answering that you should ignore the message altogether. Not good.</p><p>谷歌在Pixelbook的引导过程中采取了一种有趣的方式。当您启用从Google以外的来源引导签名图像时，引导时会弹出一个非常恼人的弹出窗口(如果内存正常的话，还带有声音效果)，它会提醒您正在引导不受信任的代码。这对开发人员来说很管用，但大多数用户会对这条消息的含义感到困惑，在网上搜索有关这条消息的答案大多会导致人们回答说，你应该完全忽略这条消息。不太好。</p><p> One might argue Apple has catered to the lowest common denominator in this case. There&#39;s some truth to this - you don&#39;t want to start a war against your users and assume they&#39;re stupid. But if people who are &#34;information security professionals&#34; can&#39;t even tell you what the implications of various controls truly are (due to the vast complexity of these systems), how could your average user make these decisions?</p><p>有人可能会说，苹果在这件事上迎合了最低公分母。这是有一定道理的--你不会想要对你的用户发动一场战争，然后认为他们是愚蠢的。但是，如果身为信息安全专业人士的人甚至不能告诉你各种控制措施的真正含义(鉴于这些系统的巨大复杂性)，普通用户怎么能做出这些决定呢？</p><p> Finally, there&#39;s the open source argument - if I have the code, build the code, nothing can hide in the code. This is a  fallacy that people buy in to thanks to effective marketing by the open source community. Software systems are so complex today that subtle issues lurk in even the most carefully curated code bases. Would a Chrome build that you built yourself and are running be inherently more secure or less likely to be compromised than one you downloaded from Google that was co-signed by Apple? Definitely not (I&#39;d argue the other direction, in fact, but that is not germane to this conversation), but the Chrome build co-signed by Apple could be revoked if there turns out to be some malware embedded in the package. This is an interesting control that benefits users massively.</p><p>最后，还有一个开放源码的论点--如果我有代码，构建代码，代码中就没有什么可以隐藏的。多亏了开源社区的有效营销，人们才相信了这一谬论。当今的软件系统是如此复杂，即使是最精心策划的代码库也潜伏着微妙的问题。你自己构建并运行的Chrome版本会不会比你从谷歌(Google)下载并由苹果(Apple)共同签名的Chrome版本在本质上更安全，或者更不可能受到攻击？当然不会(事实上，我会从另一个角度出发，但这与我们的谈话没有关系)，但如果包中嵌入了一些恶意软件，由苹果(Apple)联名签署的Chrome版本可能会被撤销(译者注：原文为“Chrome Build”，原文为“Chrome”，原文为“Chrome”，原文为“Chrome”)。这是一个有趣的控件，让用户受益匪浅。</p><p>  The privacy squad mobilised on this one - in fact, one blog post recieved a lot of attention for decrying such systems with the dogwhistle &#34;you no longer own your computer!&#34; Some took a look at the Epic Megagames situation, where Fortnite has been pulled from the App Store on iOS (and Android) as evidence of the abuse potential that these systems enable. And honestly, their points are valid - in a narrow universe of discourse.</p><p>隐私保护小组在这件事上动员起来--事实上，有一篇博文因为用狗哨来谴责这类系统而引起了很多关注！一些人关注了史诗巨人游戏的情况，堡垒之夜已经被从iOS(和安卓)上的App Store下架，作为这些系统可能导致的滥用的证据。老实说，他们的观点是有道理的--在狭隘的话语世界里。</p><p> It comes down to an argument of trust - do you trust Apple is acting in your best interests, or do you believe they&#39;re a malevolent entity? It&#39;s not feasible for an individual to maintain the list of trustworthy or untrustworthy parties that Apple does. Nor are most users capable of running a security program that monitors for malicious apps. This is the classic antivirus situation - the only reason legacy antivirus was of any value was because someone, somewhere, had to experience a virus first, and then report it to the antivirus vendor, who then would produce a signature. But replicating that on your own is infeasible, you need the crowdsourcing and the broad network to get these reports in early to respond.</p><p>归根结底，这是一个信任的争论--你相信苹果的行为符合你的最大利益，还是你认为他们是一个恶毒的实体？对个人来说，像苹果那样维护值得信赖或不值得信赖的人的名单是不可行的。大多数用户也不能运行监控恶意应用程序的安全程序。这是典型的防病毒情况--传统防病毒之所以有任何价值，唯一的原因是某个地方的某个人必须先体验到病毒，然后将其报告给防病毒供应商，然后由防病毒供应商提供签名。但仅靠你自己复制这一点是不可行的，你需要众包和广泛的网络来及早得到这些报告的回应。</p><p> Perhaps more transparency would help ease peoples&#39; concerns around misuse of their data. Having an auditable third-party run the OCSP responders for app certificate checks would assuage peoples&#39; concerns that Apple is misusing this data. There are probably a few tweaks Apple could make to improve transparency without easing up on the platform security model they offer.</p><p>或许更多的透明度将有助于缓解人们对滥用数据的担忧。让一个可审计的第三方运行OCSP响应器来进行应用程序证书检查，将缓解人们对苹果滥用这些数据的担忧。苹果可能会在不放松其提供的平台安全模型的情况下，做出一些微调来提高透明度。</p><p>  In the aftermath of the OCSP responder outage, the dust settling after the macOS Big Sur release, there are a lot of folks reasonably asking if they can trust Apple to be in the loop of deciding what apps should or should not run on their Macs. My argument is - who better than Apple?</p><p>在OCSP响应器中断，MacOS Big Sur发布后尘埃落定之后，有很多人合理地询问，他们是否可以相信苹果会参与决定哪些应用程序应该在Mac电脑上运行，哪些应用程序不应该在Mac电脑上运行。我的观点是--还有谁比苹果更好呢？</p><p> Ditto for Microsoft - Windows has made amazing strides, bounding past controls afforded by other OSes, providing a great deal of simplicity for users while focusing on verifying who compiled code that is running on a user&#39;s PC. Trust in this process is critical (hence why the Stuxnet driver signing certificate private key theft was such a huge blow), and ultimately is a business (personal) decision.</p><p>微软同上-Windows已经取得了惊人的进步，超越了其他操作系统提供的控制，为用户提供了极大的简单性，同时专注于验证谁编译了在用户PC上运行的代码。对这个过程的信任是至关重要的(这就是为什么Stuxnet驱动程序签署证书私钥被盗是一个巨大的打击)，最终是一个商业(个人)决定。</p><p> While I&#39;m going to sound like an Apple apologist, I think the privacy arguments are far-fetched. Even if we took them to their extreme conclusion and Apple allowed users to disable all the controls they provide, we would cause more harm than good. There is certainly an opportunity for Apple to abuse the data they have access to (and oh boy do they have a lot of data on their users), but then again I think about the data that companies like Reddit, Facebook, Google and PornHub have on the average user and ask myself who has the most power to compromise a person&#39;s life?</p><p>虽然我的话听起来像是苹果的辩护者，但我认为有关隐私的争论有些牵强。即使我们让他们得出极端的结论，苹果允许用户禁用他们提供的所有控制，我们也只会带来更多的伤害而不是好处。苹果当然有机会滥用他们获得的数据(哦，天哪，他们有很多关于用户的数据吗)，但我又一次想到了Reddit、Facebook、谷歌和PornHub等公司的平均用户数据，我问自己，谁最有权危及一个人的生活？</p><p> Reddit knows what you&#39;re searching for, what subreddit forums you visit, even in that incognito window. I&#39;m also sure that PornHub has every single query made on their search indexed by IP address and date... and if you think it&#39;s hard to map back to a particular human being, I&#39;ve got bad news for you, Steve from Long Island.</p><p>Reddit知道你在搜索什么，你访问了哪些子Reddit论坛，甚至在那个隐姓埋名的窗口中也是如此。我还确信，PornHub会按IP地址和日期对搜索中的每一个查询进行索引。如果你认为这很难追溯到某个特定的人身上，我有个坏消息要告诉你，来自长岛的史蒂夫。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.security-embedded.com/blog/2020/11/14/application-trust-is-hard-but-apple-does-it-well">https://www.security-embedded.com/blog/2020/11/14/application-trust-is-hard-but-apple-does-it-well</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034859.html"><img src="http://img2.diglog.com/img/2020/11/thumb_7fc439c0a733cb49345c40716da2f257.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034859.html">参议员艾米·克洛布查尔(Amy Klobuchar)可能成为拜登的AG人选，他表示，谷歌的“分手补救措施”应该“摆在桌面上”，并赞扬了美国司法部对谷歌的反垄断诉讼</a></div><span class="my_story_list_date">2020-11-13 19:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034848.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d533402dbd67ee0830f92bcdae337ba3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034848.html">IOS 14.3测试版代码表明，苹果可能会在iPhone或iPad安装过程中向用户推荐第三方应用，这可能会平息反垄断担忧</a></div><span class="my_story_list_date">2020-11-13 19:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034793.html"><img src="http://img2.diglog.com/img/2020/11/thumb_88fd6ddb8253d4481c2e73bf9c8b9c36.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034793.html">在锈迹斑斑的情况下编写过多的Brainfuck编译器来学习汇编语言</a></div><span class="my_story_list_date">2020-11-13 0:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034785.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ee8fa1e28b89f8f9ef8af0a5d8b5704a.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034785.html">一群谷歌批评者呼吁欧盟采取反垄断行动</a></div><span class="my_story_list_date">2020-11-12 23:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>