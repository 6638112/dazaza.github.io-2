<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在单台服务器上实现100Gbps入侵防御</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在单台服务器上实现100Gbps入侵防御</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 14:32:27</div><div class="page_narrow text-break page_content"><p>Papers-we-love is hosting a  mini-event this Wednesday (18th) where I’ll be leading a panel discussion including one of the authors of today’s paper choice: Justine Sherry. Please do join us if you can.</p><p>Papers-We-Love将在本周三(18日)举办一个小型活动，我将在会上主持一个小组讨论，其中包括今天报纸选择的作者之一：贾斯汀·雪莉(Justine Sherry)。如果可以的话，请一定要加入我们。</p><p> We always want more! This stems from a combination of  Jevon’s paradox and the interconnectedness of systems – doing more in one area often leads to a need for more elsewhere too. At the end of the day, there are three basic ways we can increase capacity:</p><p>我们总是想要更多！这源于杰文悖论和系统的互联性的结合--在一个领域做得更多，往往也会导致对其他领域做更多事情的需求。归根结底，我们可以通过三种基本方式来提高运力：</p><p> Improving the efficiency with which we can coordinate work across a collection of units (see the  Universal Scalability Law)</p><p>提高我们在一组单元之间协调工作的效率(参见通用可伸缩性法则)。</p><p> Options 1 and 2 are of course the ‘scale out’ options, whereas option 3 is ‘scale up’. With more nodes and more coordination comes more complexity, both in design and operation. So while scale out has seen the majority of attention in the cloud era, it’s good to remind ourselves periodically just what we really can do on a  single box or even a  single thread.</p><p>选项1和2当然是“横向扩展”选项，而选项3是“向上扩展”。随着更多的节点和更多的协调，设计和操作都变得更加复杂。因此，虽然在云时代，向外扩展受到了大部分关注，但定期提醒自己，我们在一个盒子甚至一个线程上真正能做些什么是很好的。</p><p> Today’s paper choice is a wonderful example of pushing the state of the art on a single server. We’ve been surrounding CPUs with accelerators for a long time, but at the heart of  Pigasus‘ design is a really interesting inversion of control – the CPU isn’t coordinating and calling out to the accelerator, instead the FGPA is in charge, and the CPU is playing the support role.</p><p>今天的论文选择是在一台服务器上推动最先进技术的一个很好的例子。我们用加速器包围CPU已经有很长时间了，但Pigasus设计的核心是一个非常有趣的控制反转-CPU不是协调和呼唤加速器，而是由FGPA负责，CPU扮演支持角色。</p><p>  Pigasus is an Intrusion Detection / Prevention System (IDS/IPS). An IDS/IPS monitors network flows and matches incoming packets (or more strictly, Protocol Data Units, PDUs) against a set of rules. There can be tens of thousands of these rules, which are called  signatures. A signature in turn is comprised of one or more patterns matching against either the header or the packet content, including both exact string matches and regular expressions. Patterns may span multiple packets. So before matching, the IDS/IPS has to reconstruct a TCP bytestream in the face of packet fragmentation, loss, and out-of-order delivery – a process known as  reassembly.</p><p>Pigasus是一种入侵检测/防御系统(IDS/IPS)。IDS/IPS监控网络流量，并将传入的数据包(或者更严格地说，协议数据单元，PDU)与一组规则进行匹配。可能有数以万计的这样的规则，它们被称为签名。签名又由一个或多个模式组成，这些模式与报头或数据包内容匹配，包括精确的字符串匹配和正则表达式。模式可以跨越多个分组。因此，在匹配之前，面对数据包碎片、丢失和无序传输，IDS/IPS必须重建TCP字节流-这一过程称为重组。</p><p> When used in prevention mode (IPS), this all has to happen inline over incoming traffic to block any traffic with suspicious signatures. This makes the whole system latency sensitive.</p><p>当在预防模式(IPS)下使用时，所有这些都必须发生在传入流量上，以阻止任何带有可疑签名的流量。这使得整个系统对延迟非常敏感。</p><p>  A recurring theme in IDS/IPS literature is the gap between the workloads they need to handle and the capabilities of existing hardware/software implementations. Today, we are faced with the need to build IDS/IPSes that support line rates on the order of 100Gbps with hundreds of thousands of concurrent flows and capable of matching packets against tens of thousands of rules.</p><p>IDS/IPS文献中反复出现的一个主题是它们需要处理的工作负载与现有硬件/软件实现的能力之间的差距。今天，我们面临着构建支持100Gbps数量级线速、数十万并发流并能够根据数万条规则匹配数据包的IDS/IPS的需求。</p><p>   One of the joys of this paper is that you don’t just get to see the final design, you also get insight into the forces and trade-offs that led to it. Can you  really do all this on a single server??</p><p>这篇文章的乐趣之一是，你不仅可以看到最终的设计，还可以洞察导致它的力量和权衡。你真的可以在一台服务器上完成所有这些任务吗？</p><p> The traditional approach to integrating FPGAs in IDS/IPS processing is to have the CPU in charge, and offload specific tasks, such as regular expression parsing, to the FPGA. The baseline for comparison is  Snort 3.0, “the most powerful IPS in the world” according to the Snort website. In particular, Pigasus is designed to be compatible with Snort rulesets and evaluated using the Snort Registered Ruleset (about 10K signatures). The biggest fraction of CPU time in Snort is spent in the Multi-String Pattern Matcher (MSPM) module, which is used for header and partial string matching.</p><p>在IDS/IPS处理中集成FPGA的传统方法是让CPU负责，并将特定任务(如正则表达式解析)卸载到FPGA。比较的基准是Snort 3.0，根据Snort网站的说法，它是“世界上最强大的IPS”。特别是，Pigasus被设计为与Snort规则集兼容，并使用Snort注册规则集(大约10K签名)进行评估。Snort中CPU时间的最大部分花在多字符串模式匹配器(MSPM)模块上，该模块用于标题和部分字符串匹配。</p><p> Using Amdahl’s Law, we can see that even if MSPM were offloaded to an imaginary, infinitely fast accelerator, throughput would increase by only 85% to 600Mbps/core, still requiring 166 cores to reach 100Gpbs.</p><p>利用Amdahl定律，我们可以看到，即使将MSPM卸载到一个假想的、无限快的加速器上，吞吐量也只会增加85%，达到600 Mbps/核，仍然需要166个核才能达到100Gpbs。</p><p> In fact, whatever module of Snort you try to offload to a hypothetical infinitely fast accelerator, you can never get close to the performance targets of Pigasus. That fixes Pigasus’ first design decision: the FPGA needs to be in charge as the primary compute platform, and the CPU will be secondary in service of it. (FPGAs are chosen because they are both energy efficient and available on SmartNICs).</p><p>事实上，无论您尝试将Snort模块卸载到假设的无限快加速器上，都无法接近Pigasus的性能目标。这修正了Pigasus的第一个设计决策：FPGA需要作为主要的计算平台负责，而CPU将是次要的。(之所以选择现场可编程门阵列，是因为它们既节能又可在SmartNIC上使用)。</p><p> Having settled on an FPGA-first design, this means that  stateful packet processing for matching and reassembly needs to be performed on the FPGA. And that in turn means that the primary design constraint is the amount of FPGA memory available, especially Block RAM (BRAM). The target FPGA for Pigasus has 16MB of BRAM.</p><p>在确定了FPGA优先设计之后，这意味着需要在FPGA上执行匹配和重组的状态数据包处理。而这反过来又意味着主要的设计约束是可用的FPGA存储器的大小，尤其是块RAM(BRAM)。Pigasus的目标FPGA有16MB的BRAM。</p><p> Of concern here is the regular expression matching performed by the Full Matcher. Regular expression matching is well studied, but state of the art hardware algorithms don’t reach the performance and memory targets needed for Pigasus. Performing RE matching on the FPGA would consume a lot of memory, and offer only marginal overall performance gains since most packets don’t touch the full matcher. This brings us to another major design decision: regular expression matching will be offloaded from the FPGA to the CPU.</p><p>这里需要关注的是完全匹配器执行的正则表达式匹配。正则表达式匹配得到了很好的研究，但是最先进的硬件算法没有达到Pigasus所需的性能和内存目标。在FPGA上执行RE匹配会消耗大量内存，并且只会带来微乎其微的整体性能提升，因为大多数数据包都不会触及完全匹配器。这给我们带来了另一个重要的设计决策：正则表达式匹配将从FPGA转移到CPU。</p><p>  Putting together everything we’ve learned so far, the overall architecture of Pigasus looks like this:</p><p>综合我们到目前为止学到的所有知识，Pigasus的整体架构如下所示：</p><p>  The  reassembler is responsible for ordering TCP packets. It needs to do this at line rate while maintaining state for 100K flows.</p><p>重组器负责对TCP数据包进行排序。它需要在保持100K流量状态的同时以线速完成此操作。</p><p> The  multi-string pattern matcher (MSPM) does header matching for all 10,000 rules, and exact string-match filtering to determine which further rules might possibly match.</p><p>多字符串模式匹配器(MSPM)对所有10,000条规则进行标题匹配，并进行精确的字符串匹配筛选，以确定哪些规则可能匹配。</p><p> If the MSPM indicates a possible match, the packet and rule IDs are sent to the  DMA Engine, which farms work out to the CPU for full matching.</p><p>如果MSPM指示可能的匹配，则包和规则ID被发送到DMA引擎，该场计算出CPU以进行完全匹配。</p><p> The  Full Matcher runs on the CPU, polling a ring buffer populated by the DMA Engine.</p><p>Full Matcher在CPU上运行，轮询由DMA引擎填充的环形缓冲区。</p><p> To save the precious BRAM for the most performance sensitive tasks (reassembly and MSPM), the packet buffer and DMA Engine use the less powerful eSRAM and DRAM available on the FPGA.</p><p>为了节省宝贵的BRAM用于性能最敏感的任务(重组和MSPM)，数据包缓冲器和DMA引擎使用功能较弱的FPGA上可用的ESRAM和DRAM。</p><p> Both the reassembler and MSPM modules required careful design to meet their performance and memory targets.</p><p>重新组装器和MSPM模块都需要精心设计，以满足其性能和内存目标。</p><p>  The key objective of our Reassemble is to perform this re-ordering for 100K’s of flows, while operating at 100Gbps, within the memory limitations of the FPGA.</p><p>我们重新组装的关键目标是在FPGA的内存限制内，以100Gbps的速度对100K的流执行这种重新排序。</p><p> The FPGA hardware really wants to operate in a highly parallel mode using fixed size data structures. This works well until we consider out of order packet arrival. To accomodate out-of-order packets though, a memory dense structure such as a linked list works better.</p><p>FPGA硬件确实希望使用固定大小的数据结构在高度并行模式下运行。在我们考虑无序分组到达之前，这种方法工作得很好。不过，为了容纳无序的数据包，内存密集型结构(如链表)效果更好。</p><p> The solution is to divide the reassembly pipeline into a fast path handling in-order flows using fixed size buffers and constant time operations, and a slow path handling the remaining out of order flows. The constant time operations on the fast path guarantee a processing rate of 25 million packets-per-second, enough to reach the 100Gbps target at 500B+ packets. The slow path can’t take advantage of constant time operations, but fortunately is less often used as most packets arrive in order. It’s also used when inserting new flows.</p><p>解决方案是使用固定大小的缓冲区和恒定的时间操作将重组流水线划分为处理有序流的快速路径和处理剩余无序流的慢速路径。快速路径上的恒定时间操作保证了每秒2500万个数据包的处理速率，足以达到500B+数据包数的100Gbps目标。慢速路径不能利用恒定的时间操作，但幸运的是，由于大多数数据包按顺序到达，因此较少使用慢速路径。在插入新流时也会使用它。</p><p> The fast path, new flow insertion, and out-of-order processing all synchronise over shared flow state using a cuckoo-hashing based hash table design from FlowBlaze.</p><p>使用FlowBlaze基于布谷鸟散列的哈希表设计，快速路径、新的流插入和无序处理都可以在共享流状态上同步。</p><p>    To the best of our knowledge, there are no other hardware or software projects reporting multi-string matching of tens of thousands of strings at 100Gpbs.</p><p>据我们所知，目前还没有其他硬件或软件项目报告100Gpbs的数万个字符串的多字符串匹配。</p><p> Snort 3.0 uses Intel’s Hyperscan library for MSPM. The Hyperscan string matching library is parallelisable and provides an 8x speedup over software state-machine based string matchers. But a simple translation to FPGA would blow the memory budget, requiring about 25MB of BRAM.</p><p>Snort 3.0使用英特尔针对MSPM的Hyperscan库。Hyperscan字符串匹配库是可并行的，与基于软件状态机的字符串匹配器相比，它提供了8倍的加速。但简单地转换到FPGA会耗尽内存预算，需要大约25MB的BRAM。</p><p> By carefully staging the work, Pigasus manages to fit everything into just 2MB of BRAM. This means it even has capacity to do more work in the MSPM stage than Snort itself does, reducing the amount of packets that need to be passed to the full matcher.</p><p>通过精心安排工作，皮加索斯成功地将所有东西都装进了2MB的布拉姆(Bram)中。这意味着它甚至有能力在MSPM阶段做比Snort本身更多的工作，从而减少了需要传递给完全匹配器的数据包数量。</p><p> At the end of the day, a packet must match  all the patterns in a signature for the rule to be triggered. The key insight in Pigasus is that some tests can be done very cheaply in terms of time and memory, while others are more memory intensive. Put this together with the realisation that most packets and most indices don’t match any rules at all and a plan emerges: make a filtering pipeline that progressively narrows. At the start of the pipeline we can afford to run lots of memory-cheap filters in parallel. Only a subset of incoming packets make it past these filters, so we need less of the more memory intensive filters running in parallel behind them to achieve the desired line rate.</p><p>最后，数据包必须与签名中的所有模式匹配才能触发规则。Pigasus的关键洞察力是，一些测试在时间和内存方面可以非常便宜地完成，而另一些测试则需要更多的内存。再加上大多数信息包和大多数索引根本不符合任何规则的认识，一个计划就出现了：建立一个逐渐缩小的过滤管道。在流水线开始时，我们可以并行运行大量内存廉价的过滤器。只有一小部分传入数据包可以通过这些过滤器，因此我们不需要在它们后面并行运行更多内存密集型过滤器来达到所需的线速。</p><p> Applying this filter first allows us to use fewer replicas of subsequent data structures (which are larger and more expensive), since most bytestream indices have already been filtered out by the string matcher. This enables high (effective) parallelism with a lower memory overhead.</p><p>首先应用这个过滤器允许我们使用更少的后续数据结构的副本(更大、更昂贵)，因为大多数字节流索引已经被字符串匹配器过滤掉了。这实现了高(有效)并行性和较低的内存开销。</p><p> This strategy is so effective that whereas Snort passes a packet to the full matcher if any filter matches, Pigasus is able to test for all string matches and further reduce the fraction of packets that head to the CPU for full-matching to just 5%. This testing is performed in parallel using a bloom-filter like representation, see §5.2 in the paper for details.</p><p>这种策略非常有效，Snort在任何过滤器匹配的情况下都会将数据包传递给完全匹配器，而Pigasus能够测试所有字符串匹配，并进一步将流向CPU进行完全匹配的数据包比例降低到只有5%。此测试使用类似Bloom Filter的表示法并行执行，有关详细信息，请参阅白皮书中的§5.2。</p><p>   Our experiments with a variety of traces show that Pigasus can support 100Gbps using an average of 5 cores and 1 FPGA, using 38x less power than a CPU-only approach.</p><p>我们对各种轨迹进行的实验表明，Pigasus平均使用5个内核和1个FPGA就可以支持100Gbps，功耗比仅使用CPU的方法低38倍。</p><p> There’s a full evaluation in §6 of the paper which I don’t have space to cover here. The headline is that Pigasus meets its design objectives using 23-200 fewer cores than Snort, and 18-62x less power!</p><p>这篇论文的第六节有一个完整的评估，我没有篇幅在这里讨论。标题是Pigasus达到了它的设计目标，使用的内核比Snort少23-200个，耗电量少18-62倍！</p><p> The design of Pigasus is a singular proof point that a seemingly unattainable goal (…) on a single server is well within our grasp… Given the future hardware roadmaps of FPGAs and SmartNICs, we believe that our insights and successes can more broadly inform in-network acceleration beyond IDS/IPS as well.</p><p>皮加索斯的设计是一个奇特的证据，证明了一个看似遥不可及的目标(…)。在一台服务器上运行，这完全在我们掌握的…范围内。鉴于FPGA和SmartNIC的未来硬件路线图，我们相信我们的洞察力和成功经验可以更广泛地指导超越IDS/IPS的网络内加速。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.acolyer.org/2020/11/16/pigasus/">https://blog.acolyer.org/2020/11/16/pigasus/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/入侵/">#入侵</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/intrusion/">#intrusion</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据包/">#数据包</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>