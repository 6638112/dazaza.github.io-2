<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>VSCode，Dev Containers和Docker：推进软件开发 VSCode, Dev Containers and Docker: moving software development forward</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">VSCode, Dev Containers and Docker: moving software development forward<br/>VSCode，Dev Containers和Docker：推进软件开发 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-21 23:29:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/b5604dd5edd99fc96f9c712220ea452e.png"><img src="http://img2.diglog.com/img/2021/1/b5604dd5edd99fc96f9c712220ea452e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Long term readers of this blog will know our devotion to using container-based technology, especially  Docker, to significantly improve software quality through repeatable builds.</p><p>本博客的长期读者将知道我们致力于使用基于容器的技术，尤其是Docker，通过可重复的构建来显着提高软件质量。</p><p> In the Autumn/fall of 2020, Microsoft introduced a Visual Studio Code (VSCode) extension  Remote – Containers. With one quick stroke, this extension allows you to open a VSCode project within a Docker container.</p><p> 在2020年秋/秋季，Microsoft推出了Visual Studio Code（VSCode）扩展Remote – Containers。快速扩展，此扩展使您可以在Docker容器中打开VSCode项目。</p><p>  There are several different approaches to using Dev Containers. In this post, we shall cover three options:</p><p>  有多种使用开发容器的方法。在这篇文章中，我们将介绍三个选项：</p><p>     Anyone using or experimenting with  Test-Driven-Development in C will probably be aware of  Ceedling, unity and CMock.</p><p>     任何使用C进行测试驱动开发或在其中进行实验的人都可能会意识到Ceedling，团结和CMock。</p><p> Whether or not you have Ceedling, or any dependents, such as Ruby, installed we can begin using Dev Container with an existing Dockerhub container image. Containerisation ensures we can quickly get up and running with Ceedling in a known environment. In true ‘ Blue Peter‘ style, we happen to have a pre-built Ceedling based Docker image on  Docker Hub.</p><p> 无论您是否安装了Ceedling或任何依赖项（例如Ruby），我们都可以将Dev Container与现有Dockerhub容器映像一起使用。容器化确保我们可以在已知环境中使用Ceedling迅速启动并运行。在真正的“ Blue Peter”风格中，我们恰巧在Docker Hub上有一个基于Ceedling的预先构建的Docker映像。</p><p>           VScode will detect the Dev Container configuration file and ask if you want to reopen the folder in a container. Click  Reopen in Container.</p><p>           VScode将检测“开发容器”配置文件，并询问您是否要重新打开容器中的文件夹。单击在容器中重新打开。</p><p> Open a terminal window within VSCode, and you will be presented with a shell prompt  #. We are now running within a Docker container based on the image  feabhas/ceedling.</p><p> 在VSCode中打开一个终端窗口，您将看到一个shell提示符＃。我们现在正在基于映像feabhas / ceedling的Docker容器中运行。 </p><p> # ceedling new test_projectWelcome to Ceedling! create test_project/project.ymlProject &#39;test_project&#39; created! - Execute &#39;ceedling help&#39; from test_project to view available test &amp; build tasks# cd test_project# ceedling module:create[widget]File src/widget.c createdFile src/widget.h createdFile test/test_widget.c createdGenerate Complete# ceedling testTest &#39;test_widget.c&#39;--------------------Generating runner for test_widget.c...Compiling test_widget_runner.c...Compiling test_widget.c...Compiling unity.c...Compiling widget.c...Compiling cmock.c...Linking test_widget.out...Running test_widget.out...--------------------IGNORED TEST SUMMARY--------------------[test_widget.c] Test: test_widget_NeedToImplement At line (15): &#34;Need to Implement widget&#34;--------------------OVERALL TEST SUMMARY--------------------TESTED: 1PASSED: 0FAILED: 0IGNORED: 1</p><p>＃ceedling new test_project欢迎来到Ceedling！创建test_project / project.ymlProject＆＃39; test_project＆＃39;创建！ -执行“帮助帮助”从test_project查看可用的测试＆amp;构建任务＃cd test_project＃ceedling模块：create [widget]文件src / widget.c createdFile src / widget.h createdFile test / test_widget.c createdGenerate Complete＃ceedling testTest＆＃39; test_widget.c＆＃39; ---- ----------------为test_widget.c生成运行程序...正在编译test_widget_runner.c ...正在编译test_widget.c ...正在编译unity.c ...正在编译widget.c ...正在编译cmock.c ...链接test_widget.out ...正在运行test_widget.out ...--------------------忽略的测试摘要- ----------------- [test_widget.c]测试：test_widget_NeedToImplement在第（15）行：＆＃34;需要实现小部件＆＃34; -------- ------------总体测试摘要--------------------测试：1通过：0失败：0忽略：1</p><p>  After exiting VSCode, all files created will exist in your local file system. Reopening VSCode, you will once again be prompted to reopen in the container.</p><p>  退出VSCode后，所有创建的文件将存在于本地文件系统中。重新打开VSCode，将再次提示您在容器中重新打开。</p><p>          Next, you can select your preferred base Linux image – I have used the  ubuntu-20.04 base (it doesn’t matter for this example).</p><p>          接下来，您可以选择首选的基础Linux映像–我已经使用了ubuntu-20.04基础（此示例无关紧要）。</p><p> The default Microsoft C++ container image has many additional packages suitable for hosted C/C++ development already installed in the container, e.g. (at the time of writing)</p><p> 默认的Microsoft C ++容器映像具有许多其他软件包，适用于已安装在容器中的托管C / C ++开发，例如（在撰写本文时）</p><p>   Finally, we can build our ‘application’. In a VSCode terminal window, build the CMake project, e.g.:</p><p>   最后，我们可以构建“应用程序”。在VSCode终端窗口中，构建CMake项目，例如：</p><p> vscode ➜ /workspaces/ms-cpp $ mkdir build &amp;&amp; cd buildmkdir: created directory &#39;build&#39;/workspaces/ms-cpp/buildvscode ➜ /workspaces/ms-cpp/build $ cmake ..-- The C compiler identification is GNU 9.3.0-- The CXX compiler identification is GNU 9.3.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /workspaces/ms-cpp/buildvscode ➜ /workspaces/ms-cpp/build $ makeScanning dependencies of target App[ 50%] Building CXX object CMakeFiles/App.dir/main.cpp.o[100%] Linking CXX executable App[100%] Built target Appvscode ➜ /workspaces/ms-cpp/build $ ./App Hello from Dev Containers</p><p> vscode➜/ workspaces / ms-cpp $ mkdir build＆amp;＆amp; cd buildmkdir：创建目录＆＃39; / workspaces / ms-cpp / buildvscode➜/ workspaces / ms-cpp / build $ cmake ..-C编译器标识为GNU 9.3.0-CXX编译器标识为GNU 9.3.0-检查工作的C编译器：/ usr / bin / cc--检查工作的C编译器：/ usr / bin / cc-工作-检测C编译器ABI信息-检测C编译器ABI信息-完成-检测C编译功能-检测C编译功能-完成-检查工作的CXX编译器：/ usr / bin / c ++-检查工作的CXX编译器：/ usr / bin / c ++-工作-检测CXX编译器ABI信息-检测CXX编译器ABI信息-完成-检测CXX编译功能-检测CXX编译功能-完成-配置完成-生成完成-构建文件已写入到/ workspaces / ms- cpp / buildvscode➜/ workspaces / ms-cpp / build $ make扫描目标App的依赖项[50％]构建CXX对象CMakeFiles / App.dir / main.cpp.o [100％]链接CXX可执行App [100％]构建目标Appvscode➜/工作区s / ms-cpp / build $ ./Dev Containers的App Hello</p><p> So how does this all work? If you examine the project, you will see that a  .devcontainer folder is created along with two files:</p><p> 那么，这一切如何运作？如果检查项目，将看到创建了一个.devcontainer文件夹以及两个文件： </p><p>  The  devcontainer.json file references the  Dockerfile defining the core Microsoft C++ Docker image. If you know Docker, then the files are pretty intuitive. We shall build on these in the next example.</p><p>devcontainer.json文件引用了定义核心Microsoft C ++ Docker映像的Dockerfile。如果您了解Docker，则文件非常直观。在下一个示例中，我们将以此为基础。</p><p>  The default Microsoft image does not include the capabilities for using  Googletest, GoogleMock or an alternative build system, such as  the Meson Build system.</p><p>  默认的Microsoft映像不包括使用Googletest，GoogleMock或其他构建系统（例如Meson Build系统）的功能。</p><p> We could builder our own Docker image and store this on Dockerhub, as shown previously. However, depending on your container requirements’ complexity, it can be easier to build on the base Microsoft Dockerfile and add the required packages.</p><p> 我们可以构建自己的Docker映像并将其存储在Dockerhub上，如前所示。但是，根据您的容器要求的复杂性，可以更轻松地在基础Microsoft Dockerfile上构建并添加所需的软件包。</p><p>  Using the previous “hello world” project, we want to write a simple test using GoogleTest.</p><p>  使用上一个“ hello world”项目，我们想使用GoogleTest编写一个简单的测试。</p><p>  # [Optional] Uncomment this section to install additional packages.# RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \# &amp;&amp; apt-get -y install --no-install-recommends &lt;your-package-list-here&gt;</p><p>  ＃[可选]取消注释此部分以安装其他软件包。＃RUN apt-get update＆amp;＆amp;导出DEBIAN_FRONTEND =非交互式\＃＆amp;＆amp; apt-get -y install --no-install-recommends＆lt; your-package-list-here＆gt;</p><p>   And can be installed using the  apt package manager. As GoogleMock is dependent on GoogleTest, we only need to specify the package  libgmock-dev and  apt will also install  libgtest-dev. Uncomment and modify the lines in the Dockerfile to read:</p><p>   并且可以使用apt软件包管理器进行安装。由于GoogleMock依赖于GoogleTest，因此我们只需要指定软件包libgmock-dev，apt还将安装libgtest-dev。取消注释并修改Dockerfile中的行以读取：</p><p>  Reopen the workspace in a container (you may be prompted to rebuild the container – if so, then select the rebuild option). We can quickly test if GoogleTest is installed by creating a simple test file  test.cpp:</p><p>  重新打开容器中的工作空间（可能会提示您重新构建容器–如果是，则选择rebuild选项）。我们可以通过创建一个简单的测试文件test.cpp来快速测试是否已安装GoogleTest： </p><p>      vscode ➜ /workspaces/ms-cpp $ mkdir build &amp;&amp; cd buildmkdir: created directory &#39;build&#39;/workspaces/ms-cpp/buildvscode ➜ /workspaces/ms-cpp/build $ cmake .....-- Configuring done-- Generating done-- Build files have been written to: /workspaces/ms-CPP/build</p><p>vscode➜/ workspaces / ms-cpp $ mkdir build＆amp;＆amp; cd buildmkdir：创建目录＆＃39; build＆＃39; / workspaces / ms-cpp / buildvscode➜/ workspaces / ms-cpp / build $ cmake .....-配置完成-生成完成-构建文件具有写入到：/ workspaces / ms-CPP / build</p><p>  vscode ➜ /workspaces/ms-cpp/build $ make[ 50%] Building CXX object CMakeFiles/gtest_test.dir/test.cpp.o[100%] Linking CXX executable gtest_test[100%] Built target gtest_test</p><p>  vscode➜/ workspaces / ms-cpp / build $ make [50％]构建CXX对象CMakeFiles / gtest_test.dir / test.cpp.o [100％]链接CXX可执行文件gtest_test [100％]构建目标gtest_test</p><p>  vscode ➜ /workspaces/ms-cpp/build $ ctest -VUpdateCTestConfiguration from :/workspaces/ms-cpp/build/DartConfiguration.tclUpdateCTestConfiguration from :/workspaces/ms-cpp/build/DartConfiguration.tclTest project /workspaces/ms-cpp/buildConstructing a list of testsDone constructing a list of testsUpdating test list for fixturesAdded 0 tests to meet fixture requirementsChecking test dependency graph...Checking test dependency graph endtest 1 Start 1: FailingTest1: Test command: /workspaces/ms-cpp/build/gtest_test1: Test timeout computed to be: 100000001: Running main() from /build/googletest-j5yxiC/googletest-1.10.0/googletest/src/gtest_main.cc1: [==========] Running 1 test from 1 test suite.1: [----------] Global test environment set-up.1: [----------] 1 test from setup_test_case1: [ RUN ] setup_test_case.testWillFail1: /workspaces/ms-cpp/test.cpp:4: Failure1: Expected equality of these values:1: 421: 01: [ FAILED ] setup_test_case.testWillFail (0 ms)1: [----------] 1 test from setup_test_case (0 ms total)1: 1: [----------] Global test environment tear-down1: [==========] 1 test from 1 test suite ran. (0 ms total)1: [ PASSED ] 0 tests.1: [ FAILED ] 1 test, listed below:1: [ FAILED ] setup_test_case.testWillFail1: 1: 1 FAILED TEST1/1 Test #1: FailingTest ......................***Failed 0.01 sec0% tests passed, 1 tests failed out of 1Total Test time (real) = 0.04 secThe following tests FAILED: 1 - FailingTest (Failed)Errors while running CTest</p><p>  vscode➜/ workspaces / ms-cpp / build $ ctest -VUpdateCTestConfiguration来自：/workspaces/ms-cpp/build/DartConfiguration.tclUpdateCTestConfiguration来自：/workspaces/ms-cpp/build/DartConfiguration.tclTest项目/ workspaces / ms-cpp /构建构建测试列表完成构建测试列表更新夹具的测试列表☎0满足夹具要求的测试检查测试依赖图...检查测试依赖图endtest 1开始1：FailingTest1：测试命令：/ workspaces / ms-cpp / build / gtest_test1 ：测试超时计算为：100000001：从/build/googletest-j5yxiC/googletest-1.10.0/googletest/src/gtest_main.cc1运行main（）：[==========]正在运行1个测试来自1个测试套件。1：[----------]全局测试环境设置。1：[----------]来自setup_test_case1的1个测试：[RUN] setup_test_case。 testWillFail1：/workspaces/ms-cpp/test.cpp:4：Failure1：这些值的预期相等：1：421：01：[失败] setup_test_case.testWillFail（0 ms）1：[-------- -]来自setup_tes的1个测试t_case（总计0毫秒）1：1：[----------]全局测试环境拆解1：[==========]从1个测试套件中运行了1个测试。 （总计0毫秒）1：[通过] 0个测试。1：[失​​败] 1个测试，列出如下：1：[失败] setup_test_case.testWillFail1：1：1失败的TEST1 / 1测试＃1：FailingTest ..... ........ ***失败0.01秒0％测试通过，1个测试中有1个失败总测试时间（真实）= 0.04秒以下测试失败：1-不通过测试（失败运行CTest时出现错误</p><p>  Finally, rather than using  CMake/make for our build we prefer to use Meson and  Ninja for projects. Meson is a Python-based build system, which I find far more intuitive than  CMake (Note: CMake can also produce Ninja build files instead of Makefiles).</p><p>  最后，我们不是使用CMake / make进行构建，而是选择使用Meson和Ninja进行项目。 Meson是基于Python的构建系统，我发现它比CMake直观得多（注意：CMake还可以生成Ninja生成文件而不是Makefile）。</p><p>   Add  meson to the  apt package list. It is also worth adding  pkg-config as well as  meson uses this when looking for package dependencies (it’s not essential but keeps things cleaner).</p><p>   将介子添加到apt软件包列表中。也值得添加pkg-config，并且介子在查找软件包依赖项时会使用它（这不是必不可少的，但可以使事情更清洁）。</p><p> RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \ &amp;&amp; apt-get -y install --no-install-recommends libgmock-dev meson pkg-config</p><p> 运行apt-get update＆amp;＆amp;导出DEBIAN_FRONTEND =非交互式\＆amp;＆amp; apt-get -y install --no-install-recommends libgmock-dev介子pkg-config</p><p>     project(&#39;tdd-cpp&#39;, &#39;cpp&#39;, default_options: [&#39;cpp_std=c++17&#39;])gtest_dep = dependency(&#39;gtest&#39;, main : true, required : true)gmock_dep = dependency(&#39;gmock&#39;, main : true, required : true)gtest_test = executable( &#39;gtest_test&#39;, sources : [ &#39;test.cpp&#39;, ], dependencies : [ gtest_dep, ])test(&#39;failing_test&#39;, gtest_test)</p><p>     项目（＆＃39; tdd-cpp＆＃39;，＆＃39; cpp＆＃39;，default_options：[＆＃39; cpp_std = c ++ 17＆＃39;]）gtest_dep =依赖项（＆＃39; gtest＆＃ 39; main：true，必需：true）gmock_dep =依赖关系（＆＃39; gmock＆＃39 ;, main：true，必需：true）gtest_test =可执行文件（＆＃39; gtest_test＆＃39 ;,来源：[＆＃ 39; test.cpp＆＃39 ;,]，依赖项：[gtest_dep，]）test（＆＃39; failing_test＆＃39 ;, gtest_test） </p><p>   vscode ➜ /workspaces/ms-cpp $ meson builddir &amp;&amp; cd builddirThe Meson build systemVersion: 0.53.2Source dir: /workspaces/ms-cppBuild dir: /workspaces/ms-cpp/builddirBuild type: native buildProject name: tdd-cppProject version: undefinedC++ compiler for the host machine: c++ (gcc 9.3.0 &#34;c++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&#34;)C++ linker for the host machine: c++ ld.bfd 2.34Host machine cpu family: x86_64Host machine cpu: x86_64Found pkg-config: /usr/bin/pkg-config (0.29.1)Run-time dependency GTest found: YES 1.10.0Run-time dependency GMock found: YES 1.10.0Build targets in project: 1Found ninja-1.10.0 at /usr/bin/ninja/workspaces/ms-cpp/builddir</p><p>vscode➜/ workspaces / ms-cpp $ meson builddir＆amp;＆amp; cd builddir Meson构建系统版本：0.53.2源目录：/ workspaces / ms-cppBuild目录：/ workspaces / ms-cpp / builddir构建类型：本机build项目名称：tdd-cpp项目版本：主机的未定义C ++编译器：c ++（gcc 9.3。 0＆＃34; c ++（Ubuntu 9.3.0-17ubuntu1〜20.04）9.3.0＆＃34;）主机的C ++链接器：c ++ ld.bfd 2.34主机cpu系列：x86_64主机cpu：x86_64找到pkg-config：/ usr / bin / pkg-config（0.29.1）找到运行时相关的GTest：是1.10.0找到运行时相关的GMock：是1.10.0在项目中构建目标：1在/ usr / bin / ninja中找到了ninja-1.10.0 / workspaces / ms-cpp / builddir</p><p>  vscode ➜ /workspaces/ms-cpp/builddir $ meson test -vninja: Entering directory `/workspaces/ms-cpp/builddir&#39;[2/2] Linking target gtest_test.Running main() from /build/googletest-j5yxiC/googletest-1.10.0/googletest/src/gtest_main.cc[==========] Running 1 test from 1 test suite.[----------] Global test environment set-up.[----------] 1 test from setup_test_case[ RUN ] setup_test_case.testWillFail../test.cpp:4: FailureExpected equality of these values: 42 0[ FAILED ] setup_test_case.testWillFail (0 ms)[----------] 1 test from setup_test_case (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test suite ran. (1 ms total)[ PASSED ] 0 tests.[ FAILED ] 1 test, listed below:[ FAILED ] setup_test_case.testWillFail 1 FAILED TEST1/1 failing_test FAIL 0.01 s (exit status 1)Ok: 0Expected Fail: 0</p><p>  vscode➜/ workspaces / ms-cpp / builddir $介子测试-vninja：输入目录`/ workspaces / ms-cpp / builddir＆＃39; [2/2]链接目标gtest_test。从/ build / googletest-j5yxiC运行main（） /googletest-1.10.0/googletest/src/gtest_main.cc[==========]从1个测试套件中运行1个测试。[----------]全局测试环境集-up。[----------] 1个来自setup_test_case [RUN] setup_test_case.testWillFail ../ test.cpp：4的测试：失败这些值的期望相等性：42 0 [FAILED] setup_test_case.testWillFail（0 ms）[----------]从setup_test_case中进行1个测试（总计0 ms）[----------]删除整个测试环境[======== ==]运行了1个测试套件中的1个测试。 （总计1毫秒）[通过] 0个测试。[失败] 1个测试，列出如下：[失败] setup_test_case.testWillFail 1失败TEST1 / 1 failureing_test失败0.01 s（退出状态1）确定：0预期失败：0</p><p>  The  devcontainer.json file enables the created container to be configured and extended ( devcontainer.json reference), including VSCode extensions ( Visual Studio Marketplace).</p><p>  通过devcontainer.json文件，可以配置和扩展创建的容器（devcontainer.json参考），包括VSCode扩展（Visual Studio Marketplace）。</p><p> For example, VSCode extensions are available for both  meson and  GoogleTest. There are a number of specific extensions, here we shall use  asabil.meson and  C++ TestMate. These can be added to the container configuration using the  devcontainer.json file, e.g.</p><p> 例如，介子和GoogleTest都可以使用VSCode扩展名。有许多特定的扩展，在这里我们将使用asabil.meson和C ++ TestMate。可以使用devcontainer.json文件将它们添加到容器配置中，例如</p><p> // Add the IDs of extensions you want installed when the container is created. &#34;extensions&#34;: [ &#34;ms-vscode.cpptools&#34;, &#34;asabil.meson&#34;, &#34;matepek.vscode-catch2-test-adapter&#34; ],</p><p> //添加创建容器时要安装的扩展的ID。 ＆＃34;扩展名＆＃34 ;： [＆＃34; ms-vscode.cpptools＆＃34 ;、＆＃34; asabil.meson＆＃34 ;、＆＃34; matepek.vscode-catch2-test-adapter＆＃34; ]，</p><p> Now when we open the container, the extensions are present and allow us to manage the project.</p><p> 现在，当我们打开容器时，存在扩展名，并允许我们管理项目。</p><p>     Before you rush off turning all your projects into VSCode Dev Containers, I’ve come across a couple of issues.</p><p>     在急忙将所有项目转换为VSCode Dev Containers之前，我遇到了两个问题。 </p><p> First, some of our existing containers, especially those optimised for small size (notably multi-build, alpine-based images) fail to run using Dev Containers. I’ve yet to get to the bottom of these issues (yet another backlog item).</p><p>首先，我们现有的某些容器，尤其是针对小尺寸进行了优化的容器（特别是基于多层构建的基于高山的映像）无法使用Dev Containers运行。我还没有深入探讨这些问题（还有另一个待办事项）。</p><p> Also, I have had problems where existing Dockerfiles make significant use of bash scripts for internal configuration. Often these scripts are built around specific path configurations. When using Dev Containers the workspace is mounted under the internal path  /workspaces/&lt;git repo name&gt; and can cause scripts to fail. It appears this can be managed using  advanced container configuration, but it’s yet another thing I’ve yet to experiment with.</p><p> 另外，在现有的Dockerfile大量使用bash脚本进行内部配置时，我遇到了问题。这些脚本通常围绕特定的路径配置构建。使用Dev Containers时，工作空间安装在内部路径/ workspaces /＆lt; git repo name＆gt;下。并可能导致脚本失败。看来可以使用高级容器配置进行管理，但这是我还需要尝试的另一件事。</p><p>  The integration of container technology, specifically Docker, to VSCode creates an exciting development environment. It cements the relationship between local TDD development and CI pipeline builds by ensuring common build and test environments using Docker.</p><p>  容器技术（特别是Docker）与VSCode的集成创建了一个令人兴奋的开发环境。通过确保使用Docker的通用构建和测试环境，它巩固了本地TDD开发和CI管道构建之间的关系。</p><p> The example  CMake and  meson projects are elementary and not intended to represent real-world  CMake or  meson projects, but hopefully are enough to get going with. A slightly better, but by still no means complete, Meson/gtest/gmock example project can be found at  here.</p><p> 示例CMake和介子项目是基本项目，并不打算代表现实世界中的CMake或介子项目，但希望能够继续进行下去。可以在这里找到Meson / gtest / gmock示例项目，虽然稍微好一点，但还算不完整。</p><p>  If Dev Containers pique your interest, then you love  Codespaces · GitHub. GitHub Codepsaces are the topic of the next post.</p><p>  如果Dev Containers激起了您的兴趣，那么您会喜欢Codespaces·GitHub。 GitHub Codepsaces是下一篇文章的主题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.feabhas.com/2021/01/vscode-dev-containers-and-docker-moving-software-development-forward/">https://blog.feabhas.com/2021/01/vscode-dev-containers-and-docker-moving-software-development-forward/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dev/">#dev</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>