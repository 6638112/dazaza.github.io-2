<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>KCGI  -  C / C ++的最小CGI和FastCGI库 Kcgi – minimal CGI and FastCGI library for C/C++</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Kcgi – minimal CGI and FastCGI library for C/C++<br/>KCGI  -  C / C ++的最小CGI和FastCGI库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-21 15:39:22</div><div class="page_narrow text-break page_content"><p>kcgi is an  open					source CGI and FastCGI  library for C/C++ web					applications.				It is minimal, secure, and auditable.</p><p>KCGI是用于C / C ++ Web应用程序的开源CGI和FastCGI库。它是最小，安全和可悲的。</p><p>  To start,  install the library.				Then read the  deployment and  usage guides.				Use the  GitHub tracker for questions or comments,				or find contact information there for direct contact.</p><p>  要启动，请安装库。然后阅读部署和使用指南。使用GitHub Tracker进行问题或评论，或查找联系信息直接联系。</p><p>  #include  &lt;sys/types.h&gt; /* size_t, ssize_t */ #include  &lt;stdarg.h&gt; /* va_list */ #include  &lt;stddef.h&gt; /* NULL */ #include  &lt;stdint.h&gt; /* int64_t */ #include  &lt; kcgi.h&gt; int main( void) {  struct kreq r;  const char *page =  &#34;index&#34;;  if ( khttp_parse(&amp;r, NULL, 0, &amp;page, 1, 0) != KCGI_OK) return 1;  khttp_head(&amp;r, kresps[KRESP_STATUS],  &#34;%s&#34;, khttps[KHTTP_200]); khttp_head(&amp;r, kresps[KRESP_CONTENT_TYPE],  &#34;%s&#34;, kmimetypes[KMIME_TEXT_PLAIN]);  khttp_body(&amp;r);  khttp_puts(&amp;r,  &#34;Hello, world!&#34;);  khttp_free(&amp;r);  return 0;}</p><p>  #include＆lt; sys / types.h＆gt; / * size_t，ssize_t * / #include＆lt; stdarg.h＆gt; / * va_list * / #include＆lt; stddef.h＆gt; / * null * / #include＆lt; stdint.h＆gt; / * int64_t * / #include＆lt; kcgi.h＆gt; int main（void）{struct kreq r; const char * page =＆＃34;索引＆＃34 ;; if（khttp_parse（＆amp; r，null，0，＆amp;页面，1,0）！= kcgi_ok）返回1; khttp_head（＆amp; r，kresps [kresp_status]，＆＃34;％s＆＃34;，khttps [khttp_200]）; khttp_head（＆amp; r，kresps [kresp_content_type]，＆＃34;％s＆＃34;，Kmimetypes [kmime_text_plain]）; khttp_body（＆amp; r）; khttp_puts（＆amp; r，＆＃34;您好，世界！＆＃34;）; khttp_free（＆amp; r）;返回0;}</p><p>  #include  &lt;sys/types.h&gt; /* size_t, ssize_t */ #include  &lt;stdarg.h&gt; /* va_list */ #include  &lt;stddef.h&gt; /* NULL */ #include  &lt;stdint.h&gt; /* int64_t */ #include  &lt; kcgi.h&gt; int main( void) {  struct kreq r;  const char *page =  &#34;index&#34;; /* * Parse the HTTP environment. * We only know a single page, &#34;index&#34;, which is also * the default page if none is supplied. * (We don&#39;t validate any input fields.) */  if ( khttp_parse(&amp;r, NULL, 0, &amp;page, 1, 0) != KCGI_OK) return 1; /* * Ordinarily, here I&#39;d switch on the method (OPTIONS, etc., * defined in the  method variable) then switch on which * page was requested ( page variable). * But for brevity&#39;s sake, just output a response: HTTP 200. */  khttp_head(&amp;r, kresps[KRESP_STATUS],  &#34;%s&#34;, khttps[KHTTP_200]); /* * Show content-type unilaterally as text/plain. * This would usually be set from r.mime. */ khttp_head(&amp;r, kresps[KRESP_CONTENT_TYPE],  &#34;%s&#34;, kmimetypes[KMIME_TEXT_PLAIN]); /* No more HTTP headers: start the HTTP document body. */  khttp_body(&amp;r); /* * We can put any content below here: JSON, HTML, etc. * Usually we&#39;d switch on our MIME type. * However, we&#39;re just going to put the literal string as noted… */  khttp_puts(&amp;r,  &#34;Hello, world!&#34;); /* Flush the document and free resources. */  khttp_free(&amp;r);  return 0;}</p><p>  #include＆lt; sys / types.h＆gt; / * size_t，ssize_t * / #include＆lt; stdarg.h＆gt; / * va_list * / #include＆lt; stddef.h＆gt; / * null * / #include＆lt; stdint.h＆gt; / * int64_t * / #include＆lt; kcgi.h＆gt; int main（void）{struct kreq r; const char * page =＆＃34;索引＆＃34 ;; / * *解析HTTP环境。 *我们只知道一个页面，＆＃34;索引＆＃34;，它也是*如果没有提供默认页面。 *（我们不要验证任何输入字段。）* / if（khttp_parse（＆amp; r，null，0，＆amp;页面，1,0）！= kcgi_ok）返回1; / * *通常，这里是我＆＃39; d在方法（方法变量中定义的选项等）开关，然后切换请求*页面（页面变量）。 *但对于简洁的＆＃39; sake，只是输出响应：http 200. * / khttp_head（＆amp; r，kresps [kresp_status]，＆＃34;％s＆＃34;，khttps [khttp_200]）; / * *将内容类型单方面显示为文本/平原。 *通常会从r.mime设置。 * / khttp_head（＆amp; r，kresps [kresp_content_type]，＆＃34;％s＆＃34;，kmimetypes [kmime_text_plain]）; / *没有更多HTTP标头：启动HTTP文档正文。 * / khttp_body（＆amp; r）; / * *我们可以在此处放置以下内容：JSON，HTML等*通常我们＆＃39; d开关我们的MIME类型。 *但是，我们＆＃39;重新将文字字符串放在那样... * / khttp_puts（＆amp; r，＆＃34;您好，世界！＆＃34;）; / *刷新文件和免费资源。 * / khttp_free（＆amp; r）;返回0;}</p><p>  For a fuller example, see  sample.c, or jump to the  Documentation section.				(Want a C++ version? See  samplepp.cc.)</p><p>  对于更完整的示例，请参阅示例，或跳转到文档部分。 （想要一个c ++版本？请参阅samplepp.cc。）</p><p>  kcgi supports many features: auto-compression, handling of all HTTP input operations (query strings,				cookies, page bodies, multipart) with validation, authentication, configurable output caching, request				debugging, and so on.				Its strongest differentiating feature is using sandboxing and process separation for handling the untrusted				input path.</p><p>  KCGI支持许多功能：自动压缩，处理所有HTTP输入操作（查询字符串，Cookie，Page Bodies，MultiPart），具有验证，身份验证，可配置输出缓存，请求调试等。其最强大的差异特征是使用沙箱和工艺分离来处理不受信任的输入路径。</p><p>    First, check if  kcgi isn&#39;t already packaged for your system, such as				for  OpenBSD,  FreeBSD,				 Arch Linux, and so on.				(If it is, make sure it&#39;s up to date!)				If so, install using that system.</p><p>    首先，检查KCGI ISN＆＃39; T已经打包为您的系统，例如OpenBSD，FreeBSD，Arch Linux等。 （如果是，请确保它＆＃39; s最新！）如果是这样，请使用该系统进行安装。 </p><p>  If not, you&#39;ll need a modern  UNIX system. 				To date,  kcgi has been built and run on 				GNU/ Linux machines 				(musl and glibc), BSD 				( OpenBSD, 				 NetBSD, 				 FreeBSD),				 Solaris,				 OmniOS, and 				 Mac OS X 				(only Mojave and newer!) on i386, amd64, powerpc, arm64, and sparc64.				It has been deployed under  Apache,  nginx, and OpenBSD&#39;s  httpd(8)				(the latter two natively over FastCGI and via the  slowcgi wrapper).				The only hard dependency is BSD make ( bmake on Linux).				If you&#39;re running the regression tests (see  Testing), you&#39;ll need  libcurl.</p><p>如果没有，你＆＃39; ll需要一个现代的Unix系统。迄今为止，KCGI已经在GNU / Linux机器（Musl和Glibc），BSD（OpenBSD，NetBSD，FreeBSD），Solaris，Omnios和Mac OS X上（仅Mojave和Newer！）上进行了建立和运行，在I386，AMD64，PowerPC上，arm64和sparc64。它已在Apache，Nginx和OpenBSD中部署Httpdsd＆＃39; s httpd（8）（后者在Fastcgi上的后两种，并通过Slowcgi包装器）。唯一的硬依赖性是bsd make（在Linux上bake）。如果您＆＃39;重新运行回归测试（请参阅测试），＆＃39; ll需要libcurl。</p><p>  Download  kcgi.tgz and verify the archive with  kcgi.tgz.sha512.				Configure with  ./configure, compile with  make (or  bmake				on Linux systems).				Finally, install the software using  make install. 				Optionally override default paths with a  configure.local file (see the 				 configure script 				for details) prior to configuration.</p><p>  下载kcgi.tgz并使用kcgi.tgz.sha512验证存档。配置./configure，用make（或在Linux系统上Bake）编译。最后，使用make安装安装软件。可选地在配置之前覆盖具有configure.local文件的默认路径（请参阅配置脚本以获取详细信息）。</p><p>  If  kcgi doesn&#39;t compile, please send me the  config.log				file and the output of the failed compilation.				Along with all of your operating system information of course.</p><p>  如果KCGI编译，请发送我的config.log文件和失败编译的输出。以及所有操作系统的信息当然。</p><p>  To run bleeding-edge code between releases, the CVS repository is mirrored on 				 GitHub. Installation instructions tracking the repository				version may be found on that page.</p><p>  要在版本之间运行Bleed-Edge代码，CVS存储库在GitHub上镜像。可以在该页面上找到跟踪存储库版本的安装说明。</p><p>  Well-deployed web servers, such as the default  OpenBSD server, by				default are deployed within a  chroot(2). If				this is the case, you&#39;ll need to statically link your binary.</p><p>  默认情况下部署了默认的Web服务器，例如默认OpenBSD服务器，部署在Chroot（2）中。如果是这种情况，你＆＃39; ll需要静态链接你的二进制文件。</p><p>    FastCGI applications may either be started directly by the web server (which is popular with  Apache) or  externally given a socket and  kfcgi(8) (this method is normative for OpenBSD&#39;s  httpd(8) and				suggested for the security precautions taken by the wrapper).</p><p>    FastCGI应用程序可以由Web服务器直接启动（由Apache流行）或者在外部给定套接字和kfcgi（8）（此方法是OpenBSD的规范状态，并为Httpd（8）建议采取的安全预防措施通过包装）。</p><p>  The  kcgi manpages, starting with  kcgi(3), are the				canonical source of documentation. 				The following is a list of all manpages:</p><p>  以KCGI（3）开始的KCGI编程是规范文档源。以下是所有联机的列表： </p><p>    If it&#39;s easier to start by example, you can use 				 kcgi-framework as an initial boilerplate to				start your project.				The following are introductory materials to the system.</p><p>如果它更容易以示例开始，则可以使用KCGI-Framework作为启动项目的初始样板。以下是系统的介绍性材料。</p><p>      Dzonsons, Kristaps.  Role-based Access Control in BCHS Web Applications. 					Proceedings of  AsiaBSDCon, Tokyo, Japan, March 2018.					( Slides,					 video.)					 paper.)</p><p>      Dzonsons，Kristaps。 BCHS Web应用中基于角色的访问控制。 AsiaBSDCON，东京，日本，2018年3月的常见诉讼程序。（幻灯片，视频。）纸。）</p><p>  Dzonsons, Kristaps.  Secure BSD Web Applications in C: Practical Strategies. 					Proceedings of  AsiaBSDCon, Tokyo, Japan, March 2017.					( Slides.)</p><p>  Dzonsons，Kristaps。安全BSD Web应用程序在C：实用策略中。 AsiaBSDCON，东京，日本，2017年3月份的诉讼程序。（幻灯片。）</p><p>  Dzonsons, Kristaps.  Secure BSD Web Application Development in C. 					Proceedings of  AsiaBSDCon, Tokyo, Japan, March 2016.					( Slides.)</p><p>  Dzonsons，Kristaps。安全BSD Web应用程序开发在C. AsiaBSDCON，东京，日本，2016年3月。（幻灯片。）</p><p>  Dzonsons, Kristaps.  kcgi: securing CGI applications in C. 					Proceedings of  AsiaBSDCon, Tokyo, Japan, March 2015.					( Slides,					  paper.)</p><p>  Dzonsons，Kristaps。 kcgi：在2015年3月，在日本东京东京亚洲亚洲商会中保护CGI应用。（幻灯片，纸张）</p><p>  The bulk of  kcgi&#39;s CGI handling lies in  khttp_parse(3), which fully parses the HTTP request.				Application developers must invoke this function before all others.				For FastCGI, this function is split between  khttp_fcgi_init(3), which				initialises context; and  khttp_fcgi_parse(3), which receives new				parsed requests.				In either case, requests must be freed by  khttp_free(3).</p><p>  大部分KCGI＆＃39; S CGI处理位于KHTTP_PARSE（3）中，它完全解析了HTTP请求。应用程序开发人员必须在所有其他之前调用此功能。对于FastCGI，此函数在KHTTP_FCGI_INIT（3）之间拆分，初始化上下文;和khttp_fcgi_parse（3），它收到了新的解析请求。在任何一种情况下，请求必须由KHTTP_FREE（3）释放。</p><p>  All functions isolate the parsing and validation of untrusted network data within a  sandboxed				child process.				Sandboxes limit the environment available to a process, so exploitable errors in the parsing process (or				validation with third-party libraries) cannot touch the system environment.				This parsed data is returned to the parent process over a socket.				In the following, the  HTTP parser and  input validator manage a single HTTP request, while				 connection delegator accepts new HTTP requests and passes them along.</p><p>  所有功能都将解析和验证在沙箱的子程过程中分析和验证。 Sandboxes限制了一个过程可用的环境，因此解析过程中的可利用错误（或使用第三方库的验证）无法触摸系统环境。通过套接字将此解析数据返回给父进程。在下文中，HTTP解析器和输入验证器管理单个HTTP请求，而连接委托器接受新的HTTP请求并通过它们。 </p><p>    This method of sandboxing the untrusted parsing process follows  OpenSSH, and requires special handling for each operating				system:</p><p>这种沙盒的方法，不受信任的解析过程遵循openssh，需要针对每个操作系统的特殊处理：</p><p>  This requires a fairly new kernel (≥Linux 3.5).					It is supplemented by  setrlimit(2) limiting.					For the time being, this feature is only available for x86, x86_64, and arm architectures.					If you&#39;re using another one, please send me your  uname -m and, if you know if it,					the correct  AUDIT_ARCH_xxx found in  /usr/include/linux/audit.h.</p><p>  这需要一个相当新的内核（≥linux3.5）。它由Setrlimit（2）限制补充。暂时，此功能仅适用于X86，X86_64和ARM架构。如果您使用另一个＆＃39;请将您的uname -m发送给我，如果您知道它，则在/usr/include/linux/audit.h中找到的正确的upit_arch_xxx。</p><p>        This uses the sandboxing profile for  pure computation as provided in Mac OS X Leopard and					later.					This is supplemented by resource limiting via  setrlimit(2).</p><p>        这将使用Sandboxing型材，以便在Mac OS X Leopard中提供的纯计算。这是通过SetRlimit（2）的资源限制的补充。</p><p>    Uses the capabilities facility on  FreeBSD 10 and later.					This is supplemented by resource limiting with  setrlimit(2).</p><p>    使用FreeBSD 10及更高版本的功能设施。这由资源限制补充了setrlimit（2）。</p><p>  Since validation occurs within the sandbox, special care must be taken that validation routines don&#39;t				access the environment (e.g., by opening files, network connections, etc.), as the child				 might be abruptly killed by the sandbox facility.				(Not all sandboxes do this.)				If required, this kind of validation can take place after the parse validation sequence.</p><p>  由于验证发生在沙箱内，必须采取特别小心，验证例程不访问环境（例如，通过打开文件，网络连接等），因为孩子可能被沙箱设施突然杀死。 （并非所有沙箱都这样做。）如果需要，可以在解析验证序列后进行这种验证。</p><p>  The connection delegator is similar, but has different sandboxing rules, as it must manage an open				socket connection and respond to new requests.</p><p>  连接委托器类似但具有不同的沙箱规则，因为它必须管理打开的套接字连接并响应新请求。</p><p>  kcgi is shipped with a fully automated testing framework executed with				 make regress.				To test your own applications, use the  kcgiregress(3) library.				This framework acts as a mini-webserver, listening on a local port, translating an HTTP document into a				minimal CGI request, and passing the request to a  kcgi CGI client.				For internal tests, test requests are constructed with  libcurl.				The binding local port is fixed: if you plan on running the regression suite, you may need to				tweak its access port.</p><p>  KCGI随着使用制作退回而执行的全自动测试框架提供。要测试自己的应用程序，请使用KCGiregress（3）库。此框架充当迷你网络服务器，在本地端口上侦听本地端口，将HTTP文档转换为最小的CGI请求，并将请求传递给KCGI CGI客户端。对于内部测试，测试请求由libcurl构建。绑定本地端口是固定的：如果您计划运行回归套件，则可能需要调整其访问端口。 </p><p>  Another testing framework exists for use with the  American					fuzzy lop.				To use this, you&#39;ll need to compile the  make afl target with your compiler of choice, e.g.,				 make clean, then  make afl CC=afl-gcc.				Then run the  afl-fuzz tool on the  afl-multipart,  afl-plain, and				 afl-urlencoded binaries using the test cases (and dictionaries, for the first) provided.</p><p>存在另一个测试框架，以用于美国模糊套。要使用此功能，您＆＃39; ll需要使用您的编译器编译Make AFL目标，例如，制作清洁，然后制作AFL CC = AFL-GCC。然后使用所提供的测试用例（和第一个字典）在AFL-MultiPart，AFL-Plain和AFL-Urlencoded二进制文件上运行AFL-Fuzz工具。</p><p>  Security comes at a price—but not a stiff price.				By design,  kcgi incurs overhead in three ways: first, spawning a child to				process the untrusted network data; second, enacting the sandbox framework; and third, passing parsed				pairs back to the parent context.				In the case of running CGI scripts,  kcgi performance is bound to the operating				system&#39;s ability to spawn and reap processes.				For FastCGI, the bottleneck becomes the transfer of data.				In the following graph, I graph the responsiveness of  kcgi against the baseline				web-server performance.</p><p>  安全性来自价格 - 但不是僵硬的价格。通过设计，KCGI以三种方式引入开销：首先，产卵为孩子处理不受信任的网络数据;其次，制定沙箱框架;第三，将解析对返回父环境。在运行CGI脚本的情况下，KCGI性能绑定到操作系统＆＃39; S产卵和获取进程的能力。对于FastCGI，瓶颈成为数据的转移。在下图中，我图表kcgi对基线web服务器性能的响应性。</p><p>    This shows the empirical cumulative distribution of a statisically-significant number of page requests				as measured by  ab(1) with 10 concurrent				requests.				The  CGI line is the CGI sample included in the source;				the  FastCGI line is the FastCGI sample;				the  CGI (simple) simply emits a 200 HTTP status and  Hello, World; and				the  static is a small static file on the web server.				The operating system is Mac OS X 10.7.5  Air laptop (1.86 GHz Intel Core 2 Duo, 2 GB RAM) with the				stock Apache.				The FastCGI server was started using the  kfcgi(8) defaults.</p><p>    这示出了通过AB（1）测量的统计学大量的页面请求的经验累积分布，其具有10个并发请求。 CGI线是源中包括的CGI样本; FastCGI线是FastCGI样本; CGI（简单）只会发出200个HTTP状态和Hello，世界;静态是Web服务器上的一个小静态文件。操作系统是Mac OS X 10.7.5空气笔记本电脑（1.86GHz Intel Core 2 Duo，2 GB RAM），其中Apache。 FastCGI服务器使用Kfcgi（8）默认值启动。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kristaps.bsd.lv/kcgi/">https://kristaps.bsd.lv/kcgi/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fastcgi/">#fastcgi</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/minimal/">#minimal</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>