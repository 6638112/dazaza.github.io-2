<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>测试金字塔应该看起来更像一只螃蟹</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">测试金字塔应该看起来更像一只螃蟹</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 00:17:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/a8ff3c12e4e676e6cb81d35940395a8b.jpg"><img src="http://img2.diglog.com/img/2020/11/a8ff3c12e4e676e6cb81d35940395a8b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is a fancified excerpt from Gleb Bahmutov on  JS Party #148. Gleb is VP of Engineering at  Cypress.io. To get the full experience you should listen while you read.</p><p>这是格列布·巴姆托夫关于JS党#148的一段虚构的摘录。Gleb是Cypress.io的工程副总裁。要获得完整的体验，你应该边看边听。</p><p>    Typically, people say that testing is like a pyramid. Imagine a pyramid like in Egypt.</p><p>通常，人们会说测试就像金字塔。想象一下像埃及那样的金字塔。</p><p>   At the bottom you have a very wide layer of unit tests. And unit tests test the smallest piece of code.</p><p>在底部，您有一个非常广泛的单元测试层。而单元测试测试的是最小的代码片段。</p><p> (Imagine you write a function that adds two numbers; so you write a test. If I call that function with arguments 2 and 3, do I get 5?)</p><p>(假设您编写了一个将两个数字相加的函数；因此您编写了一个测试。如果我使用参数2和3调用该函数，是否会得到5？)。</p><p> Every language under the sun has a unit testing framework, because it’s so easy. Just load a piece of code, run it, check the result that you get, make sure it’s what you expect. So that’s why the bottom of the pyramid is usually very wide, because it’s easy to just write hundreds of tests to exercise all your little components.</p><p>世界上每种语言都有一个单元测试框架，因为它非常简单。只需加载一段代码，运行它，检查您得到的结果，确保它符合您的预期。这就是金字塔底部通常非常宽的原因，因为只需编写数百个测试来测试您所有的小组件就很容易了。</p><p>  And when you move higher up in the pyramid and now you’re trying to put units of code together.</p><p>当你在金字塔中向更高的位置移动时，现在你正试图把代码单元放在一起。</p><p> Maybe you’re trying to use a  Todo class, but represent something and you do some other pieces of code. You’re now mostly trying to see if a couple of units of code work together; how they integrate. And that’s where you discover parts where the backend team and the frontend team actually did not communicate very well. So my module doesn’t work very well with another module.</p><p>也许您正在尝试使用TODO类，但是表示一些东西，然后您要做一些其他的代码片断。您现在主要是想看看几个代码单元是否协同工作；它们是如何集成的。这就是您发现后端团队和前端团队实际上沟通不是很好的地方。所以我的模块与另一个模块不能很好地协同工作。</p><p>   An end-to-end test is when you’re trying to run the whole thing as the end user would. For example, you open a website in your browser and you navigate and you work with your web application and you check if it updates the page correctly, if it calls the backend correctly.</p><p>端到端测试是指您试图像最终用户那样运行整个测试。例如，您在浏览器中打开一个网站，然后导航和使用您的Web应用程序，并检查它是否正确地更新了页面，是否正确地调用了后端。</p><p> The top of the pyramid is usually very sharp. That’s because you’re not supposed to write many end-to-end tests.  I think this is obsolete thinking nowadays, because why was it hard to write end-to-end test?</p><p>金字塔的顶部通常很尖。这是因为您不应该编写很多端到端测试。我认为现在这种想法已经过时了，因为为什么编写端到端测试会很难呢？</p><p> It was hard to install the end-to-end test runner. It was finicky. It was flaky. The tests were flaky and didn’t give you much confidence, so you actually spent more time maintaining most end-to-end tests than you would actually spend time writing your web application.</p><p>很难安装端到端的测试跑步器。太挑剔了。它是不稳定的。这些测试不可靠，没有给您太多信心，因此您实际上花费在维护大多数端到端测试上的时间比您实际花在编写Web应用程序上的时间还要多。</p><p>  Write many unit tests, write many integration tests, but just a few end-to-end tests (maybe just as a sanity).</p><p>编写许多单元测试，编写许多集成测试，但只编写几个端到端测试(可能只是为了保持理智)。</p><p> And when we look at what  Cypress allows you to do (which is write many useful tests that have very little flake) then you wanna write  more end-to-end tests. You wanna make the pyramid almost like a rectangle  or maybe as a pizza slice, where you have a lot of end-to-end tests and a few unit tests.</p><p>当我们看一看Cypress允许您做什么(即编写许多非常少的有用测试)时，您会想要编写更多的端到端测试。您希望使金字塔几乎像一个矩形，或者可能像一个披萨片，其中有很多端到端测试和几个单元测试。</p><p>  It goes back to efficiency. If you test a small, single function that adds two numbers… Yeah, the test is easy, it’s fast, but it really only hits that particular function. But your web app is  large and potential sources of errors are not just logical errors in your functions:</p><p>这又回到了效率的问题上。如果您测试一个将两个数字相加的小的单个函数…。是的，测试很简单，速度也很快，但它确实只达到了那个特定的功能。但是你的Web应用程序很大，潜在的错误来源不仅仅是你的函数中的逻辑错误：</p><p>  That you have to set correctly in the backend and the frontend and all the little internet stuff in between.  And the modern browser (which is an awfully, awfully complicated machine) where your assumptions that it will execute this add “two numbers together” completely is different from what the end thing will do.</p><p>你必须在后端和前端以及它们之间的所有互联网小东西中正确设置。而现代的浏览器(这是一台极其复杂的机器)中，您认为它将完全执行“两个数字相加”的假设与最终结果是不同的。在现代浏览器中，您认为它将完全执行“两个数字相加”的假设与最终结果是不同的。</p><p> So when you think about what’s the effectiveness, or how much do you actually exercise? How many potential errors can you find?</p><p>那么，当你思考它的有效性是什么，或者你实际锻炼了多少？您能找到多少潜在错误？</p><p> Well, the unit tests can find you a few logical errors, which is great. I write unit tests for that all the time.  But all possible sources of error are discovered by end-to-end tests.</p><p>嗯，单元测试可以找到一些逻辑错误，这很棒。我一直都在为此编写单元测试。但是所有可能的误差源都是通过端到端测试发现的。</p><p> If you can test the site you just deployed and go through the main user story –just like a human user would do later on– if  that works… the chances are when the real user goes through the same thing, it will be successful.</p><p>如果您可以测试您刚刚部署的站点并了解主用户情景-就像人类用户稍后所做的那样-如果这能正常工作的话…。当真正的用户经历同样的事情时，它可能会成功。</p><p>  So if we flip the pyramid and we make the top wider and wider, and we will write more end-to-end tests, because they’re effective and we make it almost like a pizza slice, where we write more end-to-end tests, or if we start with end-to-end tests, it makes sense.</p><p>所以，如果我们翻转金字塔，把顶部做得越来越宽，我们会写更多的端到端测试，因为它们是有效的，我们让它几乎像披萨片一样，我们在那里写更多的端到端测试，或者如果我们从端到端测试开始，这是有意义的。</p><p>   And what happens recently? Well, a functional tester or test runner like Cypress finds a text, clicks on the button, does all those things, but  it only verifies that the application works.</p><p>最近发生了什么事？像Cypress这样的功能测试者或测试运行者找到一个文本，点击按钮，做所有这些事情，但它只验证应用程序是否工作。</p><p> It  doesn’t verify that the applications looks good. And we’re all humans. We like pretty things, so we like styles. Some people even add CSS to their apps. I don’t know why, but it’s crazy. 😉</p><p>它不会验证应用程序看起来是否良好。我们都是人类。我们喜欢漂亮的东西，所以我们喜欢款式。有些人甚至将CSS添加到他们的应用程序中。我不知道为什么，但这太疯狂了。😉。</p><p> Once they add CSS and they do the styling, they want to make sure the app looks the same, and they don’t accidentally break it.</p><p>一旦他们添加了CSS并设计了样式，他们希望确保应用程序看起来是一样的，并且不会不小心弄坏它。</p><p> If we select elements, and you work with them, and you check the number of items, the CSS can still change. And then the application will look like crap, and users will be unhappy, and nobody is gonna buy anything from your website.</p><p>如果我们选择元素，并且您使用它们，并且您检查项目的数量，CSS仍然可以更改。然后应用程序看起来就像垃圾一样，用户会不高兴，没有人会从你的网站上买任何东西。</p><p> Cypress is just a functional test runner.  It doesn’t care about CSS. And it’s very hard to write all the assertions saying:</p><p>赛普拉斯只是一个功能测试跑步者。它不关心CSS。很难写出所有的断言说：</p><p> The color of this element should be blue, and the border radius should be 2…</p><p>此元素的颜色应为蓝色，边框半径应为2…</p><p>   So instead, what people do –because it’s a real browser– is you can take and generate a screenshot of your page (or a part of it) and then you can do visual testing.</p><p>因此，人们所做的-因为它是真正的浏览器-是您可以获取并生成页面(或页面的一部分)的屏幕截图，然后您可以进行视觉测试。</p><p> So you save a screenshot and it becomes a baseline or a master image. The next time you run the test you take another screenshot and then you  compare it pixel by pixel with your baseline imagine. And you store those baseline images with your source code in your repository.</p><p>因此，您保存一个屏幕截图，它将成为基线或主图像。下次运行测试时，您将拍摄另一个屏幕截图，然后逐个像素地将其与您的基线图像进行比较。然后将这些基线图像与源代码一起存储在存储库中。</p><p> Computers are really good at comparing images pixel by pixel, and they’ll tell you:</p><p>计算机非常擅长逐个像素地比较图像，它们会告诉你：</p><p>   It used to be this. Now it’s a different color. Here’s where it changed</p><p>以前是这样的。现在是不同的颜色了。这里是它改变的地方。</p><p>  Did they mean to change the CSS here? Why is it no longer blue and now red?</p><p>他们的意思是要更改这里的CSS吗？为什么它不再是蓝色而现在是红色？</p><p> Visual testing to me is such an effective tool, paired with a full end-to-end test.,You can literally load the application, take a screenshot, and now you know  it will never change accidentally. Do something where the application reacts, changes the layout, new DOM elements appear. Then you take another screenshot.</p><p>对我来说，视觉测试是一个非常有效的工具，配上完整的端到端测试，你可以直接加载应用程序，截图，现在你知道它永远不会意外改变。在应用程序做出反应、更改布局、出现新的DOM元素时执行某些操作。然后再截取另一张屏幕截图。</p><p> Boom. Now you tie it so close, any visual change (any CSS, SVG, anything) will change with pixels, and you’ll know that you accidentally broke the styling. And you’ll know that accidentally you made Craigslist look like Reddit…</p><p>砰的一声。现在你把它绑得太紧了，任何视觉改变(任何CSS、SVG，任何东西)都会随着像素的变化而改变，你就会知道你不小心破坏了样式。你会知道你不小心让Craigslist看起来像Reddit…。</p><p>   So to me, the most useful pyramid right now is a pyramid that’s wholly end-to-end, functional and visual tests. That’s it.</p><p>所以对我来说，现在最有用的金字塔是一个金字塔，完全是端到端的，功能和视觉测试。就这样。</p><p> And then, I can track code coverage instrumenting my application code; the end-to-end tests that will go through the whole flow, like a real user, are so effective at code coverage.</p><p>然后，我可以通过检测应用程序代码来跟踪代码覆盖率；将贯穿整个流程的端到端测试(就像真正的用户一样)在代码覆盖率方面非常有效。</p><p>    Well, because end-to-end tests exercise the whole application, a single test can cover most of it, if it goes through the whole user story.</p><p>嗯，因为端到端测试测试了整个应用程序，如果它贯穿整个用户故事，那么一个测试就可以涵盖大部分内容。</p><p> And then you look at the lines not covered, and you write end-to-end tests for those edge cases. And if you cannot reach both lines, because there could be edge cases that are unreachable through a well-designed interface, then you write end-to-end tests, API tests and component tests, and hit those lines, so you know that those components and unit tests of code work as well.</p><p>然后查看未覆盖的行，并为这些边缘情况编写端到端测试。如果您无法同时访问这两行，因为可能存在无法通过设计良好的接口访问的边缘情况，那么您可以编写端到端测试、API测试和组件测试，然后单击这些行，因此您知道这些代码的组件和单元测试也可以正常工作。</p><p> But it becomes a pyramid of end-to-end tests, little triangles for other types of tests, and to me it looks like a crab, because it’s a big kind of helmet shell, and little armored legs under it.</p><p>但它变成了端到端测试的金字塔，其他类型测试的小三角形，对我来说，它看起来像一只螃蟹，因为它是一种很大的头盔壳，在它下面有小装甲的腿。</p><p>     Our conversation with Gleb doesn’t stop there. Listen to the entire episode to hear the story of Cypress, how they found a business model around open source, how  you can make your end-to-end tests less brittle, and much more. Play it from the start right here 👇</p><p>我们和格莱布的谈话不止于此。收听整集，听听Cypress的故事，他们是如何围绕开源找到一种商业模式的，你如何让你的端到端测试不那么脆弱，等等。从这里开始播放，就在这里，👇。</p><p>  Oh, and don’t forget to subscribe to  JS Party in your favorite podcast app so you don’t miss future episodes and insights. ✌️</p><p>哦，别忘了在你最喜欢的播客应用中订阅JS Party，这样你就不会错过未来的剧集和洞察力。✌️</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://changelog.com/posts/the-testing-pyramid-should-look-more-like-a-crab">https://changelog.com/posts/the-testing-pyramid-should-look-more-like-a-crab</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/金字塔/">#金字塔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pyramid/">#pyramid</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>