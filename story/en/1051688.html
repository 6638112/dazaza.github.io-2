<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在nim中匹配 Patten Matching in Nim</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Patten Matching in Nim<br/>在nim中匹配 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 14:32:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/a498557a343dfd09fe4bac13a5a04699.png"><img src="http://img2.diglog.com/img/2021/3/a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Fusion contains Nim modules that are meant tobe treated as an extension to the stdlib.Currently, the following modules are present:</p><p>Fusion包含inim模块，该模块是指在stdlib的延伸视为extent.clow中，以下模块存在：</p><p> fusion/matching - pattern matching implementation using Nim macros - the main focus of this article</p><p> 使用NIM宏的融合/匹配 - 模式匹配实现 - 本文的主要重点</p><p>  To install  fusion simply run  nimble install fusion.To try it out without installing, use the  Nim playground.</p><p>  要安装融合，只需运行敏捷安装融合。在没有安装的情况下尝试熄灭，请使用Nim Playground。</p><p> import  fusion / matching {. experimental :  &#34;caseStmtMacros&#34; .} case  [ ( 1 ,  3 ),  ( 3 ,  4 ) ] :  of  [ ( 1 ,  @ a ),  _]:  echo  a  else :  echo  &#34;Match failed&#34;</p><p> 导入融合/匹配{。实验：＆＃34; Casestmtmacros＆＃34; 。}案例[（1,3），（3,4）]：[（1，@ a），_]：echo e ex：echo＆＃34;匹配失败＆＃34;</p><p>  The new pattern matching library introduces support for two very useful concepts: pattern matching and  object destructuring.</p><p>  新的模式匹配库介绍了两个非常有用的概念的支持：模式匹配和对象破坏性。</p><p> Pattern matching is a mechanism that allows you to check a particular object againsta pattern — you could think of it mainly as a way to reduce boilerplate code whencomparing objects for equality, checking if a value is within range, checking if aparticular key is present in a table and so on.</p><p> 模式匹配是一种机制，允许您检查特定对象反对的模式 - 您可以将其思考主要作为一种方法来减少样板代码，当时，检查一个值是否在范围内，检查Apartular键是否存在表等。</p><p> import  std / json ,  fusion / matching {. experimental :  &#34;caseStmtMacros&#34; .} # JSON is very simple data format, but illustrates a lot of useful features # of pattern matching case  parseJson ( &#34;&#34;&#34;{ &#34;key&#34; : &#34;value&#34; }&#34;&#34;&#34; ):  # No longer necessary to check if key is present - it is done  # automatically  of  {  &#34;key&#34;  :  JInt ()  }:  discard  # Extracting values from nested data structures also becomes much easier.  of  {  &#34;key&#34;  :  ( getStr :  @ val )  }:  echo  val  assert  val  is  string</p><p> 导入STD / JSON，融合/匹配{。实验：＆＃34; Casestmtmacros＆＃34; 。}＃json是非常简单的数据格式，但是说明了很多有用的功能模式匹配案例parsejson（＆＃34;＆＃34;＆＃34; {＆＃34; key＆＃34;：＆＃34;价值＆＃34;}＆＃34;＆＃34;＆＃34;）：＃不再需要检查键是否存在 - 它是自动完成的{＆＃34; key＆＃34; ：Jint（）}：丢弃＃从嵌套数据结构中提取值也变得更加容易。 {＆＃34; key＆＃34; ：（getstr：@ val）}：echo val assert val是字符串 </p><p>   Object destructuring allows you to extract values from particularfields in an object.It is very common in dynamic programming languages such as Python.The simplest form of destructuring is already supported by Nim — tuple unpacking:</p><p>对象破坏性允许您从对象中的特定字段中提取值.it在Python等动态编程语言中非常常见.NIM  -  Tuple Unpacking已经支持最简单的破坏性形式：</p><p>   [ ( @ first ,  @ second ),  all  @ trail ]  : =  [ ( 12 ,  3 ),  ( 33 ,  4 ),  ( 12 ,  33 ) ] echo  first ,  &#34;, &#34; ,  second ,  &#34;, &#34; ,  trail</p><p>   [（@ first，@秒），所有@ trail]：= [（12,3），（33,4），（12,33）]回声首先，＆＃34 ;,＆＃34; ，第二，＆＃34 ;,＆＃34; ，  踪迹</p><p>    The main purpose of pattern matching is a simplification of conditions andconsecutive checks.It is especially useful when paired with object variants,but can also be used to do a lot of other things, such as key-value pairs matchingand extensive support for sequence matching.A special syntactic sugar is provided for very common use cases, such as  Option[T]checking (similar to  if let in Rust):</p><p>    模式匹配的主要目的是简化条件和Checks。与对象变体配对时尤其有用，但也可以用于执行大量其他内容，例如键值对匹配和序列匹配的广泛支持。为非常常见的用例提供了一种特殊的句法糖，例如选项[t]检查（类似于rust中的话）：</p><p>    And matching tree structures of case objects (such as an AST).For  enum, conforming to the  NEP1 style guidenaming conventions, you can omit the prefix entirely, leading to code that looksroughly like this:</p><p>    和匹配的案例对象（如AST）的树结构。符合Nep1样式指南约定的枚举，您可以完全省略前缀，导致代码看起来像这样：</p><p> case  &lt; some  AST  node &gt; :  # Node kind is `nnkIdent`, but it is possible to omit `nnk`  of  Ident ( strVal :  @ name ):  echo  &#34;Found ident: &#34; ,  name  # Extracting subnodes from infix expression.  of  InfixExpr [ Ident ( strVal :  &#34;+&#34; ),  @ lhs ,  @ rhs ] :  ...  # Matching if statements with *exactly* two branches.  # No need to worry about indexing exceptions - `len` is checked accordingly  # during pattern matching.  of  IfStmt [ ElifBranch [@ cond1 ,  _], ElifBranch[@cond2, _]]:  ...</p><p> 案例＆lt;一些AST节点＆gt; ：＃节点种类是“nnkident`”，但可以省略“NNK”（Strval：@名称）：Echo＆＃34;找到标识：＆＃34; ，名称＃从infix表达式中提取子节点。 InfixExpr [Ident（strval：＆＃34; +＆＃34;），@ lhs，@ rhs]：...＃匹配与*完全*两个分支的语句。 ＃无需担心索引例外 - 在模式匹配期间相应地检查了“LEN”＃。 IFSTMT [ELIFBRANCH [@ COND1，_]，ELIFBRANCH [@ COND2，_]]：...</p><p>  Nim macros are one of the most powerful parts of the language, but they mightseem a little intimidating for newcomers, especially when it comes to implementinga macro for solving a particular problem at hand.</p><p>  NIM宏是语言中最强大的部位之一，但它们可能会对新人感到有点恐吓，特别是当涉及到实施手头的特定问题的宏时。</p><p> This article gives an example on how one can easily create a relatively complex macrousing the new pattern matching library.</p><p> 本文介绍了一个示例，就如何轻松地创建一个相对复杂的蜂映射新的模式匹配库。 </p><p> We will be creating a macro for dataflow programming, with support for some operationsfrom the  std/sequtils module (map/filter/each).The macro won’t be covering all possible combinations and use cases as it would makethe implementation significantly more complicated.</p><p>我们将为DataFlow编程创建一个宏，并支持某些操作，从STD / SEQUTILS模块（地图/过滤器/每）。宏将不会涵盖所有可能的组合和用例，因为它将实现更加复杂。</p><p>  When writing a macro, it is very useful to just write DSL code (as if you alreadyhad the macro) and what you expect it to generate.Decide  what you want to do and  how it should look like.In our case, the input could look roughly like this:</p><p>  编写宏时，只需编写DSL代码（仿佛已经宏）和您希望生成的内容非常有用。在我们的情况下，您的情况，输入可以看起来很粗糙：</p><p> flow lines(&#34;/etc/passwd&#34;): map[_, seq[string]]: it.split(&#34;:&#34;) keepIf: it.len &gt; 1 and it.matches [_.startsWith(&#34;systemd&#34;), .._] each: echo it</p><p> 流线（＆＃34; / etc / passwd＆＃34;）：地图[_，seq [string]]：它.split（＆＃34;：＆＃34;）Keepif：它.Len＆gt; 1和它.matches [_.startswith（＆＃34; systemd＆＃34;），._]每个：回声</p><p>  var  res  =  seq [ ResType ] for  it0  in  lines ( &#34;/etc/passwd&#34; ):  let  it1  =  it0 . split ( &#34;:&#34; )  if  it1 . len  &gt;  1  and  it1 . matches  [ _.startsWith(&#34;systemd&#34;), .._]:  echo  it1</p><p>  var res = seq [restype]在线（＆＃34; / etc / passwd＆＃34;）：让它= IT0。分裂（＆＃34;：＆＃34;）如果它1。 len＆gt; 1和IT1。匹配[_.startswith（＆＃34; systemd＆＃34;），._]：回声IT1</p><p>  Now the question is - how to transform the first into the second?We will start by first looking at the output for  dumpTree on the  flow macro:</p><p>  现在问题是 - 如何将第一个转换为第二个？我们将首先通过首先查看流宏上的DumpTree的输出：</p><p>   1  StmtList  2  Command  3  Ident  &#34;flow&#34;  4  Call  5  Ident  &#34;lines&#34;  6  StrLit  &#34;/etc/passwd&#34;  7  StmtList  8  Call  9  BracketExpr 10  Ident  &#34;map&#34; 11  Ident  &#34;_&#34; 12  BracketExpr 13  Ident  &#34;seq&#34; 14  Ident  &#34;string&#34; 15  StmtList 16  Call 17  DotExpr 18  Ident  &#34;it&#34; 19  Ident  &#34;split&#34; 20  StrLit  &#34;:&#34;</p><p>   1 stmtlist 2命令3 ident＆＃34; flow＆＃34; 4拨打5 ident＆＃34;线条＆＃34; 6 strlit＆＃34; / etc / passwd＆＃34; 7 stmtlist 8致电9 bracketexpr 10 ident＆＃34;地图＆＃34; 11 ident＆＃34; _＆＃34; 12 Bracketexpr 13 Idend＆＃34; SEQ＆＃34; 14 ident＆＃34; string＆＃34; 15 stmtlist 16致电17 dotexpr 18 ident＆＃34;它＆＃34; 19 ident＆＃34; split＆＃34; 20 strlit＆＃34;：＆＃34;</p><p> This load of text might seem a little confusing at first, but in the end it can betaken apart quite easily (and that is exactly what we will be doing).First, on line 3, we see the  flow identifier ( Ident &#34;flow&#34;) - this is the start of our macro.Then, on the next line is a  lines(&#34;/etc/passwd&#34;) argument.  StmtList on lines 7-20 is the actual body of the  flow macro - the  map section etc.We will get into their internal structure a little later.</p><p> 这一文本的负荷可能似乎一点令人困惑，但最终它可以很容易地分开（这正是我们将要做的）。首先，在第3行，我们看到流量标识符（Ident＆＃34 ; Flow＆＃34;） - 这是我们的宏的开始。然后，在下一行是一条线（＆＃34; / etc / passwd＆＃34;）的论点。第7-20行的StmtList是流程宏的实际正文 - 地图部分等。我们将稍后进入其内部结构。 </p><p>  After we a have rough outline of the input AST, it is time to decide on how thisparticular macro can be implemented.</p><p>在我们有一个粗略的输入AST概述之后，是时候决定如何实现这个分子宏。</p><p> I usually try to introduce some kind of intermediate representation for the DSL inorder to make things more organized and decouple the parsing stage from code generation.This might make the implementation a little longer, but more extensible and robust.You can, without a doubt, just go directly to code generation, but for a more complexDSL I would still recommend using some kind of IR.</p><p> 我经常试图为DSL介绍某种中间表示，以使事情从代码生成中更加组织和解析解析阶段。这可能会更长，但更可扩展和强大。您可以毫无疑问，毫无疑问只需直接到代码生成，但对于更复杂的公司，我仍然会建议使用某种IR。</p><p> In this particular case, the DSL structure for the  flow macro can be described as:</p><p> 在该特定情况下，可以描述流宏的DSL结构：</p><p> type  FlowStageKind  =  enum  fskMap  # Stage for element conversion  fskFilter  # Filter elements  fskEach  # Execute action without returning value  FlowStage  =  object  outputType :  Option [ NimNode ]  # Assert result type  kind :  FlowStageKind  # Type of the stage  body :  NimNode  # Stage body</p><p> 键入flowstagekind = enum fskmap＃阶段for元素转换fskfilter＃筛选元素fskeach＃执行操作而不返回值flowstage =对象outputtype：选项[nimnode] #ssuert结果类型类型：舞台主体的流动性＃键</p><p> It directly maps on the input DSL. map should create a  fskMap stage,  filter creates  fskFilter and so on.Optionally you can specify the output type like this:  map [ExpectedOutput].The macro will work in two stages: first it will convert the input representation intoan intermediate representation, and then it will generate the resulting AST.</p><p> 它直接映射到输入DSL上。映射应该创建一个FSKMAP阶段，过滤器创建FSKFilter等。因此，您可以指定这样的输出类型：地图[预期的输出]。宏将在两个阶段工作：首先，首先将输入表示形式转换为中间表示，然后它会产生结果的AST。</p><p>  Now, after we have good understanding of what exactly we want to do - the question is ‘how?’.That’s where   fusion/matchingcomes particularly handy - we already identified all patterns, and now it is only a matterof writing this down in code.</p><p>  现在，在我们对我们想要做的良好了解之后 - 这个问题是'怎么样？'。那就是融合/匹配特别方便的地方 - 我们已经识别了所有模式，现在它只是一个在代码中写下这个问题。</p><p> Without pattern matching, you’d be left with a long series of repeating  [0][0][0]and  if kind == nnkBracketExpr in order to retrieve parts from the DSL and validate input.</p><p> 没有模式匹配，您将留下长一系列重复[0] [0] [0]，如果种类== nnkbracketexpr，以便从DSL检索部分并验证输入。 </p><p> Before we proceed to writing patterns for the whole DSL, it is important to considerthe three possible cases of writing a stage.The first once is very simple - no type specified, only a stage identifier:</p><p>在我们继续为整个DSL编写模式之前，重要的是要考虑写入阶段的三种可能的情况。第一个一次非常简单 - 没有指定类型，只有舞台标识符：</p><p>    But a single stage with a type parameter can be written using two different ways - bothare  syntactically correct, but have different parse trees:</p><p>    但是可以使用两种不同的方式编写一个具有类型参数的单个阶段 - 缺两种句法正确，但有不同的解析树：</p><p>         The difference is due to the method call syntax - map[a] is treated as a bracket expression (like array subscript), but  map [a]is parsed as a procedure  map call, with argument  [a] (passing an array to afunction).</p><p>         差异是由于方法调用语法 - 映射[a]被视为括号表达式（如阵列下标），但是将映射[a]被解析为过程映射调用，具有参数[a]（将数组传递到上函数）。</p><p>  Let’s make a small digression in order to better understand how the new patternmatching library can help us here.</p><p>  让我们制作一个小型题名，以便更好地了解新的图案匹配库如何帮助我们这里。</p><p> We will be focusing on the parts that are relevant to our task - for more details youcan read the  documentation.</p><p> 我们将专注于与我们的任务相关的零件 - 有关更多详细信息，请阅读文档。</p><p> When writing Nim macros you are mostly dealing with NimNode objects - first toprocess input AST, and then to generate new code.The AST is comprised of  case objects.Usually, the first part of the macro involves lots of checks for the correct node kind,followed by iteration over the subnodes to extract the input data.Pattern matching simplifies this, allowing to directly write expected patternsfor the AST, with syntax closely matching that of  dumpTree.</p><p> 写入NIM宏时，您主要处理Nimnode对象 - 首先ToproCess输入AST，然后生成新代码。AST由案例对象组成。通常，宏的第一部分涉及正确的节点类型的大量检查，然后在子节点上进行迭代以提取输入数据.Pattern匹配简化了这一点，允许直接写入AST的预期模式，并与Dumptree的语法密切相关。</p><p> For example - if we have code like  map[string] it has the following tree representation:</p><p> 例如 - 如果我们有像Map [String]这样的代码，它有以下树表示： </p><p>      Notice the similarity between the AST and a pattern for matching - each node has  kind field,which describes what kind of node this is.In this case we are interested in the first and second subnodes of the  BracketExprnode - flow stage kind and type parameter respectively.</p><p>请注意AST和匹配模式之间的相似性 - 每个节点都有各种字段，它描述了这是什么样的节点。在这种情况下，我们对BrackEtexProde  - 流级类型和类型参数的第一和第二子节点感兴趣。</p><p> As we have already seen earlier,  map [string] and  map[string] are parseddifferently - the first one is handled as one-element array passed to  map as functionargument, and the second is a bracket expression. Method call syntaxusually makes programming a DSL a little harder - you need to check for bothalternatives, remember which index each capture should be in, etc.</p><p> 正如我们之前已经见过的那样，PAP [String]和Map [String]被解析使用 - 第一个被处理为传递给映射为functionargument的一个元素数组，第二个是括号表达式。方法调用语法使编程DSL一点更难 - 您需要检查渗透蛋白，请记住每个捕获的索引是否应等。</p><p> With pattern matching though it becomes quite easy to do - adding a secondalternative will be enough.</p><p> 使用模式匹配虽然它变得相当容易 - 添加了替代替代。</p><p>  It should also be possible to omit type parameters from the DSL entirely - they arequite nice and would allow for better type checking, but could become quite annoying to write.So, we should also expect someone to just write  map - without any type qualifications.To handle this case we add a third alternative for pattern:</p><p>  也可以完全从DSL省略类型参数 - 它们是很好的，并且可以允许更好的类型检查，但可能会变得非常烦人。所以，我们还应该指望某人只是写入地图 - 没有任何类型的资格。要处理这种情况，我们为模式添加第三个替代方案：</p><p>  This brings one important change: The  typeParam capture is no longer  NimNode - the typehas changed to  Option[NimNode], because not all alternatives have this variable. head is still a  NimNode just as before - all possible alternatives containthis variable, so it would be set if the input matches.</p><p>  这带来了一个重要的变化：typeparam捕获不再是nimnode  -  typehas更改为选项[nimnode]，因为并非所有替代品都具有此变量。头仍然是一个亮度，就像以前一样 - 所有可能的替代方案，所以如果输入匹配，则会设置它。</p><p>  This example shows really well how pattern matching can help to handle differentalternative syntaxes.Another very powerful feature is sequence matching - sadly in this particularexample we had no need for it, but I decided to still showcase it.Consider a  procedure declarationAST - suppose we need to match name, arguments, and return type.Usually, part of a case statement would look similar to this:</p><p>  此示例显示了模式匹配如何帮助处理差异替换术语。此其他功能非常强大的功能是序列匹配 - 可悲的是在此验证中，我们无需它，但我决定仍然展示它.Consider一个程序声明ast  - 假设我们需要要匹配名称，参数和返回type.usually，案例语句的一部分将类似于此图片：</p><p> of  nnkProcDef :  let  name  =  arg [ 0 ]  let  returnType  =  arg [ 3 ][ 0 ]  let  arguments  =  arg [ 3 ][ 1  ..  ^ 1 ]</p><p> nnkprocdef：让名称= arg [0]让returntype = arg [3] [0]让参数= arg [3] [1 .. ^ 1] </p><p>    Our first stage would be processing the input into a  FlowStage.We already have a way to extract the data from the input AST - using pattern matching.</p><p>我们的第一阶段将处理输入到流程中。我们已经有一种方法来从输入AST中提取数据 - 使用模式匹配。</p><p> macro  flow ( arg ,  body :  untyped ):  untyped  =  var  stages :  seq [ FlowStage ]  for  elem  in  body :  if  elem . matches (  Call [ BracketExpr [@ ident ,  opt  @ outType ] ,  @ body ]  |  # `map[string]:`  Command [@ ident  is  Ident (),  Bracket  [@ outType ] ,  @ body ]  |  # `map [string]:`  Call [@ ident  is  Ident (),  @ body ]  # just `map:`, without type argument  ):  stages . add  FlowStage (  kind :  identToKind ( ident ),  outputType :  outType ,  body :  body  )</p><p> 宏观流量（arg，body：untyped）：untyped = var阶段：身体elem的seq [flowstage]：如果是elem。匹配（调用[bracketexpr [@ ident，opt @ outtype]，@ body] | #`map [string]：`command [@ ident是ident（），bracket [outtype]，@ body] | #`map [string ]：“调用[@ ident是ident（），@ body]＃只是`地图：`，没有类型参数）：阶段。添加FlowStage（类型：identTokind（ident），OutputType：outtype，Body：Body）</p><p> After that, we have all necessary information for generating the result code.If the last stage is not  each, i.e. there is a return value after each iteration,we need to determine the type of the result sequence and then append to it oneach iteration.</p><p> 之后，我们拥有生成结果代码的所有必要信息。如果上阶段不是每个阶段，则即，每次迭代后都有返回值，我们需要确定结果序列的类型，然后追加迭代。</p><p> if  stages [ ^ 1 ] . kind  notin  { fskEach }:  # If last stage has return type (not `each`) then we need to  # accumulate results in temporary variable.  result  =  quote  do :  var  ` resId `:  seq [ #[ Type of the expression ]#]  for  it0  {. inject .}  in  ` arg `:  ` resId `. add  #[ Expression to evaluate]#  ` resId ` else :  # Otherwise just iterate each element  result  =  quote  do :  for  it0  {. inject .}  in  ` arg `:  #[ Expression to evaluate ]#</p><p> 如果阶段[^ 1]。依赖{fskeach}：＃如果上阶段有返回类型（不是`每个`）那么我们需要＃累积临时变量的结果。结果=引用do：var` reven`：seq [## [表达式]＃]为IT0 {。注射。}在`arg`：`stream`。添加＃[表达式来评估] #` revent` else：＃否则只需迭代每个元素结果=引用执行：对于IT0 {。注入。在`arg`：＃[表达式]}</p><p>  Each stage of the dataflow has a type, and potentially defines variables.In addition to that - each stage uses the special variable  it - that has to beinjected separately for each stage,  but at the same time it is used forcommunicating values between stages.</p><p>  DataFlow的每个阶段都有一种类型，并且可能定义变量。除此之外 - 每个阶段使用它的特殊变量 - 必须为每个阶段单独注入，但同时它在阶段之间使用暂停值。</p><p>   var  res :  seq [ #[ Type of the expression ]#] for  it  in  [ 1 ,  2 ,  3 ] :  let  it  =  it  *  2  let  it  =  $ it  res . add  it res</p><p>   var res：seq [＃[the表达式]＃]在[1,2,3]中：让它=它* 2让它= $ IT RES。添加它</p><p> As you can clearly see, such code would not even compile due to the redefinitionerrors.There are two possible ways to solve this problem - kind of obvious, and not-all-that-obvious.Let’s start with the first one - since each variable can be redefined in the newscope we can just do:</p><p> 正如您可以清楚地看到的，此类代码甚至不会因重新定义而编译。解决此问题的两种可能方法 - 那种明显的方式，而不是全部显而易见的.Let从第一个 - 自每个变量开始可以在Newscope中重新定义我们可以做到： </p><p> for  it  in  [ 1 ,  2 ,  3 ] :  block :  let  it  =  it  *  2  block :  let  it  =  $ it  echo  &#34;Add result - &#34; ,  it</p><p>因为它在[1,2,3]中：阻止：让它=它* 2块：让它= $ IT echo＆＃34;添加结果 - ＆＃34; ，  它</p><p>   And it would compile and work perfectly fine.But now we have a problem of getting the type of the expression itself - everythingis fine as long as you only use  map - after all  block: is an expression,and we can have something like this:</p><p>   它会非常精细地编译和工作。但是现在我们有一个问题获取表达式的类型 - 只要你只使用地图 - 毕竟块：是表达式，我们可以拥有这样的东西：</p><p> echo  typeof (( block :  let  it  =  1  block :  let  it  =  it  *  2  block :  $ it ))</p><p> echo typeof（（块：让它= 1块：让它=它* 2块：$ it））</p><p>   Not the prettiest code in the world, by all means - but it will become even worsewhen we have to deal with  filter,  each, injected variables and iterators.</p><p>   所有方法都不是世界上最漂亮的代码 - 但是当我们必须处理过滤器，每个注入的变量和迭代器时，它将变得更糟糕。</p><p> The second alternative is to use declare a proc with an  auto return type andassign the result of the expression to it.In that case, the compiler will figure out the return type for us.</p><p> 第二种替代方法是使用Auto Return类型和Assissige表达式的结果声明。在这种情况下，编译器将弄清楚我们的返回类型。</p><p> proc  hello [ T ] ( a :  T ):  auto  =  for  c  in  &#34;ee&#34; :  result  =  ( 12 ,  &#34;som&#34; ,  &#34;ee&#34; ,  a ) echo  typeof  hello [ int ]</p><p> proc hello [t]（a：t）：auto = f for c＆＃34; ee＆＃34; ：结果=（12，＆＃34; SOM＆＃34;，＆＃34; ee＆＃34; a）echo typeof hello [int]</p><p>   Now we only need to write code generation for  #[ Expression to evaluate ]# andsubstitute  result = when necessary.</p><p>   现在，我们只需要编写＃[表达式以评估]＃和asbstitutitute结果=必要时的代码生成。 </p><p>  Each stage in  flow injects an  it variable - the result of the evaluation from the previous stage.To avoid getting redefinition errors from multiple  let it = &lt;expression&gt; oneach stage, we will replace each occurrence of  it with  it&lt;stage-index&gt;.For the first stage it would be  it -&gt; it1, the second one is  it -&gt; it2 and so on.</p><p>流中的每个阶段都会注入它变量 - 从前一个阶段的评估结果。避免从多个允许重新定义错误=它=＆lt;表达式＆gt; oneach阶段，我们将用它替换它的每次出现它＆lt;阶段索引＆gt;。对于第一阶段，它将是它 - ＆gt; IT1，第二个是它 - ＆gt; IT2等等。</p><p>  rewrite takes an input  NimNode and either returns it as-is (if no rewriting is necessary)or, in case of the identifier  it ( Ident(strVal: &#34;it&#34;)), converts it into a newone with the corresponding index.</p><p>  重写占用输入nimnode，要么返回它 - 是（如果不需要重写），或者，如果是标识符IT（strval：＆＃34;它＆＃34;）），将其转换为一个纽音相应的索引。</p><p>  proc  rewrite ( node :  NimNode ,  idx :  int ):  NimNode  =  case  node :  of  Ident ( strVal :  &#34;it&#34; ):  result  =  ident ( &#34;it&#34;  &amp;  $ idx )  of  ( kind :  in  nnkTokenKinds ):  # `nnkTokenKinds` is a set of node  # kinds that don&#39;t have subnodes.  # These ones are returned without any  # modifications.  result  =  node  else :  # For node kinds with subnodes, rewriting must be done  # recursively  result  =  newTree ( node . kind )  for  subn  in  node :  result . add  subn . rewrite ( idx )</p><p>  proc重写（node：nimnode，idx：int）：nimnode =案例节点：ident（strval：＆＃34;它＆＃34;）：结果= ident（＆＃34;它＆＃34;＆amp; $ idx） （种类：在nnktokenkinds）：#`nktokenkinds`是一组Nod＃39; t有子节点的节点＃种。 ＃这些在没有任何＃修改的情况下返回。结果=节点其他：＃对于带子节点的节点种类，必须完成重写＃递归结果=节点中子N的NewTree（node。种类型）：结果。添加subn。重写（IDX）</p><p>  For each stage, we rewrite the body and then append a new chunk of generated codeto the result.</p><p>  对于每个阶段，我们重写身体，然后将生成的CodeTo的新块追加。</p><p>  func  evalExprFromStages ( stages :  seq [ FlowStage ] ):  NimNode  =  result  =  newStmtList ()  for  idx ,  stage  in  stages :  # Rewrite body  let  body  =  stage . body . rewrite ( idx )  case  stage . kind :  # If stage is a filter it is converted into `if` expression  # and new new variables are injected.  of  fskFilter :  result . add  quote  do :  let  stageOk  =  ((` body `))  if  not  stageOk :  continue  of  fskEach :  # `each` has no variables or special formatting - just  # rewrite body and paste it back to resulting code  result . add  body  of  fskMap :  # Create new identifier for injected node and assign  # result of `body` to it.  let  itId  =  ident ( &#34;it&#34;  &amp;  $ ( idx  +  1 ))  result . add  quote  do :  let  ` itId `  =  ` body `  # If output type for stage needs to be explicitly checked  # create type assertion.  if  Some ( @ expType )  ?=  stage . outputType :  result . add  makeTypeAssert ( expType ,  stage . body ,  itId )</p><p>  func evalexpromstages（阶段：seq [flowstage]）：nimnode =结果= idx的newstmtlist（），阶段阶段：#rewrite身体让body =阶段。身体 。重写（IDX）案例阶段。同类：＃如果阶段是一个过滤器，它被转换为`如果注入了`和新的新变量。 FSKFilter：结果。添加报价DO：让stexok =（（`body`））如果不是stexok：继续fskeach：#`每个`没有变量或特殊格式 - 只是＃重写身体并粘贴回到结果代码结果。添加FSKMAP的主体：＃为注入节点创建新标识符，并为其分配“身体”的＃结果。让ITID = ident（＆＃34;它＆＃34; $（IDX + 1））结果。添加报价DO：让`ITID` =`正文`＃如果需要明确检查舞台的输出类型＃创建类型断言。如果有些（@ exptype）？=阶段。 OutputType：结果。添加maketypeassert（Exptype，阶段。身体，ITID）</p><p>  func  typeExprFromStages ( stages :  seq [ FlowStage ] ,  arg :  NimNode ):  NimNode  =  let  evalExpr  =  evalExprFromStages ( stages )  var  resTuple  =  nnkPar . newTree ( ident  &#34;it0&#34; )  for  idx ,  stage  in  stages :  if  st . kind  notin  { fskFilter }:  resTuple . add  ident ( &#34;it&#34;  &amp;  $ ( idx  +  1 ))  let  lastId  =  newLit ( stages . len  -  1 )  result  =  quote  do :  block :  (  proc ():  auto  =  # `auto` annotation allows to derive type  # of the proc from any assignment within the  # proc body - we take advantage of this,  # and avoid building type expression  # manually.  for  it0  {. inject .}  in  ` arg `:  ` evalExpr `  result  =  ` resTuple ` # ^^^^^^^^^^^^^^^^^^^ # | # Type of the return will be derived from this assignment. # Even though it is placed within loop body, it will still # derive necessary return type  )() [ ` lastId ` ] # ^^^^^^^^^^^^ # | | # | Get last element from proc return type # | # After proc is declared we call it immediately</p><p>  Func typeexprofstages（阶段：seq [flowstage]，arg：nimnode）：nimnode = let evalexpr = evalexpromstages（阶段）var restuple = nnkpar。 Newtree（Ident＆＃34; IT0＆＃34;）对于IDX，阶段阶段：如果是ST。善意{fskfilter}：重新删除。添加ident（＆＃34;它＆＃34; $（idx + 1））letid = newlit（阶段。len-1）结果= quote do：block :( proc（）：auto = #` auto` annotation允许从＃proc Body中的任何分配中派生Proc的类型＃，我们利用此方法，＃并避免手动构建类型表达式＃。对于IT0 {。注入。在`arg`：`semarexpr`结果=` Resuple`＃^^^^^^^^^^^^^^^ ^^^^^^^ |＃|返回的＃类型将来自此分配。＃即使它被放置在循环体内，它仍然是＃派生必需的返回类型）（）[lastid`]＃^^^^^^^^^^^^^^^ | | ＃|从proc返回类型＃|获取最后一个元素＃| #dive proc宣布我们立即称呼它</p><p>  macro  flow ( arg ,  body :  untyped ):  untyped  =  var  stages :  seq [ FlowStage ]  for  elem  in  body :  if  elem . matches (  Call [ BracketExpr [@ ident ,  opt  @ outType ] ,  @ body ]  |  # `map[string]:`  Command [@ ident  is  Ident (),  Bracket  [@ outType ] ,  @ body ]  |  # `map [string]:`  Call [@ ident  is  Ident (),  @ body ]  # just `map:`, without type argument  ):  stages . add  FlowStage (  kind :  identToKind ( ident ),  outputType :  outType ,  body :  body  )  let  evalExpr  =  evalExprFromStages ( stages )  if  stages [ ^ 1 ] . kind  notin  { fskEach }:  # If last stage has return type (not `each`) then we need to  # accumulate results in temporary variable.  let  resExpr  =  typeExprFromStages ( stages ,  arg )  let  lastId  =  ident ( &#34;it&#34;  &amp;  $ stages . len )  let  resId  =  ident ( &#34;res&#34; )  result  =  quote  do :  var  ` resId `:  seq [ typeof (` resExpr `) ]  for  it0  {. inject .}  in  ` arg `:  ` evalExpr `  ` resId `. add  ` lastid `  ` resId `  else :  result  =  quote  do :  for  it0  {. inject .}  in  ` arg `:  ` evalExpr `  result  =  newBlockStmt ( result )</p><p>  宏观流量（arg，body：untyped）：untyped = var阶段：身体elem的seq [flowstage]：如果是elem。匹配（调用[bracketexpr [@ ident，opt @ outtype]，@ body] | #`map [string]：`command [@ ident是ident（），bracket [outtype]，@ body] | #`map [string ]：“调用[@ ident是ident（），@ body]＃只是`地图：`，没有类型参数）：阶段。添加FlowStage（种类：identTokind（ident），OutputType：Outtype，Body：Body）Let evalexpr = AsgexProMstages（阶段）如果阶段[^ 1]。依赖{fskeach}：＃如果上阶段有返回类型（不是`每个`）那么我们需要＃累积临时变量的结果。让Resexpr = typeexpromstages（阶段，arg）Letid = Ident（＆＃34;它＆＃34; $ amp; $阶段。Len）让Resid = ident（＆＃34; res＆＃34;）结果= quote do：var` resid`：seq [typeof（`resexpr`）]对于IT0 {。注射。}在`arg`：`评价中，'respexpr`` resid`。添加`lastid`` star` else：结果= quote do：for it0 {。注入。}在`arg`：`evalexpr`结果= newblockstmt（结果） </p><p>  let  res  =  flow  lines ( &#34;/etc/passwd&#34; ):  map [ seq [ string ]] :  it . split ( &#34;:&#34; )  filter :  let  shell  =  it [ ^ 1 ]  it . len  &gt;  1  and  shell . endsWith ( &#34;bash&#34; )  map :  shell</p><p>让Res =流线（＆＃34; / etc / passwd＆＃34;）：地图[seq [string]]：它。分裂（＆＃34;：＆＃34;）过滤器：让shell =它[^ 1]它。 len＆gt; 1和壳。 endswith（＆＃34; bash＆＃34;）地图：shell</p><p>  let  res  =  block :  var  res :  seq [ typeof ( block :  # largely duplicated code for getting type of the expression.  proc  ():  auto  =  for  it0  in  lines ( &#34;/etc/passwd&#34; ):  let  it1  =  split ( it0 ,  &#34;:&#34; ,  - 1 )  let  stageOk ` gensym10271  =  let  shell  =  it1 [ BackwardsIndex ( 1 ) ]  1  &lt;  len ( it1 )  and  endsWith ( shell ,  &#34;bash&#34; )  if  not  stageOk ` gensym10271 :  continue  let  it3  =  shell  result  =  ( it0 ,  it1 ,  it3 )() [ 2 ]  ) ]  # Actual implementation  for  it0  in  lines ( &#34;/etc/passwd&#34; ):  let  it1  =  split ( it0 ,  &#34;:&#34; ,  - 1 )  let  stageOk ` gensym10267  =  let  shell  =  it1 [ BackwardsIndex ( 1 ) ]  1  &lt;  len ( it1 )  and  endsWith ( shell ,  &#34;bash&#34; )  if  not  stageOk ` gensym10267 :  continue  let  it3  =  shell  add ( res ,  it3 )  res</p><p>  让res = block：var res：seq [typeof（block：＃gentley重复的代码，用于获取表达式的类型。proc（）：auto = for IT0，在线（＆＃34; / etc / passwd＆＃34;）：让IT1 = Split（IT0，＆＃34;：＆＃34;  -  1）让stageok`Gensym10271 = Let Shell = IT1 [BackwardIndex（1）] 1＆lt; len（IT1）和endswith（shell，＆＃34; Bash＆＃34;）如果不是steionok` gensym10271：继续让它het3 = shell结果=（it0，IT1，IT3）（）[2]）]＃IT0中的实际实现（＆＃34; / etc / passwd＆＃34 ;）：让它=拆分（IT0，＆＃34;：＆＃34;  -  1）让stageok`gensym10267 = Let Shell = IT1 [BackwardIndex（1）] 1＆lt; Len（IT1）和endswith（shell，＆＃34; bash＆＃34;）如果不是stexok` gensym10267：继续让它3 = shell add（res，it3）res</p><p>      Full flow macro implementation can be seen here -it is a part of the test suite for the library, but a lot of comments from the article are still present.</p><p>      这里可以看到全流程宏实现 - 是图书馆测试套件的一部分，但仍然存在从文章中的大量评论。</p><p>  I tried to write the  test suitein a way that would make it easier to use as an example as well, and while for the most part itdoes not have such level of implementation comments, it could still be treated as an example on how to use this library.</p><p>  我试图用一个方式编写测试套件，这也可以更容易地用作榜样，而在大多数情况下它没有这样的实现评论，它仍然可以将其视为如何使用的示例图书馆。</p><p>  This library is still being developed - some minor bugs and inconsistencies could be expected, aswell as ergonomics improvements.Consequently, some internal implementation details (mutability of captured variables for example)can change in the future.When  view types implementationwould become a non-experimental feature, captures would be done using immutable views instead.</p><p>  该库仍在开发出来 - 可以预期一些小错误和不一致性，也可以作为符合人体工程学的改进。将来，一些内部实施细节（例如捕获的变量的可变性）可以在未来改变。当查看类型的实施时，可以改变实现的功能，捕获将使用不可变视图完成。</p><p>  I personally see this library as a stepping stone for adding pattern matching support in Nim core -thanks to unparalleled metaprogramming capabilities, even features like that can be tested in externallibraries before being included in the language itself (instead of making almost irreversible additionsand dealing with fallback/bad design choices later).This means, first and foremost, that DSL usability and ergonomics feedback is welcome, as well asdiscussions about parts that don’t seem partic</p><p>  我个人将此库视为一个踏脚石，用于在NIM核心中添加模式匹配支持 - 谢谢，以无与伦比的成分计算能力，甚至可以在包括在语言本身的情况下在externallibraries中测试（而不是制作几乎不可逆转的附加物和处理回退/糟糕的设计选择以后）。这意味着，首先，欢迎DSL可用性和人体工程学的反馈，以及关于似乎不粉刺的部分的assdussions</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nim-lang.org/blog/2021/03/10/fusion-and-pattern-matching.html">https://nim-lang.org/blog/2021/03/10/fusion-and-pattern-matching.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/nim/">#nim</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/matching/">#matching</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/阶段/">#阶段</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>