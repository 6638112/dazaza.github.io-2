<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>NIL在GO中被打字在实践中的理论和类型中 Nil in Go is typed in theory and sort of untyped in practice</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nil in Go is typed in theory and sort of untyped in practice<br/>NIL在GO中被打字在实践中的理论和类型中 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-01 19:49:48</div><div class="page_narrow text-break page_content"><p>I was recently reading  Down the Golang nil Rabbit Hole( via), andran into the statement part way through:</p><p>我最近读到了戈兰尼尔兔洞（Via），Andran进入了声明部分的方式：</p><p> So here’s a fun fact, Go has multiple “types” of  nil.Specifically, there are both typed and untyped  nil variables.</p><p> 所以这是一个有趣的事实，Go有多种“类型”的零。特殊地，有键入和没有型号的无变量。</p><p> Some of you reading this are now reaching for your keyboards ( cf), and that was my first reaction too. ButI think it&#39;s more interesting to talk about how someone could windup feeling that  nil is sometimes untyped, because Go&#39;s  nil isa little bit slippery when you combine it with other features anda necessary API for some things. So let&#39;s start with what  nilis in Go and how it behaves in some circumstances.</p><p> 你们中的一些人现在读到了你的键盘（CF），这也是我的第一次反应。努力谈论谈论某人有时会感到有时没有型号，因为Go＆＃39;当你将它与其他一些功能结合起来时，有时候会有一些有趣的感觉。所以让＆＃39;首先，在某些情况下，它的表现如何以及它的行为。</p><p> In code, a literal of &#39; nil&#39; effectively works as if it was anuntyped constant like &#39;0&#39; (although it&#39;s not a constant; it&#39;s a predeclared identifierwith special semantics that are sprinkled all through  thespecification). However, just likeuntyped constants, when you use  nil by assigning it to a variableor passing it as a function argument, the resulting Go value isalways typed, whether it is a pointer, function, slice, map, channel,or interface of some type.For concrete types that can be  nil (pointers, functions, slices,maps, and channels), the type of even these  nil values is readilyobserved. The   fmt package&#39;s  %Tverb will report it, for example, and you can examine this typethrough   reflect. However thisis not quite the case for interfaces.</p><p> 在代码中，文字＆＃39; nil＆＃39;有效地工作好像它是annunyped常数像＆＃39; 0＆＃39; （虽然它不是一个常数;它＆＃39; s一个通过特殊语义的预先录制标识符。但是，只要使用nil，通过将其分配给传递它作为函数参数的可变常量时，刚刚使用nil，所以它是某种类型的指针，函数，切片，映射，频道或界面。对于可以是nil的具体类型（指针，函数，切片，映射和频道），甚至可以读取这些数值的类型。例如，FMT＆＃39; S％TVERB将报告它，并且您可以检查此打字机反映。但是，这不是界面的情况。</p><p> Like most everything else in Go, interfaces are typed, includingthe famous empty interface,  interface{}, and as a result so areinterface values. An interface value that is  nil still has a type.However, this interface type (of interface values) is very hard toobserve dynamically (in code) because of another property of Go: when you convert one interface type to another interface type,the original interface type is lost. If an interface value is not nil, it has an underlying concrete type, which is preserved whenthe interface value is converted to another interface type (althoughthe original interface type is lost). But if the interface valueis  nil, there&#39;s no underlying concrete type and so there&#39;s noother type information to be preserved; you can&#39;t tell a  nil ofone interface type from a  nil of another interface type.</p><p> 就像其他大多数其他东西一样，键入界面，包括着名的空界面，接口{}，以及结果如此interface值。 in的接口值仍然具有类型。无论何种方式，此接口类型（接口值）都是非常硬的toobserve（在代码中），因为go的另一个属性：将一个接口类型转换为另一个接口类型时，原始类型接口类型丢失。如果接口值不是nil，它具有底层的具体类型，保留了界面值，将界面值转换为另一个接口类型（尽管原始接口类型丢失）。但是，如果界面价值零，则没有底层混凝土类型，所以有保留的其他类型的信息;您可以＆＃39; t告诉另一个接口类型的NIL OFONE类型。</p><p> Now we get to the subtle Go trap. Neither   fmt nor   reflecthave a magic exemption from the Go type system in order to acceptarbitrary Go types. Instead, they must use the Go escape hatch ofthe empty interface,  interface{}, which everything can be convertedto. But this means that  when you call  fmt or  reflect on aninterface value, you&#39;re performing an interface conversion, andas a result you lose the type of the original interface value. Forinstance, suppose you write code like this:</p><p> 现在我们到了微妙的去陷阱。 FMT都不是FMT，也不反映出来自Go类型系统的魔法豁免，以便接受近距离类型。相反，他们必须使用空界面的Go逃生舱口，接口{}，一切都可以转换为此。但这意味着当您呼叫FMT或反映Anterface值时，您＆＃39;重新执行接口转换，以及您丢失了原始接口值的类型。 Forinstance，假设您编写这样的代码：</p><p>  The  error type is an interface type. When you call  fmt.Printf,the  error interface value is converted to the  interface{}type, and  fmt.Printf now has no access to the fact that  e wasan  error; all it can report is the concrete underlying type, ifthere is one. If you call &#39; fred(nil)&#39;,  fmt winds up being passeda  nil value of type  interface{} and can only shrug about whattype that value originally was.</p><p>  错误类型是一个接口类型。调用fmt.printf时，错误接口值将转换为接口{}类型，并且fmt.printf现在无法访问E isan错误的事实;所有它可以报告的是混凝土底层类型，如果是一个。如果你打电话给＃39; fred（nil）＆＃39;，fmt in turned type interface {}的passeda nil值{}，只能耸耸听于最初值的whattype。 </p><p> (By extension, the  fmt &#39; %T&#39; verb can never tell you what interfacetype was being used. If you want to know that, you must pass apointer to the interface value and then &#39; %T&#39; that, which willreport things like &#39; *error&#39;. See  this playground example, which demonstrates thatthis does preserve the interface type for a  nil interface value,as you&#39;d expect.)</p><p>（通过扩展，fmt＆＃39;％t＆＃39;动词永远不会告诉你正在使用的interfaceType。如果您想知道，必须将Apointer传递给接口值，然后＃39;％t＆＃39;％t＆＃ 39;那个，哪个＆＃39; *错误＆＃39;请参阅此游乐场示例，这表明这确实保留了NIL接口值的接口类型，就像您＆＃39; D.）</p><p> In this sense,  nil interface values are untyped, in that theirtype is very hard to observe dynamically and check in practice inordinary Go code. Due to this, a lot of perfectly normal Go codewill tell you that such values have no type ( fmt&#39;s &#39; %T&#39; verbwill report their type as &#39; &lt;nil&gt;&#39;, for example).</p><p> 从这个意义上讲，nil interface值是没有型号的，因为他们的rype很难动态地观察并在实践中审视非凡的go代码。由于这一点，很多完全正常的Go Codewill告诉你，这些价值没有类型（FMT＆＃39; s＆＃39;％t＆＃39; verfiill报告他们的类型为＆＃39;＆＃39 ;， 例如）。</p><p> (Perhaps their type should be reported as &#39; interface{}&#39;, but thatship has sailed and it wouldn&#39;t be all that much more useful inpractice.)</p><p> （也许他们的类型应该报告为＆＃39;界面{}＆＃39;但是本身举行了，它不会成为更有用的志法士。）</p><p> The other way to put this is that  anything that takes  interface{}arguments can&#39;t distinguish between  nil values of differentinterface types, and by extension also can&#39;t distinguish betweencalled with a literal  nil and being called with an interface valuethat happens to be  nil (for example, because it&#39;s a value of(interface) type  error and there was no error). Both  fmt and reflect take  interface{} arguments and so are limited by this.If you&#39;re not aware of this indistinguishability, things can lookpretty puzzling (or you can get caught out by it).</p><p> 这样做的另一种方法是需要界面{}参数的任何东西可以＆＃39; t区分不同切接面类型的数量，并且通过扩展也可以＆＃39; t区分与文字零和value internal inactal碰巧是nil（例如，因为它＆＃39; sa值（接口）类型错误，没有错误）。 FMT和反映接口{}参数且由此受到限制。如果您＆＃39;重新意识到这种无法区分，事情可以寻找令人费解的（或者您可以通过它被删除）。</p><p> (This is another facet of  how sometimes a  nil is not a  nil, which is sufficiently common to have  a FAQ aboutit.)</p><p> （这是一个有时零的另一个方面有时不是nil，这足以拥有常见问题解答。） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoNilIsTypedSortOf">https://utcc.utoronto.ca/~cks/space/blog/programming/GoNilIsTypedSortOf</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/在实践中/">#在实践中</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/typed/">#typed</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>