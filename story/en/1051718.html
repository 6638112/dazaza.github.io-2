<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Asahi Linux（苹果硅上的Linux）进度报告：1月/ 2月2021年 Asahi Linux (Linux on Apple Silicon) Progress Report: January / February 2021</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Asahi Linux (Linux on Apple Silicon) Progress Report: January / February 2021<br/>Asahi Linux（苹果硅上的Linux）进度报告：1月/ 2月2021年 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 18:45:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/64627d3035326522de5594b6313b25e2.png"><img src="http://img2.diglog.com/img/2021/3/64627d3035326522de5594b6313b25e2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Welcome to the first Asahi Linux Progress Report! In this series we’ll be taking a page from the  Dolphin playbook and giving you monthly updates on the progress of the project.</p><p>欢迎来到第一个Asahi Linux进度报告！在本系列中，我们将从Dolphin Playbook中拍摄页面并为您提供项目进度的每月更新。</p><p> Bringing up support for a new system-on-chip on Linux is no small task! I hope this series will be educational to everyone and give you a glimpse of the behind-the-scenes work that goes into making Linux work on a brand new device. The original plan was to do separate updates for January and February, but things were moving so fast it was hard to call a cut-off point, so we ended up with a two-month update.</p><p> 对Linux上的新系统带来支持不是小任务！我希望这个系列能够向每个人提供教育，并让您一瞥在一个全新的设备上进行Linux工作的幕后工作。原计划是为了对1月和2月进行单独的更新，但事情正在移动这么快，很难呼叫截止点，所以我们最终有一个为期两月的更新。</p><p>  In this report, you will see the terms AArch64, ARM64, and ARMv8-A. AArch64 refers to the 64-bit ARM architecture instruction set; ARM64 is what Linux calls its support for 64-bit ARM; and ARMv8-A is the ARM CPU architecture specification that includes AArch64. The terms have subtly different meanings, but for our purposes you can mostly take them all to mean “64-bit ARM”.</p><p>  在本报告中，您将看到术语AARCH64，ARM64和ARMV8-A。 AARCH64是指64位ARM架构指令集; ARM64是Linux调用其支持64位手臂的支持; ARMv8-A是ARM CPU架构规范，包括AARCH64。这些术语具有巧妙的不同含义，但是为了我们的目的，您主要可以将它们所有人视为“64位手臂”。</p><p>  The Asahi Linux project officially kicked off at the beginning of the year, but at that time we were all waiting for one crucial piece: support from Apple for booting alternate kernels on Apple Silicon systems. While the feature had been documented and mostly implemented, there was one final missing piece of the puzzle: support for the  kmutil configure-boot command, which is what lets you install a non-Apple kernel. This didn’t stop us from making progress, however, as the first step to porting an OS to an undocumented platform is documenting it!</p><p>  Asahi Linux项目在年初正式启动，但是当时我们都在等待一个关键作品：来自Apple的支持，用于在Apple Silicon系统上启动替代核。虽然该功能已被记录并大多实现，但有一个最终丢失的拼图：对KMUTIL CONFIGURE-BOOT命令的支持，这是您安装非Apple内核的原因。这并没有阻止我们取得进展，然而，作为将OS移植到无证平台的第一步是记录它！</p><p> Apple Silicon Macs boot in a completely different way from PCs. The way they work is more akin to embedded platforms (like Android phones, or, of course, iOS devices), but with quite a few bespoke mechanisms thrown in. However, Apple has taken a few steps to make this boot process  feel closer to that of an Intel Mac, so there has been a lot of confusion around how things actually work. For example, did you know that Apple Silicon Macs cannot boot from external storage at all, in the traditional sense? Or that the bootloader on Apple Silicon Macs cannot show a graphical user interface at all, and that the “Boot Picker” is in fact a full-screen macOS app, not part of the bootloader?</p><p> Apple Silicon Mac从PC完全不同的方式启动。他们工作的方式更像是嵌入式平台（如Android手机，或当然，iOS设备），但是有很多定制机制抛出。但是，Apple采取了一些步骤来使这个启动过程感到更近英特尔MAC的那个，所以如何围绕事情实际上有很大的困惑。例如，您是否知道Apple Silicon Mac无法在传统意义上从外部存储器启动？或者Apple Silicon Mac上的引导加载程序根本不能显示图形用户界面，并且“启动选择器”实际上是全屏麦斯科座应用程序，而不是引导加载程序的一部分？</p><p> And so, before we were able to run our own kernels on these machines, we set out to map out  how the boot process works,  how partitions and volumes are laid out on the internal SSD, and also  how this all compares to a PC. This documentation is intended to not only be useful for our project, but also for any macOS users who want to better understand how their machines work. Some of the functionality and the underlying rationale for it (but not all) has since been documented in the  February 2021 version of the Apple Platform Security Guide.</p><p> 因此，在我们能够在这些机器上运行自己的内核之前，我们开始映射引导过程的工作原理，分区和卷如何在内部SSD上奠定，以及如何与PC进行比较。本文档不仅对我们的项目有用，而且对任何想要更好地了解他们的机器工作的摩托斯用户都是有用的。它的一些功能和潜在的理由（但不是全部）自2011年2月2021年的Apple Platform安全指南版本已被记录。</p><p>  Apple Silicon Macs have a boot process that is not based on any existing standard. Rather, it is a bespoke Apple mechanism that has slowly evolved from the early days of iOS devices. On the other hand, the rest of the 64-bit ARM world has largely converged on two competing standards:  UEFI +  ACPI (largely used by servers running Windows or Linux), and the  ARM64 Linux boot protocol +  DeviceTree (used on smaller systems, and also supported by  U-Boot and more). We need to choose one of these for Asahi Linux and figure out a way to “bridge” Apple’s world to our own.</p><p>  Apple Silicon Macs的启动过程不基于任何现有标准。相反，它是一个定制的Apple机制，从iOS设备的早期慢慢发展。另一方面，64位ARM世界的其余部分主要融合在两个竞争标准：UEFI + ACPI（主要用于运行Windows或Linux的服务器），以及ARM64 Linux Boot协议+ Devicetree（用于较小的系统，并由U-Boot等支持）。我们需要为asahi linux选择其中一个，并弄清楚“桥接”苹果世界的方式。 </p><p> UEFI and ACPI are complicated beasts usually only used for large ARM systems. The standards are largely controlled by committees at the  UEFI Forum. Unlike the x86 PC world, which is much more homogeneous, the ARM world is extremely diverse and  systems-on-chip have all kinds of designs with different requirements for describing the hardware contained within them. This means that adding support for a new SoC almost always requires amending these standards to add “bindings” for the bits of hardware that make it unique. For ACPI, this is costly and slow, which is why ACPI is almost never used on small embedded systems that don’t run Windows. It is not a viable option for us.</p><p>UEFI和ACPI通常只用于大型臂系统的复杂性野兽。标准主要受联盟论坛委员会的控制。与X86 PC世界不同，这是一个更加均匀的，ARM世界是极其多样化，片上系统的各种设计，具有不同要求的设计，用于描述其中包含的硬件。这意味着为新SoC添加支持几乎总是要求修改这些标准，以添加使其独特的硬件的“绑定”。对于ACPI来说，这是昂贵和慢的，这就是为什么ACPI几乎从未用于不运行Windows的小型嵌入式系统。这不是我们的可行选择。</p><p> The wide variety of smaller embedded ARM Linux systems almost invariably use the DeviceTree standard – for example, this is how most Android devices boot. Devicetrees are much simpler than ACPI, since a devicetree is purely a bunch of data describing the hardware, while ACPI tables are a combination of data and code. These days, the authority on devicetree bindings is the  documentation maintained inside the Linux kernel tree itself: this means that we can amend these standards at the same time as we write the Linux drivers themselves. Thus, Asahi Linux’s boot process will use this model.</p><p> 各种较小的嵌入式ARM Linux系统几乎总是使用Devicetree标准 - 例如，这是大多数Android设备启动的方式。 Devicetrees比ACPI更简单，因为Devicetree纯粹是一堆描述硬件的数据，而ACPI表是数据和代码的组合。如今，DeviceTree绑定的权限是Linux内核树本身维护的文档：这意味着我们可以在我们编写Linux驱动程序本身时同时修改这些标准。因此，Asahi Linux的引导过程将使用此模型。</p><p> Interestingly enough, Apple also uses their own version of a device tree on Apple Silicon, called Apple Device Tree! This is because both it and the open DeviceTree standard are based on the  Open Firmware specification, which is how many PowerPC systems boot, including  older Macs. Unfortunately, while this does mean ADTs are very familiar to any embedded Linux developer, we cannot use them directly: the binary format is different and cannot be converted automatically without having high-level information about what the data represents. On top of that, the actual bindings used for devices are very different. While Linux and macOS work the same way on PowerPC Macs and are directly compatible, Linux has seen over a decade of divergent evolution from Apple in the ARM space. Trying to unify Apple’s and Linux’s ideas of how device trees should work would be a nightmare.</p><p> 有趣的是，Apple还在Apple Silicon上使用自己版本的设备树，称为Apple Device Tree！这是因为它和打开的devicetree标准都基于开放的固件规范，这是许多PowerPC系统引导，包括较旧的Mac。遗憾的是，虽然这是一个嵌入式Linux开发人员对均匀熟悉的均匀，但我们不能直接使用它们：二进制格式不同，无法自动转换，而无需有关数据所代表的高级别信息。最重要的是，用于设备的实际绑定非常不同。虽然Linux和MacOS在PowerPC Mac上的工作方式和直接兼容，Linux在Apper空间中的Apple中有十年的分歧。试图统一Apple和Linux的想法，了解设备树的工作将是噩梦。</p><p> To adapt the Apple world into a devicetree world, we are developing  m1n1, a bootloader for Apple Silicon machines. Its goal is to take care of as many “Apple-isms” as possible, to make life as easy as possible for Linux or anything else downstream.</p><p> 为了使Apple World适应一个Devicetree World，我们正在开发M1N1，这是一个用于Apple硅机的引导加载程序。它的目标是尽可能多地照顾好“苹果isms”，使生活尽可能简单，或者在下游的其他任何东西。</p><p> You can prepend m1n1 to a Linux kernel (just using  cat m1n1.macho initrd.bin devicetree.dtb Image.gz &gt; m1n1-kernel.macho works for a minimal fixed-kernel install), install it on your Mac using Apple’s  kmutil tool, and it will do everything required to make Linux boot. When you boot Linux using m1n1, this is roughly what it does:</p><p> 您可以将M1N1预先添加到Linux内核（仅使用Cat M1n1.macho initrd.bin devicetree.dtb image.gz＆gt; m1n1-kernel.macho为最小固定内核安装工作），使用Apple的KMutil工具将其安装在Mac上，它将完成制作Linux启动所需的一切。使用M1N1引导Linux时，这大致是它的：</p><p> Reads the boot information that Apple’s bootloader, iBoot, has provided to it: this includes things like how much RAM is available and the address of the  framebuffer (the video memory being displayed on the screen) in RAM.</p><p> 读取Apple的Bootloader，IBoot提供给它的引导信息：这包括以下内容以及RAM中的帧缓冲区（屏幕上显示的视频内存的地址）。</p><p> Initializes the  Memory management unit. This is required to be able to use the CPU  caches, without which everything runs extremely slowly.</p><p> 初始化内存管理单元。这是能够使用CPU高速缓存所必需的，无论哪些一切都非常慢。 </p><p>  Disables the  watchdog timer. Without this, the Mac will spontaneously reboot after a minute or so, as it thinks the boot process has gotten stuck.</p><p>禁用看门狗定时器。没有这个，在一分钟左右后，Mac会自发重启，因为它认为启动过程已被卡住。</p><p> Figures out what it is going to boot: the Linux kernel, devicetree, and (optionally) the initramfs ramdisk containing boot-time applications, if they were appended to it.</p><p> 数字突出它将启动的内容：Linux内核，devicetree和（可选）initramfs ramdisk包含启动时应用程序，如果已被附加到它。</p><p> Initializes all the other CPU cores and applies the required chicken bits, then sets them up waiting in a “spin-table”, ready for Linux to take over.</p><p> 初始化所有其他CPU核心并应用所需的鸡位，然后在“旋转表”中设置它们，为Linux占用。</p><p> Takes information from the Apple Device Tree and customizes the provided devicetree template to match. This is used for settings that change from machine to machine and from version to version of Apple’s iBoot firmware, such as memory size, information about the framebuffer, a seed to initialize Linux’s random number generator, and more. m1n1 also adds some information of its own, such as the spin-table details and command-line arguments for the kernel, if any.</p><p> 从Apple设备树中获取信息，并自定义提供的DeviceTree模板以匹配。这用于从机器到机器的设置以及从版本到Apple的Iboot固件（如内存大小）的版本，如内存大小，有关FrameBuffer的信息，种子才能初始化Linux的随机数生成器等。 M1N1还添加了自己的一些信息，例如内核的旋转表详细信息和命令行参数，如果有的话。</p><p> The “spin-table” is one of two standards that Linux on ARM can use to turn on additional CPU cores in a devicetree world. Instead of relying on platform-specific drivers, there are two standard methods available that all platforms are expected to use. Spin-tables, which are the simplest one, just have the bootloader turn on all CPUs ahead of time and leave them waiting (“spinning”) in a loop. To release the CPUs from the loop, Linux writes a value to RAM telling them where to jump into the kernel. This is perfectly fine for simple platforms; the only real limitation is that CPUs cannot be completely stopped again, as taking over the CPUs from the bootloader is a one-shot deal. However, they can be put into various low-power modes using other mechanisms. We are using this method for now, and it is possible it is all we will ever need.</p><p> “旋转表”是两个标准之一，武器上的Linux可以用于在DeviceTree World中打开额外的CPU核心。而不是依赖特定于平台的驱动程序，而是有两个标准方法可以使用所有平台使用。旋转桌子，这是最简单的表，只需提前启动引导加载程序，并在循环中留下它们等待（“旋转”）。要从循环中释放CPU，Linux将值写入RAM，告诉它们在哪里跳入内核。这对于简单的平台非常好;唯一的实际限制是CPU无法再次完全停止，因为接管来自引导加载程序的CPU是单次交易。但是，它们可以使用其他机制投入各种低功耗模式。我们现在正在使用这种方法，这是我们将需要的一切。</p><p> The alternative is called “ PSCI”, and it is an ARM standard that is designed as a proper service that a system’s firmware can provide even while Linux is running, to allow the CPUs (and other components) to be controlled at runtime. Normally, this is done via code running at “EL3” (that’s the secure firmware, or TrustZone), or via a VM hypervisor running at “EL2” – OSes normally run at EL1. However, both EL3 and EL2 are optional features of ARMv8-A CPUs – and as it turns out, there is no EL3 support on the M1. EL2 is available, but we want to support VMs running under Linux, which requires running Linux itself as EL2 – so we can’t put another hypervisor above it. This means we can’t use PSCI today, because there is no standard interface for PSCI that works for us. In the near future, alternative mechanisms may be developed that allow us to use it. This might be necessary to support full-system sleep mode – though, if fine-grained power management is good enough, we might not need “true” full-system sleep to get very good battery life anyway (modern devices work very well with finer-grained sleep modes). Time will tell, and this is still an evolving area.</p><p> 替代品被称为“psci”，它是一个臂标准，它被设计为适当的服务，即系统的固件即使在Linux正在运行时也可以提供，以允许在运行时控制CPU（和其他组件）。通常，这是通过在“EL3”（即安全固件或TrustZone）上运行的代码完成的，或者通过在“EL2”的VM虚拟机管理程序 -  OS运行在EL1上运行。然而，EL3和EL2都是ARMV8-A CPU的可选功能 - 事实证明，M1上没有EL3支撑。 EL2可用，但我们希望支持在Linux下运行的VM，这需要将Linux本身运行为EL2  - 因此我们不能将另一种虚拟机管理程序放在上面。这意味着我们今天不能使用PSCI，因为没有为我们工作的PSCI的标准界面。在不久的将来，可以开发替代机制，使我们能够使用它。这可能是支持全系统睡眠模式的必要条件 - 尽管如此，如果细粒度的电源管理足够好，我们可能不需要“真正的”全系统睡眠以获得非常好的电池寿命（现代设备与更精细的工作非常好-Greated睡眠模式）。时间会告诉，这仍然是一个不断发展的地区。</p><p> Now, I said that we would be using devicetree – but that doesn’t mean we can’t use UEFI! ARM64 systems can boot using UEFI + devicetree, and this is needed to get a “PC-like” boot experience, with bootloaders such as GRUB and the typical flows for installing and upgrading kernels. But m1n1 does not support any of that, so what do we do? Thankfully, there is another piece that completes the puzzle:  U-Boot. U-Boot can boot like a Linux kernel – so you can boot U-Boot from m1n1 – and it itself can provide a good enough UEFI environment for GRUB and Linux.</p><p> 现在，我说我们会使用devicetree  - 但这并不意味着我们不能使用UEFI！ ARM64系统可以使用UEFI + DevicEtree引导，这是为了获得“类似于”PC的“启动体验，具有Bootloader（如Grub）和用于安装和升级内核的典型流程。但M1N1不支持任何一个，所以我们该怎么办？值得庆幸的是，还有另一部分完成拼图：U-Boot。 U-Boot可以像Linux内核一样启动 - 所以您可以从M1N1启动U-Boot  - 它本身可以为GRUB和Linux提供足够的UEFI环境。 </p><p> And so, most likely, the boot chain for Asahi Linux as used by end-users will be:</p><p>所以，最有可能的是，最终用户使用的Asahi Linux的启动链将是：</p><p>  Combined with the Apple-specific bits of the boot chain, the entire boot process ends up looking like this:</p><p>  结合靴子链的特定于苹果特定位，整个启动过程最终看起来像这样：</p><p> The SecureROM inside the M1 SoC starts up on cold boot, and loads iBoot1 from NOR flash</p><p> M1 SoC内的Securerom启动了冷启动，并从NOR闪存加载iboot1</p><p> iBoot1 reads the boot configuration in the internal SSD, validates the system boot policy, and chooses an “OS” to boot – for us, Asahi Linux / m1n1 will look like an OS partition to iBoot1.</p><p> Iboot1在内部SSD中读取引导配置，验证系统引导策略，并选择“操作系统”启动 - 对于我们来说，Asahi Linux / M1N1将看起来像对iBoot1的OS分区。</p><p> iBoot2, which is the “OS loader” and needs to reside in the OS partition being booted to, loads firmware for internal devices, sets up the Apple Device Tree, and boots a Mach-O kernel (or in our case, m1n1).</p><p> Iboot2是“操作系统加载器”，并且需要驻留在未启动的OS分区中，为内部设备加载固件，设置Apple设备树，并启动Mach-O内核（或在我们的情况下，M1N1）。</p><p> m1n1 parses the ADT, sets up more devices and makes things Linux-like, sets up an FDT (Flattened Device Tree, the binary devicetree format), then boots U-Boot.</p><p> M1N1解析ADT，设置更多设备并使Linux-lim-Live，设置FDT（扁平设备树，二进制DeviceTree格式），然后启动U-Boot。</p><p> U-Boot, which will have drivers for the internal SSD, reads its configuration and the next stage, and provides UEFI services – including forwarding the devicetree from m1n1.</p><p> U-Boot将具有内部SSD的驱动程序，读取其配置和下一个阶段，并提供UEFI服务 - 包括从M1N1转发DevicEtree。 </p><p> GRUB, booting as a standard UEFI application from a disk partition, works like GRUB on any PC. This is what allows distributions to manage kernels the way we are used to, with  grub-mkconfig and  /etc/default/grub and friends.</p><p>GRUB从磁盘分区启动作为标准的UEFI应用程序，就像任何PC上的GRUB一样。这是允许在我们习惯的方式管理内核的发行版，使用grub-mkconfig和/ etc / default / grub和friends。</p><p> Finally, the Linux kernel is booted, with the devicetree that was passed all the way from m1n1 providing it with the information it needs to work.</p><p> 最后，Linux内核被引导，使用从M1N1传递的DevicEtree，提供它所需的信息。</p><p> Phew! This might look a bit crazy to people coming from the PC world, but long boot chains like this are common on embedded systems (and in fact, “UEFI” on a typical PC includes multiple stages, it’s just that end-users don’t see them). For example, one possible boot chain for a DragonBoard 410c (a Qualcomm-based platform) might look like this:</p><p> ph！这可能对来自PC世界的人看起来有点疯狂，但是像这样的长靴链在嵌入式系统上很常见（实际上，“UEFI”在典型的PC上包括多个阶段，它只是最终用户没有看他们）。例如，蜻蜓410C的一个可能的启动链（基于Qualcomm的平台）可能如下所示：</p><p>  Note that we cannot replace iBoot2 (it requires an Apple signature), but our end-user install process will deal with automatically setting up a minimal “macOS” including iBoot2 and all the required support files, sufficient for the Apple boot process to recognize it as a bootable OS (but excluding the actual macOS kernel/filesystem). The installer isn’t ready yet, so for the time being developers experimenting with m1n1/Linux have to make a separate full macOS install and then replace its kernel. We’ve written a step-by-step  Quick Start Guide to guide those wanting to join us in this adventure.</p><p>  请注意，我们无法替换iboot2（它需要一个苹果签名），但我们的最终用户安装过程将自动设置一个最小的“麦斯科斯”，包括iboot2和所有必需的支持文件，足以识别它的Apple启动进程作为可引导的操作系统（但排除实际的MacOS内核/文件系统）。安装程序还没有准备就绪，因此由于开发人员尝试使用M1N1 / Linux必须进行单独的全麦斯科斯安装，然后替换其内核。我们写了一步一步的快速入门指南，以指导那些想要加入我们的冒险。</p><p> Right now, our main development workflow is to load Linux directly from m1n1, but Mark Kettenis is working with us on  U-Boot and OpenBSD support.</p><p> 现在，我们的主要开发工作流程是直接从M1N1加载Linux，但Mark Kettenis正在与我们一起使用U-Boot和OpenBSD支持。</p><p> But m1n1 isn’t just about running Linux. In fact, it isn’t even a bootloader at heart!</p><p> 但M1N1不仅仅是运行Linux。事实上，它甚至不是心脏病的靴子！</p><p>  m1n1 traces its past to  mini, which is a minimal environment that I wrote for the Nintendo Wii’s security CPU. It was useful for experimentation and as the back-end for BootMii – for those of you who own a Wii and are familiar with it, mini is what runs on the ARM CPU while you’re in the BootMii menu.</p><p>  M1N1将过去追溯到Mini，这是我为Nintendo Wii的安全CPU写的最小环境。它对于实验和BootMii的后端是有用的 - 对于拥有Wii并熟悉它的人来说，Mini是您在BootMii菜单中的时候在ARM CPU上运行的内容。 </p><p> What does that have to do with an Apple Silicon bootloader, you ask? Well, mini was really just a very simple piece of software that runs on bare-metal 32-bit ARM systems without any external libraries or dependencies. It makes for a nice, simple base on which to build bare-metal code, so we ported it to AArch64 and Apple Silicon and renamed it to m1n1. But more importantly, mini and m1n1 have a trick up their sleeves: thanks to mini’s legacy as firmware running on a  separate processor that needs to be controlled from the main CPU, and from past experiments with Wii hardware research, it has a built-in RPC proxy that works over a serial port. This means that you can “remote control” mini and m1n1 from a development computer, in real time. m1n1 lets you play with the M1 hardware using simple Python scripts running on any computer, or even from an  interactive shell. It would be best described as a hardware experimentation tool that just happens to also feature a Linux bootloader.</p><p>你问的是什么与Apple Silicon Bootloader有关？嗯，迷你真的只是一个非常简单的软件，在裸金属32位臂系统上运行，没有任何外部库或依赖关系。它为构建裸金属代码的一个很好的，简单的基础，因此我们将其移植到AARCH64和Apple芯片，并将其重命名为M1N1。但更重要的是，迷你和M1N1有一个诡计他们的袖子：由于迷你的遗留作为在需要从主CPU的独立处理器上运行的固件，并且从过去的实验与Wii硬件研究，它有一个内置的RPC代理在串行端口上运行。这意味着您可以实时从开发计算机中“遥控”迷你和M1N1。 M1N1允许您使用在任何计算机上运行的简单Python脚本使用M1硬件，甚至可以使用Interactive Shell。它将最好被描述为硬件实验工具，该工具刚刚发生在Linux Bootloader。</p><p> This makes for an awesome platform to learn more about the hardware and discover all of Apple’s proprietary features. For example,  this script tests a special Apple feature that adds support for a some x86-specific floating point configuration bits to their CPUs, which they use to speed up Rosetta x86 emulation.  This script searches for all Apple-custom CPU registers and prints their values and their access restrictions.  This script automatically figures out how those access restrictions can be customized by an Apple-proprietary hypervisor configuration register. And, of course,  this script will boot a Linux kernel for you, streamed in straight from the serial port.</p><p> 这使得一个很棒的平台来了解有关硬件的更多信息并发现Apple的所有专有功能。例如，此脚本测试了一个特殊的Apple功能，该功能将支持某些X86特定的浮点配置位对其CPU添加，它们用于加快Rosetta x86仿真。此脚本搜索所有Apple自定义CPU寄存器并打印它们的值及其访问限制。此脚本会自动介绍如何通过Apple专有的管理程序配置寄存器自定义这些访问限制。而且，当然，此脚本将为您启动Linux内核，直接从串行端口流式传输。</p><p> Booting an M1 Mac Mini into m1n1 takes about 7 seconds, and all of these scripts can be run interactively without rebooting (until you crash the machine). m1n1 can also  load itself, so the development cycle for m1n1 itself is also very fast: you can leave an old version of m1n1 installed with  kmutil and simply load the most recent one at runtime after a reboot.</p><p> 将M1 Mac Mini引导到M1N1需要大约7秒钟，并且所有这些脚本都可以在不重新启动的情况下以交互方式运行（直到您崩溃机器）。 M1N1也可以加载自身，因此M1N1本身的开发周期也非常快：您可以留下旧版本的M1N1，并只需在重新启动后在运行时加载最新的。</p><p> Using m1n1, we’ve been hard at work documenting Apple’s custom  ARM instructions, Apple-specific  system segisters, hardware such as the  Apple Interrupt Controller, and more.</p><p> 使用M1N1，我们在工作中一直很难记录Apple的自定义ARM指令，特定于Apple的系统Segisters，诸如Apple中断控制器等硬件等。</p><p> In the future, we will keep adding features to m1n1 to make it an even more powerful research tool. One particularly exciting goal is to turn it into a very thin VM hypervisor that can boot macOS, and intercept its accesses to the M1 hardware. This will allow us to investigate how Apple’s drivers work without having to disassemble them, which makes for a very legally-sound approach, and is also quite a lot more efficient than tracing through complex proprietary driver code. Some of you might recognize this approach as the same one used by  nouveau to successfully reverse engineer Nvidia GPUs – though in that case, they used the Linux drivers and modified the kernel only, instead of adding a hypervisor.</p><p> 在未来，我们将继续向M1N1添加功能，使其成为一个更强大的研究工具。一个特别令人兴奋的目标是将其转化为一个非常薄的VM虚拟机管理程序，可以启动麦克斯，并拦截其访问到M1硬件。这将使我们能够调查Apple的司机如何工作，而无需拆卸它们，这使得具有非常合法的方法，而且通过复杂的专有驱动程序代码还比追踪更效益。您中的一些人可能会认识到Nouveau以成功逆向工程师NVIDIA GPU的同一个方法 - 尽管在这种情况下，他们使用Linux驱动程序并仅修改内核，而不是添加虚拟机管理程序。</p><p> But wait – to do all this you need a serial port. Where’s the serial port on M1 Macs? I’m glad you asked!</p><p> 但等待 - 完成所有这些，您需要一个串行端口。 M1 Mac上的串行端口在哪里？我很高兴你问过！</p><p>  To do low-level bring-up work on a new system, it is almost indispensable to have a serial port. Serial ports, sometimes called  UART ports, are practically the simplest possible communications hardware, and make for a very convenient low-level debugging tool. Sending messages over a serial port only requires a couple of CPU instructions, so it can be set up very early, and serve as a text terminal for development.</p><p>  要在新系统上进行低级调动工作，但有一个串行端口几乎是必不可少的。串口，有时称为UART端口，实际上是最简单的通信硬件，并且为一个非常方便的低级调试工具制作。通过串口发送消息仅需要几个CPU指令，因此可以很早地设置，并用作文本终端进行开发。 </p><p> Of course, modern PCs used to have RS-232 serial ports, but those are long gone. On many embedded systems (such as most home routers), a lower-voltage serial port still exists internally, but you need to remove the case to access it on a connector, or as test points directly on the board. What about M1 Macs?</p><p>当然，现代PC用于拥有RS-232串行端口，但那些很长一段时间。在许多嵌入式系统（例如大多数家庭路由器）上，低压串行端口仍然在内部存在，但您需要删除该案例以在连接器上访问它，或直接在电路板上的测试点。 M1 Mac怎么样？</p><p> It turns out that M1 Macs do in fact have a serial port accessible on the outside of the case – over one of the USB-C ports! However, to enable it, you need to send some special commands over USB-PD. USB-PD (USB Power Delivery) is a protocol that runs over the “Configuration Channel” pin on Type C ports. As usual for USB standards, it is an overengineered behemoth that does a lot more than actually delivering power – not only is it used to configure voltages and identify chargers, but it’s also used to identify cable types, dongles, alternate modes such as DisplayPort, and, in this case, as a channel for Apple-proprietary configuration messages. These messages let us ask a Mac to expose its serial port on two pins of one particular Type C port. Other  neat features include the ability to reboot the system remotely (indispensable for fast development), put it into  DFU recovery mode, access internal buses such as  I²C, and more.</p><p> 事实证明，M1 MAC实际上具有串行端口，可以在壳体外部访问 - 超过其中一个USB-C端口！但是，要启用它，您需要通过USB-PD发送一些特殊命令。 USB-PD（USB电力传递）是一种在C型端口上的“配置通道”引脚上运行的协议。像往常一样，对于USB标准，它是一个超前的庞然大物，这比实际提供的电力更多 - 不仅用于配置电压并识别充电器，还用于识别电缆类型，加密窗，诸如DisplayPort等替代模式，并且，在这种情况下，作为Apple专有配置消息的频道。这些消息让我们要求Mac在一个特定类型C端口的两个引脚上公开其串行端口。其他简洁的功能包括重启系统远程重启的功能（不可或缺的快速开发），将其进入DFU恢复模式，访问内部总线，如I²C等等。</p><p> Our first solution to getting a serial port working on these Macs was  vdmtool: a DIY cable using an Arduino, a USB-PD PHY (interface) chip, and some kind of 1.2V serial port adapter. This is fine for those with DIY skills, but it is not very practical for those who are not used to building their own hardware. There are a number of annoyances: there are no good USB-PD PHY break-out boards with all the required Type C signals, 1.2V UART adapters are rare, etc.</p><p> 我们的第一个解决方案来获得这些MAC的串口是VDMTool：使用Arduino的DIY电缆，USB-PD PHY（接口）芯片，以及某种1.2V串口适配器。这对具有DIY技能的人来说很好，但对于那些不习惯建立自己的硬件的人来说并不是很实际的。有许多烦恼：没有良好的USB-PD PHY突破板，所有必需的C型信号，1.2V UART适配器是罕见的等。</p><p> Therefore, we came up with a second solution: if you happen to have  two M1 Macs, rejoice! All you need is a standard Type C cable (the SuperSpeed / USB 3.0 type) and  macvdmtool. This little macOS app lets you turn one M1 machine into a serial debug terminal for another, so you can run m1n1 scripts and boot Linux kernels directly from macOS. Apple’s APIs allow us to configure a Mac’s own port into serial mode, as well as send the required messages to configure the remote Mac into serial mode too, which makes all of this possible with no custom hardware whatsoever.</p><p> 因此，我们提出了第二种解决方案：如果您碰巧有两个M1 Mac，请高兴！所有您需要的是标准类型C线（Superspeed / USB 3.0类型）和MacVDMTool。这个小麦克斯应用程序允许您将一个M1机器转换为另一个M1机器，以便将M1N1脚本和引导Linux内核直接从MacOS运行。 Apple的API允许我们将MAC自己的端口配置为串行模式，并发送所需的消息，以将远程MAC配置为串行模式，这使得所有这些都可以使用无关紧要的硬件。</p><p> But of course, another Mac makes for quite an  expensive serial cable! Therefore, we will be developing a much more fully-featured USB-PD debug cable as an open hardware project, useful not only as a serial adapter for M1 Macs, but also to expose the other special features. In fact, it will go beyond Macs and also work as a debug interface for other devices, such as many Android phones. It will also work as a USB-PD development platform, capable of acting as a generic source (power supply) or sink (power consumer) and more, to experiment with USB-PD chargers and devices. It’s still in the  planning stages, but stay tuned for updates! Our goal is to eventually make this widely available to the community, so anyone can just click a button and buy one.</p><p> 但当然，另一个MAC为相当昂贵的串行电缆！因此，我们将以更全面的USB-PD调试电缆作为开放式硬件项目开发，不仅可以作为M1 Mac的串行适配器，而且还可公开其他特殊功能。事实上，它将超越MAC，也可以作为其他设备的调试接口，例如许多Android手机。它还将作为USB-PD开发平台，能够作为通用源（电源）或水槽（电源消费者）等，以试验USB-PD充电器和设备。它仍在规划阶段，但留在更新的情况下！我们的目标是最终使这一社区广泛使用，所以任何人都可以点击一个按钮并购买一个。</p><p> Finally, although a hardware serial port is the best solution for low-level debugging and development, it has limitations: it is quite slow, topping out at 150 kB/s. M1 Macs, however, can also behave as normal USB devices (like an iPhone, for example), and we can make them show up as a USB-serial device (CDC-ACM) that works without drivers on most OSes. This gives us the full bandwidth of USB, and the convenience of being able to use a normal Type C cable (or Type C to Type A cable) to just connect from any other computer. USB also provides flow control, which means that no data is lost when the receiving side </p><p> 最后，虽然硬件串行端口是低级调试和开发的最佳解决方案，但它有局限性：它非常慢，速度为150 kb / s。然而，M1 Mac也可以表现为正常的USB设备（例如iPhone），例如，我们可以使它们显示为USB串行设备（CDC-ACM），在大多数OS上没有驱动程序。这为我们提供了USB的完整带宽，并且能够使用正常类型C电缆（或键入C电缆）的便利性，以便与任何其他计算机连接。 USB还提供流量控制，这意味着在接收方时不会丢失数据</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://asahilinux.org/2021/03/progress-report-january-february-2021/">https://asahilinux.org/2021/03/progress-report-january-february-2021/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>