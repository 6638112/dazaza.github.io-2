<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么很难从根本上改进编程（2017） Why Programming Is Hard to Fundamentally Improve (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Programming Is Hard to Fundamentally Improve (2017)<br/>为什么很难从根本上改进编程（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 15:27:03</div><div class="page_narrow text-break page_content"><p>One of the curious things about being human is the ability to hold two contradictory views simultaneously. When I’m in analysis mode I try to understand what market, technical and social forces have lead to the status quo. To do this effectively, or at least to induce useful principles for later use, you have to believe that things are the way they are for good reasons. As soon as I put my innovator hat on however, I get all jazzed up and think “screw that! X would be so much better if Y”. I’ve learned over the last year that balancing these two perspectives is essential to an inventor.</p><p>关于人类的好奇之处之一是能够同时持有两种矛盾的观点。当我处于分析模式时，我试图了解是什么市场，技术和社会力量导致了现状。为了有效地做到这一点，或者至少诱导出有用的原则供以后使用，您必须相信事情是有充分理由的。但是，当我戴上创新帽时，我全神贯注，并认为“拧紧！如果Y”，X会好得多。我在去年了解到，平衡这两种观点对于发明家至关重要。</p><p> This week I watched Bret Victor’s  Future of Programming lecture from July 2013 and it compelled me to put these thoughts down on paper. During the lecture, Bret uses an overhead projector and pretends its 1973. He proudly presents the latest in programming research for the time and explains why it’d be really silly if we aren’t using them in 40 years. To Victor’s credit he remains in character the whole time as he satirically paints the ideal world we’ll soon enter — one the audience knows doesn’t really exist.</p><p> 本周，我观看了Bret Victor从2013年7月开始的“编程的未来”演讲，这迫使我将这些想法记录在纸上。在演讲中，布雷特（Bret）使用一台投影仪，并假装是1973年。他自豪地介绍了当时最新的编程研究，并解释了为什么如果我们40年不使用它们，那真是愚蠢。值得赞扬的是，维克托始终讽刺地描绘着我们即将进入的理想世界，这始终是他的角色-观众知道那真的不存在。</p><p> The future Bret showed off included direct manipulations of the output (result) instead of the code, programming via constraints/goals, spatial (visual) programming paradigms, and massively parallel programming approaches. Declarative programming, functional programming, microservice architectures and WYSIWYG editors check some of those boxes, but not nearly at the level of their potential. All that being said, there’s no argument against real progress having been made the last 40 years, just not the progress many expected.</p><p> 未来的Bret展示了包括直接操纵输出（结果）而不是代码，通过约束/目标进行编程，空间（可视）编程范例以及大规模并行编程方法。声明式编程，函数式编程，微服务体系结构和所见即所得的编辑器选中了其中的某些复选框，但程度不高。话虽这么说，过去40年没有取得真正进展的论据，只是没有许多人预期的进展。</p><p> So now I’ll put on my analysis hat and work through why the art of programming is so hard to advance beyond its current levels.</p><p> 因此，现在我要戴上分析帽，研究为什么编程艺术如此难以超越当前水平。</p><p>  Many blame the lack of advancements on developers. We built shinny thing X, but developers are too arrogant, stubborn, busy, dismissive or all of the above to adopt it. I’ve even heard people accuse developers of selfishly protecting their future job prospects by trying to stifle the adoption of new programming mediums. Heck, I’ve said this before…</p><p>  许多人指责开发人员缺乏进步。我们构建了灵巧的东西X，但是开发人员过于自大，固执，忙碌，不屑一顾，或者以上所有这些都不适合采用。我什至听说人们指责开发人员试图抑制新编程介质的采用，从而自私地保护自己的未来工作前景。哎呀，我之前已经说过了……</p><p> ^ This is just wrong. In my experience developers are very rational beings. Their job is to find the most efficient way of solving problems every single day and if you create a tool that provides that they’ll be all over it. They’ll even volunteer their time to help you build it for free. If you move forward accepting that developers are mostly rational actors and have good reasons for adopting something / not adopting something you can learn a lot to inform future design.</p><p> ^这是错误的。以我的经验，开发人员是非常理性的人。他们的工作是寻找每天解决问题的最有效方法，并且如果您创建一种工具来解决问题，那将是无所不在。他们甚至会自愿花时间帮助您免费构建它。如果您继续接受开发人员主要是理性的行为者并且有充分的理由采用某些东西/不采用某些东西，那么您可以学到很多东西来为将来的设计提供信息。</p><p> So I did that. I actually sat down with people over the last 3 months and asked them why they failed to adopt a variety of tools. I overwhelmingly got rational explanations to why switching to something new was irrational.</p><p> 所以我做到了。在过去的三个月中，我实际上与人们坐下来，问他们为什么不采用各种工具。我绝大多数都得到了理性的解释，来解释为什么改用新东西是不合理的。 </p><p>  Imagine you’re building a log cabin by hand with a bad, but usable hammer. When you’re 90% of the way finished a magical genie comes and offers you a better hammer. Great! But there’s a tradeoff: If you take the new shinny hammer, you have to start the house from scratch…oh and he turns back humanity to the stone age. You can get your new hammer, but you’ll have to do without bandsaws, your pickup truck, and yes, nails.</p><p>想象一下，您正在用一个坏的但可用的锤子手动建造一个小木屋。当您完成90％的工作时，神奇的精灵就会出现，并为您提供更好的锤子。大！但是需要权衡：如果您使用新的光亮的锤子，就必须从头开始建造房子……哦，他将人类带回了石器时代。您可以买到新的锤子，但必须没有带锯，皮卡车和钉子。</p><p>  That parable emerged from summarizing all the interviews I conducted and highlights the frustrations developers have had with many of the new ‘solve all your problems’ tools they’ve tried. For context these tools fit into two categories: new programming languages including some flow &amp; graph based paradigms and no-code visual builders.</p><p>  这个寓言来自于对我进行的所有采访的总结，并突显了开发人员对他们尝试使用的许多新“解决所有问题”工具的挫败感。就上下文而言，这些工具分为两类：新的编程语言，包括一些流程和应用程序。基于图的范例和无代码的可视化构建器。</p><p> There are two areas of value to consider when choosing a programming paradigm: the developer experience of the [language, tooling, GUI] and the strength of the ecosystem (what common problems have been solved already). Many of the new paradigms, while often built on sound principles, miss out on the massive body of work that already exists is language X. How do you weight these two areas when picking your paradigm? 30–70? 90–10? 1–99? Most people I spoke with rated the ecosystem as 2–3x more important than DX.</p><p> 选择编程范例时，需要考虑两个价值领域：[语言，工具，GUI]的开发人员经验和生态系统的实力（已经解决了哪些常见问题）。许多新范例虽然经常建立在合理的原则上，却错过了X语言的大量存在。在选择范例时，您如何权衡这两个领域？ 30–70？ 90-10？ 1–99？与我交谈过的大多数人都认为，生态系统比DX重要2到3倍。</p><p> Tool-builders usually only focus on DX and [assume, hope, pray] that a community comes along and builds an ecosystem. This still can happens, but it was much much more common in the 90s than it is today. There are network effects in programming and a beautiful virtuous cycle quickly emerges among the most used tools. When a user shares functionality openly it makes paradigm more capable, which attracts new users, who continue to improve that paradigm. Boom! Node module for everything.</p><p> 工具构建者通常只关注DX，并[假定，希望，祈祷]社区出现并建立生态系统。仍然可能发生这种情况，但是在90年代，这种情况比今天更为普遍。在编程中会产生网络效应，并且在最常用的工具中很快就会出现一个美好的良性循环。当用户公开共享功能时，它将使范式更加强大，从而吸引了不断改进该范式的新用户。繁荣！一切的节点模块。</p><p> When you look at the languages that have really caught on recently, they tend to share one thing in common: they tap into an existing body of work. Look at TypeScript, the most popular language released after 2000, which interoperates with Javascript. Then there’s Swift, the second most popular language released after 2000. Just imagine where Swift would be today if it hadn’t been interoperable with Objective-C and the Cocoa legacy or if TypeScript’s ecosystem was a blue ocean from day one.</p><p> 当您查看最近真正流行的语言时，它们往往有一个共同点：它们利用现有的工作体。请看TypeScript，它是2000年后发布的最流行的语言，可与Javascript互操作。然后是Swift，它是2000年之后发布的第二流行语言。请想象一下，如果Swift无法与Objective-C和Cocoa遗留系统互操作，或者TypeScript的生态系统从一开始就是一片蓝海，它将成为当今的今天。</p><p> There are consequences for tool makers building an entirely new base abstraction, be it visual, text based or otherwise. If you choose not to interoperate with an existing ecosystem, you or your community will need to spend years coming up from the stone age to modernity. Programming is just learning to use a bunch of stacked abstractions. Even if you have an objectively better base abstraction, one that would have clearly won out over everything else had it been introduced in 1992, people will have few incentives to adopt it if there’s no ecosystem.</p><p> 对于工具制造商来说，建立一个全新的基础抽象（包括视觉，基于文本或其他方式）会产生后果。如果您选择不与现有的生态系统进行互操作，那么您或您的社区将需要花费数年的时间，从石器时代到现代。编程只是学习使用一堆堆叠的抽象。即使您拥有客观上更好的基础抽象（如果在1992年引入它，它显然会胜过其他一切），但如果没有生态系统，人们几乎没有动力去采用它。</p><p>  Most people complete the phrase “Sunk cost _____” with “fallacy”. The classic economics thought experiment usually involves a couple staying at a concert they hate just because they paid face value for the tickets. An enlightened economist would, as the story goes, leave as soon as they became unhappy with the concert and reclaim a few precious hours. But if you had to pay $50k, $50M or $5B to leave the concert early, you’d probably stay. When the switching costs are that high, there’s good reason to stay and the largest employers of programmers in the world have enormous switching costs. This keeps mainstream programmers anchored to the status quo.</p><p>  大多数人用“谬误”来完成“沉没成本_____”一词。经典的经济学思想实验通常涉及一对夫妇，他们只是因为为门票支付了票面价值而讨厌他们参加的音乐会。随着故事的发展，开明的经济学家会在对演唱会不满意时离开，并重新度过几个宝贵的时间。但是，如果您必须支付$ 50k，$ 50M或$ 5B提早离开音乐会，您可能会留下来。当转换成本如此之高时，有充分的理由留下来，而世界上最大的程序员雇主则拥有巨大的转换成本。这样可以使主流程序员始终保持现状。 </p><p> This is another completely rational choice developers make when sticking to the paradigms they know. The combined costs of hiring new people, training, rewriting the code, and the opportunity cost of choosing these actions over improving your product almost always outweigh the benefits of making the change.  Joel has a classic article about code rewrites that expands on this more.</p><p>这是开发人员在坚持他们所知道的范例时所做的另一种完全理性的选择。雇用新员工，培训，重新编写代码的总成本，以及在提高产品质量方面选择这些措施的机会成本，几乎总是超过进行更改的收益。 Joel撰写了一篇经典的有关代码重写的文章，对此进行了进一步的扩展。</p><p> Young companies without much in the way of legacy or those with no other choice have the luxury of picking new paradigms, but few of these companies end up becoming incumbents. Those who do make it are the kingmakers. Both Facebook and Twitter were first built on technologies that were inadequate for their eventual scale (PHP and Ruby). Facebook became so attached to PHP that they enhanced the language to suit their needs with Hack and other tools. Similarly, Twitter switched over to Scala which one could argue is a key reason for Scala’s mainstream success.</p><p> 没有太多传统或没有其他选择的年轻公司可以选择新的范例，但是这些公司中很少有最终成为老牌公司。做到这一点的人就是国王。 Facebook和Twitter最初都是基于最终规模不足的技术（PHP和Ruby）构建的。 Facebook对PHP的依恋如此之深，以至于他们通过Hack和其他工具增强了语言以适应其需求。同样，Twitter转到了Scala，有人可能会说这是Scala取得成功的关键原因。</p><p>  Tool makers must strike a balance between learnability and productivity. A visual programming environment like MIT’s  Scratch is incredibly learnable. I’ve seen 4-5 year old kids build games with it after just a few hours. The drag/drop interface and shape based constraints are really easy to learn and prevent Scratch from ever being in a broken state. This is great for kids and individuals trying to learn programming.</p><p>  工具制造商必须在学习能力和生产率之间取得平衡。像MIT的Scratch这样的可视化编程环境是令人难以置信的学习。我已经看到4-5岁的孩子在几个小时后就可以用它来制作游戏。拖放界面和基于形状的约束非常易于学习，可以防止Scratch处于断裂状态。这对于尝试学习编程的孩子和个人非常有用。</p><p> The same things that make Scratch easy to learn also make it an unproductive environment for more serious programmers. For a professional, programming with drag and drop is way slower than keying in code — that’s just a fact.</p><p> 使Scratch易于学习的相同因素也使它对于更认真的程序员来说是一个无用的环境。对于专业人士而言，拖放编程要比键入代码要慢得多，这是事实。</p><p> These tradeoffs must be considered whenever building a new tool. If you build something super learnable that is not productive you’ll get a lot of praise, but little follow through. If you build something that’s too difficult to learn, but very productive you’ll turn a lot of people off. To reach mainstream programmers you need to make something that is both learnable and productive.</p><p> 每当构建新工具时，都必须考虑这些折衷。如果您开发的东西没有学到任何东西，但会产生很多赞誉，但很少有后续行动。如果您构建的东西太难学了，但效率很高，那么您就会被很多人拒之门外。要吸引主流程序员，您需要做出既可学习又富有成效的东西。</p><p> I think most of the stalled innovations in programming focused disproportionally on learnability. The problem is, within a few weeks of using any paradigm developers usually have built a repository of habits that keep them from making mistakes. For instance, if a new visual logic builder prides itself on preventing all syntax errors, that’s really cool, but most developers have learned to do that automatically.</p><p> 我认为大多数停滞不前的编程创新都过度地关注可学习性。问题是，在使用任何范式的几周内，开发人员通常会建立一个习惯库，以防止他们犯错。例如，如果新的视觉逻辑构建器以防止所有语法错误为荣，那确实很酷，但是大多数开发人员已经学会了自动执行此操作。</p><p> Truth is, every tool you have ever used is flawed and every new tool will also be flawed. Humans subconsciously come up with ways to cope with their tools so they can keep themselves focussed on the bigger conceptual issues. That isn’t going to change anytime soon. If professionals already have habits in place to cope with things that have been made easier/more learnable by new tooling, those new tools do not have much value to them. It’s like offering a 40 year old who’s been driving manual her whole life an automatic car — yeah that’s great, but it’s not needed and she certainly won’t pay a premium for it to be included.</p><p> 事实是，您曾经使用过的每个工具都存在缺陷，并且每个新工具也将存在缺陷。人类下意识地想出了应对工具的方法，这样他们就可以专注于更大的概念问题。这不会很快改变。如果专业人员已经习惯了使用新工具使工作变得更容易/更易学的事情，那么这些新工具对他们就没有太大价值。这就像给一个40岁，一生一直在手动驾驶自动汽车的人－是的，这很棒，但这不是必需的，而且她当然不会为此付出任何代价。 </p><p>   Things have been getting better. The growth has just been in the ecosystems and not the paradigms themselves. We’ve been building this amazing tower of abstraction since the early days of programming that provide really useful abstractions for things like:</p><p>情况已经越来越好。增长只是在生态系统中，而不是范式本身。从编程的早期开始，我们就一直在构建这座令人惊叹的抽象塔，为诸如以下内容提供真正有用的抽象：</p><p> Configuring a massive cluster of servers is done with a short text file instead of an army of humans wandering through a data center</p><p> 配置大型服务器集群是通过短文本文件完成的，而不是一群人在数据中心中徘徊</p><p>  Now back to the conflict I mentioned earlier between seeing why things are the way they are and believing they can be changed. There are solid rational reasons why programming has not fundamentally changed over the last few decades. Any aspiring innovator who wants to change this needs to first understand why things are the way they are, and then use those insights to their advantage.</p><p>  现在回到前面我提到的在理解事物为何如此运行与相信它们可以改变之间的冲突。在过去的几十年中，编程没有发生根本变化，这有很合理的理由。任何想改变这一现状的有抱负的创新者都需要首先了解事物之所以如此的原因，然后利用这些见解来发挥其优势。</p><p> A fair criticism can be lodged in support of pure, unencumbered innovation. It can be argued that it’s wise to design like its day one and not worry about all these real world constraints. That kind of thinking has not worked with programming because the total value of the entire programming ecosystem is stored mostly in the useful abstractions that have been built and not the tools themselves. The same is true for purely conceptual fields like philosophy and mathematics. You can change the notation or the written language, but at the end of the day the ideas are what hold the real value.  The legacy is the value, it can’t be thrown out.</p><p> 可以提出公正的批评来支持纯粹，不受阻碍的创新。可以说，像第一天那样进行设计是明智的，不必担心所有这些现实世界的限制。这种想法不适用于编程，因为整个编程生态系统的总价值主要存储在已构建的有用抽象中，而不是工具本身中。对于纯粹的概念领域，例如哲学和数学，也是如此。您可以更改表示法或书面语言，但总而言之，创意才是真正的价值所在。遗产就是价值，它不能被抛弃。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://aidancunniffe.com/why-programming-is-hard-to-fundamentally-improve-4101612d4ad9">https://aidancunniffe.com/why-programming-is-hard-to-fundamentally-improve-4101612d4ad9</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/改进/">#改进</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hard/">#hard</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>