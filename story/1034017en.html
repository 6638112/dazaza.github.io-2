<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>皮朱尔：迈向1.0</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">皮朱尔：迈向1.0</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 20:58:11</div><div class="page_narrow text-break page_content"><p>After fixing the performance and scalability problems, we’re on our way to getting a stable Pijul. In this post, I explain what I’ve been up to in the recent months.</p><p>在解决了性能和可伸缩性问题之后，我们就可以获得一个稳定的Pijul了。在这篇文章中，我解释了近几个月来我一直在做的事情。</p><p>  This blog post contains documentation about Pijul. Pijul is licensed under the Gnu GPL-2.0 or any later version at your convenience.</p><p>这篇博文包含有关Pijul的文档。Pijul根据GNU GPL-2.0或任何更高版本在您方便的情况下获得许可。</p><p> Therefore, if after reading this post, you independently rediscover the algorithms presented here, that’s ok, but you must still license your “independent rediscovery” under the Gnu GPL-2.0 license, and cite the sources (for instance this post). This also applies if that rediscovery happens in the future, including in zero, one or more years.</p><p>因此，如果在读完这篇文章后，你独立地重新发现了这里给出的算法，那是可以的，但你仍然必须在Gnu GPL-2.0许可下授权你的“独立重新发现”，并引用其来源(例如这篇文章)。如果这种重新发现发生在未来，包括零年、一年或更多年后，这也同样适用。</p><p>  Pijul has always been advertised as a research project, trying to implement a theory of patches that would be sound and fast. This is an ambitious goal, and became even more ambitious than initially envisioned.</p><p>Pijul一直被宣传为一个研究项目，试图实施一种可靠而快速的补丁理论。这是一个雄心勃勃的目标，甚至比最初设想的还要雄心勃勃。</p><p> One of the hardest challenges is that source code is by essence stateful, which makes it much harder to iterate over algorithm designs, like normal research projecst need to. For example, in order to get from our last published version to our current design, we have gone through many different variants, and there wasn’t much to publish.</p><p>最困难的挑战之一是，源代码本质上是有状态的，这使得迭代算法设计变得更加困难，就像普通研究项目需要的那样。例如，为了从上一次发布的版本到现在的设计，我们经历了许多不同的变体，没有太多可发布的内容。</p><p> Moreover, the UX aspect is what matters most in the end, and testing it on a real world project is the only way to get it there. However, unlike in a compiler, where bootstrapping is done one step at a time, and previous versions are always available to compile your current one, a version control system has the additional problem that the previous versions might not always be easily accessible if there is a bug.</p><p>此外，最终最重要的是UX方面，而在现实世界的项目中测试它是实现它的唯一途径。但是，在编译器中，引导是一步完成的，并且以前的版本总是可用于编译当前的版本，与此不同的是，版本控制系统有一个额外的问题，即如果有错误，以前的版本可能并不总是很容易访问。</p><p> One of the criticisms I’ve heard since I realised that better datastructures were possible is that I was “working secretely”. I certainly understand this feeling, but this is based on a misunderstanding of how research works. When I first had the idea that I’m explaining in this post, I realised that a complete rewrite would be needed. But for a very long time, almost nothing other than unusable, unreadable prototypes happened.</p><p>自从我意识到更好的数据结构是可能的之后，我听到的批评之一就是我在“秘密工作”。我当然理解这种感觉，但这是基于对研究如何运作的误解。当我第一次有了我在这篇文章中解释的想法时，我意识到需要彻底重写。但在很长一段时间里，除了不可用、不可读的原型，几乎什么都没有发生。</p><p> Back then, there wasn’t much to show, since it wasn’t even clear that the basic datastructure would work. And even when they started working at a large enough scale, it took me quite a bit of testing on large repositories before they started actually working.</p><p>那时候，没有什么可展示的，因为甚至不清楚基本的数据结构是否可以工作。甚至当他们开始以足够大的规模工作时，在他们真正开始工作之前，我也花了相当多的时间在大型存储库上进行测试。</p><p> This also implies that there wasn’t much to show for quite a while, since the new algorithm wasn’t usable until very recently, and any repository started before now would have become obsolete in a matter of days.</p><p>这也意味着在相当长的一段时间内没有什么可展示的，因为新算法直到最近才可用，而在此之前启动的任何存储库都将在几天内过时。</p><p> There were also  persoprofessional reasons for this silence, described at the end of this post.</p><p>这篇文章的结尾处描述说，这种沉默也有非常专业的原因。</p><p>    One of these projects is Sanakirja, which is “just” a key-value store, but has the extra feature that databases can be cloned efficiently. I would have loved to just use an existing library, but there just isn’t any that has this cloning feature. However, the scope of Sanakirja is still quite modest, it does one thing and does it well. Obviously, it took some time to find the memory-management bugs, but I have good confidence that this is now done.</p><p>其中一个项目是Sanakirja，它“仅仅”是一个键值存储，但它还有一个额外的功能，即可以高效地克隆数据库。我很乐意只使用现有的库，但没有任何库具有这种克隆功能。然而，Sanakirja的范围仍然相当温和，它做了一件事，做得很好。显然，找到内存管理错误花了一些时间，但我很有信心现在已经找到了。</p><p> In previous releases of Pijul, databases were implemented with a single mmapped file containing the binary representation of B Trees. Despite their lower writing performance (compared to alternatives such as  Log-structured merge-trees), and the complexity of the code for deletions, B Trees are very well suited to this use case: indeed, since they are trees, reference-counting the nodes is enough to implement efficient clones.</p><p>在Pijul的以前版本中，数据库是使用包含B树的二进制表示形式的单个mmaps文件实现的。尽管B树的写入性能较低(与Log-Structure Merge树等替代方案相比)，而且删除的代码也很复杂，但B树非常适合这种用例：实际上，因为它们是树，所以对节点进行引用计数就足以实现高效的克隆。</p><p> One of the remaining issues was that in order to grow the database, we needed to un-mmapped the file, grow it, and mmap it again. Since applying a single change in Pijul must be an atomic operation, we needed to cancel the transaction when that happened, and restart it with a bigger file.</p><p>剩下的问题之一是，为了扩大数据库，我们需要取消mmap文件的映射，使其增长，然后再次映射它。由于在Pijul中应用单个更改必须是原子操作，因此当发生更改时，我们需要取消事务，并使用更大的文件重新启动它。</p><p> Another issue is that I wanted the next libpijul to compile on platforms that don’t have mmap, such as WASM. However, if reallocating an mmapped file has a very low complexity (even though it does have a non-zero cost in terms of system calls), reallocating a chunk of memory often requires copying everything. This completely defeats the point of the algorithms in Pijul, which rely on a particular representation of the datastructures on the disk.</p><p>另一个问题是，我想让下一个libpijul在没有mmap的平台上编译，比如WASM。然而，如果重新分配一个mmaps文件的复杂性非常低(即使它在系统调用方面的成本不是零)，重新分配一块内存通常需要复制所有内容。这完全违背了Pijul中的算法的观点，该算法依赖于磁盘上数据结构的特定表示形式。</p><p> The main innovation in Sanakirja 0.13 is to use a vector of memory blocks (either in memory or mmapped from a file), of exponentially-increasing size. The overhead is just one extra indirection, the complexity of adding items is the same (since the operation of creating an extra block is $O(1)$). The exponentially-increasing sizes mean that the allocated memory is always at least half-full.</p><p>Sanakirja 0.13中的主要创新是使用大小呈指数增长的内存块(在内存中或从文件中映射)向量。开销只是一个额外的间接开销，添加项的复杂性是相同的(因为创建额外块的操作是$O(1)$)。指数级增长的大小意味着分配的内存始终至少是半满的。</p><p>  The other one is Thrussh. That library implements the SSH protocol, and tries to handle a number of key formats. The former is a surprisingly easy goal, and keeping up with Tokio versions has historically been the hardest bit, while the latter is the most horrendous hydra-like task, with new heads and legacy formats showing up every time you think you’re done.</p><p>另一个是特鲁什。该库实现了SSH协议，并尝试处理许多密钥格式。前者是一个出人意料的简单目标，从历史上看，跟上Tokio的版本是最困难的，而后者是最可怕的类似九头蛇的任务，每次你认为你完成了，新的头部和遗留的格式就会出现。</p><p>  Old-style repositories represented a single file by a directed graph $G = (V, E)$ of lines, where each vertex $v\in V$ represented a line, and an edge from $u \in V$ to $v\in V$, labelled by some change (also called patch) number $c$, could be read as “according to change $c$, line $u$ comes before $v$”.</p><p>旧式存储库用有向图$G=(V，E)$表示单个文件，其中V$中的每个顶点$v\代表一条线，V$中的$u\到V$中的$v\的一条边，由某个变化(也称为补丁)编号$c$标记，可以理解为“根据变化$c$，行$u$在$v$之前”。</p><p> This means that changes could introduce vertices and lines, as in the following example, where a line $D$ is introduced between $A$ and $B$:</p><p>这意味着更改可能会引入顶点和线，如下例所示，其中在$A$和$B$之间引入了线$D$：</p><p>  Here, the thick line represents the change from the file containing the lines $A$, $B$, $C$ to the file with the new line $D$.An important feature to note is that  vertices are uniquely identified, by the hash of the change that introduced them, along with a position in that change. This means that two lines with the same content, introduced by different changes, will be different. It also means that a lines keeps its identity, even if the change is applied in a totally different context.</p><p>这里，粗线表示从包含行$A$、$B$、$C$的文件到包含新行$D$的文件的更改。需要注意的一个重要特性是，顶点由引入它们的更改的散列以及该更改中的位置唯一标识。这意味着，内容相同的两行，由不同的变化引入，将是不同的。这也意味着，即使在完全不同的上下文中应用更改，线条也会保持其身份。</p><p> Moreover, this system is append-only, in the sense that  deletions are handled by a more sophisticated labelling of the edges. In the example above, if we want to delete line $D$, we just need to make a change mapping the edge introduced by $c_0$ to a deleted edge, which we label by the name $c_1$ of the change that introduces it:</p><p>此外，这个系统是仅附加的，从这个意义上说，删除由更复杂的边缘标签来处理。在上面的示例中，如果我们想删除行$D$，我们只需要进行更改，将$c_0$引入的边映射到已删除的边，我们将其标记为引入它的更改的名称$c_1$：</p><p>   We have just described the two basic kinds of actions in Pijul. There are no other. One kind adds vertices to the graph, along with “alive” edges around them, and the other kind maps an existing edge label onto a different one.In order to fully described the system, I also need to mention that the edge labels are given by two parameters: their status (alive, deleted, and a few others related to multiple files and technical details explained below) and the change that introduced them.</p><p>我们刚刚描述了Pijul中的两种基本动作。没有其他的了。一种将顶点以及它们周围的“活动”边添加到图中，另一种将现有的边标签映射到另一个不同的边上。为了全面描述系统，我还需要提到边标签由两个参数给出：它们的状态(活动的、已删除的，以及与多个文件相关的一些其他参数和下面解释的技术细节)以及引入它们的更改。</p><p>   If a change $c$ adds a vertex, we must have its  “context”, i.e. the lines before and after it, hence the changes that introduced these lines are in the dependencies of $c$.</p><p>如果一个变化$c$添加了一个顶点，我们必须有它的“上下文”，即它之前和之后的线，因此引入这些线的变化依赖于$c$。</p><p> If a change $c$ deletes a vertex, or in other words maps an existing edge introduced by a change $d$, then $c$ must depend on $d$.</p><p>如果更改$c$删除了顶点，或者换句话说映射了由更改$d$引入的现有边，则$c$必须依赖于$d$。</p><p> Of course, this is just the minimal set of dependencies needed to make sense of the text edits. Hooks and scripts may add extra language-dependent dependencies based on semantics.</p><p>当然，这只是理解文本编辑所需的最小依赖集。挂钩和脚本可能会基于语义添加额外的依赖于语言的依赖项。</p><p>  Our goals is to find the smallest possible system, both for reasons of mathematical aesthetics (why store useless stuff?) and the other one for performance. Therefore, one immediate question comes to mind: why even keep the change number on the edges?</p><p>我们的目标是找到尽可能小的系统，这既是出于数学美学的原因(为什么要储存无用的东西？)。另一个是表演。因此，一个迫在眉睫的问题浮现在脑海中：为什么要把找零的数字放在边缘？</p><p> In order to answer that question, suppose we don’t keep the labels, meaning that the maps happen between statuses only. Then, consider the following two situations:</p><p>为了回答这个问题，假设我们不保留标签，这意味着映射只在状态之间发生。然后，考虑以下两种情况：</p><p> The first issue happens when two authors delete a line in parallel, and one of the authors reverts their change. Applying these changes yields the following diagram, where the two deletions get merged into one, and the inverse applies to both:</p><p>第一个问题发生在两个作者并行删除一行时，其中一个作者恢复了他们的更改。应用这些更改将生成下图，其中两个删除项合并为一个，反之亦然：</p><p>   However, this is not what we expect, since one of the authors explicitly reverted the deletion, while the other performed the same deletion in parallel.By keeping the labels, this is what we get instead:</p><p>然而，这并不是我们所期望的，因为其中一位作者显式地恢复了删除，而另一位作者并行执行了相同的删除。通过保留标签，我们得到的结果是：</p><p> For the sake of clarity, in the rest of this post, we name two users Alice (with pronouns “she/her”) and Bob (with pronouns “he/his”).</p><p>为了清楚起见，在这篇文章的其余部分，我们将两个用户命名为Alice(代词为“她/她”)和Bob(代词为“他/他”)。</p><p> This situation, where Alice writes something in the middle of a paragraph $p$, while Bob deletes $p$ in parallel.One issue here, is that the situation is not symmetric: when Bob applies Alice’s change, he can tell immediately that something is wrong, because the context of Alice’s edits is labelled as deleted in his repository.</p><p>这种情况下，Alice在段落$p$中间写了一些东西，而Bob并行删除了$p$。这里的一个问题是情况不对称：当Bob应用Alice的更改时，他可以立即判断出有问题，因为Alice编辑的上下文在他的存储库中被标记为已删除。</p><p>   However, Alice’s situation is different: indeed, consider the case where instead of deleting $p$  in parallel of her changes, Bob deleted $p$ after applying Alice’s change. The edges deleted are exactly the same, but this is not a conflict, as shown in the following diagram:</p><p>然而，Alice的情况有所不同：实际上，考虑这样一种情况：Bob在应用Alice的更改后删除了$p$，而不是在删除$p$的同时删除了她的更改。删除的边完全相同，但这不是冲突，如下图所示：</p><p>   The situation is further complicated by the fact that this system doesn’t behave symmetrically with the contexts above and below the new line. Indeed, if Bob deleted the  down context of the line (i.e. if he deleted line $C$) instead of the  up context (line $B$), Alice could detect the conflict, since in that case, $C$ would have both an alive and a dead edge pointing to it ($C$ is called a “zombie vertex” internally), as shown in the following diagram:</p><p>由于该系统与新行上下的上下文不对称，情况变得更加复杂。实际上，如果Bob删除了该行的下行上下文(即，如果他删除了行$C$)而不是向上上下文(行$B$)，则Alice可以检测到冲突，因为在这种情况下，$C$将同时有一个活动边和一个死边指向它($C$在内部称为“僵尸顶点”)，如下图所示：</p><p>   Keeping the change identifiers on each edge allows us to solve this. In Pijul 0.12, Bob would add the labels of all the edges around the deleted lines to the dependencies of his change. Then, Alice can tell whether Bob knows of her change before applying it. The changes are conflict if and only if Bob doesn’t know of the new lines.</p><p>在每条边上保留更改标识符使我们能够解决这个问题。在Pijul 0.12中，Bob会将删除行周围的所有边的标签添加到其更改的依赖项中。然后，爱丽丝可以在应用它之前判断鲍勃是否知道她的更改。当且仅当Bob不知道新行时，这些更改才是冲突的。</p><p>  A finer analysis of what dependencies are led to a different behaviour in the new Pijul. Changes now have two different sets of dependencies: one is the set of strict dependencies, which are change we require in order to apply the current change, while the other one is merely a set of “known” changes, which the apply algorithm checks to decide whether to mark a conflict or not.</p><p>对哪些依赖关系进行了更细致的分析，就会导致新Pijul的不同行为。更改现在有两组不同的依赖项：一组是严格依赖项，这是我们应用当前更改所需的更改；另一组只是一组“已知”更改，应用算法检查这些更改以决定是否标记冲突。</p><p>  According to what we described so far, there are two types of conflicts in Pijul:</p><p>根据我们到目前为止所描述的，皮朱尔有两种类型的冲突：</p><p> Two alive vertices that do not have a (directed) path between them, in either direction.</p><p>两个活动顶点之间在任一方向上都没有(有向)路径。</p><p> Moreover, it is easy to show that Pijul implements a  conflict-free replicated datatype (CRDT): indeed, we’re just adding vertices and edges to a graph, or mapping edge labels which we know exist because of dependencies.</p><p>此外，很容易说明Pijul实现了一种无冲突的复制数据类型(CRDT)：实际上，我们只是将顶点和边添加到图中，或者映射我们知道由于依赖而存在的边标签。</p><p> However, Pijul’s datastructure models, in a conflict-free way, the conflicts that can happen over a text file. In fact, Pijul would remain a CRDT with or without the design choices explained above about edge labels: for example, we could decide that the “deleted” status has higher precedence. But as shown above, that wouldn’t model conflicts accurately.</p><p>然而，Pijul的数据结构以一种无冲突的方式对文本文件中可能发生的冲突进行了建模。事实上，Pijul仍然是一个CRDT，不管有没有上面解释的关于边缘标签的设计选择：例如，我们可以决定“已删除”状态具有更高的优先级。但如上所述，这并不能准确地模拟冲突。</p><p>  The scenario I want to talk about now is the sequential (i.e. single-user) situation where we start with many lines. Our user deletes all of them, adds one new line at the very beginning, and one at the very end, as shown in the following diagram:</p><p>我现在要讨论的场景是从多行开始的顺序(即单用户)场景。我们的用户将它们全部删除，并在开头和末尾各添加一行，如下图所示：</p><p>   If we represented this situation naively like in that diagram, the complexity of applying changes and outputting the repository would depend linearly on the size of the graph, as we would need to traverse the entire thing to know about line $C$, and know it comes after $B$.</p><p>如果我们像图中那样天真地表示这种情况，那么应用更改和输出存储库的复杂性将线性依赖于图形的大小，因为我们需要遍历整个过程才能了解行$C$，并知道它位于$B$之后。</p><p> The trick is to use what we call “pseudo-edges”, which are not part of any change, but are just here to keep the “alive subgraph” (the subgraph of the alive vertices) connected. Every time we delete an edge, we add pseudo-edges between the source of the edge and all the descendants of the target, like the dotted edge in the graph below:</p><p>诀窍是使用我们所说的“伪边”，它不是任何变化的一部分，而只是用来保持“活动子图”(活动顶点的子图)的连通性。每次删除边时，我们都会在边源和目标的所有后代之间添加伪边，如下图中的虚线边所示：</p><p>     We introduce another type of edge label to indicate that edges represent files, and hence are not be transitive. In particular, when we delete a file, all descendant vertices below must be deleted.</p><p>我们引入了另一种类型的边缘标签来表示边缘代表文件，因此是不可传递的。特别是，当我们删除一个文件时，下面的所有后代顶点都必须被删除。</p><p> Each file or directory is represented by two separate vertices: one is its name, the other one is an “inode” vertex representing the file itself. This allows directory renames to commute with file renames, and file renames to commute with edits at the beginning of the file. The naive representation where files are represented as just their name would cause the kind of conflicts described above when the contexts of new vertices are deleted in parallel.</p><p>每个文件或目录由两个单独的顶点表示：一个是其名称，另一个是表示文件本身的“inode”顶点。这允许目录重命名与文件重命名进行通信，并允许文件重命名与文件开头的编辑进行通信。当并行删除新顶点的上下文时，仅将文件表示为其名称的天真表示将导致上述类型的冲突。</p><p> The non-conflicting case is where the graph of alive files, reduced by contracting the edges from and to name vertices, is a tree, and each file has exactly one unique name.</p><p>不冲突的情况是，通过收缩来自和到命名顶点的边而减少的活动文件的图形是一棵树，并且每个文件恰好有一个唯一的名称。</p><p>  First, the graph of alive files can be disconnected, when a file is introduced in a directory deleted in parallel. When that happens, we double the deleted graph path with a path of pseudo-edges.</p><p>首先，当文件被引入并行删除的目录时，可以断开活动文件的图形。当发生这种情况时，我们使用伪边路径将删除的图路径加倍。</p><p> Another kind of conflict is when a file $a$ is renamed in parallel, to $b$ by Alice, and to $c$ by Bob. This includes the case where a file gets moved to two different directories, yielding a non-tree DAG.</p><p>另一种冲突是文件$a$并行重命名，Alice重命名为$b$，Bob重命名为$c$。这包括将文件移动到两个不同目录，从而生成非树DAG的情况。</p><p> Yet another one is when two different files are given the same name in parallel.</p><p>还有一种是当两个不同的文件同时被赋予相同的名称时。</p><p> Finally, one can create a cyclic graph of directories: starting from two directories $a$ and $b$ at the root of the repository, Alice can move $a$ to a subdirectory $b/a$ of $b$, while Bob moves $b$ to a subdirectory $a/b$ of $a$.</p><p>最后，可以创建目录的循环图：从存储库根目录的两个目录$a$和$b$开始，Alice可以将$a$移动到$b$的子目录$b/a$，而Bob可以将$b$移动到$a$的子目录$a/b$。</p><p>  In the previous Pijul, the contents of each line-vertex was stored in a table in the database. This was not optimal, since:</p><p>在前面的Pijul中，每个线-顶点的内容都存储在数据库的一个表中。这并不是最佳选择，因为：</p><p> the content of lines was stored twice: once in the change file, and another time in the database,</p><p>行的内容存储了两次：一次存储在更改文件中，另一次存储在数据库中。</p><p> some memory pages used to store long (&gt;512 bytes) lines could be underfull. For example, a line of length 513 required 4096 bytes of storage.</p><p>某些用于存储长(&gt；512字节)行的内存页可能不足。例如，长度为513的行需要4096字节的存储空间。</p><p> As wasteful as this may seem, on the repositories we analysed, this was only about half of the problem. The other half of the disk space was taken by the graph.Not only were repositories taking a lot of space on the disk, but this was also making non-trivial use cases extremely hard to debug, as the graph would quickly become impossible to plot, even on a codebase as small as Pijul itself.</p><p>尽管这看起来很浪费，但在我们分析的存储库中，这只是问题的一半左右。图形占用了另一半的磁盘空间，不仅存储库占用了大量的磁盘空间，而且这也使得非常重要的用例极难调试，因为图形很快就无法绘制，即使在Pijul这样小的代码库上也是如此。</p><p> Moreover, some potential applications of Pijul called for a word-based diff. But the size of these graphs was already out of control for lines, and words would only make it worse, because that would require one vertex per word.</p><p>此外，Pijul的一些潜在应用需要基于单词的比较。但这些图表的大小已经超出了线条的控制范围，而文字只会让情况变得更糟，因为这需要每个单词一个顶点。</p><p> This was a major scalability issue, even bigger than parsing your particular format of SSH key (which is possibly the most frequently reported problem).</p><p>这是一个重大的可伸缩性问题，甚至比解析特定格式的SSH密钥(这可能是最常报告的问题)还要严重。</p><p> I did consider abandoning the project at that point, but just before that I wanted to try two ideas out:</p><p>当时我确实考虑过放弃这个项目，但就在那之前，我想尝试两个想法：</p><p> Since many graphs I was looking at had long paths of consecutive lines, could we store them “packed” together as a single vertex, until another change needs to split them?</p><p>由于我看到的许多图都有连续线的长路径，我们是否可以将它们“打包”在一起作为单个顶点存储，直到另一个更改需要拆分它们？</p><p> To be honest, I wasn’t too happy about this idea, because there was still a problem with words, since we would have to choose at the beginning of the repository, and for all the files of the repository, whether the graph represented lines of words. Also, this would involve at least a major refactoring for a potentially small benefit.</p><p>老实说，我对这个想法不太满意，因为单词仍然有问题，因为我们必须在存储库的开始，以及对于存储库的所有文件，选择图形是否表示字行。此外，这至少需要进行一次重大重构，以获得潜在的小好处。</p><p> At the same time, I tried to solve the problem of how to store the content. After all, if I had to abandon the project, then at least Sanakirja could be a nice by-product if I managed to make databases smaller on disk.</p><p>同时，我试图解决如何存储内容的问题。毕竟，如果我不得不放弃这个项目，那么如果我设法让磁盘上的数据库变得更小，那么至少Sanakirja可以是一个很好的副产品。</p><p> In the end, I didn’t “fix” Sanakirja, but managed to solve both problems at the same time. If we could store groups of  lines, we might as well store groups of  bytes, the graph would be larger. And as an extra benefit, if graph vertices store references to the  byte offsets of a change, we don’t have to store a table mapping line numbers to contents, we can simply load contents from the change files directly.</p><p>最后，我没有“修复”Sanakirja，而是设法同时解决了这两个问题。如果我们可以存储线组，我们也可以存储字节组，那么图就会更大。另外一个好处是，如果图顶点存储了对更改字节偏移量的引用，我们不必存储将行号映射到内容的表，只需直接从更改文件加载内容即可。</p><p> However, this idea meant that a completely new Pijul had to be written, in order just to benchmark the idea. I wrote the core algorithms during my Christmas holidays at the end of 2019, and the results were quite satisfactory, as I was able to import a large number of large files without a problem. Even better, I was able to graphviz the result.</p><p>然而，这个想法意味着必须写一本全新的皮朱尔，才能作为这个想法的基准。我在2019年底的圣诞节假期期间编写了核心算法，结果相当令人满意，因为我能够毫无问题地导入大量大文件。更好的是，我能够用图形显示结果。</p><p> I wasn’t super confident about how to announce that publicly, since a number of people had started using Pijul, and even though they knew the project was still experimental, this move would be a breaking change in all possible imaginable ways. Moreover, it wasn’t clear to me that I was still legally allowed to work on Pijul ( more on this below).</p><p>我对如何公开宣布这一点并不是非常有信心，因为已经有很多人开始使用Pijul，尽管他们知道这个项目还处于实验阶段，但从所有可以想象的方式来看，这一举动都将是一个突破性的变化。此外，我也不清楚我是否仍然在法律上被允许在Pijul上工作(下面有更多关于这一点的内容)。</p><p>  We first revisit the first two diagrams in this post: adding and deleting lines. Vertices are now referenced by a change number (for example $c_0$) and a byte interval in that change (for example $[0, n[$, which means “bytes from offset $0$ included to offset $n$ excluded”). Note that vertices can now represent an arbitrary number of lines. Moreover, the size they occupy in memory is independent from $n$ (assuming $n &lt; 2^{64}$).</p><p>在这篇文章中，我们首先回顾前两个图表：添加和删除行。现在，顶点由更改编号(例如$c_0$)和该更改中的字节间隔引用(例如$[0，n[$，意思是“从偏移量$0$包含到偏移量$n$排除的字节”)。请注意，顶点现在可以表示任意数量的线。此外，它们在内存中所占的大小与$n$无关(假设$n&lt；2^{64}$)。</p><p> Starting from a single vertex $c_0:[0, n[$ with $n$ bytes (containing an arbitrary number of lines), introduced by change $c_0$, adding a line is done by first splitting $c_0:[0, n[$ at some offset $i &lt; n$, and inserting the new vertex just like before.</p><p>从单个顶点$c_0：[0，n[$和$n$字节(包含任意数量的线)开始，通过更改$c_0$引入，添加一条线的方法是首先在某个偏移量$i&lt；n$处拆分$c_0：[0，n[$]，然后像以前一样插入新顶点。</p><p> This means in particular that the splitting of content into lines is done by the diff algorithm and is encoded in the changes, instead of being set in stone for all repositories. With a different diff algorithm, we could imagine splitting contents according to programming language structure.</p><p>这特别意味着，将内容拆分成行是由DIFF算法完成的，并在更改中进行编码，而不是为所有存储库固定不变。使用不同的DIFF算法，我们可以想象根据编程语言结构拆分内容。</p><p>  Once we know how to split vertices, deletions are handled almost as before: as shown in the following diagram, where we first apply the same change $c_1$ as in the previous example, and go on to applying change $c_2$, which deletes the end of vertex $c_0:[0, i[$ from some $j&lt;i$ to $i$, and the beginning of vertex $c_1:[0, m[$, from $0$ to some $k&lt;m$.</p><p>一旦我们知道如何拆分折点，删除操作就几乎和以前一样：如下图所示，我们首先应用与上一个示例相同的更改$c_1$，然后应用更改$c_2$，这将删除顶点$c_0的结尾$c_0：[0，i[$从某些$j&lt；i$删除到$i$，以及顶点$c_1的开头：[0，m[$，from$0$到某个$k&lt；m。</p><p>  One important difference with before is that our previous edges had two different roles which were not clearly distinguishable from one another until now. One of these meanings was to order the lines, and the other one was the status. However, now that vertices can be split, the “status” role of edges becomes ambiguous: for example, a deleted edge pointing to vertex some vertex $c:[i, j[$ means that bytes $[i, j[$ of change $c$ are deleted, but what if we split that vertex into $c:[i, k[$ and $c: [k, j[$? Should we add an extra deleted edge, and if so, where?</p><p>与以前的一个重要区别是，我们之前的优势有两个不同的角色，直到现在才能清楚地区分开来。其中一个意思是命令行，另一个意思是状态。然而，现在顶点可以拆分了，边的“状态”角色就变得不明确了：例如，一条被删除的边指向某个顶点$c：[i，j[$意味着更改$c$的字节$[i，j[$]，但是如果我们将该顶点拆分为$c：[i，k[$and$c：[k，j[$？我们应该添加额外的删除边吗？如果是，应该在哪里添加？</p><p> There is a simple solution: by introducing a new kind of edge label (named  BLOCK in the source code) we can distinguish between “internal” or “implicit” edges that are only here to order the blocks, and “status” edges informing about the status of their target vertex. I’ll probably explain more about this in a future blog post, or in the manual, or in a paper.</p><p>有一个简单的解决方案：通过引入一种新的边标签(在源代码中称为block)，我们可以区分“内部”或“隐式”边(仅在这里对块进行排序)和“状态”边(通知其目标顶点的状态)。我可能会在未来的博客文章、手册或论文中更多地解释这一点。</p><p>   After discussions on our discourse, “patches” have been renamed to “changes”. Not too breaking, alright.</p><p>在对我们的话语进行讨论之后，“补丁”被重新命名为“改变”。别太碎了，好吧。</p><p> Everything is stored differently, because vertices do not even mean the same thing as before.</p><p>所有内容的存储方式都不同，因为顶点的含义甚至与以前不同。</p><p> Changes are now compressed with a variant  zstd, allowing subsets of a file to be decompressed without decompressing the whole thing.</p><p>更改现在使用变体zstd进行压缩，允许在不解压缩整个文件的情况下解压缩文件的子集。</p><p> Changes are now divided into two main sections: one contains a header with metadata, the dependencies, known patches, edits, and a cryptographic hash of the contents. The other section contains the contents of the change, which is the concatenation of the contents of all new vertices in the change. In particular, changes do  not store deleted contents (they actually never did, even in previous versions of Pijul). This division allow a server and a client to skip contents that isn’t alive anymore, while allowing the client to retrieve and verify the contents at a later time, should they need to.</p><p>更改现在分为两个主要部分：一个包含一个标题，其中包含元数据、依赖项、已知补丁、编辑和内容的加密散列。另一个部分包含更改的内容，它是更改中所有新顶点内容的串联。特别是，更改不会存储删除的内容(实际上从未存储过，即使在Pijul的以前版本中也是如此)。此划分允许服务器和客户端跳过不再有效的内容，同时允许客户端在以后需要时检索和验证内容。</p><p>  Changes now have a text representation, aiming at a one-to-one conversion with binary changes.This is a new thing, and is not totally trivial to get right, in particular because one cycle of serialization and deserialization must yield the exact same binary content.</p><p>更改现在有一个文本表示，目标是使用二进制更改进行一对一转换。这是一个新事物，要正确处理并不是一件轻而易举的事，特别是因为一个序列化和反序列化周期必须产生完全相同的二进制内容。</p><p> When creating a new change, authors are presented with a draft of the change in the text format (unless some recorded files are detected to be binary files),</p><p>当创建新的改变时，向作者呈现文本格式的改变的草稿(除非检测到一些记录的文件是二进制文件)，</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pijul.org/posts/2020-11-07-towards-1.0/">https://pijul.org/posts/2020-11-07-towards-1.0/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/皮朱尔/">#皮朱尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pijul/">#pijul</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/更改/">#更改</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>