<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Mark 1家用Forth计算机（仅TTL，无微处理器） Mark 1 Homebuilt Forth Computer (TTL only, no microprocessor)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mark 1 Homebuilt Forth Computer (TTL only, no microprocessor)<br/>Mark 1家用Forth计算机（仅TTL，无微处理器） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-17 02:36:12</div><div class="page_narrow text-break page_content"><p>This computer has no microprocessor. The CPU is discrete TTL logic. I bought my first TTL data book in 1979.I was learning 6502 machine code at the time and dreamt of building a simple TTL CPU.I sketched some circuit ideas; but that was as far as it went.Now, 25 years later, I&#39;ve finally done it!Working evenings and weekends, the Mark 1 took a month to design, 4 months to build and a month to program.Here&#39;s the result: Myself is a standard way to implement recursion in FORTH.Even if you&#39;re not familiar with FORTH, if I tell you it&#39;s a stack-based language, and uses reverse polish notation (RPN), you might be able to figure out how this works.             The Mark 1 is a micro-programmed machine with a highly encoded &#34;vertical&#34; microcode.The microinstruction () is only 8-bits wide.One normally thinks in terms of &#34;horizontal&#34; microcodes, which are wider and less encoded.Some are very wide indeed.The Mark 1 is more like a RISC processor.</p><p>这台计算机没有微处理器。 CPU是离散的TTL逻辑。 我在1979年购买了第一本TTL数据书。当时我正在学习6502机器代码，梦想着构建一个简单的TTL CPU。我画了一些电路图。但这已经到了尽头。25年后的今天，我终于做到了！Mark 1在晚上和周末工作，花了一个月的设计时间，四个月的建造时间和一个月的编程时间。结果是：Myself是在FORTH中实现递归的标准方法。即使您不熟悉FORTH，如果我告诉您它是一种基于堆栈的语言，并使用反向抛光表示法（RPN），您也许可以弄清楚它是如何工作的。             Mark 1是一种微编程机器，具有高度编码的＆lt; vertical＆＃34;微码。微指令（）只有8位宽。人们通常以“水平”的方式思考。微码，范围更广，编码更少。有些确实非常广泛。Mark 1更像是RISC处理器。</p><p>              Decoding is done centrally using 74HC138 1-of-8 decoders.Decoded control signals are distributed via the back plane.Simple gating is then required at card level to complete the decoding.</p><p>              解码是使用74HC138 8分之一解码器集中完成的。解码后的控制信号通过背板分配。然后需要在卡级别进行简单的门控以完成解码。</p><p>  The conditional is a skip not a branch.It inhibits loading of another -instruction for a specified number of cycles if the test is true.The skip distance is decremented to zero at which point normal execution resumes.</p><p>  条件是跳过而不是分支。如果测试为真，则它会在指定的周期数内禁止加载另一条指令。跳过距离递减为零，此时将恢复正常执行。</p><p>  The &#34;PC←OP*16&#34; instruction (1011xxxx) a.k.a. XOP loads the uppermost 8-bits of the program counter (PC) from the operand register.It&#39;s a form of indirect jump.</p><p>  ＆＃34; PC←OP * 16＆＃34;指令（1011xxxx）a.k.a. XOP从操作数寄存器中加载程序计数器（PC）的最高8位。这是间接跳转的一种形式。</p><p>  The other jump instruction (1001xxxx) has a 4-bit operand and can only reach the first 16 bytes of the -ROM.</p><p>  另一个跳转指令（1001xxxx）具有4位操作数，并且只能到达-ROM的前16个字节。</p><p>  The 74181-based ALU requires 8 control signals.These are decoded from the 4-bit ALU function field in the -instruction using a 7x16 diode matrix ROM.The shaded squares indicate positions where diodes are fitted:</p><p>  基于74181的ALU需要8个控制信号。这些是使用7x16二极管矩阵ROM从-指令中的4位ALU功能字段解码的。阴影正方形表示二极管的安装位置：</p><p>    The control signals are transmitted from the diode matrix to the ALU via the data bus.</p><p>    控制信号通过数据总线从二极管矩阵传输到ALU。 </p><p>        FLAG selects sign or overflow testing.Sign testing routes the most significant bit of the ALU result to the conditional test multiplexer.Overflow testing required the addition of a quad-XOR gate.The 74181 does not generate an overflow signal (the later 382 variant does).This was not used in the end because FORTH implements signed comparison by testing the sign of the result after subtraction.</p><p>FLAG选择符号或溢出测试。符号测试将ALU结果的最高有效位路由到条件测试多路复用器。溢出测试需要增加一个quad-XOR门。74181不会产生溢出信号（后面的382型号会产生）。最终没有使用它，因为FORTH通过在减去后测试结果的符号来实现符号比较。</p><p>    The Mark 1 is housed in a 3U 19&#34;IEC297 sub-rack with a 64-way DIN 41612 backplane.The bus layout is shown below.The &#34;A&#34; row resembles a standard 8-bit microprocessor bus.The &#34;C&#34; row carries the -instruction and various decoded control signals.The fully-bussed pins (1, 2, 31, &amp; 32) carry power supply and clocks.</p><p>    Mark 1位于3U 19＆＃34;中。带有64路DIN 41612背板的IEC297子机架。总线布局如下所示。＆＃34; A＆＃34;该行类似于标准的8位微处理器总线。＆＃34; C＆＃34;行包含-指令和各种解码的控制信号。全总线引脚（1、2、31和32）承载电源和时钟。</p><p>    The clocks are in quadrature.CLK1  risesfalls at the beginning of the machine cycle.CLK2 is used to generate write-enable signals for the RAM and I/O.</p><p>    时钟是正交的。CLK1在机器周期开始时上升下降。CLK2用于为RAM和I / O生成写使能信号。</p><p>      The sequencer has a 12-bit micro-program counter (PC).The uppermost 8-bits can be loaded from the OP Latch, effecting a jump to one of 256 microcode routines.Each routine starts on a 16-byte -page boundary.</p><p>      该定序器具有一个12位微程序计数器（PC）。最高的8位可以从OP锁存器加载，从而跳转到256个微代码例程之一。每个例程均以16字节的页面边界开始。</p><p>    Opcodes, the machine language of the macro-machine, are loaded into the OP latch from the data bus undermicro-program control. They can be fetched from memory using one of the index registers as a program counter.A simple  micro-interpreter consists of the following 3 -instructions:</p><p>    宏机器的机器语言操作码从下面的数据总线加载到OP锁存器中微程序控制。可以使用索引寄存器之一作为程序计数器从内存中获取它们。一个简单的微解释器由以下3个指令组成：</p><p>  OP←Memory[Index] Load OP latch from memoryIndex←Index+1 Increment &#34;program counter&#34;PC←OP*16 Execute microcode routine</p><p>  OP←Memory [Index]从存储器加载OP锁存器索引←索引+1递增＆＃34;程序计数器＆＃34;PC←OP * 16执行微码程序</p><p>  How do these 3 -instructions get executed?One possibility is to append them to the end of every -routine.A slower but more space-efficient option is to append a jump to them.Mark 1 microcode has a jump specifically for this.</p><p>  这3条指令如何执行？一种可能是将它们附加到每个例程的末尾。较慢但更节省空间的选择是在它们后面附加一个跳转。Mark 1微码为此专门进行了跳转。 </p><p>      Opcodes can have zero, one, or more operands. The -routines consume operands by incrementing the program counter.During development, I used this two-operand POKE instruction to test the UART.This expects a 16-bit address followed by a data byte:</p><p>操作码可以具有零个，一个或多个操作数。-例程通过增加程序计数器来消耗操作数。在开发过程中，我使用了这两个操作数的POKE指令来测试UART。这需要一个16位地址，后跟一个数据字节：</p><p>  Poke: Index.Lo ← Memory [PC] ; Address LO PC ← PC+1 Index.Hi ← Memory [PC] ; Address HI PC ← PC+1 Temp ← Memory [PC] ; Data byte PC ← PC+1 Memory [Index] ← Temp ; Do the POKE Jump Next</p><p>  戳：Index.Lo←内存[PC];地址LO PC←PC + 1 Index.Hi←内存[PC];地址HI PC←PC + 1 温度←内存[PC];数据字节 PC←PC + 1 内存[索引]←温度;做扑克 跳到下一个</p><p>  The Mark 1 was designed to support the FORTH virtual machine.The following FORTH primitives are micro-programmed:</p><p>  Mark 1旨在支持FORTH虚拟机。以下FORTH原语是经过微编程的：</p><p>  EXIT LIT EXECUTEBRANCH 0BRANCH (LOOP) (DO) U* U/ AND OR XOR LEAVE R&gt; &gt;R R 0= 0&lt; + D+MINUS DMINUS OVER DROP SWAP DUP @ C@ ! C! (DOES)    My original plan was to build a subroutine-threaded FORTH. High-level definitions were to be called explicitly, primitives were to be compiled inline:</p><p>  退出执行分支0分支（LOOP）（DO）U * U /和或XOR LEAVE R> ＆gt; R R 0 = 0＆lt; + D +减去DUST减去DROP SWUP DUP @ C @！ C！ （做）    我最初的计划是建立一个子例程线程的FORTH。高级定义将被显式调用，原语将被内联编译：</p><p>    I abandoned this idea because most FORTHs use indirect threading and I wanted a full-featured standard FORTH with all the usual compiler facilities.Many compiling words are tightly coupled to the indirectly threaded model.</p><p>    我放弃了这个想法，因为大多数FORTH使用间接线程，并且我希望使用具有所有常用编译器功能的全功能标准FORTH。许多编译词与间接线程模型紧密耦合。</p><p>  Indirectly threaded code is a list of execution tokens.An execution token is a code field address.The code field is a pointer to machine code.This presented a problem on the mark 1 because it has separate macro and micro address spaces.What should go in the code field?My solution was to shorten it to 1 byte and store the opcode:</p><p>  间接线程代码是执行令牌的列表。执行令牌是代码字段地址。代码字段是指向机器代码的指针。这在标记1上带来了一个问题，因为它具有单独的宏和微地址空间。在代码字段中应该输入什么？我的解决方案是将其缩短为1个字节并存储操作码：</p><p>  Foo: DB OP_DUP DB OP_SWAP DB OP_DROP DB OP_EXIT Bar: DB OP_OVER DB OP_CALL DW Foo DB OP_ROT DB OP_EXIT</p><p>  Foo：DB OP_DUP 数据库OP_SWAP 数据库OP_DROP DB OP_EXIT 酒吧：DB OP_OVER DB OP_CALL DW Foo DB OP_ROT DB OP_EXIT </p><p>  cfa_Foo: DW Enter pfa_Foo: DW cfa_DUP DW cfa_SWAP DW cfa_DROP DW cfa_Exit cfa_Bar: DW Enter pfa_Bar: DW cfa_OVER DW cfa_Foo DW cfa_ROT DW cfa_Exit cfa_Exit: DW pfa_Exit pfa_Exit: .. code .. cfa_DUP: DW pfa_DUP pfa_DUP: .. code ..</p><p>cfa_Foo：DW输入 pfa_Foo：DW cfa_DUP DW cfa_SWAP DW cfa_DROP DW cfa_Exit cfa_Bar：DW输入 pfa_Bar：DW cfa_OVER DW cfa_Foo DW cfa_ROT DW cfa_Exit cfa_Exit：DW pfa_Exit pfa_Exit：..代码.. cfa_DUP：DW pfa_DUP pfa_DUP：..代码..</p><p>  cfa_Foo: DB OP_ENTER pfa_Foo: DW cfa_DUP DW cfa_SWAP DW cfa_DROP DW cfa_Exit cfa_Bar: DB OP_ENTER pfa_Bar: DW cfa_OVER DW cfa_Foo DW cfa_ROT DW cfa_Exit cfa_Exit: DB OP_EXIT cfa_DUP: DB OP_DUP cfa_SWAP: DB OP_SWAP</p><p>  cfa_Foo：数据库OP_ENTER pfa_Foo：DW cfa_DUP DW cfa_SWAP DW cfa_DROP DW cfa_Exit cfa_Bar：DB OP_ENTER pfa_Bar：DW cfa_OVER DW cfa_Foo DW cfa_ROT DW cfa_Exit cfa_Exit：DB OP_EXIT cfa_DUP：数据库OP_DUP cfa_SWAP：数据库OP_SWAP</p><p>    NEXT: mov w.l, [ip] ; W ← XT, IP ← IP+2 inc ip mov w.h, [ip] inc ip mov op, [w] ; OP ← [CFA] inc w ; W ← PFA xop ; PC ← OP*16</p><p>    下一条：mov w.l，[ip]; W←XT，IP←IP + 2 INC IP mov w.h，[ip] INC IP mov op，[w]; OP←[CFA] 公司; W←PFA xop; PC←OP * 16</p><p>  It follows the convention of invoking primitives with the PFA in W as required by ENTER:</p><p>  它遵循ENTER要求在W中使用PFA调用基元的约定：</p><p>  ENTER: dec rsp ; Push IP mov rs, ip mov ip, w ; IP ← PFA jmp NEXTEXIT: mov ip, rs ; Pop IP inc rsp jmp NEXT</p><p>  ENTER：dec rsp;推送IP mov rs，ip mov ip，w; IP←PFA 下一站退出：mov ip，rs;流行IP 公司 下一站</p><p>    Notice how the last 3 -instructions in NEXT resemble the simple micro-interpreter described earlier.This was used to advantage in the implementation of multiplication and division.</p><p>    请注意，NEXT中的最后3个指令如何类似于前面描述的简单微解释器。这在实现乘法和除法时很有用。</p><p>        I use the Microsoft Assembler (MASM) to create ROM images for the macro memory space.The syntax &#34;16 DUP()&#34; tells MASM to repeat the enclosed byte 16 times.It&#39;s equivalent to:</p><p>        我使用Microsoft汇编程序（MASM）为宏存储空间创建ROM映像。语法＆＃34; 16 DUP（）＆＃34;告诉MASM将封闭的字节重复16次。它等效于： </p><p>  cfa_Uxxx: DB OP_XXX_BEGINpfa_Uxxx: DB OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT DB OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT DB OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT DB OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT, OP_XXX_BIT DB OP_XXX_END</p><p>cfa_Uxxx：数据库OP_XXX_BEGINpfa_Uxxx：数据库OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT DB OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT DB OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT DB OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT，OP_XXX_BIT 资料库OP_XXX_END</p><p>  First, NEXT calls _BEGIN with the address of the PFA (i.e. the first _BIT) in W._BEGIN and _BIT end by jumping to the 3 rd from last instruction in NEXT.This executes _BIT 16 times incrementing W as it goes.W acts as the loop counter or temporary program counter.Finally, _END jumps to the high-level NEXT.</p><p>  首先，NEXT用W中PFA的地址（即第一个_BIT）调用_BEGIN。_BEGIN和_BIT通过从NEXT中的最后一条指令跳到第三位来结束。这将执行_BIT 16次，并随着W递增W。W充当循环计数器或临时程序计数器。最后，_END跳到高级NEXT。</p><p>    Reset forces PC to 000H.The first 8 bytes of the -ROM contain the following:</p><p>    重置将PC强制为000H。-ROM的前8个字节包含以下内容：</p><p>  RESET: mov w, 0 ; W ← 0002h inc w inc w dis ; Disable IRQ mov ip.l, [w] ; IP ← Cold start vector inc w mov ip.h, [w]Next: ...</p><p>  复位：mov w，0; W←0002h 公司 公司 迪斯;禁用IRQ mov ip.l，[w]; IP←冷启动向量 公司 mov ip.h，[w]下一个： ...</p><p>  This initialises the high-level instruction pointer (IP) from a cold start vector at location 0002h in main memory.It then drops through into NEXT.</p><p>  这将从主存储器中位置0002h的冷启动向量初始化高级指令指针（IP）。然后进入下一个。</p><p>    .Model Tiny.Code Include OPS.INC ORG 0 DW 0FFFFh ; Reserved for IRQ vector DW Reset ; Cold-start vectorReset DW UART_Init ...</p><p>    小模型。码 包括OPS.INC 组织0 DW 0FFFFh;保留用于IRQ向量 DW复位;冷启动矢量重置DW UART_Init ...</p><p>    I wrote a single-pass assembler for Mark 1 microcode.This generates Intel Hex images of the -ROM, and a list of opcodes formatted as MASM EQU statements.High-level ROMs are created using the Microsoft MASM assembler.The /TINY command-line switch forces linker version 6.15 to generate binary .COM files,which are then converted to Intel Hex. Burning EPROMs soon became tedious and I wrote a ROM-resident monitor to accept Intel Hex downloads via the serial port.This is how FORTH was originally loaded; but the latest version is ROM-resident.I now have a PC-based simulator for debugging, FORTH is fairly stable, and there&#39;s less need for the monitor. My original FORTH, posted here in 2003,reversed the stack order of quotients and remainders left by division words.This has been corrected.Here&#39;s the latest code: This implementation of fig-FORTH is based on the original May 1979 Installation Manual for the 6502 by Bill Ragsdale.It deviates from the standard in the following ways: Most fig-compliant code should run with little or no alteration.See the examples (e.g. DOER-MAKE) in the simulator zip. Aaron Tang, a student at the Universiti Teknologi Petronas in Malaysia, has built a Mark 1 FORTH Computer;and one of his classmates, Aidil Jazmi, has cloned Bill Buzbee&#39;s Magic-1.Visit their  UTP Cloners page to read all about it.Aaron first contacted me in March 2006 with a few questions, and by October 2006 his computer was working.He used the same eurocards, mounted in a similar rack to mine, and followed my layout very closely; but, whereas I mostly used pen-wiring, Aaron&#39;s computer is wire-wrapped.Well done to both Aaron and Aidil.     You&#39;ll find more homemade computers on my  links page. Please visit the other sites on the web ring (below) and don&#39;t forget to have a look at my  Mark 2 FORTH Computer.     JavaScript by  Qirien Dhaela  David Brooks, designer of the Simplex-III homebrew computer, has founded the Homebuilt CPUs Web Ring.To join, drop  Dave a line, mentioning your page&#39;s URL.You&#39;ll need to copy this code fragment into your page.</p><p>    我为Mark 1微代码编写了单遍汇编程序。这将生成-ROM的Intel Hex映像以及格式为MASM EQU语句的操作码列表。使用Microsoft MASM汇编器创建高级ROM。/ TINY命令行开关会强制链接器版本6.15生成二进制.COM文件，然后将其转换为Intel Hex。 刻录EPROM很快变得乏味，我编写了一个驻留在ROM中的监视器，以通过串行端口接受Intel Hex下载。这就是最初装入FORTH的方式。但是最新版本是ROM驻留的。我现在有一个用于调试的基于PC的模拟器，FORTH相当稳定，并且对监视器的需求减少了。 我的原始《 FORTH》，于2003年发布在这里，逆转除法运算符留下的商和余数的堆栈顺序。这已得到纠正。这是最新的代码： fig-FORTH的这种实现是基于Bill Ragsdale于1979年5月为6502安装的原始手册。它在以下方面偏离标准： 大多数符合无花果的代码都应该很少改动或没有改动地运行。请参阅模拟器zip中的示例（例如，DOER-MAKE）。 马来西亚国家石油大学的学生Aaron Tang建造了Mark 1 FORTH计算机。他的一位同学艾迪尔·贾兹米（Aidil Jazmi）克隆了比尔·布兹比（Bill Buzbee）的Magic-1。访问其“ UTP克隆”页面以阅读所有内容。Aaron于2006年3月首次与我联系，并提出了一些问题，到2006年10月，他的计算机开始工作。他使用了相同的欧元卡，并安装在与我相似的机架中，并非常仔细地遵循了我的布局。但是，尽管我主要使用笔线连接，但Aaron的计算机是用线包裹的。亚伦和艾迪尔都做得很好。     您可以在我的链接页面上找到更多自制计算机。 请访问网络环上的其他站点（如下），并且不要忘记看一下我的Mark 2 FORTH计算机。     Qirien Dhaela的JavaScriptSimplex-III自制计算机的设计师David Brooks创建了Homebuilt CPU Web Ring。要加入，请在戴夫（Dave）行中提及您页面的URL。您需要将此代码片段复制到您的页面中。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.aholme.co.uk/Mk1/Architecture.htm">http://www.aholme.co.uk/Mk1/Architecture.htm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/家用/">#家用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/homebuilt/">#homebuilt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/op/">#op</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>