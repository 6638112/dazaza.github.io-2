<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cacao：在Rust中建立本机MacOS（和iOS）应用程序 Cacao: Building native macOS (and iOS) Apps in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cacao: Building native macOS (and iOS) Apps in Rust<br/>Cacao：在Rust中建立本机MacOS（和iOS）应用程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-11 14:32:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/15bfbace6f0e8872cd0dabd0af700008.png"><img src="http://img2.diglog.com/img/2021/6/15bfbace6f0e8872cd0dabd0af700008.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Building native macOS apps outside the normal Apple ecosystem is sometimes a not-so-obvioustask. The shifting ecosystem of AppKit, Catalyst, and SwiftUI - coupled with documentation that&#39;ssometimes non-existent, or spanning multiple operating system versions that each have their own nuance -makes it tricky to know just what you need to tie into.</p><p>建立普通Apple Ecosystem外的本机MacOS应用程序有时是一个不那么ExpiuTastask。 Appkit，Catalyst和Swifui的转换生态系统 - 与文档相结合，与＆＃39; SSSometimes不存在，或跨越多个操作系统版本，每个操作系统版本都有自己的Nuance -Makes，它令人棘手地知道你需要融入的东西。</p><p> One language that I&#39;ve felt hasn&#39;t had a great solution to this yet is Rust. I&#39;ve released an initial version of Cacao, which is my effort to enable building macOS (and iOS, see below) apps in Rust. This post showcases a bit of what Cacao is, how it works, and includes some opinions on GUI work sprinkled throughout.</p><p> 我＆＃39; ve verst的一种语言＆＃39; t对此有一个很好的解决方案却是生锈。我发布了一个初始版本的可可，这是我努力在Rust中建立麦克斯（和iOS，见下文）应用程序。这篇文章展示了一点Cacao是它的工作原理，并包括关于GUI工作的一些意见。</p><p>  I should clarify something before going any further. When I say that Rust hasn&#39;t had a great solution to this yet, I meanthat there hasn&#39;t been an elegant way to build a macOS app in Rust. There is a litany of prior work though - some of which Cacao uses.</p><p>  我应该在进一步澄清一些东西。当我说Rust Hasn＆＃39; t又有一个很好的解决方案，我的意思是那里有一个优雅的方式来制造生锈的麦克斯应用程序。有一连串的事先工作 - 其中一些可可使用。</p><p> The  objc crate by  SSheldon has been around for years now, and does a very good job of providing a way to bridge Rust with Objective-C. Cacao relies on this heavily for bridging with the Apple side of things.</p><p> Ssheldon的Objc箱子现在已经存在了几年，并且非常好的工作提供了一种用目标-c桥的方法。可可依赖于与东西的苹果方面弥合这一点。</p><p> Delisa Mason wrote about building macOS apps in Rust as far as back as 2016, and the  examples repository still holds up.</p><p> delisa mason写了关于锈病的麦克斯应用程序，就像2016年一样，例子存储库仍然坚持下去。</p><p> The  core-foundation crate is often passed around as the &#34;way&#34; to build macOS apps in Rust. As far as I know, this was originally built to help Mozilla and Servo. It&#39;s a good crate, but I feel it&#39;s not as simple, and doesn&#39;t expose certain patterns that help make a macOS app feel &#34;right&#34;.</p><p> 核心基础箱子通常作为＆＃34; Way＆＃34;在锈病中构建麦斯科斯镜头应用程序。据我所知，这最初是为了帮助Mozilla和伺服。它＆＃39;是一个很好的箱子，但我感觉到它＆＃39;它不如那么简单，也没有公开一些有助于制作麦斯科斯乐园的模式＆＃34;右和＃34;</p><p> fruity and  objrs both attempt to offer better interop with the Objective-C side of things. Neither is used by Cacao, but I felt they&#39;re worth mentioning as they both are decent reading anyway.</p><p> 果味和objrs都尝试与东西的目标-c互相提供更好的互操作。既不是可被下巴使用的，但我觉得他们＆＃39;无论如何，他们都是体面的读数。 </p><p> Each of these are great works on their own, but none of them contribute to what I feel is a &#34;native&#34; macOS API style in Rust.</p><p>这些都是自己的伟大作品，但他们都没有贡献我的感受是一个＆＃34;本地＆＃34;麦斯科斯API样式在铁锈。</p><p>   When you build a macOS app in the standard, conventional way (AppKit), your primary building block is your  Application Delegate. This is effectively where you receive varying messages from the OS (notifications, lifecycle events), and then handle them accordingly. The above examples don&#39;t provide a simple way to do this, and feel very procedural. Trying to go against the grain on macOS development often becomes annoying very quickly, and thus I define  native as being able to replicate the intended pattern of development.</p><p>   在标准中构建MacOS应用程序时，传统方式（AppKit），您的主构建块是您的应用程序委托。这有效地，您可以从OS（通知，生命周期事件）接收变化的消息，然后相应地处理它们。上面的例子Don＆＃39; t提供了一种简单的方法来做到这一点，并感受到非常程序。试图对麦斯科斯开发的谷物进行反对谷物经常变得非常令人讨厌，因此我将本机定义为能够复制预期的发育模式。</p><p> Let&#39;s look at a basic Swift macOS window example. Note that we&#39;re doing this in a no-storyboards or interface-builder fashion, as that&#39;s what Rust equivalent code will be doing; it&#39;s entirely fair to say that this could be shorter if you&#39;re the type to use Interface Builder.</p><p> Let＆＃39;查看一个基本的Swift MacOS窗口示例。请注意，我们在没有故事板或界面建设者时尚中这样做，以及＃39; s生锈等同代码将在做什么;它完全公平地说，如果您＆＃39;重新使用界面构建器的类型，这可能会更短。</p><p> import  Cocoa  import  Foundation    class  AppDelegate :  NSObject ,  NSApplicationDelegate  {    var  window :  NSWindow ?        func  applicationDidFinishLaunching ( _  aNotification :  Notification ) {    let  frame =  CGRect (    x :  10.0 ,    y :  10.0 ,    width :  400.0 ,    height :  400.0    )        let  win =  NSWindow ( contentRect : frame,  styleMask : [    . closable , . fullSizeContentView , . miniaturizable , . fullScreen ,     . resizable , . unifiedTitleAndToolbar    ],  backing : . buffered ,  defer :  true )        win . title =  &#34;Hello world&#34;    win . makeKeyAndOrderFront( nil )    window = win    }  }    // Just for running the app without all the Xcode @main items.  let  delegate =  AppDelegate ()  NSApplication . shared . delegate = delegate  _  =  NSApplicationMain ( CommandLine . argc,  CommandLine . unsafeArgv)</p><p> 导入Cocoa Import Foundation类AppDelegate：nsobject，nsapplicationdelegate {var窗口：nswindow？ Func ApplicationDidFinishlaUnching（_ Anotification：通知）{让框架= CGRECT（x：10.0，y：10.0，宽度：400.0，高度：400.0）让WIN = nswindow（ContentRect：Frame，StyleMask：[。CompleSizecontentView，。fullsizeContentView。 ，。全屏，。调整大小，。unifiedTitleandtoolbar，支持：。缓冲，推迟：True）获胜。标题=＆＃34;你好世界＆＃34;赢 。 MakeKeyAndOrderFront（nil）窗口= win}} //只是为了在没有所有Xcode @main项的情况下运行应用程序。让德语= appdelegate（）nsapplication。分享。删除=委托_ = nsapplicationmain（commandline。argc，commandline。unsafeargv）</p><p> All things considered, that&#39;s pretty succinct - even the Objective-C version wouldn&#39;t be much longer! What I take note of here is specifically the  applicationDidFinishLaunching(_:) method: this is a delegate method, and is a prime example of what I wanted in Rust. With Cacao, I feel like it gets fairly close:</p><p> 所有的事情都考虑，那个＆＃39; s的漂亮简洁 - 即使是目标-c版本也会更长时间！我注意到这里特别是ApplicationDidFinishLaunching（_ :)方法：这是一个委托方法，是我在Rust中所需内容的一个主要示例。用吉兰，我觉得它相当接近：</p><p> use  cacao :: macos :: { App, AppDelegate } ;  use  cacao :: macos :: window :: Window;    #[derive(Default)]  struct  BasicApp  {    window : Option&lt;Window&gt;  }    impl  AppDelegate  for  BasicApp  {    fn  did_finish_launching ( &amp; self )  {    let  window  =  Window :: default();    window . set_minimum_content_size ( 400. ,  400. );    window . set_title ( &#34;Hello World!&#34; );    window . show ();      self . window  =  Some (window);    }  }    fn  main ()  {    App :: new( &#34;com.hello.world&#34; ,  BasicApp :: default()) . run ();  }</p><p> 使用cacao :: macos :: {app，appdelegate};使用Cacao :: MacOS ::窗口::窗口; ＃[派生（默认）] struct basicapp {window：选项＆lt; window＆gt; for BasicApp {fn did_finish_launching（＆amp; self）{let window = window :: default（）;窗户 。 set_minimum_content_size（400.，400.）;窗户 。 set_title（＆＃34;您好世界！＆＃34;）;窗户 。表演 （）;自己 。窗口=一些（窗口）; fn main（）{app :: new（＆＃34; com.hello.world＆＃34;，basicapp :: default（））。跑步 （）; }</p><p> Here, we do roughly the same thing as our Swift example, albeit even more succinct due to being able to take advantage of  Default in Rust.  App wraps  NSApplication, and marshals events and method calls over to the  AppDelegate trait implementation. For macOS, most of the  NSApplicationDelegate methods and events are supported - although I haven&#39;t gotten around to wrapping  NSNotification and passing it in to some methods. Pull requests welcome. :)</p><p> 在这里，我们粗略的是我们的Swift示例的情况大致相同，尽管能够利用默认的rust，但更加简洁。 App包装NSapplication，并腕表事件和方法调用到AppDelegate特性实现。对于麦克斯来说，支持的大多数NSApplicationDelegate方法和事件 - 尽管我已经到了包裹着NSNotification并将其传递给某种方法。拉出请求欢迎。 :) </p><p> From here, you could continue with Cacao, or defer to another framework of your choice and simply rely on Cacao for the &#34;mac&#34; pieces. In fact, each Cacao control exposes a public  objc property, which you can lock on and message pass to directly. This enables usage of other Rust wrappers (e.g, Metal), so you&#39;re not locked in to any one thing about Cacao.</p><p>从这里，你可以继续用Cacao，或者推迟到你选择的另一个框架，并只是依靠可卡洛的＆＃34; Mac＆＃34;件。事实上，每个Cacao控制都公开了一个公共objc属性，您可以直接锁定和消息传递。这使得能够使用其他生锈包装（例如，金属），所以你＆＃39;重新锁定在任何关于可可的人。</p><p>  Rust doesn&#39;t have a concept of a  Class built in to the language, instead favoring more of a composition-based approach with trait implementations. Many existing GUI models are subclass-heavy, though, and working with them can feel a bit odd from the Rust side.  gtk-rs provides some utilities for working with subclasses from the Rust side, but what if we could keep it composition-based?</p><p>  RUDEN＆＃39; T有一个内置于语言的课程的概念，而是更多地利用具有特质实现的组合式的方法。然而，许多现有的GUI模型是沉重的，并且与他们一起工作可以感觉到锈迹偏差。 GTK-RS提供了一些公用事业公司，用于与生锈侧的子类合作，但如果我们可以保留其组成的基于组成？</p><p> Cacao supports this, in a sense. Most widget types can be declared one of two ways: stock, in which you can call into it and set your properties, and treat it like a normal control - or delegated, where you can provide a struct that implements a trait for a given widget. For example, the  View type could be constructed this way:</p><p> 可可中的吉兰支持这一点。大多数小部件类型可以被声明两种方式之一：库存，您可以在其中调用它并设置您的属性，并将其视为正常的控件 - 或委派，在其中可以提供为给定小部件实现特性的结构。例如，可以通过这种方式构建视图类型：</p><p>  This works fine - you could build up a tree from here and slap it wherever you want. If we did it as a delegate pattern, it&#39;d look like this:</p><p>  这有效 - 你可以从这里建立一棵树，无论你想要的地方都会拍打它。如果我们这样做是委托模式，它看起来像这样：</p><p> #[derive(Debug)]  pub  struct  MyView  {    handle : Option&lt;View&gt;  }    impl  ViewDelegate  for  MyView  {    fn  did_load ( &amp;mut  self ,  view : View)  {    // Customize your view    self . handle  =  Some (view);    }      // You could implement further methods here for handling drop and drop, etc  }    // elsewhere...  let  view  =  View :: with( MyView :: default());</p><p> ＃[派生（debug）] pub struct myview {handle：选项＆lt;查看＆gt; } illump viewdelegate for myview {fn did_load（＆amp; mut self，查看：查看）{//自定义您的视图self。把手=一些（视图）; } //您可以在此处实现进一步的方法来处理丢弃和下降，等等} //其他地方... view = view :: with（myview :: default（））;</p><p>  A friend of mine once told me over beers:  &#34;If you go more than one subclass deep, you&#39;ve done something wrong&#34;. Over the years, I&#39;ve come around to this point of view, and I feel this approach fits that mantra perfectly - it feels like a subclass, in that you have a place to localize the logic and control setup, implement event handlers, and so on - but you can&#39;t go further into subclass hell.</p><p>  我的一位朋友曾经告诉过我啤酒：＆＃34;如果你走了多个沉重，你已经做了一些错误＆＃34;多年来，我举行了这个角度，我觉得这种方法适合那个咒语 - 它感觉像一个子类，因为你有一个定位逻辑和控制设置的地方，实现事件处理程序等等 - 但是你可以进一步进入子类地狱。</p><p>  As I&#39;m writing this, Cacao is  0.2.0. It  would be  0.1.0, but crates.io has a bit of a squatting issue, so  0.1.0 didn&#39;t truly exist.</p><p>  作为i＆＃39;编写这一点，可可是0.2.0。它将是0.1.0，但箱子有一点蹲下问题，所以0.1.0没有真正存在。 </p><p> It currently supports enough widgets on macOS to be usable. You can check out the  examples folder to see more.</p><p>它目前支持足够的小部件可以使用摩托斯。您可以查看示例文件夹以查看更多。</p><p>  iOS support... it&#39;s more of a demo, but there&#39;s nothing really blocking controls from being ported other than the time investment.</p><p>  iOS支持......它的一个演示中的更多信息，但是没有什么可以阻止被移植以外的控制。</p><p>  I don&#39;t expect that anybody would say to themselves &#34;alright, time to write/rewrite macOS apps in Rust&#34;. I would expect that Cacao would never be able to be as usable as the blessed layers and frameworks that can be found with Swift and Objective-C, and I don&#39;t see the crossover between Apple-ecosystem developers and Rust-developers needing GUI tools to be massive.</p><p>  我不期待任何人都会对自己说和＃34;好的，在生锈和＃34中写/重写麦斯科斯应用程序的时间;我希望Cacao永远不能像能够用SWIFT和Objective-C找到的祝福层和框架一样可用，我没有看到苹果生态系统开发商和生锈开发人员之间的交叉GUI工具是巨大的。</p><p>   I think it&#39;s conceivable that there are Rust-based utilities (scripts, etc) that could be useful with a GUI, but bridging is (frankly) boring work, and frustrating when it goes wrong. Cacao is useful in this scenario as it enables building a native macOS GUI without having to leave the Rust ecosystem.</p><p>   我认为它可以想到，有基于生锈的公用事业（脚本等），可能对GUI有用，但桥接是（坦率地）无聊的工作，并且在出现问题时令人沮丧。 Cacao在这种情况下很有用，因为它可以在不必离开生锈生态系统的情况下构建本机麦斯科群岛GUI。</p><p>   Target only the big three (Windows, macOS, Gnome). Anything else can be community supported.  Maybe iOS and/or Android, if the effort isn&#39;t too signficant.</p><p>   只针对三大（Windows，MacOS，Gnome）。其他任何东西都可以支持社区。也许iOS和/或Android，如果努力是＆＃39; t太签名。</p><p> Offering more than the basic controls makes the framework unmaintainable over time. Follow the web model and keep the kitchen sink barebones, even if it&#39;s annoying. Long term maintainability &gt; a million widgets.</p><p> 提供超过基本控件使框架不会随着时间的推移。遵循网络模型并保持厨房槽的圆线，即使它又讨厌。长期可维护性和gt;一百万个小部件。</p><p> Always expose a native hook on each control for the cases where someone knows what they want. AKA, get out of the way when asked.</p><p> 始终在每个控件上公开一个本机钩子，以便有人知道他们想要的东西。又名，当被问到时，就会走开。 </p><p> I think some combination of  winsafe,  gtk-rs, and  cacao could achieve this. If it happens, I&#39;m happy to repurpose  alchemy for this and make it a community thing - it was my original attempt at building a Rust cross-platform GUI, until I was sidelined by life events.</p><p>我想WinSafe，GTK-RS和Cacao的一些组合可以实现这一目标。如果发生，我很高兴为此重新努力解决炼金术并使其成为社区的事情 - 这是我在建造一个锈的跨平台GUI的原始尝试，直到我被生活事件缺席。</p><p>  A cool thing about Cacao is that the approach can work on iOS (and, presumably, tvOS) too. While support is currently very alpha in comparison to macOS, you are able to  build a proper iOS app and run it:</p><p>  关于中可的一个很酷的事情是，该方法也可以在iOS（以及，概述，TVOS）上工作。虽然支持与MacOS相比，支持是非常alpha，但您可以构建一个适当的iOS应用程序并运行它：</p><p>  This implements the newer  UIScene API, meaning you should have a modern app that works well across both iOS and iPad (and in particular supports the iPad multi-app capability).</p><p>  这实现了较新的UISCENE API，这意味着您应该有一个现代应用程序，它跨IOS和iPad运行良好（并且特别支持iPad多应用功能）。</p><p>  Part of why I wanted to push out  0.2.0 is for community usage. I&#39;m curious to see how people like it, whether it sees adoption, and so on. The documentation isn&#39;t perfect by any means (I welcome pull requests on this, although I&#39;ll continue to work on it as well), but I&#39;m hopeful that feedback drives it forward.</p><p>  一部分为什么我想推出0.2.0是为了社区使用。我很想看看人们喜欢它，无论是采用，等等。文档不完美的任何手段（我欢迎在此方面提取请求，虽然我也会继续下去它），但是我希望反馈推动它前进的反馈推动它的＆＃39。</p><p> In the long (long) term, I think frameworks like this will fade into the background and become building blocks for something like a RustUI (akin to SwiftUI with AppKit/UIKit). This is fine, and I consider it a win if Cacao acts as a bridge between UI generations.</p><p> 在长（长）的术语中，我认为这样的框架将淡入背景，并成为像Rustui这样的东西的构建块（类似于Appkit / Uikit的Swifui）。这很好，如果是Cacao作为UI世代之间的桥梁，我认为这是一个胜利。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rymc.io/blog/2021/cacao-rs-macos-ios-rust/">https://rymc.io/blog/2021/cacao-rs-macos-ios-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/building/">#building</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>