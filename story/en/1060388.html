<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实现HDB：_hyperscript调试器 Implementing HDB: The _hyperscript Debugger</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing HDB: The _hyperscript Debugger<br/>实现HDB：_hyperscript调试器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 11:12:37</div><div class="page_narrow text-break page_content"><p>The 0.0.6 release of the  _hyperscript hypertext UI scripting language introduces HDB, an interactive debugging environment. In this article I discuss how the hyper-flexible hyperscript runtime allowed me to implement the first release of HDB with ease. But first, I will introduce you to what HDB is like:</p><p>0.0.6的_hyperscript超文本UI脚本语言引入了HDB，交互式调试环境。在本文中，我讨论了如何轻松地实现Hyper-FlexiCred Runtime如何实现HDB的第一个版本。但首先，我会向您介绍HDB的样子：</p><p>          In the hyperscript runtime (which is a tree walking interpreter), each command has an  execute() method which either returns the next command to be executed, or a  Promise thereof. The execute method for the breakpoint command creates an HDB environment and assigns it to the global scope (usually  window):</p><p>          在缺记runtime（这是树行走解释器）中，每个命令具有execute（）方法，该方法返回要执行的下一个命令，或其承诺。 BreakPoint命令的执行方法会创建HDB环境，并将其分配给全局范围（通常是窗口）：</p><p>  The  HDB object keeps hold of the current command and context as we step through. (The context is the object holding the local variables for the hyperscript code, and some other things the runtime keeps track of). We call its  break() method:</p><p>  HDB对象随着我们逐步持有当前命令和上下文。 （上下文是持有屏幕上的局部变量的对象，以及运行时跟踪的其他一些事情）。我们称之为break（）方法：</p><p> .prototype . break  =  function ( ctx )  { 	 var self  =  this ; 	console . log ( &#34;%c=== HDB///_hyperscript/debugger ===&#34; , headingStyle ) ; 	self . ui ( ) ; 	 return  new   ( function  ( resolve , reject )  { 		self .bus . addEventListener ( &#34;continue&#34; ,  function  ( )  { 			 if  (self .ctx  !== ctx )  { 				 // Context switch 				 for  ( var attr  in ctx )  { 					 delete ctx [attr ] ; 				 } 				Object . assign (ctx , self .ctx ) ; 			 } 			 delete window .hdb ; 			 resolve (self .runtime . findNext (self .cmd , self .ctx ) ) ; 		 } ,  { once :  true  } ) ; 	 } )  }</p><p> 。原型 。 break =函数（ctx）{var self = this;安慰 。日志（＆＃34;％c === hdb /// _ hyperscript / debugger ===＆＃34;，头饰）;自己 。 UI（）;返回新（函数（解析，拒绝）{self .bus。addeventlistener（＆＃34;继续＆＃34;函数（）{if（self .ctx！== ctx）{//上下文切换（var attr在ctx中）{删除CTX [attr];}对象。分配（ctx，self .ctx）;删除窗口.hdb;解析（self .runtime。findnext（self .cmd，self .ctx））;}，{一次：true }）;}）}</p><p> There are a few things to unpack here. We call  self.ui() to start the UI, which we’ll get to later. Remember how a command can return the next method to execute as a promise? The break method resolves after the  internal event bus receives a  &#34;continue&#34; event, whether by the user pressing “Continue” or simply reaching the end of the debugged code.</p><p> 这里有一些东西可以打开包装。我们调用self.ui（）启动UI，我们将稍后开始。请记住，命令如何返回下一个方法作为承诺执行？断裂方法在内部事件总线接收A＆＃34之后解决;继续＆＃34;事件，是否按用户按“继续”或只是到达调试代码的末尾。</p><p> The “context switch” is the dirtiest part of it all. Because we can step out of functions, we might finish debugging session with a different context than before. In this case, we just wipe the old context and copy the current context variables over. Honestly, I thought I’d have to do a lot more of this kind of thing.</p><p> “上下文切换”是它的最肮脏的部分。因为我们可以耗尽函数，所以我们可能会完成与之前的不同上下文的调试会话。在这种情况下，我们只需擦除旧上下文并复制当前上下文变量。老实说，我以为我必须做更多的事情。</p><p>   Firstly, if self.cmd is null, then the previous command was the last one, so we just stop the debug process:</p><p>   首先，如果self.cmd为null，那么上一个命令是最后一个命令，所以我们只需停止调试过程： </p><p>  If not, then we do a little dance to execute the current command and get the next one:</p><p>如果没有，那么我们做了一点舞蹈来执行当前命令并获得下一个命令：</p><p>  We perform a useless check that I forgot to take out ( self.cmd &amp;&amp;). Then, we special-case the  breakpoint command itself and don’t execute it (nested debug sessions don’t end well…), instead finding the subsequent command ourselves with the  runtime.findNext() in hyperscript core. Otherwise, we can execute the current command.</p><p>  我们表现​​了一个无用的检查，我忘了拿出来（self.cmd＆amp;＆amp;）。然后，我们特殊情况 - 断点命令本身并且不执行它（嵌套调试会话不会结束......），而是在鼠标核心核心中使用runtime.findnext（）找到后续命令。否则，我们可以执行当前命令。</p><p>  if  (result .type  ===  &#34;implicitReturn&#34; )  return self . stepOut ( ) ;  if  (result  &amp;&amp; result .then  instanceof   )  { 	 return result . then ( function  ( next )  { 		self .cmd  = next ; 		self .bus . dispatchEvent ( new   ( &#34;step&#34; ) ) ; 		self . logCommand ( ) ; 	 } )  }  else  if  (result .halt_flag )  { 	 this .bus . dispatchEvent ( new   ( &#34;continue&#34; ) ) ;  }  else  { 	self .cmd  = result ; 	self .bus . dispatchEvent ( new   ( &#34;step&#34; ) ) ; 	 this . logCommand ( ) ;  }</p><p>  if（结果.type ===＆＃34; Implicitreturn＆＃34;）回归自我。 Stepout（）; if（结果＆amp;结果.then instanceof）{返回结果。然后（函数（下一个）{self .cmd = next; self .bus。Dispatchevent（＆＃34;步骤＆＃34;））; self。logcommand（）;}）}否则如果（结果.halt_flag）{这个。公共汽车 。 DispatchEvent（新（＆＃34;继续＆＃34））; } else {self .cmd =结果;自我.bus。 DispatchEvent（新（＆＃34; Step＆＃34;））;这 。 logcommand（）; }</p><p> If we returned from a function, we step out of it (discussed below). Otherwise, if the command returned a Promise, we await the next command, set  cmd to it, notify the event bus and log it with some fancy styles. If the result was synchronous and is a [HALT][]; we stop debugging (as I write this, I’m realizing I should’ve called [ continueExec()][continue-exec] here). Finally, we commit the kind of code duplication hyperscript is meant to help you avoid, to handle a synchronous result.</p><p> 如果我们从函数返回，我们搬出它（下面讨论）。否则，如果命令返回承诺，我们等待下一个命令，将cmd设置为它，通知事件总线并使用一些花式样式登录。如果结果是同步的，并且是[停止] [];我们停止调试（正如我写下这个问题，我意识到我应该在这里调用[continueexec（）] [继续执行]）。最后，我们提交了那种代码复制纯净的屏幕旨在帮助您避免，处理同步结果。</p><p> To step out, we first get our hands on the context from which we were called:</p><p> 要走出来，我们首先让我们的手在我们被召唤的背景下：</p><p> .prototype . stepOut  =  function ( )  { 	 var self  =  this ; 	 if  ( !self .ctx .meta .caller )  return self . continueExec ( ) ; 	 var callingCmd  = self .ctx .meta .callingCommand ; 	 var oldMe  = self .ctx .me ; 	self .ctx  = self .ctx .meta .caller ;</p><p> 。原型 。 stepout = function（）{var self = this;如果（！self .ctx .meta .caller）返回自我。 continueexec（）; var callingcmd = self .ctx .meta .callingcommand; var oldme = self .ctx .me; self .ctx = self .ctx .meta .caller;</p><p> Turns out _hyperscript function calls already keep hold of the caller context ( callingCommand was added by me though). After we change context, we do something a little odd:</p><p> 拒绝_hyperscript函数调用已经保留了呼叫者上下文（但是me由me添加）。在改变上下文之后，我们做一些奇怪的事情： </p><p>    We can’t execute the command to set  name until we have the name, so when  getName() is called, the current command is still set to the  transition. We call  findNext once to find the  set, and again to find the  log.</p><p>我们无法执行命令以设置名称，直到我们有名称，因此当调用getName（）时，当前命令仍然设置为转换。我们调用FindNext一次找到集合，然后再次找到日志。</p><p>    What did I use to make the UI for the hyperscript debugger? Hyperscript, of course!</p><p>    我用什么来制作uI用于yprecript调试器？ killscript，当然！</p><p>  There are a lot of elements listening to  load or step from hdb.bus, so I consolidated them under  update from .hdb.  #hyperscript-hdb-ui-wrapper- is the element whose Shadow DOM this UI lives in — using shadow DOM to isolate the styling of the panel cost me later on, as you’ll see.</p><p>  从HDB.Bus中侦听加载或步骤有很多元素，因此我将在从.hdb的更新中巩固它们。 ＃keperscript-hdb-ui-wrapper-是一个元素，它的阴影dom这个ui生活在 - 使用shadow dom来隔离面板的造型在后面的情况下，我会看到。</p><p>   def highlightDebugCode 	set start to hdb.cmd.startToken.start 	set end to hdb.cmd.endToken.end 	set src to hdb.cmd.programSource 	set beforeCmd to escapeHTML(src.substring(0, start)) 	set cmd to escapeHTML(src.substring(start, end)) 	set afterCmd to escapeHTML(src.substring(end)) 	return beforeCmd+&#34; &#34;+cmd+&#34; &#34;+afterCmd end</p><p>   def extullightdebudcode set start to hdb.cmd.starttoken.start设置结尾到hdb.cmd.endtoken.end set src到hdb.cmd.programsource将beForecmd设置为eScapthtml（src.substring（0，start））将cmd设置为eScapthtml（src .substring（开始，结束））将resucmd设置为eScapthtml（src.substring（end））返回beforecmd +＆＃34; ＆＃34; + cmd +＆＃34; ＆＃34; +渣打结束</p><p> Now, I wasn’t aware that we had  template literals in hyperscript at this point, so that’s for the next release. The  escapeHTML helper might disappoint some:</p><p> 现在，我没有意识到我们在这一点上有一个在kidscript中的模板文字，所以这是下一个版本。 eveschthtml帮助者可能会失望一些：</p><p> def escapeHTML(unsafe) 	js(unsafe) return unsafe 		.replace(/&amp;/g, &#34; &#34;) 		.replace(/ /g, &#34; &#34;) 		.replace(/\\x22/g, &#34; &#34;) 		.replace(/\\x27/g, &#34; &amp;#039;&#34;) end 	return it end</p><p> def vectaphtml（不安全）js（不安全）返回不安全.replace（/＆amp; / g，＆＃34;＆＃34;）.replace（/ g，＆＃34;＆＃34;）.replace（/ \ \ x22 / g，＆＃34;＆＃34;）.replace（/ \\ x27 / g，＆＃34;＆amp;＃039;＆＃34;）结束返回它结束</p><p>   And we have the most broken part of HDB, the prettyPrint function. If you know how to do this better, feel free to send a PR.</p><p>   我们拥有HDB最严重的部分，PrettyPrint功能。如果您知道如何更好，请随时发送PR。 </p><p>   Why do I use weird selectors like  &lt;input/&gt; in me when these elements have good IDs? Because  #eval-expr in hyperscript uses  document.querySelector, which doesn’t reach Shadow DOM.</p><p>为什么我使用奇怪的选择器，如＆lt;输入/＆gt;当这些元素有良好的IDS时，在我？因为＃eval-expr在鼠标中使用document.querySelector，它不会到达阴影DOM。</p><p>       That loop could definitely be cleaner. You can see the hidden feature where you can click a variable name to log it to the console (useful if you don’t want to rely on my super-buggy pretty printer).</p><p>       那循环绝对可以清洁。您可以看到隐藏的功能，您可以在其中单击变量名称以将其记录到控制台（如果您不想依赖我的超级仓鼠漂亮的打印机）。</p><p> Some CSS later, we’re done with the UI! To avoid CSS interference from the host page, we create a wrapper and put our UI in its shadow DOM:</p><p> 一些CSS后来，我们已经完成了UI！为避免从主页的干扰，我们创建一个包装器并将我们的UI放在其暗影DOM中：</p><p> .prototype . ui  =  function  ( )  { 	 var node  = document . createElement ( &#39;div&#39; ) ; 	 var shadow  = node . attachShadow ( { mode :  &#39;open&#39;  } ) ; 	node .style  =  &#39;all: initial&#39; ; 	node .id  =  &#39;hyperscript-hdb-ui-wrapper-&#39; ; 	shadow .innerHTML  = ui ; 	document .body . appendChild (node ) ; 	window .hdbUI  = shadow . querySelector ( &#39;.hdb&#39; ) ; 	_hyperscript . processNode (hdbUI ) ;  }</p><p> 。原型 。 UI =函数（）{var node =文档。牧场（＆＃39; div＆＃39;）; var shadow =节点。 attachshadow（{mode：＆＃39;打开＆＃39;}）;节点.style =＆＃39;全部：初始＆＃39; ;节点.id =＆＃39; knerscript-hdb-ui-wrapper  - ＆＃39; ;影子.innerhtml = UI;文件。Body。 AppendChild（节点）;窗口.hdbui =阴影。 QuerySelector（＆＃39; .hdb＆＃39;）; _hyperscript。 ProcessNode（HDBUI）; }</p><p>  In just 360 lines, we have a basic debugger. This speaks volumes to the flexibility of the hyperscript runtime, and I hope HDB serves as an example of what’s possible with the hyperscript extension API. Like the rest of hyperscript, it’s in early stages of development — feedback and contributors are always welcome!</p><p>  只需360行，我们有一个基本的调试器。这会说出viderscript运行时灵活性的卷，我希望HDB用作Hyperscript Extension API的可能性。就像其余的猕猴一样，它在发展的早期阶段 - 反馈和贡献者总是欢迎！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://denizaksimsek.com/2021/the-implementation-of-hdb/">https://denizaksimsek.com/2021/the-implementation-of-hdb/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/hdb/">#hdb</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>