<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>函数式程序员的静态单一赋值</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">函数式程序员的静态单一赋值</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 03:13:04</div><div class="page_narrow text-break page_content"><p>By that I mean that  lambda is my tribe. And you know how tribalism works: when two tribes meet, it&#39;s usually to argue and not to communicate.</p><p>我是说兰布达是我的部落。你知道部落主义是如何运作的：当两个部落相遇时，通常是争吵，而不是交流。</p><p> So it is that I&#39;ve been well-indoctrinated in the lore of the lambda calculus, continuation-passing style intermediate languages, closure conversion and lambda lifting. But when it comes to ideas from outside our tribe, we in the lambda tribe tune out, generally.</p><p>因此，我已经在Lambda演算、延续传递风格的中间语言、闭包转换和Lambda提升的知识中得到了很好的灌输。但是，当谈到来自我们部落以外的想法时，我们兰布达部落的人通常会置身事外。</p><p> At the last Scheme workshop in Montreal, some poor fellow had the temerity to mention SSA on stage. (SSA is what the &#34;machine tribe&#34; uses as an intermediate langauge in their compilers.) I don&#39;t think the &#34;A&#34; was out of his mouth before Olin Shivers&#39; booming drawl started, &#34;d&#39;you mean CPS?&#34; (CPS is what &#34;we&#34; use.) There were titters from the audience, myself included.</p><p>在蒙特利尔的最后一次计划研讨会上，一个可怜的家伙竟然在舞台上大胆地提到了SSA。(SSA是机器部落在他们的编译器中作为中间语言使用的。)。我不认为在奥林·瑟弗斯(Olin Shivers)低沉地说起这句话之前，他已经说出了这句话。你指的是CPS？(CPS就是我们用的东西。)。观众中传来一阵笑声，包括我自己。</p><p> But there are valuable lessons to be learned from SSA language and the optimizations that it enables, come though it may from another tribe. In this article I&#39;d like to look at what the essence of SSA is. To do so, I&#39;ll start with explaining the functional programming story on intermediate languages, as many of my readers are not of my tribe. Then we&#39;ll use that as a fixed point against which SSA may be compared.</p><p>但是，我们可以从SSA语言和它实现的优化中学到宝贵的经验教训，尽管它可能来自另一个部落。在这篇文章中，我想看看SSA的本质是什么。要做到这一点，我将从解释中间语言的函数式编程故事开始，因为我的许多读者都不属于我的圈子。然后，我们将使用它作为一个固定点，可以与SSA进行比较。</p><p>  In the beginning was the  lambda. God saw it, realized he didn&#39;t need anything else, and stopped there.</p><p>最开始的是Lambda。上帝看到了，意识到他不需要其他任何东西，于是就止步于此。</p><p>  Hey, it&#39;s true, right? The lambda-calculus is great because of its expressivity and precision. In that sense this evaluation is a utilitarian one: the lambda-calculus allows us to reason about computation with precision, so it is worth keeping around.</p><p>嘿，这是真的，对吧？λ演算是伟大的，因为它的表现力和精确度。从这个意义上说，这个评估是一个实用的评估：λ演算允许我们对计算进行精确的推理，所以它值得保留。</p><p> I don&#39;t think that Church was thinking about digital computers when he came up with the lambda-calculus back in the 1930s, given that digital computers didn&#39;t exist yet. Nor was McCarthy thinking about computers when he came up with Lisp in the 1960s. But one of McCarthy&#39;s students did hack it up, and that&#39;s still where we are now: translating between the language of the lambda-calculus and machine language.</p><p>我不认为丘奇在20世纪30年代提出λ微积分时正在考虑数字计算机，因为当时数字计算机还不存在。麦卡锡在20世纪60年代提出Lisp时也没有考虑过计算机。但是麦卡锡的一个学生确实破解了它，而且我们现在仍然在做这样的事情：在λ微积分的语言和机器语言之间进行翻译。</p><p> This translation process is compilation, of course. For the first 20 years or so of practicing computer science, compilers (and indeed, languages) were very ad-hoc. In the beginning they didn&#39;t exist, and you just wrote machine code directly, using switches on a control panel or other such things, and later, assembly language. But eventually folks figured out parsing, and you get the first compilers for high-level languages.</p><p>当然，这个翻译过程就是编译。在实践计算机科学的最初20年左右的时间里，编译器(甚至是语言)都是非常特别的。一开始它们并不存在，你只需使用控制面板上的开关或其他类似的东西直接编写机器代码，然后再用汇编语言即可。但最终人们解决了解析问题，你得到了第一批高级语言的编译器。</p><p> I&#39;ve written before about  C not being a high-level assembly language, but back then, FORTRAN was indeed such a language. There wasn&#39;t much between the parser and the code generator. Everyone knows how good compilers work these days: you parse, you optimize, then you generate code. The medium in which you do your work is your  intermediate language. A good intermediate language should be simple, so your optimizer can be simple; expressive, so that you can easily produce it from your source program; and utilitarian, in that its structure enables the kinds of optimizations that you want to make.</p><p>我以前写过关于C不是高级汇编语言的文章，但那时候FORTRAN确实是这样的语言。解析器和代码生成器之间没有太多区别。每个人都知道现在编译器是如何工作的：解析、优化，然后生成代码。你工作的媒介是你的中间语言。一种好的中间语言应该简单，这样您的优化器就可以简单；富于表现力，这样您就可以很容易地从源程序生成它；而且实用，因为它的结构支持您想要进行的各种优化。</p><p> The lambda tribe already had a good intermediate language in this regard, in the form of the lambda-calculus itself. In many ways, solving a logic problem in the lambda-calculus is a lot like optimizing a program. Copy propagation is  beta-reduction.  Inlining is copy propagation extended to lambda expressions. Eta-conversion of continuations eliminates &#34;forwarding blocks&#34; -- basic blocks which have no statements, and just jump to some other continuation. Eta-conversion of functions eliminates functional trampolines.</p><p>在这方面，lambda部落已经有了一种很好的中间语言，其形式就是lambda演算本身。在很多方面，解决lambda演算中的逻辑问题非常类似于优化程序。拷贝传播是测试版缩减。内联是将复制传播扩展到lambda表达式。延续的eta-转换消除了&#34；转发块&#34；--没有语句的基本块，而只是跳转到其他延续。功能的ETA转换消除了功能蹦床。</p><p>  But I&#39;m getting ahead of myself. In the lambda tribe, we don&#39;t actually program in the lambda-calculus, you see. If you read any of our papers there&#39;s always a section in the beginning that defines the language we&#39;re working in, and then defines its semantics as a translation to the lambda-calculus.</p><p>但我有点言过其实了。你看，在lambda部落，我们实际上并不用lambda演算编程。如果你读过我们的任何一篇论文，总会在开头有一节定义我们正在使用的语言，然后将其语义定义为对lambda演算的翻译。</p><p> This translation is always possible, for any programming language, and indeed Peter Landin did so in 1965 for Algol. Landin&#39;s original translations used his &#34;J operator&#34; to capture continuations, allowing a more direct translation of code into the lambda-calculus.</p><p>这种翻译对于任何编程语言都是可能的，事实上，Peter Landin在1965年为ALGOL做到了这一点。Landin的原始翻译使用他的J操作符来捕获延续，从而可以更直接地将代码翻译成lambda演算。</p><p> I wrote more on  Landin, letrec, and the Y combinator a couple of years ago, but I wanted to mention one recent paper that takes a modern look at J,  A Rational Deconstruction of Landin&#39;s J Operator. This paper is co-authored by V8 hacker Kevin Millikin, and cites work by V8 hackers Mads Sig Ager and Lasse R. Nielsen. Indeed all three seem to have had the privilege of having Olivier Danvy as PhD advisor. That&#39;s my tribe!</p><p>几年前，我写了更多关于兰丁、letrec和Y组合子的文章，但我想提一提最近的一篇论文，这篇论文对J进行了现代审视，这篇论文是对兰丁J算子的理性解构(A Rational Deconstruction of Landin&#39；‘s J Operator)。本文由V8黑客Kevin Millikin合著，并引用了V8黑客Mads Sig Ager和Lasse R.Nielsen的工作。事实上，这三个人似乎都有幸得到奥利维尔·丹维(Olivier Danvy)担任博士导师的殊荣。那是我的部落！</p><p> Anyway, J was useful in the context of Landin&#39;s abstract SECD machine, used to investigate the semantics of programs and programming languages. However it does not help the implementor of a compiler to a normal machine, and intermediate languages are all about utility. The answer to this problem, for functional programmers, was to convert the source program to what is known as  continuation-passing style (CPS).</p><p>无论如何，J在Landin的抽象SECD机器的上下文中非常有用，该机器用于研究程序和编程语言的语义。然而，它并不能帮助编译器的实现者在普通机器上运行，而且中间语言都是关于实用程序的。对于函数式程序员来说，这个问题的答案是将源程序转换为所谓的延续传递样式(CPS)。</p><p> With CPS, the program is turned inside out. So instead of  (+ 1 (f (+ 2 3))), you would have:</p><p>有了CPS，程序就被翻了个底朝天。因此，不是(+1(f(+23)，而是：</p><p> lambda return let c1 = 1 letcont k1 t1 = _+ return c1 t1 letcont k2 t2 = f k1 t2 let c2 = 2, c3 = 3 _+ k2 c2 c3</p><p>λ返回让c1=1让k1 t1=_+返回c1 t1让k2 t2=f k1 t2让c2=2，c3=3_+k2 c2 c3</p><p> Usually the outer lambda is left off, as it is implicit. Every call in a CPS program is a tail call, for the purposes of the lambda calculus. Continuations are explicitly represented as lambda expressions. Every function call or primitive operation takes the continuation as an argument. Papers in this field usually use Church&#39;s original lambda-calculus notation instead of the ML-like notation I give here. Continuations introduced by a CPS transformation are usually marked as such, so that they can be efficiently compiled later, without any flow analysis.</p><p>通常会去掉外层的lambda，因为它是隐式的。出于λ演算的目的，CPS程序中的每个调用都是尾部调用。延续被显式表示为lambda表达式。每个函数调用或基元操作都将延续作为参数。这一领域的论文通常使用丘奇最初的λ微积分记法，而不是我在这里给出的ML式记法。CPS转换引入的延续通常都是这样标记的，这样以后就可以有效地编译它们，而不需要进行任何流分析。</p><p>  CPS is capable of expressing higher-order control-flow, for languages in which functions may be passed as values.</p><p>对于函数可以作为值传递的语言，CPS能够表达高阶控制流。</p><p>  All temporary values are named. Unreferenced names represent dead code, or code compiled for effect only. Referenced names are the natural input to a register allocator.</p><p>所有临时值均已命名。未引用的名称表示死代码，或仅为产生效果而编译的代码。引用的名称是寄存器分配器的自然输入。</p><p>  Continuations correspond to named basic blocks. Their names in the source code correspond to a natural flow analysis simply by tracing the definitions and uses of the names. Flow analysis enables more optimizations, like code motion.</p><p>延续对应于命名的基本块。它们在源代码中的名称对应于自然流分析，只需跟踪名称的定义和使用即可。流分析支持更多优化，如代码移动。</p><p> Depending on how you implement your CPS language, you can also attach notes to different continuations to help your graph reduce further: this continuation is an effect context (because its formal parameter is unreferenced in its body, or because you knew that when you made it), so its caller can be processed for effect and not for value; this one is of variable arity (e.g. can receive one or two values), so we could jump directly to the right handler, depending on what we want; etc. Guile&#39;s compiler is not in CPS right now, but I am thinking of rewriting it for this reason, to allow more transparent handling of control flow.</p><p>根据您实现CPS语言的方式，您还可以将注释附加到不同的延续，以帮助您的图形进一步缩减：此延续是一个效果上下文(因为它的形参在其主体中未被引用，或者因为您在创建它时知道这一点)，因此它的调用者可以根据效果而不是值进行处理；这个变量是可变的(例如，可以接收一个或两个值)，因此我们可以根据需要直接跳到正确的处理程序；等等。Guile&#39；的编译器现在不在CPS中，但我正考虑出于这个原因重写它，以允许更透明地处理控制流。</p><p> Note that nowhere in there did I mention Scheme&#39;s  call-with-current-continuation! For me, the utility of CPS is in its explicit naming of temporaries, continuations, and its affordances for optimization. Call/cc is a rare construct in Guile Scheme, that could be optimized better with CPS, but one that I don&#39;t care a whole lot about, because it&#39;s often impossible to prove that the continuation doesn&#39;t escape, and in that case you&#39;re on the slow path anyway.</p><p>请注意，在那里我没有提到Scheme&#39；Call-with-Current-Continue！对我来说，CPS的用处在于它显式地命名了时态、延续以及对优化的支持。Call/cc在Guile Scheme中是一个罕见的构造，使用CPS可以对其进行更好的优化，但我并不太关心它，因为通常不可能证明Continue不会转义，在这种情况下，无论如何您都是在缓慢的道路上。</p><p> So that&#39;s CPS. Continuations compile to jumps within a function, and functions get compiled to closures, or labels for toplevel functions. The best reference I can give on it is Andrew Kennedy&#39;s 2007 paper,  Compiling With Continuations, Continued. CWCC is a really fantastic paper and I highly recommend it.</p><p>所以这就是CPS。延续编译成函数内的跳转，函数编译成闭包，或者顶层函数的标签。我能给出的最好的参考资料是安德鲁·肯尼迪(Andrew Kennedy)2007年的论文，“继续编译”(Compiling With Continuations)。CWCC是一篇非常棒的论文，我强烈推荐它。</p><p>  CPS fell out of favor in the nineties, in favor of what became known as Administrative Normal Form, or ANF. ANF is like CPS except instead of naming the continuations, the code is left in so-called &#34;direct-style&#34;, in which the continuations are implicit. So my previous example would look like this:</p><p>CPS在90年代失宠，取而代之的是后来被称为管理范式(ANF)的东西。ANF类似于CP，不同之处在于代码没有命名Continuations，而是将代码保留在所谓的直接样式&#34；中，其中的Continuations是隐式的。因此，我前面的示例如下所示：</p><p> let c2 = 2, c3 = 3 let t2 = + c2 c3 let t1 = f t2 let c1 = 1 + c1 t1</p><p>设c2=2，c3=3，t2=+c2c3，t1=ft2，c1=1+c1t1。</p><p> There are ANF correspondences for CPS reductions, like the beta-rule. See the  Essence of Compiling With Continuations paper, which introduced ANF and sparked the decline of the original CPS formulation, for more.</p><p>与贝塔规则一样，CPS降低也有ANF对应关系。有关更多信息，请参阅“使用延续进行编译的本质”一文，其中引入了ANF并引发了原始CPS公式的衰落。</p><p> This CPS-vs-ANF discussion still goes on, even now in 2011. In particular, Kennedy&#39;s CWCC paper is quite compelling. But the debate has been largely mooted by the advances made by the machine tribe, as enabled by their SSA intermediate language.</p><p>这种CPS-VS-ANF的讨论仍然在进行，即使是在2011年的今天。特别值得一提的是，肯尼迪的CWCC论文相当有说服力。但这场辩论在很大程度上是由机器部落取得的进步引起的，这一进步是由他们的SSA中间语言实现的。</p><p>    Instead of compiling abstract ideas of naming and control to existing hardware, as the lambda tribe did, the machine tribe took as a given the hardware available, and tries to expose the capabilities of the machine to the programmer.</p><p>机器部落没有像lambda部落那样将命名和控制的抽象概念编译到现有的硬件上，而是将可用的硬件视为给定的硬件，并试图将机器的功能暴露给程序员。</p><p> The machine tribe doesn&#39;t roll with closures, continuations, or tail calls. But they do have loops, and they crunch a lot of data. The most important thing for a compiler of a machine-tribe language like C is to produce efficient machine code for loops.</p><p>机器部落不会使用闭包、延续或尾部调用。但它们确实有循环，而且它们会处理大量数据。对于像C这样的机器部落语言的编译器来说，最重要的是为循环生成高效的机器代码。</p><p> Clearly, I&#39;m making some simplifications here. But if you look at a machine-tribe language like Java, you will be dealing with many control-flow constructs that are built-in to the language ( for,  while, etc.) instead of layered on top of recursion like loops in Scheme. What this means is that large, important parts of your program have already collapsed to a first-order control-flow graph problem. Layering other optimizations on top of this like inlining ( the mother of all optimizations) only expands this first-order flow graph. More on &#34;first-order&#34; later.</p><p>显然，我在这里做了一些简化。但是，如果您查看一种机器部落语言(如Java)，您将处理该语言中内置的许多控制流构造(for、while等)。而不是像Scheme中的循环一样分层在递归之上。这意味着程序的大部分、重要部分已经崩溃为一阶控制流图问题。在此基础上分层其他优化，如内联(所有优化之母)，只会展开这个一阶流程图。稍后会有更多关于第一份订单的内容。</p><p> So! After decades of struggling with this problem, after having abstracted away from assembly language to three-address register transfer language, finally the machine folks came up with something truly great: static single-assignment (SSA) form. The arc here is away from the machine, and towards more abstraction, in order to be able to optimize better, and thus generate better code.</p><p>所以!。在与这个问题斗争了几十年之后，在从汇编语言抽象到三地址寄存器传输语言之后，机器专家们终于想出了一些真正伟大的东西：静态单赋值(SSA)形式。这里的圆弧远离机器，朝向更抽象的方向，以便能够更好地优化，从而生成更好的代码。</p><p> It&#39;s precisely for this utilitarian reason that SSA was developed. Consider one of the earliest SSA papers,  Global Value Numbers and Redundant Comparisons by Rosen, Wegman, and Zadeck. Rosen et al were concerned about being able to move invariant expressions out of loops, extending the &#34;value numbering&#34; technique to operate across basic blocks. But the assignment-oriented intermediate languages that they had been using were getting in the way of code motion.</p><p>正是出于这个功利的原因，SSA应运而生。考虑一下最早的SSA论文之一，罗森、韦格曼和扎德克的“全球价值数字和冗余比较”(Global Value Number And Redundant Compare)。Rosen等人关心的是能否将不变表达式移出循环，将值编号技术扩展到跨基本块操作。但是他们一直在使用的面向赋值的中间语言阻碍了代码的移动。</p><p> To fix this issue, Rosen et al switched from the assignment-oriented model of the machine tribe to the  binding-oriented model of the lambda tribe.</p><p>为了解决这个问题，Rosen等人从机器部落的面向赋值的模型切换到了lambda部落的面向绑定的模型。</p><p> In SSA, variables are never mutated (assigned); they are bound once and then left alone. Assignment to a source-program variable produces a new binding in the SSA intermediate language.</p><p>在SSA中，变量永远不会变异(赋值)；它们只绑定一次，然后就保持原样。对源程序变量的赋值会在SSA中间语言中生成新的绑定。</p><p>  function clamp (x, lower, upper) { if (x &lt; lower) x = lower; else if (x &gt; upper) x = upper; return x;}</p><p>函数CLAMP(x，LOWER，UPPER){IF(x&lt；LOWER)x=LOWER；ELSE IF(x&&gt;；UPER)x=SUPPER；RETURN x；}。</p><p>  entry: x0, lower0, upper0 = args; goto b0;b0: t0 = x0 &lt; lower0; goto t0 ? b1 : b2;b1: x1 = lower0; goto exit;b2: t1 = x0 &gt; upper0; goto t1 ? b3 : exit; b3: x2 = upper0; goto exit; exit: x4 = phi(x0, x1, x2); return x4;</p><p>条目：x0，lower0，upper0=args；转到b0；b0：t0=x0&lt；lower0；转到t0？B1：b2；b1：x1=lower0；转到退出；b2：t1=x0&gt；upper0；转到T1？B3：退出；b3：x2=upper0；转到退出；退出：x4=phi(x0，x1，x2)；返回x4；</p><p> SSA form breaks down a procedure into basic blocks, each of which ends with a branch to another block, either conditional or unconditional. Usually temporary values receive their own names as well, as it facilitates optimization.</p><p>SSA表单将过程分解成多个基本块，每个基本块都以分支到另一个块(无论是有条件的还是无条件的)结束。通常，临时值也会收到自己的名称，因为这有助于优化。</p><p>  The funny thing about SSA is the last bit, the &#34;phi&#34; function. Phi functions are placed at control-flow joins. In our case, the value of  x may be proceed from the argument or from the assignment in the first or second  if statement. The  phi function indicates that.</p><p>关于SSA有趣的是最后一点，即函数。PHI函数放置在控制流连接处。在我们的例子中，x的值可能来自第一个或第二个if语句中的参数或赋值。φ函数表明了这一点。</p><p> But you know, lambda tribe, I didn&#39;t really get what this meant. What  is a phi function? It doesn&#39;t help to consider where the name comes from, that the original IBM compiler hackers put in a &#34;phony&#34; function to merge the various values, but considered that &#34;phi&#34; was a better name if they wanted to be taken seriously by journal editors.</p><p>但是你知道，兰布达部落，我真的不明白这是什么意思。什么是φ函数？考虑到这个名字是从哪里来的，最初的IBM编译器黑客放入一个假函数来合并各种值，这对他们没有帮助，但如果他们想要得到期刊编辑的认真对待，他们认为&#34；φ；是一个更好的名字。</p><p> Maybe phi functions are intuitive to the machine tribe; I don&#39;t know. I doubt it. But fortunately there is another interpretation: that each basic block is a function, and that a phi function indicates that the basic block has an argument.</p><p>也许φ函数对于机器部落来说是直观的；我不知道。我怀疑。但幸运的是，还有另一种解释：每个基本块都是一个函数，而φ函数表示基本块有一个参数。</p><p>  entry x lower upper = letrec b0 = let t0 = x0 &lt; lower if t0 then b1() else b2() b1 = let x = lower exit(x); b2 = let t1 = x &gt; upper0 if t1 then b3() else exit(x) b3 = let x = upper exit(x); exit x = x b0()</p><p>入口x下部上部=letrec b0=让t0=x0&lt；如果t0那么b1()否则b2()b1=让x=下部出口(X)；b2=让t1=x&gt；上部0如果t1则b3()否则退出(X)b3=让x=上部出口(X)；出口x=xb0()。</p><p> Here I have represented basic blocks as named functions instead of labels. Instead of phi functions, we allow the blocks to take a number of arguments; the call sites determine the values that the phi function may take on.</p><p>在这里，我将基本块表示为命名函数，而不是标签。我们允许块接受一些参数，而不是phi函数；调用位置决定了phi函数可能采用的值。</p><p> Note that all calls to blocks are tail calls. Reminds you of CPS, doesn&#39;t it? For more, see Richard Kelsey&#39;s classic paper,  A Correspondence Between Continuation-Passing Style and Static Single Assignment Form, or my earlier article about  Landin, Steele, letrec, and labels.</p><p>请注意，对块的所有调用都是尾部调用。让你想起了CPS，不是吗？有关更多信息，请参阅理查德·凯尔西的经典论文“接续传球风格与静态单一赋值形式之间的对应”，或我早先关于兰丁、斯蒂尔、莱特雷克和标签的文章。</p><p> But for a shorter, readable, entertaining piece, see Appel&#39;s  SSA is Functional Programming. I agree with Appel that we in the lambda-tribe get too hung up on our formalisms, when sometimes the right thing to do is draw a flow-graph.</p><p>不过，如果想要一篇简短、易读、有趣的文章，请参阅阿佩尔的“SSA is Functional Programming”(SSA是函数式编程)。我同意阿佩尔的观点，我们兰布达部落的人过于拘泥于我们的形式主义，而有时正确的做法是画流程图。</p><p>  If it were only this, what I&#39;ve said up to now, then SSA would not be as interesting as CPS, or even ANF. But SSA is not just about binding, it is also about control flow. In order to place your phi functions correctly, you need to build what is called a  dominator tree. One basic block is said to dominate another if all control paths must pass through the first before reaching the second.</p><p>如果只是这样，就像我到目前为止所说的那样，那么SSA就不会像CPS，甚至ANF那样有趣了。但是SSA不仅仅与绑定有关，它还与控制流有关。为了正确放置您的phi函数，您需要构建所谓的主控器树。如果所有控制路径在到达第二个控制路径之前必须经过第一个基本块，则称一个基本块支配另一个基本块。</p><p> For example, the entry block always dominates the entirety of a function. In our example above,  b0 also dominates every other block. However though  b1 does branch to  exit, it does not dominate it, as  exit may be reached on other paths.</p><p>例如，Entry块始终控制整个函数。在上面的示例中，b0还控制所有其他块。然而，虽然b1确实分支到出口，但它并不支配它，因为出口可能在其他路径上到达。</p><p> It turns out that you need to place phi functions wherever a definition of a variable meets a use of the variable that is not strictly dominated by the definition. In our case, that means we place a phi node on  exit. The dominator tree is a precise, efficient control-flow analysis that allows us to answer questions like this one (where do I place a phi node?).</p><p>结果是，您需要将φ函数放在变量定义满足变量使用的任何位置，而该变量不是严格由该定义支配的。在我们的示例中，这意味着我们在出口上放置一个φ节点。主导者树是一种精确、高效的控制流分析，它允许我们回答这样的问题(我应该将φ节点放在哪里？)。</p><p> For more on SSA and dominators, see the very readable 1991 paper by Cytron, Ferrante, Rosen, Wegman, and Zadeck,  Efficiently Computing Static Single Assignment Form and the Control Dependence Graph.</p><p>有关SSA和主控器的更多信息，请参阅Cytron、Ferrante、Rosen、Wegman和Zadeck在1991年发表的可读性很高的论文“高效计算静态单一赋值表和控制依赖图”。</p><p> Typical implementations of SSA embed in each basic block pointers to the predecessors and successors of the blocks, as well as the block&#39;s dominators and (sometimes) post-dominators. (A predecessor is a block that precedes the given node in the control-flow graph; a successor succeeds it. A post-dominator is like a dominator, but for the reverse control flow; search the tubes for more.) There are well-known algorithms to calculate these links in linear time, and the SSA community has developed a number of optimizations on top of this cheap flow information.</p><p>SSA的典型实现在每个基本块中嵌入指向块的前导和后导的指针，以及块的主导者和(有时)后主导者。(前置任务是控制流图中给定节点之前的块；后继任务在它之后。后主控器类似于主控器，但对于反向控制流，请搜索管道以了解更多信息。)。有一些众所周知的算法可以在线性时间内计算这些链接，SSA社区在这种廉价的流量信息基础上开发了许多优化。</p><p> In contrast, the focus in the lambda tribe has been more on  interprocedural control flow, which -- as far as I can tell -- no one does in less than O(N 2) time, which is, as my grandmother would say, &#34;just turrible&#34;.</p><p>相反，lambda部落的焦点更多地集中在过程间控制流上，据我所知，没有人在O(N2)时间内做到这一点，正如我祖母所说，这就是Turrible&#34；。</p><p> I started off with a mention of global value numbering (GVN) on purpose. This is still, 20+ years later,  the big algorithm for code motion in JIT compilers. HotSpot C1 and V8 both use it, and  it just landed in IonMonkey. GVN is well-known, well-studied, and it works. It results in loop-invariant code motion: if an invariant definition reaches a loop header, it can be hoisted out of the loop. In contrast I don&#39;t know of anything from the lambda tribe that really stacks up. There probably is something, but it&#39;s certainly not as well-studied.</p><p>我一开始就特意提到了全局值编号(GVN)。20多年后，这仍然是JIT编译器中代码移动的重要算法。HotSpot C1和V8都在使用它，它刚刚登陆了IonMonkey。GVN是众所周知的，研究得很好的，而且它是有效的。这会导致循环不变代码移动：如果不变定义到达循环标头，则可以将其提升出循环。相比之下，我不知道来自兰姆达部落的任何东西是真正堆积起来的。可能有一些东西，但肯定没有那么深入的研究。</p><p>  Peoples of the machine tribe, could you imagine returning a block as a value? Didn&#39;t think so. It doesn&#39;t make sense to return a label. But that&#39;s exactly what the lambda-calculus is about. One may represent blocks as functions, and use them as such, but one may also pass them as arguments and return them as values. Such blocks are of a higher order than the normal kind of block that is a jump target. Indeed it&#39;s the only way to express recursion in the basic lambda calculus.</p><p>机器部落的人们，你们能想象返回一个块作为值吗？我不这么认为。退回标签是没有意义的。但这正是λ微积分的意义所在。可以将块表示为函数，并将其作为函数使用，但也可以将它们作为参数传递并作为值返回。这样的块比作为跳转目标的正常类型的块具有更高的顺序。事实上，这是在基本的λ演算中表示递归的唯一方式。</p><p> That&#39;s what I mean when I say that CPS is good as a higher-order intermediate language, and when I say that SSA is a good first-order intermediate language.</p><p>这就是当我说CPS作为一种高级中间语言很好，以及当我说SSA是一种很好的一阶中间语言时，这就是我的意思。</p><p> If you have a fundamentally higher-order language, one in which you need to loop by recursion, then you have two options: do whole-program analysis to aggressively closure-convert your program to be first-order, and then you can use SSA, or use a higher-order IL, and use something more like CPS.</p><p>如果您有一种基本上更高阶的语言，其中您需要通过递归进行循环，那么您有两个选择：进行全程序分析以积极地闭包-将您的程序转换为一阶，然后您可以使用SSA，或者使用更高阶的IL，并使用更像CPS的东西。</p><p> MLton is an example of a compiler that does the former. Actually, MLton&#39;s  SSA implementation is simply lovely. They do represent blocks as functions with arguments instead of labels and phi functions.</p><p>MLton是执行前者的编译器的一个示例。实际上，MLton的SSA实现非常可爱。它们确实将块表示为带参数的函数，而不是标签和phi函数。</p><p> But if you can&#39;t do whole-program analysis -- maybe because you want to extend your program at runtime, support separate compilation, or whatever -- then you can&#39;t use SSA as a global IL. That&#39;s not to say that you shouldn&#39;t identify first-order segments of your program and apply SSA-like analysis and optimization on them, of course! That&#39;s really where the lambda tribe should go.</p><p>但是，如果您不能进行全程序分析--可能是因为您希望在运行时扩展程序、支持单独编译等--那么您就不能将SSA用作全局IL。当然，这并不是说您不应该识别程序的一阶部分，并对其应用类似SSA的分析和优化！那才是兰姆达部落真正应该去的地方。</p><p>   I wrote this because I was in the middle of V8&#39;s Crankshaft compiler and realized I didn&#39;t understand some of the idioms, so I went off to read a bunch of papers. At the same time, I wanted to settle the CPS-versus-ANF question for my Guile work. (Guile currently has a direct-style compiler, for which there are precious few optimizations; this fact is mostly a result of being difficult to work with the IL.)</p><p>我写这篇文章是因为我正在编写V8&#39；的曲轴编译器，我意识到我不理解其中的一些习语，所以我去看了一大堆论文。同时，我想为我的诡计工作解决CPS与ANF的问题。(Guile目前有一个直接风格的编译器，针对它的优化非常少；这主要是由于难以使用IL造成的。)。</p><p> This post summarizes my findings, but I&#39;m sure I made a mistake somewhere. Please note any corrections in the comments.</p><p>这篇帖子总结了我的发现，但我确信我在什么地方弄错了。请注意评论中的任何更正。</p><p> Andreas Zwinkau says:   What is a phi-function? You may see it as a funny way to denote copies, because this is how they are deconstructed/removed. I&#39;d write your example in SSA-form like this:</p><p>安德烈亚斯·兹文考(Andreas Zwinkau)说：什么是φ函数？您可能会认为这是一种有趣的表示副本的方式，因为这是它们被解构/删除的方式。我会用SSA格式编写您的示例，如下所示：</p><p> function clamp (x0, lower, upper) {  if (x0 &lt; lower)  x1 = lower;  else if (x0 &gt; upper)  x2 = upper;  x3 = phi(x1,x2,x0);  return x3;  }</p><p>函数夹具(X0，LOWER，UPPER){if(x0；lt；LOWER)x1=LOWER；ELSE IF(X0&&gt;；UPER)x2=UPPER；x3=Phi(x1，x2，x0)；返回x3；}。</p><p>  function clamp (x, lower, upper) {  if (x &lt; lower);  else if (x &gt; upper);  x2 = phi(lower,upper,x);  return x2;  }</p><p>函数CLAMP(x，LOWER，UPPER){IF(x&lt；LOWER)；ELSE IF(x&&gt;；UPER)；x2=φ(LOWER，UPPER，x)；RETURN x2；}。</p><p>  function clamp (x0, lower, upper) {  if (x &lt; lower)  x2 = lower;  else if (x &gt; upper)  x2 = upper;  else  x2 = x;  return x2;  }</p><p>函数夹具(X0，LOWER，UPPER){IF(x&lt；LOWER)x2=LOWER；ELSE IF(x&&gt;；UPER)x2=UPPER；ELSE x2=x；RETURN x2；}。</p><p> For example, LLVM does this in the backend. Since x2 is assigned twice, this is not in SSA-form anymore.</p><p>例如，LLVM在后端执行此操作。由于x2被分配了两次，因此它不再是SSA形式。</p><p> Also, note that SSA-form is not a kind or type of IL. It is a property of a representation. Also, there is nothing that about SSA, that you could not do without it. It just encodes analyses like &#34;reaching definition&#34; into the program representation.</p><p>另外，请注意，SSA-Form不是一种或一种类型的IL。它是一种表示的属性。而且，没有任何关于SSA的东西是你不能没有它的。它只是将分析(如达到定义)编码到程序表示中。</p><p> Finally, for a pet peeve of mine, SSA actually makes the concept of variables unecessary. Since any operand has exactly one defining operation, you can represent that just by a reference to this operation. This makes stuff like copy-propagation implicit, since copies are noops. See http://pp.info.uni-karlsruhe.de/publication.php?id=braun11wir</p><p>最后，让我很恼火的是，SSA实际上让变量的概念变得不必要了。因为任何操作数都只有一个定义操作，所以您可以通过引用此操作来表示该操作。这使得像复制传播这样的东西是隐式的，因为副本是Noop。请参阅http://pp.info.uni-karlsruhe.de/publication.php?id=braun11wir。</p><p>  Verte says:   &#34;In contrast, the focus in the lambda tribe has been more on *inter*procedural control flow, which -- as far as I can tell -- no one does in less than O(N^2) time, which is, as my grandmother would say, &#34;just turrible&#34;.&#34;</p><p>Verte说：相比之下，Lambda部落的焦点更多地放在*程序间控制流上，据我所知，没有人在O(N^2)时间内做到这一点，正如我祖母所说，这就是说，就像我的祖母所说的那样，这就是Turrible&#34；。&#34；的焦点更多地集中在*程序间控制流上。&#34；据我所知，没有人在O(N^2)时间内做到这一点。</p><p>  If you do certain things lazily, you can get below that for the common case. Whether you can or not depends on what you&#39;re actually trying to analyse, though.</p><p>如果你做某些事情懒惰，你可以在一般情况下做到这一点。然而，你能不能做到这一点取决于你实际上想要分析的是什么。</p><p> Don Stewart says:   Note that you can convert between SSA and ANF form. See the 2003 paper, &#34;A Functional Perspective on SSA Optimisation Algorithms&#34;,  Chakravarty, Keller and Zadarnowski, which introduces (and imp</p><p>Don Stewart说：请注意，您可以在SSA和ANF格式之间进行转换。参见2003年的论文《SSA优化算法的功能透视》，Chakravarty，Keller and Zadarnowski，其中介绍了(和imp。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wingolog.org/archives/2011/07/12/static-single-assignment-for-functional-programmers">https://wingolog.org/archives/2011/07/12/static-single-assignment-for-functional-programmers</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序员/">#程序员</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/single/">#single</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ssa/">#ssa</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030893.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1db729c0554b8ba6d54c31ff2931b7e4.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030893.html">构建跨平台的应用程序可能会很危险，尤其是对于初创企业而言</a></div><span class="my_story_list_date">2020-10-24 8:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030851.html"><img src="http://img2.diglog.com/img/2020/10/thumb_370f22c0aab1ef69efb4604e1a8f3b3d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030851.html">ClipDrop允许您使用手机摄像头将现实生活中的对象“复制并粘贴”到桌面应用程序中</a></div><span class="my_story_list_date">2020-10-24 7:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030728.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3d0a53789931404fb6e42f3d422fc987.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030728.html">看看谷歌的下一个10亿用户团队，该团队的任务是为尚未使用互联网的人(通常是在发展中市场)开发产品和应用程序</a></div><span class="my_story_list_date">2020-10-23 12:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030700.html"><img src="http://img2.diglog.com/img/2020/10/thumb_084859d72b5b9b1233be677f4ccee877.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030700.html">无缝交换Netflix Android应用程序的API后端</a></div><span class="my_story_list_date">2020-10-23 7:18</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>