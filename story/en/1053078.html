<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将数百万并发WebSocket迁移到特使 Migrating Millions of Concurrent WebSockets to Envoy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Migrating Millions of Concurrent WebSockets to Envoy<br/>将数百万并发WebSocket迁移到特使 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 03:41:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/cc674ed7f7395b75e534ab7781a05c7b.png"><img src="http://img2.diglog.com/img/2021/3/cc674ed7f7395b75e534ab7781a05c7b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Slack has a global customer base, with millions of simultaneously connected users at peak times. Most of the communication between users involves sending lots of tiny messages to each other. For much of Slack’s history, we’ve used  HAProxy as a load balancer for all incoming traffic. Today, we’ll talk about problems we faced with HAProxy, how we solved them with  Envoy Proxy, the steps involved in the migration, and what the outcome was. Let’s dive in!</p><p>Slack有一个全球客户群，在高峰时段的数百万同时连接用户。用户之间的大多数沟通涉及彼此发送大量微小消息。对于大部分休闲历史，我们将Haproxy用作所有传入流量的负载均衡器。今天，我们将谈论我们面临的问题，我们如何用特使代理解决它们，迁移所涉及的步骤以及结果是什么。让我们潜入！</p><p>  To deliver messages instantly, we use a  websocket connection, a bidirectional communications link which is responsible for you seeing “Several people are typing…” and then the thing they typed, nearly as fast as the speed of light permits. The websocket connections are ingested into a system called “wss” (WebSocket Service) and accessible from the internet using wss-primary.slack.com and wss-backup.slack.com (it’s not a website, you just get a HTTP 404 if you go there).</p><p>  要立即传送消息，我们使用WebSocket连接，一个双向通信链路负责您看到“几个人正在键入...”，然后将其键入的东西键入，几乎与光速度一样快。 WebSocket连接被摄取到名为“WSS”（WebSocket服务）的系统中，并使用WSSS-Primary.slack.com和WSS-Backup.slack.com（这不是网站，您只需获取HTTP 404，即可从Internet访问你去那里）。</p><p>  Websocket connections start out as regular HTTPS connections, and then the client issues a protocol switch request to upgrade the connection to a websocket. At Slack, we have different websocket services dedicated to messages, to presence (listing which contacts are online), and to other services. One of the websocket endpoints is specifically made for apps that need to interact with Slack (because apps want real-time communication too).</p><p>  WebSocket连接作为常规HTTPS连接启动，然后客户端发出协议交换请求以升级与WebSocket的连接。在Slack时，我们有不同的WebSocket服务专用于消息，存在（列出哪些联系人在线），以及其他服务。其中一个WebSocket端点专门用于需要与Slack交互的应用程序（因为应用程序也想要实时通信）。</p><p>  In the past, we had a set of HAProxy instances specifically dedicated to websockets in multiple  AWS regions to terminate websocket connections close to the user and forward the request to corresponding backend services.</p><p>  在过去，我们在多个AWS区域中有一组专用于WebSockets的HAProxy实例，以终止靠近用户的WebSocket连接并将请求转发给相应的后端服务。</p><p>  While we have been using HAproxy since the beginning of Slack and knew how to operate it at scale, there were some operational challenges that made us consider alternatives, like Envoy Proxy.</p><p>  虽然我们一直在使用Haproxy以来，但在Slack开始并了解如何在规模上运行它，但有一些业务挑战使我们考虑替代品，如Evenoy代理。</p><p>  At Slack, it is a common event for backend service endpoint lists to change (due to instances being added or cycled away). HAProxy provides two ways to update its configuration to accommodate changes in endpoint lists. One is to use the HAProxy Runtime API. We used this approach with one of our sets of HAProxy instances, and our experience is described in another blog post —  A Terrible, Horrible, No-Good, Very Bad Day at Slack. The other approach, which we used for the websockets load balancer (LB), is to render the backends into the HAProxy configuration file and reload HAProxy.</p><p>  在Slack时，它是后端服务端点列表更改的常见事件（由于添加或循环外部）。 HAProxy提供了两种方法来更新其配置以适应端点列表中的更改。一个是使用HAProxy运行时API。我们使用这种方法与我们的一个Haproxy实例之一，我们的经验描述于另一个博客文章中 - 一个可怕，可怕，没有好的，在松弛时非常糟糕的一天。我们用于WebSockets Load Balancer（LB）的其他方法是将后端渲染到HAProxy配置文件中并重新加载HAProxy。</p><p> With every HAProxy reload, a new set of processes is created to handle the new incoming connections. We’d keep running the old process for many hours to allow long-lived websocket connections to drain and avoid frequent disconnections of users. However, we can’t have too many HAProxy processes each running with it’s own “at the time” copy of the configuration — we wanted instances to converge on the new version of the configuration faster. We had to periodically reap old HAProxy processes, and restrict how often HAProxy could reload in case there was a churn in underlying backends.</p><p> 使用每个HAProxy重新加载，创建一个新的进程来处理新的传入连接。我们会继续运行旧进程数小时才能允许长期的WebSocket连接耗尽并避免频繁断开用户。但是，我们不能拥有太多的haproxy进程，每个流程每个都运行它是自己的“当时”的配置 - 我们希望在新版本的配置上更快地收敛实例。我们不得不定期获得旧的HAProxy流程，并限制Haproxy可以重新加载的频率，以防底层后端遇到潮流。 </p><p> Whichever approach we used, it needed some extra infrastructure in place for managing HAProxy reloads.</p><p>无论我们使用哪种方法，它都需要一些额外的基础架构来管理HAProxy重新加载。</p><p> Envoy allows us to use  dynamically configured clusters and endpoints, which means it doesn’t need to be reloaded if the endpoint list changes. If code or configuration do change, Envoy has the ability to  hot restart itself without dropping any connections. Envoy watches filesystem configurations with  inotify for updates. Envoy also copies statistics from the parent process to the child process during a hot restart, so gauges and counters don’t get reset.</p><p> Envoy允许我们使用动态配置的群集和端点，这意味着如果端点列表更改，则不需要重新加载。如果代码或配置进行更改，则Envoy可以在不删除任何连接的情况下热重启。 Envoy手表具有Inotify的文件系统配置进行更新。 Emenoy还在热重启期间将父进程中的统计信息复制到子进程，因此仪表和计数器不会重置。</p><p> This all adds up to a significant reduction in operational overhead with Envoy, and no additional services needed to manage configuration changes or restarts.</p><p> 这一切都会增加了与特使的操作开销的显着减少，并且无法管理配置更改或重新启动所需的其他服务。</p><p>     Panic Routing – Envoy will generally route traffic only to healthy backends, but it can be configured to send traffic to all backends, healthy or unhealthy, if the percentage of healthy hosts drops below a threshold. This was very helpful during our  January 4, 2021 outage, which was caused by a widespread network problem in our infrastructure.</p><p>     恐慌路由 - 特使通常将仅将流量路由到健康的后果，但如果健康主机的百分比下降到阈值以下，则可以配置为向所有后端，健康或不健康发送流量。这在2011年1月4日的中断期间非常有用，这是由我们基础设施的广泛网络问题引起的。</p><p> Because of the above reasons, in 2019, we decided to migrate our ingress load balancing tier from HAproxy to Envoy Proxy, starting with the websockets stack. The major goals of the migration were improved operability, access to new features that Envoy provides, and more standardization. By moving from HAProxy to Envoy across all of Slack, we would eliminate the need for our team to know the quirks of two pieces of software, to maintain two different kinds of configuration, to manage two build and release pipelines, and so on. By then, we were already using Envoy Proxy as the  data plane in our service mesh. We also have experienced Envoy developers in-house, so we have ready access to Envoy expertise.</p><p> 由于上述原因，在2019年，我们决定从HAProxy迁移到Envoys Proxy，从WebSockets堆栈开始。迁移的主要目标是改进的可操作性，获取特使提供的新功能以及更多标准化。通过从Haproxy移动到所有休闲的特使，我们将消除我们的团队需要了解两块软件的怪癖，维护两种不同的配置，管理两个构建和释放管道，等等。到那时，我们已经使用了Servoy代理作为我们服务网格中的数据平面。我们还有经验丰富的特使开发人员在内部，所以我们已经准备好获得了特使专业知识。</p><p>  The first step in this migration was to review our existing websocket tier configuration and generate an equivalent Envoy configuration. Managing Envoy configuration was one of our biggest challenges during the migration. Envoy has a rich feature set, and its configurations are quite different to those of HAProxy. Envoy configuration deals with four main concepts:</p><p>  此迁移的第一步是审查我们现有的WebSocket层配置并生成等效的特使配置。管理特派团配置是迁移期间的最大挑战之一。特使有一个丰富的功能集，它的配置与Haproxy的配置完全不同。 SEVOY配置处理四个主要概念：</p><p> Clusters, representing the internal services that we send requests to, like message servers and presence servers</p><p> 群集，代表我们发送请求的内部服务，如消息服务器和呈现服务器 </p><p> Configuration management at Slack is primarily done via  Chef. When we started with Envoy, we deployed envoy configuration as a  chef template file, but it became cumbersome and error-prone to manage. To solve this problem, we built chef libraries and  custom resources for generating Envoy configurations.   Inside Chef, the configuration is a  Singleton, modelling the fact that there is only one Envoy configuration per host. All Chef resources operate on that singleton, adding the listeners, routes, or clusters. At the end of the chef run, the envoy.yaml gets generated, validated, and then installed — we never write intermediate configurations, because these could be invalid.</p><p>Slack的配置管理主要通过厨师完成。当我们开始使用Envoy时，我们将特使配置部署为厨师模板文件，但它变得繁琐和容易管理。要解决此问题，我们构建了厨师库和自定义资源以生成特使配置。内部厨师，配置是一个单身级，建模每个主机只有一个特使配置。所有厨师资源都在该单例上运行，添加侦听器，路由或集群。在厨师续期的末尾，Evenoy.yaml生成，验证，然后安装了 - 我们从不编写中间配置，因为这些可能无效。</p><p> This example shows how we can create one HTTP listener with two routes that routes traffic to two  dynamic clusters.</p><p> 此示例显示我们如何创建一个HTTP侦听器，其中两个路由将流量路由到两个动态群集。</p><p> It took some effort to replicate our complicated HAProxy configuration in Envoy. Most of the features needed were already available in Envoy so it was just a matter of adding the support for it to the chef library and voila! We implemented a few missing Envoy features (some were contributed  upstream and some are maintained in-house as extensions).</p><p> 需要努力在特使中复制我们复杂的Haproxy配置。所需的大多数特征已经在特使中提供，所以这只是向厨师图书馆和瞧瞧它的支持！我们实施了一些失踪的特使特征（有些是上游贡献，有些是在内部维持作为扩展）。</p><p>  Testing the new Envoy websockets tier was an iterative process. We often prototyped with hand-coded Envoy configurations and tested it locally on a development machine with one listener, route, and cluster each. Hand-coded changes, once they worked, would be moved into the chef libraries.</p><p>  测试新的Senfoy WebSockets Tier是一个迭代过程。我们经常用手工编码的特派团配置原型，并在具有一个侦听器，路线和群集的开发机上本地测试。一旦他们工作，手工编码的变化将被移入厨师图书馆。</p><p>   We used Envoy debug logging locally on the machine when things didn’t work as expected: Debug logging explains clearly why Envoy chose to route a specific request to a specific cluster. Envoy debug log is very helpful but also verbose and expensive (you really don’t want to enable that in your production environment). Debug logging can be enabled via Curl as shown below:</p><p>   当事情按照预期运行时，我们使用了在机器上本地登录的特使调试：调试日志记录清楚地解释了为什么特使选择将特定请求路由到特定群集。 Envoy调试日志非常有帮助，但也有冗长且昂贵（您真的不想在您的生产环境中启用它）。可以通过CURL启用调试日志记录，如下所示：</p><p>   /clusters – Displays all configured clusters including information about all upstream hosts in each cluster along with per host statistics.</p><p>   / clusters  - 显示所有已配置的群集，包括每个群集中的所有上游主机的信息以及每个主机统计信息。</p><p> /certs – Displays all loaded TLS certificates, including file name, serial number, subject alternate names and days until expiration in JSON format.</p><p> / cercts  - 显示所有已加载的TLS证书，包括文件名，序列号，主题备用名称和JSON格式到期。 </p><p> Our Chef libraries run Envoy with the `–mode validate` command-line option as a validation step, in order to prevent installation of invalid configurations. This can also be done manually:</p><p>我们的厨师库运行Sengoy与`-mode validate`命令行选项作为验证步骤，以防止安装无效的配置。这也可以手动完成：</p><p>  Envoy provides JSON formatted listener logs. We ingest those logs into our logging pipeline (after sanitizing the logs for  PII, of course) and this has often been helpful for debugging.</p><p>  特使提供JSON格式化的侦听器日志。我们将这些日志摄入到我们的记录管道中（当然，在消毒PII的日志之后），这通常有助于调试。</p><p> Once confident with config in our development environment, we were ready to do some more testing — in production!</p><p> 一旦对我们的开发环境中的配置充满信心，我们就可以在生产中进行更多的测试！</p><p>  In order to minimize risk during the migration, we built a new Envoy websocket stack with an equivalent configuration to the existing HAProxy tier. This meant that we could do a gradual, controlled shift of traffic to the new Envoy stack, and that we could quickly switch back to HAProxy if necessary. The downside was our AWS cost — we were using double the resources during the migration but we were willing to spend the time and resources to do this migration transparently for our customers.</p><p>  为了最大限度地减少迁移过程中的风险，我们构建了一个新的Senfoy WebSocket Stack，其具有等效配置到现有的HAProxy层。这意味着我们可以为新的特使堆栈逐步，控制的流量转移，并且如果需要，我们可以快速切换回Haproxy。缺点是我们的AWS成本 - 我们在迁移过程中使用了双倍的资源，但我们愿意花费时间和资源来为客户透明地进行这种迁移。</p><p> We manage our DNS records   wss-primary.slack.com and   wss-backup.slack.com via  NS1. We used weighted routing to shift traffic from  haproxy-wss to  envoy-wss  NLB DNS names. The first regions were rolled out individually in steps of 10%, 25%, 50%, 75%, and 100%. The final regions were done faster (25%, 50%, 75%, 100% in just two days compared to prior one region over the course of a week), as we had confidence in the new Envoy tier and in the rollout process.</p><p> 我们通过NS1管理我们的DNS记录WSS-PRIMARY.SLACK.com和WSS-BACKUP.SLACK.com。我们使用加权路由将流量从HAProxy-WSS转移到Envoy-WSS NLB DNS名称。第一区域单独推出10％，25％，50％，75％和100％的步长。与在一周的前一个地区相比，最终地区的完成速度更快（25％，50％，75％，100％），因为我们对新的特使层和卷展处理过程中的信心有信心。</p><p> Even though the migration was smooth and outage-free, there were a number of minor problems that cropped up, such as differences in timeout values and headers. We reverted, fixed, and rolled out again multiple times during the migration.</p><p> 即使迁移是平滑和无法下降的，也有许多造成的小问题，例如超时值和标题的差异。我们在迁移期间再次恢复，修复，并在多次再次推出。</p><p>   After a very long and exciting 6 months, the migration was complete and the entire HAProxy websocket stack was replaced with Envoy Proxy globally with  zero customer impact.</p><p>   经过一个很长而令人兴奋的6个月后，迁移完成，整个HAProxy WebSocket堆栈被全局替换为零客户影响。 </p><p>  The migration itself was relatively uneventful and boring.  Boring is a good thing: exciting means things break, boring means things keep working.</p><p>迁移本身相对平静，无聊。无聊是一件好事：令人兴奋的意思是事情破裂，无聊意味着事情继续工作。</p><p> We found that the old HAProxy config had grown organically over time. It was largely shaped by the model that HAProxy uses — one large configuration that includes all listeners. Envoy’s configuration model uses much more defined scopes than HAProxy’s model. Once a listener is entered, only the rules inside that listener apply to the requests. Once a route is entered, only rules on that route apply. This makes it much easier to associate rules with the relevant requests.</p><p> 我们发现旧的Haproxy Config随着时间的推移而有机地增长。它主要由Haproxy使用的模型 - 一个包含所有侦听器的大型配置。特使的配置模型使用比haproxy模型更具定义的范围。输入侦听器后，只有该侦听器中的规则仅适用于请求。输入路由后，仅适用该路由的规则。这使得将规则与相关请求相互易于联系起来。</p><p> It took a lot of time to extract what was important in the old HAProxy configuration from what was effectively technical debt. It was often difficult to figure out why a certain rule was in place, what was intentional as opposed to unintentional, and what behavior other services relied on. For example, some services were supposed to only be under one of two virtual hosts (vhosts), but were actually available under both vhosts in HAProxy. We had to replicate this mistake, because existing code relied on that behavior.</p><p> 从有效的技术债务中提取旧的Haproxy配置中很重要的时间需要很多时间。弄清楚为什么某个规则到位为什么，有意就是无意的，以及其他服务的行为依赖的行为。例如，某些服务被认为只属于两个虚拟主机（vhosts）中的一个，但实际上是在Haproxy中的vhost中获得的。我们必须复制这个错误，因为现有代码依赖于该行为。</p><p> We missed a few subtle things in the HAProxy stack. Sometimes these were important — we broke Slack’s Daily Active User (DAU) metric for a bit (oops!). There were a lot of minor issues to fix as well. Load balancer behavior is complex and there was no real way around this problem other than time and debugging.</p><p> 我们在Haproxy堆栈中错过了一些微妙的东西。有时这些都很重要 - 我们为一点（哎呀！）打破了Slack的日常活跃的用户（DAU）度量。还有很多小问题来解决。负载均衡器行为很复杂，除了时间和调试之外，还没有真正的方法。</p><p> We started the migration without a testing framework for the load balancer configurations. Instead of having automated tests that validated that test URLs routed to the correct endpoint and behaviors related to request and response headers we had… a HAProxy config. Tests are helpful during migrations because they can provide a lot of context about the reasons for expected behaviors. Because we lacked tests, we often had to check in with service owners instead to find out what behavior they relied on.</p><p> 没有负载平衡器配置的测试框架，我们开始迁移。而不是拥有自动测试，该测试验证了路由到正确的端点和与请求和响应标题相关的正确终端点和行为的测试URL ...一个HAProxy Config。在迁移期间测试是有帮助的，因为它们可以提供大量关于预期行为的原因的背景。因为我们缺乏测试，我们经常不得不与服务主人一起办理登机手续，以了解他们依赖的行为。</p><p> The Chef resources that we built intentionally supported only a subset of Envoy functionality. This kept our libraries simpler — we only had to consider the features we actually used. The drawback was that each time we wanted to use new Envoy features, we had to add support for them in our Chef libraries. For example,  SNI (https) listeners were written part-way through development, when we decided it would be simpler than adding support to the existing listeners. However, when it came to vhost support, we had so much code developed and in-use already that refactoring resources that were in use elsewhere throughout the company would have taken a long time. The vhost support in our Chef library is a hack (and one day soon we will fix it).</p><p> 我们构建的厨师资源仅支持一个小组功能的子集。这使我们的图书馆更简单 - 我们只需要考虑我们实际使用的功能。缺点是，每次想要使用新的特征功能时，我们都必须在厨师库中为他们添加支持。例如，SNI（HTTPS）侦听器通过开发写成兼职，当我们决定它比向现有侦听器添加支持更简单。然而，当它来到vhost支持时，我们已经开发了很多代码，并且已经在整个公司其他地方使用的重构资源已经需要很长时间。我们厨师图书馆的vhost支持是一个黑客（有一天我们会解决它）。</p><p> To make it safer to change the Envoy resource Chef libraries — in other words, to ensure we didn’t break other teams that were using our libraries — we introduced a comprehensive set of tests that generated those teams’ entire configurations. This made it easy to tell exactly how all our generated Envoy configurations would (or wouldn’t) be impacted when we updated the Envoy Chef resources.</p><p> 为了使Senfoy资源厨师库更安全 - 换句话说，以确保我们没有打破使用我们库的其他团队 - 我们介绍了一系列生成这些团队的整个配置的一系列测试。这使得究竟在更新特使厨师资源时，究竟可以究竟如何影响所有生成的特使配置（或不会）。 </p><p> One of the key things in this migration (like any other) is communication. We worked hard to keep everyone informed and aligned with the changes we were making. Our Customer Experience (CE) team was a great partner — they were able to monitor incoming tickets for anything that might indicate users had been impacted as a result of this migration.</p><p>这种迁移中的一个关键东西（如任何其他）是通信的。我们努力让每个人都通知并与我们所做的更改保持一致。我们的客户体验（CE）团队是一个很棒的合作伙伴 - 他们能够监控任何可能表明用户因此迁移而受到影响的任何可能影响的传入门票。</p><p>  Despite occasional minor setbacks, the envoy websocket migration was a great success. We’ve followed up by migrating another critical Slack service, our software client metrics ingestion pipeline — which is isolated from our other ingress load balancers — to Envoy Proxy. We’re nearly done with migrating the internal load balancers for our web and API traffic to Envoy. The final part of this epic migration is to move our (regular, non-websocket) HTTP stack which terminates incoming traffic at our edge, from HAProxy to Envoy; this is also underway.</p><p>  尽管偶尔的次要挫折，但特使WebSocket迁移是一大堆成功。我们通过迁移另一个关键的休闲服务，我们的软件客户指标摄取管道 - 从我们的其他入口负载平衡器隔离 - 给Envoy Proxy。我们差点迁移了为我们的网络和API流量迁移到Emenoy的内部负载均衡器。此史诗迁移的最后一部分是移动我们的（常规，非WebSocket）HTTP堆栈，该HTTP堆栈终止我们边缘的传入流量，从Haproxy到Envoy;这也是如此。</p><p> We are now within sight of our final goal of standardization on Envoy Proxy for both our ingress load balancers and our service mesh data plane, which will significantly reduce cognitive load and operational complexity for the team, as well as making Envoy’s advanced features available throughout our load balancing infrastructure. Since migrating to Envoy, we’ve exceeded our previous peak load significantly with no issues.</p><p> 我们目睹了我们对我们的入口负荷均衡器和服务网格数据平面的指标标准化的最终目标，这将显着降低团队的认知负荷和运营复杂性，以及在我们的整个方面提供特使的高级功能负载平衡基础架构。由于迁移到特使，我们已经超出了我们之前的峰值负荷，没有任何问题。</p><p> Huge shoutout to the team —  Laura Nolan, Stephan Zuercher, Matthew Girard, David Stern, Mark McBride, John On, Cooper Bethea, V Brennan, Ann Paul, Pramilla Singh, Rafael Elvira and Stuart Williams for all the support and contributions to the project.</p><p> 巨大的Shoutout到团队 -  Laura Nolan，Stephan Zuercher，Matthew Girard，David Stern，Mark McBeride，John On，Cooper Bethea，V Brennan，Ann Paul，普拉马拉·辛格，Rafael Elvira和Stuart Williams为项目的所有支持和贡献。</p><p> Want to help Slack solve tough problems and join our growing team? Check out all our  open positions and apply today.</p><p> 想帮助松懈解决棘手的问题并加入我们的成长团队吗？查看我们所有的开放职位并立即申请。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://slack.engineering/migrating-millions-of-concurrent-websockets-to-envoy/">https://slack.engineering/migrating-millions-of-concurrent-websockets-to-envoy/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/websocket/">#websocket</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/millions/">#millions</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/特使/">#特使</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>