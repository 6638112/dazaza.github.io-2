<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Scala构建您自己的编程语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Scala构建您自己的编程语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 14:14:55</div><div class="page_narrow text-break page_content"><p>One strength of Scala is implementing programming languages. Even if your goal is not to implement an entirely new programming language, these techniques are still useful: for writing linters, program analyzers, query engines, and other such tools. This blog post will walk you through the process of implementing a simple programming language in Scala, introduce some of the fundamental concepts involved, and finishing with a working interpreter for a simple programming language.</p><p>Scala的一个优点是实现编程语言。即使您的目标不是实现一种全新的编程语言，这些技术仍然很有用：用于编写内存、程序分析器、查询引擎和其他类似工具。这篇博客文章将带您完成用Scala实现简单编程语言的过程，介绍一些基本概念，最后介绍一个简单编程语言的可用解释器。</p><p>    About the Author:  Haoyi is a software engineer, and the author of many open-source Scala tools such as the Ammonite REPL and the Mill Build Tool. If you enjoyed the contents on this blog, you may also enjoy the Author&#39;s book    Hands-on Scala Programming</p><p>关于作者：Haoyi是一名软件工程师，也是许多开源Scala工具(如Ammonite REPL和Mill构建工具)的作者。如果你喜欢这个博客上的内容，你可能也会喜欢作者的《Scala编程实战》一书。</p><p>   The goal of this exercise will to implement a subset of the  Jsonnet programming language:</p><p>本练习的目标是实现Jsonnet编程语言的一个子集：</p><p>  local greeting = &#34;Hello &#34;;local person = function(name){ &#34;name&#34;: name, &#34;welcome&#34;: greeting + name + &#34;!&#34;};{ &#34;person1&#34;: person(&#34;Alice&#34;), &#34;person2&#34;: person(&#34;Bob&#34;), &#34;person3&#34;: person(&#34;Charlie&#34;)}</p><p>本地问候语=&#34；Hello&#34；；本地人员=函数(姓名){&#34；姓名&#34；：姓名，&#34；欢迎&#34；：问候语+姓名+&#34；！&#34；}；{&#34；Pers1&#34；：Person(&#34；Alice&#34；)，&#34；Person 2&#34；：Person(&#34；Bob&#34；)，&#34；Person 3&#34；：)}。</p><p>  { &#34;person1&#34;: { &#34;name&#34;: &#34;Alice&#34;, &#34;welcome&#34;: &#34;Hello Alice!&#34; }, &#34;person2&#34;: { &#34;name&#34;: &#34;Bob&#34;, &#34;welcome&#34;: &#34;Hello Bob!&#34; }, &#34;person3&#34;: { &#34;name&#34;: &#34;Charlie&#34;, &#34;welcome&#34;: &#34;Hello Charlie!&#34; }}</p><p>{&#34；Person 1&#34；：{&#34；姓名&#34；：&#34；Alice&#34；，&#34；欢迎&#34；：&#34；Hello Alice！&#34；}，&#34；Person 2&#34；：{&#34；姓名&#34；：&#34；Bob&#34；，&#34；欢迎&#34；：&#34；Hello Bob！&#34；}，&#34；人物3&#34；：{&#34；姓名&#34；：&#34；查理；，&#34；欢迎&#34；：&#34；你好，查理！&#34；}}。</p><p> Jsonnet is a simple language meant to construct JSON configuration files: the output of evaluating a  .jsonnet file is a single JSON structure containing dictionaries, lists, strings, numbers, and booleans. The output JSON can then be used to configure  Kubernetes,  CloudFormation,  Terraform, or other software systems. Jsonnet is used heavily at Google, Databricks, and other companies in order to manage their large and complex system configurations.</p><p>Jsonnet是一种用于构造JSON配置文件的简单语言：评估.jsonnet文件的输出是一个包含字典、列表、字符串、数字和布尔值的JSON结构。然后，输出的JSON可用于配置Kubernetes、CloudForformation、Terraform或其他软件系统。Google、Databricks和其他公司大量使用Jsonnet来管理其庞大而复杂的系统配置。</p><p>   This tutorial will walk you through all three phases of implementing our simple interpreter, giving you an intuition for the techniques, data structures and algorithms involved. While not a comprehensive or production-ready implementation, this tutorial should hopefully give you enough foundation to get started with your own simple language-related projects.</p><p>本教程将引导您完成实现我们的简单解释器的所有三个阶段，让您对所涉及的技术、数据结构和算法有一个直观的了解。虽然本教程不是一个全面的或可用于生产的实现，但它有望为您提供足够的基础，让您能够开始自己的简单语言相关项目。</p><p> For this exercise, we will do all our work inside the Ammonite Scala REPL. Ammonite can be installed via:</p><p>在本练习中，我们将在Ammonite Scala REPL中完成所有工作。菊石可以通过以下方式安装：</p><p> $ sudo sh -c &#39;(echo &#34;#!/usr/bin/env sh&#34; &amp;&amp; curl -L https://github.com/lihaoyi/Ammonite/releases/download/1.6.8/2.13-1.6.8) &gt; /usr/local/bin/amm &amp;&amp; chmod +x /usr/local/bin/amm&#39; &amp;&amp; ammLoading...Welcome to the Ammonite Repl 1.6.8(Scala 2.13.0 Java 11.0.2)If you like Ammonite, please support our development at www.patreon.com/lihaoyi@</p><p>$sudo sh-c；(ECHO&#34；#！/usr/bin/env sh&34；&amp；&amp；curl-L https://github.com/lihaoyi/Ammonite/releases/download/1.6.8/2.13-1.6.8)&&gt;；/usr/LOCAL/bin/amm&amp；&amp；chmod+x/usr/LOCAL/bin/amm&39；&amp；&amp；AmmLoading...欢迎使用Ammonite Repl 1.6.8(Scala 2.13.0 Java 11.0.2)如果您喜欢Ammonite，请通过www.patreon.com/lihaoyi@支持我们的开发。</p><p>   local greeting = &#34;Hello &#34;;local person = function(name){ &#34;name&#34;: name, &#34;welcome&#34;: greeting + name + &#34;!&#34;};{ &#34;person1&#34;: person(&#34;Alice&#34;), &#34;person2&#34;: person(&#34;Bob&#34;), &#34;person3&#34;: person(&#34;Charlie&#34;)}</p><p>本地问候语=&#34；Hello&#34；；本地人员=函数(姓名){&#34；姓名&#34；：姓名，&#34；欢迎&#34；：问候语+姓名+&#34；！&#34；}；{&#34；Pers1&#34；：Person(&#34；Alice&#34；)，&#34；Person 2&#34；：Person(&#34；Bob&#34；)，&#34；Person 3&#34；：)}。</p><p> Jsonnet itself is similar to JSON, but introduces the constructs that help you tidy up verbose or repetitive portions of your JSON config: local variables like  greeting above, function definitions like  person, and basic operations like concatenating strings with  +. For the purpose of this exercise, we will stop at implementing these three simple features. Further features and improvements can be implemented the same way, and we will leave the task of exhaustively implementing the entire Jsonnet language to production intepreters like  Sjsonnet.</p><p>Jsonnet本身类似于JSON，但引入了帮助您整理JSON配置的冗长或重复部分的构造：本地变量(如上面的问候语)、函数定义(如Person)以及基本操作(如用+连接字符串)。出于本练习的目的，我们将停止实现这三个简单的功能。进一步的特性和改进可以用同样的方式实现，我们将把彻底实现整个Jsonnet语言的任务留给像Sjsonnet这样的产品解释器。</p><p>  Jsonnet has a similar set of primitives as JSON. For this tutorial, we will consider just a subset of them:</p><p>Jsonnet有一组与JSON类似的原语。在本教程中，我们只考虑其中的一部分：</p><p>  For now, we will assume strings do not contain escape sequences like  \n or  \&#34;, and leave out additional data types like numbers, booleans, arrays, or null.</p><p>目前，我们假设字符串不包含\n或\&#34；等转义序列，并省略其他数据类型，如数字、布尔值、数组或NULL。</p><p>     You can define local variables using the  local keyword, the assignment of an expression to a name, a semicolon  ;, and then the final expression:</p><p>您可以使用LOCAL关键字、为名称分配表达式、分号；，然后使用最终表达式来定义局部变量：</p><p>      As in most programming languages, functions are called using parentheses containing the arguments you wish to pass.</p><p>与大多数编程语言一样，调用函数时使用包含要传递的参数的圆括号。</p><p>     The language features described here can be combined in arbitrary ways, e.g. a function can be called inside a dictionary value:</p><p>这里描述的语言功能可以以任意方式组合，例如，可以在字典值内调用函数：</p><p>      This quick tour is only a small subset of the full Jsonnet language, but will be enough for this tutorial.</p><p>本快速教程只是完整Jsonnet语言的一小部分，但对本教程来说已经足够了。</p><p>  To parse Jsonnet, we will be using the  Fastparse library introduced in this blog post:</p><p>为了解析Jsonnet，我们将使用本文介绍的Fastparse库：</p><p>   Let&#39;s start by defining a syntax tree of what our minimal Jsonnet syntax looks like: strings, dictionaries, functions, and local definitions. We will do so using a Scala  sealed trait and  case classes:</p><p>让我们从定义最小Jsonnet语法的语法树开始：字符串、字典、函数和局部定义。我们将使用Scala密封的特征和案例类来实现这一点：</p><p> sealed trait Exprobject Expr{ case class Str(s: String) extends Expr case class Ident(name: String) extends Expr case class Plus(nodes: Seq[Expr]) extends Expr case class Dict(pairs: Map[String, Expr]) extends Expr case class Local(name: String, assigned: Expr, body: Expr) extends Expr case class Func(argNames: Seq[String], body: Expr) extends Expr case class Call(expr: Expr, args: Seq[Expr]) extends Expr}</p><p>密封的特征Exproject expr{case class Str(s：String)扩展expr case类Iden(name：String)扩展expr case类Plus(节点：SEQ[expr])扩展expr case类dict(配对：MAP[String，expr])扩展expr case类Local(name：string，assigned：expr，body：expr)扩展expr case类Func(argNames：SEQ[string]，body：expr)扩展expr case类调用(expr：expr。</p><p> (To enter this code into the Ammonite REPL, wrap it in a pair of curlies  {...} so it is entered as a single unit)</p><p>(要将此代码输入到Ammonite REPL中，请用一对卷边将其括起来{...}，这样它就可以作为一个单元输入)。</p><p> Here, the  Expr data structure is meant to represent the meaningful parts of the Jsonnet syntax. Here are some example snippets and what we expect them to parse to.</p><p>这里，expr数据结构旨在表示Jsonnet语法中有意义的部分。下面是一些示例代码片段，以及我们希望它们解析到的内容。</p><p>             And of course, we expect to be able to parse any combination of these language features combined together.</p><p>当然，我们希望能够解析组合在一起的这些语言功能的任意组合。</p><p>    First, let&#39;s write the parser for  Str. We will ignore escape characters for simplicity, meaning a string is simply a  &#34;, followed by zero-or-more non- &#34; characters, closed by another  &#34;:</p><p>首先，让我们为Str编写解析器。为简单起见，我们将忽略转义字符，这意味着字符串只是一个&#34；，后跟零个或多个非&#34；字符，最后是另一个&#34；字符：</p><p> @ def str[_: P] = P( &#34;\&#34;&#34; ~~/ CharsWhile(_ != &#39;&#34;&#39;, 0).! ~~ &#34;\&#34;&#34; ).map(Expr.Str)defined function str@ fastparse.parse(&#34;\&#34;hello\&#34;&#34;, str(_))res10: Parsed[Str] = Success(Str(&#34;hello&#34;), 7)@ fastparse.parse(&#34;\&#34;hello world\&#34;&#34;, str(_))res11: Parsed[Str] = Success(Str(&#34;hello world&#34;), 13)@ fastparse.parse(&#34;\&#34;\&#34;&#34;, str(_))res12: Parsed[Str] = Success(Str(&#34;&#34;), 2)@ println(fastparse.parse(&#34;123&#34;, str(_)))Parsed.Failure(Position 1:1, found &#34;123&#34;)</p><p>@def str[_：P]=P(&#34；\&#34；&#34；~~/CharsWhile(_！=&#39；&#34；&#39；，0).！~~&#34；\&#34；&#34；).map(Expr.Str)定义函数str@fast parse.parse(&#34；\&#34；Hello\&#34；&#34；，str(_))res10：)，7)@fast parse.parse(&#34；\&#34；Hello world\&#34；&#34；，str(_))res11：parsed[Str]=Success(Str(&#34；Hello world&#34；)，13)@fast parse.parse(&#34；\&#34；\&#34；&#34；，str(_))res12：parsed[Str]=Success(Str(&#34；，str(_))Parsed.Failure(位置1：1，找到&#34；123&#34；)。</p><p> Note how we use the  ~~/ operator after the  &#34;\&#34;&#34; open quote: the  ~~ means we do not want to consume whitespace here (since we are inside a string) and the  / is a  Fastparse Cut meaning we want to avoid backtracking if the parse fails. A detailed discussion of what Cuts give us is left to the linked documentation.</p><p>注意我们是如何在&#34；\&#34；&#34；后引号后面使用~~/运算符的：~~表示我们不想在这里使用空格(因为我们在一个字符串中)，而/是Fastparse Cut，这意味着如果解析失败，我们希望避免回溯。关于削减给我们带来什么的详细讨论留给了链接的文档。</p><p>  @ def ident[_: P] = P( CharIn(&#34;a-zA-Z_&#34;) ~~ CharsWhileIn(&#34;a-zA-Z0-9_&#34;, 0) ).!.map(Expr.Ident)defined function ident@ fastparse.parse(&#34;hello&#34;, ident(_))res17: Parsed[Ident] = Success(Ident(&#34;hello&#34;), 5)@ println(fastparse.parse(&#34;123&#34;, ident(_)))Parsed.Failure(Position 1:1, found &#34;123&#34;)</p><p>@defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.map(Expr.Iden)定义函数ident@fast parse.parse(&#34；Hello&#34；，ident(_))res17：parsed[Iden]=Success(&#34；a-Za-Z0-9_&#34；，0)。，ident(_))分析失败(位置1：1，找到&#34；123&#34；)。</p><p>  The next syntax tree node we will look into parsing is  Expr.Plus, used to model the  a + b syntax.</p><p>我们将研究的下一个语法树节点是Expr.Plus，它用于对a+b语法建模。</p><p> The  Expr.Plus nodes representing  +, and all other  case classes in our syntax tree, are a bit more complex: they have a recursive definition where  Plus is an  Expr, but an  Expr could be a  Plus node. This can be solved by making our parsers recursive, as follows:</p><p>表示+的Expr.Plus节点以及我们语法树中的所有其他case类都稍微复杂一些：它们有一个递归定义，其中Plus是expr，但是expr可以是Plus节点。这可以通过使我们的解析器递归来解决，如下所示：</p><p> @ { def expr[_: P]: P[Expr] = P( prefixExpr ~ plus.rep ).map{ case (e, Nil) =&gt; e case (e, items) =&gt; Expr.Plus(e +: items) } def prefixExpr[_: P] = P( str | ident ) def str[_: P] = P( &#34;\&#34;&#34; ~~/ CharsWhile(_ != &#39;&#34;&#39;, 0).! ~~ &#34;\&#34;&#34; ).map(Expr.Str) def ident[_: P] = P( CharIn(&#34;a-zA-Z_&#34;) ~~ CharsWhileIn(&#34;a-zA-Z0-9_&#34;, 0) ).!.map(Expr.Ident) def plus[_: P] = P( &#34;+&#34; ~ prefixExpr ) } @ fastparse.parse(&#34;a + b&#34;, expr(_))res65: Parsed[Expr] = Success(Plus(List(Ident(&#34;a&#34;), Ident(&#34;b&#34;))), 5)@ fastparse.parse(&#34;a + b + c&#34;, expr(_))res66: Parsed[Expr] = Success(Plus(List(Ident(&#34;a&#34;), Ident(&#34;b&#34;), Ident(&#34;c&#34;))), 9)@ fastparse.parse(&#34;a + \&#34; \&#34; + c&#34;, expr(_))res67: Parsed[Expr] = Success(Plus(List(Ident(&#34;a&#34;), Str(&#34; &#34;), Ident(&#34;c&#34;))), 11)</p><p>@{def expr[_：P]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]=P(str|ident)def str[_：P]=P(&#34；\&#34；&#34；~/。&#34；).map(Expr.Str)defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.Map(Expr.Iden)def plus[_：P]=P(&#34；+&#34；~prefix Expr)}@fast parse.。，expr(_))res65：parsed[expr]=Success(Plus(List(Ident(&#34；a&#34；)，Iden(&#34；b&#34；))，5)@fast parse.parse(&#34；a+b+c&#34；，expr(_))res66：parsed[expr]=Success(Plus(List(Iden(&#34；a&#34；)，Ident(&#。)，9)@fast parse.parse(&#34；a+\&#34；\&#34；+c&#34；，expr(_))res67：parsed[expr]=Success(Plus(List(Ident(&#34；a&#34；)，Str(&#34；&#34；)，Ident(&#34；c&#34；))，11)。</p><p> Note that we cannot simply define  plus as  expr ~ &#34;+&#34; ~ expr; this is because the  plus parser would then be  Left Recursive, causing an infinite recursion at parse time. Instead, we need to define  plus as just the suffix  &#34;+&#34; ~ prefixExpr, and have the  expr parser do the work of repeating  plus via  ~ plus.rep and aggregating the results into a  Expr.Plus node if non-empty.</p><p>请注意，我们不能简单地将PLUS定义为expr~&#34；+&#34；~expr；这是因为PLUS解析器将被保留为递归，从而导致在解析时进行无限递归。相反，我们需要将plus定义为后缀&#34；+&#34；~prefix Expr，并让expr解析器通过~plus.rep执行重复plus的工作，如果不为空，则将结果聚合到Expr.Plus节点中。</p><p> Expr.Dict nodes are also recursive, each comma-separated key-value pair containing a  Expr.Str key and a  Expr value. We can parse those as follows:</p><p>Expr.Dict节点也是递归的，每个逗号分隔的键值对包含一个Expr.Str键和一个expr值。我们可以按如下方式解析它们：</p><p> @ { def expr[_: P]: P[Expr] = P( prefixExpr ~ plus.rep).map{ case (e, Nil) =&gt; e case (e, items) =&gt; Expr.Plus(e +: items) } def prefixExpr[_: P] = P( str | ident | dict ) def str[_: P] = P( str0 ).map(Expr.Str) def str0[_: P] = P( &#34;\&#34;&#34; ~~/ CharsWhile(_ != &#39;&#34;&#39;, 0).! ~~ &#34;\&#34;&#34; ) def ident[_: P] = P( CharIn(&#34;a-zA-Z_&#34;) ~~ CharsWhileIn(&#34;a-zA-Z0-9_&#34;, 0) ).!.map(Expr.Ident) def plus[_: P] = P( &#34;+&#34; ~ prefixExpr ) def dict[_: P] = P( &#34;{&#34; ~/ (str0 ~ &#34;:&#34; ~/ expr).rep(0, &#34;,&#34;) ~ &#34;}&#34; ).map(kvs =&gt; Expr.Dict(kvs.toMap)) }@ fastparse.parse(&#34;&#34;&#34;{&#34;a&#34;: &#34;b&#34;, &#34;cde&#34;: id}&#34;&#34;&#34;, expr(_))res84: Parsed[Expr] = Success(Dict(Map(&#34;a&#34; -&gt; Str(&#34;b&#34;), &#34;cde&#34; -&gt; Ident(&#34;id&#34;))), 21)@ fastparse.parse(&#34;&#34;&#34;{&#34;a&#34;: &#34;b&#34;, &#34;cde&#34;: id}&#34;&#34;&#34;, expr(_))res85: Parsed[Expr] = Success(Dict(Map(&#34;a&#34; -&gt; Str(&#34;b&#34;), &#34;cde&#34; -&gt; Ident(&#34;id&#34;))), 21)@ fastparse.parse(&#34;&#34;&#34;{&#34;a&#34;: &#34;b&#34;, &#34;cde&#34;: id, &#34;nested&#34;: {}}&#34;&#34;&#34;, expr(_))res86: Parsed[Expr] = Success( Dict(Map(&#34;a&#34; -&gt; Str(&#34;b&#34;), &#34;cde&#34; -&gt; Ident(&#34;id&#34;), &#34;nested&#34; -&gt; Dict(Map()))), 35)</p><p>@{def expr[_：P]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]=P(str|ident|dict)def str[_：P]=P(Str0).map(Expr.Str)de。&#34；&#39；&#39；，0).~~&#34；\&#34；&#34；)defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.MAP(Expr.Iden)def plus[_：P]=P(&#34；+&##。~/(str0~&#34；：&#34；~/expr).rep(0，&#34；，&#34；)~&#34；}&#34；).map(kvs=&gt；Expr.Dict(kvs.toMap))}@fast parse.parse(&#34；&#34；&#34；a&#34；：&#34；b&#34；，&#34；cde&34。，expr(_))res84：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；CDE&#34；-&gt；Ident(&#34；id&#34；))，21)@fast parse.parse(&#34；&#34；&#34；{&#34；a&#34；：&#34；：id}&#34；&#34；&#34；，expr(_))res85：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；cde&#34；-&gt；ident(&#34；id&#34；)，21)@fast parse.parse(&#34；&#34；&#34；，&#34；cde&#34；：id，&#34；嵌套&#34；：{}}&#34；&#34；&#34；，expr(_)res86：parsed[expr]=Success(dict(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；cde&#34；-&gt；标识(&#34；id&34；)，DICT(地图(()，35)。</p><p> Note how we extracted the  str0 parser from  str:  str0 returns the raw  String that was parsed, while  str wraps it in an  Expr.Str syntax tree node. Since  Expr.Dict keys are syntactically the same as  Expr.Strs, but do not need to be wrapped in  Expr.Str nodes, we can re-use the  str0 parser in our  dict parser to parse them as well.</p><p>注意我们是如何从str提取str0解析器的：str0返回解析的原始字符串，而str将其包装在Expr.Str语法树节点中。由于Expr.Dict键在语法上与Expr.Strs相同，但不需要包装在Expr.Str节点中，因此我们也可以在dict解析器中重用str0解析器来解析它们。</p><p>  Adding the parsers for  func,  local and  call to this code, we get the following:</p><p>将函数解析器、本地解析器和调用解析器添加到此代码中，我们会得到以下结果：</p><p> object Parser { def expr[_: P]: P[Expr] = P( prefixExpr ~ plus.rep ).map{ case (e, Nil) =&gt; e case (e, items) =&gt; Expr.Plus(e +: items) } def prefixExpr[_: P]: P[Expr] = P( callExpr ~ call.rep ).map{ case (e, items) =&gt; items.foldLeft(e)((f, args) =&gt; Expr.Call(f, args)) } def callExpr[_: P] = P( str | dict | local | func | ident ) def str[_: P] = P( str0 ).map(Expr.Str) def str0[_: P] = P( &#34;\&#34;&#34; ~~/ CharsWhile(_ != &#39;&#34;&#39;, 0).! ~~ &#34;\&#34;&#34; ) def ident[_: P] = P( ident0 ).map(Expr.Ident) def ident0[_: P] = P( CharIn(&#34;a-zA-Z_&#34;) ~~ CharsWhileIn(&#34;a-zA-Z0-9_&#34;, 0) ).! def dict[_: P] = P( &#34;{&#34; ~/ (str0 ~ &#34;:&#34; ~/ expr).rep(0, &#34;,&#34;) ~ &#34;}&#34; ).map(kvs =&gt; Expr.Dict(kvs.toMap)) def local[_: P] = P( &#34;local&#34; ~/ ident0 ~ &#34;=&#34; ~ expr ~ &#34;;&#34; ~ expr ).map(Expr.Local.tupled) def func[_: P] = P( &#34;function&#34; ~/ &#34;(&#34; ~ ident0.rep(0, &#34;,&#34;) ~ &#34;)&#34; ~ expr ).map(Expr.Func.tupled) def plus[_: P] = P( &#34;+&#34; ~ prefixExpr ) def call[_: P] = P( &#34;(&#34; ~/ expr.rep(0, &#34;,&#34;) ~ &#34;)&#34; )}</p><p>对象解析器{def expr[_：p]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]：P[expr]=P(callExpr~call.rep).map{case(e，Items)=&gt；item.。Expr.Call(f，args)}def callExpr[_：P]=P(str|dict|local|func|ident)def str[_：P]=P(Str0).map(Expr.Str)def str0[_：P]=P(&#34；\&#34；&#34；~~/CharsWhile(_！=&#39；&#34；&#39；，0).！~。)defident[_：P]=P(Ident0).map(Expr.Iden)def ident0[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0))。！Def dict[_：P]=P(&#34；{&#34；~/(str0~&#34；：&#34；~/expr).rep(0，&#34；，&#34；)~&#34；}&#34；).map(KVS=&gt；Expr.Dict(kvs.toMap))def local[_：P]=P(&#34；local&#34；~/ident0~&#。~expr).map(Expr.Local.tupled)def函数[_：P]=P(&#34；函数&#34；~/&#34；(&#34；~ident0.rep(0，&#34；，&#34；)~&#34；)&#34；~expr).map(Expr.Local.tupled)def plus[_：P]=P(&#34；+&#34；~prefix Expr)。~/expr.rep(0，&#34；，&#34；)~&#34；)&#34；)}。</p><p> func and  local are relatively straightforward: each one starts with a keyword, and they can be parsed recursively without issue. We have also split out  ident0 from  ident, since the  func parser uses the same syntax as  ident for parsing its parameter list but does not need the identifiers to be boxed into  Expr.Ident syntax tree nodes.</p><p>Func和local相对简单：每个函数都以一个关键字开头，并且可以递归地解析它们，而不会出现问题。我们还将ident0从ident中分离出来，因为func解析器使用与ident相同的语法来解析其参数列表，但不需要将标识符装箱到Expr.Iden语法树节点中。</p><p> Note that  call also needs us to split up  prefixExpr further into  callExpr, since the  a() call syntax would otherwise be left-recursive similar to the  a + b plus syntax we saw earlier.</p><p>请注意，call还需要我们将prefix Expr进一步拆分为callExpr，因为a()调用语法将是左递归的，类似于我们前面看到的a+b加号语法。</p><p>  @ fastparse.parse(&#34;\&#34;123\&#34;&#34;, Parser.expr(_))res63: Parsed[Expr] = Success(Str(&#34;123&#34;), 5)@ fastparse.parse(&#34;id&#34;, Parser.expr(_))res64: Parsed[Expr] = Success(Ident(&#34;id&#34;), 2)@ fastparse.parse(&#34;a + b&#34;, Parser.expr(_))res65: Parsed[Expr] = Success(Plus(Ident(&#34;a&#34;), Ident(&#34;b&#34;)), 5)@ fastparse.parse(&#34;a + b + c&#34;, Parser.expr(_))res66: Parsed[Expr] = Success(Plus(Ident(&#34;a&#34;), Plus(Ident(&#34;b&#34;), Ident(&#34;c&#34;))), 9)@ fastparse.parse(&#34;&#34;&#34;{&#34;a&#34;: &#34;A&#34;, &#34;b&#34;: &#34;bee&#34;}&#34;&#34;&#34;, Parser.expr(_))res69: Parsed[Expr] = Success(Dict(Map(&#34;a&#34; -&gt; Str(&#34;A&#34;), &#34;b&#34; -&gt; Str(&#34;bee&#34;))), 22)@ fastparse.parse(&#34;&#34;&#34;f()(a) + g(b, c)&#34;&#34;&#34;, Parser.expr(_))res95: Parsed[Expr] = Success( Plus( List( Call(Call(Ident(&#34;f&#34;), List()), List(Ident(&#34;a&#34;))), Call(Ident(&#34;g&#34;), List(Ident(&#34;b&#34;), Ident(&#34;c&#34;))) ) ), 16)</p><p>@fast parse.parse(&#34；\&#34；123\&#34；&#34；，Parser.expr(_))res63：parsed[expr]=Success(Str(&#34；123&#34；)，5)@fast parse.parse(&#34；id&#34；，Parser.expr(_))res64：parsed[expr]=Success(Iden(&#34；id&#34；)，2)。，Parser.expr(_))res65：parsed[expr]=Success(Plus(标识(&#34；a&#34；)，标识(&#34；b&34；))，5)@fast parse.parse(&#34；a+b+c&34；，Parser.expr(_))res66：parsed[expr]=Success(Plus(标识(&#34；a&#34；)，Plus(Iden(&#34；a&#34；)，Plus。)，9)@fast parse.parse(&#34；&#34；&#34；{&#34；a&#34；：&#34；A&#34；，&#34；b&#34；：&#34；bee&#34；}&#34；&#34；&#34；，Parser.expr(_))res69：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；B&#34；-&gt；Str(&#34；bee&#34；))，22)@fast parse.parse(&#34；&#34；&#34；f()(A)+g(b，c)&#34；&#34；&#34；，Parser.expr(_))res95：parsed[expr]=Success(Plus(List(Call(Call(Ident(&#34；f&#34；))，List(。))，呼叫(身份(&#34；g#34；)，列表(身份(&#34；b#34；)，身份(&#34；c&#34；)，16)。</p><p> The syntax of our programming language is recursive:  local,  function,  plus, and  dict expressions can contain other expressions, nested arbitrarily deeply. We can test this out by feeding such nested examples into the  expr parser:</p><p>我们编程语言的语法是递归的：LOCAL、Function、PLUS和DICT表达式可以包含其他任意深度嵌套的表达式。我们可以通过将这样的嵌套示例提供给expr解析器来测试这一点：</p><p> @ fastparse.parse( &#34;&#34;&#34;local variable = &#34;kay&#34;; {&#34;a&#34;: &#34;A&#34;, &#34;f&#34;: function(a) a + a, &#34;nested&#34;: {&#34;k&#34;: variable}}&#34;&#34;&#34;, Parser.expr(_) )res74: Parsed[Expr] = Success( Local( &#34;variable&#34;, Str(&#34;kay&#34;), Dict( Map( &#34;a&#34; -&gt; Str(&#34;A&#34;), &#34;f&#34; -&gt; Func(List(&#34;a&#34;), Plus(Ident(&#34;a&#34;), Ident(&#34;a&#34;))), &#34;nested&#34; -&gt; Dict(Map(&#34;k&#34; -&gt; Ident(&#34;variable&#34;))) ) ) ), 85)</p><p>@fast parse.parse(&#34；&#34；&#34；局部变量=&#34；Kay&#34；；{&#34；a&#34；：&#34；A&#34；，&#34；f&#34；：函数(A)a+a，&#34；嵌套&#34；：{&#34；k&#34；：变量}}&#34；&#34；&#34；，Parser.expr(_))res74：parsed[expr]=Success(Local(&#34；Variable&34；，Str(&#34；Variable&34；)，Str(&#34；Kay&34；)，Dict(&#34；A&#34；-&gt；Str(&#34；A&#34；)，&#34；f&#34；-&&gt;；Func(List(&#34；a&#34；)，Plus(&#34；a&#34；)，))，&#34；嵌套的&34；-&gt；dict(Map(&#34；k&#34；-&gt；标识(&#34；变量&#34；)，85)。</p><p>  Now that we have a syntax tree of  Expr nodes, the next step is to interpret the syntax tree to provide a runtime data structure of  Values. We will define  Value as follows:</p><p>现在我们已经有了expr节点的语法树，下一步是解释语法树以提供值的运行时数据结构。我们将价值定义如下：</p><p> sealed trait Valueobject Value{ case class Str(s: String) extends Value case class Dict(pairs: Map[String, Value]) extends Value case class Func(call: Seq[Value] =&gt; Value) extends Value}</p><p>密封特征ValueObject Value{case类Str(s：String)扩展值case类dict(配对：Map[String，Value])扩展值case类Func(call：SEQ[value]=&gt；value)扩展值}。</p><p> (To enter this code into the Ammonite REPL, wrap it in a pair of curlies  {...} so it is entered as a single unit)</p><p>(要将此代码输入到Ammonite REPL中，请用一对卷边将其括起来{...}，这样它就可以作为一个单元输入)。</p><p> Note that while the  Expr syntax tree contains nodes that represent identifiers, local variables, function application, and so on, a  Value can only be a  Str, a  Dict, or a  Func. It doesn&#39;t matter where a  Value.Str came from: whether a literal  Expr.Str in the source code, passed in as a function parameter to a  Expr.Func, or bound to a local variable via  Expr.Local, it is still the same  Value.Str. The final  Value for the entire Jsonnet program is then converted to a JSON string as the output of the program.</p><p>请注意，虽然expr语法树包含表示标识符、局部变量、函数应用程序等的节点，但值只能是str、dict或Func。Value.Str来自哪里并不重要：无论是源代码中的文字Expr.Str，作为函数参数传递给Expr.Func，还是通过Expr.Local绑定到局部变量，它都是相同的Value.Str。然后，整个Jsonnet程序的最终值被转换为JSON字符串，作为程序的输出。</p><p> The contents of  Value.Str and  Value.Dict should be self explanatory.  Value.Func is a bit less obvious: by defining it as  Func(call: Seq[Value] =&gt;Value), we are saying &#34;a function is something you can pass a list of argument values to and returns a value&#34;. We will see how to instantiate these  Value.Func nodes later.</p><p>Value.Str和Value.Dict的内容应该是不言而喻的。Value.Func就不那么明显了：通过将其定义为Func(call：SEQ[value]=&gt；value)，我们说的是一个函数，您可以将一列参数值传递给它并返回值。稍后我们将了解如何实例化这些Value.Func节点。</p><p> The basic task here is to write a function that converts a  Expr into a  Value:</p><p>这里的基本任务是编写一个将expr转换为值的函数：</p><p>  However, the  Value returned by evaluating an  Expr isn&#39;t only dependent on the contents of that  Expr: it also depends on the enclosing scope, as the value of  Expr.Ident identifiers depends on what value was bound to that name, via  local declarations or  function parameters.</p><p>然而，通过计算expr返回的值不仅取决于该expr的内容：它还取决于包含的作用域，因为Expr.Iden标识符的值取决于通过局部声明或函数参数绑定到该名称的值。</p><p> This mapping of names to  Values is often known as the &#34;lexical scope&#34; within your program. Thus we might instead define  evaluate as:</p><p>在您的程序中，这种名称到值的映射通常被称为词法作用域。因此，我们可以将EVALUE定义为：</p><p>         Literal dictionaries are also straightforward:  Expr.Dicts become  Value.Dicts, with the same keys, except we need to evaluate each value into its corresponding expression:</p><p>文字字典也很简单：Expr.Dicts变成Value.Dicts，具有相同键的Dicts，只是我们需要将每个值计算成其相应的表达式：</p><p>  Dictionary literals do not add or remove anything from the lexical scope, so the  scope parameter is passed through unchanged. Testing it gives us:</p><p>字典文字不会在词法作用域中添加或删除任何内容，因此传递的作用域参数没有变化。通过测试，我们可以了解到：</p><p> @ evaluate( fastparse.parse(&#34;&#34;&#34;{&#34;hello&#34;: &#34;world&#34;, &#34;key&#34;: &#34;value&#34;}&#34;&#34;&#34;, Parser.expr(_)).get.value, Map.empty )res81: Value = Dict(Map(&#34;hello&#34; -&gt; Str(&#34;world&#34;), &#34;key&#34; -&gt; Str(&#34;value&#34;)))</p><p>@EVALUATE(fastparse.parse(&#34；&#34；&#34；{&#34；hello&#34；：&#34；WORLD&34；，&#34；KEY&#34；：&#34；VALUE&#34；}&#34；&#34；，Parser.expr(_)).get.value，Map.Empty)res81：Value=dict(Map(&#34；Hello&#34；-&gt；Str(&#34；WORLD&34；)，&#34；键&#34；-&gt；字符串(&#34；值&#34；))。</p><p> Next, we will look at the  Expr.Plus nodes. We have only defined their behavior to work on string values ( Value.Str), so evaluating them is involves:</p><p>接下来，我们将查看Expr.Plus节点。我们只定义了它们的行为来处理字符串值(Value.Str)，因此评估它们涉及到：</p><p>     def evaluate(expr: Expr, scope: Map[String, Value]): Value = expr match{ case Expr.Str(s) =&gt; Value.Str(s) case Expr.Dict(kvs) =&gt; Value.Dict(kvs.map{case (k, v) =&gt; (k, evaluate(v, scope))}) case Expr.Plus(items) =&gt; Value.Str(items.map(evaluate(_, scope)).map{case Value.Str(s) =&gt; s}.mkString)}</p><p>定义评估(expr：expr，作用域：MAP[字符串，值])：Value=expr Match{Case Expr.Str(S)=&gt；Value.Str(S)Case Expr.Dict(Kvs)=&gt；Value.Dict(kvs.map{Case(k，v)=&gt；(k，Evaluate(v，Scope)})Case Expr.Plus(Items)=&gt；Value.Str(item.。</p><p>   @ fastparse.parse( &#34;&#34;&#34;local greeting = &#34;Hello &#34;;greeting + greeting&#34;&#34;&#34;, Parser.expr(_) )res85: Parsed[Expr] = Success( Local(&#34;greeting&#34;, Str(&#34;Hello &#34;), Plus(Ident(&#34;greeting&#34;), Ident(&#34;greeting&#34;))), 45)</p><p>@fast parse.parse(&#34；&#34；&#34；&#34；本地问候=&#34；Hello&#34；；greeting+greeting&34；&#34；&#34；&#34；，Parser.expr(_))res85：parsed[expr]=Success(Local(&#34；greting&#34；，Str(&#34；Hello&#34；)，Plus(Ident(&#34；Greeting&34；)，Iden。</p><p>   The point of  local is to evaluate the  assigned expression to a value, assign that value to the  name, and then evaluate the  body expression with that value bound to that name. We can write that in code as follows:</p><p>LOCAL的目的是对赋值的表达式求值，将该值赋给该名称，然后使用绑定到该名称的值计算主体表达式。我们可以用如下代码编写该代码：</p><p> case Expr.Local(name, assigned, body) =&gt; val assignedValue = evaluate(assigned, scope) evaluate(body, scope + (name -&gt; assignedValue))</p><p>案例Expr.Local(名称，已分配，正文)=&gt；Val assignedValue=Evaluate(已分配，范围)Evaluate(正文，范围+(名称-&gt；assignedValue))。</p><p> Once a  local has put a name into  scope, evaluating  Ident identifier nodes is straightforward: simply fetch the value of that name in the  scope:</p><p>一旦本地将名称放入作用域，计算标识标识符节点就很简单：只需在作用域中获取该名称的值：</p><p>   @ evaluate( fastparse.parse(&#34;&#34;&#34;local greeting = &#34;Hello &#34;; greeting + greeting&#34;&#34;&#34;, expr(_)).get.value, Map.empty )res94: Value = Str(&#34;Hello Hello &#34;)</p><p>@EVALUATE(fast parse.parse(&#34；&#34；&#34；local greeting=&#34；Hello&#34；；greeting+greting&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)res94：value=Str(&#34；Hello&#34；)。</p><p>  @ evaluate( fastparse.parse(&#34;&#34;&#34;local x = &#34;Hello &#34;; local y = &#34;world&#34;; x + y&#34;&#34;&#34;, expr(_)).get.value, Map.empty )res96: Value = Str(&#34;Hello world&#34;)</p><p>@EVALUATE(fast parse.parse(&#34；&#34；&#34；local x=&#34；Hello&#34；；local y=&#34；；x+y&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)res96：value=Str(&#34；Hello world&#34；)。</p><p>  @ evaluate( fastparse.parse(&#34;&#34;&#34;local greeting = &#34;Hello &#34;; nope + nope&#34;&#34;&#34;, expr(_)).get.value, Map.empty )java.util.NoSuchElementException: key not found: nope scala.collection.immutable.Map$Map1.apply(Map.scala:242) ammonite.$sess.cmd93$.evaluate(cmd93.sc:10) ammonite.$sess.cmd93$.evaluate(cmd93.sc:5) ammonite.$sess.cmd95$.&lt;clinit&gt;(cmd95.sc:3)</p><p>@EVALUATE(Fastparse.parse(&#34；&#34；&#34；&#34；本地问候=&#34；Hello&#34；；no+nope&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)java.util.NoSuchElementException：Key Not Found：nope scala.collection.immutable.Map$Map1.apply(Map.scala:242)amamite.$sess.cmd93$.valuate(cmd93.sc：10)amitite.$sess.。(cmd95.sc：3)。</p><p>   def evaluate(expr: Expr, scope: Map[String, Value]): Value = expr match{ case Expr.Str(s) =&gt; Value.Str(s) case Expr.Dict(kvs) =&gt; Value.Dict(kvs.map{case (k, v) =&gt; (k, evaluate(v, scope))}) case Expr.Plus(items) =&gt; Value.Str(items.map(evaluate(_, scope)).map{case Value.Str(s) =&gt; s}.mkString) case Expr.Local(name, assigned, body) =&gt; val assignedValue = evaluate(assigned, scope) evaluate(body, scope + (name -&gt; assignedValue)) case Expr.Ident(name) =&gt; scope(name) }</p><p>定义评估(expr：expr，作用域：MAP[字符串，值])：Value=expr Match{Case Expr.Str(S)=&gt；Value.Str(S)Case Expr.Dict(Kvs)=&gt；Value.Dict(kvs.map{Case(k，v)=&gt；(k，Evaluate(v，Scope)})Case Expr.Plus(Items)=&gt；Value.Str(item.。S}.mkString)案例Expr.Local(名称，已分配，正文)=&gt；Val assignedValue=Evaluate(已分配，范围)Evaluate(正文，范围+(名称-&gt;；assignedValue))案例经验标识(名称)=&&gt;；范围(名称)}。</p><p>  The last thing we have left to evaluate are the  Expr.Func function literals and  Expr.Call function application nodes:</p><p>我们最后要计算的是Expr.Func函数文字和Expr.Call函数应用程序节点：</p><p> case class Func(params: Seq[String], body: Expr) extends Exprcase class Call(expr: Expr, args: Seq[Expr]) extends Expr</p><p>Case类Func(params：SEQ[字符串]，Body：expr)扩展Exprcase类调用(expr：expr，args：SEQ[expr])扩展expr</p><p>   And evaluating an  Expr.Call on a  Value.Func should give us the result of evaluating that function. The result could be a  Value.Str, a  Value.Dict, or even another  Value.Func.</p><p>在Value.Func上计算Expr.Call应该会给出计算该函数的结果。结果可以是Value.Str、Value.Dict，甚至是另一个Value.Func。</p><p> Evaluating an  Expr.Call node is straightforward: we simply evaluate the  expr:Expr into a  Value.Func, evaluate the  args: Seq[Expr] into a sequence of argument values, and then call the  Value.Func#call function on the evaluated argument values to give us the result</p><p>计算Expr.Call节点很简单：我们只需将expr：expr求值为Value.Func，将args：SEQ[expr]求值为一系列参数值，然后对求值的参数值调用Value.Func#调用函数即可给出结果。</p><p> case Expr.Call(expr, args) =&gt; val Value.Func(call) = evaluate(expr, scope) val evaluatedArgs = args.map(evaluate(_, scope)) call(evaluatedArgs)</p><p>案例Expr.Call(expr，args)=&gt；valValue.Func(Call)=Evaluate(expr，Scope)Val EvaluatedArgs=args.map(Evaluate(_，Scope))Call(EvaluatedArgs)。</p><p> The trickiness here is: how do we evaluate the  Expr.Func to produce a  Value.Func whose  call attribute does what we want?</p><p>这里的难题是：我们如何计算Expr.Func以生成一个Value.Func，它的Call属性执行我们想要的操作？</p><p> When you think about what  calling a function really means, it boils down to four steps:</p><p>当您思考调用函数的真正含义时，它可以归结为四个步骤：</p><p> Create a modified copy of the original scope at definition-site with the values of the arguments passed at cal</p><p>使用在cal传递的参数值在定义站点创建原始作用域的修改副本。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lihaoyi.com/post/BuildyourownProgrammingLanguagewithScala.html">https://www.lihaoyi.com/post/BuildyourownProgrammingLanguagewithScala.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scala/">#scala</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/expr/">#expr</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033755.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68eaef96ef90392715a86ab4529d5a51.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033755.html">费曼、算法编排和基于节点的编程</a></div><span class="my_story_list_date">2020-11-8 9:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033690.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0588ada816e1b2413594f6bfb6f8d351.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033690.html">Vgil：永远保持道德警惕的编程语言</a></div><span class="my_story_list_date">2020-11-7 18:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033652.html"><img src="http://img2.diglog.com/img/2020/11/thumb_e01dca862a9b81e167e32ca15a8281a2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033652.html">开发人员经验在编程语言研究中的作用是什么？</a></div><span class="my_story_list_date">2020-11-7 11:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033632.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1c73dcb4e8eef769e2d2e29f3add898a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033632.html">迷失的编程方法：Commodore 64 Basic</a></div><span class="my_story_list_date">2020-11-7 11:19</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>