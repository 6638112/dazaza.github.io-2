<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JWT不应该是您的默认会话 JWT should not be your default for sessions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">JWT should not be your default for sessions<br/>JWT不应该是您的默认会话 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 08:50:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/733aadd97b0eb864d74b84c7145ef804.png"><img src="http://img2.diglog.com/img/2021/5/733aadd97b0eb864d74b84c7145ef804.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When designing web applications, (especially the traditional HTML kind),you will at one point have to figure out how to log a user in and keep themlogged in between requests.</p><p>在设计Web应用程序时，（尤其是传统的HTML类型），您将在一个点省略如何弄清楚如何在请求之间记录用户并保持在POSTION。</p><p> The core mechanism we use for this are cookies. Cookies are small strings sentby a server to a client. After a client receives this string, it will repeatthis in subsequent requests. We could store a ‘user id’ in a cookie, andfor any future requests we’ll know what user_id the client was.</p><p> 我们使用的核心机制是饼干。 cookie是将服务器发送到客户端的小字符串。在客户端收到此字符串之后，它将在后续请求中重复。我们可以将“用户ID”存储在Cookie中，并为任何将来的请求都知道，我们会知道客户端的user_id。</p><p>  But this is very insecure. The information lives in the browser, which meansusers can change  USER_ID and be identified as a different user.</p><p>  但这是非常不安全的。信息生活在浏览器中，介绍者可以更改user_id并被标识为其他用户。</p><p>  The traditional way to solve this is what’s known as a ‘session’.I don’t know what the earliest usage of sessions is, but it’s in every webframework, and has been since web frameworks are a thing.</p><p>  解决这一问题的传统方式是所谓的“会话”。我不知道会话最早使用是什么，但它是在每个网络框架中，并且已经是Web框架是一件事。</p><p> Often, sessions and cookies are described as 2 different things, butthey’re really not. A session needs a cookie to work.</p><p> 通常，会话和饼干被描述为2种不同的东西，但是真的不是。会话需要饼干工作。</p><p>  Instead of a predictable user id, we’re sending the client a completely randomsession id that is impossibly hard to guess. The ID has no further meaning, anddoesn’t decode to anything. This is sometimes called an opaque token.</p><p>  而不是预测的用户ID，我们正在向客户端发送完全随机源ID，这是不可能猜到的。 ID没有进一步的意义，anddoes没有解码到任何内容。这有时被称为不透明的令牌。</p><p> When a client repeats this session id back to the server, the server will lookup the id in (for example) a database, which links it back to the user id.When a user wants to log out, the session id is removed from the data storage,which means the cookie is no longer associated with a user.</p><p> 当客户端重复此会话ID后退到服务器时，服务器将查找（例如）数据库中的ID，该数据库将其链接回用户ID。当用户想要注销时，会话ID从中删除会话ID数据存储，这意味着cookie不再与用户关联。 </p><p>  Languages like PHP have a storage system for this built in, and will by defaultby default store data in the local filesystem. In the Node.js ecosystem, bydefault this data will be in ‘memory’ and disappear after the server restarts.</p><p>PHP这样的语言具有内置的存储系统，并且将在本地文件系统中的DefaultBy Default Store数据中的存储系统。在Node.js生态系统中，bydefault此数据将处于“存储器”中，并在服务器重新启动后消失。</p><p> These approaches make sense on developer machines, or when sites were hostedon long-lived bare-metal servers, but these days a deploy typically meansa completely fresh ‘system’, so this information needs to be stored in a placethat outlives the server. An easy choice is a database, but it’s common forsites to use systems like Redis and Memcached, which works for tiny sites, butstill works at massive scales.</p><p> 这些方法对开发人员机器进行了意义，或者当网站是Hostedon长期裸机服务器时，但这些日子通常均可完全鲜明的“系统”，因此需要存储在服务器中的PlaceThat中的信息。一个简单的选择是数据库，但使用Redis和Memcached等系统使用的系统很常见，这适用于Tiny网站，但是在大规模尺度上工作。</p><p>  Over 10 years ago, I started working a bit more with OAuth v1 and similarauthentication systems, and I wondered if we could just store all theinformation in the cookie and cryptographically sign it:</p><p>  10多年前，我开始使用OAuth v1和类似的特朗尼主系统工作了更多的工作，我想知道我们是否只能将所有的所有信息存储在cookie中并加上加密签署它：</p><p>  Despite getting some good answers, I didn’t go through with it as I didn’tfeel confident enough in making this secure, and I felt it required a betterunderstanding in crypto than I did.</p><p>  尽管获得了一些好的答案，但我并没有通过它，因为我没有足够的自信，在制作这个安全方面，我觉得它需要在加密比我所做的更好的地方。</p><p> A few years later, we got  JWT, and it’s hot shit! JWT itself is a standard forencrypting/signing JSON objects and it’s used a LOT for authentication.Instead of an opaque token in a cookie, we actually embed the  user_id again,but we include a signature. The signature can only be generated by the server,and it’s calculated using a ‘secret’ and the actual data in the cookie.</p><p> 几年后，我们得到了JWT，它是热辣的狗屎！ JWT本身是一个标准的forencrypting /签名的json对象，它使用了很多用于身份验证。在cookie中的不透明令牌中，我们实际上会再次嵌入user_id，但我们包含签名。签名只能由服务器生成，并且它使用“秘密”和cookie中的实际数据计算。</p><p> This means that if the data is tampered with (the  user_id was changed), thesignature no longer matches.</p><p> 这意味着如果数据被篡改（User_ID已更改），则Thesignature不再匹配。</p><p> So why is this useful? The best answer I have for this, is that it’s notneeded to have a system for session data, like Redis or a database. All theinformation is contained in the JWT, it means your infrastructure is intheory simpler. You’re potentially making fewer calls to a data-store ona per-request basis.</p><p> 那么为什么这是有用的？我为此获得的最佳答案是，它没有与redis或数据库一样的会话数据系统。所有本信息都包含在JWT中，这意味着您的基础架构是简单的。您可能会根据每个请求的数据存储较少的呼叫较少。 </p><p>   First, it’s a complicated standard and users are prone to get the settingswrong. If the settings are wrong, in the worst case it could mean that  anyonecan generate valid JWTs and impersonate anyone else. This is not abeginners-level problem either, last year  Auth0 had a bug in one oftheir products that had this very problem.</p><p>首先，它是一个复杂的标准，用户容易获得SetterningWrong。如果设置错误，则在最坏的情况下，它可能意味着Anyonecan会生成有效的JWT，并模拟其他任何人。这不是abeginers级问题，也是去年的验证在其中一个产品中有一个错误的错误。</p><p> Auth0 is(or was? they just got acquired) a major vendor for security products,and ironically sponsor the  jwt.io website. If they’re not safe, whatchance does the general (developer) public have?</p><p> auth0是（或是？他们刚收购）安全产品的主要供应商，以及讽刺地赞助JWT.IO网站。如果他们不安全，那么普通（开发商）公众有什么？</p><p> However, this issue is part of a larger reason why many security experts dislike JWT: it has a ton of features and a very large scope, whichgives it a large surface area for potential mistakes, by either libraryauthors or users of those libraries. (alternative stateless tokens to JWT exists, and some of them do solve this.)</p><p> 然而，这个问题是许多安全专家不喜欢JWT的较大原因的一部分：它具有大量的特征和一个非常大的范围，这将其成为潜在错误的大型表面积，由图书馆遗传或这些库的用户来说。 （存在替代无国籍标记为JWT存在，其中一些人确实解决了这个问题。）</p><p> A second issue is ‘logging out’. With traditional sessions, you can justremove the session token from your session storage, which is effectivelyenough to ‘invalidate’ the session.</p><p> 第二个问题是'注销'。使用传统的会话，您可以从您的会话存储中获取会话令牌，从而有效地为“无效”会话。</p><p> With JWT and other stateless token this is not possible. We can’t removethe token, because it’s self-contained and there’s no central authority thatcan invalidate them.</p><p> 使用JWT和其他无状态令牌，这是不可能的。我们不能删除令牌，因为它是独立的，而且没有中央权威，那个人无效。</p><p>  The tokens are made very short lived. For example, 5 minutes. Before the5 minutes are over, we generate a new one. (often using a separate refreshtoken).</p><p>  令牌非常短暂。例如，5分钟。在5分钟结束之前，我们会生成一个新的。 （通常使用单独的刷新）。</p><p>    There is no server-driven log out, and the assumption is that the clientcan delete their own tokens.</p><p>    没有服务器驱动的注销，假设是客户员删除自己的令牌。 </p><p> Good systems will typically use the first two. An important thing to point outis, in order to support logout, you’ll likely still need a centralized storagemechanism (for refresh tokens, revocation lists or both), which is the verything that JWT were supposed to ‘solve’.</p><p>良好的系统通常将使用前两个。要点出口的重要事项，为了支持注销，您仍可能需要一个集中式商店（用于刷新令牌，撤销列表或两者），这是JWT应该“解决”的一员。</p><p> Sidenote: some people like JWT because it’s fewer systems to hit per request,but that contradicts with being able to revoke tokens before they expire.</p><p> Sidenote：有些人喜欢JWT，因为每次请求的系统较少，但能够在他们过期之前撤销令牌的矛盾。</p><p>  My favourite solution to this is keep a global list of JWTs that have beenrevoked before they expired (and remove the tokens after expiry). Insteadof letting webservers hit a server to get this list, push the list to eachserver using a pub/sub mechanism.</p><p>  我最喜欢的解决方案是保留在他们过期之前已经过的JWTS的全局列表（并在到期后删除令牌）。而是让WebServers命中服务器获取此列表，使用Pub / sub机制将列表推向每个Server。</p><p>  Revoking tokens is important for security, but rare. Realistically thislist is small and easily fits into memory. This largely solves thelogout issue.</p><p>  撤销令牌对安全性很重要，但罕见。现实地，这份列表很小，很容易适合内存。这在很大程度上解决了thelovout问题。</p><p> A last issue with JWT is that they are relatively big, and when used incookies it adds a lot of per-request overhead.</p><p> JWT的最后一个问题是它们比较大，并且当使用的仪式时，它会增加大量的每个请求的开销。</p><p> All in all, that’s a lot of drawbacks just to avoid a central sessionstore. It’s not my opinion that JWT are universally a bad idea or withoutbenefits, but there is a lot to consider.</p><p> 总而言之，这只是为了避免中央会话库的大量缺点。这不是我看来，JWT普遍是一个坏主意或勒出者，但有很多需要考虑。</p><p>  One thing that’s surprised me when reading tech blogs, is that thereis a  lot of chatter around JWT. Especially on Medium and subreddits like /r/node I see intros to JWT on an extremely regular basis.</p><p>  在阅读科技博客时，有一件事让我感到惊讶，这就是JWT围绕着很多喋喋不休。特别是在媒体和子资金，如/ R /节点，我以极定的基础将intris到JWT。 </p><p> I realize that that doesn’t mean that ‘JWTs are more popular thansession tokens’, for the same reason that GraphQL isn’t more popular thanREST, or NoSQL than relational databases: it’s just not that interestingto write about the technology that’s been tried and tested for a decade ormore (See:  Appeal to novelty). In addition, subject experts that writeabout new solutions are likely going to have different problems &amp; scale thanthe majority of their own readers.</p><p>我意识到这并不意味着'JWTS更受欢迎的Thanssion令牌'，因为GraphQL并不是比关系数据库更受欢迎，或者NoSQL：它不是一个有趣的关于已经尝试的技术和经过十年或更多的测试（参见：上诉到新奇）。此外，撰写新解决方案的主题专家可能会产生不同的问题＆amp;尺寸大多数自己的读者。</p><p> However, these new technologies create a lot more buzz than their simplercounterparts, and if enough people keep talking about the hot thing,eventually this can translate to actual adoption, despite it being asub-optimal choice for the majority of simple use-cases.</p><p> 然而，这些新技术比他们的SimplerCounterparts创造了更多的嗡嗡声，如果足够的人一直在谈论热门的东西，最终这可以转化为实际的采用，尽管它是大多数简单用例的Asub最佳选择。</p><p> This is similar to many newer developers learning how to build SPAs withReact before server-rendered HTML. Experienced devs would likely feel thatserver-rendered HTML should probably be your default choice, and buildingan SPA  when needed, but this is not what new developers are typicallytaught.</p><p> 这类似于许多较新的开发人员，学习如何在服务器呈现的HTML之前构建SPAS。经验丰富的Devs可能会觉得SERVER呈现的HTML可能是您需要的默认选择，并且在需要时构建SPA，但这不是新的开发人员通常是什么样的。</p><p> Adopting complex systems before the simple option is considered issomething I see happening more, but it surprised me for JWT.</p><p> 在简单的选择之前采用复杂的系统被认为是ISSOMething，我看到发生更多，但它让JWT感到惊讶。</p><p> As an exercise, I looked up the top most popular (by votes) postson /r/node that mention JWT. I was going to go over the first 100, but gotbored after the top 12.</p><p> 作为一项练习，我抬起最受欢迎的最受欢迎（by票）邮政信/ r / node提及jwt。我打算超过前100岁，但在前12名之后得出了。</p><p>  1 mentions using a revocation list,  3 mention refesh tokens.The remaining articles and github repositories simply have no means oflogging out.</p><p>  1提到使用撤销列表，3提到REFESH令牌。剩余的文章和Github存储库根本没有忘记。</p><p>        Most of posts use expiry times of weeks or months and 3 posts  neverexpire their JWTs.</p><p>        大部分帖子使用周或几个月的到期时间，3帖尼维斯省的JWTS。 </p><p> Except 1, the quality of these highly upvoted posts was extremely low, theauthors were likely not qualified to write about this and can potentiallycause real-world harm.</p><p>除了1，这些高度上升的帖子的质量极低，散步可能没有资格写下这一点，并可能潜在危害。</p><p> All this at least confirmed my bias that JWT for security tokens is hard toget right.</p><p> 所有这一切至少证实了我的偏见，即安全令牌的JWT很难。</p><p>  Going through tons of Reddit posts and comments also got me a more refinedidea of why people think JWTs are better. The top reason everywhere is:“It’s more scalable”, but it’s not obvious at what scale people  thinkthey’ll start to have issues. I believe the point where issues start toappear is likely much higher than is assumed.</p><p>  经过大量的红线帖子和评论也让我更加澄清了为什么人们认为JWTS更好。到处都是：“它更加可扩展”，但它在思考的思想开始有问题时不明显。我相信问题开始表现的观点可能远远高于假设。</p><p> Most of us aren’t Facebook, but even at ‘millions of active sessions’, adistributed key-&gt;value store is unlikely going to buckle.</p><p> 我们大多数人不是Facebook，但即使在“数百万积极的会议”中，AdistRibed Key-和GT;价值商店不太可能扣。</p><p> Statistically, most of us are building applications that won’t make aRaspberry Pi break a sweat.</p><p> 统计上，我们大多数人都在建立不会使AraSpberry Pi打破汗水的应用程序。</p><p>  Using JWTs for tokens add some neat properties and make it possible in somecases for your services to be stateless, which can be desirable property insome architectures.</p><p>  使用JWTS for令牌添加一些简洁的属性，并在某个时期使您的服务成为无状态，这可能是可取的属性Insome架构。</p><p> Adopting them comes with drawbacks. You either forego revocation, or youneed to have infrastructure in place that be way more complexthan simply adopting a session store and opaque tokens.</p><p> 采用它们附带缺点。您要么放弃撤销，或者您要拥有基础架构，以便更加复杂的方式只是采用会话商店和不透明令牌。 </p><p> My point in all this is not to discourage the use of JWT in general, butbe deliberate and careful when you do. Be aware of both the security andfunctionality trade-offs and pitfalls. Keep it out of your ‘boilerplates’and templates, and don’t make it the default choice.</p><p>我的观点在这一切都不是为了劝阻JWT的使用，而是在你做的时候刻意和小心。 了解安全和功能权衡和陷阱。 将其留出您的'Booterplates'and模板，并不使其成为默认选择。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://evertpot.com/jwt-is-a-bad-default/">https://evertpot.com/jwt-is-a-bad-default/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/默认/">#默认</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/default/">#default</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jwt/">#jwt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>