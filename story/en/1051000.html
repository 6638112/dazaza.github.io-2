<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>r中的现代文本功能 Modern Text Features in R</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Modern Text Features in R<br/>r中的现代文本功能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 10:59:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/fb0ba3ab9dfcb51793284558fecae382.jpg"><img src="http://img2.diglog.com/img/2021/3/fb0ba3ab9dfcb51793284558fecae382.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I’m extremely pleased to present the culmination of several years of work spanning the  systemfonts,  textshaping, and  ragg packages. These releases complete our efforts to create a high-quality, performant raster graphics device that works the same way on every operating system.</p><p>我非常高兴地展示了几年的工作，跨越了Systemfonts，Textshing和Ragg套餐的工作。这些发布完成我们的努力来创建一种高质量的性能光栅图形设备，在每个操作系统上都有相同的方式工作。</p><p> This blog post presents our improvements to ragg’s font rendering so that it now “just works” regardless of what you throw at it. This includes:</p><p> 此博客帖子介绍了RAGG字体渲染的改进，以便现在“只是作品”，无论你抛出什么。这包括：</p><p>  All of the above comes in addition to the fact that ragg is able to use all of your installed fonts.</p><p>  以上所有内容都是除了ragg能够使用所有已安装的字体的事实之外。</p><p> To access these features all you need to do install the latest version of ragg:</p><p> 要访问这些功能，您需要安装最新版本的RAGG：</p><p>  But I’d invite you to read on to learn how it works, how to control it, and what it all means for you as a user.</p><p>  但我邀请您阅读，以了解它是如何运作的，如何控制它，以及它作为用户的方式。</p><p>  ragg can be used directly in the same way as the built-in devices, such as   png(),   jpeg(), and   tiff(), by opening the device, running some code that renders graphics, and closing it again when done using   dev.off(). The devices in ragg are prefixed with  agg_ and named by the file format they produce (e.g.   agg_png()).</p><p>  RAGG可以通过打开设备的内置设备直接以与内置设备（如PNG（），JPEG（）和TIFF（）相同的方式使用，运行一些代码呈现图形的代码，并在完成后再次关闭它dev.off（）。 RAGG中的设备以AGG_为前缀，由它们生成的文件格式命名（例如，AGG_PNG（））。</p><p> You can use ragg with   ggsave() by passing the device function to the  device argument (e.g.   ggsave(device = agg_tiff)).</p><p> 您可以通过将设备函数传递给设备参数（例如GGSAVE（Device = Agg_tiff））来使用带有GGSave（）的RAGG。 </p><p> You can tell RStudio to use ragg in the  Plots pane be setting the backend to  AGG under  Global Options &gt; General &gt; Graphics.</p><p>您可以告诉Rstudio在Plots Pane中使用RAGG将后端设置为Global Options＆gt;一般＆gt;图形。</p><p> ragg can be used when knitting Rmarkdown files by setting  dev=&#34;ragg_png&#34; in the code chunk options.</p><p> 通过设置dev =＆＃34编织Rarkmdown文件时可以使用ragg; ragg_png＆＃34;在代码块选项中。</p><p>   With the new version of ragg, you’ll be able to render plots such as this and expect it to simply work:</p><p>   使用新版本的RAGG，您将能够呈现诸如此类的绘图，并期望它只是为了工作：</p><p> library (  ggplot2 ) city_names  &lt;-   c (  &#34;Tokyo (東京)&#34;,  &#34;Yokohama (横浜)&#34;,  &#34;Osaka (大阪市)&#34;,  &#34;Nagoya (名古屋市)&#34;,  &#34;Sapporo (札幌市)&#34;,  &#34;Kobe (神戸市)&#34;,  &#34;Kyoto (京都市)&#34;,  &#34;Fukuoka (福岡市)&#34;,  &#34;Kawasaki (川崎市)&#34;,  &#34;Saitama (さいたま市)&#34; ) main_cities  &lt;-   data.frame ( name  =  city_names, lat  =   c ( 35.690,  35.444,  34.694,  35.183,  43.067,  34.69,  35.012,  33.583,  35.517,  35.861 ), lon  =   c ( 139.692,  139.638,  135.502,  136.9,  141.35,  135.196,  135.768,  130.4,  139.7,  139.646 ) ) japan  &lt;-  rnaturalearth ::  ne_countries ( scale  =  10, country  =  &#34;Japan&#34;, returnclass  =  &#34;sf&#34; )  ggplot ( )  +   geom_sf ( data  =  japan, fill  =  &#34;forestgreen&#34;, colour  =  &#34;grey10&#34;, size  =  0.2  )  +  ggrepel ::  geom_label_repel (   aes ( lon,  lat, label  =  name ), data  =  main_cities, fill  =  &#34;#FFFFFF88&#34;, box.padding  =   unit ( 5,  &#34;mm&#34; )  )  +   geom_point (  aes ( lon,  lat ),  main_cities )  +   ggtitle (  &#34;Location of largest cities in Japan (日本) 🇯🇵&#34;  )  +   theme_void ( )  +   theme (panel.background  =   element_rect ( &#34;steelblue&#34; ), plot.title  =   element_text (margin  =   margin ( 5,  0,  5,  0 ) ) )</p><p> 图书馆（GGPLOT2）City_names＆lt;  -  c（＆＃34;东京（东京）＆＃34;＆＃34;横滨（横浜）＆＃34 ;,＆＃34;大阪（大厦市）＆＃34 ;, ＆＃34;名古屋（名字市）＆＃34 ;,＆＃34;札幌（札幌市）＆＃34 ;,＆＃34;神户（神戸市）＆＃34 ;,＆＃34;京都（京都市）＆＃34 ;,＆＃34;福冈（福州市）＆＃34 ;,＆＃34; kawasaki（川崎市）＆＃34;＆＃34;埼玉（さいたま市）＆＃34;）main_cities＆＃34;）main_cities＆lt ;  -  data.frame（name = city_names，lat = c（35.690,35.444,34.067,35.69,35.012,31.583,35.517,35.861,35.517,35.861），Lon = C（139.692,139.638,135.502,136.9,141.35,135.196 ，135.768,130.4,139.7,139.646））日本＆lt;  -  rnattalth :: ne_countries（scale = 10，country =＆＃34;日本＆＃34; returnclass =＆＃34; sf＆＃34;）ggplot（）+ geom_sf （数据=日本，填充=＆＃34; forestgreen＆＃34;，color =＆＃34; grey10＆＃34; size = 0.2）+ ggrepel :: geom_label_repel（aes（lon，lat，label = name），data = main_cities，填充=＆＃34;＃ffffff88＆＃34;，box.padding =单位（5，＆＃34; mm＆＃34;））+ geom_point（aes（ lon，lat），main_cities）+ ggtitle（＆＃34;日本最大城市的位置（日本）🇯🇵＆＃34; ）+ theme_void（）+主题（panel.background = Element_Rect（＆＃34; SteelBlue＆＃34;），Plot.title = Element_Text（Margin = Margin（5,0,5,0））））</p><p> Note the effortless mix of text in English and Japanese, along with emoji in the title. If this has piqued your interest, read on!</p><p> 注意英语和日语中的毫不费力的文本组合，以及标题中的表情符号。如果这激起了你的兴趣，请继续阅读！</p><p>  English, the lingua franca of programming, has tended to dominate everything related to text within programming, ranging from encoding to rendering. This has made the Latin script, used in most of the Western world, the best (or often only) supported script in many text-rendering pipelines. This has been true in the R world where the built-in graphic devices have struggled to display other scripts (with the exception of Cairo devices on Linux). It is about time (overdue, really!) that the graphics system in R becomes more inclusive of which languages can be used. It is thus with great joy that I announce that ragg finally supports all scripts.</p><p>  英语，Lingua Franca的编程，往往占据了编程中的文本相关的一切，从编码到渲染。这使得在大多数西方世界中使用的拉丁脚本，在许多文本渲染管道中最好的（或通常只有）支持的脚本。在R世界中，内置图形设备努力显示其他脚本（Linux上的开罗设备除外），这一直如此。它是关于时间（逾期，真的！）r中的图形系统变得更加包含哪些语言。因此，我宣布RAGG最终支持所有脚本。</p><p>  To start off we will look at a sample of different scripts (Arabic, Hebrew, and Sindhi) that pose a challenge because they are written from right to left:</p><p>  要开始，我们将查看不同脚本（阿拉伯语，希伯来语和Sindhi）的样本，这会构成挑战，因为它们是从右到左写的： </p><p> arabic_text  &lt;-  &#34;هذا مكتوب باللغة العربية&#34; hebrew_text  &lt;-  &#34;זה כתוב בעברית&#34; sindhi_text  &lt;-  &#34;هي سنڌيءَ ۾ لکيو ويو آهي&#34; p  &lt;-   ggplot ( )  +   geom_text (   aes (x  =  0, y  =  3 : 1, label  =   c ( arabic_text,  hebrew_text,  sindhi_text ) ), family  =  &#34;Arial&#34;  )  +   expand_limits (y  =   c ( 0,  4 ) ) preview_devices ( p,  &#34;rtl_example&#34; )</p><p>Arabic_text＆lt;  - ＆＃34;هذامستوبباللةالعربية＆＃34;希伯来_Text＆lt;  - ＆＃34;זהזהכתוברית＆＃34; sindhi_text＆lt;  - ＆＃34;هيسنسيةءلکيوويوفي＆＃34; p＆lt; ggplot（）+ geom_text（aes（x = 0，y = 3：1，label = c（阿拉伯语_text，hebrew_text，sindhi_text）），family =＆＃34; Arial＆＃34;）+ expand_limits（y = c（0,4））preview_devices（p，＆＃34; rtl_example＆＃34;）</p><p>  If you’re not familiar with the languages above it can be hard to see what is right and what is wrong. You may, however, look at how the text in the code is rendered in the browser and compare that to the device rendering. If you do that, you can see that the Hebrew script is rendered in the wrong direction for all the non-ragg devices (except Cairo on Linux). For the Arabic and Sindhi it’s even harder to see what’s wrong because the text looks fundamentally different. That’s because both Arabic and Sindhi rely extensively on text substitution rules and ligatures; the way a letter is written depends critically on what letters it is next to. Still, by comparing to the browser rendering you can see that the same devices failing on the Hebrew script fail here as well.</p><p>  如果你不熟悉上面的语言，那么很难看出什么是正确的，什么是错误的。但是，您可以查看代码中的文本如何在浏览器中呈现，并将其与设备呈现进行比较。如果这样做，您可以看到希伯来语脚本在所有非RAGG设备（Linux上的开罗除外）中呈现错误的方向。对于阿拉伯语和Sindhi来说，甚至更难看出有什么问题，因为文本看起来根本不同。那是因为阿拉伯语和辛迪既广泛依赖文本替代规则和扎实;写的是一封信的方式批判性地依赖于它旁边的字母。尽管如此，通过与浏览器渲染进行比较，您可以看到Hebrew脚本上失败的同一设备在此处失败。</p><p> The Cairo device on Linux handles this task well, as we have noted above. How come this works, but only on one OS? Cairo is built in to most Linux distributions and is designed to work with Pango, the library that linux uses to layout text. R’s Cairo graphics device bundles Cairo on all platforms, but doesn’t include Pango, due to the challenges of building it on other operating systems.</p><p> Linux上的开罗设备很好地处理此任务，正如我们上面所指出的那样。这是如何运作的，但只在一个操作系统上？ CAIRO内置于大多数Linux发行版，并且旨在与Pango一起使用Linux用于布局文本的库。 R的开罗图形设备在所有平台上捆绑开罗，但由于在其他操作系统上建造它的挑战，不包括Pango。</p><p>  What happens if you combine right-to-left and left-to-right text in the same sentence? The string needs to be split into pieces that each consist of text running in one direction, laid out individually, and then combined back together</p><p>  如果在同一个句子中将左右和左右文本组合在一起，会发生什么？需要将字符串分成碎片，每个部分包含在一个方向上运行的文本，单独布置，然后将它们组合在一起</p><p> bidi_text  &lt;-  &#34;The Hebrew (עִברִית) script\nis right-to-left&#34; p  &lt;-   ggplot ( )  +   geom_text (   aes (x  =  0, y  =  0, label  =  bidi_text ), family  =  &#34;Arial&#34;  ) preview_devices ( p,  &#34;bidi_example&#34; )</p><p> bidi_text＆lt;  - ＆＃34;希伯来语（עִברִית）脚本\ nis左右＆＃34; p＆lt; ggplot（）+ geom_text（aes（x = 0，y = 0，label = bidi_text），family =＆＃34; Arial＆＃34;）preview_devices（p，＆＃34; bidi_example＆＃34;）</p><p>  Given that most devices struggle with RtL scripts, it’s not surprising that they also fail when mixed. Again the exception is ragg, and Cairo on Linux.</p><p>  鉴于大多数设备与RTL脚本斗争，它并不令人惊讶，它们在混合时也会失败。再次例外是ragg，以及Linux上的开罗。</p><p>  A part of supporting some of the non-Latin scripts described above is to have support for ligatures (substituting multiple glyphs with a single new glyph). While ligatures are a requirement for the correct rendering of some scripts it is also an optional feature of fonts in general in order to support different text variations. More generally, the OpenType font format describes a long range of features, many optional, that defines specific glyph substitutions (both one-to-one and many-to-one) or position adjustments that can be turned on or off and will affect the look of the final rendered text. Some of these features are turned on automatically for specific scripts (e.g. required ligatures for Arabic), while others are left for the user to turn on at their discretion (e.g. tabular numerics). As part of the work to add support for non-Latin scripts the infrastructure to support all OpenType features was built. This, of course, requires that the font in use supports the requested feature.</p><p>  支持上述一些非拉丁脚本的一部分是支持连接的支持（用单个新字形替换多个字形）。虽然Ligatures是对某些脚本正确渲染的要求，但是通常是字体的可选功能，以便支持不同的文本变体。更一般地，OpenType字体格式描述了很多功能，许多可选，它定义了可以打开或关闭的特定字形替换（一对一和多对一）或位置调整，并将影响看最终渲染的文字。其中一些功能是自动打开特定脚本的（例如，阿拉伯语所需的脱象），而其他特征则留下其他人为用户自行决定（例如表格编号）。作为为非拉丁脚本添加支持的工作的一部分，构建了支持所有OpenType功能的基础架构。当然，这要求使用的字体支持所请求的功能。 </p><p> Some fonts, like the popular  Fira Code programming font, use ligatures as a main part of their appeal. These now work as expected with ragg:</p><p>一些字体，如流行的Fira代码编程字体，请使用脱离属作为其吸引力的主要部分。这些现在按照RAGG预期工作：</p><p> code  &lt;-  &#34;x &lt;- y != z&#34; logo  &lt;-  &#34;twitter&#34; p  &lt;-   ggplot ( )  +   geom_text (   aes (x  =  0, y  =  2, label  =  code ), family  =  &#34;Fira Code&#34;  )  +   geom_text (   aes (x  =  0, y  =  1, label  =  logo ), family  =  &#34;Font Awesome 5 brands&#34;  )  +   expand_limits (y  =   c ( 0,  3 ) ) preview_devices ( p,  &#34;def_features&#34; )</p><p> 代码＆lt;  - ＆＃34; x＆lt;  -  y！= z＆＃34; logo＆lt;  - ＆＃34; Twitter＆＃34; p＆lt;  -  ggplot（）+ geom_text（aes（x = 0，y = 2，label = code），family =＆＃34; fira code＆＃34;）+ geom_text（aes（x = 0，y = 1， label =徽标），family =＆＃34;字体很棒5个品牌＆＃34;）+ expand_limits（y = c（0,3））preview_devices（p，＆＃34; def_features＆＃34;）</p><p>  But what about non-default features? The capabilities of the graphics engine in R presents a problem here. There is very little information that the user is able to send along with the text to be plotted, apart from location and font ( bold and  italic on/off is the extent of it). So, having a device with support for advanced OpenType features in and of itself is nearly useless as there is no way to specify in your plot code that you want to turn a feature on or off.</p><p>  但是关于非默认功能呢？ R r中图形引擎的功能在这里存在问题。在除了位置和字体之外，用户能够与要绘制的文本一起发送的文本非常少的信息，（粗体和斜体开/关）。因此，拥有支持高级OpenType功能的设备本身几乎没用，因为没有办法在您想要打开或关闭功能的绘图代码中指定。</p><p> To work around this limitation, systemfonts now allows you to register font variants, providing a custom name that you can use to refer to a font with certain features enabled:</p><p> 要解决此限制，系统现在允许您注册字体变体，提供您可以使用的自定义名称来引用启用某些功能的字体：</p><p> library (  systemfonts )  register_variant ( name  =  &#34;Montserrat Extreme&#34;, family  =  &#34;Montserrat&#34;, weight  =  &#34;semibold&#34;, features  =   font_feature (ligatures  =  &#34;discretionary&#34;, letters  =  &#34;stylistic&#34; ) )</p><p> 图书馆（Systemfonts）register_variant（名称=＆＃34;蒙特塞拉特雷＆＃34;，family =＆＃34;蒙特塞拉特＆＃34;，重量=＆＃34;半old＆＃34; semibold＆＃34;，特征= font_feature（Ligatures =＆＃34;自由判配＆＃34;，字母=＆＃34;型号＆＃34;）））</p><p> The code above creates a new font based on Montserrat using a semibold weight and turning on standard ligatures and stylistic letter substitution. Now, in your text plotting code all you have to do is specify  &#34;Montserrat Extreme&#34; as the font family and the features and weights will be used. This only works with ragg, because none of the other devices are build on top of systemfonts, so don’t know how to access the registered font:</p><p> 上面的代码基于Montserrat创建了一种新的字体，使用半代体重和打开标准简断和风格字母替换。现在，在您的文本绘图代码中，您所要做的就是指定＆＃34;蒙特塞拉特·极端＆＃34;作为字体系列和功能和重量将被使用。这仅适用于RAGG，因为其他设备都不在系统字体上构建，因此不知道如何访问注册字体：</p><p> ggplot ( )  +   geom_text (   aes (x  =  0, y  =  1, label  =  &#34;This text should definitely differ&#34; ), family  =  &#34;Montserrat&#34;, size  =  6  )  +   geom_text (   aes (x  =  0, y  =  0, label  =  &#34;This text should definitely differ&#34; ), family  =  &#34;Montserrat Extreme&#34;, size  =  6  )  +   expand_limits (y  =   c ( - 1,  2 ) )</p><p> ggplot（）+ geom_text（aes（x = 0，y = 1，label =＆＃34;本文肯定应该有所不同＆＃34;），家庭=＆＃34;蒙特塞拉特＆＃34;，size = 6）+ geom_text（ aes（x = 0，y = 0，标签=＆＃34;本文应该不同＆＃34;），家庭=＆＃34;蒙特塞拉特雷＆＃34; size = 6）+ expanc_limits（y = c（ - 1,2）） </p><p> We can see that by using this font registration we not only gain access to weights other than normal and bold, but also to glyph substitutions such as the “Th” ligature, and the stylistic variations seen with the “t”, “f”, “l”, and “e” glyphs.</p><p>我们可以看到，通过使用此字体注册，我们不仅可以访问正常和粗体以外的权重，还可以访问诸如“Th”的字形替换，以及用“t”，“f”看到的风格变化， “L”和“E”字形。</p><p> While a lot of the optional OpenType features are mainly of interest to achieve a specific stylistic look of the rendered text, some have more importance for data visualizations, such as those related to how numbers are displayed. It is both possible to force even-width numbers, as well as correct display of fractional numbers (using  font_feature(numbers = c(&#34;tabular&#34;, &#34;fractions&#34;)) using OpenType. as long as the font supports it. So this is definitely something to look into when you want to add that final polish to your visualization.</p><p> 虽然很多可选的OpenType功能主要是实现呈现文本的特定风格外观的感兴趣的，但有些人对数据可视化具有更多重要性，例如与显示数字相关的数据可视化。它既可以强制均匀数字，以及使用Opotype的Font_feature的分数号的正确显示（使用font_feature（数字= c（＆＃34;表格＆＃34;＆＃34;部分;零件＆＃34;））。如只要字体支持它即可。所以当您想将最终波兰语添加到您的可视化时，这绝对是为了调查。</p><p>  A recent (in font technology terms) development is the availability of color fonts, i.e. fonts where the glyphs have designated colors. This development is largely driven by the ubiquity of emojis in modern text, and while it may seem that emojis have been around forever, it is recent enough that the world has yet to converge to a single standard for color fonts. The system emoji font on macOS, Windows, and Linux all uses different font technologies for storing the color glyphs, ranging from storing a single bitmap, to storing each glyph as an SVG. This, unsurprisingly, complicates things. To add insult to injury, emojis often get rendered slightly larger than the surrounding text and with a slightly lowered baseline in a very OS-specific way (this does not apply to all color fonts; only emojis).</p><p>  最近（以字体技术术语）开发是彩色字体的可用性，即字形具有指定颜色的字体。这种发展在很大程度上受到现代文本中的表情符号的无处不在的推动，而似乎表明Emojis一直存在，而且近来，世界尚未收敛到单一标准的颜色字体。 MacoS，Windows和Linux上的System Emoji字体都使用不同的字体技术来存储颜色字形，范围存储单个位图，以将每个字形存储为SVG。这是不确定的，使事情复杂化。为了增加伤害，表情符号通常会略大于周围文本，并以非常操作的方式略微降低的基线（这不适用于所有颜色字体;只有Emojis）。</p><p> Why am I telling you this? Well, honestly it is mostly to make you appreciate the labor that went into the fact that color fonts (and by extension, emojis) now just work:</p><p> 为什么我告诉你这个？好吧，诚实，它主要是让你欣赏到现在只是工作的颜色字体（和扩展，Emojis）的事实：</p><p> emojis  &lt;-  &#34;👩🏾‍💻🔥📊&#34; p  &lt;-   ggplot ( )  +   geom_label (   aes (x  =  0, y  =  0, label  =  emojis ), family  =  &#34;Apple Color Emoji&#34;  ) preview_devices ( p,  &#34;emoji&#34; )</p><p> Emojis＆lt;  - ＆＃34;👩🏾💻🔥📊＆＃34; p＆lt; ggplot（）+ geom_label（aes（x = 0，y = 0，label = emojis），family =＆＃34;苹果颜色表情符号＆＃34;）preview_devices（p，＆＃34; emoji＆＃34; ）</p><p>  As one can see, the failures range from not being able to render anything, to rendering in monochrome. Further, it appears as if the devices have trouble figuring out the dimensions of the glyphs. One additional wrinkle is that while Cairo on macOS is capable of rendering in monochrome, it fails to get the correct emoji. This is because emojis rely heavily on ligatures, and the “dark-skinned woman at a computer” emoji is actually a ligature of the “woman”, “dark skin”, and “computer” emojis.</p><p>  可以看到，失败范围从无法呈现任何东西，以便在单色中渲染。此外，看起来似乎设备难以弄清出格术的尺寸。一个额外的皱纹是，虽然在MacOS上的开罗能够在单色中渲染，但它无法获得正确的表情符号。这是因为emojis严重依赖韧皮，而“计算机上的黑皮肤”表情符号实际上是“女人”，“暗皮肤”和“计算机”表情符号的联系。</p><p>  In all of the above examples we have been very mindful in setting the font-face to a font that contains all the glyphs we need. This is not always practical, especially when you want to mix emojis and regular text. It is also an absolute requirement when mixing Latin and CJK (Chinese, Japanese, and Korean) text, as it is infeasible to include all CJK glyphs in a single font. However, we are used to things just working at the system level. No matter which font we choose it seems that a glyph is always displayed in e.g. browsers and text editors. This is because the OS is employing  font fallback, which is the act of figuring out an alternative font to use when a glyph is not present in the chosen font. Wouldn’t it be great if we could have that in a graphic device? Well, now we do!</p><p>  在上面的所有示例中，我们一直非常注意将字体面对设置为包含我们所需要的所有字形的字体。这并不总是实用的，特别是当您想混合Emojis和常规文本时。在混合拉丁语和CJK（中文，日语和韩语）文本时，它也是绝对的要求，因为它在单个字体中包含所有CJK字形是不可行的。但是，我们习惯于在系统级别工作的事情。无论我们选择哪个字体，似乎始终显示在例如术中。浏览器和文本编辑器。这是因为操作系统正在采用字体回退，这是当在所选择的字体中不存在字形时要用的替代字体的动作。如果我们在图形设备中有这一点，那不是很好吗？好吧，现在我们这样做！ </p><p> fallback_text  &lt;-  &#34;This is English, この文は日本語です 🚀&#34; p  &lt;-   ggplot ( )  +   geom_text (  aes (x  =  0, y  =  0, label  =  fallback_text ), size  =  2.5 ) preview_devices ( p,  &#34;fallback&#34; )</p><p>exprack_text＆lt;  - ＆＃34;这是英语，この文は日本语です＆＃34; p＆lt;  -  ggplot（）+ geom_text（aes（x = 0，y = 0，label = suppack_text），size = 2.5）preview_devices（p，＆＃34;回退和＃34;）</p><p>  The bottom line is that with ragg, you now don’t need to think about missing glyphs in any font you choose (unless you request a character that is not covered by any font on your system).</p><p>  底线与RAGG一起，您现在不需要考虑在您选择的任何字体中丢失的字形（除非您要求系统上任何字体涵盖的字符）。</p><p>  Most of what we have shown today simply works automagically and may (depending on your prior frustrations with script support in R) seem too good to be true. Is there any catch? Not really. systemfonts, textshaping, and ragg try to be as smart as possible about text shaping and only take additional action if required. Further everything is heavily cached, so the impact on performance is negligible.</p><p>  我们今天所表现出的大多数都是自自动作用的，并且可能（根据您在r中的脚本支持的先前挫折）似乎太好了。有没有捕获？并不真地。 SystemFonts，TextShaping和Ragg尽可能智能地塑造，并且只需采取额外的操作，如果需要。进一步的一切都很高速缓存，因此对性能的影响可以忽略不计。</p><p> There is something missing though, which we haven’t touched upon. Not all scripts are LtR or RtL. A few, especially Asian scripts, are top-to-bottom. Top-to-bottom scripts are sadly not yet supported. This is not due to any limitation in the underlying shaping technology, but due to limitations in the R graphics engine, which assumes horizontal text in key places of the API. This means that, until the graphics engine is updated, it is outside the grasp of graphic devices to support vertical text. Hopefully, this is an area that will improve in the future.</p><p> 我们没有触及的东西失踪。并非所有脚本都是LTR或RTL。少数尤其是亚洲脚本，是顶到底的。悲伤地尚未支持自上而下的脚本。这不是由于底层塑造技术的任何限制，而是由于R图形引擎的限制，这在API的关键位置假设水平文本。这意味着，直到更新图形引擎，它超出了图形设备的掌握以支持垂直文本。希望这是未来会改善的一个地区。</p><p>  I hope you’ll appreciate the new features described here. I’d like to thank everyone who have helped validate the text rendering on Twitter. A special thanks goes out to Behdad Esfahbod (  http://behdad.org) for his work on HarfBuzz, Fribidi, and almost everything else underlying modern font rendering. He has been especially gracious in his help and support.</p><p>  我希望您将欣赏这里描述的新功能。我要感谢所有帮助验证Twitter上的文本渲染的人。特别感谢Behdad esfahbod（http://behdad.org）在Harfbuzz，Fribidi，以及几乎所有其他潜在的现代字体渲染中的工作。他的帮助和支持是特别仁慈的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.tidyverse.org/blog/2021/02/modern-text-features/">https://www.tidyverse.org/blog/2021/02/modern-text-features/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文本/">#文本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字体/">#字体</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>