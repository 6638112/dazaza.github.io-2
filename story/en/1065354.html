<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MixPanel代码部署工具的演变 Evolution of code deployment tools at Mixpanel</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Evolution of code deployment tools at Mixpanel<br/>MixPanel代码部署工具的演变 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-13 00:43:26</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/410dc662c5bf11fa82494aac596aa623.png"><img src="http://img2.diglog.com/img/2021/6/410dc662c5bf11fa82494aac596aa623.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At Mixpanel, we’ve had our ups and downs with the cloud. We  moved off the cloud back in 2011 to dedicated hardware deployed on  Softlayer. Although we got rid of some of the noisy neighbor problems we saw on Rackspace, it came at the cost of over-provisioning our processing capacity because it was tough to get machines on-demand. After a lot of soul-searching, we finally decided to move back to the cloud in 2016. At the time, Kubernetes (k8s) was emerging as the industry leader in container orchestration. We really liked Google’s managed k8s offering (GKE), and by late 2017, a large portion of Mixpanel’s infrastructure was running on Google Cloud Platform (GCP).</p><p>在MixPanel，我们有了云的起伏。我们在2011年将云移回到2011年到部署在软层上的专用硬件。虽然我们摆脱了我们在Rackspace上看到的一些嘈杂的邻居问题，但它以过度配置的加工能力为代价，因为它很难让机器按需获取。经过大量的灵魂搜索，我们终于决定在2016年回到云端。当时，Kubernetes（K8S）被涌现为集装箱管理的行业领导者。我们真的很喜欢谷歌的托管K8S提供（GKE），并于2017年底，大部分MixPanel的基础设施正在谷歌云平台上运行（GCP）。</p><p>  When we first moved to GKE, we set up two identical clusters. Both were in the same region but in different zones for redundancy and high availability. Each team would deploy services under its own namespace. This gave us a way to scale out our k8s deployments as more and more workloads moved to the cloud. We started with handcrafted YAML files for each of these workloads. Engineers would edit and apply these files ad-hoc. To keep both clusters in sync, they would have to deploy code twice. Occasionally, someone would forget to deploy to the second zone, which led to subtle differences that were hard to debug. Over time, we created a wrapper named  mix that would diff the new files against what was running in production to give you an idea of what changes would be applied and then alert you if one zone was out of sync with the other. Soon,  mix became the de-facto tool to build and deploy code manually. Say you wanted to deploy a new version of a service  foo, you&#39;d run the following commands.</p><p>  当我们第一次移动到GKE时，我们建立了两个相同的集群。两者都在相同的地区，而是在不同的区域中进行冗余和高可用性。每个团队都会在自己的命名空间下部署服务。这给了我们一种扩展我们的K8S部署的方法，因为越来越多的工作负载移动到云。我们开始为每个工作负载中的手工制作的yaml文件。工程师会编辑并应用这些文件ad-hoc。要保持两个群集同步，它们必须两次部署代码。偶尔，有人会忘记部署到第二个区域，这导致了难以调试的细微差异。随着时间的推移，我们创建了一个名为mix的包装器，它将弥补新文件，以防止在生产中运行的内容，以便了解将应用更改的内容，然后如果一个区域与另一个区域不同步，则会提醒您。很快，Mix成为手动构建和部署代码的De-Facto工具。假设您想要部署一个服务foo的新版本，＆＃39; d运行以下命令。</p><p>   Manual deploys worked surprisingly well while we were getting our services up and running. More and more features were added to  mix to interact not just with k8s but also other GCP services. To avoid dealing with raw YAML files directly, we moved our k8s configuration management to  Jsonnet. Jsonnet allowed us to add templates for commonly used paradigms and reuse them in different deployments.</p><p>   在我们让我们的服务上运行并运行时，手动部署令人惊讶的是。添加了越来越多的功能来混合以与K8S相互作用，而且还添加了其他GCP服务。为避免直接处理原始的YAML文件，我们将K8S配置管理移动到JSONnet。 jsonnet允许我们为常用的范例添加模板，并在不同的部署中重用它们。</p><p> At the same time, we kept adding more k8s clusters. We added more geographically distributed clusters to run the servers handling incoming data to decrease latency perceived by our ingestion API clients. Around the end of 2018, we started evaluating a European Data Residency product. That required us to deploy another full copy of all our services in two zones in the European Union.</p><p> 与此同时，我们一直在添加更多的K8S集群。我们添加了更多地理上分布式的集群，以运行处理传入数据以减少摄入API客户端感知的延迟的服务器。截至2018年底，我们开始评估欧洲数据居住产品。这需要我们在欧盟两国部署我们所有服务的另一个完整副本。</p><p> We were now up to 12 separate clusters, and many of them ran the same code and had similar configurations.</p><p> 我们现在最多12个独立的集群，其中许多人运行相同的代码并具有相似的配置。</p><p>  While manual deploys worked fine when we ran code in just two zones, it quickly became infeasible to keep 12 separate clusters in sync manually. Across all our teams, we run more than 100 separate services and deployments. Many of these services depended on each other, so there were times when we’d have to carefully coordinate deploys to make sure a dependency was fully updated before then updating a service. While adding integration tests and a better alerting system helped improve things, we quickly realized that we needed to approach this problem from first principles. It was fairly clear to us that we needed an automated way to deploy code and a CI/CD setup. We decided to run a POC with two of the most popular recommendations:  Spinnaker and  Argo.</p><p>  当手动部署工作时，我们在只有两个区域中运行代码时，它很快就会发出手动连续12个独立的群集。在所有团队中，我们运行了100多个单独的服务和部署。许多这些服务彼此依赖，所以有时我们必须仔细协调部署以确保在然后更新服务之前完全更新依赖项。在添加集成测试和更好的警报系统时帮助改善了事物，我们很快意识到我们需要从第一个原则接近这个问题。我们对我们来说非常清楚，我们需要一种自动部署代码和CI / CD设置的自动化方法。我们决定使用两个最受欢迎的建议：Spinnaker和Argo。</p><p>   We found Spinnaker to be a lot more user-friendly. Seeing a visual representation of a pipeline being built was excellent. Spinnaker’s built-in Slack messaging integrated nicely with our existing deployment monitoring procedure. Our engineers monitor Slack and will respond quickly when notified about failed deployments. The biggest pain point with Spinnaker was the inability to represent pipelines in code. We tried to work around this limitation by creating a custom library using Jsonnet, but it wasn’t the easiest thing to maintain and run. Lastly, Spinnaker uses Java. This isn’t bad per-se; we do run a few Java services at Mixpanel. However, our engineering team is more familiar with Golang, and we prefer using Golang-based solutions wherever possible.</p><p>   我们发现Spinnaker更加用户友好。看到建造的管道的视觉表现非常出色。 Spinnaker的内置Slack Messaging与我们现有的部署监控程序很好地集成。我们的工程师监控Slack，并在通知未发生故障的部署时快速响应。 Spinnaker最大的痛点是无法代表代码中的管道。我们尝试通过使用JSONnet创建自定义库来解决此限制，但这不是最容易维护和运行的事情。最后，Spinnaker使用Java。这并不坏;我们在MixPanel上运行了一些Java服务。但是，我们的工程团队更熟悉Golang，我们更喜欢尽可能使用基于Golang的解决方案。 </p><p> Argo is a lot less opinionated and is built on k8s. There was no GUI for building pipelines, but the docs were fairly good at explaining everything. Because everything used k8s YAML files under the hood, we could version-control all the changes easily using  git. To make changes to a pipeline, all you needed to do was create a new branch with your changes, test it, and merge it into the main branch. We could also reuse many of our Jsonnet templates and tooling to create these workflows, which was a bonus.</p><p>ARGO是不少的自以为是，建立在K8S上。没有GUI建造管道，但文件在解释一切方面都很善良。因为一切都在引擎盖下使用了K8S Yaml文件，我们可以使用Git轻松地控制所有更改。要对管道进行更改，您所需的就是使用更改，测试它并将其与主分支合并到主分支中的所有新分支。我们还可以重用许多jsonnet模板和工具来创建这些工作流，这是一个奖金。</p><p> In the end, it was a fairly close decision, but we decided to go with Argo.</p><p> 最终，这是一个相当近的决定，但我们决定与阿尔戈一起去。</p><p>  As we mentioned earlier, one of the key features we were looking for was the ease with which any engineer at Mixpanel could define and update pipelines for deploying their services. Since Argo workflows are just YAML files, we could extend our Jsonnet libraries to help make this process smoother. To illustrate this, one of the most common workflows for an engineer at Mixpanel goes something like this:</p><p>  正如我们之前提到的，我们正在寻找的一个关键功能是MixPanel任何工程师都可以定义和更新管道部署其服务的流水管。由于ARGO工作流只是YAML文件，我们可以扩展JSONNET库以帮助使此过程更顺畅。为了说明这一点，MixPanel的工程师最常见的工作流之一是这样的：</p><p>  While we haven’t figured out a way to automate our engineers&#39; work to write features and bug fixes, the rest of it is fairly trivial with the templates we’ve built using Jsonnet. Here’s an example of what building a pipeline looks like:</p><p>  虽然我们还没有想到以自动化我们的工程师＆＃39的方式;撰写功能和错误修复的工作，其余部分与我们使用JSONnet建造的模板相当微不足道。这是建立管道的示例看起来像：</p><p>  This gives you a working pipeline to deploy your service. Adding Slack notifications is easy, as well. We use a separate task and a sequential workflow to notify the relevant channels:</p><p>  这为您提供了部署服务的工作管道。添加Slack通知也很容易。我们使用单独的任务和顺序工作流来通知相关频道：</p><p>  It did require more work than Spinnaker, but we are happy with the more custom messages.</p><p>  它确实需要更多的工作，而不是Spinnaker，但我们对更多的自定义消息感到满意。</p><p>  Now that engineers could define pipelines easier, we wanted to focus on the end-user experience of the deployment process. Our deployment options were specified by the directory structure of the YAML configuration directory, so either determining potential services to deploy or which clusters a particular service was running in wasn’t straightforward. To solve this, we made a simple interactive tool (based on  https://github.com/AlecAivazis/survey) that prompts the user with potential services and clusters for each service. Instead of a deployer having to remember all clusters where a particular service is running, the service owner updates the config when the service is deployed to a new cluster. The deployer is prompted next time they deploy to include the new instance of that service. An example of the “interactive” deploy tool can be seen below.</p><p>  现在，工程师可以更容易地定义管道，我们想专注于部署过程的最终用户体验。我们的部署选项由YAML配置目录的目录结构指定，因此确定要部署的潜在服务或特定服务运行的群集并不简单。为了解决这个问题，我们制作了一个简单的交互式工具（基于https://github.com/alecaivazis/survey），它会提示用户每个服务的潜在服务和集群。代替部署者必须记住运行特定服务的所有群集，服务所有者在将服务部署到新群集时更新配置。下次部署到包括该服务的新实例时，将提示Deployer。下面可以在“交互式”部署工具的一个示例。 </p><p>  In addition, this more holistic deploy tool allows for dependency and configuration coordination. Actively preventing conflicting deployments has become more important as our engineering team has scaled and our service orchestration has gained complexity. We have been extremely pleased with Argo so far; it addresses all of the problems we set out to solve.</p><p>此外，此更全面的部署工具允许依赖和配置协调。由于我们的工程团队缩放，因此我们的工程团队已经获得了复杂性，积极预防的部署变得更加重要。到目前为止，我们对Argo非常满意;它解决了我们所阐述的所有问题。</p><p>  Over the last few months, a lot of our services have moved to Argo. The chart below shows the number of Argo-based deploys per month.</p><p>  在过去的几个月里，我们的许多服务已经转移到Argo。下图显示了每个月的ARGO基部署数。</p><p>  While we’ve been pretty happy with k8s and Argo, we realize that improving developer experience is a continuous process (no pun intended). Over the next few months, we’d really like to get to a state where we have a stable pipeline for continuous integration and deploys for our most critical services.</p><p>  虽然我们一直非常满意K8S和ARGO，但我们意识到提高开发人员体验是一个连续的过程（没有双关语）。在接下来的几个月里，我们真的很想到达一个稳定的管道，以便为我们最关键的服务持续集成和部署。</p><p> The DevInfra team at Mixpanel acts as a force multiplier, implementing best practices and sophisticated developer tooling across teams to build a world-class platform for our engineers. We identify high-impact projects through top-notch internal analytics and observability — at times, even using Mixpanel itself! If that sounds interesting to you, please reach out to  recruiting@mixpanel.com.</p><p> MixPanel的DevInfra团队充当了力量乘法器，在团队中实施最佳实践和复杂的开发人员工具，为我们的工程师构建世界一流的平台。我们通过顶部缺口内部分析和可观察性来确定高影响力项目 - 即使使用MixPanel本身也是如此！如果对您感兴趣，请达到recuting@mixpanel.com。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://engineering.mixpanel.com/evolution-of-code-deployment-tools-at-mixpanel-210b99926cd4">https://engineering.mixpanel.com/evolution-of-code-deployment-tools-at-mixpanel-210b99926cd4</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/部署/">#部署</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>