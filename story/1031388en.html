<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>发布流程：我们如何在VSTS团队中进行分支(2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">发布流程：我们如何在VSTS团队中进行分支(2018)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 10:26:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/77a729e8f0c189fc29b3f597aa9e59c7.png"><img src="http://img2.diglog.com/img/2020/10/77a729e8f0c189fc29b3f597aa9e59c7.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Whenever I talk to somebody about Git and version control, one question  always comes up:</p><p>每当我与某人谈论Git和版本控制时，总会出现一个问题：</p><p>  And there’s no  one answer to this question. Although we’ve been moving everybody in the company into one engineering system, standardizing on  Git hosted in  Visual Studio Team Services, what we haven’t done is move everybody into the same branching and development model.</p><p>这个问题没有一个答案。虽然我们已经将公司中的每个人都转移到了一个工程系统中，并在Visual Studio Team Services中托管的Git上实现了标准化，但我们还没有做到的是将每个人都转移到相同的分支和开发模型中。</p><p> Some teams — like Windows — have kept a branching strategy that is similar to the one that they’ve been using for many years. It’s hard to argue with this approach, they’ve got a lot of tooling to support it, and the developers have institutional knowledge about how things move between branches. Moving a team that big to Git was  challenging enough — you can only boil so many oceans at the same time.</p><p>有些团队 - ，比如Windows - ，保留了一个分支策略，这与他们多年来一直使用的策略类似。这种方法是无可争辩的，他们有很多工具来支持它，而且开发人员对如何在分支机构之间移动有一定的机构知识。把这么大的一个团队搬到吉特是很有挑战性的， - 你只能同时煮这么多大洋。</p><p> But this has led to some confusion in the way we talk about using Git: for example, Raymond Chen recently  wrote an interesting series of blog posts explaining how you shouldn’t cherry-pick commits in Git. And while this is perfectly reasonable advice for  his team’s workflows, it goes against the workflows that we use to build Visual Studio Team Services itself, and how the VSTS team works on a daily basis.</p><p>但是这导致了我们谈论使用Git的方式上的一些混乱：例如，Raymond Chen最近写了一系列有趣的博客文章，解释你不应该在Git中挑剔承诺。虽然这对他的团队的工作流来说是非常合理的建议，但它与我们用来构建Visual Studio Team Services本身的工作流以及VSTS团队的日常工作方式相违背。</p><p> So, then — how do  we do branching on the VSTS Team? First, we follow a trunk-based development approach. But unlike some trunk-based models, like GitHub Flow, we do not continuously deploy master to production. Instead, we release our master branch every sprint by creating a branch for each release. When we need to bring hotfixes into production, we cherry-pick those changes from master into the release branch. It’s a strategy that we call “ Release Flow“.</p><p>那么， - ，我们如何在VSTS团队中进行分支？首先，我们遵循基于主干的开发方法。但与一些基于干线的模型(如GitHub Flow)不同，我们不会持续地将Master部署到生产中。取而代之的是，我们通过为每个版本创建一个分支，在每个Sprint中发布我们的主分支。当我们需要将修补程序投入生产时，我们会从主版本中挑选那些更改到发布分支中。这是一种我们称之为“释放流”的策略。</p><p>   We’re big fans of  trunk-based development on the VSTS team. We like a simple branching structure where there’s a single master branch that everybody works in. This is much simpler than our old branching structure back in the dark days, many years ago, when our team was in the same TFVC repository as the Visual Studio IDE. We used to have this multi-level branching strategy that was — to be polite — ”complex”.</p><p>我们是VSTS团队中基于干线的开发的忠实粉丝。我们喜欢简单的分支结构，其中只有一个主分支，每个人都在其中工作。这比许多年前我们的旧分支结构要简单得多，当时我们的团队与Visual Studio IDE在同一个TFVC存储库中。我们曾经有过这种多层次的分支策略，即 - to be礼貌 - “Complex”。</p><p>  The more I talk to developers, the more I’ve observed something that tends to happen to teams that  don’t do trunk-based development. No matter how organized they  think they are, in fact, they tend to structure their branches in the same way. It’s a bit of a corollary to  Conway’s Law:</p><p>我与开发人员交谈的越多，我就越能观察到不进行基于主干的开发的团队往往会发生的事情。无论他们认为自己有多有组织，实际上，他们往往会以同样的方式组织自己的分支机构。这是康威定律的一个推论：</p><p>  We were no exception: you could basically watch your code flowing through the org chart. When you checked in to your branch, your code would eventually be “forward integrated” into the next branch closer to trunk, eventually landing in trunk. Once that would happen, you’d want to “reverse integrate” trunk back up to all the feature branches so that you’d have everybody else’s code.</p><p>我们也不例外：您基本上可以看到您的代码在组织结构图中流动。当您签入您的分支时，您的代码最终将被“向前集成”到离主干更近的下一个分支中，最终落地到主干中。一旦发生这种情况，您会希望将主干“反向集成”回所有功能分支，这样您就可以拥有其他所有人的代码。</p><p> This is merge hell — yes, that’s actually what we called it — and we had a person employed full-time to deal with merging, conflict resolution and making sure all this integration continued to build. Whatever we paid him, it probably wasn’t enough.</p><p>这是Merge地狱 - ，是的，这实际上就是我们所说的 - ，我们有一个人全职处理合并，解决冲突，并确保所有这些整合继续建立。不管我们付他多少钱，可能都不够。</p><p>  When you back away from feature branches and start thinking about trunk-based branching strategies, the one that often comes up is GitHub Flow. (Note, that’s  GitHub Flow, not  Git Flow, which has two “trunks” and is therefore is not really trunk-based at all.)</p><p>当您放弃功能分支，开始考虑基于主干的分支策略时，经常会出现的是GitHub流。(请注意，这是GitHub流，而不是Git流，Git流有两个“干线”，因此根本不是基于干线的。)。</p><p> I’m very familiar with GitHub Flow from my time working at GitHub. Overall, I really like this system; it’s lightweight and with good tooling and automation, you can be very productive. This system works pretty well for GitHub, but unfortunately, it doesn’t scale to the VSTS team’s needs. That’s because there’s a subtlety to GitHub Flow that often goes overlooked. You actually deploy your changes to production  before merging the pull request:</p><p>在GitHub工作期间，我对GitHub Flow非常熟悉。总体而言，我真的很喜欢这个系统；它是轻量级的，拥有良好的工具和自动化，您可以非常高效。这个系统在GitHub上运行得很好，但不幸的是，它不能扩展到VSTS团队的需求。这是因为GitHub流有一个经常被忽视的微妙之处。您实际上是在合并拉式请求之前将更改部署到生产中：</p><p> Once your pull request has been reviewed and the branch passes your tests, you can deploy your changes to verify them in production… Now that your changes have been verified in production, it is time to merge your code into the master branch. —  Understanding GitHub Flow</p><p>一旦您的拉入请求被检查并且分支通过了您的测试，您就可以部署您的更改以在Production…中验证它们。既然您的更改已经在生产中得到验证，现在就可以将您的代码合并到主分支中了。- 了解GitHub流。</p><p> This system is extremely clever: when you’re ready to check-in, you get immediate feedback on how a pull request will behave in production, and that feedback happens  before you complete the pull request. So if there’s a problem with your code changes, you can simply abandon the deployment, and your bad code never got merged into master. This lets you take a step back and look at the monitoring data to understand why your changes were problematic, then iterate on the pull request and try again.</p><p>这个系统非常聪明：当您准备好签入时，您会立即得到关于拉入请求在生产中的行为的反馈，该反馈会在您完成拉入请求之前发生。因此，如果您的代码更改有问题，您可以简单地放弃部署，并且您的坏代码永远不会合并到master中。这使您可以后退一步，查看监视数据以了解更改存在问题的原因，然后迭代拉取请求并重试。</p><p> The problem with this development strategy is that it scales  extremely poorly to larger teams, because there’s contention when you’re trying to deploy to production:</p><p>此开发策略的问题在于，它对大型团队的伸缩性极差，因为当您尝试将其部署到生产环境时会出现争用：</p><p> During peak work hours, multiple developers are often trying to deploy their changes to production. To avoid confusion and give everyone a fair chance, we can ask Hubot to add us to the deployment queue. —  Deploying Branches to GitHub.com</p><p>在工作高峰期，多个开发人员经常试图将他们的更改部署到生产环境中。为了避免混淆并给每个人一个公平的机会，我们可以要求Hubot将我们添加到部署队列中。- 将分支机构部署到gihub.com。</p><p> (If you’re not familiar with  Hubot, it’s the core of GitHub’s chatops infrastructure. GitHub uses Hubot to perform their deployments from within Slack.)</p><p>(如果您不熟悉Hubot，那么它是GitHub聊天基础设施的核心。GitHub使用Hubot从Slake内部执行其部署。)</p><p> When you have a few developers, you’re going to need a deployment queue to ensure that only one pull request can be deployed at once. This is great, but as you start to grow and hire more developers, there are more people in the queue. As your codebase grows, builds start to take longer. And as you get more popular, your infrastructure grows and with it, the time it takes to deploy.</p><p>当您有几个开发人员时，您将需要一个部署队列来确保一次只能部署一个拉请求。这很好，但是随着您开始发展并雇佣更多的开发人员，排队的人也会更多。随着代码库的增长，构建开始需要更长的时间。随着您变得越来越受欢迎，您的基础设施也会随之增长，部署所需的时间也会随之增加。</p><p> Visual Studio Team Services has hundreds of developers working on it. On average, we build, review and merge over 200 pull requests a day into our master branch. If we wanted to deploy each of those before we merged them it, it would  decimate our velocity.</p><p>Visual Studio team Services有数百名开发人员在从事这项工作。平均而言，我们每天构建、审查和合并200多个拉入请求到我们的主分支。如果我们想在合并它们之前部署它们，那会大大降低我们的速度。</p><p> We try to strike a balance where we want to code fast and get changes into master quickly, even if it takes them a little while longer to get into production. So instead of deploying every pull request to production, we deploy master to production at the end of each sprint —  every three weeks. This means that a new feature could take that long to get into production. (And, of course, that new feature might only be enabled in testing, and not for all users, since we use  feature flags in production.)</p><p>我们试图取得平衡，既要快速编码，又要快速将更改带入Master，即使它们需要更长的时间才能投入生产。因此，我们不是将每个拉请求部署到生产中，而是每三周在每个Sprint - 结束时将MASTER部署到生产中。这意味着一项新功能可能需要这么长时间才能投入生产。(当然，该新特性可能只在测试中启用，而不是对所有用户启用，因为我们在生产中使用特性标志。)。</p><p>  At the end of a sprint, when we’re ready to do a release, we create a new branch from master. This will be  the release branch for the remainder of the sprint. While new feature work and development goes on in master, production stays nicely isolated from that work. Again, this keeps our development velocity moving quickly; we don’t have to worry about how long it takes to deploy these changes to our cloud of hundreds of servers spread across multiple Azure regions. We just open a pull request, get a code review and merge it into master.</p><p>在冲刺结束时，当我们准备发布时，我们从master创建一个新分支。这将是Sprint剩余部分的发布分支。当新特性的工作和开发在大师手中进行时，生产与该工作保持良好的隔离状态。同样，这使我们的开发速度保持快速；我们不必担心需要多长时间才能将这些更改部署到我们分布在多个Azure区域的由数百台服务器组成的云中。我们只需打开一个Pull请求，进行代码审查，然后将其合并到Master中。</p><p>  We name these branches after the sprint that they correspond with. At the end of sprint 129, we create a branch named  releases/M129 from master and deploy that. Once we finish development in sprint 130, we’re ready to deploy those changes to production; at that point, we forget about the old  releases/M129 branch. Instead, we create a new branch named  releases/M130 from master and deploy it. Once the  releases/M130 deployment finishes — which would take a while, since we use a  ringed deployment strategy — we don’t care about the old  releases/M129 branch anymore. Once all the servers are running  releases/M130 and there’s nothing with M129 in production, that branch is only of historical interest. We could even delete it.</p><p>我们根据它们所对应的SPRINT来命名这些分支。在Sprint 129的末尾，我们从master创建一个名为Release/M129的分支并部署它。一旦我们在Sprint 130中完成了开发，我们就可以将这些更改部署到生产环境中了；在这一点上，我们忘记了旧的Release/M129分支。相反，我们从MASTER创建一个名为Release/M130的新分支并部署它。一旦Release/M130部署完成 - ，这将需要一段时间，因为我们使用环形部署策略 - ，所以我们不再关心旧的Release/M129分支。一旦所有服务器都运行Release/M130，并且生产中没有M129，该分支就只有历史意义了。我们甚至可以删除它。</p><p>   Of course, we don’t want production to exist in a vacuum. If there’s a high-priority bug or an availability issue, we need to be able to fix the problem quickly and deploy it immediately. That’s where cherry-picking comes in.</p><p>当然，我们不希望生产存在于真空中。如果存在高优先级的bug或可用性问题，我们需要能够快速修复问题并立即部署。这就是挑樱桃的用武之地。</p><p> When we need to bring a change to production, we first make the change against the master branch. We get it code reviewed as usual — though at a bit higher priority than normal — and merge it into master. Then we cherry-pick that pull request into the current production release branch and start deploying it.</p><p>当我们需要对生产进行更改时，我们首先针对主分支进行更改。我们让它像通常的 - 一样进行代码审查，尽管优先级比普通的 - 高一点，并将其合并到MASTER中。然后，我们将该拉请求挑选到当前生产版本分支中，并开始部署它。</p><p>  We find this workflow so useful that you can cherry-pick a pull request right from VSTS:</p><p>我们发现此工作流非常有用，您可以直接从VSTS挑选拉取请求：</p><p>  This actually cherry-picks the whole pull request, bringing each commit that made up the PR from one branch to another.</p><p>这实际上挑选了整个Pull请求，将组成PR的每个提交从一个分支带到另一个分支。</p><p> We  always make production changes this way, starting in master; that’s because  how the code gets into production is as important as the code that ultimately gets there. If we were to hotfix production directly, we might accidentally forget to bring a change back to master for the next release. But by bringing changes into master first, we ensure that we never have regressions in production.</p><p>我们总是以这种方式进行生产更改，从MASTER开始；这是因为代码进入生产的方式与最终进入生产的代码一样重要。如果我们直接热修复生产，我们可能会意外地忘记为下一个版本将更改带回MASTER。但是通过先把变化带入师父，我们确保我们的生产永远不会倒退。</p><p> This is so important that we ask if you’ve done it in the pull request template for our release branches:</p><p>这一点非常重要，我们询问您是否已在我们发布分支的拉式请求模板中这样做：</p><p>  The only exception, of course, is when the change doesn’t make sense to bring into master. Perhaps there’s been some refactoring that means that this bug doesn’t exist in master anymore. That’s the only time pull requests can go directly into a release branch without going through master first.</p><p>当然，唯一的例外是，将更改引入Master是没有意义的。也许已经进行了一些重构，这意味着MASTER中不再存在此错误。这是拉取请求可以直接进入发布分支的唯一一次，而不需要先通过MASTER。</p><p> Even though this “master first” policy takes a few extra minutes, it’s always worth it. That’s especially true when you feel the time pressure to resolve a production incident, when you might be tempted to cut corners. It ensures that we only fix these bugs once and that we won’t have a repeat availability incident due to the same problem.</p><p>尽管这个“大师优先”的政策需要额外的几分钟，但它总是值得的。当您感到解决生产事件的时间压力时，当您可能想偷工减料时，情况尤其如此。它确保我们只修复这些错误一次，并且不会因为相同的问题而出现重复的可用性事件。</p><p> I hope that this gives some context behind the branching strategy we use on the VSTS team and why it works for us. Of course, for  your branching strategy, you need to pick an approach that works for your team you have and the product that you’re building. And you should be willing to re-evaluate as those things change: as we transitioned from building an on-premises product shipping every few years to a cloud service deploying all the time, we had to change our branching strategy to fit. We needed a structure that would meet the challenges that we face today instead of fighting battles of the past. You do, too.</p><p>我希望这能为我们在VSTS团队中使用的分支策略提供一些背景信息，以及为什么它对我们有效。当然，对于您的分支策略，您需要选择一种适合您的团队和您正在构建的产品的方法。随着这些变化，您应该愿意重新评估：当我们从构建每隔几年发货一次的内部部署产品过渡到始终部署云服务时，我们必须改变分支战略以适应需求。我们需要一个能够应对我们今天面临的挑战的结构，而不是过去的战斗。你也是。</p><p> If you have any questions, please feel free to leave a comment — or if you’re coming to the  Build 2018 conference on May 7th, then I’d love to chat in person. You can drop by the version control area on the expo floor, where I’ll be hanging out.</p><p>如果您有任何问题，请随时发表评论--或者如果您要来参加5月7日的Build 2018大会，那么我很乐意亲自与您交谈。你可以顺道去一下世博会楼层的版本控制区，我会在那里闲逛。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team">https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/流程/">#流程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/flow/">#flow</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分支/">#分支</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030962.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5c422cb33c0f6b57de23bf7719b616a7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030962.html">Amazon SNS FIFO-先进先出发布/订阅消息</a></div><span class="my_story_list_date">2020-10-24 20:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030878.html"><img src="http://img2.diglog.com/img/2020/10/thumb_97511e88750ae8a6cb17654529848100.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030878.html">今天是iPhone12和iPad Air发布日，但别指望能快速发货</a></div><span class="my_story_list_date">2020-10-24 7:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030847.html"><img src="http://img2.diglog.com/img/2020/10/thumb_022db9c04e07bf6c9b7dc68a52a807d3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030847.html">FCC不会因为T-Mobile在6月15日全国范围内12小时的停机而对其进行处罚，而只是发布一份公开通知，“提醒”运营商最佳做法</a></div><span class="my_story_list_date">2020-10-24 7:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030725.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c78511cfa32eec81e26c7eb3ea637e02.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030725.html">Microsoft、IBM、NVIDIA和其他公司发布了一个开放式框架，以帮助安全分析人员检测、应对和补救机器学习系统面临的威胁</a></div><span class="my_story_list_date">2020-10-23 12:13</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>