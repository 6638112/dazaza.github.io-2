<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>稳健性原则的有害后果The harmful consequences of the robustness principle</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The harmful consequences of the robustness principle<br/>稳健性原则的有害后果</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 15:58:19</div><div class="page_narrow text-break page_content"><p>The robustness principle, often phrased as &#34;be conservative in what you send,and liberal in what you accept&#34;, has long guided the design and implementationof Internet protocols. The posture this statement advocates promotesinteroperability in the short term, but can negatively affect the protocolecosystem over time. For a protocol that is actively maintained, the robustnessprinciple can, and should, be avoided. ¶</p><p>稳健性原则，通常被称为&#34；发送的内容要保守，接受的内容要自由&#34；，长期以来一直指导着互联网协议的设计和实施。该声明倡导的姿态在短期内促进了互操作性，但随着时间的推移，可能会对原生态系统产生负面影响。对于积极维护的协议，可以也应该避免使用健壮性原则。¶</p><p> Discussion of this document takes place on the Architecture-Discuss mailing list (architecture-discuss@ietf.org), which is archived at  https://mailarchive.ietf.org/arch/browse/architecture-discuss/. ¶</p><p>本文档的讨论在架构讨论邮件列表（架构）上进行-discuss@ietf.org)，存档于https://mailarchive.ietf.org/arch/browse/architecture-discuss/. ¶</p><p> This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79. ¶</p><p>本互联网草案完全符合BCP 78和BCP 79的规定。¶</p><p> Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at   https://datatracker.ietf.org/drafts/current/. ¶</p><p>互联网草案是互联网工程任务组（IETF）的工作文件。请注意，其他小组也可以将工作文件作为互联网草稿分发。目前互联网上的草稿列表位于https://datatracker.ietf.org/drafts/current/. ¶</p><p> Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#34;work in progress.&#34; ¶</p><p>互联网草案是有效期最长为六个月的文件草案，可随时由其他文件更新、替换或作废。不应将互联网草稿用作参考资料或引用as&#34以外的内容；工作正在进行中&#34; ¶</p><p> Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved. ¶</p><p>版权（C）2021 IETF信托和被认定为文件作者的人。版权所有。¶</p><p> This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (  https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License. ¶</p><p>本文件受BCP 78和IETF信托&#39的约束；s与IETF文件相关的法律规定（https://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文档中提取的代码组件必须包括简化的BSD许可证文本，如第4节所述。如简化BSD许可证所述，不提供任何担保。¶</p><p>  The robustness principle has been hugely influential in shaping the design ofthe Internet. As stated in IAB RFC 1958  [ PRINCIPLES], the robustnessprinciple advises to: ¶</p><p>稳健性原则对互联网的设计有着巨大的影响。正如IAB RFC 1958[原则]所述，稳健原则建议：</p><p> Be strict when sending and tolerant when receiving. Implementations must follow specifications precisely when sending to the network, and tolerate faulty input from the network. When in doubt, discard faulty input silently, without returning an error message unless this is required by the specification. ¶</p><p>发送时要严格，接收时要宽容。在发送到网络时，实现必须严格遵循规范，并容忍来自网络的错误输入。当有疑问时，无提示地放弃错误输入，而不返回错误消息，除非规范要求这样做。¶</p><p> This simple statement captures a significant concept in the design ofinteroperable systems. Many consider the application of the robustnessprinciple to be instrumental in the success of the Internet as well as thedesign of interoperable protocols in general. ¶</p><p>这个简单的陈述抓住了互操作系统设计中的一个重要概念。许多人认为，应用RoistNeNess原则，有助于互联网的成功，以及一般的互操作协议的设计。¶</p><p> Time and experience shows that negative consequences to interoperabilityaccumulate over time if implementations apply the robustness principle. Thisproblem originates from an assumption implicit in the principle that it is notpossible to affect change in a system the size of the Internet. That is, theidea that once a protocol specification is published, changes that might requireexisting implementations to change are not feasible. ¶</p><p>时间和经验表明，如果实现应用健壮性原则，那么对互操作性的负面影响会随着时间的推移而累积。这个问题源于一个隐含在原则中的假设，即不可能影响互联网规模的系统的变化。也就是说，一旦协议规范发布，可能需要现有实现才能更改的更改是不可行的。¶</p><p> Many problems that might lead to applications of the robustness principle areavoided for protocols under active maintenance. Active protocol maintenance iswhere a community of protocol designers, implementers, and deployers worktogether to continuously improve and evolve protocol specifications alongsideimplementations and deployments of those protocols. A community that takes anactive role in the maintenance of protocols can greatly reduce and eveneliminate opportunities to apply the robustness principle. ¶</p><p>对于处于主动维护状态的协议，许多可能导致应用健壮性原则的问题都是无效的。主动协议维护是指协议设计者、实施者和部署者共同努力，在这些协议的实施和部署过程中不断改进和发展协议规范。在协议维护中扮演积极角色的社区可以大大减少甚至消除应用健壮性原则的机会。¶</p><p> There is good evidence to suggest that many important protocols are routinelymaintained beyond their inception. In particular, a sizeable proportion of IETFactivity is dedicated to the stewardship of existing protocols. This documentserves primarily as a record of the hazards inherent in applying the robustnessprinciple and to offer an alternative strategy for handling interoperabilityproblems in deployments. ¶</p><p>有很好的证据表明，许多重要的协议都是在其初始阶段之后常规维护的。尤其是，相当大一部分IETFactivity致力于现有协议的管理。本文件主要用于记录应用稳健性原则所固有的危害，并为处理部署中的互操作性问题提供替代策略。¶</p><p> Ideally, protocol implementations never have to apply the robustness principle.Or, where it is unavoidable, use of the robustness principle is viewed as ashort term workaround that needs to be quickly reverted. ¶</p><p>理想情况下，协议实现永远不必应用健壮性原则。或者，在不可避免的情况下，稳健性原则的使用被视为一种需要迅速恢复的短期变通方法。¶</p><p> The context from which the robustness principle was developed provides valuableinsights into its intent and purpose. The earliest form of the principle in theRFC series (in RFC 760  [ IP]) is preceded by a sentence that revealsthe motivation for the principle: ¶</p><p>稳健性原则产生的背景为其意图和目的提供了有价值的见解。theRFC系列（在RFC 760[IP]中）中，原则的最早形式前面有一句话，揭示了原则的动机：</p><p> While the goal of this specification is to be explicit about the protocol there is the possibility of differing interpretations. In general, an implementation should be conservative in its sending behavior, and liberal in its receiving behavior. ¶</p><p>虽然本规范的目标是明确协议，但可能存在不同的解释。一般来说，实现在发送行为上应该是保守的，在接收行为上应该是自由的。¶</p><p> This formulation of the principle expressly recognizes the possibility that thespecification could be imperfect. This contextualizes the principle in animportant way. ¶</p><p>该原则的这种表述明确承认了该规范可能不完善的可能性。这以一种重要的方式将该原则置于语境中。¶</p><p> An imperfect specification is natural, largely because it is more important toproceed to implementation and deployment than it is to perfect a specification.A protocol, like any complex system, benefits greatly from experience with itsuse. A deployed protocol is immeasurably more useful than a perfect protocol.The robustness principle is a tool that is suited to early phases of systemdesign. ¶</p><p>不完美的规范是很自然的，主要是因为需要实现和部署比完善规范更重要。与任何复杂系统一样，协议也从其使用经验中受益匪浅。部署的协议比完美的协议有用得多。稳健性原则是一种适用于系统设计早期阶段的工具。¶</p><p> As  [ SUCCESS] demonstrates, success or failure of a protocol dependsfar more on factors like usefulness than on on technical excellence. Timelypublication of protocol specifications, even with the potential for flaws,likely contributed significantly to the eventual success of the Internet. ¶</p><p>正如[成功]所表明的，协议的成功或失败更多地取决于有用性等因素，而不是技术上的卓越性。协议规范的及时发布，即使可能存在缺陷，也可能对互联网的最终成功做出重大贡献。¶</p><p> The problem is therefore not with the premise, but with its conclusion: therobustness principle itself. ¶</p><p>因此，问题不在于前提，而在于结论：公正原则本身。¶</p><p> The application of the robustness principle to the early Internet, or any systemthat is in early phases of deployment, is expedient. Applying the principledefers the effort of dealing with interoperability problems, which prioritizesprogress. However, deferral can amplify the ultimate cost of handlinginteroperability problems. ¶</p><p>将稳健性原则应用于早期互联网或任何处于部署早期阶段的系统是有利的。应用这些原则可以促进处理互操作性问题的努力，这将优先发展。然而，延迟可能会放大处理互操作性问题的最终成本。¶</p><p> Divergent implementations of a specification emerge over time. When variationsoccur in the interpretation or expression of semantic components,implementations cease to be perfectly interoperable. ¶</p><p>随着时间的推移，规范的不同实现会出现。当语义组件的解释或表达发生变化时，实现就不再具有完美的互操作性。¶</p><p> Implementation bugs are often identified as the cause of variation, though it isoften a combination of factors. Application of a protocol to uses that were notanticipated in the original design, or ambiguities and errors in thespecification are often confounding factors. Disagreements on theinterpretation of specifications should be expected over the lifetime of aprotocol. ¶</p><p>实现缺陷通常被认为是导致变化的原因，尽管它是多种因素的组合。将协议应用于原始设计中未提及的用途，或规范中的歧义和错误通常是混淆因素。在阿普罗托考的使用期限内，对说明书的解释可能会出现分歧。¶</p><p> Even with the best intentions, the pressure to interoperate can be significant.No implementation can hope to avoid having to trade correctness forinteroperability indefinitely. ¶</p><p>即使出于最好的意图，互操作的压力也可能很大。任何实现都无法避免无限制地用正确性换取互操作性。¶</p><p> An implementation that reacts to variations in the manner recommended in therobustness principle sets up a feedback cycle. Over time: ¶</p><p>以稳健原则中建议的方式对变化做出反应的实施会建立一个反馈周期。随着时间的推移：</p><p> Implementations progressively add logic to constrain how data is transmitted,or to permit variations in what is received. ¶</p><p>实现逐步添加逻辑，以限制数据的传输方式，或允许接收内容发生变化。¶</p><p> A flaw can become entrenched as a de facto standard. Any implementation of theprotocol is required to replicate the aberrant behavior, or it is notinteroperable. This is both a consequence of applying the robustness principle,and a product of a natural reluctance to avoid fatal error conditions. Ensuringinteroperability in this environment is often referred to as aiming to be &#34;bugfor bug compatible&#34;. ¶</p><p>缺陷可以成为事实标准。协议的任何实现都需要复制异常行为，否则无法互操作。这既是应用稳健性原则的结果，也是避免致命错误条件的自然不情愿的产物。确保这种环境中的互操作性通常被称为目标是&#34；bugfor bug兼容&#34；。¶</p><p> For example, in TLS  [ TLS] extensions use a tag-length-value format,and they can be added to messages in any order. However, some serverimplementations terminate connections if they encounter a TLS ClientHellomessage that ends with an empty extension. To maintain interoperability, clientimplementations are required to be aware of this bug and ensure that aClientHello message ends in a non-empty extension. ¶</p><p>例如，在TLS[TLS]中，扩展使用标记长度值格式，可以按任何顺序将它们添加到消息中。但是，如果某些服务器实现遇到以空扩展名结尾的TLS ClientHellomessage，则会终止连接。为了保持互操作性，客户端实现需要注意这个错误，并确保aClientHello消息以非空扩展结尾。¶</p><p> The original JSON specification  [ JSON] demonstrates the effect ofspecification shortcomings. RFC 4627 omitted critical details on a range of keydetails including Unicode handling, ordering and duplication of object members,and number encoding. Consequently, a range of interpretations were used byimplementations. An updated specification  [ JSON-BIS] did not correctthese errors, concentrating instead on identifying the interoperable subset ofJSON. I-JSON  [ I-JSON] takes that subset and defines a new formatthat prohibits the problematic parts of JSON. Of course, that means that I-JSONis not fully interoperable with JSON. Consequently, I-JSON is not widelyimplemented in parsers. Many JSON parsers now implement the more precisealgorithm specified in  [ ECMA262]. ¶</p><p>最初的JSON规范[JSON]演示了规范缺陷的影响。RFC 4627省略了一系列关键细节，包括Unicode处理、对象成员的排序和复制，以及数字编码。因此，实现使用了一系列解释。更新后的规范[JSON-BIS]没有纠正这些错误，而是专注于识别JSON的可互操作子集。I-JSON[I-JSON]获取该子集，并定义一种新格式，禁止JSON中有问题的部分。当然，这意味着I-jsoni不能与JSON完全互操作。因此，I-JSON并没有在解析器中广泛实现。许多JSON解析器现在实现了[ECMA262]中指定的更精确的算法。¶</p><p> The robustness principle therefore encourages a reaction that can createinteroperability problems. In particular, the application of the robustnessprinciple is particularly deleterious for early implementations of new protocolsas quirks in early implementations can affect all subsequent deployments. ¶</p><p>因此，稳健性原则鼓励人们做出可能导致互操作性问题的反应。尤其是，应用健壮性原则对新协议的早期实现尤其有害，因为早期实现中的怪癖可能会影响所有后续部署。¶</p><p> Once deviations become entrenched, it can be extremely difficult - if notimpossible - to rectify the situation. ¶</p><p>一旦偏差根深蒂固，纠正这种情况可能极其困难——如果不是不可能的话。¶</p><p> Interoperability requirements for protocol implementations are set by otherdeployments. Specifications and - where they exist - conformance test suitesmight guide the initial development of implementations, but implementationsultimately need to interoperate with deployed implementations. ¶</p><p>协议实施的互操作性要求由其他部署设置。规范和一致性测试套件（如果有）可以指导实现的初始开发，但实现结果需要与已部署的实现进行互操作。¶</p><p> For widely used protocols, the massive scale of the Internet makes large-scaleinteroperability testing infeasible for all but a privileged few. The cost ofbuilding a new implementation using reverse engineering increases as the numberof implementations and bugs increases. Worse, the set of tweaks necessary forwide interoperability can be difficult to discover. ¶</p><p>对于广泛使用的协议，互联网的巨大规模使得大规模的可互操作性测试对于除少数特权之外的所有人都不可行。随着实现数量和bug的增加，使用逆向工程构建新实现的成本也在增加。更糟糕的是，广泛的互操作性所需的一系列调整可能很难发现。¶</p><p> Consequently, new implementations might be forced into niche uses, where theproblems arising from interoperability issues can be more closely managed.However, restricting new implementations into limited deployments risks causingforks in the protocol. If implementations do not interoperate, little preventsthose implementations from diverging more over time. ¶</p><p>因此，新的实现可能会被迫进入小众应用领域，从而可以更紧密地管理互操作性问题带来的问题。然而，将新的实现限制在有限的部署中可能会导致协议中出现分叉。如果实现不能互操作，就很难防止这些实现随着时间的推移出现更多分歧。¶</p><p> This has a negative impact on the ecosystem of a protocol. New implementationsare important in ensuring the continued viability of a protocol. New protocolimplementations are also more likely to be developed for new and diverse usecases and often are the origin of features and capabilities that can be ofbenefit to existing users. ¶</p><p>这对议定书的生态系统有负面影响。新的实施对于确保协议的持续可行性非常重要。新的协议实现也更有可能针对新的和多样化的用例进行开发，并且通常是现有用户受益的特性和功能的来源。¶</p><p> The need to work around interoperability problems also reduces the ability ofestablished implementations to change. An accumulation of mitigations forinteroperability issues makes implementations more difficult to maintain and canconstrain extensibility (see also  [ USE-IT]). ¶</p><p>解决互操作性问题的需要也降低了已建立的实现进行更改的能力。针对互操作性问题的缓解措施的累积使得实现更难维护，并且无法训练可扩展性（另请参见[USE-IT]）。¶</p><p> Sometimes what appear to be interoperability problems are symptomatic of issuesin protocol design. A community that is willing to make changes to theprotocol, by revising or extending it, makes the protocol better in the process.Applying the robustness principle instead conceals problems, making it harder,or even impossible, to fix them later. ¶</p><p>有时，看似互操作性的问题是协议设计问题的症候。一个愿意通过修改或扩展协议来对协议进行修改的社区，可以在这个过程中使协议变得更好。相反，应用稳健性原则会隐藏问题，使得以后更难甚至不可能解决问题。¶</p><p> The robustness principle can be highly effective in safeguarding against flawsin the implementation of a protocol by peers. Especially when a specificationremains unchanged for an extended period of time, incentive to be tolerant oferrors accumulates over time. Indeed, when faced with divergent interpretationsof an immutable specification, the only way for an implementation to remaininteroperable is to be tolerant of differences in interpretation andimplementation errors. ¶</p><p>健壮性原则可以非常有效地防止对等方执行协议时出现缺陷。尤其是当一个规范在很长一段时间内保持不变时，容忍错误的动机会随着时间的推移而累积。事实上，当面对一个不变规范的不同解释时，实现保持可互操作性的唯一方法是容忍解释和实现错误的差异。¶</p><p> From this perspective, application of the robustness principle to theimplementation of a protocol specification that does not change is logical, evennecessary. But that conclusion relies on an assumption that existingspecifications and implementations are unable to change. Applying therobustness principle in this way disproportionately values short-term gains overthe negative effects on future implementations and the protocol as a whole. ¶</p><p>从这个角度来看，将健壮性原则应用于实现不变的协议规范是合乎逻辑的，甚至是必要的。但这一结论依赖于一个假设，即现有规范和实现无法更改。以这种方式应用鲁棒性原则，会不成比例地重视短期收益，而不是对未来实现和整个协议的负面影响。¶</p><p> For a protocol to have sustained viability, it is necessary for bothspecifications and implementations to be responsive to changes, in addition tohandling new and old problems that might arise over time. ¶</p><p>为了使协议具有持续的生存能力，除了处理随着时间的推移可能出现的新问题和旧问题外，规范和实现都必须对变化做出响应。¶</p><p> Maintaining specifications so that they closely match deployments ensures thatimplementations are consistently interoperable and removes needless barriers fornew implementations. Maintenance also enables continued improvement of theprotocol. New use cases are an indicator that the protocol could be successful [ SUCCESS]. ¶</p><p>维护规范，使其与部署紧密匹配，可以确保实现一致的互操作性，并为新实现消除不必要的障碍。维护还可以持续改进协议。新的用例是协议可能成功的一个指标。¶</p><p> Protocol designers are strongly encouraged to continue to maintain and evolveprotocol specificationss beyond their initial inception and definition. Thismight require the development of revised specifications, extensions, or othersupporting material that documents the current state of the protocol.Involvement of those who implement and deploy the protocol is a critical part ofthis process, as they provide input on their experience with how the protocol isused. ¶</p><p>强烈鼓励协议设计人员在最初的开始和定义之后继续维护和改进协议规范。这可能需要制定修订后的规范、扩展或其他支持材料，以记录协议的当前状态。实施和部署协议的人员的参与是这一过程的关键部分，因为他们提供了关于如何使用协议的经验的输入。¶</p><p> Most interoperability problems do not require revision of protocols or protocolspecifications. For instance, the most effective means of dealing with adefective implementation in a peer could be to email the developer responsible.It is far more efficient in the long term to fix one isolated bug than it is todeal with the consequences of workarounds. ¶</p><p>大多数互操作性问题不需要修改协议或协议规范。例如，在对等网络中处理有效实现的最有效方法可能是向负责的开发人员发送电子邮件。从长远来看，修复一个孤立的bug要比处理变通方法的后果有效得多。¶</p><p> Early implementations of protocols have a stronger obligation to closely followspecifications as their behavior will affect all subsequent implementations. Inaddition to specifications, later implementations will be guided by whatexisting deployments accept. Tolerance of errors in early deployments is mostlikely to result in problems. Protocol specifications might need more frequentrevision during early deployments to capture feedback from early rounds ofdeployment. ¶</p><p>协议的早期实现有更严格的义务严格遵守规范，因为它们的行为将影响所有后续实现。除了规范之外，以后的实现将以现有部署所接受的内容为指导。在早期部署中容忍错误最有可能导致问题。在早期部署期间，协议规范可能需要更频繁的修订，以获取早期部署的反馈。¶</p><p> Neglect can quickly produce the negative consequences this document describes.Restoring the protocol to a state where it can be maintained involves firstdiscovering the properties of the protocol as it is deployed, rather than theprotocol as it was originally documented. This can be difficult andtime-consuming, particularly if the protocol has a diverse set ofimplementations. Such a process was undertaken for HTTP  [ HTTP] aftera period of minimal maintenance. Restoring HTTP specifications to relevancetook significant effort. ¶</p><p>忽视会很快产生本文件所述的负面后果。将协议恢复到可以维护的状态需要首先在部署时发现协议的属性，而不是最初记录的协议。这可能既困难又耗时，尤其是当协议有多种实现时。在经过一段时间的最少维护后，HTTP[HTTP]就开始了这样一个过程。将HTTP规范恢复到relevancetook需要付出巨大的努力。¶</p><p> Maintenance is most effective if it is responsive, which is greatly affected byhow rapidly protocol changes can be deployed. For protocol deployments thatoperate on longer time scales, temporary workarounds following the spirit of therobustness principle might be necessary. If specifications can be updated morereadily than deployments, details of the workaround can be documented, includingthe desired form of the protocols once the need for workarounds no longer existsand plans for removing the workaround. ¶</p><p>如果维护是响应性的，那么它是最有效的，这在很大程度上受部署协议更改的速度的影响。对于在较长时间范围内运行的协议部署，可能需要遵循鲁棒性原则的精神采取临时解决办法。如果规范比部署更容易更新，则可以记录解决方案的详细信息，包括不再需要解决方案时所需的协议形式，以及删除解决方案的计划。¶</p><p> Good extensibility  [ EXT] can make it easier to respond to new usecases or changes in the environment in which the protocol is deployed. ¶</p><p>良好的可扩展性[EXT]可以更容易地响应协议部署环境中的新用例或更改。¶</p><p> The ability to extend a protocol is sometimes mistaken for an application of therobustness principle. After all, if one party wants to start using a newfeature before another party is prepared to receive it, it might be assumed thatthe receiving party is being tolerant of unexpected inputs. ¶</p><p>扩展协议的能力有时被误认为是应用了可靠性原则。毕竟，如果一方希望在另一方准备接收新功能之前就开始使用它，那么可能会假设接收方能够容忍意外的输入。¶</p><p> A well-designed extensibility mechanism establishes clear rules for the handlingof things like new messages or parameters. This depends on having clear rulesfor the handling of malformed or illegal inputs so that implementations behaveconsistently in all cases that might affect interoperation. If extensionmechanisms and error handling are designed and implemented correctly, newprotocol features can be deployed with confidence in the understanding of theeffect they have on existing implementations. ¶</p><p>设计良好的可扩展性机制为处理新消息或参数等事项建立了明确的规则。这取决于对格式错误或非法输入的处理有明确的规则，以便在所有可能影响互操作的情况下实现行为一致。如果扩展机制和错误处理被正确地设计和实现，那么新的协议特性就可以在理解它们对现有实现的影响的情况下进行部署。¶</p><p> In contrast, relying on implementations to consistently apply the robustnessprinciple is not a good strategy for extensibility. Using undocumented oraccidental features of a protocol as the basis of an extensibility mechanism canbe extremely difficult, as is demonstrated by the case study in   Appendix A.3 of [ EXT]. ¶</p><p>相比之下，依赖实现来一致地应用健壮性原则并不是一个好的可扩展性策略。如[EXT]附录a.3中的案例研究所示，使用协议的未记录或附带特性作为扩展机制的基础可能非常困难。¶</p><p> A protocol could be designed to permit a narrow set of valid inputs, or it couldallow a wide range of inputs as a core feature (see for example  [ HTML]).Specifying and implementing a more flexible protocol is more difficult; allowingless variability is preferable in the absence of strong reasons to be flexible. ¶</p><p>协议可以设计为允许一组有限的有效输入，也可以允许广泛的输入作为核心功能（例如参见[HTML]）。指定和实施更灵活的协议更加困难；在没有充分理由保持灵活性的情况下，无许可可变性更可取。¶</p><p> A well-specified protocol includes rules for consistent handling of aberrantconditions. This increases the chances that implementations will haveconsistent and interoperable handling of unusual conditions. ¶</p><p>明确规定的协议包括一致处理异常情况的规则。这增加了实现对异常情况进行一致且可互操作处理的可能性。¶</p><p> Intolerance of any deviation from specification, where implementations generatefatal errors in response to observing undefined or unusual behaviour, can beharnessed to reduce occurrences of aberrant implementations. Choosing togenerate fatal errors for unspecified conditions instead of attempting errorrecovery can ensure that faults receive attention. ¶</p><p>不容忍任何偏离规范的行为，在这种情况下，实现会因观察到未定义或异常的行为而产生默认错误，从而减少异常实现的发生。选择为未指定的条件生成致命错误，而不是尝试错误恢复，可以确保故障得到关注。¶</p><p> This improves feedback for new implementations in particular. When a newimplementation encounters a peer that is intolerant of an error, it receivesstrong feedback that allows the problem to be discovered quickly. ¶</p><p>这尤其改善了对新实现的反馈。当一个新的实现遇到一个不能容忍错误的对等方时，它会收到强烈的反馈，从而能够快速发现问题。¶</p><p> To be effective, intolerant implementations need to be sufficiently widelydeployed that they are encountered by new implementations with high probability.This could depend on multiple implementations deploying strict checks. ¶</p><p>为了有效，不容忍的实现需要得到足够广泛的部署，以使新的实现很可能遇到它们。这可能取决于部署严格检查的多个实现。¶</p><p> This does not mean that intolerance of errors in early deployments of protocolshave the effect of preventing interoperability. On the contrary, when existingimplementations follow clearly specified error handling, new implementations orfeatures can be introduced more readily as the effect on existingimplementations can be easily predicted; see also  Section 6. ¶</p><p>这并不意味着不容忍协议早期部署中的错误会影响互操作性。相反，当现有的实现遵循明确指定的错误处理时，新的实现或功能可以更容易地引入，因为对现有实现的影响可以很容易地预测；另见第6节。¶</p><p> Any intolerance also needs to be strongly supported by specifications, otherwisethey encourage fracturing of the protocol community or proliferation ofworkarounds; see  Section 8. ¶</p><p>任何不容忍也需要得到规范的有力支持，否则它们会导致协议社区的分裂或工作环境的扩散；见第8节。¶</p><p> Intolerance can be used to motivate compliance with any protocol requirement.For instance, the INADEQUATE_SECURITY error code and associated requirements inHTTP/2  [ HTTP2] resulted in improvements in the security of thedeployed base. ¶</p><p>不容忍可以用来激励遵守任何协议要求。例如，TTP/2[HTTP2]中的不充分的_安全错误代码和相关要求导致部署基地的安全性得到改善。¶</p><p> Any protocol participant that is affected by changes arising from maintenancemight be excluded if they are unwilling or unable to implement or deploy changesthat are made to the protocol. ¶</p><p>任何受维护引起的更改影响的协议参与者，如果他们不愿意或无法实施或部署对协议所做的更改，则可以将其排除在外。¶</p><p> Deliberate exclusion of problematic implementations is an important tool thatcan ensure that the interoperability of a protocol remains viable. Whilecompatible changes are always preferable to incompatible ones, it is not alwayspossible to produce a design that protects the ability of all current and futureprotocol participants to interoperate. Developing and deploying changes thatrisk exclusion of previously interoperating implementations requires some care,but changes to a protocol should not be blocked on the grounds of the risk ofexclusion alone. ¶</p><p>故意排除有问题的实现是一个重要工具，可以确保协议的互操作性仍然可行。尽管可兼容的更改总是比不兼容的更改更可取，但并不总是能够产生一种保护所有当前和未来协议参与者互操作能力的设计。开发和部署具有排除以前互操作实现风险的更改需要一定的谨慎，但不应仅以排除风险为由阻止对协议的更改。¶</p><p> Exclusion is a direct goal when choosing to be intolerant of errors (see Section 7). Exclusionary actions are employed with the deliberate intentof protecting future interoperability. ¶</p><p>当选择不容忍错误时，排除是一个直接目标（见第7节）。排他性行为是为了保护未来的互操作性而故意采取的。¶</p><p> Excluding implementations or deployments can lead to a fracturing of theprotocol system that could be more harmful than any divergence resulting fromfollowing the robustness principle. RFC 5704  [ UNCOORDINATED]describes how conflict or competition in the maintenance of protocols can leadto similar problems. ¶</p><p>排除实施或部署可能会导致协议系统崩溃，这可能比遵循健壮性原则导致的任何分歧更有害。RFC 5704[UNCOORDINATED]描述了协议维护中的冲突或竞争如何导致类似问题。¶</p><p> Sloppy implementations, lax interpretations of specifications, and uncoordinatedextrapolation of requirements to cover gaps in specification can result insecurity problems. Hiding the consequences of protocol variations encouragesthe hiding of issues, which can conceal bugs and make them difficult todiscover. ¶</p><p>草率的实现、对规范的松散解释，以及为弥补规范中的漏洞而对需求进行的不协调，都可能导致不安全问题。隐藏协议变化的后果会鼓励隐藏问题，这会隐藏错误并使其难以发现。¶</p><p> The consequences of the problems described in this document are especially acutefor any protocol where security depends on agreement about semantics of protocolelements. For ins</p><p>本文档中描述的问题的后果对于安全性依赖于协议元素语义一致性的任何协议来说都是特别严重的。对于ins</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/稳健性/">#稳健性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/协议/">#协议</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>