<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们的250k线Clojure Codebase之旅 Tour of our 250k line Clojure codebase</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Tour of our 250k line Clojure codebase<br/>我们的250k线Clojure Codebase之旅 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-04 03:25:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/eb9ae9b671cb6d82cf7081b95216a89e.png"><img src="http://img2.diglog.com/img/2021/6/eb9ae9b671cb6d82cf7081b95216a89e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At  Red Planet Labs we’ve been quietly developing a new kind of developer tool for many years. Our tool reduces the cost of building large-scale end-to-end applications by multiple orders of magnitude, and Clojure is a big reason why we’ve been able to tackle such an ambitious project with a small team.</p><p>在红色的行星实验室，我们已经悄悄地开发了多年的新型开发工具。我们的工具通过多个数量级来降低建立大型端到端应用的成本，而Clojure是我们能够用一支小型团队解决这样一个雄心勃勃的项目的重要原因。</p><p> Our codebase consists of 250k lines of Clojure split evenly between source and test code. It’s one of the largest Clojure codebases in the world. In this post I’ll give a tour of how we organize our code so a project of this size can be understood amongst a team, the development and testing techniques we use that leverage the unique qualities of Clojure, and an overview of the key libraries we use.</p><p> 我们的Codebase由250k行的Clojure在源和测试代码之间均匀分开。它是世界上最大的Clojure Codebase之一。在这篇文章中，我将参考我们如何组织我们的代码，因此可以在团队中，我们使用的开发和测试技术中可以理解这一规模的项目，从而利用Clojure的独特品质，以及关键库的概述我们用。</p><p>   One of the coolest parts of our codebase is the new general purpose language at its foundation. Though the semantics of the language are substantially different than Clojure, it’s defined entirely within Clojure using macros to express the differing behavior. It compiles directly to bytecode using the  ASM library. The rest of our system is built using both this language and vanilla Clojure, interoperating seamlessly.</p><p>   我们的Codebase的最酷部分之一是其基础的新通用语言。虽然语言的语义与Clojure的语义不同，但它在使用宏中完全在Clojure内定义，以表达不同的行为。它使用ASM库直接编译为字节码。我们的其余系统是使用这种语言和Vanilla Clojure建造的，无缝互操作。</p><p> One of the striking capabilities our language has that vanilla Clojure does not is  first-class continuations. The way in which our language expresses continuations makes it extremely good at async, parallel, and reactive programming. All of these are foundational to the large-scale distributed infrastructure we’re building.</p><p> 我们的语言的一个引人注目的能力，Vanilla Clojure并不是一流的持续。我们的语言表达持续的方式使其在异步，平行和无功规划中非常擅长。所有这些都是我们建造的大型分布式基础设施的基础。</p><p> That you can build an entirely new language with radically different semantics within Clojure demonstrates how powerful Clojure is. There’s a lot you get &#34;for free&#34; when building a language this way: lexing, parsing, datatypes, namespaces, immutable data structures, and the entire library ecosystem of Clojure and the JVM. Ultimately our new language  is Clojure since it’s defined within Clojure, so it benefits from seamless interoperability with both Clojure and the JVM.</p><p> 您可以在Clojure内使用完全不同的语义构建完全新的语言，证明了Clojure的强大程度。有很多你得到了很多＆＃34;免费＆＃34;在以这种方式构建语言时：LEXING，解析，数据类型，名称空间，不可变数据结构以及CLOJURE和JVM的整个库生态系统。最终，我们的新语言是Clojure，因为它在Clojure中定义，因此它与Clojure和JVM都有效益。</p><p> The vast majority of applications are not going to need to develop a full language like we have. But there are plenty of use cases where a focused DSL is appropriate, and we have examples of that too. The ability when using Clojure to customize how code itself is interpreted, via macros and meta-programming, is an incredibly powerful capability.</p><p> 绝大多数申请不需要像我们一样开发完整的语言。但是有很多用例子，其中聚焦的DSL是合适的，我们也有一个例子。使用Clojure进行自定义代码本身是如何解释的，通过宏和元编程，是一种令人难以置信的强大功能。</p><p>  Central to any codebase is the data that is created, managed, and manipulated. We find it’s imperative to carefully and clearly document the data flying around the system. At the same time, type or schema annotations add overhead so it’s important to be thoughtful and not overdo it.</p><p>  任何CodeBase的核心是创建，管理和操纵的数据。我们发现它必须仔细，并清楚地记录系统周围的数据。同时，类型或架构注释增加了开销，所以要进行体贴，而不是过度思考是很重要的。 </p><p> We use the  Schema library for defining datatypes within our codebase. It’s easy to use and we like the flexibility to define schema constraints beyond just types: e.g. arbitrary predicates, enums, and unions. Our codebase contains about 600 type definitions, most of which are annotated using Schema.</p><p>我们使用模式库来定义Codebase中的数据类型。它易于使用，我们喜欢灵活地定义超出类型的模式约束：例如任意谓词，枚举和工会。我们的Codebase包含大约600个类型的定义，其中大部分都是使用架构注释的。</p><p> Around Schema we have a helper called &#34;defrecord+&#34; which defines constructor functions which also perform validation (e.g. for type Foo it generates &#34;-&gt;valid-Foo&#34; and &#34;map-&gt;valid-Foo&#34;). These functions throw a descriptive exception if the schema check fails.</p><p> 围绕架构我们有一个叫做＆＃34; defrecord +＆＃34;它定义了也执行验证的构造函数（例如，它为其生成＆＃34;  - ＆gt;  - ＆gt;有效的 -  foo＆＃34;和＆＃34; map-＆gt;有效 -  foo＆＃34;）。如果架构检查失败，这些函数会抛出描述性异常。</p><p> There’s no static type checking in Clojure, and static type checks wouldn’t be able to check all the kinds of constraints we define using Schema anyway (e.g. the value of a number being within a certain range). We’ve found we only need to insert schema checking on either:</p><p> 在Clojure中没有静态类型检查，并且静态类型检查将无法检查我们使用架构定义的所有类型的约束（例如，数字在某个范围内的值）。我们发现我们只需要插入架构检查：</p><p> Construction of types, for which our auto-generated &#34;valid&#34; constructor functions remove all the ceremony. Detecting an error when creating a record is much better than when using it later on, as during creation you have the context needed to debug the problem.</p><p> 施工类型，我们的自动生成和＃34;有效＆＃34;构造函数功能删除所有仪式。在创建记录时检测到错误比在稍后使用时更好，如在创建期间，您就可以使用所需的上下文来调试问题。</p><p> We only occasionally annotate the types of function args and return values. We find instead that being consistent about how we name things is good enough for understanding the code. We do have about 500 assertions throughout our codebase, though these are generally about higher-level properties rather than simple type checks.</p><p> 我们偶尔只会注释函数args和返回值的类型。我们发现，始终如一，我们将如何命名为何种方式足以了解代码。我们在我们的代码库中有大约500个断言，但这些通常是关于更高级别的属性而不是简单类型的检查。</p><p> The approach we’ve taken for schema definition and enforcement is lightweight, comprehensive, and doesn’t get in our way. The lack of static typing in Clojure scares a lot of programmers who have never used Clojure, and all we can say is that with a little bit of thought in how you organize your code it’s not an issue at all. And doing things dynamically means we can enforce stronger constraints than possible with static type systems.</p><p> 我们采取了模式定义和实施的方法是重量轻，全面，并没有通过我们的方式。 Clojure中缺乏静态打字吓到了很多从未使用Clojure的程序员，我们可以说的只是在你组织你的代码中有一点思考，它根本不是一个问题。并动态做事意味着我们可以使用静态类型系统来强制执行更强大的限制。</p><p>  Our codebase exists in a single git repo with four modules to split up the implementation:</p><p>  我们的Codebase存在于单个Git repo中，具有四个模块来分割实现： </p><p> &#34;core&#34;, which contains the definition of our compiler and the corresponding abstractions for parallel programming</p><p>＆＃34;核心＆＃34;其中包含我们编译器的定义和并行编程的相应抽象</p><p> We use  Leiningen and  deps.edn for our build. The ability to specify local targets as dependencies in deps.edn files is key to our multi-module setup, and the basic organization of our source tree looks like:</p><p> 我们使用Leiningen和Deps.edn为我们的构建。将本地目标指定为Deps.edn文件中的依赖性的能力是我们的多模块设置的关键，我们的源树的基本组织如下所示：</p><p>    This setup lets us develop within any one of the modules and automatically see any source changes in the other modules without having to make explicit Maven dependencies.</p><p>    此设置允许我们在任何一个模块中开发，并自动查看其他模块中的任何源更改，而无需进行显式的Maven依赖项。</p><p> Loading the entire codebase for running tests or loading a REPL is pretty slow (largely from compilation of code using our custom language), so we use AOT compilation heavily to speed up development. Since we spend most of our time developing in “distributed”, we AOT compile “core” to speed things up.</p><p> 加载整个代码库进行运行测试或加载REPL非常慢（主要是从使用我们的自定义语言编译代码），因此我们使用AOT编译速度迅速启动。由于我们花费大部分时间在“分布式”中发展，我们将AOT编译“核心”来加速。</p><p>  Specter is a library we developed for supercharging our ability to work with data structures, especially nested and recursive data. Specter is based around the concept of “paths” into data structures, where a path can “navigate” to any number of values starting from the root of a data structure. The path can include traversals, views, and filters, and they’re deeply composable.</p><p>  幽灵是一个我们开发的库，用于加强我们使用数据结构的能力，尤其是嵌套和递归数据。幽灵基于“路径”的概念，进入数据结构，其中路径可以从数据结构的根目录“导航”到任意数量的值。路径可以包括遍历，视图和过滤器，并且它们非常可编译。</p><p> Our compiler compiles code into an abstract representation with a distinct record type for each kind of operation possible in our language. There are a variety of attributes every operation type must expose in a uniform way. For example, one of these attributes is “needed fields”, the fields in the closure of that operation that it requires to do its work. A typical way to express this polymorphic behavior would be to use an interface or protocol, like so:</p><p> 我们的编译器将代码编译为抽象表示，并为我们的语言中的每种操作都有不同的记录类型。每个操作类型都必须以统一的方式曝光各种属性。例如，其中一个属性是“需要的字段”，关闭该操作的字段需要执行它的工作。表达这种多态行为的典型方式是使用界面或协议，如下所示：</p><p>  The problem with this approach is it only covers querying. Some phases of our compiler must rewrite the fields throughout the abstract representation (e.g. uniquing vars to remove shadowing) and this protocol doesn’t support that. A (set-needed-fields [this fields] ) method could be added to this protocol, but that doesn’t cleanly fit data types which have a fixed number of input fields. It also doesn’t compose well for nested manipulation.</p><p>  这种方法的问题只是涵盖查询。我们的编译器的一些阶段必须在整个抽象表示中重写字段（例如，唯一定义删除阴影），此协议不支持该字段。 a（设置所需的字段[此字段]）方法可以添加到此协议中，但这并不清晰适合具有固定数量的输入字段的数据类型。它也没有很好地讨论嵌套操作。 </p><p> Instead, we use Specter’s &#34;protocol paths&#34; feature to organize the common attributes of our varying compiler types. Here’s an excerpt from our compiler:</p><p>相反，我们使用幽灵的＆＃34;协议路径＆＃34;组织不同编译器类型的公共属性的功能。这是我们编译器的摘录：</p><p> (defprotocolpath NeededFields  [ ] )   (defrecord + OperationInput    [fields : -  [ (s /pred opvar? ) ]     apply? : - Boolean     ] )   (defrecord + Invoke    [op    : -  (s /cond -pre  (s /pred opvar? ) IFn RFn )    input : - OperationInput ] )   (extend -protocolpath NeededFields Invoke    (multi -path  [: op opvar? ]  [: input : fields ALL ] ) )   (defrecord + VarAnnotation    [var : -  (s /pred opvar? )    options : -  {s /Keyword Object } ] )   (extend -protocolpath NeededFields VarAnnotation   : var )   (defrecord + Producer    [producer : -  (s /cond -pre  (s /pred opvar? ) PFn ) ] )   (extend -protocolpath NeededFields Producer    [: producer opvar? ] )</p><p> （defprotocolpath所需的字段[]）（Defrecord + OperationInput [字段： -  [（s / predopopvar？）]应用？： -  boolean]）（defrecord +调用[op： - （s / cond -pre（s / pred opvar？ ）IFN RFN）输入： -  OperationInput]）（扩展-ProtocolPath所需的字段调用（Multi -Path [：Op Opvar？] [：输入：字段全部]））（Defrecord + Varannotation [var： - （s / predopvar？）选项： -  {s /关键字对象}]）（扩展-protocolpath所需字段SARANnotation：var）（Defrecord + Producer [Producer： - （S / Cond-Pre（S / Prep Opvar？）PFN））（扩展-ProtocolPath所需菲尔德生产者[：生产者OPVAR？]）</p><p> &#34;Invoke&#34;, for instance, is the type that represents calling another function. The :op field could be a static function or a var reference to a function in the closure. The other path navigates to all the fields used as arguments to the function invocation.</p><p> ＆＃34;例如，Invoke＆＃34;，例如表示调用另一个函数的类型。 ：OP字段可能是静态功能或对闭包中的函数的VAR引用。另一条路径导航到用作函数调用的所有字段。</p><p> This structure is extremely flexible and allows for modifications to be expressed just as easily as queries by integrating directly with Specter. For instance, we can append a &#34;-foo&#34; suffix to all the needed fields in a sequence of operations like so:</p><p> 这种结构非常灵活，允许通过直接与幽灵集成来表达疑问的修改。例如，我们可以附加A＆＃34; --foo＆＃34;在一系列操作中的所有所需字段的后缀如此：</p><p>  If we want the unique set of fields used in a sequence of ops, the code is:</p><p>  如果我们希望在一系列OPS中使用的独特字段，则代码是：</p><p>  Protocol paths are a way to make the data itself polymorphic and able to integrate with the supercharged abilities of Specter. They greatly reduce the number of manipulation helper functions that would be required otherwise and make the codebase far more comprehensible.</p><p>  协议路径是使数据本身多态性并且能够与幽灵的增压能力集成的方式。它们大大减少了否则所需的操作辅助功能的数量，并使CodeBase更加可理解。</p><p>  The daemons comprising the distributed system we’re building are comprised of dozens of subsystems that build on top of one another and depend on each other. The subsystems need to be started in a particular order, and in tests they must be torn down in a particular order. Additionally, within tests we need the ability to inject mocks for some subsystems or disable some subsystems altogether.</p><p>  包括我们构建的分布式系统的守护进程由数十个子系统组成，这些子系统彼此构建并彼此依赖。子系统需要以特定顺序启动，并且在测试中，必须以特定的顺序撕下。此外，在测试中，我们需要能够为某些子系统注入模型或完全禁用某些子系统。 </p><p> We use the  Component library to organize our subsystems in a way that manages lifecycle and gives us the flexibility to inject alternate dependencies or disable subsystems. Internally, we built a &#34;defrcomponent&#34; helper to unify field and dependency declarations. For example, from our codebase:</p><p>我们使用组件库以管理生命周期的方式组织我们的子系统，并为我们提供重新注入替代依赖项或禁用子系统的灵活性。在内部，我们建造了一个＆＃34; defrcomponent＆＃34;帮助统一领域和依赖声明。例如，来自我们的codebase：</p><p>  This automatically retrieves fields &#34;metastore&#34;, &#34;service-handler&#34;, and &#34;cluster-retriever&#34; from the system map it’s started in and makes them available in the closure of the component’s implementation. It expects one field &#34;port&#34; in the constructor of the component, and it generates another field &#34;jetty-instance&#34; on startup into its internal closure.</p><p>  这会自动检索字段＆＃34;转移和＃34 ;,＆＃34;服务处理程序＆＃34;和＃34;集群 - 猎犬＆＃34;从系统映射开始，它已启动并使其在关闭组件的实现中可用。它期望一个字段＆＃34;端口＆＃34;在组件的构造函数中，它生成另一个字段＆＃34; jetty-instance＆＃34;启动进入其内部关闭。</p><p> We also extended the component lifecycle paradigm with &#34;start-async&#34; and &#34;stop-async&#34; protocol methods. Some components do part of their initialization/teardown on other threads, and it was important for the rest of our system (especially deterministic simulation, described below) for those to be doable in a non-blocking way.</p><p> 我们还将组件生命周期范例扩展为＆＃34; start-async＆＃34;和＃34; stop-async＆＃34;协议方法。某些组件在其他线程上执行部分初始化/拆除，对我们的其余系统（特别是确定性模拟，下面描述的）对于那些以非阻塞方式进行可行而重要。</p><p> Our test infrastructure builds upon Component for doing dependency injection. For instance, from our test code:</p><p> 我们的测试基础架构在组件上构建了依赖注入。例如，来自我们的测试代码：</p><p>  That first map is a dependency injection map, and this code disables the “ticker” component. The “ticker” causes simulation tests to advance time occasionally, and since this test wants to control time explicitly it disables it. That dependency injection map can be used to override or disable any component in the system, providing the flexibility necessary for writing tests.</p><p>  第一个映射是依赖注入映射，此代码禁用“Ticker”组件。 “股票机”导致仿真测试偶尔推进时间，并且由于该测试想要明确控制时间它禁用它。该依赖注入地图可用于覆盖或禁用系统中的任何组件，提供写入测试所需的灵活性。</p><p>  Clojure provides the macro &#34;with-redefs&#34; that can redefine any function executed within the scope of that form, including on other threads. We have found this to be an invaluable feature for writing tests.</p><p>  Clojure提供宏＆＃34;有重复的＆＃34;这可以重新定义在该形式范围内执行的任何功能，包括其他线程。我们发现这是写作测试的宝贵功能。</p><p> Sometimes we use with-redefs to mock specific behavior in the dependencies of what we’re testing so we can test that functionality in isolation. Other times we use it to inject failures to test fault-tolerance.</p><p> 有时，我们将在我们测试的依赖关系中使用 - 重新使用来模拟特定的行为，以便我们可以在隔离中测试该功能。其他时候我们使用它来注入故障以测试容错。 </p><p> The most interesting usage of with-redefs in our codebase, and one of our most common, is using it alongside no-op functions we insert into our source code. These functions effectively provide a structured event log that can be dynamically tapped in an à la carte way depending on what a test is interested in.</p><p>在我们的代码库中最有趣的是重定码以及我们最常见的最常见的使用情况，它与我们插入我们的源代码的无op函数一起使用它。这些功能有效地提供了一个结构化事件日志，可以根据测试对其感兴趣的方式动态挖掘。</p><p> Here’s one example (out of hundreds in our codebase) of how we use this pattern. One part of our system executes user-specified work in a distributed way and needs to: 1) retry the work if it fails, and 2) checkpoint its progress to a durable, replicated store after a threshold amount of work has succeeded. One of the tests for this injects a failure the first time work is attempted and then verifies the system retries the work.</p><p> 这是我们使用此模式的一个示例（在我们的代码库中的数百个）。我们的系统的一个部分以分布式方式执行用户指定的工作，需要：1）如果失败，则重试工作，并且2）在阈值工作成功后检查到持久的复制商店的进度。尝试第一次工作的测试失败的测试之一，然后验证系统重试工作。</p><p> The source function that executes the work is called &#34;process-data!&#34;, and here is an excerpt from that function:</p><p> 执行工作的源函数被称为＃34;进程数据！＆＃34;，这里是摘录的摘录：</p><p>  In a totally separate function called &#34;checkpoint-state!&#34;, the no-op function &#34;durable-state-checkpointed&#34; is called after it finishes replicating and writing to disk the progress information. In our test code, we have:</p><p>  在一个完全单独的函数中，称为＃34;检查点 - 状态！＆＃34;，no-op函数＆＃34;持久状态检查点和＃34;在完成复制和写入磁盘的进度信息之后被调用。在我们的测试代码中，我们有：</p><p> ( deftest retry -user -work -simulated -integration -test    ( let  [checkpoints      (volatile !  0 )         retry -successes  (volatile !  0 ) ]      (with -redefs  [manager /durable -state -checkpointed                    ( fn  [ ]  (vswap ! checkpoints  inc ) )                    manager /retry -succeeded                    ( fn  [ ]  (vswap ! retry -successes  inc ) ) ]        ...        ) ) )</p><p> （排放重试 - 用户 - 工作 - 致催化 - 最终（让[检查点（Volatile！0）重试 -  uccesses（Volatile！0）]（使用-ReDefs [Manager / idured -State -CheckPointed（FN []（vswap！ CheckPoints Inc）））Manager / Retry -Succeeded（FN []（vswap！Retry -successes inc））] ...）））</p><p> Then in the body of the test, we check the correct internal events happen at the correct moments.</p><p> 然后在测试的正文中，我们检查正确的时刻发生正确的内部事件。</p><p> Best of all, since this à la carte event log approach is based on no-op functions, it adds basically no overhead when the code runs in production. We have found this approach to be an incredibly powerful testing technique that utilizes Clojure’s design in a unique way.</p><p> 最重要的是，由于这种点菜事件日志方法基于No-Op功能，因此在生产中运行时，它基本没有开销。我们发现这种方法是一种令人难以置信的强大的测试技术，以独特的方式利用Clojure的设计。 </p><p>  We have about 400 macros defined through our codebase, 70% of which are part of source code and 30% of which are for test code only. We have found the common advice for macros, like don’t use a macro when you can use a function, to be wise guidance. That we have 400 macros doing things you can’t do with regular functions demonstrates the extent to which we make abstractions that go far beyond what you can do with a typical language that doesn’t have a powerful macro system.</p><p>我们有大约400个通过我们的代码库定义的宏，其中70％是源代码的一部分，其中30％仅用于测试代码。我们已经找到了宏的常见建议，就像使用函数时不要使用宏，以明智的指导。我们有400个宏，做你不能做的事情，你不能用常规函数演示我们制作抽象的程度远远超出您可以使用没有强大宏系统的典型语言。</p><p> About 100 of our macros are simple &#34;with-&#34; style macros which open a resource at the start and ensure the resource is cleaned up when the form exits. We use these macros for things like managing file lifecycles, managing log levels, scoping configurations, and managing complex system lifecycles.</p><p> 我们约100只宏观是简单的＆＃34;与 - ＆＃34;在开始时打开资源的样式宏并确保在表单退出时清除资源。我们使用这些宏进行管理文件生命周期，管理日志级别，范围配置和管理复杂系统生命周期。</p><p> About 60 of our macros define abstractions of our custom language. In all of these the interpretation of the forms within is different than vanilla Clojure.</p><p> 我们大约60个宏定义了自定义语言的抽象。在所有这些中，在内部的形式的解释与香草克洛库不同。</p><p> Many of our macros are utility macros, like &#34;letlocals&#34; which lets us more easily mix variable binding with side effects. We use it heavily in test code like so:</p><p> 我们的许多宏都是Utility Macros，喜欢＆＃34; Letlocals＆＃34;这让我们更容易与副作用混合变化。我们在测试代码中使用它很大，如下所示：</p><p> (letlocals    (bind a  (mk -a -thing ) )    (do -something ! a )    (bind b  (mk -another -thing ) )    (is  ( =  (foo b )  (bar a ) ) ) )</p><p> （LetLocals（绑定一个（mk -a -thing））（do -something！a）（bind b（mk-anthoththing））（是（=（foo b）（bar a））））））</p><p>   The rest of the macros are a mix of internal abstractions, like a state machine DSL we built, and various idiosyncratic implementation details where the macro removes code duplication that can’t be removed otherwise.</p><p>   其余的宏是内部抽象的混合，如我们构建的状态机DSL，以及各种特殊的实现细节，其中宏删除无法删除的代码复制。</p><p> Macros are a language feature that can be abused to produce terribly confusing code, or they can be leveraged to produce fantastically elegant code. Like anything else in software development, the result you end up with is determined by the skill of those using it. At Red Planet Labs we can’t imagine building software systems without macros in our toolbox.</p><p> 宏是一种语言功能，可以滥用来产生非常令人困惑的代码，或者可以利用它们以产生奇妙优雅的代码。就像软件开发中的任何其他东西一样，您最终结束的结果由使用它的人的技能决定。在红色行星实验室，我们无法想象在我们的工具箱中没有宏的构建软件系统。 </p><p>  As  we wrote about previously, we have the ability to write 100% reproducible distributed systems tests by running our whole system on a single thread and randomizing the order in which entities execute events starting from a random seed. Simulation is a major, codebase-spanning capability that heavily utilizes the aforementioned techniques of dependency injection and redefs. For example:</p><p>正如我们之前写的那样，我们通过在单个线程上运行我们的整个系统并随机化从随机种子开始执行事件的顺序来编写100％可重复的分布式系统测试。仿真是一种主要的码级跨越能力，其大量利用上述依赖性注入和重复性的技术。例如：</p><p> Any part of the system that in production would be a unique thread is coded in terms of  executor services. To get an executor service for that particular part of the system, it requests one from an &#34;executor service factory&#34;. In production, this returns new threads. In simulation, however, we override that component to provide executor services from our single-threaded, globally managed source.</p><p> 在生产中的系统的任何部分都是唯一的线程在执行者服务方面被编码。要为系统的该特定部分获得执行者服务，它请求来自AN＆＃34;执行者服务工厂＆＃34;在生产中，这将返回新的线程。但是，在仿真中，我们覆盖该组件从我们的单线程全局管理源提供执行者服务。</p><p> Much of our system relies on time (e.g. timeouts), so time is abstracted away from our implementation. Any part of the system that is interested in time consults a &#34;time source&#34; dependency. In production this is the system clock, but in simulation the component is overridden with a &#34;simulated time source&#34; that can be explicitly controlled within our simulation tests.</p><p> 我们的大部分系统都依赖于时间（例如，超时），因此时间从我们的实施中抽象出来。对时间感兴趣的系统的任何部分咨询A＆＃34;时间来源＆＃34;依赖。在生产中，这是系统时钟，但在模拟中，组件被A＆＃34覆盖;模拟时间源＆＃34;可以在我们的模拟测试中明确控制。</p><p> Promises are used quite a bit throughout the codebase to manage asynchronous, non-blocking behavior. Simulation uses with-redefs to layer in additionally functionality into promises useful for stepping through simulation.</p><p> 承诺在整个CodeBase中使用相当多的位置来管理异步，非阻塞行为。仿真用与重定款到图层的额外功能进入有用用于踩下模拟的承诺。</p><p>  Our product provides a UI to let users see what they have running on a cluster, the current status of operations like scaling, and telemetry showing what’s going on in their applications.</p><p>  我们的产品提供了一个UI，让用户了解它们在群集中运行的内容，以及缩放等操作的当前状态，以及遥测，显示其应用程序发生了什么。</p><p> The front end is a web-based single page app coded in ClojureScript. The ClojureScript ecosystem has many mature, well-designed libraries that make development efficient and fun.</p><p> 前端是在CLOJUSERCRIPT中编码的基于Web的单页应用程序。 Clojurescript生态系统有许多成熟，精心设计的图书馆，使开发有效和乐趣。</p><p> Reviewing the libraries and their advantages could be a blog post in itself, but briefly: we use  re-frame because its data-oriented state management and event handling models are easy to reason about and inspect. We use  reitit for frontend routing; we like how its data-oriented design allows us to associate arbitrary data with each route, which in turn lets us do neat things like dispatch re-frame events on route changes. We use  shadow-cljs to compile the project, in part because it dramatically simplifies the process of using JavaScript libraries and dealing with externs.</p><p> 审查图书馆及其优势可能是一个博客文章本身，但简要介绍：我们使用重新框架，因为它的数据导向状态管理和事件处理模型很容易理解和检查。我们使用reitit for frontend路由;我们喜欢其数据导向的设计如何使我们能够将任意数据与每个路线相关联，这反过来让我们在路线更改上的调度重新框架事件中进行整洁的事物。我们使用Shadow-CLJS编译项目，部分原因是它大大简化了使用JavaScript库和处理外部的过程。 </p><p> We use  uPlot for displaying time-series data. Our API backend is served using a  Jetty server, and we use  Compojure to define backend routes.</p><p>我们使用UPLOT来显示时间序列数据。我们的API后端使用Jetty Server提供服务，我们使用Compojure来定义后端路由。</p><p> Defining our front end in the same language as the rest of our codebase is a huge win, especially the ease of shuttling data back and forth between Clojure and ClojureScript. The immutable style emphasized by Clojure is just as beneficial in front-end code as back-end code, so being able to leverage that consistently benefits our productivity and the robustness of our product greatly.</p><p> 定义我们的前端与我们的代码库的其余部分具有相同的语言，尤其是在Clojure和Clojurescript之间来回穿梭数据的易用性。 Clojure强调的不可变形的风格与前端代码中的前端代码一样有益，因此能够利用始终如一地利用我们产品的生产力和强大的稳健性。</p><p>  Here are many of the external libraries we use in our codebase, a mixture of Clojure, ClojureScript, Java, and Javascript libraries:</p><p>  以下是我们在Codebase中使用的许多外部库，Clojure，Clojurescript，Java和JavaScript库的混合：</p><p>  Clojure has been fantastic for developing our product. It’s enabled us to build powerful abstractions not possible in other languages, remove all ceremony whatsoever, and utilize powerful testing techniques. Plus we’ve had multiple members on our team start with no Clojure or functional programming experience and they were able to get up to speed quickly.</p><p>  Clojure是开发产品的奇妙。它使我们能够以其他语言构建不可能的强大抽象，删除所有仪式，并利用强大的测试技术。此外，我们在我们的团队中有多个成员开始，没有Clojure或功能规划体验，他们能够快速加快速度。</p><p> If you’re interested in working with us to help define the future of software development,  we’re hiring! We work on hard problems pushing what’s possible with compilers, databases, and distributed systems. Our team is  fully distributed and we’re open to hiring anywhere in the world.</p><p> 如果您有兴趣与我们合作帮助定义软件开发的未来，我们正在招聘！我们努力努力使用编译器，数据库和分布式系统推动可能的事情。我们的团队完全分发，我们正在开放招聘世界上的任何地方。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tech.redplanetlabs.com/2021/06/03/tour-of-our-250k-line-clojure-codebase/">https://tech.redplanetlabs.com/2021/06/03/tour-of-our-250k-line-clojure-codebase/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/clojure/">#clojure</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>