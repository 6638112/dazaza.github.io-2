<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可视化垃圾收集器算法[2014] Visualizing Garbage Collector Algorithms[2014]</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Visualizing Garbage Collector Algorithms[2014]<br/>可视化垃圾收集器算法[2014] </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-10 15:22:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/123cc48c1a0403cf923fea8b15f35e4c.gif"><img src="http://img2.diglog.com/img/2021/5/123cc48c1a0403cf923fea8b15f35e4c.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Most developers take automatic garbage collection for granted. It’s just another amazing feature provided by our language run-times to make our jobs easier.</p><p>大多数开发人员授予自动垃圾收集。这只是我们的语言运行时间提供的另一个惊人的功能，使我们的工作更轻松。</p><p>  But if you try to peek inside a modern garbage collector, it’s very difficult to see how they actually work. There are thousands of implementation details that will confuse you unless you already have a good understanding of what it’s trying to do and how they can go fantastically wrong.</p><p>  但如果你试图在现代垃圾收集器里偷看，那么很难看出他们实际工作的工作。除非您已经对尝试做的事情有所了解以及如何奇妙地了解，否则有成千上万的实施细节会困惑。</p><p>  I’ve built a toy with five different garbage collection algorithms. Small animations were created from the run-time behavior. You can find larger animations and the code to create them at  github.com/kenfox/gc-viz. It surprised me how much a simple animation reveals about these important algorithms.</p><p>  我建造了一个有五个不同的垃圾收集算法的玩具。从运行时行为创建小动画。您可以在Github.com/kenfox/gc-viz找到更大的动画和代码以在github.com/kenfox/gc-viz中创建它们。这让我惊讶了一个简单的动画揭示了这些重要的算法。</p><p>    The simplest possible way of cleaning up garbage is to just wait until a task is done and dispose of everything at once. This is a surprisingly useful technique, especially if you have a way of breaking up a task into pieces. The Apache web server, for example, creates a small pool of memory per request and throws the entire pool away when the request completes.</p><p>    清理垃圾的最简单可能的方式是等到任务完成并立即处理所有事情。这是一个令人惊讶的有用技术，特别是如果您有办法将任务分解成碎片。例如，Apache Web服务器每个请求创建一小部分内存池，并在请求完成时将整个池抛出。</p><p>  The small animation to the right represents a running program. The entire image represents the program’s memory. Memory starts out colored black, which means it isn’t used. Areas that flash bright green or yellow are memory reads or writes. The color decays over time so you can see how memory was used, but also see current activity. If you watch carefully, you can see patterns emerge where the program begins to ignore some memory. Those areas have become garbage — they are not used and not reachable by the program. Everything else that isn’t garbage is “live”.</p><p>  右侧的小动画代表了一个正在运行的程序。整个图像代表程序的内存。记忆开始彩色黑色，这意味着它不使用。闪光亮绿色或黄色的区域是内存读取或写入。随着时间的推移，颜色衰减，因此您可以看到如何使用内存，但也看到了当前活动。如果您仔细观察，您可以看到模式出现的模式开始忽略一些内存。这些地区已成为垃圾 - 它们未被使用而无法通过该计划访问。其他不是垃圾的东西是“生活”。</p><p>  The program easily fits in memory without needing to worry about cleaning up garbage while the program is running. I’m going to stick with this simple program for the rest of the examples.</p><p>  该程序容易符合内存，而无需担心程序运行时清理垃圾。我将在剩下的例子中坚持这个简单的程序。</p><p>    Another simple solution is to keep a count of how many times you are using a resource (an object in memory, in this case) and dispose of it when the count drops to zero. This is the most common technique that developers use when they add garbage collection to an existing system —it’s the only garbage collector that easily integrates with other resource managers and existing code bases. Apple learned this lesson after releasing a mark-sweep collector for Objective-C. It caused so many problems that they retracted the feature and replaced it with an automated reference counting collector that works much better with existing code.</p><p>    另一个简单的解决方案是保留您使用资源（在内存中的对象，在这种情况下的对象）的计数，并且当计数下降到零时将其处置。这是开发人员在将垃圾收集添加到现有系统时使用的最常用技术 - 这是唯一与其他资源管理器和现有代码基础集成的唯一垃圾收集器。苹果在释放Mark-Sweep收集器以获得目标-C后，Apple学到了本课程。它引起了许多问题，它们缩回了该功能并用自动参考计数收集器替换它，与现有代码更好地工作。 </p><p>  The animation shows the same program as above, but this time it will try to dispose of garbage by keeping a reference count on each object in memory. The red flashes indicate reference counting activity. A very useful property of reference counting is that garbage is detected as soon as possible — you can sometimes see a flash of red immediately followed by the area turning black.</p><p>动画显示相同的程序，如上所述，但这一次它将通过在内存中的每个对象上保持引用计数来尝试处理垃圾。红色闪烁表示参考计数活动。一个非常有用的参考计数属性是尽快检测到垃圾 - 您有时可以看到一闪红的红色，然后立即关闭区域。</p><p>  Unfortunately reference counting has a lot of problems. Worst of all, it can’t handle cyclic structures. These are very common — anything with a parent or reverse reference creates a cycle which will leak memory. Reference counting also has very high overhead — you can see in the animation that red flashes are constantly happening even when memory use is not increasing. Arithmetic is fast on a modern  CPU, but memory is slow, and the counters are being loaded and saved to memory often. All these counter updates also make it difficult to have read-only or thread-safe data.</p><p>  不幸的是，参考算有很多问题。最糟糕的是，它无法处理循环结构。这些非常常见 - 具有父级或反向引用的任何内容都会创建一个泄漏内存的循环。参考计数也具有很高的开销 - 您可以在动画中看到，即使内存使用不断增加，也可以在动画中不断发生。算法在现代CPU上快速，但内存缓慢，并且次数正在加载并经常保存到内存中。所有这些计数器更新也使得难以具有只读或线程安全数据。</p><p>  Reference counting is an amortized algorithm (the overhead is spread over the run-time of the program), but it’s an accidentally amortized algorithm that can’t guarantee response times. For example, say a program is working with a very large tree structure. The last piece of the program that uses the tree will trigger the disposal of the entire tree, which Murphy will guarantee happens when the user least desires the delay. None of the other algorithms here are amortized either though, so accidentally amortized may be a feature depending on your data. (All of these algorithms do have concurrent or partially-concurrent variations, but those are beyond the capabilities of my toy program to demonstrate.)</p><p>  参考计数是摊销算法（开销在程序的运行时间上传播），但它是一种意外摊销的算法，不能保证响应时间。例如，假设一个程序正在使用非常大的树结构。使用树的最后一块程序将触发整个树的处理，当用户最不希望延迟时，墨菲将保证。这里的其他算法都没有摊销，因此，因此意外摊销可能是根据您的数据的特征。 （所有这些算法确实都有并发或部分并发变体，但这些算法超出了我玩具程序的能力来证明。）</p><p>    Mark-sweep eliminates some of the problems of reference count. It can easily handle cyclic structures and it has lower overhead since it doesn’t need to maintain counts.</p><p>    标记扫描消除了一些参考数数问题。它可以轻松处理循环结构，并且它具有较低的开销，因为它不需要维持计数。</p><p>  It gives up being able to detect garbage immediately. You can see that in the animation where there’s a period of activity without any red flashes, then suddenly a bunch of red flashes indicate where it is marking live objects. After marking is finished, it sweeps over all of memory and disposes of garbage. You can see that in the animation too — several areas turn black all at once instead of more spread out over time in the reference counting approach.</p><p>  它放弃了能够立即检测垃圾。您可以在动画中看到有一段时间没有任何红色闪烁的活动，那么突然一堆红色闪光指示它标记实时对象的位置。标记完成后，它会扫过所有内存并处置垃圾。您可以在动画中看到它太多 - 几个区域一次转动黑色，而不是在参考计数方法中随时间播放。</p><p>  Mark-sweep requires more implementation consistency than reference counting and is more difficult to retrofit into existing systems. The mark phase requires being able to traverse all live data, even data encapsulated within an object. If an object doesn’t provide traversal, it’s probably too risky to attempt to retrofit mark-sweep into the code. The other weakness of mark-sweep is the fact the sweep phase must sweep over all of memory to find garbage. For systems that do not generate much garbage, this is not an issue, but modern functional programming style generates enormous amounts of garbage.</p><p>  标记扫描需要更多的实现一致性而不是参考计数，并且更难以改装到现有系统中。标记阶段需要遍历所有实时数据，甚至封装在对象中的数据。如果对象没有提供遍历，则尝试将标记扫描到代码中可能过于危险。标记扫描的其他弱点是事实，扫描阶段必须扫过所有内存以找到垃圾。对于不产生大量垃圾的系统，这不是一个问题，但现代功能规划风格产生了大量的垃圾。</p><p>    One thing you may have noticed in the previous animations is that objects never move. Once an object is allocated in memory, it stays in the same place even if memory turns into a fragmented sea of islands surrounded by black. The next two algorithms change that, but with completely different approaches.</p><p>    在上一动画中可能注意到的一件事是对象永远不会移动。一旦对象被分配在内存中，即使记忆变成黑色围绕着黑色的岛屿的分散的海洋，它也处于同一个位置。接下来的两个算法改变了，但具有完全不同的方法。 </p><p>  Mark-compact disposes of memory, not by just marking it free, but by moving objects down into the free space. Objects always stay in the same memory order — an object allocated before another object will always be lower in memory — but gaps caused by disposed objects will be closed up by objects moving down.</p><p>标记紧凑的内存处理，而不是通过自由标记，而是通过将物体移动到自由空间中。对象始终保持在相同的内存顺序 - 在另一个对象之前分配的对象将始终在内存中较低 - 但是由设置的对象导致的差距将被移动向下关闭。</p><p>  The crazy idea of moving objects means that new objects can always just be created at the end of used memory. This is called a “bump” allocator and is as cheap as stack allocation, but without the limitations of stack size. Some systems using bump allocators don’t even use call stacks for data storage, they just allocate call frames in the heap and treat them like any other object.</p><p>  移动对象的疯狂思想意味着始终可以在旧的内存结束时创建新对象。这被称为“凹凸”分配器，并且与堆栈分配一样便宜，但没有堆栈大小的局限性。一些使用Bump分配器的系统甚至没有使用呼叫堆栈进行数据存储，它们只需在堆中分配呼叫帧并像任何其他对象一样对待它们。</p><p>  Another benefit, sometimes more theory than practice, is that when objects are compacted like this, programs have better memory access patterns that are friendly to modern hardware memory caches. It’s far from certain you will see this benefit, though — the memory allocators used in reference counting and mark-sweep are complex, but also very well debugged and very efficient.</p><p>  另一个好处，有时比实践更多的理论，就是当物体被压缩时，程序具有更好的内存访问模式，友好到现代硬件存储器缓存。尽管如此，它远远甚至可以看到这种好处 - 参考计数和标记扫描中使用的内存分配器是复杂的，但也很好地调试和非常高效。</p><p>  Mark-compact is a complex algorithm requiring several passes over all allocated objects. In the animation you can see the red flashes of live object marking followed by lots of reads and writes as destinations are computed, objects are moved and finally references are fixed to point to where objects have moved. The main benefit of all this complexity is operating under extremely low memory overhead. Oracle’s Hotspot  JVM uses several different garbage collection algorithms. The tenured object space uses mark-compact.</p><p>  Mark-Compact是一种复杂的算法，需要多次通过所有分配的对象。在动画中，您可以看到Live对象标记的红色闪烁，然后读取许多读写，因为计算目的地，因此移动对象，最后引用是指向对象移动的位置。所有这些复杂性的主要好处是在极低的内存开销下运行。 Oracle的热点JVM使用几种不同的垃圾收集算法。终身物体空间使用标记紧凑。</p><p>    The last algorithm I’ve animated is the foundation of most high-performance garbage collection systems. It’s a moving collector like mark-compact, but it’s incredibly simple. It uses two memory spaces and simply copies live objects back and forth between them. In practice, there are more than two spaces and the spaces are used for different generations of objects. New objects are created in one space, get copied to another space if they survive, and finally copied to a tenured space if they are very long-lived. If you hear a garbage collector described as generational or ephemeral, it’s usually a multi-space copy collector.</p><p>    我动画的最后一次算法是大多数高性能垃圾收集系统的基础。这是一个动作的收集器，如标记紧凑，但它非常简单。它使用两个内存空间，并在它们之间来回复制活对象。在实践中，有两个以上的空间，并且空间用于不同几代物体。新对象是在一个空格中创建的，如果他们生存，将复制到另一个空间，并且如果它们非常长期以来，最终会复制到职业空间。如果您听到垃圾收集器被描述为世代或短暂的，它通常是多空间复制收集器。</p><p>  Other than simplicity and flexibility, the main advantage of this algorithm is that it only spends time on live objects. There is no separate mark phase that must be later swept or compacted. Objects are immediately copied during live object traversal, and object references are patched up by following a broken-heart reference where the object used to be.</p><p>  除了简单和灵活性之外，该算法的主要优点是它仅在实时对象上花费时间。没有单独的标记阶段必须稍后扫除或压缩。在实时对象遍历期间立即复制对象，并且通过遵循常用的对象，通过遵循常见的心脏引用来修补对象引用。</p><p>  In the animation, you can see there are several collections where almost all the data is copied from one space to the other. This is a terrible situation for this algorithm and shows one of the reasons why people talk about tuning garbage collectors. If you can size your memory and tune your allocations so that most objects are dead when the collection begins, then you get a fantastic combination of safe functional programming style and high performance.</p><p>  在动画中，您可以看到有几个集合，几乎所有数据都将从一个空间复制到另一个空间。这是这种算法的可怕情况，并显示了人们谈论调整垃圾收集器的原因之一。如果您可以进行尺寸，并调整您的分配，以便在收集开始时大多数物体都死了，那么您可以获得安全功能性编程风格和高性能的奇妙组合。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可视化/">#可视化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/垃圾/">#垃圾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/garbage/">#garbage</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>