<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C#原始字符串文字提案C# Raw String Literal Proposal</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C# Raw String Literal Proposal<br/>C#原始字符串文字提案</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 01:11:59</div><div class="page_narrow text-break page_content"><p>Allow a new form of string literal that starts with a minimum of three  &#34;&#34;&#34; characters (but no maximum), optionally followed by a  new_line, the content of the string, and then ends with the same number of quotes that the literal started with. For example:</p><p>允许一种新形式的字符串文字，以最少三个&#34开头&#34;&#34; 字符（但没有最大值），可选地后跟新的_行，即字符串的内容，然后以与文本开头相同数量的引号结尾。例如：</p><p>  Because the nested contents might itself want to use  &#34;&#34;&#34; then the starting/ending delimiters can be longer like so:</p><p>因为嵌套内容本身可能希望使用&#34&#34;&#34; 然后开始/结束分隔符可以更长，如下所示：</p><p>  To make the text easy to read and allow for indentation that developers like in code, these string literals will naturally remove the indentation specified on the last line when producing the final literal value. For example, a literal of the form:</p><p>为了使文本易于阅读，并允许开发人员喜欢在代码中使用缩进，这些字符串文字在生成最终文字值时会自然删除最后一行中指定的缩进。例如，形式的文字：</p><p>    This allows code to look natural, while still producing literals that are desired, and avoiding runtime costs if this required the use of specialized string manipulation routines.</p><p>这使得代码看起来很自然，同时仍能生成所需的文本，如果需要使用专门的字符串操作例程，还可以避免运行时成本。</p><p> If the indentation behavior is not desired, it is also trivial to disable like so:</p><p>如果不需要缩进行为，那么也可以这样禁用：</p><p>  A single line form is also supported. It starts with a minimum of three  &#34;&#34;&#34; characters (but no maximum), the content of the string (which cannot contain any  new_line characters), and then ends with the same number of quotes that the literal started with. For example:</p><p>还支持单行表单。它从最少三个开始&#34&#34;&#34; 字符（但没有最大值），字符串的内容（不能包含任何新的_行字符），然后以与文本开头相同数量的引号结尾。例如：</p><p>  Interpolated raw strings are also supported. In this case, the string specifies the number of braces needed to start an interpolation (determined by the number of dollar signs present at the start of the literal). Any brace sequence with fewer braces than that is just treated as content. For example:</p><p>还支持插值原始字符串。在本例中，字符串指定开始插值所需的大括号数（由文本开头的美元符号数决定）。任何大括号少于该大括号的大括号序列都被视为内容。例如：</p><p>   C# lacks a general way to create simple string literals that can contain effectively any arbitrary text. All C# string literal forms today need some form of escaping in case the contents use some special character (always if a delimiter is used). This prevents easily having literals containing other languages in them (for example, an XML, HTML or JSON literal).</p><p>C#缺乏一种通用的方法来创建简单的字符串文字，这些文字可以有效地包含任意文本。现在所有C#字符串文字形式都需要某种形式的转义，以防内容使用某些特殊字符（如果使用分隔符，则始终如此）。这可以防止文本中包含其他语言（例如，XML、HTML或JSON文本）。</p><p> All current approaches to form these literals in C# today always force the user to manually escape the contents. Editing at that point can be highly annoying as the escaping cannot be avoided and must be dealt with whenever it arises in the contents. This is particularly painful for regexes, especially when they contain quotes or backslashes. Even with a  @&#34;&#34; string, quotes themselves must be escaped leading to a mix of C# and regex interspersed.  { and  } are similarly frustrating in  $&#34;&#34; strings.</p><p>目前所有在C#中形成这些文字的方法都会迫使用户手动转义内容。在这一点上编辑可能会非常烦人，因为转义是不可避免的，必须在内容中出现时处理。这对正则表达式来说尤其痛苦，尤其是当它们包含引号或反斜杠时。即使是34岁&#&#34; 字符串、引号本身必须转义，导致C#和正则表达式的混合。{和}在$&#34中同样令人沮丧&#34; 串。</p><p> The crux of the problem is that all our strings have a fixed start/end delimiter. As long as that is the case, we will always have to have an escaping mechanism as the string contents may need to specify that end delimiter in their contents. This is particularly problematic as that delimiter  &#34; is exceedingly common in many languages.</p><p>问题的关键是我们所有的字符串都有一个固定的开始/结束分隔符。在这种情况下，我们总是需要一个转义机制，因为字符串内容可能需要在其内容中指定结束分隔符。这是特别有问题的，因为分隔符#34；在许多语言中非常普遍。</p><p> To address this, this proposal allows for flexible start and end delimiters so that they can always be made in a way that will not conflict with the content of the string.</p><p>为了解决这个问题，这个建议允许使用灵活的开始和结束分隔符，以便它们总是以一种不会与字符串内容冲突的方式生成。</p><p>  Provide a mechanism that will allow  all string values to be provided by the user without the need for  any escape-sequences whatsoever. Because all strings must be representable without escape-sequences, it must always be possible for the user to specify delimiters that will be guaranteed to not collide with any text contents.</p><p>提供一种机制，允许用户提供所有字符串值，而不需要任何转义序列。因为所有字符串都必须是无转义序列的可表示字符串，所以用户必须始终能够指定分隔符，以确保不会与任何文本内容冲突。</p><p> Support interpolations in the same fashion. As above, because  all strings must be representable without escapes, it must always be possible for the user to specify an  interpolation delimiter that will be guaranteed to not collide with any text contents. Importantly, languages that use our  interpolation delimiter characters ( { and  }) should feel first-class and not painful to use.</p><p>以相同的方式支持插值。如上所述，由于所有字符串都必须是不带转义符的可表示字符串，因此用户必须始终能够指定一个插值分隔符，以确保不会与任何文本内容发生冲突。重要的是，使用插值分隔符（{和}）的语言应该是一流的，而且使用起来不会很痛苦。</p><p> Multiline string literals should look pleasant in code and should not make indentation within the compilation unit look strange. Importantly, literal values that themselves have no indentation should not be forced to occupy the first column of the file as that can break up the flow of code and will look unaligned with the rest of the code that surrounds it. This behavior should be easy to override while keeping literals clear and easy to read.</p><p>多行字符串文字在代码中应该看起来令人愉快，并且不应该使编译单元中的缩进看起来奇怪。重要的是，本身没有缩进的文本值不应该被强制占据文件的第一列，因为这可能会中断代码流，并且看起来与围绕它的其余代码不一致。这种行为应该易于重写，同时保持文字清晰易读。</p><p> For all strings that do not themselves contain a  new_line or start or end with a quote ( &#34;) character, it should be possible to represent the string literal itself on a single line. Optionally, with extra complexity, we could refine this to state that: For all strings that do not themselves contain a  new_line (but can start or end with a quote  &#34; character), it should be possible to represent the string literal itself on a single line. For more details see the expanded proposal in the  Drawbacks section.</p><p>对于本身不包含新行或以引号（&#34；）开头或结尾的所有字符串字符，应该可以在一行中表示字符串文字本身。此外，我们还可以通过额外的复杂度对其进行细化，以说明：对于所有本身不包含新行（但可以以引号开头或结尾&#34；字符）的字符串，应该可以在一行上表示字符串文字本身。有关更多详细信息，请参阅“缺点”部分中的扩展提案。</p><p>   string_literal : regular_string_literal | verbatim_string_literal | raw_string_literal ;raw_string_literal : single_line_raw_string_literal | multi_line_raw_string_literal ;raw_string_literal_delimiter : &#34;&#34;&#34; | &#34;&#34;&#34;&#34; | &#34;&#34;&#34;&#34;&#34; | etc. ;raw_content : not_new_line+ ;single_line_raw_string_literal : raw_string_literal_delimiter raw_content raw_string_literal_delimiter ;multi_line_raw_string_literal : raw_string_literal_delimiter whitespace* new_line (raw_content | new_line)* new_line whitespace* raw_string_literal_delimiter ;not_new_line : &lt;any unicode character that is not new_line&gt; ;</p><p>string_literal:regular_string_literal | verbatim_string_literal | raw_string_literal；原始字符串文字：单行原始字符串文字；多行原始字符串文字；原始字符串文字分隔符：&#34&#34;&#34; | &#34;&#34;&#34;&#34; | &#34;&#34;&#34;&#34;&#34; | 等原始内容：非新行+；单行原始字符串文字：原始字符串文字分隔符原始内容原始字符串文字分隔符；多行_原始_字符串_文字：原始_字符串_文字_分隔符空格*新行（原始_内容|新行）*新行空格*原始_字符串_文字_分隔符；非新行：&lt；任何非新的unicode字符；</p><p> The ending delimiter to a  raw_string_literal must match the starting delimiter. So if the starting delimiter is  &#34;&#34;&#34;&#34;&#34; the ending delimiter must be that as well.</p><p>原始字符串文字的结束分隔符必须与起始分隔符匹配。如果起始分隔符是&#34&#34;&#34;&#34;&#34; 结尾分隔符也必须是该分隔符。</p><p>  It then continues with contents on the same line as the starting quotes. These contents on the same line can be blank, or non-blank. &#39;blank&#39; is synonymous with &#39;entirely whitespace&#39;.</p><p>然后，它将继续使用与起始引号位于同一行的内容。同一行中的这些内容可以是空白的，也可以是非空白的&#39;空白和#39；是&#39的同义词；完全是空白；。</p><p> If the contents on that same line is non-blank no further content can follow. In other words the literal is required to end with the same number of quotes on that same line.</p><p>如果同一行的内容为非空，则不能再添加其他内容。换句话说，要求文本在同一行上以相同数量的引号结尾。</p><p> If the contents on the same line is blank, then the literal can continue with a  new_line and number of subsequent content lines and  new_lines. It then ends with a  new_line some number (possibly zero) of  whitespace and the same number of quotes that the literal started with.</p><p>如果同一行上的内容为空，则文字可以继续使用一个新的_行以及随后的多个内容行和新的_行。然后，它以一个新的_行结束，其中包含一定数量（可能为零）的空格和与文本开头相同数量的引号。</p><p>  The portions between the starting and ending  raw_string_literal_delimiter are used to form the value of the  raw_string_literal in the following fashion:</p><p>起始和结束的原始字符串文字分隔符之间的部分用于按以下方式形成原始字符串文字的值：</p><p> In the case of  single_line_raw_string_literal the value of the literal will exactly be the contents between the starting and ending  raw_string_literal_delimiter.</p><p>在单_行_原始_字符串_文本的情况下，文本的值正好是起始和结束原始_字符串_文本_分隔符之间的内容。</p><p> In the case of  multi_line_raw_string_literal the initial  whitespace* new_line and the final  new_line whitespace* is not part of the value of the string. However, the final  whitespace* portion preceding the  raw_string_literal_delimiter terminal is considered the &#39;indentation whitespace&#39; and will affect how the other lines are interpreted.</p><p>在多行原始字符串文本的情况下，初始空白*新行和最终新行空白*不是字符串值的一部分。然而，原始的_string _literal _分隔符终端前面的最后一个空格*部分被认为是&#39；缩进空格&#39；也会影响其他台词的解读。</p><p> To get the final value the sequence of  (raw_content | new_line)* is walked and the following is performed: If it a  new_line the content of the  new_line is added to the final string value.</p><p>要获得最终值，需要遍历（原始内容|新行）*序列，并执行以下操作：如果是新行，则新行的内容将添加到最终字符串值。</p><p> If it is not a &#39;blank&#39;  raw_content (i.e.  not_new_line+ contains a non- whitespace character): the &#39;indentation whitespace&#39; must be a prefix of the  raw_content. It is an error otherwise.</p><p>如果不是a&#39；空白和#39；原始内容（即not_new_line+包含非空白字符）：39；缩进空格&#39；必须是原始内容的前缀。否则就是一个错误。</p><p> the &#39;indentation whitespace&#39; is stripped from the start of  raw_content and the remainder is added to the final string value.</p><p>第&#39；缩进空格&#39；从原始内容的开头剥离，剩余部分添加到最终字符串值。</p><p> If it is a &#39;blank&#39;  raw_content (i.e.  not_new_line+ is entirely  whitespace): the &#39;indentation whitespace&#39; must be a prefix of the  raw_content or the  raw_content must be a prefix of of the &#39;indentation whitespace&#39;. It is an error otherwise.</p><p>如果是a&#39；空白和#39；原始内容（即非新行+完全是空白）：39；缩进空格&#39；必须是原始内容的前缀，或者原始内容必须是&#39的前缀；缩进空格&#39；。否则就是一个错误。</p><p> as much of the &#39;indentation whitespace&#39; is stripped from the start of  raw_content and any remainder is added to the final string value.</p><p>大部分&#39；缩进空格&#39；从原始内容的开头剥离，剩余部分添加到最终字符串值。</p><p>  A  single_line_raw_string_literal is not capable of representing a string with a  new_line value in it. A  single_line_raw_string_literal does not participate in the &#39;indentation whitespace&#39; trimming. Its value is always the exact characters between the starting and ending delimiters.</p><p>单个_line_raw_string_literal无法表示包含新行值的字符串。单个_行_原始_字符串_文字不参与&#39；缩进空格&#39；修剪。它的值始终是起始分隔符和结束分隔符之间的精确字符。</p><p> Because a  multi_line_raw_string_literal ignores the final  new_line of the last content line, the following represents a string with no starting  new_line and no terminating  new_line</p><p>由于多行\u原始\u字符串\u文本忽略最后一个内容行的最后一个新\u行，因此下面表示一个没有起始新行和终止新行的字符串</p><p>  This maintains symmetry with how the starting  new_line is ignored, and it also provides a uniform way to ensure the &#39;indentation whitespace&#39; can always be adjusted. To represent a string with a terminal  new_line an extra line must be provided like so:</p><p>这与忽略起始新线的方式保持了对称性，并提供了一种统一的方式来确保&#39；缩进空格&#39；可以随时调整。要用终端新行表示字符串，必须提供额外的一行，如下所示：</p><p>  A  single_line_raw_string_literal cannot represent a string value that starts or ends with a quote ( &#34;) though an augmentation to this proposal is provided in the  Drawbacks section that shows how that could be supported.</p><p>单个_行_原始_字符串_文字不能表示以引号（&#34；）开头或结尾的字符串值尽管缺陷部分提供了对该提案的补充，说明了如何支持该提案。</p><p> A  multi_line_raw_string_literal starts with  whitespace* new_line following the initial  raw_string_literal_delimiter. This content after the delimiter is entirely ignored and is not used in any way when determining the value of the string. This allows for a mechanism to specify a  raw_string_literal whose content starts with a  &#34; character itself. For example:</p><p>多行原始字符串文字以初始原始字符串文字分隔符后面的空格*新行开头。分隔符后面的内容将被完全忽略，并且在确定字符串的值时不会以任何方式使用。这允许一种机制来指定一个原始字符串，其内容以&#34开头；角色本身。例如：</p><p>  A  raw_string_literal can also represent content that end with a quote ( &#34;). This is supported as the terminating delimiter must be on its own line. For example:</p><p>原始字符串文字也可以表示以引号（&#34；）结尾的内容。这是受支持的，因为终止分隔符必须位于其自己的行上。例如：</p><p> var v1 = &#34;&#34;&#34; &#34;The content of this string starts and ends with a quote&#34; &#34;&#34;&#34;</p><p>var v1=&#34&#34;&#34; &#34;该字符串的内容以引号#34开头和结尾&#34;&#34;&#34;</p><p> var v1 = &#34;&#34;&#34; &#34;&#34;The content of this string starts and ends with two quotes&#34;&#34; &#34;&#34;&#34;</p><p>var v1=&#34&#34;&#34; &#34;&#34;该字符串的内容以两个引号开头和结尾&#34&#34; &#34;&#34;&#34;</p><p> The requirement that a &#39;blank&#39;  raw_content be either a prefix of the &#39;indentation whitespace&#39; or the &#39;indentation whitespace&#39; must be a prefix of it helps ensure confusing scenarios with mixed whitespace do not occur, especially as it would be unclear what should happen with that line. For example, the following case is illegal:</p><p>a&#39；空白和#39；原始内容可以是&#39的前缀；缩进空格&#39；或者&#39；缩进空格&#39；必须是它的前缀，这有助于确保不会出现混合空格的混乱场景，尤其是因为不清楚该行应该发生什么。例如，以下情况是非法的：</p><p>  Here the &#39;indentation whitespace&#39; is nine space characters, but the &#39;blank&#39;  raw_content does not start with a prefix of that. There is no clear answer as to how that  &lt;tab&gt; line should be treated at all. Should it be ignored? Should it be the same as  .........&lt;tab&gt;? As such, making it illegal seems the clearest for avoiding confusion.</p><p>这里是&#39；缩进空格&#39；是九个空格字符，但&#39；空白和#39；原始内容不以该前缀开头。至于这是怎么回事，目前还没有明确的答案&lt；选项卡&gt；这条线应该被处理。应该忽略它吗？应该和……一样吗&书信电报；tab&gt；？因此，为了避免混淆，将其定为非法似乎是最明确的。</p><p>   In both these cases, the &#39;indentation whitespace&#39; will be nine spaces. And in both cases, we will remove as much of that prefix as possible, leading the &#39;blank&#39;  raw_content in each case to be empty (not counting every  new_line). This allows users to not have to see and potentially fret about whitespace on these lines when they copy/paste or edit these lines.</p><p>在这两种情况下，&#39；缩进空格&#39；将有九个空间。在这两种情况下，我们将尽可能多地删除前缀，以&#39；空白和#39；每种情况下的原始内容都是空的（不包括每一行新内容）。这使得用户在复制/粘贴或编辑这些行时，不必看到这些行上的空白，也不必担心这些行上的空白。</p><p>   The &#39;indentation whitespace&#39; will still be nine spaces. Here though, we will remove as much of the &#39;indentation whitespace&#39; as possible, and the &#39;blank&#39;  raw_content will contribute a single space to the final content. This allows for cases where the content does need whitespace on these lines that should be preserved.</p><p>第&#39；缩进空格&#39；还是九个空间。不过，在这里，我们将删除尽可能多的&#39；缩进空格&#39；以及&#39；空白和#39；原始内容将为最终内容提供一个单独的空间。这允许在这些行中的内容确实需要保留空白的情况下使用。</p><p>   This is because the start of the raw string must have a  new_line (which is does) but the end must have a  new_line as well (which it does not). The minimal legal  raw_string_literal is:</p><p>这是因为原始字符串的开头必须有一个新的_行（它有），但结尾也必须有一个新的_行（它没有）。最小合法原始字符串文字为：</p><p>                                Interpolations in normal interpolated strings (e.g.  $&#34;...&#34;) are supported today through the use of the  { character to start an  interpolation and the use of an  {{ escape-sequence to insert an actual open brace character. Using this same mechanism would violate goals &#39;1&#39; and &#39;2&#39; of this proposal. Languages that have  { as a core character (examples being JavaScript, JSON, Regex, and even embedded C#) would now need escaping, undoing the purpose of raw string literals.</p><p>普通插值字符串中的插值（例如$&#34；…&#34；）现在通过使用{字符开始插值和使用{转义序列插入实际的大括号字符来支持。使用相同的机制将违反本提案的目标&#39；1&#39；和&#39；2&#39（例如JavaScript、JSON、正则表达式，甚至嵌入式C#）现在需要转义，从而取消了原始字符串文本的用途。</p><p> To support interpolations we introduce them in a different fashion than normal  $&#34; interpolated strings. Specifically, an  interpolated_raw_string_literal will start with some number of  $ characters. The count of these indicates how many  { (and  }) characters are needed in the content of the literal to delimit the  interpolation. Importantly, there continues to be no escaping mechanism for curly braces. Rather, just as with quotes ( &#34;) the literal itself can always ensure it specifies delimiters for the interpolations that are certain to not collide with any of the rest of the content of the string. For example a JSON literal containing interpolation holes can be written like so:</p><p>为了支持插值，我们以不同于普通$34的方式引入它们；插入字符串。具体来说，插值的_raw_string_literal将以一些$字符开始。这些字符的计数指示在文本内容中需要多少{（和}）字符来分隔插值。重要的是，卷发牙套仍然没有逃脱机制。相反，就像引用（&#34；）文本本身始终可以确保为插值指定分隔符，这些分隔符肯定不会与字符串的任何其他内容冲突。例如，包含插值孔的JSON文本可以这样写：</p><p>  Here, the  {{...}} matches the requisite count of two braces specified by the  $$ delimiter prefix. In the case of a single  $ that means the interpolation is specified just as  {...} as in normal interpolated string literals. Importantly, this means that an interpolated literal with  N  $ characters can have a sequence of  2*N-1 braces (of the same type in a row). The last  N braces will start (or end) an interpolation, and the remaining  N-1 braces will just be content. For example:</p><p>这里是{{…}匹配$$分隔符前缀指定的两个大括号的必要计数。在单个$的情况下，这意味着插值被指定为{…}与普通插值字符串文字一样。重要的是，这意味着带有N$个字符的插值文字可以有一个2*N-1大括号的序列（一行中的同一类型）。最后N个大括号将开始（或结束）插值，剩下的N-1个大括号将只是内容。例如：</p><p>  In this case the inner two  {{ and  }} braces belong to the interpolation, and the outer singular braces are just content. So the above string is equivalent to the content  X{2}Z. Having  2*N (or more) braces is always an error. To have longer sequences of braces as content, the number of  $ characters must be increased accordingly.</p><p>在这种情况下，内部的两个{和}}大括号属于插值，外部的奇异大括号只是内容。因此，上面的字符串相当于内容X{2}Z。使用2*N（或更多）大括号总是一个错误。要将较长的大括号序列作为内容，必须相应增加$字符的数量。</p><p>  interpolated_raw_string_literal : single_line_interpolated_raw_string_literal | multi_line_interpolated_raw_string_literal ;interpolated_raw_string_start : $ | $$ | $$$ | etc. ;interpolated_raw_string_literal_delimiter : interpolated_raw_string_start raw_string_literal_delimiter ;single_line_interpolated_raw_string_literal : interpolated_raw_string_literal_delimiter interpolated_raw_content raw_string_literal_delimiter ;multi_line_interpolated_raw_string_literal : interpolated_raw_string_literal_delimiter whitespace* new_line (interpolated_raw_content | new_line)* new_line whitespace* raw_string_literal_delimiter ;interpolated_raw_content : (not_new_line | raw_interpolation)+ ;raw_interpolation : raw_interpolation_start interpolation raw_interpolation_end ;raw_interpolation_start : { | {{ | {{{ | etc. ;raw_interpolation_end : } | }} | }}} | etc. ;</p><p>内插原始字符串文字：单行内插原始字符串文字；多行内插原始字符串文字；插入的_原始_字符串_开始：$|$$|$$$|等；内插原始字符串文字分隔符：内插原始字符串起始原始字符串文字分隔符；单行插入的原始字符串文字：插入的原始字符串文字分隔符插入的原始内容原始字符串文字分隔符；multi_line_interpolated_raw_string_literal:interpolated_raw_string_literal_分隔符空格*新行（interpolated_raw_content |新行）*新行空格*raw_string_literal_分隔符；插值的原始内容：（非新的线|原始插值）+；原始插值：原始插值开始插值原始插值结束；原始插值开始：{{{{{{{}等；原始插值结束：}}}}}}}等；</p><p> The above is similar to the definition of  raw_string_literal but with some important differences. A  interpolated_raw_string_literal should be interpreted as:</p><p>以上内容与原始字符串文字的定义类似，但有一些重要区别。插入的_原始_字符串_文字应解释为：</p><p> It starts with at least one dollar sign (but no upper bound) and then three quotes (also with no upper bound).</p><p>它从至少一个美元符号（但没有上限）开始，然后是三个引号（也没有上限）。</p><p> It then continues with content on the same line as the starting quotes. This content on the same line can be blank, or non-blank. &#39;blank&#39; is synonymous with &#39;entirely whitespace&#39;.</p><p>然后，它将继续使用与起始引号位于同一行的内容。同一行的内容可以是空白，也可以是非空白&#39;空白和#39；是&#39的同义词；完全是空白；。</p><p> If the content on that same line is non-blank no further content can follow. In other words the literal is required to end with the same number of quotes on that same line.</p><p>如果同一行的内容为非空，则不能再添加其他内容。换句话说，要求文本在同一行上以相同数量的引号结尾。</p><p> If the contents on the same line is blank, then the literal can continue with a  new_line and number of subsequent content lines and  new_lines. A content line can contain multiple  raw_interpolation occurrences at any position. The  raw_interpolation must start with an equal number of open braces ( {) as the number of dollar signs at the start of the literal.</p><p>如果同一行上的内容为空，则文字可以继续使用一个新的_行以及随后的多个内容行和新的_行。内容行可以在任何位置包含多个原始插值事件。原始_插值必须以相等数量的大括号（{）开始，作为文字开头的美元符号数。</p><p> The  raw_interpolation will following the normal rules specified at  §11.7.3. Any  raw_interpolation must end with the same number of close braces ( }) as dollar signs and open braces.</p><p>原始插值将遵循§11.7.3规定的正常规则。任何原始的_插值必须以与美元符号和开放大括号相同数量的闭大括号（}）结束。</p><p> Any  interpolation can itself contain new-lines within in the same manner as an  interpolation in a normal  verbatim_string_literal ( @&#34;&#34;).</p><p>任何插值本身都可以包含新行，其方式与普通逐字字符串文字（@&#34；&#34；）中的插值相同。</p><p> It then ends with a  new_line some number (possibly zero) of  whitespace and the same number of quotes that the literal started with.</p><p>然后，它以一个新的_行结束，其中包含一定数量（可能为零）的空格和与文本开头相同数量的引号。</p><p> Computation of the interpolated string value follows the same rules as a normal  raw_string_literal except updated to handle lines containing  raw_interpolations. Building the string value happens in the same fashion, just with the interpolation holes replaced with whatever values those expressions produce at runtime. If the  interpolated_raw_string_literal is converted to a  FormattableString then the values of the interpolations are passed in their respective order to the  arguments array to  FormattableString.Create. The rest of the content of the  interpolated_raw_string_literal  after the &#39;indentation whitespace&#39; has been stripped from all lines will be used to generate  format string passed to  FormattableString.Create, except with appropriately numbered  {N} contents in each location where a  raw_interpolation occurred (or  {N,constant} in the case if its  interpolation is of the form  expression &#39;,&#39; constant_expression).</p><p>插值字符串值的计算遵循与普通原始字符串文字相同的规则，但已更新以处理包含原始字符串插值的行。构建字符串值的方式也是一样的，只是将插值孔替换为这些表达式在运行时生成的任何值。如果插值的_raw_string_literal被转换为FormattableString，则插值的值将按各自的顺序传递给参数数组，以生成FormattableString。创造插入的_raw_string_literal在&#39之后的其余内容；缩进空格&#39；将用于生成传递给FormattableString的格式字符串。创建，除非在发生原始_插值的每个位置有适当编号的{N}内容（如果其插值形式为表达式&#39；，&#39；常量_表达式，则为{N，常量}）。</p><p> There is an ambiguity in the above specification. Specifically when a section of  { in text and  { of an interpolation abut. For example:</p><p>上述规范存在歧义。特别是当{文本中的{部分和{插值的{部分邻接时。例如：</p><p>  This could be interpreted as:  {{ {order_number } }} or  { {{order_number}} }. However, as the former is illegal (no C# expression could start with  {) it would be pointless to interpret that way. So we interpret in the latter fashion, where the innermost  { and  } braces form the interpolation, and any outermost ones form the text. In the future this might be an issue if the language ever supports any expressions that are surrounded by braces. However, in that case, the recommendation would be to write such a case like so:  {{({some_new_expression_form})}}. Here, parentheses would help designate the expression portion from the rest of the literal/interpolation. This has precedence already with how ternary conditional expressions need to be wrapped to not conflict with the formatting/alignment specifier of an interpolation (e.g.  {(x ? y : z)}).</p><p>这可以解释为：{{{order_number}}或{{{{order_number}}}。然而，由于前者是非法的（没有任何C#表达式可以以{开头），这样解释是没有意义的。所以我们用后一种方式解释，最里面的{和}大括号构成插值，最外面的大括号构成文本。将来，如果语言支持任何用大括号括起来的表达式，这可能会成为一个问题。然而，在这种情况下，建议写这样一个案例：{（{some_new_expression_form}}}。在这里，括号将有助于从文字/插值的其余部分指定表达式部分。这已经优先于三元条件表达式需要如何包装，以避免与插值的格式/对齐说明符冲突（例如{（x？y:z）}）。</p><p>   Raw string literals add more complexity to the language. We already have many string literal forms already for numerous purposes.  &#34;&#34; strings,  @&#34;&#34; strings, and  $&#34;&#34; strings already have a lot of power and flexibility. But they all lack a way to provide raw contents that never need escaping.</p><p>原始字符串文字增加了语言的复杂性。我们已经有了许多字符串文字形式，用于多种用途&#34;&#34; 字符串，@&#34&#34; 字符串和$&#34&#34; 弦已经有了很大的力量和灵活性。但它们都缺乏一种方式来提供不需要逃逸的原始内容。</p><p>  ... Optionally, with extra complexity, we could refine this to state that: For all strings that do not themselves contain a  new_line (but can start or end with a quote  &#34; character), it should be possible to represent the string literal itself on a single line.</p><p>... 此外，我们还可以通过额外的复杂度对其进行细化，以说明：对于所有本身不包含新行（但可以以引号开头或结尾&#34；字符）的字符串，应该可以在一行上表示字符串文字本身。</p><p> That&#39;s because we have no means to know that a starting or ending quote ( &#34;) should belong to the contents and not the delimiter itself. If this is an important scenario we want to support though, we can add a parallel  &#39;&#39;&#39; construct to go along with the  &#34;&#34;&#34; form. With that parallel construct, a single line string that start and ends with  &#34; can be written easily as  &#39;&#39;&#39;&#34;This string starts and ends with quotes&#34;&#39;&#39;&#39; along with the parallel construct  &#34;&#34;&#34;&#39;This string starts and ends with apostrophes&#39;&#34;&#34;&#34;. This may also be desirable to support to help visually separate out quote characters, which may help when embedding languages that primarily use one quote character much more than then other.</p><p>那&#39；因为我们没有办法知道开头或结尾的报价（&#34；）应该属于内容，而不是分隔符本身。如果这是我们想要支持的一个重要场景，我们可以添加一个并行的&#39&#39;&#39; 按照&#34进行施工&#34;&#34; 类型使用这种平行结构，一个以&#34开头和结尾的单行字符串；可以很容易地写成&#39&#39;&#39;&#34;该字符串以引号&#34开头和结尾&#39;&#39;&#39; 以及平行结构#34&#34;&#34;&#39;这个字符串以撇号开头和结尾&#39&#34;&#34;&#34;. 这可能也有助于支持从视觉上分离引号字符，这可能有助于嵌入主要使用一个引号字符而不是另一个引号字符的语言。</p><p>  https://github.com/dotnet/csharplang/discussions/89 covers many options here. Alternatives are numerous, but i feel stray too far into complexity and poor ergonomics. This approach opts for simplicity where you just keep increasing the start/end quote length until there is no concern about a conflict with the string contents. It also allows the code you write to look well indented, while still producing a dedented literal that is what most code wants.</p><p>https://github.com/dotnet/csharplang/discussions/89这里介绍了许多选项。替代品有很多，但我觉得太过复杂和糟糕的人体工程学。这种方法为简单起见，只需不断增加起始/结束引号长度，直到不担心与字符串内容冲突为止。它还允许您编写的代码看起来缩进良好，同时仍然生成大多数代码想要的dededented文本。</p><p> One of the most interesting potential variations though is the use of  ` (or  ```) fences for these raw string literals. This would have several benefits:</p><p>不过，最有趣的潜在变化之一是对这些原始字符串文本使用`（或```）围栏。这将有几个好处：</p><p> It would look familiar to markdown. Though that in itself is potentially not a good thing as users might expect markdown interpretation.</p><p>这对markdown来说很熟悉。尽管这本身可能不是一件好事，因为用户可能会期望降价解释。</p><p> A raw string literal would only have to start and end with a single character in most cases, and would only need multiple in the much rarer case of contents that contain back-ticks themselves.</p><p>在大多数情况下，原始字符串文字只需以单个字符开头和结尾，而在更罕见的包含回号的内容中，则只需要多个字符。</p><p> It would feel natural to extend this in the future with  ```xml, again akin to markdown. Though, of course, that is also true of the  &#34;&#34;&#34; form.</p><p>将来用`` xml扩展它会感觉很自然，这又类似于降价。当然，这也适用于&#34&#34;&#34; 类型</p><p> Overall though, the net benefit here seems small. In </p><p>但总的来说，这里的净收益似乎很小。在里面</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/原始/">#原始</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/raw/">#raw</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>