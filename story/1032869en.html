<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>快速反平方根</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">快速反平方根</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 06:56:47</div><div class="page_narrow text-break page_content"><p>The famous  fast inverse square root is some mysterious code  not written by programming legend John Carmack to calculate a fast approximation of $1/\sqrt{x}$:</p><p>著名的快速反平方根是一些神秘的代码，不是由编程传奇人物John Carmack编写的，用于计算$1/\sqrt{x}$的快速近似值：</p><p>  // Code from Quake 3 Arena. float Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) &amp;y // evil floating point bit level hacking i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck? y = * ( float * ) &amp;i y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration //	y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed return y; }</p><p>//来自地震3竞技场的代码。Float q_rsqrt(Float Number){long i；Float x2，y；Const Float Three Halfs=1.5F；x2=number*0.5F；y=number；i=*(long*)&amp；y//邪恶的浮点位级黑客攻击i=0x5f3759df-(i&&gt;；&&gt;1)；//他妈的是什么？Y=*(浮点*)&amp；i y=y*(Three Halfs-(x2*y*y))；//第一次迭代//y=y*(Three Halfs-(x2*y*y))；//第二次迭代，返回y；}。</p><p>  Games calculate square roots and inverse square roots all the time to find the lengths of vectors and  to normalise them, but using the   sqrt() function can be very slow. The code above finds an approximate result much more quickly through some integer magic. I was curious how it works but the  Wikipedia page describing it is  so badly written that it was easier to figure it out from scratch. Here&#39;s what I found.</p><p>游戏总是计算平方根和反平方根，以找到向量的长度并将其归一化，但是使用sqrt()函数可能非常慢。上面的代码通过一些整数魔术更快地找到近似结果。我很好奇它是如何工作的，但维基百科上描述它的页面写得太糟糕了，所以更容易从头开始弄清楚。这是我找到的东西。</p><p>   The code works by computing an initial approximation to $1/\sqrt{x}$ (which can also be written as $x^{-1/2}$) and then refining it using one or two iterations of  the Newton-Raphson method. If you aren&#39;t familiar with the Newton-Raphson method, don&#39;t worry - it isn&#39;t very complicated and also isn&#39;t the clever bit so you can ignore it if you like. There are a ton of good visual explanations on the web (e.g.  this one) so I won&#39;t go into it here.</p><p>代码的工作方式是计算$1/\sqrt{x}$(也可以写为$x^{-1/2}$)的初始近似值，然后使用牛顿-拉夫森方法的一次或两次迭代进行优化。如果你不熟悉牛顿-拉夫森方法，别担心--它不是很复杂，也不是很聪明，所以如果你愿意，你可以忽略它。网络上有一大堆很好的视觉解释(比如这个)，所以我就不在这里赘述了。</p><p>      The heart of the method is bit manipulation of floating point numbers, so we need to know how they work. But the method is simpler to explain using a weird number format that nobody uses.</p><p>该方法的核心是浮点数的位操作，因此我们需要知道它们是如何工作的。但是，使用一种没有人使用的奇怪的数字格式来解释这种方法会更简单。</p><p>       We can use the upper bit for the sign (0 for positive numbers, 1 for negative numbers), and the remaining bits to represent a  positive real number. Using a dedicated bit to represent sign is called  sign and magnitude. Since we cannot take the square root of a negative number we can assume the sign bit is always 0.</p><p>我们可以用高位表示符号(0表示正数，1表示负数)，其余位表示正实数。使用专用位来表示符号称为符号和幅度。因为我们不能取负数的平方根，所以我们可以假设符号位始终为0。</p><p>  We can interpret the next 8 bits as the integral part of a value, and the remaining bits are the fractional part. In this case the value is  10001010.0100001 in binary (we can elide trailing zeros just like with decimal numbers). This corresponds to a decimal value of $138.2578125.$ We can use this value which I will denote $f$ to represent numbers in a few different ways. If we treat the 31-bit value as an unsigned integer $u$ (i.e. $u=\mathrm{0b01000101001000010000000000000000}=1159790592$) then</p><p>我们可以将接下来的8位解释为值的整数部分，其余的位是小数部分。在本例中，值是二进制的10001010.0100001(我们可以去掉尾随的零，就像十进制数一样)。这相当于十进制值$138.2578125。$我们可以使用这个值，我将它表示为$f$，以几种不同的方式表示数字。如果我们将31位值视为无符号整数$u$(即$u=\mathrm{0b01000101001000010000000000000000}=1159790592$)，则。</p><p> $$f = \frac{u}{2^{23}}$$    We can just set $x=f$, i.e. we consider  01000101 00100001 00000000 00000000 to represent the number $138.2578125.$ This format is called  fixed point, because the decimal point is always always fixed at the same place. It has some niche uses but isn&#39;t commonly used because of its major weakness: the range of values it can represent is very limited: only up to 128.9999999 in this example.</p><p>$$f=\frac{u}{2^{23}}$$我们可以只设置$x=f$，即我们认为01000101 00100001 00000000 00000000代表数字$138.2578125。$此格式称为固定点，因为小数点始终固定在同一位置。它有一些特殊用途，但并不常用，因为它的主要弱点是：它可以表示的值范围非常有限：在本例中，最多只能有128.9999999个值。</p><p>    We can increase the range of values that we can represent by exponentiating the fixed point value, i.e. $f=2^{x-127}$. So, instead of considering  01000101 00100001 00000000 00000000 to represent the value $138.2578125$ we say it represents the number $2^{138.2578125 - 127} = 2448.7.$ This is called the  Logarithmic Number System (LNS). The $^{-127}$ offset is used so we can represent numbers smaller than $1.$ Now we can represent numbers up to $2^{128.9999999}.$ We do lose some nice properties though, the most critical is that addition and subtraction are difficult to implement with this number system.</p><p>我们可以通过对不动点取幂来增加我们可以表示的值的范围，即$f=2^{x-127}$。所以，不考虑01000101 00100001 00000000 00000000来表示$138.2578125，我们说它表示数字$2^{138.2578125-00000000}=2448.7，这被称为对数系统(Lns)。使用$^{-127}$偏移量，以便我们可以表示小于$1的数字。$现在我们可以表示最大值为$2^{128.9999999}的数字。$虽然我们确实失去了一些很好的属性，但最关键的是很难使用此数字系统实现加法和减法。</p><p>    To make addition and subtraction easier to implement we can treat the integral and fractional parts of $f$ differently, let&#39;s call them $f_e$ and $f_m$. We make the integral part logarithmic, and the fractional part linear using $x=2^{f_e - 127} \times (1 + f_m)$. In our example $2^{138 - 127} \times 1.2578125 = 2576.$ This means the exponent of $2$ is always integral, which computers can easily deal with. This format is called  floating point because the decimal point floats around (don&#39;t worry about it). Virtually all code uses this format for real numbers, and almost all processors have hardware support for it. This is also why real numbers in C are  float.</p><p>为了使加法和减法更容易实现，我们可以区别对待$f$的整数部分和小数部分，让我们称它们为$f_e$和$f_m$。我们用$x=2^{f_e-127}\x(1+f_m)$使整数部分对数，小数部分线性。在我们的例子中，$2^{138-127}\乘以1.2578125=2576。$这意味着$2$的指数总是整数，这是计算机很容易处理的。这种格式被称为浮点，因为小数点是浮动的(不用担心)。几乎所有的代码都使用这种实数格式，并且几乎所有的处理器都有对它的硬件支持。这也是C中的实数是浮点数的原因。</p><p>  To summarise, the same bit pattern can mean three different numbers depending on the number format we are using:</p><p>总而言之，相同的位模式可能意味着三个不同的数字，具体取决于我们使用的数字格式：</p><p>     If we are using LNS numbers, we do not need a trick to calculate the inverse square root - we can easily calculate it exactly. Recall that the LNS interpretation of an unsigned integer $u$ is</p><p>如果我们使用LNS数，我们不需要技巧来计算平方根的倒数-我们可以很容易地精确地计算它。回想一下，无符号整数$u$的LNS解释为。</p><p> $$2^{u/2^{23} - 127}$$   $$(2^x)^{-1/2} = 2^{-x/2}$$  So to find the unsigned integer $q$ that would give the inverse square root, we need to solve</p><p>$$2^{u/2^{23}-127}$(2^x)^{-1/2}=2^{-x/2}$$因此要找到将给出反平方根的无符号整数$q$，我们需要求解。</p><p> $$2^{q/2^{23} - 127} = 2^{-(u/2^{23} - 127)/2}$$   $$q/2^{23} - 127 = -(u/2^{23} - 127)/2$$ $$q/2^{23} - 127 = -(u/2^{23})/2 + 127/2$$ $$q/2^{23} = 190.5 - (u/2^{23})/2$$ $$q = 190.5 \times 2^{23} - u/2$$      Or if I convert that constant to  hex, and use a bit shift to divide by 2</p><p>$$2^{q/2^{23}-127}=2^{-(u/2^{23}-127)/2}$q/2^{23}-127=-(u/2^{23}-127)/2$q/2^{23}-127=-(u/2^{23})/2+127/2$q/2^{23}=190.5-(u/2^{23})/2$q=190.5\x 2^{23}-u/2$$。并使用位移位除以2。</p><p>    Look familiar? It&#39;s pretty close to the mystical line we saw before! &#34;But&#34;, I imagine you ask, &#34;this is for these weird LNS numbers! What about actual floating point numbers?&#34;</p><p>看起来眼熟吗？这与我们之前看到的神秘路线非常接近！但是，我想你会问，这是给这些奇怪的LNS号码的！。实际的浮点数是多少？&#34；</p><p>   The formula above calculates an  exact inverse square root for LNS numbers. The trick is that floating point numbers are actually pretty similar to LNS numbers! They never differ by more than a factor of $\frac{2}{e\log 2} = 1.0615.$ The following graph shows the value of an LNS number when reinterpreted as a float. In other words the value we get when we take the bit pattern of an LNS number and work out what value those bits represent if they were a floating point number. As you can see they are pretty close!</p><p>上面的公式计算LNS数的精确反平方根。诀窍在于浮点数实际上与LNS数非常相似！它们的差异永远不会超过$\frac{2}{e\log2}=1.0615的因子。$下图显示了重新解释为浮点数时的lns编号的值。换句话说，当我们获取LNS数的位模式，并计算出如果这些位是浮点数，它们代表什么值时，我们得到的值。如你所见，他们非常接近！</p><p>      Another way to look at the difference between LNS and floating point is to vary $f$ and plot the LNS and floating point results.</p><p>查看LNS和浮点之间差异的另一种方法是改变$f$，并绘制LNS和浮点结果。</p><p>       You can see how LNS is fully logarithmic between integer powers of 2, but floating point is linear between those points. All this is just to say that LNS and floating point are pretty similar, so the exact inverse square root of an LNS number is still pretty close to the inverse square root of a floating point number! But why does the code use  0x5f3759df instead of  0x5F400000?</p><p>您可以看到LNS是如何在2的整数幂之间完全对数的，但是浮点在这些点之间是线性的。所有这些都只是说LNS和浮点数非常相似，所以LNS数的精确平方根倒数仍然非常接近浮点数的平方根倒数！但是为什么代码使用0x5f3759df而不是0x5F400000呢？</p><p>   We have a calculation that gives an exact result with LNS numbers, and an approximate result with floating point. How good is the approximation? We can plot the ratio of the approximate output to the correct output for different inputs. A log scale is used so that being out by a constant factor (e.g. $\times 2$ or $\div 2$) looks the same. The green line shows the result after the initial approximation, the blue line shows the result after one iteration of Newton-Raphson. Closer to 1 (the red line) is better.</p><p>我们有一个计算，用LNS数给出一个精确的结果，用浮点数给出一个近似的结果。这个近似值有多好？对于不同的输入，我们可以画出近似输出与正确输出的比率。使用对数刻度，这样以恒定因子(例如$\x 2$或$\div 2$)计算出来的结果看起来是一样的。绿线表示初始近似后的结果，蓝线表示牛顿-拉夫森迭代一次后的结果。越接近1(红线)越好。</p><p>                        Using a subtractant (a word I just made up) of $190.5$ ( 0x5F400000) you can see that the initial approximation always gives a value that is too high (the green line is above the red line). This is because floating point numbers are always greater than the corresponding LNS number. The estimate is somewhere between $1$ and $1.09$ times the actual answer. If we could multiply that output by a constant factor of around $0.96$ then we could balance the error above and below $1$, which would reduce the maximum error.</p><p>使用$190.5$(0x5F400000)的减法(我刚刚编造的一个词)，您可以看到初始近似值总是太高(绿线在红线之上)。这是因为浮点数始终大于相应的LNS数。估计约为1元至1.09元，是实际答案的1倍。如果我们可以将输出乘以大约$0.96$的恒定因子，那么我们就可以平衡$1$上下的误差，这将减少最大误差。</p><p>  This is easy to do just by reducing the subtractant by a small amount. I could go into detail, but you can easily see the effect by sliding the slider above. See how small you can make the maximum error, and then click the &#34;Carmack&#34; button to see the value Quake 3 uses.</p><p>这很容易做到，只需将减法剂减去少量即可。我可以详细介绍一下，但是您可以通过在上面滑动滑块很容易地看到效果。看看你能犯的最大错误有多小，然后单击Carmack按钮查看Quake 3使用的值。</p><p>  It&#39;s pretty close to optimal! But... maybe there&#39;s a way we can do better. Notice that the output after one iteration of Newton-Raphson is still always too small (the blue line is below the red line). Is there a way we could multiply that by some constant factor slightly more than $1$? Yes! All we have to do is modify the  0.5 in the original code a little.    Try playing around with the &#34;One half&#34; slider. In fact, while we&#39;re at it, what happens if we change the  1.5 in the code too and feed the whole thing into a hacked together  optimisation program that I wrote? We can do even slightly better! Click the extra buttons to see the optimisation results when two or three parameters are allowed to change.</p><p>这是相当接近最佳的！但是..。也许有一种方法我们可以做得更好。请注意，牛顿-拉夫森迭代一次后的输出总是太小(蓝线在红线下方)。有没有办法把它乘以略高于1美元的某个常数因子？是!。我们所要做的就是稍微修改一下原始代码中的0.5。试着玩一下这个“半边”滑块。事实上，当我们还在做这件事的时候，如果我们也改变代码中的1.5，并将整个代码输入到我编写的一个拼凑在一起的优化程序中，会发生什么呢？我们可以做得更好一点！单击额外的按钮，查看允许更改两个或三个参数时的优化结果。</p><p>    That&#39;s basically it. To summarise, using LNS numbers we can calculate an exact solution using  0x5F400000. LNS numbers are pretty close to floating point numbers, so the same code gives an approximate solution for floating point. But floating point numbers are always greater than LNS numbers so there is a bias in the approximation that can be corrected by subtracting a small amount from  0x5F400000.</p><p>基本上就是这样。总而言之，使用LNS数字，我们可以使用0x5F400000计算出精确的解。LNS数与浮点数非常接近，因此相同的代码给出了浮点数的近似解决方案。但是浮点数总是大于LNS数，所以近似中存在偏差，可以通过从0x5F400000中减去少量来纠正。</p><p>  Let me know if anything wasn&#39;t clear or I made a mistake. Read on for the answers to a few extra questions I&#39;m pretending you have asked.</p><p>如果有什么不清楚或我弄错了，请告诉我。继续往下看，我假装你已经问了几个额外问题的答案。</p><p>    Yes! I started doing this, but because there are 3 or 4 parts to the error curve it gets very tedious very quickly. Numerical optimisation is much much easier.</p><p>是!。我开始这样做，但是因为误差曲线有3到4个部分，所以很快就变得非常单调乏味。数值优化要容易得多。</p><p>     $$q=190.5 - \frac{u}{2}$$   $$q=\frac{381 - u}{2}$$       $$x^{\pm 2^n}$$  Where $n$ is an integer (positive or negative). E.g. $x^{1/2}$, $x^{-8}$, $x^2$, though you probably wouldn&#39;t use it for positive exponents since you can just use multiplication to get an exact answer.</p><p>$$q=190.5-\frac{u}{2}$q=\frac{381-u}{2}$x^{\pm 2^n}$$其中$n$是整数(正数或负数)。例如，$x^{1/2}$，$x^{-8}$，$x^2$，尽管您可能不会将其用于正指数，因为您可以只使用乘法来获得准确的答案。</p><p>  Can it be used for things like the cube root? Maybe. We need to solve:</p><p>它可以用来做立方根之类的东西吗？也许吧。我们需要解决的问题是：</p><p> $$2^{q/2^{23} - 127} = 2^{(u/2^{23} - 127)/3}$$ $$q/2^{23} - 127 = \frac{u/2^{23} - 127}{3}$$ $$q/2^{23} = \frac{u/2^{23} - 127}{3} + 127$$ $$q = \frac{u}{3} + \frac{2\times 127}{3} * 2^{23} = \frac{u}{3} + \mathrm{0x2A555555}$$  So our (non-optimised; exercise for the reader) magic line would look like this (not tested!)</p><p>$$2^{q/2^{23}-127}=2^{(u/2^{23}-127)/3}$q/2^{23}-127=\frac{u/2^{23}-127}{3}$q/2^{23}=\frac{u/2^{23}-127}{3}+127$q=\frac{u}{3}+\frac{2\x 127}{3}*2^{23}=\frac{u}{3}+。\mathm{0x2A555555}$$因此我们的(未优化；读者练习)魔术线条将如下所示(未经过测试！)。</p><p>    Integer division is not as fast as a bit shift, but because we are dividing by a constant most compilers are able  to optimise it into multiplication and bit shifts. &#34;How?&#34; you ask? Let me just check Wikipedia...</p><p>整数除法不如位移位快，但是因为我们除以常数，所以大多数编译器能够将其优化为乘法和位移位。怎么做到的？你问吗？让我查一下维基百科。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://timmmm.github.io/fast-inverse-square-root/">https://timmmm.github.io/fast-inverse-square-root/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/平方根/">#平方根</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/inverse/">#inverse</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/表示/">#表示</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>