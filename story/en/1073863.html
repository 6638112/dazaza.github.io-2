<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Haskell错误信息：加油Haskell error messages: come on</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Haskell error messages: come on<br/>Haskell错误信息：加油</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 16:10:29</div><div class="page_narrow text-break page_content"><p>I am a big fan of strongly typed languages, and my favorite GC’d languageis Haskell. And I want you, the reader, to keep that in mind today.What I am writing is some commentary about a language I deeply love,some loving criticism.</p><p>我非常喜欢强类型语言，我最喜欢的GC语言是Haskell。我希望读者今天记住这一点。我写的是一些关于我深爱的语言的评论，一些充满爱的批评。</p><p> So here’s what happened: A few days ago, I was showing off some Haskellfor a friend who primarily programs in Python. The stakes were high– could I demonstrate that this strange language was worth someinvestigation?</p><p>事情是这样的：几天前，我向一位主要使用Python编程的朋友展示了一些Haskell。风险很高——我能证明这种奇怪的语言值得调查吗？</p><p> My primary focus was on infinite lists, and defining  fibonacci as a recursive data structure– all fun things to show off Haskell’s laziness.But at some point, we wrote an expression by accident that had a typeerror in it, and so we got to see how the compiler treated such things.I don’t remember the exact expression – it was deep in context – butthe problem was I was trying to add an integer to an list. Somethinganalogous to  1+[2,3].</p><p>我的主要关注点是无限列表，并将斐波那契定义为递归数据结构——所有这些都是展示哈斯克尔懒惰的有趣事情。但在某个时刻，我们意外地编写了一个表达式，其中有一个类型错误，因此我们了解了编译器是如何处理这些事情的。我不记得确切的表达式了——它在上下文中很深——但问题是我试图在列表中添加一个整数。与1+[2,3]有关的内容。</p><p> Now, in some  “weakly typed” languages, this sort of thing is actually allowed, asa colleague of mine recently pointed out:</p><p>现在，在一些“弱类型”语言中，这种事情实际上是允许的，我的一位同事最近指出：</p><p>  This is, of course, hilarious. But! We shouldn’t paint “weakly typed”languages with such a broad brush. In my friend’s native Python, itwould have been an error, as it should be. It is a run-time error, butwhat does that matter when you’re working in an interpreted language,writing ad hoc scripts. The important thing is that failure isrecognized as failure, and it doesn’t try to continue with nonsense:</p><p>这当然很搞笑。但是我们不应该用如此宽泛的笔触描绘“弱类型”语言。在我朋友的原生Python中，这应该是一个错误。这是一个运行时错误，但当您使用解释性语言编写临时脚本时，这又有什么关系呢。重要的是，失败被视为失败，它不会继续胡说八道：</p><p> [jim@palatinate:~]$ python3Python 3.8.10 (default, Nov 26 2021, 20:14:08)[GCC 9.3.0] on linuxType &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.&gt;&gt;&gt; 1+[2,3]Traceback (most recent call last): File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;list&#39;</p><p>[jim@palatinate[~] Python 3Python 3.810（默认值，11月26日2021，20:14:08）[GCC 93.0]在LimuxType和γ34；帮助&#34&#34;版权所有&#34&#34;学分&#34；或&#34；执照和#34；了解更多信息&gt&gt&gt；1+[2,3]回溯（最后一次调用）：文件和#34&书信电报；stdin&gt&#34;, 第1行，in&lt；模块&gt；TypeError:不支持+：&#39的操作数类型；int&#39；和&#39；名单&#39；</p><p> This is an error message. It’s even a pretty decent error message.There are many things you can pass to the  + operator in Python,but an  int and a  list together are not among them.</p><p>这是一条错误消息。这甚至是一条相当不错的错误信息。在Python中，有很多东西可以传递给+运算符，但int和list不在其中。</p><p> So now, what did Haskell do, this language that I’m trying to show off?Well, unfortunately, my friend didn’t see the actual problem in the code,but was first made aware of it from the compiler’s error message. Andif you’ve ever done this before in Haskell, you’re probably wincing rightnow, because you know what this error message is:</p><p>那么现在，哈斯克尔做了什么，我想炫耀的语言？不幸的是，我的朋友没有看到代码中的实际问题，但首先是从编译器的错误消息中得知的。如果你以前在Haskell做过这件事，你现在可能会退缩，因为你知道这个错误信息是什么：</p><p> [jim@palatinate:~]$ ghciGHCi, version 8.6.5: http://www.haskell.org/ghc/ :? for helpPrelude&gt; 1+[2,3]&lt;interactive&gt;:1:1: error: • Non type-variable argument in the constraint: Num [a] (Use FlexibleContexts to permit this) • When checking the inferred type it :: forall a. (Num a, Num [a]) =&gt; [a]</p><p>[jim@palatinate：~]$ghciGHCi，8.6.5版：http://www.haskell.org/ghc/ :? 帮助前奏&gt；1+[2,3]&lt；交互式&gt；：1:1：错误：•约束中的非类型变量参数：Num[a]（使用FlexibleContexts允许此操作）•检查推断的类型时，它：：forall a.（Num a，Num[a]）=&gt；[a]</p><p> Now, my friend didn’t understand this error message at all.Since I was in Demonstration Mode, my instinct was to explain it to him,but after a few false starts, I realized that this would simply nothelp, and pointed out that you couldn’t add integers to lists,and showed him where this was happening (it was a little moresubtle than this example).</p><p>现在，我的朋友根本不理解这个错误信息。由于我处于演示模式，我的本能是向他解释，但在几个错误的开始之后，我意识到这根本没有帮助，并指出不能向列表中添加整数，并向他展示了发生这种情况的地方（这比这个例子要微妙一些）。</p><p> But since then, my colleagues and I were discussing error messages inSlack, specifically how good Rust’s error messages are, specificallyhow much better they are than Haskell’s. So I had an opportunity topaste that very bad Haskell error message me and my friend discoveredinto the Slack. There, it served as a case study, so we could discuss howproblematically incomprehensible it is, sparking a lot of discussion, fromwhich I shall try to extract the most interesting parts into this post.</p><p>但从那以后，我和同事们一直在讨论拉克的错误信息，特别是Rust的错误信息有多好，特别是它们比Haskell的好多少。所以我有机会分享我和我的朋友发现的非常糟糕的Haskell错误信息。在那里，它作为一个案例研究，所以我们可以讨论它在多大程度上是不可理解的，引发了很多讨论，我将尝试从中提取最有趣的部分到这篇文章中。</p><p> For one, this error message has little to do with the concreteproblem. The problem is – and the error message should say this – thatyou can’t add lists. Specifically, in Haskell, you can only add things thatimplement the  Num typeclass (which lists don’t), and so you’d think thecompiler would be smart enough to mention  anywhere in this error messagesomething along the lines of “expecting  [a] to have  Num instance,but it does not.” That’s the  actual problem, even if not well-explained.</p><p>首先，这个错误消息与具体问题几乎没有关系。问题是——错误消息应该这样说——你不能添加列表。具体来说，在Haskell中，您只能添加实现Num typeclass的东西（列表中没有），因此您可能认为编译器会足够聪明，在这个错误消息的任何地方提到类似于“期望[a]有Num instance，但它没有”这样的内容这才是真正的问题，即使没有得到很好的解释。</p><p> But instead,  ghc tries to assume you meant what you wrote, and figureout a way in which  [a]  can have the  Num instance. This is whereit fails, and then it gives advice on how to make  that succeed.As my professor-colleague points out, this is dangerous advice, especiallyfor beginners, because there’s no way that using  FlexibleContextswill actually help in that situation. The problem isn’t that theselists aren’t numbers in particular, and that you need to only acceptlists that are numbers in your function. The problem is that no listsare (or at least should be) numbers! But a beginner might just followthe advice, try to figure out what the hell  FlexibleContexts are,and find themselves in a world of pain, and no closer to solving theactual problem.</p><p>但是，ghc试图假设你的意思是你所写的，并找出[a]可以拥有Num实例的方式。这就是它失败的原因，然后它给出了如何使其成功的建议。正如我的教授同事所指出的，这是一个危险的建议，尤其是对初学者来说，因为在这种情况下，使用FlexibleContexts实际上是没有帮助的。问题不在于这些列表不是特别的数字，而在于您只需要接受函数中的数字列表。问题是没有列表是（或者至少应该是）数字！但是初学者可能只是按照建议去做，试着弄清楚什么是该死的灵活环境，然后发现自己身处一个痛苦的世界，离解决实际问题已经不远了。</p><p> Part of what causes this is the type of  1 itself. Haskell, unlikeRust, allows literals like  1 to be interpreted in any number type.Given that Haskell (like Rust) has return-type polymorphism, it can directlyexpress this in the type system:</p><p>部分原因是1型本身。Haskell，unlikeRust，允许以任何数字类型解释像1这样的文字。鉴于Haskell（如Rust）具有返回类型多态性，它可以在类型系统中直接表达这一点：</p><p>  In Rust, this would be something like  impl Num. It means that  1 canbe any type that is  Num. Combine that with the fact that  + requiresits arguments to be  Num and to match ( (+) :: Num a =&gt; a -&gt; a -&gt; a),and when we see  1+[2,3], we’re simply left trying to figure out how [2,3] is  Num.</p><p>在Rust中，这类似于impl Num。这意味着1可以是Num的任何类型。结合+要求参数为Num并匹配（（+）：：Num a=&gt；a-&gt；a-&gt；a） ，当我们看到1+[2,3]时，我们只是想弄清楚[2,3]是怎么回事。</p><p> If we did not have this  polymorphic literal, this notion that themeaning of  1 is flexible, we would have seen a much more comprehensibleerror message. If  1 meant the same thing as  (1::Integer) (or anyarbitrary choice), we’d have this beautiful explanation:</p><p>如果我们没有多态文字，没有1的含义是灵活的这个概念，我们会看到一个更容易理解的错误信息。如果1的意思与（1:：Integer）相同（或任意选择），我们会有一个漂亮的解释：</p><p> Prelude&gt; (1::Integer) + [2,3]&lt;interactive&gt;:4:16: error: • Couldn&#39;t match expected type ‘Integer’ with actual type ‘[Integer]’ • In the second argument of ‘(+)’, namely ‘[2, 3]’ In the expression: (1 :: Integer) + [2, 3] In an equation for ‘it’: it = (1 :: Integer) + [2, 3]</p><p>序曲&gt；（1：：整数）+[2,3]&lt；交互式&gt；：4:16：错误：•无法&#39；t在“（+）”的第二个参数中，即表达式中的“[2,3]”（1:：Integer）+[2,3]中，将预期类型“Integer”与实际类型“[Integer]”匹配：它=（1:：Integer）+[2,3]</p><p> Or even if we just had non-numbers on both sides, we’d similarlyhave a better error message:</p><p>或者，即使双方都没有数字，我们也同样会有更好的错误信息：</p><p> [jim@palatinate:~]$ ghciGHCi, version 8.6.5: http://www.haskell.org/ghc/ :? for helpPrelude&gt; () + [1,2]&lt;interactive&gt;:1:6: error: • Couldn&#39;t match expected type ‘()’ with actual type ‘[Integer]’ • In the second argument of ‘(+)’, namely ‘[1, 2]’ In the expression: () + [1, 2] In an equation for ‘it’: it = () + [1, 2]Prelude&gt;</p><p>[jim@palatinate：~]$ghciGHCi，8.6.5版：http://www.haskell.org/ghc/ :? 帮助前奏&gt；（）+[1,2]&lt；交互式&gt；：1:6：错误：•无法&#39；t在“（+）”的第二个参数中，即表达式中的“[1,2]”中，将预期类型“（）”与实际类型“[Integer]”匹配：（）+[1,2]在“it”的等式中：it=（）+[1,2]Prelude&gt；</p><p> What is my take-away here? I don’t think the compiler has been sufficientlytweaked when it comes to error messages, or that the Haskell communitycares sufficiently about beginners. Rust as a communityputs a lot of energy into good error messages, so that even thoughRust also has a trait you could add to arrays to make  + work,it still has a better error message:</p><p>我的外卖是什么？我不认为编译器在错误信息方面受到了足够的削弱，或者Haskell社区对初学者的关注不够。Rust作为一个通讯器会将大量能量转化为良好的错误消息，因此即使Rust也有一个特性可以添加到数组中以使+工作，它仍然有一个更好的错误消息：</p><p> error[E0277]: cannot add `[{integer}; 2]` to `{integer}` --&gt; test.rs:2:7 |2 | 1 + [2,3]; | ^ no implementation for `{integer} + [{integer}; 2]` | = help: the trait `Add&lt;[{integer}; 2]&gt;` is not implemented for `{integer}`</p><p>错误[E0277]：无法将`[{integer}；2]`添加到`{integer}`-&gt；测验rs:2:7 | 2 | 1+[2,3]| ^没有实现`{integer}+[{integer}；2]`|=help:trait`Add&lt；[{integer}；2]&gt；`没有为`{integer}实现`</p><p> But I also think the semantics of  1 are too liberal, leaving the compilerin an awkward place. See, the weird thing is, you can declare  [2,3]a number, making  1+[2,3] an expression that adds two lists:</p><p>但我也认为1的语义太过自由，给编译器留下了一个尴尬的位置。看，奇怪的是，你可以声明[2,3]一个数字，使1+[2,3]成为一个添加两个列表的表达式：</p><p> instance Num [a] where (+) = (&lt;&gt;) (-) = (&lt;&gt;) -- Eh, why not? (*) = (&lt;&gt;) negate = reverse abs = id signum = const [] fromInteger i = take (fromInteger i) $ repeat undefinedmain = do print $ signum $ 1 + [2,3]</p><p>实例编号[a]，其中（+）=（&lt；&gt；）（-）=（&lt；&gt；）——呃，为什么不呢？（*）=（&lt；&gt；）否定=反向abs=id signum=const[]from integer i=take（from integer i）$repeat undefinedmain=do print$signum$1+[2,3]</p><p> Once you’ve defined lists as a number,  1 is suddenly a list ifit wants to be. And this contributes to the difficulty of findingthe right error message: what you asked for is possible after all.</p><p>一旦你将列表定义为一个数字，1就会突然变成它想要的列表。这就增加了找到正确错误信息的难度：毕竟你所要求的是可能的。</p><p> And in the end, this leaves me with the feeling that Haskell hasthis in common with Javascript, and that makes me sad. A polymorphicenough strongly typed language is no longer strongly typed.</p><p>最后，这让我觉得Haskell和Javascript有着共同点，这让我很难过。强类型语言不再是强类型语言。</p><p>   comments powered by  Disqus</p><p>由discus支持的评论</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/错误信息/">#错误信息</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/error/">#error</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>