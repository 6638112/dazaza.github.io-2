<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>DRPC：我们对GRPC的更换 DRPC: Our Replacement for gRPC</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">DRPC: Our Replacement for gRPC<br/>DRPC：我们对GRPC的更换 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 10:51:23</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/9f08a671bf077aa60235f0fbaa2b1b8f.png"><img src="http://img2.diglog.com/img/2021/4/9f08a671bf077aa60235f0fbaa2b1b8f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In 2016, Google launched  gRPC, which has overall taken the systems programming community by storm. gRPC stands for something with a G, Remote Procedure Call; it&#39;s a mechanism for easily defining interfaces between two different remote services. It&#39;s tightly bundled with  Protocol Buffers version 3 (another highly adopted data interchange specification from Google), and... it seems like everyone is using it. Wikipedia, Square, Netflix, IBM, Docker, Cockroach Labs, Cisco, Spotify, Dropbox, etc., all use gRPC.</p><p>2016年，谷歌推出了GRPC，其整体地通过风暴拍摄了系统编程社区。 GRPC代表了G，远程过程呼叫的东西;它＆＃39; s一种在两个不同远程服务之间轻松定义接口的机制。它与协议缓冲器版本3紧密捆绑在一起（来自Google的另一个高度采用的数据交汇处），似乎每个人都在使用它。维基百科，广场，Netflix，IBM，Docker，蟑螂实验室，思科，Spotify，Dropbox等，都使用GRPC。</p><p> Here at Storj, we’re pioneers in decentralized cloud storage. By early 2018, we built and scaled a 150 petabyte decentralized storage network. Of course, like every good scaling story, by the time we got to 150 petabytes, we discovered some fundamental architectural issues that needed to be reworked. Staring down the barrel of a few hundred thousand lines of untyped Javascript with... sort of decent test coverage, we made the  risky decision in March of 2018 to fix these architectural issues with a ground-up reimplementation in Go. We&#39;re calling this iteration our V3 network, which had its production launch in March of 2020. You can read all about our architecture in  our whitepaper, and you can  try out our live service.</p><p> 在Storj，我们在分散的云存储中的先驱。到2018年初，我们构建并缩放了150个Petabyte分散的存储网络。当然，像每个好的比例故事一样，当我们到达150岁的Petabytes时，我们发现了一些需要重新制作的基本架构问题。盯着几十万行的桶的桶，有......一种体面的测试覆盖，我们在2018年3月制造了危险的决定，以便在去的次要重新实现方面修复这些架构问题。我们＆＃39;重新召开这种迭代我们的V3网络，它在2020年3月开始推出。您可以阅读我们的白皮书中的所有建筑，您可以尝试我们的直播服务。</p><p>  Building a new decentralized storage platform from the ground up in Go, obviously, we considered using gRPC to simplify our development process in peer-to-peer remote procedure calling. In fact, I&#39;m not even sure we really considered anything else. Using gRPC for us was a deliberate decision to  avoid using an innovation token. How could gRPC be the wrong choice? It has impressive credentials and wide usage. We were always disappointed Google didn&#39;t release a standard RPC implementation with proto2. With an otherwise previously strongly positive experience with protocol buffers, we were excited to jump all in to the new protobuf RPC land.</p><p>  显然，从地上建立一个新的分散存储平台，我们考虑使用GRPC来简化我们在点对点远程过程调用中的开发过程。事实上，我甚至不确定我们真的被认为是别的什么。使用GRPC为我们是故意决定避免使用创新令牌。 GRPC如何成为错误的选择？它具有令人印象深刻的凭据和广泛的用法。我们总是失望的谷歌并没有发布标准的RPC实现。通过以前与协议缓冲区的完全强烈的积极经验，我们很高兴能够跳到新的Protobuf RPC土地上。</p><p> Fast forward to the latter half of 2019, and we had 170k lines of Go, a beta network of over 4 PB, real live active users, and it turns out the gRPC bed we made for ourselves was not all roses, and we kind of pooped just a little in it. Just a little bit. This much -&gt;||&lt;-. So not a lot, but still.</p><p> 快进到2019年下半年后，我们有170k线，一个超过4磅的测试网络，真正的活跃的用户，事实证明我们为自己制造的GRPC床并非所有玫瑰，而且我们有点在它中稍微大便。只是一点点。这个很多 - ＆gt; ||＆lt;  - 。所以不多，但仍然。</p><p> So we rewrote gRPC and migrated our live network.  DRPC is an open-source, drop-in replacement that handles everything we needed from gRPC (and most likely, everything you need) in under 3000 lines of Go. It now powers our full network of tens of thousands of servers and countless clients.</p><p> 所以我们重写GRPC并迁移我们的实时网络。 DRPC是一个开源的替代品，处理我们在3000线以下的GRPC（以及最有可能的一切）所需的一切。它现在为我们的全部网络提供了数万种服务器和无数客户。</p><p>   Let’s just get out here and say what not enough people are saying—in a nutshell, gRPC has feature creep, bloat and is trying to solve too many problems. It’s overcomplicated and has become a dumping ground of features, tangled in a standards body-based web of crap.</p><p>   让我们刚出去这里说出什么是不够的人在一个简单的人中，Grpc拥有蠕变，臃肿，并试图解决太多问题。它过度自由化，已成为倾销的特色，纠结在基于标准的废话垃圾网。</p><p>   Did you know that there are 40 different dial options? There are 26 server options. You have 13 call options. gRPC is huge. One major issue that led us away from gRPC was that it constituted over a fifth of our own (sizeable) binaries.</p><p>   你知道有40个不同的拨号选择吗？有26个服务器选项。你有13个电话选项。 GRPC是巨大的。导致我们远离GRPC的一个主要问题是它在我们自己（相当大的）二进制文件中构成。 </p><p> Do you use gRPC’s built-in APIs for internal load balancing? You probably don’t—your load balancer probably does something else. Do you use manual name resolution builders? Do you find yourself uncertain what operations are synchronous or not? Wait, should we use WithBlock? gRPC tends to accrue features so that it tries to solve every problem, and with every solution comes more code to maintain, places for bugs to hide, and additional semantics to worry about.</p><p>您是否使用GRPC的内置API进行内部负载平衡？你可能没有 - 你的负载平衡器可能会做其他事情。您是否使用手动名称解析库？你发现自己不确定的操作是同步的吗？等等，我们应该用whelock吗？ GRPC倾向于累积功能，以便它试图解决每个问题，并且每个解决方案都有更多的代码来维护，令人担忧的错误和额外的语义。</p><p> On the other hand, DRPC’s core is under 3000 lines! It’s a reasonable task to audit and understand it.</p><p> 另一方面，DRPC的核心低于3000线！审核和理解它是一个合理的任务。</p><p>     This tweet is from 2019, and as of today, in 2021, WithDefaultServiceConfig is still experimental, and WithBalancerName is still deprecated.</p><p>     这款Tweet是2019年，as今天，在2021年，vitefaultserviceConfig仍然是实验性的，并且仍被弃用了Balancername。</p><p> At the time of this writing, there are 37 deprecation notices in the top-level  gRPC documentation. This makes it hard to understand what you’re supposed to use, what you’re not supposed to use, what things are available, etc.</p><p> 在这份写作时，顶级GRPC文档中有37个弃用通知。这使得很难了解你应该使用的是什么，你不应该使用什么，有什么东西可以使用。</p><p>  81% of the heap usage of one of our Storage Nodes was in gRPC. You can’t use another protobuf library; there are a large number of allocations, you get its own HTTP/2 server, and the hits keep coming.</p><p>  81％的堆用节点的堆用节点是GRPC。你不能使用另一个protobuf库;有大量的分配，你得到自己的http / 2服务器，并击中了。</p><p> A protobuf-based protocol has the fortunate ability to avoid a complicated string parsing and overhead of traditional, older protocols, such as HTTP, unless you use gRPC. Then you have to deal with HTTP/2 and all the legacy edge cases that may arise.</p><p> 基于Protobuf的协议具有幸运能力，避免了传统旧协议的复杂字符串解析和开销，例如HTTP，除非您使用GRPC。然后，您必须处理HTTP / 2以及可能出现的所有传统边缘案例。</p><p>  Pop quiz: imagine you’re trying to debug some issue that’s happening during dialing of connections, and you use  https://pkg.go.dev/google.golang.org/grpc#WithContextDialer. See if you can find where in the gRPC code base the function you provide there is called.</p><p>  POP测验：想象一下，您正在尝试调试在拨号连接期间发生的问题，您使用https://pkg.go.dev/google.golang.org/grpc#withcontextdialer。看看您是否可以在GRPC代码库中找到您提供的功能，所以调用。 </p><p> gRPC is at least 10 times more lines of code than DRPC, and it is safe to say some of the API has grown organically and is hard to reason about.</p><p>GRPC比DRPC的代码行至少10倍，并且可以安全地说一些API有机地增长，很难理由。</p><p>   Yep! Considering we have 170k lines of Go, tightly integrated into both single and streaming request styles of gRPC, in 2019, we narrowed our options down to:</p><p>   是的！考虑到我们有170K的GO线，紧紧融入GRPC的单一和流媒体请求风格，2019年，我们将选择缩小为：</p><p>  We really wanted to avoid having to change every service already registered with gRPC. Again, the services were fine, and we just needed to change the connection layer. Thrift was a pretty big departure for pretty much all of our code, so we eliminated it. Maybe it would have been good to start with, but we judged by the cover and suspected it wasn’t the best place to start.</p><p>  我们真的很想避免不得不更改已经在GRPC注册的每个服务。再次，服务很好，我们只需要更改连接层。节俭是一个非常大的出发，因为我们所有的代码都是如此，所以我们消除了它。也许从求职者开始，我们会判断并怀疑它不是最佳的开始。</p><p> We could have eliminated Twirp for the same reason, but Twirp had another problem - we needed support for bidirectional streaming, and Twirp didn’t have it.</p><p> 我们可以出于同样的原因淘汰Twirp，但Twirp还有另一个问题 - 我们需要支持双向流的支持，Twirp没有它。</p><p> Forking gRPC may have been a good choice, but we would suddenly be responsible for all of it, as we ripped out the parts we didn’t need. Ripping out the overhead of HTTP/2 alone was by itself essentially a rewrite. It seemed like a simpler undertaking to start fresh.</p><p> 分叉GRPC可能是一个不错的选择，但我们突然对所有这些都负责，因为我们撕掉了我们不需要的零件。撕掉了单独的HTTP / 2的开销本身基本上是重写。它似乎是一个更简单的事项开始新鲜。</p><p> So, we decided to time-box an experiment to write our own. The experiment was a smashing success.</p><p> 所以，我们决定用时代来写自己的实验。实验是一种粉碎的成功。</p><p>  DRPC is a code-wise drop-in replacement for the client/server interactions of gRPC. If you’re using gRPC today in Go, you should be able to swap your protocol buffer generation pipeline to DRPC and be on your way. If you already have proto3 .proto files, the protoc protobuf compiler can be told to generate DRPC code instead of gRPC code (or both, if you&#39;re migrating).</p><p>  DRPC是GRPC客户端/服务器交互的代码替换。如果您今天使用GRPC，则应该能够将协议缓冲生成管道交换给DRPC并在您的路上。如果您已经有proto3 .proto文件，则可以告知Protoc Protobuf编译器以生成DRPC代码而不是GRPC代码（或两者，如果您＆＃39;重新迁移）。 </p><p> DRPC supports a wide range of functionality in its spartan few thousand lines. DRPC is blazingly fast and lightweight (the protocol does not require HTTP header parsing, for example), it supports unitary and streaming requests, it has an HTTP/JSON gateway, it supports metadata for per-request side-channel information like tracing, it supports layering and middleware, etc.</p><p>DRPC在其斯巴达几千行中支持各种功能。 DRPC巧妙地快速轻便（例如，例如，协议不需要HTTP标题解析），它支持酉和流媒体请求，它有一个HTTP / JSON网关，它支持每个请求的侧通道信息，如跟踪，它支持分层和中间件等。</p><p>  Also be sure to check out the gRPC vs DRPC benchmarks on  our Github README. I want to specifically call out how much better with memory usage DRPC is. GC pressure sucks! When you have high performance servers, reducing GC pressure is always a good call.</p><p>  另一定要查看我们的GitHub Readme上的GRPC VS DRPC基准。我想专门调用内存使用DRPC的更好。 GC压力很糟糕！当您有高性能服务器时，降低GC压力始终是一个很好的呼叫。</p><p>  It&#39;s worth pointing out that DRPC is  not the same protocol as gRPC, and DRPC clients cannot speak to gRPC servers and vice versa.</p><p>  它的价值指出DRPC与GRPC不同的协议，DRPC客户端不能与GRPC服务器交谈，反之亦然。</p><p>  One major challenge we faced was that we already had gRPC deployed. We needed to support both DRPC and gRPC clients for a transition period until everything understood gRPC.</p><p>  我们面临的一个主要挑战是我们已经部署了GRPC。我们需要支持DRPC和GRPC客户端进行过渡期，直到所有内容都理解GRPC。</p><p> As a result, we wrote (and included in DRPC) migration helpers that allow you to listen for and respond to DRPC and gRPC requests on the same port. Make sure to check out  https://pkg.go.dev/storj.io/drpc/drpcmigrate#ListenMux and our gRPC and DRPC example:  https://github.com/storj/drpc/tree/main/examples/grpc_and_drpc</p><p> 因此，我们写道（并包含在DRPC中）迁移助词允许您倾听并响应同一端口上的DRPC和GRPC请求。确保查看https://pkg.go.dev/storj.io/drpc/drpcmigrate#listenmux和我们的grpc和drpc示例：https：//github.com/storj/drpc/tree/main/examples/grpc_and_drpc</p><p>  Release and deploy new server code that understands both gRPC and DRPC concurrently. With DRPC, this was a breeze since all of our application code could be used identically with both, and our ListenMux allowed us to do both from the same server port.</p><p>  释放并部署新的服务器代码，并同时了解GRPC和DRPC。使用DRPC，这是一个微风，因为我们所有的应用程序代码都可以与两者相同使用，我们的Listenmux允许我们从同一服务器端口执行。</p><p> Once all the servers and Nodes were updated, release and deploy new clients that spoke DRPC instead of gRPC.</p><p> 一旦更新所有服务器和节点，就会发布并部署辐注DRPC而不是GRPC的新客户端。 </p><p> We immediately eliminated a whole class of inscrutable WAN network errors (our availability metrics went up), improved performance and reduced CPU and resource utilization, reduced our binary sizes significantly, and have overall been much, much happier.</p><p>我们立即消除了一整套缺乏的WAN网络错误（我们的可用性指标上升），提高性能和降低的CPU和资源利用率，显着降低了我们的二进制大小，并且整体而言，更快乐。</p><p>  DRPC, like almost everything else at Storj, is open source. DRPC is MIT/expat licensed, and we’d love your help! Since we currently only have Go bindings for DRPC, bindings for new languages would be a great place to start.</p><p>  DRPC，就像Storj的几乎所有其他东西一样，是开源。 DRPC是MIT / EXPAT许可，我们喜欢你的帮助！由于我们目前只有DRPC的GO绑定，新语言的绑定将是一个很好的开始。</p><p> Feel free to check out  our Github repo and let us know if we can help you dive in!</p><p> 随意查看我们的GitHub repo，让我们知道我们是否可以帮助您潜入！</p><p>  Storj Labs is building the next generation cloud object storage. Our decentralized approach makes us more secure and private than existing cloud object storage providers. Nothing sells our product better than just trying it for yourself.  Sign up, or check out our service at  https://link.us1.storjshare.io/s/jvgmjntaucpfedohxn3ogdrsfcfa/homepage/TardigradeExplainerVideo.m4v</p><p>  Storj Labs正在构建下一代云对象存储。我们的分散方法使我们更安全和私有，而不是现有的云对象存储提供商。没有什么比试图为自己销售我们的产品。注册，或在HTTPS://link.us1.storjshare.io/s/jvgmjntaucpfedohxn3ogdrsfcfa/homepage/tardigradeexplainervideo.m4v中查看我们的服务</p><p> Storj Labs is looking for developers who want to be a part of the decentralized future. We have  a number of openings. Please  shoot me an email if you’re interested!  ‍</p><p> Storj Labs正在寻找希望成为分散未来的一部分的开发人员。我们有很多开口。如果您有兴趣，请给我发电子邮件！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.storj.io/blog/introducing-drpc-our-replacement-for-grpc">https://www.storj.io/blog/introducing-drpc-our-replacement-for-grpc</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/grpc/">#grpc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>