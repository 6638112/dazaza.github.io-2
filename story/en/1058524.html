<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux上DNS客户端配置的Sisyphean任务 The Sisyphean Task of DNS Client Config on Linux</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Sisyphean Task of DNS Client Config on Linux<br/>Linux上DNS客户端配置的Sisyphean任务 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-16 00:49:29</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/ea1865f54c8d4d8aaf0a14292b37ffd9.png"><img src="http://img2.diglog.com/img/2021/4/ea1865f54c8d4d8aaf0a14292b37ffd9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>DNS (Domain Name Service) was invented in 1983. DNS is a system that lets youturn names into IP addresses so that your computer can know how to connect withwebsites like tailscale.com. This is a simple service, so the authors of 4.3 BSDspecified a simple configuration file called  /etc/resolv.conf:</p><p>DNS（域名服务）是在1983年发明的。DNS是一个系统，它可以将名称置于IP地址，以便您的计算机可以知道如何像Tailscale.com这样连接到Websites。这是一个简单的服务，所以作者为4.3 bsdspecified一个名为/etc/resolv.conf的简单配置文件：</p><p>  In this case, it tells the DNS resolution function to use 192.168.122.1 as theDNS server. This means that when you do lookups for websites like tailscale.com,it will ask 192.168.122.1 to do that lookup for you:</p><p>  在这种情况下，它讲述了DNS解析函数使用192.168.122.1作为THEDNS服务器。这意味着当您为TailScale.com等网站进行查找时，它将询问192.168.122.1对您进行查找：</p><p>  If Tailscale were around in the old days, we could probably just modify/etc/resolv.conf safely, and that would be the end of it.</p><p>  如果在过去的旧日子周围，我们可能只会安全修改/ etc / soldv.conf，这将是它的结束。</p><p> However, things like DHCP came along and added a bunch of needed complexity intothe equation. DHCP is a protocol that lets machines on a network discover whatconfig they should use by shouting aimlessly at everyone on the network untilsomeone tells them what they want. One of the things that DHCP provides is theIP address of the network’s preferred DNS server. The contents of /etc/resolv.conf need to be managed by some program, and if there aredisagreements, the disagreeing programs (such as a DHCP client and Tailscale)need to compete for DNS supremacy. Most distributions and custom setups startedusing an ungoogleable program called  resolvconf to aid this.</p><p> 然而，像DHCP这样的事情进入并添加了一堆所需的复杂性Intothe等式。 DHCP是一个协议，让网络上的机器发现它们应该通过漫无目的地喊叫在网络上的每个人身上，直到我们讲述他们想要的东西。 DHCP提供的一件事是网络首选DNS服务器的AIP地址。 /etc/resolv.conf的内容需要由某些程序管理，如果有aredisagreements，则不同意的计划（例如DHCP客户端和TailScale）需要竞争DNS至上。大多数发行版和自定义设置，同步为一个名为rescolvconf的ungoolable程序，以帮助这一点。</p><p> resolvconf will helpfully add a comment to the beginning of a /etc/resolv.conf letting you know that  resolvconf is managing it:</p><p> Resolvconf将有助地向ARTC/RESOLV.conf的开头帮助您的评论，让您知道rollevconf正在管理它：</p><p>  resolvconf is a loose convention for managing DNS, which is implemented inslightly mutually-incompatible ways by multiple programs. The two common onesare  Debian’s  resolvconf and openresolv.</p><p>  RESCRVCONF是管理DNS的一个松散的公约，该公约由多个程序实现了互相不兼容的方式。两个常见的evaneare是debian的resolvconf和OpenResolv。</p><p> When several things have opinions about the DNS configuration, you need some wayto arbitrate between them. Debian’s  resolvconf adopts the strategy of lettingeverybody win, and installs a configuration that is a blend of all its inputs.This is fine until you get into a situation like Tailscale, where you actuallydo want to be able to override the DNS configuration entirely (e.g. because anadmin set a forced DNS configuration in the Tailscale admin panel). Of course, we think we’re more right than others, but the others think the same aboutthemselves, and Debian resolvconf refuses to pick a winner.</p><p> 当几件事有关于DNS配置的意见时，您需要某种方式在它们之间仲裁。 Debian的ResolVConf采用LettingVenyBody赢取的策略，并安装了所有输入的混合的配置。这很好，直到您进入像尾部的情况，您实际上希望能够完全覆盖DNS配置（例如，因为Anadmin在TailScale管理面板中设置强制DNS配置）。当然，我们认为我们比其他人更为正确，但其他人认为对自己同样的事情，而Debian Refalvconf拒绝选择一个胜利者。 </p><p> openresolv allows you to specify the priority order of DNS servers. Additionallyit allows programs to specify an “exclusive” mode where it will always preferthat option and other options will be discarded. If two programs want to be in“exclusive” mode, the last one that provided a configuration wins, and we’reback to competing for DNS supremacy.</p><p>OpenResolv允许您指定DNS服务器的优先顺序。另外允许程序指定“独占”模式，其中它将始终更喜欢选项，并且将丢弃其他选项。如果两个程序希望处于“独占”模式，则最后一个提供配置获胜的最后一个，以及我们的竞争为DNS至上的竞争。</p><p> However, as Tailscale we actually want this behavior, so we use it to set DNSconfiguration when we can:</p><p> 但是，正如TailScale我们实际上想要这种行为，所以我们使用它来设置DNSconFiguration：</p><p>  After a while people in FreeDesktop noticed that this constant battling for DNSsupremacy was very annoying (not to mention configuring wifi connections waseven more annoying) and they got together to create a better path forward. Theycalled this  NetworkManager. Ituses a protocol called  D-Busto allow other programs to tell it what to do. This is a marked improvement overwhat  resolvconf does. To update  /etc/resolv.conf with  resolvconf you needto pipe your desired configuration to  resolvconf and hope the thing you wantedactually happens. NetworkManager’s API has a schema and allows introspecting,which makes things easier on our end.</p><p>  过了一段时间的人在Freedesktop中注意到这种不断的DNSSupremacy的战斗非常烦人（更不用说配置WiFi连接是令人讨厌的，他们在一起创造了更好的道路。他们这个网络管理器。 ituses一个名为d-busto的协议允许其他程序告诉它该做什么。这是一个明显的改进resolvconf。要使用ResolvConf更新/etc/resolv.conf，您需要将所需配置管制到Rescrivconf，并希望您愿意发生的事情。 NetworkManager的API具有架构并允许内省，这在我们的末端更容易。</p><p> NetworkManager aimed to be the One Daemon To Rule Them All of network managementon Linux. Even though it has its own ways to manage  /etc/resolv.conf,sometimes NetworkManager can be configured to use  resolvconf to manage /etc/resolv.conf. This happens on more distros then you would think.NetworkManager did a very good job at hiding a lot of the hard parts and allowsusers to configure the network with GUI tools.</p><p> NetworkManager旨在成为一个守护程序，以统治所有网络Mancesson Linux。尽管它有自己的方法来管理/etc/resolv.conf，但是networkManager可以配置为使用roctVconf来管理/etc/resolv.conf。这会发生在更多的发行版，然后你会想到的是在隐藏很多硬件和允许使用GUI工具的硬件和允许员时做得非常好的工作。</p><p> NetworkManager was the standard and best of breed way of doing DNS configurationfor a long time (some distros still prefer it to this day), however as thingsgot more complicated there was a need for something a bit more powerful. The systemd project created asolution called systemd-resolved, whichallows administrators to have more control over how DNS gets resolved on aper-network interface basis. Here’s the resolved status on one of our Linuxmachines:</p><p> NetworkManager是长时间做DNS配置的标准和最好的方法，但是，一些发行版仍然更喜欢这一天），然而随着物品更复杂，有需要更强大的东西。 Systemd项目创建了名为systemd-solutived的solution，该管理员可以更好地控制DNS在APER-Network界面中如何解决。以下是我们的LinuxMachines之一的已解决状态：</p><p> $ resolvectl statusGlobal Protocols: +LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported resolv.conf mode: stub Current DNS Server: 100.100.100.100 DNS Servers: 100.100.100.100 8.8.8.8 1.1.1.1Fallback DNS Servers: 100.100.100.100 8.8.8.8 1.1.1.1 DNS Domain: akua.xeserv.us christine.website.beta.tailscale.netLink 2 (enp5s0)Current Scopes: LLMNR/IPv4 LLMNR/IPv6 Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupportedLink 9 (tailscale0)Current Scopes: LLMNR/IPv4 LLMNR/IPv6 Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported</p><p> $ resolvectl状态全球的 协议：+ llmnr + mdns -dnsovertls dnssec =否/不支持 resolv.conf模式：stub 当前DNS服务器：100.100.100.100 DNS服务器：100.100.100.100 8.8.8.8 1.1.1.1后退DNS服务器：100.100.100.100 8.8.8.8 1.1.1.1 DNS域：Akua.xeserv.us christine.website.beta.tailscale.net链接2（ENP5S0）当前范围：LLMNR / IPv4 LLMNR / IPv6 协议：-defaultroute + llmnr -mdns -dnsovertls dnssec =否/不支持链接9（Tailscale0）当前范围：LLMNR / IPv4 LLMNR / IPv6 协议：-defaultroute + llmnr -mdns -dnsovertls dnssec =否/不支持</p><p> Among other things, systemd-resolved allows you to use  DNS overTLS. This is an extra ball of funthat is thankfully out of scope for this article. However, systemd-resolved alsoallows Tailscale to reliably configure it with its D-Bus API (not quite the sameAPI as NetworkManager, of course).</p><p> 除此之外，Systemd-Devertved允许您使用DNS DESTLS。这是一个额外的肮脏球，愉快地脱离了这篇文章的范围。但是，SystemD-Devallved andallows optaWale可以使用其D-Bus API可靠地配置它（当然不是NetworkManager，而不是Sameapi，当然）。 </p><p> Of course this assumes that we’re treating DNS as a globally consistentnamespace, the way DNS was intended when it was first invented. This is notalways the case.</p><p>当然，这假设我们将DNS视为全球一致的NameSpace，在首次发明时DNS的方式。这并非总是如此。</p><p> Some networks or organizations have their own private DNS server with names thatare unable to be resolved over the internet. This makes things a lot morecomplicated. For lack of a better term we will be calling this setup “split DNS”(if you have a better term in mind we are more than happy to take suggestions,but for the sake of this article we’re going to call it “split DNS”).</p><p> 某些网络或组织具有自己的私有DNS服务器，其中包含无法通过Internet解析的名称。这使事情变得很多。由于缺乏更好的术语，我们将呼叫此设置“拆分DNS”（如果您有更好的术语，我们非常乐意采取建议，但为了本文，我们将称之为“拆分” DNS“）。</p><p> IP traffic is routed between other machines using a routing table. This routingtable has a list of networks and instructions on what to do with them. Tocorrectly handle a split DNS setup, you need a routing table for DNS, brokendown by subdomain instead of by IP address. This is how Windows, macOS, andlinux with systemd-resolved handle these kinds of configurations. For example,you could have a DNS routing table that looks like this:</p><p> 使用路由表在其他计算机之间路由到IP流量。此路由标准有一个网络和关于与它们有关的指示。 Tocorryly处理拆分DNS设置，您需要一个用于DNS的路由表，由子域而不是IP地址。这就是Windows，MacOS，Andlinux与Systemd-Departved处理这些类型的配置。例如，您可以拥有一个如下所示的DNS路由表：</p><p>  These setups are more common than you would think at first and are in use injust about every household with a Mac in it. This lets you automaticallydiscover the IP for computername with the domain  computername.local. Mostcorporate VPNs will also want this to have internal-facing services (such asgit, database or IRC servers) resolve to an IP address behind the VPN. Thisprevents leaking requests to the public DNS service, and Linux lacking thissupport out of the box (when running without systemd-resolved, that is) has beena significant limitation.</p><p>  这些设置比你首先思考的更常见，并且在其中的每个家庭都有伤害。这使您可以使用域ComputerName.local自动触发ComputerName的IP。 MOSTCORENTATE VPN还希望实现内部服务（如售货机，数据库或IRC服务器）解析到VPN后面的IP地址。这项服务器对公共DNS服务泄露请求，以及缺少框中的Linux（在没有Systemd-Resolved的情况下运行时）已成为显着的限制。</p><p> /etc/resolv.conf does not have support for routing DNS based on the domainname, so in the most basic configuration, we implement the routing in anin-process resolver within the Tailscale daemon, and tell the OS to send all itsDNS traffic to 100.100.100.100. This traffic gets handled locally by yourmachine’s tailscaled process, and lets resolv.conf-based systems have split DNS.We still have to occasionally battle for DNS supremacy, depending on what elseis trying to edit  /etc/resolv.conf.  resolvconf is a similar story, possiblywith a little less fighting over the configuration.</p><p> /etc/resolv.conf对基于domainname的路由DNS不具有支持，因此在最基本的配置中，我们在TailScale守护程序中的Anin-Process Resolver中实现路由，并告诉操作系统将所有ITSDNS流量发送到100.100 .100.100。此流量通过您的尾声流程本地处理，让基于Resolv.conf的系统分开了DNS。我们仍然必须偶尔为DNS至上的战斗，具体取决于尝试编辑/etc/resolv.conf。 Resolvconf是一个类似的故事，可能在较少的配置方面略低。</p><p> Then comes NetworkManager. NetworkManager has the ability to control /etc/resolv.conf,  resolvconf and optionally a DNS server called  dnsmasq. The only mode thatallows split DNS is  dnsmasq mode. This means that Tailscale needs to careabout which mode NetworkManager is in, and we use  thiscodeto do it. We have some extra code in there to handle cases where we  should beusing NetworkManager, but it fails to respond to pings (thank $DEITY that thestandard D-Bus way of doing things is to have every object implement a “Ping”method), in which case we need to get into the trenches again.</p><p> 然后是NetworkManager。 NetworkManager能够控制/etc/resolv.conf，soldvconf和可选的DNS服务器，称为DNSMASQ。只有拆分DNS的唯一模式是DNSMASQ模式。这意味着TailScale需要Careabout哪种模式NetworkManager在内，我们使用该ododeto执行此操作。我们在那里有一些额外的代码来处理我们应该营养的案例，我们应该营造NetworkManager，但它无法响应pings（感谢D-Bus做事的Tandard D-Bus方式的方式是让每个对象实现“Ping”方法），进入我们需要再次进入沟渠。</p><p> As an aside, one major difficulty in all of this is that name resolution onLinux systems is very poorly specified, and each of these methods results inslightly different behavior.[j] If we do a resolution for  go.akua, what willhappen? Will it go to the resolver for the public internet? Will it go to theright split server? Will it get sent over Tor for some reason? Will it get sentto the potentially dodgy DNS server on the public wifi hotspot at your localcoffee shop? Will it get sent over UDP, TCP or DNS over HTTPS? We don’t know.This stuff is not documented and as a result, you need to figure out what itdoes through blood, tears and heartbreak. For extra fun, the behavior of glibcand musl differs here too. Please document your behaviors when you write newsoftware. This saves so many people so much time.</p><p> 除了旁边，所有这些中的一个主要困难都是onlinux系统的名称分辨率指定非常差，这些方法中的每一个都会产生不同的行为。[j]如果我们为go.akua做出决议，那么willhappen是什么？它会转向公共互联网的解析程序吗？它会去视图拆分服务器吗？出于某种原因，它会被送过吗？将在您的LocalCoffee Shop的公共WiFi热点上发出潜在狡猾的DNS服务器吗？它会通过HTTPS通过UDP，TCP或DNS发送吗？我们不知道。这个东西没有记录，结果，你需要弄清楚通过血液，泪水和心碎的东西。为额外乐趣，Glibcand Musl的行为也不同。写新闻时文时，请记录您的行为。这很多时间挽救了这么多人。 </p><p> An example of how to do this  right is systemd-resolved. It can do everything amodern split-DNS VPN needs natively, so in theory there’s no extra work (exceptsee below, because reality is not  quite as clean as we’d like). The systemdteam  painstakingly wrote down what theydo, andmade it unambiguously obvious how you should twiddle things to get what youwant. This is the kind of documentation that infrastructure programs shouldstrive to have.</p><p>如何执行此操作的示例是已解决的。它可以做所有Amodern Split-DNS VPN的所有东西都需要自然，所以理论上没有额外的工作（除了下面的除外，因为现实不像我们想要的那样干净）。 SystemDteam精心讲述他们的他们，andmade它明确明显明显，你应该如何旋转东西来获得你的东西。这是基础架构程序突出的那种文档。</p><p> Now, if you are in a place where you need to provide a DNS server on Linux, andhave to figure out how you should configure the system’s resolver, here is howyou do it.</p><p> 现在，如果您在Linux上提供DNS服务器的地方，并且弄清楚如何配置系统的解析器，那么这里就是如何做到。</p><p> Starting from the top, first you need to check if  /etc/resolv.conf exists atall. If it doesn’t you can just overwrite it:</p><p> 从顶部开始，首先需要检查Alall是否存在/etc/resolv.conf。如果不是，你不能覆盖它：</p><p>  If it does exist, then you need to check who the owner of the file is. You cancheck for the owner of  /etc/resolv.conf by looking for the magic words at thetop of  /etc/resolv.conf, such as these:</p><p>  如果确实存在，则需要检查文件的所有者是谁。您可以通过查找/etc/resolv.conf的魔术单词来查找/etc/resolv.conf的所有者。</p><p>    These will tell you which service manages your  /etc/resolv.conf file. If youcan’t find any owner you need to blow away  /etc/resolv.conf and hope for thebest.</p><p>    这些将告诉您哪个服务管理/etc/resolv.conf文件。如果您不会找到任何所有者，则需要吹掉/etc/resolv.conf并希望最为希望。</p><p> If  resolvconf is in use, then you should too, assuming of course the resolvconf binary is available on your  $PATH:</p><p> 如果正在使用的ResolvConf，那么您也应该在$ PATH上假设当然，您可以在$ PATH上提供resolvconf二进制文件：</p><p>  If the config seems owned by NetworkManager, you need to check if NetworkManageris available over D-Bus, and if so, you can use it. Otherwise, you’re back tooverwriting resolv.conf.</p><p>  如果Config似乎拥有NetworkManager，则需要检查NetworkManageris是否通过D-Bus提供可用，如果是，则可以使用它。否则，您将返回ToOverwriting arcorv.conf。 </p><p> NetworkManager also adds a wrinkle to the resolvconf path: if theresolvconf-generated configuration comes from NetworkManager, we want to try anduse NetworkManager rather than resolvconf, because NetworkManager is morecapable. So, we do an extra detection pass to see if resolvconf is being fed byNetworkManager, and switch to NetworkManager if so.</p><p>NetworkManager还将皱纹添加到RegryVconf路径：如果Theresolvconf生成的配置来自NetworkManager，我们希望尝试Andure NetworkManager而不是resolvconf，因为NetworkManager是难以征存的。因此，我们进行额外的检测通行证，看看rescrikvconf是否正在通过网络填充，并且如果是，请切换到NetworkManager。</p><p> And if resolvconf seems to be fed by NetworkManager, but we’re unable to talk toNetworkManager, we should fall back to using resolvconf.</p><p> 如果resolvconf似乎被networkManager喂养，但我们无法谈论TonetWorkManager，我们应该返回使用ResolvConf。</p><p>  If you’re using systemd-resolved, things should be smooth sailing… But there’s awrinkle. It turns out that NetworkManager, up until very recently, configuressystemd-resolved slightly incorrectly in a way that makes it impossible tooverride the default resolver if you’re talking to systemd-resolved yourself.This was fixed in December 2020 with NetworkManager 1.26.6 ( relevant bugreport).</p><p>  如果您正在使用Systemd-solutived，事情应该是平稳的帆船......但是有震惊。事实证明，NetworkManager，直到最近，CommentUressystemd  - 以一种方式略微解决，这使得如果您正在与Systemd-soluating yours oversing yoursformative，则无法实现默认解析器。这是在2020年12月的NetworkManager 1.26.6（相关的bugreport）。</p><p> So, if systemd-resolved is in use, we need to check if NetworkManager is alsopresent,  and whether it’s pushing its configuration into systemd-resolved. Ifso, we must use NetworkManager to configure DNS, even though its capabilitiesare slightly less than systemd-resolved.</p><p> 因此，如果正在使用的系统已解决，我们需要检查NetworkManager是否是Alspresent，以及它是否将其配置推向系统已解决。 IFSO，我们必须使用NetworkManager来配置DNS，即使它的能力略小于Systemd-solutived。</p><p>  As far as we understand, this setup will allow you to have a somewhat consistentway to configure DNS on Linux systems. We hope this will save you time whenfacts and circumstances force you to implement this logic in the future. Youwill also need to implement a “polyfill” for the DNS routing bits that yourservice needs, for every case where you don’t have a routing-aware DNSconfiguration (which on this graph is most of the cases).</p><p>  据我们所知，此设置将允许您在Linux系统上配置DNS有点一致。我们希望这将节省您的时间和环境在将来努力实施这一逻辑。对于您没有路由感知DNSConfiguration的每种情况，您还需要为您的服务需求的DNS路由位实现“Polyfill”，以便为您没有路由感知的DNSConfiguration（其中大多数情况下的情况）。</p><p> If you decide that you want to make some new DNS configuration managementservice in the future, please make sure it’s documented. Including itsinteractions with the rest of this graph.</p><p> 如果您决定将来要制作一些新的DNS配置管理服务，请确保已记录。包括与此图的其余部分的娱乐。</p><p> If you’re a Linux distro maintainer, you may be wondering what part of thishilarity you should inflict on your users. Our take is that you should usesystemd-resolved, and if you need user-friendly network configuration, a veryrecent version of NetworkManager (1.26.6 or better). This will give your distrostate-of-the-art DNS capabilities, and make implementers of networking softwaremuch happier. With this setup, the DNS configuration graph look like this:</p><p> 如果您是一个Linux Distro维护者，您可能会想知道您应该对您的用户施加的特征性的哪一部分。我们的认为是您应该使用ystemd解决，如果您需要用户友好的网络配置，则是NetworkManager（1.26.6或更好）的redrecent版本。这将为您提供艺术态度的DNS功能，使网络化软旺旺更快乐的实施者。使用此设置，DNS配置图形如下所示： </p><p>  The upcoming Tailscale 1.8 release implements all of the above, which shouldhopefully make DNS on Linux just work, no matter how your machine is choosing todo it.</p><p>即将举行的Tailscale 1.8释放实现了以上所有内容，它在Linux上就可以在Linux上制作DNS，无论您的机器如何选择如何。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tailscale.com/blog/sisyphean-dns-client-linux/">https://tailscale.com/blog/sisyphean-dns-client-linux/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sisyphean/">#sisyphean</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/task/">#task</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dns/">#dns</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>