<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Python对正则表达式的支持Python Support for Regular Expressions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Python Support for Regular Expressions<br/>Python对正则表达式的支持</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-23 21:33:11</div><div class="page_narrow text-break page_content"><p>The following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider  subscribing to LWN. Thank youfor visiting LWN.net!</p><p>LWN订户已向您提供以下仅限订阅的内容。成千上万的订阅者依靠LWN从Linux和自由软件社区获得最好的消息。如果您喜欢这篇文章，请考虑订阅LWN。感谢您访问LWN。网</p><p> Regularexpressions are a common feature of computer languages, especially higher-level languages like Ruby, Perl, Python, and others, for doingfairly sophisticated text-pattern matching. Some languages, includingPerl, incorporate regular expressions into the language itself,while others have classes or libraries that come with the languageinstallation. Python&#39;s standard library has the   re module,which provides facilities for working with regular expressions; as a recentdiscussion on the python-ideas mailing shows, though, that module hassomewhat fallen by the wayside in recent times.</p><p>正则表达式是计算机语言的一个常见功能，尤其是Ruby、Perl、Python等高级语言，用于进行相当复杂的文本模式匹配。有些语言（包括Perl）将正则表达式合并到语言本身中，而另一些语言则有随languageinstallation附带的类或库。蟒蛇&#39；s的标准库有re模块，它提供了处理正则表达式的工具；然而，正如最近关于python思想邮件的讨论所显示的那样，该模块在最近几次被搁置了。</p><p>  J.B. Langston  postedto the list on February 14; he had  filed a bug about a problemhe encountered using  re, which was closed with a suggestion that hebring it to the mailing list. Langston had a regular expression (which isoften abbreviated as &#34;regex&#34; or &#34;regexp&#34;) thatseemed to hang his program when applied to a rarely occurring log message;it turned out that there was a flaw in his regular expression, which caused an enormousamount of backtracking that, effectively, never completed. In the bug report, he wasasking for a way to specify a timeout: I will try to rewrite my regex to address this specific issue, but it&#39;shard to anticipate every possible input and craft a bulletproof regex, sosomething like this kind of thing can be used for a denial of serviceattack (intentional or not). In this case the regex was used in anautomated import process and caused the process to back up for many hoursbefore someone noticed. Maybe a solution could be to add a timeout optionto the regex engine so it will give up and throw an exception if the regexexecutes for longer than the configured timeout.</p><p>2月14日，J.B.兰斯顿登上榜单；他提交了一个关于他在使用re时遇到的一个问题的bug，并建议将其添加到邮件列表中。Langston有一个正则表达式（缩写为&#34；regex&#34；或&#34；regexp&#34；）当应用到很少出现的日志消息时，这似乎挂起了他的程序；事实证明，他的正则表达式中有一个缺陷，导致了大量的回溯，实际上，这些回溯从未完成。在bug报告中，他要求提供一种指定超时的方法：我将尝试重写我的正则表达式以解决这个特定问题，但它&#39；shard可以预测每一个可能的输入并设计一个防弹正则表达式，所以类似的东西可以用于拒绝服务攻击（无论是有意还是无意）。在本例中，regex用于自动导入过程，并导致该过程在有人注意到之前备份了许多小时。也许一个解决方案是在正则表达式引擎上添加一个超时选项，这样如果正则表达式执行的时间超过配置的超时时间，它就会放弃并抛出一个异常。</p><p> He elaborated his use case further in his post: My use case is log parsing and I have a large number of regexes that runover many different log lines. With the volume of regexes I have, it&#39;s hardto make sure every regex has no potential problems, especially when the pathological behavior only occurs on certain inputs that may not have beenanticipated when developing the regex. Also because of the volume of data these regexes are parsing, I would neverwant to allow a regex to run longer than a few milliseconds because if itdid, that would kill my log processing throughput. I&#39;d rather that it justraise an exception and move on to the next log entry.</p><p>他在帖子中进一步阐述了自己的用例：我的用例是日志解析，我有大量的正则表达式，它们运行在许多不同的日志行上。我有大量的正则表达式，它是&#39；很难确保每个正则表达式都没有潜在的问题，尤其是当病理行为只发生在某些输入上时，这些输入在开发正则表达式时可能没有被激活。此外，由于这些正则表达式正在解析的数据量很大，我决不想让正则表达式的运行时间超过几毫秒，因为如果它超过了几毫秒，这将降低我的日志处理吞吐量。我&#39；我宁愿它只是引发一个异常并继续下一个日志条目。</p><p> Jonathan Slenders  repliedthat the   regexmodule on the  Python Package Index(PyPI) has support for timeouts.  regex is meant to be both adrop-in replacement for  re (using its &#34;version 0&#34;) and to providesupport for additional regular-expression features when using &#34;version 1&#34;. Thosefeatures include nested sets, full Unicode case-folding by default,dropping the global interpreter lock (GIL) during matching for concurrency,and more. The  regex home page lists a whole raft of differenceswhen using version 1, including a  timeout parameter for thematching functions.</p><p>Jonathan Slenders回答说Python包索引（PyPI）上的regexmodule支持超时。regex是用来替代re的adrop（使用它的&#34；版本0&#34；）以及在使用&#34；版本1&#34；。这些特性包括嵌套集、默认情况下完整的Unicode大小写折叠、在匹配并发性时删除全局解释器锁（GIL）等等。regex主页列出了使用版本1时的一系列差异，包括匹配函数的超时参数。</p><p>  Tim Peters also  mentioned regex, though not because it implements timeouts (which issomething he only learned via the thread), but because it is &#34; aterrific module&#34; with many features from newer regular-expression implementations.It is &#34; alsoharder to provoke into exponential-time bad cases&#34;. He discussed some of the tradeoffs that come with regular expressions and recommended theclassic book,   MasteringRegular Expressions, for those struggling to use them well. Henoted that  SNOBOL, whichis a string-processing language from the 1960s, did not have regular expressions, thoughthere were tasks where it (andits successor of sorts,  Icon)were able to do matching in more natural ways: Naive regexps are both clumsy and prone to badtiming in many tasks that &#34;should be&#34; very easy to express. Forexample, &#34;now match up to the next occurrence of &#39;X&#39;&#34;. In SNOBOL andIcon, that&#39;s trivial. 75% of regexp users will write &#34;.*X&#34;, with scantunderstanding that it may match waaaay more than they intended.Another 20% will write &#34;.*?X&#34;, with scant understanding that mayextend beyond _just_ &#34;the next&#34; X in some cases. That leaves the happy5% who write &#34;[^X]*X&#34;, which finally says what they intended from thestart.</p><p>Tim Peters也提到了regex，虽然不是因为它实现了超时（这是他通过线程才学到的东西），而是因为它是&#34；三级模块&#34；具有更新的正则表达式实现的许多功能。它是&#34；也更难引发指数级的不良事件&#34；。他讨论了正则表达式带来的一些折衷，并向那些努力使用正则表达式的人推荐了经典书籍《掌握正则表达式》。他指出，SNOBOL是20世纪60年代的一种字符串处理语言，它没有正则表达式，尽管它（及其后继者，Icon）能够以更自然的方式进行匹配：天真的正则表达式既笨拙，又容易在许多任务中出现计时错误，这些任务&#34；应该是&#34；很容易表达。例如&#34；现在匹配到下一个出现的&#39；X&#39&#34;. 在斯诺博尔·安迪肯，这&#39；这很琐碎。75%的regexp用户会写&#34*X&#34；，因为它可能比他们预期的更符合Waaay。另外20%的人会写&#34；*？X&#34；，缺乏理解，这可能会超出_just&#34；下一个&#34；在某些情况下是X。这就剩下5%的幸福作家&#34；[^X]*X&#34；，这最终说明了他们的初衷。</p><p> Those who are not well-versed in regular-expression syntax may find some of that a bitpuzzling. While this article cannot be an introduction to regular expressions—there arecountless web sites, books, and other resources for that—we will try togive readers a bit of a leg up. In regular-expression syntax, &#34; .&#34; represents anysingle character, adding &#34; *&#34; says to match zero or moreoccurrences of the previous term, so &#34; .*&#34; matches any string,while &#34; .*X&#34; matches any string up to a literal &#34;X&#34;. But, as thefollowing example shows, that may not be exactly what the programmer had inmind:</p><p>那些不精通正则表达式语法的人可能会发现其中一些有点令人费解。虽然本文不能介绍正则表达式，但有无数的网站、书籍和其他资源，我们将尝试为读者提供一些帮助。在正则表达式语法中，&#34&#34; 表示任何单个字符，添加&#34*&#34; 表示匹配上一个术语的零次或多次出现，因此&#34*&#34; 匹配任何字符串，而&#34*X&#34；匹配任何字符串，最大值为#34；X&#34；。但是，正如下面的例子所示，这可能不是程序员的想法：</p><p> The  match value in the object returned from   re.search()shows that it matched all the way up to the second occurrence of &#34;X&#34; in thestring. That is becausethe &#34; *&#34; operator is &#34; greedy&#34;—itmatches as much as it can. The 20% case in Peters&#39;s message uses the non-greedy quantifier &#34; ?&#34; to get closer to the resultthat was asked for:</p><p>从re返回的对象中的匹配值。search（）显示它一直匹配到第二次出现&#34；X&#34；在字符串中。那是因为&#34*&#34; 接线员是&#34；贪婪&#34-它尽可能地匹配。彼得斯和#39；s消息使用非贪婪量词#34&#34; 为了更接近要求的结果：</p><p> The 5% case, &#34; [^X]*X&#34;, uses a negated character set,&#34; [^X]&#34;, which means to match anything  but &#34;X&#34;. So that regular expressioncan be read as &#34;match any characters that are not &#39;X&#39;, followed by &#39;X&#39;&#34;,but it may well not be the first thing that comes to mind. Steven D&#39;Aprano  wassurprised that &#34; .*?X&#34; might match beyond the next &#34;X&#34;, but Chris Angelico  pointedout that non-greedy does not mean it will only match to the next &#34;X&#34;: Nongreedy means it&#39;ll prefer the next X, but it has to be open tochecking others. The X between bbb and ccc won&#39;t result in a match, so the .*? has tocapture more.</p><p>5%的病例和#34；[^X]*X&#34；，使用否定字符集&34；[^X]&#34；，也就是说，除了&#34；X&#34；。因此，正则表达式可以理解为&#34；匹配任何不是&#39的字符；X&#39；，其次是&#39；X&#39&#34;,但这可能不是第一个想到的。史蒂文·D&#39；阿普拉诺很惊讶&#34；*？X&#34；可能超过下一个&#34；X&#34；，但Chris Angelico指出，不贪婪并不意味着它只会与下一个&#34；X&#34；：Nongreedy的意思是&#39；I’我更喜欢下一个X，但它必须对其他人开放。bbb和ccc之间的X赢了#39；结果不匹配，所以？必须捕捉更多。</p><p> The sub-thread extended a ways, looking into deeper aspects of matching &#34;upto the next &#39;string&#39;&#34;, which shows the complications that canarise—complete with mistaken &#34;solutions&#34;. As can be seen, regular expressions are a powerful mechanism, but they arecomplex, can beused inappropriately, and areprone to bugs of various sorts; they are also difficult to test fully andto debug when problems are encountered. But they have become ubiquitous intoday&#39;s computing landscape. Peters  said: As to why regexps prevailed, traction! They are useful tools, and_started_ life as pretty simple things, with small, elegant, andefficient implementations Feature creep and &#34;faster! faster! faster!&#34;turned the implementations more into bottomless pits now ;-)</p><p>子线程扩展了一种方式，深入研究了匹配的深层次方面&#34；直到下一个&39；字符串&#39&#34;, 这显示了伴随着错误的#34；解决方案&#34；。可以看出，正则表达式是一种强大的机制，但它们很复杂，可以不恰当地使用，并且容易出现各种各样的错误；它们也很难完全测试，遇到问题时也很难调试。但如今它们已经无处不在&#39；这是计算机领域。彼得斯说：至于为什么regexps占上风，牵引力！它们是有用的工具，而且u开始的时候非常简单，具有小、优雅和高效的实现功能，包括爬行和#34；快点！快点！快点&#34;现在把实现更多地变成了无底洞；-）</p><p> Matthew Barnett (&#34;MRAB&#34;), who is the developer of  regex,  agreedwith that assessment: Regexes were simple to start with, so only a few metacharacters wereneeded, the remaining characters being treated as literals. As new features were added, the existing metacharacters were used in newways that had been illegal until then in order to remainbackwards-compatible. Add to that that there are multiple implementations with differing (andsometimes only slightly differing) features and behaviours.</p><p>Matthew Barnett（&#34；MRAB&#34；），regex的开发人员同意这一评估：regex一开始很简单，所以只需要少数元字符，其余字符被视为文本。随着新功能的增加，现有的元字符被以新的方式使用，而在那之前，这些方式都是非法的，目的是为了重新兼容。此外，还有多个具有不同（有时只是略有不同）功能和行为的实现。</p><p>  Langston &#34; quite enjoyed reading&#34; the thread that resulted fromhis post, but wanted to see if there was support &#34; for adding a timeoutfeature to the Python re library&#34;. He said that he would beinvestigating  regex but still thought  re could benefitfrom a way to stop runaway regular expressions. Angelico  wasopposed to the idea, suggesting that some of the other matchingtechniques explored in the thread should be pursued instead.&#34; Itwould add overhead to common cases in order to put a shield aroundpathological ones, and it&#39;s difficult to impossible to usefully definethe cutoff.&#34;As he noted in his first reply, though, Peters  thinksthat no work is likely to be done on features for  re: Buried in the fun discussion was my guess: no way. Python&#39;s re iseffectively dead legacy code, with no current &#34;owner&#34;. Its commithistory shows very little activity for some years already. Mostcommits are due to generic &#34;code cleanup&#34; crusades that have nothingspecific to do with the algorithms. None required non-trivialknowledge of the implementation.</p><p>兰斯顿&#34；非常喜欢阅读&#34；这条线索来自他的帖子，但想看看是否有人支持&#34；用于将timeoutfeature添加到Python re库&#34；。他说他将调查正则表达式，但仍然认为re可以从阻止失控正则表达式的方法中获益。Angelico反对这一想法，建议应该采用线程中探索的其他一些匹配技术&#34; 它会增加普通病例的开销，以便在病态病例周围加上一道屏障，而且&#39；很难有效地定义截止时间&#34;不过，正如他在第一次回复中指出的那样，彼得斯认为不太可能在re的功能上做任何工作：埋没在有趣的讨论中的是我的猜测：不可能。蟒蛇&#39；s实际上是死气沉沉的遗留代码，没有当前的&#34；所有者&#34；。它的委员会几年来几乎没有活动。大多数承诺是由于通用的#34；代码清理&#34；与算法无关的十字军东征。没有人需要对实现有非常重要的了解。</p><p> Peters said that the code that makes up the  regex module was  originally targeted at becomingpart of core Python back in 2008 by its original author, JeffreyC. Jacobs; the work was  pickedup and carried forward by Barnett, and eventually turned into regex. The request to switch  re over to using it was  closed in 2021because of the existence of  regex in PyPI; &#34; If someone wantsto move it into the Python stdlib, I suggest to start on the python-ideaslist first.&#34;</p><p>Peters说，组成regex模块的代码最初的目标是在2008年由其原作者JeffreyC成为核心Python的一部分。雅各布斯；这项工作由巴内特挑选并继续进行，最终变成了正则表达式。由于PyPI中存在正则表达式，将re转换为使用它的请求于2021年关闭&#34; 如果有人想把它移到Python stdlib中，我建议先从Python ideaslist开始&#34;</p><p> The problem is that  regex has &#34; _dozens_ of features that would bevaluable to have in the standard library&#34;, Peters said, so: [N]o core dev I know of is going to devote theirlimited time to reproducing a tiny subset of regex&#39;s many improvementsin Python&#39;s legacy engine. In fact, &#34;install regex!&#34; is such anobvious choice at this point that I wouldn&#39;t even give time to justreviewing a patch that added timeouts.</p><p>问题是regex有&#34_标准库中有几十个有价值的功能&#34；，彼得斯说，所以：[N]据我所知，没有一个核心开发人员会将他们有限的时间用于复制正则表达式的一小部分&#39；Python有很多改进&#39；它的传统引擎。事实上&#34；安装正则表达式&#34; 在这一点上是如此不寻常的选择，以至于我不会&#39；我甚至没有时间回顾一个增加了超时的补丁。</p><p> Barnett  saidthat he eventually decided against having the  regex code added tothe standard library, at least in part because &#34; that would tie fixesand additions to Python&#39;s release cycle&#34;. Python is known for being&#34;batteries included&#34;, &#34; but not nuclearreactors&#34;, so having  regex in PyPI makes more sense, hesaid. Peters  thoughtthat some features in  regex might have been nuclear reactors backin 2008, but are being used more commonly today: [...] Python&#39;s re module is frozen in anever-receding past. Nobody wants to work on it because, well, &#34;regexalready does that! In fact, it&#39;s been doing it for 15 years already&#34;.</p><p>Barnett说，他最终决定不将正则表达式代码添加到标准库中，至少部分原因是&#34；这将把修复和添加绑定到Python中#39；s发布周期&#34；。Python以&#34；电池包括&#34&#34; 但不是核反应堆&#34；，因此，在PyPI中使用正则表达式更有意义，他说。彼得斯认为，regex中的一些功能可能早在2008年就已经出现在核反应堆上，但如今被更普遍地使用：[……]蟒蛇&#39；s re模块被冻结在一个不断后退的过去。没人想做这件事，因为，嗯，&#34；regexalready已经做到了！事实上，它&#39；他已经做了15年了；。</p><p> Peters also  pointedout that trying out  regex may be easier than Langstonrealized. In fact, because of the version 0 compatibility mode, he couldperhaps add a simple import to give it a whirl: In another message, Peters furtherdescribedwhat he meant by that: What I wrote here is more elaboration on that _trying_ this is easierthan they might be thinking: They don&#39;t have to, e.g., rewrite theirregexps, or invoke different function or method names, or worry thatthey&#39;ll get different results. The packages are highly compatible insyntax and semantics and APIs so long as you stick to the things redoes. That in no way suggests they _should_ stick to what re does.It&#39;s assuring them that _getting started_ is close to trivial. Theircurrent code should continue to work unchanged, apart from justchanging &#34;re&#34; to &#34;regex&#34;.</p><p>彼得斯还指出，尝试正则表达式可能比兰斯顿意识到的要容易。事实上，由于版本0的兼容性模式，他可能会添加一个简单的导入来让它运行起来：在另一条消息中，彼得斯进一步描述了他的意思：我在这里写的是更多的详细说明，这比他们可能想的要容易：他们不&#39；例如，不必重写它们的IRegexp，或者调用不同的函数或方法名，或者担心它们&#39；我会得到不同的结果。这些软件包与insyntax、语义和API高度兼容，只要你坚持重做的事情。这绝不意味着他们应该坚持re的做法。它&#39；他向他们保证“入门”几乎无关紧要。他们当前的代码应该保持不变，除了改变#34；re&#34；至&#34；regex&#34；。</p><p> It turns out that Langston&#39;s program  alreadyuses  regex &#34; via some transitivedependency&#34;, but he was  notimpressed with its performance when compared to  re. A testdata set of 700MB was processed in 77 seconds with  re but ittook 92 seconds with  regex. Peters  was&#34; mildly surprised&#34; by that, since: &#34; Most timespeople report that regex is at least modestly faster than re&#34;.   The performance of  regex seems like something that might needattention, especially if it is becoming the de facto regular-expression module forPython. Peters&#39;s analysis of the status of  re is somewhatdisheartening; it is apparently permanently stuck in the past. That may besufficient for many, however, but it somehow seems suboptimal to have twoseparate pieces of the Python ecosystem that both support the more limited re subset; most enhancements are likely to only go into regex so that  re falls further and further behind thestate of the art.</p><p>结果是兰斯顿&#39；s程序alreadyuses regex和#34；通过某种过渡依赖性#34；，但与re相比，他的表现并不令人印象深刻。一个700MB的测试数据集用re在77秒内处理完毕，而用regex处理则需要92秒。彼得斯34岁；有点惊讶&#34；至此，自：&#34；大多数时候，人们报告说regex至少比re&#34；稍微快一些；。regex的性能似乎需要注意，尤其是如果它正在成为Python的事实上的正则表达式模块的话。彼得斯&#39；s对稀土现状的分析令人震惊；它显然永远停留在过去。然而，这对许多人来说可能是足够的，但在Python生态系统中有两个单独的部分，都支持更有限的re子集，这似乎是次优的；大多数增强功能可能只会出现在正则表达式中，因此re越来越落后于最先进的技术。</p><p> Supplanting  re with  regex in the standard library (usingversion 0 by default) would seem attractive, though Barnett seems atleast somewhat cautious about doing so. A similar thing occurred with thepopular  Requests HTTPmodule, which was  considered as a possibleaddition to the standard library at the  2015Python Language Summit. The conclusion was that it made more sensefor Requests to stay out of the standard library because it moves fasterthan the normal Python release cadence (then 18 months, but now yearly),especially for security updates (which are done more frequently for thelanguage, but not as quickly as Requests can move on its own).</p><p>在标准库中用正则表达式取代re（默认情况下使用0版）似乎很有吸引力，不过巴内特似乎至少对这样做有些谨慎。同样的事情也发生在流行的Requests HTTPmodule上，在2015年的Python语言峰会上，它被认为是标准库的一个可能的补充。得出的结论是，对于不在标准库中的请求来说，它更有意义，因为它比正常的Python发布周期（当时是18个月，但现在是每年一次）移动得更快，尤其是在安全更新方面（对该语言进行更新的频率更高，但不如请求本身移动的速度快）。</p><p> The &#34;batteries included&#34; story for Python has been a major part of itssuccess over the years, but it is starting to fray in various ways. Forone thing, the large number of said batteries is straining the maintenance ability ofthe Python core developers. That has led to  discussions, a  Python Enhancement Proposal (PEP), and  further discussion about removing some partsof the library over the years. Most of the modules in the standard librarywere added long ago and, oncesomething is added, it is difficult to remove it—even if the reason for itsinclusion and the existence of maintainers for it have gone away.</p><p>34岁；电池包括&#34；多年来，Python的故事一直是其成功的一个主要部分，但它开始以各种方式受到影响。首先，大量的电池正在使Python核心开发人员的维护能力变得紧张。这导致了讨论、Python增强计划（PEP），以及多年来关于删除库中某些部分的进一步讨论。标准库中的大多数模块都是在很久以前添加的，一旦添加了方法，就很难删除它，即使包含它的原因和它的维护人员已经消失。</p><p> Meanwhile, regular expressions are clearly something that Python programmers use—a lot—sohaving the best support for them, in one place if possible, seems like theright approach. As Peters noted, they are a &#34; a tool with a hyper-concise notation, where acorrect expression is pretty much indistinguishable from line noise,and a typo is rarely detectable as a syntax error&#34;. Adding risks ofincompatibility (or differing performance) into the mix may not lead tomuch joy either. It is all a bit of a pickle, but not  that   pickle,of course.</p><p>同时，正则表达式显然是Python程序员使用的东西——因此，尽可能在一个地方为它们提供最佳支持似乎是正确的方法。正如彼得斯所指出的，他们是一个&#34；一种具有超简洁符号的工具，其中正确的表达式几乎无法与线条噪音区分开来，而且打字错误很少被检测为语法错误&#34；。在混合中增加不相容的风险（或不同的性能）可能也不会带来如此的快乐。这一切都有点棘手，但当然不是那么棘手。</p><p> On the other hand,  re, which was originally developed by FredrikLundh (who sadly  died back in November), doeswhat it needs to do for lots of different use cases. Those who need timeouts,  atomic groups,nested character sets,  possessivequantifiers, and other advanced features have a place to turn.Barnett seems keen to maintain the compatibility with  re, so itmay turn out to be a situation, like with Requests, where alternatives tothe standard library should be recommended, perhaps even in the Pythondocumentation. There is no clear and obvious &#34;right&#34; solution here it seems.</p><p>另一方面，re最初是由FredrikLundh（不幸地在11月去世）开发的，它不需要为许多不同的用例做什么。那些需要超时、原子组、嵌套字符集、所有格量词和其他高级功能的人可以求助。Barnett似乎热衷于保持与re的兼容性，因此它可能会变成一种情况，比如在请求中，应该推荐标准库的替代品，甚至在Python文档中也是如此。没有明确而明显的#34；对&#34；这里似乎有一个解决方案。</p><p>         ( Log in to post comments)</p><p>（登录发表评论）</p><p>  This article and discussion did not go the way I expected. Maybe my way of thinking is uncommon, but I avoid using the &#34;non-regular&#34; (in the theoretical sense of regular languages) features of regex at all costs. Sure, assertions and backreferences can simplify things, but at that point you&#39;re trying to implement logic in a quite arcane language, and you&#39;d likely be better served by writing that logic with, well, Python. I had assumed this discussion would naturally land on the issues of exponential backtracking, and a recommendation to switch to a truly &#34;regular&#34; expression engine, such as Google&#39;s re2. (A good background on this from Russ Cox is found here [1]).  Probably as a result of my attitude toward regex matching, I haven&#39;t really found any issues with the default &#34;re&#34; module, and didn&#39;t even know of the existence of &#34;regex&#34;, nor that it was a de-facto standard for many Python users -- I suppose I&#39;ve never felt that re lacked features.  In any case, I wonder of the original use case would have been solved by a truly &#34;regular&#34; engine, maybe with the option to switch to the more complex (and slower) engine for the rare cases where non-regular features are needed.</p><p>这篇文章和讨论没有按照我预期的方式进行。也许我的思维方式并不常见，但我避免使用&#34；非常规&#34；（在正规语言的理论意义上）不惜一切代价实现正则表达式的功能。当然，断言和反向引用可以简化事情，但在这一点上，你&#39；我们试图用一种相当神秘的语言来实现逻辑，而你&#39；用Python编写这种逻辑可能会更好。我本以为这次讨论会自然而然地涉及指数回溯的问题，以及一个切换到真正的&#34；常规&#34；表达式引擎，如谷歌&#39；这是re2。（Russ Cox对此有很好的背景[1]）。可能是因为我对正则表达式匹配的态度，我没有&#39；我没有发现默认设置有任何问题#34；re&#34；模块，并且没有&#39；我甚至不知道&#34的存在；正则表达式&#34；，对于许多Python用户来说，它也不是事实上的标准——我想我&#39；I’我从来没有觉得你缺少特征。在任何情况下，我都不知道最初的用例是否会由一个真正的&#34；常规&#34；引擎，可能可以选择切换到更复杂（和更慢）的引擎，以满足少数需要非常规功能的情况。</p><p> Same, I enjoyed the &#34;contrast&#34; between:  &gt; As can be seen, regular expressions are a powerful mechanism, but they are complex, can be used inappropriately, and are prone to bugs of various sorts; they are also difficult to test fully and to debug when problems are encountered. [...] They are useful tools, and _started_ life as pretty simple things, with small, elegant, and efficient implementations Feature creep and &#34;faster! faster! faster!&#34; turned the implementations more into bottomless pits now ;-)  and:  &gt; Those who need timeouts, atomic groups, nested character sets, possessive quantifiers, and other advanced footguns ...</p><p>同样，我喜欢&#34；对比度&#34；之间：&gt；可以看出，正则表达式是一种强大的机制，但它们很复杂，可能使用不当，并且容易出现各种各样的错误；在遇到问题时，它们也很难进行全面测试和调试。[...] 它们是有用的工具，而且u开始时u生活非常简单，具有小、优雅和高效的实现功能，包括爬行和#34；快点！快点！快点&#34; 现在把实现更多地变成了无底洞；-）和：&gt；那些需要超时、原子组、嵌套字符集、所有格量词和其他高级步兵的人。。。</p><p>  &gt; (A good background on this from Russ Cox is found here [1]).  &gt; [1]:  https://swtch.com/~rsc/regexp/regexp1.html  Thanks for that link. That is certainly an enlightening read. Make me wonder if what is *really* needed isn&#39;t a &#34;simple-re&#34; module with a &#34;Thompson NFA&#34; regex engine. A 6 digit speedup should be worth aiming for after all</p><p>&gt；（Russ Cox对此有很好的背景[1]）&gt；[1]:  https://swtch.com/~rsc/regexp/regexp1。谢谢你的链接。这无疑是一本启发性的读物。让我想知道，真正需要的是什么；34岁；简单的re&#34；带有&#34的模块；汤普森NFA&#34；正则表达式引擎。毕竟，6位数的加速应该是值得追求的</p><p>  I feel like the real question here is less what python is going to do about regex specifically, but what they can do about the &#34;The standard library is where modules go to die&#34; situation. Importing the current state of the art in regex library into the cpython repository is going to be nice for a bit, but it doesn&#39;t really do anything to address the reasons that it came to be neglected in the first place. It would effectively crowd out an actively maintained pypi module in favor of a soon-to-be-unmaintained standard library one once again, as keeps happening. Surely that&#39;s not in the ecosystem&#39;s best interest.</p><p>我觉得这里真正的问题不是python具体对regex做什么，而是他们能对&#34；标准库是模块去死的地方&#34；情况将regex库中的最新技术导入到cpython存储库中会有一段时间不错，但它没有&#39；I don’我真的没有做任何事情来解决它一开始被忽视的原因。它将有效地排挤一个积极维护的pypi模块，而再次支持一个即将无法维护的标准库模块，就像不断发生的那样。当然是&#39；它不在生态系统中&#39；这是最大的利益。</p><p> There is no reason you can&#39;t have both (stdlib and pypi). Ruby, for example, ships some gems by default, which you can upgrade independently in your Gemfile. This opens a path for removal from the stdlib: recommend to &#34;just add foo to your gemfile&#34; and then it can be removed from the included batteries in a later release. They did this in ruby 3 iirc.</p><p>你没有理由&#39；t两者都有（stdlib和pypi）。例如，Ruby默认提供一些gem，您可以在gem文件中独立升级。这为从stdlib中删除打开了一条路径：推荐至&#34；只需将foo添加到您的gemfile#34；然后在以后的版本中可以将其从附带的电池中移除。他们是在ruby 3 iirc中完成的。</p><p>  I really wish Python releases came bundled with particular versions of some well-managed PyPI packages you could upgrade further. You should be able to rely on the fact that &#34;regex&#34; is present, and that it conforms to the documentation frozen when 3.9 came out, but not that is doesn&#39;t have undocumented features from the future or that it still has bugs that hadn&#39;t been discovered.  AFAICT, &#34;requests&#34; hasn&#39;t removed any documented features since 2015; on the other hand, &#34;construct&#34; has not been as stable, even over a shorter period of time.</p><p>我真的希望Python发行版能与一些管理良好的PyPI包的特定版本捆绑在一起，您可以进一步升级。你应该能够相信这样一个事实&#34；正则表达式&#34；它符合3.9版本发布时冻结的文件，但并非如此；没有未来的未记录功能，或者它仍然有以前没有的bug&#39；没有被发现。AFAICT和#34；请求&#34；没有&#39；自2015年以来，t删除了任何记录在案的功能；另一方面&#34；建造&#34；即使在较短的时间内，情况也没有那么稳定。</p><p> I feel like almost every language does packaging and dependencies poorly, and they all just find different ways of being terrible (albeit most also have some redeeming qualities). In the case of Python:  * On the one hand, import statements use a relatively straightforward, easy to understand set of semantics (i.e. &#34;just stick a bunch of py files in a directory structure, and you&#39;re done!&#34;). This is good for scripting purposes, because you don&#39;t have to faff about with something like CMake just to build an entirely self-contained app. * On the other, those semantics are perhaps *too* simple, because there is no way to specify &#34;I need version X or greater&#34; within the import statement itself, nor where the module actually comes from. So now that information needs to live in metadata somewhere, and get tracked and managed separately by a tool like Pip. * To add insult to injury, you can&#39;t have two different versions of the same module in the same process, without doing all sorts of nasty hacks that may or may not break something depending on how the underlying module works (e.g. Does it check __name__? Does it fiddle around with sys.modules? etc.). * And, of course, you have the common beginner mistake of accidentally naming a Python script after a stdlib module (Python will prefer to re-import the script a second time, rather than using the stdlib module, and then everything breaks because it probably won&#39;t implement the stdlib module&#39;s API). This can break backcompat if a new stdlib module is introduced with the same name as one of your existing modules, but for some reason nobody seems</p><p>我觉得几乎每种语言的包装和依赖性都很糟糕，它们都会以不同的方式变得糟糕（尽管大多数语言也有一些弥补的品质）。在Python的例子中：*一方面，import语句使用了一组相对简单易懂的语义（即&#34；只需在目录结构中粘贴一堆py文件，就可以&#39；完成了！&#34；）。这对于脚本编写非常有用，因为您不需要&#39；I don’我不必为了构建一个完全独立的应用程序而去摆弄像CMake这样的东西。*另一方面，这些语义可能太简单了，因为无法指定&#34；我需要版本X或更高版本&#34；在import语句本身中，也不是模块的实际来源。因此，现在这些信息需要存在于某个元数据中，并通过Pip之类的工具分别进行跟踪和管理。*雪上加霜的是，你可以&#39；t在同一个过程中，同一个模块有两个不同的版本，而不进行各种恶劣的黑客攻击，这些攻击可能会破坏某些东西，也可能不会破坏某些东西，这取决于底层模块的工作方式（例如，它是否检查_name_________;它是否摆弄sys.modules？等等）。*当然，初学者常犯的错误是，不小心将Python脚本命名为stdlib模块（Python更愿意第二次重新导入脚本，而不是使用stdlib模块，然后一切都会中断，因为它可能无法实现stdlib模块的API）。如果一个新的stdlib模块与您现有的一个模块同名，但由于某些原因，似乎没有人使用它，这可能会破坏backcompat</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/正则表达式/">#正则表达式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/support/">#support</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>