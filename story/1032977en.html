<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Dark的新后端将在F#(2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dark的新后端将在F#(2020)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 22:51:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/c71cf32a9b845cee62d402a50d3fb46b.jpeg"><img src="http://img2.diglog.com/img/2020/11/c71cf32a9b845cee62d402a50d3fb46b.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Nothing in my life so far would have prepared me for the fact that I would be willfully choosing to move to .NET, but it&#39;s 2020, and nothing matters anymore.</p><p>到目前为止，我的生活中还没有任何东西让我做好准备，因为我会故意选择迁移到.NET，但现在已经是2020年了，什么都不重要了。</p><p> I&#39;ve been evaluating new languages for the Dark backend over the last 2 months or so. For a  bunch of reasons, OCaml has been a little unsatisfactory.</p><p>在过去的两个月左右的时间里，我一直在为Dark Backend评估新的语言。由于一系列原因，OCaml的表现有点不令人满意。</p><p> Over the last few years we&#39;ve always said &#34;when we rewrite the backend&#34;, &#34;at some point we&#39;ll rewrite and this will go away&#34;, etc. There&#39;s a lot of new code to be written on the backend, to meet our roadmap. Are we really going to write it once, and then rewrite it later? Or would it be faster to just port it now, and write the new code in the new stack?</p><p>在过去的几年里，我们总是说，当我们重写后端时，我们将在某个时候重写，这将会消失，等等。有很多新的代码需要在后端编写，以满足我们的路线图。我们真的要写一次，然后再重写吗？或者现在直接移植，然后在新堆栈中编写新代码会更快吗？</p><p> Ultimately, I decided that if there was going to be a change, now was the time. And more importantly, if there wasn&#39;t going to be a change, now was an excellent time to fully commit to OCaml, and not be second guessing the choice.</p><p>最终，我决定，如果要做出改变，现在就是时候。更重要的是，如果不会有什么变化，那么现在是完全致力于OCaml的绝佳时机，而不是第二次猜测这个选择。</p><p> Initially, I expected to go to Rust.  Rust has excellent tooling, great libraries, a delightful community, etc. But after spending about a month on it, I can&#39;t say I like writing Rust. Especially, I don&#39;t like writing async code in Rust. I like a nice high level language, and that&#39;s kinda what you need when you have a project as big as Dark to build. And Rust is not that. I&#39;ll publish &#34;Why Dark didn&#39;t choose Rust&#34; next. Or I might call it &#34;you&#39;ll never believe just how much a Garbage Collector does for you!&#34;, because that&#39;s the summary.</p><p>起初，我希望去“铁锈”。Rust有很好的工具，很棒的库，一个令人愉快的社区，等等。但是在上面花了大约一个月的时间，我不能说我喜欢写Rust。尤其是，我不喜欢用Rust编写异步代码。我喜欢一种很好的高级语言，当你有一个像Dark这样大的项目要构建时，这就是你需要的。而铁锈不是那样的。接下来，我将发表“黑暗为何没有选择生锈”一书。或者我可以称之为“垃圾收集器”，你永远不会相信垃圾收集器为你做了多少事，因为这就是总结。</p><p> When I was working on  Async benchmarks before, what I was really doing was evaluating &#34;are any of these OCaml alternatives better? And if so are they also faster?&#34;. I evaluated and expected not to like F#. I actually quite like it. It&#39;s close enough to OCaml, has great library support, and tooling which so far has been a mix of great and terrible. The 90&#39;s Microsoft tooling is still there, and that bit isn&#39;t all that great, but overall it&#39;s a much better situation than OCaml or Rust.</p><p>当我之前从事异步基准测试时，我真正做的是评估这些OCaml替代品中有没有更好的？如果是这样的话，它们也更快吗？我进行了评估，预计不会喜欢F#。我其实挺喜欢的。它与OCaml足够接近，有很好的库支持，而且到目前为止工具也是好的和糟糕的混合在一起。90年代的微软工具仍然在那里，这个比特并不是那么好，但总的来说，它比OCaml或Rust要好得多。</p><p>  Let&#39;s start with the obvious, F# is OCaml. It&#39;s OCaml backed by the world&#39;s largest and most experienced creators of programming languages. And in the areas that OCaml is great, F# is also great! Sum types, static typing, eager execution, pipelines, immutable values, all of this is really great.</p><p>让我们从显而易见的开始，F#是OCaml。它是由世界上最大和最有经验的编程语言创建者支持的OCaml。在OCaml很棒的领域，F#也很棒！SUM类型、静态类型、急切执行、管道、不可变值，所有这些都非常棒。</p><p> It actually has a much better type system, in my opinion. One thing that sticks out is that OCaml made it really cumbersome to use maps. Like, hashtables, associative arrays, whatever you call them. It seems the old version of Real World OCaml has been taken down, so I can&#39;t show you how unpleasant they were at the start. Now, in the latest version, they are  more moderately unpleasant to use. Whereas in F#, you have a  Map&lt;OneType,AnotherType&gt; and that&#39;s really it. Magic!</p><p>在我看来，它实际上有一个更好的类型系统。突出的一点是，OCaml使地图的使用变得非常麻烦。比如哈希表，关联数组，随便你怎么称呼它们。看起来老版的真实世界OCaml已经被撤下了，所以我不能向你展示他们一开始有多令人不快。现在，在最新版本中，它们使用起来更加不舒服。而在F#中，你有一个Map&lt；OneType，AnotherType&gt；，这就是真正的地图&lt；OneType和AnotherType&gt；。魔法！</p><p> Of course, the main reason I chose .NET was the libraries. It has libraries for everything, what a surprise. While there aren&#39;t all that many F# first-party libraries, every vendor out there has a .NET SDK that you can use directly from F#. I look forward to finally having first-party support for  Honeycomb,  Rollbar, and Google Cloud. I&#39;m even finally going to get to use  LaunchDarkly, after  years of telling Edith I would.</p><p>当然，我选择.NET的主要原因是库。它什么都有图书馆，真令人惊讶。虽然没有那么多的F#第一方库，但是每个供应商都有一个.NETSDK，您可以直接从F#使用。我期待着最终获得对Honeycomb、Rolbar和Google Cloud的第一方支持。多年来我一直告诉伊迪丝我会的，现在我甚至终于可以使用LaunchDarry了。</p><p> The other thing I&#39;ve really enjoyed is how good the docs and community content are. A lot of OCaml community content is on the language and what you can do with it. F# developers seem to just want to get shit done. There&#39;s a million blog posts, youtube videos, etc, from enterprise software developers talking about the best way to build web software. And then of course the massively detailed and useful  FSharpForForAndProfit, as well as  Tomas Petricek&#39;s work - it&#39;s really great.</p><p>我真正喜欢的另一件事是文档和社区内容有多好。很多OCaml社区内容都是关于这门语言的，以及你能用它做些什么。F#开发人员似乎只想把狗屎做完。有数以百万计的博客帖子、YouTube视频等等，来自企业软件开发人员，他们在讨论构建Web软件的最佳方式。当然，还有非常详细和有用的FSharpForAndProfit，以及托马斯·彼得里克的作品-它真的很棒。</p><p> I think most of this is due to the size of the community. I&#39;ve heard people say that there are very few F# developers; something like there&#39;s 1M C# users, 100k VB users, and 10K F# users, or something like that. I&#39;m not sure exactly what counts as user, but I would imagine that OCaml has fewer than 100 &#34;users&#34; in this metric, so it feels like I&#39;m moving to a massive community.</p><p>我认为这主要是因为社区的规模。我听人说过F#开发人员很少，大约有100万C#用户、10万VB用户和10K F#用户，或者类似的东西。我不确定到底什么才算用户，但我可以想象，在这个指标中，OCaml的用户不到100人，所以感觉我正在向一个庞大的社区进军。</p><p> Not everything is amazing though. The build system is attrocious. While  paket is roughly on par with  esy, msbuild is 1000 times worse than  dune. An incremental build in dune is like 1s for me, and 6s in .NET, even if nothing is happening. I know they have fancy incremental compilers for .NET so this puzzles me; if anyone has tips on getting really fast compilation in F#,  I would appreciate them.</p><p>不过，并不是每件事都令人惊叹。这套建筑系统很不美观。虽然paket与esy大致相当，但msbuild比沙丘差1000倍。在沙丘中的增量构建对我来说就像1，在.NET中就像6，即使什么都没有发生。我知道他们有漂亮的.NET增量式编译器，所以这让我感到困惑；如果有人有关于用F#进行真正快速编译的提示，我将不胜感激。</p><p> An important thing to check was whether I could compile my code to JS. Dark&#39;s execution engine runs it the editor as well, and that&#39;s one of the core things that makes Dark special. Because of this, I want to take unaltered backend code and compile it directly to JS. This isn&#39;t like  Rescript (which is OCaml compiled to JS with slightly different semantics and ecosystem, or it&#39;s equivalent in F#,  Fable). Fortunately, F# code can be compiled to Wasm using  Blazor. Blazor compiles the .NET runtime to WASM and runs your code in that. It  barely took any code to get working either (though figuring out the right incantation was not trivial).</p><p>需要检查的一件重要事情是我是否可以将代码编译成JS。Dark的执行引擎也可以在编辑器中运行它，这是Dark与众不同的核心特性之一。正因为如此，我想采用未经更改的后端代码，并将其直接编译为JS。这不像Rescript(它是OCaml编译成的JS，语义和生态系统略有不同，或者是F#中的等价物，寓言)。幸运的是，F#代码可以使用Blazor编译成Wasm。Blazor将.NET运行时编译成WASM，并在其中运行您的代码。它也几乎不需要任何代码就能运行(尽管找出正确的咒语并不是一件容易的事)。</p><p>  Yesterday&#39;s post got a lot of people to add their opinions. In addition to some  Scala and  Erlang love, a lot of people pointed to F#:</p><p>昨天的帖子吸引了很多人发表意见。除了一些Scala和Erlang的喜爱之外，很多人还提到了F#：</p><p> So...I think a decent choice to make here is to switch from OCaml to F#. You&#39;ll get almost all of the benefits and most of the drawbacks go away. And for the most part, you can directly translate the code from OCaml to F#. -  darksaints</p><p>所以…我认为在这里做一个不错的选择是从OCaml切换到F#。你会得到几乎所有的好处，而大部分缺点都会消失。在大多数情况下，您可以直接将代码从OCaml转换为F#。-黑暗圣徒。</p><p> I&#39;ve been using F# on GCP in production for 3 years now and it&#39;s fantastic and only getting better. You can leverage existing .NET libraries (for example, you get official GCP libraries from google) and if you use them enough it&#39;s easy enough to write a functional wrapper around them. -  angio</p><p>我已经在生产中的GCP上使用F#3年了，它非常棒，而且只会变得更好。您可以利用现有的.NET库(例如，您可以从Google获得官方的GCP库)，如果您足够多地使用它们，就可以很容易地为它们编写一个函数包装器。-血管造影</p><p> We have considered OCaml but went for F# instead. I could not be happier. Great libraries, good tooling, in 2020 F# is a first class citizen in the cloud thanks to C# and .NET Core. You can develop on Linux, Windows, MacOS and without modification it works. Compilation times are great. Unless you want to deal with the low level nature and the C++ influence in Rust F# is a much more logical step to move from OCaml. There is dotnet fsi for REPL too. F# has access to C# libraries and it is relatively easy to write a thin wrapper that convert nulls to Nones, so you are null safe or C# style functions to ML style functions so you can use |&gt; or &lt;| etc. -  l1x</p><p>我们考虑过OCaml，但选择了F#。我高兴得不能再高兴了。很棒的库，很好的工具，在2020年，多亏了C#和.NET Core，F#成为了云中的头等公民。您可以在Linux、Windows、MacOS上进行开发，无需修改即可运行。编译时间很长。除非您想要处理Rust中的低级特性和C++影响，否则F#是从OCaml迁移到更符合逻辑的步骤。还有适用于REPL的DotNet FSI。F#可以访问C#库，并且编写将NULL转换为None的薄包装器相对容易，因此您是NULL安全的或C#样式函数到ML样式函数，这样您就可以使用|&gt；或&lt；|etc.-l1x。</p><p>  I recently merged the  first F# code into the codebase. It&#39;s an async version of the core of the Dark interpreter, connected to Giraffe (F#&#39;s low-level interface to .NET&#39;s Kestrel web server).</p><p>我最近将第一个F#代码合并到代码库中。它是Dark解释器核心的异步版本，连接到长颈鹿(F#39；与.NET的Kestrel Web服务器的低级接口)。</p><p> My plan is to reimplement the same language, but with some of the learnings that are in the  roadmap. For example:</p><p>我的计划是重新实现相同的语言，但需要学习路线图中的一些内容。例如：</p><p> Int will be infinite precision (this is technically a breaking change, but not a significant one AFAICT)</p><p>INT将是无限精确的(从技术上讲，这是一个突破性的变化，但不是AFAICT的重大变化)。</p><p> I&#39;ll be working on making the equivalent to the existing Dark interpreter, keeping the semantics the same. After that, I&#39;ll be making new features from the  Dark Roadmap.</p><p>我将致力于使其等同于现有的Dark解释器，保持语义不变。在那之后，我将从“黑暗路线图”中制作新的功能。</p><p>  Dark&#39;s backend is 37K lines of OCaml, of which 8K lines are tests, and 10K lines are the Dark standard library. So there&#39;s about 20K lines to port. Should be fun. My implementation plan is to get to parity - there&#39;s plenty of time after that to take advantage of the ecosytem:</p><p>Dark的后台是37K行的OCaml，其中8K行是测试，10K行是Dark标准库。所以到港口大约有两万条线路。应该会很有趣的。我的实施计划是实现平价-在此之后还有足够的时间来利用生态系统：</p><p> make an OCaml library to deserialize the binary opcodes in the DB and covert them into F# (via, I presume, a JSON intermediary). This will allow incoming requests to (optionally) be routed to the F# service.</p><p>创建一个OCaml库来反序列化DB中的二进制操作码，并将它们转换为F#(我假设是通过JSON中介)。这将允许(可选的)将传入请求路由到F#服务。</p><p> add a fuzzer to ensure the semantics of the OCaml and F# versions of Dark are the same (especially the library functions)</p><p>添加模糊器以确保OCaml和F#版本的Dark的语义相同(尤其是库函数)</p><p>     start recording traces using  the new design (this is actually the main thing driving the whole change, believe it or not!)</p><p>开始使用新设计记录痕迹(信不信由你，这实际上是推动整个更改的主要原因！)。</p><p> There&#39;s lots to do, and  Dark contributors are welcome to take part. Porting standard library functions might be an easy place to get started, as is adding language features. Most things are a straight port from OCaml, except as mentioned above. As always, feel free to ask in  the Slack or  issues if you&#39;ve any questions.</p><p>有很多事情要做，欢迎黑暗贡献者参加。移植标准库函数可能是一个简单的入门之处，添加语言功能也是如此。除了上面提到的以外，大多数东西都是直接来自OCaml的端口。和往常一样，如果你有任何问题，请随时在“空档”或“问题”中提问。</p><p>  You can sign up for Dark      here    . For more info on Dark, follow our      RSS    , follow      us     (or      me    ) on Twitter, join our      Slack Community    , or watch our      GitHub repo    .</p><p>你可以在这里报名参加“黑暗”。欲了解更多关于Dark的信息，请关注我们的RSS，在Twitter上关注我们(或我)，加入我们的松弛社区，或观看我们的GitHub回购。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.darklang.com/new-backend-fsharp/">https://blog.darklang.com/new-backend-fsharp/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dark/">#dark</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ocaml/">#ocaml</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032972.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d2db3b6adfdf5517e228d413950a9070.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032972.html">2020沃尔沃V60越野：如何毁掉旅行车</a></div><span class="my_story_list_date">2020-11-3 22:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032802.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a0e0fde123b00309179ee652dbf6189f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032802.html">
相对论太空的蒂姆·埃利斯将参加TC Sessions：Space 2020</a></div><span class="my_story_list_date">2020-11-3 0:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032630.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d1f97801644aa76bf904e9d04313d5c8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032630.html">一辆古董雅达利是2020年的天气终点站</a></div><span class="my_story_list_date">2020-11-1 22:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032627.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b8aa2e2c515cb21f94bc60774989bac9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032627.html">现在是2020年。为什么打印机还在烂呢？</a></div><span class="my_story_list_date">2020-11-1 22:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>