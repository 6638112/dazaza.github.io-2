<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Gitlab 14.0发布 Gitlab 14.0 Released</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Gitlab 14.0 Released<br/>Gitlab 14.0发布 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-23 05:13:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/c7f5a18c060405cc9f936ff51d842d56.png"><img src="http://img2.diglog.com/img/2021/6/c7f5a18c060405cc9f936ff51d842d56.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When we think of everything released in the year since GitLab 13.0, we could not be more proud of our community and our team. This month, we celebrate our release of GitLab 14.0 by first taking a step back.</p><p>当我们想到自Gitlab 13.0以来一年中发布的一切时，我们无法为我们的社区和我们的团队感到骄傲。本月，我们首先返回辞职，我们庆祝我们的Gitlab 14.0发布。</p><p> Together, we’ve made so much progress over the last year that we want to talk about everything it took to get to  GitLab 14.</p><p> 在一起，我们在去年我们谈到了我们想谈论到Gitlab 14所采取的一切的进展。</p><p> We use semantic versioning so a point release, like 14.0, represents everything new in this month. GitLab 14 is the culmination of the past year. Even more than that, GitLab 14 represents the future of GitLab, and the future of DevOps.</p><p> 我们使用语义版本控制，因此点发布，如14.0，表示本月新的一切。 Gitlab 14是过去一年的高潮。甚至超过那个，Gitlab 14代表了Gitlab的未来，以及Devops的未来。</p><p> With GitLab 14, teams of all sizes are moving from maintaining DIY DevOps toolchains to adopting modern DevOps. GitLab 14 is a complete DevOps platform with security embedded in its DNA, visibility and insights enabled by its single data store, and a seamless experience and extensible system, so end users and enterprises alike reap the benefits of speed and efficiency.</p><p> 与Gitlab 14一起，各种尺寸的团队正在维持DIY Devops Toolchains采用现代Devops。 Gitlab 14是一个完整的Devops平台，具有嵌入其DNA的安全性，可通过其单一数据商店启用的可见性和见解，以及无缝体验和可扩展系统，因此最终用户和企业相似地获得了速度和效率的好处。</p><p> We’re so excited that we’ve written a post where you can  read more about GitLab 14 and our vision for modern DevOps, and how it enables any team to build and deliver software with velocity, visibility, and trust.</p><p> 我们很兴奋，我们写了一篇关于Gitlab 14的更多关于Gitlab 14的帖子以及我们对现代Devops的愿景以及它如何使任何团队能够以速度，可见性和信任提供构建和交付软件。</p><p> As ever, we are also excited about what’s new this month in 14.0. Read on for our regular highlights from dozens of significant new features and improvements. Along with these exciting new features, there are a few  breaking changes in 14.0. To preview what&#39;s coming in next month’s release, check out our  Upcoming Releases page, which includes our 14.1 release kickoff video.</p><p> 常见的是，我们对本月在14.0时令人兴奋。阅读我们的常规亮点，从数十个重要的新功能和改进。除了这些令人兴奋的新功能之外，14.0次有几种破碎变化。预览下个月发布中的内容＆＃39;查看了我们即将推出的版本页面，其中包括我们的14.1发行启动视频。</p><p>  Mathieu has contributed significantly to the Package stage with his work on both the Debian and Helm package registries. These direction features have been fully contributed by Mathieu thus far.</p><p>  Mathieu在Webian和Helm封装注册机构上的工作中对包裹阶段作出了重大贡献。迄今为止，这些方向特征已完全由Mathieu提供。 </p><p> The effort to implement  Debian packages has been ongoing since September of 2020. Approximately 38 MRs merged so far, and now we are nearing the end of the  iterative plan that Mathieu put together and maintained. As a result of Mathieu’s efforts, we are just a few merge requests away from feature completion and release.</p><p>自2020年9月以来，努力实施Debian包的努力。到目前为止，大约38夫人合并，现在我们临近Mathieu组合和维持的迭代计划的结束。由于Mathieu的努力，我们只是几个合并了远离功能完成和发布的请求。</p><p> Mathieu also planned the  Helm Charts Package Manager effort and has been working on that over the past three months. In this work, Mathieu has embraced the GitLab values of iteration and collaboration, working closely with the entire Package team and beyond on these and many other features.</p><p> Mathieu还计划了掌舵图表的套餐经理努力，并在过去的三个月里致力于这一点。在这项工作中，Mathieu已经接受了迭代和协作的Gitlab价值，与整个包装团队密切合作，超越这些和许多其他功能。</p><p>   Epic Boards align teams and organizations by communicating the status of epics continuously. Previous versions of GitLab required you to view and sort epics in a list to view the overall status. Keeping epics up to date meant making most changes through an epic’s detail page. Epic Boards enable you to visualize and refine all of your epics in one place, using a customizable, drag-and-drop interface that is easy for any teammate to understand and collaborate.</p><p>   Epic Loards通过持续沟通EPIC的状态对齐团队和组织。以前版本的Gitlab需要您在列表中查看和排序ePIC以查看整体状态。将史诗保持最新意味着通过Epic的详细信息页面使大多数更改。 Epic Loards使您可以在一个地方可视化和优化所有史诗，使用可自定义的拖放界面在一个地方进行可自定义的，拖放界面，这很容易理解和协作。</p><p> Epic Boards are also a game-changer for managing and visualizing ideal epic workflows, such as authoring workflow states (Draft, Writing, Done), DevOps workflow states (such as Planned, In Development, and In Production), or any other mutually exclusive states you might model with scoped labels. Visualizing workflows with an Epic Board empowers you to increase predictability and efficiency.</p><p> EPIC板也是一个游戏更改器，用于管理和可视化理想的史诗工作流程，例如创作工作流状态（草稿，写作，完成），Devops工作流状态（例如计划，在开发和生产中），或任何其他互斥的互斥您可能会使用范围标签模型。用史诗委员会赋予您提高可预测性和效率的工作流程。</p><p>  Terraform modules play a central role in building standard infrastructure components throughout an organization. Up to GitLab 13.12, GitLab users had to use either a third-party Terraform module registry, local modules, or Git-based modules. While these options work well, they do not help with the distribution of the modules and they lack proper versioning support, which introduces risks for module users. GitLab 14.0 extends our  Infrastructure-as-Code offerings with a Terraform module registry. Now, you can use the Terraform module registry built into GitLab to discover Terraform modules with semantic versioning support for upgrades and maintenance. Moreover, you can publish modules easily using GitLab CI/CD.</p><p>  Terraform模块在整个组织中建立标准基础设施组件方面发挥着核心作用。到Gitlab 13.12，Gitlab用户必须使用第三方Terraform模块注册表，本地模块或基于Git的模块。虽然这些选项良好，但它们没有帮助模块的分发，并且缺乏适当的版本控制支持，这引入了模块用户的风险。 Gitlab 14.0将我们的基础架构 - 以代码产品扩展到Terraform模块注册表。现在，您可以使用内置Giitlab中的Terraform模块注册表，以发现具有语义版本控制的Terraform模块，用于升级和维护。此外，您可以使用Gitlab CI / CD轻松发布模块。</p><p> While following Terraform’s best practices, we recommend developing each Terraform module in a dedicated GitLab project. To simplify the transition to the registry, users can host and publish multiple modules from a single GitLab repository. You can learn more about publishing and consuming a new module  in our documentation.</p><p> 在遵循Terraform的最佳实践时，我们建议在专用Gitlab项目中开发每个Terraform模块。要简化到注册表的转换，用户可以从单个Gitlab存储库主持和发布多个模块。您可以在文档中了解有关发布和消费新模块的更多信息。</p><p>  GitLab 14.0 introduces an all-new, streamlined top navigation menu to help you get where you’re going faster and with fewer clicks. This new, consolidated menu offers the combined functionality of the previous Projects, Groups, and More menus. It gives you access to your projects, groups, and instance-level features with a single click. Additionally, all-new responsive views improve the navigation experience on smaller screens.</p><p>  Gitlab 14.0介绍了一个全新的简化的顶部导航菜单，以帮助您获得更快，较少的点击次数。这个新的综合菜单提供了先前项目，组和更多菜单的组合功能。它可以使用单击“访问”您的项目，组和实例级别“功能。此外，全新的响应视图改善了较小屏幕上的导航体验。 </p><p>  As a developer, you often spend a majority of your time working in your local development environment. When you’re assigned a merge request for review, this requires you to leave your editor and perform that review inside of GitLab. While performing your review inside GitLab, you might also need to use your local editor to gain more context on the proposed changes.</p><p>作为开发人员，您经常花费大部分时间在您当地的发展环境中工作。当您分配合并审核请求时，这要求您离开您的编辑并执行Gitlab内部的审查。在Gitlab中执行您的评论时，您可能还需要使用本地编辑器在提出的更改中获得更多上下文。</p><p> GitLab Workflow version  3.21.0 for Visual Studio Code (VS Code) now supports the complete merge request review process, including threads. Select the GitLab icon in VS Code to open the  sidebar to display  Merge requests I’m reviewing. Select a merge request overview to view the complete details and discussions of the merge request.</p><p> Gitlab Workflow Version 3.21.0 for Visual Studio代码（VS代码）现在支持完整的合并请求审核流程，包括线程。选择VS代码中的Gitlab图标以打开侧栏以显示Merge请求我正在评阅。选择合并请求概述，以查看合并请求的完整详细信息和讨论。</p><p> The sidebar also contains a list of all the changed files in the merge request. Selecting files opens a diff comparison for you to review the changes in VS Code. While viewing the diff, you can read feedback left on the files, and create new comments by selecting a line number and creating your comment. All comments and feedback you provide in VS Code are available in the GitLab web interface, making it easy for you to perform your reviews in VS Code, and other users to participate in GitLab.</p><p> 侧栏还包含合并请求中所有已更改文件的列表。选择文件打开Diff比较，以便您查看VS代码中的更改。在查看Diff时，您可以通过选择行号并创建注释来读取文件上的反馈，并创建新评论。您在GS代码中提供的所有评论和反馈都可以在Gitlab Web界面中提供，使您可以轻松地在VS代码中执行您的评论，以及其他用户参与Gitlab。</p><p> We’re really excited about bringing the complete merge request review process to you inside of VS Code. Let us know what you think by  opening an issue for GitLab Workflow.</p><p> 我们非常兴奋地将完整的合并请求审核流程带到VS代码中。让我们通过为Gitlab Workflow打开一个问题来了解您的想法。</p><p>  GitLab is big. And it’s getting bigger. As we’ve introduced new features and categories, navigating the densely-packed left sidebar has become less intuitive.</p><p>  Gitlab很大。它变得更大。正如我们推出的新功能和类别，导航密集包装的左侧栏变得不那么直观。</p><p> In GitLab 14.0 we’ve redesigned and restructured the left sidebar for improved usability, consistency, and discoverability. We’ve moved some links to features around, split up features in the  Operations menu into three distinct menus, improved visual contrast, and optimized spacing so all the menu items can fit comfortably on a smaller screen. These changes are intended to better match your mental model of the DevOps lifecycle, and provide a more predictable and consistent experience while navigating within your projects and groups.</p><p> 在Gitlab 14.0中，我们已经重新设计并重组左侧栏，以提高可用性，一致性和可发现性。我们将一些链接移动到周围的特点，将操作菜单中的功能分成三个不同的菜单，改进的视觉对比度和优化的间距，因此所有菜单项都可以舒适地适合较小的屏幕。这些更改旨在更好地匹配DevOps生命周期的心理模型，并在您的项目和组中导航时提供更可预测和一致的体验。</p><p>  Editing wiki content could be so much easier! Many GitLab wikis use Markdown formatting, and for some users, Markdown is a barrier to efficient collaboration. In this release, you now have access to a rich, modern Markdown editing experience in your wiki, so you can edit with confidence.</p><p>  编辑Wiki内容可能会更容易！许多Gitlab Wiki使用Markdown格式，以及一些用户，Markdown是有效协作的障碍。在此版本中，您现在可以访问维基中获得丰富的现代标准编辑体验，因此您可以自信地编辑。 </p><p> Instant feedback and visual editing tools help make wiki editing more intuitive, and remove barriers to collaboration. GitLab saves the changes as Markdown when you’re done, so users who want to edit the Markdown directly can do so. You can even type Markdown into the new editor and it will automatically format the text as you type.</p><p>即时反馈和视觉编辑工具有助于使Wiki编辑更直观，并删除协作的障碍。 Gitlab在完成后将更改保存为Markdown，因此想要编辑标记的用户直接可以这样做。您甚至可以在新编辑器中键入markdown，它将自动格式化文本。</p><p> GitLab 14.0 introduces the  Content Editor into the Wiki with support for most of the basic Markdown content types like headers, bold and italic text, lists, code blocks, and links.  Full support for the entire  GitLab Flavored Markdown specification will arrive in upcoming releases. We also plan to make the Content Editor available in other areas of GitLab in the future. We welcome input on this early MVC in  this feedback issue.</p><p> Gitlab 14.0将内容编辑器引入Wiki，并支持大多数基本标记内容类型，如标题，粗体和斜体文本，列表，代码块和链接。完全支持整个Gitlab味道的Markdown规范将到达即将到来的版本。我们还计划在未来在Gitlab的其他地区提供内容编辑。我们欢迎在此反馈问题上进行此早期MVC输入。</p><p>  In GitLab 13.12 and earlier, all DAST vulnerabilities found in a scan were listed individually for each URL the vulnerability was found on. This could create many vulnerabilities when the fix was a single file or configuration change. For example: an issue with a server header sent with every HTTP response would be reported on every page on the site, rather than reported as a single issue with multiple occurrences.</p><p>  在Gitlab 13.12及更早版本中，在扫描中找到的所有DAST漏洞都是单独列出的，针对每个URL单独列出该漏洞。当修复程序是单个文件或配置更改时，这可能会产生许多漏洞。例如：将在站点上的每个页面上报告使用每个HTTP响应发送的服务器标头的问题，而不是报告为具有多个出现的单个问题。</p><p> To reduce the overhead of managing vulnerabilities, GitLab combines identical vulnerabilities found on multiple pages into a single reported vulnerability in the DAST report. The vulnerability details include a list of all the URLs where the vulnerability was found, rather than individual vulnerabilities being created in the vulnerability list and dashboard for each page.</p><p> 为减少管理漏洞的开销，Gitlab将多页上的相同漏洞组合成DAST报告中的单个报告的漏洞。漏洞详细信息包括找到漏洞的所有URL的列表，而不是在漏洞列表和每个页面中的仪表板中创建的单个漏洞。</p><p> This new reporting functionality will not retroactively combine vulnerabilities found in previous scans. It only applies to scans performed in GitLab 14.0 and later.</p><p> 这种新的报告功能不会追溯地结合以前扫描中发现的漏洞。它只适用于在Gitlab 14.0及更高版本中执行的扫描。</p><p>  In this release, we are moving away from the CI/CD template-based approach for cluster management. Cluster management is the ability to manage Kubernetes clusters to improve application availability running on a cluster. The old method hides too much of the logic, restricts customizations and extensions of your apps. With the new approach, you can easily create a cluster management project from a project template and fully control your applications. A project created using the new template contains the code needed for cluster management jobs, including  built-in support for several applications. You can easily extend the project to other applications and own them completely.</p><p>  在此版本中，我们正在远离基于CI / CD模板的群集管理方法。群集管理是管理Kubernetes集群的能力，以改善在群集中运行的应用程序可用性。旧方法隐藏过多的逻辑，限制应用程序的自定义和扩展。使用新方法，您可以从项目模板轻松创建群集管理项目，并完全控制您的应用程序。使用新模板创建的项目包含群集管理作业所需的代码，包括对多个应用程序的内置支持。您可以轻松扩展到其他应用程序并完全拥有它们。</p><p> Additionally, new applications will be installed using Helm v3. If you have former GitLab Managed Applications installed using Helm v2, check the  Helm migration guide and the  GitLab Managed Apps migration guide. The CI/CD job output will also guide you through these migrations.</p><p> 此外，将使用Helm V3安装新应用程序。如果使用Helm v2安装了前Gitlab托管应用程序，请检查Helm迁移指南和Gitlab托管应用程序迁移指南。 CI / CD作业输出还将指导您完成这些迁移。 </p><p> In GitLab 14.0, the cluster management project supports only certificate-based cluster integrations. We plan to add support for the GitLab Kubernetes Agent in the next release.</p><p>在Gitlab 14.0中，群集管理项目仅支持基于证书的群集集成。我们计划在下一个版本中添加对Gitlab Kubernetes代理的支持。</p><p>  The pipeline editor in GitLab is your one-stop shop when interacting with CI/CD pipelines. Previously, when writing your first pipeline with the editor, you were presented with a blank configuration. While perfectly useful for experienced pipeline authors, it was a bit of a leap for those just starting out.</p><p>  Gitlab中的管道编辑器是与CI / CD管道交互时的一站式商店。以前，使用编辑器编写第一管线时，您将呈现出空白配置。虽然对于经验丰富的管道作者来说非常有用，但对于刚开始的人来说，这有点跳跃。</p><p> In this release, if a project does not have a pipeline configured, the editor preloads a template showing an example 3-stage pipeline. You can save and run this pipeline right away to see it in action in your project. On top of that, it also has comments that help you understand the syntax, and tips and hints to help you start customizing the template to match your needs. It is now much easier to get your first green pipeline!</p><p> 在此版本中，如果项目没有配置管道，则编辑器预加载示例3级流水线的模板。您可以立即保存并运行此管道，以便在项目中看到它。最重要的是，它还具有评论，帮助您了解语法，提示和提示，帮助您开始自定义模板以匹配您的需求。现在可以让您的第一个绿色管道更容易！</p><p>  Container scanning in GitLab now uses the Trivy engine by default. This change provides customers with more timely vulnerability intelligence updates, more accurate results, and support for a larger number of operating systems. Users who run container scanning with default settings are switched seamlessly and automatically to the new engine in GitLab 14.0. Users who customize the variables in their container scanning job should review our  migration guide and make any necessary updates.</p><p>  Gitlab中的集装箱扫描现在默认使用Trivy引擎。此更改为客户提供更及时的漏洞智能更新，更准确的结果，并支持更大数量的操作系统。运行默认设置的容器扫描的用户无缝，自动切换到Gitlab 14.0中的新引擎。自定义容器扫描作业中的变量的用户应查看我们的迁移指南并进行必要的更新。</p><p>  As part of our efforts to natively support  DORA4 metrics in GitLab, the lead time for merge requests chart is now available at the Group level. This release extends on the work completed in  GitLab 13.11; you can now use a chart that shows how long it takes merge requests to be deployed to a production environment (not just in individual projects, but aggregated across a group). This allows you to get a full picture of throughput across multiple projects.</p><p>  作为我们在Gitlab中本地支持DORA4指标的努力的一部分，Merge请求图表的提前时间现在可以在组级别获得。此版本在Gitlab 13.11完成的工作中延伸;您现在可以使用一个图表，该图表显示将合并要部署到生产环境的合并请求需要多长时间（不仅仅在单个项目中，而且跨组汇总）。这允许您在多个项目中获得完整的吞吐量。</p><p> The stages in project-level value stream analytics are now shown in a horizontal layout. This helps visualize the flow of work through the stages of a value stream. It also matches the navigation experience in group-level value stream analytics.</p><p> 项目级值流分析中的阶段现在以水平布局显示。这有助于通过值流的阶段可视化工作流程。它还与组级值流分析中的导航体验匹配。</p><p> The DevOps Adoption table provides insight into how GitLab has been adopted across your organization with a comparison by group and subgroup. Previously, you could add no more than 200 groups to the table. We understand that larger organizations can have thousands of GitLab groups. You can now use a searchable dropdown to add any subgroup to the table.</p><p> DevOps采用表提供了介绍Gitlab如何通过组和子组进行比较。以前，您可以将不超过200组添加到表中。我们了解，较大的组织可以拥有数千个Gitlab组。您现在可以使用可搜索的下拉列表来将任何子组添加到表中。 </p><p> In addition, subgroups removed from the DevOps Adoption table in one group  no longer automatically get removed from the tables of other groups. As a result of the data migration that was done for this fix, you might need to manually re-add some subgroups to your tables the first time that you revisit them.</p><p>此外，在一个组中从Devops采用表中删除的子组不再自动从其他组的表中删除。由于此修复所做的数据迁移，您可能需要在您重新审视它们时手动将某些子组重新添加到表中。</p><p> Expired SSH keys  added to GitLabare now disabled by default. This helps to make your GitLab instance more secure. Previously, expired SSH keys added to GitLab were enabled by default, and could be used unless explicitly disabled by an administrator.</p><p> 默认情况下，已将已过期的SSH密钥添加到Gitlabare。这有助于使您的Gitlab实例更安全。以前，默认情况下，将启用添加到Gitlab的过期SSH密钥，除非管理员明确禁用，否则可以使用。</p><p> This change affects expired SSH keys used on GitLab.com. If your keys are expired or will expire soon, you need to update the key and any services using them. Our  documentation on SSH keys has helpful steps on how to create a new SSH key.</p><p> 此更改会影响Gitlab.com上使用的已过期SSH键。如果您的键已过期或将很快到期，则需要更新使用它们的密钥和任何服务。我们关于SSH密钥的文档有助于如何创建新的SSH密钥。</p><p> Self-managed administrators can still  allow the use of expired keys, similar to how theycan  allow use of expired personal access tokens.</p><p> 自我管理的管理员仍然可以允许使用过期的密钥，类似于他们允许使用过期的个人访问令牌。</p><p> Code Owners are an important piece of the code review process in GitLab. When code owners are clearly identified, contributors can see who should review contributions to a file or repository. The Code Owners feature can also be used to establish a merge request approval process. Now, you can track which teams across your organization are using the Code Owners feature in their development workflow.</p><p> 代码所有者是Gitlab中的代码审查过程的重要组成部分。当Code Oveers明确识别时，贡献者可以看到谁应该审查文件或存储库的贡献。代码所有者功能也可用于建立合并请求批准过程。现在，您可以跟踪组织中的哪些团队正在使用其开发工作流程中的代码所有者功能。</p><p> If you would like to drive adoption of Code Owners, sort the DevOps Adoption table by the Code Owners column to find teams that haven’t yet adopted the feature so you can easily identify which teams need help getting started. Alternatively, find teams that have successfully configured Code Owners and get tips and feedback. The DevOps Adoption table is available at  the group level and  the instance level.</p><p> 如果您想推出采用代码所有者，请通过代码所有者列对Devops采用表进行排序，以查找尚未采用该功能的团队，以便您可以轻松识别哪些团队需要帮助入门。或者，找到已成功配置代码所有者的团队并获取提示和反馈。 Devops采用表可在组级别和实例级别中获得。</p><p> Our  Slack notification service can notify you when a user edits a wiki page. The Slack message gives you helpful context about the edit, including the project, page name, and the commit message. Sometimes, however, the commit message doesn’t give enough context, and you need more information about how the content changed.</p><p> 我们的Slack Notification Service可以在用户编辑Wiki页面时通知您。 Slack消息为您提供有关编辑的有用的上下文，包括项目，页面名称和提交消息。但是，有时，提交消息没有足够的上下文，并且您需要更多有关内容如何更改的信息。 </p><p> Now you can click  Compare changes in the Slack message to immediately view the diff, saving you time and reducing confusion from ambiguous or incomplete commit messages.</p><p>现在，您可以单击Slack消息中的比较更改，立即查看Diff，保存您的时间并减少含糊不清或不完整的提交消息的混淆。</p><p> We’re also releasing GitLab Runner 14.0 today! GitLab Runner is the lightweight, highly-scalable agent that runs your build jobs and sends the results back to a GitLab instance. GitLab Runner works in conjunction with GitLab CI/CD, the open-source continuous integration service included with GitLab.</p><p> 我们今天还释放了Gitlab Runner 14.0！ Gitlab Runner是轻量级，高度可扩展的代理，运行构建作业，并将结果发送回Gitlab实例。 Gitlab Runner与Gitlab CI / CD一起配合使用Gitlab包含的开源连续集成服务。</p><p> If you want to reuse scripts and configuration between deployment jobs using the  environment: keyword, it can be difficult to exclude certain behaviors based on the type of action the deployment job performs. For example, an  environment: action of  stop might be a job that is stopping a  review_app, and you don’t want your deployment scripts to run.</p><p> 如果要使用环境中重复使用部署作业之间的脚本和配置：关键字，则难以根据部署作业执行的操作类型排除某些行为。例如，环境：停止的操作可能是一项停止评论_App的作业，并且您不希望您的部署脚本运行。</p><p> Now, the value of  environment: action: is available as the  CI_ENVIRONMENT_ACTION predefined CI/CD variable, making it easier than ever to configure one script that can work for all deployment jobs.</p><p> 现在，环境的值：Action：可用作CI_ENvironment_Action预定义CI / CD变量，使其比以前更容易配置一个可以为所有部署作业工作的脚本。</p><p> You can use your project’s Package Registry to publish and install PyPI packages. When you install a PyPI package, you must specify which project the package resides in. This works well if you have a small number of projects. If you have multiple projects nested within a group, you might quickly find yourself adding dozens or even hundreds of different sources.</p><p> 您可以使用项目的包注册表发布和安装PYPI软件包。安装PYPI包时，必须指定包驻留在哪个项目。如果您有少量项目，则运行良好。如果您有多个项目嵌套在组中，您可能很快发现自己添加了数十种或甚至数百个不同的来源。</p><p> For large organizations with many teams, it’s common for a team to publish packages to their project’s Package Registry alongside the source code and pipelines. However, they must also be able to easily install dependencies from other projects within their organization. You can now install packages from your group, so you don’t have to remember which package lives in which project. To do this, use the simple API to specify a package:  GET groups/:id/packages/pypi/files/:sha256/:file_identifier.</p><p> 对于具有许多团队的大型组织，一支团队将包裹与源代码和管道一起发布到项目的包裹注册表。但是，它们还必须能够轻松地从组织内的其他项目中安装依赖项。您现在可以从组中安装包，因此您不必记住哪个项目的包装。为此，请使用简单的API指定包：获取组/：ID /包/ PYPI /文件/：SHA256 /：FILE_IDENTIFIER。</p><p> You can also write the output to a file, or return the package descriptor as an HTML file.  Read the docs for more info and let us know how it goes. We hope that this helps to make your team and organization more efficient.</p><p> 您还可以将输出写入文件，或将包描述符作为HTML文件返回。阅读更多信息的文档，让我们知道它是怎么回事。我们希望这有助于使您的团队和组织更高效。 </p><p> Automated security scanning is an important part of any secure development process. There are a wide variety of tools and technologies covering the entire SDLC from source code scanning to post-deployment application and infrastructure scanning. While the ultimate goal of any of these tools is to discover both known and potential vulnerabilities, the information coming from any given scanner can vary widely. Efforts to standardize scanning output data do exist but they tend to focus only on one category of scanning technology or even a specific set of tools. This presents a big challenge to security teams who need to aggregate a wide array of scanner findings. Without a consistent way to normalize disparate findings, viewing the unique details for each scanner’s output can be a very apples-and-oranges experience. And if the tool outputs aren’t aggregated, then results are often reviewed in the source tool, leaving the true picture of vulnerability risk fragmented and sitting outside of the rest of the DevOps toolchain.</p><p>自动安全扫描是任何安全开发过程的重要组成部分。从源代码扫描到后部署应用程序和基础架构扫描，有各种各样的工具和技术覆盖整个SDLC。虽然任何这些工具的最终目标是发现已知和潜在的漏洞，但来自任何给定扫描仪的信息都可以广泛变化。为了规范扫描输出数据的努力确实存在，但它们倾向于仅关注一个类别的扫描技术甚至是一组特定的工具。这对需要聚集各种扫描仪调查结果的安全团队提出了巨大挑战。没有一致的方式来规范化不同的发现，查看每个扫描仪输出的独特细节可以是非常苹果和橙色的体验。并且如果刀具输出没有汇总，则源工具通常会审查结果，留下漏洞风险的真实情况分散并坐在沿着Devops Toolchain的其余部分之外。</p><p> The new generalized details structure in our security report schemas can bridge this gap. You can already integrate a wide variety of security scanners into GitLab with minimal effort. Now you can go even further with rich formatting options for finding details. Our new structure makes it easy to map most tool’s existing outputs into our JSON report formats while adding consistent presentation logic automatically. Flexibility without sacrificing the ability to provide rich vulnerability finding data is a primary purpose behind the new structure. Details are provided in an open structure using pre-defined data types. The pre-defined types handle both data validation as well as standardized UI presentation inside GitLab. For instance, we provide types such as Integer, URL, Table, and even GFM ( GitLab Flavored Markdown). This allows granular control over how finding details are presented while keeping the overall experience inside GitLab consistent.</p><p> 我们的安全报告模式中的新的广义细节结构可以弥合这个差距。您可以使用最小的努力将各种安全扫描仪整合到Gitlab中。现在，您可以进一步进一步了解丰富的格式选项，以查找详细信息。我们的新结构使大多数工具的现有输出易于映射到我们的JSON报告格式，同时自动添加一致的演示逻辑。灵活性而不牺牲提供丰富的漏洞发现数据的能力是新结构背后的主要目的。使用预定义的数据类型，在开放结构中提供了详细信息。预定义类型涉及Gitlab内的数据验证以及标准化的UI呈现。例如，我们提供整数，URL，表，甚至GFM（Gitlab调味标记）等类型。这允许粒度控制如何在将Gitlab内部保持整体体验的同时呈现出展示的详细信息。</p><p> Previously, to access the user lists, you had to navigate to a separate tab under the Feature Flags page. This design obscured the relationship between feature flags and user lists since user lists are a sub-feature of feature flags.In this release, user lists are now under a subpage of Feature Flags, which improves the workflow and makes their relationship more clear.</p><p> 以前，要访问用户列表，则必须导航到“功能标志”页面下的单独选项卡。此设计掩盖了功能标志和用户列表之间的关系，因为用户列表是功能标志的子特征。在此版本中，用户列表现在属于特征标志的子页，这提高了工作流程并使他们的关系更清晰。</p><p> The Incident Service Level Agreement (SLA) Timer, introduced in GitLab 13.5, shows the time remaining until an SLA violation for an incident.However, the user had to refresh the page to update the timer. Starting in GitLab 14.0, the timer updates dynamically every 15 minutes without the need for a page refresh.</p><p> 在Gitlab 13.5中引入的事件服务级别协议（SLA）计时器显示了剩余的时间，直到SLA违反事件。然而，用户必须刷新页面以更新计时器。从Gitlab 14.0开始，定时器每15分钟动态更新，而无需页面刷新。</p><p> GitLab’s database load balancer enables the distribution of read-only queries across multiple database servers. For GitLab instances with thousands of users, using the load balancer can reduce the load on the primary database and increase responsiveness, thus resulting in faster page load inside GitLab.</p><p> Gitlab的数据库负载均衡器允许在多个数据库服务器上分发只读查询。对于具有数千个用户的Gitlab实例，使用负载均衡器可以减少主数据库上的负载并提高响应性，从而导致Gitlab内的页面加载。</p><p> In this release, we moved the load balancer from Premium to Free to allow more users to benefit from this feature.</p><p> 在此版本中，我们将负载均衡器从溢价移动到允许更多用户从此功能中受益。</p><p> Patroni is a solution forPostgreSQL high availability, which also allows theconfiguration of a highly-available PostgreSQL standby cluster on a Geosecondary. This configuration is important when a secondary is used aspart of a disaster recovery strategy, because it allows systemsadministrators to mirror the number of database nodes on the primary andsecondary site. This means that after a failover, no additional database nod</p><p> Patroni是ForPostGRESQL高可用性的解决方案，其还允许在GeoSecondary上进行高可用的PostgreSQL备用群集。当使用灾难恢复策略的辅助Aspart时，此配置非常重要，因为它允许SystemsAdministrators镜像主要和激发站点上的数据库节点数量。这意味着在故障转移之后，没有其他数据库点头 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://about.gitlab.com/releases/2021/06/22/gitlab-14-0-released/">https://about.gitlab.com/releases/2021/06/22/gitlab-14-0-released/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gitlab/">#gitlab</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>