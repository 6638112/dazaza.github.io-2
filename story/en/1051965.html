<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>国家核武器政府 Kubernetes State Checker</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Kubernetes State Checker<br/>国家核武器政府 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-12 19:10:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/939978433e417cfb34c10d8103bc3202.png"><img src="http://img2.diglog.com/img/2021/3/939978433e417cfb34c10d8103bc3202.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Kubernetes State Checker as the name suggests helps you check the state of your Kubernetes cluster.</p><p>Kubernetes State Checker，因为名称建议您可以帮助您检查Kubernetes集群的状态。</p><p> You might ask, with Kubernetes, don’t you declare the state you want and Kubernetes makes that happen, why do I have to check the state? You would be correct but there are usually interactions from one Kubernetes resource with another or it might depend on an external or third party resource. Anyone of these items might not be able to get into the state you wanted which can have downstream effects or effects on the environment. Even if Kubernetes put the state of the cluster/application in the state you declared, sometimes what you declared could be wrong because someone changed the setting looking to make a fix which was not communicated to downstream dependencies and that could break the environment.</p><p> 你可能会问，用Kubernetes，你不宣布你想要的州，Kubernetes会发生这种情况，为什么我要检查这个国家？您将是正确的，但通常从一个Kubernetes资源与另一个Kubernetes资源进行交互，或者它可能取决于外部或第三方资源。任何人都可能无法进入您所需的状态，从而可以对环境有下行效应或影响。即使Kubernetes将群集/应用程序的状态放在您声明的状态下，有时，您声明的是错误的，因为有人更改了设置的设置，希望若要传达到下游依赖项，并且可能会破坏环境。</p><p> With a microservice architecture, multiple teams can contribute to one application environment. Ensuring everything coming together and working correctly is often a challenge. There are often the application expert(s) that know how all of these applications integrate with each other and are supposed to work for your environment and this person is relied on to debug integration problems. This is a tedious task and relying on certain people to debug these types of issues makes them a bottleneck.</p><p> 通过微服务架构，多个团队可以贡献一个应用环境。确保一切顺利，正常工作往往是一个挑战。应用专家通常知道所有这些应用程序如何相互集成，并且应该为您的环境工作，并且此人依赖于调试集成问题。这是一个繁琐的任务，依靠某些人调试这些类型的问题使它们成为一个瓶颈。</p><p>  Here is a real example that has been sanitized and made generic. We have an environment with a bunch of microservices. In this scenario, we will talk about 2 of them. Microservice 1 was set to listen on port 5000 and Microservice 2 was set to connect to Microservice 1 on port 30001. Based on the configuration each state of the deployments made it to it’s desired state but when Microservice 2 tried to connect to Microservice 1, that connection failed.</p><p>  这是一个已经消毒和泛型的真实例子。我们有一个具有一堆微服务的环境。在这种情况下，我们将谈论其中的2个。 MicroService 1被设置为侦听端口5000，并且将MicroService 2设置为连接到端口30001上的微服务1.基于配置部署的每个状态使其成为所需状态，但是当微服务2尝试连接到微服务1时，即连接失败。</p><p> We just told you the exact problem but when this occurred, it was not apparent that the ports were set incorrectly. The initial thing that alerted us that this environment was now broken was an e2e test that failed. However, the e2e tests only tests from certain entry points into the system and can’t tell us why the system is broken. This led to developers looking at application logs on the various services since they know how the call flows through the system. From the logs, the developers were able to localize the problem to a few microservices but was not able to say exactly why the call is broken. The next step was to loop in the infrastructure people to take a look. The infrastructure people had to catch up on what was happening and with that information started to check various Kubernetes things. After some tedious task of tracing out how the application was configured to what it was trying to communicate with, it was found that the port settings were off and one side of the port numbers would have to change.</p><p> 我们刚刚告诉你确切的问题，但是当发生这种情况时，港口被设置不正确，并不明显。警告我们这个环境现在破损的最初的事情是一个失败的E2E测试。但是，E2E测试只测试某些入口点到系统中，无法告诉我们系统已破坏。这导致了在各种服务上查看应用程序日志的开发人员，因为他们知道呼叫如何流过系统。从日志中，开发人员能够将问题本地化为几个微服务，但无法准确地说明呼叫被打破。下一步是在基础设施中循环观看。基础设施人们必须赶上正在发生的事情，并开始使用该信息来检查各种Kubernetes的东西。经过一些繁琐的任务来追溯应用程序如何配置到它试图与之通信的内容，发现端口设置已关闭，端口号的一侧必须更改。</p><p> With Kubernetes State Checker, we will be able to declare these states on how the port numbers should be configured and then run a check to make sure it is in that state. If it is not, like in this case, it would tell you that this particular port is not in the state that you said you wanted it in. This was essentially an integration problem between Microservice 1 and Microservice 2. Microservice 1 was listening on one port but Microservice 2 thought it should connect to Microservice 1 on another port. Who is correct? This is an understanding between the two microservices on how they will connect to each other but nothing is enforcing or checking that. Kubernetes State Checker can be that “check” or “enforcement”.</p><p> 使用Kubernetes状态检查器，我们将能够在如何配置端口号，然后运行检查以确保它处于该状态的情况下声明这些状态。如果没有，就像在这种情况下，它会告诉你这个特定的端口不是你所说的状态。这基本上是微服务1和微猎狼之间的集成问题。微服务1正在听一个端口但微服务2认为它应该连接到另一端口上的微服务1。谁是正确的？这是两个微服务之间的理解，它们如何相互连接，但没有任何东西正在强制执行或检查。 Kubernetes状态检查器可以是“检查”或“强制”。</p><p> From a developers point of view, this gives them a tool to check the layers underneath the application to ensure that everything in those layers is set to what is expected.</p><p> 从开发人员的角度来看，这为它们提供了一种检查应用下方的图层的工具，以确保这些层中的所有内容设置为预期的内容。 </p><p> From a DevOps/Infrastructure person’s point of view, this allows them to set up an expected state and enable other groups to check for that. It also gives this group a tool where they can run to check the state which can help them eliminate what could possibly be wrong and look at other areas that this tool did not cover.</p><p>从Devops / Infrastructure人的角度来看，这允许它们设置预期状态并使其他组能​​够检查。它还给出了这组一个工具，他们可以运行以检查可以帮助他们消除可能是错误的状态，并查看此工具未覆盖的其他区域。</p><p>   If you had a series of checks that represents a correctly setup environment, then you can use those checks and run it against another environment to make sure everything is in place. If something is not correctly set, then kubernetes-state-checker will output what is not correct.</p><p>   如果您有一系列代表正确设置环境的检查，则可以使用这些检查并将其与另一个环境进行运行以确保一切都已到位。如果未正确设置某些内容，则Kubernetes-State-Checker将输出不正确的内容。</p><p>  As the developer is developing the application, this person usually knows what the application needs in order for it to function properly and probably have found some hiccups while debugging this application. The developer can create check(s) very similiar to how they can create unit tests on areas that are known to failures. Then other teams that are managing other environments can uses these check(s) to make sure their environments are correctly setup.</p><p>  由于开发人员正在开发应用程序，此人通常知道应用程序所需的需求，以便在调试此应用程序时才能正常运行，可能已经找到了一些打嗝。开发人员可以创建待遇，非常类似于它们如何在故障已知的区域上创建单元测试。然后，正在管理其他环境的其他团队可以使用这些检查来确保其环境已正确设置。</p><p> The check(s) can flow from the other way as well. Usually in a larger organization, the developers might not be the ones that are taking care of the production systems. There might be another team for that. As you run the application(s) in production, you will usually see other operational issues that are not an issue in dev. This team can also write check(s) for these items so that these issue(s) are detected before it becomes a problem. With these checks, the other teams including the developers can run it to make sure everything is good and that the assumptions from development to production are adhere to.</p><p> 检查也可以从另一种方式流动。通常在更大的组织中，开发人员可能不是正在处理生产系统的人。可能还有另一个团队。在生产中运行应用程序时，您通常会看到其他操作问题，这些问题不是DEV中的问题。该团队还可以为这些项目编写检查，以便在成为问题之前检测到这些问题。通过这些支票，包括开发人员在内的其他团队可以运行它以确保一切良好，并且从开发到生产的假设都坚持。</p><p>   kubernetes-state-checker:- type: doesServicePortExist name: Does microservice 1 have a kubernetes service with port 5000 exposed description: This checks if microservice 1 has a Kubernetes service with port 5000 exposed namespace: app # Input values for this specific check values: serviceName: microservice-1 port: 5000</p><p>   Kubernetes-State-Checker： - 类型：DoesServicePortExist名称：MicroService 1具有Kubernetes服务与端口5000公开说明：此检查是否具有PicroService 1具有端口5000公开名称空间的Kubernetes服务：此特定检查值的应用程序＃输入值： ServiceName：MicroService-1端口：5000</p><p>  kubernetes-state-checker:- type: doesEnvarExistInDeployment name: Check that the microservice 2 deployments has the correct envar for microservice 1 description: The microservice 2 uses the &#34;MICROSERVICE_1_HOST_PORT&#34; envar to find microservice 1. This checks to make sure that this envar is there and set to the correct value. Namespace: app # Input values for this specific check values: deploymentName: microservice-2 envarKey: MICROSERVICE_1_HOST_PORT envarValue: microservice-1:5000</p><p>  Kubernetes-State-Checker： - 类型：DoneNvareXistindeployMentment名称：检查MicroService 2部署是否具有MicroService的正确envar 1说明：微服务2使用＆＃34; microService_1_host_port＆＃34;寻找微服务1.这检查此envar是否存在并设置为正确的值。命名空间：应用程序＃此特定检查值的输入值：DeploymentName：MicroService-2 Envarkey：microService_1_Host_Port envarvalue：MicroService-1：5000</p><p>     During a peer review of this document, there was an idea put out to see if we can read in configurations in a more dynamic way so that these configurations don&#39;t have to be in more than one place. Taking our our microservice 1 and microservice 2 example from above. The actual ports and envars are defined in each services Helm values files. Then with this test, we once again have to define what ports maps to what. This means that the same information is in two places now. When someone wants to update the port for microservice 1, they would have to update it in microservice 1&#39;s Helm values and then go into the kubernetes-state-checker&#39;s check config yaml and change the value in there as well. This make repetitive and tedious amount of work.</p><p>     在对本文件的同行评审期间，有一个想法提出了我们可以以更具动态的方式读取配置，以便这些配置不得不在一个以上的地方。从上面拍摄我们的MicroService 1和MicroService 2示例。实际端口和维护在每个服务掌舵文件中都定义。然后通过此测试，我们再次必须定义映射到什么端口。这意味着相同的信息现在是两个地方。当有人想要更新MicroService 1的端口时，它们必须在微服务1＆＃39; s helm值中更新它，然后进入Kubernetes-State-Checker＆＃39; s检查配置yaml并将值更改为出色地。这使得重复和繁琐的工作。 </p><p> We would like a way where we can tell this kubernetes-state-checker&#39;s check config yaml that here is the port that microservice-1 is listening on and here is the file and here is the envar that microservice-2 is using to reach that port. These values should be the same.</p><p>我们希望在哪里可以告诉这个Kubernetes-State-Checker＆＃39; s检查配置yaml，这里是microService-1正在侦听的端口，这里是microService-2正在使用的envar到达那个港口。这些值应该是相同的。</p><p>  Be able to read from any yaml file with a  kubernetes-state-checker sectionWe can point it to any yaml file and it will find and only the  kubernetes-state-checker section.</p><p>  能够使用Kubernetes-State-Checker部分从任何Yaml文件读取，可以将其指向任何yaml文件，并且它将仅找到kubernetes-state checker部分。</p><p> fullnameOverride: &amp;name &#34;hos-core-authentication&#34;image: repository: 1234.dkr.ecr.us-west-2.amazonaws.com/hos/hos-core-authentication pullPolicy: Always tag: &amp;tag devservice: port: 20004 targetPort: 20004some-other-yaml: foo: barkubernetes-state-checker:- type: doesServicePortExist name: Does hos-core-authentication have a kubernetes service with port 20004 exposed description: This checks if hos-core-authentication has a Kubernetes service with port 20004 exposed namespace: app # Input values for this specific check values: serviceName: hos-core-authentication port: 20004</p><p> fullnameoverride：＆amp;名称＆＃34; hos-core-authentication＆＃34;图片：存储库：1234.dkr.ecr.us-west-2.amazonaws.com/hos/hos-core-authentication pullpolicy：始终标签：＆amp ;标签devservice：port：20004 targetport：20004some-thater-yaml：foo：barkubernetes-nature-checker： - 类型：doesserviceportexist名称：hos-core-authentication是否具有kubernetes服务与端口20004公开说明：此检查是否hos- Core-Authentication具有带有端口20004的Kubernetes服务，公开名称空间：应用程序＃此特定检查值的输入值：ServiceName：HOS-Core-Authentication Port：20004</p><p>   This has the configuration files that helps you bring up the enviroment you need to develop against this locally via a Docker container.</p><p>   这具有可帮助您通过Docker容器在本地开发的环境的配置文件。</p><p>   Once you install this, and restart VScode in this repository, it will ask if you want to open it in a container. The first time you do this, it will take some time since it is building the container based on the Dockerfile in the  .devcontainer directory. After it builds the container, it will open this project inside of this container and you can code away as normal.</p><p>   安装此后台并在此存储库中重新启动vsode后，会询问您是否要在容器中打开它。第一次执行此操作时，它需要一些时间，因为它是基于.devContainer目录中的Dockerfile构建容器。构建容器后，它将在此容器内部打开此项目，您可以像正常一样代码。</p><p>  go get gopkg.in/yaml.v2go get k8s.io/apimachinery/pkg/api/errorsgo get k8s.io/apimachinery/pkg/apis/meta/v1go get k8s.io/client-go/kubernetesgo get k8s.io/client-go/tools/clientcmdgo get k8s.io/client-go/util/homedirgo get github.com/evanphx/json-patchgo get k8s.io/kube-openapi/pkg/util/protogo get github.com/olekukonko/tablewriter</p><p>  get get goet gopkg.in/yaml.v2go get k8s.io/apimachinery/pkg/api/errorsgo get k8s.io/apimachinery/pkg/apis/meta/v1go get k8s.io/client-go/kubernetesgo get k8s.io/客户端 -  go / tools / clientcmdgo get k8s.io/client-go/util/homedirgo get github.com/evanphx/json-patchgo get k8s.io/kube-openapi/pkg/util/protogo get github.com/olekukonko/表格</p><p>      The  .devcontainer/devcontainer.json file specifies a local mount from your  $HOME/.kube/config into the  $HOME/.kube/config inside the container.</p><p>      .devcontainer / devcontainer.json文件指定从$ home / .kube / confiol的本地安装程序进入容器内的$ home / .kube / config。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/anthem-ai/kubernetes-state-checker">https://github.com/anthem-ai/kubernetes-state-checker</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/核武器/">#核武器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/检查/">#检查</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>