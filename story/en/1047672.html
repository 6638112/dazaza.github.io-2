<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Gridsort：比std：sort更快的稳定排序 Gridsort: A stable sort faster than std:sort</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Gridsort: A stable sort faster than std:sort<br/>Gridsort：比std：sort更快的稳定排序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-10 03:22:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/c15620efa08bd067f610c4fc53209a50.jpeg"><img src="http://img2.diglog.com/img/2021/2/c15620efa08bd067f610c4fc53209a50.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Gridsort sorts data by storing data in a simplified  binary cube, a multidimentional sorted array. The binary cube offers excellent cache utilization. It&#39;s easiest to view a binary cube as a hash table, but instead of a hash function to find a bucket it uses a binary search on a lookup table.</p><p>Gridsort通过将数据存储在简化的二进制多维数据集（多维排序的数组）中对数据进行排序。二进制多维数据集提供了出色的缓存利用率。将二进制多维数据集查看为哈希表是最简单的方法，但它不是使用哈希函数来查找存储桶，而是在查找表上使用二进制搜索。</p><p>  The first step when sorting an element is a  boundless binary search to pin point the bucket where the element should be stored. A boundless binary search is up to two times faster than the legacy binary search used by most applications. Once a bucket is found the element is added to the end of the bucket.</p><p>  对元素进行排序时的第一步是无限制的二进制搜索，以查明应在其中存储元素的存储桶。无限二进制搜索的速度比大多数应用程序使用的传统二进制搜索快两倍。一旦找到存储桶，该元素就会添加到存储桶的末尾。</p><p> Gridsort switches to an adaptive binary search when it detects data that is already sorted.</p><p> 当Gridsort检测到已排序的数据时，它将切换到自适应二进制搜索。</p><p>  Once a bucket overflows it is sorted using  quadsort and a new bucket is created. The sorted data is split between the two buckets so each bucket is half full. The lowest element in each bucket is added to the lookup table.</p><p>  存储桶溢出后，将使用四叉排序对其进行分类并创建一个新存储桶。排序后的数据在两个存储桶之间分配，因此每个存储桶都已装满一半。每个存储桶中最低的元素将添加到查找表中。</p><p>  Once all elements have been inserted into the binary cube every bucket receives a final sort and is copied back to the original array.</p><p>  将所有元素都插入二进制多维数据集后，每个存储桶都会得到最终排序，并被复制回原始数组。</p><p>  The C implementation of gridsort supports long doubles and 8, 16, 32, and 64 bit data types. By using pointers it&#39;s possible to sort any other data type.</p><p>  gridsort的C实现支持长双精度和8、16、32和64位数据类型。通过使用指针，可以对任何其他数据类型进行排序。</p><p>    ┌───────────────────────┐┌───────────────────────┐    │comparisons   ││swap memory   │ ┌───────────────┐├───────┬───────┬───────┤├───────┬───────┬───────┤┌──────┐┌─────────┐┌─────────┐ │name   ││min   │avg   │max   ││min   │avg   │max   ││stable││partition││adaptive │ ├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤ │gridsort   ││n   │n log n│n log n││n   │n   │n   ││yes   ││yes   ││yes   │ ├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤ │mergesort   ││n log n│n log n│n log n││n   │n   │n   ││yes   ││ no   ││ no   │ ├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤ │quadsort   ││n   │n log n│n log n││1   │n   │n   ││yes   ││ no   ││yes   │ ├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤ │quicksort   ││n   │n log n│n²   ││1   │1   │1   ││ no   ││yes   ││ no   │ ├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤ │introsort   ││n log n│n log n│n log n││1   │1   │1   ││ no   ││yes   ││ no   │ └───────────────┘└───────┴───────┴───────┘└───────┴───────┴───────┘└──────┘└─────────┘└─────────┘</p><p>    ┐──────────────────┐┌┐┌────────────────┐ │比较││交换内存│┌─────────────┐├───────────────────┬ ────────┬────────┬────────┤┌────┐┌────────┐┌ ────┐│名称││最小│avg│max││min│avg│max││稳定││分区││自适应│├───────────┤ ──────┼────────┼────────┤├───────┼──────┼────────┤ ──────────────────────┤│gridsort││n│nlogn│nlogn││n│n│n││是││是││是│├─────────────┤├────────┼────────── ────────┼──────┼────┼────────────┤──────────┤ ────┤│合并排序││n日志n│n日志n│n日志n││n│n│n││││否││否│├─────────── ──┤├───────┼───────┼────────┤├───────┼────────┼──── │││n│nlogn│nlogn││1│ n│n││是││否││是│├─────────────┤ ──────────────┼────────────────┤ ──────────┤│快速排序││n│nlogn│n²││1│1│1││否││是││否│├───────── ────┤├──────┼ ──┼────────┤├───────┼──────────────┤ ────┤├──────────────────────────────────────────┤────────────────────────────────────────────────────────────┤ ────────────┘└──────┴────────────────┘└────────┴── ──────┴────────┘└──────┘└────────┘└ </p><p> Gridsort makes n comparisons when the data is fully in order or in reverse order.</p><p>当数据完全按顺序排列或按相反顺序排列时，Gridsort会进行n次比较。</p><p>  People wanting to port gridsort might want to have a look at  twinsort, which is a simplified implementation of quadsort. Gridsort itself is a simplified implementation of cubesort.</p><p>  想要移植gridsort的人们可能想看看twinsort，这是quadsort的简化实现。 Gridsort本身是cubesort的简化实现。</p><p>  In the visualization below eight tests are performed. Random, Ascending, Ascending Saw, Generic,Descending, Descending Saw, Random Tail, and Wave order.</p><p>  在下面的可视化中，执行了八项测试。随机，升序，升锯，通用，降序，降锯，随机尾巴和波动顺序。</p><p>  In the visualization below one test is performed on a random distribution. This visualization more accurately shows the use of pointer operations to partition memory.</p><p>  在下面的可视化中，对随机分布执行一项测试。这种可视化效果更准确地显示了使用指针操作对内存进行分区。</p><p> Cyan numbers are unsorted, green numbers are sorted, white numbers are sorted and ready to bemerged, yellow numbers are the index upon which a binary search is performed to find out whereto insert the next number, magenta numbers are ready to be merged back to the main array.</p><p> 青色数字未排序，绿色数字已排序，白色数字已排序并准备合并，黄色数字是执行二进制搜索以找出要插入下一个数字的位置的索引，洋红色数字已准备好合并回到主数组。</p><p>   The following benchmark was on WSL gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) using the  wolfsort benchmark.The source code was compiled using g++ -O3 -w -fpermissive bench.c. The bar graph shows the best run out of 100 on 32 bit integers. Comparisons for gridsort and std::sort are inlined. The std::sort() in the benchmark should be an in-place IntroSort.</p><p>   以下基准测试是使用Wolfsort基准测试在WSL gcc版本7.5.0（Ubuntu 7.5.0-3ubuntu1〜18.04）上进行的。源代码是使用g ++ -O3 -w -fpermissive bench.c编译的。条形图显示了32位整数上100的最佳耗尽。内联了gridsort和std :: sort的比较。基准测试中的std :: sort（）应该是就地IntroSort。</p><p>       The following benchmark was on WSL gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1).The source code was compiled using gcc -O3 bench.c. The bar graph shows the best run out of 100 on 32 bit integers. Comparisons for gridsort and qsort are not inlined. The stdlib qsort() in the benchmark is a mergesort variant.</p><p>       以下基准测试是在WSL gcc版本7.4.0（Ubuntu 7.4.0-1ubuntu1〜18.04.1）上进行的。源代码是使用gcc -O3 bench.c编译的。条形图显示了32位整数上100的最佳耗尽。没有内联gridsort和qsort的比较。基准测试中的stdlib qsort（）是mergesort变体。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/scandum/gridsort">https://github.com/scandum/gridsort</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sort/">#sort</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gridsort/">#gridsort</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>