<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在X7中实现记录</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在X7中实现记录</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-19 17:01:34</div><div class="page_narrow text-break page_content"><p>X7是我用来探索语言设计和解释器的LISP。以下是它的问候世界：</p><p>；；定义输入的平方函数(Defn Square(X)(*x x))；谓词for x mod 4==1(Defn is-one-mod-4(X)(=1(%x 4)；；过滤并映射前200个数字(filter is-one-mod-4(map square(范围200)；；输出：(1 9 25 49 81 121 169 225...)。</p><p>X7拥有函数式语言提供的所有美好的、不变的、无状态的乐趣。它不能做的是表示内部有状态的类型，如文件或套接字。本文将解释如何以记录的形式向语言添加状态。</p><p>这样做的动机是，如果您想要操作文件(或实际上是任何IO)，操作系统希望您保持某种状态。有一些技巧可以避免内部可变状态，但将其添加到语言中会更有趣。</p><p>记录或对象允许我们将状态封装在一个位置，您可以对其调用方法。我们将致力于在x7中打开、写入和读取文件。它看起来是这样的：</p><p>；；打开文件(def my-file(fs：：open&#34；my_file.txt&#34；))；；.write是Record File的一个方法，；会将字符串写入文件(.write my-file&#34；Hello World&#34；)；；同样可以使用.read_to_string；；方法读取文件内容(.read_to_string my-file)。</p><p>要运行x7程序，我们需要将传入的字符串解析成我们可以实际计算的形式。这一点的核心是类型expr，它表示解释器中所有可能的类型：</p><p>所示的枚举成员是计算(+11)等简单表达式所需的最小变体。如果您不熟悉LISP，这就等同于1+1。</p><p>字符串&#34；(+11)&#34；需要转换成我们可以操作的类型。解析器的细节与本文无关。我们真正需要知道的就是(+11)被转换成下面的expr类型：</p><p>LISP的关键在于表达式，即类型只是存在并通过计算传播的概念。简单地说，求值是取一个表达式，然后返回另一个表达式的计算过程。例如，在x7解释器中键入3.3将返回3.3，这是另一个表达式。相比之下，(+11)要复杂得多，因为它表示将两个数字相加的函数调用。我们需要用我们的方式去那里。</p><p>要建立评估(+11)的方法，我们需要讨论表达式、符号和列表等核心概念。</p><p>如前所述，求值是x7功能的基础。更重要的是，不同类型的人评价不同！</p><p>&gt；&gt；3.3；；Num3.3&gt；&gt；&gt；(fn(X)(X))；；函数Fn&lt；AnonFn，1，[x]&gt；&gt；+；SymbolFn&lt；+，1，[]&gt；&gt；(+1 1)；列表2。</p><p>考虑到这种行为，我们需要更好地理解符号在解释器中是如何工作的。</p><p>符号充当对解释器中其他内容的引用-例如常量或函数。X7使用SymbolTable类型，该类型提供查找(&amp；self，key：&amp；expr)方法将符号映射到解释器中的表达式。</p><p>X7初始化过程的一部分是使用标准库填充符号表-或者使用make_stdlib_fns从RUST填充符号表！宏或stdlib/中的x7文件。如果我们禁用符号填充，您将看到x7运行良好，但不是很有用：</p><p>下一个领域是理解列表和符号之间的交互。X7(和LISP)中的列表求值是函数调用，约定如下：</p><p>然后，x7解释器的目标是将&lt；fn-expr&gt；求值为一个函数，然后使用参数调用该函数。绝大多数时间&lt；fn-expr&gt；将是一个符号，如+或-，因此它将是一个符号查找。然后，我们需要的过程：</p><p>If let OK(Mut List)=self.get_list(){//空列表Are_Not_Function调用if list.is_Empty(){return OK(self.clone())；}let head=list.op_front().unwire()；let ail=list；return head.eval(&amp；Symbol_table)？.call_fn(ail，Symbol_table)；}。</p><p>最后一行是可操作的行-我们计算第一项(HEAD)，然后使用CALL_FN方法调用函数。</p><p>评估HEAD，如果我们收到错误，请提前返回。最常见的错误只是符号没有解析。更奇怪的错误可能是，Head本身就是一个失败的函数调用。</p><p>更详细地说，Head可以对任何东西求值。虽然这种情况的目的是将符号映射到函数，但这里可能发生任何事情。如果我们不计算Head，Symbol(&#34；+&34；)永远不会成为函数fn&lt；+，1，[]&gt；。对于好奇的人来说，((if(Random_Bool)+-)105)是一个有效的x7程序。它随机返回5或15。</p><p>值得注意的是，我们不评估尾巴。要允许像if或cond这样的条件构造不计算未采用的分支，我们需要一种选择退出计算的方法！这是作为函数结构上的一个标志来实现的，该标志可以由标准库的rust部分控制。</p><p>现在我们已经概述了x7解释器的内部结构，我们实际上可以向语言中添加记录了！</p><p>为了表示内部有状态的类型，我们将向语言添加一个称为记录的特性。它需要表达以下行为：</p><p>除了调用方法之外，这些项目中的大多数都与确保错误消息正确相关，或者将其与其他解释器机器干净利落地插在一起。</p><p>/记录的基本特征。/记录允许x7表示各种内部可变类型/同时不会过度扩展expr枚举。如果这些类型需要文档，则负责/实现RecordDoc。Pub(Crate)特征记录：SYNC+Send{/调用此记录的方法。/(.method_name&lt；rec&gt；arg1 arg2 arg3)/变成：/(&amp；self：&lt；rec&gt；，sym：&#34；method_name&#34；，args：Vector！[arg1，arg2，arg3])fn call_method(&amp；self，sym：&amp；str，args：Vector&lt；expr&gt；)-&gt；LispResult&lt；expr&gt；/唯一标识此记录的FN ID(&amp；self)-&gt；U64{0}/正确显示记录类型。FN DISPLAY(&amp；Self)-&gt；string；/添加有关调试打印FN DEBUG(&amp；Self)-&gt；String；/克隆对象的更多信息。Fn clone(&amp；self)-&gt；RecordType；/返回帮助消息的方法名称。Fn方法(&amp；self)-&gt；vec&lt；&amp；#39；static str&&gt;；/返回尼斯帮助消息的类型名称fn type_name(&amp；self)-&gt；&amp；&#39；static str；}。</p><p>现在我们有了一个特征，我们需要一个可以在整个x7中导出和使用的基本类型。由于我们要使用特征对象，因此Box是一个自然的选择：</p><p>我将省略为RecordType实现Record的实现细节，但是如果您很好奇，可以在这里找到它们。</p><p>要将RecordType集成到语言中，我们需要将其添加到前面提到的expr枚举中。下面是我们添加记录之前的情况：</p><p>就这么简单。我们可以使用编译器错误来找出我们遗漏了什么。</p><p>/我们可以随心所欲地将任何内容插入到哈希图中，因此我们需要为RecordType{fn hash&lt；H：hasher&gt；(&amp；self，state：&amp；mut H){self.id().hash(State)；}}/我们还需要对RecordTypes进行相等检查/因为它们的内部状态可能不同，所以始终返回false。/这是可以改进的。RecordType的Iml PartialEq{fn eq(&amp；Self，_Other：&amp；RecordType)-&gt；bool{false}}/x7到处克隆RecordType的Iml Clone{fn Clone(&amp；Self)-&gt；RecordType{Record：：Clone(Self)}}</p><p>太棒了！我们现在已经为RecordType实现了必要的特性，除了像我的自定义显示实现这样的一些更改之外，我们可以开始工作了。</p><p>我们最不想要的就是在需要的时候从枚举中获取RecordType的方法：</p><p>实施表达式{//...。躲避了..。Pub(Crate)fn get_Record(&amp；self)-&gt；LispResult&lt；RecordType&gt；{if let expr：：Record(R)=self{OK(r.clone())}Else{Bad_Types！(&#34；Record&#34；，&amp；Self)}}。</p><p>这将允许我们获取标准库中的记录类型，如果不这样做，则会有很好的错误消息。</p><p>我们要做的下一件事是添加一个标准库函数来调用方法！</p><p>既然RecordType已经嵌入到解释器的机器中，我们就可以实际使用它了！我们需要一种显式调用标准库stdlib：：call_method中的方法的方法。</p><p>我们还没有.method-call语法糖，所以一个独立的x7函数就可以了。</p><p>我们只得到了一个参数列表，因此我们需要定义一个调用约定：</p><p>因此，我们将期望记录作为第一个成员，然后是方法名称，最后是参数。例如，下面是我们期望写入文件的方式：</p><p>Fn call_method(exprs：Vector&lt；expr&gt；，_Symbol_table：&amp；SymbolTable)-&gt；LispResult&lt；expr&gt；{//第一个列表成员是记录。设rec=exprs[0].get_record()？；//第二个列表成员为方法字符串。Let method=&amp；exprs[1].get_string()？；//收集列表中的参数。设args=exprs.clone().Slice(2.。)；//.clone()为O(1)，.Slice需要一个&amp；mut//最后，用参数调用记录上的方法使用Crate：：Records：：Record：：Record：：Record；rec.call_method(method，args)}。</p><p>现在我们有了这个函数，我们需要使它可以从解释器访问。X7使用名为make_stdlib_fns的宏向解释器公开rust函数，因此我们只需将其插入：</p><p>好的!。我们真的不能用它做很多事情，因为我们还没有在任何类型上实现记录，所以让我们这样做吧！</p><p>将记录添加到x7的最初动机是能够打开、读取和写入文件。我们将通过rust File结构支持x7 File实现，因此让我们在x7-Records/file.rs中创建一个新文件：</p><p>#[Deriate(Clone，Debug)]pub(Crate)struct FileRecord{path：string，//记录特性需要同步+发送文件：arc&lt；mutex&lt；std：：fs：：file&gt；&gt；，}。</p><p>现在我们有了一个结构，让我们公开一种从x7生成结构的方法。我们希望下面的x7表达式起作用：</p><p>Impl FileRecord{/使用给定路径pub(Crate)fn open_file(path：string)-&gt；LispResult&lt；expr&gt；{//使用自由权限打开文件。让f=OpenOptions：：new().write(True).create(True).read(True).open(path.clone()).map_err(|e|无论如何！(&#34；无法打开文件\&#34；{}\&#34；因为{}&#34；，&amp；path，e)？；//使路径美观。让abs_path=fs：：canonicalize(Path).map_err(|e|无论如何！(&#34；无法规范化路径！{}&#34；，e))？.to_str().ok_or_Else(||无论如何！(&#34；无法将路径表示为UTF-8字符串&#34；))？.into()；//记录！是帮助制作LispResult&lt；expr：：Record&gt；类型记录的宏！(FileRecord：：New(f，abs_path))}/从x7打开文件/此函数签名允许我们将其直接暴露给_x7的解释器pub(Crate)fn(表达式：Vector&lt；expr&gt；，_Symbol_table：&amp；SymbolTable)-&gt；LispResult&lt；expr&gt；{exact_len！(exprs，1)；let path=exprs[0].get_string()？；FileRecord：：open_file(Path)}}</p><p>现在我们有了创建FileRecord的能力，我们将需要实现Record以便解释器(expr：：Record)能够理解它。</p><p>FileRecord{fn call_method(&amp；self，sym：&amp；str，args：Vector&lt；expr&gt；)-&gt；LispResult&lt；expr&gt；{//我们还没有方法。UNKNOWN_METHOD！(SELF，sym)}FN TYPE_NAME(&amp；self)-&gt；&amp；&39；static str{&amp；FileRecord&#34；}FN DISPLAY(&amp；self)-&gt；string{format！(&#34；File&lt；{}&gt；&#34；，self.path)}FN DEBUG(&amp；self)-&gt；String{self.display()}FN CLONE(&amp；Self)-&gt；RecordType{Box：：New(Clone：：Clone(Self))}FN方法(&amp；Self)-&gt；Vec&lt；&amp；&39；Static str&gt；{Vec：：New()}FN ID(&amp；Self)-&gt；U64{使用STD：：Collection：：hash_map：：DefaultHasher；使用std：：hash：：{hash，hasher}；让mut h=DefaultHasher：：New()；self.path.hash(&amp；mut h)；h.Finish()}}。</p><p>我们还需要向解释器公开FileRecord：：from_x7，因此让&#39；返回并将其添加到make_stdlib_fns：</p><p>Make_stdlib_fns！{//省略函数...。(&#34；call_method&#34；，2，call_method，true，&#34；&lt；doc-string&gt；&#34；)，//打开文件(&#34；fs：：open&#34；，1，FileRecord：：from_x7，true，&#34；打开文件。&#34；)，}。</p><p>好的!。我们已经打开了一个文件。我们现在可以在FileRecord上实现一些其他有用的方法，比如从文件中读取：</p><p>Impl FileRecord{/将文件内容读入字符串，/将光标倒带到前面。Fn read_all(&amp；self)-&gt；LispResult&lt；string&gt；{let mut buf=string：：new()；let mut Guard=self.file.lock()；Guard.read_to_string(&amp；mut buf).map_err(|e|无论如何！(&#34；无法读取字符串{}&#34；，e))？；rewind_file！(Guard)；OK(Buf)}/将FileRecord的内容读取到字符串。Fn read_to_string(&amp；self，args：Vector&lt；expr&gt；)-&gt；LispResult&lt；expr&gt；{//我们不需要参数。完全正确！(args，0)；self.read_all().map(expr：：string)}}。</p><p>FileRecord的IMPL记录{fn call_method(&amp；self，sym：&amp；str，args：Vector&lt；expr&gt；)-&gt；LispResult&lt；expr&gt；{Match sym{&#34；read_to_string&#34；=&gt；self.read_to_string(Args)，_=&gt；UNKNOWN_METHOD！(SELF，SYM)，}。</p><p>太棒了！我们能够调用FileRecord上的方法。实现.write和其他有用的文件操作是相同的过程，因此我们将省略它。这是很棒的东西，加点语法糖就更好了。</p><p>我们可以修改解析器以识别句点，并将其解析成为我们调用我们的方法的函数，而不需要在解析器中获得太多信息，而是将.method解析成expr：：symbol.我们可以修改解析器来识别句点。</p><p>Fn parse_Symbol&lt；&#39；a&gt；(i：&amp；&39；a str)-&gt；IResult&lt；&amp；&amp；a str，expr，VerboseError&lt；&amp；&39；a str；&gt；{map(taken_while e1(Is_Symbol_Char)，|sym：&amp；str|{expr：：Symbol(sym.into()}))(I)}。</p><p>因此，它所做的就是尝试识别一个符号，然后在完全解析一个符号时转换类型。我们将修改它以识别符号是否以句点开头，如果是，则调用make_method_call并返回一个expr：：函数。</p><p>Fn make_method_call(method：string)-&gt；expr{//导入一些有用的类型使用Crate：：Symbols：：Function；使用std：：sync：：Arc；let method_clone=method.clone()；//这是很酷的部分。我们正在创建符合//X7FunctionPtr类型的闭包。//当我们调用.write时，它将调用此函数。让method_fn=Move|args：Vector&lt；expr&gt；，_sym：&amp；SymbolTable|{//第一项是记录，get_record(){OK(Rec)=&gt；rec，err(E)=&gt；return err(E)，}；//`rec`是记录，调用该方法。//请注意，我们将`method_clone`移到了this闭包中！Use Crate：：Records：：Record；//`args`的布局是：(&lt；record&gt；&lt；arg1&gt；&lt；arg2&gt；...)，//我们有的类型签名是record：：call_method(method，args)rec.call_method(&amp；method_clone，args.clone().Slice(1.。))；}；//创建函数结构let f=function：：new(format！(&#34；method_call&lt；{}&gt；&#34；，method)，//函数名1，//参数个数Arc：：new(Method_Fn)，//函数指针true，//eval args)；//返回expr：：function expr：：function(F)}。</p><p>这相当酷--我们正在将一个符号转换成一个函数。我们所需要做的就是在parse_symbol中添加一个if-gate，然后我们就重新设置了！</p><p>Fn parse_Symbol&lt；(i：&amp；&39；a str)-&gt；IResult&lt；&amp；#39；a str，expr，VerboseError&lt；&amp；&amp；{map(Take_While e1(Is_Symbol_Char)，|sym：&amp；str|{if sym.starts_with(&#39；.&#39；){make_method_call(sym[1].&#39；){make_method_call(sym[1]，|sym：&amp；str|{if sym.start_with(&#39；.&#39；){make_method_call(sym[1.。].into()//sym[1..]=&gt；删除句点}否则{expr：：Symbol(sym.into())}})(I)}。</p><p>就是这样！我们已经在x7中实现了记录。我希望你喜欢读这篇文章！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://dpbriggs.ca/blog/Implementing-Method-Calls-In-x7">https://dpbriggs.ca/blog/Implementing-Method-Calls-In-x7</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/records/">#records</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/x7/">#x7</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1024417.html"><img src="http://img2.diglog.com/img/2020/9/thumb_e7777ae520534fac8cd87985fb74598e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1024417.html">
JupiterOne筹集1900万美元首轮融资，实现网络资产管理自动化</a></div><span class="my_story_list_date">2020-9-17 5:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1023908.html"><img src="http://img2.diglog.com/img/2020/9/thumb_aec36799a6a43e58bed218639d7035d4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1023908.html">我如何在我的长期项目中保持动力</a></div><span class="my_story_list_date">2020-9-15 0:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019949.html"><img src="http://img.diglog.com/img/2020/8/thumb_e3e3c53c81cc405d75899b6436b8ec4f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019949.html">用JavaScript实现幻想CPU的仿真器</a></div><span class="my_story_list_date">2020-8-24 3:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019701.html"><img src="http://img.diglog.com/img/2020/8/thumb_95b90d0f787c6a5cbe37788adc7b9f77.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019701.html">在Go-Blog中实现Traceroute</a></div><span class="my_story_list_date">2020-8-22 6:56</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>