<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>OAuth 2.0身份验证漏洞 OAuth 2.0 Authentication Vulnerabilities</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">OAuth 2.0 Authentication Vulnerabilities<br/>OAuth 2.0身份验证漏洞 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-29 00:06:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/c9ded08ae970ed445d65c70e049c5bb0.png"><img src="http://img2.diglog.com/img/2021/3/c9ded08ae970ed445d65c70e049c5bb0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>While browsing the web, you&#39;ve almost certainly come across sites that let you log in using your social media account. The chances are that this feature is built using the popular OAuth 2.0 framework. OAuth 2.0 is highly interesting for attackers because it is both extremely common and inherently prone to implementation mistakes. This can result in a number of vulnerabilities, allowing attackers to obtain sensitive user data and potentially bypass authentication completely.</p><p>在浏览网络时，您＆＃39;几乎肯定会遇到遍布您使用社交媒体帐户登录的网站。此功能是使用流行的OAuth 2.0框架构建此功能。 OAuth 2.0对攻击者来说非常有趣，因为它既非常常见，并且本质上容易实现错误。这可能导致许多漏洞，允许攻击者获得敏感的用户数据并完全逐步绕过身份验证。</p><p>  In this section, we&#39;ll teach you how to identify and exploit some of the key  vulnerabilities found in OAuth 2.0 authentication mechanisms. Don&#39;t worry if you&#39;re not too familiar with OAuth authentication - we&#39;ve provided plenty of background information to help you understand the key concepts you&#39;ll need. We&#39;ll also explore some  vulnerabilities in OAuth&#39;s OpenID Connect extension. Finally, we&#39;ve included some guidance on how to  protect your own applications against these kinds of attacks.</p><p>  在本节中，我们＆＃39; ll教你如何识别和利用OAuth 2.0身份验证机制中找到的一些关键漏洞。不要担心，如果你＆＃39;重新熟悉OAuth身份验证 - 我们提供了大量的背景信息，以帮助您了解您的关键概念＆＃39; ll需要。我们＆＃39; LL还探索OAuth＆＃39; S OpenID Connect扩展中的一些漏洞。最后，我们＆＃39; ve包括一些关于如何保护自己的应用程序免受这些类型的攻击的指导。</p><p>    As usual, we&#39;ve provided a series of deliberately vulnerable websites, known as &#34;labs&#34;, so that you can see these vulnerabilities in practice and put what you&#39;ve learned about exploiting them to the test. If you&#39;d prefer to dive straight into the labs, you can access the full list from our labs index page.</p><p>    像往常一样，我们＆＃39;已经提供了一系列故意脆弱的网站，被称为＆＃34;实验室＆＃34 ;,这样就可以在实践中看到了这些漏洞，并把你＆＃39;已经了解了他们开发的测试。如果您＆＃39更喜欢直接潜入实验室，您可以从我们的Labs索引页面访问完整列表。</p><p>      OAuth is a commonly used authorization framework that enables websites and web applications to request limited access to a user&#39;s account on another application. Crucially, OAuth allows the user to grant this access without exposing their login credentials to the requesting application. This means users can fine-tune which data they want to share rather than having to hand over full control of their account to a third party.</p><p>      OAuth是一个常用的授权框架，使网站和Web应用程序能够请求有限访问用户＆＃39; s帐户在另一个应用程序上。至关重要的是，OAuth允许用户授予此访问，而不会将其登录凭据暴露给请求应用程序。这意味着用户可以精细调整他们想要分享的数据，而不是不得不完全控制他们的帐户到第三方。</p><p>  The basic OAuth process is widely used to integrate third-party functionality that requires access to certain data from a user&#39;s account. For example, an application might use OAuth to request access to your email contacts list so that it can suggest people to connect with. However, the same mechanism is also used to provide third-party authentication services, allowing users to log in with an account that they have with a different website.</p><p>  基本的OAuth进程广泛用于集成需要访问用户＆＃39; S帐户的某些数据的第三方功能。例如，应用程序可能会使用OAuth来请求访问电子邮件联系人列表，以便它可以建议人们连接。但是，相同的机制也用于提供第三方认证服务，允许用户使用与不同的网站有不同的帐户登录。</p><p>  Although OAuth 2.0 is the current standard, some websites still use the legacy version 1a. OAuth 2.0 was written from scratch rather than being developed directly from OAuth 1.0. As a result, the two are very different. Please be aware that the term &#34;OAuth&#34; refers exclusively to OAuth 2.0 throughout these materials.</p><p>  虽然OAuth 2.0是当前标准，但某些网站仍然使用旧版版本1a。 OAuth 2.0由划痕写入，而不是直接从OAuth 1.0开发。结果，这两个是非常不同的。请注意，这个词和＃34; OAuth＆＃34;在整个这些材料中专门引用OAuth 2.0。</p><p>    OAuth 2.0 was originally developed as a way of sharing access to specific data between applications. It works by defining a series of interactions between three distinct parties, namely a client application, a resource owner, and the OAuth service provider.</p><p>    OAuth 2.0最初开发为分享对应用程序之间特定数据的访问方式。它通过定义三个不同方之间的一系列交互，即客户端应用程序，资源所有者和OAuth服务提供商。 </p><p>  Client application - The website or web application that wants to access the user&#39;s data.</p><p>客户端应用程序 - 想要访问用户＆＃39; s数据的网站或Web应用程序。</p><p>    OAuth service provider - The website or application that controls the user&#39;s data and access to it. They support OAuth by providing an API for interacting with both an authorization server and a resource server.</p><p>    OAuth服务提供商 - 控制用户的网站或应用程序和数据和访问它。它们通过提供与授权服务器和资源服务器交互的API来支持OAuth。</p><p>  There are numerous different ways that the actual OAuth process can be implemented. These are known as OAuth &#34;flows&#34; or &#34;grant types&#34;. In this topic, we&#39;ll focus on the &#34;authorization code&#34; and &#34;implicit&#34; grant types as these are by far the most common. Broadly speaking, both of these grant types involve the following stages:</p><p>  可以实现实际OAuth过程的许多不同的方法。这些被称为OAuth＆＃34;流动＆＃34;或＆＃34;授予类型＆＃34;在这个主题中，我们＆＃39; ll专注于＆＃34;授权码＆＃34;和＃34;隐式＆＃34;授予类型，因为这些类型是最常见的。广泛地说，这两个授予类型都涉及以下阶段：</p><p>  The client application requests access to a subset of the user&#39;s data, specifying which grant type they want to use and what kind of access they want.</p><p>  客户端应用程序请求访问用户＆＃39; s数据的子集，指定他们想要使用的授权类型以及他们想要的任何类型的访问。</p><p>  The user is prompted to log in to the OAuth service and explicitly give their consent for the requested access.</p><p>  提示用户登录OAuth Service，并明确表示同意所请求的访问。</p><p>  The client application receives a unique access token that proves they have permission from the user to access the requested data. Exactly how this happens varies significantly depending on the grant type.</p><p>  客户端应用程序收到唯一的访问令牌，证明他们有权从用户访问所请求的数据。根据授权类型，究竟如何发生这种情况。</p><p>  The client application uses this access token to make API calls fetching the relevant data from the resource server.</p><p>  客户端应用程序使用此访问令牌来使API调用从资源服务器获取相关数据。 </p><p>  Before learning how OAuth is used for authentication, it&#39;s important to understand the fundamentals of this basic OAuth process. If you&#39;re completely new to OAuth, we recommend familiarizing yourself with the details of both of the grant types we&#39;re going to cover before reading further.</p><p>在学习OAUTH如何用于身份验证之前，它非常重要，了解这一基本OAuth流程的基本面。如果您与OAuth完全新的，我们建议您熟悉授予我们＆＃39的授予类型的详细信息;重新覆盖进一步阅读前。</p><p>      Although not originally intended for this purpose, OAuth has evolved into a means of authenticating users as well. For example, you&#39;re probably familiar with the option many websites provide to log in using your existing social media account rather than having to register with the website in question. Whenever you see this option, there&#39;s a good chance it is built on OAuth 2.0.</p><p>      虽然最初未用于此目的，但OAuth也进化为验证用户的手段。例如，您可能熟悉了许多网站的选项，以使用现有的社交媒体帐户登录的选项，而不是必须与有问题的网站注册。每当你看到这个选项时，那就＆＃39;它是一个很好的机会，它建立在OAuth 2.0上。</p><p>  For OAuth authentication mechanisms, the basic OAuth flows remain largely the same; the main difference is how the client application uses the data that it receives. From an end-user perspective, the result of OAuth authentication is something that broadly resembles SAML-based single sign-on (SSO). In these materials, we&#39;ll focus exclusively on vulnerabilities in this SSO-like use case.</p><p>  对于OAuth身份验证机制，基本OAuth流程仍然是相同的;主要区别是客户端应用程序如何使用它收到的数据。从最终用户的角度来看，OAuth身份验证的结果是广泛类似于SAML的单点登录（SSO）的原因。在这些材料中，我们＆＃39; LL专注于此SSO的用例中的漏洞。</p><p>    The user chooses the option to log in with their social media account. The client application then uses the social media site&#39;s OAuth service to request access to some data that it can use to identify the user. This could be the email address that is registered with their account, for example.</p><p>    用户选择使用社交媒体帐户登录的选项。然后，客户端应用程序使用社交媒体站点＆＃39; s OAuth服务来请求访问它可以用于识别用户的某些数据。例如，这可以是其帐户注册的电子邮件地址。</p><p>  After receiving an access token, the client application requests this data from the resource server, typically from a dedicated  /userinfo endpoint.</p><p>  在接收到访问令牌后，客户端应用程序通常从资源服务器请求该数据，通常来自专用/ userInfo端点。</p><p>  Once it has received the data, the client application uses it in place of a username to log the user in. The access token that it received from the authorization server is often used instead of a traditional password.</p><p>  一旦收到数据，客户端应用程序就会代替用户名来登录用户名。从授权服务器接收的访问令牌通常使用而不是传统密码。</p><p>  You can see a simple example of how this looks in the following lab. Just complete the &#34;Log in with social media&#34; option while proxying traffic through Burp, then study the series of OAuth interactions in the proxy history. You can log in using the credentials  wiener:peter. Note that this implementation is deliberately vulnerable - we&#39;ll teach you how to exploit this later.</p><p>  您可以看到一个简单的例子，即如何在以下实验室中查找。刚完成＆＃34;登录社交媒体和＃34;通过Burp代理流量的选项，然后在代理历史记录中研究一系列OAuth交互。您可以使用凭据Wiener登录：Peter。请注意，此实现是故意脆弱的 - 我们＆＃39; LL教你如何稍后剥离。 </p><p>      OAuth authentication vulnerabilities arise partly because the OAuth specification is relatively vague and flexible by design. Although there are a handful of mandatory components required for the basic functionality of each grant type, the vast majority of the implementation is completely optional. This includes many configuration settings that are necessary for keeping users&#39; data secure. In short, there&#39;s plenty of opportunity for bad practice to creep in.</p><p>OAuth身份验证漏洞部分地出现，因为OAuth规范的设计相对模糊，灵活。虽然每个授予类型的基本功能所需的少量强制性组件，但绝大多数实施是完全可选的。这包括保持用户＆＃39所必需的许多配置设置;数据安全。简而言之，有足够的机会来蠕动的不良做法。</p><p>  One of the other key issues with OAuth is the general lack of built-in security features. The security relies almost entirely on developers using the right combination of configuration options and implementing their own additional security measures on top, such as robust input validation. As you&#39;ve probably gathered, there&#39;s a lot to take in and this is quite easy to get wrong if you&#39;re inexperienced with OAuth.</p><p>  OAuth的其他关键问题之一是普遍缺乏内置安全功能。安全性依赖于使用配置选项的正确组合和在顶部实现自己的额外安全措施，例如强大的输入验证。像你＆＃39;可能会聚集在那里，有很多东西，如果你＆＃39;重新经历OAuth，这很容易出错。</p><p>  Depending on the grant type, highly sensitive data is also sent via the browser, which presents various opportunities for an attacker to intercept it.</p><p>  根据授权类型，也通过浏览器发送高度敏感的数据，这为攻击者拦截了各种机会。</p><p>    Recognizing when an application is using OAuth authentication is relatively straightforward. If you see an option to log in using your account from a different website, this is a strong indication that OAuth is being used.</p><p>    识别应用程序使用OAuth身份验证时相对简单。如果您看到要使用不同网站使用帐户登录的选项，则这是在使用OAuth的强烈指示。</p><p>  The most reliable way to identify OAuth authentication is to proxy your traffic through Burp and check the corresponding HTTP messages when you use this login option. Regardless of which OAuth grant type is being used, the first request of the flow will always be a request to the  /authorization endpoint containing a number of query parameters that are used specifically for OAuth. In particular, keep an eye out for the  client_id,  redirect_uri, and  response_type parameters. For example, an authorization request will usually look something like this:</p><p>  识别OAuth身份验证最可靠的方法是通过Burp来代理您的流量，并在使用此登录选项时检查相应的HTTP消息。无论是否使用哪个OAuth授权类型，流程的第一个请求将始终是包含许多用于OAUTH的查询参数的/授权端点的请求。特别是，对Client_ID，Redirect_URI和Response_type参数留出遥留。例如，授权请求通常看起来像这样：</p><p>      Doing some basic recon of the OAuth service being used can point you in the right direction when it comes to identifying vulnerabilities.</p><p>      在识别漏洞方面，使用正在使用的OAuth服务的一些基本录制可以指向您的正确方向。</p><p>  It goes without saying that you should study the various HTTP interactions that make up the OAuth flow - we&#39;ll go over some specific things to look out for later. If an external OAuth service is used, you should be able to identify the specific provider from the hostname to which the authorization request is sent. As these services provide a public API, there is often detailed documentation available that should tell you all kinds of useful information, such as the exact names of the endpoints and which configuration options are being used.</p><p>  不言而喻，您应该研究构成OAuth流的各种HTTP交互 - 我们＆＃39; LL浏览一些特定的东西来稍后要看。如果使用外部OAuth服务，则应该能够从发送授权请求的主机名中识别特定提供程序。由于这些服务提供了一个公共API，通常有详细的文档可用于告诉您各种有用的信息，例如端点的确切名称以及正在使用的配置选项。 </p><p>  Once you know the hostname of the authorization server, you should always try sending a  GET request to the following standard endpoints:</p><p>了解授权服务器的主机名后，应始终尝试将GET请求发送到以下标准端点：</p><p>    These will often return a JSON configuration file containing key information, such as details of additional features that may be supported. This will sometimes tip you off about a wider attack surface and supported features that may not be mentioned in the documentation.</p><p>    这些通常会返回包含关键信息的JSON配置文件，例如可以支持的附加功能的详细信息。这有时会提示您在文档中可能未提及的更广泛的攻击表面和支持的功能。</p><p>    Vulnerabilities can arise in the client application&#39;s implementation of OAuth as well as in the configuration of the OAuth service itself. In this section, we&#39;ll show you how to exploit some of the most common vulnerabilities in both of these contexts.</p><p>    客户申请中可能会出现漏洞＆＃39; oauth的实施以及OAuth服务本身的配置。在本节中，我们＆＃39; ll向您展示如何利用这两个上下文中的一些最常见的漏洞。</p><p>      Client applications will often use a reputable, battle-hardened OAuth service that is well protected against widely known exploits. However, their own side of the implementation may be less secure.</p><p>      客户端应用程序通常会使用信誉良好的战斗，并良好地保护广泛的已知漏洞利用良好的oauth服务。但是，他们自己的实施方面可能不那么安全。</p><p>  As we&#39;ve already mentioned, the OAuth specification is relatively loosely defined. This is especially true with regard to the implementation by the client application. There are a lot of moving parts in an OAuth flow, with many optional parameters and configuration settings in each grant type, which means there&#39;s plenty of scope for misconfigurations.</p><p>  正如我们已经提到的那样，OAuth规范相对松散地定义。对于客户申请的实现尤其如此。 OAuth流中有很多活动部件，每个授予类型中有许多可选的参数和配置设置，这意味着有大量的错误控制范围。</p><p>    Due to the dangers introduced by sending access tokens via the browser, the  implicit grant type is mainly recommended for single-page applications. However, it is also often used in classic client-server web applications because of its relative simplicity.</p><p>    由于通过浏览器发送访问令牌引入的危险，主要推荐用于单页应用的隐式授予类型。但是，它通常也用于经典的客户端 - 服务器Web应用程序，因为它相对简单。</p><p>  In this flow, the access token is sent from the OAuth service to the client application via the user&#39;s browser as a URL fragment. The client application then accesses the token using JavaScript. The trouble is, if the application wants to maintain the session after the user closes the page, it needs to store the current user data (normally a user ID and the access token) somewhere.</p><p>  在此流程中，访问令牌通过用户＆＃39; s浏览器从OAuth服务发送到客户端应用程序作为URL片段。然后，客户端应用程序使用JavaScript访问令牌。问题是，如果应用程序想要在用户关闭页面后维护会话，则需要将当前用户数据（通常是用户ID和访问令牌）存储在某处。 </p><p>  To solve this problem, the client application will often submit this data to the server in a  POST request and then assign the user a session cookie, effectively logging them in. This request is roughly equivalent to the form submission request that might be sent as part of a classic, password-based login. However, in this scenario, the server does not have any secrets or passwords to compare with the submitted data, which means that it is implicitly trusted.</p><p>为了解决这个问题，客户端应用程序通常会在POST请求中将此数据提交到服务器，然后为用户分配会话cookie，有效地记录。此请求大致相当于可能作为零件发送的表单提交请求基于经典的密码登录。但是，在这种情况下，服务器没有任何秘密或密码来与提交的数据进行比较，这意味着它是隐式信任的。</p><p>  In the implicit flow, this  POST request is exposed to attackers via their browser. As a result, this behavior can lead to a serious vulnerability if the client application doesn&#39;t properly check that the access token matches the other data in the request. In this case, an attacker can simply change the parameters sent to the server to impersonate any user.</p><p>  在隐式流动中，该帖子请求通过浏览器暴露给攻击者。因此，如果客户端应用程序不正确检查访问令牌是否与请求中的其他数据匹配，则此行为可能导致严重漏洞。在这种情况下，攻击者可以简单地将发送给服务器发送到服务器以模拟任何用户的参数。</p><p>      Although many components of the OAuth flows are optional, some of them are strongly recommended unless there&#39;s an important reason not to use them. One such example is the  state parameter.</p><p>      虽然OAuth流的许多组件是可选的，但是，除非有没有使用它们的重要原因，否则将强烈建议其中一些组件。一个这样的示例是状态参数。</p><p>  The  state parameter should ideally contain an unguessable value, such as the hash of something tied to the user&#39;s session when it first initiates the OAuth flow. This value is then passed back and forth between the client application and the OAuth service as a form of  CSRF token for the client application. Therefore, if you notice that the authorization request does not send a  state parameter, this is extremely interesting from an attacker&#39;s perspective. It potentially means that they can initiate an OAuth flow themselves before tricking a user&#39;s browser into completing it, similar to a traditional  CSRF attack. This can have severe consequences depending on how OAuth is being used by the client application.</p><p>  状态参数应该理想地包含一个不间断的值，例如与用户绑定的东西的散列; s＆＃39; s会话首次启动OAuth流程时。然后，此值将在客户端应用程序和OAuth服务之间来回通过，作为客户端应用程序的CSRF令牌的形式。因此，如果您注意到授权请求不发送状态参数，这对攻击者的透视非常有趣。它可能意味着他们可以在欺骗用户欺骗浏览器之前启动OAuth流动，类似于传统的CSRF攻击。这取决于客户端应用程序如何使用OAuth的严重后果。</p><p>  Consider a website that allows users to log in using either a classic, password-based mechanism or by linking their account to a social media profile using OAuth. In this case, if the application fails to use the  state parameter, an attacker could potentially hijack a victim user&#39;s account on the client application by binding it to their own social media account.</p><p>  考虑一个网站，允许用户使用经典，基于密码的机制或通过使用OAuth将其帐户链接到社交媒体配置文件的网站。在这种情况下，如果应用程序无法使用状态参数，则攻击者可能会通过将其绑定到自己的社交媒体帐户来劫持受害者用户＆＃39; s帐户。</p><p>    Note that if the site allows users to log in exclusively via OAuth, the  state parameter is arguably less critical. However, not using a  state parameter can still allow attackers to construct login CSRF attacks, whereby the user is tricked into logging in to the attacker&#39;s account.</p><p>    请注意，如果站点允许用户专门通过OAUTH登录，则状态参数可以变得不那么重要。但是，不使用状态参数仍然可以允许攻击者构建登录CSRF攻击，从而欺骗用户登录攻击者＆＃39; s帐户。</p><p>    Perhaps the most infamous OAuth-based vulnerability is when the configuration of the OAuth service itself enables attackers to steal authorization codes or access tokens associated with other users&#39; accounts. By stealing a valid code or token, the attacker may be able to access the victim&#39;s data. Ultimately, this can completely compromise their account - the attacker could potentially log in as the victim user on any client application that is registered with this OAuth service.</p><p>    也许是最昭着的基于OAuth的漏洞是当OAuth服务本身的配置使攻击者能够窃取与其他用户相关联的授权代码或访问令牌;帐户。通过窃取有效的代码或令牌，攻击者可能能够访问受害者＆＃39; s数据。最终，这可以完全妥协他们的帐户 - 攻击者可能会在以此OAuth服务注册的任何客户端应用程序上作为受害者用户身份登录。 </p><p>  Depending on the grant type, either a code or token is sent via the victim&#39;s browser to the  /callback endpoint specified in the  redirect_uri parameter of the authorization request. If the OAuth service fails to validate this URI properly, an attacker may be able to construct a CSRF-like attack, tricking the victim&#39;s browser into initiating an OAuth flow that will send the code or token to an attacker-controlled  redirect_uri.</p><p>根据授权类型，代码或令牌通过受害者＆＃39; s浏览器发送到授权请求的redirect_uri参数中指定的/回调端点。如果OAuth服务无法正常验证此URI，则攻击者可能能够构建类似CSRF的攻击，欺骗受害者和＃39;浏览器，以启动将代码或令牌发送到攻击者控制的redirect_uri的OAuth流程。</p><p>  In the case of the authorization code flow, an attacker can potentially steal the victim&#39;s code before it is used. They can then send this code to the client application&#39;s legitimate  /callback endpoint (the original  redirect_uri) to get access to the user&#39;s account. In this scenario, an attacker does not even need to know the client secret or the resulting access token. As long as the victim has a valid session with the OAuth service, the client application will simply complete the code/token exchange on the attacker&#39;s behalf before logging them in to the victim&#39;s account.</p><p>  在授权代码流的情况下，攻击者可能会在使用之前窃取受害者＆＃39; s代码。然后，它们可以将此代码发送到客户端应用程序＆＃39; s合法/回调端点（原始redirect_uri）以访问用户＆＃39; s帐户。在这种情况下，攻击者甚至不需要了解客户端密钥或生成的访问令牌。只要受害者与OAuth服务有了有效的会话，客户端应用程序就会在登录受害者之前完成攻击者和＃39; s的代码/令牌交换。</p><p>  Note that using  state or  nonce protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser.</p><p>  请注意，使用状态或随机保护不一定会阻止这些攻击，因为攻击者可以从自己的浏览器生成新值。</p><p>    More secure authorization servers will require a  redirect_uri parameter to be sent when exchanging the code as well. The server can then check whether this matches the one it received in the initial authorization request and reject the exchange if not. As this happens in server-to-server requests via a secure back-channel, the attacker is not able to control this second  redirect_uri parameter.</p><p>    更安全的授权服务器还需要在交换代码时发送redirect_uri参数。然后，服务器可以检查这是否与初始授权请求中收到的那个匹配，并拒绝交换否则。由于这在通过安全反向通道的服务器到服务器请求中发生，因此攻击者无法控制第二个redirect_uri参数。</p><p>    Due to the kinds of attacks seen in the previous lab, it is best practice for client applications to provide a whitelist of their genuine callback URIs when registering with the OAuth service. This way, when the OAuth service receives a new request, it can validate the  redirect_uri parameter against this whitelist. In this case, supplying an external URI will likely result in an error. However, there may still be ways to bypass this validation.</p><p>    由于在上一个实验室中看到的各种攻击，在注册OAuth服务时，客户应用程序为客户端申请提供了一个正版回调URI的白名单是最好的。这样，当OAuth服务接收到新请求时，它可以对此白名单验证redirect_uri参数。在这种情况下，提供外部URI可能会导致错误。但是，可能仍有方法来绕过这种验证。</p><p>  When auditing an OAuth flow, you should try experimenting with the  redirect_uri parameter to understand how it is being validated. For example:</p><p>  审核OAuth流时，您应该尝试使用Redirect_Uri参数来了解它是如何验证的。例如：</p><p>  Some implementations allow for a range of subdirectories by checking only that the string starts with the correct sequence of characters i.e. an approved domain. You should try removing or adding arbitrary paths, query parameters, and fragments to see what you can change without triggering an error.</p><p>  某些实现允许通过仅检查字符串以正确的字符序列序列来允许一系列子目录i.e.批准的域。您应该尝试删除或添加任意路径，查询参数和片段，以查看您可以在不触发错误的情况下更改。 </p><p>  If you can append extra values to the default  redirect_uri parameter, you might be able to exploit discrepancies between the parsing of the URI by the different components of the OAuth service. For example, you can try techniques such as:    https://default-host.com &amp;@foo.evil-user.net#@bar.evil-user.net/   If you&#39;re not familiar with these techniques, we recommend reading our content on how to  circumvent common SSRF defences and  CORS.</p><p>如果您可以将额外的值附加到默认的redirect_uri参数，则可以通过OAuth服务的不同组件来利用URI解析之间的差异。例如，您可以尝试以下方式：https://default-host.com＆amp; @ foo.evil-user.net＃@ bar.evil-user.net /如果您＆＃39;重复不熟悉这些技术，我们建议阅读我们的内容，以如何规避共同的SSRF防御和CORS。</p><p>  You may occasionally come across server-side parameter pollution vulnerabilities. Just in case, you should try submitting duplicate  redirect_uri parameters as follows:    https://oauth-authorization-server.com/?client_id=123&amp;redirect_uri=client-app.com/callback&amp;redirect_uri=evil-user.net</p><p>  您可能偶尔会遇到服务器端参数污染漏洞。只是在情况下，您应该尝试提交重复的redirect_uri参数，如下所示：https://oauth-authorization-server.com/?client_id=123 &amp ;edirect_uri= client-app.com/callback＆骤数;redirect_uri=evil-user.net</p><p>  Some servers also give special treatment to  localhost URIs as they&#39;re often used during development. In some cases, any redirect URI beginning with  localhost may be accidentally permitted in the production environment. This could allow you to bypass the validation by registering a domain name such as  localhost.evil-user.net.</p><p>  某些服务器还将特殊的处理给Localhost Uri，因为它们经常在开发期间使用。在某些情况下，可以在生产环境中意外允许使用localhost开始的任何重定向URI。这可能允许您通过注册域名（例如localhost.evil-user.net）绕过验证。</p><p>  It is important to note that you shouldn&#39;t limit your testing to just probing the  redirect_uri parameter in isolation. In the wild, you will often need to experiment with different combinations of changes to several parameters. Sometimes changing one parameter can affect the validation of others. For example, changing the  response_mode from  query to  fragment can sometimes completely alter the parsing of the  redirect_uri, allowing you to submit URIs that would otherwise be blocked. Likewise, if you notice that the  web_message response mode is supported, this often allows a wider range of subdomains in the  redirect_uri.</p><p>  值得注意的是，您应该限制您的测试，以便在隔离中探测redirect_uri参数。在野外，您经常需要尝试不同的变化组合到几个参数。有时改变一个参数会影响他人的验证。例如，将response_mode从查询更改为片段，有时可以完全更改redirect_uri的解析，允许您提交否则会被阻止的URI。同样，如果您注意到支持Web_Message响应模式，则这通常允许更广泛的redirect_uri子域。</p><p>    Against more robust targets, you might find that no matter what you try, you are unable to successfully submit an external domain as the  redirect_uri. However, that doesn&#39;t mean it&#39;s time to give up.</p><p>    针对更强大的目标，您可能会发现无论您尝试什么，您都无法成功提交外部域作为redirect_uri。然而，这不起作用，这意味着它＆＃39;时间放弃。</p><p>  By this stage, you should have a relatively good understanding of which parts of the URI you can tamper with. The key now is to use this knowledge to try and access a wider attack surface within the client application itself. In other words, try to work out whether you can change the  redirect_uri parameter to point to any other pages on a whitelisted domain.</p><p>  在这个阶段，你应该对你可以篡改哪些部位的uri才有相对良好的理解。键现在是使用此知识来尝试访问客户端应用程序本身内的更广泛的攻击面。换句话说，尝试解决是否可以更改redirect_uri参数以指向白名单域上的任何其他页面。</p><p>  Try to find ways that you can successfully access different subdomains or paths. For example, the default URI will often be on an OAuth-specific path, such as  /oauth/callback, which is unlikely to have any interesting subdirectories. However, you may be able to use  directory traversal tricks to supply any arbitrary path on the domain. Something like this:</p><p>  尝试找到您可以成功访问不同子域或路径的方法。例如，默认URI通常会位于特定于OAuth的路径上，例如/ OAuth /回调，这不太可能具有任何有趣的子目录。但是，您可以使用目录遍历技巧来提供域上的任意路径。这样的东西： </p><p>        Once you identify which other pages you are able to set as the redirect URI, you should audit them for additional vulnerabilities that you can potentially use to leak the code or token. For the  authorization code flow, you need to find a vulnerability that gives you access to the query parameters, whereas for the  implicit grant type, you need to extract the URL fragment.</p><p>一旦确定您能够设置为重定向URI的其他页面，您应该审核它们以获取可能使用泄漏代码或令牌的其他漏洞。对于授权代码流，您需要查找一个漏洞，可让您访问查询参数，而对于隐式授予类型，则需要提取URL片段。</p><p>  One of the most useful vulnerabilities for this purpose is an open redirect. You can use this as a proxy to forward victims, along with their code or token, to an attacker-controlled domain where you can host any malicious script you like.</p><p>  为此目的的最有用的漏洞之一是开放式重定向。您可以使用此作为代理转发受害者，以及其代码或令牌，到攻击者控制的域，您可以在其中托管您喜欢的任何恶意脚本。</p><p>  Note that for the implicit grant type, stealing an access token doesn&#39;t just enable you to log in to the victim&#39;s account on the client application. As the entire implicit flow takes place via the browser, you can also use the token to make your own API calls to the OAuth service&#39;s resource server. This may enable you to fetch sensitive user data that you cannot normally access from the client application&#39;s web UI.</p><p>  请注意，对于隐式授权类型，窃取访问令牌并不能让您登录受害者＆＃39;在客户端应用程序上登录。随着通过浏览器进行的整个隐式流动，您还可以使用令牌来使您自己的API调用oauth service＆＃39; s资源服务器。这可以使您能够获取您无法从客户端应用程序和＃39; S Web UI中无法访问的敏感用户数据。</p><p>    In addition to open redirects, you should look for any other vulnerabilities that allow you to extract the code or </p><p>    除了开放式重定向外，您还应该查找允许您提取代码或的任何其他漏洞</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://portswigger.net/web-security/oauth">https://portswigger.net/web-security/oauth</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/身份验证/">#身份验证</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oauth/">#oauth</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>