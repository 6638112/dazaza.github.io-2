<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ARM内存模型工具：Morello(和一些内存标记)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ARM内存模型工具：Morello(和一些内存标记)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 05:50:13</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/c3c9efae39d7ebcf5fe1d3f84f835c39.jpg"><img src="http://img2.diglog.com/img/2020/11/c3c9efae39d7ebcf5fe1d3f84f835c39.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This post presents the implementation of Morello in the Memory Model Tool. The reader is expected to have some understanding of the tool, which is documented in previous posts:  A working example of how to use the herd7 Memory Model Tool and  How to generate litmus tests automatically with the diy7 tool.</p><p>这篇文章介绍了Morello在内存模型工具中的实现。读者应该对该工具有一些了解，该工具已在前面的文章中介绍：如何使用herd7 Memory Model工具以及如何使用diy7工具自动生成石蕊测试的工作示例。</p><p>  Morello is a security architecture developed by Arm, based on Capability Hardware Enhanced RISC Instructions (CHERI). More information can be found in the  Arm Morello program.</p><p>Morello是ARM开发的基于功能硬件增强型RISC指令(CHERI)的安全架构。更多信息可以在ARM Morello计划中找到。</p><p>   Extending the Memory Model Tools to include the Morello instruction set increases the coverage of the tools. This benefits hardware developers and software developers during the prototyping of Morello evaluation boards and the code that runs on them. There are several aspects that are of interest in the implementation of Morello in the Memory Model Tool, namely the addition of:</p><p>扩展内存模型工具以包括Morello指令集增加了工具的覆盖范围。在Morello评估板及其上运行的代码的原型制作过程中，这对硬件开发人员和软件开发人员都有好处。在Memory Model Tool中实现Morello有几个方面令人感兴趣，即添加：</p><p>   Before we dive into Morello, let us have a brief introduction about the Arm Memory Tagging Extension (MTE), since it is useful later in this post. MTE implements lock and key access to memory. More information can be found in the  Armv8-A security features.</p><p>在我们开始讨论Morello之前，让我们先简要介绍一下ARM内存标记扩展(MTE)，因为它在本文后面会很有用。MTE实现对内存的锁定和密钥访问。更多信息可在ARMv8-A安全功能中找到。</p><p> MTE has been part of the Memory Model Tools for some time now (introduced with  https://github.com/herd/herdtools7/commit/6378f2fb0ce9a489d76544dd07bfcb32116d6e76).</p><p>MTE作为内存模型工具的一部分已经有一段时间了(与https://github.com/herd/herdtools7/commit/6378f2fb0ce9a489d76544dd07bfcb32116d6e76).一起引入。</p><p> Both MTE and Morello have objects called “tags”. In both MTE and Morello, the goal of tags is to act as labels attached to the rest of the data . As a consequence, the implementation of the MTE and Morello tags in the tool have some similarities. Therefore we briefly describe the way the MTE variant works here, to support the presentation of the Morello variant.</p><p>MTE和Morello都有称为“标签”的对象。在MTE和Morello中，标签的目标都是作为附加在其余数据上的标签。因此，该工具中MTE和Morello标记的实现有一些相似之处。因此，我们在这里简要描述MTE变体的工作方式，以支持Morello变体的呈现。</p><p> In the Memory Model Tool, the different values the MTE tag can take are represented as colors: “green”, “red”, “blue”, … They can be read with the “LDG” instruction, and written with the “STG” instruction.</p><p>在内存模型工具中，MTE标签可以采用的不同值用颜色表示：“绿色”、“红色”、“蓝色”、“…。它们可以用“LDG”指令读取，用“STG”指令写入。</p><p>  &gt; diyone7 -arch AArch64 -variant memtag PodWWTT Rfe PodRRTT Fre -name MP-MTEAArch64 MP-MTE{0:X0=x:red; 0:X1=x:green; 0:X2=y:red; 0:X3=y:green;1:X1=y:red; 1:X3=x:green;} P0 | P1 ; STG X0,[X1] | MOV X0,X1 ; STG X2,[X3] | LDG X0,[X1] ; | MOV X2,X3 ; | LDG X2,[X3] ;exists (1:X0=y:red /\ 1:X2=x:green)</p><p>&gt；diyone7-ARCH AArch64-Variant Memtag PodWWTT RFE PodRRTT Fre-name MP-MTEAArch64 MP-MTE{0：x0=x：红色；0：x1=x：绿色；0：x2=y：红色；0：x3=y：绿色；1：x1=y：红色；1：x3=x：绿色；}P0|P1；STG X0，[X1]|MOV X0，X1；STG X2，[X3]|LDG X0，[X1]；|MOV X2、X3；|LDG X2，[X3]；存在(1：x0=y：红色/\1：x2=x：绿色)</p><p> Note the use of the new “memtag” variant and the new “T” annotation to generate MTE instructions operating on the MTE tags instead of the data.</p><p>请注意，使用了新的“memtag”变体和新的“T”注释来生成在MTE标记(而不是数据)上操作的MTE指令。</p><p>  &gt; herd7 -variant memtag MP-MTE.litmusTest MP-MTE AllowedStates 41:X0=y:green; 1:X2=x:green;1:X0=y:green; 1:X2=x:red;1:X0=y:red; 1:X2=x:green;1:X0=y:red; 1:X2=x:red;OkWitnessesPositive: 1 Negative: 3Condition exists (1:X0=y:red /\ 1:X2=x:green)Observation MP-MTE Sometimes 1 3Time MP-MTE 0.03Hash=8955f3049e5ad93e9d858b99d7d6ef22</p><p>&gt；herd7-Variant memtag MP-MTE.litmus测试MP-允许的MTE州41：x0=y：绿色；1：x2=x：绿色；1：x0=y：绿色；1：x2=x：红色；1：x0=y：红色；1：x2=x：绿色；1：x0=y：red；1：x2=x：red；好的证人阳性：1阴性：3存在条件(1：x0=y：红色/\1：x2=x：绿色)观测MP-MTE有时为1 3Time MP-MTE 0.03散列=8955f3049e5ad93e9d858b99d7d6ef22。</p><p>  Morello has two instruction sets: A64 and C64. The difference between the two is the interpretation of the operands in some instructions. Take the example of a load instruction:</p><p>Morello有两个指令集：A64和C64。这两者之间的区别在于对某些指令中的操作数的解释。以加载指令为例：</p><p> In A64, “LDR X0,[X1]” checks whether the load is permitted in a System register</p><p>在A64中，“LDR X0，[X1]”检查系统寄存器中是否允许加载。</p><p> In C64, “LDR X0,[C1 ]” checks whether the load is permitted in the “C1” capability register.</p><p>在C64中，“LDR X0，[C1]”检查“C1”能力寄存器中是否允许加载。</p><p>   In Armv8 without extensions, an address and a numeric value are indistinguishable. The choice to see a register as holding an address or a numeric value depends on the programmer’s intent.</p><p>在没有扩展的ARMv8中，地址和数值是无法区分的。选择将寄存器视为保存地址还是数值取决于程序员的意图。</p><p> That is not the case in the Memory Model Tool, where memory locations are distinguished from numeric values: memory locations are represented as strings. This allows for a clear distinction between  what is read or written  in memory and  where that happens. Notations such as “Wx=1” then clearly means that the value 1 is written to memory location “x”, and “Rx=1” that the same memory location was read with value 1. In other words, the tool works on symbolic rather than byte memory locations.</p><p>但在Memory Model工具中情况并非如此，在Memory Model工具中，内存位置与数值不同：内存位置用字符串表示。这使得在内存中读取或写入的内容以及它们发生的位置之间有了明确的区别。那么，诸如“wx=1”这样的符号显然意味着值1被写入内存位置“x”，而“rx=1”意味着相同的内存位置是用值1读取的。换句话说，该工具在符号内存位置上工作，而不是在字节内存位置上工作。</p><p> When dealing with mixed memory access sizes (for example, 32-bit and 64-bit accesses to the same memory location), it is important to be able to refer to only part of a memory location . Depending on the litmus test, the tool identifies a “smallest access size”, and divides and memory locations into sublocations of that size. An offset can be added to the base memory location to access the other sublocations. If a mixed-size litmus test containing W and X sized memory accesses, what would have been a single 64-bit “x” location gets divided in two 32-bit sublocations: “x” and “x+4”.</p><p>在处理混合内存访问大小(例如，对同一内存位置的32位和64位访问)时，能够仅引用内存位置的一部分非常重要。根据Litmus测试，该工具确定“最小访问大小”，并将和内存位置划分为该大小的子块。可以将偏移量添加到基本存储器位置以访问其他子块。如果混合大小的石蕊测试包含W和X大小的内存访问，那么一个64位的“x”位置将被分成两个32位的子块：“x”和“x+4”。</p><p> But it is impossible to reference a symbolic memory location “y” from another symbolic memory location “x” by adding any amount of offset. This is a design choice of the tool, which we refer to in the remainder of this post. This allows us to explain certain choices made in the implementation of the Morello variant, as well as distinctions in the way numeric values and addresses are handled .</p><p>但是不可能通过添加任何数量的偏移量来从另一个符号存储器位置“x”引用符号存储器位置“y”。这是对该工具的设计选择，我们将在本文的其余部分提到这一点。这使我们能够解释在实现Morello变体时所做的某些选择，以及在处理数值和地址的方式上的区别。</p><p>  Morello introduces a new data type, the capability. This data type is held in Capability registers, which are 129-bit wide. Those registers are composed of the following fields:</p><p>Morello引入了一种新的数据类型，即功能。此数据类型保存在容量寄存器中，寄存器为129位宽。这些寄存器由以下字段组成：</p><p> ObjectType, determines whether a valid capability is sealed (ObjectType  ≠  0) or unsealed (ObjectType = 0)</p><p>对象类型，确定有效功能是密封(对象类型≠0)还是解封(对象类型=0)。</p><p>  Tag, determines whether a capability is valid (Tag = 1) or not (Tag = 0)</p><p>标记，确定功能是否有效(标记=1)或无效(标记=0)。</p><p> The Flags  and the lower bits of the Capability Bounds share encoding with the Capability Value.</p><p>标志和能力界限的低位与能力值共享编码。</p><p> Here is a graph showing the organization of the fields in a capability, from the  Arm Architecture Reference Manual Supplement - Morello, version A.f, page 58:</p><p>下面的图表显示了功能中的字段组织，摘自ARM架构参考手册附录-Morello，A.F版，第58页：</p><p> The capability registers are stored in a capability-tagged memory, where a capability tag location exists for every 16 byte locations.</p><p>能力寄存器存储在能力标记存储器中，其中每16字节位置存在一个能力标记位置。</p><p> This has to be reflected in the Memory Model Tool when using it with the Morello variant enabled:</p><p>在启用Morello变量的情况下使用内存模型工具时，这必须反映在内存模型工具中：</p><p>   herd7’s representation of memory needs to account for this additional capability tag location.</p><p>Herd7的内存表示需要考虑到这个额外的功能标签位置。</p><p> This is implemented by adding a memory sublocation containing the capability tag, similarly to what has been done for the MTE tag. A significant difference being that the MTE tag of a particular memory location is accessed independently from the value held in this location. That is not the case for Morello. For Morello, this additional memory sublocation is treated in a way that is closer to the mixed-size variant, in that they are accessed together in memory .</p><p>这是通过添加包含CAPABILITY标签的内存子区块来实现的，类似于对MTE标签所做的操作。一个显著的区别在于，访问特定存储器位置的MTE标签独立于保存在该位置中的值。但莫雷洛的情况并非如此。对于Morello来说，这种额外的内存子区块的处理方式更接近于混合大小变量，因为它们在内存中被一起访问。</p><p> For performance reasons, as well as simplicity of implementation, at the time of writing using the Morello variant in the tool triggers the use of the mixed variant. For the user, it means that reading graphs of the execution can potentially show a “smallest access size” (as described in 3.1  Memory locations ) smaller than what the litmus test would suggest.</p><p>出于性能原因以及实现的简单性，在编写本文时，在工具中使用Morello变量会触发混合变量的使用。对于用户来说，这意味着读取执行图表可能会显示出比Litmus测试所建议的更小的“最小访问大小”(如3.1个内存位置中所述)。</p><p>  The Morello architecture ensures that certain checks guard every memory access. Those checks check whether the access is permitted or not. If a check fails, a synchronous Data Abort is generated, with a specific fault depending on what caused it. The implemented faults are the  capability tag fault, the  capability sealed fault and the  capability permission fault. The  capability bounds fault is not implemented because bounds cannot be represented in the Memory Model Tool at the moment.</p><p>Morello架构确保某些检查保护每次内存访问。这些检查检查是否允许访问。如果检查失败，则会生成同步数据中止，具体故障取决于原因。实现的错误有能力标签错误、能力密封错误和能力许可错误。由于目前无法在内存模型工具中表示边界，因此未实现功能边界错误。</p><p> In order not to fault, memory accesses need to use a valid and unsealed capability that has the necessary permissions to perform the relevant type of access (load or store).</p><p>为了不出错，存储器访问需要使用有效且未密封的功能，该功能具有执行相关类型的访问(加载或存储)所需的权限。</p><p> The other types of faults introduced by Morello are not implemented in the tool. Those faults are:</p><p>Morello引入的其他类型的故障不会在工具中实现。这些故障是：</p><p>   The Morello instruction set expands the “classic” memory instructions (STR, LDR, SWP, CAS, …) to use capability registers, creating 128-bit aligned accesses. Note that capability registers are 129-bit wide, but that virtual addresses are 128-bit aligned.</p><p>Morello指令集扩展了“经典”内存指令(str、ldr、swp、cas、…)。使用功能寄存器，创建128位对齐访问。请注意，功能寄存器是129位宽，但虚拟地址是128位对齐的。</p><p> It also adds two new instructions that operate specifically on capability tags: STCT (store capability tags) and LDCT (load capability tags). They have a unique interaction with memory and are therefore  of special interest for the tool. It is also for that reason that they get their own annotation in the diy tool (more later). The instructions STCT and LDCT theoretically operate on 4 consecutive capability locations in memory. However the tool cannot reference a memory location “y” from a memory location “x” (see 3.1  Memory locations ). Therefore those instructions only operate on the specified location . This limitation would translate to a real system where variables are 512-bit aligned.</p><p>它还添加了两条专门操作功能标签的新指令：STCT(存储功能标签)和LDCT(加载功能标签)。它们与内存有独特的交互作用，因此对该工具特别感兴趣。也正是由于这个原因，他们在DIY工具中获得了自己的注释(稍后将详细介绍)。理论上，指令STCT和LDCT在存储器中的4个连续能力位置上操作。但是，该工具不能引用内存位置“x”中的内存位置“y”(参见3.1中的内存位置)。因此，这些指令只在指定位置运行。这一限制将转化为变量是512位对齐的实际系统。</p><p>  Behind the scene, the diy tool uses different “banks” to manage the values written and read in the cycles it creates. Banks are unique to each memory location. There is only one bank used when no variant is specified: “Ord”.</p><p>在幕后，DIY工具使用不同的“库”来管理它创建的周期中写入和读取的值。存储体对于每个存储位置都是唯一的。当没有指定变量时，只使用一个银行：“ORD”。</p><p> The tool increments the bank of a memory location by  1 when a write occurs, and the final state of the cycle is generated from the expected values. In the example above, the read of “y” happens after the write of y with value 1, so the expected value of the read of y is 1. The read of “x” happens before the write of x with value, so the expected value of the read of x is 0.</p><p>当发生写入时，该工具将内存位置的存储体加1，并根据期望值生成周期的最终状态。在上面的例子中，读取“y”发生在值为1的y写入之后，因此读取y的期望值为1。读取“x”发生在写入x之前，因此读取x的期望值为0。</p><p> The memtag variant of the tool added a second bank: “Tag”, storing the value of the MTE tag independently from the Ord bank. Reading and writing from and to the Tag bank is done by using the “T” annotation with the diy tool.</p><p>该工具的memtag变体添加了第二个库：“tag”，独立于Ord库存储MTE标记值。读取和写入标签库是通过使用DIY工具的“T”注释来完成的。</p><p> In the same spirit, the Morello variant introduces new banks to handle the different fields of capabilities, “CapaTag” for the capability tag and “CapaSeal” for the object type.</p><p>本着同样的精神，Morello变体引入了新的银行来处理不同的功能字段，“CapaTag”用于功能标记，“CapaSeal”用于对象类型。</p><p> Here you can see that writing to different banks of a same memory location (here with “Wy.seal” followed by “Wy”) keeps all the written values in memory, and that reading from one of the banks (noted as “Ry.Seal”) only retrieves the value of the specified bank:</p><p>在这里，您可以看到，写入同一内存位置的不同存储体(这里后跟“Wy.seal”)会将所有写入的值保存在内存中，而从其中一个存储体(标记为“Ry.Seal”)读取只会检索指定存储体的值：</p><p> Unlike the MTE Tag bank, the capability banks act, along with Ord, as a tuple of values. The reason being that writing a capability tag or an object type to a register needs to be associated with the rest of the banks in order not to lose information. That can result in many more instructions in litmus tests.</p><p>与MTE标签库不同的是，能力库与ORD一起作为一个值的元组。原因在于，为了不丢失信息，将能力标签或对象类型写入寄存器需要与其余存储体相关联。这可能会在石蕊测试中产生更多的说明。</p><p>  &gt; diyone7 -arch AArch64 -variant morello PodWW Cs PosWW Rfe Cs PodRR FreAArch64 A{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X2=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; MOV X0,#1 | LDR C0,[C1] ; STR X0,[C1] | GCTYPE X0,C0 ; MOV X3,#0 | LDR X2,[C3] ; MOV X4,#1 | ; SCVALUE C3,C2,X3 | ; SEAL C3,C3,C4 | ; STR C3,[C2] | ; MOV X5,#1 | ; STR X5,[C2] | ;exists (1:X0=1 /\ 1:X2=0)</p><p>&gt；diyone7拱AArch64变种Morello PodWW Cs PosWW RFE Cs PodRR FreAArch64 A{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x2=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；MOV X0，#1|LDR C0，[C1]；字符串X0，[C1]|GCTYPE X0，C0；MOV X3，#0|LDR X2，[C3]；MOV X4，#1|；SCVALUE C3、C2、X3|；密封C3、C3、C4|；字符串C3，[C2]|；MOV X5，#1|；字符串X5，[C2]|；存在(1：x0=1/\1：x2=0)。</p><p>      When using “-variant morello”, capability registers holding values that are not memory locations are represented as:</p><p>使用“-Variant Morello”时，保存非存储位置的值的功能寄存器表示为：</p><p>  Where C is an integer representing bits &lt;127:0&gt; of the capability and T is the tag (bit &lt;128&gt;). When “T” is 0, only “C” is displayed.</p><p>其中C是表示能力的比特127：0的整数，T是标签(比特128)。当“T”为0时，只显示“C”。</p><p> The tag is separated from the rest of the fields to simplify the reading when using cycles focused on tags. For example, a tagged capability with value 2 is represented as “0x2:1” instead of a more classical “0x100000000000000000000000000000002”.</p><p>标签与其他字段分开，以便在使用专注于标签的循环时简化阅读。例如，值为2的标记功能表示为“0x2：1”，而不是更经典的“0x1000000000000000000000000000002”。</p><p>  Note that it might be useful to use “-hexa true” to get a more intelligible reading of the permission and object type fields of capability registers. For example, a tagged capability with all permissions and value 3 is represented as:</p><p>请注意，使用“-HEXA TRUE”可以更容易理解地读取功能寄存器的权限和对象类型字段，这可能很有用。例如，所有权限和值为3的标记功能表示为：</p><p> “340281068846723829756467474807685906435:1” with “-hexa false” (or no hexa flag, since false is the default value)</p><p>“340281068846723829756467474807685906435：1”，带“-HEXA FALSE”(或无六进制标志，因为FALSE是缺省值)。</p><p>  Memory locations represents a symbol in the tool: “x”, “y”, … (see 3.1  Memory locations ). Bits &lt;91:0&gt; of capabilities holding a memory location are amalgamated as the letter representing this location. This is why the tool uses the following representation:</p><p>内存位置表示工具中的符号：“x”、“y”、…。(参见3.1：内存位置)。存储位置的容量的位&lt；91：0和gt；合并为代表该位置的字母。这就是该工具使用以下表示形式的原因：</p><p>   “C” is an integer representing bits &lt;127:92&gt; of the capability. Those bits are:</p><p>“C”是一个整数，表示容量的位127：92。这些位是：</p><p> When both “C” and “T” are 0, only “m” is displayed.</p><p>当“C”和“T”都为0时，只显示“m”。</p><p> In the previous example, “0xffffc0000:x:1” denotes a tagged and unsealed capability with full permissions, containing the memory location “x”.</p><p>在上例中，“0xffffc0000：x：1”表示具有完全权限的标记和解封能力，包含内存位置“x”。</p><p> Note that in this case “C” is always represented as a hexadecimal value, ignoring the “-hexa” flag.</p><p>请注意，在本例中，“C”始终表示为十六进制值，忽略“-HEXA”标志。</p><p>  The initialization section of the litmus tests contains the initial state of the registers for each processing element. The input format matches the output format previously described.</p><p>石蕊测试的初始化部分包含每个处理元件的寄存器的初始状态。输入格式与前面描述的输出格式匹配。</p><p> For example, using the diy tool to get a message-passing cycle with “-variant morello” gives the following litmus:</p><p>例如，使用DIY工具获得带有“-Variant Morello”的消息传递循环会带来以下试金石：</p><p> &gt; diyone7 -arch AArch64 -variant morello PodWW Rfe PodRR FreAArch64 MP{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; MOV X0,#1 | LDR X0,[C1] ; STR X0,[C1] | LDR X2,[C3] ; MOV X2,#1 | ; STR X2,[C3] | ;exists (1:X0=1 /\ 1:X2=0)</p><p>&gt；diyone7拱AArch64变种Morello PodWW RFE PodRR FreAArch64 MP{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；MOV X0，#1|LDR X0，[C1]；字符串X0，[C1]|LDR X2，[C3]；MOV X2，#1|；字符串X2，[C3]|；存在(1：x0=1/\1：x2=0)。</p><p> Compared to the previous MP-MTE litmus test, this cycle does not contain additional annotations. The memory accesses are unchanged compared to the no-variant version of the message passing litmus test. Using “-variant morello” merely initializes the addresses so that they do not fault when executed in a Morello environment.</p><p>与之前的MP-MTE石蕊测试相比，此周期不包含额外的注释。与消息通过石蕊测试的无变化版本相比，存储器访问没有变化。使用“-Variant Morello”只是对地址进行了初始化，以便它们在Morello环境中执行时不会出错。</p><p>  It may be interesting to observe the behavior of mixed Morello and non-Morello instructions in the same program. Classic “P”, “L”, “A” and “Q” annotations are receiving optional modifiers to reflect this. They can be suffixed with a lower-cased “c” to generate a Morello variation of the specified access.</p><p>观察同一程序中混合Morello和非Morello指令的行为可能很有趣。经典的“P”、“L”、“A”和“Q”批注正在接收可选的修饰符来反映这一点。它们可以以小写的“c”作为后缀，以生成指定访问的Morello变体。</p><p>      &gt; diyone7 -arch AArch64 -variant morello PodRW L Rfe A PodRW L Rfe AAArch64 A{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; LDAR X0,[C1] | LDAR X0,[C1] ; MOV X2,#1 | MOV X2,#1 ; STLR X2,[C3] | STLR X2,[C3] ;exists (0:X0=1 /\ 1:X0=1) &gt; diyone7 -arch AArch64 -variant morello PodRW L Rfe Ac PodRW Lc Rfe AAArch64 A{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; LDAR X0,[C1] | LDAR C0,[C1] ; MOV X2,#1 | GCVALUE X0,C0 ; STLR X2,[C3] | MOV X2,#1 ; | STLR C2,[C3] ;exists (0:X0=1 /\ 1:X0=1)</p><p>&gt；diyone7拱AArch64变种Morello PodRW L RFE A PodRW L RFE AAArch64 A{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；激光雷达X0，[C1]|激光雷达X0，[C1]；MOV X2，#1|MOV X2，#1；STLR X2，[C3]|STLR X2，[C3]；存在(0：x0=1/\1：x0=1)&gt；Diyone7拱AArch64变种Morello PodRW L RFE ac PodRW LC RFE AAArch64 A{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；激光雷达X0，[C1]|激光雷达C0，[C1]；MOV X2，#1|GCVALUE X0，C0；STLR X2，[C3]|MOV X2，#1；|STLR C2，[C3]；存在(0：x0=1/\1：x0=1)。</p><p> Notice the use of capability registers in P1 in the second example, and that “GCVALUE” is added to the load to extract the Capability Value field from the capability.</p><p>请注意，在第二个示例中使用了P1中的功能寄存器，并将“GCVALUE”添加到加载中以从功能中提取功能值字段。</p><p> There are also new annotations that act on specific fields of a capability: “Ct” and “Cs”. Those annotations are the user-side of the banks concept developed in paragraph 3.5:  Introducing new Banks . They correspond respectively to the “CapaTag” and “CapaSeal” banks. “Ct” to feature memory accesses modifying the Tag. “Cs” to feature memory accesses modifying the ObjectType. Note that because a capability tag is either 0 or 1, a “Ct” write can only be performed once per memory location.</p><p>还有一些新的注释作用于功能的特定字段：“ct”和“cs”。这些注释是第3.5段中提出的银行概念的用户端：介绍新银行。它们分别对应于“CapaTag”和“CapaSeal”银行。“CT”以修改标签的存储器访问为特征。“Cs”表示修改ObjectType的内存访问。请注意，因为功能标签要么是0，要么是1，所以每个内存位置只能执行一次“CT”写入。</p><p> &gt; diyone7 -arch AArch64 -variant morello PodWWCtCt Rfe PodRRCtCt FreAArch64 A{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; MOV X0,#1 | LDCT X0,[C1] ; STCT X0,[C1] | LDCT X2,[C3] ; MOV X2,#1 | ; STCT X2,[C3] | ;exists (1:X0=1 /\ 1:X2=0)</p><p>&gt；diyone7拱AArch64-Variant Morello PodWWCtCt RFE PodRRCtCt FreAArch64 A{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；MOV X0，#1|LDCT X0，[C1]；STCT X0，[C1]|LDCT X2，[C3]；MOV X2，#1|；STCT X2，[C3]|；存在(1：x0=1/\1：x2=0)。</p><p>  When no variant is selected, the diy tool creates cycles where the memory locations (or addresses) and the values are two completely separate entities. The registers containing memory locations are initialized once with the string representing that location (“x”, “y”, ...); their content does not change during the execution of the litmus test. On the other hand, values are numbers that are incremented for each write to the same memory location.</p><p>当没有选择变量时，DIY工具会创建内存位置(或地址)和值是两个完全独立的实体的循环。包含内存位置的寄存器用表示该位置的字符串(“x”，“y”，...)初始化一次；它们的内容在Litmus测试执行期间不会改变。另一方面，值是每次写入相同内存位置时递增的数字。</p><p> Morello offers a memory protection in the form of checks on every memory access. If those checks fail, this results in a capability fault (see 3.3  Capability memory protection ). We handle this behavior in the tool .</p><p>Morello以检查每次内存访问的形式提供内存保护。如果这些检查失败，则会导致功能故障(参见3.3功能内存保护)。我们在工具中处理此行为。</p><p> But creating diy cycles that display a possibility of fault depending on the execution order requires to move away from the separation of values and memory locations.</p><p>但是，创建根据执行顺序显示故障可能性的DIY周期需要摆脱值和内存位置的分离。</p><p> When no variant is selected, the diy tool creates a dependency using an “exclusive or” operation. That way the address is unchanged, but the register value does depend on the previous load.</p><p>当没有选择变量时，DIY工具使用“异或”操作创建依赖项。这样，地址不会改变，但寄存器值确实取决于前一次加载。</p><p>   The Morello variant builds on the address dependency to introduce scenarios where a fault can happen. When used with one of the new “Ct” or “Cs” annotations, the dependency of DpAddr still exists but under a different form. In this context, the content of the capability used for the second memory access still depends on the value read during the first access . However, the difference between the value read and the expected value in the cycle is used to fill the specified capability field of the address: the tag when specifying “DpAddr(s|d)(R|W)Ct”, the object type when specifying “DpAddr(s|d)(R|W)Cs”.   This can be observed in the tool with:</p><p>Morello变体构建在地址依赖之上，以引入可能发生故障的场景。当与新的“Ct”或“Cs”批注一起使用时，DpAddr的依赖项仍然存在，但形式不同。在这种情况下，用于第二次存储器访问的能力的内容仍然取决于在第一次访问期间读取的值。然而，周期中读取的值与期望值之间的差值用于填充地址的指定能力字段：指定“DpAddr(s|d)(R|W)Ct”时的标记，指定“DpAddr(s|d)(R|W)Cs”时的对象类型。在工具中可以通过以下方式观察到这一点：</p><p>   AArch64 A&#34;DpAddrdWPCs RfeCsP PodRW Rfe&#34;Generator=diyone7 (version 7.56+02~dev)Prefetch=0:x=F,0:y=W,1:y=F,1:x=WCom=Rf RfOrig=DpAddrdWPCs RfeCsP PodRW Rfe{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; LDR X0,[X1] | LDR X0,[X1] ; SUBS X4,X0,#1 | MOV X2,#1 ; AND X4,X4,#4095 | STR X2,[X3] ; SCVALUE C4,C3,X4 | ; CSEAL C4,C3,C4 | ; MOV X5,#0 | ; MOV X6,#1 | ; SCVALUE C5,C3,X5 | ; SEAL C5,C5,C6 | ; STR C5,[X4] | ;exists (0:X0=1 /\ 1:X0=0) /\ ~fault(P0,y)</p><p>AArch64 A&#34；DpAddrdWPC RfeCsP PodRW RFE&#34；生成器=diyone7(版本7.56+02~dev)预取=0：X=F、0：Y=W、1：Y=F、1：X=WCOM=射频射频ORIG=DpAddrdWPCS RfeCsP PodRW RFE{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；LDR X0，[X1]|LDR X0，[X1]；Subs X4，X0，#1|MOV X2，#1；和X4、X4、#4095|STR X2、[X3]；SCVALUE C4、C3、X4|；CSEAL C4、C3、C4|；MOV X5，#0|；MOV X6，#1|；SCVALUE C5、C3、X5|；密封C5、C5、C6|；字符串C5，[X4]|；存在(0：x0=1/\1：x0=0)/\~故障(P0，y)</p><p> Because there are many more fields to consider as compared to, for example, a plain write, the creation of the capability requires several instructions.</p><p>例如，由于与普通写入相比，需要考虑的字段要多得多，因此创建该功能需要几条指令。</p><p>    AArch64 A{uint128_t y; uint128_t x; 0:X1=0xffffc0000:x:1; 0:X3=0xffffc0000:y:1;1:X1=0xffffc0000:y:1; 1:X3=0xffffc0000:x:1;} P0 | P1 ; LDR X0,[C1] | LDR C0,[C1] ; SUBS X4,X0,#1 | GCTYPE X0,C0 ; AND X4,X4,#4095 | MOV X2,#1 ; SCVALUE C4,C3,X4 | STR X2,[C3] ; CSEAL C4,C3,C4 | ; MOV X5,#0 | ; MOV X6,#1 | ; SCVALUE C5,C3,X5 | ; SEAL C5,C5,C6 | ; STR C5,[C4] | ;exists (0:X0=1 /\ 1:X0=1) /\ ~fault(P0,y)</p><p>AArch64 A{Uint128_t y；uint128_t x；0：x1=0xffffc0000：x：1；0：x3=0xffffc0000：y：1；1：x1=0xffffc0000：Y：1；1：x3=0xffffc0000：x：1；}P0|P1；LDR X0，[C1]|LDR C0，[C1]；Subs X4，X0，#1|GCTYPE X0，C0；和X4、X4、#4095|MOV X2、#1；SCVALUE C4，C3，X4|STR X2，[C3]；CSEAL C4、C3、C4|；MOV X5，#0|；MOV X6，#1|；SCVALUE C5、C3、X5|；密封C5、C5、C6|；字符串C5，[C4]|；存在(0：x0=1/\1：x0=1)/\~故障(P0，y)</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/memory-model-tool-morello-and-some-memory-tagging">https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/memory-model-tool-morello-and-some-memory-tagging</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/morello/">#morello</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034386.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f13ced149f78b76cda9d92768fa2feb1.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034386.html">IBM推出7纳米POWER10 CPU</a></div><span class="my_story_list_date">2020-11-11 4:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034358.html"><img src="http://img2.diglog.com/img/2020/11/thumb_95d8f744f0afb6d711b9929ffe863c9a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034358.html">苹果首次推出搭载M1的13.3英寸MacBook Pro，电池续航时间长达20小时，CPU速度提高2.8倍，ML速度提高11倍，GPU速度提高5倍，内存容量从1,299美元起，最高可达16 GB</a></div><span class="my_story_list_date">2020-11-11 3:0</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033606.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b245f67c3b3cbeea18876c89a1c8070.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033606.html">使用jemalloc在围棋中进行手动内存管理</a></div><span class="my_story_list_date">2020-11-7 11:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032431.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f84a708f828fff14f092a76e6ba324d4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032431.html">现代Kafka-API存储系统的每核线程缓存管理</a></div><span class="my_story_list_date">2020-10-31 9:55</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>