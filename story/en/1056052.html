<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cloudflare耐用的物体 Cloudflare Durable Objects</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cloudflare Durable Objects<br/>Cloudflare耐用的物体 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 11:31:57</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/61a7986ae0bfd101131a1ad64bbba1c7.png"><img src="http://img2.diglog.com/img/2021/4/61a7986ae0bfd101131a1ad64bbba1c7.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Durable Objects provide low-latency coordination and consistent storage for the Workers platform through two features: global uniqueness and a transactional storage API.</p><p>持久对象通过两个功能为工人平台提供低延迟协调和一致存储：全局唯一性和事务存储API。</p><p> Global Uniqueness guarantees that there will be a single Durable Object with a given id running at once, across the whole world. Requests for a Durable Object id are routed by the Workers runtime to the Cloudflare point-of-presence that owns the Durable Object.</p><p> 全球唯一性保证，在整个世界各地都会有一个持久的对象，同时运行给定的ID。持久对象ID的请求由Workers运行时路由到拥有持久对象的CloudFlare的窗口点。</p><p> The transactional storage API provides strongly-consistent key-value storage to the Durable Object. Each Object can only read and modify keys associated with that Object. Execution of a Durable Object is single-threaded, but multiple request events may be processed out-of-order from how they arrived at the Object.</p><p> 事务存储API为持久对象提供了强烈一致的键值存储。每个对象只能读取和修改与该对象关联的键。执行持久对象是单线程的，但可以从它们到达对象的方式处理多个请求事件。</p><p> For a high-level introduction to Durable Objects,   see the announcement blog post     Open external link.</p><p> 对于耐用对象的高级介绍，请参阅公告博客文章打开外部链接。</p><p> Durable Objects are currently in beta and are available to anyone with a Workers subscription. You can enable them for your account in   the Cloudflare dashboard     Open external link by navigating to “Workers” and then “Durable Objects”.</p><p> 耐用的物体目前在Beta中，可供其他人订阅任何人。您可以通过导航到“Workers”，然后“持久对象”启用它们在CloudFlare仪表板上的帐户中为您的帐户启用。</p><p>  Durable Objects are named instances of a class you define. Just like a class in object-oriented programming, the class defines the methods and data a Durable Object can access.</p><p>  持久对象被命名为您定义的类的实例。就像面向对象编程的类一样，该类定义了持久对象可以访问的方法和数据。</p><p>    Before you can create and access Durable Objects, you must define their behavior by exporting an ordinary JavaScript class. Other languages will need a shim that translates their class definition to a JavaScript class.</p><p>    在创建和访问持久对象之前，必须通过导出普通的JavaScript类来定义其行为。其他语言需要一个垫片，将其类定义转换为JavaScript类。 </p><p> The first parameter passed to the class constructor contains state specific to the Durable Object, including methods for accessing storage. The second parameter contains any bindings you have associated with the Worker when you uploaded it.</p><p>传递给类构造函数的第一个参数包含特定于持久对象的状态，包括访问存储的方法。第二个参数包含您上传时与工人关联的任何绑定。</p><p>  Workers communicate with a Durable Object via the fetch API. Like a Worker, a Durable Object listens for incoming Fetch events by registering an event handler. The only difference is that for Durable Objects the fetch handler is defined as a method on the class.</p><p>  工人通过fetch API与持久对象进行通信。像工作者一样，通过注册事件处理程序来侦听传入的获取事件的耐用对象。唯一的区别是，对于持久对象，Fetch处理程序被定义为类上的方法。</p><p> export   class      {       constructor ( state ,  env )   {       }           async   fetch ( request )   {       return   new   Response ( &#39;Hello World&#39; ) ;       }          }</p><p> 导出类{构造函数（状态，env）{}异步获取（请求）{返回新响应（＆＃39;您好世界＆＃39;）; }}</p><p> A Worker can pass information to a Durable Object via headers, the HTTP method, the Request body, or the Request URI.</p><p> 工作人员可以通过标题，HTTP方法，请求正文或请求URI将信息传递给持久对象。</p><p> HTTP requests received by a Durable Object do not come directly from the Internet. They come from other Worker code -- possibly other Durable Objects, or just plain Workers. We&#39;ll see how to send such a request in a bit. Durable Objects use HTTP for familiarity, but we plan to introduce other protocols in the future.</p><p> 持久对象收到的HTTP请求不会直接来自Internet。他们来自其他工人代码 - 可能是其他持久的物体，或只是简单的工人。我们＆＃39; ll看到如何在一下发送这样的请求。持久对象使用HTTP熟悉，但我们计划将来引入其他协议。</p><p>  Durable Objects gain access to a   persistent storage API via the first parameter passed to the Durable Object constructor. While access to a Durable Object is single-threaded, it&#39;s important to remember that request executions can still interleave with each other when they wait on I/O, such as when waiting on the promises returned by persistent storage methods or  fetch requests.</p><p>  持久对象通过传递给耐用对象构造函数的第一个参数来访问持久存储API。虽然访问持久对象是单线程的，但重要的是要记住，请记住，当请求执行时仍然可以在I / O等待时彼此交互，例如在等待持久存储方法返回的承诺或获取时要求。</p><p> export   class      {       constructor ( state ,  env )   {       this . state   =  state ;       }           async   fetch ( request )   {       let  ip  =  request . headers . get ( &#39;CF-Connecting-IP&#39; ) ;       let  data  =   await  request . text ( ) ;       let  storagePromise  =   this . state . storage . put ( ip ,  data ) ;       await  storagePromise ;       return   new   Response ( ip  +   &#39; stored &#39;   +  data ) ;       }          }</p><p> 导出类{构造函数（州，env）{此。国家=州; }异步获取（请求）{允许IP =请求。标题。得到（＆＃39; cf-connecting-ip＆＃39;）;让数据=等待请求。文本 （ ） ;让StoragePromise =这个。状态 。贮存 。放（IP，数据）;等待存储妥协;返回新响应（IP +＆＃39;存储＆＃39; +数据）; }} </p><p> Each individual storage operation behaves like a database transaction. More complex use cases can wrap multiple storage statements in a transaction. For example, this Durable Object puts a key if and only if its current value matches the provided &#34;If-Match&#34; header value:</p><p>每个单独的存储操作都表现类似于数据库事务。更复杂的用例可以在事务中包装多个存储语句。例如，如果其当前值与提供的＆＃34匹配，则此持久对象仅符合其当前值; if-match＆＃34;标题值：</p><p> export   class      {       constructor ( state ,  env )   {       this . state   =  state ;       }           async   fetch ( request )   {       let  key  =   new   URL ( request . url ) . host       let  ifMatch  =  request . headers . get ( &#39;If-Match&#39; ) ;       let  newValue  =   await  request . text ( ) ;       let  changedValue  =   false ;       await   this . state . storage . transaction ( async   txn   =&gt;   {       let  currentValue  =   await  txn . get ( key ) ;       if   ( currentValue  !=  ifMatch  &amp;&amp;  ifMatch  !=   &#39;*&#39; )   {      txn . rollback ( ) ;       return ;       }      changedValue  =   true ;       await  txn . put ( key ,  newValue ) ;       } ) ;       return   new   Response ( &#34;Changed: &#34;   +  changedValue ) ;       }          }</p><p> 导出类{构造函数（州，env）{此。国家=州; }异步获取（请求）{让键=新URL（请求。URL）。主机让IfMatch =请求。标题。得到（＆＃39; if-match＆＃39;）;让NewValue =等待请求。文本 （ ） ;让epartValue = false;等待这个。状态 。贮存 。事务（异步txn =＆gt; {让currentvalue = await txn。get（key）;如果（currentvalue！= ifmatch＆amp; ifmatch！=＆＃39; *＆＃39;）{txn。回滚（）;返回;} epartValue = true;等待TXN。放（钥匙，newValue）;}）;返回新响应（＆＃34;已更改：＆＃34; + exputhvalue）; }}</p><p> Transactions operate at a   serializable isolation level     Open external link. This means transactions can fail if they conflict with a concurrent transaction being run by the same Durable Object.</p><p> 事务在可序列化隔离级别打开外部链接运行。如果它们与同一持久对象运行的并发事务冲突，则此表示事务可能会失败。</p><p> Transactions are transparently and automatically retried once by rerunning the provided function before returning an error. To avoid transaction conflicts, don&#39;t use transactions when you don&#39;t need them, don&#39;t hold transactions open any longer than necessary, and limit the number of key-value pairs operated on by each transaction.</p><p> 在返回错误之前，通过重新运行提供的功能，事务是透明的，并自动重试一次。为了避免交易冲突，Don＆＃39; t＆＃39; t＆＃39; t＆＃39; t需要它们，不要按住任何超过必要的交易，并限制每个事务所操作的键值对的数量。</p><p> Since each Durable Object is single-threaded, technically it is not necessary to use transactions to achieve transactional semantics. With careful use of promises, you could serialize operations in your live object so that there&#39;s no possibility of concurrent storage operations. We provide the transactional interface as a convenience for those who don&#39;t want to do their own synchronization.</p><p> 由于每个持久对象都是单线程，因此技术上没有必要使用事务来实现事务语义。通过仔细使用承诺，您可以在您的Live对象中序列化操作，以便其中没有可能并发存储操作。我们为那些不想做自己的同步的人提供交易界面。</p><p>  Variables in a Durable Object will maintain state as long as your Durable Object is not evicted from memory. A common pattern is to initialize an object from persistent storage and set class variables the first time it is accessed. Since future accesses are routed to the same object, it is then possible to return any initialized values without making further calls to persistent storage.</p><p>  持久对象中的变量将保持状态，只要不从内存中逐出耐用对象即可保持状态。常用模式是首次访问它第一次从持久存储和设置类变量初始化对象。由于未来访问被路由到相同的对象，因此可以返回任何初始化值而不会进一步调用持久存储。</p><p>  export   class      {       constructor ( state ,  env )   {       this . state   =  state ;       }           async   initialize ( )   {       let  stored  =   await   this . state . storage . get ( &#34;value&#34; ) ;       // after initialization, future reads don&#39;t need to access storage!       this . value   =  stored  ||   0 ;       }           // Handle HTTP requests from clients.       async   fetch ( request )   {       // Make sure we&#39;re fully initialized from storage.       if   ( ! this . initializePromise )   {       this . initializePromise   =   this . initialize ( ) ;       }       await   this . initializePromise ;       // this.value will retain its state until this object is evicted from memory       ...       }      }</p><p>  导出类{构造函数（州，env）{此。国家=州; } Async initialize（）{让存储=等待它。状态 。贮存 。得到（＆＃34;价值＆＃34;）; //初始化后，未来读取Don＆＃39; t需要访问存储！这个 。 value =存储|| 0; } //从客户端处理HTTP请求。异步获取（请求）{//确保我们＆＃39;重新初始化存储。如果（！这个。initializePromise）{这个。 initializepromise =它。 initialize（）;等待这个。 initializepromise; //它.Value将保留其状态，直到从内存中逐出此对象...}} </p><p>  As part of Durable Objects, we&#39;ve made it possible for Workers to act as WebSocket endpoints -- including as a client or as a server. Previously, Workers could proxy WebSocket connections on to a back-end server, but could not speak the protocol directly.</p><p>作为持久对象的一部分，我们＆＃39; VE使工人成为WebSocket端点 - 包括作为客户端或作为服务器。以前，工人可以将WebSocket连接到后端服务器上，但不能直接讲协议。</p><p> While technically any Worker can speak WebSocket in this way, WebSockets are most useful when combined with Durable Objects. When a client connects to your application using a WebSocket, you need a way for server-generated events to be sent back to the existing socket connection. Without Durable Objects, there&#39;s no way to send an event to the specific Worker holding a WebSocket. With Durable Objects, you can forward the WebSocket to an Object. Messages can then be addressed to that Object by its unique ID, and the Object can then forward those messages down the WebSocket to the client.</p><p> 虽然从技术上讲，任何工人都可以通过这种方式讲WebSocket，但在与持久对象组合时，WebSocket最有用。当客户端使用WebSocket连接到应用程序时，您需要一种向现有套接字连接发送的服务器生成的事件。没有耐用的物体，没有＆＃39;＆＃39是没有向拿着Websocket的特定工作者发送事件。使用持久对象，您可以将WebSocket转发到对象。然后可以通过其唯一ID向该对象进行寻址消息，然后该对象可以将WebSocket向客户端转发这些消息。</p><p> Full documentation for WebSockets will be coming soon, but for now check out this   heavily commented example chat application     Open external link that runs in Durable Objects to see how it works.</p><p> WebSockets的完整文档将即将推出，但现在看看此重新评论的示例聊天应用程序打开在持久对象中运行的外部链接，以查看其工作原理。</p><p>  As mentioned above, Durable Objects do not receive requests directly from the Internet, but from Workers or other Durable Objects. This is achieved by configuring a binding in the calling Worker for each Durable Object class that you&#39;d like it to be able to talk to. These bindings work similarly to KV bindings and must be configured at upload time. Methods exposed by the binding can be used to communicate with particular Durable Object instances.</p><p>  如上所述，持久对象不会直接从互联网接收请求，而是从工人或其他持久对象接收请求。这是通过在呼叫工作人员中配置绑定的每个持久对象类，为您＆＃39; d喜欢它能够交谈来实现的。这些绑定与KV绑定类似，并且必须在上传时间内配置。绑定暴露的方法可用于与特定的耐用对象实例进行通信。</p><p> When a Worker talks to a Durable Object, it does so through a &#34;stub&#34; object. The class binding&#39;s  get() method returns a stub to the particular Durable Object instance, and the stub&#39;s  fetch() method sends HTTP   Requests to the instance.</p><p> 当工人与持久对象交谈时，它通过A＆＃34;存根和＃34;目的。类绑定＆＃39; s get（）方法返回特定持久对象实例的存根，存根和＃39; s fetch（）方法向实例发送HTTP请求。</p><p> Note that in the example below, we have written the fetch handler using a new kind of Workers syntax based on ES modules. This syntax is required for Durable Objects. The fetch handler in this example implements the Worker that talks to the Durable Object. We recommend following this approach of implementing Durable Objects and a corresponding fetch handler in the same script not only because it is convenient, but also because as of today it is not possible to upload a script to the runtime that does not implement a fetch handler.</p><p> 请注意，在下面的示例中，我们使用基于es模块的新工程语法编写了fetch处理程序。持久对象需要此语法。此示例中的fetch处理程序实现了与持久对象交谈的工作者。我们建议在同一脚本中实现持久对象和相应的Fetch处理程序的方法不仅是因为它方便，而且因为截至今天，无法将脚本上传到不实现Fetch处理程序的运行时。</p><p> ES Modules differ from regular JavaScript files in that they have imports and exports. As you saw above, we wrote  export class DurableObjectExample when defining our class. To implement a fetch handler, you must export a method named  fetch in an  export default {} block.</p><p> es模块与常规JavaScript文件不同，因为它们具有导入和导出。如上所述，我们在定义我们的课程时写了出口类DurableObjectExample。要实现Fetch处理程序，必须在导出默认{}块中导出名为fetch的方法。 </p><p> // In modules-syntax workers, we use `export default` to export our script&#39;s      // main event handlers, such as the `fetch` handler for receiving HTTP      // requests. In pre-modules workers, the fetch handler was registered using      // `addEventHandler(&#34;fetch&#34;, event =&gt; { ... })`; this is just new syntax for      // essentially the same thing.      export   default   {       // In modules-syntax workers, bindings are delivered as a property of the       // environment object passed as the second parameter when an event handler or       // class constructor is invoked. This is new compared to pre-module workers,       // in which bindings show up as global variables.       async   fetch ( request ,  env )   {       // Derive an object ID from the URL path. `EXAMPLE_CLASS` is the Durable       // Object binding that we will show how to configure in the next section.       // `EXAMPLE_CLASS.idFromName()` always returns the same ID when given the       // same string as input (and called on the same class), but never the same       // ID for two different strings (or for different classes). So, in this       // case, we are creating a new object for each unique path.       let  id  =  env . EXAMPLE_CLASS . idFromName ( new   URL ( request . url ) . pathname ) ;           // Construct the stub for the Durable Object using the ID. A &#34;stub&#34; is a       // client object used to send messages to the Durable Object.       let  stub  =   await  env . EXAMPLE_CLASS . get ( id ) ;           // Forward the request to the Durable Object. Note that `stub.fetch()` has       // the same signature as the global `fetch()` function, except that the       // request is always sent to the object, regardless of the request&#39;s URL.       //       // The first time we send a request to a new object, the object will be       // created for us. If we don&#39;t store durable state in the object, it will       // automatically be deleted later (and recreated if we request it again).       // If we do store durable state, then the object may be evicted from memory       // but its durable state will be kept around permanently.       let  response  =   await  stub . fetch ( request ) ;           // We received an HTTP response back. We could process it in the usual       // ways, but in this case we will just return it to the client.       return  response ;       }      }</p><p>//在模块 - 语法工作人员中，我们使用“导出默认值”（导出默认值）以导出我们的脚本＆＃39; s // main事件处理程序，例如`fetch`处理程序，用于接收http //请求。在模块前的工作人员中，使用//` addeventhandler（＆＃34; fetch＆＃34; event =＆gt; {...}）`中注册了fetch处理程序。这只是//基本上是相同的新语法。导出默认{//在模块中，语法工作人员，绑定作为调用事件处理程序或//类构造函数时作为第二个参数传递的属性。与模块前工人相比，这是新的，其中绑定显示为全局变量。异步获取（请求，env）{//从URL路径中派生对象ID。 “example_class`是持久//对象绑定，我们将在下一节中展示如何配置。 //` example_class.idfromName（）`始终返回与//相同的字符串作为输入时返回相同的ID（并在同一类上调用），但是对于两个不同的字符串（或针对不同类别）的相同// ID。因此，在此//案例中，我们正在为每个唯一路径创建一个新对象。让ID = ENV。 example_class。 IDFROMNAME（新URL（请求。URL）。pathname）; //使用ID构建耐用对象的存根。 A＆＃34;存根＆＃34;是//客户端对象用于向持久对象发送消息。让stub =等待Env。 example_class。得到（ID）; //将请求转发给持久对象。请注意，“stup.fetch（）`has //与全局`fetch（）函数相同的签名，除了//请求始终发送到对象，无论请求＆＃39; s URL如何。 // //我们第一次向新对象发送请求时，对象将为//为我们创建。如果我们不在对象中存储持久状态，它将自动删除（如果我们再次请求，则重新创建）。 //如果我们存储持久状态，则可以从内存中驱逐对象//，但其持久状态将永久地保持周围。让响应=等待存根。获取（请求）; //我们收到了一个HTTP响应。我们可以以通常的//方式处理它，但在这种情况下，我们只会将其返回给客户。回复响应; }}</p><p> Learn more about communicating with a Durable Object in the   Workers Durable Objects API reference.</p><p> 了解有关与工作人员持久对象API参考的持久对象进行通信的更多信息。</p><p> In the above example, we used a string-derived object ID by calling the  idFromName() function on the binding. You can also ask the system to generate random unique IDs. System-generated unique IDs have better performance characteristics, but require that you store the ID somewhere in order to access the object again later.   See the API reference docs for more information.</p><p> 在上面的示例中，我们通过调用绑定上的idfromName（）函数来使用字符串派生对象ID。您还可以要求系统生成随机唯一ID。系统生成的唯一ID具有更好的性能特征，但要求您将ID存储在某处以便稍后再次访问对象。有关更多信息，请参阅API参考文档。</p><p>  At the time of writing, Durable Object support in Wrangler is not yet available in a full release build, so you need to install a release candidate instead. See the   release notes     Open external link for installation instructions and more information.</p><p>  在撰写本文时，Wrangler中的持久对象支持尚未在完整的版本构建中提供，因此您需要安装发布候选人。有关安装说明和更多信息，请参阅发行说明打开外部链接。</p><p> The easiest way to upload Workers that implement or bind to Durable Objects is to use   Wrangler, the Workers CLI. We recommend starting with one of our templates, the simplest of which can be used by running:</p><p> 上传实现或绑定到持久对象的工人的最简单方法是使用Wrangler，工人CLI。我们建议您从我们的模板之一开始，最简单的运行可以使用：</p><p>  This will create a directory for your project with basic configuration and a single JavaScript source file already set up. If you want to be able to bundle external dependencies with your code using Rollup or Webpack, or to use CommonJS modules rather than ES modules, you may want to try one of our other starter templates instead:</p><p>  这将为您的项目创建一个具有基本配置的目录，以及已设置的单个JavaScript源文件。如果您希望使用Rollup或WebPack使用代码捆绑外部依赖项，或者使用CompenJS模块而不是es模块，您可能需要尝试其中一个其他入门模板：</p><p>  The following sections will cover how to customize the configuration, but if you&#39;d like you can immediately publish the generated project using this command:</p><p>  以下部分将介绍如何自定义配置，但如果您可以立即使用此命令启动生成的项目： </p><p>   Workers that use modules syntax must have a &#34;main&#34; module specified from which all Durable Objects and event handlers are exported. The file that should be treated as the main module is configured using &#34;module&#34; key in the  package.json file in the project.</p><p>使用模块语法的工人必须有一个＆＃34;主要＆＃34;指定的模块从中导出所有持久对象和事件处理程序。应该使用＆＃34处理作为主模块的文件。模块＆＃34;在项目中的Package.json文件中的键。</p><p>  Durable Objects bindings can be configured in  wrangler.toml by providing the class name and script name whose objects you wish to access using the binding. The script name can be omitted when creating a binding for a class that is defined in the same Worker as the binding.</p><p>  可以通过提供所希望使用绑定访问其对象的类名和脚本名称，在Wrangler.Toml中配置持久对象绑定。创建在与绑定中定义的类的绑定时，可以省略脚本名称。</p><p> [  ]      bindings   =   [       {   name   =   &#34;EXAMPLE_CLASS&#34; ,   class_name   =   &#34;DurableObjectExample&#34;   }   # Binding to our DurableObjectExample class      ]</p><p> []绑定= [{name =＆＃34; example_class＆＃34; ，class_name =＆＃34; durableObjectExample＆＃34; ＃绑定到我们的DurableObjectExample类]</p><p>    Normally when you want to publish a Worker using Wrangler, you just run  wrangler publish. However, when you export a new Durable Objects class from your script, you must tell the Workers platform about itbefore you can create and access Durable Objects associated with that class. This process is called a &#34;migration&#34;, and is currently performed by providing extra options to  wrangler publish.</p><p>    通常，当您想使用Wrangler发布工人时，您只需运行Wrangler发布。但是，当您从脚本导出新的持久对象类时，您必须告诉Workers平台关于Itbefore您可以创建和访问与该类关联的持久对象。此过程称为A＆＃34;迁移＆＃34;，目前通过为Wrangler发布提供额外的选项来执行。</p><p>   Note that after you&#39;ve run  --new-class for a given class name once, you do not need to include the migration on subsequent uploads of the Worker. You&#39;d just run  wrangler publish with no additional flags.</p><p>   请注意，在您＆＃39; ve run-new-class for the给定的类名称后，您无需在后续上传的工作人员中包含迁移。你＆＃39; d只是运行牧马人没有额外的旗帜。</p><p> If you want to delete the Durable Objects associated with an exported class, you can use  --delete-class:</p><p> 如果要删除与导出的类关联的持久对象，则可以使用--delete-class：</p><p>  Running a  --delete-class migration will delete all Durable Objects associated with the deleted class, including all of their stored data. Don&#39;t do this without first ensuring that you aren&#39;t relying on the Durable Objects anymore and have copied any important data to some other location.</p><p>  运行--delete类迁移将删除与删除类关联的所有持久对象，包括所有存储的数据。不要在没有首先确保你依赖于持久的物体并且已经将任何重要数据复制到其他地方。 </p><p> These are basic examples -- you can use multiple of these options in a single  wrangler publish call if you&#39;d like, one class per option. Future versions of Wrangler will also include migration directives for renaming a class or transferring a class from one file to another.</p><p>这些是基本的例子 - 如果您＆＃39喜欢，您可以在单个争吵者发布呼叫中使用这些选项的多个。 Wrangler的未来版本还将包括重命名类或将类从一个文件传输到另一个文件的迁移指令。</p><p> At this point, we&#39;re done! If you copy the  DurableObjectExample and fetch handler code from above into a generated Wrangler project, publish it using a  --new-class migration, and make a request to it, you&#39;ll see that your request was stored in a Durable Object:</p><p> 在这一点上，我们＆＃39;完成了！如果将DurableObjectExample和Fetch处理程序代码从上面复制到生成的Wrangler项目中，请使用 - 新级迁移发布它，并向您提出请求，您＆＃39; ll看到您的请求存储在持久对象中：</p><p>  As you write Durable Objects, you can find more helpful details in the   Durable Objects runtime API documentation.</p><p>  当您编写持久对象时，您可以在持久对象运行时API文档中找到更多有用的详细信息。</p><p>  Durable Objects is currently in early beta, and some planned features have not been enabled yet. Many of these limitations will be fixed before Durable Objects becomes generally available.</p><p>  耐用对象目前在早期的测试版中，尚未启用一些计划的功能。在耐用对象通常可用之前，许多这些限制将是固定的。</p><p>  At this time, we are not ready to guarantee that data won&#39;t be lost. We don&#39;t expect data loss and do maintain regular backups, but bugs are always possible.</p><p>  此时，我们还没有准备好保证数据赢得＆＃39; t丢失。我们不会期望数据丢失并保持定期备份，但始终可能。</p><p> For now, if you are storing data in Durable Objects that you can&#39;t stand to lose, you must arrange to make backups of that data into some other storage system. Do not rely on Durable Objects for storing production data during the beta period. (This is, of course, always best practice anyway, but it is especially important in the beta.)</p><p> 目前，如果您将数据存储在持久对象中，则可以＆＃39; t站立丢失，您必须安排将该数据的备份置于其他存储系统中。不要依赖耐用对象来在测试期间存储生产数据。 （当然，无论如何，这总是最好的练习，但它在测试版中尤为重要。）</p><p>  Uniqueness is currently enforced upon starting a new event (such as receiving an HTTP request), and upon accessing storage. After an event is received, if the event takes some time to execute and does not ever access its durable storage, then it is possible that the Durable Object instance may no longer be current, and some other instance of the same object ID will have been created elsewhere. If the event accesses storage at this point, it will receive an exception, but if the event completes without ever accessing storage, it may not ever realize that the object was no longer current.</p><p>  目前在启动新事件（例如接收HTTP请求）时强制执行唯一性，并且在访问存储时。收到事件后，如果事件需要一些时间才能执行并且不会访问其持久存储，则可能不再可能不再是当前的持久对象实例，并且存在相同对象ID的一些其他实例在其他地方创造。如果事件在此时访问存储，则会收到异常，但如果事件在不访问存储的情况下完成，则可能无法意识到该对象不再是电流。 </p><p> In particular, a Durable Object may be superseded in this way in the event of a network partition or a software update (including either an update of the Durable Object&#39;s class code, or of the Workers system itself).</p><p>特别地，在网络分区或软件更新的情况下可以以这种方式（包括持久对象＆＃39; s类代码或工人系统本身的更新）来以这种方式取代耐用对象。</p><p>  There is currently no support for generating a list of all existing objects, nor any way to bulk export objects.</p><p>  目前没有支持生成所有现有对象的列表，也不是批量导出对象的任何方式。</p><p>   The Workers dashboard does not yet support viewing or editing Workers that use modules syntax. It also does not yet display any information about your Durable Objects or allow you to create client bindings to Durable Objects in your Workers.</p><p>   工人仪表板尚不支持查看或编辑使用模块语法的工作人员。它还尚未显示有关耐用对象的任何信息，或允许您创建对工人中持久对象的客户端绑定。</p><p>  Not all Cloudflare locations support Durable Objects yet, so objects may not be created in exactly the same point-of-presence where they are first requested.</p><p>  并非所有CloudFlare位置都支持持久对象，因此可能无法在首次请求它们的存在点中创建对象。</p><p> Currently, Durable Objects do not migrate between locations after initial creation. We will be enabling automatic migration in the future.</p><p> 目前，持久对象不会在初始创建后迁移位置之间。我们将来将在将来启用自动迁移。</p><p>  Using Durable Objects will often add response latency, as the request must be forwarded to the point-of-presence where the object is located.</p><p>  使用持久对象通常会添加响应延迟，因为必须将请求转发到对象所在的位置。</p><p> While Durable Objects already perform well for many kinds of tasks, we have lots of performance tuning to do. Expect performance (latency, throughput, overhead, etc.) to improve over the beta period -- and if you observe a performance problem, please tell us about it!</p><p> 虽然持久对象已经表现出很多任务，但我们有很多性能调整。预计绩效（延迟，吞吐量，开销等）改善了测试期 - 如果您遵守绩效问题，请告诉我们它！ </p><p>  We&#39;ve included complete example code for both the Worker and the Durable Object for a basic counter below.</p><p>我们＆＃39; Ve包括下面基本计数器的工作者和持久对象的完整示例代码。</p><p> // Worker          export   default   {       async   fetch ( request ,  env )   {       return   await   handleRequest ( request ,  env ) ;       }      }          async   function   handleRequest ( request ,  env )   {       let  id  =  env .  . idFromName ( &#34;A&#34; ) ;       let  obj  =  env .  . get ( id ) ;       let  resp  =   await  obj . fetch ( request . url ) ;       let  count  =   await  resp . text ( ) ;           return   new   Response ( &#34;Durable Object &#39;A&#39; count: &#34;   +  count ) ;      }          // Durable Object          export   class      {       constructor ( state ,  env )   {       this . state   =  state ;       }           async   initialize ( )   {       let  stored  =   await   this . state . storage . get ( &#34;value&#34; ) ;       this . value   =  stored  ||   0 ;       }           // Handle HTTP requests from clients.       async   fetch ( request )   {       // Make sure we&#39;re fully initialized from storage.       if   ( ! this . initializePromise )   {       this . initializePromise   =   this . initialize ( ) . catch ( ( err )   =&gt;   {       // If anything throws during initialization then we need to be       // sure sure that a future request will retry initialize().       // Note that the concurrency involved in resetting this shared       // promise on an error can be tricky to get right -- we don&#39;t       // recommend customizing it.       this . initializePromise   =   undefined ;       throw  err      } ) ;       }       await   this . initializePromise ;           // Apply requested action.       let  url  =   new   URL ( request . url ) ;       let  currentValue  =   this . value ;       switch   ( url . pathname )   {    </p><p> //工作者导出默认{异步获取（请求，env）{return await handleRequest（请求，env）; }} Async函数handlerequest（请求，env）{让id = env。 。 IDFROMNAME（＆＃34; A＆＃34;）;让obj = env。 。得到（ID）;让resp = await obj。获取（请求。URL）;让Count =等待resp。文本 （ ） ;返回新响应（＆＃34;耐用的对象＆＃39; a＆＃39; count：＆＃34; +计数）; } //持久对象导出类{构造函数（州，env）{this。国家=州; } Async initialize（）{让存储=等待它。状态 。贮存 。得到（＆＃34;价值＆＃34;）;这个 。 value =存储|| 0; } //从客户端处理HTTP请求。异步获取（请求）{//确保我们＆＃39;重新初始化存储。如果（！这个。initializePromise）{这个。 initializepromise =它。 initialize（）。 catch（（err）=＆gt; {//如果在初始化期间抛出任何东西，那么我们需要确定将来的请求将重试initialize（）。//请注意重置此共享//承诺中所涉及的并发出错可能是棘手的 - 我们不会＆＃39; t //建议自定义它。这个。initializepromise =未定义;扔犯罪}）;等待这个。 initializepromise; //应用请求的操作。让URL =新URL（请求。URL）;让CurrentValue =这。价值 ;切换（URL。pathname）{</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://developers.cloudflare.com/workers/learning/using-durable-objects?mkt_tok=NzEzLVhTQy05MTgAAAF8KE9Qw8mOEk1HTmCBjwdRtR40ki1kElPd6rf2veAbxRc5aJO99_BKLa4ojN3KpGGTbEEWK90VzpQLCJP4KnKjypjqAAI-E4EmWlrWHlMTxorBtB3B">https://developers.cloudflare.com/workers/learning/using-durable-objects?mkt_tok=NzEzLVhTQy05MTgAAAF8KE9Qw8mOEk1HTmCBjwdRtR40ki1kElPd6rf2veAbxRc5aJO99_BKLa4ojN3KpGGTbEEWK90VzpQLCJP4KnKjypjqAAI-E4EmWlrWHlMTxorBtB3B</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/durable/">#durable</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>