<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>多核OCaml – 2021年将会发生什么 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">多核OCaml – 2021年将会发生什么 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-11 07:35:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/9ac02047708b53ffad59661ba596c275.jpg"><img src="http://img2.diglog.com/img/2020/12/9ac02047708b53ffad59661ba596c275.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>多核OCaml重叠执行A B A C B时间同时执行A B C时间</p><p>  多核OCaml重叠执行A B A C B时间同时执行A B C时间效果处理程序</p><p>  多核OCaml重叠执行A B A C B时间同时执行A B C时间效果处理程序域</p><p>  在编写时没有并发性和并行性✦重构顺序代码本身的成本令人望而却步</p><p>  在编写时就没有并发和并行的问题✦重构顺序代码本身的成本高昂•低延迟和可预测的性能✦非常适合要求约10ms延迟的应用程序</p><p>  在编写时就没有并发和并行的问题sequential重构顺序代码本身的成本高昂•低延迟和可预测的性能✦非常适合要求约10ms延迟的应用程序•与调试和配置工具s gdb，lldb，性能，libunwind等</p><p>  在编写时就没有并发和并行的问题sequential重构顺序代码本身的成本高昂•低延迟和可预测的性能✦非常适合要求约10ms延迟的应用程序•与调试和配置工具s gdb，lldb， perf，libunwind等。可伸缩性之前向后兼容 </p><p>现有代码•性能向后兼容✦现有程序仅使用相同的内存就可以以同样的速度运行</p><p>  现有代码•性能向后兼容✦现有程序仅使用相同的内存就可以以同样的速度运行•多核可伸缩性之前的GC延迟</p><p>  现有代码•性能向后兼容✦现有程序仅使用相同的内存就可以以同样的速度运行•多核可伸缩性之前的GC延迟•与程序检查工具的兼容性</p><p>  现有代码•性能向后兼容✦现有程序使用相同的内存运行速度一样快•多核可伸缩性之前的GC延迟•与程序检查工具的兼容性•高效的并发和并行编程抽象</p><p>      —映射到操作系统威胁d✦建议每个内核有1个域</p><p>  —映射到OS威胁d✦建议每个内核具有1个域•低级域AP I✦Spawn＆amp;加入，等待和if✦域本地存储✦原子存储操作✤Dolan等人，“时空上的数据竞争”，PLDI’18</p><p>  —映射到OS威胁d✦建议每个内核具有1个域•低级域AP I✦Spawn＆amp;加入，等待和if✦域本地存储✦原子存储操作✤Dolan等人，“时空上的数据竞争”，PLDI’18•在域s之间共享对象没有限制✦但是它是如何工作的？ </p><p>增量标记扫频GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•将幸存者复制到主要堆</p><p>  增量标记扫频GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•将幸存者复制到主要堆中</p><p>  增量，标记和清除GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•将幸存者复制到主要堆Mutator主循环开始空闲标记根标记根</p><p>  分代，不移动，增量，标记清除的GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•幸存者已复制到主要堆中Mutator主要周期的开始空闲标记根标记根</p><p>  GC•分代，不移动，增量，标记清除的GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•幸存者已复制到主要堆中Mutator主要循环的开始空闲标记根标记根</p><p>  GC•世代的，不可移动的，增量的，标记清除的GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•幸存者已复制到主要堆中主循环结束Mutator主循环开始空闲标记根标记根</p><p>  GC•世代的，不可移动的，增量的，标记清除的GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•幸存者已复制到主要堆中主循环结束Mutator主循环开始空闲标记根标记根•快速分配 </p><p>GC•世代的，不可移动的，增量的，标记清除的GC次要堆主要堆•小（默认为2 MB）•凹凸指针分配•幸存者已复制到主要堆中主循环结束Mutator主循环开始空闲标记根标记根•快速分配•最大GC延迟＆lt; 10毫秒，第99个百分位数延迟＜ 1毫秒</p><p>  Dom 1 Dom 0 Dom 1域0分配指针域1分配指针次堆</p><p>  次要hea p✦2个全局障碍/次要g c✦在24个内核上，〜10 ms的暂停主要堆Dom 0 Dom 0 Dom 1 Dom 0 Dom 1域0分配指针域1分配指针次堆</p><p>  without所有标记和清扫工作都没有同步完成per每个周期3个屏障（最坏的情况），以同意GC阶段s的结束✤OCam中的两种纤芯的2个屏障✦〜5毫秒在24个核上暂停标记根mutator扫描标记根主要周期的开始主要周期的标记和扫描阶段的末尾可能重叠域0域1</p><p>      库存（正常运行时间的几何数）measurement测量噪声下的差异最多y分配器上的差异导致的离群值</p><p>    编译器级别太低•Domainslib-https://github.com/ocaml-multicore/domainslib Domain 0 Domain N…Task Pool Async / Await Parallel for Domainslib</p><p>  编译器级别太低•Domainslib-https://github.com/ocaml-multicore/domainslib Domain 0 Domain N…Task Pool Async / Await为Domainslib并行让我们来看示例！ </p><p>= let res中的T.setup_pool〜num_domains：（num_domains-1）= T.teardown_pool池中的fib_par池n; res模块T = Domainslib.Task</p><p>  = let res中的T.setup_pool〜num_domains：（num_domains-1）= T.teardown_pool池中的fib_par池n; res let rec fib_par池n =如果n＆lt; = 40则fib_seq n否则让a = T.async池（fun_-> fib_par池（n-1））在let b = T.async池（fun _- > T.await池a + T.await池b模块中的fib_par池（n-2））T = Domainslib.Task</p><p>  n ＜ 2然后1个其他fib_seq（n-1）+ fib_seq（n-2）let fib n = let pool = T.setup_pool〜num_domains：（num_domains-1）in let res = T.teardown_pool pool中的fib_par pool n; res let rec fib_par池n =如果n＆lt; = 40则fib_seq n否则让a = T.async池（fun_-> fib_par池（n-1））在let b = T.async池（fun _- > T.await池a + T.await池b模块中的fib_par池（n-2））T = Domainslib.Task</p><p>  自我1 37.787 0.98 1 2 19.034 1.94 1.99 4 9.723 3.8 3.89 8 5.023 7.36 7.52 16 2.914 12.68 12.97 24 2.201 16.79 17.17</p><p>      x = 0等于board_size-1做y = 0等于board_size-1做next_board。（x）。（y）＆lt;-next_cell cur_board x y完成; ...</p><p>  x = 0等于board_size-1做y = 0等于board_size-1做next_board。（x）。（y）＆lt;-next_cell cur_board x y完成; ...让next（）= ... T.parallel_for pool〜start：0〜finish：（board_size-1）〜body：（fun x-＆gt; for y = 0 to board_size-1 do next_board。（x） 。（y）＆lt;-next_cell cur_board xy完成）; ...</p><p>  自身1 24.326 1 1 2 12.290 1.980 1.98 4 6.260 3.890 3.89 8 3.238 7.51 7.51 16 1.726 14.09 14.09 24 1.212 20.07 20.07电路板尺寸= 1024，迭代= 512 </p><p>OCam中的编程库with具有更好语法的面向回调的编程并行是一种性能hack，而并发是一种程序结构机制</p><p>  OCam中的编程库✦具有更好的语法的面向回调的编程•遭受面向回调的程序的许多陷阱min✦没有回溯，不能使用异常，monadic语法并行性是一种性能hack，而并发是一种程序结构机制</p><p>  OCam中的编程库✦具有更好的语法的面向回调的编程•遭受面向回调的程序的许多陷阱•back没有回溯，无法使用异常，单语法的语法•Go（goroutines）和GHC Haskell（线程）具有更好的抽象—轻量级线程并行是一种性能hack，而并发是一种程序结构机制</p><p>  OCam中的编程库✦具有更好的语法的面向回调的编程•遭受面向回调的程序的许多陷阱•back没有回溯，无法使用异常，单语法的语法•Go（goroutines）和GHC Haskell（线程）具有更好的抽象—轻量级线程并行性是一种性能突破，而并发则是一种程序结构化机制是否应该向OCaml添加轻量级线程？</p><p>    固定效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程</p><p>  固定效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释分开（参见c.f.异常）</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; </p><p>定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;效果声明</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;计算效果声明</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;计算处理程序效果声明</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;计算处理程序暂停当前的计算效果声明</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;计算处理程序定界的延续暂停当前的计算效果声明</p><p>  定义的效果•非本地控制流机制的模块化基础✦异常，生成器，轻量级线程，promise，异步IO，协程•效果声明与解释（cf异常）分开效果E：字符串let comp（）= print_string ＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;计算处理程序定界的连续中止当前计算恢复中止计算效果声明</p><p>  （）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;个人电脑 </p><p>（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34;个人电脑</p><p>  comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp父光纤：一块堆栈+效果处理程序</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp父0</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp k 0</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp k 0</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp k 0</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc main sp k 0 1 </p><p>让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc main sp k 0 1</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc主sp k父0 1</p><p>  让comp（）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc main sp k父级0 1 2</p><p>  （）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc main sp k 0 1 2 3</p><p>  （）= print_string＆＃34; 0＆＃34 ;; print_string（执行E）; print_string＆＃34; 3＆＃34;让main（）=尝试comp（）的效果E k-> print_string＆＃34; 1＆＃34 ;;继续k＆＃34; 2＆＃34 ;; print_string“ 4＆＃34; pc main sp k 0 1 2 3 4</p><p>    效果收益率：unit let run main = ...（*假定连续队列*）let run_next（）=将出队（）与|匹配。一些k-＆gt;继续k（）|无-＆gt; （）中的rec rec生成f =将f（）与|匹配。 （）-＆gt; run_next（）|效果产量k-＆gt;排队k; run_next（）|效果（叉f）k->排队k;在主生成中生成f</p><p>  效果收益率：unit let run main = ...（*假定连续队列*）let run_next（）=将出队（）与|匹配。一些k-＆gt;继续k（）|无-＆gt; （）中的rec rec生成f =将f（）与|匹配。 （）-＆gt; run_next（）|效果产量k-＆gt;排队k; run_next（）|效果（叉f）k->排队k;生成主生成中的f，让fork f =执行（Fork f）let yield（）=执行Yield </p><p>print_endline＆＃34; 1.a＆＃34 ;;让 （）; print_endline＆＃34; 1.b＆＃34;）;叉（fun _-＆gt; print_endline＆＃34; 2.a＆＃34 ;; yield（）; print_endline“ 2.b＆＃34;）;;主跑</p><p>  print_endline＆＃34; 1.a＆＃34 ;;让 （）; print_endline＆＃34; 1.b＆＃34;）;叉（fun _-＆gt; print_endline＆＃34; 2.a＆＃34 ;; yield（）; print_endline“ 2.b＆＃34;）;;运行主1.a 2.a 1.b 2.b</p><p>  print_endline＆＃34; 1.a＆＃34 ;;让 （）; print_endline＆＃34; 1.b＆＃34;）;叉（fun _-＆gt; print_endline＆＃34; 2.a＆＃34 ;; yield（）; print_endline“ 2.b＆＃34;）;;运行main 1.a 2.a 1.b 2.b•直接样式（无monad）•用户代码无需了解效果</p><p>  产生值s JavaScript JavaScript和Pytho n中的基元✦可以使用效果处理程序从迭代器中自动派生</p><p>  产生值s JavaScript JavaScript和Pytho n中的基元✦可以使用效果处理程序从迭代器自动派生•任务-遍历深度为2的完整二叉树✦226个堆栈开关</p><p>  产生值s JavaScript JavaScript和Pytho n中的基元✦可以使用效果处理程序从迭代器自动派生•任务-遍历深度2的完整二叉树5✦226个堆栈开关•迭代器-惯用递归遍历</p><p>  产生值s JavaScript JavaScript和Pytho n中的基元✦可以使用效果处理程序从迭代器自动派生•任务-遍历深度为2的完整二叉树5✦226个堆栈开关•迭代器-惯用的递归遍历•生成器✦手写的生成器（hw-generator）✤CPS转换+去功能化以消除中间闭合分配n effect使用效果处理程序的生成器（eh-generator） </p><p>（3.76x）eh生成器1879（9.30x）多核OCaml变体时间（毫秒）迭代器（基线）492生成器43842（89.1x）nodejs 14.07</p><p>  e✦https://github.com/kayceesrk/ocaml-aeio/•变体s✦Go + net / http（GOMAXPROCS = 1）✦OCaml + http / af + Lwt（显式回调）✦OCaml + http / af +效果处理程序（MC）•使用wrk2衡量的性能</p><p>  e✦https://github.com/kayceesrk/ocaml-aeio/•变体s✦Go + net / http（GOMAXPROCS = 1）✦OCaml + http / af + Lwt（显式回调）✦OCaml + http / af +效果处理程序（MC）•使用wrk2衡量的性能</p><p>  e✦https://github.com/kayceesrk/ocaml-aeio/•变体s✦Go + net / http（GOMAXPROCS = 1）✦OCaml + http / af + Lwt（显式回调）✦OCaml + http / af +效果处理程序（MC）•使用wrk2衡量的性能•直接样式（无monadic语法）</p><p>      rst 2.对效果处理程序的运行时支持•没有效果语法，但其中的所有编译器和运行时位</p><p>  rst 2.效果处理器的运行时支持•没有效果语法，但3.效果系统中的所有编译器和运行时位。跟踪典型值中用户定义的效果。在典型值c中跟踪ambinet效果（参考，IO）。 OCaml成为纯语言（在Haskell意义上）。</p><p>  rst 2.效果处理器的运行时支持•没有效果语法，但3.效果系统中的所有编译器和运行时位。跟踪典型值中用户定义的效果。在典型值c中跟踪ambinet效果（参考，IO）。 OCaml成为纯语言（在Haskell意义上）。让foo（）= print_string＆＃34; hello，world＆＃34; val foo：unit-[io]-＆gt;单元语法仍在开发中 </p><p>资助多核OCaml开发！ •多核+ Tezo✦并行Lwt抢占任务✦直接样式异步IO库✤桥接Async和Lw t之间的差距✦并行Irmin（Tezos的存储层）  资助多核OCaml开发！ •多核+ Tezo✦并行Lwt抢占任务✦直接样式异步IO库✤桥接Async和Lw t之间的差距✦并行Irmin（Tezos的存储层）•端到端多核Tezos演示器（2021年中） ）  — https://github.com/ocaml-multicore/effects-示例•Sivaramakrishnan等人，“并行化到OCaml的并行化”，ICFP 2020  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://speakerdeck.com/kayceesrk/multicore-ocaml-whats-coming-in-2021">https://speakerdeck.com/kayceesrk/multicore-ocaml-whats-coming-in-2021</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ocaml/">#ocaml</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/效果/">#效果</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035964.html"><img src="http://img2.diglog.com/img/2020/11/thumb_15fa78c8d09d8b30e47163ae4b6e977c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035964.html">焦糖色：OCaml到Erlang编译器</a></div><span class="my_story_list_date">2020-11-23 2:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035358.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d3e23d24a57c76a018fbd6ee32757a46.gif" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035358.html">对我在OCaml中完成的第一个应用程序的思考</a></div><span class="my_story_list_date">2020-11-16 9:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034028.html"><img src="http://img2.diglog.com/img/2020/11/thumb_436b4615af308e85c16fea4a159af18a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034028.html">多核OCaml：2020年10月</a></div><span class="my_story_list_date">2020-11-9 21:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032977.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c71cf32a9b845cee62d402a50d3fb46b.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032977.html">Dark的新后端将在F#(2020)</a></div><span class="my_story_list_date">2020-11-3 22:51</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>