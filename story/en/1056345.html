<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>两年后的Elixir和Phoenix Elixir and Phoenix after two years</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Elixir and Phoenix after two years<br/>两年后的Elixir和Phoenix </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-06 04:05:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/fb05ffcca8db76da97390409bd593bfa.png"><img src="http://img2.diglog.com/img/2021/4/fb05ffcca8db76da97390409bd593bfa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Thoughts on the Elixir language and its Phoenix framework after two years of professional work.</p><p>两年后专业工作经过两年后的灵长素语言及其凤凰框架的思考。</p><p> I am a seasoned web developer (working primarily with Ruby on Rails before) and someone who got an opportunity to work on a commercial Elixir project. During the past 2 years, I wrote a lot of Elixir, which I had to learn from scratch. I always found this kind of personal post interesting, so I figured I would write one for you.</p><p> 我是一个经验丰富的网络开发商（主要用手用Ruby在Rails上工作）以及有机会在商业酏剂项目上工作的人。在过去的两年里，我写了很多酏剂，我必须从头开始学习。我一直发现这种个人帖子有趣，所以我想我会为你写一个。</p><p>  If you haven’t heard about Elixir yet, I recommend watching the  Elixir Documentary featuring the creator Jóse Valim for a start. I don’t remember exactly how I found out about Elixir, but most likely from some Ruby community news. I lurked around Elixir space, read many exciting blog posts, and was generally impressed. What drew me to Elixir? While many good things can be said for Elixir, I liked the idea of the preemptive scheduler and the per-process garbage collector. Why?</p><p>  如果您还没有听说过Elixir，我建议观看Elixir纪录片，以创建者JóseValim为一个开始。我不记得我是如何发现Elixir的方式，但最有可能来自一些Ruby社区新闻。我围绕着Elixir Space，阅读了很多令人兴奋的博客文章，并且一般印象深刻。什么让我兴奋于酏剂？虽然可以为elixir说许多好事，但我喜欢先发制人的调度程序和每个过程垃圾收集器的想法。为什么？</p><p> The preemtivness of Beam (the Erlang Virtual Machine) means that the system behaves reasonably under high load. That’s not a small thing. Being able to connect with a remote shell to your running system and still operate it despite the fact it’s under 100% load is quite something. A per-process GC then means that you don’t run GC most of the time while processing web requests. Both give you a very low latency. If you want to know what I am talking about, go and watch the excellent video by Saša Jurić  The Soul of Erlang and Elixir. It’s the best video out there to realize what Beam is about.</p><p> 光束的预先发生（Erlang虚拟机）意味着系统在高负荷下表现合理。这不是一件小事。能够将遥控器连接到运行系统，并且尽管它在100％以下的情况下，它仍然在100％负载下是相当的。然后，每个流程GC意味着在处理Web请求时大部分时间都不会运行GC。两者都给你一个非常低的延迟。如果你想知道我在谈论什么，请通过sašajurić的erlang和elixir的灵魂观看优秀的视频。这是最佳视频，实现了什么光束是关于什么。</p><p> Despite my interest, though, I never actually went and wrote any Elixir. I even told myself that I would most likely pass on Elixir. The problems at hand seemed solvable by Ruby/Rails, and forcing oneself to learn a language without commercial adoption is difficult. To my surprise, one Elixir project appeared out of nowhere in Prague, where I stayed at the time.</p><p> 尽管我的兴趣，但我实际上从未去过任何Elixir。我甚至告诉自己，我很可能会通过酏剂。用红宝石/轨道的手似乎可以解决，并且迫使自己学习没有商业采用的语言是困难的。令我惊讶的是，一位精灵项目出现在布拉格无处不在，在那里我当时住在那里。</p><p> I was working on  my book full-time, and without having any job per se I accepted :). The project itself is not public yet, so while I would love to tell you more about it, you will still have to wait for its public launch.</p><p> 我正在全职工作，没有任何工作，我接受了:)。该项目本身并不公共，所以虽然我很乐意告诉你更多关于它的信息，但您仍然需要等待其公开发布会。</p><p>  On the surface, Elixir feels Ruby-like, but soon you’ll realize it’s very different. It’s a strongly-typed, dynamic, but compiled language. Overall it’s very well designed and features a modern standard library.</p><p>  在表面上，Elixir感到红宝石，但很快你就会意识到它非常不同。这是一个强大的动态但编译的语言。总的来说，它设计得很好，拥有现代标准图书馆。 </p><p>  iex &gt;  1  # integer iex &gt;  0x1F  # integer iex &gt;  1.0  # float iex &gt;  true  # boolean iex &gt;  :atom  # atom / symbol iex &gt;  &#34;elixir&#34;  # string iex &gt;  [ 1 ,  2 ,  3 ]  # list iex &gt;  [{ :atom ,  &#34;value&#34; },  { :atom ,  &#34;value2&#34; }]  # keyword list iex &gt;  { 1 ,  2 ,  3 }  # tuple iex &gt;  ~D[2021-03-30]  # sigil iex &gt;  ~r/^regex$/  # sigil</p><p>IEX＆gt; 1＃Integer Iex＆gt; 0x1f＃Integer Iex＆gt; 1.0＃float iex＆gt;真＃boolean iex＆gt; ：Atom＃原子/符号IEX＆gt; ＆＃34; elixir＆＃34; ＃字符串IEX＆gt; [1,2,3]＃list iex＆gt; [{：原子，＆＃34;价值＆＃34; }，{：原子，＆＃34; value2＆＃34; }]＃关键词列表IEX＆gt; {1,2,3}＃tople iex＆gt; 〜D [2021-03-30] #sigil iex＆gt; 〜r / ^ regex $ /＃sigil</p><p> As you can see, there are no arrays. Just linked lists and quite special keyword lists. We have symbols like in Ruby (with the same problems of mixing them with strings for keys access) and tuples that get used a lot to return errors ( :ok vs  {:error, :name}). I love how tuples make the flow of returning errors standardized (even though it’s not enforced in any way).</p><p> 如您所见，没有数组。只需链接列表和相当特殊的关键字列表。我们在Ruby中有符号（具有与键访问的字符串混合它们的相同问题）和使用批量返回错误的元组（：确定vs {：错误，：name}）。我喜欢元组如何使标准化的返回错误流动（即使它没有以任何方式强制执行）。</p><p>  iex &gt;  map  =  %{ a:  1 ,  b:  2 } %{ a:  1 ,  b:  2 } iex &gt;  map [ :a ] 1 iex &gt;  %{ map  |  a:  3 } %{ a:  3 ,  b:  2 }</p><p>  IEX＆gt;地图=％{A：1，B：2}％{A：1，B：2} IEX＆GT;地图[：a] 1 iex＆gt; ％{MAP |答：3}％{A：3，B：2}</p><p>   Structs work similarly to maps, because it’s basically a wrapper on top of them.</p><p>   结构与映射类似，因为它基本上是一个包装器在它们之上。</p><p> We can use typespecs to add typing annotation for structs and function definitions, but they are limited. Elixir compiler won’t use them. Still, they help with documentation, and their syntax is actually nice:</p><p> 我们可以使用TypeSpecs添加键入的结构和函数定义，但它们有限。 Elixir编译器不会使用它们。仍然，他们帮助文档，他们的语法实际上很好：</p><p> defmodule  StringHelpers  do  @type  word ()  ::  String . t ()  @spec  long_word? ( word ())  ::  boolean ()  def  long_word? ( word )  when  is_binary ( word )  do  String . length ( word )  &gt;  8  end end</p><p> defmodule stringhelpers do @type word（）:: string。 t（）@spec long_word？ （word（））:: boolean（）def long_word？ （Word）当IS_Binary（Word）进行字符串时。长度（字）＆gt; 8结束</p><p> Arguably, we do get one of the best  pattern matching out there. You can pattern match everything all the time. Thanks to pattern matching, you also almost don’t need static typing. Ruby is  getting there as well, but could never really match the wholesome pattern matching experience of Elixir, which was designed around pattern matching from the beginning. You pattern match in method definitions on what arguments you accept, pattern match in  case statements, and your regular code.</p><p> 可以说，我们确实得到了匹配的最佳模式之一。您可以在模式中匹配所有时间。由于模式匹配，您也几乎不需要静态键入。 Ruby也在那里了，但永远不会真正匹配Elixir的有益的模式匹配体验，这是在开始的模式匹配周围设计的。您在方法定义中的模式匹配 - 在案例语句中接受的参数，模式匹配以及您的常规代码。 </p><p>  def  add ( nil ,  nil ),  do :  { :error ,  :cannot_be_nil } def  add ( x ,  nil ),  do :  { :error ,  :cannot_be_nil } def  add ( nil ,  y ),  do :  { :error ,  :cannot_be_nil } def  add ( x ,  y ),  do :  x  +  y</p><p>def添加（nil，nil），do：{：错误，：无法_be_nil} def添加（x，nil），do：{：错误，：无法_be_nil} def添加（nil，y），do：{：错误，：无法_be_nil def添加（x，y），do：x + y</p><p>  def  add ( nil ,  nil ),  do :  { :error ,  :cannot_be_nil } def  add ( x ,  y )  when  is_integer ( x )  and  is_integer ( y )  do  x  +  y end def  add ( x ,  y ),  do :  { :error ,  :has_to_be_integer }</p><p>  def add（nil，nil），do：{：错误，：无法_be_nil} def添加（x，y）当is_integer（x）和is_integer（y）做x + y结束def添加（x，y），do：{ ：错误，：has_to_be_integer}</p><p> You can also make your own guards with  defguard/1 so guards can be pretty flexible.</p><p> 您还可以用Defguard / 1制作自己的警卫，所以防护装置可以非常灵活。</p><p> Elixir is  not an object-oriented language. We practically only write modules and functions. This helps tremendously in understanding code. No  self. Just data in and out of functions and composition with pipes. Unfortunately, there is no early  return that could be useful.</p><p> Elixir不是一种面向对象的语言。我们实际上只编写模块和函数。这有助于了解代码。没有自我。只是用管道进出功能和组合物。不幸的是，没有早期回报可能有用。</p><p>  The standard library is excellent and well documented. It feels modern because it’s modern. If you tried Elixir before, you might remember having to use external libraries for basic calendaring, but that’s the past. It does not try to implement everything as the philosophy is that you can also rely on Erlang standard library. An example of that might be functions to work with ETS (Erlang Term Storage),  rand, and  zip modules.</p><p>  标准图书馆是优秀的，记录好。它感觉现代，因为它是现代化的。如果您之前尝试过Elixir，则可能记住必须使用外部库进行基本的日历，但这是过去。它不会尝试实施一切，因为哲学是您也可以依赖Erlang标准库。该示例可能是与ETS（Erlang术语存储），RAND和ZIP模块一起使用的函数。</p><p> Calling Erlang is without performance penalty, and when I encounter an Erlang call, it does not even feel weird. All-in-all it feels clean and well designed especially compared to Ruby, which keeps a lot of legacy cruft in the standard library.</p><p> 叫erlang没有表现惩罚，当我遇到一个erlang呼叫时，它甚至没有觉得奇怪。一体化的所有意味着清洁，设计精美，特别是与Ruby相比，这在标准库中保持了很多遗留CRUFT。</p><p> ExDoc might be the first impressive thing you get to see in the Elixir world. Just go on and browse  the Elixir docs. Beautifully designed and featuring nice search, version switching, day and night modes. I love it. And as for the code documentation itself, Elixir is amazing. So are the docs for the main libraries and modules (Phoenix, Absinth). Some not-so-common ones could use help, though.</p><p> Exdoc可能是您在Elixir世界中看到的第一个令人印象深刻的事情。继续进行并浏览Elixir Docs。精美的设计和良好的搜索，版本切换，日夜模式。我喜欢它。至于代码文档本身，Elixir很棒。主图书馆和模块（凤凰，苦艾酒）的文档也是如此。有些不太常见的人可以使用帮助。 </p><p>  Elixir’s tooling is one of the best out there. Outside static type checking or editor support, that is. You get Mix which you use as a single interface for all the tasks you might want to do around a given project. From starting and compiling a project, managing dependencies, running custom tasks (like Rake from Ruby) to making releases for deployment. There is a standardized  mix format to format your code as well:</p><p>Elixir的工具是那里最好的工具之一。静态类型检查或编辑器支持，即。您可以将您用作单个接口的组合，以满足您可能想要在给定项目周围执行的所有任务。从启动和编译项目，管理依赖项，运行自定义任务（比如Ruby的Rake）到发布部署。还有一种标准化的混合格式来格式化代码：</p><p> $ mix new mix_project  &amp;&amp;  cd mix_project $ mix deps.get $ mix deps.compile $ mix  test $ mix format $ mix release</p><p> $ mix new mix_project＆amp;＆amp; CD mix_project $ mix deps.get $ mix deps.compile $ mix test $ mix格式$ mix发行版</p><p> A little annoying is the Erlang’s build tool  rebar3 which you will use indirectly and which causes weird compilation errors:</p><p> 有点恼人的是Erlang的构建工具螺纹道3，您将间接使用，并导致奇怪的编译错误：</p><p> ==&gt; myapp **  (Mix ) Could not compile dependency :telemetry,  &#34;/home/strzibny/.mix/rebar3 bare compile --paths=&#34;/home/strzibny/Projects/digi/backend/_build/dev/lib/ */ebin &#34;&#34;  command failed. You can recompile this dependency with  &#34;mix deps.compile telemetry&#34;, update it with  &#34;mix deps.update telemetry&#34; or clean it with  &#34;mix deps.clean telemetry&#34;</p><p> ==＆gt; myapp **（mix）无法编译依赖性：遥测，＆＃34; /home/strzibny/mix/rebar3裸致编译 -  patanss =＆＃34; / home / strzibny / projects / digi / backend / _build / dev / lib / * / ebin＆＃34;＆＃34;命令失败。您可以重新编译＆＃34; mix deps.compile etemetry＆＃34;，用＆＃34更新它; mix deps.update遥测＆＃34;或用＃34清洁它;混合DEPS.CLEAN遥测＆＃34;</p><p>    Moving on from Mix, you’ll get to use the very nice IEx shell that I wrote about  in detail already. My favorite things about IEx are the easy recompilation of the project:</p><p>    从混合开始，您将使用我已经详细编写的非常漂亮的IEX shell。关于IEX的我最喜欢的事情是项目的轻松重新编译：</p><p>    The only annoyance comes from Elixir data types and how they work. Inspecting lists require this:</p><p>    唯一的烦恼来自于Elixir数据类型以及它们的工作方式。检查列表需要如下：</p><p>   And there is more! Beam also gives you a debugger and an observer. To start Debugger:</p><p>   还有更多！光束还为您提供调试器和观察者。要启动调试器： </p><p>       Debugger’s function is clear, Observer helps to oversee the processes and supervision trees as Erlang VM is based on the Actor pattern with lightweight supervised processes. Coming from Ruby, I also like how the compiler does catch a bunch of errors before you get to your program. Then we have Dialyzer that can catch a ton of stuff that’s wrong, including the optional types from typespecs. But it’s far from perfect (both in function and speed), and so many people don’t run with it.</p><p>调试器的功能很清楚，观察员有助于监督流程和监督树，因为Erlang VM基于带有轻量级监督程序的演员模式。来自Ruby，我也喜欢编译器如何在访问程序之前捕获一堆错误。然后我们有透析器，可以捕获一大吨的东西，这是错误的，包括典型值的可选类型。但它远非完美（在功能和速度中），很多人都没有搭配它。</p><p> Most developers seek a great IDE or editor integration. I am using Sublime Text together with  Elixir language server, and I documented the setup  before. There is also a good  plugin for IntelliJ IDEA that might be the best you can get right now. Elixir is not Java, but many nice things work.</p><p> 大多数开发人员都会寻求一个伟大的IDE或编辑集成。我使用升华文本与elixir语言服务器，我以前记录了设置。 Intellij Idea也有一个很好的插件，可能是您现在可以获得最好的。 Elixir不是Java，但很多好的事情就是工作。</p><p> The only real trouble for me is that my setup is quite resource-hungry. So while super helpful, I do tend to disable it at times. In general, I would say the editor support is somehow on par with Ruby, but I also believe Elixir’s design allows for great tools, we just don’t have them yet.</p><p> 对我来说唯一的真正麻烦是我的设置是非常饥饿的。因此，虽然超级有帮助，但我倾向于有时禁用它。一般来说，我会说编辑支持是以某种方式与Ruby相提并论，但我也相信Elixir的设计允许伟大的工具，我们尚未拥有它们。</p><p>  Testing Elixir code is pretty nice. I like that everyone uses ExUnit. One cool thing is doctests:</p><p>  测试Elixir代码非常好。我喜欢每个人都使用exunit。一件很酷的事情是医生：</p><p> # Test defmodule  CurrencyConversionTest  do  @moduledoc  false  use  ExUnit . Case ,  async:  true  doctest  CurrencyConversion  ... end # Module defmodule  CurrencyConversion  do  ...  @doc  &#34;&#34;&#34; Convert from currency A to B. ### Example iex&gt; convert(Money.new(7_00, :CHF), :USD) %Money{amount: 7_03, currency: :USD} &#34;&#34;&#34;  ... end</p><p> ＃测试defmodule currencyconverstest do @moduledoc false使用exunit。案例，异步：真正的医疗currencyConversion ......结束＃模块DefModule CurrencyConversion ... @doc＆＃34;＆＃34;从货币A转换为B. ###示例IEX＆gt;转换（金钱.NEW（7_00，：CHF），：USD）％金额{金额：7_03，货币：：USD}＆＃34;＆＃34;＆＃34; ... 结尾</p><p> The above documentation’s example will be run as part of the test suite. Sweet!</p><p> 上述文档示例将作为测试套件的一部分运行。甜的！</p><p> The thing getting used to coming from Rails is mocking. While you might like the end result, it certainly is more tedious to write. This is because you cannot just override anything like in the Ruby world. When I use the Mox library, I usually have to:</p><p> 习惯于来自rails的东西是嘲笑的。虽然您可能喜欢最终结果，但它肯定更繁琐。这是因为你不能只覆盖红宝石世界中的任何东西。当我使用MOX库时，我通常必须： </p><p> Use this behavior for my real module and my new stub (that will return a happy path)</p><p>为我的真实模块和我的新存根使用此行为（这将返回一个快乐的路径）</p><p> That way, you can easily test a default response and also use Mox to return something else for each test (such as an error response). I have  a post explaining that.</p><p> 这样，您可以轻松测试默认响应，也可以使用MOX返回每个测试（例如错误响应）的其他东西。我有一个解释的帖子。</p><p> The language nature of modules and functions ensures that your testing is straightforward, and multicore support ensures your test runs really really fast. The downside to a fast test suite is that you have to compile it first. So do not necessarily expect fast tests for your projects in CI. You will, however, see a considerable improvement over the Rails test suites once they get big.</p><p> 模块和功能的语言性质可确保您的测试很简单，而且多核支持可确保您的测试真的非常快。快速测试套件的缺点是您必须先编译它。因此，不一定期望在CI中的项目进行快速测试。但是，您将看到一旦它们变大，可以看到Rails测试套件的相当大。</p><p>  Phoenix is the go-to web framework for Elixir. It’s neither Rails in scope but neither a microframework like Sinatra. It has some conventions, but you can change them without any big problem. Part of the reason for that is that it’s essentially a library, and also that you pair it with Ecto, your “ORM”. You write your Elixir application “with” Phoenix, not writing a Phoenix application (like with Rails).</p><p>  Phoenix是Elixir的Go-web框架。它既不是范围的轨道，但既不是SINATRA这样的微型ramework。它有一些惯例，但你可以在没有任何大问题的情况下改变它们。部分原因是它基本上是一个图书馆，也是你用ecto，你的“orm”配对它。您将Elixir应用程序写作“与”凤凰，而不是撰写凤凰申请（如rails）。</p><p> Apart from being  fast (Elixir is not fast perse, but templates are super-efficient, for example), it has two  unique features that make it stand out even more.</p><p> 除了快速（Elixir不是快速的Perse，而是模板例如是超效率，它有两个独特的功能，使其更加突出。</p><p> One of those is  LiveView, which lets you build interactive applications without writing JavaScript. And the second is  LiveDashboard, a beautiful dashboard built on top of LiveView that you can include in your application in 2 minutes. It gives you many tabs of useful information about the currently running system (and you can switch nodes easily too). Some of those are:</p><p> 其中一个是LiveView，它允许您在不编写JavaScript的情况下构建交互式应用程序。第二个是Liveashboard，一个美丽的仪表板，内置于LiveView之上，您可以在2分钟内包含在您的应用程序中。它为您提供了许多有关当前运行系统的有用信息的标签（并且您也可以轻松切换节点）。其中一些是：</p><p>  I wish Phoenix had a maintenance policy like Rails so it could be taken more seriously. On the other hand, I think it doesn’t change as much anymore. Phoenix name and logo are also a nice touch as a reference to Beam’s fault tolerance (your Elixir processes will come back from the ashes).</p><p>  我希望Phoenix有一个像轨道这样的维护政策，所以它可以更认真地拍照。另一方面，我认为它不会更改。 Phoenix名称和徽标也是一个很好的触摸，作为对梁的容错公差的参考（您的Elixir进程将从灰烬中回来）。 </p><p>  What’s important to me in a web framework is productivity. I don’t care I can craft the best performing applications in C, or have everything compiler-checked. I care about getting stuff done. I prefer frameworks that are designed for small teams because I want to be productive on my own. Phoenix is  not batteries-included as Rails, although having features like LiveDashboard is probably better than having Action Text baked in. There are file uploads in LiveView, but it’s not a complete framework like  Active Storage. So it’s behind Rails a little in productivity, but it’s still a very productive framework.</p><p>在Web框架中对我很重要的是生产力。我不在乎我可以在c中制作最好的执行应用程序，或者有一切编译器检查。我关心完成的东西。我更喜欢为小型团队设计的框架，因为我希望自己富有成效。凤凰不是作为rails包含的电池，尽管具有Liveveashboard等功能可能比烘焙的动作文本更好。LiveView中有文件上传，但它不是一个完整的框架，如活动存储。所以它在生产力的轨迹后面，但它仍然是一个非常富有成效的框架。</p><p> I am also convinced Phoenix scales better not only for hardware but also in terms of the codebase. I like the idea of splitting  lib/app and  lib/app_web from the beginning and the introduction of  contexts. Context tells you to split your  lib/app in a kind of service-oriented way where you would have  app/accounting.ex or  app/accounts.ex as your entry points to the functionality of your app.</p><p> 我也很顺利，不仅适用于硬件，还可以更好地适用于码级。我喜欢从开始和引入上下文中拆分lib / app和lib / app_web的想法。上下文告诉您以一种以服务为导向的方式拆分您的LIB /应用程序，您可以将App / Consucting.ex或App / Account.ex作为您的应用程序的输入点。</p><p> Another interesting aspect is that since Phoenix is compiled, browsing your development version of the app is not slow like in Rails. It flies. Errors are also pretty good (and both error reporting and compiler warnings are improving every day):</p><p> 另一个有趣的方面是，自编译菲尼克斯以来，浏览应用程序的开发版本不像Rails中的速度。它飞了。错误也非常好（并且每天都有错误报告和编译器警告都需要改进）：</p><p> constraint error when attempting to insert struct: * unique_validation_api_request_on_login_id_year_week (unique_constraint)If you would like to stop this constraint violation from raising anexception and instead add it as an error to your changeset, pleasecall `unique_constraint/3` on your changeset with the constraint`:name` as an option.The changeset defined the following constraints: * unique_address_api_request_on_login_id_year_week (unique_constraint)</p><p> 尝试插入结构时的约束错误：* unique_validation_api_request_on_login_id_year_week（unique_constraint）如果要停止违反此约束违反anexception，而是将其添加到Changeset上的错误，请使用约束：名称`作为选项。Changeset定义了以下约束：* unique_address_api_request_on_login_id_year_week（unique_constraint）</p><p> But what I really really like? The development of Phoenix full-stack applications. No split between an Asset Pipeline and Webpacker (two competing solutions) and everything works without separately running your development Webpack server. You change a React component, switch to a Firefox window, and the change is there! And the only thing you were running is your  mix phx.server.</p><p> 但我真的很喜欢的是什么？ Phoenix全堆叠应用程序的开发。在资产管道和WebPacker（两个竞争解决方案）之间没有拆分，并且一切都在没有单独运行开发的WebPack服务器。您更改React组件，切换到Firefox窗口，更改在那里！你正在运行的唯一方法是你的mix phx.server。</p><p> But productivity cannot happen without good  libraries. While Elixir and Phoenix eco-system has some outstanding options for things like GraphQL (Absinth) and Stripe (Stripity Stripe) there are not many good options for cloud libraries and other integrations. I feel like Stripe is the only exception here, but it’s not an official SDK.</p><p> 但没有良好的图书馆，生产力就不会发生。虽然Elixir和Phoenix Eco-System具有一些出色的选择GraphQL（嗯）和条纹（条纹条纹），但云库和其他集成没有许多好的选择。我觉得条纹是这里唯一的例外，但这不是官方的SDK。</p><p> Sometimes this is problematic as making your own SOAP library is not as much fun if you need to be shipping features involving SOAP at the same time. Sometimes, though, this can lead to building minimal solutions that are easy to maintain. We have practically two little modules for using object storage in Azure. I blogged before about how I implemented  Azure pre-signing if you are interested.</p><p> 有时，如果您需要同时携带SOAP的运输功能，您的SOAP库也没有很有趣。但有时，这可能导致构建易于维护的最小解决方案。我们实际上有两个小模块，用于在Azure中使用对象存储。我之前博彩了关于我如何实现Azure预签名，如果您有兴趣。 </p><p>  The deployment of Phoenix can be as easy as copying the Mix release I already mentioned to the remote server. You can then start it as a systemd service, for instance. While it wasn’t always straightforward to deploy Elixir web applications, it got ridiculously easy recently. Imagine running something like this:</p><p>Phoenix的部署可以简单地复制我已经提到的Mix释放到远程服务器。然后，您可以将其作为SystemD服务启动。虽然部署Elixir Web应用程序并不总是很简单，但它最近被嘲笑。想象一下，这样的东西：</p><p> $ mix deps.get  --only prod $ MIX_ENV =prod mix compile $ npm  install  --prefix ./assets $ npm run deploy  --prefix ./assets $ MIX_ENV =prod mix phx.digest $ MIX_ENV =prod mix release new_phoenix $ PORT =4000 build/prod/rel/new_phoenix/bin/new_phoenix start</p><p> $ mix deps.get  -  gix $ mix_env = prod mix compile $ npm install --prefix ./assets $ npm运行部署--prefix ./assets $ mix_env = prod mix mix phx.digest $ mix_env = prod mix发行new_phoenix $ Port = 4000 Build / Prod / Rel / New_Phoenix / Bin / New_Phoenix Start</p><p> Of course, you can make a light way Docker container too, but maybe you don’t even need to. Mix releases are entirely self-contained (even better than a Java’s JAR)! Here is how to make them with a little bit of  context. The only thing to pay attention to is that they are platform-dependent, so you  cannot cross-compile them easily right now.</p><p> 当然，你也可以制作一个轻微的方式码头容器，但也许你甚至不需要。混合释放完全是独立的（甚至比Java的罐更好）！以下是如何用一点点上下文制作它们。唯一要注意的是他们是平台依赖的，所以你现在不能轻易编译它们。</p><p> Although people are drawn to Elixir for its distributed nature, its performance makes it a great platform for running a powerful single server too (which is how devs at  X-Plane flight simulator run their Elixir backend). Especially since Elixir also supports hot deployments, which is kind of cool. Mix releases do not support this option, though.</p><p> 虽然人们被授予Elixir的分布式性质，但它的性能也使其成为运行强大的单服务器的一个很好的平台（这是X-Plane Flight Simulator的Devs如何运行他们的Elixir后端）。特别是因为Elixir也支持热门部署，这是一种很酷的。但是，MIX版本不支持此选项。</p><p>  The Elixir (and Phoenix) community is amazing. I always got quick and very helpful answers on  Elixir Forum and other places. Elixir is niche. But it’s not Crystal or Nim niche. Still, it’s not an exception that you get answers directly from José Valim. How he can even reply so fast is still beyond me :). Thanks, Jóse!</p><p>  Elixir（和Phoenix）社区很棒。我总是在Elixir论坛和其他地方得到快速而非常有帮助的答案。 Elixir是利基。但它不是水晶或nim niche。尽管如此，你不是一个例外，你直接从josévalim得到答案。他甚至可以回复这么快，仍然超出我:)。谢谢，jóse！</p><p> Podium, Sketch, Bleacher Report, Brex, Heroku, and PepsiCo are famous brands using Elixir.  Elixir Companies is a site tracking public Elixir adoption. I am myself on a not yet public project, so I am sure they are more Elixir out there!</p><p> 领奖台，素描，漂白板报告，Brex，Heroku和百事可乐是使用Elixir的着名品牌。 Elixir公司是一个追踪公共Elixir采用的网站。我是我自己在尚未公开的项目上，所以我相信他们更加灵活了！</p><p> If you are blogging about Elixir, join us at  BeamBloggers.com. There is also  ElixirStatus for community news.</p><p> 如果您是关于Elixir的博客，请加入我们的Beambloggers.com。还有Elixirstatus为社区新闻。 </p><p>  And that’s pretty much it. If you are surprised I didn’t get into OTP, it’s because I didn’t get to do much OTP. It’s sure great (you reap the benefits just by using Phoenix), but you can use Elixir without doing a lot of OTP yourself.</p><p>这就是它。如果你感到惊讶，我没有进入OTP，这是因为我没有做太多的OTP。这确实很棒（你只是通过使用Phoenix获得的好处），但你可以使用Elixir而不做出很多OTP自己。</p><p> The certain pros of Elixir are a small language you’ll learn fast, a modern, beautifully documented standard library, robust pattern matching, and understanding functions without headaches. What I don’t like is the same split for string vs atom keys in maps (without the Rails  HashWithIndifferentAccess) and I have to admit – there are times I miss my instance variables.</p><p> Elixir的某些专业人士是一种小型语言，您将学习快速，现代，精美记录的标准库，强大的模式匹配和理解功能，无头疼。我不喜欢的是，映射中的字符串VS atom键（没有rails hashwithindifferentaccess），我必须承认 - 有时我想念我的实例变量。</p><p> Learning Elixir and Phoenix is undoubtedly worth it. I think it’s technologically the best option to build ambitious web applications and soft-realtime systems we have today. It still lacks in few areas, but nothing that cannot be fixed in the future. And if not for Elixir, then for the Beam platform (see  Caramel).</p><p> 学习Elixir和Phoenix无疑值得。我认为它在技术上是建立我们今天的雄心勃勃的Web应用程序和软实时系统的最佳选择。它仍然缺少几个地区，但未来没有任何无法修复。如果不是Elixir，那么对于梁平台（见焦糖）。</p><p> I also like that Elixir is not just a language for the web. There is  Nerves for IoT, and recently we got  Nx with LibTorch backend.</p><p> 我也喜欢那个elixir不仅仅是网络的语言。 IOT有神经，最近我们得到了Libtorch后端的NX。</p><p>       I am writing a complete guide on web application deployment. Ruby with Puma, Python with Gunicorn, NGINX, PostgreSQL, Redis, networking, processes, systemd, backups, and all your usual suspects.</p><p>       我正在编写关于Web应用程序部署的完整指南。 Ruby用Puma，Python与枪手，Nginx，PostgreSQL，Redis，网络，流程，系统，备份和所有通常的嫌疑人。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nts.strzibny.name/elixir-phoenix-after-two-year/">https://nts.strzibny.name/elixir-phoenix-after-two-year/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/phoenix/">#phoenix</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>