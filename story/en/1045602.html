<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>隐藏图像中的消息：使用Python和Repl.it进行隐写术 Hiding messages in images: steganography with Python and Repl.it</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hiding messages in images: steganography with Python and Repl.it<br/>隐藏图像中的消息：使用Python和Repl.it进行隐写术 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-22 01:05:28</div><div class="page_narrow text-break page_content"><p>In this tutorial, we&#39;ll build a steganography tool in Python. Steganography is the practice of hiding information within other data. Unlike encryption, where the goal is to secure  the contents of communication between two parties, steganography aims to obscure the fact that the parties are communicating at all.</p><p>在本教程中，我们将使用Python构建隐写工具。隐写术是将信息隐藏在其他数据中的一种做法。与加密不同，加密的目标是确保两方之间的通信内容的安全，而隐写术则旨在掩盖双方之间根本无法通信的事实。</p><p> Our tool will enable the user to hide secret text within a normal-looking  .png image file. The receiver of the image will use the same tool to reveal the hidden message.</p><p> 我们的工具将使用户能够在外观正常的.png图像文件中隐藏秘密文本。图像的接收者将使用相同的工具来显示隐藏的消息。</p><p> We&#39;ll use Python to build the tool. The most popular Python image processing libraries are  Pillow and  OpenCV, but these are heavy libraries with many dependencies. We&#39;ll avoid these and instead use the lightweight  PyPNG library which is written in pure Python, and therefore easier to run on various platforms.</p><p> 我们将使用Python来构建该工具。最受欢迎的Python图像处理库是Pillow和OpenCV，但它们是具有许多依赖关系的繁重库。我们将避免这些情况，而是使用轻量级的PyPNG库（该库是用纯Python编写的），因此更易于在各种平台上运行。</p><p>  Let&#39;s imagine three people: Alice, Bob and Eve. Alice wants to send a private message to Bob, while Eve wants to intercept this message. While modern-day encryption can help Alice and Bob ensure that Eve doesn&#39;t know the  contents of their message, Eve can possibly still deduce interesting information just from knowing that Alice and Bob are communicating at all, and how frequently they communicate.</p><p>  让我们想象三个人：爱丽丝，鲍勃和夏娃。爱丽丝想发送私信给鲍勃，夏娃想截取这条消息。虽然现代加密可以帮助Alice和Bob确保Eve不知道其消息的内容，但是Eve仍然可以仅从知道Alice和Bob处于通信状态以及它们通信的频率来推断出有趣的信息。</p><p> To obscure the communication channel completely, Alice and Bob can exploit the fact that hundreds of millions of photos are uploaded and shared across the internet daily. Instead of communicating directly, Alice can leave her message hidden in an image at a pre-agreed location and Bob can access this message. From Eve&#39;s perspective, there is now no direct communication between the two.</p><p> 为了完全掩盖通信渠道，爱丽丝和鲍勃可以利用每天通过互联网上传和共享数亿张照片这一事实。爱丽丝可以直接在图像中的预定位置隐藏她的消息，而不必直接进行通信，而鲍勃可以访问此消息。从夏娃的角度来看，两者之间现在没有直接联系。</p><p> A single image is made up of millions of pixels. While many formats exist, a pixel is most simply represented by a group of three numbers between 0 and 255, one number each for the red, blue, and green values of that pixel. Using this Red-Green-Blue scheme we can represent any colour in the  RGB color model.</p><p> 单个图像由数百万个像素组成。尽管存在许多格式，但是像素最简单地由一组介于0到255之间的三个数字表示，每个数字分别代表该像素的红色，蓝色和绿色值。使用这种红-绿-蓝方案，我们可以代表RGB颜色模型中的任何颜色。</p><p> Digital text, like images, is also represented internally by numbers, so the differences between a text file and an image file are not as large as you might assume. Any digital data can be represented as a  binary string, a bunch of 1s and 0s, and we can make tiny modifications to an image to encode a binary string within it. As an example, consider the following:</p><p> 数字文本（例如图像）在内部也用数字表示，因此文本文件和图像文件之间的差异并不像您想象的那么大。任何数字数据都可以表示为二进制字符串，一串1和0，我们可以对图像进行微小的修改以在其中编码二进制字符串。例如，请考虑以下内容： </p><p>  This is a representation of an image with three pixels: one red, one green, and one blue. If we encode this as an image and open it in an image viewer, we&#39;ll see the three pixel image, but if we read this data with Python, it is simply a list of tuples, each containing three integers.</p><p>这是具有三个像素的图像的表示形式：一个红色，一个绿色和一个蓝色。如果将其编码为图像并在图像查看器中打开，我们将看到三个像素的图像，但是如果我们使用Python读取此数据，则它只是一个元组列表，每个元组包含三个整数。</p><p> We could also look at each value making up each pixel and calculate whether it is  odd or  even. We could encode odd numbers as  1 and even values as  0. This would give us the binary string &#34;100 010 001&#34; (as the 255 values are odd and the 0s are even).</p><p> 我们还可以查看组成每个像素的每个值，并计算它是奇数还是偶数。我们可以将奇数编码为1，将偶数编码为0。这将为我们提供二进制字符串＆＃34; 100 010 001＆＃34;。 （因为255个值是奇数，0个是偶数）。</p><p>   The image would look almost identical in any image viewer (we have just added or subtracted a minuscule amount of color from some values), but the binary string -- using our odd/even method -- would look completely different: &#34;011 111 100&#34;.</p><p>   在任何图像查看器中，图像看起来几乎都是相同的（我们刚刚从某些值中添加或减去了少量的颜色），但是使用我们的奇/偶方法，二进制字符串看起来将完全不同：＆＃34; 011111100＆＃34;。</p><p> Using this technique but extending it over an entire image (millions of pixels), we can hide a large amount of text data in any image.</p><p> 使用此技术但将其扩展到整个图像（数百万像素），我们可以在任何图像中隐藏大量文本数据。</p><p>  If you were serious about keeping your messages as secret as possible, you&#39;d want to do all of these steps on an offline computer that you fully control. As a learning exercise though, we&#39;ll set the project up on  repl.it. Navigate to their site and sign up for an account if you don&#39;t have one.</p><p>  如果您认真考虑将消息尽可能保密，则希望在完全控制的脱机计算机上执行所有这些步骤。不过，作为学习练习，我们将在repl.it上设置项目。如果您没有帐户，请导航到他们的网站并注册一个帐户。</p><p> Create a new project, choosing &#34;Python&#34; as the language, and give your project a name.</p><p> 创建一个新项目，选择＆＃34; Python＆＃34;作为语言，并为您的项目命名。</p><p>  The first piece we need to build is a function to encode any text message as a binary string.</p><p>  我们需要构建的第一部分是将任何文本消息编码为二进制字符串的函数。 </p><p>   import base64def encode_message_as_bytestring( ): b64 =  .encode( &#34;utf8&#34;) bytes_ = base64.encodebytes(b64) bytestring =  &#34;&#34;.jo [ &#34;{:08b}&#34;. ( ) for     bytes_])   bytestring</p><p>import base64def encode_message_as_bytestring（）：b64 = .encode（＆＃34; utf8＆＃34;）bytes_ = base64.encodebytes（b64）bytestring =＆＃34;＆＃34; .jo [＆＃34; {：08b}＆ ＃34;。 （）for bytes_]）bytestring</p><p> This first encodes our text as  base64 and then as a binary string. You can add some print statements to see how the message is transformed in the different steps, as shown below.</p><p> 这首先将我们的文本编码为base64，然后编码为二进制字符串。您可以添加一些打印语句，以查看如何在不同的步骤中转换消息，如下所示。</p><p>  The base64 step is not strictly necessary, but it is useful as any file or data can be encoded as base64. This opens our project up to future extensions such as hiding other kinds of files within image files instead of just text strings.</p><p>  base64步骤不是严格必需的，但是它很有用，因为任何文件或数据都可以编码为base64。这使我们的项目可以扩展到将来的扩展，例如在图像文件中隐藏其他类型的文件，而不仅仅是文本字符串。</p><p>  We&#39;ll assume that our message will always &#39;fit&#39; in our image. We can fit three binary digits per pixel (one for each of the RGB values), so our resulting binary string should be shorter than the the number of pixels in the image multiplied by three.</p><p>  我们假设我们的信息将始终“适合”您的信息。在我们的形象。我们可以将每个像素容纳三个二进制数字（每个RGB值一个），因此，我们得到的二进制字符串应短于图像中像素的数目乘以3。</p><p> We&#39;ll also need to know when the message  ends. The message will only be encoded in the beginning of the image file, but if we don&#39;t know how long the message is, we&#39;ll keep looking at normal pixels and trying to encode them as text data. Let&#39;s add an &#34;end of string&#34; delimiter to the end of our message: this should be something that wouldn&#39;t appear half way through our actual message by chance. We&#39;ll use the binary representation of &#39;!ENDOFMESSAGE!&#39; for this.</p><p> 我们还需要知道消息何时结束。该消息将仅在图像文件的开头进行编码，但是如果我们不知道该消息有多长，我们将继续查看正常像素并将其编码为文本数据。让我们添加一个字符串的结尾。在消息末尾定界：这应该是偶然出现在我们实际消息中间的内容。我们将使用＆＃39;！ENDOFMESSAGE！＆＃39;的二进制表示形式为了这。</p><p>  import  base64ENDOFMESSAGE =  &#34;0100100101010101010101100100111101010010010001010011100101000111010101000101010101010110010101000101010100110000010001100100100001010010010100110100010100111101&#34;def encode_message_as_bytestring(message):  b64 = message.encode( &#34;utf8&#34;)  bytes_ =  base64.encodebytes(b64)  bytestring =  &#34;&#34;. join([&#34;{:08b}&#34;.format(x) for x in  bytes_])  bytestring += ENDOFMESSAGE return  bytestring</p><p>  导入base64ENDOFMESSAGE =＆＃34; 0100100101010101010101100100111101010010010001010011100101000111010101000101010101010110010101000101010100110000010001100100100001010010010010010010001000100101101＆＃34; def encode_message_as_bytestring（message）：b64 = 34。 。 join（[＆＃34; {：08b}＆＃34; .format（x）for x in bytes_]]）字节串+ = ENDOFMESSAGE返回字节串</p><p>   Find a PNG image somewhere - either one you&#39;ve taken yourself or from a site like unsplash. You can use any online JPG to PNG converter if you only have  .jpg files available.</p><p>   在某处找到PNG图片-您是自己拍摄的，还是来自unsplash之类的网站。如果只有.jpg文件，则可以使用任何在线JPG到PNG转换器。 </p><p> Upload your PNG file by clicking on the three dot menu in the repl sidebar, in the top right corner of the files pane to the left, and selecting  upload file or by simply dragging and dropping your file within the files pane.</p><p>通过单击repl侧栏中的三点菜单（在文件窗格的右上角到左侧），然后选择上载文件，或通过简单地将文件拖放到文件窗格中，来上载PNG文件。</p><p>  We&#39;re going to write a function that extracts the raw pixel data from this image file. Add an import to the top of the file.</p><p>  我们将编写一个从该图像文件中提取原始像素数据的函数。将导入添加到文件顶部。</p><p>      We are primarily interested in the third item, &#34;rows&#34;, which is an iterator containing all the pixels of the image, row by row. If you&#39;re not familiar with Python generators take a look at  this guide, but they are essentially memory-efficient lists.</p><p>      我们主要对第三项＆＃34; rows＆＃34;感兴趣，它是一个迭代器，它逐行包含图像的所有像素。如果您不熟悉Python生成器，请参阅本指南，但它们本质上是内存有效的列表。</p><p>  Now that we have the encoded message and pixels of the image ready we can combine them to form our secret encoded image.</p><p>  现在我们已经准备好图像的编码消息和像素，可以将它们组合起来以形成我们的秘密编码图像。</p><p> Add the following function to the bottom of the  main.py file. This function takes in the outputs from the previous functions (our raw pixels and our message encoded as a binary string), and combines them.</p><p> 将以下函数添加到main.py文件的底部。此函数接收先前函数的输出（我们的原始像素和我们的消息编码为二进制字符串），并将它们组合在一起。</p><p> def  ( pixels, bytestring):  &#39;&#39;&#39;modifies pixels to encode the contents from bytestring&#39;&#39;&#39; enc_pixels = [] string_i =  0  for row  in pixels: enc_row = []  for i, char  in  enumerate(row):  if string_i &gt;=  len(bytestring): pixel = row[i]  else:  if row[i] %  2 !=  int(bytestring[string_i]):  if row[i] ==  0: pixel =  1  else: pixel = row[i] -  1  else: pixel = row[i] enc_row.append(pixel) string_i +=  1 enc_pixels.append(enc_row)  return enc_pixels</p><p> def（像素，字节串）：＆＃39;＆＃39;＆＃39;修改像素以对字节串中的内容进行编码enc_pixels = [] string_i = 0（以像素为单位）：enc_row = [] for i，char枚举（行）：如果string_i> = len（bytestring）：像素= row [i]否则：if row [i]％ 2！= int（bytestring [string_i]）：如果row [i] == 0：像素= 1 else：像素= row [i]-1 else：像素= row [i] enc_row.append（pixel）string_i + = 1 enc_pixels.append（enc_row）返回enc_pixels</p><p> This is the most complicated part of our project, but most of the code is there to handle edge cases. The important insight is that we want to control whether each pixel has an odd value (representing a 1 in our binary string) or an even one (to represent a 0). By chance, half of the pixel values will already have the correct value.</p><p> 这是我们项目中最复杂的部分，但是大多数代码都可以用来处理极端情况。重要的见解是，我们要控制每个像素是一个奇数值（在我们的二进制字符串中表示1）还是偶数（表示0）。偶然地，一半的像素值将已经具有正确的值。 </p><p> We simply loop through the binary string and the pixel and &#39;bump&#39; each value that isn&#39;t correct by one. That is, we subtract 1 from the value if we need to change it from odd to even or vice versa. We don&#39;t want any negative numbers, so if we need to change any of the  0 values, we add 1 instead.</p><p>我们只是简单地遍历二进制字符串和像素以及“凸点”。每个不正确的值都不能以1校正。也就是说，如果需要将其从奇数更改为偶数，反之亦然，则从值中减去1。我们不希望有任何负数，因此，如果需要更改0个值中的任何一个，则改为添加1。</p><p>  We now have all the image data, including the encoded message but it is still just a list of pixels. Let&#39;s add a function that will compile our pixels back into a PNG image.</p><p>  现在，我们拥有了所有图像数据，包括编码后的消息，但它仍然只是像素列表。让我们添加一个将像素重新编译为PNG图像的函数。</p><p>   The above function takes the array  pixels and uses the  png module to write these to a brand new  .png file.</p><p>   上面的函数获取数组像素，并使用png模块将其写入到全新的.png文件中。</p><p> Play around with these functions to make sure you understand how they work. Before we write some wrapper code to actually use these, we&#39;re going to do everything backwards so that we can also extract hidden messages from previously encoded PNG files.</p><p> 尝试使用这些功能，以确保您了解它们的工作原理。在编写一些包装代码以实际使用它们之前，我们将向后进行所有操作，以便我们还可以从以前编码的PNG文件中提取隐藏的消息。</p><p>  First we need a function that can turn a binary string back into readable text. As before, we&#39;ll go via base64 for better compatability. Add the following function to the bottom of the  main.py file.</p><p>  首先，我们需要一个可以将二进制字符串转换回可读文本的函数。和以前一样，我们将通过base64获得更好的兼容性。将以下函数添加到main.py文件的底部。</p><p> def decode _message_from_bytestring( bytestring): bytestring = bytestring.split(ENDOFMESSAGE) [ 0] message =  int(bytestring,  2). to _bytes( len( bytestring)  // 8, byteorder=&#39;big&#39;) message = base64.decodebytes(message).decode( &#34;utf8&#34;) return message</p><p> def解码_message_from_bytestring（字节串）：字节串=字节串.split（ENDOFMESSAGE）[0]消息= int（字节串，2）。到_bytes（len（bytestring）// 8，byteorder =＆＃39; big＆＃39;）message = base64.decodebytes（message）.decode（＆＃34; utf8＆＃34;）返回消息</p><p> Remember how we added a special  ENDOFMESSAGE delimiter above? Here we first split our string on that so we don&#39;t look for text in random data (pixels from the unmodified part of the image) and then go backwards through our encoding pipe: first to base64 and then to text.</p><p> 还记得我们如何在上面添加特殊的ENDOFMESSAGE分隔符吗？在这里，我们首先将字符串拆分为字符串，这样我们就不会在随机数据中寻找文本（来自图像未修改部分的像素），然后向后遍历编码管道：首先到达base64，然后再到达文本。 </p><p> We also need a way to extract the bytestring from an image. Add the following function to  main.py to do this.</p><p>我们还需要一种从图像中提取字节串的方法。将以下函数添加到main.py中以执行此操作。</p><p> def decode_pixels( pixels): bytestring = []  for row in  pixels:  for c in row: bytestring. append( str(c %  2)) bytestring =  &#39;&#39;. join(bytestring) message = decode_message_from_bytestring(bytestring)  return message</p><p> def encode_pixels（像素）：bytestring = []对于像素行：对于c行：字节字符串。 append（str（c％2））字节串=＆＃39;＆＃39;。 join（bytestring）消息=解码_消息_from_bytestring（bytestring）返回消息</p><p> Once again, this is just the reverse of what we did before. We grab the remainder of each value to get  1 for each odd value and  0 for each even one and keep them in a string. We then call our decode function to get the plaintext.</p><p> 再一次，这只是我们之前所做的相反。我们获取每个值的其余部分，以使每个奇数获得1，为每个偶数获得0，并将其保留在字符串中。然后，我们调用解码函数以获取纯文本。</p><p> That&#39;s it for our encoding and decoding functions; next we&#39;ll put everything together in our  main() function.</p><p> 这就是我们的编码和解码功能；接下来，我们将所有内容放到main（）函数中。</p><p>  At this point, we could create a web application with a UI for people to add text to their images. Given the fact that people who want to do steganography probably won&#39;t trust a web application with their data, we&#39;ll rather create a command line application that people can run on their own machines.</p><p>  在这一点上，我们可以创建一个带有UI的Web应用程序，以便人们将文本添加到他们的图像中。考虑到想要进行隐写术的人们可能不会信任其数据的Web应用程序，我们宁愿创建一个命令行应用程序，使人们可以在自己的计算机上运行该应用程序。</p><p>  =  &#34;&#34;&#34;Welcome to basic steganography. Please choose:1. To encode a message into an image2. To decode an image into a messageq. To exit&#34;&#34;&#34;</p><p>  =＆＃34;＆＃34;欢迎使用基本隐写术。请选择：1。将消息编码为图像2。将图像解码为消息q。退出＆＃34;＆＃34;＆＃34;</p><p> Now let&#39;s write the  main() function that puts it all together. Add the following to the end of the  main.py file.</p><p> 现在，让我们编写将所有内容组合在一起的main（）函数。将以下内容添加到main.py文件的末尾。 </p><p> def main (): print(PROMPT) user_inp =  &#34;&#34;  while user_inp not  in ( &#34;1&#34;,  &#34;2&#34;,  &#34;q&#34;): user_inp = input( &#34;Your choice: &#34;)  if user_inp  ==  &#34;1&#34;: in_image = input( &#34;Please enter filename of existing PNG image: &#34;) in_message = input( &#34;Please enter the message to encode: &#34;) print( &#34;-ENCODING-&#34;) pixels = get _pixels_from_image( in_image) bytestring = encode _message_as_bytestring( in_message) epixels = encode _pixels_with_message( pixels,  bytestring) write _pixels_to_image( epixels,  in_image +  &#34;-enc.png&#34;) elif user_inp  ==  &#34;2&#34;: in_image = input( &#34;Please enter the filename of an existing PNG image: &#34;) print( &#34;-DECODING-&#34;) pixels = get _pixels_from_image( in_image) print(decode _pixels( pixels)) if __name__  ==  &#34;__main__&#34;: main ()</p><p>def main（）：print（PROMPT）user_inp =＆＃34;＆＃34;而user_inp不在（＆＃34; 1＆＃34 ;、＆＃34; 2＆＃34 ;、＆＃34; q＆＃34;）中：user_inp = input（＆＃34;您的选择：＆＃34;）如果user_inp ==＆＃34; 1＆＃34 ;： in_image =输入（＆＃34;请输入现有PNG图像的文件名：＆＃34;）in_message =输入（＆＃34;请输入要编码的消息：＆＃ 34;）print（＆＃34; -ENCODING-＆＃34;）像素=获取_pixels_from_image（in_image）字节字符串=编码_message_as_bytestring（in_message）epixels =编码_pixels_with_message（像素，字节字符串）写入_pixels_to_image（epixels，in_image + ; -enc.png＆＃34;）elif user_inp ==＆＃34; 2＆＃34 ;: in_image = input（＆＃34;请输入现有PNG图像的文件名：＆＃34;）print（＆＃34 ; -DECODING-＆＃34;）像素=如果__name__ ==＆＃34; __ main __＆＃34;则获得_pixels_from_image（in_image）print（解码_pixels（pixel））：main（）</p><p> The  main() function above creates a prompt flow for the user to interact with the program. Depending on the input from the user, the program will call the relevant functions in order to either encode or decode a message. We also included a  q for the user to close the program.</p><p> 上面的main（）函数为用户创建了与程序交互的提示流。取决于用户的输入，程序将调用相关功能以对消息进行编码或解码。我们还为用户提供了一个q来关闭程序。</p><p>  If you have followed along you&#39;ll have your own repl to expand; if not you can fork  our repl and work from there or test it out below.</p><p>  如果您一直遵循，您将有自己的代表进行扩展；如果不是，您可以派遣我们的代表并从那里进行工作或在下面进行测试。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://docs.repl.it/tutorials/13-steganography">https://docs.repl.it/tutorials/13-steganography</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/messages/">#messages</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/像素/">#像素</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>