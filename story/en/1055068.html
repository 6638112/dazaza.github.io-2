<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于铁锈膨胀的想法（2019） Thoughts on Rust bloat (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Thoughts on Rust bloat (2019)<br/>关于铁锈膨胀的想法（2019） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 00:30:15</div><div class="page_narrow text-break page_content"><p>I’m about to accept a  PR that will increase druid’s compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.</p><p>我即将接受一个将增加德鲁伊的编译时间约为3x，其可执行大小几乎2倍。在这种情况下，我认为权衡是值得的（如果没有本地化，GUI工具包是严格的玩具），但膨胀让我不开心，我认为铁锈生态系统有改善的余地。</p><p>  For me, bloat in Rust is mostly about compile times and executable size. Compile time is on the  top 10 list of bad things about the Rust development experience, but to some extent it’s under the developer’s control, especially by choosing whether or not to take dependencies on bloated crates.</p><p>  对我来说，融资的生锈主要是关于编译时和可执行的大小。编译时间是在锈病发展经验的十大坏事列表中，但在某种程度上它是在开发人员的控制下，尤其是选择是否在臃肿的板条符合依赖性。</p><p> Bloat is an endemic problem in software, but there are a few things that make it a particular challenge for Rust:</p><p> 膨胀是软件中的流行问题，但有一些事情使其成为生锈的特殊挑战：</p><p>  One of the subtler ways compile times affect the experience is in tools like RLS.</p><p>  其中一个编译时间影响体验的彩色方式是RLS等工具。</p><p> It’s going to vary from person to person, but I personally do care a lot. One of my hopes for xi-editor is that the core would be lightweight, especially as we could factor out concerns like UI. However, the release binary is now 5.9M (release build, Windows, and doesn’t include syntax coloring, which is an additional 2.1M). I’ve done a bunch of other things across the Rust ecosystem to reduce bloat, and I’ll brag a bit about that in this post.</p><p> 它将与人的人有所不同，但我个人会照顾很多。我对XI-Editor的希望之一是核心将是轻量级的，特别是我们可以根据UI的疑虑。但是，释放二进制文件现在是5.9m（发布构建，窗口，并且不包含语法着色，即额外的2.1M）。我在锈病生态系统上做了一堆其他事情来减少臃肿，我会在这篇文章中吹嘘一点。</p><p>  Of course, the reason why I’m considering such a huge jump in compile times on druid is that I want localization, an important and complex feature. Doing it right requires quite a bit of logic around locale matching, Unicode, and natural language processing (such as plural rules). I don’t  expect a tiny crate for this.</p><p>  当然，我考虑在德鲁伊上编译时跳跃的原因是我想要本地化，一个重要和复杂的功能。正确执行它需要相当多的逻辑围绕语言环境匹配，Unicode和自然语言处理（例如复数规则）。我不指望这个微小的箱子。</p><p> One recent case we saw a similar tradeoff was the observation that the  unicase dep adds 50k to the binary size for pulldown-cmark. In this case, the  CommonMark spec demands Unicode case-folding, and without that, it’s no longer complying with the standard. I understand the temptation to cut this corner, but I think having versions out there that are not spec-compliant is a bad thing, especially unfriendly to the majority of people in the world whose native language is other than English.</p><p> 最近的一个案例我们看到了类似的权衡是观察到unicase Dep将50K增加到下拉卡马的二元尺寸。在这种情况下，Complarmarm规范要求Unicode折叠，而且没有它，它不再符合标准。我理解削减这个角落的诱惑，但我认为在那里没有规范符合规范的版本是一件坏事，特别是对世界上大多数人的母语是英语之外的大多数人。 </p><p> So, it’s important not to confuse lean engineering with a lack of important features. I would say bloat is unneeded resource consumption beyond what’s necessary to meet the requirements. Unicode and internationalization are a particularly contentious point, both because they actually do require code and data to get right, but also because there’s a ton of potential for bloat.</p><p>因此，重要的是不要将精益工程混淆，缺乏重要的功能。我会说臃肿是不需要的资源消耗，超出了满足要求的必要条件。 Unicode和International化是一个特别有争议的点，因为它们实际上确实需要代码和数据来实现正确，但也因为膨胀的潜力也是如此。</p><p>  I would apply a higher standard to “foundational” crates, which are intended to be used by most Rust applications that need the functionality. Bloat in those is a reason  not to use the dependency, or to fragment the ecosystem into different solutions depending on needs and tolerance for bloat.</p><p>  我将申请更高的标准“基础”板条箱，旨在由需要功能的大多数生锈应用程序使用。在那些中膨胀是一种不使用依赖的原因，或者根据膨胀的需求和容忍来将生态系统分段为不同的解决方案。</p><p> I think a particular risk are crates providing generally useful features, ones that would definitely make the cut in a “batteries included” language. Some of these (bitflags, lazy_static, cfg-if, etc) are not very heavy, and provide obvious benefit, especially to make the API more humane. For others (rental, failure), the cost is higher and I would generally recommend not using them in foundational crates. But for your own app, if you like them, sure. I believe rental might be the most expensive transitive dependency for fluent, as I find it takes 27.3s (debug, Windows; 53.2s for release) for the crate alone.</p><p> 我认为特殊风险是提供一般有用的特征的条箱，肯定会使切割的“包括”语言。其中一些（bitflags，lazy_static，cfg-if等）不是很重，并提供明显的好处，特别是使API更加人性化。对于其他人（租赁，失败），成本更高，我普遍建议不要在基础箱中使用它们。但是对于你自己的应用程序，如果你喜欢他们，肯定。我相信租赁可能是流利最昂贵的传递依赖性，因为我发现它需要27.3秒（调试，窗户;释放53.2秒）。</p><p> I’m concerned about bloat in  gfx-rs - about a minute for a debug build, and about 3M (Windows, quad example). For this reason (and stability and documentation), I’m leaning towards making the GPU renderers for piet use the underlying graphics APIs directly rather than using this abstraction layer. I’ve found similar patterns with other “wrapper” crates, including  direct2d. But here the tradeoffs are complex.</p><p> 我担心在GFX-RS中膨胀 - 大约一分钟拍摄调试构建，大约3米（Windows，Quad示例）。出于这个原因（和稳定性和文档），我倾向于让PIET的GPU渲染器直接使用底层图形API而不是使用此抽象层。我发现了类似的模式与其他“包装器”板条箱，包括Direct2D。但这里的权衡很复杂。</p><p> [Update added afterwards re gfx-rs: In response to this post, the gfx-rs team very quickly landed major improvements to compile time, and kvark also pointed out that my methodology of using the quad example is not valid because it pulls in a bunch of other dependencies that not actually needed to run gfx-rs. I’m happy that there’s been attention to this, and a lot of my concerns are alleviated, so will be looking much more closely at using gfx-rs for future GPU work. I have noticed compile time impact from other wrapper crates, so the general advice to take a careful look at these still stands.]</p><p> [之后添加的更新Re GFX-RS：响应这篇文章，GFX-RS团队非常快速地降落了编译时间的重大改进，而Kvark也指出，我的使用Quad示例的方法无效，因为它会拉到a束实际上不需要运行GFX-R的其他依赖项。我很高兴能够注意到这一点，我很担心很大，所以将在使用GFX-R款中仔细观察未来的GPU工作。我注意到了从其他包装板箱的编译时间影响，因此普通建议仔细看看这些仍然存在。]</p><p> I don’t have hard numbers yet, but I’ve found that the  rust-objc macros produce quite bloated code, on the order of 1.5k per method invocation. This is leading me to consider rewriting the macOS platform binding code in Objective-C directly (using C as the common FFI is not too bad), rather than relying on Rust code that uses the dynamic Objective-C runtime. I expect bloat here to affect a fairly wide range of code that calls into the macOS (and iOS) platform, so it would be a good topic to investigate more deeply.</p><p> 我还没有硬度，但我发现Rust-Objc宏产生了相当臃肿的代码，每种方法调用1.5k的顺序。这导致我考虑直接在Objective-C中重写麦斯卡斯平原绑定代码（使用C作为常见的FFI不太糟糕），而不是依赖于使用动态目标-C运行时的生锈代码。我希望在这里膨胀，以影响调用麦斯科斯乐队（和iOS）平台的相当广泛的代码，因此可以更深入地调查这是一个好主题。</p><p>  I sometimes hear that it’s ok to depend on commonly-used crates, because their cost is amortized among the various users that share them. I’m not convinced, for a variety of reasons. For one, it’s common that you get different versions anyway (the  Zola build currently has two versions each of unicase, parking_lot, parking_lot_core, crossbeam-deque, toml, derive_more, lock_api, scopeguard, and winapi). Second, if generics are used heavily (see below), there’ll likely be code duplication anyway.</p><p>  我有时会听到依靠常用的箱子，因为他们的成本在分享它们的各种用户中摊销。由于各种原因，我不相信。对于一个，常见的是，无论如何，您得到了不同的版本其次，如果泛型使用大量（见下文），则可能是代码复制。 </p><p> That said, for stuff like Unicode data, it is quite important that there as few copies as possible in the binary. The best choice is crates engineered to be lean.</p><p>也就是说，对于像Unicode数据等的东西，它非常重要，即在二进制中可以很少有副本。最佳选择是倾斜的板条箱。</p><p>  A particularly contentious question is proc macros. The support crates for these (syn and quote) take maybe 10s to compile, and don’t directly impact executable size. It’s a major boost to the expressivity of the Rust language, and we’ll likely use them in druid, though have been discussing making them optional.</p><p>  一个特别有争议的问题是proc宏。用于这些（SYN和CAITE）的支持箱需要10s来编译，并且不会直接影响可执行大小。它是对生锈语言表达性的重大推动，我们可能会在德鲁伊中使用它们，尽管已经讨论了使它们是可选的。</p><p> What I’d personally like to see is proc macros stabilize more and then be adopted into the language.</p><p> 我个人喜欢看到的是proc宏稳定更多，然后被采用语言。</p><p>  Digging into xi-editor, the biggest single source of bloat is serde, and in general the fact that it serializes everything into JSON messages. This was something of an experiment, and in retrospect I would say one of the things I’m most unhappy about. It seems that efficient serialization is not a solved problem yet. [Note also that JSON serialization is  extremely slow in Swift]</p><p>  挖掘Xi-Editor，最大的单一膨胀源是SERDE，一般来说它是它将所有内容序列化为JSON消息。这是一个实验的东西，回顾我会说我最不开心的事情。似乎有效的序列化尚未解决问题。 [注意，JSON序列化在SWIFT中非常慢]</p><p>  The  particular reason serde is so bloated is that it monomorphizes everything. There are alternatives;  miniserde in particular yields smaller binaries and compile times by using dynamic dispatch (trait objects) in place of monomorphization. But it has other limitations and so hasn’t caught on yet.</p><p>  Serde如此臃肿的特定原因是它是单一的一切。有替代方案;特别是通过使用动态调度（特质物体）代替单数化的副经内较小的二进制文件和编译时。但它有其他限制，所以还没有抓住。</p><p> In general, overuse of polymorphism is a leading cause of bloat. For example, resvg  switched from lyon to kurbo  for this reason [Note added: RazrFalcon  points out that the big contribution to lyon compile times is proc macros, not polymorphism, and that’s  since been fixed]. We don’t adopt the lyon / euclid ecosystem, also for this reason, which is something of a shame because now there’s more fragmentation. When working on  kurbo, I did experiments indicating there was no real benefit to allowing floating point types other than  f64, so just decided that would be the type for coordinates. I’m happy with this choice.</p><p> 一般来说，过度使用多态性是膨胀的主要原因。例如，Resvg于此原因从Lyon转换为Kurbo：Razrfalcon指出，对Lyon编译时的大贡献是促进宏观，而不是多态性，而且已修复。我们没有采用Lyon / Euclid生态系统，也是为了这个原因，这是一种耻辱，因为现在有更多的碎片。在KURBO工作时，我做了表明允许除F64以外的浮点类型没有真正的好处，因此刚刚决定是坐标的类型。我对这个选择感到满意。</p><p>  For a variety of reasons, async code is considerably slower to compile than corresponding sync code, though the compiler team has been  making great progress. Even though async/await is the shiny new feature, it’s important to realize that old-fashioned sync code is still better in a lot of cases. Sure, if you’re writing high-scale Internet servers, you need async, but there are a lot of other cases.</p><p>  出于各种原因，虽然编译团队一直在取得巨大进展，但Async代码比相应的同步代码相当慢得多。尽管异步/等待是闪亮的新功能，但重要的是意识到老式的同步代码在很多情况下仍然更好。当然，如果您正在编写大型互联网服务器，则需要异步，但有很多其他案例。 </p><p> I’ll pick on  Zola for this one. A release build is over 9 minutes and 15M in size. (Debug builds are about twice as fast but 3-5x bigger). Watching the compile (over 400 crates total!) it’s clear that its web serving (actix based) accounts for a lot of that, pulling in a big chunk of the tokio ecosystem as well. For just previewing static websites built with the tool, it might be overkill. That said, for this particular application perhaps bloat is not as important, and there are benefits to using a popular, featureful web serving framework.</p><p>我会选择Zola这一点。释放构建尺寸超过9分钟，15米。 （调试构建大约是快速但3-5倍更大的两倍）。观看编译（超过400个箱子总数！）很明显，它的网页服务（基于Actix的）占了很多，也占据了Tokio生态系统的大块。仅仅预览使用该工具构建的静态网站，它可能是矫枉过正。也就是说，对于这个特定的应用，可能膨胀并不是重要的，并且有利于使用流行的，具有一系列网络服务框架的好处。</p><p> As a result, I’ve chosen  not to use async in druid, but rather a simpler, single-threaded approach, even though async approaches have been  proposed.</p><p> 因此，我选择不使用德国的异步，而是更简单，单线程方法，即使已经提出了异步方法。</p><p>  It’s common for a crate to have some core functionality, then other stuff that only some users will want. I think it’s a great idea to have optional dependencies. For example, xi-rope had the ability to serialize deltas to JSON because we used that in xi-editor, but that’s a very heavyweight dependency for people who just want an efficient data structure for large strings. So we  made that optional.</p><p>  一个箱子有一些核心功能，那么只有一些用户想要的其他东西是常见的。我认为拥有可选依赖性是一个很好的主意。例如，Xi-Rope有能力将Deltas序列化为JSON，因为我们在XI-Editor中使用它，但这是一个非常重量级依赖，只需要一个用于大字符串的高效数据结构的人。所以我们做了那个可选的。</p><p> An alternative is to fragment the crate into finer grains;  rand is a particular offender here, as it’s not uncommon to see 10 subcrates in a build. We’ve found that having lots of subcrates often makes life harder for users because of the increased coordination work making sure versions are compatible.</p><p> 另一种方法是将箱子分割成更精细的谷物;兰特在这里是一个特定的罪犯，因为它在构建中没有少见的是10个副押出。我们发现有很多委员会通常会使用户的生活更加困难，因为肯定版本兼容。</p><p>  Another crate that often shows up in Rust builds is  phf, an implementation of perfect hashing. That’s often a great idea and what you want in your binaries, but it also accounts for ~13s of compile time when using the macro version (again bringing in two separate copies of quote and syn). [Note added: sfackler points out that you can use phf-codegen to generate Rust source and check that into your repos.]</p><p>  另一个经常出现在铁锈构建中的箱子是phf，这是完美散列的实施。这通常是一个伟大的主意，你想要在二进制文件中，但它也在使用宏版本时〜13岁的编译时间（再次引入两个单独的报价副本和SYN）。 [注释添加：SFackler指出，您可以使用PHF-Codegen生成生锈源并检查到您的repos中。]</p><p> For optimizing compile times in  unicode-normalization, I decided to build the hash tables using a custom tool, and check those into the repo. That way, the work is done only when the data actually changes (about once a year, as Unicode revs), as opposed to every single compile. I’m proud of this work, as it improved the compile time for unicode-normalization by about 3x, and I do consider that an important foundational crate.</p><p> 为了优化Unicode-ranalization中的编译时，我决定使用自定义工具构建哈希表，并检查那些repo。这样，只有当数据实际上更改时（大约一年，作为Unicode Revs）而不是每一次编译时，都只能完成工作。我为这项工作感到自豪，因为它改善了大约3倍的Unicode-ranalization的编译时间，我认为这是一个重要的基本箱。</p><p>  Compile time and executable size are aspects of performance (even though often not as visible as runtime speed), and  performance culture applies. Always measure, using tools like  cargo-bloat where appropriate, and keep track of regressions.</p><p>  编译时间和可执行大小是性能的方面（即使通常不像运行时速度可见），并且适用性能文化。始终衡量，在适当的情况下使用货物膨胀等工具，并跟踪回归。 </p><p> A good case study for cargo-bloat is  clap, though it’s still pretty heavyweight today (it accounts for about 1M of Zola’s debug build, measured on macOS).</p><p>对于货物膨胀的一个很好的案例研究是拍手，尽管今天它仍然非常重量级（它占了大约1米的Zola调试版本，在MacOS上测量）。</p><p> There’s also an effort to  analyze binary sizes more systematically. I applaud such efforts and would love it if they were even more visible. Ideally,  crates.io would include some kind of bloat report along with its other metadata, although using fully automated tools has limitations (for example, a “hello world” example using clap might be pretty modest, but one with hundreds of options might be huge).</p><p> 还努力分析二进制规模更系统地。我赞赏这样的努力，如果他们更加明显，就会喜欢它。理想情况下，箱子将包括某种膨胀的报告以及其他元数据，尽管使用完全自动化工具有限制（例如，使用CLAP的“Hello World”示例可能是非常谦虚的，但可能有数百个选项巨大的）。</p><p> Once you accept bloat, it’s very hard to claw it back. If your project has multi-minute compiles, people won’t even notice a 10s regression in compile time. Then these pile up, and it gets harder and harder to motivate the work to reduce bloat, because each second gained in compile time becomes such a small fraction of the total.</p><p> 一旦接受膨胀，就很难抓住它。如果您的项目编译多分钟，人们甚至不会在编译时注意到10秒的回归。然后这些堆积起来，它变得越来越难以激励减少臃肿的工作，因为每秒在编译时获得的每秒都变得如此小的总数。</p><p>  As druid develops into a real GUI, I’ll be facing many more of these kinds of choices, and both compile times and executable sizes will inevitably get larger. But avoiding bloat is just another place to apply engineering skill. In writing this blog post, I’m hoping to raise awareness of the issue, give useful tips, and enlist the help of the community to keep the Rust ecosystem as bloat-free as possible.</p><p>  随着德鲁伊开发成真正的GUI，我将面临更多这些选择，并且编译时代和可执行尺寸都将不可避免地变得更大。但避免臃肿只是另一个应用工程技能的地方。在撰写本博客文章时，我希望提高对问题的认识，给予有用的提示，并征求社区的帮助，使防锈生态系统尽可能膨胀。</p><p> As with all engineering, it’s a matter of tradeoffs. Which is more important for druid, having fast compiles, or being on board with the abundance of features provided by the Rust ecosystem such as fluent? That doesn’t have an obvious answer, so I intend to mostly listen to feedback from users and other developers.</p><p> 与所有工程一样，这是权衡问题。哪个对德鲁伊更重要的是，快速编译，或者在船上携带丰富的功能，例如流利的生态系统提供的丰富功能？这没有明显的答案，所以我打算大多倾听来自用户和其他开发人员的反馈。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html">https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/膨胀/">#膨胀</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>