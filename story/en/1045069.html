<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>再次基于0索引和基于1索引 Again on 0-based vs. 1-based indexing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Again on 0-based vs. 1-based indexing<br/>再次基于0索引和基于1索引 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-19 18:02:15</div><div class="page_narrow text-break page_content"><p>André Garzia made a nice blog post called  “Lua, a misunderstood language” recently, and unfortunately (but perhaps unsurprisingly) a bulk of HN comments on it was about the age-old 0-based vs. 1-based indexing debate. You see, Lua uses 1-based indexing, and lots of programmers claimed this is unnatural because “every other language out there” uses 0-based indexing.</p><p>最近，AndréGarzia发表了一篇不错的博客文章，名为“ Lua，一种被误解的语言”，不幸的是（但不足为奇），HN对此发表了大量评论，涉及的是基于0和1的古老索引问题。您会看到，Lua使用基于1的索引，许多程序员声称这是不自然的，因为“其他语言”都使用基于0的索引。</p><p> I’ll brush aside quickly the fact that this is not true — 1-based indexing has a long history, all the way from Fortran, COBOL, Pascal, Ada, Smalltalk, etc. — and I’ll grant that the vast majority of popular languages in the industry nowadays are 0-based. So, let’s avoid the popularity contest and address the claim that 0-based indexing is “inherently better”, or worse, “more natural”.</p><p> 我将很快撇开事实并非如此-基于1的索引具有悠久的历史，从Fortran，COBOL，Pascal，Ada，Smalltalk等到现在都如此-我将承认绝大多数当今业界流行的语言是从0开始的。因此，让我们避免进行人气竞赛，并提出基于0的索引“本来就更好”，或更糟糕的是“更自然”的说法。</p><p> It really shows how conditioned an entire community can be when they find the statement “given a list x, the first item in x is x[1], the second item in x is x[2]” to be unnatural. :) And in fact this is a somewhat scary thought about groupthink outside of programming even!</p><p> 它确实显示了当整个社区发现陈述“给定列表x，x中的第一项是x [1]，x中第二项是x [2]”时，其条件是多么不自然。 :)实际上，即使在编程之外，这对于groupthink还是有些令人恐惧的想法！</p><p> I guess I shouldn’t be surprised by groupthink coming from HN, but it was also alarming how a bunch of the HN comments gave nearly identical responses, all linking to the same  writing by Dijkstra defending 0-based indexing as inherently better, as an implicit  Appeal to Authority. (Well, I did read Dijkstra’s note years ago and wasn’t particularly convinced by it — not the first time I  disagree with Dijkstra, by the way — but if we’re giving it extra weight for coming from one of our field’s legends, then the list of 1-based languages above gives me a much longer list of legends who disagree — not to mention standard mathematical notation which is rooted on a much greater history.)</p><p> 我想我应该不会对来自HN的groupthink感到惊讶，但是这也令人震惊，一堆HN注释如何给出几乎相同的响应，所有这些都与Dijkstra的同一篇文章相联系，从而捍卫了基于0的索引在本质上更好。向当局隐含上诉。 （好吧，我几年前确实读过Dijkstra的笔记，并没有对此特别信服-顺便说一句，这不是我第一次不同意Dijkstra-但是，如果我们给予它以来自该领域传奇人物的额外权重，然后上面基于1的语言的列表为我提供了更长的不同意见的传说列表-更不用说植根于更悠久历史的标准数学符号了。）</p><p> I think that a better thought, instead of trying to defend 1-based indexing, is to try to answer the question “why is 0-based indexing even a thing in programming languages?” — of course, nowadays the number one reason is tradition and familiarity given other popular languages, and I think even proponents of 0-based indexing would agree, in spite of the fact that most of them wouldn’t even notice that they don’t call it a number zero reason. But if the main reason for something is tradition, then it’s important to know how did the tradition start. It wasn’t with Dijkstra.</p><p> 我认为，一个更好的想法不是尝试捍卫基于1的索引，而是尝试回答以下问题：“为什么基于0的索引甚至在编程语言中也是如此？” -当然，当今的首要原因是传统和熟悉其他流行的语言，而且我认为即使是基于0的索引的支持者也同意，尽管事实上大多数人甚至都不会注意到它们没有称之为零号原因。但是，如果某件事的主要原因是传统，那么了解传统是如何开始的就很重要。迪克斯特拉不是。</p><p> C is pointed as the popularizer of this style. C’s well-known history points to BCPL by Martin Richards as its predecessor, a language  designed to be simple to write a compiler for. One of the simplifications carried over to C: array indexing and pointer offsets were mashed together.</p><p> C被指出是这种风格的普及者。 C的著名历史指出，马丁·理查兹（Martin Richards）是BCPL的前身，该语言旨在简化编写编译器的过程。 C语言的简化方法之一是：将数组索引和指针偏移混在一起。</p><p> It’s telling how, whenever people go into non-Appeal-to-Authority arguments to defend 0-based indexes (including Dijkstra himself), people start talking about offsets. That’s because offsets  are naturally 0-based, being a relative measurement: here + 0 = here; here + 1 meter = 1 meter away from here, and so on. Just like numeric indexes are identifiers for elements of an ordered object, and thus use the 1-based ordinal numbers: the first card in the deck, the second in the deck, etc.</p><p> 它告诉人们，每当人们进入非上诉至权威论点来捍卫基于0的索引（包括Dijkstra本人）时，人们如何开始谈论偏移量。那是因为偏移量自然是从0开始的，是相对的量度：这里+ 0 =这里；这里+ 1米=距离这里1米，依此类推。就像数字索引是有序对象的元素的标识符一样，因此使用基于1的序数：卡座中的第一个卡，卡座中的第二个卡，依此类推。 </p><p> BCPL, back in 1967, made a shortcut and made it so that  p[i] (an index) was equal to  p + i an offset. C inherited that. And nowadays, all arguments that say that indexes should be 0-based are actually arguments that offsets are 0-based, indexes are offsets, therefore indexes should be 0-based. That’s a circular argument. Even Dijkstra’s argument also starts with the calculation of differences, i.e., doing “pointer arithmetic” (offsets), not indexing.</p><p>早在1967年，BCPL就做了一个捷径，使p [i]（索引）等于p + i的偏移量。 C继承了这一点。如今，所有说索引应基于0的参数实际上都是偏移量基于0的参数，索引是偏移量，因此索引应基于0的参数。这是一个循环的论点。甚至Dijkstra的论点也从差的计算开始，即进行“指针算术”（偏移），而不是建立索引。</p><p> Nowadays, people just repeat these arguments over and over, because “C won”, and now that tiny compiler-writing shortcut from the 1960s appears in Java, C#, Python, Perl, PHP, JavaScript and so on, even though none of these languages even have pointer arithmetic.</p><p> 如今，人们只是一遍又一遍地重复这些论点，因为“ C胜了”，而现在，1960年代微小的编译器编写捷径出现在Java，C＃，Python，Perl，PHP，JavaScript等中，即使这些都不用语言甚至具有指针算法。</p><p> What’s funny to think about is that if instead C had  not done that and used 1-based indexing, people today would certainly be claiming how C is superior for providing  both 1-based indexing with  p[i] and 0-based pointer offsets with  p + i. I can easily visualize how people would argue that was the best design because there are always scenarios where one leads to more natural expressions than the other (similar to having both  x++ and  ++x), and how newcomers getting them mixed up were clearly not suited for the subtleties of low-level programming in C, and should be instead using simpler languages with garbage collection and without 0-based pointer arithmetic.</p><p> 有趣的是，如果C没有这样做，而是使用基于1的索引，那么今天的人们肯定会声称C在提供基于1的索引和p [i]以及基于0的指针偏移量方面具有优势。 p +我我可以轻松地想象人们如何认为这是最好的设计，因为在某些情况下，一个场景会比另一个场景产生更自然的表达（类似于同时使用x ++和++ x），而新手如何将它们混在一起显然不是适用于C语言中的底层编程的精妙之处，应该使用带有垃圾回收且不基于0的指针算法的简单语言。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hisham.hm/2021/01/18/again-on-0-based-vs-1-based-indexing/">https://hisham.hm/2021/01/18/again-on-0-based-vs-1-based-indexing/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/索引/">#索引</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>