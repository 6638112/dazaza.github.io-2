<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>提交是不差异的快照 Commits are snapshots not diffs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Commits are snapshots not diffs<br/>提交是不差异的快照 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 02:59:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/465c541dab2f455f5a5b34bef422866d.png"><img src="http://img2.diglog.com/img/2021/4/465c541dab2f455f5a5b34bef422866d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Git  has a reputation for  being confusing. Users stumble over terminology and phrasing that misguides their expectations. This is most apparent in commands that “rewrite history” such as  git cherry-pick or  git rebase. In my experience, the root cause of this confusion is an interpretation of commits as  diffs that can be shuffled around. However,  commits are snapshots, not diffs!</p><p>Git令人困惑的声誉。用户绊倒术语和措辞误导他们的期望。这在命令中最明显的是“重写历史记录”，例如Git Cherry-Pick或Git Rebase。在我的经验中，这种混乱的根本原因是对可以随身携带的罪行的解释。但是，提交是快照，而不是差异！</p><p> I believe that Git becomes understandable if we peel back the curtain and look at how Git stores your repository data. After we investigate this model, we’ll explore how this new perspective helps us understand commands like  git cherry-pick and  git rebase.</p><p> 如果我们剥离窗帘并查看Git如何存储您的存储库数据，我认为Git会变得可以理解。在我们调查此模型后，我们将探讨新的视角如何帮助我们了解Git Cherry-Pick和Git Rebase等命令。</p><p> If you want to go  really deep, you should read  the Git Internals chapter of the Pro Git book.</p><p> 如果你想真的很深，你应该阅读Pro Git Book的Git Internals章节。</p><p> I’ll be using the   git/git repository checked out at  v2.29.2 as an example. Follow along with my command-line examples for extra practice.</p><p> 我将使用在v2.29.2签出的git / git存储库作为一个例子。跟随我的命令行示例以获取额外的练习。</p><p>  The most important part to know about Git objects is that Git references each by its  object ID (OID for short), providing a unique name for the object. We will use  the  git rev-parse &lt;ref&gt; command to discover these OIDs. Each object is essentially a plain-text file and we can examine its contents using  the  git cat-file -p &lt;oid&gt; command.</p><p>  要了解Git对象的最重要部分是GIT由其对象ID（oid for short）引用，为对象提供唯一名称。我们将使用Git Rev-parse＆lt; Ref＆gt;命令发现这些OID。每个对象都基本上是一个纯文本文件，我们可以使用git cat-file -p -p＆lt; oid＆gt来检查其内容。命令。</p><p> You might also be used to seeing OIDs given as a shorter hex string. This string is given as something long enough that only one object in the repository has an OID that matches that abbreviation. If we request the type of an object using an abbreviated OID that is too short, then we will see the list of OIDs that match</p><p> 您也可以用于看到作为较短的十六进制字符串给出的OID。此字符串作为足够长的东西给出了存储库中只有一个对象的OID匹配该缩写。如果我们使用太短的缩写oid请求对象的类型，那么我们将看到匹配的oid列表</p><p> $ git cat-file -t e0c03error: short SHA1 e0c03 is ambiguoushint: The candidates are:hint: e0c03f27484 commit 2016-10-26 - contrib/buildsystems: ignore irrelevant files in Generators/hint: e0c03653e72 treehint: e0c03c3eecc blobfatal: Not a valid object name e0c03</p><p> $ git cat-file -t e0c03error：short sha1 e0c03是模棱两可的：候选人是：提示：e0c03f27484提交2016-10-26  -  Contrib / Buildsystems：忽略生成器中的无关文件/提示：e0c03653e72 treehhint：e0c03c3eecc blobfatal：不是有效的对象名称e0c03. </p><p> What are these types:  blob,  tree, and  commit? Let’s start at the bottom and work our way up.</p><p>这些类型是什么：Blob，树和提交？让我们从底部开始工作。</p><p>  At the bottom of the object model,  blobs contain file contents. To discover the OID for a file at your current revision, run  git rev-parse HEAD:&lt;path&gt;. Then, use  git cat-file -p &lt;oid&gt; to find its contents.</p><p>  在对象模型的底部，BLOB包含文件内容。要在当前修订时发现文件的OID，请运行Git Rev-Parse头：＆lt; path＆gt ;.然后，使用git cat-file -p＆lt; oid＆gt;找到它的内容。</p><p> $ git rev-parse HEAD:README.mdeb8115e6b04814f0c37146bbe3dbc35f3e8992e0$ git cat-file -p eb8115e6b04814f0c37146bbe3dbc35f3e8992e0 | head -n 8[![Build status](https://github.com/git/git/workflows/CI/PR/badge.png)](https://github.com/git/git/actions?query=branch%3Amaster+event%3Apush)Git - fast, scalable, distributed revision control system=========================================================Git is a fast, scalable, distributed revision control system with anunusually rich command set that provides both high-level operationsand full access to internals.</p><p> $ Git Rev-Parse头：Readme.mdeb8115e6b04814f0c37146bbe3dbc35f3e8992e0 $ git cat-file -p eb8115e6b04814f0c37146bbe3dbc35f3e8992e0 | head-n 8 [！[构建状态]（https://github.com/git/git/workflows/ci/pr/badge.png）]（https://github.com/git/git/actions?query =分支％3amaster +事件％3apush）Git  - 快速，可扩展，分布式修订控制系统=============================== ========================== git是一个快速，可扩展，分布式的修订控制系统，具有anunusipy富有的命令集，提供了高级运算和满访问内部。</p><p> If I edit the  README.md file on my disk, then  git status notices that the file has a recent modified time and hashes the contents. If the contents don’t match the current OID at  HEAD:README.md, then  git status reports the file as “modified on disk.” In this way, we can see if the file contents in the current working directory match the expected contents at  HEAD.</p><p> 如果我在磁盘上编辑README.MD文件，则GIT状态通知该文件具有最近修改的时间和哈希内容。如果内容与Head的当前OID不匹配：Readme.md，则Git Status将文件报告为“修改在磁盘上”。通过这种方式，我们可以看到当前工作目录中的文件内容是否与头部的预期内容匹配。</p><p>  Note that blobs contain file  contents, but not the file  names! The names come from Git’s representation of directories:  trees. A tree is an ordered list of path entries, paired with object types, file modes, and the OID for the object at that path. Subdirectories are also represented as trees, so trees can point to other trees!</p><p>  请注意，Blobs包含文件内容，但不是文件名！名称来自Git的目录表示：树木。树是路径条目的有序列表，与对象类型，文件模式和该路径处对象的OID配对。子目录也代表为树，所以树木可以指向其他树木！</p><p>  We will use diagrams to visualize how these objects are related. We use boxes for blobs and triangles for trees.</p><p>  我们将使用图表来可视化这些对象的相关方式。我们使用盒子和树木的三角形。</p><p> $ git rev-parse HEAD^{tree}75130889f941eceb57c6ceb95c6f28dfc83b609c$ git cat-file -p 75130889f941eceb57c6ceb95c6f28dfc83b609c | head -n 15100644 blob c2f5fe385af1bbc161f6c010bdcf0048ab6671ed .cirrus.yml100644 blob c592dda681fecfaa6bf64fb3f539eafaf4123ed8 .clang-format100644 blob f9d819623d832113014dd5d5366e8ee44ac9666a .editorconfig100644 blob b08a1416d86012134f823fe51443f498f4911909 .gitattributes040000 tree fbe854556a4ae3d5897e7b92a3eb8636bb08f031 .github100644 blob 6232d339247fae5fdaeffed77ae0bbe4176ab2de .gitignore100644 blob cbeebdab7a5e2c6afec338c3534930f569c90f63 .gitmodules100644 blob bde7aba756ea74c3af562874ab5c81a829e43c83 .mailmap100644 blob 05f3e3f8d79117c1d32bf5e433d0fd49de93125c .travis.yml100644 blob 5ba86d68459e61f87dae1332c7f2402860b4280c .tsan-suppressions100644 blob fc4645d5c08bd005238fc72cfa709495d8722e6a CODE_OF_CONDUCT.md100644 blob 536e55524db72bd2acf175208aef4f3dfc148d42 COPYING040000 tree a58410edddbdd133cca6b3322bebe4fb37be93fa Documentation100755 blob ca6ccb49866c595c80718d167e40cfad1ee7f376 GIT-VERSION-GEN100644 blob 9ba33e6a141a3906eb707dd11d1af4b0f8191a55 INSTALL</p><p> $ git rev-parse头^ {tree} 75130889f941ceb57c6ceb95c6f28dfc83b609c $ git cat-fire-p_ 75130889f941eCeb57c6ceb95c6f28dfc83b609c |头-n 15100644 BLOB c2f5fe385af1bbc161f6c010bdcf0048ab6671ed .cirrus.yml100644 BLOB c592dda681fecfaa6bf64fb3f539eafaf4123ed8 .clang-format100644 BLOB f9d819623d832113014dd5d5366e8ee44ac9666a .editorconfig100644斑点b08a1416d86012134f823fe51443f498f4911909 .gitattributes040000树fbe854556a4ae3d5897e7b92a3eb8636bb08f031 .github100644 BLOB 6232d339247fae5fdaeffed77ae0bbe4176ab2de .gitignore100644斑点cbeebdab7a5e2c6afec338c3534930f569c90f63 .gitmodules100644斑点bde7aba756ea74c3af562874ab5c81a829e43c83 .mailmap100644斑点05f3e3f8d79117c1d32bf5e433d0fd49de93125c .travis.yml100644斑点5ba86d68459e61f87dae1332c7f2402860b4280c .tsan -suppressions100644 BLOB fc4645d5c08bd005238fc72cfa709495d8722e6a CODE_OF_CONDUCT.md100644斑点536e55524db72bd2acf175208aef4f3dfc148d42 COPYING040000树a58410edddbdd133cca6b3322bebe4fb37be93fa Documentation100755 BLOB ca6ccb49866c595c80718d167e40cfad1ee7f376 GIT-VERSION-GEN100644 BLOB 9ba33e6a141a3906eb707dd11d1af4b0f8191a55 INSTALL </p><p> Trees provide names for each sub-item. Trees also include information such as Unix file permissions, object type ( blob or  tree), and OIDs for each entry. We cut the output to the top 15 entries, but we can use  grep to discover that this tree has a  README.md entry that points to our earlier blob OID.</p><p>树为每个子项提供名称。树还包括每个条目的UNIX文件权限，对象类型（BLOB或TREE）和OID等信息。我们将输出剪切到前15个条目，但我们可以使用Grep发现这棵树有一个readme.md条目，指向我们的早期Blob OID。</p><p>  Trees can point to blobs and other trees using these path entries. Keep in mind that those relationships are paired with path names, but we will not always show those names in our diagrams.</p><p>  树木可以使用这些路径条目指向Blob和其他树木。请记住，这些关系与路径名配对，但我们并不总是在我们的图表中显示这些名称。</p><p> The tree itself doesn’t know where it exists within the repository, that is the role of the objects pointing to the tree. The tree referenced by  &lt;ref&gt;^{tree} is a special tree: the  root tree. This designation is based on a special link from your  commits.</p><p> 树本身不知道存储库中存在的位置，这是指向树的对象的角色。由＆lt; ref＆gt; ^ {树}引用的树是一个特殊的树：根树。此名称基于您提交的特殊链接。</p><p>  A  commit is a snapshot in time. Each commit contains a pointer to its root tree, representing the state of the working directory at that time. The commit has a list of  parent commits corresponding to the previous snapshots. A commit with no parents is a  root commit and a commit with multiple parents is a  merge commit. Commits also contain metadata describing the snapshot such as author and committer (including name, email address, and date) and a commit message. The commit message is an opportunity for the commit author to describe the purpose of that commit with respect to the parents.</p><p>  提交是一个快照。每个提交都包含指向其根树的指针，表示当时的工作目录的状态。提交有与上一个快照对应的父级提交列表。没有父母的提交是一个root提交，并且具有多个父母的提交是合并提交。提交还包含描述快照（包括作者和提名（包括名称，电子邮件地址和日期）和提交消息的快照。提交消息是提交作者描述该提交关于父母的目的的机会。</p><p>  For example, the commit at  v2.29.2 in the Git repository describes that release, and is authored and committed by the Git maintainer.</p><p>  例如，GIT存储库中的v2.29.2的提交描述了该发布，并由Git维护者撰写并提交。</p><p> $ git rev-parse HEAD898f80736c75878acc02dc55672317fcc0e0a5a6/c/_git/git ((v2.29.2))$ git cat-file -p 898f80736c75878acc02dc55672317fcc0e0a5a6tree 75130889f941eceb57c6ceb95c6f28dfc83b609cparent a94bce62b99be35f2ee2b4c98f97c222e7dd9d82author Junio C Hamano &lt;gitster@pobox.com&gt; 1604006649 -0700committer Junio C Hamano &lt;gitster@pobox.com&gt; 1604006649 -0700Git 2.29.2Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;</p><p> $ GIT中REV-解析HEAD898f80736c75878acc02dc55672317fcc0e0a5a6 / C / _git / GIT中（（v2.29.2））$ GIT中猫文件-p 898f80736c75878acc02dc55672317fcc0e0a5a6tree 75130889f941eceb57c6ceb95c6f28dfc83b609cparent a94bce62b99be35f2ee2b4c98f97c222e7dd9d82author JUNIOÇ滨野＆LT; gitster@pobox.com&gt; 1604006649 -0700Committer Junio C Hamano＆lt; gitster@pobox.com& gt; 1604006649 -0700GIT 2.29.2SIGNID-off-BY：Junio C Hamano＆lt; gitster@pobox.com& gt;</p><p>  Looking a little farther in the history with  git log, we can see a more descriptive commit message talking about the change between that commit and its parent.</p><p>  在GIT日志中看起来有点远，我们可以看到一个更具描述性的提交消息，谈论该提交与其父级之间的变化。 </p><p> $ git cat-file -p 16b0bb99eac5ebd02a5dcabdff2cfc390e9d92eftree d0e42501b1cf65395e91e22e74f75fc5caa0286eparent 56706dba33f5d4457395c651cf1cd033c6c03c7aauthor Jeff King &amp;lt;peff@peff.net&amp;gt; 1603436979 -0400committer Junio C Hamano &amp;lt;gitster@pobox.com&amp;gt; 1603466719 -0700am: fix broken email with --committer-date-is-author-dateCommit e8cbe2118a (am: stop exporting GIT_COMMITTER_DATE, 2020-08-17)rewrote the code for setting the committer date to use fmt_ident(),rather than setting an environment variable and letting commit_tree()handle it. But it introduced two bugs:- we use the author email string instead of the committer email- when parsing the committer ident, we used the wrong variable tocompute the length of the email, resulting in it always being azero-length stringThis commit fixes both, which causes our test of this option via therebase &#34;apply&#34; backend to now succeed.Signed-off-by: Jeff King &amp;lt;peff@peff.net&amp;gt; Signed-off-by: Junio C Hamano &amp;lt;gitster@pobox.com&amp;gt;</p><p>$ git cat-file -p 16b0bb99a5dabdff2cfc390e9d92eftree d0e42501b1cf65395255caaa0286普通56706dba33f5d4457395c651cf1cd0333f5d4457395c651cf1cd033c6c03c7aaauthor jeff国王＆amp; gt; gt; gt; 1603436979 -0400Committer Junio C Hamano＆amp; lt; gitster@pobox.com &amp; gt; 1603466719 -0700AM：修复破碎的电子邮件 -  Committer-Date-Is-Author-DateCommit E8CBE2118A（AM：停止导出Git_Committer_date，2020-08-17）重写用于设置提交日期以使用FMT_IDE（）而不是设置的代码环境变量并让Commit_tree（）处理它。但它介绍了两个错误： - 我们使用作者电子邮件字符串而不是提交人电子邮件 - 在解析提交信件时，我们使用错误的变量来蜂化电子邮件的长度，从而始终是Azero-LengthThis提交修复，这导致我们对此选项的测试通过sitebase＆＃34;适用＆＃34;后端到现在成功。jeff-off-by：jeff king＆amp; lt; peff@peff.net& amp; gt;签名：Junio C hamano＆amp; lt; gitster@pobox.com &amp; gt;</p><p> In our diagrams, we will use  circles to represent commits. Notice the alliteration? Let’s review:</p><p> 在我们的图表中，我们将使用圆圈表示提交。注意头韵？我们来复习：</p><p>   In Git, we move around the history and make changes without referring to OIDs most of the time. This is because  branches provide pointers to the commits we care about. A branch with name  main is actually a reference in Git called  refs/heads/main. These files literally contain hex strings referencing the OID of a commit. As you work, these references change their contents to point to other commits.</p><p>   在Git中，我们在历史悠久中移动，并在大部分时间提及OID的情况下进行更改。这是因为分支为我们关心的提交提供指针。具有名称主要的分支实际上是名为refs / heads / main的git的引用。这些文件实际上包含引用提交的OID的十六进制字符串。在您工作时，这些参考文献将其内容更改为指向其他提交。</p><p> This means branches are significantly different from our previous Git objects. Commits, trees, and blobs are  immutable, meaning you can’t change their contents. If you change the contents, then you get a different hash and thus a new OID referring to the new object! Branches are named by users to provide meaning, such as  trunk or  my-special-project. We use branches to track and share work.</p><p> 这意味着分支与我们以前的Git对象有很大差异。提交，树和斑点是不可变的，这意味着你无法改变他们的内容。如果更改内容，则会获得不同的哈希，从而引用新对象的新oid！分支机构由用户命名，以提供含义，例如中继或我的专题项目。我们使用分支来跟踪和分享工作。</p><p> The special reference  HEAD points to the current branch. When we add a commit to  HEAD, it automatically updates that branch to the new commit.</p><p> 特殊的参考头指向当前分支。当我们添加提交到头时，它会自动更新该分支到新提交。</p><p>  $ git switch -c my-branchSwitched to a new branch &#39;my-branch&#39;$ cat .git/refs/heads/my-branch1ec19b7757a1acb11332f06e8e812b505490afc6$ cat .git/HEADref: refs/heads/my-branch</p><p>  $ git switch -c my-branchswected to新的分支和＃39;我的分支＆＃39; $ cat .git / refs / head / my-branch1ec19b7757a1acb11332f06e8e812b505490afc6 $ cat .git / headref：refs / heads / my-brang</p><p> Notice how creating  my-branch created a file ( .git/refs/heads/my-branch) containing the current commit OID and the  .git/HEAD file was updated to point at this branch. Now, if we update  HEAD by creating new commits, the branch  my-branch will update to point to that new commit!</p><p> 请注意创建My-Branch如何创建包含当前提交OID的文件（.git / refs / heads / my-branch）和.git / head文件已更新为此分支。现在，如果我们通过创建新的提交来更新头，分支我的分支将更新以指向该新提交！ </p><p>  Let’s put all of these new terms into one giant picture. Branches point to commits, commits point to other commits and their root trees, trees point to blobs and other trees, and blobs don’t point to anything. Here is a diagram containing all of our objects all at once:</p><p>让我们将所有这些新术语放入一个巨型图片中。分支指向提交，提交指向其他提交和他们的根树，树指向Blob和其他树木，而且Blob不指向任何东西。这是一个包含所有对象的图表一次：</p><p>  In this diagram, time moves from left to right. The arrows between a commit and its parents go from right to left. Each commit has a single root tree.  HEAD points to the  main branch here, and  main points to the most-recent commit. The root tree at this commit is fully expanded underneath, while the rest of the trees have arrows pointing towards these objects. The reason for that is that the same objects are reachable from multiple root trees! Since these trees reference those objects by their OID (their  content) these snapshots do not need multiple copies of the same data. In this way, Git’s object model forms a  Merkle tree.</p><p>  在此图中，时间从左到右移动。提交和父母之间的箭头从右到左。每个提交都有一个根树。头部点到这里的主要分支机构，主要点到最近的提交。此提交的根树在下面完全扩展，而树木的其余部分具有指向这些对象的箭头。其原因是，来自多根根树的相同对象！由于这些树通过其OID（它们的内容）引用这些对象，因此这些快照不需要多个相同数据的副本。通过这种方式，Git的对象模型形成Merkle树。</p><p> When we view the object model in this way, we can see why commits are snapshots: they link directly to a full view of the expected working directory for that commit!</p><p> 当我们以这种方式查看对象模型时，我们可以看到提交为何是快照：它们直接链接到该提交的预期工作目录的完整视图！</p><p>  Even though commits are snapshots, we frequently look at a commit in a history view or  on GitHub as a diff. In fact, the commit message frequently refers to this diff. The diff is  dynamically generated from the snapshot data by comparing the root trees of the commit and its parent. Git can compare any two snapshots in time, not just adjacent commits.</p><p>  即使提交是快照，我们常常在历史视图或GitHub上查看历史视图中的提交。实际上，提交消息经常是指这个差异。通过比较提交和其父的根图，从快照数据动态生成差异。 Git可以在时间上比较任何两个快照，而不仅仅是邻近的提交。</p><p> To compare two commits, start by looking at their root trees, which are almost always different. Then, perform a depth-first-search on the subtrees by following pairs when paths for the current tree have different OIDs. In the example below, the root trees have different values for the  docs, so we recurse into those two trees. Those trees have different values for  M.md, so those two blobs are compared line-by-line and that diff is shown. Still within  docs,  N.md is the same, so that is skipped and we pop back to the root tree. The root tree then sees that the  things directories have equal OIDs as well as the  README.md entries.</p><p> 要比较两个提交，首先看他们的根树，几乎总是不同。然后，当当前树的路径具有不同的OID时，通过跟随对在子树上进行深度优先搜索。在下面的示例中，根树对文档具有不同的值，因此我们将其重复到这两种树中。这些树具有不同的M.md值，因此两种斑点被逐行比较，并且显示了该差异。仍然在文档中，n.md是相同的，所以跳过，我们弹回根树。然后，根树看到事项目录具有相同的OID以及README.MD条目。</p><p>  In the diagram above, we notice that the  things tree is never visited, and so none of its reachable objects are visited. This way, the cost of computing a diff is relative to the number of paths with different content.</p><p>  在上图中，我们注意到从未访问过的东西树，因此没有任何可达物体被访问过。这样，计算差异的成本是相对于具有不同内容的路径的数量。</p><p> Now we have the understanding that  commits are snapshots and we can dynamically compute a diff between any two commits. Then why isn’t this common knowledge? Why do new users stumble over this idea that a commit is a diff?</p><p> 现在我们有致意是快照的理解，我们可以动态计算任何两个提交之间的差异。那为什么这个共同的知识不是吗？为什么新用户偶然偶然达到这个想法，提交是差异？ </p><p> One of my favorite analogies is to think of commits as having  a wave/partical duality where  sometimes they are treated like snapshots and  other times they are treated like diffs. The crux of the matter really goes into a different kind of data that’s not actually a Git object: patches.</p><p>我最喜欢的类比之一是认为犯罪是具有波浪/部分二元性，其中有时它们被视为快照和其他时间，它们被视为差异。此事的症状真的进入了不同类型的数据，实际上不是Git对象：补丁。</p><p>  A  patch is a text document that describes how to alter an existing codebase. Patches are how extremely-distributed groups can share code without using Git commits directly. You can see these being shuffled around on  the Git mailing list.</p><p>  修补程序是一个文本文档，用于描述如何更改现有代码库。修补程序是极其分布式的组可以在不使用Git提交的情况下共享代码。您可以看到这些在Git邮件列表中随身携带。</p><p> A patch contains a description of the change and why it is valuable, followed by a diff. The idea is that someone could use that reasoning as a justification to  apply that diff to their copy of the code.</p><p> 补丁包含更改的描述以及为什么它是有价值的，然后是差异。这个想法是有人可以使用该推理作为应用该副本的理由作为其代码的副本。</p><p> Git can convert a commit into a patch using   git format-patch. A patch can then be applied to a Git repository using   git apply. This was the dominant way to share code in the early days of open source, but most projects have moved to sharing Git commits directly through pull requests.</p><p> git可以使用git format-patch将提交转换为修补程序。然后可以使用Git应用将补丁应用于Git存储库。这是在开源早期分享代码的主导方式，但大多数项目通过拉动请求直接转移到分享Git提交。</p><p> The biggest issue with sharing patches is that the patch  loses the parent information and the new commit has a parent equal to your existing  HEAD. Moreover, you get a different commit even if you use the same parent as before due to the commit time, but also the committer changes! This is the fundamental reason why Git has both “author” and “committer” details in the commit object.</p><p> 共享修补程序的最大问题是修补程序丢失父信息，新提交的父级等于现有头部。此外，即使您在提交时间使用相同的父级，您也会得到不同的提交，但提交人也会更改！这是Git在提交对象中具有“作者”和“提交人”详细信息的基本原因。</p><p> The biggest problem with using patches is that it is hard to apply a patch when your working directory does not match the sender’s previous commit. Losing the commit history makes it difficult to resolve conflicts.</p><p> 使用修补程序的最大问题是，当您的工作目录与发件人的先前提交不匹配时，很难应用补丁。失去提交历史使得难以解决冲突。</p><p> This idea of “moving patches around” has transferred into several Git commands as “moving commits around.” Instead, what actually happens is that commit diffs are  replayed, creating new commits.</p><p> 这种“围绕移动补丁”的想法已转移到几个Git命令中，作为“搬家的搬家”。相反，实际发生的是重播的提交差异，创建新的提交。 </p><p>  The   git cherry-pick &lt;oid&gt; command creates a new commit with an identical diff to  &lt;oid&gt; whose parent is the current commit. Git is essentially following these steps:</p><p>git cherry-pick＆lt; oid＆gt;命令创建一个新的差异与＆lt; oid＆gt的新提交。谁的父母是当前的提交。 Git基本上遵循以下步骤：</p><p> Create a new commit whose root tree matches the new working directory and whose parent is the commit at  HEAD.</p><p> 创建一个新的提交，其根树与新工作目录匹配，父父母是head的提交。</p><p>  After Git creates the new commit, the output of  git log -1 -p HEAD should match the output of  git log -1 -p &lt;oid&gt;.</p><p>  GIT创建新提交后，Git Log -1 -P头的输出应匹配Git Log -1 -P＆lt; OID＆gt的输出。</p><p> It is important to recognize that we didn’t “move” the commit to be on top of our current  HEAD, we  created a new commit whose diff matches the old commit.</p><p> 重要的是要认识到，我们没有“移动”致力于在我们目前的头顶上，我们创建了一个新的提交，其差异与旧的提交相匹配。</p><p>  The  git rebase command presents itself as a way to move commits to have a new history. In its most basic form it is really just a series of  git cherry-pick commands, replaying diffs on top of a different commit.</p><p>  git rebase命令将自己呈现为移动提交以具有新历史记录的方式。在最基本的形式中，它真的只是一系列Git Cherry-Pick命令，在不同的提交之上重播差异。</p><p> The most important thing is that  git rebase &lt;target&gt; will discover the list of commits that are reachable from  HEAD but not reachable from  &lt;target&gt;. You can show these yourself using  git log --oneline &lt;target&gt;..HEAD.</p><p> 最重要的是git rebase＆lt; target＆gt;将发现从头到达的提交列表，但无法从＆lt;目标＆gt ;.您可以使用git log -oneline＆lt; target＆gt; .. head。</p><p> Then, the  rebase command simply navigates to the  &lt;target&gt; location and starts performing  git cherry-pick commands on this commit range, starting from the oldest commits. At the end, we have a new set of commits  with different OIDs but similar diffs to the original commit range.</p><p> 然后，rebase命令只需导航到＆lt; target＆gt;从最旧的提交开始，位置并开始在此提交范围内执行Git Cherry-Pick命令。最后，我们有一组新的提交，不同的oid，但与原始提交范围相似的差异。 </p><p> For example, consider a sequence of three commits in the current  HEAD since branching off of a  target branch. When running  git rebase target, the common base  P is computed to determine the commit list  A,  B, and  C. These are then cherry-picked on top of  target in order to construct new commits  A&#39;,  B&#39;, and  C&#39;.</p><p>例如，考虑当前头中的三个提交序列，因为分支目标分支。在运行Git Rebase目标时，计算公共基础p以确定提交列表A，B和C.然后将这些是樱桃摘在目标顶部，以构建新的犯下A＆＃39;，B＆＃39;，和C＆＃39;</p><p>  The commits  A&#39;,  B&#39;, and  C&#39; are brand new commits that share a lot of information with  A,  B, and  C, but are distinct new objects. In fact, the old commits still exist in your repository until garbage collection runs.</p><p>  提交A＆＃39;，B＆＃39 ;,和C＆＃39;是全新的致力于与A，B和C共享大量信息，但是不同的新对象。事实上，旧的提交仍然存在于您的存储库中，直到垃圾收集运行。</p><p> We can even inspect how these two commit ranges are different using the  git range-diff command! I’ll use some example commits in the Git repository to rebase onto the  v2.29.2 tag, then modify the tip commit slightly.</p><p> 我们甚至可以检查这两个提交范围如何使用Git Range-Diff命令不同！我将在Git存储库中使用一些示例提交来绑定到v2.29.2标签上，然后稍微修改提示提交。</p><p> $ git checkout -f 8e86cf65816$ git rebase v2.29.2$ echo extra line &gt;&gt;README.md$ git commit -a --amend -m &#34;replaced commit message&#34;$ git range-diff v2.29.2 8e86cf65816 HEAD1: 17e7dbbcbc = 1: 2aa8919906 sideband: avoid reporting incomplete sideband messages2: 8e86cf6581 ! 2: e08fff1d8b sideband: report unhandled incomplete sideband messages as bugs @@ Metadata Author: Johannes Schindelin &lt;Johannes.Schindelin@gmx.de&gt; ## Commit message ## - sideband: report unhandled incomplete sideband messages as bugs + replaced commit message - It was pretty tricky to verify that incomplete sideband messages are - handled correctly by the `recv_sideband()`/`demultiplex_sideband()` - code: they have to be flushed out at the end of the loop in - `recv_sideband()`, but the actual flushing is done by the - `demultiplex_sideband()` function (which therefore has to know somehow - that the loop will be done after it returns). - - To catch future bugs where incomplete sideband messages might not be - shown by mistake, let&#39;s catch that condition and report a bug. - - Signed-off-by: Johannes Schindelin &lt;johannes.schindelin@gmx.de&gt; - Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt; + ## README.md ## +@@ README.md: and the name as (depending on your mood): + [Documentation/giteveryday.txt]: Documentation/giteveryday.txt + [Documentation/gitcvs-migration.txt]: Documentation/gitcvs-migration.txt + [Documentation/SubmittingPatches]: Documentation/SubmittingPatches ++extra line ## pkt-line.c ## @@ pkt-line.c: int recv_sideband(const char *me, int in_stream, int out)</p><p> $ git checkout -f 8e86cf65816 $ git rebase v2.29.2 $ echo额外线＆gt;＆gt; Readme.md $ git commit -a -amend -m＆＃34;替换的提交消息＆＃34; $ git范围 -  diff v2。 29.2 8E86CF65816 HEAD1：17E7DBCBC = 1：2AA8919906边带：避免报告不完整的边带消息2：8E86CF6581！ 2：E08FFF1D8B SideBand：报告未处理的不完整的边带消息作为错误@@元数据作者：Johannes Schindelin＆lt; Johannes.schindelin@gmx.de&gt; ## comment消息##  -  sideBand：报告未处理的不完整的边带消息作为错误+替换提交消息 - 验证不完整的边带消息是否由`recv_sideband（）`/`demultiplex_sideband（）` - 代码正确处理了不完整的边带消息是非常棘手的：它们必须在循环终点的末尾刷新 - “recv_sideBand（）”，但实际刷新由--`multiplex_sideBand（）`（因此必须以某种方式知道 - 循环完成返回后）。 -   - 要捕获不完整的边带消息可能不会出现的未来错误，以错误地显示，让＆＃39; s捕获该条件并报告错误。 -   - 签名：Johannes Schindelin＆lt; Johannes.schindelin@gmx.de&gt; - 签名 - 逐个：junio c hamano＆lt; gitster@pobox.com& gt; + ## Readme.md ## + @@ Readme.md：和名称（取决于您的心情）：+ [文档/ giteveryday.txt]：文档/ giteveryday.txt + [文档/ gitcvs-migration.txt] ：文档/ gitcvs-migration.txt + [文档/提交斑点]：文档/提交份数++额外行## pkt-line.c ## @@ pkt-line.c：int recv_sideband（const char * me，int in_stream， int）</p><p> Notice that the resulting range-diff claims that commits  17e7dbbcbc and  2aa8919906 are “equal”, which means they would generate the same patch. The second pair of commits are different, showing that the commit message changed and there is an edit to the  README.md that was not in the original commit.</p><p> 请注意，提交17E7DBBCBC和2AA8919906的生成范围 -  DEMAC索赔是“相等的”，这意味着它们会产生相同的补丁。第二对提交是不同的，显示提交消息已更改，并且readme.md的编辑不在原始提交中。</p><p> If you are following along, you can also see how the commit history still exists for these two commit sets. The new commits have the  v2.29.2 tag as the third commit in the history while the old commits have the (earlier)  v2.29.0-rc0 tag as the third commit.</p><p> 如果您在一起，您还可以看到这两个提交集的提交历史如何仍然存在。新的提交有v2.29.2标签作为历史记录中的第三个提交，而旧的提交则具有（早）v2.29.0-rc0标签作为第三个提交。</p><p> $ git log --oneline -3 HEADe08fff1d8b2 (HEAD) replaced commit message2aa89199065 sideband: avoid reporting incomplete sideband messages898f80736c7 (tag: v2.29.2) Git 2.29.2$ git log --oneline -3 8e86cf658168e86cf65816 sideband: report unhandled incomplete sideband messages as bugs17e7dbbcbce sideband: avoid reporting incomplete sideband messages47ae905ffb9 (tag: v2.28.0) Git 2.28</p><p> $ git的日志--oneline -3 HEADe08fff1d8b2（HEAD）代替提交message2aa89199065带：避免报告不完整的带messages898f80736c7（标签：v2.29.2）Git的2.29.2 $ git的日志--oneline -3 8e86cf658168e86cf65816带：报告未处理的不完整边带信息为Bugs17E7DBBCBCE SideBand：避免报告不完整的边带消息47ae905ffb9（标签：v2.28.0）git 2.28 </p><p>  If you were looking carefully at the object model, you might have noticed that Git never tracks changes between commits in the stored object data. You might have wondered “how does Git know a rename happened?”</p><p>如果您在对象模型中仔细查找，则可能注意到Git从不追踪所存储的对象数据中的提交之间的更改。你可能想知道“Git如何知道重命名发生了？”</p><p> Git doesn’t track renames. There is no data structure inside Git that stores a record that a rename happened between a commit and its parent. Instead, Git tries to  detect renames during the dynamic diff calculation. There are two stages to this rename detection: exact renames and edit-renames.</p><p> git不跟踪重命名。 Git内没有数据结构，可以存储一个重命名在提交和其父之间发生重命名的记录。相反，Git试图在动态差异计算期间检测重命名。此重命名检测有两个阶段：精确的重命名和编辑重命名。</p><p> After first computing a diff, Git inspects the internal model of that diff to discover which paths were  added or  deleted. Naturally, a file that was moved from one location to another would appear as a deletion from the first location and an add in the second. Git attempts to  match these adds and deletes to create a set of  inferred renames.</p><p> 在首次计算差异之后，Git检查差异的内部模型，以发现添加或删除了哪些路径。当然，从一个位置移动到另一个位置的文件将显示为删除第一位置和第二个位置的删除。 Git尝试匹配这些添加和删除以创建一组推断的重命名。</p><p> The first stage of this matching algorithm looks at the OIDs of the paths that were added and deleted and see if any are exact matches. Such exact matches are paired together.</p><p> 此匹配算法的第一阶段查找添加和删除的路径的OID，并查看是否有完全匹配。这种确切的比赛在一起配对。</p><p> The second stage is the expensive part: how can we detect files that were renamed  and edited? Git iterates through each added file and compares that file against each deleted file to compute a  similarity score as a percentage of lines in common. By default, anything larger than 50% of lines in common counts as a potential edit-rename. The algorithm continues comparing these pairs until finding the maximum match.</p><p> 第二阶段是昂贵的部分：我们如何检测重命名和编辑的文件？ git通过每个添加的文件迭代，并将该文件与每个已删除的文件进行比较，以将相似性分数计算为常见的行的百分比。默认情况下，任何大于50％的常见计数中的50％作为潜在的编辑重命名。该算法继续比较这些对，直到找到最大匹配。</p><p> Did you notice a problem? This algorithm runs  A * D diffs, where  A is the number of adds and  D is the number of deletes. This is quadratic! To avoid extra-long rename computations, Git will skip this portion of detecting edit-renames if  A + D</p><p> 你注意到了一个问题吗？此算法运行A * D Diff，其中A是添加和D的数量是删除的数量。这是二次！为避免长期重命名计算，如果A + D，Git将跳过该部分检测编辑重命名的部分</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/">https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/差异/">#差异</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/snapshots/">#snapshots</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>