<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>FuzzOS –专为模糊测试而设计的操作系统 FuzzOS – an operating system which is designed specifically for fuzzing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">FuzzOS – an operating system which is designed specifically for fuzzing<br/>FuzzOS –专为模糊测试而设计的操作系统 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-08 04:13:09</div><div class="page_narrow text-break page_content"><p>We’re going to work on an  operating system which is designed specifically for fuzzing! This is going to be a streaming series for most of December which will cover making a new operating system with a strong focus on fuzzing. This means that things like the memory manager, determinism, and scalability will be the most important parts of the OS, and a lot of effort will go into making them super fast!</p><p>我们将使用专门为模糊测试设计的操作系统！这将是12月大部分时间的流媒体系列，内容包括制作一个新的操作系统，重点是模糊测试。这意味着诸如内存管理器，确定性和可伸缩性之类的东西将是操作系统最重要的部分，并且要花很多精力才能使其变得超快！</p><p>  Streaming will start sometime on Thursday, December 10th, probably around 18:00 UTC, but the streams will be at relatively random times on relatively random days. I can’t really commit to specific times!</p><p>  直播将在12月10日（星期四）世界标准时间18:00左右的某个时间开始，但直播将在相对随机的日期相对随机的时间进行。我真的不能承诺特定的时间！</p><p> Streams will likely be 4-5 days a week (probably M-F), and probably 8-12 hours in length. We’ll see, who knows, depends how much fun we have!</p><p> 信息流一周大概有4-5天（可能是M-F），长度可能是8-12小时。我们将知道，这取决于我们能获得多少乐趣！</p><p>  You’ll be able to find the streams live on my  Twitch Channel, and if you’re unlucky and miss the streams, you’ll be able to find the recordings on my  YouTube Channel! Don’t forget to like, comment, and subscribe, of course.</p><p>  您可以在我的Twitch频道上找到直播，而如果不幸或错过了直播，则可以在我的YouTube频道上找到录音！当然，不要忘记喜欢，评论和订阅。</p><p>  So… ultimately, I don’t really know what all will happen. But, I can predict a handful of things that we’ll do. First of all, it’s important to note that these streams are not training material. There is no prepared script, materials, flow, etc. If we end up building something totally different, that’s fine and we’re just going with the flow. There is no requirement of completing this project, or committing to certain ways the project will be done. So… with that aside.</p><p>  所以……最终，我真的不知道会发生什么。但是，我可以预测我们会做的一些事情。首先，必须注意这些流不是培训材料。没有准备好的脚本，材料，流程等。如果我们最终构建出完全不同的东西，那很好，我们就顺其自然。不需要完成此项目，也不必承诺完成该项目的某些方式。所以……除了那个。</p><p> We’ll be working on making an operating system, specifically for x86-64 (Intel flavor processors at the start, but AMD should work in non-hypervisor mode). This operating system will be designed for fuzzing, which means we’ll want to focus on making virtual memory management extremely fast. This is the backbone of most performant fuzzing, and we’ll need to be able to map in, unmap, and restore pages as they are modified by a fuzz case.</p><p> 我们将致力于开发专门针对x86-64的操作系统（一开始是Intel风味处理器，但AMD应该在非管理程序模式下工作）。该操作系统将专为模糊测试而设计，这意味着我们将专注于使虚拟内存管理非常快速。这是性能最高的模糊测试的基础，我们需要能够在模糊情况下修改页面时映射，取消映射和还原页面。</p><p> To keep you on the edge of your toes, I’ll first start with the boring things that we have to do.</p><p> 为了让您保持脚尖，我首先要从无聊的事情开始。 </p><p>  We have to make an operating system which boots. We’re gonna make a UEFI kernel, and we might dabble in running it on ARM64 as most of our code will be platform agnostic. But, who knows. It’ll be a pretty generic kernel, I’m mainly going to develop it on bare metal, but of course, we’ll make sure it runs on KVM/Xen/Hyper-V such that it can be used in a cloud environment.</p><p>我们必须制作一个可以启动的操作系统。我们将要制作UEFI内核，并且可能会涉足在ARM64上运行它，因为我们的大多数代码都是平台无关的。但是，谁知道。这将是一个非常通用的内核，我主要是在裸机上开发它，但是当然，我们将确保它在KVM / Xen / Hyper-V上运行，以便可以在云环境中使用。</p><p>  We’re gonna need to write ACPI table parsers such that we can find the NUMA locality of memory and CPUs on the system. This will be critical to getting a high performance memory manager that scales with cores.</p><p>  我们将需要编写ACPI表解析器，以便我们可以找到系统上内存和CPU的NUMA局部性。这对于获得可随内核扩展的高性能内存管理器至关重要。</p><p>  Of course, the kernel will support multiple cores, as otherwise it’s kinda useless for compute.</p><p>  当然，内核将支持多个内核，否则对于计算来说是没有用的。</p><p>  Since I never work with disks, I’m going to follow my standard model of just using the network as general purpose whatever. To do this, we’ll need 10gbit network drivers and a TCP stack such that we can communicate with the rest of a network. Nothing too crazy here, we’ll probably borrow some code from  Chocolate Milk</p><p>  由于我从不使用磁盘，因此我将遵循将网络作为通用用途的标准模型。为此，我们需要10gbit网络驱动程序和TCP堆栈，以便我们可以与网络的其余部分进行通信。这里没有什么太疯狂的，我们可能会从Chocolate Milk中借用一些代码</p><p>     Since we’ll be “snapshotting” memory itself, we need to make sure things like pointers aren’t a problem. The fastest, easiest, and best solution to this, is simply to make sure the memory always gets loaded at the same address. This is no problem for a single core, but it’s difficult for multiple cores, as they need to have copies of the same data mapped at the same location.</p><p>     由于我们将要“快照”内存本身，因此我们需要确保指针等不是问题。最快，最简单，最好的解决方案只是确保内存始终加载到同一地址。对于单个核心来说，这没问题，但是对于多个核心来说，这很困难，因为它们需要在同一位置映射相同数据的副本。</p><p> What’s the solution? Well of course, we’ll have every single core on the system running it’s own address space. This means there is no shared memory between cores (with some very, very minor execeptions). Not only does this lead to execeptionally high memory access performance (due to caches only being in the exclusive or shared states), but it also means that shared (mutable) memory will not be a thing! This means that we’ll do all of our core synchronization through message passing, which is higher latency in the best case than shared memory models, but with an advantage of scaling much better. As long as our messages can be serialized to TCP streams, that means we can scale across the network without any effort.</p><p> 有什么解决方案？当然，我们将使系统上的每个核心都运行自己的地址空间。这意味着内核之间没有共享内存（带有一些非常非常小的概念）。这不仅会带来极高的内存访问性能（由于缓存仅处于互斥或共享状态），而且这意味着共享（可变）内存将不再是问题！这意味着我们将通过消息传递来完成所有核心同步，在最佳情况下，此延迟比共享内存模型要高，但具有扩展性更好的优势。只要我们的消息可以序列化为TCP流，这意味着我们可以毫不费力地跨网络扩展。</p><p> This has some awesome properties since we no longer need any locks to our page tables to add and remove entries, nor do we need to perform any TLB shootdowns, which can cost tens thousands of cycles.</p><p> 这具有一些很棒的属性，因为我们不再需要对页表进行任何锁定来添加和删除条目，也不需要执行任何TLB击落操作，这会花费数万个周期。 </p><p> I used this model in  Sushi Roll, and I really miss it. It had incredibly good performance properties and forced a bit more thought about sharing information between cores.</p><p>我在Sushi Roll中使用了这个模型，我真的很想念它。它具有令人难以置信的良好性能，并迫使人们多考虑在内核之间共享信息。</p><p>  As with most things I write, linear scaling will be required, and scaling across the network is just implied, as it’s required for really any realistic application of fuzzing.</p><p>  与我所写的大多数东西一样，将需要线性缩放，并且暗示着在整个网络中进行缩放，因为对于任何实际的模糊应用来说都是必需的。</p><p>  So far, none of these things are super interesting. I’ve had many OSes that do these things well, for fuzzing, for quite a long time. However, I’ve never made these memory management techniques into a true data structure, rather I use them as needed manually. I plan to make the core of this operating system, a combination of Rust procedural macros and virtual memory management tricks to allow for arbitrary data structure to be stored in a tree-shaped checkpointed structure.</p><p>  到目前为止，这些事情都没有超级有趣。很长时间以来，我有很多操作系统可以很好地完成这些任务。但是，我从未将这些内存管理技术变成真正的数据结构，而是根据需要手动使用它们。我计划使用Rust程序宏和虚拟内存管理技巧的组合来构成该操作系统的核心，以允许将任意数据结构存储在树形检查点结构中。</p><p> This will allow for fast transitions between different state of the structure as they were snapshotted. This will be done by leveraging the dirty bits in the page tables, and creating an allocator that will allocate in a pool of memory which will be saved and restored on snapshots. This memory will be treated as an opaque blob internally, and thus it can hold any information you want, device state, guest memory state, register state, something completely unrelated to fuzzing, won’t matter. To handle nested structures (or more specifically, pointers in structures which are to be tracked), we’ll use a Rust procedural macro to disallow untracked pointers within tracked structures.</p><p> 这将允许在快照快照时在结构的不同状态之间进行快速转换。这将通过利用页表中的脏位并创建一个分配器来实现，该分配器将在内存池中进行分配，该内存将在快照中保存和恢复。此内存在内部将被视为不透明的Blob，因此它可以保存您想要的任何信息，设备状态，来宾内存状态，寄存器状态，与绒毛完全无关的信息，都没有关系。为了处理嵌套结构（或更具体地说，是要跟踪的结构中的指针），我们将使用Rust过程宏来禁止在跟踪的结构中使用未跟踪的指针。</p><p> Effectively, we’re going to heavily leverage the hardware’s MMU to differentally snapshot, teleport between, and restore blobs of memory. For fuzzing, this is necessary as a way to hold guest memory state and register state. By treating this opaquely, we can focus on doing the MMU aspects really well, and stop worrying about special casing all these variables that need to be restored upon resets.</p><p> 实际上，我们将充分利用硬件的MMU，以不同的方式快照，在它们之间传送和恢复内存块。对于模糊测试，这是保持访客内存状态和寄存器状态的一种方法。通过不透明地处理此问题，我们可以专注于真正很好地处理MMU方面，而不必担心特殊的大小写，这些所有变量在重置时都需要恢复。</p><p>  Okay, so all of that is kinda to make room for developing high performance fuzzers. In my case, I want this mainly for a new rewrite of vectorized emulation, but to make it interesting for others, we’re going to implement a Linux emulator capable of running QEMU.</p><p>  好的，所有这些都为开发高性能模糊器腾出了空间。就我而言，我主要是希望对矢量化仿真进行新的重写，但是为了让其他用户感兴趣，我们将实现一个能够运行QEMU的Linux仿真器。</p><p> This means that we’ll be able to (probably staticially only) compile QEMU. Then we can take this binary, and load it into our OS and run QEMU in our OS. This means we can control the syscall responses to the requests QEMU makes. If we do this deterministically (we will), this means QEMU will be deterministic. Which thus means, the guest inside of QEMU will also be deterministic. You see? This is a technique I’ve used in the past, and works exceptionally well. We’ll definitely outperform Linux’s handling of syscalls, and we’ll scale better, and we’ll blow Linux away when it comes to memory management.</p><p> 这意味着我们将能够（可能只是静态地）编译QEMU。然后，我们可以获取此二进制文件，并将其加载到我们的操作系统中，然后在我们的操作系统中运行QEMU。这意味着我们可以控制对QEMU发出的请求的系统调用响应。如果我们（将）确定性地执行此操作，则这意味着QEMU将是确定性的。因此，这意味着QEMU内部的来宾也将是确定性的。你看？这是我过去使用过的一种技术，效果非常好。我们绝对会胜过Linux对syscall的处理，并且我们会更好地扩展，并且在内存管理方面我们将Linux淘汰。 </p><p>  So, I have no idea how hard this would be, but from about 5 minutes of skimming the interwebs, it seems that I could pretty easily write a hypervisor in my OS that emulates KVM ioctls. Meaning QEMU would just think KVM is there, and use it!</p><p>因此，我不知道这样做会有多困难，但是从浏览Internet大约5分钟之后，看来我可以很轻松地在我的OS中编写模拟KVM ioctl的虚拟机管理程序。意思是QEMU只会认为KVM在那，然后使用它！</p><p> This will give us full control of QEMU’s determinism, syscalls, performance, and reset speeds… without actually having to modify QEMU code.</p><p> 这将使我们能够完全控制QEMU的确定性，系统调用，性能和重置速度……而无需实际修改QEMU代码。</p><p>  So that’s the plan. An OS + fast MMU code + hypervisor + Linux emulator, to allow us to deterministically run anything QEMU can run, which is effectively everything. We’ll do this with performance likely into the millions of VM resets per second per core, scaling linearly with cores, including over the network, to allow some of the fastest general purpose fuzzing the world has ever seen :D</p><p>  这就是计划。一个OS +快速的MMU代码+虚拟机管理程序+ Linux模拟器，使我们能够确定性地运行QEMU可以运行的任何东西，这实际上就是一切。我们这样做的性能可能是每个内核每秒数百万个VM重置，并与内核线性地扩展，包括通过网络进行扩展，以实现世界上见过的最快的通用模糊测试：D</p><p>   I’ve been streaming a lot more regularly on my  Twitch! I’ve developed hypervisors for fuzzing, mutators, emulators, and just done a lot of fun fuzzing work on stream. Come on by!</p><p>   我在Twitch上的直播越来越频繁了！我已经开发了用于模糊测试的虚拟机管理程序，转换器，仿真器，并且在流中完成了很多有趣的模糊测试工作。来吧！</p><p> Follow me at  @gamozolabs on Twitter if you want notifications whennew blogs come up. I often will post data and graphs from data as it comes inand I learn!</p><p> 如果您想在新博客出现时收到通知，请在Twitter上@gamozolabs跟我来。我经常会根据输入的数据发布数据和图形，然后我就会学习！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/operating/">#operating</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>