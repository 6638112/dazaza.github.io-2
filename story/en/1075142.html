<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PostgreSQL模式更改指南PostgreSQL Schema Change Guide</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PostgreSQL Schema Change Guide<br/>PostgreSQL模式更改指南</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 09:05:31</div><div class="page_narrow text-break page_content"><p>Braintree Payments uses PostgreSQL as its primary datastore. We rely heavily on the data safety and consistency guarantees a traditional relational database offers us, but these guarantees come with certain operational difficulties. To make things even more interesting, we allow zero scheduled functional downtime for our main payments processing services.</p><p>Braintree Payments使用PostgreSQL作为其主要数据存储。我们严重依赖传统关系数据库提供的数据安全性和一致性保证，但这些保证会带来一定的操作困难。为了让事情变得更有趣，我们允许我们的主要支付处理服务实现零计划功能停机。</p><p> Several years ago we  published a blog post detailing some of the things we had learned about how to safely run DDL operations without interrupting our production API traffic.</p><p>几年前，我们发表了一篇博客文章，详细介绍了我们在不中断生产API流量的情况下安全运行DDL操作的一些经验。</p><p> Since that time PostgreSQL has gone through quite a few major upgrade cycles -- several of which have added improved support for concurrent DDL. We&#39;ve also further refined our processes. Given how much has changed, we figured it was time for a blog post redux.</p><p>从那时起，PostgreSQL经历了相当多的主要升级周期——其中有几个增加了对并发DDL的改进支持。我们&#39；我们还进一步完善了我们的流程。考虑到变化有多大，我们认为是时候发布一篇博客文章了。</p><p>     Live code and schemas be forward-compatible with updated code and schemas: this allows us to roll out deploys gradually across a fleet of application servers and database clusters.</p><p>实时代码和模式与更新后的代码和模式保持前向兼容：这使我们能够在一组应用服务器和数据库集群中逐步展开部署。</p><p> New code and schemas be backward-compatible with live code and schemas: this allows us to roll back any change to the previous version in the event of unexpected errors.</p><p>新的代码和模式与实时代码和模式向后兼容：这允许我们在发生意外错误时回滚到以前版本的任何更改。</p><p>  Any exclusive locks acquired on tables or indexes be held for at most ~2 seconds.</p><p>在表或索引上获取的任何独占锁最多可保持2秒。</p><p>  PostgreSQL supports transactional DDL. In most cases, you can execute multiple DDL statements inside an explicit database transaction and take an &#34;all or nothing&#34; approach to a set of changes. However, running multiple DDL statements inside a transaction has one serious downside: if you alter multiple objects, you&#39;ll need to acquire exclusive locks on all of those objects in a single transactions. Because locks on multiple tables creates the possibility of deadlock and increases exposure to long waits, we do not combine multiple DDL statements into a single transaction. PostgreSQL will still execute each separate DDL statement transactionally; each statement will be either cleanly applied or fail and the transaction rolled back.</p><p>PostgreSQL支持事务性DDL。在大多数情况下，可以在显式数据库事务中执行多个DDL语句，并使用&#34；要么全无&#34；一系列改变的方法。然而，在一个事务中运行多个DDL语句有一个严重的缺点：如果您更改多个对象，您&#39；我们需要在单个事务中获取所有这些对象的独占锁。由于多个表上的锁会造成死锁，并增加长时间等待的风险，因此我们不会将多个DDL语句组合到一个事务中。PostgreSQL仍将以事务方式执行每个单独的DDL语句；每条语句要么被干净地应用，要么失败，事务被回滚。</p><p> Note: Concurrent index creation is a special case. Postgres disallows executing  CREATE INDEX CONCURRENTLY inside an explicit transaction; instead Postgres itself manages the transactions. If for some reason the index build fails before completion, you may need to drop the index before retrying, though the index will still never be used for regular queries if it did not finish building successfully.</p><p>注意：并发索引创建是一种特殊情况。Postgres不允许在显式事务中同时执行创建索引；相反，Postgres自己管理交易。如果由于某种原因，索引生成在完成之前失败，您可能需要在重试之前删除该索引，但如果索引未成功完成生成，则该索引将永远不会用于常规查询。</p><p>  PostgreSQL has  many different levels of locking. We&#39;re concerned primarily with the following table-level locks since DDL generally operates at these levels:</p><p>PostgreSQL有许多不同级别的锁定。我们&#39；我们主要关注以下表级锁，因为DDL通常在这些级别上运行：</p><p> SHARE ROW EXCLUSIVE: blocks concurrent DDL against and row modification (allowing reads) in the locked table.</p><p>SHARE ROW EXCLUSIVE：阻止对锁定表中的行进行并发DDL和行修改（允许读取）。</p><p>  All DDL operations generally necessitate acquiring one of these locks on the object being manipulated. For example, when you run:</p><p>所有DDL操作通常都需要在被操纵的对象上获取其中一个锁。例如，运行时：</p><p>  PostgreSQL attempts to acquire an  ACCESS EXCLUSIVE lock on the table  foos. Atempting to acquire this lock  causes all subsequent queries on this table to queue until the lock is released. In practice your DDL operations can cause other queries to back up for as long as your longest running query takes to execute. Because arbitrarily long queueing of incoming queries is indistinguishable from an outage, we try to avoid any long-running queries in databases supporting our payments processing applications.</p><p>PostgreSQL试图获取表foos上的访问独占锁。试图获取此锁会导致此表上的所有后续查询排队，直到释放锁为止。在实践中，DDL操作可能会导致其他查询在执行最长运行查询所需的时间内进行备份。由于传入查询的任意长排队与中断是无法区分的，因此我们试图避免在支持支付处理应用程序的数据库中出现任何长时间运行的查询。</p><p> But sometimes a query takes longer than you expect. Or maybe you have a few special case queries that you already know will take a long time. PostgreSQL offers some additional runtime configuration options that allow us to guarantee query queueing backpressure doesn&#39;t result in downtime.</p><p>但有时查询所需的时间比您预期的要长。或者你可能有一些你已经知道需要很长时间的特殊情况查询。PostgreSQL提供了一些额外的运行时配置选项，使我们能够保证查询队列背压不会&#39；不会导致停机。</p><p> Instead of relying on Postgres to lock an object when executing a DDL statement, we acquire the lock explicitly ourselves. This allows us to carefully control the time the queries may be queued. Additionally when we fail to acquire a lock within several seconds, we pause before trying again so that any queued queries can be executed without significantly increasing load. Finally, before we attempt lock acquisition, we check ( query here) for any currently long running queries to avoid unnecessarily queueing queries for several seconds when it is unlikely that lock acquisition is going to succeed.</p><p>在执行DDL语句时，我们不依赖Postgres来锁定对象，而是自己显式地获取锁。这使我们能够仔细控制查询排队的时间。此外，当我们无法在几秒钟内获得锁时，我们会在重试之前暂停，以便在不显著增加负载的情况下执行任何排队查询。最后，在尝试锁获取之前，我们检查（此处的查询）是否存在任何当前长时间运行的查询，以避免在锁获取不太可能成功的情况下，不必要地将查询排队几秒钟。</p><p> Starting with Postgres 9.3, you adjust the   lock_timeout parameter to control how long Postgres will allow for lock acquisition before returning without acquiring the lock. If you happen to be using 9.2 or earlier (and those are unsupported; you should upgrade!), then you can simulate this behavior by using the   statement_timeout parameter around an explicit  LOCK &lt;table&gt; statement.</p><p>从Postgres 9.3开始，您可以调整lock_timeout参数，以控制Postgres在返回而不获取锁之前允许获取锁的时间。如果您碰巧使用的是9.2或更早版本（这些版本不受支持，您应该升级！），然后，您可以通过在显式锁周围使用statement_timeout参数来模拟这种行为&lt；表&gt；陈述</p><p> In many cases an  ACCESS EXCLUSIVE lock need only be held for a very short period of time, i.e., the amount of time it takes Postgres to update its &#34;catalog&#34; (think metadata) tables. Below we&#39;ll discuss the cases where a lower lock level is sufficient or alternative approaches for avoiding long-held locks that block  SELECT/INSERT/UPDATE/DELETE.</p><p>在许多情况下，访问独占锁只需保持很短的时间，即Postgres更新其&#34；目录&#34；（想想元数据）表。下面我们&#39；我们将讨论较低的锁级别足以避免阻塞SELECT/INSERT/UPDATE/DELETE的长锁的情况或替代方法。</p><p> Note: Sometimes holding even an  ACCESS EXCLUSIVE lock for something more than a catalog update (e.g., a full table scan or even rewrite) can be functionally acceptable when the table size is relatively small. We recommend testing your specific use case against realistic data sizes and hardware to see if a particular operation will be &#34;fast enough&#34;. On good hardware with a table easily loaded into memory, a full table scan or rewrite for thousands (possibly even 100s of thousands) of rows may be &#34;fast enough&#34;.</p><p>注：有时，在表大小相对较小的情况下，即使对目录更新以外的内容（例如，完整表扫描或甚至重写）持有访问独占锁，在功能上也可以接受。我们建议根据实际的数据大小和硬件测试您的特定用例，以查看特定操作是否为&#34；足够快&#34；。在好的硬件上，表很容易加载到内存中，对数千行（甚至可能是100到数千行）的完整表扫描或重写可能是&#34；足够快&#34；。</p><p>   In general, adding a table is one of the few operations we don&#39;t have to think too hard about since, by definition, the object we&#39;re &#34;modifying&#34; can&#39;t possibly be in use yet. :D</p><p>一般来说，添加一个表是我们不做的少数操作之一&#39；I don’我们不必想得太多，因为根据定义，我们&#39；re&#34；修改&#34；可以&#39；目前还不可能投入使用D</p><p> While most of the attributes involved in creating a table do not involve other database objects, including a foreign key in your initial table definition will cause Postgres to acquire a  SHARE ROW EXCLUSIVE lock against the referenced table blocking any concurrent DDL or row modifications. While this lock should be short-lived, it nonetheless requires the same caution as any other operation acquiring such a lock. We prefer to split these into two separate operations: create the table and then  add the foreign key.</p><p>虽然创建表所涉及的大多数属性都不涉及其他数据库对象，但在初始表定义中包含外键将导致Postgres获取对引用表的共享行独占锁，阻止任何并发DDL或行修改。虽然该锁应该是短期的，但它需要与获取此类锁的任何其他操作一样的谨慎。我们更愿意将它们分成两个独立的操作：创建表，然后添加外键。</p><p>  Dropping a table requires an exclusive lock on that table. As long as the table isn&#39;t in current use you can safely drop the table. Before allowing a  DROP TABLE ... to make its way into our production environments we require documentation showing when all references to the table were removed from the codebase. To double check that this is the case you can  query PostgreSQL&#39;s table statistics view  pg_stat_user_tables confirming that the returned statistics don&#39;t change over the course of a reasonable length of time.</p><p>删除表需要在该表上使用独占锁。只要桌子不是&#39；t在当前使用中，你可以安全地放下桌子。在允许放下桌子之前。。。为了进入我们的生产环境，我们需要文档来显示表的所有引用何时从代码库中删除。要再次检查这种情况，可以查询PostgreSQL&#39；s table statistics view pg_stat_user_tables确认返回的统计数据不&#39；不要在合理的时间内改变。</p><p>  While it&#39;s unsurprising that a table rename requires acquiring an  ACCESS EXCLUSIVE lock on the table, that&#39;s far from our biggest concern. Unless the table is not being read from or written to, it&#39;s very unlikely that your application code could safely handle a table being renamed underneath it.</p><p>而它&#39；不足为奇的是，表重命名需要获取表上的访问独占锁，即&#39；这远非我们最大的担忧。除非该表没有被读取或写入，否则它&#39；it’应用程序代码不太可能安全地处理在其下重命名的表。</p><p> We avoid table renames almost entirely. But if a rename is an absolute must, then a safe approach might look something like the following:</p><p>我们几乎完全避免表重命名。但如果重命名是绝对必要的，那么安全的方法可能如下所示：</p><p> Use INSERT and UPDATE triggers on the old table to maintain parity in the new table.</p><p>在旧表上使用INSERT和UPDATE触发器来维护新表中的奇偶校验。</p><p> Other approaches involving views and/or RULEs may also be viable depending on the performance characteristics required.</p><p>其他涉及视图和/或规则的方法也可能可行，具体取决于所需的性能特征。</p><p>    Adding a column to an existing table generally requires holding a short  ACCESS EXCLUSIVE lock on the table while catalog tables are updated. But there are several potential gotchas:</p><p>向现有表中添加列通常需要在更新目录表时在表上保持短访问独占锁。但有几个潜在的问题：</p><p> Default values: Introducing a default value at the same time of adding the column will cause the table to be locked while the default value in propogated for all rows in the table. Instead, you should:</p><p>默认值：在添加列的同时引入默认值将导致表被锁定，而表中所有行的默认值都将被分配。相反，你应该：</p><p>  Note: In the recently release PostgreSQL 11, this is no longer the case for non-volatile default values. Instead adding a new column with a default value only requires updating catalog tables, and any reads of rows without a value for the new column will  magically have it &#34;filled in&#34; on the fly.</p><p>注意：在最近发布的PostgreSQL 11中，非易失性默认值不再是这种情况。相反，添加一个带有默认值的新列只需要更新目录表，任何没有新列值的行读取都会神奇地拥有它&#34；填写&#34；在飞行中。</p><p> Not-null constraints: Adding a column with a not-constraint is only possible if there are no existing rows or a  DEFAULT is also provided. If there are no existing rows, then the change is effectively equivalent to a catalog only change. If there are existing rows and you are also specifying a default value, then the same caveats apply as above with respect to default values.</p><p>Not null约束：只有在没有现有行或还提供了默认值的情况下，才能添加带有Not约束的列。如果没有现有行，那么该更改实际上相当于仅目录更改。如果存在现有行，并且您也指定了默认值，那么对于默认值，上述警告同样适用。</p><p> Note: Adding a column will cause all  SELECT * FROM ... style queries referencing the table to begin returning the new column. It is important to ensure that all currently running code safely handles new columns. To avoid this gotcha in our applications we require queries to avoid  * expansion in favor of explicit column references.</p><p>注意：添加列将导致所有SELECT*FROM。。。引用表以开始返回新列的样式查询。确保所有当前运行的代码安全地处理新列是很重要的。为了避免应用程序中出现这种情况，我们要求查询避免*扩展，以支持显式列引用。</p><p>  In the general case changing a column&#39;s type requires holding an exclusive lock on a table while the entire table is rewritten with the new type.</p><p>在一般情况下，更改列&#39；s类型要求在使用新类型重写整个表时，在表上保持独占锁。</p><p>   Note: Even though one of the exceptions above was added in 9.1, changing the type of an indexed column would always rewrite the index even if a table rewrite was avoided. In 9.2 any column data type that avoids a table rewrite also  avoids rewriting the associated indexes. If you&#39;d like to confirm that your change won&#39;t rewrite the table or any indexes, you can  query  pg_class and verify the  relfilenode column doesn&#39;t change.</p><p>注意：尽管9.1中添加了上述异常之一，但更改索引列的类型始终会重写索引，即使避免了表重写。在9.2中，任何避免表重写的列数据类型也可以避免重写相关的索引。如果你&#39；I’我想确认一下，您的零钱赢了&#39；如果不重写表或任何索引，可以查询pg_类并验证relfilenode列不&#39；不要改变。</p><p> If you need to change the type of a column and one of the above exceptions doesn&#39;t apply, then the safe alternative is:</p><p>如果您需要更改列的类型，且上述异常之一不存在&#39；如果不适用，那么安全的替代方案是：</p><p> Rename  &lt;column&gt; to  old_&lt;column&gt; and  new_&lt;column&gt; inside a single transaction and explicit  LOCK &lt;table&gt; statement.</p><p>重命名&lt；列&gt；致老uu&lt；列&gt；和新的&lt；列&gt；在单个事务和显式锁定中&lt；表&gt；陈述</p><p>  It goes without saying that dropping a column is something that should be done with great care. Dropping a column requires an exclusive lock on the table to update the catalog but  does not rewrite the table. As long as the column isn&#39;t in current use you can safely drop the column. It&#39;s also important to confirm that the column is not referenced by any dependent objects that could be unsafe to drop. In particular, any indexes using the column should be dropped separately and safely with   DROP INDEX CONCURRENTLY since otherwise they will be automatically dropped along with the column under an  ACCESS EXCLUSIVE lock. You can  query  pg_depend for any dependent objects.</p><p>不言而喻，删除一篇专栏文章应该非常小心。删除列需要表上的独占锁来更新目录，但不会重写表。只要列不是&#39；t在当前使用中，你可以安全地放下柱子。它&#39；确认列未被任何可能不安全的依赖对象引用也很重要。特别是，任何使用该列的索引都应该单独安全地删除，同时删除索引，否则它们将在访问独占锁下与该列一起自动删除。您可以查询pg_depend中的任何依赖对象。</p><p> Before allowing a  ALTER TABLE ... DROP COLUMN ... to make its way into our production environments we require documentation showing when all references to the column were removed from the codebase. This process allows us to safely roll back to the release prior to the one that dropped the column.</p><p>在允许更改表格之前。。。删除列。。。为了进入我们的生产环境，我们需要文档来显示何时从代码库中删除了对该列的所有引用。这个过程使我们能够安全地回滚到丢弃列之前的版本。</p><p> Note: Dropping a column will require that you update all views, triggers, function, etc. that rely on that column.</p><p>注意：删除列需要更新所有依赖该列的视图、触发器、函数等。</p><p>   The standard form of  CREATE INDEX ... acquires an  ACCESS EXCLUSIVE lock against the table being indexed while building the index using a single table scan. In contrast, the form  CREATE INDEX CONCURRENTLY ... acquires an  SHARE UPDATE EXCLUSIVE lock but must complete two table scans (and hence is somewhat slower). This lower lock level allows reads and writes to continue against the table while the index is built.</p><p>创建索引的标准形式。。。在使用单个表扫描构建索引时，针对正在编制索引的表获取访问独占锁。相比之下，表单会同时创建索引。。。获取共享更新独占锁，但必须完成两次表扫描（因此速度稍慢）。这个较低的锁级别允许在构建索引时继续对表进行读写。</p><p>  Multiple concurrent index creations on a single table will not return from either  CREATE INDEX CONCURRENTLY ... statement until the slowest one completes.</p><p>单个表上的多个并发索引创建不会从两个创建索引中同时返回。。。语句，直到最慢的语句完成。</p><p> CREATE INDEX CONCURRENTLY ... may not be executed inside of a transaction but does maintain transactions internally. This holding open a transaction means that no auto-vacuums (against any table in the system) will be able to cleanup dead tuples introduced after the index build begins until it finishes. If you have a table with a large volume of updates (particularly bad if to a very small table) this could result in extremely unoptimal query execution.</p><p>同时创建索引。。。可能不会在事务内部执行，但会在内部维护事务。这种保持打开事务的方式意味着，在索引构建开始之后，直到构建完成之前，自动清空（针对系统中的任何表）都无法清理引入的死元组。如果有一个更新量很大的表（如果更新到非常小的表，情况尤其糟糕），这可能会导致非常不理想的查询执行。</p><p> CREATE INDEX CONCURRENTLY ... must wait for all transactions using the table to complete before returning.</p><p>同时创建索引。。。必须等待使用该表的所有事务完成后才能返回。</p><p>  The standard form of  DROP INDEX ... acquires an  ACCESS EXCLUSIVE lock against the table with the index while removing the index. For small indexes this may be a short operation. For large indexes, however, file system unlinking and disk flushing can take a significant amount of time. In contrast, the form  DROP INDEX CONCURRENTLY ... acquires a  SHARE UPDATE EXCLUSIVE lock to perform these operations allowing reads and writes to continue against the table while the index is dropped.</p><p>下降指数的标准形式。。。在删除索引时获取对具有索引的表的访问独占锁。对于小索引，这可能是一个短期操作。但是，对于大型索引，文件系统断开链接和磁盘刷新可能需要大量时间。相比之下，表单删除索引。。。获取共享更新独占锁以执行这些操作，允许在删除索引时继续对表进行读写。</p><p>  DROP INDEX CONCURRENTLY ... cannot be used to drop any index that supports a constraint (e.g.,  PRIMARY KEY or  UNIQUE).</p><p>同时删除索引。。。不能用于删除任何支持约束（例如主键或唯一）的索引。</p><p> DROP INDEX CONCURRENTLY ... may not be executed inside of a transaction but does maintain transactions internally. This holding open a transaction means that no auto-vacuums (against any table in the system) will be able to cleanup dead tuples introduced after the index build begins until it finishes. If you have a table with a large volume of updates (particularly bad if to a very small table) this could result in extremely unoptimal query execution.</p><p>同时删除索引。。。可能不会在事务内部执行，但会在内部维护事务。这种保持打开事务的方式意味着，在索引构建开始之后，直到构建完成之前，自动清空（针对系统中的任何表）都无法清理引入的死元组。如果有一个更新量很大的表（如果更新到非常小的表，情况尤其糟糕），这可能会导致非常不理想的查询执行。</p><p> DROP INDEX CONCURRENTLY ... must wait for all transactions using the table to complete before returning.</p><p>同时删除索引。。。必须等待使用该表的所有事务完成后才能返回。</p><p> Note:  DROP INDEX CONCURRENTLY ... was  added in Postgres 9.2. If you&#39;re still running 9.1 or prior, you can achieve somewhat similar results by marking the index as invalid and not ready for writes, flushing buffers with the pgfincore extension, and the dropping the index.</p><p>注意：同时删除索引。。。在Postgres 9.2中添加。如果你&#39；如果仍在运行9.1或更早版本，则可以通过将索引标记为无效且未准备好写入、使用pgfincore扩展刷新缓冲区以及删除索引来获得类似的结果。</p><p>  ALTER INDEX ... RENAME TO ... requires an  ACCESS EXCLUSIVE lock on the index blocking reads from and writes to the underlying table. However a  recent commit expected to be a part of Postgres 12 lowers that requirement to  SHARE UPDATE EXCLUSIVE.</p><p>改变索引。。。重命名为。。。需要索引上的访问独占锁，阻止对基础表的读取和写入。然而，最近的一项承诺预计将成为Postgres 12的一部分，降低了共享独家更新的要求。</p><p>  REINDEX INDEX ... requires an  ACCESS EXCLUSIVE lock on the index blocking reads from and writes to the underlying table. Instead we use the following procedure:</p><p>重新索引索引。。。需要索引上的访问独占锁，阻止对基础表的读取和写入。相反，我们使用以下程序：</p><p>  Note: If the index you need to rebuild backs a constraint, remember to re-add the constraint as well (subject to all of the  caveats we&#39;ve documented.</p><p>注意：如果需要重建的索引支持一个约束，请记住也要重新添加约束（根据我们记录的所有注意事项）。</p><p>   Removing an existing not-null constraint from a column requires an exclusive lock on the table while a simple catalog update is performed.</p><p>从列中删除现有的NOTNULL约束需要在执行简单目录更新时对表进行独占锁定。</p><p> In constrast, adding a not-null constraint to an existing column requires an exclusive lock on the table while a full table scan verifies that no  null values exist. Instead you should:</p><p>相反，向现有列添加NOTNULL约束需要表上的独占锁，而完整表扫描验证不存在空值。相反，你应该：</p><p> Add a  CHECK constraint requiring the column be not-null with  ALTER TABLE &lt;table&gt; ADD CONSTRAINT &lt;name&gt; CHECK (&lt;column&gt; IS NOT NULL) NOT VALID;. The  NOT VALID tells Postgres that it doesn&#39;t need to scan the entire table to verify that all rows satisfy the condition.</p><p>使用ALTER TABLE添加一个CHECK约束，要求列不为空&lt；表&gt；添加约束&lt；名称&gt；检查（&lt；column&gt；不为空）无效；。无效项告诉Postgres它没有&#39；不需要扫描整个表来验证所有行是否满足条件。</p><p>  Validate the constraint with  ALTER TABLE &lt;table&gt; VALIDATE CONSTRAINT &lt;name&gt;;. With this statement PostgreSQL will block acquisition of other EXCLUSIVE locks for the table, but will not block reads or writes.</p><p>使用ALTER TABLE验证约束&lt；表&gt；验证约束&lt；name&gt；；。使用此语句，PostgreSQL将阻止获取表的其他独占锁，但不会阻止读取或写入。</p><p> Bonus: There is currently a  patch in the works (and possibly it will make it into Postgres 12) that will allow you to create a  NOT NULL constraint without a full table scan if a CHECK constraint (like we created above) already exists.</p><p>额外好处：目前有一个补丁正在开发中（可能它会进入Postgres 12），如果已经存在检查约束（如我们上面创建的）的话，它将允许您在不进行完整表扫描的情况下创建一个非空约束。</p><p>  ALTER TABLE ... ADD FOREIGN KEY requires a  SHARE ROW EXCLUSIVE lock ( as of 9.5)  on both the altered and referenced tables. While this won&#39;t block  SELECT queries, blocking row modification operations for a long period of time is equally unacceptable for our transaction processing applications.</p><p>改变桌子。。。ADD FOREIGN KEY要求在修改的表和引用的表上都有一个共享行独占锁（从9.5开始）。而这场胜利&#39；t阻塞SELECT查询，长时间阻塞行修改操作对于我们的事务处理应用程序来说同样是不可接受的。</p><p>  ALTER TABLE ... ADD FOREIGN KEY ... NOT VALID: Adds the foreign key and begins enforcing the constraint for all new  INSERT/UPDATE statements but does not validate that all existing rows conform to the new constraint. This operation still requires  SHARE ROW EXCLUSIVE locks, but the locks are only briefly held.</p><p>改变桌子。。。添加外键。。。无效：添加外键并开始对所有新的INSERT/UPDATE语句强制执行约束，但不验证所有现有行是否符合新约束。此操作仍然需要共享行独占锁，但这些锁仅短暂保持。</p><p> ALTER TABLE ... VALIDATE CONSTRAINT &lt;constraint&gt;: This operation checks all existing rows to verify they conform to the specified constraint. Validation requires a  SHARE UPDATE EXCLUSIVE so may run concurrently with row reading and modification queries.</p><p>改变桌子。。。验证约束&lt；约束&gt；：此操作将检查所有现有行，以验证它们是否符合指定的约束。验证需要共享更新独占，因此可以与行读取和修改查询同时运行。</p><p>  ALTER TABLE ... ADD CONSTRAINT ... CHECK (...) requires an  ACCESS EXCLUSIVE lock. However, as with foreign keys, Postgres supports breaking the operation into two steps:</p><p>改变桌子。。。添加约束。。。检查（…）需要访问独占锁。然而，与外键一样，Postgres支持将操作分为两个步骤：</p><p> ALTER TABLE ... ADD CONSTRAINT ... CHECK (...) NOT VALID: Adds the check constraint and begins enforcing it for all new  INSERT/UPDATE statements but does not validate that all existing rows conform to the new constraint. This operation still requires an  ACCESS EXCLUSIVE lock.</p><p>改变桌子。。。添加约束。。。检查（…）无效：添加检查约束，并开始对所有新的INSERT/UPDATE语句强制执行该约束，但不验证所有现有行是否符合新约束。此操作仍需要访问独占锁。</p><p> ALTER TABLE ... VALIDATE CONSTRAINT &lt;constraint&gt;: This operation checks all existing rows to verify they conform to the specified constraint. Validation requires a  SHARE UPDATE EXCLUSIVE on the altered table so may run concurrently with row reading and modification queries. A  ROW SHARE lock is held on the reference table which will block any operaitons requiring exclusive locks while validating the constraint.</p><p>改变桌子。。。验证约束&lt；约束&gt；：此操作将检查所有现有行，以验证它们是否符合指定的约束。验证需要对修改后的表进行独占的共享更新，因此可以与行读取和修改查询同时运行。引用表上有一个行共享锁，它将在验证约束时阻止任何需要独占锁的操作。</p><p>  ALTER TABLE ... ADD CONSTRAINT ... UNIQUE (...) requires an  ACCESS EXCLUSIVE lock. However, Postgres supports breaking the operation into two steps:</p><p>改变桌子。。。添加约束。。。独特的（…）需要访问独占锁。然而，Postgres支持将操作分为两个步骤：</p><p> Create a unique index  concurrently. This step will immediately enforce uniquesness, but if you need a declared constraint (or a primary key), then continue to add the constraint separately.</p><p>同时创建一个唯一的索引。此步骤将立即强制唯一性，但如果需要声明的约束（或主键），则继续单独添加约束。</p><p> Add the constraint using the already existing index with  ALTER TABLE ... ADD CONSTRAINT ... UNIQUE USING INDEX &lt;index&gt;. Adding the constraint still requires an  ACCESS EXCLUSIVE lock, but the lock will only be held for fast catalog operations.</p><p>使用已有的带有ALTER TABLE的索引添加约束。。。添加约束。。。唯一使用索引&lt；索引&gt；。添加约束仍然需要访问独占锁，但该锁将仅用于快速目录操作。</p><p> Note: If you specify  PRIMARY KEY instead of  UNIQUE then any non-null columns in the index will be made  NOT NULL. This requires a full table scan which currently can&#39;t be avoided. See  NOT NULL Constraints for more details.</p><p>注意：如果指定主键而不是唯一键，则索引中的任何非空列都将变为非空。这需要一个完整的表格扫描，目前可以&#39；这是不可避免的。有关更多详细信息，请参见非空约束。</p><p>  ALTER TABLE ... ADD CONSTRAINT ... EXCLUDE USING ... requires an  ACCESS EXCLUSIVE lock. Adding an exclusion constraint builds the supporting index, and, unfortunately, there is currently no support for using an existing index (as you can do with a  unique constraint).</p><p>改变桌子。。。添加约束。。。排除使用。。。需要访问独占锁。添加排除约束会生成支持索引，不幸的是，目前不支持使用现有索引（可以使用唯一约束）。</p><p>   CREATE TYPE &lt;name&gt; AS (...) and  DROP TYPE &lt;name&gt; (after verifying there are no existing usages in the database) can both be done safely without unexpected locking.</p><p>创建类型&lt；名称&gt；作为（…）和下拉式&lt；名称&gt；（在验证数据库中没有现有用法后）这两种方法都可以安全地完成，而不会出现意外锁定。</p><p>  ALTER TYPE &lt;enum&gt; RENAME VALUE &lt;old&gt; TO &lt;new&gt; was  added in Postgres 10. This statement does not require locking tables which use the enum type.</p><p>改变类型&lt；enum&gt；重命名值&lt；旧的&gt；到&lt；新&gt；在10级后加上。此语句不需要使用枚举类型的锁定表。</p><p>  Enums are stored internally as integers and there is no support for gaps in the valid range, removing a value would currently shifting values and rewriting all rows using those values. PostgreSQL does not currently support removing values from an existing enum type.</p><p>枚举在内部存储为整数，不支持有效范围内的间隙，删除一个值将导致当前值移位，并使用这些值重写所有行。PostgreSQL目前不支持从现有枚举类型中删除值。</p><p>  We&#39;re also excited to announce that we have open-sourced our internal library  pg_ha_migrations. This Ruby gem enforces DDL safety in projects using Ruby on Rails and/or ActiveRecord with an emphasis on explicitly choosing tradeoffs and avoiding unnecessary magic (and the corresponding surprises). You can read more in the project&#39;s  README.</p><p>我们&#39；我们也很高兴地宣布，我们已经开放了我们的内部库pg_ha_迁移。这个Ruby gem在使用Ruby on Rails和/或ActiveRecord的项目中加强了DDL安全性，重点是明确选择折衷方案，避免不必要的魔法（以及相应的意外）。你可以在项目#39；这是自述。</p><p>   [^locks-held] You can find active long-running queries and the tables they lock with the following query: https://gist.github.com/30b4779cb101c133859a1a11247233f1</p><p>[^locks hold]您可以找到活动的长期运行查询，以及它们通过以下查询锁定的表：https://gist.github.com/30b4779cb101c133859a1a11247233f1</p><p> [^relation-rewritten] You can see if DDL causes a relation to be rewritten by seeing if the  relfilenode value changes after running the statement: https://gist.github.com/67687738c11f1f5ba8a04a7198d92715</p><p>[^relation Rewrited]通过查看运行语句后relfilenode值是否发生变化，可以查看DDL是否会导致关系被重写：https://gist.github.com/67687738c11f1f5ba8a04a7198d92715</p><p> [^dependent-objects] You can find objects (e.g., indexes) that depend on a specific column by running the statement: https://gist.github.com/5fac44d798bbce1d5d4f9c0bd57abb21</p><p>[^dependent objects]通过运行以下语句，可以找到依赖于特定列的对象（例如索引）：https://gist.github.com/5fac44d798bbce1d5d4f9c0bd57abb21</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/模式/">#模式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/schema/">#schema</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/索引/">#索引</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>