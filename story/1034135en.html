<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何重新计算电子表格</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何重新计算电子表格</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 04:44:45</div><div class="page_narrow text-break page_content"><p>Let’s say I’m ordering burritos for my two friends while they quar up in Jersey City, and want to calculate the total price of my order:</p><p>假设我正在为我的两个朋友在泽西城排队时点玉米煎饼，并想要计算我点的总价：</p><p>  It’s a little confusing to follow the flow of data in a spreadsheet when it’s written like that, so I hope you don’t mind this equivalent diagram that represents it as a graph:</p><p>在这样编写的电子表格中跟踪数据流有点令人困惑，所以我希望您不介意将其表示为图形的等价图：</p><p>  We’re rounding the cost of an El Farolito super vegi burrito to $8, so assuming the per-burrito delivery toll remains at just $2 per burrito, it looks like the total for our two burritos will be $20.</p><p>我们把El Farolito超级素食玉米煎饼的价格四舍五入到8美元，所以假设每个玉米煎饼的送货费用仍然只有2美元，那么我们两个玉米煎饼的总价看起来将是20美元。</p><p> Oh no, I completely forgot! One of my friends loves to wolf down multiple burritos at a time, so I actually want to place an order for three burritos. If I update  Num Burritos, a naïve spreadsheet engine might recompute the entire document, recalculating first the cells with no inputs, and then recalculating any cell whose inputs are ready until we’ve finished every cell. In this case, we’d first calculate  Burrito Price and  Num Burritos, then  Burrito Price w Ship, and then a new final  Total of $30.</p><p>哦，不，我完全忘了！我的一个朋友喜欢一次狼吞虎咽地吃下多个玉米煎饼，所以我真的想点三个玉米煎饼。如果我更新num Burritos，一个幼稚的电子表格引擎可能会重新计算整个文档，首先重新计算没有输入的单元格，然后重新计算输入准备就绪的任何单元格，直到我们完成每个单元格。在本例中，我们首先计算玉米煎饼价格和玉米煎饼数量，然后计算玉米煎饼价格w船，然后计算新的最终总计30美元。</p><p>  This simple strategy of recalculating the whole document may sound wasteful, but it’s actually already  better than VisiCalc, the first spreadsheet software ever made, and the first so-called “killer app”, responsible for popularizing the Apple II. VisiCalc would repeatedly recalculate cells from left-to-right and top-to-bottom, sweeping over them again and again until none of them changed. Despite this “interesting” algorithm, VisiCalc remained the dominant spreadsheet software for four years. Its reign ended in 1983, when Lotus 1-2-3 swept the market with “natural-order recalculation”,  as described by Tracy Robnett Licklider in Byte Magazine:</p><p>这种简单的重新计算整个文档的策略听起来可能很浪费，但实际上已经比VisiCalc更好了。VisiCalc是有史以来第一款电子表格软件，也是第一款所谓的“杀手级应用”，负责推广Apple II。VisiCalc会从左到右、从上到下反复重新计算单元格，一遍又一遍地扫描，直到它们都没有改变。尽管有这种“有趣”的算法，VisiCalc在四年的时间里仍然是占主导地位的电子表格软件。它的统治在1983年结束，当时莲花1-2-3以“自然顺序重新计算”席卷市场，正如Tracy Robnett Licklider在Byte Magazine中所描述的那样：</p><p> Lotus 1-2-3 exploited natural-order recalculation, although it also supported VisiCalc’s row- and column-order modes. Natural-order recalculation maintained a cell dependency list and recalculated a cell before recalculating cells that depended on it.</p><p>Lotus1-2-3利用了自然顺序重新计算，尽管它也支持VisiCalc的行顺序和列顺序模式。自然顺序重新计算维护了一个单元格依赖列表，并在重新计算依赖于该单元格的单元格之前重新计算该单元格。</p><p> Lotus 1-2-3 implemented the “recalculate everything” strategy we’ve shown above, and for the first decade of spreadsheets, that was as good as it got. Yes, we recalculate every cell in the document, but at least we only recalculate every cell once.</p><p>Lotus1-2-3实现了我们上面展示的“重新计算所有内容”策略，对于电子表格的第一个十年来说，这已经是最好的结果了。是的，我们重新计算文档中的每个单元格，但至少我们只重新计算每个单元格一次。</p><p>  Great point, header 2. In my three burrito example there’s no reason to recompute  Burrito Price w Ship, because changing the number of burritos we order can’t possibly influence the per-burrito price. In 1989, one of Lotus’ competitors realized this, and created SuperCalc5, presumably naming it after the theory of super burritos at the core of this algorithm. SuperCalc5 recalculated “only cells dependent on changed cells”, which would make updating the burrito count look more like this:</p><p>很好，标题2。在我的三个玉米煎饼例子中，没有理由重新计算玉米煎饼的价格，因为改变我们订购的玉米煎饼的数量不可能影响每个玉米煎饼的价格。1989年，莲花的一个竞争对手意识到了这一点，于是创造了SuperCalc5，大概是根据该算法核心的超级玉米煎饼理论命名的。SuperCalc5重新计算了“只有细胞依赖于改变的细胞”，这使得玉米煎饼的更新数量看起来更像这样：</p><p>  By only updating a cell when one of its inputs changes, we can avoid recalculating  Burrito Price w Ship. In this case, it saves just a single addition, but on larger spreadsheets it can save quite a bit of time! Unfortunately, we now have another problem. Let’s say my friends now want meat burritos, which cost a dollar more, and simultaneously El Farolito adds a $2 fee paid per-order, regardless of how many burritos you order. Before any formula outputs are recalculated, our graph might look like this:</p><p>通过只在单元格的一个输入发生变化时更新单元格，我们可以避免重新计算玉米煎饼价格w Ship。在这种情况下，它只节省了一次添加，但在较大的电子表格中，它可以节省相当多的时间！不幸的是，我们现在有了另一个问题。比方说，我的朋友现在想要肉玉米煎饼，价格高出一美元，同时El Farolito还增加了每单2美元的费用，无论你点了多少玉米煎饼。在重新计算任何公式输出之前，我们的图表可能如下所示：</p><p>  Since there are two updated cells here, we have a problem. Should we recalculate  Burrito Price first, or  Total? Ideally, we first calculate  Burrito Price, notice that its output has changed, then recalculate  Burrito Price w Ship, and finally recalculate  Total. However, if we instead recalculate  Total first, we’ll have to recalculate it a second time once the new $9 burrito price propagates down. If we don’t calculate cells in the right order, this algorithm isn’t better than recalculating the whole document. In some cases, it’s as slow as VisiCalc!</p><p>因为这里有两个更新的单元格，所以我们有问题。我们应该先重新计算玉米煎饼价格，还是总价？理想情况下，我们首先计算玉米煎饼价格，注意它的产量发生了变化，然后重新计算玉米煎饼价格w船，最后重新计算总价格。然而，如果我们首先重新计算Total，那么一旦新的9美元玉米煎饼价格向下传播，我们将不得不重新计算它。如果我们没有按正确的顺序计算单元格，这个算法并不比重新计算整个文档更好。在某些情况下，它的速度和VisiCalc一样慢！</p><p> Clearly, it’s important for us to figure out the right order to update our cells. Broadly, there are two solutions to this problem: dirty marking and topological sorting.</p><p>显然，找出更新细胞的正确顺序对我们来说很重要。大体上，这个问题有两种解决方案：脏标记和拓扑排序。</p><p> This first solution involves marking all cells downstream from an edit as dirty. For instance, when we update  Burrito Price, we would mark the downstream cells  Burrito Price w Ship and  Total as dirty, even before doing any recalculations:</p><p>第一个解决方案涉及将编辑下游的所有单元格标记为脏。例如，当我们更新Burrito Price时，甚至在执行任何重新计算之前，我们都会将下游单元格Burrito Price w Ship和Total标记为脏：</p><p>  Then, in a loop, we find a dirty cell that has no dirty inputs, and recalculate it. When there are no dirty cells left, we’re done! This solves our ordering problem. There’s one downside though — if a cell is recalculated and we find its new output to be the same as its previous output, we’ll still recalculate downstream cells! A little bit of extra logic can avoid actually running the formula trouble in this case, but we unfortunately still waste time marking and unmarking a lot of cells as dirty.</p><p>然后，在循环中，我们找到一个没有脏输入的脏单元格，并重新计算它。当没有肮脏的牢房时，我们就完了！这解决了我们的排序问题。不过，这也有一个缺点--如果重新计算了一个单元格，而我们发现它的新输出与之前的输出相同，那么我们仍然会重新计算下游的单元格！在这种情况下，稍微增加一点逻辑就可以避免实际运行公式的麻烦，但不幸的是，我们仍然浪费时间将许多单元格标记和取消标记为脏的。</p><p> The second solution is topological sorting. If a cell has no inputs, we mark its height as 0. If a cell has inputs, we mark its height as the maximum of the heights of its inputs, plus one. This guarantees all cells have a greater height than any of their inputs, so we just keep track of all cells with a changed input, always choosing the cell with the lowest height to recalculate first:</p><p>第二种解决方案是拓扑排序。如果单元格没有输入，我们将其高度标记为0。如果单元格有输入，我们将其高度标记为其输入高度的最大值加1。这确保了所有单元格的高度都大于它们的任何输入，因此我们只跟踪输入发生更改的所有单元格，始终首先选择高度最低的单元格进行重新计算：</p><p>  In our double-update example,  Burrito Price and  Total would be initially added to the recalculation heap.  Burrito Price has lesser height, and would be recalculated first. Since its output changes, we then would add  Burrito Price w Ship to the recalculation heap, and since it too has less height than  Total, it would be recalculated before we finally recalculate  Total.</p><p>在我们的双重更新示例中，Burrito Price和Total最初将被添加到重新计算堆中。玉米煎饼价格较低，将首先重新计算。由于它的输出发生了变化，因此我们将把Burrito Price w Ship添加到重新计算堆中，并且由于它的高度也小于Total，因此在我们最终重新计算Total之前将重新计算它。</p><p> This has a big advantage over the first solution: no cell is ever marked dirty unless one of its inputs actually change. However, it requires we keep all cells pending recalculation in sorted order. If we use a heap, this results in an  O(n log n) slowdown, so in the worst case, asymptotically slower than Lotus 1-2-3’s strategy of recalculating everything.</p><p>与第一种解决方案相比，这有一个很大的优势：任何细胞都不会被标记为脏的，除非它的一个输入确实发生了变化。但是，它要求我们将所有等待重新计算的单元格按排序顺序保存。如果我们使用堆，这将导致O(Nlogn)减慢，因此在最坏的情况下，比Lotus 1-2-3的重新计算一切的策略渐近慢。</p><p> Modern-day Excel uses  a combination of dirty marking and topological sorting, which you can read more about in their docs.</p><p>现代的Excel使用脏标记和拓扑排序的组合，你可以在他们的文档中阅读更多关于这一点的内容。</p><p>  We’ve now more or less reached the algorithms used in modern-day spreadsheet recalculation. Unfortunately, I suspect there is basically no business case to be made for ever improving it further. The few people with the problem “my Excel spreadsheet is too slow” have already written enough Excel formulas that migration to any other platform is impossible. Fortunately, I have no understanding of business, and so we’re going to look at further improvements anyway.</p><p>我们现在或多或少已经达到了现代电子表格重新计算中使用的算法。不幸的是，我怀疑基本上没有任何商业理由可以继续改进它。有“我的Excel电子表格太慢”问题的少数人已经编写了足够多的Excel公式，以至于不可能移植到任何其他平台。幸运的是，我对商业一无所知，所以我们无论如何都要考虑进一步的改进。</p><p> Beyond caching, one of the cool aspects of a spreadsheet-style computation graph is we can only calculate the cells that we’re interested in. This is sometimes called lazy computation, or demand-driven computation. As a more concrete example, here’s a slightly expanded burrito spreadsheet graph. This example is the same as before, but we’ve added what is best described as “salsa calculations”. Each burrito contains 40 grams of salsa, and we perform a quick multiplication to know how much salsa is in our entire order. In this case, since our order has three burritos, there’s a total of 120 grams of salsa in our entire order.</p><p>除了缓存之外，电子表格样式的计算图的一个很酷的方面是，我们只能计算我们感兴趣的单元格。这有时被称为懒惰计算，或需求驱动计算。作为一个更具体的例子，这里有一个略微扩展的玉米煎饼电子表格图表。这个示例与前面的相同，但是我们添加了最恰当的描述为“salsa计算”。每个墨西哥玉米煎饼含有40克萨尔萨酱，我们进行快速乘法，以知道我们整个订单中有多少萨尔萨酱。在这种情况下，因为我们点的是三个玉米煎饼，所以我们整个订单总共有120克辣酱。</p><p>  Of course, astute readers will have spotted the problem here already: knowing the total weight of salsa in an order is a pretty useless measurement. Who cares that it’s 120 grams? What am I supposed to do with this information?? Unfortunately, a regular spreadsheet would waste cycles calculating  Salsa In Order, even if we don’t want it recalculated most of the time.</p><p>当然，精明的读者可能已经在这里发现了问题：知道一份订单中萨尔萨的总重量是一个相当无用的衡量标准。谁会在乎它有120克呢？我该怎么处理这些信息？？不幸的是，一个常规的电子表格会浪费按顺序计算Salsa的周期，即使我们不希望它在大部分时间内重新计算。</p><p> This is where demand-driven recalculation can help. If we could somehow specify that we’re only interested in the output of  Total, we could only recompute that cell and its dependencies, and skip touching  Salsa In Order and  Salsa Per Burrito. Let’s call  Total an  observed cell, since we’re trying to look at its output. We can also call both  Total and its three dependencies  necessary cells, since they’re necessary to compute some observed cell.  Salsa In Order and  Salsa Per Burrito would be aptly described as  unnecessary.</p><p>这就是需求驱动的重新计算可以提供帮助的地方。如果我们能以某种方式指定我们只对Total的输出感兴趣，那么我们只能重新计算该单元格及其依赖项，并跳过按顺序触及Salsa和按玉米煎饼触及Salsa。让我们称Total为观察到的单元格，因为我们试图查看它的输出。我们也可以称Total及其三个依赖项为必需单元，因为它们是计算某些观察到的单元所必需的。顺序沙拉和玉米煎饼沙拉恰如其分地被描述为不必要的。</p><p> Some folks on the Rust team created the  Salsa framework to solve this problem, clearly naming it after the unnecessary salsa calculations their computers were wasting cycles on. Salsa is really cool, and I’m sure  they can explain how it works better than I can. Very roughly, they use revision numbers to track whether a cell needs recalculation. Any mutation to a formula or input increments the global revision number, and every cell tracks two revisions:  verified_at to track the revision its output was last brought up-to-date, and  changed_at to track the revision its output last actually changed.</p><p>Rust团队中的一些人创建了Salsa框架来解决这个问题，显然是根据他们的计算机浪费周期进行的不必要的Salsa计算来命名的。萨尔萨舞真的很酷，我相信他们能比我解释得更好。粗略地说，他们使用修订号来跟踪单元格是否需要重新计算。公式或输入的任何变化都会增加全局修订号，每个单元格都会跟踪两个修订：verized_at跟踪其输出上一次更新的修订，Changed_at跟踪其输出上一次实际更改的修订。</p><p>  When the user indicates they’d like a fresh value for  Total, we’d first recursively recalculate any cell necessary to  Total, skipping cells if their  last_updated revision is equal to the global revision. Once the dependencies of  Total are up-to-date, we only rerun the actual formula in  Total if either  Burrito Price w Ship or  Num Burrito have a  changed_at revision greater than the  verified_at revision of  Total. This is great for Salsa’s purposes in the rust-analyzer, where simplicity is important and each cell takes a significant amount of time to compute. However, we can see the disadvantages in our burrito graph above — if  Salsa Per Burrito constantly changes, our global revision number will frequently tick up. This will make each observation of  Total walk the three cells necessary to it, even though none of those cells have actually changed. No formulas will be recalculated, but if the graph is large, repeatedly walking all of a cell’s dependencies could get expensive.</p><p>当用户表示他们想要一个新的Total值时，我们首先递归地重新计算Total所需的任何单元格，如果单元格的LAST_UPDATED修订版等于全局修订版，则跳过该单元格。一旦Total的相关性是最新的，如果Burrito Price w Ship或Num Burrito的Changed_at版本大于Total的VERIFIED_AT版本，我们只会重新运行Total中的实际公式。这对于SASA在锈蚀分析仪中的用途非常有用，因为简单很重要，每个细胞都需要大量的时间来计算。然而，我们可以从上面的玉米煎饼图表中看到缺点--如果每个玉米煎饼的萨尔萨不断变化，我们的全球修订号将频繁上升。这将使道达尔的每一次观察都走到它所必需的三个细胞中，即使这些细胞实际上都没有改变。不会重新计算公式，但如果图表很大，重复遍历一个单元格的所有依赖项可能会很昂贵。</p><p>  Instead of inventing new algorithms for demand-driven spreadsheets, what if we instead draw from the two classical spreadsheet algorithms mentioned earlier: dirty marking and topological sorting? As you might imagine, a demand-driven model complicates both of these, but both are still viable.</p><p>与其为需求驱动的电子表格发明新的算法，不如借鉴前面提到的两种经典电子表格算法：脏标记和拓扑排序。正如你可能想象的那样，需求驱动的模式使这两种模式都变得复杂，但这两种模式仍然可行。</p><p> Let’s first look at dirty marking. As before, when we change a cell’s formula, we mark all downstream cells as dirty. So if we update  Salsa Per Burrito, it would look something like this:</p><p>让我们先来看看肮脏的标记。与以前一样，当我们更改单元格的公式时，我们将所有下游单元格标记为脏。因此，如果我们按玉米煎饼更新Salsa，它将如下所示：</p><p>  However, instead of immediately recomputing  all cells that are dirty, we wait for the user to observe a cell. Then we run Salsa’s algorithm on the observed cell, but instead of reverifying dependencies with outdated  verified_at revision numbers, we instead only reverify cells marked as dirty. This is the technique used by  Adapton. You’ll note that when we observe  Total, we’ll find it isn’t dirty, and so we can skip the graph walk that Salsa would have performed!</p><p>然而，我们并不是立即重新计算所有脏的细胞，而是等待用户观察一个细胞。然后，我们在观察到的单元格上运行Salsa的算法，但不是用过时的VERIFIED_AT修订号来验证依赖关系，而是只验证标记为脏的单元格。这是Adapton使用的技术。您会注意到，当我们观察Total时，我们会发现它并不脏，因此我们可以跳过Salsa执行的图形遍历！</p><p> If we instead decide to observe  Salsa In Order, we’ll find it  is marked as dirty, and so we’ll reverify and recompute both  Salsa Per Burrito and  Salsa In Order. Even here, there are benefits over using just revision numbers, since we’ll be able to skip a recursive walk on the still-clean  Num Burritos cell.</p><p>如果我们决定按顺序观察Salsa，我们会发现它被标记为脏的，因此我们将重新检查并重新计算每玉米煎饼的Salsa和按顺序计算的Salsa。即使在这里，只使用修订号也有好处，因为我们可以跳过在仍然干净的Num Burritos单元格上的递归遍历。</p><p> Demand-driven dirty marking performs fantastically when the set of cells we’re trying to observe changes frequently. Unfortunately, this has the same downsides as the dirty marking algorithm from before. If a cell with many downstream cells changes, we may waste a lot of time marking and unmarking cells as dirty, even if their inputs won’t actually have changed when we go to recalculate them. In the worst case, each changes causes us to mark the entire graph as dirty, which would give us the same ~order of magnitude performance as Salsa’s algorithm.</p><p>当我们试图观察的一组细胞频繁变化时，需求驱动的脏标记表现出惊人的效果。不幸的是，这与以前的脏标记算法有相同的缺点。如果一个包含许多下游单元的单元发生变化，我们可能会浪费大量时间来标记和取消标记为脏的单元，即使当我们重新计算它们时，它们的输入实际上并没有改变。在最坏的情况下，每一次更改都会导致我们将整个图标记为脏的，这将给我们带来与Salsa算法相同的~数量级的性能。</p><p> Moving on from dirty marking, we can also adapt topological sorting for demand-driven computations. This is the technique used by Jane Street’s  Incremental library, and requires  major tricks to get right. Before we added demand-driven computations, our topological sorting algorithm used a heap to determine which cell would be recomputed next. But now, we only want to recompute cells that are  necessary. How? We don’t want to walk the entire tree from our observed cells like Adapton, since a complete tree walk defeats the entire purpose of topological sorting, and would give us performance characteristics similar to Adapton.</p><p>除了肮脏的标记，我们还可以调整拓扑排序以适应需求驱动的计算。这是Jane Street的增量图书馆使用的技术，需要一些重要技巧才能正确使用。在添加需求驱动的计算之前，我们的拓扑排序算法使用堆来确定下一步将重新计算哪个单元。但现在，我们只想重新计算必要的单元格。多么?。我们不想从Adapton这样的观察到的单元遍历整棵树，因为完整的树遍历违背了拓扑排序的全部目的，并且会给出与Adapton类似的性能特征。</p><p> Instead, Incremental maintains a set of cells that the user has marked  observed, as well as the set of cells that are  necessary to any observed cell. Whenever a cell is marked observed or unobserved, Incremental walks that cell’s dependencies to make sure the necessary marks are applied correctly. Then, we only add cells to the recalculation heap if they’re marked necessary. In our burrito graph, if only  Total is part of the observed set, changing  Salsa in Order would not result in any walking of the graph, since only necessary cells are recomputed:</p><p>相反，增量维护一组用户已标记为观察到的单元格，以及任何观察到的单元格所必需的一组单元格。每当单元格被标记为观察到或未观察到时，增量遍历该单元格的依赖项以确保正确应用必要的标记。然后，我们只在单元格被标记为必需时才将其添加到重新计算堆中。在我们的玉米煎饼图中，如果只有Total是观察集的一部分，则按顺序更改Salsa不会导致图的任何遍历，因为只重新计算必要的单元格：</p><p>  This solves our problem without eagerly walking the graph to mark cells as dirty! We still have to remember that  Salsa per Burrito is dirty, since if it later becomes necessary, we will need to recompute it. But unlike Adapton’s algorithm, we don’t need to push this single dirty mark down the entire graph.</p><p>这解决了我们的问题，而无需急于遍历图表将单元格标记为脏！我们仍然必须记住，每玉米煎饼的萨尔萨是肮脏的，因为如果以后有必要的话，我们将需要重新计算它。但与Adapton的算法不同的是，我们不需要在整个图表中压下这个单一的污点。</p><p>  Both Adapton and Incremental walk the graph, even when not recomputing cells. Incremental walks the graph upstream when the set of observed cells changes, and Adapton walks the graph downstream when a formula changes. With these small graphs, it may not be immediately apparent that this graph walking is expensive. However, if your graph is large and your cells are relatively cheap to compute — often the case with spreadsheets — you’ll find that most of your costs come from wasted graph walking! When cells are cheap, marking a bit on a cell can cost roughly the same as just recomputing the cell from scratch. So ideally, if we want our algorithm to be substantially faster than computing from scratch, we’ve got to avoid unnecessarily walking the graph as best we can.</p><p>Adapton和Incremental都在图中走动，即使不重新计算单元。当观察到的单元格集合改变时，增量遍历图形的上游，而当公式改变时，Adapton遍历图形的下游。使用这些小图表，可能不会立即看出这种图表遍历是昂贵的。但是，如果您的图表很大，而单元格的计算成本相对较低(通常是电子表格的情况)，您会发现大部分成本来自浪费的图表遍历！当电池价格便宜时，在电池上打上一点记号的成本与从零开始重新计算电池的成本大致相同。因此，理想情况下，如果我们希望我们的算法比从头开始计算的速度快得多，我们必须尽可能避免不必要的遍历图形。</p><p> The more I thought about the problem, the more I realized that they waste time walking the graph in roughly opposite situations. In our burrito graph, let’s imagine cell formulas rarely change, but we rapidly switch between first observing  Total, and then observing  Salsa in Order.</p><p>我越是思考这个问题，就越是意识到他们浪费时间在大相径庭的情况下走马观花。在我们的玉米煎饼图中，让我们设想细胞公式几乎不会改变，但我们会在首先观察Total，然后按顺序观察Salsa之间快速切换。</p><p>  In this case, Adapton will never walk the tree. No inputs are changing, and so we never need to mark anything as dirty. Since nothing is dirty, each observation is cheap as well, since we can simply return the cached value from a clean cell immediately. However, Incremental performs poorly in this example. Even though no values are ever recomputed, Incremental will repeatedly mark and unmark many cells as necessary and unnecessary.</p><p>在这种情况下，Adapton将永远不会在树上行走。没有任何输入会改变，因此我们永远不需要将任何东西标记为脏的。因为没有东西是脏的，所以每个观察也很便宜，因为我们只需从干净的单元格立即返回缓存值。但是，在本例中，增量的性能很差。即使不重新计算任何值，增量也会反复标记和取消标记许多必要和不必要的单元格。</p><p> In the opposite case, let’s imagine a graph where our formulas are rapidly changing, but we don’t change which cells we’re observing. For instance, we could imagine we’re observing  Total while rapidly changing  Burrito Price from  4+4 to  2*4.</p><p>在相反的情况下，让我们想象一个图表，其中我们的公式正在迅速改变，但我们没有改变我们正在观察的细胞。例如，我们可以想象我们正在观察Total，同时将玉米煎饼价格从4+4快速调整为2*4。</p><p>  Just like the previous example, we aren’t really recomputing many cells.  4+4 and  2*4 both equal  8, so ideally we only recompute that one bit of arithmetic when the user makes this change. However, unlike the previous example, Incremental is now the library that avoids tree walking. With Incremental, we’ve cached the fact that  Burrito Price is a necessary cell, and so when it changes, we can recalculate it without walking the graph. With Adapton, we waste time marking  Burrito Price w Ship and  Total as dirty, even though the output of  Burrito Price won’t have changed.</p><p>就像前面的例子一样，我们并没有真正重新计算很多单元。4+4和2*4都等于8，所以理想情况下，当用户进行此更改时，我们只重新计算一位算术。然而，与前一个示例不同的是，增量现在是避免树遍历的库。使用Incremental，我们缓存了这样一个事实，即Burrito Price是一个必要的单元格，因此当它发生变化时，我们可以重新计算它，而不需要遍历图表。使用Adapton，我们浪费时间将Burrito Price w Ship和Total标记为脏，即使Burrito Price的输出不会改变。</p><p> Given each algorithm performs well in the other’s degenerate cases, wouldn’t it be ideal if we could just detect those degenerate cases, and switch to the faster algorithm? This is what I have attempted to do with my own library,  Anchors. Anchors runs both algorithms simultaneously on the same graph! If this sounds wild and unnecessary and overly complicated, that’s probably because it is.</p><p>考虑到每种算法在彼此退化的情况下都表现良好，如果我们只检测那些退化的情况，然后切换到速度更快的算法，那不是很理想吗？这就是我试图用我自己的图书馆Anchors做的事情。Anchors在同一张图上同时运行这两种算法！如果这听起来很疯狂、不必要而且过于复杂，那很可能是因为它确实如此。</p><p> In many cases, Anchors follows Incremental’s algorithm exactly, which avoids Adapton’s degenerate case above. But when cells are marked as unobserved, its behavior diverges slightly. Let’s look at what happens. We start with marking  Total as observed:</p><p>在许多情况下，Anchors完全遵循Incremental的算法，避免了Adapton的上述退化情况。但当细胞被标记为未被观察到时，其行为略有不同。让我们来看看发生了什么。我们首先将Total标记为观察到的：</p><p>  If we then mark  Total as unobserved and  Salsa in Order as observed, the traditional Incremental algorithm would alter the graph to look like this, walking through every cell in the process:</p><p>如果我们随后将Total标记为未观察到，并将Salsa标记为观察到的顺序，则传统的增量算法会将图表更改为如下所示，遍历过程中的每个单元格：</p><p>  Anchors also walks every cell for this change, but instead produces a graph that looks like this:</p><p>锚点还会遍历此更改的每个单元格，但会生成如下所示的图形：</p><p>  Note the “clean” flags! When a cell is no longer necessary, we mark it as “clean”. Let’s look at what happens when we switch from observing  Salsa in Order to  Total:</p><p>注意“干净”的旗帜！当一个细胞不再需要时，我们将其标记为“干净”。让我们看看从观察Salsa转换到Total时会发生什么：</p><p>  That’s right — our graph now has  no necessary cells. If a cell has a “clean” flag, we never mark it as observed. At this point, no matter what cell we mark as observed or unobserved, Anchors will never waste time walking the graph — it knows that none of the inputs have changed.</p><p>没错，我们的图表现在没有必要的单元格。如果一个单元格有一个“干净”的标志，我们永远不会把它标记为观察到的。此时，无论我们将哪个单元格标记为观察到或未观察到，Anchors都不会浪费时间遍历图表-它知道所有输入都没有更改。</p><p> Looks like there’s a discount at El Farolito! Let’s drop  Burrito Price by a dollar. How does Anchors know  Total needs to be recomputed? Before we recompute any formulas, let’s look at how Anchors will see the graph right after we change just  Burrito Price, before recomputing anything:</p><p>看来El Farolito有折扣！我们把墨西哥卷饼降价一美元吧。主播如何知道需要重新计算总数？在重新计算任何公式之前，让我们先看看Anchors在我们只更改了Burrito Price之后，在重新计算任何东西之前将如何查看图表：</p><p>  If a cell has a clean flag, we run the traditional Adapton algorithm on it, eagerly marking downstream cells as dirty. When we later run the Incremental algorithm, we can quickly tell that there is an observed cell marked as dirty, and know we need to recompute its dependencies. After that’s finished, the final graph will look like this:</p><p>如果单元格有干净标志，我们就会对其运行传统的Adapton算法，急切地将下游单元格标记为脏的。当我们稍后运行增量算法时，我们可以快速判断出有一个观察到的单元格被标记为脏，并且知道我们需要重新计算它的依赖项。完成后，最终的图形将如下所示：</p><p>  We only recompute cells if they’re necessary, so whenever we recompute a dirty cell, we also mark it as necessary. At a high level, you can imagine these three cell states form a looping state machine:</p><p>我们只在必要的时候重新计算单元格，所以每当我们重新计算脏乱的单元格时，我们也会将其标记为必要的。在较高级别上，您可以想象这三个单元状态形成一个循环状态机：</p><p>  On necessary cells, we run the Incremental’s topological sorting algorithm. On unnecessary cells, we run the Adapton algorithm.</p><p>对于需要的单元格，我们运行增量的拓扑排序算法。对于不必要的单元格，我们运行Adapton算法。</p><p>  I’d like to finish up by answering a final question: so far, we’re been discussing the many problems the demand-driven model causes for our recomputation strategy. But the problems aren’t just for the algorithm: there are syntactic problems to solve too. For instance, let’s make a spreadsheet to select a burrito emoji for our customer. We’d write an  IF statement in the spreadsheet like this:</p><p>最后，我想回答最后一个问题：到目前为止，我们一直在讨论需求驱动模式给我们的重新计算策略带来的许多问题。但问题不仅仅在于算法：还有语法问题需要解决。例如，让我们制作一个电子表格，为我们的客户选择一个玉米煎饼表情符号。我们会在电子表格中编写一条if语句，如下所示：</p><p>  Because traditional spreadsheets aren’t demand-driven, we can compute  B1,  B2, and  B3 in any order, so long as we compute our  IF cell after all three inputs are ready. In a demand-driven world however, if we can calculate the value of  B1 first, we can peek at the value to know which of  B2 or  B3 we need to recalculate. Unfortunately, a traditional spreadsheet’s  IF has no way to express this!</p><p>因为传统的电子表格不是需求驱动的，所以我们可以按任何顺序计算B1、B2和B3，只要我们在所有三个输入都准备好之后计算IF单元即可。然而，在一个需求驱动的世界里，如果我们能先计算B1的值，我们就可以窥视它的值，从而知道我们需要重新计算B2或B3中的哪一个。不幸的是，传统电子表格的IF无法表达这一点！</p><p> The problem:  B2 simultaneously references cell  B2 and retrieves its value, 🥦. Most demand-driven libraries mentioned in this post instead explicitly distinguish between a reference to a cell and the act of retrieving its actual value. In Anchors, we call this cell reference an  Anchor. Much like a burrito in real life wraps a bunch of ingredients together, the  Anchor&lt;T&gt; type wraps  T — which I suppose makes our vegi burrito cell  Anchor&lt;Burrito&gt;, a sort of ridiculous burrito of burritos. Functions can pass around our  Anchor&lt;Burrito&gt; as much as they’d like — it’s only when they actually unwrap the burrito to access the  Burrito inside that we create a dependency edge in our graph, indicating to the recomputation algorithm that the cell may be necessary and need recomputing.</p><p>问题：B2同时引用单元格B2并检索其值🥦。这篇文章中提到的大多数需求驱动库都明确区分了对单元的引用和检索其实际值的行为。在Anchors中，我们将此单元格引用称为Anchor。就像现实生活中的玉米煎饼一样，Anchor&lt；T&gt；T型玉米煎饼包裹着T--我想这就是我们的素食玉米煎饼细胞Ancho&lt；Burrito&gt；，一种可笑的玉米煎饼。函数可以随心所欲地传递Anchor&lt；Burrito&&gt;-只有当它们真正打开玉米煎饼以访问其中的玉米煎饼时，我们才会在图中创建依赖边，向重新计算算法表明该单元格可能是必需的，需要重新计算。</p><p> The approach taken by Salsa and Adapton is to use function calls and normal control flow as a way to unwrap these values. For instance, in Adapton, we might write our “Burrito for Customer” cell something like this:</p><p>Salsa和Adapton采取的方法是使用函数调用和正常控制流作为展开这些值的一种方式。例如，在Adapton中，我们可能会将“Burrito for Customer”单元格写成这样：</p><p>  By distinguishing between a cell reference ( vegi_burrito here) and the act of unwrapping its value ( get!), Adapton can piggy-back on top of Rust’s control flow operators like  if. This is a great solution! However, a little bit of magical global state is needed to correctly connect the  get! calls to the  cell! that needs recomputing when  is_vegetarian changes. The approach I’ve taken with Anchors, inspired by Incremental, is a slightly less magical system. Similar to a pre-async/await  Future, Anchors allows you to use operations like  map and  then on an  Anchor&lt;T&gt;. For instance,</p><p>通过区分单元格引用(这里是vegi_burrito)和展开其值的行为(get！)，Adapton可以利用Rust的控制流运算符(如if)。这是一个很棒的解决方案！然而，需要一点神奇的全局状态才能正确连接GET！给手机打电话！当素食改变时，这需要重新计算。我对Anchors采取的方法，灵感来自增量，是一个稍微不那么神奇的系统。与预异步/等待未来类似，Anchors允许您使用MAP等操作，然后在Anchor&lt；T&gt；上使用。例如,。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lord.io/blog/2020/spreadsheets/">https://lord.io/blog/2020/spreadsheets/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/计算/">#计算</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/单元格/">#单元格</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033135.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a866e392e404a3752e927e6b0eb2142a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033135.html">基于石墨烯的存储电阻器在基于大脑的计算中显示出希望</a></div><span class="my_story_list_date">2020-11-4 15:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032753.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b7667a830f6856680ac19a31ff719691.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032753.html">覆盆子PI 400</a></div><span class="my_story_list_date">2020-11-2 17:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032748.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b7667a830f6856680ac19a31ff719691.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032748.html">覆盆子PI 400</a></div><span class="my_story_list_date">2020-11-2 17:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029769.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2b6ad8c176f8976f889d1f4a26d8f66d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029769.html">新的Raspberry Pi计算模块4回顾和基准</a></div><span class="my_story_list_date">2020-10-19 20:0</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>