<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>纪律不成比例</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">纪律不成比例</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 09:02:19</div><div class="page_narrow text-break page_content"><p>If programmers were just more disciplined, more  professional, they’d write better software. All they need is a  code of conduct telling them how to work like those of us who’ve worked it out.</p><p>如果程序员更有纪律，更专业，他们会写出更好的软件。他们所需要的只是一份行为准则，告诉他们如何像我们这些已经解决问题的人一样工作。</p><p> The above statement is true, which is a good thing for those of us interested in improving the state of software and in helping our fellow professionals to improve their craft. However, it’s also very difficult and inefficient to apply, in addition to being entirely unnecessary. In the common parlance of our industry, “discipline doesn’t scale”.</p><p>上面的说法是正确的，这对于我们中那些有兴趣改善软件状态和帮助我们的同行改进他们的技术的人来说是一件好事。然而，除了完全没有必要之外，申请它也是非常困难和低效的。用我们这个行业的通俗说法来说，“纪律不成比例”。</p><p> Consider the trajectory of object lifecycle management in the Objective-C programming language, particularly the NeXT dialect. Between 1989 and 1995, the dominant way to deal with the lifecycle of objects was to use the  +new and  -free methods, which work much like  malloc/free in C or  new/delete in C++. Of course it’s  possible to design a complex object graph using this ownership model, it just needs discipline, that’s all. Learn the heuristics that the experts use, and the techniques to ensure correctness, and get it correct.</p><p>考虑Objective-C编程语言中对象生命周期管理的轨迹，特别是下一种方言。在1989到1995年间，处理对象生命周期的主要方法是使用+new和-free方法，它们的工作方式与C中的malloc/free或C++中的new/delete非常相似。当然，使用这种所有权模型设计复杂的对象图是可能的，它只需要纪律，仅此而已。学习专家使用的启发式方法，以及确保正确性的技术，并使其正确。</p><p> But you know what’s better? Not having to get that right. So around 1994 people introduced new tools to do it an easier way: reference counting. With NeXTSTEP Mach Kit’s  NXReference protocol and OpenStep’s  NSObject, developers no longer need to know when  everybody in an app is done with an object to destroy it. They can indicate when a reference is taken and when it’s relinquished, and the object itself will see when it’s no longer used and free itself. Learn the heuristics and techniques around auto releasing and unretained references, and get it correct.</p><p>但你知道什么更好吗？不需要做对这件事。因此，大约在1994年，人们引入了新的工具，以更简单的方式完成这项工作：引用计数。有了NeXTSTEP Mach Kit的NXReference协议和OpenStep的NSObject，开发人员不再需要知道应用程序中的每个人何时都完成了销毁它的对象。它们可以指示何时接受引用和何时放弃引用，对象本身将看到它何时不再使用并释放自己。学习关于自动释放和未保留引用的启发式方法和技巧，并使其正确。</p><p> But you know what’s better? Not having to get that right. So a couple of other tools were introduced, so close together that they were probably developed in parallel[*]: Objective-C 2.0 garbage collection (2006) and Automatic Reference Counting (2008). ARC “won” in popular adoption so let’s focus there: developers no longer need to know exactly when to retain, release, or autorelease objects. Instead of describing the edges of the relationships, they describe the  meanings of the relationships and the compiler will automatically take care of ownership tracking. Learn the heuristics and techniques around weak references and the “weak self” dance, and get it correct.</p><p>但你知道什么更好吗？不需要做对这件事。因此，还引入了其他几个工具，它们非常接近，很可能是并行开发的[*]：Objective-C2.0垃圾收集(2006)和自动引用计数(2008)。ARC在流行的采用中“赢了”，所以让我们把重点放在这一点上：开发人员不再需要确切地知道何时保留、释放或自动释放对象。它们描述关系的含义，而不是描述关系的边缘，编译器将自动负责所有权跟踪。学习关于弱引用和“弱自我”舞蹈的启发式和技巧，并使其正确。</p><p> [*] I’m ignoring here the significantly earlier integration of the Boehm conservative GC with Objective-C, because so did everybody else. That in itself is an important part of the technology adoption story.</p><p>[*]我在这里忽略了Boehm保守GC与Objective-C明显更早的集成，因为其他人也是如此。这本身就是技术采用故事的重要组成部分。</p><p> But you know what’s better? You get the idea. You see similar things happen in other contexts: for example C++’s move from  new/delete to smart pointers follows a similar trajectory over a similar time. The reliance on an entire programming community getting some difficult rules right, when faced with the alternative of using different technology  on the same computer that follows the rules for you, is a tough sell.</p><p>但你知道什么更好吗？你明白我的意思。您可以在其他上下文中看到类似的事情发生：例如，C++从new/delete转移到智能指针的过程在类似的时间内遵循类似的轨迹。当面对在同一台计算机上使用不同技术并遵循规则的替代方案时，依赖整个编程社区正确处理一些困难的规则是很难说服的。</p><p> It seems so simple: computers exist to automate repetitive information-processing tasks. Requiring programmers who have access to computers to recall and follow repetitive information processes is wasteful, when the computer can do that. So give those tasks to the computers.</p><p>这看起来很简单：计算机的存在是为了使重复的信息处理任务自动化。当计算机可以做到这一点时，要求能够访问计算机的程序员回忆和跟踪重复的信息过程是浪费的。所以把这些任务交给计算机。</p><p> And yet, for some people the problem with software isn’t a lack of automation but a lack of discipline. Software would be better if only people knew the rules, honoured them, and slowed themselves down so that instead of cutting corners they just chose to ignore important business milestones instead. Back in my day, everybody knew “no Markdown around town” and “don’t code in an IDE after Labour Day”, but now the kids do whatever they want. The motivations seem different, and I’d like to sort them out.</p><p>然而，对一些人来说，软件的问题不是缺乏自动化，而是缺乏纪律。如果人们知道规则，遵守规则，放慢脚步，而不是偷工减料，而只是选择忽略重要的业务里程碑，软件会更好。在我那个时代，每个人都知道“在镇上没有降价”和“劳动节后不要在IDE中编写代码”，但现在孩子们想做什么就做什么。动机似乎不同，我想把它们理清。</p><p> Let’s start with hazing. A lot of the software industry suffers from “I had to go through this, you should too”. Look at software engineering interviews, for example. I’m not sure whether anybody actually believes “I had to deal with carefully ensuring NUL-termination to avoid buffer overrun errors so you should too”, but I do occasionally still hear people telling less-experienced developers that they should learn C to learn more about how their computer works.  Your computer is not a fast PDP-11, all you will learn is how the C virtual machine works.</p><p>让我们从欺凌开始吧。软件行业的很多人都在遭受“我不得不经历这些，你也应该经历这些”的困扰。例如，看看软件工程面试。我不确定是否有人真的相信“我必须小心地确保NUL终止以避免缓冲区溢出错误，所以您也应该相信”，但我偶尔仍听到有人告诉经验较少的开发人员，他们应该学习C来更多地了解他们的计算机是如何工作的。您的计算机不是快速的PDP-11，您将学到的只是C虚拟机的工作原理。</p><p> Just as Real Men Don’t Eat Quiche, so  real programmers don’t use Pascal. Real Programmers use FORTRAN. This motivation for sorting discipline from rabble is based on the idea that if it isn’t at least as hard as it was when  I did this, it isn’t hard enough. And that means that the goalposts are movable, based on the orator’s experience.</p><p>就像真正的男人不吃乳蛋饼一样，真正的程序员也不使用Pascal。真正的程序员使用FORTRAN。这种将纪律与乌合之众区分开来的动机是基于这样一种想法，即如果它不像我做这件事时那样难，那就不够难。这意味着，根据演说家的经验，球门柱是可移动的。</p><p> This is often related to the  term of their experience: you don’t need TypeScript to write good React Native code, just Javascript and some discipline. You don’t need React Native to write good front-end code, just JQuery and some discipline. You don’t need JQuery…</p><p>这通常与他们的经验有关：您不需要输入脚本来编写好的响应原生代码，只需要Javascript和一些规则即可。要编写好的前端代码，您不需要Reaction Native，只需要JQuery和一些规则即可。您不需要JQuery…。</p><p> But along with the term of experience goes the breadth. You see, the person who learned reference counting in 1995 and thinks that you can only  really understand programming if you manually type out your own reference-changing events, presumably didn’t go on to use garbage collection in Java in 1996. The person who thinks you can only  really write correct software if every case is accompanied by a unit test presumably didn’t learn Eiffel. The person who thinks that you can only  really design systems if you use the Haskell type system may not have tried OCaml. And so on.</p><p>但伴随着经验的术语，广度也随之消失。您知道，1995年学习引用计数的人认为只有手动键入自己的引用更改事件才能真正理解编程，他大概在1996年没有继续使用Java中的垃圾收集。那个认为只有在每个案例都伴随着单元测试的情况下才能真正编写正确软件的人，大概没有学过埃菲尔。认为只有使用Haskell类型的系统才能真正设计系统的人可能没有尝试过OCaml。诸若此类。</p><p> The conclusion is that for this variety of disciplinarian, the appropriate character and quantity of discipline is whatever they had to deal with at some specific point in their career. Probably a high point: after they’d got over the tricky bits and got productive, and after you kids came along and ruined everything.</p><p>结论是，对于这类纪律人员来说，他们在职业生涯的某个特定阶段必须处理的任何事情，都应该具有适当的纪律性质和数量。可能是一个高潮：在他们克服了棘手的部分并变得富有成效之后，在你们这些孩子出现并毁了一切之后。</p><p> Sometimes the reason for suggesting the disciplined approach is entomological in nature, as in the case of the eusocial insect the “performant” which, while not a real word, exists in greater quantities in older software than in newer software, apparently. The performant is capable of making software faster, or use less memory, or more concurrent, or less dependent on I/O: the specific characteristics of the performant depend heavily on context.</p><p>有时，提出这种有纪律的方法的理由本质上是昆虫学的，就像“表演者”这种真社会昆虫的例子，它虽然不是一个真正的词，但显然在旧软件中比在新软件中存在的数量更多。Performant能够使软件更快，或者使用更少的内存，或者更多的并发，或者更少地依赖I/O：Performant的特定特征在很大程度上依赖于上下文。</p><p> The performant is often not talked about in the same sentences as its usual companion species, the irrelevant. Yes, there may be opportunities to shave a few percent off the runtime of that algorithm by switching from the automatic tool to the manual, disciplined approach, but does that matter (yet, or at all)? There are software-construction domains where specific performance characteristics are desirable, indeed that’s true across a lot of software. But it’s typical to focus performance-enhancing techniques on the bits where they enhance performance that needs enhancing, not to adopt them across the whole system on the basis that it was better when everyone worked this way. You might save a few hundred cycles writing native software instead of using a VM for that UI method, but if it’s going to run after a network request completes over EDGE then trigger a 1/3s animation, nobody will notice the improvement.</p><p>表演者通常不会和它通常的同伴--无关紧要的人--在同一句话里被谈论。是的，通过从自动工具切换到手动、有纪律的方法，可能会有机会将该算法的运行时间减少几个百分点，但这重要吗(目前或根本不重要)？有一些软件构建领域需要特定的性能特征，事实上，在很多软件中都是如此。但是，典型的做法是将性能增强技术集中在需要增强性能的BIT上，而不是在每个人都这样工作更好的基础上在整个系统中采用它们。编写本机软件可能会节省数百个周期，而不是将VM用于该UI方法，但是如果它要在网络请求在EDGE上完成之后运行，然后触发1/3秒动画，没有人会注意到改进。</p><p> Anyway, whatever the source, the problem with calls for discipline is that there’s no strong motivation to  become more disciplined. I can use these tools, and my customer is this much satisfied, and my employer pays me this much. Or I can learn from you how I’m  supposed to be doing it, which will slow me down, for…your satisfaction? So you know I’m doing it the way it’s supposed to be done? Or so that I can tell everyone else that they’re doing it wrong, too? Sounds like a great deal.</p><p>无论从何而来，呼吁纪律的问题在于没有强烈的动机去变得更有纪律。我可以使用这些工具，我的客户非常满意，我的雇主付给我这么多钱。或者我可以从你那里学到我应该怎么做，这会减慢我的速度，对于…来说。你满意吗？所以你知道我是按照应该做的方式来做的？或者这样我就可以告诉其他人他们也做错了？听起来挺划算的。</p><p> Therefore discipline doesn’t scale. Whenever you ask some people to slow down and think harder about what they’re doing, some fraction of them will. Some will wonder whether there’s some other way to get what you’re peddling, and may find it. Some more will not pay any attention. The dangerous ones are the ones who thought they  were paying attention and yet still end up not doing the disciplined thing you asked for: they either torpedo your whole idea or turn it into not doing the thing (see OOP, Agile, Functional Programming). And still more people, by far the vast majority, just weren’t listening at all, and you’ll never reach them.</p><p>因此，纪律是不成比例的。每当你要求一些人放慢脚步，更努力地思考他们正在做的事情时，他们中的一小部分会这样做。有些人会想知道有没有其他方法可以买到你在兜售的东西，而且可能会找到。更多的人不会在意。危险的人是那些认为他们在关注，但最终仍然没有做你要求的有纪律的事情的人：他们要么破坏了你的整个想法，要么把它变成了不做事情(参见OOP、敏捷、函数式编程)。还有更多的人，到目前为止，绝大多数人根本没有在听，你永远也无法联系到他们。</p><p> Let’s flip this around. Let’s look at where we  need to be disciplined, and ask if there are gaps in the tool support for software engineers. Some people want us to always write a failing test and make it pass before adding any code (or want us to write a passing test and revert our changes if it accidentally fails): does that mean our tools should not let us write code for which there’s no test? Does the same apply for acceptance tests? Some want us to refactor mercilessly; does that mean our design tools should always propose more parsimonious alternatives for passing the same tests? Some say we should get into the discipline of writing code that always reveals its intent: should the tools make a crack at interpreting the intention of the code-as-prose?</p><p>让我们把这件事翻过来。让我们看看我们需要在哪里受到约束，并询问一下在对软件工程师的工具支持方面是否存在差距。有些人希望我们总是编写失败的测试并使其在添加任何代码之前通过(或者希望我们编写通过的测试并在意外失败时恢复我们的更改)：这是否意味着我们的工具不应该让我们编写没有测试的代码？验收测试也是如此吗？有些人希望我们毫不留情地重构；这是否意味着我们的设计工具应该总是提出更简约的替代方案来通过相同的测试？有些人说，我们应该养成编写总是揭示其意图的代码的纪律：这些工具是否应该尝试将代码的意图解释为散文？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.sicpers.info/2020/10/discipline-doesnt-scale/">https://www.sicpers.info/2020/10/discipline-doesnt-scale/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/纪律/">#纪律</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/doesn/">#doesn</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>