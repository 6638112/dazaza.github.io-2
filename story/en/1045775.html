<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Knuth-Morris-Pratt字符串搜索算法：不含DFA的版本 Knuth-Morris-Pratt string-searching algorithm: DFA-less version</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Knuth-Morris-Pratt string-searching algorithm: DFA-less version<br/>Knuth-Morris-Pratt字符串搜索算法：不含DFA的版本 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-22 19:48:36</div><div class="page_narrow text-break page_content"><p>unsigned search_ok (char *s, unsigned len){ if (len&lt;2) return len; // not found for (unsigned i=0; i&lt;len; i++) { if (s[i]==&#39;o&#39; &amp;&amp; s[i+1]==&#39;k&#39;) return i; // found }; return len; // not found};</p><p>unsigned search_ok（char * s，unsigned len）{如果（len＆lt; 2）返回len; //找不到（unsigned i = 0; i <len; i ++）的{如果（s [i] ==＆＃39; o＆＃39;＆amp; s s [i + 1] ==＆＃39; k＆＃39;）返回i; //找到}; len返回// 未找到};</p><p> You see, there are two memory accesses per one character of the input string.Hence, the total number of all memory accesses can be len*2 at worst.</p><p> 您会看到，输入字符串的每个字符有两个内存访问权限，因此，最坏情况下所有内存访问的总数可能为len * 2。</p><p> Is it possible to reduce that number? Yes. In the following example, we have only one single memory access per character:</p><p> 可以减少这个数字吗？是。在以下示例中，每个字符只有一个内存访问权限：</p><p> unsigned search_ok (char *s, unsigned len){ if (len&lt;2) return len; // not found bool seen_o=false; for (unsigned i=0; i&lt;len-1; i++) { char ch=s[i]; // this is single read operation if (ch==&#39;o&#39;) seen_o=true; else if (seen_o &amp;&amp; ch==&#39;k&#39;) return i-1; // found else seen_o=false; // reset }; return len; // not found};</p><p> unsigned search_ok（char * s，unsigned len）{如果（len＆lt; 2）返回len; //找不到bool seen_o = false; for（unsigned i = 0; i＆lt; len-1; i ++）{char ch = s [i]; //如果（ch ==＆＃39; o＆＃39;）seen_o = true;这是一次读取操作否则（seen_o＆amp; ch ==＆＃39; k＆＃39;）返回i-1; //找到其他seen_o = false; // 重启 }; len返回// 未找到};</p><p>  Can we extend that method to any 3-character strings? Let&#39;s write a function that searches for the &#39;eel&#39; string.(For the non-English speakers: this is indeed a word.  Some kind of fish.)</p><p>  我们可以将该方法扩展到任何3个字符的字符串吗？让我们编写一个搜索鳗鱼的函数。字符串。（对于非英语使用者：这确实是一个词。有些鱼。）</p><p> We will use the &#39;seen&#39; variable, reflecting, how many characters of the sought string we&#39;ve already seen:</p><p> 我们将使用“已见”变量，反映了我们已经看到的所查找字符串的多少个字符：</p><p> unsigned search_eel (char *s, unsigned len){ if (len&lt;3) return len; // not found unsigned seen=0; for (unsigned i=0; i&lt;len; i++) { char ch=s[i]; // this is single read operation if (seen==0 &amp;&amp; ch==&#39;e&#39;) seen=1; else if (seen==1 &amp;&amp; ch==&#39;e&#39;) seen=2; else if (seen==2 &amp;&amp; ch==&#39;l&#39;) return i-2; // found else seen=0; // reset } return len; // not found};</p><p> unsigned search_eel（c​​har * s，unsigned len）{如果（len＆lt; 3）返回len; //未找到unsigned seen = 0; for（unsigned i = 0; i <len; i ++）{char ch = s [i]; //如果（seen == 0＆amp;＆amp; ch ==＆＃39; e＆＃39;）看到= 1，则这是单次读取操作；否则，如果（seen == 1＆amp;＆ch; ==＆＃39; e＆＃39;）see = 2;否则，如果（seen == 2＆amp;＆ch; ==＆＃39; l＆＃39;）返回i-2; //发现其他人看过= 0; // reset} return len; // 未找到}; </p><p> But this implementation has a bug.To find it, i&#39;ll use  CBMC, the excellent tool, that can verify if a C function is equivalent to another function.(To read more about verification:  SAT/SMT by Example.)</p><p>但是此实现存在一个错误：要找到它，我将使用出色的工具CBMC，该工具可以验证C函数是否等效于另一个函数（要了解有关验证的更多信息，请参见SAT / SMT示例）。</p><p>  unsigned search_eel_brute (char *s, unsigned len){ if (len&lt;3) return len; // not found for (unsigned i=0; i&lt;len-2; i++) { if (s[i]==&#39;e&#39; &amp;&amp; s[i+1]==&#39;e&#39; &amp;&amp; s[i+2]==&#39;l&#39;) return i; }; return len; // not found};...void check(){ unsigned len=LEN; char s[len]; __CPROVER_assert (search_eel_brute(s, len)==search_eel(s, len), &#34;assert&#34;);};</p><p>  unsigned search_eel_brute（char * s，unsigned len）{如果（len＆lt; 3）返回len； //找不到（unsigned i = 0; i＆lt; len-2; i ++）{如果（s [i] ==＆＃39; e＆＃39;＆amp;＆s s [i + 1] ==＆＃ 39; e＆amp;＆amp; s s [i + 2] ==＆＃39; l＆＃39;）返回i; }; len返回//未找到}; ...避免check（）{unsigned len = LEN; char s [len]; __CPROVER_assert（search_eel_brute（s，len）== search_eel（s，len），＆＃34; assert＆＃34;）;};</p><p> % cbmc --trace --function check -DLEN=4 kmp_eel2.c...** Results:[check.assertion.1] assert: FAILURETrace for check.assertion.1:...State 21 file kmp_eel2.c line 41 function check thread 0---------------------------------------------------- s={ &#39;e&#39;, &#39;e&#39;, &#39;e&#39;, &#39;l&#39; } ({ 01100101, 01100101, 01100101, 01101100 })...</p><p> ％cbmc --trace --function check -DLEN = 4 kmp_eel2.c ... **结果：[check.assertion.1]断言：FAILURETrace for check.assertion.1：...状态21文件kmp_eel2.c行41功能检查线程0 --------------------------------------------- ------- s = {＆＃39; e＆＃39 ;、＆＃39; e＆＃39 ;、＆＃39; e＆＃39 ;、＆＃39; l＆＃39; }（{01100101、01100101、01100101、01101100}）...</p><p> It failed for the string &#34;eeel&#34;.After some thinking, we can find a problem.If a third character isn&#39;t &#39;l&#39;, but &#39;e&#39;, we are in the middle of a long string of &#39;e&#39; characters.So if seen==2 and the input character isn&#39;t &#39;l&#39;, but &#39;e&#39;, we shouldn&#39;t advance the &#39;seen&#39; variable:</p><p> 经过一番思考后，我们发现一个问题，如果第三个字符不是＆＃39; e＆＃39; ;，我们处于一长串＆＃39; e＆＃39;的中间字符。因此，如果看到== 2并且输入的字符不是＆＃39; l，而是＆quot; e＆＃39 ;，则我们不应该提前＆＃39; seen＆＃ 39;变量：</p><p> ... if (seen==0 &amp;&amp; ch==&#39;e&#39;) seen=1; else if (seen==1 &amp;&amp; ch==&#39;e&#39;) seen=2; else if (seen==2 &amp;&amp; ch==&#39;l&#39;) return i-2; // found else if (seen==2 &amp;&amp; ch==&#39;e&#39;) // fix seen=2; // fix else seen=0; // reset...</p><p> ...如果（seen == 0＆amp;＆ch; ==＆＃39; e＆＃39;）看到= 1;否则，如果（seen == 1＆amp;＆ch; ==＆＃39; e＆＃39;）see = 2;否则，如果（seen == 2＆amp;＆ch; ==＆＃39; l＆＃39;）返回i-2; //发现是否为（seen == 2＆amp;＆amp; ch ==＆＃39; e＆＃39;）// //修复seen = 2; //修复else see = 0; // 重启...</p><p>  #!/bin/bashfor i in $( seq 0 15 ); do #echo $i cbmc --trace --function check -DLEN=$i kmp_eel2.cdone</p><p>  ＃！/ bin / bashfor i in $（seq 0 15）;做#echo $ i cbmc --trace --function check -DLEN = $ i kmp_eel2.cdone</p><p>  The &#34;cocos&#34; substring is much more problematic.But fixing it with the help of CBMC is a great programming exercise.</p><p>  ＆＃34; cocos＆＃34; substring的问题要多得多。但是在CBMC的帮助下进行修复是一项很棒的编程工作。 </p><p> unsigned search_cocos_brute (char *s, unsigned len){ if (len&lt;5) return len; // not found for (unsigned i=0; i&lt;len-4; i++) { if (s[i]==&#39;c&#39; &amp;&amp; s[i+1]==&#39;o&#39; &amp;&amp; s[i+2]==&#39;c&#39; &amp;&amp; s[i+3]==&#39;o&#39; &amp;&amp; s[i+4]==&#39;s&#39;) return i; // found }; return len; // not found};unsigned search_cocos_naive (char *s, unsigned len){ if (len&lt;5) return len; // not found unsigned seen=0; for (unsigned i=0; i&lt;len; i++) { char ch=s[i]; // this is single read operation if (seen==0 &amp;&amp; ch==&#39;c&#39;) seen=1; else if (seen==1 &amp;&amp; ch==&#39;o&#39;) seen=2; else if (seen==2 &amp;&amp; ch==&#39;c&#39;) seen=3; else if (seen==3 &amp;&amp; ch==&#39;o&#39;) seen=4; else if (seen==4 &amp;&amp; ch==&#39;s&#39;) return i-4; // found else seen=0; // reset } return len; // not found};void check(){ unsigned len=LEN; char s[len]; __CPROVER_assert (search_cocos_brute(s, len)==search_cocos_naive(s, len), &#34;assert&#34;);};</p><p>unsigned search_cocos_brute（char * s，unsigned len）{如果（len＆lt; 5）返回len； //找不到（unsigned i = 0; i＆lt; len-4; i ++）{如果（s [i] ==＆＃39; c＆＃39;＆amp;＆amp; s [i + 1] ==＆＃ 39; o＆amp; s s [i + 2] ==＆＃39; c＆＃39;＆amp; s s [i + 3] ==＆＃39; o＆＃39;＆amp; s [i + 4] ==＆＃39; s＆＃39;）返回i; //找到}; len返回//找不到}}; unsigned search_cocos_naive（char * s，unsigned len）{如果（len＆lt; 5）返回len; //未找到unsigned seen = 0; for（unsigned i = 0; i <len; i ++）{char ch = s [i]; //如果（seen == 0＆amp;＆amp; ch ==＆＃39; c＆＃39;）看到= 1，则这是单次读取操作；否则，如果（seen == 1＆amp;＆ch; ==＆＃39; o＆＃39;）看到= 2;否则，如果（seen == 2＆amp;＆ch; ==＆＃39; c＆＃39;）see = 3;否则，如果（seen == 3＆amp; ch ==＆＃39; o＆＃39;）看到= 4;否则（seen == 4＆amp;＆ch; ==＆＃39; s＆＃39;）返回i-4; //发现其他人看过= 0; // reset} return len; //未找到};避免check（）{unsigned len = LEN; char s [len]; __CPROVER_assert（search_cocos_brute（s，len）== search_cocos_naive（s，len），＆＃34; assert＆＃34;）;};</p><p>  % cbmc --trace --function check -DLEN=6 kmp_cocos.c...** Results:[check.assertion.1] assert: FAILURETrace for check.assertion.1:...State 21 file kmp_cocos.c line 47 function check thread 0---------------------------------------------------- s={ &#39;c&#39;, &#39;c&#39;, &#39;o&#39;, &#39;c&#39;, &#39;o&#39;, &#39;s&#39; } ({ 01100011, 01100011, 01101111, 01100011, 01101111, 01110011 })...</p><p>  ％cbmc --trace --function check -DLEN = 6 kmp_cocos.c ... **结果：[check.assertion.1]断言：FAILURETrace for check.assertion.1：...陈述21个文件kmp_cocos.c行47功能检查线程0 --------------------------------------------- ------- s = {＆＃39; c＆＃39 ;,＆＃39; c＆＃39 ;,＆＃39; o＆＃39 ;,＆＃39; c＆＃39 ;,＆＃39; o＆＃39;，＆＃39; }（{01100011、01100011、01101111、01100011、01101111、01110011}）...</p><p>  Here is the fix: if the first &#39;c&#39; is repeating, we shouldn&#39;t advance the &#39;seen&#39; variable:</p><p>  解决方法是：如果第一个＆＃39; c＆＃39;重复一遍，我们不应该推进看到的变量：</p><p> if (seen==0 &amp;&amp; ch==&#39;c&#39;) seen=1; else if (seen==1 &amp;&amp; ch==&#39;o&#39;) seen=2; else if (seen==1 &amp;&amp; ch!=&#39;o&#39;) { // we can be here if the input is &#39;ccocos&#39; if (ch==&#39;c&#39;) seen=1; else seen=0; } else if (seen==2 &amp;&amp; ch==&#39;c&#39;) seen=3; else if (seen==3 &amp;&amp; ch==&#39;o&#39;) seen=4; else if (seen==4 &amp;&amp; ch==&#39;s&#39;) return i-4; // found else seen=0; // reset</p><p> 如果（seen == 0＆amp;＆ch; ==＆＃39; c＆＃39;）看到= 1;否则，如果（seen == 1＆amp;＆ch; ==＆＃39; o＆＃39;）看到= 2; else if（seen == 1＆amp;＆amp; ch！=＆＃39; o＆＃39;）{//如果输入为＆＃39; ccocos＆＃39;如果（ch ==＆＃39; c＆＃39;）看到= 1；否则看到= 0； }否则，如果（seen == 2＆amp;＆amp; ch ==＆＃39; c＆＃39;）看到= 3;否则，如果（seen == 3＆amp; ch ==＆＃39; o＆＃39;）看到= 4;否则（seen == 4＆amp;＆ch; ==＆＃39; s＆＃39;）返回i-4; //发现其他人看过= 0; // 重启</p><p> CBMC can verify this function for all 6-character strings, OK.But it can find problematic 7-character string:</p><p> CBMC可以针对所有6个字符的字符串验证此功能，但是可以找到有问题的7个字符的字符串：</p><p> % cbmc --trace --function check -DLEN=7 kmp_cocos.c...** Results:[check.assertion.1] assert: FAILURETrace for check.assertion.1:...State 21 file kmp_cocos.c line 79 function check thread 0---------------------------------------------------- s={ &#39;c&#39;, &#39;o&#39;, &#39;c&#39;, &#39;o&#39;, &#39;c&#39;, &#39;o&#39;, &#39;s&#39; } ({ 01100011, 01101111, 01100011, 01101111, 01100011, 01101111, 01110011 })...</p><p> ％cbmc --trace --function check -DLEN = 7 kmp_cocos.c ... **结果：[check.assertion.1]断言：FAILURETrace for check.assertion.1：...陈述21个文件kmp_cocos.c行79功能检查线程0 --------------------------------------------- ------- s = {＆＃39; c＆＃39 ;、＆＃39; o＆＃39 ;、＆＃39; c＆＃39 ;、＆＃39; o＆＃39 ;、＆＃39; c＆＃39;，o＆＃39;，＆＃39; s }（{01100011，01101111，01100011，01101111，01100011，01101111，01110011}）...</p><p>   ... else if (seen==4 &amp;&amp; ch==&#39;s&#39;) return i-4; // found else if (seen==4 &amp;&amp; ch!=&#39;s&#39;) { // the input string is &#39;cocoX&#39; where X is not &#39;s&#39; // (current state of ch=&#39;X&#39;) // but &#39;X&#39; could be &#39;c&#39; if the input string is &#39;cococos&#39; if (ch==&#39;c&#39;) { // if the string is &#39;cococos&#39;, // we can say that we have already seen the &#39;coc&#39; part of it: seen=3; } else { // &#39;X&#39; is not &#39;c&#39;, so reset seen=0; }; } else seen=0; // reset...</p><p>   ...否则，如果（seen == 4＆amp;＆ch; ==＆＃39; s＆＃39;）返回i-4; //发现是否为if（seen == 4＆amp;＆amp; ch！=＆＃39; s＆＃39;）{//输入字符串为＆＃39; cocoX＆＃39;其中X不是//（ch =＆＃39; X＆＃39;的当前状态）//但＆＃39; X＆＃39;可能是＆＃39; c＆＃39;如果输入字符串是＆＃39; cococos＆＃39; if（ch ==＆＃39; c＆＃39;）{//如果字符串是＆＃39; cococos＆＃39 ;， //我们可以说我们已经看到了＆＃39; coc＆＃39;部分内容：see = 3; } else {//＆＃39; X＆＃39;不是＆c＆＃39 ;，因此重置为= 0； }; } else see = 0; // 重启... </p><p>  % cbmc --trace --function check -DLEN=8 kmp_cocos.c...** Results:[check.assertion.1] assert: FAILURETrace for check.assertion.1:...State 21 file kmp_cocos.c line 96 function check thread 0---------------------------------------------------- s={ &#39;c&#39;, &#39;o&#39;, &#39;c&#39;, &#39;c&#39;, &#39;o&#39;, &#39;c&#39;, &#39;o&#39;, &#39;s&#39; } ({ 01100011, 01101111, 01100011, 01100011, 01101111, 01100011, 01101111, 01110011 })...</p><p>％cbmc --trace --function check -DLEN = 8 kmp_cocos.c ... **结果：[check.assertion.1]断言：FAILURETrace for check.assertion.1：...陈述21个文件kmp_cocos.c行96功能检查线程0 --------------------------------------------- ------- s = {＆＃39; c＆＃39 ;、＆＃39; o＆＃39 ;、＆＃39; c＆＃39 ;、＆＃39; c＆＃39 ;、＆＃39; o＆＃39;，＆＃39;，o＆＃39;，＆＃39; s }（{01100011、01101111、01100011、01100011、01101111、01100011、01101111、01110011}）...</p><p> It fails with &#34;coccocos&#34;.We have to add another check for the repeating second &#39;c&#39; character.</p><p> 它因＆＃34; coccocos＆＃34;失败。我们必须为重复的第二个＆＃39c＆＃39;添加另一张支票字符。</p><p> ... else if (seen==3 &amp;&amp; ch==&#39;o&#39;) seen=4; else if (seen==3 &amp;&amp; ch!=&#39;o&#39;) { // if input=&#39;coccocos&#39; if (ch==&#39;c&#39;) seen=1; else seen=0; // reset } else if (seen==4 &amp;&amp; ch==&#39;s&#39;)...</p><p> ...否则，如果（seen == 3＆amp;＆ch; ==＆＃39; o＆＃39;）看到= 4;否则if（seen == 3＆amp;＆amp; ch！=＆＃39; o＆＃39;）{// if input =＆＃39; coccocos＆＃39;如果（ch ==＆＃39; c＆＃39;）看到= 1；否则看到= 0； // reset} else if（seen == 4＆amp;＆ch; ==＆＃39; s＆＃39;）...</p><p> Now CBMC can check it all up to 15-character strings. The whole fixed function is:</p><p> 现在CBMC最多可以检查所有15个字符的字符串。整个固定功能为：</p><p> unsigned search_cocos_fixed (char *s, unsigned len){ if (len&lt;5) return len; // not found unsigned seen=0; for (unsigned i=0; i&lt;len; i++) { char ch=s[i]; // this is single read operation if (seen==0 &amp;&amp; ch==&#39;c&#39;) seen=1; else if (seen==1 &amp;&amp; ch==&#39;o&#39;) seen=2; else if (seen==1 &amp;&amp; ch!=&#39;o&#39;) { // we can be here if the input is &#39;ccocos&#39; if (ch==&#39;c&#39;) seen=1; else seen=0; } else if (seen==2 &amp;&amp; ch==&#39;c&#39;) seen=3; else if (seen==3 &amp;&amp; ch==&#39;o&#39;) seen=4; else if (seen==3 &amp;&amp; ch!=&#39;o&#39;) { // if input=&#39;coccocos&#39; if (ch==&#39;c&#39;) seen=1; else seen=0; // reset } else if (seen==4 &amp;&amp; ch==&#39;s&#39;) return i-4; // found else if (seen==4 &amp;&amp; ch!=&#39;s&#39;) { // the input string is &#39;cocoX&#39; where X is not &#39;s&#39; // (current state of ch=&#39;X&#39;) // but &#39;X&#39; could be &#39;c&#39; if the input string is &#39;cococos&#39; if (ch==&#39;c&#39;) { // if the string is &#39;cococos&#39;, // we can say that we have already seen the &#39;coc&#39; part of it: seen=3; } else { // &#39;X&#39; is not &#39;c&#39;, so reset seen=0; }; } else seen=0; // reset } return len; // not found};</p><p> unsigned search_cocos_fixed（char * s，unsigned len）{如果（len＆lt; 5）返回len； //未找到unsigned seen = 0; for（unsigned i = 0; i <len; i ++）{char ch = s [i]; //如果（seen == 0＆amp;＆amp; ch ==＆＃39; c＆＃39;）看到= 1，则这是单次读取操作；否则，如果（seen == 1＆amp;＆ch; ==＆＃39; o＆＃39;）看到= 2; else if（seen == 1＆amp;＆amp; ch！=＆＃39; o＆＃39;）{//如果输入为＆＃39; ccocos＆＃39;如果（ch ==＆＃39; c＆＃39;）看到= 1；否则看到= 0； }否则，如果（seen == 2＆amp;＆amp; ch ==＆＃39; c＆＃39;）看到= 3;否则，如果（seen == 3＆amp; ch ==＆＃39; o＆＃39;）看到= 4; else if（seen == 3＆amp;＆amp; ch！=＆＃39; o＆＃39;）{//如果input =＆＃39; coccocos＆＃39;如果（ch ==＆＃39; c＆＃39;）看到= 1；否则看到= 0； //重置}否则，如果（seen == 4＆amp;＆amp; ch ==＆＃39; s＆＃39;）返回i-4; //发现是否为if（seen == 4＆amp;＆amp; ch！=＆＃39; s＆＃39;）{//输入字符串为＆＃39; cocoX＆＃39;其中X不是//（ch =＆＃39; X＆＃39;的当前状态）//但＆＃39; X＆＃39;可能是＆＃39; c＆＃39;如果输入字符串是＆＃39; cococos＆＃39; if（ch ==＆＃39; c＆＃39;）{//如果字符串是＆＃39; cococos＆＃39 ;， //我们可以说我们已经看到了＆＃39; coc＆＃39;部分内容：see = 3; } else {//＆＃39; X＆＃39;不是＆c＆＃39 ;，因此重置为= 0； }; } else see = 0; // reset} return len; // 未找到};</p><p> It is capable of searching for the &#39;cocos&#39; substring reading each character of the input string only once,and it is formally verified by CBMC.</p><p> 它能够搜索＆＃39; cocos＆＃39;子字符串仅读取一次输入字符串的每个字符，并由CBMC正式验证。</p><p> Code like that is very hard to test(can you execute these functions with all 15-characters input strings?),but thanks to CBMC, we can be sure it&#39;s correct, or at least, equivalent to the simple &#39;bruteforce&#39; version.I couldn&#39;t devise a correct version without it. In fact first versions were written in Python.I rewritten it to pure C so that I can verify them using CBMC.</p><p> 像这样的代码很难测试（您可以使用所有15个字符的输入字符串来执行这些功能吗？），但是由于有了CBMC，我们可以确保它是正确的，或者至少等同于简单的＃ 39; bruteforce＆＃39;版本。没有它，我无法设计出正确的版本。实际上第一个版本是用Python编写的，我将其重写为纯C语言，以便可以使用CBMC对其进行验证。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://yurichev.com/news/20210121_Knuth_Morris_Pratt_1/">https://yurichev.com/news/20210121_Knuth_Morris_Pratt_1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/morris/">#morris</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cbmc/">#cbmc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>