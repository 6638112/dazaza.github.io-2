<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实际的？ JVM 上的 Common Lisp：现代 Web 应用程序的 ABCL 快速介绍</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">实际的？ JVM 上的 Common Lisp：现代 Web 应用程序的 ABCL 快速介绍</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-08-06 03:44:28</div><div class="page_narrow text-break page_content"><p>为了证明有关 Lisp（特别是 Common Lisp）的实用性的互联网错误，我试图让简单（但现实）的网络应用程序运行起来，这是一种荒谬的尝试。四天后，ABCL 的补丁我得到了一些工作。 (let* ((port 8080) (server (make-server 8080))) (route server &quot;GET&quot; &quot;/&quot; (lambda (ctx) &quot;My index!&quot;)) (route server &quot;GET&quot; &quot;/search&quot; ( lambda (ctx) (模板 &quot;search.tmpl&quot; &#39;((&quot;version&quot; &quot;0.1.0&quot;) (&quot;results&quot; (&quot;cat&quot; &quot;dog&quot; &quot;mouse&quot;))))))) &lt;html&gt; &lt;title&gt;版本 {{ version }}&lt;/title&gt; {% for item in results %} &lt;h2&gt;{{ item }}&lt;/h2&gt; {% endfor %}&lt;/html&gt; Armed Bear Common Lisp (ABCL) 是唯一的 Common Lispimplementation 我知道它可以连接到像 JVM 或 CLR 这样的主要库生态系统。从理论上讲，这对于那些想要生态系统的稳定性和资源的人来说是一个安全的建议，即使他们不使用其旗舰语言。像 Micronaut（和 Jersey）这样的库的问题在于它们做了大量的动态检查来弄清楚如何注册控制器等等。这对于使用 Java 库的开发人员来说当然很方便。但是，当您尝试通过另一种语言的外部函数接口 (FFI) 使用库时，这将成为一种折磨。例如，如果框架扫描目录中的所有文件以获取 @GET 注释。另一方面，Spark 对引入 Websocket 库有一个看似严格的要求，这在配置过程中导致了一些问题。所以我最终选择了 Jooby 和 Netty（作为底层服务器）。最后，我查看了一些类似 Jinja 的模板库并选择了 Pebble，因为 Jinjava 不会加载表单。</p><p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.github.eatonphil&lt;/groupId&gt; &lt;artifactId&gt;abcl-rest-api -hello-world&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.jooby&lt;/groupId&gt; &lt;artifactId&gt;jooby&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jooby&lt;/groupId&gt; &lt;artifactId&gt;jooby-netty&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.pebbletemplates &lt;/groupId&gt; &lt;artifactId&gt;pebble&lt;/artifactId&gt; &lt;version&gt;3.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ABCL 有一个名为 abcl-asdf 的包，它可以帮助您通过 Maven 和你的文件系统。我们将导入它和它所依赖的包 (abcl-contrib)：要从 Maven 导入特定包，您可以调用 abcl-asdf:resolve 并使用包含 Maven 包组 ID 和工件 ID 的冒号分隔字符串调用 abcl-asdf:resolve。然后将该结果传递给 abcl-asdf:as-classpath 并将该结果传递给 java:add-to-classpath。现在您可以在这些包中调用函数。如果您只想使用内置函数调用 Java 方法，它看起来像 (jcall &quot;method&quot;&quot;com.organization.package.Class&quot; object arg1 arg2 ... argN)。如果要调用静态 Java 方法，请使用 (jstatic...) 而不是 (jcall ...)。似乎 ABCL 会自动将简单类型从 theirLisp 表示形式转换为 Java，但它不会将列表转换为数组。如果 Java 函数需要数组，则必须使用类似 (java:jnew-array-from-list&quot;java.lang.String&quot; my-string-list) 之类的函数明确地执行此操作。使用内置 Java FFI 时，您始终需要对 java.lang.Objectfor Object 或 java.util.Arrayfor Array 等类使用完全限定名称。或者，您可以（需要 :jss）访问用于进行 Java 调用的更简单的语法。方法调用看起来像 (#&quot;method&quot; object arg1 arg2 ... argN)。创建对象的新实例正在调用 (jss:jnew&#39;className)。当您使用 JSS 时，您不需要完全限定类名，除非有多个类同名。例如，要创建一个新的 Jooby 应用程序实例，我们可以调用 (jss:jnew &#39;Jooby)。只要在类路径中可以找到该类，JSS 就会解析它。</p><p>真正的代码将类似于本文顶部的伪代码。我们将剔除特定于库的包装器，用于呈现模板和注册路由。 * 服务器服务器 = new Netty(); // 或 Jetty 或 Utow * * App app = new App(); * * server.start(app); * * ... * * server.stop(); Netty 来自 Maven 上 io.jooby 组中的 jooby-netty 工件。而 App 是扩展 io.jooby.Jooby 的对象。由于我们没有使用 OOP 语言，但我们将尽量避免使用类。因此，我们将创建一个新的 io.jooby.Jooby 实例并直接向其添加路由。 (defun template (filename context) &quot;&quot;)(defun route (app method path handler) nil)(defun register-endpoints (app) (route app &quot;GET&quot; &quot;/&quot; (lambda (ctx) &quot;An index!&quot;)) (route app &quot;GET&quot; &quot;/search&quot; (lambda (ctx) (template &quot;search.tmpl&quot; `((&quot;version&quot; &quot;1.0.0&quot;) (&quot;results&quot; ,(java:jarray-from-list &#39;(&quot;) cat&quot; &quot;dog&quot; &quot;mouse&quot;))))))) (route app &quot;GET&quot; &quot;/hello-world&quot; (lambda (ctx) &quot;Hello world!&quot;)))(let* ((port 8080)) (server (jss:new &#39;Netty)) (app (jss:new &#39;Jooby))) (register-endpoints app) (#&quot;setOptions&quot; server (#&quot;setPort&quot; (jss:new &#39;ServerOptions) port)) (#&quot;start &quot; server app) (#&quot;join&quot; server)) 我们再次不会像 Jooby 文档建议的那样使用花哨的 Java 语法（如果你使用 Java 很好）。再次搜索 Jooby 源代码看起来我们可以使用方法字符串、路径字符串和实现 io.jooby.Route.Handler 接口的对象实例调用 Jooby 类上的路由。由于这个处理程序参数是一个接口，我们不能通过创建它的实例来再次欺骗我们必须在 Lisp 中实际创建一个扩展它的新类。幸运的是，我们只需要实现一个方法来满足这个接口，apply。它接受一个 io.jooby.Context 对象并返回一个 java.lang.Object。然后，框架会进行自省，以确定对象到底是什么，以及是否需要将其转换为字符串以作为 HTTP 响应正文返回。要在 ABCL 中创建一个新类，我们调用 (java:jnew-runtime-class&quot;classname&quot; :interfaces &#39;(&quot;an interface name&quot;) :methods &#39;((&quot;methodname 1&quot; &quot;return type&quot; (&quot;first parameter type&quot; . ..) (lambda (this arg1 ...) body)))):</p><p>(defun route (app method path handler) (#&quot;route&quot; app method path (jss:new (java:jnew-runtime-class (substitute #\$ #\/ (substitute #\$ #\- path)) :interfaces &#39;(&quot;io.jooby.Route$Handler&quot;) :methods `( (&quot;apply&quot; &quot;java.lang.Object&quot; (&quot;io.jooby.Context&quot;) (lambda (this ctx) (funcall ,handler ctx))) ))))) 需要注意的一件事是，在文件中引用子类时，我们需要使用 io.jooby.Route$Handler 语法来处理它，而不是像您在 Java 中引用的 io.jooby.Route.Handler 那样。在后一种情况下，ABCLthinks Route 是一个包，而实际上它只是一个类。如果你现在用 abcl --load main.lisp 运行它。它会一直工作，直到您到达终点。问题是 Jooby 如何试图找出返回对象的真实类型。在这种情况下，它尝试打开并解析我们应用程序的（Java）源代码，以尝试找到此应用函数的返回类型。这是一个问题，因为我们的代码不是 Java。通过反复试验Irealized，我们可以通过添加另一个apply实现来向我们的类返回一个字符串，从而欺骗Jooby/Java/某人找出正确的返回类型。 (defun route (app method path handler) (#&quot;route&quot; app method path (jss:new (java:jnew-runtime-class (substitute #\$ #\/ (substitute #\$ #\- path)) :interfaces &#39;(&quot;io.jooby.Route$Handler&quot;) :methods `(;; 需要定义这个来让 Jooby 找出返回类型;; 否则它会尝试读取不是 Java 文件的“这个文件”，所以无法解析 (&quot;apply&quot; &quot;java.lang.String&quot; (&quot;io.jooby.Context&quot;) (lambda (this ctx) nil)) ;; 这个实际上被调用 (&quot;apply&quot; &quot;java.lang.Object&quot; (&quot;io.jooby.Context&quot;) (lambda (this ctx) (funcall ,handler ctx)))))))) 你可能想知道，为什么保留原始方法？嗯，这是因为在反射过程中，ABCL 说在 Handlerinterface 中不存在这样的返回 String 的方法。我想这很公平。</p><p>PebbleEngine engine = new PebbleEngine.Builder().build();PebbleTemplatecompiledTemplate = engine.getTemplate(&quot;home.html&quot;);Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();context.put(&quot;name&quot; , &quot;Mitchell&quot;);Writer writer = new StringWriter();compiledTemplate.evaluate(writer, context);String output = writer.toString(); (defun hashmap (alist) (let ((map (jss:new &#39;HashMap))) (loop for el in alist do (#&quot;put&quot; map (car el) (cadr el))) map))(defun template ( filename context-alist) (let* ((ctx (hashmap context-alist)) (path (java:jstatic &quot;of&quot; &quot;java.nio.file.Path&quot; filename)) (file (#&quot;readString&quot; &#39;java.nio .file.Files path)) (engine (#&quot;build&quot; (jss:new &#39;PebbleEngine$Builder))) (compiledTmpl (#&quot;getTemplate&quot; engine filename)) (writer (jss:new &#39;java.io.StringWriter)) ) (#&quot;evaluate&quot;compiledTmpl writer ctx) (#&quot;toString&quot; writer))) 但是如果你运行这个 abcl --load main.lisp 并点击这个 /search 端点，它会爆炸说“没有这样的方法”存在于对 Path.of(filename) 的调用。虽然有使用可变参数函数的例子，当函数只有一个参数，比如 java.util.Arrays.asList(T ...)，在这里使用相同的技术继续导致“没有这样的方法”：最终我找到了一个例子有人在这种函数调用上进行反射/调用，在 ABCL 源代码的本地副本上尝试了这种逻辑。 (defun 模板 (filename context-alist) (let* ((ctx (hashmap context-alist)) (path (java:jstatic &quot;of&quot; &quot;java.nio.file.Path&quot; 文件名 (java:jnew-array &quot;java. lang.String&quot; 0))) (file (#&quot;readString&quot; &#39;java.nio.file.Files path)) (engine (#&quot;build&quot; (jss:new &#39;PebbleEngine$Builder))) (compiledTmpl (#&quot;getTemplate) &quot; 引擎文件名)) (writer (jss:new &#39;java.io.StringWriter))) (#&quot;evaluate&quot;compiledTmpl writer ctx) (#&quot;toString&quot; writer))) $ mkdir ~/vendor$ cd ~/vendor$ git克隆 https://github.com/eatonphil/abcl$ cd abcl$ git checkout pe/more-variadic$ sudo {dnf/brew/apt} install ant maven$ ant -f build.xml</p><p>我正在将此示例移植到 Kawa 以查看它的表现。博客文章来了。为了证明互联网关于 Lisp（特别是 Common Lisp）的实用性是错误的，我试图让一个简单（但现实）的网络应用程序运行起来，这是一种荒谬的尝试。经过四天和 ABCL 的补丁，我得到了一些工作。 https://t.co/5UUWNR8Wnn pic.twitter.com/cZsx32IlKD — Phil Eaton (@phil_eaton) 2021 年 8 月 5 日</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/quot/">#quot</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>