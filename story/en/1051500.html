<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么异步生锈不起作用 Why asynchronous Rust doesn't work</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why asynchronous Rust doesn't work<br/>为什么异步生锈不起作用 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 01:10:44</div><div class="page_narrow text-break page_content"><p>In 2017, I said that  “asynchronous Rust programming is a disaster and a mess”. In 2021a lot more of the Rust ecosystem has become asynchronous – such that it might be appropriate to just say that Rustprogramming is now a disaster and a mess. As someone who used to really love Rust, this makes me quite sad.</p><p>2017年，我说“异步防锈编程是一场灾难和一团糟”。在2021A中，更多的铁锈生态系统变得异步 - 这可能是适当的只是说Rustrogramming现在是一场灾难和一团糟。作为曾经真正爱过生锈的人，这让我很伤心。</p><p> I’ve had a think about this, and I’m going to attempt to explain how we got here. Many people have explained the problemswith asynchronous programming – the famous  what colour is your functionessay, for example.  1 However, I think there are a number of things  specific to the design of Rust that make asynchronousRust particularly messy,  on top of the problems inherent to doing any sort of asynchronous programming.</p><p> 我觉得这个，我会试图解释我们在这里的方式。许多人已经解释了异步编程的问题 - 例如，着名的颜色是你的函数。 1但是，我认为有许多特定于生锈设计的东西，使异步源特别杂乱，最重要的是做出任何类型的异步编程所固有的问题。</p><p> In particular,I actually think the design of Rust is almost fundamentally incompatible with a lot of asynchronous paradigms. It’s not thatthe people designing async were incompetent or bad at their jobs – they actually did a surprisingly good job given thecircumstances!  2 I just don’t think it was ever going to work out cleanly – and to see why, you’re going to have to reada somewhat long blog post!</p><p> 特别是，我实际上认为Rust的设计几乎与许多异步范例根本不兼容。这并不是那些设计的人在他们的工作中是无能的或坏的 - 他们实际上给予了令人惊讶的好工作！ 2我只是不认为它永远都会干净地锻炼 - 并看看为什么，你将不得不读取一些长的博客文章！</p><p>  I’d like to make a simple function that does some work in the background, and lets us know when it’s done by running  anotherfunction with the results of said background work.</p><p>  我想制作一个简单的功能，在后台做一些工作，让我们知道它是通过运行另一个背景工作的结果来完成的。</p><p> use  std :: thread ; /// Does some strenuous work &#34;asynchronously&#34;, and calls `func` with the /// result of the work when done. fn  do_work_and_then ( func :  fn ( i32 ))  {  thread :: spawn ( move  ||  {  // Figuring out the meaning of life...  thread :: sleep_ms ( 1000 );  // gee, this takes time to do...  // ah, that&#39;s it!  let  result :  i32  =  42 ;  // let&#39;s call the `func` and tell it the good news...  func ( result )  }); }</p><p> 使用std :: thread; ///做一些艰苦的工作＆＃34;异步地和＃34;，并且在完成后用///的结果呼叫`func`。 fn do_work_and_then（func：fn（i32））{thread :: spawn（move || {//计算出生命的含义...线程:: sleep_ms（1000）; // gee，这需要时间.. 。//啊，它＆＃39; s＆＃39;让结果：i32 = 42; //让＆＃39; s调用`func`并告诉它好消息...... func（结果）}）; }</p><p> There’s this idea called “ first-class functions” which says youcan pass around functions as if they were objects. This would be great to have in Rust, right?</p><p> 有这个想法称为“一流的函数”，称你绕过函数，就像它们是对象一样。这将是生锈，对吗？</p><p> See that  func: fn(i32)?  fn(i32) is the type of a function that takes in one singular  i32 and returns nothing.Thanks to first-class functions, I can pass a function to  do_work_and_then specifying what should happen next after I’mdone with my work – like this:</p><p> 看那个Func：fn（i32）？ fn（i32）是一个统一I32的函数的类型，并没有返回任何函数。谢谢到一流的函数，我可以通过函数来​​do_ward_and_then指定在我的工作中ondone之后应该发生的是什么 - 如此： </p><p> fn  main ()  {  do_work_and_then (| meaning_of_life |  {  println! ( &#34;oh man, I found it: {}&#34; ,  meaning_of_life );  });  // do other stuff  thread :: sleep_ms ( 2000 ); }</p><p>fn main（）{do_work_and_then（|意思_of_life | {println！（＆＃34;哦，我找到它：{}＆＃34;，digen_of_life）;}; //做其他东西线程:: sleep_ms（2000）; }</p><p> Because  do_work_and_then is  asynchronous, it returns immediately and does its thing in the background, so the controlflow of  main isn’t disrupted. I could do some other form of work, which would be nice (but here I just wait for 2 seconds,because there’s nothing better to do). Meanwhile, when we do figure out the meaning of life, it gets printed out. Indeed,if you run this program, you get:</p><p> 因为do_work_and_then是异步的，它立即返回它的东西在后台，因此main的控制流程不会中断。我可以做一些其他形式的工作，这会很好（但在这里我只等2秒，因为没有什么比这更好的了）。同时，当我们弄清楚生活的意义时，它会被打印出来。实际上，如果您运行此程序，您可以得到：</p><p>  This is really exciting; we could build whole web servers and network stuff and whatever out of this! Let’stry a more advanced example: I have a database I want to store the meaning of life in when I find it, and then I can runa web server in the foreground that enables people to get it once I’m done (and returns some error if I’m not done yet).</p><p>  这真是令人兴奋;我们可以构建整个Web服务器和网络的东西，无论如何！让我们是一个更高级的例子：我有一个数据库，我想在找到它的时候存储生命的意义，然后我可以在前台运行Web服务器，使人们能够在我完成后获得它（并返回如果我还没有完成一些错误）。</p><p> struct  Database  {  data :  Vec &lt; i32 &gt; } impl  Database  {  fn  store ( &amp; mut  self ,  data :  i32 )  {  self .data .push ( data );  } } fn  main ()  {  let  mut  db  =  Database  {  data :  vec! []  };  do_work_and_then (| meaning_of_life |  {  println! ( &#34;oh man, I found it: {}&#34; ,  meaning_of_life );  db .store ( meaning_of_life );  });  // I&#39;d read from `db` here if I really were making a web server.  // But that&#39;s beside the point, so I&#39;m not going to.  // (also `db` would have to be wrapped in an `Arc&lt;Mutex&lt;T&gt;&gt;`)  thread :: sleep_ms ( 2000 ); }</p><p> struct数据库{data：vec＆lt; I32＆gt; } Alcm Database {Fn Store（＆amp; mut self，data：i32）{self .data .push（数据）; fn main（）{let mut db = database {data：vec！ []; do_work_and_then（| tapt_of_life | {println！（＆＃34;哦，我发现它：{}＆＃34;，digen_of_life）; db .store（意大图_of_life）;}）; // i＆＃39; d如果我真的在制作一个web服务器，请在这里从`db读取。 //，但它在点旁边，所以我不去。 //（也必须在`电弧＆lt; t＆gt;＆gt;`）线程:: sleep_ms（2000）; }</p><p>  error[E0308]: mismatched types --&gt; src/main.rs:27:22 |27 | do_work_and_then(|meaning_of_life| { | ______________________^28 | | println!(&#34;oh man, I found it: {}&#34;, meaning_of_life);29 | | db.store(meaning_of_life);30 | | }); | |_____^ expected fn pointer, found closure | = note: expected fn pointer `fn(i32)` found closure `[closure@src/main.rs:27:22: 30:6]`</p><p>  错误[E0308]：不匹配类型 - ＆gt; SRC / MAIN.RS：27：22 | 27 | do_work_and_then（|意思_of_life | {| ______________________ ^ 28 | | Println！（＆＃34;哦，我找到它：{}＆＃34;，意思_of_life）; 29 | | db.store（意思_of_life）; 30 | |} ）; | | _____ ^预期的fn指针，找到闭合| =注意：预期FN指针`Fn（i32）`找到关闭`[closure@src/main.rs：27：22：30：6]`</p><p>   So, this is actually quite complicated. Before, the function we passed to  do_work_and_then was  pure: it didn’t have anyassociated data, so you could just pass it around as a function pointer ( fn(i32)) and all was grand.However, this new function in that last example is a  closure: a function object with a bit of data (a  &amp;mut Database)tacked onto it.</p><p>   所以，这实际上非常复杂。之前，我们传递给do_work_and_then的函数是纯粹的：它没有任何数据，所以你可以像函数指针一样传递它（fn（i32）），并且所有都是grand.wever，这个新的函数在这个榜样是一个关闭：一个函数对象，其中一点数据（a＆amp; mut数据库）加到它上。</p><p> Closures are kind of magic. We can’t actually name their type – as seen above, the Rust compiler called it a [closure@src/main.rs:27:22: 30:6], but we can’t actually write that in valid Rust code. If you were to write it outexplicitly, a closure would look something like this:</p><p> 关闭是魔法。我们实际上无法命名他们的类型 - 如上所示，rust编译器称为它[closue@src/main.rs：27：22：30：6]，但我们实际上无法在有效的生锈代码中写入。如果你要在外面写它，一个关闭会看起来像这样： </p><p> struct  Closure &lt; &#39;a &gt;  {  data :  &amp; &#39;a  mut  Database ,  func :  fn ( i32 ,  &amp; mut  Database ) } impl &lt; &#39;a &gt;  Closure &lt; &#39;a &gt;  {  fn  call ( &amp; mut  self ,  arg :  i32 )  {  ( self .func )( arg ,  self .data )  } }</p><p>结构闭合＆lt; ＆＃39; a＆gt; {数据：＆amp; ＆＃39; mut数据库，func：fn（i32，＆amp; mut数据库）} iclip＆lt; ＆＃39; a＆gt;关闭＆lt; ＆＃39; a＆gt; {fn呼叫（＆amp; mut self，arg：i32）{（self .func）（arg，self .data）}}</p><p>    Being able to name types in Rust is quite important. With a regular old type, like  u8, life is easy. I can write a function fn add_one(in: u8) -&gt; u8 that takes one and returns one without any hassle.</p><p>    能够命名生锈类型非常重要。常规旧类型，像U8，生活很容易。我可以写一个函数fn add_one（：u8） - ＆gt; U8需要一个并返回一个没有任何麻烦的人。</p><p> If you can’t actually name a type, working with it becomes somewhat cumbersome. What you end up having to do instead isrefer to it using generics – for example, closures’ types can’t be named directly, but since they implement one of the  Fnfamily of traits, I can write functions like:</p><p> 如果您无法实际命名类型，请使用它变得有些繁琐。您最终不得不代替使用泛型的东西 - 例如，封闭类型无法直接命名，但由于它们实现了一个fnfamily的特征之一，我可以编写以下功能：</p><p>  If I want to store them in a  struct or something, I’ll also need to do this dance with the  where clause every time they’reused. This is annoying and makes things harder for me, but it’s still vaguely workable. For now.</p><p>  如果我想用struct或其他东西将它们存储，我还需要每次被用来与where子句一起做这个舞蹈。这很烦人，让我更加困难，但它仍然含糊不清。目前。</p><p>  [image: from the   msql-srv crate,showing an example of many  where clauses as a result of using closures]</p><p>  [图片：来自MSQL-SRV箱，显示了使用封闭件结果的许多子句的示例]</p><p>   The way Rust is designed tends to encourage certain patterns while discouraging others. Because of ownership and lifetimes,having pieces of data that hold references to other pieces of data becomes a bit of a problem. If my type has a  &amp; or a  &amp;mutreference to something, Rust makes me ensure that:</p><p>   设计的方式往往会鼓励某些模式，同时劝阻他人。由于所有权和生命，拥有对其他数据块的引用的数据变为问题。如果我的类型有一个＆amp;或者一个＆amp;捣蛋到某种东西，生锈让我确保：</p><p> the something in question  outlives my type; you can’t go and drop the thing I’m referring to if Istill have a reference to it, otherwise my reference will become invalid</p><p> 有问题的东西概述了我的类型;你不能去除我所指的东西，如果istill有一个引用，我的参考是无效的 </p><p>    my reference to the something doesn’t conflict with other references to the something (e.g. I can’t have my  &amp; reference ifsomething else has a  &amp;mut reference)</p><p>我对某些东西的提及不会与其他引用相冲突（例如，我不能拥有我的＆＆amp; Ifsomething其他有A＆amp; mut参考）</p><p> So types with references in them are almost ‘radioactive’; you can keep them around for a bit (e.g. inside one particularfunction), but attempting to make them long-lived is usually a bit of an issue (requiring advanced tricks such as the  Pin&lt;T&gt;type which didn’t even exist until a few Rust versions ago). Generally Rust doesn’t really like it when you use radioactivetypes for too long – they make the borrow checker uneasy, because you’re borrowing something for an extended period of time.</p><p> 因此，它们的参考资料几乎是“放射性”;您可以将它们保留一下（例如在一个特定功能内），但试图使它们长期以来通常是有点问题（需要提前技巧，例如引脚＆lt; t＆gt;甚至没有存在的类型很少有锈版版本前）。当你使用射入型号太久时，生锈并不喜欢它 - 他们让借用检查员不安，因为你延长了一段时间。</p><p>    Closures can be pretty radioactive. Look at the thing we just wrote out: it has a  &amp;&#39;a mut Database reference in it!That means while we’re passing our  Closure object around, we have to be mindful of the three rules (outlives, doesn’t move,no conflicting) – which makes things pretty hard. I can’t just hand off the  Closure to another function (for example, the do_work_and_then function), because then I have to make all of those rules work, and that’s not necessarily easy all the time.</p><p>    关闭可以是放射性的。看看我们刚刚写的东西：它有一个＆amp;＆＃39; ut数据库引用它！这意味着在我们传递我们的关闭对象时，我们必须注意三个规则（旅行，并不是“T搬家，没有冲突） - 这使得事情变得非常难。我不能只用封闭关闭另一个函数（例如，do_work_and_then函数），因为那么我必须制作所有这些规则工作，这一切都不一定很容易。</p><p> (Not  all closures are radioactive: if you make them  move closures, they’ll take everything by value instead, and createclosure objects that own data instead of having radioactive references to data.Slightly more of a pain to deal with, but you lose the blue radiation glow the things give out when you look at them.)</p><p> （并非所有闭包都是放射性的：如果您让它们移动闭合，则它们将按价值取得的一切，而且群集对象拥有数据，而不是对数据进行放射性引用。更多的痛苦来处理，但你失去了蓝色辐射发光，当你看着它们时，东西会发出。）</p><p> Also, remember what I said about being able to name types? We’re not actually dealing with a nice, written-out  Closure objecthere; we’re dealing with something the compiler generated for us that we can’t name, which is annoying. I also lied whenI said that it was as simple as making all of your functions take  F, where F: Fn(i32) or something – there are actually three different  Fn-style traits,  Fn,  FnMut, and  FnOnce. Do you know the difference between them?</p><p> 另外，请记住我所说的能够命名类型？我们实际上并没有处理一个漂亮的，写的封闭性质;我们正在处理为我们生成的编译器，我们不能命名，这很烦人。我也撒谎，当我说它像制作你的所有功能一样简单，其中f：fn（i32）或某物 - 实际上有三种不同的fn风格的特征，fn，fnmut和fnonce。你知道它们之间的区别吗？</p><p> So. A closure is this magical, un-nameable type that the compiler makes for us whenever we use  || {...} syntax, which implementsone of three traits (and it’s not immediately obvious which), and it also might be radioactive.Try and use one of these, and the Rust compiler is probably going to be watching you  very carefully.</p><p> 所以。关闭是这种神奇的，不可最可爱的类型，编译器在我们使用时为我们提供|| {...}语法，它的含义三个特征（它没有立即显而易见的），它也可能是放射性的.try和使用其中一个，而且生锈编译器可能会非常谨慎地看着你。</p><p>  The thing I really want to try and get across here is that  Rust is not a language where first-class functions are ergonomic.It’s a lot easier to make some data (a  struct) with some functions attached (methods) than it is to make some functions with somedata attached (closures).</p><p>  我真正想要尝试在这里尝试的事情是Rust不是一种语言，其中一流的功能是符合人体工程学的。它更容易制作一些数据（方法）附加的一些函数（方法）而不是制作有些功能与有一天附着（闭包）。 </p><p>  you choose what traits and methods to implement on them and how to set them out / implement them</p><p>您选择在它们上实施的特征和方法以及如何将它们放出/实现它们</p><p>  the  struct can actually be referred to by other parts of the code by its type</p><p>  结构实际上可以通过其类型的代码的其他部分引用</p><p>  it might be radioactive (or force you to use  move and maybe insert a bunch of  clone() calls)  3</p><p>  它可能是放射性的（或强制您使用移动，也可能插入一堆克隆（）呼叫）3</p><p>  you can’t actually name their type anywhere or do things like return them from a function</p><p>  您实际上无法在任何地方命名或做的事情，如从函数返回它们</p><p> Importantly, the restrictions applied to using closures  infect types that contain them – if you’re writing a type that containsa closure, you’ll have to make it generic over some  Fn-trait-implementing type parameter, and it’s going to be impossible forpeople to name your type as a result.</p><p> 重要的是，应用于使用包含它们的闭包的限制 - 如果您正在编写包含的类型，则必须使其在某些FN特征实现类型参数上泛型，并且它将是不可能的为结果命名您的类型。</p><p> (Other languages, like Haskell, flip this upside down: functions are everywhere, you can pass them around with reckless abandon, etc.Of course, these other languages usually have garbage collection to make it all work…)</p><p> （其他语言，如haskell，翻转这个倒置：功能无处不在，你可以通过鲁莽的放弃等。课程，这些其他语言通常有垃圾收集，使其全部工作......）</p><p>  Bearing this in mind, it is  really quite hard to make a lot of asynchronous paradigms (like  async/ await) work well in Rust.As the  what colour is your function post says,  async/ await(as well as things like promises, callbacks, and futures) are really a big abstraction over continuation-passing style – an idea closelyrelated to the  Schemeprogramming language. Basically, the idea is you take your normal, garden-variety function and smear it out into  a bunch of closures.(Well, not quite. You can read the blue links for more; I’m not going to explain CPS here for the sake of brevity.)</p><p>  考虑到这一点，它真的很难制作很多异步范式（如异步/等待）在Rust中工作。你的职能帖子的颜色是什么，异步/等待（以及承诺等事情，回调和期货）真的是延续传递风格的大抽象 - 一个与方案编程语言感到平时的想法。基本上，你的想法是你的常规，花园 - 品种的功能，并将其涂抹成一堆封闭。（嗯，不完全。你可以读取更多的蓝色链接;我不会在这里解释CPS简洁。） </p><p> Hopefully by now you can see that making a bunch of closures is really not going to be a good idea (!)</p><p>希望现在你可以看到让一堆关闭真的不会是一个好主意（！）</p><p>  And then fast forward a few years and you have an entire  language ecosystem built on top of the idea of making these  Future objectsthat actually have a load of closures inside  4, and all of the problems listed above(hard to name, can contain references which make them radioactive, usually require using a generic  where clause, etc)apply to them because of how “infectious” closures are.</p><p>  然后快进了几年，你有一个完整的语言生态系统，基于制作这些未来的Objectsthat的概念之上，实际上有一个封闭封闭式封闭件，上面列出的所有问题（难以命名，可以包含哪些引用使它们放射性，通常需要使用通用的Where子句等）适用于它们，因为如何“传染性”闭包。</p><p> The language people have actually been hard atwork to solve  some (some!) of these problems by introducing features like  impl Trait and  async fn that make dealing with thesenot  immediately totally terrible, but trying to use other language features (like traits) soon makes it clear that the problemsaren’t really gone; just hidden.</p><p> 通过引入ichar特性和异步Fn等功能，这种语言的人实际上是艰难的atwork来解决一些（一些！）这些问题，如ichar特和异步fn，使得与thesenot立即完全可怕，但试图使用其他语言特征（如特征）很快清楚问题，问题并非真正消失;只是隐藏了。</p><p> Oh, and all the problems from  what colour is your functionare still there too, by the way – on  top of the Rust-specific ones.</p><p> 哦，所有颜色的问题都是你的功能，顺便说一下，在特定于防锈的方面也是如此。</p><p> Beginner (and experienced) Rust programmers look at the state of the world as it is and try and build things on top of these shakyabstractions, and end up running into obscure compiler errors, and using hacks like the   async_traitcrate to glue things together, and end up with projects that depend on like 3 different versions of  tokio and  futures (perhapssome  async-std in there if you’re feeling spicy) because people have differing opinions on how to try and avoid the fundamentally unavoidable problems, and it’s all a bit frustrating, and ultimately, all a bit sad.</p><p> 初学者（和经验丰富的）铁锈程序员看世界的状态，并尝试并在这些shakyabstractions之上建立东西，并最终跑进模糊的编译器错误，并使用像异步_traitcrate这样的黑客粘合在一起，结束依赖于像3种不同版本的Tokio和期货（如果你感到辛辣），那里有3种不同版本的项目，因为人们对如何尝试和避免从根本上不可避免的问题有不同的意见，这一切都有点令人沮丧并且最终，一切都很伤心。</p><p>  Did it really have to end this way? Was spinning up a bunch of OS threads not an acceptablesolution for the majority of situations? Could we have explored solutions more like Go, where a language-provided runtime makes blockingmore of an acceptable thing to do?</p><p>  它真的必须以这种方式结束吗？在大多数情况下旋转一堆操作系统线路我们可以更喜欢解决的解决方案，其中一个语言提供的运行时使阻止更多的事情要做？</p><p> Maybe we could just have kept Rust as it was circa 2016, and let the crazy non-blocking folks  5 writehand-crafted  epoll() loops like they do in C++. I honestly don’t know, and think it’s a difficult problem to solve.</p><p> 也许我们可以像2016年大约在大约十时候一样生锈，让疯狂的无阻塞人为5写作制作的ePOLS（）循环，就像他们在C ++中一样。老实说，我不知道，认为这是一个难以解决的问题。 </p><p> But as far as my money goes, I’m finding it difficult to justify starting new projects in Rust when the ecosystem is like this. And, asI said at the start, that makes me kinda sad, because I do actually like Rust.</p><p>但就我的钱而言，我发现当生态系统这样的时候，我发现很难证明在生锈中启动新项目。 Asi在开始时说，这让我有点难过，因为我真的像生锈。</p><p>  ( Common Lisp is pretty nice, though. We have crazy macros and parentheses and a language ecosystem that isolder than I am and isn’t showing any signs of changing…)</p><p>  （但常见的LISP非常好。我们有疯狂的宏和括号，以及一种语言生态系统，它比我的isolder和没有显示任何改变的迹象......）</p><p>  This is really recommended reading if you aren’t already familiar with it (as you’ll soon see)  ↩</p><p>  如果您尚未熟悉它，这是真的建议的阅读（因为你很快看到）♥</p><p>  Seriously – when I put out the last blog post, the actual async core team members commented saying how much they appreciated the feedback, and then they actually went and made futures 1.0 better as a result. Kudos!  ↩</p><p>  严重 - 当我拨出最后一个博客帖子时，实际的异步核心团队成员评论说他们有多普赏的反馈，然后他们实际上是最好的1.0。荣誉！ ↩</p><p>  You might be thinking “well, why don’t you just only use  move closures then?” – but that’s beside the point; it’s often a lot harder to do so, because now you might have to wrap your data in an  Arc or something, by which point the ergonomic gains of using the closure are outweighed by the borrow checker-induced pain.  ↩</p><p>  你可能会想到“好吧，你为什么不用移动封闭件？” - 但这就是在旁边;这样做通常很难，因为现在您可能必须将数据包装在弧形或其他东西中，所以通过借用检查者诱导的疼痛超过了使用闭包的符合人体工程学的痛苦。 ↩</p><p>  You  can actually manually implement  Future on a regular old  struct. If you do this, things suddenly become a lot simpler, but also you can’t easily perform more async operations inside that  struct’s methods.  ↩</p><p>  您实际上可以在常规旧结构上手动实施未来。如果您这样做，事情突然变得更简单，但您也无法轻松在该结构的方法内执行更多的异步操作。 ↩</p><p>  (sorry, I mean, the esteemed companies that deign to use Rust for their low-latency production services)  ↩</p><p>  （对不起，我的意思是，为他们的低延迟生产服务使用Rust的尊敬的公司）↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://theta.eu.org/2021/03/08/async-rust-2.html">https://theta.eu.org/2021/03/08/async-rust-2.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>