<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>FreeBSD和I2C FreeBSD and I2C</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">FreeBSD and I2C<br/>FreeBSD和I2C </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 18:03:32</div><div class="page_narrow text-break page_content"><p>I2C is a communication protocol which was originally designed and used for inter-board communications between peripherals, like the processor talking to an EEPROM in a system. These days it is also used for short distance communication with sensors - not what it was designed for, but it works anyway. Wikipedia has this to say about  I2C:</p><p>I2C是一种通信协议，最初设计用于外围设备之间的板间通信，例如处理器与系统中的EEPROM通讯。如今，它还用于与传感器的短距离通信-并非设计目的，但无论如何它都能工作。维基百科上有关于I2C的说法：</p><p>  I2C (Inter-Integrated Circuit), pronounced I-squared-C, is a synchronous, multi-master, multi-slave, packet switched, single-ended, serial communication bus invented in 1982 by Philips Semiconductor (now NXP Semiconductors). It is widely used for attaching lower-speed peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. Alternatively, I2C is spelled I2C (pronounced I-two-C) or IIC (pronounced I-I-C). (thanks  Wikipedia!)</p><p>  I2C（集成电路间），发音为I-squared-C，是Philips半导体公司（现为NXP Semiconductors）于1982年发明的一种同步，多主机，多从机，分组交换，单端，串行通信总线。它广泛用于在板内短距离通信中将低速外围IC连接到处理器和微控制器。或者，I2C拼写为I2C（发音为I-two-C）或IIC（发音为I-I-C）。 （感谢维基百科！）</p><p>  I&#39;ve been playing around with some  I2C based sensors from SparkFun. They have  QWIIC connectors making it easy to speak to them from SparkFuns  OpenLog Artemis. The OpenLog Artemis can log sensor data to SD card and also presents itself as a serial device where it streams data from the sensors in a CSV-like format. It works great and I can highly recommend the whole  QWIIC ecosystem.</p><p>  我一直在使用一些来自SparkFun的基于I2C的传感器。它们具有QWIIC连接器，可轻松从SparkFuns OpenLog Artemis与他们交谈。 OpenLog Artemis可以将传感器数据记录到SD卡，也可以将自己显示为串行设备，在串行设备中以类似CSV的格式从传感器流式传输数据。它的效果很好，我强烈推荐整个QWIIC生态系统。</p><p>  Occationally I need to use one of the  QWIIC sensors from some FreeBSD based system, without the  OpenLog Artemis. In this case I am using a  Raspberry PI Zero with FreeBSD a 13-CURRENT from December. This is easy because the  QWIIC system is just plain  I2C underneath, so it is easy to hook a sensor up directly to the  GPIO pins of the RPI with  one of these.</p><p>  有时，我需要使用一些基于FreeBSD的系统中的QWIIC传感器之一，而无需使用OpenLog Artemis。在这种情况下，我将从12月开始使用带有FreeBSD的Raspberry PI Zero（13电流）。这很容易，因为QWIIC系统只是其下面的普通I2C，因此使用其中之一将传感器直接连接到RPI的GPIO引脚很容易。</p><p>  In FreeBSD land we have  i2c(8) which is a userspace utility for reading and writing to  I2C devices. I will start by going over basic usage before diving deeper into the actual sensors I am playing with in this learning session.</p><p>  在FreeBSD领域中，我们拥有i2c（8），这是一个用于读写I2C设备的用户空间实用程序。在学习本课程中要使用的实际传感器之前，我将首先介绍基本用法。</p><p>        First things first, I need some hardware with an  I2C bus which is exposed to FreeBSD. I am using a  Raspberry PI Zero and the  I2C bus looks like this in  dmesg:</p><p>        首先，我需要一些带有I2C总线的硬件，该硬件已在FreeBSD中公开。我正在使用Raspberry PI Zero，并且I2C总线在dmesg中如下所示：</p><p>  [root@pizero1 ~]# grep I2C /var/run/dmesg.boot iicbus0: &lt;OFW I2C bus&gt; on iichb0iic0: &lt;I2C generic I/O&gt; on iicbus0[root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃grep I2C /var/run/dmesg.bootiicbus0：＆lt; OFW I2C总线＆gt;在iichb0上iic0：＆lt; I2C通用I / O＆gt;。在iicbus0上[root @ pizero1〜]＃ </p><p>  The first sensor I&#39;ve hooked up is a SparkFun  TMP117 temperature sensor. According to the  hookup guide the default  I2C address of this sensor is  0x48 which matches what I am seeing after hooking up the hardware and running  i2c(8) with the  -s flag to make it scan the  I2C bus for devices:</p><p>我连接的第一个传感器是SparkFun TMP117温度传感器。根据连接指南，此传感器的默认I2C地址为0x48，与连接硬件并使用-s标志运行i2c（8）以使其扫描I2C总线中的设备后所看到的相符：</p><p>  [root@pizero1 ~]# i2c -sHardware may not support START/STOP scanning; trying less-reliable read method.Scanning I2C devices on /dev/iic0: 48 [root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -s硬件可能不支持START / STOP扫描；尝试不太可靠的读取方法。扫描/ dev / iic0上的I2C设备：48[root @ pizero1〜]＃</p><p>  After connecting an additional sensor which has a default  I2C address of  0x60 the bus scan can see that device too:</p><p>  连接附加传感器后，该传感器的默认I2C地址为0x60，总线扫描也可以看到该设备：</p><p>  [root@pizero1 ~]# i2c -svdev: /dev/iic0, addr: 0x0, r/w: r, offset: 0x00, width: 8, count: 1Hardware may not support START/STOP scanning; trying less-reliable read method.Scanning I2C devices on /dev/iic0: 48 60 [root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -sv开发人员：/ dev / iic0，地址：0x0，读/写：r，偏移量：0x00，宽度：8，计数：1硬件可能不支持START / STOP扫描；尝试不太可靠的读取方法。扫描/ dev / iic0上的I2C设备：48 60[root @ pizero1〜]＃</p><p>    Reading from the sensor is straightforward. I specify that I want to read with  -d r (meaning  read), the length of data to get with  -c 2 (meaning 2 bytes) and the address of the device to read from with  -a 48:</p><p>    从传感器读取很简单。我指定我要使用-d r读取（表示已读取），使用-c 2读取的数据长度（表示2个字节），以及使用-a 48读取的设备地址：</p><p>  [root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr0d 67 [root@pizero1 ~]# while true; do date; i2c -a 48 -d r -c 2 -m tr; sleep 1; doneSun Dec 20 00:51:45 UTC 20200d 67 Sun Dec 20 00:51:46 UTC 20200d 67 Sun Dec 20 00:51:48 UTC 20200d 66 Sun Dec 20 00:51:49 UTC 20200d 66 ^C[root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr0天67[root @ pizero1〜]＃为true；约会； i2c -a 48 -d r -c 2 -m tr;睡1完毕星期日十二月20 00:51:45 UTC 20200天67星期日十二月20 00:51:46世界标准时间20200天67星期日十二月20 00:51:48世界标准时间20200天66星期日十二月20 00:51:49 UTC 20200天66^ C[root @ pizero1〜]＃</p><p>  After some trial and error I also add  -m tr to set the  addressing mode to  complete-transfer which is needed on this I2C bus to make everything work.</p><p>  经过一番尝试和错误之后，我还添加了-m tr来将寻址模式设置为完全传输，这是该I2C总线所需的，以便使所有工作正常。 </p><p>  The reading shown is a hex value, exactly two bytes as requested with  -c 2.</p><p>显示的读数是一个十六进制值，正好是-c 2请求的两个字节。</p><p>  When reading temperature from this sensor I don&#39;t need to add  -o to the  i2c(8) command to specify an offset, since the temperature is stored in the first register in the device. If I wanted to read from the next register (which for the  TMP117 is where the configuration is stored) I would use  -o 1: [root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr -o 122 20 [root@pizero1 ~]#</p><p>  从该传感器读取温度时，由于温度存储在设备的第一个寄存器中，因此我无需在i2c（8）命令中添加-o来指定偏移量。如果要读取下一个寄存器（用于TMP117的寄存器是存储配置的位置），则可以使用-o 1： [root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr -o 122 20[root @ pizero1〜]＃</p><p>  All the registers in the  TMP117 are 16 bits (or two bytes), but the  I2C command can read or write any number of bytes, just specify the width with  -c.</p><p>  TMP117中的所有寄存器均为16位（或2个字节），但是I2C命令可以读取或写入任意数量的字节，只需使用-c指定宽度即可。</p><p>  Trying to read more data than the register size just results in FF bytes being returned:</p><p>  尝试读取比寄存器大小更多的数据只会导致返回FF字节：</p><p>  [root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr0c bc [root@pizero1 ~]# i2c -a 48 -d r -c 4 -m tr0c bc ff ff [root@pizero1 ~]# i2c -a 48 -d r -c 40 -m tr0c bd ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr0c bc[root @ pizero1〜]＃i2c -a 48 -d r -c 4 -m tr0c bc ff ff[root @ pizero1〜]＃i2c -a 48 -d r -c 40 -m tr0c bd ff ff ff ff ff ff ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff[root @ pizero1〜]＃</p><p>    The  i2c(8) utility also makes it easy to write values back to the device. The  TMP117 sensor has a programmable low and high thresholds in registers 2 and 3. The first one defaults to  0x6000 and changing it is much like reading, except we want the bytes to be written on  stdin:</p><p>    i2c（8）实用程序还使将值写回到设备变得容易。 TMP117传感器在寄存器2和3中具有可编程的低阈值和高阈值。第一个传感器的默认阈值为0x6000，对其进行更改与读取非常相似，不同之处在于，我们希望将字节写入stdin：</p><p>  [root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr -o 260 00 [root@pizero1 ~]# echo -en &#34;\x60\x01&#34; | i2c -a 48 -d w -c 2 -m tr -o 2[root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr -o 260 01 [root@pizero1 ~]# echo -en &#34;\x60\x00&#34; | i2c -a 48 -d w -c 2 -m tr -o 2[root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr -o 260 00 [root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr -o 260 00[root @ pizero1〜]＃echo -en＆＃34; \ x60 \ x01＆＃34; | i2c -a 48 -d w -c 2 -m tr -o 2[root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr -o 260 01[root @ pizero1〜]＃echo -en＆＃34; \ x60 \ x00＆＃34; | i2c -a 48 -d w -c 2 -m tr -o 2[root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr -o 260 00[root @ pizero1〜]＃ </p><p>    Reading the  datasheet for the  TMP117 sensor I learned that the temperature readings are stored in the first register, as a 16-bit value, which means I use  -c 2 for  i2c(8) so it reads two bytes (16 bits) from the sensor.</p><p>读取TMP117传感器的数据表后，我了解到温度读数以16位值的形式存储在第一个寄存器中，这意味着我对i2c（8）使用-c 2，因此它从I2c（8）读取了两个字节（16位）。传感器。</p><p>  The datasheet for the  TMP117 has this to say about the register where the temperature is stored:  The data in the result register is in two&#39;s complement format, has a data width of 16 bits and a resolution of 7.8125m °C..</p><p>  TMP117的数据表中有关于温度存储寄存器的说法：结果寄存器中的数据为二进制补码格式，数据宽度为16位，分辨率为7.8125m°C。 。</p><p>    Two&#39;s complement is a widely used and convenient way to work with signed (negative) numbers in binary. Basically the most significant bit is used to indicate if what follows is a positive or a negative binary number.</p><p>    二进制补码是一种广泛使用的便捷方式，用于处理二进制中的带符号（负）数字。基本上，最高有效位用于指示紧随其后的是正数还是负数。</p><p>  The following table is from the  TMP117 datasheet, it shows some sample temperatures in celcius and what those readings translate to in decimal, two&#39;s complement binary, and hex:</p><p>  下表来自TMP117数据表，它以摄氏度显示一些样品温度，这些读数以十进制，两个补码二进制和十六进制表示的含义：</p><p>    I haven&#39;t worked much with  two&#39;s complement format, so I started out by familiarising myself with it in Python. I borrowed the following function from  SO and started out by reproducing the values in the above table:</p><p>    我在使用补码格式方面工作不多，所以我首先在Python中熟悉了它。我从SO借用了以下函数，并通过重现上表中的值开始了它：</p><p>  [root@pizero1 ~]# cat twos.py #!/usr/bin/env python3import sysdef twos(binary_str, bytecount): integer = int(binary_str, bytecount) bytes = integer.to_bytes(bytecount, byteorder=&#34;big&#34;, signed=False) return int.from_bytes(bytes, byteorder=&#34;big&#34;, signed=True)print(twos(sys.argv[1], int(sys.argv[2])))[root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃cat twos.py＃！/ usr / bin / env python3导入系统def twos（binary_str，bytecount）： 整数= int（binary_str，字节数） bytes = integer.to_bytes（bytecount，byteorder =＆＃34; big＆＃34;，signed = False） 返回int.from_bytes（bytes，byteorder =＆＃34; big＆＃34;，signed = True）打印（twos（sys.argv [1]，int（sys.argv [2]）））[root @ pizero1〜]＃</p><p>    [root@pizero1 ~]# echo &#34;$(python twos.py 1000000000000000 2) * 0.0078125&#34; | bc-256.0000000[root@pizero1 ~]# echo &#34;$(python twos.py 1111001110000000 2) * 0.0078125&#34; | bc-25.0000000[root@pizero1 ~]# echo &#34;$(python twos.py 1111111111110000 2) * 0.0078125&#34; | bc-.1250000[root@pizero1 ~]# echo &#34;$(python twos.py 1111111111111111 2) * 0.0078125&#34; | bc-.0078125[root@pizero1 ~]# echo &#34;$(python twos.py 0000000000000000 2) * 0.0078125&#34; | bc0[root@pizero1 ~]# echo &#34;$(python twos.py 0000000000000001 2) * 0.0078125&#34; | bc.0078125[root@pizero1 ~]# echo &#34;$(python twos.py 0000000000010000 2) * 0.0078125&#34; | bc.1250000[root@pizero1 ~]# echo &#34;$(python twos.py 0000000010000000 2) * 0.0078125&#34; | bc1.0000000[root@pizero1 ~]# echo &#34;$(python twos.py 0000110010000000 2) * 0.0078125&#34; | bc25.0000000[root@pizero1 ~]# echo &#34;$(python twos.py 0011001000000000 2) * 0.0078125&#34; | bc100.0000000[root@pizero1 ~]# echo &#34;$(python twos.py 0111111111111111 2) * 0.0078125&#34; | bc255.9921875[root@pizero1 ~]#</p><p>    [root @ pizero1〜]＃echo＆＃34; $（python twos.py 1000000000000000 2）* 0.0078125＆＃34; |公元前-256.0000000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 1111001110000000 2）* 0.0078125＆＃34; |公元前-25.0000000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 1111111111110000 2）* 0.0078125＆＃34; |公元前-.1250000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 1111111111111111 2）* 0.0078125＆＃34; |公元前-.0078125[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0000000000000000 2）* 0.0078125＆＃34; |公元前0[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0000000000000001 2）* 0.0078125＆＃34; |公元前.0078125[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0000000000010000 2）* 0.0078125＆＃34; |公元前.1250000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0000000010000000 2）* 0.0078125＆＃34; |公元前1.0000000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0000110010000000 2）* 0.0078125＆＃34; |公元前25.0000000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0011001000000000 2）* 0.0078125＆＃34; |公元前100.0000000[root @ pizero1〜]＃echo＆＃34; $（python twos.py 0111111111111111 2）* 0.0078125＆＃34; |公元前255.9921875[root @ pizero1〜]＃ </p><p>  Looks like it works perfectly. Going from a reading to celcius is also easy, I tested with the values from the table again:</p><p>看起来效果很好。从读数到摄氏也很容易，我再次测试了表中的值：</p><p>  [root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;8000&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;-256.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;F380&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;-25.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;FFF0&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;-0.125[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;FFFF&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;-0.0078125[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;0000&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;0.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;0001&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;0.0078125[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;0010&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;0.125[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;0080&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;1.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;0C80&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;25.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;3200&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;100.0[root@pizero1 ~]# python -c &#39;print(round(int.from_bytes(bytearray.fromhex(&#34;7FFF&#34;), byteorder=&#34;big&#34;, signed=True) * 0.0078125, 8))&#39;255.9921875[root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 8000＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;-256.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; F380＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;-25.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; FFF0＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;-0.125[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; FFFF＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;-0.0078125[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 0000＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;0.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 0001＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;0.0078125[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 0010＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;0.125[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 0080＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;1.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 0C80＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;25.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 3200＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;100.0[root @ pizero1〜]＃python -c＆＃39; print（round（int.from_bytes（bytearray.fromhex（＆＃34; 7FFF＆＃34;），byteorder =＆＃34; big＆＃34;，signed = True ）* 0.0078125，8））＆＃39;255.9921875[root @ pizero1〜]＃</p><p>  This means taking a reading from the sensor and converting it to celcius can be done like this:</p><p>  这意味着可以像这样从传感器获取读数并将其转换为摄氏温度：</p><p>  [root@pizero1 ~]# i2c -a 48 -d r -c 2 -m tr0c 81 [root@pizero1 ~]# python -c &#34;print(round(int.from_bytes(bytearray.fromhex(&#39;0c 81&#39;), byteorder=&#39;big&#39;, signed=True) * 0.0078125, 8))&#34;25.0078125[root@pizero1 ~]#</p><p>  [root @ pizero1〜]＃i2c -a 48 -d r -c 2 -m tr0分81分[root @ pizero1〜]＃python -c＆＃34; print（round（int.from_bytes（bytearray.fromhex（＆＃39; 0c 81＆＃39;），byteorder =＆＃39; big＆＃39;，signed =是的）* 0.0078125，8））＆＃34;25.0078125[root @ pizero1〜]＃</p><p>      A  PI Zero is cheap, and along with a TMP117 you have a nice FreeBSD based high precision temperature measurement setup for like 160,- DKK (just over 20€).</p><p>      PI Zero价格便宜，并且与TMP117一起，您还可以使用基于FreeBSD的出色的高精度温度测量设置，价格约为160-丹麦克朗（仅20欧元以上）。</p><p>  Since the  QWIIC sensors can be daisychained such a setup can easily be expanded with more sensors to measure more stuff. Most of the sensors have existing high-quality Arduino libraries (the  TMP117 is no different) if interpreting the data turns out to be tricky.</p><p>  由于QWIIC传感器可以通过菊花链连接，因此可以通过更多传感器轻松扩展设置，以测量更多东西。如果解释数据非常棘手，则大多数传感器都具有现有的高质量Arduino库（TMP117也不例外）。</p><p>  Next step is to take a look at getting FreeBSD support into SparkFuns  Qwiic_Py Python package, which requires  getting FreeBSD support in  Qwiic_I2C_Py which in turn depends on  getting FreeBSD support in  smbus2.   I&#39;ve recently signed up for  Github Sponsors meaning it is now easy to sponsor me and my work. If this post or some of my other writing, software or services have helped you then you can consider  becoming a sponsor.</p><p>  下一步是看看如何在SparkFuns Qwiic_Py Python软件包中获得FreeBSD支持，这需要在Qwiic_I2C_Py中获得FreeBSD支持，而这又取决于在smbus2中获得FreeBSD支持。   我最近注册了Github赞助商，这意味着现在可以很容易地赞助我和我的工作。如果这篇文章或我的其他著作，软件或服务对您有帮助，那么您可以考虑成为赞助商。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.tyk.nu/blog/freebsd-and-i2c/">https://blog.tyk.nu/blog/freebsd-and-i2c/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/freebsd/">#freebsd</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/i2c/">#i2c</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>