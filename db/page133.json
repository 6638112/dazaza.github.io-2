[{"category": "", "categoryclass": "", "imagename": "", "infoid": 1072567, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u57c3\u83f2\u5c14\u534f\u8bae\u57282012\u5e74\u7684\u5149\u4e4b\u4eae\u662f\u7231\u7acb\u4fe1\u4e2d\u7684\u5927\u89c4\u6a21\u8f6f\u4ef6\u96c6\u6210\u7684\u534f\u8bae\u3002 2016\u5e74\u7231\u7acb\u4fe1\u521d\u6b65\u8d21\u732e\u8be5\u534f\u8bae\u5f00\u6e90\uff0c\u4ece\u90a3\u4ee5\u540e\u4e00\u76f4\u4e0e\u793e\u533a\u5408\u4f5c\uff0c\u4ee5\u521b\u5efa\u5b83\u7684\u5f00\u6e90\u5b9e\u73b0\u3002\u6765\u81ea\u5927\u578b\u7535\u4fe1\u7cfb\u7edf\u7684\u4e16\u754c\uff0c\u5b83\u662f\u4e3a\u53ef\u6269\u5c55\u6027\u548c\u5bf9\u53ef\u8ffd\u6eaf\u6027\u7684\u9700\u6c42\u800c\u8bbe\u8ba1\u7684\u3002\u540c\u65f6\uff0c\u534f\u8bae\u7684\u8bbe\u8ba1\u53ca\u5176\u5b9e\u73b0\u53ef\u786e\u4fdd\u60a8\u53ef\u4ee5\u9009\u62e9\u4e0e\u60a8\u76f8\u5173\u7684\u96f6\u4ef6\u3002\u8fd9\u63d0\u4f9b\u4e86\u4e00\u79cd\u6613\u4e8e\u91c7\u7528\u4f46\u9ad8\u5ea6\u7075\u6d3b\u4e14\u53ef\u6269\u5c55\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ef\u4ee5\u968f\u7740\u60a8\u7684\u9700\u6c42\u800c\u589e\u957f\u3002", "note_en": "The Eiffel protocol saw the light of day in 2012 as a protocol for large-scale software integration within Ericsson. In 2016 Ericsson made the initial contribution of the protocol to open source, and has since then been collaborating with the community to create open source implementations of it. Coming from the world of large telecommunications systems it was designed for scalability and high demands on traceability. At the same time, the design of the protocol and its implementations ensures that you can cherry-pick the parts that are relevant to you. This affords an easy-to-adopt yet highly flexible and scalable solution that will grow along with your needs.", "posttime": "2022-01-10 06:39:55", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "ci,traceable,\u534f\u8bae", "title": "EIFFIL  -  CI / CD ECO\u7cfb\u7edf\u7684\u53ef\u8ffd\u8e2a\u5b9e\u65f6\u6d88\u606f\u4f20\u9012\u534f\u8bae", "title_en": "Eiffel \u2013 Traceable real time messaging protocol for CI/CD eco systems", "transed": 1, "url": "https://eiffel-community.github.io/", "via": "", "real_tags": ["ci", "traceable", "\u534f\u8bae"]}, {"category": "", "categoryclass": "", "imagename": "6db74e6e2529a27f59efbb63314a8c2f.jpeg", "infoid": 1072566, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u4eb2\u7231\u7684\u793e\u533a\uff0c\u6211\u4eec\u5f88\u81ea\u8c6a\u80fd\u6210\u4e3a\u7b2c\u4e00\u5bb6\u5ba3\u5e03\u6700\u65b0\u7684RK3588\u4ea7\u54c1 -  Rock5B SBC\u7684\u4f9b\u5e94\u5546\u4e4b\u4e00\u3002\u7279\u70b9\u6982\u8ff0\u5ca9\u4f535B\uff1aRock5B\u4eae\u70b9PI-CO ITX\u5f62\u72b6\u56e0\u5b50\uff082.5\u82f1\u5bf8\uff0c100 x 72mm\uff09RK3588 Powered\uff0c8NM\u5236\u9020\u8fc7\u7a0bQuad A76 2.4GHz +\u56db\u5206\u4e4b\u4e00A55 1.8GHz Mali G610MC4 GPU\uff08\u6700\u591a5\u901a\u90534K UI\uff096T NPU 8K 10bit\u89e3\u7801\u5668\uff0c8K\u7f16\u7801\u5668\u652f\u6301WiFi 6e\u548cBT5.2\u652f\u6301PCIe 3.0 X4 NVME SSD\u4e09\u91cd\u663e\u793a\u5c4f\u652f\u6301\uff08\u5e26HDR\uff09\u4e24\u4e2aHDMI 2.1 up\u52308k @ 60fps\u4e00\u4e2aUSB C W ...", "note_en": "Dear community,  We are so proud to be one of the first vendor to announce our latest RK3588 based product - ROCK5B SBC.  Feature overview for ROCK 5B:    ROCK5B Highlights  PI-co ITX form factor(2.5 inch, 100 x 72mm) RK3588 powered, 8nm manufacturing process  Quad A76 2.4Ghz + Quad A55 1.8Ghz Mali G610MC4 GPU(up to 5 channel 4K UI) 6T NPU 8K 10bit decoder, 8K encoder   Support WiFi 6E and BT5.2 Support PCIe 3.0 x4 NVMe SSD Triple display support(with HDR)  Two HDMI 2.1up to 8K@60FPS One USB C w...", "posttime": "2022-01-10 06:37:59", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u5ca9\u77f3,rock,\u652f\u6301", "title": "\u4ecb\u7ecd\u5ca9\u77f35\u578b\u53f7B  -  ARM\u684c\u9762\u7ea7SBC", "title_en": "Introduce ROCK 5 Model B - ARM desktop level SBC", "transed": 1, "url": "https://forum.radxa.com/t/introduce-rock-5-model-b-arm-desktop-level-sbc/8361", "via": "", "real_tags": ["\u5ca9\u77f3", "rock", "\u652f\u6301"]}, {"category": "", "categoryclass": "", "imagename": "b00058ccd20d70029a6dd084ae39bfb9.jpeg", "infoid": 1072565, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u4f5c\u4e3a\u4f18\u6b65\u5de5\u7a0b\u7684\u4e00\u90e8\u5206\u52aa\u529b\u8fbe\u5230\u76c8\u5229\u80fd\u529b\uff0c\u6700\u8fd1\u6211\u4eec\u7684\u56e2\u961f\u901a\u8fc7\u63d0\u9ad8\u6548\u7387\u6765\u964d\u4f4e\u8ba1\u7b97\u80fd\u529b\u7684\u6210\u672c\u3002\u4e00\u4e9b\u6700\u6709\u5f71\u54cd\u529b\u7684\u5de5\u4f5c\u662fGogc\u4f18\u5316\u3002\u5728\u672c\u535a\u5ba2\u4e2d\uff0c\u6211\u4eec\u5e0c\u671b\u5229\u7528\u9ad8\u6548\uff0c\u4f4e\u98ce\u9669\uff0c\u5927\u89c4\u6a21\uff0c\u534a\u81ea\u52a8\u5316GO GC\u8c03\u6574\u673a\u5236\u5206\u4eab\u6211\u4eec\u7684\u7ecf\u9a8c\u3002\n\u5b83\u4e0d\u77e5\u9053\u5206\u914d\u7ed9\u5bb9\u5668\u7684\u6700\u5927\u5185\u5b58\uff0c\u53ef\u80fd\u5bfc\u81f4\u5185\u5b58\u95ee\u9898\u3002\n\u4f7f\u7528Madv_free\u5185\u5b58\u7b56\u7565\u7684\u670d\u52a1\u5bfc\u81f4\u9519\u8bef\u7684\u5185\u5b58\u6307\u6807\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u7684\u53ef\u89c2\u5bdf\u6027\u5ea6\u91cf\u6807\u51c6\u663e\u793a\u4e8650\uff05\u7684\u5185\u5b58\u5229\u7528\u7387\uff08\u5f53\u5b83\u5b9e\u9645\u4e0a\u5df2\u7ecf\u53d1\u5e03\u4e8650\uff05\u768420\uff05\u65f6\uff09\u3002\u7136\u540e\uff0c\u670d\u52a1\u6240\u6709\u8005\u53ea\u4f7f\u7528\u6b64\u201c\u4e0d\u51c6\u786e\u201d\u5ea6\u91cf\u6807\u51c6\u8c03\u6574Gogc\u3002\n\u8c03\u7528\u8fd0\u884c\u65f6\u3002 setfinalizer\uff08f\uff0cfinalizer handler\uff09\u5728FinalizerHandler\u5185\u90e8\u5141\u8bb8\u5904\u7406\u7a0b\u5e8f\u5728\u6bcf\u4e2aGC\u4e0a\u8fd0\u884c;\u5b83\u57fa\u672c\u4e0a\u6ca1\u6709\u8ba9\u53c2\u8003\u6a21\u5177\uff0c\u56e0\u4e3a\u5b83\u4e0d\u662f\u4fdd\u6301\u6d3b\u529b\u7684\u6602\u8d35\u8d44\u6e90\uff08\u5b83\u53ea\u662f\u4e00\u4e2a\u6307\u9488\uff09\u3002", "note_en": "As part of Uber engineering\u2019s wide efforts to reach profitability, recently our team was focused on reducing cost of compute capacity by improving efficiency. Some of the most impactful work was around GOGC optimization. In this blog we want to share our experience with a highly effective, low-risk, large-scale, semi-automated Go GC tuning mechanism.\n Uber\u2019s tech stack is composed of thousands of microservices, backed by a cloud-native, scheduler-based infrastructure. Most of these services are written in Go. Our team, Maps Production Engineering, has previously played an instrumental role in significantly improving the efficiency of multiple Java services by tuning GC. At the beginning of 2021, we explored the possibilities of having a similar impact on Go-based services. We ran several CPU profiles to assess the current state of affairs and we found that GC was the top CPU consumer for a vast majority of mission-critical services. Here is a representation of some CPU profiles where GC (identified by the  runtime.scanobject method) is consuming a significant portion of allocated compute resources.\n        Emboldened by this finding, we commenced to tune GC for the relevant services. To our delight, Go\u2019s GC implementation and the simplicity of tuning allowed us to automate the bulk of the detection and tuning mechanism. We detail our approach and its impact in the following sections.\n   Go runtime invokes a concurrent garbage collector at periodic intervals unless there is a triggering event before it. The triggering events are based on memory back pressure. Due to this, GC-impacted Go services benefit from more memory, since it reduces the times GC has to run. In addition, we realized that our host-level CPU to memory ratio is 1:5 (1 core : 5 GB RAM), while most Golang services were configured with a 1:1 to 1:2 ratio. Therefore, we were confident that we could leverage using more memory to reduce GC CPU impact. This is a service-agnostic mechanism that can yield a large impact when applied judiciously.\n Delving deep into Go\u2019s garbage collection is beyond the scope of this article, but here are the relevant bits for this work: Garbage collection in Go is concurrent and involves analyzing all objects to identify which ones are still reachable. We would call the reachable objects the \u201clive dataset.\u201d Go offers only one knob,   GOGC,  expressed in percentage of live dataset, to control garbage collection. The   GOGC  value acts as a multiplier for the dataset. The default value of   GOGC  is 100%, which means Go runtime will reserve the same amount of memory for new allocations as the live dataset. For instance:\n  Then the   pacer  is in charge of predicting when it is the best time to trigger GC to avoid hitting the hard target (soft target).\n     We identified that a fixed GOGC value-based tuning is not suitable for services at Uber. Some of the challenges are:\n It is not aware of the maximum memory assigned to the container and can cause out of memory issues.\n Our microservices have a significantly diverse memory utilization portfolio. For example, a sharded system can have very different live datasets. We experienced this in one of our services where the p99 utilization was 1G but the p1 was 100MB, therefore the 100MB instances were having a huge GC impact.\n   The pain points previously presented are the reason for the conception of GOGCTuner. GOGCTuner is a library which simplifies the process of tuning garbage collection for service owners and adds a reliability layer on top of it.\n GOGCTuner dynamically computes the correct GOGC value in accordance with the container\u2019s memory limit (or the upper limit from the service owner) and sets it using Go\u2019s runtime API. Following are the specifics of the GOGCTuner library\u2019s features:\n Simplified configuration for easier reasoning and deterministic calculations. GOGC at 100% is not clear for beginner Go developers and it is not deterministic, because it still depends on the live dataset. On the other hand a 70% limit ensures that the service is always going to use 70% of the heap space.\n Protection against OOMs (Out Of Memory): The library reads the memory limit from the cgroup and uses a default hard limit of 70%, a safe value from our experience. It is important to note that there is a limit to this protection. The tuner can only adjust the buffer allocation, so if your service live objects are higher than the limit the tuner would set a default lower limit of 1.25X your live objects utilization.\n Allow higher GOGC values for corner cases like: As we mentioned above, manual GOGC is not deterministic. We are still relying on the size of the live dataset. What if live_dataset doubles our last peak value? GOGCTuner would enforce the same memory limit at the cost of more CPU. Manual tuning instead could cause OOMs. Therefore, service owners used to give plenty of buffer for these types of scenarios. See the example below:\n           Services using   MADV_FREE  memory policy that results in wrong memory metrics. For instance, our observability metrics were showing 50% memory utilization (when it actually had already released 20% of that 50%). Then service owners were only tuning GOGC using this \u201cinaccurate\u201d metric.\n   We found that we lacked some critical metrics which would give us more insights into garbage collection of each service.\n Intervals between garbage collections : useful to know if we can still tune. For instance, Go forces a garbage collection every 2 minutes. If your service is still having high GC impact, but you already see 120s for this graph, it means that you can no longer tune using GOGC. In this case you would need to optimize your allocations.\n    GC CPU impact : allows us to know which services are the most affected by GC.\n    Live dataset size : helps us to identify memory leaks. The concern noted by service owners was that they saw an increase in memory utilization. In order to show them there was no memory leak we added the \u201clive usage\u201d metric, which showed a steady utilization.\n          Our initial approach was to have a ticker to run every second to monitor the heap metrics, and then adjust GOGC value accordingly. The disadvantage of this approach is that the overhead starts to become considerable, because in order to read heap metrics Go needs to do a STW (  ReadMemStats ) and it is somewhat inaccurate, because we can have more than one garbage collection per second.\n Luckily we were able to find a good alternative. Go has finalizers (  SetFinalizer ), which are functions that run when the object is going to be garbage collected. They are mainly useful for cleaning memory in C code or some other resources. We were able to employ a self-referencing finalizer that resets itself on every GC invocation. This allows us to reduce any CPU overhead. For instance:\n   Calling   runtime . SetFinalizer ( f ,  finalizerHandler )  inside of  finalizerHandler  is what allows the handler to run on every GC; it is basically not letting the reference die, since it is not a costly resource to keep alive (it is just a pointer).\n   After deploying GOGCTuner across a few dozen of our services, we dove deep on a few that showed significant, double-digit improvement in their CPU utilization. Accumulated cost savings from these services alone are around 70K cores. Following are 2 such examples:\n       The resulting CPU utilization reduction improves p99 latency (and associated SLA, user experience) tactically, and cost of capacity strategically (since services are scaled based on their utilization).\n   Garbage collection is one of the most elusive and underestimated performance influencers of an application. Go\u2019s robust GC mechanism and simplified tuning, our diverse, large-scale Go services footprint, and a robust internal platform (Go, compute, observability) collectively allowed us to make such a large-scale impact. We expect to continue improving how we tune GC as the problem space itself is evolving, due to changes in the tech and our competency.\n To reiterate what we mentioned at the introduction: there is no one size fits all solution. We feel GC performance will remain variable in cloud-native setup due to the highly variable performance of both public clouds and containerized workloads that run within. Coupled with the fact that a vast majority of CNCF landscape projects that we use are written in Golang (Kubernetes, Prometheus, Jaeger, etc.), this means any large-scale deployment outside could also benefit from such effort.", "posttime": "2022-01-10 06:37:15", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u534a\u81ea\u52a8,semi,\u5185\u5b58", "title": "\u6211\u4eec\u5982\u4f55\u4f7f\u7528\u534a\u81ea\u52a8GO GC\u8c03\u6574\u4fdd\u5b5870K\u5185\u6838", "title_en": "How We Saved 70K Cores with Semi-Automated Go GC Tuning", "transed": 1, "url": "https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/", "via": "", "real_tags": ["\u534a\u81ea\u52a8", "semi", "\u5185\u5b58"]}, {"category": "", "categoryclass": "", "imagename": "6003c74de391823d5141a450b25fecf9.jpg", "infoid": 1072564, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u6fb3\u5927\u5229\u4e9a\u7684\u6089\u5c3c\u897f\u5317\u6570\u767e\u82f1\u91cc\u7684\u6fb3\u5927\u5229\u4e9a\u4e2d\u592e\u5927\u6559\u5802\uff0c\u4eca\u5929\u7531\u8349\u548c\u7ea4\u7ef4\u6811\u5360\u4e3b\u5bfc\u5730\u4f4d\u3002\u4f46\u79d1\u5b66\u5bb6\u6700\u8fd1\u53d1\u73b0\uff0c\u4e00\u4e9b\u5730\u533a\u7684\u751f\u9508\u5ca9\u77f3\u63a9\u76d6\u4e86\u90c1\u90c1\u8471\u8471\u7684\u96e8\u6797\u7684\u75d5\u8ff9\uff0c\u8fd9\u4e9b\u96e8\u6797\u5728\u4e2d\u95f4\u65f6\u4ee3\u7eaa\u5ff5\u671f\u95f4\u6db5\u76d6\u4e861500\u4e07\u5e74\u524d\u7684\u8302\u5bc6\u96e8\u6797\u3002\n\u8be5\u7f51\u7ad9\u8fd8\u4ea7\u751f\u4e86\u5341\u51e0\u4e2a\u53e4\u8001\u7684arachnids\u3002\u867d\u7136\u6606\u866b\u5177\u6709\u575a\u56fa\u7684\u5916\u9aa8\u9abc\uff0c\u8fc8\u514b\u5c14\u00b7\u5f17\u96f7\u6cfd\uff0c\u582a\u57f9\u62c9\u5927\u5b66\u7684\u75c5\u6bd2\u5b66\u5bb6\u548c\u53e4\u751f\u7269\u5b66\u5bb6\u4ee5\u53ca\u8be5\u7814\u7a76\u7684\u5171\u540c\u4f5c\u8005\uff0c\u5c06\u8718\u86db\u6bd4\u8f83\u201c\u6324\u538b\u888b\u201d\u3002\u56e0\u6b64\uff0c\u6fb3\u5927\u5229\u4e9a\u7684\u8718\u86db\u5316\u77f3\u8bb0\u5f55\u51e0\u4e4e\u4e0d\u5b58\u5728\uff0c\u5728\u9ea6\u683c\u62c9\u65af\u5e73\u5766\u4e4b\u524d\u3002\n\u201c\u7814\u7a76\u8fd9\u4e9b\u5316\u77f3\u751f\u6001\u7cfb\u7edf\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u54ea\u4e9b\u7269\u79cd\u66f4\u80fd\u591f\u9002\u5e94\u8fd9\u4e9b\u53d8\u5316\uff0c\u201d\u9ea6\u514b\u62c9\u7279\u535a\u58eb\u8bf4\u3002 \u201c\u6211\u4eec\u53ef\u4ee5\u5728\u672a\u6765\u7684\u53d8\u5316\u65b9\u9762\u9884\u6d4b\u6700\u591a\u7684\u98ce\u9669\u3002\u201d", "note_en": "Australia\u2019s Central Tablelands, hundreds of miles northwest of Sydney, are dominated today by grasses and spindly trees. But scientists recently discovered that some of the area\u2019s rusted rocks conceal traces of the lush rainforests that covered the area 15 million years ago during the Miocene Epoch.\n The area, McGraths Flat, is not Australia\u2019s only Miocene deposit, but these new fossils are a paleontological boon because of their exquisite preservation. Over the past three years paleontologists have excavated flowers, insects and even a bird\u2019s wispy feather.\n The scientists\u2019 discoveries,  published Friday in the journal Science Advances, help reconstruct Australia\u2019s Miocene rainforest in extensive detail, and the site \u201copens a whole new area of exploration for Australian paleontology,\u201d said Scott Hocknull, a paleontologist at Queensland Museum who was not involved in the research.\n Fifteen million years ago, a river carved through the jungle, leaving an oxbow lake (known as a billabong in Australia) in its wake at McGraths Flat. Nearly devoid of oxygen, this stagnant pool kept scavengers at bay, allowing plant material and animal carcasses to accumulate. As iron-rich runoff from nearby basalt mountains seeped into the billabong, the pool\u2019s low pH caused the iron to precipitate and encase the organic material. As a result, the fossils at McGraths Flat are preserved in a dense, iron-rich rock known as goethite.\n  This method of fossilization is uncommon, Dr. Hocknull said. Because quality fossils are rarely found in igneous rocks, paleontologists often overlook them. However, the fossils from McGraths Flat illustrate that goethite, which is common in Australia, can yield remarkable fossils.\n \u201cThere\u2019s no shortage of goethite,\u201d Dr. Hocknull said. \u201cWe\u2019re essentially a rusting country.\u201d\n   Because of their iron-tinted origins, many of the fossils from McGraths Flat glimmer with a metallic sheen. In addition to pristine plants, the goethite is crawling with fossilized insects. As they split apart the brick-colored slabs of stone, the researchers have discovered a miniature menagerie of giant cicadas, dragonflies and parasitic wasps. And many are remarkably preserved \u2014 some ancient flies sport the detailed imprints of their compound eyes.\n The site has also yielded more than a dozen archaic arachnids. While insects have sturdy exoskeletons, Michael Frese, a virologist and paleontologist at the University of Canberra and a co-author of the study, likens spiders to \u201csquishy bags of liquid.\u201d As a result, Australia\u2019s fossil record of spiders was nearly nonexistent before McGraths Flat.\n  The fossils are so well preserved that the paleontologists were able to observe relationships between species \u2014 something that is often difficult to parse from fossil sites, according to Matthew McCurry, the curator of paleontology at The Australian Museum and the study\u2019s lead author. For example, the team observed parasites fastened to a fish\u2019s tail and a nematode that had infiltrated a longhorn beetle.\n Dr. Frese utilized an electron microscope and microphotography techniques to examine the rainforest\u2019s inhabitants. While imaging a fossilized sawfly, Dr. Frese discovered a clump of pollen on the bee-like insect\u2019s head.\n \u201cWe can tell which flower was visited by this particular sawfly before it fell into the water and met its untimely end,\u201d Dr. Frese said. \u201cThat would not be possible if the quality of preservation was not as high.\u201d\n   The pollen also revealed that the rainforest was surrounded by drier environments, making it likely that McGraths Flat represents a remnant patch of a once larger forest. According to Dr. McCurry, this makes sense considering the climatic trends of the Miocene.\n When these insects scurried around the iron-tainted billabong, Australia was drifting northward, away from Antarctica. As it traveled, its climate drastically dried out, causing the rainforests to retract and leading to widespread extinctions.\n  The researchers believe McGraths Flat offers an intimate glimpse of how this dramatic climate transition affected particular species within the rainforest ecosystem. For instance, some insects found at McGraths Flat endured drier conditions while others are now found only in northern Australia\u2019s remnant pockets of rainforest.\n \u201cStudying these fossil ecosystems, we can see which species were better able to adapt to those changes,\u201d Dr. McCurry said. \u201cWe can potentially predict which are most at risk in terms of future changes.\u201d\n Dr. Frese said that McGraths Flat was particularly useful for reconstructing ancient ecosystems because of the breadth of species it preserved.\n \u201cOur site is different because it\u2019s all small fossils, but in the end, I think it will tell us more about what has happened in the ecosystem,\u201d Dr. Frese said. \u201cYou do not need to find a one-ton terror bird to tell this story.\u201d", "posttime": "2022-01-10 05:43:04", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "rust,\u96e8\u6797,prehistoric,\u53d8\u5316", "title": "\u53f2\u524d\u96e8\u6797\u7684\u5316\u77f3\u5728\u6fb3\u5927\u5229\u4e9a\u751f\u9508\u7684\u5ca9\u77f3\u91cc\u85cf\u8d77\u6765", "title_en": "Fossils of a Prehistoric Rainforest Hide in Australia\u2019s Rusted Rocks", "transed": 1, "url": "https://www.nytimes.com/2022/01/07/science/fossils-australia-rainforest.html", "via": "", "real_tags": ["rust", "\u96e8\u6797", "\u53d8\u5316"]}, {"category": "", "categoryclass": "", "imagename": "7cf484ceeae6bc7fc2161eddc603cd15.jpg", "infoid": 1072563, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u6211\u8981\u5e26\u9886\u6280\u672f\u6821\u6b63\u7ebf\uff0c\u7136\u540e\u89e3\u91ca\u4e00\u4e0b\uff1a\n\u572890\u5e74\u4ee3\u56de\u6765\uff0c\u6211\u5728\u5927\u5b66\u5de5\u4f5c\uff0c\u6211\u50cf\u5176\u4ed6\u6bcf\u4f4d\u5458\u5de5\u4e00\u6837\uff0c\u5728\u6211\u7684\u684c\u5b50\u4e0a\u6709\u4e00\u4e2a\u6ca1\u6709\u58c1\u7684\u516c\u5171\u77e5\u8bc6\u4ea7\u6743\u3002\u6211\u5b89\u88c5\u4e86\u4e00\u4e2aweb\u670d\u52a1\u5668\u548cpoof-instant\u7f51\u7ad9\u3002\u5982\u4eca\uff0c\u4ece\u5bb6\u91cc\u8fd0\u884c\u4e00\u4e2a\u7f51\u7ad9\u5c31\u662f\u4e0d\u53ef\u80fd\u7684\u3002\u60a8\u53ef\u80fd\u6ca1\u6709\u516c\u5171IP\uff0c\u5982\u679c\u60a8\u8fd9\u6837\u505a\uff0c\u5b83\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u60a8\u7684ISP\u53ef\u80fd\u4f1a\u963b\u6b62\u60a8\u5728\u5176\u4e0a\u8fd0\u884c\u670d\u52a1\u5668\u3002\n\u60a8\u53ef\u4ee5\u65c5\u884c\u5730\u7403\uff0c\u60a8\u7684IP\u5c06\u8ddf\u968f\u60a8\uff1a\u5728\u98de\u673a\u4e0a\uff0c\u4ece\u5927\u9646\u5230\u5927\u9646\uff0c\u65e0\u8bba\u4f55\u5904\u3002 yggdrasil\u4f1a\u627e\u5230\u4f60\u3002", "note_en": "I\u2019m going to lead with the technical punch line, and then explain it:\n Yggdrasil Network is an opportunistic mesh that can be deployed privately or as part of a global-scale network. Each node gets a stable IPv6 address (or even an entire /64) that is derived from its public key and is bound to that node as long as the node wants it (of course, it can generate a new keypair anytime) and is valid wherever the node joins the mesh. All traffic is end-to-end encrypted.\n Yggdrasil will automatically discover peers on a LAN via broadcast beacons, and requires zero configuration to peer in such a way. It can also run as an overlay network atop the public Internet. Public peers serve as places to join the global network, and since it\u2019s a mesh, if one device on your LAN joins the global network, the others will automatically have visibility on it also, thanks to the mesh routing.\n It neatly solves a lot of problems of portability (my ssh sessions stay live as I move networks, for instance), VPN (incoming ports aren\u2019t required since local nodes can connect to a public peer via an outbound connection), security, and so forth.\n   Every device on the Internet, at one time, had its own globally-unique IP address. This number was its identifier to the world; with an IP address, you can connect to any machine anywhere. Even now, when you connect to a computer to download a webpage or send a message, under the hood, your computer is talking to the other one by IP address.\n Only, now it\u2019s hard to get one. The Internet protocol we all grew up with, version 4 (IPv4), didn\u2019t have enough addresses for the explosive growth we\u2019ve seen. Internet providers and IT departments had to use a trick called NAT (Network Address Translation) to give you a sort of fake IP address, so they could put hundreds or thousands of devices behind a single public one. That, plus the mobility of devices \u2014 changing IPs whenever they change locations \u2014 has meant that a fundamental rule of the old Internet is now broken:\n  Nowadays, you can\u2019t you host your own website from your phone. Or share files from your house. (Without, that is, the use of some third-party service that locks you down and acts as an intermediary.)\n Back in the 90s, I worked at a university, and I, like every other employee, had a PC on my desk with an unfirewalled public IP. I installed a webserver, and poof \u2013 instant website. Nowadays, running a website from home is just about impossible. You may not have a public IP, and if you do, it likely changes from time to time. And even then, your ISP probably blocks you from running servers on it.\n In short, you have to buy your way into the resources to participate on the Internet.\n I wrote about these problems in more detail in my article  Recovering Our Lost Free Will Online.\n  I already gave away the punch line at the top. But what does all that mean?\n  Every device that participates gets an IP address that is fully live on the Yggdrasil network.\n You can host a website, or a mail server, or whatever you like with your Yggdrasil IP.\n Encryption and authentication are smaller (though not nonexistent) worries thanks to the built-in end-to-end encryption.\n You can travel the globe, and your IP will follow you: onto a plane, from continent to continent, wherever. Yggdrasil will find you.\n  I\u2019ve set up /etc/hosts on my laptop to use the Yggdrasil IPs for other machines on my LAN. Now I can just \u201cssh foo\u201d and it will work \u2014 from home, from a coffee shop, from a 4G tether, wherever. Now, other tools like tinc can do this, obviously. And I could stop there; I could have a completely closed, private Yggdrasil network.\n Or, I can join the global Yggdrasil network. Each device, in addition to accepting peers it finds on the LAN, can also be configured to establish outbound peering connections or accept inbound ones over the Internet. Put a public peer or two in your configuration and you\u2019ve joined the global network. Most people will probably want to do that on every device (because why not?), but you could also do that from just one device on your LAN. Again, there\u2019s no need to explicitly build routes via it; your other machines on the LAN will discover the route\u2019s existence and use it.\n This is one of many projects that are working to democratize and decentralize the Internet. So far, it has been quite successful, growing to over 2000 nodes. It is the direct  successor to the earlier cjdns/Hyperboria and BATMAN networks, and aims to be a proof of concept and a viable tool for global expansion.\n Finally, think about how much easier development is when you don\u2019t have to necessarily worry about TLS complexity in every single application. When you don\u2019t have to worry about port forwarding and firewall penetration. It\u2019s what the Internet should be.", "posttime": "2022-01-10 05:42:39", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u4e92\u8054\u7f51,instant,\u53ef\u80fd", "title": "\u4f7f\u7528\u5373\u65f6\u7f51\u72b6\u7f51\u7edc\u518d\u6b21\u4f7f\u4e92\u8054\u7f51\u6210\u4e3a\u60a8\u7684\u4e92\u8054\u7f51", "title_en": "Make the Internet Yours Again with an Instant Mesh Network", "transed": 1, "url": "https://changelog.complete.org/archives/10319-make-the-internet-yours-again-with-an-instant-mesh-network", "via": "", "real_tags": ["\u4e92\u8054\u7f51", "instant", "\u53ef\u80fd"]}]