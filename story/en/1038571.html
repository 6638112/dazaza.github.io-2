<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ORC – Nim的新内存管理 ORC – Nim's new memory managment</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ORC – Nim's new memory managment<br/>ORC – Nim的新内存管理 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-09 19:48:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/a498557a343dfd09fe4bac13a5a04699.png"><img src="http://img2.diglog.com/img/2020/12/a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Version 1.4 ships with the so-called ORC memory management algorithm.ORC is the existing ARC algorithm (first shipped in version 1.2) plus acycle collector. That’s also where the name comes from – the “O” standsfor a cycle and “RC” stands for “reference counting”, which is thealgorithm’s foundation.</p><p>1.4版附带了所谓的ORC内存管理算法.ORC是现有的ARC算法（1.2版中首次提供）以及acycle收集器。这也是名称的由来-“ O”代表循环，“ RC”代表“引用计数”，这是算法的基础。</p><p> The cycle collector is based on the pretty well known “trial deletion”algorithm by Lins and others. I won’t describe here how this algorithmworks – you can read the paperfor a good description.</p><p> 循环收集器基于Lins和其他人众所周知的“尝试删除”算法。在这里，我不会描述该算法的工作原理-您可以阅读该论文以获得很好的描述。</p><p> As usual, I couldn’t resist the temptation to improve the algorithm andadd more optimizations: The Nim compiler analyses the involved types andonly if it is potentially cyclic, code is produced that calls into thecycle collector. This type analysis can be helped out by annotating atype as  acyclic. For example, this is howa binary tree could be modeled:</p><p> 像往常一样，我忍不住要改进算法并增加更多优化的诱惑：Nim编译器会分析涉及的类型，并且只有当它可能是循环的时，才会生成调用循环收集器的代码。可以通过将类型注释为非循环来帮助进行类型分析。例如，这是如何建模二叉树的方法：</p><p>  Unfortunately, the overhead of the cycle collector can be measurable inpractice. This annotation can be crucial in order to get ORC’sperformance close to ARC’s.</p><p>  不幸的是，周期收集器的开销是可以测量的。此注释对于使ORC的性能接近ARC至关重要。</p><p> An innovation in ORC’s design is that cyclic root candidates can beregistered and unregistered in constant time O(1). The consequence isthat at runtime we exploit the fact that data in Nim is rarely cyclic.</p><p> ORC设计的创新之处在于，可以在固定时间O（1）内对循环根候选进行注册和注销。结果是，在运行时我们利用Nim中的数据很少是循环的这一事实。</p><p>  ARC is Nim’s pure reference-counting GC, however, many reference countoperations are optimized away: Thanks to move semantics, theconstruction of a data structure does not involve RC operations. Andthanks to “cursor inference”, another innovation of Nim’s ARCimplementation, common data structure traversals do not involve RCoperations either! The performance of both ARC and ORC is independent ofthe size of the heap.</p><p>  ARC是Nim的纯引用计数GC，但是，许多引用计数操作已被优化：由于移动语义，数据结构的构建不涉及RC操作。而且由于Nim ARC实现的另一项创新“游标推断”，常见的数据结构遍历也不涉及RC操作！ ARC和ORC的性能均与堆的大小无关。</p><p>  To put some weight behind my words, I wrote a simple benchmark showingoff these  algorithmic differences. Please note that the benchmark waswritten to stress the differences between ORC and Nim’s other GCs; it’snot supposed to model realistic workloads (yet!).</p><p>  为了给自己打个比方，我写了一个简单的基准来展示这些算法上的差异。请注意，基准测试是为了强调ORC与Nim其他GC之间的差异而编写的；它不应该为现实的工作负载建模（还！）。 </p><p> import  asynchttpserver ,  asyncdispatch ,  strutils ,  json ,  tables ,  streams # about 135 MB of live data: var  sessions :  Table [ string ,  JsonNode ] for  i  in  0  ..&lt;  10 :  sessions [ $ i ]  =  parseJson ( newFileStream ( &#34;1.json&#34; ,  fmRead ) ,  &#34;1.json&#34; ) var  served  =  0 var  server  =  newAsyncHttpServer ( ) proc  cb ( req :  Request )  { . async . }  =  inc  served  await  req . respond ( Http200 ,  &#34;Hello World&#34; )  if  served  mod  10  ==  0 :  when  not  defined ( memForSpeed ) :  GC_fullCollect ( ) waitFor  server . serve ( Port ( 8080 ) ,  cb )</p><p>导入asynchttpserver，asyncdispatch，strutils，json，表，流＃约135 MB的实时数据：var会话：i中0的表[string，JsonNode]。 10：会话[$ i] = parseJson（newFileStream（＆＃34; 1.json＆＃34;，fmRead），＆＃34; 1.json＆＃34;）var serve = 0 var server = newAsyncHttpServer（）proc cb（要求：要求）{。异步} = inc待命req。如果服务模块10 == 0，则响应（Http200，＆＃34; Hello World＆＃34;）：未定义（memForSpeed）时：GC_fullCollect（）waitFor服务器。服务（端口（8080），cb）</p><p> Lines 10-18 are the “Hello World” asynchronous HTTP server example fromNim’s standard library.</p><p> 第10-18行是Nim标准库中的“ Hello World”异步HTTP服务器示例。</p><p> In lines 4-6, we load about 135MB of JSON data into the global  sessions variable.ORC never touches this memory after it has been loaded, even though it remains alive for therest of the program run. The older Nim GCs do have to touch this memory.I compare ORC to Nim’s “mark and sweep” GC (M&amp;S) as M&amp;S performs best onthis benchmark.</p><p> 在第4-6行中，我们将约135MB的JSON数据加载到了全局session变量中.ORC永远不会触及该内存，即使它在程序其余的运行过程中仍然有效。较早的Nim GC确实需要触摸此内存。我将ORC与Nim的“标记并清除” GC（M＆amp; S）进行比较，因为M＆amp; S在此基准测试中表现最佳。</p><p> GC_fullCollect is called frequently in order to keep the memoryconsumption close to the 135MB of RAM that the program needs in theory.</p><p> 经常调用GC_fullCollect以使内存消耗接近程序理论上需要的135MB RAM。</p><p>   That’s right, ORC is  over 100 times faster than the M&amp;S GC. Thereason is that ORC only touches memory that the mutator touches, too.This is a key feature that allows reasoning about performance on modernmachines. A generational GC could probably offer comparable guarantees.In fact, ORC can be seen as a generational and incremental GC with theadditional guarantee that acyclic structures are freed as soon as theybecome garbage.</p><p>   没错，ORC比M＆amp; S GC快100倍以上。原因是ORC也只触及mutator触及的内存。这是一项关键功能，可以推理现代机器的性能。一个世代的GC可能会提供类似的保证。实际上，ORC可以看作是世代的和增量的GC，并附带保证无环结构一旦成为垃圾就被释放。</p><p>   M&amp;S now wins in throughput, but not in latency. However, the memoryconsumption rises to about 330MB; more than twice as much memory as theprogram really requires!</p><p>   现在，M＆amp; S在吞吐量方面胜出，但在延迟方面却没有。但是，内存消耗增加到了约330MB。是程序真正需要的两倍多的内存！</p><p> ORC always wins on latency and memory consumption; plays nice withdestructors, and hence with custom memory management; is independent ofthe heap sizes; tracks stack roots precisely and works cleanly with allsanitizers the C/C++ ecosystem offers.</p><p> ORC总是在延迟和内存消耗方面取胜；与析构函数配合很好，因此可以与自定义内存管理一起使用；与堆大小无关；精确地跟踪堆栈根，并与C / C ++生态系统提供的所有消毒剂一起干净地工作。 </p><p> These results are typical for what we see in other programs:Latency is reduced, there is little jitter and the memory consumptionremains close to the required minimum that a program needs.Excellent results for embedded development!</p><p>这些结果是我们在其他程序中看到的典型结果：延迟减少，抖动少且内存消耗保持接近程序所需的最低要求。嵌入式开发的出色结果！</p><p> Further advancements to the cycle collection algorithm itself are in development;it turns out there are lots of ideas that the GC research overlooked.Exciting times for Nim!</p><p> 循环收集算法本身的进一步改进正在开发中；事实证明，GC研究忽略了许多想法。</p><p>   ORC works out of the box with Valgrind and other C++ sanitizers.(Compile with  --gc:orc -g -d:useMalloc for precise Valgrindchecking.)</p><p>   ORC可与Valgrind和其他C ++消毒剂一起使用（使用--gc：orc -g -d：useMalloc编译以进行精确的Valgrindchecking）。</p><p>    ORC can be orders of magnitudes faster in throughput when memoryconsumption is important. It is comparable in throughput when memoryconsumption is not as important.</p><p>    当内存消耗很重要时，ORC的吞吐量可以快几个数量级。当内存消耗不那么重要时，它的吞吐量可比。</p><p>  ORC uses no CPU specific tricks; it works without hacks even onlimited targets like Webassembly.</p><p>  ORC不使用CPU特有的技巧。即使在有限的目标（如Webassembly）上，它也不会受到黑客攻击。</p><p>  ORC offers sub-millisecond latencies. It is well suited for (hard)realtime systems. There is no “stop the world” phase.</p><p>  ORC提供亚毫秒级的延迟。它非常适合（硬）实时系统。没有“停止世界”阶段。</p><p>  If you like this article and how we evolve Nim, please consider adonation. You can donate via:</p><p>  如果您喜欢本文以及我们如何发展Nim，请考虑捐赠。您可以通过以下方式捐款： </p><p>  If you are a company, we also offer commercial support. Please get intouch with us via   [email protected]. As a commercial backer, youcan decide what features and bugfixes should be prioritized.</p><p>如果您是一家公司，我们还提供商业支持。 请通过[电子邮件保护]与我们联系。 作为商业支持者，您可以决定应优先考虑哪些功能和错误修正。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nim/">#nim</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/orc/">#orc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>