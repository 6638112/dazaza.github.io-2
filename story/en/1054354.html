<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>比较Svelte并反应 Comparing Svelte and React</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Comparing Svelte and React<br/>比较Svelte并反应 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 19:43:11</div><div class="page_narrow text-break page_content"><p>Last year I created  Pomodone, a small time tracking application based on the Pomodoro technique of working in 25 minute intervals. It&#39;s a pretty basic app; it has a 25 minute timer (that runs in a Web Worker) and saves a history of your &#34;poms&#34; to a small Firebase database. I initially built it using React (well, Preact actually) but I then started to play around with Svelte, and decided rebuilding the app in Svelte might be a nice way to blog about the similarities and differences between the libraries.</p><p>去年我创建了Pomodone，这是一个小型时间跟踪应用，基于Pomodoro技术的工作时间为25分钟的间隔。它＆＃39; s一个非常基本的应用程序;它有一个25分钟的计时器（在Web工作者中运行）并保存您的＆＃34; Poms＆＃34的历史;到一个小的firebase数据库。我最初使用React（井实际上）建立它，但我开始使用Svelte播放，并决定在Svelte中重建应用程序可能是博客关于库之间的相似性和差异的好方法。</p><p> This is  not a post declaring Svelte to be better than React, or vice-versa. This is a post where I&#39;ll tell you about my preferences, and what I find easier or harder with either framework. I&#39;m not here to pick a fight! Plus, Pomodone is hardily a vastly complex application that could be used to fully put React or Svelte through its paces. Think of this post as a commentary based on my experience throwing a side project together, focusing on the developer experience putting these components together.</p><p> 这不是声明svelte的帖子比反应更好，或反之亦然。这是一个＆＃39; ll告诉你我的偏好的帖子，以及我发现更容易或框架更容易或更难。我不是在这里选择一场战斗！此外，POMODONE是难以置信的应用程序，可用于通过其鞋面完全放置反应或智能。将这篇文章作为评论，根据我的经验扔在一起，专注于将这些组件放在一起的开发人员体验。</p><p>  The app uses Firebase Authentication to log a user in via either their GitHub or Google account. I  love Firebase Authentication, it&#39;s such an easy way to add auth to side projects.</p><p>  该应用程序使用Firebase身份验证通过其GitHub或Google帐户登录用户。我喜欢Firebase身份验证，它＆＃39;这是一个简单的方法，可以将验证添加到侧面项目。</p><p> React&#39;s hooks are a great way to package this up; I create a  useCurrentUser hook which listens out to authentication changes and sets some state accordingly. I can then trust React to re-render as required when an authentication change is noted.</p><p> 反应＆＃39; s钩子是包装的好方法;我创建了一个USECURRENTUSER挂钩，侦听身份验证更改并相应地设置某些状态。然后，当注意到认证更改时，我可以信任重新渲染重新渲染。</p><p> export  const  useCurrentUser  =  ( )  =&gt;  {   const  [currentUser , setCurrentUser ]  =  useState ( undefined )    useEffect ( ( )  =&gt;  {   return firebase . auth ( ) . onAuthStateChanged ( ( details )  =&gt;  {   setCurrentUser (  details   ?  {  displayName : details .displayName ,  provider :  {   &#39;google.com&#39; :  &#39;Google&#39; ,   &#39;github.com&#39; :  &#39;GitHub&#39; ,   } [details .providerData [ 0 ] .providerId ] ,  uid : details .uid ,   }   :  null   )   } )   } ,  [ ] )   return  [currentUser ]  }</p><p> Export Const UseCurrentUser =（）=＆gt; {const [currentUser，setCurrentUser] = useState（未定义）使用effeffect（（）=＆gt; {return firebase。auth（）。OnauthstateChanged（（详细信息）=＆gt; {setCurrentUser（详细信息？{displayname：详细信息.displayname，提供者：{ ＆＃39; google.com＆＃39;：＆＃39; google＆＃39;，＆＃39; github.com＆＃39;：＆＃39; github＆＃39;，} [详细信息.providerdata [0] .providerid ]，UID：详细信息.UID，}：null）}）}，[]）返回[普照用户]}</p><p>   This is nice; it&#39;s low effort and lets any component quickly access the current user. The only downside of this is that you potentially have many  onAuthStateChanged listeners; I could mitigate this by only binding one listener, or by putting the current user in a  context instead.</p><p>   这很好;它＆＃39;低的努力，让任何组件快速访问当前用户。这唯一的缺点是您可能有许多OnauthstateChanged听众;我可以通过仅绑定一个侦听器，或者通过将当前用户放在上下文中来缓解这一点。</p><p> Talking of context, that&#39;s much closer to the approach I take with Svelte and use a  writable store.</p><p> 谈论上下文，＆＃39;较近我带有Svelte的方法，并使用可写商店。 </p><p> export  const currentUser  =  writable ( )   export  const  listenForAuthChanges  =  ( )  =&gt;  {   return firebase . auth ( ) . onAuthStateChanged ( ( details )  =&gt;  {   if  (details )  {  currentUser . set ( {  displayName : details .displayName ,  provider :  {   &#39;google.com&#39; :  &#39;Google&#39; ,   &#39;github.com&#39; :  &#39;GitHub&#39; ,   } [details .providerData [ 0 ] .providerId ] ,  uid : details .uid ,   } )   }  else  {  currentUser . set ( null )   }   } )  }</p><p>Export Const CurrentUser =可写（）导出const listenforauthchanges =（）=＆gt; {返回Firebase。 auth（）。 OnauthStateChanged（（详细信息）=＆gt; {if（详细信息）{uscuserer。设置（{displayname：详细信息.displayname，提供程序：{＆＃39; google.com＆＃39;：＆＃39;谷歌＆＃39;，＆＃ 39; github.com＆＃39;：＆＃39; github＆＃39;，} [详细信息.providerdata [0] .providerid]，uid：详细信息.uid，}）} else {lustuser。set（null）}}） }</p><p> Within the top level Svelte component, I can call this within  onMount, which will run once when the component is mounted (the function is  returned so we unsubscribe when the component is removed, much like how  useEffect lets you return a function).</p><p> 在顶层Svelte组件中，我可以在onmount内调用此，这将在挂载组件时运行一次（返回该函数，因此我们在删除组件时取消订阅，就像使用的是使用yeffect excume yours yours yours yourse yeffect）。</p><p>  Now anywhere in my Svelte codebase, a component can import the  currentUser writable store, and act accordingly. What I like is that  currentUser isn&#39;t a value, it&#39;s a store, and therefore you have full control over how you deal with it. You can either subscribe to it and manually control with state changes:</p><p>  现在在我的svelte代码库中的任何地方，一个组件可以导入普照用户可写存储，并相应行动。我喜欢的是普照用户ISN＆＃39; t a值，它＆＃39;它的一家商店，因此您可以完全控制您如何处理它。您可以订阅它并使用状态更改手动控制：</p><p>  Or, if you want to just read the latest value, you can prefix it with a  $:</p><p>  或者，如果您想要仔细阅读最新值，则可以使用$前缀为$：</p><p>  This is where some of Svelte&#39;s syntax trickery begins to shine; this dollar prefix trick automatically subscribes you to the store&#39;s latest value. I both like and dislike this; it&#39;s a nice syntax once you know it, but it&#39;s a bit odd as a beginner to get used to. However I like that Svelte doesn&#39;t make me use the  subscribe API every time I need to read the value.</p><p>  这是一些Svelte＆＃39; s语法技巧开始发光的地方;这款美元前缀技巧自动向您订购商店＆＃39;最新值。我都喜欢和不喜欢这个;它一旦你知道，它就是一个很好的语法，但它＆＃39;有点奇怪作为初学者习惯。但是，我喜欢那个svelte并在每次需要读取该值时让我使用订阅API。</p><p> As far as basic authentication goes, both libraries seem to take similar approaches here. Whilst the terminology and exact syntax differs slightly, both allow you to subscribe to a Firebase listener and get updated when the authentication state changes. React&#39;s contexts and Svelte&#39;s stores play almost identical roles for their library.</p><p> 就基本身份验证而言，这两个库似乎都在这里采取类似的方法。虽然术语和精确语法略有不同，但两者都允许您订阅Firebase侦听器并在验证状态更改时更新。反应＆＃39; s的上下文和svelte＆＃39; s商店对他们的图书馆发挥几乎相同的角色。</p><p>  Pomodone has to keep a 25 minute timer going and try to be as accurate as possible. If a browser tab is backgrounded (e.g., not the focused tab), most browsers will lower the priority of its  setTimeout calls and not run them strictly to time. Most of the time on the web this isn&#39;t a massive deal, but when a user is tracking 25 minutes of work via your app, it is! Plus, over the course of 25 minutes, any slight time drift will cause the final time to be quite far off. However, if these timeouts are moved into a web worker, they should run to time and not get de-prioritised by the browser.</p><p>  Pomodone必须保持25分钟的计时器，并尽量尽可能准确。如果背景（例如，不是聚焦选项卡），大多数浏览器将降低其SetTimeout调用的优先级，而不是严格运行时间。大部分时间在网上这个都是一个大量的交易，但是当用户通过你的应用程序跟踪25分钟的工作时，它是！此外，在25分钟的过程中，任何轻微的时间漂移​​都会导致最后一次更远。但是，如果这些超时被移动到Web工作者，则它们应该运行时间而不会被浏览器进行除见所要求。 </p><p> Therefore, in my  Tracker component, I need to instantiate a web worker, send it messages and receive data (such as time remaining) back. This is one area where I found React more &#34;admin heavy&#34; than Svelte; because React components are re-executed every time the component re-renders, you can easily end up with thousands of workers being created! It&#39;s essential to use  useRef to avoid this problem by maintaining a reference to the worker that you&#39;ve created.</p><p>因此，在我的跟踪器组件中，我需要实例化一个Web工作者，发送它消息并接收数据（例如剩余时间）。这是我发现的一个领域，其中＆＃34; admin重＃34;比velte;因为每次组件重新渲染时重新执行React组件，所以您可以轻松地结束成千上万的工人！它＆＃39;对于使用valef来避免对您创建的工人的参考来避免这个问题。</p><p>   And then create a  useEffect hook that will instantiate the worker, if required, and bind an event listener to listen for messages:</p><p>   然后创建一个使用效果钩子，如果需要，将实例化工作者，并绑定事件侦听器以侦听消息：</p><p> useEffect ( ( )  =&gt;  {   if  ( !worker .current )  {  worker .current  =  new   (workerURL )  window .worker  = worker .current   }    const  onMessage  =  ( event )  =&gt;  {   if  (event .data .name  ===  &#39;tick&#39; )  {   setCurrentPom ( ( currentPom )  =&gt;  ( {   ...currentPom ,  secondsRemaining : event .data .counter ,   } ) )   }  else  if  (event .data .name  ===  &#39;start&#39; )  {   // More branches removed here to save space...   }   }  worker .current . addEventListener ( &#39;message&#39; , onMessage )    return  ( )  =&gt;  {  worker .current . removeEventListener ( &#39;message&#39; , onMessage )   }  } ,  [currentUser ] )</p><p> 使用effeffect（（）=＆gt; {if（！worker .current）{worlter .current = new（warlerull）窗口.worker = worker .current} const onmessage =（事件）=＆gt; {if（事件.data .name = ==＆＃39;勾选＆＃39;）{setCurrentPom（（currentPom）=＆gt;（{... currentPom，秒数：事件.data .counter，}）}如果（事件.data .name === ＆＃39; start＆＃39;）{//在这里删除的更多分支以保存空间...}}}工作者.Current。addeventListener（＆＃39;消息＆＃39;，onmessage）return（）=＆gt; {工人。当前。RemoveeventListener（＆＃39;消息＆＃39;，onmessage）}，[普查队]）</p><p> And then, when the user hits the &#34;Start&#34; button, I have to send the worker a message:</p><p> 然后，当用户击中＆＃34;开始＆＃34;按钮，我必须发送工作者消息：</p><p>  Svelte looks pretty similar, but has two small changes that personally make the Svelte code easier to read, in my opinion:</p><p>  Svelte看起来很相似，但有两个小变化，个人使Svelte代码更容易阅读，在我看来：</p><p> We don&#39;t have to keep the worker in  useRef, and can just assign it to a variable.</p><p> 我们不必将工人保留在Useref中，可以将其分配给变量。</p><p> We can pull the event listener code out into a function more easily, as that function won&#39;t then become a dependency to a  useEffect - at which point we will have to wrap it in  useCallback.</p><p> 我们可以更轻松地将事件侦听器代码更容易地输出，因为该函数Won＆＃39; t然后成为一个使用effeffect的依赖 - 那么我们必须将其包装在USECALLBALL中。 </p><p>  let worker  onMount ( ( )  =&gt;  {  worker  =  new   (workerURL )  worker . addEventListener ( &#39;message&#39; , onWorkerMessage )   return  ( )  =&gt;  {  worker . removeEventListener ( &#39;message&#39; , onWorkerMessage )   }  } )</p><p>让工作者onmount（（）=＆gt; {worler = new（workerull）工作者。addeventlistener（＆＃39; message＆＃39;，onworkermessage）return（）=＆gt; {worlter。removeeventlistener（＆＃39;消息＆＃39; ，onworkermessage）}}）</p><p> We also don&#39;t have to set state by using React&#39;s  setX(oldX =&gt; newX) convention, and can just mutate the local variable:</p><p> 我们也不要使用React＆＃39; s setx（oldx =＆gt; newx）惯例来设置状态，并且可以只是突变局部变量：</p><p> function  onWorkerMessage ( event )  {   if  (event .data .name  ===  &#39;tick&#39; )  {  currentPom  =  {   ...currentPom ,  secondsRemaining : event .data .counter ,   }   }  else  if  (event .data .name  ===  &#39;start&#39; )  {   // More branches here removed to save space...   }  }</p><p> 函数onWorkermessage（事件）{if（事件.data .name ===＆＃39;勾选＆＃39;）{currentpom = {... currentpom，stickeRemaining：事件.data .counter，}} else（事件.data .name ===＆＃39; start＆＃39;）{//更多分支机构删除以保存空间...}}</p><p> Here&#39;s where I start to have a preference for Svelte; the two are very similar but once I got used to Svelte I found that React felt like jumping through hoops. You can&#39;t create a worker instance, it has to go in a  useRef, and then you can&#39;t easily pull code out into a function without then requiring  useCallback so it can be a safe dependency on  useEffect. With Svelte I write code that&#39;s closer to &#34;plain&#34; JavaScript, whereas in React more of my code is wrapped in a React primitive.</p><p> 这里＆＃39;我开始有妙语的偏好;这两者非常相似，但是一旦我习惯了Svelte，我发现那种反应感觉像跳过箍一样。您可以创建一个工人实例，它必须进入USERF，然后您可以＆＃39; t轻松地将代码拉出到一个函数中，而无需USECALLBALL，因此它可以是对使用效果的安全依赖性。使用svelte我写代码＆＃39;靠近＆＃34; plain＆＃34; JavaScript，而在反应原始中将更多的代码造成更多代码。</p><p>  One part of React that I&#39;ve always championed is how  it&#39;s just JavaScript. I like that in React you don&#39;t use a distinct template syntax and instead embed JavaScript, compared to Svelte&#39;s templating language:</p><p>  反应的一部分是我＆＃39; Ve始终冠军的反应是它的＆＃39; s只是javascript。我喜欢那个反应你不要使用不同的模板语法，而是与svelte＆＃39; s模板语言相比嵌入了javascript：</p><p>  {pomsForCurrentDay . map ( entryData , index )  =&gt;  {   const finishedAt  =  format ( new   (entryData .timeFinished ) ,  &#39;H:mm:ss&#39; )   return   {index  +  1 }    } ) }</p><p>  {PomsforCurrentday。地图（entrydata，index）=＆gt; {const iteftat =格式（new（entrydata .timefinished），＆＃39; h：mm：ss＆＃39;）返回{index + 1}}）}</p><p> &lt;ul  class = &#34;poms-list&#34; &gt;   {#each currentDayPoms  as value , index }   &lt;li  title = {  ` Finished at   ${ format (   new   (value .timeFinished ) ,   &#39;H:mm:ss&#39;   ) } ` }   &gt;   {index  +  1 }   &lt; /li &gt;   { /each }  &lt; /ul &gt;</p><p> ＆lt; ul class =＆＃34; poms-list＆＃34; ＆gt; {#ach CurrandayPoMS为值，索引}＆lt; li标题= {`以$ {格式完成（重大值。 {index + 1}＆lt; / Li＆gt; {/每个}＆lt; / ul＆gt; </p><p> I was pleasantly surprised by Svelte&#39;s templating; in the past I&#39;ve found templating languages overwhelming and inflexible, but Svelte offers just the right amount of templating whilst enabling you to use JavaScript too. That said, I will always find React&#39;s approach easier - at least in my head - and I think more friendly to people familiar with JavaScript who are learning a library.</p><p>我对Svelte＆＃39的模板感到惊喜;在过去的我＆＃39; ve发现模板语言压倒性和不灵活，但Svelte提供了适量的模板，同时也可以使用JavaScript。也就是说，我将永远发现反应＆＃39;至少在我的头上，我认为对熟悉正在学习图书馆的javascript的人更友好。</p><p> However, Svelte does have some nice touches to its syntax when it comes to rendering components (which feels very JSX-like). My favourite is the ability to collapse props:</p><p> 但是，在渲染组件（感觉非常JSX类似）时，Svelte确实有一些很好的触摸它的语法。我最喜欢的是折叠道具的能力：</p><p>      React requires us to use  useEffect and other hooks because it fully controls how all your code is run and re-runs your code whenever a component is re-rendered. Svelte is different in that by default most of your code is only going to run once; a  console.log(&#39;foo&#39;) line in a component will only run when that component is first rendered. In React, it will run many times.</p><p>      React要求我们使用IndeFeffect和其他钩子，因为它完全控制了所有代码如何运行并在重新呈现组件时重新运行代码。 Svelte是不同的，因为默认情况下，大多数代码只能运行一次; CONSOLE.LOG（＆＃39; foo＆＃39;）在组件中只在第一次呈现该组件时运行。在反应中，它将运行很多次。</p><p> React&#39;s re-rendering approach has its upsides: let&#39;s say you are taking in a big list of data and running some function to convert it into data that you can render. In React, within your component, you can write:</p><p> 反应＆＃39; S重新渲染方法有其上限：假设您正在进行大量数据列表，并运行一些功能以将其转换为您可以呈现的数据。在您的组件中反应，您可以写入：</p><p>  And this will always be up to date - should the user provide new  props.inputData, the component will re-render and the output will be updated.</p><p>  并且这将始终是最新的 - 如果用户提供新的Props.InputData，则组件将重新呈现，输出将更新。</p><p>   Here the output will be rendered the first time the component is rendered, but then not updated at all. We can solve this in two ways, either by using the  $: label syntax, which marks the code as reactive, or by moving our transform logic into the template:</p><p>   这里首次呈现组件的输出将呈现，但根本不会更新。我们可以通过使用$：标签语法以两种方式解决这一方式，它将代码标记为反应，或者通过将我们的转换逻辑移动到模板中：</p><p>    This is another example of Svelte taking JavaScript syntax and using it for a slightly different meaning; it tells Svelte that the statement is  reactive and should be recalculate should any imports change. You might also call it a &#34;computed property&#34;. The second solution simply moves the logic into the template, thus ensuring that when the component re-renders the logic is executed again. In my time with Svelte this is the approach I&#39;ve gone with most of the time, often pulling out the logic into a function:</p><p>    这是Svelte拍摄JavaScript语法的另一个例子，并使用它略有不同的含义;它告诉Svelte声明是反应性的，如果任何进口改变，应重新计算。您也可以称之为A＆＃34;计算的属性＆＃34;第二个解决方案只需将逻辑移动到模板中，从而确保当组件重新渲染逻辑时再次执行。在我的时间与svelte这是我大部分时间都走了的方法，经常将逻辑拉到一个函数： </p><p>  Coming from React to Svelte this did catch me out numerous times but for me I now prefer Svelte&#39;s approach, particularly because it removes some of the boilerplate around  useEffect.</p><p>来自智慧的反应，这确实很多次，但对我来说，我现在更喜欢Svelte＆＃39; S的方法，特别是因为它去除了围绕使用的一些样板。</p><p>  Component composition is a huge part of what makes working with a component based framework enjoyable or not and it&#39;s something that both React and Svelte solve well. React&#39;s  children prop makes it very easy to render any provided content:</p><p>  组件组成是使基于组件基于组件的框架且诸如反应和Svelte解决方案的东西的巨大部分。 React＆＃39; sendrain prop使其很容易渲染任何提供的内容：</p><p>  (If you&#39;ve not read it, the  React guide on Composition is well worth a read).</p><p>  （如果你没有阅读它，那么组合物的反应指南都值得一读）。</p><p>   They take different approaches when it comes to multiple children, and this is where I find myself preferring Svelte&#39;s approach more. React suggest passing through multiple props:</p><p>   当涉及多个孩子时，他们采取不同的方法，这就是我发现自己更喜欢智慧的地方。反应表明通过多个道具：</p><p> function  Box ( props )  {   return  (        {props .left }      {props .right }        )  }   function  App ( )  {   return    }</p><p> 功能框（道具）{return（{props .left} {props .right}）}函数app（）{return}</p><p> One gripe I&#39;ve had with this approach is that you lose the visual cues that you&#39;re passing children into the Box component; they now aren&#39;t nested within the Box when you render them like we&#39;re used to in HTML; it&#39;s now up to you to read the props and spot which ones are being used to provide children. It&#39;s easily done on this dummy example, but harder in &#34;real world&#34; applications - or at least, I find it harder!</p><p> 一个抱着我的方法是这种方法，你还失去了你的视觉线索和＃39;将孩子们传入盒子组件;当你像我们一样渲染它们时，他们现在仍然嵌套在盒子里。它现在由您读到用于提供儿童的道具和位置。它＆＃39轻松在这个虚设的例子上完成，但在＆＃34中更难;现实世界＆＃34;应用程序 - 或者至少，我发现它更难！</p><p> Svelte&#39;s approach is to define multiple slots with explicit names to let the user provide the elements that should fill those slots:</p><p> svelte＆＃39; s方法是定义具有显式名称的多个插槽，让用户提供应该填充这些插槽的元素： </p><p>  I like this approach more because I can scan the code that renders the  Box component and easily spot that it takes two children. If the  Box took any props, they&#39;d be within the opening  &lt;Box&gt; tag, and they would be distinct from any children props.</p><p>我喜欢这种方法更多，因为我可以扫描渲染框组件的代码，并且轻松发现它需要两个孩子。如果盒子接受了任何道具，它们在开口＆lt; box＆gt;标签，他们会与任何儿童道具不同。</p><p> My preference here is biased by the fact that I spend everyday at work building web components, so Svelte&#39;s approach feels very familiar to  slots in web components.</p><p> 我的偏好通过我每天在工作建筑Web组件上花费的事实偏见，所以Svelte＆＃39; S方法对Web组件中的插槽感觉非常熟悉。</p><p>  I enjoy that Svelte has an opinion about styling; especially in the context of small side projects like Pomodone, it&#39;s great to have that decision made for me. The fact that Svelte can also detect unused CSS is great, and this is one of the reasons why I suspect I&#39;ll reach more for Svelte in future projects.</p><p>  我喜欢Svelte对造型有意义;特别是在像丘陵等小的侧面项目的背景下，它很高兴为我做出这个决定。 Svelte还可以检测到未使用的CSS的事实是很大的，这是我怀疑i＆＃39的原因之一; LL在未来的项目中为Svelte达到更多。</p><p> This isn&#39;t really a downside to React; one of React&#39;s strengths is that it lets you control so much and slot React into your environment, but I like that Svelte comes with a good CSS story out the box.</p><p> 这不是一个缺点的反应; React＆＃39; S优势之一是它让您控制如此多，插槽在您的环境中反应，但我喜欢那个Svelte附带一个很好的CSS故事。</p><p>  One small feature I love about Svelte is how I can apply classes conditionally to an element:</p><p>  我喜欢svelte的一个小功能是我如何有条件地将类应用于元素：</p><p>  This will apply the class  is-active to the element, but only if the value  isActive is truthy. This reads well, is clear and is great that it comes out of the box.</p><p>  这将应用该类对元素有效，但仅当值是achiach是真实的。这读得很好，很清楚，很棒，它出来了盒子里。</p><p> I have used  classnames to achieve similar functionality in React, and it&#39;s a good solution, but I enjoy that Svelte provides this out the box.</p><p> 我使用ClassNames在反应中实现了类似的功能，而且它是一个很好的解决方案，但我喜欢Svelte提供了这个盒子。 </p><p>  Similarly to conditional classes, Svelte packs in some extra utilities for binding event listeners in the form of  modifiers. These let you modify event listeners to ask Svelte to include common functionality, such as calling  event.preventDefault(), for you.</p><p>与条件类类似，Svelte包在一些额外的实用程序中，用于以修饰程序的形式绑定事件侦听器。这些允许您修改事件侦听器以便询问Svelte以包含常用功能，例如调用event.preventdefault（）。</p><p>   &lt;script &gt;  function  click ( )  {   // No need to preventDefault ourselves   // logic here  }  &lt; /script &gt;   &lt;button on :click |preventDefault = {click } &gt;  Click me !  &lt; /button &gt;</p><p>   ＆lt; script＆gt;函数单击（）{//无需防止我们自己//逻辑}}＆lt; / script＆gt; ＆lt;按钮：单击| preventdefault = {click}＆gt;点击我！ ＆lt; /按钮＆gt;</p><p>  I like both React and Svelte. Put me in a codebase with either of them and I&#39;ll enjoy it, be productive and happy putting new features together or fixing bugs. I have side projects in React, and others in Svelte, and I&#39;m in no rush to convert any from one to the other. React and Svelte are very similar in many ways, but what I&#39;ve found is that in all the little ways that they are different, I prefer Svelte. The codebase for Pomodone makes more sense to me in Svelte, not React. I find it easier to navigate and work with.</p><p>  我喜欢反应和svelte。让我在一个码比中与其中任何一个，我享受它，享受它，富有成效，快乐地将新功能放在一起或修复错误。我的反应和其他人在Svelte中有一方的项目，我＆＃39; m毫不急于将任何一个转换为另一个。反应和Svelte在许多方面非常相似，但是我发现的是，在它们不同的一切方面，我更喜欢Svelte。 POMODONE的CODEBASE对SVelte中的ME更为有意义，而不是反应。我发现它更容易导航和工作。</p><p> If I were to sum up why in one sentence, it&#39;s because  I don&#39;t miss  useEffect. I understand why it exists, I understand the approach React takes, and there are benefits of its approach. But writing complex React components feels more like admin; a constant worry that I&#39;ll miss a dependency in my  useEffect call and end up crashing my browser session. With Svelte I don&#39;t have that lingering feeling, and that&#39;s what I&#39;ve come to enjoy. Svelte is there when I need it with useful APIs, but fades into the background as I put my app together.</p><p> 如果我总结为什么在一句话中，它＆＃39; s是因为我没有错过使用的使用。我理解为什么它存在，我理解这种方法会采取的，并且有利于其方法。但是写复杂的反应组件感觉更像是管理员;一个不断担心我＆＃39; ll错过了我的使用次数呼叫中的依赖，最终崩溃了我的浏览器会话。用svelte我没有＆＃39; t有那种挥之不去的感觉，那个＆＃39;那是我的＆＃39; vere来享受。当我用有用的API需要时，svelte是在那里，但是当我把我的应用程序放在一起时，逐渐消失。</p><p> If you enjoyed this post, join the newsletter to get updates on new content 😎.</p><p> 如果您喜欢此帖子，请加入时事通讯以获取新内容的更新😎。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.jackfranklin.co.uk/blog/comparing-svelte-and-react-javascript/">https://www.jackfranklin.co.uk/blog/comparing-svelte-and-react-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/svelte/">#svelte</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>