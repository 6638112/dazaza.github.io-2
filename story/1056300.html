<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java早期草案：不变对象的功能转换 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Java早期草案：不变对象的功能转换 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-05 23:59:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/cdb16523b7498dc023625f7bbc10e891.png"><img src="http://img2.diglog.com/img/2021/4/cdb16523b7498dc023625f7bbc10e891.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>本文档是一个早期阶段草案，概述了在Java语言中支持功能转换的可能方向。这是一个探索文件，而不是构成任何特定版本的Java语言的任何特定功能的计划。本文件还可以参考探索下的其他特征;这纯粹是为了说明目的，并且不构成提供任何这些功能的计划或承诺。</p><p> 每个人都喜欢记录。但是，添加了记录和解构等功能，可以解决一些旧问题，提高了新闻。而且，我们可以提供的一切，但没有课程的一切都会增加一个差距，用户可能会觉得他们努力选择;它的时候开始绘制概括记录的路径和＃39;好吃的东西＆＃34;这样合适的课程可以加入乐趣。</p><p> 本文件主要侧重于一个特定的好代教，我们喜欢终止记录，然后尽快延伸到类：functionaltransformation。有其他潜在的新好东西（例如，基于关键字，基于关键字的建筑和解构）和新的善世的民主化opportonities（例如，任意课程的受访者）可以稍后。</p><p> 更一般地说，在过去的10-15年里，Java开发人员已经开始达到不可抗性的价值，以创造安全，可靠的代码，这意味着它的理由，而且语言开始反映这种升值 - 但每次转弯，而是每次转弯和运行时仍然让我们为使用immutable对象征税。功能转换允许不可阻力的物体到无可用的可用性税（以及内联课程，也是较少的绩效税。）</p><p>  记录和内联课是两种新形式的浅不变的课程戒律。这使得它更加明显，＆＃34;突变＆＃34; （应用功能转发到）一个不可变的物体目前过于痛苦。 （显然records不能突变 - 但是下一个最好的事情是创建一个新的录音，从现有记录中有一个已知的三角洲。）如果我们的点记录想要欺骗＆＃34; set＆＃34; x和y组件，它必须写入withx和携带方法：</p><p> 记录点（int x，int y）{点用x（int newx）{返回新点（newx，y）; }点富有（int newy）{返回新点（x，newy）; }}</p><p> 这是可行的，并且具有与我们的语言合作的优势，但有两个明显的缺点。开发人员对通常的国家相关的样品板块令人难以令人兴奋，这将形成一个新的Theperplate，没有自动化的水位板（前进的两个步骤，一个退台），并且当记录有许多状态组件时，写作这些＆＃34 ;枯萎＆＃34;变得更加繁琐和容易出错。对于记录，至少，语言已有信息来自动化，所以尤其是令人羞耻的开发人员用手做。 </p><p>事实上，＆＃34;枯萎＆＃34;会比Getters和Setter更糟糕，因为虽然ACLASS可能有O（n）吸气器，但它可以想到的是o（2 ^ n）枯萎.worse，随着组件的数量增长，这些＆＃34的尸体;枯萎病＃34;存取驻宿程序更容易出错。让＆＃39; s在芽之前将此扼杀一个＆＃34;模式＆＃34; （或更糟糕的是，A＆＃34;最佳实践＆＃34;）</p><p> 这个问题不是记录或内联类的唯一;现有的基于价值（例如LocalDateTeme）必须揭示富于方法。但是如果语言会鼓励我们编写不可变类，它也会帮助我们解决这个问题。</p><p>  我们在C＃世界中的朋友已经在这个问题上拍摄了两个摇摆.TheIR第一个解决方案构建了它们已经允许参数允许参数默认值，后来添加了默认值的能力来引用它。这意味着您可以编写一个调用的普通库方法：</p><p> 课程点{int x; int y;点（int x = this.x，int y = this.y）{返回新点（x，y）; }}</p><p> 这是一个改进，它允许您编写一个方法来处理2 ^ n可能的组合，作为纯API考虑，并且客户端只能只能识别他们想要更改的参数：</p><p>  但是，显然是C＃开发人员的不够＆＃39;最近（C＃9），他们还介绍了一个表达式的语言：</p><p>  右侧的块极为有限;它是一组唯一的职业分配器。 （C＃也最近引入了＆＃34; init-only＆＃34;属性（有效地，命名的构造函数参数），因此上面导致新的点不存在，其中在块中写入的属性分配覆盖左操作数的属性分配。） </p><p>C＃方法对它们是明智的，因为它们可以在它们上构建它们（默认参数，属性），但只是复制该方法会用很多行李拖累。但我们已经拥有了，在Java中，我们需要（几乎）以不同的方式，可能更加丰富：构造函数和解构器。</p><p> 重建表达式采用其静态类型为T和A块的操作数，其中块对操作数的状态表达了功能转换，并产生了T类型的新实例：</p><p>  在这里，PP将有任何Y值p，x = 3。该块可以为Java语句（分配，循环，方法调用等）的任意序列进行一些限制。理想情况下，我们可以定义若丙族类的重建，而不仅仅是记录，而是我们＆＃39; ll从记录开始。招商局具有规范构造函数和解构模式。含义可以将上面的表达方式解释为：</p><p> 声明一个新的块，新的可变当地人，其名称和类型的记录组件呈计;</p><p> 用规范解构器解构目标，并将结果分配给上面描述的变量;</p><p> 在该范围内执行块，可以将这些LOCALSIF突变使用正确的名称;</p><p>    {//新的范围点（var x，var y）= p; //用规范CTOR解析LHS {x = 3; } //执行该范围的RHS产生新点（x，y）; //重建新值} </p><p>我们可以在表达式上思考RHS上的块作为记录状态的功能动态形态。因此，它可以合理地对其施加限制。出于稍后将清楚的原因，我们将写入写入除了对应于外提示组件的当地人之外的任何变量，以及块内声明的当地人。该块是FreeTo使用语言（如循环和条件）的任何功能，而不是justAsigmer  - 它不是A＆＃34; DSL＆＃34;它＆＃39; SA块的Java代码，它表达了状态的Atransformation记录。</p><p> 客户端可以与表达式一起使用，但类也可能还希望使用它们的Intheir实现。例如：</p><p> 记录复杂（双重真实，双IM）{复合共轭（）{用{Im = -im返回它; }}}复杂realonly（）{用{im = 0返回它;复杂的imonly（）{用{re = 0返回它; }}}</p><p> 客户当然可以执行这些相同的操作，但作者可以在这个域中进行操作令人遗憾的是，它使其感到意识到是一种方法。</p><p> 请注意，如果规范构造函数检查不变量，那么一个带表达也会检查它们。例如：</p><p> 记录Rational（int num，int denom）{Rational {if（enom == 0）投掷新的IllegalArgumentException（＆＃34;否定不能为零＆＃34;）; }}</p><p>   我们将获得同样的例外，因为这将是将数字解压缩分母解压缩到可变的当地人，使分母变为零，然后将它们返回到规范构造函数 - 谁将抛出。 </p><p>我们很少的我们必须要开始支持表达式记录;所有构建块都已到位。但在我们去那里之前，韦弗坦要确保我们有一个路径将其扩展到任何想要在本协议中的追容性的类。</p><p> 什么使得与记录一起使用的事情是我们有一个规范构造函数anddeconstruction模式，他被称为稳定的签名，名称，以及彼此匹配。我们可以将其解释为外部陈述，我们知道如何映射到内部状态描述（在记录的情况下与外部描述相同，可能包含一些验证。）普通类不会有所有这些，因为它们可能存在不同的表示，但是可以添加足够的足够数据，以导出这些行为。</p><p> 功能转换取决于解构，因此我们需要一种方法向任意类进行DeconStructor，这是在计划上。出于本文件的目的，我们将表示解构模式，如：</p><p>  但是，我们＆＃39;还没有那里。一个类可能有多个构造函数anddeconstructors;我们必须选择一个匹配的对，然后提取所有相关的待命序列，然后愿意将修改状态重新包到一个新对象中。 WENED一种选择正确的构造函数和解构器的方法。</p><p> 显然，选择过载的传统方式赢得了＆＃39;在这里工作，但是我们可以通过参数名称来实现另一种方式。假设参数名称是重要的（尽管我们知道他们不是。）我们可以解释</p><p>  作为过载选择问题：＆＃34;找到一个（最大）upling函数，它需要x。然后，将参数列表中的所有名称和类型用于该编曲器，并找到我的一个（最小）解构器，提取它们所有。＆＃34;但是我们甚至找到初始集{x}？这是我们限制（无论如何是合理的）进来的地方;我们可以查看块中的分配标准，这些块不会分配给块中声明的当地人，它们必须分配给＆＃34;属性＆＃34;被重建的对象。</p><p>  在此功能需要进行构造函数和解构器的参数和绑定名称（以及事实证明，此类其他可爱的功能也是如此。）我们肯定可以＆＃39; t只是说＆＃34;从今天开始，他们重要的＆＃34;但我们可以让人们选择一个重点到重要名字。在本文档中的博览会上，我们＆＃39;在构造函数或解构器上LLUSUS Modifier __byName，以指示该名称很大。 </p><p>自从我们在客户站点上使用这些名称进行预测以来，我们还需要Todefine如何重载__byname构造函数和解压缩器，以及如何进行过载选择。作为一个草兵，我们＆＃39; ll拍摄最简单的东西，只能工作：只有一个__byname构造函数或解构器。后来我们＆＃39;据揭示这一点。如果只有一个__byname构造函数anddeconstructor，则清楚地给出：</p><p>   用__byname解构器解构目标，在类中找到的__byname解构器是目标的静态类型;</p><p>  在此上下文中执行RHS块，其中限制它可以只执行其名称在构造函数中显示的变量;</p><p> 以这种方式，任何类都有一个__byname构造函数和解压缩函数在重建协议中的canparticipate。</p><p>  ＆＃34;只有一个构造函数和deconstructor＆＃34;规则过于限制，索勒特＆＃39; s延伸到更有用。关于根据其参数类型和位置的超载和选择成员的现有规则不需要更改，但我们需要新的规则来重载__byname成员（彼此的BothageSt，以及针对位置声明）。</p><p> 每个__byname构造函数/解压缩程序可以在位置调用，因此它遵循现有规则以进行重载和过载选择。一组__byname成员有效，如果才有才能且仅当每个这样的成员时，它们的名称集要么脱节，也只有一个是另一个是另一个是一个适当的子集，并且对应于公共名称的类型是相应的。这确实是将__byname成员组织成不相交的伸缩链。</p><p>   示例，这意味着我们选择具有X的最大（链条）构造函数的最大（顶部成员），然后找到最小的Deconstructor在该选定的构造函数中包含所有名称。这再现了最大保真度和最小提取成本的对象。 </p><p>重载规则起初可能会限制，但它们并不像糟糕的isthey似乎。许多当前的构造函数过载 - 特别是对于功能转换的压缩 - 是＆＃34;伸缩＆＃34;品种，其中超载形成X-is-shorthan-for-y的线性链，并且存在更简单的仅作为位置便利，提供默认值（新的Hashmap（）代表到新的HashMap（initCapacity），该代表委托给新的HashMap（initCapacity，LoadFactor）。）</p><p> 部分选择了该方案，因为某些类可以具有与其外部API的全面内部表示，而是希望使用外部API来支持客户端的功能和实现的InternalEupration。通过具有用于内部表示的内部表示的私有构造函数/解压缩程序对，ANDA在外部API方面用于客户端使用的公共对，两个客户端和Adimlementation都可以利用对它们的感觉术语来利用功能转换。并且在公共和普遍的对之间存在重叠的范围，私有对中的名称可以始终是alpha-命名的。</p><p>  __byname修饰符是诸如许多其他有用程序的底层的一部分，例如基于关键字的调用（新的foo（x：3）），带有或没有参数，基于关键字的解构和普通类的自动生成readcare，如普通类（您可以将一个解构器作为淘压者，并从中获取吸气器。）我们＆＃39;请谈论这些时间。</p><p>  功能转换取决于具有__byname构造函数，但是许多发光者更喜欢公开工厂而不是构造函数。我们可以指定__byname工厂来取代这个角色吗？</p><p> 第一个问题是出厂方法是API设计模式，而不是泛al功能。我们可以用一些简单的糖来解决这个问题;我们caninerpret：</p><p>    这是一项琐碎的转型，作为奖金，使我们能够在＆＃34中包含契约方法;构造函数＆＃34; javadoc的部分。然后我们可以允许__byname工厂，并扩展过载规则，以将所有__byname构造函数和工厂视为组。为了支持FunctionalTransformation，我们可以扩展规则以允许选择__bynameConstructor或工厂。</p><p> 奖励圆：接口？我们已经允许界面中的静态工厂，并且没有理由＆＃39;否则接口不能具有解构器的原因（如果接口界面提供了允许提取状态组件的API）。如果我们还允许Deconstructors在接口中，我们甚至可以Dowith＆＃39;在接口上也是： </p><p>接口尖尖{public __byname factory（int x，int y）{return new pointimpl（x，y）; public __byname __deconstructor尖头（int x，int y）{__match（x（），y（））; public int x（）; public int y（）;}  Pointy P = Pointy.of（1,2）;尖头翻转= p，{x = -x; y = -y; }; </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/openjdk/amber-docs/blob/master/eg-drafts/reconstruction-records-and-classes.md">https://github.com/openjdk/amber-docs/blob/master/eg-drafts/reconstruction-records-and-classes.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/早期/">#早期</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/early/">#early</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/记录/">#记录</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1056275.html"><img src="http://img2.diglog.com/img/2021/4/thumb_17ce458b1340dade7bf8e9655aa057e1.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056275.html">最高法院规则6-2在谷歌对版权纠纷的青睐与java Apis的奥秘，推翻了Oracle的胜利 </a></div><span class="my_story_list_date">2021-4-5 22:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1055565.html"><img src="http://img2.diglog.com/img/2021/4/thumb_7b48e7f8ee9c72f9557b7af584101d1b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1055565.html">自JDK 8到16以来，所有Java和JVM功能的分类列表 </a></div><span class="my_story_list_date">2021-4-2 0:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1055047.html"><img src="http://img2.diglog.com/img/2021/3/thumb_f9bad19606aa5f93645c72b30d099dee.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1055047.html">MK.JS：在JavaScript中实现的凡人kombat原型 </a></div><span class="my_story_list_date">2021-3-30 0:23</span></div><div class="col-sm"><div><a target="_blank" href="/story/1054849.html"><img src="http://img2.diglog.com/img/2021/3/thumb_0d5c10b751f178e7a8a271af641af512.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054849.html">Jenetics：Java的遗传/进化算法库 </a></div><span class="my_story_list_date">2021-3-28 14:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>