<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Roblox八年Eight Years at Roblox</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Eight Years at Roblox<br/>Roblox八年</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 12:24:17</div><div class="page_narrow text-break page_content"><p>I joined Roblox at the end of 2012 as a rendering engineer; I had just spent more than a year working on various titles from FIFA franchise after years of console game development and was becoming a bit tired of the “big game development”. My work on FIFA was as a contractor and I got an offer for a full-time position, but I also had a friend who worked at Roblox reach out and offer me to move to California and work on Roblox. I knew absolutely nothing about Roblox, but California was nice and my friend told me it would be awesome. The platform was so different (and so strange!) that I decided to take a chance - here I am, 8 years later, still working at Roblox and enjoying it. I started on my first full time job in April 2007 so at this point I’ve worked for 13 years in game development and 8 of them were at Roblox.</p><p>我于2012年底加入Roblox，担任渲染工程师。经过多年的主机游戏开发，我刚刚花了一年多的时间来研究FIFA系列的各种游戏，对“大型游戏开发”感到有些厌倦。我在FIFA上的工作是作为承包商的，我得到了一份全职职位的报价，但是我还有一个在Roblox工作的朋友伸出援手，并提议我搬到加利福尼亚并在Roblox上工作。我对Roblox完全一无所知，但是加利福尼亚很好，我的朋友告诉我那太棒了。这个平台是如此的不同（太奇怪了！），我决定抓住一个机会-8年后的今天，我仍然在Roblox工作并享受它。我于2007年4月开始了我的第一份全职工作，因此我在游戏开发领域已经工作了13年，其中有8年在Roblox。</p><p> My memory works in interesting ways. I remember my interview pretty well, I remember having lunch at some place in San Mateo downtown near the Roblox HQ - a few people were at lunch including Roblox CEO David Baszucki and I remember him asking many questions about my thoughts about the engines and rendering, and distinctly remember not finishing most of my lunch because I talked most of the time. However I don’t really remember what was going through my head in regards to my perception of Roblox - why did I join besides just thinking I want to do something else for a change? Who knows, but I am glad I did.</p><p>我的记忆以有趣的方式工作。我记得我的采访很好，我记得在Roblox总部附近的San Mateo市区的某个地方吃过午餐-包括Roblox首席执行官David Baszucki在内的一些人共进午餐，我记得他问了很多关于我对引擎和渲染的想法的问题，并且清楚地记得我大部分时间没有吃完午餐，因为我大部分时间都在讲话。但是，我真的不记得我对Roblox的看法正在经历什么？除了为什么我想做一些其他改变之外，我为什么还加入？谁知道，但我很高兴自己做到了。</p><p> I don’t really understand why Roblox is so successful - you can invent all sorts of reasons in retrospect but it’s hard to validate them, and if you came to anybody back in 2012 and asked for an investment to build a platform where all games are user generated and run on a custom engine with a custom toolset and all users participate in a giant virtual economy and …, I think you’d have gotten a blank stare.</p><p>我真的不明白为什么Roblox如此成功-您可以回顾一下各种原因，但是很难验证它们，如果您在2012年遇到任何人并要求投资以构建一个平台，让所有游戏用户生成并在具有自定义工具集的自定义引擎上运行，并且所有用户都参与了巨大的虚拟经济，而且…，我想您会茫然无措。</p><p> But I do understand that I found the perfect place for me, especially at that point in my career - I enjoy working on game technology but I never liked working on actual games, and Roblox maximizes the number of developers who can use the technology you work on while maintaining a good autonomy and a very wide range of problems you’d need to solve. It’s very hard to get bored here.</p><p>但是我确实知道我为自己找到了理想的地方，尤其是在我职业生涯的那一点上-我喜欢从事游戏技术的工作，但我从不喜欢从事实际游戏的工作，并且Roblox最大限度地增加了可以使用您所运用的技术的开发人员同时保持良好的自主权和您需要解决的广泛问题。这里很难无聊。</p><p> I think I could talk for hours about Roblox - it somehow became a huge part of my life. I was very fortunate to join at the time when I did and witness the growth of our technology and business. I am really unsure of what the future holds but it’s hard to imagine what, if anything, comes after Roblox - I certainly don’t intend to leave any time soon…</p><p>我想我可以谈论Roblox几个小时-它在某种程度上成为了我一生的重要组成部分。我很幸运能在那时加入，并见证了我们技术和业务的增长。我真的不确定未来会怎样，但很难想象Roblox之后会发生什么，如果有的话-我当然不打算很快离开。</p><p> So I thought it might be fun to do what I’ve planned to do for a year or more now, and to go over all decently sized projects I’ve ever worked on at Roblox. This is based on resummarizing and reliving the source control history, which tells me I’ve had 2752 changes that made it to our main branch, with merge commits counting as one, so, uh, this blog might be on a larger side. Hopefully this will be fun!</p><p>因此，我认为现在进行一年或一年以上计划的工作，并处理我在Roblox从事过的所有大型项目，可能会很有趣。这是基于对源代码控制历史的总结和回顾，它告诉我我对主分支进行了2752项更改，合并提交为一，所以，这个博客可能面目全非。希望这会很有趣！</p><p> Before we begin, I just want to conclude this by saying that I’m very grateful to the Roblox leadership for treating me well, for all the friends and colleagues I made along the way, and for the wonderful Roblox community. The reason why I still enjoy what I do is because whenever I write about a new big thing I’m working on or a small feature or even a bug fix, it’s usually met with excitement which keeps me going. Thank you all from the bottom of my heart. I don’t think I could have done it without you and I hope this continues for as long as possible despite the current trying and uncertain times.</p><p>在开始之前，我只想总结一下，我非常感谢Roblox领导层对我的良好对待，我一路交往的所有朋友和同事以及美好的Roblox社区。我之所以仍然喜欢我的工作，是因为每当我写我正在处理的新事物，小功能甚至是错误修复时，通常都会感到兴奋，这使我不断前进。衷心感谢大家。我想如果没有您的帮助我就做不到，尽管目前困难重重，但我希望这种情况能持续尽可能长的时间。</p><p>  Notably including half-pixel offset fixes for Direct3D9 which I guess is a rite of passage for rendering engineers. The rendering code back then was based on OGRE rendering engine, so I had to learn that, and this was also my first time using OpenGL professionally - prior to that I’ve used Direct3D 9 and proprietary console APIs, and Direct3D 10/11 as a hobby.</p><p>值得注意的是，它包括Direct3D9的半像素偏移修复程序，我认为这对渲染工程师来说是很容易的事情。当时的渲染代码基于OGRE渲染引擎，所以我必须学习这一点，这也是我第一次专业使用OpenGL-在此之前，我已经使用Direct3D 9和专有控制台API，以及Direct3D 10/11作为一个爱好。</p><p>  Initially added for “100 player” project, in October it evolved to render all parts and continued to be used as part renderer until the introduction of instancing in 2018. Otherwise known as “featherweight parts”. This was further optimized and deployed around November 2012. Most of this code survived to this day but evolved over time, and is still used when instancing doesn’t apply.</p><p>最初是为“ 100播放器”项目添加的，10月份演变为渲染所有零件，并一直用作零件渲染器，直到2018年引入实例化。否则称为“轻量级零件”。该代码在2012年11月前后得到了进一步的优化和部署。大多数代码都可以保留到今天，但是随着时间的推移而不断发展，当不适用实例化时仍然可以使用。</p><p> The core idea in this system was to dynamically batch meshes together, for characters this would be based on the character model hierarchy, and for everything else the grouping is spatial. This allowed us to reduce the number of draw calls, which was a big concern due to both driver overhead and inefficiencies in OGRE.</p><p>该系统的核心思想是将网格动态地批处理在一起，对于字符而言，这将基于字符模型层次结构，而对于其他所有方面，分组都是空间的。由于驱动程序开销和OGRE效率低下，这使我们减少了绘图调用的数量，这是一个很大的问题。</p><p> This would pave the way for what eventually turned out to be a complete, but gradual, rewrite of the rendering stack. The main motivation for this was always performance - what we ended up let us port to mobile (the old rendering code was nowhere near fast enough even for relatively simple scenes), and break new grounds on the number of objects we could render in a frame.</p><p>这将为最终成为渲染堆栈的完整但逐步的重写铺平道路。其主要动机始终是性能-最终我们让我们移植到了移动设备上（即使对于相对简单的场景，旧的渲染代码也远远不够快），并在可在帧中渲染的对象数量上取得了新的突破。 。</p><p>  One of a few OGRE upgrades we’ve needed to do, this one was to get better GLES support. It was pretty painful to do those, just like any other big middleware update is. Read further to learn what happened to OGRE eventually…</p><p>我们需要做的几项OGRE升级之一是获得更好的GLES支持。就像其他大型中间件更新一样，执行这些操作非常痛苦。进一步阅读以了解OGRE最终发生了什么……</p><p> One thing I remember from doing these is that documentation in source code makes the upgrade process that much more painful. I had scripts that changed the copyright years in headers back to whatever they were in our tree just to make merging less painful, but there was some OGRE upgrade where 70% of the changes were documentation, and this was very hard to get through.</p><p>我记得做过的一件事是，源代码中的文档使升级过程变得更加痛苦。我有一些脚本将标头中的版权年更改为我们树中的内容，以减轻合并的痛苦，但是OGRE进行了一些升级，其中70％的更改是文档，这很难实现。</p><p> The reason why these were challenging in general is that whenever we did an upgrade we had to a) merge our plentiful changes with the new code, b) gate dangerous parts of the upgrade with flags. We’ve used the same system of feature flags (we call them fast flags) since I joined Roblox which allows us to dynamically disable parts of the release based on metrics, but this requires actually isolating changes behind if statements selectively - which for OGRE was sometimes necessary as we didn’t know what the impact of some low level change in OpenGL code would be.</p><p>这些通常具有挑战性的原因是，每当我们进行升级时，我们都必须a）将大量更改与新代码合并，b）用标志标记升级的危险部分。自从我加入Roblox以来，我们就使用了相同的功能标志系统（我们称它们为快速标志），它允许我们根据指标动态禁用发行版的各个部分，但这实际上需要有选择地隔离if语句后面的更改-对于OGRE，有时是必需的，因为我们不知道OpenGL代码中的一些低级更改会带来什么影响。</p><p>  Before this we had hand-translated shaders, which started to be painful to maintain. The first version of the pipeline used hlsl2glsl and glsl-optimizer (same as Unity back in the day). We are using version 3 today, see below!</p><p>在此之前，我们需要手工翻译的着色器，维护起来很麻烦。管道的第一个版本使用hlsl2glsl和glsl-optimizer（与当天的Unity相同）。我们今天使用的是版本3，请参见下文！</p><p> Since this was done at the point where we used OGRE, the compiler would take HLSL files, preprocess and translate them to optimized GLSL, and save the resulting GLSL back to disk - which would then be loaded by OGRE directly through the material definition file. Eventually we replaced this with a binary shader pack that could store GLSL code for OpenGL and shader bytecode for other APIs, but back then we shipped HLSL and GLSL source and compiled HLSL code on device!</p><p>由于此操作是在使用OGRE的那一刻完成的，因此编译器将获取HLSL文件，对其进行预处理并将其转换为优化的GLSL，然后将生成的GLSL保存回磁盘-然后OGRE将通过材料定义文件直接将其加载。最终，我们用一个二进制着色器包替换了它，它可以存储OpenGL的GLSL代码和其他API的着色器字节码，但是那时候我们才发行了HLSL和GLSL源代码并在设备上编译了HLSL代码！</p><p>  Our equivalent of “Steam Hardware Survey” that went through SQL databases and coalesced various system information bits to help us understand the hardware at the time. This was during my era of obsession with F#, so it was written in F# instead of something like Python. We don’t use this anymore and don’t even have the SQL database in question!</p><p>我们相当于通过SQL数据库进行“蒸汽硬件调查”，并合并了各种系统信息位，以帮助我们当时了解硬件。这是在我迷恋F＃的时代，所以它是用F＃编写的，而不是像Python这样的东西。我们不再使用它，甚至没有问题的SQL数据库！</p><p> We never published the resulting data, and I’m not sure how often we used it to make decisions, but it was fun to look at the number of graphics cards from various vendors or amount of RAM or resolution a typical Roblox user has.</p><p>我们从未发布过最终的数据，我不确定我们使用它进行决策的频率，但是查看来自不同供应商的图形卡的数量或典型Roblox用户拥有的RAM或分辨率的数量很有趣。</p><p>  Although I was hired as a rendering engineer, I had a lot of really deep low-level systems experience and as a consequence ended up engaging in both optimization work and security related work from the very beginning. I don’t do this anymore these days but I was often involved in the security work for the first 3 or 4 years. Now we fortunately have people who can do this full time and better than I could :)</p><p>尽管我被聘为渲染工程师，但我在底层系统方面拥有非常丰富的经验，因此从一开始就从事优化工作和安全相关工作。这些天我不再这样做了，但在最初的3或4年中，我经常参与安全工作。现在我们幸运的是，有一些人可以全职做，并且比我做的更好:)</p><p>  A second part of “100 player project”, necessary to render every character in one draw call (these were really expensive for us back in the day!). A side effect included some resolution sacrifices on character items that shirt creators aren’t fond of. The new system managed the atlas texture memory, rebaking humanoids far away to smaller textures to conserve texture memory. The compositor survived with minor changes to this day, although we’re now working on a new one.</p><p>“ 100个玩家项目”的第二部分，必须在一次抽奖中呈现每个角色（对于我们来说，这真是太昂贵了！）。副作用包括在衬衫创作者不喜欢的角色物品上牺牲了一些分辨率。新系统管理了Atlas纹理记忆，将类人动物重新烘烤到较小的纹理以节省纹理记忆。尽管我们现在正在开发一个新的合成器，但直到今天，该合成器仍然进行了微小的更改。</p><p> The compositor was built in a very configurable fashion, allowing the high level code to specify the layout to bake, and managing all the complex asynchronous processing and budgeting by itself. This allowed us to switch the composit layout completely years later for R15.</p><p>该合成器以非常可配置的方式构建，允许高级代码指定要烘焙的布局，并自行管理所有复杂的异步处理和预算。这使我们可以在数年后为R15完全切换合成布局。</p><p>  At the end of 2012 we were actively working on the mobile port. Since then we’ve had to do a lot of work in a lot of different parts of the engine to make data structures smaller and algorithms - faster. Of course you’re never done with optimizations so we do this to this day. Curiously, our minimum spec on iOS stayed the same since the initial launch in 2012!</p><p>在2012年底，我们正在积极致力于移动端口。从那时起，我们不得不在引擎的许多不同部分中进行大量工作，以使数据结构更小，算法更快。当然，您永远不会完成优化工作，因此我们至今仍在这样做。奇怪的是，自2012年首次发布以来，我们在iOS上的最低规范一直保持不变！</p><p> A fun fact is that even though we started with iPad 2 as the min. spec we discussed adding support to iPad 1 after launch. At the time there were a lot of people who couldn’t play Roblox on iOS on older hardware. However the performance characteristics of those devices were just… not good enough. You could touch the screen with the finger and pan the camera, and during panning you lost 30% of a single available core to the OS processing the touch. We decided to not add support for this, and 8 years later it seems like a great decision for sure :D</p><p>一个有趣的事实是，即使我们最初只是将iPad 2作为开始。规格，我们讨论了在发布后为iPad 1添加支持。当时，很多人无法在较旧的硬件上的iOS上玩Roblox。但是这些设备的性能特征仅仅是……还不够好。您可以用手指触摸屏幕并摇摄相机，并且在摇摄过程中，您失去了30％的单个可用内核给处理触摸的OS。我们决定不为此提供支持，并且8年后肯定可以肯定的决定是：D</p><p>  It was very hard to use Xcode Instruments to profile frame spikes on an iPad; to try to figure out how to get our performance to a better place on mobile, I wrote some ad-hoc code to dump all internal log events to a binary stream, and a desktop UI tool in F# and WPF to visualize it. This included a Lua profiler as well that could display profiles of Lua code in a traditional hierarchical aggregated view based on event data. This did not survive but curiously we ended up using a similar approach with microprofile years later.</p><p>使用Xcode Instruments剖析iPad上的帧尖峰非常困难。为了设法弄清楚如何在移动设备上获得更好的性能，我编写了一些临时代码将所有内部日志事件转储到二进制流中，并编写了F＃和WPF中的桌面UI工具以对其进行可视化。其中还包括一个Lua分析器，该分析器可以基于事件数据在传统的分层聚合视图中显示Lua代码的概要文件。这无法幸免，但奇怪的是，几年后，我们最终还是使用了类似的方法来进行微轮廓分析。</p><p>   What started in August as a character-only renderer that supported meshes, evolved into something that could render any part in Roblox the same way as old rendering code did. This was not easy, both because performance was really important in every part of the code, and because there’s a  lot of corner cases that had to function pretty much as they did before. Except for perhaps the legacy cylinder rendering:</p><p>它始于八月，最初是支持网格的仅角色渲染器，后来演变成可以像以前的渲染代码一样渲染Roblox中任何部分的东西。这并不容易，这是因为性能在代码的每个部分中都非常重要，并且因为很多极端情况下的功能必须像以前一样发挥作用。除了可能的旧圆柱体渲染：</p><p>  This code supported FFP as well, using matrix palette blending to efficiently render characters with rigid joints, and on desktop also came with vertex shaders that were carefully optimized to run faster on Intel GPUs without hardware vertex shading (through software vertex shading path). Also this implemented stencil shadows using GPU-based extrusion and CPU-based detection of silhouettes with dynamic index buffers. Fun times!</p><p>该代码还支持FFP，使用矩阵调色板混合有效地渲染带有刚性接头的字符，并且在桌面上还附带了经过精心优化的顶点着色器，可在没有硬件顶点着色的情况下（通过软件顶点着色路径）在Intel GPU上更快地运行。同样，此方法使用基于GPU的拉伸和基于CPU的动态索引缓冲区检测轮廓来实现模具阴影。娱乐时间！</p><p>  My memory is a bit fuzzy on this one but I think we were brainstorming possible ways to implement full scene shadows in a way that would work on mobile, and I’ve recently watched the presentation from Little Big Planet on how they did lighting on PS3 with voxel based computations; our CEO was part of the discussions and mentioned “what if all lighting was voxel based”, and the rest is history. The approach we ended up taking was very unique and distinct from many other voxel based implementations to my knowledge.</p><p>我对此记忆有些模糊，但我认为我们正在集思广益，以一种可以在移动设备上使用的方式来实现全场景阴影的方法，最近我观看了《小小大星球》上的演示，介绍了他们如何在PS3上进行照明基于体素的计算；我们的首席执行官是讨论的一部分，并提到“如果所有照明均基于体素该怎么办”，其余就是历史。据我所知，我们最终采用的方法非常独特，不同于许多其他基于体素的实现。</p><p>   In January voxel lighting engine got support for sun shadows and point/spot lights but it felt like on good GPU hardware we could get better results with other techniques, so we were looking for other things we can use voxels for. I don’t remember who came up with the idea but this is when skylight was implemented, which is a form of ambient occlusion with sky as a light source, and is very hard to do correctly without voxels.</p><p>一月份，体素照明引擎获得了对太阳阴影和点/点光源的支持，但是感觉就像在良好的GPU硬件上，我们可以使用其他技术来获得更好的效果，因此我们正在寻找可以用于体素的其他东西。我不记得是谁提出了这个主意，但这是在实施天窗的时候进行的，这是一种以天空为光源的环境光遮挡形式，如果没有体素则很难正确地进行。</p><p>  To make voxel lighting practical I also rewrote all functions using hand coded SIMD (SSE2), including the voxelizer - lighting on CPU isn’t practical without this (this code was later translated to NEON for the iOS port).</p><p>为了使体素照明实用，我还使用了手动编码的SIMD（SSE2）重写了所有功能，包括体素生成器-如果没有此功能，则无法在CPU上进行照明（此代码后来翻译为iOS端口的NEON）。</p><p> The resulting lighting code survived up until FIB Phase 1 which added HDR support and changed voxelizer to use anisotropic occupancy, but is otherwise still used today.</p><p>产生的照明代码一直保存到FIB第一阶段，该阶段增加了对HDR的支持并更改了体素器以使用各向异性的占用率，但直到今天仍在使用。</p><p>  In an effort to redefine the way Roblox games look (back then we thought Roblox as a platform needs an art style), the work on new materials began. We used to use a random set of shaders including some procedural ones; this work replaced the shader framework with “surface shaders” (this is inspired by Aras P. work on Unity from around the same time; we use the resulting shader interfaces to this day although it’s not clear that they are actually pulling their weight, and if I did it today again I would not have gone that route), and implemented more traditional texture-based materials on top, ruining wood grain forever.</p><p>为了重新定义Roblox游戏的外观（当时我们认为Roblox作为平台需要一种艺术风格），开始了新材料的研究。我们曾经使用随机的着色器集，包括一些程序化的着色器。这项工作用“表面着色器”代替了着色器框架（这是由Aras P.在大约同一时间在Unity上的工作启发而来的；直到目前，我们仍使用最终的着色器接口，尽管尚不清楚它们实际上是在增加重量，并且如果我今天再做一次，我就不会走那条路），并在顶部使用更传统的基于纹理的材料，永远毁了木纹。</p><p>  Annoyed with the time it took our custom XML parser/serializer to work with large places, I designed and implemented a custom binary file format. It was chunk-based with per-chunk LZ4 compression and custom binary filters to preprocess the data to help LZ4; the format was structured to make reflection interop cheaper, and maximize loading performance. We use this as the main file format to this day, although the format got a few small tweaks (mainly extensions to handle cryptographic signatures and more efficient shared binary blobs). I’m still happy with the design but I’d slightly change the layout in a couple of places to make loading for very big places more cache-coherent, something that wasn’t as big of a concern back then. This can still be done today but requires small revisions to how some chunks represent data.</p><p>厌倦了我们的自定义XML解析器/序列化器在大型场所上使用的时间，我设计并实现了自定义二进制文件格式。它是基于块的，具有每块LZ4压缩和自定义二进制过滤器，以预处理数据以帮助LZ4；该格式的结构可以使反射互操作更便宜，并最大化加载性能。到目前为止，我们将其用作主要文件格式，尽管该格式进行了一些细微调整（主要是用于处理密码签名的扩展名和更有效的共享二进制blob）。我仍然对设计感到满意，但我会在几个地方稍作更改，以使非常大的地方的加载更加具有缓存一致性，这在当时并不重要。今天仍然可以完成此操作，但需要对一些块表示数据的方式进行小幅修改。</p><p> The initial rollout of this change was just for Play Solo, which saved the entire world to a file and loaded the result back into the new datamodel; this meant it was safe to release because no permanent data loss would occur. After this we gradually switched to using this format for publishing places, and eventually started using it for models (packages) as well. Today almost all semantically rich content on Roblox uses this format.</p><p>这项更改最初是针对Play Solo推出的，它将整个世界保存到一个文件中，并将结果加载回新的数据模型中。这意味着可以安全释放，因为不会发生永久性数据丢失。此后，我们逐渐切换到使用此格式发布位置，最终也开始将其用于模型（包）。如今，Roblox上几乎所有语义丰富的内容都使用这种格式。</p><p> Ironically we did end up replacing our XML parser with a library of mine,  pugixml, in 2019 - although the binary storage is still more performant and space efficient.</p><p>具有讽刺意味的是，尽管二进制存储仍然具有更高的性能和空间效率，但我们最终还是在2019年用了我的pugixml库替换了XML解析器。</p><p>  When we shipped our iOS port it was done with ES1 (FFP); this meant a lot of features didn’t work, including lighting which was becoming pretty important. OGRE support for ES2 was immature at the time, so this included a lot of fixes in OGRE code, and a fair amount of shader tweaks, plus the aforementioned NEON optimization for voxel lighting code to make it practical to run on a mobile device.</p><p>当我们交付iOS端口时，它是通过ES1（FFP）完成的；这意味着很多功能都无法使用，包括照明变得越来越重要。 OGRE对ES2的支持当时还不成熟，因此其中包括OGRE代码中的许多修复，大量的着色器调整以及上述针对体素照明代码的NEON优化，使其可以在移动设备上运行。</p><p> This change helped in the future work - after this landed we never used FFP on mobile, always using shaders to render content, which meant that we wouldn’t need to support ES1 for any technology upgrades, that as it turned out were waiting around the corner.</p><p>这项更改对将来的工作有所帮助-登陆之后，我们再也没有在移动设备上使用FFP，而是始终使用着色器渲染内容，这意味着我们不需要为任何技术升级都支持ES1，因为事实证明，ES1一直在等待角。</p><p>  The development of Roblox engine usually follows a tic-toc-tac pattern (okay we don’t actually have a name for this, but whatever). First we make a new awesome implementation of a subsystem that was in the need of being replaced. Then we work on that new implementation becoming better. Then we remove the legacy system to simplify maintenance. By this point we’ve switched all parts to render in the new cluster rendering path and the old code was ready to be removed. The commit says “removes 500 kb of C++ code, 400 kb of shader/material code, and 3 Mb of content/ textures. Also removes 17 rendering fast flags and 5 rendering log groups.” which felt pretty good at the time!</p><p>Roblox引擎的开发通常遵循tic-toc-tac模式（好吧，我们实际上没有这个名称，但无论如何）。首先，我们为子系统提供了一个很棒的新实现，需要对其进行替换。然后我们致力于使新的实施变得更好。然后，我们删除旧系统以简化维护。至此，我们已将所有部分切换为在新的群集渲染路径中渲染，并且旧代码已准备好删除。提交说：“删除了500 kb的C ++代码，400 kb的着色器/材质代码以及3 Mb的内容/纹理。还删除了17个渲染快速标记和5个渲染日志组。”当时感觉还不错！</p><p>  The way we render thumbnails is with the same rendering code we usually use on the client, but it runs on our servers using a software renderer. This was inefficient because we used a slow software renderer (single-threaded without a JIT) and additionally we went through the setup/teardown of the entire engine for every new image; this was reworked to use a faster software renderer (which was mostly hard because building open-source software on Windows is a pain), and to reuse the same engine context for many thumbnails, which allowed us to dramatically cut the amount of servers we used. It’s comparatively rare that the work I do can be measured in money spent for the company so this felt good.</p><p>渲染缩略图的方式与我们通常在客户端上使用的渲染代码相同，但是它使用软件渲染器在我们的服务器上运行。这是低效的，因为我们使用了速度较慢的软件渲染器（没有JIT的单线程），此外，对于每个新图像，我们都要对整个引擎进行设置/拆卸。对其进行了重新设计，以使用更快的软件渲染器（这很困难，因为在Windows上构建开源软件很痛苦），并且将相同的引擎上下文重用于许多缩略图，这使我们可以大大减少使用的服务器数量。相对而言，我所做的工作可以用为公司花费的金钱来衡量，因此这种感觉很好，这种情况比较少见。</p><p>  … I guess in March I just did some preparatory work, and it’s in June when we actually started working on new shaders and new textures. There was a lot of back-n-forth with our artist to make sure the art can look good in-game but also not create too many issues for games using built-in materials completely counter to their intended purpose (e.g. using Sand colored in blue as water).</p><p>…我想三月份我只是做了一些准备工作，而实际上是在六月，我们开始研究新的着色器和新的纹理。我们的美术师反复进行很多次研究，以确保美术在游戏中看起来不错，但也不会为使用完全违背其预期目的的内置材料（例如使用沙色的蓝色如水）。</p><p> A big portion of work here though was a new UV layout for our terrain materials - we used a voxel based terrain that had a few distinct block types (block, wedges, corner wedges), and together with artists we came up with a new UV layout that was more uniformly distributing pixels in the texture to get good density everywhere.</p><p>不过，这里的大部分工作是为地形材料设置新的UV布局-我们使用了基于体素的地形，该地形具有几种不同的块类型（块，楔形，角形楔形），并且与艺术家一起我们提出了新的UV可以在纹理中更均匀地分布像素的布局，以便在各处获得良好的密度。</p><p>  I remember thinking about voxel lighting more and at some point realizing, well, we can do directional shadows from the sun, we can do point lights - why can’t we do both at the same time, so that every single light source can cast shadow? It turned out that the approach we used for the directional shadows could be adapted to work for point lights, and with some optimizations and tweaks the first version of the voxel lighting engine was finally complete. This would survive up until Future Is Bright Phase 1 which would ship at the end of 2018. This was finalized in September 2013 and optimized with SIMD:</p><p>我记得更多地考虑了体素照明，并且在某个时候意识到，我们可以做来自太阳的定向阴影，我们可以做点光源-为什么我们不能同时做这两个事情，以便每个光源都可以投射阴影？事实证明，我们用于定向阴影的方法可以适用于点光源，并且通过一些优化和调整，体素照明引擎的第一个版本终于完成。这将一直持续到将于2018年底发布的Future Is Bright第一阶段。该阶段于2013年9月完成，并使用SIMD进行了优化：</p><p> Change 37700: SIMD shadow update now works, but I have no idea why.Change 37701: SIMD shadow update works, and now I know why :) Still need more optimization</p><p>更改37700：SIMD阴影更新现在可以正常运行，但我不知道为什么。更改37701：SIMD阴影更新可以运行，现在我知道为什么:)仍然需要更多优化</p><p> I love writing commit messages that straddle the border between “professional” and “fun”.</p><p>我喜欢编写跨越“专业”和“有趣”之间界限的提交消息。</p><p>   Since all of the easy problems, such as part rendering and lighting, were solved, it was time to face the final rendering challenge: text.</p><p>由于解决了所有容易的问题，例如零件渲染和照明，因此现在是时候面对最终的渲染挑战：文本。</p><p> Back then we used a prebaked bitmap (actually two) at two different sizes, and a very poorly written layout code that didn’t support kerning and didn’t handle spacing well. Instead I wrote an F# script (of course!) that baked lots of different sizes of a single font into a large atlas; to conserve texture space, I used a rectangle packer. At runtime the layout algorithm used kerning data to place glyphs at correct locations. This substantially improved text quality at most frequently used sizes, and would last for a few years up until internationalization became a priority and we had to start rendering the font atlas dynamically from TTF source. The layout algorithm would survive for a few more years up until we integrated Harfbuzz to do complex Unicode aware shaping - both of these were done by other people years later.</p><p>当时，我们使用了两种大小的预烘焙位图（实际上是两个），并且编写的布局代码写得很差，不支持字距调整，也无法很好地处理间距。取而代之的是，我写了一个F＃脚本（当然！），它将许多不同大小的单个字体烘焙到一个大图集中。为了节省纹理空间，我使用了矩形包装机。在运行时，布局算法使用字距调整数据将字形放置在正确的位置。这可以在最常用的尺寸上显着提高文本质量，并且可以持续数年，直到国际化成为优先事项为止，我们不得不开始从TTF来源动态渲染字体图集。在我们集成Harfbuzz进行复杂的Unicode感知成形之前，布局算法将继续存在数年，而这两者都是在几年后由其他人完成的。</p><p>  Continuing the trend of increasing the scope of work beyond just rendering, I’ve worked on the design and implementation of new remote events API, including fire-and-forget events and remote function calls (which are super nifty in Lua - because of coroutine support, you can just call a function in Lua, that call will be routed to the server, server will run the code and return the result, and your coroutine will continue running, almost oblivious to the time spent!). It was very hard to find good names for the APIs involved; we haven’t changed any of this since and I still struggle with what the correct function/event name is sometimes.</p><p>继续扩大工作范围（不仅仅是渲染）的趋势，我一直在设计和实现新的远程事件API，包括即发即忘事件和远程函数调用（在Lua中非常漂亮，因为协程）支持，您可以仅在Lua中调用一个函数，该调用将被路由到服务器，服务器将运行代码并返回结果，并且协程将继续运行，几乎不花时间！）。很难找到所涉及的API的好名字。从那以后，我们没有做任何更改，而我仍然为有时使用正确的函数/事件名称而苦恼。</p><p>  Voxel terrain wasn’t very popular among our game developers. For a feature that took a lot of effort to develop and maintain this was unsatisfying, and I was trying to figure out “why”. One hypothesis was that the limited size (512x64x512 voxels I want to say?) made it too limiting; to remedy that I’ve worked on a new sparse voxel storag</p><p>在我们的游戏开发人员中，Voxel地形并不是很受欢迎。对于需要花费大量精力来开发和维护的功能，这是不令人满意的，我正试图找出“为什么”。一种假设是有限的尺寸（我想说512x64x512体素？）太过局限了。以弥补我在研究新的稀疏体素storag</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://zeux.io/2020/08/02/eight-years-at-roblox/">https://zeux.io/2020/08/02/eight-years-at-roblox/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/roblox/">#roblox</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/years/">#years</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>