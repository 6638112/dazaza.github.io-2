<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>应用解析 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">应用解析 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-02 02:12:48</div><div class="page_narrow text-break page_content"><p>解析器组合器是用于以可组合方式构建解析器的功能集。 Haskell的Parsec库和OCaml的Angstrom是两个示例。这两个库都公开了用于描述上下文相关语法的monadic接口。这篇文章着眼于实现一个更受限制的解析库，该解析库是围绕applicativefunctors而不是monads构造的。</p><p> 有什么理由可以放弃单子？根据设计，可能会得到一些回报。在本练习中，目标是具有以下功能的API：</p><p>  要查看为什么（1）无法用monad完成，请考虑使用monadic bind-operator构造的解析器：</p><p>  在此，f是形式为＆＃39; a-＆gt;的函数。 ＆＃39b解析器；这意味着我们不知道它将生成哪种解析器，直到为其提供值为止。因此，我们无法推断出这些解析器消耗的所有可能的符号。同样的道理适用于漂亮的印刷。</p><p>    解析器将字符列表作为输入，并在成功时返回解析的值以及其余的输入。</p><p> 但是，这种表示形式不支持符号提取，漂亮的打印或允许多种评估策略。为了适应这些情况，我们必须在更多上下文中修饰类型。问题是我们不一定知道完整的功能集每次需要一些新功能时（无论是错误报告，记录还是其他），我们都必须返回并更改定义以适应新功能。</p><p> 替代方法不是尝试预先预期所有用例，而是选择一种保留尽可能多的结构的表示形式，以便稍后可以添加替代解释器。为此，我们将通过定义表示抽象语法树（AST）的类型，来有效地枚举解析器的集合及其组合方式。为此，我们将使用GADT，它还表示不同的解析器按不同的类型编制索引。初始构造函数分为两组-原始构造函数（树的叶子节点）和用于构成解析器的组合器： </p><p>输入＆＃39; a t =（*本机解析器*）|失败：字符串-＆gt; ＆＃39; t |空：单位t |返回：＆＃39; a-＆gt; ＆＃39; t |符号：char-＆gt; char t（*组成部分-适用*）|地图：（＆＃39; a-＆gt;＆＃39; b）*＆＃39; t-＆gt; ＆＃39;吨|产品：＆＃39; t *＆＃39; b t-＆gt; （＆＃39; a *＆＃39; b）t（*组成部分-替代*）|要么：＆＃39; t *＆＃39; t-＆gt; ＆＃39;在</p><p>  返回x-不消耗任何输入并且始终返回x的解析器。</p><p> 应用接口是提供顺序组合的接口，例如：首先使用解析器p1解析x，然后使用解析器p2解析y并将其结果合并。</p><p> Either构造函数可以提供替代的执行路径，即在不同类型的输入上成功的解析器。</p><p> 由于我们不想让用户直接访问该类型，因此我们将机械地添加一些智能构造函数：</p><p> let empty =空let失败m =失败m let return x =返回x let symbol c = Symbol c let map fx = Map（f，x）let product pq = Product（p，q）让pq = Either（p， q）</p><p> 拥有应用接口意味着还可以利用新的语法扩展-let + ..和+表示法-我在这里已经进行了描述。假设OCaml 4.08或dune future_syntax节，我们可以添加一个语法模块，如下所示： </p><p>模块语法= struct let（let +）p f =映射f p let（and +）p q =乘积p q结束</p><p> 除此之外，我们还将包括一个带有infix版本的Ops模块以及一些派生的组合器：</p><p> module Ops = struct open语法let（＆lt; $＆gt;）fp = map fp let（＆lt; |＆gt;）pq =要么pq let（＆lt; *＆gt;）pf px = let + f = pf和+ x = fx中的px let（*＆gt;）pq =（fun _ x-＆gt; x）＆lt; $＆gt; p * q let（＆lt; *）p q = const＆lt; $＆gt; p * q结束</p><p>  （*身份*）val id：＆＃39; a-＆gt; ＆＃39;一个（* Const *）val const：＆＃39; a-＆gt; ＆＃39; b-＆gt; ＆＃39; a（*正向构成*）val（＆gt;）：（＆＃39; a-＆gt;＆＃39; b）-＆gt; （＆＃39; b-＆gt;＆＃39; c）-＆gt; ＆＃39; a-＆gt; ＆＃39; c（*将字符列表转换为字符串*）val string_of_list：字符列表-＆gt;字符串（*然后再返回*）val list_of_string：字符串-＆gt;字符列表</p><p>   我们如何使用API​​构建实际的解析器？让我们考虑一些简单的例子。首先，解析器解析一个特定的字符串，即一个函数：</p><p>  要实现字符串解析器，我们可以使用符号原语并在给定的字符串上折叠以使用适用性的语法（let + ..和+）组合解析器：</p><p> let字符串s = let accum cp =（*使用＆＃39; c＆＃39;解析器*）解析let + x =符号c（*然后解析＆＃39; xs＆＃39 ;使用＆＃39;解析器*）和+ xs = p（*将＆＃39＆x39＆xs＆＃39;在字符串中组合*）Printf。 sprintf＆＃34;％c％s＆＃34; x xs在List中。 fold_right accum（list_of_string s）（return＆＃34;＆＃34;） </p><p>接下来，让我们尝试一个解析器来解析数字。检测到一位数字的版本可以定义为：</p><p>  在解析器列表之间进行选择是对二进制或组合器的自然概括，并应使用其自己的版本：</p><p>  我们也可以泛化数字定义以将符号列表作为参数：</p><p>     接下来，考虑一个可以识别任意整数的解析器？整数至少包含一个数字，但我们不知道确切多少个数字。我们如何定义捕获此语义的解析器？第一次尝试：</p><p> let int = let rec digits（）= let + d = digit和+ ds = any（digits（））（return []）in d :: ds in map（string_of_list＆gt;＆gt;＆lt; int_of_string）@@ digits（）</p><p> 您能发现以上定义的问题吗？如果没有，请尝试运行它，您会发现它引发了堆栈溢出异常。问题在于，递归调用永远不会以任何基本情况为条件，并且始终会对其进行评估。我们需要一种方法来描述可能会消耗任意大输入而无需构造无限解析表达式的解析器！为了从int示例中进行概括，我们的目标是具有以下签名的组合器：</p><p>   输入＆＃39; a t = ... |延迟：（单位-＆gt; a t）-＆gt; ＆＃39; t t延迟f =延迟f </p><p>那是一个构造延迟的解析器。我们可以使用延迟来定义许多，如：</p><p> let rec many p = let many_one = let + x = p和+ xs = delay @@ fun _-＆gt; x :: xs中的many p）在many_one中的任何一个（return []）</p><p> 现在，递归的每个步骤都是按需评估，而不是前期评估。如果该解决方案不是针对更雄心勃勃的约束集而必须进行漂亮的打印和符号提取，则此解决方案将非常有效。问题在于，为了提取延迟解析器的所有可能符号，我们需要对其进行评估；这将展开许多定义中表示的无限递归，并再次杀死堆栈。</p><p>  对于同时具有有限可遍历表示并提供足够的表达能力来描述无限解析器的问题，是否有解决方法？问题就出在这里。不递归地表示递归结构的一种方式正是定点组合器所提供的。</p><p> 让我们使用定点构造函数扩展解析器类型（并摆脱Delay）：</p><p> 输入＆＃39; a t = ... |修复：（＆＃39; a t-＆gt;＆＃39; a t）-＆gt; ＆＃39; a t让修复f =修复f</p><p> 然后，我们可以从上面使用fix作为对many定义的递归性的一种补救措施： </p><p>让很多p =修复@@有趣-＆gt; let many_one = let + x = p和+ xs = many in x :: xs在many_one中（return []）</p><p> 请注意，看不到rec关键字。函数修复只是使我们能够模仿递归函数的便捷工具。假设我们仍然遇到需要评估的Fix节点-类型为（＆lt; a t-＆gt;＆＃39; a t）的函数，那么您可能会疑惑如何精确地解决符号提取问题。希望有关解释分析器的下一部分将使该问题更清晰。</p><p> 回到整数解析的例子，这里是如何以许多方式定义int的：</p><p> let int = let + d =数字和+ ds = int_of_string @@ string_of_list（d :: ds）中的许多数字</p><p> 同样，我们可以通过添加新的组合器来提取使用相同解析器（在上面的示例中为一个或多个数字）来解析一次或多次的通用模式，如下所示：</p><p> 让many_one p =让+ x = p和+ xs =很多p x :: xs</p><p> 给定一个解析器p，如果解析器p至少可以在其输入上应用p一次，则很多p成功。 </p><p>附带说明一下，该代码慷慨地利用了新的应用语法来演示如何使用它来编写声明性代码，从而避免使用infix运算符。另外，我们也可以不依赖语法扩展而定义相同的函数。例如：</p><p> （*需要打开Ops模块*）让很多p =修复@@有趣-＆gt;任一个（List。cons＆lt; $＆gt; p＆lt; *＆gt; many）（return []）let many_one p = List。缺点＆lt; $＆gt; p * many p let int =（string_of_list＆gt;＆gt; int_of_string）＆lt; $＆gt; many_一位数字</p><p>  （*需要打开Ops模块*）let int =（string_of_list＆gt;＆gt; int_of_string string_of_list）＆lt; $＆gt; many_一位数字</p><p> 为了总结最初的解析器示例集，这是一个浮点解析器的实现，它也支持以科学计数法解析值：</p><p> let float =（* Ex：123. *）let p1 = let + ds = many_one位，+ d =符号＆＃39;。在ds @ [d]中（* Ex：123.45 *）中let p2 = let + ds1 = p1和+ ds2 = ds1中的many_one位数@ ds2 in（* Ex：12.34e56或12e34 *） p2＆lt; |＆gt; many_one位和+ e =符号＆＃39; e＆＃39;和+ ds2 = ds1 @ [e] @ ds2中的many_one数字，fol cs = float_of_string @@ string_of_list cs in fol＆lt; $＆gt;选择[p1; p2; p3]</p><p>  到目前为止，重点一直是设计一种表达能力足够强的解析器语言，我们甚至已经实现了一些简单的示例，用于解析十进制数字。但是，关于如何在实际输入上运行解析器，没有一行代码。我们还没有对外观的确切语义做出任何决定，例如，运行解析器是否应该返回所有可能结果的列表，或者仅返回它找到的第一个有效结果？我们是否希望解析器回退一个或更多步骤以防卡住？</p><p> 缺乏这样的设计决策是一个功能，而不是错误！精心设计用于构造解析器的前端，使我们能够提供多个后端来运行它们。首先，我们将看一个简单的非回溯评估器。 </p><p>为了执行解析器，我们需要将其转换为函数。对于不处理错误报告的简单版本，我们可以使用与上述相同的类型-函数类型：char list-＆gt; （＆*字符列表）选项：</p><p>  我添加了一组多余的括号，以强调eval使用一个解析器并返回一个函数的事实。</p><p>  由于GADT的结构，每个递归调用都可以使用不同类型的解析器来调用该函数；因此，我们需要对多态局部抽象类型使用语法。以下是一个完整的实现。对于选项类型，它假定适用于应用程序和Monadic组合器的模块为Option.Syntax，如下所述：</p><p> 让我们回想一下：键入a。 t-＆gt;字符列表-＆gt; （a *字符列表）选项= fun p->将p与|匹配失败_-＆gt; const无|空-＆gt;有趣的CS-＆gt; （将CS与| []-＆gt; Some（（），[]）| _-＆gt; None匹配）|返回x-＆gt;有趣的CS-＆gt;一些（x，cs）|符号s-＆gt;有趣的CS-＆gt; （当c = s-> Some（s，cs）| _-＆gt; None时，将cs与| c :: cs匹配）|映射（f，p）-＆gt;令ep = eval p有趣的CS->选项 。语法（let +（x，cs）= ep cs in（f x，cs））|乘积（p，q）-＆gt;令ep ＝ eval p，令eq ＝ eval q的乐趣cs->选项 。语法（let *（x，cs）= ep cs in let *（y，cs）= eq cs in Some（（x，y），cs））| （p，q）-＆gt;令ep ＝ eval p，令eq ＝ eval q的乐趣cs-> （用| Some r-> Some r | None-> eq cs匹配ep cs）|修复f-＆gt;有趣的CS-＆gt;评估（f（Fix f））cs</p><p> 模式匹配的每个分支都返回一个接受字符列表并产生可选结果的函数。</p><p> 为方便起见，我们可以将其公开为一个函数，该函数将解析器规范转换为使用字符串的函数以实际执行解析：</p><p>     ＃eval＆＃39;浮动＆＃34.12.34＆＃34; ;; -：（float * char list）选项=某些（12. 34，[]）＃eval＆＃39;浮动＆＃34; 1.2e3＆＃34; ;; -：（float * char list）选项=某些（1200。，[]）＃eval＆＃39;浮动＆＃34; a1.23＆＃34; ;; -：（float * char list）选项=无 </p><p>eval的实现不是回溯，而是仅针对给定的输入返回解析器的一个可能匹配项。一种替代实现将返回结果列表，如下所示：</p><p>    符号提取是解析器解释器的另一个示例-通过遍历其树来识别解析器所有可能输入的集合的功能：</p><p>   模块CS =设置。 Make（Char）let符号p = let recaux：键入a。 t-＆gt; CS 。 t =函数|失败_-＆gt; CS 。空的空-＆gt; CS 。空的返回_-＆gt; CS 。空的符号c-＆gt; CS 。单例c |地图（_，p）-＆gt;辅助p |乘积（p，q）-＆gt; CS 。联合（辅助p）（辅助q）| （p，q）-＆gt; CS 。联合（辅助p）（辅助q）|修复f-＆gt; aux @@ f @@在aux p |＆gt;中修正（fun _-＆gt;失败＆＃34;＆＃34;）。 CS 。 to_seq |＆gt;列表 。 of_seq</p><p> 大多数情况都是微不足道的-例如，Symbol c返回带有c的单例集，而Either返回每个分支中符号的并集。Fix f可能是最有趣的情况。 Fix的有效负载具有以下类型的功能： ＆lt; t，因此我们只需要传递一些解析器，该解析器不会引入任何其他符号，因此会失败。</p><p>  ＃个符号浮动;; -  ：  CS 。 elt list = [＆＃39;。＆＃39; ; ＆＃39; 0＆＃39; ; ＆＃39; 1＆＃39; ; ＆＃39; 2＆＃39; ; ＆＃39; 3＆＃39; ; ＆＃39; 4＆＃39; ; ＆＃39; 5＆＃39; ; ＆＃39; 6＆＃39; ; ＆＃39; 7＆＃39; ; ＆＃39; 8＆＃39; ; ＆＃39; 9＆＃39; ; ＆＃39; e＆＃39; ]</p><p>  作为解析器解释器的最后一个示例，我们将编写一个将解析器转换为字符串的函数：</p><p>   让rec显示：输入a。 t-＆gt;字符串=函数|信息失败-＆gt;味精|空-＆gt; ＆＃34;空＆＃34; |符号c-＆gt; Printf。 sprintf＆＃34;符号＆＃39;％c＆＃39;＆＃34; c |返回x-＆gt; ＆＃34;返回？＆＃34; |映射（f，p）-＆gt; Printf。 sprintf＆＃34; map？ （％s）＆＃34; （显示p）|乘积（p，q）-＆gt; Printf。 sprintf＆＃34;产品（％s）（％s）＆＃34; （显示p）（显示q）| （p，q）-＆gt; Printf。 sprintf＆＃34;任一（％s）（％s）＆＃34; （显示p）（显示q）|修复f-＆gt; Printf。 sprintf＆＃34;让f（）中的rec f（）=％s） @@ show（f（失败＆＃34; f（）＆＃34;）） </p><p>请注意，我们无法完全显示所有结构。 Map的有效负载包含一个我们不知道如何打印的功能。我们还缺少打印机以返回参数。对于完全透明的解析器，我们必须强加一些其他结构（例如，将参数与打印机配对），但是现在，我们仅插入一些问号以指示不透明的参数。还要注意我们如何恢复Fix f的递归结构，方法是像let rec ..那样打印它。例如，考虑打印由许多组合器解析的解析器：</p><p> ＃let p = many（符号＆＃39; a＆＃39;）;; val p：字符列表P。 t =固定＆lt;乐趣＆gt; ＃print_endline @@ show p ;; let rec f（）=在f（）中的（map？（product（map？（symbol＆＃39; a＆＃39;））（f（））））（return（））</p><p> 要了解这有何意义，请在下面的版本中填写问号：</p><p> let rec f（）=或者（map List。cons（product（map id（symbol＆＃39; a＆＃39;））（f（））））（return（]）in f（）</p><p> 这与我们在引入定点组合器之前开始的许多递归版本非常相似。</p><p>  在查看eval的实现时，您可能已经注意到，在每种情况下（除了Fix f之外），返回函数的主体中都没有递归调用。例如，在乘积（p，q）的情况下，在返回使用实际输入的函数之前，先对p和q进行求值。因此，对于不使用fix的解析器–解析器AST的所有痕迹都将被eval消除，并且在实际解析过程中我们无需支付任何额外的运行时成本。</p><p> 是否可以修改Fix f的情况以提前进行评估？第一个尝试是简单地排除递归调用： </p><p>|修复f-＆gt;让g = eval @@ f（修复f）有趣的cs-＆gt; g cs</p><p> 但是，人们很快意识到，由于评估可能会停留在不断扩展的f（Fix f）表达式上，因此并不能完全解决问题。请记住，引入了修订程序来编码许多组合器所需的递归定义。该策略是在评估级别将其转换回递归定义，类似于我们在上面的show实施中为打印所做的操作。</p><p>     aux主体是通过将函数f应用于可能会回调自身的其他表达式来给出的。但是，问题在于f的参数本身必须是解析器表达式。我们可以通过引入另一个节点来保留原始评估程序来解决此问题：</p><p> 输入＆＃39; a t = ... | Raw：（字符列表-＆gt;（＆＃39; a *字符列表）选项）-＆gt; ＆＃39;在</p><p> 暴露这样的构造函数当然会挫败首先使用定点组合器的目的，因为无论如何我们都必须放弃符号提取和打印。但是，我们仅将其用作内部帮助程序节点。如果我们专门导出智能构造函数，并使其类型为抽象或私有，则用户将永远无法构造原始节点。因此，对于其他任何评估者，我们可以放心地忽略这种情况。</p><p> 返回到eval的实现，这里介绍了递归转换的实现方式：</p><p> 让我们回想一下：键入a。 t-＆gt;字符列表-＆gt; （a *字符列表）选项= fun p-> ... |修复f-＆gt; let rec k =懒惰（eval @@ f（Raw（fun cs-> Lazy。force k cs）））。力k |原始f-＆gt; F </p><p>k的递归定义懒惰地调用eval。 但是，由于我们立即对其进行强制，因此我们只对其进行过一次评估！ 通过应用f返回的表达式可以包含一个子节点Raw g，其中g表示k。另一种选择是使用ref-cells而不是lazy构造。  在查看如何使用解析库的另一个示例之前，有一些实用程序函数会很方便：  val one_of：字符串-＆gt; 之间的字符：＆＃39; t-＆gt; ＆＃39; b t-＆gt; ＆＃39; c t-＆gt; ＆＃39; 忘记：＆＃39; t-＆gt; 在  在p1 p2 p之间的是一个解析器，该解析器首先解析p1，然后是p，然后是p2，并且仅返回p的结果。  函数one_of和between之间可以用现有的组合器来编写。 至于  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jobjo.github.io/2019/05/19/applicative-parsing.html">https://jobjo.github.io/2019/05/19/applicative-parsing.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/应用/">#应用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1047496.html"><img src="http://img2.diglog.com/img/2021/2/thumb_5874478f0b0ae958ec9ce9c06165d611.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1047496.html">马克·库班（Mark Cuban）与他人共同创建了一个播客应用，主持人可以在此与粉丝交流，并通过他们的会话获利 </a></div><span class="my_story_list_date">2021-2-9 20:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1046515.html"><img src="http://img2.diglog.com/img/2021/1/thumb_8972c1f5c96234129fddcae1ce3b433e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1046515.html">罗宾汉（Robinhood）的Android应用在Play商店中的排名已根据约30万的评分降至1星； 其iOS应用仍然反映出超过4星的评分 </a></div><span class="my_story_list_date">2021-1-29 4:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045802.html"><img src="http://img2.diglog.com/img/2021/1/thumb_43f6e6999ad41e5eacb408bc452c2ed3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045802.html">约会集团表示已拥有7300万注册用户，它以1490万欧元的价格收购了一次基于瑞士的应用，该应用利用人工智能为每个用户每天提供一场比赛 </a></div><span class="my_story_list_date">2021-1-22 22:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045016.html"><img src="http://img2.diglog.com/img/2021/1/thumb_8d249c8b8af200daef377b022ac5ef57.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045016.html">集团起诉苹果允许在App Store上使用Telegram，声称存在“令人讨厌的内容” </a></div><span class="my_story_list_date">2021-1-19 10:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>