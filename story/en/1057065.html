<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们将Github API缩放了Redis中的分片，复制的速率限制器 We scaled the GitHub API with a sharded, replicated rate limiter in Redis</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">We scaled the GitHub API with a sharded, replicated rate limiter in Redis<br/>我们将Github API缩放了Redis中的分片，复制的速率限制器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 00:01:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/50b167e95326ddd1d22749c631dcdc2a.png"><img src="http://img2.diglog.com/img/2021/4/50b167e95326ddd1d22749c631dcdc2a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>About a year ago, we migrated an old rate limiter in order to serve more traffic and accommodate a more resilient platform architecture. We adopted a replicated Redis backend with client-side sharding. In the end, it worked out great, but we learned some lessons along the way.</p><p>大约一年前，我们迁移了一个旧的速率限制器，以便为更多的流量提供服务，并适应更具弹性的平台架构。我们采用了一个带客户端分级的复制redis后端。最后，它的效果很棒，但我们沿途学到了一些教训。</p><p>   In Memcached, increment the value of that key, setting it to 1 if there wasn’t any current value</p><p>   在memcached中，将该键的值递增，如果没有任何当前值，将其设置为1</p><p> Also, if there wasn’t already one, set a “reset at” value in Memcached, using a related key (eg, “ #{key}:reset_at“)</p><p> 此外，如果尚未存在一个，请使用相关键（例如，“＃{key}：reset_at”）设置“在”memcached中的值“重置”值。</p><p> When incrementing, if the “reset at” value is in the past, ignore the existing value and set a new “reset at”</p><p> 递增时，如果过去的“重置”值，请忽略现有值并设置新的“复位”</p><p> At the beginning of each request, if the value for the key is above the limit, and “reset at” is in the future, then reject the request</p><p> 在每个请求的开头，如果密钥的值高于限制，并且将来“重置为”，然后拒绝请求</p><p> (There might have been more nuance to it, but that’s the main idea.)</p><p> （可能对它有更多细微差别，但这是主要的想法。）</p><p>  Our Memcached architecture was due to change. Since it was  mostly used as a caching layer, we were going to switch from a single, shared Memcached to one Memcached per datacenter. Although that’d work fine for application caching, it would cause our rate limiter to behave very strangely if client requests were routed to different data centers.</p><p>  我们的Memcached架构是由于变化。由于它大多数用作缓存层，因此我们将从单个共享MEMCACHED从单个共享的MEMCACHE切换到每个数据中心的一个MEMCACHED。虽然适用于应用程序缓存，但如果客户要求被路由到不同的数据中心，则会导致我们的速率限制器非常奇怪。 </p><p> Memcached “persistence” wasn’t working for us. The Memcached backend was shared by the rate limiter and other application caches which meant that, when it filled up, it would sometimes evict rate limiter data, even when it was still active. (As a result, clients would get “fresh” rate limit windows when they shouldn’t. Sometimes, only  one key would be evicted – they’d keep the same “used” value, but get new, future, “reset at” values!)</p><p>Memcached“持久性”不适合我们。 Memcached后端由速率限制器和其他应用程序缓存共享，这意味着，当它填满时，它有时会阻止速率限制器数据，即使它仍然处于活动状态。 （结果，客户端将获得“新鲜”的速率限制窗口。有时，只有一个关键就会被驱逐 - 他们会保持相同的“使用”价值，但获得新的未来，“重置”价值观！）</p><p>   Use Redis, since it has a more appropriate persistence system and simple sharding and replication setups</p><p>   使用Redis，因为它具有更合适的持久性系统和简单的分片和复制设置</p><p> Shard inside the application: the app would pick, for each key, which Redis cluster to read and write from</p><p> 应用程序内的碎片：该应用程序将为每个密钥选择，redis群集读取和写入</p><p> To mitigate the CPU-bound nature of Redis, put a single primary (for writes) and several replicas (for reads) in each cluster</p><p> 要缓解REDIS的CPU绑定性质，请在每个群集中放置单个主要（编写）和几个副本（对于读取）</p><p> Instead of writing “reset at” in the database, use Redis expiration to make values disappear when they no longer apply</p><p> 而不是在数据库中写入“重置”，而是在不再适用的情况下使用redis到期来使值消失</p><p> Implement the storage logic in Lua, to guarantee atomicity of operations (this was an improvement over the previous design)</p><p> 在Lua实现存储逻辑，保证操作的原子性（这是对以前的设计改进）</p><p> One option we  considered but decided against was using our MySQL-backed KV store ( GitHub::KV) for storage. We didn’t want to add traffic to already-busy MySQL primaries: usually, we use replicas for GET requests, but rate limit updates would require write access to a primary. By choosing a different storage backend, we could avoid the additional (and substantial) write traffic to MySQL.</p><p> 我们考虑的一个选项，但决定使用我们的MySQL支持的KV商店（GitHub :: kV）进行存储。我们不想向已经忙碌的MySQL原序添加流量：通常，我们使用副本获取请求，但速率限制更新需要对主要的写访问权限。通过选择不同的存储后端，我们可以避免向MySQL提供额外的（和实质性）。 </p><p> Another advantage to using Redis is that it’s a well-traveled path. We could take inspiration from two excellent existing resources:</p><p>使用Redis的另一个优点是它是一个良好的路径。我们可以从两个优秀的现有资源中获取灵感：</p><p> Stripe’s technical blog post, “ Scaling your API with Rate Limiters”, which includes a Ruby and Redis  example implementation</p><p> Stripe的技术博客文章“用速率限制仪缩放您的API”，其中包括Ruby和Redis示例实现</p><p>  To roll out this change, we isolated the current persistence logic into a  MemcachedBackend class, and built a new  RedisBackend class for the rate limiter. We used a feature flag to gate access to the new backend. This allowed us to gradually increase the percentage of clients using the new backend. We could change the percentage  without a deploy, which meant, if something went wrong, we could quickly switch back to the old implementation.</p><p>  要推出此更改，我们将当前的持久性逻辑分离为MemcachedBackend类，并为速率限制器构建了一个新的RedisBackend类。我们使用一个功能标志来门访问新的后端。这允许我们使用新的后端逐步增加客户的百分比。我们可以改变没有部署的百分比，这意味着，如果出现问题，我们可以快速切换回旧的实现。</p><p> The release went smoothly, and when it was done, we removed the feature flag and the  MemcachedBackend class, and integrated  RedisBackend directly with the  Throttler class that delegated to it.</p><p> 该发布顺利进行，当完成后，我们删除了功能标志和MemcachedBackend类，并直接与委托给它的Throttler类集成了RedisBackend。</p><p>   A lot of integrators watch their rate limit usage very closely. We got two really interesting bug reports in the weeks following our release:</p><p>   很多集成商密切关注他们的速率限制使用。在我们发布后的几周内，我们有两个非常有趣的错误报告：</p><p> Some clients observed that their  X-RateLimit-Reset header value “wobbled” – it might show  2020-01-01 10:00:00 for one request, but  2020-01-01 10:00:01 on another request (with one second difference).</p><p> 一些客户观察到他们的x-RATELIMIT-RESET标题值“摆动” - 它可能会显示一个请求的10:00:00，但另一个请求（带一个）第二区别）。</p><p> Some clients had their requests  rejected for being over the limit, but the response headers said  X-RateLimit-Remaining: 5000. That didn’t make sense: if they had a full rate limit window ahead of them, why was the request rejected?</p><p> 一些客户的要求拒绝过度限制，但响应标题表示X-RATELIMIT  - 剩余时间：5000.这没有意义：如果他们在他们面前有一个全额限制窗口，为什么请求被拒绝？ </p><p>   We were optimistic about using Redis’s built-in time-to-live (TTL) to implement our “reset at” feature. But it turns out, my implementation caused the “wobble” described above.</p><p>我们对使用Redis的内置时间到Live（TTL）持乐观态度，以实现我们的“重置”功能。但事实证明，我的实现导致上面描述的“摆动”。</p><p> The Lua script returned the TTL of the client’s rate limit value, and then in Ruby, it was added to  Time.now.to_i to get a timestamp for the  X-RateLimit-Reset header. The problem was, time  passes between the call to TTL (in Redis) and  Time.now.to_i (in Ruby). Depending exactly how much time, and where it fell on the clock’s second boundary, the resulting timestamp might be different. For example, consider the following calls:</p><p> Lua脚本返回了客户端的速率限制值的TTL，然后在Ruby中，它被添加到Time.Now.to_I获取X-RATELIMIT复位标题的时间戳。问题是，时间在TTL（redis中）和time.now.to_i（在Ruby）之间传递。根据需要多少时间，并且在时钟的第二个边界上落下的位置，所产生的时间戳可能是不同的。例如，考虑以下呼叫：</p><p>  In that case, since the second boundary happened  between the call to TTL and  Time.now, the resulting timestamp was one second  bigger than the previous ones.</p><p>  在这种情况下，由于第二个边界发生在TTL和Time.Now之间，因此得到的时间戳比前一个更大的时间。</p><p> We could have tried increasing the precision of this operation (eg, Redis PTTL), but there would  still have been some wobble, even if it was greatly reduced.</p><p> 我们本可以尝试提高此操作的精度（例如，Redis PTTL），但即使它被大大降低，仍然存在一些摆动。</p><p> Another possibility was to calculate the time using  only Redis, instead of mixing Ruby and Redis calls to create it. Redis’s  TIME command could have been used as the source of truth. (Old Redis versions didn’t allow  TIME in Lua scripts, but Redis 5+ does.) We avoided this design because it would have been harder to test: by using Ruby’s time as the source of truth, I could time-travel in my tests with Timecop, asserting that expired keys were handled correctly without actually  waiting for Redis’s calls to the system clock to return true, future times. (I still had to wait on Redis to test the  EXPIRE-based database cleanup, but since  expires_at came from Ruby-land, I could inject very short expiration windows to simplify testing.)</p><p> 另一种可能性是仅使用Redis计算时间，而不是混合Ruby和Redis呼叫来创建它。 redis的时间命令可能被用作真理来源。 （旧的redis版本没有时间在Lua脚本中允许时间，但redis 5+确实如此。）我们避免了这种设计，因为它会更加难以测试：通过使用Ruby的时间作为真理的来源，我可以在我的时间里旅行使用TimeCop进行测试，断言已过期密钥，无需实际等待Redis对系统时钟返回True，未来时间的呼叫。 （我仍然不得不等待Redis来测试基于过期的数据库清理，但是由于Expires_at来自Ruby-Land，我可以注入非常短的到期窗口来简化测试。）</p><p> Instead, we decided to  persist the “reset at” time from Ruby in the database. That way, we could be sure it wouldn’t wobble. (Wobbling was an effect of the  calculation – but reading from the database would guarantee a stable value.) Instead of reading TTL from Redis, we stored another value in the database (effectively doubling our storage footprint, but OK).</p><p> 相反，我们决定持续到数据库中的Ruby的“重置”时间。这样，我们可以确定它不会摆动。 （Wobbling是计算的效果 - 但从数据库中的读取将保证稳定的值。）而不是从Redis读取TTL，我们在数据库中存储了另一个值（有效地加倍我们的存储空间，但是确定）。</p><p> We still applied a TTL to rate limit keys, but they were set for one second  after the “reset at” time. That way, we could use Redis’s own semantics to clean up “dead” rate limit windows.</p><p> 我们仍然将TTL应用于速率限制键，但在“在”时间“时，它们被设置为一秒钟。这样，我们可以使用Redis的自己的语义清理“死亡”速率限制窗口。 </p><p>  Weirdly, many clients reported  rejections that included  X-RateLimit-Remaining: 5000 headers. What’s going on!?</p><p>奇怪地，许多客户报告拒绝包含X-RATELIMIT的拒绝：5000个标题。这是怎么回事！？</p><p>  At the beginning of the request, check the client’s current rate limit value. If it’s over the maximum allowed limit, prepare a rejection response.</p><p>  在请求的开头，检查客户的当前速率限制值。如果它超过最大允许的限制，则准备拒绝响应。</p><p> Before delivering the response, increment the current rate limit value, and use the response to populate the  X-RateLimit-... headers.</p><p> 在提供响应之前，将当前速率限制值递增，并使用响应填充X-RATELIMIT -...标题。</p><p> Well, it turned out that Step 1 above hit a Redis  replica, since it was a read operation. The read operation returned information about the client’s previous window, and the application prepared a rejection response.</p><p> 嗯，事实证明，上面的步骤1击中了Redis副本，因为它是读取操作。读取操作返回了有关客户端上一个窗口的信息，并且应用程序准备了拒绝响应。</p><p> Then, Step 2 would hit a Redis  primary. During that database call, Redis would expire the previous window data and return data for a  fresh rate limit. This is a known limitation of Redis: replicas don’t expire data until they receive instructions to do so from their primaries, and primaries don’t expire keys until they’re accessed ( GitHub issue). (In fact, primaries  do randomly sample keys from time to time, expiring them as appropriate, see “ How Redis Expires Keys”.)</p><p> 然后，步骤2将击中redis primary。在该数据库调用期间，Redis将过期前一个窗口数据并返回新速率限制的数据。这是一个已知的redis限制：副本不会过期数据，直到他们从原初级接收到这样做，并且初选不会到期键（GitHub问题）直到它们才会过期（实际上，Primaries不时会随机采样键，适当到期，请参阅“Redis如何到期键”。）</p><p>  Basically, the same fix as above: instead of relying on Redis’s TTL to expire old rate limit windows, we needed to manage that feature in the application. (The application should be prepared to read stale data from replicas, then ignore it.)</p><p>  基本上，如上所述，相同的修复：而不是依赖于Redis的TTL来过期旧速率限制窗口，而是需要在应用程序中管理该功能。 （应用程序应准备好从副本阅读陈旧数据，然后忽略它。）</p><p> Even after fixing that, a better design was required: in the case of rate-limited requests, we should avoid a second call to the database. The client’s window might expire between the two calls, resulting in the kind of inconsistent response described above. This fix required improving the Ruby code that prepared responses so that the response from Step 1 above was used to populate  X-RateLimit-... headers.</p><p> 即使在修复之后，还需要更好的设计：在速率有限的请求的情况下，我们应该避免对数据库的第二个调用。客户端的窗口可能会在两个呼叫之间过期，从而导致上述响应的类型。此修复程序需要改进编写响应的Ruby代码，以便上面步骤1的响应填充X-Ratelimit -...标题。 </p><p>   -- RATE_SCRIPT:-- count a request for a client-- and return the current state for the client-- rename the inputs for clarity belowlocal rate_limit_key = KEYS[1]local increment_amount = tonumber(ARGV[1])local next_expires_at = tonumber(ARGV[2])local current_time = tonumber(ARGV[3])local expires_at_key = rate_limit_key .. &#34;:exp&#34;local expires_at = tonumber(redis.call(&#34;get&#34;, expires_at_key))if not expires_at or expires_at &lt; current_time then -- this is either a brand new window, -- or this window has closed, but redis hasn&#39;t cleaned up the key yet -- (redis will clean it up in one more second) -- initialize a new rate limit window redis.call(&#34;set&#34;, rate_limit_key, 0) redis.call(&#34;set&#34;, expires_at_key, next_expires_at) -- tell Redis to clean this up _one second after_ the expires-at time. -- that way, clock differences between Ruby and Redis won&#39;t cause data to disappear. -- (Redis will only clean up these keys &#34;long after&#34; the window has passed) redis.call(&#34;expireat&#34;, rate_limit_key, next_expires_at + 1) redis.call(&#34;expireat&#34;, expires_at_key, next_expires_at + 1) -- since the database was updated, return the new value expires_at = next_expires_atend-- Now that the window is either known to already exist _or_ be freshly initialized,-- increment the counter (`incrby` returns a number)local current = redis.call(&#34;incrby&#34;, rate_limit_key, increment_amount)return { current, expires_at } -- CHECK_SCRIPT:-- Getting both the value and the expiration-- of key as needed by our algorithm needs to be ran-- in an atomic way, hence the script.-- rename the inputs for clarity belowlocal rate_limit_key = KEYS[1]local expires_at_key = rate_limit_key .. &#34;:exp&#34;local current_time = tonumber(ARGV[1])local tries = tonumber(redis.call(&#34;get&#34;, rate_limit_key))local expires_at = nil -- maybe overridden belowif not tries then -- this client hasn&#39;t initialized a window yet -- let this fall through to returning {nil, nil}, -- where the application will provide defaultselse -- we found a number of tries, now check -- if this window is actually expired expires_at = tonumber(redis.call(&#34;get&#34;, expires_at_key)) if not expires_at or expires_at &lt; current_time then -- this window hasn&#39;t been cleaned up by Redis yet, but it has closed. -- (maybe it was _partly_ cleaned up, if we found `tries` but not `expires_at`) -- ignore the data in the database; return a fresh window instead tries = nil expires_at = nil endend-- Maybe {nil, nil} if the window is brand new (or expired)return { tries, expires_at }</p><p>-  Rate_script： - 计算客户端的请求 - 并返回客户端的当前状态 - 重命名输入的输入下调以下本地incly_key =键[1]本地increntment_amount = tonumber（argv [1]）local next_expires_at = tonumber （argv [2]）本地current_time = tonumber（argv [3]）本地expires_at_key = paters_limit_key ..＆＃34;：exp＆＃34; local affires_at = tonumber（redis.call（＆＃34; get＆＃34; expires_kate_key ））如果没有expires_at或affires_at＆lt; thount_time然后 - 这是一个全新的窗口， - 或者这个窗口已经关闭，但是redis hasn＆＃39; t清理了钥匙 - （Redis会再次清除它） - 初始化一个新的速率限制窗口redis.call（＆＃34; set＆＃34; hate_limit_key，0）redis.call（＆＃34; set＆＃34; affires_at_key，nexp_expires_at） - 告诉Redis清除_one _到期后_one _one - 时间。 - 这种方式，Ruby和Redis之间的时钟差异Won＆＃39; t导致数据消失。 - （Redis只会清理这些钥匙＆＃34;窗口已经过去）rediS.call（＆＃34; expireat＆＃34;，pater_limit_key，next_expires_at + 1）redis.call（＆＃34 ; expireat＆＃34;，affires_at_key，nexp_expires_at + 1） - 由于更新了数据库，因此返回新值expires_at = next_expires_atend--现在窗口已知已存在_or_刚刚初始化， - 增量计数器（ `Incby`返回一个数字）本地Current = redis.call（＆＃34; incrby＆＃34; ratury_limit_key，increntment_amount）return {current，appires_at}  -  check_script： - 获得键的值和到期根据需要的算法需要以原子方式ran--因此脚本.--重命名输入的输入，以便清楚地下降至本地rate_key_key = keys [1] local expires_at_key = rate_limit_key ..＆＃34;：exp＆＃34;当地current_time = tonumber（argv [1]）本地尝试= tonumber（redis.call（＆＃34; get＆＃34; pare_limit_key））local appires_at = nil  - 可能被覆盖以下原因，而不是尝试 -  thi S客户端HASN＆＃39; T初始化了一个窗口 - 让这一点才能返回{nil，nil}， - 在应用程序提供defaultselse的地方 - 我们发现了许多尝试，现在检查 - 如果这个窗口是实际上已过期expires_at = tonumber（redis.call（＆＃34; get＆＃34; get＆＃34; expires_at_key）），如果没有expires_at或affires_at <t＆lt; Current_Time那么 - 这个窗口Hasn＆＃39; redis清理过来，但它已关闭。 - （也许它是_Partly_清理，如果我们发现了？尝试但不是`Expires_at`） - 忽略数据库中的数据;返回一个新鲜的窗口，而不是tries = nil expires_at = nil endend--如果窗口是全新的（或过期）返回{tries，affires_at}，那么{nil，nil}</p><p>  We’ve learned a lot from this new approach, but there’s still one shortcoming we’re considering: the current implementation doesn’t increment the “current” rate limit value until after the request is  finished. We do this because we don’t charge clients for  304 Not Modified responses (this can happen when the client provides an E-Tag). A better implementation might increment the value when the request  starts, then refunds the client if the response is  304. That would prevent some edge cases where a client can exceed its limit when the final allowed request is still being processed.</p><p>  我们从这种新方法学到了很多，但我们仍然存在一个缺点：当前的实现不会递增“当前”速率限制值，直到请求完成后。我们这样做是因为我们不向客户收取304的客户端，而不是修改的响应（当客户端提供电子标签时可能会发生）。更好的实现可能会在请求开始时递增值，然后如果响应为304，则会退回客户端。这将阻止客户端在仍在处理最终允许的请求时客户端可以超过其限制的边缘情况。</p><p> After working out the issues described in this post, the new rate limiter has worked great. It has improved reliability, fixed issues for clients, and reduced our support load (eventually 😉) and the architecture is ready for our next wave of platform improvements.</p><p> 在解决这篇文章中描述的问题之后，新的速率限制器已经很好。它具有改进的可靠性，固定客户的问题，并减少了我们的支持负载（最终😉），并且该架构已准备好进行我们的下一波平台改进。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-04-05-how-we-scaled-github-api-sharded-replicated-rate-limiter-redis/">https://github.blog/2021-04-05-how-we-scaled-github-api-sharded-replicated-rate-limiter-redis/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/redis/">#redis</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>