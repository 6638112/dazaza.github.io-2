<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Zabbix–不安全会话存储的案例研究Zabbix â€“ A Case Study of Unsafe Session Storage</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Zabbix â€“ A Case Study of Unsafe Session Storage<br/>Zabbix–不安全会话存储的案例研究</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 15:38:02</div><div class="page_narrow text-break page_content"><p>Zabbix is a very popular open-source monitoring platform used to collect, centralize and track metrics like CPU load and network traffic across entire infrastructures. It is very similar to solutions like Pandora FMS and Nagios. Because of its popularity, features and its privileged position in most company’s networks, Zabbix is a high-profile target for threat actors. A public vulnerability broker, a company specialized in the acquisition of security bugs, also publicly announced their interest in this software.</p><p>Zabbix是一个非常流行的开源监控平台，用于收集、集中和跟踪整个基础设施的CPU负载和网络流量等指标。它与Pandora FMS和Nagios等解决方案非常相似。由于Zabbix的受欢迎程度、功能以及在大多数公司网络中的特权地位，它是威胁参与者的一个引人注目的目标。一家专门收购安全漏洞的公共漏洞代理公司也公开宣布对该软件感兴趣。</p><p> We discovered a high-severity vulnerability in Zabbix’s implementation of client-side sessions that could lead to the compromise of complete networks. In this article, we give an introduction to the different kinds of session storage and discuss what makes an implementation safe. Then, we describe the technical details of the vulnerability that we discovered in Zabbix, its impact and how it can be prevented. Let’s dive into it!</p><p>我们在Zabbix的客户端会话实现中发现了一个高度严重的漏洞，该漏洞可能会导致整个网络受损。在本文中，我们将介绍不同类型的会话存储，并讨论如何确保实现的安全性。然后，我们描述了我们在Zabbix中发现的漏洞的技术细节、其影响以及如何预防。让我们投入其中吧！</p><p>   Sessions are all about storing a state across several HTTP requests, stateless by design. To this end, applications commonly hand a unique identifier to each client; they have to transmit it alongside future requests. The server can then load the associated information whether it is stored in-memory, in a database, on the local file system, etc. That’s what we usually call server-side session storage.</p><p>会话都是关于跨多个HTTP请求存储状态，设计上是无状态的。为此，应用程序通常会向每个客户机传递一个唯一的标识符；他们必须将其与未来的请求一起传输。然后，服务器可以加载相关信息，无论它是否存储在内存、数据库、本地文件系统等中。这就是我们通常所说的服务器端会话存储。</p><p> This historical approach works well but has drawbacks with the way modern web applications are developed and deployed. For instance, it does not scale well: if the backend service is split across multiple servers, how to make sure one’s session is available across services or even the entire server fleet?</p><p>这种历史性的方法工作得很好，但与现代web应用程序的开发和部署方式相比存在缺点。例如，它不能很好地扩展：如果后端服务被拆分到多个服务器上，如何确保一个会话在多个服务甚至整个服务器组中可用？</p><p> As a result, developers introduced the storage of the session on the client-side. Instead of assigning a session identifier to the client, they now have to send a copy of the state with every request. Technology stacks like ASP and Java wrapped this concept in something called View States, but it is now very common to rely on the JSON Web Token (JWT) standard instead.</p><p>因此，开发人员在客户端引入了会话存储。他们现在需要在每个请求中发送一份状态副本，而不是将会话标识符分配给客户端。像ASP和Java这样的技术栈将这个概念包装在一种叫做视图状态的东西中，但是现在非常常见的是依赖JSON Web令牌（JWT）标准。</p><p>  The goal of both approaches is to safely store data client-side, but in a way that backend services can still ensure its authenticity and integrity: it requires the use of cryptography to offer these guarantees. Despite the risks of misconfiguration (weak secrets, support for broken cryptographic algorithms) and the inherent difficulty to revoke JWTs, this is mostly a safe way to proceed.</p><p>这两种方法的目标都是在客户端安全地存储数据，但后端服务仍然可以确保其真实性和完整性：它需要使用加密技术来提供这些保证。尽管存在错误配置的风险（弱机密、对破坏的加密算法的支持）以及撤销JWT的固有困难，但这基本上是一种安全的方式。</p><p> One must not confuse the security guarantees offered by encryption and authentication in such use cases. While the encrypted data may look “secure” to uneducated eyes, the backend service cannot detect if the session data was altered by the client. The use of encryption modes like ECB can even let attackers craft a valid, arbitrary ciphertext without knowledge of the key!</p><p>在这种情况下，不能混淆加密和身份验证提供的安全保证。虽然加密数据在未受过教育的人看来可能“安全”，但后端服务无法检测会话数据是否被客户端更改。使用ECB之类的加密模式，攻击者甚至可以在不知道密钥的情况下伪造有效的任意密文！</p><p> As a demonstration of risks that could arise because of an unsafe design and implementation of client-side session code, let’s look at the technical details of the two vulnerabilities we identified in Zabbix.</p><p>为了演示由于客户端会话代码的不安全设计和实现而可能产生的风险，让我们看看我们在Zabbix中发现的两个漏洞的技术细节。</p><p>    Zabbix Agent: service running on all monitored nodes, collecting information when requested by a  Zabbix Server;</p><p>Zabbix代理：在所有受监控节点上运行的服务，在Zabbix服务器请求时收集信息；</p><p> Zabbix Server: it connects to  Zabbix Agents to collect monitoring data and raise alerts if configured thresholds are reached;</p><p>Zabbix服务器：它连接到Zabbix代理以收集监控数据，并在达到配置的阈值时发出警报；</p><p> Zabbix Proxy: associating a single  Zabbix Server to hundreds of  Zabbix Agents can be very costly and hard to deploy in some network topologies.  Zabbix Proxy instances aim to centralize the data of entire zones and report the collected data to the main  Zabbix Server;</p><p>Zabbix代理：将单个Zabbix服务器与数百个Zabbix代理相关联可能非常昂贵，在某些网络拓扑中很难部署。Zabbix代理实例旨在集中整个区域的数据，并将收集到的数据报告给Zabbix主服务器；</p><p> Zabbix Web Frontend: an interface to the  Zabbix Server, communicating over TCP and a shared database. This dashboard is used by system administrators to access the collected monitoring data and configure the  Zabbix Server (e.g. list hosts, run scripts on  Zabbix Agents).</p><p>Zabbix Web前端：与Zabbix服务器的接口，通过TCP和共享数据库进行通信。系统管理员使用此仪表板访问收集的监控数据并配置Zabbix服务器（例如，列出主机、在Zabbix代理上运行脚本）。</p><p> During December 2021, we analyzed the external attack surface of the  Zabbix Web Frontend to better understand the risks associated with the exposure of this software to untrusted networks. This effort led to the discovery of two critical vulnerabilities, CVE-2022-23131 and CVE-2022-23134.</p><p>在2021年12月期间，我们分析了ZabBiX Web前端的外部攻击表面，以更好地理解与该软件暴露于不可信网络相关的风险。这一努力导致发现了两个关键漏洞：CVE-2022-23131和CVE-2022-23134。</p><p> These findings are both related to the way Zabbix stores session data on the client-side. We will guide you through their vulnerable implementation, discuss its impact and how it could have been spotted in earlier development stages.</p><p>这些发现都与Zabbix在客户端存储会话数据的方式有关。我们将指导您完成其脆弱的实现，讨论其影响，以及在早期开发阶段如何发现它。</p><p>   The discovered vulnerabilities affect all supported  Zabbix Web Frontend releases at the time of our research, up to and including 5.4.8, 5.0.18 and 4.0.36. They do not require prior knowledge of the target, and can be effortlessly automated by attackers.</p><p>发现的漏洞影响到我们研究时支持的所有Zabbix Web前端版本，包括5.4.8、5.0.18和4.0.36。它们不需要事先了解目标，攻击者可以毫不费力地实现自动化。</p><p> We highly recommend upgrading your instances running a  Zabbix Web Frontend to 6.0.0beta2, 5.4.9, 5.0.19 or 4.0.37 to protect your infrastructure.</p><p>我们强烈建议将运行Zabbix Web前端的实例升级到6.0.0beta2、5.4.9、5.0.19或4.0.37，以保护您的基础架构。</p><p> On instances where the SAML SSO authentication is enabled, it allows bypassing the authentication and gaining administrator privileges. This access can be used by attackers to execute arbitrary commands both on the linked  Zabbix Server and  Zabbix Agent instances with CVE-2021-46088, for which exploitation code is already public. Unlike  Zabbix Agent, it is not possible to configure  Zabbix Servers to disallow the execution of commands.</p><p>在启用SAML SSO身份验证的情况下，它允许绕过身份验证并获得管理员权限。攻击者可利用该访问权限在链接的Zabbix服务器和带有CVE-2021-46088的Zabbix代理实例上执行任意命令，其攻击代码已经公开。与Zabbix代理不同，无法将Zabbix服务器配置为不允许执行命令。</p><p>   Server-side sessions are a built-in feature of PHP. The client is assigned a unique session identifier in a cookie,  PHPSESSID being the most common one, and has to transmit it with every request. On the server-side, PHP takes this value and looks for the associated session values on the filesystem ( /var/lib/php/sessions, sometimes  /tmp/) to populate the superglobal variable  $_SESSION. Session values cannot be freely modified by clients, as they only control the identifier of the session.</p><p>服务器端会话是PHP的内置功能。客户端在cookie中被分配了一个唯一的会话标识符，PHPSESSID是最常见的会话标识符，并且必须在每个请求中传输它。在服务器端，PHP获取这个值，并在文件系统（/var/lib/PHP/sessions，有时是/tmp/）上查找相关的会话值，以填充超全局变量$_session。客户端不能自由修改会话值，因为它们只控制会话的标识符。</p><p> The  Zabbix Web Frontend rolls its own client-side storage implementation based on a powerful feature of PHP, custom session handlers. By calling  session_set_save_handler() with a class implementing  SessionHandlerInterface, all subsequent accesses to  $_SESSION will be handled by methods of this class.</p><p>Zabbix Web前端基于PHP的强大功能、自定义会话处理程序推出了自己的客户端存储实现。通过使用实现SessionHandlerInterface的类调用session_set_save_handler（），对$_session的所有后续访问都将由此类的方法处理。</p><p> In their case, the goal is to map any access to  $_SESSION to cookies. For instance, indexing  $_SESSION results in a call to  CCookieSession::read();  CCookieHelper::get() is simply a wrapper around  $_COOKIE:</p><p>在他们的例子中，目标是将对$_会话的任何访问映射到cookie。例如，索引$_SESSION会导致调用CCookieSession:：read（）；CCookieHelper:：get（）只是$_COOKIE的包装器：</p><p>  &lt;?php class CCookieSession implements SessionHandlerInterface { // [...] public const COOKIE_NAME = ZBX_SESSION_NAME; // [...] public function read($session_id) { $session_data = json_decode($this-&gt;parseData(), true); // [...] foreach ($session_data as $key =&gt; $value) { CSessionHelper::set($key, $value); } // [...] protected function parseData(): string { if (CCookieHelper::has(self::COOKIE_NAME)) { return base64_decode(CCookieHelper::get(self::COOKIE_NAME)); } return &#39;&#39;; }</p><p>&lt；？php类CCookiSession实现SessionHandlerInterface{/[…]public const COOKIE_NAME=ZBX_SESSION_NAME；//[...] 公共函数read（$session_id）{$session_data=json_decode（$this-&gt；parseData（），true）；//[…]foreach（$key=&gt；$value）{csSessionHelper:：set（$key，$value）；}//[...] 受保护函数parseData（）：字符串{if（ccookieheloper:：has（self:：COOKIE_NAME））{return base64_decode（ccookieheloper:：get（self:：COOKIE_NAME））；}返回&#39&#39;; }</p><p> Zabbix developers introduced a way to authenticate the data stored in cookies and to ensure they were not tampered with. This feature is implemented in  CEncryptedCookieSession:</p><p>Zabbix开发人员引入了一种方法来验证存储在cookie中的数据，并确保它们不被篡改。此功能在CEncryptedCookieSession中实现：</p><p>  class CEncryptedCookieSession extends CCookieSession { // [...] public function extractSessionId(): ?string { // [...] if (!$this-&gt;checkSign($session_data)) { return null; } // [...] return $session_data[&#39;sessionid&#39;]; } // [...] protected function checkSign(string $data): bool { $data = json_decode($data, true); if (!is_array($data) || !array_key_exists(&#39;sign&#39;, $data)) { return false; } $session_sign = $data[&#39;sign&#39;]; unset($data[&#39;sign&#39;]); $sign = CEncryptHelper::sign(json_encode($data)); return $session_sign &amp;&amp; $sign &amp;&amp; CEncryptHelper::checkSign($session_sign, $sign); }}</p><p>类CEncryptedCookieSession扩展了CCookieSession{/[…]公共函数extractSessionId（）：？字符串{/[…]if（！$this-&gt；checkSign（$session_data））{return null；}//[...] 返回$session_data[&#39；sessionid&#39；]}/[...] 受保护函数checkSign（string$data）：bool{$data=json_decode（$data，true）；如果（！is_array（$data）| |！array_key_存在（&#39；sign&#39；，$data））{返回false；}$session_sign=$data[&#39；sign&#39；]；未设置（$data[&#39；sign&#39；]）$sign=CEncryptHelper:：sign（json_encode（$data））；返回$session_sign&amp&amp$标志及&amp；CEncryptHelper:：checkSign（$session_sign，$sign）；}</p><p> As a side note for advanced readers, there is a big red flag here: the terms “sign[ature]” and “encrypted” are used interchangeably.  CEncryptHelper::sign() internally uses AES ECB, prone to malleability and not able to offer security guarantees about the authenticity of the data. Use of this construct also resulted in another security advisory, but it will not be detailed in this article.</p><p>作为高级读者的旁注，这里有一个巨大的危险信号：“签名”和“加密”可以互换使用。CEncryptHelper:：sign（）在内部使用AES ECB，易于延展，无法提供有关数据真实性的安全保证。这种结构的使用还带来了另一个安全建议，但本文将不详细介绍。</p><p> The method  CEncryptedCookieSession::checkSign() is only invoked in  CEncryptedCookieSession::extractSessionId(), but never in  CCookieSession methods (e.g. during access in ​​ CCookieSession::read()). The authenticity of the session is never validated when fields other than  sessionid are accessed.</p><p>方法CEncryptedCookieSession:：checkSign（）仅在CEncryptedCookieSession:：extractSessionId（）中调用，但在CCookieSession方法中（例如，在中的访问期间）从不调用​​ CCookieSession:：read（））。当访问sessionid以外的字段时，永远不会验证会话的真实性。</p><p> Since cookies are fully controlled by clients, they basically have control over the session. This is quite uncommon, and breaks most assumptions about the trustworthiness of values stored in it. It could lead to vulnerabilities in parts of the application where the session is used.</p><p>由于cookie完全由客户端控制，因此它们基本上可以控制会话。这是非常罕见的，并且打破了大多数关于存储在其中的值的可信度的假设。它可能会导致使用会话的应用程序部分存在漏洞。</p><p>   Security Assertion Markup Language (SAML) is one of the most common Single-Sign-On (SSO) standards. Implemented around XML, it allows Identity Providers (IdP, an entity with the ability to authenticate the user) to tell the Service Provider (SP, here Zabbix) who you are. You can configure the  Zabbix Web Frontend to allow user authentication over SAML, but it is not enabled by default since it requires the knowledge of the details of the identity provider. This is the most common setup for enterprise deployments.</p><p>安全断言标记语言（SAML）是最常见的单点登录（SSO）标准之一。它围绕XML实现，允许身份提供者（IdP，一个能够验证用户身份的实体）告诉服务提供者（SP，这里是Zabbix）你是谁。您可以将Zabbix Web前端配置为允许用户通过SAML进行身份验证，但默认情况下不会启用，因为它需要了解身份提供者的详细信息。这是企业部署最常见的设置。</p><p> The code related to the SAML authentication mechanism can be found in  index_sso.php. In a nutshell, its goal is to:</p><p>与SAML身份验证机制相关的代码可以在index_sso中找到。php。简而言之，其目标是：</p><p> After the user has been authenticated, validate the format and the signature of the incoming SAML payload. A session entry named  saml_data is created to remember the user&#39;s attributes;</p><p>用户经过身份验证后，验证传入SAML负载的格式和签名。创建一个名为saml_data的会话条目来记住用户&#39；个性；</p><p> If an entry named  saml_data exists in the session, extract its value and authenticate the user on Zabbix based on the value of  username_attribute.</p><p>如果会话中存在名为saml_data的条目，则提取其值，并根据username_属性的值在Zabbix上对用户进行身份验证。</p><p> As explained in the previous section,  CEncryptedCookieSession::checkSign() is never called in this file, hence the value of the session entry  saml_data[username_attribute] can be fully controlled by the client:</p><p>如前一节所述，此文件中从未调用CEncryptedCookieSession:：checkSign（），因此会话条目saml_data[用户名_属性]的值可以完全由客户端控制：</p><p>   The exploitation is straightforward, especially since the  Zabbix Web Frontend is automatically configured with a highly-privileged user named  Admin.</p><p>这种攻击非常简单，特别是因为Zabbix Web前端自动配置了名为Admin的高权限用户。</p><p>    Once authenticated as Admin on the dashboard, attackers can execute arbitrary commands on any attached  Zabbix Server, and on  Zabbix Agents if explicitly allowed in the configuration with  AllowKey=system.run[*] (non-default).</p><p>一旦在仪表板上验证为管理员，攻击者可以在任何连接的Zabbix服务器上执行任意命令，如果AllowKey=system的配置中明确允许，攻击者可以在Zabbix代理上执行任意命令。运行[*]（非默认）。</p><p>   Another occurrence of the unsafe use of the session was found in  setup.php. This script is usually run by system administrators when first deploying  Zabbix Web Frontend and later access is only allowed to authenticated and highly-privileged users.</p><p>在安装程序中发现了另一次不安全使用会话的情况。php。此脚本通常由系统管理员在首次部署Zabbix Web前端时运行，以后仅允许经过身份验证的高权限用户访问。</p><p> This page normally uses the session to keep track of the progress across the setup steps; again,  CEncryptedCookieSession::checkSign() is never called here. Crafting a session with the entry step set to 6 allows re-running the latest step of the installation process.</p><p>此页面通常使用会话来跟踪整个设置步骤的进度；同样，这里从未调用CEncryptedCookieSession:：checkSign（）。在将entry step设置为6的情况下创建会话，可以重新运行安装过程的最新步骤。</p><p> This step is really interesting for attackers, as its goal is to create the  Zabbix Web Frontend configuration file  conf/zabbix.conf.php:</p><p>这一步对攻击者来说非常有趣，因为它的目标是创建Zabbix Web前端配置文件conf/Zabbix。conf.php：</p><p>  private function stage6(): array { // [...] [1] $config = new CConfigFile($config_file_name); $config-&gt;config = [ &#39;DB&#39; =&gt; [ &#39;TYPE&#39; =&gt; $this-&gt;getConfig(&#39;DB_TYPE&#39;), &#39;SERVER&#39; =&gt; $this-&gt;getConfig(&#39;DB_SERVER&#39;), &#39;PORT&#39; =&gt; $this-&gt;getConfig(&#39;DB_PORT&#39;), &#39;DATABASE&#39; =&gt; $this-&gt;getConfig(&#39;DB_DATABASE&#39;), // [...] ] + $db_creds_config + $vault_config, // [...] ]; $error = false; // [...] [2] $db_connect = $this-&gt;dbConnect($db_user, $db_pass); $is_superadmin = (CWebUser::$data &amp;&amp; CWebUser::getType() == USER_TYPE_SUPER_ADMIN); $session_key_update_failed = ($db_connect &amp;&amp; !$is_superadmin) ? !CEncryptHelper::updateKey(CEncryptHelper::generateKey()) : false; if (!$db_connect || $session_key_update_failed) { // [...] return $this-&gt;stage2(); } // [...] if (!$config-&gt;save()) { // [...]</p><p>私有函数stage6（）：数组{/[…][1] $config=new CConfigFile（$config\u file\u name）$配置-&gt；config=[&#39；DB&#39；=&gt；[&#39；TYPE&#39；=&gt；$this-&gt；getConfig（&#39；DB#u TYPE&#39；）&#39;服务器&#39=&gt$这个-&gt；getConfig（&#39；DB#U服务器&#39；）&#39;39号港口=&gt$这个-&gt；getConfig（&#39；DB#U端口&#39；）&#39;数据库&#39=&gt$这个-&gt；getConfig（&#39；DB#U数据库&#39；），//[...] ] + $db_creds_config+$vault_config，//[…]$error=false；//[...] [2] $db_connect=$this-&gt；dbConnect（$db_user，$db_pass）$is_superadmin=（CWebUser:：$data&amp；CWebUser:：getType（）==USER_TYPE_SUPER_ADMIN）$session_key_update_failed=（$db_connect&amp；！$is_superadmin）！CEncryptHelper:：updateKey（CEncryptHelper:：generateKey（））：false；如果（！$db_connect | |$session_key_update_失败）{/[…]退回$this-&gt；stage2（）；}//[...] 如果（！$config-&gt；save（））{/[…]</p><p> At  [1], a new  CConfigFile object is created to store and validate the new configuration values. The method  CSetupWizard::getConfig() is simply a wrapper around the current session, hence these values are fully controlled by the attacker.</p><p>在[1]中，将创建一个新的CConfigFile对象来存储和验证新的配置值。方法CSetupWizard:：getConfig（）只是当前会话的包装器，因此这些值完全由攻击者控制。</p><p> At  [2], the code tries to identify if the new database configuration is valid by attempting a connection to it. As this code is only supposed to be called during the initial setup process, when user accounts and database settings like the encryption key are not yet provisioned, attackers with control over the session will be able to go through the various checks.</p><p>在[2]处，代码试图通过尝试连接到新数据库配置来确定其是否有效。由于该代码只应在初始设置过程中调用，当用户帐户和数据库设置（如加密密钥）尚未设置时，控制会话的攻击者将能够通过各种检查。</p><p> As a result, existing configuration files can be overridden by attackers even if the  Zabbix Web Frontend instance is already in a working state. By pointing to a database under their control, attackers can then gain access to the dashboard with a highly-privileged account:</p><p>因此，即使Zabbix Web前端实例已经处于工作状态，攻击者也可以覆盖现有的配置文件。通过指向其控制下的数据库，攻击者可以使用高度特权的帐户访问仪表板：</p><p>  It is important to understand that this access cannot be used to reach  Zabbix Agents deployed on the network: the  Zabbix Web Frontend and the  Zabbix Server have to both use the same database to be able to communicate. It could still be possible to chain it with a code execution vulnerability on the web dashboard to gain control of the database and pivot on the network.</p><p>重要的是要理解，这种访问不能用于访问部署在网络上的Zabbix代理：Zabbix Web前端和Zabbix服务器都必须使用相同的数据库才能进行通信。仍有可能将其与web仪表板上的代码执行漏洞相关联，以获得对数据库的控制，并在网络上转向。</p><p> Other exploitation scenarios are possible in non-hardened or old environments. For instance, PHP’s MySQL client implements the   LOAD DATA LOCAL statement, but now  disabled by default for 3 years. Another lead could be the presence of calls to  file_exists() with a fully-controlled parameter when validating the database configuration, which is known to be a security risk because of potentially dangerous scheme wrappers like  phar://.</p><p>在未加固或旧环境中，也可能存在其他利用场景。例如，PHP的MySQL客户端实现了LOAD DATA LOCAL语句，但现在默认情况下禁用了3年。另一个原因可能是，在验证数据库配置时，存在对带有完全受控参数的文件_exists（）的调用，这是一个已知的安全风险，因为存在潜在的危险方案包装，如phar://。</p><p>    An additional signature field is introduced in the SSO authentication flow to prevent users from altering the SAML attributes stored in the session ( 0395828a)</p><p>SSO身份验证流中引入了一个附加的签名字段，以防止用户更改存储在会话（0395828a）中的SAML属性</p><p> The way session cookies are authenticated is now done using an HMAC construct instead of AES ECB ( eea1f70a).</p><p>会话cookie的身份验证方式现在使用HMAC构造而不是AES ECB（eea1f70a）完成。</p><p> The setup process now bails out earlier if the instance is already installed and the current user does not have the  Super Administrator role ( 20943ae3).</p><p>如果实例已安装且当前用户没有超级管理员角色（20943ae3），安装过程现在会提前退出。</p><p> They also took the decision to not enforce cookie signature checks: the main drawback of this approach is that new features relying on the session can introduce a similar vulnerability if the call to  CEncryptedCookieSession::checkSign() is forgotten. There is also no way to detect potential security regressions.</p><p>他们还决定不强制执行cookie签名检查：这种方法的主要缺点是，如果忘记了对CEncryptedCookieSession:：checkSign（）的调用，依赖会话的新功能可能会引入类似的漏洞。也没有办法检测潜在的安全倒退。</p><p>      In this article we introduced common security issues when implementing client-side session storage. As a case study, we described high-severity vulnerabilities that we discovered in Zabbix, a popular open-source monitoring platform. The vulnerabilities CVE-2022-23131 and CVE-2022-23134, both with the same root cause, can lead to a bypass of authentication and enable remote attackers to execute arbitrary code on a targeted server instance.</p><p>在本文中，我们介绍了在实现客户端会话存储时常见的安全问题。作为一个案例研究，我们描述了在流行的开源监控平台Zabbix中发现的高严重性漏洞。具有相同根源的漏洞CVE-2022-23131和CVE-2022-23134可导致绕过身份验证，并使远程攻击者能够在目标服务器实例上执行任意代码。</p><p> When writing and reviewing code related to important security features, it is easy to make the same assumptions as the original developer who introduced the vulnerability. Here, there were no integration tests related to the client-side session storage that could have spotted this behavior.</p><p>在编写和审查与重要安全功能相关的代码时，很容易做出与引入该漏洞的原始开发人员相同的假设。在这里，没有任何与客户端会话存储相关的集成测试能够发现这种行为。</p><p> Always provide access to sensible services with extended internal accesses (e.g. orchestration, monitoring) over VPNs or a restricted set of IP addresses, harden filesystem permissions to prevent unintended changes, remove setup scripts, etc.</p><p>始终通过VPN或一组受限IP地址的扩展内部访问（如编排、监控）提供对合理服务的访问，强化文件系统权限以防止意外更改，删除安装脚本等。</p><p> We would like to thank the Zabbix maintainers for their responsiveness and robust disclosure process.</p><p>我们要感谢Zabbix维护人员的响应能力和强大的披露流程。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/案例/">#案例</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/case/">#case</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zabbix/">#zabbix</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>