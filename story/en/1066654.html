<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在铁锈中重写GNU Coreutils Rewriting the GNU Coreutils in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rewriting the GNU Coreutils in Rust<br/>在铁锈中重写GNU Coreutils </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-18 13:59:16</div><div class="page_narrow text-break page_content"><p>Benefits for LWN subscribers The primary benefit from  subscribing to LWN is helping to keep us publishing, but, beyond that, subscribers get immediate access to all site content and access to a number of extra site features. Please sign up today!</p><p>LWN订阅者订阅LWN的主要福利有助于让我们出版，但是，超出该订户可以立即访问所有网站内容并访问多个额外站点功能。请立即注册！</p><p>   As movement toward memory-safe languages, and  Rust in particular, continues togrow, it is worth looking atone of the larger scale efforts to port C code that has existed for decadesto Rust. The  uutils project aims torewrite all of the individual utilities included in the  GNU Coreutils project inRust. Originally created by JordiBoggiano in 2013, the project aims to provide drop-inreplacements for the Coreutils programs, addingthe data-race protection and memory safety that Rust provides.</p><p>   作为对存储器安全语言的运动，特别是RUDE，继续剧集，值得寻找对DECADESTO RUST存在的C代码的更大规模努力。 UUTILS项目旨在托管GNU Coreutils项目冻结中包含的所有个人公用事业。最初由2013年由Jordiboggiano创建，该项目旨在为Coreutils计划提供掉落，添加Rust提供的数据竞争保护和内存安全性。</p><p> Many readers will be familiar with the Coreutils project. Itincludes the basic file, process, and text manipulation programs that areexpected to exist on every GNU-based operating system. The Coreutilsproject was created to consolidate three sets of tools that were previously offeredseparately, Fileutils, Textutils, and Shellutils, along with some othermiscellaneous utilities. Many of the programs that areincluded in the project, such as  rm,  du,  ls,and  cat, have been around for multiple decades and, though other  implementations exist, theseutilities are not available for platforms like Windows in their original form.</p><p> 许多读者将熟悉Coreutils项目。 IINCLUDES在每个基于GNU的操作系统上都存在于存在的基本文件，过程和文本操作程序。 CoreutilsProject是创建的，以巩固以前提供的三组工具，以前提供的Fileutils，Textutils和Shultutils以及一些其他的实用程序。许多在项目中被列入的项目，例如RM，DU，LS和CAT，几十年来，虽然存在其他实现，但是智能行为不适用于其原始形式的窗口等平台。</p><p> Collectively, the Coreutils programs are seen as low-hanging fruit wherea working Rust-based version can be produced in a reasonable amount oftime. The requirements for each utility are clear and many of the them areconceptually straightforward, although that&#39;s not to suggest that the workis easy. While a lot of progress has been made to get uutilsinto a usable state, it will take some time for it to reach thestability and maturity of Coreutils.</p><p> 总的来说，Coreutils计划被视为低悬挂的水果，可以在合理的时间内生产基于Rust的版本。每用公用事业的要求都很清楚，它们的许多它们被抑制了直接，虽然不是建议工作容易的工作。虽然已经取得了很大的进步来获得UUTILSINTO一个可用的国家，但它需要一些时间来达到Coreutils的灵感和成熟。</p><p> The use of Rust for thisproject will help to speed this process along since a huge swathe ofpossible memory errors and other undefined behavior is eliminatedentirely. It also opens the door to the use of efficient, race-freemultithreading which has the potential to speed up some of the programsunder certain conditions. The uutils rewrite also provides an opportunity to not justreimplement Coreutils but to also enhance the functionality of some ofthe utilities to yield a better user experience, while maintainingcompatibility with the GNU versions. For example, feature requests thathave long been  rejectedin the Coreutils project, like adding a progress bar option forutilities like  mv and  cp, are currently being  entertained inthis Rust rewrite.</p><p> Fore for TheProject的使用将有助于加速这一过程，因为巨大的斯科什的内存错误和其他未定义的行为是消除的。它还打开了使用高效，种族 - 弗解的门，这有可能加快某些条件下的一些程序。 UUTILS重写还提供了不提供JustreImplement Coreutils的机会，而是还可以增强一些公用事业公司的功能，以产生更好的用户体验，同时维护与GNU版本的载玻片。例如，Hond Lended in Coreutils项目的功能请求，例如添加像MV和CP这样的进度条选项特性，当前正在娱乐Inthis Rust Rewrite。</p><p>  On the project&#39;s GitHubpage, a  table can be foundwith the utilities divided into three columns: &#34;Done&#34;,&#34;Semi-Done&#34;, and &#34;To-Do&#34;. At the time of this writing, only 23 of the 106utilities being worked on are not yet in the &#34;Done&#34; column, with 16 of themmarked as &#34;Semi-Done&#34; and seven under the &#34;To-Do&#34; column. The utilities under&#34;To-Do&#34; have either not been worked on at all or are currently undergoing theirinitial implementation (like with   pr and   chcon). Thosein the &#34;Semi-Done&#34; column are missing options that have not yet beenimplemented, or their behavior is slightly different from their GNUcounterparts in certain situations. For example:</p><p>  在项目中＆＃39; s githubpage，一张表可以向公用事业分为三列：＆＃34; DONE＆＃34;，＆＃34;半完成＆＃34;和＆＃34; to-do＆＃ 34;在这份写作时，只有23个工作中的23个尚未在＆＃34中工作; Done＆＃34;列，有16个标记为＆＃34;半完成＆＃34;和＃34下的七个;待办事项＆＃34;柱子。 ＆＃34下的实用程序;待办事项＆＃34;完全没有工作或目前正在接受自动化实施（如PR和CHCON）。那些＆＃34;半成品＆＃34;列是缺少尚未实现的选项，或者它们的行为与某些情况下的GNucounterPart略有不同。例如：</p><p> Several utilities do not support non-UTF-8 arguments, although this islargely being mitigated by migrating from  getopts to  clap for command-line argumentparsing.</p><p> 几个实用程序不支持非UTF-8参数，尽管通过从Getopts迁移到Comment-Line ArgumentParsing的拍摄时，这是可缓解的。 </p><p> It is important to keep in mind that just because a program is marked as&#34;Done&#34; doesn&#39;t mean that all of the tests are passing or that the utility isas performant or memory-efficient as the GNU version. For example, thereare open issues to  improve theperformance of  factor (roughly 5x slower) and   sort(between 1.5x to 6x slower). In some other cases, the uutils versions are fasterthan their GNU equivalents. An example is the  cp utility in whicha measurable performance improvement has been  reported,primarily due to the use of the   sendfile()and   copy_file_range()system calls, which are not being used in the GNU version despite several proposals to do so.</p><p>重要的是要记住，只是因为程序被标记为＆＃34; Done＆＃34; DON＆＃39; t意味着所有测试都通过或者将实用程序ISAS执行或记忆效率为GNU版本。例如，临时开放问题以改善因子（大约5倍较慢）和排序（1.5倍至6倍）的性能。在其他某些情况下，UUTILS版本将更加迅速为其GNU等价物。一个例子是报告了可测量的性能改进的CP实用程序，主要是由于使用SendFile（）和Copy_file_Range（）系统调用，这在GNU版本中不在GNU版本中进行了几个提案。</p><p> At the moment, only 142 of 624 tests in the Coreutils test suite arepassing compared to around 546 tests passing with the GNU version. However, it should be noted that many of the errors are due todifferences in the output of the commands.</p><p> 目前，在Coreutils测试套件中只有142个测试套件与GNU版本的约546个测试相比。但是，应该指出的是，许多错误都是命令输出中的到来的atfferents。</p><p> A separate  tablealso exists to show all of the platforms and architectures that the uutilsproject currently supports. The major operating systems (Linux, macOS, andWindows) are well accounted for across various architectures althoughquite a few utilities are currently not building on Windows. FreeBSD,NetBSD, and Android also compile most binaries except for a handful of utilities including  chroot, uptime,  uname,  stat,  who, andothers. The rows for Redox OS, Solaris, WebAssembly, and Fuchsia arecurrently all blank, which reflects the lower priority assigned to thoseplatforms at the moment.</p><p> 存在一个单独的TableAlems，以显示UutilsProject当前支持的所有平台和架构。主要的操作系统（Linux，MacOS，AndWindows）很好地占各种架构，但是几个实用程序目前无法在Windows上构建。 FreeBSD，NetBSD和Android还编译大多数二进制文件，除了包括Chroot，正常运行时间，统一，统计数据，谁，andothers等少数公用事业。 redox操作系统，solaris，webassembly和fuchsia的行常常所有空白，这反映了目前分配给OpenPlatforms的较低优先级。</p><p> The uutils project, currently at version 0.0.6, has already been packaged inthe repositories for various Linux distributions and packagingsystems. Notably, Sylvestre Ledru, a director at Mozilla and prolificcontributor to the Debian and Ubuntu projects, has  ledthe way in getting the project  packaged for Debian as analternative to the GNU Coreutils. Its current state is deemed good enoughto get a system with GNOME up and running, install a thousand of the mostpopular Debian packages, and to build Firefox, the Linux kernel, andLLVM/Clang. Additionally, uutils is present in the  repositories for ArchLinux (Community),  Homebrewfor macOS,and the  ExherboLinux distribution.</p><p> 目前在0.0.6版本的Uutils项目已经包装了各种Linux发行版和Packagingsystems的储藏库。值得注意的是，Mozilla和Debian和Ubuntu项目的Devian和Propioxtributor的董事Sylvestre Ledru导致了让Debian的项目作为Analternation ove GNU Coreutils。它的当前状态被视为好的enugeNo获得一个带有Gnome的系统，始终安装了一千个大多数Debian包，并建立Firefox，Linux内核，Andllvm / clang。此外，UUTILS存在于archlinux（社区），rewbel的ke和exherbolinux分布的存储库中。</p><p>  An important aspect of the uutils project to be aware of is itslicensing. All of the utilities in the project are licensedunder the permissive MIT License, instead of the GPLv3 license of GNUCoreutils. This potentially makes it more attractive for use in places where software licensed with GPLv3 is not adopted due to its restrictionson  Tivoization amongother things. The decision to use the MIT License is not without its critics; somewho commented in a  GitHub issue aboutthe choice would rather see a copyleft license applied to a project ofthis sort.</p><p>  UUTILS项目的一个重要方面要意识到是它的兴奋。该项目中的所有实用程序都是许可的许可，而是允许麻省理工学院许可证，而不是GNUcoreutils的GPLv3许可证。这可能使它在利用在彼此的限制性统一化而没有采用GPLV3许可的地方使用更具吸引力。使用麻省理工学院执照的决定并非没有批评者;有些关于选择的GitHub问题评论了，宁可看到应用于该项目的项目的Copyleft许可证。</p><p> The main criticism echoes arguments over FOSS licensing in the past:a non-copyleft license is harmful to the freedoms of end userssince it allows a person or organization to incorporate any part of theproject into a device or in the distribution of other software withoutproviding the source code so it is impossible tostudy, change, or improve it.There is also a concern that the license choice is being made to maximizeRust usage without regard for other effects; replacing GPL-licensed tools withalternatives under a more-permissive license is seen by some as a step backward.</p><p> 主要批评过去呼应了对福斯许可的论据过去：非Copyleft许可证对最终用户的自由有害它允许一个人或组织将任何部分纳入设备或其他软件的分发而没有提出源代码所以这是不可能的扭曲，改变或改善它。也令人担忧了许可选择，无需其他效果就可以获得最大化的使用;在一个更宽容的许可证下，用一些逐步倒退，在更加允许的许可证下替换GPL-许可的工具。</p><p>  The best way to follow the development of the uutils project is throughits GitHub repository andofficial  Discord server.Details on how to get started contributing to the project can be found in a documentthat is included in the repository.</p><p>  遵循Uutils项目的开发的最佳方法是贯通GitHub存储库andofficial discord server.deTails如何在文档中找到如何在RocuiteThat中找到贡献。 </p><p> A lot of work remains to be done to get uutils into aproduction-ready state. The project has been positioned as a good way get into Rustdevelopment and there is a  listof issues for newcomers as a place to begin. Thecurrent focus of the project appears to be full compatibility with the GNUCoreutils and improving the test coverage before tackling otherproblems. Things like removing unnecessary dependencies, improvingperformance, and decreasing memory use are better suited to beingaddressed after the compatibility issues have been ironed out.</p><p>很多工作仍有待完成，以便将UUTILS进入淡化就绪状态。该项目已定位为一种良好的方式进入RustDevelopment，并且新人作为开始的地方有一个问题。该项目的焦点似乎与GNUcoreutils完全兼容，并在解决其他问题之前提高测试覆盖范围。在兼容性问题熨烫之后，删除不必要的依赖关系，改进性能和降低内存使用的东西更适合在兼容。</p><p>     ( Log in to post comments)</p><p>     （ 登录后发表评论）</p><p>  One thing I&#39;d love for a new and more modern coreutils: io_uring support everywhere. There&#39;s already a cp fork that supposedly does great ( https://wheybags.com/blog/wcp.html), but when ls-ing a bazillion files on HDD, it screams for io_uring to get into the head of that elevator algorithm. Same with tar! (Even if tar isn&#39;t part of coreutils.)</p><p>  一件事，我喜欢新的更现代的内核：IO_调节到处都是支持。已经有一个cp fork的cp fork，据说是很棒的（https://wheybags.com/blog/wcp.html），但是当在硬盘上的一个bazillion文件时，它尖叫用于io_uring才进入头部那个电梯算法。同样的焦油！ （即使是Coreutils的Tar ISN＆＃39;）</p><p> io_uring everywhere to take care of the async I/O, and work-stealing thread pools on every for loop for the computation.   Now that languages like Rust are making thread-safety practically the default, it is getting a bit silly to iterate over items with only one core while the other 7 or 15 watch.  Legacy tools are being very innefficient with both, currently. Even git is criminally underthreaded and often blocking on serial I/O.   Though that is slowly being improved, the software has not kept up with the silicon, and that is because the abstractions we had made it too hard.   Hail the new languages and the bloated libraries like Tokio. They compile to megabytes of statically linked copies, but boy is it nice to have a modern and fast runtime underneath instead of all the barely-reentrant-half-the-time and definitely blocking POSIX legacy!</p><p> IO_调节到处都在照顾ASYNC I / O，以及每个用于计算的循环的工作窃取线程池。现在，像生锈这样的语言实际上是默认的，它有点愚蠢地迭代，只有一个核心迭代，而另一个核心在其他7或15手表中。目前，遗留工具与两者都非常融入。甚至git甚至是犯罪的核心，通常在序列I / O上阻塞。虽然这一点慢慢得到改善，但该软件并没有与硅保持一致，这是因为我们已经让它变得太难了。欢呼新语言和像Tokio这样的臃肿的库。他们编制了统计链接副本的兆字节，但男孩很高兴在下面拥有现代和快速的运行时，而不是所有的勉强重击 - 半时间，绝对阻止POSIX遗产！</p><p> In ls doing all those stat() and systemcalls are way way heavier than any CPU processing.  You can use several threads but they are blocking each other out to access the same hardware resource, and remember that switching thread is not cheap at all, so in the end you are likely to end up with a multicore version of ls that is also way slower and has much much more complex code that is also more error prone.</p><p> 在LS中，执行所有这些stat（）和systemcalls比任何CPU处理都重视。您可以使用多个线程，但它们互相阻止以访问相同的硬件资源，并记住切换线程根本不便宜，所以最终您可能最终有一个多芯版本的LS较慢，并且具有更多复杂的代码，也容易出错。</p><p> I think the point of using io_uring was not try to use mulitiple cores in user space, but to allow kernel to do stat IO operations in parallel. On both SSD and HDD it should be 10x faster.</p><p> 我认为使用IO_调节的点不是尝试在用户空间中使用Mulitiple核心，而是允许内核并行执行STAT IO操作。在SSD和HDD上，它应该更快地为10倍。</p><p>  &gt; remember that switching thread is not cheap at all  This isn&#39;t really true in this day and age. It used to be quite expensive, but that&#39;s no longer the case (in the common case). Of course it&#39;s still more expensive than not doing it (assuming that you cannot do anything productive with that parallelism), but that&#39;s neither here nor there.  Anyway, the point of io_uring is avoiding traversing the userland&lt;-&gt;kernel boundary unless absolutely required because *THAT* is expensive.  More generally, I&#39;d also challenge your assertion that accessing the hardware in a multithreaded fashion doesn&#39;t have gains. Sure, it might not do much for spinning rust, but SSDs can certainly handle multiple non-interfering I/O operations.</p><p>  ＆gt;请记住，在这一天和年龄的时代，切换线程并不便宜。它曾经是相当昂贵的，但它不再是这种情况（在常见的情况下）。当然它＆＃39; s还比不做的更贵（假设你不能用那个并行性做出任何提高的东西），但这既不是在这里也没有。无论如何，IO_uring的点避免了遍历userland＆lt;  - ＆gt;内核边界，除非是绝对需要的，因为* *昂贵。更一般地，我也挑战了您以多线程时尚访问硬件的断言，并在多线程中获得了收益。当然，纺丝生锈可能无法做些多数人，但SSD肯定可以处理多个无干扰的I / O操作。 </p><p> (Apologies for the self-reply.)  Note also that parallelizing I/O can actually also help with the latency incurred between userland and the actual device latency. The more commands you can queue ahead of time, the more commands the device can go through in a rapid fire fashion -- even in the case where no actual parallel fetching/writing can happen on the device itself.</p><p>（为自我回复道歉。）还要注意，并行化I / O实际上还可以帮助使用屏幕域和实际设备延迟之间产生的延迟。您可以提前排队的命令越多，即使在设备本身上没有发生实际并行捕获/写入的情况下，设备可以通过快速消防方式越多。</p><p> And if you scattergun 10 requests at one hdd, the kernel tries to re-order them to minimise the overall time - it should spot if two are close together, and read them one after the other in the right order, etc etc.</p><p> 如果您在一个硬盘上散射10请求，内核将尝试重新定位它们以最小化整个时间 - 如果两个靠近一起，则应该点击它们，并以正确的顺序等地读取它们。</p><p> Not just the kernel - all modern storage devices also reorder requests to minimise the overall time. Every level in the stack below the application benefits from having deep queues; the only reason to not issue all the I/O you can at once is that you might not be able to handle the responses as fast as they come in. Otherwise, you might as well queue up as much I/O as you can keep track of; the kernel will do its re-ordering, and the device can reorder anything from 31 commands upwards to maximise throughput.</p><p> 不仅仅是内核 - 所有现代存储设备还会重新排序请求以最小化整个时间。堆栈中的每个级别低于申请的效益都有深队员;不发布所有I / O的唯一原因是您可以立即发出所有I / O的原因是您可能无法在进入时尽可能快地处理响应。否则，您可能会像可以保留的那样队列踪迹;内核将重新订购，设备可以从31个命令向上重新排序，以最大化吞吐量。</p><p>  &gt; Anyway, the point of io_uring is avoiding traversing the userland&lt;-&gt;kernel boundary unless absolutely required because *THAT* is expensive.  That is certainly a part of the point, but not the entire point. Probably more important than that is to be able to do issue many I/Os in parallel, ie., it finally gives Linux usable, performant async I/O. This is required if you want to drive modern SSDs fast, but also for many small files on a HDD. When I implemented io_uring support in plocate, that was the big killer; being able to issue 256 stat()s at once and watch the kernel reorder them into one big head sweep, as opposed to jittering back and forth over the disk. (You&#39;ll see a similar thing when ls-ing or cp-ing many (small) files.) Syscall overhead didn&#39;t play into it at all; in fact, nearly all the gains were realized in the prototype implementation where I called io_uring_enter() once for every stat, ie., no reduction in syscall overhead at all.</p><p>  ＆gt;无论如何，IO_uring的点避免了遍历userland＆lt;  - ＆gt;内核边界，除非是绝对需要的，因为* *昂贵。这肯定是一部分的一部分，但不是整个点。可能更重要的是能够并行地发出许多I / O，即。，它最终提供Linux可用，表演异步I / O.如果您想快速驱动现代SSD，也需要在HDD上驾驶现代SSD。当我在庞大中实施了IO_调整的支持时，这是大杀手;能够立即发出256个stat（）s，并观看内核将它们重新排序到一个大头扫描中，而不是在磁盘上来回抖动。 （你＆＃39; ll在ls-ing或cp-ing许多（小）文件时看到类似的东西。）Syscall开销并没有参加它;事实上，几乎所有的收益都是在原型实现中实现的，其中我叫做IO_URAP_ENTER（）一次，即每个数据，即。，根本没有减少SYSCALL开销。</p><p> You&#39;re right. I was being a bit oblique I suppose... One of the advantages is the ability to avoid the syscall overhead of all of select(), epoll() etc. ... which means that it&#39;s a lot cheaper to just queue up IO. :)</p><p> 你＆＃39;右转。我认为我是有点斜的......其中一个优点是避免所有SELECT（），ePOLL（）等的SYSCALL开端的能力。这意味着它＆＃39; SA LOT更便宜队列up io。 :)</p><p>  it is getting a bit silly to iterate over items with only one core while the other 7 or 15 watch.</p><p>  在其他7或15手表中，只有一个核心迭代物品，迭代物品正在愚蠢。</p><p> Only if that program is the only process running! Especially with utilities like this, you may not assume you have the whole CPU to yourself. Sometimes it is true, usually not.</p><p> 只有那个程序是唯一运行的进程！特别是与这样的公用事业，您可能不会以为您自己拥有整个CPU。有时它是真的，通常不是。 </p><p> True, but can&#39;t the utility also increase its CPU nice value while keeping the I/O niceness low to reflect that the parallelism is mainly about I/O than CPU utilization?</p><p>真实，但可以＆＃39; t该实用程序还增加了CPU很好的价值，同时保持I / O质量低，以反映并行性主要是关于I / O而不是CPU利用率？</p><p> Why should a utility that is I/O-bound and only uses minimal CPU time increase the CPU nice value? Such a utility should have a low CPU-nice value such that in case it needs the CPU (for a very short time) to issue the next IO operation it can do so and make the most efficient use of the available IO bandwidth. For other tasks it should not matter whether the few msec of CPU time needed are nice or non-nice, but for the utility it certainly matters whether it has to wait for the CPU or not.  And of course, high nice values are for background tasks where the user is not waiting for the output. If I run a core utility from the shell, I want to have the result now and I do not care whether a background task has to wait.</p><p> 为什么一个I / O绑定的实用程序，只使用最小的CPU时间增加CPU很好的值？这样的实用程序应该具有低CPU  - 漂亮的价值，以便在它需要CPU（非常短的时间）以发出下一个IO操作，它可以这样做，并最有效地使用可用的IO带宽。对于其他任务，无论需要的CPU时间的少数款待是不好的，但对于该实用程序，但它肯定是它是否必须等待CPU而不是。当然，高漂亮的值是用于用户不等待输出的背景任务。如果我从shell运行核心实用程序，我现在想要得到结果，我不关心背景任务是否必须等待。</p><p>  Posted Jun 9, 2021 18:09 UTC (Wed) by  Cyberax ( ✭ supporter ✭, #52523) [ Link]</p><p>  发表于2021年6月9日，2011年18:09 UTC（周三）由Cyber​​ax（✭支持者✭，＃52523）[链接]</p><p>  It should be pretty trivial to add a switch or an environment variable to restrict concurrency for the cases where you don&#39;t want it.</p><p>  添加交换机或环境变量应该非常琐碎，以限制您不希望它的情况的案例并发。</p><p> Except you&#39;re changing the default API. You need to add a switch to enable concurrency instead. And then you&#39;re dumping all the cost of this new feature on the people who want improved performance (fine), but who probably won&#39;t realise this option is available ... :-)</p><p> 除了你和＃39;重新改变默认API。您需要添加一个交换机以启用并发性。然后你＆＃39;重新倾倒这个新功能的所有成本，他们想要改善性能（细腻），但可能赢得了＆＃39; t意识到这个选项可用... :-)</p><p> It is funny how it was said that advances in CPU design had hit a wall. You couldn&#39;t increase clock frequency anymore and the only way to squeeze more computing power out of a CPU was to increase the number of cores. But this was a big problem, because it required software to be rewritten to increase parallelism, and we all know the massive inertia built in in the software industry. And now, when someone comes up with a genuine improvement (a language that advertises built-in thread safety), people start complaining that the programs hog the CPU.</p><p> 这是有趣的，据说CPU设计的进步袭击了墙壁。您可以＆＃39; t增加时钟频率，并且挤出CPU更多计算电源的唯一方法是增加核心的数量。但这是一个很大的问题，因为它需要重写软件来增加并行性，我们都知道软件行业内置的大型惯性。现在，当有人出现真正的改进时（一种宣传内置线程安全的语言），人们开始抱怨程序患上CPU。</p><p> This is not a negligible distinction.  Similarly, Rust does not trap integer overflows (except in signed types in non-release builds, i.e. unit tests), so does not prevent such bugs. Complacency around bugs the Rust compiler permits is encouraged by neglect as part of the Holy Mission to drive Rust into universal enterprise use. (&#34;Rewrite It in Rust&#34; has lately been repudiated as official policy of Rust advocacy, for reasons, but uutils seems to have missed the memo.)  When bugs do trap, such as array indexing errors, the resulting panic cannot be presumed to clean up properly before exiting. This sort of thing is hard to get right, and only comes with maturity. Coreutils probably still have bugs of their own, but they are manifestly bugs we have found we can live with.  All of the core utilities, and many others, could be switched over to build with a C++ compiler and then incrementally modernized with overwhelmingly smaller effort than a wholesale rewrite, at much less risk of introducing new bugs, and without abandoning those targets LLVM poorly serves. No Holy Mission drives such activity, so we see it happen with resounding success in Gcc and Gdb, but not yet in less active projects, or in more hidebound ones like PosgreSQL, SQLite, Git, Systemd, the BSDs, or Linux.  There is more than one way to get memory safety without compromising performance. Rust offers one way. Modern C++ practice, writing at a level of abstraction that confines risky operations to trusted libraries, is another. As such libraries are needed anyway, the cost is small. In effect, one places the trust in such libraries that Rust users place in their compiler and in audited &#34;unsafe&#34; blocks in their corresponding libraries.  It could be seen as tragic when wholly new projects, like Pipewire, Vulkan, and Wayland, are coded in archaic, bug-prone C for no defensible reason; but they can anyway be redeemed starting with a 1-line change to their build script.</p><p> 这不是一个可忽略的区别。同样，RURD不会陷入整数溢出（在非发布构建中的签名类型除外，即单元测试），因此不会阻止此类错误。虚张全满来围绕错误，通过忽视作为圣使命的一部分，以促进普通企业使用的一部分，鼓励生锈编译允许。 （＆＃34;在Rust＆＃34中重写它;最近被拒绝为Rust倡导的官方政策，因为原因，但Uutils似乎错过了备忘录。）当错误做陷阱时，例如数组索引错误，所产生的恐慌在退出前不能被假定正确清理。这种事情很难正确，只有成熟。 Coreutils可能仍然有自己的错误，但他们表明我们发现我们可以忍受的错误。所有核心实用程序以及许多其他核心实用程序都可以转换为使用C ++编译器构建，然后随着批发重写而逐渐变小的努力逐渐变得越来越多，在介绍新错误的风险，并且在不放弃那些目标LLVM的情况下的风险。没有神圣的使命推动了这样的活动，因此我们看到它发生在GCC和GDB中的响亮成功，但尚未在不太活动的项目中，或者在Posgresql，SQLite，Git，Systemd，BSD或Linux中的更多隐藏项目中。在不影响性能的情况下，有多种方法可以获得内存安全。铁锈提供一种方式。现代C ++练习，在一个抽象水平上写作，将危险的操作限制在信任库中，是另一个。无论如何需要这种图书馆，成本很小。实际上，一个在这些库中的信任居住在他们的编译器中和审计＆＃34中生锈的用户的数据库;不安全＆＃34;它们相应的库中的块。它可以被视为悲剧，当时的新项目，如pipewire，vulkan和wayland，都是在古代的，错误的错误中被编码，无可辩驳的原因;但是，无论如何，他们可以以1行的改变开始兑换到他们的构建脚本。 </p><p> Perhaps if you spent as much time doing this work which you claim is so trivial, rather than slagging off people who are shipping code that I can use, you&#39;d have more of a case.</p><p>也许如果你花了尽可能多的时间做这项工作，你声称是如此微不足道，而不是脱离我可以使用的运输代码的人，你＆＃39; d更多的情况。</p><p> Not interested in slagging anyone off, thanks.  Unfortunate choices are unfortunate, including choices that generate unnecessary extra work; but as none of them make extra work for me, I happily coexist. You?</p><p> 谢谢，对任何人脱离任何人，谢谢。不幸的选择是不幸的，包括产生不必要的额外工作的选择;但由于他们都没有为我做出额外的工作，我很高兴共存。你？</p><p>  &gt; (&#34;Rewrite It in Rust&#34; has lately been repudiated as official policy of Rust advocacy, for reasons, but uutils seems to have missed the memo.)  Or they found the Rust benefits worth it regardless of advocacy. Your scorn is unwarranted.</p><p>  ＆gt; （＆＃34;在Rust＆＃34中重写它;最近被视为官方宣传的官方政策，原因，但Uutils似乎错过了备忘录。）或者他们发现无论宣传如何，他们都发现了不值得的生锈利益。你的蔑视是无人责任的。</p><p> If you read scorn, you read wrong.  Rust is manifestly a better language than C for any use where it works at all. But it is not the only, and often enough not the wisest choice. Everyone chooses for their own reasons, and wisdom may come too late, but late is better than never.</p><p> 如果你读得以蔑视，你读错了。对于任何用途，Rust表现出比C更好的语言。但这不是唯一的，通常足够最聪明的选择。每个人都选择他们自己的原因，智慧可能会太晚，但晚来比从未好。</p><p> &gt; If you read scorn, you read wrong.  I wasn&#39;t the only who read it that way. Couple of examples:  &#34;Complacency around bugs the Rust compiler permits is encouraged by neglect as part of the Holy Mission to drive Rust into universal enterprise use&#34;  Sounds like a conspiracy with no evidence cited.  &#34;No Holy Mission drives such activity&#34;  Sounds scornful to me. If you didn&#39;t intend to be read that way, you should rephrase these.</p><p> ＆gt;如果你读得以蔑视，你读错了。我不是那样读它的唯一读它。几个例子：＆＃34;围绕错误的自满来忽略漏洞的漏洞编译允许作为圣务任务的一部分，以便驾驶普通企业使用＆＃34;听起来像阴谋，没有证据。 ＆＃34;没有神圣的使命驱动此类活动＆＃34;听起来很嘲笑我。如果你没有打算阅读那样，你应该改写这些。</p><p>  &gt; But it is not the only, and often enough not the wisest choice. Sadly today they are precisely  one language suitable for writing safe low-level code. Well… one and half, essentially: Rust and “GCC&#39;s C with set of flags Linus insisted on being added to GCC”. C++ is flat-out unsuitable.</p><p>  ＆gt;但这不是唯一的，通常足够最聪明的选择。可悲的是，他们正是一种适合写入安全低级代码的一种语言。嗯......一个半，基本上：生锈和“GCC”和第39页; S C一套Linus Linus被坚持被添加到GCC“。 C ++净空不合适。</p><p> One?  Did everyone suddenly forget about Ada and it’s sinking Spark? These two have been in use in mission critical work for decades.</p><p> 一？每个人都突然忘记了Ada，它正在沉没火花吗？这两者已经在关键经济作品中使用了几十年。 </p><p>  You are the first simultaneous Rust promoter and C apologist I have encountered. You might be all alone in the world.</p><p>您是我遇到的第一个同时锈的启动子和C人体医师。你可能是世界各地的。</p><p> Posted Jun 12, 2021 23:22 UTC (Sat) by  Cyberax ( ✭ supporter ✭, #52523) [ Link]</p><p> 发表于6月12日，2021 23:22 UTC（SAT）由Cyber​​ax（✭支持者✭，＃52523）[链接]</p><p>  Why? C is a de-facto systems language (duh), and Rust is the only modern-ish alternative. I believe that C++ can be used as well, but it has way too many drawbacks to justify rewrite of low-level systems in C++.</p><p>  为什么？ C是一个事实上的系统语言（DUH），RUDR是唯一的现代替代品。我相信也可以使用C ++，但它有太多的缺点来证明在C ++中的低级系统的重写。</p><p>  &gt; All of the core utilities, and many others, could be switched over to build with a C++ compiler and then incrementally modernized with overwhelmingly smaller effort than a wholesale rewrite,  Great plan on paper. The reasons why this does not work in practice are well known and have been detailed in about every single article about Rust.  - While much safer than C, even the &#34;most modern&#34; C++ is not as safe as Rust [1]  - Different C++ programmers seem to have different opinions about &#34;modernity&#34; (and everything C++?) &#34;There is more than one way to do it&#34;, famous last words.  - Similarly, there is no simple tool or set of rules to detect unsafe/old C and tell when such a safety effort is &#34;done&#34;. With Rust you know that safety is done when it compiles and all the unsafe blocks have been very carefully review. In C/C++ there is instead a patchwork of external checkers [2] with varying and overlapping coverage, rules and false positives.   - For the above reasons,</p><p>  ＆gt;所有核心实用程序以及许多其他核心实用程序都可以转换为使用C ++编译器构建，然后随着批发重写，纸上的巨大计划逐渐变得越来越努力。在实践中不起作用的原因是众所周知的，并详述了关于生锈的每篇文章。 - 虽然比c更安全，甚至是＆＃34;最现代化的＆＃34; C ++与Rust [1]一样安全[1]  - 不同的C ++程序员似乎有不同的意见＆＃34;现代性＆＃34; （以及一切c ++？）＆＃34;有多种方式来做它＆＃34;着名的最后一句话。 - 类似地，没有简单的工具或一组规则来检测不安全/旧的c，并告诉何时这样的安全努力＆＃34;完成＆＃34;通过Rust，您知道在编译时，安全完成安全性，所有不安全的块都非常仔细地审查。在C / C ++中，还有外部检查器[2]的拼凑而成，具有不同且重叠的覆盖范围，规则和误报。 - 为了上述原因，</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lwn.net/Articles/857599/">https://lwn.net/Articles/857599/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gnu/">#gnu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>