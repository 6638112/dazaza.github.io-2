<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Enkits：用于创建并行程序的C和C ++任务调度程序 enkiTS: A C and C++ Task Scheduler for creating parallel programs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">enkiTS: A C and C++ Task Scheduler for creating parallel programs<br/>Enkits：用于创建并行程序的C和C ++任务调度程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 10:10:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/e3ad7b086174e765cfc6374152ff5b2b.png"><img src="http://img2.diglog.com/img/2021/4/e3ad7b086174e765cfc6374152ff5b2b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A permissively licensed C and C++ Task Scheduler for creating parallel programs. Requires C++11 support.</p><p>允许许可的C和C ++任务调度程序，用于创建并行程序。需要C ++ 11支持。</p><p> The primary goal of enkiTS is to help developers create programs which handle both data and task level parallelism to utilize the full performance of multicore CPUs, whilst being lightweight (only a small amount of code) and easy to use.</p><p> Enkits的主要目标是帮助开发人员创建处理数据和任务级并行性的程序，以利用多核CPU的全部性能，同时轻量级（仅限少量代码）和易于使用。</p><p>     enkiTS is primarily developed on x64 and x86 Intel architectures on MS Windows, with well tested support for Linux and somewhat less frequently tested support on Mac OS and ARM Android.</p><p>     Enkits主要在MS Windows上的X64和X86 Intel架构开发，具有对Linux的良好测试支持，并且在Mac OS和Arm Android上的频率频率不太频繁地支持。</p><p>     Building enkiTS is simple, just add the files in enkiTS/src to your build system (_c.* files can be ignored if you only need C++ interface), and add enkiTS/src to your include path. Unix / Linux builds will require the pthreads library.</p><p>     构建Enkits很简单，只需将Enkit / SRC中的文件添加到构建系统（_C. *如果您只需要C ++接口，则可以忽略文件，并将Enkit / SRC添加到Cromply Path。 UNIX / Linux构建将需要pthreads库。</p><p> For cmake, on Windows / Mac OS X / Linux with cmake installed, open a prompt in the enkiTS directory and:</p><p> 对于CMake，在安装CMake的Windows / Mac OS X / Linux上，在Enkits目录中打开提示：</p><p>   Lightweight - enkiTS is designed to be lean so you can use it anywhere easily, and understand it.</p><p>   轻量级 -  Enkits设计为精益，因此您可以轻松地在任何地方使用它，并了解它。</p><p> Fast, then scalable - enkiTS is designed for consumer devices first, so performance on a low number of threads is important, followed by scalability.</p><p> 快速，然后可扩展 -  Enkits首先为消费者设备设计，因此在较低数量的线程上的性能很重要，然后是可扩展性。 </p><p> Braided parallelism - enkiTS can issue tasks from another task as well as from the thread which created the Task System, and has a simple task interface for both data parallel and task parallelism.</p><p>编织并行性 -  Enkits可以从另一个任务中发出任务以及从创建任务系统的线程中发出任务，并具有一个简单的任务界面，用于数据并行和任务并行性。</p><p>  Can pin tasks to a given thread - enkiTS can schedule a task which will only be run on the specified thread.</p><p>  可以将针对给定的线程引脚 -  Enkits可以安排仅在指定的线程上运行的任务。</p><p> Can set task priorities - Up to 5 task priorities can be configured via define ENKITS_TASK_PRIORITIES_NUM (defaults to 3). Higher priority tasks are run before lower priority ones.</p><p> 可以通过define enkits_task_priorities_num（默认为3）来配置最多5项任务优先级。在低优先级之前运行更高的优先任务。</p><p> Can register external threads to use with enkiTS - Can configure enkiTS with numExternalTaskThreads which can be registered to use with the enkiTS API.</p><p> 可以注册外部线程要与Enkits一起使用 - 可以使用NumexternAltASKThreads配置Enkits，可以注册与EnkitS API一起使用。</p><p>   NEW  Completion Actions - can perform an action on task completion. This avoids the expensive action of adding the task to the scheduler, and can be used to safely delete a completed task. See  example/CompletionAction.cpp and  example/CompletionAction_c.c</p><p>   新的完成操作 - 可以对任务完成执行操作。这避免了将任务添加到调度程序的昂贵动作，并且可用于安全地删除已完成的任务。请参见示例/ complediveAction.cpp和example / complediveAction_c.c</p><p>    # include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS;  // define a task set, can ignore range if we only do one thing struct ParallelTaskSet : enki::ITaskSet {  void  ExecuteRange( enki::TaskSetPartition range_,  uint32_t threadnum_ ) override {   // do something here, can issue tasks with g_TS }}; int  main( int argc,  const  char * argv[]) { g_TS. Initialize(); ParallelTaskSet task;   // default constructor has a set size of 1 g_TS. AddTaskSetToPipe( &amp;task );   // wait for task set (running tasks if they exist) since we  &#39;ve just added it and it has no range we &#39;ll likely run it. g_TS. WaitforTask( &amp;task );  return  0;}</p><p>    ＃包括＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; //定义任务集，如果我们只做一件事struct strationtaskset }; int main（int argc，const char * argv []）{g_ts。初始化（）;并行曲线任务; //默认构造函数的设置大小为1 g_ts。 Addtasksettopipe（＆amp;任务）; //等待任务集（如果存在运行任务，如果它们存在），因为我们刚刚添加了它，它没有范围我们＆＃39; ll可能会运行它。 G_TS。助人的陪伴（＆amp;任务）;返回0;}</p><p>   # include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS; int  main( int argc,  const  char * argv[]) { g_TS. Initialize(); enki::TaskSet  task(  1, []( enki::TaskSetPartition range_,  uint32_t threadnum_ ) {   // do something here } ); g_TS. AddTaskSetToPipe( &amp;task ); g_TS. WaitforTask( &amp;task );  return  0;}</p><p>   ＃包括＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; int main（int argc，const char * argv []）{g_ts。初始化（）; enki :: taskset任务（1，[]（enki :: tasksetpartition _，uint32_t threadnum_）{//在这里做某事}）; G_TS。 Addtasksettopipe（＆amp;任务）; G_TS。助人的陪伴（＆amp;任务）;返回0;} </p><p>   // See full example in Priorities.cpp# include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS; struct ExampleTask : enki::ITaskSet{  ExampleTask( ) { m_SetSize = size_; }  void  ExecuteRange( enki::TaskSetPartition range_,  uint32_t threadnum_ ) override {   // See full example in Priorities.cpp }};  // This example demonstrates how to run a long running task alongside tasks  // which must complete as early as possible using priorities. int  main( int argc,  const  char * argv[]){ g_TS. Initialize(); ExampleTask  lowPriorityTask(  10 ); lowPriorityTask. m_Priority = enki::TASK_PRIORITY_LOW; ExampleTask  highPriorityTask(  1 ); highPriorityTask. m_Priority = enki::TASK_PRIORITY_HIGH; g_TS. AddTaskSetToPipe( &amp;lowPriorityTask );  for(  int task =  0; task &lt;  10; ++task ) {   // run high priority tasks g_TS. AddTaskSetToPipe( &amp;highPriorityTask );   // wait for task but only run tasks of the same priority or higher on this thread g_TS. WaitforTask( &amp;highPriorityTask, highPriorityTask. m_Priority ); }   // wait for low priority task, run any tasks on this thread whilst waiting g_TS. WaitforTask( &amp;lowPriorityTask );  return  0;}</p><p>//查看优先级的完整举例.cpp＃contely＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; struct exampletask：enki :: itaskset {exampletask（）{m_setsize = size_; void Executerange（enki :: tasksetpartition _，uint32_t threadnum_）覆盖{//查看优先级的完整示例.cpp}}; //此示例演示了如何运行长时间运行的任务以及使用优先级尽早完成的任务//。 int main（int argc，const char * argv []）{g_ts。初始化（）; Exampletask LowPriorityTask（10）; LowPriorityTask。 m_priority = enki :: task_priority_low; Exampletask HighPriorityTask（1）;高级别托斯购物。 m_priority = enki :: task_priority_high; G_TS。 Addtaskstettopipe（＆amp; lowprioritytask）; for（int task = 0;任务＆lt; 10; ++任务）{//运行高优先级任务G_TS。 AddTaskstettopipe（＆amp; HighPriorityTask）; //等待任务，但仅在此线程G_TS上运行相同优先级或更高的任务。助人的陪伴（＆amp;高级别，高级别托斯购物。m_priority）;等待低优先级任务，在等待G_TS时运行此线程上的任何任务。助人的陪伴（＆amp; lowprioritytask）;返回0;}</p><p>   # include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS;  // define a task set, can ignore range if we only do one thing struct PinnedTask : enki::IPinnedTask {  void  Execute() override {   // do something here, can issue tasks with g_TS }}; int  main( int argc,  const  char * argv[]) { g_TS. Initialize(); PinnedTask task;   //default constructor sets thread for pinned task to 0 (main thread) g_TS. AddPinnedTask( &amp;task );   // RunPinnedTasks must be called on main thread to run any pinned tasks for that thread.   // Tasking threads automatically do this in their task loop. g_TS. RunPinnedTasks();   // wait for task set (running tasks if they exist)   // since we&#39;ve just added it and it has no range we&#39;ll likely run it. g_TS. WaitforTask( &amp;task );  return  0;}</p><p>   ＃包括＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; //定义任务集，如果我们只做一件事struct pinnedtask：enki :: ipinnedtask {void execute（）override {//做某事，可以发布与g_ts}}的任务}}}; int main（int argc，const char * argv []）{g_ts。初始化（）; PinnedTask任务; //默认构造函数将固定任务的线程设置为0（主线程）G_TS。 addpinnedtask（＆amp;任务）; // runpinnedtasks必须在主线程上调用以运行该线程的任何固定任务。 //任务线程在任务循环中自动执行此操作。 G_TS。 runpinnedtasks（）; //等待任务集（如果存在运行任务）//自从我们＆＃39;刚刚添加了它，它没有范围我们＆＃39; ll可能会运行它。 G_TS。助人的陪伴（＆amp;任务）;返回0;}</p><p>   # include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS;  // define a task set, can ignore range if we only do one thing struct TaskA : enki::ITaskSet {  void  ExecuteRange( enki::TaskSetPartition range_,  uint32_t threadnum_ ) override {   // do something here, can issue tasks with g_TS }}; struct TaskB : enki::ITaskSet { enki::Dependency m_Dependency;  void  ExecuteRange( enki::TaskSetPartition range_,  uint32_t threadnum_ ) override {   // do something here, can issue tasks with g_TS }}; int  main( int argc,  const  char * argv[]) { g_TS. Initialize();   // set dependencies once (can set more than one if needed). TaskA taskA; TaskB taskB; taskB. SetDependency( taskB. m_Dependency, &amp;taskA ); g_TS. AddTaskSetToPipe( &amp;taskA );   // add first task g_TS. WaitforTask( &amp;taskB );   // wait for last  return  0;}</p><p>   ＃包括＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; //定义任务集，如果我们只做一件事struct taska：enki :: iTaskset {void executerange（enki :: tasksetpartition范围_，uint32_t threadnum_）override {//在这里做某事，可以用g_ts发布任务} }; struct taskb：enki :: itaskset {enki :: decindency m_dependency; void Executerange（enki :: tasksetpartition范围_，uint32_t threadnum_）覆盖{//在这里做某事，可以使用g_ts}}; int main（int argc，const char * argv []）{g_ts。初始化（）; //设置依赖项一次（如果需要，可以设置多个）。 Taska Taska; TaskB TaskB;任务。 setDependency（taskb。m_dependency，＆amp; taska）; G_TS。 Addtasksettopipe（＆amp; taska）; //添加第一个任务g_ts。助人的陪伴（＆amp; taskb）; //等待最后返回0;}</p><p>   # include   &#34;TaskScheduler.h &#34;enki::TaskScheduler g_TS; struct ParallelTaskSet : ITaskSet{  void  ExecuteRange( enki::TaskSetPartition range_,  uint32_t threadnum_ ) override {   // Do something }}; void  threadFunction(){ g_TS. RegisterExternalTaskThread();   // sleep for a while instead of doing something such as file IO  std::this_thread::sleep_for(  std::chrono::milliseconds( num_ *  100 ) ); ParallelTaskSet task; g_TS. AddTaskSetToPipe( &amp;task ); g_TS. WaitforTask( &amp;task); g_TS. DeRegisterExternalTaskThread();} int  main( int argc,  const  char * argv[]){ enki::TaskSchedulerConfig config; config. numExternalTaskThreads =  1;   // we have one extra external thread g_TS. Initialize( config ); std::thread  exampleThread( threadFunction ); exampleThread. join();  return  0;}</p><p>   ＃包括＆＃34; taskscheduler.h＆＃34; enki :: taskscheduler g_ts; struct parallelTask​​set：ITASkSet {void Executerange（enki :: tasksetpartition范围_，uint32_t threadnum_）覆盖{// do stames}}; void threadfunction（）{g_ts。 RegisterExternAltaskThread（）; //睡一会儿而不是做一些文件io std :: thing_thread :: sleep_for（std :: chrono :: milliseconds（num_ * 100））;并行曲线任务; G_TS。 Addtasksettopipe（＆amp;任务）; G_TS。助人的陪伴（＆amp;任务）; G_TS。 deregisterexternaltaskthread（）; in int main（int argc，const char * argv []）{enki :: taskschedulerconfig config;配置。 numexternaltaskthreads = 1; //我们有一个额外的外部线程g_ts。初始化（配置）; std :: threademplethread（threadfunction）;考试。加入（）;返回0;}</p><p>  # include   &#34;TaskScheduler_c.h &#34;enkiTaskScheduler*	g_pTS; void  ParalleTaskSetFunc(  uint32_t start_,  uint32_t end_,  uint32_t threadnum_,  void* pArgs_ ) {   /* Do something here, can issue tasks with g_pTS  */} int  main( int argc,  const  char * argv[]) { enkiTaskSet* pTask; g_pTS =  enkiNewTaskScheduler();  enkiInitTaskScheduler( g_pTS );   // create a task, can re-use this to get allocation occurring on startup pTask =  enkiCreateTaskSet( g_pTS, ParalleTaskSetFunc );  enkiAddTaskSetToPipe( g_pTS, pTask);   // defaults are NULL args, setsize of 1   // wait for task set (running tasks if they exist)   // since we&#39;ve just added it and it has no range we&#39;ll likely run it.  enkiWaitForTaskSet( g_pTS, pTask );  enkiDeleteTaskSet( g_pTS, pTask );  enkiDeleteTaskScheduler( g_pTS );  return  0;}</p><p>  ＃包括＆＃34; taskscheduler_c.h＆＃34; enkitaskscheduler * g_pts; void paraltasksetsetfunc（uint32_t start_，uint32_t end_，uint32_t threadnum_，void * pargs_）{/ *在这里做某事，可以用g_pts * /} int main发出任务（int argc，const char * argv []）{enkitaskset * ptask; g_pts = enkinewtaskscheduler（）; enkiinittaskscheduler（g_pts）; //创建任务，可以重新使用它来获取在启动ptask = enkicreateaskset上发生的分配（g_pts，paralletasksetfunc）; enkiaddtasksettopipe（g_pts，ptask）; //默认值为null args，setize为1 //等待任务集（如果存在运行任务，如果它们存在）//自从我们＆＃39;刚刚添加了它，它没有范围我们＆＃39; ll可能会运行它。 enkiwaitfortaskset（g_pts，ptask）; enkideletetAskset（g_pts，ptask）; enkideletetAskscheduler（g_pts）;返回0;}</p><p>    The C++98 compatible branch has been deprecated as I&#39;m not aware of anyone needing it.</p><p>    C ++ 98兼容分支已被推翻为i＆＃39; m不知道任何需要它的人。</p><p> The user thread versions are no longer being maintained as they are no longer in use.</p><p> 用户线程版本不再被维护，因为它们不再使用。 </p><p> User thread version on Branch UserThread for running enkiTS on other tasking / threading systems, so it can be used as in other engines as well as standalone for example.</p><p>Branch上的用户线程版本userThread用于在其他任务/线程系统上运行Enkits，因此它可以用作其他引擎以及独立的独立。</p><p>   Avoyd is an abstract 6 degrees of freedom voxel game. enkiTS was developed for use in our  in-house engine powering Avoyd.</p><p>   Avoyd是一个抽象的6度自由voxel游戏。开发了Enkits用于我们内部发动机供电的Avoyd。</p><p>      Aras Pranckevičius&#39; code for his series on  Daily Path Tracer experiments with various languages.</p><p>      araspranckevičius＆＃39;他的系列代码在每日路径跟踪器实验中进行各种语言。</p><p>    This software is provided &#39;as-is&#39;, without any express or impliedwarranty. In no event will the authors be held liable for any damagesarising from the use of this software.</p><p>    此软件提供＆＃39; AS-IS＆＃39;没有任何表达或ImpliedWarranty。在任何情况下，作者将责备使用本软件的任何损坏。</p><p> Permission is granted to anyone to use this software for any purpose,including commercial applications, and to alter it and redistribute itfreely, subject to the following restrictions:</p><p> 授予任何人授予任何用于任何目的（包括商业应用程序）的软件，并改变它并重新分发的软件，而且符合以下限制：</p><p> The origin of this software must not be misrepresented; you must notclaim that you wrote the original software. If you use this softwarein a product, an acknowledgement in the product documentation would beappreciated but is not required.</p><p> 该软件的起源不得被误导;您必须违背您写的原始软件。如果在产品中使用此软件，则产品文档中的确认将是非必需的，但不需要。</p><p> Altered source versions must be plainly marked as such, and must not bemisrepresented as being the original software.</p><p> 必须明显标记更改的源版本，并且不得Bemisreprsented作为原始软件。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/dougbinks/enkiTS">https://github.com/dougbinks/enkiTS</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>