<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>文本呈现讨厌你（2019）Text Rendering Hates You (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Text Rendering Hates You (2019)<br/>文本呈现讨厌你（2019）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 20:20:58</div><div class="page_narrow text-break page_content"><p>Rendering text, how hard could it be? As it turns out, incredibly hard! To my knowledge, literally no system renders text “perfectly”. It’s all best-effort, although some efforts are more important than others.</p><p>渲染文本，有多困难？事实证明，这非常难！据我所知，几乎没有任何系统能“完美地”呈现文本。这都是最好的努力，尽管有些努力比其他努力更重要。</p><p> I’ll be assuming you want to support arbitrary text provided by users with custom fonts, colors, and styles with line-wrapping and support for text-selection. Basically the minimum required to properly display a simple rich-text document, terminal, webpage, or anything else.</p><p>我假设您希望支持用户提供的任意文本，这些文本具有自定义字体、颜色和带有换行和支持文本选择的样式。基本上是正确显示简单的富文本文档、终端、网页或其他任何内容所需的最低要求。</p><p> The overarching theme here will be: there are no consistent right answers, everything is way more important than you think, and everything affects everything else.</p><p>这里最重要的主题是：没有一致的正确答案，每件事都比你想象的重要得多，每件事都会影响其他一切。</p><p> The topics I focus on here have no particular rhyme or reason, they’re just the ones that come to mind after a few years of working on rendering in Firefox. For instance, I don’t spend much time talking about the challenges of text-segmentation or managing the different platform-specific text libraries, because I don’t look at that much.</p><p>我在这里关注的主题没有特别的韵味或理由，它们只是在Firefox中渲染几年后出现在我脑海中的主题。例如，我不会花太多时间讨论文本分割或管理不同平台特定文本库的挑战，因为我不会看太多。</p><p>  Text is complicated and english is bad at expressing these nuances. For the purpose of this document, I will try to stick to the following terms. Note that these words aren’t “right”, I just find them useful for communicating the key concepts to native english speakers who don’t have backgrounds in linguistics.</p><p>文本很复杂，英语不善于表达这些细微差别。就本文件而言，我将尽量遵守以下条款。请注意，这些词不是“正确的”，我只是觉得它们对向没有语言学背景的英语母语人士传达关键概念很有用。</p><p>  Scalar: A Unicode Scalar, the “smallest unit” unicode describes (AKA a code point).</p><p>标量：Unicode标量，Unicode描述的“最小单位”（又名代码点）。</p><p> Character: A Unicode Extended Grapheme Cluster (EGC), the “biggest unit” unicode describes (potentially composed of multiple scalars).</p><p>字符：一个Unicode扩展字集集群（EGC），Unicode描述的“最大单元”（可能由多个标量组成）。</p><p> Glyph: An atomic unit of rendering yielded by the font. Generally this will have a unique ID in the font.</p><p>字形：由字体产生的一种原子呈现单位。通常，字体中会有一个唯一的ID。</p><p> Ligature: A glyph that is made up of several scalars, and potentially even several characters (native speakers may or may not think of a ligature as multiple “characters”, but to the font it’s just one “character”).</p><p>连字：由几个标量，甚至可能是几个字符组成的字形（母语人士可能认为连字是多个“字符”，也可能不认为连字是多个“字符”，但对于字体来说，它只是一个“字符”）。</p><p>  Script: The set of glyphs that make up some language (fonts tend to implement particular scripts).</p><p>脚本：组成某种语言的一组字形（字体倾向于实现特定的脚本）。</p><p>  Color: RGB and Alpha values for fonts (alpha isn’t needed for some usecases, but it’s interesting).</p><p>颜色：字体的RGB和Alpha值（有些用例不需要Alpha，但很有趣）。</p><p> Style: Bold and Italics modifiers for fonts (hinting, aliasing, and other settings tend to also get crammed in here in practical implementations).</p><p>样式：字体的粗体和斜体修饰符（暗示、别名和其他设置在实际实现中也会被塞满）。</p><p>  Just so you have an idea for how a typical text-rendering pipeline works, here’s a quick sketch:</p><p>为了让您了解典型的文本渲染管道是如何工作的，下面是一个简单的示意图：</p><p>   Most fonts don’t actually provide every glyph in existence. There’s too many glyphs, so fonts are usually designed to only implement a particular script. End users usually don’t know or care about this, and so a robust system must  cascade into other fonts when characters aren’t available.</p><p>大多数字体实际上并没有提供所有现存的字形。字形太多，所以字体通常设计为只实现特定的脚本。最终用户通常不知道或不关心这一点，因此当字符不可用时，一个健壮的系统必须级联到其他字体中。</p><p> For instance, even though the markup of the following text doesn’t  suggest the presence of multiple fonts, drawing it correctly on all systems absolutely requires it: hello 😺 मनीष بسم 好. This is dangerously close to Step 1 (Styling) depending on the results of Step 3 (Shaping)!</p><p>例如，尽管以下文本的标记并不表示存在多种字体，但在所有系统上正确绘制它绝对需要：hello😺 मनीष بسم 好. 这与步骤1（造型）非常接近，这取决于步骤3（造型）的结果！</p><p> (Alternatively, you can take the  Noto approach and use a single Uber Font that contains every character ever. Although that means users can’t configure the font, and you can’t provide a “native” text experience to users on all platforms. But let’s assume you want the more robust solution.)</p><p>（或者，你可以采用Noto方法，使用一种包含所有字符的Uber字体。尽管这意味着用户无法配置字体，也无法在所有平台上为用户提供“原生”文本体验。但假设你想要更强大的解决方案。）</p><p> Similarly, layout requires you to know how much space each part of your text takes up, but this is only known once you shape the text! Step 2 depends on the results of Step 3?</p><p>同样，布局要求您知道文本的每个部分占用了多少空间，但这只有在您塑造文本之后才能知道！第二步取决于第三步的结果？</p><p> Shaping absolutely depends on you knowing your layout and styling, so we seem to be stuck. What do we do?</p><p>造型完全取决于你对自己的布局和造型的了解，所以我们似乎被卡住了。我们该怎么办？</p><p> First off, styling gets to cheat. Although what we  really want from a font is full glyphs, styling only needs to ask about  scalars. If a font doesn’t properly support a script it shouldn’t claim to know anything about the scalars that make up that script. So we can easily find the “best” font as follows:</p><p>首先，造型会作弊。虽然我们真正想要的字体是完整的字形，但样式设计只需要询问标量。如果字体不能正确支持脚本，它就不应该声称知道组成脚本的标量。因此，我们可以很容易地找到“最佳”字体，如下所示：</p><p> For every character (EGC) in our text, keep asking each font in our cascade if it knows about all the scalars that make up that character, and use it if it does. If we get to the end of the cascade with no providers, then we yield tofu ( 􏿽, a missing glyph indicator).</p><p>对于文本中的每个字符（EGC），不断询问级联中的每个字体是否知道组成该字符的所有标量，如果知道，就使用它。如果我们在没有供应商的情况下走到最后，那么我们就会生产豆腐（􏿽, 缺少图示符指示器）。</p><p> In the case of emoji, you’ve probably seen the failure mode of this process before! Because some emoji are actually ligatures of several simpler emoji, a font may successfully report support for the character while only yielding the components. So 🤦🏿‍♀️ may literally appear as 🤦 🏿‍ ♀ if the font is “too old” to know about the new ligature. This can also happen if your unicode implementation is “too old” to know about a character, causing the styling system to accept a partial match in the font.</p><p>在表情符号的例子中，你可能已经见过这个过程的失败模式了！因为一些表情符号实际上是几个简单表情符号的连字，所以字体可能会成功地报告对该字符的支持，同时只生成组件。所以🤦🏿‍♀️ 可能看起来像🤦 🏿‍ ♀ 如果字体“太旧”，无法了解新的连字。如果unicode实现“太旧”，无法了解字符，导致样式系统接受字体中的部分匹配，也会发生这种情况。</p><p> So now we know exactly what fonts we’ll use without looking at layout or shape (although shaping might change our colors, more on that in later sections). Can we untie layout and shape as well? Nope! Things like paragraph breaks give you a nice hard break on lines, but the only way to do wrapping is to iteratively do shaping!</p><p>因此，现在我们不需要查看布局或形状，就可以确切地知道我们将使用什么字体（尽管形状可能会改变我们的颜色，后面的部分将对此进行详细介绍）。我们能同时解开布局和形状吗？不！像段落分隔符这样的东西会让你在行上有一个很好的硬中断，但是进行包装的唯一方法是迭代地进行造型！</p><p> You have to assume that your text fits on a single line and shape it until you run out of space. At that point you can perform layout operations and figure out where to break the text and start the next line. Repeat until everything is shaped and laid out.</p><p>你必须假设你的文本只适合一行，并塑造它，直到你用完空间。在这一点上，您可以执行布局操作，并确定在何处打断文本并开始下一行。重复这个过程，直到所有的东西都成型并布置好。</p><p>  Coming from english, you might think ligatures are just fancy fluff. I mean, who  really cares if “æ” is written as “ae”? Well, as it turns out, some languages are basically entirely ligatures. For instance “ड्ड بسم” has individual characters of “ड् ड ب س م”. If you’re viewing this in a competent text-rendering system (any of the major browsers), those two strings should look  very different.</p><p>来自英语，你可能会认为连字只是花哨的绒毛。我的意思是，谁真的在乎“æ”是否写为“ae”？事实证明，有些语言基本上完全是连字。例如“ड्ड بسم“具有”的个性ड् ड بسم”。如果您在一个有能力的文本呈现系统（任何主要浏览器）中查看此内容，那么这两个字符串看起来应该非常不同。</p><p> And no: this isn’t about the difference between unicode scalars and extended grapheme clusters. If you ask a unicode-robust system (such as Swift) for the extended grapheme clusters of that string, it will spit out those 5 characters!</p><p>不：这不是unicode标量和扩展的grapheme集群之间的区别。如果你向一个unicode健壮的系统（比如Swift）询问该字符串的扩展字符集，它会吐出这5个字符！</p><p> The shape of a character depends on its neighbours:  you cannot correctly draw text character-by-character.</p><p>一个字符的形状取决于它的邻域：你不能一个字符一个字符地正确绘制文本。</p><p> Which is to say, you must use a  shaping library. The industry standard for this is  HarfBuzz, and it’s extremely hard to implement your own. Use HarfBuzz.</p><p>也就是说，你必须使用一个成形库。这方面的行业标准是HarfBuzz，要实现自己的标准非常困难。使用哈夫布兹。</p><p>  Cursive scripts frequently have their glyphs intersect to avoid seams, and that can cause you problems.</p><p>草书的字形经常相交以避免接缝，这可能会给您带来问题。</p><p> Let’s look at “मनीष منش” again. Seems fine, eh? Let’s blow it up:</p><p>让我们看看“मनीष “又来了。看起来不错吧？让我们把它炸了吧：</p><p>    If you’re in Safari or Edge, this might still look ok! If you’re in Firefox or Chrome, it looks awful, like this:</p><p>如果你在狩猎或边缘，这可能仍然看起来不错！如果你使用的是Firefox或Chrome，它看起来很糟糕，如下所示：</p><p>  The problem is that Chrome and Firefox are trying to  cheat. They ate their vegetables and properly shaped the text, but once they had glyphs they still tried to draw them individually. This mostly works fine, except for when there’s transparency and overlapping. Then you get darkening at the overlaps.</p><p>问题是Chrome和Firefox正在试图作弊。他们吃蔬菜，并正确地塑造文字，但一旦他们有了字形，他们仍然试图单独绘制。除了透明和重叠之外，这基本上可以正常工作。然后在重叠处变暗。</p><p> A “correct” implementation will draw the text to a temporary surface  without transparency and then composite that surface into the scene  with transparency. Firefox and Chrome don’t do this because it’s expensive and  usually unnecessary for the major western languages. Interestingly, they  do understand the issue, because they actually bend over backwards to specially handle this for emoji (but we’ll get to that later).</p><p>“正确”的实现会将文本绘制到没有透明度的临时曲面上，然后将该曲面合成到具有透明度的场景中。Firefox和Chrome不这么做，因为它很昂贵，而且对于主要的西方语言来说通常是不必要的。有趣的是，他们确实理解这个问题，因为他们实际上会竭尽全力专门处理emoji（但我们将在后面讨论）。</p><p>  Ok this one is  mostly a curiosity in that I’m not aware of any super-reasonable cases where this happens, but it naturally falls out of markups. Here’s two pieces of text with the same  content but different color styling:</p><p>好的，这一个主要是一个好奇，因为我不知道有任何超合理的情况下会发生这种情况，但它自然会下降的加价。以下是两段内容相同但颜色样式不同的文本：</p><p> पन्ह  पन्ह  त्र  र्च  कृक ृ  ड ्ड  न ्ह ृ े  إل ا  ب س م  ا ل ل ه</p><p>पन्ह  पन्ह  त्र  र्च  कृक ृ  ड ्ड  न ्ह ृ े  إل ا  ب س م  ا ل ل ه</p><p> पन्ह पन्ह त्र र्च कृकृ ड्ड न्हृे إلا بسم الله</p><p>पन्ह पन्ह त्र र्च कृकृ ड्ड न्हृे إلا بسم الله</p><p>     Here’s what they look like in Chrome (if using its  new layout implementation):</p><p>以下是它们在Chrome中的外观（如果使用新的布局实现）：</p><p>        I guess everyone should do what Firefox does, right? But if we zoom in, we can see that it’s doing something very janky:</p><p>我想每个人都应该像Firefox那样做，对吧？但如果我们放大，我们可以看到它正在做一些非常刺耳的事情：</p><p>   The problem is, there’s really no reasonable answer for what  should happen here. We’ve broken up a ligature with different stylings, and since the ligature is in some sense a rendering “unit” it’s reasonable to simply refuse to support this (as most do).</p><p>问题是，这里真的没有合理的答案。我们已经用不同的样式分解了一个连字，由于连字在某种意义上是一个呈现“单元”，所以拒绝支持它是合理的（就像大多数人那样）。</p><p> For whatever reason,  someone working on Firefox got really enthusiastic about trying to handle it more gracefully. The general approach is to draw the ligature multiple times with best-guess masks and different colors, which works surprisingly well!</p><p>不管出于什么原因，Firefox上的工作人员非常热衷于尝试更优雅地处理它。一般的方法是用最佳猜测面具和不同的颜色多次画连字，效果出人意料地好！</p><p> There is a  some merit in trying to support these “partial ligatures”: only shaping can know if a ligature will happen, and it can depend on system-specific fonts, so a ligature may show up where no one expected! The classic english example here is an æ ligature from a user-installed font spanning the boundary of a hyperlink.</p><p>尝试支持这些“部分连字”有一些好处：只有整形才能知道是否会发生连字，而且它可以取决于系统特定的字体，所以连字可能会出现在没有人预料到的地方！这里的经典英文示例是用户安装的字体跨越超链接边界的æ连字。</p><p> Also it kinda sucks that english can ch ange  style mid-word but cursive scripts can’t?</p><p>还有一点很糟糕，英语可以改变中间词的风格，但草书却不能？</p><p>   If you draw emoji the way the native system would, you need to disrespect the text’s color settings (except for transparency):</p><p>如果按照本机系统的方式绘制表情符号，则需要不尊重文本的颜色设置（透明度除外）：</p><p> Hello ❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 There (Black)</p><p>你好❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 那里（黑色）</p><p> Hello ❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 There (Red)</p><p>你好❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 那里（红色）</p><p> Hello ❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 There (Transparent)</p><p>你好❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 那里（透明）</p><p> Hello ❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 There (Bold)</p><p>你好❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 那里（粗体）</p><p> Hello ❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 There (Italics)</p><p>你好❤️ 😺 🎉 ™️ 🥶 😡 😈 🤟 🤟🏻 🤟🏿 有（斜体）</p><p> Emoji generally have their own native colors, and this color can even have semantic meaning, as is the case for skin-tone modifiers. More problematically: they have multiple colors!</p><p>表情符号通常有自己的本色，这种颜色甚至可以有语义意义，就像肤色修饰语一样。更麻烦的是：它们有多种颜色！</p><p> As far as I can tell, this wasn’t really a thing before emoji, and so different platforms approach this in different ways. Some provide emoji as a straight-up image (Apple), others provide emoji as  a series of single-color  layers (Microsoft).</p><p>据我所知，这在表情符号出现之前并不是一件真正的事情，所以不同的平台以不同的方式处理这件事。一些人将表情符号作为一个直接的图像提供（苹果），另一些人将表情符号作为一系列单色图层提供（微软）。</p><p> The latter approach is kinda nice because it integrates well with existing text rendering pipelines by “just” desugarring a glyph into a series of single-color glyphs, which everyone is used to working with.</p><p>后一种方法有点不错，因为它通过“仅仅”将一个glyph去糖化为一系列单色glyph，与现有的文本渲染管道很好地集成，每个人都习惯于使用这些glyph。</p><p> However that means that your style can change  repeatedly while drawing a “single” glyph. It also means that a “single” glyph can overlap itself, leading to the transparency issues discussed in an earlier section. And yet, as shown above, browsers  do properly composite the transparency for emoji!</p><p>然而，这意味着您的样式可以在绘制“单个”字形时反复更改。这也意味着一个“单一”字形可能会重叠，从而导致前面一节中讨论的透明度问题。然而，如上所示，浏览器确实正确地合成了表情符号的透明度！</p><p>  You already need to detect color glyphs and handle them specially, so it’s easy to take a special compositing path for them</p><p>您已经需要检测颜色图示符并对其进行特殊处理，因此很容易为它们采用特殊的合成路径</p><p> Cursive scripts are slightly ugly with bad transparency, but emoji are terrifying/gibberish, so extra work is justified</p><p>草书有点难看，透明度不好，但表情符号很可怕/胡言乱语，所以额外的工作是合理的</p><p>  Oh also, what does it mean to italicize or bold an emoji? Should you ignore those styles? Should you synthesize them? Who knows. 🤷‍♀️</p><p>哦，还有，将表情符号斜体化或加粗是什么意思？你应该忽略这些风格吗？你应该合成它们吗？谁知道呢。🤷‍♀️</p><p>  Yeah for whatever reason a bunch of systems secretly increase the font-size for emoji to make them look better.</p><p>是的，不管出于什么原因，很多系统都会秘密地增加表情符号的字体大小，让它们看起来更好。</p><p>  Text is really small and detailed, and it’s really important that it’s easily legible. Sounds like a job for anti-aliasing (AA)! Oh, 480p really is low resolution huh. More AA!!!</p><p>文本非常小，非常详细，而且非常重要的是它很容易阅读。听起来像是反走样（AA）的工作！哦，480p真的是低分辨率，嗯。更多AA！！！</p><p>    Greyscale-AA is the “natural” approach to anti-aliasing. The basic idea is to give partially-covered pixels partial-transparency. During composition, this will cause that pixel to be slightly tinted as if it were slightly covered, creating clearer details.</p><p>灰度AA是消除混叠的“自然”方法。其基本思想是为部分覆盖的像素提供部分透明度。在构图过程中，这将导致像素稍微着色，就像它被稍微覆盖一样，从而创建更清晰的细节。</p><p> It’s greyscale because that’s the term used for one-dimensional color, like our one-dimensional transparency (otherwise glyphs tend to be a single solid color). Also in the common case of black text on a white background, the anti-aliasing literally shows up as greyness around the edges.</p><p>它是灰度的，因为这是用于一维颜色的术语，就像我们的一维透明度（否则字形往往是单一的纯色）。同样，在白色背景上的黑色文本的常见情况下，抗锯齿会在边缘周围显示为灰色。</p><p> Subpixel-AA is a trick that abuses the common way pixels are laid out on desktop monitors. It’s more complicated than this, so if you’re really interested you should look it up, but here’s a TL;DR of the high-level concept:</p><p>亚像素AA是一种滥用桌面显示器上像素布局的常见方式的把戏。它比这更复杂，所以如果你真的感兴趣，你应该查一下，但这里有一个TL；高层概念的DR：</p><p> Your monitor’s pixels are actually three little columns of RED GREEN BLUE. If you make a pixel red you’re  kinda also making it “WHITE BLACK BLACK”. Similarly, if you make it blue, you’re making “BLACK BLACK WHITE”. In other words, by messing around with colors you can  triple your horizontal resolution and get way more details!</p><p>你的显示器的像素实际上是三小列红、绿、蓝。如果你把一个像素变成红色，你也会把它变成“黑白”。同样地，如果你把它变成蓝色，你就变成了“黑白”。换句话说，通过混淆颜色，你可以将水平分辨率提高三倍，获得更多细节！</p><p> You might think that this would look super messed up and rainbowy, but in practice it honestly works out really well (some disagree). The human brain likes to see patterns and smooth things out. That said, if you take a screenshot of subpixel-AA text you will  absolutely be able to see the colors if you resize the image, or even look at it on a monitor with a different subpixel layout. This is why screenshots of text often look really weird and bad.</p><p>你可能会认为这看起来非常混乱，像彩虹一样，但实际上效果非常好（有些人不同意）。人类的大脑喜欢看到模式并使事情变得平滑。这就是说，如果你拍摄一张亚像素AA文本的屏幕截图，如果你调整图像大小，或者甚至在不同亚像素布局的显示器上观看，你绝对能够看到颜色。这就是为什么文本截图看起来非常奇怪和糟糕的原因。</p><p> (As a total aside, the fact that this works also means that the color of an icon can accidentally change its perceived size and position, which is really annoying.)</p><p>（总的来说，这也意味着图标的颜色可能会意外地改变其感知的大小和位置，这真的很烦人。）</p><p> So subpixel-AA is a really neat hack that can significantly improve text legibility, great! But, sadly, it’s also a huge pain in the neck!</p><p>所以亚像素AA是一个非常好的黑客，可以显著提高文本的易读性，太棒了！但是，可悲的是，这也是一个巨大的颈部疼痛！</p><p> Note that regardless of the AA system you use, you can also have  subpixel glyph offsets. Although you always want your rasterized glyphs to be snapped to full pixels, the rasterization itself is for a specific subpixel offset (a value between 0 and 1).</p><p>请注意，无论使用哪种AA系统，也可以使用亚像素轮廓偏移。尽管您总是希望光栅化的图示符捕捉到完整像素，但光栅化本身适用于特定的子像素偏移（0到1之间的值）。</p><p>  If its subpixel offset was 0.5, then its rasterization would be two 50% grey pixels</p><p>如果它的亚像素偏移为0.5，那么它的光栅化将是两个50%的灰色像素</p><p>  Rasterizing glyphs is surprisingly expensive, so you really want to cache it in an atlas. But how do you cache glyph rasterizations when you’re using subpixel-offsets? Each offset is its own unique rasterization, so you’re incredibly unlikely to get cache hits like that!</p><p>栅格化图示符的成本惊人地高，所以您真的希望将其缓存在atlas中。但在使用亚像素偏移时，如何缓存轮廓光栅化？每个偏移量都有自己独特的光栅化，所以你不太可能得到这样的缓存命中率！</p><p> Quality and performance must be balanced here, and that can be done by snapping your subpixel offsets. For english text, a reasonable balance is to have no vertical subpixel precision while snapping the horizontal subpixel offset to a quarter-integer. This leaves you with only 4 subpixel-positions, which is still a big improvement in quality while allowing for a reasonable amount of caching.</p><p>质量和性能必须平衡，这可以通过捕捉亚像素偏移来实现。对于英文文本，一个合理的平衡是在将水平子像素偏移捕捉为四分之一整数时没有垂直子像素精度。这只剩下4个亚像素位置，这仍然是质量上的一大改进，同时允许合理的缓存量。</p><p>  One nice thing about greyscale-AA is that you can play a bit fast-and-loose with it, and it will degrade gracefully. For instance, if you transform a texture with text on it (scaling, rotating, or translating), it might look a bit blurry but it will look basically fine.</p><p>greyscale AA的一个优点是，你可以玩得快一点，放松一点，它会优雅地退化。例如，如果在纹理上变换文本（缩放、旋转或平移），它可能看起来有点模糊，但基本上看起来很好。</p><p> If you do the same thing with subpixel-AA, it will look terrible. The entire idea behind subpixel-AA is that you are abusing how the pixels are laid out in a display. If the pixels of the display don’t line up with the pixels of your texture, the red and blue edges will be clearly visible!</p><p>如果你用亚像素AA做同样的事情，它看起来会很糟糕。亚像素AA背后的整个想法是，你在滥用显示器中像素的布局方式。如果显示的像素与纹理的像素不一致，则红色和蓝色边缘将清晰可见！</p><p> One might think that the “fix” for this is to just rerasterize the glyphs in their new location. And indeed, if the transform is static, this can work. But if the transform is an  animation this will actually look  even worse. This is actually a really common browser bug: if we  ever fail to detect that an animation is happening to some text, the characters will  jiggle as each glyph bounces around between different subpixel snappings and hints on each frame.</p><p>有人可能会认为，解决这个问题的“办法”是在新位置重新标记符号。事实上，如果转换是静态的，这是可行的。但如果变换是一个动画，这实际上看起来会更糟。这实际上是一个非常常见的浏览器错误：如果我们无法检测到某个文本正在发生动画，当每个字形在不同的子像素捕捉和每帧提示之间来回跳跃时，角色将抖动。</p><p> As a result, browsers contain several heuristics to detect things which might be animations so that they can force-disable subpixel-AA for that part of the page (and ideally even subpixel-positioning). This can be pretty hard to do reliably, because arbitrarily complex JS can drive an animation without giving any clear “heads up” to the browser.</p><p>因此，浏览器包含了几种试探法来检测可能是动画的东西，以便它们可以强制禁用页面该部分的亚像素AA（理想情况下甚至亚像素定位）。这可能很难做到可靠，因为任意复杂的JS可以驱动动画，而不给浏览器任何清晰的“提示”。</p><p> Furthermore, if partial transparency is involved, subpixel-AA is also problematic. Basically, we’re tweaking our R, G, and B channels to encode 3 transparency values (one for each subpixel), but the text itself also has a color, and the thing the text is on does to, so information easily gets lost.</p><p>此外，如果涉及部分透明度，亚像素AA也有问题。基本上，我们正在调整R、G和B通道，以编码3个透明度值（每个子像素一个），但文本本身也有一种颜色，并且文本上的内容会改变，因此信息很容易丢失。</p><p> When using greyscale-AA we have a dedicated alpha channel so nothing is ever lost. As such, browsers tend to use greyscale-AA when transparency is involved.</p><p>当使用greyscale AA时，我们有一个专用的alpha通道，因此不会丢失任何东西。因此，当涉及透明度时，浏览器倾向于使用灰度AA。</p><p> …Except Firefox. Yet again, this is a weird place where someone working on Firefox got really enthusiastic and did something complicated: Component Alpha. It turns out you can in fact properly composite subpixel-AA text, but it involves effectively having 3 extra channels dedicated to the transparency of your R, G, and B channels. Unsurprisingly, this doubles the memory footprint of text that’s composited in this way.</p><p>除了Firefox。再一次，这是一个奇怪的地方，有人在Firefox上工作非常热情，做了一些复杂的事情：组件Alpha。事实证明，你实际上可以正确地合成亚像素AA文本，但它实际上需要有3个额外的通道，专门用于R、G和B通道的透明度。不出所料，这会使以这种方式合成的文本的内存占用增加一倍。</p><p>  On newer versions of macos, subpixel-aa of text is disabled at the OS level by default</p><p>在较新版本的macos上，默认情况下在操作系统级别禁用文本的子像素aa</p><p> Chrome seems to be disabling subpixel-aa more aggressively (not sure what the exact policy is)</p><p>Chrome似乎更积极地禁用了亚像素aa（不确定具体的策略是什么）</p><p> Firefox’s new graphics backend (webrender) has abandoned Component Alpha for the sake of simplicity</p><p>Firefox的新图形后端（webrender）为了简单起见放弃了Alpha组件</p><p>  This part’s just a grab bag of little things that don’t need merit much discussion.</p><p>这部分只是一些不需要太多讨论的小东西。</p><p>  God this blows. These fonts are mostly provided by Adobe, because they got really into SVG a while ago. Sometimes you can just ignore the SVG parts (I believe the Source Code Pro font technically contains some SVG glyphs, but in practice they aren’t actually used by websites), but in general you need to implement SVG support to draw All The Fonts.</p><p>天呐，这太棒了。这些字体主要由Adobe提供，因为它们不久前就真正进入了SVG。有时候你可以忽略SVG部分（我相信源代码Pro字体在技术上包含一些SVG字形，但实际上它们并没有被网站使用），但通常你需要实现SVG支持来绘制所有字体。</p><p> Also have you heard of  Animated SVG Fonts? No? Good. I think they’re broken/unimplemented everywhere now. (Firefox randomly supported it for a while because of some enthusiastic developer.)</p><p>你听说过SVG动画字体吗？不好的我认为他们现在到处都失败了。（由于一些热心的开发者，Firefox随机支持了它一段时间。）</p><p>  If you naively respect a user’s request for a very large font (or very large zoom level), you will run into extreme memory management problems with the size of your glyph atlas, as each character may be bigger than the entire screen. There are a few ways to handle this:</p><p>如果你天真地尊重用户对超大字体（或超大缩放级别）的要求，你会在字形图谱的大小上遇到极端的内存管理问题，因为每个字符都可能比整个屏幕大。有几种方法可以解决这个问题：</p><p> Rasterize the glyph at a smaller size, and upscale during composition (easy, produces blurry edges)</p><p>在构图过程中以较小的尺寸和较高的比例栅格化轮廓（简单，产生模糊的边缘）</p><p>  It’s pretty common for folks to know that the primary direction of text can be left-to-right (english), right-to-left (arabic), or top-to-bottom (japanese).</p><p>人们通常知道文本的主要方向可以是从左到右（英语）、从右到左（阿拉伯语）或从上到下（日语）。</p><p>     On a desktop, if you drag your mouse across that text to select it, you may notice that the selection becomes discontinuous and jumpy in the middle. This is because we’re mixing left-to-right and right-to-left text in the same line, which absolutely happens all the time.</p><p>在桌面上，如果将鼠标拖动到该文本上以选择它，您可能会注意到该选择在中间变得不连续和跳跃。这是因为我们在同一行中混合了从左到右和从右到左的文本，这绝对是经常发生的。</p><p> At first dragging right  increases the selection, but then it  decreases it until it suddenly starts increasing again. This is in fact totally correct and desirable: the selection is just remaining contiguous  in the actual underlying string. This way you can correctly copy a fragment of text that spans the transition.</p><p>起初，向右拖动会增加选择，但随后会减少选择，直到它突然开始再次增加。这实际上是完全正确和可取的：选择只是在实际的底层字符串中保持连续。通过这种方式，您可以正确复制跨越转换的文本片段。</p><p> So you need to deal with that in your selection code’s hit-detection. Also you need to deal with that in your line breaking algorithm during layout.</p><p>因此，您需要在选择代码的命中检测中处理这一点。在布局过程中，你还需要在换行算法中处理这个问题。</p><p>   oh hey what? oh  لا بسم الله no 你好 1234你好</p><p>什么？哦，不你好 1234你好</p><p>    When characters are missing from fonts, it’s nice to be able to communicate to the user that this happened. This is the “tofu” glyph. Now, you can just draw a blank tofu (a rectangle) and leave it at that, but if you want to be helpful you can write out the value of the missing character so it can be debugged more easily.</p><p>当字体中缺少字符时，能够向用户传达这一情况是很好的。这是“豆腐”字形。现在，你可以只画一个空白的豆腐（一个矩形）并保留它，但是如果你想有所帮助，你可以写出缺少的字符的值，这样就可以更容易地调试它。</p><p> But, wait, we’re using text to explain that we can’t draw text? Hmm.</p><p>但是，等等，我们用文字来解释我们不能画文字？隐马尔可夫模型。</p><p> You could appeal to an assumption that the system must have a basic font that can draw 0-9 and A-F, but for those who expect to truly Destroy Their Tools With Their Tools you can do what Firefox does: the microfont!</p><p>你可以假设系统必须有一个基本的字体，可以画0-9和a-F，但是对于那些希望用工具真正破坏工具的人来说，你可以做Firefox做的事情：microfont！</p><p> Inside Firefox there’s a little hardcoded array describing one-bit pixel art of a tiny font atlas for exactly those 16 characters. So when drawing tofu, it can blit those glyphs out without worrying about fonts.</p><p>Firefox内部有一个小的硬编码数组，描述了一个小字体图集的一位像素艺术，正好对应这16个字符。所以在画豆腐的时候，它可以快速地画出那些字形，而不用担心字体。</p><p>   For high-quality fonts, stylings like  italics and  bold are provided natively, as there isn’t a simple algorithmic way to do those effects nicely.</p><p>对于高质量的字体，像斜体和粗体这样的样式是本机提供的，因为没有简单的算法可以很好地实现这些效果。</p><p> Except some fonts don’t provide those stylings, and so you need a simple algorithmic way to do those effects.</p><p>除了一些字体不提供这些样式，所以你需要一个简单的算法来实现这些效果。</p><p> Exactly how you detect and handle all of this is pretty system-specific, hairy, and outside my area of expertise, so I can’t really explain it well. I would just be digging through  Webrender’s font code.</p><p>准确地说，你是如何检测和处理这一切的，这是非常具体的系统，非常复杂，超出了我的专业领域，所以我不能很好地解释它。我只是在浏览Webrender的字体代码。</p><p> Anyway, no matter what you do, you need a  synthetic fallback. Thankfully, the implementations are actually pretty straightforward:</p><p>不管怎样，不管你做什么，你都需要一个综合的退路。谢天谢地，这些实现实际上非常简单：</p><p>   Honestly, these approaches do a pretty decent job! But users might notice that things seem “wrong” and you can do better if you put in the work.</p><p>老实说，这些方法做得相当不错！但用户可能会注意到事情似乎“不对”，如果你投入工作，你可以做得更好。</p><p>  Platform-specific bugs, optimizations, and quirks have thrived for long enough to become aesthetics. So even if you adamantly believe that certain things are ideal or important, there’s always going to be a huge group of users with different preferences. A robust text rendering system supports those different preferences (while picking reasonable defaults).</p><p>特定于平台的bug、优化和怪癖已经发展了足够长的时间，成为了美学。所以，即使你坚信某些东西是理想的或重要的，也总会有一大群用户有不同的偏好。健壮的文本呈现系统支持这些不同的首选项（同时选择合理的默认值）。</p><p> You should support system configurations, font-specific configurations, application-specific configurations, and text-run-specific configurations. You should also try to</p><p>您应该支持系统配置、字体特定配置、应用程序特定配置和文本运行特定配置。你也应该试着</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/呈现/">#呈现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rendering/">#rendering</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文本/">#文本</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>