<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Rust中编写Kubernetes CRD控制器 Writing a Kubernetes CRD Controller in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Writing a Kubernetes CRD Controller in Rust<br/>在Rust中编写Kubernetes CRD控制器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-10 13:17:37</div><div class="page_narrow text-break page_content"><p>In this post, we&#39;ll define a Kubernetes Custom Resource Definition (CRD) and then write a controller (or operator) to manage it -- all in 60 lines of Rust code.</p><p>在本文中，我们将定义一个Kubernetes自定义资源定义（CRD），然后编写一个控制器（或运算符）来管理它-全部用60行Rust代码编写。</p><p> Over the last several months, I have been writing more and more Kubernetes-specific code in Rust. Even though Kubernetes itself was written in Go, I am finding that I can typically write more concise, readable, and stable Kubernetes code in Rust. For example, I recently wrote functionally equivalent CRD controllers in Rust and in Go. The Go version was over 1700 lines long and was loaded with boilerplate and auto-generated code. The Rust version was only 127 lines long. It was much easier to understand and debug... and definitely faster to write. Here, we&#39;ll write one in just 60 lines.</p><p> 在过去的几个月中，我一直在Rust中编写越来越多的Kubernetes特定代码。尽管Kubernetes本身是用Go编写的，但我发现我通常可以在Rust中编写更简洁，可读性和稳定性更高的Kubernetes代码。例如，我最近在Rust和Go中编写了功能等效的CRD控制器。 Go版本超过1700行，并装有样板和自动生成的代码。 Rust版本只有127行。它更容易理解和调试……而且绝对更快地编写。在这里，我们仅用60行就可以写一个。</p><p>  You should have the latest stable Rust release. You&#39;ll also need  kubectl, configured to point to an existing Kubernetes cluster.</p><p>  您应该拥有最新的稳定Rust版本。您还需要配置为指向现有Kubernetes集群的kubectl。</p><p> A controller runs as a daemon process, typically inside of a Kubernetes cluster. So we&#39;ll create a new Rust program (as opposed to a library). Our aim here is to provide a basic model for writing controllers, so we won&#39;t spend time breaking things down into modules. We also won&#39;t cover things like building a Rust Docker image or creating a Deployment to run our controller. All of that is well documented elsewhere.</p><p> 控制器通常在Kubernetes集群内部作为守护进程运行。因此，我们将创建一个新的Rust程序（与库相对）。我们的目的是提供用于编写​​控制器的基本模型，因此我们不会花时间将事物分解为模块。我们还将介绍构建Rust Docker映像或创建Deployment来运行控制器的内容。所有这些都在其他地方有据可查。</p><p>   Before we start writing code, let&#39;s create two YAML files. The first is our CRD definition, and the second is an instance of that CRD. We&#39;ll create a directory in  k8s-controller/ called  docs/ and put our YAML files there.</p><p>   在开始编写代码之前，让我们创建两个YAML文件。第一个是我们的CRD定义，第二个是该CRD的实例。我们将在k8s-controller /中创建一个名为docs /的目录，并将我们的YAML文件放在此处。</p><p>  apiVersion :  apiextensions.k8s.io/v1beta1 kind :  CustomResourceDefinition metadata :  name :  books.example.technosophos.com spec :  group :  example.technosophos.com  versions :  -  name :  v1  served :  true  storage :  true  scope :  Namespaced  names :  plural :  books  singular :  book  kind :  Book</p><p>  apiVersion：apiextensions.k8s.io/v1beta1种类：CustomResourceDefinition元数据：名称：books.example.technosophos.com规格：组：example.technosophos.com版本：-名称：v1服务：真实存储：真实范围：命名空间名称：复数：单书：书的种类：书</p><p> Stepping through this file is beyond the scope of this tutorial, but you can learn all about this file format  in the official docs. (Recent versions of Kubernetes added more fields to the definition, but we&#39;re going to stick with a basic version.) A CRD is just a manifest that declares a new resource type and expresses the names that are associated with this new resource type. The full name of ours is  books.example.technosophos.com/v1.</p><p> 单步执行此文件超出了本教程的范围，但是您可以在官方文档中了解有关此文件格式的所有信息。 （Kubernetes的最新版本在定义中添加了更多字段，但我们将坚持使用基本版本。）CRD只是一个清单，用于声明新的资源类型并表示与此新资源关联的名称。类型。我们的全名是books.example.technosophos.com/v1。 </p><p>      $  kubectl  create -f docs/crd.yamlcustomresourcedefinition.apiextensions.k8s.io &#34;books.example.technosophos.com&#34; created $  kubectl  create -f docs/book.yamlbook.example.technosophos.com &#34;moby-dick&#34; created $  kubectl  delete book moby-dickbook.example.technosophos.com &#34;moby-dick&#34; deleted</p><p>$ kubectl创建-f docs / crd.yamlcustomresourcedefinition.apiextensions.k8s.io＆＃34; books.example.technosophos.com＆＃34;创建了$ kubectl create -f docs / book.yamlbook.example.technosophos.com＆＃34; moby-dick＆＃34;创建了$ kubectl删除书moby-dickbook.example.technosophos.com＆＃34; moby-dick＆＃34;已删除</p><p>   Rather than incrementally adding dependencies to our  Cargo.toml file as we go, we&#39;ll just set up all of the dependencies now. As the text progresses, we&#39;ll see how these are used.</p><p>   我们不会像现在那样向我们的Cargo.toml文件中逐步添加依赖关系，而是现在要设置所有依赖关系。随着本文的进展，我们将看到如何使用它们。</p><p> [package] name  =  &#34;k8s-controller&#34; version  =  &#34;0.1.0&#34; edition  =  &#34;2018&#34; [dependencies] kube  =  &#34;0.14.0&#34; serde  =  &#34;1.0&#34; serde_derive  =  &#34;1.0&#34; serde_json  =  &#34;1.0&#34;</p><p> [package] name =＆＃34; k8s-controller＆＃34;版本=＆＃34; 0.1.0＆＃34;版本=＆＃34; 2018＆＃34; [依赖关系] kube =＆＃34; 0.14.0＆＃34; serde =＆＃34; 1.0＆＃34; serde_derive =＆＃34; 1.0＆＃34; serde_json =＆＃34; 1.0＆＃34;</p><p> The  serde serialization libraries are likely already familiar to you. And  kube is the Kubernetes library for writing controllers. (Another library,  k8s_openapi, is useful for working with existing Kubernetes resource types, but we don&#39;t need it here)</p><p> serde序列化库可能已经为您所熟悉。而kube是用于编写控制器的Kubernetes库。 （另一个库k8s_openapi对于处理现有的Kubernetes资源类型很有用，但是我们在这里不需要它）</p><p>  The first piece of code we&#39;ll write is a struct that represents our book CRD. And the easiest way to start with that is to write the basic struct that defines the body ( spec). In our  book.yaml we had two fields in  spec:</p><p>  我们将编写的第一段代码是代表我们的书CRD的结构。最简单的方法是编写定义主体（规范）的基本结构。在book.yaml中，规范中有两个字段：</p><p>  Since we&#39;re just writing a quick example, we&#39;ll go ahead and create this struct inside of  main.rs:</p><p>  由于我们只是在编写一个简单的示例，因此我们将继续在main.rs中创建此结构：</p><p> # [ macro_use ] extern  crate  serde_derive ; // This is our new Book struct #[derive(Serialize,  Deserialize,  Clone,  Debug)] pub  struct  Book  {  pub  title :  String ,  pub  authors :  Option &lt; Vec &lt; String &gt;&gt; , } // This was the boilerplate that Cargo generated: fn  main ()  {  println! ( &#34;Hello, world!&#34; ); }</p><p> ＃[macro_use] extern crate serde_derive; //这是我们的新Book struct＃[derive（Serialize，Deserialize，Clone，Debug）] pub struct Book {pub title：String，pub authors：Option＆lt; Vec＆lt;字符串＆gt;＆gt; ，} //这是Cargo生成的样板：fn main（）{println！ （＆＃34;你好，世界！＆＃34;）; } </p><p> By making the  title a string and the  authors an  Option, we&#39;re stating that the title is required, but the authors are not. So now we have:</p><p>通过将标题设置为字符串，将作者设置为选项，我们声明标题是必需的，但作者不是必需的。现在我们有了：</p><p>  We&#39;ve also used macros to generate the Serde serializer and deserializer features as well as clone and debug support.</p><p>  我们还使用了宏来生成Serde序列化器和解串器功能以及克隆和调试支持。</p><p> If we look again at our  book.yaml, we will see that the body of the book has two sections:</p><p> 如果再次查看book.yaml，我们将看到本书的正文有两个部分：</p><p>  Some Kubernetes objects have a third section called  status. We don&#39;t need one of those.</p><p>  一些Kubernetes对象的第三部分称为状态。我们不需要其中之一。</p><p> The  kube library is aware of this  metadata/ spec/ status pattern. So it provides a generic type called  kube::api::Object that we can use to create a Kubernetes-style resource. To make our code easier to read, we&#39;ll create a type alias for this new resource type:</p><p> kube库知道此元数据/规范/状态模式。因此，它提供了一种称为kube :: api :: Object的泛型类型，可用于创建Kubernetes风格的资源。为了使我们的代码更易于阅读，我们将为此新资源类型创建类型别名：</p><p> // Describes a Kubernetes object with a Book spec and no status type  KubeBook  =  Object &lt; Book ,  Void &gt; ;</p><p> //描述具有Book规格且无状态类型的Kubernetes对象KubeBook = Object＆lt;书本，虚空＆gt; ;</p><p> A  cube::api::Object already has the  metadata section defined. But it gives us the option of adding our own  spec and  status fields. We add  Book as the spec, but we don&#39;t need a status field, so we set it to  Void.</p><p> cube :: api :: Object已经定义了元数据部分。但这使我们可以选择添加自己的规格和状态字段。我们将Book添加为规格，但是我们不需要状态字段，因此将其设置为Void。 </p><p>  # [ macro_use ] extern  crate  serde_derive ; use  kube :: api ::{ Object ,  Void }; #[derive(Serialize,  Deserialize,  Clone,  Debug)] pub  struct  Book  {  pub  title :  String ,  pub  authors :  Option &lt; Vec &lt; String &gt;&gt; , } // This is a convenience alias that describes the object we get from Kubernetes type  KubeBook  =  Object &lt; Book ,  Void &gt; ; fn  main ()  {  println! ( &#34;Hello, world!&#34; ); }</p><p>＃[macro_use] extern crate serde_derive;使用kube :: api :: {Object，Void}; ＃[derive（Serialize，Deserialize，Clone，Debug）] pub struct Book {pub title：String，pub authors：Option＆lt; Vec＆lt;字符串＆gt;＆gt; ，} //这是一个方便的别名，用于描述我们从Kubernetes获取的对象，类型为KubeBook = Object＆lt;书本，虚空＆gt; ; fn main（）{println！ （＆＃34;你好，世界！＆＃34;）; }</p><p>   Next, we&#39;ll create the controller in the  main() function. We&#39;ll take this in a few steps. First, let&#39;s load all of the information we need in order to work with Kubernetes.</p><p>   接下来，我们将在main（）函数中创建控制器。我们将分几个步骤进行。首先，让我们加载使用Kubernetes所需的所有信息。</p><p> # [ macro_use ] extern  crate  serde_derive ; use  kube ::{  api ::{ Object ,  Void ,  RawApi },  client :: APIClient ,  config , }; #[derive(Serialize,  Deserialize,  Clone,  Debug)] pub  struct  Book  {  pub  title :  String ,  pub  authors :  Option &lt; Vec &lt; String &gt;&gt; , } // This is a convenience alias that describes the object we get from Kubernetes type  KubeBook  =  Object &lt; Book ,  Void &gt; ; fn  main ()  {  // Load the kubeconfig file.  let  kubeconfig  =  config :: load_kube_config () .expect ( &#34;kubeconfig failed to load&#34; );  // Create a new client  let  client  =  APIClient :: new ( kubeconfig );  // Set a namespace. We&#39;re just hard-coding for now.  let  namespace  =  &#34;default&#34; ;  // Describe the CRD we&#39;re working with.  // This is basically the fields from our CRD definition.  let  resource  =  RawApi :: customResource ( &#34;books&#34; )  .group ( &#34;example.technosophos.com&#34; )  .within ( &amp; namespace ); }</p><p> ＃[macro_use] extern crate serde_derive;使用kube :: {api :: {Object，Void，RawApi}，client :: APIClient，config，}; ＃[derive（Serialize，Deserialize，Clone，Debug）] pub struct Book {pub title：String，pub authors：Option＆lt; Vec＆lt;字符串＆gt;＆gt; ，} //这是一个方便的别名，用于描述我们从Kubernetes获取的对象，类型为KubeBook = Object＆lt;书本，虚空＆gt; ; fn main（）{//加载kubeconfig文件。让kubeconfig = config :: load_kube_config（）.expect（＆＃34; kubeconfig无法加载＆＃34;）; //创建一个新的客户端let client = APIClient :: new（kubeconfig）; //设置名称空间。我们现在只是进行硬编码。让命名空间=＆＃34; default＆＃34; ; //描述我们正在使用的CRD。 //这基本上是我们CRD定义中的字段。 let resource = RawApi :: customResource（＆＃34; books＆＃34;）.group（＆＃34; example.technosophos.com＆＃34;）.within（＆amp; namespace）; }</p><p> If we run this program it won&#39;t do anything visible. But here&#39;s what&#39;s happening in the  main() function:</p><p> 如果我们运行此程序，它将不会做任何可见的事情。但是，这是在main（）函数中发生的事情：</p><p> First we load the  kubeconfig file (or, in cluster, read the secrets out of the volume mounts). This loads the URL to the Kubernetes API server, and also the credentials for authenticating.</p><p> 首先，我们加载kubeconfig文件（或者在集群中，从卷装载中读取机密信息）。这会将URL加载到Kubernetes API服务器，并加载用于身份验证的凭据。</p><p> Second, we create a new API client. This is the object that will communicate with the Kubernetes API server.</p><p> 其次，我们创建一个新的API客户端。这是将与Kubernetes API服务器通信的对象。</p><p> Third, we set the namespace. Kubernetes segments objects by namespaces. In a normal program, we&#39;d provide a way for the user to specify a particular namespace. But for this, we&#39;ll just use the  default built-in namespace.</p><p> 第三，我们设置名称空间。 Kubernetes按名称空间分割对象。在普通程序中，我们为用户提供了一种指定特定名称空间的方法。但是为此，我们将仅使用默认的内置名称空间。 </p><p> Forth, we are creating a  resource that describes our CRD. We&#39;ll use this in a bit to tell the informer which things it should watch for.</p><p>第四，我们正在创建描述CRD的资源。我们将用一点时间来告诉告密者它应该注意什么。</p><p> So now we have sufficient information to run operations against the Kubernetes API server for our particular namespace and watch for our particular CRD.</p><p> 因此，现在我们有足够的信息来针对特定的名称空间针对Kubernetes API服务器运行操作，并注意特定的CRD。</p><p>   In Kubernetes parlance, an  informer is a special kind of agent that watches the Kubernetes event stream and  informs the program when a particular kind of resource triggers an event. This is the heart of our controller.</p><p>   用Kubernetes的话来说，告密者是一种特殊的代理，它监视Kubernetes事件流，并在特定种类的资源触发事件时通知程序。这是我们控制者的核心。</p><p> There is a second kind of watching agent that keeps a local cache of all objects that match a type. That is called a  reflector.</p><p> 还有第二种监视代理程序，用于保留与类型匹配的所有对象的本地缓存。这就是所谓的反射器。</p><p> In our case, we&#39;re going to write an informer that tells us any time anything happens to a  Book.</p><p> 在我们的案例中，我们将编写一个告密者，该告密者会告诉我们任何时候书籍发生任何变化。</p><p> Here&#39;s the code to create an informer and then handle events as they come in:</p><p> 这是创建通知程序，然后处理事件进入时的代码：</p><p> # [ macro_use ] extern  crate  serde_derive ; use  kube ::{  api ::{ Object ,  RawApi ,  Informer ,  WatchEvent ,  Void },  client :: APIClient ,  config , }; #[derive(Serialize,  Deserialize,  Clone,  Debug)] pub  struct  Book  {  pub  title :  String ,  pub  authors :  Option &lt; Vec &lt; String &gt;&gt; , } // This is a convenience alias that describes the object we get from Kubernetes type  KubeBook  =  Object &lt; Book ,  Void &gt; ; fn  main ()  {  // Load the kubeconfig file.  let  kubeconfig  =  config :: load_kube_config () .expect ( &#34;kubeconfig failed to load&#34; );  // Create a new client  let  client  =  APIClient :: new ( kubeconfig );  // Set a namespace. We&#39;re just hard-coding for now.  let  namespace  =  &#34;default&#34; ;  // Describe the CRD we&#39;re working with.  // This is basically the fields from our CRD definition.  let  resource  =  RawApi :: customResource ( &#34;books&#34; )  .group ( &#34;example.technosophos.com&#34; )  .within ( &amp; namespace );  // Create our informer and start listening.  let  informer  =  Informer :: raw ( client ,  resource ) .init () .expect ( &#34;informer init failed&#34; );  loop  {  informer .poll () .expect ( &#34;informer poll failed&#34; );  // Now we just do something each time a new book event is triggered.  while  let  Some ( event )  =  informer .pop ()  {  handle ( event );  }  } } fn  handle ( event :  WatchEvent &lt; KubeBook &gt; )  {  println! ( &#34;Something happened to a book&#34; ) }</p><p> ＃[macro_use] extern crate serde_derive;使用kube :: {api :: {Object，RawApi，Informer，W​​atchEvent，Void}，client :: APIClient，config，}; ＃[derive（Serialize，Deserialize，Clone，Debug）] pub struct Book {pub title：String，pub authors：Option＆lt; Vec＆lt;字符串＆gt;＆gt; ，} //这是一个方便的别名，用于描述我们从Kubernetes获取的对象，类型为KubeBook = Object＆lt;书本，虚空＆gt; ; fn main（）{//加载kubeconfig文件。让kubeconfig = config :: load_kube_config（）.expect（＆＃34; kubeconfig无法加载＆＃34;）; //创建一个新的客户端let client = APIClient :: new（kubeconfig）; //设置名称空间。我们现在只是进行硬编码。让命名空间=＆＃34; default＆＃34; ; //描述我们正在使用的CRD。 //这基本上是我们CRD定义中的字段。 let resource = RawApi :: customResource（＆＃34; books＆＃34;）.group（＆＃34; example.technosophos.com＆＃34;）.within（＆amp; namespace）; //创建我们的告密者并开始收听。让notifyer = Informer :: raw（client，resource）.init（）.expect（＆＃34; informer init failed＆＃34;）;循环{notifyer .poll（）.expect（＆＃34; informer poll failed＆＃34;）; //现在，每次触发新书事件时，我们都要做一些事情。而让Some（event）= notifyer .pop（）{handle（event）; }}} fn句柄（事件：WatchEvent＆lt; KubeBook＆gt;）{println！ （＆＃34;书中发生了什么事＆＃34;）} </p><p>   This line creates a  raw informer. A raw informer is one that does not use the Kubernetes OpenAPI spec to decode its contents. Since we are using a custom CRD, we don&#39;t need the OpenAPI spec. Note that we give this informer two pieces of information:</p><p>该行创建了一个原始的告密者。原始告密者是不使用Kubernetes OpenAPI规范对其内容进行解码的告密者。由于我们使用的是自定义CRD，因此我们不需要OpenAPI规范。请注意，我们为通知者提供了两条信息：</p><p>  Based on these pieces of information, our informer will now connect to the API server and watch for any events having to do with our Book CRD. Next, we just need to tell it to keep listening for new events:</p><p>  基于这些信息，我们的通知者现在将连接到API服务器，并监视与Book CRD有关的任何事件。接下来，我们只需要告诉它继续监听新事件即可：</p><p> loop  {  informer .poll () .expect ( &#34;informer poll failed&#34; );  // Now we just do something each time a new book event is triggered.  while  let  Some ( event )  =  informer .pop ()  {  handle ( event );  } }</p><p> 循环{notifyer .poll（）.expect（＆＃34; informer poll failed＆＃34;）; //现在，每次触发新书事件时，我们都要做一些事情。而让Some（event）= notifyer .pop（）{handle（event）; }}</p><p> The above tells the informer to poll the API server. Each time a new event is queued,  pop() takes the event off of the queue and handles it. Right now, our  handle() method is unimpressive:</p><p> 上面告诉告密者轮询API服务器。每次有新事件排队时，pop（）都会将事件从队列中移出并进行处理。现在，我们的handle（）方法令人印象深刻：</p><p>  In a moment, we&#39;ll add some features to  handle(), but first let&#39;s see what happens if we run this code.</p><p>  稍后，我们将向handle（）添加一些功能，但是首先让我们看看如果运行此代码会发生什么。</p><p>   Make sure your local environment is pointed to a Kubernetes cluster! Otherwise neither  cargo run nor the  kubectl commands will work. And make sure you installed  docs/crd.yaml.</p><p>   确保您的本地环境指向Kubernetes集群！否则，货物运行和kubectl命令都将无效。并确保您安装了docs / crd.yaml。</p><p>    Finished dev [unoptimized + debuginfo] target(s) in 7.28s Running `target/debug/k8s-controller`Something happened to a bookSomething happened to a book</p><p>    在7.28秒内完成dev [unoptimized + debuginfo]目标运行`target / debug / k8s-controller`书中发生了某事书中发生了某事 </p><p>   In this last part, we&#39;ll add a few more things to the  handle() function. Here is our revised function:</p><p>在最后一部分中，我们将向handle（）函数添加更多内容。这是我们修改后的功能：</p><p> fn  handle ( event :  WatchEvent &lt; KubeBook &gt; )  {  // This will receive events each time something   match  event  {  WatchEvent :: Added ( book )  =&gt;  {  println! ( &#34;Added a book {} with title &#39;{}&#39;&#34; ,  book .metadata.name ,  book .spec.title )  },  WatchEvent :: Deleted ( book )  =&gt;  {  println! ( &#34;Deleted a book {}&#34; ,  book .metadata.name )  }  _  =&gt;  {  println! ( &#34;another event&#34; )  }  } }</p><p> fn handle（event：WatchEvent＆lt; KubeBook＆gt;）{//每当匹配事件{WatchEvent ::添加的（book）=＆gt; {println！ （＆＃34;添加了书名{}的书{}，书.metadata.name，书.spec.title）}，WatchEvent :: Deleted（book）=＆gt ; {println！ （＆＃34;删除了图书{}＆＃34;，图书.metadata.name）} _ =＆gt; {println！ （＆＃34;另一个事件＆＃34;）}}}</p><p> Note that the function signature says that it accepts  event: WatchEvent&lt;KubeBook&gt;. The informer emits  WatchEvent objects that describe the event that it saw occur on the Kubernetes event stream. When we created the informer, we told it to watch for a  resource that described our Book CRD.</p><p> 注意，函数签名表示它接受事件：WatchEvent＆lt; KubeBook＆gt;。通知程序发出WatchEvent对象，该对象描述了它在Kubernetes事件流上看到的事件。创建告密者时，我们告诉它要注意描述我们Book CRD的资源。</p><p> So each time a  WatchEvent is emitted, it will wrap a  KubeBook object. And that object will represent our earlier YAML definition:</p><p> 因此，每次发出WatchEvent时，它都会包装一个KubeBook对象。该对象将代表我们之前的YAML定义：</p><p>  So we would expect that a  KubeBook would have fields like  book.metadata.name or  book.spec.title. In fact, all of the attributes of our earlier  Book struct will be available on the  book.spec.</p><p>  因此，我们希望KubeBook将具有诸如book.metadata.name或book.spec.title之类的字段。实际上，我们之前的Book结构的所有属性都可以在book.spec中获得。</p><p>   In our code above, we use a  match event to match on one of the events. We explicitly handle  Added and  Deleted, but capture the others with the generic  _ match.</p><p>   在上面的代码中，我们使用match事件匹配其中一个事件。我们显式处理添加和删除，但使用通用_匹配捕获其他对象。</p><p> To look closer, in the first match we simply print out the book object&#39;s name and the book&#39;s title:</p><p> 为了更仔细地观察，在第一个匹配项中，我们只需打印出书对象的名称和书名： </p><p>  If we execute  cargo run and then run our  kubectl create and  kubectl delete commands again, this is what we&#39;ll see in the  cargo run output:</p><p>如果执行货物运行，然后再次运行kubectl create和kubectl delete命令，这将在货物运行输出中看到：</p><p> $ cargo run Compiling k8s-controller v0.1.0 (/Users/technosophos/Code/Rust/k8s-controller) Finished dev [unoptimized + debuginfo] target(s) in 5.33s Running `target/debug/k8s-controller`Added a book moby-dick with title &#39;Moby Dick&#39;Deleted a book moby-dick</p><p> $ cargo run编译k8s-controller v0.1.0（/ Users / technosophos / Code / Rust / k8s-controller）在5.33s中完成dev [unoptimized + debuginfo]目标运行`target / debug / k8s-controller`已添加标题为Moby Dick的书Moby-Dick，删除了书Moby-Dick</p><p> From here, we might want to do something more sophisticated with our informer. Or we might want to instead experiment with a reflector. But in just 60 lines of code we have written an entire Kubernetes controller with a Custom Resource Definition!</p><p> 从这里开始，我们可能想对我们的告密者做一些更复杂的事情。或者，我们可能想尝试使用反射器。但是仅用60行代码，我们就编写了带有自定义资源定义的整个Kubernetes控制器！</p><p>  That is all there is to creating a basic controller. Unlike writing these in Go, you won&#39;t need special code generators or annotations, gobs of boilerplate code, and complex configurations. This is a fast and efficient way of creating new Kubernetes controllers.</p><p>  这就是创建基本控制器的全部。与用Go编写这些代码不同，您不需要特殊的代码生成器或注释，样板代码的小样以及复杂的配置。这是创建新的Kubernetes控制器的快速有效的方法。</p><p> From here, you may want to take a closer look at the  kube library&#39;s documentation. There are dozens of examples, and the API itself is well documented. You will also learn how to work with built-in Kubernetes types (also an easy thing to do).</p><p> 从这里开始，您可能需要仔细阅读kube库的文档。有数十个示例，并且API本身已有充分的文档记录。您还将学习如何使用内置的Kubernetes类型（这也是一件容易的事）。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://technosophos.com/2019/08/07/writing-a-kubernetes-controller-in-rust.html">http://technosophos.com/2019/08/07/writing-a-kubernetes-controller-in-rust.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/crd/">#crd</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>