<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>构建Homelab虚拟机服务器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">构建Homelab虚拟机服务器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 12:10:23</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/79e2dde7ebaf4c5659a7e70bd4e424ca.jpg"><img src="http://img2.diglog.com/img/2020/11/79e2dde7ebaf4c5659a7e70bd4e424ca.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>For the past five years, I’ve done all of my software development in virtual machines (VMs). Each of my projects gets a dedicated VM, sparing me the headache of dependency conflicts and TCP port collisions.</p><p>在过去的五年里，我所有的软件开发都是在虚拟机(VM)中完成的。我的每个项目都有一个专用的VM，省去了依赖冲突和TCP端口冲突的麻烦。</p><p> Three years ago, I took things to the next level by  building my own homelab server to host all of my VMs. It’s been a fantastic investment, as it sped up numerous dev tasks and improved reliability.</p><p>三年前，我构建了自己的家庭实验室服务器来托管我所有的虚拟机，从而使事情更上一层楼。这是一项非常棒的投资，因为它加快了无数的开发任务，并提高了可靠性。</p><p> In the past few months, I began hitting the limits of my VM server. My projects have become more resource-hungry, and mistakes I’d made in my first build were coming back to bite me. I decided to build a brand new homelab VM server for 2020.</p><p>在过去的几个月里，我开始达到我的虚拟机服务器的极限。我的项目变得更加需要资源，而且我在第一次构建时犯的错误又回来咬我了。我决定在2020年打造一台全新的家庭实验室虚拟机服务器。</p><p>    If you’re not interested in the “why” of this project, you can jump  directly to the build.</p><p>如果你对这个项目的“为什么”不感兴趣，你可以直接跳到构建。</p><p>  Originally, I used VirtualBox to run VMs from my Windows desktop. That was fine for a while, but reboots became a huge hassle.</p><p>最初，我使用VirtualBox从我的Windows桌面运行虚拟机。这在一段时间内还不错，但重新启动成了一个巨大的麻烦。</p><p> Between forced reboots from Windows Update, voluntary restarts to complete software installs, and the occasional OS crash, I had to restart my entire suite of development VMs three to five times per month.</p><p>在从Windows更新强制重启、自愿重启以完成软件安装，以及偶尔出现操作系统崩溃之间，我不得不每月重启我的整个开发虚拟机套件三到五次。</p><p> A dedicated VM server spares me most reboots. The VM host runs a minimal set of software, so crashes and mandatory reboots are rare.</p><p>一台专用的虚拟机服务器让我不必重启。虚拟机主机运行的软件最少，因此很少出现崩溃和强制重启的情况。</p><p>   Cloud servers could serve the same function and save me the trouble (fun!) of maintaining my own hardware, but it’s prohibitively expensive. For VM resources similar to my homelab server, AWS EC2 instances  would cost over $6k per year:</p><p>云服务器可以提供相同的功能，省去了我的麻烦(有趣！)。维护我自己的硬件，但它贵得令人望而却步。对于与我的家庭实验室服务器类似的虚拟机资源，AWS EC2实例每年的成本将超过6000美元：</p><p>   I could substantially reduce costs by turning cloud instances on and off as needed, but that would introduce friction into my workflows. With a local VM server, I can keep 10-20 VMs available and ready at all times without worrying about micromanaging my costs.</p><p>我可以根据需要打开和关闭云实例，从而大幅降低成本，但这会给我的工作流程带来摩擦。使用本地VM服务器，我可以随时保持10-20个VM可用和就绪，而无需担心微观管理我的成本。</p><p>  My 2017 build served me well, but in three years of using it, I’ve come to recognize a few key areas begging for improvement.</p><p>我2017年的版本对我很有帮助，但在使用它的三年中，我逐渐认识到了几个亟待改进的关键领域。</p><p>  My Synology NAS has 10.9 TB of storage capacity. With all that network storage space, I thought, “why put more disk space on the server than the bare minimum to boot the host OS?”</p><p>我的Synology NAS有10.9TB的存储容量。有了这么多的网络存储空间，我想，“为什么要在服务器上投入比启动主机操作系统所需的最少空间更多的磁盘空间呢？”</p><p>    First, running VMs on network storage creates a strict dependency on the disk server. Synology publishes OS upgrades every couple of months, and their patches always require reboots. With my VMs running on top of Synology’s storage, I had to shut down my entire VM fleet before applying any update from Synology. It was the same reboot problem I had when I ran VMs on my Windows desktop.</p><p>首先，在网络存储上运行虚拟机会对磁盘服务器产生严格的依赖关系。Synology每隔几个月发布一次操作系统升级，他们的补丁总是需要重新启动。由于我的虚拟机运行在Synology的存储上，在应用Synology的任何更新之前，我不得不关闭我的整个虚拟机群。这与我在Windows桌面上运行虚拟机时遇到的重启问题相同。</p><p>   Second, random disk access over the network is  slow. At the time of my first build, most of my development work was on backend Python and Go applications, and they didn’t perform significant disk I/O. Since then, I’ve expanded into frontend web development. Modern web frameworks all use Node.js, so every project has anywhere from 10k-200k random JavaScript files in its dependency tree. Node.js builds involve tons of random disk access, a worst-case scenario for network storage.</p><p>其次，网络上的随机磁盘访问速度很慢。在我第一次构建的时候，我的大部分开发工作都是在后端的Python和Go应用程序上进行的，它们并没有执行大量的磁盘I/O。从那时起，我就扩展到了前端Web开发。现代的Web框架都使用Node.js，所以每个项目的依赖树中都有10k-200k的随机JavaScript文件。Js构建涉及大量的随机磁盘访问，这对网络存储来说是最糟糕的情况。</p><p>  For my first server, I evaluated two options for VM management:  Kimchi and  VMWare ESXi. VMWare was far more polished and mature, but Kimchi charmed me with its scrappy spirit and open-source nature.</p><p>对于我的第一台服务器，我评估了两种虚拟机管理选项：泡菜和VMWare ESXi。VMware要完美和成熟得多，但泡菜以其斗志和开源的本质迷住了我。</p><p>      Over time, Kimchi’s shortcomings became more and more apparent. I often had to click a VM’s “clone” or “shutdown” button multiple times before it cooperated. And there were infuriating UI bugs where buttons disappeared or shifted position right before I clicked on them.</p><p>随着时间的推移，泡菜的缺点变得越来越明显。我经常不得不多次点击虚拟机的“克隆”或“关机”按钮才能与其合作。还有一些令人恼火的用户界面错误，按钮在我点击之前消失或移动了位置。</p><p>    If you read the above and thought, “Kimchi is just software. Why did Michael have to build a whole new server just to install a different VM manager?” It’s because I failed to anticipate the importance of remote administration.</p><p>如果你读了上面的文章，你会想，“泡菜只是个软件而已。”为什么迈克尔必须建造一台全新的服务器，才能安装一个不同的虚拟机管理器？这是因为我没有预见到远程管理的重要性。</p><p> My VM server is just a PC that sits in the corner of my office with no monitor or keyboard attached. That’s fine 99% of the time when I can SSH in or use the web interface. But for the 1% of the time when the server fails to boot or I want to install a new host OS, it’s a huge pain. I have to drag the server over to my desk, disconnect my desktop keyboard and monitor, fix whatever needs fixing, then restore everything in my office to its original configuration.</p><p>我的虚拟机服务器只是一台放在办公室角落里的PC，没有连接显示器或键盘。当我可以通过SSH登录或使用Web界面时，99%的时间都可以。但在1%的时间里，当服务器启动失败或我想安装新的主机操作系统时，这是一个巨大的痛苦。我必须把服务器拖到我的办公桌上，断开我的桌面键盘和显示器，修复任何需要修复的东西，然后将我办公室里的一切恢复到原来的配置。</p><p> For my next build, I wanted a virtual console with physical-level access to the machine as soon as it powered on. I was thinking something like  Dell’s iDRAC or  HP’s iLO.</p><p>在我的下一次构建中，我想要一个虚拟控制台，只要机器一开机，它就可以进行物理级访问。我想的是戴尔的iDRAC或惠普的iLO。</p><p>     My first VM server’s CPU was a  Ryzen 7 1700. At eight cores and 16 threads, it was  the hot new CPU at the time. But when I showed off my build on  /r/homelab, reddit’s homelab subcommunity, they mocked me as a filthy casual because I used  consumer parts. The cool kids used enterprise gear.</p><p>我的第一台VM服务器的CPU是Ryzen 7 1700。它拥有8个内核和16个线程，是当时炙手可热的新CPU。但是，当我展示我在Reddit的HomeLab子社区/r/HomeLab上的构建时，他们嘲笑我是一个肮脏的休闲者，因为我使用了消费者部件。酷孩子们用的是企业用具。</p><p>  Resolved never to let /r/homelab make fun of me again, I ventured into the world of enterprise server hardware. I even got fancy and chose to build a system with two physical CPUs.</p><p>我决心再也不让/r/homelab取笑我了，于是我冒险进入了企业服务器硬件领域。我甚至想入非非，选择构建一个有两个物理CPU的系统。</p><p> To get the best performance for my dollar, I restricted my search to used CPUs, released four to eight years ago. For each candidate, I  looked up benchmark scores on PassMark and then checked eBay for recent sales of that CPU model in used condition.</p><p>为了让我的钱物有所值，我把搜索范围限制在四到八年前发布的二手CPU。对于每个候选人，我在PassMark上查找基准分数，然后在eBay上查看该CPU型号在二手状态下最近的销售情况。</p><p> The most cost-efficient performance seemed to be in the  Intel Xeon E5 v3 family, especially the 2600 models. I settled on the  E5-2680 v3. It had an average benchmark of 15,618 and cost ~$130 used on eBay.</p><p>性价比最高的似乎是英特尔至强E5 v3系列，尤其是2600机型。我选择了E5-2680 v3。它的平均基准是15618，在eBay上使用的价格约为130美元。</p><p>  For context, my previous build’s Ryzen 7 had a benchmark of 14,611. So with dual-E5-2680s, I’d more than double the processing power from my old server.</p><p>作为背景，我之前构建的Ryzen 7的基准测试是14,611。因此，有了双E5-2680，我的处理能力将比我的旧服务器高出一倍以上。</p><p>    The downside of a dual-CPU system was that it limited my options for motherboards. Only a handful of motherboards support dual Intel 2011-v3 CPUs. Their prices ranged from $300 to $850, which was far more than I expected to spend on a motherboard.</p><p>双CPU系统的缺点是限制了我对主板的选择。只有少数主板支持双英特尔2011-v3 CPU。它们的价格从300美元到850美元不等，这远远超过了我在主板上的预期花费。</p><p> I chose the  SuperMicro MBD-X10DAL-I-O, which at $320 was lower in price than similar motherboards, but it was still  five times what I paid for  my last one.</p><p>我选择了超微MBD-X10DAL-I-O，它的价格比同类主板低320美元，但仍然是我上一块主板价格的五倍。</p><p>    There seems to be a lot less informed choice for server memory. With consumer hardware, plenty of websites publish reviews and benchmarks of different RAM sticks, but I didn’t see anything like that for server RAM.</p><p>对于服务器内存，似乎有很多不那么知情的选择。对于消费类硬件，很多网站都会发布对不同内存条的评论和基准测试，但我没有看到任何类似的服务器内存条。</p><p> I went with  Crucial CT4K16G4RFD4213 64 GB (4 x 16 GB) because I trusted the brand. I chose 64 GB because  my previous build had 32 GB, and some of my workflows were approaching that limit, so I figured doubling RAM would cover me for the next few years.</p><p>我选择了关键的CT4K16G4RFD4213 64 GB(4x16 GB)，因为我信任这个品牌。我之所以选择64 GB，是因为我之前的版本是32 GB，而我的一些工作流正在接近这个限制，所以我想在接下来的几年里，将RAM翻一番就可以满足我的需求。</p><p>    I love M.2 SSDs, as they’re small, perform outstandingly, and neatly tuck away in the motherboard without any cabling. Sadly, the MBD-X10DAL doesn’t support the M.2 interface.</p><p>我喜欢M.2固态硬盘，因为它们体积小，性能出众，而且整齐地藏在主板上，没有任何线缆。遗憾的是，MBD-X10DAL不支持M.2接口。</p><p> Instead, I stuck with traditional old SATA. I bought a  1 TB Samsung 860 EVO. I typically allocate 40 GB of space to each VM, so 1 TB would give me plenty of room. If I need to upgrade later, I can always buy more disks.</p><p>取而代之的是，我坚持使用传统的SATA。我买了一台1TB的三星860EVO。我通常为每个虚拟机分配40 GB的空间，因此1 TB会给我足够的空间。如果我以后需要升级，我总是可以买更多的磁盘。</p><p>    Choosing a power supply unit (PSU) isn’t that interesting, so I again chose mainly by trusted brand, the  Corsair CX550M 550W 80 Plus Bronze.</p><p>选择电源单元(PSU)并不是那么有趣，所以我再次选择了主要受信任的品牌，海盗船CX550M 550W 80加青铜。</p><p> The wattage on all of my components added up to 400 W, so 450 W would have been sufficient. But the 550 W version was only $10 more, which seemed like a fair price for an extra 100 W of breathing room.</p><p>我所有组件的功率加起来是400W，所以450W就足够了。但550瓦版本的价格只高出10美元，对于额外100瓦的呼吸空间来说，这似乎是一个公平的价格。</p><p> The only other important feature to me was semi-modular cabling. In my last build, I made the mistake of using non-modular cabling, which meant that all of the PSU cables stay attached permanently. My server barely has any internal components, so the extraneous power cables created clutter. With semi-modular cabling, I can keep things tidy by removing unused cables from the PSU.</p><p>对我来说，唯一的另一个重要特征是半模块化布线。在我的上一次构建中，我犯了一个错误，使用了非模块化布线，这意味着所有的PSU电缆都保持永久连接。我的服务器几乎没有任何内部组件，所以多余的电源线造成了混乱。使用半模块化布线，我可以通过从PSU上移除不用的电缆来保持东西整洁。</p><p>    The dual-CPU build made cooling an unexpected challenge. The MBD-X10DAL doesn’t leave much space between the two CPU sockets, so I looked carefully for fans thin enough to work side-by-side. A pair of  Cooler Master Hyper 212s fit the bill.</p><p>双CPU版本使得冷却成为一个意想不到的挑战。MBD-X10DAL在两个CPU插座之间没有留下太多空间，所以我仔细寻找了足够薄的风扇，以便并行工作。一双更酷的Master Hyper 212正好符合要求。</p><p>    My server sits inconspicuously in the corner of my office, so I didn’t want a case with clear panels or flashy lights.</p><p>我的服务生不显眼地坐在办公室的角落里，所以我不想要一个面板清晰或灯光耀眼的箱子。</p><p> The  Fractal Design Meshify C Black had positive reviews and seemed like a simple, quiet case.</p><p>Fractal Design Meshify C Black得到了积极的评价，似乎是一个简单、安静的案例。</p><p>    For a headless server, the graphics card doesn’t matter much. It’s still necessary so I can see the screen during the initial install and the occasional debugging session, so I went with the  MSI GeForce GT 710 as a cheap, easy option.</p><p>对于无头服务器来说，显卡并不重要。它仍然是必要的，这样我就可以在初始安装和偶尔的调试过程中看到屏幕，所以我选择了MSI GeForce GT 710，作为一个便宜、简单的选择。</p><p>  I looked into remote administration solutions and was blown away by how expensive they were. At first, I thought I’d use a Dell iDRAC, but the remote console requires a  $300 enterprise license and constrains my build to Dell components. I looked at KVM over IP solutions, but those were even more expensive, ranging from $600 to $1,000.</p><p>我研究了远程管理解决方案，他们的昂贵让我大吃一惊。起初，我想我应该使用戴尔iDRAC，但远程控制台需要300美元的企业许可证，并且将我的构建限制在戴尔组件上。我研究了KVM over IP解决方案，但它们甚至更贵，从600美元到1000美元不等。</p><p>   To achieve remote administration, I took the unusual approach of  building my own KVM over IP device out of a Raspberry Pi. I call it  TinyPilot.</p><p>为了实现远程管理，我采用了一种不同寻常的方法，用Raspberry PI构建我自己的KVM over IP设备。我叫它TinyPilot。</p><p>  TinyPilot captures HDMI output and forwards keyboard and mouse input from the browser. It provides the same access you’d have if you physically connected a real keyboard, mouse, and monitor. The software is  fully open source, and I offer all-in-one kits if you’d like to build one for yourself.</p><p>TinyPilot捕获HDMI输出，并从浏览器转发键盘和鼠标输入。它提供的访问权限与物理连接真正的键盘、鼠标和显示器时的访问权限相同。该软件是完全开源的，如果你想自己构建一个，我可以提供一体机工具包。</p><p>              After  Kimchi burned me on my last build, I was reluctant to try another free solution.  Proxmox has been around for 12 years, so I felt like they were a safe enough bet. Graphics-wise, it’s a huge step up from Kimchi, but it lags behind ESXi in slickness.</p><p>在泡菜烧了我的最后一个版本之后，我不愿意尝试另一个免费的解决方案。Proxmox已经存在12年了，所以我觉得他们是一个足够安全的赌注。在图形方面，它比泡菜有了很大的进步，但在流畅度上落后于ESXi。</p><p> The part of Proxmox that I most appreciate is its scriptability. One of my frequent tasks is creating a new VM from a template and then using  Ansible to install additional software. With ESXi, I couldn’t find a way to do this without manually clicking buttons in the web UI every time. With Proxmox,  their CLI is powerful enough that I can script it down to just  ./create-vm whatgotdone-dev and my scripts create a fresh  What Got Done development VM.</p><p>我最欣赏的Proxmox部分是它的脚本化。我经常执行的任务之一是从模板创建一个新的虚拟机，然后使用Ansible安装其他软件。使用ESXi时，如果不是每次都手动点击web用户界面中的按钮，我无法找到一种方法来做到这一点。有了Proxmox，他们的CLI就足够强大，我可以把它写成./create-vm Whatgodo-dev，我的脚本可以创建一个全新的完成了什么的开发VM。</p><p> My biggest complaint is that Proxmox is unintuitive. I couldn’t even figure out how to install it until I found  Craft Computing’s installation tutorial. But once you learn your way around, it’s easy to use.</p><p>我最大的抱怨是Proxmox不直观。我甚至不知道如何安装它，直到我找到了Craft Computing的安装教程。但是一旦你熟悉了你的方法，它就很容易使用了。</p><p>  Before I decommissioned my old VM server, I collected simple benchmarks of my common workflows to measure performance improvements.</p><p>在我停用旧的VM服务器之前，我收集了常见工作流的简单基准来衡量性能提升。</p><p> Most of my old VMs ran on network storage because its local SSD only had room for a couple of VMs. In the benchmarks below, I compare performance in three different scenarios:</p><p>我的大多数旧虚拟机都运行在网络存储上，因为它的本地SSD只有几个虚拟机的空间。在下面的基准测试中，我比较了三种不同场景下的性能：</p><p> 2020 Server: All VMs run on local SSD, so there’s no NAS vs. SSD</p><p>2020服务器：所有虚拟机都在本地固态硬盘上运行，因此没有NAS与固态硬盘。</p><p>   The first benchmark I took was provisioning a new VM. I have a standard Ubuntu 18.04 VM template I use for almost all of my VMs. Every time I need a new VM, I run a shell script that performs the following steps:</p><p>我采用的第一个基准测试是配置一个新的虚拟机。我有一个标准的Ubuntu 18.04 VM模板，我几乎所有的VM都使用它。每次需要新的虚拟机时，我都会运行一个执行以下步骤的Shell脚本：</p><p>   My new server brought a huge speedup to this workflow. Cloning a VM went from 15 minutes on my old server to less than four minutes on the new one.</p><p>我的新服务器为这个工作流程带来了巨大的加速。克隆一个虚拟机在我的旧服务器上只用了15分钟，而在新服务器上只用了不到4分钟。</p><p> If I skip the package upgrade step, the speedup is a little less impressive. The new server still blows away performance on NAS storage, dropping from eight minutes to just under two and a half. SSD to SSD, it underperforms my previous server. Cloning a VM is likely disk-bound, and my old M.2 SSD was faster than my new SATA SSD.</p><p>如果我跳过包升级步骤，加速效果就不那么令人印象深刻了。新服务器在NAS存储上的性能仍然令人叹为观止，从8分钟降至略低于2.5分钟。固态硬盘到固态硬盘，它的性能逊于我之前的服务器。克隆一个虚拟机可能是受磁盘限制的，而且我的旧M.2固态硬盘比我的新SATA固态硬盘更快。</p><p>  From the moment I power on a VM, how long does it take for me to see the login prompt?</p><p>从我打开虚拟机的那一刻起，我需要多长时间才能看到登录提示？</p><p>  My old VMs booted in 48 seconds. The few SSD VMs on my old system did a little better, showing the login prompt in 32 seconds. My new server blows both away, booting up a VM in only 18 seconds.</p><p>我的旧虚拟机在48秒内启动。我的旧系统上的几个SSD虚拟机做得稍好一些，在32秒内就显示了登录提示。我的新服务器在18秒内就启动了一台虚拟机。</p><p>  My weekly journaling app,  What Got Done, has automated tests that exercise its functionality end-to-end. This is one of my most diverse workflows — it involves compiling a Go backend, compiling a Vue frontend, building a series of Docker containers, and automating Chrome to exercise my app. This was one of the workflows that exhausted resources on my old VM, so I expected substantial gains here.</p><p>我每周一次的日志应用What Good Done已经完成了自动测试，可以端到端地运行它的功能。这是我最多样化的工作流程之一--它包括编译Go后端、编译Vue前端、构建一系列Docker容器，以及自动化Chrome来运行我的应用程序。这是耗尽我的旧虚拟机上资源的工作流之一，所以我预计这里会有很大的收益。</p><p>   Surprisingly, there was no significant performance difference between the two servers. For a cold start (downloading all of the Docker base images), the new server is 2% slower than the old one. When the base Docker images are available locally, my new server beats my old, but only by 6%. It looks like the bottleneck is mainly the disk and browser interaction, so the new server doesn’t make much of a difference.</p><p>令人惊讶的是，这两台服务器之间没有显著的性能差异。冷启动(下载所有Docker基础镜像)，新服务器比旧服务器慢2%。当基本Docker镜像在本地可用时，我的新服务器比我的旧服务器好，但仅高出6%。看起来瓶颈主要是磁盘和浏览器的交互，所以新的服务器没有太大的不同。</p><p>  One frequent workflow I have is building  Is It Keto, my resource for keto dieters. I generate the site using  Gridsome, a static site generator for  Vue.</p><p>我有一个经常使用的工作流程，那就是为酮类节食者提供的资源是不是Keto？我使用Gridome(Vue的静态站点生成器)生成站点。</p><p>  I expected a significant speedup here, so I was surprised when my build got slower. The build seemed to be mostly CPU-bound on my old server, but doubling CPU resources on my new server did nothing. My next guess was that it was disk-bound, so I tried moving the files to a RAMdisk, but build speeds remained the same.</p><p>我预计这里会有显著的加速，所以当我的构建速度变慢时，我感到很惊讶。在我的旧服务器上，构建似乎主要是受CPU限制的，但是在我的新服务器上加倍CPU资源并没有起到任何作用。我的下一个猜测是它是受磁盘限制的，所以我尝试将文件移动到RAM磁盘，但构建速度保持不变。</p><p> My hypothesis is that the workflow is CPU-bound but parallelizes poorly. My old server has fewer CPU cores, but each core is faster. If the build is limited to five or six threads, it can’t take advantage of my new server’s 48 cores.</p><p>我的假设是，工作流是受CPU限制的，但是并行性很差。我的旧服务器的CPU核心较少，但每个核心都更快。如果构建被限制为五六个线程，它就不能利用我的新服务器的48个核心。</p><p>  Zestful is my machine-learning-based API for parsing recipe ingredients. Every few months, I train it on new data. This is my most CPU-intensive workflow, so I was interested to see how the new system would handle it.</p><p>Zestful是我的基于机器学习的API，用于解析食谱成分。每隔几个月，我就会根据新的数据对其进行培训。这是我的CPU最密集的工作流，所以我很想看看新系统将如何处理它。</p><p>  Finally, a case where my 48 CPU cores shine! The new server blows the old one away, training the model in less than half the time. Unfortunately, it’s a workflow I only run a few times per year.</p><p>最后，我的48个CPU内核大放异彩！新的服务器彻底颠覆了旧的服务器，只用了不到一半的时间就训练好了模型。不幸的是，这是一个我一年只运行几次的工作流程。</p><p>   Even though /r/homelab may never respect me, on my next build, I’m planning to return to consumer hardware.</p><p>尽管/r/homelab可能永远不会尊重我，但在我的下一次构建中，我计划回到消费类硬件。</p><p> The biggest advantage I see with server components is that they have  better compatibility with server software. Back in 2017, I  couldn’t install ESXi until I disabled multithreading on my CPU, degrading performance substantially. But that was a limitation in the Linux kernel, and later updates  fixed it.</p><p>我认为服务器组件的最大优势是它们与服务器软件有更好的兼容性。早在2017年，我就无法安装ESXi，直到我禁用了CPU上的多线程，这大大降低了性能。但这是Linux内核中的一个限制，后来的更新修复了它。</p><p> Server hardware commands a premium because of its greater reliability. For user-facing services, this characteristic is meaningful, but it matters much less on a development server. An occasional crash or bit flip on a dev server shouldn’t ruin your day.</p><p>服务器硬件因其更高的可靠性而备受推崇。对于面向用户的服务，此特性很有意义，但在开发服务器上就没那么重要了。开发服务器上偶尔出现的崩溃或位翻转不应该毁了您的一天。</p><p>  This was the first time I’d ever built a dual-CPU computer. It was an interesting experience, but I don’t think it was worth the trouble.</p><p>这是我第一次建造双CPU计算机。这是一次有趣的经历，但我认为不值得这么麻烦。</p><p> Based on my benchmarks, the CPU was so rarely the limiting factor in my workflows. The most damning evidence is Proxmox’s graph of my CPU usage over time. In the past few months, I’ve never pushed CPU load above 11%, so I’m crazy overprovisioned.</p><p>根据我的基准，CPU很少是我工作流程中的限制因素。最确凿的证据是Proxmox的CPU使用率随时间变化的图表。在过去的几个月里，我从未将CPU负载提升到11%以上，所以我被过度配置了。</p><p>   The requirement for dual CPUs drove up the cost of a motherboard substantially and limited my options. Only a scant few mobos support dual Intel 2011-v3 CPUs, so I didn’t have many choices in terms of other motherboard features.</p><p>对双CPU的要求大大提高了主板的成本，限制了我的选择。只有为数不多的Mobos支持英特尔2011-v3双CPU，所以我在其他主板功能上没有太多选择。</p><p>  Before I used TinyPilot to manage my server, I didn’t realize how change-averse I was. Changing any BIOS or network settings brought a risk of losing the next few hours of my life physically moving around machines and reconnecting peripherals to debug and fix the problem. Knowing that, I never wanted to modify any of those settings.</p><p>在我使用TinyPilot管理我的服务器之前，我并没有意识到我是多么厌恶改变。更改任何BIOS或网络设置都有可能损失我生命中接下来的几个小时，因为我需要在机器上四处走动，并重新连接外围设备来调试和修复问题。知道这一点后，我再也不想修改这些设置了。</p><p> Having a virtual console gives me the freedom to fail and makes me more open to experimenting with different operating systems. It’s always going to be a substantial effort to install and learn a new OS, but knowing that I don’t have to drag machines back and forth makes me much more open to it. Had I not built TinyPilot, I might have stuck with ESXi as “good enough” rather than taking a chance on Proxmox.</p><p>拥有虚拟控制台让我有了失败的自由，也让我更愿意尝试不同的操作系统。安装和学习一个新的操作系统总是需要付出巨大的努力，但知道我不必来回拖拽机器，这让我对它更加开放。如果我没有创建TinyPilot，我可能会坚持认为ESXi“足够好”，而不是冒险选择Proxmox。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mtlynch.io/building-a-vm-homelab/">https://mtlynch.io/building-a-vm-homelab/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟机/">#虚拟机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/homelab/">#homelab</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>