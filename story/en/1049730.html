<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JSON互操作性漏洞探索 An Exploration of JSON Interoperability Vulnerabilities</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An Exploration of JSON Interoperability Vulnerabilities<br/>JSON互操作性漏洞探索 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-27 09:15:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/c49ed71b1bfbe9acd1c6fbf5024dc439.png"><img src="http://img2.diglog.com/img/2021/2/c49ed71b1bfbe9acd1c6fbf5024dc439.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>TL;DR The same JSON document can be parsed with different values across microservices, leading to a variety of potential security risks. If you prefer a hands-on approach,  try the labs and when they scare you, come back and read on.</p><p>TL; DR相同的JSON文档可以在微服务中使用不同的值进行解析，从而导致各种潜在的安全风险。如果您喜欢动手实践的方法，请尝试一下实验，当实验吓到您时，请返回并继续阅读。</p><p>  JSON is the backbone of web application communications. The simplicity of JSON is often taken for granted. We don&#39;t usually consider JSON parsing as part of our threat model. However, in our modern, multi-language, microservice architectures, our applications often rely on several separate JSON parsing implementations, each of which has its own quirks.</p><p>  JSON是Web应用程序通信的基础。 JSON的简单性通常被认为是理所当然的。我们通常不将JSON解析作为威胁模型的一部分。但是，在我们现代的多语言微服务体系结构中，我们的应用程序通常依赖于几个单独的JSON解析实现，每个实现都有自己的怪癖。</p><p> As we&#39;ve seen through attacks like  HTTP request smuggling, discrepancies across parsers combined with multi-stage request processing can introduce serious vulnerabilities. In this research, I conducted a survey of 49 JSON parsers, cataloged their quirks, and present a variety of attack scenarios and  Docker Compose labs to highlight their risks. Through our payment processing and user management examples, we will explore how JSON parsing inconsistencies can mask serious business logic vulnerabilities in otherwise benign code.</p><p> 正如我们通过HTTP请求走私这样的攻击所看到的那样，解析器之间的差异与多阶段请求处理相结合会带来严重的漏洞。在这项研究中，我对49个JSON解析器进行了调查，对它们的怪癖进行了分类，并提出了各种攻击方案和Docker Compose实验以突出它们的风险。通过我们的付款处理和用户管理示例，我们将探索JSON解析不一致如何掩盖其他良性代码中严重的业务逻辑漏洞。</p><p>   Even in the best-case implementation, there are inevitably minor, unintentional deviations from specifications. However, JSON parsers have a couple additional challenges. Even within the official JSON RFC, there is open-ended guidance on a few topics, such as how to handle duplicate keys and represent numbers. Although this guidance is followed by disclaimers about interoperability, most users of JSON parsers aren&#39;t aware of these caveats.</p><p>   即使在最佳情况下实施，也不可避免地会出现与规格的微小，无意的偏差。但是，JSON解析器还有其他一些挑战。即使在正式的JSON RFC中，也存在一些主题的开放式指南，例如如何处理重复的键和表示数字。尽管此指南后面是关于互操作性的免责声明，但是大多数JSON解析器的用户并没有意识到这些警告。</p><p>  IETF JSON RFC (8259 and prior): This is the official Internet Engineering Task Force (IETF) specification.</p><p>  IETF JSON RFC（8259及更低版本）：这是官方的Internet工程任务组（IETF）规范。</p><p> ECMAScript Standard : Changes to JSON are released in lockstep with RFC releases, and the standard refers to the RFC for guidance on JSON. However, non-spec conveniences provided by the JavaScript interpreter, such as quoteless strings and comments, have inspired many parsers.</p><p> ECMAScript标准：对JSON的更改与RFC版本同步发布，该标准参考RFC以获取有关JSON的指导。但是，JavaScript解释器提供的非规范便利（例如无引号的字符串和注释）启发了许多解析器。</p><p> JSON5 : This superset specification augments the official specification by explicitly adding convenience features (e.g., comments, alternative quotes, quoteless strings, trailing commas).</p><p> JSON5：此超集规范通过显式添加便捷功能（例如，注释，替代引号，无引号的字符串，尾部逗号）来增强官方规范。 </p><p> So, why would some parsers begin to selectively incorporate features that others ignore, or take contradicting approaches with parser behavior?</p><p>那么，为什么某些解析器会开始选择性地合并其他人忽略的功能，或者采用与解析器行为相矛盾的方法呢？</p><p>  As discussed in the sections below, decisions on handling duplicate keys and representing numbers are often left open-ended. I suspect this may be due to the specification being published after implementations became popular. Perhaps the design committee decided not to break backwards compatibility with pre-specification JSON parsers, including the original JavaScript implementation.</p><p>  如以下各节所述，处理重复键和表示数字的决定通常是开放式的。我怀疑这可能是由于该规范在实施变得流行之后被发布了。也许设计委员会决定不破坏与预规范JSON解析器的向后兼容性，包括原始的JavaScript实现。</p><p> However, these decisions continue to propagate through the ecosystem into super-set specs like JSON5 and HJSON and even into the binary variants like BSON, MessagePack, and CBOR, as we will discuss later on.</p><p> 但是，这些决策将继续通过生态系统传播到JSON5和HJSON之类的超集规范中，甚至传播到BSON，MessagePack和CBOR之类的二进制变量中，我们将在后面讨论。</p><p> Further interoperability concerns come from delayed guidance on number and string encoding. String encoding was only explicitly required to be UTF-8 in the 2017 revision of the specification.</p><p> 进一步的互操作性问题来自对数字和字符串编码的延迟指导。在规范的2017年修订版中，仅明确要求字符串编码为UTF-8。</p><p>       Creed said they were different. Creed and Pam were both right, but it depends on whom you ask.</p><p>       信条说他们是不同的。信条和帕姆都是正确的，但这取决于你问谁。</p><p> Many of us have encountered this quirk of JSON through our development work: What happens if you have a duplicate key?</p><p> 我们中的许多人在我们的开发工作中都遇到了JSON的这个怪癖：如果您有重复的密钥，会发生什么？</p><p>   Is the value of      obj[&#34;test&#34;] going to be 1 or 2, or will it produce an error?</p><p>   obj [＆＃34; test＆＃34;]的值是1还是2，还是会产生错误？ </p><p> According to the official specification, any of those results are acceptable. Surprisingly, I&#39;ve even encountered developers directly leveraging duplicate key precedence to create self-documenting JSON. Here&#39;s an example:</p><p>根据官方规范，任何这些结果都是可以接受的。令人惊讶的是，我什至遇到了开发人员直接利用重复的键优先级来创建自文档化JSON的情况。这是一个示例：</p><p> // For a parser where the last key takes precedence, the first “test” key will be ignored during parsing.obj = {&#34;test&#34;: &#34;this is a description of the test field&#34;, &#34;test&#34;: &#34;Actual Value&#34;}</p><p> //对于最后一个键优先的解析器，在解析过程中第一个“测试”键将被忽略。obj = {＆＃34; test＆＃34 ;:＆＃34;这是测试字段的描述＆＃34 ;，＆＃34; test＆＃34 ;:＆＃34; Actual Value＆＃34;}</p><p> You may be surprised to find that the guidance from the spec is quite descriptive rather than prescriptive. The following is from the latest version of IETF JSON RFC (8259):</p><p> 您可能会惊讶地发现，该规范中的指导是描述性的而非规范性的。以下是IETF JSON RFC（8259）的最新版本：</p><p> An object whose names are all unique is interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, the behavior of software that receives such an object is  unpredictable.  Many implementations report the last name/value pair only. Other implementations report an error or fail to parse the object, and some implementations report all of the name/value pairs, including duplicates.     JSON parsing libraries  have been observed to differ as to whether or not they make the ordering of object members visible to calling software. Implementations whose behavior does not depend on member ordering will be interoperable in the sense that they will not be affected by these differences.</p><p> 从名称接收到的所有软件实现都将在名称-值映射上达成一致的意义上来说，名称都是唯一的对象是可以互操作的。如果对象中的名称不是唯一的，则接收到该对象的软件的行为是不可预测的。许多实现仅报告姓/值对。其他实现报告错误或无法解析对象，某些实现报告所有名称/值对，包括重复项。观察到JSON解析库在是否使调用软件可见对象成员的顺序方面存在差异。行为不取决于成员顺序的实现将可以互操作，因为它们不会受到这些差异的影响。</p><p> My suspicion is that the specification did not want to break backwards compatibility with pre-specification parsers. To be fair, the interoperability concerns are noted. But in a practical sense, as stated earlier, how many developers read the JSON RFC, or consider interoperability issues with such a simple format? Needless to say, the language in the specification above is quite different than the explicit and direct guidance that is commonly found in an RFC.</p><p> 我怀疑规范不希望破坏与规范前解析器的向后兼容性。公平地说，注意到了互操作性问题。但是，如前所述，从实际意义上讲，有多少开发人员阅读JSON RFC，或考虑使用这种简单格式的互操作性问题？不用说，以上规范中的语言与RFC中常见的显式和直接指导有很大不同。</p><p>   Let&#39;s consider an e-commerce application where we have a Cart service that enforces business logic, forwards the request to a Payment service for payment processing, and performs order fulfillment. Let&#39;s attempt to get something for free. This example will use the design described below:</p><p>   让我们考虑一个电子商务应用程序，在该应用程序中，我们具有执行业务逻辑的购物车服务，将该请求转发到付款服务以进行付款处理，并执行订单履行。让我们尝试免费获得一些东西。本示例将使用以下描述的设计：</p><p>  Let&#39;s suppose the Cart service receives a request like this (note the duplicated      qty key for the second item in the cart):</p><p>  假设购物车服务收到这样的请求（请注意购物车中第二个项目的重复数量键）： </p><p> POST /cart/checkout HTTP/1.1...Content-Type: application/json{	&#34;orderId&#34;: 10,	&#34;paymentInfo&#34;: { 	//... }, &#34;shippingInfo&#34;: { 	//... },	&#34;cart&#34;: [ { &#34;id&#34;: 0, &#34;qty&#34;: 5 }, { &#34;id&#34;: 1, &#34;qty&#34;: -1, &#34;qty&#34;: 1 } ]}</p><p>POST /购物车/结帐HTTP / 1.1 ...内容类型：application / json {＆＃34; orderId＆＃34 ;: 10，＆＃34; paymentInfo＆＃34 ;: {// ...}，＆＃34 ; shippingInfo＆＃34 ;: {// ...}，＆＃34; cart＆＃34 ;: [{＆＃34; id＆＃34 ;: 0，＆＃34; qty＆＃34 ;: 5}，{＆ ＃34; id＆＃34 ;: 1，＆＃34; qty＆＃34 ;: -1，＆＃34; qty＆＃34 ;: 1}]}</p><p>  As shown below, the Cart service enforces business logic before sending the order to the payment service. The API is written with Python Flask and uses the Python standard library JSON parser, which uses last-key precedence for duplicated keys (meaning for      id: 1 the      qty = 1):</p><p>  如下所示，购物车服务在将订单发送到支付服务之前强制执行业务逻辑。该API是使用Python Flask编写的，并使用Python标准库JSON解析器，该解析器对重复的键使用last-key优先级（对于id：1，数量= 1）；</p><p> @app.route(&#39;/cart/checkout&#39;, methods=[&#34;POST&#34;])def checkout(): # 1a: Parse JSON body using Python stdlib parser. data = request.get_json(force=True) # 1b: Validate constraints using jsonschema: id: 0 &lt;= x &lt;= 10 and qty: &gt;= 1 # See the full source code for the schema jsonschema.validate(instance=data, schema=schema) # 2: Process payments resp = requests.request(method=&#34;POST&#34;, url=&#34;http://payments:8000/process&#34;, data=request.get_data(), ) # 3: Print receipt as a response, or produce generic error message if resp.status_code == 200: receipt = &#34;Receipt:\n&#34; for item in data[&#34;cart&#34;]: receipt += &#34;{}x {} @ ${}/unit\n&#34;.format( item[&#34;qty&#34;], productDB[item[&#34;id&#34;]].get(&#34;name&#34;), productDB[item[&#34;id&#34;]].get(&#34;price&#34;) ) receipt += &#34;\nTotal Charged: ${}\n&#34;.format(resp.json()[&#34;total&#34;]) return receipt return &#34;Error during payment processing&#34;</p><p> @ app.route（＆＃39; / cart / checkout＆＃39 ;, methods = [＆＃34; POST＆＃34;]）def checkout（）：＃1a：使用Python stdlib解析器解析JSON正文。数据= request.get_json（force = True）＃1b：使用jsonschema验证约束：id：0＆lt; = x＆lt; = 10和qty：＆gt; = 1＃请参阅架构jsonschema.validate（instance）的完整源代码= data，schema = schema）＃2：处理付款分别= request.request（method =＆＃34; POST＆＃34 ;， url =＆＃34; http：// payments：8000 / process＆＃34;，data = request.get_data（），）＃3：将回执打印为响应，或者如果resp.status_code == 200：则产生通用错误消息：回执=＆＃34;回执：\ n＆＃34;数据[＆cart＆＃34;]中的项目：收据+ =＆＃34; {} x {} @ $ {} /单位\ n＆＃34; .format（item [＆＃34; qty＆＃34 ;]，productDB [item [＆＃34; id＆＃34;]。get（＆＃34; name＆＃34;），productDB [item [＆＃34; id＆＃34;]]。get（＆＃34 ; price＆＃34;））收据+ =＆＃34; \ n总收费：$ {} \ n＆＃34; .format（resp.json（）[＆＃34; total＆＃34;]）返回收据return＆＃ 34;付款处理过程中出现错误＆＃34;</p><p> The JSON body will validate successfully because the duplicated key is ignored, and all the parsed values satisfy the constraints. Now that the JSON is deemed safe, the original JSON string (     request.get_data()) is forwarded to the Payments service. From a developer&#39;s perspective, why would you waste computation by re-serializing a JSON object that you just parsed and validated when the string input is readily available? This assumption should be sound.</p><p> JSON主体将成功验证，因为忽略了重复的键，并且所有解析的值都满足约束。现在，JSON被认为是安全的，原始的JSON字符串（request.get_data（））被转发到Payments服务。从开发人员的角度来看，为什么要在字符串输入易于使用时通过重新序列化刚刚解析并验证的JSON对象来浪费计算量？这个假设应该是正确的。</p><p> Next, the request is received at the Payments service. This Golang service uses a high-performance third-party JSON parser (     buger/jsonparser). However, this JSON parser uses first-key precedence (meaning for      id: 1 the      qty = -1). This service calculates the total, as shown below:</p><p> 接下来，在付款服务处收到请求。此Golang服务使用高性能的第三方JSON解析器（buger / jsonparser）。但是，此JSON解析器使用第一键优先级（对于id：1，数量= -1表示含义）。该服务计算总计，如下所示：</p><p> func processPayment(w http.ResponseWriter, r *http.Request) { var total int64 = 0 data, _ := ioutil.ReadAll(r.Body) jsonparser.ArrayEach( data, func(value []byte, dataType jsonparser.ValueType, offset int, err error) { // Retrieves first instance of a duplicated key. Including qty = -1 id, _ := jsonparser.GetInt(value, &#34;id&#34;) qty, _ := jsonparser.GetInt(value, &#34;qty&#34;) total = total + productDB[id][&#34;price&#34;].(int64) * qty; }, &#34;cart&#34;) //... Process payment of value &#39;total&#39; // Return value of &#39;total&#39; to Cart service for receipt generation. io.WriteString(w, fmt.Sprintf(&#34;{\&#34;total\&#34;: %d}&#34;, total))}</p><p> func processPayment（w http.ResponseWriter，r * http.Request）{var total int64 = 0 data，_：= ioutil.ReadAll（r.Body）jsonparser.ArrayEach（data，func（value [] byte，dataType jsonparser.ValueType ，offset int，err error）{//检索重复键的第一个实例，包括qty = -1 id，_：= jsonparser.GetInt（value，＆＃34; id＆＃34;）qty，_：= jsonparser。 GetInt（value，＆＃34; qty＆＃34;）total =总数+ productDB [id] [＆＃34; price＆＃34;]。（int64）* qty;}，＆＃34; cart＆＃34;）/ / ...处理付款金额“总额” //返回总值＆＃39;到购物车服务以生成收据。 io.WriteString（w，fmt.Sprintf（＆＃34; {\＆＃34; total \＆＃34 ;:％d}＆＃34; total））}</p><p>  The Cart service receives the total that was charged from the payment service and generates a receipt for the response. We view the receipt from Cart service, but we can see an error. We will be shipped six products of a value of $700, but we were charged only $300:</p><p>  购物车服务接收从支付服务收取的总费用，并生成响应收据。我们查看了购物车服务中的收据，但看到错误。我们将向您运送价值700美元的六种产品，但我们仅收取了300美元的费用： </p><p>  However, in this example, the validated JSON document was not re-stringified after being parsed; instead, it uses the JSON string from the original request. In  section 3, JSON Serialization Quirks, we will explore examples of re-stringified objects that still propagate risky quirks.</p><p>但是，在此示例中，经过验证的JSON文档在解析后并未重新进行字符串化。而是使用原始请求中的JSON字符串。在第3节JSON序列化怪癖中，我们将探讨仍传播风险怪癖的重新字符串化对象的示例。</p><p>     It is also possible to induce key collisions through character truncation and comments, increasing the number of parsers affected by the duplicate key precedence.</p><p>     还可以通过字符截断和注释来引发键冲突，从而增加受重复键优先级影响的解析器的数量。</p><p>  Some parsers truncate particular characters when they appear in a string, while others don&#39;t. This can cause different keys to be interpreted as duplicates in a subset of parsers. For example, the following documents will appear to have duplicate keys in some last-key precedence parsers, but not others:</p><p>  有些解析器在字符串中出现特定字符时会截断它们，而其他解析器则不会。这可能导致将不同的密钥解释为解析器子集中的重复项。例如，以下文档在某些最后关键字优先级解析器中似乎具有重复的关键字，而在其他文档中则没有：</p><p> {&#34;test&#34;: 1, &#34;test\[raw \x0d byte]&#34;: 2}  {&#34;test&#34;: 1, &#34;test\ud800&#34;: 2} {&#34;test&#34;: 1, &#34;test&#34;&#34;: 2} {&#34;test&#34;: 1, &#34;te\st&#34;: 2}</p><p> {＆＃34; test＆＃34;：1，＆＃34; test \ [原始\ x0d字节]＆＃34;：2} {＆＃34; test＆＃34;：1，＆＃34; test \ ud800＆ ＃34 ;: 2} {＆＃34; test＆＃34 ;: 1，＆＃34; test＆＃34;＆＃34 ;: 2} {＆＃34; test＆＃34 ;: 1，＆＃34; te \ st＆＃34;：2}</p><p>  These string representations are  usually not stable for multiple rounds of deserialization and reserialization. For example, the Unicode codepoints      U+D800  through      U+DFFF are unpaired UTF-16 surrogates, and while unpaired surrogates can be encoded into a UTF-8 byte string, it&#39;s considered illegal Unicode.</p><p>  这些字符串表示形式通常对于多轮反序列化和反序列化是不稳定的。例如，通过U + DFFF的Unicode代码点U + D800是不成对的UTF-16替代，并且可以将未成对的替代编码为UTF-8字节字符串，但它被认为是非法的Unicode。</p><p> All of these examples can be used in a similar manner to the previous example and Lab 1. However, environments that allow encoding and decoding of illegal Unicode (e.g., Python 2.x) may be susceptible to complex attacks that require storage (serialization) and retrieval (deserialization) of these values.</p><p> 所有这些示例都可以与之前的示例和实验1相似的方式使用。但是，允许对非法Unicode进行编码和解码的环境（例如Python 2.x）可能容易受到需要存储（序列化）的复杂攻击的影响。并检索（反序列化）这些值。</p><p>  $ python2&gt;&gt;&gt; import json&gt;&gt;&gt; import ujson# Serialization into illegal unicode. &gt;&gt;&gt; u&#34;asdf\ud800&#34;.encode(&#34;utf-8&#34;)&#39;asdf\xed\xa0\x80&#39;# Reserializing illegal unicode&gt;&gt;&gt; json.dumps({&#34;test&#34;: &#34;asdf\xed\xa0\x80&#34;})&#39;{&#34;test&#34;: &#34;asdf\\ud800&#34;}&#39;# Let&#39;s observe the third party parser ujson&#39;s truncation behavior and how it creates a duplicate key.&gt;&gt;&gt; ujson.loads(&#39;{&#34;test&#34;: 1, &#34;test\\ud800&#34;: 2}&#39;){u&#39;test&#39;: 2}</p><p>  $ python2＆gt;＆gt;＆gt;导入json＆gt;＆gt;＆gt;将ujson＃序列化导入非法unicode。 ＆gt;＆gt;＆gt; u＆asdf \ ud800＆＃34; .encode（＆＃34; utf-8＆＃34;）＆＃39; asdf \ xed \ xa0 \ x80＆＃39;＃重新序列化非法Unicode＆gt;＆gt;＆gt; json.dumps（{＆＃34; test＆＃34 ;:＆＃34; asdf \ xed \ xa0 \ x80＆＃34;}）＆＃39; {＆＃34; test＆＃34 ;:＆＃34; asdf \ \ ud800＆＃34;}＆＃39;让我们观察第三方解析器ujson的截断行为及其如何创建重复密钥。 ujson.loads（＆＃39; {＆＃34; test＆＃34 ;: 1，＆＃34; test \\ ud800＆＃34 ;: 2}＆＃39;）{u＆＃39; test＆＃39 ;: 2 } </p><p> As we will see in our next example, an attacker can use this functionality to bypass sanitization checks, e.g., to create and store a role called      superadmin\ud888 that may be retrieved and parsed as      superadmin. However, this technique requires support for encoding and decoding illegal Unicode codepoints (not so hard), as well as a database with a type system that won&#39;t throw exceptions (harder).</p><p>如我们在下一个示例中将看到的，攻击者可以使用此功能绕过清理检查，例如，创建并存储一个名为superadmin \ ud888的角色，该角色可以检索并解析为superadmin。但是，此技术需要支持对非法Unicode代码点进行编码和解码（不是那么难），以及具有不会抛出异常的类型系统的数据库（更难）。</p><p> For the following lab, we will use Python 2.7 and MySQL in binary mode to allows us to focus on the risks of storing illegal unicode and its effect on inconsistent JSON parsing.</p><p> 在以下实验中，我们将以二进制模式使用Python 2.7和MySQL，以使我们能够专注于存储非法Unicode的风险及其对不一致的JSON解析的影响。</p><p>  Let&#39;s consider a multi-tenant application where an organization admin is able to create custom user roles. Additionally, we know that users who have cross-organizational access are assigned the internal role      superadmin. Let’s attempt to escalate privileges. This example will use the design shown below:</p><p>  让我们考虑一个多租户应用程序，组织管理员可以在该应用程序中创建自定义用户角色。此外，我们知道具有跨组织访问权限的用户被分配了内部角色超级管理员。让我们尝试提升特权。本示例将使用如下所示的设计：</p><p>   POST /user/create HTTP/1.1...Content-Type: application/json{ &#34;user&#34;: &#34;exampleUser&#34;, &#34;roles&#34;: [ &#34;superadmin&#34; ]}HTTP/1.1 401 Not Authorized...Content-Type: application/json{&#34;Error&#34;: &#34;Assignment of internal role &#39;superadmin&#39; is forbidden&#34;}</p><p>   POST / user / create HTTP / 1.1 ... Content-Type：application / json {＆＃34; user＆＃34 ;:＆＃34; exampleUser＆＃34 ;,＆＃34; roles＆＃34 ;: [＆＃34 ;超级管理员]} HTTP / 1.1 401未经授权...内容类型：application / json {＆＃34; Error＆＃34 ;：＆＃34;内部角色分配＆＃39; superadmin＆＃39;被禁止＆＃34;}</p><p>  As shown above, the User API has a server-side security control to block users from creating new users with the      superadmin role. This control is shared by the Roles API to avoid overwriting existing user-defined and system roles. Here, we&#39;ll assume our      /user/ and      /role/ endpoints on the User API use well-behaved, compliant parsers.</p><p>  如上所示，用户API具有服务器端安全控件，以阻止用户创建具有superadmin角色的新用户。角色API共享此控件，以避免覆盖现有的用户定义角色和系统角色。在这里，我们将假设User API上的/ user /和/ role /端点使用行为良好的兼容解析器。</p><p> Instead, with the aim of affecting a downstream parser, we&#39;ll create a role with a name that is unstable across parsers,      superadmin\ud888:</p><p> 相反，为了影响下游解析器，我们将创建一个角色，其名称在整个解析器中都是不稳定的，即superadmin \ ud888：</p><p>    POST /user/create HTTP/1.1...Content-Type: application/json{ &#34;user&#34;: &#34;exampleUser&#34;, &#34;roles&#34;: [ &#34;superadmin\ud888&#34; ]}HTTP/1.1 200 OK...Content-Type: application/json{&#34;result&#34;: &#34;OK: Created user &#39;exampleUser&#39;&#34;}</p><p>    POST / user / create HTTP / 1.1 ... Content-Type：application / json {＆＃34; user＆＃34 ;:＆＃34; exampleUser＆＃34 ;,＆＃34; roles＆＃34 ;: [＆＃34 ; superadmin \ ud888＆＃34; ]} HTTP / 1.1 200 OK ...内容类型：application / json {＆＃34; result＆＃34 ;：＆＃34; OK：创建的用户＆＃39; exampleUser＆＃39;＆＃34;} </p><p>  The User API stores the user into the database. Up until this point, all of the parsers see the user-defined role (     superadmin\ud888) as a distinct name from the internal role      superadmin.</p><p>用户API将用户存储到数据库中。到目前为止，所有解析器都将用户定义的角色（superadmin \ ud888）视为与内部角色superadmin不同的名称。</p><p> However, when later accessing the cross-organizational      /admin endpoint, the server requests the user&#39;s permissions from the Permissions API. The Permissions API faithfully encodes the role, as shown below:</p><p> 但是，当稍后访问跨组织的/ admin端点时，服务器从权限API请求用户权限。 Permissions API忠实地编码角色，如下所示：</p><p>   But here is where things go wrong: The admin API uses the third-party      ujson parser. As we saw earlier, this parser truncates any bytes that contain illegal codepoints:</p><p>   但是这里出了问题：管理API使用了第三方ujson分析器。如前所述，该解析器会截断包含非法代码点的所有字节：</p><p> @app.route(&#39;/admin&#39;)def admin(): username = request.cookies.get(&#34;username&#34;) if not username: return {&#34;Error&#34;: &#34;Specify username in Cookie&#34;} username = urllib.quote(os.path.basename(username)) url = &#34;http://permissions:5000/permissions/{}&#34;.format(username) resp = requests.request(method=&#34;GET&#34;, url=url) # &#34;superadmin\ud888&#34; will be simplified to &#34;superadmin&#34; ret = ujson.loads(resp.text) if resp.status_code == 200: if &#34;superadmin&#34; in ret[&#34;roles&#34;]: return {&#34;OK&#34;: &#34;Superadmin Access granted&#34;} else: e = u&#34;Access denied. User has following roles: {}&#34;.format(ret[&#34;roles&#34;]) return {&#34;Error&#34;: e}, 401 else: return {&#34;Error&#34;: ret[&#34;Error&#34;]}, 500</p><p> @ app.route（＆＃39; / admin＆＃39;）def admin（）：用户名= request.cookies.get（＆＃34;用户名＆＃34;）如果不是用户名：返回{＆＃34; Error＆＃34 ;：＆＃34;在Cookie中指定用户名＆＃34;}用户名= urllib.quote（os.path.basename（用户名））url =＆＃34; http：//权限：5000 / permissions / {}＆＃34 ; .format（用户名）resp = requests.request（方法=＆＃34; GET＆＃34 ;, url = url）＃＆＃34; superadmin \ ud888＆＃34;将简化为＆＃34; superadmin＆＃34; ret = ujson.loads（resp.text）如果resp.status_code == 200：如果＆＃34; superadmin＆＃34;在ret [＆＃34; roles＆＃34;]中：返回{＆＃34; OK＆＃34 ;：＆＃34;授予超级管理员访问权限＆＃34;}否则：e = u＆＃34;访问被拒绝。用户具有以下角色：{}＆＃34; .format（ret [＆＃34; roles＆＃34;]）返回{＆＃34; Error＆＃34 ;: e}，401其他：return {＆＃34; Error＆ ＃34;：ret [＆＃34; Error＆＃34;]}，500</p><p> As shown above, our user-defined role will be truncated to      superadmin, granting access to the privileged API.</p><p> 如上所示，我们的用户定义角色将被截断为超级管理员，从而​​授予对特权API的访问权限。</p><p>   Many JSON libraries support quoteless strings and comment syntax from JavaScript interpreter environments (e.g.,      /*,      */). However, neither of these features is part of the official specification. These features allow parsers to process documents like the following:</p><p>   许多JSON库都支持JavaScript解释器环境（例如/ *，* /）中的无引号字符串和注释语法。但是，这些功能都不是正式规范的一部分。这些功能使解析器可以如下处理文档：</p><p>  Given two parsers that support quoteless strings, but only one that recognizes comments, we can smuggle duplicate keys. Consider the example below:</p><p>  给定两个支持无引号的字符串的解析器，但是只有一个可以识别注释的解析器，我们可以走私重复的键。考虑下面的示例： </p><p>                So far, we&#39;ve only focused on JSON decoding, but nearly all implementations also offer JSON encoding (aka serialization). Let&#39;s look at a few examples.</p><p>到目前为止，我们只关注JSON解码，但是几乎所有实现都还提供JSON编码（也称为序列化）。让我们看几个例子。</p><p>  Conventional wisdom is to avoid duplicate keys, which is easy to do with internal services, but not possible to guarantee with external user input. So, not all parsers explore the behavior with duplicate keys. In one instance, a parser (Java&#39;s JSON-iterator) produced the following input and outputs:</p><p>  传统的观点是避免重复的键，这对于内部服务很容易实现，但是无法通过外部用户输入来保证。因此，并非所有解析器都使用重复键来探索行为。在一个实例中，解析器（Java的JSON-iterator）产生了以下输入和输出：</p><p>     As shown above, the values of key retrieval and serialization differ. The underlying data structure seems to have preserved the value of the duplicate key; however, the precedence between the serializer and deserializer was inconsistent.</p><p>     如上所示，密钥检索和序列化的值不同。底层的数据结构似乎保留了重复键的值。但是，序列化程序和反序列化程序之间的优先级不一致。</p><p>  Per the specification, it&#39;s acceptable to serialize duplicate keys, and some parsers (e.g., C++’s rapidjson) do just that:</p><p>  按照规范，序列化重复的密钥是可以接受的，某些解析器（例如C ++的Rapidjson）可以做到这一点：</p><p>     In these cases, reserializing parsed JSON objects does not provide protection. These serialization behaviors allow attackers to smuggle values across sanitization layers. As we saw previously, this can lead to business logic flaws, injection vulnerabilities, or other security impacts.</p><p>     在这些情况下，重新序列化已解析的JSON对象不会提供保护。这些序列化行为使攻击者可以跨消毒层走私价值。如我们先前所见，这可能导致业务逻辑缺陷，注入漏洞或其他安全影响。</p><p>   Now that we&#39;ve observed the many risks of duplicate keys, we&#39;ll examine number representation. First, let&#39;s look at an excerpt of the RFC discussing number interoperability:</p><p>   现在，我们已经观察到重复密钥的许多风险，我们将研究数字表示。首先，让我们看一下讨论数字互操作性的RFC摘录：</p><p> Since software that implements IEEE 754 binary64 (double precision) numbers [IEEE754] is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.  A JSON number such as 1E400 or 3.141592653589793238462643383279 may indicate potential interoperability problems, since it suggests that the software that created it expects receiving software to have greater capabilities for numeric magnitude and precision than is widely available.  Note that when such software is used, numbers that are integers and are in the range [-(2**53)+1, (2**53)-1] are interoperable in the sense that implementations will agree exactly on their numeric values.</p><p> 由于实现IEEE 754二进制64（双精度）数字[IEEE754]的软件通常可用并得到广泛使用，因此，期望实现的精度或范围不超过提供的精度或范围的实现可以实现良好的互操作性，在这种意义上，实现将在其中近似JSON数。预期的精度。诸如1E400或3.141592653589793238462643383279之类的JSON数字可能表示潜在的互操作性问题，因为它表明创建它的软件期望接收软件具有比广泛使用的更大的数字幅度和精度功能。请注意，使用此类软件时，整数表示并且在[-（2 ** 53）+1，（2 ** 53）-1]范围内的数字是可互操作的，因为实现将在数字上完全一致价值观。 </p><p>   When not decoded accurately, large numbers may be decoded as      MAX_INT or      0 (or      MIN_INT as we approach negative infinity). Across multiple parsers, we will find that a large number, such as:</p><p>如果解码不正确，则大数可能会解码为MAX_INT或0（或MIN_INT，因为我们接近负无穷大）。在多个解析器中，我们将发现大量的解析器，例如：</p><p>      Let&#39;s revisit Lab 1. We know that the third-party Golang jsonparser library used in the Payments API will decode large numbers to 0, while the Cart API will decode the number faithfully. We can exploit this inconsistency to get free items. Let&#39;s purchase a large quantity of e-gift cards (     id: 8):</p><p>      让我们重温实验1。我们知道，Payments API中使用的第三方Golang jsonparser库会将大数字解码为0，而Cart API将忠实地解码数字。我们可以利用这种不一致来获取免费物品。让我们购买大量的电子礼品卡（ID：8）：</p><p>  POST /cart/checkout HTTP/1.1...Content-Type: application/json{ &#34;orderId&#34;: 10, &#34;paymentInfo&#34;: { //... }, &#34;shippingInfo&#34;: { //... }, &#34;cart&#34;: [ { &#34;id&#34;: 8, &#34;qty&#34;: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 } ]}</p><p>  POST /购物车/结帐HTTP / 1.1 ...内容类型：application / json {＆＃34; orderId＆＃34 ;: 10，＆＃34; paymentInfo＆＃34 ;: {// ...}，＆＃34 ; shippingInfo＆＃34 ;: {// ...}，＆＃34; cart＆＃34 ;: [{＆＃34; id＆＃34 ;: 8，＆＃34; qty＆＃34 ;: 9999999999999999999999999999999999999999999999999999999999999999</p><p>   The business logic layer faithfully decodes the integer, while the payment processing layer defaults to the value 0 for large numbers.</p><p>   业务逻辑层忠实地解码该整数，而支付处理层默认为0表示大数。</p><p> Try this attack out in Lab 1: part 2 with the request in      lab1_alt_req.json. As described in the lab, the jsonparser library can detect this overflow with proper error checking.</p><p> 在Lab 1：第2部分中使用lab1_alt_req.json中的请求尝试这种攻击。如实验室中所述，jsonparser库可以通过适当的错误检查来检测到此溢出。</p><p>  Positive and negative infinity along with NaN (not a number) are not supported by the official RFC. But many parsers have chosen workarounds. Deserializing and/or reserializing values can lead to a variety of outcomes such as:</p><p>  正式RFC不支持正和负无穷大以及NaN（不是数字）。但是许多解析器都选择了解决方法。反序列化和/或重新序列化值可以导致多种结果，例如：</p><p>     Note the type conversions from a JSON number to a string. Type conversions in strict comparison can be benign but in loose comparisons can lead to type juggling vulnerabilities. Consider the following code (note: strings are interpreted as 0):</p><p>     请注意从JSON数字到字符串的类型转换。严格比较中的类型转换可能是良性的，但在宽松比较中可能导致类型变戏法的漏洞。考虑以下代码（注意：字符串被解释为0）： </p><p> &lt;?phpecho 0 == 1.0e4096 ? &#34;True&#34;: &#34;False&#34; . &#34;\n&#34;; # Falseecho 0 == &#34;Infinity&#34; ? &#34;True&#34;: &#34;False&#34; . &#34;\n&#34;; # True?&gt;</p><p>＆lt;？phpecho 0 == 1.0e4096？ ＆＃34;真＆＃34 ;：假＃＆＃34; 。 ＆＃34; \ n＆＃34 ;; ＃Falseecho 0 ==＆＃34; Infinity＆＃34; ？ ＆＃34;真＆＃34 ;：假＃＆＃34; 。 ＆＃34; \ n＆＃34 ;; ＃正确吗？＆gt;</p><p> As in previous examples, business logic layers may falsely validate values that are decoded inconsistently. Prefer strict comparison or perform type validation prior to usage.</p><p> 如在先前的示例中，业务逻辑层可能会错误地验证不一致解码的值。建议在使用前进行严格比较或执行类型验证。</p><p>   Some parsers were permissive of stray characters, alternative quote characters, and syntax errors in documents, while others had strict enforcement of the RFC-defined grammar. Let’s look at instances of permissive parsing that do not relate to duplicate keys.</p><p>   一些解析器允许杂散字符，替代引号字符和文档中的语法错误，而其他解析器则严格执行RFC定义的语法。让我们看一下与重复键无关的许可解析实例。</p><p>  Allowing trailing garbage is a well-known issue with many JSON parsers that has been misused for many years to conduct cross-site request forgery (CSRF) attacks. To bypass same-origin policy (SOP) “simple request” limitations, a JSON document can be posted with a trailing equals sign to suggest a      x-form-urlencoded document, which is permitted in cross-origin requests. For example:</p><p>  对于许多JSON解析器来说，允许尾随垃圾是一个众所周知的问题，多年来一直被滥用以进行跨站点请求伪造（CSRF）攻击。为了绕过同源策略（SOP）的``简单请求''限制，可以在JSON文档中添加尾随等号来建议x形式的通用编码文档，这在跨域请求中是允许的。例如：</p><p>  Services that disregard the      Content-Type and process all requests as JSON will be exposed to these types of CSRF attacks.</p><p>  忽略Content-Type并以JSON处理所有请求的服务将受到这些CSRF攻击。</p><p>  Two parsing libraries crashed on malformed JSON. Both of these instances have been reported to the</p><p>  两个解析库在格式错误的JSON上崩溃。这两种情况都已报告给</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://labs.bishopfox.com/tech-blog/an-exploration-of-json-interoperability-vulnerabilities">https://labs.bishopfox.com/tech-blog/an-exploration-of-json-interoperability-vulnerabilities</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/互操作性/">#互操作性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>