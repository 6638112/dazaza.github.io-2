<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#编译</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#编译</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021850.html">关于编译器警告设计的两点思考</a></div><div class="item_title_en"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/09/02/wparentheses/">Two musings on the design of compiler warnings</a><span>(quuxplusone.github.io)</span></div><span class="my_story_list_date">2020-9-3 8:58</span><div class="my_story_list_item_desc">今天，我终于写下了一些关于编译器诊断设计的两个外围方面的思考，我认为这两个方面对某些类型的警告非常重要，我的第一个思考是关于修复程序，第二个是关于抑制机制。
现在大多数C++编译器并不只是告诉你发生了问题(就像ed的有名的？提示符)，以及问题是什么(例如，“预期标识符”)，他们会试图告诉您如何解决问题。
将GCC 4......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/警告/">#警告</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021605.html">编译器的深度学习</a></div><div class="item_title_en"><a target="_blank" href="https://era.ed.ac.uk/handle/1842/36866">Deep Learning for Compilers</a><span>(era.ed.ac.uk)</span></div><span class="my_story_list_date">2020-9-1 22:59</span><div class="my_story_list_item_desc">构建编译器很困难。优化编译器是耗资数百万美元的项目多年来的发展，但仍然无法充分利用可用的性能，并且很容易被窃听。快速过渡到异构并行和多样化的体系结构提高了对积极优化编译器的需求一直居高不下，使得编译器开发人员难以跟上。我们需要的是简化编译器构造的更好工具。本文提出了显著降低编译器成本的新技术构造，同时提......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/深度学习/">#深度学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/深度/">#深度</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learning/">#learning</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021570.html">一种基于神经网络的程序反编译器(2019)</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/1906.12029">A Neural-Based Program Decompiler (2019)</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-9-1 16:6</span><div class="my_story_list_item_desc">下载PDF摘要：二进制可执行文件的逆向工程是计算机安全领域的一个关键问题。一方面，恶意方可能会从软件产品中找回可解释的源代码，以获取商业优势。另一方面，二进制反编译可用于代码漏洞分析和恶意软件检测。然而，高效的二进制反编译是具有挑战性的。传统的反编译器有以下主要局限性：(I)它们只适用于特定的源-目标语言程序，因此为......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/神经网络/">#神经网络</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/coda/">#coda</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021239.html">保证优化：证明编译器的零空间性质(2002)</a></div><div class="item_title_en"><a target="_blank" href="https://help.luddy.indiana.edu/techreports/TRNNN.cgi?trnum=TR564">Guaranteed Optimization: Proving Nullspace Properties of Compilers (2002)</a><span>(help.luddy.indiana.edu)</span></div><span class="my_story_list_date">2020-8-30 10:7</span><div class="my_story_list_item_desc">编写性能关键型程序可能会令人沮丧，因为为命令式语言优化编译器往往是不可预测的。对于优化的子集--那些简化而不是重新排序代码的优化--证明编译器可靠地执行优化将是有用的。我们表明，采用“超分析”的方法进行优化可以证明这一点。通过与线性代数类比，我们将优化器的零空间定义为它归结为空程序的程序。为了跨越空空间，我们定义了通......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/优化/">#优化</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021198.html">铁锈编译器开发指南</a></div><div class="item_title_en"><a target="_blank" href="https://rustc-dev-guide.rust-lang.org/">Guide to the Rust Compiler Development</a><span>(rustc-dev-guide.rust-lang.org)</span></div><span class="my_story_list_date">2020-8-30 3:39</span><div class="my_story_list_item_desc">本指南旨在帮助记录Rustc(Rust编译器)是如何工作的，并帮助新的贡献者参与到Rustc开发中来。
构建和调试rustc：包含无论您如何贡献都应该有用的信息，关于构建、调试、概要分析等。
贡献给Rustc：包含无论您如何贡献都应该有用的信息，关于贡献的程序、稳定特性等。
高级编译器体系结构：讨论编译器的高级体系结......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rustc/">#rustc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020193.html">BPF可移植性和CO-Re(随处运行一次编译)</a></div><div class="item_title_en"><a target="_blank" href="https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html">BPF Portability and CO-Re (Compile Once Run Everywhere)</a><span>(facebookmicrosites.github.io)</span></div><span class="my_story_list_date">2020-8-25 21:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1020193.html"><img src="http://img.diglog.com/img/2020/8/thumb_9bd778cfcc328679893c549d5c444b89.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">可移植性在BPF上下文中意味着什么？编写开发人员需要处理的可移植BPF程序的挑战是什么？这篇文章将描述BPF的可移植性问题，以及BPF CO-RE(编译一次，随处运行)是如何帮助解决这个问题的。
自从(E)BPF诞生以来，对BPF社区来说，尽可能简化BPF应用程序的开发，使其体验像用户空间应用程序一样简单和熟悉，一直......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bpf/">#bpf</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020018.html">一个简单的模式编译器(1997)</a></div><div class="item_title_en"><a target="_blank" href="https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v14/schintro_142.html#SEC271">A Simple Scheme Compiler (1997)</a><span>(www.cs.utexas.edu)</span></div><span class="my_story_list_date">2020-8-24 19:8</span><div class="my_story_list_item_desc">现在，当我们开始编译时，我们只需处理一种事情--整个过程，当我们拿回结果代码并将其打包以运行它时，我们将始终处理整个过程的代码。这使得创建要调用的实际闭包变得很容易。
我们用来开始编译的主要例程是Compile-Procedure，它以表达式、编译时环境、编译时连续和文字列表作为参数。它返回过程的中间代码和更新后的文......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模式/">#模式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scheme/">#scheme</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019940.html">编写一个简单的Python到C编译器：你好，斐波纳契</a></div><div class="item_title_en"><a target="_blank" href="https://notes.eatonphil.com/writing-a-simple-python-compiler.html">Writing a simple Python to C compiler: hello, fibonacci</a><span>(notes.eatonphil.com)</span></div><span class="my_story_list_date">2020-8-24 2:51</span><div class="my_story_list_item_desc">在这篇文章中，我们将用Python编写一个Python到C的编译器。这特别容易做到，因为Python有一个内置的解析库，而且许多CPython内部都向扩展编写者公开。
在本文结束时，只要几百行Python代码，我们就可以编译并运行以下程序：
$cat tests/recursive_fib.pydef fib(N)：......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ctx/">#ctx</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019627.html">但我在帮助编译器</a></div><div class="item_title_en"><a target="_blank" href="https://pankajraghav.com/2020/08/16/RVO.html">But I was helping the compiler</a><span>(pankajraghav.com)</span></div><span class="my_story_list_date">2020-8-22 1:6</span><div class="my_story_list_item_desc">编译器在每个版本中都变得越来越好。有时，在同一编译器的不同版本中，同一段代码的汇编输出可以观察到明显的差异(可以通过编译器资源管理器轻松地完成)。
最近，我开始了检查程序集输出的实践，以分析各种实现的开销。当心，有时它会让人上瘾。但我认为这是学习阅读汇编语言的一种很好的方式，同时也会惊讶于现在的编译器是多么聪明。
在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/帮助/">#帮助</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/helping/">#helping</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018788.html">一种用于三维机织的编译器</a></div><div class="item_title_en"><a target="_blank" href="https://studios.disneyresearch.com/2016/07/10/a-compiler-for-3d-machine-knitting/">A Compiler for 3D Machine Knitting</a><span>(studios.disneyresearch.com)</span></div><span class="my_story_list_date">2020-8-18 7:53</span><div class="my_story_list_item_desc">我们提出了一个编译器，它可以自动将高级形状基元(管、板)的汇编转换为低级机器指令。
工业针织机可以在没有人工干预的情况下快速生产精细的、无缝的3D表面。然而，用于对它们进行编程的工具需要详细的操作和对低级针织操作的理解。我们提出了一个编译器，它可以自动将高级形状基元(管、板)的汇编转换为低级机器指令。这些高级形状基元......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/机织/">#机织</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/machine/">#machine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方式/">#方式</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018508.html">具有强类型的类NIM-Python编译语言</a></div><div class="item_title_en"><a target="_blank" href="https://nim-lang.org/">Nim – Python-like compiled language with strong types</a><span>(nim-lang.org)</span></div><span class="my_story_list_date">2020-8-17 0:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1018508.html"><img src="http://img.diglog.com/img/2020/8/thumb_a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">NIM是一种静态类型的编译系统编程语言。它结合了成熟语言(如Python、Ada和Moda)的成功概念。
NIM生成本地无依赖关系的可执行文件，不依赖于虚拟机，这些文件很小，很容易重新分发。
NIM编译器和生成的可执行文件支持所有主要平台，如Windows、Linux、BSD和MacOS。
受C++和Rust的启发，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nim/">#nim</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017900.html">我们能比我们的C编译器做得更好吗？</a></div><div class="item_title_en"><a target="_blank" href="https://briancallahan.net/blog/20200812.html">Can we do better than our C compiler?</a><span>(briancallahan.net)</span></div><span class="my_story_list_date">2020-8-13 13:22</span><div class="my_story_list_item_desc">今天，我想成为一名C编译器。我从前面的编码练习中添加了一个手工编译的ECHO汇编版本，并添加了一个新的make目标make asm，它将对其进行汇编。让我们看看我们手工编译的程序集，并将其与我们的C编译器进行比较，然后问问它是否值得。
.text.p2ign 2.globl main.type main，@funct......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/argv/">#argv</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016695.html">编译器编号，以及为什么它们无关紧要</a></div><div class="item_title_en"><a target="_blank" href="https://briancallahan.net/blog/20200806.html">Compiler numbers, and why they don't matter</a><span>(briancallahan.net)</span></div><span class="my_story_list_date">2020-8-7 2:18</span><div class="my_story_list_item_desc">使测量二进制大小变得如此困难的原因之一是，编译器可以在幕后执行很多可能导致二进制大小不同的工作，这也是为什么，尽管将其用作SnakeQR的粗略度量，我并不认为它是一个比较度量。对我们来说幸运的是，我们再也不用太担心二进制文件的大小了。不过，让我们来比较一下，只是为了好玩。
我们将比较clang 8.0.1和clang......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编号/">#编号</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/numbers/">#numbers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016549.html">编译器/ISA资源管理器：请参阅不同编译器的ARM、RISCV、x86输出</a></div><div class="item_title_en"><a target="_blank" href="https://godbolt.org/">Compiler / ISA explorer: see ARM, RISCV, x86 output for different compilers</a><span>(godbolt.org)</span></div><span class="my_story_list_date">2020-8-6 7:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1016549.html"><img src="http://img.diglog.com/img/2020/8/thumb_fe137f795d7a9df985fdb60dd4d99242.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">编译器资源管理器是一个交互式在线编译器，它显示编译后的C++、Rust、Go(以及更多)代码的汇编输出。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/isa/">#isa</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016340.html">如何在2020年内进一步提高Rust编译器的速度</a></div><div class="item_title_en"><a target="_blank" href="https://blog.mozilla.org/nnethercote/2020/08/05/how-to-speed-up-the-rust-compiler-some-more-in-2020/">How to speed up the Rust compiler some more in 2020</a><span>(blog.mozilla.org)</span></div><span class="my_story_list_date">2020-8-5 13:7</span><div class="my_story_list_item_desc">我上一次写这篇文章是在4月份，讲述了我在加速Rust编译器方面所做的工作。又到了更新的时间了。
首先是流程改变：我已经开始每周进行性能分类。每周二，我都会查看过去一周合并的所有公关的业绩结果。对于性能下降或提高了不可忽略的每个PR，我都会向PR添加一条注释，并提供指向测量结果的链接。我还将这些结果收集到一份每周报告中......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进一步提高/">#进一步提高</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014655.html">正则表达式可视化、模拟器和交叉编译工具</a></div><div class="item_title_en"><a target="_blank" href="https://blog.robertelder.org/regular-expression-visualizer/">The Regular Expression Visualizer, Simulator and Cross-Compiler Tool</a><span>(blog.robertelder.org)</span></div><span class="my_story_list_date">2020-7-28 21:24</span><div class="my_story_list_item_desc">本文是正则表达式系列的一部分。*有关要可视化的更多正则表达式示例，请查看此正则表达式测试用例列表。
下面的C源代码是上面生成的任何代码示例所需的公共代码。只需将以下代码与上面动态生成的代码一起复制并粘贴到名为main.c&39；的文件中，即可生成执行您想要的正则表达式搜索的硬编码程序。确保在上面动态生成的代码之前传递......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/可视化/">#可视化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/正则表达式/">#正则表达式</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014241.html">Langcraft：将LLVM IR编译为“我的世界”数据包</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/SuperTails/langcraft">Langcraft: Compile LLVM IR to Minecraft data packs</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-26 17:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1014241.html"><img src="http://img.diglog.com/img/2020/7/thumb_d762b13b874e4d5d38cd413d83c5baec.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Langcraft是一个针对“我的世界”数据包的代码生成器。它目前可以毫无问题地运行相当多的位码文件。该项目有一个内置的命令解释器，用于调试，支持断点(ISH)和检查寄存器/内存值。所有生成的数据包都可以在不到5分钟的时间内在真实的Mincraft Java Edition 1.16+环境中运行。
将整个输出文件夹(......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/llvm/">#llvm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据包/">#数据包</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013664.html">将SARS-CoV-2基因组反编译成可读的功能</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nqureshi/sars-cov-2/blob/master/SARS-Cov-2.ipynb">Decompiling the SARS-CoV-2 genome into readable functions</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-23 10:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013664.html"><img src="http://img.diglog.com/img/2020/7/thumb_3a1170a6fcffe40776f779ec7de87405.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">PermalLink GitHub是5000多万开发人员的家园，他们一起工作，共同托管和审查代码、管理项目和构建软件。
报名</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cov/">#cov</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sars/">#sars</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/审查/">#审查</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013424.html">火箭现在可以在稳定的铁锈上编译</a></div><div class="item_title_en"><a target="_blank" href="https://www.reddit.com/r/rust/comments/hviz2q/rocket_can_now_compile_on_stable_rust/">Rocket can now compile on stable Rust</a><span>(www.reddit.com)</span></div><span class="my_story_list_date">2020-7-22 14:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013424.html"><img src="http://img.diglog.com/img/2020/7/thumb_0cb7eb9181a290b41c61dee3c3dde806.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">级别1火箭的最终上游依赖已经更新，允许在稳定上编译，所以塞尔吉奥-贝尼特斯/火箭的主分支现在可以在稳定上编译了！
级别1我很高兴看到这一点&#34；Rocket是Rust的异步Web框架，关注可用性、安全性、可扩展性和速度。
级别2我刚刚给你的网站加了书签，看起来上面有很多很棒的内容。我对Reaction/Node很......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/火箭/">#火箭</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013322.html">编译器基准测试</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nordlow/compiler-benchmark">Compiler Benchmark</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-22 2:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013322.html"><img src="http://img.diglog.com/img/2020/7/thumb_2d9745cfe2a1ae038646d105cceecc63.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这将在生成的目录中生成代码，然后针对语言、操作类型和编译器的每种组合，运行支持的基准测试。最后，一个显示基准结果的Markdown格式表被打印到标准输出。
GCC和克朗并没有为C++执行所有的语义检查(因为它太昂贵了)。这与执行所有这些任务的D&39；s和Rust&#39；编译器形成了鲜明对比。
LONG ADD_L......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基准/">#基准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/long/">#long</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012823.html">CUCU：一个你能理解的编译器(1/3)</a></div><div class="item_title_en"><a target="_blank" href="https://zserge.com/posts/cucu-part1/">Cucu: A compiler you can understand (1/3)</a><span>(zserge.com)</span></div><span class="my_story_list_date">2020-7-19 10:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012823.html"><img src="http://img.diglog.com/img/2020/7/thumb_3cd67f8c773c5df13d60d9d2e7f8918c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我会试着告诉你这有多简单。第一部分很有理论性，所以要有耐心。
CUCU是玩具语言的玩具编译器。我希望它尽可能接近ANSI CA，这样每个有效的CUCU程序都可以用C编译器编译，没有任何错误。当然，整个ANSI C标准的支持非常困难，所以我选择了一个非常小的C语言子集。
Int cucu_strlen(char*s){......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/理解/">#理解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/expr/">#expr</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012360.html">让我们做一个Teeny Tiny编译器</a></div><div class="item_title_en"><a target="_blank" href="http://austinhenley.com/blog/teenytinycompiler1.html">Let's make a Teeny Tiny compiler</a><span>(austinhenley.com)</span></div><span class="my_story_list_date">2020-7-17 2:16</span><div class="my_story_list_item_desc">外面天气很好，让我们做个编译器吧。您不需要任何关于编译器如何工作的知识就可以跟上。我们将使用Python来实现我们自己的编程语言Teeny Tiny，它将编译成C代码。它将需要大约500行代码，并提供定制编译器所需的初始基础设施，并将其扩展为您自己的数十亿美元的生产就绪编译器。
本教程是一系列帖子，循序渐进地构建可工......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tiny/">#tiny</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011578.html">编译时在Apple Silicon的MacOS上从源码段错误构建灵丹妙药</a></div><div class="item_title_en"><a target="_blank" href="https://groups.google.com/forum/#!msg/elixir-lang-core/9s6-BIxaCz8/i-NmhjabAQAJ">Building Elixir from source segfaults on macOS on Apple Silicon while compiling</a><span>(groups.google.com)</span></div><span class="my_story_list_date">2020-7-14 2:27</span><div class="my_story_list_item_desc">Google群组允许您创建并参与在线论坛和基于电子邮件的群组，这些群组具有丰富的社区对话体验。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/silicon/">#silicon</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/群组/">#群组</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011559.html">C++编译器中的优化</a></div><div class="item_title_en"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=3372264">Optimizations in C++ Compilers</a><span>(queue.acm.org)</span></div><span class="my_story_list_date">2020-7-14 1:17</span><div class="my_story_list_item_desc">2019年11月12日第17卷第5期编译器是将高级的、更容易编写的代码转化为高效的机器代码以供计算机执行的必备技术。他们在做这件事上的老练经常被忽视。您可能会花费大量时间仔细考虑算法和处理错误消息，但可能没有足够的时间来了解编译器能够做些什么。
本文介绍了一些编译器和代码生成概念，然后介绍了您的编译器正在为您完成的一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010827.html">GCC编译器针对ARM直线投机漏洞的土地保护</a></div><div class="item_title_en"><a target="_blank" href="https://www.phoronix.com/scan.php?page=news_item&px=GCC-Lands-SLS-Mitigation">GCC Compiler Lands Mitigation for Arm's Straight Line Speculation Vulnerability</a><span>(www.phoronix.com)</span></div><span class="my_story_list_date">2020-7-10 0:44</span><div class="my_story_list_item_desc">在ARM披露CPUSLS漏洞和LLVM编译器初始缓解后花了一个月的时间，但GNU编译器集合(GCC)现在也针对此直线推测漏洞进行了缓解。(注：Gnu Compiler Collection(Gnu Compiler Collection，GNU Compiler Collection)(GCC))现在也针对此直线推测......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/直线/">#直线</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓解/">#缓解</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010519.html">使用SymCC执行符号：不解释，编译</a></div><div class="item_title_en"><a target="_blank" href="http://www.s3.eurecom.fr/tools/symbolic_execution/symcc.html">Symbolic execution with SymCC: Don't interpret, compile</a><span>(www.s3.eurecom.fr)</span></div><span class="my_story_list_date">2020-7-8 19:55</span><div class="my_story_list_item_desc">美国马萨诸塞州波士顿，第29届USENIX安全研讨会(USENIX Security 20)论文集实用符号执行的一个主要障碍是速度，特别是与模糊测试等接近本地速度的解决方案相比。我们提出了一种基于编译的符号执行方法，其性能比最先进的实现要好几个数量级。我们介绍了SymCC，这是一个基于LLVM的C和C++编译器，它将......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/symcc/">#symcc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/execution/">#execution</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010197.html">Go与C#：编译器、运行时、类型系统、模块</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/servicetitan-engineering/go-vs-c-part-3-compiler-runtime-type-system-modules-and-everything-else-faa423dddb34">Go vs. C#: Compiler, Runtime, Type System, Modules</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-7 5:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010197.html"><img src="http://img.diglog.com/img/2020/7/thumb_fe5ff336acc9de4afb0853043ce93294.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是系列文章中的最后一篇，也是最有趣的一篇。第1部分和第2部分重点介绍了Golang-Goroutines和几乎停顿的GC的两个关键特性。这篇帖子补充了所有缺失的部分。
但是，在如何实现所有这些功能方面，有更多的不同之处而不是相似之处。让我们跳到这些内容：)。
Go编译成本机二进制文件--也就是说，它的二进制文件“绑......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010110.html">即时编译器速成课程(2017)</a></div><div class="item_title_en"><a target="_blank" href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">A crash course in just-in-time compilers (2017)</a><span>(hacks.mozilla.org)</span></div><span class="my_story_list_date">2020-7-6 21:19</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010110.html"><img src="http://img.diglog.com/img/2020/7/thumb_88ff4dec58afa367d96369000fda9bc3.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是关于WebAssembly的系列文章的第二部分，以及它的快速之处。如果您还没有阅读其他内容，我们建议从头开始。
JavaScript一开始速度很慢，但后来变得更快，这要归功于一种名为JIT的东西。但是JIT是如何运作的呢？
当您作为开发人员将JavaScript添加到页面时，您有一个目标和一个问题。
你说的是人类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/速成/">#速成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010014.html">实现了快速的JIT编译器：Julia、PyPy、LuaJIT、Graal等</a></div><div class="item_title_en"><a target="_blank" href="https://carolchen.me/blog/jits-impls/">JIT Compilers Are Implemented and Fast: Julia, PyPy, LuaJIT, Graal and More</a><span>(carolchen.me)</span></div><span class="my_story_list_date">2020-7-6 5:13</span><div class="my_story_list_item_desc">这篇文章详细介绍了5+JIT和各种优化策略，并讨论了它们如何与不同的JIT协同工作。这篇博文中的信息是深度优先的，因此有许多重要的概念可以跳过。
有关JIT编译器的背景信息，请参阅JIT编译器深度介绍：JIT不是非常及时的。如果标题对你没有意义，那么它可能值得浏览一下。
我经常描述一种优化行为，并声称它可能存在于其他......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009973.html">JIT编译器深度介绍：JIT不是即时的</a></div><div class="item_title_en"><a target="_blank" href="https://carolchen.me/blog/jits-intro/">A Deep Introduction to JIT Compilers: JITs Are Not Just-in-Time</a><span>(carolchen.me)</span></div><span class="my_story_list_date">2020-7-6 3:2</span><div class="my_story_list_item_desc">如果您熟悉JIT的一般工作方式(如果您理解了标题所指的内容)，我建议您略读这篇文章，或者直接阅读JIT编译器是如何实现和快速的：Julia、PyPy、LuaJIT、Graal等。
我的导师克里斯把我从“什么是JIT”带到了我现在所处的位置，他曾经告诉我，编译器只是以字节为单位输出的，根本不是低级的和可怕的。这实际上是......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jit/">#jit</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/编译/">0</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page3.html">3</a></li><li class="page-item active"><a class="page-link" href="/tag/编译/page4.html">4</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page5.html">5</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page6.html">6</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>