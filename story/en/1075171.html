<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>字典压缩Dictionary Compression</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dictionary Compression<br/>字典压缩</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-03-02 22:46:02</div><div class="page_narrow text-break page_content"><p>Posted   A certain  5-letter word game has gotten really popular recently. A peek at the source shows an interesting choice for implementing the dictionary of allowed guesses and the answer list.</p><p>最近，一款5个字母的文字游戏非常流行。浏览一下源代码，就可以看到实现允许猜测字典和答案列表的一个有趣的选择。</p><p> The list of secret words is just sitting in the code, the word is picked based on the user’s local date.</p><p>秘密单词的列表就在代码中，这个单词是根据用户的本地日期选择的。</p><p> The first point is clever. It means that they don’t need to update the backend every day (or have logic on the backend) and it automatically switches at midnight for each user, not some random time of day based on the server’s midnight.</p><p>第一点很聪明。这意味着他们不需要每天更新后端（或者后端有逻辑），它会在午夜为每个用户自动切换，而不是根据服务器的午夜随机切换。</p><p> The other two surprised me. I would have expected at least some simple domain-specific compression. Also, I would have expected the answers list to just be pointers into the dictionary, rather than a separate list (which requires the validation code to check both lists every time you submit a word).</p><p>另外两个让我吃惊。我希望至少有一些简单的特定领域的压缩。此外，我希望答案列表只是字典中的指针，而不是单独的列表（每次提交单词时都需要验证代码检查两个列表）。</p><p> I thought to myself how I would implement this, and from there started wondering about how to optimize it.  A post about compressing the dictionary to fit on a Game Boy then added fuel to the fire, and eventually I cracked. I spend a fun day trying different things, and here are my findings.  All the code backing this study is open source and can be viewed here.</p><p>我想我将如何实现这一点，并从那里开始思考如何优化它。一篇关于将字典压缩到适合一个游戏机的帖子，然后火上浇油，最终我崩溃了。我花了一天的时间尝试不同的事情，以下是我的发现。支持这项研究的所有代码都是开源的，可以在这里查看。</p><p> Note: For this analysis I am using  this archive of the original Wordle. The dictionary and answers have changed over time. I don’t expect any changes to make much difference to this analysis. For all general-purpose compression I am using  zstd since it is a very high quality compressor.</p><p>注意：对于这个分析，我使用的是原始单词的档案。随着时间的推移，字典和答案都发生了变化。我认为任何改变都不会对这一分析产生太大影响。对于所有的通用压缩，我使用的是zstd，因为它是一个非常高质量的压缩机。</p><p>  My requirements are pretty simple. I’ll assume a browser target, and I’m going to see how best to get the data there. I’m going to assume I can send binary data, and I’ll also approximate decoder size to ensure that I am not just moving data into the decoder. However, in practice, this wasn’t an issue for any of my solutions.</p><p>我的要求很简单。我将假设一个浏览器目标，我将看看如何最好地在那里获取数据。我将假设我可以发送二进制数据，并且我还将估计解码器的大小，以确保我不只是将数据移动到解码器中。然而，在实践中，这不是我的任何解决方案的问题。</p><p> Measuring code size it is very difficult due to WASM overhead and Rust error handling overhead. To normalize for this I will be taking the code size of the smallest implementation ( bitmap at 1347 B) and subtract the difference in size of the same when implemented with no possibility of panic (234 B). This means that the code sizes seen in this post will be 1113 B less than the actual compressed size. This should roughly account for the overhead of the Rust panic infrastructure. I think this makes sense because unless you are implementing just this one function in WASM you will have to pay this cost anyway, and this isn’t storing any domain-specific data. I also didn’t feel like implementing each one with unsafe to avoid the chance of panic due to slice bounds checking. This is not very scientific and mostly makes sure that no implementation results in a huge code size.</p><p>由于WASM开销和Rust错误处理开销，测量代码大小非常困难。为了对此进行规范化，我将采用最小实现的代码大小（位图为1347） B） 并减去在没有恐慌可能性的情况下实施时的大小差异（234 B） 。这意味着本文中看到的代码大小将比实际压缩大小小1113b。这应该大致说明基础设施的开销。我认为这是有意义的，因为除非您在WASM中只实现这一个函数，否则您将不得不支付这一成本，而且这并没有存储任何特定于域的数据。我也不想用“不安全”来实现每一个，以避免切片边界检查带来的恐慌。这不是很科学，主要是确保没有实现会导致巨大的代码量。</p><p> I also want to ensure that the encoding is feasible for interactive use. I’ll target 50 ms to leave lots of room in the 100 ms threshold for other work. In practice this isn’t an issue for any of my solutions by a couple orders of magnitude. All times in this article were taken by counting the average time to check all possible valid or invalid words in a random order on an AMD 5950X. This is not particularly scientific because the branch predictor will quickly learn to always say yes or no and the timings were just run once but since I am so far under my time requirement it doesn’t seem important.</p><p>我还想确保编码对于交互使用是可行的。我的目标是50 女士在100号房间里留了很多空间 ms是其他工作的门槛。实际上，对于我的任何解决方案来说，这都不是一个数量级的问题。本文中的所有时间都是通过计算平均时间，在AMD5950X上以随机顺序检查所有可能的有效或无效单词。这并不特别科学，因为分支预测器将很快学会总是说是或否，并且计时只运行了一次，但由于我目前还没有达到时间要求，这似乎并不重要。</p><p>  First, let’s see how the simplest options will work. The game has 12 972 words in the dictionary, 2315 answers, and 10 657 guessable words. In the game these are JSON encoded in two separate lists. Let’s see how big these are. For the “both” I took the best-case scenario of simply concatenating them with not even a newline between them.</p><p>首先，让我们看看最简单的选项是如何工作的。这场比赛有12场 字典里有972个单词，2315个答案，10个单词 657个可猜单词。在游戏中，这些是JSON编码在两个单独的列表中。让我们看看这些有多大。对于“两者”，我采用了最好的情况，即简单地将它们连接起来，而不是在它们之间换行。</p><p>  Let’s be honest. Less than 25 KiB for your app data is not much these days. But let’s see how much better we can do.</p><p>说实话。不到25 如今，应用程序数据的KiB已经不多了。但让我们看看我们能做得多好。</p><p>  First, let’s try putting the words into a single list. This should allow for better compression because all the words are in order, not the randomized order for the answers. (Notice that the answers only compressed down to ⅓ of their size whereas the full dictionary compressed down to almost ⅕. I assume that a lot of this is the unpredictable ordering.) However, at the same time, I’m also dropping the JSON encoding. I’m just concatenating all the 5-letter words. This saves me three characters ( &#34;,&#34;) on every entry which is a ⅜ savings (although these characters likely compress very well).</p><p>首先，让我们试着把单词放在一个列表中。这应该允许更好的压缩，因为所有单词都是按顺序排列的，而不是答案的随机顺序。（请注意，答案仅限于⅓ 而完整的字典压缩到几乎⅕. 我认为这其中很大一部分是不可预测的顺序。）然而，与此同时，我也放弃了JSON编码。我只是把所有5个字母的单词连在一起。这为我节省了三个字符（&#34；，&#34；）在每一个属于⅜ 节省（尽管这些字符可能压缩得很好）。</p><p> As for lookup, I’m doing a binary search. It isn’t necessary to hit my performance target but significantly speeds up my exhaustive testing. Plus the added code size is tiny.</p><p>至于查找，我正在进行二进制搜索。没有必要达到我的性能目标，但可以显著加快我的全面测试。另外，增加的代码大小很小。</p><p>   While our size dropped significantly from removing the JSON the compression became less effective and we ended up saving less than 2%. If you add on 2 bytes per answer to regain the answer list you basically break even.</p><p>虽然我们的尺寸因删除JSON而显著下降，但压缩效果变差，最终节省了不到2%。如果每个答案增加2个字节以重新获得答案列表，则基本上是收支平衡。</p><p> Note: An interesting optimization would be to restrict answers selection so that instead of 2 bytes to select an arbitrary answer you only use 1 byte (or even less). It should be fairly easy to devise a scheme that humans couldn’t easily use to bias their choice even though it would make some answer orders impossible.</p><p>注意：一个有趣的优化是限制答案的选择，这样你就不用2个字节来选择任意答案，只需要1个字节（甚至更少）。设计一个人类无法轻易利用的方案来偏向他们的选择，尽管它会使一些答案变得不可能，这应该是相当容易的。</p><p>  The first obvious thing is that all the words only use letters in the  a-z range. We don’t need to spend a full byte per character. We only need  log_2(26) = 4.7 bits per character, or 23.5 bits per word. I’ll ignore the half a bit and use 24 bits, or 3 bytes per word.</p><p>第一件显而易见的事情是，所有的单词都只使用a-z范围内的字母。我们不需要每个字符花费一个完整字节。我们只需要log_2（26）=每个字符4.7位，或每个字23.5位。我将忽略半位，使用24位，或每个字3字节。</p><p> The logic is quite simple. Instead of storing the word itself you store the index of the word in the list of possible words. For example  aaaaa is  0 and  zzzzz is  26^5 - 1. The code is below:</p><p>逻辑很简单。不存储单词本身，而是将单词索引存储在可能的单词列表中。例如aaaaa是0，zzzzz是26^5-1。代码如下：</p><p> fn  index ( word :  [ u8 ;  5 ])  -&gt;  u32  {	 let  mut  i :  u32  =  0 ;	 for  c  in  word  {		 debug_assert! (( b &#39;a&#39; ..= b &#39;z&#39; ) .contains ( &amp; c ));		 i  *=  26 ;		 i  +=  ( c  -  b &#39;a&#39; )  as  u32 ;	 }	 i }</p><p>fn索引（单词：[u8；5]）-&gt；u32{let mut i:u32=0；对于单词{debug#u assert！（b&#39；a&#39；.=b&#39；z&#39；）中的c。包含（&amp；c））；i*=26；i+=（c-b&#39；a&#39；）如u32；}i}</p><p>    We get the ⅗ size difference we were expecting, however zstd completely fails to find any patterns! The compressed size is actually larger than before, and on the default zstd setting it doesn’t compress at all. This is surprising because typically there is repetition 3 bytes apart at the start of every word, but I guess zstd doesn’t notice that.  gzip also struggles but   zopfli does manage to crunch it down to 34.314 KiB. Still significantly larger than letting the compressor see the ASCII directly.</p><p>我们得到了⅗ 我们期待的尺寸差异，但是zstd完全没有找到任何图案！压缩的大小实际上比以前大，在默认的zstd设置下，它根本不压缩。这是令人惊讶的，因为通常每个单词的开头都有3个字节的重复，但我猜zstd没有注意到这一点。gzip也在挣扎，但佐夫利确实设法将其压缩到34.314 基布。仍然比让压缩器直接看到ASCII码要大得多。</p><p>  Instead of storing each word in 3 bytes we can use the first 2 characters in an index and compress the remaining 3 characters into 2 bytes. This saves us 1 byte per word but takes up space on the index.</p><p>我们可以使用索引中的前2个字符，并将剩余的3个字符压缩成2个字节，而不是将每个单词存储在3个字节中。这样每个字可以节省1字节，但会占用索引空间。</p><p> Luckily the most common 2-letter prefix “co” only has 220 words, this means that we only need one byte per prefix in our index or  26^2 = 676 bytes.</p><p>幸运的是，最常见的两个字母前缀“co”只有220个单词，这意味着我们在索引中每个前缀只需要一个字节，或者26^2=676字节。</p><p>   This is much smaller than before plus the compression seems to find more patterns, but it is significantly slower. There are two main reasons.</p><p>这比以前小得多，加上压缩似乎找到了更多的模式，但速度明显较慢。有两个主要原因。</p><p> We sum up the values in the index. This is good for space but bad for speed. This could be fixed with a pre-processing pass to resolve the offers before doing the lookups.</p><p>我们把索引中的值加起来。这对空间有利，但对速度不利。这可以通过一个预处理过程来解决，以便在进行查找之前解析报价。</p><p>  I didn’t bother implementing a binary search for the values. I didn’t think it would help for a max of 220 entries, but maybe it would.</p><p>我没有费心对这些值进行二进制搜索。我不认为这对最多220个条目有帮助，但也许会有帮助。</p><p>  What if instead of storing the indexes we stored one bit for every possible word.  1 if it is an allowed word and a  0 otherwise. This will require  26^5 bits and should give very fast lookups.</p><p>如果不是存储索引，而是为每个可能的单词存储一位呢。如果是允许的单词，则为1，否则为0。这将需要26^5位，并应提供非常快速的查找。</p><p> We can use the same logic for converting the word into an index then just check that bit in the table.</p><p>我们可以使用相同的逻辑将单词转换为索引，然后只需检查表中的该位。</p><p>   This method is incredibly fast, a great option if you were hosting the data on a server. The general-purpose compression also does a great job making this option quite small on the wire.</p><p>这种方法速度非常快，如果你在服务器上托管数据，这是一个很好的选择。通用压缩也做了一个伟大的工作，使这个选项相当小的电线。</p><p>  Another option is that instead of storing the words, we just store the change from the previous word. This takes advantage that in the sorted list the first character is almost always the same, the second character is usually the same, and so on. The way I decided to do this was by storing the difference in indexes. This works well because we can enumerate the possible words. Other options would be including a count for the number of characters that don’t match, then the replacement characters.</p><p>另一种选择是，我们不存储单词，只存储前一个单词的更改。这样做的好处是，在排序列表中，第一个字符几乎总是相同的，第二个字符通常是相同的，依此类推。我决定这样做的方式是将差异存储在索引中。这很有效，因为我们可以列举可能的单词。其他选项包括计数不匹配的字符数，然后是替换字符。</p><p> Unfortunately, the distance between words varies wildly. From adjacent words like “charr”, “chars” and “chart” to distant words like “xerus” and “xoana” which are 164 068 possible words apart! That means we will need 17.4 bits to store the distance. However, since most gaps are smaller it makes the most sense to use a variable-length encoding.</p><p>不幸的是，单词之间的距离差异很大。从“charr”、“chars”和“chart”等相邻单词到“xerus”和“xoana”等164个遥远的单词 068个可能的单词！这意味着我们需要17.4位来存储距离。然而，由于大多数间隙较小，因此使用可变长度编码最有意义。</p><p> In this case, I use a simple varint encoding where the top bit set means that there are more bytes to add on. In this system, 3 bytes gives us 21 usable bits which is large enough for our largest gap.</p><p>在本例中，我使用了一种简单的变量编码，其中顶部的位集意味着要添加更多字节。在这个系统中，3个字节为我们提供了21个可用位，足以填补我们最大的空白。</p><p>   This solution is slow because it sequentially scans all the words until it finds a match. This is because we can’t seek in the variable-length encoding, and you need to sum all previous values to find the current index. However, at 10 µs it is still well within our target time. This could also be improved easily by building a 2 or even 3 character prefix index on the client, or the client could just construct a  bitmap.</p><p>这个解决方案很慢，因为它会顺序扫描所有单词，直到找到匹配项。这是因为我们无法在可变长度编码中搜索，需要将所有以前的值相加才能找到当前索引。然而，10岁时 µs仍在我们的目标时间内。这也可以通过在客户机上构建2个甚至3个字符的前缀索引来轻松改进，或者客户机可以只构建一个位图。</p><p>  This was an idea that in retrospect doesn’t make much sense. It was basically the same as the previous idea except that I inserted a jump-table for the first letter at the front. This speeds up lookup as you don’t need to scan every earlier word. However, I thought that it would also be smaller because I didn’t have to include the first letter in the list, however since I was doing delta encoding it doesn’t make a difference. The distance between  taken and  tools is the same as the distance between  aken and  ools.</p><p>回想起来，这个想法没有多大意义。这基本上与之前的想法相同，只是我在前面插入了第一个字母的跳转表。这会加快查找速度，因为您不需要扫描之前的每个单词。然而，我认为它也会更小，因为我不必在列表中包含第一个字母，但是因为我在进行增量编码，所以没有什么区别。工具和工具之间的距离与aken和工具之间的距离相同。</p><p> Note: This is basically the same approach that  Alexander Pruss used for his Game Boy implementation. On the Game Boy it is likely beneficial to build the index up front instead of using valuable RAM.</p><p>注意：这与Alexander Pruss在Game Boy实现中使用的方法基本相同。在游戏机上，提前建立索引而不是使用有价值的RAM可能是有益的。</p><p>    The speed-up is significant, about 20x faster. This makes sense because instead of scanning half of all words on average, you only need to scan half of the words with the same first letter. I’ll assume this isn’t exactly 26x due to unequal letter distribution.</p><p>速度显著加快，大约快20倍。这很有意义，因为你不需要平均扫描一半的单词，只需要扫描一半首字母相同的单词。我假设这不完全是26倍，因为字母分布不均。</p><p>  This is the reason why I started the project. I thought I would be able to over-fit a bloom filter to the problem. However, doing the math showed that this was unlikely. I experimented anyway and confirmed my suspicion. To get no false-positives I needed to use a ¼MiB filter. This could maybe be reduced slightly by jigging some constants to over-fit the data, but it seemed very unlikely that a small enough filter could be found to be an efficient approach.</p><p>这就是我开始这个项目的原因。我以为我可以用布卢姆过滤器来解决这个问题。然而，计算结果表明这不太可能。我还是做了实验，证实了我的怀疑。为了避免误报，我需要使用¼MiB过滤器。通过调整一些常数来过度拟合数据，这可能会稍微降低，但似乎很难找到足够小的过滤器来有效地解决这一问题。</p><p> One intrinsic downside of the filter is that you can’t iterate the entries. This means that you can’t ship your answers as a 16-bit index into the valid-word list, you need to use a full 24-bit possible-word index. However, even if you want to store a year of answers it is a small extra cost (only 365 extra bytes).</p><p>过滤器的一个固有缺点是无法迭代条目。这意味着您不能将答案作为16位索引发送到有效的单词列表中，您需要使用完整的24位可能的单词索引。然而，即使你想存储一年的答案，这也是一个小的额外成本（只有365个额外字节）。</p><p> I still think this idea has value even if it doesn’t fit my goal of no false positives at a reasonable size. If you can compromise on requirements it could be a good choice. With a 16 KiB filter, you can get 1:127 false positive rate, with 8 KiB you can get 1:11. If the goal is to prevent accidental submits from typos and avoid people just guessing “aeiou” as their first word then these may be reasonable tradeoffs. The word list is full of strange words like “abcee” anyway, so I don’t think anyone will notice a couple false-positives.</p><p>我仍然认为这个想法有价值，即使它不符合我的目标，即在合理的范围内没有误报。如果你能在需求上做出妥协，这可能是一个不错的选择。16岁 KiB过滤器，你可以得到1:127的假阳性率，8 KiB你可以得到1:11。如果目标是防止因拼写错误而意外提交，避免人们仅仅猜测“aeiou”是他们的第一个单词，那么这些可能是合理的权衡。不管怎么说，单词表上都充满了像“abcee”这样的奇怪单词，所以我认为没有人会注意到一些误报。</p><p>   It is very fast (and I could have used a faster hash) but if you want no false-positives this approach isn’t great.</p><p>它非常快（我本可以使用更快的散列），但如果你不想出现误报，这种方法并不好。</p><p>  The best approach was  Delta Encoding at 15 KiB after compression. This is a significant reduction over the simple approach at 25 KiB. Of course, it is easy to argue that this isn’t a worthwhile optimization compared to the simplicity of embedding the list in the JavaScript and checking membership using   dictionary . includes ( guess ())  ||  answers . includes ( guess ).</p><p>最好的方法是在15岁时进行增量编码 压缩后的KiB。与25岁时的简单方法相比，这是一个显著的降低 基布。当然，与在JavaScript中嵌入列表和使用字典检查成员身份的简单性相比，很容易认为这不是一个值得优化的方法。包括（猜测（））| |答案。包括（猜测）。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字典/">#字典</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/单词/">#单词</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>