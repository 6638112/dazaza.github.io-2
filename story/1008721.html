<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>抽象出正确性</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">抽象出正确性</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-28 21:48:01</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/6/99194f67e5542018f2c1c325832cade0.png"><img src="http://img.diglog.com/img/2020/6/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>这句话并不是以同样的方式引起每个人的共鸣。为了真正理解我所说的仔细的API设计是什么意思，一个人必须经历过这两种情况。</p><p>但也有一线希望--一旦你体验了好的设计，就真的很难再回到另一种设计了。即使在承认好的设计不可避免地要付出代价之后，无论是认知负担、编译时间，还是让招聘变得更具挑战性等，都不可避免地要付出代价。</p><p>学习新事物，理解它的价值，然后再回到旧的做事方式，这是一种非常困难的经历。这适用于任何主题，而不仅仅是编程。</p><p>我知道这对我来说很困难。所以，这里是你的警告：一旦你学会了发现设计缺陷，你就不能忘记它，而且这确实会让你很难把工作做好。这是一个微妙的平衡。</p><p>几年前，当我开始使用Go时，我很高兴地发现了一些核心界面。</p><p>首先，它从Go1.0开始就有了，它只有一个功能。所以基本上你能想到的任何东西都已经实现了。</p><p>//在`main.go`包main import(&#34；io&#34；&#34；log&#34；&#34；os&#34；)func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}readSome(F)}函数readSome(r io.。读卡器){buf：=make([]byte，4)n，err：=r.Read(Buf)if err！=nil{log.。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，n，buf[：n])}}。</p><p>包主要导入(&#34；io&#34；&#34；log&#34；&#34；net&#34；)func main(){log.。SetFlags(日志。L短文件)连接，错误：=NET。如果err！=nil{log！，则拨号(&#34；TCP&#34；，&#34；example.org：80&#34；)。Fatalf(&#34；%+v&#34；，err)}_，err=conn。如果err！=nil{log.，则写入([]byte(&#34；GET/HTTP/1.1\r\n\r\n&#34；))。Fatalf(&#34；%+v&#34；，err)}readSome(Conn)}//省略：readSome</p><p>包主要导入(&#34；io&#34；&#34；log&#34；&#34；net/http&#34；)func main(){log.。SetFlags(日志。L短文件)，错误：=http。Get(&#34；http://example.org&#34；)if Err！=nil{log.。Fatalf(&#34；%+v&#34；，err)}readSome(分别。BODY)}Funcc readSome(r io.。读卡器){buf：=make([]byte，4)n，err：=r.Read(Buf)if err！=nil{log.。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，n，buf[：n])}}。</p><p>我们可以继续下去，但我们不能--基本上，围棋生态系统中任何可以阅读的东西几乎都可以实现io.Reader。</p><p>AltReader接口提出了几个问题-让我们通过为*os.File实现它来强调这些问题。</p><p>包主导入(&#34；log&#34；&#34；os&#34；)类型AltReader接口{AltRead()([]byte，error)}func(f*os.。文件)AltRead()([]字节，错误){buf：=make([]byte，1024)n，err：=f.read(Buf)return buf[：n]，err}func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}readSome(F)}func readSome(R AltReader){buf，err：=r.AltRead()if err！=nil{log.。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，len(Buf)，buf)}}。</p><p>$Go运行main.go#命令行参数。\main.go：12：6：无法在非本地类型os.File上定义新方法。\main.go：26：10：不能在参数中使用f(类型*os.File)作为类型AltReader来读取Some：*os.File不实现AltReader(缺少AltRead方法)。</p><p>包主导入(&#34；io&#34；&#34；log&#34；&#34；os&#34；)类型AltReader接口{AltRead()([]byte，error)}//新类型：类型AltReadWrapper struct{Internal io.。Reader}//现在接收器是我们的包装器类型func(arw*AltReadWrapper)AltRead()([]byte，error){buf：=make([]byte，1024)n，err：=arw。内部。read(Buf)return buf[：n]，err}func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}//参数现在换行为readSome(&amp；AltReadWrapper{Internal：f})}func readSome(R AltReader){buf，err：=r.AltRead()if err！=nil{log.。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，len(Buf)，buf)}}。</p><p>$GO运行main.gomain.go：42：读取705字节：[112 97 99 107 97 103 101 32 109 97 105(等)]。</p><p>请注意，当我们实现AltReader时，我们只声明了一个具有正确签名的名为AltRead()的函数。</p><p>好的，所以AltReader接口可以工作了--但是，没有办法指定您想要读取多少数据。我们很高兴早些时候只读取了4个字节，但是现在我们依赖于AltReader的实现者选择的任何缓冲区大小。</p><p>类型AltReader接口{AltRead(N Int)([]byte，error)}类型AltReadWrapper结构{内部io。Reader}var_AltReader=(*AltReadWrapper)(Nil)func(arw*AltReadWrapper)AltRead()([]字节，错误){buf：=make([]byte，1024)n，err：=arw。内部。read(Buf)return buf[：n]，Err}//省略：其他所有内容。</p><p>Func(arw*AltReadWrapper)AltRead()([]字节，错误){buf：=Make([]字节，1024)//⬅此处n，Err：=arw。内部。读取(Buf)返回buf[：n]，错误}。</p><p>$Go运行main.go#命令行参数。\main.go：17：5：不能使用(*AltReadWrapper)(Nil)(type*AltReadWrapper)作为赋值中的AltReader类型：*AltReadWrapper不实现AltReader(AltRead方法的类型错误)有AltRead()([]byte，error)Want AltRead(Int)([]byte，error)。\main.go：AltReadWrapper文本(type*AltReadWrapper)作为readSome的参数中的类型AltReader：*AltReadWrapper未实现AltReader(AltRead方法的类型错误)Have AltRead()([]byte，Error)Want AltRead(Int)([]Byte，Error)。\main.go：38：23：调用r.AltRead Have()Want(Int)时参数不足。</p><p>func(arw*AltReadWrapper)AltRead(N Int)([]byte，error){buf：=make([]byte，n)n，err：=arw。内部。读取(Buf)返回buf[：n]，错误}。</p><p>func readSome(R AltReader){buf，err：=r.AltRead(4)if err！=nil{log.。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，len(Buf)，buf)}}。</p><p>现在，一切都重新编译并运行-我们得到了4个字节，就像我们想要的那样：</p><p>函数(arw*AltReadWrapper)AltRead(N Int)([]byte，error){//我们要找出GC是否真的很快buf：=make([]byte，n)n，err：=arw。内部。读取(Buf)返回buf[：n]，错误}</p><p>包主导入(&#34；io&#34；&#34；log&#34；&#34；os&#34；)类型AltReader接口{AltRead(N Int)([]byte，error)}类型AltReadWrapper struct{Internal io.。Reader buf[]byte}var_AltReader=(*AltReadWrapper)(Nil)func(arw*AltReadWrapper)AltRead(N Int)([]byte，error){if len(arw.。buf)&lt；n{log.。Printf(&#34；分配%v字节&#34；，n)arw。buf=make([]byte，n)}n，Err：=arw。内部。阅读(arw.。buf)返回arw。buf[：n]，err}func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。对于i：=0；i&lt；4；i++{readSome(Arw)}}函数readSome(R AltReader){buf，err：=r.AltRead(4)if err！=nil{log.，则Fatalf(&#34；%+v&#34；，err)}arw：=&amp；AltReadWrapper{Internal：f}for i：=0；i&lt；4；i++{readSome(Arw)}}函数readSome(R AltReader){buf，err：=r.AltRead(4)。Printf(&#34；获取错误：%+v&#34；，Err)}其他{日志。Printf(&#34；读取%v字节：%v&#34；，len(Buf)，buf)}}。</p><p>$GO运行main.gomain.go：22：分配4字节main.go：49：读取4字节：[112 97 99 107]main.go：49：读取4字节：[97 103 101 32]main.go：49：读取4字节：[109 97 105 110]main.go：49：读取4字节：[10 10 105 109]。</p><p>当然，返回内部缓冲区的问题在于没有什么能阻止调用者保留对它的引用。</p><p>包主导入(&#34；io&#34；&#34；log&#34；&#34；os&#34；//new！&#34；github.com/davecgh/go-spew/spew&#34；)//某些类型/函数省略了func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}fc：=readFourChunks(&amp；AltReadWrapper{Internal：f})输出。dump(Fc)}type FourChunks struct{one[]byte Two[]byte Three[]byte four[]byte}func readFourChunks(R AltReader)FourChunks{masRead：=func()[]byte{r，err：=r.AltRead(4)if err！=nil{log.。Fatalf(&#34；Cannot Not Read：%+v&#34；，Err)}return r}return FourChunks{One：mastRead()，Two：msiRead()，Three：msiRead()，Four：mastRead()，}。</p><p>$go run main.gomain.go：24：分配4字节(main.FourChunks){一：([]uint8)(len=4 cap=4){00000000 0A 0A 69 6d|..im|}，二：([]uint8)(len=4 cap=4){00000000 0A 0A 69 6d|..im|}，三：([]uint8)(len=4 cap=4){00000000 0A 0A 69 6d|..im。</p><p>啊哦。FourChunks的所有字段都设置为main.go中找到的第四组偏置字节。</p><p>键入AltReadWrapper struct{interi.。Reader}函数(arw*AltReadWrapper)AltRead(N Int)([]字节，错误){buf：=make([]byte，n)n，err：=arw。内部。读取(Buf)返回buf[：n]，错误}。</p><p>$go run main.go(main.FourChunks){一：([]uint8)(len=4 cap=4){00000000 70 61 63 6b|pack|}，二：([]uint8)(len=4 cap=4){00000000 61 67 65 20|age|}，三：([]uint8)(len=4 cap=4){00000000 6d 61 69 6e|main|}，四：([]uint8)(len=4 cap=4)</p><p>而且我们在每次读取设计时都会坚持分配，因为我们不知道调用者可能会保留我们返回的切片多长时间。在我们的AltReader实现类型获取垃圾回收之后，他们可能会保留很长时间。</p><p>但我认为Reader没有这个问题。通过采用单个[]字节参数，它可以同时满足这两个要求：</p><p>如果我们将示例更改为只使用io.Reader，我们可以看到一切都很正常：</p><p>软件包主要导入(&#34；io&#34；&#34；log&#34；os&#34；&#34；github.com/davecgh/go-spew/spew&#34；)func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}fc：=readFourChunks(F)spew.。dump(Fc)}type FourChunks struct{one[]byte Two[]byte Three[]byte four[]byte}函数读取FourChunks(r io.。Reader)FourChunks{masRead：=func(p[]byte)[]byte{_，err：=io。ReadFull(r，p)if err！=nil{log.。Fatalf(&#34；Cannot Not Read：%+v&#34；，Err)}Return p}return FourChunks{One：mastRead(make([]byte，4))，Two：mastRead(make([]byte，4))，Three：mastRead(make([]byte，4))，Four：mastRead(make([]byte，4))，}}。</p><p>$go run main.go(main.FourChunks){一：([]uint8)(len=4 cap=4){00000000 70 61 63 6b|pack|}，二：([]uint8)(len=4 cap=4){00000000 61 67 65 20|age|}，三：([]uint8)(len=4 cap=4){00000000 6d 61 69 6e|main|}，四：([]uint8)(len=4 cap=4)。</p><p>软件包主要导入(&#34；io&#34；&#34；log&#34；os&#34；&#34；github.com/davecgh/go-spew/spew&#34；)func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}readFourTimes(F)}函数readFourTimes(r io.。读卡器){buf：=make([]byte，4)for i：=0；i&lt；4；i++{_，err：=io。ReadFull(r，buf)，如果err！=nil{log.。Fatalf(&#34；无法读取：%+v&#34；，Err)}拼写。转储(Buf)}}。</p><p>见鬼，如果我们愿意，我们甚至可以把它读到缓冲区的中间：</p><p>func main(){log.。SetFlags(日志。L短文件)f，错误：=os。如果错误！=nil{log.(&#34；main.go&#34；)，则打开(&#34；main.go&#34；)。Fatalf(&#34；%+v&#34；，err)}readToMid.(F)}函数readToMid.。读卡器){buf：=[]byte(&#34；.&#34；)_，Err：=io。ReadFull(r，buf[8：20])，如果err！=nil{log.。Fatalf(&#34；无法读取：%+v&#34；，Err)}拼写。转储(Buf)}</p><p>$go run main.go([]uint8)(len=30 cap=30){00000000 2e 2e 2e 70 61 63 6b 61 67 65 20|.Package|00000010 6d 61 69 6e 2e 2e 2e|Main.|}。</p><p>在这一点上，我认为公平地说，io.Reader是一个更好的设计。</p><p>我还没有展示完整的io.Reader界面--只展示了它的函数签名。不幸的是，这还不足以完全指定接口。</p><p>任何时候，只要界面的签名本身不足以推断其行为，就会有麻烦出现。</p><p>想象一下，你可以拉起或拉下一个火警报警器。如果你把它拉起来-警报器响了，人们都疏散了，一切都很好。</p><p>当然，最终人们会想出办法的--他们会把它拉下来，看看什么都没有发生，困惑几秒钟，然后试着把它拉起来。或者也许他们赢了，然后假设它坏了。</p><p>当然，除非拉警报器的人什么也听不到。也许大厦管理人员可以确信这是一个潜在的问题，应该做些什么来解决它。</p><p>他们没有更换警报器，而是设立了员工培训。所有的火警警报器都必须拉下来，而不是拉起来--不，等等，反过来。</p><p>他们还没有解决问题的根源。这充其量只是一个创可贴。任何还没有参加过培训的人，比如新员工，都是大楼的潜在危险。</p><p>现在，酷熊，你知道这个类比并不适用于每个人。我可以从这里看到评论.。</p><p>不要紧--不管怎样，让我们在这里公平地说：不是所有的事情都是可以解决的。有时你只需要在墙上贴一张告示，上面写着不要戳熊，因为那里有熊是有充分理由的。</p><p>不管怎样，我要说的是我们还没有讨论完整的IO.Reader界面。</p><p>尽管它只是一个函数，但有一堆可移动的部分。首先，这是Go，在Go中，您没有元组，您没有Result&lt；T&gt；类型，您没有异常处理-您有多值回报。</p><p>多值回报的问题之一是，没有人抱怨这样的事情：</p><p>软件包主要导入(&#34；log&#34；&#34；os&#34；&#34；github.com/davecgh/go-spew/spew&#34；)func main(){log.。SetFlags(日志。lShort file)//这显然不是一个好主意f，_：=os。打开(&#34；woops&#34；)buf：=make([]byte，32)//n，_：=f.read(Buf)spew。转储(buf[：n])}。</p><p>编译器不会抱怨，去兽医也不会抱怨，golangci-lint运行的51个短针都不会抱怨。</p><p>他们当然不会抱怨，你在想，你只是用_！叫他们闭嘴！</p><p>在支持异常的语言中懒于处理错误的方法是.。什么都不做。</p><p>//@ts-check const{readFile}=REQUIRED(&#34；fs&#34；)。承诺；异步函数main(){const content=await readFile(&#34；woops&#34；，{coding：&#34；utf-8&#34；})；控制台。log(`刚刚读取文件：${Contents。Slice(0，20)}.`)；}main()；</p><p>woops文件不存在，而且我们肯定没有花任何时间考虑错误处理，因此，它导致整个程序中断：</p><p>$node--unhanded-rejections=Strict main.jsInternal/process/promises.js：194 riggerUncaughtException(err，true/*from mPromise*/)；^[错误：ENOENT：无此类文件或目录，打开&#39；C：\msys64\home\amos\go\aac\woops&#39；]{errno：-4058，code：&#39；ENOENT&#39；，SysCall。</p><p>导入java。伊俄。BufferedReader；导入java。伊俄。FileInputStream；导入java。伊俄。InputStreamReader；导入java。尼欧。CharBuffer；public class main{public static void main(string args[])抛出java。朗。异常{BufferedReader Reader=new BufferedReader(new InputStreamReader(new FileInputStream(&#34；woops&#34；)，&#34；UTF-8&#34；))；CharBuffer BUF=CharBuffer。分配(32)；读取器。读(BUF)；读。关闭()；系统。出去。println(&#34；只需读取文件：&#34；+buf。toString())；}}。</p><p>$javac Main.java&amp；&amp；线程中的java MainException&#34；Main&34；java.io.FileNotFoundException：位于java.base/java.io.FileInputStream.open0(Native方法的Woops(系统找不到指定的文件)位于java.base/java.io.FileInputStream.open(FileInputStream.java:219)位于java.base/java.io.FileInputStream.&lt；init&gt；(FileInputStream.java:157)位于java.base/java.io.FileInputStream.&lt；init&gt；(FileInputStream.java：112)在Main.main(Main.java：8)。</p><p>$python main.pyTraceback(最近一次调用)：file&#34；main.py&#34；，第2行，在&lt；module&gt；file=open(&#34；woops&#34；，&#34；r&#34；)FileNotFoundError：[Errno 2]没有这样的文件或目录：&#39；woops&#39；</p><p>#DEFINE_CRT_SECURE_NO_WARNINGS#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；int main(int argc，char**argv){file*f=fopen(&#34；woops&#34；，&#34；r&#34；)；const size_t len=32；//(！)。无偿使用sizeof传达意图//作者意识到sizeof(Char)只有1.char*buf=calloc(len，sizeof(Char))；fread(buf，sizeof(Char)，len，f)；printf(&#34；只读取文件的一部分：%.*s\n&#34；，(Int)len，buf)；return 0；}。</p><p>$lldb./Main(Lldb)目标创建&#34；./Main&#34；当前可执行文件设置为&#39；./Main&#39；(X86_64)r进程14644已启动：&#39；C：\msys64\HOME\amos\go\aac\main&#39；(X86_64)进程14644已停止*线程#1，停止原因=在地址0x7ff6遇到异常0xc0000409。IMM=0xC0000417 0x7ff6f10c6385：LEAL 0x1(%r8)，%ecx。</p><p>我做的不仅仅是几条下划线。我故意隐藏了一些非常有趣的警告。</p><p>$clang main.c-o main.c：5：13：警告：&#39；fopen&39；已弃用：此函数或变量可能不安全。请考虑改用fopen_s。要禁用弃用，请使用_CRT_SECURE_NO_WARNINGS。有关详细信息，请参阅联机帮助。[-W不推荐使用的声明]文件*f=fopen(&#34；woops&#34；，&#34；r&#34；)；^C：\Program Files(X86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h:207:20：备注：&#39；fopen&#39；已被显式标记为已弃用HERE_CHECK_RETURN__CRT_INSECURE_DELPERATE(FOPEN_S)^D：\Programs\MicrosoftVisual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vcruntime.h:316:55：备注：从宏展开；_CRT_INSECURE_DEPREATE&#39；#DEFINE_CRT_INSECURE_DEPREATE(_REPLACE)_CRT_DEPROATE_TEXT(\^D：\PROGRAM\MICROSOFT Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vcruntime.h:306:47：注意：从宏&#39；_CRT_DEPREATE_TEXT&#39；#DEFINE_CRT_DEPREATE_TEXT(_TEXT)__DECLSPEC(DEPERATED(_TEXT))^1生成警告。</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；int main(int argc，char**argv){file*f；fopen_s(&amp；f，&#34；woops&#34；，&#34；r&#34；)；//etc返回0；}。</p><p>然后..。没有其他警告了。不过，微软(我在Windows上写这篇文章)已经为C开发了一种注释语言。</p><p>_check_return_wat__ACRTIMP errno_t__cdecl fopen_s(_Outptr_result_maybenull_file**_Stream，_in_z_char const*_filename，_in_z_char const*_Mode)；</p><p>(顺便说一句，这是在PowerShell中运行的-我通常在msys2中运行shell sessionin)。</p><p>$cl.exe/nlogo/Analyze main.cmain.cC：\msys64\home\amos\go\aac\main.c(8)：警告C6031：已忽略返回值：&#39；fopen_s&#39；.C：\msys64\home\amos\go\aac\main.c(14)：警告C6387：&#39；buf&#39；可能是&#39；0&#39；：这不符合s。</p><p>..</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/abstracting-away-correctness">https://fasterthanli.me/articles/abstracting-away-correctness</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/抽象/">#抽象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/main/">#main</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>