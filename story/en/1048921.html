<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>git是我的好友：作为独奏开发人员的有效git Git is my buddy: Effective Git as a solo developer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Git is my buddy: Effective Git as a solo developer<br/>git是我的好友：作为独奏开发人员的有效git </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:46:48</div><div class="page_narrow text-break page_content"><p>At this point, most developers use Git as a tool for collaboration. We have ourrote-learned commands to pull, commit, and push. And of course, there&#39;s  thatone coworker who knows a bit more about Git thaneveryone else, who helps get us back on track whenever our local repos end up ina strange state.</p><p>此时，大多数开发人员使用Git作为协作的工具。我们有欧洲学习的命令来拉，提交和推动。当然，那里的同事在那里知道有关Git的那个同事比别人更加了解Git，这是帮助我们在当地的回购最终ina陌生状态时回到轨道。</p><p> But what if I told you that Git can be a valuable tool without ever setting up aremote repository? I&#39;m not just talking about having a working version of yourcode base to roll back to if you mess something up, although there&#39;s that too.Used correctly, Git can help to structure your work, identifying gaps in yourtest coverage and minimizing dead code.</p><p> 但如果我告诉过你，如果Git可以成为一个有价值的工具我不只是谈论拥有一个工作版本的你的码基础，如果你搞砸了一些东西，虽然它也是如此。使用了，Git可以帮助构建你的工作，识别你最大的空白覆盖并最大限度地减少死亡代码。</p><p>  There are two subjects I&#39;m going to avoid for the purposes of this blog post:other developers, who are the most compelling but least interesting argumentfor keeping your commit history clean, and  git bisect, which does factorheavily into my workflow but deserves its own blog post.</p><p>  有两个主题I＆＃39; m将避免避免此博客文章：其他开发人员，是最引人注目但最有趣的争论，使您的提交历史清洁和Git Botect，这会将视为我的工作流程，但值得注意它自己的博客文章。</p><p> As with any ubiquitous developer tool, the Git user base has a lot of strong andconflicting opinions about the one &#34;correct&#34; way to use it. My goal is simply tointroduce a workflow that I&#39;ve been using and refining for much of my career;take from it what you will. And, importantly, it&#39;s a workflow that has become avital part not just of my collaboration process, but of the way I write code.</p><p> 与任何无处不在的开发人员工具一样，Git用户基数有很多关于一个＆＃34;正确的＆＃34;使用它的方法。我的目标只是倾向于introduce我＆＃39; ve一直在使用和炼制我的职业生涯的工作流程;从你兴奋地夺取它。而且，重要的是，它的工作流程是一项工作流程，它不仅仅成为我的协作过程，而且我写代码的方式。</p><p> Ultimately, these principles serve two purposes: they focus my work onto aparticular bugfix, feature, or goal, and they ensure that my Git history isn&#39;tset in stone. With proper hygiene, commits can be dropped, rearranged, and splitoff into other branches painlessly and without merge conflicts.</p><p> 最终，这些原则提供了两种目的：他们将我的工作集中在一个公寓错误修正，功能或目标上，他们确保我的git历史isn＆＃39; tset在石头上。通过适当的卫生，可以轻松地丢弃，重新排列，重新排列，并拆分和拆分进入其他分支，而不会合并冲突。</p><p>  When I&#39;m managing my own projects, I have a lot of ideas that I want to seehappen. If I&#39;m just throwing one commit after another into  main, I&#39;ll gethalfway through implementing one feature and then jump off to hacking onanother. If any of the features get completed, it will be at the expense of awasteland of half-completed features that are now taking up space in my codebase.</p><p>  当我管理自己的项目时，我有很多我想要Seehappen的想法。如果我＆＃39; m只是把一个又一次地扔进了一个主要的，我＆＃39; ll gethalfway通过实施一个功能，然后跳到骚扰onanother。如果任何功能都完成，它将牺牲AWASTELALD的AWASTELELAL，现在正在占用Codebase中的空间。</p><p> In a brand-new project, sure, I&#39;ll throw a bunch of garbage commits into  main.My rule of thumb for when to stop this is when I can write my first effectiveintegration test. If there is  something useful to test, there is now enoughsubstance to my project that I can have distinct tasks on the go. Trying tobreak into branches too early just results in me throwing my garbage commitsinto a branch instead of main.</p><p> 在一个全新的项目，当然，我＆＃39; ll扔了一堆垃圾犯规到main.my的拇指规则，何时停止这是我可以编写我的第一个有效的测试。如果有什么可用于测试的东西，现在已经有足够的项目，我可以在GO上有不同的任务。早起，尝试分支机构刚刚导致我扔掉我的垃圾委员会而不是主要的分支。 </p><p> In the early stages of a project, articulating the purpose of a branch can be assimple as giving it a descriptive name. If a commit isn&#39;t moving the code basein that direction, it can always get cherry-picked into a different branch.</p><p>在项目的早期阶段，阐明分支的目的可能很简单，只需为其赋予一个描述性名称即可。如果提交没有沿该方向移动代码库，则始终可以将其精选到另一个分支中。</p><p> As the project matures, I&#39;ll start using some sort of issue or bug trackingsoftware to flesh out what I&#39;m trying to accomplish in more detail andcoordinate the branches for multiple related useful things.</p><p> 随着项目的成熟，我将开始使用某种问题或错误跟踪软件来充实我试图更详细地完成的工作，并协调分支机构以处理多个相关的有用事情。</p><p> I find that descriptive branch names also help to refocus my attention on whatI&#39;m trying to accomplish. For instance, my command prompt currently looks likethis:</p><p> 我发现描述性分支名称还有助于将我的注意力重新集中在我要完成的事情上。例如，我的命令提示符当前如下所示：</p><p>   So much for branches, let&#39;s zoom into a commit level. I&#39;ve articulated whatconcrete thing I want my branch to add, now how do I add it? Usually, there&#39;ssome poking around my code base involved in figuring that out. Sometimes I takea wrong turn, sometimes I just get distracted. That&#39;s okay, it&#39;s part of theprocess.</p><p>   对于分支机构而言，如此之多，让我们放大到一个提交级别。我已经明确表达了我要添加分支的具体内容，现在该如何添加？通常，在弄清楚我的代码库时有些涉及。有时我走错了路，有时我只是分心。没关系，这是过程的一部分。</p><p> However, that doesn&#39;t mean that every commit I make right now is going to end upgetting merged in this branch. By keeping my commits independent from oneanother, I ensure that I can rearrange or cherry-pick them into new branchesif I discover that they really don&#39;t have anything to do with what I&#39;m workingon right now.</p><p> 但是，这并不意味着我现在所做的每一次提交都将最终合并到该分支中。通过确保我的提交彼此独立，如果我发现它们确实与我现在正在工作的内容无关，那么我可以确保将它们重新排列或挑选到新的分支中。</p><p> If my commits are not independent, I am essentially stuck with the exact historyas it was written. Trying to tease out a commit into a different branch or moveit to the beginning of my branch history will become fraught with mergeconflicts as later commits that modified code introduced in this commit falllike dominoes.</p><p> 如果我的提交不是独立的，那么我本质上就是坚持写的确切历史。尝试将提交提交到另一个分支或移动到我的分支历史的开始将变得充满合并冲突，因为后来的提交（该提交中引入的修改后的代码就像多米诺骨牌一样）。</p><p> Obviously, I&#39;m still allowed to call code written in one commit from a latercommit. That&#39;s the reason I&#39;m doing this particular work in this particularbranch, after all. But I never touch the same code multiple times. If I have togo back and fix something, maybe add a validation check or field that I hadn&#39;tthought of, I&#39;ll go back to the commit where it was created rather than amendingit in a later commit.</p><p> 显然，我仍然可以从以后的提交中调用一次提交中编写的代码。毕竟，这就是我在此特定分支中从事这项特定工作的原因。但是我从来不会多次触摸相同的代码。如果我必须返回并修复某些问题，也许添加一个我没有想到的验证检查或字段，我将回到创建它的提交，而不是在以后的提交中进行修改。 </p><p> Obviously, this could go on forever, which is why the &#34;one useful thing&#34;principle exists. Once I&#39;ve settled on what I want the code to look like for thepurposes of this branch, I merge and then start a new commit in the next branchfor further changes to the same.</p><p>显然，这可能永远持续下去，这就是为什么存在一个有用的原则的原因。一旦确定了我希望该分支的代码看起来像什么，我就合并，然后在下一个分支中开始新的提交，以进一步更改该分支。</p><p>  Here&#39;s where keeping commits small starts to pay dividends. If the code in eachcommit is small enough for me to reason about, it&#39;s small enough for me tovisually ensure that its test coverage is good.</p><p>  在这里，小的保证金开始带来红利。如果每个提交中的代码都足够我进行推理，那么它也足够我凭视觉确保其测试覆盖范围良好。</p><p> And of course, if I do end up rearranging this commit or splitting it off to adifferent branch, I want its tests to come along with.</p><p> 当然，如果我最终重新布置了该提交或将其拆分到另一个分支，则我希望它的测试能够随之进行。</p><p> The exception to this is integration and functional/behavioural tests, which canand should have their own commits. In that case, the tests are really tied tothe branch level rather than the commit level, since Principle 1 implies thatthere should be exactly one new test to add as a result of this branch.</p><p> 集成和功能/行为测试是一个例外，可以并且应该具有自己的提交。在这种情况下，测试实际上是与分支级别联系在一起的，而不是与提交级别联系在一起的，因为原则1暗示应该有一个新的测试要作为该分支的结果添加。</p><p>  Again, breaking something in a commit (even if I  really definitely intend tofix it in a later commit) locks me into the git history as written. Andintroducing a breaking change with the intention of fixing things later alwayscarries the risk that I&#39;ll get distracted and end up merging the breakingchange.</p><p>  同样，在提交中破坏某些内容（即使我确实确实打算在以后的提交中进行修复）也将我锁定在git历史记录中。为了以后解决问题而引入重大更改总是会冒这样的风险，即我会分心，最终合并重大更改。</p><p> If there&#39;s some prerequisite to get this change to pass tests - say, apreexisting bug that snuck through a hole in my test coverage - that gets itsown commit.</p><p> 如果存在进行此更改以通过测试的一些先决条件-例如，一个已经存在的漏洞会通过我的测试覆盖范围的一个洞潜入-则将其提交。</p><p> Speaking of holes in test coverage, there&#39;s another (temporary) exception here.I don&#39;t normally practice strict  test-drivendevelopment, but if I dofix a long-standing bug, I normally temporarily put its test in a separatecommit. I&#39;ll then rebase so that the test appears before the fix, ensure thatthe test fails  without the fix, then complete the rebase and validate that thetest now passes. Once the due diligence to validate my test is done, I can goahead and squash the bugfix with its test.</p><p> 说到测试覆盖率方面的漏洞，这里还有另一个（临时）异常。我通常不练习严格的测试驱动开发，但是如果我修复了一个长期存在的错误，通常我会暂时将其测试放入单独提交。然后我将重新设置基准，以使测试出现在修复程序之前，确保没有修复程序的测试失败，然后完成重新设置基准并验证测试现在可以通过。一旦完成了验证我的测试的尽职调查，我就可以继续通过该测试修正错误修正。 </p><p>  If I know that I&#39;ll be coming back to a change later, I&#39;m much more comfortablesetting it down and moving on to roughing in the next part of the process,rather than finishing, polishing, and unit testing code that might need tochange before my branch gets merged.</p><p>如果我知道以后会再进行更改，那么我会更轻松地将其设置为下一部分，然后继续进行粗加工，而不是精加工，抛光和单元测试代码在合并我的分支之前可能需要更改。</p><p> In fact, I find that I waste much less time on writing tests for things thatI&#39;ll later change when I&#39;m following this workflow to the letter than I do whenI get &#34;lazy&#34; and start dumping everything into big catch-all commits.</p><p> 实际上，我发现我花在编写测试上的时间要比在我变得懒惰时要花的时间少，这些事情后来在我遵循此工作流程进行时会更改。并开始将所有内容转储为大型的所有提交。</p><p> Some people favour TODO comments in their code, occasionally supported byautomated checks that prevent code containing &#34;TODO&#34; from merging. I prefer toannotate my commit messages and leave my code clean. Normally, this lookssomething like &#34;add controller class - TODO test me&#34;. (I always put my TODOs onthe first line of the commit message, so that they show up even in short logviews.)</p><p> 某些人喜欢代码中的TODO注释，有时会通过自动检查来支持，以防止代码中包含＆＃34; TODO＆＃34;。从合并。我更喜欢注释我的提交消息，并保持代码干净。通常，这看起来像是＆＃34;添加控制器类-TODO测试我＆＃34;。 （我总是将我的TODO放在提交消息的第一行，这样即使在简短的日志视图中也可以显示它们。）</p><p>  Often I start a task by tidying up the surrounding code, in the same way I mightorganize my desk before starting work. (I don&#39;t, but I  might.) Sometimes thatcleanup turns out to be a valuable part of the groundwork for this change, butsometimes it&#39;s just dead weight. Keeping my commits independent makes it easy todiscard or cherry-pick out code that turned out to be unnecessary, along withany unit tests that went along with.</p><p>  我经常通过整理周围的代码来开始任务，就像在开始工作之前整理办公桌一样。 （我没有，但是我可以。）有时候，清理工作被证明是进行此更改的基础工作的宝贵组成部分，但有时这只是沉重的负担。保持我的提交独立，可以很容易地丢弃或废除不必要的代码，以及随之而来的任何单元测试。</p><p> (I do still consider the tidying to be a valuable part of the process. It clearsmy mind and refreshes my knowledge of the problem space with some simple rotetasks before I dive into something more complex. And occasionally it results incleaner code.)</p><p> （我仍然认为整理是该过程的重要组成部分。在深入研究更复杂的问题之前，它使我头脑清醒，并通过一些简单的轮转任务刷新了我对问题空间的了解。有时会产生更简洁的代码。）</p><p>  I&#39;m not perfect. [citation needed] Obviously, it&#39;s not practical tomaintain this level of commit hygiene by making each change sequentially.Instead, I jump around  constantly. Doing so requires me to be comfortable innavigating my commit history. (Conversely, it&#39;s also a good way to  becomecomfortable with navigating history.)</p><p>  我并不完美。 [需要引用]显然，通过依次进行每个更改来保持这种提交卫生的水平是不切实际的。相反，我一直在跳来跳去。这样做需要我习惯浏览自己的提交历史。 （相反，这也是使浏览历史变得舒适的一种好方法。）</p><p> In that vein, here are some tools beyond your standard checkout/ branch/ pull/ commit/ push workflow that come in handy.</p><p> 因此，除了标准的checkout / branch / pull / commit / push工作流程之外，这里还有一些工具非常有用。 </p><p> git commit --fixup [hash] – Whenchanging history, I used to find myself making a lot of commits with messageslike &#34;merge me with xyz&#34; if I need to revisit commits before the most recentone. It turns out that  git commit has flags to help with this:  --fixup and --squash will automatically suggest a fixup or squash with another commitduring rebase if the  --autosquash flag is provided to that command. (Toenable this behaviour by default, run  git config --global rebase.autosquash true. It won&#39;t behave any differently if there are no commit messages in thehistory being edited that contain &#34;squash!&#34; or &#34;fixup!&#34;.) A surprise bonus:since the fixup operation inherits the message of the previous commit, youwon&#39;t be prompted to enter a new one.</p><p>git comput --fixup [哈希]  - 当历史记录时，我曾经发现自己用邮件＆＃34致力于与xyz＆＃34合并我;如果我需要重新审视最近于最近于的。事实证明，Git Commit有标志来帮助解决问题：--fixup和--Squash将自动建议使用另一个ComputCing Rebase，如果为该命令提供--AutoSquash标志，则会自动建议使用upducing rebase。 （默认情况下，运行Git Config-Global Rebase.autosquash true。它赢得了＆＃39;如果没有在athistory中没有编辑＆＃34;南瓜！＆＃34;或＆＃34;修复！＆＃34;。）一个惊喜奖金：由于修复操作继承了先前提交的消息，因此提示输入新的奖励。</p><p> git rebase --interactive main – I canalso use  git rebase --interactive HEAD~5 to edit the last 5 commits, but Ifind rebasing directly on  main (or  master, or whatever my upstream branchis) kills two birds with one stone. It will show me all commits since Ibranched off from  main, and will simultaneously bring my branch up to datewith my latest local copy of main.</p><p> Git Rebase  -  Interactive Main  - 我可以使用git rebase  -  interactive head〜5编辑最后5个提交，但Ifind rechasing直接在主（或掌握，或者上游的brankis）用一块石头杀死两只鸟。它将向我展示自从Memon的Ibranched以来的所有提交，并将同时将我的分支带到我最新的主要当地主要副本。</p><p> git stash – Sometimes I have unrelatedchanges on the go that I don&#39;t want to commit right now.  git stash is aneasy way to make them go away, and  git stash pop brings them back again.Just use it sparingly, because finding your changes in the stash later is apain. If I&#39;m not planning to pop it back off again in the near future, I makea progress commit instead.</p><p> git stash  - 有时候我没有想到的，我现在不想提交。 git stash是一种让他们走开的一种自由的方式，而git stash pop会再次恢复它们。谨慎使用它，因为找到了困难后来的更改是猿。如果我没有计划在不久的将来再次突破它，我的进步提交了。</p><p> git blame – Okay, this is morevaluable in collaboration. When it&#39;s my code base, I already know whose faultit is. Still, despite the name, I use  git blame not to find out who toblame, but to find out why something was done. That applies equally whetherit was done by another developer or me six months ago. Most commonly, I&#39;ll useit when I see something that  looks like a bug, and I want to find out: a)what purpose the thing was supposed to serve, b) if it was successful inserving that purpose, and c) whether or not any related code is still in thecode base. It&#39;s the task of finding related code that really puts yourproject&#39;s commit hygiene to the test.</p><p> git责备 - 好的，这是在合作中的更值。当它＆＃39;我的代码库时，我已经知道谁的错位。尽管如此，我仍然存在，我使用Git责备不要找出谁是谁，而是为了了解为什么做某事。六个月前，它同样适用。最常见的是，我＆＃39;当我看到看起来像一个虫子的东西时，我想知道：a）如果它成功地确保了该目的，那么这件事就应该服务的目的是什么？无论是否有关代码仍处于Thecode基础中。它和＃39;找到真正将yourproject＆＃39; s致力于测试的相关代码的任务。</p><p> The usual Git/Vim disclaimer applies to my list: if you get five power users ina room and ask them to do a complicated task, they&#39;ll get it done quickly,efficiently, and in seven different ways. The commands I use are not the onlyways to accomplish the same results, and are probably not the best way.</p><p> 通常的git / vim免责声明适用于我的列表：如果您获得五个电源用户Ina房间并要求他们做一个复杂的任务，他们会通过七种不同的方式完成快速，有效地完成。我使用的命令不是唯一实现相同结果的道路，可能不是最好的方式。</p><p>  While I think my workflow stands on its own as a way of structuring yourthoughts and ensuring that your test coverage is good, this is of course also aworkflow that will get you a lot of love from coworkers or collaborators.Well-crafted pull requests are  a joy less of a misery to review, andreferring back to a well-written commit turned up in  git blame makes it mucheasier to understand what you or another developer was trying to accomplish witha change (and evaluate whether or not it was successful).</p><p>  虽然我认为我的工作流程独立就像一个构建你的方法，确保你的测试覆盖是好的，这当然也是Aworkflow，让你从同事或合作者那里得到很多爱。威尔制作的拉出请求是一个令人痛苦的痛苦越来越多的审查，并转回了一个写作的提交人，因为Git Chinkend造成了责任，使你或另一个开发人员试图通过变革来实现的东西很多，并评估它是否成功）。</p><p> And of course, there&#39;s   git bisect. Theshort version, for those who haven&#39;t used it, is that  git bisect allows you tofind when something changed, across  all of history, either  manually or usingautomated tests, all in  O(log n) time. Ensuring that your commits always passtests make them friendly to  git bisect, and ensuring that they are as small aspossible means that when bisect tells you which commit introduced a bug, thereis very little code in which that bug could appear.</p><p> 当然，那里的git bot。 TheShort版本，适用于那些vit＆＃39; t使用它，是git bisect在手动或使用历史上的所有历史记录时都可以弥补，所有在O（log n）时间。确保您的提交普遍存在普通人使他们能够友好地友好地友好，并确保它们是小的只有的动意意味着当Bisect告诉您哪个提交引入错误时，其中可以出现很少的代码。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mikkel.ca/blog/git-is-my-buddy-effective-solo-developer/">https://mikkel.ca/blog/git-is-my-buddy-effective-solo-developer/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/好友/">#好友</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/提交/">#提交</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>