<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>执行Docker容器作为QEMU MicroVMS </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">执行Docker容器作为QEMU MicroVMS </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-17 01:18:41</div><div class="page_narrow text-break page_content"><p>Warning: Can only detect less than 5000 characters</p><p>让我们开始吧！与大多数常规VM不同，我们跳过BIOS / UEFI初始化并直接引导到内核中。这是Qemu的一个很好的特征，但提出了我们应该启动的内核的问题？ Docker容器通常不包括一个。答案很简单：我们构建自己的内核，只包含我们实际需要的驱动程序。要使您的生活更轻松，您可以从这里获取我的内核配置，并使用下面的命令编译它：</p><p>  由于我们现在在Arch / X86_64 / Boot / Bzimage上有一个编译的内核映像，我们可以尝试使用qemu microvm引导内核的第一步。由于我们不提供任何文件系统，因此系统将恐慌，但它为我们提供了一个基线，用于将容器才能启动多长时间。</p><p> $ qemu-system-x86_64-m microvm，x-option-roms =关闭，ISA-Serial = OFF，RTC = OFF -NO-ACPI -ENABLY-KVM -CPU主机--Nodefaults -NO-User-Config -Nographic -No -reboot -device Virtio-erial-device -Chardev stdio，ID = Virtiocon0 -Device VirtConsole，Chardev = VirtioCon0 -Kernel Kernel / Bzimage -Append＆＃34;控制台= HVC0 ACPI = OFF重启= T PANIC = -1＆＃34; [0.043774]加载了X.509 Cert＆＃39;构建时间自动化内核键：A55DE9768F536D965F27C2FE6FC963974D95B367＆＃39; [0.044079]键类型._fscrypt注册[0.044211]键类型.fscrypt注册[0.044294]关键类型fscrypt-配置已注册[0.044559]密钥类型加密已注册[0.044888] VFS：无法打开根设备＆＃34;（null）＆＃34;或未知块（0,0）：错误-6 [0.045056]请附加正确的＆＃34; root =＆＃34;启动选项;以下是可用的分区：[0.045224]内核恐慌 - 不同步：VFS：无法在未知块（0,0）上装入根FS [0.045386] CPU：0 PID：1 Comm：Swapper / 0不受污染5.12.10 ＃1 [0.045479]呼叫跟踪：[...]</p><p> 正如常规的那样，具有VFS的内核恐慌：无法打开根设备＆＃34;（null）＆＃34;或未知块（0,0）：错误-6。更有趣的细节是，内核花费不到50毫秒才能初始化！如果添加Qemu的启动时间，您将获得左右180ms。您可以尝试进一步通过压缩内核进行优化，但这足以让我们的用例。</p><p> 让我们仔细看看用于启动Qemu的命令行选项，因为这些是很多：</p><p> 切换到MicroVM模式并禁用所有不必要的设备（BIOS选项ROM，ISA串行设备和实时时钟）</p><p> 禁用ACPI支持，通常用于控制主机的电源状态（即待机模式） </p><p>添加一个串行设备，该设备与主机上的STDIN / STDOUT以名称的VirtioCon0名称</p><p>   内核命令行。使用HVC0（= VirtioCon0）为控制台，禁用ACPI无论如何都没有，使用三重CPU故障重新启动（正常重启需要ACPI）并在发生恐慌时立即重新启动</p><p> 由于内核似乎工作，我们可以从我们的Todo列表中勾选并继续init系统。</p><p>  在安装内核命令行指定的文件系统后，Linux将尝试执行/索引/ init和恐慌，如果它终止或根本不存在。我们现在可以尝试使用Docker Image的入口点作为init，但这可能会失败，因为我们的Linux环境尚未完全初始化。我们需要注入一个Init系统，该系统考虑安装各种目录并设置其他系统设置。可以使用SystemD或BusyBox init的内容，但在大多数情况下，这将是矫枉过正的。对于开始，我们使用自己的自我写入初始系统：</p><p> #include＆lt; errno.h＆gt; #include＆lt; stdio.h＆gt; #include＆lt; stdlib.h＆gt; #include＆lt; unistd.h＆gt; #include＆lt; sys / mount.h＆gt; #include＆lt; sys / stat.h＆gt; #include＆lt; sys / stat.h＆gt; char * const default_environment [] = {＆＃34; path = / usr / local / bin：/ usr / local / sbin：/ usr / bin：/ usr / sbin：/ bin：/ sbin＆＃34;，null，} ; void mount_check（const char * source，const char * target，const char * filesystemtype，unsigned long mountflags，const void * data）{struct stat info; if（统计（目标，＆amp;信息）==  -  1＆amp;＆amp; errno == Enoent）{printf（＆＃34;创建％s \ n＆＃34;目标）; if（mkdir（target，0755）＆lt; 0）{perror（＆＃34;创建目录失败＆＃34;）;出口（1）; printf（＆＃34;安装％s \ n＆＃34;目标）; if（mount（源，目标，filesystemtype，mountflags，data）＆lt; 0）{perror（＆＃34;装载失败＆＃34;）;出口（1）; int main（int argc，char * argv []）{mount_check（＆＃34; none＆＃34; / proc＆＃34 ;,＆＃34; proc＆＃34 ;, 0，＆＃34 ;＆＃34;）; mount_check（＆＃34;没有＃34; / dev / pts＆＃34;＆＃34; devpts＆＃34 ;, 0，＆＃34;＆＃34;）; mount_check（＆＃34;没有＆＃34; / dev / muqueue＆＃34 ;,＃34; muque＆＃34 ;, 0，＆＃34;）; mount_check（＆＃34;没有＃34; / dev / shm＆＃34 ;,＃34; tmpfs＆＃34 ;, 0，＆＃34;）; mount_check（＆＃34;没有＆＃34; / sys＆＃34 ;,＃34; sysfs＆＃34 ;, 0，＆＃34;＆＃34;）; mount_check（＆＃34;没有＆＃34; / sys / fs / cgroup＆＃34; cgroup＆＃34; 0，＆＃34;＆＃34;＆＃34;）; sethostname（＆＃34; microvm＆＃34; sizeof（＆＃34; microvm＆＃34;））; execle（＆＃34; / bin / sh＆＃34;＆＃34; / bin / sh＆＃34;，null，default_environment）; perror（＆＃34; exec失败＆＃34;）;返回1;}</p><p> 当启动容器时，该小C应用程序基本上与Docker相同。使测试更容易，我们将硬件/垃圾箱/ sh作为入口点。从长远来看，您希望将其替换为其他应用程序或启动脚本。请注意，我们使用execle替换我们的init应用程序，以便目标进程成为新的init进程。如果应用程序不等待子进程（呼叫Sigchld上的WADEPID（）），您可能最终可以使用大量僵尸进程，因为所有孤立进程都重新定义到init进程。如果事实证明是一个问题，可以扩展小的C脚本，或者您可以通过Bash运行所有内容，这也可以照顾此操作。</p><p>   在我们可以测试我们的init应用程序之前，我们首先需要一个文件系统，我们可以注入它。文件系统还需要提供/ bin / sh。让我们弄清楚如何将码头图像转换为QEMU磁盘图像！ </p><p>我们现在编译了我们的内核并创建了一个简单而简约的初始系统。最后缺少部分是在我们第一次测试我们的方法之前将现有的Docker映像转换为虚拟机磁盘映像。在此过程中，我们将注入自己的init系统二进制文件，以便我们不需要单独的initramfs文件系统。我们将我们的方法分为两个步骤，首先我们尝试生成包含基本文件系统的Tar存档，然后我们将其转换为磁盘映像。</p><p> 有多种方式如何将码头图像转换为tar存档。最简单的方法是使用Docker构建。它为我们提供了一种简单的方法，如何注入我们的init系统，我们也可以自定义图像。另一种方法是使用Docker容器创建和Docker容器导出以导出基本文件系统或手动组合由Docker Save导出的图层。对于本教程，我们将使用Docker构建，但您也可以使用脚本从Docker注册表中获取不同的图层，而不是使用Docker。</p><p> 对于我们的第一次测试，我们将使用Alpine Linux并告诉Docker Build来注入我们的init系统并将文件系统作为tar存档提取：</p><p>   我们几乎已经完成，只需将TAR存档转换为QCOW2图像：</p><p>  第一个命令将tar存档转换为qcow2图像。 QCOW2图像格式与使用原始图像的效率不高，但它有各种优势，我们可以从中受益。与Docker容器相比，使用VM的一个问题是您不能轻易在访客和主机之间共享资源。 VM无法简单地使用所有可用的磁盘空间，但仅限于磁盘映像的大小。从安全性的角度来看，限制容器可用的最大磁盘空间是有意义的，但有时候很难提前预测所需的磁盘空间量，并且您可能希望更多地分配才能确定（见大小参数）。使用原始图像时，您将最终包含几乎没有任何内容的巨大图像文件，如果您不希望丢失大量磁盘空间，则需要依赖您的文件系统作为稀疏处理文件。图像格式QCow2已经支持稀疏图像本身，至少在理论上。出于某种原因，Virt-Make-FS不会产生稀疏图像，并且生成的Alpine-Light.qcow2的大小为207MB。要解决此问题，我们调用qemu-img转换重新编码我们的图像文件，它会缩小到9.9MB。使用QCOW2的另一个优点是它支持差异图像，因为我们稍后会看到。</p><p>  我们现在收集了所有依赖关系，并可以第一次运行VM。我们只需要调整我们的QEMU命令行有点以附加磁盘映像。</p><p> qemu-system-x86_64-m microvm，x-option-roms =关闭，ISA-Serial = OFF，RTC = OFF -NO-ACPI -ENABLY-KVM -CPU主机--Nodefaults -No-User-Config -Nographic -No- Reboot -Device Virtio-Serial-Device -Chardev STDIO，ID = VirtioCon0 -Device VirtConsole，Chardev = VirtioCon0 -Drive ID = root，file = Alpine.qcow2，format = qcow2，if = none -device Virtio-Blk-Device，驱动器= root -kernel kernel / bzimage -append＆＃34;控制台= hvc0 root = / dev / vda rw acpi =关闭重启= t panic = -1＆＃34; </p><p>我们的概念证明作品！我们可以在Qemu运行的Alpine Docker集装箱内执行应用程序。这是一个非常简单的例子。为了做点什么，我们需要延长我们的方法。</p><p>  我们已经证明，将Docker图像转换为VM的基本思想，但有各种功能缺少，以便真正利用这种方法。到目前为止，我们只能使用STDIO与VM通信，并且每次启动新实例时都需要重新创建图像。让我们进一步掌握这种方法，并学习如何模仿Docker的各种功能。</p><p>  如果您熟悉QEMU并密切关注命令行，您会注意到我们定义了所有所需的设备，但从未真正指定了内存量或CPU内核数量。默认情况下，VM将具有大约100MB的内存和1个CPU核心。在实践中，这可能是不够的，并且您希望扩展命令行：</p><p>  将更多CPU核心分配给VM而不是必需的不是真正的问题，因为VM只是在系统中的任何其他进程中运行。如果访客无法完全使用其所有指定的核心，则您的主机CPU仍然可以使用其他任务或VM的物理核心。因此，如果您不知道实际需要多少，则可以过度管理虚拟CPU内核的数量。</p><p> 您可能会迟早注意到的另一个问题是Linux内核永远才能初始化随机数生成器。我们的MicroVM中根本没有真正的熵源，并且试图访问RNG的应用程序将冻结。您可以通过将主机RNG公开给来宾：使用：</p><p>   我们必须每次启动VM时重新创建磁盘映像，如果我们要确保未通过上一个运行修改图像，或者我们要并行执行多个实例。这减慢了启动过程，并且还会消耗比必要的更多磁盘空间。一个选项是将磁盘映像标记为只读，但这可能会破坏大多数容器，除非我们将额外的技巧应用于TMPFS覆盖物。更好的方法是使用qemu的差分/增量磁盘映像特征。这允许我们在原始图像文件的顶部添加另一层。所有写入指令只修改顶层顶层，而我们的原始图像文件被视为只读。这种方法与Docker的OverlayFS存储驱动程序非常相似。</p><p>   只需替换QEMU命令行选项中的图像文件名，您就完成了。现在可以并行运行具有相同基础图像的多个VM。在VM终止之后，您可以再次删除差异图像。您可能希望将这些步骤包装到脚本中，以便您不必手动执行它们。 </p><p>如果要保持其中一个VM所做的更改，则可以使用以下方式将它们与基本图像合并：</p><p>   概念证明只使用STDIO与外部世界进行沟通，并且没有其他方式进出数据。如果您想在主机和访客之间传输大量文件，这显然不够。有两种简单的方法，我们可以用来传输文件。</p><p> 使用磁盘映像：如果只想在VM开始之前上传/下载文件，并且在终止之后，您可以简单地修改差分磁盘映像中的文件。像QEMU-NBD或Guestmount这样的工具可以简单地安装在主机系统中的图像，以便您可以根据需要读取和写入文件。这样的方法是有意义的（可重复的）构建。源代码在VM开始之前上载，并且在VM关闭后提取生成的软件包。</p><p> 虽然VM正在运行：如果要在运行时与VM共享文件，则可以使用9PFS虚拟文件系统设备。此设备允许您从主机系统挂载目录，类似于码头器中的绑定安装。要将目录公开给客户端，我们需要向QEMU命令行添加两个选项：</p><p> 使用ID文件注册MyFiles目录。如果需要，您可以将RabOnly添加为选项。</p><p> 要访问guest虚拟机中的文件，您需要使用mount_tag指定的名称装入文件系统。如果使用前面提供的内核配置，则使用Virtio的9P网络文件系统支持。您可以使用命令行安装文件系统：</p><p>    您可能需要调整MSIZE参数，如QEMU Wiki中所述，以获得最佳性能。 </p><p>QEMU提供可用于在访客和主机之间进行通信的各种虚拟设备。 最明显的解决方案是添加网络设备。 在许多情况下，这可能是必要的，但它也具有您需要在主机上创建桥梁或虚拟以太网设备的缺点。 此步骤需要特殊的权限，也是默认情况下为root运行的原因之一。 如果您不需要实际的网络访问，则可能需要尝试其他选项之一。  串行设备：您可以将一个或多个串行设备添加到访客并以各种方式（管道，套接字，文件等）从主机访问它们。 这使得可以在主机和访客之间传输数据。 Virtio设备也比模拟硬件串行设备快得多。 我在过去使用这种方法将Live-Stream Build Logs到构建系统的网站。  如果你想  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mergeboard.com/blog/2-qemu-microvm-docker/">https://mergeboard.com/blog/2-qemu-microvm-docker/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>