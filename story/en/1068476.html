<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让我们代码TCP / IP堆栈（2016） Let's code a TCP/IP stack (2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Let's code a TCP/IP stack (2016)<br/>让我们代码TCP / IP堆栈（2016） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-29 22:45:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/ab44f4c3edc604980a93c0aa5664efbb.png"><img src="http://img2.diglog.com/img/2021/6/ab44f4c3edc604980a93c0aa5664efbb.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Writing your own TCP/IP stack may seem like a daunting task. Indeed, TCP has accumulated many specifications over its lifetime of more than thirty years. The core specification, however, is seemingly compact  1 - the important parts being TCP header parsing, the state machine, congestion control and retransmission timeout computation.</p><p>写自己的TCP / IP堆栈可能看起来像是一个令人生畏的任务。实际上，TCP积累了超过三十年的寿命的许多规格。然而，核心规范看似紧凑1  -  TCP标题解析的重要部分，状态机，拥塞控制和重传超时计算。</p><p> The most common layer 2 and layer 3 protocols, Ethernet and IP respectively, pale in comparison to TCP’s complexity. In this blog series, we will implement a minimal userspace TCP/IP stack for Linux.</p><p> 分别是最常见的第2层和第3层协议，以太网和IP，与TCP的复杂性相比，苍白。在此博客系列中，我们将为Linux实施最小的用户空间TCP / IP堆栈。</p><p> The purpose of these posts and the resulting software is purely educational - to learn network and system programming at a deeper level.</p><p> 这些帖子的目的和生成的软件纯粹是教育 - 以更深层次的级别学习网络和系统编程。</p><p>    To intercept low-level network traffic from the Linux kernel, we will use a Linux TAP device. In short, a TUN/TAP device is often used by networking userspace applications to manipulate L3/L2 traffic, respectively. A popular example is  tunneling, where a packet is wrapped inside the payload of another packet.</p><p>    要从Linux内核拦截低级网络流量，我们将使用Linux Tap设备。简而言之，网络用户空间应用程序通常使用TUN / TAP设备分别用于操纵L3 / L2流量。一个流行的例子是隧道，其中数据包在另一个数据包的有效载荷内包装。</p><p> The advantage of TUN/TAP devices is that they’re easy to set up in a userspace program and they are already being used in a multitude of programs, such as  OpenVPN.</p><p> TUN / TAP设备的优势在于它们易于在用户空间程序中设置，并且它们已在多个程序中使用，例如OpenVPN。</p><p> As we want to build the networking stack from the layer 2 up, we need a TAP device. We instantiate it like so:</p><p> 正如我们想要从第2层构建网络堆栈，我们需要一个点击设备。我们将其实例化：</p><p> /* * Taken from Kernel Documentation/networking/tuntap.txt */ int  tun_alloc ( char  * dev ) {  struct  ifreq  ifr ;  int  fd ,  err ;  if (  ( fd  =  open ( &#34;/dev/net/tap&#34; ,  O_RDWR ))  &lt;  0  )  {  print_error ( &#34;Cannot open TUN/TAP dev&#34; );  exit ( 1 );  }  CLEAR ( ifr );  /* Flags: IFF_TUN - TUN device (no Ethernet headers) * IFF_TAP - TAP device * * IFF_NO_PI - Do not provide packet information */  ifr . ifr_flags  =  IFF_TAP  |  IFF_NO_PI ;  if (  * dev  )  {  strncpy ( ifr . ifr_name ,  dev ,  IFNAMSIZ );  }  if (  ( err  =  ioctl ( fd ,  TUNSETIFF ,  ( void  * )  &amp; ifr ))  &lt;  0  ){  print_error ( &#34;ERR: Could not ioctl tun: %s \n &#34; ,  strerror ( errno ));  close ( fd );  return  err ;  }  strcpy ( dev ,  ifr . ifr_name );  return  fd ; }</p><p> / * *从内核文档/ networking / tuntap.txt * / int tun_alloc（char * dev）{struct ifreq ifr; int fd，err; if（（fd =打开（＆＃34; / dev / net / tap / tap＆＃34;，o_rdwr））＆lt; 0）{print_error（＆＃34;无法打开tun / tap dev＆＃34;）;出口（1）; }清除（IFR）; / *标志：IFF_TUN  -  TUN设备（无以太网标题）* IFF_TAP  - 点击设备* * IFF_NO_PI  - 不提供数据包信息* / IFR。 ifr_flags = iff_tap | iff_no_pi; if（* dev）{strncpy（ifr。ifr_name，dev，ifnamsiz）;如果（（eroctl（fd，tunsetiff，（void *）＆amp; ifr））＆lt; 0）{print_error（＆＃34; err：不能ioctl tun：％s \ n＆＃34;，sterror（ errno））;关闭（FD）;返回错误; strcpy（dev，ifr。ifr_name）;返回FD; } </p><p> After this, the returned file descriptor  fd can be used to  read and  write data to the virtual device’s ethernet buffer.</p><p>在此之后，返回的文件描述符FD可用于读取和写入虚拟设备的以太网缓冲区。</p><p> The flag  IFF_NO_PI is crucial here, otherwise we end up with unnecessary packet information prepended to the Ethernet frame. You can actually take a look at the kernel’s  source code of the tun-device driver and verify this yourself.</p><p> FLAG IFF_NO_PI在此处至关重要，否则我们最终会有不必要的数据包信息向以太网帧。您实际上可以查看核心设备驱动程序的内核源代码，并验证此操作。</p><p>  The multitude of different Ethernet networking technologies are the backbone of connecting computers in  Local Area Networks (LANs). As with all physical technology, the Ethernet standard has greatly evolved from its first version  2, published by Digital Equipment Corporation, Intel and Xerox in 1980.</p><p>  众多不同的以太网网络技术是在局域网（LAN）中连接计算机的骨干。与所有物理技术一样，以太网标准从1980年由数字设备公司，英特尔和施乐发布的第一个版本2。</p><p> The first version of Ethernet was slow in today’s standards - about 10Mb/s and it utilized half-duplex communication, meaning that you either sent or received data, but not at the same time. This is why a  Media Access Control (MAC) protocol had to be incorporated to organize the data flow. Even to this day,  Carrier Sense, Multiple Access with Collision Detection (CSMA/CD) is required as the MAC method if running an Ethernet interface in half-duplex mode.</p><p> 以太网的第一个版本在当今标准中缓慢 - 约为10MB / s，它使用了半双工通信，这意味着您要么发送或接收数据，但不同时。这就是为什么必须合并媒体访问控制（MAC）协议以组织数据流。即使到了这一天，如果在半双工模式下运行以太网接口，则需要使用碰撞检测（CSMA / CD）的多次访问。</p><p> The invention of the  100BASE-T Ethernet standard used twisted-pair wiring to enable full-duplex communication and higher throughput speeds. Additionally, the simultaneous increase in popularity of Ethernet switches made CSMA/CD largely obsolete.</p><p> 100Base-T以太网标准使用双绞线接线的发明，实现全双工通信和较高的吞吐量速度。此外，以太网交换机的普及同时增加，使CSMA / CD很大陈旧。</p><p>  Next, we’ll take a look at the Ethernet Frame header. It can be declared as a C struct followingly:</p><p>  接下来，我们会查看以太网帧头。它可以跟踪C结构声明：</p><p> #include &lt;linux/if_ether.h&gt; struct  eth_hdr {  unsigned  char  dmac [ 6 ];  unsigned  char  smac [ 6 ];  uint16_t  ethertype ;  unsigned  char  payload []; }  __attribute__ (( packed ));</p><p> #include＆lt; linux / if_ether.h＆gt; struct eth_hdr {unsigned char dmac [6]; unsigned char smac [6]; uint16_t以太网; unsigned char payload []; } __attribute__（（包装））; </p><p> The  dmac and  smac are pretty self-explanatory fields. They contain the MAC addresses of the communicating parties (destination and source, respectively).</p><p>DMAC和SMAC是非常自我解释的领域。它们包含传送方的MAC地址（分别为目的地和来源）。</p><p> The overloaded field,  ethertype, is a 2-octet field, that depending on its value, either indicates the length or the type of the payload. Specifically, if the field’s value is greater or equal to 1536, the field contains the type of the payload (e.g. IPv4, ARP). If the value is less than that, it contains the length of the payload.</p><p> 重载的字段以太网是一个2个八位字节字段，即根据其值，指示有效载荷的长度或类型。具体而言，如果字段的值更大或等于1536，则该字段包含有效载荷的类型（例如IPv4，ARP）。如果值小于该值，则它包含有效载荷的长度。</p><p> After the type field, there is a possibility of several different  tags for the Ethernet frame. These tags can be used to describe the  Virtual LAN (VLAN) or the  Quality of Service (QoS) type of the frame. Ethernet frame tags are excluded from our implementation, so the corresponding field also does not show up in our protocol declaration.</p><p> 在类型字段之后，以太网帧有几种不同的标签。这些标签可用于描述虚拟LAN（VLAN）或帧的服务质量（QoS）类型。以太网帧标记被排除在我们的实现之外，因此相应的字段也不会显示在我们的协议声明中。</p><p> The field  payload contains a pointer to the Ethernet frame’s payload. In our case, this will contain an ARP or IPv4 packet. If the payload length is smaller than the minimum required 48 bytes (without tags), pad bytes are appended to the end of the payload to meet the requirement.</p><p> 现场有效负载包含指向以太网帧的有效载荷的指针。在我们的情况下，这将包含ARP或IPv4数据包。如果有效载荷长度小于所需的48字节（没有标签），则填充字节将附加到有效载荷的末尾以满足要求。</p><p> We also include the  if_ether.h Linux header to provide a mapping between ethertypes and their hexadecimal values.</p><p> 我们还包括IF_ETHER.H Linux标题，以提供以太网类型和其十六进制值之间的映射。</p><p> Lastly, the Ethernet Frame Format also includes the  Frame Check Sequence field in the end, which is used with  Cyclic Redundancy Check (CRC) to check the integrity of the frame. We will omit the handling of this field in our implementation.</p><p> 最后，以太网帧格式还包括结尾的帧检查序列字段，其与循环冗余校验（CRC）一起使用，以检查帧的完整性。我们将在我们的实施中省略处理该领域。</p><p>  The attribute  packed in a struct’s declaration is an implementation detail - It is used to instruct the GNU C compiler not to optimize the struct memory layout for data alignment with padding bytes  4. The use of this attribute stems purely out of the way we are “parsing” the protocol buffer, which is just a type cast over the data buffer with the proper protocol struct:</p><p>  在STRACH的声明中包装的属性是实现详细信息 - 它用于指示GNU C编译器不优化与填充字节的数据对齐的结构存储器布局4.使用此属性纯粹符合我们的方式“解析“协议缓冲区，该协议缓冲区只是使用正确的协议结构在数据缓冲区上传递的类型： </p><p>  A portable, albeit slightly more laborious approach, would be to serialize the protocol data manually. This way, the compiler is free to add padding bytes to conform better to different processor’s data alignment requirements.</p><p>一个便携式，尽管稍微更加费力的方法，是手动序列化协议数据。这样，编译器可以自由地添加填充字节以更好地符合不同的处理器的数据对齐要求。</p><p>  if  ( tun_read ( buf ,  BUFLEN )  &lt;  0 )  {  print_error ( &#34;ERR: Read from tun_fd: %s \n &#34; ,  strerror ( errno )); } struct  eth_hdr  * hdr  =  init_eth_hdr ( buf ); handle_frame ( &amp; netdev ,  hdr );</p><p>  if（tun_read（buf，buflen）＆lt; 0）{print_error（＆＃34; err：从tun_fd读取：％s \ n＆＃34;，sterror（errno））; struct eth_hdr * hdr = init_eth_hdr（buf）; handle_frame（＆amp; netdev，hdr）;</p><p> The  handle_frame function just looks at the  ethertype field of the Ethernet header, and decides its next action based upon the value.</p><p> handle_frame函数只查看以太网标题的EtherType字段，并根据值决定其下一个操作。</p><p>  The  Address Resolution Protocol (ARP) is used for dynamically mapping a 48-bit Ethernet address (MAC address) to a protocol address (e.g. IPv4 address). The key here is that with ARP, multitude of different L3 protocols can be used: Not just IPv4, but other protocols like CHAOS, which declares 16-bit protocol addresses.</p><p>  地址解析协议（ARP）用于将48位以太网地址（MAC地址）动态映射到协议地址（例如IPv4地址）。这里的关键是通过ARP，可以使用多个不同的L3协议：不仅仅是IPv4，而是混沌等其他协议，它声明了16位协议地址。</p><p> The usual case is that you know the IP address of some service in your LAN, but to establish actual communications, also the hardware address (MAC) needs to be known. Hence, ARP is used to broadcast and query the network, asking the owner of the IP address to report its hardware address.</p><p> 通常的情况是您知道LAN中某些服务的IP地址，但要建立实际通信，还需要知道硬件地址（MAC）。因此，ARP用于广播和查询网络，询问IP地址的所有者报告其硬件地址。</p><p>  struct  arp_hdr {  uint16_t  hwtype ;  uint16_t  protype ;  unsigned  char  hwsize ;  unsigned  char  prosize ;  uint16_t  opcode ;  unsigned  char  data []; }  __attribute__ (( packed ));</p><p>  struct arp_hdr {uint16_t hwtype; UINT16_T型焊接; unsigned char hwsize;未签名的炭辱; UINT16_T OPCODE; unsigned char数据[]; } __attribute__（（包装））;</p><p> The ARP header ( arp_hdr) contains the 2-octet  hwtype, which determines the link layer type used. This is Ethernet in our case, and the actual value is  0x0001.</p><p> ARP标题（ARP_HDR）包含2-OCTET HWTYPE，该HWTYPE确定使用的链路层类型。在我们的情况下，这是以太网，实际值为0x0001。 </p><p> The 2-octet  protype field indicates the protocol type. In our case, this is IPv4, which is communicated with the value  0x0800.</p><p>2-octet Prolype字段表示协议类型。在我们的情况下，这是IPv4，它与值0x0800通信。</p><p> The  hwsize and  prosize fields are both 1-octet in size, and they contain the sizes of the hardware and protocol fields, respectively. In our case, these would be 6 bytes for MAC addresses, and 4 bytes for IP addresses.</p><p> HWSIZE和PRESIZE FIALES的大小均为1八位字节，它们分别包含硬件和协议字段的大小。在我们的情况下，MAC地址为6个字节，IP地址为4个字节。</p><p> The 2-octet field  opcode declares the type of the ARP message. It can be ARP request (1), ARP reply (2), RARP request (3) or RARP reply (4).</p><p> 2-octet字段操作码声明ARP消息的类型。它可以是ARP请求（1），ARP回复（2），RARP请求（3）或RARP回复（4）。</p><p> The  data field contains the actual payload of the ARP message, and in our case, this will contain IPv4 specific information:</p><p> 数据字段包含ARP消息的实际有效载荷，并且在我们的情况下，这将包含IPv4特定信息：</p><p>  The fields are pretty self explanatory.  smac and  dmac contain the 6-byte MAC addresses of the sender and receiver, respectively.  sip and  dip contain the sender’s and receiver’s IP addresses, respectively.</p><p>  这些田地非常自我解释。 SMAC和DMAC分别包含发件人和接收者的6字节MAC地址。 SIP和DIP分别包含发件人和接收器的IP地址。</p><p>   ?Do I have the hardware  type  in ar $hrd?Yes:  (almost definitely )  [optionally check the hardware length ar $hln ] ?Do I speak the protocol  in ar $pro? Yes:  [optionally check the protocol length ar $pln ] Merge_flag : =  false If the pair &lt;protocol  type, sender protocol address&gt; is already  in my translation table, update the sender hardware address field of the entry with the new information  in the packet and  set Merge_flag to true. ?Am I the target protocol address? Yes: If Merge_flag is  false, add the triplet &lt;protocol  type, sender protocol address, sender hardware address&gt; to the translation table. ?Is the opcode ares_op $REQUEST?  (NOW look at the opcode!! ) Yes: Swap hardware and protocol fields, putting the  local hardware and protocol addresses  in the sender fields. Set the ar $op field to ares_op $REPLY Send the packet to the  (new ) target hardware address on the same hardware on which the request was received.</p><p>   ？我是否在AR $ HRD中有硬件类型？是的:(几乎肯定）[可选地检查硬件长度AR $ HLN]？我是否在AR $ PRO中讲协议？是：[可选地检查协议长度AR $ PLN] merge_flag：= false如果该对＆lt;协议类型，发件人协议地址＆gt;已经在我的翻译表中，使用数据包中的新信息更新条目的发件人硬件地址字段，并将merge_flag设置为true。我是目标协议地址吗？是：如果merge_flag为false，则添加三态组＆lt;协议类型，发件人协议地址，发件人硬件地址＆gt;到翻译表。 ？操作码ares_op $申请吗？ （现在看看Opcode !!）是：交换硬件和协议字段，将本地硬件和协议地址放在发件人字段中。将AR $ OP字段设置为ARES_OP $ REPLY将数据包发送到收到请求的同一硬件上的（新）目标硬件地址。</p><p> Namely, the  translation table is used to store the results of ARP, so that hosts can just look up whether they already have the entry in their cache. This avoids spamming the network for redundant ARP requests.</p><p> 即，翻译表用于存储ARP的结果，以便主机可以查看它们是否已在其缓存中有条目。这避免了垃圾签发冗余ARP请求的网络。 </p><p>  Finally, the ultimate test for an ARP implementation is to see whether it replies to ARP requests correctly:</p><p>最后，ARP实现的最终测试是看它是否正确地返回ARP请求：</p><p> [saminiir@localhost lvl-ip] $ arping  -I tap0 10.0.0.4ARPING 10.0.0.4 from 192.168.1.32 tap0Unicast reply from 10.0.0.4  [00:0C:29:6D:50:25] 3.170msUnicast reply from 10.0.0.4  [00:0C:29:6D:50:25] 13.309ms [saminiir@localhost lvl-ip] $ arpAddress HWtype HWaddress Flags Mask Iface10.0.0.4 ether 00:0c:29:6d:50:25 C tap0</p><p> [saminiir @ localhost lvl-ip] $ arping -i tap0 10.0.0.4arping 10.0.4起从192.168.1.32 Tap 0unicast回复从10.0.0.4从10.0.0.4 [00：0C：29：6D：50：25] 3.170msunicast回复从10.0.0.4 [00：0C：29：6D：50：25] 13.309MS [Saminiir @ localhost lvl-IP] $ Arpaddress HWTYPE HWAddress Flags Mask iFace10.0.0.4 ether00：0C：29：6D：50：25 C Tap0</p><p> The kernel’s networking stack recognized the ARP reply from our custom networking stack, and consequently populated its ARP cache with the entry of our virtual network device. Success!</p><p> 内核的网络堆栈识别来自自定义网络堆栈的ARP回复，因此使用我们的虚拟网络设备的条目填充其ARP缓存。成功！</p><p>  The minimal implementation of Ethernet Frame handling and ARP is relatively easy and can be done in a few lines of code. On the contrary, the reward-factor is quite high, since you get to populate a Linux host’s ARP cache with your own make-belief Ethernet device!</p><p>  以太网帧处理和ARP的最小实现相对容易，并且可以在几行代码中完成。相反，奖励因素非常高，因为您可以使用自己的制作信念以太网设备填充Linux主机的ARP缓存！</p><p>  In the next post, we’ll continue the implementation with ICMP echo &amp; reply (ping) and IPv4 packet parsing.</p><p>  在下一个帖子中，我们将继续执行ICMP Echo＆amp;回复（ping）和IPv4数据包解析。</p><p> If you liked this post, you can  share it with your followers and   follow me on Twitter!</p><p> 如果您喜欢这篇文章，您可以与您的追随者分享并跟随我的推特！</p><p> Kudos to Xiaochen Wang, whose similar implementation proved invaluable for me in getting up to speed with C network programming and protocol handling. I find his  source code  5 easy to understand and some of my design choices were straight-out copied from his implementation.</p><p> Kudos到Xiaochen Wang，其类似的实现对我来说，在加快C网络编程和协议处理时，对我来说是非常宝贵的。我发现他的源代码5易于理解，我的一些设计选择从他的实施中直接复制。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/">https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tcp/">#tcp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/协议/">#协议</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>