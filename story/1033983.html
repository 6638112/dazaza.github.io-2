<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Scala构建您自己的编程语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Scala构建您自己的编程语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 14:14:55</div><div class="page_narrow text-break page_content"><p>Scala的一个优点是实现编程语言。即使您的目标不是实现一种全新的编程语言，这些技术仍然很有用：用于编写内存、程序分析器、查询引擎和其他类似工具。这篇博客文章将带您完成用Scala实现简单编程语言的过程，介绍一些基本概念，最后介绍一个简单编程语言的可用解释器。</p><p>关于作者：Haoyi是一名软件工程师，也是许多开源Scala工具(如Ammonite REPL和Mill构建工具)的作者。如果你喜欢这个博客上的内容，你可能也会喜欢作者的《Scala编程实战》一书。</p><p>本练习的目标是实现Jsonnet编程语言的一个子集：</p><p>本地问候语=&#34；Hello&#34；；本地人员=函数(姓名){&#34；姓名&#34；：姓名，&#34；欢迎&#34；：问候语+姓名+&#34；！&#34；}；{&#34；Pers1&#34；：Person(&#34；Alice&#34；)，&#34；Person 2&#34；：Person(&#34；Bob&#34；)，&#34；Person 3&#34；：)}。</p><p>{&#34；Person 1&#34；：{&#34；姓名&#34；：&#34；Alice&#34；，&#34；欢迎&#34；：&#34；Hello Alice！&#34；}，&#34；Person 2&#34；：{&#34；姓名&#34；：&#34；Bob&#34；，&#34；欢迎&#34；：&#34；Hello Bob！&#34；}，&#34；人物3&#34；：{&#34；姓名&#34；：&#34；查理；，&#34；欢迎&#34；：&#34；你好，查理！&#34；}}。</p><p>Jsonnet是一种用于构造JSON配置文件的简单语言：评估.jsonnet文件的输出是一个包含字典、列表、字符串、数字和布尔值的JSON结构。然后，输出的JSON可用于配置Kubernetes、CloudForformation、Terraform或其他软件系统。Google、Databricks和其他公司大量使用Jsonnet来管理其庞大而复杂的系统配置。</p><p>本教程将引导您完成实现我们的简单解释器的所有三个阶段，让您对所涉及的技术、数据结构和算法有一个直观的了解。虽然本教程不是一个全面的或可用于生产的实现，但它有望为您提供足够的基础，让您能够开始自己的简单语言相关项目。</p><p>在本练习中，我们将在Ammonite Scala REPL中完成所有工作。菊石可以通过以下方式安装：</p><p>$sudo sh-c；(ECHO&#34；#！/usr/bin/env sh&34；&amp；&amp；curl-L https://github.com/lihaoyi/Ammonite/releases/download/1.6.8/2.13-1.6.8)&&gt;；/usr/LOCAL/bin/amm&amp；&amp；chmod+x/usr/LOCAL/bin/amm&39；&amp；&amp；AmmLoading...欢迎使用Ammonite Repl 1.6.8(Scala 2.13.0 Java 11.0.2)如果您喜欢Ammonite，请通过www.patreon.com/lihaoyi@支持我们的开发。</p><p>本地问候语=&#34；Hello&#34；；本地人员=函数(姓名){&#34；姓名&#34；：姓名，&#34；欢迎&#34；：问候语+姓名+&#34；！&#34；}；{&#34；Pers1&#34；：Person(&#34；Alice&#34；)，&#34；Person 2&#34；：Person(&#34；Bob&#34；)，&#34；Person 3&#34；：)}。</p><p>Jsonnet本身类似于JSON，但引入了帮助您整理JSON配置的冗长或重复部分的构造：本地变量(如上面的问候语)、函数定义(如Person)以及基本操作(如用+连接字符串)。出于本练习的目的，我们将停止实现这三个简单的功能。进一步的特性和改进可以用同样的方式实现，我们将把彻底实现整个Jsonnet语言的任务留给像Sjsonnet这样的产品解释器。</p><p>Jsonnet有一组与JSON类似的原语。在本教程中，我们只考虑其中的一部分：</p><p>目前，我们假设字符串不包含\n或\&#34；等转义序列，并省略其他数据类型，如数字、布尔值、数组或NULL。</p><p>您可以使用LOCAL关键字、为名称分配表达式、分号；，然后使用最终表达式来定义局部变量：</p><p>与大多数编程语言一样，调用函数时使用包含要传递的参数的圆括号。</p><p>这里描述的语言功能可以以任意方式组合，例如，可以在字典值内调用函数：</p><p>本快速教程只是完整Jsonnet语言的一小部分，但对本教程来说已经足够了。</p><p>为了解析Jsonnet，我们将使用本文介绍的Fastparse库：</p><p>让我们从定义最小Jsonnet语法的语法树开始：字符串、字典、函数和局部定义。我们将使用Scala密封的特征和案例类来实现这一点：</p><p>密封的特征Exproject expr{case class Str(s：String)扩展expr case类Iden(name：String)扩展expr case类Plus(节点：SEQ[expr])扩展expr case类dict(配对：MAP[String，expr])扩展expr case类Local(name：string，assigned：expr，body：expr)扩展expr case类Func(argNames：SEQ[string]，body：expr)扩展expr case类调用(expr：expr。</p><p>(要将此代码输入到Ammonite REPL中，请用一对卷边将其括起来{...}，这样它就可以作为一个单元输入)。</p><p>这里，expr数据结构旨在表示Jsonnet语法中有意义的部分。下面是一些示例代码片段，以及我们希望它们解析到的内容。</p><p>当然，我们希望能够解析组合在一起的这些语言功能的任意组合。</p><p>首先，让我们为Str编写解析器。为简单起见，我们将忽略转义字符，这意味着字符串只是一个&#34；，后跟零个或多个非&#34；字符，最后是另一个&#34；字符：</p><p>@def str[_：P]=P(&#34；\&#34；&#34；~~/CharsWhile(_！=&#39；&#34；&#39；，0).！~~&#34；\&#34；&#34；).map(Expr.Str)定义函数str@fast parse.parse(&#34；\&#34；Hello\&#34；&#34；，str(_))res10：)，7)@fast parse.parse(&#34；\&#34；Hello world\&#34；&#34；，str(_))res11：parsed[Str]=Success(Str(&#34；Hello world&#34；)，13)@fast parse.parse(&#34；\&#34；\&#34；&#34；，str(_))res12：parsed[Str]=Success(Str(&#34；，str(_))Parsed.Failure(位置1：1，找到&#34；123&#34；)。</p><p>注意我们是如何在&#34；\&#34；&#34；后引号后面使用~~/运算符的：~~表示我们不想在这里使用空格(因为我们在一个字符串中)，而/是Fastparse Cut，这意味着如果解析失败，我们希望避免回溯。关于削减给我们带来什么的详细讨论留给了链接的文档。</p><p>@defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.map(Expr.Iden)定义函数ident@fast parse.parse(&#34；Hello&#34；，ident(_))res17：parsed[Iden]=Success(&#34；a-Za-Z0-9_&#34；，0)。，ident(_))分析失败(位置1：1，找到&#34；123&#34；)。</p><p>我们将研究的下一个语法树节点是Expr.Plus，它用于对a+b语法建模。</p><p>表示+的Expr.Plus节点以及我们语法树中的所有其他case类都稍微复杂一些：它们有一个递归定义，其中Plus是expr，但是expr可以是Plus节点。这可以通过使我们的解析器递归来解决，如下所示：</p><p>@{def expr[_：P]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]=P(str|ident)def str[_：P]=P(&#34；\&#34；&#34；~/。&#34；).map(Expr.Str)defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.Map(Expr.Iden)def plus[_：P]=P(&#34；+&#34；~prefix Expr)}@fast parse.。，expr(_))res65：parsed[expr]=Success(Plus(List(Ident(&#34；a&#34；)，Iden(&#34；b&#34；))，5)@fast parse.parse(&#34；a+b+c&#34；，expr(_))res66：parsed[expr]=Success(Plus(List(Iden(&#34；a&#34；)，Ident(&#。)，9)@fast parse.parse(&#34；a+\&#34；\&#34；+c&#34；，expr(_))res67：parsed[expr]=Success(Plus(List(Ident(&#34；a&#34；)，Str(&#34；&#34；)，Ident(&#34；c&#34；))，11)。</p><p>请注意，我们不能简单地将PLUS定义为expr~&#34；+&#34；~expr；这是因为PLUS解析器将被保留为递归，从而导致在解析时进行无限递归。相反，我们需要将plus定义为后缀&#34；+&#34；~prefix Expr，并让expr解析器通过~plus.rep执行重复plus的工作，如果不为空，则将结果聚合到Expr.Plus节点中。</p><p>Expr.Dict节点也是递归的，每个逗号分隔的键值对包含一个Expr.Str键和一个expr值。我们可以按如下方式解析它们：</p><p>@{def expr[_：P]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]=P(str|ident|dict)def str[_：P]=P(Str0).map(Expr.Str)de。&#34；&#39；&#39；，0).~~&#34；\&#34；&#34；)defident[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0)).！.MAP(Expr.Iden)def plus[_：P]=P(&#34；+&##。~/(str0~&#34；：&#34；~/expr).rep(0，&#34；，&#34；)~&#34；}&#34；).map(kvs=&gt；Expr.Dict(kvs.toMap))}@fast parse.parse(&#34；&#34；&#34；a&#34；：&#34；b&#34；，&#34；cde&34。，expr(_))res84：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；CDE&#34；-&gt；Ident(&#34；id&#34；))，21)@fast parse.parse(&#34；&#34；&#34；{&#34；a&#34；：&#34；：id}&#34；&#34；&#34；，expr(_))res85：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；cde&#34；-&gt；ident(&#34；id&#34；)，21)@fast parse.parse(&#34；&#34；&#34；，&#34；cde&#34；：id，&#34；嵌套&#34；：{}}&#34；&#34；&#34；，expr(_)res86：parsed[expr]=Success(dict(&#34；a&#34；-&gt；str(&#34；b&#34；)，&#34；cde&#34；-&gt；标识(&#34；id&34；)，DICT(地图(()，35)。</p><p>注意我们是如何从str提取str0解析器的：str0返回解析的原始字符串，而str将其包装在Expr.Str语法树节点中。由于Expr.Dict键在语法上与Expr.Strs相同，但不需要包装在Expr.Str节点中，因此我们也可以在dict解析器中重用str0解析器来解析它们。</p><p>将函数解析器、本地解析器和调用解析器添加到此代码中，我们会得到以下结果：</p><p>对象解析器{def expr[_：p]：P[expr]=P(prefix Expr~plus.rep).map{case(e，Nil)=&gt；e case(e，Items)=&gt；Expr.Plus(e+：Items)}def prefix Expr[_：P]：P[expr]=P(callExpr~call.rep).map{case(e，Items)=&gt；item.。Expr.Call(f，args)}def callExpr[_：P]=P(str|dict|local|func|ident)def str[_：P]=P(Str0).map(Expr.Str)def str0[_：P]=P(&#34；\&#34；&#34；~~/CharsWhile(_！=&#39；&#34；&#39；，0).！~。)defident[_：P]=P(Ident0).map(Expr.Iden)def ident0[_：P]=P(Charin(&#34；a-Za-Z_&#34；)~~CharsWhileIn(&#34；a-Za-Z0-9_&#34；，0))。！Def dict[_：P]=P(&#34；{&#34；~/(str0~&#34；：&#34；~/expr).rep(0，&#34；，&#34；)~&#34；}&#34；).map(KVS=&gt；Expr.Dict(kvs.toMap))def local[_：P]=P(&#34；local&#34；~/ident0~&#。~expr).map(Expr.Local.tupled)def函数[_：P]=P(&#34；函数&#34；~/&#34；(&#34；~ident0.rep(0，&#34；，&#34；)~&#34；)&#34；~expr).map(Expr.Local.tupled)def plus[_：P]=P(&#34；+&#34；~prefix Expr)。~/expr.rep(0，&#34；，&#34；)~&#34；)&#34；)}。</p><p>Func和local相对简单：每个函数都以一个关键字开头，并且可以递归地解析它们，而不会出现问题。我们还将ident0从ident中分离出来，因为func解析器使用与ident相同的语法来解析其参数列表，但不需要将标识符装箱到Expr.Iden语法树节点中。</p><p>请注意，call还需要我们将prefix Expr进一步拆分为callExpr，因为a()调用语法将是左递归的，类似于我们前面看到的a+b加号语法。</p><p>@fast parse.parse(&#34；\&#34；123\&#34；&#34；，Parser.expr(_))res63：parsed[expr]=Success(Str(&#34；123&#34；)，5)@fast parse.parse(&#34；id&#34；，Parser.expr(_))res64：parsed[expr]=Success(Iden(&#34；id&#34；)，2)。，Parser.expr(_))res65：parsed[expr]=Success(Plus(标识(&#34；a&#34；)，标识(&#34；b&34；))，5)@fast parse.parse(&#34；a+b+c&34；，Parser.expr(_))res66：parsed[expr]=Success(Plus(标识(&#34；a&#34；)，Plus(Iden(&#34；a&#34；)，Plus。)，9)@fast parse.parse(&#34；&#34；&#34；{&#34；a&#34；：&#34；A&#34；，&#34；b&#34；：&#34；bee&#34；}&#34；&#34；&#34；，Parser.expr(_))res69：parsed[expr]=Success(dict(Map(&#34；a&#34；-&gt；B&#34；-&gt；Str(&#34；bee&#34；))，22)@fast parse.parse(&#34；&#34；&#34；f()(A)+g(b，c)&#34；&#34；&#34；，Parser.expr(_))res95：parsed[expr]=Success(Plus(List(Call(Call(Ident(&#34；f&#34；))，List(。))，呼叫(身份(&#34；g#34；)，列表(身份(&#34；b#34；)，身份(&#34；c&#34；)，16)。</p><p>我们编程语言的语法是递归的：LOCAL、Function、PLUS和DICT表达式可以包含其他任意深度嵌套的表达式。我们可以通过将这样的嵌套示例提供给expr解析器来测试这一点：</p><p>@fast parse.parse(&#34；&#34；&#34；局部变量=&#34；Kay&#34；；{&#34；a&#34；：&#34；A&#34；，&#34；f&#34；：函数(A)a+a，&#34；嵌套&#34；：{&#34；k&#34；：变量}}&#34；&#34；&#34；，Parser.expr(_))res74：parsed[expr]=Success(Local(&#34；Variable&34；，Str(&#34；Variable&34；)，Str(&#34；Kay&34；)，Dict(&#34；A&#34；-&gt；Str(&#34；A&#34；)，&#34；f&#34；-&&gt;；Func(List(&#34；a&#34；)，Plus(&#34；a&#34；)，))，&#34；嵌套的&34；-&gt；dict(Map(&#34；k&#34；-&gt；标识(&#34；变量&#34；)，85)。</p><p>现在我们已经有了expr节点的语法树，下一步是解释语法树以提供值的运行时数据结构。我们将价值定义如下：</p><p>密封特征ValueObject Value{case类Str(s：String)扩展值case类dict(配对：Map[String，Value])扩展值case类Func(call：SEQ[value]=&gt；value)扩展值}。</p><p>(要将此代码输入到Ammonite REPL中，请用一对卷边将其括起来{...}，这样它就可以作为一个单元输入)。</p><p>请注意，虽然expr语法树包含表示标识符、局部变量、函数应用程序等的节点，但值只能是str、dict或Func。Value.Str来自哪里并不重要：无论是源代码中的文字Expr.Str，作为函数参数传递给Expr.Func，还是通过Expr.Local绑定到局部变量，它都是相同的Value.Str。然后，整个Jsonnet程序的最终值被转换为JSON字符串，作为程序的输出。</p><p>Value.Str和Value.Dict的内容应该是不言而喻的。Value.Func就不那么明显了：通过将其定义为Func(call：SEQ[value]=&gt；value)，我们说的是一个函数，您可以将一列参数值传递给它并返回值。稍后我们将了解如何实例化这些Value.Func节点。</p><p>这里的基本任务是编写一个将expr转换为值的函数：</p><p>然而，通过计算expr返回的值不仅取决于该expr的内容：它还取决于包含的作用域，因为Expr.Iden标识符的值取决于通过局部声明或函数参数绑定到该名称的值。</p><p>在您的程序中，这种名称到值的映射通常被称为词法作用域。因此，我们可以将EVALUE定义为：</p><p>文字字典也很简单：Expr.Dicts变成Value.Dicts，具有相同键的Dicts，只是我们需要将每个值计算成其相应的表达式：</p><p>字典文字不会在词法作用域中添加或删除任何内容，因此传递的作用域参数没有变化。通过测试，我们可以了解到：</p><p>@EVALUATE(fastparse.parse(&#34；&#34；&#34；{&#34；hello&#34；：&#34；WORLD&34；，&#34；KEY&#34；：&#34；VALUE&#34；}&#34；&#34；，Parser.expr(_)).get.value，Map.Empty)res81：Value=dict(Map(&#34；Hello&#34；-&gt；Str(&#34；WORLD&34；)，&#34；键&#34；-&gt；字符串(&#34；值&#34；))。</p><p>接下来，我们将查看Expr.Plus节点。我们只定义了它们的行为来处理字符串值(Value.Str)，因此评估它们涉及到：</p><p>定义评估(expr：expr，作用域：MAP[字符串，值])：Value=expr Match{Case Expr.Str(S)=&gt；Value.Str(S)Case Expr.Dict(Kvs)=&gt；Value.Dict(kvs.map{Case(k，v)=&gt；(k，Evaluate(v，Scope)})Case Expr.Plus(Items)=&gt；Value.Str(item.。</p><p>@fast parse.parse(&#34；&#34；&#34；&#34；本地问候=&#34；Hello&#34；；greeting+greeting&34；&#34；&#34；&#34；，Parser.expr(_))res85：parsed[expr]=Success(Local(&#34；greting&#34；，Str(&#34；Hello&#34；)，Plus(Ident(&#34；Greeting&34；)，Iden。</p><p>LOCAL的目的是对赋值的表达式求值，将该值赋给该名称，然后使用绑定到该名称的值计算主体表达式。我们可以用如下代码编写该代码：</p><p>案例Expr.Local(名称，已分配，正文)=&gt；Val assignedValue=Evaluate(已分配，范围)Evaluate(正文，范围+(名称-&gt；assignedValue))。</p><p>一旦本地将名称放入作用域，计算标识标识符节点就很简单：只需在作用域中获取该名称的值：</p><p>@EVALUATE(fast parse.parse(&#34；&#34；&#34；local greeting=&#34；Hello&#34；；greeting+greting&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)res94：value=Str(&#34；Hello&#34；)。</p><p>@EVALUATE(fast parse.parse(&#34；&#34；&#34；local x=&#34；Hello&#34；；local y=&#34；；x+y&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)res96：value=Str(&#34；Hello world&#34；)。</p><p>@EVALUATE(Fastparse.parse(&#34；&#34；&#34；&#34；本地问候=&#34；Hello&#34；；no+nope&#34；&#34；&#34；，expr(_)).get.value，Map.Empty)java.util.NoSuchElementException：Key Not Found：nope scala.collection.immutable.Map$Map1.apply(Map.scala:242)amamite.$sess.cmd93$.valuate(cmd93.sc：10)amitite.$sess.。(cmd95.sc：3)。</p><p>定义评估(expr：expr，作用域：MAP[字符串，值])：Value=expr Match{Case Expr.Str(S)=&gt；Value.Str(S)Case Expr.Dict(Kvs)=&gt；Value.Dict(kvs.map{Case(k，v)=&gt；(k，Evaluate(v，Scope)})Case Expr.Plus(Items)=&gt；Value.Str(item.。S}.mkString)案例Expr.Local(名称，已分配，正文)=&gt；Val assignedValue=Evaluate(已分配，范围)Evaluate(正文，范围+(名称-&gt;；assignedValue))案例经验标识(名称)=&&gt;；范围(名称)}。</p><p>我们最后要计算的是Expr.Func函数文字和Expr.Call函数应用程序节点：</p><p>Case类Func(params：SEQ[字符串]，Body：expr)扩展Exprcase类调用(expr：expr，args：SEQ[expr])扩展expr</p><p>在Value.Func上计算Expr.Call应该会给出计算该函数的结果。结果可以是Value.Str、Value.Dict，甚至是另一个Value.Func。</p><p>计算Expr.Call节点很简单：我们只需将expr：expr求值为Value.Func，将args：SEQ[expr]求值为一系列参数值，然后对求值的参数值调用Value.Func#调用函数即可给出结果。</p><p>案例Expr.Call(expr，args)=&gt；valValue.Func(Call)=Evaluate(expr，Scope)Val EvaluatedArgs=args.map(Evaluate(_，Scope))Call(EvaluatedArgs)。</p><p>这里的难题是：我们如何计算Expr.Func以生成一个Value.Func，它的Call属性执行我们想要的操作？</p><p>当您思考调用函数的真正含义时，它可以归结为四个步骤：</p><p>使用在cal传递的参数值在定义站点创建原始作用域的修改副本。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lihaoyi.com/post/BuildyourownProgrammingLanguagewithScala.html">https://www.lihaoyi.com/post/BuildyourownProgrammingLanguagewithScala.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scala/">#scala</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/expr/">#expr</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033755.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68eaef96ef90392715a86ab4529d5a51.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033755.html">费曼、算法编排和基于节点的编程</a></div><span class="my_story_list_date">2020-11-8 9:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033690.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0588ada816e1b2413594f6bfb6f8d351.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033690.html">Vgil：永远保持道德警惕的编程语言</a></div><span class="my_story_list_date">2020-11-7 18:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033652.html"><img src="http://img2.diglog.com/img/2020/11/thumb_e01dca862a9b81e167e32ca15a8281a2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033652.html">开发人员经验在编程语言研究中的作用是什么？</a></div><span class="my_story_list_date">2020-11-7 11:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033632.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1c73dcb4e8eef769e2d2e29f3add898a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033632.html">迷失的编程方法：Commodore 64 Basic</a></div><span class="my_story_list_date">2020-11-7 11:19</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>