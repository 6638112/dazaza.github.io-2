<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们将Github API缩放了Redis中的分片，复制的速率限制器 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我们将Github API缩放了Redis中的分片，复制的速率限制器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 00:01:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/50b167e95326ddd1d22749c631dcdc2a.png"><img src="http://img2.diglog.com/img/2021/4/50b167e95326ddd1d22749c631dcdc2a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>大约一年前，我们迁移了一个旧的速率限制器，以便为更多的流量提供服务，并适应更具弹性的平台架构。我们采用了一个带客户端分级的复制redis后端。最后，它的效果很棒，但我们沿途学到了一些教训。</p><p>   在memcached中，将该键的值递增，如果没有任何当前值，将其设置为1</p><p> 此外，如果尚未存在一个，请使用相关键（例如，“＃{key}：reset_at”）设置“在”memcached中的值“重置”值。</p><p> 递增时，如果过去的“重置”值，请忽略现有值并设置新的“复位”</p><p> 在每个请求的开头，如果密钥的值高于限制，并且将来“重置为”，然后拒绝请求</p><p> （可能对它有更多细微差别，但这是主要的想法。）</p><p>  我们的Memcached架构是由于变化。由于它大多数用作缓存层，因此我们将从单个共享MEMCACHED从单个共享的MEMCACHE切换到每个数据中心的一个MEMCACHED。虽然适用于应用程序缓存，但如果客户要求被路由到不同的数据中心，则会导致我们的速率限制器非常奇怪。 </p><p>Memcached“持久性”不适合我们。 Memcached后端由速率限制器和其他应用程序缓存共享，这意味着，当它填满时，它有时会阻止速率限制器数据，即使它仍然处于活动状态。 （结果，客户端将获得“新鲜”的速率限制窗口。有时，只有一个关键就会被驱逐 - 他们会保持相同的“使用”价值，但获得新的未来，“重置”价值观！）</p><p>   使用Redis，因为它具有更合适的持久性系统和简单的分片和复制设置</p><p> 应用程序内的碎片：该应用程序将为每个密钥选择，redis群集读取和写入</p><p> 要缓解REDIS的CPU绑定性质，请在每个群集中放置单个主要（编写）和几个副本（对于读取）</p><p> 而不是在数据库中写入“重置”，而是在不再适用的情况下使用redis到期来使值消失</p><p> 在Lua实现存储逻辑，保证操作的原子性（这是对以前的设计改进）</p><p> 我们考虑的一个选项，但决定使用我们的MySQL支持的KV商店（GitHub :: kV）进行存储。我们不想向已经忙碌的MySQL原序添加流量：通常，我们使用副本获取请求，但速率限制更新需要对主要的写访问权限。通过选择不同的存储后端，我们可以避免向MySQL提供额外的（和实质性）。 </p><p>使用Redis的另一个优点是它是一个良好的路径。我们可以从两个优秀的现有资源中获取灵感：</p><p> Stripe的技术博客文章“用速率限制仪缩放您的API”，其中包括Ruby和Redis示例实现</p><p>  要推出此更改，我们将当前的持久性逻辑分离为MemcachedBackend类，并为速率限制器构建了一个新的RedisBackend类。我们使用一个功能标志来门访问新的后端。这允许我们使用新的后端逐步增加客户的百分比。我们可以改变没有部署的百分比，这意味着，如果出现问题，我们可以快速切换回旧的实现。</p><p> 该发布顺利进行，当完成后，我们删除了功能标志和MemcachedBackend类，并直接与委托给它的Throttler类集成了RedisBackend。</p><p>   很多集成商密切关注他们的速率限制使用。在我们发布后的几周内，我们有两个非常有趣的错误报告：</p><p> 一些客户观察到他们的x-RATELIMIT-RESET标题值“摆动” - 它可能会显示一个请求的10:00:00，但另一个请求（带一个）第二区别）。</p><p> 一些客户的要求拒绝过度限制，但响应标题表示X-RATELIMIT  - 剩余时间：5000.这没有意义：如果他们在他们面前有一个全额限制窗口，为什么请求被拒绝？ </p><p>我们对使用Redis的内置时间到Live（TTL）持乐观态度，以实现我们的“重置”功能。但事实证明，我的实现导致上面描述的“摆动”。</p><p> Lua脚本返回了客户端的速率限制值的TTL，然后在Ruby中，它被添加到Time.Now.to_I获取X-RATELIMIT复位标题的时间戳。问题是，时间在TTL（redis中）和time.now.to_i（在Ruby）之间传递。根据需要多少时间，并且在时钟的第二个边界上落下的位置，所产生的时间戳可能是不同的。例如，考虑以下呼叫：</p><p>  在这种情况下，由于第二个边界发生在TTL和Time.Now之间，因此得到的时间戳比前一个更大的时间。</p><p> 我们本可以尝试提高此操作的精度（例如，Redis PTTL），但即使它被大大降低，仍然存在一些摆动。</p><p> 另一种可能性是仅使用Redis计算时间，而不是混合Ruby和Redis呼叫来创建它。 redis的时间命令可能被用作真理来源。 （旧的redis版本没有时间在Lua脚本中允许时间，但redis 5+确实如此。）我们避免了这种设计，因为它会更加难以测试：通过使用Ruby的时间作为真理的来源，我可以在我的时间里旅行使用TimeCop进行测试，断言已过期密钥，无需实际等待Redis对系统时钟返回True，未来时间的呼叫。 （我仍然不得不等待Redis来测试基于过期的数据库清理，但是由于Expires_at来自Ruby-Land，我可以注入非常短的到期窗口来简化测试。）</p><p> 相反，我们决定持续到数据库中的Ruby的“重置”时间。这样，我们可以确定它不会摆动。 （Wobbling是计算的效果 - 但从数据库中的读取将保证稳定的值。）而不是从Redis读取TTL，我们在数据库中存储了另一个值（有效地加倍我们的存储空间，但是确定）。</p><p> 我们仍然将TTL应用于速率限制键，但在“在”时间“时，它们被设置为一秒钟。这样，我们可以使用Redis的自己的语义清理“死亡”速率限制窗口。 </p><p>奇怪地，许多客户报告拒绝包含X-RATELIMIT的拒绝：5000个标题。这是怎么回事！？</p><p>  在请求的开头，检查客户的当前速率限制值。如果它超过最大允许的限制，则准备拒绝响应。</p><p> 在提供响应之前，将当前速率限制值递增，并使用响应填充X-RATELIMIT -...标题。</p><p> 嗯，事实证明，上面的步骤1击中了Redis副本，因为它是读取操作。读取操作返回了有关客户端上一个窗口的信息，并且应用程序准备了拒绝响应。</p><p> 然后，步骤2将击中redis primary。在该数据库调用期间，Redis将过期前一个窗口数据并返回新速率限制的数据。这是一个已知的redis限制：副本不会过期数据，直到他们从原初级接收到这样做，并且初选不会到期键（GitHub问题）直到它们才会过期（实际上，Primaries不时会随机采样键，适当到期，请参阅“Redis如何到期键”。）</p><p>  基本上，如上所述，相同的修复：而不是依赖于Redis的TTL来过期旧速率限制窗口，而是需要在应用程序中管理该功能。 （应用程序应准备好从副本阅读陈旧数据，然后忽略它。）</p><p> 即使在修复之后，还需要更好的设计：在速率有限的请求的情况下，我们应该避免对数据库的第二个调用。客户端的窗口可能会在两个呼叫之间过期，从而导致上述响应的类型。此修复程序需要改进编写响应的Ruby代码，以便上面步骤1的响应填充X-Ratelimit -...标题。 </p><p>-  Rate_script： - 计算客户端的请求 - 并返回客户端的当前状态 - 重命名输入的输入下调以下本地incly_key =键[1]本地increntment_amount = tonumber（argv [1]）local next_expires_at = tonumber （argv [2]）本地current_time = tonumber（argv [3]）本地expires_at_key = paters_limit_key ..＆＃34;：exp＆＃34; local affires_at = tonumber（redis.call（＆＃34; get＆＃34; expires_kate_key ））如果没有expires_at或affires_at＆lt; thount_time然后 - 这是一个全新的窗口， - 或者这个窗口已经关闭，但是redis hasn＆＃39; t清理了钥匙 - （Redis会再次清除它） - 初始化一个新的速率限制窗口redis.call（＆＃34; set＆＃34; hate_limit_key，0）redis.call（＆＃34; set＆＃34; affires_at_key，nexp_expires_at） - 告诉Redis清除_one _到期后_one _one - 时间。 - 这种方式，Ruby和Redis之间的时钟差异Won＆＃39; t导致数据消失。 - （Redis只会清理这些钥匙＆＃34;窗口已经过去）rediS.call（＆＃34; expireat＆＃34;，pater_limit_key，next_expires_at + 1）redis.call（＆＃34 ; expireat＆＃34;，affires_at_key，nexp_expires_at + 1） - 由于更新了数据库，因此返回新值expires_at = next_expires_atend--现在窗口已知已存在_or_刚刚初始化， - 增量计数器（ `Incby`返回一个数字）本地Current = redis.call（＆＃34; incrby＆＃34; ratury_limit_key，increntment_amount）return {current，appires_at}  -  check_script： - 获得键的值和到期根据需要的算法需要以原子方式ran--因此脚本.--重命名输入的输入，以便清楚地下降至本地rate_key_key = keys [1] local expires_at_key = rate_limit_key ..＆＃34;：exp＆＃34;当地current_time = tonumber（argv [1]）本地尝试= tonumber（redis.call（＆＃34; get＆＃34; pare_limit_key））local appires_at = nil  - 可能被覆盖以下原因，而不是尝试 -  thi S客户端HASN＆＃39; T初始化了一个窗口 - 让这一点才能返回{nil，nil}， - 在应用程序提供defaultselse的地方 - 我们发现了许多尝试，现在检查 - 如果这个窗口是实际上已过期expires_at = tonumber（redis.call（＆＃34; get＆＃34; get＆＃34; expires_at_key）），如果没有expires_at或affires_at <t＆lt; Current_Time那么 - 这个窗口Hasn＆＃39; redis清理过来，但它已关闭。 - （也许它是_Partly_清理，如果我们发现了？尝试但不是`Expires_at`） - 忽略数据库中的数据;返回一个新鲜的窗口，而不是tries = nil expires_at = nil endend--如果窗口是全新的（或过期）返回{tries，affires_at}，那么{nil，nil}</p><p>  我们从这种新方法学到了很多，但我们仍然存在一个缺点：当前的实现不会递增“当前”速率限制值，直到请求完成后。我们这样做是因为我们不向客户收取304的客户端，而不是修改的响应（当客户端提供电子标签时可能会发生）。更好的实现可能会在请求开始时递增值，然后如果响应为304，则会退回客户端。这将阻止客户端在仍在处理最终允许的请求时客户端可以超过其限制的边缘情况。</p><p> 在解决这篇文章中描述的问题之后，新的速率限制器已经很好。它具有改进的可靠性，固定客户的问题，并减少了我们的支持负载（最终😉），并且该架构已准备好进行我们的下一波平台改进。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-04-05-how-we-scaled-github-api-sharded-replicated-rate-limiter-redis/">https://github.blog/2021-04-05-how-we-scaled-github-api-sharded-replicated-rate-limiter-redis/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/redis/">#redis</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1056460.html"><img src="http://img2.diglog.com/img/2021/4/thumb_a1bae0d5a70292c085bae75e30a69999.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056460.html">Kallithea  - 自托管替代GitHub </a></div><span class="my_story_list_date">2021-4-6 16:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056324.html"><img src="http://img2.diglog.com/img/2021/4/thumb_fa8e1970c1559e22ccdfba516d81ef6e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056324.html">在github的新身份验证令牌格式后面 </a></div><span class="my_story_list_date">2021-4-6 3:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056196.html"><img src="http://img2.diglog.com/img/2021/4/thumb_665c798489d1e536f61f0280086b7ef3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056196.html">GitHub行动正在积极滥用挖掘GitHub服务器的加密货币 </a></div><span class="my_story_list_date">2021-4-5 9:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056122.html"><img src="http://img2.diglog.com/img/2021/4/thumb_dd04095be00b430a8b3d59c98d30414d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056122.html">患者的健康信息是否进入GitHub的北极代码库？ </a></div><span class="my_story_list_date">2021-4-4 23:10</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>