<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>化石对吉特Fossil versus Git</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fossil versus Git<br/>化石对吉特</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 18:09:44</div><div class="page_narrow text-break page_content"><p>For example, the default behavior in Git is to only synchronizea single branch, whereas with Fossil the only sync option is tosync the entire DAG. Git commands,GitHub, and GitLab tend to show only a single branch ata time, whereas Fossil usually shows all parallel branches atonce. Git has commands like &#34;rebase&#34; that help keep all relevantchanges on a single branch, whereas Fossil encourages a style ofmany concurrent branches constantly springing into existence,undergoing active development in parallel for a few days or weeks, thenmerging back into the main line and disappearing. This difference in emphasis arises from the different purposes ofthe two systems. Git focuses on individual branches, because thatis exactly what you want for a highly-distributed bazaar-style projectsuch as Linux. Linus Torvalds does not want to see every check-inby every contributor to Linux, as such extreme visibility does not scalewell. But Fossil was written for the cathedral-style SQLite projectwith just a handful of active committers. Seeing allchanges on all branches all at once helps keep the whole teamup-to-date with what everybody else is doing, resulting in a more tightly focused and cohesive implementation.  Because Git commingles the repository data with the initial checkout ofthat repository, the default mode of operation in Git is to stick to thatsingle work/repo tree, even when that&#39;s a shortsighted way of working. Fossil doesn&#39;t work that way. A Fossil repository is a SQLite databasefile which is normally stored outside the working checkout directory. You can open a Fossil repository any number of times intoany number of working directories. A common usage pattern is to have oneworking directory per active working branch, so that switching branchesis done with a  cd command rather than by checking out thebranches successively in a single working directory. Fossil does allow you to switch branches within a working checkoutdirectory, and this is also often done. It is simply that there is noinherent penalty to either choice in Fossil as there is in Git. Thestandard advice is to use a switch-in-place workflow in Fossil whenthe disturbance from switching branches is small, and to use multiplecheckouts when you have long-lived working branches that are differentenough that switching in place is disruptive. While you can  use Git in the Fossil style,Git&#39;s default tie between working directory andrepository means the standard method for working with a Git repo is tohave one working directory only. Most Git tutorials teach this style, soit is how most people learn to use Git. Because relatively few peopleuse Git with multiple working directories per repository, there are several knownproblems with that way of working, problems which don&#39;t happen in Fossil because ofthe clear  separation between a Fossil repository andeach working directory. This distinction matters because switching branches inside a single working directory loses local contexton each switch. For instance, in any software project where the runnable program must bebuilt from source files, you invalidate build objects on each switch,artificially increasing the time required to switch versions. Most obviously, thisaffects software written in statically-compiled programming languagessuch as C, Java, and Haskell, but it can even affect programs written indynamic languages like JavaScript. A typical SPA buildprocess involves several passes:  Browserify to convert Node packages so they&#39;ll run in a web browser, SASS to CSS translation,transpilation of  Typescript to JavaScript, uglification, etc.Once all that processing work is done for a given inputfile in a given working directory, why re-do that work just to switchversions? If most of the files that differ between versions don&#39;t changevery often, you can save substantial time by switching branches with cd rather than swapping versions in-place within a workingcheckout directory. For another example, you might have an active long-running test grindingaway in a working directory, then get a call from a customer requiringthat you switch to a stable branch to answer questions in terms of theversion that customer is running. You don&#39;t want to stop the test inorder to switch your lone working directory to the stable branch. Disk space is cheap. Having several working directories, each with itsown local state, makes switching versions cheap and fast. Plus, cd is faster to type than  git checkout or  fossilupdate.  Git puts a lot of emphasis on maintaininga &#34;clean&#34; check-in history. Extraneous and experimental branches byindividual developers often never make it into the main repository.Branches may be rebased before being pushed to makeit appear as if development had been linear, or &#34;squashed&#34; to make itappear that multiple commits were made as a single commit.There are  other history rewriting mechanisms in Git as well. Git strives to record whatthe development of a project should have looked like had there been nomistakes. Fossil, in contrast, puts more emphasis on recording exactly what happened,including all of the messy errors, dead-ends, experimental branches, andso forth. One might argue that thismakes the history of a Fossil project &#34;messy,&#34; but another point of viewis that this makes the history &#34;accurate.&#34; In actual practice, thesuperior reporting tools available in Fossil mean that the added &#34;mess&#34;is not a factor. Like Git, Fossil has an  amend command for modifyingprior commits, but unlike in Git, this works not by replacing data inthe repository, but by adding a correction record to the repository thataffects how later Fossil operations present the corrected data. The oldinformation is still there in the repository, it is just overridden fromthe amendment point forward. Fossil lacks almost every other history rewriting mechanism listed onthe Git documentation page linked above.  There is norebase in Fossil, on purpose, thus no way to reorder or copy commitsaround in the commit hash tree. There is no commit squashing, dropping,or interactive patch-based cherry-picking of commit elements in Fossil.There is nothing like Git&#39;s  filter-branch in Fossil. The lone exception is deleting commits. Fossil has two methods for doingthat, both of which have stringent limitations, on purpose. The first is  shunning. See thatdocument for details, but briefly, you only get mandatory compliancefor shun requests within a single repository. Shun requests do notpropagate automatically between repository clones. A Fossil repositoryadministrator can  cooperatively pull another repo&#39;s shun requestsacross a sync boundary, so that two admins can get together and agree toshun certain committed artifacts, but a person cannot force their localshun requests into another repo without having admin-level control overthe receiving repo as well. Fossil&#39;s shun feature isn&#39;t for fixing upeveryday bad commits, it&#39;s for dealing with extreme situations: publiccommits of secret material, ticket/wiki/forum spam, law enforcementtakedown demands, etc. There is also the experimental   purgecommand, which differs from shunning in ways that aren&#39;t especiallyimportant in the context of this document. At a 30000 foot level, youcan think of purging as useful only when you&#39;ve turned off Fossil&#39;sautosync feature and want to pluck artifacts out of its hash tree beforethey get pushed. In that sense, it&#39;s approximately the same as git rebase -i, drop. However, given that Fossil defaults tohaving autosync enabled  for good reason, the purge commandisn&#39;t very useful in practice: once a commit has been pushed intoanother repo, shunning is more useful if you need to delete it fromhistory. If these accommodations strike you as incoherent with respect toFossil&#39;s philosophy of durable, unchanging commits, realize that ifshunning and purging were removed from Fossil, you could still removeartifacts from the repository with SQL  DELETE statements; therepository database file is, after all, directly modifiable, beingwritable by your user. Where the Fossil philosophy really takes hold isin making it difficult to violate the integrity of the hash tree.It&#39;s somewhat tangential, but the document  &#34;Is Fossila Blockchain?&#34; touches on this and related topics. One commentator characterized Git as recording history according tothe victors, whereas Fossil records history as it actually happened.  One of the things that falls out of Git&#39;s default separation of commitfrom push is that there are several Git sub-commands that jump straightto the commit step before a change could possibly be tested. Fossil, bycontrast, makes the equivalent change to the local working check-outonly, requiring a separate check-in step to commit the change. Thisdesign difference falls naturally out of Fossil&#39;s default-enabledautosync feature and its philosophy of  not offering historyrewriting features. The prime example in Git is rebasing: the change happens to the localrepository immediately if successful, even though you haven&#39;t tested thechange yet. It&#39;s possible to argue for such a design in a tool like Gitsince it lacks an autosync feature, because you can still test thechange before pushing local changes to the parent repo, but in themeantime you&#39;ve made a durable change to your local Git repository. Youmust do something drastic like  git reset --hard to revert thatrebase or rewrite history before pushing it if the rebase causes aproblem. If you push your rebased local repo up to the parent withouttesting first, you cannot fix it without violating the golden rule of rebasing. Lesser examples are the Git  merge,  cherry-pick, and revert commands, all of which apply work from one branch ontoanother, and all of which commit their change to the local repositoryimmediately without giving youan opportunity to test the change first unless you give the --no-commit option. Otherwise, you&#39;re back in the same boat:reset the local repository or rewrite history to fix things, then mayberetry. Fossil cannot sensibly work that way because of its default-enabledautosync feature and its purposeful paucity of commands for modifyingcommits, as discussed in  the prior section. Instead of jumping straight to the commit step, Fossilapplies the proposed merge to the local working directory only,requiring a separate check-in step before the change is committed to therepository. This gives you a chance to test the change first,either manually or by running your software&#39;s automatic tests. (Ideally,both!) Thus, Fossil doesn&#39;t need rebase, squashing, reset --hard, or other Git commit mutating mechanisms. Because Fossil requires an explicit commit for a merge, it has the niceside benefit that it makes you give an explicit commit  messagefor each merge, whereas Git writes that commit message itself by defaultunless you give the optional  --edit flag to override it. We don&#39;t look at this difference as a workaround in Fossil for autosync,but instead as a test-first philosophical difference: fossil commit is a  commitment. When every commit ispushed to the parent repo by default, it encourages a working style inwhich every commit is tested first. It encourages thinking beforeacting. We believe this is an inherently good thing. Incidentally, this is a good example of Git&#39;s messy command design.These three commands:  ...are all the same command in Fossil:  If you think about it, they&#39;re all the same function: apply work done onone branch to another. All that changes between these commands is howmuch work gets applied — just one check-in or a whole branch — and themerge direction. This is the sort of thing we mean when we point outthat Fossil&#39;s command interface is simpler than Git&#39;s: there are fewerconcepts to keep track of in your mental model of Fossil&#39;s internaloperation. Fossil&#39;s implementation of the feature is also simpler to describe. Thebrief online help for   fossil merge iscurrently 41 lines long, to which you want to add the 600 lines of the branching document. The equivalentdocumentation in Git is the aggregation of the man pages for the abovethree commands, which is over 1000 lines, much of it mutually redundant.(e.g. Git&#39;s  --edit and  --no-commit options getdescribed three times, each time differently.) Fossil&#39;sdocumentation is not only more concise, it gives a nice split of briefonline help and full online documentation.  Fossil started out using 160-bit SHA-1 hashes to identify check-ins,just as in Git. That changed in early 2017 when news of the SHAttered attack broke, demonstrating that SHA-1collisions were now practical to create. Two weeks later, the creator ofFossil delivered a new release allowing a clean migration to 256-bit SHA-3 with full backwards compatibility to old SHA-1 basedrepositories. In October 2019, after the last of the major binarypackage repos offering Fossil upgraded to Fossil 2. x,we switched the default hash mode so that fromFossil 2.10 forward, the conversion to SHA-3 is fully automatic.This notonly solves the SHAttered problem, it should prevent a reoccurrence ofsimilar problems for the foreseeable future. Meanwhile, the Git community took until August 2018 to publish their first planfor solving the same problem by moving to SHA-256, a variant of the older SHA-2 algorithm. As ofthis writing in February 2020, that plan hasn&#39;t been implemented, as faras this author is aware, but there is now a competing SHA-256 based plan which requires complete repositoryconversion from SHA-1 to SHA-256, breaking all public hashes in therepo. One way to characterize such a massive upheaval in Git terms is awhole-project rebase, which violates Git&#39;s ownGolden Rule of Rebasing. Regardless of the eventual implementation details, we fully expect Gitto move off SHA-1 eventually and for the changes to take years more topercolate through the community. Almost three years after Fossil solved this problem, the SHAmbles attack was published, furtherweakening the case for continuing to use SHA-1. The practical impact of attacks like SHAttered and SHAmbles on theGit and Fossil Merkle trees isn&#39;t clear, but you want to have your repositoriesmoved over to a stronger hash algorithm before someone figures out howto make use of the weaknesses in the old one. Fossil has had this coveredfor years now, so that the solution is now almost universally deployed.</p><p>例如，Git中的默认行为是只同步一个分支，而Fossil中唯一的同步选项是同步整个DAG。Git命令、GitHub和GitLab往往在ata时间只显示一个分支，而Fossil通常同时显示所有并行分支。Git有如下命令&#34；再基地&#34；这有助于将所有相关的变化保持在一个分支上，而化石鼓励了许多并发分支不断涌现出来的风格，在几天或几周的时间里并行进行积极的发展，然后重新融入主线并消失。这种侧重点的差异源于两个系统的不同目的。Git专注于单个分支，因为对于高度分布式的集市式项目（如Linux），这正是您想要的。Linus Torvalds不希望看到Linux的每个贡献者的每一次检查，因为这样的极端可见性不适合scalewell。但化石是为大教堂风格的SQLite项目编写的，只有少数活跃的提交者。一次看到所有分支上的所有变化，有助于使整个团队与其他人的工作保持同步，从而实现更集中、更连贯的实施。因为Git将存储库数据与该存储库的初始签出混合在一起，所以Git中的默认操作模式是坚持使用单一的工作/回购树，即使是&#39；这是一种短视的工作方式。化石没有&#39；我不能那样做。化石存储库是一个SQLite数据库文件，通常存储在工作签出目录之外。你可以在任意数量的工作目录中多次打开化石存储库。一种常见的使用模式是，每个活动工作分支都有一个工作目录，因此切换分支是通过cd命令完成的，而不是通过在单个工作目录中依次检出分支。Fossil确实允许您在工作签出目录中切换分支，这也是经常做的。简单地说，化石中的任何一种选择都不会像Git中的选择那样受到严重的惩罚。标准建议是，当切换分支的干扰很小时，在Fossil中使用就地切换工作流，当存在不同的长期工作分支时，使用多个就地切换工作流，尽管就地切换会造成中断。虽然你可以使用化石风格的Git，但Git&#39；工作目录和pository之间的默认连接意味着使用Git回购的标准方法是只使用一个工作目录。大多数Git教程都教授这种风格，所以大多数人都是这样学习使用Git的。由于使用Git的人相对较少，每个存储库都有多个工作目录，因此这种工作方式存在一些已知的问题，这些问题不会&#39；化石中不会发生这种情况，因为化石存储库和每个工作目录之间存在明显的分离。这种区别很重要，因为在单个工作目录中切换分支会丢失每个交换机上的本地上下文。例如，在任何必须从源文件生成可运行程序的软件项目中，都会使每个开关上的生成对象无效，人为地增加切换版本所需的时间。最明显的是，这会影响用C、Java和Haskell等静态编译编程语言编写的软件，但它甚至会影响用JavaScript等动态语言编写的程序。一个典型的SPA构建过程涉及几个过程：Browserify转换节点包，使其&#39；我会在网络浏览器中运行，从SASS到CSS的翻译，从Typescript到JavaScript的转换，uglification等等。一旦所有的处理工作都完成了，在一个给定的工作目录中，一个给定的输入文件，为什么要重新工作，只切换版本？如果不同版本之间的大多数文件没有&#39；通常，通过使用cd切换分支，而不是在workingcheckout目录中就地交换版本，可以节省大量时间。例如，您可能有一个长期运行的活动测试正在工作目录中运行，然后接到一个客户的电话，要求您切换到一个稳定的分支，以回答有关客户正在运行的版本的问题。你没有&#39；I don’我不想为了把你的工作目录切换到稳定的分支而停止测试。磁盘空间很便宜。拥有多个工作目录，每个目录都有自己的本地状态，这使得切换版本既便宜又快捷。此外，cd比git checkout或fossilupdate打字更快。Git非常重视维护a&#34；清洁&#34；登记历史。独立开发人员的无关分支和实验分支通常不会进入主存储库。分支在被推动之前可能会被重新设定，使其看起来像是线性发展，或&#34；压扁&#34；让我觉得多个提交都是作为一个提交进行的。Git中还有其他历史重写机制。Git努力记录一个项目的开发应该是什么样子的，如果没有任何风险的话。相比之下，化石更强调准确记录所发生的事情，包括所有混乱的错误、死胡同、实验分支等等。有人可能会说，这创造了一个化石项目的历史#34；凌乱&#34；但另一种观点是，这创造了历史#34；准确&#34; 在实际操作中，化石中可用的高级报告工具意味着增加了&#34；混乱&#34；这不是一个因素。与Git一样，Fossil也有一个用于修改先前提交的修正命令，但与Git不同的是，这不是通过替换存储库中的数据来实现的，而是通过向存储库添加一条修正记录来实现的，该记录会影响以后的Fossil操作如何呈现修正后的数据。旧信息仍在存储库中，只是从修改点开始被覆盖。Fossil几乎没有上面链接的Git文档页面上列出的所有其他历史重写机制。化石中有norebase，因此无法在提交哈希树中重新排序或复制CommitsRound。化石中没有提交元素的提交挤压、删除或基于交互补丁的樱桃采摘。没有什么能比得上Git&#39；化石中的滤器分支。唯一的例外是删除提交。化石有两种方法可以做到这一点，这两种方法都有严格的限制。首先是回避。有关详细信息，请参阅该文档，但简单地说，对于单个存储库中的请求，您只能获得强制遵从性。请求不会在存储库克隆之间自动传播。化石存储管理员可以合作进行另一次存储&#39；s sun requests跨越同步边界，这样两个管理员就可以聚在一起并同意运行某些已提交的工件，但是如果没有对接收的repo进行管理员级别的控制，一个人不能将其localsun请求强制进入另一个repo。化石&#39；s-sun特征不是&#39；t用于纠正每天的不良行为，它&#39；处理极端情况的方法：公开提交机密材料、罚单/维基/论坛垃圾信息、执法部门采取行动的要求等。此外还有实验性的purgecommand，它与回避的方式不同，后者不是&#39；在本文件中尤其重要。在30000英尺的高度，只有当你&#39；我关掉了化石&#39；sautosync功能，并希望在推送工件之前将其从哈希树中取出。从这个意义上说，它&#39；这和git rebase差不多——我，放下。然而，考虑到Fossil默认启用自动同步是有充分理由的，清除命令是&#39；这在实践中不是很有用：一旦一个提交被推到另一个回购协议中，如果你需要从历史中删除它，那么回避就更有用了。如果你觉得这些适应措施与化石&#39不一致；s关于持久不变的提交的理念，认识到如果从Fossil中删除了回避和清除，您仍然可以使用SQL DELETE语句从存储库中删除artifacts；毕竟，存储数据库文件是可直接修改的，用户可以编写。化石哲学真正占据主导地位的地方在于，很难破坏哈希树的完整性。它&#39；这有点牵强，但文件&#34；Fossila是区块链吗&#34; 涉及这个和相关的话题。一位评论员将Git描述为根据胜利者记录历史，而化石记录的是实际发生的历史。Git中的一件事&#39；commitfrom push的默认分离是，在可能测试更改之前，有几个Git子命令直接跳到提交步骤。相比之下，Fossil只对本地工作签出进行了等效的更改，需要单独的签入步骤来提交更改。这种设计上的差异自然来自化石#39；它的默认启用DautoSync功能及其不提供历史重写功能的理念。Git中的一个主要例子是重定基址：如果成功，localrepository会立即发生更改，即使您没有&#39；我还没测试过这种变化。它&#39；在Git这样的工具中，这样的设计是有可能的，因为它没有自动同步功能，因为在将本地更改推送到父回购之前，您仍然可以测试更改，但同时您&#39；我对本地Git存储库进行了持久的更改。你必须做一些激烈的事情，比如git reset——如果重新基址导致问题，在推之前很难恢复该基址或重写历史。如果你在没有先测试的情况下将你的重定基本地回购推高给母公司，你就无法在不违反重定基金规则的情况下修复它。较小的例子是Git merge、cherry pick和revert命令，所有这些命令都将工作从一个分支应用到另一个分支，并且所有这些命令都会立即将其更改提交到本地存储库，而不给您先测试更改的机会，除非您给出--no commit选项。否则，你&#39；我们回到了同一条船上：重置本地存储库或重写历史以修复问题，然后再尝试。Fossil无法明智地以这种方式工作，因为它默认的enabledautosync功能及其故意缺少命令</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/化石/">#化石</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fossil/">#fossil</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>