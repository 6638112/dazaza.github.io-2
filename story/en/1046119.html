<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>x86处理器中的TLB和Pagewalk一致性（2015） TLB and Pagewalk Coherence in x86 Processors (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TLB and Pagewalk Coherence in x86 Processors (2015)<br/>x86处理器中的TLB和Pagewalk一致性（2015） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-24 13:28:06</div><div class="page_narrow text-break page_content"><p>Since the 386, x86 processors have supported paging, which uses a page table to map virtual address pages to physical address pages. This mapping is controlled by the operating system, which gives user applications a contiguous virtual memory space, and isolates the memory spaces of different processes.</p><p>从386开始，x86处理器支持分页，该分页使用页表将虚拟地址页映射到物理地址页。该映射由操作系统控制，该操作系统为用户应用程序提供了连续的虚拟内存空间，并隔离了不同进程的内存空间。</p><p> Page tables are located in main memory, so a cache (TLB: Translation Lookaside Buffer) is needed for acceptable performance. When doing virtual to physical address translations, the TLB maps virtual pages to physical pages, and is typically looked up in parallel with the L1 cache. For x86, the processor “walks” the page tables in memory if there is a TLB miss. Some other architectures throw an exception and ask the OS to load the required entry into the TLB.</p><p> 页表位于主内存中，因此需要一个缓存（TLB：转换后备缓冲区）以达到可接受的性能。当执行虚拟到物理地址的转换时，TLB将虚拟页面映射到物理页面，并且通常与L1缓存并行查找。对于x86，如果出现TLB丢失，则处理器将“遍历”内存中的页表。其他一些体系结构则引发异常，并要求操作系统将所需的条目加载到TLB中。</p><p> The x86 architecture specifies that the TLB is  not coherent or ordered with memory accesses (i.e., page tables), and requires that the relevant TLB entry (or the entire TLB) be flushed after any changes to the page tables. Failing to invalidate would cause the processor to use the stale entry in the TLB if the entry is in the TLB, or a page table walk could non-deterministically see either the old or new page table entry. With out-of-order processors, relaxing coherence requirements allows the processor to more easily reorder operations for more performance.</p><p> x86体系结构指定TLB与内存访问（即页面表）不相关或不按顺序排列，并且要求在对页面表进行任何更改后刷新相关的TLB条目（或整个TLB）。如果该条目位于TLB中，则无法使之无效将导致处理器使用TLB中的陈旧条目，或者页面表遍历可能不确定地看到旧页面表条目或新页面表条目。对于乱序的处理器，宽松的一致性要求使处理器可以更轻松地对操作进行重新排序以提高性能。</p><p> But do real processor implementations really behave this way, or do some processors provide more coherence guarantees in practice? One particular interesting case concerns what happens when a page table entry that is known not to be cached in the TLB is changed, then immediately used for a translation (via a pagewalk) without any invalidations. Are real processors’ pagewalks more coherent than required by the specification (and does any software rely on this)? And if pagewalks are coherent with memory, what mechanism is used?</p><p> 但是，真正的处理器实现是否真的以此方式运行，还是某些处理器在实践中提供了更多的一致性保证？一个特别有趣的情况是，当更改一个已知不会在TLB中缓存的页表条目，然后立即将其用于翻译（通过分页浏览）而没有任何无效时，会发生什么情况。真实处理器的页面走动是否比规范要求的连贯性更好（并且任何软件都依赖此规范）？如果分页浏览与内存保持一致，则使用什么机制？</p><p> In the rest of this post, I’ll attempt answer some of the above questions, and measure the pagewalking behaviour of a bunch of x86 processors.</p><p> 在本文的其余部分中，我将尝试回答上述一些问题，并评估一堆x86处理器的分页浏览行为。</p><p>    The basic task of paging is to map virtual addresses to physical addresses. This occurs at the granularity of a “page” (default 4 KB on x86). This means that for a 32-bit address, the upper 20 bits are translated (“virtual page number” mapped to “physical page number”), while the lower 12 are unchanged (“page offset”). Figure 1 shows an example where the virtual address 0x12345678 is mapped to 0x00abc678, doing two memory accesses. PAE and 64-bit extensions allow larger address spaces by increasing the number of levels of page tables, to 3 and 4, respectively.</p><p>    分页的基本任务是将虚拟地址映射到物理地址。这以“页面”的粒度发生（x86上默认为4 KB）。这意味着对于32位地址，高20位将被转换（“虚拟页号”映射为“物理页号”），而低12位将保持不变（“页偏移”）。图1显示了一个示例，其中虚拟地址0x12345678映射到0x00abc678，进行了两次内存访问。通过将页表的级别数分别增加到3和4，PAE和64位扩展名允许更大的地址空间。</p><p>  Of course, if every memory access became three accesses, the performance penalty would not be acceptable. A TLB (Figure 2) is a cache of translations that stores the result of previous pagewalks, which directly maps virtual page numbers to physical page numbers without reading the page tables on a TLB hit.</p><p>  当然，如果每个内存访问变为三个访问，则性能损失将是不可接受的。 TLB（图2）是翻译的高速缓存，用于存储以前的页面遍历的结果，该结果将虚拟页码直接映射到物理页码，而无需读取TLB命中的页表。 </p><p>    Whenever there are caches, there is the problem of cache coherence. If a page table entry is changed, would the corresponding entry in the TLB be automatically updated or invalidated, or would software need to explicitly invalidate or flush the TLB? In x86 (and all other architectures I can think of), the TLB is not coherent. The behaviour of non-coherent TLBs is fairly intuitive: if there is a stale entry cached in the TLB, a translation would use the stale entry in the TLB. But if there is no stale entry cached in the TLB, a translation requires a page table walk. Is this page table walk coherent with memory accesses? Here is what Intel’s and AMD’s manuals say about it:</p><p>只要有缓存，就存在缓存一致性的问题。如果页面表条目被更改，TLB中的相应条目是否会自动更新或无效，或者软件是否需要显式使TLB无效或刷新？在x86（以及我能想到的所有其他体系结构）中，TLB是不一致的。非相干TLB的行为非常直观：如果TLB中缓存了一个陈旧的条目，则转换将使用TLB中的陈旧的条目。但是，如果在TLB中没有缓存过时的条目，则转换需要页表遍历。该页表的走行是否与内存访问一致？这是Intel和AMD的手册中所说的：</p><p>  The processor may cache translations required for prefetches and for accesses that are a result of speculative execution that would never actually occur in the executed code path.</p><p>  处理器可以缓存预取和访问所需要的转换，这些转换是推测执行的结果，而实际上不会在执行的代码路径中发生。</p><p>  …it is possible for the processor to prefetch the data from physical-page M before the page table for virtual-page A is updated in Step 2 [to page N] … Similar behavior can occur when instructions are prefetched from beyond the page table update instruction. To prevent this problem, software must use an INVLPG or MOV CR3 instruction immediately after the page-table update…</p><p>  …处理器有可能在步骤2中将虚拟页A的页表更新到[N页]之前从物理页M中预取数据…当从页表更新之外预取指令时，可能会发生类似的行为指令。为避免此问题，软件必须在页表更新后立即使用INVLPG或MOV CR3指令…</p><p> Both Intel and AMD manuals state that without invalidation, even if the old entry is not cached in the TLB, the pagewalk may still see the old entry. That is, in the following pseudocode, the second instruction (load) can non-deterministically use either the old mapping or new mapping, and that there must be an invalidation or TLB flush in between to guarantee the new page table entry is visible by the second instruction.   mov [page table], new_mapping mov eax, [linear address using updated mapping]</p><p> 英特尔和AMD手册均声明，即使旧条目未缓存在TLB中，也不会无效，但pagewalk仍然可以看到旧条目。也就是说，在下面的伪代码中，第二条指令（装入）可以不确定地使用旧映射或新映射，并且它们之间必须存在无效或TLB刷新，以确保新页表项对用户可见。第二条指令。 mov [页表]，new_mapping mov eax，[使用更新的映射的线性地址]</p><p> Interestingly, non-coherent pagewalk behaviour is mentioned in the Pentium 4  specification update as an erratum ( N94, NoFix) even though the supposedly-erroneous behaviour is still “correct”.</p><p> 有趣的是，Pentium 4规范更新中提到了非连贯的分页浏览行为是一种错误（N94，NoFix），即使所谓的错误行为仍然是“正确的”。</p><p> In this post, I use “TLB coherence” to refer to coherence between page tables in memory and the TLB contents (affecting TLB hits), and “pagewalk coherence” for the coherence between pagewalks and page table modifications (affecting TLB misses).</p><p> 在本文中，我使用“ TLB一致性”来指代内存中的页表与TLB内容（影响TLB命中）之间的一致性，而“ pagewalk一致性”指的是页游与页面表修改之间的一致性（影响TLB未命中）。</p><p>  Even though the instruction set specification does not guarantee pagewalk coherence, there is OS code that relies on it for correctness. There is kernel code in Windows 95 through Me  that modifies page table mappings without invalidation, and this causes random crashes if pagewalks are not coherent.</p><p>  即使指令集规范不能保证Pagewalk的一致性，也有OS代码依靠它来保证正确性。通过Me的Windows 95中有内核代码，可修改页面表映射而不会使其失效，并且如果页面漫游不连贯，则会导致随机崩溃。 </p><p> This leads me to think that perhaps real processors do provide pagewalk coherence (or that Windows 95 through Me were crash-prone, hmm…)</p><p>这使我认为也许真正的处理器确实提供了页面漫游的一致性（或者Windows 95通过Me容易崩溃，嗯……）</p><p>   The first design decision is whether TLB contents are coherent with memory accesses (page table modifications). This is not required, and real processors do not provide it.</p><p>   第一个设计决策是TLB内容是否与内存访问（页表修改）保持一致。这不是必需的，真正的处理器也不提供它。</p><p> The second design decision is whether page table walks are coherent with memory accesses. The instruction set specifications do not require it, but many processors choose to provide coherence anyway.</p><p> 第二个设计决策是页表遍历是否与内存访问一致。指令集规范不需要它，但是无论如何，许多处理器选择提供一致性。</p><p> For processors that do provide coherence, there are two classes of mechanisms to provide it: All pagewalks could be performed non-speculatively, after all earlier memory instructions are completed. Or, for more performance, pagewalks could be performed speculatively, with a mechanism to detect and retry the pagewalk if the processor later detects that the pagewalk conflicted with an earlier store to memory.</p><p> 对于确实提供一致性的处理器，有两种机制可以提供一致性：在所有较早的内存指令完成后，所有分页操作都可以非推测性地执行。或者，为了获得更高的性能，可以使用一种机制来推测性地执行分页查询，如果处理器稍后检测到该分页查询与较早的存储冲突时，该机制可以检测并重试该分页查询。</p><p> The design space of pagewalk behaviours can be classified into three categories: Non-coherent pagewalks, coherent pagewalks done non-speculatively, and coherent pagewalks done speculatively with detect-and-retry.</p><p> 分页走行行为的设计空间可分为三类：非相干分页走行，以非推测方式进行的连贯分页走行和以“检测并重试”以推测方式进行的相干分页走行。</p><p>   Intel Pentium Pro (6, 1, 9) Intel Pentium 4 Northwood (15, 2, 9) Intel Sandy Bridge (6, 42, 7) Intel Ivy Bridge (6, 58, 9) Intel Haswell (6, 60, 3) AMD K7 Thunderbird (6, 4, 2) AMD K7 Thoroughbred (6, 8, 1) AMD Phenom (16, 2, 3) AMD Phenom II (16, 10, 0)</p><p>   Intel Pentium Pro（6、1、9）Intel Pentium 4 Northwood（15、2、9）Intel Sandy Bridge（6、42、7）Intel Ivy Bridge（6、58、9）Intel Haswell（6、60、3） AMD K7雷鸟（6、4、2）AMD K7纯种马（6、8、1）AMD Phenom（16、2、3）AMD Phenom II（16、10、0）</p><p>  Intel Atom Silvermont (6, 55, 3) Via C3 “Samuel 2” (CentaurHauls 6, 7, 3)</p><p>  Intel Atom Silvermont（6、55、3）通过C3“ Samuel 2”（CentaurHauls 6、7、3） </p><p> AMD Bulldozer (21, 1, 2) AMD Piledriver (21, 2, 0) AMD Zen 2 (23, 113, 0) Ryzen 5 3600X</p><p>AMD推土机（21、1、2）AMD打桩机（21、2、0）AMD Zen 2（23、113、0）Ryzen 5 3600X</p><p>  VirtualBox with shadow page tables behaves as a coherent TLB (not merely coherent pagewalks). Updates to page tables are always immediately visible without TLB invalidation. But the cost of providing this coherence is around 60,000 clock cycles per page table update, compared to one or a few for a simple store instruction.</p><p>  具有影子页表的VirtualBox的行为就像一个连贯的TLB（而不仅仅是连贯的分页浏览）。在没有TLB无效的情况下，页面表的更新总是立即可见。但是，与每个简单的存储指令中的一个或几个相比，提供这种一致性的代价是每次页表更新大约需要60,000个时钟周期。</p><p> Virtual machines have two levels of translation: Guest virtual to guest physical (which is also the host virtual address), then the usual host virtual to host physical translation, with two sets of page tables, one managed by the guest OS, one managed by the host OS. Virtual machines without nested paging usually implement  shadow page tables, where the CPU uses “shadow” page tables that directly map guest virtual addresses to host physical addresses. The VM monitors changes in the guest OS’s page tables and updates the shadow page tables in response. Often the guest page tables are marked as read-only so all writes immediately trap into the VM to be handled.</p><p> 虚拟机具有两种转换级别：客户机虚拟到客户机物理（这也是主机虚拟地址），然后是通常的虚拟到主机物理翻译，具有两组页面表，一组由客户机OS管理，一组由客户机OS管理。主机操作系统。没有嵌套分页的虚拟机通常实现影子页面表，其中CPU使用“影子”页面表将客户虚拟地址直接映射到主机物理地址。 VM监视来宾OS的页面表中的更改，并作为响应更新影子页面表。通常，来宾页表被标记为只读，因此所有写操作都会立即捕获到要处理的VM中。</p><p>   Testing for TLB and pagewalk coherence requires changing page table mappings and observing their behaviour and timing. The test needed kernel-mode code needed to gain access to the page tables. It also needed to create a mechanism for modifying the page tables quickly from user mode.</p><p>   测试TLB和pagewalk的一致性需要更改页表映射并观察其行为和时间。该测试需要访问页表所需的内核模式代码。还需要创建一种机制，以从用户模式快速修改页表。</p><p> There were two variations of the test, one to test for TLB and pagewalk coherence (functionality), and another timing-based test to test whether pagewalks can occur speculatively and whether there is a penalty for misspeculations. These tests were then run on multiple systems.</p><p> 该测试有两种变体，一种用于测试TLB和页面漫游的一致性（功能），另一种基于时间的测试用于测试是否可以以推测的方式进行页面漫游，以及是否因误导而受到惩罚。这些测试然后在多个系统上运行。</p><p>  Page tables are located in physical address space, is controlled by the OS, and normally inaccessible from user mode. Gaining access to the page tables requires that we know where the page tables are located in (physical) memory, and a method to read and write to physical memory.</p><p>  页表位于物理地址空间中，由操作系统控制，通常无法从用户模式访问。要访问页表，需要了解页表在（物理）内存中的位置，以及一种读写物理内存的方法。</p><p> The page tables used by the current process is stored in control register CR3. Directly reading from CR3 (using a MOV instruction) is privileged, so can’t be done in user mode. Linux does not appear to provide an alternative mechanism to read a process’s CR3, so I wrote a short kernel module that simply reports the current CR3 value (presumably valid for the current process).</p><p> 当前进程使用的页表存储在控制寄存器CR3中。具有从CR3直接读取（使用MOV指令）的特权，因此不能在用户模式下进行。 Linux似乎没有提供替代方法来读取进程的CR3，因此我编写了一个简短的内核模块，该模块仅报告当前CR3值（大概对当前进程有效）。 </p><p> Accessing physical memory is easier, as Linux already provides a /dev/mem character device that can read and write to physical memory (as long as the kernel was not compiled with STRICT_DEVMEM). Knowing the location of the page tables and having a mechanism to read/write arbitrary physical memory allows me to write pagewalking routines that can traverse and modify the page tables. There are different routines depending on the type of paging in use (two-level 32-bit x86, three-level 32-bit PAE, and four-level 48-bit x86-64).</p><p>访问物理内存更容易，因为Linux已经提供了一个/ dev / mem字符设备，该设备可以读写物理内存（只要内核未使用STRICT_DEVMEM进行编译）。知道页表的位置并具有读取/写入任意物理内存的机制，这使我能够编写可以遍历和修改页表的分页程序。根据使用的分页类型，有不同的例程（两级32位x86，三级32位PAE和四级48位x86-64）。</p><p> However, since /dev/mem is accessed with file read/write operations and requires a switch into kernel mode, it is much too slow. A microbenchmark needs a method to update a page table entry quickly with just one instruction.</p><p> 但是，因为/ dev / mem是通过文件读/写操作访问的，并且需要切换到内核模式，所以它太慢了。微基准测试需要一种仅用一条指令即可快速更新页表条目的方法。</p><p>  Fast page table updates is done by using /dev/mem to set up the page tables so that a region of the virtual memory space maps to the page tables for a different array. Something similar is often used by OSes as well. This allows user-mode code (with paging enabled) to directly update page tables with a single instruction, without switching to kernel mode, and without disabling paging. Figure 3 shows the page table setup. The page tables that control the mappings for the  pt_window array are changed (using slow /dev/mem) so that accesses to  pt_array actually access the page tables for  bigbuf, allowing fast modification of  bigbuf‘s page table mappings.</p><p>  通过使用/ dev / mem设置页表来完成快速页表更新，以便虚拟内存空间的区域映射到其他数组的页表。操作系统也经常使用类似的东西。这允许用户模式代码（启用分页）直接用一条指令更新页表，而无需切换到内核模式，也无需禁用分页。图3显示了页表设置。更改了控制pt_window数组映射的页表（使用慢速的/ dev / mem），以便对pt_array的访问实际上访问了bigbuf的页表，从而可以快速修改bigbuf的页表映射。</p><p> Linux checks the consistency of a process’s page tables when the process exits, so the microbenchmark backs up any of the page tables entries it modifies and restores them before exiting.</p><p> 在进程退出时，Linux会检查该进程的页表的一致性，因此，微基准测试会备份它修改的任何页表项，并在退出前将其恢复。</p><p>      TLB and pagewalk coherence concerns the processor’s behaviour when a page table mapping is modified and then used without an intervening invalidation. We can measure this by changing the mappings to point to one of two pages with known contents, so the result of a load indicates which page mapping was actually used. Pointing all of the mappings to just two pages has the additional advantage of using only 8 KB of (VIPT or PIPT) L1 cache footprint, allowing better timing measurements with less interference from data cache misses.</p><p>      TLB和pagewalk一致性关系到修改页表映射然后在没有中间无效的情况下使用时处理器的行为。我们可以通过将映射更改为指向具有已知内容的两个页面之一来进行测量，因此加载的结果指示实际使用了哪个页面映射。将所有映射指向仅两页还有一个额外的优势，即仅使用8 KB的（VIPT或PIPT）L1缓存占用空间，可以实现更好的时序测量，同时减少来自数据缓存未命中的干扰。</p><p> The test accesses pages in a random cyclic ordering, to defeat prefetching and generate TLB misses with high probability. All pages point to a page containing the number 1 (“page 1”) by default. For each page, the mapping is changed to point to a different page containing the number 2 (“page 2”), then immediately used by a load. This is immediately changed back to point to page 1, and another load performed, so the page tables point to page 2 only very briefly.</p><p> 该测试以随机循环顺序访问页面，以击败预取并极有可能生成TLB未命中。默认情况下，所有页面都指向包含数字1的页面（“页面1”）。对于每个页面，映射都会更改为指向包含数字2的不同页面（“页面2”），然后立即由负载使用。立即将其更改回指向第1页，并执行了另一个加载，因此页表仅非常简短地指向第2页。</p><p> *p_thispte = map_pte2; // Change mappingn = *(unsigned int*)p_array; // First access: n is always 1 or 2.lcounts[n+1]++; // Count occurrences of n*p_thispte = map_pte1; // Change mapping backn = *(unsigned int*)p_array; // Second accesslcounts[n-1]++;</p><p> * p_thispte = map_pte2; //更改映射n = *（unsigned int *）p_array; //首次访问：n始终为1或2。lcounts [n + 1] ++; //计算n的出现* p_thispte = map_pte1; //将映射改回n = *（unsigned int *）p_array; //二次访问lcounts [n-1] ++; </p><p> In a fully-coherent system, the first load will read a 2 from the newly-changed mapping, and the second load will read a 1 right after the mapping is reverted. If the TLB is not coherent, the second load will still see 2 because the first load has already placed the mapping in the TLB which the second load reuses. If the pagewalks are not coherent, the first load can (but doesn’t necessarily) see 1, because the pagewalk speculatively occurred before the page table update.</p><p>在完全一致的系统中，第一个负载将从新更改的映射中读取2，第二个负载将在还原映射后立即读取1。 如果TLB不相干，则第二个负载仍将看到2，因为第一个负载已将映射放入第二个负载重用的TLB中。 如果分页浏览不连贯，则第一次加载可以（但不一定）为1，因为分页浏览是推测性地发生在页表更新之前的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.stuffedcow.net/2015/08/pagewalk-coherence/">https://blog.stuffedcow.net/2015/08/pagewalk-coherence/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/pagewalk/">#pagewalk</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/页表/">#页表</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>