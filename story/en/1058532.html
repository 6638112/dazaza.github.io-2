<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在C ++中键入擦除解释 Type Erasure in C++ Explained</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Type Erasure in C++ Explained<br/>在C ++中键入擦除解释 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-16 00:52:01</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/6c3a1708133a5968307fe81835b9d8a7.jpg"><img src="http://img2.diglog.com/img/2021/4/6c3a1708133a5968307fe81835b9d8a7.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You have heard about Type Erasure of C++. You probably know  std::function is a classic usage of the pattern. But what is Type Erasure in C++? It&#39;s effectively trying to achieve Duck Typing, which is common in languages like Python.</p><p>您已经听说过C ++的类型擦除。您可能知道std ::函数是模式的经典用法。但是C ++中的类型擦除是什么？它有效地尝试实现鸭键入，这是Python这样的语言常见的。</p><p> # Notice that there&#39;s no relationship between Bar1 or Bar2class Bar1: def doSomething(): print(&#34;bar1&#34;) class Bar2: def doSomething(): print(&#34;bar2&#34;)def foo(bar): # works on _any_ bar that has `doSomething()` defined bar.doSomething()foo(Bar1())foo(Bar2())</p><p> ＃请注意，Bar1或Bar2class Bar1：def dosomething（）：print（＆＃34; bar1＆＃34;）class bar2：def dosomething（）：print（＆＃34; bar2＆＃34; ）def foo（bar）：#wore in _any_栏上有`dosomething（）`定义的bar.dosomething（）foo（bar1（））foo（bar2（））</p><p>   If we are not forgoing type safety, we need an interface definition. Something that describes the expectation on the argument. e.g. it has a  doSomething method defined. Easy.</p><p>   如果我们不上文类型安全，我们需要一个接口定义。描述了对论证的期望的东西。例如它具有定义了一种包含的剂量方法。简单的。</p><p> class AbstractBar { virtual void doSomething() = 0; virtual ~AbstractBar() = default; // always have a virtual destructor};void foo(AbstractBar&amp; bar);</p><p> 类摘录栏{虚拟void dosomething（）= 0; Virtual〜AbstractBar（）=默认值; //始终具有虚拟析构函数}; void foo（摘录栏和amp; bar）;</p><p> Now  foo takes any bars that inherit from  AbstractBar class. This means we need make  Bar1 and  Bar2 inherit from  Abstractbar, which can very quickly spin out of hand (one parent class for each interface). Not to mention that Bar1 and Bar2 might be defined in third party libraries that we can&#39;t change.</p><p> 现在，Foo采用从摘录栏课程继承的任何条形图。这意味着我们需要制作Bar1和Bar2从抽象栏继承，它可以非常快速地从手中旋转（每个接口的一个父类）。更不用说Bar1和Bar2可以在我们可以＆＃39; t改变的第三方库中定义。</p><p>    The downside of this is that now as a library you expose your implementation to all users (because of template) and if there are a lot of callsites, and it slows down the compilation time (sometimes dramatically). There&#39;s also no types erased here. Not the Duck Typing we wanted. We want the type T to be actually captured/erased. E.g. we want to have a  vector of  things that we can call  doSomething upon, and they can have different behaviors (different underlying types).</p><p>    这一点的缺点是，现在作为一个库，您将您的实现公开给所有用户（由于模板），如果有很多呼叫，则它会减慢编译时间（有时剧烈地）。这里没有删除的类型＆＃39。不是我们想要的鸭子。我们希望实际捕获/删除类型t。例如。我们希望有一个我们可以称呼的东西的向量，他们可以有不同的行为（不同的底层类型）。</p><p>  What&#39;s THE hammer that can solve most problems in computer science? Yes,  another level of indirection.</p><p>  什么＆＃39;锤子可以解决计算机科学中大多数问题的锤子？是的，另一个间接程度。 </p><p>  class Bar : public AbstractBar {public: template &lt;typename T&gt; Bar(T t) {} void doSomething() override { t_.doSomething(); // hmm... but how do we store t_ }};void foo(Bar bar);</p><p>班级栏：公共摘录栏{public：模板＆lt; typename t＆gt;栏（t t）{} void dosomething（）覆盖{t_.dosomething（）; //嗯......但是我们如何存储t_}}; void foo（栏杆）;</p><p> If we have a  Bar class that has a templated constructor, it can  capture/erase the type T. And if we make  Bar a subclass of  AbstractBar that seems to solve the problem. Well not quite. We need to store  t_ of type  T, which can only be done with a templated class.</p><p> 如果我们有一个具有模板构造函数的栏级，它可以捕获/删除T型，如果我们制作纸条的一个似乎解决问题的抽象子类。不太好。我们需要存储T型T，只能使用模板类别完成。</p><p>   template &lt;typename T&gt;class BarWrapper : public AbstractBar {public: explicit BarWrapper(T t): t_(t) {} void doSomething() override { t_.doSomething(); // no vtable lookup here }private: T t_;};class Bar {public: template &lt;typename T&gt; Bar(T t) { // type captured/erased here t_ = std::make_unique&lt;BarWrapper&lt;T&gt;&gt;(t); } void doSomething() { t_-&gt;doSomething(); // vtable lookup here }private: std::unique_ptr&lt;AbstractBar&gt; t_; // now we solved the problem of storing t_ without knowing T};void foo(Bar bar);</p><p>   模板＆lt; typeName t＆gt;类Barwrapper：公共摘录栏{public：显式barwrapper（t t）：t_（t）{} void dosomething（）覆盖{t_.dosomething（）; //这里没有VTABLE查找}私有：T T _;};类栏{PUBLIC：模板＆lt; typeName t＆gt;栏（t t）{//类型捕获/删除此处t_ = std :: make_unique＆lt; barwrapper＆lt; t＆gt;（t）; void dosomething（）{t _-＆gt; dosomething（）; // vtable查找在这里}私有：std :: unique_ptr＆lt;摘录栏和gt; T_; //现在我们解决了在不知道t}的情况下存储t_的问题; void foo（酒吧吧）;</p><p>    Well that&#39;s a lot of levels of indirection. But the result is beautiful.  void foo(Bar bar), which accepts  anything that affords  doSomething (Duck Typing in C++). When  Bar1 gets converted to  Bar, its type got erased. We can have a  std::vector&lt;Bar&gt; that stores wildly different things as long as they can afford the  doSomething action, and it would work as you expect.</p><p>    那个＆＃39;很多间接级别。但结果很漂亮。 Void Foo（酒吧酒吧），它接受任何提供剂量的东西（在C ++中键入的鸭子）。当Bar1转换为栏时，它的类型被删除了。我们可以拥有STD :: Vector＆lt; bar＆gt;只要他们能够负担得起的手动行动，它就会储蓄不同的东西，并且它会在您期望的时候工作。</p><p> I learned a lot about Type Erasure from Author O&#39;Dwyer&#39;s post –  https://quuxplusone.github.io/blog/2019/03/18/what-is-type-erasure/. I highly recommend his posts and cppconf videos as well.</p><p> 我学到了关于来自作者O＆＃39的类型擦除; dwyer＆＃39; s post  -  https://quxplusone.github.io/blog/2019/03/18/what-is-type-erasure/我也强烈推荐他的帖子和CPPCONF视频。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.the-pans.com/type-erasure/">https://blog.the-pans.com/type-erasure/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/键入/">#键入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/erasure/">#erasure</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>