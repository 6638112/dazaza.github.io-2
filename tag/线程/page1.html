<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#线程</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#线程</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017088.html">论用户态线程和协程的性能</a></div><div class="item_title_en"><a target="_blank" href="https://inside.java/2020/08/07/loomperformance/">On the Performance of User-Mode Threads and Coroutines</a><span>(inside.java)</span></div><span class="my_story_list_date">2020-8-9 12:0</span><div class="my_story_list_item_desc">重定向…。
如果您未被重定向，请单击此处。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/协程/">#协程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/user/">#user</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/重定向/">#重定向</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016379.html">Java中小于10毫秒的延迟：使用绿色线程的并发GC</a></div><div class="item_title_en"><a target="_blank" href="https://jet-start.sh/blog/2020/08/05/gc-tuning-for-jet">Sub-10 Ms Latency in Java: Concurrent GC with Green Threads</a><span>(jet-start.sh)</span></div><span class="my_story_list_date">2020-8-5 19:28</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1016379.html"><img src="http://img.diglog.com/img/2020/8/thumb_95e30af2803e1b62dc04dbd82ab78efe.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在第3部分中，我们展示了运行实时流聚合的现代JVM可以实现低于10毫秒的99.99%延迟。这篇帖子的重点是比较JVM可用的不同GC选项。为了保持一个公平的竞争环境，我们尽可能地保持默认设置。
在这一轮中，我们想从相反的角度看同样的问题：我们可以做些什么来帮助Hazelcast Jet在JVM上实现最佳性能？当我们停留......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/latency/">#latency</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014453.html">谷歌建议为Linux提供用户线程</a></div><div class="item_title_en"><a target="_blank" href="https://lore.kernel.org/lkml/20200722234538.166697-1-posk@posk.io/">Google proposes user threads for Linux</a><span>(lore.kernel.org)</span></div><span class="my_story_list_date">2020-7-28 0:49</span><div class="my_story_list_item_desc">/color/Atom提要发件人：Peter Oskolkov&lt；posk@posk.io&gt；收件人：Linux内核邮件列表&lt；linux-kernel@vger.kernel.org&gt；，Thomas Gleixner&lt；tglx@linuconix.de&gt；，ingo Molnar&lt；......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/建议/">#建议</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014245.html">线程与进程：看看它们在程序中是如何工作的</a></div><div class="item_title_en"><a target="_blank" href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/#.Xxyr_JO0DSY.hackernews">Threads vs. Processes: A Look at How They Work Within Your Program</a><span>(www.backblaze.com)</span></div><span class="my_story_list_date">2020-7-26 17:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1014245.html"><img src="http://img.diglog.com/img/2020/7/thumb_5905b82cc9a0c1ffddd00fe06573cf58.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">您是否经常听到与计算机程序相关的术语“线程”，但您并不确定它的确切含义？流程呢？您可能知道线程在某种程度上与程序和进程密切相关，但是如果您不是计算机科学专业的学生，那么您的理解可能就是这样。
如果你是一名程序员，了解这些术语的含义是绝对必要的，但对普通计算机用户来说，理解它们也是很有用的。能够查看和了解Macinto......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进程/">#进程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/work/">#work</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013502.html">GoodJob 1.0，一个新的基于Postgres的多线程ActiveJob Rails后端</a></div><div class="item_title_en"><a target="_blank" href="https://island94.org/2020/07/introducing-goodjob-1-0">GoodJob 1.0, a new Postgres-based, multithreaded, ActiveJob back end for Rails</a><span>(island94.org)</span></div><span class="my_story_list_date">2020-7-22 23:26</span><div class="my_story_list_item_desc">受Delayed：：Job和Que的启发，GoodJob旨在最大限度地兼容Ruby on rails、ActiveJob和Postgres，使其对于大多数工作负载都是简单和高效的。
专为ActiveJob设计。使用几乎为零的配置完全支持异步、队列、延迟、优先级、超时和重试。
为Rails构建的。完全采用Ruby on......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/activejob/">#activejob</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/goodjob/">#goodjob</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012357.html">Zulip 3.0：线程化开源团队聊天</a></div><div class="item_title_en"><a target="_blank" href="https://blog.zulip.com/2020/07/16/zulip-3-0-released/">Zulip 3.0: Threaded Open Source Team Chat</a><span>(blog.zulip.com)</span></div><span class="my_story_list_date">2020-7-17 2:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012357.html"><img src="http://img.diglog.com/img/2020/7/thumb_563c2ae84467d984d469104dfbcb96dc.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我们很兴奋地宣布发布Zulip Server3.0，其中包含数百个新功能和错误修复，以帮助分布式和远程团队保持高效和专注。
Zulip是一款开源的线程化团队聊天应用，全球有数千个团队在使用。Zulip独特的基于主题的线程化体验将实时聊天的即时性与电子邮件式线程化的异步效率相结合。
Zulip Server 3.0包含......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/团队/">#团队</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/open/">#open</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zulip/">#zulip</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012328.html">Twitter发布了一个全新的、完全重建的开发者API，它具有对话线程、推文中的投票结果和固定推文等功能，将于下周推出</a></div><div class="item_title_en"><a target="_blank" href="https://techcrunch.com/2020/07/16/twitter-introduces-a-new-fully-rebuilt-developer-api-launching-next-week/">Twitter unveils a new, fully rebuilt developer API with features like conversation threading, poll results in tweets, and pinned tweets, launching next week</a><span>(techcrunch.com)</span></div><span class="my_story_list_date">2020-7-17 0:17</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012328.html"><img src="http://img.diglog.com/img/2020/7/thumb_a925cdd856b933f82fbe08d2e53bc62f.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">虽然Twitter表示没有证据表明昨天的安全事件与其API有关，但实际上，按照计划，今天启动它不得不将重点放在确保Twitter及其账户的安全上。该公司计划在下周某个时候推出APIv2和其他内容，比如新的支持中心、文档和其他详细信息的博客文章。
Twitter的APIv2将引入多个访问级别，以取代当前API(v1.1......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/功能/">#功能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tweets/">#tweets</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012294.html">举例说明：异常、时间旅行搜索、线程等</a></div><div class="item_title_en"><a target="_blank" href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">Continuations by example: Exceptions, time-traveling search, threads, and more</a><span>(matt.might.net)</span></div><span class="my_story_list_date">2020-7-16 23:0</span><div class="my_story_list_item_desc">使用一级延续，可以将非确定性(或模糊性)选择&34；过程添加到语言中：AMB。AMB过程获取一个值列表，并从中选择一个。这里的问题是，AMB必须选择一个值，以便在计算的将来遇到的所有ASSERT语句都为真。例如，下面的Scheme代码：(#*_)。
((a(amb(List 1 2 3 4 5 6 7)(b(amb(......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/旅行/">#旅行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/过程/">#过程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010363.html">并发成本层次结构</a></div><div class="item_title_en"><a target="_blank" href="https://travisdowns.github.io/blog/2020/07/06/concurrency-costs.html">A Concurrency Cost Hierarchy</a><span>(travisdowns.github.io)</span></div><span class="my_story_list_date">2020-7-8 1:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010363.html"><img src="http://img.diglog.com/img/2020/7/thumb_ec75e516c56363ac44446e56713e2e7c.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">并发性很难纠正，至少对于我们这些不幸地用直接暴露并发硬件内部的语言编写的人来说是这样的：线程和共享内存。正确而快速地获得并发性也很困难。您的单线程优化知识通常对您没有帮助：在微(指令)级别，我们不能简单地应用μ操作、依赖链、吞吐量限制等常见规则。规则是不同的。
如果第一段让您燃起了希望，那么第二段将使您的希望破灭：我......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/成本/">#成本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cost/">#cost</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008256.html">制作我们自己的可执行打包程序，第13部分，线程本地存储</a></div><div class="item_title_en"><a target="_blank" href="https://fasterthanli.me/blog/2020/thread-local-storage/">Making our own executable packer, part 13, Thread-local storage</a><span>(fasterthanli.me)</span></div><span class="my_story_list_date">2020-6-26 2:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1008256.html"><img src="http://img.diglog.com/img/2020/6/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">欢迎回来，感谢你加入我们的阅读笔记…。关于ELF文件的系列文章的第13部分介绍了它们是什么，它们可以做什么，动态链接器对它们做了什么，以及我们自己如何做到这一点。
到目前为止，我一直很成功地避免谈论TLS(不，不是那个)，但我想我们已经到了不能再拖延的地步了，所以。
我们从艰难地阅读文件的经历中知道，作为一个用户端应......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/执行/">#执行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/local/">#local</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007487.html">观看AMD ThreadRipper 3990X在任务管理器中使用128个线程渲染视频</a></div><div class="item_title_en"><a target="_blank" href="https://www.tomshardware.com/news/watch-amd-threadripper-3990x-128-threads-render-video-task-manager">Watch AMD Threadripper 3990X Use 128 Threads to Render a Video in Task Manager</a><span>(www.tomshardware.com)</span></div><span class="my_story_list_date">2020-6-21 9:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1007487.html"><img src="http://img.diglog.com/img/2020/6/thumb_11504fbbff7cf4290d5f112a072fbba4.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">您是否想过将Windows任务管理器用作视频播放器？我也没有，尽管随着我的系统在内核和线程数量上的进步，我总是被它监控的CPU内核数量的增加迷住了。然而，AMD的64核、128线程的Ryzen ThreadRepper 3990X将使事情变得更加令人着迷。
将所有这些线程打包到Windows监控工作站中，您就拥有了1......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/amd/">#amd</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1005452.html">使用AppsScript实现Gmail自动化</a></div><div class="item_title_en"><a target="_blank" href="https://akshayshah.org/automating-gmail-with-appsscript/">Automating Gmail with AppsScript</a><span>(akshayshah.org)</span></div><span class="my_story_list_date">2020-6-6 23:4</span><div class="my_story_list_item_desc">我们都被电子邮件淹没了。问题不在于明目张胆的垃圾邮件--订阅大部分垃圾邮件并屏蔽其余内容很容易。真正的杀手是一封有点有趣的电子邮件：关于你外围参与的项目的讨论，每周的时事通讯，几个月前你提交的关于GitHub问题的闲聊，以及所有其他你有时间就略过的邮件，如果你忙的话就跳过。手动分类这些电子邮件可能是一场令人精疲力竭的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gmail/">#gmail</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004419.html">生锈：将较重的东西放入另一个线程可以使您的代码速度提高10000倍</a></div><div class="item_title_en"><a target="_blank" href="https://abramov.io/rust-dropping-things-in-another-thread">Rust: Dropping heavy things in another thread can make your code 10000x faster</a><span>(abramov.io)</span></div><span class="my_story_list_date">2020-5-31 1:11</span><div class="my_story_list_item_desc">在处理需要以最快速度向最终用户显示内容的Rust应用程序或CLI时，我经常发现，大量时间通常不是花在做任何计算上，而是花在删除函数末尾的大型数据结构上。
例如，假设您有一个函数，该函数获取一些较重的对象并返回其大小：
弄到a的大小是非常便宜的。它大约需要0.01ms，但是整个函数在返回任何东西之前可能需要1000ms......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/速度/">#速度</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dropping/">#dropping</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003557.html">用C++实现简单的协作线程</a></div><div class="item_title_en"><a target="_blank" href="https://brennan.io/2020/05/24/userspace-cooperative-multitasking/">Implementing simple cooperative threads in C</a><span>(brennan.io)</span></div><span class="my_story_list_date">2020-5-25 3:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1003557.html"><img src="http://img.diglog.com/img/2020/5/thumb_4d16095418a953c639be9666b70f5aac.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">斯蒂芬·布伦南·2020年5月24日，就像操作系统提供的许多服务一样，多任务处理是一件理所当然的事情，以至于感觉很平凡。有了我们功能强大的智能手机和计算机，一台计算机不能同时处理数百个进程的想法让人感觉很陌生。我认为正是这样的功能让计算机变得非常有用，但也让它们感觉如此复杂和神奇。
很难玩弄实现多任务的代码，如果不构......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002747.html">Java.net.SocketInputStream.socketRead0中的线程卡住</a></div><div class="item_title_en"><a target="_blank" href="https://blog.fastthread.io/2018/09/02/threads-stuck-in-java-net-socketinputstream-socketread0/">Threads Stuck in Java.net.SocketInputStream.socketRead0</a><span>(blog.fastthread.io)</span></div><span class="my_story_list_date">2020-5-19 15:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1002747.html"><img src="http://img.diglog.com/img/2020/5/thumb_d88be342f778ae311b6e5a0efb01cc19.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">java.net.SocketInputStream.socketRead0()API做什么？为什么它经常出现在几个线程转储中？为什么会在像TastThread.io这样的线程转储分析工具中报告呢？是不是有什么我需要关心的事情？这个问题的潜在解决方案是什么？让我们找出这些问题的答案。
通过现实生活中的类比，记住新概念......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/stuck/">#stuck</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002384.html">织机的状态</a></div><div class="item_title_en"><a target="_blank" href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">State of Loom</a><span>(cr.openjdk.java.net)</span></div><span class="my_story_list_date">2020-5-16 19:15</span><div class="my_story_list_item_desc">Project Loom旨在极大地减少编写、维护和观察充分利用可用硬件的高吞吐量并发应用程序的工作。
织布机项目于2017年底开工。这份文件解释了项目的动机和采取的方法，并总结了我们到目前为止的工作。像所有OpenJDK项目一样，它将分阶段交付，不同的组件在不同的时间到达GA(通用可用性)，很可能首先利用预览机制。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/织机/">#织机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002314.html">Java：(项目)绝缘线束的状态</a></div><div class="item_title_en"><a target="_blank" href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">Java: State of (Project) Loom</a><span>(cr.openjdk.java.net)</span></div><span class="my_story_list_date">2020-5-16 6:0</span><div class="my_story_list_item_desc">Project Loom旨在极大地减少编写、维护和观察充分利用可用硬件的高吞吐量并发应用程序的工作。
织布机项目于2017年底开工。这份文件解释了项目的动机和采取的方法，并总结了我们到目前为止的工作。像所有OpenJDK项目一样，它将分阶段交付，不同的组件在不同的时间到达GA(通用可用性)，很可能首先利用预览机制。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/项目/">#项目</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1000370.html">锈写的氧化还原操作系统引导128线程AMD Ryzen线程裂解器3990X</a></div><div class="item_title_en"><a target="_blank" href="https://www.phoronix.com/scan.php?page=news_item&px=Redox-OS-On-Threadripper-3990X">Rust-Written Redox OS Booting the 128-Thread AMD Ryzen Threadripper 3990X</a><span>(www.phoronix.com)</span></div><span class="my_story_list_date">2020-5-2 23:50</span><div class="my_story_list_item_desc">专注于Rust语言的Redox OS开源操作系统现在能够启动AMD Ryzen ThreadRipper 3990X 64核/128线程处理器，并以完整的多线程功能运行。虽然Rust编程语言的基本原则之一是提供安全的并发性，但Redox OS本身存在一个多核问题，直到本周，首席Redox OS开发人员(和System......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ryzen/">#ryzen</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/redox/">#redox</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/线程/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/线程/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>