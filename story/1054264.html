<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>64位Linux面向返回的编程 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">64位Linux面向返回的编程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-24 02:27:53</div><div class="page_narrow text-break page_content"><p>更新：Dongli Zhang报告较新的Linux版本以不同的方式组织堆栈。下面的代码需要相应修改。</p><p> 没有人是完美的。特别不是程序员。有些日子，我们花了一半的时间我们在另一半制作的错误。那就是我们幸运的时候：经常，一个微妙的虫子被嘲笑进入野外，我们只学习易碎的巨大灾难。</p><p> 一些灾难是偶然的。例如，在触发被忽视的逻辑错误所需的精确条件下，Mightresult的不幸事件连锁术中可能是故意的。就像在复杂规则的迷宫中滥用税收漏洞的会计师一样，攻击者可能会发现一个错误，然后利用它接管许多计算机。</p><p> 因此，现代系统与安全功能为设计的超级泄露者提供的安全功能。例如，这些保障措施可能会隐藏重要信息，或者在检测机构行为后立即停止执行程序。</p><p> 可执行空间保护是一个这样的防御。不幸的是，它是攻击性的防御。在本指南中，我们展示了如何使用称为ReturnieDrogramming的技术来旨在将可执行的SpaceProt调整为64位Linux。</p><p> 我们开始通过编写程序集通过execvesystem调用来启动shell的旅程。</p><p> 对于向后兼容性，64-Bitlinux支持32位Linux系统调用，因此我们可能会认为我们可以重用针对32位系统的ShellCode。但是，EXECVE SYSCALL占据程序的NUL-TRADIDINGNAME的内存地址应该被执行。我们的shellcode可能会注入一下，要求我们引用大于32位的内存地址.Thus我们必须使用64位系统调用。 </p><p>int main（）{asm（＆＃34; \ needle0：jmp with \ n \ ni ne：pop％rdi \ n \ xor％rax，％rax \ n \ movb $ 0x3b，％al \ n \ xor％RSI，％ RSI \ n \ xor％rdx，％rdx \ n \ syscall \ n \ n \ with：呼叫这里\ n \ .string \＆＃34; / bin / sh \＆＃34; \ n \ preedle1：.octa 0xdeadbeef \ n \＆＃34;）;}</p><p> 无论在内存我们的代码时，Call-Pop技巧会将RDI注册到＆＃34; / bin / sh＆＃34的地址;细绳。</p><p> 针头0和针1标签是稍后有助于搜索;所以0xDeadBeef常数是（虽然x86是小endian，但它将显示为ef为ad de，后跟4个零字节）。</p><p> 为简单起见，我们不正确地使用API​​;第二和第三areguctsto执行应该指向NULL终止指针ToS​​trings阵列（argv []和envp []）。但是，我们的系统宽恕：运行＆＃34; / bin / sh＆＃34; null argv和envp成功：</p><p> $ objdump -d a.out | SED -N＆＃39; /针0 /，/针头1 / P＆＃39; 00000000004004BF＆lt;针0＆gt ;: 4004bf：EB 0e 2 4004cf＆lt;这里＆gt ;: 4004c1：5f pop％rdi 4004c2：48 31 C0 XOR％rax，％rax 4004c5：b0 3b mov $ 0x3b，％al 4004c7：48 31 f6 xor％RSI，％RSI 4004ca：48 31d2 XOR％RDX，％RDX 4004CD：0F 05 SYSCALL0000000000004004CF＆LT;其中＆gt ;: 4004CF ：E8 ED FF FF FF CALLQ 4004C1＆LT;此处＆gt; 4004D4：2F（坏）4004D5：62（坏）4004D6：69 6E 2F 73 68 00 EF IMUL $ 0xEF006873,0x2F（％RSI），％EBP00000000004004DC＆lt;针1＆gt ;:</p><p> 在64位系统上，代码段通常位于0x400000，因此在二进制文件中，我们的代码在偏移0x4bf以偏移0x4bf开始，并在Offoffset 0x4DC之前完成。这是29个字节：</p><p>  我们将此达到下一个倍数为8以获得32，然后运行： </p><p>#include＆lt; stdio.h＆gt; int main（）{char name [64];放（＆＃34;什么＆＃39;你的名字？＆＃34;）;得到（姓名）; printf（＆＃34; hello，％s！\ n＆＃34;，姓名）;返回0;}</p><p> 由于X86系统的CDECL呼叫约定，如果我们输入一个真正的字符串，我们将溢出名称缓冲区，并覆盖returnaddress。输入shellcode后跟右字节，程序在尝试从主要功能返回时运行它。</p><p> 唉，堆栈粉碎这些时代更难。我的股票Ubuntu 12.04安装，有3个对策：</p><p> GCC Stack-Smashing Protector（SSP），AKA Propolice：编译器重新排列堆栈布局，使缓冲区溢出较少危险并插入运行时堆栈完整性检查。</p><p> 可执行空间保护（NX）：尝试在堆栈中执行代码会导致分段错误。这项功能通过许多名称，例如， Windows上的数据执行预防（DEP），或在BSD上写入XOR执行（W ^ x）。我们在此处调用它，因为64位Linux使用CPU的NX位（＆＃34;切勿执行＆＃34;）实现此功能。</p><p> 地址空间布局随机化（ASLR）：堆栈的位置每次运行都随机化，因此即使我们可以覆盖返回地址，我们也不知道将其放在那里。</p><p>        #include＆lt; stdio.h＆gt; int main（）{char name [64]; printf（＆＃34;％p \ n＆＃34;名称）; //打印缓冲区地址。放（＆＃34;什么＆＃39;你的名字？＆＃34;）;得到（姓名）; printf（＆＃34; hello，％s！\ n＆＃34;，姓名）;返回0;} </p><p>$（（cat shellcode; printf％080d 0; echo $ a）| xxd -r -p; cat）| setarch` arch` -r ./victim</p><p> shellcode占用缓冲区的前32个字节。 ThePrintF中的80个零代表40个零字节，其中32个填充缓冲区的其余部分，并且其余8覆盖RBP寄存器的保存位置。接下来的8 overwrite返回地址，并指向缓冲区的开头，从何处shellcode谎言。</p><p> 点击几次，然后输入＆＃34; ls＆＃34;确认我们确实是ina运行的shell。没有提示，因为标准输入由CAT提供，而不是终端（/ dev / tty）提供。</p><p> 只是为了好玩，我们会绕道而行并查看ASLR。在过去，您可以通过查看/ proc / pid / stal来阅读任何进程的ESP注册。 Thisleak很久以前插了。 （如今，一个过程可以在纯粹的过程上间谍，否则它有权允许Ptrace（）。）</p><p> 让我们假装我们在一个未被淘汰的系统上，因为它更加令人满意而不禁止。此外，我们看到首先是被修补的重要性，以及为什么aslrneeds保密以及随机性。</p><p>       因此，虽然受害者程序正在等待用户输入，但它是Stack Pointeris 0x7FFFFFE038。我们计算与该指针到NameBuffer的距离：</p><p>  我们现在武装偏移，我们需要在旧系统上击败ASLR。使用ASLR重新启用运行受害者程序： </p><p>$ sp =`ps  -  no-header -c progrest -o esp` $ a =`printf％016x $（（0x7fff $ sp + 88））| TAC -R -S..` $（（cat shellcode; printf％080d 0;回声$ a）| xxd -r -p; cat）＆gt; pip</p><p> 重新编译受害者程序而不运行execstack命令。通过运行，重新激活可执行空间保护：</p><p>  尝试如上所述攻击此二进制文件。我们的努力被挫败了，只要Propram跳到了堆栈中的注入的shellcode。整个区域都被标记为nonexecutable，所以我们被关闭了。</p><p> 以返回返回的编程灵巧地偏信这种防御。经典的bufferoverflow inspoit用我们想要运行的代码填充缓冲区; Return-OrientEdProgramment（RESOREDPRAGGUMMING）填充了带有代码络部片段的地址的缓冲区来运行，将堆栈指针转换为一种间接的指令点。</p><p> 代码片段从可执行内存中处理：例如，它们是libc的碎片。因此，NX位无力阻止我们。更多详细信息：</p><p> 我们从SP开始指向一系列地址的开始。 RET指令踢掉了东西。</p><p> 忘记从子程序返回的通常含义。相反，关注其影响：Ret跳转到SP保持的内存位置的地址，并递增8（在64位系统上）。 </p><p>我们的使命是用＆＃34致电Libc系统（）函数; / bin / sh＆＃34;作为杆头。我们可以通过调用分配所选值tordi的小工具来执行此操作，然后跳转到系统（）libc函数。</p><p>   我的系统有一个32位和64位libc。我们想要64位;这是列表中的那零。</p><p>      虽然指针到＆＃34; / bin / sh＆＃34;位于堆栈的顶部。这将在推进堆栈指针之前将指针指向到RDI。相应的机器代码是两个字节序列0x5f 0xC3，其在Libc中的某处发生。</p><p> 可悲的是，我知道没有广泛的Linux工具，可以搜索一个文件的一个文件的一个字节;大多数工具似乎面向文本文件，并期望他们的纽扣组织。 （我提醒抢劫派克的＆＃34;结构规范抑制＆＃34;）</p><p>  $ xxd -c1 -p /llib/x86_64-linux-gnu/libc.so.6 | grep-n -b1 c3 | grep 5f-m1 | awk＆＃39; {printf＆＃34;％x \ n＆＃34;，$ 1-1}＆＃39; 22a12</p><p>  寻找＆＃34; c3＆＃34;，并与匹配一起打印一行领先的上下文。我们还打印了行号。</p><p>  由于行号从1开始，偏移开始从0开始，我们必须减去1以从前者那里得到后者。此外，我们希望十六进制中的地址。要求awk将第一个参数视为一个数字（由于减法）方便地删除数字后的所有字符，即＆＃34; -5f＆＃34;那个grep输出。 </p><p>然后在执行下一个ret指令时，程序将弹出＆＃34的地址; / bin / sh＆＃34;由于第一个小工具进入RDI，然后跳转到系统功能。</p><p> $ pid =`ps -c受害者-o pid --no-headers | TR -D＆＃39; ＆＃39;`$ grep libc / proc / $ pid / maps7aff7a1d000-7fff7bd0000 r-xp 00000000 08:05 7078182 /llib/x86_64-linux-gnu/libc-2.15.so7ffff7bd0000-7ffff7dcf000 --- p 001b3000 08:05 7078182 /llib/86_64-linux-gnu/libc-2.15.so7ffff7dcf000-7ffff7dd3000 r  -  p 001b2000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so7ffff7dd3000-7ffff7dd5000 rw-p 001b6000 08:05 7078182 / lib / x86_64-linux-gnu / libc-2.15.so</p><p> 因此，Libc以0x7ffff7a1d000开始加载到存储器中。这给出了救助的第一成分：小工具的地址是0x7ffff7a1d000 + 0x22a12。</p><p> 接下来我们想要＆＃34; / bin / sh＆＃34;在记忆中的某个地方。我们可以同样地进行脚步，并在缓冲区的开头放置此字符串。从之前，它的地址是0x7FFFFFFFE090。</p><p>    $（echo -n / bin / sh | xxd -p; printf％0130d 0; printf％016x $（（0x7ffff7a1d000 + 0x22a12））| tac -rs ..; printf％016x 0x7fffffffe090 | tac -rs ..; printf％ 016x $（（0x7ffff7a1d000 + 0x44320））| TAC -RS ..）| XXD -R -P | setarch` arch` -r ./victim</p><p> 点击几次，然后输入一些命令以确认这是一个shell。</p><p> 这次有130个0s，XXD变成了65个零个字节。这种情况不足以覆盖＆＃34之后的其余缓冲区; / bin / sh＆＃34;除了ThePushed的RBP寄存器，使我们覆盖的下一个位置是堆栈的顶部。 </p><p>在我们的简短冒险中，普罗尔尼是最好的防守。它试图将ArraySto移动到堆栈的最高部分，因此可以通过溢出它们来实现较少.Aditionally，它在阵列的末端处置于阵列的末尾，该值被称为金丝雀。如果大公者受到伤害，它会在返回停止指令之前插入检查。我们不得不完全禁用普牛犬开始。</p><p> ASLR还捍卫我们的攻击，只要有足够的熵，随机性保持秘密。这实际上是相当棘手的。我们看到豪索系统通过/ proc泄露了信息泄露了信息。一般来说，攻击者已经设计了巧妙的方法来学习隐藏的地址。</p><p> 最后，最少，我们有可执行的空间保护。事实证明，它被生动了。那么如果我们不能在堆栈中运行代码怎么办？我们将简单地指向其他地方的代码并运行它！我们使用了libc，但一般来说，通常有一些代码语料库我们可以raid。例如，研究人员组织了一个具有广泛可执行空间保护的投票机，将自己的代码反对它。</p><p>  ASLR需要与许多缔约方的合作。程序和图书馆必须在随机地址中加载。必须插入信息泄漏。</p><p> 有人一定是想到的，因为它现在如此普遍。现在是时候问：是可执行的空间保护值得删除吗？可执行空间保护比什么都好吗？</p><p> 我们刚看到它是多么微观，缝合在一起的现有Codeto做我们肮脏的工作。我们几乎没有划伤表面：只有几个小工具，任何计算都是可能的。此外，还有工具，用于将输入语言转换为ofddresses系列的小工具，以及将输入语言转换为一系列的编译器，可用于毫无疑问的不可执行的堆栈。令人畏缩的攻击者可能忘记可执行空间保护偶数。</p><p> 因此，我认为可执行空间保护比没有更糟糕。可以从高成本和低利益，它从数据中隔离代码。抢劫派克这件事： </p><p>这在面对图灵和冯诺伊曼的理论面前，这将综合杂于储存程序计算机的基本原则。代码和dataare相同，或者至少可以。</p><p> 可执行空间保护干扰了自修改的代码，该代码是可用于准时编译的，以及奇迹般地呼吸新的LifeInto古老的呼叫约定在石头上设置。</p><p> 在一个描述如何为C的函数添加到C的论文中，尽管它是简单的呼叫约定和薄指针，Thomas Breuel观察：</p><p> 然而，有些架构和/或操作系统禁止在运行时生成和执行代码的程序。我们认为这一限制是任意的，并考虑它的硬件或软件设计差。诸如规划语言的实现，例如，LISP或SmallTalk可以从运行时快速生成或修改代码的能力显着地受益。</p><p> 非常感谢Hovav Shacham，他们先发制人归来以返回的编程为我的注意力。他共同撰写了全面介绍了以Toreturn为导向的编程。此外，请参阅如何返回返回的编程的技术细节。</p><p> 我们专注于特定的攻击。对于其他种类的攻击，我们遇到的防御可能是无效的。例如，ASLR的堆叠喷涂很难。</p><p> 以返回返回的编程是返回libc攻击的概括，该攻击调用库函数而不是小工具。在32位Linux中，Thec Calling Aructory有用，因为参数通过堆栈传递：我们需要做的只是钻机堆栈，以便堆叠我们的参数和地址库函数。执行时，我们正在商业。 </p><p>但是，64位C呼叫约定与64位系统关联的相同，除了RCX占R10的位置，并且可能存在超过6个参数（任何额外的附件以左右左右排列在堆栈上） .Flowing缓冲区仅允许我们控制堆栈的内容，而不是寄存器，并不复杂返回libc攻击。</p><p> 正如建造者在完成摩天大楼后取出脚手架一样，我省略了GDB会话，帮助我沿途。你认为我有没有第一次完美地利用字节？我希望！</p><p> 说到哪些，我差不多确定我从来没有用调试器调试！我只用它们在装配中编程，调查一副我缺少来源，现在，对于缓冲区溢出漏洞。 Fromlinus Torvalds的报价来找：</p><p> 我不喜欢调试器。从来没有，可能永远不会。我使用GDB所有轮动，但我倾向于使用它不是调试器，而是作为您可以编程的反汇编扬声器。</p><p>  最有效的调试工具仍然是谨慎的想法，与明智地放置的打印陈述耦合。</p><p> 我不确定，如果我会写GDB，因为已经存在了很多指南。如果现在，我将列出一些选择命令：</p><p>  GDB有助于确定代码，尽管当禁用ASLR时，位置瘙痒与Shell的选择略微不同。 </p><p>Ben Lynn Blynn@cs.stanford.edu💡 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://crypto.stanford.edu/~blynn/rop/">https://crypto.stanford.edu/~blynn/rop/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1054242.html"><img src="http://img2.diglog.com/img/2021/3/thumb_266d9659efe94309e136aacc736706de.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054242.html">Linus Torvalds在Rust将适合Linux的地方 </a></div><span class="my_story_list_date">2021-3-24 0:17</span></div><div class="col-sm"><div><a target="_blank" href="/story/1054147.html"><img src="http://img2.diglog.com/img/2021/3/thumb_5d51f4bdf451cbe4ca4bd341d97666ac.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054147.html">将Linux桌面留在后面 </a></div><span class="my_story_list_date">2021-3-23 13:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1054108.html"><img src="http://img2.diglog.com/img/2021/3/thumb_53d0c619fd03b523cd1bd197f3c19787.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054108.html">在Windows子系统中设置拱门Linux，用于Linux 2 </a></div><span class="my_story_list_date">2021-3-23 7:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1053667.html"><img src="http://img2.diglog.com/img/2021/3/thumb_5b33100f3c021c3c81ba8a4322c905d8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1053667.html">Rust将“暂定第一步”朝向Linux内核 </a></div><span class="my_story_list_date">2021-3-21 0:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>