<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于冗余的冗余故事 Redundant Stories about Redundancy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Redundant Stories about Redundancy<br/>关于冗余的冗余故事 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-15 22:32:07</div><div class="page_narrow text-break page_content"><p>This is a buffet of redundant stories. I provide several pieces and you choose which of them to read and share, and in which order. Every piece contains the same thought only put differently so don&#39;t be afraid to miss anything. Experiment and enjoy!</p><p>这是一个冗余故事的自助餐。我提供了几件，你选择其中哪一个读取和分享，并且在哪个顺序中。每件事都包含相同的想法，只有不同的思想，所以不要害怕错过任何东西。实验和享受！</p><p>           Component   redundancy is used heavily in safety-critical and mission-critical systems for reliability improvement. But outside this niche, it&#39;s surprisingly little known in the world of software. Which is a shame since it&#39;s a simple but economical idea. It costs nothing to keep in mind, and it saves you a lot on hotfixes and emergency repairs.</p><p>           组件冗余在很大程度上用于安全关键和关键任务系统，以实现可靠性改进。但在这个利基外，它＆＃39;在软件世界中令人惊讶的是令人惊讶的。这是一个耻辱自It＆＃39;是一个简单但经济的想法。它不需要记住，它可以在修补程序和紧急维修时拯救您很多。</p><p>  Redundancy, however, only makes sense if you have unreliable components and software components are theoretically infinitely reliable. It is only in practice they aren&#39;t.</p><p>  但是，如果您拥有不可靠的组件和软件组件理论上无限可靠，则冗余只会有意义。它只是在实践中，他们aren＆＃39; t。</p><p>     Let’s say you want to keep your core temperature under control. You put a thermal sensor there, wire it out to some kind of  SCADA, and here you go. Except, since it’s very important, you can’t rely on just one wire. What if for whatever reason it snaps?</p><p>     假设您希望在控制下保持核心温度。你把一个热传感器放在那里，将它电向某种苏米达，你走了。除了它非常重要，因为你不能依赖一根电线。如果不管它捕捉到什么原因，怎么办？</p><p>  So you add another scanner and another wire. It’s now more reliable. But what if one of the scanners shows 300 degrees Celsius, and the other 1234? Should you shut down the reactor or replace the broken scanner?</p><p>  所以你添加另一个扫描仪和另一个电线。现在更可靠。但是，如果其中一个扫描仪显示300摄氏度，另一个1234？如果您关闭反应堆或替换破碎的扫描仪？</p><p>  Well, you add another scanner and another wire. Now it’s either 300, 300, 1234, or 1234, 1234, 300. You can now make a decision.</p><p>  嗯，你添加另一个扫描仪和另一根电线。现在它是300,300,1234或1234,1234,300。您现在可以做出决定。</p><p>  In Ukraine, up until the early 90s, components like these were triplicated on all the nuclear power plants. But then the collaboration with  IAEA started and they brought in the new question: let’s say you know that you need to replace the broken sensor. Now how can you be sure, you’re getting adequate data  while you’re replacing it?</p><p>  在乌克兰，直到90年代初期，这些组成部分在所有核电站都有三次。但随后与原子能机构的合作开始，他们带来了新问题：让我们说你知道你需要更换破碎的传感器。现在你怎能确定，在更换它时，你会得到足够的数据吗？ </p><p>  The rest of the world was already quadruplicating their components, but the Ukrainian NPP industry didn’t yet have a reliable quadruplicator — a special device to bring four signals together. Developing and producing this device, considering the strictest reliability requirements, would be too risky at that point, so they decided to duplicate a triplicator instead.</p><p>世界其他地区已经四分类的组件，但乌克兰NPP行业尚未拥有可靠的四分夹子 - 一种特殊的设备，可以将四个信号带到一起。考虑到最严格的可靠性要求，开发和生产该设备，在那一点上会过于危险，因此他们决定重复一份三倍者。</p><p>  Let that sink in. Multiplicating the proven multiplicator was considered a better option than introducing a completely new component to the system.</p><p>  让它进入。乘法乘以验证的乘法器被认为是比向系统引入完全新的组件的更好的选择。</p><p>    Well, nothing. Because we somehow presume that software components are flawless. They are, of course, not, but this is the model we chose to believe in. A diode can fail, a resistor can burn, a capacitor can leak, but a hello-world is a hello-world forever and ever.</p><p>    好吧，没有。因为我们以某种方式假设软件组件完美无瑕。当然，他们是不是，但这是我们选择相信的模型。二极管可以失效，电阻可以燃烧，电容器可以泄漏，但是一个地狱世界永远是一个地狱世界。</p><p>  If software is flawless, then redundancy brings no value. But empirically, it does. To understand why is it so appreciated in the world of safety-critical development, and to learn to use it for our advantage, we first have to abandon the notion of software infallibility.</p><p>  如果软件完美无瑕，那么冗余带来没有值。但经验，它确实如此。要了解为什么在安全关键发展的世界中如此赞赏，并学会使用它的优势，我们首先必须放弃软件无谬误的概念。</p><p>     In the world of inherently unreliable components, a. k. a. the real world, introducing redundancy is the only realistic way to improve your system reliability. It’s simple math.</p><p>     在世界上固有的不可靠的组件，a。 k。一种。现实世界，引入冗余是提高系统可靠性的唯一现实方式。这是简单的数学。</p><p>  Let’s say you have 3 components. Each has a 10% chance of failure and a 90% chance to work. If you wire them consequently, the reliability of this subsystem would be:</p><p>  让我们说你有3个组件。每个人都有10％的失败机会和90％的工作机会。如果您如下，此子系统的可靠性将是：</p><p>        Now if you have the same low-reliability components but you wire them in parallel, so the working ones could substitute the failed, then the reliability of such subsystem would be:</p><p>        现在，如果您具有相同的低可靠性组件，但您并联地连接它们，因此工作组可以替换失败，那么此类子系统的可靠性将是： </p><p>      Adding unreliable components in a sequence reduces your system&#39;s reliability little by little. But duplicating unreliable components improves your system&#39;s reliability drastically. That&#39;s how redundancy works.</p><p>在序列中添加不可靠的组件可减少您的系统＆＃39; S的可靠性小。但是，重复的不可靠的组件急剧改善了您的系统和＃39; S的可靠性。那个＆＃39; s冗余如何运作。</p><p>  Hardware guys, especially those who burned enough resistors, realize that. That’s why they duplicate and triplicate anything worth triplicating. We don’t.</p><p>  硬件家伙，尤其是那些燃烧足够电阻的人，意识到这一点。这就是为什么他们重​​复和三份值得一式一同的东西。我们没有。</p><p>  Because in software, we assume that the code is always defect-free or at least deterministic. There is a  whole field of study that disproves the former and a lot of  anecdotal evidence to contradict the latter, but the general notion is: programs are not susceptible to wear and decay, and that alone makes them ultimately reliable.</p><p>  因为在软件中，我们假设代码总是无缺陷或至少确定的。有一个整个研究领域，使前者和许多轶事证据具有矛盾，但总体概念是：计划不容易磨损和腐烂，而且单独使它们最终使他们最终可靠。</p><p>  Of course, if your reliability is measured as 1, then you can multiply it however you like, you&#39;ll still get 1. Redundancy is then pointless. It only makes sense if we admit that the software is inherently just as fault-prone as everything else in the world.</p><p>  当然，如果您的可靠性被测量为1，那么您可以乘以它，但是您喜欢，您＆＃39;仍然获得1.冗余是无意义的。如果我们承认该软件本身就像易受世界上其他所有其他东西一样，它只有意义。</p><p>       I had to build a very cool thing I can’t tell much about for legal reasons. I can tell about its build process though. It was supposed to be a CUDA thing wired into a C++ code built with CMake and running on Linux. The build instruction, actually a Docker file, was explicit about versions but only to the point at which it works in Docker. I wanted to build the thing on WSL, and this brought enough uncertainty to make the build system crumble.</p><p>       我必须建立一个非常酷的事情，我无法讲述法律原因。我可以讲述它的构建过程。它应该是用CMake和Linux上运行的C ++代码连接的CUDA。构建指令实际上是Docker文件，是关于版本的显式，但仅对它在Docker中工作的点。我想在WSL上建立这件事，这带来了足够的不确定性来使构建系统崩溃。</p><p>  What I found out that weekend. For some reason, CMake versions 16 and higher don’t bootstrap on GCC 5 to 7. But only on WSL2. On WSL, they do, but CUDA doesn’t see your GPU. The target architecture for CUDA is set differently in CMake 17 and CMake 18. And clang-tools and clanglib can but really shouldn&#39;t belong to different versions of Clang.</p><p>  我发现的那个周末。出于某种原因，CMAKE版本16和更高版本在GCC 5到7上不会引导。但仅在WSL2上。在WSL上，他们这样做，但CUDA没有看到你的GPU。 CUDA的目标架构在CMake 17和CMake 18中不同地设置。和克朗 - 工具和Clanglib可以但真的不属于不同版本的铿cl声。</p><p>  There were also troubles with different C++ standards and dialects. The most annoying, the most trivial, and the most unnecessary ones. Like on MSVC, you can get away with messages in plain std::exceptions, on GCC, you can not. In C++17, there are messageless static_asserts, but in C++14, all the static asserts should be supplied with a message string.</p><p>  还有不同的C ++标准和方言的麻烦。最烦人的，最琐碎的和最不必要的人。就像在msvc上一样，您可以在普通的std ::例外，在gcc上播放消息，你不能。在C ++ 17中，有Messageless Static_Asserts，但在C ++ 14中，应使用消息字符串提供所有静态断言。 </p><p>    The build process was too consecutive, a failure in any subsystem caused all the build to fail. And if you even tried CMake, CUDA, and even cross-platform C++, you know how fragile these things are. You can’t build a reliable consecutive system out of unreliable subsystems. It’s simple math.</p><p>构建过程太过连续，任何子系统的失败导致所有构建都失败。如果你甚至尝试了CMake，CUDA，甚至跨平台C ++，你就知道这些事情是多么脆弱。您无法从不可靠的子系统中构建可靠的连续系统。这是简单的数学。</p><p>  But in fact, the build process had plenty of redundancy within. It’s just I had to manage it manually.</p><p>  但实际上，构建过程有很多冗余。这只是我必须手动管理它。</p><p>  When CMake 17 didn’t work, I tried 18. When clang 10 wasn’t enough, I installed clang 11. When CUDA 11 requested an std=c++17 option, I added this option. This variability made the build possible both mathematically and practically.</p><p>  当CMake 17没工作时，我尝试了18.当Clang 10不够时，我安装了Cuda 11.当CUDA 11要求STD = C ++ 17选项时，我添加了此选项。这种可变性在数学和实际情况下使构建成为可能。</p><p>  Come to think about it, this is just insane. You don’t need a person to switch connectors in a nuclear core. In fact, you don’t want this person there. And the person doesn’t want to be there. So electrical engineers found a way to automate this. But we, software engineers, who should be ahead in any possible automation, are still switching subsystems manually.</p><p>  来思考它，这只是疯了。您不需要一个人在核心内切换连接器。事实上，你不希望这个人在那里。而这个人不想在那里。所以电气工程师发现了一种自动化的方法。但是，我们，应该在任何可能的自动化中领先的软件工程师仍在手动切换子系统。</p><p>  We can, of course, introduce redundancy to our systems as well. But this will require a shift in perception. We would have to admit that software is just as fault-prone as hardware. A build can eat up your disk space, a package can be unavailable because of network issues, even a  compiler can miscompile.</p><p>  当然，我们也可以向我们的系统引入冗余。但这需要对感知的转变。我们必须承认，软件就像容易出现故障。一个构建可以吃掉你的磁盘空间，由于网络问题，一个包可能无法使用，甚至一个编译器可以误解。</p><p>     Programs are just as faulty as resistors and capacitors. It’s just a matter of scale. Sure,  prnit &#34;hello world&#34; is reliable enough. But  one defect per every two thousand lines of code is the industry norm these days. Software subsystems are evidently fault-prone.</p><p>     程序与电阻器和电容器一样有故障。这只是一个规模问题。当然，prnit＆＃34;你好世界＆＃34;是可靠的。但是每两条缺陷每两条代码都是这些日子的行业规范。软件子系统显然是容易发生的。</p><p>    In safety-critical applications, every component is considered faulty. And if you acknowledge faulty components, you have no other option but to think of a way to juggle them for the best possible outcome. Redundancy is not a silver bullet, but it makes building a reliable system out of unreliable components possible.</p><p>    在安全关键应用中，每个组件都被视为错误。如果您承认有问题的组件，则无法以其他选项，但要考虑以获得最佳结果的方式拼凑它们。冗余不是银弹，但它使得可以从不可靠的部件中建立可靠的系统。 </p><p>  If we want to build reliable systems, if we even want to start considering reliability, first we have to acknowledge that our components aren&#39;t reliable.</p><p>如果我们想建立可靠的系统，如果我们愿意开始考虑可靠性，首先我们必须承认我们的组件aren＆＃39; t可靠。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wordsandbuttons.online/redundant_stories_about_redundancy.html">https://wordsandbuttons.online/redundant_stories_about_redundancy.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/故事/">#故事</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/stories/">#stories</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>