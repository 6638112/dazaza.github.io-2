<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>《乱叫：端到端加密的毛茸茸指南》</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">《乱叫：端到端加密的毛茸茸指南》</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-15 09:56:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/134065637c1ffaca95df51ea14c9ecc5.png"><img src="http://img2.diglog.com/img/2020/11/134065637c1ffaca95df51ea14c9ecc5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Between the  U.S. Senate’s “EARN IT” Act, the  E.U.’s slew of anti-encryption proposals, and  Australia’s new anti-encryption law, it’s become clear that the authoritarians in office view online privacy as a threat to their existence.</p><p>在美国参议院的“赚取IT”法案，欧盟的一系列反加密提案，以及澳大利亚新的反加密法律之间，很明显，办公室里的威权主义者将网络隐私视为对他们生存的威胁。</p><p> Normally, when the governments increase their anti-privacy sabre-rattling, technologists start talking more loudly about Tor, Signal, and other privacy technologies (usually only to be drowned out by paranoid people who think Tor and Signal are government backdoors or something stupid; conspiracy theories ruin everything!).</p><p>通常，当政府加大反隐私威吓力度时，技术专家们开始更大声地谈论Tor、Signal和其他隐私技术(通常只会被偏执狂淹没，他们认为Tor和Signal是政府的后门或什么愚蠢的东西；阴谋论毁了一切！)。</p><p>  Instead, I’m going to show you how to add end-to-end encryption to any communication software you’re developing. (Hopefully, I’ll avoid making  any bizarre design decisions along the way.)</p><p>相反，我将向您展示如何为您正在开发的任何通信软件添加端到端加密。(希望在此过程中，我将避免做出任何奇怪的设计决定。)。</p><p>  Yes, you should absolutely do this. I don’t care how banal your thing is; if you expect people to use it to communicate with each other, you should make it so that you can never decrypt their communications.</p><p>是的，你绝对应该这么做。我不管你的东西有多平庸；如果你希望人们用它来相互交流，你应该让它永远不能解密他们的通信。</p><p> You should absolutely NOT bill the thing you’re developing as an  alternative to Signal or WhatsApp.</p><p>你绝对不应该把你正在开发的东西标榜为Signal或WhatsApp的替代品。</p><p> The goal of doing this is to increase the amount of end-to-end encryption deployed on the Internet that the service operator cannot decrypt (even if compelled by court order) and make E2EE normalized. The goal is NOT to compete with highly specialized and peer-reviewed privacy technology.</p><p>这样做的目的是增加部署在互联网上的端到端加密量，服务运营商无法解密(即使是法院命令强制)，并使E2EE正常化。我们的目标不是与高度专业化和经过同行评审的隐私技术竞争。</p><p> I am not a lawyer, I’m some furry who works in cryptography. The contents of this blog post is not legal advice, nor is it endorsed by any company or organization. Ask the  EFF for legal questions.</p><p>我不是律师，我是从事密码学工作的毛茸茸的人。这篇博文的内容不是法律咨询，也没有得到任何公司或组织的认可。向EFF询问法律问题。</p><p>  You don’t have to implement the full stack of solutions to protect users, but the further you can afford to go, the safer your users will be from privacy-invasive policing.</p><p>你不必实施全套解决方案来保护用户，但你能走得越远，你的用户就越安全，不会受到侵犯隐私的监管。</p><p>    In the examples contained on this page, I will be using the  Sodium cryptography library. Specifically, my example code will be written with the  Sodium-Plus library for JavaScript, since it strikes a good balance between performance and being cross-platform.</p><p>在本页包含的示例中，我将使用钠密码库。具体地说，我的示例代码将使用用于JavaScript的Sodium-Plus库编写，因为它在性能和跨平台之间取得了很好的平衡。</p><p> const { SodiumPlus } = require(&#39;sodium-plus&#39;);(async function() { // Select a backend automatically const sodium = await SodiumPlus.auto(); // Do other stuff here})();</p><p>Const{SodiumPlus}=Required(&#39；Na-plus&#39；)；(Async Function(){//自动选择后端const钠=等待SodiumPlus.auto()；//在此执行其他操作})()；</p><p> Libsodium is  generally the correct choice for developing cryptography features in software, and is available in most programming languages,</p><p>LibNa通常是在软件中开发密码功能的正确选择，并且在大多数编程语言中都可用，</p><p> If you’re prone to choose a different library, you should consult your cryptographer (and yes, you should have one on your payroll if you’re doing things different) about your design choices.</p><p>如果你倾向于选择不同的库，你应该咨询你的密码学家(是的，如果你在做不同的事情，你应该在你的工资单上有一个)关于你的设计选择。</p><p>  Remember above when I said, “You don’t have to implement the full stack of solutions to protect users, but the further you can afford to go, the safer your users will be from privacy-invasive policing”?</p><p>还记得上面我说过的话吗？“你不必实施一整套的解决方案来保护用户，但你能负担得起的程度越高，你的用户就能越安全地免受侵犯隐私的监控”。</p><p> How far you go in implementing the steps outlined on this blog post should be informed by  a threat model, not an ad hoc judgment.</p><p>你在实施这篇博客文章中概述的步骤方面走了多远，应该通过威胁模型来告知，而不是临时判断。</p><p> For example, if you’re encrypting user data and storing it in the cloud, you probably want to pass  the Mud Puddle Test:</p><p>例如，如果您正在加密用户数据并将其存储在云中，则可能需要通过泥坑测试：</p><p> 1. First, drop your device(s) in a mud puddle. 2. Next, slip in said puddle and crack yourself on the head. When you regain consciousness you’ll be perfectly fine, but  won’t for the life of you be able to recall your device passwords or keys. 3. Now try to get your cloud data back.  Did you succeed? If so, you’re screwed. Or to be a bit less dramatic, I should say: your cloud provider has access to your ‘encrypted’ data, as does the government if they want it, as does any rogue employee who knows their way around your provider’s internal policy checks.</p><p>1.首先，把你的设备扔进泥坑。2.下一步，滑进水坑，砸自己的头。当你恢复意识时，你会完全好起来，但你的一生都不会回忆起你的设备密码或钥匙。3.现在试着找回你的云数据。你成功了吗？如果是这样的话，你就完了。或者说得不那么戏剧化，我应该说：你的云提供商可以访问你的加密数据，如果政府想要的话，政府也可以访问，任何知道如何绕过你的云提供商的内部政策检查的流氓员工都可以这样做。</p><p> Matthew Green describes the Mud Puddle Test, which Apple products  definitely don’t pass.</p><p>马修·格林(Matthew Green)描述了“泥坑测试”(Mud Puddle Test)，苹果产品肯定无法通过这一测试。</p><p> If you must fail the Mud Puddle Test for your users, make sure you’re clear and transparent about this in the documentation for your product or service.</p><p>如果您必须为您的用户通过泥坑测试，请确保您在产品或服务的文档中明确和透明地说明了这一点。</p><p>   The easiest piece of this puzzle is to encrypt data in transit between both ends (thus, satisfying the loosest definition of end-to-end encryption).</p><p>这个难题中最简单的一块是加密两端之间传输的数据(因此，满足端到端加密的最宽松定义)。</p><p> At this layer, you already have some kind of symmetric key to use for encrypting data before you send it, and for decrypting it as you receive it.</p><p>在这一层，您已经有某种对称密钥可用于在发送数据之前对其进行加密，以及在接收数据时对其进行解密。</p><p> For example, the following code will encrypt/decrypt strings and return hexadecimal strings with a version prefix.</p><p>例如，下面的代码将加密/解密字符串，并返回带有版本前缀的十六进制字符串。</p><p>  Under-the-hood, this is using  XChaCha20-Poly1305, which is less sensitive to timing leaks than AES-GCM. However, like AES-GCM, this encryption mode doesn’t provide  message- or key-commitment.</p><p>实际上，它使用的是XChaCha20-Poly1305，与AES-GCM相比，XChaCha20-Poly1305对定时泄漏的敏感度较低。然而，与AES-GCM一样，这种加密模式不提供消息或密钥承诺。</p><p> If you want message or key commitment, you should derive two keys from  $key using a KDF based on hash functions: One for actual encryption, and the other  as a key commitment value.</p><p>如果您想要消息或密钥提交，则应该使用基于散列函数的KDF从$key派生两个密钥：一个用于实际加密，另一个作为密钥承诺值。</p><p>   Another design choice you might make is to encode ciphertext with base64 instead of hexadecimal. That doesn’t significantly alter the design here, but it does mean your decoding logic has to accommodate this.</p><p>您可能会做出的另一个设计选择是使用Base64而不是十六进制对密文进行编码。这并不会显著改变这里的设计，但它确实意味着您的解码逻辑必须适应这一点。</p><p> You SHOULD version your ciphertexts, and include this in the AAD provided to your AEAD encryption mode. I used “v1” and “v2” as a version string above, but you can use your software name for that too.</p><p>您应该对密文进行版本化，并将其包含在提供给您的AEAD加密模式的AAD中。我在上面使用了“v1”和“v2”作为版本字符串，但您也可以使用您的软件名称。</p><p>  If you’re not familiar with  Elliptic Curve Diffie-Hellman or  Authenticated Key Exhcanges, the two of the earliest posts on this blog were dedicated to those topics.</p><p>如果你不熟悉Elliptic Curve Diffie-Hellman或认证的Key Exhcanges，这个博客上最早的两篇文章就是关于这些主题的。</p><p>  There are many schools of thought for extending ECDH into an authenticated key exchange protocol.</p><p>对于将ECDH扩展为认证密钥交换协议，有许多流派的思想。</p><p> We’re going to implement what the Signal Protocol calls  X3DH instead of doing some interactive EdDSA + ECDH hybrid, because X3DH provides cryptographic  deniability (see  this section of the X3DH specification for more information).</p><p>我们将实现信号协议所称的X3DH，而不是进行某种交互式EdDSA+ECDH混合，因为X3DH提供了密码可否认性(有关更多信息，请参阅X3DH规范的这一节)。</p><p> For the moment, I’m going to assume a client-server model. That may or may not be appropriate for your design. You can substitute “the server” for “the other participant” in a peer-to-peer configuration.</p><p>目前，我将采用客户端-服务器模型。这可能适合也可能不适合您的设计。在对等配置中，您可以用“服务器”代替“其他参与者”。</p><p>   Each participant will need to upload an Ed25519 identity key once (which is a detail covered in another section), which will be used to sign bundles of X25519 public keys to use for X3DH.</p><p>每位参与者需要上传一次Ed25519身份密钥(这一细节将在另一节中介绍)，该密钥将用于签署X25519公钥捆绑包，以用于X3DH。</p><p>      In accordance to Signal’s X3DH spec, you want to use  x3dh_pre_key(secretKey, 1) to generate the “signed pre-key” bundle and  x3dn_pre_key(secretKey, 100) when pushing 100 one-time keys to the server.</p><p>根据Signal的X3DH规范，在向服务器推送100个一次性密钥时，需要使用x3dh_pre_key(SecretKey，1)来生成“签名的预密钥”包，并使用x3dn_pre_key(SecretKey，100)。</p><p>    (If any remain unburned) One of your key’s One-Time Keys (an X25519 public key) — and then delete it</p><p>(如果有未烧录的)密钥的一次性密钥之一(X25519公钥)-然后将其删除</p><p>             We abstracted some of the details away (i.e.  kdf(), the transport mechanisms, the session key management mechanisms, and a few others). Some of them will be highly specific to your application, so it doesn’t make a ton of sense to flesh them out.</p><p>我们抽象了一些细节(即KDF()、传输机制、会话密钥管理机制等)。其中一些将高度特定于您的应用程序，因此充实它们没有多大意义。</p><p> One thing to keep in mind: According to the X3DH specification, participants should regularly (e.g. weekly) replace their Signed Pre-Key in the server with a fresh one. They should also publish more One-Time Keys when they start to run low.</p><p>需要记住的一件事：根据X3DH规范，参与者应该定期(例如每周)将他们在服务器中签名的预密钥更换为新的密钥。当它们开始耗尽时，它们还应该发布更多的一次性密钥。</p><p>  Using X3DH to for every message is inefficient and unnecessary. Even the Signal Protocol doesn’t do that.</p><p>使用X3DH来处理每条消息是低效且没有必要的。即使是信号协议也不能做到这一点。</p><p> Instead, Signal  specifies a Double Ratchet protocol that combines a Symmetric-Key Ratchet on subsequent messages, and a Diffie-Hellman-based ratcheting protocol.</p><p>相反，Signal指定了双棘轮协议，该协议结合了后续消息上的对称密钥棘轮和基于Diffie-Hellman的棘轮协议。</p><p>  It’s worth reading through the specification to understand their usages of Key-Derivation Functions (KDFs) and KDF Chains.</p><p>有必要通读该规范以了解它们对密钥派生函数(KDF)和KDF链的用法。</p><p> Although it is recommended to use HKDF as the Signal protocol specifies, you can  strictly speaking use any secure keyed PRF to accomplish the same goal.</p><p>虽然建议使用HKDF作为信号协议的指定，但严格地说，您可以使用任何安全密钥PRF来实现相同的目标。</p><p> What follows is an example of a symmetric KDF chain that uses BLAKE2b with 512-bit digests of the current session key; the leftmost half of the BLAKE2b digest becomes the new session key, while the rightmost half becomes the encryption key.</p><p>下面是一个对称KDF链的示例，它使用具有512位当前会话密钥摘要的BLAKE2b；BLAKE2b摘要的最左半部分成为新的会话密钥，而最右半部分成为加密密钥。</p><p>  In the interest of time, a full DHRatchet implementation is left as an exercise to the reader (since it’s mostly a state machine), but using the appropriate functions provided by sodium-plus ( crypto_box_keypair(),  crypto_scalarmult()) should be relatively straightforward.</p><p>为了节省时间，完整的DHRatchet实现留给读者作为练习(因为它主要是一个状态机)，但是使用钠加(crypto_box_keypair()，crypto_scalarmult())提供的适当函数应该相对简单。</p><p>   The Signal Protocol specified X3DH and the Double Ratchet for securely encrypting information between two parties.</p><p>信令协议规定了X3DH和双棘轮，用于安全地加密双方之间的信息。</p><p> Group conversations are trickier, because you have to be able to encrypt information that multiple recipients can decrypt, add/remove participants to the conversation, etc.</p><p>群组对话比较棘手，因为您必须能够加密多个收件人可以解密的信息、添加/删除对话参与者等。</p><p>  The best design I’ve read to date for tackling group key agreement is the  IETF Messaging Layer Security RFC draft.</p><p>到目前为止，我读到的处理组密钥协议的最佳设计是IETF Messaging Layer Security RFC草案。</p><p> I am not going to implement the entire MLS RFC in this blog post. If you want to support multiple devices or group conversations, you’ll want a complete MLS implementation to work with.</p><p>在这篇博客文章中，我不打算实现整个MLS RFC。如果你想支持多个设备或组对话，你需要一个完整的MLS实现来使用。</p><p>  That was a lot of ground to cover, but we’re not done yet.</p><p>这是一个很大的领域，但我们还没有完成。</p><p>  So far we’ve tackled encryption, initial key agreement, and session key management. However, we did not flesh out how Identity Keys (which are signing keys–Ed25519 specifically–rather than Diffie-Hellman keys) are managed. That detail was just sorta hand-waved until now.</p><p>到目前为止，我们已经解决了加密、初始密钥协议和会话密钥管理问题。然而，我们没有详细说明身份密钥(具体是签名密钥-Ed25519，而不是Diffie-Hellman密钥)是如何管理的。到目前为止，这一细节只是在某种程度上挥舞着手。</p><p>   There’s a meme among technology bloggers to write a post titled “Falsehoods Programmers Believe About _____”.</p><p>在科技博客中有一种米姆(Meme)写了一篇题为“程序员相信的谎言_”的帖子。</p><p> Fortunately for us, Identity is one of the topics that furries are positioned to understand better than most (due to fursonas): Identities have a many-to-many relationship with Humans.</p><p>对我们来说幸运的是，身份是毛茸茸比大多数人更好理解的主题之一(由于Fursonas)：身份与人类有多对多的关系。</p><p> In an end-to-end encryption protocol, each identity will consist of some identifier (phone number, email address, username and server hostname, etc.) and an Ed25519 keypair (for which the public key will be published).</p><p>在端到端加密协议中，每个身份将由一些标识符(电话号码、电子邮件地址、用户名和服务器主机名等)组成。以及Ed25519密钥对(将为其发布公钥)。</p><p> But how do you know whether or not a given public key is correct for a given identity?</p><p>但是，如何知道给定的公钥对于给定的身份是否正确呢？</p><p>  This is where we segue into one of the hard problems in cryptography, where the solutions available are entirely dependent on your threat model:  Public Key Infrastructure (PKI).</p><p>这就是我们进入密码学中的一个难题的地方，其中可用的解决方案完全依赖于您的威胁模型：公钥基础设施(PKI)。</p><p>  Key Transparency / Certificate Transparency (CT) — TLS  also does this for ensuring CA-issued certificates are auditable (although it was originally meant to replace Certificate Authorities)</p><p>密钥透明度/证书透明度(CT)-TLS还可以确保CA颁发的证书是可审核的(尽管它最初的目的是取代证书颁发机构)。</p><p> And you can sort of choose-your-own-adventure on this one, depending on what’s most appropriate for the type of software you’re building and who your customers are.</p><p>在这一点上，你可以选择自己的冒险，这取决于你正在构建的软件类型和你的客户是谁，什么才是最合适的。</p><p> One design I’m particularly fond of is called  Gossamer, which is a PKI design without Certificate Authorities, originally designed for making WordPress’s automatic updates more secure (i.e. so every developer can sign their theme and plugin updates).</p><p>我特别喜欢的一种设计叫做Gossamer，这是一种没有证书颁发机构的PKI设计，最初是为了让WordPress的自动更新更安全(即每个开发人员都可以在他们的主题和插件更新上签名)。</p><p> Since we only need to maintain an up-to-date repository of Ed25519 identity keys for each participant in our end-to-end encryption protocol, this makes Gossamer a suitable starting point.</p><p>由于我们只需要为我们的端到端加密协议中的每个参与者维护一个最新的Ed25519身份密钥库，这使得Gossamer成为一个合适的起点。</p><p> Gossamer specifies a limited grammar of  Actions that can be performed:  AppendKey,  RevokeKey,  AppendUpdate,  RevokeUpdate, and  AttestUpdate. These actions are signed and published to an append-only cryptographic ledger.</p><p>Gossamer指定了可以执行的操作的有限语法：AppendKey、RevokeKey、AppendUpdate、RevokeUpdate和AttestUpdate。这些操作被签署并发布到仅附加的加密分类帐。</p><p> I would propose a sixth action:  AttestKey, so you can have WoT-like assurances and  key-signing parties. (If nothing else, you should be able to attest that the identity keys of other cryptographic ledgers in the network are authentic at a point in time.)</p><p>我建议执行第六个操作：AttestKey，这样您就可以拥有类似WoT的保证和密钥签名方。(如果没有其他问题，您应该能够证明网络中其他加密分类帐的身份密钥在某个时间点是可信的。)。</p><p>  In the previous section, I proposed the use of Gossamer as a PKI for Identity Keys. This would provide Ed25519 keypairs for use with X3DH and the Double Ratchet, which would in turn provide session keys to use for symmetric authenticated encryption.</p><p>在上一节中，我建议使用Gossamer作为身份密钥的PKI。这将提供与X3DH和双棘轮一起使用的Ed25519密钥对，该密钥对又将提供用于对称认证加密的会话密钥。</p><p> If you’ve implemented everything preceding this section, you have a full-stack end-to-end encryption protocol. But let’s make intelligence agencies and surveillance capitalists even more mad by making it impractical to backdoor our software (and impossible to  silently backdoor it).</p><p>如果您已经实现了本小节之前的所有内容，那么您就拥有了一个全栈的端到端加密协议。但是，让我们让情报机构和监视资本家变得更加疯狂，让我们的软件后门变得不切实际(而且不可能悄悄地后门)。</p><p>   For us, the implementation is simple: Use Gossamer as it was originally intended (i.e. to secure your software distribution channels).</p><p>对我们来说，实现很简单：按照最初的目的使用Gossamer(即保护您的软件分发渠道)。</p><p> Gossamer provides up-to-date verification keys and a commitment to a cryptographic ledger of every software update. You can learn more about its inspiration  here.</p><p>Gossamer提供最新的验证密钥，并承诺提供每个软件更新的加密分类账。你可以在这里了解更多关于它的灵感。</p><p> It isn’t enough to merely use Gossamer to manage keys and update signatures. You need independent third parties to use the  AttestUpdate action to assert one or more of the following:</p><p>仅仅使用Gossamer来管理密钥和更新签名是不够的。您需要独立的第三方才能使用AttestUpdate操作来断言以下一项或多项内容：</p><p> That they have reviewed the source code and found no evidence of backdoors or exploitable vulnerabilities.</p><p>他们审查了源代码，没有发现后门或可利用漏洞的证据。</p><p> (And then you should let your users decide which of these independent third parties they trust to vet software updates.)</p><p>(然后，您应该让您的用户决定他们信任哪些独立的第三方来审查软件更新。)</p><p>  The U.S. Government cries and moans a lot about “criminals going dark” and wonders a lot about how to solve the “going dark problem”.</p><p>美国政府对“罪犯蒙在鼓里”叫苦连天，对如何解决“蒙在鼓里的问题”感到疑惑不已。</p><p> If more software developers implement end-to-end encryption in their communications software, then maybe one day they won’t be able to use dragnet surveillance to spy on citizens and they’ll be forced to do actual detective work to solve actual crimes.</p><p>如果更多的软件开发商在他们的通信软件中实现端到端加密，那么也许有一天他们将无法使用拉网式监视来监视公民，他们将被迫进行实际的侦察工作，以解决实际的犯罪问题。</p><p>   Let’s collectively tell the intelligence community in every sophisticated nation state the one word they don’t hear often enough:</p><p>让我们一起告诉每个先进民族国家的情报界，他们不经常听到的一个词：</p><p>     That’s one of the major reasons why the thing we’re building isn’t meant to compete with Signal (and it MUST NOT be advertised as such):</p><p>这就是为什么我们正在建设的东西不打算与Signal竞争的主要原因之一(也不能这样宣传)：</p><p> Signal is a privacy tool, and their servers have no way of identifying who can contact who.</p><p>Signal是一个隐私工具，他们的服务器无法识别谁可以联系谁。</p><p> What we’ve built here isn’t a complete privacy solution, it’s only providing end-to-end encryption (and possibly making NSA employees cry at their desk).</p><p>我们在这里建立的并不是一个完整的隐私解决方案，它只是提供端到端的加密(可能会让NSA的员工在办公桌前哭泣)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://soatok.blog/2020/11/14/going-bark-a-furrys-guide-to-end-to-end-encryption/">https://soatok.blog/2020/11/14/going-bark-a-furrys-guide-to-end-to-end-encryption/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/乱叫/">#乱叫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/furry/">#furry</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/密钥/">#密钥</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>