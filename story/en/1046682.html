<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>星期五的事实＃364 – 1.1稳定 Factorio Friday Facts #364 – 1.1 stable</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Factorio Friday Facts #364 – 1.1 stable<br/>星期五的事实＃364 – 1.1稳定 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 20:49:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/09b61099548dd49eef55a6f316ab2793.png"><img src="http://img2.diglog.com/img/2021/1/09b61099548dd49eef55a6f316ab2793.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When we were releasing the  1.0 FFF-360, we actually stated that there were  &#34;around 150 bugs on the forums and around 80 internal tasks to be solved&#34;. These were obviously minor issues, things hard to reproduce or very rare problems. In other words, it was quite reasonably stable, which normally goes without saying when it comes to Factorio stable versions. But it proved to be a mistake wording it this way, since some media picked up on it and presented it as a &#34;fairly bugged release&#34;.</p><p>当我们发布1.0 FFF-360时，实际上是说论坛上有大约150个错误，还有大约80个要解决的内部任务。这些显然是次要问题，难以重现的问题或非常罕见的问题。换句话说，它相当稳定，在谈到Factorio稳定版本时通常不用说。但这被证明是一种错误的措辞，因为一些媒体对此予以了表述，并把它表示为“有错误的发行版”。</p><p>  So I&#39;m pretty thrilled to finally get to the point, where we actually have 0 known issues and 0 active bug reports on the forums. Its like cleaning the kitchen properly, so you can start cooking something fresh. More about that next week!</p><p>  因此，我很高兴最终到达这一点，我们在论坛上实际上有0个已知问题和0个活动的错误报告。这就像正确清洁厨房一样，因此您可以开始烹饪新鲜的东西。关于下周的更多信息！</p><p>  For now, we want to go over some of the features of the 1.1 that you might have missed until now if you&#39;ve been sticking with stable 1.0.</p><p>  现在，如果您坚持使用稳定的1.0，我们想复习一下您可能会错过的1.1的某些功能。</p><p>      It was requested a lot over the years, and we always said no. The reason being, well not everything can flip, things like oil recipes, rail signals, pumpjacks etc. Due to these asymmetries, if you flipped a blueprint with these entities, the result would be non-functional in the best case, and cause complete chaos in others.</p><p>      多年来，人们对此提出了很多要求，我们一直拒绝。原因是，并非所有事物都能翻转，例如油配方，铁路信号，泵站等。由于这些不对称性，如果翻转这些实体的设计图，结果在最佳情况下将无法正常工作并导致故障。在别人的混乱。</p><p>  But then kovarex was playing and  really really wanted to just copy and flip his train unloading setup (just your typical Inserters, chests, and belts). So he decided to just add it, and prevented the flip problems by just disallowing flipping blueprints that wouldn&#39;t flip properly.</p><p>  但是后来kovarex玩了，真的很想复制并翻转他的火车卸载设置（仅是典型的插入器，箱子和皮带）。因此，他决定只添加它，并通过不允许翻转不会正确翻转的蓝图来避免翻转问题。</p><p>        We added a few last minute nice to have features to the Spiders for 1.1. This is in addition to the things we demonstrated in  FFF-362.</p><p>        我们在最后一刻增加了一些功能，以便在Spiders 1.1中具有功能。这是我们在FFF-362中演示的内容的补充。</p><p>    It was super frustrating trying to navigate our quite watery playtesting map with the spiders. They would always get caught on the edge of some lake. Queuing move commands seemed like a pretty obvious fix, and it wasn&#39;t much work in the end.</p><p>    试图用蜘蛛浏览我们相当潮湿的游戏测试地图实在令人沮丧。他们总是会被某个湖边困住。排队移动命令似乎是一个很明显的解决方法，最后并没有太多工作。 </p><p>      Another frustration was trying to control multiple spiders in combat. The remote works fine for a handful of spiders, but once you get into the double digits, managing the spider remotes and spiders was just a hassle.</p><p>另一个挫败感是试图在战斗中控制多只蜘蛛。遥控器对于少数蜘蛛工作正常，但是一旦您达到两位数，管理蜘蛛遥控器和蜘蛛就很麻烦了。</p><p>  So alongside the waypoints, kovarex added the feature of letting spiders follow entities... and even other spiders...</p><p>  因此，除了航路点外，kovarex还添加了让蜘蛛跟随实体...甚至其他蜘蛛...的功能。</p><p>        With the Lane locked belt building added in 1.1.0, there was some wonky/undefined behavior related to rotating the belt while building.</p><p>        在1.1.0中添加了带锁的安全带建筑后，在构建建筑时会发生一些与旋转安全带有关的不明/不确定行为。</p><p>  So we fixed the bug by extending the feature set of belt building, with the new &#39;Smart belt building&#39;.</p><p>  因此，我们通过使用新的＆＃39; Smart Belt building＆＃39;扩展了皮带构建的功能集来修复了该错误。</p><p>    And with a great feature, we give ourselves the oppourtunity to do a little feature creep. So we added the anti-frustration feature of the automatic underground belt traversal.</p><p>    有了出色的功能，我们就有机会进行小小的功能爬行。因此，我们增加了自动穿越地下带的抗挫折功能。</p><p>        In the constant battle with the optimizations to let players build bigger bases, quite often we do small changes that give performance gains in the range of 1-2%. Recently I started looking into the possibility of multithreading the transport belt logic. This is one of the more significant performance drains and it is still being done single threaded, resulting in a huge potential performance gain.</p><p>        在不断进行优化以让玩家建立更大的基础方面，我们经常进行一些小的更改，以使性能提高1-2％。最近，我开始研究对传输带逻辑进行多线程处理的可能性。这是更重要的性能消耗之一，并且仍在单线程中完成，从而带来了巨大的潜在性能提升。</p><p>  Transport belts were already quite optimized ( FFF-176). One could simply say &#34;make it multithreaded&#34; but there are a lot of technical challenges to solve before this is even possible in order to not cause any issues when running in multiplayer. Basically, to ensure it will still be deterministic.</p><p>  运输带已经进行了非常优化（FFF-176）。可以简单地说＆＃34;使其成为多线程＆＃34;但是要想在多人游戏中运行时不会引起任何问题，甚至还需要解决许多技术难题。基本上，确保它仍然是确定性的。 </p><p>    Trying to do naive multi-threading with all the transport lines being updated at the same time doesn&#39;t work. In  Fig. 1: depending on which transport line would be updated first, the copper plate could land before or after the iron plate. This could be fixed by using all sorts of synchronization primitives, but using them would increase the complexity of the code to the point where nobody would want to maintain it, and mainly it would not guarantee the code would be faster or would not desync.</p><p>尝试在同时更新所有传输线的情况下执行朴素的多线程操作是行不通的。在图1中：根据首先更新哪条运输线，铜板可以在铁板之前或之后着陆。可以通过使用各种同步原语来解决此问题，但是使用它们会增加代码的复杂性，以至于没人愿意维护它，并且主要是不能保证代码会更快或不会取消同步。</p><p>    After some observations I noticed a trivial fact: not all transport lines can interact with each other.</p><p>    经过一些观察，我注意到了一个琐碎的事实：并非所有传输线都可以相互影响。</p><p>    In  Fig. 2, the left transport line on the horizontal belts can never receive items from the right line of the horizontal belts or any items from the side-loading. This gave me a simple nice idea. We can group transport lines in a way, that lines from one group don&#39;t interact with any line from any other group. This means, we can avoid all the synchronization logic between transport lines. When one thread updates one group, other groups can be updated by other threads independently at the same time.</p><p>    在图2中，水平皮带的左输送线永远不会从水平皮带的右线接收任何物品，也不会接收任何来自侧面装载的物品。这给了我一个简单的好主意。我们可以以某种方式对传输线进行分组，即一组中的线不会与任何其他组中的任何线交互。这意味着，我们可以避免传输线之间的所有同步逻辑。当一个线程更新一组时，其他线程可以同时独立地更新其他组。</p><p>  Each color is a different group of transport lines. Each group is updated in parallel.</p><p>  每种颜色都是不同的传输线组。每个组并行更新。</p><p>  Maintaining those groups in itself was a challenge: when a player builds or rotates a transport belt, underground belt, or splitter, transport lines will change their connections and some groups may now be connected, and they need to be merged. The opposite is also true: the player is able to remove some connections making the group contain multiple components which can be extracted to separate groups. While groups merging has to be done immediately (having multiple groups being able to interact with each other would create race conditions), splitting does not.</p><p>  维持这些组本身是一个挑战：当玩家建造或旋转运输带，地下带或分割器时，运输线将改变它们的连接，并且某些组现在可能已连接，并且需要合并。反之亦然：播放器能够删除一些连接，从而使该组包含可以提取到单独组中的多个组件。尽管必须立即进行组合并（使多个组能够相互交互会产生竞争条件），但拆分并不需要。</p><p>    By far the largest issue we faced was that the transport lines aren&#39;t entirely independent. We have a sleep/wakeup mechanism in the game since version 0.9 and it goes like this: Inserters taking from belts may become inactive when there is nothing happening on both transport lines to save UPS. An inactive inserter would be stuck on its own in that position if there would not be any way to wake it up. In this case, the Inserter registers on the transport lines so that when a new item comes to it, it can be woken up to check if it needs to pick up any items.</p><p>    到目前为止，我们面临的最大问题是运输线不是完全独立的。从0.9版本开始，我们就在游戏中提供了一种睡眠/唤醒机制，它的样子是这样的：当两条传输线上都没有任何东西可以保存UPS时，从传送带上取走的插入器可能变得不活动。如果没有任何方法可以将不活动的插入器卡在该位置上。在这种情况下，插入器会在传输线上进行注册，以便在有新物品进入时可以将其唤醒以检查是否需要拾取任何物品。</p><p>    Since the 2 transport lines going through a single belt can belong to different groups, those groups are not independent because both could try to wakeup/put to sleep the same inserter. In that case, the inserter becomes the shared state for both groups and has to be properly dealt with. Transport lines cannot simply wakeup that inserter, because it could be woken up by another thread, and activation order is important as it also defines the order in which Inserters will be updated. If Inserters would activate in a different order, desyncs would happen.</p><p>    由于通过一条传送带的两条传输线可以属于不同的组，所以这些组不是独立的，因为它们都可能试图唤醒/使同一个插入器进入睡眠状态。在这种情况下，插入程序将成为两个组的共享状态，必须正确处理。传输线不能简单地唤醒该插入器，因为它可能被另一个线程唤醒，并且激活顺序很重要，因为它还定义了更新插入器的顺序。如果插入器将以其他顺序激活，则会发生不同步。 </p><p>  To solve this, when working, the threads don&#39;t wake the entities immediately, but instead add the wakeup requests to a list to be processed later. After all threads are done, the main thread collects and merges all those requests, and wakes up the entities in a deterministic way based on the group update order number.</p><p>为了解决这个问题，线程在工作时不会立即唤醒实体，而是将唤醒请求添加到列表中以供以后处理。完成所有线程后，主线程将收集并合并所有这些请求，并根据组更新顺序号以确定的方式唤醒实体。</p><p>  With the wakeup lists and other similar cases handled properly, I started comparing some belt based megabases which are capable of producing 10k science per minute and I noticed that transport belt update times dropped from 4ms to 1.6ms which in total update time gives between 20 to 40% overall performance gain.</p><p>  在唤醒列表和其他类似情况得到正确处理的情况下，我开始比较一些基于皮带的巨型数据库，这些巨型数据库每分钟可产生10k科学数据，我注意到传送带更新时间从4ms降低到1.6ms，总更新时间为20至整体性能提升40％。</p><p>        The original Trains GUI was added in 0.13, and only had cosmetic changes all the way to 1.1.0.</p><p>        原始的Trains GUI在0.13中添加，并且仅在外观上一直进行了更改，直到1.1.0。</p><p>      At the time it was a big step forward, as there was no other good way of interacting with trains. For instance you couldn&#39;t open them from the map view, there wasn&#39;t even zoom to world, and the Locomotive GUI was very limited.</p><p>      当时这是向前迈出的一大步，因为没有其他与火车互动的好方法。例如，您无法从地图视图中打开它们，甚至无法缩放到世界，并且机车GUI非常有限。</p><p>  During the old days, the mindset was, that the players would have just a few trains or 10-20 max in an extreme case, so we didn&#39;t really see a need to categorize them much.</p><p>  在过去，人们的心态是，在极端情况下，玩家只有几列火车或最多10-20列火车，因此我们并没有真正需要对其进行大量分类。</p><p>    With time, the game evolved, factories were growing, and subsequently the number of train kept going up. The insufficiency of the GUI became very clear during our internal 1.1 playtesting. We played for a whole week and extensively used the new train limits. We had over 100 trains and over 200 train stops.</p><p>    随着时间的流逝，游戏不断发展，工厂不断壮大，随后火车的数量不断增加。在我们内部的1.1游戏测试中，GUI的不足之处变得非常明显。我们玩了整整一个星期，并广泛使用了新的火车限制。我们有超过100列火车和200多个车站。</p><p>  Once we finished I asked the rest of the team &#34;Did anybody opened the Trains GUI even once?&#34;. The answer was &#34;No&#34;.</p><p>  完成后，我问了团队的其他成员＆＃34;有人甚至没有打开过Trains GUI吗？＆＃34;。答案是＆＃34;否＆＃34;。 </p><p>  While playtesting I also became highly familiar with what features I  wished the Trains GUI had, and what questions it should answer:</p><p>在进行游戏测试时，我也非常熟悉我希望Trains GUI具有的功能以及它应该回答的问题：</p><p>    I started by making a mockup mod in Lua. It allowed me to quickly iterate on the design and content on the GUI much faster than C++ would have allowed. After 2 days I basically had a finalised design ready. After we reviewed the mockups, we agreed it was a massive improvement, and decided to make it properly. I took it as &#39;Christmas homework&#39; to write the new Train GUI into the engine in C++ (even though programming isn&#39;t much my area of expertise). After the New year, it was ready, so we did the usual QA and released it in 1.1.8.</p><p>    我首先在Lua中制作了一个模型Mod。它使我能够以比C ++更快的速度快速迭代GUI上的设计和内容。 2天后，我基本上完成了最终设计。在审查了模型之后，我们同意这是一个巨大的改进，并决定适当地进行。我把它当作＆＃39;圣诞节作业＆＃39;用C ++将新的Train GUI编写到引擎中（即使编程不是我的专长）。新年过后，它已经准备好了，所以我们进行了常规的质量检查，并在1.1.8中发布了它。</p><p>  There are 2 tabs of the new Trains GUI, and each follows a simple but meaningful design principle: ...and honestly from there it just kinda all fell into place. But let me explain some of the details...</p><p>  新的Trains GUI有两个选项卡，每个选项卡都遵循一个简单但有意义的设计原则： ...从老实说，一切都落到了位。但让我解释一些细节...</p><p>      I would say the most controversial part here is removing the Schedule display under each Train map, and replacing it with the &#39;State description button&#39;. With the schedule displayed on the side, it is almost completely redundant information. The state button provides much more precise and relevant information, you can see which stop it is going to, how far away it is, and also click on the state button to open the map at the specific train stop it is going to.</p><p>      我要说的是，最有争议的部分是删除每张火车地图下的“时刻表”显示，并用“状态描述”按钮替换。时间表显示在侧面，几乎完全是冗余信息。状态按钮提供了更为精确和相关的信息，您可以看到它要去的停靠站，距离有多远，还可以单击状态按钮以在要去的特定火车停靠处打开地图。</p><p>  The nice thing is, that whenever you have some wrong or inconsistent schedule, you can easily notice it in this list.</p><p>  令人高兴的是，只要您的日程安排有误或不一致，您都可以在此列表中轻松注意到它。</p><p>      Since the stations tab is completely new, there are no changes that people can disagree with it. The aim with this tab was to try to present the information about the train limit of each station in some easy to digest way.</p><p>      由于“电台”选项卡是全新的，因此没有任何变化是人们可以不同意的。使用此选项卡的目的是尝试以某种易于理解的方式呈现有关每个车站的火车限制的信息。</p><p>  The remark in the form of  &lt;Reservations&gt;/ &lt;Train limit&gt; describes the station state.When I look at the Dropoff+Pickup station of a single product, I can easily identify 3 basic states: Not enough trains: when the sum of  &lt;Reservations&gt; is too low compared to the sum of the  &lt;Train limits&gt;.</p><p>  以＆lt;预订＆gt; /＆lt;火车限制＆gt;形式的注释被保留。描述工作站状态。当我查看单个产品的Dropoff + Pickup站时，我可以轻松识别3种基本状态： 火车数量不足：＆lt; Reservations＆gt;之和与＆lt; Train limit＆gt;之和相比太低。 </p><p>  Not enough input: when almost all of the trains are in the Pickup waiting to be loaded.</p><p>输入的信息不足：几乎所有的火车都在接机中等待装载。</p><p>  Backed up: when  &lt;Reservation&gt;= &lt;Train limit&gt; in the Dropoff where the trains are waiting to be unloaded.</p><p>  备份：＆lt;预订＆gt; =＆lt;火车限制＆gt;在下车的地方，火车正在等待被卸载。</p><p>      There are many things in Factorio I&#39;ve optimized over the years; runtime performance, startup time, saving, loading, even quit speed. It gets more and more difficult to find anything to improve on without changing game features – which mostly I try to avoid. Autosave time has always been one of those &#34;I wish it could be faster&#34; but never finding anything that stuck out or gave any measurable improvements.</p><p>      多年来，Factorio我进行了很多优化。运行时性能，启动时间，保存，加载，甚至退出速度。在不更改游戏功能的情况下，找到任何需要改进的地方变得越来越困难–我主要试图避免这种情况。自动保存时间一直是其中的一个＆＃34;我希望它可以更快一些＆＃34;但从来没有发现任何突出或可以衡量的改进。</p><p>  Several years ago I parallelized the iterate-the-game and the compress-and-save-to-disk ( FFF-201) however there hasn&#39;t been any major improvements since then. The issue I would always run into was: I could make one of those two processes faster but the other always bottlenecked and so the overall speed didn’t change. Every few months I would go back to it and try to think of new ways to make it faster but always ran into that same issue.</p><p>  几年前，我并行执行了迭代游戏和压缩并保存到磁盘（FFF-201）的操作，但是此后没有任何重大改进。我总是会遇到的问题是：我可以使这两个过程之一更快，但另一个总是瓶颈，因此总体速度不会改变。每隔几个月，我都会重新讨论它，并尝试思考使之更快的新方法，但总是遇到相同的问题。</p><p>    The other week I was doing that again and I wondered just how much faster the save process would be if I could just &#39;pretend&#39; the compress and write to disk didn&#39;t happen. It turned out; a lot. The larger the save got the more time got spent waiting for the compress and write to disk. After thinking for a while I decided to instead of save the map information in one big compressed file, to split it into multiple compressed files. It&#39;s not a new concept but we hadn&#39;t done it before in Factorio. A quick 30 minute implementation later showed that without a lot of changes – it just worked.</p><p>    前一周我又做了一次，我想知道如果我能“假装”那么保存过程会快多少呢？压缩和写入磁盘没有发生。结果是;很多。保存量越大，等待压缩并写入磁盘的时间就越多。经过一会儿的思考，我决定将地图信息分成多个压缩文件，而不是将地图信息保存在一个大的压缩文件中。这不是一个新概念，但我们以前在Factorio中并未做到这一点。经过30分钟的快速实施，结果表明，无需进行太多更改-即可正常工作。</p><p>  The end result meant the compress-and-write-to-disk parallel processing never blocked the main iterate-the-game logic. That alone made the entire save process around 20% faster and as a side result any improvements I made to the main logic gave direct further improvements. In the testing I performed the larger saves saw upwards of 2x improvements to save times.</p><p>  最终结果意味着压缩和写入磁盘并行处理从未阻塞主要的迭代游戏逻辑。仅此一项就使整个保存过程加快了约20％，结果是我对主逻辑所做的任何改进都直接带来了进一步的改进。在测试中，我执行了较大的节省操作，从而节省了2倍以上的时间。</p><p>    Thank you for tuning in, let us know what you think at the usual places.</p><p>    感谢您的收看，让我们知道您在平时的想法。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://factorio.com/blog/post/fff-364">https://factorio.com/blog/post/fff-364</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/星期五/">#星期五</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/friday/">#friday</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>