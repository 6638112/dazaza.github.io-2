<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>突变驱动测试：当TDD不够好时 Mutation Driven Testing: When TDD Just Isn’t Good Enough</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mutation Driven Testing: When TDD Just Isn’t Good Enough<br/>突变驱动测试：当TDD不够好时 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:20:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/2539a110b72f01a6b25d41d50987b20c.jpg"><img src="http://img2.diglog.com/img/2021/2/2539a110b72f01a6b25d41d50987b20c.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As someone who loves discussing Software Craftsmanship and best practices, Test Driven Development (TDD) is a bit of a sore spot for me. Let me start off by saying that I  love TDD’s emphasis on testing. Too many software projects skimp on testing. And the results speak for themselves many years down the road, when  changes take exponentially longer to implement, and people are too afraid to even touch anything.</p><p>作为一个喜欢讨论软件工艺和最佳实践的人，测试驱动开发（TDD）对我来说有点痛。首先，我要说我喜欢TDD对测试的重视。太多的软件项目无法进行测试。结果是不言而喻的，因为要实施变更需要成倍的时间，而且人们甚至都不敢碰任何东西，结果要说明很多年。</p><p> That said, I’ve still never been a big fan of TDD. One the one hand, it’s too strict. Insisting on writing tests first, often gets in the way of the exploratory work – work that is needed before you can iron out what the right interfaces, methods, and OO-structure should be.</p><p> 话虽如此，我仍然从不热衷于TDD。一方面，它太严格了。首先坚持编写测试，通常会妨碍探索工作–在确定正确的接口，方法和OO结构应该是什么之前，需要做的工作。</p><p> But on the other hand, TDD is ironically  too lenient. Many practitioners assume that because they are practicing TDD, their test-suite is rock solid. When in reality, I’ve seen far too many tests written during TDD, that still suffer from gaping coverage holes. Coverage holes that can and will result in production bugs, either now or in the future. As far as testing methodology goes, plugging these coverage holes should be your top priority – overriding all other fads and recommendations.</p><p> 但是，另一方面，TDD太宽容了。许多从业者认为，由于他们正在练习TDD，因此他们的测试套件坚如磐石。实际上，我看到在TDD期间编写了太多测试，但仍然面临覆盖漏洞。覆盖漏洞，无论现在还是将来，都可能会导致生产错误。就测试方法论而言，填补这些漏洞是您的头等大事-取代所有其他时尚和建议。</p><p> Hence why my favored testing philosophy is best illustrated by Mutation Driven Testing, which follows this sequence of steps:</p><p> 因此，为什么我最喜欢的测试原理可以通过以下步骤顺序的突变驱动测试得到最好的说明：</p><p> Get to a state where you have both code and successfully passing tests Whether you should write code-first or test-first is best debated elsewhere. You’re certainly welcome to use TDD to get to this point</p><p> 进入既拥有代码又成功通过测试的状态，应该在其他地方辩论是编写代码优先还是测试优先。当然，欢迎使用TDD达到这一点</p><p> Go through your newly added/modified code, line by line, and manually inject a single bug When deciding what a “reasonable bug” is, assume carelessness, laziness, inexperience and incompetence. But not malice. Using tests to catch malicious bugs is exponentially harder, and less realistic</p><p> 逐行浏览新添加/修改的代码，并手动注入一个错误在确定什么是“合理的错误”时，请假定粗心，懒惰，缺乏经验和能力不足。但不是恶意。使用测试来捕获恶意错误会成倍增加难度，并且不太现实</p><p>  If a test does not fail, review what coverage holes you have in your tests, and fix them by adding new tests or updating your existing tests</p><p>  如果测试没有失败，请查看测试中存在哪些覆盖漏洞，并通过添加新测试或更新现有测试来修复它们 </p><p>  Go back to step 2 and repeat, until you’ve injected every bug you can think of, or have run out of time As you get the hang for Mutation-Driven-Testing, you’ll develop an intuitive knack for figuring out which bugs are most likely to slip past your average test suite. This will dramatically speed up this process, and also teach you to write more comprehensive tests</p><p>返回第2步并重复，直到您注入了您可以想到的每个错误，或者用完了所有时间。当您对Mutation-Driven-Testing有所了解时，您将找到一个直观的诀窍来找出哪些错误最有可能超越您的平均测试套件。这将大大加快此过程，并教会您编写更全面的测试</p><p> The philosophy behind Mutation-Driven-Testing is simple. The only way to assess the reliability of your test suite, is to see whether it fails when a bug is present. So inject that bug yourself. Use the resulting output to figure out where your coverage holes are, and strengthen them as appropriate. Not just to catch the specific bug you just injected, but any other similar category of bug too. By doing this, you can identify the blind spots in your test suite, and strengthen your test coverage accordingly.</p><p> 突变驱动测试背后的原理很简单。评估测试套件可靠性的唯一方法是查看存在错误时是否失败。因此，请自己注入该错误。使用结果输出找出覆盖漏洞的位置，并根据需要进行增强。不仅要捕捉您刚刚注入的特定错误，而且还要捕捉其他类似类别的错误。这样，您可以确定测试套件中的盲点，并相应地增强测试范围。</p><p>   If you listen closely, you can hear a million TDD proponents crying out in protest.</p><p>   如果您仔细听讲，您会听到一百万个TDD支持者大声抗议。</p><p> “But you don’t need to do Mutation Testing if you’ve actually done TDD! If you do TDD correctly, every single piece of functionality will have a dedicated test, so you will never ever have a coverage hole!”</p><p> “但是，如果您确实完成了TDD，则无需进行突变测试！如果您正确执行TDD，则每一项功能都会进行专门的测试，因此您永远不会遇到漏洞！”</p><p> To illustrate why this is not true, and to demonstrate the benefits of Mutation-Driven-Testing, I have put together the following example.  The source of the example is the top google result, when you search for “TDD Example”.</p><p> 为了说明为什么这是不正确的，并且为了说明突变驱动测试的好处，我整理了以下示例。当您搜索“ TDD示例”时，示例的来源是Google排名最高的结果。</p><p> One might argue that the author of this article is not a good role model for TDD. That  “no true TDD practitioner” would write tests like in the above example. But this really is just sour grapes. The author is making a concerted effort to write comprehensive tests, has done a good job, and the example chosen below is very simple. The reality of TDD in the workplace, is that most practitioners aren’t perfect, and are always prone to some oversights. Oversights that can be flagged and fixed with Mutation-Driven-Testing.</p><p> 有人可能会认为本文的作者不是TDD的好榜样。 “没有真正的TDD实践者”会像上面的示例一样编写测试。但这真的只是酸葡萄。作者正在共同努力编写综合测试，做得很好，下面选择的示例非常简单。 TDD在工作场所的现实是，大多数从业人员都不是完美的，并且总是容易受到疏忽。可以使用Mutation-Driven-Testing标记并修复的疏忽。</p><p> Without further ado, let’s dive into the example – creating a simple string-based calculator. For the sake of conciseness, let’s look at just the first 3 requirements in the example, along with their implementations and tests.</p><p> 事不宜迟，让我们深入研究示例-创建一个简单的基于字符串的计算器。为了简洁起见，让我们仅看一下示例中的前三个要求以及它们的实现和测试。 </p><p>       Certainly seems like a good suite of tests that covers all functionality. But how well does it stand up to Mutation-Driven-Testing? In the real world, I would inject bugs one at a time, and run the tests after each injection. But for the sake of conciseness, let’s just inject all the relevant bugs at once.</p><p>当然，这似乎是涵盖所有功能的一组不错的测试。但是，它经受突变驱动测试的效果如何？在现实世界中，我会一次注入一个bug，并在每次注入之后运行测试。但是为了简洁起见，让我们一次注入所有相关的错误。</p><p>   This is a bit of a freebie, but worth pointing out. What if we just removed the  trim() call from our implementation. Certainly seems like a plausible oversight.</p><p>   这有点免费，但值得指出。如果我们只是从实现中删除trim（）调用，该怎么办。当然，这似乎是一个合理的监督。</p><p>    The requirement says to return 0 for an empty string. Presumably, based on the author’s implementation, this means that any empty sub-string should be treated as 0, whereas previous non-empty sub-strings should still be summed. But what if the implementation does something different and returns 0 as soon as it sees any empty string?</p><p>    要求说为空字符串返回0。据推测，基于作者的实现，这意味着任何空子字符串应被视为0，而先前的非空子字符串仍应加和。但是，如果实现做一些不同的事情并在看到任何空字符串后立即返回0，该怎么办？</p><p>    The requirement says that the method can take  “0, 1 or 2 numbers.” So…. we should check for 3 numbers and throw an exception?</p><p>    要求说该方法可以采用“ 0、1或2个数字”。所以…。我们应该检查3个数字并抛出异常？</p><p> This is admittedly a pretty foolish bug, but never underestimate how creative fools can be.</p><p> 诚然，这是一个非常愚蠢的错误，但永远不要低估创意傻瓜的能力。</p><p>    When building a “string -&gt; numeric” calculator, with an integer final result, there are many different ways of implementing string conversions:</p><p>    构建“字符串->”时数字”计算器，其最终结果为整数，有许多不同的方式来实现字符串转换：</p><p> Convert string to int, perform int operations, return an int result. Throw an exception if your input string is not an int</p><p> 将字符串转换为int，执行int操作，返回int结果。如果您的输入字符串不是整数，则引发异常 </p><p> Convert string to double, cast the double to an int, perform int operations, return an int result</p><p>将字符串转换为double，将double转换为int，执行int操作，返回int结果</p><p> Convert string to double, perform double operations, cast the final result to an int and return it</p><p> 将字符串转换为double，执行double操作，将最终结果转换为int并将其返回</p><p> The above 3 approaches all produce completely different outputs when given an input like  &#34;1.5, 1.5&#34;. In the example, the author had implemented option #1. Let’s assume that is indeed the desired behavior. But what if he had mistakenly implemented option #3?</p><p> 当给定输入＆＃34; 1.5，1.5＆＃34;时，上述3种方法都会产生完全不同的输出。在示例中，作者实现了选项＃1。让我们假设这确实是所需的行为。但是，如果他错误地实施了方案3，该怎么办？</p><p>   In practice, we would only inject a single bug at a time. But for the purposes of conciseness, let’s combine all of them, which leaves us with the following mess:</p><p>   实际上，我们一次只能注入一个bug。但是为了简洁起见，让我们将所有这些结合起来，使我们陷入以下混乱：</p><p>  Amazingly, not a single test has failed! Every single test written by the author is still green, despite us injecting plausible bugs in every other line. Demonstrating that our test suite has the following holes:</p><p>  令人惊讶的是，没有一个测试失败！尽管我们在其他各行中注入了可能存在的错误，但作者编写的每个测试仍然是绿色的。证明我们的测试套件存在以下漏洞：</p><p>  And once you’ve identified the above holes, you can start plugging them by adding more tests. Tests that are now failing, and start passing once you revert all the injected bugs:</p><p>  一旦确定了上述漏洞，就可以通过添加更多测试来开始堵塞它们。现在测试失败了，一旦恢复所有注入的错误，测试就开始通过：</p><p>  Let me be clear – the above tests are certainly not perfect. With further iterations of mutation testing, you can identify even more coverage holes that are missed by the above tests. Also, you really should be using  far more sophisticated testing techniques (discussed here), in order to enhance your test coverage in a concise manner.</p><p>  让我明确地说-上述测试当然不是完美的。随着突变测试的进一步迭代，您可以发现上述测试遗漏的更多覆盖孔。另外，您确实应该使用更为复杂的测试技术（在此讨论），以便以简洁的方式增强测试覆盖率。 </p><p> But at least this process helps us better understand where the coverage holes are, and get us much closer towards eliminating the most glaring ones.</p><p>但是至少这个过程可以帮助我们更好地了解覆盖漏洞的位置，并使我们更加接近消除最明显的漏洞。</p><p>  Admittedly, going through the above process will take additional effort and time. And the end result will be a much more verbose suite of tests, many of which would seem redundant to the untrained eye. Is this really worth it?</p><p>  诚然，完成上述过程将花费更多的精力和时间。最终结果将是一套更为冗长的测试，其中许多对于未经训练的人来说似乎是多余的。这真的值得吗？</p><p> As always, it depends on your priorities. If you’re building a quick-and-dirty prototype and don’t mind smaller corner-case bugs leaking through, you’re probably fine. But if production bugs scare you, you should absolutely invest time and effort into enhancing your test suite. A rock solid test suite with minimal coverage holes, is the best defense against production bugs. And in the long run,  it will actually increase your development velocity, by allowing people to refactor safely and deploy changes quickly, without spending gobs of time on manual testing.</p><p> 与往常一样，这取决于您的优先级。如果您要构建快速且肮脏的原型，并且不介意漏出较小的极端情况，则可能很好。但是，如果生产错误使您感到恐惧，则绝对应该花费时间和精力来增强测试套件。具有最小覆盖漏洞的坚如磐石的测试套件是抵御生产错误的最佳选择。从长远来看，通过允许人们安全地重构并快速部署更改，而无需花费大量时间进行手动测试，它实际上将提高您的开发速度。</p><p> People often talk about TDD as though it’s a silver bullet that “solves” testing. Clearly, this is not the case. Perhaps if you’re Jeff Dean or Sanjay Ghemawat, you can write a perfect test suite purely through reason alone. But for the rest of us mortals, the best way to identify and fix coverage holes in our test suite, is by empirically putting it to the test.</p><p> 人们经常谈论TDD，好像它是“解决”测试的灵丹妙药。显然，事实并非如此。也许，如果您是Jeff Dean或Sanjay Ghemawat，则可以纯粹通过推理来编写完美的测试套件。但是对于我们其余的凡人而言，识别和修复测试套件中覆盖漏洞的最佳方法是凭经验进行测试。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://software.rajivprab.com/2021/02/04/mutation-driven-testing-when-tdd-just-isnt-good-enough/">https://software.rajivprab.com/2021/02/04/mutation-driven-testing-when-tdd-just-isnt-good-enough/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/驱动/">#驱动</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/driven/">#driven</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>