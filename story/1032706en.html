<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>名称不是类型安全的</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">名称不是类型安全的</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 09:23:24</div><div class="page_narrow text-break page_content"><p>Haskell programmers spend a lot of time talking about  type safety. The Haskell school of program construction advocates “capturing invariants in the type system” and “making illegal states unrepresentable,” both of which sound like compelling goals, but are rather vague on the techniques used to achieve them. Almost exactly one year ago, I published  Parse, Don’t Validate as an initial stab towards bridging that gap.</p><p>Haskell程序员花了大量时间讨论类型安全。程序构造的哈斯克尔学派主张“捕获类型系统中的不变量”和“使非法状态不可表示”，这两个听起来都是令人信服的目标，但在实现这些目标所使用的技术上却相当模糊。几乎就在一年前，我出版了“解析，不要验证”(Parse，Don‘t Validation)一书，作为弥合这一鸿沟的初步尝试。</p><p> The ensuing discussions were largely productive and right-minded, but one particular source of confusion quickly became clear: Haskell’s  newtype construct. The idea is simple enough—the  newtype keyword declares a wrapper type, nominally distinct from but representationally equivalent to the type it wraps—and on the surface this  sounds like a simple and straightforward path to type safety. For example, one might consider using a  newtype declaration to define a type for an email address:</p><p>随后的讨论在很大程度上是富有成效的和正确的，但一个特别的困惑来源很快就变得清晰起来：哈斯克尔的新型结构。这个想法非常简单--newtype关键字声明了一个包装器类型，名义上与它包装的类型不同，但在表示上等同于它所包装的类型-从表面上看，这听起来像是一条通向类型安全的简单而直接的路径。例如，您可以考虑使用Newtype声明来定义电子邮件地址的类型：</p><p>  This technique can provide  some value, and when coupled with a smart constructor and an encapsulation boundary, it can even provide some safety. But it is a meaningfully distinct  kind of type safety from the one I highlighted a year ago, one that is far weaker. On its own, a newtype is just a name.</p><p>这项技术可以提供一些价值，当与智能构造函数和封装边界结合使用时，它甚至可以提供一些安全性。但是，与我一年前强调的类型安全相比，它是一种有意义的截然不同的类型安全，它要弱得多。就其本身而言，新型只是一个名称。</p><p>   To illustrate the difference between constructive data modeling (discussed at length in my  previous blog post) and newtype wrappers, let’s consider an example. Suppose we want a type for “an integer between 1 and 5, inclusive.” The natural constructive modeling would be an enumeration with five cases:</p><p>为了说明构造性数据建模(在我上一篇博客文章中详细讨论)和Newtype包装器之间的区别，让我们考虑一个示例。假设我们需要一个“介于1和5之间(包括1和5)的整数”类型。自然的构造性建模将是具有五种情况的枚举：</p><p>   toOneToFive  ::  Int  -&gt;  Maybe  OneToFive toOneToFive  1  =  Just  One toOneToFive  2  =  Just  Two toOneToFive  3  =  Just  Three toOneToFive  4  =  Just  Four toOneToFive  5  =  Just  Five toOneToFive  _  =  Nothing fromOneToFive  ::  OneToFive  -&gt;  Int fromOneToFive  One  =  1 fromOneToFive  Two  =  2 fromOneToFive  Three  =  3 fromOneToFive  Four  =  4 fromOneToFive  Five  =  5</p><p>ToOneToFive：：Int-&gt；可能OneToFive：：OneToFive 1=只有一个到OneToFive 2=只有两个到OneToFive 3=只有三个到OneToFive 4=只有四个到OneToFive 5=只有五个到OneToFive_=没有任何来自OneToFive：：OneToFive-&gt；Int；Int FromOneToFive 1=1 FromOneToFive 2=2 FromOneToFive 3=3 FromOneToFive 5=4 FromOneToFive-&gt；Int；Int FromOneToFive 1=1 from OneToFive 2=2 from OneToFive 3=3 from OneToFive 4=4 from OneToFive=5。</p><p> This would be perfectly sufficient for achieving our stated goal, but you’d be forgiven for finding it odd: it would be rather awkward to work with in practice. Because we’ve invented an entirely new type, we can’t reuse any of the usual numeric functions Haskell provides. Consequently, many programmers would gravitate towards a newtype wrapper, instead:</p><p>对于实现我们声明的目标，这将是完全足够的，但是您会发现它很奇怪，这是情有可原的：在实践中使用它将是相当尴尬的。因为我们发明了一种全新的类型，所以不能重用Haskell提供的任何常用数值函数。因此，许多程序员会倾向于使用新型包装器，而不是：</p><p>   toOneToFive  ::  Int  -&gt;  Maybe  OneToFive toOneToFive  n  |  n  &gt;=  1  &amp;&amp;  n  &lt;=  5  =  Just  $  OneToFive  n  |  otherwise  =  Nothing fromOneToFive  ::  OneToFive  -&gt;  Int fromOneToFive  ( OneToFive  n )  =  n</p><p>ToOneToFive：：Int-&gt；可能OneToFive到OneToFive n|n&gt；=1&amp；&amp；n&lt；=5=仅$OneToFive n|否则=OneToFive：：OneToFive-&gt；Int FromOneToFive(OneToFive N)=n。</p><p> If we put these declarations in their own module and choose not to export the  OneToFive constructor, these APIs might appear entirely interchangeable. Naïvely, it seems that the newtype version is both simpler and equally type-safe. However—perhaps surprisingly—this is not actually true.</p><p>如果我们将这些声明放在它们自己的模块中，并选择不导出OneToFive构造函数，这些API可能看起来完全可以互换。天真的是，新型版本似乎既更简单，又同样是类型安全的。然而，也许令人惊讶的是，这实际上并不是真的。</p><p> To see why, suppose we write a function that consumes a  OneToFive value as an argument. Under the constructive modeling, such a function need only pattern-match against each of the five constructors, and GHC will accept the definition as exhaustive:</p><p>要了解原因，假设我们编写了一个使用OneToFive值作为参数的函数。在构造性建模下，这样的函数只需要对五个构造器中的每一个进行模式匹配，GHC将接受该定义为详尽的：</p><p> ordinal  ::  OneToFive  -&gt;  Text ordinal  One  =  &#34;first&#34; ordinal  Two  =  &#34;second&#34; ordinal  Three  =  &#34;third&#34; ordinal  Four  =  &#34;fourth&#34; ordinal  Five  =  &#34;fifth&#34;</p><p>序数：：OneToFive-&gt；text序数一=&#34；第一&#34；序数二=&#34；第二&#34；序数三=&#34；第三&#34；序数四=&#34；第四&#34；序数五=&#34；第五&#34；</p><p> The same is not true given the newtype encoding. The newtype is opaque, so the only way to observe it is to convert it back to an  Int—after all, it  is an  Int. An  Int can of course contain many other values besides  1 through  5, so we are forced to add an error case to satisfy the exhaustiveness checker:</p><p>对于NewType编码，情况并非如此。Newtype是不透明的，因此观察它的唯一方法是将其转换回Int-毕竟，它是Int。Int当然可以包含除1到5之外的许多其他值，因此我们被迫添加错误情况以满足穷举检查器的要求：</p><p> ordinal  ::  OneToFive  -&gt;  Text ordinal  n  =  case  fromOneToFive  n  of  1  -&gt;  &#34;first&#34;  2  -&gt;  &#34;second&#34;  3  -&gt;  &#34;third&#34;  4  -&gt;  &#34;fourth&#34;  5  -&gt;  &#34;fifth&#34;  _  -&gt;  error  &#34;impossible: bad OneToFive value&#34;</p><p>序号：：OneToFive-&gt；text序号n=case from OneToFive n of 1-&&gt;；&#34；第一&#34；2-&gt；&#34；第二&#34；3-&gt；&#34；第三&#34；4-&gt；&#34；第四&#34；5-&gt；&#34；第五&#34；_-&gt；错误&#34；错误&#34；不可能：OneToFive值&#34；</p><p> In this highly contrived example, this may not seem like much of a problem to you. But it nonetheless illustrates a key difference in the guarantees afforded by the two approaches:</p><p>在这个精心设计的示例中，这对您来说可能不是什么大问题。但尽管如此，它还是说明了这两种方法提供的保障的关键区别：</p><p> The constructive datatype captures its invariants in such a way that they are  accessible to downstream consumers. This frees our  ordinal function from worrying about handling illegal values, as they have been made unutterable.</p><p>构造性数据类型以下游用户可以访问的方式捕获其不变量。这将我们的序号函数从处理非法值的烦恼中解放出来，因为它们已经变得无法表达。</p><p>  The newtype wrapper provides a smart constructor that  validates the value, but the boolean result of that check is used only for control flow; it is not preserved in the function’s result. Accordingly, downstream consumers cannot take advantage of the restricted domain; they are functionally accepting  Ints.</p><p>Newtype包装提供了验证值的智能构造函数，但该检查的布尔结果仅用于控制流；它不会保留在函数的结果中。因此，下游消费者不能利用限制域；他们在功能上接受Int。</p><p> Losing exhaustiveness checking might seem like small potatoes, but it absolutely is not: our use of  error has punched a hole right through our type system. If we were to add another constructor to our  OneToFive datatype,  1 the version of  ordinal that consumes a constructive datatype would be immediately detected non-exhaustive at compile-time, while the version that consumes a newtype wrapper would continue to compile yet fail at runtime, dropping through to the “impossible” case.</p><p>丢失穷举检查似乎是小菜一碟，但它绝对不是：我们对错误的使用直接在我们的类型系统上打了一个洞。如果我们向OneToFive数据类型添加另一个构造函数，1使用构造数据类型的Ordial版本将在编译时立即检测到非穷举，而使用Newtype包装器的版本将继续编译，但在运行时失败，一直到“不可能”的情况。</p><p> All of this is a consequence of the fact that the constructive modeling is  intrinsically type-safe; that is, the safety properties are enforced by the type declaration itself. Illegal values truly are unrepresentable: there is simply no way to represent  6 using any of the five constructors. The same is not true of the newtype declaration, which has no intrinsic semantic distinction from that of an  Int; its meaning is specified extrinsically via the  toOneToFive smart constructor. Any semantic distinction intended by a newtype is thoroughly invisible to the type system; it exists only in the programmer’s mind.</p><p>所有这些都是因为构造建模本质上是类型安全的；也就是说，安全属性是由类型声明本身强制执行的。非法的值确实是不可表示的：根本没有办法使用五个构造函数中的任何一个来表示6。Newtype声明则不是这样，它与Int没有内在的语义区别；它的含义是通过toOneToFive智能构造函数从外部指定的。任何Newtype意图的语义区别对于类型系统来说都是完全不可见的；它只存在于程序员的头脑中。</p><p>  Our  OneToFive datatype is rather artificial, but identical reasoning applies to other datatypes that are significantly more practical. Consider the  NonEmpty datatype I’ve repeatedly highlighted in recent blog posts:</p><p>我们的OneToFive数据类型相当人为，但是相同的推理适用于其他明显更实用的数据类型。考虑一下我在最近的博客文章中反复强调的非Empty数据类型：</p><p>  It may be illustrative to imagine a version of  NonEmpty represented as a newtype over ordinary lists. We can use the usual smart constructor strategy to enforce the desired non-emptiness property:</p><p>设想将NonEmpty的一个版本表示为普通列表上的新类型可能是说明性的。我们可以使用通常的智能构造函数策略来强制执行所需的非空属性：</p><p> newtype  NonEmpty  a  =  NonEmpty  [ a ] nonEmpty  ::  [ a ]  -&gt;  Maybe  ( NonEmpty  a ) nonEmpty  []  =  Nothing nonEmpty  xs  =  Just  $  NonEmpty  xs instance  Foldable  NonEmpty  where  toList  ( NonEmpty  xs )  =  xs</p><p>Newtype NonEmpty a=NonEmpty[a]NonEmpty：：[a]-&gt；可能(NonEmpty A)NonEmpty[]=Nothing NonEmpty Xs=Just$NonEmpty Xs实例可折叠非空，其中toList(NonEmpty Xs)=Xs。</p><p> Just as with  OneToFive, we quickly discover the consequences of failing to preserve this information in the type system. Our motivating use case for  NonEmpty was the ability to write a safe version of  head, but the newtype version requires another assertion:</p><p>就像使用OneToFive一样，我们很快就会发现未能在类型系统中保留此信息的后果。我们对NonEmpty的激励用例是能够编写安全版本的Head，但是Newtype版本需要另一个断言：</p><p> head  ::  NonEmpty  a  -&gt;  a head  xs  =  case  toList  xs  of  x : _  -&gt;  x  []  -&gt;  error  &#34;impossible: empty NonEmpty value&#34;</p><p>Head：：NonEmpty a-&gt；a Head Xs=case to List Xs of x：_-&gt；x[]-&gt；错误&#34；不可能：空的非空值&#34；</p><p> This might not seem like a big deal, since it seems unlikely such a case would ever happen. But that reasoning hinges entirely on trusting the correctness of the module that defines  NonEmpty, while the constructive definition only requires trusting the GHC typechecker. As we generally trust that the typechecker works correctly, the latter is a much more compelling proof.</p><p>这可能看起来不是什么大事，因为这样的情况似乎不太可能发生。但是，这种推理完全取决于信任定义NonEmpty的模块的正确性，而构造性定义只需要信任GHC类型检查器。由于我们通常相信类型检查器工作正常，因此后者是一个更有说服力的证据。</p><p>  If you are fond of newtypes, this whole argument may seem a bit troubling. It may seem like I’m implying newtypes are scarcely better than comments, albeit comments that happen to be meaningful to the typechecker. Fortunately, the situation is not quite that grim—newtypes  can provide a sort of safety, just a weaker one.</p><p>如果你喜欢新的类型，这整个争论可能看起来有点麻烦。我似乎是在暗示新类型并不比注释好多少，尽管注释恰好对类型检查器有意义。幸运的是，情况并不是很严峻-新类型可以提供一种安全，只是一种较弱的安全。</p><p> The primary safety benefit of newtypes is derived from abstraction boundaries. If a newtype’s constructor is not exported, it becomes opaque to other modules. The module that defines the newtype—its “home module”—can take advantage of this to create a  trust boundary where internal invariants are enforced by restricting clients to a safe API.</p><p>新类型的主要安全优势来自抽象边界。如果未导出NewType的构造函数，则它对其他模块变得不透明。定义NewType的模块(它的“主模块”)可以利用这一点来创建信任边界，在该边界中，通过将客户端限制为安全的API来实施内部不变量。</p><p> We can use the  NonEmpty example from above to illustrate how this works. We refrain from exporting the  NonEmpty constructor, and we provide  head and  tail operations that we trust to never actually fail:</p><p>我们可以使用上面的NonEmpty示例来说明这是如何工作的。我们避免导出NonEmpty构造函数，而是提供我们相信实际上永远不会失败的Head和Tail操作：</p><p> module  Data.List.NonEmpty.Newtype  (  NonEmpty  ,  cons  ,  nonEmpty  ,  head  ,  tail  )  where newtype  NonEmpty  a  =  NonEmpty  [ a ] cons  ::  a  -&gt;  [ a ]  -&gt;  NonEmpty  a cons  x  xs  =  NonEmpty  ( x : xs ) nonEmpty  ::  [ a ]  -&gt;  Maybe  ( NonEmpty  a ) nonEmpty  []  =  Nothing nonEmpty  xs  =  Just  $  NonEmpty  xs head  ::  NonEmpty  a  -&gt;  a head  ( NonEmpty  ( x : _ ))  =  x head  ( NonEmpty  [] )  =  error  &#34;impossible: empty NonEmpty value&#34; tail  ::  NonEmpty  a  -&gt;  [ a ] tail  ( NonEmpty  ( _ : xs ))  =  xs tail  ( NonEmpty  [] )  =  error  &#34;impossible: empty NonEmpty value&#34;</p><p>模块Data.List.NonEmpty.Newtype(NonEmpty，cons，NonEmpty，Head，Tail)其中Newtype NonEmpty a=NonEmpty[a]cons：：a-&gt；[a]-&gt；NonEmpty a cons xxs=NonEmpty(x：xs)NonEmpty：：[a]-&gt；可能(NonEmpty A)NonEmpty[]=Nothing NonEmpty xs=Just$NonEmpty Xs Head：：NonEmpty a-&gt；A Head(NonEmpty(x：_))=x Head(NonEmpty[])=错误&#34；不可能：空非空值&#34；Tail：：NonEmpty a-&gt；[a]Tail(NonEmpty(_：xs))=Xs Tail(NonEmpty[])=错误&#34；不可能：空非空值&#34；</p><p> Since the only way to construct or consume  NonEmpty values is to use the functions in  Data.List.NonEmpty.Newtype’s exported API, the above implementation makes it impossible for clients to violate the non-emptiness invariant. In a sense, values of opaque newtypes are like  tokens: the implementing module issues tokens via its constructor functions, and those tokens have no intrinsic value. The only way to do anything useful with them is to “redeem” them to the issuing module’s accessor functions, in this case  head and  tail, to obtain the values contained within.</p><p>由于构造或使用NonEmpty值的唯一方法是使用Data.List.NonEmpty.Newtype的导出API中的函数，因此上述实现使得客户端不可能违反非空不变量。从某种意义上说，不透明的新类型的值就像令牌：实现模块通过其构造函数发布令牌，而这些令牌没有内在价值。要对它们做任何有用的事情，唯一的方法是将它们“赎回”到发布模块的访问器函数，在本例中是head和ail，以获取其中包含的值。</p><p> This approach is significantly weaker than using a constructive datatype, since it is theoretically possible to screw up and accidentally provide a means to construct an invalid  NonEmpty [] value. For this reason, the newtype approach to type safety does not on its own constitute a  proof that a desired invariant holds. However, it restricts the “surface area” where an invariant violation can occur to the defining module, so reasonable confidence the invariant really does hold can be achieved by thoroughly testing the module’s API using fuzzing or property-based testing techniques.  2</p><p>这种方法比使用构造数据类型弱得多，因为理论上有可能搞砸并意外地提供一种方法来构造无效的NonEmpty[]值。因此，类型安全的新型方法本身并不构成所需不变量成立的证明。但是，它限制了定义模块可能出现不变违规的“表面积”，因此，通过使用模糊或基于属性的测试技术彻底测试模块的API，可以获得不变量确实具有的合理置信度。2个。</p><p> This tradeoff may not seem all that bad, and indeed, it is often a very good one! Guaranteeing invariants using constructive data modeling can, in general, be quite difficult, which often makes it impractical. However, it is easy to dramatically underestimate the care needed to avoid accidentally providing a mechanism that permits violating the invariant. For example, the programmer may choose to take advantage of GHC’s convenient typeclass deriving to derive a  Generic instance for  NonEmpty:</p><p>这种权衡可能看起来并不是那么糟糕，事实上，它往往是非常好的！使用构造性数据建模来保证不变量通常是相当困难的，这通常使其不切实际。然而，很容易严重低估避免意外提供允许违反不变量的机制所需的谨慎。例如，程序员可以选择利用GHC方便的类型类派生来派生NonEmpty的泛型实例：</p><p>    This is a particularly extreme example, since derived  Generic instances are fundamentally abstraction-breaking, but this problem can crop up in less obvious ways, too. The same problem occurs with a derived  Read instance:</p><p>这是一个特别极端的例子，因为派生的泛型实例从根本上破坏了抽象，但是这个问题也可能以不太明显的方式突然出现。派生的Read实例也会出现同样的问题：</p><p>  To some readers, these pitfalls may seem obvious, but safety holes of this sort are remarkably common in practice. This is especially true for datatypes with more sophisticated invariants, as it may not be easy to determine whether the invariants are actually upheld by the module’s implementation. Proper use of this technique demands caution and care:</p><p>对于一些读者来说，这些陷阱可能看起来很明显，但这种安全漏洞在实践中非常常见。对于具有更复杂的不变量的数据类型尤其如此，因为可能不容易确定模块的实现是否实际支持这些不变量。正确使用这项技术需要谨慎和小心：</p><p> All invariants must be made clear to maintainers of the trusted module. For simple types, such as  NonEmpty, the invariant is self-evident, but for more sophisticated types, comments are not optional.</p><p>所有不变量必须清楚地告知可信模块的维护人员。对于简单类型(如NonEmpty)，不变量是不言而喻的，但对于更复杂的类型，注释不是可选的。</p><p>  Every change to the trusted module must be carefully audited to ensure it does not somehow weaken the desired invariants.</p><p>必须仔细审核可信模块的每个更改，以确保它不会以某种方式削弱所需的不变量。</p><p>  Discipline is needed to resist the temptation to add unsafe trapdoors that allow compromising the invariants if used incorrectly.</p><p>需要纪律来抵制添加不安全陷门的诱惑，如果使用不当，这些陷门可能会危及不变量。</p><p>  Periodic refactoring may be needed to ensure the trusted surface area remains small. It is all too easy for the responsibility of the trusted module to accumulate over time, dramatically increasing the likelihood of some subtle interaction causing an invariant violation.</p><p>可能需要定期重构以确保可信表面积保持较小。随着时间的推移，受信任模块的责任很容易积累，从而极大地增加了一些微妙的交互导致不变违规的可能性。</p><p> In contrast, datatypes that are correct by construction suffer none of these problems. The invariant cannot be violated without changing the datatype definition itself, which has rippling effects throughout the rest of the program to make the consequences immediately clear. Discipline on the part of the programmer is unnecessary, as the typechecker enforces the invariants automatically. There is no “trusted code” for such datatypes, since all parts of the program are equally beholden to the datatype-mandated constraints.</p><p>相比之下，通过构造而正确的数据类型不会遇到这些问题。在不更改数据类型定义本身的情况下，不能违反不变量，这会在整个程序的其余部分产生连锁反应，使结果立即变得清晰。程序员没有必要遵守规则，因为类型检查器会自动强制执行不变量。这样的数据类型没有“可信代码”，因为程序的所有部分都同样受制于数据类型强制约束。</p><p> In libraries, the newtype-afforded notion of safety via encapsulation is useful, as libraries often provide the building blocks used to construct more complicated data structures. Such libraries generally receive more scrutiny and care than application code does, especially given they change far less frequently. In application code, these techniques are still useful, but the churn of a production codebase tends to weaken encapsulation boundaries over time, so correctness by construction should be preferred whenever practical.</p><p>在库中，由Newtype提供的通过封装实现的安全性概念非常有用，因为库通常提供用于构建更复杂数据结构的构建块。这类库通常比应用程序代码受到更多的检查和关注，特别是考虑到它们的更改频率要低得多。在应用程序代码中，这些技术仍然有用，但是随着时间的推移，产品代码库的混乱往往会削弱封装边界，因此只要可行，就应该优先使用构造的正确性。</p><p>  The previous section covers the primary means by which newtypes are useful. However, in practice, newtypes are routinely used in ways that do not fit the above pattern. Some such uses are reasonable:</p><p>上一节介绍了新类型有用的主要方式。然而，在实践中，新类型的常规使用方式不符合上述模式。一些这样的用途是合理的：</p><p> Haskell’s notion of typeclass coherency limits each type to a single instance of any given class. For types that permit more than one useful instance, newtypes are the traditional solution, and this can be used to good effect. For example, the  Sum and  Product newtypes from  Data.Monoid provide useful  Monoid instances for numeric types.</p><p>Haskell的类型类一致性概念将每个类型限制为任何给定类的单个实例。对于允许多个有用实例的类型，新类型是传统的解决方案，这可以取得很好的效果。例如，Data.Monoid中的Sum和Product新类型为数值类型提供了有用的Monoid实例。</p><p>  In a similar vein, newtypes can be useful for introducing or rearranging type parameters. The  Flip newtype from  Data.Bifunctor.Flip is a simple example, flipping the arguments of a  Bifunctor so the  Functor instance may operate on the other side:</p><p>同样，新类型对于引入或重新排列类型参数也很有用。Flip Newtype from Data.Bifunctor.Flip是一个简单的示例，它翻转Bifunctor的参数，以便函数器实例可以在另一端操作：</p><p>    Newtypes are needed to do this sort of juggling, as Haskell does not (yet) support type-level lambdas.</p><p>由于Haskell(目前)还不支持类型级别的lambdas，因此需要使用新类型来处理这类问题。</p><p>  More simply, transparent newtypes can be useful to discourage misuse when the value needs to be passed between distant parts of the program and the intermediate code has no reason to inspect the value. For example, a  ByteString containing a secret key may be wrapped in a newtype (with a  Show instance omitted) to discourage code from accidentally logging or otherwise exposing it.</p><p>更简单地说，当值需要在程序的远程部分之间传递并且中间代码没有理由检查值时，透明的新类型对于防止误用非常有用。例如，可以将包含密钥的ByteString包装在NewType中(省略Show实例)，以防止代码意外记录或以其他方式公开它。</p><p> All of these applications are good ones, but they have little to do with  type safety. The last bullet in particular is often confused for safety, and to be fair, it does in fact take advantage of the type system to help avoid logical mistakes. However, it would be a mischaracterization to claim such usage actually  prevents misuse; any part of the program may inspect the value at any time.</p><p>所有这些应用程序都很好，但它们与类型安全关系不大。为了安全起见，最后一个项目常常被混淆，而且公平地说，它实际上确实利用了类型系统来帮助避免逻辑错误。然而，声称这样的使用实际上防止了误用将是一个错误的描述；程序的任何部分都可能在任何时候检查该值。</p><p> Too often, this illusion of safety leads to outright newtype abuse. For example, here’s a definition from the very codebase I work on for a living:</p><p>太多时候，这种安全的错觉导致了彻底的新型滥用。例如，下面是我工作的代码库中的一个定义：</p><p> newtype  ArgumentName  =  ArgumentName  {  unArgumentName  ::  GraphQL . Name  }  deriving  (  Show ,  Eq ,  FromJSON ,  ToJSON ,  FromJSONKey ,  ToJSONKey  ,  Hashable ,  ToTxt ,  Lift ,  Generic ,  NFData ,  Cacheable  )</p><p>Newtype ArgumentName=ArgumentName{unArgumentName：：GraphQL.。名称}派生(Show，Eq，FromJSON，ToJSON，FromJSONKey，ToJSONKey，Hasable，ToTxt，Lift，Generic，NFData，Cacheable)。</p><p> This newtype is useless noise. Functionally, it is completely interchangeable with its underlying  Name type, so much so that it derives a dozen typeclasses! In every location it’s used, it’s immediately unwrapped the instant it’s extracted from its enclosing record, so there is no type safety benefit whatsoever. Worse, there isn’t even any clarity added by labeling it an  ArgumentName, since the enclosing field name already makes its role clear.</p><p>这种新型的噪音是无用的。在功能上，它完全可以与其底层名称类型互换，以至于它派生了十几个类型类！在使用它的每一个位置，一旦它从封闭的记录中提取出来，它就会立即打开，所以没有任何类型安全好处。更糟糕的是，将其标记为ArgumentName甚至没有增加任何清晰度，因为包含的字段名已经清楚地说明了它的作用。</p><p> Newtypes like these seem to arise from a desire to use the type system as a taxonomy of the external world. An “argument name” is a more specific concept than a generic “name,” so surely it ought to have its own type. This makes some intuitive sense, but it’s rather misguided: taxonomies are useful for documenting a domain of interest, but not necessarily helpful for modeling it. When programming, we use types for a different end:</p><p>这样的新类型似乎是由于希望将类型系统用作外部世界的分类法而产生的。“参数名称”是一个比通用“名称”更具体的概念，因此它当然应该有自己的类型。这有一定的直觉意义，但却相当误导：分类法对于记录感兴趣的领域很有用，但不一定对建模有帮助。在编程时，我们将类型用于不同的目的：</p><p> Primarily, types distinguish  functional differences between values. A value of type  NonEmpty a is  functionally distinct from a value of type  [a], since it is fundamentally structurally different and permits additional operations. In this sense, types are  structural; they describe what values  are in the internal world of the programming language.</p><p>首先，类型区分值之间的功能差异。类型为NonEmpty a的值与类型为[a]的值在功能上是不同的，因为它在结构上完全不同，并且允许其他操作。从这个意义上说，类型是结构化的；它们描述了编程语言内部世界中的值。</p><p>  Secondarily, we sometimes use types to help ourselves avoid making logical mistakes. We might use separate  Distance and  Duration types to avoid accidentally doing something nonsensical like adding them together, even though they’re both representationally real numbers.</p><p>其次，我们有时使用类型来帮助自己避免犯逻辑错误。我们可能会使用单独的距离和持续时间类型，以避免意外地做一些无意义的事情，比如将它们加在一起，即使它们都是代表实数的数字。</p><p> Note that both these uses are  pragmatic; they look at the type system as a tool. This is a rather natural perspective to take, seeing as a static type system  is a tool in a literal sense. Nevertheless, that perspective seems surprisingly unusual, even though the use of types to classify the world routinely yields unhelpful noise like  ArgumentName.</p><p>请注意，这两种用法都是实用的；它们将类型系统视为一种工具。这是一个相当自然的观点，因为静态类型系统是字面意义上的工具。然而，这种观点似乎出人意料地不同寻常，尽管使用类型对世界进行分类通常会产生像ArgumentName这样无益的噪音。</p><p> If a newtype is completely transparent, and it is routinely wrapped and unwrapped at will, it is likely not very helpful. In this particular case, I would eliminate the distinction altogether and use  Name, but in situations where the different label adds genuine clarity, one can always use a type alias:  3</p><p>如果一个新类型是完全透明的，并且经常随意地进行包装和解包，那么它可能不会有太大帮助。在本例中，我将完全消除区别并使用name，但在不同标签增加真正清晰度的情况下，可以始终使用类型别名：3。</p><p>  Newtypes like these are security blankets. Forcing programmers to jump through a few hoops is not type safety—trust me when I say they will happily jump through them without a second thought.</p><p>像这样的新人是安全毯。强迫程序员跳过几个圈子不是典型的安全-相信我，当我说他们会毫不犹豫地愉快地跳过这些圈子的时候。</p><p>  I’ve been wanting to write this blog post for a long time. Ostensibly, it’s a very specific critique of Haskell newtypes, and I’ve chosen to frame things this way because I write Haskell for a living and this is the way I encounter this problem in practice. Really, though, the core idea is much bigger than that.</p><p>我想写这篇博文已经很久了。从表面上看，这是对哈斯克尔新类型的非常具体的批评，我之所以选择这样的框架，是因为我写哈斯克尔是为了谋生，而这就是我在实践中遇到这个问题的方式。不过，实际上，核心理念远不止于此。</p><p> Newtypes are one particular mechanism of defining  wrapper types, a concept that exists in almost any language, even those that are dynamically typed. Even if you don’t write Haskell, much of the reasoning in this blog post is likely still relevant in your language of choice. More broadly, this is a continuation of a theme I’ve been trying to convey from different angles over the past year: type systems are tools, and we should be more conscious and intentional about what they actually do and how to use them effectively.</p><p>新类型是定义包装类型的一种特殊机制，这个概念几乎存在于任何语言中，甚至包括那些动态类型的语言。即使您没有编写Haskell，这篇博客文章中的大部分推理可能仍然与您选择的语言相关。更广泛地说，这是我在过去一年里试图从不同角度传达的一个主题的延续：类型系统是工具，我们应该更有意识和有意识地了解它们实际上做了什么，以及如何有效地使用它们。</p><p> The catalyst that got me to finally sit down and write this was the recently-published  Tagged is not a Newtype. It’s a good blog post, and I wholeheartedly agree with its general thrust, but I thought it was a missed opportunity to make a larger point. Indeed,  Tagged  is a newtype, definitionally, so the title of the blog post is something of a misdirection. The real problem is a little deeper.</p><p>让我最终坐下来写这篇文章的催化剂是最近出版的标签，而不是新型的。这是一篇很好的博客文章，我全心全意地同意它的总体主旨，但我认为这是一个错失了表达更大观点的机会。事实上，从定义上讲，Tagked是一种新类型，所以这篇博客文章的标题有点误导。真正的问题是更深层次的问题。</p><p> Newtypes are useful when carefully applied, but their safety is not intrinsic, no more than the safety of a traffic cone is somehow contained within the plastic it’s made of. What matters is being placed in the right context—without that, newtypes are just a labeling scheme, a way of giving something a name.</p><p>当小心使用时，新型是有用的，但它们的安全性并不是固有的，就像交通锥的安全性以某种方式包含在它所用的塑料中一样。重要的是放在正确的上下文中-如果没有这样的上下文，新类型只是一个标签方案，一种给某个东西命名的方式。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/">http://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032409.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2269f52f0eb0ef16935e9b7ae5ee39df.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032409.html">我讨厌Python静态类型标注方案</a></div><span class="my_story_list_date">2020-10-31 7:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030569.html"><img src="http://img2.diglog.com/img/2020/10/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030569.html">镍：以更少的成本实现更好的配置</a></div><span class="my_story_list_date">2020-10-22 23:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028427.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028427.html">铁锈中1和1=2的证明</a></div><span class="my_story_list_date">2020-10-13 20:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028278.html"><img src="http://img2.diglog.com/img/2020/10/thumb_112e8ad687703295c4a6e412456388da.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028278.html">C++中按返回类型重载</a></div><span class="my_story_list_date">2020-10-12 21:43</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>