<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从在流行的DBMS中发现400个错误的Bug Hunter中获得的经验教训</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">从在流行的DBMS中发现400个错误的Bug Hunter中获得的经验教训</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 03:59:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/4dcb5b2083e1adcccbc610e48f00ab68.jpg"><img src="http://img2.diglog.com/img/2020/10/4dcb5b2083e1adcccbc610e48f00ab68.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Finding logic bugs is an important part of building a reliable Database Management System (DBMS). But sometimes the most obvious approach doesn&#39;t work. You can&#39;t just query several databases and compare the results. You need a more sophisticated bug-hunting approach.</p><p>查找逻辑错误是构建可靠的数据库管理系统(DBMS)的重要组成部分。但有时最明显的方法也不管用。您不能只查询几个数据库并比较结果。您需要一种更复杂的错误搜索方法。</p><p> That&#39;s why we wanted you to meet Manuel Rigger. In this video, Manuel, a postdoctoral fellow at ETH Zurich, describes the techniques that have made him and his colleague, Professor Zhendong Su,  TiDB&#39;s #1  bug hunters. They&#39;ve  found over 50 TiDB bugs, and when you factor in their work with other popular DBMSs, they&#39;ve  found over 400.</p><p>这就是我们想让你见见曼纽尔·里杰的原因。在这段视频中，苏黎世理工大学博士后曼纽尔描述了使他和他的同事苏振东教授成为TiDB头号虫子猎手的技术。他们已经发现了50多个TiDB错误，当你考虑到他们与其他流行的DBMS一起工作时，他们已经发现了400多个错误。</p><p>  Manuel evaluates three techniques for finding logic bugs. Then, he gives us a demo of Non-optimizing Reference Engine Construction (NoREC), a simple, but not obvious approach to finding optimization bugs. With this technique alone, Manuel and his colleague have  found over 150 bugs.</p><p>Manuel评估了三种查找逻辑错误的技术。然后，他向我们演示了非优化参考引擎构造(NoREC)，这是一种简单但并不明显的查找优化bug的方法。仅用这项技术，曼纽尔和他的同事就发现了150多个错误。</p><p> As Manuel explains, the key to this method is rewriting query statements so the DBMS cannot optimize the query. Although this approach isn&#39;t intuitive, it&#39;s an effective way to find optimization bugs.</p><p>正如Manuel解释的那样，此方法的关键是重写查询语句，以便DBMS无法优化查询。虽然这种方法不直观，但它是发现优化错误的有效方法。</p><p> Manuel gave this talk at  TiDB DevCon 2020.Click the video link to watch Manuel take you step-by-step through his process. You can see the slides  here.</p><p>Manuel在TiDB DevCon 202上做了此演讲。单击视频链接观看Manuel带领您一步一步完成他的过程。你可以在这里看到幻灯片。</p><p>   Hello, everyone. My name is Manuel Rigger. I am a postdoctoral fellow at ETH Zurich. I am very grateful to  PingCAP for inviting me to introduce myself and my work. I am from Austria, 29 years old. I like to go hiking, go travelling, and play table tennis.</p><p>大家好。我叫曼纽尔·里杰。我是苏黎世理工学院的博士后研究员。我非常感谢PingCAP邀请我介绍我自己和我的工作。我来自奥地利，今年29岁。我喜欢徒步旅行、旅行和打乒乓球。</p><p> So, I&#39;m back from hiking, and now I want to take a couple of minutes to give an overview of our work on finding logic bugs in Database Management Systems (DBMSs), which is a project that I&#39;ve been working on together with Professor Zhendong Su, who leads the Advanced Software Technologies Lab at ETH Zurich.</p><p>所以，我刚徒步旅行回来，现在我想花几分钟概述一下我们在数据库管理系统(DBMS)中寻找逻辑错误的工作，这是我和苏振东教授(他是苏黎世理工学院高级软件技术实验室的负责人)一直在合作的一个项目。</p><p> So in our work, we have tested quite a number of popular and widely used DBMSs, including TiDB, and we&#39;ve found over 400 bugs so far.</p><p>因此，在我们的工作中，我们测试了相当多的流行和广泛使用的DBMS，包括TiDB，到目前为止，我们已经发现了400多个错误。</p><p> With respect to TiDB, we rank on place one in the  TiDB Bug-hunting Challenge Program, and overall we&#39;ve reported over 50 bugs, so far, for TiDB, also including those that we reported before this challenge.</p><p>关于TiDB，我们在TiDB漏洞搜索挑战计划中排名第一，到目前为止，我们已经为TiDB报告了50多个错误，还包括我们在此挑战之前报告的那些错误。</p><p> But let&#39;s first get a step back now and talk about our goal. So, our goal is to detect logic bugs in DBMSs.</p><p>但现在让我们先退一步，谈谈我们的目标。因此，我们的目标是检测DBMS中的逻辑错误。</p><p>  What are logic bugs? Well, I want to explain this on a concrete example. Namely, we have a client application, which sends a SQL query to the DBMS, which is TiDB in our case. Then, the DBMS is supposed to go through all the relevant records. So in this example here, we have three records, two for which the condition—this predicate here—evaluates to TRUE, and one for which it evaluates to FALSE. Consequently, we would expect that the result set that is returned comprises two rows; namely, those for which the condition evaluates to TRUE. However, in some cases it can happen that by sending the query to the DBMS, we trigger a bug, and in such a case it might happen that the result set that is returned is incorrect, such as in this case here, where only a single row rather than two are fetched, and we refer to these kinds of bugs as logic bugs. So those bugs, that result in the computation of an incorrect result set.</p><p>什么是逻辑错误？那么，我想用一个具体的例子来解释这一点。也就是说，我们有一个客户端应用程序，它向DBMS发送SQL查询，在我们的示例中是TiDB。然后，数据库管理系统应该检查所有相关记录。在本例中，我们有三条记录，其中两条条件(这里的谓词)的计算结果为true，另一条记录的条件计算结果为false。因此，我们预计返回的结果集包括两行；即条件计算为true的行。然而，在某些情况下，通过将查询发送到DBMS，我们可能会触发错误，在这种情况下，可能会发生返回的结果集不正确的情况，例如在这里的情况下，只提取一行而不是两行，我们将这些类型的错误称为逻辑错误。所以这些错误会导致错误结果集的计算。</p><p>  How could we tackle this? Well, the most obvious approach would be to use differential testing. Differential testing in this context basically means that we have a query generator, which we use to generate a query that we send to multiple DBMSs. For example, not only to TiDB, but also MariaDB and MySQL, which are the closest, or which are DBMSs with the closest SQL dialect to TiDB. Each of these DBMSs then fetches a result set, and we can compare all the three result sets in this example, and check if they are all the same. If not, we have likely found a bug in one of these systems. Unfortunately, differential testing is  not applicable for DBMSs.</p><p>我们怎么才能解决这个问题呢？嗯，最明显的方法是使用差异测试。在此上下文中的差异测试基本上意味着我们有一个查询生成器，我们使用它来生成发送给多个DBMS的查询。例如，不仅到TiDB，而且MariaDB和MySQL也是最接近的，或者是与TiDB的SQL方言最接近的DBMS。然后，这些DBMS中的每一个都会获取一个结果集，我们可以比较本例中的所有三个结果集，并检查它们是否都相同。如果没有，我们很可能在其中一个系统中发现了错误。不幸的是，差异测试不适用于DBMS。</p><p> Why do we claim this? Well, first of all, the common SQL core is rather small, and the DBMSs differ widely.</p><p>我们为什么要这样说呢？首先，公共SQL核心相当小，并且DBMS差别很大。</p><p> Now, for TiDB, you might argue that TiDB tries to support the MySQL SQL dialect to a large degree, but even there, we encountered a number of problems; for example, that MySQL and TiDB shared common bugs, in which case it was impossible to detect this. So, for example, here we opened a bug report where a TiDB developer mentioned that MySQL also is affected by the same underlying bug.</p><p>现在，对于TiDB，您可能会争辩说，TiDB试图在很大程度上支持MySQL方言，但即使这样，我们也遇到了许多问题；例如，MySQL和TiDB共享共同的bug，在这种情况下不可能检测到这一点。例如，我们在这里打开了一个bug报告，其中一位TiDB开发人员提到MySQL也受到相同底层bug的影响。</p><p> So, in order to tackle this we have been coming up with approaches to detect logic bugs in DBMSs. The first approach, or the approach that I focus on in my talk today, is Non-optimizing Reference Engine Construction (NoREC). NoREC is a simple, but also a non-obvious approach to finding specifically optimization bugs.</p><p>因此，为了解决这个问题，我们一直在想办法来检测DBMS中的逻辑错误。第一种方法，也就是我今天演讲中重点介绍的方法，是非优化参考引擎构造(NoREC)。NoREC是一种简单但也不明显的查找具体优化错误的方法。</p><p> Then, another approach that we have been working on is Pivoted Query Synthesis (PQS), which is a more powerful technique, but also more elaborate—and this point, I want to mention that PingCAP is actually the first company which has adopted this approach. Also other companies are following now, but Qiang Zhou (Efficiency Improvement Team Manager at PingCAP) and his team—they have successfully implemented it as the first company, so I want to thank them for their effort. Then, Ternary Logic Query Partitioning (TLP) is work-in-progress, and this is the approach that we have actually used to find the bugs that we reported for TiDB.</p><p>然后，我们一直在研究的另一种方法是枢轴查询合成(PQS)，这是一种更强大的技术，但也更精细-在这一点上，我想指出的是，PingCAP实际上是第一家采用这种方法的公司。其他公司现在也在效仿，但周强(PingCAP效率改进团队经理)和他的团队-他们作为第一家公司已经成功实施了它，所以我想感谢他们所做的努力。然后，三元逻辑查询分区(TLP)是正在进行的工作，这是我们实际上用来查找我们为TiDB报告的错误的方法。</p><p>  But let&#39;s focus on NoREC now, which is a simple, but non-obvious approach that I can also explain in a couple of minutes. And it allowed us to find over 150 bugs in widely-used DBMSs.</p><p>但现在让我们把注意力集中在NoREC上，这是一种简单但不明显的方法，我也可以在几分钟内解释一下。它允许我们在广泛使用的DBMS中发现150多个错误。</p><p> So as I mentioned, the approach specifically aims to find optimization bugs, which are an important subcategory of logic bugs. Namely, we can take the original motivating example and assume that the bug is caused by a bug in the query optimizer of TiDB, which causes this row to be omitted from the result set.</p><p>因此，正如我提到的，该方法特别旨在查找优化错误，这是逻辑错误的一个重要的子类别。也就是说，我们可以采用最初的激励示例，并假设bug是由TiDB的查询优化器中的bug引起的，这会导致从结果集中省略此行。</p><p> Now, what we would like to have is the following: Namely, we would like to have a version of TiDB where all the optimizations are enabled, and one where all of them are disabled. So, if you are familiar with C/C++ compilers like GCC or LLVM, you might know these optimization flags, where basically -O0 means that the majority of optimizations are turned off, and -O3, where the majority of optimizations are turned on. And, if you would have something like this, we could directly compare the result sets and spot errors caused by the query optimizer. Unfortunately, TiDB, but also the other DBMSs that we considered provide limited control over optimizations, so only a couple of options or flags, which do not help in detecting the majority of bugs.</p><p>现在，我们想要的是：也就是说，我们希望有一个启用所有优化的TiDB版本，以及一个禁用所有优化的版本。因此，如果您熟悉像GCC或llvm这样的C/C++编译器，您可能知道这些优化标志，其中-O0基本上表示关闭了大多数优化，-O3表示打开了大部分优化。而且，如果您有类似的东西，我们可以直接比较结果集并找出查询优化器导致的错误。不幸的是，TiDB以及我们认为的其他DBMS对优化提供了有限的控制，因此只有几个选项或标志，这无助于检测大多数错误。</p><p> So the idea that we had was that rather than relying on the DBMS, we could rewrite the query so that the DBMS cannot optimize it, and thus be able to find optimization bugs.</p><p>所以我们的想法是，我们可以重写查询，使DBMS无法对其进行优化，从而能够找到优化错误，而不是依赖于DBMS。</p><p> And we came up with the following translation routine. So, here you see the original query, where we have the WHERE rows and where the two rows are fetched for which the condition evaluates to TRUE. Now, the idea here is that we can basically take the condition from the WHERE clause and move it directly after the SELECT. And the question is: What effect does this now have? Well, this basically means that this predicate or condition is evaluated on every row in these tables here. Since we have three records in these tables, namely, two where the condition evaluates to TRUE and one where it evaluates to FALSE, we expect that the result set with three rows is returned, namely, two with the value TRUE, and one with value FALSE. There, we can basically see that for two rows the condition evaluates true. We can simply compare these two, and validate for this example here, that the expected result is computed.</p><p>我们想出了下面的翻译例程。因此，在这里您可以看到原始查询，其中我们有WHERE行，在哪里提取条件计算为true的两行。现在，这里的想法是，我们基本上可以从WHERE子句中提取条件，并将其直接移动到SELECT之后。问题是：这现在有什么影响？好的，这基本上意味着这个谓词或条件在这些表中的每一行上都被求值。由于我们在这些表中有三条记录，即两条条件的计算结果为TRUE，一条条件的计算结果为FALSE，因此我们预计会返回三行的结果集，即两行的值为TRUE，一行的值为FALSE。在这里，我们基本上可以看到，对于两行，条件的计算结果为真。我们可以简单地将这两个进行比较，并在此示例中验证预期结果是计算出来的。</p><p> And the intuition here is that the translated query cannot be efficiently optimized by the DBMS, because DBMSs typically try to be smart about only inspecting the necessary records, but here this condition has to be evaluated on every record, which disables most of the optimizations. So, if now there is a bug in the query optimizer—and for this example only a single row is fetched—we are able to detect these bugs, since there is a mismatch between the two rows for which the predicate evaluates to TRUE and the one row that is actually fetched. And this is basically already the approach that allowed us to detect this many bugs.</p><p>这里的直觉是DBMS不能有效地优化转换后的查询，因为DBMS通常试图聪明地只检查必要的记录，但这里必须对每条记录计算此条件，这会禁用大多数优化。因此，如果查询优化器中现在存在错误(在本例中，只提取了一行)，我们能够检测到这些错误，因为谓词的计算结果为true的两行与实际提取的一行之间存在不匹配。这基本上已经是让我们能够检测到这么多错误的方法了。</p><p> The concrete implementation of this approach: We implemented it in SQLancer, which soon will be available on GitHub, and SQLancer performs the following steps when using NoREC. First, it randomly generates a database, then it generates the optimized query, from which it derives the unoptimized query, and validates the result by checking that the optimized and unoptimized query are the same.</p><p>该方法的具体实现：我们在SQLancer中实现了它，不久将在GitHub上提供，SQLancer在使用NoREC时执行以下步骤。首先，它随机生成一个数据库，然后生成优化的查询，从中派生未优化的查询，并通过检查优化的查询和未优化的查询是否相同来验证结果。</p><p> And with that, I want to also give you a short demo to actually demonstrate that our approach works in practice and could have found many of the bugs in TiDB that we already reported.</p><p>到此为止，我还想给您一个简短的演示，以实际演示我们的方法在实践中是有效的，并且可以在TiDB中发现我们已经报告的许多错误。</p><p> So here you can see a bug report. This was a P1 bug, so quite a severe bug, and you can see here that we create a table, we then create a view, we insert into the table, and then we have this query here that fetches records from this.</p><p>因此，您可以在这里看到错误报告。这是一个P1错误，所以是一个相当严重的错误，您可以在这里看到，我们创建了一个表，然后我们创建了一个视图，我们将其插入到表中，然后我们在这里有一个从表中提取记录的查询。</p><p> So I&#39;m copying now these SQL statements. And here I&#39;m going to feed them to TiDB. Let&#39;s not look too deeply into what the query should actually do, but let&#39;s observe that here now an empty result set is returned. Now, let&#39;s translate this to the unoptimized query. So I&#39;m adding here this IS TRUE to force that the predicate is evaluated as a Boolean. And here you can actually see now that a row is returned with a value of 1, which basically means TRUE. And since we see here that a TRUE value is returned, we can infer that actually this query here [the one above] should have returned a single record, which was not the case, and thus, we would have been able to detect this bug in TiDB.</p><p>所以我现在要复制这些SQL语句。现在我要把它们喂给TiDB。让我们不太深入地研究查询实际应该做什么，但是让我们观察一下，现在返回了一个空的结果集。现在，让我们将其转换为未优化的查询。因此，我在这里添加这一点，以强制将谓词计算为布尔值。在这里，您实际上可以看到，返回一行的值为1，这基本上表示为真。因为我们在这里看到返回的是真值，所以我们可以推断，实际上这里的这个查询(上面的那个)应该返回单个记录，但事实并非如此，因此，我们应该能够在TiDB中检测到这个错误。</p><p> So, I hope that I could convince you that this simple, but non-obvious approach is actually quite useful to detect bugs, and I hope also that this overview of our ongoing research was interesting for you, and I hope you will have fun at the conference. And with this I say, thank you for listening and 加油 (&#34;come on&#34;) TiDB.</p><p>所以，我希望我能说服你们，这个简单但不明显的方法实际上对检测错误非常有用，我也希望我们正在进行的研究的概述会让你们感兴趣，我希望你们会在会议上玩得开心。在此，我要说，感谢你的收听和加油(#34；加油&34；)TiDB。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pingcap.com/blog/lessons-from-tidb-no.-1-bug-hunters-who-have-found-over-400-bugs-in-popular-dbmss">https://pingcap.com/blog/lessons-from-tidb-no.-1-bug-hunters-who-have-found-over-400-bugs-in-popular-dbmss</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bug/">#bug</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/popular/">#popular</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tidb/">#tidb</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>