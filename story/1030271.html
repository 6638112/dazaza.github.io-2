<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>高级GraphQL功能</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">高级GraphQL功能</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 16:44:22</div><div class="page_narrow text-break page_content"><p>在过去的几年里，GraphQL已经成为一个被广泛采用的标准。然而，并不是每个人都在利用该标准的全部功能。在本文中，我将演示创建更具表现力的模式以更好地满足您的数据需求的方法。</p><p>让我们从定义一个示例场景开始。我们正在构建一个论坛应用程序，它将拥有几种类型的用户：</p><p>管理论坛操作的管理员。例如，处理技术问题、指定版主等。</p><p>这样一个站点的架构可能是什么样子的？让我们从一个基本架构开始。此示例将使用Node Express和GraphQL项目。我假设您已经知道如何做到这一点，但稍后我将在本文的底部包含整个项目代码。创建一个typeDefs.ts文件，如下所示。请注意，我们使用的是TypeScript，因为类型注释有助于使代码更清晰。</p><p>从&#34；appollo-server-express&#34；导入{gql}；const typeDefs=gql`类型StandardUser{id：id！用户名：String！明星：int！}类型版主{id：id！用户名：String！星星：INT！类别：[类别！]}类型管理员{id：id！用户名：字符串！}类型类别{id：id！名称：String！}`；导出默认typeDefs；</p><p>您会注意到，我们有三个用户类型，以及一个名为Category的附加类型，它表示我们的帖子将进入的组。然而，很明显，我们的字段之间存在重复(例如，id、用户名)。实际上，可以从三个用户相关类型中的每一个中提取一个“基类型”。让我们尝试通过使用Interfaces更新此架构来实现此目的。</p><p>界面只是某种形式的骨架。它是一个声明规则的约定，在本例中是特定的字段，但是它没有实现，因此不能返回数据。只有类型可以。但是，因为它确实提供了结构，所以我们使用接口来定义基本字段，然后让我们的类型实现这些接口。例如，如果我们使用Interfaces更新typeDefs，它可能如下所示。</p><p>Const typeDefs=gql`接口可识别{id：id！}接口用户实现可识别{id：id！Username：string！}接口评级{STARS：INT！}类型StandardUser实现可识别的&amp；用户&amp；评级{id：id！用户名：String！STARS：INT！}类型版主实现可识别&amp；用户&amp；评级{id：id！用户名：String！星星：INT！类别：[类别！]}类型管理员实现可识别的&amp；用户{id：id！UserName：string！}类型类别实现可识别的{id：id！名称：String！}`；</p><p>如果我们从顶部开始，您将看到我们的第一个界面名为“可识别”。因为我们的数据模型中的所有实体都有一个惟一的ID，所以这个接口将是我们所有实体的基础。接下来，我们看到用户界面实现了可识别接口。请注意，用户如何同时拥有id字段和自己的字段(名为username)。当类型或接口实现接口时，它们必须实现其所有字段。</p><p>接下来，我们有另一个名为Rating的接口。因为我们的两个类型StandardUser和Master使用STARS字段，而管理员没有，所以我们有这个接口，以便只有使用STARS字段的类型才能实现它-否则，用户模型可以跳过它。</p><p>现在，我们终于拥有了实际的StandardUser、Master和Administrator类型，其中每个类型都使用&amp；符号表示要实现的多个接口，从而仅实现其所需的接口。最后是类别类型。</p><p>因此，正如您所看到的，这组类型和层次结构非常类似于大多数现代编程语言，例如TypeScript。</p><p>我们现在有了一个合理的模式模型。让我们试着查询一下。通过添加此查询更新typeDefs变量。</p><p>如您所见，我们添加了一个函数，该函数检索站点的所有用户，但将他们作为用户数组返回。现在让我们编写解析器，看看这是否可以工作。首先创建您的解析器文件，如下所示：</p><p>从&#34；Apollo-server-express&#34；导入{IResolvers}；从&#34；../dataService&#34；导入{GqlContext}；从&#34；导入{GqlContext}。/GqlContext&#34；；Const解析器：IResolvers={query：{getAllUsers：async(parent，args：null，ctx：GqlContext，info：any)：Promise&gt；=&gt；{return getAllUsers()；}，}，}；导出默认解析器；</p><p>我们的解析器唯一的操作是调用getAllUsers函数来检索实际数据。您会注意到，我们的getAllUsers解析器返回一个用户界面数组。这应该有点可疑，但现在让我们看看会发生什么。</p><p>现在，我们必须在代码中实现getAllUsers函数。但为了使本文更简单，并将重点放在GraphQL上，我们将创建一个返回硬编码值的函数。创建名为dataService.ts的文件并添加以下代码。</p><p>从&#34；uuid&#34；导入{v4}；导出接口可标识{id：string；}导出接口用户扩展可标识{username：string；}导出接口评级{STARS：NUMBER；}导出类StandardUser实现user{structor(public id：string，public username：string，public star：number){}}导出类版主实现user{structor(public id：string，public username：string，public star：number，public ategories：[类别]){}}导出类管理员实现user{structor(public id：string，public username：string){}}导出类类别实现可识别的{structor(public id：string，public name：string){}}export函数getAllUsers(){const Users：array=[]；Users.ush(new StandardUser(v4()，&#34；dave&#34；，4))；users.ush(new版主(v4()，&#34；Ruth&#34；，5，[new Category(v4()，&#34；Cooking&#34；)])；users.ush(new StandardUser(v4()，&#34；Jane&#34；，5))；users.ush(new StandardUser(v4()，&#34；tom&#34；，1))；Users.ush(new Administrator(v4()，&#34；linda&34；))；users.ush(new版主(v4()，&#34；tom&#34；，2，[new Category(v4()，&#34；Programming&#34；)])；users.ush(new Administrator(v4()，&#34；Betty&#34；))；返回用户；}。</p><p>我们的dataService包含反映我们的GraphQL模式的所有类型脚本类型，以及返回从用户界面继承的对象列表的getAllUsers函数。如您所见，getAllUsers使用所有类型的用户，包括StandardUsers和Administrators，但是由于他们都实现了用户界面(即User是所有用户的父类型)，所以函数的返回类型被设置为一组用户类型。现在让我们试着查询一下！</p><p>通过打开浏览器访问GraphQL服务器URL(类似于http://localhost：&lt；port Number&&gt;；/GraphQl)，打开您的GraphQL游乐场。然后添加此查询，如下所示。</p><p>这是我们对getAllUsers的查询，但是我们看到的不是字段，而是三个句点。我们看到的“…”称为内联片段。这将告诉GraphQL服务我们要查找的数据类型。在本例中，我们指出需要Interface User及其id和username字段。</p><p>因此，让我们尝试运行此查询，但当我们这样做时，会显示此错误。</p><p>这个错误意味着什么？如果我们回顾一下我们对GraphQL接口的定义，我们会说它们只有声明，没有实现。因此，我们需要将接口替换为接口的实现，即返回数据的类型。让我们看看如何做到这一点。</p><p>用户：{__Resolution veType(obj：any，ctx：GqlContext，info：any){if(obj.ategories){return&#34；；版主&#34；；}Else if(obj.star){return&#34；StandardUser&34；；}return&#34；Administrator&#34；；}，}，</p><p>通过在解析器中定义用户界面，我们告诉GraphQL，当它在查询中遇到用户时，应该返回列出的特定类型之一。请注意，如何确定这一点的逻辑完全取决于您。但是，一种明显的潜在方法是使用每种类型唯一的成员字段，就像我们在这里所做的那样。</p><p>显然，这是可行的，但是我们没有获得所有相关字段，并且很难判断每个返回的项是哪种类型。让我们稍微更新一下查询以显示这些详细信息。</p><p>如果我们遍历此查询，可以看到通过使用__typeName字段，我们可以获得结果集中每一项的类型名称。因此，这在一定程度上肯定有助于澄清一些事情。但是，只有StandardUser类型返回实际字段。显示了其他类型，但具体类型数据为空！我们需要做什么是很清楚的，所以让我们试一试吧。</p><p>正如您可能猜到的那样，我们需要添加其他类型及其特定字段。例如，在Master的情况下，我们有一个名为Categories的唯一字段，因为该类别也是它自己的类型，所以我们还从类型中指定了“name”成员。</p><p>现在我们已经把一切都准备好了！唉，还有一个小问题。即使在实现了这样的健壮类型之后，我们仍然要多次重复id和username字段。在这种情况下，这无关紧要。但是对于较大的数据模型，拥有几十个共享字段是相当容易的-想象一下重复指定所有这些字段！</p><p>我们已经看到了如何使用内联片段来指示我们想要的特定类型的字段，但是我们也可以使用片段来帮助减少重复。让我们像这样再次更新我们的查询。</p><p>那好多了。我们能够删除冗余并使我们的代码更干净。现在，让我们再做一次更改，以进一步改善情况。</p><p>GraphQL中的UNION是一种可以是几个类型定义之一的类型。例如，我们的模式类型的UNION可能是这样的。</p><p>如果我们现在让getAllUsers查询函数返回一个Result Union而不是User Interface，那么我们打算返回哪些特定类型就变得更加清楚了。此外，在较大的模式中，我们可能希望将UNION用于不同的目的，以便一个UNION在我们的模式中只能包含几个类型中的两个，而另一个UNION可能包含几个其他类型。</p><p>现在我们已经创建了一个Union，我们还需要为它创建一个解析器。对于我们的模式，解析器实现实际上可以与用户解析器相同。它看起来会是这样的。</p><p>结果：{__ResolveType(obj：any，ctx：GqlContext，info：any){if(obj.ategories){return&#34；；版主&#34；；}Else if(obj.star){return&#34；StandardUser&34；；}return&#34；Administrator&#34；；}，}，</p><p>如果您按原样重新运行最后一个查询，它的工作方式应该与以前相同。在我们的样例应用程序中，它恰好是相同的实现。在更完整、更现实的模式中，它可以也将是不同的-我们会有许多不同的类型，在将它们组合成一个UNION的方式上会有所不同。</p><p>在本教程中，我们向您介绍了接口、片段和联合。每个特性都可以帮助改进您的模式，使其更精确地符合您的数据需求，并且更易于查询。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.getcortexapp.com/post/more-sophisticated-schemas-with-advanced-graphql-features">https://www.getcortexapp.com/post/more-sophisticated-schemas-with-advanced-graphql-features</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1026627.html"><img src="http://img2.diglog.com/img/2020/9/thumb_30781efdb874f4497edbc80788b80215.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026627.html">关于GraphQL中“可嵌入字段”的建议</a></div><span class="my_story_list_date">2020-9-27 4:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1022772.html"><img src="http://img2.diglog.com/img/2020/9/thumb_958cc229c7ef1d75189575312ca93cd3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1022772.html">
Hasura筹集了2500万美元的B系列资金，并在其GraphQL服务中增加了对MySQL的支持</a></div><span class="my_story_list_date">2020-9-9 0:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1022650.html"><img src="http://img2.diglog.com/img/2020/9/thumb_803b3b7a76e49ef4a7e6dc20afe81dae.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1022650.html">在没有SDL的情况下向GraphQL架构添加指令</a></div><span class="my_story_list_date">2020-9-8 11:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019604.html"><img src="http://img.diglog.com/img/2020/8/thumb_9271efbd7560d4a88aa5081ff9236a38.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019604.html">我们[OkayCupid]决定不使用GraphQL进行当地州管理</a></div><span class="my_story_list_date">2020-8-22 0:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>