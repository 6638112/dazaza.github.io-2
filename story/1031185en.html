<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对Lisp语法的直观认识</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">对Lisp语法的直观认识</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 11:23:41</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/40becf456d568eb672f89c4d3aea36ca.png"><img src="http://img2.diglog.com/img/2020/10/40becf456d568eb672f89c4d3aea36ca.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Every lisp hacker I ever met, myself included, thought that all those brackets in Lisp were off-putting and weird. At first, of course. Soon after we all came to the same epiphany:  lisp’s power lies in those brackets! In this essay, we’ll go on a journey to that epiphany.</p><p>我遇到的每个LISP黑客，包括我自己，都认为Lisp中的所有括号都令人讨厌和奇怪。当然，一开始是这样的。不久之后，我们都得到了同样的顿悟：LISP的力量在于这些括号！在这篇文章中，我们将踏上一段通往那个顿悟的旅程。</p><p>  Say we were creating a program that let you draw stuff. If we wrote this in JavaScript, we might have functions like this:</p><p>假设我们正在创建一个让你画东西的程序。如果我们用JavaScript编写，我们可能会有如下函数：</p><p> drawPoint ({x:  0 , y:  1 },  &#39;yellow&#39; ) drawLine ({x:  0 , y:  0 }, {x:  1 , y:  1 },  &#39;blue&#39; ) drawCircle ( point ,  radius ,  &#39;red&#39; ) rotate ( shape ,  90 ) ...</p><p>DraPoint({x：0，y：1}，&#39；黄色&#39；)draLine({x：0，y：0}，{x：1，y：1}，&#39；蓝色&#39；)draCircle(point，Radius，&#39；；red&#39；)Rotate(Shape，90)...。</p><p>    This means that a user would be able to “send” instructions to your screen, and you would see their drawing come to life.</p><p>这意味着用户将能够向您的屏幕“发送”指令，您将看到他们的绘画栩栩如生。</p><p>  Well, say we set up a websocket connection. We could receive instructions from the user like this:</p><p>好吧，假设我们设置了一个网络插座连接。我们可以收到来自用户的指令，如下所示：</p><p>   To make it work off the bat, one option could be to take code strings as input:</p><p>要使其即时工作，一种选择是将代码字符串作为输入：</p><p>  Now the user could send  &#34;drawLine({x: 0, y: 0}, {x: 1, y: 1}, &#39;red&#39;)&#34; and bam: we’ll draw a line!</p><p>现在，用户可以发送&#34；draLine({x：0，y：0}，{x：1，y：1}，&#39；red&#39；)&#34；和bam：我们要画一条线！</p><p> But…your spidey sense may already be tingling. What if the user was malicious and managed to send us an instruction like this:</p><p>但是…。你的蜘蛛感可能已经刺痛了。如果用户是恶意的，并且设法向我们发送了如下指令，该怎么办：</p><p>  Uh oh…our cookie would get sent to iwillp3wn.com, and the malicious user would indeed pwn us. We can’t use eval; it’s too dangerous.</p><p>哦哦…。我们的cookie会被发送到iwill p3wn.com，而恶意用户确实会对我们进行攻击。我们不能用EVAL，太危险了。</p><p> There lies our problem: we can’t use  eval, but we need some way to receive arbitrary instructions.</p><p>这就是我们的问题所在：我们不能使用eval，但我们需要某种方式来接收任意指令。</p><p>  Well, we could represent those instructions as JSON. We can map each JSON instruction to a special function, and that way we can control what runs. Here’s one way we can represent it:</p><p>我们可以将这些指令表示为JSON。我们可以将每个JSON指令映射到一个特殊的函数，这样我们就可以控制运行什么。以下是我们可以表示它的一种方式：</p><p> {  instructions: [  { functionName:  &#34;drawLine&#34; , args: [{ x:  0 , y:  0  }, { x:  1 , y:  1  },  &#34;blue&#34; ] },  ]; }</p><p>{说明：[{functionName：&#34；drawLine&#34；，args：[{x：0，y：0}，{x：1，y：1}，&#34；Blue&#34；]}，]；}。</p><p>      Let’s see if we can clean this up. Here’s our JSON:</p><p>让我们看看能不能把这里清理干净。下面是我们的JSON：</p><p> {  instructions: [  { functionName:  &#34;drawLine&#34; , args: [{ x:  0 , y:  0  }, { x:  1 , y:  1  },  &#34;blue&#34; ] },  ]; }</p><p>{说明：[{functionName：&#34；drawLine&#34；，args：[{x：0，y：0}，{x：1，y：1}，&#34；Blue&#34；]}，]；}。</p><p> Well, since  every instruction has a  functionName, and an  args, we don’t really need to spell that out. We  could write it like this:</p><p>因为每条指令都有functionName和args，所以我们不需要详细说明。我们可以这样写：</p><p> {  instructions: [[ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  },  &#34;blue&#34; ]], }</p><p>{说明：[[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}，&#34；Blue&#34；]]，}</p><p> Nice! We changed our object in favor of an array. To handle that, all we need is a rule:  the   first  part of our instruction is the function name, and the  rest are arguments. If we wrote that down, here’s how our  onMessage would look:</p><p>好的!。我们将对象更改为支持数组。要处理这一点，我们只需要一条规则：指令的第一部分是函数名，其余部分是参数。如果我们把它写下来，我们的onMessage会是这样的：</p><p> websocket .onMessage ( data   =&gt;  {    const   fns   =  {  drawLine:  drawLine ,   ...  };   data . instructions .forEach (([ fnName ,  ... args ])  =&gt;   fns \[ fnName \]( ... args )); })</p><p>WebSocket.onMessage(data=&gt；{const fns={drawLine：drawLine，...}；data.。说明.forEach(([fnName，...。Args])=&gt；fns\[fnName\](...。Args))；})。</p><p>    drawLine ({x:  0 , y:  0 }, {x:  1 , y:  1 },  &#39;blue&#39; ) // same as [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }]</p><p>DrawLine({x：0，y：0}，{x：1，y：1}，&#39；Blue&#39；)//与[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]相同。</p><p>    [ &#34;rotate&#34; , [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }],  90 ]</p><p>[&#34；Rotate&#34；，[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]，90]。</p><p> Here, the  rotate instruction has an argument that is in  itself an instruction! Pretty powerful. Surprisingly, we just need to tweak our code a tiny bit to make it work:</p><p>这里，Rotate指令有一个本身就是指令的参数！相当强大。令人惊讶的是，我们只需稍微调整代码即可使其正常工作：</p><p> websocket .onMessage ( data   =&gt;  {    const   fns   =  {  drawLine:  drawLine ,   ...  };   const   parseInstruction   =  ( ins )  =&gt;  {   if  ( ! Array .isArray ( ins )) {   // this must be a primitive argument, like {x: 0 y: 0}   return   ins ;  }   const  [ fName ,  ... args ]  =   ins ;   fns \[ fName \]( ... args );  };   data . instructions .forEach ( parseInstruction ); })</p><p>WebSocket.onMessage(Data=&gt；{const fns={drawLine：drawLine，...}；const parseInstruction=(Ins)=&gt；{if(！Array.isArray(Ins)){//这必须是基元参数，如{x：0 y：0}return ins；}const[fName，...。Args]=INS；fns\[fName\](...。Args)；}；数据。指令.forEach(ParseInstruction)；})。</p><p> Nice, We introduce a  parseInstruction function. We can apply  parseInstruction recursively to arguments, and support stuff like:</p><p>不错，我们引入了parseInstruction函数。我们可以递归地将parseInstruction应用于参数，并支持如下内容：</p><p> [ &#34;rotate&#34; , [ &#34;rotate&#34; , [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }],  90 ]]]</p><p>[&#34；Rotate&#34；，[&#34；Rotate&#34；，[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]，90]]</p><p>    {  instructions: [[ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }]], }</p><p>{说明：[[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]]，}。</p><p>    Instead of a top-level key, we could have a special instruction called  do, which runs all the instructions it’s given.</p><p>我们可以有一个名为do的特殊指令，而不是顶级键，它运行它给出的所有指令。</p><p>  websocket .onMessage ( data   =&gt;  {    const   fns   =  {   ...   do : ( ... args )  =&gt;   args [ args .length  -   1 ],  };   const   parseInstruction   =  ( ins )  =&gt;  {   if  ( ! Array .isArray ( ins )) {   // this must be a primitive argument, like {x: 0, y: 0}   return   ins ;  }   const  [ fName ,  ... args ]  =   ins ;   return   fns \[ fName \]( ... args .map ( parseInstruction ));  };   parseInstruction ( instruction ); })</p><p>WebSocket.onMessage(数据=&gt；{const fns={...。做：(……。Args)=&gt；args[args.length-1]，}；const parseInstruction=(INS)=&gt；{if(！Array.isArray(Ins)){//这必须是基元参数，如{x：0，y：0}return ins；}const[fName，...。Args]=ins；返回fns\[fName\](...。Args.map(ParseInstruction)；}；parseInstruction(指令)；})。</p><p> Oh wow, that was easy. We just added  do in  fns. Now we can support an instruction like this:</p><p>哦，哇，那太简单了。我们刚刚在FNS中添加了DO。现在我们可以支持这样的指令：</p><p> [   &#34;do&#34; ,  [ &#34;drawPoint&#34; , { x:  0 , y:  0  }],  [ &#34;rotate&#34; , [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }],  90 ]], ];</p><p>[&#34；DO&#34；，[&#34；DrawPoint&#34；，{x：0，y：0}]，[&#34；Rotate&#34；，[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]，90]]，]；</p><p>    If we could support definitions, our remote user could write some very expressive instructions! Let’s convert our code to the kind of data structure we’ve been playing with:</p><p>如果我们可以支持定义，我们的远程用户就可以编写一些非常有表现力的指令！让我们将代码转换为我们一直使用的数据结构：</p><p> [ &#34;def&#34; ,  &#34;shape&#34; , [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }]] [ &#34;rotate&#34; ,  &#34;shape&#34; ,  90 ]</p><p>[&#34；def&#34；，&#34；Shape&#34；，[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]][&#34；Rotate&#34；，&#34；Shape&#34；，90]。</p><p> Noot bad! If we can support an instruction like that, we’d be golden! Here’s how:</p><p>没什么不好的！如果我们能支持这样的指令，我们就大功告成了！以下是方法：</p><p> websocket .onMessage ( data   =&gt;  {    const   variables   =  {};   const   fns   =  {   ...   def : ( name ,  v )  =&gt;  {   defs [ name ]  =   v ;  },  };   const   parseInstruction   =  ( ins )  =&gt;  {   if  ( variables [ ins ]) {   // this must be some kind of variable, like &#34;shape&#34;   return   variables [ ins ];  }   if  ( ! Array .isArray ( ins )) {   // this must be a primitive argument, like {x: 0 y: 0}   return   ins ;  }   const  [ fName ,  ... args ]  =   ins ;   return   fns \[ fName \]( ... args .map ( parseInstruction ));  };   parseInstruction ( instruction ); })</p><p>WebSocket.onMessage(数据=&gt；{常量变量={}；常量fns={...。Def：(name，v)=&gt；{defs[name]=v；}，}；const parseInstruction=(Ins)=&gt；{if(Variables[Ins]){//这必须是某种变量，如&#34；Shape&#34；Return Variables[Ins]；}If(！Array.isArray(Ins)){//这必须是基元参数，如{x：0 y：0}return ins；}const[fName，...。Args]=ins；返回fns\[fName\](...。Args.map(ParseInstruction)；}；parseInstruction(指令)；})。</p><p> Here, we introduced a  variables object, which keeps track of every variable we define. A special  def function updates that  variables object. Now we can run this instruction:</p><p>在这里，我们引入了一个Variables对象，它跟踪我们定义的每个变量。一个特殊的def函数会更新该Variables对象。现在我们可以运行以下指令：</p><p> [   &#34;do&#34; ,  [ &#34;def&#34; ,  &#34;shape&#34; , [ &#34;drawLine&#34; , { x:  0 , y:  0  }, { x:  1 , y:  1  }]],  [ &#34;rotate&#34; ,  &#34;shape&#34; ,  90 ], ];</p><p>[&#34；do&#34；，[&#34；def&#34；，&#34；Shape&#34；，[&#34；DrawLine&#34；，{x：0，y：0}，{x：1，y：1}]]，[&#34；旋转&#34；，&#34；Shape&#34；，90]，]；</p><p>   Let’s step it up a notch. What if we let our remote user  define their own functions?</p><p>让我们更上一层楼吧。如果我们让我们的远程用户定义他们自己的功能会怎么样？</p><p>  const   drawTriangle   =   function ( left ,  top ,  right ,  color ) {    drawLine ( left ,  top ,  color );   drawLine ( top ,  right ,  color );    drawLine ( left ,  right ,  color );  }  drawTriangle ( ... )</p><p>Const draTriangle=function(Left，top，right，color){drawLine(Left，top，color)；draLine(top，right，color)；DrawLine(Left，Right，color)；}DrawTriangle(...)。</p><p> How would we do it? Let’s follow our intuition again. If we transcribe this to our data representation, here’s how it could look:</p><p>我们该怎么做呢？让我们再跟着我们的直觉走一遍。如果我们将其转录为我们的数据表示形式，则如下所示：</p><p> [ &#34;def&#34; ,  &#34;drawTriangle&#34; ,  [ &#34;fn&#34; , [ &#34;left&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [ &#34;do&#34; ,  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;top&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  ],  ], ], [ &#34;drawTriangle&#34; , { x:  0 , y:  0  }, { x:  3 , y:  3  }, { x:  6 , y:  0  },  &#34;blue&#34; ],</p><p>[&#34；def&#34；，&#34；Drag三角形&#34；，[&#34；FN&#34；，[&#34；Left&#34；，&#34；，&#34；Right&#34；，&#34；color&#34；]，[&#34；Do&#34；，[&#34；DrawLine&#34；，&#34；Left&#34；，&#34；top&#34；，&#34；color&#34；]，[&#34；drawLine&#34；，&#34；top&#34；，&#34；right&#34；，&#34；color&#34；]，[&#34；drawLine&#34；，&#34；Left&#34；，&#34；right&#34；，&#34；color&#34；]，[&#34；draTriangle&#34；，{x：0，y：0}，{x：3，y：3}，{x：6，y：0}，&#34；蓝色&#34；]，</p><p>         All we need to do is to parse this instruction somehow, and bam, we are good to go!</p><p>我们所需要做的就是以某种方式解析这条指令，然后砰的一声，我们就可以开始了！</p><p>  The key to making this work is our  [&#34;fn&#34;, …] instruction. What if we did this:</p><p>完成这项工作的关键是我们的[#34；fn&#34；，…]。指令。如果我们这样做会怎么样：</p><p> const   parseFnInstruction   =  ( args ,  body ,  oldVariables )  =&gt;  {   return  ( ... values )  =&gt;  {   const   newVariables   =  {   ... oldVariables ,   ... mapArgsWithValues ( args ,  values ),  };   return   parseInstruction ( body ,  newVariables );  }; };</p><p>Const parseFnInstruction=(args，body，oldVariables)=&gt；{return(...。值)=&gt；{const newVariables={...。旧的变量，..。MapArgsWithValues(args，value)，}；return parseInstructions(Body，newVariables)；}；}；</p><p> When we find a  fn instruction, we run  parseFnInstruction. This produces a new javascript function. We would replace  drawTriangle here with that function:</p><p>当我们找到Fn指令时，我们运行parseFnInstruction。这将产生一个新的javascript函数。我们将使用该函数替换此处的DrawTriangle：</p><p> [ &#34;drawTriangle&#34; , { x:  0 , y:  0  }, { x:  3 , y:  3  }, { x:  6 , y:  0  },  &#34;blue&#34; ]</p><p>[&#34；draTriangle&#34；，{x：0，y：0}，{x：3，y：3}，{x：6，y：0}，&#34；蓝色&#34；]。</p><p>  [{ x:  0 , y:  0  }, { x:  3 , y:  3  }, { x:  6 , y:  0  },  &#34;blue&#34; ]</p><p>[{x：0，y：0}，{x：3，y：3}，{x：6，y：0}，&#34；蓝色&#34；]。</p><p>   Would create a new  variables object, that includes a mapping of the function arguments to these newly provided values:</p><p>将创建一个新的Variables对象，该对象包括函数参数到这些新提供的值的映射：</p><p> const   newVariables   =  {   ... oldVariables ,  left: { x:  0 , y:  0  },   top: { x:  3 , y:  3  },  right: {x:  6 , y:  0  },   color:  &#34;blue&#34; ,  }</p><p>Const newVariables={...。旧变量，左侧：{x：0，y：0}，顶部：{x：3，y：3}，右侧：{x：6，y：0}，颜色：&#34；蓝色&#34；，}。</p><p>  [   &#34;do&#34; ,  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;top&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  ],</p><p>[&#34；Do&#34；，[&#34；drawLine&#34；，&#34；Left&#34；，&#34；，&#34；color&#34；]，[&#34；DrawLine&#34；，&#34；top&#34；，&#34；，&#34；color&#34；]，[&#34；DrawLine&#34；]；，&#34；左&#34；，&#34；右&#34；，&#34；颜色&#34；]，]，</p><p> And run it through  parseInstruction, with our  newVariables. With that  &#34;left&#34; would be looked up as a variable and map to  {x: 0, y: 0}.</p><p>并使用我们的新变量通过parseInstructions运行它。这样，会将&#34；LEFT&#34；作为变量进行查找并映射到{x：0，y：0}。</p><p>   Let’s follow through on our plan. The first thing we need to do, is to have  parseInstruction accept  variables as an argument:</p><p>让我们继续执行我们的计划吧。我们需要做的第一件事是让parseInstructions接受变量作为参数：</p><p> const   parseInstruction   =  ( ins ,  variables )  =&gt;  {   ...   return   fn ( ... args .map (( arg )  =&gt;   parseInstruction ( arg ,  variables )));  };   parseInstruction ( instruction ,  variables );</p><p>Const parseInstruction=(ins，变量)=&gt；{...。返回fn(...。Args.map((Arg)=&gt；parseInstruction(arg，变量)；}；parseInstruction(指令，变量)；</p><p> Next, we’ll want to add a special check to detect if we have a “fn” instruction:</p><p>接下来，我们将添加一个特殊检查，以检测是否有“fn”指令：</p><p> const   parseInstruction   =  ( ins ,  variables )  =&gt;  {   ...   const  [ fName ,  ... args ]  =   ins ;   if  ( fName   ==   &#34;fn&#34; ) {   return   parseFnInstruction ( ... args ,  variables );  }   ...   return   fn ( ... args .map (( arg )  =&gt;   parseInstruction ( arg ,  variables )));  };   parseInstruction ( instruction ,  variables );</p><p>Const parseInstruction=(ins，变量)=&gt；{...。Const[fName，...。Args]=ins；if(fName==&#34；fn&#34；){return parseFnInstruction...。参数，变量)；}...。返回fn(...。Args.map((Arg)=&gt；parseInstruction(arg，变量)；}；parseInstruction(指令，变量)；</p><p>  const   mapArgsWithValues   =  ( args ,  values )  =&gt;  {    return   args .reduce (( res ,  k ,  idx )  =&gt;  {   res [ k ]  =   values [ idx ];   return   res ;  }, {}); } const   parseFnInstruction   =  ( args ,  body ,  oldVariables )  =&gt;  {   return  ( ... values )  =&gt;  {   const   newVariables   =  { ... oldVariables ,  ... mapArgsWithValues ( args ,  values )}   return   parseInstruction ( body ,  newVariables );  }; };</p><p>Const mapArgsWithValues=(args，Values)=&gt；{return args.duce((res，k，idx)=&gt；{res[k]=values[idx]；return res；}，{})；}const parseFnInstructions=(args，body，oldVariables)=&gt；{return(...。值)=&gt；{const newVariables={...。旧的变量，..。MapArgsWithValues(args，value)}return parseInstructions(Body，newVariables)；}；}；</p><p> It works exactly like we said. We return a new function. When it’s run, it:</p><p>它完全按照我们说的那样工作。我们返回一个新函数。当它运行时，它：</p><p>   const   parseInstruction   =  ( ins ,  variables )  =&gt;  {   ...   const  [ fName ,  ... args ]  =   ins ;   if  ( fName   ==   &#34;fn&#34; ) {   return   makeFn ( ... args ,  variables );  }   const   fn   =   fns [ fName ]  ||   variables [ fName ];   return   fn ( ... args .map (( arg )  =&gt;   parseInstruction ( arg ,  variables )));</p><p>Const parseInstruction=(ins，变量)=&gt；{...。Const[fName，...。Args]=ins；if(fName==&#34；fn&#34；){return makeFn(...。Args，Variables)；}const fn=fns[fName]||变量[fName]；返回fn(...。Args.map((Arg)=&gt；parseInstruction(arg，Variables)；</p><p>   Here, since  fn can now come from both  fns and  variables, we check both. Put it all together, and it works!</p><p>这里，由于fn现在既可以来自fn，也可以来自变量，所以我们同时检查两者。把所有这些放在一起，它就会起作用！</p><p> websocket .onMessage ( data   =&gt;  {    const   variables   =  {};   const   fns   =  {  drawLine:  drawLine ,  drawPoint:  drawPoint ,  rotate:  rotate ,   do : ( ... args )  =&gt;   args [ args .length  -   1 ],   def : ( name ,  v )  =&gt;  {   variables [ name ]  =   v ;  },  };   const   mapArgsWithValues   =  ( args ,  values )  =&gt;  {   return   args .reduce (( res ,  k ,  idx )  =&gt;  {   res [ k ]  =   values [ idx ];   return   res ;  }, {});  };   const   parseFnInstruction   =  ( args ,  body ,  oldVariables )  =&gt;  {   return  ( ... values )  =&gt;  {   const   newVariables   =  {   ... oldVariables ,   ... mapArgsWithValues ( args ,  values ),  };   return   parseInstruction ( body ,  newVariables );  };  };   const   parseInstruction   =  ( ins ,  variables )  =&gt;  {   if  ( variables [ ins ]) {   // this must be some kind of variable   return   variables [ ins ];  }   if  ( ! Array .isArray ( ins )) {   // this must be a primitive argument, like {x: 0 y: 0}   return   ins ;  }   const  [ fName ,  ... args ]  =   ins ;   if  ( fName   ==   &#34;fn&#34; ) {   return   parseFnInstruction ( ... args ,  variables );  }   const   fn   =   fns [ fName ]  ||   variables [ fName ];   return   fn ( ... args .map (( arg )  =&gt;   parseInstruction ( arg ,  variables )));  };   parseInstruction ( instruction ,  variables ); })</p><p>WebSocket.onMessage(Data=&gt；{const Variables={}；const fns={drawLine：DrawLine，DrawPoint：DrawPoint，Rotate：Rotate，Do：(...。Args)=&gt；args[args.length-1]，def：(name，v)=&gt；{变量[name]=v；}，}；const mapArgsWithValues=(args，value)=&gt；{return args.duce((res，k，idx)=&gt；{res[k]=values[idx]；return res；}，{})；}；Const parseFnInstruction=(args，body，oldVariables)=&gt；{return(...。值)=&gt；{const newVariables={...。旧的变量，..。MapArgsWithValues(args，Values)，}；return parseInstructions(body，newVariables)；}；}；const parseInstruction=(ins，Variables)=&gt；{if(Variables[Ins]){//这必须是某种变量返回变量[Ins]；}if(！Array.isArray(Ins)){//这必须是基元参数，如{x：0 y：0}return ins；}const[fName，...。Args]=ins；if(fName==&#34；fn&#34；){return parseFnInstruction...。Args，Variables)；}const fn=fns[fName]||变量[fName]；返回fn(...。Args.map((Arg)=&gt；parseInstruction(arg，变量)；}；parseInstruction(指令，变量)；})。</p><p>  [   &#34;do&#34; ,  [   &#34;def&#34; ,   &#34;drawTriangle&#34; ,  [   &#34;fn&#34; ,  [ &#34;left&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [   &#34;do&#34; ,  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;top&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  ],  ],  ],  [ &#34;drawTriangle&#34; , { x:  0 , y:  0  }, { x:  3 , y:  3  }, { x:  6 , y:  0  },  &#34;blue&#34; ],  [ &#34;drawTriangle&#34; , { x:  6 , y:  6  }, { x:  10 , y:  10  }, { x:  6 , y:  16  },  &#34;purple&#34; ], ])</p><p>[&#34；Do&#34；，[&#34；def&#34；，&#34；draTriangle&#34；，[&#34；FN&#34；，[&#34；Left&#34；，&#34；top&#34；，&#34；Right&#34；，&#34；color&#34；]，[&#34；Do&#34；，[&#34；DrawLine&#34；，&#34；左侧&#34；，&#34；顶部&#34；，&#34；color&#34；]，[&#34；DrawLine&#34；，&#34；顶部&#34；，&#34；右侧&#34；，&#34；颜色&#34；]，[&#34；drawLine&#34；，&#34；左侧&#34；，&#34；右侧&#34；，&#34；color&#34；]，[&#34；drawTriangle&#34；，{x：0，y：0}，{x：3，y：3}，{x：6，y：0}，&#34；蓝色&#34；]，[&#34；drawTriangle&#34；，{x：6，y：6}，{x：10，y：10}，{x：6，y：16}，&#34；紫色&#34；]，])。</p><p> We can compose functions, we can define variables, and we can even create our own functions. If we think about it, we just created a programming language!  1.</p><p>我们可以编写函数，我们可以定义变量，甚至可以创建我们自己的函数。如果我们仔细想想，我们刚刚创建了一种编程语言！</p><p>     We may even notice something interesting. Our new array languages has advantages to JavaScript itself!</p><p>我们甚至可能会注意到一些有趣的事情。我们新的数组语言比JavaScript本身更有优势！</p><p>  In JavaScript, you define variables by writing  const x = foo. Say you wanted to “rewrite”  const to be just  c. You couldn’t do this, because  const x = foo is special syntax in JavaScript. You’re not allowed to change that around.</p><p>在JavaScript中，您可以通过编写const x=foo来定义变量。假设您希望将const“重写”为c。您不能这样做，因为const x=foo是JavaScript中的特殊语法。你不能改变这一点。</p><p> In our array language though, there’s no syntax at all! Everything is just arrays. We could easily write some special  c instruction that works just like  def.</p><p>但是，在我们的数组语言中，根本没有语法！所有东西都只是数组。我们可以很容易地编写一些特殊的c指令，其工作方式与def类似。</p><p> If we think about it, it’s as though in Javascript we are guests, and we need to follow the language designer’s rules. But in our array language, we are “co-owners”. There is no big difference between the “built-in” stuff (“def”, “fn”) the language designer wrote, and the stuff we write! (“drawTriangle”).</p><p>如果我们仔细想想，就好像在Javascript中我们是客人，我们需要遵循语言设计者的规则。但在我们的数组语言中，我们是“共同所有者”。语言设计者编写的“内置”内容(“def”、“fn”)和我们编写的内容没有太大区别！(“Drawing Triangle”)。</p><p>  There’s another, much more resounding win. If our code is just a bunch of arrays, we can  do stuff to the code. We could write code that generates code!</p><p>还有另一个更响亮的胜利。如果我们的代码只是一堆数组，我们可以对代码做一些操作。我们可以编写生成代码的代码！</p><p>      This would be difficult to do. We’d need something like Babel to parse our file, and work on top of the AST to make sure we rewrite our code safely to</p><p>这是很难做到的。我们需要像babel这样的东西来解析我们的文件，并在AST之上工作，以确保我们安全地重写代码。</p><p>  But in our array language, our code is just arrays! It’s easy to rewrite  unless:</p><p>但是在我们的数组语言中，我们的代码只是数组！它很容易重写，除非：</p><p>     Having your code represented as data doesn’t just allow you to manipulate your code with ease. It also allows your editor to do it too. For example, say you are editing this code:</p><p>将代码表示为数据不仅仅允许您轻松地操作代码。它还允许您的编辑器也这样做。例如，假设您正在编辑此代码：</p><p>         If you’re editor understood these arrays, you can tell it: “expand” this area to the right:</p><p>如果您是了解这些数组的编辑，您可以告诉它：向右“展开”此区域：</p><p>       All of a sudden, instead of editing characters, you are editing the  structure of your code. This is called structural editing  2. It can help you move with the speed of a sculptor, and is one of the many wins you’ll get when your code is data.</p><p>突然之间，您编辑的不是字符，而是代码的结构。这就是所谓的结构化编辑2。它可以帮助你以雕刻家的速度移动，这也是当你的代码是数据时你将获得的众多胜利之一。</p><p>  Well, this array language you happened to have discovered…is a poorly implemented dialect of Lisp!</p><p>嗯，您碰巧发现的这种数组语言是…。是Lisp的一种实现不佳的方言！</p><p>  [   &#34;do&#34; ,  [   &#34;def&#34; ,   &#34;drawTriangle&#34; ,  [   &#34;fn&#34; ,  [ &#34;left&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [   &#34;do&#34; ,  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;top&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;top&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  [ &#34;drawLine&#34; ,  &#34;left&#34; ,  &#34;right&#34; ,  &#34;color&#34; ],  ],  ],  ],  [ &#34;drawTriangle&#34; , { x:  0 , y:  0  }, { x:  3 , y:  3  }, { x:  6 , y:  0  },  &#34;blue&#34; ],  [ &#34;drawTriangle&#34; , { x:  6 , y:  6  }, { x:  10 , y:  10  }, { x:  6 , y:  16  },  &#34;purple&#34; ], ])</p><p>[&#34；Do&#34；，[&#34；def&#34；，&#34；draTriangle&#34；，[&#34；FN&#34；，[&#34；Left&#34；，&#34；top&#34；，&#34；Right&#34；，&#34；color&#34；]，[&#34；Do&#34；，[&#34；DrawLine&#34；，&#34；左侧&#34；，&#34；顶部&#34；，&#34；color&#34；]，[&#34；DrawLine&#34；，&#34；顶部&#34；，&#34；右侧&#34；，&#34；颜色&#34；]，[&#34；drawLine&#34；，&#34；左侧&#34；，&#34；右侧&#34；，&#34；color&#34；]，[&#34；drawTriangle&#34；，{x：0，y：0}，{x：3，y：3}，{x：6，y：0}，&#34；蓝色&#34；]，[&#34；drawTriangle&#34；，{x：6，y：6}，{x：10，y：10}，{x：6，y：16}，&#34；紫色&#34；]，])</p><p>  ( do    ( def  draw-triangle ( fn  [left top right color]  ( draw-line  left top color)  ( draw-line  top right color)  ( draw-line  left right color)))  ( draw-triangle  { :x   0   :y   0 } { :x   3   :y   3 } { :x   6   :y   0 }  &#34;blue&#34; )  ( draw-triangle  { :x   6   :y   6 } { :x   10   :y   10 } { :x   6   :y   16 }  &#34;purple&#34; ))</p><p>(DO(定义绘制三角形(FN[左上右上颜色](画线左上颜色)(画线右上颜色)(绘制三角形{：x0：y0}{：x3：y3}{：x6：y0}&#34；蓝色&#34；)(绘制三角形{：x6：y6}{：x10：y10}{：x6：y16}&#34；紫色&#34；)。</p><p>        Now, if we agree that the ability to manipulate source code is important to us, what kind of languages are most conducive for supporting it?</p><p>现在，如果我们同意操纵源代码的能力对我们来说很重要，那么什么样的语言最有利于支持它呢？</p><p> One way we can solve that question is to rephrase it: how could we make manipulating code as intuitive as manipulating  data within  our code? The answer sprouts out: Make the code data! What an exciting conclusion. If we care about manipulating source code, we glide into the answer: the code  must be data  3.</p><p>我们可以解决这个问题的一种方法是重新表述：我们如何才能使操作代码与操作代码中的数据一样直观？答案冒出来了：制作代码数据！这是一个多么激动人心的结论。如果我们关心操纵源代码，我们就会得到答案：代码必须是数据3。</p><p> If the code must be data, what kind of data representation could we use? XML could work, JSON could work, and the list goes on. But, what would happen if we tried to find the simplest data structure? If we keep simplifying, we glide into to the simplest nested structure of all…lists!</p><p>如果代码必须是数据，那么我们可以使用什么样的数据表示呢？XML可以工作，JSON可以工作，不胜枚举。但是，如果我们试图找到最简单的数据结构，会发生什么呢？如果我们继续简化，我们就会滑向所有…中最简单的嵌套结构。清单！</p><p>  It’s illuminating, in the sense that it seems like Lisp is “discovered”. It’s like the solution to an optimization problem: if you care about manipulating code, you gravitate towards discovering Lisp. There’s something awe-inspiring about using a tool that’s discovered: who knows, alien life-forms could use Lisp!</p><p>它很有启发性，从某种意义上说，Lisp似乎是被“发现”的。这就像是优化问题的解决方案：如果您关心代码操作，那么您会倾向于使用Lisp。使用已发现的工具有一些令人敬畏的东西：谁知道，外星生命形式可能会使用Lisp！</p><p> It’s exciting, in that, there  may be a better syntax. We don’t know. Ruby and Python in my opinion where experiments, trying to bring lisp-like power without the brackets. I don’t think the question is a solved one yet. Maybe you can think about it 🙂</p><p>这很令人兴奋，因为可能有更好的语法。我们不知道。在我看来，Ruby和Python在哪里做实验，试图带来LISP式的功能，没有括号。我认为这个问题还没有解决。也许你可以考虑一下，🙂。</p><p>  You can imagine how expressive you can be if you can rewrite the code your language is written in. You’d truly be on the same footing as the language designer, and the abstractions you could write at that level, can add up to save you years of work.</p><p>您可以想象，如果您可以重写您的语言所用的代码，那么您的表现力会有多强。您将真正处于与语言设计人员相同的地位，并且您可以在该级别编写的抽象加起来可以节省您多年的工作。</p><p>   Thanks to Daniel Woelfel,  Alex Kotliarskyi, Sean Grove, Joe Averbukh, Irakli Safareli, for reviewing drafts of this essay</p><p>感谢Daniel Woelfel，Alex Kotliarskyi，Sean Grove，Joe Averbukh，Irakli Safareli审阅这篇文章的草稿</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/265">https://stopa.io/post/265</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>