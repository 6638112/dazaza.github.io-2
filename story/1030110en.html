<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>超快的Unicode(UTF-8)验证</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">超快的Unicode(UTF-8)验证</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 00:51:56</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/c72a4bdf84c77ccc3eff0558d5edc17a.jpg"><img src="http://img2.diglog.com/img/2020/10/c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>One of the most common “data type” in programming is the text string. When programmers think of a string, they imagine that they are dealing with a list or an array of characters. It is often a “good enough” approximation, but reality is more complex.</p><p>编程中最常见的“数据类型”之一是文本字符串。当程序员想到字符串时，他们会想象自己在处理一个列表或一个字符数组。这通常是一个“足够好”的近似值，但实际情况要复杂得多。</p><p> The characters must be encoded into bits in some way. Most strings on the Internet, including this blog post, are encoded using a standard called UTF-8. The UTF-8 format represents “characters” using 1, 2, 3 or 4 bytes. It is a generalization of the ASCII standard which uses just one byte per character. That is, an ASCII string is also an UTF-8 string.</p><p>字符必须以某种方式编码成位。互联网上的大多数字符串，包括这篇博客文章，都是使用一种名为UTF-8的标准进行编码的。UTF-8格式使用1、2、3或4个字节表示“字符”。它是ASCII标准的推广，每个字符只使用一个字节。也就是说，ASCII字符串也是UTF-8字符串。</p><p> It is slightly more complicated because, technically, what UTF-8 describes are code points, and a visible character, like emojis, can be made of several code points… but it is a pedantic distinction for most programmers.</p><p>它稍微复杂一些，因为从技术上讲，utf-8描述的是代码点，一个可见字符(如表情符号)可以由几个代码点…组成。但对于大多数程序员来说，这是一个迂腐的区别。</p><p> There are other standards. Some older programming languages like C# and Java rely on UTF-16. In UTF-16, you use two or four bytes per character. It seemed like a good idea at the time, but I believe that the consensus is increasingly moving toward using UTF-8 all the time, everywhere.</p><p>还有其他标准。一些较老的编程语言(如C#和Java)依赖于UTF-16。在UTF-16中，每个字符使用两个或四个字节。这在当时看起来是个好主意，但我相信，共识正越来越多地朝着随时随地使用UTF-8的方向发展。</p><p> What most character encodings have in common is that they are subject to constraints and that these constraints must be enforce. To put it another way, not any random sequence of bits is UTF-8. Thus you must validate that the strings you receive are valid UTF-8.</p><p>大多数字符编码的共同点是它们受到约束，并且这些约束必须强制执行。换句话说，并不是任何随机位序列都是UTF-8。因此，您必须验证收到的字符串是有效的UTF-8。</p><p> Does it matter? It does. For example, Microsoft’s web server had a security vulnerability whereas one could send URIs that would appear to the security checks as being valid and safe, but once interpreted by the server, would allow an attacker to navigate on the disk of the server. Even if security is not a concern, you almost surely want to reject invalid strings before you store them in your database as it is a form of corruption.</p><p>有关系吗？的确如此。例如，Microsoft的Web服务器存在安全漏洞，而用户可以发送在安全检查看来是有效和安全的URI，但一旦被服务器解释，就会允许攻击者在服务器的磁盘上导航。即使安全性不是问题，您几乎肯定希望在将无效字符串存储到数据库之前拒绝它们，因为这是一种损坏形式。</p><p> So your programming languages, your web servers, your browsers, your database engines, all validate UTF-8 all of the time.</p><p>因此，您的编程语言、Web服务器、浏览器、数据库引擎一直都在验证UTF-8。</p><p> If your strings are mostly just ASCII strings, then checks are quite fast and UTF-8 validation is no issue. However, the days when all of your strings were reliably ASCII strings are gone. We live in the world of emojis and international characters.</p><p>如果您的字符串大多只是ASCII字符串，那么检查速度会相当快，UTF-8验证是没有问题的。然而，所有字符串都是可靠的ASCII字符串的日子已经一去不复返了。我们生活在表情符号和国际字符的世界里。</p><p> Back in 2018, I started wondering…  How fast can you validate UTF-8 strings? The answer I got back then is a few CPU cycles per character. That may seem satisfying, but I was not happy.</p><p>早在2018年，我就开始想知道…。验证UTF-8字符串的速度有多快？我当时得到的答案是每个字符需要几个CPU周期。这可能看起来令人满意，但我并不高兴。</p><p> It took years, but I believe we have now arrived at what might be close to the best one can do: the lookup algorithm. It can be more than ten times faster than common fast alternatives. We wrote a research paper about it:  Validating UTF-8 In Less Than One Instruction Per Byte (to appear at Software: Practice and Experience).  We have also published our benchmarking software.</p><p>这花了几年时间，但我相信我们现在已经达到了可能是人们所能做的最好的东西：查找算法。它可以比常见的FAST替代产品快十倍以上。我们写了一篇关于它的研究论文：在每个字节少于一条指令的情况下验证UTF-8(将出现在软件：实践和体验中)。我们还发布了我们的基准软件。</p><p> Because we have a whole research paper to explain it, I will not go into the details, but the core insight is quite neat. Most of the UTF-8 validation can be done by looking at pairs of successive bytes. Once you have identified all violations that you can detect by looking at all pairs of successive bytes, there is relatively little left to do (per byte).</p><p>因为我们有一整篇研究论文来解释，所以我不会深入细节，但是核心的洞察力是相当整齐的。大多数UTF-8验证可以通过查看成对的连续字节来完成。一旦您确定了通过查看所有连续字节对可以检测到的所有违规，剩下的工作就相对较少了(每个字节)。</p><p> Our processors all have fast SIMD instructions. They are instructions that operate on wide registers (128 bits, 256 bits, and so forth). Most of them have a “vectorized lookup” instruction that can take, say, 16 byte values (in the range 0 to 16) and look them up in a 16-byte table. Intel and AMD processors have the  pshufb instruction that match this description. A value in the range 0 to 16 is sometimes called a nibble, it spans 4 bits. A byte is made of two nibbles (the low and high nibble).</p><p>我们的处理器都有快速的SIMD指令。它们是在宽寄存器(128位、256位等)上操作的指令。它们中的大多数都有一个“矢量化查找”指令，该指令可以获取16字节值(在0到16的范围内)，然后在16字节表中查找它们。英特尔和AMD处理器具有与此描述匹配的pShufb指令。范围在0到16之间的值有时称为半字节，它跨越4位。一个字节由两个半字节(低半字节和高半字节)组成。</p><p> In the lookup algorithm, we call a vectorized lookup instruction three times: once on the low nibble, once on the high nibble and once on the high nibble of the next byte. We have three corresponding 16-byte lookup tables. By choosing them just right, the bitwise AND of the three lookups will allow us to spot any error.</p><p>在查找算法中，我们调用矢量化查找指令三次：一次在低位半字节上，一次在高位半字节上，一次在下一个字节的高位半字节上。我们有三个相应的16字节查找表。通过恰到好处地选择它们，三个查找中的逐位AND将允许我们发现任何错误。</p><p> Refer to the paper for more details, but the net result is that you can validate almost entirely a UTF-8 string using roughly 5 lines of fast C++ code without any branching… and these 5 lines validate blocks as large as 32 bytes at a time…</p><p>有关更多详细信息，请参阅本文，但最终结果是，您可以使用大约5行快速C++代码验证几乎全部的UTf-8字符串，而无需任何分支…。并且这5行一次验证大小为32字节的块…。</p><p> simd8 classify (simd8 input , simd8 previous_input )  {  auto prev1  = input .prev &lt; 1 &gt; (previous_input ) ;  auto byte_1_high  = prev1 .shift_right  &lt; 4 &gt; ( ) .lookup_16 (table1 ) ;  auto byte_1_low  =  (prev1  &amp;  0x0F ) .lookup_16 (table2 ) ;  auto byte_2_high  = input .shift_right  &lt; 4 &gt; ( ) .lookup_16 (table3 ) ;   return  (byte_1_high  &amp; byte_1_low  &amp; byte_2_high ) ; }</p><p>Simd8分类(simd8输入，simd8上一次输入){AUTO PROVER1=输入.prev&lt；1&gt；(Previous_Input)；AUTO BYTE_1_HIGH=优先1.Shift_Right&lt；4&gt；().lookup_16(表1)；AUTO BYTE_1_LOW=(优先1&amp；0x0F).lookup_16(表2)；AUTO BYTE_2_HIGH=输入.Shift_Right&lt；4&gt；().lookup_16(表3)；RETURN(BYTE_1_HIGH&amp；BYTE_1_LOW&AMP；BYTE_2_HIGH)；}。</p><p> It is not immediately obvious that this would be sufficient and 100% safe.  But it is. You only need a few inexpensive additional technical steps.</p><p>目前还不清楚这是否足够和100%安全。但它是。您只需要几个便宜的额外技术步骤。</p><p> The net result is that on recent Intel/AMD processors, you need just under an instruction per byte to validate even the worse random inputs, and because of how streamlined the code is, you can retire more than three such instructions per cycle. Thus we consistently achieve speeds of over 12 GB/s.</p><p>最终结果是，在最新的Intel/AMD处理器上，即使是更糟糕的随机输入，也只需要每字节不到一条指令就可以验证，而且由于代码非常精简，每个周期可以停用三条以上这样的指令。因此，我们始终实现超过12 Gb/s的速度。</p><p> The lesson is that while lookup tables are useful, vectorized lookup tables are fundamental building blocks for high-speed algorithms.</p><p>教训是，虽然查找表很有用，但矢量化查找表是高速算法的基本构建块。</p><p> If you need to use the fast lookup UTF-8 validation function in a production setting, we recommend that you go through the  simdjson library (version 0.5 or better). It is well tested and has features to make your life easier like runtime dispatching. Though the simdjson library is motivated by JSON parsing, you can use it to just validate UTF-8 even when there is no JSON in sight. The simdjson supports 64-bit ARM and x64 processors, with fallback functions for other systems. We package it as a single header file along with a single source file; so you can pretty much just drop it into your C++ project.</p><p>如果您需要在生产设置中使用快速查找UTF-8验证功能，我们建议您查看simdjson库(0.5版或更高版本)。它经过了很好的测试，并且有一些功能可以让您的生活变得更轻松，比如运行时调度。虽然simdjson库是由JSON解析驱动的，但是即使在看不到JSON的情况下，您也可以使用它来验证UTF-8。Simdjson支持64位ARM和x64处理器，具有其他系统的后备功能。我们将其打包为单个头文件和单个源文件；因此，您几乎可以将其放入您的C++项目中。</p><p> Credit: Muła popularized more than anyone the vectorized classification technique that is key to the lookup algorithm. To my knowledge, Keiser first came up with the three-lookup strategy. To my knowledge, the first practical (non hacked) SIMD-based UTF-8 validation algorithm was crafted by K. Willets. Several people, including Z. Wegner showed that you could do better. Travis Downs also provided clever insights on how to accelerate conventional algorithms.</p><p>功劳：Muł比任何人都普及了矢量化分类技术，这是查找算法的关键。据我所知，Keiser最先提出了三查策略。据我所知，第一个实用的(非破解的)基于SIMD的UTF-8验证算法是由K.Willets设计的。包括Z.Wegner在内的几个人表明，你可以做得更好。特拉维斯·唐斯还就如何加速传统算法提供了聪明的见解。</p><p> Further reading: If you like this work, you may like  Base64 encoding and decoding at almost the speed of a memory copy (Software: Practice and Experience 50 (2), 2020) and  Parsing Gigabytes of JSON per Second (VLDB Journal 28 (6), 2019).</p><p>进一步阅读：如果您喜欢这项工作，您可能会喜欢以几乎与内存副本相同的速度进行Base64编码和解码(软件：实践和经验50(2)，2020)和每秒解析千兆字节的JSON(VLDB Journal 28(6)，2019年)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lemire.me/blog/2020/10/20/ridiculously-fast-unicode-utf-8-validation/">https://lemire.me/blog/2020/10/20/ridiculously-fast-unicode-utf-8-validation/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/utf-8/">#utf-8</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/unicode/">#unicode</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fast/">#fast</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字节/">#字节</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>