<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>凭借读过太多“教程”的人的函数和Monads Functors and Monads for People Who Have Read Too Many “Tutorials”</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Functors and Monads for People Who Have Read Too Many “Tutorials”<br/>凭借读过太多“教程”的人的函数和Monads </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 08:44:01</div><div class="page_narrow text-break page_content"><p>Title is literally true. This may not be the best place to learn about these concepts for the first time, because I&#39;m going to focus on knocking down the misconceptions about them.</p><p>标题实际上是真的。这可能不是第一次了解这些概念的最佳位置，因为我将专注于敲击对他们的误解。</p><p>  I had promised myself I would not add to the pile of functor or monad &#34;tutorials&#34;, but I&#39;ve been worn down. I gave up when I saw a reddit comment complaining about how Functor was &#34;too hard to understand&#34;, which made me sad, because the correct response to the Functor interface is, &#34;That&#39;s it?&#34;. And while Monad is legitimately a bit more interesting and complex, the correct response to that is not that different.</p><p>  我曾答应自己，我不会加入堆上的函件或monad＆＃34;教程＆＃34;但我戴着斗争。当我看到一个红线评论时，抱怨归赛跑者是如何理解的，这太难以理解了，这让我感到难过，因为对函数界面的正确响应是，＆＃34;那个＆＃39; s它？＆＃34;。虽然Monad合法有点有趣和复杂，但对这不是一个不同的反应。</p><p> I am aware of the notorious effect that people &#34;get&#34; monads and then post their own idiosyncratic takes on them. In my defense, this isn&#39;t something I write just after my &#34;ah ha!&#34; moment, I&#39;ve understood them in Haskell&#39;s context for many years now, and actually... this isn&#39;t even about that &#34;ah ha!&#34; moment at all. This is only about  what they are. Even if you completely understand everything I write in this post, the real &#34;ah ha!&#34; where you realize just how useful the libraries built up around the monad interface are, the first time you search for a type on  Hoogle where you&#39;re like  this should exist and it turns out it does in fact exist already, that&#39;s still in your future. In fact I&#39;m quite  deliberately not trying to convey that feeling in the interests of getting at simply  what the monad interface is. Which isn&#39;t, strictly speaking, a pre-requisite to that experience, but it does help.</p><p> 我知道人们的臭名昭着的影响;＆＃34; Monads然后发布他们自己的特质，占据了他们。在我的辩护中，这不是我写的东西在我的＆＃34之后写的东西！啊哈！＆＃34;时刻，我在Haskell＆＃39的情况下了解他们多年的上下文，实际上......这个不是关于那个＆＃34;啊HA！＆＃34;一瞬间。这只是关于它们的东西。即使你完全了解我在这篇文章中写的一切，也是真实的＆＃34;啊哈！＆＃34;在哪里实现了Monad接口周围建立的图书馆的有用是有用的，首次搜索＆＃39的obogle上的类型; re喜欢这应该存在，事实证明它实际上已经存在，那个＆＃39仍然在你的未来。事实上，我很故意没有试图传达这种感觉，以简单地获得Monad接口是什么。哪个是＆＃39; t，严格来说，这是一个经验的先决条件，但它确实有所帮助。</p><p>    Fact: If you have a source of  Blobs, and a function that can turn a  Blob into a  Thing, you can put them together to create a source of  Things.</p><p>    事实：如果您有一个斑点的源头，并且可以将blob变成一件事的函数，您可以将它们放在一起以创建一个事物来源。</p><p>  If I have A: a list of integers, and B: a function to convert integers to strings, I can easily create C: a list of strings.</p><p>  如果我有一个：一个整数列表，b：一个函数要将整数转换为字符串，我可以轻松地创建c：字符串列表。</p><p> If I have A: a hash table of integers to strings, and B: a function to convert strings to booleans, I can have C: a hash table of integers to booleans.</p><p> 如果我有一个：一个散列表到字符串，b：将字符串转换为booleans的函数，我可以拥有c：一个整数的哈希表到booleans。</p><p> Duh. Obviously. The only reason it sounds even slightly complicated is just that English doesn&#39;t have a good equivalent for a &#34;variable&#34;, so it always sounds complicated when you have a sentence with them. The concept itself is, if not ELI5, well within the ELI12 range.</p><p> 杜。明显地。它听起来甚至略微复杂的唯一原因只是英国人＆＃39; t对A＆＃34有很好的相当于一个＆＃34;变量＆＃34;当你与他们判刑时，它总是听起来很复杂。概念本身如果不是ELI5，那么在ELI12范围内。 </p><p> I don&#39;t say  how I get from A and B to C. Each case is different, but simple every time. Takes more English words to say it than implementing it in your favorite language would.</p><p>我不会说我从A和B到C到C.每种情况都不同，但每次都很简单。采用更多的英语单词来说它而不是在你喜欢的语言中实施它。</p><p> What is functor then? Functor is an  interface (or &#34;trait&#34;, &#34;concept&#34;, &#34;typeclass&#34; or whatever your language favors; &#34;interface&#34; from now on as I am deliberately trying to use more common terminology) that allows you to refer to the fact above as a first-class language element. In Haskell&#39;s case,  Functor, which is implemented by providing an  fmap implementation. For the above examples, that function will:</p><p> 什么是归韵特？仿函数是一个接口（或＆＃34; trait＆＃34;＆＃34;概念＆＃34;＆＃34; typeclass＆＃34;或者你的语言偏好;＆＃34;界面＆＃34;从现在开始我故意尝试使用更多常见的术语），允许您将上图作为一流语言元素的事实。在Haskell＆＃39; S案例，通过提供FMAP实现来实现的函数。对于上述示例，该功能将：</p><p> List implementation: Take the function in B and run it on all my elements and return a new list, commonly called  map.</p><p> 列表实现：拍摄B中的函数并在所有元素上运行它并返回一个名单，通常称为地图。</p><p> Hash table implementation: Take the function in B and run it on all my values, return a new hash table with the same keys and new values.</p><p> 哈希表实现：拍摄B中的函数并在所有值上运行它，返回具有相同密钥和新值的新哈希表。</p><p> Function implementation: Return a function that runs the function in A, then runs the function in B on the result. This is commonly called function composition.</p><p> 函数实现：返回运行函数的函数，然后在结果中运行B中的函数。这通常称为功能组合。</p><p> The last one is slightly tricky, but if you think of functions in their metaphor as black boxes that take input on the left and provide their output on the right, that&#39;s just taking the second function and slamming it on the right side of the first to create a new one. This is why I say &#34;source of&#34; something; the principle here is  very general and extends beyond functions, containers, and all the other convenient words I have... it applies to  anything you might obtain a value from.</p><p> 最后一个是略有棘手的，但是如果你认为他们的隐喻中的函数作为在左侧输入的黑匣子并在右侧提供它们的输出，那就是在右侧猛击它的＆＃39; s刚刚撞击它第一个创造一个新的。这就是为什么我说＆＃34;＆＃34的来源;某物;这里的原理是非常一般的，延伸超出功能，容器和我所拥有的所有其他方便的单词......它适用于您可能获得的任何值。</p><p>   That is literally all it is; a way of discussing that simple operation coherently across a whole bunch of types.</p><p>   这实际上是它的一切;一种讨论这种简单的操作，在整个一堆类型中讨论了简单的操作。 </p><p>  Because even setting aside the occasional outright writer confusion, it&#39;s easy to get too excited in a blog post and end up conflating  what a functor is with  what we can build on it.</p><p>因为甚至在偶尔彻底的作家混乱，它＆＃39;很容易在博客帖子中太兴奋，最终与我们能够建立的东西。</p><p> I&#39;m going to repeatedly analogize to a more commonly-understood interface throughout the rest of this post: Iterator. Why is Functor &#34;important&#34; or &#34;interesting&#34;? For the same reason the iterator interface is. Iterators existed since the beginning of programming, just as &#34;functors&#34; did. Individual iterator implementations are typically quite boring, sometimes even outright trivial, like iterating along an array. But if you have a whole bunch of ad-hoc implementations of &#34;iterators&#34; that don&#39;t fit together, you can&#39;t create an  itertools package. Once you have a common contract and a coherent name, you can start building on top of what used to be a chaotic mess of almost-but-not-quite-the-same implementations.</p><p> 我将在本篇文章的其余部分中重复一致化为更常见的界面：迭代器。为什么汇流符＆＃34;重要＆＃34;或＆＃34;有趣的＆＃34 ;?出于同样的原因，迭代器界面是。自编程开始以来存在迭代器，就像＆＃34;仿函数＆＃34;做过。单个迭代器实现通常非常无聊，有时甚至是彻头彻尾的微不足道，例如沿着阵列迭代。但如果你有一堆＆＃34的ad-hoc实现;迭代器＆＃34;那个＆＃39; t融合在一起，你可以＆＃39; t创建一个斜衣包。一旦您有一个常见的合同和连贯的名称，您就可以在曾经是几乎 - 但不相同的实现的混乱混乱的顶部开始建立。</p><p> As a modern example of a language missing this, Go lacks any sort of language or library support for &#34;iterators&#34;, and consequently there are at least three iteration patterns in common use and a modestly common antipattern (using  range over channels, which has decent semantics but horrible performance for most use cases). Lacking this concept, Go also lacks anything like  itertools or a similarly-useful library.</p><p> 作为失踪的语言的现代示例，Go缺少任何类型的语言或图书馆支持和＃34;迭代器＆＃34;，因此共同使用中至少有三个迭代模式，并且常见的常见反饰特（使用范围频道，具有体面的语义，但对于大多数用例而言，性能可怕）。缺乏这一概念，也缺乏迭代机或类似的图书馆等任何东西。</p><p> It is exactly the same with functor. Just as a variety of functions are now possible and useful that only know they are taking &#34;an iterator&#34;, by having a named, coherent &#34;functor&#34; concept in the language functions can be written that take advantage of the common functionality.</p><p> 它与仿函数完全相同。正如现在可能的各种功能一样并且只知道他们正在服用它们的效果和＃34;迭代器＆＃34;通过命名，连贯＆＃34;函数＆＃34;可以编写语言函数中的概念，从而利用常用功能。</p><p> It is important not to credit complexity of particular implementations to the complexity of the interface. Behind an interface of  function () string could lie a constant return of some particular string, or  a series of events that takes nearly a full book to explain by fetching a web page and returning its text... but the latter&#39;s complexity should be accounted solely to that particular implementation, not the  function () string interface it can conform to.</p><p> 重要的是对界面的复杂性进行特定实现的信用复杂性。函数（）字符串的界面后面可以呈现某些特定字符串的常量返回，或者通过获取网页并返回其文本来解释几乎全书的一系列事件......但是后者＆＃39; s复杂性应仅考虑到特定的实现，而不是它可以符合的函数（）字符串接口。</p><p> Similarly, a functor may be as simple as mapping the incoming function over a list, or it may require an arbitrarily-complicated traversal over a data structure like a skip list and construction of a new one. But that is not a complicated operation because &#34;functors are complicated&#34;, it is a complicated operation because skip lists are complicated. The functor interface itself does not account for the complication.</p><p> 类似地，算法可以像映射到列表中的传入功能一样简单，或者它可能需要在数据结构上进行任意复杂的遍历，例如跳过列表和新的一个新的遍历。但这不是一个复杂的操作，因为＆＃34;仿函数复杂，而且它是一个复杂的操作，因为跳过列表很复杂。 Functor接口本身不会占复杂。</p><p> It is important not to credit the complexity of what we can  do with iterators to implementations of the interface. It is possible to take three iterators, reverse one of them, combine two others with a reduction function, and take only the prime indexed values from the result, but that doesn&#39;t affect the fact that an iterator is just a function you call to get &#34;the next value&#34;.</p><p> 重要的是不要借鉴我们可以处理迭代器的复杂性以实现界面的实现。可以采取三个迭代器，反转其中一个迭代器，将另外两个与减少函数组合，并仅从结果中占据Prime索引值，但这不会影响迭代器只是函数的事实打电话给Get＆＃34;下一个值＆＃34; </p><p>   For their own good reasons, mathematicians use &#34;functor&#34; as a concrete noun. Haskell copied this, hence how often you hear about &#34;a functor&#34;.</p><p>出于他们自己的原因，数学家使用＆＃34;函数＆＃34;作为一个具体的名词。 Haskell复制了这一点，因此您多久听到一次＆＃34;函授＆＃34;</p><p> However, interfaces are  adjectives that describe a data structure, which is why in many languages they are often named with  -able suffixes (Iterable, Serializable, etc.) Programmers are better off thinking of it as Functable or Fmapable or something like that.</p><p> 但是，接口是描述数据结构的形容词，这就是为什么它们通常以许多语言命名为可行的后缀（可迭代，可序列化等）程序员更好地忽略它作为可用或欺骗或类似的东西或类似的东西。</p><p> Unfortunately, we do not have a pre-existing verb form for &#34;using the Functor interface&#34; the way we have &#34;iterate on&#34; for Iterable or &#34;serialize&#34; for Serializable. The closest we have is &#34;map on&#34;, and that is deceptive because that term usually has the mental image of some concrete data structure, possibly only and exactly a list, being mapped on, despite it being much more general. I recommend taking a nonsense term like Functable and owning it, rather than jamming a square concept into a round concept hole.</p><p> 不幸的是，我们没有＆＃34的预先存在的动词形式;使用函数界面＆＃34;我们的方式＆＃34;迭代＆＃34;对于可迭代或＆＃34;序列化＆＃34;用于序列化。我们最接近的是＆＃34;地图＆＃34;这是欺骗性的，因为该术语通常具有一些具体数据结构的心理形象，可能只是一个列表，映射，尽管它更普遍。我建议采取一个无意义的术语，如功能和拥有它，而不是用正方形概念卡入圆形概念洞。</p><p> If you find yourself confused, I recommend literally saying &#34;Functable&#34; to yourself. Eventually you will naturally start to hear Functor as just a synonym for how you say it to yourself. You may also consider &#34;Functionable&#34;, which is perilously close to &#34;functional&#34;, but carries the idea of &#34;we can apply a function to it&#34;, albeit a very particular function with a certain signature.</p><p> 如果你发现自己困惑，我建议＆＃34;可用和＃34;对自己。最终，您将自然地开始听到仿函数只是你对自己的说法的同义词。您也可以考虑＆＃34;功能＆＃34;，它易于靠近＆＃34;功能＆＃34;，但带来＆＃34的想法;我们可以将函数应用于它＆＃34;，尽管是一个具有一定签名的特殊功能。</p><p> In the context of the post you are reading right now, this may feel like nitpicking. However, I think it is actually a very significant contributor to the problem people have with understanding the functor and monad interfaces. I&#39;ve tried to carefully use those words in this post consistently as adjectives, because when you use them as nouns it becomes very confusing as you try to treat them as you treat most nouns. A lot of people speak as if you can have &#34;a functor&#34; or &#34;a monad&#34; in your hand, and start trying to talk about what they &#34;do&#34; stripped away from the context of the specific implementation in question. But you can&#39;t do that, any more than you can speak about the specific implementation of &#34;an iterator&#34; stripped away from what it is a specific implementation  for. Treating &#34;monad&#34; and &#34;functor&#34; as nouns leads to a lot of confusion.</p><p> 在你现在阅读的帖子的上下文中，这可能会觉得自己是尼特。但是，我认为它实际上是人们对理解函授和Monad界面的问题的重要贡献者。我试图在这篇文章中一直仔细使用这些词语作为形容词，因为当你用它们作为名词时，你会在你对待大多数名词时尝试对待它们时变得非常令人困惑。很多人都说好像你可以拥有＆＃34;一个函数＆＃34;或＆＃34;一个monad＆＃34;在你的手中，开始尝试谈论他们的＆＃34;做＆＃34;从有关具体实施情况的背景下剥夺。但是你可以＆＃39; t这样做，比你能谈论和＃34的具体实施;一个迭代器＆＃34;剥夺了它是一个具体实施的东西。治疗＆＃34; Monad＆＃34;和＆＃34;函数＆＃34;因为名词导致很多混乱。</p><p>  Functor can be applied to a number of things that aren&#39;t containers. We&#39;ve seen that already with functions. It is a common mistake in non-Haskell implementations to assume that functor implementations can only go on containers.</p><p>  仿函数可以应用于areN＆＃39; t容器的许多东西。我们已经看到了已经有职能的＆＃39。在非Haskell实现中是一个常见的错误，以假设算子实现只能继续容器。</p><p> When I bring this up online, inevitably someone says something like &#34;Well, if you squint hard enough, functions are containers, and those other things are containers, and so on, so they do always work on containers.&#34; To that I say, if everything is a container, then the word container has no meaning. I think when you&#39;re rendering useful words meaningless just to conform to your misconceptions that you&#39;re stepping into a maze of mirrors that is only going to confuse you. The most sensible approach is to discard the misconception and understand that functors are not always containers.</p><p> 当我在线提出这个时，不可避免地有人说＆＃34;嗯，如果你眯着电脑，功能是容器，那些其他东西是容器，所以他们始终在容器上工作。＆＃34 ;对于我说，如果一切都是一个容器，那么这个词容器没有意义。我想你的时候＆＃39;重新渲染有用的词语只是为了符合你的误解，你跳进你的迷宫迷宫，只是迷惑你的镜子。最合理的方法是丢弃误解并理解算子并不总是容器。 </p><p>     looks like you are calling the function &#34;fmap&#34; with two parameters, a function to add one to integers and a list of integers. This can compound confusion when functor is thought of as a noun, because, what is fmap? Maybe it&#39;s a part of &#34;functor&#34;? In OO languages, functions do not have any sort of interface resolution on them.</p><p>看起来你呼吁这个功能＆＃34; fmap＆＃34;使用两个参数，一个将一个添加到整数的函数和整数列表。当仿函数被认为是名词时，这可以复合混淆，因为，什么是fmap？也许是＆＃39;＆＃34;函数＆＃34 ;?在OO语言中，函数在它们上没有任何类型的接口分辨率。</p><p>   that is, a method call on a list. In fact it isn&#39;t even particularly relevant at this point that &#34;fmap&#34; participates in an interface, because this is all statically-resolvable at compile time, just as it would be in many other languages. Laid out this way, an OO programmer has no problem imagining that resolving &#34;fmap&#34; may involve looking at the definition of the list itself.</p><p>   也就是说，在列表上调用方法。事实上它甚至特别相关，此时＆＃34; fmap＆＃34;参与一个接口，因为这在编译时都是静态可解决的，就像它是许多其他语言一样。这样做，OO程序员没有想象解决解决和＃34; FMAP＆＃34;可能涉及查看列表本身的定义。</p><p> This is not how Haskell resolves names. It isn&#39;t an object-oriented name. But if you don&#39;t want to learn Haskell and merely want to learn about what all this &#34;monad&#34; and &#34;functor&#34; hype is, this is a  better metaphor for what Haskell is doing than thinking of  fmap as some sort of weird magical function. It&#39;s  closer to a method name resolving to an &#34;fmap&#34; implementation on a particular data structure. (Which, again, isn&#39;t  quite what&#39;s going on; it&#39;s just close enough for now.)</p><p> 这不是Haskell如何解析名称。它是一个面向对象的名称。但如果你不想学习Haskell并仅仅想了解所有这一切＆＃34; Monad＆＃34;和＆＃34;函数＆＃34;炒作是，这是一个更好的比喻，因为哈斯克尔正在做什么而不是对FMAP的想法作为某种奇怪的魔法功能。它靠近方法名称解析为＆＃34; fmap＆＃34;在特定数据结构上实现。 （再次，ISN＆＃39; t相当鲜明的;它现在足够接近了。）</p><p>   class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b</p><p>   fmap ::（a  - ＆gt; b） - ＆gt; f a  - ＆gt; F B.</p><p> This just says, if you have a way of taking an  a and producing a  b, and you have a source of  as, you can have a source of  bs.</p><p> 这只是说，如果你有一种拍摄A和产生B的方法，你有一个源头，你可以拥有BS的源头。</p><p>  This is the  full definition. There is no additional hidden machinery that Haskell is somehow automatically invoking when you &#34;use a Functor&#34;. Like many OO languages, there is no additional conversion or weird stuff wrapped around the resolved method. Just like OO resolving an overridden method (with no automatic conversions),  all the magic is in picking the correct implementation; once resolved the language is not doing anything else.</p><p>  这是完整的定义。没有额外的隐藏机械，哈克尔在某种程度上自动调用你＆＃34;使用函授＆＃34;像许多语言一样，没有围绕解决方法包裹的额外转换或奇怪的东西。就像OO解析了一个覆盖的方法（没有自动转换）一样，所有魔法都在挑选正确的实施;一旦解决了语言没有做任何其他事情。</p><p> What makes a data structure &#34;functorish&#34;? It is having a sensible implementation of fmap, whatever that may be on the data structure. If it has a sensible implementation, we can give it, that makes it a Functor, not the other way around. Theoretically this is how it ought to work in all languages with a concept of an interface of some sort, but sometimes the paperwork can get in the way and make it feel like it&#39;s the other way around, that something isn&#39;t an Iteratable until I deliberately make it one. But I think it&#39;s a more mature programming view to think of a data structure as always having a set of possible sensible implementations for a given interface, possibly empty or more than one, and you simply choose whether or not to explain it to the language. You usually aren&#39;t &#34;creating&#34; these implementations. At least for these simpler, more mathematical types of interfaces.</p><p> 是什么制作数据结构＆＃34;函件＆＃34 ;?它具有令人明智的FMAP实现，无论哪种数据结构都在。如果它有一个明智的实现，我们可以给它，这使它成为一个仿函数，而不是另外的方式。理论上这就是它如何用某种界面的概念来工作，但有时文书工作可以妨碍它，让它感觉像它一样，这是另一条路的，所以某种东西尚未＆＃39 ; t一个迭代，直到我故意使它成为一个。但我认为它更加成熟的编程视图，以便将数据结构呈现为给定接口的一组可能的明智实现，可能是空的或多于一个，并且您只需选择是指解释它语言。你通常不是＆＃39; t＆＃34;创建＆＃34;这些实现。至少对于这些更简单的，更多数学类型的接口。 </p><p>  The functor definition above has  f a, which is Haskell notation for &#34;a type  f parameterized by  a&#34;. That&#39;s abstract with type variables, but easy in examples;  List Int is a &#34;List&#34; parameterized by &#34;Int&#34;, meaning it can hold Ints.</p><p>上面的函数定义具有f a，它是＆＃34的haskell符号;由a＆＃34参数化的类型f;那个＆＃39; s摘要与类型变量，但在例子中容易;列表int是一个＆＃34;列表＆＃34;由＆＃34; int＆＃34;，意思是它可以持有INTS。</p><p> While in full Haskell this can get more complicated, for the simple types I&#39;m using in this post you can do the match visually. To match  f a to  List Int, we set  f = List and  a = Int.</p><p> 虽然在完整的Haskell中，这可能会变得更加复杂，因为简单的类型I＆＃39; m在此帖子中使用您可以在视觉上进行比赛。要匹配f a列出int，我们设置f = list和a = int。</p><p> Unfortunately, two of Haskell&#39;s most important types get special-cased and visually matching them is hard. Rather than  List Int, Haskell uses  [Int], which is confusing at the worst possible time for a novice.</p><p> 不幸的是，两个哈斯克尔＆＃39;最重要的类型得到特殊套餐，视觉匹配它们很难。 Haskell而不是列出int，而是使用[int]，这在新手的最糟糕的时间内令人困惑。</p><p> Fortunately, we can write this as  [] Int. It is already valid Haskell syntax. Then we can visually match:  f = [] and  a = Int. I don&#39;t write a lot of Haskell code nowadays but I&#39;ve been adopting that as how I represent lists everywhere in my types, because I don&#39;t think the special case is very useful.</p><p> 幸运的是，我们可以将此写成[] int。它已经有效的haskell语法。然后我们可以在视觉上匹配：f = []和a = int。我现在不要写很多Haskell代码，但是我一直在采用它如何在我的类型中所在的列表，因为我认为特殊情况非常有用。</p><p> The other confusing type is the function type  a -&gt; b. For didactic purposes, it is better spelled  (-&gt;) a b. Again, legal Haskell syntax today, though you unfortunately need the parentheses. In this case, for the functor implementation on  (-&gt;),  f = (-&gt;) a and the remainder is  b. That&#39;s still a bit abstract, so let&#39;s concretize it by observing that you can convert the  output of both a  (-&gt;) String Int and a  (-&gt;) Int Int if you have some function  (-&gt;) Int String, because what matters is that the output of the function you are &#34;functionableing&#34; matches the input of the function you are applying to it, which is  Int in this case.</p><p> 另一个混淆类型是函数类型a  - ＆gt;湾对于教学目的，它是更好的拼写（ - ＆gt;）a b。同样，当今法律哈斯克尔语法，虽然你不幸需要括号。在这种情况下，对于（ - ＆gt;），f =（ - ＆gt;）a和剩余部分是b。仍然有点摘要，所以通过观察您可以转换（ - ＆gt;）字符串int和a（ - ＆gt;）int int的输出，使其具体化。如果您有一些功能，请将其转换为（ - ＆gt;）int int。 （ - ＆gt;）int string，因为重要的是你是＆＃34的函数的输出;功能＆＃34;匹配您申请的功能的输入，在这种情况下是int。</p><p> I do  not use this in my code, because it mangles type signatures something fierce to do this everywhere. Still, it is important to bear in mind what it really means.</p><p> 我在我的代码中没有使用它，因为它的手动类型签名到处都是凶猛的事情。尽管如此，重要的是要记住它的真正意味着什么。</p><p> In this case, the  f in the pattern matches &#34;the front piece&#34; instead of just the first element. If you do not intend to program in Haskell, just take my word for it that this is a legal match and let this wash over you; if you do intend to program in Haskell you&#39;ll find this won&#39;t take much to understand. Either way it&#39;s not terribly important for understanding what the monad interface is so I will be moving merrily along now.</p><p> 在这种情况下，图案匹配中的f＆＃34;前件＆＃34;而不是第一个元素。如果您不打算在Haskell进行编程，只需将我的通知为此，这是一个法律匹配，让这款清洗到您身上;如果您打算在Haskell＆＃39中编程。LL找到这赢得了＆＃39; T.无论是如何，它对理解Monad接口是如此，我将沿着现在沿着狂欢的方式移动。 </p><p>   A data structure is monadish when you have some source of  a, and a way of taking an  a and turning it into the same sort of source of  b, and turning that all into the same sort of source of  b. As with &#34;functor&#34; I am using the word &#34;source&#34; as the closest English word I can think of for the maximally generic idea of a type; you have a list of ints, or a function that yields an int, or a way of getting an int from user input, etc.</p><p>当您有一些源A的数据结构是MONADISIS，以及一种拍摄A并将其转换为相同的B源的方式，并将全部转向相同的B源。和＆＃34;函数＆＃34;我正在使用这个词＆＃34;来源＆＃34;作为最接近的英语单词，我可以想到为类型的最大泛型概念;您有一个ints列表，或产生int的函数，或者从用户输入等获得int的方式等。</p><p> class Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</p><p> Class Monad M在哪里（＆gt;＆gt; =）:: m a  - ＆gt; （a  - ＆gt; m b） - ＆gt; M B.</p><p> English is really tripping over itself here, but between the English description and the definition I hope the basic idea comes across. It probably also doesn&#39;t help that we have a function literally called  &gt;&gt;=, which is hard to pronounce. It&#39;s pronounced &#34;bind&#34;, which is only slightly more helpful in that that still fails to evoke any useful imagery. Let&#39;s take a specific example:</p><p> 英语真的在这里绊倒，但在英语描述与定义之间，我希望基本的想法遇到。它可能也没有帮助我们有一个职能称为＆gt;＆gt; =，这很难发音。它＆＃39; s发音＆＃34;绑定＆＃34;，这只是稍微有用的是，仍然无法唤起任何有用的图像。设＆＃39;■参加一个具体的例子：</p><p>  On its own, that&#39;s not a confusing function. In this particular case, there aren&#39;t that many possible sensible implementations. Clearly, we&#39;re going to iterate along the list of ints, pass them one by one to the thing that produces a list of strings, and the concatenate all those results together into the final list. (We have to do that, because the final result can&#39;t be a  List (List String); that&#39;s a separate type.)</p><p>  独自一人，＆＃39; s不是一个令人困惑的功能。在这个特殊的情况下，有许多可能的明智的实现。显然，我们沿着ints列表迭代，将它们逐一传递给生成字符串列表的东西，并且将所有这些结果连接到最终列表中。 （我们必须这样做，因为最终结果可以＆＃39; t是列表（列表字符串）;那个＆＃39; s一个单独的类型。）</p><p>   That&#39;s all Monad is. It is an implementation of some &#34;method&#34; that conforms to that interface specification.</p><p>   所有Monad都是＆＃39;它是一些＆＃34;方法＆＃34;这符合该接口规范。</p><p> Understanding this is not what people mean by &#34;understanding monad&#34;. This is the &#34;what&#34; of the monad interface, but not the &#34;why&#34;. But I think it is a step often glossed over too quickly in other works (if not at times outright skipped), so let&#39;s stay here and chew on that &#34;what&#34; for a bit.</p><p> 理解这不是人们的意思＆＃34;了解Monad＆＃34;这是＆＃34;什么＆＃34; Monad接口，但不是＆＃34;为什么＆＃34;但我认为这是一个往往在其他作品中过于迅速的一步（如果不是彻头彻尾的跳过），所以让＆＃39;留在这里，咀嚼那个＆＃34;什么＆＃34;就一点点。</p><p> Once again, I want to emphasize that just like in OO languages and just like fmap, there is no special magic that Haskell invokes because &#34;it&#39;s a monad&#34;. All Haskell does is look up the interface&#39;s implementation and pass the arguments in. There is &#34;do notation&#34; but that is  only a syntax-sugar respelling of this function call; it still does no further manipulation of arguments, no coercions, no modification of input, no modification of output, nothing. Since this article is about understanding &#34;monad&#34; without going deeply into Haskell-specific details, I&#39;m going to ignore it because it&#39;s just syntax sugar.</p><p> 再一次，我想强调，就像以OO语言一样，就像FMAP一样，没有特殊的魔法哈斯克尔调用，因为＆＃34;它＆＃39; sonad＆＃34;所有Haskell都是查找界面＆＃39; s的实现并传递参数。＆＃34; do符号＆＃34;但这只是这个功能呼叫的语法 - 糖重点;它仍然没有进一步操纵参数，没有胁迫，没有改进输入，没有改进输出，没有。自本文是关于理解和＃34; Monad＆＃34;如果没有深入了解了Haskell特定的细节，我将忽略它，因为它只是语法糖。 </p><p> Bind is simply a function that takes some wrapped type, a function that takes the inner value and returns a wrapped value, and a final wrapped value of that type.</p><p>绑定只是一种函数，它采用一些包装类型，一个函数，它是一个内部值并返回包装的函数，以及该类型的最终包装值。</p><p>  Again, no mystery to this implementation. It takes something that may have an Int or not, converts it to a string, and then returns something that is either a String or nothing.</p><p>  再次，没有谜。它需要一个可能具有int的内容，将其转换为字符串，然后返回一个字符串或任何内容的内容。</p><p>  Obviously, you don&#39;t know what Blorp does. I named it and I don&#39;t even know what it does. But you can see this would be an implementation of &#34;bind&#34; for Blorp, on particular types  Int and  String.</p><p>  显然，你不知道Blorp的＆＃39。我把它命名，我甚至不知道它的所作所为。但是你可以看到这将是＆＃34; bind＆＃34;对于Blorp，特定类型int和string。</p><p> That&#39;s all Monad is. Just as there is no magic around the Iterator&#39;s  Next method, just as there is no magic around functors,this is all the  what of a Monad is. In fact, it literally  can&#39;t be more complicated, because this is all an interface  is. All an interface can do is name a particular method. Nothing else happens. If you find your current conception of monad does not match that and it is insisting there&#39;s a big ball o&#39; mystery here, throw it out. It is nothing more than declaring a particular function as the implementation of this interface and the subsequent resolution machinery when you use it. Nothing. More.</p><p> 所有Monad都是＆＃39;就像迭代器周围没有魔法一样迭代＆＃39;下一个方法，就像函件周围没有魔法一样，这就是一切都是一切都是如此。事实上，它字面上可以＆＃39; t更复杂，因为这是一个接口。所有接口都可以做到一个特定的方法。没有别的发生。如果您发现您当前的Monad的概念不匹配，它坚持在那里＆＃39;一个大球O＆＃39;这里的神秘面纱，扔掉它。它只不过是将特定函数声明为此接口的实现以及当您使用时的后续分辨率机械。没有什么。更多的。</p><p> No, I do not mean this in a &#34;this hard concept is really easy if you look at right&#34;. I do not mean it as an attempt to simplify some explanation at all, because this isn&#39;t a simplified explanation. This  is what a monadic implementation is. It&#39;s not a simplification at all. It&#39;s a completely accurate description. It is no more and no less than a specification of an implementation for the particular interface. It is the same as Iterator and Functor and Stringable and all the other well-known interfaces many languages have.</p><p> 不，我不是在A＆＃34中的意思;如果你看右图，这个艰难的概念就会很容易。我并不意味着它一直试图简化一些解释，因为这是一个简化的解释。这就是Monadic实现是什么。它并非简化。它完全准确的描述。它不再少于特定接口的实现的规范。它与迭代器和仿函数和销毁以及许多语言的所有其他众所周知的接口相同。</p><p> I have belabored this point in text mostly in the hopes that you&#39;ll slow down and process this before continuing on. A lot of people have really built this particular interface up in their head as something fundamentally mysterious. But this is all the  what of monad is.</p><p> 我在文本中结合了这一点，希望你＆＃39; LL在继续之前慢下来并处理这个。很多人真的在他们的头上建立了这个特殊的界面，就像从根本上神秘的东西。但这就是Monad的一切。</p><p> Is it a burrito? Is it a space suit? Is it some other bizarre metaphor? No. You don&#39;t need a bizarre metaphor to understand this part. In fact you rather need a  lack of bizarre metaphors, because they mythologize</p><p> 这是一个卷饼吗？这是一个太空服吗？它是其他一些奇怪的比喻吗？不，你不需要一个奇怪的隐喻来了解这一部分。事实上，你宁愿需要缺乏奇异的隐喻，因为他们是神话 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.jerf.org/iri/post/2958">http://www.jerf.org/iri/post/2958</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/monads/">#monads</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>