<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>潜入/proc/pid/mem</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">潜入/proc/pid/mem</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 21:07:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/d31768f043a397f45761ccf56624d357.png"><img src="http://img2.diglog.com/img/2020/10/d31768f043a397f45761ccf56624d357.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A few months ago, after reading about  Cloudflare doubling its intern class size, I quickly dusted off my CV and applied for an internship. Long story short: now, a couple of months later, I found myself staring into Linux kernel code and adding a pretty cool feature  to gVisor, a Linux container runtime.</p><p>几个月前，在读到Cloudflare实习生班级人数翻了一番的消息后，我很快重拾简历，申请了一份实习工作。长话短说：现在，几个月后，我发现自己开始研究Linux内核代码，并在Linux容器运行时gVisor中添加了一个相当酷的特性。</p><p> My internship was under the Emerging Technologies and Incubation group on a project involving gVisor. A co-worker contacted my team about not being able to read the debug symbols of stack traces inside the sandbox. For example, when the isolated process crashed, this is what we saw in the logs:</p><p>我的实习是在新兴技术和孵化小组的一个涉及gVisor的项目上进行的。一位同事联系了我的团队，说他无法读取沙箱中堆栈跟踪的调试符号。例如，当隔离进程崩溃时，我们在日志中看到：</p><p> *** Check failure stack trace: *** @ 0x7ff5f69e50bd (unknown) @ 0x7ff5f69e9c9c (unknown) @ 0x7ff5f69e4dbd (unknown) @ 0x7ff5f69e55a9 (unknown) @ 0x5564b27912da (unknown) @ 0x7ff5f650ecca (unknown) @ 0x5564b27910fa (unknown)</p><p>*检查故障堆栈轨迹：*@0x7ff5f69e50bd(未知)@0x7ff5f69e9c9c(未知)@0x7ff5f69e4dbd(未知)@0x7ff5f69e55a9(未知)@0x5564b27912da(未知)@0x7ff5f650ecca(未知)@0x5564b27910fa(未知)。</p><p> Obviously, this wasn&#39;t very useful. I eagerly volunteered to fix this stack unwinding code - how hard could it be?</p><p>显然，这并不是很有用。我迫不及待地自愿修复这个堆栈展开代码-这能有多难呢？</p><p> After some debugging, we found that the logging library used in the project opened  /proc/self/mem to look for ELF headers at the start of each memory-mapped region. This was necessary to calculate an offset to find the correct addresses for debug symbols.</p><p>经过一些调试之后，我们发现项目中使用的日志库打开了/proc/self/mem，以便在每个内存映射区域的开头查找ELF标头。这是计算偏移量以找到调试符号的正确地址所必需的。</p><p> It turns out this mechanism is rather common. The stack unwinding code is often run in weird contexts - like a SIGSEGV handler - so it would not be appropriate to dig over real memory addresses back and forth to read the ELF. This could trigger another SIGSEGV. And SIGSEGV inside a SIGSEGV handler means either termination via the default handler for a segfault or recursing into the same handler again and again (if one sets  SA_NODEFER) leading to a stack overflow.</p><p>事实证明，这种机制相当常见。堆栈展开代码通常在奇怪的上下文中运行-如SIGSEGV处理程序-因此不适合来回挖掘实际内存地址来读取ELF。这可能会引发另一个SIGSEGV。SIGSEGV处理程序内的SIGSEGV意味着要么通过SEGFAULT的默认处理程序终止，要么反复递归到同一处理程序(如果设置了SA_NODEFER)，从而导致堆栈溢出。</p><p> However, inside gVisor, each call of  open() on  /proc/self/mem resulted in  ENOENT, because the entire  /proc/self/mem file was missing. In order to provide a robust sandbox, gVisor has to carefully reimplement the Linux kernel interfaces. This particular  /proc file was simply unimplemented in the virtual file system of Sentry, one of gVisor&#39;s sandboxing components.  Marek asked the devs on the project chat and got confirmation - they would be happy to accept a patch implementing this file.</p><p>然而，在gVisor内部，每次调用/proc/self/mem上的open()都会导致ENOENT，因为整个/proc/self/mem文件都丢失了。为了提供健壮的沙箱，gVisor必须小心地重新实现Linux内核接口。这个特定的/proc文件根本没有在gVisor的沙箱组件之一Sentry的虚拟文件系统中实现。Marek在项目聊天中询问了开发人员，并得到了确认-他们会很高兴接受实现此文件的补丁。</p><p> The easy way out would have been to make a small, local patch to the unwinder behavior, yet I found myself diving into the Linux kernel trying to figure how the  mem file worked in an attempt to implement it in Sentry&#39;s VFS.</p><p>最简单的解决办法是对展开的行为做一个小的本地补丁，然而我发现自己潜入Linux内核，试图弄清楚mem文件是如何工作的，试图在Sentry的VFS中实现它。</p><p>  The file itself is quite powerful, because it allows raw access to the virtual address space of a process.  According to manpages, the documented file operations are  open(),  read() and  lseek(). Typical use cases are debugging tasks or dumping process memory.</p><p>该文件本身非常强大，因为它允许对进程的虚拟地址空间进行原始访问。根据手册页，有文档记录的文件操作是open()、read()和lSeek()。典型的用例是调试任务或转储进程内存。</p><p>  When a process wants to open the file, the kernel does the file permissions check, looks up the associated operations for  mem and invokes a method called  proc_mem_open. It retrieves the associated task and  calls a method named  mm_access.</p><p>当进程想要打开文件时，内核执行文件权限检查，查找与mem相关的操作，并调用名为proc_mem_open的方法。它检索关联的任务并调用名为mm_access的方法。</p><p> /* * Grab a reference to a task&#39;s mm, if it is not already going away * and ptrace_may_access with the mode parameter passed to it * succeeds. */</p><p>/**获取对任务mm的引用(如果它还没有离开)，并使用传递给它的模式参数ptrace_May_access*成功。*/。</p><p> Seems relatively straightforward, right? The special thing about  mm_access is that it verifies the permissions the current task has regarding the task to which the memory belongs. If the current task and target task do not share the same memory manager, the kernel  invokes a method named  __ptrace_may_access.</p><p>看起来比较直截了当，对吧？Mm_access的特殊之处在于，它验证当前任务对内存所属任务的权限。如果当前任务和目标任务不共享同一内存管理器，内核将调用名为__ptrace_May_access的方法。</p><p> /* * May we inspect the given task? * This check is used both for attaching with ptrace * and for allowing access to sensitive information in /proc. * * ptrace_attach denies several cases that /proc allows * because setting up the necessary parent/child relationship * or halting the specified task is impossible. * */</p><p>/**我们可以检查给定的任务吗？*此检查既用于附加ptrace*，也用于允许访问/proc中的敏感信息。**ptrace_Attach拒绝/proc允许的几种情况*因为无法设置必要的父/子关系*或停止指定的任务。**/。</p><p> According to the manpages, a process which would like to read from an unrelated  /proc/[pid]/mem file should have access mode   PTRACE_MODE_ATTACH_FSCREDS. This check does not verify that a process is attached via  PTRACE_ATTACH, but rather if it has the permission to attach with the specified credentials mode.</p><p>根据手册页，希望从不相关的/proc/[PID]/mem文件读取的进程应该具有访问模式ptrace_mode_ATTACH_FSCREDS。此检查不会验证进程是否通过ptrace_ATTACH附加，而是验证它是否具有使用指定凭据模式附加的权限。</p><p>  After skimming through the function, you will see that a process is allowed access if the current task belongs to the same thread group as the target task, or denied access (depending on whether  PTRACE_MODE_FSCREDS or  PTRACE_MODE_REALCREDS is set, we will use either the file-system UID / GID, which is typically the same as the effective UID/GID, or the real UID / GID) if none of the following conditions are met:</p><p>浏览完函数后，您将看到，如果当前任务与目标任务属于同一线程组，则允许进程访问；如果不满足以下条件，则允许进程访问(取决于是否设置了ptrace_mode_FSCREDS或ptrace_mode_REALCREDS，我们将使用文件系统UID/GID，通常与有效的UID/GID相同)，或者使用真实的UID/GID；如果当前任务与目标任务属于同一线程组，则允许进程访问；如果不满足以下条件，则拒绝访问(取决于是否设置了ptrace_mode_FSCREDS或ptrace_mode_REALCREDS，我们将使用文件系统UID/GID，通常与有效UID/GID相同)：</p><p> the current task&#39;s credentials (UID, GID) match up with the credentials (real, effective and saved set-UID/GID) of the target process</p><p>当前任务的凭据(UID，GID)与目标进程的凭据(真实、有效和保存的Set-UID/GID)匹配</p><p> In the next check, access is denied if the current task has neither  CAP_SYS_PTRACE inside the user namespace of the target task, nor the target&#39;s dumpable attribute is set to  SUID_DUMP_USER.  The dumpable attribute is typically required to allow producing core dumps.</p><p>在下一次检查中，如果当前任务在目标任务的用户命名空间内既没有CAP_SYS_PTRACE，也没有将目标的Dumpable属性设置为SUID_DUMP_USER，则拒绝访问。通常需要Dumpable属性来允许生成核心转储。</p><p> After these three checks, we also go through the commoncap Linux Security Module (and other LSMs) to verify our access mode is fine. LSMs you may know are SELinux and AppArmor. The commoncap LSM performs the checks on the basis of effective or permitted process capabilities (depending on the mode being  FSCREDS or  REALCREDS), allowing access if</p><p>在完成这三项检查之后，我们还将通过通用的Linux安全模块(和其他LSM)来验证我们的访问模式是否正常。您可能知道LSM是SELinux和AppArmor。COMMONCAP LSM根据有效或允许的进程能力(取决于模式为FSCREDS或REALCREDS)执行检查，允许在以下情况下进行访问。</p><p> the capabilities of the current task are a superset of the capabilities of the target task, or</p><p>当前任务的功能是目标任务功能的超集，或者。</p><p>  the credentials of the current and target task match up in the given credentials mode, the target task is dumpable, they run in the same user namespace and the target task&#39;s capabilities are a subset of the current task&#39;s capabilities</p><p>当前任务和目标任务的凭据在给定凭据模式下匹配，目标任务是可转储的，它们在相同的用户命名空间中运行，并且目标任务的能力是当前任务能力的子集。</p><p> I highly recommend reading through the  ptrace manpages to dig deeper into the different modes, options and checks.</p><p>我强烈建议您阅读ptrace手册页，更深入地挖掘不同的模式、选项和检查。</p><p>  Since all the access checks occur when opening the file, reading from it is quite straightforward. When one invokes  read() on a  mem file,  it calls up  mem_rw (which actually can do both reading and writing).</p><p>由于所有访问检查都在打开文件时进行，因此读取文件非常简单。当对mem文件调用read()时，它会调用mem_rw(它实际上既可以进行读操作，也可以进行写操作)。</p><p> To avoid using lots of memory,  mem_rw performs the copy in a loop and buffers the data in an intermediate page.  mem_rw has a hidden superpower, that is, it uses  FOLL_FORCE to avoid permission checks on user-owned pages (handling pages marked as non-readable/non-writable readable and writable).</p><p>为了避免使用大量内存，mem_rw在循环中执行复制，并在中间页中缓冲数据。Memrw具有隐藏的超能力，即，它使用FOLL_FORCE来避免对用户拥有的页面进行权限检查(处理标记为不可读/不可写、可读和可写的页面)。</p><p>  if the target task has exited after opening the file descriptor, performing  read() will always succeed with reading 0 bytes</p><p>如果目标任务在打开文件描述符后退出，则执行read()将始终成功，并读取0字节</p><p> if the initial copy from the target task&#39;s memory to the intermediate page fails, it does not always return an error but only if no data has been read</p><p>如果从目标任务的内存到中间页的初始拷贝失败，它并不总是返回错误，但只有在没有读取数据的情况下才会返回错误。</p><p>   Luckily, gVisor already implemented  ptrace_may_access as  kernel.task.CanTrace, so one can avoid reimplementing all the ptrace access logic. However,  the implementation in gVisor is less complicated due to the lack of support for  PTRACE_MODE_FSCREDS (which is  still an open issue).</p><p>幸运的是，gVisor已经将ptrace_May_access实现为kernel.task.CanTrace，因此可以避免重新实现所有的ptrace访问逻辑。但是，由于缺乏对ptrace_mode_FSCREDS的支持(这仍然是一个悬而未决的问题)，gVisor中的实现不那么复杂。</p><p> When a new file descriptor is  open()ed, the  GetFile method of the virtual Inode is invoked, therefore this is where the access check naturally happens. After a successful access check, the  method returns a  fs.File. The  fs.File implements all the file operations you would expect such as  Read() and  Write(). gVisor also provides tons of primitives for quickly building a working file structure so that one does not have to reimplement a generic  lseek() for example.</p><p>当新的文件描述符打开()时，会调用虚拟inode的GetFile方法，因此这是访问检查自然发生的地方。访问检查成功后，该方法返回fs.File。Fs.File实现了您预期的所有文件操作，比如read()和write()。例如，gVisor还提供了大量用于快速构建工作文件结构的原语，这样就不必重新实现泛型lSeek()。</p><p> In case a task invokes a  Read() call onto the  fs.File, the  Read method retrieves the memory manager of the file’s Task.  Accessing the task&#39;s memory manager is a breeze with comfortable  CopyIn and  CopyOut methods, with interfaces similar to  io.Writer and  io.Reader.</p><p>如果任务调用对fs.File的read()调用，则read方法将检索该文件的Task的内存管理器。使用类似于io.Writer和io.Reader的接口，使用舒适的Copin和CopyOut方法访问任务的内存管理器非常容易。</p><p>  *** Check failure stack trace: *** @ 0x7f190c9e70bd google::LogMessage::Fail() @ 0x7f190c9ebc9c google::LogMessage::SendToLog() @ 0x7f190c9e6dbd google::LogMessage::Flush() @ 0x7f190c9e75a9 google::LogMessageFatal::~LogMessageFatal() @ 0x55d6f718c2da main @ 0x7f190c510cca __libc_start_main @ 0x55d6f718c0fa _start</p><p>*检查故障堆栈跟踪：*@0x7f190c9e70bd Google：：LogMessage：：Fail()@0x7f190c9ebc9c Google：：LogMessage：：SendToLog()@0x7f190c9e6dbd Google：：LogMessage：：Flush()@0x7f190c9e75a9 Google：：LogMessageFtal：：~LogMessageFtal()@0x55d6f718c2da main@0x7f190c510cca_libc_start_main@0x55d6f718c0c0start_main@0x7f190c510cca_libc_start_main@0x55d6f718c0c0start。</p><p>  A comprehensive victory! The  /proc/&lt;pid&gt;/mem file is an important mechanism that gives insight into contents of process memory. It is essential to stack unwinders to do their work in case of complicated and unforeseeable failures. Because the process memory contains highly-sensitive information, data access to the file is determined by a complex set of poorly documented rules. With a bit of effort, you can emulate  /proc/[PID]/mem inside gVisor’s sandbox, where the process only has access to the subset of procfs that has been implemented by the gVisor authors and, as a result, you can have access to an easily readable stack trace in case of a crash.</p><p>全面胜利！/proc/&lt；pid&gt；/mem文件是深入了解进程内存内容的重要机制。在出现复杂和不可预见的故障时，堆叠开卷机进行工作是必不可少的。由于进程内存包含高度敏感的信息，因此对文件的数据访问由一组文档不完善的复杂规则决定。稍加努力，您就可以在gVisor的沙箱中模拟/proc/[pid]/mem，其中该进程只能访问gVisor作者已经实现的procf子集，因此，您可以在发生崩溃时访问易于读取的堆栈跟踪。</p><p>  Deep Dive  Programming  Linux</p><p>深潜编程Linux</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudflare.com/diving-into-proc-pid-mem/">https://blog.cloudflare.com/diving-into-proc-pid-mem/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/proc/">#proc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>