<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>QEMU转换器的演变 The Evolution of the QEMU Translator</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Evolution of the QEMU Translator<br/>QEMU转换器的演变 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 13:36:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/62065fb4a221af898dd58cd9fef1d65b.jpg"><img src="http://img2.diglog.com/img/2021/1/62065fb4a221af898dd58cd9fef1d65b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The QEMU team in Linaro sits inside a group known as the Toolchain Working Group (TCWG). The rest of the team spend their time working with compilers and other code generators such as  GCC and  LLVM. When dealing with emulation, QEMU has its own module known as the Tiny Code Generator (TCG). It shares many similarities with a compiler albeit one that works with different constraints than your typical compiler. As the code generator works on a just-in-time (JIT) basis it can’t afford to spend large amounts of time (or memory!) that a typical compiler does when optimising its output. This is especially true for code that only gets executed once or twice before being flushed out of the cache.</p><p>Linaro的QEMU团队隶属于工具链工作组（TCWG）。团队的其余成员将时间花在与编译器和其他代码生成器（如GCC和LLVM）上。在处理仿真时，QEMU有其自己的模块，称为微型代码生成器（TCG）。它与编译器具有许多相似之处，尽管它与典型的编译器相比具有不同的约束条件。由于代码生成器是基于即时（JIT）的，因此它无法像典型的编译器在优化其输出时那样花费大量时间（或内存！）。对于仅在刷新到缓存中之前仅执行一次或两次的代码而言尤其如此。</p><p>    The TCG is actually the second code generator that QEMU has used. Originally QEMU worked as a “template” translator where each individual instruction has a snippet of C code associated with it. The translation was a case of stitching these templates together into larger blocks of code. This meant porting QEMU to a new system was relatively easy because if GCC supported it, you could generate code to run under it. However, eventually the limits of this approach necessitated moving to a new code generator and TCG was born.</p><p>    TCG实际上是QEMU使用的第二个代码生成器。最初，QEMU充当“模板”翻译器，其中每个单独的指令都有与之关联的C代码片段。翻译是将这些模板拼接成更大的代码块的情况。这意味着将QEMU移植到新系统相对容易，因为如果GCC支持，您可以生成在其下运行的代码。但是，最终，这种方法的局限性使得必须转向新的代码生成器，TCG诞生了。</p><p>  TCG has its roots as a generic back end for a C compiler. The main difference is instead of converting an abstract syntax tree from a high level language into micro ops, its input is the decomposed operations of an individual instruction.</p><p>  TCG的根源是C编译器的通用后端。主要区别在于不是将抽象语法树从高级语言转换为微操作，而是将输入分解为单个指令的操作。</p><p>    static void disas_add_imm(DisasContext *s, uint32_t insn) { /* Decode Instruction */ int rd = extract32(insn, 0, 5); int rn = extract32(insn, 5, 5); uint64_t imm = extract32(insn, 10, 12); /* Allocate Temporaries */ TCGv_i64 tcg_rn = cpu_reg_sp(s, rn); TCGv_i64 tcg_rd = cpu_reg_sp(s, rd); TCGv_i64 tcg_result = tcg_temp_new_i64(); /* Do operation */ tcg_gen_addi_i64(tcg_result, tcg_rn, imm); tcg_gen_mov_i64(tcg_rd, tcg_result); /* Clean-up */ tcg_temp_free_i64(tcg_result); }</p><p>    static void disas_add_imm（DisasContext * s，uint32_t insn）{/ *解码指令* / int rd = extract32（insn，0，5）; int rn = extract32（insn，5，5）; uint64_t imm = extract32（insn，10，12）; / *分配临时人员* / TCGv_i64 tcg_rn = cpu_reg_sp（s，rn）; TCGv_i64 tcg_rd = cpu_reg_sp（s，rd）; TCGv_i64 tcg_result = tcg_temp_new_i64（）; / *执行操作* / tcg_gen_addi_i64（tcg_result，tcg_rn，imm）; tcg_gen_mov_i64（tcg_rd，tcg_result）; / *清理* / tcg_temp_free_i64（tcg_result）; }</p><p>  The decode step involves dissecting the various fields of the instruction to work out what registers and immediate values are needed. The operation is synthesised from TCG ops which are the basic units of the code generator. After a simple optimisation pass, these ops are then converted into host instructions and executed.</p><p>  解码步骤涉及解剖指令的各个字段，以计算出需要哪些寄存器和立即值。该操作是从作为代码生成器基本单元的TCG ops合成的。经过简单的优化之后，这些操作将转换为主机指令并执行。</p><p>  You can see the process yourself if you turn on the debugging options in QEMU although be warned it generates a lot of output:</p><p>  如果在QEMU中打开调试选项，则可以自己查看该过程，尽管要警告它会产生很多输出：</p><p>      While the TCG has been part of QEMU since 2008 it has seen some changes over time. I’ve been working in and around it since 2015 and I thought it would be an interesting exercise to look at some of the changes it has seen over the last five years.</p><p>      自2008年以来，TCG一直是QEMU的一部分，但随着时间的推移，它发生了一些变化。自2015年以来，我一直在从事这项工作，并且认为过去五年来发生的一些变化将是一个有趣的练习。 </p><p>    Originally each guest architecture just supplied a ‘gen_intermediate_code’ function that dealt with the process of translating a block of guest code into TCG operations. While they all looked fairly similar they also tended to have accumulated their own slight idiosyncrasies. The work to convert to a common translator loop didn’t involve any particular bleeding edge technology and was mostly concerned with re-factoring architecture specific parts behind a set of ‘TranslatorOps’ that would be familiar to anyone who has worked on something like a Linux device driver. The main reason I mention this work is because it opened the way for architecturally independent enhancements to be made functioning of the translator. This includes things like much improved tracing and  TCG plugin instrumentation.</p><p>最初，每个来宾体系结构都只提供了“ gen_intermediate_code”功能，该功能处理将来宾代码块转换为TCG操作的过程。尽管他们看上去都非常相似，但他们也倾向于积累自己的轻微特质。转换为通用翻译器循环的工作不涉及任何特定的前沿技术，而主要涉及重构一组“ TranslatorOps”背后的特定于体系结构的部分，任何从事过Linux之类工作的人都会熟悉设备驱动。我提到这项工作的主要原因是因为它为实现翻译器的结构独立增强功能开辟了道路。其中包括改进的跟踪和TCG插件检测等功能。</p><p>  Another recent innovation is the  Decode Tree. This started as an experiment with another of QEMU’s testing tools known as Random Instruction Sequence (generator for) Userspace  RISU which is used to test the instruction decoder.</p><p>  最近的另一项创新是解码树。这是从QEMU的另一种测试工具（称为“随机指令序列”（生成器）用户空间RISU）进行的实验开始的，该工具用于测试指令解码器。</p><p>  Ideally an instruction set fits into a nice regular and tree like decode pattern. However, reality often gets in the way, especially when ISA designers are trying to squeeze additional functionality into an increasingly crowded opcode space. Eventually you end up with functions like  this which do a series of masked pattern tests in a very particular order to tease out exactly which instruction is being decoded. Needless to say this process is error prone and many bugs have occurred due to mistakes in decoding the opcode.</p><p>  理想情况下，一个指令集适合一个很好的规则和树状解码模式。但是，现实常常会遇到麻烦，尤其是当ISA设计人员试图将其他功能压缩到越来越拥挤的操作码空间中时。最终，您将获得类似这样的功能，这些功能以非常特殊的顺序执行一系列蒙版模式测试，以准确弄清正在解码的指令。不用说，此过程容易出错，并且由于对操作码进行解码时的错误而发生了许多错误。</p><p>  Decode Tree solves this problem by allowing a simple textual description of the opcode fields and then having a script automatically generate the most efficient decoding of opcode it can. As a bonus it can also automatically extract the fields from the instruction and pass those to a simplified implementation that can just concentrate on the semantics of the operation.</p><p>  解码树通过允许对操作码字段进行简单的文本描述来解决此问题，然后让脚本自动生成可以对其进行的最有效的操作码解码。另外，它还可以自动从指令中提取字段并将其传递给简化的实现，而该实现只需专注于操作的语义即可。</p><p>  static void trans_add_imm(DisasContext *s, arg_rri *a) { TCGv_i64 tcg_rn = cpu_reg_sp(s, a-&gt;rn); TCGv_i64 tcg_rd = cpu_reg_sp(s, a-&gt;rd); TCGv_i64 tcg_result = tcg_temp_new_i64(); /* Do operation */ tcg_gen_addi_i64(tcg_result, tcg_rn, a-&gt;imm); tcg_gen_mov_i64(tcg_rd, tcg_result); /* Clean-up */ tcg_temp_free_i64(tcg_result); }</p><p>  static void trans_add_imm（DisasContext * s，arg_rri * a）{TCGv_i64 tcg_rn = cpu_reg_sp（s，a-> rn）; TCGv_i64 tcg_rd = cpu_reg_sp（s，a-> rd）; TCGv_i64 tcg_result = tcg_temp_new_i64（）; / *执行操作* / tcg_gen_addi_i64（tcg_result，tcg_rn，a-> imm）; tcg_gen_mov_i64（tcg_rd，tcg_result）; / *清理* / tcg_temp_free_i64（tcg_result）; }</p><p>  Decode Tree was originally written to support the introduction of  SVE in QEMU but since then new guests have used it and several existing guest architectures have been converted to use decode tree powered instruction decode.</p><p>  解码树最初是为了支持QEMU中SVE的引入而编写的，但是从那时起，新的来宾就使用了它，并且几种现有的来宾体系结构已被转换为使用由解码树支持的指令解码。</p><p>    The original implementation of system emulation was single-threaded and although user-mode emulation followed the threading model of the programs it translated, this was distinctly flaky in its behaviour. The process of converting QEMU to a fully multi-threaded app had started with the introduction of KVM support but for a long time it was always assumed that TCG had too much global state to make multi-threading viable.</p><p>    系统仿真的原始实现是单线程的，尽管用户模式仿真遵循其翻译的程序的线程模型，但这在行为上显然很不稳定。将QEMU转换为完全多线程的应用程序的过程始于引入KVM支持，但很长一段时间以来，一直认为TCG具有太多的全局状态，无法使多线程可行。 </p><p>  In the end it was a multi-year effort involving contributions from many different sections of the community. You can read about some of the details in a  LWN article I wrote as we approached merge. There where changes behind the scenes like a lock-less hash table called QEMU Hash Table ( QHT) which is optimised for the read case as well as front end changes like properly modelling atomic and memory barrier operations.</p><p>最后，这是一项多年努力，涉及社区许多不同部门的捐款。您可以在我进行合并时写的LWN文章中了解一些详细信息。幕后发生的变化如称为QEMU哈希表（QHT）的无锁哈希表（已针对读取案例进行了优化）以及前端更改（如正确地对原子和内存屏障操作进行建模）。</p><p>  Now MTTCG is the default for the majority of the mainline architectures and any new architecture tends to support MTTCG from the start.</p><p>  现在，MTTCG是大多数主线架构的默认设置，任何新架构从一开始就倾向于支持MTTCG。</p><p>    When we started working on implementing ARM’s  Scalable Vector Extensions for QEMU we realised we were taxing TCG’s scalar orientated API. Up until that point most Single Instruction Multiple Data (SIMD) instructions where implemented by manually unrolling into a series of scalar operations. While this worked it was somewhat inefficient, especially if the actual implementation would end up in helper calls anyway (as most floating point operations do). Previous proposals for introducing SIMD TCG ops had been rejected because of the large range of vector sizes that would lead to an explosion of TCG ops - one for each vector size.</p><p>    当我们开始为QEMU实施ARM的可扩展矢量扩展时，我们意识到我们正在对TCG的标量定向API费劲。到目前为止，大多数单指令多数据（SIMD）指令都是通过手动展开一系列标量操作来实现的。尽管这样做有效，但效率还是有些低下的，特别是如果实际的实现最终还是以助手调用的形式结束时（就像大多数浮点操作一样）。引入SIMD TCG ops的先前提议已被拒绝，因为矢量大小范围很大，这会导致TCG ops激增-每个矢量大小一个。</p><p>  In the end SVE’s vector size agnostic approach would be an inspiration for a new API which can encode a vector op on an arbitrarily sized vector. The interface is rich enough that the backend still has the option of using the hosts own vector instructions to generate code while also providing helper based fallbacks for the cases where we can’t. There is still a place for target specific helpers but now they can use the TCGv_vec interface to pass pointers to the register file in a consistent way. While originally written to support SVE work, other targets have started using the interface for their vector implementations.</p><p>  最终，SVE的向量大小不可知方法将是一种新API的灵感，该API可以在任意大小的向量上对向量op进行编码。该界面足够丰富，后端仍然可以选择使用主机自己的向量指令来生成代码，同时还为我们无法提供的情况提供基于帮助程序的后备。目标特定助手仍然存在，但现在他们可以使用TCGv_vec接口以一致的方式将指针传递到寄存器文件。虽然最初是为了支持SVE工作而编写的，但其他目标已经开始将界面用于其矢量实现。</p><p>    The translator works by translating a block of instructions at a time. At the end of the block it can jump to one of two blocks. When these are static addresses, that jump will get patched in, once the next block is translated. If the translator doesn’t know what to execute next it exits from the translated code back to the outer loop which will either translate a new block or process some sort of asynchronous operation. However, there is one case where we shouldn’t need to make such an expensive exit which is that of the computed jump. The translator can’t know at translation time where a jump may go, but it can certainly do the lookup inline and avoid the expensive exit.</p><p>    转换器通过一次翻译指令块来工作。在该块的末尾，它可以跳转到两个块之一。当这些是静态地址时，一旦下一个块被翻译，该跳转将被修补。如果翻译器不知道下一步要执行什么，它将从已翻译的代码返回到外部循环，该外部循环将翻译一个新块或处理某种异步操作。但是，在某些情况下，我们不需要进行如此昂贵的退出，即计算出的跳转。译员在翻译时无法知道跳转的位置，但可以肯定地进行内联查找并避免昂贵的退出。</p><p>    There is still plenty of scope to improve things, so some of things that are being considered for future improvement include:</p><p>    仍有很多改进的余地，因此，一些需要改进的方面包括：</p><p>    While the JIT is fast enough that you don’t notice it even in interactive use it is still quite inefficient in a lot of use cases. A common use case for linux-user mode is using a guest compiler as a fake cross-compiler - effectively running a native compiler on the emulated target hardware. For a typical compilation there is a lot of code that we end up re-generating for every invocation which is a bit of a waste. We could on completion of an execution save our translation cache for the benefit of future runs.</p><p>    尽管JIT足够快，即使在交互使用中您也不会注意到它，但在许多用例中它仍然效率很低。 linux-user模式的常见用例是使用来宾编译器作为伪交叉编译器-在模拟目标硬件上有效地运行本机编译器。对于典型的编译，最终每次调用都会重新生成很多代码，这有点浪费。我们可以在执行完成后保存翻译缓存，以备将来之用。 </p><p>    When running system emulation we disable chaining of generated blocks between pages. This is because at any point the system may swap out a page for different contents at which point we would need to find all blocks that jump into a page and invalidate them. However page granularity is overkill for a lot of the code. For example the kernel typically resides in a fixed series of physical pages and never swaps itself out.</p><p>在运行系统仿真时，我们禁用页面之间生成的块的链接。这是因为系统在任何时候都可能换出页面以换取不同的内容，这时我们将需要找到跳入页面的所有块并使它们无效。但是，对于许多代码而言，页面粒度过大。例如，内核通常驻留在一系列固定的物理页面中，并且从不进行交换。</p><p>    Currently the JIT doesn’t take into account any hot sequences of multiple blocks. For example most JavaScript engines will detect when a particular sequence of blocks is in a tight loop and then combine the hot-path into a single heavily optimised sequence. By taking the larger block into account you have more opportunities for traditional optimizations like dead-code elimination and register propagation.</p><p>    目前，JIT并未考虑多个块的任何热序列。例如，大多数JavaScript引擎将检测特定的块序列何时处于紧密循环中，然后将热路径组合为单个高度优化的序列。通过考虑更大的块，您将有更多机会进行传统优化，例如消除死代码和寄存器传播。</p><p>    The current optimisation pass is relatively simple as most blocks are quite small and you always need to ensure that values computed in host registers are stored correctly back in the memory that represents the guest registers before the end of the block. However currently we still end up re-loading values more than we need to. Two examples are  constants which are used for multiple operations and store-load propagation where a value is stored in a register and then immediately used for a following operation and is still present in a host register.</p><p>    当前的优化过程相对简单，因为大多数块都非常小，您始终需要确保在块结束之前，将主机寄存器中计算出的值正确地存储回代表来宾寄存器的内存中。但是，目前我们仍然需要重新加载更多的值。两个示例是用于多个操作和存储负载传播的常量，其中，值存储在寄存器中，然后立即用于后续操作，并且仍然存在于主机寄存器中。</p><p>    Single Static Assignment (SSA) form is a fairly standard way that compilers use to represent the data flow of a particular set of operations. It is favoured by compilers because it makes analysis easier and optimisations become a matter of transforming a tree of operations. QEMU currently uses a simpler virtual register approach which favours faster code generation. There is a trade-off to be made between fast and optimal code generation that we tend not to worry about with compilers (compare for example a -O0 and -O3 compile). It might be a step too far or it might be the gateway to even faster code. We shall have to experiment ;-)</p><p>    单一静态分配（SSA）表单是编译器用来表示特定操作集的数据流的相当标准的方式。它受到编译器的青睐，因为它使分析更容易，并且优化成为转换操作树的问题。 QEMU当前使用一种更简单的虚拟寄存器方法，该方法有利于更快的代码生成。在快速代码生成和最佳代码生成之间需要权衡取舍，而对于编译器，我们通常不必担心（例如，比较-O0和-O3编译）。这可能是距离太远的一步，也可能是更快代码的门户。我们将不得不试验;-)</p><p>    It is fair to assume a lot of the work done in the team is about improving QEMU’s ARM specific emulation - see for example the recent  changelog and  ARMv8.5-MemTag in the upcoming 5.1 release. However, we also benefit from the QEMU being a healthy project that supports a wide range of host and guest architectures. Our goal is still to make QEMU the go to emulation platform for free software developers to experiment with the latest ARM ISA features - as well as the best free software emulation platform for any architecture. I hope this article has given you a flavour of the sort of changes that have been made to the core translator over the last few years. There is certainly more to come as we continue to work on improving QEMU every day.</p><p>    可以公平地假设团队中完成的许多工作都是关于改进QEMU的ARM特定仿真的-例如，参见即将发布的5.1版本中的最新变更日志和ARMv8.5-MemTag。但是，我们也受益于QEMU是一个健康的项目，它支持各种各样的主机和客户机体系结构。我们的目标仍然是使QEMU成为免费软件开发人员的仿真平台，以试用最新的ARM ISA功能以及适用于任何体系结构的最佳免费软件仿真平台。我希望本文能使您了解过去几年对核心翻译人员所做的各种更改。随着我们每天继续致力于改善QEMU，肯定还会有更多的事情发生。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.linaro.org/blog/the-evolution-of-the-qemu-translator/">https://www.linaro.org/blog/the-evolution-of-the-qemu-translator/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/转换器/">#转换器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/qemu/">#qemu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tcg/">#tcg</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>