<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>比较Fauna和DynamoDB：体系结构和定价 Comparing Fauna and DynamoDB: Architecture and Pricing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Comparing Fauna and DynamoDB: Architecture and Pricing<br/>比较Fauna和DynamoDB：体系结构和定价 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-11 07:58:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/34b8e460dd272f44dd936bb803a47368.png"><img src="http://img2.diglog.com/img/2020/12/34b8e460dd272f44dd936bb803a47368.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>&lt;- Back     Fauna and DynamoDB are both serverless databases, but their design goals, architecture, and use cases are very different. In this post, I will overview both systems, discuss where they shine and where they don’t, and explain how various engineering and product decisions have created fundamentally different value propositions for database users.</p><p>＆lt;-Back Fauna和DynamoDB都是无服务器数据库，但是它们的设计目标，体系结构和用例却大不相同。在这篇文章中，我将概述两种系统，讨论它们在什么地方发光以及在哪些地方不发光，并解释各种工程和产品决策如何为数据库用户创造根本不同的价值主张。</p><p>  AWS DynamoDB was developed in response to the success of Apache Cassandra. The Cassandra database was originally open sourced and abandoned by Facebook in 2008. My team at Twitter contributed extensively to it alongside the team from Rackspace that eventually became DataStax.</p><p>  AWS DynamoDB是为响应Apache Cassandra的成功而开发的。 Cassandra数据库最初是在2008年由Facebook开源并放弃的。我在Twitter上的团队与Rackspace团队（后来成为DataStax）一起为该数据库做出了巨大贡献。</p><p> However, in an odd twist of history, Cassandra itself was inspired by a  2007 paper from Amazon about a different, internal database called Dynamo—an eventually-consistent key-value store that was used for high-availability shopping cart storage. Amazon cared a lot about shopping carts long before they had a Web Services business. Within Amazon, the Dynamo paper, and thus the roots of DynamoDB, predate any concept of offering a database product to external customers.</p><p> 但是，在一段奇怪的历史变迁中，Cassandra本身受到了亚马逊2007年的一篇论文的启发，该论文涉及一个名为Dynamo的内部数据库，后者是最终一致的键值存储，用于高可用性购物车存储。亚马逊很早就开始关注购物车，而他们还没有开展Web服务业务。在Amazon内部，Dynamo论文以及DynamoDB的根源早于向外部客户提供数据库产品的任何概念。</p><p> DynamoDB and Cassandra both focused on two things: high availability and low latency. To achieve this, their initial releases sacrificed everything else one might value from traditional operational databases like PostgreSQL or even MongoDB: transactionality, schema, database normalization or document modeling, indexes, foreign keys, even the idea of a query planner itself. DynamoDB did improve on the original Dynamo architecture by making single-key writes serializable and dropping the baroque CRDT reconciliation scheme, and on Cassandra by having a somewhat more humane API.</p><p> DynamoDB和Cassandra都专注于两件事：高可用性和低延迟。为了实现这一目标，他们的初始版本牺牲了PostgreSQL等传统操作数据库甚至MongoDB可能带来的其他价值：事务性，模式，数据库规范化或文档建模，索引，外键，甚至是查询计划程序本身的想法。 DynamoDB通过使可序列化的单键写入可序列化并删除了巴洛克式的CRDT协调方案，确实在原始Dynamo架构上进行了改进，而在Cassandra上通过具有更人性化的API进行了改进。</p><p>  DynamoDB’s architecture essentially puts a web server in front of a collection of B-tree partitions (think  BDB databases) into which documents are consistently hashed. Documents are columnar, but do not have a schema.</p><p>  DynamoDB的体系结构本质上是将Web服务器置于B树分区（认为是BDB数据库）的集合的前面，在这些B树分区中，文档始终被哈希化。文档是纵栏式的，但是没有架构。</p><p> Within a DynamoDB region, each data partition is replicated three times. Durability is guaranteed by requiring synchronous majority commits on writes. Consistency is only enforced within a single partition, which in practice, means a single document, because partition boundaries cannot be directly managed. Writes always go through a leader replica first; reads can come from any replica in eventually-consistent mode, or the leader replica in strongly consistent mode.</p><p> 在DynamoDB区域内，每个数据分区被复制3次。通过要求在写入时进行同步多数提交来保证持久性。一致性仅在单个分区内强制实施，实际上，这意味着单个文档，因为无法直接管理分区边界。写入始终首先通过领导者副本进行；读取可以来自最终一致模式下的任何副本，也可以来自强一致模式下的前导副本。</p><p> Although DynamoDB has recently added some new features like secondary indexes and multi-key transactions, their limitations reflect the iron law of DynamoDB: “everything is a table”:</p><p> 尽管DynamoDB最近添加了一些新功能，例如二级索引和多键事务，但是它们的局限性反映了DynamoDB的铁律：“一切都是表格”： </p><p> Replication to other regions is implemented by creating additional tables that asynchronously apply changes from a per-replica, row-based changelog.</p><p>复制到其他区域是通过创建其他表来实现的，这些表异步地应用每个副本基于行的更改日志中的更改。</p><p> Secondary indexes are implemented by asynchronously projecting data into additional tables--they are not serializable and not transactional.</p><p> 辅助索引是通过将数据异步投影到其他表中来实现的-它们不可序列化且不可事务处理。</p><p> Transactionality is implemented via a multi-phase lock—presumably DynamoDB keeps a hidden lock table, which is directly reflected in the additional costs for transactionality. DynamoDB transactions are not ACID (they are not fully  isolated or serializable) and cannot effectively substitute for relational transactions. Transaction state is not visible to replicas or even to secondary indexes within the same replica.</p><p> 事务性是通过多阶段锁定实现的-大概是DynamoDB保留了一个隐藏的锁定表，这直接反映在事务性的额外成本中。 DynamoDB事务不是ACID（它们不是完全隔离的或可序列化的），并且不能有效地替代关系事务。事务状态对副本甚至同一副本内的二级索引都不可见。</p><p> As you may predict from the above, the DynamoDB literature is absolutely packed with examples of “single-table design” using aggressive NoSQL-style denormalization. Using the more complex features is generally discouraged. It makes sense that DynamoDB’s pricing is also designed around single-table, eventually-consistent usage, even though in replicated and indexed scenarios individual queries must interact with multiple tables, often multiple times.</p><p> 正如您可能从上面预测的那样，DynamoDB文献中绝对包含使用积极的NoSQL风格的非规范化的“单表设计”示例。通常不建议使用更复杂的功能。有道理的是，即使在复制和建立索引的方案中，单个查询必须与多个表进行交互（通常是多次），DynamoDB的定价也围绕单表，最终一致的用法进行设计。</p><p> Additional challenges lie in the query model itself. Unlike Fauna’s query language FQL or SQL, DynamoDB’s API does not support dependent reads or intra-query computation. Fauna does, allowing developers to encapsulate complex business logic in transactions without any consistency, latency, or availability penalty.</p><p> 其他挑战在于查询模型本身。与Fauna的查询语言FQL或SQL不同，DynamoDB的API不支持从属读取或查询内计算。 Fauna做到了，允许开发人员将复杂的业务逻辑封装在事务中，而不会造成任何一致性，延迟或可用性损失。</p><p> DynamoDB works best for the use cases for which it was originally designed—scenarios where data can be organized by hand to match a constrained set of predetermined query patterns; where low latency from a single region is enough; and where multi-document updates are the exception, not the rule. For example, lock storage, as durable cache for a different, less scalable database like an RDBMS, or for transient data like the original shopping cart use case.</p><p> DynamoDB最适合最初设计的用例，即可以手动组织数据以匹配一组受限的预定查询模式的场景；来自单个区域的低延迟就足够了；并且多文档更新是例外，而不是规则。例如，锁存储，作为RDBMS等不同的，可伸缩性较小的数据库的持久缓存，或作为原始购物车用例的临时数据。</p><p>  Fauna, on the other hand, was inspired from our experience at Twitter delivering a global real-time consumer internet service and API. Our team has extensively used and contributed to MySQL, Cassandra, Memcache, Redis, and many other popular data systems. Rather than focus on helping people optimize workloads that are already at scale, we wanted to help people develop functionality quickly and scale it easily over time.</p><p>  另一方面，Fauna的灵感来自我们在Twitter上的经验，该经验提供了全球实时的消费者互联网服务和API。我们的团队广泛使用MySQL，并为MySQL，Cassandra，Memcache，Redis和许多其他流行的数据系统做出了贡献。我们希望帮助人们快速开发功能并随时间轻松扩展功能，而不是专注于帮助人们优化已经大规模的工作负载。 </p><p> We wanted to make it possible for any development team to iterate on their application along the journey from small to large  without having to become database experts and spend their time on caching, denormalization, replication, architectural rewrites, and everything else that distracts from building a successful software product.</p><p>我们希望使任何开发团队都可以在从小型到大型的整个过程中迭代其应用程序，而不必成为数据库专家，而将他们的时间花在缓存，非规范化，复制，体系结构重写以及其他一切不利于构建数据库的事情上。成功的软件产品。</p><p>  To further this goal, Fauna uses a  unique architecture that guarantees low latency and transactional consistency across all replicas and indexes even with global replication, and offers a  unique query language that preserves key relational concepts like ACID transactions, foreign keys, unique constraints, and stored procedures, while also enabling modern non-relational concepts like document-oriented modeling, declarative procedural indexing, and a standards-based GraphQL API.</p><p>  为了实现此目标，Fauna使用独特的体系结构，即使使用全局复制，该体系结构也可确保所有副本和索引之间的低延迟和事务一致性，并提供一种独特的查询语言，该语言保留了关键关系概念，如ACID事务，外键，唯一约束和存储程序，同时还支持现代非关系概念，例如面向文档的建模，声明性过程索引和基于标准的GraphQL API。</p><p>  Data replicas apply transaction statements from the log in deterministic order, guaranteeing ACID properties without additional coordination.</p><p>  数据副本以确定的顺序应用日志中的事务处理语句，从而确保ACID属性而无需其他协调。</p><p>  Read-only transactions achieve lower latency than writes by skipping the log, but with additional tricks, remain fully consistent.</p><p>  通过跳过日志，只读事务可实现比写入更低的延迟，但还有其他技巧，可以保持完全一致。</p><p> Unlike DynamoDB, Fauna shines in the same areas the SQL RDBMS does: modeling messy real-world interaction patterns that start simply but must evolve and scale over time. Unlike SQL, Fauna’s API and security model is designed for the modern era of mobile, browser, edge, and  serverless applications.</p><p> 与DynamoDB不同，Fauna在SQL RDBMS的相同领域中发挥着重要作用：对混乱的现实世界交互模式进行建模，这些交互模式开始时很简单，但是必须随着时间的推移而发展和扩展。与SQL不同，Fauna的API和安全模型是为现代移动，浏览器，边缘和无服务器应用程序设计的。</p><p> Like DynamoDB, and unlike the RDBMS, Fauna transparently manages operational concerns like replication, data consistency, and high availability. However, a major difference from DynamoDB is the scalability model. DynamoDB scales by predictively splitting and merging partitions based on observed throughput and storage capacity. By definition, this works well for predictable workloads, and less well for unpredictable ones, because  autoscaling changes take time.</p><p> 与DynamoDB一样，与RDBMS不同，Fauna透明地管理操作问题，例如复制，数据一致性和高可用性。但是，与DynamoDB的主要区别在于可伸缩性模型。 DynamoDB通过根据观察到的吞吐量和存储容量来预测性地拆分和合并分区来进行扩展。根据定义，这对于可预测的工作负载效果很好，而对于不可预测的工作负载效果则不太好，因为自动缩放更改需要时间。</p><p> FaunaDB, on the other hand, scales dynamically. As an API, all resources including compute and storage are potentially available to all users at any time. Similar to operating system multithreading, Fauna is continuously scheduling, running, and pausing queries across all users of the service. Resource consumption is tracked and billed, and our team scales the capacity of each region in aggregate, not on a per-user basis.</p><p> 另一方面，FaunaDB可动态扩展。作为API，包括计算和存储在内的所有资源随时都可能对所有用户可用。与操作系统多线程类似，Fauna在服务的所有用户之间持续调度，运行和暂停查询。对资源消耗进行跟踪和计费，并且我们的团队总体上扩展了每个区域的容量，而不是基于每个用户。 </p><p> Naturally, this design has a different cost structure than something like DynamoDB. For example, there is no way to create an unreplicated Fauna database or to disable transactions. Like DynamoDB, Fauna has metered pricing that scales with the resources your workload actually consumes. But unlike DynamoDB, you are not charged per low-level read and write operation, per replica, per index, because our base case is DynamoDB’s outlier case: the normalized, indexed data model, with the transactional, multi-region access pattern.</p><p>自然，这种设计的成本结构与DynamoDB之类的成本结构不同。例如，无法创建非复制的Fauna数据库或禁用事务。与DynamoDB一样，Fauna的计费定价根据您的工作负载实际消耗的资源而定。但是与DynamoDB不同，您不需为每个低级的读写操作，每个副本，每个索引付费，因为我们的基本情况是DynamoDB的异常情况：具有事务性多区域访问模式的规范化索引数据模型。</p><p> Higher levels of abstraction exist to deliver higher levels of productivity. Fauna offers a much higher level of abstraction than DynamoDB, and our pricing reflects that as well—it includes by default everything that DynamoDB does not. At Fauna we want to provide a database with the highest possible level of abstraction, so that you don’t have to worry about any of the low level concerns at all.</p><p> 存在更高级别的抽象以提供更高级别的生产力。 Fauna提供的抽象级别比DynamoDB高得多，并且我们的定价也反映出这一点-默认情况下，它包含DynamoDB不提供的所有内容。在Fauna，我们希望为数据库提供尽可能高的抽象级别，以便您完全不必担心任何低级别的问题。</p><p>  Almost all other databases aside from DynamoDB and Fauna are delivered as managed cloud infrastructure, and billed on a provisioned basis that directly reflects the vendor’s costs and those costs alone. Serverless infrastructure is relatively new—S3 is perhaps the first service with a serverless billing model to reach widespread adoption—and serverless databases are even newer. The serverless model in DynamoDB is a retrofit. It is essentially still a provisioned system with the addition of predictive autoscaling.</p><p>  除了DynamoDB和Fauna之外，几乎所有其他数据库都作为托管的云基础结构交付，并按预配置计费，直接反映了供应商的成本以及这些成本。无服务器基础设施是相对较新的-S3可能是第一种具有无服务器计费模型的服务，可以被广泛采用-无服务器数据库甚至更新。 DynamoDB中的无服务器模型是一种改进。从本质上讲，它仍然是预配置的系统，并具有预测性自动缩放功能。</p><p> Instead, serverlessness to date has mainly been restricted to vertically-integrated, single-purpose APIs. These APIs have been monetized indirectly like Twitter, billed per-action like Twilio, or billed as a percentage of the value exchanged via the API between third parties—like Stripe.</p><p> 取而代之的是，迄今为止，无服务器性主要限于垂直集成的单用途API。这些API已通过Twitter间接获利，如Twilio那样按操作收费，或按第三方（如Stripe）之间通过API交换的价值的百分比计费。</p><p> Serverless infrastructure, as we all know, is actually  made from servers. It has a more complex accounting challenge than vertically-integrated APIs, and is constrained by:</p><p> 众所周知，无服务器基础架构实际上是由服务器组成的。与垂直集成的API相比，它具有更复杂的记帐挑战，并且受以下因素的约束：</p><p>  The multi-tenancy of serverless infrastructure creates a fundamentally better customer experience. Who wants to pay for capacity they aren’t using? Who wants to have their application degrade because they didn’t buy enough capacity in advance? It’s also a better vendor experience, since no vendor wants to waste infrastructure, and it can be more environmentally friendly.</p><p>  无服务器基础架构的多租户可从根本上改善客户体验。谁愿意为不使用的容量付费？谁想要由于他们没有提前购买足够的容量而导致其应用程序降级？这也是一种更好的供应商体验，因为没有供应商愿意浪费基础设施，而且可以更加环保。</p><p> However, the vendor’s aggregate price across all customers must cover the static infrastructure costs, which are tightly coupled and resistant to change. (As a practical matter, a vendor can’t upgrade and downgrade CPUs, memory, disks, and networks independently of either on demand, even when using managed cloud services.) The aggregate price must also correlate with the business value recognized, and it must be appropriately apportioned based on the realization of that value for each individual customer over time.</p><p> 但是，供应商在所有客户之间的总价必须涵盖静态基础结构成本，这些成本紧密耦合并且可以抵御变化。 （实际上，即使使用托管云服务，供应商也不能独立于需求按需升级和降级CPU，内存，磁盘和网络。）总价还必须与公认的业务价值相关联，并且必须根据每个客户随时间实现的价值进行适当分配。 </p><p> Compared to simply marking up the incremental cost of a server, this pricing problem is hard. Let’s discuss the solutions that DynamoDB and Fauna have found.</p><p>与仅标记服务器的增量成本相比，此定价问题很难解决。让我们讨论DynamoDB和Fauna找到的解决方案。</p><p>  After careful analysis and testing, we believe these formulas correctly summarize  DynamoDB pricing, specifically on-demand billing in most US AWS regions:</p><p>  经过仔细的分析和测试，我们相信以下公式正确总结了DynamoDB的定价，尤其是在美国大部分AWS地区的按需计费：</p><p> $0.25 * ((eventually‑consistent‑reads + index‑reads) * 0.5 + consistent‑reads + transactional‑reads * 2)</p><p> $ 0.25 *（（最终一致读+索引读）* 0.5 +一致读+事务读* 2）</p><p> $1.25 * (consistent‑writes + transactional‑writes * 2 + (consistent‑writes + transactional‑writes) * index‑count) * replica‑count</p><p> $ 1.25 *（一致写入+事务性写入* 2 +（一致写入+事务性写入）*索引计数）*复制数</p><p> Read operations assume a data size of 4K or less; each additional 4K costs an additional operation. Write operations assume a data size of 1K or less. Notably, index writes count as entirely separate write operations; they are not included in the document’s 1K.</p><p> 读取操作假定数据大小为4K或更小；每增加4K，就会增加一次操作。写操作假定数据大小为1K或更小。值得注意的是，索引写入被视为完全独立的写入操作；它们不包含在文档的1K中。</p><p> As a rule, read costs scale with the number of documents multiplied by the consistency level. Write costs scale with the number of documents multiplied by the number of indexes, multiplied again by the number of replicas, plus the consistency level.</p><p> 通常，读取成本按文档数量乘以一致性级别来衡量。写入成本按文档数乘以索引数，再乘以副本数再加上一致性级别来衡量。</p><p> This pricing is clear and straightforward in the use cases that DynamoDB was designed for. However, if you add in usage of newer features like global replication, indexes, and transactions, the pricing becomes more opaque, and it can become very difficult to predict costs in advance.</p><p> 在DynamoDB设计的用例中，这种定价清晰明了。但是，如果您添加了诸如全局复制，索引和事务之类的新功能，定价将变得更加不透明，并且很难预先预测成本。 </p><p>    Read operations assume a data size of 4K or less; each additional 4K costs an additional operation. Write operations assume a data size of 1K or less. Unlike DynamoDB, index writes are charged by size only, not by both size and number of indexes. If a document write and its indexes fit within the 1K limit, there will be no additional charge for the indexes. Since index data is usually small, many indexes can be updated in just a few write operations, greatly reducing costs. Finally, there is no separate charge for replication; in Fauna, data is data.</p><p>读取操作假定数据大小为4K或更小；每增加4K，就会增加一次操作。写操作假定数据大小为1K或更小。与DynamoDB不同，索引写入仅按大小收费，而不同时按索引大小和数量收费。如果文档写操作及其索引在1K的范围内，则索引不会收取额外费用。由于索引数据通常很小，因此只需几次写操作就可以更新许多索引，从而大大降低了成本。最后，复制没有单独的费用。在动物区系中，数据就是数据。</p><p> DynamoDB doesn’t support computation of any kind within a query, but Fauna does. Thus, Fauna charges separately for compute costs. In DynamoDB, since computation for any particular workload can’t be done in the database at all, it must be done application-side in a compute environment like AWS Lambda, which has its own cost.</p><p> DynamoDB不支持查询中的任何类型的计算，但Fauna支持。因此，Fauna分别收取计算成本。在DynamoDB中，由于根本无法在数据库中完成任何特定工作负载的计算，因此必须在应用程序端在AWS Lambda之类的计算环境中完成，这需要自己付费。</p><p>   The efficiency variance of the possible compute stacks that would substitute for Fauna compute is so high (Ruby in AWS Lambda vs. C++ on EC2?) that it is not possible to make any general comparison. Nevertheless, doing data-dependent computation co-located with the data itself is usually a good thing, so Fauna shows well in most real-world scenarios.</p><p>   替代Fauna计算的可能计算堆栈的效率差异非常大（AWS Lambda中的Ruby与EC2上的C ++？），无法进行任何常规比较。尽管如此，与数据本身位于同一位置的依赖于数据的计算通常是一件好事，所以Fauna在大多数实际场景中都表现良好。</p><p> However, note that every API call costs at least one compute operation. In Fauna, it’s best to write sophisticated queries that do as much work as possible in a single request, rather than treat it like a key-value store. This minimizes costs, maximizes performance, and guarantees transactional correctness.</p><p> 但是，请注意，每个API调用至少要花费一次计算操作。在Fauna中，最好编写复杂的查询，以在单个请求中完成尽可能多的工作，而不是将其视为键值存储。这样可以最小化成本，最大化性能并保证交易的正确性。</p><p> Because it’s more high level, Fauna’s pricing is much more straightforward. The downside, of course, is if you don’t want the higher level functionality, it may be more expensive than DynamoDB. You get what you pay for in serverless!</p><p> 因为价格更高，所以动物区系的定价要简单得多。当然，不利的一面是，如果您不想要更高级别的功能，则它可能比DynamoDB昂贵。您可以在无服务器环境中获得所需的费用！</p><p>  Let’s take the most basic possible example to start. Imagine a hit counter on a webpage from 1998. It doesn’t have to be recent, it doesn’t have to be fast, but it does have to increase over time. We will do one million reads and one million writes to a single document, at the default consistency level and with the default replication configuration.</p><p>  让我们以最基本的示例开始。想象一下1998年以来某个网页上的点击量计数器。它不一定是最新的，它不必很快，但它必须随着时间而增加。我们将以默认的一致性级别和默认的复制配置对单个文档进行100万次读取和100万次写入。</p><p> In Dynamo, this gives us an eventually consistent read, and a consistent write, in one region. Because of the read default, clients will not even be able to read their own writes: somebody could refresh our webpage and see the count stay the same, which doesn’t make sense. But they probably won’t notice, and after all, we don’t want to spend much money counting hits.</p><p> 在Dynamo中，这使我们在一个区域中实现了最终一致的读取和一致的写入。由于默认为读取，客户甚至无法读取自己的写入内容：有人可以刷新我们的网页，看到数量保持不变，这没有任何意义。但是他们可能不会注意到，毕竟，我们不想花很多钱来计算点击数。 </p><p> In Fauna, we get more than we asked for. We get global replication, providing higher availability and lower latency to clients. We also get consistency across keys, but since our visitors aren’t in the habit of comparing counts across pages in realtime, nobody will probably know the difference . However, clients will always read their own writes, which is good: refreshing the page will always make the hit count go up.</p><p>在动物区系，我们得到的超出了我们的要求。我们获得全局复制，从而为客户端提供更高的可用性和更低的延迟。我们还可以使键之间保持一致，但是由于访问者不习惯于实时比较跨页计数，因此没人会知道其中的区别。但是，客户总是会读自己的文章，这很不错：刷新页面总是会使点击量增加。</p><p>    This seems a bit high for Fauna, but if we batch operations in groups of 50 per request, the compute cost is amortized:</p><p>    对于Fauna来说，这似乎有点高，但是如果我们将每个请求以50个为一组批处理操作，则将分摊计算成本：</p><p> ($0.50 + $2.25 / 50) * 1 + ($2.50 + $2.25 / 50 ) * 1</p><p> （$ 0.50 + $ 2.25 / 50）* 1 +（$ 2.50 + $ 2.25 / 50）* 1</p><p>   Let’s do something useful now, like the original Dynamo use case, the globally replicated shopping cart. Unlike the implementation described in the paper, we are not going to store entire carts as single records, nor will we rely on complex CRDT schemes to merge conflicting carts. We have better technology now and we can model carts as collections of items in a more natural, relational way.</p><p>   现在，让我们做些有用的事情，例如原始的Dynamo用例，全球复制的购物车。与本文中描述的实现不同，我们不会将整个购物车存储为单个记录，也不会依赖复杂的CRDT方案来合并有冲突的购物车。我们现在拥有更好的技术，我们可以以更自然，更相关的方式将购物车建模为商品的集合。</p><p> To make sure users can always access their cart quickly, we will configure DynamoDB with two additional replicas. We will also add three indexes in both DynamoDB and Fauna, so that we can sort the items in the three ways, regardless of how many items there are.</p><p> 为了确保用户始终可以快速访问他们的购物车，我们将为DynamoDB配置两个附加副本。我们还将在DynamoDB和Fauna中都添加三个索引，以便我们可以用三种方式对项目进行排序，而不管有多少项目。</p><p> And we will use consistent reads for DynamoDB, so that customers can’t see missing items in the default view. However, DynamoDB indexes are  never consistent. So for DynamoDB, we need to make duplicate consistent reads of the items by their primary key after reading them via the index, to verify that they are still really in the cart.</p><p> 而且，我们将对DynamoDB使用一致的读取，这样客户就不会在默认视图中看到缺失的物品。但是，DynamoDB索引永远不会保持一致。因此，对于DynamoDB，我们需要在通过索引读取项目后，通过它们的主键对项目进行重复一致的读取，以验证它们是否仍在购物车中。</p><p> For one million carts where we add a single item and then view the cart, our costs are:</p><p> 对于一百万个购物车，我们在其中添加了一个商品然后查看了购物车，我们的成本是： </p><p> $0.25 * (1 * 0.5 + 1) + $1.25 * (1 + 1 * 3) * 3</p><p>$ 0.25 *（1 * 0.5 +1）+ $ 1.25 *（1 +1 * 3）* 3</p><p>  Because our index values are small and fit within the 1K write operation limit, there is no separate charge for indexing. We also do not need to pay extra for multi-region replication.</p><p>  因为我们的索引值很小并且适合1K写操作限制，所以没有单独收取索引费用。我们也不需要为多区域复制支付额外的费用。</p><p> Adding and viewing multiple items per request would benefit Fauna’s model even more, due to compute cost amortization. Let’s add 5 items and view the result in each request:</p><p> 由于计算成本摊销，每个请求添加和查看多个项目将使Fauna的模型受益更多。让我们添加5个项目并在每个请求中查看结果：</p><p> $0.25 * (5 * 0.5 + 5) + $1.25 * (5 + 5 * 3) * 3</p><p> $ 0.25 *（5 * 0.5 + 5）+ $ 1.25 *（5 + 5 * 3）* 3</p><p>   Finally, let’s imagine we have something more like a typical SaaS application, for example, a CRM. We have an accounts table with 20 secondary indexes defined for all the possible sort fields (DynamoDB’s maximum—Fauna has no limit). We also have an activity table with 10 indexes, and a users table with 5 indexes. Viewing just the default account screen queries 7 indexes and 25 documents. A typical activity update transactionally updates 3 documents at a time with 10 dependency checks and modifies all 35 indexes.</p><p>   最后，让我们想象一下，我们有一些类似典型的SaaS应用程序的产品，例如CRM。我们有一个帐户表，其中为所有可能的排序字段（DynamoDB的最大值，Fauna没有限制）定义了20个二级索引。我们还有一个包含10个索引的活动表和一个包含5个索引的用户表。仅查看默认帐户屏幕将查询7个索引和25个文档。一个典型的活动更新通过10个依赖项检查一次事务性地更新3个文档，并修改所有35个索引。</p><p> And of course, we have replicated this data globally to two additional regions in DynamoDB. We will also do consistency checks on all data returned from indexes.</p><p> 当然，我们已经将该数据全局复制到了DynamoDB中的另外两个区域。我们还将对从索引返回的所有数据进行一致性检查。</p><p> In Fauna, we do not need to configure replication, or do any additional consistency checking. And we benefit greatly from Fauna’s index write coalescing.</p><p> 在动物区系中，我们不需要配置复制或进行任何其他的一致性检查。而且，我们也从Fauna的索引写入合并中受益匪浅。 </p><p> With that in mind, one million account screen views and one million activity updates will cost us:</p><p>考虑到这一点，一百万个帐户的屏幕浏览量和一百万个活动更新将使我们花费：</p><p> $0.25 * (7 * 0.5 + 7 + 25 + 10) + $1.25 * (3 * 2 + 3 * 35) * 3</p><p> $ 0.25 *（7 * 0.5 + 7 + 25 + 10）+ $ 1.25 *（3 * 2 + 3 * 35）* 3</p><p> ($0.50 * (7 + 25) + $2.25) + ($0.50 * 10 + $2.50 * 3 + $2.25)</p><p> （$ 0.50 *（7 + 25）+ $ 2.25）+（$ 0.50 * 10 + $ 2.50 * 3 + $ 2.25）</p><p>  Even if we assume that Fauna will require multiple write operations per document because of all the indexes, the result does not materially change. Fauna’s query pattern could also be improved by using unique constraints instead of dependency reads, which would reduce costs further.</p><p>  即使我们假设Fauna由于所有索引都需要对每个文档执行多次写操作，结果也不会发生实质性变化。通过使用唯一约束而不是依赖项读取，还可以改善Fauna的查询模式，这将进一步降低成本。</p><p>  One misconception we see is that DynamoDB is cheap at scale and Fauna is expensive, or that DynamoDB is fast and Fauna is slow. This is untrue, although understandable given that many people evaluate a simple use case and move on.</p><p>  我们看到的一个误解是DynamoDB在规模上很便宜，而Fauna则很昂贵，或者DynamoDB很快而Fauna却很慢。这是不正确的，尽管可以理解，因为许多人都评估了一个简单的用例并继续前进。</p><p> Because DynamoDB is designed for the simple use case rather than the complex, it always wins this superficial comparison. Along with the pricing model, there are various other pain points in DynamoDB like manual partitioning and the eventually-consistent DDL that reflect its roots as a lower-level system.</p><p> 由于DynamoDB是为简单的用例而不是复杂的用例设计的，因此它总是赢得这种表面的比较。除了定价模型外，DynamoDB还存在其他许多痛点，例如手动分区和最终一致的DDL，这反映了其作为低级系统的根源。</p><p> This situation is similar, but less malignant, than the MongoDB  unsafe commit scandal, where writes appeared faster than the laws of physics allow, because the MongoDB client acknowledged them before they were actually written. Indeed, not doing something is always faster and cheaper than doing it—but if the customer does need to do it, they must take on the implementation burden of supporting what should be a database-level concern in a broken, ad-hoc way in their application.</p><p> 这种情况与MongoDB不安全的提交丑闻相似，但没有那么恶性，后者的写出速度快于物理定律，因为MongoDB客户端在实际写之前就承认了它们。确实，不做某事总是比做某事更快，更便宜—但是，如果客户确实需要做某件事，他们必须承担实现负担，以断断续续的临时方式支持数据库级关注点他们的应用。 </p><p> For example, if you configure a dozen indexes for a global deployment in Dynamo, you will find your write and storage costs have multiplied by an order of magnitude compared to a single region, unindexed table. Make them transactional writes or start doing dependent reads and they go up even more. On the other hand, if you try to use Fauna as an application-adjacent durable cache at scale, you may find you are paying for data replication and transactional consistency that you don’t actually need.</p><p>例如，如果为Dynamo中的全局部署配置了十几个索引，则与单个未索引区域的表相比，您的写入和存储成本将增加一个数量级。使它们成为事务性写入或开始进行从属读取，它们的上升速度甚至更大。另一方面，如果您尝试将Fauna大规模用作与应用程序相邻的持久性高速缓存，则可能会发现您为实际上不需要的数据复制和事务一致性支付了费用。</p><p> It is more accurate to say that both DynamoDB and Fauna are fast and cheap when used for their correct purposes, and expensive when used incorrectly. This seems like a universal rule, but it actually isn’t. Most databases, even in the managed cloud, are disproportionately expensive for intermittent or variable workloads, which real-world workloads always are. This is the benefit of the serverless model: an order of magnitude less waste for both the customer and the vendor.</p><p> 准确地说，DynamoDB和Fauna在用于正确目的时既快速又便宜，而在错误使用时则很昂贵。这似乎是一条通用规则，但实际上并非如此。即使是在托管云中，大多数数据库对于间歇性或可变工作负载（现实世界中的工作负载始终如此）而言，其成本却过高。这是无服务器模型的好处：对客户和供应商的浪费都减少了一个数量级。</p><p>  At Fauna, we recognize that DynamoDB has pushed the envelope in distributed cloud databases and we are grateful for that. We share the same greater mission. At the same time, we know we as an industry can do better than  all existing databases for mission-critical operational workloads, whether key-value, document-oriented, or based on SQL.</p><p>  在Fauna，我们认识到DynamoDB推动了分布式云数据库的发展，对此我们深表感谢。我们肩负着更大的使命。同时，我们知道作为关键行业，面向文档或基于SQL的任务关键型工作负载，作为一个行业，我们可以比所有现有数据库做得更好。</p><p> I hope this post has provided you clearer understanding of the motivations, architectures, and business value of both DynamoDB and Fauna. And further, that this understanding helps you make more informed decisions about wh</p><p> 希望本文能使您对DynamoDB和Fauna的动机，架构和业务价值有更清晰的了解。而且，这种理解可以帮助您做出更明智的决策</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fauna.com/blog/comparing-fauna-and-dynamodb">https://fauna.com/blog/comparing-fauna-and-dynamodb</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/dynamodb/">#dynamodb</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fauna/">#fauna</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>