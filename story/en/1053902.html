<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Regexploit：DOS-能够的正则表达式 Regexploit: DoS-Able Regular Expressions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Regexploit: DoS-Able Regular Expressions<br/>Regexploit：DOS-能够的正则表达式 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-22 12:53:09</div><div class="page_narrow text-break page_content"><p>When thinking of Denial of Service (DoS), we often focus on Distributed Denial of Service (DDoS) where millions of zombie machines overload a service by launching a tsunami of data.However, by abusing the algorithms a web application uses, an attacker can bring a server to its knees with as little as a single request.Doing that requires finding algorithms which have terrible performance under certain conditions, and then triggering those conditions.One widespread and frequently vulnerable area is in the misuse of regular expressions (regexes).</p><p>在思考拒绝服务（DOS）时，我们经常专注于分布式拒绝服务（DDOS），其中数百万僵尸机通过启动数据的海啸来重载服务。然而，通过滥用Web应用程序使用的算法，可以使用攻击者将服务器带到其膝盖，只需单个请求。需要发现在某些条件下具有可怕性能的算法，然后触发那些条件的算法。一般且经常易受攻击的区域是滥用正则表达式（正则表达式）。</p><p> Regular expressions are used for all manner of text-processing tasks.They may seem to run fine, but if a regex is vulnerable to Regular Expression Denial of Service (ReDoS), it may be possible to craft input which causes the CPU to run at 100% for years.</p><p> 正则表达式用于所有文本处理任务的方式。它们似乎可以运行正常，但如果正则表达式容易受到正则表达式拒绝服务（REDO），则可以工艺引起CPU运行的输入100％多年。</p><p> In this blog post, we’re releasing a new tool to analyse regular expressions and hunt for ReDoS vulnerabilities. Our heuristic has been proven to be extremely effective, as demonstrated by many vulnerabilities discovered across popular NPM, Python and Ruby dependencies.</p><p> 在本博客文章中，我们正在发布一个新工具来分析正则表达式并寻找Redos漏洞。我们的启发式已被证明是非常有效的，正如各地流行的NPM，Python和Ruby依赖项所发现的许多漏洞所示。</p><p>     To get into the topic, let’s review how the regex matching engines in languages like Python, Perl, Ruby, C# and JavaScript work. Let’s imagine that we’re using this deliberately silly regex to extract version numbers:</p><p>     要进入主题，让我们回顾像Python，Perl，Ruby，C＃和JavaScript工作的语言中的Regex匹配引擎的匹配方式。让我们想象一下，我们正在使用这种故意愚蠢的regex来提取版本号：</p><p>  That will correctly process something like  123.456.789, but it’s a pretty inefficient regex. How does the matching process work?</p><p>  这将正确地处理类似于123.456.789的东西，但它是一个非常低效的正则表达式。匹配过程如何工作？</p><p> The first  .+ capture group greedily matches all the way to the end of the string as dot matches every character.</p><p> 第一个。+捕获组贪婪地匹配字符串的末尾，因为点匹配每个角色。</p><p>    $1=&#34;123.456.789&#34;.The matcher then looks for a literal dot character.Unable to find it, it tries removing one character at a time from the first  .+</p><p>    $ 1 =＆＃34; 123.456.789＆＃34;那个匹配器然后查找一个字面点字符。可找到它，它试图从第一个字符删除一个字符。+ </p><p>        The second capture group matches the final three digits  $2=&#34;789&#34;, but we need another dot so it has to backtrack.</p><p>第二个捕获组与最终三位数2美元=＆＃34; 789＆＃34;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,望</p><p>    Hmmm… it seems that maybe the match for capture group 1 is incorrect, let’s try backtracking.</p><p>    嗯......似乎可能是捕获组1的匹配是不正确的，让我们尝试回溯。</p><p>    OK let’s try with  $1=&#34;123&#34;, and let’s match group 2 greedily all the way to the end.</p><p>    好的，让我们尝试1美元=＆＃34; 123＆＃34 ;,让我们将群体匹配到最后。</p><p>    $2=&#34;456.789&#34; but now there’s no dot! That can’t be the correct group 2…</p><p>    $ 2 =＆＃34; 456.789＆＃34;但现在没有DOT！这不能是正确的第2组......</p><p> As you can hopefully see, there can be a lot of back-and-forth in the regex matching process.This backtracking is due to the ambiguous nature of the regex, where input can be matched in different ways.If a regex isn’t well-designed, malicious input can cause a much more resource-intensive backtracking loop than this.</p><p> 正如您希望看到的，因此可以在Regex匹配过程中存在很多。这是由于正则表达式的模糊性质，其中输入可以以不同的方式匹配。如果正则表达式不是精心设计的，恶意输入可能导致更多的资源密集型回溯循环。</p><p> If backtracking takes an extreme amount of time, it will cause a Denial of Service, such as what happened to  Cloudflare in 2019.In runtimes like NodeJS, the  Event Loop will be blocked which stalls all timers,  awaits, requests and responses until regex processing completes.</p><p> 如果回溯需要极高的时间，它将导致拒绝服务，例如CloudFlare在2019年发生的事情。在NodeJS这样的运行时，将阻止事件循环，该循环停止所有计时器，等待，请求和响应直到正则表达式处理完成。</p><p>  Now we can look at a ReDoS example. The ua-parser package contains a  giant list of regexes for  deciphering browser User-Agent headers. One of the regular expressions reported in  CVE-2020-5243 was:</p><p>  现在我们可以看一下重做例子。 UA-Parser软件包包含用于解密浏览器用户 - 代理标头的巨大正则表达式列表。 CVE-2020-5243中报告的一个正则表达式是： </p><p>  If we look closer at the end part we can see three overlapping repeating groups:</p><p>如果我们在结束部门仔细观察，我们可以看到三个重叠重复组：</p><p>  Digit characters are matched by  \d and by  [ˆ\);]. If a string of  N digits enters that section, there are  ½(N-1)N possible ways to split it up between the  \d+,  [ˆ\);]+ and  [ˆ\);]* groups. The key to causing ReDoS is to supply input which  doesn’t successfully match, such as by not ending our malicious input with a closing parenthesis.The regex engine will backtrack and try all possible ways of matching the digits in the hope of then finding a  ).</p><p>  数字字符匹配\ d和[\）;]。如果一串n个数字进入该部分，则会在\ d +，[\）] +和[\）之间将其拆分为1/2（n-1）n可能的方法。导致重做的关键是提供未成功匹配的输入，例如未结束我们的恶意输入，并使用关闭括号。正则表达式引擎将返回并尝试所有可能的方式匹配数字的匹配数字的希望）。</p><p> This visualisation of the matching steps was produced by emitting verbose debugging from cpython’s regex engine using my  cpython fork.</p><p> 通过使用CPython Fork从CPython的Regex引擎发出冗长调试，通过从CPython的RegEx引擎发出匹配步骤的这种可视化。</p><p>  Today, we are releasing a tool called  Regexploit to extract regexes from code, scan them and find ReDoS.</p><p>  今天，我们正在发布一个名为Regexploit的工具来从代码中提取正则表达式，扫描它们并查找重做。</p><p> Several tools already exist to find regexes with exponential worst case complexity (regexes of the form  (a+)+b), but cubic complexity regexes ( a+a+a+b) can still be damaging. Regexploit walks through the regex and tries to find ambiguities where a single character could be captured by multiple repeating parts.Then it looks for a way to make the regular expression  not match, so that the regex engine has to backtrack.</p><p> 已经存在了几个工具以查找具有指数最坏情况复杂性的正则表达式（表单的正则表达式（A +）+ B），但立方复杂性正则表达式（A + A + A + B）仍然可以损害。 Regexploit遍历正则表达式，并试图找到一个字符可以通过多个重复零件捕获单个字符的含糊之处。然后它正在寻找一种使正则表达式不匹配的方法，以便Regex引擎必须回溯。</p><p> The  regexploit script allows you to enter regexes via stdin. If the regex looks OK it will say “No ReDoS found”. With the regex above it shows the vulnerability:</p><p> Regexploit脚本允许您通过Stdin输入正则表达式。如果正则表达式正常好的话，它会说“找不到重做”。使用上面的正则表达式，它显示了漏洞：</p><p> Worst-case complexity: 3 ⭐⭐⭐ (cubic)Repeated character: [[0-9]]Example: &#39;;0 Build/HuaweiA&#39; + &#39;0&#39; * 3456</p><p> 最糟糕的复杂性：3‰（立方）重复字符：[[0-9]]示例：＆＃39 ;; 0 Build / Huaweia＆＃39; +＆＃39; 0＆＃39; * 3456. </p><p> The final line of output gives a recipe for creating a User-Agent header which will cause ReDoS on sites using old versions of ua-parser, likely resulting in a Bad Gateway error.</p><p>最终输出系列提供了一个创建用户代理标题的配方，该标题将使用旧版本的UA-Parser在站点上导致重做可能导致错误的网关错误。</p><p>  To scan your source code, there is built-in support for extracting regexes from  Python,  JavaScript,  TypeScript,  C#,  JSON and  YAML. If you are able to extract regexes from other languages, they can be piped in and analysed.</p><p>  要扫描您的源代码，有内心支持从Python，JavaScript，CyperScript，C＃，JSON和Yaml中提取正则表达式。如果您能够从其他语言中提取正则表达式，则可以将其送入并分析。</p><p> Once a vulnerable regular expression is found, it does still require some manual investigation. If it’s not possible for untrusted input to reach the regular expression, then it likely does not represent a security issue. In some cases, a prefix or suffix might be required to get the payload to the right place.</p><p> 一旦找到了一个脆弱的正则表达式，它仍然需要一些手动调查。如果不可信的输入不可能达到正则表达式，那么它可能不代表安全问题。在某些情况下，可能需要前缀或后缀以将有效载荷获取到正确的位置。</p><p>  So what kind of ReDoS issues are out there? We used  Regexploit to analyse the top few thousand npm and pypi libraries (grabbed from the  libraries.io API) to find out.</p><p>  那么有什么样的重做问题？我们使用Regexploit来分析几千名NPM和PYPI库（从Libraries.io API抓住）来查明。</p><p>  We tried to exclude build tools and test frameworks, as bugs in these are unlikely to have any security impact.When a vulnerable regex was found, we then needed to figure out how untrusted input could reach it.</p><p>  我们试图排除构建工具和测试框架，因为这些错误不太可能有任何安全影响。找到一个易受攻击的正则表达式时，我们需要弄清楚不受信任的输入如何达到它。</p><p>  The most problematic area was the use of regexes to parse programming or markup languages.Using regular expressions to parse some languages e.g.  Markdown,  CSS,  Matlab or  SVG is fraught with danger.Such languages have grammars which are designed to be processed by specialised lexers and parsers. Trying to perform the task with regexes leads to overly complicated patterns which are difficult for mere mortals to read.</p><p>  最有问题的区域是使用正则表达式来解析编程或标记语言。对于定期表达来解析一些语言。 Markdown，CSS，Matlab或SVG充满了危险。危险的语言具有语法，该语法被设计为由专门的Lexers和Parsers处理。尝试使用正则表达式执行任务导致过于复杂的模式，这是难以读取的凡人。</p><p> A recurring source of vulnerabilities was the handling of optional whitespace. As an example, let’s take the Python module  CairoSVG which used the following regex:</p><p> 重复漏洞源是可选空格的处理。例如，让我们带上使用以下Regex的Python模块CairSvg： </p><p>  $ regexploit-py .env/lib/python3.9/site-packages/cairosvg/Vulnerable regex in .env/lib/python3.9/site-packages/cairosvg/colors.py #190Pattern: rgba\([ \n\r\t]*(.+?)[ \n\r\t]*\)Context: RGBA = re.compile(r&#39;rgba\([ \n\r\t]*(.+?)[ \n\r\t]*\)&#39;)---Starriness: 3 ⭐⭐⭐ (cubic)Repeated character: [20,09,0a,0d]Example: &#39;rgba(&#39; + &#39; &#39; * 3456</p><p>$ regexploit-py .env / lib / python3.9 / site-packages / cairosvg / vvstnerable regnx在.env / lib / python3.9 / site-packages / cairosvg / colors.py＃190pattern：rgba \（[\ n \ r \ t] *（。+？）[\ n \ r \ t] * \）上下文：rgba = re.compile（r＆＃39; rgba \（[\ n \ r \ t] *（。+？） [\ n \ r \ t] * \）＆＃39;）--- Starriness：3⭐⭐⭐（立方）重复字符：[20,09,0a，0d]示例：＆＃39; rgba（＆＃ 39; +＆＃39;＆＃39; * 3456</p><p> The developer wants to find strings like  rgba(   100,200, 10, 0.5   ) and extract the middle part without surrounding spaces. Unfortunately, the  .+ in the middle  also accepts spaces.If the string does not end with a closing parenthesis, the regex will not match, and we can get  O(n 3) backtracking.</p><p> 开发人员想要找到像RGBA（100,200,10,0.5）的字符串，并在没有周围空间的情况下提取中间部分。不幸的是，。+中间也接受空间。如果字符串不以关闭括号结尾，则Regex将不匹配，我们可以获得O（n 3）回溯。</p><p> Let’s take a look at the matching process with the input  &#34;rgba(&#34; + &#34; &#34; * 19:</p><p> 让我们来看看输入＆＃34; rgba（＆＃34; +＆＃34;＆＃34; * 19：</p><p>  A fun ReDoS bug was discovered in  cpython’s http.cookiejar with this gorgeous regex:</p><p>  在CPython的Http.Cookiejar中发现了一个有趣的Redos错误，并使用这一华丽的Regex：</p><p> Pattern: ^ (\d\d?) # day (?:\s+|[-\/]) (\w+) # month (?:\s+|[-\/]) (\d+) # year (?: (?:\s+|:) # separator before clock (\d\d?):(\d\d) # hour:min (?::(\d\d))? # optional seconds )? # optional clock \s* ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone \s* (?:\(\w+\))? # ASCII representation of timezone in parens. \s*$Context: LOOSE_HTTP_DATE_RE = re.compile(---Starriness: 3 ⭐⭐⭐Repeated character: [SPACE]Final character to cause backtracking: [^SPACE]Example: &#39;0 a 0&#39; + &#39; &#39; * 3456 + &#39;0&#39;</p><p> 模式：^（\ d \ d？）＃day（？：\ s + | [ -  \ /]）（\ w +）＃月（？：\ s + | [ -  \ /]）（\ d +）＃年（？ ：（？：\ S + | :)＃时钟分隔符（\ d \ d？）:( \ d \ d）＃小时：min（？::（\ d \ d））？＃可选秒）？ ＃可选时钟\ s *（[ -  +]？\ d {2,4} |（？！[apap] [mm] \ b）[a-za-z] +）？ ＃timezone \ s *（？：\（\ w +））？ ＃ASCII表示Parens的时区。 stock_http_date_re = re.compile（ -   - ＆＃39;＆＃39; * 3456 +＆＃39; 0＆＃39;</p><p> It was used when processing cookie expiry dates like  Fri, 08 Jan 2021 23:20:00 GMT, but with compatibility for some deprecated date formats.The last 5 lines of the regex pattern contain three  \s* groups separated by  optional groups, so we have a cubic ReDoS.</p><p> 它是在Processing Cookie到达日期时使用的GMT，但GMT 23:20:00 23:20:00 23:20:00的兼容性，但兼容一些已弃用的日期格式。正则表达式模式的最后5行包含由可选组分隔的三个\ s *组我们有一个立方重做。</p><p> A victim simply making an HTTP request like  requests.get(&#39;http://evil.server&#39;) could be attacked by a remote server responding with  Set-Cookie headers of the form:</p><p> 仅仅是制作HTTP请求的受害者（＆＃39; http：//evil.server&#39;）等http请求可能是由窗体的set-cookie标题响应的远程服务器攻击： </p><p>  With the maximum 65506 spaces that can be crammed into an HTTP header line in Python, the client will take over a week to finish processing the header.</p><p>最大65506个空格可以填充到Python中的HTTP标头行中，客户端将需要一周时间才能完成处理标题。</p><p>  Another point to notice is that, based on the git history, the troublesome regexes we discovered had mostly remained untouched since they first entered the codebase.While it shows that the regexes seem to cause no issues in normal conditions, it perhaps indicates that regexes are too illegible to maintain.If the regex above had no comments to explain what it was supposed to match, who would dare try to alter it? Probably only the guy from xkcd.</p><p>  另一点注意到，基于Git历史，我们发现的麻烦正跳得大多仍然保持不变，因为他们首次进入CodeBase。虽然正常情况似乎在正常情况下没有问题，但它可能表明正常呈现太难以难以维护。如果上面的正则表达式没有评论来解释它应该匹配的内容，谁敢试图改变它？可能只有来自XKCD的人。</p><p>    So why didn’t I bother looking for ReDoS in Golang? Go’s regex engine  re2  does not backtrack.</p><p>    那么为什么我不打算在戈兰寻找重做？ Go的Regex引擎RE2不会回溯。</p><p> Its design ( Deterministic Finite Automaton) was chosen to be safe even if the regular expression itself is untrusted. The guarantee is that regex matching will occur in linear time regardless of input.There was a trade-off though.Depending on your use-case, libraries like re2 may not be the fastest engines.There are also some regex features such as backreferences which had to be dropped.But in the pathological case, regexes won’t be what takes down your website.There are re2 libraries for many languages, so you can use it in preference to Python’s  re module.</p><p> 它的设计（确定性有限自动机）选择即使正则表达本身也是不受信任的。保证是，无论Input.Thevers，虽然，Legex匹配会在线性时间发生。但是，虽然是一个折衷。虽然是一个折衷。像用例中，像re2这样的库可能不是最快的引擎。还有一些regex特征，如反向参考必须丢弃。在病理情况下，正则表达式不会成为您的网站所需的内容。对于许多语言来说是Re2库，因此您可以使用它以优先于Python的RE模块。</p><p>  For the whitespace ambiguity issue, it’s often possible to first use a simple regex and then trim / strip the spaces from either side of the result.</p><p>  对于空白模糊的问题，通常可以首先使用一个简单的正则表达式，然后从结果的两侧修剪/剥离空格。</p><p>   In Ruby, the standard library contains  StringScanner which helps with “lexical scanning operations”.While the  http-cookie gem has  many more lines of code than a mega-regex, it avoids REDoS when parsing  Set-Cookie headers. Once each part of the string has been matched, it refuses to backtrack.In some regular expression flavours, you can use “possessive quantifiers” to mark sections as non-backtrackable and achieve a similar effect.</p><p>   在Ruby中，标准库包含StringScanner，它有助于“词汇扫描操作”。虽然HTTP-cookie Gem具有比Mega-Regex更多的代码行，但它会在解析Set-cookie标头时避免重做。一旦匹配的每个部分都匹配，它拒绝回溯。在某些正则表达式味道中，您可以使用“占有量词”将部分标记为非回溯并实现类似的效果。</p><p>  CVE-2021-27291: pygments lexers for ADL, CADL, Ceylon, Evoque, Factor, Logos, Matlab, Octave, ODIN, Scilab &amp; Varnish VCL (Syntax highlighting)</p><p>  CVE-2021-27291：Pygments For Adl，Cadl，锡兰，Evoque，因子，徽标，Matlab，octave，Odin，Scilab＆amp;清漆VCL（语法突出显示） </p><p>            Plus many more unpublished bugs in a handful of pypi, npm, ruby and nuget packages. We will update this list on  https://github.com/doyensec/regexploit</p><p>加上少数几个Pypi，NPM，Ruby和Nuget套餐中的更多未发布错误。 我们将在https://github.com/doyensec/regexploit上更新此列表 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.doyensec.com/2021/03/11/regexploit.html">https://blog.doyensec.com/2021/03/11/regexploit.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/dos/">#dos</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/正则表达式/">#正则表达式</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>