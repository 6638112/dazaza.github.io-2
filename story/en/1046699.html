<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Nintil –关于软件工程的思考 Nintil – Thinking about software engineering</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nintil – Thinking about software engineering<br/>Nintil –关于软件工程的思考 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 22:35:01</div><div class="page_narrow text-break page_content"><p>Though I&#39;m right now not employed as a software engineer I have been writing code under various hats for the last few years (As a data scientist, ML engineer, and software engineer). Naturally me being me I have not just done the thing but also reflected about the thing. Questions like what&#39;s good software, what does being a good software engineer mean, how should meetings be ran, and so on. Here are some thoughts on that.</p><p>尽管我现在尚未受聘为软件工程师，但最近几年我一直在编写各种代码（作为数据科学家，ML工程师和软件工程师）。自然地，我就是我，我不仅做过这件事，还反思了这件事。这些问题包括什么是好的软件，什么是好的软件工程师，意味着如何召开会议等等。这是一些想法。</p><p>   In many cases a disagreement may be over something that both sides agree is not sizable. I can think something is 80% good whereas you think it&#39;s just 75% and I can think the opposite of your solution. But we can agree that the cost to resolve that disagreement can defeat the gains from actually choosing the best solution. So &#34;I disagree but let&#39;s go ahead&#34; is something that should be done in these cases, with a coin flip if needed. Consensus-driven decision making may be good at some stages, especially if paired with good processes around meetings but it can lead to gridlock.</p><p>   在许多情况下，双方可能都认为分歧不大。我可以认为某些东西是80％好的，而您认为它只是75％，我可以认为您的解决方案的反面。但是我们可以同意，解决分歧的成本可能会抵消实际选择最佳解决方案的收益。所以，我不同意，但让我们继续吧。在这种情况下应该做的事情，如果需要的话可以掷硬币。由共识驱动的决策在某些阶段可能会很好，尤其是如果与会议周围良好的流程配合使用，但可能导致僵局。</p><p> I&#39;m of course not the first one in proposing the &#34; disagree and commit&#34; principle though I only learned this had a name very recently.</p><p> 我当然不是提出建议的第一个人。不同意并承诺原则，尽管我最近才知道这个名字。</p><p>  Meetings can be terrible, meetings can be great. Bad meetings tend to occur because people show up without having thought much about what is to be discussed in the meeting. Isn&#39;t the point of the meeting to do the thinking? That&#39;s one way, perhaps the most common way of viewing meetings, and it&#39;s a lazy default because they don&#39;t impose homework on you. But doing the thinking in real time, with many voices to be sequentially heard and given a constrained time is not great for good decision making. Many times I&#39;ve seen meetings that dragged on forever where disagreements would keep circling back and forth, or where we would simply be talking past each other.</p><p>  会议可能会很糟糕，会议可能会很棒。人们之所以会召开不好的会议，是因为人们露面时没有考虑会议中要讨论的内容。会议的目的不是思考吗？这是查看会议的一种方式，也许是最常见的方式，而且这是一种懒惰的默认方式，因为它们不会向您施加家庭作业。但是，要进行良好的决策，实时地进行思考，要有许多声音要被顺序地听到，并且时间有限。我多次看到会议永远拖延着分歧不断出现的地方，或者我们只是互相交谈而已。</p><p> A better way to run meetings, which I also tried, is to collate whatever is it that the outcome should be before the meeting. If it&#39;s an architecture design meeting, do the work, usually the meeting owner can do most of it, even if they know it won&#39;t be 100% perfect. Then ask for feedback a week ahead of the meeting. Incorporate the feedback to the document, repeat. Note down disagreements; have a literal &#34;Standing disagreements&#34; section in the document with the key points that are not quite agreed on, plus the reasoning behind them. Having everyone review the disagreements and having time to do so, on (digital) paper sets up a clearer goal for the meeting: Iron out specific points. During the meeting, a moderator would go one by one over those points and ask for a decision, then highlighting in bold which option was chosen. Then we would move to the next point and so on. Everyone liked this kind of meeting.</p><p> 我也尝试过一种更好的召开会议的方法，就是整理会议之前结果应该是什么。如果是架构设计会议，请进行工作，通常会议所有者可以完成大部分工作，即使他们知道这样做并非100％完美。然后在会议开始前一周征求反馈。将反馈合并到文档中，重复一次。记下分歧；有字面上的＆＃34;常设分歧＆＃34;文档中的“关键”部分，以及尚未达成共识的关键点，以及其背后的理由。让所有人复习分歧并有时间这样做，在（数字）纸上为会议设定了一个更清晰的目标：消除特定的问题。在会议期间，主持人将逐一讨论这些问题并要求作出决定，然后以粗体突出显示选择了哪个选项。然后，我们将移至下一点，依此类推。每个人都喜欢这种会议。</p><p>  Lack of ownership is the root of all evil (ok, some exaggeration here). Everyone&#39;s problem is no one&#39;s problem. In documentation, lack of ownership means finding obsolete documentation and no one person to go to to get it fixed; or what&#39;s worse, no system in place to enforce that the documentation is up to date (i.e. every document could disappear 6 months after it&#39;s published unless whoever uploaded or created it says otherwise in an email the system sends them after six months, documents shouldn&#39;t live rent free). Or having a team dedicated to tirelessly aggregating information so that everything everyone is doing is visible. We had something like this in my first job at the London Electric Vehicle Company (LEVC) and I suspect this may be more common in automotive or aerospace than in software or in biotech.</p><p>  缺乏所有权是万恶之源（好吧，这里有些夸张）。每个人的问题都不是问题。在文档中，缺乏所有权意味着找到过时的文档，没有人去修复它。或更糟糕的是，没有适当的系统来强制要求文档是最新的（即，每个文档都可能在文档发布后的6个月内消失，除非上传或创建文档的人在系统发送的电子邮件中另有说明）六个月后，文件便不能免费交房租）。或者拥有一支致力于不懈地汇总信息的团队，以便每个人都可以看到所有内容。在伦敦电动车公司（LEVC）的第一份工作中，我们遇到过类似的事情，我怀疑这在汽车或航空航天中可能比在软件或生物技术中更常见。</p><p> Apple had a very clever idea in defining  Directly Responsible Individuals (DRIs) for everything. Having a name accountable instead of a vague &#34;the team&#34; or &#34;the process&#34; makes it easy to make changes. I think many people are reluctant to blame individuals for mistakes they make, but well timed blame (feedback about what mistakes were made, potentially there being consequences for grave mistakes etc) can both help the blamed individual (They can know what to improve) and the team as a whole to succeed.</p><p> 苹果公司有一个非常聪明的想法，那就是为所有事情定义直接负责的个人（DRI）。用负责任的名字代替模糊的团队或＆＃34;流程＆＃34;使更改变得容易。我认为许多人都不愿意将自己犯的错误归咎于个人，但是适时的责备（反馈有关犯下的错误，可能会导致严重错误等）既可以帮助被指责的个人（他们可以知道如何改进），又可以整个团队取得成功。 </p><p> Something I once thought is that many decisions that involve estimates could be made into bets, either for small amounts of money or some kind of token. If you say X will be finished in a week and it takes longer, then you lose. This could be gamed by overestimating how long things take, but something like this seems like the right way to get better at making decisions involving uncertainty.</p><p>我曾经想过的一件事是，许多涉及估计的决策都可以押注，无论是少量资金还是某种代币。如果您说X将在一周内完成，并且需要更长的时间，那么您将输掉。这可以通过高估事情花费多长时间来解决，但类似的事情似乎是正确地做出更好的决策的正确方法。</p><p>  Every question asked in an internal Slack is a policy failure. It means the existing information systems failed to deliver an answer, and the user falls back to manually asking the hive mind&#39;s tacit knowledge. This has various problems: One, it introduces longer delays between question and answer, especially if whoever knows the answer is in another timezone. Two, it embraces tacit knowledge in a distributed and incoherent fashion: If there is no one true answer there can be many answers and that can lead to disagreements and wrong decisions. Instead, ideally there is a centralized repository of information where for each Q there is one and only one A, and a team dedicated to getting owners of various systems to actually codify their knowledge. This should work well with the ownership system above.</p><p>  内部Slack中提出的每个问题都是策略失败。这意味着现有的信息系统无法提供答案，并且用户退回到手动询问蜂巢思维的默认知识。这有很多问题：第一，问题和答案之间的延迟更长，特别是如果知道答案的人在另一个时区。第二，它以分布和不连贯的方式包含隐性知识：如果没有一个正确的答案，那么就会有很多答案，这可能导致分歧和错误的决定。取而代之的是，理想情况下是一个集中的信息存储库，其中每个Q都有一个且只有一个A，并且有一个专门致力于使各种系统的所有者真正地整理其知识的团队。这应该与上面的所有权系统配合良好。</p><p>   Good software is code that is readable, fast, flexible, and scalable. Out of these only speed is the one that is universally agreed on how to measure. The rest are fuzzy, as are most things in life.</p><p>   好的软件是可读，快速，灵活和可扩展的代码。在这些唯一的速度中，有一个关于如何测量的普遍同意的速度。其余的都是模糊的，就像生活中的大多数事物一样。</p><p> Readable code pretty much depends on who is writing it;  Dyalog looks like  Brainfuck to me, and the many parenthesis in Lisps can make code hard to read to someone who is not a lisper (I did the experiment; I spent some time learning basic Clojure and while I remain not a Clojurian, the parenthesis become less of an issue). Lifetimes in Rust seem obscure until one know how they work.</p><p> 可读代码在很大程度上取决于编写者。 Dyalog在我看来就像Brainfuck，并且Lisps中的许多括号会使非lisper的人难以阅读代码（我做了实验；我花了一些时间学习基本的Clojure，而当我仍然不是Clojurian时，括号变成了更少的问题）。直到人们知道它们是如何工作的，Rust的生命才显得晦涩难懂。</p><p> Flexible code is code that is easier to extend. This is hard to quantify but anyone that has coded knows it when they see it; a given piece of code can just effortlessly do something new with a two line change, or it may need a thousand line change to work again. The former is more flexible than the latter. Moreover this flexibility shouldn&#39;t come at the expense of readability though sometimes this can be the case.</p><p> 灵活的代码是更易于扩展的代码。这很难量化，但是任何编码的人在看到它时都知道。给定的一段代码只需两行更改即可轻松完成一些新工作，或者可能需要一千行更改才能再次工作。前者比后者更灵活。而且，这种灵活性不应该以可读性为代价，尽管有时候是这种情况。</p><p> Scalable code is code that works well with small as well as big inputs, this can be achieved in a single machine or many.</p><p> 可伸缩代码是无论输入大小都适用的代码，可以在一台或多台机器上实现。</p><p> The extent to which these matter depend on who is developing it (Readable code depends on individual preferences), and flexibility is not really needed if the end result is more or less fixed; but it&#39;s really desired in a startup that is constantly adapting. In that environment, speed may be sacrificed for extra flexibility.</p><p> 这些问题的程度取决于开发人员（可读代码取决于个人喜好），如果最终结果或多或少是固定的，则实际上并不需要灵活性。但是在不断适应的初创公司中确实很需要。在那种环境下，为了牺牲额外的灵活性可能会牺牲速度。 </p><p> The code that should be written absent any constraints is good code, but real life situations means that the right thing to do is to make tradeoffs and move ahead. Those decisions are at the heart of what experience in software engineering is.</p><p>在没有任何约束的情况下应该编写的代码是好的代码，但是现实生活中的情况意味着正确的做法是权衡取舍并向前发展。这些决定是软件工程经验的核心。</p><p>  Static typing is great. Early on in a codebase in Python back at Aiden.ai, we made the decision of going for static typing using myopia as much as we could. So instead of writing something like</p><p>  静态类型很棒。早在Aiden.ai的Python代码库中，我们就决定尽可能多地使用近视进行静态类型化。所以不要写像</p><p>    Or even further, in some cases we would use  newtypes to make these type annotations more meaningful, dataclasses to bundle data together, as well as exhaustive enumerations to ensure that all variants of an enum get handled, for example:</p><p>    甚至更进一步，在某些情况下，我们将使用新类型来使这些类型注释更有意义，使用数据类将数据捆绑在一起，并使用详尽的枚举来确保处理枚举的所有变体，例如：</p><p> class  Operation ( Enum ):  Multiply=&#34; Multiply &#34; Add=&#34; Add &#34;Value = Union[int,float] def  assert_never ( x : NoReturn) -&gt; NoReturn:  raise  AssertionError ( f &#34; Invalid value:  {x !r }&#34;) def  do_the_op ( a :Value, b : Value,  op :Operation) -&gt; Value:  if  op is Operation.Multiply:  return  a*b  else if  op is Operation.Add:  return  a+b  else :  assert_never (op)</p><p> class Operation（Enum）：Multiply =＆＃34;相乘＆＃34;添加=＆＃34;添加＆＃34; Value = Union [int，float] def assert_never（x：NoReturn）-＆gt; NoReturn：引发AssertionError（f＆＃34;无效值：{x！r}＆＃34;）def do_the_op（a：Value，b：Value，op：Operation）-＆gt;值：如果op是Operation.Multiply：返回a * b否则如果op是Operation.Add：返回a + b else：assert_never（op）</p><p> So if we ever say remove an operation or add a new one, mypy will force us to handle it. This is enforced dynamically but most importantly also statically so the code won&#39;t pass tests if there is a missing variant.</p><p> 因此，如果我们说删除一个操作或添加一个新操作，则mypy将迫使我们进行处理。这是动态执行的，但最重要的是也是静态执行的，因此，如果缺少变体，代码将无法通过测试。</p><p> All these typing (Plus a custom pandas typechecker I wrote, but that&#39;s another story) made it relatively easy to refactor, and add new features when we needed to do so. It would have been a huge pain to fly blind without the types. Python has a tendency to blow up in your face when you least expect it. Starting with types from day 1 is something I don&#39;t regret having gone for, it didn&#39;t make the coding any slower and saved a lot of time (Or so we imagine!).</p><p> 所有这些键入（加上我编写的自定义熊猫typechecker，但这是另一个故事）使重构相对容易，并在需要时添加了新功能。没有类型的盲目飞行将是巨大的痛苦。当您最不期望Python时，Python会把它炸开。从第一天的类型开始，我就不会后悔，它并没有使编码变慢并且节省了大量时间（或者我们可以想象！）。</p><p> There seems to be a trend now towards types everywhere. Javascript died (for any serious developer) to let Typescript rise and Ruby, while still around with the Sorbet type checker, got Crystal.</p><p> 现在似乎到处都有类型的趋势。 Javascript死了（对任何认真的开发人员而言），让Typescript崛起，而Ruby仍在Sorbet类型检查器中，获得了Crystal。 </p><p> As a  wise man once said,  Python and its consequences have been a disaster for the human race. Python has a tendency to blow up in your face, even with all the typing. The typechecker may be happy but it doesn&#39;t guarantee that if it thinks something is type T it&#39;s actually so, maybe what you thought was a number is actually a string and because of duck typing it can take a few function calls for the error to manifest itself.</p><p>就像一个聪明人曾经说过的那样，Python及其后果对人类来说是一场灾难。即使进行所有键入操作，Python也会使您的脸部膨胀。类型检查器可能很高兴，但是并不能保证如果它认为某事是类型T，那么实际上，也许您认为是数字的实际上是一个字符串，并且由于鸭子输入而需要花费一些时间。函数要求该错误显示出来。</p><p>  I believe there is a tradeoff between writing a lot of code and writing correct code. In a day you could write X lines of code or you could write X/2. Two days of programmer B will produce the same as one day of programmer A but probably the latter will have introduced fewer bugs. You can write more or less tests, you can be more or less sure that something you just wrote is actually correct.</p><p>  我相信在编写大量代码和编写正确的代码之间要进行权衡。一天之内，您可以编写X行代码，也可以编写X / 2。程序员B的两天时间将与程序员A的一日时间相同，但后者可能会引入较少的错误。您可以编写或多或少的测试，或多或少可以确保刚编写的内容是正确的。</p><p> As you can expect from the number of typos here, I&#39;m more of a YOLO programmer than a chill programmer. I&#39;m the guy that was once pushing to prod from a one-handed GitHub hot fix from my phone as I was having dinner in a hotel in Tokyo (That one did work!).</p><p> 您可以从这里的错别字数中看出，我是一个YOLO程序员，而不是一个冷酷的程序员。我是曾经在东京的一家饭店吃晚饭的时候曾经用我的手机从一个GitHub修补程序生产产品的人（那个人确实工作了！）。</p><p> YOLO programming when the programming language doesn&#39;t have your back is more problematic and conversely it greatly benefits from strongly typed languages (Like Rust; probably of functional programming as well). While the &#34;if it compiles it works&#34; idea is not quote true, it is more true than &#34;if it typechecks it works&#34; in Python. In the Python case the code may seem &#34;good enough&#34; to you as well as the (insufficient) tests and the (imperfect) type checker, and all it takes for bugs to slip through is that code review is not perfect. In the Rust case no amount of &#34;It seems right to me&#34; will make  rustc happy. Many errors (Logic errors) can be hard to avoid, but in innumerable times I&#39;ve seen bugs getting through that would have been caught by proper types.</p><p> YOLO编程在编程语言无法胜任时会遇到更多问题，相反，它会从强类型语言（如Rust；也可能是函数式编程）中受益匪浅。如果＆＃34;可以编译，则可以正常工作＆＃34;这个主意不是引用正确的，它比＆＃34;如果进行类型检查是否正确＆＃34;更正确。在Python中。在Python的情况下，代码似乎足够好了。以及（不足的）测试和（不完美的）类型检查器对您的影响，所有让错误流过的缺陷是代码审查并不完美。在Rust案中，对我来说似乎没什么问题。将使rustc开心。许多错误（逻辑错误）是很难避免的，但是在无数次的时间内，我已经看到可以通过适当类型捕获通过这些错误的错误。</p><p> More code is buggier code (on average) and so another way to do safer YOLO programming is designing the code so that fewer lines of code need to be added over time. How to do this? If you can pull it off, DSLs and  compilers for them. A DSL is (if done well) a concise, readable, modular way of describing business logic for the domain of interest, and making as much invalid possibilities unrepresentable. Back at Aiden.ai instead of writing lots of data pipelines, I ended up writing a general data transformation system that would fetch configuration at runtime and transform data arbitrarily. That way we could plug new data sources into a common framework with relatively little work.</p><p> 更多的代码是错误的代码（平均而言），因此进行更安全的YOLO编程的另一种方法是设计代码，以便随着时间的推移，只需添加更少的代码行。这个怎么做？如果可以实现，则为它们提供DSL和编译器。 DSL是（如果做得很好的话）一种简洁，可读，模块化的方式，用于描述关注领域的业务逻辑，并使尽可能多的无效可能性无法表示。回到Aiden.ai，而不是编写大量数据管道，我最终编写了一个通用的数据转换系统，该系统将在运行时获取配置并任意转换数据。这样，我们就可以以相对较少的工作将新的数据源插入到通用框架中。</p><p>  How long is a long function? A program could be a single, very long function. Or it could be lots of tiny functions that each do one absurdly simple thing. What&#39;s the best? Should you inline heavily? Should you follow the &#34;Single Responsibility Principle&#34; to its ultimate consequences. I personally like longer functions that can be read top-down; even if a pattern repeats itself within a function, rather than defining a new function outside the main function I would rather either use closures or write this new function inside the original function. The fewer functions you can grab the better, it makes it easier to find what you are looking for. Having lots of smaller functions makes it more difficult, at least to me, to track what the larger body of code is doing, and when deleting old code, it&#39;s hard to miss these auxiliary functions. Absent tooling to detect dead ode that is not being called, they can linger there and be maintained over time even though they serve no purpose anymore. Shorter functions can also hide what the code is really doing. What if the innocent  getPersonFromId is doing a database call? Are you going to map over and spam the database with calls? Or... write a new function that does a single call? With fewer layers of abstraction this is easier to see.</p><p>  长函数有多长时间？一个程序可以是一个很长的函数。也可能是许多微小的功能，每个功能都做一件非常简单的事情。最好的是什么？您是否应该大量内联？您是否应该遵循“单一责任原则”其最终结果。我个人喜欢可以自上而下阅读的更长的功能；即使模式在函数中重复出现，而不是在主函数之外定义一个新函数，我还是愿意使用闭包或将此新函数写在原始函数中。您可以抓住的功能越少越好，这使得查找所需内容变得更加容易。至少对我来说，拥有许多较小的功能使跟踪更大的代码主体正在做的事情变得更加困难，并且在删除旧代码时，很难错过这些辅助功能。缺少检测未被调用的死语的工具，即使它们不再有用，它们也可以在那儿徘徊并得到维护。较短的函数也可以隐藏代码的实际作用。如果无辜的getPersonFromId正在执行数据库调用怎么办？您要映射到数据库并向其发送垃圾邮件吗？还是...写一个可以调用一个新函数？使用较少的抽象层，就更容易看到。</p><p> But short function defenders will argue that they make the code more readable. I can see how that could be in some cases, and that made me realize that it probably has to do with cognitive differences and values at various levels. How much working memory do you have, or preference for concreteness vs abstraction, or how much do you trust the code you are reading? Ultimately the answer is that the right function length is a function of the team working on a given codebase.</p><p> 但是功能短小的捍卫者会争辩说，他们使代码更具可读性。我看到在某些情况下可能会怎样，这使我意识到这可能与认知差异和各个层面的价值观有关。您有多少工作内存，或者偏爱具体性还是抽象性，或者您信任正在阅读的代码有多少？最终，答案是正确的函数长度是团队在给定代码库上的功能。 </p><p>  Premature optimization is said to be the root of all evil. But late optimization can also be harmful. Imagine you get to a point where everything just feels slow. You profile the causes and turns out it&#39;s everywhere: The database is not properly indexed, the queries are not optimized, queries are made repeatedly, or slow algorithms or functions were written. It can be tempting at that stage to just throw clouds at the problem and replicate the database and spin up 4 more servers. Now you have to pay for all that and deal with database synchronization. I think there is a reasonable middle ground of designing with future performance needs in mind, instead of making it a complete afterthought.</p><p>据说过早的优化是万恶之源。但是，后期优化也可能有害。想象一下，您到了感觉一切缓慢的地步。您找出原因并找出原因：数据库未正确索引，查询未优化，查询反复执行或编写了较慢的算法或函数。在那个阶段可能很诱人，只是在问题上扔下云，然后复制数据库并启动另外4台服务器。现在，您必须支付所有费用并处理数据库同步。我认为在设计时要考虑到未来的性能需求，这是一个合理的中间立场，而不是将其作为一个完整的事后思考方法。</p><p>  I&#39;ve read many books about software. A  philosophy of software design,  clean code and so on. I&#39;ve also watched lots of talks about software. For some reason I ended up appreciating the points of view of game developers ( Jonathan  Blow,  Casey Muratori, John  Carmack) a lot. I guess part of it is their &#34;It depends&#34; approach to many of these problems. One can recognize the advantages of functional programming or of having classes here and there, or of writing unit tests without making everything into a pure function, going full OOP, or spending days testing code that could do with a shorter test suite. If you take say  SOLID which sounds kind of reasonable, the Single Responsibility Principle in an OCD way can only be met by  unary functions. Everything else must be doing more than &#34;one thing&#34;. Things that seem like hard rules in programming run afoul of the  nebulosity of the art of programming.</p><p>  我已经读了许多有关软件的书。软件设计，简洁代码等的哲学。我还观看了许多有关软件的讨论。由于某种原因，我最终非常欣赏游戏开发人员（乔纳森·布洛，凯西·穆拉托里，约翰·卡马克）的观点。我想其中一部分是因为他们的情况而定解决其中许多问题的方法。可以认识到函数式编程的优点，或者在这里或那里拥有类，或者编写单元测试而不将所有内容都变成纯函数，进行完整的OOP或花费数天的时间来测试可以用较短的测试套件完成的代码的优点。如果您说听起来很合理的SOLID，则OCD方式的“单一责任原则”只能由一元函数满足。其他所有事情都要做的不只是一件事。在编程中看似硬性规定的事情与编程艺术的模糊性不符。</p><p> What do we really know about programming? Well, evidence-based software engineering is a thing. There are  books about it. There are  talks about it. But it&#39;s not a huge thing. Software engineering is like education in that is a huge part of modern society yet there is little resources devoted to making it better, unlike for the life sciences say. Twitter was originally written in Ruby and then there was a transition away into Scala. Many people these days use Kubernetes-backed micro service architectures rather than monoliths. Is that a good thing? Who knows. My guess is that probably monoliths are underrated.</p><p> 我们对编程真正了解什么？好吧，基于证据的软件工程就是一回事。有关于它的书。有谈论它。但这不是一件大事。软件工程就像教育一样，它是现代社会的重要组成部分，但是很少有资源致力于使其变得更好，这与生命科学说的不同。 Twitter最初是用Ruby编写的，然后过渡到Scala。如今，许多人使用的是Kubernetes支持的微服务架构，而不是整体架构。那是件好事儿吗？谁知道。我的猜测是，巨石可能被低估了。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nintil.com/programming">https://nintil.com/programming</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件工程/">#软件工程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/thinking/">#thinking</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>