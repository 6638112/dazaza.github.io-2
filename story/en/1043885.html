<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>禁止提供Konrad Zuse（2014） Blocks Courtesy of Konrad Zuse (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Blocks Courtesy of Konrad Zuse (2014)<br/>禁止提供Konrad Zuse（2014） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-10 20:33:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/19bec52c512ddf34d1a4d5081e737c77.png"><img src="http://img2.diglog.com/img/2021/1/19bec52c512ddf34d1a4d5081e737c77.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Konrad Zuse was an early pioneer in computer science, although his name is perhaps somewhat less well-known than others. Zuse holds the honor of having built the first programmable computer—-the Z3—-back in the 40&#39;s, as well as several other computing firsts  1. Of particular interest to this blog post is his early unimplemented programming language, Plankalkül.</p><p>康拉德·祖斯（Konrad Zuse）是计算机科学的早期开拓者，尽管他的名字也许不如其他人那么知名。祖斯（Zuse）拥有在40年代制造出第一台可编程计算机Z3以及其他几项计算第一的荣誉。这篇博客文章特别令人感兴趣的是他早期未实现的编程语言Plankalkül 。</p><p> Plankalkül was, like the Z3, in many respects ahead of its time. Zuse&#39;s explicit goal was to be able to describe programs at a high level, which meant he included control structures and datatype definitions  2 and other high-level constructs that were often missing in languages of the early years of computing. Zuse was working on Plankalkül at a time when his machines were not useable, which meant that his language work was more theoretical than it was technical, and consequently he allowed features that he wasn&#39;t entirely sure how to program. Despite his notes on it having been written in the mid-40&#39;s, they were not published until the 70&#39;s, and it was not implemented until the year 2000.</p><p> 像Z3一样，普兰卡库尔（Plankalkül）在许多方面都比它的时代提前。 Zuse的明确目标是能够以较高的级别描述程序，这意味着他包括控制结构和数据类型定义2以及其他在早期计算语言中经常缺少的高级构造。 Zuse在无法使用机器的时候就在Plankalkül上工作，这意味着他的语言工作更具理论性，而不是技术性，因此他允许自己不确定自己如何编程的功能。尽管他的注释已经写在40年代中期，但直到70年代才出版，直到2000年才实施。</p><p> One thing that struck me, as I read programs in this notation that had been set down on a typewriter  3, is that certain kinds of grouping were handled by explicit indication of scope: not via matched delimiters as in ALGOL-style languages, or via indentation in languages such as Python and Haskell, but by formatting the code so that a line bordered on the left of the scoped parts of the code:</p><p> 当我阅读在打字机3上设置的这种符号的程序时，令我印象深刻的是，某些类型的分组是通过范围的显式指示来处理的：不是像ALGOL风格的语言那样通过匹配的定界符，也不是通过用诸如Python和Haskell之类的语言缩进，但是通过格式化代码，使在代码范围部分的左侧有一条边界：</p><p>  This is meant to capture the way grouping works in the hand-written or typeset notation, with brackets spanning multiple lines:</p><p>  这是为了捕获以手写或排字法表示的分组方式，并用方括号括起来：</p><p>  I think this is notationally interesting: it&#39;s like Python&#39;s significant whitespace, but not, uh, whitespace. It would be incredibly tedious to type out, but still entirely compatible with current programming notation:</p><p>  我认为这在概念上很有趣：它就像Python的重要空白，但不是，空白。输入将非常繁琐，但仍与当前的编程符号完全兼容：</p><p> class Tet | @staticmethod | def new_tet() | | n = randint(0, len(Tet.Tets) - 1) | | for p in Tet.Tets[n] | | | if p in Board.permanent | | | | Game.lose() | | Game.current = Tet(Tet.Tets[n], Tet.TetColors[n]) | | def __init__(self, points, color) | | self.points = points | | self.color = color</p><p> 春节| @staticmethod | def new_tet（）| | n = randint（0，len（Tet.Tets）-1）| |用于Tet.Tets中的p [n] | | |如果Board.permanent中的p | | | | Game.lose（）| | Game.current = Tet（Tet.Tets [n]，Tet.TetColors [n]）| | def __init __（自身，点，颜色）| | self.points =点| | self.color =颜色</p><p>  class Tet ┃ @staticmethod ┃ def new_tet() ┃ ┃ n = randint(0, len(Tet.Tets) - 1) ┃ ┃ for p in Tet.Tets[n] ┃ ┃ ┃ if p in Board.permanent ┃ ┃ ┗ ┗ Game.lose() ┃ ┗ Game.current = Tet(Tet.Tets[n], Tet.TetColors[n]) ┃ ┃ def __init__(self, points, color) ┃ ┃ self.points = points ┃ ┗ self.color = color</p><p>  class Tet┃@staticmethod┃def new_tet（）┃n = randint（0，len（Tet.Tets）-1）T在Tet中用于p.Tets [n]┃如果在board.permanent中保留p ┗Game.lose（）┗Game.current = Tet（Tet.Tets [n]，Tet.TetColors [n]）┃def __init __（self，points，color）┃self.points =点┗self。颜色=颜色 </p><p> Looking at this notation, however, an interesting possibility struck me: a programmer could explicit annotate information about the  kind of scope involved in a given line. In this Python-like example, I could, for example, distinguish class scope using double lines, function scope with thick lines, and control structure scope with thin lines:</p><p>然而，看一下这种表示法，我想到了一个有趣的可能性：程序员可以显式地注释有关给定行中涉及的范围类型的信息。在这个类似于Python的示例中，例如，我可以区分使用双行的类作用域，使用粗线的函数作用域和使用细线的控件结构作用域：</p><p> class Tet ║ @staticmethod ║ def new_tet() ║ ┃ n = randint(0, len(Tet.Tets) - 1) ║ ┃ for p in Tet.Tets[n] ║ ┃ │ if p in Board.permanent ║ ┃ └ └ Game.lose() ║ ┗ Game.current = Tet(Tet.Tets[n], Tet.TetColors[n]) ║ ║ def __init__(self, points, color) ║ ┃ self.points = points ║ ┗ self.color = color</p><p> 类Tet║@staticmethod║def new_tet（）┃n = randint（0，len（Tet.Tets）-1）T在Tet.Tets中用作p [T] [n]┃│如果p在Board.permanent中║ └Game.lose（）┗Game.current = Tet（Tet.Tets [n]，Tet.TetColors [n]）║def __init __（self，points，color）┃self.points =点┗self。颜色=颜色</p><p> One advantage of this scheme is that a handful of lines, viewed in isolation, still give you a clear view of what surrounds them. For example, I can view these two lines in isolation and still tell that they are within a control structure used within a function declared within a class:</p><p> 此方案的一个优点是，孤立地查看了几行，仍然可以清晰地看到周围的内容。例如，我可以单独查看这两行，但仍然可以看出它们在类中声明的函数中使用的控制结构内：</p><p>  You could also imagine a hypothetical language in which choice of scope delimiter is important. In Python,  for and  if do not form a new lexical scope. What if instead we could stipulate the kind of scope they form by this notational convention?</p><p>  您还可以想象一种假设语言，其中选择范围定界符很重要。在Python中，for和if不会形成新的词汇范围。相反，如果我们可以规定这种符号约定所形成的范围的类型呢？</p><p> def okay() ┃ if True ┃ └ n = 5 # n is declared in function scope ┗ return n # n leaks out of the if-scopedef not_okay() ┃ if True ┃ ┗ n = 5 # n is declared in the if&#39;s scope ┗ return n # error: no n in scope here</p><p> def okay（）┃如果在函数作用域中声明了True┗n = 5＃n，则返回n＃n从if-scopedef not_okay（）中泄漏出来，如果True┃n = 5＃n在if＆＃中声明了39; s范围┗return n＃错误：此处范围内无n</p><p> That being said, there are a number of reasons that this notation is in inferior to existing notations:</p><p> 话虽这么说，但有很多原因使这种表示形式不如现有的表示形式：</p><p> It requires that the programmer  pay attention to the sequence of enclosing scopes on a  line-by-line basis, which is generally too pedantic and not particularly useful for a programmer.</p><p> 它要求程序员逐行注意包围范围的顺序，这通常过于繁琐，对程序员而言并不是特别有用。 </p><p> The ability to select “which kind of scope” is by no means only expressible by this notation, as other syntactic features such as keywords and delimiters could express the same thing.</p><p>选择“哪种范围”的能力绝不能用这种表示法来表达，因为其他语法功能（例如关键字和定界符）可以表达相同的内容。</p><p> There are only so many line-like characters which can serve as a scope marker, so this scheme is not very extensible.</p><p> 可以用作作用域标记的线状字符太多，因此该方案不是很可扩展。</p><p> It complicates parsing (especially by introducing an entirely new class of parse errors in which adjacent lines feature incompatible sequences of delimiting lines), and so it also...</p><p> 它使解析变得复杂（特别是通过引入一类全新的解析错误，其中相邻的行具有不兼容的定界线序列），因此...</p><p> Complicates parse  error messages, which are an important part of a language&#39;s UI and should be considered seriously.</p><p> 复杂的解析错误消息，这是语言UI的重要组成部分，应认真考虑。</p><p> So, as in my previous post on  grammatical case in programming languages, I urge readers  not to use this notation as the concrete syntax for a programming language. This is merely an entertaining peek through the looking glass at a curious notational convention which was never adopted.</p><p> 因此，就像我之前关于编程语言中的语法案例的文章一样，我敦促读者不要将这种表示法用作编程语言的具体语法。这仅仅是在好奇的符号约定上通过窥镜进行的娱乐性偷看，从未被采用。</p><p> That said: this makes a very nice notation for  viewing code, where the programmer does not have to explicitly draw ASCII art around their code; indeed, it bears more than a passing similarity to the graphical interface used in  Scratch, and Sean McDirmid&#39;s  Experiments in Code Typography features this very convention as an interactive ornament on code in a Python-like language.</p><p> 就是说：这对于查看代码是一个很好的表示法，程序员不必在代码周围显式绘制ASCII文字。的确，它与Scratch中使用的图形界面相比具有更多的相似之处，Sean McDirmid的“代码排版实验”将这种约定作为一种类似Python的语言在代码上的交互式装饰。</p><p> He even wrote A New Kind Of Science half a century before Stephen Wolfram published it. In spirit, anyway—-if you strip away Wolfram&#39;s self-aggrandizement and the pretty pictures, much that remains of the book resembles Zuse&#39;s 1969 book  Rechnender Raum.</p><p> 他甚至在斯蒂芬·沃尔夫拉姆（Stephen Wolfram）发表半个世纪之前就撰写了《一种新型科学》。无论如何，从精神上讲，如果把沃尔夫拉姆的自我强化和漂亮的图画都去掉，那本书的其余部分就很像祖斯在1969年出版的著作《 Rehnhender Raum》。 </p><p> Datatype definitions wouldn&#39;t be found in other programming languages until the late 50&#39;s. Zuse&#39;s treatment of them was quite sophisticated: Plankalkül had no notion of what we would now call sums, but did have products in the form of tuples. The primitive type was  S0, which represented a single bit and had the values  + and  -, so a two-bit value might be represented as  (S0,S0). Arrays were included of the form  m×t, which stood for  m repetitions of  t, and variable-length arrays were encoded as  □×t. Integers were included as a primitive, and floats were defined as  (3×S0,7×S0,22×S0), which stood for three sign bits (which could also indicate whether the number was real or imaginary or zero), a seven-bit exponent, and a twenty-two-bit significand.</p><p>直到50年代后期，才能在其他编程语言中找到数据类型定义。 Zuse对它们的处理非常复杂：Plankalkül对我们现在所说的总和没有任何概念，但是确实有元组形式的乘积。基本类型为S0，它代表一个位，并具有值+和-，因此两位值可能表示为（S0，S0）。包含格式为m×t的数组，表示t的m个重复，而可变长度数组则编码为□×t。包含整数作为原始数，浮点数定义为（3×S0,7×S0,22×S0），代表三个符号位（也可以指示数字是实数还是虚数或零），即七个位指数和22位有效数字。</p><p> The image given is from Knuth and Pardo&#39;s  The Early History of Programming Languages, which surveys early programming languages—-implemented and not implemented—-and gives the same basic program implemented in each one.</p><p> 给出的图像来自Knuth和Pardo的“程序设计语言的早期历史”，它调查了已实现和未实现的早期程序设计语言，并给出了在每个程序语言中都实现的相同基本程序。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://journal.infinitenegativeutility.com/blocks-courtesy-of-konrad-zuse">https://journal.infinitenegativeutility.com/blocks-courtesy-of-konrad-zuse</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/提供/">#提供</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/courtesy/">#courtesy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>