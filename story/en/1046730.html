<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>StrictMark：Markdown，重构 StrictMark: Markdown, Refactored</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">StrictMark: Markdown, Refactored<br/>StrictMark：Markdown，重构 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-30 01:59:16</div><div class="page_narrow text-break page_content"><p>Markdown is a wonderful lightweight markup: minimalistic,easy to read and write. Markdown is supported by GitHub,Bitbucket, Reddit, Diaspora, Stack Exchange, and many others.It is not without issues though. Markdown is precedent-based,so to say. It aimed to codify preexisting practices whichwere... diverse. For that reason, it is messy and inconsistentbetween implementations.</p><p>Markdown是一种出色的轻量级标记：简约，易于阅读和书写。 GitHub，Bitbucket，Reddit，Diaspora，Stack Exchange和许多其他语言都支持Markdown，但这并不是没有问题的。降价可以说是基于先例的。它的目的是整理各种……以前存在的做法。因此，实现之间是混乱且不一致的。</p><p> StrictMark is a rational  subset of Markdown that implementsall the features with the shortest  formal grammar possible.Hence, uniform syntax and no ambiguities. The idea is thatStrictMark can reuse all the existing Markdown support,without sharing the weight of the legacy syntax and itsincidental complexity.</p><p> StrictMark是Markdown的合理子集，它以可能的最短形式语法实现所有功能。因此，语法统一且无歧义。这个想法是，StrictMark可以重用所有现有的Markdown支持，而无需共享传统语法的权重及其偶然的复杂性。</p><p>   Markdown implementations are inconsistent. Vim highlights it oneway, VS Code does it differently, and the resulting HTML is yetanother thing. A textbook fix for inconsistent implementationsis having a  formal grammar. That might be either a proper eBNF grammar or just some regexes in simpler cases. Theremust be something formal and unambiguous. HTML has it, CSS hasit, every markup or programming language has it. But Markdown.Sadly, the syntax itself is so ambiguous that making a formalgrammar becomes a road of pain. For example, HTML (which ishardly lightweight) has a uniform syntax for its  &lt;/elements&gt;.With Markdown, every element has its own syntax and thosesyntaxes interact. Markdown formal grammar was attempted in thepast, but if you ask me, the result was underwhelming. The  PEGbased grammar is 700 lines long. For a  minimalisticmarkup, that is  a lot. So ironic.</p><p>   Markdown的实现是不一致的。 Vim会以一种方式突出显示它，而VS Code则以不同的方式进行突出显示，结果HTML则是另一回事。针对具有正式语法的不一致实现的教科书修复。在更简单的情况下，这可能是适当的eBNF语法，也可能只是一些正则表达式。必须有正式而明确的东西。 HTML拥有，CSS拥有，每种标记或编程语言都拥有。但Markdown令人遗憾的是，语法本身含糊不清，以至于形式化语法成为一条痛苦之路。例如，HTML（几乎是轻量级的）对于＆lt; / elements＆gt;具有统一的语法。使用Markdown，每个元素都有其自己的语法，并且那些语法相互影响。过去曾尝试过Markdown正式语法，但是如果你问我，结果是难以理解的。基于PEG的语法长700行。对于极简主义的标记，这很多。好讽刺。</p><p> CommonMark is a Markdown codification effort that producedthe most complete spec so far. Still, that spec isrule-and-exception based, no grammar. The text of the spec isfull of &#34;legalese&#34;:</p><p> CommonMark是Markdown的一项编纂工作，产生了迄今为止最完整的规范。尽管如此，该规范基于规则和例外，没有语法。规范的文本充满＆＃34; legalese＆＃34 ;：</p><p> «An indented code block cannot interrupt a paragraph, sothere must be a blank line between a paragraph and afollowing indented code block»</p><p> «缩进的代码块不能中断段落，因此段落与后面的缩进的代码块之间必须有空白行»</p><p> Here it describes the specifics of interrelations between twoparticular markup elements. But  N elements produce  N*Nrelations! Consider that ATX headings are always single-linewhile Setext headings can be multiline. Why? Because the specsays so. It is one big heap of rules and another one ofexceptions. That&#39;s why it advises a &#34;parsing strategy&#34; andnot a parser generator.</p><p> 在这里，它描述了两个特定标记元素之间的相互关系的细节。但是N个元素会产生N * Nrelations！考虑到ATX标题始终是单行，而Setext标题可以是多行。为什么？因为这种说法。这是一大堆规则，另一个例外。这就是为什么它建议一种解析策略的原因。而不是解析器生成器。</p><p> Whether the CommonMak spec has fixed all the corner cases andambiguities is unclear. Or maybe clear, as the spec is activelyrevised. So is the code. The CommonMark C parser is 10KLoC ofhand-written code. It has plenty of exceptions and tweaks.While writing  RON docs, I ran into issues immediately;had to use the HEAD version which has those issues fixed.</p><p> 尚不清楚CommonMak规范是否已解决所有极端情况和歧义。也许很明确，因为该规范正在积极修订中。代码也是如此。 CommonMark C解析器是10KLoC的手写代码。它有很多例外和调整。在编写RON文档时，我立即遇到了问题；必须使用HEAD版本，该版本已解决了这些问题。 </p><p> Overall, that seemingly theoretical grammar problem causesplenty of  accidental complexity. Markdown is messy and hardto reason about; it is not always clear how to interpret agiven construct. That combinatorial mess may not be a problemfor its current uses, of course. (Although, I highly doubtthat.) After all, the existing libcmark parser is fuzzed,thus reasonably reliable. Still, Markdown is a very shakybase if you want to build on top of it. To build somethingmore advanced than a README. Like, full WYSIWYG editing ordiff highlighting or other complex behavior.</p><p>总的来说，看似理论上的语法问题会导致大量的偶然复杂性。 Markdown混乱且难以推理；目前尚不清楚如何解释给定的结构。当然，对于当前的用途来说，组合混乱可能不是问题。 （尽管，我对此非常怀疑。）毕竟，现有的libcmark解析器是模糊的，因此相当可靠。不过，如果您想在Markdown的基础上进行构建，Markdown仍然是一个非常不稳定的基础。构建比自述文件更高级的内容。就像完整的所见即所得编辑或差异突出显示或其他复杂行为一样。</p><p>  StrictMark&#39;s objective is to make a Markdown  subset which is a proper markup language. To remove that incidental complexityby rationalizing the grammar and making it formal. Thisdocument  is StrictMark.</p><p>  StrictMark的目标是制作Markdown子集，这是一种适当的标记语言。通过合理化语法并将其形式化来消除偶然的复杂性。本文档为StrictMark。</p><p> One may ask, why do I want to make Markdown a proper language?After all, there is HTML which is proper enough. Yes, HTML is awidely supported standard, but it is hopelessly elephantine.Let&#39;s think, who can afford to develop/support a proper HTMLengine? That is roughly one-and-a-half companies in the world.Hence the interest in a minimalistic hypertext markup language.</p><p> 可能有人会问，为什么要让Markdown成为一种合适的语言？毕竟，有足够的HTML了。是的，HTML是一种广泛支持的标准，但是它毫无希望。我们认为，谁负担得起开发/支持适当的HTML引擎的能力？这大约是全世界的一家半公司，因此人们对简约的超文本标记语言很感兴趣。</p><p> The next question is obvious. If StrictMark is ever used atsome scale, would not it become elephantine, naturally?Consider Wikipedia/Mediawiki markup. Once neat and lean likeall such markups, it evolved into an elephantine  mess.What about table support, for example? Some people think it isnecessary, quite deservedly so.</p><p> 下一个问题很明显。如果StrictMark曾经被大规模使用，它自然不会变成大象吗？请考虑Wikipedia / Mediawiki标记。一旦像所有这样的标记一样整洁，精益，它就演变成一团糟。例如，表支持呢？有人认为这是必要的，这是当之无愧的。</p><p> I plan to prevent feature sprawl by enabling  transclusion.A document may reference other documents and objects throughhyperlinks. It can also  include other objects and documents,through hyperlinks. The good old  &lt;img&gt; tag is an example oftransclusion. That will not even extend the syntax: StrictMarkreuses the image syntax for the general case of transclusion.Once you need a table, you transclude a table! It is up to therenderer to deal with all those other data types. CSV is a muchbetter format for tables than HTML or Markdown.</p><p> 我计划通过启用包含来防止功能泛滥。文档可能会通过超链接引用其他文档和对象。它还可以通过超链接包含其他对象和文档。好老的＆lt; img＆gt;标签是包含的一个例子。这甚至都不会扩展语法：StrictMark在通常的包含情况下重新使用图像语法。一旦需要表，就将包含表！渲染器要处理所有其他数据类型。 CSV是一种比HTML或Markdown更好的表格格式。</p><p> StrictMark is a backwards compatible subset of CommonMark, forthe most part. Any existing CommonMark tooling will supportStrictMark reasonably well. A StrictMark parser may notunderstand arbitrary Markdown.</p><p> 在大多数情况下，StrictMark是CommonMark的向后兼容子集。任何现有的CommonMark工具都将很好地支持StrictMark。 StrictMark解析器可能无法理解任意Markdown。</p><p>  A formal grammar. StrictMark is a  regular language in itsstructural part (i.e. blocks). The inline markup syntax isbased on regex-defined  markers. That way, a decent parsercan be implemented in regexes only.</p><p>  正式语法。 StrictMark在其结构部分（即块）是一种常规语言。内联标记语法基于正则表达式定义的标记。这样，仅可以在正则表达式中实现体面的解析器。 </p><p> There is one way to do a thing, as uniform as possible.Hence: spaces, not tabs! Because spaces can replace tabs,not the other way around. ATX headings only. Formattingbrackets are  *one char* wide only. All block formatting isindented uniformly.</p><p>有一种方法可以做到尽可能统一，因此：空格，而不是制表符！因为空格可以代替制表符，所以不能反过来。仅适用于ATX标题。格式括号仅*个字符*宽。所有块格式均统一缩进。</p><p>  No spooky action-at-a-distance. Each line can be parsedseparately. All the structural markup is 4-char-wide, henceindents are uniform. This restriction makes the nestingstructure clear and unambiguous.</p><p>  没有诡异的距离动作。每行都可以单独解析。所有结构标记均为4个字符宽，因此凹痕是均匀的。这种限制使嵌套结构清晰明确。</p><p> Inline markup has very limited nesting; it is of secondaryimportance anyway. There is clear markup precedence; a code span wins over  strong,  strong wins over  emph.</p><p> 内联标记的嵌套非常有限；无论如何，它是次要的。有明确的标记优先级；代码跨度胜过强力，胜于强力。</p><p> HTML is not the only output format. It could be PDF, DOC,TeX, whatever. Hence, no HTML inserts. Use transclusionfor other formats.</p><p> HTML不是唯一的输出格式。可以是PDF，DOC，TeX等。因此，没有HTML插入。对其他格式使用包含。</p><p>   Markdown inline markup may seem like an easy part. Sadly, it isnot. Due to very irregular and ambiguous syntax, implementingit properly is difficult. For that reason, StrictMarkrationalizes the inline markup in the following ways:</p><p>   Markdown内联标记似乎很简单。可悲的是，事实并非如此。由于语法不规则且模棱两可，因此很难正确实施。因此，StrictMarkration通过以下方式对内联标记进行标准化：</p><p> All inline markup is seen as bracketing. Brackets arematched separately, using regular expressions; e.g. (?&lt;=\s)[*](?=\S) is the opening bracket for STRONG.Bracket pairs only become effective if they satisfy theprecedence rules.</p><p> 所有内联标记被视为括弧。括号使用正则表达式分别匹配；例如（？＆lt; = \ s）[*]（？= \ S）是STRONG的开头括号。括号对只有在满足优先级规则时才有效。</p><p>  An open bracket can be paired with any following closingbracket of that kind. A new open bracket will cancel anypreceding unmatched open bracket of its kind.</p><p>  开括号可以与以下任何该类型的闭括号配对。一个新的开括号将取消任何之前同类的不匹配的开括号。 </p><p>  Higher-precedence brackets may nest in lower-precedence, butnot the other way around (the lower one is cancelled). Incase of equal-precedence, the earlier range wins.</p><p>较高优先级的括号可能嵌套在较低优先级的括号中，但反之则不行（较低的括号被取消）。如果优先顺序相同，则以较早的范围为准。</p><p>   That may seem restrictive, but again: inline formatting has asupplementary role. It must pull its own weight or it must notbe there. The accurate bracket patterns are listed in thegrammar appendix.</p><p>   这似乎是限制性的，但又是：内联格式具有辅助作用。它必须自己拉重量，否则不能拉重量。准确的括号模式在语法附​​录中列出。</p><p>  The only form of links CommonMark supports is full referencelinks. The link label must be exactly one symbol long. Thisapproach:</p><p>  CommonMark支持的唯一链接形式是完整的参考链接。链接标签的长度必须恰好是一个符号。这种方法：</p><p>  Reference definitions can be placed anywhere. It is nice to putthem at the end of a section or in the end of the document.Example:</p><p>  参考定义可以放在任何地方。最好将它们放在节的末尾或文档末尾。例如：</p><p>  If you have more than 10 links, use letters. In case you have thousands of links, use Unicode symbols.</p><p>  如果您有10个以上的链接，请使用字母。如果您有成千上万的链接，请使用Unicode符号。</p><p> Transclusions and images use the same syntax as links, with an exclamation mark  ! prepended.Example:</p><p> 包含和图像使用与链接相同的语法，带有感叹号！例如：</p><p>     Container and entry blocks can contain other blocks, leaf blockscan not. Depending on the type of a leaf block, it can containtext, metadata or nothing at all,</p><p>     容器和入口块可以包含其他块，叶块则不能。根据叶子块的类型，它可以包含文本，元数据或根本不包含任何内容， </p><p> The block-related markup goes in the beginning of theline, in blocks of four symbols. That part of a line is calleda  block stack. The allowed nesting pattern is (INDENT|QUOTE)* LIST? LEAF?. In absence of an explicit leafblock, a formatted text paragraph is implied.</p><p>与块相关的标记在该行的开头，以四个符号组成。线的那一部分称为块堆栈。允许的嵌套模式是（INDENT | QUOTE）* LIST？叶？。在没有显式叶块的情况下，将隐含格式化的文本段落。</p><p> A block can be continued in the following lines; that issignaled by indents (four spaces) in place of the block markup.An empty line is considered to be a continuation line for thecontainer blocks in the stack, but not for the leaf block.</p><p> 可以在以下各行中继续执行块：空行被认为是代替块标记的缩进（四个空格）。空行被视为堆栈中容器块的续行，而不是叶块。</p><p>  # Multiline header 1. here the entry starts, and then it continues and continues... 2. ...till the next entry.</p><p>  ＃多行标题1.此条目开始，然后继续并继续... 2. ...直到下一个条目。</p><p> Changes in blockstack depth cause container nesting changes.Additional indent of less than 4 spaces is not meaningful.That allows for easier line-by-line parsing and interpretation.If an indent level starts with a bare indent, that creates ageneric container block (in other words, a  div). WithCommonMark, that should be a code block. StrictMark generalizesthat slightly.</p><p> 块堆栈深度的变化会导致容器嵌套的更改。少于4个空格的额外缩进没有意义，这使得逐行解析和解释更加容易。如果缩进级别以裸露的开头开始，则会创建通用容器块（在换句话说，一个div）。 WithCommonMark，应该是一个代码块。 StrictMark对此进行了概括。</p><p> In case a block marker ends with a non-space symbol, the nextsymbol must be whitespace (the gap space). For example, theonly  &lt;h4&gt; marker is  #### which must be followed by somewhitespace. That whitespace might be a part of the next markeror the line itself.</p><p> 如果块标记以非空格符号结尾，则下一个符号必须为空白（空格）。例如，唯一的＆lt; h4＆gt;标记是####，后面必须跟空格。该空格可能是下一个标记或行本身的一部分。</p><p>  &gt; blockquote, - bulleted list, 1. numbered list, generic block (div), ```` fenced code block, ## header (4 levels), [x]: reference definition, ____ ruler, [ ] TODO entry (in a list).</p><p>  ＆gt;块引用，-项目符号列表，1.编号列表，通用块（div），``围栏代码块，##标头（4级），[x]：参考定义，____标尺，[] TODO条目（在清单）。</p><p>  StrictMark is limited to four levels of headers. Only ATXheaders are allowed. Headers can be multiline. The markings only go in the beginning ofthe line. Examples:</p><p>  StrictMark限于四个级别的标题。只允许ATXheader。标头可以是多行。标记仅在行的开头。例子： </p><p>  Note that header markings are padded to 4 chars with spaces,like the rest of the block markup. In case the last char is nota space, the inline text must start with a gap space.</p><p>请注意，标头标记用空格填充为4个字符，与块标记的其余部分一样。如果最后一个字符不是一个空格，则内联文本必须以空格开头。</p><p>  The unordered list markup symbol is a dash  -. The other twoMarkdown options are  * and  +. But  * is ambiguous and  +is unpopular and there must be one way only!</p><p>  无序列表标记符号是破折号-。其他两个Markdown选项是*和+。但是*是模棱两可的，而+是不受欢迎的，并且只能是一种方法！</p><p> The ordered list markup is  12. numbers-dot. Again, listmarkup takes four chars per level. If the last char is not aspace, the first inline-text char must be a space. Theparticular indenting of bullet markers is up to the user.Typography purists may prefer  _1._ while people who like touse Tab will write  1.__. The GitHub ToDo extension syntax issupported as another leaf block,  _[ ].</p><p> 有序列表的标记为12.数字点。同样，listmarkup每个级别需要四个字符。如果最后一个字符不是空格，则第一个内联文本字符必须是空格。项目符号的特殊缩进由用户决定。印刷术纯粹主义者可能更喜欢_1._，而喜欢使用Tab的人会写1 .__。支持GitHub ToDo扩展语法作为另一个叶子块_ []。</p><p> - bulleted list - still bulleted 1. nested numbered list 2. more numbered plain paragraph, also nested, indented 4 chars 1. another nested list 2. of two entries - resume the bulleted list 1. I am a typography 2. purist, I set terminal to 3. custom fonts on a Mac. &lt;!-- --&gt; 1. I use Tab a lot, 2. I don&#39;t like to bother.</p><p> -项目符号列表-仍为项目符号1.嵌套编号列表2.更多编号的普通段落，也嵌套，缩进4个字符1.另一个嵌套列表2.包含两个条目-恢复项目符号列表1.我是排版2.纯粹主义者，我在Mac上将终端设置为3.自定义字体。 ＆lt;！--＆gt; 1.我经常使用Tab，2.我不喜欢打扰。</p><p> Note that numbered lists are limited to 999 properly numberedentries. Technically, numbering all entries   1.  will produceperfectly correct output, but the raw markup will not beproperly numbered then.</p><p> 请注意，编号列表仅限于999个正确编号的条目。从技术上讲，对所有条目编号1.将产生完全正确的输出，但是原始标记将不会正确编号。</p><p> To separate two adjacent lists of the same kind, CommonMarksuggests to use an empty HTML comment. We can not do better thanto recommend exactly the same trick. That counts as two piecesof fictive block markup, 8 chars total. In practice, you&#39;dbetter put some text inbetween.</p><p> 为了分隔相同类型的两个相邻列表，CommonMark建议使用空的HTML注释。我们不能做得比建议完全相同的技巧更好。这算作两个虚拟块标记，总共8个字符。在实践中，您会在两者之间插入一些文本。</p><p>    The only type of formatting where the continuation is notnecessarily an empty indent, but can also be a quotation marker.This exception is made because of historical reasons; it ishighly advised to use indents.</p><p>    唯一的一种格式，其中延续不一定是空的缩进，也可以是引号。强烈建议使用缩进。 </p><p>  Code blocks use the fenced syntax with exactly four backticks.The opening fence may mention the language used. The code mustbe indented 4 chars; that follows the same continuation rules asall the other block containers have. The closing code fence isoptional; the end of the code block can be signaled by the lackof indent. The code can safely use four backticks.</p><p>代码块使用带有四个反引号的栅栏语法。开头的栅栏可能会提到所使用的语言。代码必须缩进4个字符；遵循与其他所有块容器相同的延续规则。结束码栏是可选的；代码块的结尾可以通过缺少缩进来表示。该代码可以安全地使用四个反引号。</p><p>    ## C O N T A I N E R B L O C K S CHAR = any; WS = [ \t\r\n]; NONWS = CHAR - WS; # StrictMark allows NO \n\r as there must be one way only! # Also, notepad.exe now supports Unix newlines. NL = &#34;\n&#34;; NONNL = CHAR - NL; INLINE = NONNL*; MARKUP = [`*_\[\]]; PUNCT = &#34;!&#34;..&#34;/&#34; | &#34;:&#34;..&#34;&#34; | &#34;[&#34;..&#34;`&#34; | &#34;{&#34;..&#34;~&#34;; NONWSP = NONWS - PUNCT; WSP = WS | PUNCT; WSA = WS ; INDENT = &#34; &#34;; HEAD1 = &#34; #&#34; | &#34; # &#34; | &#34; # &#34; | &#34;# &#34;; HEAD2 = &#34; ##&#34; | &#34; ## &#34; | &#34;## &#34;; HEAD3 = &#34; ###&#34; | &#34;### &#34;; HEAD4 = &#34;####&#34;; HEADER = HEAD1 | HEAD2 | HEAD3 | HEAD4 ; QUOTE = &#34;&gt; &#34; | &#34; &gt; &#34; | &#34; &gt; &#34; | &#34; &gt;&#34;; ULIST = &#34; - &#34; | &#34;- &#34; | &#34; - &#34; | &#34; -&#34;; OLIST = &#34; &#34; digit &#34;. &#34; | digit &#34;. &#34; | &#34; &#34; digit &#34;.&#34; | digit digit &#34;. &#34; | &#34; &#34; digit digit &#34;.&#34; | digit digit digit &#34;.&#34;; FENCE = &#34;````&#34;; HLINE = &#34;----&#34;; LINK_LABEL = CODEPOINT - WSP - &#34;]&#34;; REFDEF = &#34;[&#34; LINK_LABEL &#34;]:&#34;; NESTBLOCK = INDENT | QUOTE ; LISTBLOCK = ULIST | OLIST ; LEAFBLOCK = HEADER | FENCE | HLINE | REFDEF ; BLOCK_STACK = NESTBLOCK* LISTBLOCK? LEAFBLOCK?; FUCKED_LINE = &#34;TODO&#34;; LINE = ( BLOCK_STACK INLINE NL ) ; WIKITEXT = LINE*; ## S T R I C T M A R K I N L I N E ## not that each word is a URL candidate; use the URL parser separately ## as the full URL grammar will blow this state machine up AWORD = (NONWS+) ; WORDS = AWORD (WS+ AWORD)*; ## emphasized text EMPH_BOTH_FLANKING = PUNCT &#34;_&#34; PUNCT ; EMPH_LEFT_FLANKING = (WSP &#34;_&#34; NONWS ) - EMPH_BOTH_FLANKING; EMPH_RIGHT_FLANKING = (NONWS &#34;_&#34; WSP ) - EMPH_BOTH_FLANKING; ## strong emphasis; can nest URIs, code spans; may contain escapes STRONG_BOTH_FLANKING = PUNCT &#34;*&#34; PUNCT ; STRONG_LEFT_FLANKING = (WSP &#34;*&#34; NONWS ) - STRONG_BOTH_FLANKING; STRONG_RIGHT_FLANKING = (NONWS &#34;*&#34; WSP ) - STRONG_BOTH_FLANKING; STRONG_INTRAWORD = &#34;*&#34; NONWSP+ &#34;*&#34; ; ## a reference link LINK_OPEN = [^\]] &#34;[&#34; ; LINK_CLOSE = &#34;][&#34; LINK_LABEL &#34;]&#34; ; ## code spans contain arbitrary Unicode, all parsed literally CODE = &#34;`&#34; ; ## backslash and ampersand escapes have higher precedence ## than other inline markup BACKSLASH_ESC = &#34;\\&#34; PUNCT ; AMPERSAND_ESC = &#34;&amp;&#34; ( alnum+ | &#34;#&#34; digit+ | &#34;#&#34; [xX] xdigit+ ) &#34;;&#34; ; ESC = BACKSLASH_ESC | AMPERSAND_ESC; ## to prevent combinatorial state explosion we find markup elements in the ## inline soup (left/right separately) then filter them by the nesting rules LEFT_MARKUP = EMPH_LEFT_FLANKING | STRONG_LEFT_FLANKING | LINK_OPEN; RIGHT_MARKUP = EMPH_RIGHT_FLANKING | STRONG_RIGHT_FLANKING | LINK_CLOSE; OTHER = STRONG_INTRAWORD | CODE | ESC; INLINE_SOUP = (LEFT_MARKUP|RIGHT_MARKUP|OTHER|CHAR)* ; LINK_REF_DEF = REFDEF WS* (NONWS+) (WS+ [&#34;] (CHAR-[&#34;])* [&#34;] )? WS*; }%%</p><p>    ## C O N T A I N E R B L O C K S CHAR =任何； WS = [\ t \ r \ n]; NONWS = CHAR-WS; ＃StrictMark不允许\ n \ r，因为只能有一种方法！ ＃此外，notepad.exe现在支持Unix换行符。 NL =＆＃34; \ n＆＃34 ;; NONNL = CHAR-NL; INLINE = NONNL *; MARKUP = [`* _ \ [\]]; PUNCT =＆＃34;！＆＃34; ..＆＃34; /＆＃34; | ＆＃34;：＆＃34; ..＆＃34;＆＃34; | ＆＃34; [＆＃34; ..＆＃34;`＆＃34; | ＆＃34; {＆＃34; ..＆＃34;〜＆＃34 ;; NONWSP = NONWS-PUNCT; WSP = WS | PUNCT; WSA = WS; INDENT =＆＃34; ＆＃34 ;; HEAD1 =＆＃34; ＃＆＃34; | ＆＃34; ＃＆＃34; | ＆＃34; ＃＆＃34; | ＆＃34;＃＆＃34 ;; HEAD2 =＆＃34; ##＆＃34; | ＆＃34; ##＆＃34; | ＆＃34; ##＆＃34 ;; HEAD3 =＆＃34; ###＆＃34; | ＆＃34; ###＆＃34 ;; HEAD4 =＆＃34; ####＆＃34 ;; HEADER = HEAD1 | HEAD2 | HEAD3 | HEAD4; QUOTE =＆＃34;＆gt; ＆＃34; | ＆＃34; ＆gt; ＆＃34; | ＆＃34; ＆gt; ＆＃34; | ＆＃34; ＆gt;＆＃34 ;; ULIST =＆＃34; -＆＃34; | ＆＃34;-＆＃34; | ＆＃34; -＆＃34; | ＆＃34; -＆＃34 ;; OLIST =＆＃34; ＆＃34;数字＆＃34;。 ＆＃34; |数字＆＃34;。 ＆＃34; | ＆＃34; ＆＃34;数字＆＃34;。＆＃34; |数位＆＃34;。 ＆＃34; | ＆＃34; ＆＃34;数位＆＃34;。＆＃34; |位数位数＆＃34;。＆＃34 ;;围栏=＆＃34;````＆＃34 ;; HLINE =＆＃34; ----＆＃34 ;; LINK_LABEL = CODEPOINT-WSP-＆＃34;]＆＃34 ;; REFDEF =＆＃34; [＆＃34; LINK_LABEL＆＃34;]：＆＃34 ;; NESTBLOCK = INDENT |报价; LISTBLOCK = ULIST |奥利斯特; LEAFBLOCK =标题|围栏| HLINE | REFDEF; BLOCK_STACK = NESTBLOCK * LISTBLOCK？叶块？ FUCKED_LINE =＆＃34; TODO＆＃34 ;; LINE =（BLOCK_STACK INLINE NL）; WIKITEXT = LINE *; ##不是每个单词都是URL候选者；单独使用URL解析器##，因为完整的URL语法会使状态机崩溃AWORD =（NONWS +）；字= AWORD（WS + AWORD）*; ##强调文字EMPH_BOTH_FLANKING = PUNCT＆＃34; _＆＃34; PUNCT; EMPH_LEFT_FLANKING =（WSP＆＃34; _＆＃34; NONWS）-EMPH_BOTH_FLANKING; EMPH_RIGHT_FLANKING =（NONWS＆＃34; _＆＃34; WSP）-EMPH_BOTH_FLANKING; ##强调；可以嵌套URI，代码范围；可能包含转义符STRONG_BOTH_FLANKING = PUNCT＆＃34; *＆＃34; PUNCT; STRONG_LEFT_FLANKING =（WSP＆＃34; *＆＃34; NONWS）-STRONG_BOTH_FLANKING; STRONG_RIGHT_FLANKING =（NONWS＆＃34; *＆＃34; WSP）-STRONG_BOTH_FLANKING; STRONG_INTRAWORD =＆＃34; *＆＃34; NONWSP +＆＃34; *＆＃34; ; ##参考链接LINK_OPEN = [^ \]]＆＃34; [＆＃34; ; LINK_CLOSE =＆＃34;] [＆＃34; LINK_LABEL＆＃34;]＆＃34; ; ##代码范围包含任意Unicode，所有字符均按字面解析CODE =＆＃34;`＆＃34; ; ##反斜杠和＆换码符的优先级比其他内联标记的优先级更高## BACKSLASH_ESC =＆＃34; \\＆＃34; PUNCT; AMPERSAND_ESC =＆＃34;＆＃34; （alnum + |＆＃34;＃＆＃34; digit + |＆＃34;＃＆＃34; [xX] xdigit +）＆＃34 ;;＆＃34; ; ESC = BACKSLASH_ESC | AMPERSAND_ESC; ##为防止组合状态爆炸，我们在##嵌入式汤中（分别为左/右）找到标记元素，然后通过嵌套规则过滤它们。LEFT_MARKUP = EMPH_LEFT_FLANKING | STRONG_LEFT_FLANKING | LINK_OPEN； RIGHT_MARKUP = EMPH_RIGHT_FLANKING | STRONG_RIGHT_FLANKING | LINK_CLOSE; OTHER = STRONG_INTRAWORD |代码| ESC键; INLINE_SOUP =（LEFT_MARKUP | RIGHT_MARKUP | OTHER | CHAR）*； LINK_REF_DEF = REFDEF WS *（NONWS +）（WS + [＆＃34;]（CHAR-[＆＃34;]）* [＆＃34;]）？ WS *; } %% </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://doc.replicated.cc/%5EWiki/strictmark.sm">http://doc.replicated.cc/%5EWiki/strictmark.sm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/markdown/">#markdown</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>