<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>StackOverflow：鲜为人知但有用的数据结构</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">StackOverflow：鲜为人知但有用的数据结构</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 20:50:46</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/ff0287210796737fd34a6056d629fa7a.png"><img src="http://img2.diglog.com/img/2020/11/ff0287210796737fd34a6056d629fa7a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There are some data structures around that are really useful but are unknown to most programmers. Which ones are they?</p><p>周围有一些数据结构非常有用，但大多数程序员都不知道。他们是哪几个？</p><p> Everybody knows about linked lists, binary trees, and hashes, but what about  Skip lists and  Bloom filters for example. I would like to know more data structures that are not so common, but are worth knowing because they rely on great ideas and enrich a programmer&#39;s tool box.</p><p>每个人都知道链表、二叉树和散列，但是例如跳过列表和Bloom过滤器呢？我想知道更多不那么常见但值得了解的数据结构，因为它们依赖于伟大的想法，并丰富了程序员的工具箱。</p><p> PS: I am also interested in techniques like  Dancing links which make clever use of properties of a common data structure.</p><p>PS：我对舞蹈链接这样的技术也很感兴趣，这些技术巧妙地利用了公共数据结构的属性。</p><p> EDIT:Please try to  include links to pages describing the data structures in more detail. Also, try to add a couple of words on  why a data structure is cool (as  Jonas Kölker already pointed out). Also, try to provide   one data-structure per answer. This will allow the better data structures to float to the top based on their votes alone.</p><p>编辑：请尝试包含更详细描述数据结构的页面的链接。此外，尝试添加几个词来说明为什么数据结构很酷(正如Jonas Kölker已经指出的那样)。此外，请尝试为每个答案提供一个数据结构。这将允许更好的数据结构仅基于它们的投票而浮动到顶部。</p><p>    Tries, also known as prefix-trees or  crit-bit trees, have existed for over 40 years but are still relatively unknown. A very cool use of tries is described in &#34; TRASH - A dynamic LC-trie and hash data structure&#34;, which combines a trie with a hash function.</p><p>尝试，也称为前缀树或临界位树，已经存在了40多年，但仍然相对鲜为人知。&#34；trash-A dynamic LC-trie和散列数据结构&#34；中描述了一种非常酷的尝试用法，它将trie与散列函数相结合。</p><p>  Burst tries are also an interesting variant, where you use only a prefix of the strings as nodes and otherwise store lists of strings in the nodes. –  Torsten Marek</p><p>突发尝试也是一个有趣的变体，您只使用字符串的前缀作为节点，否则将字符串列表存储在节点中。-托尔斯滕·马雷克(Torsten Marek)。</p><p>    In my experience tries are painfully expensive, given that a pointer is generally longer than a char, which is a shame. They&#39;re only suitable for certain data-sets. –  Joe</p><p>根据我的经验，考虑到指针通常比字符更长，尝试的代价高得令人痛苦，这是一件令人遗憾的事情。它们只适用于某些数据集。-约翰·乔(Joe)。</p><p>  Since no SO question, regardless of topic, is complete without someone mentioning jQuery.... John Resig, creator of jQuery, has an interesting data structure series of posts where he looks at various trie implementations among others:  ejohn.org/blog/revised-javascript-dictionary-search –  Oskar Austegard</p><p>因为如果没有人提到jQuery，那么任何问题，无论是什么主题，都是完整的……。John Resig，jQuery的创建者，有一个有趣的数据结构系列文章，其中他研究了各种TRIE实现，其中包括：ejohn.org/blog/revised-javascript-dictionary-search-奥斯卡·奥斯特加德(Oskar Austegard)</p><p>      To add an item you run it through  k hash functions that will give you  k indices in the array which you then set to 1.</p><p>要添加一个项目，您可以通过k个散列函数运行它，这些散列函数将给您数组中的k个索引，然后将其设置为1。</p><p> To check if an item is in the set, compute the  k indices and check if they are all set to 1.</p><p>要检查项目是否在集合中，请计算k个指数，并检查它们是否都设置为1。</p><p> Of course, this gives some probability of false-positives (according to wikipedia it&#39;s about 0.61^(m/n) where n is the number of inserted items). False-negatives are not possible.</p><p>当然，这也给出了一些误报的可能性(根据维基百科的数据，大约是0.61^(m/n)，其中n是插入的项目数)。假-阴性是不可能的。</p><p> Removing an item is impossible, but you can implement  counting bloom filter, represented by array of ints and increment/decrement.</p><p>移除一个项目是不可能的，但是您可以实现计数Bloom Filter，用整数数组和增量/减量来表示。</p><p>  You forget to mention their use with dictionaries :) You can squeeze a full dictionary into a bloom filter with about 512k, like a hashtable without the values –  Chris S</p><p>您忘了提到它们在字典中的用法：)您可以将一个完整的字典压缩到大约512k的Bloom过滤器中，就像没有值的哈希表一样--克里斯·S(Chris S)。</p><p>  Google cites the use of Bloom filters in there implementation of BigTable. –  Brian Gianforcaro</p><p>Google在Bigtable的实现中引用了Bloom Filters的使用。--布莱恩·詹福卡罗(Brian Gianforcaro)。</p><p>  @FreshCode It actually lets you cheaply test for the  absence of an element in the set since you can get false positives but never false negatives –  Tom Savage</p><p>@FreshCode它实际上允许您以较低的成本测试集合中是否缺少元素，因为您可能会得到假阳性，但绝不会得到假阴性-汤姆·萨维奇(Tom Savage)。</p><p>  @FreshCode As @Tom Savage said, it&#39;s more useful when checking for negatives. For example, you can use it as a fast and small (in terms of memory usage) spell checker. Add all of the words to it and then try to look up words the user enters. If you get a negative it means it&#39;s misspelled. Then you can run some more expensive check to find closest matches and offer corrections. –  lacop</p><p>@FreshCode正如@Tom Savage所说，它在检查底片时更有用。例如，您可以将其用作快速且较小的拼写检查器(就内存使用量而言)。将所有单词添加到其中，然后尝试查找用户输入的单词。如果你得到的是否定的，那就意味着拼错了。然后，您可以运行一些更昂贵的检查来查找最接近的匹配项并提供更正。--Lacop(空洞无章)</p><p>  @abhin4v: Bloom filters are often used when most requests are likely to return an answer of &#34;no&#34; (such as the case here), meaning that the small number of &#34;yes&#34; answers can be checked with a slower exact test. This still results in a big reduction in the  average query response time. Don&#39;t know if Chrome&#39;s Safe Browsing does that, but that would be my guess. –  j_random_hacker</p><p>@abhin4v：当大多数请求可能返回答案&#34；no&#34；(如这里的情况)时，通常会使用Bloom过滤器，这意味着可以使用较慢的精确测试来检查少数&#34；是&#34；答案。这仍然大大缩短了平均查询响应时间。我不知道Chrome的安全浏览功能是否能做到这一点，但那只是我的猜测。-dj_Random_hacker。</p><p>    Rope: It&#39;s a string that allows for cheap prepends, substrings, middle insertions and appends. I&#39;ve really only had use for it once, but no other structure would have sufficed. Regular strings and arrays prepends were just far too expensive for what we needed to do, and reversing everthing was out of the question.</p><p>绳索：它是一种允许廉价的前缀、子串、中间插入和附加的字符串。我真的只用过一次，但没有其他结构可以满足我的需要。常规的字符串和数组前缀对于我们需要做的事情来说太昂贵了，而且颠倒一切都是不可能的。</p><p>  I&#39;ve had thoughts of something like this for my own uses. Nice to know it&#39;s already been implemented somewhere else. –  Kibbee</p><p>我想过把这样的东西用在我自己身上。很高兴知道它已经在其他地方实施了。-Kibbee。</p><p>    Without knowing what is was called I recently wrote something very similar to this for Java - performance has been excellent:  code.google.com/p/mikeralib/source/browse/trunk/Mikera/src/… –  mikera</p><p>在不知道它叫什么的情况下，我最近为JAVA写了一些非常类似的东西-性能一直很出色：code.google.com/p/mikeralib/source/browse/trunk/Mikera/src/…。-米凯拉(Sigmikera)。</p><p>      Wikipedia  A skip list is a probabilistic data structure, based on multiple parallel, sorted linked lists, with efficiency comparable to a binary search tree (order log n average time for most operations).</p><p>维基百科跳过列表是一种概率数据结构，基于多个并行的排序链表，其效率可与二叉搜索树相媲美(对于大多数操作，排序日志n平均时间)。</p><p> They can be used as an alternative to balanced trees (using probalistic balancing rather than strict enforcement of balancing). They are easy to implement and faster than say, a red-black tree. I think they should be in every good programmers toolchest.</p><p>它们可以用作平衡树的替代方案(使用概率平衡，而不是严格执行平衡)。它们很容易实现，而且比红黑树更快。我认为它们应该出现在每个优秀的程序员工具箱中。</p><p> If you want to get an in-depth introduction to skip-lists here is a  link to a video of MIT&#39;s Introduction to Algorithms lecture on them.</p><p>如果你想深入了解跳表，这里有一个链接，链接到麻省理工学院关于它们的算法入门讲座的视频。</p><p>  +1 Qt uses skip lists rather than RB-trees for its sorted maps &amp; sets. Yep, they&#39;re nifty (in imperative languages, anyway). –  Michael Ekstrand</p><p>+1 Qt使用跳过列表而不是RB树作为其排序的映射&amp；集。是的，它们很漂亮(至少是在命令式语言中)。-迈克尔·埃克斯特兰德(Michael Ekstrand)</p><p>    Skip lists are probably my favorite data structure to use when I need a good data structure and I have no guarantees as to the order of the data, and I want a simpler implementation than other &#34;balanced&#34; data structures. Such a good thing. –  earino</p><p>当我需要一个好的数据结构，并且我不能保证数据的顺序，并且我想要一个比其他平衡数据结构更简单的实现时，跳跃列表可能是我最喜欢使用的数据结构。真是一件好事。-西里诺。</p><p>  Interesting side-note: If you add enough levels to your skip lists, you essentially end up with a B-tree. –  Riyad Kalla</p><p>有趣的附注：如果您向您的跳跃列表中添加了足够的级别，您基本上会得到一个B树。-里亚德·卡拉(Riyad Kalla)。</p><p>    Spatial Indices, in particular  R-trees and  KD-trees, store spatial data efficiently. They are good for geographical map coordinate data and VLSI place and route algorithms, and sometimes for nearest-neighbor search.</p><p>空间索引，特别是R-树和KD-树，能够高效地存储空间数据。它们适用于地理地图坐标数据和VLSI位置和路线算法，有时还适用于最近邻搜索。</p><p>  Spatial indices are also useful for N-body simulations involving long-range forces like gravity. –  Justin Peel</p><p>空间索引对于涉及长程力(如重力)的N体模拟也很有用。-作者贾斯汀·皮尔(Justin Peel)。</p><p>    Zippers - derivatives of data structures that modify the structure to have a natural notion of &#39;cursor&#39; -- current location. These are really useful as they guarantee indicies cannot be out of bound -- used, e.g. in the  xmonad window manager to track which window has focused.</p><p>拉链(Zippers)-数据结构的派生，将结构修改为具有光标的自然概念-当前位置。这些非常有用，因为它们保证索引不会越界--例如，在xmonad窗口管理器中用来跟踪哪个窗口被聚焦。</p><p> Amazingly, you can derive them by  applying techniques from calculus to the type of the original data structure!</p><p>令人惊讶的是，您可以通过将微积分中的技术应用于原始数据结构的类型来派生它们！</p><p>  this is only useful in functional programming (in imperative languages you just keep a pointer or an index). Also tbh I still don&#39;t get how Zippers really work. –  Stefan Monov</p><p>这只在函数式编程中有用(在命令式语言中，您只需保留一个指针或索引)。另外，我还是不明白拉链到底是怎么工作的。--斯特凡·莫诺夫(Stefan Monov)。</p><p>  @Stefan the point is that you don&#39;t need to keep a separate index or pointer now. –  Don Stewart</p><p>@Stefan，重点是你现在不需要保留单独的索引或指针。-唐·斯图尔特(Don Stewart)</p><p>    Suffix tries. Useful for almost all kinds of string searching (  http://en.wikipedia.org/wiki/Suffix_trie#Functionality). See also suffix arrays; they&#39;re not quite as fast as suffix trees, but a whole lot smaller.</p><p>后缀尝试。适用于几乎所有类型的字符串搜索(http://en.wikipedia.org/wiki/Suffix_trie#Functionality).。另请参阅后缀数组；它们不如后缀树快，但要小得多。</p><p> They are small: you only need the left and right pointers like you do in any binary tree (no node-color or size information needs to be stored)</p><p>它们很小：您只需要左指针和右指针，就像在任何二叉树中一样(不需要存储节点颜色或大小信息)。</p><p>  They offer optimal amortized complexity for a whole host of &#34;measurement criteria&#34; (log n lookup time being the one everybody knows). See   http://en.wikipedia.org/wiki/Splay_tree#Performance_theorems</p><p>它们为一系列度量标准(每个人都知道log n查找时间)提供了最佳的摊销复杂性。请参阅http://en.wikipedia.org/wiki/Splay_tree#Performance_theorems。</p><p> Heap-ordered search trees: you store a bunch of (key, prio) pairs in a tree, such that it&#39;s a search tree with respect to the keys, and heap-ordered with respect to the priorities. One can show that such a tree has a unique shape (and it&#39;s not always fully packed up-and-to-the-left). With random priorities, it gives you expected O(log n) search time, IIRC.</p><p>按堆排序的搜索树：您在树中存储一串(键，优先级)对，这样它就是相对于键的搜索树，并且按照优先级按堆排序。人们可以证明，这样的树有一个独特的形状(而且它并不总是被完全打包在一起，向左)。对于随机优先级，它给出了预期的O(Logn)搜索时间IIRC。</p><p> A niche one is adjacency lists for undirected planar graphs with O(1) neighbour queries. This is not so much a data structure as a particular way to organize an existing data structure. Here&#39;s how you do it: every planar graph has a node with degree at most 6. Pick such a node, put its neighbors in its neighbor list, remove it from the graph, and recurse until the graph is empty. When given a pair (u, v), look for u in v&#39;s neighbor list and for v in u&#39;s neighbor list. Both have size at most 6, so this is O(1).</p><p>一个小生境是具有O(1)个邻接查询的无向平面图的邻接表。与其说这是一种数据结构，不如说是组织现有数据结构的一种特殊方式。你可以这样做：每个平面图都有一个度不超过6的节点。选择一个这样的节点，把它的邻居放在它的邻居列表中，把它从图中删除，然后递归，直到图为空。当给定一对(u，v)时，在v&#39；的邻居列表中查找u，在u&#39；的邻居列表中查找v。这两个函数的大小都不超过6，所以这是O(1)。</p><p> By the above algorithm, if u and v are neighbors, you won&#39;t have both u in v&#39;s list and v in u&#39;s list. If you need this, just add each node&#39;s missing neighbors to that node&#39;s neighbor list, but store how much of the neighbor list you need to look through for fast lookup.</p><p>根据上述算法，如果u和v是邻居，则v的列表中不会同时包含u和v。如果需要，只需将每个节点缺少的邻居添加到该节点的邻居列表中，但要存储您需要查找多少邻居列表才能快速查找。</p><p>  The Heap ordered search tree is called a treap. One trick you can do with these is change the priority of a node to push it to the bottom of the tree where its easier to delete. –  paperhorse</p><p>堆排序搜索树称为树。其中一个技巧是更改节点的优先级，将其推到树的底部，这样更容易删除。--纸马。</p><p>  &#34;The Heap ordered search tree is called a treap.&#34; -- In the definition I&#39;ve heard, IIRC, a treap is a heap-ordered search tree with  random priorities. You could choose other priorities, depending on the application... –  Jonas Kölker</p><p>堆排序搜索树称为树。--在我听说的定义中，IIRC，树是具有随机优先级的堆排序搜索树。您可以根据应用程序选择其他优先级...--乔纳斯·科尔克(Jonas Kölker)</p><p>  A suffix  trie is almost but not quite the same as the much cooler suffix  tree, which has strings and not individual letters on its edges and can be built in linear time(!). Also despite being asymptotically slower, in practice suffix arrays are often much faster than suffix trees for many tasks because of their smaller size and fewer pointer indirections. Love the O(1) planar graph lookup BTW! –  j_random_hacker</p><p>后缀trie几乎但不完全与更酷的后缀树相同，后者的边缘有字符串，而不是单个字母，并且可以在线性时间内构建(！)。此外，尽管后缀数组的速度渐近较慢，但实际上对于许多任务而言，后缀数组通常比后缀树快得多，因为后缀数组的大小更小，指针间接性更少。喜欢O(1)平面图查找BTW！-dj_Random_hacker。</p><p>  @j_random_hacker: suffix arrays are not asymptotically slower. Here is ~50 lines of code for linear suffix array construction:  cs.helsinki.fi/u/tpkarkka/publications/icalp03.pdf –  Edward KMETT</p><p>@j_Random_Hacker：后缀数组不会渐近变慢。下面是构建线性后缀数组的大约50行代码：cs.helsinki.fi/u/tpkarkka/publications/icalp03.pdf-爱德华·KMETT(Edward KMETT)。</p><p>  @Edward Kmett: I have in fact read that paper, it was quite a breakthrough in suffix array  construction. (Although it was already known that linear time construction was possible by going &#34;via&#34; a suffix tree, this was the 1st undeniably practical &#34;direct&#34; algorithm.) But some operations outside of construction are still asymptotically slower on a suffix array unless a LCA table is also built. That can also be done in O(n), but you lose the size and locality benefits of the pure suffix array by doing so. –  j_random_hacker</p><p>@Edward Kmett：事实上，我读过那篇论文，它在后缀数组构造方面取得了相当大的突破。(虽然我们已经知道通过后缀树进行线性时间构造是可能的，但这是第一个不可否认的实用算法。)。但是，除非还构建了LCA表，否则在后缀数组上，构造外的一些操作仍然会逐渐变慢。这也可以在O(N)中实现，但是这样做会失去纯后缀数组的大小和局部性优势。-dj_Random_hacker。</p><p>    I think lock-free alternatives to standard data structures i.e lock-free queue, stack and list are much overlooked. They are increasingly relevant as concurrency becomes a higher priority and are much more admirable goal than using Mutexes or locks to handle concurrent read/writes.</p><p>我认为标准数据结构的无锁替代方案(即无锁队列、堆栈和列表)被忽视了。随着并发性成为更高的优先级，它们变得越来越相关，并且比使用Mutex或锁来处理并发读/写要好得多。</p><p>  Lock-free alternatives are so important in todays multi-core, very parallel, scalability addicted world :-) –  earino</p><p>在当今多核、高度并行、可扩展性上瘾的世界里，无锁替代方案非常重要：-)-西里诺。</p><p>    I think  Disjoint Set is pretty nifty for cases when you need to divide a bunch of items into distinct sets and query membership. Good implementation of the Union and Find operations result in amortized costs that are effectively constant (inverse of Ackermnan&#39;s Function, if I recall my data structures class correctly).</p><p>我认为当您需要将一堆项目划分为不同的集合并查询成员身份时，不相交集合非常有用。UNION和FIND操作的良好实现会产生有效恒定的摊销成本(如果我没有记错数据结构类，则与Ackermnan的函数相反)。</p><p>  This is also called the  &#34;union-find data structure.&#34; I was in awe when I first learned about this clever data structure in algorithms class... –  BlueRaja - Danny Pflughoeft</p><p>这也被称为联合查找数据结构。当我在算法课上第一次了解到这种聪明的数据结构时，我感到非常敬畏……--BlueRaja-Danny Pflughoeft。</p><p>    I used a Disjoint Set for my Dungeon generator, to ensure all rooms are reachable by passages :) –  goldenratio</p><p>我为我的地下城发电机使用了一套不相交的装置，以确保所有房间都可以通过通道到达：)-更高的黄金比率</p><p>    They&#39;re used in some of the fastest known algorithms (asymptotically) for a lot of graph-related problems, such as the Shortest Path problem. Dijkstra&#39;s algorithm runs in O(E log V) time with standard binary heaps; using Fibonacci heaps improves that to O(E + V log V), which is a huge speedup for dense graphs. Unfortunately, though, they have a high constant factor, often making them impractical in practice.</p><p>它们被用在一些已知的最快算法中(渐近地)来解决许多与图相关的问题，例如最短路径问题。Dijkstra&#39；的算法使用标准的二进制堆运行在O(E Log V)时间内；使用斐波纳契堆将其改进为O(E+V log V)，这对于密集图来说是一个巨大的加速。然而，不幸的是，它们有一个很高的恒定因素，经常使它们在实践中不切实际。</p><p>  High constant factor as you said, and hard to implement well according to a friend who had to. Fianally not that cool, but still, maybe worth knowing. –  p4bl0</p><p>如你所说的高恒定因素，据一位不得不这样做的朋友说，很难很好地实施。虽然不是很酷，但也许还是值得了解一下。-3p4bl0。</p><p>  These guys here made them run competetive in comparison to other heap kinds:  cphstl.dk/Presentation/SEA2010/SEA-10.pdf There is a related data structure called Pairing Heaps that&#39;s easier to implement and that offers pretty good practical performance. However, the theoretical analysis is partially open. –  Manuel</p><p>这里的这些人使它们与其他堆类型相比更具竞争力：cphstl.dk/Presentation/SEA2010/SEA-10.pdf有一种称为配对堆的相关数据结构，它更容易实现，并且提供了相当好的实际性能。然而，理论分析是部分开放的。--约翰·曼努埃尔。</p><p>  From my experience with Fibonacci heaps, I found out that costly operation of memory allocations makes it less efficient than a simple binary heap backended by an array. –  jutky</p><p>根据我使用斐波纳契堆的经验，我发现内存分配的昂贵操作使其效率低于由数组作为后端的简单二进制堆。-JUTTACY。</p><p>    Anyone with experience in 3D rendering should be familiar with  BSP trees. Generally, it&#39;s the method by structuring a 3D scene to be manageable for rendering knowing the camera coordinates and bearing.</p><p>任何有3D渲染经验的人都应该熟悉BSP树。一般来说，这是一种方法，通过构造一个3D场景，以便在知道相机坐标和方位的情况下进行渲染。</p><p> Binary space partitioning (BSP) is a method for recursively subdividing a space into convex sets by hyperplanes. This subdivision gives rise to a representation of the scene by means of a tree data structure known as a BSP tree.</p><p>二元空间划分(BSP)是一种用超平面递归地将空间细分为凸集的方法。该细分通过称为BSP树的树数据结构产生场景的表示。</p><p>  In other words, it is a method of breaking up intricately shaped polygons into convex sets, or smaller polygons consisting entirely of non-reflex angles (angles smaller than 180°). For a more general description of space partitioning, see space partitioning.</p><p>换句话说，它是一种将形状复杂的多边形分解为凸集或完全由无反射角度(小于180°的角度)组成的较小多边形的方法。有关空间分区的更一般说明，请参见空间分区。</p><p>  Originally, this approach was proposed in 3D computer graphics to increase the rendering efficiency. Some other applications include performing geometrical operations with shapes (constructive solid geometry) in CAD, collision detection in robotics and 3D computer games, and other computer applications that involve handling of complex spatial scenes.</p><p>这种方法最初是在3D计算机图形学中提出的，目的是提高渲染效率。一些其他应用包括在CAD中对形状执行几何操作(构造性实体几何)，在机器人和3D计算机游戏中进行碰撞检测，以及涉及处理复杂空间场景的其他计算机应用。</p><p>    Although it is interesting, isn&#39;t this sort of an &#39;Intro to Algorithms&#39;, here-is-an-example-of-a-greedy-algo type topic? –  rshepherd</p><p>虽然这很有趣，但这不是算法导论的一种吗，这里是一个贪婪算法的例子类型的话题吗？-牧羊人。</p><p>    Have a look at  Finger Trees, especially if you&#39;re a fan of the  previously mentioned purely functional data structures. They&#39;re a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece.</p><p>看一下指状树，特别是如果您是前面提到的纯函数数据结构的粉丝的话。它们是持久序列的函数表示，支持在分期恒定时间内访问末端，并且在较小片段的大小中以时间对数连接和拆分。</p><p>  Our functional 2-3 finger trees are an instance of a general design technique in- troduced by Okasaki (1998), called  implicit recursive slowdown. We have already noted that these trees are an extension of his implicit deque structure, replacing pairs with 2-3 nodes to provide the flexibility required for efficient concatenation and splitting.</p><p>我们的功能性2-3指树是Okasaki(1998)介绍的一种称为隐式递归减速的通用设计方法的一个实例。我们已经注意到，这些树是他的隐式双队列结构的扩展，用2-3个节点替换对，以提供有效的级联和拆分所需的灵活性。</p><p> A Finger Tree can be parameterized with a  monoid, and using different monoids will result in different behaviors for the tree. This lets Finger Trees simulate other data structures.</p><p>指状树可以用么半群参数化，使用不同的么半群将导致树的不同行为。这使指状树可以模拟其他数据结构。</p><p>  Have a look at  this duplicate answer, it&#39;s well worth reading ! –  Francois G</p><p>看一下这个重复的答案，它非常值得一读！--弗朗索瓦·G(Francois G)。</p><p>    Also, disgustingly, somehow managed to be patented (at least when used for video).  ip.com/patent/USRE36801 –  David Eison</p><p>此外，令人作呕的是，不知何故设法获得了专利(至少在用于视频时是这样)。IP.com/Patent/USRE36801-大卫·艾森(David Eison)。</p><p>  Based on reading the link, I don&#39;t think the data structure itself is patented, but some invention based on it. I agree that this is definitely a very under-used data structure. –  Gravity</p><p>基于阅读链接，我认为数据结构本身并不是专利，而是一些基于它的发明。我同意这绝对是一个很少使用的数据结构。--地心引力。</p><p>    Used in many cases (P2P programs, digital signatures) where you want to verify the hash of a whole file when you only have part of the file available to you.</p><p>在许多情况下(P2P程序、数字签名)使用，当您只有部分文件可用时，您想要验证整个文件的哈希。</p><p>    I think it&#39;d be useful to know  why they&#39;re cool. In general, the question &#34;why&#34; is the most important to ask ;)</p><p>我想知道为什么它们很酷是很有用的。通常，为什么要问的问题是最重要的。)。</p><p> My answer is that they give you O(log log n) dictionaries with {1..n} keys, independent of how many of the keys are in use. Just like repeated halving gives you O(log n), repeated sqrting gives you O(log log n), which is what happens in the vEB tree.</p><p>我的答案是，他们给您提供具有{1..n}个键的O(Log Log N)个字典，与正在使用的键的数量无关。就像重复减半得到O(Logn)一样，重复sqrting得到O(Logn)，这就是在VEB树中发生的事情。</p><p>  They are nice from a theoretical point of view. In practice, however, it&#39;s quite tough to get competetive performance out of them. The paper I know got them to work well up to 32 bit keys ( citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.7403) but the approach will not scale to more than maybe 34-35 bits or so and there is no implementation of that. –  Manuel</p><p>从理论上讲，它们是不错的。然而，在实践中，要从他们身上获得有竞争力的表现是相当困难的。据我所知，这篇论文让它们可以很好地工作到32位密钥(citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.7403))，但这种方法不会扩展到超过34-35位左右，而且还没有实现。--约翰·曼努埃尔。</p><p>  Another reason why they are cool is that they are a key building block for a number of cache-oblivious algorithms. –  Edward KMETT</p><p>它们很酷的另一个原因是，它们是许多缓存无关算法的关键构建块。-爱德华·KMETT(Edward KMETT)。</p><p>        An interesting variant of the hash table is called  Cuckoo Hashing. It uses multiple hash functions instead of just 1 in order to deal with hash collisions. Collisions are resolved by removing the old object from the location specified by the primary hash, and moving it to a location specified by an alternate hash function. Cuckoo Hashing allows for more efficient use of memory space because you can increase your load factor up to 91% with only 3 hash functions and still have good access time.</p><p>哈希表的一个有趣变体称为布谷鸟散列。它使用多个散列函数而不是只使用1个散列函数来处理散列冲突。冲突的解决方法是从主散列指定的位置删除旧对象，并将其移动到备用散列函数指定的位置。布谷鸟散列允许更有效地使用内存空间，因为您只需使用3个散列函数就可以将负载率提高到91%，并且仍然具有良好的访问时间。</p><p>    A  min-max heap is a variation of a  heap that implements a double-ended priority queue. It achieves this by by a simple change to the heap property: A tree is said to be min-max ordered if every element on even (odd) levels are less (greater) than all childrens and grand children. The levels are numbered starting from 1.</p><p>最小-最大堆是实现双端优先级队列的堆的变体。它通过简单地更改heap属性来实现这一点：如果偶(奇)级上的每个元素都小于(大于)所有子级和子级，则称树是最小-最大排序的。级别从1开始编号。</p><p>    I like  Cache Oblivious datastructures. The basic idea is to lay out a tree in recursively smaller blocks so that caches of many different sizes will take advantage of blocks that convenient fit in them. This leads to efficient use of caching at everything from L1 cache in RAM to big chunks of data read off of the disk without needing to know the specifics of the sizes of any of those caching layers.</p><p>我喜欢缓存不经意的数据结构。其基本思想是在递归较小的块中布局树，以便许多不同大小的缓存将利用适合它们的块。这导致高效地使用从RAM中的L1缓存到从磁盘读取的大块数据的所有内容的缓存，而无需知道任何缓存层的具体大小。</p><p>  Interesting transcription from that link: &#34;The key is the van Emde Boas layout, named after the van Emde Boas tree data structure conceived in 1977 by Peter van Emde Boas&#34; –  sergiol</p><p>该链接的有趣抄写：&#34；关键是van Emde Boas布局，以1977年由Peter van Emde Boas&#34构思的van Emde Boas树数据结构命名；-谢尔盖·塞吉奥尔</p><p>    Left Leaning Red-Black Trees. A significantly simplified implementation of red-black trees by Robert Sedgewick published in 2008 (~half the lines of code to implement). If you&#39;ve ever had trouble wrapping your head around the implementation of a Red-Black tree, read about this variant.</p><p>左倾的红黑相间的树。Robert Sedgewick在2008年发布的一个显著简化的红黑树实现(大约需要实现一半的代码行)。如果您曾经在理解红黑树的实现时遇到过困难，请阅读这个变体。</p><p>    Lock-free data structure for dividing the work equaly among multiple threads Implementation of a work stealing queue in C/C++?</p><p>多线程工作均衡分配的无锁数据结构C/C++中工作窃取队列的实现。</p><p>    Despite their long name, they provide asymptotically optimal heap operations, even in a function setting.</p><p>尽管它们的名称很长，但它们提供了渐近最优的堆操作，即使在函数设置中也是如此。</p><p>  Note that union takes  O(1) rather than  O(log n) time unlike the more well-known heaps that are commonly covered in data structure textbooks, such as  leftist heaps. And unlike  Fibonacci heaps, those asymptotics are worst-case, rather than amortized, even if used persistently!</p><p>请注意，UNION需要O(1)而不是O(Logn)时间，这与数据结构教科书中通常介绍的更知名的堆不同，比如左倾堆。与斐波那契堆不同的是，这些渐近是最坏的情况，而不是摊销，即使持续使用！</p><p>  They were jointly derived by Brodal and Okasaki, after Brodal came up with an  imperative heap with the same asymptotics.</p><p>它们是在布罗达尔提出具有相同渐近性的命令堆之后，由布罗达尔和冈崎共同推导出来的。</p><p>    Kd-Trees, spatial data structure used (amongst others) in Real-Time Raytracing, has the downside that triangles that cross intersect the different spaces need to be clipped. Generally BVH&#39;s are faster because they are more lightweight.</p><p>KD-Trees是实时光线跟踪中使用的(其中包括)空间数据结构，其缺点是需要对与不同空间相交的三角形进行裁剪。一般来说，BVH&39；的速度更快，因为它们更轻。</p><p> MX-CIF Quadtrees, store bounding boxes instead of arbitrary point sets by combining a regular quadtree with a binary tree on the edges of the quads.</p><p>MX-CIF四叉树通过将规则四叉树与四叉树边缘的二叉树相结合来存储边界框而不是任意点集。</p><p> HAMT, hierarchical hash map with access times that generally exceed O(1) hash-maps due to the constants involved.</p><p>HAMT，由于涉及的常量，访问时间通常超过O(1)个散列映射的分层散列映射。</p><p> Inverted Index, quite well known in the search-engine circles, because it&#39;s used for fast retrieval of documents associated with different search-terms.</p><p>倒排索引，在搜索引擎界非常有名，因为它用于快速检索与不同搜索词相关联的文档。</p><p> Most, if not all, of these are documented on the NIST  Dictionary of Algorithms and Data Structures</p><p>其中的大部分(如果不是全部)都记录在NIST算法和数据结构字典中。</p><p>    A ball tree is a data structure that indexes points in a metric space.  Here&#39;s an article on building them. They are often used for finding nearest neighbors to a point or accelerating k-means.</p><p>球树是对公制空间中的点进行索引的数据结构。这里有一篇关于建造它们的文章。它们通常用于查找到某一点的最近邻居或加速k-Means。</p><p>  These are also commonly known as &#34;vantage point&#34; trees or vp-trees.  en.wikipedia.org/wiki/Vp-tree –  Edward KMETT</p><p>这些树也通常被称为“有利位置树”或“VP树”。En.wikipedia.org/wiki/vp-tree-爱德华·KMETT(Edward KMETT)。</p><p>    Not really a data structure; more of a way to optimize dynamically allocated arrays, but the  gap buffers used in Emacs are kind of cool.</p><p>不是真正的数据结构；更多的是一种优化动态分配数组的方式，但是Emacs中使用的间隙缓冲区是一种很酷的方式。</p><p>  For anyone interested, this is exactly how the Document (e.g. PlainDocument) models backing the Swing text components are implemented as well; before 1.2 I believe the document models were straight Arrays, which lead to horrible insertion performance for large documents; as soon as they moved to Gap Buffers, all was right with the world again. –  Riyad Kalla</p><p>对于任何感兴趣的人，这也正是支持Swing文本组件的文档(例如，PlainDocument)模型的实现方式；在1.2之前，我认为文档模型是直数组，这导致大型文档的插入性能非常糟糕；一旦它们转移到Gap Buffers，一切又都正常了。-里亚德·卡拉(Riyad Kalla)。</p><p>    Fenwick Tree. It&#39;s a data structure to keep count of the sum of all elements in a vector, between two given subindexes i and j. The trivial solution, precalculating the sum since the begining doesn&#39;t allow to update a item (you have to do O(n) work to keep up).</p><p>芬威克树。它是一种数据结构，用来计算向量中两个给定子索引i和j之间的所有元素的总和。平凡的解决方案是，从一开始就预先计算总和，不允许更新项目(你必须做O(N)次工作才能跟上)。</p><p> Fenwick Trees allow you to update and query in O(log n), and how it works is really cool and simple. It&#39;s really well explained in Fenwick&#39;s original paper, freely available here:</p><p>Fenwick树允许您在O(Logn)内更新和查询，并且它的工作方式非常酷和简单。芬威克的原创论文对此进行了很好的解释，可以在这里免费获得：</p><p>  Its father, the RQM tree is also</p><p>它的父亲，RQM树也是。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">https://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/鲜为人知/">#鲜为人知</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lesser/">#lesser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据结构/">#数据结构</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>