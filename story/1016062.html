<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go与Rust：编写CLI工具</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Go与Rust：编写CLI工具</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-04 08:08:15</div><div class="page_narrow text-break page_content"><p>本文讲述了我的冒险经历，使用两种我几乎没有经验的语言(两次)编写了一个小型CLI应用程序。</p><p>如果您急于直接跳到代码中并亲自进行比较，请查看Go源代码和Rust源代码。</p><p>我有一个很受欢迎的项目，叫做HashTrack，这是我为一次技术采访而编写的全栈Web应用程序。这个项目相当小，使用起来也很简单：</p><p>面试结束后，我一直在改进这个项目，只是为了好玩，我注意到它可能是一个通过实现CLI工具来测试我技能的完美地方。我已经有了服务器，所以我只需要选择一种语言来在我的项目的API下实现一小部分功能。</p><p>Hashtrace login-创建会话令牌，并将其存储在本地文件系统的配置文件中。</p><p>在这种情况下，我想要一种我以前几乎没有或没有经验的语言，我还想要一种可以轻松编译为本机可执行文件的语言，这是在CLI工具上拥有的好处。</p><p>出于某种原因，我的第一个显而易见的选择是走。但我对铁锈也没什么经验，我觉得它也很适合这个项目。</p><p>所以..。为什么不两者兼得呢？因为我在这里的主要目标是学习，这可能是一个很好的机会来实施这个项目两次，并从我的角度找出每一次的利弊。</p><p>尊敬的提到克里斯托和尼姆，这也是非常有希望的选择。我期待着在另一个令人喜爱的项目中了解它们。</p><p>在使用新工具集时，我首先考虑的是它是否有一种简单的方法可以让我的用户使用它，而无需使用分发包管理器在系统范围内安装它。我们谈论的是版本管理器，他们以用户范围而不是系统范围的方式安装工具，从而使我们的生活变得更容易。Node.js的NVM做得非常好。</p><p>使用GO时，有GVM工程处理本地安装和版本管理，安装简单：</p><p>我们还需要了解两个环境变量，它们是GOROOT和GOPATH--您可以在这里阅读有关它们的更多信息。</p><p>我使用GO发现的第一个问题是，当我弄清楚模块解决方案如何与GOPATH一起工作时，设置一个具有功能性本地开发环境的项目结构变得相当令人沮丧。</p><p>最后，我只是在我的项目目录中使用了GOPATH=$(Pwd)，主要的好处是有一个针对每个项目的依赖关系设置，比如node_module。它运行得很好。</p><p>在完成我的项目后，我发现VIRTALGO存在，并且可以用GOPATH解决我的问题。</p><p>Rust有一个名为Rustup的官方项目，该项目管理Rust安装，也称为工具链。使用一行程序可以很容易地设置它。此外，还有一组使用Rustup的可选组件，如RLS和rustfm.许多项目需要Rust工具链的夜间版本，Rustup在版本之间切换没有问题。</p><p>对于这两种语言，编辑器工具都是完美无缺的，作为一名VSCode用户，我可以在市场上找到Go和Rust的扩展。</p><p>Go没有包管理器，甚至没有官方注册表。相反，它的模块解析的工作方式是您可以从外部URL导入它们。</p><p>对于依赖项管理，Rust使用Cargo，它从crates.io下载并编译依赖项，crates.io是Rust包的官方注册中心。板条箱生态系统内的软件包也可以在docs.rs中找到它们的文档。</p><p>我的第一个目标是看看在HTTP上实现一个简单的GraphQLquery/突变有多容易。</p><p>对于Go语言，我发现了一些库，比如machinebox/GraphQL和shurCoL/GraphQL，第二个库使用strucesstructs来(取消)封送数据，这就是我坚持使用它的原因。</p><p>我使用了shurcoL/GraphQL的分支，因为我需要在客户端中设置Authorization头，更改在这个Pull请求中。</p><p>Type creationMutation struct{CreateSession struct{Token raphql.String}`raphql：&#34；createSession(email：$email，password：$password)&#34；`}type CreationPayload struct{email string password string}func(client*raphql.Client，payload CreationPayload)(string，error){var突变creationMutation变量：=map[string]interface{}{&#34；email&#34；：：raphql.String(payload.Password)，}err：=client.Mutate(context.Background()，&amp；arision，Variables)返回字符串(mumatation.CreateSession.Token)，err}。</p><p>在Rust中，我必须使用两个库来进行GraphQL调用。这是因为GraphQL_Client与协议无关，它只关注序列化和反序列化数据的代码生成。所以我需要第二个库(Reqwest)来处理HTTP请求。</p><p>结构；发布结构{发布令牌：字符串，}发布类型=CREATE_SESSION：：Variables；发布异步FN(Context：&amp；Context，Creation：Creation)-&gt；Result&lt；Session，api：：Error&gt；{let res=api：：Build_BASE_REQUEST(Context).json(&amp；CreateSession：：build_query(creation)).Send()。等着？.json：：&lt；Response&lt；create_session：：ResponseData&gt；&gt；()。等待？；匹配res.data{Some(Data)=&gt；OK(会话{Token：data.create_session.Token，})，_=&gt；Err(api：：Error(api：：get_error_message(res).to_string()))，}}。</p><p>Go和Rust的两个库都没有任何GraphQL viaWebSocket协议的实现。</p><p>事实上，Rust的GraphQL_Client支持订阅，但是因为它是协议不可知的，所以我不得不自己实现整个GraphQL WebSocket通信。</p><p>要在Go版本中使用WebSockets，应将库修改为支持该协议。因为我已经在用图书馆的叉子了，所以我不想这么做。取而代之的是，我使用了一个穷人观看新推文的方式，即每5秒请求一次API来检索它们，我并不以此为荣。</p><p>使用go，有go关键字来产生一个轻量级线程，也称为goroutine。相反，Rust通过调用Thread：：Scren使用操作系统线程。除此之外，这两种实现都使用通道在它们的线程之间传输对象。</p><p>在GO中，错误与任何其他值一样对待。在围棋中处理错误的常见方法是只检查它们是否存在。</p><p>Func(config*Config)(){Contents，Err：=json.MarshalIndent(config，&#34；&#34；，&#34；&#34；，&#34；&#34；)if err！=nil{return err}err=ioutil.WriteFile(config.path，content，0o644)if err！=nil{return err}return nil}。</p><p>Ruust具有结果&lt；T，E&gt；枚举，它可以封装表示成功的OK(T)或表示错误的Err(E)。它还有&lt；T&gt；枚举选项，带一些(T)或不带。如果你熟悉Haskell，你可能会认出这两种语言中的一种和可能的一种。</p><p>还有一个错误传播的句法甜点(The？运算符)，它从结果或选项结构中解析值，自动返回err(...)。或者当事情变坏的时候什么都不做。</p><p>Pub fn(&amp；mut self)-&gt；io：：result&lt；()&gt；{let json=serde_json：：to_string(&amp；self.content)？；let mut file=File：：create(&amp；self.path)？；file.write_all(json.as_bytes())}。</p><p>Pub fn(&amp；mut self)-&gt；io：：result&lt；()&gt；{let json=match serde_json：：to_string(&amp；self.content){OK(Json)=&gt；json，err(E)=&gt；return err(E)}；let mut file=Match File：：Create(&amp；self.path){OK(File)=&gt；file，er.。File.write_all(json.as_bytes())}。</p><p>以上三个特性的结合构成了我在一门语言中看到的最好的错误处理解决方案，既简单、完善，同时又可维护。</p><p>&gt；time go get hashtrace1，39s user 0，41s system 43%cpu 4,122 total&gt；time go build-o hashtrace hashtrace#first timego build-o hashtrace hashtrace 0，80s user 0，12s system 152%CPU 0,603 total&gt；time go build-o hashtrace hashtrace 0，19 s user 0，07。</p><p>&gt；Time Cargo Build编译libc v0.2.67编译cfg-if v0.1.10编译autocfg v1.0.0...。编译hashtrace v0.1.0(/home/Paulo/code/cuchi/hashtrace/cli-rust)已完成开发[未优化+调试信息]目标，共1M 44scargo版本363，80s用户17，05s系统365%cpu 1：44，09。</p><p>它编译了所有的依赖项，总共是214个模块。当我们再次运行它时，所有东西都已经编译好了，所以它会立即运行：</p><p>&gt；Time Cargo内部版本#Second Time Finded dev[未优化+调试信息]目标在0.08scargo内部版本0，07s用户0，03s系统104%CPU 0,094总计&gt；Time Cargo内部版本#进行了更改，编译hashtrace v0.1.0(/home/Paulo/code/cuchi/hashtrace/cli-rust)已完成3.15scargo内部版本3，01s用户0，01s中的开发[未优化+调试信息]目标</p><p>如您所见，Rust使用增量编译模型，该模型部分地重新编译模块依赖树，从更改的模块开始，直到它传播到它的依赖项。</p><p>如果您正在进行发布构建，则需要更长的时间，这是预期的，因为编译器在内部执行优化任务：</p><p>&gt；Time Cargo Build--发布编译libc v0.2.67编译cfg-if v0.1.10编译autocfg v1.0.0...。编译hashtrace v0.1.0(/home/Paulo/code/cuchi/hashtrace/cli-rust)完成了2M 42scargo版本中的[优化]目标版本--版本1067，72s用户16，95s系统667%CPU 2：42，45。</p><p>为了测量内存使用情况，我对每个版本使用了/usr/bin/time-v./hashtrace列表。Time-v显示了很多有趣的信息，但是我们在这里寻找的是进程的最大驻留集大小，也就是执行期间分配的物理内存的峰值。</p><p>对于{1..5}；中的n，执行/usr/bin/time-v/hashtrace list&gt；/dev/null 2&gt；&gt；time.log donegrep&#39；最大驻留集大小&#39；time.log。</p><p>最大驻留集大小(千字节)：13632最大驻留集大小(千字节)：14016最大驻留集大小(千字节)：14244最大驻留集大小(千字节)：13648最大驻留集大小(千字节)：14500。</p><p>最大驻留集大小(千字节)：9,840最大驻留集大小(千字节)：10068最大驻留集大小(千字节)：9,972最大驻留集大小(千字节)：10032最大驻留集大小(千字节)：10072。</p><p>Go有一个垃圾收集器，这是追踪未使用的堆内存并回收它的常用方法，而不是手动执行此操作。由于垃圾收集器是启发式算法的组合，因此总是需要权衡，通常是在性能和内存使用率之间进行权衡。</p><p>RUST内存模型具有所有权、借用和生存期等概念，不仅有助于保证内存安全，而且无需手动管理或垃圾回收器即可保证对程序堆内存的完全控制。</p><p>它们都是这项工作的非常好的工具。但当然，他们有不同的优先事项。一方面，我们可以选择保持软件开发的简单性、可维护性和可访问性。另一方面，我们有一种专注于稳健性、安全性和性能的语言。</p><p>把注意力放在简单上，有时会产生相反的效果(比如GOROOT和GOPATH)。</p><p>我仍然不太明白铁锈是如何生活的，如果你试图解决这个问题，它可能会变得相当令人沮丧。</p><p>从个人的角度来看，这两个都非常有趣，在C和C++的世界里都是一个很好的补充。它们提供了更广泛的应用程序，如Web服务，甚至前端Web框架，这要归功于WebAssembly：)。</p><p>如果您想要对这两种语言进行另一种比这更深入的比较，请从FastThan LIME查看这篇文章。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cuchi.me/posts/go-vs-rust">https://cuchi.me/posts/go-vs-rust</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/writing/">#writing</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1015967.html"><img src="http://img.diglog.com/img/2020/8/thumb_10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015967.html">铁锈1.45.2</a></div><span class="my_story_list_date">2020-8-4 2:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015886.html"><img src="http://img.diglog.com/img/2020/8/thumb_16bbcd1cab07a0bf56a5572d0af2777c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015886.html">C++：Bjarne Stroustrup关注分布式系统、类型安全和锈蚀</a></div><span class="my_story_list_date">2020-8-3 20:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015707.html"><img src="http://img.diglog.com/img/2020/8/thumb_cdb41c5ca2e82352bb03252c8034acdb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015707.html">Python在新语言受欢迎程度排名中超过Java，Rust跻身前20名</a></div><span class="my_story_list_date">2020-8-2 9:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1015706.html"><img src="http://img.diglog.com/img/2020/8/thumb_ffafaa979a0d827f9f20daa5316c78bc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1015706.html">蓝色战队之锈：什么是“记忆安全”，真的吗？</a></div><span class="my_story_list_date">2020-8-2 9:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>