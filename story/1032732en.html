<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Unix域套接字上的文件描述符传输</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Unix域套接字上的文件描述符传输</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 14:21:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/5ef2ea312d19aa1f2a1506f2e04253c4.png"><img src="http://img2.diglog.com/img/2020/11/5ef2ea312d19aa1f2a1506f2e04253c4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Yesterday, I read a  phenomenal paper on how disruption free release of services that speak different protocols and serve different types of requests (long lived TCP/UDP sessions, requests involving huge chunks of data etc.) works at Facebook.</p><p>昨天，我读了一篇现象级的论文，内容是如何无中断地发布使用不同协议并服务于不同类型的请求(长时间的TCP/UDP会话、涉及大量数据的请求等)的服务。在脸书工作。</p><p> One of the techniques used by Facebook is what they call “Socket Takeover”.</p><p>Facebook使用的技术之一是他们所说的“套接字接管”。</p><p> Socket Takeover enables Zero Downtime Restarts for Proxygen by spinning up an updated instance in parallel that takes over the listening sockets, whereas the old instance goes into graceful draining phase. The new instance assumes the responsibility of serving the new connections and responding to health-check probes from the L4LB Katran. Old connections are served by the older instance until the end of draining period, after which other mechanism (e.g.,Downstream Connection Reuse) kicks in.</p><p>套接字接管通过并行启动接管侦听套接字的更新实例来实现Proxygen的零停机重新启动，而旧实例则进入正常排出阶段。新实例承担服务新连接和响应来自L4LB Katran的运行状况检查探测的责任。旧连接由较旧的实例服务，直到排空周期结束，在此之后，其他机制(例如，下行连接重用)开始发挥作用。</p><p> As we pass an open FD from the old process to the newly spun one, both the passing and the receiving process share the same file table entry for the listening socket and handle separate accepted connections on which they serve connection level transactions. We leverage the following Linux kernel features to achieve this:</p><p>当我们将打开的FD从旧进程传递到新旋转的进程时，传递进程和接收进程共享侦听套接字的相同文件表项，并处理各自接受的连接，它们在这些连接上为连接级事务提供服务。我们利用以下Linux内核功能来实现这一点：</p><p> CMSG: A feature in   sendmsg() allows sending control messages between local processes (commonly referred to as ancillary data). During the restart of L7LB processes, we use this mechanism to send the set of FDs for all active listening socketsfor each VIP (Virtual IP of service) from the active instance to the newly spun instance. This data is exchanged using   sendmsg and   recvmsg over a UNIX domain socket.</p><p>CMSG：sendmsg()中的一个特性允许在本地进程之间发送控制消息(通常称为辅助数据)。在L7LB进程重启期间，我们使用此机制将每个VIP(服务的虚拟IP)的所有活动侦听套接字的FD集从活动实例发送到新旋转的实例。此数据通过UNIX域套接字使用sendmsg和recvmsg进行交换。</p><p> SCM_RIGHTS: We set this option to send open FDs with the data portion containing an integer array of the open FDs. On the receiving side, these FDs behave as though they have been created with dup(2).</p><p>SCM_RIGHTS：我们将此选项设置为发送开放式FD，其数据部分包含开放式FD的整数数组。在接收端，这些FD的行为就像它们是使用DUP(2)创建的一样。</p><p> I got a number of reponses on Twitter from folks expressing astonishment that this is even possible. Indeed, if you’re not very familiar with some of the features of Unix domain sockets, the aforementioned paragraph from the paper might be pretty inscrutable.</p><p>我在推特上收到了许多人的回复，他们对这一可能性表示惊讶。事实上，如果您不太熟悉Unix域套接字的一些特性，本文中的前述段落可能会让人费解。</p><p> Transfer ring TCP sockets over a Unix domain socket is, actually, a tried and tested method to implement “hot restarts” or “zero downtime restarts”. Popular proxies like  HAProxy and Envoy use very similar mechanisms to drain connections from one instance of the proxy to another without dropping any connections. However, many of these features are not very widely known.</p><p>Unix域套接字上的传输环TCP套接字实际上是实现“热重新启动”或“零停机重新启动”的一种久经考验的方法。流行的代理(如HAProxy和特使)使用非常类似的机制将连接从一个代理实例排出到另一个实例，而不会丢弃任何连接。然而，这些功能中的许多并不是非常广为人知的。</p><p> In this post, I want to explore some of the features of Unix domain sockets that make it a suitable candidate for several of these use-cases, especially transferring a socket (or  any file descriptor, for that matter) from one process to another where a parent-child relationship doesn’t necessarily exist between the two processes.</p><p>在这篇文章中，我想探讨Unix域套接字的一些特性，这些特性使其适合于其中几种用例，特别是在两个进程之间不一定存在父子关系的情况下，将套接字(或任何文件描述符)从一个进程传输到另一个进程。</p><p>  It’s commonly known that Unix domain sockets allow communication between processes on the same host system. Unix domain sockets are used in many popular systems: HAProxy, Envoy, AWS’s Firecracker virtual machine monitor, Kubernetes, Docker and Istio to name a few.</p><p>众所周知，Unix域套接字允许同一主机系统上的进程之间进行通信。UNIX域套接字用于许多流行的系统中：HAProxy、特使、AWS的Firecracker虚拟机监视器、Kubernetes、Docker和Istio等等。</p><p>  Like network sockets, Unix domain sockets support both  stream and  datagram socket types. However, unlike network sockets that take an  IP address and a  port as the address, a Unix domain socket address takes the form of a  pathname. Unlike network sockets, I/O across Unix domain sockets do not involve operations on the underlying  device (which makes Unix domain sockets a lot faster compared to network sockets for performing IPC on the same host).</p><p>与网络套接字一样，Unix域套接字支持流和数据报套接字类型。但是，与采用IP地址和端口作为地址的网络套接字不同，Unix域套接字地址采用路径名的形式。与网络套接字不同，Unix域套接字之间的I/O不涉及底层设备上的操作(这使得Unix域套接字比在同一主机上执行IPC的网络套接字快得多)。</p><p> Binding a name to a Unix domain socket with  bind(2 ) creates a socket file named  pathname in the filesystem. However, this file is different from any normal file you might create.</p><p>使用bind(2)将名称绑定到Unix域套接字将在文件系统中创建名为path name的套接字文件。但是，此文件不同于您可能创建的任何普通文件。</p><p> A simple Go program to create an “echo server” listening on a Unix domain socket would be the following:</p><p>创建监听Unix域套接字的“回显服务器”的简单GO程序如下所示：</p><p>  If you build and run this program, a couple of interesting facts can be observed.</p><p>如果您构建并运行此程序，可以观察到一些有趣的事实。</p><p>  First, the socket file  /tmp/uds.sock is marked as a  socket. When   stat() is applied to this pathname, it returns the value  S_IFSOCK in the file-type component of the   st_mode field of the   stat structure.</p><p>首先，套接字文件/tmp/uds.sock被标记为套接字。将stat()应用于此路径名时，它在stat结构的st_mode字段的file-type组件中返回值S_IFSOCK。</p><p> When listed with   ls –l, a UNIX domain socket is shown with the type   s in the first column, whereas an   ls –F appends an equal sign (=) to the socket pathname.</p><p>当使用ls-l列出时，UNIX域套接字在第一列显示类型为s，而ls-F在套接字路径名后附加等号(=)。</p><p> root@1fd53621847b:~/uds# ./uds ^C root@1fd53621847b:~/uds# ls -ls /tmp total 0 0  srwxr-xr-x 1 root root 0 Aug 5 01:45 uds.sock root@1fd53621847b:~/uds#  stat /tmp/uds.sock File: /tmp/uds.sock Size: 0 Blocks: 0 IO Block: 4096  socket Device: 71h/113d Inode: 1835567 Links: 1 Access: (0755/srwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2020-08-05 01:45:41.650709000 +0000 Modify: 2020-08-05 01:45:41.650709000 +0000 Change: 2020-08-05 01:45:41.650709000 +0000 Birth: - root@5247072fc542:~/uds# ls -F /tmp  uds.sock= root@5247072fc542:~/uds#</p><p>Root@1fd53621847b：~/uds#./udds^C root@1fd53621847b：~/uds#ls-ls/tmp总计0 0 srwxr-xr-x 1根根0 8月5 01：45 uds.sock root@1fd53621847b：~/udds#stat/tmp/uds.sock File：/tmp/uds.sock File：/tmp/uds.sock size：0 Block：0 IO Block：4096 Socket Device：71H/113D inode：1835567 link：1 access：(0755/srwxr-xr-x)uid：(0/root)gid：(0/root)。)访问：2020-08-05 01：45：41.650709000+0000修改：2020-08-05 01：45：41.650709000+0000更改：2020-08-05 01：45：41.650709000+0000出生：-ROOT@5247072fc542：~/uds#ls-F/tmp uds.sock=root@5247072fc542：~/uds#。</p><p> Normal system calls that work on files don’t work on socket files: this means that system calls like   open(), close(), read()  cannot be used on socket files. Instead, socket specific system calls like  socket(),  bind(),  recv(),  sendmsg(),  recvmsg() etc. are used to work with Unix domain sockets.</p><p>处理文件的正常系统调用不适用于套接字文件：这意味着诸如open()、close()、read()之类的系统调用不能用于套接字文件。相反，套接字特定的系统调用(如Socket()、bind()、recv()、sendmsg()、recvmsg()等)用于处理Unix域套接字。</p><p> Another interesting fact about the socket file is that it is removed not when the socket is closed but rather is closed by calling:</p><p>关于套接字文件的另一个有趣事实是，它不是在套接字关闭时删除的，而是通过调用以下命令来关闭的：</p><p>       The  SO_REUSEPORT option allows multiple network sockets on any given host to connect to the same address and the port. The very first socket to try to bind to the given port needs to set the  SO_REUSEPORT option, and any subsequent socket can bind to the same port.</p><p>SO_REUSEPORT选项允许任何给定主机上的多个网络套接字连接到相同的地址和端口。尝试绑定到给定端口的第一个套接字需要设置SO_REUSEPORT选项，并且任何后续套接字都可以绑定到同一端口。</p><p> Support for  SO_REUSEPORT was introduced in Linux 3.9 and above. However, on Linux, all sockets that want to share the same address and port combination must belong to processes that share the same effective UID.</p><p>Linux 3.9及更高版本中引入了对SO_REUSEPORT的支持。但是，在Linux上，希望共享相同地址和端口组合的所有套接字必须属于共享相同有效UID的进程。</p><p> int fd = socket(domain, socktype, 0); int optval = 1; setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, sizeof(optval)); bind(sfd, (struct sockaddr *) &amp;addr, addrlen);</p><p>Int fd=socket(domain，socktype，0)；int optval=1；setsockopt(SFD，SOL_SOCKET，SO_REUSEPORT，&amp；optval，sizeof(Optval))；bind(sfd，(struct sockaddr*)&amp；addr，addrlen)；</p><p> However, it’s not possible for two Unix domain sockets to bind to the same  path.</p><p>但是，两个Unix域套接字不可能绑定到同一路径。</p><p>  The  socketpair() function creates two sockets that are then connected together. In a manner of speaking, this is very similar to  pipe, except that it supports  bidirectional transfer of data.</p><p>函数的作用是：创建两个套接字，然后将它们连接在一起。从某种意义上说，这与PIPE非常相似，不同之处在于它支持双向数据传输。</p><p> socketpair only works with Unix domain sockets. It returns two file descriptors which are already connected to one another (so one doesn’t have to do the whole  socket → bind → listen → accept dance to set up a listening socket and a  socket → connect dance to create a client to the listening socket before beginning to transfer data!).</p><p>SocketPair仅适用于Unix域套接字。它返回两个已经彼此连接的文件描述符(因此，在开始传输数据之前，不必执行整个套接字→绑定→Listen→Accept舞蹈来设置侦听套接字，并执行套接字→连接舞蹈来创建侦听套接字的客户端！)。</p><p>  Now that we’ve established that a Unix domain socket allows communication between two processes on the same host, it’s time to explore  what kind of data can be transferred over a Unix domain socket.</p><p>既然我们已经确定Unix域套接字允许同一台主机上的两个进程之间进行通信，那么现在是时候探索可以通过Unix域套接字传输什么类型的数据了。</p><p> Since a Unix domain socket is similar to network sockets in many respects,  any data that one might usually send over a network socket can be sent over a Unix domain socket.</p><p>由于Unix域套接字在许多方面类似于网络套接字，因此通常通过网络套接字发送的任何数据都可以通过Unix域套接字发送。</p><p> Furthermore, the special system calls  sendmsg and  recvmsg allow sending a  special message across the Unix domain socket. This message is handled specially by the kernel, which allows passing open   file descriptions from the sender to the receiver.</p><p>此外，特殊的系统调用sendmsg和recvmsg允许跨Unix域套接字发送特殊消息。此消息由内核专门处理，允许将打开的文件描述从发送方传递到接收方。</p><p>  Note that I mentioned   file descripTION  and not    file descripTOR . The difference between the two is subtle and isn’t often well understood.</p><p>请注意，我提到的是文件描述，而不是文件描述符。这两者之间的区别是微妙的，通常并不是很好地理解。</p><p> A   file descriptor really is just a  per process pointer to an underlying kernel data structure called (confusingly) the   file description. The kernel maintains a table of all open   file descriptions called the   open file table. If two processes (A and B) try to open the same file, the two processes might have their own separate   file descriptors, which point to the same   file   description in the open file table.</p><p>文件描述符实际上只是一个指向底层内核数据结构的每个进程的指针，该数据结构称为(令人困惑的)文件描述。内核维护一个包含所有打开文件描述的表，称为打开文件表。如果两个进程(A和B)尝试打开同一文件，则这两个进程可能有各自单独的文件描述符，这些描述符指向打开的文件表中的相同文件描述。</p><p>  So “sending a file descriptor” from one Unix domain socket to another with  sendmsg() really just means sending a  reference to the file description. If process A were to send file descriptor 0 (fd0) to process B, the file descriptor might very well be referenced by the number 3 (fd3) in process B. They will, however, refer to the same  file description.</p><p>因此，使用sendmsg()从一个Unix域套接字向另一个Unix域套接字“发送文件描述符”实际上意味着发送对文件描述的引用。如果进程A向进程B发送文件描述符0(Fd0)，则该文件描述符很可能在进程B中由数字3(Fd3)引用。但是，它们将引用相同的文件描述。</p><p> The sending process calls  sendmsg to send the descriptor across the Unix domain socket. The receiving process calls  recvmsg to receive the descriptor on the Unix domain socket.</p><p>发送进程调用sendmsg通过Unix域套接字发送描述符。接收进程调用recvmsg来接收Unix域套接字上的描述符。</p><p> Even if the sending process closes its file descriptor referencing the file description being passed via  sendmsg before the receiving process calls  recvmsg, the file description remains open for the receiving process. Sending a descript or increments the descrip tion’s reference count by one. The kernel only removes file descriptions from its open file table if the reference count drops to 0.</p><p>即使发送进程在接收进程调用recvMsg之前关闭其引用通过sendMSG传递的文件描述的文件描述符，该文件描述对于接收进程也保持打开。发送描述或将描述的引用计数加1。如果引用计数降至0，则内核仅从其打开的文件表中删除文件描述。</p><p>      The special “message” that one can transfer with  sendmsg over a Unix domain socket is specified by the  msghdr . The process which wishes to send the file description over to another process creates a  msghdr structure containing the description to be passed.</p><p>可以使用sendmsg在Unix域套接字上传输的特殊“消息”由msghdr指定。希望将文件描述发送到另一个进程的进程创建包含要传递的描述的MSGHDR结构。</p><p> struct msghdr {  void *msg_name; /* optional address */  socklen_t msg_namelen; /* size of address */  struct  iovec *msg_iov; /* scatter/gather array */  int msg_iovlen; /* # elements in msg_iov */  void  *msg_control; /* ancillary data, see below */  socklen_t  msg_controllen; /* ancillary data buffer len */  int msg_flags; /* flags on received message */ };</p><p>Struct msghdr{void*msg_name；/*可选地址*/socklen_t msg_namelen；/*地址大小*/struct iovec*msg_IOV；/*散布/聚集数组*/int msg_iovlen；/*#msg_iov中的元素*/void*msg_control；/*辅助数据见下文*/socklen_t msg_control len；/*辅助数据缓冲区*/int msg_flag；/*接收消息的标志*/}；</p><p> The  msg_control member of the  msghdr structure, which has length  msg _controllen, points to a buffer of messages of the form:</p><p>Msghdr结构的msg_control成员的长度为msg_control len，它指向以下形式的消息缓冲区：</p><p> struct cmsghdr {  socklen_t cmsg_len; /* data byte count, including header */  int cmsg_level; /* originating protocol */  int cmsg_type; /* protocol-specific type */  /* followed by */  unsigned char  cmsg_data[]; };</p><p>Struct cmsghdr{socklen_t cmsg_len；/*数据字节数，包头*/int cmsg_level；/*发起协议*/int cmsg_type；/*协议具体类型*//*后跟*/unsign char cmsg_data[]；}；</p><p> In POSIX, a buffer of   struct cmsghdr structures  with appended data is called  ancillary data. On Linux, the maximum buffer size allowed per socket can be set by modifying   /proc/sys/net/core/optmem_max .</p><p>在POSIX中，带有附加数据的struct cmsghdr结构的缓冲区称为辅助数据。在Linux上，可以通过修改/proc/sys/net/core/optmem_max来设置每个套接字允许的最大缓冲区大小。</p><p>  While there are a plethora of gotchas with such data transfer, when used correctly, it can be a pretty powerful mechanism to achieve a number of goals.</p><p>虽然这样的数据传输有太多的问题，但如果使用得当，它可以成为实现许多目标的一种非常强大的机制。</p><p> On Linux, there are three such types of “ancillary data” that can be shared between two Unix domain sockets:</p><p>在Linux上，有三种类型的“辅助数据”可以在两个Unix域套接字之间共享：</p><p>  All three forms of ancillary data should  only be accessed using the macros described below and never directly.</p><p>所有三种形式的辅助数据都只能使用下面描述的宏来访问，并且绝对不能直接访问。</p><p> struct cmsghdr *CMSG_FIRSTHDR(struct msghdr * msgh ); struct cmsghdr *CMSG_NXTHDR(struct msghdr * msgh , struct cmsghdr * cmsg ); size_t CMSG_ALIGN(size_t  length ); size_t CMSG_SPACE(size_t  length ); size_t CMSG_LEN(size_t  length ); unsigned char *CMSG_DATA(struct cmsghdr * cmsg );</p><p>Struct cmsghdr*CMSG_FIRSTHDR(struct msghdr*msgh)；struct cmsghdr*CMSG_NXTHDR(struct msghdr*msgh，struct cmsghdr*cmsg)；size_t CMSG_ALIGN(Size_T Length)；size_t CMSG_space(Size_T Length)；size_t CMSG_LEN(Size_T Length)；unsign char*CMSG_data(struct cmsghdr*cmsg)；</p><p> While I’ve never had a need to use the latter two,  SCM_RIGHTS is what I hope to explore more in this post.</p><p>虽然我从来不需要使用后两者，但SCM_RIGHT是我希望在这篇文章中更多地探讨的内容。</p><p>  SCM_RIGHTS allows a process to send or receive a set of open file descriptors from another process using  sendmsg.</p><p>Scm_right允许一个进程使用sendmsg从另一个进程发送或接收一组打开的文件描述符。</p><p> The  cmsg_data component of the  cmsghdr structure  can  contain an array of the file descriptors that a process wants to send to another.</p><p>Cmsghdr结构的cmsg_data组件可以包含一个进程想要发送给另一个进程的文件描述符的数组。</p><p> struct cmsghdr {  socklen_t cmsg_len; /* data byte count, including header */  int cmsg_level; /* originating protocol */  int cmsg_type; /* protocol-specific type */  /* followed by */  unsigned char  cmsg_data[]; };</p><p>Struct cmsghdr{socklen_t cmsg_len；/*数据字节数，包头*/int cmsg_level；/*发起协议*/int cmsg_type；/*协议具体类型*//*后跟*/unsign char cmsg_data[]；}；</p><p>  The book The Linux Programming Interface has a  good programmatic guide on how to use the  sendmsg and  recvmsg.</p><p>“Linux编程接口”一书对如何使用sendmsg和recvmsg有一个很好的编程指南。</p><p>  As mentioned, there are a number of gotchas when trying to pass ancillary data over Unix domain sockets.</p><p>如前所述，当尝试通过Unix域套接字传递辅助数据时，有许多问题。</p><p>  On Linux, at least one byte of “real data” is required to successfully send ancillary data over a Unix domain  stream socket.</p><p>在Linux上，至少需要一个字节的“真实数据”才能通过Unix域流套接字成功发送辅助数据。</p><p> However, when sending ancillary data over a Unix domain  datagram socket on Linux, it is not necessary to send any accompanying real data. That said, portable applications should also include at least one byte of real data when sending ancillary data over a datagram socket.</p><p>但是，在Linux上通过Unix域数据报套接字发送辅助数据时，不需要发送任何附带的实际数据。也就是说，当通过数据报套接字发送辅助数据时，便携式应用程序还应该包括至少一个字节的实际数据。</p><p>  If the buffer  cmsg_data used to receive the ancillary data containing the file descriptors is too small (or is absent), then the ancillary data is truncated (or discarded) and the excess file descriptors are automatically closed in the receiving process.</p><p>如果用于接收包含文件描述符的辅助数据的缓冲区cmsg_data太小(或不存在)，则辅助数据被截断(或丢弃)，并且在接收过程中自动关闭多余的文件描述符。</p><p> If the number of file descriptors received in the ancillary data cause the process to exceed its  RLIMIT_NOFILE resource limit, the excess file descriptors are automatically closed in the receiving process. One cannot split the list over multiple  recvmsg calls.</p><p>如果在辅助数据中接收的文件描述符的数量导致进程超过其RLIMIT_NOFILE资源限制，则在接收进程中会自动关闭多余的文件描述符。不能在多个recvmsg调用上拆分该列表。</p><p>  sendmsg and  recvmsg act similar to  send and  recv system calls, in that there isn’t a 1:1 mapping between every  send call and every  recv call.</p><p>Sendmsg和recvmsg的行为类似于send和recv系统调用，因为在每个send调用和每个recv调用之间不存在1：1的映射。</p><p> A single  recvmsg call can read data from  multiple  sendmsg calls. Likewise, it can take  multiple  recvmsg calls to consume the data sent over a single  sendmsg call. This has serious and surprising implications, some of which have been reported  here.</p><p>单个RecvMSG调用可以从多个SendMSG调用读取数据。同样，可能需要多个recvmsg调用才能使用通过单个sendmsg调用发送的数据。这具有严重而令人惊讶的影响，其中一些已经在这里报道过。</p><p>  The kernel constant  SCM_MAX_FD ( 253 (or 255 in kernels before 2.6.38)) defines a limit on the number of file descriptors in the array.</p><p>内核常量SCM_MAX_FD(253(在2.6.38之前的内核中为255))定义了数组中文件描述符的数量限制。</p><p> Attempting to send an array larger than this limit causes  sendmsg to fail with the error  EINVAL.</p><p>尝试发送大于此限制的数组会导致sendmsg失败，并显示错误EINVAL。</p><p>  A very concrete real world use case where this is used is zero downtime proxy reloads.</p><p>使用此功能的一个非常具体的实际用例是零停机代理重新加载。</p><p> Anyone who’s ever had to work with HAProxy can attest that “zero downtime config reloads” wasn’t really a thing for a long time. Often, a plethora of  Rube Goldberg-esque hacks were used to achieve this.</p><p>任何曾经使用过HAProxy的人都可以证明，“零停机时间配置重新加载”在很长一段时间内都不是真正意义上的事情。通常，过多的Rube Goldberg风格的黑客就是用来实现这一点的。</p><p> In late 2017,  HAProxy 1.8 shipped with support for hitless reloads achieved by transferring the listening socket file descriptors from the old HAProxy process to the new one. Envoy  uses a similar mechanism for hot restarts where file descriptors are passed over a Unix domain socket.</p><p>在2017年末，HAProxy 1.8发布时支持通过将侦听套接字文件描述符从旧的HAProxy进程转移到新的进程来实现无中断重新加载。特使使用类似的机制进行热重新启动，其中文件描述符通过Unix域套接字传递。</p><p> In late 2018, Cloudflare  blogged about its use of transferring file descriptors from nginx to a Go TLS 1.3 proxy.</p><p>在2018年末，Cloudflare在博客中介绍了它将文件描述符从nginx传输到Go TLS 1.3代理的情况。</p><p> The paper on how Facebook achieves zero downtime releases that prompted me to write this entire blog post uses the selfsame CMSG + SCM_RIGHTS trick to pass live file descriptors from the draining process to the newly released process.</p><p>这篇关于Facebook如何实现零停机释放的文章促使我撰写了整篇博客文章，它使用了selfame CMSG+SCM_RIGHT技巧，将实时文件描述符从排出进程传递到新发布的进程。</p><p>  Transferring file descriptors over a Unix domain socket can prove to be very powerful if used correctly. I hope this post gave you a slightly better understanding of Unix domain sockets and features it enables.</p><p>如果使用得当，可以证明通过Unix域套接字传输文件描述符非常有效。我希望这篇文章能让你对Unix域套接字及其支持的特性有一个更好的理解。</p><p>  LWN.net has an interesting article on creating cycles when passing file descriptions over a Unix domain socket and implications for the fabulous new io_uring kernel API.  https://lwn.net/Articles/779472/</p><p>LWN.net有一篇有趣的文章，介绍了在Unix域套接字上传递文件描述时创建循环，以及对新的令人难以置信的io_uring内核API的影响。Https://lwn.net/Articles/779472/</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec">https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/描述符/">#描述符</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进程/">#进程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>