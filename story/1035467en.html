<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SwiftNIO SSHSwiftNIO SSH</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SwiftNIO SSH<br/>SwiftNIO SSH</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 12:03:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/e7117e2db671fcdebcea09e106639103.png"><img src="http://img2.diglog.com/img/2020/11/e7117e2db671fcdebcea09e106639103.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I am delighted to introduce a new open source project for the Swift Server ecosystem,  SwiftNIO SSH. Distributed as a Swift package, SwiftNIO SSH is designed to enable Swift developers to interact with the SSH network protocol.</p><p>我很高兴为Swift Server生态系统引入一个新的开源项目SwiftNIO SSH。 SwiftNIO SSH作为Swift软件包分发，旨在使Swift开发人员能够与SSH网络协议进行交互。</p><p>  SwiftNIO SSH is a programmatic implementation of SSH: that is, it is a collection of APIs that allow programmers to implement SSH-speaking endpoints. Critically, this means it is more like libssh2 than openssh. SwiftNIO SSH does not ship production-ready SSH clients and servers, but instead provides the building blocks for building this kind of client and server.</p><p>SwiftNIO SSH是SSH的程序化实现：即，它是API的集合，允许程序员实现讲SSH的终结点。至关重要的是，这意味着它比libssh更像libssh2。 SwiftNIO SSH不会交付可用于生产环境的SSH客户端和服务器，而是提供了构建此类客户端和服务器的构件。</p><p> There are a number of reasons to provide a programmatic SSH implementation. One is that SSH has a unique relationship to user interactivity. Technical users are highly accustomed to interacting with SSH interactively, either to run commands on remote machines or to run interactive shells. Having the ability to programmatically respond to these requests enables interesting alternative modes of interaction. As prior art, we can point to Twisted’s  Manhole, which uses  a programmatic SSH implementation called  conch to provide an interactive Python interpreter within a running Python server, or  ssh-chat, a SSH server that provides a chat room instead of regular SSH shell functionality. Innovative uses can also be imagined for TCP forwarding.</p><p>提供编程SSH实现有多种原因。一个是SSH与用户交互性具有独特的关系。技术用户非常习惯于与SSH进行交互，以在远程计算机上运行命令或运行交互式Shell。能够以编程方式响应这些请求的功能可以实现有趣的交互方式。作为现有技术，我们可以指向Twisted的Manhole，它使用称为chench的编程SSH实现在运行中的Python服务器或ssh-chat（提供聊天室而不是常规SSH shell功能的SSH服务器）内提供交互式Python解释器。 。对于TCP转发，也可以想象创新的用途。</p><p> Another good reason to provide programmatic SSH is that it is not uncommon for services to need to interact with other services in a way that involves running commands. While  Process solves this for the local use-case, sometimes the commands that need to be invoked are remote. While  Process could launch an  ssh client as a sub-process in order to run this invocation, it can be substantially more straightforward to simply invoke SSH directly. This is   libssh2’s target use-case. SwiftNIO SSH provides the equivalent of the networking and cryptographic layer of libssh2, allowing motivated users to drive SSH sessions directly from within Swift services.</p><p>提供编程SSH的另一个很好的理由是，服务需要以一种涉及运行命令的方式与其他服务进行交互的情况并不少见。尽管Process为本地用例解决了此问题，但有时需要调用的命令是远程的。虽然Process可以将ssh客户端作为子进程启动以运行此调用，但直接直接调用SSH可能要简单得多。这是libssh2的目标用例。 SwiftNIO SSH提供了与libssh2的网络和加密层相同的功能，使有动力的用户可以直接从Swift服务内部驱动SSH会话。</p><p>   Modern cryptographic primitives only: Ed25519 and EDCSA over the major NIST curves (P256, P384, P521) for asymmetric cryptography, AES-GCM for symmetric cryptography, x25519 for key exchange</p><p>仅限现代密码原语：非对称密码在主要NIST曲线（P256，P384，P521）上的Ed25519和EDCSA，对称密码用于AES-GCM，密钥交换用于x25519</p><p>  SwiftNIO SSH provides a SwiftNIO  ChannelHandler,  NIOSSHHandler. This handler implements the bulk of the SSH protocol. Users are not expected to generate SSH messages directly: instead, they interact with the  NIOSSHHandler through child channels and delegates.</p><p>SwiftNIO SSH提供了一个SwiftNIO ChannelHandler NIOSSHHandler。该处理程序实现了大部分SSH协议。不应期望用户直接生成SSH消息：相反，他们通过子通道和委托与NIOSSHHandler进行交互。</p><p> SSH is a multiplexed protocol: each SSH connection is subdivided into multiple bidirectional communication channels called, appropriately enough, channels. SwiftNIO SSH reflects this construction by using a “child channel” abstraction. When a peer creates a new SSH channel, SwiftNIO SSH will create a new NIO  Channel that is used to represent all traffic on that SSH channel. Within this child  Channel all events are strictly ordered with respect to one another: however, events in different  Channels may be interleaved freely by the implementation.</p><p>SSH是一个多路复用协议：每个SSH连接都细分为多个双向通信通道，这些通道称为适当的通道。 SwiftNIO SSH通过使用“子通道”抽象来反映这种构造。当对等方创建新的SSH通道时，SwiftNIO SSH将创建一个新的NIO通道，该通道用于表示该SSH通道上的所有流量。在此子Channel内，所有事件都严格按照彼此进行排序：但是，实现中可以自由地交错不同Channel中的事件。</p><p>  ┌ ─ NIO Channel ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐│ ┌───────────────────────────┐ │ │ ││ │ │ │ │ ││ │ │ │ │ NIOSSHHandler │──────────────────────┐│ │ │ │ │ │ │ ││ │ │ │ │ │ │ ││ └───────────────────────────┘ │ │ │└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘ │ │ │ │ │ ▼ ┌── SSH Child Channel ────────────────────────────────────────────────────┐ │ │ │ ┌───────────────────────────┐ ┌────────────────────────────┐ ├───┐ │ │ │ │ │ │ │ │ │ │ │ │ │ ├───┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ User Handler │ │ User Handler │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └───────────────────────────┘ └────────────────────────────┘ │ │ │ │ │ │ │ └───┬─────────────────────────────────────────────────────────────────────┘ │ │ │ │ │ └───┬─────────────────────────────────────────────────────────────────────┘ │ │ │ └─────────────────────────────────────────────────────────────────────────┘</p><p>IO──NIO频道─────────────IO│┌─────────────────────┐││││││ │││││││││NIOSSHHandler│────────────────┐│││││││││││││││││ │└──────────────────┘│││└──────────────────────── ──┘│││││▼┌──SSH子频道──────────────────────────── ────────────────┐│││┌─────────────┐ ────────────────────────────────────────││││││││││││││├ ─│││││││││││││││││││││││││││││││││││││││ ││││││││││││││└─────────────────┘ ──────────────────┘│││││││┘───┬────────────── ────────────────────────────────────────────────── ────┘│││││└───┬────────────────────── ────────────────────┘│││└────────── ────────────────────────────────────────────────── ──────────┘</p><p> An SSH channel is invoked with a channel type. SwiftNIO SSH supports three:  session,  directTCPIP, and  forwardedTCPIP. The most common channel type is  session, which is used to represent the invocation of a program, whether a specific named program or a shell. The other two channel types are related to TCP port forwarding, and will be discussed later.</p><p>使用通道类型调用SSH通道。 SwiftNIO SSH支持三种：会话，directTCPIP和转发的TCPIP。最常见的通道类型是会话，用于表示程序的调用，无论是特定的命名程序还是外壳程序。其他两种通道类型与TCP端口转发有关，将在后面讨论。</p><p> An SSH channel operates on a single data type:  SSHChannelData. This structure encapsulates the fact that SSH supports both regular and “extended” channel data. The regular channel data ( SSHChannelData.DataType.channel) is used for the vast majority of core data. In  session channels the  .channel data type is used for standard input and standard output: the  .stdErr data type is used for standard error. In TCP forwarding channels, the  .channel data type is the only kind used, and represents the forwarded data.</p><p>SSH通道对单一数据类型进行操作：SSHChannelData。这种结构封装了SSH支持常规和“扩展”通道数据的事实。常规通道数据（SSHChannelData.DataType.channel）用于绝大多数核心数据。在会话通道中，.channel数据类型用于标准输入和标准输出：.stdErr数据类型用于标准错误。在TCP转发通道中，.channel数据类型是唯一使用的类型，它表示转发的数据。</p><p>  A  session channel represents an invocation of a command. Exactly how the channel operates is communicated in a number of inbound user events. SwiftNIO SSH supports a wide range, and it covers the most important use-cases, including executing a command directly, requesting a shell, requesting a pseudo terminal, setting environment variables, and more.</p><p>会话通道代表命令的调用。在许多入站用户事件中传达了通道的确切运行方式。 SwiftNIO SSH支持范围广泛，涵盖了最重要的用例，包括直接执行命令，请求外壳程序，请求伪终端，设置环境变量等等。</p><p>  User authentication is a vital part of SSH. SwiftNIO SSH manages user authentication via a series of delegate protocols. These protocols are fully asynchronous, supporting use-cases that may need to read from disk in order to perform user authentication.</p><p>用户身份验证是SSH的重要组成部分。 SwiftNIO SSH通过一系列委托协议管理用户身份验证。这些协议是完全异步的，支持用例可能需要从磁盘读取以执行用户身份验证。</p><p>  Direct port forwarding is port forwarding from client to server. In this mode traditionally the client will listen on a local port, and will forward inbound connections to the server. It will ask that the server forward these connections as outbound connections to a specific host and port.</p><p>直接端口转发是从客户端到服务器的端口转发。传统上，此模式下，客户端将在本地端口上侦听，并将入站连接转发到服务器。它将要求服务器将这些连接作为出站连接转发到特定的主机和端口。</p><p>   Remote port forwarding is a less-common situation where the client asks the server to listen on a specific address and port, and to forward all inbound connections to the client. As the client needs to request this behaviour, it does so using “global requests”, an SSH feature that enables requesting features that operate at a connection-scope.</p><p>远程端口转发是一种不太常见的情况，客户端要求服务器侦听特定的地址和端口，并将所有入站连接转发给客户端。当客户端需要请求此行为时，它使用“全局请求”来执行此操作，这是一种SSH功能，可启用在连接范围内运行的请求功能。</p><p> Global requests are initiated using  NIOSSHHandler.sendGlobalRequest, and are received and handled by way of a  GlobalRequestDelegate. There are two global requests supported today:</p><p>全局请求是使用NIOSSHHandler.sendGlobalRequest发起的，并通过GlobalRequestDelegate进行接收和处理。今天支持两个全局请求：</p><p>  Servers may be notified of and respond to these requests using a  GlobalRequestDelegate. This delegate will be invoked any time a global request is received. Once a listener is established, inbound connections are then sent from server to client using the  .forwardedTCPIP channel type.</p><p>可以使用GlobalRequestDelegate通知服务器并响应这些请求。每当接收到全局请求时，都会调用该委托。一旦建立了侦听器，然后使用.forwardedTCPIP通道类型将入站连接从服务器发送到客户端。</p><p>    This project is currently in a pre-release state. While it’s considered to be feature complete, we’d like to give it some more time to bake in the public eye before we tag a 1.0 release. However, we do not expect any API breakage between now and that release.</p><p>该项目当前处于预发布状态。虽然它被认为是功能完善的，但在标记1.0版本之前，我们希望给它更多的时间来引起公众的注意。但是，我们预计从现在到该版本之间不会有API损坏。</p><p>  If you are interested in SwiftNIO SSH, please get involved! SwiftNIO SSH is a fully open-source project, developed on  GitHub. Contributions from the open source community are welcome at all times. We encourage discussion on the  Swift forums. For bug reports, feature requests, and pull requests, please use the GitHub repository.</p><p>如果您对SwiftNIO SSH感兴趣，请参与！ SwiftNIO SSH是在GitHub上开发的完全开源项目。任何时候都欢迎来自开源社区的贡献。我们鼓励在Swift论坛上进行讨论。对于错误报告，功能请求和提取请求，请使用GitHub存储库。</p><p> We’re very excited to see what amazing things you do with SwiftNIO SSH!</p><p>我们很高兴看到您使用SwiftNIO SSH所做的惊人的事情！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://swift.org/blog/swiftnio-ssh/">https://swift.org/blog/swiftnio-ssh/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swiftnio/">#swiftnio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ssh/">#ssh</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>