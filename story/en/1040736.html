<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Shopify如何在浏览器之外使用WebAssembly How Shopify Uses WebAssembly Outside of the Browser</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Shopify Uses WebAssembly Outside of the Browser<br/>Shopify如何在浏览器之外使用WebAssembly </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-19 23:44:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/bf37f7ffae82da2c5a5222bdc950902d.jpg"><img src="http://img2.diglog.com/img/2020/12/bf37f7ffae82da2c5a5222bdc950902d.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At Shopify we aim to make what most merchants need easy, and the rest possible. We make the rest possible by exposing interfaces to query, extend and alter our Platform. These interfaces empower a rich ecosystem of Partners to solve a variety of problems. The primary mechanism of this ecosystem is an “App”, an independently hosted web service which communicates with Shopify over the network. This model is powerful, but comes with a host of technical issues. Partners are stretched beyond their available resources as they have to build a web service that can operate at Shopify’s scale. Even if Partners’ resources were unlimited, the network latency incurred when communicating with Shopify precludes the use of Apps for time sensitive use cases.</p><p>在Shopify，我们的目标是使大多数商人所需的一切变得容易，而其余的则变为可能。我们通过公开接口来查询，扩展和更改我们的平台，从而使剩下的一切成为可能。这些界面使合作伙伴的丰富生态系统能够解决各种问题。该生态系统的主要机制是“应用程序”，这是一个独立托管的Web服务，可通过网络与Shopify通信。该模型功能强大，但存在许多技术问题。合作伙伴无法提供可用的资源，因为他们必须构建可以在Shopify规模上运行的网络服务。即使合作伙伴的资源是无限的，与Shopify进行通信时所产生的网络延迟也不能将Apps用于时间敏感的用例。</p><p> We want Partners to focus on using their domain knowledge to solve problems, and not on managing scalable web services. To make this a reality we’re keeping the flexibility of untrusted Partner code, but executing it on our own infrastructure. We choose a universal format for that code that ensures it’s performant, secure, and flexible: WebAssembly.</p><p> 我们希望合作伙伴专注于利用他们的领域知识来解决问题，而不是管理可伸缩的Web服务。为了实现这一点，我们保留了不受信任的合作伙伴代码的灵活性，但要在我们自己的基础架构上执行它。我们为该代码选择一种通用格式，以确保其性能，安全性和灵活性：WebAssembly。</p><p>   “WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.”</p><p>   “ WebAssembly（缩写为Wasm）是用于基于堆栈的虚拟机的二进制指令格式。 Wasm被设计为编程语言的可移植编译目标，从而可以在Web上为客户端和服务器应用程序进行部署。”</p><p> To learn more, see this series of  illustrated articles written by Lin Clark of Mozilla with information on WebAssembly and its history.</p><p> 要了解更多信息，请参阅Mozilla的Lin Clark撰写的带插图的系列文章，其中包含有关WebAssembly及其历史的信息。</p><p> Wasm is often presented as a performant language that runs alongside JavaScript from within the Browser. We, however, execute Wasm outside of the browser and with no Javascript involved. Wasm, far from being solely a Javascript replacement, is designed for  Web and Non-Web Embeddings alike. It solves the more general problem of performant execution in untrusted environments, which exists in browsers and code execution engines alike. Wasm satisfies our three main technical requirements: security, performance, and flexibility.</p><p> Wasm通常被表示为一种性能语言，它与浏览器中的JavaScript一起运行。但是，我们在浏览器外部执行Wasm，并且不涉及Javascript。 Wasm不仅是Java脚本的替代品，还为Web和非Web嵌入而设计。它解决了在不受信任的环境中执行程序执行的更普遍的问题，该问题存在于浏览器和代码执行引擎中。 Wasm满足我们的三个主要技术要求：安全性，性能和灵活性。</p><p>  Executing untrusted code is a dangerous thing—it&#39;s exceptionally difficult to predict by nature, and it has potential to cause harm to Shopify’s platform at large. While no application is entirely secure, we need to both prevent security flaws and mitigate their impacts when they occur.</p><p>  执行不受信任的代码是很危险的事情-本质上很难预测，并且有可能对Shopify的整个平台造成损害。尽管没有一种应用程序是完全安全的，但我们既需要防止安全漏洞，又要在发生安全漏洞时减轻其影响。</p><p> Wasm executes within a sandboxed stack-based environment, relying upon explicit imports to allow communication with the host. Because of this, you cannot  express anything malicious in Wasm. You can only express manipulations of the virtual environment and use provided imports. This differs from bytecodes which have references to the computers or operating systems they expect to run on built right into the syntax.</p><p> Wasm在基于沙盒的堆栈环境中执行，依赖于显式导入来允许与主机进行通信。因此，您无法在Wasm中表达任何恶意内容。您只能表达对虚拟环境的操纵并使用提供的导入。这与字节码不同，字节码引用了它们希望直接在语法中运行的计算机或操作系统。 </p><p> Wasm also hosts a number of features which protect the user from buggy code, including protected call stacks and runtime type checking.  More details on the security model of Wasm can be found on WebAssembly.org.</p><p>Wasm还具有许多保护用户免受错误代码攻击的功能，包括受保护的调用堆栈和运行时类型检查。有关Wasm安全模型的更多详细信息，请访问WebAssembly.org。</p><p>  In ecommerce, speed is a competitive advantage that merchants need to drive sales. If a feature we deliver to merchants doesn’t come with the right tradeoff of load times to customization value, then we may as well not deliver it at all.</p><p>  在电子商务中，速度是商家推动销售所需要的竞争优势。如果我们交付给商家的功能没有正确地将加载时间权衡为定制价值，那么我们也可能根本不交付该功能。</p><p> Wasm is designed to leverage common hardware capabilities that provide it near native performance on a wide variety of platforms. It’s used by a community of performance driven developers looking to optimize browser execution. As a result, Wasm and surrounding tooling was built, and continues to be built, with a performance focus.</p><p> Wasm旨在利用常见的硬件功能，在各种平台上提供接近本机的性能。寻求性能最佳化的浏览器开发人员社区可以使用它。结果，建立了Wasm和周围的工具，并将继续以性能为重点。</p><p>  A code execution service is only as useful as the developers using it are productive. This means providing first class development experiences in multiple languages they’re familiar with. As a bytecode format, Wasm is targeted by a number of different compilers. This allows us to support multiple languages for developer use without altering the underlying execution model.</p><p>  代码执行服务仅与使用它的开发人员富有成效的一样有用。这意味着以他们熟悉的多种语言提供一流的开发经验。作为字节码格式，Wasm是许多不同编译器的目标。这使我们能够支持多种语言供开发人员使用，而无需更改基础执行模型。</p><p>  We have a fundamental alignment in goals and design, which provides our “engineering reason” for using Wasm. But there’s more to it than that—it’s about the people as well as the technology. If nobody was working on the Wasm ecosystem, or even if it was just on life support in its current state,  we wouldn’t use it. WebAssembly is an energized community that’s constantly building new things and has a lot of potential left to reach. By becoming a part of that community, Shopify stands to gain significantly from that enthusiasm.</p><p>  我们在目标和设计上有着根本的一致性，这提供了使用Wasm的“工程理由”。不仅如此，它还有更多的意义-与人员和技术有关。如果没有人在Wasm生态系统上工作，或者即使只是在当前状态下依靠生命支持，我们也不会使用它。 WebAssembly是一个充满活力的社区，它不断在开发新事物，并且还有很多潜力可挖掘。通过成为该社区的一部分，Shopify将从这种热情中显着受益。</p><p> We’re also contributing to that enthusiasm ourselves. We’re collecting user feedback, discussing feature gaps, and most importantly contributing to the open source tools we depend on. We think this is the start of a healthy reciprocal relationship between ourselves and the WebAssembly community, and we expect to expand these efforts in the future.</p><p> 我们也为自己的热情做出了贡献。我们正在收集用户反馈，讨论功能差距，最重要的是为我们依赖的开源工具做出了贡献。我们认为这是我们与WebAssembly社区之间建立健康互惠关系的开始，并且我们希望在将来扩大这些努力。</p><p>  Now that we’ve covered WebAssembly and why we’re using it, let’s move onto how we’re executing it.</p><p>  既然我们已经介绍了WebAssembly以及为什么要使用它，让我们继续执行它。 </p><p> We use an open source tool called  Lucet (originally written by Fastly). As a company, Fastly provides a programmable edge cloud platform. They’re trying to bring execution of high-volume, short-lived, and untrusted modules closer to where they’re being requested. This is the same as the problem we’re trying to solve with our Partner code, so it’s a natural fit to be using the same tools.</p><p>我们使用一种称为Lucet的开源工具（最初由Fastly编写）。作为一家公司，Fastly提供了一个可编程的边缘云平台。他们正试图使高容量，寿命短且不受信任的模块的执行更接近要求的位置。这与我们尝试使用合作伙伴代码解决的问题相同，因此使用相同的工具自然是合适的。</p><p>  Lucet is both a runtime and a compiler for Wasm. Modules are represented in Wasm for the safety that representation provides. Recall that you can’t  express anything malicious in Wasm. Lucet takes advantage of this and uses a validation of the Wasm module as a security check. After the validation, the module is compiled to an executable artifact with near bare metal performance. It also supports ahead of time compilation, allowing us to have these artifacts ready to execute at runtime. Lucet containers boast an impressive startup time of  35   μs. That’s because it’s a container that doesn’t need to do anything at all to start up.  If you want the full picture, Tyler McMullan, the CTO of Fastly, did a great talk which  gives an overview of Lucet and how it works.</p><p>  Lucet既是Wasm的运行时又是编译器。为了保证表示的安全性，模块以Wasm表示。回想一下，您无法在Wasm中表达任何恶意内容。 Lucet充分利用了这一点，并使用Wasm模块的验证作为安全检查。验证之后，该模块将编译为具有几乎裸机性能的可执行工件。它还支持提前编译，使我们能够在运行时准备好执行这些工件。 Lucet容器的启动时间令人印象深刻，为35μs。那是因为它是一个容器，根本不需要执行任何操作即可启动。如果您想了解整个情况，Fastly的首席技术官Tyler McMullan进行了精彩演讲，概述了Lucet及其工作原理。</p><p>  We wrap Lucet within a Rust web service which manages the I/O and storage of modules, which we call the Wasm Engine. This engine is called by Shopify during a runtime process, usually a web request, in order to satisfy some function. It then applies the output in context of the callsite. This application could involve the creation of a discount, the enforcement of a constraint, or any form of synchronous behaviour Merchants want to customize within the Platform.</p><p>  我们将Lucet包装在Rust网络服务中，该服务管理模块的I / O和存储，我们将其称为Wasm引擎。 Shopify在运行时过程（通常是Web请求）中调用此引擎，以满足某些功能。然后，它将输出应用到呼叫站点的上下文中。此应用程序可能涉及折扣的创建，约束的实施或商人想要在平台内自定义的任何形式的同步行为。</p><p>  Here’s some metrics pulled from a recent performance test. During this test, 100k modules were executed per minute for approximately 5 min. These modules contained a trivial implementation of enforcing a limit on the number of items purchased in a cart.</p><p>  以下是一些根据最近的性能测试得出的指标。在此测试期间，每分钟执行10万个模块，持续大约5分钟。这些模块包含了对购物车中购买的商品数量实施限制的简单实现。</p><p>  This chart demonstrates a breakdown of the time taken to execute a module, including I/O with the container and the execution of the module. The y-axis is time in ms, the x-axis is the time over which the test was running.</p><p>  该图表演示了执行模块所需时间的细分，包括使用容器进行I / O和执行模块的时间。 y轴是以毫秒为单位的时间，x轴是测试运行的时间。</p><p> The light purple bar shows the time taken to execute the module in Lucet, the width of which hovers around 100 μs. The remaining bars deal with I/O and engine specifics, and the total time of execution is around 4 ms. All times are 99th percentiles (p99).To put these times in perspective, let’s compare these times to the request times of  Storefront Renderer, our performant Online Store rendering service:</p><p> 浅紫色条显示了在Lucet中执行模块所需的时间，该模块的宽度徘徊在100μs左右。其余的小节处理I / O和引擎的细节，执行的总时间约为4毫秒。所有时间均为第99个百分位（p99）。为便于了解，我们将这些时间与我们的高性能在线商店渲染服务Storefront Renderer的请求时间进行比较：</p><p>  This chart demonstrates the request time to Storefront Renderer over time. The y-axis is request time in seconds. The x-axis is the time over which the values were retrieved. The light blue line representing the 99th percentile hovers around 700 ms.</p><p>  该图表演示了一段时间后到Storefront Renderer的请求时间。 y轴是以秒为单位的请求时间。 x轴是获取值的时间。代表第99个百分位的浅蓝色线徘徊在700毫秒左右。 </p><p> Then if we consider the time taken by our module execution process to be generally under 5 ms, we can say that the performance impact of Lucet execution is negligible.</p><p>然后，如果我们认为模块执行过程所花费的时间通常不超过5毫秒，那么可以说Lucet执行对性能的影响可以忽略不计。</p><p>  To get value out of our high performance execution engine, we’ll need to empower developers to create compatible Wasm modules. Wasm is primarily intended as a compilation target, rather than something you write by hand ( though you can write Wasm by hand). This leaves us with the question of what languages we’ll support and to what extent.</p><p>  为了从我们的高性能执行引擎中获取价值，我们需要授权开发人员创建兼容的Wasm模块。 Wasm主要用作编译目标，而不是您手工编写的东西（尽管您可以手工编写Wasm）。这给我们留下了一个问题，我们将支持哪种语言以及在何种程度上支持。</p><p> Theoretically any language with a Wasm target can be supported, but the effort developers spend to conform to our API is better focused on solving problems for merchants. That’s why we’ve chosen to provide first class support to a single language that includes tools that get developers up and running quickly.At Shopify, our language of choice is Ruby. However, because Ruby is a dynamic language, we can’t compile it down to Wasm directly. We explored solutions involving compiling interpreters, but found that there was a steep performance penalty. Because of this, we decided to go with a statically compiled language and revisit the possibility of dynamic languages in the future.</p><p> 从理论上讲，可以支持任何以Wasm为目标的语言，但是开发人员为遵守我们的API而花费的精力更好地集中于为商人解决问题。因此，我们选择为单一语言提供一流的支持，其中包括使开发人员快速启动和运行的工具。在Shopify，我们选择的语言是Ruby。但是，由于Ruby是一种动态语言，因此我们无法直接将其编译为Wasm。我们探索了涉及编译解释器的解决方案，但发现性能损失很大。因此，我们决定使用静态编译语言，并在将来重新考虑使用动态语言的可能性。</p><p> Through our research we found that developers in our ecosystem were most familiar with Javascript. Unfortunately, Javascript was precluded as it’s a dynamic language like Ruby. Instead, we chose a language with familiar TypeScript-like syntax called  AssemblyScript.</p><p> 通过我们的研究，我们发现生态系统中的开发人员最熟悉Javascript。不幸的是，由于它是一种动态语言（如Ruby），因此Javascript被排除在外。相反，我们选择了一种具有类似于TypeScript语法的语言，称为AssemblyScript。</p><p>  At first glance, there are a huge number of languages that support a WebAssembly target. Unfortunately, there are two broad categories of WebAssembly compilers which we can’t use:</p><p>  乍一看，有许多语言支持WebAssembly目标。不幸的是，我们无法使用两大类WebAssembly编译器：</p><p> Compilers that generate environment or language specific artifacts, namely node or the browser. (Examples:  Asterius,  Blazor)</p><p> 生成特定于环境或语言的工件（即节点或浏览器）的编译器。 （例如：Asterius，Blazor）</p><p> Compilers that are designed to work only with a particular Runtime. The modules generated by these compilers rely upon special language specific imports. This is often done to support a language’s standard library, which expects certain system calls or runtime features to be available. Since we don’t want to be locked down to a certain language or tool, we don’t use these compilers. (Examples:  Lumen)</p><p> 旨在仅与特定运行时一起使用的编译器。这些编译器生成的模块依赖于特定于语言的导入。通常这样做是为了支持一种语言的标准库，该库需要某些系统调用或运行时功能可用。由于我们不想被锁定在某种语言或工具上，因此我们不使用这些编译器。 （例如：流明） </p><p> These are powerful tools in the right conditions, but aren’t built for our use case. We need tools that produce WebAssembly, rather than tools which are  powered by WebAssembly. AssemblyScript is one such tool.</p><p>这些工具在适当的条件下是功能强大的工具，但并非针对我们的用例而构建。我们需要生成WebAssembly的工具，而不是由WebAssembly支持的工具。 AssemblyScript就是这样一种工具。</p><p> AssemblyScript, like many tools in the WebAssembly space, is still under development. It’s missing a few key features, such as closure support, and it still has a number of edge case bugs. This is where the importance of the community comes in.</p><p> 像WebAssembly领域中的许多工具一样，AssemblyScript仍在开发中。它缺少一些关键功能（例如关闭支持），并且仍然存在许多边缘错误。这就是社区重要性的体现。</p><p> The language and the tooling around AssemblyScript has an active community of enthusiasts and maintainers who have supported Shopify since we first started using the language in 2019. We’ve supported the community through  an OpenCollective donation and continuing code contributions. We’ve written  a language server, made some progress towards implementing closures, and have written bug fixes for the compiler and surrounding tooling.</p><p> 自从我们于2019年首次使用Shopify以来，AssemblyScript的语言和工具就拥有一个活跃的爱好者和维护者社区，他们一直为Shopify提供支持。我们已经编写了语言服务器，在实现闭包方面取得了一些进展，并为编译器和周围的工具编写了错误修复程序。</p><p> We’ve also integrated AssemblyScript into our own early stage tooling. We’ve built integrations into  the Shopify CLI which will allow developers to create, test, and deploy modules from their command line. To improve developer ergonomics, we provide SDKs which handle the low level implementation concerns of Shopify defined objects like “Money”. In addition to these tools, we’re building out systems which allow Partners to monitor their modules and receive alerts when their modules fail. The end goal is to give Partners the ability to move their code onto our service without losing any of the flexibility or observability they had on their own platform.</p><p> 我们还将AssemblyScript集成到我们自己的早期工具中。我们已经在Shopify CLI中建立了集成，开发人员可以通过命令行来创建，测试和部署模块。为了改善开发人员的人机工程学，我们提供了SDK，用于处理Shopify定义的对象（例如“ Money”）的底层实现问题。除了这些工具之外，我们还在构建系统，使合作伙伴可以监视其模块并在模块发生故障时接收警报。最终目标是使合作伙伴能够将其代码移动到我们的服务上，而不会失去他们在自己的平台上拥有的任何灵活性或可观察性。</p><p>  As we tear down the boundaries between Partners and Merchants, we connect merchants with the entrepreneurs ready to solve their problems. If you have ideas on how our code execution could help you and the Apps you own or use, please tweet us at @ShopifyEng. To learn more about Apps at Shopify and how to get started, visit  our developer page.</p><p>  当我们打破合伙人和商人之间的界限时，我们将商人与准备解决他们的问题的企业家联系起来。如果您对我们的代码执行可以如何帮助您以及您拥有或使用的应用程序有任何想法，请通过@ShopifyEng发推文。要了解有关Shopify上的Apps以及如何入门的更多信息，请访问我们的开发人员页面。</p><p> Duncan is a Senior Developer at Shopify. He is currently working on the Scripts team, a team dedicated to enabling and managing untrusted code execution within Shopify for Merchants and Developers alike.</p><p> Duncan是Shopify的高级开发人员。他目前正在脚本团队工作，该团队致力于在Shopify中为商人和开发人员启用和管理不受信任的代码执行。</p><p>  If you love working with open source tools, are passionate about API design and extensibility, and want to  work remotely, we’re always hiring! Reach out to us or  apply on our careers page.</p><p>  如果您喜欢使用开放源代码工具，并且对API设计和可扩展性充满热情，并且希望远程工作，那么我们始终在招聘！与我们联系或在我们的职业页面上申请。 </p><p>  Stories from the teams who build and scale Shopify, the leading cloud-based, multi-channel commerce platform powering over 1,000,000 businesses around the world.</p><p>来自构建和扩展Shopify的团队的故事，Shopify是领先的基于云的多渠道商业平台，为全球超过1,000,000家企业提供支持。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shopify.engineering/shopify-webassembly">https://shopify.engineering/shopify-webassembly</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/shopify/">#shopify</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wasm/">#wasm</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>