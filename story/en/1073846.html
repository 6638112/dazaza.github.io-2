<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你的单子是什么颜色的What Color Is Your Monad</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What Color Is Your Monad<br/>你的单子是什么颜色的</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 14:23:20</div><div class="page_narrow text-break page_content"><p>There’s a lovely old blog post   What Color is Your Function ( WCIYF).If you haven’t read that, please do so instead of reading this one.</p><p>有一篇可爱的老博文《你的功能是什么颜色》（WCIYF）。如果你还没有读过这篇文章，请不要读这篇。</p><p> Since you are here, you should understand the  colored function problem described in that post. I’d like to explore how that problem generalized beyondasync concerns and how it connects to the much bemoaned  monad.</p><p>既然你在这里，你应该理解那篇文章中描述的有色函数问题。我想探讨一下这个问题是如何将beyondasync问题概括化的，以及它是如何与备受哀叹的monad联系在一起的。</p><p> You don’t really need to know what a monad is to start reading this post, but you  should understand the colored function problem described in the linked post.</p><p>阅读这篇文章时，你并不需要知道什么是单子，但你应该理解链接文章中描述的有色函数问题。</p><p>  To recap  WCIYF: Red functions are the async ones. If a blue (synchronous) function needsto be updated to call a red one, the blue one needs to be changed to red, which in turn, causes a  proliferation of redness. Also, the red functionsare more painful to call. I’ll mostly be concerned with the  proliferation of redness, but we’ll discuss the pain as well.</p><p>概括一下WCIYF:Red函数是异步函数。如果需要更新蓝色（同步）函数以调用红色函数，则需要将蓝色函数更改为红色，这反过来会导致红色扩散。而且，调用红色函数更痛苦。我主要关注的是发红的扩散，但我们也会讨论疼痛。</p><p> The author mentions Promises as a mitigation, but ultimately decides using threads (green or os) is a better solution.</p><p>作者提到承诺是一种缓解措施，但最终决定使用线程（绿色或os）是更好的解决方案。</p><p>  Promises are an example of a monad. There  is pain in using them, but I’llargue it is worth it: you should just bite the bullet and make everything red.When everything is red, you don’t have to think about color, and the problemgoes away.</p><p>承诺是单子的一个例子。使用它们是痛苦的，但我认为这是值得的：你应该咬紧牙关，把所有东西都染成红色。当所有东西都是红色时，你不必考虑颜色，问题就消失了。</p><p> I’ll give a few alternative definitions of “red function”, we willhave roughly the same problem, and the solution will always be some monad.</p><p>我将给出“红色函数”的几个替代定义，我们将有大致相同的问题，解决方案将始终是一些单子。</p><p>  The big reveal in  WCIYF is that “Red functions are asynchronous ones”. Consider instead, functions that throw exceptions.Could we consider those “red”? If you have a function that does not throw (blue) and you need to edit it to call a function that throws, then your functionwill also become one that throws,  unless you are able to handle the exception. In practice, there will be times where you can handle the exception and timesthat you can’t, so the redness really only  proliferates when you can’t handle the exception. Catching an exception is the analogue waiting on a promise,and it’s much more reasonable to have code that handles exceptions than code that waits on promises. Nevertheless, let’s focus on the case where we are  not ableto handle the exceptions and so the redness does proliferate like the async case.</p><p>WCIYF最大的启示是“红色函数是异步函数”。相反，考虑抛出异常的函数。我们可以考虑那些“红色”吗？如果您有一个不抛出（蓝色）的函数，并且需要对其进行编辑以调用抛出的函数，那么您的函数也将成为抛出的函数，除非您能够处理异常。在实践中，有时你可以处理异常，有时你不能，所以只有当你不能处理异常时，红色才会增加。捕获异常类似于等待承诺，让代码处理异常比等待承诺更合理。然而，让我们关注一下我们无法处理异常的情况，因此红色确实像异步情况一样扩散。</p><p> Side note: some languages like Java have  checked exceptions, in this case you really do need to update you method signatures and explicitly change your bluefunction to red by declaring that the exception is thrown. This fits a bit better with the async case since there are actual (mechanical) code changes.In the unchecked case, all the pain falls on whoever is getting paged because of new exceptions being thrown at runtime.</p><p>旁注：像Java这样的一些语言已经检查了异常，在这种情况下，您确实需要更新方法签名，并通过声明抛出异常来显式地将bluefunction更改为红色。这更适合异步情况，因为存在实际的（机械的）代码更改。在未检查的情况下，所有的痛苦都落在了被寻呼的人身上，因为在运行时抛出了新的异常。</p><p>  Exceptions separate the happy path from the sad path, the typical from the atypical, the unexceptional from the exceptional.They come with their own control flow mechanism as an implementation detail  1.</p><p>例外将快乐的道路与悲伤的道路分开，将典型的道路与非典型的道路分开，将平凡的道路与例外的道路分开。它们有自己的控制流机制作为实现细节1。</p><p> As an alternative, many languages or libraries define a type  Either&lt;SomeErrorType, DesiredType&gt;,where you can specify that your function returns one of two things. You have tochoose your preferred error type, which doesn’t matter for this article, so let’sjust say we have chosen “ SomeErrorType”.</p><p>作为替代方案，许多语言或库也定义了一种类型&lt；SomeErrorType，DesiredType&gt；，可以指定函数返回以下两种情况之一。你必须选择你喜欢的错误类型，这与本文无关，所以我们只能说我们选择了“SomeErrorType”。</p><p> WCIYF explains promises as  reifying the concept of passing a callback/errorback. Likewise,  Either&lt;SomeErrorType, *&gt; reifies the concept of typical/atypical outcomes.In both cases, your function now returns a  value that represents the control flow, and  values tend to be easier to reason about than behaviors.</p><p>WCIYF将承诺解释为将回调/错误返回的概念具体化。同样地，也不是&lt；SomeErrorType，*&gt；具体化典型/非典型结果的概念。在这两种情况下，函数现在都返回一个表示控制流的值，而值往往比行为更容易推理。</p><p>  Side note: In every language I’ve seen, a Promise/Future has a success and failure case built in. So it essentially has  Either built into it. I  thinkthis is because languages that have exceptions often have no way of guaranteeing that an exception  won’t happen. This feels a lot like languages where anything could be null. I’d be interested in a language that forces the use of  Optional,  Either instead of allowing for  null,  exceptions. Maybe Haskell does this?!</p><p>旁注：在我所见过的每一种语言中，承诺/未来都有一个成功和失败的案例。所以它本质上要么是内置的。我认为这是因为有异常的语言通常无法保证异常不会发生。这感觉很像任何东西都可以为空的语言。我会对一种强制使用可选的语言感兴趣，而不是允许null异常。也许是哈斯克尔干的？！</p><p>  WCIYF sort of admits that promises are less painful than callbacks, but also pooh-poohs them as being a half solution. I just want to point outthat some languages have  for expressions (e.g. Scala) or  do notation (e.g. Haskell), which further lessens the pain  2. A rough example:</p><p>WCIYF有点承认承诺比撤回承诺痛苦，但也不以为然地认为它们是半个解决方案。我只想指出一些语言有for表达式（例如Scala）或do表示法（例如Haskell），这进一步减轻了痛苦2。一个粗略的例子：</p><p>  That’s some made up code to asynchronously get a user from their id and then get all their friends by id. Allow me to repeat the code with thetypes specified (typescript style) after all the values:</p><p>这是一些虚构的代码，用于从用户id异步获取用户，然后通过id获取他们的所有朋友。请允许我在所有值之后使用指定的类型（typescript样式）重复代码：</p><p> def getFriends (userId ) :  Promise&lt;User []&gt;  =  for  { user :  User  &lt;-  asyncGetUser ( userId ) :  Promise&lt;User&gt; friends :  User []  &lt;- user .friendIds .traverse (asyncGetUser ) :  Promise&lt;User []&gt;  }  yield friends</p><p>def getFriends（用户ID）：承诺&lt；用户[]&gt；=对于{user:user&lt；-asyncGetUser（userId）：Promise&lt；user&gt；friends:user[]&lt；-user.friends.traverse（asyncGetUser）：Promise&lt；user[]&gt；}交朋友</p><p> Notice how on the left of the  &lt;- we always have  T whenever the right is  Promise&lt;T&gt;. Also notice the  proliferatation of the  Promise,  getFriends returns a  Promise because asyncGetUser does.  .traverse is a a combination of   map and   Promise.all, and it does the only thing that makes sense for this code.</p><p>请注意&lt；-无论什么时候，只要权利是承诺，我们就永远拥有它&lt；T&gt；。还要注意承诺的激增，getFriends会返回一个承诺，因为asyncGetUser会。traverse是map和Promise的结合。所有的，并且它做了唯一对这段代码有意义的事情。</p><p> Now instead, suppose we have  syncGetUser which returns  Either&lt;SomeErrorType, User&gt;. The code is the same, except the types:  Either&lt;SomeErrorType, T&gt; replaces  Promise&lt;T&gt; .</p><p>现在，假设我们有syncGetUser，它返回&lt；SomeErrorType，用户&gt；。代码相同，但类型不同：要么&lt；SomeErrorType，T&gt；取代承诺&lt；T&gt。</p><p> def getFriends (userId ) :  Either&lt;SomeErrorType ,  User []&gt;  =  for  { user :  User  &lt;-  syncGetUser ( userId ) :  Either&lt;SomeErrorType ,  User &gt; friends :  User []  &lt;- user .friendIds .traverse (asyncGetUser ) :  Either&lt;SomeErrorType ,  User []&gt;  }  yield friends</p><p>def getFriends（userId）：要么&lt；SomeErrorType，用户[]&gt；=对于{user:user&lt；-syncGetUser（userId）：或者&lt；SomeErrorType，用户&gt；friends:user[]&lt；-user.friendIds.traverse（asyncGetUser）：或者&lt；SomeErrorType，用户[]&gt；}交朋友</p><p>    I’ll start with a concrete example: For some context, suppose you have a single page app with micro-services all making http calls sending json to and from the browser and between services.It’s nice to have a per-request “correlation id” that is included in all the log statements. In order for this to work, the correct id needs to be availablewhenever you log something. It also needs to be available whenever you make and http call to another service. So let’s say “red functions” are functions that need to know the correlation id. Given thatwe need the id for logging and http calls we expect the redness to quickly proliferate almost everywhere.</p><p>我将从一个具体的例子开始：在某些上下文中，假设您有一个单页应用程序，其中的微服务都在进行http调用，在浏览器之间和服务之间发送json。在所有日志语句中都包含一个每个请求的“相关id”，这很好。为了使其正常工作，无论何时登录，都需要提供正确的id。它还需要在您对另一个服务进行http调用时可用。假设“红色函数”是需要知道相关id的函数。鉴于我们需要用于日志记录和http调用的id，我们预计红色会迅速扩散到几乎所有地方。</p><p>   Recall however, that we were able to solve our other problems be returning a value that better represents our needs. So, in this case,we need to return a value that represents “the need for a correlation id”. For this, we can use a function, i.e.</p><p>然而，回想一下，我们能够通过返回一个更好地代表我们需求的值来解决其他问题。因此，在这种情况下，我们需要返回一个值，该值表示“对相关id的需求”。为此，我们可以使用一个函数，即。</p><p>     def getFriends (userId ) :  CorrelationId  =&gt;  User []  =  for  { user :  User  &lt;-  syncGetUser ( userId ) :  CorrelationId  =&gt;  User friends :  User []  &lt;- user .friendIds .traverse (asyncGetUser ) :  CorrelationId  =&gt;  User []  }  yield friends</p><p>def getFriends（userId）：CorrelationId=&gt；User[]=对于{User:User&lt；-syncGetUser（userId）：CorrelationId=&gt；用户朋友：User[]&lt；-User.friendIds.traverse（asyncGetUser）：CorrelationId=&gt；User[]}生成朋友</p><p> Note that this code doesn’t deal with the correlation Id. (It also didn’t deal with asynchronicity, or errors).</p><p>请注意，这段代码不处理相关Id（它也不处理异步性或错误）。</p><p>  Now that we’ve written essentially the same code three times, let’s pull out the different part as a variable:</p><p>既然我们已经三次编写了基本相同的代码，那么让我们把不同的部分作为变量：</p><p> def getFriends &lt;F :  Monad&gt; ( userId ) :  F&lt;User []&gt;  =  for  { user :  User  &lt;-  syncGetUser ( userId ) :  F&lt;User&gt; friends :  User []  &lt;- user .friendIds .traverse (asyncGetUser ) :  F&lt;User []&gt;  }  yield friends</p><p>def getFriends&lt；F:Monad&gt；（userId）：F&lt；用户[]&gt；=对于{user:user&lt；-syncGetUser（userId）：F&lt；user&gt；friends:user[]&lt；-user.friends.traverse（asyncGetUser）：F&lt；user[]&gt；}交朋友</p><p> Here my method is parameterized by  F with the restriction that  F is a monad  4 ( F: Monad). You can get all the previous examplesby replacing  F&lt;*&gt; with  Promise&lt;*&gt;,  Either&lt;SomeErrorType, *&gt;, or  CorrelationId =&gt; *. (The  * being the spot where you have to substitute the type you  actually care about).</p><p>在这里，我的方法由F参数化，但有一个限制，即F是monad 4（F:monad）。您可以通过替换F&lt*&gt；带着承诺&lt*&gt；，要么&lt；SomeErrorType，*&gt；，或CorrelationId=&gt；*。（在*处，你必须替换你真正关心的类型）。</p><p> We can even combine things, so  F could be  CorrelationId =&gt; Promise&lt;*&gt; if  getUser needed a  CorrelationId  and we wanted it to be async.</p><p>我们甚至可以组合东西，所以F可以是CorrelationId=&gt；承诺&lt*&gt；如果getUser需要一个CorrelationId，我们希望它是异步的。</p><p>  Many languages have generic types. Take  Array&lt;Int&gt;, I’ll refer to  Array as the  outside and  Int as the  inside. Often a language willlet you make the inside a variable  Array&lt;T&gt; is an array, but I don’t know or care what is inside it. It’s less common to be able to put a variable on the  outside. F&lt;Int&gt; is a bit odd, you don’t really have any idea what it is, there’s only a suggestion that is has something to do with  Int. Nevertheless, that is preciselythe thing that changes across our three examples  5.</p><p>许多语言都有泛型类型。以阵列为例&lt；Int&gt；，我将数组称为外部，Int称为内部。通常，一种语言会让你在一个变量数组中创建内部变量&lt；T&gt；是一个数组，但我不知道也不在乎里面是什么。能够在外部设置变量的情况不太常见。F&lt；Int&gt；有点奇怪，你真的不知道它是什么，只有一个建议与Int有关。然而，这正是我们三个例子5中的变化。</p><p>  In our example we needed a  CorrelationId, but the same pattern can be used for other things you need, but don’t really want to explicitly pass. For example,database connections, user session ids, user authorization info. Any time you want something available but don’t really want to pass it around.</p><p>在我们的示例中，我们需要一个CorrelationId，但相同的模式可以用于您需要的其他事情，但实际上不想显式传递。例如，数据库连接、用户会话ID、用户授权信息。任何时候你想要一些可用的东西，但并不真的想把它传给别人。</p><p>  A bug comes in. A number is wrong in the UI. The backend that  my team is responsible for really just calls other APIs that other teams are responsible for.The first thing we’d want to look atis the request and response we made to these external APIs (after all, we wantto pass the blame as quickly as possible if it’s an upstream error). Now, forvarious reasons we didn’t want to log all the requests and responses. So,for every external API call, we returned the full request/response in additionto whatever we wanted to. At least, in QA environments.</p><p>一只虫子进来了。用户界面中的数字有误。我的团队负责的后端实际上只是调用其他团队负责的其他API。我们首先要看的是我们对这些外部API的请求和响应（毕竟，如果是上游错误，我们希望尽快推卸责任）。现在，由于各种原因，我们不想记录所有的请求和响应。因此，对于每个外部API调用，我们都会返回完整的请求/响应，以及我们想要的任何内容。至少，在QA环境中。</p><p>   Here,  DiagnosticData is the request/response or anything else we want to also return to help diagnose issues. It’s an array because we need to allow for multiple things coming back.Then the json coming back to the browser would always be an object and it would contain one extra field with the  diagnosticData serialized in the response.</p><p>在这里，DiagnosticData是请求/响应或我们希望返回以帮助诊断问题的任何其他内容。这是一个数组，因为我们需要允许多个东西返回。然后返回浏览器的json将始终是一个对象，它将包含一个额外的字段，并在响应中序列化diagnosticData。</p><p> The hope would be that anyone doing QA could copy the json from the dev tools in the browser and any bug ticket would include all of theAPI calls we made. Often that’s enough to figure out which team needs to take action.</p><p>希望任何做QA的人都能从浏览器中的开发工具中复制json，任何错误记录都会包括我们所做的所有API调用。通常，这就足以确定哪个团队需要采取行动。</p><p> In this case  F is  [DiagnosticData[], *] and it  proliferates precisely because we need to bubble up the extra data to the controller.</p><p>在这种情况下，F是[DiagnosticData[]，*]，它的扩散正是因为我们需要向控制器提供额外的数据。</p><p>  There’s no denying that the blue functions are nicer. The best signature for  getUser is</p><p>不可否认，蓝色的功能更好。getUser的最佳签名是</p><p>  But that is not always practical: You often have other  cross cutting concerns: resource usage, error handling, code cleanliness, monitoring.So if, instead, you return:</p><p>但这并不总是切实可行的：您通常还有其他贯穿各领域的问题：资源使用、错误处理、代码清洁度、监控。因此，如果您返回：</p><p>  You are giving yourself a lot of flexibility to not exactly return a  User. We saw different examples where we did not exactly return a  User. You can even vary  F based on context, only return extra data outside of production, or be synchronous  6 in unit tests but async when actually running.</p><p>您为自己提供了很大的灵活性，可以不完全返回用户。我们看到了不同的例子，其中我们没有完全返回用户。您甚至可以根据上下文改变F，只返回生产之外的额外数据，或者在单元测试中是同步的，但在实际运行时是异步的。</p><p>  No, not really. I mean, I think it was fun to think about colored functions and monads, but most languages don’t support these features that make this practical. Also, it’s going to be hard to get your whole team (including future teammates) on board with coding like this. So  don’t actually do this.</p><p>不，不是真的。我的意思是，我认为考虑彩色函数和单子很有趣，但大多数语言不支持这些使其实用的功能。而且，用这样的编码很难让你的整个团队（包括未来的队友）参与进来。所以不要真的这么做。</p><p> I think the control flow aspect mostly makes code a bit less verbose at a fairly large conceptual expense.  ↩︎</p><p>我认为控制流方面主要是以相当大的概念代价让代码不那么冗长。  ↩︎</p><p> javascript, of course, has  async/await syntax. I’m curious if that is equivalent to for expressions/do notation and could (in theory) be used for monads other than  Promise.  ↩︎</p><p>当然，javascript有异步/等待语法。我很好奇这是否等同于for expressions/do符号，并且（理论上）可以用于monad而不是Promise。  ↩︎</p><p> There are other ways to avoid passing the parameter explicitly, but this is just for the sake of example.  ↩︎</p><p>还有其他方法可以避免显式传递参数，但这只是为了举例。  ↩︎</p><p> It needs to be a monad so we can use the  for expression.  ↩︎</p><p>它必须是单子，这样我们就可以用单子来表示。  ↩︎</p><p> Languages that do support that feature would call it “Higher kinded types”.  ↩︎</p><p>支持该功能的语言称之为“高级类型”。  ↩︎</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/单子/">#单子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/color/">#color</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/承诺/">#承诺</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>