<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我对莫诺雷波的思考</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我对莫诺雷波的思考</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 03:13:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/df048330b3e6582edd6465fd7bc7d427.png"><img src="http://img2.diglog.com/img/2020/11/df048330b3e6582edd6465fd7bc7d427.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Before we start let me give some context on my background so that you can better understand my thoughts on Monorepo.</p><p>在我们开始之前，让我先介绍一下我的背景，这样您就可以更好地了解我对Monorepo的想法。</p><p> I head technology at an IT services organization. Most of the products that I build are using Microservices architecture, have multiple frontends(web and mobile). The biggest product that I recently built had close to 30 microservices, 1 web client written in React,  and native mobile app built using React Native. These numbers are nowhere near the numbers big product companies have shared.</p><p>我在一家IT服务机构负责技术工作。我构建的大多数产品都使用微服务架构，有多个前端(Web和移动)。我最近开发的最大的产品有近30个微服务，1个用React编写的Web客户端，以及使用React Native构建的原生移动应用程序。这些数字与大型产品公司分享的数字相去甚远。</p><p> I prefer Macroservices over Microservices. I think most products don’t need more than 10 microservices.</p><p>与微观服务相比，我更喜欢宏观服务。我认为大多数产品不需要超过10个微服务。</p><p>  The reason I am clearly specifying I belong to the IT services world is because most of the stuff we consume on software development is written by engineers and senior tech people at the product companies. The stuff they write and share is based on the real problems and challenges they face at work. There are times when those problems resonate with problems other software engineers face at their work but there are times they are solutions to the problems we don’t have. So, we have to look at these solutions from the lens of our problems.</p><p>我之所以明确说明我属于IT服务领域，是因为我们在软件开发上消费的大部分东西都是由产品公司的工程师和高级技术人员编写的。他们写和分享的东西是基于他们在工作中面临的真正问题和挑战。有时这些问题会与其他软件工程师在工作中面临的问题产生共鸣，但有时它们是我们没有的问题的解决方案。因此，我们必须从我们问题的角度来看待这些解决方案。</p><p> The post is based on my experience building software, leading and managing software delivery teams, and learning from the great articles written by engineers using Monorepos. Please refer to the references section for good resources on monorepos.</p><p>这篇文章是基于我在构建软件、领导和管理软件交付团队，以及从使用Monorepos的工程师撰写的优秀文章中学习的经验。有关monorepos的好资源，请参阅参考部分。</p><p>   A monorepo is a software development strategy where a single version control repository has source code for multiple projects, libraries, and applications irrespective of their programming language. Also, the organizations using Monorepo strategy often use a common build tool (like Bazel, Pants, Buck) to manage all the source code. Some of the popular examples of organizations that employ monorepo strategy are Google, Facebook, Twitter, Microsoft, and Uber.</p><p>Monorepo是一种软件开发策略，其中单个版本控制存储库具有多个项目、库和应用程序的源代码，而与它们的编程语言无关。此外，使用Monorepo策略的组织通常使用一个通用的构建工具(如Bazel、Pants、Buck)来管理所有源代码。一些采用Monorepo策略的组织的流行示例是Google、Facebook、Twitter、Microsoft和Uber。</p><p> The alternative to monorepo is polyrepo/multirepo. In multirepo, you have a separate version control repository for each component. This is the common strategy used by most organizations to structure their code. This in my view has been largely driven by Microservices architecture style and small modules movement.</p><p>Monorepo的替代方案是polyrepo/multirepo。在multirepo中，每个组件都有单独的版本控制存储库。这是大多数组织用来构建代码结构的通用策略。在我看来，这在很大程度上是由微服务架构风格和小模块移动推动的。</p><p> As mentioned in the paper[1] (Advantages and Disadvantages of a Monolithic Repository – A case study at Google), Monorepos have following properties:</p><p>正如论文[1](单一存储库的优点和缺点-Google的案例研究)中提到的，Monorepos具有以下属性：</p><p> Completeness: Any project in the repo can be built only from dependencies also checked into the repo. Dependencies are unversioned; projects must use whatever version of their dependency is at the repo head.</p><p>完整性：repo中的任何项目都只能从也签入repo的依赖项构建。依赖项是未版本化的；项目必须使用位于repo头的依赖项的任何版本。</p><p> Standardization: A shared set of tooling governs how engineers interact with the code, including building, testing, browsing, and reviewing code.</p><p>标准化：一组共享的工具控制着工程师如何与代码交互，包括构建、测试、浏览和审查代码。</p><p> My understanding is that to successfully use monorepo you will have to satisfy all the properties. Otherwise, you will not get benefits intended from monorepo.</p><p>我的理解是，要成功使用monorepo，您必须满足所有属性。否则，您将无法从monorepo中获得预期的好处。</p><p>  There are valid reasons why many big product organizations prefer Monorepo. Following are the main reasons:</p><p>许多大型产品组织更喜欢Monorepo是有充分理由的。主要原因如下：</p><p>   You can easily depend on other projects/modules in a monorepo without the need for artifact management tools like Nexus, Artifactory etc.</p><p>您可以轻松地依赖Monorepo中的其他项目/模块，而不需要Nexus、ArtiFactory等工件管理工具。</p><p> You avoid diamond dependency problem. Diamond dependences occur when a project has two dependencies which depend on the same underlying library. When a developer upgrades a dependency, they run the risk of breaking a diamond in the dependency graph.</p><p>你避免了钻石依赖问题。当项目有两个依赖于同一基础库的依赖项时，就会发生菱形依赖项。当开发人员升级依赖项时，他们会冒着打破依赖关系图中菱形的风险。</p><p> It is easier to keep all dependencies on the same version by using a centralized way to manage version numbers.</p><p>通过使用集中方式管理版本号，可以更容易地将所有依赖项保留在同一版本上。</p><p> This is simplified further by using a single build tool. I have not used Bazel, Bucks, or Pants. I was watching a talk on Twitter monorepo journey where they talked about Gradle being too slow for their use case. For the size of applications I have built Gradle has worked just fine.</p><p>使用单个构建工具可以进一步简化这一过程。我没有用过巴泽尔、巴克斯或裤子。我在Twitter Monorepo Travel上看了一场演讲，他们在会上谈到Gradle对于他们的用例来说太慢了。就我构建的应用程序的规模而言，Gradle运行得很好。</p><p>  The second big benefit of Monorepo is that developers can share code across projects. It is easier to enforce best practices across the code base by using monorepo. Another related point is that with monorepo we don’t end up creating silos. This is important in an enterprise setup because it leads to passing the buck and bugs falling through the cracks of the boundaries. In my experience with multirepo setup people only care about their Microservice running fine. They miss the point that value is achieved by integrating the software and collaboration. In IT service organizations where there is more bureaucracy and uneven distribution of skilled developers the problem scales very quickly with multirepo setup. Yes, I know it is a culture problem but most IT service organizations can’t burn investor dollars to build the culture.</p><p>Monorepo的第二大好处是开发人员可以跨项目共享代码。通过使用monorepo可以更容易地在代码库中实施最佳实践。另一个相关的问题是，使用monorepo，我们最终不会创建竖井。这在企业设置中很重要，因为它会导致推卸责任，并导致错误从边界的裂缝中落下。在我使用Multirepo设置的经验中，人们只关心他们的微服务是否运行良好。他们忽略了通过集成软件和协作来实现价值这一点。在IT服务组织中，有更多的官僚作风和熟练开发人员的不均匀分布，随着多资源设置，问题会非常迅速地扩展。是的，我知道这是一个文化问题，但大多数IT服务机构不能烧掉投资者的钱来建设这种文化。</p><p>  This I didn’t realize before I read literature on Monorepo. There is a lot of benefit in seeing related changes in a single commit. If you are working on a story that requires changes in multiple components then in a multirepo scenario you will have to see changes in multiple repositories and merge the PRs in some sequence so that you are in a healthy state. WIth monorepo you save the pain of trying to coordinate commits across multiple repositories. Also, this leads to better code reviews as all the changes are in one place.</p><p>这是我在阅读关于莫诺波的文学之前没有意识到的。在一次提交中看到相关更改有很多好处。如果您正在处理一个需要在多个组件中进行更改的故事，那么在多存储库场景中，您将必须查看多个存储库中的更改，并按一定顺序合并PR，以便您处于健康状态。使用monorepo，您可以省去尝试跨多个存储库协调提交的痛苦。而且，这会带来更好的代码审查，因为所有更改都在一个地方。</p><p>  This is related to reason 3. With a monorepo, you can refactor the API and all of its callers in one commit. You see all the usages of an API at a single place and it is much easier to do than with multirepo where you might not even have all the code checked out. In my experience with multirepo setup most developers don’t keep all the repos updated with the upstream changes. Monorepos enables continuous improvement on global level that multirepo you do at local level.</p><p>这与原因3相关。使用monorepo，您可以在一次提交中重构API及其所有调用方。您可以在单个位置查看API的所有用法，这比使用Multirepo要容易得多，在Multirepo中，您甚至可能没有签出所有代码。根据我在Multirepo设置方面的经验，大多数开发人员不会让所有的repo都随着上游的更改进行更新。Monorepos支持在全局级别上持续改进，就像您在本地级别上所做的Multirepo一样。</p><p>  With some organizations I have worked at, you have to create ServiceNow tickets to create a repository. It can take a couple of days before you get your empty repository. With monorepo you don’t have to go through this pain.</p><p>在我工作过的一些组织中，您必须创建ServiceNow票证才能创建存储库。可能需要几天时间才能获得空的存储库。使用monorepo，您不必经历这种痛苦。</p><p>  Nothing comes for free. There are always trade offs involved. Your job as a software engineer is to figure out if advantages weigh more than trade offs or not.</p><p>没有什么是免费的。总是需要权衡取舍。作为一名软件工程师，您的工作是弄清楚优势是否比取舍更重要。</p><p>  Monorepos could slow down developers because of slow build times, poor tooling, and merge conflicts.</p><p>Monorepos可能会因为缓慢的构建时间、糟糕的工具和合并冲突而减慢开发人员的速度。</p><p> There is cognitive overhead involved as developers have to get comfortable with a much larger code base than they would have with multirepo setup.</p><p>这涉及到认知开销，因为开发人员必须适应比使用Multirepo设置大得多的代码库。</p><p> To do monorepo well require investment in tooling that most organization non-tech leadership will fail to understand</p><p>要做好Monorepo，需要对工具进行投资，而大多数组织的非技术领导层将无法理解这一点</p><p>  Before I talk about my views on Monorepo let’s understand three main constraints of IT services organization.</p><p>在我谈论我对Monorepo的看法之前，让我们先了解一下IT服务组织的三个主要限制。</p><p> We work with multiple customers so we can’t keep code of all customers in the same repository even when we host their code in our version control for obvious reasons. Also, we can’t give access to all our repositories to all our developers because of security and IP related issues. So, we will keep our discussion focused on how to manage repos for a single customer.</p><p>我们与多个客户一起工作，因此我们不能将所有客户的代码保存在同一个存储库中，即使我们将他们的代码托管在我们的版本控制中也是如此，原因很明显。此外，由于安全和IP相关问题，我们不能将所有存储库的访问权限授予所有开发人员。因此，我们将继续集中讨论如何管理单个客户的回购。</p><p> IT services organizations have a high ratio of junior(&lt; 5 years) to senior engineers(&gt; 10 years) somewhere in the range of 10:1 to 100:1 or may be higher in bigger IT service organizations. The reason I am bringing this point is that monorepos requires discipline and it is tough to achieve without senior engineers driving it using a well-defined process.</p><p>IT服务组织的初级工程师(&lt；5年)与高级工程师(&gt；10年)的比例很高，介于10：1到100：1之间，在较大的IT服务组织中可能更高。我提出这一点的原因是，Monorepos需要纪律，如果没有高级工程师使用定义良好的过程驱动它，就很难实现这一点。</p><p> Given the above two constraints and the disadvantages of monorepos it might seem that monorepos will not work for us. But, I see real problems faced by software delivery teams that can be solved by monorepos.</p><p>考虑到上述两个限制和monorepos的缺点，monorepos似乎不适合我们。但是，我认为软件交付团队面临的真正问题可以通过monorepos来解决。</p><p> We build products for different customers. These products usually follow Microservice architecture, have multiple frontends – web and mobile, functional tests, scripts for deployment automation. In the multirepo strategy, you will create at minimum 5 repositories – 1 for backend with all microservices, 1 for SPA frontend, 1 or 2 repo for mobile depending on whether you are building pure native or using some native framework like React Native or Flutter, 1 for functional tests, 1 for deployment automation scripts.  More often than not your team will use one repo per Microservice then only god knows how many repos you end up creating.</p><p>我们为不同的客户生产产品。这些产品通常遵循微服务架构，具有多个前端-Web和移动、功能测试、用于部署自动化的脚本。在多存储库策略中，您将至少创建5个存储库-1个用于所有微服务的后端，1个用于SPA前端，1个用于移动存储库，具体取决于您是构建纯本机还是使用某些本地框架(如Reaction Native或Ffltter)，1个用于功能测试，1个用于部署自动化脚本。但通常情况下，您的团队将为每个微服务使用一个存储库，那么只有上帝知道您最终会创建多少存储库。</p><p> Let me tell you a real story. I was once working with a client that had more than 1000 repositories in their version control system. They were using the Gitlab version control platform. They had 5 products and each product was made up of multiple Microservices. The first question I asked them was to help us understand which all services and their respective code repositories were part of product A. Their chief architect had to spent a day figuring out all the repositories that made the product A. After spend a day still she was not sure if she has covered all the services.</p><p>让我给你讲一个真实的故事。我曾经与一个客户一起工作，该客户的版本控制系统中有1000多个存储库。他们使用的是GitLab版本控制平台。他们有5个产品，每个产品都由多个微服务组成。我问他们的第一个问题是帮助我们了解哪些所有服务及其各自的代码存储库都是产品A的一部分。他们的首席架构师必须花一天时间弄清楚构成产品A的所有存储库。花了一天时间之后，她仍然不确定自己是否已经涵盖了所有服务。</p><p> Let’s discuss problems that I face with software delivery teams using the multirepo strategy. Just to reiterate these problems are in the context of a single customer.</p><p>让我们讨论一下我在使用多资源策略的软件交付团队中遇到的问题。我只想重申，这些问题都是在单个客户的背景下出现的。</p><p> Lack of accountability: Humans are good at creating boundaries and silos. They don’t care what happens outside those boundaries. They don’t care about the bigger picture.</p><p>缺乏责任感：人类擅长创造边界和竖井。他们不在乎那些边界之外会发生什么。他们不关心更大的图景。</p><p> Version drift. 10 different versions of Spring Boot, three different JDK versions, multiple versions of React, and god knows how many different versions of libraries.</p><p>版本漂移。10个不同的Spring Boot版本，3个不同的JDK版本，多个Reaction版本，天知道有多少个不同版本的库。</p><p>  Health of projects. Using the same tools for all projects. Code consistency. Single source of truth</p><p>项目的健康状况。对所有项目使用相同的工具。代码一致性。单一的真理来源。</p><p> When you use multirepo everything ends up become a separate repository. And soon you lose the sight on how many repos you have.</p><p>当您使用multirepo时，所有内容最终都会变成一个单独的存储库。很快你就看不清你有多少回忆录了。</p><p>  Yes. For a single customer we don’t have to scale to millions of lines of code and 1000’s of developers. For a single customer we are under a million lines of code and our delivery teams are well under 100. We don’t have large version control histories and our developers commit less than 1000 commits in a week. So, we are well below the numbers shared by Google and Facebook.</p><p>是。对于单个客户，我们不必扩展到数百万行代码和1000个开发人员。对于单个客户，我们的代码不到一百万行，我们的交付团队不到100行。我们没有很大的版本控制历史记录，我们的开发人员一周提交的数量不到1000个。因此，我们远远低于谷歌和Facebook分享的数字。</p><p>  We are already doing that for one of our big customers. Below is the mono starter repo we use for new products.</p><p>我们已经在为我们的一个大客户这么做了。下面是我们用于新产品的单声道起动机回购(Mono Starter Repo)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shekhargulati.com/2020/11/02/my-thoughts-on-monorepo/">https://shekhargulati.com/2020/11/02/my-thoughts-on-monorepo/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/雷波/">#雷波</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/thoughts/">#thoughts</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>