<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您一直错过的反应式编程入门</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">您一直错过的反应式编程入门</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 23:03:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/cc2953afaaa8b4e0287395dbd7e10605.png"><img src="http://img2.diglog.com/img/2020/10/cc2953afaaa8b4e0287395dbd7e10605.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>If you prefer to watch video tutorials with live-coding, then check out this series I recorded with the same contents as in this article:  Egghead.io - Introduction to Reactive Programming.</p><p>如果您更喜欢观看实况编码的视频教程，请查看我用与本文相同的内容录制的这个系列：Egghead.io-反应式编程简介。</p><p>  So you&#39;re curious in learning this new thing called Reactive Programming, particularly its variant comprising of Rx, Bacon.js, RAC, and others.</p><p>所以您很好奇学习这个叫做反应式编程的新东西，特别是它的变体，包括Rx、Bacon.js、RAC和其他。</p><p> Learning it is hard, even harder by the lack of good material. When I started, I tried looking for tutorials. I found only a handful of practical guides, but they just scratched the surface and never tackled the challenge of building the whole architecture around it. Library documentations often don&#39;t help when you&#39;re trying to understand some function. I mean, honestly, look at this:</p><p>学习它很难，由于缺乏好的材料，学习起来就更难了。刚开始的时候，我试着找教程。我只找到了几个实用指南，但他们只是触及了皮毛，从来没有解决过围绕它构建整个体系结构的挑战。当您试图理解某些功能时，库文档通常无济于事。我是说，老实说，看看这个：</p><p>  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element&#39;s index and then transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.</p><p>通过合并元素的索引将可观测序列的每个元素投影到新的可观测序列序列中，然后将可观测序列的可观测序列变换为仅产生来自最新可观测序列的值的可观测序列。</p><p>  I&#39;ve read two books, one just painted the big picture, while the other dived into how to use the Reactive library. I ended up learning Reactive Programming the hard way: figuring it out while building with it. At my work in  Futurice I got to use it in a real project, and had the  support of some colleagues when I ran into troubles.</p><p>我已经读了两本书，一本只是描绘了大局，而另一本则潜心研究如何使用反应式图书馆。我最终以一种艰难的方式学习了反应式编程：一边用它构建，一边算出它。在我在Futurice的工作中，我在一个真正的项目中使用了它，当我遇到麻烦时，我得到了一些同事的支持。</p><p> The hardest part of the learning journey is  thinking in Reactive. It&#39;s a lot about letting go of old imperative and stateful habits of typical programming, and forcing your brain to work in a different paradigm. I haven&#39;t found any guide on the internet in this aspect, and I think the world deserves a practical tutorial on how to think in Reactive, so that you can get started. Library documentation can light your way after that. I hope this helps you.</p><p>学习之旅中最艰难的部分是被动思考。这在很大程度上是关于放弃典型编程的旧的命令性和有状态的习惯，迫使你的大脑在不同的范例中工作。我在互联网上还没有找到任何关于这方面的指南，我认为这个世界应该有一个关于如何被动思考的实用教程，这样你就可以开始了。在此之后，库文档可以为您指明方向。我希望这对你有帮助。</p><p>  There are plenty of bad explanations and definitions out there on the internet.  Wikipedia is too generic and theoretical as usual.  Stackoverflow&#39;s canonical answer is obviously not suitable for newcomers.  Reactive Manifesto sounds like the kind of thing you show to your project manager or the businessmen at your company. Microsoft&#39;s  Rx terminology &#34;Rx = Observables + LINQ + Schedulers&#34; is so heavy and Microsoftish that most of us are left confused. Terms like &#34;reactive&#34; and &#34;propagation of change&#34; don&#39;t convey anything specifically different to what your typical MV* and favorite language already does. Of course my framework views react to the models. Of course change is propagated. If it wouldn&#39;t, nothing would be rendered.</p><p>互联网上有很多糟糕的解释和定义。维基百科一如既往地过于笼统和理论化。StackOverflow的标准答案显然不适合新来者。反应性宣言听起来像是你向你的项目经理或你公司的商人展示的那种东西。微软的处方术语(Rx=Observables+LINQ+Schedulers&34；)是如此繁琐和繁琐，以至于我们大多数人都感到困惑。像“被动”和“传播变化”这样的术语并没有传达出与你的典型MV*和你最喜欢的语言已经做的有什么特别的不同。当然，我的框架视图会对模型做出反应。当然，变化是会传播的。如果它不这样做，什么都不会呈现。</p><p>   In a way, this isn&#39;t anything new. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. Reactive is that idea on steroids. You are able to create data streams of anything, not just from click and hover events. Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc. For example, imagine your Twitter feed would be a data stream in the same fashion that click events are. You can listen to that stream and react accordingly.</p><p>在某种程度上，这并不是什么新鲜事。事件总线或典型的单击事件实际上是异步事件流，您可以在其上观察和执行一些副作用。反应性是类固醇的想法。您可以创建任何内容的数据流，而不仅仅是从单击和悬停事件创建数据流。流既便宜又无处不在，任何东西都可以是流：变量、用户输入、属性、缓存、数据结构等。例如，假设您的Twitter提要是一个数据流，其方式与点击事件相同。您可以监听该流并做出相应的反应。</p><p> On top of that, you are given an amazing toolbox of functions to combine, create and filter any of those streams. That&#39;s where the &#34;functional&#34; magic kicks in. A stream can be used as an input to another one. Even multiple streams can be used as inputs to another stream. You can  merge two streams. You can  filter a stream to get another one that has only those events you are interested in. You can  map data values from one stream to another new one.</p><p>最重要的是，您可以使用一个令人惊叹的工具箱来组合、创建和过滤这些流。这就是功能性魔法发挥作用的地方。一个流可以用作另一个流的输入。即使是多个流也可以用作另一个流的输入。您可以合并两个流。您可以筛选一个流，以获得只包含您感兴趣的那些事件的另一个流。您可以将数据值从一个流映射到另一个新流。</p><p> If streams are so central to Reactive, let&#39;s take a careful look at them, starting with our familiar &#34;clicks on a button&#34; event stream.</p><p>如果流是反应性的核心，那么让我们从我们熟悉的单击按钮事件流开始，仔细研究一下它们吧。</p><p>  A stream is a sequence of  ongoing events ordered in time. It can emit three different things: a value (of some type), an error, or a &#34;completed&#34; signal. Consider that the &#34;completed&#34; takes place, for instance, when the current window or view containing that button is closed.</p><p>流是按时间排序的一系列正在进行的事件。它可以发出三种不同的东西：值(某种类型)、错误或已完成信号。例如，假设在关闭包含该按钮的当前窗口或视图时发生&#34；Complete&#34；。</p><p> We capture these emitted events only  asynchronously, by defining a function that will execute when a value is emitted, another function when an error is emitted, and another function when &#39;completed&#39; is emitted. Sometimes these last two can be omitted and you can just focus on defining the function for values. The &#34;listening&#34; to the stream is called  subscribing. The functions we are defining are observers. The stream is the subject (or &#34;observable&#34;) being observed. This is precisely the  Observer Design Pattern.</p><p>我们只异步捕获这些发出的事件，方法是定义一个值发出时将执行的函数、发出错误时执行的另一个函数和发出&#39；完成时发出的另一个函数。有时后两个可以省略，您只需专注于定义值的函数即可。监听该流的称为订阅。我们定义的函数是观察者。流是被观察的对象(或可观察的)。这正是观察者设计模式。</p><p> An alternative way of drawing that diagram is with ASCII, which we will use in some parts of this tutorial:</p><p>绘制该图表的另一种方法是使用ASCII，我们将在本教程的某些部分使用该方法：</p><p> --a---b-c---d---X---|-&gt;a, b, c, d are emitted valuesX is an error| is the &#39;completed&#39; signal---&gt; is the timeline</p><p>--a-b-c-d-X-|--&gt；a、b、c、d是发射值X是错误|是&#39；完成&#39；信号-&gt；是时间线。</p><p> Since this feels so familiar already, and I don&#39;t want you to get bored, let&#39;s do something new: we are going to create new click event streams transformed out of the original click event stream.</p><p>既然这感觉已经很熟悉了，而且我不想让您感到厌烦，让我们来做点新的事情：我们将从原来的单击事件流转换成新的单击事件流。</p><p> First, let&#39;s make a counter stream that indicates how many times a button was clicked. In common Reactive libraries, each stream has many functions attached to it, such as  map,  filter,  scan, etc. When you call one of these functions, such as  clickStream.map(f), it returns a  new stream based on the click stream. It does not modify the original click stream in any way. This is a property called  immutability, and it goes together with Reactive streams just like pancakes are good with syrup. That allows us to chain functions like  clickStream.map(f).scan(g):</p><p>首先，让我们创建一个计数器流来指示按钮被点击了多少次。在常见的反应库中，每个流都附加了许多函数，如map、filter、scan等。当您调用其中一个函数(如clickStream.map(F))时，它将根据单击流返回一个新流。它不会以任何方式修改原始点击流。这是一种被称为不变性的属性，它与反应性流一起使用，就像煎饼和糖浆一起吃一样。这允许我们链接诸如clickStream.map(F).scan(G)这样的函数：</p><p>  The  map(f) function replaces (into the new stream) each emitted value according to a function  f you provide. In our case, we mapped to the number 1 on each click. The  scan(g) function aggregates all previous values on the stream, producing value  x = g(accumulated, current), where  g was simply the add function in this example. Then,  counterStream emits the total number of clicks whenever a click happens.</p><p>Map(F)函数根据您提供的函数f替换(到新流中)每个发射值。在我们的示例中，我们在每次单击时都映射到数字1。Scan(G)函数聚合流上所有先前的值，产生值x=g(累积的，当前的)，其中g在本例中只是加法函数。然后，每当发生单击时，Counterstream都会发出总的单击次数。</p><p> To show the real power of Reactive, let&#39;s just say that you want to have a stream of &#34;double click&#34; events. To make it even more interesting, let&#39;s say we want the new stream to consider triple clicks as double clicks, or in general, multiple clicks (two or more). Take a deep breath and imagine how you would do that in a traditional imperative and stateful fashion. I bet it sounds fairly nasty and involves some variables to keep state and some fiddling with time intervals.</p><p>为了展示反应性的真正威力，让我们只说你想要有一系列的双击事件吧。为了让它更有趣，让我们假设我们希望新的流将三次点击视为双击，或者通常认为是多次点击(两次或更多)。深吸一口气，想象一下你将如何以传统的命令和有状态的方式做到这一点。我敢打赌，这听起来相当糟糕，而且涉及到一些保持状态的变量和一些摆弄时间间隔的因素。</p><p> Well, in Reactive it&#39;s pretty simple. In fact, the logic is just  4 lines of code.But let&#39;s ignore code for now. Thinking in diagrams is the best way to understand and build streams, whether you&#39;re a beginner or an expert.</p><p>嗯，在反应性方面，这是相当简单的。实际上，逻辑只有4行代码，但是让我们暂时忽略代码。无论您是初学者还是专家，用图表思考都是理解和构建流的最好方式。</p><p>  Grey boxes are functions transforming one stream into another. First we accumulate clicks in lists, whenever 250 milliseconds of &#34;event silence&#34; has happened (that&#39;s what  buffer(stream.throttle(250ms)) does, in a nutshell. Don&#39;t worry about understanding the details at this point, we are just demoing Reactive for now). The result is a stream of lists, from which we apply  map() to map each list to an integer matching the length of that list. Finally, we ignore  1 integers using the  filter(x &gt;= 2) function. That&#39;s it: 3 operations to produce our intended stream. We can then subscribe (&#34;listen&#34;) to it to react accordingly how we wish.</p><p>灰盒是将一个流转换为另一个流的函数。首先，我们在列表中累积点击，只要发生250毫秒的事件静默(简而言之，这就是Buffer(Stream.throttle(250ms))所做的事情)。不要担心在这一点上理解细节，我们现在只是演示反应性)。结果是一个列表流，我们从其中应用map()将每个列表映射到一个与该列表的长度匹配的整数。最后，我们使用FILTER(x&gt；=2)函数忽略1个整数。这就是：生产我们想要的流的3个操作。然后我们就可以订阅(收听)它来做出我们想要的相应反应。</p><p> I hope you enjoy the beauty of this approach. This example is just the tip of the iceberg: you can apply the same operations on different kinds of streams, for instance, on a stream of API responses; on the other hand, there are many other functions available.</p><p>我希望你喜欢这种方法的美感。这个示例只是冰山一角：您可以对不同类型的流应用相同的操作，例如，对API响应流应用相同的操作；另一方面，还有许多其他函数可用。</p><p>  Reactive Programming raises the level of abstraction of your code so you can focus on the interdependence of events that define the business logic, rather than having to constantly fiddle with a large amount of implementation details. Code in RP will likely be more concise.</p><p>反应式编程提高了代码的抽象级别，这样您就可以专注于定义业务逻辑的事件之间的相互依赖，而不必经常纠结于大量的实现细节。RP中的代码可能会更简洁。</p><p> The benefit is more evident in modern webapps and mobile apps that are highly interactive with a multitude of UI events related to data events. 10 years ago, interaction with web pages was basically about submitting a long form to the backend and performing simple rendering to the frontend. Apps have evolved to be more real-time: modifying a single form field can automatically trigger a save to the backend, &#34;likes&#34; to some content can be reflected in real time to other connected users, and so forth.</p><p>这一好处在与大量与数据事件相关的UI事件高度互动的现代Web应用程序和移动应用程序中更为明显。10年前，与网页的交互基本上是向后端提交一个很长的表单，然后向前端执行简单的渲染。应用程序已经向更实时的方向发展：修改单个表单域可以自动触发保存到后端，对某些内容的点赞可以实时反映给其他连接的用户，以此类推。</p><p> Apps nowadays have an abundancy of real-time events of every kind that enable a highly interactive experience to the user. We need tools for properly dealing with that, and Reactive Programming is an answer.</p><p>如今的应用程序拥有丰富的各种实时事件，为用户提供了高度互动的体验。我们需要工具来恰当地处理这一问题，而反应式编程就是答案。</p><p>  Let&#39;s dive into the real stuff. A real-world example with a step-by-step guide on how to think in RP. No synthetic examples, no half-explained concepts. By the end of this tutorial we will have produced real functioning code, while knowing why we did each thing.</p><p>让我们一头扎进真正的东西里吧。这是一个真实世界的例子，有一个关于如何用RP思考的循序渐进的指南。没有人工合成的例子，没有半解的概念。在本教程结束时，我们将生成真正有效的代码，同时了解我们为什么要做每件事。</p><p> I picked  JavaScript and   RxJS as the tools for this, for a reason: JavaScript is the most familiar language out there at the moment, and the  Rx* library family is widely available for many languages and platforms ( .NET,  Java,  Scala,  Clojure,  JavaScript,  Ruby,  Python,  C++,  Objective-C/Cocoa,  Groovy, etc). So whatever your tools are, you can concretely benefit by following this tutorial.</p><p>我选择JavaScript和RxJS作为工具是因为：JavaScript是目前最熟悉的语言，Rx*库家族广泛适用于多种语言和平台(.NET、Java、Scala、Clojure、JavaScript、Ruby、Python、C++、Objective-C/Cocoa、Groovy等)。因此，无论您的工具是什么，您都可以通过遵循本教程获得具体的好处。</p><p>     On click &#39;x&#39; button on an account row, clear only that current account and display another</p><p>单击帐户行上的按钮时，仅清除该当前帐户并显示另一个帐户。</p><p> We can leave out the other features and buttons because they are minor. And, instead of Twitter, which recently closed its API to the unauthorized public, let&#39;s build that UI for following people on Github. There&#39;s a  Github API for getting users.</p><p>我们可以省略其他功能和按钮，因为它们是次要的。而且，与其最近关闭其API对未经授权的公众开放的Twitter，不如让我们为在Github上关注用户构建用户界面。有一个Github API可以用来获取用户。</p><p> The complete code for this is ready at  http://jsfiddle.net/staltz/8jFJH/48/ in case you want to take a peak already.</p><p>这方面的完整代码已经在http://jsfiddle.net/staltz/8jFJH/48/上准备好了，如果您想要达到峰值的话。</p><p>  How do you approach this problem with Rx? Well, to start with, (almost)  everything can be a stream. That&#39;s the Rx mantra. Let&#39;s start with the easiest feature: &#34;on startup, load 3 accounts data from the API&#34;. There is nothing special here, this is simply about (1) doing a request, (2) getting a response, (3) rendering the response. So let&#39;s go ahead and represent our requests as a stream. At first this will feel like overkill, but we need to start from the basics, right?</p><p>您如何使用Rx解决此问题？嗯，首先，(几乎)一切都可以是溪流。这就是处方咒语。让我们从最简单的功能开始：在启动时，从API加载3个帐户数据。这里没有什么特别的，这只是(1)执行请求，(2)获取响应，(3)呈现响应。因此，让我们继续并将我们的请求表示为流。乍一看，这感觉有点矫枉过正，但我们需要从基础做起，对吗？</p><p> On startup we need to do only one request, so if we model it as a data stream, it will be a stream with only one emitted value. Later, we know we will have many requests happening, but for now, it is just one.</p><p>在启动时，我们只需要执行一个请求，所以如果我们将其建模为数据流，那么它将是一个只有一个发送值的流。稍后，我们知道会有许多请求发生，但目前，这只是一个请求。</p><p>  This is a stream of URLs that we want to request. Whenever a request event happens, it tells us two things: when and what. &#34;When&#34; the request should be executed is when the event is emitted. And &#34;what&#34; should be requested is the value emitted: a string containing the URL.</p><p>这是我们要请求的URL流。每当请求事件发生时，它都会告诉我们两件事：时间和内容。&#34；何时&#34；应该执行请求的时间是事件发出时。并且&#34；应该请求的是发出的值：包含URL的字符串。</p><p> To create such stream with a single value is very simple in Rx*. The official terminology for a stream is &#34;Observable&#34;, for the fact that it can be observed, but I find it to be a silly name, so I call it  stream.</p><p>在Rx*中，使用单个值创建这样的流非常简单。流的官方术语是&#34；Observable&#34；，因为它可以被观察到，但我觉得它是一个愚蠢的名字，所以我称它为流。</p><p>  But now, that is just a stream of strings, doing no other operation, so we need to somehow make something happen when that value is emitted. That&#39;s done by  subscribing to the stream.</p><p>但是现在，这只是一个字符串流，不做其他操作，所以我们需要在发出该值时以某种方式使某些事情发生。这是通过订阅流来实现的。</p><p>  Notice we are using a jQuery Ajax callback (which we assume you  should know already) to handle the asynchronicity of the request operation. But wait a moment, Rx is for dealing with  asynchronous data streams. Couldn&#39;t the response for that request be a stream containing the data arriving at some time in the future? Well, at a conceptual level, it sure looks like it, so let&#39;s try that.</p><p>注意，我们使用jQuery Ajax回调(假设您已经知道)来处理请求操作的异步性。但请稍等片刻，Rx用于处理异步数据流。该请求的响应不能是包含将来某个时间到达的数据的流吗？嗯，在概念层面上，它看起来确实很像，所以让我们试一试吧。</p><p> requestStream . subscribe ( function ( requestUrl )  {  // execute the request  var  responseStream  =  Rx . Observable . create ( function  ( observer )  {  jQuery . getJSON ( requestUrl )  . done ( function ( response )  {  observer . onNext ( response ) ;  } )  . fail ( function ( jqXHR ,  status ,  error )  {  observer . onError ( error ) ;  } )  . always ( function ( )  {  observer . onCompleted ( ) ;  } ) ;  } ) ;  responseStream . subscribe ( function ( response )  {  // do something with the response  } ) ; }</p><p>RequestStream。SUBSCRIBE(function(RequestUrl){//执行请求var responseStream=Rx。看得见。CREATE(函数(观察者){jQuery.。GetJSON(RequestUrl)。完成(函数(响应){观察者。OnNext(响应)；})。FAIL(Function(jqXHR，Status，Error){观察者。OnError(Error)；})。Always(Function(){观察者。OnCompleted()；})；})；ResponseStream。Subscribe(function(Response){//对响应做点什么})；}。</p><p> What   Rx.Observable.create() does is create your own custom stream by explicitly informing each observer (or in other words, a &#34;subscriber&#34;) about data events ( onNext()) or errors ( onError()). What we did was just wrap that jQuery Ajax Promise.  Excuse me, does this mean that a Promise is an Observable?</p><p>Rx.Observable.create()所做的是通过显式通知每个观察者(或者换句话说，订阅者)有关数据事件(onNext())或错误(onError())的数据事件(onNext())或错误(onError())来创建您自己的定制流。我们所做的只是包装jQuery Ajax承诺。打扰一下，这是不是意味着承诺就是可遵守的？</p><p>    Observable is Promise++. In Rx you can easily convert a Promise to an Observable by doing  var stream = Rx.Observable.fromPromise(promise), so let&#39;s use that. The only difference is that Observables are not  Promises/A+ compliant, but conceptually there is no clash. A Promise is simply an Observable with one single emitted value. Rx streams go beyond promises by allowing many returned values.</p><p>可观察的是Promise++。在Rx中，您可以通过执行var stream=Rx.Observable.FromPromise(Promise)轻松地将承诺转换为可观察对象，所以让我们使用它。唯一的区别是，可观测对象不符合Promises/A+，但在概念上没有冲突。承诺只是一个具有单一发射值的可观察物。RX流允许许多返回值，超出了承诺。</p><p> This is pretty nice, and shows how Observables are at least as powerful as Promises. So if you believe the Promises hype, keep an eye on what Rx Observables are capable of.</p><p>这是相当不错的，并且显示了可观测性至少和承诺一样强大。因此，如果你相信承诺的炒作，请密切关注Rx观察者的能力。</p><p> Now back to our example, if you were quick to notice, we have one  subscribe() call inside another, which is somewhat akin to callback hell. Also, the creation of  responseStream is dependent on  requestStream. As you heard before, in Rx there are simple mechanisms for transforming and creating new streams out of others, so we should be doing that.</p><p>现在回到我们的示例，如果您很快注意到的话，我们在另一个调用中有一个Subscribe()调用，这有点类似于回调地狱。此外，ResponseStream的创建依赖于requestStream。正如您以前听到的，在Rx中有一些简单的机制可以转换其他流并创建新的流，所以我们应该这样做。</p><p> The one basic function that you should know by now is   map(f), which takes each value of stream A, applies  f() on it, and produces a value on stream B. If we do that to our request and response streams, we can map request URLs to response Promises (disguised as streams).</p><p>到目前为止，您应该知道的一个基本函数是map(F)，它获取流A的每个值，对其应用f()，然后在流B上生成值。如果我们对请求流和响应流执行此操作，则可以将请求URL映射到响应承诺(伪装成流)。</p><p>  Then we will have created a beast called &#34; metastream&#34;: a stream of streams. Don&#39;t panic yet. A metastream is a stream where each emitted value is yet another stream. You can think of it as  pointers: each emitted value is a  pointer to another stream. In our example, each request URL is mapped to a pointer to the promise stream containing the corresponding response.</p><p>然后，我们将创建一个名为#34；metastream&#34；的野兽：一条溪流。先别惊慌失措。传输流是一个流，其中每个发射值都是另一个流。您可以将其视为指针：每个发出的值都是指向另一个流的指针。在我们的示例中，每个请求URL被映射到一个指向包含相应响应的承诺流的指针。</p><p>  A metastream for responses looks confusing, and doesn&#39;t seem to help us at all. We just want a simple stream of responses, where each emitted value is a JSON object, not a &#39;Promise&#39; of a JSON object. Say hi to  Mr. Flatmap: a version of  map() that &#34;flattens&#34; a metastream, by emitting on the &#34;trunk&#34; stream everything that will be emitted on &#34;branch&#34; streams. Flatmap is not a &#34;fix&#34; and metastreams are not a bug, these are really the tools for dealing with asynchronous responses in Rx.</p><p>响应的转移流看起来令人困惑，而且似乎对我们一点帮助都没有。我们只需要一个简单的响应流，其中发出的每个值都是一个JSON对象，而不是JSON对象的承诺。向Flatmap先生问好：MAP()的一个版本，它通过在主干上发射将在分支上发射的所有流来扁平传输流。Flatmap不是修复程序，传输流也不是bug，它们确实是用来处理Rx中异步响应的工具。</p><p>   Nice. And because the response stream is defined according to request stream,  if we have later on more events happening on request stream, we will have the corresponding response events happening on response stream, as expected:</p><p>不错啊。因为响应流是根据请求流定义的，所以如果稍后我们有更多的事件发生在请求流上，我们就会像预期的那样在响应流上发生相应的响应事件：</p><p>  Now that we finally have a response stream, we can render the data we receive:</p><p>现在我们终于有了响应流，我们可以呈现我们收到的数据了：</p><p>   var  requestStream  =  Rx . Observable . just ( &#39;https://api.github.com/users&#39; ) ; var  responseStream  =  requestStream  . flatMap ( function ( requestUrl )  {  return  Rx . Observable . fromPromise ( jQuery . getJSON ( requestUrl ) ) ;  } ) ; responseStream . subscribe ( function ( response )  {  // render `response` to the DOM however you wish } ) ;</p><p>Var requestStream=Rx。看得见。只需(#39；https://api.github.com/users&#39；)；var responseStream=requestStream。FlatMap(function(RequestUrl){return Rx.。看得见。FromPromise(jQuery.。GetJSON(RequestUrl))；})；responseStream。Subscribe(function(Response){//Render`Response`随心所欲地访问DOM})；</p><p>  I did not yet mention that the JSON in the response is a list with 100 users. The API only allows us to specify the page offset, and not the page size, so we&#39;re using just 3 data objects and wasting 97 others. We can ignore that problem for now, since later on we will see how to cache the responses.</p><p>我还没有提到响应中的JSON是一个包含100个用户的列表。API只允许我们指定页面偏移量，而不是页面大小，所以我们只使用了3个数据对象，浪费了97个其他数据对象。我们现在可以忽略该问题，因为稍后我们将了解如何缓存响应。</p><p> Everytime the refresh button is clicked, the request stream should emit a new URL, so that we can get a new response. We need two things: a stream of click events on the refresh button (mantra: anything can be a stream), and we need to change the request stream to depend on the refresh click stream. Gladly, RxJS comes with tools to make Observables from event listeners.</p><p>每次单击刷新按钮时，请求流都应该发出一个新的URL，这样我们就可以获得一个新的响应。我们需要两件事：刷新按钮上的单击事件流(咒语：任何东西都可以是流)，并且我们需要更改请求流以依赖于刷新点击流。令人高兴的是，RxJS附带了一些工具，可以从事件侦听器获得可观察性。</p><p>  Since the refresh click event doesn&#39;t itself carry any API URL, we need to map each click to an actual URL. Now we change the request stream to be the refresh click stream mapped to the API endpoint with a random offset parameter each time.</p><p>因为刷新单击事件本身不携带任何API URL，所以我们需要将每次单击映射到一个实际的URL。现在，我们将请求流更改为每次使用随机偏移量参数映射到API端点的刷新点击流。</p><p> var  requestStream  =  refreshClickStream  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } ) ;</p><p>Var requestStream=fresh hClickStream。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；返回&#39；https://api.github.com/users?since=&#39；+随机偏移；})；</p><p> Because I&#39;m dumb and I don&#39;t have automated tests, I just broke one of our previously built features. A request doesn&#39;t happen anymore on startup, it happens only when the refresh is clicked. Urgh. I need both behaviors: a request when  either a refresh is clicked  or the webpage was just opened.</p><p>因为我很笨，而且我没有自动测试，所以我刚刚破坏了我们之前构建的一个功能。请求在启动时不再发生，它只在单击刷新时发生。呃。我需要这两种行为：单击刷新或刚刚打开网页时的请求。</p><p>  var  requestOnRefreshStream  =  refreshClickStream  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } ) ;  var  startupRequestStream  =  Rx . Observable . just ( &#39;https://api.github.com/users&#39; ) ;</p><p>Var requestOnRechresStream=fresh hClickStream。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；Return&#39；https://api.github.com/users?since=&#39；+随机偏移；})；var启动pRequestStream=Rx。看得见。只要(#39；https://api.github.com/users&#39；)；</p><p> But how can we &#34;merge&#34; these two into one? Well, there&#39;s   merge(). Explained in the diagram dialect, this is what it does:</p><p>但是我们怎样才能把这两件事合而为一呢？嗯，这是Merge()。用图表方言解释，它是这样做的：</p><p>   var  requestOnRefreshStream  =  refreshClickStream  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } ) ;  var  startupRequestStream  =  Rx . Observable . just ( &#39;https://api.github.com/users&#39; ) ; var  requestStream  =  Rx . Observable . merge (  requestOnRefreshStream ,  startupRequestStream ) ;</p><p>Var requestOnRechresStream=fresh hClickStream。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；Return&#39；https://api.github.com/users?since=&#39；+随机偏移；})；var启动pRequestStream=Rx。看得见。只需(#39；https://api.github.com/users&#39；)；var requestStream=Rx。看得见。Merge(requestOnRechresStream，StartupRequestStream)；</p><p>  var  requestStream  =  refreshClickStream  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } )  . merge ( Rx . Observable . just ( &#39;https://api.github.com/users&#39; ) ) ;</p><p>Var requestStream=fresh hClickStream。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；返回&#39；https://api.github.com/users?since=&#39；+随机偏移；})。合并(处方。看得见。就(#39；https://api.github.com/users&#39；)；</p><p>  var  requestStream  =  refreshClickStream  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } )  . startWith ( &#39;https://api.github.com/users&#39; ) ;</p><p>Var requestStream=fresh hClickStream。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；返回&#39；https://api.github.com/users?since=&#39；+随机偏移；})。开始(#39；https://api.github.com/users&#39；)；</p><p> The   startWith() function does exactly what you think it does. No matter how your input stream looks like, the output stream resulting of  startWith(x) will have  x at the beginning. But I&#39;m not  DRY enough, I&#39;m repeating the API endpoint string. One way to fix this is by moving the  startWith() close to the  refreshClickStream, to essentially &#34;emulate&#34; a refresh click on startup.</p><p>StartWith()函数的作用与您认为的完全相同。无论您的输入流是什么样子，startWith(X)得到的输出流的开头都是x。但是我还不够干，我正在重复API终结点字符串。解决这个问题的一种方法是将startWith()移到接近fresh hClickStream的位置，实质上模拟启动时的刷新单击。</p><p> var  requestStream  =  refreshClickStream . startWith ( &#39;startup click&#39; )  . map ( function ( )  {  var  randomOffset  =  Math . floor ( Math . random ( )* 500 ) ;  return  &#39;https://api.github.com/users?since=&#39;  +  randomOffset ;  } ) ;</p><p>Var requestStream=fresh hClickStream。StartWith(启动单击)。Map(function(){var随机偏移=数学。地板(数学。Random()*500)；返回&#39；https://api.github.com/users?since=&#39；+随机偏移；})；</p><p> Nice. If you go back to the point where I &#34;broke the automated tests&#34;, you should see that the only difference with this last approach is that I added the  startWith().</p><p>好的。如果回到我破坏自动化测试的地方，您应该会看到，最后一种方法的唯一区别是我添加了startWith()。</p><p>  Until now, we have only touched a  suggestion UI element on the rendering step that happens in the responseStream&#39;s  subscribe(). Now with the refresh button, we have a problem: as soon as you click &#39;refresh&#39;, the current 3 suggestions are not cleared. New suggestions come in only after a response has arrived, but to make the UI look nice, we need to clean out the current suggestions when clicks happen on the refresh.</p><p>到目前为止，我们只在ResponseStream的Subscribe()的呈现步骤中触及了Suggest UI元素。现在使用“刷新”按钮，我们遇到了一个问题：一旦您单击“刷新”，当前的3条建议就不会被清除。新的建议只有在响应到达后才会出现，但是为了使UI看起来更美观，我们需要在刷新时清除当前的建议。</p><p>  No, not so fast, pal. This is bad, because we now have  two subscribers that affect the suggestion DOM elements (the other one being  responseStream.subscribe()), and that doesn&#39;t really sound like  Separation of concerns. Remember the Reactive mantra?</p><p>不，别这么快，伙计。这很糟糕，因为我们现在有两个影响建议DOM元素的订阅者(另一个是responseStream.scribe())，这听起来并不像是关注点分离。还记得那句反应性的咒语吗？</p><p>   So let&#39;s model a suggestion as a stream, where each emitted value is the JSON object containing the suggestion data. We will do this separately for each of the 3 suggestions. This is how the strea</p><p>因此，让将建议建模为流，其中发出的每个值都是包含建议数据的JSON对象。我们将针对这3个建议中的每一个分别执行此操作。这就是这条街是如何。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/反应式/">#反应式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reactive/">#reactive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/事件/">#事件</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030894.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c95c6640c04b0b64f58812e5c40b98fc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030894.html">安全系统编程为何生锈</a></div><span class="my_story_list_date">2020-10-24 8:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030555.html"><img src="http://img2.diglog.com/img/2020/10/thumb_66677dbb1fb90331051acf350be81b57.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030555.html">循序渐进：增量编程</a></div><span class="my_story_list_date">2020-10-22 22:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030394.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2c2bdfa2dc7529c1988bef213a9e80ef.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030394.html">Kite将其AI代码完成从2种扩展到13种编程语言</a></div><span class="my_story_list_date">2020-10-22 9:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029787.html"><img src="http://img2.diglog.com/img/2020/10/thumb_e53752bd18d47c7f19ff44e8b34448be.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029787.html">如何学习编程：成为软件工程师的路线图</a></div><span class="my_story_list_date">2020-10-19 20:54</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>