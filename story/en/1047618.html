<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go中的块分析 Block Profiling in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Block Profiling in Go<br/>Go中的块分析 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-10 00:20:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/431df62be2f4c604dc62513a6e7d1011.png"><img src="http://img2.diglog.com/img/2021/2/431df62be2f4c604dc62513a6e7d1011.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Permalink       This document was last updated for  go1.15.7 but probably still applies to older/newer versions for the most parts.</p><p>永久链接本文档最后一次更新是针对go1.15.7，但在大多数情况下仍可能适用于旧/新版本。</p><p>    The block profile in Go lets you analyze how much time your program spends waiting on the blocking operations listed below:</p><p>    Go中的阻止配置文件可让您分析程序等待以下阻止操作所花费的时间：</p><p>  Time is only tracked when Go has to suspend the goroutine&#39;s execution by parking it into a  waiting state. So for example a  Mutex.Lock() operation will not show up in your profile if the lock can be aquired immediately or via a short amount of  spinning.</p><p>  仅当Go必须通过将goroutine停在等待状态来中止执行goroutine的执行时，才会跟踪时间。因此，例如，如果可以立即或通过少量旋转来获取锁，则Mutex.Lock（）操作将不会显示在您的配置文件中。</p><p> The operations above are a subset of the  waiting states used by the Go runtime, i.e. the operations below  will not show up in a block profile:</p><p> 上面的操作是Go运行时使用的等待状态的子集，即下面的操作不会显示在块配置文件中：</p><p>    The block profiler is disabled by default. You can enable it by passing a  rate &gt; 0 as shown below.</p><p>    默认情况下，块分析器是禁用的。您可以通过传递速率＆gt;来启用它。 0如下图所示。</p><p>  The  rate impacts the  Accuracy and  Overhead of the profiler. In the  docs the rate is described like this:</p><p>  速率影响探查器的准确性和开销。在文档中，速率的描述如下：</p><p> SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</p><p> SetBlockProfileRate控制在阻止配置文件中报告的goroutine阻止事件的比例。探查器的目的是平均每阻塞1纳秒的速率采样一次阻塞事件。 </p><p> To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &lt;= 0.</p><p>要将每个阻止事件包括在配置文件中，合格率=1。要完全关闭分析，合格率＆lt; = 0。</p><p> Personally I struggle to parse the second sentence, and prefer to describe the  rate (aka  blockprofilerate) like this instead:</p><p> 就我个人而言，我很难解析第二句话，而是更喜欢这样描述速率（aka blockprofilerate）：</p><p> rate =&gt; 2 sets the sampling rate in  nanoseconds. Every event with a  duration &gt;= rate will be tracked. For events with a  duration &lt; rate, the profiler will  randomly sample  duration / rate events. E.g. if you have an event with a duration of  100ns and your rate is  1000ns, there is a  10% chance it will be tracked by the block profiler.</p><p> 比率=＆gt; 2设置采样率（以纳秒为单位）。持续时间＆gt; =速率的每个事件都将被跟踪。对于持续时间＆lt;速率，探查器将随机采样持续时间/速率事件。例如。如果您有一个持续时间为100ns的事件，并且您的速率为1000ns，则块分析器将有10％的机会对其进行跟踪。</p><p> Block durations are aggregated over the lifetime of the program (while the profiling is enabled). To get a  pprof formated snapshot of the current stack traces that lead to blocking events and their cumulative time duration, you can call:</p><p> 块持续时间会在程序的整个生命周期内汇总（启用概要分析时）。要获取导致堆栈事件及其累积持续时间的当前堆栈跟踪的pprof格式快照，可以调用：</p><p>  Alternatively you can use  github.com/pkg/profile for convenience, or  net/http/pprof to expose profiling via http, or use a  continious profiler to collect the data automatically in production.</p><p>  另外，为方便起见，您可以使用github.com/pkg/profile或net / http / pprof通过http公开分析，或使用连续分析器在生产中自动收集数据。</p><p> Last but not least you can use the   runtime.BlockProfile API to get the same information in a structured format.</p><p> 最后但并非最不重要的一点是，您可以使用runtime.BlockProfile API以结构化格式获取相同的信息。</p><p>  tl;dr: A  blockprofilerate &gt;=  10000 (10µs) should have negligable impact on production apps, including those suffering from extreme contention.</p><p>  tl； dr：块配置率＆gt; = 10000（10µs）对生产应用程序（包括遭受极端竞争的应用程序）的影响应忽略不计。 </p><p>  Block profiling is essentially implemented like this inside of the Go runtime (see the links in the  Description above for real code):</p><p>块分析基本上是在Go运行时内部实现的（有关实际代码，请参见上面的说明中的链接）：</p><p> func  chansend( ...) {  var  t0  int64  if  blockprofilerate  &gt;  0 {  t0  =  cputicks() }  // ... park goroutine in waiting state while blocked ...  if  blockprofilerate  &gt;  0 {  cycles  :=  cputicks()  -  t0  if  blocksampled( cycles) {  saveblockevent( cycles) } }}</p><p> func chansend（...）{如果blockprofilerate＆gt;则为var t0 int64； 0 {t0 = cputicks（）} // ...在阻塞状态下将goroutine停在等待状态...如果blockprofilerate＆gt; 0 {周期：= cputicks（）-如果blocksampled（周期）{saveblockevent（周期）}}}</p><p> This means that unless you enable block profiling, the overhead should be effectively zero thanks to CPU branch prediction.</p><p> 这意味着除非启用块分析，否则由于CPU分支预测，开销应实际上为零。</p><p> When block profiling is enabled, every blocking operation will pay the overhead of two  cputicks() calls. On  amd64 this is done via  optimized assembly using the  RDTSC instruction and takes a negligible  ~10ns/op on  my machine. On other platforms various alternative clock sources are used which may have higher overheads and lower accuracy.</p><p> 启用块分析后，每个阻止操作将支付两次cputicks（）调用的开销。在amd64上，这是通过使用RDTSC指令进行优化的汇编来完成的，并且在我的计算机上的耗费约为10ns / op。在其他平台上，使用了各种替代时钟源，这些时钟源可能具有更高的开销和更低的精度。</p><p> Depending on the configured  blockprofilerate (more about this in the  Accuracy section) the block event may end up getting saved. This means a stack trace is collected which takes  ~1µs on  my machine (stackdepth=16). The stack is then used as a key to update an  internal hashmap by incrementing the corresponding   blockRecord count and cycles.</p><p> 根据配置的块轮廓速率（“精度”部分中的更多信息），块事件可能最终会被保存。这意味着收集的堆栈跟踪在我的机器上大约需要1µs（堆栈深度= 16）。然后，通过增加相应的blockRecord计数和周期，将堆栈用作更新内部哈希图的键。</p><p>  The costs of updating the hash map is probably similar to collecting the stack traces, but I haven&#39;t measured it yet.</p><p>  更新哈希图的成本可能与收集堆栈跟踪信息相似，但是我尚未对其进行测量。</p><p>  Anyway, what does all of this mean in terms of overhead for your application? It generally means that block profiling is  low overhead. Unless your application spends literally all of its time parking and unparking goroutines due to contention, you probably won&#39;t be able to see a measurable impact even when sampling every block event.</p><p>  无论如何，这对于您的应用程序的开销而言意味着什么？通常，这意味着块分析的开销很低。除非您的应用程序由于争用而在字面上全部花费时间来停泊和取消goroutine，否则即使对每个块事件进行采样，您也将无法看到可测量的影响。 </p><p> That being said, the benchmark results below (see  Methodology) should give you an idea of the  theoretical worst case overhead block profiling could have. The graph  chan(cap=0) shows that setting  blockprofilerate from  1 to  1000 on a  workload that consists entirely in sending tiny messages across unbuffered channels decreases throughput significantly. Using a buffered channel as in graph  chan(cap=128) greatly reduces the problem to the point that it probably won&#39;t matter for real applications that don&#39;t spend all of their time on channel communication overheads.</p><p>话虽这么说，下面的基准测试结果（请参阅方法论）应该使您对开销块分析可能具有的理论上最坏情况有所了解。图表chan（cap = 0）显示，在完全包含通过无缓冲通道发送微小消息的工作负载上，将blockprofilerate从1设置为1000会大大降低吞吐量。使用图chan（cap = 128）中的缓冲通道可以极大地减少问题，以至于对于不花所有时间在通道通信开销上的实际应用来说，这可能无关紧要。</p><p> It&#39;s also interesting to note that I was unable to see significant overheads for   mutex based workloads. I believe this is due to the fact that mutexes employe spin locks before parking a goroutine when there is contention. If somebody has a good idea for a workload that exhibits high non-spinning mutex contention in Go, please let me know!</p><p> 还要有趣的是，我看不到基于互斥量的工作负载的大量开销。我认为这是由于存在争用时互斥锁在存放goroutine之前先使用了自旋锁。如果有人对在Go中表现出高非旋转互斥锁争用的工作负载有个好主意，请告诉我！</p><p> Anyway, please remember that the graphs below show workloads that were specifically designed to trigger the worst block profiling overhead you can imagine. Real applications will usually see no significant overhead, especially when using a  blockprofilerate &gt;=  10000 (10µs).</p><p> 无论如何，请记住，下图显示了专门设计用来触发您可以想象的最坏的数据块分析开销的工作负载。实际的应用程序通常不会看到明显的开销，特别是在使用块配置率> == 10000（10µs）时。</p><p>   Block profiling utilizes a shared hash map that  uses  1.4 MiB of memory even when empty. Unless you explicitly  disable heap profiling in your application, this map will get allocated regardless of whether you use the block profiler or not.</p><p>   块分析利用共享哈希图，即使空间为空，它也使用1.4 MiB的内存。除非您在应用程序中明确禁用堆分析，否则无论是否使用块分析器，都将分配此映射。</p><p> Addtionally each unique stack trace will take up some additional memory. The  BuckHashSys field of   runtime.MemStats allows you to inspect this usage at runtime. In the future I might try to provide additional information about this along with real world data.</p><p> 另外，每个唯一的堆栈跟踪都将占用一些额外的内存。 runtime.MemStats的BuckHashSys字段允许您在运行时检查此用法。将来，我可能会尝试提供有关此方面的其他信息以及现实世界的数据。</p><p>  The first call to  runtime.SetBlockProfileRate() takes  100ms because it tries to  measure the speed ratio between the wall clock and the  TSC clock. However, recent changes around async preemption have  broken this code, so the call is taking only  ~10ms right now.</p><p>  第一次调用runtime.SetBlockProfileRate（）需要100毫秒，因为它试图测量挂钟和TSC时钟之间的速度比。但是，有关异步抢占的最新更改已破坏了此代码，因此该调用现在仅需要10毫秒。</p><p>   tl;dr: Setting your sampling  rate too high will bias your results towards infrequent long events over frequent short events.</p><p>   tl; dr：将采样率设置得太高会使您的结果偏向于不经常发生的长事件而不是频繁发生的短事件。 </p><p>    func  blocksampled( cycles  int64)  bool {	 rate  :=  int64( atomic. Load64( &amp; blockprofilerate))	 if  rate  &lt;=  0  || ( rate  &gt;  cycles  &amp;&amp;  int64( fastrand()) % rate  &gt;  cycles) {		 return  false	}	 return  true}</p><p>func blocksampled（循环int64）bool {如果速率＆lt; = 0 ||，则速率== int64（原子。Load64（＆amp; blockprofilerate））。 （比率＆gt;周期＆amp;＆amp; int64（fastrand（））％比率＆gt;周期）{return false} return true}</p><p> This means that if you set your profiling  rate low enough, you&#39;ll get very accurate results. However, if your  rate is higher than the  duration of some of the events you are sampling, the sampling process will exhibit a bias favoring infrequent events of higher  duration over frequent events with lower  duration even so they may contribute to the same amount of overall block duration in your program.</p><p> 这意味着，如果将配置率设置得足够低，您将获得非常准确的结果。但是，如果您的速率高于您要采样的某些事件的持续时间，则采样过程将出现偏向，即偏向于具有较高持续时间的偶发事件而不是具有较低持续时间的频繁事件，即使它们可能对相同数量的总体阻止起作用程序的持续时间。</p><p>    Given this scenario, the  blockprofiler is guaranteed to catch and accurately report event  A as  100ns in the profile. For event  B the most likely outcome is that the profiler will capture only a single event (10% of 10 events) and report  B as  10ns in the profile. So you might find yourself in a situation where you think event  A is causing 10x more blocking than event  B, which is not true.</p><p>    在这种情况下，可以保证blockprofiler在配置文件中捕获并准确报告事件A为100ns。对于事件B，最有可能的结果是，事件探查器将仅捕获单个事件（10个事件中的10％），并将B报告为事件10ns。因此，您可能会发现自己认为事件A导致的阻塞比事件B多10倍，这是不正确的。</p><p>  For an even better intuition about this, consider the  simulated example below. Here we have a histogram of all durations collected from 3 types of blocking events. As you can see, they all have different mean durations ( 1000ns,  2000ns,  3000ns) and they are occurring at different frequencies, with  count(a) &gt; count(b) &gt; count(c). What&#39;s more difficult to see, is that the cumulative durations of these events are the same, i.e.  sum(a) = sum(b) = sum(c), but you can trust me on that : ).</p><p>  为了获得更好的直觉，请考虑下面的模拟示例。在这里，我们从3种阻塞事件中收集了所有持续时间的直方图。如您所见，它们都具有不同的平均持续时间（1000ns，2000ns，3000ns），并且它们以不同的频率发生，且count（a）数（b）＆gt;计数（c）。更难看到的是这些事件的累积持续时间是相同的，即sum（a）= sum（b）= sum（c），但是您可以相信我：)。</p><p>  So given that your application might produce events like this, how will they show up in your block profile as you try out different  blockprofilerate values? As you can see below, all is well and fine until a  blockprofilerate of  1000ns. Each event shows up with the same total duration in the profile (the red and green dots are hidden below the blue ones). However starting at  1000ns you see that event  a starts to fade from our profile and at  2000ns you&#39;d already think that events  b and  c are causing twice as much blocking time as event  a.</p><p>  因此，假设您的应用程序可能会产生这样的事件，那么当您尝试不同的blockprofilerate值时，它们将如何显示在您的区块文件中？如下所示，一切正常，直到达到1000ns的块轮廓速率为止。每个事件在配置文件中以相同的总持续时间显示（红色和绿色的点隐藏在蓝色的下面）。但是，从1000ns开始，您会看到事件a开始从我们的配置文件中消失，而在2000ns，您已经认为事件b和c造成的阻塞时间是事件a的两倍。</p><p>  So what can we do? Do we always need to live in fear of bias when working with block profiles? No! If the  Overhead for your workload allows it, the simplest solution is to use a low enough  blockprofilerate in order to capture most blocking events.</p><p>  所以，我们能做些什么？在使用块轮廓时，是否总是需要担心偏见吗？没有！如果您的工作负载开销允许的话，最简单的解决方案是使用足够低的块概要速率来捕获大多数阻塞事件。</p><p> But perhaps there is an even better way. I&#39;m thinking we could correct for the current bias by keeping the same logic of sampling  duration / rate fraction of events when  duration &lt; rate. However, when this happens we could simply multiply the sampled duration like this:</p><p> 但是也许还有更好的方法。我认为我们可以通过在持续时间＆lt;＆lt;＆lt;率。但是，发生这种情况时，我们可以像这样简单地乘以采样持续时间： </p><p> duration = duration * (rate/duration)# note: the expression above can be simplified to just `duration = rate`</p><p>持续时间=持续时间*（速率/持续时间）＃注意：以上表达式可以简化为“持续时间=速率”</p><p> Doing so could be done with a  trivial patch to the go runtime and the picture below shows the results from simulating it. So from my point of view it should be possible to eliminate this bias from future versions of Go and I&#39;m planning to work with the Go project on that.</p><p> 可以使用go运行时的普通补丁来做到这一点，下面的图片显示了模拟它的结果。因此，从我的角度来看，应该有可能消除Go的未来版本中的这种偏见，并且我计划在该版本上与Go项目一起工作。</p><p> That being said, I&#39;m not trained in statistics, so my analysis here might be hilariously misguided  🙃.</p><p> 话虽这么说，我没有接受过统计学方面的培训，所以我在这里的分析可能会被误导🙃。</p><p>  🚧 It might be possible to reduce the bias in block profiles after recording them. I&#39;ve got a  proof of concept for this, but it&#39;s not clear yet if this will work well in practice.</p><p>  recording记录下来之后，可能可以减少块轮廓中的偏差。我已经对此进行了概念验证，但是尚不清楚这在实践中是否能很好地工作。</p><p>  amd64 and other platforms use  TSC for implementing the  cputicks() function. This technique has been historically challenged by problems with frequency scaling and other kinds of CPU power transitions. Modern CPUs should provide invariant TSCs, but at  least some Go users are still reporting issues. I can&#39;t tell whether those are due to broken hardware or issues regarding multi-socket systems, but hope to do more research on this in the future.</p><p>  amd64和其他平台使用TSC来实现cputicks（）函数。过去，此技术一直受到频率缩放和其他类型的CPU电源转换问题的挑战。现代CPU应该提供不变的TSC，但是至少某些Go用户仍在报告问题。我无法确定原因是由于硬件损坏还是与多路插座系统有关的问题，但希望将来对此做更多的研究。</p><p> Please also note the bug description in the  Initialization Time section which may impact the accuracy of converting cputicks to wall clock time.</p><p> 另请注意“初始化时间”部分中的错误描述，这可能会影响将cputicks转换为墙上时钟时间的准确性。</p><p>  The max stack depth for block profiles is  32. Block events occurring at deeper stack depths will still be included in the profile, but the resulting data might be more difficult to work with.</p><p>  块概要文件的最大堆栈深度为32。在较深的堆栈深度处发生的块事件仍将包含在概要文件中，但是生成的数据可能更难处理。 </p><p>  As described earlier, contended Go mutexes will first try to  spin for a bit before yielding to the scheduler. If the spinning is successful, no block event will be tracked. This presents another subtle bias in the block profiler towards events of longer duration.</p><p>如前所述，有争议的Go互斥锁将首先尝试旋转一下，然后屈服于调度程序。如果旋转成功，则不会跟踪任何块事件。这在块剖析器中对持续时间较长的事件提出了另一个细微的偏差。</p><p> 🚧 This section needs more research that I&#39;ll do as part of my mutex profiler note.</p><p> section这部分需要做更多的研究，作为互斥量分析器注释的一部分。</p><p>  Blocking time is not bound by wall clock time. Multiple goroutines can simultaneously spend time blocking, which means it&#39;s possible to see profiles with a cumulative block duration that exceeds the runtime of the program.</p><p>  阻塞时间不受挂钟时间限制。多个goroutine可以同时花费时间进行阻塞，这意味着可以查看累积的块持续时间超过程序运行时间的配置文件。</p><p>  The  mutex profiling feature in Go overlaps with block profiling. It seems like both can be used to understand mutex contention. When using the mutex profiler it will report the  Unlock() call sites rather than the  Lock() call sites reported by the block profiler. The mutex profiler also uses a simpler and probably unbiased sampling mechanism which should make it more accurate. However, the mutex profiler does not cover channel contention, so the block profiler is a bit more flexible. When the mutex and block profiler are both enabled, it seems likely that some overhead will be wasted on tracking duplicate contention events.</p><p>  Go中的互斥锁分析功能与块分析重叠。似乎两者都可以用来理解互斥争用。使用互斥量探查器时，它将报告Unlock（）调用站点，而不是块探查器报告的Lock（）调用站点。互斥锁探查器还使用了一种更简单且可能无偏的采样机制，这应该使其更加准确。但是，互斥锁探查器不涵盖通道争用，因此块探查器更加灵活。启用互斥量和块分析器后，跟踪重复的争用事件可能会浪费一些开销。</p><p> 🚧 This section needs more research that I&#39;ll do as part of my mutex profiler notes.</p><p> section这部分需要做更多的研究，作为互斥量分析器注释的一部分。</p><p>  The block profiler does not support  profiler labels right now, but it seems like this might be easy to implement in the future.</p><p>  块探查器目前不支持探查器标签，但似乎将来可能很容易实现。</p><p>  Below is an example of block profile encoded in  pprof&#39;s protobuf format. There are two value types:</p><p>  下面是以pprof的protobuf格式编码的块配置文件的示例。有两种值类型： </p><p>   $ go tool pprof -raw block.pb.gz PeriodType: contentions countPeriod: 1Time: 2021-02-08 14:53:53.243777 +0100 CETSamples:contentions/count delay/nanoseconds 22820 867549417: 1 2 3 4 22748 453510869: 1 2 5 4 Locations 1: 0x10453af M=1 runtime.selectgo /usr/local/Cellar/go/1.15.6/libexec/src/runtime/select.go:511 s=0 2: 0x10d082b M=1 main.simulateBlockEvents /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:71 s=0 3: 0x10d0b72 M=1 main.eventB /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:57 s=0 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:33 s=0 4: 0x10d01b8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0 5: 0x10d0b12 M=1 main.eventA /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:53 s=0 main.run.func1 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:30 s=0Mappings1: 0x0/0x0/0x0 [FN]</p><p>$ go工具pprof -raw block.pb.gz PeriodType：争用计数周期：1时间：2021-02-08 14：53：53.243777 +0100 CETS样本：争用/计数延迟/纳秒22820 867549417：1 2 3 4 22748 453510869：1 2 5 4位置1：0x10453af M = 1运行时.selectgo /usr/local/Cellar/go/1.15.6/libexec/src/runtime/select.go:511 s = 0 2：0x10d082b M = 1 main.simulateBlockEvents / Users /felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:71 s = 0 3：0x10d0b72 M = 1 main.eventB /Users/felix.geisendoerfer /go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:57 s = 0 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com /felixge/go-profiler-notes/examples/block-sample/main.go:33 s = 0 4：0x10d01b8 M = 1 golang.org/x/sync/errgroup.(*Group).Go.func1 / Users / felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go：57 s = 0 5：0x10d0b12 M = 1 main.eventA / Users / felix。 geisendoerfer / go / src / github.com / felixge / go-profile r-notes / examples / block-sample / main.go：53 s = 0 main.run.func1 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block- sample / main.go：30 s = 0Mappings1：0x0 / 0x0 / 0x0 [FN]</p><p>  Block profiling was  implemented by  Dmitry Vyukov and first appeared in the  go1.1 release (2013-05-13).</p><p>  区块剖析由Dmitry Vyukov实现，并首次出现在go1.1版本（2013-05-13）中。</p><p>  I work at  Datadog on  Continuous Profiling for Go. You should check it out. We&#39;re also  hiring : ).</p><p>  我在Datadog上进行Go的连续分析。你应该检查一下。我们也正在招聘：）。</p><p> The information on this page is believed to be correct, but no warranty is provided. Feedback is welcome!</p><p> 该页面上的信息被认为是正确的，但不提供任何保修。欢迎反馈！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/felixge/go-profiler-notes/blob/main/block.md">https://github.com/felixge/go-profiler-notes/blob/main/block.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/分析/">#分析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/block/">#block</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/事件/">#事件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>