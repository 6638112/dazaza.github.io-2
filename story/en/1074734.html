<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>AMD分支（Mis）预测器：设置它，然后忘记它The AMD Branch (Mis)Predictor: Just Set It and Forget It</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The AMD Branch (Mis)Predictor: Just Set It and Forget It<br/>AMD分支（Mis）预测器：设置它，然后忘记它</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-23 22:13:03</div><div class="page_narrow text-break page_content"><p>In this blog article, we discuss some technical details of the AMD CPU branch predictor, focusing on its behavior with simple conditional branches. We also discuss how the behavior relates to exploitation of common and not so common Spectre v1 gadgets. As part of this discussion, we take a look at AMD&#39;s &#34; Software Techniques for Managing Speculation on AMD Processors&#34; white paper  [1] and evaluate the recommended mitigations (V1-1 to V1-3). Next, we implement a seemingly benign, artificial Spectre v1 gadget and exploit it as an easy-to-use arbitrary memory leak primitive. Finally, we reproduce the eBPF exploit described in the &#34; An Analysis of Speculative Type Confusion Vulnerabilities in the Wild&#34; paper  [2] to demonstrate the ease of exploiting such Spectre v1 gadgets on AMD CPUs (compared to Intel).</p><p>在这篇博客文章中，我们将讨论AMD CPU分支预测器的一些技术细节，重点讨论它在简单条件分支中的行为。我们还讨论了这种行为与利用常见和不常见的Spectre v1小工具的关系。作为讨论的一部分，我们来看看AMD&#39；s&#34；管理AMD处理器投机的软件技术&#34；白皮书[1]并评估建议的缓解措施（V1-1至V1-3）。接下来，我们实现了一个看似温和的人工幽灵v1小工具，并将其作为易于使用的任意内存泄漏原语加以利用。最后，我们复制了&#34；对野外投机型混乱脆弱性的分析#34；论文[2]展示了在AMD CPU（与英特尔相比）上开发此类Spectre v1小工具的易用性。</p><p> This article is highly technical with plenty of empirical data presented in the form of diagrams, charts and listings. An intermediate level of understanding the microarchitectural details of modern CPUs is assumed. Whenever applicable, a brief introduction to the discussed topics is provided.  Too much for you? Not a problem, check our  final remarks section for a TL;DR.</p><p>本文具有高度的技术性，以图表和列表的形式提供了大量的经验数据。假设对现代CPU的微体系结构细节有中等程度的理解。在适用的情况下，对讨论的主题进行简要介绍。对你来说太多了？没问题，请查看我们的最后评论部分，了解TL；博士</p><p> To make this article somewhat easier to consume and digest, we aim to follow a FAQ-like document structure. The discussed topics are gradually presented with an increasing level of detail. Hopefully, this unusual blog post structure works well with the technical material described.</p><p>为了使本文更易于阅读和消化，我们的目标是遵循类似FAQ的文档结构。讨论的主题逐渐呈现出越来越详细的内容。希望这个不寻常的博客帖子结构与所描述的技术材料配合得很好。</p><p> Enjoy yet another story featuring mispredicted branches, Spectre v1 gadgets and a PoC or two.</p><p>享受另一个关于预测失误的分支、幽灵v1小工具和一两个PoC的故事吧。</p><p>  Before this publication, we discussed our findings and observations with the AMD PSIRT team between January 7th and February 2nd 2022. AMD concluded they were all typical Spectre v1 scenarios and recommended applying mitigations as explained in their guide  [1]. AMD (understandably and consistent with other chip-makers) did not want to comment on their branch predictor design, nor, in our opinion, seem interested in performing a more thorough analysis of the reported behavior and its effects. Whether such an analysis had been performed already before or was performed after our report, we do not know.</p><p>在此之前，我们在2022年1月7日至2月2日期间与AMD PSIRT团队讨论了我们的发现和观察结果。AMD得出结论，它们都是典型的Spectre v1场景，并建议按照指南[1]中的解释应用缓解措施。AMD（可以理解，并与其他芯片制造商保持一致）不想对其分支预测器的设计发表评论，我们认为，似乎也没有兴趣对报告的行为及其影响进行更彻底的分析。我们不知道这种分析是在我们的报告之前进行的，还是在报告之后进行的。</p><p> Given this, we decided to investigate this issue thoroughly ourselves and present our research publicly here. We believe the suggested mitigations are impractical for the scenarios discussed in this article, for the reasons that the details below hopefully illuminate.</p><p>有鉴于此，我们决定亲自彻底调查这个问题，并在这里公开展示我们的研究成果。我们认为，对于本文讨论的场景，建议的缓解措施是不切实际的，因为下面的细节有望说明这些原因。</p><p>  The story began with a somewhat accidental, yet unexpected observation. At one point I asked myself: &#34;Can a trivially computable, memory-access-free and likely latency-free conditional branch be mispredicted? If it can, what would be the circumstances?&#34;. The answers to the questions were somewhat already given. There are many reasons why modern CPUs can mispredict any branch. Microarchitectural resource contention, branch instruction misalignment, cache line or page boundary splitting could be some of the reasons. On top of that, there is also the technique of deliberate branch mistraining for Spectre v1 gadget exploitation.</p><p>故事从一个有点意外但出人意料的观察开始。有一次我问自己：&#34；一个可计算、无内存访问且可能无延迟的条件分支是否会被预测失误？如果可以，情况会怎样&#34;. 这些问题的答案多少已经给出了。现代CPU会对任何分支进行错误预测的原因有很多。微体系结构资源争用、分支指令错位、缓存线或页面边界拆分可能是其中的一些原因。除此之外，还有一种故意对幽灵v1小工具进行分支误训练的技术。</p><p> However, many vendors and security practitioners seem to share the common misconception that Spectre v1 gadgets are mainly about out-of-bound array memory accesses and consist of array bound checks with variable computation latency (typically a memory access). Here, I was thinking of trivially computable conditional branches, whose conditions operands are immediately available in general purpose registers. Is it possible to have such branches mispredicted in a controllable manner? Does it have an impact on security? Let&#39;s find out.</p><p>然而，许多供应商和安全从业人员似乎都有一个共同的误解，即Spectre v1小工具主要是关于超出范围的阵列内存访问，由具有可变计算延迟（通常是内存访问）的阵列绑定检查组成。在这里，我想到的是可计算的条件分支，它的条件操作数在通用寄存器中立即可用。这样的分支是否可能以可控的方式预测失误？它对安全有影响吗？让&#39；让我们来看看。</p><p> I usually begin such research by implementing simple experiments using my favorite tool KTF (Kernel Test Framework  [3]), which I created a while ago with exactly such purposes in mind. KTF makes it easy to re-run the experiments in many different execution environments (bare-metal or virtualized) and comes with a few well-tested cache-based side-channel primitives.</p><p>我通常通过使用我最喜欢的工具KTF（Kernel Test Framework[3]）实现简单的实验来开始这类研究，我在不久前创建了KTF，正是出于这样的目的。KTF使在许多不同的执行环境（裸机或虚拟化）中重新运行实验变得很容易，并配备了一些经过良好测试的基于缓存的侧通道原语。</p><p>   0. mov $CACHE_LINE_ADDR, %rsi ; memory address whose access latency allows to observe the mispredictions1. clflush (%rsi) ;  flush the  cache line  out  of  cache  hierarchy  to  get a clean state 2. sfence 3. lfence ; make sure the  cache line  is really  out 4.  xor %rdi, %rdi ;  set ZF= 1 5. jz END_LABEL ; if ZF==1 goto END_LABEL6. mov (%rsi), %rax ; memory  load  to the flushed  cache line; it never executes architecturally7. END_LABEL:8. measure CACHE_LINE_ADDR access time</p><p>0.mov$CACHE_LINE_ADDR，%rsi；访问延迟允许观察预测失误的内存地址1。clflush（%rsi）；将缓存线从缓存层次结构中清除，以获得干净状态2。答案3。忠诚；确保缓存线真的在4之外。异或%rdi，%rdi；设置ZF=1.5。jz END_标签；如果ZF==1，则转到END_LABEL6。mov（%rsi），%rax；刷新缓存线的内存负载；它从不在架构上执行7。结束标签：8。测量缓存线地址访问时间</p><p> The question was: how many times can the trivial always-taken branch at location 5 be mispredicted?</p><p>问题是：位置5处的“总是执行”分支有多少次会被预测失误？</p><p> I ran the code ten times in a loop of 100k iterations and counted all low-latency accesses to  CACHE_LINE_ADDR, which were indicating a speculatively executed memory load. This is what I got:</p><p>我在一个100k次的循环中运行了十次代码，并统计了所有对CACHE_LINE_ADDR的低延迟访问，这表明推测执行的内存负载。这就是我得到的：</p><p> CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,Iterations  6,100000  2,100000  4,100000  6,100000  5,100000  4,100000  4,100000  6,100000  4,100000  7,100000Total:  48</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，迭代次数6100000 2100000 4100000 6100000 5100000 4100000 4100000 6100000 4100000 7100000总计：48</p><p> The column  CL0 (and  CL1 in later experiments) represents the number of times the measurement cache line has been speculatively loaded (i.e. the number of mispredictions) during  Iterations number of the main loop iterations, for every of the ten executions. The  Total is the sum of all the mispredictions that occurred.  Baseline is the average number of CPU ticks it takes to access memory data from cache.</p><p>列CL0（以及后面的实验中的CL1）表示在迭代过程中推测加载测量缓存线的次数（即预测失误的次数）主循环迭代的次数，对于十次执行中的每一次。总数是发生的所有预测失误的总和。Baseline是从缓存访问内存数据所需的平均CPU周期数。</p><p> I was not expecting this. A few irregular occurrences would not be shocking, but this was quite regular. The few years I spent in this field have taught me the hard way that this might not mean anything. There could be cache noise (e.g. due to frequent interrupts or sibling hyper-thread activity), a miscalculated baseline problem, fake signal due to floating vCPU of the VM I tested this on, or a gazillion of other reasons crippling the experiment.</p><p>我没想到会这样。一些不规则的事件并不令人震惊，但这是很正常的。我在这个领域度过的几年让我明白，这可能毫无意义。可能存在缓存噪音（例如，由于频繁中断或同级超线程活动）、基线计算错误、由于我测试的虚拟机的vCPU浮动而产生的假信号，或者大量其他原因破坏了实验。</p><p> To quickly rule out some of these, I tend to add another non-colliding measurement cache line and measure both of the cache lines during the experiment runtime. If the signal does not change accordingly and reliably the experiment detected noise.</p><p>为了快速排除其中一些，我倾向于添加另一个非冲突测量缓存线，并在实验运行时测量两个缓存线。如果信号没有相应且可靠地变化，则实验检测到噪声。</p><p> 0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. sfence 5. lfence ; make sure the  cache  lines  are really  out 6.  xor %rdi, %rdi ;  set ZF= 1 7. jz END_LABEL ; if ZF==1 goto END_LABEL8. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturally9. END_LABEL:A. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。忠诚；确保缓存线真的在6。异或%rdi，%rdi；设置ZF=17。jz END_标签；如果ZF==1，则转到END_LABEL8。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不在架构上执行9。结束标签：A.测量缓存线地址访问时间</p><p> I ran this code again in a loop of 100k iterations twice, each time using a different cache line at location 8. This is what I got for  %rsi:</p><p>我在100k次迭代的循环中再次运行了这段代码两次，每次都在位置8使用不同的缓存线。这是我为%rsi得到的：</p><p> CPU: AMD EPYC 7601 32-Core Processor Baseline: 200 CL0,CL1,Iterations  4, 0,100000  2, 0,100000  4, 0,100000  1, 0,100000  2, 0,100000  3, 0,100000  2, 0,100000  4, 0,100000  2, 0,100000  4, 0,100000 Total: 28</p><p>CPU:AMD EPYC 7601 32核处理器基线：200 CL0，CL1，迭代次数4，0100000 2，0100000 4，0100000 1，0100000 2，0100000 3，0100000 2，0100000 4，0100000 2，0100000 4，0100000总计：28</p><p> CPU: AMD EPYC 7601 32-Core Processor Baseline: 200 CL0,CL1,Iterations  0, 3,100000  0, 3,100000  0, 1,100000  0, 3,100000  0, 3,100000  0, 2,100000  0, 2,100000  0, 2,100000  0, 6,100000  0, 3,100000 Total: 28</p><p>CPU:AMD EPYC 7601 32核处理器基线：200 CL0，CL1，迭代次数0，3100000，3100000，1100000，3100000，3100000，3100000，2100000，2100000，2100000，2100000，6100000，3100000总计：28</p><p> At this point, I started to suspect that something might be really off, particularly since I also disabled interrupts for the loop ( cli/ sti) and made sure the system was idle.</p><p>在这一点上，我开始怀疑可能真的出了问题，特别是因为我还禁用了循环中断（cli/sti），并确保系统处于空闲状态。</p><p> On the other hand, it is expected that a conditional branch like the above gets mispredicted at least once during main loop execution. In the hypothetical, ideal case of a very clean state of the Branch Prediction Unit (BPU), a newly encountered conditional branch usually falls under the static predictor outcome ruling. It then decides what to do based on a default heuristic (e.g. new forward branch always taken and backward branch always not-taken or vice versa). If you wonder why there is any prediction in the first place for branches like these, there will be an answer later on.</p><p>另一方面，像上面这样的条件分支在主循环执行期间至少会出现一次预测失误。在分支预测单元（BPU）状态非常干净的假设理想情况下，新遇到的条件分支通常属于静态预测结果规则。然后，它根据默认的启发式（例如，始终采用新的前向分支，始终不采用后向分支，反之亦然）决定要做什么。如果你想知道为什么一开始会有这样的分支预测，那么稍后就会有答案。</p><p>  I quickly re-tested the same code on different CPUs I had access to. Some of them were Intel, others AMD, some server and others client parts. I was expecting the usual: different results on different machines, without any clearly visible pattern forming. But this time the unusual happened.</p><p>我很快在不同的CPU上重新测试了相同的代码。其中一些是英特尔，另一些是AMD，一些是服务器，还有一些是客户端。我期待着通常的结果：在不同的机器上得到不同的结果，没有任何清晰可见的图案形成。但这一次，不同寻常的事情发生了。</p><p> All AMD CPUs I tested it on displayed somewhat similar result patterns to the one presented above. Yet, all Intel CPUs displayed  no mispredictions at all, regardless of the cache line I used.</p><p>我测试过的所有AMD CPU都显示出与上面显示的有点类似的结果模式。然而，无论我使用的缓存线是什么，所有英特尔CPU都没有显示任何预测失误。</p><p> CPU: Intel(R) Core(TM) i9- 10980XE CPU @  3. 00GHzFrequency:  3000 MHzBaseline:  169CL0,CL1,Iterations  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0</p><p>CPU:Intel（R）Core（TM）i9-10980XE CPU@3。00GHZ频率：3000 MHZ基线：169CL0，CL1，迭代次数0，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000总计：0，0100000，0100000，0100000，0100000，0100000，0100000，0100000，0100000总计：0</p><p> It was getting interesting at this point. I double-checked that the memory access latency baseline was reasonable and that the cache oracle implementation still worked. I also made sure the code execution was pinned to a given logical CPU. I also re-ran the experiment with some deliberately incorrect baselines to see if I got noise, and I did.</p><p>这一点很有趣。我仔细检查了内存访问延迟基线是否合理，以及缓存oracle实现是否仍然有效。我还确保代码执行被固定在给定的逻辑CPU上。我还用一些故意不正确的基线重新运行了实验，看看是否有噪音，我做到了。</p><p> At this point, all signs pointed to there being something off with AMD CPUs and its mispredictions.</p><p>在这一点上，所有迹象都表明AMD的CPU及其预测失误有问题。</p><p> Since we are dealing with a branch misprediction leading to the speculative execution of a memory load, we can put a serializing instruction right after the branch to stop the speculative execution. Thereby, we can have better confidence about the observation, since there should be no signal whatsoever.</p><p>由于我们正在处理导致推测性执行内存加载的分支预测失误，我们可以在分支之后放置一条串行化指令来停止推测性执行。因此，我们可以对观察结果有更好的信心，因为不应该有任何信号。</p><p>   0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. sfence 5. lfence ; make sure the  cache  lines  are really  out 6.  xor %rdi, %rdi ;  set ZF= 1 7. jz END_LABEL ; if ZF==1 goto END_LABEL8. lfence ; on AMD lfence can be  set  to dispatch serializing  mode, which stops speculation 9. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturallyA. END_LABEL:B. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。忠诚；确保缓存线真的在6。异或%rdi，%rdi；设置ZF=17。jz END_标签；如果ZF==1，则转到END_LABEL8。忠诚；在AMD上，lfence可以设置为dispatch Serialization mode（调度序列化模式），从而停止推测9。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不执行架构。结束标签：B.测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代次数0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000总计：0</p><p> No signal as anticipated. At this point, I convinced myself that I was seeing a frequent branch misprediction of this trivial conditional branch happening  only on AMD CPUs and not on Intel CPUs.</p><p>没有预期的信号。在这一点上，我说服自己，我看到这个微不足道的条件分支的频繁分支预测失误只发生在AMD CPU上，而不是英特尔CPU上。</p><p>  To answer that, we need to learn a few things about the AMD branch predictor implementation. But before we do, let&#39;s run a few more experiments to get a better picture of the situation.</p><p>为了回答这个问题，我们需要了解一些有关AMD branch predictor实现的信息。但在此之前，让&#39；让我们再做几次实验，以便更好地了解情况。</p><p>   0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. sfence 5. lfence ; make sure the  cache  lines  are really  out 6.  xor %rdi, %rdi ;  set ZF= 1 7. lfence ; on AMD lfence can be  set  to dispatch serializing  mode, which stops speculation 8. jz END_LABEL ; if ZF==1 goto END_LABEL9. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturallyA. END_LABEL:B. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。忠诚；确保缓存线真的在6。异或%rdi，%rdi；设置ZF=17。忠诚；在AMD上，lfence可以设置为dispatch Serialization mode（调度串行化模式），从而停止推测。jz END_标签；如果ZF==1，则转到END_LABEL9。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不执行架构。结束标签：B.测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  6,  0,100000  5,  0,100000  7,  0,100000  8,  0,100000  12,  0,100000  6,  0,100000  9,  0,100000  10,  0,100000  8,  0,100000  9,  0,100000Total:  80  0,  6,100000  0,  7,100000  0,  8,100000  0,  9,100000  0,  5,100000  0,  7,100000  0,  8,100000  0,  8,100000  0,  8,100000  0,  9,100000Total:  75</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代次数6，0100000 5，0100000 7，0100000 8，0100000 12，0100000 6，0100000 9，0100000 10，0100000 8，0100000 9，0100000总数：80，61000000，7100000 0，8100000 0，9100000 0，5100000 0，7100000 0，8100000 0，8100000 0，8100000 9100000总计：75</p><p> It was a bit surprising to see a slight, but consistent increase of the misprediction rate as a result of placing the  lfence before the jump. Is the serialization somehow related to issue at hand?</p><p>由于在跳跃之前放置lfence，预测失误率出现了轻微但持续的增加，这有点令人惊讶。序列化是否与手头的问题有关？</p><p>   0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. sfence 5.  xor %rdi, %rdi ;  set ZF= 1 6. jz END_LABEL ; if ZF==1 goto END_LABEL7. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturally8. END_LABEL:9. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。异或%rdi，%rdi；设置ZF=16。jz END_标签；如果ZF==1，则转到END_LABEL7。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不在架构上执行8。结束标签：9。测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  1,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  1,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  1,  0,100000Total:  3  0,  1,100000  0,  0,100000  0,  1,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  1,100000  0,  1,100000  0,  0,100000  0,  1,100000Total:  5</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代次数1，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 1，0100000 0，总计：3101100000，0100000 0，1100000，0100000 0，0100000 0，1100000总计：5</p><p> It looked like the signal was still there, but noticeably weaker. Let&#39;s then remove the  sfence as well:</p><p>看起来信号仍然存在，但明显较弱。让&#39；s然后移除sfence：</p><p>  0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mis-predictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mis-predictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4.  xor %rdi, %rdi ;  set ZF= 1 5. jz END_LABEL ; if ZF==1 goto END_LABEL6. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturally7. END_LABEL:8. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察错误预测1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察错误预测2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。异或%rdi，%rdi；设置ZF=1.5。jz END_标签；如果ZF==1，则转到END_LABEL6。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不在架构上执行7。结束标签：8。测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000Total:  0</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代次数0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000总计：0</p><p> No signal at all! I was not expecting that. After all, the  sfence instruction should not be that relevant here; it is not serializing and it should not affect the branch misprediction at all. Quite the opposite, assuming the  sfence was required to make sure the cache lines are flushed. Without it, the signal should be (falsely) stronger. So at least the results obtained with and without the  sfence should indicate presence of the signal.</p><p>根本没有信号！我没料到。毕竟，sfence指令在这里不应该那么相关；它不是串行化的，并且完全不应该影响分支预测失误。相反，假设需要sfence来确保缓存线被刷新。如果没有它，信号应该（错误地）更强。因此，至少在有和没有sfence的情况下获得的结果应该表明信号的存在。</p><p> I was curious if the difference was just the result of a delay caused by the mere presence of the  sfence, or something else. So, I decided to try with another instruction that is neither serializing nor memory ordering. I decided to go with a  pause instruction for this purpose.</p><p>我很好奇，这种差异是否仅仅是因为有人在场而造成的延误，还是其他什么原因造成的。因此，我决定尝试使用另一条既不是序列化也不是内存排序的指令。为此，我决定使用暂停指令。</p><p>  0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. pause 5.  xor %rdi, %rdi ;  set ZF= 1 6. jz END_LABEL ; if ZF==1 goto END_LABEL7. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturally8. END_LABEL:9. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。暂停5。异或%rdi，%rdi；设置ZF=16。jz END_标签；如果ZF==1，则转到END_LABEL7。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不在架构上执行8。结束标签：9。测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  2,  0,100000  1,  0,100000  0,  0,100000  1,  0,100000  2,  0,100000  0,  0,100000  1,  0,100000  0,  0,100000  0,  0,100000  2,  0,100000Total:  9  0,  1,100000  0,  2,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  0,100000  0,  1,100000  0,  0,100000Total:  4</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代2，0100000 1，0100000 0，0100000 1，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 2，0100000总计：9，1100000，2100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，0100000 0，1100000，010000总计：4</p><p>   0. mov CACHE_LINE_0_ADDR, %rsi ; memory address 0 whose access latency allows to observe the mispredictions1. mov CACHE_LINE_1_ADDR, %rbx ; memory address 1 whose access latency allows to observe the mispredictions2. clflush (%rsi)3. clflush (%rbx) ;  flush  both  cache  lines  out  of  cache  hierarchy  to  get a clean state 4. mfence 5.  xor %rdi, %rdi ;  set ZF= 1 6. jz END_LABEL ; if ZF==1 goto END_LABEL7. mov (%rsi / %rbx), %rax ; memory  load  to the flushed  cache line; it never executes architecturally8. END_LABEL:9. measure CACHE_LINE_ADDR access time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。异或%rdi，%rdi；设置ZF=16。jz END_标签；如果ZF==1，则转到END_LABEL7。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不在架构上执行8。结束标签：9。测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  3,  0,100000  2,  0,100000  0,  0,100000  1,  0,100000  0,  0,100000  0,  0,100000  3,  0,100000  1,  0,100000  1,  0,100000  0,  0,100000Total:  11  0,  0,100000  0,  2,100000  0,  2,100000  0,  1,100000  0,  0,100000  0,  3,100000  0,  1,100000  0,  2,100000  0,  1,100000  0,  2,100000Total:  14</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代3，0100000 2，0100000 0，0100000 1，0100000 0，0100000 3，0100000 1，0100000 1，0100000 0，0100000 0，0100000总计：11000100000 0，2100000 0，2100000 0，2100000 0，1100000，0100000 0，3100000 0，1100000，2100000，11000002100000总计：14</p><p>   I was confused for a while, but a peek at the &#34; AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions&#34;  [4] section describing the  clflush instruction helped me understand. It turned out that the problem was caused by the weakly ordered  clflush instructions with respect to speculative memory loads.Let&#39;s quote the manual: &#34; [...] the CLFLUSH instruction is weakly ordered with respect to other instructions that operate on memory. Speculative loads initiated by the processor, or specified explicitly using cache-prefetch instructions, can be reordered around a CLFLUSH instruction. Such reordering can invalidate a speculatively prefetched cache line, unintentionally defeating the prefetch operation.&#34;</p><p>我困惑了一会儿，但瞥了一眼&#34；AMD64体系结构程序员手册第3卷：通用和系统说明&#34；[4] 描述clflush指令的部分帮助我理解。事实证明，这个问题是由弱序clflush指令引起的，这些指令与推测性内存加载有关。让&#39；让我们引用手册：&#34；[...] CLFLUSH指令相对于在内存上运行的其他指令是弱顺序的。处理器启动的推测性加载，或使用缓存预取指令显式指定的推测性加载，可以围绕CLFLUSH指令重新排序。这种重新排序可能会使推测预取的缓存线无效，从而无意中破坏预取操作&#34;</p><p> Apparently, this is what was happening here. The speculative load got reordered with the  clflush and executed before the flush. The  clflush instruction was unintentionally masking the signal. The manual also says:</p><p>显然，这就是这里发生的事情。推测负载在clflush中重新排序，并在clflush之前执行。clflush指令无意中屏蔽了信号。手册还说：</p><p> &#34; The only way to avoid this situation is to use the MFENCE instruction after the CLFLUSH instruction to force strong-ordering of the CLFLUSH instruction with respect to subsequent memory operations.&#34;</p><p>&#34; 避免这种情况的唯一方法是在CLFLUSH指令之后使用MFENCE指令，强制CLFLUSH指令对后续内存操作进行强排序&#34;</p><p> Here we go. From now on, we will be using the  mfence instruction to order the  clflush instructions&#39; execution properly.</p><p>开始了。从现在起，我们将使用mfence指令来订购clflush指令&#39；执行得当。</p><p>  So far, I was experimenting with forward always-taken branches. But the BPU may treat backward conditional branches differently. Let&#39;s take a look at backward always-taken branches now.</p><p>到目前为止，我一直在尝试向前移动的分支。但BPU可能会以不同的方式对待向后条件分支。让&#39；现在让我们来回顾一下过去一直以来的分支。</p><p> Similar to the previous experiments, I ran this one ten times in a loop of 100k iterations using the following backward conditional branch code construct:</p><p>与之前的实验类似，我使用以下向后条件分支代码构造，在100k次迭代的循环中运行了十次：</p><p>  0. mov CACHE_LINE_0_ADDR, %rsi ; memory address  0 whose access latency allows  to observe  the mispredictions 1. mov CACHE_LINE_1_ADDR, %rbx ; memory address  1 whose access latency allows  to observe  the mispredictions 2. clflush (%rsi) 3. clflush (%rbx) ; flush both cache  lines out  of cache hierarchy  to  get  a clean state 4. mfence 5. jmp BRANCH_LABEL ; go  to  the backward branch 6. RETURN_LABEL: ; this is  the backward branch target  7. jmp END_LABEL ; go  to  the measurements 8. ALIGN  64 ; This alignment construct serves  the purpose  of isolating  the backward  9. ud2 ; branch  from  the earlier branches. This is important, because  the density A. ALIGN  64 ;  of branches per cache  line matters.B. BRANCH_LABEL:C. xor %rdi, %rdi ;  set ZF= 1D. jz RETURN_LABEL ;  if ZF== 1 goto RETURN_LABELE. mov (%rsi / %rbx), %rax ; memory  load  to  the flushed cache  line;  it never executes architecturallyF. END_LABEL: 10. measure CACHE_LINE_ADDR access  time</p><p>0.移动缓存线0地址%rsi；内存地址0，其访问延迟允许观察预测失误1。mov缓存线地址%rbx；内存地址1，其访问延迟允许观察预测失误2。clflush（%rsi）3。clflush（%rbx）；清除缓存层次结构中的两条缓存线，以获得干净的状态4。第五章。jmp BRANCH_标签；到后面的分支6。返回标签：；这是向后分支目标7。jmp-END_标签；去测量8。对齐64；该对齐结构用于隔离后向9。ud2；从早期的分支中分支。这一点很重要，因为密度A.对准64；每个缓存线的分支数很重要。B.分支机构标签：C.异或%rdi，%rdi；设置ZF=1D。jz返回_标签；如果ZF==1，则转到返回标签。mov（%rsi/%rbx），%rax；刷新缓存线的内存负载；它从不执行架构。结束标签：10。测量缓存线地址访问时间</p><p>  CPU: AMD EPYC  7601  32-Core Processor Baseline:  200CL0,CL1,Iterations  2,  0,100000  2,  0,100000  0,  0,100000  1,  0,100000  2,  0,100000  1,  0,100000  1,  0,100000  1,  0,100000  3,  0,100000  1,  0,100000Total:  14  0,  1,100000  0,  1,100000  0,  4,100000  0,  2,100000  0,</p><p>CPU:AMD EPYC 7601 32核处理器基线：200CL0，CL1，迭代次数2，0100000 2，0100000 0，0100000 1，0100000 1，0100000 1，0100000 3，0100000 1，0100000 0总计：1401100000，1100000，4100000，2100000，</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/分支/">#分支</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/branch/">#branch</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>