<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>VIANILA-TODO：VIRENAL WEB开发可行技术的案例研究</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">VIANILA-TODO：VIRENAL WEB开发可行技术的案例研究</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 19:13:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/dc5f4272c181e4dde802bde3b25fa730.jpeg"><img src="http://img2.diglog.com/img/2020/10/dc5f4272c181e4dde802bde3b25fa730.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A  TeuxDeux clone in plain HTML, CSS and JavaScript(no build steps). It&#39;s fully animated and runs smoothly at 60 FPSwith a total transfer size of  44KB (unminified).</p><p>TeuxDeux在纯HTML、CSS和JavaScript中的克隆(没有构建步骤)。它是全动画的，以60fps流畅运行，总传输大小为44KB(未缩小)。</p><p>  More importantly, it&#39;s a case study showing that  vanilla web development isviable in terms of  maintainability,and worthwhile in terms of  user experience( 100% faster loads and  90% less bandwidth in this case).</p><p>更重要的是，它是一个案例研究，表明就可维护性而言，普通web开发是可行的，在用户体验方面也是值得的(在这种情况下，加载速度提高了100%，带宽减少了90%)。</p><p> There&#39;s no custom framework invented here.Instead, the case study was  designed to discoverminimum viable  patterns that are truly vanilla.The result is maintainable, albeit  verbose and withconsiderable duplication (most of which may be mitigated by ES6).</p><p>这里并没有发明定制的框架。相反，案例研究的目的是发现最小的可行模式，这些模式都是真正的香草。结果是可维护的，尽管冗长且有相当多的重复(ES6可能会减轻大部分重复的影响)。</p><p> If anything, the case study validates the value of build steps and frameworks,but also demonstrates that standard web technologies can be used effectively andthere are only a few  critical areas where a vanilla approach isclearly inferior (especially in browser testing).</p><p>如果说有什么不同的话，那就是案例研究验证了构建步骤和框架的价值，但也证明了标准Web技术可以得到有效利用，只有少数几个关键领域的普通方法明显逊色(特别是在浏览器测试中)。</p><p>     I believe too little has been invested in researchingpractical, scalable methods for building web applicationswithout third party dependencies.</p><p>我认为，在研究实用的、可伸缩的方法来构建无第三方依赖的Web应用程序方面投入的太少。</p><p> It&#39;s not enough to describe how to create DOM nodesor how to toggle a class without a framework.It&#39;s also rather harmful to write an articlesaying you don&#39;t need library X, and then proceed in describing howto roll your own untested, inferior version of X.</p><p>仅描述如何创建DOM节点或如何在没有框架的情况下切换类是不够的。写一篇文章说您不需要库X，然后继续描述如何运行您自己未经测试的低级版本X，这也是相当有害的。</p><p> What&#39;s missing are thorough examples of complex web applicationsbuilt only with standard web technologies, covering as many aspects ofthe development process as possible.</p><p>缺少的是仅使用标准Web技术构建的复杂Web应用程序的完整示例，尽可能多地涵盖开发过程的各个方面。</p><p> This case study is an attempt to fill this gap, at least a little bit,and inspire further research in the area.</p><p>这一案例研究试图填补这一空白，至少是一点点，并启发该领域的进一步研究。</p><p>      I&#39;ve chosen to build a functionally equivalent clone of TeuxDeux for this study.The user interface has interesting challenges,in particular performant drag &amp; drop when combined with animations.</p><p>为了这项研究，我选择构建一个功能相当的TeuxDeux克隆。用户界面面临着有趣的挑战，特别是在与动画结合时的性能拖放。</p><p> The user interface is arguably small (which is good for a case study)but large enough to require thought on its architecture.</p><p>用户界面可以说很小(这对案例研究很好)，但是足够大，需要考虑其体系结构。</p><p>    To produce valid vanilla solutions, and because constraints spark creativity,I came up with a set of rules to follow throughout the process:</p><p>为了产生有效的普通解决方案，并且因为约束激发创造力，我想出了一套在整个过程中要遵循的规则：</p><p>   (2) These usually end up becoming a custom micro-framework,thereby questioning why you didn&#39;t use one of theestablished and tested libraries/frameworks in the first place.</p><p>(2)这些通常最终会变成一个自定义的微框架，从而质疑您为什么不首先使用一个已建立并经过测试的库/框架。</p><p>    The resulting product should be comparable to or betterthan the original regarding functionality, performance and design.</p><p>由此产生的产品在功能、性能和设计方面应该与原始产品相当或更好。</p><p>        This section walks through the resulting implementation, highlighting techniquesand problems found during the process. You&#39;re encouraged to inspect the source code alongside this section.</p><p>本节将逐步介绍最终的实现，重点介绍在此过程中发现的技术和问题。我们鼓励您在本节旁边查看源代码。</p><p>  Since build steps are ruled out, the codebase is organized aroundplain HTML, CSS and JS files. The HTML and CSS mostly follows rscss (devised by  Rico Sta. Cruz)which yields an intuitive, component-oriented structure.</p><p>由于排除了构建步骤，代码库是围绕纯HTML、CSS和JS文件组织的。HTML和CSS主要遵循rscss(由Rico Sta设计。Cruz)，它产生了直观的、面向组件的结构。</p><p> The stylesheets are slightly verbose.I missed  SCSS or  LESS hereand I think one of these is a must-have for bigger projects.</p><p>样式表有点冗长，我在这里错过了SCSS或更少，我认为其中一个是大型项目的必备内容。</p><p> ES6 modules are ruled out so all JavaScript lives undera global namespace ( VT). This works everywhere but has some downsidese.g. cannot be statically analyzed and may miss code completion.</p><p>ES6模块被排除在外，因此所有JavaScript都位于全局命名空间(VT)之下。这在任何地方都行得通，但也有一些缺点。无法静态分析，可能会错过代码完成。</p><p> Polyfills are directly fetched from  polyfill.io.I&#39;ve set the  nomodule script attribute so polyfills are only fetchedfor older browsers.</p><p>多边形填充是直接从polyful.ioI&#39；获取的。我已经设置了noodule脚本属性，因此仅为较旧的浏览器提取多边形填充。</p><p> Basic code quality (code style, linting) is guided by Prettier,  stylelint and ESLint.I&#39;ve set the ESLint parser to ES5 to ensure only ES5 code is allowed.</p><p>基本代码质量(代码样式、线条)由Pretier、Styelint和ESLint指导。我已将ESLint解析器设置为ES5，以确保只允许ES5代码。</p><p> Note that I&#39;ve opted out of web components completely.I can&#39;t clearly articulate what I dislike about thembut I never missed them throughout this study.</p><p>请注意，我已经完全退出了Web组件。我无法清楚地表达我对它们的不喜欢之处，但在整个研究过程中，我从未错过过它们。</p><p>  The basic structure comes with some boilerplate,e.g. referencing all the individual stylesheets and scripts from the HTML;probably enough to justify a simple build step.</p><p>基本结构附带一些样板，例如引用HTML中的所有单个样式表和脚本；可能足以证明一个简单的构建步骤是合理的。</p><p> It is otherwise straight-forward and trivial to understand(literally just a bunch of HTML, CSS and JS files).</p><p>其他方面，理解起来都很简单和琐碎(字面上只有一堆HTML、CSS和JS文件)。</p><p>   I found that using a combination of functions,query selectors and DOM events is sufficientto build a scalable, maintainable codebase,albeit with some trade-offs as we will see later.</p><p>我发现组合使用函数、查询选择器和DOM事件就足以构建一个可伸缩、可维护的代码库，尽管如我们稍后将看到的那样需要进行一些权衡。</p><p> Conceptually, the proposed architecture loosely mapsCSS selectors to JS functions which are  mounted (i.e. called) onceper matching element. This yields a simple mental model and synergizeswith the DOM and styles:</p><p>从概念上讲，提出的体系结构松散地将CSS选择器映射到挂载(即称为)onceper匹配元素的JS函数。这就产生了一个简单的心理模型，并与DOM和样式产生了协同作用：</p><p>    Mount functions take a DOM element as their (only) argument.Their responsibility is to set up initial state, event listeners, andprovide behavior and rendering for the target element.</p><p>Mount函数将DOM元素作为(唯一)参数，它们的职责是设置初始状态、事件侦听器，并为目标元素提供行为和呈现。</p><p>  // safely initialize namespace window . MYAPP  =  window . MYAPP  ||  { } ; // define mount function // loosely mapped to &#34;.hello-world&#34; MYAPP . HelloWorld  =  function  ( el )  {  // define initial state  var  state  =  {  title:  &#39;Hello, World!&#39; ,  description:  &#39;An example vanilla component&#39; ,  counter:  0 ,  } ;  // set rigid base HTML  // no ES6 template literals :(  el . innerHTML  =  [  &#39;&lt;h1 class=&#34;title&#34;&gt;&lt;/h1&gt;&#39; ,  &#39;&lt;p class=&#34;description&#34;&gt;&lt;/p&gt;&#39; ,  &#39;&lt;div class=&#34;my-counter&#34;&gt;&lt;/div&gt;&#39; ,  ] . join ( &#39;\n&#39; ) ;  // mount sub-components  el . querySelectorAll ( &#39;.my-counter&#39; ) . forEach ( MYAPP . MyCounter ) ;  // attach event listeners  el . addEventListener ( &#39;modifyCounter&#39; ,  function  ( e )  {  update ( {  counter:  state . counter  +  e . detail  } ) ;  } ) ;  // expose public interface  // use lower-case function name  el . helloWorld  =  {  update:  update ,  } ;  // initial update  update ( ) ;  // define idempotent update function  function  update ( next )  {  // update state  // optionally optimize, e.g. bail out if state hasn&#39;t changed  Object . assign ( state ,  next ) ;  // update own HTML  el . querySelector ( &#39;.title&#39; ) . innerText  =  state . title ;  el . querySelector ( &#39;.description&#39; ) . innerText  =  state . description ;  // pass data to sub-scomponents  el . querySelector ( &#39;.my-counter&#39; ) . myCounter . update ( {  value:  state . counter ,  } ) ;  } } ; // define another component // loosely mapped to &#34;.my-counter&#34; MYAPP . MyCounter  =  function  ( el )  {  // define initial state  var  state  =  {  value:  0 ,  } ;  // set rigid base HTML  // no ES6 template literals :(  el . innerHTML  =  [  &#39;&lt;p&gt;&#39; ,  &#39; &lt;span class=&#34;value&#34;&gt;&lt;/span&gt;&#39; ,  &#39; &lt;button class=&#34;increment&#34;&gt;Increment&lt;/button&gt;&#39; ,  &#39; &lt;button class=&#34;decrement&#34;&gt;Decrement&lt;/button&gt;&#39; ,  &#39;&lt;/p&gt;&#39; ,  ] . join ( &#39;\n&#39; ) ;  // attach event listeners  el . querySelector ( &#39;.increment&#39; ) . addEventListener ( &#39;click&#39; ,  function  ( )  {  // dispatch an action  // use .detail to transport data  el . dispatchEvent (  new  CustomEvent ( &#39;modifyCounter&#39; ,  {  detail:  1 ,  bubbles:  true ,  } )  ) ;  } ) ;  el . querySelector ( &#39;.decrement&#39; ) . addEventListener ( &#39;click&#39; ,  function  ( )  {  // dispatch an action  // use .detail to transport data  el . dispatchEvent (  new  CustomEvent ( &#39;modifyCounter&#39; ,  {  detail:  - 1 ,  bubbles:  true ,  } )  ) ;  } ) ;  // expose public interface  // use lower-case function name  el . myCounter  =  {  update:  update ,  } ;  // define idempotent update function  function  update ( next )  {  Object . assign ( state ,  next ) ;  el . querySelector ( &#39;.value&#39; ) . innerText  =  state . value ;  } } ; // mount HelloWorld component(s) // any &lt;div class=&#34;hello-world&#34;&gt;&lt;/div&gt; in the document will be mounted document . querySelectorAll ( &#39;.hello-world&#39; ) . forEach ( MYAPP . HelloWorld ) ;</p><p>//安全初始化命名空间窗口。MYAPP=窗口。MYAPP||{}；//定义装载函数//松散映射到&#34；.hello-world&#34；MYAPP。HelloWorld=function(El){//定义初始状态var state={title：&#39；Hello，World！&#39；，description：&#39；A Example Vanilla Component&#39；，Counter：0，}；//设置刚性基础HTML//没有ES6模板文字：(EL.。InnerHTML=[&#39；&lt；h1class=&#34；title&#34；&gt；&lt；/h1&gt；&#39；，&#39；&lt；p class=&#34；description&#34；&gt；&lt；/p&gt；&#39；，&#39；&lt；div class=&#34；my-counter&#34；&gt；&lt；/div&gt；&#39；，]。Join(&#39；\n&#39；)；//挂载子组件el。QuerySelectorAll(.my-Counter&#39；)。For Each(MYAPP.。MyCounter)；//附加事件监听器el。AddEventListener(&#39；ModifyCounter&#39；，function(E){update({count：stat.。计数器+e。Detail})；})；//公开公共接口//使用小写函数名el。Helloworld={update：update，}；//初始更新update()；//定义幂等更新函数update(Next){//update state//可选优化，例如，如果状态没有更改对象，则退出。Assign(state，next)；//更新自己的HTML el。QuerySelector(&#39；.title&#39；)。InnerText=状态。头衔；头衔。QuerySelector(&#39；.description&#39；)。InnerText=状态。描述；//将数据传递给子组件e1。QuerySelector(&#39；.my-counter&#39；)。我的计数器。更新({值：状态。计数器，})；}}；//定义另一个组件//松散映射到&#34；.my-counter&#34；MYAPP。MyCounter=function(El){//定义初始状态var state={value：0，}；//设置刚性基础HTML//没有ES6模板文字：(el.。InnerHTML=[&#39；&lt；p&&gt;；&#39；，&#39；&lt；SPAN class=&#34；Value&34；&gt；&lt；/SPAN&&gt;；&#39；，&#39；&lt；按钮class=&#34；increment&#34；&gt；Increment&lt；/button&gt；&#39；，&#39；&lt；按钮class=&#34；decrement&#34；&gt；Decrement&lt；/button&gt；&#39；，&#39；&lt；/p&gt；&#39；，]。Join(&#39；\n&39；)；//附加事件侦听器el。QuerySelector(&#39；.increment&#39；)。AddEventListener(&#39；单击&#39；，function(){//调度操作//使用.Detail传输数据EL。DispatchEvent(new CustomEvent(&#39；modfyCounter&#39；，{Detail：1，气泡：true，}))；})；el。QuerySelector(&#39；.deducment&#39；)。AddEventListener(&#39；单击&#39；，function(){//调度操作//使用.Detail传输数据EL。DispatchEvent(new CustomEvent(&#39；modfyCounter&#39；，{Detail：-1，泡泡：true，}))；})；//公开公共接口//使用小写函数名el。MyCounter={update：update，}；//定义幂等更新函数update(Next){Object.。分配(州，下一个)；分配(州，下一个)。QuerySelector(&#39；.value&#39；)。InnerText=状态。Value；}}；//挂载HelloWorld组件//文档中的任何&lt；div class=&#34；hello-world&#34；&gt；&lt；/div&gt；将被挂载文档。QuerySelectorAll(.hello-world&#39；)。For Each(MYAPP.。你好世界)；</p><p> This comes with quite some boilerplate but has useful properties,as we will see in the following sections.</p><p>它附带了相当多的样板，但也有一些有用的属性，我们将在下面几节中看到。</p><p> Note that any part of a mount function is entirely optional.For example, a mount function does not have to set any base HTML,and may instead only set event listeners to enable some behavior.</p><p>请注意，mount函数的任何部分都是完全可选的。例如，mount函数不必设置任何基本HTML，而可以只设置事件侦听器来启用某些行为。</p><p> Also note that an element can be mounted with multiple mount functions.For example, to-do items are mounted with  VT.TodoItem and  VT.AppDraggable.</p><p>还要注意，一个元素可以使用多个挂载函数挂载，例如，待办事项使用VT.TodoItem和VT.AppDraggable挂载。</p><p> Compared to React components, mount functions provide interesting flexibility ascomponents and behaviors can be implemented using the same idiom and combinedarbitrarily.</p><p>与反应组件相比，挂载函数提供了有趣的灵活性，因为组件和行为可以使用相同的习惯用法实现，并且可以任意组合。</p><p>     Data flows downwards from parent components to child componentsthrough their public interfaces (usually  update functions).</p><p>数据通过它们的公共接口从父组件向下流到子组件(通常是更新函数)。</p><p> Actions flow upwards through custom DOM events (bubbling up),usually resulting in some parent component state change which is in turnpropagated downwards through  update functions.</p><p>操作通过自定义DOM事件向上流动(冒泡向上)，通常会导致一些父组件状态更改，而这些更改又会通过更新函数向下传播。</p><p> The data store is factored into a separate behavior ( VT.TodoStore).It only receives and dispatches events, and encapsulates all of the data logic.</p><p>数据存储被分解成一个单独的行为(VT.TodoStore)，它只接收和分派事件，并封装所有数据逻辑。</p><p> Listening to and dispatching events is slightly verbose with standard APIs andcertainly justifies introducing helpers.I didn&#39;t need event delegation à la jQuery for this studybut I believe it&#39;s a useful concept that is difficult to doconcisely with standard APIs.</p><p>使用标准API侦听和分派事件稍微有点冗长，这当然证明引入助手是合理的。我不需要像jQuery那样的事件委派来进行本研究，但我相信这是一个很有用的概念，使用标准API很难简明扼要地做到这一点。</p><p>    Naively re-rendering a whole component using  .innerHTML should be avoidedas this may hurt performance and will likely break important functionality suchas input state, focus, text selection etc. which browsers have already beenoptimizing for decades.</p><p>应该避免使用.innerHTML幼稚地重新呈现整个组件，因为这可能会影响性能，并且可能会破坏浏览器几十年来一直在优化的重要功能，如输入状态、焦点、文本选择等。</p><p> As seen in  3.2.1., rendering is therefore split intosome rigid base HTML and an idempotent, complete update function which onlymakes necessary changes.</p><p>如3.2.1.所示，渲染因此被分成一些刚性的基本HTML和一个幂等的、完整的更新函数，该函数只进行必要的更改。</p><p> Idempotency is key here, i.e. update functions may be called at any timeand should always render the component correctly.</p><p>幂等是这里的关键，即可以随时调用更新函数，并且应该始终正确地呈现组件。</p><p> Completeness is equally important, i.e. update functions should renderthe whole component, regardless of what triggered an update.</p><p>完整性同样重要，也就是说，无论是什么触发了更新，更新函数都应该呈现整个组件。</p><p> In effect, this means almost all DOM manipulation is done in update functions,which greatly contributes to robustness and readability of the codebase.</p><p>实际上，这意味着几乎所有的DOM操作都在更新函数中完成，这极大地提高了代码库的健壮性和可读性。</p><p> As seen above this approach is quite verbose and ugly compared to JSX, forexample. However, it&#39;s very performant and can be further optimizedby checking for data changes, caching selectors, etc.It is also simple to understand.</p><p>如上所述，与JSX相比，这种方法相当冗长和丑陋，例如。然而，它的性能非常好，可以通过检查数据更改、缓存选择器等来进一步优化。它也很容易理解。</p><p>    Expectedly, the hardest part of the study was rendering a variableamount of dynamic components efficiently. Here&#39;s a commented examplefrom the implementation outlining the reconciliation algorithm:</p><p>不出所料，这项研究最困难的部分是高效地呈现不同数量的动态组件。下面是一个来自实施的注释示例，概述了协调算法：</p><p> /* global VT */ window . VT  =  window . VT  ||  { } ; VT . TodoList  =  function  ( el )  {  var  state  =  {  items:  [ ] ,  } ;  el . innerHTML  =  &#39;&lt;div class=&#34;items&#34;&gt;&lt;/div&gt;&#39; ;  function  update ( next )  {  Object . assign ( state ,  next ) ;  var  container  =  el . querySelector ( &#39;.items&#39; ) ;  // mark current children for removal  var  obsolete  =  new  Set ( container . children ) ;  // map current children by data-key  var  childrenByKey  =  new  Map ( ) ;  obsolete . forEach ( function  ( child )  {  childrenByKey . set ( child . getAttribute ( &#39;data-key&#39; ) ,  child ) ;  } ) ;  // build new list of child elements from data  var  children  =  state . items . map ( function  ( item )  {  // find existing child by data-key  var  child  =  childrenByKey . get ( item . id ) ;  if  ( child )  {  // if child exists, keep it  obsolete . delete ( child ) ;  }  else  {  // otherwise, create new child  child  =  document . createElement ( &#39;div&#39; ) ;  child . classList . add ( &#39;todo-item&#39; ) ;  // set data-key  child . setAttribute ( &#39;data-key&#39; ,  item . id ) ;  // mount component  VT . TodoItem ( child ) ;  }  // update child  child . todoItem . update ( {  item:  item  } ) ;  return  child ;  } ) ;  // remove obsolete children  obsolete . forEach ( function  ( child )  {  container . removeChild ( child ) ;  } ) ;  // (re-)insert new list of children  children . forEach ( function  ( child ,  index )  {  if  ( child !==  container . children [ index ] )  {  container . insertBefore ( child ,  container . children [ index ] ) ;  }  } ) ;  }  el . todoList  =  {  update:  update ,  } ; } ;</p><p>/*全局VT*/Window。VT=窗口。|{}；vt.。TodoList=函数(El){var state={Items：[]，}；el.。InnerHTML=&#39；&lt；div class=&#34；Items&#34；&gt；&lt；/div&gt；&#39；；函数UPDATE(NEXT){对象。ASSIGN(STATE，NEXT)；var CONTAINER=el。QuerySelector(&#39；.Items&#39；)；//将当前子项标记为要删除var陈旧=new set(CONTAINER.。Child)；//按data-key映射当前子项var Child drenByKey=new Map()；废弃。ForEach(function(Child){ChildrenByKey。设置(子项。GetAttribute(&#39；data-key&#39；)，Child)；})；//从data var Children=state构建新的子元素列表。物品。Map(function(Item){//Find Existing Child by Data-Key var Child=ChildrenByKey。获取(项。Id)；如果(Child){//如果有Child，则将其作废。DELETE(CHILD)；}ELSE{//否则，创建新的子级CHILD=DOCUMENT。CreateElement(&#39；div&39；)；子元素。ClassList。添加(&#39；TODO-Item&#39；)；//设置数据键子项。SetAttribute(&#39；data-key&#39；，Item。Id)；//挂载组件VT。TodoItem(Child)；}//更新子级。图腾。Update({Item：Item})；返回子项；})；//删除作废的子项。ForEach(函数(子级){容器。RemoveChild(Child)；})；//(重新)插入新的子代子代列表。ForEach(function(Child，index){if(Child！==容器。子[索引]){容器。在前面插入(子项，容器。儿童[索引])；}})；}el。TodoList={update：update，}；}；</p><p> It&#39;s very verbose and has lots of opportunity to introduce bugs.Compared to a simple loop in JSX, this seems insane.It is quite performant as it does minimal work but is otherwise messy;definitely a candidate for a utility function or library.</p><p>它非常冗长，而且有很多机会引入错误。与JSX中的简单循环相比，这似乎是疯狂的。它的性能相当好，因为它只做最少的工作，但在其他方面是混乱的；绝对是实用函数或库的候选者。</p><p>   Using a library would have been a lot more cost-effective initially.However, having a customized implementation paid off once I startedintroducing animations as both had to be coordinated closely.I can imagine this would have been a difficult problemwhen using third party code for either.</p><p>最初使用库的性价比会高得多，但是，一旦我开始引入动画，定制的实现就得到了回报，因为两者都必须密切协调。我可以想象，当使用第三方代码时，这将是一个困难的问题。</p><p> The drag &amp; drop implementation is (again) based on DOM events and integrateswell with the remaining architecture.It&#39;s clearly the most complex part of the study but I was able to implement itwithout changing existing code besides mounting behaviors andadding event handlers.</p><p>拖放实现(再次)基于DOM事件，并与其余体系结构很好地集成。它显然是研究中最复杂的部分，但除了挂载行为和添加事件处理程序外，我能够在不更改现有代码的情况下实现它。</p><p> I suspect the drag &amp; drop implementation to have some subtle problems ontouch devices, as I haven&#39;t extensively tested them. Using a library foridentifying the gestures could be more sensible and would reduce costs intesting browsers and devices.</p><p>我怀疑拖放实现在触控设备上有一些微妙的问题，因为我还没有对它们进行广泛的测试。使用一个库来识别手势可能更明智，并将降低测试浏览器和设备的成本。</p><p>    For the final product I wanted smooth animations for most user interactions.This is a cross-cutting concern which was implemented using the FLIP technique as devisedby  Paul Lewis.</p><p>对于最终的产品，我希望大多数用户交互都有流畅的动画效果，这是一个横切的关注点，它是使用Paul Lewis设计的翻转技术实现的。</p><p> Implementing FLIP animations without a large refactoring was the biggestchallenge of this case study, especially in combination with drag &amp; drop.After days of work I was able to implement the algorithm in isolation andcoordinate it with other concerns at the application&#39;s root level.The  useCapture mode of  addEventListener proved to be very usefulin this case.</p><p>在不进行大型重构的情况下实现翻转动画是本案例研究的最大挑战，特别是与拖放结合使用时。经过几天的工作，我能够单独实现算法，并在应用程序的根级别将其与其他关注点协调起来。在这种情况下，addEventListener的use Capture模式被证明非常有用。</p><p>         Additionally, most interactions are smoothly animated at 60 frames per second.In particular, dragging and dropping gives proper visual feedbackwhen elements are reordered.</p><p>此外，大多数交互都以每秒60帧的速度流畅地设置动画。特别是，当元素重新排序时，拖放可以提供适当的视觉反馈。</p><p> The latter was an improvement over the original application when I startedworking on the case study some weeks ago. In the meantime, the TeuxDeuxteam released an update with a much better drag &amp; drop experience. Great job!</p><p>当我几周前开始做案例研究时，后者比最初的应用程序有了改进。与此同时，TeuxDeuxTeam发布了一个更新，提供了更好的拖放体验。干得好！</p><p> One notable missing feature is Markdown support. It would be insensibleto implement Markdown from scratch; this is a valid candidate for usingan external library as it is entirely orthogonal to the remaining codebase.</p><p>一个值得注意的缺失功能是对Markdown的支持。从头开始实现Markdown是不明智的；这是使用外部库的有效候选，因为它与剩余的代码库完全正交。</p><p>   A fresh load of the original TeuxDeux application transfers around  435 KB andfinishes loading at around  1000 ms, sometimes up to 2000ms(measured on 10/21 2020).Reloads finish at around  500ms.</p><p>原始TeuxDeux应用程序的新加载大约传输435 KB，并在大约1000毫秒左右完成加载，有时高达2000毫秒(在2020年10月21日测量)。重新加载大约在500毫秒完成。</p><p> With a transferred size of around  44 KB, the vanilla application consistentlyloads in  300-500 ms—not minified and with each script, stylesheet and iconserved as an individual file. Reloads finish at  100-200ms; again, notoptimized at all (with e.g. asset hashing/indefinite caching).</p><p>传输大小约为44KB时，Vanilla应用程序可以在300-500ms内一致加载，而不是缩小，每个脚本、样式表和图标都作为单独的文件。重新加载在100-200ms完成；同样，根本没有优化(例如，使用资产散列/无限缓存)。</p><p> To be fair, my implementation misses quite a few features from the original.I suspect a fully equivalent clone to be well below 100 KB transfer, though.</p><p>公平地说，我的实现遗漏了原始版本中的许多特性，不过我怀疑完全等效的克隆文件的传输大小远低于100KB。</p><p>   Unfortunately, it is quite hard to find undisputed, objective measurementsfor code quality (besides trivialities like code style, linting, etc.).The only generally accepted assessment seems to be peer reviewal.</p><p>不幸的是，很难找到无可争议的、客观的代码质量衡量标准(除了代码样式、linting等琐碎的东西之外)，唯一被普遍接受的评估似乎是同行评审。</p><p> To have at least some degree of assessment of the code&#39;s quality,the following sections summarize relevant facts about the codebaseand some opinionated statements based on my experience in the industry.</p><p>为了至少在一定程度上评估代码的质量，下面几节总结了关于代码库的相关事实，并根据我在该行业的经验总结了一些自以为是的声明。</p><p>  The app can be naturally enhanced from the outside by handling/dispatchingevents (just like you can naturally animate some existing HTML).</p><p>这个应用程序可以通过处理/分派事件从外部自然增强(就像你可以自然地制作一些现有的HTML动画一样)。</p><p> All source files (HTML, CSS and JS) combine to  under 2500 lines of code,including comments and empty lines.</p><p>所有源文件(HTML、CSS和JS)合并到2500行以下的代码，包括注释和空行。</p><p>  To be fair, my implementation misses quite a few features from the original.I suspect a fully equivalent clone to be well below 10000 LOC, though.</p><p>公平地说，我的实现遗漏了原始版本中相当多的功能，不过我怀疑完全等效的克隆版本会远低于10000 LOC。</p><p>  Although not used in this study,event delegation is not trivial to implement without code duplication.</p><p>虽然在本研究中没有使用事件委托，但是在没有代码重复的情况下实现事件委托并不是一件容易的事。</p><p> Eliminating verbosities through build steps and a minimal set of helperswould reduce the comparably low code size (see above) even further.</p><p>通过构建步骤和最小的帮助器集消除冗余将进一步减少相对较低的代码大小(见上文)。</p><p>  The separation between base HTML and dynamic rendering is not idealwhen compared to JSX, for example.</p><p>例如，与JSX相比，基本HTML和动态呈现之间的分离并不理想。</p><p>  Reconciliation is verbose, brittle and repetitive.I wouldn&#39;t recommend the proposed techniquewithout a well-tested helper function, at least.</p><p>协调是冗长、脆弱和重复的，我至少不会推荐在没有经过良好测试的助手功能的情况下提出的技术。</p><p> You have to remember mounting behaviors correctly whencreating new elements. It would be helpful to automate this somehow,e.g. watch elements of selector X (at all times) and ensure the desiredbehaviors are mounted once on them.</p><p>在创建新元素时，必须正确记住安装行为。以某种方式实现自动化会很有帮助，例如(始终)观察选择器X的元素，并确保所需的行为一次安装在它们上面。</p><p> No type safety. I&#39;ve always been a proponent of dynamic languagesbut since TypeScripts&#39; type system provides the best of both worlds,I cannot recommend using it enough.</p><p>没有类型安全。我一直都是动态语言的支持者，但既然打字系统两全其美，我就不推荐充分使用它。</p><p> We&#39;re effectively locked out of using NPM dependencies that don&#39;t providebrowser builds as we cannot use CommonJS or ES6 modules.</p><p>我们实际上被禁止使用不提供浏览器版本的NPM依赖项，因为我们不能使用CommonJS或ES6模块。</p><p> Most frameworks handle a lot of browser inconsistencies  for free andcontinuously monitor regressions with extensive test suites.The cost of browser testing is surely a lot higherwhen using a vanilla approach.</p><p>大多数框架免费处理大量的浏览器不一致问题，并通过大量的测试套件持续监控回归，使用普通的方法测试浏览器的成本肯定要高得多。</p><p>  Besides the issues described above, I believe the codebase is well organizedand there are clear paths for bugfixes and feature development.Since there&#39;s no third party code, bugs are easy to find and fix,and there are no dependency limitations to work around.</p><p>除了上述问题，我相信代码库组织良好，有明确的修复错误和功能开发的路径。由于没有第三方代码，因此很容易找到和修复错误，并且没有要解决的依赖限制。</p><p> A certain degree of DOM API knowledge is required but I believe thisshould be a goal for any web developer.</p><p>一定程度的DOM API知识是必需的，但我相信这应该是任何Web开发人员的目标。</p><p>  Assessing the generality of the discovered techniques objectively isnot really possible without production usage. From my experience, however,I can&#39;t imagine any scenario where mount functions, event-based data flow etc.are not applicable. The underlying principles power the established frameworks,after all:</p><p>如果没有生产使用，客观地评估所发现技术的通用性是不可能的。然而，根据我的经验，我无法想象有哪种场景不适用挂载函数、基于事件的数据流等。毕竟，基本原则为既定的框架提供了动力：</p><p>   The result of this study is a working todo application with decent UI/UX andmost of the functionality of the original TeuxDeux app,built using only standard web technologies.It comes with better overall performanceat a fraction of the code size and bandwidth.</p><p>这项研究的结果是一个可以工作的待办事项应用程序，它具有不错的UI/UX和原始TeuxDeux应用程序的大部分功能，该应用程序只使用标准的Web技术构建，整体性能更好，代码量和带宽只有一小部分。</p><p> The codebase seems manageable through a handful of simple concepts,although it is quite verbose and even messy in some areas.This could be mitigated by a small number of helper functions andsimple build steps (e.g. SCSS and TypeScript).</p><p>通过几个简单的概念，代码库似乎是可以管理的，尽管它在某些领域相当冗长甚至凌乱，这可以通过少量的帮助器函数和简单的构建步骤(例如，SCSS和TypeScript)来缓解。</p><p> The study&#39;s method helped discovering patterns and techniques thatare at least on par with a framework-based approach for the given subject,without diverging into building a custom framework.</p><p>这项研究的方法有助于发现模式和技术，这些模式和技术至少与特定主题的基于框架的方法相当，而不会偏离到构建自定义框架。</p><p> A notable exception to the latter is rendering variable numbers of elementsin a concise way. I was unable to eliminate the verbosity involvedin basic but efficient reconciliation.Further research is needed in this area, but for now this appears to bea valid candidate for a (possibly external) general-purpose utility.</p><p>后者的一个显著例外是以简明的方式呈现可变数量的元素。我无法消除基本但有效的协调所涉及的繁琐。这方面需要进一步的研究，但目前看来这是(可能是外部的)通用实用程序的有效候选者。</p><p> When looking at the downsides, remember that all of the individual parts areself-contained, highly decoupled, portable, and congruent to the web platform.The resulting implementation cannot &#34;rust&#34;, by definition, as no dependenciescan become out of date.</p><p>在考虑缺点时，请记住，所有单独的部分都是独立的、高度解耦的、可移植的，并且与Web平台一致。根据定义，由此产生的实现不能生锈，因为任何依赖项都不会过时。</p><p> Another thought to be taken with a grain of salt: I believe frameworksmake simple tasks even simpler, but hard tasks (e.g. implementing cross-cuttingconcerns or performance optimizations) often more difficult.</p><p>另一个要持保留态度的想法是：我认为框架使简单的任务变得更加简单，但困难的任务(例如，实现横切关注点或性能优化)往往更加困难。</p><p>  Setting some constraints up-front forced me to challengemy assumptions and preconceptions about vanilla web development.It was quite liberating to avoid general-purpose utilities andget things done with what&#39;s readily available.</p><p>预先设置一些约束迫使我挑战关于普通web开发的假设和先入为主的观念，避免通用的实用工具，用现成的东西来做事情，这是相当解放的。</p><p> As detailed in the assessment,the study would likely be more convincing if build steps were allowed.Modern JavaScript and SCSS could reduce most ofthe unnecessarily verbose parts to a minimum.</p><p>正如评估中详细描述的那样，如果允许构建步骤，研究可能会更有说服力。现代JavaScript和SCSS可以将大多数不必要的冗长部分减少到最低限度。</p><p> Finally, this case study does not question using dependencies or frameworksin general—they do provide lots of value in many areas.It was a constrained experiment designed to discover novel methodsfor vanilla web development and, hopefully,inspire innovation and further research in the area.</p><p>最后，这个案例研究不会质疑使用依赖关系或框架-它们确实在许多领域提供了很大的价值。这是一个受限的实验，旨在发现普通Web开发的新方法，并有望激励该领域的创新和进一步研究。</p><p>  I&#39;d love to hear feedback and ideas on any aspect of the case study.It&#39;s still lacking in some important areas, e</p><p>I‘我很乐意听取有关案例研究的任何方面的反馈和意见。它在一些重要的领域仍有欠缺，例如</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/morris/vanilla-todo">https://github.com/morris/vanilla-todo</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/todo/">#todo</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vanilla/">#vanilla</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031348.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fd35c42af2ed8b6df3654f6e8bf283ad.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031348.html">开发人员给自己的建议</a></div><span class="my_story_list_date">2020-10-27 6:22</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031242.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fbcaf123169b8dafcabb71982fd03a98.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031242.html">总部位于伦敦的PrimaryBid开发连接散户投资者和上市公司的软件，筹集4230万欧元的B系列资金</a></div><span class="my_story_list_date">2020-10-26 22:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031198.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7d2650058dc365736b30d405882e6fa8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031198.html">使用Terminal.gui用C#开发CLI音乐播放器(第一部分)</a></div><span class="my_story_list_date">2020-10-26 12:55</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031097.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c3efa904682e069f89569fb53a11a7f2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031097.html">为您的开发团队创建有效的教程</a></div><span class="my_story_list_date">2020-10-25 23:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>