<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重用标准RDF词汇 - 第1部分 Reusing Standard RDF Vocabularies – Part 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reusing Standard RDF Vocabularies – Part 1<br/>重用标准RDF词汇 - 第1部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 23:24:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/8f7c872731b6620dd23edad914cccdb0.jpeg"><img src="http://img2.diglog.com/img/2021/3/8f7c872731b6620dd23edad914cccdb0.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is a guest blog post by Adam Retter of   Evolved Binary , who is acting as consultant Technical Architect on Project Omega for The National Archives…</p><p>这是Adam Retter的Guest Blog Post作出的二进制文件，他是全国档案馆项目欧米茄的顾问技术架构师......</p><p>  In Phase 1 of Project Omega at TNA ( The National Archives) we evaluated several different existing models and vocabularies/ontologies to ascertain their suitability for expressing the data of TNA’s new Pan-Archival Catalogue. We published a fairly comprehensive report of our findings and proposed a way forward:  Catalogue Model Proposal.</p><p>  在TNA（国家档案馆）项目Omega的第1阶段，我们评估了几种不同现有的模型和词汇表/本体，以确定他们表达TNA新的Pan-Archival目录数据的适用性。我们出版了一份相当综合的考察报告，并提出了前进的方式：目录模型提案。</p><p> In summary, we felt that none of the existing models were perfect. We recognised that ICA’s RiC (International Council on Archives’ Record in Contexts) was very promising but currently under-developed for TNA’s needs. Ultimately, we felt that the approach taken in developing  The Matterhorn RDF Data Model had a lot of strengths and that we would take a similar path.</p><p> 总之，我们认为没有现有的模型是完美的。我们认识到，ICA的RIC（国际档案馆关于上下文中的档案记录）非常有前途，但目前为TNA的需求开发。最终，我们觉得在开发马特宏峰数据模型中采取的方法具有很大的优势，我们将采取类似的路径。</p><p>  attempt to adhere to the broader principles of  RiC’s Conceptual Model, but discard  RiC’s Ontology.</p><p>  试图遵守RIC概念模型的更广泛的原则，但丢弃了RIC的本体论。</p><p> follow the approach of The Matterhorn RDF Data Model, i.e. reuse existing vocabularies and NOT create our own.</p><p> 遵循马特宏峰RDF数据模型的方法，即重复使用现有词汇表，而不是创建自己的。</p><p> We started with the model specified in Matterhorn and added additional properties and classes from other shared and standardised vocabularies as we needed. The (work-in-progress) documentation of our data model:  Omega Catalogue Data Model.</p><p> 我们开始使用Matterhorn中指定的模型，并根据我们需要的其他共享和标准化词汇表添加了附加属性和类。我们的数据模型的（正在进行的）文件：Omega目录数据模型。</p><p> Now that we are in Phase 2 of Project Omega and exporting data into this data model in the form of Turtle RDF, we are starting to revisit some of our initial assumptions about reuse.</p><p> 现在我们在项目欧米茄的第2阶段，并以龟RDF的形式将数据导出到此数据模型中，我们开始重新审视我们关于重用的一些初始假设。 </p><p>  The beauty of reusing existing vocabularies (assuming that you choose popular and standardised ones), is that any developer, data scientist, or user who has worked with RDF before can likely already understand and work with our data. For example let’s consider a simplified description of a Record:</p><p>重用现有词汇的美丽（假设您选择了流行和标准化的词汇），是任何开发人员，数据科学家或与RDF一起工作的用户可能已经了解并与我们的数据合作。例如，让我们考虑记录的简化描述：</p><p> @prefix tna: &lt; http://www.nationalarchives.gov.uk/&gt; . @prefix dct: &lt; http://purl.org/dc/terms/&gt; .  tna:res.FO.2020.3J.P.1  dct:identifier &#34;FO.2020.3J.P.1&#34; ;  dct:description &#34;This is a Foreign Office record about...&#34; ;  .</p><p> @prefix tna：＆lt; http://www.nationalarchives.gov.uk/&gt; 。 @prefix dct：＆lt; http://purl.org/dc/terms/&gt; 。 tna：res.fo.2020.3j.p.1 dct：标识符＆＃34; fo.2020.3j.p.1＆＃34; ; DCT：描述＆＃34;这是关于...＆＃34的外交办公室记录; ; 。</p><p>  DCT (Dublin Core Terms) is a vocabulary that has been around since 2008 and its use is ubiquitous. Even if somehow the user was not aware of Dublin Core, the naming of the terms is straight-forward. As a human I can likely infer the meaning of  dct:identifier as holding an identifier for the resource, and  dct:description as holding a description of the resource. If you felt the need to, you could confirm your suspicions by checking the Dublin Core standard document itself, however, the point here is that you didn&#39;t have to, the meaning is already known or at least almost-obvious. This is a major benefit of reusing popular vocabularies as it both reduces the cognitive load for those working with the data, and enables us to form and use a shared language even when working with vastly different datasets.</p><p>  DCT（都柏林核心术语）是自2008年以来一直存在的词汇，其使用是无处不在的。即使某种方式用户不知道都柏林核心，条款的命名也是直截了当的。作为人类，我可能会推断DCT：标识符作为保存资源的标识符的标识符，以及DCT：描述作为保留资源的描述。如果您觉得需要，您可以通过检查都柏林核心标准文档本身确认您的怀疑，但这是您没有必要的点，这意味着已经知道或至少几乎明显。这是重用流行词汇表的主要好处，因为它既可以减少与数据一起使用的人的认知负载，并使我们能够形成和使用共享语言，即使在使用众异的数据集时也可以使用共享语言。</p><p> On the flip-side, the disadvantage of reusing popular shared vocabularies is that they are often, by design, quite generic in their definitions. This is of course by necessity, common terms acceptable to a wide-audience need to be agreeable by that audience, and so generic and/or vaguely defined terms are more palatable.</p><p> 在倒塌方面，重新使用流行的共享词汇表的缺点是它们通常是通过设计，在其定义中非常通用。这当然是必要的，广泛受众可以接受的共同术语需要通过该受众来令人满意，因此通用和/或模糊的术语更加卑鄙。</p><p> Defining your own vocabulary has the absolute advantage of allowing you to precisely define your world-view and exactly what you mean. That’s powerful stuff!</p><p> 定义自己的词汇表具有绝对优势，允许您精确定义世界观，并准确地界定您的意思。这是强大的东西！</p><p>  @prefix tna: &lt; http://www.nationalarchives.gov.uk/&gt; .  tna:res.FO.2020.3J.P.1  tna:oci &#34;FO.2020.3J.P.1&#34; ;  tna:scope-content &#34;This is a Foreign Office record about...&#34; ;  .</p><p>  @prefix tna：＆lt; http://www.nationalarchives.gov.uk/&gt; 。 tna：res.fo.2020.3j.p.1 tna：oci＆＃34; fo.2020.3j.p.1＆＃34; ; TNA：范围内容＆＃34;这是关于...＆＃34的外交办公室记录; ; 。</p><p>  If you work in the Archives sector you might well guess that  tna:scope-content holds the  Scope and Content of the record... but how many people outside of the Archives sector know exactly what is meant by the &#34;Scope and Content&#34; of a record? Even then, you likely wouldn&#39;t know the meaning of  tna:oci! It&#39;s the  Omega Catalogue Identifier, and awareness of that is not even organisation-wide throughout TNA yet. We would of course write OWL and documentation to define exactly what  tna:oci and  tna:scope-content mean, but the user has to go and read those before they can work with the data.</p><p>  如果您在档案部门工作，您可能会猜测TNA：范围内容持有记录的范围和内容......但是档案部门以外的人究竟知道＆＃34;范围和内容＆＃34;记录？即便如此，你可能会知道TNA的含义：OCI！它＆＃39; omega目录标识符，并且意识甚至在整个TNA中都没有组织。我们当然会写入owl和文档来定义什么TNA：OCI和TNA：范围内容意味着，但用户必须先阅读并读取它们可以使用数据。 </p><p> The trade-off is ultimately: Ease of consumption through reuse of Shared Vocabularies vs. Precisely/Correctly expressing your domain and data.</p><p>权衡最终是：通过重用共享词汇表Vs.精确/正确表达您的域和数据来易消化。</p><p>  In Omega our underlying principle is to always attempt reuse first. We are discovering that sometimes however there just isn’t an appropriate Property or Class that can be reused from a popular standardised vocabulary.</p><p>  在Omega，我们的潜在原则是首先尝试重复使用。我们正在发现有时，只能从流行的标准化词汇中重复使用，只有一个合适的财产或类。</p><p> By way of an example let me explain a use-case that we recently had to solve for Project Omega. TNA’s Catalogue currently contains  Covering Dates for each Unit of Description (a single document of folder). These  covering dates are the period-of-time during which the record(s) being described were created. They are expressed using between 1 and 3 values: The  Date Text (as it appears on the unit of description), the  First Date (the start of the period), and the  Last Date (the end of the period).</p><p> 作为一个例子，让我解释一下我们最近不得不解决项目Omega的用例。 TNA的目录目前包含每个描述单位的覆盖日期（文件夹的单个文档）。这些覆盖日期是所描述的记录的时间段。它们在1到3之间表示：日期文本（如描述单位上显示），第一次（期间开始）以及期间的最后日期（期末）。</p><p> Originally we had decided to use a property from a common vocabulary to express these, Dublin Core Terms (perhaps you know it!). The property we initially selected was  dct:temporal. As I interpret the DCT (Dublin Core Terms) standard, it appears to me that  dct:temporal is intended to describe the  temporal coverage of the resource, i.e. the time period discussed/indicated within the resource as opposed to the date that the resource was created. So after further consideration, we decided to use something else instead of  dct:temporal, and this is where we had to start making trade-offs.</p><p> 最初我们决定使用普通词汇的财产来表达这些，都柏林核心条款（也许你知道它！）。我们最初选择的属性是DCT：时间。正如我解释DCT（Dublin核心术语）标准，它看起来是DCT：时间旨在描述资源的时间覆盖，即资源中讨论/所示的时间段而不是资源的日期创建。因此，在进一步考虑之后，我们决定使用其他东西而不是DCT：时间，这是我们必须开始进行权衡的地方。</p><p>  Use  dct:created instead. Unfortunately  dct:created is a Data Type Property and so requires a literal value, yet we need to store 3 literal values ( Date Text,  First Date, and  Last Date). To achieve this we could either: a) Encode the 3 literal values into 1 literal value using  ISO 8601-1,  W3CDTF,  EDTF, or  DCMI Period. This has the downside that querying this with SPARQL becomes complex and requires various string split operations. For example, encoding using DCMI Period might produce the single literal string value:  name=1941-1951; scheme=W3C-DTF; start=1941-01-01Z; end=1951-01-01Z. b) Ignore Dublin Core specifics here, and use an Object Property. We could somewhat enforce this approach with SHACL and documentation. However, those that are used to Dublin Core may be surprised; SPARQL queries for  dct:created would be different in our system than other systems. This negates the advantage of using a property from a shared standardised vocabulary!</p><p>  使用DCT：改为创建。不幸的是DCT：创建是一个数据类型属性，所以需要一个文字值，但我们需要存储3个文字值（日期文本，第一个日期和最后一个日期）。为了实现这一目标，我们可以：a）使用ISO 8601-1，W3CDTF，EDTF或DCMI期间将3个文字值编码为1个文字值。这具有对SPARQL查询此功能的缺点变得复杂，需要各种字符串分割操作。例如，使用DCMI期间的编码可能会产生单个文字字符串值：name = 1941-1951;方案= W3C-DTF; start = 1941-01-01z;结束= 1951-01-01z。 b）忽略这里的Dublin核心细节，并使用对象属性。我们可以在某种程度上强制使用Shacl和文档来强制这种方法。然而，那些习惯于都柏林核心的人可能会感到惊讶; DCT的SPARQL查询：我们的系统中的创建将不同于其他系统。这否定了使用来自共享标准化词汇的财产的优势！</p><p> Use  time:hasTime instead. This is a generic property from the  W3C Time Ontology in OWL. This is an Object Property that allows us to express our covering dates exactly as we would need. Unfortunately  tme:hasTime only tells us that there is a time, not what that time represents. It is too generic and fails to adequately describe that these are the created dates of the records;  dct:created would have been much more precise!</p><p> 使用时间：更换。这是来自W3C时间本体在OWL中的通用属性。这是一个对象属性，使我们能够完全按照我们所需的方式表达我们的覆盖日期。不幸的是，TME：赶紧只告诉我们有一个时间，而不是那个时间代表的时间。它太过通用，无法充分描述这些是记录的创建日期; DCT：创建会更精确！</p><p> Create our own vocabulary property. We have two main options of how to approach this: a) Define our own standalone property in our own vocabulary. b) If there is a property from a common vocabulary that is close to what we need, we can define our own property which is derived from that.</p><p> 创建自己的词汇属性。我们有两个如何接近的主要选择：a）在我们自己的词汇表中定义自己的独立财产。 b）如果常见的词汇属性接近我们所需要的常见词汇，我们可以定义我们自己的属性，该属性来自此。 </p><p> Whilst  dct:created infers (to a human) the meaning that we are looking for it, doesn&#39;t allow us to store the information we need. The  time:hasTime property is the opposite, it lacks a sufficient precise meaning, but allows great flexibility in how we store our covering dates. Therefore, as there is no readily suitable property from a common vocabulary we have little choice but to create our own!</p><p>虽然DCT：创建了infers（对人类）我们正在寻找它的含义，并不让我们存储我们所需要的信息。时间：Hastime属性是相反的，它缺乏足够的精确含义，但允许我们如何存储我们的覆盖日期的极大灵活性。因此，由于没有常见词汇的易于合适的财产，我们几乎没有选择，而是创造自己的！</p><p> As the property  time:hasTime allows us to store the data we need, but is lacking in sufficient descriptive power, rather than defining our own standalone property, we can instead derive our property from  time:hasTime and add further descriptive information. Our new derived property will be  tna:created and could look something like this:</p><p> 作为属性时间：Hastime允许我们存储我们需要的数据，但缺乏足够的描述性，而不是定义自己的独立财产，而不是定义我们的房产，而是从时间派生我们的财产：加速并添加进一步的描述性信息。我们的新派生属性将是TNA：创建，可以看出这样的东西：</p><p> @prefix owl &lt; http://www.w3.org/2002/07/owl#&gt; . @prefix rdfs &lt; http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix tna: &lt; http://www.nationalarchives.gov.uk/&gt; . @prefix dct: &lt; http://purl.org/dc/terms/&gt; . @prefix time: &lt; http://www.w3.org/2006/time#&gt; . @prefix rdae: &lt; http://rdaregistry.info/Elements/e/&gt; .  tna:created  a owl:ObjectProperty ;  rdfs:subPropertyOf time:hasTime ;  rdfs:label &#34;Created date&#34; ;  rdfs:comment &#34;The date that the resource was created, or the  date-period during which the resource was created.  Historically at The National Archives, this has  also been known as the &#39;Covering Dates&#39; (of the  Unit of Description).&#34;@en ;  rdfs:seeAlso dct:created, rdae:P20214  .</p><p> @prefix owl＆lt; http://www.w3.org/2002/07/owl#&gt; 。 @prefix rdfs＆lt; http://www.w3.org/2000/01/rdf-schema#&gt; 。 @prefix tna：＆lt; http://www.nationalarchives.gov.uk/&gt; 。 @prefix dct：＆lt; http://purl.org/dc/terms/&gt; 。 @prefix时间：＆lt; http://www.w3.org/2006/time#& gt; 。 @prefix rdae：＆lt; http://rdaregistry.info/elements/e/&gt; 。 TNA：创建了一只猫头鹰：ObjectProperty; rdfs：subpropertyof时间：匆匆; RDFS：标签＆＃34;创建的日期＆＃34; ; RDFS：评论＆＃34;创建资源的日期，或者创建资源的日期期间。历史上，在国家档案中，这也被称为＆＃39;覆盖日期＆＃39; （描述单位）。＆＃34; @en; RDFS：Seealso DCT：创建，RDAE：P20214。</p><p>  The above definition of  tna:created declares it as a sub-property of  time:hasTime but gives further information about its use, and also informs us that additional information can be found by looking at  dct:created and  rdae:P20214.</p><p>  上面的TNA定义：创建将其声明为时间的子属性：汇率，但提供有关其使用的更多信息，并通过查看DCT来通知我们，创建和RDAE可以找到其他信息：P20214。</p><p> In practical use our earlier RDF augmented with our Covering Dates now finally looks something like:</p><p> 在实际使用中，我们之前的RDF增强了我们的覆盖日期，现在终于看起来像：</p><p> @prefix tna: &lt; http://www.nationalarchives.gov.uk/&gt; . @prefix dct: &lt; http://purl.org/dc/terms/&gt; . @prefix time: &lt; http://www.w3.org/2006/time#&gt; . @prefix xsd: &lt; http://www.w3.org/2001/XMLSchema#&gt; .  tna:res.FO.2020.3J.P.1  dct:identifier &#34;FO.2020.3J.P.1&#34; ;  dct:description &#34;This is a Foreign Office record about...&#34; ;  tna:created [  a time:ProperInterval ;  dct:description &#34;1941-1951&#34; ;  time:hasBeginning [  a time:Instant ;  time:inXSDDate &#34;1941-01-01Z&#34;^^xsd:date  ] ;  time:hasEnd [  a time:Instant ;  time:inXSDDate &#34;1951-12-31Z&#34;^^xsd:date  ]  ]  .</p><p> @prefix tna：＆lt; http://www.nationalarchives.gov.uk/&gt; 。 @prefix dct：＆lt; http://purl.org/dc/terms/&gt; 。 @prefix时间：＆lt; http://www.w3.org/2006/time#& gt; 。 @prefix xsd：＆lt; http://www.w3.org/2001/xmlschema#& gt; 。 tna：res.fo.2020.3j.p.1 dct：标识符＆＃34; fo.2020.3j.p.1＆＃34; ; DCT：描述＆＃34;这是关于...＆＃34的外交办公室记录; ; TNA：创建[时间：proceptinterval; DCT：描述＆＃34; 1941-1951＆＃34; ;时间：hasbeginning [时间：即时;时间：inxsddate＆＃34; 1941-01-01z＆＃34; ^^ xsd：date];时间：哈打[时间：瞬发;时间：Inxsddate＆＃34; 1951-12-31z＆＃34; ^^ xsd：date]]。</p><p>  We still utilise  dct:identifier and  dct:description above, because they are a good fit for our reuse. Whilst the new  tna:created demonstrates our trade-off perfectly!</p><p>  我们仍然利用DCT：标识符和DCT：上面的描述，因为它们是重复使用的合适。虽然新的TNA：创建完全展示了我们的权衡！ </p><p> Earlier, I explained that we had wanted to reuse  dct:created because it is a property that is widely used and understood, but that it was unsuitable for storing our covering dates (as it is specified as a Data Type Property). As we could not find a suitable property from an existing popular vocabulary that we could reuse, we were forced to create our own. This property,  tna:created, has two important design aspects:</p><p>早些时候，我解释说我们想要重复使用DCT：创建，因为它是一个广泛使用和理解的属性，但它不适合存储我们的覆盖日期（因为它被指定为数据类型属性）。由于我们找不到来自现有流行词汇的合适物业，我们可以重用，我们被迫创造自己的。这个属性，TNA：创建，有两个重要的设计方面：</p><p> It’s name is straight forward. Even someone from outside of the Archival sector can likely guess it’s meaning and purpose. It’s unlikely that someone would have to look at our OWL definition or documentation to be able to  start working with it. It’s very much intentional that at a glance it looks a lot like  dct:created.</p><p> 它的名字是直截了当的。即使是来自档案部门之外的人也可能猜测它是意义和目的。有人不太可能看看我们的猫头鹰定义或文档，以便能够开始与之合作。非常有意的是，这一目了然看起来很像DCT：创造了。</p><p> Whilst this property is TNA specific and explicates a precise meaning, it does not standalone. Instead, it reuses the W3C Time Ontology in OWL (a popular vocabulary itself) by virtue of being derived from the  time:hasTime property.</p><p> 虽然这个属性是TNA特定的并且阐述了精确的含义，但它并不是独立的。相反，它通过从时间衍生出来的ovl（一种流行的词汇本身）来重用W3C时间本体论：Hastime属性。</p><p>  For Project Omega — we still prefer reuse wherever possible as it enables easier consumption by others. Creating a new Property or Class (even if derived from a common vocabulary) is sometimes unavoidable, but should be considered as an absolute last resort and undertaken only when no common property exists, or said property fails to adequately describe the data.</p><p>  对于项目Omega  - 我们仍然可以随时随地重复使用，因为它可以让他人更容易消耗。创建新的属性或类（即使从公共词汇中派生）有时是不可避免的，但应该被视为绝对的最后一个度假胜地，并且只有在没有共同属性时才进行，或者所述财产未能充分描述数据。</p><p> Hopefully this article has provided you with some insight into the challenges that arise when strictly trying to reuse existing vocabularies, and the trade-offs that may have to be made.</p><p> 希望本文为您提供了一些洞察力，以严格试图重用现有的词汇表以及可能所需的权衡时出现的挑战。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/the-national-archives-digital/reusing-standard-rdf-vocabularies-part-1-5a9bbfa58b85">https://medium.com/the-national-archives-digital/reusing-standard-rdf-vocabularies-part-1-5a9bbfa58b85</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/标准/">#标准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/standard/">#standard</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>