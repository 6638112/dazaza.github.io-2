<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>像素/体素网格上的渐变–前向，中央和对角线差异 Gradients on grids of pixels/voxels – forward, central, and diagonal differences</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Gradients on grids of pixels/voxels – forward, central, and diagonal differences<br/>像素/体素网格上的渐变–前向，中央和对角线差异 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-02 07:34:41</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/856f4702f67998857c343544ba945259.png"><img src="http://img2.diglog.com/img/2021/3/856f4702f67998857c343544ba945259.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this post, I will focus on  gradients of image signals defined on grids in computer graphics and image processing. Specifically, gradients / derivatives of images, height fields, distance fields, when they are represented as discrete, uniform grids of pixels or voxels.</p><p>在本文中，我将重点介绍计算机图形学和图像处理中定义在网格上的图像信号的梯度。具体来说，是将图像的梯度/导数，高度场，距离场表示为离散的，均匀的像素或体素网格。</p><p> I’ll start with the very basics – what do we typically mean by gradients (as it’s not always “standardized”), what are they used for, what are the ypical methods (forward or central differences), their cons and problems, and then proceed to discuss an interesting alternative with very nice properties –  diagonal gradients.</p><p> 我将从最基本的内容开始-梯度通常是什么意思（因为它并不总是“标准化”的），它们的用途是什么，典型的方法（正向或中心差异）是什么，它们的利弊是什么，以及然后继续讨论一个具有非常好的属性的有趣替代方法-对角渐变。</p><p> My post will conclude with advice on how to use them in practice in a simple useful scheme, how to extend it with a little bit of computations to a super useful concept of a  structure tensor that can characterize dominating direction of any gradient field, and finish with some signal processing fun –  frequency domain analysis of forward and central differences.</p><p> 我的文章将以如何在简单有效的方案中实际使用它们的建议作为结尾，以及如何通过少量的计算将其扩展为结构张量的超级有用的概念，该结构张量可以表征任何梯度场的主导方向，并完成带来一些信号处理乐趣–前向和中央差异的频域分析。</p><p>   It’s not very well defined problem on discrete signals, but the most common and useful way to think about it is inspired by signal processing and the idea of sampling:</p><p>   对于离散信号来说，这并不是一个很好定义的问题，但是最常见和最有用的思考方式是受信号处理和采样思想的启发：</p><p> Assuming there was some continuous signal that got discretized, what would be the partial derivative with regards to the spatial dimension of this continuous signal at gradient evaluation points?</p><p> 假设存在一些离散的连续信号，那么在梯度评估点上，该连续信号的空间维数将是偏导数？</p><p> This interpretation is useful both for computer graphics (where we might have discretized descriptions of continuous surfaces; like voxel fields, heightmaps, or distance fields), as well as in image processing (where we often assume that images are “natural images” that got photographed).</p><p> 这种解释对于计算机图形学（我们可能对连续曲面进行离散化描述；例如体素场，高度图或距离场）以及图像处理（我们通常认为图像是“自然图像”）都非常有用。拍下）。</p><p> Continuous gradients and derivatives used for things like normals of procedural SDFs are also interesting, but a different story. I will not cover those here, and instead recommend you check out  this cool post by Inigo Quilez with lots of practical tricks (re-reading it I learned about the tetrahedron trick) and advice. I am sure that no matter your level of familiarity with the topic, you will learn something new.</p><p> 用于过程SDF的法线之类的连续渐变和导数也很有趣，但情况有所不同。我不会在这里介绍这些内容，而是建议您阅读Inigo Quilez的这篇很棒的文章，其中包含许多实用技巧（重新阅读我从四面体技巧中学到的技巧）和建议。我相信，无论您对本主题的熟悉程度如何，您都会学到一些新东西。 </p><p> In my post, I will focus on computer graphics, image processing, and basic signal processing takes on the problem. There are two much deeper connections that I haven’t personally worked too much with. So I leave it as something that I wish I can expand my knowledge in the future, but also encourage my readers to explore it:</p><p>在我的帖子中，我将重点介绍计算机图形学，图像处理以及解决该问题的基本信号处理。我个人之间并没有进行过多的深层次的联系。因此，我希望我将来能扩展自己的知识，同时也鼓励我的读者探索它：</p><p> Further reading one: The first connection is with  Partial Differential Equations and their discretization. Solving PDEs and solving discretized PDEs is something that many specialized scientific domains deal with, and computing gradients is an inherent part of numerical discretized PDE solutions. I don’t know too much about those, but I’m sure literature covers this in much detail.</p><p> 进一步阅读一个：第一个关系是偏微分方程及其离散化。解决PDE和解决离散PDE是许多专业科学领域都需要解决的问题，计算梯度是数字离散PDE解决方案的固有部分。我对此不太了解，但是我敢肯定文学会对此进行详细介绍。</p><p> Further reading two: The second connection is  wavelets, filter banks, and the frequency precision / localization trade-off. This is something used in communication theory, electrical engineering, radar systems, audio systems, and many more. While I read and am familiar with  some theory, I haven’t found too many practical uses of wavelets (other than the simplest Gabor ones or in use for image pyramids) in my work, so again I’ll just recommend you some more specialized reading.</p><p> 进一步阅读二：第二个连接是小波，滤波器组以及频率精度/定位权衡。这是在通信理论，电气工程，雷达系统，音频系统等中使用的东西。当我阅读并熟悉一些理论时，我在工作中没有发现太多小波的实际用途（除了最简单的Gabor或用于图像金字塔的小波），所以我再次向您推荐一些更专业的小波读。</p><p>   Compute surface normals – when we have something like a scalar field – whether distance field describing an underlying implicit surface, or simply a height field, we might want to compute its gradients to compute normals of the surface, or of the heightfield for normal mapping, evaluating BRDFs and lighting etc. Maybe even for physical simulation, collision, or animation on terrain!</p><p>   计算表面法线-当我们具有标量场之类的东西时-无论是描述底层隐式表面的距离场还是仅是高度场，我们可能要计算其梯度以计算表面法线或法线贴图的高度场，评估BRDF和照明等。甚至可以用于地形上的物理模拟，碰撞或动画！</p><p>  Find edges, discontinuities, corners, and image features – the other application that I will focus much more on is simply finding image features like edges, corners, regions of “detail” or texture; areas where signal changes and becomes more “interesting”. The human visual system is actually built from many  edge detectors and local differentiators and can be thought of as a  multi-scale spatiotemporal gradient analyzer! This is biologically motivated – when signal changes in space or time, it means it’s a potential point of interest or a threat.</p><p>  查找边缘，不连续性，拐角和图像特征–我将重点关注的另一个应用程序是简单地找到图像特征，例如边缘，拐角，“细节”或纹理区域；信号变化并变得更加“有趣”的区域。人类视觉系统实际上是由许多边缘检测器和局部微分器构建而成的，可以看作是多尺度的时空梯度分析仪！这是出于生物学动机–当信号在空间或时间上发生变化时，这意味着它是潜在的兴趣点或威胁。</p><p> The bonus use-case of just computing the gradients is finding the orientation and description of those features. This is bread and butter of any image processing, but also very common in computer graphics – from morphological anti-aliasing, selectively super-sampling only edges, or special effects. I will go back to it in the description of local features in the  Structure Tensor section, but for now let’s use the most common application – just using the gradient vector magnitude, used for example in the  Sobel operator:  .</p><p> 仅计算梯度的额外用例就是找到这些特征的方向和描述。这是任何图像处理的基础，但在计算机图形学中也很常见-从形态学抗锯齿，选择性地仅对边缘进行超采样或特殊效果。我将在“结构张量”部分中对局部特征的描述中再次进行介绍，但现在让我们使用最常见的应用程序–仅使用梯度矢量幅度，例如在Sobel运算符中使用的。</p><p>    Siemens star – a test pattern useful to test different “angles” and different frequencies,</p><p>    西门子之星–一种测试模式，可用于测试不同的“角度”和不同的频率， </p><p>  The Siemens star was rendered at 16x resolution and downsampled with a  sharp antialiasing filter (windowed sinc). There is some aliasing in the center, but it’s ok for our use-case (we want to see a sharp signal change there and then detect it).</p><p>以16倍分辨率渲染Siemens星，并使用尖锐的抗混叠滤波器（带窗的sinc）进行降采样。中间有一些混叠，但是对于我们的用例来说是可以的（我们希望在那里看到一个急剧的信号变化然后检测出来）。</p><p>    What I love about this solution is that it is both intuitive, naive, as well as theoretically motivated! I don’t want to rephrase the wikipedia and most of readers of my blog don’t care so much for formal proofs, so feel free to  have a look there, or in specialized courses ( side note: 2010s+ are amazing, with so many best professors sharing their course slides openly on the internet…). It’s basically built around the  Taylor expansion of the f(x+1) – f(x).</p><p>    我喜欢这个解决方案的地方在于它既直观，天真又具有理论上的动机！我不想改写维基百科，并且我博客的大多数读者都不太在乎形式证明，因此随时可以在那里查看或参加专门课程（旁注：2010年代+很棒，有很多最好的教授在互联网上公开分享他们的课程幻灯片…）。它基本上是围绕f（x + 1）– f（x）的泰勒展开建立的。</p><p> This difference operator is the same as  convolving the image with a [-1, 1] filter.</p><p> 此差分算子与使用[-1，1]滤波器对图像进行卷积相同。</p><p> It’s easy, works reasonably well, is useful. But there are two bigger problems.</p><p> 这很容易，运作得相当好，很有用。但是有两个更大的问题。</p><p>  If you have  read my previous blog post – on bilinear down/upsampling – one of challenges might be visible right away. Convolving with an  even-sized filter,  shifts the whole image by a half a pixel.</p><p>  如果您已经阅读了我以前的博客文章-关于双线性下采样/上采样-可能马上就会看到挑战之一。与偶数大小的滤镜卷积，将整个图像移动半个像素。</p><p>   Depending on the application, this can be a problem or not. “A solution” is simple – undo it with another even sized filter. Perfect solution would be resampling, but resampling by a half pixel is surprisingly challenging (see my  another blog post), so instead we can blur it with a symmetric filter. Blurring the gradient magnitude fixes it (at the cost of blur):</p><p>   根据应用程序的不同，这可能是一个问题。 “解决方案”很简单–用另一个大小相等的过滤器将其撤消。完美的解决方案将是重采样，但是以半像素进行重采样却具有令人惊讶的挑战（请参阅我的另一篇博客文章），因此我们可以使用对称滤镜对其进行模糊处理。模糊梯度大小可以解决此问题（以模糊为代价）：</p><p>  Blurring with an even sized filter fixes the even sized shift. But one other problem might have became much more visible right now.</p><p>  使用均匀大小的滤镜进行模糊处理可以固定均匀大小的偏移。但是另一个问题现在可能已经变得更加明显。 </p><p> Note: You might wonder, what would happen if we would  blur just the partial differences instead? We will see in a second.</p><p>注意：您可能想知道，如果我们仅模糊部分差异，会发生什么？我们将在一秒钟内看到。</p><p>   Second problem is more severe; what happens if we compute  multiple partial derivatives; like df/dx and df/dy this way?</p><p>   第二个问题更加严重。如果我们计算多个偏导数会怎样？像df / dx和df / dy这样吗？</p><p>   Now let’s have a look at the same plot again, this time focusing on “symmetry”. This shows why it’s a real, not just theoretical issue. If we look at gradients of a Siemens star and the box, we can see some  asymmetry:</p><p>   现在，让我们再次看看同一幅图，这次重点是“对称性”。这说明了为什么这是一个现实的问题，而不仅仅是理论上的问题。如果我们看西门子星和盒子的梯度，我们会发现一些不对称性：</p><p>  This is definitely not good and will cause problems in image processing or computing normals, but it’s even worse if we look at the gradient magnitude of a simple “square” in the center of the image – notice what happens to the image corners,  one corner is cut off, and another one 2x too intense!</p><p>  这绝对不好，并且会在图像处理或计算法线中引起问题，但是如果我们查看图像中心的简单“正方形”的梯度大小，则情况更糟–请注意图像拐角处（一个拐角处）发生了什么被切断，另外一个2倍太紧！</p><p> This is a big problem for any real application. We need to look at better approximations.</p><p> 对于任何实际应用程序来说，这都是一个大问题。我们需要研究更好的近似值。</p><p>  I mentioned that “blurring” partial derivatives can “recenter” them, right? What if I told you that it is also  numerically more accurate? This is the so-called  central difference.</p><p>  我提到“模糊”偏导数可以使它们“居中”，对吗？如果我告诉您它在数值上也更准确怎么办？这就是所谓的中心差异。</p><p> It is evaluated by  . The division by two is important and intuitively can be understood as dividing by the distance between the pixels, or the differential dx, where dx is 2x larger.</p><p> 由评估。除以2很重要，直观上可以理解为除以像素之间的距离或差分dx，其中dx大2倍。 </p><p> When forward difference was an approximation accurate to the O(h), this one is more accurate, to O(h^2). I won’t explain those terms here, but  the wikipedia has some basic intro, and in numerical methods literature you can find a more detailed explanation.</p><p>当前向差是近似于O（h）的近似值时，该近似值更近似于O（h ^ 2）。我不会在这里解释这些术语，但是维基百科有一些基本的介绍，在数值方法文献中，您可以找到更详细的解释。</p><p> It is also  equivalent to “blurring” the forward difference with a [0.5, 0.5] filter! [0.5, 0.5] o [-1, 1] leads to [-0.5, 0, 0.5]. I was initially very surprised by this connection – of a more accurate, theoretically motivated Taylor expansion, and just “some random ad-hoc practical blur”. This is even sized blur, so this also fixes the half pixel shift problem and centers both partial derivatives correctly:</p><p> 这也等效于用[0.5，0.5]滤波器“模糊”正向差异！ [0.5，0.5] o [-1，1]导致[-0.5，0，0.5]。最初，我对这种联系感到非常惊讶-更精确，理论上有动机的泰勒展开，以及“一些随机的临时实践模糊”。这甚至是大小上的模糊，因此这也解决了半像素偏移问题并使两个偏导数正确居中：</p><p>   However, there is another problem. Notice how the gradient estimate on the pixel doesn’t take pixel’s value into account at all! This means that  patterns like 0 1 0 1 0 1 will have… zero gradient!</p><p>   但是，还有另一个问题。请注意，像素上的梯度估算完全没有考虑像素的值！这意味着像0 1 0 1 0 1这样的模式将具有…零梯度！</p><p> This is how both methods compare on all gradients, including the “striped” pattern:</p><p> 这就是两种方法在所有梯度（包括“条纹”图案）上进行比较的方式：</p><p>  The central difference predicts zero gradient for any 1 0 1 0-like, highest frequency (Nyquist) sequence! On Siemens star it demonstrates as missing / zero gradients just outside of the center.</p><p>  中心差可预测任何类似于1 0 1 0的最高频率（奈奎斯特（Nyquist））序列的零梯度！在西门子星上，正好在中心以外显示为缺少/零梯度。</p><p> We know that we have strong gradients there, and strong patterns/edges, so this is clearly not right.</p><p> 我们知道那里有很强的渐变色，还有很强的图案/边缘，所以这显然是不对的。</p><p> This can and will lead to some serious problems. If we look at the Siemens star, we can notice how it is nicely symmetric, but  misses gradient information in the center…</p><p> 这可能会并会导致一些严重的问题。如果我们看西门子星，我们会注意到它很好地对称，但是却错过了中心的梯度信息…… </p><p>  It’s worth mentioning here what is the commonly used  Sobel filter. Sobel filter is nothing more or less than central difference that is blurred (with a binomial filter approximation of Gaussian) in the direction perpendicular to evaluated gradient, so something like:</p><p>这里值得一提的是什么是常用的Sobel滤波器。 Sobel滤波器无非是在垂直于评估梯度的方向上被模糊（具有高斯二项式滤波器近似）的中心差所引起的，所以类似：</p><p>  The practical motivation for it in Sobel filter is a) filtering out some noise and tendency to be sensitive to single pixel gradients that are not very visible, and more importantly b)  its blurring introduces more “isotropic” behavior (you will see below how “diagonals” and “corners” are closer magnitude to the horizontal/vertical edges).</p><p>  在Sobel滤波器中进行此操作的实际动机是：a）滤除一些噪声和对不太明显的单个像素渐变敏感的趋势，更重要的是b）它的模糊引入了更多的“各向同性”行为（您将在下面看到“对角线”和“角线”的幅度更接近水平/垂直边缘）。</p><p> Sobel operator would compare to the central difference (comparing those due to the largest similarity):</p><p> Sobel运算符将与中心差异进行比较（比较相似度最大的差异）：</p><p>   Mentioning isotropic or anisotropic response on grids is always weird to me. Why? Because the Nyquist frequencies are not isotropic or radial, they form a box. This means that we can represent higher frequencies on the diagonals than the principal axes. I have covered in  an older post of mine how  this property can be used in checkerboard rendering by rotating the sample grid (used for example in many Playstation 4 Pro to achieve 4K rendering with spatiotemporal upsampling). But any analysis becomes “weird” and I often see discussions of whether separable sinc is “the best” filter for images, as opposed to  rotationally symmetric jinc.</p><p>   在网格上提到各向同性或各向异性响应对我来说总是很奇怪。为什么？因为奈奎斯特频率不是各向同性或径向的，所以它们形成一个盒子。这意味着我们可以在对角线上代表比主轴更高的频率。我在我的较早的文章中介绍了如何通过旋转示例网格（例如在许多Playstation 4 Pro中使用此属性以时空上采样来实现4K渲染）在棋盘格渲染中使用此属性。但是任何分析都变得“怪异”，我经常看到关于可分离Sinc是否是“最佳”图像滤波器的讨论，而不是旋转对称Jinc。</p><p> I don’t have an easy answer for how important it is for the image gradients, and the question is “it depends”. Do you care about detecting higher frequency diagonal gradient as stronger gradients or not? What’s the use-case? I haven’t thought about it in the context of normal mapping, as this could lead to “weird” curvatures, but I’m not sure. I might come back to it out of personal curiosity at some point, so please let me know in the comments what are your thoughts and/or experiences.</p><p> 对于图像渐变的重要性，我没有一个简单的答案，问题是“取决于”。您是否关心将较高频率的对角线梯度检测为较强的梯度？用例是什么？在法线贴图的背景下，我还没有考虑过这一点，因为这可能会导致“怪异”的曲率，但我不确定。出于个人好奇心，我可能会在某些时候再次提及它，因此请在评论中让我知道您的想法和/或经历。</p><p>  Notice that as you can use the central difference for increase of the accuracy of the forward difference / higher order approximation, you can  go even further and further,  adding more taps to your derivative-approximating filter!</p><p>  请注意，由于您可以使用中心差来提高前向差/高阶近似的精度，因此您可以走得更远，在派生近似滤波器中添加更多抽头！</p><p> They can help with disappearing high frequency gradients, but your gradients become less and less localized in space. This is the connection to wavelets, audio, STFT and other areas that I mentioned.</p><p> 它们可以帮助消除高频梯度，但是您的梯度在空间中的位置越来越少。这是我提到的与小波，音频，STFT和其他区域的连接。 </p><p> I also like to think of it intuitively as half pixel resampling of the [-1, 1] filter. 🙂 For example if you were to  resample [-1, 1] with a half pixel shifting larger sinc filter, you’d get similar behavior:</p><p>我还喜欢直观地将其视为[-1，1]滤镜的半像素重采样。 🙂例如，如果您要对[-1，1]进行重新采样，并移动较大的sinc滤镜半个像素，则会得到类似的行为：</p><p>   With all this background, it’s finally time for the main suggestion of the post.</p><p>   在所有这些背景下，现在是该帖子的主要建议的时候了。</p><p> This is something I have learned from my coworkers who worked on the  BLADE project (approximating image operations with discrete learned filters), and then we used in our work that materialized as the  Handheld Multiframe Super-Resolution paper and  Super-Res Zoom Pixel 3 project that I had a pleasure of leading.</p><p> 这是我从BLADE项目的同事那里学到的（使用离散的学习滤镜近似图像操作），然后我们在工作中使用了手持多帧超分辨率纸和Super-Res Zoom Pixel 3项目。我很高兴领导。</p><p> I get a lot of questions about this part of the paper in some emails as well, so I think it’s not a very commonly known “trick”. If you know where it might have originated and domains that use it more often, please let me know.</p><p> 在一些电子邮件中，我也对本文的这一部分有很多疑问，所以我认为这不是一个非常普遍的“技巧”。如果您知道它的起源和使用它的域越来越多，请告诉我。</p><p> Edit:  Don Williamson has noticed on twitter that it’s known as  Robert’s Cross and was developed in 1963!</p><p> 编辑：唐·威廉姆森（Don Williamson）在推特上注意到它的名字叫罗伯特·克罗斯（Robert’s Cross），它是1963年开发的！</p><p> The idea here is to  compute gradients on the diagonals. For example in 2D (note that it extends to higher dimensions!):</p><p> 这里的想法是计算对角线上的梯度。例如在2D中（请注意，它会扩展到更高的尺寸！）：</p><p>  We can see that with the diagonal difference, both partial derivative approximations are centered in the same point. We compute those just like forward differences, but need to compensate for larger distance, sqrt(2), size of the diagonal of the pixels, so   and  .</p><p>  我们可以看到，在对角线差的情况下，两个偏导数近似值都位于同一点的中心。我们像前向差一样计算它们，但是需要补偿更大的距离，sqrt（2），像素对角线的大小，所以和。 </p><p> If you use gradients like this you can “rotate it” for normals. For just gradient magnitude you don’t need to do anything special, it’s computed the same way (length of the vector)!</p><p>如果使用这样的渐变，则可以“旋转”法线。对于梯度幅度，您无需执行任何特殊操作，它的计算方法相同（向量的长度）！</p><p> Gradient computed like this doesn’t have missing high frequency gradients problems; nor asymmetry problems:</p><p> 这样计算出来的梯度不会缺少高频梯度问题；也不存在不对称问题：</p><p>  It has the problem of pixel shift, and some anisotropy, but the pixel shift can be easily fixed.</p><p>  它具有像素偏移和某些各向异性的问题，但是像素偏移可以很容易地固定。</p><p>    This means sum all the squared gradients, and divide by 4 (number of gradient pairs) – all very efficient operations. Then you just take the square root and get the gradient magnitude.</p><p>    这意味着将所有平方梯度求和，然后除以4（梯度对的数量），这都是非常有效的操作。然后，您只需取平方根并获得梯度量值。</p><p> This fixes the problem of phase shift and IMO is the best of all alternatives discussed so far:</p><p> 这解决了相移问题，而IMO是迄今为止讨论的所有替代方案中最好的：</p><p>  Diagonal differences detect high frequencies properly, don’t have a pixel shift problem, and while they show perfect isotropy, in practice it is often “good enough”.</p><p>  对角线差异可以正确检测高频，不存在像素偏移问题，尽管它们表现出完美的各向同性，但实际上通常“足够好”。</p><p> Some blurring is on the one hand reducing the “localization”, but on the other hand it can be desired and  improve robustness to noise and single pixel gradients.</p><p> 一方面有些模糊会降低“定位”，但另一方面这可能是理想的，它可以提高对噪声和单个像素渐变的鲁棒性。 </p><p>  With just a few lines of code (and some extra computation…) we can extract even more information from it!</p><p>仅需几行代码（以及一些额外的计算……），我们就可以从中提取更多信息！</p><p>  We have a “bag” or gradient values for a bunch of pixels… What if we tried to  find a least squares solution to “what is the dominant gradient direction in the neighborhood”?</p><p>  我们有一堆像素的“袋”或梯度值……如果我们试图找到“附近的主要梯度方向是什么”的最小二乘解，该怎么办？</p><p> I am not great at math derivations, but  here’s an elegant explanation of the  structure tensor. Structure tensor is a  Gram matrix of the gradients (vector of “stacked” gradients multiplied by its transpose).</p><p> 我在数学推导方面并不擅长，但这是对结构张量的优雅解释。结构张量是梯度的Gram矩阵（“堆叠”梯度的矢量乘以其转置）。</p><p> Lots of difficult words, but in essence it’s a very simple 2×2 matrix, where entries are averages of dx^2, dy^2 on the diagonal, and dx*dy on the off diagonal:</p><p> 许多困难的单词，但从本质上讲，它是一个非常简单的2×2矩阵，其中的条目是dx ^ 2，dy ^ 2在对角线上的平均值和dx * dy在非对角线上的平均值：</p><p>  Now if we do  eigendecomposition of this matrix (which is always possible for a Gram matrix – symmetric, positive semidefinite), we get the following  simple closed forms for the eigenvalues:</p><p>  现在，如果我们对该矩阵进行特征分解（对于Gram矩阵始终是可能的–对称，正半定数），我们将得到以下简单的特征值封闭形式：</p><p>    You might want to normalize the vectors; in the case of the off-diagonal Gram matrix entry of zero, the eigenvectors are simply coordinate system principal axes (1, 0) and (0, 1) (be sure to “sort” them in that case though , same for underdetermined systems, where the ordering doesn’t matter.</p><p>    您可能要对向量进行归一化；在非对角线Gram矩阵项为零的情况下，特征向量仅是坐标系主轴（1、0）和（0、1）（尽管在这种情况下，请务必对它们进行“排序”，对于欠定系统也是如此） ，顺序无关紧要。</p><p> Larger eigenvalue and associated eigenvector describe the direction and magnitude of the gradient in dominant direction; it gives us both its orientation and how strong the gradient is in that specific direction.</p><p> 较大的特征值和相关的特征向量描述了主导方向上梯度的方向和大小；它既为我们提供了方向，又为我们提供了该特定方向上的渐变强度。 </p><p> The second, smaller eigenvalue and perpendicular, second eigenvector gives us  information about the gradient in the perpendicular direction.</p><p>第二个较小的特征值和垂直的第二个特征向量为我们提供了有关垂直方向上的梯度的信息。</p><p> Together this is really cool, as it allows us to distinguish edges, corners, regions with texture, as well as orientation of edges. In our  Handheld Multiframe Super-Resolution paper we used two “derived” properties –  strength (simply the square root of the structure tensor dominant eigenvalue) describing how strong is the gradient locally, and  coherence computed as  . (Note: the original version of the paper had a mistake in the definition of the coherence, a result of late edits for the camera ready version of the paper that we missed. This value has to be between 0 and 1).</p><p> 在一起这真的很酷，因为它使我们能够区分边缘，拐角，具有纹理的区域以及边缘的方向。在我们的《手持式多帧超分辨率》论文中，我们使用了两个“派生”属性-强度（仅是结构张量主导特征值的平方根）描述了局部梯度的强度，而相干性计算为。 （注意：论文的原始版本在连贯性的定义上有误，这是由于我们错过了对相机准备好的版本的后期编辑而导致的结果。该值必须在0到1之间）。</p><p> Coherence is a bit more uncommon; it describes how much stronger is the dominant direction over the perpendicular one.</p><p> 连贯性不常见。它描述了主导方向比垂直方向强多少。</p><p> By analyzing the eigenvector (any of them is fine, since they are perpendicular), we can get information about the dominant gradient orientation.</p><p> 通过分析特征向量（由于它们是垂直的，它们中的任何一个都是很好的），我们可以获得有关主导梯度方向的信息。</p><p> In the case of our test signals that are comprised of simple frequencies, those look as follow (please ignore the behavior on borders/boundaries between images in my quick and dirty implementation):</p><p> 在我们的测试信号由简单频率组成的情况下，这些信号如下所示（在我快速而肮脏的实现中，请忽略图像之间的边界/边界上的行为）：</p><p>  Here’s some other example on an actual image, with a remapping often used for displaying vectors – hue defined by the angle, and saturation by the gradient strength:</p><p>  这是实际图像上的其他示例，通常使用重映射来显示矢量-由角度定义的色相，由梯度强度定义的饱和度：</p><p>  Such analysis is important for both edge-aware, non-linear image processing, as well as in computer vision. Structure tensor is a part of  Harris corner detector, which used to be probably the most common computer vision question prior to the whole deep learning revolution. 🙂 (Still, if you’re looking for a job in the field even today, I suggest not skipping on such fundamentals as interviewers can still ask for classic approaches to verify how much of the background you understand!)</p><p>  这样的分析对于边缘感知的非线性图像处理以及计算机视觉都非常重要。结构张量是Harris角点检测器的一部分，它曾经是整个深度学习革命之前最常见的计算机视觉问题。 🙂（不过，即使您今天仍在实地寻找工作，我还是建议您不要跳过一些基本知识，因为面试官仍然可以要求采用经典方法来验证您了解多少背景知识！） </p><p>  One thing that is worth mentioning is how to “fix” the rotation of  structure tensor from diagonal gradients. If you compute the angle through arctan, this is not something you’d care about (just add value to your angle), but in scenarios where you need higher computational efficiency,  you don’t want to be doing any inverse trigonometry, and this matters a lot. Luckily, rotating Gram or covariance matrices is super easy! Formula for rotating a covariance matrix is simply  . Constructing a rotation matrix by 45 degree from angle formula, we get first:</p><p>值得一提的是如何从对角线渐变“固定”结构张量的旋转。如果通过arctan计算角度，这不是您关心的问题（只需为角度添加值），但是在需要更高计算效率的情况下，您不需要进行任何反三角运算，并且至关重要。幸运的是，旋转Gram或协方差矩阵非常简单！旋转协方差矩阵的公式很简单。从角度公式以45度构造旋转矩阵，我们首先得到：</p><p>    ( Note: worth double checking my math. But it makes sense that having exactly the same 4 diagonal elements cancels them and suggests a vertical only or diagonal only gradient!)</p><p>    （注意：值得仔细检查一下我的数学。但是，具有完全相同的4个对角线元素会取消它们，并建议使用仅垂直或仅对角线渐变！）</p><p>  Before I conclude the post, I couldn’t resist looking at comparing the forward differences and central differences from the perspective of signal processing.</p><p>  在结束本文之前，我不禁从信号处理的角度比较前向差异和中心差异。</p><p> It’s probably a bit unorthodox and most people don’t look at it this way, but I couldn’t stop thinking about the disappearing high frequencies;  ideal differentiator of continuous signals should have “infinite” frequency response as frequencies go to infinity!</p><p> 这可能有点不合常规，并且大多数人不是这样看的，但是我不能停止思考高频消失的问题。当频率达到无穷大时，理想的连续信号微分器应具有“无限”的频率响应！</p><p> Obviously frequencies can go only up to Nyquist in the discrete domain. But let’s have a look at the frequency response of the forward difference convolution filter and the central difference:</p><p> 显然，在离散域中，频率只能上升到奈奎斯特。但是，让我们看一下前向差分卷积滤波器的频率响应和中心差分：</p><p>  The central difference convolution filter has zero frequency response at Nyquist and seems to match the frequency response worse than a simple forward difference filter with increasing frequencies.  This is the “cost” we pay for compensating for the phase shift.</p><p>  中央差分卷积滤波器在Nyquist处的频率响应为零，并且似乎比简单的前向差分滤波器随频率增加而使频率响应更差。这是我们为补偿相移而付出的“成本”。</p><p> But given this frequency response, it makes sense that a sequence of 1 0 1 0 completely “disappears”, as it is exactly at Nyquist, where the response is zero!</p><p> 但是给定该频率响应，有意义的是完全“消失”了一个1 0 1 0序列，正好在奈奎斯特（Nyquist），响应为零！ </p><p> Finally, if we look at higher order / more filter tap gradient approximations, we can see that it definitely improves for most mid-high frequencies, but the behavior when approaching Nyquist is still a problem:</p><p>最后，如果我们查看更高阶/更多阶的滤波器抽头梯度近似值，我们可以看到它对于大多数中高频肯定有所改善，但是接近奈奎斯特时的行为仍然是一个问题：</p><p>  Ok, with 9 taps we get better and better behavior and closer to the differentiator line.</p><p>  好的，通过9次抽头，我们将获得越来越好的性能，并且更加接近微分线。</p><p> At the same time, the convergence is slow and we won’t be able to recover the exact Nyquist:</p><p> 同时，收敛速度很慢，我们将无法恢复确切的奈奎斯特：</p><p>  This is due to “perfect” resampling having frequency response of 0 at Nyquist. Whether this is a problem or not depends on your use-case. In both photography, as well as computer graphics we get get sequences occurring at perfect Nyquist (from rasterization or sampling photographic signals). Anyway, I highly recommend the diagonal filters which don’t have this issue!</p><p>  这是由于在Nyquist的频率响应为0的“完美”重采样所致。这是否是一个问题取决于您的用例。在摄影以及计算机图形学中，我们都获得了发生在完美奈奎斯特上的序列（通过光栅化或采样摄影信号）。无论如何，我强烈建议您不要使用对角线滤镜！</p><p>  In my post, I only skimmed the surface of the deep topic of grid (image, voxel) gradients, but covered a bunch of related topics and connections:</p><p>  在我的帖子中，我只浏览了网格（图像，体素）渐变的深层主题，但涵盖了一系列相关主题和联系：</p><p> I discussed differences between the  forward and central differences, how to address some of their problems, and some reasons for the classic  Sobel operator.</p><p> 我讨论了前向差异和中央差异之间的差异，如何解决它们的一些问题，以及使用经典Sobel算子的一些原因。</p><p> I presented a neat “trick” of using  diagonal gradients that fixes some of the shortcomings of the alternatives and I’d suggest it to you as the go-to one. Try it out with other signal sources like voxels, or for co</p><p> 我提出了使用对角线渐变的巧妙“技巧”，可解决其他替代方式的一些缺点，并建议您使用它。尝试使用其他信号源（例如体素），或用于 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bartwronski.com/2021/02/28/computing-gradients-on-grids-forward-central-and-diagonal-differences/">https://bartwronski.com/2021/02/28/computing-gradients-on-grids-forward-central-and-diagonal-differences/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/体素/">#体素</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/grids/">#grids</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/梯度/">#梯度</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>