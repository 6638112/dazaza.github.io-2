<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>舰队编辑器中的数据结构Data Structures in the Fleet Editor</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Data Structures in the Fleet Editor<br/>舰队编辑器中的数据结构</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 11:52:53</div><div class="page_narrow text-break page_content"><p>In the first part of this series we looked at an overview of the Fleet architecture. In this second part we’re going to cover the algorithms and data structures that are used under the covers in the editor.</p><p>在本系列的第一部分中，我们对车队架构进行了概述。在第二部分中，我们将介绍在编辑器的封面下使用的算法和数据结构。</p><p>    There’s a line of text with syntax highlighting and a widget providing information about usages of the particular variable. Now one could find multiple ways to display this information, but the issue with editors is that they are not read-only. In addition to visualization of data, they can also be updated. A simple operation such as changing a function name could impact many things such as syntax highlighting, usages, and of course any other feature offered such as static analysis or on-the-fly compilation.</p><p>这里有一行带语法突出显示的文本，还有一个小部件提供关于特定变量用法的信息。现在人们可以找到多种方式来显示这些信息，但编辑的问题是它们不是只读的。除了数据的可视化，它们还可以更新。一个简单的操作，比如更改函数名，可能会影响很多事情，比如语法高亮显示、用法，当然还有其他任何功能，比如静态分析或动态编译。</p><p> In order to be able to provide a good experience, we need to make sure that editing text and the consequent visualization can be as seamless as possible. In order to accomplish this, we have to store and manipulate data in an efficient manner. However, it’s not just one way of storing data. In fact, the image above stores data in multiple ways, using different data structures that all come together to form what we call the editor. In other words, think of the editor as an aggregator of data structures!</p><p>为了能够提供良好的体验，我们需要确保编辑文本和随后的可视化尽可能无缝。为了实现这一点，我们必须以高效的方式存储和操作数据。然而，这不仅仅是存储数据的一种方式。事实上，上面的图像以多种方式存储数据，使用不同的数据结构，这些数据结构组合在一起形成我们所说的编辑器。换句话说，把编辑器想象成数据结构的聚合器！</p><p>   For those familiar with working with large amounts of text, you may already know that using strings (i.e. array of chars) to store them isn’t very efficient. Usually any operation on an array is going to imply having to create a new larger or smaller array, and copy the contents from the old one to the new one. This is hardly efficient.</p><p>对于那些熟悉处理大量文本的人来说，您可能已经知道使用字符串（即字符数组）来存储它们不是很有效。通常，对数组的任何操作都意味着必须创建一个更大或更小的新数组，并将内容从旧数组复制到新数组。这几乎没有效率。</p><p> A better and more standardized approach is to use  rope structures. The idea behind this abstract data type is to store strings in leaf nodes on a tree.</p><p>更好、更标准的方法是使用绳索结构。这种抽象数据类型背后的思想是将字符串存储在树的叶节点中。</p><p>  Each leaf node contains a string and its length (called weight), and each intermediate node also contains a weight which is the sum of all the leaves in its left subtree.</p><p>每个叶节点包含一个字符串及其长度（称为权重），每个中间节点还包含一个权重，该权重是其左子树中所有叶的总和。</p><p> From the example above, if we take for instance the node which holds the characters  fun, the count of the node is 3 because the length of the string is 3. Moving up to the parent node, the count is also 3 because the sum of the weight of all nodes to its left is 3. Its parent in turn has a count of 19 because the sum of the leaves to its left is 3 and 16.</p><p>从上面的例子来看，如果我们以包含字符fun的节点为例，节点的计数是3，因为字符串的长度是3。向上移动到父节点时，计数也为3，因为其左侧所有节点的权重之和为3。它的父代依次计数为19，因为它左边的叶子之和是3和16。</p><p> Common actions such as searching, appending, removing, splitting strings can be performed with O(log N) time complexity, where N is the length of the string. Operations start by traversing a tree, and given the information of the nodes, this makes it faster. For instance, if we want to find a character in position  i = 30, we start with the node, and if 30 is less than the weight of the node (character count), we go to the left, subtracting (see note below) the value of the weight from i. If on the other hand  i is higher, we go to the right. As we move down and the value of  i decreases, once we reach a leaf node, the character at the  i position of the string the leaf node holds is what we’re looking for.</p><p>搜索、追加、删除、拆分字符串等常见操作的时间复杂度为O（logn），其中N是字符串的长度。操作从遍历一棵树开始，并且给定节点的信息，这会使操作更快。例如，如果我们想在位置i=30处找到一个字符，我们从节点开始，如果30小于节点的权重（字符数），我们向左，从i中减去权重值（见下面的注释）。如果另一方面i更高，我们向右。当我们向下移动，i的值减小时，一旦我们到达一个叶节点，叶节点所在字符串i位置的字符就是我们要寻找的。</p><p>  Note: depending on the metric used, subtraction may not be the required operation. What’s important is that as we move down the tree we accumulate the metric up to that point and compare it to the key we are scanning for.</p><p>注意：根据使用的度量，减法可能不是必需的操作。重要的是，当我们沿着树向下移动时，我们将度量累积到该点，并将其与我们正在扫描的键进行比较。</p><p> When inserting or deleting nodes in the rope structure in Fleet, we use a self-balancing  B-Tree. We start by reading chunks of 64 characters, and once we get to 32 chunks we create a node and start collecting chunks for a second node. Each node has two numbers – in addition to the weight we also store the line count (combination of both is what we call  metrics).</p><p>在Fleet的绳索结构中插入或删除节点时，我们使用自平衡B树。我们从读取64个字符的块开始，一旦达到32个块，我们就创建一个节点，并开始为第二个节点收集块。每个节点有两个数字——除了权重之外，我们还存储行数（两者的组合就是我们所说的度量）。</p><p>  By storing the line count, we can navigate faster to specific offsets. Another trait of the tree in Fleet is that we aim to keep them wide as opposed to deep.</p><p>通过存储行计数，我们可以更快地导航到特定偏移。舰队中树的另一个特点是，我们的目标是保持它们宽而不是深。</p><p>  As we saw before a fragment of code may not only contain the actual text, but also additional elements like  usages.</p><p>正如我们之前看到的，代码片段可能不仅包含实际文本，还包含其他元素，比如用法。</p><p>  We call these widgets, and they can be interline widgets such as the  Find Usages or  Run widgets, postline (e.g. debug information appearing after the line of code) or inlay (e.g. type hinting on variables and lambdas).</p><p>我们称这些小部件为行间小部件，比如Find Usages或Run小部件、postline（例如出现在代码行之后的调试信息）或inlay（例如变量和lambda上的类型提示）。</p><p> A widget in itself is merely a markup element, and the data structure that holds it is a variation on  interval trees, which in some way is also a rope structure. In Interval trees, nodes hold a range and the weight corresponds to the maximum of the ranges from the subtree.</p><p>小部件本身只是一个标记元素，保存它的数据结构是区间树的一种变体，在某种程度上也是一种绳结构。在区间树中，节点拥有一个范围，权重对应于子树中范围的最大值。</p><p>  In Fleet, each node contains a relative start and end of children nodes. Leaves in turn contain an actual widget. When running queries to see if a particular widget needs to be displayed based on some specific coordinate, we traverse the tree until we find an intersection of the range with the one we’re querying.</p><p>在Fleet中，每个节点都包含子节点的相对起点和终点。叶子依次包含一个实际的小部件。当运行查询以查看是否需要基于某个特定坐标显示特定的小部件时，我们遍历树，直到找到该范围与我们正在查询的范围的交点。</p><p> An important aspect is that the leaves also contain the widget ID. This means that in addition to querying what intersects with a specific range, for any widget we can also query to determine where it actually is located.</p><p>一个重要的方面是，叶子还包含小部件ID。这意味着除了查询与特定范围相交的内容外，对于任何小部件，我们还可以查询以确定其实际位置。</p><p> One variation from a standard interval tree is that in Fleet we allow nodes to overlap. This leads to the possibility of making searches somewhat less efficient, but by allowing this, we can create balanced trees and have them updatable as we type.</p><p>标准间隔树的一个变化是，在舰队中，我们允许节点重叠。这可能会降低搜索的效率，但通过允许这一点，我们可以创建平衡树，并在键入时对其进行更新。</p><p> In addition to widgets, interval trees in Fleet are also used to keep track of carets, highlighting of text, as well as  sticky locations in text which we call anchors.</p><p>除了小部件，Fleet中的间隔树还用于跟踪插入符号、突出显示文本，以及文本中我们称之为锚的粘性位置。</p><p>  When working with source code, whether it’s a compiler or an editor, you normally would use an Abstract Syntax Tree (AST). The way this works is that a parser analyzes the source code and creates a series of tokens. These tokens are then used to build up the AST.</p><p>在处理源代码时，无论是编译器还是编辑器，通常都会使用抽象语法树（Abstract Syntax Tree，AST）。其工作方式是解析器分析源代码并创建一系列标记。然后，这些令牌用于构建AST。</p><p>     where each token is represented by square brackets (notice how empty spaces are also tokens). These tokens are then used to build the corresponding AST</p><p>每个标记都用方括号表示（注意空格也是标记）。然后使用这些令牌构建相应的AST</p><p>  The AST is then used for a variety of operations such as syntax highlighting, static analysis, etc. It is an important part of any IDE.</p><p>AST随后用于各种操作，如语法高亮显示、静态分析等。它是任何IDE的重要组成部分。</p><p> By the way, if you’re interested in seeing how some code is translated into an AST, check-out this   cool online AST explorer  (which provides support for a variety of languages)</p><p>顺便说一句，如果你有兴趣了解一些代码是如何被翻译成AST的，可以看看这个很酷的在线AST浏览器（它支持多种语言）</p><p> As we type in the editor, the text changes, meaning the tokens change, which in turn requires building a new AST so as to be able to provide the above functionality.</p><p>当我们在编辑器中键入时，文本会发生变化，这意味着标记会发生变化，这反过来需要构建一个新的AST，以便能够提供上述功能。</p><p> In Fleet, in order to avoid updating the AST directly, we use a rope structure to store the tokens in leaves (actually only the lengths are stored). To give an example, the above list of tokens could be represented with the following tree</p><p>在Fleet中，为了避免直接更新AST，我们使用rope结构将令牌存储在叶子中（实际上只存储长度）。举个例子，上面的令牌列表可以用下面的树表示</p><p>  When the user types something, for instance a space character, the tree is updated (length of 1 added in the leftmost leaf, causing increase in count along that path)</p><p>当用户键入某个内容（例如空格字符）时，树将被更新（最左边的叶子中添加了1的长度，导致该路径上的计数增加）</p><p>  The specific leaf gets the new token length added, which in turn causes updates to certain nodes of the tree in order to adjust the weight. The parser then receives a notification which forces it to update and reparse the AST. As such, for a fraction of second the AST may not be entirely correct, however the user experience is much better when it comes to editing as very little has to be updated.</p><p>特定的叶子会添加新的标记长度，这反过来会导致更新树的某些节点，以调整权重。然后，解析器会收到一个通知，强制它更新并重新分析AST。因此，在一小部分时间内，AST可能并不完全正确，但在编辑方面，用户体验要好得多，因为几乎不需要更新。</p><p>  The image below is yet another example of the editor, but this time with a few additional elements, namely the actual usages widget expanded to display usages, soft-wrap of lines, and other things such as colored vertical lines in the scrollbar.</p><p>下面的图片是编辑器的另一个例子，但这一次添加了一些额外的元素，即“实际用法”小部件，它被扩展以显示用法、行的软包装以及其他内容，例如滚动条中的彩色垂直线。</p><p>  To render the above, for a specific  Y coordinate, we need to know not only which line is displayed but also take into account all the widgets and soft-wrapped lines.</p><p>为了呈现上述内容，对于特定的Y坐标，我们不仅需要知道显示哪条线，还需要考虑所有小部件和软包装线。</p><p> Fun fact: the editor rendered in the usages widget uses the same underlying data structures we’re exploring in this post. For usages in the same file, the same ropes are used to build and render this overlay editor.</p><p>有趣的事实：usages小部件中呈现的编辑器使用了我们在本文中探讨的相同的底层数据结构。对于同一文件中的用法，使用相同的绳索构建和渲染此覆盖编辑器。</p><p> Widget and soft-wrap information is also stored as a rope structure. Whereas before the leaves of the tree would hold the string and its length, in this case, we’re using leaves to hold what we call  SoftLine objects. These are chunks of text accompanied by the heights that are considered visual lines. The weight of the nodes in this case (what we call metrics) are the height and length of the  SoftLine. The height is stored in order to be able to support viewport queries. This height is affected by the interlines located inside of it. In addition, when soft-wraps are enabled,  SoftLines don’t correspond one to one with real lines, but can span multiple lines.</p><p>小部件和软包装信息也存储为绳索结构。而在树的叶子可以容纳字符串和它的长度之前，在本例中，我们使用叶子来容纳我们所说的软线对象。这些是文本块和高度，被视为视觉线条。在这种情况下，节点的权重（我们称之为度量）是软线的高度和长度。存储高度是为了能够支持视口查询。此高度受其内部的中间线影响。此外，启用软包装时，软线不会与实际线一一对应，但可以跨越多条线。</p><p>  It’s important to mention that in Fleet we embrace immutability. Working with pure functions and immutable objects provide many benefits. Pure functions allow us to not only reason better about the code but also know that calling a function will not cause some other part of a system to change without our knowledge (i.e. have side-effects). In terms of data, knowing that an object is immutable means that it is thread-safe, and consequently there would not be race conditions when attempting any updates. For multi-threaded environments, this provides huge benefits.</p><p>值得一提的是，在舰队中，我们信奉不变性。使用纯函数和不可变对象有很多好处。纯函数不仅让我们能够更好地解释代码，还让我们知道调用函数不会导致系统的其他部分在我们不知情的情况下发生变化（即产生副作用）。就数据而言，知道一个对象是不可变的意味着它是线程安全的，因此在尝试任何更新时都不会有竞争条件。对于多线程环境，这提供了巨大的好处。</p><p> This idea of immutability is also central to operations that use rope structures. Previously we spoke about how we make updates to nodes and leaves of the trees. These are all done in an immutable way – any operation on the tree produces a new copy of the tree which shares the structure with the old one, except from the root to the single node which needs changing. The fact that the trees in general are wide and not deep means that paths are very short. If the operation leads to any unreferenced nodes, these get garbage collected.</p><p>这种不变性的想法对于使用绳索结构的操作也是至关重要的。之前我们讨论了如何更新树的节点和叶子。这些都是以不变的方式完成的——树上的任何操作都会生成树的新副本，该副本与旧副本共享结构，但从根到需要更改的单个节点除外。事实上，这些树一般都很宽，并不深，这意味着路径很短。如果操作导致任何未引用的节点，这些节点将被垃圾收集。</p><p> This is a significantly different approach from what we do on the IntelliJ platform where we use read-write lock mechanisms to perform changes.</p><p>这与我们在IntelliJ平台上使用读写锁定机制来执行更改的做法截然不同。</p><p>  As we’ve seen in this second part on how we build Fleet, something as simple as an editor where we can type and read code turns out to be a complex underlying aggregation of multiple different data structures, many of them being ropes. If you’re interested in learning more about ropes, make sure you check out the series on  Rope Science, which has heavily influenced the work we’ve been doing on Fleet.</p><p>正如我们在关于如何构建舰队的第二部分中所看到的，像编辑器这样简单的东西，我们可以在其中键入和读取代码，结果是一个复杂的多个不同数据结构的底层聚合，其中许多是绳索。如果你有兴趣了解更多关于绳索的知识，一定要看看绳索科学系列，它对我们在舰队上所做的工作产生了重大影响。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/舰队/">#舰队</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>