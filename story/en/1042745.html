<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不要将Protobuf用于遥测 Don't Use Protobuf for Telemetry</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Don't Use Protobuf for Telemetry<br/>不要将Protobuf用于遥测 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:51:13</div><div class="page_narrow text-break page_content"><p>Protobuf needs no introduction, but this post argues that you shouldn’t use it for telemetry.The basic premise of this post is that a good telemetry library needs to be lightweight to avoid perturbing the application; inefficient diagnostic tools are self-defeating.Unlike other formats, nested Protobuf messages cannot be written contiguously into a stream without significant buffering. The post doesn’t argue to never use Protobuf, but that the trade-off made by the  wire-format itself, as opposed to any existing implementation, is unlikely to work for lightweight message senders.</p><p>Protobuf无需介绍，但本文认为您不应该将其用于遥测。本文的基本前提是，一个好的遥测库必须轻巧，以免干扰应用程序。与其他格式不同，嵌套的Protobuf消息无法在没有大量缓冲的情况下连续写入流中。这篇文章并没有主张永远不要使用Protobuf，但是与任何现有的实现方式相比，有线格式本身进行的权衡对于轻量级消息发送者来说不太可能起作用。</p><p>  A few months ago I needed to become familiar with the Protobuf wire-format for a proof of concept.The motivation for digging in to the wire-format, rather than just using  protobuf-java, was the dimensions of the library, which I would need to bundle in an agent:</p><p>  几个月前，我需要熟悉Protobuf线格式以进行概念验证。深入研究线格式的动机（不仅仅是使用protobuf-java）是库的尺寸，我会需要捆绑代理：</p><p>  Just depending on the library adds 1.6MB and nearly 700 classes before you even generate your own message classes.Since the deployment in question was an agent which can’t assume the presence of  protobuf-java at runtime, there is no way to avoid bundling the extra 1.6MB.Since the aforementioned agent implements  ClassLoader isolation to avoid interfering with application class loading, even if  protobuf-java  is present at runtime, the classes would need to be loaded again by an isolated  ClassLoader.</p><p>  甚至在生成自己的消息类之前，仅依靠库就增加了1.6MB和将近700个类。由于所涉及的部署是无法在运行时假设protobuf-java存在的代理，因此无法避免捆绑额外的1.6MB。由于上述代理实现了ClassLoader隔离以避免干扰应用程序类的加载，即使在运行时存在protobuf-java，这些类也需要由隔离的ClassLoader再次加载。</p><p> A tracer only needs to  produce messages, so not all of those 669 classes (which doesn’t include your own generated classes) will get loaded, but a lot of them do.Having since implemented library-neutral Protobuf serialisation in DataDog’s  sketches-java, I have a reasonable  point of comparison to show how many classes get loaded in a write-only context:</p><p> 跟踪程序只需要生成消息，因此不会加载这669个类（不包括您自己生成的类）中的所有类，但其中的许多类都可以装入。自从在DataDog的sketches-java中实现了与库无关的Protobuf序列化以来，我有一个合理的比较点来显示在只写上下文中加载了多少个类：</p><p> @OutputTimeUnit ( TimeUnit . MICROSECONDS ) @BenchmarkMode ( Mode . AverageTime ) public  class  Serialize  extends  BuiltSketchState  {  @Benchmark  public  byte []  serialize ()  {  return  sketch . serialize (). array ();  }  @Benchmark  public  byte []  toProto ()  {  return  DDSketchProtoBinding . toProto ( sketch ). toByteArray ();  } }</p><p> @OutputTimeUnit（TimeUnit.MICROSECONDS）@BenchmarkMode（Mode.AverageTime）公共类Serialize扩展BuiltSketchState {@Benchmark公共字节[] serialize（）{返回草图。序列化（）。数组（）; } @Benchmark公共字节[] toProto（）{返回DDSketchProtoBinding。 toProto（草图）。 toByteArray（）; }}</p><p> Since I mention a DataDog library and am a DataDog employee, I make clear that none of the opinions presented in this post or elsewhere on this blog represent those of my employer.</p><p> 由于我提到了DataDog库并且是DataDog的雇员，因此我明确指出，本博文或此博客的其他地方提出的观点均不代表雇主的观点。</p><p> Each method produces identical bytes, and the purpose of the benchmark above is to compare speeds.One of the methods relies on a single class consisting of fewer than 150 lines of code, including white-space, whereas the other depends on a large library.For the record, the hand-written method  serialize above is roughly 10x faster than using  protobuf-java, but it’s not the point of this post. By running the benchmark for a single warmup iteration each, with the argument  -jvmArgsPrepend &#34;-verbose:class&#34;, the classes which are loaded are logged, which I captured in separate files.276 more classes are loaded when using  protobuf-java:</p><p> 每种方法产生相同的字节，以上基准测试的目的是比较速度。一种方法依赖于一个类，该类由少于150行的代码组成，包括空白，而另一种方法则依赖于大型库。记录在案，上面的手写方法比使用protobuf-java快大约10倍，但这不是本文的重点。通过分别使用-jvmArgsPrepend＆＃34; -verbose：class＆＃34;参数运行单个预热迭代的基准测试，将记录加载的类，我将它们记录在单独的文件中。使用时会加载276个更多的类protobuf-java： </p><p>  If you work at a large organisation which has entirely embraced Protobuf, I would not suggest worrying about 1.6MB or a few hundred loaded classes; these costs quickly amortise as you use the library for more features.However, your resource budget for a diagnostic agent which tells you what your application is doing and how it’s performing should be tiny, and I’m not sure  protobuf-java can be made to fit in to it, given the isolation constraints for agents outlined above.</p><p>如果您在一个完全采用Protobuf的大型组织中工作，我不建议担心1.6MB或数百个已加载的类；这些费用会随着您使用该库提供更多功能而迅速摊销。但是，用于诊断代理的资源预算（告诉您应用程序正在做什么以及其性能如何）应该很小，而且我不确定是否可以制作protobuf-java考虑到上面概述的代理程序的隔离限制，可以适应它。</p><p>  This meant that I needed to write my own (which is a lot easier than it sounds if you haven’t done this sort of thing before) so I had to read the only documentation there is on  encoding.I couldn’t get the formatter I had written based on my first reading of this document to produce valid protobuf because I had skim-read the section on embedded messages, and because it includes a design decision that would never have occurred to me.When I went back and read it again I was surprised to find that embedded messages are length-prefixed, but the length prefix is varint encoded, which means you don’t know how many bytes you need for the length until you’ve done the serialisation, and it’s recursive.</p><p>  这意味着我需要编写自己的文件（如果您之前没有做过这样的事情，这比听起来容易得多），所以我不得不阅读编码方面的唯一文档。我无法获得格式化程序我是基于对本文档的初读而编写的，以产生有效的protobuf，因为我已经略读了有关嵌入式消息的部分，并且因为它包含了我永远不会想到的设计决策。当我回头再次阅读时我很惊讶地发现嵌入式消息是长度前缀的，但是长度前缀是varint编码的，这意味着在完成序列化之前，您不知道长度需要多少字节，并且它是递归的。</p><p> Length prefixes aren’t unusual in binary formats: BSON documents are prefixed by their sizes in bytes, meaning sub-documents need to be serialised recursively before their lengths can be written.BSON makes this easy by not compressing the document length so you just leave 4 bytes for the length and come back and fill it in when popping document contexts ( it can add up to a significant portion of your database though).Msgpack, for example,  does apply prefix compression of embedded element lengths (e.g. maps and arrays) but the length is an element count, not a number of bytes, which makes streaming serialisation a lot easier to do.</p><p> 长度前缀在二进制格式中并不少见：BSON文档以其字节大小为前缀，这意味着子文档在写其长度之前需要递归序列化.BSON通过不压缩文档长度来简化此操作，因此您只需离开长度为4个字节，然后在弹出文档上下文时返回并填充（尽管它可能会增加数据库的很大一部分）。例如，Msgpack确实对嵌入式元素长度（例如，映射和数组）应用前缀压缩但是长度是元素计数，而不是字节数，这使得流序列化变得非常容易。</p><p> Protobuf does both, and, consequently, there’s no way to produce nested Protobuf messages without doing something relatively expensive.You must either maintain a stack and copy contents from frame to frame as they are popped, or pre-compute serialised lengths of nested elements recursively; it isn’t possible to simply write serialised output sequentially to a stream as it is with other formats. I abandoned the proof of concept when I found that a streaming zero-allocation msgpack codec I had written was around 6x faster than either  protobuf-java or a handwritten Protobuf codec for messages with nesting.Since I couldn’t remove the nesting in the messages I needed to produce, I blamed the wire-format and moved on.</p><p> Protobuf会同时执行这两种操作，因此，如果不做相对昂贵的事情，就无法生成嵌套的Protobuf消息。您必须维护堆栈并在弹出时逐帧复制内容，或者递归地预先计算嵌套元素的序列化长度;就像其他格式一样，不可能简单地将序列化的输出顺序地写入流中。当我发现我编写的流零分配msgpack编解码器比带有嵌套消息的protobuf-java或手写Protobuf编解码器快大约6倍时，我放弃了概念证明。由于我无法删除消息中的嵌套我需要制作，我指责有线格式并继续前进。</p><p> People who actually know Protobuf already know this (it’s literally written in the encoding manual), and understand the benefits which arise from this cost elsewhere (e.g. implementing partial deserialisation is easy, easy to skip over sections of the message), but lots of people don’t seem to understand the cost model the wire-format imposes.If they did, there would probably be a lot less nesting in Protobuf as used in the wild.</p><p> 真正了解Protobuf的人已经知道了这一点（实际上是在编码手册中写的），并且了解了其他地方从此成本中获得的收益（例如，实现部分反序列化很容易，很容易跳过消息的各个部分），但是很多人似乎不了解线格式所施加的成本模型，如果确实如此，那么Protobuf中的嵌套可能会比野外使用的少得多。</p><p> This more or less concludes my argument against using Protobuf for telemetry: if you find for yourself that producing Protobuf messages is costly, it’s not even a case of a third party library making the wrong trade-offs for your application; it’s the wire-format itself at fault.If you want to ship telemetry data out of an application and aim to minimise the impact on the application, even if you implement your own zero-allocation, micro-optimised codec, you shouldn’t choose Protobuf.</p><p> 这或多或少地得出了我反对使用Protobuf进行遥测的论点：如果您发现自己生成Protobuf消息的成本很高，那么即使是第三方库也无法为您的应用程序做出错误的权衡；如果您想将遥测数据从应用程序中传输出来，并希望将对应用程序的影响降到最低，即使您实现自己的零分配，微优化编解码器，也不应选择这种格式。 Protobuf。</p><p> This is a good opportunity to segue into describing the wire-format for Protobuf 3, filling in a couple of the gaps in  Google’s encoding document, but read the official document if you want to write your own.</p><p> 这是一个很好的机会，可以描述Protobuf 3的有线格式，填补Google编码文档中的一些空白，但是如果您要编写自己的文档，请阅读正式文档。 </p><p>  Protobuf’s wire format is really simple: it’s just a list of tagged key-value pairs. Since readers have a schema to refer to, ambiguity is permissible and advantageous.The logical structure of a Protobuf message is as below, with each tag followed by some bytes associated with the tag.</p><p>Protobuf的电汇格式非常简单：它只是一个标记的键/值对的列表。由于读者具有要引用的架构，因此模棱两可是允许的并且是有利的。Protobuf消息的逻辑结构如下，每个标签后跟与该标签关联的一些字节。</p><p>   body 	 ::= 	tagged_value*tagged_value ::= tag valuetag ::= varint((field_number &lt;&lt; 3) | wire_type)wire_type ::= VARINT | FIXED_64 | LENGTH_DELIMITED | GROUP_BEGIN | GROUP_END | FIXED_32VARINT ::= 0FIXED_64 ::= 1LENGTH_DELIMITED ::= 2GROUP_BEGIN ::= 3 (deprecated)GROUP_END ::= 4 (deprecated)FIXED_32 ::= 5value ::= varint | double | length_delimited | floatlength_delimited ::= varint(N) byte{N}</p><p>   正文:: =标记值*标记的值:: =标签值标记:: = varint（（field_number＆lt;＆lt; 3）| wire_type）wire_type :: = VARINT | FIXED_64 | LENGTH_DELIMITED | GROUP_BEGIN | GROUP_END | FIXED_32VARINT :: = 0FIXED_64 :: = 1LENGTH_DELIMITED :: = 2GROUP_BEGIN :: = 3（不推荐使用）GROUP_END :: = 4（不推荐使用）FIXED_32 :: = 5value :: = varint |双| length_delimited | floatlength_delimited :: = varint（N）个字节{N}</p><p> Each data item has a tag, which contains the field number (as defined in the .proto file) and one of the four wire types still in use in Protobuf 3.The tag is constructed by shifting the field number left by three bits and combining with the wire type, and then  varint-encoded so it takes up less space.Since there are only three bits for the wire type, there can only ever be eight wire types, and two have already been wasted on group begin and end markers (I don’t know the story behind these).Given that  FIXED_32=5 with only two possible wire types left, I imagine that there were some tense meetings before deciding to add it.</p><p> 每个数据项都有一个标签，其中包含字段编号（在.proto文件中定义）和Protobuf 3中仍在使用的四种导线类型之一。该标签是通过将字段编号向左移动三位并组合而成的导线类型，然后进行varint编码，因此占用的空间更少。由于导线类型只有3位，因此只能有8种导线类型，其中2种已经浪费在组开始和结束标记上（我不知道这些背后的故事）。考虑到FIXED_32 = 5仅剩两种可能的导线类型，我想在决定添加它之前会有一些紧张的会议。</p><p> The terminology above is my own, but notice that there are no terms like  repeated,  oneof, or  message.This is because they don’t exist at this level.  message is just a length delimiter followed by some more protobuf, preceded by a  LENGTH_DELIMITED tag; the schema has the necessary information to read the raw bytes. repeated fields come in two kinds: packed and not packed. Packed  repeated fields are indistinguishable from a  message or a  string on the wire. repeated fields which aren’t packed are a list of tag-values with the same field number and the element type in each tag, and they don’t need to be contiguous within the message.Incidentally, writers aren’t obliged not to repeat non- repeated fields, and as there is nothing to distinguish these fields over the wire, readers are obliged to take the  last value for a non- repeated field (which makes some of the partial deserialisers I’ve seen illegal).</p><p> 上面的术语是我自己的术语，但请注意，没有重复，重复或消息之类的术语。这是因为它们在此级别上不存在。 message只是一个长度定界符，后跟一些protobuf，之后是LENGTH_DELIMITED标签；模式具有读取原始字节所需的信息。重复字段分为两种：打包的和不打包的。打包的重复字段与消息或电线上的字符串是无法区分的。没有打包的重复字段是具有相同字段编号和每个标签中元素类型的标签值的列表，并且它们不必在消息中是连续的。顺便说一句，编写者不必重复非重复字段，并且由于无法通过导线区分这些字段，因此读者必须对非重复字段取最后一个值（这使我看到的部分反序列化器是非法的）。</p><p> FIXED_32 corresponds to proto types  float,  fixed32, and  sfixed32, whereas  FIXED_64 corresponds to  double,  fixed64, and  sfixed64.All other integers, which includes booleans, are  varint encoded, which has the basic effect of removing leading zeros in order to save space.Starting with the least significant bits, seven bits are taken at a time from the integer until no bits remain, and all but the last byte have their most significant bit set.This allows the parser to detect the end of an integer by looking for a byte with the MSB unset. Whilst this saves space, it makes reserving space for lengths not yet known problematic.</p><p> FIXED_32对应于原型类型float，fixed32和sfixed32，而FIXED_64对应于double，fixed64和sfixed64。所有其他整数（包括布尔值）都是varint编码的，具有删除前导零以节省空间的基本作用。从最低有效位开始，从整数开始一次取7位，直到没有剩余位为止，除最后一个字节外的所有字节都设置了最高有效位，这使解析器可以通过查找整数来检测整数的结尾未设置MSB的字节。虽然这节省了空间，但是使得保留空间的长度尚不成问题。</p><p> map&lt;T, U&gt; can be encoded as if it were a  repeated message with the key of proto type  T in field position 1, and the value of proto type  U in field position 2. That is, for each entry in the map, a tag with the field number  x of the map field and  LENGTH_DELIMITED wire type, followed by the same protobuf as would be generated from:</p><p> 图＆lt; T，U＆gt;可以被编码为重复消息，在字段位置1中使用原型类型T的键，在字段位置2中使用原型类型U的值。即，对于映射中的每个条目，使用具有字段编号的标签地图字段的x和LENGTH_DELIMITED导线类型，后跟与以下相同的protobuf：</p><p>  Varints are probably the most interesting thing about Protobuf, and I stumbled upon some simple tricks to produce them more efficiently than in other Java libraries I looked at.This is what it looks like in  protobuf-java’s  CodedOutputStream (see  source)</p><p>  Varint可能是Protobuf上最有趣的东西，我偶然发现了一些简单的技巧，可以比我看过的其他Java库更有效地产生它们。这就是protobuf-java的CodedOutputStream的样子（请参阅源代码） </p><p> @Override  public  final  void  writeUInt64NoTag ( long  value )  throws  IOException  {  if  ( HAS_UNSAFE_ARRAY_OPERATIONS  &amp;&amp;  spaceLeft ()  &gt;=  MAX_VARINT_SIZE )  {  while  ( true )  {  if  (( value  &amp;  ~ 0x7F L )  ==  0 )  {  UnsafeUtil . putByte ( buffer ,  position ++,  ( byte )  value );  return ;  }  else  {  UnsafeUtil . putByte ( buffer ,  position ++,  ( byte )  ((( int )  value  &amp;  0x7F )  |  0x80 ));  value  &gt;&gt;&gt;=  7 ;  }  }  }  else  {  try  {  while  ( true )  {  if  (( value  &amp;  ~ 0x7F L )  ==  0 )  {  buffer [ position ++]  =  ( byte )  value ;  return ;  }  else  {  buffer [ position ++]  =  ( byte )  ((( int )  value  &amp;  0x7F )  |  0x80 );  value  &gt;&gt;&gt;=  7 ;  }  }  }  catch  ( IndexOutOfBoundsException  e )  {  throw  new  OutOfSpaceException (  String . format ( &#34;Pos: %d, limit: %d, len: %d&#34; ,  position ,  limit ,  1 ),  e );  }  }  }</p><p>@Override public final void writeUInt64NoTag（long value）引发IOException {if（HAS_UNSAFE_ARRAY_OPERATIONS＆amp;＆amp; spaceLeft（）＆gt; = MAX_VARINT_SIZE）{while（true）{if（（（value＆amp;〜0x7F L）== 0）{UnsafeUtil 。 putByte（缓冲区，位置++，（字节）值）;回报; } else {UnsafeUtil。 putByte（buffer，position ++，（byte）（（（int）value＆amp; 0x7F）| 0x80））;值＆gt;＆gt;＆gt; = 7; }}}其他{尝试{while（true）{if（（value＆amp;〜0x7F L）== 0）{buffer [position ++] =（byte）value;回报; } else {缓冲区[位置++] =（字节）（（（（int）value＆amp; 0x7F）| 0x80）;值＆gt;＆gt;＆gt; = 7; }}} catch（IndexOutOfBoundsException e）{抛出新的OutOfSpaceException（String。format（＆＃34; Pos：％d，limit：％d，len：％d＆＃34;，position，limit，1），e）; }}}</p><p> Ignoring all of the boilerplate to do with detecting whether  Unsafe is available, this reduces to a loop with a data dependency:</p><p> 忽略所有样板都与检测不安全是否可用有关，这简化为具有数据依赖性的循环：</p><p> while  ( true )  {  if  (( value  &amp;  ~ 0x7F L )  ==  0 )  {  buffer [ position ++]  =  ( byte )  value ;  return ;  }  else  {  buffer [ position ++]  =  ( byte )  ((( int )  value  &amp;  0x7F )  |  0x80 );  value  &gt;&gt;&gt;=  7 ;  }  }</p><p> while（true）{if（（（value＆amp;〜0x7F L）== 0）{buffer [position ++] =（byte）value;回报; } else {缓冲区[位置++] =（字节）（（（（int）value＆amp; 0x7F）| 0x80）;值＆gt;＆gt;＆gt; = 7; }}</p><p> Data dependencies are generally bad in CPU bound loops, such as if you have a reasonably large packed array of some integer type, perhaps if you are encoding some kind of histogram.You can actually write this much more efficiently without using  Unsafe by turning this in to a counted loop, which you can do by computing the number of leading zeros and dividing by 7:</p><p> 在CPU绑定循环中，数据依赖关系通常很糟糕，例如，如果您有一个相当大的某种整数类型的压缩数组，或者如果您正在编码某种直方图，则实际上可以更有效地编写此代码而无需使用Unsafe，方法是将其打开到计数循环，您可以通过计算前导零的数目并除以7来完成：</p><p>  Long.numberOfLeadingZeros is a HotSpot intrinsic which is compiled to a single instruction -  lzcnt on x86 and  clz on ARM - which is really fast.Happily, negative proper fractions round to zero.Integer divisions are really expensive, but the JIT compiler won’t actually emit a divide instruction for this code.Even so, this can be sped up a little more by precomputing the lengths and just looking them up.</p><p>  Long.numberOfLeadingZeros是一个HotSpot内部函数，可以编译为单条指令-在x86上为lzcnt，在ARM上为clz-确实是非常快。实际上会为此代码发出除法指令。即使这样，也可以通过预先计算长度并查找它们来加快速度。</p><p> private  static  final  int []  VAR_INT_LENGTHS  =  new  int [ 65 ];  static  {  for  ( int  i  =  0 ;  i  &lt;=  64 ;  ++ i )  {  VAR_INT_LENGTHS [ i ]  =  ( 63  -  i )  /  7 ;  }  }  int  varIntLength ( long  value )  {  return  VAR_INT_LENGTHS [ Long . numberOfLeadingZeros ( value )];  }</p><p> 私有静态最终int [] VAR_INT_LENGTHS =新int [65]；静态{for（int i = 0; i＆lt; = 64; ++ i）{VAR_INT_LENGTHS [i] =（63-i）/ 7; }} int varIntLength（长值）{返回VAR_INT_LENGTHS [长整数。 numberOfLeadingZeros（value）]; }</p><p>  private  void  writeVarInt ( int  offset ,  long  value )  {  int  length  =  varIntLength ( value );  for  ( int  i  =  0 ;  i  &lt;  length ;  ++ i )  {  buffer [ offset  +  i ]  =  (( byte )  (( value  &amp;  0x7F )  |  0x80 ));  value  &gt;&gt;&gt;=  7 ;  }  buffer [ offset  +  i ]  =  ( byte )  value ;  }</p><p>  私有void writeVarInt（int offset，long value）{int length = varIntLength（value）; for（int i = 0; i＆lt; length; ++ i）{缓冲区[offset + i] =（（字节）（（value＆amp; 0x7F）| 0x80））;值＆gt;＆gt;＆gt; = 7; }缓冲区[偏移+ i] =（字节）值; } </p><p> I found that this performs similarly for short varints (tags are typically very short varints, so it’s an important case to consider), but for larger numbers the counted loop performs much better.</p><p>我发现对于短varint（标签通常是非常短的varint），其性能类似。但是对于较大的数字，计数循环的性能要好得多。</p><p>  Protobuf’s strength lies in its interface definition language, which makes communication between components owned by different teams easy, but it wasn’t designed for performance.The generated Java code is generally OK, if a little bloated, and you’ll probably find it allocates a lot, but it has to, because of the wire format.If you have a low latency or low overhead use case, Protobuf may not be the right choice.If the ability to declare interfaces and generate compliant services and clients trumps performance, you can improve performance by removing any nesting you don’t need.I really don’t think Protobuf is the right choice for telemetry because perfect telemetry would have no overhead whatsoever, which is impossible, but wire-formats which favour readers over writers should be avoided to move cost out of the host application.</p><p>  Protobuf的优势在于其接口定义语言，该语言使不同团队拥有的组件之间的通信变得容易，但是它并不是为提高性能而设计的。生成的Java代码通常还可以，如果有点肿，您可能会发现它可以分配很多，但是必须这样做，因为有线格式。如果延迟时间短或开销低的用例，Protobuf可能不是正确的选择。如果声明接口和生成兼容服务和客户端的能力比性能高，则您可以选择Protobuf。可以通过消除不需要的嵌套来提高性能。我真的不认为Protobuf是遥测的正确选择，因为完美的遥测不会有任何开销，这是不可能的，但是应该采用有利于读者而不是作家的有线格式避免将成本移出主机应用程序。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://richardstartin.github.io/posts/dont-use-protobuf-for-telemetry">https://richardstartin.github.io/posts/dont-use-protobuf-for-telemetry</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/protobuf/">#protobuf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>