<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>建立事件存储 Building an Event Storage</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building an Event Storage<br/>建立事件存储 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-13 03:37:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/b9713f9d9377425a7f02aff6820526e0.png"><img src="http://img2.diglog.com/img/2020/12/b9713f9d9377425a7f02aff6820526e0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In “Events as a Storage Mechanism” the concept of rebuilding state from a series of events was looked at from a conceptual viewpoint. This chapter will focus on the implementation of an actual Event Storage and some of the issues that come up in producing an implementation.</p><p>在“事件作为存储机制”中，从概念的角度考察了从一系列事件重建状态的概念。本章将重点讨论实际事件存储的实现以及在产生实现时会出现的一些问题。</p><p> The implementation discussed in this chapter is not intended to be a production quality Event Storage, more so it is provided as a discussion point around how to build an Event Storage. The implementation here although not highly performant could meet the needs of a large percentage of applications that are built today.</p><p> 本章中讨论的实现并非旨在成为具有生产质量的事件存储，更多地是作为围绕如何构建事件存储的讨论点而提供的。尽管性能不高，但此处的实现可以满足当今构建的大部分应用程序的需求。</p><p> For the explanatory implementation it is easiest to build the Event Storage in an existing technology such as a RDBMS. This will alleviate many of the technical issues that can arise that are out of the scope of a basic discussion on how to build an event storage such as transaction commit models or data locality for read performance.</p><p> 对于说明性实施，最简单的方法是在现有技术（如RDBMS）中构建事件存储。这将减轻可能出现的许多技术问题，这些问题不在有关如何构建事件存储的基本讨论的范围内，例如事务提交模型或数据局部性以提高读取性能。</p><p>  A basic Event Storage can be represented in a Relational Database utilizing only two tables.</p><p>  基本事件存储可以仅使用两个表在关系数据库中表示。</p><p>   This table represents the actual Event Log. There will be one entry per event in this table. The event itself is stored in the [Data] column. The event is stored using some form of serialization, for the rest of this discussion the mechanism will assumed to be built in serialization although the use of the memento pattern can be highly advantageous.</p><p>   该表代表实际的事件日志。该表中的每个事件只有一个条目。事件本身存储在[Data]列中。该事件是使用某种形式的序列化存储的，对于本讨论的其余部分，该机制将假定是建立在序列化中的，尽管使用记忆模式可能会非常有利。</p><p> The table is shown with the minimum amount of information possible, most organizations would want to add a few columns such as the time that the change was made or context information associated with the change. Examples of context information might include the user that initiated the change, the ip address they sourced the change from, or their level of permission when they sourced the change.</p><p> 该表显示的信息量最少，大多数组织希望添加几列，例如进行更改的时间或与更改关联的上下文信息。上下文信息的示例可能包括发起更改的用户，他们从中发出更改的IP地址或他们在发出更改时的权限级别。</p><p> A version number is also stored with each event in the Events Table. This can generally be thought of as an increasing integer for most cases. Each event that is saved has an incremented version number. The version number is unique and sequential only within the context of a given aggregate. This is because Aggregate Root boundaries are consistency boundaries.</p><p> 版本号也与每个事件一起存储在事件表中。在大多数情况下，通常可以将其视为一个递增的整数。保存的每个事件都有一个递增的版本号。版本号仅在给定聚合的上下文中是唯一且顺序的。这是因为聚合根边界是一致性边界。 </p><p> The [AggregateId] column is a foreign key that should be indexed; it points to the next table which is the Aggregates table.</p><p>[AggregateId]列是应该建立索引的外键；它指向下一个表，即“聚集”表。</p><p>   Author comment: I have gone back and forth between calling this concept “Aggregate” in the Event Storage in lieu of another name such as “Event Provider” as “Aggregate” is really a domain concept and an Event Storage could work without a domain.</p><p>   作者评论：我在事件存储中称呼这个概念为“聚合”来代替诸如“事件提供者”之类的另一个名字，因为“聚合”实际上是一个域概念，并且事件存储可以在没有域的情况下工作。</p><p> The Aggregates table is representing the aggregates currently in the system, every aggregate must have an entry in this table. Along with the identifier there is a denormalization of the current version number. This is primarily an optimization as it could be derived from the Events table but it is much faster to query the denormalization that it would be to query the Events table directly. This value is also used in the optimistic concurrency check.</p><p> 聚合表代表当前系统中的聚合，每个聚合必须在此表中都有一个条目。除标识符外，还对当前版本号进行了非规范化。这主要是一种优化，因为它可以从事件表中派生，但是查询非规范化要比直接查询事件表要快得多。此值还用于乐观并发检查中。</p><p> Also included is a [Type] column for this example, this would be the fully qualified name of the type of aggregate being stored. This can be useful for various purposes not the least of which is debugging, it is however unnecessary for the creation of a basic Event Storage.</p><p> 在此示例中还包括[Type]列，这将是要存储的聚合类型的完全限定名称。这对于各种目的很有用，其中不仅包括调试，而且对于创建基本事件存储来说是不必要的。</p><p>  Event Storages are far simpler that most data storage mechanisms as they do not support general purpose querying. An Event Storage at its simplest level has only two operations. Having only two operations makes an Event Storage simpler than most data storage mechanisms as well as easier to optimize.</p><p>  与大多数数据存储机制相比，事件存储要简单得多，因为它们不支持通用查询。最简单的事件存储只有两个操作。仅执行两个操作就使事件存储比大多数数据存储机制更简单，并且更易于优化。</p><p> The first operation is to get all of the events for an aggregate. It is extremely important that the events are ordered in the same order that they were written, the version number can be used for this purpose. This can all be done quite simply using an underlying RDBMS.</p><p> 第一步是获取所有事件的汇总。按事件写入的顺序对事件进行排序非常重要，可以将版本号用于此目的。使用底层RDBMS可以很简单地完成所有操作。</p><p>  This is the only query that should be executed by a production system against the Event Storage. A possible secondary query that can be useful is to limit this result set by an actual date to see the state of an object at a point in time, but generally a production system should not be doing this.</p><p>  这是生产系统应针对事件存储执行的唯一查询。可能有用的辅助查询是通过实际日期限制此结果集，以便在某个时间点查看对象的状态，但通常生产系统不应这样做。 </p><p> The other operation an Event Storage must support is the writing of a set of events to an aggregate root. This can be done either in code or in a stored procedure. A stored procedure or dynamically generated SQL containing if statements is preferred as without the insert process will take multiple round trips. The pseudo-code for the insert process can be seen in Listing 1.</p><p>事件存储必须支持的另一种操作是将一组事件写入聚合根。这可以用代码或存储过程来完成。如果没有插入过程，则首选包含if语句的存储过程或动态生成的SQL将需要多次往返。清单1中可以看到插入过程的伪代码。</p><p>   The write operation is also relatively simple though there are a few subtleties to be found within it. The basic narrative is that it first checks to see if an aggregate exists with the unique identifier it is to use, if there is not one it will create it and consider the current version to be zero. It will then attempt to do an optimistic concurrency test on the data coming in if the expected version does not match the actual version it will raise a concurrency exception. Providing the versions are the same, it will then loop through the events being saved and insert them into the events table, incrementing the version number by one for each event. Finally it will update the Aggregates table to the new current version number for the aggregate. It is important to note that these operations are in a transaction as it is required to insure that optimistic concurrency amongst other things works in a distributed environment.</p><p>   尽管其中有一些细微之处，但写操作也相对简单。基本叙述是，它首先检查是否存在带有要使用的唯一标识符的聚合，如果没有，它将创建该聚合并将其视为当前版本。然后，如果预期版本与实际版本不匹配，它将尝试对传入的数据进行乐观并发测试，这将引发并发异常。如果版本相同，则它将循环浏览所保存的事件并将其插入事件表中，从而为每个事件将版本号增加一。最后，它将“聚合”表更新为该聚合的新的当前版本号。重要的是要注意，这些操作是在事务中，因为需要确保乐观的并发性在分布式环境中起作用。</p><p> The contract for an Event Storage in code can be defined with the following interface.</p><p> 可以使用以下接口定义代码中事件存储的合同。</p><p>   Although not a trivial exercise to create a production quality Event Storage the overall concepts behind an Event Storage are relatively easy. Likely in the future there will be many off the shelf Event Storage systems available as either products or open source projects. There is however one very important optimization that was discussed in “Events as a Storage Mechanism” that really should exist in most systems and that is the concept of a “Rolling Snapshot”.</p><p>   尽管创建产品质量的事件存储并非轻而易举的事，但事件存储背后的总体概念相对容易。将来可能会有许多现成的事件存储系统作为产品或开源项目提供。但是，“事件作为存储机制”中讨论了一个非常重要的优化，它实际上应该存在于大多数系统中，这就是“滚动快照”的概念。</p><p>  Rolling Snapshots are a heuristic to prevent the need to load all of the events when issuing a query to rebuild an Aggregate. They are a denormalization of the aggregate at a given point in time. A change to the query logic and an additional table are all that is necessary to add the heuristic to the basic Event Storage. Further discussion on Rolling Snapshots at a conceptual level can be found in the “Events as a Storage Mechanism” chapter.</p><p>  滚动快照是一种启发式方法，可以防止在发出查询以重建聚合时加载所有事件。它们是在给定时间点的聚合异常化。将启发式方法添加到基本事件存储中，只需更改查询逻辑和其他表即可。在概念级别上有关滚动快照的进一步讨论可以在“事件作为存储机制”一章中找到。</p><p>   The Snapshots table is relatively basic. It’s primary data in the blob that contains the serialized version of the aggregate at a given point in time. The serialized data could be in any one of a host of possible schemas, binary, XML, raw text, etc. The decision on how to serialize the snapshots is really dependent upon the system being built. A version number is included with the snapshot, it represents which version of the aggregate the snapshot represents.</p><p>   快照表是相对基本的。它是Blob中的主要数据，其中包含给定时间点的汇总的序列化版本。序列化的数据可以是许多可能的模式，二进制，XML，原始文本等中的任何一种。如何序列化快照的决定实际上取决于所构建的系统。快照包含一个版本号，它表示快照代表的聚合的哪个版本。</p><p> In order to have snapshots being created a process that handles the task of creating the snapshots needs to be introduced. This process can live outside of the Application Server as a background process. There can be a single process running or many depending on needs due to throughput. All snapshots happen asynchronously. Figure 4 shows a conceptual architecture with a [SnapShotter] process introduced.</p><p> 为了创建快照，需要引入处理快照创建任务的过程。此过程可以作为后台进程驻留在Application Server外部。由于吞吐量的关系，可以运行一个进程，也可以根据需要运行多个进程。所有快照都是异步发生的。图4显示了引入[SnapShotter]流程的概念架构。 </p><p>   The [SnapShotter] sits behind the Event Storage and periodically queries for any Aggregates that need to have a snapshot taken because they have gone past the allowed number of events. This query can be done quite easily in the simple Event Storage discussed by joining the Aggregates table to the Snapshots table on the Aggregate identifier. The difference is calculated by subtracting the last snapshot version from the current version with a where clause that only returned the aggregates with a difference greater than some number. This query will return all of the Aggregates that a snapshot to be created. The snapshotter would then iterate through this list of Aggregates to create the snapshots (if using multiple snapshotters the competing consumer pattern works well here).</p><p>[SnapShotter]位于事件存储后面，并定期查询所有需要快照的聚合，因为它们已经超过了允许的事件数量。通过将Aggregates表连接到Aggregate标识符上的Snapshots表，可以在讨论的简单事件存储中轻松地完成此查询。差异是通过使用where子句从当前版本中减去最后一个快照版本而得出的，该子句仅返回差异大于某个数字的聚合。该查询将返回要创建快照的所有聚合。然后，快照程​​序将遍历此聚合列表以创建快照（如果使用多个快照程序，则竞争的消费者模式在此效果很好）。</p><p> The process of creating a snapshot involves having the domain load up the current version of the Aggregate then take a snapshot of it. The creation of the snapshot can be done in many ways. Once the snapshot has been taken, it is saved back to the snapshot table so that queries will have the snapshot available.</p><p> 创建快照的过程涉及让域加载聚合的当前版本，然后对其进行快照。快照的创建可以通过多种方式完成。拍摄快照后，会将其保存回快照表，以便查询可以使用快照。</p><p> Many use the default serialization package available with their platform with good results though the Memento pattern is quite useful when dealing with snapshots. The Memento pattern (or custom serialization) better insulates the domain over time as the structure of the domain objects change. The default serializer has versioning problems when the new structure is released (the existing snapshots must either deleted and recreated or updated to match the new schema). The use of the Memento pattern allows the separated versioning of the snapshot schema from the domain object itself.</p><p> 尽管使用Memento模式在处理快照时非常有用，但许多人使用其平台上可用的默认序列化程序包都能获得良好的结果。随着域对象结构的变化，随着时间的推移，Memento模式（或自定义序列化）可以更好地隔离域。释放新结构时，默认的序列化程序存在版本控制问题（必须删除并重新创建或更新现有快照，以匹配新架构）。使用Memento模式可以将快照架构的版本与域对象本身分开。</p><p> In “Events as a Storage Mechanism” a different, simpler mechanism was shown for the storage of snapshots. That system had the snapshots in line in the Event Log, this other mechanism although conceptually simpler has a few issues that can come up in a production system. The issues revolve around the need of ordering of the snapshot within the event log.</p><p> 在“事件作为存储机制”中，展示了一种不同的，更简单的快照存储机制。该系统的快照在事件日志中排成一行，这是另一种机制，尽管从概念上讲比较简单，但生产系统中可能会遇到一些问题。问题围绕着在事件日志中对快照进行排序的需求。</p><p> Consider that the Snapshotter has realized that an Aggregate Root needs to have a snapshot taken. It loads up the Aggregate and takes the snapshot. Unfortunately while it was doing this, one of the Application Servers made a change to the same Aggregate. As the snapshot is position dependent within the Event Log, it would receive an optimistic concurrency failure. The easy answer would be to simply repeat the process but what if it failed again? The snapshotter on a very busy Aggregate could end up in a situation where it would have a very low probability of actually writing the snapshot successfully.</p><p> 考虑到Snapshotter已经意识到聚合根需要创建快照。它加载聚合并拍摄快照。不幸的是，在执行此操作时，其中一个应用程序服务器对同一聚合进行了更改。由于快照在事件日志中取决于位置，因此它将收到乐观并发故障。简单的答案是简单地重复该过程，但是如果再次失败该怎么办？繁忙的聚合服务器上的快照程序可能会最终成功写入快照的可能性很小。</p><p> By separating the snapshots into their own table and associating them to a version of the aggregate this problem is solved. Ordering of snapshots is not needed, the snapshot does not even need to be at the latest version, the snapshot that is taken is valid  at the version it was taken.</p><p> 通过将快照分成各自的表并将它们与聚合的版本关联，可以解决此问题。不需要对快照进行排序，快照甚至不需要是最新版本，所拍摄的快照在所拍摄的版本中有效。</p><p> Snapshots are a heuristic that will dramatically improve the performance of many systems, though not all systems need snapshotting. It is generally recommended to handle development without snapshotting as it can always be introduced later as a simple performance enhancement for the system.</p><p> 快照是一种启发式方法，可以显着提高许多系统的性能，尽管并非所有系统都需要快照。通常建议在不使用快照的情况下处理开发，因为以后可以将其作为对系统的简单性能增强而引入。 </p><p>  It has been previously discussed that the events coming out of a domain are also an [Integration Model]. Very often these events are not only saved but also published to queue where they are dispatched asynchronously to listeners either within the same system (the reporting model is a good example) or to other applications. An issue that exists with many systems publishing events is that they require a two-phase commit between whatever storage they are using (Relational or otherwise) and the publishing of their events to the queue.</p><p>先前已经讨论过，来自域的事件也是[集成模型]。通常，这些事件不仅被保存，而且还被发布到队列中，在该队列中，它们被异步地分发给同一系统内的侦听器（报告模型是一个很好的例子）或其他应用程序。许多发布事件的系统都存在一个问题，即它们需要在使用的任何存储（关系存储或其他存储）与事件发布到队列之间进行两阶段提交。</p><p> The reason that the two-phase commit is needed is that a catastrophe could occur during the small period of time between when the write to the data storage commits and when the write to the queue commits. If a failure were to happen during this period the message would not be published on the queue (or if the other direction it may be published but the change may not be saved). If either case were to happen the listeners of the events would be out of sync with the producer.</p><p> 之所以需要两阶段提交，是因为在对数据存储的写入提交与对队列的写入提交之间的一小段时间内，可能会发生灾难。如果在此期间发生故障，则该消息将不会在队列中发布（或者如果是其他方向，则消息可能会发布，但更改可能不会保存）。如果发生任何一种情况，事件的侦听器将与生产者不同步。</p><p> The two-phase commit can be expensive but for low latency systems there is a larger problem when dealing with this situation. Generally the queue itself is persistent so the event becomes written on disk twice in the two-phase commit, once to the Event Storage and once to the persistent queue. Given for most systems having dual writes is not that important but if you have low latency requirements it can become quite an expensive operation as it will also force seeks on the disk. Figure 5 illustrates the two-phase commit between data storage and a publishing queue.</p><p> 两阶段提交可能很昂贵，但是对于低延迟系统，在处理这种情况时存在更大的问题。通常，队列本身是持久性的，因此该事件在两阶段提交中两次写入磁盘，一次写入事件存储，一次写入持久性队列。对于大多数具有双重写入功能的系统而言，这并不重要，但是如果您对延迟的要求较低，那么它可能会成为一项非常昂贵的操作，因为它还会强制在磁盘上进行寻道。图5说明了数据存储和发布队列之间的两阶段提交。</p><p>   Some try to get around this problem by only writing to a queue then have something on the other side of the queue update the data storage with the changes represented by the events, this however has some issues. The largest issue is that not all of the events will be able to be written to the storage, eventual consistency has been introduced and it is possible that an optimistic concurrency problem will occur on the write of the events. Dealing with this problem in a production system is non-trivial.</p><p>   一些尝试通过仅写入队列来解决此问题，然后在队列的另一端使用事件表示的更改来更新数据存储的方法，但这存在一些问题。最大的问题是，并非所有事件都可以写入存储，最终引入了一致性，并且在写入事件时可能会出现乐观的并发问题。在生产系统中处理此问题并非易事。</p><p> Many organizations do the opposite, use the event storage as a queue. Adding a sequence number to the Events table previously discussed allows the use the Event Storage as a queue. Figure 5 illustrates the change to the schema of the Events table.</p><p> 许多组织则相反，将事件存储用作队列。在前面讨论的“事件”表中添加序列号可以将“事件存储”用作队列。图5说明了对事件表的架构的更改。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cqrs.wordpress.com/documents/building-event-storage/">https://cqrs.wordpress.com/documents/building-event-storage/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/事件/">#事件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/event/">#event</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>