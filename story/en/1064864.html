<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Process Monitor在Windows中查找特权升级漏洞 Finding Privilege Escalation Vulnerabilities in Windows Using Process Monitor</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Finding Privilege Escalation Vulnerabilities in Windows Using Process Monitor<br/>使用Process Monitor在Windows中查找特权升级漏洞 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-10 23:12:43</div><div class="page_narrow text-break page_content"><p>Skip to end of metadata    Go to start of metadata   This post will explain how to find privilege escalation vuls on Windows that no one appears to be looking for, because it&#39;s been pretty easy to find a bunch of them. After explaining how to find them, I&#39;ll introduce some defenses that can partly mitigate the problem in different ways. But what I&#39;d like to see change is for developers to start looking for these vuls in the way I describe so that they stop introducing them in the first place.</p><p>跳到元数据结束转到元数据的开始，这篇文章将解释如何在Windows上找到任何似乎无法寻找的Windows上的特权升级Vuls，因为它＆＃39; S一直很容易找到一堆。解释如何找到它们，我＆＃39; LL介绍一些可以以不同方式减轻问题的一些防御。但是，我喜欢看到改变是为了开发人员在我描述的方式开始寻找这些VULS，以便他们停止首先引入它们。</p><p> Back when we first released   CERT BFF, the usual process for putting together a proof-of-concept exploit for a memory corruption vulnerability was:</p><p> 回到我们第一次发布CERT BFF时，将概念验证泄漏的常用流程用于内存损坏漏洞的常规过程是：</p><p> Find out which bytes can be used to store your shellcode, using   BFF string minimization.</p><p> 了解哪些字节可用于存储shellcode，使用BFF字符串最小化。</p><p> Use   ROP as necessary to modify the program flow so that it executes your shellcode.</p><p> 必要时使用ROP来修改程序流程，以便它执行ShellCode。</p><p> It was often relatively straightforward to go from   Start to PoC with CERT BFF. As time went on, the bar for exploiting memory corruption vulnerabilities was raised. This can likely be attributed to two things that happened over the years:</p><p> 从START到POC与CERT BFF开始往往相对简单。随着时间的推移，筹集了用于利用内存损坏漏洞的酒吧。这可能归因于多年来发生的两件事：</p><p> Increased presence of exploit mitigations in both software and the platforms that they run on.</p><p> 在软件和他们运行的平台上增加了利用缓解的存在。</p><p> I have recently worked on a vulnerability discovery technique that reminded me of the early BFF days. Both with respect to how easy it is to find the vulnerabilities and also how easy it can be to exploit them. In fact, the concept is so trivial that I was surprised by how successful it was in finding vulnerabilities. Just like the idea of going directly from fuzzing with BFF to a working exploit became less and less viable as time went on, I&#39;d like for there to be much less low-hanging fruit that can be easily found with this technique.</p><p> 我最近曾在漏洞发现技术上，提醒我早期的BFF天。两个都是为了找到漏洞的容易以及如何利用它们是多么容易。事实上，这个概念如此琐碎，我对发现漏洞的成功感到惊讶。就像直接与BFF直接从模糊到模糊的想法，因为时间继续下去，因为时间越来越少，我喜欢那里的低悬垂的水果，可以用这种技术很容易地发现。 </p><p> In this post I will share some of my findings as well as the filter itself for finding privilege escalation vulnerabilities with   Sysinternals Process Monitor (Procmon).</p><p>在这篇文章中，我将分享我的一些发现以及过滤器本身，用于查找使用Sysinternals进程监视器（Procmon）的特权升级漏洞。</p><p>  When a program is installed on the Windows platform, some components of it may run with privileges, regardless of which user is currently logged on to the system. These privileged components generally take two forms:</p><p>  当程序安装在Windows平台上时，它的某些组件可能会使用权限运行，无论该用户当前登录到系统。这些特权组件通常采取两种形式：</p><p>  How might we achieve privilege escalation on a Windows system? Any time that a privileged process interacts with a resource that an unprivileged user may be able to influence, this opens up the possibility for a privilege escalation vulnerability.</p><p>  我们如何在Windows系统上实现特权升级？任何时候特权进程与未经特权用户可能能够影响的资源交互，这会使特权升级漏洞的可能性打开。</p><p>   The easiest way to check for privileged processes that might be able to be influenced by non-privileged users is to use a Process Monitor filter that displays operations based on the following attributes:</p><p>   检查可能能够受非特权用户影响的特权进程的最简单方法是使用基于以下属性显示操作的进程监视器过滤器：</p><p>  Checks 1 and 2 can be trivially implemented in Process Monitor. Check 3 is a little more complicated and may result in some false positives if we limit our tool to strictly what can be done with a Process Monitor Filter. But I&#39;ve created a   filter that seems to do a pretty good job of making privilege escalation vulnerabilities pretty obvious.</p><p>  检查1和2可以在过程监视器中进行琐碎。检查3有点复杂，如果我们将工具限制为严格，可以使用流程监视器过滤器完成操作，可能会导致某些误报。但是，我创造了一个过滤器，似乎做了一个非常好的工作，使特权升级脆弱性很明显。</p><p>       Let&#39;s start by looking at a boot log of a common baseline that we might deal with as a vulnerability analyst - a 64-bit Windows 10 2004 system with VMware Tools installed:</p><p>       Let＆＃39</p><p> Even with virtually no software installed in our VM, we can already see something suspicious:  C:\Program%20Files\</p><p> 即使在我们的VM中几乎没有安装软件，我们也可以看到可疑的东西：C：\ Program％20files \ </p><p> Windows users may be familiar with the path  C:\Program Files\, but what&#39;s with the  %20? Why might such a file operation occur? We&#39;ll cover the reason in the section below.</p><p>Windows用户可能熟悉路径C：\ Program Files \，但是＆＃39; s为％20？为什么可能发生这种文件操作？我们＆＃39; ll涵盖下面的部分的原因。</p><p>   There are a number of mistakes that a developer might make that can lead to a privileged process being able to be influenced by an unprivileged user. The mistakes that I&#39;ve noticed with respect to simple privilege escalation vulnerabilities with Windows applications fall into two main categories:</p><p>   有许多错误，即开发人员可能会使这可以导致能够受到非特权用户的特权进程。我在Windows应用程序中对简单的特权升级漏洞感到注意到的错误分为两个主要类别：</p><p>   In some cases, an unexpected path is accessed during the execution of a program. That is, the developer would probably be surprised if they realized that the path was being accessed. These unexpected path accesses can be caused by a number of reasons:</p><p>   在某些情况下，在执行程序期间访问意外路径。也就是说，如果他们意识到被访问的路径，开发人员可能会感到惊讶。这些意外的路径访问可能是由许多原因引起的：</p><p>  As we noticed in the screenshot above, the VMware Tools process  VGAuthService.exe attempts to access the path  C:\Program%20Files\VMware\VMware%20Tools\VMware%20VGAuth\schemas\xmldsig-core-schema.xsd. How might this happen? If a path containing spaces is   HTML encoded, those spaces will be replaced with %20.</p><p>  正如我们在上面的屏幕截图中注意到，VMware Tools过程vgauthservice.exe尝试访问路径c：\ program％20files \ vmware \ vmware％20tools \ vmware％20vgauth \ schemas \ xmldsig-core-schema.xsd。这可能怎么发生？如果包含空格的路径是编码的HTML，那么这些空间将被替换为％20。</p><p> What are the consequences of this transformation? The most important aspect of this new path is that rather than being a subdirectory of  C:\Program Files\, which has proper ACLs by default, this requested path now starts looking at the root directory. Unprivileged users on Windows systems can create subdirectories off of the system root directory. This will be a recurring theme, so remember this.</p><p> 这种转变的后果是什么？这条新路径最重要的方面是，而不是作为C：\ Program Files \的子目录，默认情况下具有适当的ACL，而此请求的路径现在开始查看根目录。 Windows系统上的未经特权用户可以从系统根目录中创建子目录。这将是一个反复出现的主题，所以请记住这一点。</p><p>  We can dig a little deeper in Process Explorer by selecting the file access and pressing Ctrl-K to get the call stack:</p><p>  通过选择文件访问，然后按Ctrl-k来获取呼叫堆栈，我们可以在流程资源管理器中深入挖掘</p><p> Here we can see that the file access is triggered by  VGAuthService.exe + 0x110d9, and along the way there is a call to  xmlLoadExternalEntity().</p><p> 在这里，我们可以看到文件访问由vgauthservice.exe + 0x110d9触发，沿着呼叫xmlloadexternalentity（）。 </p><p> Putting all of the pieces together here, we have a privileged process that attempts to load a file that does not exist because the path is HTML encoded. Since an unprivileged user can create this path, this now turns into a case where an unprivileged user can influence a privileged process. In this particular case, the consequences are only an   XML External Entity (XXE) vulnerability. But we&#39;re also just getting warmed up.</p><p>将所有部分放在这里，我们有一个特权进程，试图加载不存在的文件，因为路径是HTML编码的。由于一个未经特权的用户可以创建此路径，因此它现在变成了一个非特权用户可以影响特权进程的情况。在这种特殊情况下，后果仅是XML外部实体（XXE）漏洞。但我们＆＃39; re也只是被加热了。</p><p>  If an application uses a POSIX-style path on a Windows machine, this path is normalized to a Windows style path. For example, if a Windows application attempts to access the   /usr/local/   directory, the path will be interpreted as   C:\usr\local\ . And as described above, this is a path that an unprivileged user can create on Windows.</p><p>  如果应用程序在Windows计算机上使用POSIX样式路径，则此路径将归一化为Windows样式路径。例如，如果Windows应用程序尝试访问/ usr / local /目录，则路径将被解释为c：\ usr \ local \。如上所述，这是一个路径，即未特权的用户可以在Windows上创建。</p><p> Here is a Process Monitor log of a system with a fully-patched security product installed:</p><p> 以下是安装完全修补的安全产品的系统的流程监视器日志：</p><p> Using a publicly-known technique for achieving    code execution via openssl.cnf, we can now demonstrate code execution via running   calc.exe  with SYSTEM privileges from a limited user account:</p><p> 使用公知的技术来实现通过openssl.cnf实现代码执行的技术，我们现在可以通过运行Calc.exe与有限用户帐户的系统权限一起演示代码执行：</p><p>  In some cases, a developer may have done nothing wrong other than using a library that happens to have load from a location that can be influenced by an unprivileged Windows user. For example, here&#39;s a Process Monitor log of an application that attempts to access the path   C:\CMU\bin\sasl2:</p><p>  在某些情况下，开发人员可能已经做错了，除了使用可能从可能受到未经特权的Windows用户影响的位置的库中遇到加载的库，更为错误。例如，这里＆＃39;＆＃39; s一个进程监视器日志，该应用程序尝试访问路径c：\ cmu \ bin \ sasl2：</p><p> If we look at the call stack, we can see that this access is likely triggered by the   libsasl.dll  library:</p><p> 如果我们查看调用堆栈，我们可以看到此访问可能是libsasl.dll库触发的：</p><p> And sure enough, if we look at the code for libsasl, we can see a   hard-coded reference to the path  C:\CMU\bin\sasl2.</p><p> 并确保如果我们查看libsasl的代码，我们可以看到对路径c：\ cmu \ bin \ sasl2的硬编码引用。 </p><p> As an unprivileged user, we can create the directory and place whatever code we want there. Once again, we have calc.exe executing with SYSTEM privileges. All from an unprivileged user account.</p><p>作为一个未经特权的用户，我们可以创建目录并将我们想要的任何代码放在那里。我们再一次，使用System权限执行Calc.exe。来自无特势率的用户帐户。</p><p>  Sometimes a program may contain references to paths that only exist on the developer&#39;s system. As long as the software functions properly on systems that do not have such a directory, then this attribute may not be recognized unless somebody is looking. For example, this software looks for a plugins subdirectory in the   C:\Qt\   directory:</p><p>  有时程序可能包含对开发人员和＃39; S系统上只存在的路径的引用。只要软件在没有这样一个目录的系统上正常运行，那么除非有人在寻找，否则可能无法识别此属性。例如，此软件在C：\ QT \目录中查找插件子目录：</p><p> I&#39;ll skip some steps for the sake of brevity, but after a bit of investigation we see that we can achieve code execution by placing a special library in the appropriate directory:</p><p> 我＆＃39; ll跳过一些步骤，以便简洁起见，但经过一点调查，我们看到我们可以通过在相应目录中放置特殊库来实现代码执行：</p><p> Looking further into the Qt development platform, this type of vulnerability is a known issue. The vulnerability was    patched  more than 5 years ago, but it never received a CVE. Software may be vulnerable to privilege escalation if it was built with a Qt version from before this patch was introduced or the developer did not use    windeployqt  to patch out the   qt_prfxpath  value stored in   Qt5core.dll.</p><p> 进一步进入Qt开发平台，这种类型的漏洞是一个已知的问题。该漏洞在5年前修补，但它从未收到过CVE。如果在介绍此修补程序之前使用Qt版本构建或未使用WindeployQt修补存储在Qt5core.dll中的Qt_prfxpath值，则软件可能很容易受到Qt版本的特权升级。</p><p>  Most cases of an unexpected path being accessed by an application can be exploited because of a simple fact: unprivileged users can create subdirectories off of the Windows system root directory. Finding and exploiting software that fails to properly set ACLs requires just a bit more investigation.</p><p>  由于简单的事实，可以利用应用程序访问的大多数情况下的意外路径：未经特权用户可以从Windows系统根目录中创建子目录。发现和利用无法正确设置ACL的软件需要更多调查。</p><p> Most of the ACL issues related to Windows software is related to one concept:  Software that executes from a subdirectory of  C:\Program Files\ or  C:\Program Files (x86)\ has secure ACLs  by default by virtue of inheritance. For example, consider the case where I install my software to  C:\Program Files\WD\. Unprivileged users will not be able to modify the contents of the WD subdirectory because its parent directory of  C:\Program Files\ cannot be written to by unprivileged processes, and the  WD subdirectory by default will inherit its parents permissions.</p><p> 与Windows软件相关的大多数ACL问题与一个概念有关：从C：\ Program Files \或C：\ Program Files（x86）的子目录中执行的软件默认情况下通过继承来保护ACL。例如，考虑我将软件安装到C：\ Program Files \ WD \的情况。未经特权的用户无法修改WD子目录的内容，因为C：\ Program Files \的父目录无法写入未经特权的进程，而WD子目录默认将继承其父父母权限。</p><p>  The   ProgramData directory by design can be written to without elevated permissions. As such, any subdirectory that has been created in the ProgramData directory will by default be writable by unprivileged users. Depending on  how an application uses its ProgramData subdirectory, a privilege escalation may be possible if the ACLs for the subdirectory are not explicitly set.</p><p>  可以将设计的ProgramData目录写入，而无需提高。因此，默认情况下，在ProgramData目录中创建的任何子目录都将被非特权用户可写入。根据应用程序如何使用其ProgramData子目录，如果未明确设置子目录的ACL，则可能是特权升级。 </p><p> Here we have a popular application that has a scheduled update component that runs from the C:\ProgramData\ directory:</p><p>在这里，我们有一个流行的应用程序，它具有从C：\ programdata \目录运行的计划更新组件：</p><p> This is a straightforward potential case of    DLL hijacking , which is made possible due to lax ACLs on the directory from which the software runs. Let&#39;s plant a crafted msi.dll there and see what we can accomplish:</p><p> 这是DLL劫持的直接潜在案例，这是由于软件运行的目录中的LAX ACL可能成为可能。让＆＃39; s植物在那里制作一个制作的msi.dll，看看我们可以完成什么：</p><p> There&#39;s our calc.exe, executing with SYSTEM privileges. These problems seem a bit too prevalent. And easy to exploit.</p><p> 我们的calc.exe有关系统权限。这些问题看起来有点普遍。而且很容易剥削。</p><p> It&#39;s worth noting that DLL hijacking isn&#39;t our only option for privilege escalation.  Any user-writable file that is used by a privileged process introduces the possibility of introducing a privilege escalation vulnerability. For example, here&#39;s a popular program that checks for a user-creatable text file to direct its privileged auto-update mechanism. As we can see here, the presence of a crafted text file can lead to arbitrary command execution. In our case, we have it launch calc.exe:</p><p> 它值得注意的是，DLL劫持ISN＆＃39; T我们唯一的特权升级选择。特权进程使用的任何用户可写文件介绍了引入权限升级漏洞的可能性。例如，这里＆＃39; s一种受欢迎的程序，检查用户可创建的文本文件，以指导其特权自动更新机制。正如我们在这里看到的那样，构造的文本文件的存在可能导致任意命令执行。在我们的情况下，我们有它启动Calc.exe：</p><p>  An installer that places an application by default to a directory off of the system root must set appropriate ACLs to remain secure. For example, Python 2.7 installs to   C:\python27\   by default:</p><p>  将应用程序默认为OFF系统root的目录置于默认情况下的安装程序必须设置适当的ACL以保持安全。例如，Python 2.7默认安装到C：\ Python27 \</p><p> The default ACLs for this directory allow unprivileged users to modify the contents of this directory. What might we be able to do with this? We can try the standard DLL hijacking technique:</p><p> 此目录的默认ACL允许未经特权的用户修改此目录的内容。我们可以用这个问题做些什么？我们可以尝试标准DLL劫持技术：</p><p> But we don&#39;t even need to be that clever. We can simply replace any file in the   C:\python27\  directory as an unprivileged user:</p><p> 但我们甚至不需要那个聪明。我们可以简单地将C：\ Python27 \目录中的任何文件替换为非特权用户： </p><p>  Many installers are secure because of inheritance of secure ACLs from C:\Program Files\. However any installer that allows a user to choose their own installation directory must explicitly set ACLs in the target location. Sadly, in my testing I&#39;ve found that it is very rare for an installer to explicitly set ACLs. Let&#39;s take a look at the Microsoft SQL Server 2019 installer, for example:</p><p>由于C：\ Program Files \的安全ACL的继承，许多安装人员是安全的。但是，任何允许用户选择自己的安装目录的安装程序都必须在目标位置明确设置ACL。遗憾的是，在我的测试中，我发现安装人员明确设置ACL是非常罕见的。让＆＃39;请查看Microsoft SQL Server 2019安装程序，例如：</p><p>   Microsoft SQL Server 2019, as well as just about any Windows application that allows you to choose where to install it, might be vulnerable to privilege escalation simply based on what directory it is installed to.</p><p>   Microsoft SQL Server 2019以及允许您选择安装它的位置的任何Windows应用程序，可能只需基于它安装到的目录即可易受权限升级。</p><p>    The simplest defense against many of the attacks outlined above is to remove the permission to create folders off of the system root directory:</p><p>    以上概述的许多攻击的最简单防御是删除从系统根目录中创建文件夹的权限：</p><p>  If software is installed to any location other than  C:\Program Files\  or  C:\Program Files (x86)\, you are relying on the installer to explicitly set ACLs for it to be secure. You can avoid needing to make this leap of faith by only installing software to recommended program locations.</p><p>  如果软件安装到C：\ Program Files \或C：\ Program Files（x86）之外的任何位置（x86）\，则依靠安装程序，显式设置ACL以确保安全。只需将软件安装到推荐的程序位置即可避免使用这种信仰的飞跃。</p><p>  You can test your own platforms for privilege escalation vulnerabilities using the Process Monitor filter and techniques described above. For any file locations that are determined to be insecure, you can manually lock down those directories so that unprivileged users cannot modify those locations. For any vulnerabilities that you discover, we recommend contacting the affected vendors to notify them of the vulnerabilities so that they can be fixed for everyone. In cases where the vendor communications are unproductive, the CERT/CC may be able to    provide assistance.</p><p>  您可以使用上述过程监视器过滤器和技术测试您自己的特权升级漏洞的平台。对于确定为不安全的任何文件位置，您可以手动锁定这些目录，以便未经特权的用户无法修改这些位置。对于您发现的任何漏洞，我们建议您与受影响的供应商联系以通知他们漏洞，以便它们可以为每个人修复。在供应商通信是不生产的情况下，证书/ CC可能能够提供援助。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vuls.cert.org/confluence/display/Wiki/Finding+Privilege+Escalation+Vulnerabilities+in+Windows+using+Process+Monitor">https://vuls.cert.org/confluence/display/Wiki/Finding+Privilege+Escalation+Vulnerabilities+in+Windows+using+Process+Monitor</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/process/">#process</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/privilege/">#privilege</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>