<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我编写了JavaScript以避免使用JavaScript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我编写了JavaScript以避免使用JavaScript</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-08 23:51:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/b6ede9d3ccb8b8afda35eebfbd118083.png"><img src="http://img2.diglog.com/img/2020/11/b6ede9d3ccb8b8afda35eebfbd118083.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Web technologies have come so far, that you realize: not everything needs to be done in JavaScript nowadays anymore.</p><p>Web技术已经取得了长足的进步，您会意识到：如今并不是所有的事情都需要用JavaScript来完成。</p><p>     But that&#39;s already a mouthful and also would have revealed too much and you might not have clicked my slightly clickbait-y title, right?</p><p>但这已经是一张大嘴巴了，而且还会透露太多信息，你可能就不会点击我那略显诱人的标题了，对吧？</p><p>    First of all I am not against JavaScript ( JS) at all. If you&#39;re building a web  application, then this is not only totally fine but most likely a core requirement.</p><p>首先，我根本不反对JavaScript(JS)。如果你正在构建一个Web应用程序，那么这不仅完全可以，而且很可能是一个核心需求。</p><p> But I do have my pet peeve with  JS for plain websites and blogs. Currently there is still such a strong draught in the static site generator world, telling us all our sites should be some kind of React or other frontend framework based project (looking at you, Gatsby, Next, Nuxt, VuePress, …). That you need to have that plentyful of code running in the browser of your visitors to have a smooth and  feels like a native app user experience. That a site should be a  Single Page Application (SPA). I can tell you, a plain HTML+CSS website does it really well, too. Surprise!</p><p>但我确实对JS的普通网站和博客感到恼火。目前在静态站点生成器领域仍然有如此强烈的风潮，告诉我们我们所有的站点都应该是某种类型的Reaction或其他基于前端框架的项目(看看你，盖茨比，NeXT，Nuxt，VuePress，…)。。你需要在访问者的浏览器中运行大量的代码，才能获得流畅的、感觉像原生应用程序用户体验的体验。网站应该是单页面应用程序(SPA)。我可以告诉你，一个普通的HTML+CSS网站也能很好地做到这一点。惊喜！</p><p> While on one hand the browser vendors add more and more  Web APIs, we also got a lot of improvement in the HTML and CSS area. Usually there is no big hype train around them, unless you are very enthusiastic and live in that niche.</p><p>一方面，浏览器供应商增加了越来越多的WebAPI，我们在HTML和CSS方面也得到了很大的改进。通常情况下，他们周围不会有大肆宣传的列车，除非你非常热情，并生活在那个利基市场。</p><p> Take a look at  caniuse.com to get an idea what is possible today and what might come tomorrow.  Did you know that HTML5 is still iterated on and we&#39;re moving towards  version 5.3? On the other hand »HTML 5« is also used as an umbrella term for a  wide variety of standards. Also for CSS the story got very interesting: while CSS until 2.1 was a single specification, since CSS 3 there is a whole potpourri of recommendations and drafts. The  wiki of the CSS Working Group might be a good starting point for further discovery.</p><p>看看caniuse.com，看看今天可能发生什么，明天可能会发生什么。你知道HTML5还在迭代，我们正在向5.3版本迈进吗？另一方面，“HTML5”也被用作各种标准的总称。另外，对于CSS来说，故事变得非常有趣：尽管CSS 2.1之前是一个单一的规范，但从CSS3开始就有了一大堆建议和草案。CSS工作组的wiki可能是进一步发现的一个很好的起点。</p><p>     The key ingredient is the CSS  position: sticky  🛈. Even though most of them are labeled as  partial support, this property value can be used in most scenarios except in some table related cases. If you want a sticky menu after scrolling and use only elements like  div everything is just fine. I could throw away all the code for that after I realized that none of the common and modern browsers had any blocking issues. So I did. The only real latecomers were the web view components, no big deal for me here.</p><p>关键因素是css的位置：粘性🛈。尽管它们中的大多数被标记为部分支持，但此属性值可以在大多数情况下使用，但在某些与表相关的情况下除外。如果你想在滚动后看到一个粘滞的菜单，并且只使用div这样的元素，那么一切都很好。当我意识到所有常见的和现代的浏览器都没有任何阻塞问题后，我可以扔掉所有的代码。所以我就这么做了。唯一真正的后来者是网页视图组件，这对我来说没什么大不了的。</p><p>   const  navbar  =  document .querySelector( &#39;.navbar&#39; ); let  sticky  =  navbar.offsetTop; const  navbarScroll  =  ()  =&gt;  {  if  ( window .pageYOffset  &gt;=  sticky) { navbar.classList.add( &#39;sticky&#39; ) }  else  { navbar.classList.remove( &#39;sticky&#39; ); }}; window .onscroll  =  navbarScroll;</p><p>Const navbar=Document.querySelector(&#39；.navbar&#39；)；let Sticky=navbar.offsetTop；const navbarScroll=()=&gt；{if(Window.pageYOffset&gt；=Sticky){navbar.classList.add(&#39；Sticky&39；))}Else{navbar.classList.Remove(&#39；Sticky&39；)；}；窗口。</p><p>       .navbar  {  position :  sticky ;  top :  0 ;  /* it does not reposition right away, but determines at which point it sticks */ }</p><p>.navbar{position：Sticky；top：0；/*它不会立即重新定位，但会确定它粘在哪个点上*/}。</p><p>   Also notice how little code is actually needed now? Two CSS properties and the job is done.</p><p>还注意到现在实际需要的代码有多少吗？两个CSS属性，工作就完成了。</p><p>   Also in 2018 I played with  Progressive Web Apps (PWA). The whole blog was one. A few days ago I teared down all of it. At the core of PWAs sit  Service Workers (SW), though you can use SW also without building an app. And that&#39;s what I was aiming for, but in the end my home-grown dynamic cache solution was more annoying to me than helpful for anyone else. Every time I updated anything here, I had to wait and/or force refresh to see the result. I&#39;m sure some people probably see visual inconsistencies due to a still running service worker in their browser. If you do, try to force clear all data for this website.</p><p>同样在2018年，我玩了进步网络应用(PWA)。整个博客都是一个。几天前，我把它都拆了。在PWAS的核心是SIT服务工作者(SW)，不过您也可以使用SW而无需构建应用程序。这就是我的目标，但最终，我自己开发的动态缓存解决方案对我来说更令人讨厌，而不是对其他任何人有帮助。每次我在这里更新任何东西时，我都必须等待和/或强制刷新才能看到结果。我相信有些人可能会因为浏览器中仍在运行的服务人员而看到视觉上的不一致。如果这样做，请尝试强制清除此网站的所有数据。</p><p> Long story short: if you do not build a web  app, you most likely do not need service workers. So yet another thing down from the  JS list.</p><p>长话短说：如果你不开发网络应用，你很可能不需要服务人员。因此，还有一件事是从JS名单上掉下来的。</p><p> No  before/after comparison here, but several precious kilobytes of JavaScript shaved off by removing them.</p><p>这里没有之前/之后的比较，但是通过删除它们，减少了宝贵的几千字节的JavaScript。</p><p>    If you have images and they are not very small in file size, you maybe want to provide a temporary placeholder with very low resolution and quality. This is pretty useful for slow internet connections; living here in Germany I know how difficult this situation can be. That thing called internet is still very Neuland to us. 🤦</p><p>如果您有文件大小不是很小的图像，则可能需要提供分辨率和质量非常低的临时占位符。这对于低速的互联网连接非常有用；我生活在德国，我知道这种情况有多困难。那个叫互联网的东西对我们来说仍然是纽兰(Neuland)式的东西。🤦。</p><p>  SVG are Scalable Vector Graphics, an image format I really love a lot, my logo is done with it ( I wrote about it a while ago).</p><p>SVG是可伸缩向量图形，这是一种我非常喜欢的图像格式，我的徽标已经用它做好了(我不久前写过这篇文章)。</p><p> LQIP finally stands for  »Low Quality Image Placeholders« and is based on an algorithm to find primitive shapes to describe the source image. Basically try to find only a few triangles, rectangles, circles, ellipsis, and other low poly shapes. It is also an art form in its own, you can enjoy some  nice examples there. The advantage of SVG is that it is made to encode such figures in very few characters of human readable text, so a less complex image for a placeholder can be written in one kilobyte or less.</p><p>LQIP最终代表»低质量图像占位符(Low Quality Image Placeders)，它基于一种算法来寻找基元形状来描述源图像。基本上只能找到几个三角形、矩形、圆形、椭圆形和其他低多边形。它本身也是一种艺术形式，你可以在那里欣赏到一些很好的例子。SVG的优点在于，它是用极少的人类可读文本字符对这些数字进行编码的，因此占位符的不太复杂的图像可以用1千字节或更少的字节来编写。</p><p> Compared to the original high resolution image which can easily weigh half a megabyte and more this is great. You can reserve the space in your page and very early in the loading process display some visual hint that there will be a proper picture soon. Especially for types which do not support progessive loading (as JPEG can) using SQIP/LQIP placeholders makes a lot of sense.</p><p>与原始的高分辨率图像相比，这是很棒的，因为高分辨率图像可以轻松地重达0.5兆字节甚至更多。您可以在页面中预留空间，并在加载过程的早期显示一些视觉提示，表明很快就会有合适的图片。特别是对于不支持渐进式加载的类型(如JPEG)，使用SQIP/LQIP占位符非常有意义。</p><p> In this scenario at first it was not really about saving frontend  JS, more about saving it on the backend site and replacing it with something else. Unfortunately in between some code creeped into the frontend anyway.</p><p>在这个场景中，一开始并不是真的要保存前端JS，而是更多地将其保存在后端站点上，并用其他东西替换它。不幸的是，在这中间，一些代码不管怎样悄悄地进入了前台。</p><p>    So one reason to use small low quality placeholders is because before such tags became a thing we solely relied on a single  &lt;img&gt; and some trickery with CSS (and sometimes aided by sprinkles of JavaScript). I tried to avoid  JS completely, but of course I had to use some styling hacks eventually.</p><p>因此，使用小的低质量占位符的一个原因是，在这类标签成为一种东西之前，我们完全依赖于单一的&lt；img&gt；和一些使用CSS的技巧(有时还辅之以少量的JavaScript)。我试图完全避免JS，但当然最终我不得不使用一些样式技巧。</p><p>  &lt; img  src = &#34;highres-and-heavy.png&#34;  style = &#34; background-size :  cover ;  background-image :  url ( &#39;data:image/svg+xml;base64,PHN2…&#39; ); &#34; &gt; &lt;!-- Usually in some post processing all style attributes were collected into a &lt;style&gt; tag or CSS file. --&gt;</p><p>&lt；img src=&#34；高大。png&#34；样式=&#34；背景-大小：封面；背景-图像：url(&#39；数据：图像/svg+xml；base 64，phn2…。&#39；)；&#34；&gt；&lt；！--通常在某些后处理中，所有样式属性都被收集到&lt；style&gt；标记或CSS文件中。--&gt；</p><p> The JavaScript entered this scenery at one point: after I used images with transparency. Sadly with this background image workaround you would&#39;ve seen the low quality placeholder through the transparent parts, and this was extremly ugly to be honest. I could not stand it and deployed some snippet to trigger a background removal once the actual image was loaded:</p><p>在我使用透明图像之后，JavaScript一度进入了这个场景。遗憾的是，用这个背景图像解决办法，你会看到低质量的占位符透过透明的部分，说实话，这是非常丑陋的。我无法忍受，在实际图片加载后，我部署了一些代码片段来触发背景移除：</p><p> // remove the background image styling, so transparent images won&#39;t have// strange SQIP artefacts shining through document .querySelectorAll(  &#34;img[loading=lazy][class]:not(.thumbnail):not(.loaded)&#34; ).forEach(( img )  =&gt;  {  img . onload  =  ( _event )  =&gt;  img.className  =  &#34;loaded&#34; ;}); document .querySelectorAll(  &#34;img[loading=lazy].thumbnail:not(.loaded)&#34; ).forEach(( img )  =&gt;  {  img . onload  =  ( _event )  =&gt;  img.className  =  &#34;thumbnail loaded&#34; ;});</p><p>//删除背景图像样式，以便透明图像不会//出现//奇怪的SQIP伪像通过文档.querySelectorAll(&#34；img[loading=lazy][class]：not(.thumbnail)：not(.loaded)&#34；).forEach((Img)=&gt；{img.。OnLoad=(_Event)=&gt；img.className=&#34；已加载&#34；；})；文档.querySelectorAll(&#34；img[loading=lazy].thumbnail:not(.loaded)&#34；).forEach((Img)=&gt；{img.。OnLoad=(_Event)=&gt；img.className=&#34；加载的缩略图&#34；；})；</p><p> Theoretically it would have been tolerable, but I noticed some strange behaviour once I started wrapping my images into  picture tags.</p><p>理论上这是可以忍受的，但当我开始将图片包装成图片标签时，我注意到了一些奇怪的行为。</p><p>   Come on, more acronyms? I&#39;m sorry, the web is a place with a lot of them.</p><p>得了吧，更多的缩略语？我很抱歉，网络上有很多这样的东西。</p><p> All you need to know for now is that both of them are pretty modern image formats with quite good (lossy) compression rates while keeping a respectable quality.   WEBP has been around for some time and most of the browsers do support it.   AVIF is extremly new and right now only Chrome since version 85 and Opera 71 can display them. Firefox has a configuration flag, maybe they will enable it by default pretty soon.</p><p>目前你需要知道的是，这两种图像格式都是相当现代的图像格式，在保持良好质量的同时具有相当好的(有损)压缩比。WebP出现已经有一段时间了，大多数浏览器都支持它。AVIF非常新，目前只有Chrome版本85和Opera 71可以显示它们。Firefox有一个配置标志，也许他们很快就会默认启用它。</p><p> So the current situation is that I have my original image (PNG or JPEG in most cases), a WEBP version, an AVIF version, and the SQIP placeholder. How do I deal with it? Back to our  &lt;picture&gt; tag:</p><p>因此，目前的情况是，我有我的原始图像(大多数情况下是PNG或JPEG)、WebP版本、AVIF版本和SQIP占位符。我该怎么处理呢？返回到我们的&lt；图片&&gt;标签：</p><p> &lt; picture &gt; &lt; source  srcset = &#34;./cover.avif&#34;  type = &#34;image/avif&#34; &gt; &lt; source  srcset = &#34;./cover.webp&#34;  type = &#34;image/webp&#34; &gt; &lt; img  src = &#34;./cover.png&#34;  style = &#34; /* SQIP data: see example above */ &#34; &gt;&lt;/ picture &gt;</p><p>&lt；图片&&gt;源资源=&#34；./over.avif&#34；type=&#34；Image/avif&#34；&gt；&lt；源资源=&#34；./cover.webp&#34；type=&#34；Image/WebP&#34；&gt；&lt；img src=&#34；./over.png&#34；style=&。&lt；/Picture&gt；</p><p> You can also use source sets for different view sizes based on media queries, but in my case I&#39;m mainly concerned about supporting different image formats. My idea is to prioritize the formats with the smallest file size first, and given the compression ratios the order is usually: AVIF, WEBP, PNG/JPG. Not in every case will this be true; WEBP does not always have better savings then a decently compressed JPEG for example. AVIF has not disappointed so far, but sadly a part of my visitors will not see the effect yet.</p><p>您也可以根据媒体查询使用不同视图大小的源集，但在我的例子中，我主要关心的是支持不同的图像格式。我的想法是首先对文件大小最小的格式进行优先排序，给出压缩比通常的顺序是：AVIF、WebP、PNG/JPG。并非在所有情况下都是如此；例如，WebP并不总是比经过适当压缩的JPEG节省得更多。到目前为止，AVIF还没有令人失望，但遗憾的是，我的部分访问者还没有看到效果。</p><p> What did not really happen anymore was a display of the placeholder before the final image was loaded. I experimented for quite some time until I realized that I do not want to spent more energy any further.</p><p>真正不再发生的是在加载最终图像之前显示占位符。我做了相当长一段时间的实验，直到我意识到我不想再花更多的精力。</p><p>  I made a  risk-return tradeoff compromise and got rid of SQIP altogether. For the growing number of AVIF support the images are sometimes significantly smaller which makes it acceptable to allow for some display delay anyway.</p><p>我在风险和回报之间进行了权衡，完全放弃了SQIP。对于越来越多的AVIF支持，图像有时要小得多，这使得允许一些显示延迟是可以接受的。</p><p> In the following screenshot the JPEG was the source photo. The PNG was created for some transparency stuff; of course, for photos this format does not really make a lot of sense in general. Sadly also WEBP fails to compete in this scenario. That&#39;s why I have to make this picture group generation a bit smarter soon to reorder based on the actual file sizes. Right now it is just based on a fixed format preference choice.</p><p>在下面的屏幕截图中，JPEG是源照片。PNG是为一些透明的东西而创建的；当然，对于照片来说，这种格式通常没有多大意义。遗憾的是，WebP在这种情况下也无法竞争。这就是为什么我必须让这个图片组生成更智能一点，以便根据实际文件大小进行重新排序。目前，它只是基于固定的格式首选项选择。</p><p> Well, AVIF is beating it definitely here. And yes, this 17.6 KB version is visually comparable to the original one. Sure, a closer look and you can spot differences, but for supportive symbolic pictures 100 % accuracy is not required. If you don&#39;t pay attention to it (or just don&#39;t know the source), it can compete with ease.</p><p>嗯，AVIF在这方面绝对打败了它。是的，这个17.6KB的版本在视觉上可以与原始版本相媲美。当然，仔细观察你可以发现不同之处，但对于支持性的符号图片来说，不需要100%的准确率。如果你不注意它(或者只是不知道它的来源)，它可以很容易地与之竞争。</p><p>  Just as an aside: during deployment another attempt of compression is done, the PNG gets shrunken down to 159 KB, the WEBP not at all.</p><p>顺便说一句：在部署过程中，进行了另一次压缩尝试，PNG压缩到159KB，而WebP则完全没有。</p><p> The only annoying part is still that the image dimensions are not reserved appropriately, even with present  width and  height attributes. So the layout can jump around if you scroll past the not yet loaded image. If you have an idea how to deal with that within  picture groups, I love to hear about it.</p><p>唯一令人恼火的部分仍然是图像尺寸没有被适当地保留，即使使用目前的宽度和高度属性也是如此。因此，如果您滚动到尚未加载的图像，布局可以跳转。如果你有办法在图片组中解决这个问题，我很乐意听听。</p><p>  More images in different formats, more backend processing (and for now mostly in  JS), no placeholder images, no frontend scripts.</p><p>更多不同格式的图片，更多的后端处理(目前主要是JS)，没有占位符图片，没有前端脚本。</p><p> You can find my current attempt for » &lt;img&gt; to  &lt;picture&gt;« transformation in the  GitHub repository for this site.</p><p>您可以在此站点的GitHub存储库中找到我当前尝试将»&lt；img&gt；转换为&lt；Picture&gt；。</p><p>   »Sometimes I will add something here and there. And just a bit later I think I should remove something again.« —  me</p><p>»有时我会在这里和那里添加一些东西。再过一会儿，我想我应该再去掉一些东西。</p><p> Basically I removed all scripts not essential for visiting, viewing, and reading. Visually pleasing hints like a subtle progress bar for the reading position were a nice toy, though not necessary at all.</p><p>基本上，我删除了访问、查看和阅读不必要的所有脚本。视觉上令人愉悦的提示，如阅读位置的细微进度条，是一个很好的玩具，尽管根本不是必要的。</p><p> In the beginning I mentioned, that there are exceptions to the JavaScript-free site. You&#39;ll find scripts for the pages  resolution and  theme.</p><p>我在一开始就提到，没有JavaScript的站点也有例外。你会找到页面分辨率和主题的脚本。</p><p> The first page is actually for myself when I need to check screen and window sizes while tweaking my theme. It needs to dynamically (re)calculate those values when resizing and scaling, so there is not really a way around  JS here. And as said, I don&#39;t mind it at all.</p><p>当我需要在调整主题的同时检查屏幕和窗口大小时，第一页实际上是为我自己准备的。在调整大小和缩放时，它需要动态(重新)计算这些值，所以这里没有真正绕过JS的方法。正如我所说的，我一点也不介意。</p><p> The second page could live without client side scripting if I&#39;m honest, but back then I was a bit too lazy to automate the data generation in a fully static fashion before or during deployment. Nowadays it serves as a reminder that you can get the computed style programmatically. Sometimes this can be very useful.</p><p>如果我诚实的话，第二个页面可以没有客户端脚本，但当时我有点懒得在部署之前或部署期间以完全静态的方式自动生成数据。现在，它提醒您可以通过编程获得计算样式。有时这可能非常有用。</p><p> By the way, this site is powered by 153 MB of  node_modules during build, pre &amp; post processing, and deployment times. I&#39;m not immensily happy about it, but currently that&#39;s okay. Though I will probably work on replacing that with something else in the future.</p><p>顺便说一句，在构建、前后处理和部署期间，该站点由153 MB的node_module提供支持。我对此并不十分满意，但目前这还可以。不过，我可能会在未来努力用其他东西来取代它。</p><p> 🙅🏻‍♀️🕵🏻‍♀️, 🙅🏻‍♀️🍪</p><p>🙅🏻‍♀️🕵🏻‍♀️，🙅🏻‍♀️🍪。</p><p> Another side fact: since I do not track my visitors, not even any third party scripts are lingering around anywhere. This also means you have to not only bring coffee or tea for your afternoon reading, but also your very own cookies, too. Because I don&#39;t  eat need them.</p><p>另一个侧面的事实是：由于我不跟踪我的访问者，甚至没有任何第三方脚本在任何地方徘徊。这也意味着你不仅要带咖啡或茶来下午阅读，还要带上你自己的饼干。因为我吃的时候不需要它们。</p><p>  I wish more people—specifically working or being interested in the web development field—would consider to reduce or avoid the JavaScript cruft in their projects. When you build a static site, also ask yourself, what &#34;static&#34; really means to you?  (I remember the slightly darker sides of the era of  DHTML, Java Applets, and Flash, brrrrr …)</p><p>我希望更多的人--特别是在Web开发领域工作或感兴趣的人--会考虑减少或避免在他们的项目中使用JavaScript。当你建立一个静态网站时，也要问问自己，静态对你来说意味着什么？(我还记得动态超文本标记语言、Java applet和Flash时代略显阴暗的一面，brrrrr…)。</p><p> Call me oldschool, but if you create a site with mostly text to read and images to view, why would you want to try to turn my device into a heater or stove? The simplicity of things also lies in what not do add and what to leave out.</p><p>可以说我很老派，但如果你创建了一个以文字和图片为主的网站，为什么你要试图把我的设备变成加热器或炉子呢？事物的简单还在于什么不做什么不做，什么不做什么省略。</p><p> I hope I gave you some ideas with the examples above. Discover the HTML and CSS specs and look for opportunities to replace parts with smaller and smarter solutions. If something is still rough around the edges, don&#39;t worry, most of the things are living standards and constantly evolve and improve over time (and you can help if you want to). Browser vendors usually implement some draft before the proposals and specifications are final. Everything is moving fast. Keep your eyes open!</p><p>我希望我通过上面的例子给了你一些想法。了解HTML和CSS规格，并寻找用更小、更智能的解决方案替换部件的机会。如果有些东西还很粗糙，不要担心，大多数东西都是生活水平，而且会随着时间的推移不断演变和改进(如果你愿意的话，你可以提供帮助)。浏览器供应商通常在提案和规范最终确定之前实施一些草案。一切都在快速发展。睁大你的眼睛！</p><p> »Enjoy the little things, for one day you may look back and realize they were the big things.« — Robert Brault</p><p>尽情享受小事吧，因为有一天你回首往事，可能会意识到它们才是大事。“--罗伯特·布劳特</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://markentier.tech/posts/2020/10/wrote-javascript-to-avoid-javascript/">https://markentier.tech/posts/2020/10/wrote-javascript-to-avoid-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033316.html"><img src="http://img2.diglog.com/img/2020/11/thumb_21f8be35cef4397449ea9dd55e0aa657.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033316.html">Python取代Java成为第二大最受欢迎的编程语言</a></div><span class="my_story_list_date">2020-11-5 20:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032758.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5284cf17db551895b1215de49c9ea500.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032758.html">Dojo3D-用于3D互动故事的简单JavaScript库</a></div><span class="my_story_list_date">2020-11-2 18:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032702.html"><img src="http://img2.diglog.com/img/2020/11/thumb_74f1ccfa4249fcc4f7e79edad2d58586.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032702.html">Go中常量的细微差别；Go不是JavaScript</a></div><span class="my_story_list_date">2020-11-2 9:22</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032572.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b2a7fcceee51585feb5628a787bccaa.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032572.html">打算停止在我的(JavaScript)代码中使用NULL</a></div><span class="my_story_list_date">2020-11-1 10:50</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>