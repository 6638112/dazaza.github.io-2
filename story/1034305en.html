<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>F#5</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">F#5</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 01:46:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/c048e76e97f37c2c2721591fa63f0f86.png"><img src="http://img2.diglog.com/img/2020/11/c048e76e97f37c2c2721591fa63f0f86.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Today, we’re excited to announce the general availability of F# 5. It ships with  .NET 5. We’ve been working on F# 5 for over the past year now, and we’re excited to share it with everyone.</p><p>今天，我们很兴奋地宣布F#5正式发布。它与.NET5一起发布。我们在过去的一年里一直致力于F#5，我们很高兴能与大家分享它。</p><p>   If you’re using Visual Studio on Windows, you’ll need to upgrade to the  latest 16.8 release.</p><p>如果您在Windows上使用Visual Studio，则需要升级到最新的16.8版本。</p><p>  From  F# 4.1 to F# 5, the chief focus for F# has been bringing up great support for .NET Core (now .NET 5). With F# 5, we’re considering this journey mostly complete. F# 5 marks the start of a new era of F# evolution centered around three main things:</p><p>从F#4.1到F#5，F#的主要关注点一直是对.NET Core(现在是.NET5)的巨大支持。有了F#5，我们认为这段旅程基本结束了。F#5标志着F#演变的新时代的开始，主要围绕三个方面：</p><p>  We started F# 5 with roughly these same goals, stating in the first preview that  “F# 5 is focused on better interactive and analytical programming”. This remains true, and we also added a few more orthogonal features that everyone can enjoy regardless of how they’re using F#.</p><p>我们带着大致相同的目标开始了F#5，在第一个预告片中说“F#5专注于更好的交互式和分析性编程”。这仍然是正确的，我们还添加了一些更多的正交特性，每个人都可以享受这些特性，而不管他们是如何使用F#的。</p><p>  F# 5 is the new default language version for the .NET SDK and Visual Studio. Any new or existing project compiled with either of those toolsets will use F# 5.</p><p>F#5是.NET SDK和Visual Studio的新默认语言版本。任何使用这两个工具集编译的新项目或现有项目都将使用F#5。</p><p>  Check out the  sample repository that shows off some of what you can do with F# 5. You can play with each of the features there instead of starting from scratch.</p><p>看看这个样本库，它展示了你可以用F#5做的一些事情。你可以尝试那里的每一个特性，而不是从头开始。</p><p>  F# 5 brings support for package references in F# scripts with  #r &#34;nuget:...&#34; syntax. Here’s how it looks for most packages:</p><p>F#5支持使用#r&#34；Nuget：...语法在F#脚本中引用包。以下是大多数套餐的外观：</p><p>   Package references also support packages with special requirements about referencing dependent  .dlls. For example, the  FParsec package used to require that users manually ensure that its dependent  FParsecCS.dll was referenced first before  FParsec.dll was referenced in F# Interactive. This is no longer needed, and you can simply just reference the package like this:</p><p>包引用还支持对引用依赖.dll有特殊要求的包。例如，FParsec包过去要求用户手动确保在F#Interactive中引用FParsec.dll之前首先引用其依赖的FParsecCS.dll。这不再需要，您只需如下所示引用该包即可：</p><p>  Package references are the basis for acquiring any package when using F# in Jupyter Notebooks or VSCode Notebooks.</p><p>在Jupyter笔记本或VSCode笔记本中使用F#时，包引用是获取任何包的基础。</p><p>  To coincide with package references, F# 5 is fully supported in  Jupyter Notebooks,  nteract, and VSCode Notebooks.</p><p>为了与包引用相一致，Jupyter笔记本、Interact和VSCode笔记本都完全支持F#5。</p><p>       VSCode Notebooks themselves are still in preview, but they already support quite a few features:</p><p>VSCode笔记本本身仍处于预览阶段，但它们已经支持相当多的功能：</p><p>    We’d love to have you try it out and give us feedback on what you feel needs to be there. To do so, follow the  installation instructions and don’t be shy when filing issues on GitHub!</p><p>我们希望您能试用一下，并就您觉得需要的内容给我们反馈。要做到这一点，请按照安装说明操作，在GitHub上提交问题时不要害羞！</p><p>  String Interpolation is one of the most highly-requested language features and the very first feature that we had an initial design for in the  F# Language Design repository. The design has undergone a lot of discussion over the years, but finally a breakthrough on how to best handle it was made by  Yatao Li, who also supplied an initial implementation.</p><p>字符串内插是最受欢迎的语言特性之一，也是我们在F#语言设计库中最初设计的第一个特性。多年来，这个设计经历了很多讨论，但最终李亚涛在如何最好地处理它方面取得了突破，他也提供了一个初步的实现方案。</p><p> F# interpolated strings are fairly similar to C# or JavaScript interpolated strings, in that they let you write code in “holes” inside of a string literal. Here’s a basic example:</p><p>F#内插字符串与C#或JavaScript内插字符串非常相似，因为它们允许您在字符串文字内的“洞”中编写代码。下面是一个基本的例子：</p><p>  However, F# interpolated strings also allow for typed interpolations, just like the  sprintf function, to enforce that an expression inside of an interpolated context conforms to a particular type. It uses the same format specifiers.</p><p>但是，F#内插字符串也允许类型内插，就像print intf函数一样，以强制内插上下文中的表达式符合特定类型。它使用相同的格式说明符。</p><p>  For more advanced usage, you can write multiple expressions inside of an interpolation (and technically almost an entire program). That said, it’s usually better to keep function definitions outside of interpolated strings as much as possible!</p><p>对于更高级的用法，您可以在一个插值(从技术上讲几乎是整个程序)中编写多个表达式。也就是说，通常最好将函数定义放在内插字符串之外！</p><p>  Another highly-requested feature of F# 5 is  nameof which resolves the symbol it’s being used for and produces its name in F# source. This is useful in various scenarios, such as logging, and protects your logging against changes in source code.</p><p>F#5的另一个被高度要求的特性是NameOf，它可以解析它所使用的符号，并在F#源代码中生成它的名字。这在各种情况下都很有用，例如日志记录，并保护您的日志记录不受源代码更改的影响。</p><p>  The last line will throw an exception and “month” will be shown in the error message.</p><p>最后一行将抛出异常，错误消息中将显示“月”。</p><p>   Three final additions are changes to how operators work: the addition of the  nameof&lt;&#39;type-parameter&gt; form for generic type parameters, and the ability to use  nameof as a pattern in a pattern match expression.</p><p>最后增加的三项是对运算符工作方式的更改：为泛型类型参数添加了nameof&lt；type-参数&gt；形式，以及能够在模式匹配表达式中将nameof用作模式。</p><p>    F# 5 also adds support for open type declarations. An open type declaration is like opening a static class in C#, except with some different syntax and some slightly different behavior to fit F# semantics.</p><p>F#5还增加了对开放类型声明的支持。开放类型声明类似于在C#中打开一个静态类，只不过它有一些不同的语法和一些稍微不同的行为来适应F#语义。</p><p> With Open Type Declarations, you can  open any type to expose static contents inside of it. Additionally, you can  open F#-defined unions and records to expose their contents. For example, this can be useful if you have a union defined in a module and want to access its cases, but don’t want to open the entire module.</p><p>使用Open Type声明，您可以打开任何类型以公开其中的静态内容。此外，您还可以打开F#定义的联合和记录以公开其内容。例如，如果您在一个模块中定义了一个联合，并且想要访问它的案例，但不想打开整个模块，那么这会很有用。</p><p>   Slicing data types is critical when doing analytical work on sets of data. To that end, we enhanced F# slicing in two areas for release, with one still considered preview.</p><p>在对数据集执行分析工作时，切片数据类型至关重要。为此，我们在两个方面增强了F#切片以供发布，其中一个仍被认为是预览版。</p><p>  Behavior for slicing the built-in FSharp.Core data types (array, list, string, 2D array, 3D array, 4D array) used to not be consistent prior to F# 5. Some edge-case behavior threw an exception and some wouldn’t. In F# 5, all built-in types now return empty slices for slices that are impossible to generate:</p><p>在F#5之前，对内置FSharp.Core数据类型(数组、列表、字符串、2D数组、3D数组、4D数组)进行切片的行为通常不一致。有些边缘情况行为会引发异常，有些则不会。在F#5中，对于无法生成的切片，所有内置类型现在都会返回空切片：</p><p>   The built-in 3D and 4D array types have always supported slices, but they did not support fixing a particular index (such as the  y-dimension in a 3D array). Now they do!</p><p>内置的3D和4D数组类型一直支持切片，但它们不支持固定特定的索引(例如3D数组中的y维)。现在他们做到了！</p><p>      What if you wanted to extract the slice  [| 4; 5 |] from the array? This is now very simple!</p><p>如果要从数组中提取切片[|4；5|]，该怎么办？现在这很简单了！</p><p>    Computation expressions (CEs) are used today to model “contextual computations”, or in more functional programming friendly terminology, monadic computations. However, they are a more flexible construct than just offering syntax for monads (you can encode monoids or even a computation expression that  explicitly violates every monad law if you like).</p><p>如今，计算表达式(CE)被用来建模“上下文计算”，或者用更多函数式编程友好的术语来说，就是一元计算。然而，与仅仅提供Monad语法相比，它们是一种更灵活的构造(如果愿意，您可以编码Monid，甚至可以编码显式违反每个Monad定律的计算表达式)。</p><p> F# 5 introduces applicative CEs, which are a slightly different form of CE than what you’re perhaps used to. Applicative CEs allow for significantly more efficient computations provided that every computation is independent, and their results are merely accumulated at the end. When computations are independent of one another, they are also trivially parallelizable. This benefit comes at a restriction, though: computations that depend on previously-computed values are not allowed.</p><p>F#5介绍了应用型CE，它是CE的一种形式，与您可能习惯的形式略有不同。如果每个计算都是独立的，并且它们的结果只是在结束时累积，则应用CE允许更高效的计算。当计算相互独立时，它们也可以微不足道地并行化。不过，这一好处有一个限制：不允许进行依赖于先前计算值的计算。</p><p>   Work for Applicative CEs was done in collaboration with  G-Research, who frequently contribute to the F# ecosystem. Thanks, folks!</p><p>应用CES的工作是与G-Research合作完成的，G-Research经常为F#生态系统做出贡献。谢谢大家！</p><p> If you’re a library author who exposes CEs in their library today, there are some additional considerations you’ll need to be aware of. These will be documented in the  Computation Expressions article by release.</p><p>如果您是一个现在在库中公开CE的库作者，那么您需要注意一些额外的考虑事项。这些将在逐个版本的计算表达式文章中进行记录。</p><p> For consumers of applicative CEs, things aren’t too different from the CEs that you already use. The previously-mentioned restriction around independent computations is the key concept to understand.</p><p>对于应用型CE的消费者来说，这与你已经在使用的CE并没有太大的不同。前面提到的关于独立计算的限制是要理解的关键概念。</p><p>  Thanks to a contribution by  Nino Floris, stack traces coming from caught exceptions in computation expressions (such as F# async) now retain more information. Consider the following code that uses the  Ply library:</p><p>多亏了Nino Floris的贡献，来自计算表达式(如F#Async)中捕获的异常的堆栈跟踪现在保留了更多信息。请考虑以下使用PLY库的代码：</p><p>  Prior to F# 5, the  origin function would not appear in stack traces without a workaround in the Ply library (and any other library where this is a scenario). Now it shows the full trace:</p><p>在F#5之前，如果不在PLY库(以及任何其他可能出现这种情况的库)中解决问题，源函数就不会出现在堆栈跟踪中。现在，它显示了完整的跟踪信息：</p><p>     You can now implement the same interface at different generic instantiations.  Lukas Rieger contributed an initial design and implementation of this feature.</p><p>现在，您可以在不同的泛型实例化上实现相同的接口。Lukas Rieger贡献了这一特性的初始设计和实现。</p><p>      You can consume it in F# through any of the standard means of implementing an interface:</p><p>您可以通过实现接口的任何标准方法在F#中使用它：</p><p>  This lets you safely take advantage of C# code and .NET components written in modern C# when they expect users to be able to consume a default implementation.</p><p>这使您可以在期望用户能够使用默认实现时，安全地利用用现代C#编写的C#代码和.NET组件。</p><p>  Nullable (value) types (called Nullable Types historically) have long been supported by F#, but interacting with them has traditionally been somewhat of a pain since you’d have to construct a  Nullable or  Nullable&lt;SomeType&gt; wrapper every time you wanted to pass a value. Now the compiler will implicitly convert a value type into a  Nullable&lt;ThatValueType&gt; if the target type matches. The following code is now possible:</p><p>可空(值)类型(历史上称为可空类型)长期以来一直受到F#的支持，但传统上与它们交互有点麻烦，因为每次您想要传递一个值时，都必须构造一个可为空或可为空的SomeType&&gt;包装器。现在，如果目标类型匹配，则编译器将隐式地将值类型转换为Nullable&lt；ThatValueType&gt；。现在可以执行以下代码：</p><p>   .NET 5 brings improvements to the performance of processing  .tail calls, which F# emits in various scenarios (especially in recursive and async code). The impact of this on the runtime performance of your app can vary depending on the  kind of code you’re writing, as not all  .tail calls are equal. However, you should generally expect an improvement to runtime performance compared to .NET Core 3.1.</p><p>.NET5改进了处理.ail调用的性能，F#在各种情况下(特别是在递归和异步代码中)会发出.ail调用。这对应用程序运行时性能的影响可能会因您编写的代码类型而异，因为并不是所有的.ail调用都是相等的。但是，与.NET Core3.1相比，您通常可以预期运行时性能会有所提高。</p><p>   F# compiler performance has steadily improved over the years. I’ll demostrate this by compiling the core project in the  FSharpPlus library. This core project makes use of a lot of F# constructs in a way that acts as a great stress test for the compiler itself. I ran the following commands against F# 5, F# 4.7, and F# 4.5.</p><p>多年来，F#编译器的性能一直在稳步提高。我将通过在FSharpPlus库中编译核心项目来演示这一点。这个核心项目使用了大量的F#构造，对编译器本身起到了很好的压力测试作用。我对F#5、F#4.7和F#4.5运行了以下命令。</p><p>  These commands clean the output directories and force msbuild to run serially (though it would likely be serial anyways since it’s compiling a single project), and reports timings for all tasks run during build. The following table shows the time it took for the  Fsc task to complete, which is the F# compiler:</p><p>这些命令清理输出目录并强制msbuild串行运行(尽管无论如何它都可能是串行的，因为它正在编译单个项目)，并报告在构建期间运行的所有任务的时间。下表显示了完成FSC任务(即F#编译器)所需的时间：</p><p>  There was a big improvement from F# 4.5 to F# 4.7, and another big jump with F# 5 as well!</p><p>从F#4.5到F#4.7有了很大的进步，F#5也有了又一次大的飞跃！</p><p> Your own results may vary a bit depending on a variety of factors, but if you try this out yourself you should see a fairly similar spread. It’s also worth noting that everything else in the .NET toolchain has improved too, so it’s not just the F# compiler getting faster when you use F# 5 with .NET 5.</p><p>你自己的结果可能会因各种因素而略有不同，但如果你自己试一试，你应该会看到相当相似的价差。同样值得注意的是，.NET工具链中的其他所有东西也都得到了改进，所以当你在.NET5中使用F#5时，不仅仅是F#编译器变得更快了。</p><p>  F# 5 is also bringing along two new preview features. To use these, you’ll need to set your  &lt;LangVersion&gt;preview&lt;/LangVersion&gt; like so:</p><p>F#5还带来了两个新的预览功能。要使用这些设置，您需要如下设置您的&lt；LangVersion&gt；preview&lt；/LangVersion&gt；：</p><p>   We decided to keep the ability to do reverse indexes in preview for F# 5. There are still some quirks to work out with respect to  System.Range and  System.Index interop that we want to get right before releaseing fully.</p><p>我们决定在F#5的预览版中保留反向索引的功能。在完全发布之前，仍然有一些关于System.Range和System.Index互操作的问题需要解决。</p><p> The syntax is  ^idx. Here’s how you can an element 1 value from the end of a list:</p><p>语法为^IDX。下面是如何从列表末尾开始计算元素1值的方法：</p><p>  You can also define reverse indexes for your own types. To do so, you’ll need to implement the following method:</p><p>您还可以为自己的类型定义反向索引。为此，您需要实现以下方法：</p><p>    We feel that these three enhancements will make slicing data types more convenient in F# moving forward. What do you think?</p><p>我们认为这三个增强将使F#中的数据类型切片更加方便。你认为如何？</p><p>  Computation expressions are a powerful feature for library and framework authors. They allow you to greatly improve the expressiveness of your components by letting you define well-known members and form a DSL for the domain you’re working in.</p><p>对于库和框架作者来说，计算表达式是一个强大的功能。它们允许您定义知名成员并为您所在的域形成DSL，从而极大地提高了组件的表现力。</p><p> Diego Esmerio and  Ryan Riley contributed a design an implementation to allow for overloading custom keywords in computation expressions. This new feature allows code like the following to be written:</p><p>迭戈·埃斯梅里奥(Diego Esmerio)和瑞安·莱利(Ryan Riley)贡献了一个设计和实现，允许在计算表达式中重载自定义关键字。这一新功能允许编写如下代码：</p><p>  Prior to this change, you could write the  InputBuilder type as it is, but you couldn’t use it the way it’s used in the previous example. Since overloads, optional parameters, and now  System.ParamArray types are allowed, everything just works as you’d expect it to.</p><p>在此更改之前，您可以按原样编写InputBuilder类型，但不能像上一个示例中那样使用它。由于允许重载、可选参数以及现在的System.ParamArray类型，因此一切都如您所期望的那样工作。</p><p>  Now that F# 5 is released, we’re moving our focus to a few areas:</p><p>现在F#5发布了，我们将重点放在以下几个方面：</p><p>  Today, the  F# development repository is quite a complex codebase. There are several test suites that were created at various points in history, one of which being particularly challenging to work with because it doesn’t load in any IDE tooling. We feel that it’s unfair to ask open source contributors to do things like add or update tests when this test suite is concerned, so we’re migrating it to be modern. The codebase also builds two versions of the F# compiler, called the “desktop compiler” and the “CoreCLR compiler”. From a technical standpoint, the “CoreCLR compiler” can be used to build any F# project targeting any .NET flavor on any OS. The only reason why we still build both is technical debt that we intend on paying off. From an open source contributor’s standpoint, this should simplify things as well.</p><p>今天，F#开发库是一个相当复杂的代码库。有几个测试套件是在历史上的不同阶段创建的，其中一个特别具有挑战性，因为它不会加载到任何IDE工具中。我们觉得要求开源贡献者在这个测试套件中添加或更新测试这样的事情是不公平的，所以我们正在将其迁移到现代版本。代码库还构建了两个版本的F#编译器，称为“桌面编译器”和“CoreCLR编译器”。从技术角度来看，“CoreCLR编译器”可以用来在任何操作系统上构建任何针对任何.NET风格的F#项目。我们仍在建设这两个项目的唯一原因是我们打算偿还的技术债务。从开源贡献者的角度来看，这也应该简化事情。</p><p> We also plan on making significant F# tooling improvements over time. We’ve already started this work. One of the first steps was to incorporate  FSharp.Compiler.Service into our build and packaging infrastructure so that any consumers of this package (e.g., the  Ionide plugin in VSCode) can simply add a NuGet feed and get nightly updates. Next, we’ll work towards retiring the  FSharp.Compiler.Private project, which is functionally equivalent to  FSharp.Compiler.Service, so that all F# tooling consumes the same functionality in the same way. From there, we intend on working with the F# community to eventually harden the  F# LSP implementation so that it powers all F# editor tooling (including Visual Studio). The long-term goal is that all F# tools have consistent behavior and feature availability, with individual editors adding their own “flavor” and unique feature set on top of that behavior so that F# programmers can pick the tool they like the most.</p><p>我们还计划随着时间的推移对F#工具进行重大改进。我们已经开始这项工作了。第一步是将FSharp.Compiler.Service整合到我们的构建和打包基础架构中，这样任何使用此包的用户(例如VSCode中的Ionide插件)都可以简单地添加NuGet提要并获得每晚的更新。接下来，我们将致力于淘汰FSharp.Compiler.Private项目，该项目在功能上等同于FSharp.Compiler.Service，以便所有F#工具以相同的方式使用相同的功能。从那时起，我们打算与F#社区合作，最终强化F#LSP实现，使其支持所有F#编辑器工具(包括Visual Studio)。长期目标是所有F#工具都具有一致的行为和功能可用性，各个编辑器在该行为之上添加自己的“风格”和独特的功能集，以便F#程序员可以选择他们最喜欢的工具。</p><p> Additionally, we’re continuing to invest in F# tooling for Visual Studio by improving performance and adding several features. One such feature is called “Inline Hints”, which you can activate by pressing and holding a key command. This lets you see the inferred types for all declarations and the names of F# parameters when applied (as if they were named parameters):</p><p>此外，我们还将继续投资于Visual Studio的F#工具，以提高性能并增加几个功能。其中一个功能被称为“内联提示”，你可以通过按住一个按键命令来激活它。这使您可以看到所有声明的推断类型以及应用时F#参数的名称(就像它们是命名参数一样)：</p><p>  The intention behind a feature like this is to let you effectively ask the compiler what it’s chosen to infer for your code at any time. We’re interested in incorporating other features that make things more productive for F# developers.</p><p>这样的功能背后的意图是让您能够有效地询问编译器，它在任何时候都可以为您的代码推断出什么。我们有兴趣加入其他功能，让F#开发人员的工作效率更高。</p><p> Finally, we’re planning the next version of the F# language. There are several things on the docket already:</p><p>最后，我们正在计划F#语言的下一个版本。议事日程上已经有几件事：</p><p>  The list for new F# language features is constantly evolving and new requirements come in and we adjust accordingly. However, we’re still committed to the direction that we set out on with F# 5. We want to continue to make F# a delightful language for interactive and analytical programming. You can expect to see more goodness in the near future.</p><p>新的F#语言特性列表在不断演变，新的需求不断涌现，我们也相应地进行了调整。然而，我们仍然致力于F#5开始的方向。我们希望继续让F#成为一种令人愉快的交互式和分析性编程语言。你可以期待在不久的将来看到更多的美好。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/dotnet/announcing-f-5/">https://devblogs.microsoft.com/dotnet/announcing-f-5/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034217.html"><img src="http://img2.diglog.com/img/2020/11/thumb_84e9ef6db136f3fbdf494272e186a3fb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034217.html">使用Scala 3进行显式项推理</a></div><span class="my_story_list_date">2020-11-10 15:24</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033662.html"><img src="http://img2.diglog.com/img/2020/11/thumb_76fee038427af967d4a62ff40c6ab0a4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033662.html">为什么输入Erlang很难：标准Erlang</a></div><span class="my_story_list_date">2020-11-7 14:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032409.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2269f52f0eb0ef16935e9b7ae5ee39df.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032409.html">我讨厌Python静态类型标注方案</a></div><span class="my_story_list_date">2020-10-31 7:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030569.html"><img src="http://img2.diglog.com/img/2020/10/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030569.html">镍：以更少的成本实现更好的配置</a></div><span class="my_story_list_date">2020-10-22 23:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>