<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可重复性机器学习在生产中的应用</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">可重复性机器学习在生产中的应用</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 21:42:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/0441fa362a492debfe7d36686087373e.png"><img src="http://img2.diglog.com/img/2020/11/0441fa362a492debfe7d36686087373e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The last two decades have yielded us some great understandings about Software Development. A big part of that is due to the emergence of DevOps and it’s wide adoption throughout the industry.</p><p>在过去的二十年里，我们对软件开发有了一些深刻的理解。这在很大程度上要归功于DevOps的出现和整个行业的广泛采用。</p><p> Leading software companies follow identical patterns: Fast iterations in software development followed by Continuous Integration, Continuous Delivery, Continuous Deployment. Every artefact is tested on its ability to provide value, always has a state of readiness and is deployed through automation.</p><p>领先的软件公司遵循相同的模式：软件开发中的快速迭代，然后是持续集成、持续交付、持续部署。每件工件都要通过测试其提供价值的能力，始终处于就绪状态，并通过自动化进行部署。</p><p> As a field, Machine Learning differs from traditional software development, but we can still borrow many learnings and adapt them to “our” industry. For the last few years, we’ve been doing Machine Learning projects in production, so beyond proof-of-concepts, and our goals where the same is in software development: reproducibility. So we built a pipeline orchestrator, strong automations and established a workflow to achieve exactly that.</p><p>作为一个领域，机器学习不同于传统的软件开发，但我们仍然可以借鉴许多知识，使其适应我们的行业。在过去的几年里，我们一直在做生产中的机器学习项目，所以超越了概念验证，以及我们在软件开发中同样的目标：可重复性。所以我们建立了一个管道协调器，强大的自动化，并建立了一个工作流程来实现这一点。</p><p> Why not just Jupyter Notebooks? Well, how long does it take to construct a Notebook from scratch, with all processing steps, from scratch? And how easy is it to onboard new members to the team? Can you reproduce the results you’ve had two months ago, now, fast? Can you compare today’s results against historic one’s? Can you give provenance over your data throughout training? And what happens if your model goes stale?</p><p>为什么不只是Jupyter笔记本呢？那么，从头开始构建一个笔记本需要多长时间，所有的处理步骤都是从头开始的呢？让新成员加入团队有多容易？你能快速复制两个月前的结果吗？你能把今天的结果和历史上的结果进行比较吗？你能在整个培训过程中给出你的数据的出处吗？如果你的模型变旧了怎么办？</p><p> We’ve faced all of these issues, and more, and now took our experience to deduce 12 factors (as a nod to the  12 factor app) that build the backbone of successful ML in production.</p><p>我们已经面对了所有这些问题，甚至更多，现在我们利用我们的经验推导出了12个因素(作为对12个因素应用程序的认可)，这些因素构成了生产中成功的ML的支柱。</p><p>  While obvious to basically all Software Engineers, version control is not an universally accepted methodology among Data Scientists. Let me quote the folks at Gitlab as a quick primer:</p><p>虽然版本控制对于基本上所有的软件工程师来说都是显而易见的，但它并不是数据科学家普遍接受的方法。让我引用GitLab的同事们的话作为一个快速入门：</p><p> Version control facilitates coordination, sharing, and collaboration across the entire software development team. Version control software enables teams to work in distributed and asynchronous environments, manage changes and versions of code and artifacts, and resolve merge conflicts and related anomalies.</p><p>版本控制促进了整个软件开发团队之间的协调、共享和协作。版本控制软件使团队能够在分布式和异步环境中工作，管理代码和工件的更改和版本，并解决合并冲突和相关异常。</p><p>  As a special form of Software Development, Machine Learning has unique requirements. First, it has not one but two moving parts: Code and Data. Second, model trainings happen in (fast) iterations and introduce a high variance of code (e.g. splitting, preprocessing, models).</p><p>作为软件开发的一种特殊形式，机器学习有其独特的要求。首先，它不是一个而是两个活动部分：代码和数据。其次，模型训练发生在(快速)迭代中，并引入了高方差的代码(例如，拆分、预处理、模型)。</p><p> As soon as data can be subject to change it needs to be versioned to be able to reproducibly and repeatably conduct experiments and train models. Cruder forms of versioning (read: hard-copies) can go a long way, but especially in team scenarios shared, immutable version control becomes critical.</p><p>一旦数据可以更改，就需要对其进行版本化，以便能够重复地进行实验和训练模型。粗略的版本控制形式(阅读：硬拷贝)可以大有用武之地，但特别是在共享的团队场景中，不变的版本控制变得至关重要。</p><p> Version control of code is even more key. In addition to above’s quote, preprocessing code is not just relevant at training but also at serving time and needs to be immutably correlatable with models. Serverless functions can provide an easy-access way to achieve a middle ground between the workflow of Data Scientists and production-ready requirements.</p><p>代码的版本控制更为关键。除了上面的引用，预处理代码不仅与培训相关，而且与服务时间相关，并且需要与模型保持一致的相关性。无服务器功能可以提供一种易于访问的方式，在数据科学家的工作流和生产就绪需求之间实现折衷。</p><p>   In a perfect world, whatever produces your input data will forever produce exactly the same data, at least structurally. But the world is not perfect, you’re consuming data from an upstream service that’s built by humans and might be subject to change. Features will change, eventually. At best, your models fail outright, but at worst they’ll just silently start to produce garbage results.</p><p>在一个完美的世界中，任何产生您的输入数据的东西都将永远产生完全相同的数据，至少在结构上是这样。但这个世界并不完美，你正在使用的数据来自上游服务，该服务是由人类构建的，可能会发生变化。最终，功能将会改变。在最好的情况下，您的模型完全失败，但在最坏的情况下，它们只会默默地开始产生垃圾结果。</p><p> Explicitly defined feature dependencies allow for transparent failure as early as possible. Well-designed systems will accommodate feature dependencies both in continuous training as well as at serving time.</p><p>明确定义的功能依赖项允许尽可能早地出现透明故障。设计良好的系统将在持续训练和服役期间适应功能依赖。</p><p>   Good software is descriptive - it can be read and understood easily without reading every line of code.</p><p>好的软件是描述性的-它可以很容易地阅读和理解，而不需要阅读每一行代码。</p><p> And while Machine Learning is a unique flavor of Software Development it doesn’t exempt practitioners from following established coding guidelines. Basic understanding of coding standard essentials can be picked up with very little effort and in a short amount of time.</p><p>虽然机器学习是软件开发的一种独特风格，但它并不能免除从业者遵循已建立的编码指导原则的责任。对编码标准要领的基本理解可以用很少的努力和很短的时间来掌握。</p><p> Code for both preprocessing and models should follow  PEP8. It should consist of meaningful object names and contain helpful comments. Following PEP8 will improve code legibility, reduce complexity and speed up debugging. Programming paradigms such as  SOLID provide thought frameworks to make code more maintainable, understandable and flexible for future use cases.</p><p>预处理和模型的代码都应该遵循PEP8。它应该由有意义的对象名称组成，并包含有用的注释。遵循PEP8将提高代码的易读性，降低复杂性，并加快调试速度。诸如SOLID之类的编程范例提供了思想框架，使代码对于未来的用例更易维护、更易于理解和更灵活。</p><p> Configuration should be separated from code. Don’t hardcode your split ratios, provide them at runtime through configuration. As known from hyperparameter tuning, a well-separated configuration increases speed of iterations significantly and makes codebases reusable.</p><p>配置应该与代码分开。不要硬编码您的拆分比率，在运行时通过配置提供它们。从超参数调优可知，良好分离的配置可以显著提高迭代速度，并使代码库可重用。</p><p>   If you can’t reproduce training results you can’t trust the results. While this is somewhat the overarching theme of this blogpost, there are nuances to reproducibility. Not just do you need to be able to reproduce a training yourself, the entire team should be able to do so. Obscuring trainings in Jupyter Notebooks on someones PC or on some VM on AWS is the literal inverse of a reproducible training.</p><p>如果你不能重现训练结果，你就不能相信结果。虽然这在某种程度上是这篇博文的主要主题，但重现性也有一些细微的差别。你不仅需要能够自己重现训练，整个团队也应该能够做到这一点。在某人PC上的Jupyter笔记本或AWS上的某些VM上模糊培训是可重现培训的字面上的反面。</p><p> By using pipelines to train models entire teams gain both access and transparency over conducted experiments and training runs. Bundled with a reusable codebase and a separation from configuration, everyone can successfully relaunch any training at any point in time.</p><p>通过使用管道来训练模型，整个团队在进行的实验和培训运行中既获得了访问权限，又获得了透明度。捆绑了可重用代码库和独立于配置的功能，每个人都可以在任何时间点成功重新启动任何培训。</p><p>    Unit testing is testing on an atomic level - every function is tested individually on it’s own specific criteria.</p><p>单元测试是在原子级别上进行测试-每个函数都根据其自己的特定标准进行单独测试。</p><p>  Integration testing is taking an inverse approach - all elements of a codebase are tested as a group, in conjunction and with clones/mocks of up- and downstream services.</p><p>集成测试采用的是相反的方法-代码库的所有元素作为一个组进行测试，并与上行和下行服务的克隆/模拟一起进行测试。</p><p> Both paradigms are good starting points for Machine Learning. Preprocessing code is predestined for unit testing - do transforms yield the right results given various inputs? Models are a great use case for integration tests - does your model produce comparable results to evaluation at serving time in a production environment?</p><p>这两个范例都是机器学习的良好起点。预处理代码注定要用于单元测试-在给定各种输入的情况下，转换是否会产生正确的结果？模型是集成测试的一个很好的用例-您的模型在生产环境中的服务时间产生与评估相当的结果吗？</p><p>   Drift is a legit problem for production scenarios. You need to account for drift as soon as there is even a slight possibility that data might change (e.g. user input, upstream service volatility). Two measures can mitigate risk exposure:</p><p>对于生产场景来说，漂移是一个合法的问题。只要数据有轻微变化的可能性(例如，用户输入、上游服务波动性)，您就需要考虑漂移。有两种措施可以降低风险敞口：</p><p> Data monitoring for production systems. Establish automated reporting mechanisms to alert teams of changing data, even beyond explicitly defined feature dependencies.</p><p>生产系统的数据监控。建立自动报告机制，以便向团队发出更改数据的警报，甚至超出明确定义的功能依赖项。</p><p>  Continuous training on newly incoming data. Well-automated pipelines can be rerun on newly recorded data and offer comparability to historic training results to show performance degradation as well as offer a quick way to promote newly trained models into production, given better model performance.</p><p>对新输入的数据进行持续培训。自动化程度高的管道可以根据新记录的数据重新运行，并提供与历史培训结果的可比性，以显示性能下降，并提供一种快速方法，在提供更好的模型性能的情况下，将新培训的模型提升到生产中。</p><p>   Excel is not a good way to track experiment results. And not just Excel, any decentralized, manual form of tracking will yield non-authoritative and therefore untrustworthy information.</p><p>Excel不是跟踪实验结果的好方法。而且不仅仅是Excel，任何分散的、手动的跟踪形式都会产生非权威性的、因此不可信的信息。</p><p> The right approach are automated methods to record training results in a centralized data store. Automation ensures the reliable tracking of every training run, and allows for a later comparability of training runs against each other. Centralized storage of results give transparency across teams and allows for continuous analysis.</p><p>正确的方法是在集中的数据存储中记录培训结果的自动化方法。自动化确保了对每次训练运行的可靠跟踪，并允许稍后对彼此的训练运行进行可比性。结果的集中存储提供了团队间的透明度，并允许持续分析。</p><p>   Understanding datasets requires effort. Commonly, this understanding is gathered through experimentation, especially when operating in fields with a lot of hidden domain knowledge. Start a Jupyter Notebook, get some/all of the data into a Pandas Dataframe, do some hours of out-of-sequence magic, train a first model, evaluate results - Job done. Well, unfortunately not.</p><p>理解数据集需要付出努力。通常，这种理解是通过实验收集的，特别是在具有大量隐藏领域知识的领域中操作时。开始使用Jupyter笔记本，将部分/全部数据放入Pandas Dataframe，进行几个小时的无序魔术，训练第一个模型，评估结果-工作完成。嗯，不幸的是没有。</p><p> Experiments serve a purpose in the lifecycle of Machine Learning. The results of these Experiments are however not models, but understanding. Models from explorative Jupyter Notebooks are proof for understanding, not production-ready artefacts. Gained understanding will need more molding and fitting into production-ready training pipelines.</p><p>在机器学习的生命周期中，实验起到了一定的作用。然而，这些实验的结果不是模型，而是理解。探索性的Jupyter笔记本的模型是理解的证据，而不是准备生产的人工制品。获得理解将需要更多的成型和安装到准备生产的培训管道中。</p><p> All understandings unrelated to domain-specific knowledge can however be automated. Generate statistics on each data version you’re using to skip any one-time, ad-hoc exploratory work you might have had to do in Jupyter Notebooks, and move straight to the first pipelines. The earlier you experiment in pipelines, the earlier you can collaborate on intermediate results and the earlier you’ll receive production-ready models.</p><p>然而，所有与特定领域知识无关的理解都可以自动化。生成您正在使用的每个数据版本的统计数据，以跳过您可能必须在Jupyter笔记本中进行的任何一次性、特别的探索工作，并直接转到第一条管道。越早在管道中进行试验，就越早能够就中间结果进行协作，也就越早收到可投入生产的模型。</p><p>   The avoidance of skewed training and serving environments is often reduced to correctly embedding all data preprocessing into the model serving environments. This is absolutely correct, and you need to adhere to this rule. However, it is also a too narrow interpretation of Training-Serving-Skew.</p><p>避免偏斜的训练和服务环境通常被简化为正确地将所有数据预处理嵌入到模型服务环境中。这是绝对正确的，你需要遵守这条规则。然而，这也是对训练-服务-倾斜的过于狭隘的解释。</p><p> A little detour to ancient DevOps history: In 2006 the CTO of Amazon, Werner Vogels, coined the term “You build it, you run it”. It’s a descriptive phrase for extending the responsibility of Developers to not only writing but also running the software they build.</p><p>稍微绕道回顾一下古老的DevOps历史：2006年，亚马逊的首席技术官沃纳·沃格斯(Werner Vogels)创造了“你建造它，你运行它”这个术语。这是一个描述性的短语，意思是将开发人员的责任扩展到不仅编写而且运行他们构建的软件。</p><p> A similar dynamic is required for Machine Learning projects - an understanding of both the upstream generation of data and the downstream usage of generated Models is within the responsibility of Data Scientists. What system generates your data for training? Can it break, what’s the system SLO (service level objective), is it the same as for serving? How is your model served? What’s the runtime environment, and how are your preprocessing functions applied during serving? These are questions that Data Scientists need to understand and find answers to.</p><p>机器学习项目也需要类似的动态--理解数据的上游生成和生成的模型的下游使用都是数据科学家的责任。哪个系统会为您的培训生成数据？它能打破吗，系统的SLO(服务级别目标)是什么，它与服务是一样的吗？你们的模特是怎么服务的？什么是运行时环境，您的预处理功能在服务期间是如何应用的？这些都是数据科学家需要理解并找到答案的问题。</p><p> TL;DR: Correctly embed preprocessing to serving, and make sure you understand up- and downstream of your data.</p><p>TL；DR：正确地将预处理嵌入到服务中，并确保您理解数据的上下游。</p><p>  From the point in time that introduces a second training script to a project comparability becomes a fundamental part of any future work. If the results of the second model can not, at all, be compared to the first model, waste was generated and at least one of the two models is superfluous, if not both.</p><p>从向项目引入第二个培训脚本的时间点开始，可比性成为任何未来工作的基本部分。如果第二个模型的结果根本不能与第一个模型进行比较，就会产生浪费，并且两个模型中至少有一个是多余的，如果不是两个都是多余的话。</p><p> By definition, all model trainings that are trying to solve the same problem need to be comparable, otherwise they are not solving the same problem. And while iterations will change the definition of what to compare models on over time, the technical possibility to compare model trainings needs to be built into training architecture as a first-class citizen early on.</p><p>根据定义，所有试图解决同一问题的模型培训都需要具有可比性，否则它们就不是在解决同一问题。虽然随着时间的推移，迭代会改变对模型进行比较的定义，但是需要在早期将比较模型培训的技术可能性作为一等公民构建到培训架构中。</p><p>   As a very rough description, Machine Learning models are supposed to solve a problem by learning from data. To solve this problem, compute resources are allocated. First to training the model, later to serving the model. The abstract entity (e.g. the person or the department) responsible for spending the resources during training carries the responsibility forward to serving. Plenty of negative degradations can occur in the lifecycle of a model: Data can drift, models can become bottlenecks for overall performance and bias is a real issue.</p><p>作为一个非常粗略的描述，机器学习模型被认为是通过从数据中学习来解决问题的。为了解决这个问题，需要分配计算资源。首先是培训模型，然后是为模型服务。负责在培训期间花费资源的抽象实体(例如，个人或部门)将责任向前推进到服务。在模型的生命周期中可能会出现大量的负面降级：数据可能会漂移，模型可能会成为整体性能的瓶颈，而偏差是一个真正的问题。</p><p> The effect: Data Scientists and teams are responsible for monitoring the models they produce. Not necessarily in the implementation of that monitoring, if bigger organizations are at play, but for sure for the understanding and interpretation of monitoring data. At its minimum, a model needs to be monitored for input data, inference times, resource usage (read: CPU, RAM) and output data.</p><p>效果：数据科学家和团队负责监控他们制作的模型。如果有较大的组织在发挥作用，则不一定在实施监测方面，但肯定是为了理解和解释监测数据。至少，需要监视模型的输入数据、推理时间、资源使用情况(读取：CPU、RAM)和输出数据。</p><p> TL;DR: Again: you build it, you run it. Monitoring models in production is a part of data science in production.</p><p>戴利：再说一遍：你建造它，你运行它。生产监控模型是生产数据科学的一部分。</p><p>  On a technical level every model training pipeline needs to produce an artefact deployable to production. The model results might be horrible, no questions asked, but it needs to end up wrapped up into an artefact you can directly move towards a production environment.</p><p>在技术层面上，每个模型培训流水线都需要生产出可部署到生产中的人工制品。模型的结果可能是可怕的，没有任何问题，但它需要最终包装成一个可以直接转移到生产环境中的人工制品。</p><p> This is a common theme in Software Development - it’s called Continuous Delivery. Teams should be able to deploy their software at any given moment, and iteration cycles need to be quick enough to accommodate that goal.</p><p>这是软件开发中的一个共同主题--称为持续交付。团队应该能够在任何给定的时刻部署他们的软件，迭代周期需要足够快来适应这一目标。</p><p> A similar approach needs to be taken with Machine Learning. It’ll enforce first and foremost a conversation about reality and the expectations towards models. All stakeholders need to be aware of what’s even theoretically possible regarding model results. All stakeholders need to agree on a way to deploy a model, and where it fits into the bigger software architecture around it. It will however also lead to strong automations, and by necessity the adoption of a majority of the factors outlined in the prior paragraphs.</p><p>机器学习需要采取类似的方法。它将首先加强关于现实和对模型的期望的对话。所有利益相关者都需要意识到模型结果在理论上是可能的。所有利益相关者都需要就部署模型的方式达成一致，以及它在哪里适合于围绕它的更大的软件体系结构。然而，它也将导致强大的自动化，并必然采用前面段落中概述的大多数因素。</p><p> TL;DR: Every training pipeline needs to produce a deployable artefact, not “just” a model.</p><p>每个培训渠道都需要生产一个可部署的人工制品，而不是“仅仅”一个模型。</p><p>  This is by no means an exhaustive list. It’s the combination of our experience, and you’re welcome to use it as a boilerplate to benchmark your production architecture, or as a blueprint to design your own.</p><p>这绝不是一份详尽的清单。它结合了我们的经验，欢迎您将其作为基准测试您的生产体系结构的样板，或者作为设计您自己的蓝图。</p><p> We used these factors as the guiding principles for the Core Engine, our ML orchestrator. So before you start from scratch: Sign up and give us a run for your money!</p><p>我们使用这些因素作为我们的ML协调器Core Engine的指导原则。所以，在你从头开始之前：报名吧，让我们为你的钱而奔跑吧！</p><p> To read more about the Core Engine head over to our  website or  docs for more details. If you want to start using the Core Engine for your own ML production environment,  contact us!</p><p>要了解更多有关酷睿引擎的信息，请访问我们的网站或文档以获取更多详细信息。如果您想开始在您自己的ML生产环境中使用Core Engine，请联系我们！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.maiot.io/12-factors-of-ml-in-production/">https://blog.maiot.io/12-factors-of-ml-in-production/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/机器/">#机器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/machine/">#machine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032374.html"><img src="http://img2.diglog.com/img/2020/10/thumb_a5116efe1cd15abc5c469f76b03f4013.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032374.html">回送机器页面的事实检查和上下文</a></div><span class="my_story_list_date">2020-10-31 4:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030879.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c540917af1691081258e0184117f572b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030879.html">BOT每30分钟订购18752美元的McSundaes。要查看机器是否在工作，请执行以下操作</a></div><span class="my_story_list_date">2020-10-24 7:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030248.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f6d6b2e8cf2019d1c7173cedabf8162a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030248.html">Qcdoc：芯片上的量子色动力学</a></div><span class="my_story_list_date">2020-10-21 12:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029083.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b8e4e6e17d5850ee55dcdc73a708b9b4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029083.html">
新的基于牛津机器学习的新冠肺炎测试可以在5分钟内给出结果</a></div><span class="my_story_list_date">2020-10-16 2:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>