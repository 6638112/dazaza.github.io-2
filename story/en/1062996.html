<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>验证矢量化防锈重新审视 Verifying Vectorized Rust Revisited</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Verifying Vectorized Rust Revisited<br/>验证矢量化防锈重新审视 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-16 17:46:41</div><div class="page_narrow text-break page_content"><p>Research is characterized by allowing yourself to make mistakes: performingexperiments; drawing conclusions; later, realizing that yourexperiment was not sufficient and you got it wrong; andtrying again.Back in March, we thought that we knew  how to deal with vectorized Rust: tell the compiler not to auto-vectorize code; tell the compilernot to use vector instructions; and use existing conditional compilationfeature flags to disable hand-vectorized code.Unfortunately, two of those three ideas don’t work – but we think we have aviable approach now.</p><p>研究的特点是允许自己犯错误：表演实验;得出结论;后来，意识到你的体验不够，你弄错了;再次和练习。我们认为我们知道如何应对矢量化生锈：告诉编译器不自动矢量化代码;告诉CompiLernot使用矢量说明;并使用现有的条件编译方法标志来禁用手矢量化代码.不幸的是，这三个想法中的两个不起作用 - 但我们认为我们现在有可用的方法。</p><p> The first of these ideas probably works: you can tell the compiler not toauto-vectorize code. If you are using cargo, you can control this with RUSTFLAGS; if you are using rustc directly, you can directly disableauto-vectorization when invoking rustc. And, if your program calls C code (oruses a crate that calls C code) and uses the  CC-rs crate to compile the code,then you can easily pass flags to the C compiler to disable auto-vectorization.(If your program calls C code that was not compiled using the CC-rs crate, youwill need to modify the C code’s build system – which is a bit more work.)</p><p> 这些想法中的第一个可能有效：您可以告诉编译器不是传达的代码。如果您使用的是货物，您可以使用RustFlags控制它;如果您使用RustC直接使用，可以在调用Rustc时直接拒绝武容式化。而且，如果您的程序调用C代码（orus调用C代码的箱子）并使用CC-RS Crate编译代码，那么您可以轻松地将标志传递给C编译器以禁用自动矢量化。（如果您的程序调用C代码未使用CC-RS Crate编译，YouWill需要修改C代码的构建系统 - 这有点工作。）</p><p> The reason that telling the compiler not to use vector instructions does notwork is that it is not possible to turn off the x86 architecture’s SSE2instructions without breaking floating point. We recently realized that the -Ctarget-feature=-sse2 flag turns of both SSE2 vector instructions andalso support for IEEE floating point.With IEEE floating point disabled, LLVM attempts to use the old 80-bit x87 floating point unit and thenfails an assertion while compiling your code.In short, you cannot use the  -sse2 flag with Rust.It took us a while to recognize that we could not just disable SSE2 because,the technique we were using to disable SSE2 in the standard library turnedout to do nothing. We thought that we could do this using the environment variable  RUSTFLAGS_STAGE_NOT_0to disable SSE2 (and other x86 vector extensions) when compiling thestandard library.Alas, this environment variable has been renamed so our attempt to disable SSE2was being ignored.</p><p> 告诉编译器不使用载体指令的原因不应禁忌，是不可能关闭x86架构的sse2instructions而不会破坏浮点。我们最近意识到--ctarget-feature = -sse2标志转向SSE2矢量指令和对IEEE浮点的支持。与IEEE浮点禁用，LLVM尝试使用旧的80位X87浮点单元，然后在此时进行断言简而言之，你不能使用-sse2标志与rust.这需要一段时间才能识别我们不能只禁用SSE2，因为我们使用的技术在标准库中禁用SSE2才能做任何事情。我们认为我们可以使用环境变量rustflags_sse_not_0来禁用sse2（和其他x86向量扩展）在编译theStandard库时.alas，此环境变量已重命名，因此我们尝试禁用SSE2Was被忽略。</p><p> Finally, the reason that using existing conditional compilation feature flagsto disable hand-vectorized code does not work is that there is no single feature flag thateverybody uses.In some crates, the  miri flag is used to disable vectorization but, as you mightimagine, the miri flag has other effects.In other crates, there is an explicit way of disabling vectorization usingsome crate-specific feature flag.And, in other crates, there is no way to disable vectorization.It might be a good idea to have a standard feature flag to disablehand-vectorized code but, at least for now,attempts to disable hand-vectorized code require different approaches foreach crate you want to use.</p><p> 最后，使用现有条件编译功能flagsto禁用手矢量化代码的原因是没有单个特征标志。在某些箱子中，Miri标志用于禁用矢量化，但与您一样，Miri标志有其他效果。在其他箱子中，有一种明确的方式来禁用传感器特定的传感器特定的功能标志。在其他箱子中，无法禁用Vecsionization.it可能是具有标准功能标志的好主意禁用禁用矢量化代码，但至少暂时尝试禁用手动矢量化代码需要不同的方法您要使用的句柄箱。</p><p>  Before I describe our new solution to this problem, it’s worth asking whetherthis matters? If your approach to verification is to use function contracts tolimit the scope of your work to the function you are currently working on, thenit will not matter at all. On the other hand, if your goal is like ours ofverifying entire programs without the overhead of specifying every function,then this will probably matter a lot because, even if the code you wrote doesnot use vector instructions, the chances are high that your code depends ona crate that depends on a crate that uses one of  regex/aho-corasick, hashbrown or  std::collections::HashMap – all of which use vectorinstructions. So, if you are interested in verifying entire programs, youprobably need a way of handling vector instructions. Alas, no Rustverification tools that we know of actually support vector instructions: theyjust fail with a message about unsupported instructions.</p><p>  在我描述了这个问题的新解决方案之前，值得询问吗？如果您的验证方法是使用职能合同，可以将您目前正在处理的功能的工作范围，但是根本无关紧要。另一方面，如果您的目标就像我们在没有指定每个函数的开销的情况下的那样，那么这可能很重要，因为即使您写的代码不使用矢量指令，您的代码很高ona crate，取决于使用Regex / Aho-corasick，hashbrown或std :: collections :: hashmap的箱子的箱子 - 所有这些都使用vector increstions。因此，如果您有兴趣验证整个程序，则可以使用一种方法来处理矢量指令。唉，没有我们知道实际支持的rustrified工具，我们知道了向量指令：它们会失败，并通过关于不受支持的指令的消息。</p><p> Our new approach to handling vector instructions is to  emulate vectorinstructions instead of trying to  eliminate them. That is we need a  SIMDemulation library and then we need to arrange for verification tools to usethat emulation library when they encounter vector instructions instead ofreporting that they have found an unsupported instruction.</p><p> 我们处理矢量指令的新方法是仿真矢量图，而不是尝试消除它们。这是我们需要一个Simdemulation库，然后我们需要安排验证工具在遇到仿真库时遇到矢量指令而不是报销他们找到了不受支持的指令。</p><p> Our  SIMD emulation library implements the processor-specific SIMD intrinsicsthat we have been finding in the LLVM bitcode generated from Rust programs.(This is probably a subset of the intrinsics that you would need if yourverification tools are based on MIR. We would happily add additional intrinsicsif other verification tools need them.)</p><p> 我们的SIMD仿真库实现了特定于处理器的SIMD IntrinsicSthat，我们已经在RUST程序生成的LLVM位代码中找到。（如果您的付款工具基于MIR，这可能是您需要的内在的子集。我们很乐意添加额外的InstinsicsIF其他验证工具需要它们。） </p><p>  SIMD instruction sets are typically quite large: there are a lot ofinstructions to support but there three features of SIMD instructions that reducethe effort required to write an emulation library.</p><p>SIMD指令集通常相当大：有很多义的标记来支持，但有三个功能的SIMD指令，可将所需仿真库所需的努力减少。</p><p> Almost all SIMD instructions fit into one of three patterns: map-likeinstructions such as vector addition that process vector elementsindependently of each other; fold-like instructions that combine vectorelements to give either a shorter vector or a scalar value; and permutationinstructions that rearrange vector elements.</p><p> 几乎所有SIMD指令都适用于三种模式之一：映射曲线标记，例如矢量添加，加工矢量彼此相互依赖;折叠式指令，将卷向量组合以提供较短的向量或标量值;和重新排列矢量元素的融合局。</p><p>  Almost all SIMD instructions are based on taking a large register anddividing it into a number of elements of with 8, 16, 32 or 64 bitsand, with the exception of Arm’s SVE, the register size and the number ofelements is a fixed power of two.</p><p>  几乎所有SIMD指令都基于将大型寄存器缩小到8,16,32或64位的元素中，除了ARM的SVE之外，寄存器尺寸和数量是两个固定功率。</p><p>  Almost all SIMD instructions have either two vector arguments or a vector argument and a scalar argument.</p><p>  几乎所有SIMD指令都有两个向量参数或矢量参数和标量参数。</p><p> These observations allow us to make very effective use of Rust’s macros andRust’s  Fn trait when writing our emulation library.</p><p> 这些观察允许我们在编写仿真库时非常有效地利用Rust的宏andrust的FN特征。</p><p> For example, the x86 architecture has a family of instructions called PSRLIthat combine a vector with a scalar immediate value.Each element of the vector argument is shifted by the distance specified by thescalar argument.</p><p> 例如，x86架构具有一个名为psrlithat的指令系列，该指令组合了一个标量标量的向量。向量参数的分离元素由thescalar参数指定的距离转移。</p><p> The action on each vector element can be described by a scalar functionthat shifts a scalar value by a scalar shift amount.For example, for 32-bit elements, the function looks like this.</p><p> 每个矢量元素的动作可以通过标量函数来描述按标量移量移位标量值。例如，对于32位元素，该函数看起来像这样。 </p><p> /// Logical shift right by 8-bit immediate (0 if shift distance too large) pub  fn  srl_immed_u32_u8 ( x :  u32 ,  imm8 :  u8 )  -&gt;  u32  {  if  imm8  &gt;  31  {  0  }  else  {  x  &gt;&gt;  imm8  } }</p><p>///逻辑转移到右8位立即（0如果移位距离太大）Pub Fn Srl_immed_u32_u8（x：u32，imm8：u8） - ＆gt; U32 {如果Imm8＆gt; 31 {0}否则{x＆gt;＆gt; IMM8}}</p><p> To implement the corresponding vector function, we “lift” the scalar functionso that it operates on vectors instead.Since this pattern is very common, we do this by defining alifting function such as this one that operates on vectors of four elementsto produce a function with one vector argument and one scalar argument.</p><p> 要实现相应的向量功能，我们“提升”标量功能，它在向量上运行.Since这个模式非常常见，我们通过定义诸如在四个ElementSto的矢量上运行的实现诸如此之外的化学函数来实现这一点一个矢量参数和一个标量参数。</p><p> // lift a binary operation over vector and scalar pub  fn  lift4_vs_v &lt; F ,  A ,  B ,  R &gt; ( f :  F ,  a :  A :: Vec ,  b :  B )  -&gt;  R :: Vec where  F :  Fn ( A ,  B )  -&gt;  R ,  A :  Vector4 ,  B :  Copy ,  R :  Vector4 , {  let  r0  =  f ( A :: get0 ( &amp; a ),  b );  let  r1  =  f ( A :: get1 ( &amp; a ),  b );  let  r2  =  f ( A :: get2 ( &amp; a ),  b );  let  r3  =  f ( A :: get3 ( &amp; a ),  b );  R :: new ( r0 ,  r1 ,  r2 ,  r3 ) }</p><p> //通过向量和标量PUB FN Lift4_VS_V升降二进制操作。 F，A，B，R>; （f：f，a：a :: vec，b：b） - ＆gt; R :: VEC其中F：Fn（a，b） - ＆gt; R，A：Vector4，B：复制，R：Vector4，{Let R0 = F（A :: Get0（＆amp; a），b）;让R1 = F（A :: Get1（＆amp; a），b）;让R2 = F（A :: Get2（＆amp; a），b）;让R3 = F（a :: get3（＆amp; a），b）; R :: New（R0，R1，R2，R3）}</p><p> It is now easy to combine these functions to emulate the 32-bit version of thePSRLI instruction.</p><p> 现在可以轻松地组合这些功能来模拟32位版本的ThePsRLI指令。</p><p> #[no_mangle]unsafe extern &#34;C&#34; fn llvm_x86_sse2_psrli_d(a: u32x4, imm8: i32) -&gt; u32x4 { lift4_vs_v(scalar::srl_immed_u32_u8, a, imm8 as u8)}</p><p> ＃[no_mangle]不安全extern＆＃34; c＆＃34; fn llvm_x86_sse2_psrli_d（a：u32x4，imm8：i32） - ＆gt; U32x4 {升降机4_vs_v（scalar :: srl_immed_u32_u8，a，imm8为u8）}</p><p> Note that the type  u32x4 is the Rust type representing a vector of four32-bit values.This type implements the trait  Vector4 used in the definition of lift4_vs_v.</p><p> 请注意，u32x4类型是表示四32位值的向量的生锈类型。本类型实现了升力4_vs_v定义中使用的特征矢量4。</p><p> And, by defining traits  Vector2,  Vector4,  Vector8,  Vector16 and Vector32, and associated lifting functions, we can very quickly implementother versions of the SSE2 PSRLI instruction.</p><p> 并且，通过定义特征Vector2，Vector4，Vector8，Vector16和Vector32，以及相关的提升功能，我们可以非常快速地实现SSE2 PSRLI指令的其他版本。 </p><p> #[no_mangle] unsafe  extern  &#34;C&#34;  fn  llvm_x86_sse2_psrli_b ( a :  u8x16 ,  imm8 :  i32 )  -&gt;  u8x16  {  lift16_vs_v ( scalar :: srl_immed_u8_u8 ,  a ,  imm8  as  u8 ) } #[no_mangle] unsafe  extern  &#34;C&#34;  fn  llvm_x86_sse2_psrli_w ( a :  u16x8 ,  imm8 :  i32 )  -&gt;  u16x8  {  lift8_vs_v ( scalar :: srl_immed_u16_u8 ,  a ,  imm8  as  u8 ) } #[no_mangle] unsafe  extern  &#34;C&#34;  fn  llvm_x86_sse2_psrli_q ( a :  u64x2 ,  imm8 :  i32 )  -&gt;  u64x2  {  lift2_vs_v ( scalar :: srl_immed_u64_u8 ,  a ,  imm8  as  u8 ) }</p><p>＃[no_mangle]不安全extern＆＃34; c＆＃34; fn llvm_x86_sse2_psrli_b（a：u8x16，imm8：i32） - ＆gt; U8X16 {升降机16_VS_V（Scalar :: srl_immed_u8_u8，a，imm8为u8）}＃[no_mangle]不安全extern＆＃34; c＆＃34; fn llvm_x86_sse2_psrli_w（a：u16x8，imm8：i32） - ＆gt; U16x8 {升降机8_vs_v（scalar :: srl_immed_u16_u8，a，imm8为u8）}＃[no_mangle]不安全extern＆＃34; c＆＃34; fn llvm_x86_sse2_psrli_q（a：u64x2，imm8：i32） - ＆gt; U64x2 {升降机2_vs_v（scalar :: srl_immed_u64_u8，a，imm8为u8）}</p><p>  There is no compiler flag that will cause rustc or LLVM to use our SIMDemulation library so whether our verification tool uses MIR or LLVM IR,the output of the compiler will contain calls to the official SIMD intrinsicsinstead of the SIMD emulation library.</p><p>  没有编译器标志将导致RustC或LLVM使用我们的Simdemulation库，以便我们的验证工具是使用MIR还是LLVM IR，编译器的输出将包含对SIMD仿真库的官方SIMD内部机构的呼叫。</p><p> One option for using the SIMD emulation library would be to modify ourverification tool to recognize calls to SIMD intrinsics and, instead,to treat them as calls to the emulation functions.</p><p> 使用SIMD仿真库的一个选项将是修改备伪工具以识别对SIMD内部内部的调用，而是将它们视为对仿真功能的调用。</p><p> But, one of our project goals is to be able to use as many differentverification tools as possible and we did not want to have to modify multipletools.So, instead, we extended the post-processor  rvt-patch-llvm that we wrote to handle initializers and command-line argumentsto replace all calls to SIMD intrinsics with calls to our SIMDemulation library. (The code that does the patching is  here.)</p><p> 但是，我们的项目目标之一就是能够尽可能多的不同操作工具，而且我们不想修改多重ools.so，相反，我们将我们写信的后处理器RVT-Patch-LLVM扩展initializers和命令行ArgumentSto将所有呼叫替换为SIMD内部内部的呼叫与我们的Simdemulation库进行调用。 （修补程序的代码在这里。）</p><p>   Although it initially seemed to be effective, we realized that our approach oftrying to  eliminate vector intrinsics was not working. This forced us to“bite the bullet” and write a partial SIMD emulation library. This turned outto be easier than we had feared because, although SIMD instruction sets arehuge, they contain a large amount of regularity.</p><p>   虽然它最初似乎是有效的，但我们意识到我们对消除传染媒介内在的方法不起作用。这使我们迫使我们“咬子弹”并写出部分SIMD仿真库。这令人伤心比我们担心更容易，因为SIMD指令集是arehuge，它们包含大量规律性。</p><p> Our emulation library meets our needs but we believe that it would also beuseful to teams developing other Rust verification tools. We would be veryhappy to work with other Rust verification teams to create a single SIMDemulation library that meets everybody’s needs.</p><p> 我们的仿真图书馆符合我们的需求，但我们认为它也会对开发其他生锈验证工具的团队肆无忌惮。我们将与其他生锈验证团队合作，以创建一个符合每个人需求的单一辛格测量库。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://project-oak.github.io/rust-verification-tools/2021/05/15/verifying-vectorized-code2.html">https://project-oak.github.io/rust-verification-tools/2021/05/15/verifying-vectorized-code2.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/矢量化/">#矢量化</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>