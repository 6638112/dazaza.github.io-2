<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>《数据集》(2018)中的有趣想法</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">《数据集》(2018)中的有趣想法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 02:23:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/34afa80e2a658d3608af0a50877a34f9.jpeg"><img src="http://img2.diglog.com/img/2020/10/34afa80e2a658d3608af0a50877a34f9.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Datasette ( previously) is my open source tool for exploring and publishing structured data. There are a lot of ideas embedded in Datasette. I realized that I haven’t put many of them into writing.</p><p>Datasette(以前)是我用于浏览和发布结构化数据的开源工具。在Datasette中嵌入了很多想法。我意识到我并没有把很多东西写下来。</p><p>   Datasette provides a read-only API to your data. It makes no attempt to deal with writes. Avoiding writes entirely is fundamental to a plethora of interesting properties, many of which are expanded on further below. In brief:</p><p>Datasette为您的数据提供只读API。它不尝试处理写入。完全避免写入是众多有趣属性的基础，其中许多属性将在下面进一步展开。简而言之：</p><p> Hosting web applications with no read/write persistence requirements is incredibly cheap in 2018—often free (both  ZEIT Now and a  Heroku have generous free tiers). This is a big deal: even having to pay a few dollars a month is enough to dicentivise sharing data, since now you have to figure out who will pay and ensure the payments don’t expire in the future.</p><p>在2018年，托管没有读/写持久性要求的web应用非常便宜--通常是免费的(Zeit Now和Heroku都有慷慨的免费层级)。这是一件大事：即使每月支付几美元也足以对共享数据进行统计，因为现在你必须找出谁来支付，并确保未来的支付不会过期。</p><p> Being read-only makes it trivial to scale: just add more instances, each with their own copy of the data. All of the hard problems in scaling web applications that relate to writable data stores can be skipped entirely.</p><p>因为是只读的，所以很难扩展：只需添加更多实例，每个实例都有自己的数据副本。在扩展Web应用程序时，与可写数据存储相关的所有难题都可以完全跳过。</p><p> Since the database file is opened using SQLite’s  immutable mode, we can accept arbitrary SQL queries with no risk of them corrupting the data.</p><p>由于数据库文件是使用SQLite的不可变模式打开的，因此我们可以接受任意SQL查询，而不会有损坏数据的风险。</p><p> Any time your data changes, you need to publish a brand new copy of the whole database. With the right hosting this is easy: deploy a brand new copy of your data and application in parallel to your existing live deployment, then switch over incoming HTTP traffic to your API at the load balancer level. Heroku and Zeit Now both support this strategy out of the box.</p><p>每当您的数据发生更改时，您都需要发布整个数据库的全新副本。有了合适的主机，这很容易做到：在现有实时部署的同时部署全新的数据和应用程序副本，然后在负载平衡器级别将传入的HTTP流量切换到您的API。Heroku和Zeit现在都支持这一开箱即用的策略。</p><p>  Since the data is read-only and is encapsulated in a single binary SQLite database file, we can bundle the data as part of the app. This means we can trivially create and publish Docker images that provide both the data and the API and UI for accessing it. We can also publish to any hosting provider that will allow us to run a Python application, without also needing to provision a mutable database.</p><p>由于数据是只读的，并且封装在单个二进制SQLite数据库文件中，因此我们可以将数据捆绑为应用程序的一部分。这意味着我们可以轻松地创建和发布Docker镜像，这些镜像既可以提供数据，也可以提供访问它的API和UI。我们还可以发布到允许我们运行Python应用程序的任何宿主提供程序，而不需要提供可变数据库。</p><p> The  datasette package command takes one or more SQLite databases and bundles them together with the Datasette application in a single Docker image, ready to be deployed anywhere that can run Docker containers.</p><p>Datasette Package命令获取一个或多个SQLite数据库，并将它们与Datasette应用程序捆绑在单个Docker映像中，随时可以部署到可以运行Docker容器的任何位置。</p><p>   Relational database are great: once you know how to use them, you can represent any data you can imagine using a carefully designed schema.</p><p>关系数据库很棒：一旦您知道如何使用它们，就可以使用精心设计的模式来表示您能想象到的任何数据。</p><p> What about data that’s too unstructured to fit a relational schema? SQLite includes excellent  support for JSON data—so if you can’t shape your data to fit a table schema you can instead store it as text blobs of JSON—and use SQLite’s JSON functions to filter by or extract specific fields.</p><p>如果数据过于非结构化，不适合关系模式怎么办？SQLite包括对JSON数据的出色支持-因此，如果您不能塑造适合表模式的数据，您可以将其存储为JSON的文本BLOB-并使用SQLite的JSON函数来过滤或提取特定字段。</p><p> What about binary data? Even that’s covered: SQLite will happily store binary blobs. My  datasette-render-images plugin ( live demo here) is one example of a tool that works with binary image data stored in SQLite blobs.</p><p>那么二进制数据呢？即使是这样，SQLite也会很高兴地存储二进制blob。我的Datasette-Render-Image插件(这里是实时演示)是一个处理存储在SQLite blob中的二进制图像数据的工具示例。</p><p> What if my data is too big? Datasette is not a “big data” tool, but if your definition of big data is something that won’t fit in RAM that threshold is growing all the time (2TB of RAM on a single AWS instance  now costs less than $4/hour).</p><p>如果我的数据太大怎么办？Datasette不是一个“大数据”工具，但是如果您对大数据的定义不适合RAM，那么这个门槛会一直在增加(单个AWS实例上2TB的RAM现在的成本不到4美元/小时)。</p><p> I’ve personally had great results from multiple GB SQLite databases and Datasette. The theoretical maximum size of a single SQLite database is  around 140TB.</p><p>我个人从多GB SQLite数据库和Datasette中获得了很好的结果。单个SQLite数据库的理论最大大小约为140TB。</p><p> SQLite also has built-in support for  surprisingly good full-text search, and thanks to being extensible via modules has excellent geospatial functionality in the form of the  SpatiaLite extension. Datasette benefits enormously from this wider ecosystem.</p><p>SQLite还内置了对好得出奇的全文搜索的支持，并且由于模块的可扩展性，它以SpatiaLite扩展的形式提供了出色的地理空间功能。Datasette从这个更广泛的生态系统中获益良多。</p><p> The reason most developers avoid SQLite for production web applications is that it doesn’t deal brilliantly with large volumes of concurrent writes. Since Datasette is read-only we can entirely ignore this limitation.</p><p>大多数开发人员避免将SQLite用于生产Web应用程序的原因是，它不能出色地处理大量并发写入。由于数据集是只读的，我们可以完全忽略此限制。</p><p>  Since the data in a Datasette instance never changes, why not cache calls to it forever?</p><p>既然Datasette实例中的数据永远不会更改，为什么不永远缓存对它的调用呢？</p><p> Datasette sends a far future HTTP cache expiry header with every API response. This means that browsers will only ever fetch data the first time a specific URL is accessed, and if you host Datasette behind a CDN such as  Fastly or  Cloudflare each unique API call will hit Datasette just once and then be cached essentially forever by the CDN.</p><p>Datasette在每个API响应中发送一个遥远的HTTP缓存过期标头。这意味着浏览器只会在第一次访问特定URL时获取数据，如果您在CDN(如Fastly或Cloudflare)后面托管Datasette，则每个唯一的API调用只会访问Datasette一次，然后CDN基本上会永远缓存它。</p><p> This means it’s safe to deploy a JavaScript app using an inexpensively hosted Datasette-backed API to the front page of even a high traffic site—the CDN will easily take the load.</p><p>这意味着使用廉价托管的Datasette支持的API将JavaScript应用程序部署到即使是高流量站点的首页也是安全的-CDN将很容易承担负载。</p><p> Zeit added Cloudflare to every deployment (even their free tier)  back in July, so if you are hosted there you get this CDN benefit for free.</p><p>早在7月份，Zeit就将Cloudflare添加到了每个部署中(甚至包括他们的免费层)，因此，如果您在那里托管，就可以免费获得CDN好处。</p><p> What if you re-publish an updated copy of your data? Datasette has that covered too. You may have noticed that every Datasette database gets a hashed suffix automatically when it is deployed:</p><p>如果您重新发布数据的更新副本，该怎么办？Datasette也涵盖了这一点。您可能已经注意到，每个DataSet数据库在部署时都会自动获得一个散列后缀：</p><p>  This suffix is based on the SHA256 hash of the entire database file contents—so any change to the data will result in new URLs. If you query a previous suffix Datasette will notice and redirect you to the new one.</p><p>此后缀基于整个数据库文件内容的SHA256散列，因此对数据的任何更改都将导致新的URL。如果您查询以前的后缀，Datasette会通知您并将您重定向到新的后缀。</p><p> If you know you’ll be changing your data, you can build your application against the non-suffixed URL. This will not be cached and will always 302 redirect to the correct version (and these redirects are extremely fast).</p><p>如果您知道要更改数据，则可以根据无后缀的URL构建应用程序。这将不会被高速缓存，并且将总是302重定向到正确的版本(并且这些重定向非常快)。</p><p>  The redirect sends an HTTP/2 push header such that if you are running behind a CDN that understands push ( such as Cloudflare) your browser won’t have to make two requests to follow the redirect. You can use the Chrome DevTools to see this in action:</p><p>重定向发送一个HTTP/2Push报头，这样，如果您在理解推送的CDN(比如Cloudflare)后面运行，您的浏览器就不必发出两个请求来跟踪重定向。您可以使用Chrome DevTools查看实际操作：</p><p>  And finally, if you need to opt out of HTTP caching for some reason you can disable it on a per-request basis by including  ?_ttl=0  in the URL query string. —for example, if you want to return a random member of the Avengers it doesn’t make sense to cache the response:</p><p>最后，如果出于某种原因需要退出HTTP缓存，您可以在URL查询字符串中包含？_ttl=0，以针对每个请求禁用它。-例如，如果您想要返回复仇者联盟的随机成员，则缓存响应没有意义：</p><p>   Datasette aims to reduce the friction for publishing interesting data online as much as possible.</p><p>Datasette的目标是尽可能减少在网上发布有趣数据的摩擦。</p><p>  # deploy to Herokudatasette publish heroku mydatabase.db# Or deploy to Zeit Nowdatasette publish now mydatabase.db</p><p>#部署到Herokudatasette发布Heroku mydatabase ase.db#或部署到Zeit NowDataette立即发布mydatabase.db。</p><p> These commands take one or more SQLite databases, upload them to a hosting provider, configure a Datasette instance to serve them and return the public URL of the newly deployed application.</p><p>这些命令获取一个或多个SQLite数据库，将它们上传到主机提供商，配置一个Datasette实例为它们提供服务，并返回新部署的应用程序的公共URL。</p><p> Out of the box, Datasette can publish to either Heroku or to Zeit Now. The  publish_subcommand plugin hook means other providers can be supported by writing plugins.</p><p>开箱即用，Datasette现在既可以发布到Heroku，也可以发布到Zeit。PUBLISH_SUBMAND插件钩子意味着可以通过编写插件来支持其他提供程序。</p><p>  Datasette believes that data should be accompanied by source information and a license, whenever possible. The  metadata.json file that can be bundled with your data supports these. You can also provide source and license information when you run  datasette publish:</p><p>Datasette认为，只要有可能，数据都应该伴随着源信息和许可证。可以与您的数据捆绑在一起的metadata.json文件支持这些功能。您还可以在运行数据集发布时提供源和许可证信息：</p><p>  When you use these options Datasette will create the corresponding  metadata.json file for you as part of the deployment.</p><p>当您使用这些选项时，Datasette将在部署过程中为您创建相应的metadata.json文件。</p><p>  I really love faceted search: it’s the first tool I turn to whenever I want to start understanding a collection of data. I’ve built faceted search engines on top of Solr, Elasticsearch and PostgreSQL and many of my favourite tools (like Splunk and Datadog) have it as a core feature.</p><p>我真的很喜欢分面搜索：每当我想要开始理解数据集合时，它都是我求助的第一个工具。我在Solr、Elasticsearch和PostgreSQL的基础上构建了多方面搜索引擎，许多我最喜欢的工具(如Splunk和Datadog)都将其作为核心功能。</p><p> Datasette automatically attempts to calculate facets against every table. You can read  more about the Datasette Facets feature here—as a huge faceted search fan it’s one of my all-time favourite features of the project. Now I can add SQLite to the list of technologies I’ve used to build faceted search!</p><p>Dataset自动尝试计算每个表的面。你可以在这里阅读关于Datasette facets特性的更多信息--作为一个巨大的分面搜索迷，它是我一直以来最喜欢的项目特性之一。现在我可以将SQLite添加到我用来构建分面搜索的技术列表中了！</p><p>  CSV is by far the most common format for sharing and publishing data online. Almost every useful data tool has the ability to export to it, and it remains the lingua franca of spreadsheet import and export.</p><p>CSV是迄今为止最常用的在线共享和发布数据格式。几乎每个有用的数据工具都可以导出到它，并且它仍然是电子表格导入和导出的通用语言。</p><p> It has many flaws: it can’t easily represent nested data structures, escaping rules for values containing commas are inconsistently implemented and it doesn’t have a standard way of representing character encoding.</p><p>它有许多缺陷：它不能很容易地表示嵌套的数据结构，包含逗号的值的转义规则实现不一致，并且它没有表示字符编码的标准方式。</p><p> Datasette aims to promote SQLite as a much better default format for publishing data. I would much rather download a .db file full of pre-structured data than download a .csv and then have to re-structure it as a separate piece of work.</p><p>Datasette旨在将SQLite提升为更好的发布数据的默认格式。我更愿意下载一个充满预结构化数据的.db文件，而不是下载一个.csv，然后不得不将其重新组织为一项单独的工作。</p><p> But interacting well with the enormous CSV ecosystem is essential. Datasette has  deep CSV export functionality: any data you can see, you can export—including the results of arbitrary SQL queries. If your query can be paginated Datasette can stream down every page in a single CSV file for you.</p><p>但与庞大的CSV生态系统良好互动是至关重要的。Datasette具有强大的CSV导出功能：您可以看到的任何数据都可以导出-包括任意SQL查询的结果。如果您的查询可以分页，Datasette可以向下传输单个CSV文件中的每一页。</p><p> Datasette’s sister-tool  csvs-to-sqlite handles the other side of the equation: importing data from CSV into SQLite tables. And the  Datasette Publish web application allows users to upload their CSVs and have them deployed directly to their own fresh Datasette instance—no command line required.</p><p>Datasette的姊妹工具CSV-to-sqlite处理等式的另一边：将数据从CSV导入SQLite表。此外，Datasette Publish Web应用程序允许用户上传其CSV，并将其直接部署到自己的全新Datasette实例中-不需要命令行。</p><p>  A lot of people these days are excited about  GraphQL, because it allows API clients to request exactly the data they need, including traversing into related objects in a single query.</p><p>现在很多人都对GraphQL感到兴奋，因为它允许API客户端准确地请求他们需要的数据，包括在单个查询中遍历到相关对象。</p><p>  There are a number of reasons most APIs don’t allow people to pass them arbitrary SQL queries:</p><p>大多数API不允许人们向它们传递任意SQL查询的原因有很多：</p><p> Performance: what if someone sends an accidental (or deliberate) expensive query that exhausts our resources?</p><p>性能：如果有人发送的意外(或故意)昂贵的查询耗尽了我们的资源，该怎么办？</p><p> Hiding implementation details: if people write SQL against our API we can never change the structure of our database tables</p><p>隐藏实现细节：如果人们针对我们的API编写SQL，我们就永远不能更改数据库表的结构。</p><p>  On security: the data is read-only, using SQLite’s immutable mode. You can’t damage it with a query—INSERT and UPDATEs will simply throw harmless errors.</p><p>在安全性方面：数据是只读的，使用SQLite的不可变模式。您不能用查询插入来破坏它，更新只会抛出无害的错误。</p><p> On performance: SQLite has a mechanism for canceling queries that take longer than a certain threshold. Datasette sets this to one second by default, though you can  alter that configuration if you need to (I often bump it up to ten seconds when exploring multi-GB data on my laptop).</p><p>在性能方面：SQLite有一种机制来取消耗时超过特定阈值的查询。默认情况下，Datasette将其设置为1秒，但如果需要，您可以更改该配置(在笔记本电脑上浏览多GB数据时，我经常将其设置为10秒)。</p><p> On hidden implementation details: since we are publishing static data rather than maintaining an evolving API, we can mostly ignore this issue. If you are really worried about it you can take advantage of  canned queries and  SQL view definitions to expose a carefully selected forward-compatible view into your data.</p><p>关于隐藏的实现细节：因为我们发布的是静态数据，而不是维护不断发展的API，所以我们基本上可以忽略这个问题。如果您确实担心这个问题，您可以利用预录查询和SQL视图定义将精心选择的向前兼容视图公开到您的数据中。</p><p>  I mentioned Datasette’s SQL time limits above. These aren’t just there to avoid malicious queries: the idea of “optimistic SQL evaluation” is baked into some of Datasette’s core features.</p><p>我在上面提到了Datasette的SQL时间限制。它们不仅仅是为了避免恶意查询：“乐观SQL求值”的概念已经融入到Datasette的一些核心特性中。</p><p> Consider  suggested facets—where Datasette inspects any table you view and tries to suggest columns that are worth faceting against.</p><p>考虑建议的方面-Datasette检查您查看的任何表，并尝试建议值得针对其进行方面的列。</p><p> The way this works is Datasette loops over  every column in the table and runs a query to see if there are less than 20 unique values for that column. On a large table this could take a prohibitive amount of time, so Datasette sets an aggressive timeout on those queries:  just 50ms. If the query fails to run in that time it is silently dropped and the column is not listed as a suggested facet.</p><p>其工作方式是Datasette遍历表中的每一列，并运行查询以查看该列的唯一值是否少于20个。在大型表上，这可能会花费令人望而却步的时间，因此Datasette对这些查询设置了激进的超时：只有50ms。如果查询在该时间内运行失败，它将被静默删除，并且该列不会作为建议的方面列出。</p><p> Datasette’s JSON API provides a mechanism for JavaScript applications to use that same pattern. If you add  ?_timelimit=20 to any Datasette API call, the underlying query will only get 20ms to run. If it goes over you’ll get a very fast error response from the API. This means you can design your own features that attempt to optimistically run expensive queries without damaging the performance of your app.</p><p>Datasette的JSON API为JavaScript应用程序提供了使用相同模式的机制。如果将？_TimeLimit=20添加到任何Datasette API调用，底层查询将只有20ms的运行时间。如果成功，您将从API获得非常快速的错误响应。这意味着您可以设计自己的功能，尝试乐观地运行昂贵的查询，而不会损害应用程序的性能。</p><p>  SQL pagination using OFFSET/LIMIT has a fatal flaw: if you request page number 300 at 20 per page the underlying SQL engine needs to calculate and sort all 6,000 preceding rows before it can return the 20 you have requested.</p><p>使用OFFSET/LIMIT的SQL分页有一个致命的缺陷：如果以每页20的速度请求页码300，底层SQL引擎需要计算和排序前面的所有6000行，然后才能返回您请求的20行。</p><p>  Keyset pagination (often known by other names, including cursor-based pagination) is a far more efficient way to paginate through data. It works against ordered data. Each page is returned with a token representing the last record you saw, then when you request the next page the engine merely has to filter for records that are greater than that tokenized value and scan through the next 20 of them.</p><p>键集分页(通常也称为其他名称，包括基于指针的分页)是一种更有效的数据分页方法。它对有序数据起作用。每页返回一个表示您最后看到的记录的令牌，然后当您请求下一页时，引擎只需过滤大于该标记化值的记录，并扫描接下来的20条记录即可。</p><p> (Actually, it scans through 21. By requesting one more record than you intend to display you can detect if another page of results exists—if you ask for 21 but get back 20 or less you know you are on the last page.)</p><p>(实际上，它扫描21个。通过请求比您打算显示的记录多一条记录，您可以检测是否存在另一页结果-如果您请求21条记录，但得到的结果少于或等于20条，则您知道您是在最后一页。)。</p><p>  Datasette defaults to sorting by primary key (or SQLite rowid). This is perfect for efficient pagination: running a select against the primary key column for values greater than X is one of the fastest range scan queries any database can support. This allows users to paginate as deep as they like without paying the offset/limit performance penalty.</p><p>数据集默认为按主键(或SQLite行ID)排序。这非常适合进行高效的分页：对主键列运行SELECT以查找大于X的值是任何数据库都能支持的最快的范围扫描查询之一。这允许用户根据自己的喜好进行分页，而无需支付偏移/限制性能损失。</p><p> This is also how the “export all rows as CSV” option works: when you select that option, Datasette opens a stream to your browser and internally starts keyset-pagination over the entire table. This keeps resource usage in check even while streaming back millions of rows.</p><p>这也是“将所有行导出为CSV”选项的工作方式：当您选择该选项时，Datasette会向您的浏览器打开一个流，并在内部开始对整个表进行键集分页。这样即使在流回数百万行的情况下也能保持对资源使用的控制。</p><p> Here’s where Datasette gets fancy: it handles keyset pagination for any other sort order as well. If you sort by any column and click “next” you’ll be requesting the next set of rows after the last value you saw. And this even works for columns containing duplicate values: If you sort by such a column, Datasette actually sorts by that column combined with the primary key. The “next” pagination token it generates encodes both the sorted value and the primary key, allowing it to correctly serve you the next page when you click the link.</p><p>这就是Datasette的用武之地：它还处理任何其他排序顺序的键集分页。如果按任何列排序并单击“下一步”，您将请求上一次看到的值之后的下一组行。这甚至适用于包含重复值的列：如果您按这样的列排序，Datasette实际上会结合主键按该列排序。它生成的“NEXT”分页标记对排序值和主键都进行了编码，这样当您单击链接时，它就可以正确地为您提供下一页。</p><p> Try clicking “next”  on this page to see keyset pagination against a sorted column in action.</p><p>尝试单击此页面上的“下一步”，查看针对已排序列的键集分页操作。</p><p>  I love interactive demos. I decided it would be useful if every single release of Datasette had a permanent interactive demo illustrating its features.</p><p>我喜欢互动演示。我决定，如果Datasette的每个版本都有一个永久性的交互式演示来说明它的功能，那将会很有用。</p><p> Thanks to Zeit Now, this was pretty easy to set up. I’ve actually taken it a step further: every successful push to master on GitHub is also deployed to a permanent URL.</p><p>多亏了Zeit Now，这很容易设置。实际上，我已经更进一步：在GitHub上成功推送到Master的每一次推送都会部署到一个永久的URL。</p><p>  https://latest.datasette.io/—the most recent commit to Datasette master. You can see the currently deployed commit hash on  https://latest.datasette.io/-/versions and compare it to  https://github.com/simonw/datasette/commits</p><p>Https://latest.datasette.io/-对数据集主设备的最新提交。您可以查看https://latest.datasette.io/-/versions上当前部署的提交散列，并将其与https://github.com/simonw/datasette/commits进行比较。</p><p> https://v0-25.datasette.io/ is a permanent URL to the 0.25 tagged release of Datasette. See also  https://v0-24.datasette.io/ and  https://v0-23-2.datasette.io/</p><p>Https://v0-25.datasette.io/是0.25标签版本数据集的永久网址。另请参阅https://v0-24.datasette.io/和https://v0-23-2.datasette.io/。</p><p> The database that is used for this demo is the exact same database that is created by Datasette’s  unit test fixtures. The unit tests are already designed to exercise every feature, so reusing them for a live demo makes a lot of sense.</p><p>此演示使用的数据库与Datasette的单元测试装置创建的数据库完全相同。单元测试已经设计用于执行每个功能，因此重用它们作为实时演示非常有意义。</p><p> You can view this test database on your own machine by checking out the full Datasette repository from GitHub and running the following:</p><p>通过从GitHub签出完整的Datasette存储库并运行以下命令，您可以在自己的计算机上查看此测试数据库：</p><p>  Here’s  the code in the Datasette Travis CI configuration that deploys a live demo for every commit and every released tag.</p><p>下面是Datasette Travis CI配置中的代码，它为每个提交和发布的标记部署一个实时演示。</p><p>   Datasette’s unit tests  include some assertions that ensure that every plugin hook, configuration setting and underlying view class is mentioned in the documentation. A commit or pull request that adds or modifies these without also updating the documentation (or at least ensuring there is a corresponding heading in the docs) will fail its tests.</p><p>Datasette的单元测试包括一些断言，以确保文档中提到每个插件挂钩、配置设置和底层视图类。在不更新文档(或至少确保文档中有相应的标题)的情况下添加或修改这些内容的提交或拉入请求将无法通过其测试。</p><p>  Datasette’s  documentation is in pretty good shape now, and  the changelog provides a detailed overview of new features that I’ve added to the project. I presented Datasette at the PyBay conference in August and I’ve published  my annotated slides from that talk. I was  interviewed about Datasette for the Changelog podcast in May and  my notes from that conversation include some of my favourite demos.</p><p>Datasette的文档现在相当不错，ChangeLog提供了我添加到项目中的新功能的详细概述。我在8月份的PyBay会议上展示了Datasette，我已经发表了那次演讲的注释幻灯片。我在5月份为Changelog播客接受了关于Datasette的采访，我在那次对话中的笔记包括了一些我最喜欢的演示。</p><p> Datasette now has an official Twitter account—you can follow  @datasetteproj there for updates about the project.</p><p>Datasette现在有了一个官方Twitter账号-你可以在那里关注@Datetteproj，以获得关于该项目的最新消息。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://simonwillison.net/2018/Oct/4/datasette-ideas/">https://simonwillison.net/2018/Oct/4/datasette-ideas/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ideas/">#ideas</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/datasette/">#datasette</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1029792.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fe3e0410abbdbd95dc5c54de84a2381f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029792.html">
谷歌云推出其首个专用抵押贷款行业工具Lending DocAI</a></div><span class="my_story_list_date">2020-10-19 21:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029773.html"><img src="http://img2.diglog.com/img/2020/10/thumb_4145a05d706987593301182d291ceb1b.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029773.html">隐私倡导者对新加坡全球首个面部扫描计划感到震惊</a></div><span class="my_story_list_date">2020-10-19 20:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029747.html"><img src="http://img2.diglog.com/img/2020/10/thumb_be571547a6f3353786414c764df0adf2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029747.html">综述人工智能驱动的电池研究的现状，直到最近，这一研究还受到数据缺乏的阻碍，但现在正准备加快步伐</a></div><span class="my_story_list_date">2020-10-19 15:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029659.html"><img src="http://img2.diglog.com/img/2020/10/thumb_eeec9a4b1344d33d99a0a14e66d4ae43.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029659.html">一种激进的新技术让人工智能在几乎没有数据的情况下学习</a></div><span class="my_story_list_date">2020-10-19 3:55</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>