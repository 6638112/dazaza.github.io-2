<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#编译器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#编译器</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1065348.html">从javascript透视中生锈 </a></div><div class="item_title_en"><a target="_blank" href="https://blogs.harvard.edu/kapolos/rust-from-a-javascript-perspective/">Rust from a JavaScript Perspective</a><span>(blogs.harvard.edu)</span></div><span class="my_story_list_date">2021-6-13 0:40</span><div class="my_story_list_item_desc">使用Rust为写小工具，我一直在很开心。我的日常工作涉及大量的JavaScript和Rust提供了一种熟悉的感觉，因此尝试锈病是一个容易做出的决定。但与此同时，实际上在Rust中做了有意义的工作需要很多重新思考如何构建与您的代码有关的结构和原因。编译器 - 符合其呼叫 - 是无情的;然而，出于某种原因，它出现了很多乐......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1065237.html">openmp的编译器视图 </a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=eIMpgez61r4">A Compilers View of OpenMP</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2021-6-12 7:46</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1065237.html"><img src="http://img2.diglog.com/img/2021/6/thumb_90aa18043a2651958098d0095532dd94.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在本网络研讨会中，我们将通过编译器前端查看OpenMP API指令的解释，包括OpenMP与编译器Optimi的互动... </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/view/">#view</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/openmp/">#openmp</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062592.html">用于小型系统的自托管ADA灵感编程语言 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/davidgiven/cowgol">A self-hosted Ada-inspired programming language for small systems</a><span>(github.com)</span></div><span class="my_story_list_date">2021-5-14 7:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1062592.html"><img src="http://img2.diglog.com/img/2021/5/thumb_90b7496d5b969f36dcf39c27db9980f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Cowgol是一种实验性的，适用于非常小的系统的ADA灵感语言（6502，Z80等）。它不同，因为它的＆＃39;旨在自托管在这些设备上：最终目标是能够重建整个编译器onan 8位微量，虽然我们＆＃39;尚未存在。
  桌面驱动，易于端口后端（80386后端是1.2kloc，需要其他编译器更改）
 微小：80386 L......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/托管/">#托管</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ada/">#ada</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1060980.html">可移植性是可靠性 </a></div><div class="item_title_en"><a target="_blank" href="http://evan.nemerson.com/2021/05/04/portability-is-reliability/">Portability Is Reliability</a><span>(evan.nemerson.com)</span></div><span class="my_story_list_date">2021-5-6 14:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1060980.html"><img src="http://img2.diglog.com/img/2021/5/thumb_7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">任何熟悉我的开源工作的人都知道我的工作的重点是在可移植性上，但最近对我来说，很多人可能不知道为什么。
  Hedley  - 一个C / C ++标题，让您利用所有平台（旧标准，C与C ++，不同编译器，旧编译器等）可能无法使用的功能，而不会创建硬依赖性。
 便携式代码段 - 织放相关模块的集合，旨在提供对不同功能的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/可移植性/">#可移植性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1060559.html">编译器将优化它 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.royalsloth.eu/posts/the-compiler-will-optimize-that-away/">The compiler will optimize that away</a><span>(blog.royalsloth.eu)</span></div><span class="my_story_list_date">2021-5-5 20:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1060559.html"><img src="http://img2.diglog.com/img/2021/5/thumb_2dc7adb413e443e6dedaa2c19a2ef1c2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">很多程序员都认为编译器是魔法黑匣子，您可以在其中普通杂乱的代码，并获得一个很好的优化二进制。走廊哲学家频道经常开始争论哪个语言功能或编译器标志使用的命令来捕获编译器的魔术的全部力量。如果您见过GCC码库，您真的相信它必须是来自另一个星球的工人魔法优化。
 尽管如此，如果您分析编译器的输出，您将发现编译器并不是在优化代......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1060129.html">业余编译器作家的资源 </a></div><div class="item_title_en"><a target="_blank" href="https://c9x.me/compile/bib/">Resources for Amateur Compiler Writers</a><span>(c9x.me)</span></div><span class="my_story_list_date">2021-4-26 10:30</span><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters
每个计算机科学家应该知道浮点算术。 大卫·格洛伯格。 [PDF]系统V应用二进制接口（AMD64）。 [PDF]（几乎）在运行UNIX OS上的X64平台上与C代码接口的所有内容。 手术呼叫标准ARM 64位架构。 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/amateur/">#amateur</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/接口/">#接口</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1057284.html">一年的编译器模糊竞选活动 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.trailofbits.com/2021/03/23/a-year-in-the-life-of-a-compiler-fuzzing-campaign/">A Year in the Life of a Compiler Fuzzing Campaign</a><span>(blog.trailofbits.com)</span></div><span class="my_story_list_date">2021-4-9 23:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1057284.html"><img src="http://img2.diglog.com/img/2021/4/thumb_38946b4e40e80ee3b42b0c5fe6224e1b.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在2020年夏天，我们描述了我们的工作模糊巩固编译器，Solc。所以现在我们想重新审视这个项目，因为模糊运动往往会“饱和”，以时间随着时间的推移找到较少的新结果。坚固的模糊耗尽气体吗？欺骗一个高赌注项目值得的，特别是如果它有自己的积极和有效的模糊努力？
 使用AFL Variant的2月20日2月份提交了该模糊运动的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/life/">#life</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1055270.html">为什么电脑不会让自己更聪明 </a></div><div class="item_title_en"><a target="_blank" href="https://www.newyorker.com/culture/annals-of-inquiry/why-computers-wont-make-themselves-smarter">Why Computers Won't Make Themselves Smarter</a><span>(www.newyorker.com)</span></div><span class="my_story_list_date">2021-4-1 19:34</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1055270.html"><img src="http://img2.diglog.com/img/2021/4/thumb_f10e5af7a9be0cd712ed97160b37081b.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在第十一个世纪，坎特伯雷的圣安塞姆提出了一个粗略地存在的上帝的争论：上帝通过定义，我们可以想象的最大的是;一个不存在的上帝显然不如上帝那么伟大; ergo，上帝必须存在。这被称为本体论争论，有足够的人发现它令人信服仍在讨论，近一千年之后。本体论争论的一些批评者争辩说，它基本上定义了存在的存在，这不是定义如何工作。
 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/电脑/">#电脑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/won/">#won</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1052673.html">kotlin编译器崩溃课程 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/ahinchman1/Kotlin-Compiler-Crash-Course">Kotlin Compiler Crash Course</a><span>(github.com)</span></div><span class="my_story_list_date">2021-3-16 14:56</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1052673.html"><img src="http://img2.diglog.com/img/2021/3/thumb_86209d8c77a4f7f8ba0b1ee05ac78f17.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">根据Kotlin编译器，PSI或Program Struction界面，树是基于AST的顶部构建的，为操纵特定语言构造添加语义和方法。  AST节点具有直接映射到底层文档中的文本范围。 AST的最底部节点匹配Lexer返回的单个令牌，更高级别的节点匹配多个令牌片段。 对AST树的节点执行的操作，例如插入，删除，重新排......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048950.html">向后教授编制者 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.sigplan.org/2021/02/23/teaching-compilers-backward/">Teaching Compilers Backward</a><span>(blog.sigplan.org)</span></div><span class="my_story_list_date">2021-2-24 21:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1048950.html"><img src="http://img2.diglog.com/img/2021/2/thumb_932aecf5e920ef33444d8ee2ec6a420d.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">编译程序是一个引人入胜的复杂过程，高级程序通过该程序成为低级可执行代码。如何规划和实现这样的旅程？开发技术后，如何教给别人？
  最近有很多关于编译器类的教学法的讨论。在此博客文章中，我们将重点介绍编译器构造类的一种设计：材料的表示顺序。通常，编译器类按执行顺序显示编译器的阶段。我们称此为“前进”方向。在特拉维夫大学......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/教授/">#教授</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/teaching/">#teaching</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048697.html">Cranelift，第2部分：编译器效率，CFG和分支窥孔优化器 </a></div><div class="item_title_en"><a target="_blank" href="https://cfallin.org/blog/2021/01/22/cranelift-isel-2/">Cranelift, Part 2: Compiler Efficiency, CFGs, and a Branch Peephole Optimizer</a><span>(cfallin.org)</span></div><span class="my_story_list_date">2021-2-21 7:59</span><div class="my_story_list_item_desc">这篇文章是有关Cranelift的三部分系列文章中的第二篇。在第一篇文章中，我描述了Cranelift及其替代后台代码生成基础结构的项目的上下文，并详细说明了指令选择问题以及如何解决它。剩下的两篇文章将深入探讨一些有趣的工程问题。
 在本文中，我想更深入地探讨我们工作中的编译器性能方面。 （在下一篇文章中，我们将探讨......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/part/">#part</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分支/">#分支</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048244.html">StoneKnifeForth（带有元圆编译器） </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/kragen/stoneknifeforth">StoneKnifeForth (With a Metacircular Compiler)</a><span>(github.com)</span></div><span class="my_story_list_date">2021-2-18 19:58</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1048244.html"><img src="http://img2.diglog.com/img/2021/2/thumb_ce00794a028c72d5981243d49a05839d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这就是StoneKnifeForth，这是一种受Forth启发的非常简单的语言。预计它不会有用；相反，其目的是显示编译器的简单程度。删除注释时，编译器在两页代码下有点不足。
 该软件包包括一个用“ StoneKnifeForth”编写的“元圆环编译器”，并将StoneKnifeForth编译为x86 Linux EL......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1047442.html">编译器类 </a></div><div class="item_title_en"><a target="_blank" href="https://norswap.com/compilers/">Compiler Class</a><span>(norswap.com)</span></div><span class="my_story_list_date">2021-2-9 20:38</span><div class="my_story_list_item_desc">所有课程材料都可以在线获取，以供有兴趣的人阅读。 我也很乐意回答您的问题。  该课程的项目是创建自己的编程语言。 提供了一些库来协助完成此任务： </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/回答/">#回答</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1046017.html">旧编译器和旧错误 </a></div><div class="item_title_en"><a target="_blank" href="https://lwn.net/Articles/842122/">Old Compilers and Old Bugs</a><span>(lwn.net)</span></div><span class="my_story_list_date">2021-1-24 3:33</span><div class="my_story_list_item_desc">给LWN订户的好处订阅LWN的主要好处是有助于我们继续发布，但除此之外，订户还可以立即访问所有网站内容，并可以访问许多其他网站功能。 请立即注册！  内核项目竭尽全力促进使用较旧的工具链进行构建。 在新系统上构建内核就已经是一个挑战。 首先被迫安装自定义工具链不会改善这种情况。 因此，内核开发人员试图通过大多数发行商......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发人员/">#开发人员</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045495.html">编译器很难 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.shipreq.com/post/compilers_are_hard">Compilers Are Hard</a><span>(blog.shipreq.com)</span></div><span class="my_story_list_date">2021-1-21 12:43</span><div class="my_story_list_item_desc">我经常听说编写编译器很困难，并且与编写其他类型的软件有所不同。一些近期的经验使我对为什么会这样有深刻的认识，并证明了这很有趣！
 我最近完成了ShipReq的新功能的工作。我花了大约2个月的时间进行开发，最终成为我一生中编写过的最困难的代码。我已经进行了数十年的编码，从事过许多不同的项目，并且从事的工作非常庞大组织；......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041902.html">如何设计一种新的编程语言 </a></div><div class="item_title_en"><a target="_blank" href="https://drewdevault.com/2020/12/25/How-to-design-a-new-programming-language.html">How to design a new programming language</a><span>(drewdevault.com)</span></div><span class="my_story_list_date">2020-12-26 19:28</span><div class="my_story_list_item_desc">从模糊的，空洞的想法到如何在新的编程语言中实现，再到健壮，自洽，实际的实现这些想法，还有很长的路要走。从头开始设计和实现新的编程语言是程序员可以执行的最具挑战性的任务之一。
 注意：这篇文章的目标读者是那些想要在设计有用的编程语言上做出艰苦尝试的积极进取的程序员。如果您只是想将一种语言作为有趣的附带项目，那么您完全可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039109.html">CS 6120：高级编译器：自学在线课程 </a></div><div class="item_title_en"><a target="_blank" href="https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/">CS 6120: Advanced Compilers: The Self-Guided Online Course</a><span>(www.cs.cornell.edu)</span></div><span class="my_story_list_date">2020-12-12 0:14</span><div class="my_story_list_item_desc">CS 6120是Adrian Sampson撰写的有关编程语言实现的博士学位级别的Cornell CS课程。它涵盖通用编译器主题，例如中间表示，数据流和“经典”优化，以及更多研究型主题，例如并行化，即时输入。编译和垃圾回收。这项工作包括阅读论文和开源黑客任务，这些任务使用LLVM和为此课程发明的教育IR。
 本页列出......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/课程/">#课程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037116.html">Nim编译器— Pascal源代码</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nim-lang/Nim/tree/ea1f1ec6d4d6c776eb0f81c2bebdd4cb4c817ebe/nim">Nim compiler — Pascal source code</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-29 16:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037116.html"><img src="http://img2.diglog.com/img/2020/11/thumb_025b67dc2053e70abacf6317da9484ff.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Nim是一种静态类型的编译系统编程语言。它结合了来自成熟语言（如Python，Ada和Modula）的成功概念。其设计注重效率，表达力，...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036520.html">法国税法的现代编译器</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2011.07966">A Modern Compiler for the French Tax Code</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-11-25 22:0</span><div class="my_story_list_item_desc">下载PDF摘要：在法国，所得税是根据法国公共财政局（DGFiP）创作，设计和维护的，从纳税人的个人收益中计算得出的。该算法依赖于传统的自定义语言和最初于1990年设计的编译器，它与法国葡萄酒不同，没有随着时间的流逝而衰老。由于输入语言的不足和编译器的技术局限性，该算法越来越难以维护，它依靠临时行为和变通办法来实现税法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/税法/">#税法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035815.html">切线的白日梦（Julia中的自动区分）[视频]</a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=mQnSRfseu0c">Daydreaming of Cotangents (Automatic Differentiation in Julia) [video]</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-11-22 6:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035815.html"><img src="http://img2.diglog.com/img/2020/11/thumb_8897a2eadffecec0c4d8d745847b32a6.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">非本地语义编译器转换（例如自动区分和某些贝叶斯推理算法）给动态化带来了特殊挑战。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/白日梦/">#白日梦</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033590.html">在C语言中如何处理左递归语法</a></div><div class="item_title_en"><a target="_blank" href="https://www.reddit.com/r/Compilers/comments/jj70l3/how_is_left_recursive_grammar_handled_in_the_c/">How is left recursive grammar handled in the C language</a><span>(www.reddit.com)</span></div><span class="my_story_list_date">2020-11-7 11:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1033590.html"><img src="http://img2.diglog.com/img/2020/11/thumb_3607dbc78d46474b844fe4e0060bee56.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在过去的几个月里，我一直在用C语言编写一个C编译器，这是一次非常困难的经历。我这么做是为了看看能不能把《龙》这本著名的书中提到的理论概念用上，其中有几个让我有点摸不着头脑。
所以我做了一个小程序，简单地声明了`x`，并给它赋值，这个值是`x`的乘法。
这是可以编译的，但我想知道编译器如何决定在RHS上设置‘x’的值来......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/递归/">#递归</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/recursive/">#recursive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032476.html">迷你编译器：lexing</a></div><div class="item_title_en"><a target="_blank" href="https://christine.website/blog/minicompiler-lexing-2020-10-29">Minicompiler: Lexing</a><span>(christine.website)</span></div><span class="my_story_list_date">2020-10-31 19:54</span><div class="my_story_list_item_desc">我一直想做自己的编译器。编译器是我日常工作中不可或缺的一部分，我经常使用它们的成果。不久前，当我浏览TempleOS源代码时，在：：/Demos/Lessons文件夹中发现了MiniCompiler.HC，我有点吃惊。它实现了一个从简单的数学表达式到AMD64字节码的两阶段编译器(完成后将其比特转换为代码稍后跳转到的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030801.html">了解静态单一分配表单</a></div><div class="item_title_en"><a target="_blank" href="https://blog.yossarian.net/2020/10/23/Understanding-static-single-assignment-forms">Understanding static single assignment forms</a><span>(blog.yossarian.net)</span></div><span class="my_story_list_date">2020-10-24 7:24</span><div class="my_story_list_item_desc">应大众要求，我正在做另一篇LLVM帖子。这一次，它是单一静态赋值(或SSA)形式，这是优化编译器的中间表示中的一个常见特性。
就像上一个一样，SSA是编译器和IR设计的主题，我大部分都能理解，但可以从一些自我指导的学习中受益。我们到了。
在最高级别，编译器的工作是单一的：将一些源语言输入转换成一些机器语言输出。在内部......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/static/">#static</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027243.html">除非它是编译器错误，否则它永远不会是编译器错误</a></div><div class="item_title_en"><a target="_blank" href="http://r6.ca/blog/20200929T023701Z.html">It Is Never a Compiler Bug Until It Is</a><span>(r6.ca)</span></div><span class="my_story_list_date">2020-9-30 18:43</span><div class="my_story_list_item_desc">上周，我试图向libsecp256k1添加一些测试代码，我拔掉头发试图让它正常工作。没有多少printf工作来说明我做错了什么。最后，出于无奈，我想我应该快速检查一下是否有与memcmp相关的编译器错误，结果，我发现了GCC错误#95189：memcmp像strcmp一样被错误地剥离。
老实说，读起来这是一个相当可怕......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026143.html">自举</a></div><div class="item_title_en"><a target="_blank" href="https://bootstrapping.miraheze.org/wiki/Main_Page">Bootstrapping</a><span>(bootstrapping.miraheze.org)</span></div><span class="my_story_list_date">2020-9-24 21:23</span><div class="my_story_list_item_desc">简单说明：自举是指使用比自身更小的工具构建编译器，而不是使用已构建的自身版本构建编译器。第二个问题是：预构建的二进制文件是从哪里来的？
这是从使用十六进制编辑器编写的十六进制汇编器开始引导一系列语言过程的详细日志。
本文讨论了软件长期保存的方法。简要介绍不会随着时间的推移而降级的硬件，但本文的大部分内容是关于如何设计......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026110.html">CPython编译器的工作原理</a></div><div class="item_title_en"><a target="_blank" href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">How the CPython compiler works</a><span>(tenthousandmeters.com)</span></div><span class="my_story_list_date">2020-9-24 17:31</span><div class="my_story_list_item_desc">在本系列的第一篇文章中，我们介绍了CPython VM。我们已经了解到它是通过执行一系列称为字节码的指令来工作的。我们还看到，Python字节码不足以完全描述一段代码的功能。这就是存在代码对象概念的原因。执行诸如模块或函数的代码块意味着执行相应的代码对象。代码对象包含块的字节码、常量和块中使用的变量名称以及块的各种属......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022623.html">如何对Rust编译器进行最后一次加速</a></div><div class="item_title_en"><a target="_blank" href="https://blog.mozilla.org/nnethercote/2020/09/08/how-to-speed-up-the-rust-compiler-one-last-time/">How to speed up the Rust compiler one last time</a><span>(blog.mozilla.org)</span></div><span class="my_story_list_date">2020-9-8 7:16</span><div class="my_story_list_item_desc">由于Mozilla最近的变化，我从事Rust编译器的时间即将结束。我仍然在Mozilla工作，但在可预见的未来，我将专注于Firefox的工作。
所以我想我应该结束我的“如何加速铁锈编译器”系列，这个系列始于2016年。
如何提高铁锈编译器的速度。原始的帖子，标题最有意义的帖子。它主要关注如何为性能工作设置编译器，包......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021605.html">编译器的深度学习</a></div><div class="item_title_en"><a target="_blank" href="https://era.ed.ac.uk/handle/1842/36866">Deep Learning for Compilers</a><span>(era.ed.ac.uk)</span></div><span class="my_story_list_date">2020-9-1 22:59</span><div class="my_story_list_item_desc">构建编译器很困难。优化编译器是耗资数百万美元的项目多年来的发展，但仍然无法充分利用可用的性能，并且很容易被窃听。快速过渡到异构并行和多样化的体系结构提高了对积极优化编译器的需求一直居高不下，使得编译器开发人员难以跟上。我们需要的是简化编译器构造的更好工具。本文提出了显著降低编译器成本的新技术构造，同时提......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/深度学习/">#深度学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/深度/">#深度</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learning/">#learning</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021198.html">铁锈编译器开发指南</a></div><div class="item_title_en"><a target="_blank" href="https://rustc-dev-guide.rust-lang.org/">Guide to the Rust Compiler Development</a><span>(rustc-dev-guide.rust-lang.org)</span></div><span class="my_story_list_date">2020-8-30 3:39</span><div class="my_story_list_item_desc">本指南旨在帮助记录Rustc(Rust编译器)是如何工作的，并帮助新的贡献者参与到Rustc开发中来。
构建和调试rustc：包含无论您如何贡献都应该有用的信息，关于构建、调试、概要分析等。
贡献给Rustc：包含无论您如何贡献都应该有用的信息，关于贡献的程序、稳定特性等。
高级编译器体系结构：讨论编译器的高级体系结......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rustc/">#rustc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020018.html">一个简单的模式编译器(1997)</a></div><div class="item_title_en"><a target="_blank" href="https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v14/schintro_142.html#SEC271">A Simple Scheme Compiler (1997)</a><span>(www.cs.utexas.edu)</span></div><span class="my_story_list_date">2020-8-24 19:8</span><div class="my_story_list_item_desc">现在，当我们开始编译时，我们只需处理一种事情--整个过程，当我们拿回结果代码并将其打包以运行它时，我们将始终处理整个过程的代码。这使得创建要调用的实际闭包变得很容易。
我们用来开始编译的主要例程是Compile-Procedure，它以表达式、编译时环境、编译时连续和文字列表作为参数。它返回过程的中间代码和更新后的文......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模式/">#模式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scheme/">#scheme</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item active"><a class="page-link" href="/tag/编译器/">0</a></li><li class="page-item"><a class="page-link" href="/tag/编译器/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>