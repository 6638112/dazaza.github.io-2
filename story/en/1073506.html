<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>结构型条件处理Structurally-Typed Condition Handling</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Structurally-Typed Condition Handling<br/>结构型条件处理</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 19:39:17</div><div class="page_narrow text-break page_content"><p>Something I&#39;ve had puttering around in the back of my head for  ages now is My Perfect Application Language. There are languages out there that I like more or less, but I still believe that another language could be a more perfect fit for the software I want to write  1, and I have a large number of ideas about what features it would include, what features it would omit, how it might be written, and so forth.</p><p>我&#39；我已经在脑后胡思乱想了很长时间，现在是我完美的应用程序语言。有一些语言我或多或少都喜欢，但我仍然相信另一种语言可能更适合我想写的软件1，我有很多想法，关于它将包括哪些功能，它将省略哪些功能，如何编写，等等。</p><p> One dissatisfaction I have with existing languages is that I think none of them do error-handling  terribly well.  Graydon Hoare&#39;s very good blog post  What next? talks about places that programming languages might go in the future, and one thing he notes is that we&#39;ve got various approaches but none of them feel obviously right. I very much agree and I don&#39;t want to pretend I&#39;ve “solved” error-handling here.</p><p>我对现有语言的一个不满是，我认为它们都不能很好地处理错误。格雷登·霍尔&#39；What’很好的博客文章下一步是什么？谈到编程语言未来可能会去的地方，他指出的一件事是我们&#39；我有各种各样的方法，但没有一种感觉明显是对的。我非常同意，我不&#39；我不想假装我&#39；我们在这里“解决”了错误处理。</p><p> However, I&#39;ve got a hypothesis about what sort of error-handling system I might want in My Perfect Application Language, and I&#39;ve never actually written it down in full. I&#39;m not imagining a completely novel error-handling system: instead, I&#39;m imagining taking a few ideas which have been tried and combining them in a somewhat novel way to hopefully combine their strengths and temper their weaknesses. To explain this hypothetical feature, I&#39;m going to break it down into two language design hypotheses:</p><p>然而，我&#39；我有一个假设，关于在我完美的应用程序语言中我可能需要什么样的错误处理系统，我&#39；我从来没有完整地写过。我&#39；我没有想象一个全新的错误处理系统：相反，我&#39；我想象着用一些已经尝试过的想法，并以一种新颖的方式将它们结合起来，希望能将它们的优点和缺点结合起来。为了解释这一假设特征，我&#39；我将把它分解为两种语言设计假设：</p><p> The  first hypothesis: statically declaring the list of possible exceptions which a function can throw, like Java&#39;s checked exceptions or C++ exception specifications, can be a good feature  so long as they can be optionally inferred and do not need to be explicitly listed by the programmer.</p><p>第一个假设：静态声明函数可以抛出的可能异常列表，比如Java&#39；S检查异常或C++异常规范，只要它们可以被推断，不需要由程序员明确列出，就可以是一个很好的特性。</p><p> The  second hypothesis: we can create an incredibly flexible and powerful error-handling mechanism by implementing a  statically typed inferred condition system inspired by Common Lisp&#39;s condition system, coupling static inference of error conditions with static inference of restarts.</p><p>第二个假设：我们可以通过实现一个受Common Lisp#39启发的静态类型推断条件系统，创建一个极其灵活和强大的错误处理机制；s条件系统，将错误条件的静态推断与重新启动的静态推断耦合起来。</p><p> The rest of this post will explain them in fragments. I should also note that this  all hypothetical: I haven&#39;t implemented this, and I don&#39;t believe  any programming language feature can be really justified until it has proven itself in at least medium-scale programs in its intended domain. (In fact, one of the features I&#39;m about to discuss seemed fine in tiny snippets and turned out to be abysmal in large programs.) That said, it&#39;s a hypothesis I&#39;d like to test, because I  suspect a feature like the one I&#39;m about to describe would be a tremendous boon to the kinds of programs and libraries that I usually write!</p><p>这篇文章的其余部分将以片段的形式解释它们。我还应该指出，这一切都是假设性的：我没有&#39；我没有实现这一点，我也没有&#39；I don’我不相信任何编程语言功能都是正当的，除非它在其预期领域的至少中等规模的程序中得到证明。（事实上，我将要讨论的一个特性在小片段中似乎很好，而在大型程序中却非常糟糕。）也就是说，它&#39；这是一个假设I&#39；我想测试一下，因为我怀疑有一个功能，比如我&#39；我将要描述的将是我通常编写的各种程序和库的一大福音！</p><p>  I think it&#39;s probably pretty uncontroversial to say that checked exceptions might sound appealing in theory but are downright miserable in practice. The idea is simple: you can statically verify that all error paths are checked if each method enumerates the exceptions that might be thrown. If I call a method  foo() that declares no exceptions, then I know for sure that I won&#39;t need to catch any of them! If I look in the source and see  foo() throws ThatException, then I know for sure that I might need to handle  ThatException! The compiler will yell at me if I don&#39;t do  something about  ThatException: I either need to explicitly catch it, or I need to explicitly pass it on by adding  throws ThatException to my method. I can sleep easy, knowing that all error paths are handled!</p><p>我觉得是&#39；如果说检查过的异常在理论上听起来可能很有吸引力，但在实践中却非常糟糕，这可能是相当无可争议的。想法很简单：如果每个方法都列举了可能引发的异常，那么可以静态地验证是否检查了所有错误路径。如果我调用一个没有声明任何异常的方法foo（），那么我肯定会赢&#39；我不需要抓住任何一个！如果我查看源代码，发现foo（）抛出了该异常，那么我肯定需要处理该异常！如果我不&#39；我不能对那个异常做些什么：我要么需要显式地捕捉它，要么需要通过向我的方法中添加抛出那个异常来显式地传递它。知道所有的错误路径都得到了处理，我可以轻松入睡！</p><p> …except, of course, now you need to copy-and-paste  throws ThatException again and again and again and again throughout your whole damn codebase, which is  ridiculously noisy and nobody wants to do it. (To say nothing of the half-dozen or more exceptions I might want to actually throw!) In practice, Java programmers have pretty universally found checked exceptions to be firmly Not Worth It: either they haphazardly toss the generic and unhelpful  throws Exception around all their methods, or they  catch any exception without bothering to discriminate in order to silence the warning, or they use runtime errors which don&#39;t need to be included in the type. Findings with large codebases have firmly indicated that exception specifications increase toil but don&#39;t significantly impact safety.</p><p>…当然，除了现在你需要在你的整个该死的代码库中一次又一次地复制和粘贴这个异常，这个代码库非常嘈杂，没有人愿意这么做。（更不用说我可能想要抛出的六个或更多例外了！）在实践中，Java程序员普遍认为检查异常绝对不值得：要么他们随意地在所有方法周围抛出泛型和无帮助的抛出异常，要么他们捕获任何异常而不费心辨别以消除警告，要么他们使用运行时错误，而这些错误不&#39；不需要包含在类型中。大型代码库的研究结果坚定地表明，异常规范会增加工作强度，但不会&#39；不会显著影响安全性。</p><p> But I suspect the problem isn&#39;t that they can&#39;t increase safety in some respects: the problem is that the amount of toil they cause is disproportionate to the safety you get, and in that they tend to push programmers to use them in ways which minimize the toil and therefore  also minimizes safety. So what if we got rid of the toil?</p><p>但我怀疑问题不在于&#39；他们不能&#39；t在某些方面提高安全性：问题在于，它们所造成的工作量与您所获得的安全性不成比例，而且它们往往会促使程序员以最小化工作量的方式使用它们，从而也会最小化安全性。那么，如果我们摆脱了辛劳呢？</p><p> Let&#39;s imagine a hypothetical programming language with exceptions: the syntax isn&#39;t important, so I&#39;m going to borrow a handwavey Rust-like syntax, but I shold be clear that all the examples below are imaginary and in a fictional non-Rust language. What I imagine here is that the default way of a method might look something like this:</p><p>让&#39；让我们设想一种假设的编程语言，但有例外：语法不是&#39；不重要，所以我&#39；我将借用handwavey Rust的语法，但我必须清楚，下面所有的例子都是虚构的，都是虚构的非锈语言。我在这里想象的是，方法的默认方式可能如下所示：</p><p> // an example function in a fictional languagefn find(haystack: String, needle: String) -&gt; Nat { // implementation elided}</p><p>//虚构语言fn find（haystack:String，needle:String）中的一个函数示例&gt；Nat{//implementation elided}</p><p>  Ah, but there&#39;s nothing in that snippet that mentions exceptions, right? In our hypothetical language, that doesn&#39;t mean it  won&#39;t throw an exception: instead, that means it&#39;s allowed to throw any exception! However, the compiler can infer which exceptions it  might throw, and it shouldn&#39;t be hard to compute: simply accumulate any uncaught exception thrown in the method body or any uncaught exception thrown by a method which is called in the method body. If I asked the compiler for the type of  find here, it might tell me a type like</p><p>啊，但是有&#39；这段话里没有提到例外，对吧？在我们假设的语言中，这并不意味着&#39；不是说它赢了&#39；t抛出异常：相反，这意味着它&#39；允许抛出任何异常！然而，编译器可以推断它可能抛出哪些异常，并且它不应该&#39；不难计算：只需累积方法体中抛出的任何未捕获异常或方法体中调用的方法抛出的任何未捕获异常。如果我向编译器询问find的类型，它可能会告诉我</p><p>  So that means the compiler is well aware that  find might throw an exception, and in fact knows what exception it might throw. Anything which uses  find now can be aware that it might throw  SubstringNotFound. That means that, in this hypothetical language, we can write something like</p><p>这意味着编译器很清楚find可能会抛出异常，并且实际上知道它可能抛出什么异常。使用find now的任何东西都可以知道它可能会抛出SubstringNotFound。这意味着，在这个假设的语言中，我们可以写</p><p>  And  now we&#39;ve given our compiler license to yell at us: we&#39;ve claimed that  example throws no exceptions, but because we&#39;re using  find, the compiler can correctly point out that we haven&#39;t handled  SubstringNotFound. Just like in Java, we&#39;ve got two basic options—either catching  SubstringNotFound in the body of  example, or adding  SubstringNotFound to the list of exceptions thrown—but we&#39;ve also got a third, substantially more terse option: we can wholly remove  throws () and allow it to infer for us whatever it wants to. We can add the specification  if we care but otherwise let the compiler handle the rest.</p><p>现在我们&#39；we&#39；我声称这个例子没有例外，但因为我们&#39；重新使用find，编译器可以正确地指出我们没有&#39；未找到处理过的子字符串。就像在爪哇一样，我们&#39；我们有两个基本选项，要么捕获示例主体中的SubstringNotFound，要么将SubstringNotFound添加到抛出的异常列表中，但我们&#39；我们还有第三个更简洁的选择：我们可以完全删除throws（）并允许它为我们推断出它想要的任何东西。如果我们愿意的话，我们可以添加规范，但其他的则由编译器来处理。</p><p> I think there&#39;s also more that can be done around expressivity here. For example, perhaps a programmer could choose to explicitly include an exception in the list: a type like  fn example() -&gt; Nat throws (SomeException, ...) would mean, “Whatever the compiler infers for the method body here, but it can also throw  SomeException even if the compiler didn&#39;t infer that one.” One situation you might want this is when prototyping an API: perhaps I know that my API might  eventually throw  CacheMissException, but I haven&#39;t wired up the cache yet, so I&#39;m going to make sure I include that in my type signatures in the appropriate places just in case, and elsewhere use  throws () to make sure I handle it in places where I need to.</p><p>我认为有&#39；这里还有更多关于表现力的内容。例如，程序员可能会选择在列表中显式地包含一个异常：一个类型，比如fn example（）-&gt；Nat抛出（某个异常，…）这意味着，“无论编译器在这里为方法体推断出什么，但它也可以抛出一些异常，即使编译器没有推断出该异常。”有一种情况你可能希望这样做，那就是在原型化一个API时：也许我知道我的API最终可能会抛出CacheMissException，但我没有&#39；我还没把缓存连接好，所以我&#39；我要确保在我的类型签名中，在适当的地方包括它，以防万一，在其他地方使用throws（）来确保我在需要的地方处理它。</p><p> More usefully, though, I can imagine a syntax for ensuring that specific exceptions  aren&#39;t included in the inferred type. In this case, a type like  fn example() -&gt; Nat throws (!OtherException, ...) would mean, “This throws whatever the compiler infers for the body, but if that inferred set includes  OtherException then raise a compile error.” This means you don&#39;t need to regularly re-write the set of exceptions for a complicated API which might throw a dozen different specific errors, but you  could still say, “I don&#39;t want this specific exception to escape, so keep me honest: if  example() ever tries to throw  OtherException, then yell at me about it.”</p><p>不过，更有用的是，我可以想象一种语法来确保特定的异常不会出现&#39；t包含在推断类型中。在本例中，像fn example（）这样的类型-&gt；Nat抛出（！OtherException，…）这意味着，“这会抛出编译器为主体推断的任何内容，但如果推断集包含OtherException，则会引发编译错误。”这意味着你没有&#39；不需要为一个复杂的API定期重新编写异常集，它可能会抛出十几个不同的特定错误，但你仍然可以说，“我不希望这个特定的异常逃逸，所以请告诉我实话：如果example（）试图抛出其他异常，那么就对我大喊大叫。”</p><p> In fact, I can imagine wanting to implement this in a way where exception lists, even empty ones like  (), will actually implicitly include pervasive “existential” exceptions: for example, exceptions that represent signals like  SIGKILL or exceptions that get raised when the process runs out of memory. In that case,  fn foo() throws () would be a convenient fiction, because it won&#39;t force the programmer to handle out-of-memory errors, but a programmer could write  fn foo() throws (!OutOfMemory) to indicate that  foo not only doesn&#39;t throw any user-written or typical stdlib exceptions, it also promises to handle out-of-memory exceptions that bubbled up from within it. A typical program probably would still probably define  fn main() throws (), but a server that&#39;s intended to be long-lived might define  fn main() throws (!OutOfMemory, !Sigkill) so that the compiler can let you know when you&#39;ve failed to handle those error conditions.</p><p>事实上，我可以想象，想要以一种方式实现这一点，异常列表，即使是像（）这样的空列表，实际上也会隐式地包含普遍存在的“存在”异常：例如，表示SIGKILL之类信号的异常，或者在进程耗尽内存时引发的异常。在这种情况下，fn foo（）抛出（）将是一个方便的小说，因为它赢得了&#39；不要强迫程序员处理内存不足错误，但是程序员可以编写fn foo（）throws（！OutOfMemory）来表示foo不仅没有&#39；它不会抛出任何用户编写的或典型的stdlib异常，它还承诺处理从内部冒出的内存不足异常。一个典型的程序可能仍然会定义fn main（）throws（），但服务器&#39；可能会定义fn main（）抛出（！OutOfMemory，！Sigkill），这样编译器就可以在&#39；我们无法处理这些错误情况。</p><p> I haven&#39;t implemented this in any language, so it&#39;s quite possible it&#39;d still have problems. And I&#39;ve handwaved away a number of issues that I haven&#39;t tried to solve. For example, I haven&#39;t tried fully articulating the typing rules for higher-order functions, or how this would interact with typeclasses, or how the compilation model will work: there&#39;s a lot to be done, and it might require other limitations or compromises or heuristics in practice. But my  hypothesis is that a feature such as this would let people use checked exceptions in a way that includes minimal overhead, allowing programmers to opt-in to useful checks but also get out of their way when it&#39;s not useful.</p><p>我没有&#39；我没有用任何语言实现这一点，所以它&#39；很可能是&#39；我仍然有问题。而我&#39；我已经解决了一些我没有解决的问题&#39；我没有试图解决这个问题。例如，我没有&#39；t试图充分阐明高阶函数的类型规则，或者这将如何与类型类交互，或者编译模型将如何工作：there&#39；还有很多工作要做，在实践中可能需要其他限制、妥协或启发。但我的假设是，这样的功能可以让人们以一种包含最小开销的方式使用检查过的异常，允许程序员选择使用有用的检查，但也可以在检查时避开它们&#39；这没用。</p><p>  I said there was another part of my hypothesis, and to explain that I&#39;ll have to talk about Common Lisp&#39;s condition system. Let&#39;s start with exceptions and describe in fine detail how they work, because that&#39;ll help us understand how conditions differ.</p><p>我说我的假设还有另一部分，并解释我&#39；我得谈谈常见的Lisp&#39；s条件系统。让&#39；让我们从例外开始，详细描述它们是如何工作的，因为&#39；我们将帮助我们了解情况的不同。</p><p> In a language with exceptions, you signal the existence of an error by you constructing a “thing” called an  exception, which is usually a value of a specific type. In languages with inheritance these are often values that inherit from a specific base class (although not always—Ruby, for example, allows any value to be thrown) and in languages without inheritance they usually have some kind of error-specific tag (e.g. in Haskell or various ML languages.) These values can be “raised” or “thrown”. When an exception is “raised”, the language runtime will begin to walk up the stack, freeing stack frames as it goes, until it finds a “handler”, a bit of code which matches the appropriate exception type or tag and is attached to a block of error-handling code. If it fails to find a handler, the runtime will usually terminate the program and print a relevant message. If it  does find a handler, it resumes from that point, providing the exception to that bit of code.</p><p>在一种有异常的语言中，你通过构造一个叫做异常的“东西”来表示错误的存在，异常通常是一个特定类型的值。在具有继承性的语言中，这些值通常是从特定基类继承的（尽管Ruby并不总是允许抛出任何值），而在没有继承性的语言中，它们通常具有某种特定于错误的标记（例如在Haskell或各种ML语言中）这些值可以“提升”或“抛出”。当一个异常被“引发”时，语言运行库将开始沿着堆栈向上移动，在移动过程中释放堆栈帧，直到它找到一个“处理程序”，一个与适当的异常类型或标记匹配的代码位，并附加到一个错误处理代码块上。如果找不到处理程序，运行时通常会终止程序并打印相关消息。如果它确实找到了一个处理程序，它将从该点恢复，为该代码位提供异常。</p><p> This is a widely-used mechanism for errors: so much so, in fact, that it can be hard to imagine alternatives. What else  could you do? What else would you want out of it?</p><p>这是一种被广泛使用的错误机制：事实上，这一机制如此之多，以至于很难想象替代方案。你还能做什么？你还想从中得到什么？</p><p> I&#39;m going to steal an example from  Peter Seibel&#39;s  Practical Common Lisp as motivation, but rewrite it in a curly-bracket syntax for people who aren&#39;t as comfortable with Lisp. Imagine that I&#39;m writing a library which is parsing log files in a particular format. I have a function called  parse_log_entry which takes a fragment of text and produces a log entry. Say I&#39;ve written it like this:</p><p>我&#39；我要从彼得·塞贝尔那里偷一个例子&#39；这是一个实用的通用Lisp作为动机，但是对于那些没有&#39；我不喜欢口齿不清。想象一下我&#39；我正在写一个库，它正在解析特定格式的日志文件。我有一个名为parse_log_entry的函数，它获取一段文本并生成一个日志条目。说我&#39；我是这样写的：</p><p> fn parse_log_entry(text: String) -&gt; LogEntry { if (is_well_formed(text)) { return LogEntry::from_text(text); } else { raise MalformedLogEntry(text); }}</p><p>fn解析日志条目（文本：字符串）->；LogEntry{if（格式良好（文本））{return LogEntry:：from_text（文本）；}else{raise morformedlogentry（text）；}</p><p> Now the library is about parsing whole log files, so I also expose a function to parse an entire file like this:</p><p>现在这个库是关于解析整个日志文件的，所以我还公开了一个函数来解析整个文件，如下所示：</p><p> fn parse_log_file(f: File) -&gt; List&lt;LogEntry&gt; { let mut list = List::new(); for ln in f.read_lines() { list.append(parse_log_entry(ln)); } list}</p><p>fn解析日志文件（f:file）-&gt；列表&lt；登录&gt；{let mut list=list:：new（）；for ln in f.read_lines（）{list.append（parse_log_entry（ln））；}列表}</p><p> This is nice and simple! Unfortunately, if a single entry fails to parse, we&#39;ll throw a  MalformedLogEntry exception and lose access to the whole log parsed so far! In some applications, maybe that&#39;s fine, but I&#39;ve said we&#39;re writing a  library, and we want it to be as flexible as possible for an eventual user. Perhaps a user of the library would like us to put a special kind of  LogEntry value that represents a malformed entry instead? We could write something like this:</p><p>这很好也很简单！不幸的是，如果一个条目无法解析，我们&#39；我将抛出一个格式错误的Genetry异常，并失去对迄今为止分析的整个日志的访问权限！在某些应用中，可能是&#39；很好，但我&#39；我说过我们&#39；我们正在编写一个库，我们希望它对最终用户来说尽可能灵活。也许库的用户希望我们使用一种特殊的LogEntry值来表示格式错误的条目？我们可以这样写：</p><p> fn parse_log_file(f: File) -&gt; List&lt;LogEntry&gt; { let mut list = List::new(); for ln in f.read_lines() { try { list.append(parse_log_entry(ln)) } catch (exn: MalformedLogEntry) { list.append(bad_log_entry()) } } list}</p><p>fn解析日志文件（f:file）-&gt；列表&lt；登录&gt；{let mut list=list:：new（）；for ln in f.read_line（）{try{list.append（parse_log_entry（ln））}catch（exn:MalformedLogEntry）{list.append（bad_log_entry（））}list}</p><p> Now we handle that error gracefully. But now we&#39;re assuming that&#39;s how the user wants us to handle that error. Maybe the user wants us to quietly skip that entry instead! We can write that, too:</p><p>现在我们优雅地处理这个错误。但现在我们&#39；我们假设&#39；这就是用户希望我们处理错误的方式。也许用户希望我们悄悄地跳过这个条目！我们也可以这样写：</p><p> fn parse_log_file(f: File) -&gt; List&lt;LogEntry&gt; { let mut list = List::new(); for ln in f.read_lines() { try { list.append(parse_log_entry(ln)) } catch (_exn: MalformedLogEntry) { // do nothing } } list}</p><p>fn解析日志文件（f:file）-&gt；列表&lt；登录&gt；{let mut list=list:：new（）；for ln in f.read_line（）{try{list.append（parse_log_entry（ln））}catch（_exn:MalformedLogEntry）{//do nothing}list}</p><p> But what if they want us to skip them but write the errors to stdout? Or to a specific logger? Or apply a correction heuristic and try parsing the line again? Or…</p><p>但如果他们想让我们跳过它们，但将错误写入stdout呢？还是特定的记录器？或者应用一个修正启发式，然后再次尝试解析该行？或者…</p><p> Okay, library design is hard, and designing libraries which handle errors in every possible way is  really hard. One approach here might be to provide all these as options which can be chosen by the library user. Maybe we expose different methods to the user which each implement different versions of these strategies, like  parse_log_file_with_default versus  parse_log_file_skip_bad. Maybe we provide one function with lots of optional parameters, like  parse_log_file(with_default: ..., skip_invalid: ...). Maybe we just throw our hands in the air and choose one we think is sensible: convention over configuration, right?</p><p>好吧，库的设计很难，而设计能够以各种可能的方式处理错误的库真的很难。这里的一种方法可能是提供所有这些选项，供图书馆用户选择。也许我们向用户公开了不同的方法，每个方法都实现了这些策略的不同版本，比如使用默认值解析日志文件与跳过坏文件解析日志文件。也许我们提供了一个带有许多可选参数的函数，比如parse_log_file（默认值为：…，跳过无效值为：…）。也许我们只是把手举在空中，然后选择一个我们认为合理的：常规而非配置，对吗？</p><p> On the other hand, if we had a  condition system, we would have a  really powerful way of allowing the user to choose any of these and more without having to significantly change our interface. What a condition system does is separate out two different concerns that get conflated by exception-handling:  what error recovery code does and  what error recovery code should be invoked. To begin with, instead of an exception handler, we install what&#39;s called a  restart and give it a name: this is how we define our recovery code that might run after an error is raised, but it does  not guarantee that the error-handling code associated with the restart is actually run. In this case, let&#39;s start with logic around skipping entries:</p><p>另一方面，如果我们有一个条件系统，我们将有一个非常强大的方式，允许用户选择其中任何一个或更多，而不必大幅改变我们的界面。条件系统所做的是分离出两个因异常处理而混淆的不同关注点：错误恢复代码的作用和应该调用的错误恢复代码。首先，我们不安装异常处理程序，而是安装什么&#39；它被称为重启，并给它起了一个名字：这就是我们如何定义在引发错误后可能运行的恢复代码，但它不能保证与重启相关的错误处理代码实际运行。在这种情况下，让&#39；让我们从跳过条目的逻辑开始：</p><p> fn parse_log_file(f: File) -&gt; List&lt;LogEntry&gt; { let mut list = List::new(); for ln in f.read_lines() { try { list.append(parse_log_entry(ln)) } restart SkipEntry { // do nothing } } list}</p><p>fn解析日志文件（f:file）-&gt；列表&lt；登录&gt；{let mut list=list:：new（）；for ln in f.read_lines（）{try{list.append（parse_log_entry（ln））}重新启动SkipEntry{//do nothing}}list}</p><p> This  restart block represents a possible recovery strategy in the presence of an error, and  SkipError is the name we&#39;ve given it. However, we&#39;re still missing something: we haven&#39;t actually told our program to  use it. Our library shouldn&#39;t be the one to make that choice, so let&#39;s imagine that we&#39;re calling the  parse_log_file library function from some application code. We now tell our application code to  handle a condition by invoking the  restart we&#39;ve defined:</p><p>此重启块代表出现错误时可能的恢复策略，Skiperor是we&#39；我已经给了。然而，我们&#39；我们仍然缺少一些东西：我们没有&#39；我没有告诉我们的程序使用它。我们的图书馆应该&#39；I don’我不是做出这个选择的人，所以让&#39；让我们想象一下&#39；从一些应用程序代码中重新调用parse_log_file library函数。现在，我们告诉应用程序代码通过调用restart We&#39；我定义了：</p><p> fn analyze_log() -&gt; List&lt;LogEntry&gt; { try { parse_log_file(File::open(&#34;my_log.txt&#34;)) } handle { MalformedLogEntry(_) =&gt; restart SkipEntry, }}</p><p>fn analyze_log（）-&gt；列表&lt；登录&gt；{试试{parse_log_file（file:：open（&#34；my_log.txt&#34；）}句柄{MalformedLogEntry（）=&gt；restart skippentry，}</p><p> This is where I&#39;m telling the program  which piece of recovery code to use. What I&#39;m saying is, “If we ever come across a situation where our code has produced a  MalformedLogEntry, then recover from that by finding the recovery path labeled with  SkipEntry and restart from there.”</p><p>这就是我&#39；我告诉程序使用哪段恢复代码。我&#39；我的意思是，“如果我们遇到代码产生了错误的生成，那么通过找到标记为SkipEntry的恢复路径并从那里重新启动来恢复。”</p><p> So far we&#39;ve only defined that one recovery path. Let&#39;s revisit  parse_log_entry and add a few more strategies we might use to recover from an error within that function. Unlike  SkipEntry above, these also take parameters, which are pieces of information that the handler can supply in the  handle blocks:</p><p>到目前为止，我们&#39；我只定义了一条恢复路径。让&#39；我们将重新访问parse_log_条目，并添加一些可能用于从该函数中的错误中恢复的策略。与上面的SkipEntry不同，它们还接受参数，这些参数是处理程序可以在句柄块中提供的信息片段：</p><p> fn parse_log_entry(text: String) -&gt; LogEntry { if (is_well_formed(text)) { return LogEntry::from_text(text); } else { try { raise MalformedLogEntry(text); } restart UseValue(v: LogEntry) { return v; } restart RetryParse(new_text: String) { return parse_log_entry(new_text); } }}</p><p>fn解析日志条目（文本：字符串）->；LogEntry{if（格式良好（文本））{return LogEntry:：from_text（文本）；}否则{try{raise morformedlogentry（text）；}重新启动UseValue（v:LogEntry）{return v；}重新启动RetryParse（new_text:String）{return parse_log_entry（new_text）；}}</p><p> Now we have a total of three possible ways to recover from a  MalformedLogEntry: we can invoke the  SkipEntry restart which will simply skip past malformed lines, we can use the  UseValue restart with a value of type  LogEntry to replace the bad log with a different provided one, or we can use the  RetryParse restart to supply a new corrected string and attempt the parsing again.</p><p>现在我们总共有三种可能的方法来从错误的生成中恢复：我们可以调用SkipEntry重新启动，它只会跳过错误的行，我们可以使用带有LogEntry类型的值的UseValue重新启动来用提供的不同日志替换坏日志，或者，我们可以使用RetryParse重新启动来提供一个新的已更正字符串，然后再次尝试解析。</p><p> The important thing now is that the library allows all of these restarts to exist simultaneously, but  does not specify which to take: that&#39;s up to the calling code. Let&#39;s change our application code to supply  bad_log_entry() as a default value instead; this means an application will still include as many  LogEntry values as we had lines, but some are specifically represented as bad ones:</p><p>现在重要的是，库允许所有这些重启同时存在，但没有指定要执行哪些重启：即&#39；这取决于呼叫代码。让&#39；让我们更改应用程序代码，将bad_log_entry（）作为默认值提供；这意味着一个应用程序仍将包含与我们的行一样多的日志条目值，但有些特定地表示为坏值：</p><p> fn analyze_log() -&gt; List&lt;LogEntry&gt; { try { parse_log_file(File::open(&#34;my_log.txt&#34;)) } handle { MalformedLogEntry(_) =&gt; restart UseEntry(bad_log_entry()), }}</p><p>fn analyze_log（）-&gt；列表&lt；登录&gt；{试试{parse_log_file（file:：open（&#34；my_log.txt&#34；）}句柄{MalformedLogEntry（）=&gt；重新启动UseEntry（bad_log_entry（）），}</p><p> What if we want to skip the bad ones but still record that we saw them by printing messages to our logger? We can use  SkipEntry with some extra handler code, then:</p><p>如果我们想跳过那些不好的，但仍然通过向日志记录程序打印消息来记录我们看到的，该怎么办？我们可以使用SkipEntry和一些额外的处理程序代码，然后：</p><p> fn analyze_log() -&gt; List&lt;LogEntry&gt; { try { parse_log_file(File::open(&#34;my_log.txt&#34;)) } handle { MalformedLogEntry(text) =&gt; { logger.log(&#34;Found bad log entry: `{}`&#34;, text); restart SkipEntry; } }}</p><p>fn analyze_log（）-&gt；列表&lt；登录&gt；{试试{parse_log_file（file:：open（&#34；my_log.txt&#34；）}句柄{MalformedLogEntry（text）=&gt；{logger.log（&#34；发现错误的日志条目：`{}`&#34；，text）；重新启动SkipEntry；}}}</p><p> What if we want to try applying a correction heuristic to the first several errors that we see, but exit the program if we see more than an pre-determined “allowable” amount of bad errors? We can use shared state in our handler and the  RetryParse restart:</p><p>如果我们想尝试对我们看到的前几个错误应用修正启发，但如果我们看到的错误超过预先确定的“允许”数量，就退出程序，该怎么办？我们可以在处理程序和RetryParse重新启动中使用共享状态：</p><p> fn analyze_log() -&gt; List&lt;LogEntry&gt; { let mut errors = 0; try { parse_log_file(File::open(&#34;my_log.txt&#34;)) } handle { MalformedLogEntry(text) =&gt; { if (errors &lt; ALLOWED_LOG_ERRORS) { errors += 1; restart RetryParse(try_correction(text)); } else { logger.log(&#34;Encountered too many bad log entries; exiting&#34;); system.exit(1); } } }}</p><p>fn analyze_log（）-&gt；列表&lt；登录&gt；{let mut errors=0；尝试{parse_log_file（file:：open（&#34；my_log.txt&#34；）}处理{MalformedLogEntry（文本）=&gt；{if（errors&lt；ALLOWED_LOG_errors）{errors+=1；重新启动RetryParse（try_correction（文本））；}else{logger.log（&#34；遇到太多错误的日志条目；正在退出&#34；）；系统退出（1）；}}}</p><p> Admittedly, this system is definitely more fiddly than exception-handling: you&#39;ve got more moving parts, what with the error conditions (which in this example we had only one of)  plus the named error restarts  plus the handler logic. (I suspect this is one reason why language designers haven&#39;t bothered porting this into new languages, preferring simpler exception-based errors or explicit result types instead.) But the separation can be incredibly powerful: we no longer need to manually thread state through our API; instead, our API is designed for the “happy path”, but errors can still be handled in a granular way, and what&#39;s more, the application has full control over how those errors get handled. Breaking up strategies for error recovering (as named restarts) from how to  actually handle errors (as handler strategies) allows for some incredibly simple but powerful API designs.</p><p>诚然，这个系统肯定比异常处理更精细：你&#39；我们得到了更多的移动部件，包括错误条件（在本例中，我们只有一个）加上命名的错误重启加上处理程序逻辑。（我怀疑这就是为什么语言设计师没有费心将其移植到新语言中的原因之一，而是更喜欢基于异常的简单错误或显式结果类型。）但这种分离可能非常强大：我们不再需要通过API手动执行线程状态；相反，我们的API是为“快乐之路”而设计的，但错误仍然可以以细粒度的方式处理，还有什么&#39；此外，应用程序可以完全控制如何处理这些错误。将错误恢复策略（称为重新启动）从如何实际处理错误（称为处理程序策略）中分离出来，可以实现一些非常简单但功能强大的API设计。</p><p>  Okay, so let&#39;s put these together. The last section glossed over types, and for good reason: in Common Lisp, there aren&#39;t types for restarts. In fact, it&#39;s possible for a handler to specify a restart which doesn&#39;t exist, in which case it&#39;ll produce a  different kind of error (a  CONTROL-ERROR in Common Lisp parlance) because it wasn&#39;t able to find the place where code should resume.</p><p>好吧，让&#39；让我们把这些放在一起。最后一节讨论了类型，理由很充分：在Common Lisp中，没有&#39；t类型用于重新启动。事实上，它&#39；处理程序可能会指定一个不&#39；不存在，在这种情况下它&#39；我会产生另一种错误（用Lisp的说法是控制错误），因为它不是&#39；无法找到代码应该恢复的位置。</p><p> But we could build a statically typed language that implements a condition system, so that the compiler could reject programs which catch non-existent errors or try to resume from non-existent restarts (or supply those restarts with values of the wrong type.) Yet again, the way I&#39;d propose doing this is by allowing errors—or conditions, to use the Common Lisp terminology—but  also restar</p><p>但我们可以构建一种实现条件系统的静态类型语言，这样编译器就可以拒绝捕获不存在的错误的程序，或者尝试从不存在的重新启动中恢复（或者为这些重新启动提供错误类型的值）再一次，我&#39；d建议这样做是通过允许错误或条件，使用常见的Lisp术语，但也可以重新启动</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/条件/">#条件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/typed/">#typed</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>