<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>木偶：无障碍-第一个木偶脚本</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">木偶：无障碍-第一个木偶脚本</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 08:56:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/665bfd348d7a78912cc2d3e0c6d5fd94.png"><img src="http://img2.diglog.com/img/2020/11/665bfd348d7a78912cc2d3e0c6d5fd94.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Puppeteer is a browser automation library for Node: it lets you control a browser using a simple and modern JavaScript API.</p><p>Pupeteer是Node的浏览器自动化库：它允许您使用简单而现代的JavaScript API控制浏览器。</p><p> The most prominent browser task is, of course, browsing web pages. Automating this task essentially amounts to automating interactions with the webpage.</p><p>当然，最突出的浏览器任务是浏览网页。自动执行此任务实质上等同于自动执行与网页的交互。</p><p> In Puppeteer, this is achieved by querying for DOM elements using string-based selectors and performing actions such as clicking or typing text on the elements. For example, a script that opens opens  developer.google.com, finds the search box, and searches for  puppetaria could look like this:</p><p>在Puppeteer中，这是通过使用基于字符串的选择器查询DOM元素并执行诸如在元素上单击或键入文本等操作来实现的。例如，打开developer.google.com、找到搜索框并搜索puppetaria的脚本可能如下所示：</p><p> (async () =&gt; { const browser = await puppeteer.launch({ headless: false }); const page = await browser.newPage(); await page.goto(&#39;https://developers.google.com/&#39;, { waitUntil: &#39;load&#39; }); // Find the search box using a suitable CSS selector. const search = await page.$(&#39;devsite-search &gt; form &gt; div.devsite-search-container&#39;); // Click to expand search box and focus it. await search.click(); // Enter search string and press Enter. await search.type(&#39;puppetaria&#39;); await search.press(&#39;Enter&#39;); })();</p><p>(async()=&gt；{const Browser=await puppeteer.unch({Headless：False})；const page=aWait Browser.newPage()；await page.goto(&#39；https://developers.google.com/&#39；，{waitUntil：&#39；Load&#39；})；//使用合适的css选择器查找搜索框。Const search=等待页面。$(&#39；devsite-search&gt；form&gt；div.devsite-search-tainer&#39；)；//单击以展开搜索框并将其聚焦。等待搜索。点击()；//输入搜索字符串并按Enter键。等待搜索。type(&#39；Pppetaria)；等待搜索。按(#39；Enter；)；})()；</p><p> How elements are identified using query selectors is therefore a defining part of the Puppeteer experience. Until now, selectors in Puppeteer have been limited to CSS and XPath selectors which, albeit expressionally very powerful, can have drawbacks for persisting browser interactions in scripts.</p><p>因此，如何使用查询选择器识别元素是Puppeteer体验的重要组成部分。到目前为止，Puppeteer中的选择器仅限于CSS和XPath选择器，尽管这两种选择器在表达上非常强大，但在脚本中持久保存浏览器交互方面可能存在缺陷。</p><p>  CSS selectors are syntactic in nature; they are tightly bound to the inner workings of the textual representation of the DOM tree in the sense that they reference IDs and class names from the DOM. As such, they provide an integral tool for web developers for modifying or adding styles to an element in a page, but in that context the developer has full control over the page and its DOM tree.</p><p>CSS选择器本质上是语法的；它们与DOM树的文本表示的内部工作紧密绑定，因为它们引用了DOM中的ID和类名。因此，它们为Web开发人员提供了一个完整的工具，用于修改或添加样式到页面中的元素，但在这种情况下，开发人员可以完全控制页面及其DOM树。</p><p> On the other hand, a Puppeteer script is an external observer of a page, so when CSS selectors are used in this context, it introduces hidden assumptions about how the page is implemented which the Puppeteer script has no control over.</p><p>另一方面，Puppeteer脚本是页面的外部观察者，因此当在此上下文中使用CSS选择器时，它引入了Puppeteer脚本无法控制的有关页面如何实现的隐藏假设。</p><p> The effect is that such scripts can be brittle and susceptible to source code changes. Suppose, for example, that one uses Puppeteer scripts for automated testing for a web application containing the node  &lt;button&gt;Submit&lt;/button&gt; as the third child of the  body element. One snippet from a test case might look like this:</p><p>其结果是，这样的脚本很脆弱，很容易受到源代码更改的影响。例如，假设您使用Puppeteer脚本对一个Web应用程序进行自动化测试，该Web应用程序包含节点&lt；Button&gt；作为Body元素的第三个子节点。测试用例中的一段代码可能如下所示：</p><p>  Here, we are using the selector  &#39;body:nth-child(3)&#39; to find the submit button, but this is tightly bound to exactly this version of the webpage. If an element is later added above the button, this selector no longer works!</p><p>在这里，我们使用选择器Body：nth-Child(3)&39；来查找提交按钮，但它与这个版本的网页紧密绑定。如果稍后在按钮上方添加了元素，则此选择器将不再起作用！</p><p> This is not news to test writers: Puppeteer users already attempt to pick selectors that are robust to such changes. With Puppetaria, we give users a new tool in this quest.</p><p>这对测试编写者来说并不是什么新鲜事：木偶师用户已经在尝试挑选对这种变化很健壮的选择器。有了Puppetaria，我们为用户提供了一种新的工具。</p><p> Puppeteer now ships with an  alternative query handler based on querying the accessibility tree rather than relying on CSS selectors. The underlying philosophy here is that if the concrete element we want to select has not changed, then the corresponding accessibility node should not have changed either.</p><p>Pupeteer现在提供了一个基于查询可访问性树的替代查询处理程序，而不是依赖于CSS选择器。这里的基本原理是，如果我们要选择的具体元素没有更改，那么相应的可访问性节点也不应该更改。</p><p> We name such selectors “ ARIA selectors” and support querying for the computed accessible name and role of the accessibility tree. Compared to the CSS selectors, these properties are semantic in nature. They are not tied to syntactic properties of the DOM but instead descriptors for how the page is observed through assistive technologies such as screen readers.</p><p>我们将这样的选择器命名为“ARIA选择器”，并支持查询计算出的可访问性树的可访问名称和角色。与CSS选择器相比，这些属性本质上是语义的。它们与DOM的语法属性无关，而是描述如何通过屏幕阅读器等辅助技术观察页面。</p><p> In the test script example above, we could instead use the selector  aria/Submit[role=&#34;button&#34;] to select the wanted button, where  Submit refers to the accessible name of the element:</p><p>在上面的测试脚本示例中，我们可以使用选择器aria/Submit[Role=&#34；Button&#34；]来选择所需的按钮，其中Submit指的是元素的可访问名称：</p><p>  Now, if we later decide to change the text content of our button from  Submit to  Done the test will again fail, but in this case that is desirable; by changing the name of the button we change the page&#39;s content, as opposed to its visual presentation or how it happens to be structured in the DOM. Our tests should warn us about such changes to ensure that such changes are intentional.</p><p>现在，如果我们稍后决定将按钮的文本内容从Submit更改为Done，测试将再次失败，但在这种情况下，这是可取的；通过更改按钮的名称，我们更改了页面的内容，而不是它的可视表示形式或它恰好在DOM中的结构。我们的测试应该对这些变化发出警告，以确保这些变化是有意的。</p><p> Going back to the larger example with the search bar, we could leverage the new  aria handler and replace</p><p>返回到搜索栏的较大示例，我们可以利用新的aria处理程序替换。</p><p>     More generally, we believe that using such ARIA selectors can provide the following benefits to Puppeteer users:</p><p>更广泛地说，我们认为使用这样的ARIA选择器可以为Puppeteer用户提供以下好处：</p><p>  The rest of this article dives into the details on how we implemented the Puppetaria project.</p><p>本文的其余部分将深入讨论我们如何实现Puppetaria项目的细节。</p><p>   As motivated above, we want to enable querying elements by their accessible name and role.These are properties of the  accessibility tree, a dual to the usual DOM tree, that is used by devices such as screen readers to show webpages.</p><p>如上所述，我们希望能够通过元素的可访问名称和角色来查询元素。这些都是可访问性树的属性，这是通常的DOM树的双重属性，屏幕阅读器等设备使用它来显示网页。</p><p> From looking at the specification for  computing the accessible name, it is clear that computing the name for an element is a non-trivial task, so from the beginning we decided that we wanted to reuse Chromium’s existing infrastructure for this.</p><p>从计算可访问名称的规范来看，很明显，计算元素的名称不是一项简单的任务，所以我们从一开始就决定重用Chromium的现有基础设施来实现这一点。</p><p>  Even limiting ourselves to using Chromium’s accessibility tree, there are quite a few ways that we could implement ARIA querying in Puppeteer. To see why, let’s first see how Puppeteer controls the browser.</p><p>即使仅限于使用Chromium的可访问性树，也有很多方法可以在Puppeteer中实现ARIA查询。要了解原因，首先让我们看看Puppeteer是如何控制浏览器的。</p><p> The browser exposes a debugging interface via a protocol called the  Chrome DevTools Protocol (CDP). This exposes functionality such as &#34;reload the page&#34; or &#34;execute this piece of JavaScript in the page and hand back the result&#34; via a language-agnostic interface.</p><p>浏览器通过称为Chrome DevTools协议(CDP)的协议公开调试界面。这将公开诸如重新加载页面或在页面中执行这段JavaScript并通过与语言无关的界面返回结果等功能。</p><p> Both the DevTools front-end and Puppeteer are using CDP to talk to the browser. To implement CDP commands, there is DevTools infrastructure inside all components of Chrome: in the browser, in the renderer, and so on. CDP takes care of routing the commands to the right place.</p><p>DevTools前端和Puppeteer都使用CDP与浏览器通信。要实现CDP命令，Chrome的所有组件中都有DevTools基础设施：在浏览器、渲染器等中。CDP负责将命令路由到正确的位置。</p><p> Puppeteer actions such as querying, clicking, and evaluating expressions are performed by leveraging CDP commands such as  Runtime.evaluate that evaluates JavaScript directly in the page context and hands back the result. Other Puppeteer actions such as emulating color vision deficiency, taking screenshots, or capturing traces use CDP to communicate directly with the Blink rendering process.</p><p>操纵者的操作(如查询、单击和计算表达式)是通过利用CDP命令(例如直接在页面上下文中计算JavaScript并返回结果的Runme.valuate)来执行的。其他木偶操作(如模拟色觉缺陷、截屏或捕捉痕迹)使用CDP直接与Blink呈现进程通信。</p><p>   Write our querying logic in JavaScript and have that injected into the page using  Runtime.evaluate, or</p><p>用JavaScript编写我们的查询逻辑，并使用Runtime.valuate将其注入到页面中，或者</p><p> Use a CDP endpoint that can access and query the accessibility tree directly in the Blink process.</p><p>使用可以在闪烁过程中直接访问和查询辅助功能树的CDP端点。</p><p>  Puppeteer AXTree traversal - based on using the existing CDP access to the accessibility tree</p><p>木偶人AXTree遍历-基于使用现有CDP访问可访问性树。</p><p> CDP DOM traversal - using a new CDP endpoint purpose-built for querying the accessibility tree</p><p>CDP DOM遍历-使用专门为查询可访问性树而构建的新CDP端点。</p><p>  This prototype does a full traversal of the DOM and uses  element.computedName and  element.computedRole, gated on the   ComputedAccessibilityInfo launch flag, to retrieve the name and role for each element during the traversal.</p><p>此原型对DOM进行完全遍历，并使用由ComputedAccessibilityInfo启动标志控制的element.cultedName和element.cultedRole在遍历过程中检索每个元素的名称和角色。</p><p>  Here, we instead retrieve the full accessibility tree through CDP and traverse it in Puppeteer. The resulting accessibility nodes are then mapped to DOM nodes.</p><p>这里，我们通过CDP检索完整的可访问性树，并在Puppeteer中遍历它。然后将得到的可访问性节点映射到DOM节点。</p><p>  For this prototype, we implemented a new CDP endpoint specifically for querying the accessibility tree. This way, the querying can happen on the back-end through a C++ implementation instead of in the page context via JavaScript.</p><p>对于这个原型，我们实现了一个新的CDP端点，专门用于查询可访问性树。这样，查询可以通过C++实现在后端进行，而不是通过JavaScript在页面上下文中进行。</p><p>  The following figure compares the total runtime of querying four elements 1000 times for the 3 prototypes. The benchmark was executed in 3 different configurations varying the page size and whether or not caching of accessibility elements was enabled.</p><p>下图比较了3个原型查询4个元素1000次的总运行时间。该基准测试在3种不同的配置中执行，不同的配置改变了页面大小以及是否启用了辅助功能元素的缓存。</p><p>  It is quite clear that there is a considerable performance gap between the CDP-backed querying mechanism and the two others implemented solely in Puppeteer, and the relative difference seems to increase dramatically with the page size. It is somewhat interesting to see that the JS DOM traversal prototype responds so well to enabling accessibility caching. With caching disabled, the accessibility tree is computed on demand and discards the tree after each interaction if the domain is diabled. Enabling the domain makes Chromium cache the computed tree instead.</p><p>很明显，CDP支持的查询机制与仅在Puppeteer中实现的其他两种查询机制之间存在着相当大的性能差距，并且相对差异似乎随着页面大小的增加而显著增大。有趣的是，JS DOM遍历原型对启用可访问性缓存做出了如此好的响应。在禁用缓存的情况下，可访问性树按需计算，如果域被禁用，则在每次交互后丢弃该树。启用该域将使Chromium缓存计算树。</p><p> For the JS DOM traversal we ask for the accessible name and role for every element during the traversal, so if caching is disabled, Chromium computes and discards the accessibility tree for every element we visit. For the CDP based approaches, on the other hand, the tree is only discarded between each call to CDP, i.e. for every query. These approaches also benefit from enabling caching, as the accessibility tree is then persisted across CDP calls, but the performance boost is therefore comparatively smaller.</p><p>对于JS DOM遍历，我们在遍历过程中要求每个元素的可访问名称和角色，因此如果禁用缓存，Chromium将计算并丢弃我们访问的每个元素的可访问性树。另一方面，对于基于CDP的方法，仅在对CDP的每个调用之间(即，对于每个查询)丢弃树。这些方法还受益于启用缓存，因为可访问性树随后在CDP调用之间保持不变，但性能提升相对较小。</p><p> Even though enabling caching looks desirable here, it does come with a cost of additional memory usage. For Puppeteer scripts that e.g  records trace files, this could be problematic. We therefore decided not to enable accessibility tree caching per default. Users can turn on caching themselves by enabling the CDP  Accessibility domain.</p><p>尽管启用缓存在这里看起来是可取的，但它确实会带来额外的内存使用成本。对于记录跟踪文件的Puppeteer脚本来说，这可能是有问题的。因此，我们决定默认情况下不启用可访问性树缓存。用户可以通过启用CDP可访问域自己打开缓存。</p><p>  The previous benchmark showed that implementing our querying mechanism at the CDP layer gives a performance boost in a clinical unit-test scenario.</p><p>之前的基准测试表明，在CDP层实现我们的查询机制可以在临床单元测试场景中提升性能。</p><p> To see if the difference is pronounced enough to make it noticeable in a more realistic scenario of running a full test suite, we  patched the DevTools end-to-end test suite to make use of the JavaScript and CDP-based prototypes and compared the runtimes. In this benchmark, we changed a total of 43 selectors from  [aria-label=…] to a custom query handler  aria/…, which we then implemented using each of the prototypes.</p><p>为了查看差异是否足够明显，以使其在运行完整测试套件的更现实场景中变得明显，我们为DevTools端到端测试套件打了补丁，以利用基于JavaScript和CDP的原型，并比较了运行时。在这个基准测试中，我们总共更改了43个选择器，从[aria-Label=…]。发送到自定义查询处理程序aria/…。，然后我们使用每个原型实现它。</p><p> Some of the selectors are used multiple times in test scripts, so the actual number of executions of the  aria query handler was 113 per run of the suite. The total number of query selections was 2253, so only a fraction of the query selections happened through the prototypes.</p><p>有些选择器在测试脚本中被多次使用，因此每次运行套件时，aria查询处理程序的实际执行次数是113次。查询选择的总数是2253，所以只有一小部分查询选择是通过原型实现的。</p><p>  As seen in the figure above, there is a discernible difference in the total runtime. The data is too noisy to conclude anything specific, but it is clear that the performance gap between the two prototypes shows in this scenario as well.</p><p>如上图所示，总运行时间有明显的差异。这些数据太过嘈杂，无法得出任何具体的结论，但很明显，在这种情况下，两种原型之间的性能差距也是显而易见的。</p><p>  In light of the above benchmarks, and since the launch flag-based approach was undesirable in general, we decided to move forward with implementing a new CDP command for querying the accessibility tree. Now, we had to figure out the interface of this new endpoint.</p><p>根据上述基准，并且由于基于启动标志的方法通常是不可取的，我们决定继续实现用于查询可访问性树的新的CDP命令。现在，我们必须弄清楚这个新端点的接口。</p><p> For our use case in Puppeteer, we need the endpoint to take so-called   RemoteObjectIds as argument and, to enable us to find the corresponding DOM elements afterwards, it should return a list of objects that contains the   backendNodeIds for the DOM elements.</p><p>对于我们在Puppeteer中的用例，我们需要端点将所谓的RemoteObjectIds作为参数，并且为了使我们能够在之后找到相应的DOM元素，它应该返回包含DOM元素的backendNodeIds的对象列表。</p><p> As seen in the chart below, we tried quite a few approaches satisfying this interface. From this, we found that the size of the returned objects, i.e whether or not we returned full accessibility nodes or only the  backendNodeIds made no discernible difference. On the other hand, we found that using the existing   NextInPreOrderIncludingIgnored was a poor choice for implementing the traversal logic here, as that yielded a noticeable slow-down.</p><p>如下图所示，我们尝试了相当多的方法来满足此界面。由此，我们发现返回对象的大小，即我们是否返回完整的可访问性节点或仅返回backendNodeIds没有明显的差别。另一方面，我们发现使用现有的NextInPreOrderIncludingIgnored在这里实现遍历逻辑是一个糟糕的选择，因为这会导致明显的速度减慢。</p><p>   Now, with the CDP endpoint in place, we implemented the query handler on  the Puppeteer side. The grunt of the work here was to restructure the query handling code to enable queries to resolve directly through CDP instead of querying through JavaScript evaluated in the page context.</p><p>现在，CDP端点就位后，我们在Puppeteer端实现了查询处理程序。这里的繁重工作是重组查询处理代码，使查询能够直接通过CDP解析，而不是通过在页面上下文中计算的JavaScript进行查询。</p><p>  The new  aria handler shipped with  Puppeteer v5.4.0 as a built-in query handler. We are looking forward to seeing how users adopt it into their test scripts, and we cannot wait to hear your ideas on how we can make this even more useful!</p><p>Puppeteer V5.4.0附带的新的aria处理程序是内置的查询处理程序。我们期待着看到用户如何将其应用到他们的测试脚本中，我们迫不及待地想听听您关于如何让它变得更有用的想法！</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p>  Thank you for the feedback. If you have specific ideas on how to improve this page, please  create an issue.</p><p>谢谢你的反馈。如果您对如何改进此页面有具体的想法，请创建一个问题。</p><p> To discuss the new features and changes in this post, or anything else related to DevTools:</p><p>要讨论这篇文章中的新功能和变化，或者与DevTools相关的任何其他内容：</p><p>   Below is a list of everything that&#39;s been covered in the  Chrome DevTools Engineering Blog series.</p><p>以下是Chrome DevTools工程博客系列中涉及的所有内容。</p><p>  rss_feed Subscribe to our  RSS or  Atom feed and get the latest  updates in your favorite feed reader!</p><p>订阅我们的RSS或Atom提要，在您最喜爱的提要阅读器中获取最新更新！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://developers.google.com/web/updates/2020/11/puppetaria">https://developers.google.com/web/updates/2020/11/puppetaria</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/木偶/">#木偶</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>