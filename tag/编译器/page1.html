<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#编译器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#编译器</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019940.html">编写一个简单的Python到C编译器：你好，斐波纳契</a></div><div class="item_title_en"><a target="_blank" href="https://notes.eatonphil.com/writing-a-simple-python-compiler.html">Writing a simple Python to C compiler: hello, fibonacci</a><span>(notes.eatonphil.com)</span></div><span class="my_story_list_date">2020-8-24 2:51</span><div class="my_story_list_item_desc">在这篇文章中，我们将用Python编写一个Python到C的编译器。这特别容易做到，因为Python有一个内置的解析库，而且许多CPython内部都向扩展编写者公开。
在本文结束时，只要几百行Python代码，我们就可以编译并运行以下程序：
$cat tests/recursive_fib.pydef fib(N)：......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ctx/">#ctx</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019627.html">但我在帮助编译器</a></div><div class="item_title_en"><a target="_blank" href="https://pankajraghav.com/2020/08/16/RVO.html">But I was helping the compiler</a><span>(pankajraghav.com)</span></div><span class="my_story_list_date">2020-8-22 1:6</span><div class="my_story_list_item_desc">编译器在每个版本中都变得越来越好。有时，在同一编译器的不同版本中，同一段代码的汇编输出可以观察到明显的差异(可以通过编译器资源管理器轻松地完成)。
最近，我开始了检查程序集输出的实践，以分析各种实现的开销。当心，有时它会让人上瘾。但我认为这是学习阅读汇编语言的一种很好的方式，同时也会惊讶于现在的编译器是多么聪明。
在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/帮助/">#帮助</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/helping/">#helping</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017900.html">我们能比我们的C编译器做得更好吗？</a></div><div class="item_title_en"><a target="_blank" href="https://briancallahan.net/blog/20200812.html">Can we do better than our C compiler?</a><span>(briancallahan.net)</span></div><span class="my_story_list_date">2020-8-13 13:22</span><div class="my_story_list_item_desc">今天，我想成为一名C编译器。我从前面的编码练习中添加了一个手工编译的ECHO汇编版本，并添加了一个新的make目标make asm，它将对其进行汇编。让我们看看我们手工编译的程序集，并将其与我们的C编译器进行比较，然后问问它是否值得。
.text.p2ign 2.globl main.type main，@funct......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/argv/">#argv</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013875.html">使D成为我最喜欢的编程语言的特性</a></div><div class="item_title_en"><a target="_blank" href="https://opensource.com/article/20/7/d-programming">The feature that makes D my favorite programming language</a><span>(opensource.com)</span></div><span class="my_story_list_date">2020-7-24 7:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013875.html"><img src="http://img.diglog.com/img/2020/7/thumb_fef3789ffd179224a0c938d558d394e9.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">早在2017年，我就写过为什么D编程语言是开发的绝佳选择。但是D中有一个突出的特性我没有进行足够的扩展：通用函数调用语法(UFCS)。UFCS是D中的语法糖，可以将任何常规函数链接到一个类型(字符串、数字、布尔值等)上。类似于该类型的成员函数。
如果您尚未安装D，请安装D编译器，以便您可以自己运行本文中的D代码。
/......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程语言/">#编程语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/favorite/">#favorite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012830.html">约翰·吉尔摩：天鹅座成长史</a></div><div class="item_title_en"><a target="_blank" href="https://minnie.tuhs.org/pipermail/tuhs/2020-May/021225.html">John Gilmore: History of Cygnus's Growth</a><span>(minnie.tuhs.org)</span></div><span class="my_story_list_date">2020-7-19 11:18</span><div class="my_story_list_item_desc">Toad.com的约翰·吉尔莫·格努于美国东部标准时间2020年5月23日06：39：25在gmail.com&gt；的泰勒·亚当斯&lt；Coppero1237写道：&gt；&gt；是因为给GCC添加后台是免费的，C已经广为人知，而C已经足够了？Skeeve.com的阿诺德写道：&gt；天鹅座解决方案公司(Hi J......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/天鹅座/">#天鹅座</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gilmore/">#gilmore</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011559.html">C++编译器中的优化</a></div><div class="item_title_en"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=3372264">Optimizations in C++ Compilers</a><span>(queue.acm.org)</span></div><span class="my_story_list_date">2020-7-14 1:17</span><div class="my_story_list_item_desc">2019年11月12日第17卷第5期编译器是将高级的、更容易编写的代码转化为高效的机器代码以供计算机执行的必备技术。他们在做这件事上的老练经常被忽视。您可能会花费大量时间仔细考虑算法和处理错误消息，但可能没有足够的时间来了解编译器能够做些什么。
本文介绍了一些编译器和代码生成概念，然后介绍了您的编译器正在为您完成的一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011390.html">面向GPU的域特定多级IR重写</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2005.13014">Domain-Specific Multi-Level IR Rewriting for GPU</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-7-13 3:42</span><div class="my_story_list_item_desc">下载PDF摘要：传统编译器在单个通用中间表示(IR)上操作。这些IR通常是低级的，接近机器指令。因此，依赖领域特定信息的优化要么是不可能的，要么需要复杂的分析来恢复丢失的信息。相反，多级重写实例化方言层次结构(IR)，逐层降低程序，并在最合适的级别执行代码转换。我们展示了这种方法在天气和气候领域的有效性。特别地，我们......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/specific/">#specific</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011284.html">Linus Torvalds谈“Linux内核树内锈蚀支持”</a></div><div class="item_title_en"><a target="_blank" href="https://lkml.org/lkml/2020/7/10/1261">Linus Torvalds on 'Linux kernel in-tree Rust support'</a><span>(lkml.org)</span></div><span class="my_story_list_date">2020-7-12 8:43</span><div class="my_story_list_item_desc">在2020年7月10日星期五下午3：59，Josh Triplett&lt；Josh@joshtriplett.org&&gt;写道：据我回忆，Greg；最初引入此选项的最大条件是执行与LTO使用的相同的Kconfig选项，并关闭其下的&&gt;选项。有足够的时间来做实验。否，请将其设为铁锈可用自动配置选项。与我们已......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/torvalds/">#torvalds</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010197.html">Go与C#：编译器、运行时、类型系统、模块</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/servicetitan-engineering/go-vs-c-part-3-compiler-runtime-type-system-modules-and-everything-else-faa423dddb34">Go vs. C#: Compiler, Runtime, Type System, Modules</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-7 5:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010197.html"><img src="http://img.diglog.com/img/2020/7/thumb_fe5ff336acc9de4afb0853043ce93294.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是系列文章中的最后一篇，也是最有趣的一篇。第1部分和第2部分重点介绍了Golang-Goroutines和几乎停顿的GC的两个关键特性。这篇帖子补充了所有缺失的部分。
但是，在如何实现所有这些功能方面，有更多的不同之处而不是相似之处。让我们跳到这些内容：)。
Go编译成本机二进制文件--也就是说，它的二进制文件“绑......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010014.html">实现了快速的JIT编译器：Julia、PyPy、LuaJIT、Graal等</a></div><div class="item_title_en"><a target="_blank" href="https://carolchen.me/blog/jits-impls/">JIT Compilers Are Implemented and Fast: Julia, PyPy, LuaJIT, Graal and More</a><span>(carolchen.me)</span></div><span class="my_story_list_date">2020-7-6 5:13</span><div class="my_story_list_item_desc">这篇文章详细介绍了5+JIT和各种优化策略，并讨论了它们如何与不同的JIT协同工作。这篇博文中的信息是深度优先的，因此有许多重要的概念可以跳过。
有关JIT编译器的背景信息，请参阅JIT编译器深度介绍：JIT不是非常及时的。如果标题对你没有意义，那么它可能值得浏览一下。
我经常描述一种优化行为，并声称它可能存在于其他......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008912.html">关于编译器优化，每个科学程序员都应该知道些什么？</a></div><div class="item_title_en"><a target="_blank" href="https://dl.acm.org/doi/abs/10.1145/3392717.3392754">What every scientific programmer should know about compiler optimizations?</a><span>(dl.acm.org)</span></div><span class="my_story_list_date">2020-6-30 0:55</span><div class="my_story_list_item_desc">为了帮助支持我们的社区在新冠肺炎期间远程工作，我们将在2020年6月30日之前免费提供ACM在我们数字图书馆中发布的所有作品。了解更多。
我们使用饼干，以确保我们给你最好的经验，在我们的网站。
您的浏览器似乎不支持它们，这会影响网站功能。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/网站/">#网站</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008669.html">GNU GCC不将浮点除法舍入到最接近的值</a></div><div class="item_title_en"><a target="_blank" href="https://lemire.me/blog/2020/06/26/gcc-not-nearest/">GNU GCC does not round floating-point divisions to the nearest value</a><span>(lemire.me)</span></div><span class="my_story_list_date">2020-6-28 6:44</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1008669.html"><img src="http://img.diglog.com/img/2020/6/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我知道浮点算术在现代计算机上有点疯狂。例如，浮点数不具有关联性：
但是，至少在我的经验中，这是相当一致的。您不应该简单地假设像关联性这样的花哨属性在现实世界中起作用。
如果上帝真的存在，可变比率就会是0.50178230318，故事就到此为止了。不幸的是，没有正好为0.50178230318的浮点数。相反，它落在浮点......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/除法/">#除法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gcc/">#gcc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008286.html">基于查询的编译器体系结构</a></div><div class="item_title_en"><a target="_blank" href="https://ollef.github.io/blog/posts/query-based-compilers.html">Query-Based Compiler Architectures</a><span>(ollef.github.io)</span></div><span class="my_story_list_date">2020-6-26 5:18</span><div class="my_story_list_item_desc">注意：这是一篇来自Sixten编程语言文档的老帖子，我对它进行了润色和充实。在写完之后，我发现了Salsa，这是一个与我的Rock库有着非常相似目标的Rust库，它也绝对值得一看！
编译器不再仅仅是获取一堆源文件并产生汇编代码的黑匣子。我们期望他们：
是增量的，这意味着如果我们在做了一些更改之后重新编译一个项目，我们......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007846.html">微型C编译器</a></div><div class="item_title_en"><a target="_blank" href="https://bellard.org/tcc/">Tiny C Compiler</a><span>(bellard.org)</span></div><span class="my_story_list_date">2020-6-24 2:46</span><div class="my_story_list_item_desc">小的!。您可以在任何地方编译和执行C代码，例如在救援盘上(x86TCC可执行文件大约100KB，包括C预处理器、C编译器、汇编器和链接器)。
快地!。TCC生成x86代码。无字节码开销。编译、汇编、链接比GCC快好几倍。
无限量！任何C动态库都可以直接使用。TCC正朝着完全符合ISOC99的方向发展。TCC当然可以自......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tiny/">#tiny</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007391.html">编译器简介</a></div><div class="item_title_en"><a target="_blank" href="https://nicoleorchard.com/blog/compilers">An Intro to Compilers</a><span>(nicoleorchard.com)</span></div><span class="my_story_list_date">2020-6-20 17:26</span><div class="my_story_list_item_desc">编译器只是一个翻译其他程序的程序。传统编译器将源代码转换为您的计算机能够理解的可执行机器码。(一些编译器将源代码翻译成另一种编程语言。这些编译器称为源到源翻译器或转换程序。)。LLVM是一个广泛使用的编译器项目，由许多模块化的编译器工具组成。
前端将源代码转换为中间表示(IR)*。clang是LLVM用于C语言家族的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/intro/">#intro</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/i32/">#i32</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006402.html">搜索原始的Fortran编译器</a></div><div class="item_title_en"><a target="_blank" href="https://mcjones.org/dustydecks/archives/2017/07/14/968/">In search of the original Fortran compiler</a><span>(mcjones.org)</span></div><span class="my_story_list_date">2020-6-13 19:55</span><div class="my_story_list_item_desc">《寻找原始的Fortran编译器》刊载于2017年4-6月的IEEE计算史年鉴。如果链接不起作用，你可以在这里阅读我最终提交的版本。
我写这篇文章是为了记录我在2003年末开始寻找IBM704的原始FORTRAN编译器的源代码的过程。很多搜索都记录在这个灰尘甲板的博客上，我在2004年7月创建了这个博客，作为一种广告......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/原始/">#原始</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/original/">#original</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1005256.html">Go编译器需要更智能</a></div><div class="item_title_en"><a target="_blank" href="https://lemire.me/blog/2020/06/04/the-go-compiler-needs-to-be-smarter/">The Go Compiler Needs to Be Smarter</a><span>(lemire.me)</span></div><span class="my_story_list_date">2020-6-5 11:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1005256.html"><img src="http://img.diglog.com/img/2020/6/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我最喜欢的语言之一是围棋语言。我喜欢它的简约。它在云环境中很受欢迎，也很有用。许多流行的工具都是用Go编写的，这是有充分理由的。
去年我做了一次关于围棋的演讲，有人要求我对围棋进行批评。我不介意围棋缺少例外或泛型。这些功能通常被高估了。
然而，尽管Go很有魅力，但我发现它的编译器与我对其他编程语言的期望不一样。当围棋......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/围棋/">#围棋</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004431.html">为什么C到Z80编译器产生的代码很差？</a></div><div class="item_title_en"><a target="_blank" href="https://retrocomputing.stackexchange.com/questions/6095/why-do-c-to-z80-compilers-produce-poor-code">Why do C to Z80 compilers produce poor code?</a><span>(retrocomputing.stackexchange.com)</span></div><span class="my_story_list_date">2020-5-31 3:24</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1004431.html"><img src="http://img.diglog.com/img/2020/5/thumb_bff2a714cd7081340512131d66996508.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我的印象是，很难将C编译成Z80并最终得到优化良好的代码。是这样吗？为什么？
我对6502的了解更多。下面的一些例子说明了为什么C不适合6502：
C中的数组由整数类型索引。6502在索引数组方面相当快，但不幸的是，只有在索引是一个字节宽的情况下。因此，像strcmp或strlen这样的代码可能需要对每个字符执行16......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003400.html">一遍编译器</a></div><div class="item_title_en"><a target="_blank" href="https://keleshev.com/one-pass-compiler-primer">One-pass Compiler</a><span>(keleshev.com)</span></div><span class="my_story_list_date">2020-5-23 21:43</span><div class="my_story_list_item_desc">让我们来看看什么是一遍编译器，并尝试实现一遍编译器。
一遍编译器在分析过程中直接发出汇编(或二进制代码)，而不创建中间表示，如AST。这是一种罕见的技术，在计算机内存匮乏的时代使用。这限制了可能的语言功能和生成的代码的质量。但是，这种技术产生的快速编译器让比尔·盖茨羡慕不已。这是一种非常罕见的技术，在计算机内存匮乏的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pass/">#pass</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/输出/">#输出</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002438.html">通过构建一个小型的Markdown编译器开始使用Rust</a></div><div class="item_title_en"><a target="_blank" href="https://jesselawson.org/rust/getting-started-with-rust-by-building-a-tiny-markdown-compiler/">Getting Started with Rust by Building a Tiny Markdown Compiler</a><span>(jesselawson.org)</span></div><span class="my_story_list_date">2020-5-17 4:42</span><div class="my_story_list_item_desc">我的名字是Jesse，这是一个面向喜欢在实践中学习的开发人员的Rust入门教程。
本教程的目的是发展对Rust中的工具构建的直觉-具体地说，学习如何在Rust中思考和构建。
我们的目标是生产一个非常基本的命令行编译器，可以将包含标题和段落的基本Markdown文档转换为html文件。
为此，我们将从构建一个简单的“H......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/编译器/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/编译器/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>