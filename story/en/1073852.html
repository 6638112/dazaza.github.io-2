<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MIR轻量级JIT编译器的代码专门化Code specialization for the MIR lightweight JIT compiler</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Code specialization for the MIR lightweight JIT compiler<br/>MIR轻量级JIT编译器的代码专门化</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 14:53:32</div><div class="page_narrow text-break page_content"><p>For the past three years, I have spent half of my work time on the  MIR project. The goal is to create a universal lightweight Just-in-Time (JIT) compiler, and the project&#39;s cornerstone is a machine-independent  medium-level intermediate representation (MIR). For more about the project, see my previous articles on Red Hat Developer:</p><p>在过去的三年里，我把一半的工作时间花在和平号项目上。目标是创建一个通用的轻量级即时（JIT）编译器，以及该项目&#39；s基石是一个独立于机器的中级中间表示（MIR）。有关该项目的更多信息，请参阅我之前关于Red Hat Developer的文章：</p><p>  So far, my work on the MIR project has focused on making a fast JIT compiler that generates decent machine code for a few major targets: x86-64 Linux and macOS, aarch64, s390x, riscv64 Linux, and ppc64 big- and little-endian Linux.</p><p>到目前为止，我在MIR项目上的工作重点是制作一个快速的JIT编译器，为几个主要目标生成合适的机器代码：x86-64 Linux和macOS、AARC64、s390x、riscv64 Linux和ppc64 big-and little-endian Linux。</p><p> The project in its current state is a method JIT compiler that can be effectively used for statically typed programming languages such as  C, which is the most widely used statically typed language. We&#39;ve developed a C-language JIT based on the C-to-MIR  compiler.</p><p>当前状态下的项目是一个方法JIT编译器，可以有效地用于静态类型编程语言，如C，这是使用最广泛的静态类型语言。我们&#39；我开发了一个基于C-to-MIR编译器的C语言JIT。</p><p> The original goal for the MIR project was to implement a better  Ruby JIT compiler. (Specifically, I&#39;m focusing on CRuby, the default Ruby interpreter, which is  written in C.)  Ruby is a  very dynamic programming language—it is so flexible that you can even redefine the plus method for integer numbers.</p><p>MIR项目的最初目标是实现更好的Ruby JIT编译器。（具体来说，我关注的是CRuby，默认的Ruby解释器，它是用C编写的。）Ruby是一种非常动态的编程语言，它非常灵活，甚至可以重新定义整数的加号方法。</p><p> To achieve better performance for dynamic programming languages, you need to follow program execution, make various assumptions from the execution, and generate code based on those assumptions. For example, you might find that a given plus operation in a given method has only integer operands. You can assume that this will always be the case and generate  specialized plus operation code working only for integer operands.</p><p>为了获得更好的动态编程语言性能，您需要跟踪程序执行，从执行中做出各种假设，并根据这些假设生成代码。例如，您可能会发现给定方法中的给定加号运算只有整数操作数。您可以假设情况始终如此，并生成仅适用于整数操作数的专用加号运算代码。</p><p> You need to use different techniques to guarantee that your assumptions hold, such as implementing assumption checks or guards, or proving that on a given execution path the assumption is always true. If the guards find that the assumption is wrong, you need to switch to code that can work for any case. The process of switching from specialized code to general case code is frequently called  deoptimization in the JIT context.</p><p>你需要使用不同的技术来保证你的假设成立，比如实施假设检查或保护，或者证明在给定的执行路径上，假设总是正确的。如果警卫发现这个假设是错误的，你需要切换到适用于任何情况的代码。在JIT上下文中，从专用代码切换到通用案例代码的过程通常被称为去优化。</p><p> In this article, I&#39;ll discuss how I plan to support the generation of specialized and deoptimized code in MIR, and what support has already been implemented in the MIR project.</p><p>在本文中，我&#39；我将讨论我计划如何支持在MIR中生成专门的、非优化的代码，以及在MIR项目中已经实现了哪些支持。</p><p> Note: Most JITs are specialized for specific languages: There&#39;s  V8 for  JavaScript, for instance, or  luajit for Lua and  PHP JIT for  PHP.  I am more interested in  language agnostic support to facilitate the implementation of specialization and deoptimization in JITs for different dynamic programming languages. (See  How the JIT compiler boosts Java performance in OpenJDK for more about deoptimization in a JIT compiler.)</p><p>注：大多数JIT专门针对特定语言：有&#39；例如，s V8代表JavaScript，luajit代表Lua，PHP代表PHP的PHP JIT。我更感兴趣的是语言无关性支持，以促进不同动态编程语言在JIT中实现专门化和去优化。（有关JIT编译器中去优化的更多信息，请参阅JIT编译器如何在OpenJDK中提高Java性能。）</p><p>  So that we can look specifically at specialization and deoptimization in the MIR compiler, I will use the following simplified code for the virtual machine (VM) instruction  plus in the CRuby implementation:</p><p>为了让我们能够具体了解MIR编译器中的专门化和去优化，我将在CRuby实现中使用以下虚拟机（VM）指令plus的简化代码：</p><p> if (FIXNUM_2_P(recv, obj) &amp;&amp; BASIC_OP_UNREDEFINED_P(BOP_PLUS, INTEGER_REDEFINED_OP_FLAG)) { res = rb_fix_plus_fix(recv, obj); } else if (FLONUM_2_P(recv, obj) &amp;&amp; BASIC_OP_UNREDEFINED_P(BOP_PLUS, FLOAT_REDEFINED_OP_FLAG)) { res = DBL2NUM(RFLOAT_VALUE(recv) + RFLOAT_VALUE(obj)); } else if (SPECIAL_CONST_P(recv) || SPECIAL_CONST_P(obj)) { ... } else if (RBASIC_CLASS(recv) == rb_cFloat &amp;&amp; RBASIC_CLASS(obj) == rb_cFloat &amp;&amp; BASIC_OP_UNREDEFINED_P(BOP_PLUS, FLOAT_REDEFINED_OP_FLAG)) { ... } else if (RBASIC_CLASS(recv) == rb_cString &amp;&amp; RBASIC_CLASS(obj) == rb_cString &amp;&amp; BASIC_OP_UNREDEFINED_P(BOP_PLUS, STRING_REDEFINED_OP_FLAG)) { ... } else if (RBASIC_CLASS(recv) == rb_cArray &amp;&amp; RBASIC_CLASS(obj) == rb_cArray &amp;&amp; BASIC_OP_UNREDEFINED_P(BOP_PLUS, ARRAY_REDEFINED_OP_FLAG)) { ... } else { .. // call of method implementing + for object recv }</p><p>如果（固定资产）&amp；基本的_OP_undefined_P（BOP_PLUS，INTEGER_refined_OP_FLAG））{res=rb_fix_PLUS_fix（recv，obj）；}否则，如果（FLONUM_2_P（recv，obj）&amp&amp；基本的_OP_undefined_P（BOP_PLUS，FLOAT_refined_OP_FLAG））{res=db2num（RFLOAT_值（recv）+RFLOAT_值（obj））}否则如果（特殊常数P（recv）| |特殊常数P（obj））{…}否则如果（RBASIC_CLASS（recv）=rb_cFloat&amp&amp；RBASIC_CLASS（obj）=rb_cFloat&amp&amp；基本的_OP_undefined_P（BOP_PLUS，FLOAT_refined_OP_FLAG））{…}否则如果（RBASIC_CLASS（recv）=rb_cString&amp&amp；RBASIC_CLASS（obj）=rb_cString&amp&amp；基本_OP_undefined_P（BOP_PLUS，STRING_refined_OP_FLAG））{…}否则，如果（RBASIC_CLASS（recv）=rb_cArray&amp&amp；RBASIC_CLASS（obj）=rb_cArray&amp&amp；基本_OP_undefined_P（BOP_PLUS，数组_refined_OP_FLAG））{…}else{..//object recv实现+的方法调用}</p><p> So, what&#39;s happening here? First, the code checks that operands are fixed numbers and that the plus method for integers is not redefined. If that is the case, the code implements the  plus operation for fixed numbers. Otherwise, it makes analogous checks for floating point numbers, strings, and arrays. At the end, it calls the Ruby method implementing  + for the object  recv.</p><p>那么，什么&#39；这里发生了什么事？首先，代码检查操作数是否为固定数，整数的加号方法是否未重新定义。如果是这种情况，代码将对固定数字执行加号操作。否则，它会对浮点数、字符串和数组进行类似的检查。最后，它为对象recv调用Ruby方法implementing+。</p><p> Fixed numbers (or  fixnums) in CRuby are a subset of integers that can be efficiently supported by the target machine. Bigger numbers are represented as multi-precision numbers implemented by the  GMP library.</p><p>CRuby中的Fixed numbers（或FixNum）是目标机器可以有效支持的整数子集。较大的数字表示为GMP库实现的多精度数字。</p><p> All values in CRuby are represented by a machine word and  tagged. For example, a fixnum always has 1 as the least significant bit of the word and a pointer to an object always has three (or two, on 32-bit targets) zero-least significant bits. So the macro  FIXNUM_2_P is implemented as the following code:</p><p>CRuby中的所有值都由一个机器字表示并标记。例如，fixnum总是有1作为单词的最低有效位，而指向对象的指针总是有三个（或两个，在32位目标上）零最低有效位。因此，宏FIXNUM_2_P的实现如下代码所示：</p><p>  And the fixnum  plus operation looks like this, if we omit the code for checking overflow:</p><p>如果省略检查溢出的代码，fixnum plus操作如下所示：</p><p>  Note: For further simplicity, in the next sections I will ignore checks for redefinition of the  plus operation, such as the invocations of the macro  BASIC_OP_UNREDEFINED_P in the above example.</p><p>注意：为了进一步简化，在接下来的部分中，我将忽略对plus操作重新定义的检查，例如在上面的示例中调用宏BASIC_OP_undefined_P。</p><p>  Assume that we&#39;ve checked the operand types of a particular  plus operation and found so far that they have always been fixed numbers. In that case, we could generate the following:</p><p>假设我们&#39；我检查了一个特定加号运算的操作数类型，发现它们一直都是固定数。在这种情况下，我们可以生成以下内容：</p><p>  At first glance, it seems we didn&#39;t improve the code because the check ( FIXNUM_2_P) is still present. But if we look at a sequence of several plus operations,  v1 + v2 + v3 + v4, we&#39;ll have:</p><p>乍一看，我们似乎没有&#39；t改进代码，因为检查（FIXNUM_2_P）仍然存在。但是如果我们看一系列的加号运算，v1+v2+v3+v4，我们&#39；我们有：</p><p> if (!FIXNUM_2_P(v1, v2)) goto general_case; res = rb_fix_plus_fix(v1, v2) if (!FIXNUM_2_P(res, v3)) goto general_case; res = rb_fix_plus_fix(res, v3) if (!FIXNUM_2_P(res, v4)) goto general_case; res = rb_fix_plus_fix(res, v4)</p><p>如果（！FIXNUM_2_P（v1，v2））转到一般情况；res=rb_fix_plus_fix（v1，v2）如果（！FIXNUM_2_P（res，v3））转到一般情况；res=rb_fix_plus_fix（res，v3）如果（！FIXNUM_2_P（res，v4））转到一般情况；res=rb_fix_plus_fix（res，v4）</p><p> A smart compiler could remove the last two  FIXNUM_2_P checks. Unfortunately, neither GCC nor Clang can figure out that  res always has 1 as the least significant bit. Therefore, these compilers do not know the last two  FIXNUM_2_P checks should be removed. GCC&#39;s situation might change in the future with the full implementation of  Project Ranger. (By the way, if the values were represented by a structure with two members,  type and  value, GCC/LLVM even now could figure out their types and remove the last two checks.)</p><p>智能编译器可以删除最后两个FIXNUM_2_P检查。不幸的是，GCC和Clang都不能确定res的最低有效位总是1。因此，这些编译器不知道应该删除最后两个FIXNUM_2_P检查。GCC和#39；随着Ranger项目的全面实施，未来的情况可能会发生变化。（顺便说一句，如果值是由一个包含两个成员（type和value）的结构表示的，那么GCC/LLVM现在甚至可以找出它们的类型并删除最后两个检查。）</p><p>  Even without removing the redundant checks, executing such specialized code is beneficial because compilers can successfully do other optimizations, such as removing redundant loads and stores. That&#39;s because such code forms specific regions called  extended basic blocks (EBBs), and optimizing compilers work particularly well on such regions. Code like this also has much better code locality and branch prediction.</p><p>即使不删除冗余检查，执行这种专用代码也是有益的，因为编译器可以成功地进行其他优化，例如删除冗余加载和存储。那&#39；因为这样的代码形成了称为扩展基本块（EBB）的特定区域，而优化编译器在这样的区域上工作得特别好。这样的代码还具有更好的代码局部性和分支预测。</p><p>  How might we implement the code labeled by  general_case in the fixed number example? There are three possibilities:</p><p>在固定数字示例中，我们如何实现由general_case标记的代码？有三种可能性：</p><p> A JIT compiler call to remove the specialized code generated for the Ruby method, then generate and use general code for the method VM instructions.</p><p>JIT编译器调用，删除为Ruby方法生成的专用代码，然后为方法VM指令生成并使用通用代码。</p><p>  A  goto to a particular location containing all code for all type cases of the method VM instructions.</p><p>转到一个特定位置，其中包含方法VM指令的所有类型案例的所有代码。</p><p> As switching to the interpreter in CRuby is very expensive, it might be better to generate general case code at the same time as specialized code, along with  gotos to the general code from the specialized code when the guards fail. After several executions of the  gotos to the general case code, we could rebuild the entire method with the current profile info.</p><p>由于切换到CRuby中的解释器非常昂贵，因此最好在生成专用代码的同时生成通用案例代码，以及在警卫失败时从专用代码转到通用代码。在对一般案例代码执行了几次gotos之后，我们可以使用当前概要信息重建整个方法。</p><p>  The MIR JIT compiler is not smarter than GCC or Clang, and it encounters the same problem of removing redundant checks for tagged values. To solve the problem, I am planning to introduce  properties for program variables and MIR instructions, along with built-in C functions working with properties:</p><p>MIR-JIT编译器并不比GCC或Clang更聪明，它遇到了相同的问题，即删除对标记值的冗余检查。为了解决这个问题，我计划引入程序变量和MIR指令的属性，以及使用属性的内置C函数：</p><p>  Note: For brevity, I&#39;ll skip over a description of property support on the MIR level.</p><p>注：为简洁起见，I&#39；我将跳过对MIR级别的财产支持的描述。</p><p> Properties are integer constants. We can use  __builtin_prop_set to assign properties to program variables at a given execution point. Properties are propagated to other program variables through variable assignments.</p><p>属性是整数常量。我们可以使用_builtin_prop_set在给定的执行点为程序变量分配属性。属性通过变量赋值传播到其他程序变量。</p><p> When we cannot calculate the property of a program variable at a given execution point, the variable gets the  zero property at that point. A zero property is an unknown property.</p><p>当我们无法计算程序变量在给定执行点的属性时，该变量在该点的属性为零。零属性是未知属性。</p><p> We can annotate  plus code with the new built-in calls for properties describing program variable types as follows:</p><p>我们可以通过对描述程序变量类型的属性的新内置调用来注释plus代码，如下所示：</p><p> enum prop { unknown = 0, inttype, flotype, ... }; if (__builtin_prop_cond (FIXNUM_2_P(recv, obj), recv, intype, obj, intype)) { res = rb_fix_plus_fix(recv, obj); __builtin_prop_set (res, inttype) } else if (__builtin_prop_cond (FLONUM_2_P(recv, obj), recv, flotype, obj, flotype)) res = DBL2NUM(RFLOAT_VALUE(recv) + RFLOAT_VALUE(obj)); __builtin_prop_set (res, flotype); } else { ... // call of method implemented + for object recv }</p><p>枚举属性{unknown=0，inttype，flotype，…}；如果（uuu builtin_prop_cond（FIXNUM_2_P（recv，obj），recv，intype，obj，intype））{res=rb_fix_plus_fix（recv，obj）；uuu builtin_prop_set（res，intype）}如果（uuuuu builtin_prop cond_cond（FLONUM_2_P（recv，obj），recv，flotype，obj，flotype））res=db2num__内置道具套装（res，flotype）；]else{…//为对象recv实现的方法+调用}</p><p>  if (recv.prop == intype &amp;&amp; obj.prop == inttype || (recv.prop == unknown &amp;&amp; obj.prop == unknown) &amp;&amp; FIXNUM_2_P(recv, obj)) { res = rb_fix_plus_fix(recv, obj); res.prop = intype; } else if (__builtin_prop_cond (FLONUM_2_P(recv, obj), recv, flotype, obj, flotype)) res = DBL2NUM(RFLOAT_VALUE(recv) + RFLOAT_VALUE(obj)); __builtin_prop_set (res, flotype); } else { ... // call of method implemented + for object recv }</p><p>如果（recv.prop==inttype&amp；obj.prop==inttype | | |（recv.prop==unknown&amp；obj.prop==unknown）&amp&amp；FIXNUM_2_P（recv，obj））{res=rb_fix\u plus_fix（recv，obj）；res.prop=intype；}否则如果（_内置_属性条件（FLONUM_2_P（recv，obj），recv，flotype，obj，flotype））res=db2num（RFLOAT_值（recv）+RFLOAT_值（obj））__内置道具套装（res，flotype）；]else{…//为对象recv实现的方法+调用}</p><p> Because we always know properties during code generation,  all assignments and comparisons of properties will go away in the final code. For example, if we figure out that  recv and  obj both have the property  inttype, the final code will be:</p><p>因为我们在代码生成过程中总是知道属性，所以所有属性的赋值和比较都会在最终代码中消失。例如，如果我们发现recv和obj都具有inttype属性，那么最终的代码将是：</p><p>  If we figure out during analysis that  recv and  obj both have the property  flotype, the final code will be:</p><p>如果我们在分析过程中发现recv和obj都具有属性flotype，则最终代码将为：</p><p>  If the properties of values of  recv and  obj are zero, we will have the original code as before the annotation. If only one property of  recv or  obj is zero, we will have only the code in the final  else part.</p><p>如果recv和obj的值的属性为零，我们将获得与注释之前相同的原始代码。如果recv或obj只有一个属性为零，那么在最后的else部分中只有代码。</p><p> Consider the code after the profiling discussed above. The analogous code annotated with properties after profiling will look like this:</p><p>考虑上面讨论的分析之后的代码。分析后，用属性注释的类似代码如下所示：</p><p> if (!__builtin_prop_cond (FIXNUM_2_P(v1, v2), v1, intype, v2, intype)) goto general_case;res = rb_fix_plus_fix(v1, v2);__builtin_prop_set (res, inttype);if (!__builtin_prop_cond (FIXNUM_2_P(res, v3), res, intype, v3, intype)) goto general_case;res = rb_fix_plus_fix(res, v3);__builtin_prop_set (res, inttype);if (!__builtin_prop_cond (FIXNUM_2_P(res, v4), res, intype, v4, intype)) goto general_case;res = rb_fix_plus_fix(res, v4);__builtin_prop_set (res, inttype);...</p><p>如果（！uuuu内置属性条件（FIXNUM_u2_up（v1，v2），v1，intype，v2，intype））转到一般情况；res=rb_fix_加_fix（v1，v2）__内置道具（res、inttype）；如果（！__内置_prop_cond（FIXNUM_2_P（res，v3），res，intype，v3，intype））转到一般情况；res=rb_fix_加_fix（res，v3）__内置道具（res、inttype）；如果（！__内置_prop_cond（FIXNUM_2_P（res，v4），res，intype，v4，intype））转到一般情况；res=rb_fix_加_fix（res，v4）__内置属性集（res，inttype）；。。。</p><p> It is now pretty easy to find and propagate properties of program variables for the extended basic block above. Property analysis is trivial for variables in MIR registers, while for variables represented by MIR memory operands it requires a more complex point-to analysis.</p><p>现在很容易找到并传播上面扩展的基本块的程序变量属性。对于MIR寄存器中的变量，属性分析很简单，而对于由MIR内存操作数表示的变量，则需要更复杂的分析点。</p><p>   Note: For brevity, I am omitting a description of how to do the profiling, especially when code is executed in more than one thread.</p><p>注意：为了简洁起见，我省略了如何进行分析的描述，尤其是当代码在多个线程中执行时。</p><p>  What would happen for specialization based on profiling if, in the Ruby code  v1 + v2 + v3 + v4 that we looked at earlier, all variables in half of all cases had fixnum values and in the other half had floating point number values? This is a common situation for a polymorphic function in dynamic programming languages.</p><p>如果在我们前面看到的Ruby代码v1+v2+v3+v4中，一半情况下的所有变量都有fixnum值，另一半情况下的所有变量都有浮点数值，那么基于分析的专门化会发生什么？这是动态编程语言中多态函数的常见情况。</p><p> We could generate specialized code only for one half of the cases and do the deoptimization when a case from the other half occurred. Or we might generate and use only general case code. If a particular call to some small function had specific type values in the majority of cases, we could improve the generated code by using code inlining. That&#39;s a complicated solution, however. A simpler approach to solve the problem is  basic block versioning (BBV).</p><p>我们只能为其中一半的案例生成专门的代码，并在另一半的案例发生时进行去优化。或者，我们可能只生成并使用一般案例代码。如果对某个小函数的特定调用在大多数情况下具有特定的类型值，我们可以通过使用代码内联来改进生成的代码。那&#39；然而，这是一个复杂的解决方案。解决这个问题的一种更简单的方法是基本块版本控制（BBV）。</p><p> How does basic block versioning work? Suppose we have different paths to reach a basic block of our code (by different calls to a function, say), and on these different paths we have specific types (properties) of variables. We can clone the basic block and generate different versions of specialized code for different types of variables, as illustrated in Figure 1 (note that basic blocks are denoted as BB).</p><p>基本块版本控制是如何工作的？假设我们有不同的路径来到达代码的一个基本块（比如通过对函数的不同调用），在这些不同的路径上，我们有特定类型（属性）的变量。我们可以克隆基本块，并为不同类型的变量生成不同版本的专用代码，如图1所示（请注意，基本块表示为BB）。</p><p>  Creating a specialized basic block version can deduce types of outgoing variable values, like the value of  res in our example. This in turn can result in the generation of different versions of successor basic blocks.</p><p>创建一个专门的基本块版本可以推断出输出变量值的类型，比如我们示例中的res值。这反过来会导致生成不同版本的后续基本块。</p><p> You can probably guess that if we don&#39;t constrain the number of basic block versions, a combinatorial explosion of different versions might arise. In practice, only a few versions of one basic block are generated, where one basic block version is always used for unknown types (zero properties).</p><p>如果我们不&#39；如果不限制基本块版本的数量，可能会出现不同版本的组合爆炸。实际上，只生成一个基本块的几个版本，其中一个基本块版本始终用于未知类型（零属性）。</p><p>  There are two ways to generate basic block versions. It can be done in an  eager way or in a  lazy way. In the eager strategy, when we generate code for a basic block version, we also create versions of successor basic blocks and generate code for them, and so on. In other words, we generate code for the whole method at once.</p><p>有两种方法可以生成基本块版本。它可以用渴望的方式或懒惰的方式来完成。在渴望策略中，当我们为基本块版本生成代码时，我们也会创建后续基本块的版本，并为它们生成代码，以此类推。换句话说，我们一次生成整个方法的代码。</p><p> In the lazy strategy, we generate code for a basic block version only when we start execution of that version. This means that we generate code for method basic blocks that are actually executed in the program. Obviously, lazy basic block versioning results in less generated code and, usually, less compilation time. (If we need to generate code for the same number of basic block versions with both strategies, lazy code compilation would probably require more time because of more time spent for data initialization and finalization for each separate basic block code generation.)</p><p>在惰性策略中，我们只在开始执行基本块版本时才为该版本生成代码。这意味着我们为程序中实际执行的方法基本块生成代码。显然，懒惰的基本块版本控制会减少生成的代码，通常也会减少编译时间。（如果我们需要使用这两种策略为相同数量的基本块版本生成代码，惰性代码编译可能需要更多时间，因为每次单独的基本块代码生成都需要更多时间进行数据初始化和最终确定。）</p><p>  When compared to specialized code generation based on profiling, as described in the previous section, lazy basic block versioning has several advantages:</p><p>如前一节所述，与基于分析的专门代码生成相比，lazy basic块版本控制有几个优点：</p><p> We don&#39;t need to generate machine code for all BBs, which can be attractive when only a small part of the JIT&#39;ed program is executed.</p><p>我们没有&#39；不需要为所有BBs生成机器代码，当只有JIT的一小部分时，这可能很有吸引力；执行一个新的程序。</p><p>  We don&#39;t need to do special implementation of deoptimization. It is automatically done through BB versioning.</p><p>我们没有&#39；不需要特别实施去优化。它是通过BB版本控制自动完成的。</p><p>  Many method JITs generate code only for methods that were executed a number of times greater than some threshold. The execution is switched only at function calls. Such an approach does not work well if a method is called rarely but has a very long-running loop. Switching to new method code during method execution is called  on-stack replacement (OSR). Lazy basic block versioning does not require a special implementation of OSR; it is done automatically.</p><p>许多方法JIT只为执行次数超过某个阈值的方法生成代码。仅在函数调用时切换执行。如果一个方法很少被调用，但有一个非常长的循环，那么这种方法就不能很好地工作。在方法执行期间切换到新的方法代码称为堆栈替换（OSR）。懒惰的基本块版本控制不需要OSR的特殊实现；这是自动完成的。</p><p> One might think that basic block versioning results in an explosion in code size. In practice, the average number of versions is quite small. About 95 percent of basic blocks had only one version on a set of JavaScript benchmarks, according to a paper by Maxime Chevalier-Boisvert and Marc Feely (see  Simple and Effective Type Check Removal through Lazy Basic Block Versioning).</p><p>有人可能会认为，基本块版本控制会导致代码大小激增。实际上，版本的平均数量非常少。根据Maxime Chevalier Boisvert和Marc Feely的一篇论文，大约95%的基本块在一组JavaScript基准上只有一个版本（参见通过延迟基本块版本控制删除简单有效的类型检查）。</p><p> When bootstrapping the x86-64 C-to-MIR compiler, which is about 30,000 lines of C code, the number of generated basic block versions is only 51 percent of all basic blocks of the compiler functions executed at least once (14,737 out of 29,131) and only 18 percent (14,737 out of 81,799) of all basic blocks of the compiler, as you can see in Figure 2.</p><p>在引导x86-64 C-to-MIR编译器（大约30000行C代码）时，生成的基本块版本仅占至少执行一次的编译器函数的所有基本块的51%（29131中有14737个），仅占编译器所有基本块的18%（81799中有14737个），如图2所示。</p><p>  It should come as no surprise that I started to implement lazy basic block versioning first for the MIR project.</p><p>毫不奇怪，我首先开始为MIR项目实施lazy basic块版本控制。</p><p>  How is lazy basic block versioning implemented for the MIR project? All calls of MIR functions are indirect and implemented through small runtime-generated code snippets called  thunks, which usually consist of one or two machine instructions. Thunks are used to easily change machine code for any MIR function; for instance, we need this for switching specialized machine code to deoptimized code.</p><p>MIR项目的基本块版本控制是如何实现的？MIR函数的所有调用都是间接的，通过名为thunks的运行时生成的小代码段实现，thunks通常由一条或两条机器指令组成。Thunks用于轻松更改任何MIR功能的机器代码；例如，我们需要将专用机器代码转换为非优化代码。</p><p> MIR already has a  lazy function code generation mechanism, which is also implemented through thunks. At the start of program execution, all function thunks redirect to the machine code generator. When a function is called for the first time, the MIR code generator optimizes the function and generates machine code for it; the function thunk is then redirected to the generated machine code and execution continues from the generated code, as shown in Figure 3.</p><p>MIR已经有了一种惰性函数代码生成机制，它也通过thunks实现。在程序执行开始时，所有函数thunk都重定向到机器代码生成器。当函数第一次被调用时，MIR代码生成器优化函数并为其生成机器代码；然后将函数thunk重定向到生成的机器代码，并从生成的代码继续执行，如图3所示。</p><p>  When we use lazy block versioning, the function thunk implements a switch to a specific address that depends on the properties of program variables at the beginning of the basic block. The switch can be implemented in various ways—as a table-based switch, for instance. Any switch is less efficient than just the one jump instruction used previously. Still, we cannot use several simple jump thunks for one function instead of the switch, as we need to support a one-to-one relation between a function and its thunk. That is because a function in MIR is represented by its thunk address, and functions are first-class values that can be assigned and compared.</p><p>当我们使用延迟块版本控制时，函数thunk实现了一个到特定地址的切换，该地址取决于基本块开头的程序变量的属性。例如，该开关可以以多种方式实现为基于表的开关。任何开关的效率都低于之前使用的一条跳转指令。尽管如此，我们不能对一个函数使用几个简单的跳转thunk来代替开关，因为我们需要支持函数与其thunk之间的一对一关系。这是因为MIR中的函数由其thunk地址表示，函数是可以赋值和比较的一级值。</p><p> The function thunk for lazy basic block versioning redirects to a machine code generator of a basic block version or to already-generated machine code of that version. A function call also passes an identifier of the properties of call arguments through some register that is not saved by a called function according to the application binary interface (ABI) used.</p><p>用于延迟基本块版本控制的函数thunk重定向到基本块版本的机器代码生成器或该版本的已生成机器代码。函数调用还通过一些寄存器传递调用参数属性的标识符，根据所使用的应用程序二进制接口（ABI），这些寄存器不是被调用函数保存的。</p><p> Initially, a function thunk redirects to a machine code generator, which works in a special mode. It only optimizes the function but does not generate machine code. Instead, it creates a version of the function&#39;s first basic block, redirects the function thunk to the basic block version generator, and calls it. The next calls modify the function thunk whenever a new basic block version is necessary. Figure 4 illustrates how the function thunk changes when the limit for the number of basic block versions is three.</p><p>最初，函数thunk重定向到机器代码生成器，该生成器在特殊模式下工作。它只优化功能，但不生成机器代码。相反，它创建了函数的一个版本#39；s第一个基本块，将函数thunk重定向到基本块版本生成器，并调用它。下一个调用会在需要新的基本块版本时修改函数thunk。图4说明了当基本块版本的数量限制为三个时，函数thunk是如何变化的。</p><p>  The basic block version generator processes MIR property instructions optimizing code for the given properties, and generates machine code for the basic block. It finds successor basic blocks with properties at the end of the current basic block and adds jumps at the end of that basic block to the machine code of its successors.</p><p>基本块版本生成器处理MIR属性指令，优化给定属性的代码，并生成基本块的机器代码。它查找在当前基本块末尾具有属性的后续基本块，并将该基本块末尾的跳转添加到后续基本块的机器代码中。</p><p> If the basic block version generator can&#39;t find basic block versions of a basic block&#39;s successors, it creates them, along with their thunks. The generator adds jumps to the new thunks at the end of the machine code of the current basic block version and continues execution from the machine code of the current version. In rare cases, jumps through basic block versions can still be done through basic block thunks. This happens when, in the original basic block version, there&#39;s an indirect jump or MIR switch instruction with more than one case having the same target label.</p><p>如果基本块版本生成器可以&#39；找不到基本块的基本块版本&#39；它创造了他们的继任者，以及他们的重击。生成器将跳转添加到当前基本块版本的机器代码末尾的新thunks，并从当前版本的机器代码继续执行。在极少数情况下，跳过基本块版本仍然可以通过基本块重击完成。在原始的基本块版本中，出现&#39；s一个间接跳转或MIR switch指令，其中多个case具有相同的目标标签。</p><p>   Lazy basic block generation in the MIR project was inspired by the recent  Shopify YJIT for CRuby. But there are important differences between the two:</p><p>MIR项目中的懒惰基本块生成是受最近的Shopify YJIT for CRuby的启发。但两者之间有重要区别：</p><p> YJIT is a specialized CRuby JIT, whereas MIR is a universal JIT and can be used for JIT implementations of different languages.</p><p>YJIT是一种专门的CRuby JIT，而MIR是一种通用的JIT，可以用于不同语言的JIT实现。</p><p>  A YJIT basic block is a CRuby VM instruction basic block, whereas a MIR basic block is a machine-instruction-level basic block.</p><p>YJIT基本块是CRuby VM指令基本块，而MIR基本块是机器指令级基本块。</p><p>  YJIT does not do any optimization of basic block versions. The MIR generator optimizes the whole function first and individual basic block versions later.</p><p>YJIT不会对基本块版本进行任何优化。MIR生成器首先优化整个功能，然后优化单个基本块版本。</p><p>  YJIT only supports x86-64 code generation. MIR supports x86-64, aarch64, ppc64, s390, and 64-bit RISCV.</p><p>YJIT仅支持x86-64代码生成。MIR支持x86-64、AARC64、ppc64、s390和64位RISCV。</p><p> As you&#39;ve seen, code generated with basic block versions contains more jumps than generated code for the entire function. But I did not find any performance difference on x86-64 machines (just some noise) with the  benchmarks I use for the MIR and the C-to-MIR compilers. My guess is that direct jump instructions are probably low cost on modern processors, with their sophisticated branch prediction units, and any additional cost is compensated by better code locality produced by using basic block versions.</p><p>作为你&#39；我们已经看到，使用基本块版本生成的代码比为整个函数生成的代码包含更多的跳转。但我没有发现x86-64机器上的性能与我用于MIR和C-to-MIR编译器的基准测试有任何差异（只是一些噪音）。我的猜测是，在现代处理器上，直接跳转指令的成本可能很低，因为它们具有复杂的分支预测单元，任何额外的成本都可以通过使用基本块版本产生的更好的代码局部性来补偿。</p><p>  So far, I&#39;ve described approaches to support the implementation of method JITs for dynamic programming languages. Lazy basic block code generation could be one step towards implementing a  tracing JIT.</p><p>到目前为止，我&#39；我已经描述了支持动态编程语言方法JIT实现的方法。惰性基本块代码生成可能是实现跟踪JIT的一个步骤。</p><p> A tracing JIT records VM instructions that are usually executed in a hot loop, optimizes them, and generates machine code for them. The block diagram on the left side of Figure 6 shows an example of a loop execution, with the most frequently executed blocks filled with a dar</p><p>跟踪JIT记录通常在热循环中执行的VM指令，对它们进行优化，并为它们生成机器代码。图6左侧的方框图显示了一个循环执行的示例，最频繁执行的块中填充了dar</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072461.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fb508e6cf18e791c484b3c2c3c695664.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072461.html">代码审查方式</a></div><span class="my_story_list_date">2022-1-9 21:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072457.html"><img src="http://img2.diglog.com/img/2022/1/thumb_44cc3c562cfb3896f12902316e131f35.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072457.html">绕过门密码</a></div><span class="my_story_list_date">2022-1-9 21:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072403.html"><img src="http://img2.diglog.com/img/2021/8/thumb_85e5202f76bb0f0b03afa2d1ee761760.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072403.html">明天新 OpenAI 代码编写技术的现场演示</a></div><span class="my_story_list_date">2021-8-10 4:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072393.html"><img src="http://img2.diglog.com/img/2021/8/thumb_6b556d6fd050f0203839396803172378.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072393.html">联合国 IPCC 关于气候变化的报告听起来像是地球的“红色代码”</a></div><span class="my_story_list_date">2021-8-10 3:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>