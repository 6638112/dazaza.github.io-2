<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我有99个问题，一个分布式数据库不是一个</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我有99个问题，一个分布式数据库不是一个</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 01:02:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/69ef93455acd7d2aafcef4e201f773b2.jpeg"><img src="http://img2.diglog.com/img/2020/11/69ef93455acd7d2aafcef4e201f773b2.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Your company is growing steadily and so is your data. Everyday, you reap the benefits of data driven decisions and enjoy all the insights you get from that beefy database. Despite all the exciting things ahead, you can’t help but wonder how long this monolithic storage — this faithful Swiss knife — will continue to support your business needs.</p><p>您的公司正在稳步增长，您的数据也在稳步增长。每天，您都可以从数据驱动的决策中获益，并享受从这个强大的数据库中获得的所有洞察力。尽管前面有很多令人兴奋的事情，但您还是不禁想知道，这种单一的存储设备--这把忠实的瑞士刀--还能持续支持您的业务需求多久。</p><p> Maybe you already started to notice incre ased latency on certain workloads, or even faced downtime due to this single point of failure. You also know that you cannot store an infinite amount of data on a single, physical database, but you don’t intend to stop collecting it.</p><p>也许您已经开始注意到某些工作负载的延迟增加，甚至由于此单点故障而面临停机。您还知道不能在单个物理数据库上存储无限数量的数据，但是您不打算停止收集这些数据。</p><p> On a beautiful day, you then decide that it’s time to shop for a new, shiny Distributed Database System (DDBS), and you come up with this list of requirements:</p><p>在一个美好的日子里，您决定是时候购买一个新的、闪亮的分布式数据库系统(DDBS)了，然后您提出了以下需求列表：</p><p>  Uh-oh… I may have a bad news for you. The bad news is that you will never find a distributed database that can successfully optimize for all these properties simultaneously. On the other hand, by understanding the limitations of distributed systems as well as the specificities of your own data workloads, you will surely find a tradeoff that suits your needs.</p><p>啊哦…。我可能有个坏消息要告诉你。坏消息是，您永远找不到可以同时成功优化所有这些属性的分布式数据库。另一方面，通过了解分布式系统的限制以及您自己的数据工作负载的特殊性，您一定会找到适合您需要的折衷方案。</p><p> Let’s start by looking at inherent limitations of distributed systems, with the help of 2 theorems.</p><p>让我们借助于2个定理，从研究分布式系统的固有局限性开始。</p><p>    If you are like me, reading this theorem probably didn’t enlighten you that much. To have a better understanding of its implications on the design of distributed systems, let’s first rephrase the 3 properties for mere mortals.</p><p>如果你和我一样，阅读这个定理可能不会给你太多启发。为了更好地理解它对分布式系统设计的影响，让我们首先对凡人的3个属性进行重新表述。</p><p>    Here we have a simplistic DDBS comprised of 4 nodes. A user can send queries to the system via some interface that delegates the call to any database node. We also see that this system is facing a network partition — this temporary failure prevents nodes from each side of the partition to communicate with each other, so data synchronization between Node A and the others is not possible. On the other hand, Node A is still accessible from the interface, so a user could still query and update data from it. Here is where it becomes (a little bit) more interesting:</p><p>这里我们有一个由4个节点组成的简单的DDBS。用户可以通过某些接口向系统发送查询，该接口将调用委托给任何数据库节点。我们还可以看到，此系统正面临网络分区-此临时故障会阻止分区两端的节点相互通信，因此节点A与其他节点之间的数据同步是不可能的。另一方面，节点A仍然可以从界面访问，因此用户仍然可以从它查询和更新数据。下面是它变得(稍微)有趣的地方：</p><p> While data synchronization between some nodes is not possible, if you want your system to be  strongly consistent, you cannot allow writing to one side of the partition and querying from the other side, because you can end up with different versions of the same data point. This means you need to render unavailable one side of the partition and send read and write queries to the other side of the partition only. In that case, to be strongly consistent, your system forfeited  high availability.</p><p>虽然某些节点之间的数据同步是不可能的，但如果您希望您的系统保持高度一致，则不能允许写入分区的一侧并从另一侧进行查询，因为您最终可能会得到同一数据点的不同版本。这意味着您需要使分区的一侧不可用，而只向分区的另一侧发送读写查询。在这种情况下，为了保持高度一致，您的系统丧失了高可用性。</p><p> While data synchronization between some nodes is not possible, if you want your system to be  highly available,  thus don’t have to drop requests, you need to allow reading and writing to both sides of the partition. This can lead to inconsistent responses, depending what side of the partition handles the requests. To be highly available, your system forfeited  strong consistency.</p><p>虽然某些节点之间的数据同步是不可能的，但如果您希望系统高度可用，从而不必丢弃请求，则需要允许对分区两端进行读写。这可能会导致响应不一致，具体取决于分区的哪一侧处理请求。为了实现高可用性，您的系统失去了很强的一致性。</p><p>  Now, the “2 out of 3” thing is misleading for various reasons (and Dr. Brewer acknowledged that in his follow up paper   CAP Twelve Years Later: How the “Rules” Have Changed ). If your distributed system continues to operate during a network partition, you have the “P” property by default (hooray). When designing your system, you definitely want it to work under such circumstances, so your choice is truly between “C” and “A” only.</p><p>现在，由于各种原因，“三分之二”的说法具有误导性(布鲁尔博士在他12年后的后续论文“CAP：”规则“如何改变”中承认了这一点)。如果您的分布式系统在网络分区期间继续运行，则默认情况下您具有“P”属性(万岁)。在设计您的系统时，您肯定希望它在这样的情况下工作，因此您只能在“C”和“A”之间做出真正的选择。</p><p> Another useful thing to note is the asymmetry of this Consistency vs Availability tradeoff. The  strong consistency property is something that you can  guarantee, in the sense that you can design your system to always be strongly consistent. Adversely, your system can never  guarantee high availability. This property is typically measured in uptime in “number of nines”, and no system can guarantee 100% uptime.</p><p>需要注意的另一件有用的事情是这种一致性与可用性权衡的不对称性。强一致性属性是您可以保证的，从这个意义上说，您可以将系统设计为始终保持强一致性。相反，您的系统永远不能保证高可用性。此属性通常以“9的数量”来衡量正常运行时间，任何系统都不能保证100%的正常运行时间。</p><p> Finally, the CAP theorem only deals with distributed systems facing network partitions, and does not say anything about tradeoffs in a normal regime. Considering the popularity of cloud providers such as AWS, GCP and Azure, and that network partitions are less frequent now that we stopped hosting stuff in our grandmother’s basement, tradeoffs during normal regime should be the main driver of the design of our systems.</p><p>最后，CAP定理只处理面向网络分区的分布式系统，而没有说明正常情况下的权衡。考虑到AWS、GCP和Azure等云提供商的流行，以及由于我们不再在祖母的地下室托管东西，网络分区变得不那么频繁，正常制度下的权衡应该是我们系统设计的主要驱动因素。</p><p> This brings me to the PACELC theorem, which is an extension of CAP that also states necessary tradeoffs when there are no network partitions.</p><p>这就引出了PACELC定理，它是CAP的扩展，也说明了在没有网络分区时的必要权衡。</p><p>  Interestingly enough, it seems like the PACELC theorem went a bit unnoticed, despite being more practical than CAP and giving more general insights on the limitations of distributed systems.</p><p>足够有趣的是，PACELC定理似乎没有引起注意，尽管它比CAP更实用，并且对分布式系统的限制提供了更一般的见解。</p><p> We can summarize it that way: Under a network  Partition, the distributed database system needs to choose between  Availability or  Consistency (based on CAP).  Else (under normal condition), it needs to find a tradeoff between  Latency and  Consistency.</p><p>我们可以这样总结：在网络分区下，分布式数据库系统需要在可用性和一致性(基于CAP)之间做出选择。否则(在正常情况下)，它需要在延迟和一致性之间找到折衷。</p><p>  In the paper   Consistency Tradeoffs in Modern Distributed Database System Design , its author Daniel J. Abadi explains it that way:</p><p>在“现代分布式数据库系统设计中的一致性权衡”一文中，作者丹尼尔·J·阿巴迪这样解释：</p><p> As soon as a DDBS replicates data, a tradeoff between consistency and latency arises. This occurs because there are only three alternatives for implementing data replication: the system sends data updates to all replicas at the same time, to an agreed-upon master node first, or to a single (arbitrary) node first. The system can implement each of these cases in various ways; however, each implementation comes with a consistency/latency tradeoff.</p><p>一旦DDBS复制数据，就会在一致性和延迟之间进行权衡。这是因为实现数据复制只有三种替代方案：系统同时向所有副本发送数据更新，首先向商定的主节点发送数据更新，或者首先向单个(任意)节点发送数据更新。系统可以以各种方式实现其中的每一种情况；但是，每种实现都有一致性/延迟权衡。</p><p>  John changes his username from  Master Pain to  Betty (Kung Pow reference, you are welcome) by sending a write request to the DDBS, and Node A handles it.</p><p>John通过向DDBS发送写请求将其用户名从Master Pain更改为Betty(Kung Pow Reference，欢迎使用)，由Node A处理。</p><p> Reminder: if you want your system to be strongly consistent, it means that all subsequent requests that users make to retrieve John’s username should return  Betty, even if Node B, C or D handle them.</p><p>提醒：如果您希望您的系统具有很强的一致性，这意味着用户检索John用户名的所有后续请求都应该返回Betty，即使Node B、C或D处理这些请求也是如此。</p><p> For this to be true, a possibility is to only let Node A serve the subsequent read requests until Node B, C and D have been fully synchronized. This will incur additional latency to users that are physically far away from Node A.</p><p>为了实现这一点，一种可能是在节点B、C和D完全同步之前，仅让节点A服务于后续的读请求。这将给物理上远离节点A的用户带来额外的延迟。</p><p> Another possibility is to wait for Node B, C and D to be fully synchronized with Node A before letting anyone query John’s username. In that case, additional latency is also incurred.</p><p>另一种可能是等待节点B、C和D与节点A完全同步后，再让任何人查询John的用户名。在这种情况下，还会产生额外的延迟。</p><p> A mix of the 2 previous options is also possible: a  quorum protocol (see Paxos or Raft) could ensure that a certain number of replicas have been updated before allowing to read John’s username. In that case, latency is inherent to the protocol, and the tradeoff of synchronous vs asynchronous replica updates still holds.</p><p>前面两个选项的混合也是可能的：法定协议(参见Paxos或RAFT)可以确保在允许读取John的用户名之前已经更新了一定数量的副本。在这种情况下，延迟是协议固有的，同步和异步副本更新之间的权衡仍然有效。</p><p> Of course, if instead you want your system to be as low latency as possible, it’s very intuitive to see that you cannot afford to wait for all replicas to be synchronously updated before allowing subsequent read requests. You can certainly improve your write throughput by not waiting for a complete synchronization, but you also lose your guarantee of data consistency. If Node A takes care of updating John’s username but your system does not wait for other nodes to be up-to-date before allowing reads to this record, some users quickly asking for his username might get  Master Pain, while others get  Betty.</p><p>当然，如果相反，您希望您的系统尽可能低延迟，那么您就会非常直观地看到，您不能在允许后续读取请求之前等待所有副本同步更新。您当然可以通过不等待完全同步来提高写入吞吐量，但您也会失去数据一致性的保证。如果节点A负责更新John的用户名，但您的系统不等待其他节点更新后才允许读取此记录，则一些快速请求他的用户名的用户可能会得到Master Pain，而另一些用户可能会得到Betty。</p><p> In short, the main takeaway from this theorem is that  under normal conditions, your DDBS can be both highly available and strongly consistent,  but aiming for more consistency necessarily results in increased latency. This is where a good understanding of your business requirements, as well as the nature of your data workloads, will help you choose the right latency/consistency tradeoff. That being said, let’s dive a bit more deeper into this consistency property.</p><p>简而言之，这个定理的主要结论是，在正常情况下，您的DDBS既可以是高可用性的，也可以是强一致性的，但是追求更多的一致性必然会导致延迟的增加。这就是很好地了解您的业务要求以及数据工作负载的性质将帮助您选择正确的延迟/一致性权衡的地方。也就是说，让我们更深入地研究这个一致性属性。</p><p>  The latency/consistency tradeoff is not only limited to distributed database systems. In fact, a lot of transactional databases like PostgreSQL and MySQL are also designed with this tradeoff at their core, and they provide configurable  isolation levels that directly impact this tradeoff.</p><p>延迟/一致性权衡不仅限于分布式数据库系统。事实上，许多事务性数据库(如PostgreSQL和MySQL)也是以这种权衡为核心进行设计的，它们提供了直接影响这种权衡的可配置隔离级别。</p><p> Here is a trick question to introduce the different isolation levels. Let’s say you have the following  users table:</p><p>这里有一个刁钻的问题来介绍不同的隔离级别。假设您有以下用户表：</p><p>  And you run this transaction that selects all usernames, then waits for 1 minute and re-selects them before returning the results:</p><p>然后运行此事务，选择所有用户名，然后等待1分钟，并在返回结果之前重新选择它们：</p><p>   Another one starts to rename  McSwinster to  BigShot, but does not have time to commit before the initial query returns, and</p><p>另一个开始将McSwinster重命名为Bigshot，但在初始查询返回之前没有时间提交，并且。</p><p> At last, I ask you my one million dollar question: what result can we expect from that  SELECT request up there? The answer is… it depends on the isolation level you set to your database!!1!</p><p>最后，我要问您一个价值一百万美元的问题：我们能从上面的SELECT请求中期待什么结果呢？答案是…。这取决于您为数据库设置的隔离级别！！1！</p><p> Basically, the isolation level determines to what extent a transaction is visible to the outside world. Stronger isolation means stronger data integrity, but also higher latency. Weaker isolation means better throughput, but you are vulnerable to anomalies and inconsistencies. More specifically  dirty reads (can query uncommitted data),  non-repeatable reads (rows getting queried change during the transaction), and  phantom reads (while records are being read by a transaction, new rows can be added or removed concurrently that affect the result).</p><p>基本上，隔离级别决定了事务在多大程度上对外部世界可见。更强的隔离意味着更强的数据完整性，但也意味着更高的延迟。较弱的隔离意味着更高的吞吐量，但您很容易受到异常和不一致的影响。更具体地说，脏读(可以查询未提交的数据)、不可重复读(事务期间查询的行发生变化)和幻影读(当事务读取记录时，可以同时添加或删除影响结果的新行)。</p><p>  This is equivalent to “no isolation”. Read uncommitted means that reading or writing to a table does not lock the records you are interacting with. A concurrent write request could overwrite the rows you are currently trying to update, and you can read “dirty” rows that have been updated but not yet committed. You can guess that not supporting isolated transactions at all means concurrent queries don’t have to wait for locks, thus optimizing latency. On the flip side, this isolation level is prone to dirty reads, non-repeatable reads and phantom reads, which makes a lot more to handle at the application level. Regarding the trick question above, a system configured with this isolation level would have returned  [Sally, BigShot, LucieLajoie].</p><p>这相当于“没有隔离”。未提交读意味着读取或写入表不会锁定您正在与之交互的记录。并发写请求可能会覆盖您当前尝试更新的行，并且您可以读取已更新但尚未提交的“脏”行。您可以猜测，完全不支持隔离事务意味着并发查询不必等待锁，从而优化了延迟。另一方面，此隔离级别容易出现脏读、不可重复读和幻影读，这使得在应用程序级别需要处理更多内容。关于上面的刁钻的问题，配置了这个隔离级别的系统会返回[Sally，Bigshot，LucieLajoie]。</p><p>  Read committed provides more data consistency than read uncommitted, by locking rows during updates. This prevents dirty reads by only allowing reads on records that have been committed. On the other hand, read requests do not lock the data items involved, so such system is prone to non-repeatable reads and phantom reads. In our scenario, a database with this isolation level would have returned  [Sally, McSwinster, LucieLajoie]. This is the default isolation level for PostgreSQL and Oracle Database, for instance.</p><p>通过在更新期间锁定行，“已提交读”比“未提交读”提供了更多的数据一致性。这通过仅允许对已提交的记录进行读取来防止脏读取。另一方面，读请求不会锁定所涉及的数据项，因此这样的系统容易出现不可重复读取和幻影读取。在我们的场景中，具有此隔离级别的数据库将返回[Sally，McSwinster，LucieLajoie]。例如，这是PostgreSQL和Oracle数据库的默认隔离级别。</p><p>  Locks are obtained for both read and write requests. This is a more consistent upgrade over read committed that does not allow to update records that are being read by a concurrent transaction. This isolation level is only prone to phantom reads, because records can still be added while your select query is in progress. In our scenario, a database configured that way would have returned  [Betty, McSwinster, LucieLajoie]. This is the default isolation level for MySQL, for instance.</p><p>读取和写入请求都会获得锁定。这是对READ COMMITTED进行的更一致的升级，不允许更新并发事务正在读取的记录。此隔离级别仅易于进行幻影读取，因为在您的SELECT查询正在进行时，仍然可以添加记录。在我们的场景中，以这种方式配置的数据库将返回[Betty，McSwinster，LucieLajoie]。例如，这是MySQL的默认隔离级别。</p><p>  Records are locked during read and write queries, as well as  access structures, like indexes. This prevents records from being added while a concurrent read query targeting matching records is in progress (like our addition of  LucieLajoie while the read has not yet returned). A database with that isolation level is then free from dirty reads, non-repeatable reads and phantom reads, but keeps on granting locks like there is no tomorrow, which negatively affects latency. In our scenario, this isolation level would have yielded the following result set:  [Betty, McSwinster]. This is the default isolation level for VoltDB, for instance.</p><p>记录在读写查询以及访问结构(如索引)期间被锁定。这可以防止在针对匹配记录的并发读取查询正在进行时添加记录(就像我们在读取尚未返回时添加LucieLajoie一样)。然后，具有该隔离级别的数据库不会出现脏读、不可重复读和幻象读，但会继续授予锁，就像没有明天一样，这会对延迟产生负面影响。在我们的场景中，此隔离级别将生成以下结果集：[Betty，McSwinster]。例如，这是VoltDB的默认隔离级别。</p><p> A lot of use cases could justify using each of these 4 isolation levels. Once again, the best option for you directly depends on your business area, service level agreement and workloads.</p><p>许多用例可以证明使用这4个隔离级别是合理的。同样，您的最佳选择直接取决于您的业务区域、服务级别协议和工作负载。</p><p>  Now that we have a better understanding of how Consistency, Availability and Latency are interrelated, let’s take a look at a simple case where one wants to go from a monolithic PostgreSQL database to a distributed one using native replication. Despite being one of the simplest DDBS example I could choose, it is a very common one, and it illustrates well the inability to optimize all properties simultaneously, which holds true for all distributed systems.</p><p>现在，我们已经更好地理解了一致性、可用性和延迟是如何相互关联的，让我们来看一个简单的案例，在这个案例中，我们希望使用本机复制从单一的PostgreSQL数据库转变为分布式数据库。尽管它是我能选择的最简单的DDBS示例之一，但它是一个非常常见的示例，它很好地说明了无法同时优化所有属性，这适用于所有分布式系统。</p><p> Let’s say you have a single PostgreSQL database and its failure would render your whole application unavailable. This thought would surely prevent you from sleeping, but luckily you know that PostgreSQL supports synchronizing write transactions to other databases using native   streaming replication. In short, all write requests go to a database called the  primary, and those transactions are replayed to other read-only  replicas by streaming the write-ahead logging records.</p><p>假设您有一个PostgreSQL数据库，它的故障将导致整个应用程序不可用。这种想法肯定会让您睡不着觉，但幸运的是，您知道PostgreSQL支持使用本地流复制将写事务同步到其他数据库。简而言之，所有写请求都会转到一个名为主数据库的数据库，并且通过流式传输预写日志记录，将这些事务重放到其他只读副本。</p><p>   On the other hand — and I hope this starts to become more and more obvious — you don’t get these benefits without sacrificing something else! Depending on how you choose to replicate data from the primary to the replicas, you will either  increase write latency, or  forfeit strong consistency:</p><p>另一方面-我希望这一点开始变得越来越明显-你不牺牲其他东西就得不到这些好处！根据您选择将数据从主服务器复制到复制副本的方式，您可能会增加写入延迟，也可能会丧失很强的一致性：</p><p> Synchronous replication: write transaction is considered complete only when it has been copied to all replicas. This will definitely  increase your write latency, as your system becomes as slow as your slowest node. Note that PostgreSQL supports 2 types of synchronous replications, each of them having its latency/consistency tradeoffs.</p><p>同步复制：仅当写入事务已复制到所有副本时，才将其视为完成。这肯定会增加您的写入延迟，因为您的系统变得与最慢的节点一样慢。请注意，PostgreSQL支持两种类型的同步复制，每种类型都有其延迟/一致性权衡。</p><p> Asynchronous replication: you write transaction completes as soon as the primary DB considers it done, without any guarantee about the state of this data item on the replicas. This will render your system  eventually consistent, as you cannot guarantee that all replicas will return the latest version of the data.</p><p>异步复制：只要主数据库认为事务已经完成，您就可以写入事务，而不会对副本上该数据项的状态提供任何保证。这将使您的系统最终保持一致，因为您不能保证所有副本都将返回最新版本的数据。</p><p> If you are instead looking for  low write latency or  increased storage capacity and still want to stick with PostgreSQL, there is no native solution to that problem, but you might want to check available PostgreSQL extensions like  Citus. Again, you’ll have to pick your poison because other tradeoffs are in sight.</p><p>如果您正在寻找低写入延迟或更大的存储容量，并且仍然希望使用PostgreSQL，那么这个问题没有本机解决方案，但是您可能希望检查可用的PostgreSQL扩展，如CUTUS。再一次，你将不得不选择你的毒药，因为其他的权衡已经近在眼前。</p><p> All that being said, what is the best configuration, you ask me? Well, this is entirely dependant on your specific use case, so you tell me! On the bright side, you now know what to expect from such distributed systems and won’t be taken by surprise when optimizing for one property negatively impacts some others.</p><p>话虽如此，你问我最好的配置是什么？嗯，这完全取决于您的特定用例，所以您来告诉我！好的一面是，您现在知道了这样的分布式系统会带来什么，当针对一个属性进行优化会对其他一些属性产生负面影响时，您不会感到意外。</p><p>  Life is short and there are lots of other subjects I would have liked to discuss here. I first wanted to shed some light on the Consistency vs Availability vs Latency tradeoffs at the heart of distributed systems, as I felt this was not common knowledge for a lot of software engineers. On another note, it seems like these tradeoffs get completely set aside by database marketers. Be it Aurora, Redshift, DynamoDB, Spanner, or FaunaDB , their documentation rarely states the necessary tradeoffs implied in their design. For example, to figure out that using Multi-AZ deployments (synchronous replication of data across availability zones) in Amazon RDS will negatively impact your write throughput, you really need to be actively looking for  one single sentence in their documentation.</p><p>生命是短暂的，我还有很多其他的话题想在这里讨论。我首先想阐明分布式系统核心的一致性、可用性和延迟权衡，因为我觉得这对许多软件工程师来说并不是常识。另一方面，数据库营销者似乎完全搁置了这些权衡。无论是Aurora、RedShift、DynamoDB、Spanner还是FaunaDB，它们的文档很少说明其设计中隐含的必要权衡。例如，要确定在Amazon RDS中使用多AZ部署(跨可用区同步复制数据)会对您的写入吞吐量产生负面影响，您确实需要在他们的文档中积极查找一句话。</p><p> Once that is well understood, and considering you want to further your knowledge on the topic of DDBS, what should you be looking for next?</p><p>一旦很好地理解了这一点，并考虑到您想要进一步了解DDBS的主题，您接下来应该寻找什么？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/@olfal/ive-got-99-problems-and-a-distributed-database-ain-t-one-70977de7896c">https://medium.com/@olfal/ive-got-99-problems-and-a-distributed-database-ain-t-one-70977de7896c</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分布式/">#分布式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030615.html"><img src="http://img2.diglog.com/img/2020/10/thumb_69aa9f7bb5f5af253d1db30b98e61892.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030615.html">心理治疗中心数据库被黑，患者信息扣留赎金</a></div><span class="my_story_list_date">2020-10-23 1:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030433.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2b56f915518fb33f55f689b3337502bc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030433.html">你不需要区块链，你需要一个时间序列数据库</a></div><span class="my_story_list_date">2020-10-22 9:35</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029583.html"><img src="http://img2.diglog.com/img/2020/10/thumb_63ff8accedb5e54e6a85ac65caf21108.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029583.html">为您的数据库和存储获取免费备份服务</a></div><span class="my_story_list_date">2020-10-18 16:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029529.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1714270cceda55206ce1ec8c906025bd.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029529.html">我不小心删除了生产数据库</a></div><span class="my_story_list_date">2020-10-18 7:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>