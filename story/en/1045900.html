<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Haskell异常捕获调用堆栈 Capturing call stack with Haskell exceptions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Capturing call stack with Haskell exceptions<br/>使用Haskell异常捕获调用堆栈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 05:54:09</div><div class="page_narrow text-break page_content"><p>Recently I discovered a nice way to capture call stack in Haskell exceptions almost transparently, and I’m going to share it in this post</p><p>最近，我发现了一种几乎透明地捕获Haskell异常中的调用堆栈的好方法，我将在本文中与大家分享</p><p>    foo :: [a]  -&gt; a  foo []  =  error  &#34;impossible!&#34;  foo a :_  = a     bar :: [ Int]  -&gt; [ Int]  -&gt;  Int  bar a b  = foo a  + foo b</p><p>    foo :: [a]-＆gt; foo [] =错误＆＃34;不可能！＆＃34; foo a：_ =条形:: :: [Int]-＆gt; [Int]-＆gt;整数条a b = foo a + foo b</p><p>  λ &gt; bar [] []   ***  Exception : impossible !   CallStack (from  HasCallStack) :    error, called at stacks .hs : 4 : 10  in main : Main</p><p>  λ＞ bar [] [] ***例外：不可能！ CallStack（来自HasCallStack）：错误，在堆栈中调用。hs：4：10 in main：Main</p><p> Obviously, there is an error, but  GHCI also prints a peculiar thing: a call stack! It contains only one entry and isn’t helpful, though… So you go to  GHC manual to see what  HasCallStack the message is talking about, and there it is:   HasCallStack section.</p><p> 显然，这是一个错误，但是GHCI也打印出一个奇特的东西：调用堆栈！它仅包含一个条目，但是对您没有帮助。因此，您可以转到GHC手册，查看消息在谈论什么HasCallStack，它位于：HasCallStack部分。</p><p>  foo ::  HasCallStack  =&gt; [a]  -&gt; a  foo []  =  error  &#34;impossible!&#34;  foo a :_  = a     bar ::  HasCallStack  =&gt; [ Int]  -&gt; [ Int]  -&gt;  Int  bar a b  = foo a  + foo b</p><p>  foo :: HasCallStack =＆gt; [a]-＆gt; foo [] =错误＆＃34;不可能！＆＃34; foo a：_ =条形:: HasCallStack =＆gt; [Int]-＆gt; [Int]-＆gt;整数条a b = foo a + foo b</p><p>  λ &gt; bar [] []   ***  Exception : impossible !   CallStack (from  HasCallStack) :    error, called at stacks .hs : 6 : 10  in main : Main   foo, called at stacks .hs : 10 : 11  in main : Main   bar, called at  &lt;interactive &gt;: 5 : 1  in interactive : Ghci1</p><p>  λ＞ bar [] [] ***例外：不可能！ CallStack（来自HasCallStack）：错误，在堆栈上调用.hs：6：10在main：主foo中，在堆栈上调用.hs：10：11在main：主栏，在＆lt; interactive＆gt ;: 5：1中调用互动式：Ghci1</p><p> You get function names, module names and even source locations for all calls starting from the  ghci prompt down to the point where  error is called.</p><p> 从ghci提示到调用错误的位置，您可以获得所有调用的函数名称，模块名称甚至源位置。 </p><p> Remember, however, that stack is captured only as far from the  error call as there are  HasCallStack constraint. E.g., dropping the constraint from  foo will also exclude  bar from the log:</p><p>但是请记住，仅在有HasCallStack约束的情况下，才从错误调用中捕获该堆栈。例如，从foo中删除约束也会从日志中排除bar：</p><p> λ &gt; bar [] []   ***  Exception : impossible !   CallStack (from  HasCallStack) :    error, called at stacks .hs : 6 : 10  in main : Main</p><p> λ＞ bar [] [] ***例外：不可能！ CallStack（来自HasCallStack）：错误，在堆栈中调用.hs：6：10 in main：Main</p><p> Still, you get to know the precise location of the  error call, which is nice.</p><p> 不过，您仍然可以知道错误调用的确切位置，这很好。</p><p> Caveat:  head,  tail,  read and so on use   errorWithoutStackTrace (for performance reasons), so you won’t ever see stack traces from them. One more reason to avoid  head!</p><p> 注意：头，尾，读等使用errorWithoutStackTrace（出于性能原因），因此您永远不会看到来自它们的堆栈跟踪。避免头的另一原因！</p><p>  However, using  error to report errors is not very convenient: you can pass only a  String as an argument and so catching specific errors while propagating others becomes very hard and messy.</p><p>  但是，使用错误报告错误不是很方便：您只能传递一个String作为参数，因此在传播其他错误时捕获特定错误变得非常困难和混乱。</p><p> Fortunately, there is another mechanism in GHC for that: exceptions. So you define your custom exception type and throw it from the  foo function like this:</p><p> 幸运的是，GHC中还有另一种机制：异常。因此，您可以定义自定义异常类型，并通过foo函数将其抛出，如下所示：</p><p> data  FooException  =  FooException    deriving ( Show,  Exception)     foo ::  HasCallStack  =&gt; [a]  -&gt; a  foo []  = throw  FooException  foo a :_  = a     bar ::  HasCallStack  =&gt; [ Int]  -&gt; [ Int]  -&gt;  Int  bar a b  = foo a  + foo b</p><p> 数据FooException = FooException派生（显示，异常）foo :: HasCallStack =＆gt; [a]-＆gt; a foo [] =抛出FooException foo a：_ =条形:: HasCallStack =＆gt; [Int]-＆gt; [Int]-＆gt;整数条a b = foo a + foo b </p><p> You run it and expect to see the nice exception with a stack trace. But…</p><p>您运行它并期望看到带有堆栈跟踪的漂亮异常。但…</p><p>   The reason is that exceptions don’t capture the stack trace automatically, even when thrown from a place with  HasCallStack context. There is an  open issue to do so, reported back in 2016, but no progress was made yet.</p><p>   原因是，即使从具有HasCallStack上下文的地方抛出异常，异常也不会自动捕获堆栈跟踪。这样做有一个未解决的问题，早在2016年就报告过，但尚未取得任何进展。</p><p>  But what if we want to capture stack with exceptions? One possible way would be to save the stack (represented as   CallStack type) as part of the exception constructor, then make your custom  throwWithStack :: HasCallStack =&gt; Foo -&gt; IO () function and use it everywhere, but that is too cumbersome, and you may just forget to use the right throwing function.</p><p>  但是，如果我们想捕获异常堆栈呢？一种可能的方法是将堆栈（表示为CallStack类型）保存为异常构造函数的一部分，然后进行自定义throwWithStack :: HasCallStack =＆gt;。 Foo-＆gt; IO（）函数可以在任何地方使用它，但这太麻烦了，您可能只是忘记使用正确的throwing函数。</p><p> Fortunately, there is a better way. Recall that magic  HasCallStack constraint captures call stack from the point where something annotated with it is used. We don’t want to annotate  throw, but there is one more thing on the same line — exception constructor itself! It turns out, you can use GADTs to capture stack with an exception data:</p><p> 幸运的是，有更好的方法。回想一下神奇的HasCallStack约束从使用注释的点捕获调用栈。我们不想注释异常，但是同一行还有另外一件事-异常构造函数本身！事实证明，您可以使用GADT捕获具有异常数据的堆栈：</p><p>   instance  Show  FooException  where    show  FooException  =  &#34;FooException\n&#34;  &lt;&gt; prettyCallStack callStack     deriving anyclass  instance  Exception  FooException   -- alternatively, derive Show from stock and print call stack in &#39;displayException&#39; method.</p><p>   实例Show FooException，其中show FooException =＆＃34; FooException \ n＆＃34; ＆lt;＆gt; prettyCallStack callStack派生任何类实例Exception FooException-或者，从股票派生Show并在＆＃39; displayException＆＃39;中打印调用堆栈。方法。</p><p> Here  callStack is provided by  GHC.Stack and will use  HasCallStack constraint introduced by pattern match on  FooException GADT constructor.</p><p> 这里的callStack由GHC.Stack提供，将使用在FooException GADT构造函数上由模式匹配引入的HasCallStack约束。</p><p>  λ &gt; bar [] []   ***  Exception :  FooException   CallStack (from  HasCallStack) :    FooException, called at stacks .hs : 18 : 16  in main : Main   foo, called at stacks .hs : 22 : 11  in main : Main   bar, called at  &lt;interactive &gt;: 7 : 1  in interactive : Ghci1</p><p>  λ＞ bar [] [] ***异常：FooException CallStack（来自HasCallStack）：FooException，在堆栈处调用。hs：18：16 in main：Main foo，在堆栈处调用。hs：22：11 in main：Main bar，称为在＆lt; interactive＆gt;中：7：1在inactive：Ghci1中 </p><p> For another example, here is a real call stack I reproduced in our production code:</p><p>再举一个例子，这是我在生产代码中复制的真实调用堆栈：</p><p> Exception :  Operation timeout   CallStack (from  HasCallStack) :    TimeOut, called at src / Database / Bolt /Connection.hs : 38 : 36  in hasbolt - 0.1 . 4.3 -inplace : Database.Bolt.Connection   run, called at src / XXX / DB /Impl.hs : 42 : 43  in xxx - 0.3 . 5.0 -inplace : XXX.DB.Impl   runDB, called at src / XXX / DB /Impl.hs : 124 : 14  in xxx - 0.3 . 5.0 -inplace : XXX.DB.Impl   programs, called at src / XXX / API /Program.hs : 33 : 17  in xxx - 0.3 . 5.0 -inplace : XXX.API.Program</p><p> 例外：操作超时CallStack（来自HasCallStack）：超时，在src / Database / Bolt / Connection.hs处调用：hasbolt-0.1中的38:36。 4.3 -inplace：Database.Bolt.Connection运行，在xxx-0.3中以src / XXX / DB / Impl.hs：42:43调用。 5.0 -inplace：XXX.DB.Impl runDB，在src / XXX / DB / Impl.hs处调用：xxx-0.3中的124：14。 5.0 -inplace：XXX.DB.Impl程序，在src / XXX / API / Program.hs中调用：xxx-0.3中的33:17。 5.0 -inplace：XXX.API.Program</p><p>  HasCallStack is a magic constraint, so the fact that this trick works may or may not be a coincidence: some later change in GHC may stop GADT pattern match from affecting how  HasCallStack is solved. However, I think that this approach is useful enough and may be used in practice. Just don’t forget to add enough  HasCallStack to places which can fail.</p><p>  HasCallStack是一个魔术约束，因此此技巧起作用的事实可能是偶然的，也可能不是偶然的：GHC的某些后续更改可能会阻止GADT模式匹配影响HasCallStack的求解方式。但是，我认为这种方法足够有用，可以在实践中使用。只是不要忘记在可能出现故障的地方添加足够的HasCallStack。</p><p> Don’t forget, though, that  HasCallStack is not free and sometimes can break some optimizations, especially if used in recursive functions (that’s the reason  head &amp; friends do not capture the stack).</p><p> 不过，请不要忘记，HasCallStack不是免费的，有时会破坏某些优化，特别是在递归函数中使用时（这就是head＆amp; amp; friends不会捕获堆栈的原因）。</p><p> Of course, this post does nothing to help debugging standard exceptions, like  IOError. For that, the usual way is to build with  -prof and run your code with  +RTS -xc, as documented in  the manual.</p><p> 当然，这篇文章对调试IOError等标准异常没有任何帮助。为此，通常的方法是使用-prof进行构建，并使用+ RTS -xc运行代码，如手册中所述。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://maksbotan.github.io/posts/2021-01-20-callstacks.html">https://maksbotan.github.io/posts/2021-01-20-callstacks.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/调用/">#调用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/call/">#call</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>