<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>先发制人的多元化是（可能）不是邪恶的 Preemptive Pluralization Is (Probably) Not Evil</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Preemptive Pluralization Is (Probably) Not Evil<br/>先发制人的多元化是（可能）不是邪恶的 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 04:45:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/2e03a0b6c3a65fc372c2e924119bc7e8.jpg"><img src="http://img2.diglog.com/img/2021/3/2e03a0b6c3a65fc372c2e924119bc7e8.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Before you write any code — ask if you could ever possibly want multiple kinds of the thing you are coding. If yes, just do it. Now, not later.</p><p>在您编写任何代码之前 - 询问您是否可能想要您正在编码的多种类型。如果是的话，只是做到这一点。现在，不是稍后。</p><p>  You assume that one team has many users, and correspondingly, one user belongs to one team.  But you are depressed because you now have to  spend 2 months refactoring every line of code and database schema that assumed the one-to-one mapping 😱 More examples  here.</p><p>  您假设一个团队有许多用户，相应地，一个用户属于一个团队。但是，你受到沮丧，因为你现在必须花2个月重构每一系列代码和数据库模式，这是一个假定的一到一个映射😱这里的更多例子。</p><p>  You assume that loading state only has two states — true / false — so you make a boolean  isLoading variable  Then you realize you need to track error state, so you do, with  isError. You do some work to make sure the 4 combinations of states behave intuitively. You write tests for each of them like the good developer you are. Of course.</p><p>  您假设加载状态只有两个状态 - 真/假 - 所以您制作一个布尔上载变量，然后您实现了需要跟踪错误状态，因此您可以使用iSError。您可以做一些工作，以确保各国的4种组合直观行为。您可以为您的每个良好开发人员编写测试测试。当然。</p><p>    Eventually you realize every addition or modification takes  exponentially longer to account for each edge case. It&#39;s hard to even tell if you&#39;ve covered them all. Most don&#39;t.</p><p>    最终，您实现了每种添加或修改，以呈指数延长的时间才能考虑每个边缘案例。它＆＃39;甚至甚至讲你的＆＃39; ve and＃39;大多数Don＆＃39; t。</p><p>  The solution is  explicit state machines - but at this point you&#39;re too far in to justify a rewrite.</p><p>  该解决方案是明确的状态机 - 但此时你＆＃39; refe and and才能证明重写。</p><p>    Pagination. To quote  Simon Willison, co-creator of Django, &#34;Refactoring an existing non-paginated API to support pagination will break everything. Better to fake pagination but only ever return a single page, just in case&#34;.</p><p>    分页。 Quote Simon Wallison，Django的共同创建者，＆＃34;重构现有的非分名API来支持分页将打破一切。更好地假装分页，但只返回一个页面，以防万一。</p><p>  I&#39;ve done this refactoring a million times. I&#39;ll be like, I thought there would only ever be one subscription team, user plan, name, address , and it always ends up being like, &#34;Oh, actually there&#39;s more.&#34; I almost never go the other way. What if you just paid the upfront cost of thinking &#34;This is just always a collection&#34;?</p><p>  我完成了一百万次的重构。我＆＃39;我想，我认为只有一个订阅团队，用户计划，姓名，地址，它总是如此，＆＃34;哦，实际上有更多。＆＃ 34;我几乎永远不会去另一种方式。如果你刚刚支付思维＆＃34的前期成本怎么办;这只是一个集合＆＃34 ;? </p><p> Donald Knuth is famous for noting that  Premature Optimization is the Root of All Evil (there&#39;s  some nuance to that, btw). I am very sympathetic to the appeal to simplicity — if &#34;You Ain&#39;t Gonna Need It&#34;, then don&#39;t use it. But I think  Preemptive Pluralization — projecting forward into hypothetical situations when you need N types of a thing — is exempt, even though you are literally optimizing for a future you don&#39;t currently live in.</p><p>唐纳德Knuth着名，因为注意到的过早优化是所有邪恶的根源（其中有一些细微差别，BTW）。我非常同情对简单性的吸引力 - 如果＆＃34;你是AIN＆＃39; t将需要它＆＃34;然后不要使用它。但我认为先发制人的多元化 - 当你需要n种类型的东西时，突出到假设的情况 - 豁免，即使你对未来的优化，你不会＆＃39;目前居住。</p><p> It is a LOT easier to scale code from a cardinality of 2 to 3 than it is to refactor from a cardinality of 1 to 2. This is a fundamentally under-appreciated nonlinearity. In other words, Preemptive Pluralization can make the difference between &#34;sure, I&#39;ll add that today&#34; and &#34;this is going to take us 2 months and we&#39;ll introduce merge conflicts with every other in-progress feature.&#34;</p><p> 从2到3的基数比为1至2的基数，从2到3的基数缩放代码更容易。这是一个从根本上不受欢迎的非线性。换句话说，先发制人的多元化可以使＆＃34之间的差异有所不同;当然，我＆＃39; ll今天补充说，今天和＃34;和＃34;这将带我们2个月，我们＆＃39; LL与其他所有正在进行的进展功能介绍合并冲突。＆＃34;</p><p> Requirements volatility is a core problem of software engineering. As a software engineer, writing code that does what you ask of it today is the bare minimum. Your real skill comes in what happens next — what you do when requirements inevitably change, whether by new feature request or scaling issues arising from I/O or compute bounds.</p><p> 要求波动性是软件工程的核心问题。作为一个软件工程师，编写您今天要求的代码是最少的。您的真实技能会发生在接下来的情况下 - 当需求不可避免地改变时，无论是通过I / O或计算界限引起的新功能请求还是缩放问题所做的事情。</p><p>  It may not be enough to write code for what you foresee in the near term — those are just more requirements. Software design and architecture is all about making it  easy to respond to  unforeseen changes.</p><p>  对于您在近期预见的内容来写代码可能不够 - 这些是更多的要求。软件设计和架构是关于使不可预见的更改的响应容易。</p><p>  Hillel Wayne has proposed calling these  requirement perturbations. If a small, typical feature request can throw your whole design out of whack, then you have  fragile code. Clearly you want the opposite of fragile — I am tempted to call it &#34;Antifragile&#34; because that gets clicks — but really the best you can hope for is code that mostly doesn&#39;t fall apart due to 1-2 standard deviation changes in requirements. In other words:  robust code. Robust code is  optimized for change (more in a future blogpost).</p><p>  Hillel Wayne提出了这些要求扰动。如果一个小的，典型的特征请求可以丢弃你的整个设计，然后你有脆弱的代码。显然你想要脆弱的对面 - 我很想打电话给它＆＃34;抗皱＆＃34;因为那里点击 - 但是真的最好的是你能希望的代码是大多数＆＃39; t由于1-2要求的标准偏差变化而崩溃。换句话说：强大的代码。强大的代码针对变更进行了优化（在未来的博客中更多）。</p><p>  The nonlinearity in how expensive it is to make a change comes from the &#34; emergent sclerosis&#34; of code. Code that is robust to future changes is far cheaper to write today, than when written later, as delayed technical debt that you must pay up before you can proceed to a feature request. Fragile code is like the payday loan lender of technical debt.</p><p>  非线性在如何昂贵，改变来自＆＃34;紧急硬化和＃34;代码。对未来变化具有强大的代码，今天写入比在稍后写入时，您必须在您必须在进行功能请求之前支付的延迟技术债务。脆弱的代码就像是发薪日贷款贷款人的技术债务。</p><p> I&#39;m so committed to not prematurely optimizing that I want to make a final pitch for why Preemptive Pluralization is not premature. Let&#39;s address two obvious criticisms of Preemptive Pluralization:</p><p> 我如此致力于过早地优化我想做最终的音高，为什么先发制人的多元化不足。让＆＃39;解决了对先发制人的多元化的两个明显的批评： </p><p>  Increased code complexity: Functional languages and other abstractions can help make array or matrix operations almost as easy to work with as regular operations.</p><p>增加的代码复杂性：功能语言和其他抽象可以帮助使阵列或矩阵操作变得易于使用作为常规操作。</p><p>  Slow performance from doing extra loops: Loops only cost significantly when you have lots of N. By definition, if you are pluralizing prematurely, N = 1.</p><p>  额外循环的性能缓慢：当您有很多N的情况下，循环只能成本显着。根据定义，如果您是过早的，N = 1。</p><p>  Ultimately I think what makes something premature or not is your definition of what you need to write. If you view &#34;code that works today&#34; as your job, preemptive pluralization is premature. If you view &#34;code that doesn&#39;t blow up in my face a year from now&#34; as your job, then it is not.</p><p>  最终，我认为是什么让某些东西过早或不是您对所需的定义。如果您查看＆＃34;今天工作的代码＆＃34;作为你的工作，先发制人的多元化是早产。如果您浏览＆＃34;从现在＆＃34的一年中爆炸＆＃39的代码。作为你的工作，那不是。</p><p>    Number of clouds in your company (you think you will avoid this... until you can&#39;t, per  the Hashimoto lemma)</p><p>    贵公司中的云数（您认为您将避免这种情况......直到您可以＆＃39; t，每个Hashimoto lemma）</p><p> Thanks to  Jon Wong for reviewing a draft of this post and contributing the boolean and internationalization examples</p><p> 感谢Jon Wong进行审查此帖子的草案并促成布尔和国际化的例子</p><p>        Jared Palmer and  Daniel Yokomizo mention the  Zero one infinity rule - though this article argues FOR preemptively favoring &#34;infinity&#34; over &#34;one&#34;</p><p>        Jared Palmer和Daniel Yokomizo提到零一个无限统治 - 虽然本文争辩于先发制人的青睐和＃34;无限＆＃34;过度＆＃34;一个＆＃34;</p><p>  Disclosures    :  This is an idea I have been mulling for a while, but have not practiced at scale. Written in a couple hours after a prompt from a podcast.</p><p>  披露：这是我一直在仔细考虑一段时间的想法，但尚未以规模实行。在从播客的提示之后写的几个小时。 </p><p>      Tweet about this post  and it will show up here, or you could  leave a comment on Dev.to</p><p>关于这篇文章的推文，它将在这里出现，或者您可以在dev.to上发表评论 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.swyx.io/preemptive-pluralization/">https://www.swyx.io/preemptive-pluralization/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/多元化/">#多元化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>