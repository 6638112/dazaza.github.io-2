<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>苹果M1和英特尔AVX512上的基准划分和Libdivide Benchmarking division and libdivide on Apple M1 and Intel AVX512</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Benchmarking division and libdivide on Apple M1 and Intel AVX512<br/>苹果M1和英特尔AVX512上的基准划分和Libdivide </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 03:41:43</div><div class="page_narrow text-break page_content"><p>libdivide is  fish’s library for speeding up integer division by runtime constants. It works by replacing divide instructions with cheaper multiplications and shifts.</p><p>Libdivide是Fish的库，用于通过运行时常量加快整数划分。它通过用更便宜的乘法和班次替换划分说明来工作。</p><p> libdivide supports SIMD, and recently gained support for AVX-512 and ARM NEON. Let’s benchmark on an Intel Xeon and Apple’s M1.</p><p> Libdivide支持SIMD，最近对AVX-512和ARM NEON的支持。让我们在英特尔Xeon和Apple的M1上进行基准。</p><p>   uint32_t  sumq ( const  uint32_t  * vals ,  size_t  count ,  uint32_t  d )  {  uint32_t  sum  =  0 ;  for  ( size_t  i = 0 ;  i  &lt;  count ;  i ++ )  sum  +=  vals [ i ]  /  d ;  // this division is the bottleneck  return  sum ; }</p><p>   uint32_t sumq（const uint32_t * vals，size_t count，uint32_t d）{uint32_t sum = 0; for（size_t i = 0; i＆lt;计数; i ++）sum + = vals [i] / d; //这个司是瓶颈退货总和; }</p><p> The execution time of this function is dominated by the divide. It may be optimized with libdivide:</p><p> 此函数的执行时间由鸿沟主导。它可以用libdivide优化：</p><p> uint32_t  sumq ( const  uint32_t  * vals ,  size_t  count ,  uint32_t  d )  {  libdivide :: divider &lt; uint32_t &gt;  div ( d );  uint32_t  sum  =  0 ;  for  ( size_t  i = 0 ;  i  &lt;  count ;  i ++ )  sum  +=  vals [ i ]  /  div ;  // faster libdivide division  return  sum ; }</p><p> uint32_t sumq（const uint32_t * vals，size_t count，uint32_t d）{libdivide :: divider＆lt; uint32_t＆gt; div（d）; uint32_t sum = 0; for（size_t i = 0; i＆lt;计数; i ++）sum + = vals [i] / div; //更快的Libdivide Divion Return Sum; }</p><p> This is typically 2-10x faster, depending on  d and  count. It also unlocks vectorization for even more speedup -  example.</p><p> 这通常是2-10x的速度更快，取决于D和计数。它还解锁了矢量化，以便更加加速 - 示例。</p><p> The times below measure the above loop with  d=7 (a “slow case”) and  count=524k. The loop is repeated 30 times, and the best (fastest) result is kept.   1</p><p> 以下时间用D = 7测量上述环路（“慢速案例”）和计数= 524K。循环重复30次，保持最佳（最快）结果。 1 </p><p>  Times are nanoseconds per divide, and a percentage improvement compared to hardware (i.e.  udiv instruction). Lower is better.</p><p>与硬件相比，次数是每分的纳秒和百分比改进（即UDIV指令）。较低更好。</p><p>   AVX512 is twice the width of AVX2 but only marginally faster. Speculatively, AVX512 processes multiplies serially, one 256-bit lane at a time, losing half its parallelism.</p><p>   AVX512是AVX2宽度的两倍，但仅略微更快。首先，AVX512在一次串联，一个256位通道的过程中乘以一半的并行性。</p><p> libdivide must use 32x32-&gt;64 muls ( mul_epu32) for vectorized 64 bit, incurring the 4x penalty   2. We would expect to break even at AVX2, which has 4x parallelism; instead AVX2 is faster than scalar, perhaps because a 32 bit multiply is faster than 64 bit.</p><p> Libdivide必须使用32x32-＆gt; 64 Muls（Mul_epu32）为矢量化64位，招致4x罚款2.即使在具有4倍并行性的AVX2中也希望打破。相反，AVX2比标量快，也许是因为32位乘以比64位更快。</p><p>    The M1 is 10x faster than the Xeon at 64 bit divides. It’s…just wow.</p><p>    M1比64位划分的Xeon快10倍。它是......只是哇。</p><p> The hardware division time of 0.624 nanoseconds is a clean multiple of 3.2 GHz, suggesting a throughput of 2 clock cycles per divide. That is remarkable: hardware dividers are typically variable-latency and hard to pipeline, so 30+ clock cycles per divide is common. Does the M1 have more than one integer division unit per core?</p><p> 0.624纳秒的硬件分割时间是3.2 GHz的干净倍数，表明每分的2个时钟周期的吞吐量。这是显着的：硬件分隔器通常是可变的延迟，并且难以向管道，因此每分的30+时钟周期是常见的。 M1每个核心有多个整数分部单位吗？</p><p> Amusingly, scalar 64 bit is faster than scalar 32 bit. This is because AARCH64 has a dedicated instruction for 64 bit high multiplies ( umulh), while 32 bit high multiplies are performed with a 64 bit low multiply ( umull), followed by a right shift.</p><p> 有趣地，标量64位比标量32位更快。这是因为AARCH64具有64位高乘数（UMULH）的专用指令，而32位高乘数以64位低乘法（Umull）执行，然后进行右移。</p><p> NEON with u32 allows four 32-bit high-multiplies with only two  umull instructions ( godbolt). So NEON u32 should be nearly twice as fast as scalar; in fact it is even faster, probably because of amoritized fixed costs (branches, etc).</p><p> 带有U32的霓虹灯允许只有两个Umull指令（Godbolt）的四个32位高倍增。所以霓虹灯U32应该是标量的几乎是速度的两倍;事实上，它甚至更快，可能是因为有态度的固定成本（分支等）。 </p><p> NEON with u64 is slower because its multiplier is not wide enough, so it incurs the 4x penalty   2, and its skinny vector only offers 2x parallelism. (Nevertheless it still may be useful as part of a larger sequence, to keep data in vector registers.)</p><p>与U64的霓虹灯较慢，因为它的乘数不够宽，因此它会引发4X罚款2，其瘦载体仅提供2倍并行性。 （尽管如此，它仍然可能是较大序列的一部分，以将数据保持在矢量寄存器中。）</p><p>  libdivide is still quite effective at speeding up integer division, even with the M1’s fast divider. Vectorization greatly improves 32 bit, and is a mixed bag for 64 bit, but still faster than hardware.</p><p>  即使使用M1的快速分频器，Libdivide仍然非常有效地加快整数划分。矢量化大大改善了32位，并且是64位的混合袋，但仍然比硬件更快。</p><p>  Why is AVX512 only slightly faster than AVX2? Are the umuls are serialized per-lane, is it downclocking?</p><p>  为什么AVX512只略微比AVX2略快？ umuls是每巷序列化，是它倒下吗？</p><p>  How is Apple M1 able to achieve a throughput of .5 divides per cycle? Is the hardware divider pipelined, is there more than one per core?</p><p>  Apple M1如何实现每个周期的.5划分的吞吐量？硬件分频器流水线，是否有超过每个核心？</p><p>   The results were collected using libdivide’s  benchmark tool. You can run it yourself:</p><p>   使用Libdivide的基准工具收集结果。你可以自己运行：</p><p> git clone https://github.com/ridiculousfish/libdivide.gitmkdir libdivide/build &amp;&amp; cd libdivide/buildcmake .. &amp;&amp; make benchmark./benchmark u32 # or u64 or s32 or s64</p><p> git clone https://github.com/ridiculicfish/libdivide.gitmkdir libdivide / build＆amp;＆amp; CD Libdivide / BuildcMake ..＆amp;制作基准./Benchmark U32＃或U64或S32或S64</p><p> 7 is a “slow case” for libdivide, because 7’s magic number must be 33 or 65 bits, and so cannot fit in a register. This is as slow as libdivide gets.  ↩</p><p> 7是libdivide的“慢速案例”，因为7的魔号必须是33或65位，因此不能符合寄存器。这和libdivide得到的缓慢。 ↩ </p><p>  To divide a 64 bit number, libdivide needs the high half of a 64 bit product, a so-called  high multiply. Unfortunately SIMD hardware typically has a 53-bit multiplier: just big enough for double-precision floating point, not big enough for libdivide. So libdivide must cobble together a 64-bit high-multiply through four 32x32-&gt;64 multiplies. This incurs a factor-of-4 penalty for 64 bit vectorized division on SIMD.  ↩  ↩ 2</p><p>要划分64位数，LibDivide需要64位产品的高半，所谓的高乘法。 不幸的是，SIMD硬件通常具有53位倍增器：对于双精度浮点，足够大，对Libdivide不够大。 因此，Libdivide必须将64位高乘以四个32x32-＆gt; 64乘以。 这会在SIMD中遭受64位矢量化分区的4个惩罚。 ↩↩2 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ridiculousfish.com/blog/posts/benchmarking-libdivide-m1-avx512.html">https://ridiculousfish.com/blog/posts/benchmarking-libdivide-m1-avx512.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/英特尔/">#英特尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/划分/">#划分</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/division/">#division</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>