<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>机械CAD的新时代 A New Era for Mechanical CAD</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A New Era for Mechanical CAD<br/>机械CAD的新时代 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-16 00:50:49</div><div class="page_narrow text-break page_content"><p>June 6, 2021   Volume 19, issue 2       CAD (computer-aided design) has been around since the 1950s. The first graphical CAD program, called Sketchpad, came out of MIT [ designworldonline.com]. Since then, CAD has become essential to designing and manufacturing hardware products. Today, there are multiple types of CAD. This column focuses on mechanical CAD, used for mechanical engineering.</p><p>6月6日，2021年第19卷，问题2 CAD（电脑辅助设计）自20世纪50年代以来一直存在。第一个称为Sketchpad的图形CAD程序出来了麻省理工学院[DesignWorldonline.com]。从那时起，CAD对设计和制造硬件产品至关重要。今天，有多种类型的CAD。该专栏侧重于机械CAD，用于机械工程。</p><p> Digging into the history of computer graphics reveals some interesting connections between the most ambitious and notorious engineers. Ivan Sutherland, who won the Turing Award for Sketchpad in 1988, had Edwin Catmull as a student. Catmull and Pat Hanrahan won the Turing award for their contributions to computer graphics in 2019. This included their work at Pixar building RenderMan [ pixar.com], which was licensed to other filmmakers. This led to innovations in hardware, software, and GPUs. Without these innovators, there would be no mechanical CAD, nor would animated films be as sophisticated as they are today. There wouldn&#39;t even be GPUs.</p><p> 挖掘计算机图形的历史，揭示了最雄心勃勃和臭名昭着的工程师之间的一些有趣的联系。 Ivan Sutherland于1988年赢得了Sketchpad的图灵奖，让Edwin Catmull为学生。 Catmull和Pat Hanrahan于2019年赢得了他们对计算机图形学的贡献的图灵奖。这包括他们在Pixar Building Renderman [Pixar.com]的工作，该公司被许可给其他电影制作者。这导致了硬件，软件和GPU中的创新。如果没有这些创新者，就没有机械CAD，而且动画电影也不会像今天一样复杂。甚至没有gpus。</p><p> Modeling geometries has evolved greatly over time. Solids were first modeled as wireframes by representing the object by its edges, line curves, and vertices. This evolved into surface representation using faces, surfaces, edges, and vertices. Surface representation is valuable in robot path planning as well. Wireframe and surface representation contains only geometrical data. Today, modeling includes topological information to describe how the object is bounded and connected, and to describe its neighborhood. (A  neighborhood of a point consists of a set of points containing that point where one can move some distance in any direction away from that point without leaving the set.)</p><p> 建模几何形状随着时间的推移已经大大发展。首先通过其边缘，线曲线和顶点代表物体来设计为线框。这种使用面部，表面，边缘和顶点演变为表面表示。表面表示在机器人路径规划中是有价值的。线框和表面表示仅包含几何数据。如今，建模包括拓扑信息，以描述对象是界限和连接的如何，并描述其邻居。 （一个点的邻域由包含该点的一组点组成，其中一个点可以在任何方向远离该点的任何方向上移动一些距离而不离开集合。）</p><p> OpenCascade, Parasolid, and ACIS are all boundary-representation (B-rep) kernels. A B-rep model is composed of geometry and topology information. The topology information differs depending on the program used. B-rep file formats include STEP (Standard for the Exchange of Product Model Data), IGES (Initial Graphics Exchange Specification), NX&#39;s prt, Solid Edge&#39;s par and asm, Creo&#39;s prt and asm, SolidWorks&#39; sldprt and sldasm, Inventor&#39;s ipt and iam, and AutoCAD&#39;s dwg.</p><p> Opencascade，Parasolid和Acis都是边界代表（B-REP）内核。 B-REP模型由几何和拓扑信息组成。拓扑信息因使用的程序而异。 B-rep文件格式包括步骤（产品型号数据交换的标准），IGES（初始图形交换规范），NX＆＃39; S PRT，Solid Edge＆＃39; S par和Asm，Creo＆＃39; PRT和ASM，SolidWorks＆＃39; SLDPRT和SLDASM，INVENTOR＆＃39; S IPT和IAM，AUTOCAD＆＃39; S DWG。</p><p> Visual representation (vis-rep) models tend to be much smaller in data size than B-rep models. This is because they do not contain as much structural or product management information. Vis-rep models are approximations of geometry and are composed of a mass of flat polygons. Vis-rep file formats include obj, STL, 3D XML, 3D PDF, COLLADA, and PLY.</p><p> 视觉表示（VIS-REP）模型往往比B-REP模型更小。这是因为它们不包含尽可能多的结构或产品管理信息。 VIS-REP模型是几何形状的近似，并且由大量的扁平多边形组成。 VIS-rep文件格式包括OBJ，STL，3D XML，3D PDF，Collada和PLY。</p><p> CAD programs tend to use B-rep models, while animation, game development, augmented reality, and virtual reality tend to use vis-rep models. However, the two are interchanged frequently. For example, if you were using a B-rep model for manufacturing but wanted to load it into Apple&#39;s ARKit for some animations, you would first convert it to COLLADA, a vis-rep file format. The file should already be a bit smaller from dropping all the CAD data, but if you wanted to make it even smaller, you could tweak the polygon counts on each of the meshes for the various parts.</p><p> CAD程序倾向于使用B-REP模型，而动画，游戏开发，增强现实和虚拟现实倾向于使用VIS-REP模型。然而，这两个经常互换。例如，如果您使用的是制造的B-REP模型，但想要将其加载到Apple＆＃39;对于某些动画的Arkit，您将首先将其转换为Collada，VIS-REP文件格式。从删除所有CAD数据时，该文件应该已经有点较小，但如果您想要使其更小，则可以调整各个部分的每个网格上的多边形计数。</p><p> The tools used to build with today are supported on the shoulders of giants, but a lot could be done to make them even better. At some point, mechanical CAD lost some of its roots of innovation. Let&#39;s dive into a few of the problems with the CAD programs that exist today and see how to make them better.</p><p> 用于今天建造的工具都支持巨人队的肩膀，但可以做到很多，以使它们更好。在某些时候，机械CAD失去了其创新的一些根源。让＆＃39;潜水到今天存在的CAD程序中的一些问题，看看如何更好地让它们变得更好。 </p><p>   Since most CAD kernels are built on cores from the &#39;80s, they are not meant for modern systems. Even the latest CPU or GPU won&#39;t do much to help the performance since most of these programs are single-threaded, or have single-threaded aspects, and have no awareness of a GPU. OpenSCAD and everything built on CGAL (Computational Geometry Algorithms Library) are single-threaded. Sure, some of these kernels have been updated since the &#39;80s, but their roots are still tied to their predecessors. (I am sure there is a lot to learn from these codebases, but as someone who has seen many old codebases, I know this can lead down a dangerous path.)</p><p>由于大多数CAD内核在来自＆＃39; 80年代的核心内构建，它们并不意味着现代系统。即使是最新的CPU或GPU Won＆＃39; T做了很多帮助，因为大多数这些程序是单线程的，或者具有单线程的方面，并且没有意识到GPU。 OpenSCAD和基于CGAL（计算几何算法库）的一切都是单线程的。当然，自从＆＃39; 80年代以来已经更新了这些内核中的一些，但他们的根源仍然与他们的前辈捆绑在一起。 （我确信从这些代码库中学习很多，而是作为看过许多旧码码的人，我知道这可以导致危险的道路。）</p><p> This does not mean that all CAD kernels are  entirely single-threaded. Parasolid is multithreaded, but that still means if you are importing or exporting to a file format other than Parasolid, you might have just switched back to a single-threaded process. Another example of a multithreaded kernel is ImplicitCAD [ implicitcad.org], which is written in Haskell.</p><p> 这并不意味着所有CAD内核都是完全单螺纹的。遮阳伞是多线程的，但仍然意味着如果您正在导入或导出到adarasolid以外的文件格式，则可能刚刚切换回单程过程。多线程内核的另一个例子是ImplicIticCAD [ImblicitCad.org]，它是用Haskell编写的。</p><p> One problem with making a whole CAD program multithreaded is the different file formats. For example, a STEP file, whose format dates back to the &#39;80s [ iso.org], pretty much mandates the need for a single-threaded process. (Additionally, a STEP file cannot be read sequentially; it must be loaded into memory and then resolved.) Most parametric CAD operations are single-threaded; however, the open-source project SolveSpace [ solvespace.com], which uses NURBS (nonuniform rational basis splines), has some parallel operations.</p><p> 制作整个CAD程序多线程的一个问题是不同的文件格式。例如，逐步文件，其格式日期回到＆＃39; 80s [iso.org]，几乎要求需要单线程过程。 （另外，无法顺序读取步骤文件;它必须加载到内存中然后解决。）大多数参数CAD操作是单线程的;但是，使用NURBS（非均匀合理基础样条线）的开源项目索沃空间[Solvespace.com]具有一些并行操作。</p><p>   In software development, a pointer is used to get the contents of a memory address. This allows users to reference that same content over and over again without the expense of copying the content itself.</p><p>   在软件开发中，指针用于获取内存地址的内容。这允许用户在没有牺牲内容本身的情况下延续同样的内容。</p><p> Some products built using CAD may never duplicate a part of their model—lucky for them! For people who do have multiple similar parts in their CAD designs, most CAD programs are creating very expensive copies of these parts.</p><p> 使用CAD建造的一些产品可能永远不会重复他们的模型幸运！对于在他们的CAD设计中有多个类似部件的人来说，大多数CAD程序正在创建这些部件的非常昂贵的副本。</p><p> For example, imagine a model of a server rack. The  default method of copying a part (using copy and paste) in SolidWorks, as well as many other industrywide CAD programs, is to copy the entire contents of a child model to a new model. So, if you have 32 sleds in the server rack and use the default copy method in SolidWorks, you have 32 of the exact same model in individual copies. This is very expensive. Each sled has many more models inside, and then those models have child models as well. This exponentially increases the workload on the kernel and on your program to load your model in the first place, since the program does not know these are all the same thing.</p><p> 例如，想象一个服务器机架的模型。在SolidWorks中复制零件（使用副本和粘贴）以及许多其他InditionalWide CAD程序复制的默认方法是将子模型的整个内容复制到新模型。因此，如果在服务器机架中有32个SLIDS并在SolidWorks中使用默认复制方法，则您在单个副本中有32个完全相同的模型。这非常昂贵。每个雪橇里面都有更多的模型，然后那些模型也有儿童模型。这是指数增长内核上的工作负载以及在您的程序上首先加载模型，因为该程序不知道这些都是相同的。</p><p> Taking a lesson from software development, what you really want is a form of pointer to the model. In the CAD world, these are called  instances. Then you can have one copy of the model stored, and all the other instances are actually just references to the original copy. This also saves the user a bunch of time. Imagine having to update parts of models in 32 different locations when a part in a sled changes. A wise person once said, &#34;The definition of insanity is doing the same thing over and over again but expecting different results.&#34;</p><p> 从软件开发中课程，您真正想要的是一种指向模型的形式。在CAD世界中，这些被称为实例。然后，您可以存储一个存储的模型副本，并且所有其他实例实际上只是对原始副本的引用。这也将用户节省了一堆时间。想象一下，在滑雪更改的一部分时，必须在32个不同位置更新模型的部分。一个明智的人曾经说过，＆＃34;疯狂的定义一遍又一遍地做同样的事情，但期待不同的结果。＆＃34; </p><p> SolidWorks does offer another option that is more in line with how pointers operate, but since this is not the default, most users might not even realize there is a better way. The default path should lead to the least amount of pain. Instead of having two methods for copying, products should have just one. They should make the default method act more like a pointer (or instance)  until the geometry, surfaces, or topology of the copy (not the main) has changed. In this case the user should be warned that this will now act like a unique part aside from the main copy. Or the user might have mistakenly meant to apply those changes to all the copies, in which case the changes should be applied to the main copy.</p><p>SolidWorks确实提供了另一种选择，更符合指针如何运行，但由于这不是默认值，大多数用户甚至没有意识到有更好的方法。默认路径应导致最少的疼痛。而不是有两种复制方法，产品应该只有一个。它们应该使默认方法更像是指针（或实例），直到副本（不是主）的几何，曲面或拓扑已经改变。在这种情况下，应该警告用户现在将像唯一的副本一样行动。或者用户可能会错误地将这些更改应用于所有副本，在这种情况下，应将更改应用于主副本。</p><p> There is another huge problem with this. Each CAD program has its own way of implementing and referencing instances. If you export your design from one CAD program to another, you will likely still have 32 individual sleds rather than one sled and 31 references to the original with only the xyz coordinates changed. Some programs offer ways to import instances, but they all rely on the file format being imported and whether they have the support for that format.</p><p> 这有另一个巨大的问题。每个CAD程序都有自己的实施方式和参考实例。如果将设计从一个CAD程序导出到另一个CAD程序，则可能仍然有32个单独的SLIDS而不是一个SLID，并且仅使用XYZ坐标更改的原始SLID和31引用。某些程序提供导入实例的方法，但它们都依赖于导入的文件格式以及它们是否具有该格式的支持。</p><p> Even if you are using instances, you are still at the mercy of the single-threaded kernel, and none of the copies are likely to render in parallel.</p><p> 即使您使用的实例，您仍然仍处于单线程内核的ercy，并且否则尚未呈现并行呈现。</p><p>   For software teams that are accustomed to using git, being able to diff, fix merge conflicts, and work as a team in parallel on the same file is a huge time saver. A number of startups are working to bring this ability to mechanical CAD.</p><p>   对于习惯于使用git的软件团队，能够差异，修复合并冲突，并在同一文件上并行工作是一个巨大的节省时间。许多初创公司正致力于为机械CAD带来这种能力。</p><p> Instead of reinventing version control for CAD, those who use git today want to continue to use git and not have to add another tool to their workflow. Today there is no way to push a CAD file to a git repo, have several people modify the file, and resolve merge conflicts. (Well, maybe it could be done, but it would be the opposite of fun.) For all the startups working to solve version control for mechanical CAD, this is why they had to reinvent the wheel.</p><p> 今天使用Git的那些使用Git的人来继续使用Git而不是重新发明的CAD版本，而不是将另一个工具添加到他们的工作流程中。今天，没有办法将CAD文件推向Git Repo，有几个人修改文件，并解决合并冲突。 （嗯，也许它可以完成，但它与乐趣相反。）对于努力解决机械CAD的版本控制的所有启动，这就是他们必须重新发明轮子的原因。</p><p> In a world where a kernel can fully utilize a modern CPU and GPU, can you not also use a file format that is human-readable and would allow for resolving merge conflicts? When you ask, &#34;What is human-readable and works well with git?&#34; he first answer that comes to mind is a programming language.</p><p> 在一个内核可以充分利用现代CPU和GPU的世界中，您还不能使用人类可读的文件格式，并允许解决合并冲突？当你问，＆＃34;什么是人类可读的，与git效果很好？＆＃34;他第一次回答这个想法是一种编程语言。</p><p> The other great win from using a programming language is this: Even if you don&#39;t use or want to use git, there are already many different options for version control of human-readable files. Additionally, integrations with GitHub and other version-control tools could be extended with wasm (WebAssembly) support so that diffs could be visualized as renders as well.</p><p> 来自使用编程语言的其他伟大赢得了：即使您使用或想要使用或想要使用Git，对于人类可读文件的版本控制有许多不同的选项。此外，可以使用WASM（WebasseMbly）支持扩展与GitHub和其他版本控制工具的集成，以便可以将Diffs可视为渲染。 </p><p>   Think back to the example of the rack of servers. If part of the rack contained complex math that you were calculating in a program such as Mathematica, you would have to reevaluate the math continuously in another program and update it in your model. If, instead, you could program in the CAD product itself, then you could do all your calculations in one place and the model would update if anything in the equations changed.</p><p>思考服务器机架的示例。如果机架的一部分包含您在Mathematica等程序中计算的复杂数学，您必须在另一个程序中连续重新评估数学并在模型中更新。如果代替，您可以在CAD产品本身中编程，那么您可以在一个地方进行所有计算，如果方程式中的任何内容发生变化，模型将更新。</p><p> Each sled in the rack of servers has network cables that connect to the back of the sled. Using the GUI, you would have difficulty making these align perfectly with the connector on the sled. Someone would have to sit with the model for an hour or so just tweaking each cable to be perfectly aligned—a huge waste of time. Instead, if you could program the alignment of the cables, you could ensure each was perfectly aligned with the connector.</p><p> 在服务器机架中的每个雪橇都有网络电缆连接到雪橇背面。使用GUI，您将难以使这些与雪橇上的连接器完美齐合。有人必须坐在模型中一小时左右，只是调整每个电缆完全对齐 - 浪费时间巨大。相反，如果您可以编程电缆的对齐，可以确保每个都与连接器完全对齐。</p><p> The need for programming becomes even more acute if you want to do mesh or topology optimizations. Unfortunately, most optimizations are implemented through GUI click interfaces, and given their complexity to define, can often be more trouble than they are worth. Today, some programs allow for scripting, but their APIs are COM (Component Object Model) based and, as you can imagine, built in the &#39;90s. It&#39;s great they even offer this, however. (Thank you, AutoCAD, for being the first CAD command-line interface I ever used.)</p><p> 如果您想做网格或拓扑优化，则需要对编程的需求变得更加敏锐。不幸的是，大多数优化通过GUI单击接口实现，并赋予他们的复杂性来定义，通常可以比他们的价值更麻烦。今天，某些程序允许脚本，但它们的API是基于COM（组件对象模型），如您所能想象的，内置于​​＆＃39; 90s。然而，它＆＃39;但是，他们甚至提供了这一点。 （谢谢AutoCAD，是我曾经使用过的第一个CAD命令行界面。）</p><p> For the modern world, it would be great to generate SDK clients for the CAD program in every language, much the way API clients are generated. This would allow anyone to program in any language. It would lower the barrier to entry since learning a new language would not be required. This would allow for complex math to be done in the CAD program itself rather than using Mathematica, MATLAB, or Wolfram Alpha.</p><p> 对于现代世界来说，在每种语言中为CAD程序生成SDK客户端，就会产生API客户端的CAD程序。这将允许任何人以任何语言编程。自从学习新的语言是不需要的，它将降低入门障碍。这将允许在CAD程序本身中完成复杂的数学，而不是使用Mathematica，Matlab或Wolfram Alpha。</p><p> A few scriptable CAD programs exist today and are paving the way for this transition: ImplicitCAD [ implicitcad.org], libfive Studio [ libfive.com], OpenSCAD [ openscad.org], CadQuery [ github.com], FreeCAD [ freecadweb.org], and ruckus [ github.com]. Blender [ blender.org] has a great console interface. Three.js [ threejs.org], while not CAD oriented, is also another great example of a 3D programming language. Jonathan Blow&#39;s Jai [ oxide.computer] is for writing systems-level code and a great example of creating a language thinking heavily about performance. (This is not yet open to the public, but he has talked about it extensively.)</p><p> 今天存在一些可编写的CAD程序，并为此过渡铺平道路：ImplicicCAD [ImplicitCad.org]，Libfive Studio [LibFive.com]，OpenSCAD [OpenScad.org]，Cadquery [Github.com]，Freecad [FreecadWeb.org [ruckus [github.com]。 Blender [Blender.org]有一个很棒的控制台界面。 Three.js [threejs.org]，虽然不是cad定向，也是3D编程语言的另一个伟大典范。 Jonathan Blow＆＃39; s Jai [Oxide.com电脑]用于编写系统级代码和创建语言思考性能的重要示例。 （这还没有向公众开放，但他已经广泛谈过它。）</p><p> Most of the mechanical engineering community is tied to the GUI, so generating code from GUI interactions would be necessary. This is quite similar to an HTML point-and-click GUI that generates code on the back end. This allows people who want to script to script, and others who want to click can click. Both worlds can be happy—code on the left side, render on the right, just like a markdown editor.</p><p> 大多数机械工程界都与GUI相关联，因此需要从GUI交互产生代码。这与HTML点击GUI非常类似于在后端生成代码的GUI。这允许希望脚本脚本的人员以及想要点击的其他人单击。这两个世界都可以在左侧的快乐代码，右侧呈现，就像一个标记编辑器。</p><p> If there is an SDK client for the CAD program and underlying kernel, you can imagine a rich ecosystem of plug-ins and tools emerging, much like the ecosystem that surrounds VSCode, Vim, and Emacs. Most CAD editors used for products are closed off and don&#39;t allow for this type of community-based development and sharing. Plug-ins could be written for any use case: for example, mesh/topology optimizations and supply-chain system integrations. This includes the functionality for finding parts, creating BOMs (bills of materials), and computing lead times for parts of the model. Today, this is usually done in separate programs or even spreadsheets.</p><p> 如果CAD程序和底层内核有一个SDK客户端，您可以想象一个丰富的插件和工具兴起的生态系统，就像围绕vscode，vim和emacs的生态系统一样。用于产品的大多数CAD编辑器都关闭，不要允许这种基于社区的开发和共享。可以为任何用例编写插件：例如，网格/拓扑优化和供应链系统集成。这包括用于查找部件的功能，创建BOM（材料账单），以及模型部分的计算交付时间。今天，这通常是在单独的程序甚至电子表格中完成的。 </p><p> Plug-ins that support a command+P function would be welcome. In most programs, when you want to print something, you hit command+P. (Creo probably has the closest thing to this functionality but lacks an open ecosystem.) For mechanical CAD, when you want to print your model the underlying program should discover all the 3D printers and machines on the local network (or plugged directly into your machine) and send the parts of your model that are compatible with each machine to be printed. This could even be taken a step further—in a fully automated factory with robots, the program should set up and start the assembly for the model and all the parts.</p><p>欢迎支持命令+ P功能的插件。在大多数程序中，当您想打印某些内容时，您将命中命令+ p。 （Creo可能对此功能最接近的事情，但缺乏开放的生态系统。）对于机械CAD，当您想打印模型时，底层计划应发现本地网络上的所有3D打印机和机器（或直接插入机器）并发送与要打印的每台机器兼容的模型的部件。这甚至可以进一步参加一个完全自动化的工厂，其中包含机器人，该程序应设置并启动模型和所有部件的组装。</p><p> Speaking of 3D printing, let&#39;s look at the STL file format. This format was defined in 1987, and its namesake comes from stereolithography, the first method of additive manufacturing. STL files represent geometry in a series of triangular surfaces. Since STL is a vis-rep format, it does not hold any data about internal structure, color, texture, or any other CAD data that a B-rep format would contain. Modern 3D printers have innovated past the simplicity of the STL format. For example, to print a full-color model, users need a VRML (Virtual Reality Modeling Language) file, or an STL file associated with textures in order for the printer to add color and texture to the object. Plug-ins can ensure that the printer gets the correct data for the specific model to be printed, without the pain of conversion and ensuring that no materials or textures are dropped.</p><p> 说到3D打印，让＆＃39; s查看STL文件格式。这种格式在1987年定义，其同名来自立体化，第一种添加剂制造方法。 STL文件表示一系列三角形表面的几何图形。由于STL是VIS-rep格式，因此它不会保留有关内部结构，颜色，纹理或任何其他CAD数据的数据，即B-rep格式将包含的任何其他CAD数据。现代3D打印机创新了STL格式的简单性。例如，要打印全色模型，用户需要VRML（虚拟现实建模语言）文件，或与纹理关联的STL文件，以便打印机将颜色和纹理添加到对象。插件可以确保打印机获得要打印的特定模型的正确数据，而不会转换疼痛，确保没有丢弃材料或纹理。</p><p>   The test flow of CAD models usually consists of running simulations. Let&#39;s use airflow and thermals as examples.</p><p>   CAD模型的测试流程通常包括运行模拟。让＆＃39; s用气流和热量作为例子。</p><p> In the software world, after pushing your code updates, typically a CI (continuous integration) is run on the changes, letting you and your teammates know if you broke anything or if your code is safe to merge. CAD should work the same way. If you make changes to a model, your simulations should run in a CI to let your teammates know if your code is safe to merge. Most of these simulations are compute intensive, so being able to offload the simulations to the cloud or remote servers would also be ideal.</p><p> 在软件世界中，在推动代码更新后，通常会在更改中运行CI（持续集成），让您和您的队友知道您是否已打破任何或者您的代码是否安全地合并。 CAD应该以同样的方式工作。如果您对模型进行了更改，则您的模拟应该在CI中运行，以便您的队友知道您的代码是否安全合并。大多数这些模拟都是计算密集型的，因此能够将模拟卸载到云或远程服务器也是理想的。</p><p> Much as VSCode and other editors have nice plug-ins for offloading tests to other computers, a modern CAD program should have the same.</p><p> 与vscode和其他编辑器有很多用于卸载测试到其他计算机的漂亮插件，现代CAD程序应该具有相同的。</p><p>   After trying many different industry CAD programs, I have found that most have one characteristic in common: a user interface that looks like it is from the &#39;90s. It is a bit ironic that a tool used for mechanical design has not considered the design and experience of its user interface. Most CAD programs are in need of a makeover, though there are a couple of outliers that do interface design well: Shapr3D [ shapr3d.com], an iPad app, has a great design and intuitive interface; SketchUp [ sketchup.com] has an intuitive and beautiful design.</p><p>   在尝试许多不同的行业CAD程序之后，我发现大多数人都有一个共同的特征：一个看起来它来自＆＃39; 90s的用户界面。对于机械设计的工具，它是一个讽刺意味的是，用于机械设计的工具没有考虑其用户界面的设计和经验。大多数CAD程序都需要改造，尽管有几个界面设计井的异常值：ShapR3D [ShapR3D.com]，iPad应用程序，具有很好的设计和直观的界面; Sketchup [Sketchup.com]有直觉而美丽的设计。</p><p> Additionally, CAD applications need to be native on MacOS, Linux, and Windows. Native applications built for their specific platform perform better than ones built with Electron and the like. (That being said, VSCode is a nice Electron app.) Especially for a program as graphics heavy as CAD, using the underlying operating-system graphics mechanisms helps achieve the best performance possible. Today, a CAD program can be used only on the operating system that is supported by that specific program. Additionally, most use archaic GUI frameworks that truly show their age.</p><p> 此外，CAD应用程序需要在MacOS，Linux和Windows上是本地性的。为其特定平台构建的本机应用程序比使用电子等构建的更好。 （所说的，vscode是一个很好的电子应用程序。）特别是对于作为CAD的图形的程序，使用底层操作系统图形机制有助于实现最佳性能。如今，CAD程序只能用于该特定程序支持的操作系统。此外，大多数都使用真正展示他们年龄的古老GUI框架。 </p><p> Onshape [ onshape.com] changed the mold by offering a SaaS (software-as-a-service) CAD program. This allows expensive compute processes to be easily offloaded to the cloud. This was a truly revolutionary idea, but it limits the user&#39;s ability to work offline. In contrast, native apps can work offline but also have the ability to offload workloads to the cloud when connected to the network.</p><p>onshape [onshape.com]通过提供SaaS（软件 -  AS-Service）CAD程序来改变模具。这允许昂贵的计算过程轻松卸载到云。这是一个真正的革命性想法，但它限制了用户的能力下线。相比之下，本机应用程序可以脱机工作，但也能够在连接到网络时将工作负载卸载到云。</p><p> If CAD programs can focus on an intuitive design without falling into a trap of complexity, both new users and professionals should be productive. Just as I would use Vim for side projects as well as professional jobs, I would expect my CAD tool to work just as well for building a toy for fun as it would for a complex project. A lot of this capability comes down to the interface design and extensibility through plug-ins.</p><p> 如果CAD程序可以专注于直观的设计，而不会陷入复杂性的陷阱，这两个用户和专业人士都应该富有成效。正如我将使用Vim为侧面项目以及专业工作，我希望我的CAD工具也可以工作，因为它适用于复杂的项目。许多这种功能通过插件来实现界面设计和可扩展性。</p><p>   Developers of new CAD programs need to think through each of these aspects. No existing CAD program has solved all of these problems.</p><p>   新的CAD计划的开发人员需要通过这些方面思考。没有现有的CAD计划解决了所有这些问题。</p><p> The world owes so much of the amazing innovation of computer graphics to brilliant people such as Ivan Sutherland, Pat Hanrahan, Ed Catmull, John Carmack, and many others. I can only hope some truly revolutionary changes are headed to the world of computer-aided design in the same way that computer graphics pioneers paved the way for rendering, animations, and virtual reality.</p><p> 世界归功于计算机图形学的惊人创新，为伊万·萨特兰，帕塔哈汉，埃德·帕特梅尔，约翰卡克拉克等许多其他人。我只希望有些真正的革命性变化是以计算机辅助设计的方式领导的，同样的方式是计算机图形公司铺平了渲染，动画和虚拟现实的方式。</p><p> The hardware industry is desperate for a modern way to do mechanical design. A new CAD program created for the modern world would lower the barrier to building hardware, decrease the time of development, and usher in a new era of building.</p><p> 硬件行业绝望是一种现代做机械设计的方法。为现代世界创建的一个新的CAD计划将降低建筑硬件的障碍，减少发展时间，并在建筑的新时代。</p><p>  Jessie Frazelle is the cofounder and chief product officer of the Oxide Computer Company. Before that, she worked on various parts of Linux, including containers, as well as the Go programming language.</p><p>  Jessie Frazelle是氧化物计算机公司的Cofounder和首席产品。在此之前，她在Linux的各个部分工作，包括集装箱，以及去编程语言。</p><p>  Originally published in Queue vol. 19, no. 2— see this item in the  ACM Digital Library</p><p>  最初在队列卷发布。 19，没有。 2-在ACM数字库中查看此项目 </p><p> Related: Arvind Narayanan, Arunesh Mathur, Marshini Chetty, Mihir Kshirsagar -   Dark Patterns: Past, Present, and Future Dark patterns are an abuse of the tremendous power that designers hold in their hands. As public awareness of dark patterns grows, so does the potential fallout. Journalists and academics have been scrutinizing dark patterns, and the backlash from these exposures can destroy brand reputations and bring companies under the lenses of regulators. Design is power. In the past decade, software engineers have had to confront the fact that the power they hold comes with responsibilities to users and to society. In this decade, it is time for designers to learn this lesson as well.</p><p>相关：Arvind Narayanan，Arunesh Mathur，Marshini Chetty，Mihir Kshirsagar  - 黑暗模式：过去，礼物和未来的黑暗模式是滥用设计师握在手中的巨大力量。随着对黑暗模式的公众意识增长，潜在的辐射也是如此。记者和学者一直在仔细审查黑暗图案，这些暴露的反射可以破坏品牌声誉，并将公司带到监管机构的镜片下。设计是电力。在过去的十年中，软件工程师必须面对他们所持有的权力对用户和社会的责任来说。在这十年中，设计师也要学习这一课的时候了。</p><p>  Kari Pulli, Anatoly Baksheev, Kirill Kornyakov, Victor Eruhimov -   Realtime Computer Vision with OpenCV Computer vision is a rapidly growing field devoted to analyzing, modifying, and high-level understanding of images. Its objective is to determine what is happening in front of a camera and use that understanding to control a computer or robotic system, or to provide people with new images that are more informative or aesthetically pleasing than the original camera images. Application areas for computer-vision technology include video surveillance, biometrics, automotive, photography, movie production, Web search, medicine, augmented reality gaming, new user interfaces, and many more.</p><p>  Kari Pulli，Anatoly Baksheev，Kirill Kornyakov，Victor Eruhimov  - 具有OpenCV电脑愿景的实时计算机视觉是一个迅速增长的领域，致力于分析，修改和高级别了解图像。其目标是确定在相机前发生的事情，并使用该理解来控制计算机或机器人系统，或者为人们提供比原始摄像机图像更丰富或美观令人愉悦的新图像。计算机视觉技术的应用领域包括视频监控，生物识别，汽车，摄影，电影制作，网络搜索，医学，增强现实游戏，新用户界面等。</p><p>  Julian Harty -   Finding Usability Bugs with Automated Tests Ideally, all software should be easy to use and accessible for a wide range of people; however, even software that appears to be modern and intuitive often falls short of the most basic usability and accessibility goals. Why does this happen? One reason is that sometimes our designs loo</p><p>  Julian Harty  - 理想地发现自动化测试的可用性错误，所有软件都应该易于使用，可供各种各样的人使用;但是，似乎似乎是现代和直观的软件往往缺乏最基本的可用性和可访问性目标。为什么会发生这种情况？一个原因是有时我们的设计厕所</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=3469844">https://queue.acm.org/detail.cfm?id=3469844</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/cad/">#cad</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>