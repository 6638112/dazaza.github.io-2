<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对控制台应用程序进行单元测试 Unit-testing a console app</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Unit-testing a console app<br/>对控制台应用程序进行单元测试 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-10 18:53:41</div><div class="page_narrow text-break page_content"><p>The most notable feature in  EndBASIC 0.3 is its new full-screen console-based text editor. It took longer than I wanted to start developing this, in part because I was busy moving, and in part because I  dreaded the thought of having to unit test the text editor. (Yes, EndBASIC is a personal project and I develop it in my free time, but that doesn’t mean I don’t want it to be properly engineered!)</p><p>EndBASIC 0.3中最显着的功能是其新的基于控制台的全屏文本编辑器。它比我开始开发它所花的时间要长，部分原因是我忙于移动，部分原因是我担心必须对文本编辑器进行单元测试。 （是的，EndBASIC是一个个人项目，我在业余时间开发它，但这并不意味着我不希望它得到适当的设计！）</p><p>  In the end, I rolled up my sleeves, got to work, and achieved reasonable test coverage. In fact, the tests have already paid off by uncovering various bugs and inefficiencies, so the effort was well-spent. Developing these tests was non-trivial, though, so here is an overview on  why it is worthwhile to unit-test a full-screen console app and  how to go about it.</p><p>  最后，我卷起袖子，开始工作，并取得了合理的测试范围。实际上，通过发现各种错误和效率低下的问题，这些测试已经获得了回报，因此付出了巨大的努力。但是，开发这些测试并非易事，因此，这里概述了为什么值得对全屏控制台应用程序进行单元测试以及如何进行测试。</p><p> The key insight, unsurprisingly, is to  design for testability. I knew I wanted to unit-test the text editor from the beginning, so I had to come up with a design that allowed for this. Retrofitting tests into code that never considered testing is very difficult.</p><p> 毫不奇怪，关键的见识是针对可测试性进行设计。我知道我从一开始就想对文本编辑器进行单元测试，所以我不得不设计一个允许这样做的设计。将测试改造为从未考虑过测试的代码非常困难。</p><p> As usual, while the specific code I’m going to show you is in Rust, you can easily apply these ideas to your favorite language. All you need is a mechanism to express an abstraction layer between your app and the console manipulation code—and you could do that even in the shell.</p><p> 和往常一样，虽然我要向您展示的特定代码是在Rust中，但您可以轻松地将这些想法应用到您喜欢的语言。您所需要的只是一种机制，用于在您的应用程序和控制台操作代码之间表达一个抽象层，您甚至可以在外壳中做到这一点。</p><p>  Command-line applications typically interact with the console by reading from their standard input (stdin) and writing to their standard output (stdout). Both stdin and stdout are “streams”: you can read from and write to them, but these I/O operations are sequential. The streams do not know anything about where the cursor is or how to change colors or anything like that. And this makes sense because if stdin and stdout are connected to files, what does it mean to “clear the screen”?</p><p>  命令行应用程序通常通过从标准输入（stdin）中读取并写入标准输出（stdout）与控制台进行交互。 stdin和stdout都是“流”：您可以读写它们，但是这些I / O操作是顺序的。流不知道有关光标在哪里或如何更改颜色的任何信息。这是有道理的，因为如果stdin和stdout连接到文件，“清除屏幕”是什么意思？</p><p> If that’s the case, though, how does a console program manipulate the screen to, for example, clear it and position the cursor at an arbitrary location? Well, the answer is that… it depends.</p><p> 但是，如果是这种情况，控制台程序如何操作屏幕以例如清除屏幕并将光标定位在任意位置？好吧，答案是……这取决于。</p><p> On Unix-like systems, the application writes special collections of bytes, known as  escape sequences, to stdout. How the escape sequences look like and what they mean depends completely on what stdout is attached to. Again, if stdout is attached to a file, these sequences mean nothing more than a sequence of bytes. Contrariwise, if stdout is attached to a terminal, then the terminal interprets them and performs certain actions.</p><p> 在类似Unix的系统上，应用程序将特殊的字节集合（称为转义序列）写入stdout。转义序列的外观及其含义完全取决于附加的stdout。同样，如果将stdout附加到文件，则这些序列只不过是字节序列而已。相反，如果stdout连接到终端，则终端将对其进行解释并执行某些操作。 </p><p> The most obvious escape sequence you can think of is the line terminator, or  \n. On its own,  \n is nothing more than ASCII byte 10. But when the terminal sees this byte, the terminal knows that it has to advance the cursor to the next line  and move it to the first column. But the semantics of what  \n does vary across systems: Windows interprets  \n as  just moving the cursor one line down, not rolling it back go the first column.</p><p>您可以想到的最明显的转义序列是行终止符或\ n。 \ n本身就是ASCII字节10。但是，当终端看到该字节时，终端便知道必须将光标移至下一行并将其移至第一列。但是\ n所做的语义在整个系统中各不相同：Windows将\ n解释为仅将光标向下移动一行，而不是将其回滚到第一列。</p><p> There are more complex escape sequences, of course. This is why you can trivially (assuming you know what terminal type you are talking to) embed escape sequences in  printf or  echo -e invocations to control how things look like. You essentially use escape sequences as a way to mark up the text:</p><p> 当然，还有更复杂的转义序列。这就是为什么您可以轻松地（假设您知道要与之对话的终端类型）将转义序列嵌入到printf或echo -e调用中以控制外观的原因。本质上，您可以使用转义序列作为标记文本的一种方式：</p><p>  For completeness, I’ll also mention that the terminal emulator is usually in the kernel, which is what allows you to have full-screen text apps in the text mode console, but it can also be implemented in  hardware (where the concept originated), and thus also in user space, which is what graphical programs like  xterm used to do before PTYs (and is why they are called terminal  emulators).</p><p>  为了完整起见，我还将提到终端仿真器通常位于内核中，这使您可以在文本模式控制台中使用全屏文本应用程序，但也可以在硬件中实现（概念起源于此）。 ，因此也在用户空间中，这是xterm之类的图形程序在PTY之前曾经做过的事情（这就是为什么将它们称为终端仿真器的原因）。</p><p> If you haven’t connected the dots yet, this is precisely what the ancient  TERM environment variable is about: it tells the console applications what specific terminal it is talking to so that the application itself can generate the correct escape sequences to control it. Nowadays, the  ANSI escape sequences are almost universal, but they weren’t always.  terminfo/ termcap and  (n)curses are libraries to abstract all these details away and offer the programmer a generic console-manipulation interface that works across  TERM variants.</p><p> 如果您还不了解问题，那就恰恰是古老的TERM环境变量所要解决的：它告诉控制台应用程序正在与哪个特定终端通信，以便应用程序本身可以生成正确的转义序列来对其进行控制。如今，ANSI转义序列几乎是通用的，但并不总是如此。 terminfo / termcap和（n）curses是将所有这些详细信息抽象出来的库，并为程序员提供了一个通用的控制台操作界面，该界面可在TERM变体中使用。</p><p> This is all about Unix though. On Windows, things are different (and my knowledge is very limited). Command-line applications communicate with the Console Window Host ( conhost.exe) by means of  ioctl-like calls. In other words: console manipulation happens out of band and isn’t part of what goes into stdout. Or at least that’s the only way it used to be: the new console host supports ANSI escape sequences too, presumably to facilitate interop with WSL.</p><p> 不过，这全都与Unix有关。在Windows上，情况有所不同（并且我的知识非常有限）。命令行应用程序通过类似ioctl的调用与控制台窗口主机（conhost.exe）通信。换句话说：控制台操作是带外进行的，不是stdout的一部分。或者至少这是过去的唯一方法：新的控制台主机也支持ANSI转义序列，大概是为了促进与WSL的互操作。</p><p> Anyhow. We don’t care about how the console is updated from a testing perspective: we want to know how the console changes, but not exactly how that’s done by the OS. Therefore, I’m going to refer to the escape sequences and/or the  ioctls sent to the console as  console manipulation commands or  console commands in the text below.</p><p> 无论如何。从测试的角度来看，我们不在乎控制台是如何更新的：我们想知道控制台是如何变化的，而不是操作系统是如何完成的。因此，在下面的文本中，我将把发送到控制台的转义序列和/或ioctl称为控制台操纵命令或控制台命令。</p><p>  Testing a full-screen console app—which some people refer to as a  Text User Interface or  TUI for short—exposes essentially the same difficulties as testing a GUI:</p><p>  测试全屏控制台应用程序（某些人简称为文本用户界面或TUI）与测试GUI基本上具有相同的困难： </p><p> We are trying to write tests for something that  responds to user input, and every user interaction causes  changes that are inherently visual and require the human eye for interpretation.</p><p>我们正在尝试为响应用户输入的内容编写测试，并且每次用户交互都会导致本质上是视觉变化并需要人眼才能进行解释的更改。</p><p> Let’s break these problems down into pieces and see how we can approach them.</p><p> 让我们将这些问题分解为几部分，看看如何解决。</p><p> First and foremost: we have to ensure that the  outcome of our input (key presses) has the right effect on the program  state. Given that we are testing a text editor, this is easy: we can populate the editor’s buffer with some text, let the editor process a set of key presses, and then verify that the contents of the editor’s buffer match a golden text. Not very different from other, more traditional tests.</p><p> 首先，我们必须确保输入结果（按键）对程序状态具有正确的影响。假设我们正在测试文本编辑器，这很容易：我们可以用一些文本填充编辑器的缓冲区，让编辑器处理一组按键，然后验证编辑器缓冲区的内容是否与金色文本匹配。与其他更传统的测试没有太大区别。</p><p> Second, we need to worry about user input. After all, the TUI is interactive and reacts to user key presses, so our tests will have to drive the TUI. This is easier than dealing with the visual console updates, as all we have to do is represent the sequence of key presses to send to the app and then feed those to it in some way. Again, this is not very different from other tests: we have an algorithm and we inject some input.</p><p> 其次，我们需要担心用户输入。毕竟，TUI是交互式的，并且对用户按键操作有反应，因此我们的测试将必须驱动TUI。这比处理可视控制台更新要容易得多，因为我们要做的就是代表要发送到应用程序的按键序列，然后以某种方式将其输入给应用程序。同样，这与其他测试没有太大不同：我们有一个算法，并注入了一些输入。</p><p> And third, we have to worry about how things look like, which is the most interesting part of this problem. Because, after all… we can write a test to verify that a piece of code selects the blue color and then clears the screen, but unless we  see the result, we don’t know if the screen was all emptied with a blue background or not.</p><p> 第三，我们必须担心情况如何，这是此问题中最有趣的部分。因为，毕竟……我们可以编写测试来验证一段代码选择蓝色，然后清除屏幕，但是除非看到结果，否则我们不知道屏幕是否全部清空了蓝色背景或不。</p><p> Well, we  could. Presumably, we could capture the raw screen contents (or poke at them if we were in the DOS era;  0xB8000 anyone?) and compare those against golden “screenshots” after every key press. This would do the trick and would result in tests that are completely decoupled form the way the screen is updated… which actually sounds like a good idea. The problem with this approach of comparing screen contents is that we would need a terminal emulator to “render” the console from the console commands that the application emits, and a terminal emulator isn’t a trivial piece of software.</p><p> 好吧，我们可以。大概，我们可以捕获原始屏幕内容（如果我们处于DOS时代，则可以对它们进行戳戳；是否为0xB8000？），并在每次按键后将它们与金色的“屏幕截图”进行比较。这样就可以解决问题，并导致测试与屏幕更新的方式完全脱钩……实际上听起来是个好主意。这种比较屏幕内容的方法的问题在于，我们需要一个终端仿真器来从应用程序发出的控制台命令“渲染”控制台，而终端仿真器并不是一件简单的软件。</p><p> The alternative to this idea of comparing screen  contents is to capture the console commands that the app emits and compare those to expectations. This is easier to implement but has different fidelity tradeoffs as we shall see below.</p><p> 比较屏幕内容的想法的另一种选择是捕获应用程序发出的控制台命令，并将其与期望进行比较。这将更易于实现，但在保真度方面会有不同，如下所述。 </p><p>  If we follow the ideas presented above, we will end up with a bunch of tests that inject key presses into the TUI and, for each of them, we will capture which console manipulation commands were emitted and we will compare them against expectations.</p><p>如果遵循上述思想，我们将进行一堆将按键按下到TUI中的测试，并且针对每个按键，我们将捕获发出了哪些控制台操作命令，并将其与期望值进行比较。</p><p> Which… sounds fragile and not particularly useful, doesn’t it? As mentioned earlier, a sequence of commands is meaningless  unless we humans see the visual results once a terminal emulator has processed the commands. You could then say that these tests are pointless. But these tests provide three separate benefits:</p><p> 哪个……听起来很脆弱，但不是特别有用，不是吗？如前所述，除非终端仿真器处理了命令，否则我们看不到视觉结果，否则命令序列是没有意义的。然后，您可以说这些测试毫无意义。但是这些测试提供了三个单独的好处：</p><p> Corner-case and regression validation. In the scenario we are looking at, a lot of the editor behavior is obvious: if we press the right arrow key, we know that the cursor has to move one position to the right if the line of text permits. If we break the way this works, the breakage will be extremely visible once we do any kind of manual test.</p><p> 特殊情况和回归验证。在我们正在观察的场景中，许多编辑器的行为都是显而易见的：如果按向右箭头键，则知道如果文本行允许，光标必须向右移动一个位置。如果我们破坏了它的工作方式，那么一旦我们进行任何类型的手动测试，破损就会非常明显。</p><p> But… what happens if the cursor is located in the middle of the last visible line of text, with the viewport scrolled to the right because the line was extremely long, and we press enter to split it? That’s not something you usually do, so what’s the expected behavior there? We need to make sure that, once this works as we intend, it doesn’t unexpectedly break, and we don’t want to have to manually verify this every time we change the editor logic.</p><p> 但是……如果光标位于文本的最后可见行的中间，并且视口滚动到右侧（因为该行过长），然后按Enter键将其拆分，该怎么办？那不是您通常要做的事，那么那里的预期行为是什么？我们需要确保，一旦按预期运行，就不会意外中断，并且我们不想每次更改编辑器逻辑时都必须手动进行验证。</p><p> Behavior documentation. The collection of test cases for the TUI will serve us as the documentation of all cases we must care about in the code if we are doing any kind of refactoring, for example. As illustrated above, there are a lot of corner cases to deal with, and unless they are tracked somewhere, it’s too easy to forget about them.</p><p> 行为文档。例如，如果进行任何类型的重构，那么TUI的测试用例的收集将作为我们在代码中必须关注的所有用例的文档。如上所示，有很多情况需要处理，除非在某个地方进行跟踪，否则很容易忘记它们。</p><p> Efficiency measures. The last benefit these tests give us is a way to measure efficiency. By capturing the sequence of commands emitted by the TUI logic, we can see if those commands are  minimal. Because if they are not, the TUI will flicker.</p><p> 效率措施。这些测试给我们带来的最后一个好处是一种衡量效率的方法。通过捕获TUI逻辑发出的命令序列，我们可以查看这些命令是否最少。因为如果没有，则TUI将闪烁。</p><p> For example: an easy way to implement the TUI is to refresh the whole screen after every key press—and while that will yield updates that  look correct (and that would pass a testing model where we verify screen contents), the app will be doing too much work to update the screen. We need to worry about only doing partial screen updates (clearing a single line, using terminal scrolling features, etc.), and to that end, capturing the sequence of commands lets us do that.</p><p> 例如：实现TUI的一种简单方法是在每次按键后刷新整个屏幕，尽管这将产生看起来正确的更新（并且将通过我们验证屏幕内容的测试模型），但应用程序会执行太多的工作无法更新屏幕。我们只需要担心只进行部分屏幕更新（清除一行，使用终端滚动功能等），为此，捕获命令序列就可以做到这一点。 </p><p> The downside of this testing approach is that, again, we have no visual knowledge of how the screen looks like in the tests. Having the tests is thus insufficient to validate the TUI behavior: if we change the editor code, we will have to manually and visually inspect that our new changes behave accordingly. But the idea is that we will only need to do a minimal check-up for the new behavior once. After that, we can trust that our tests will catch unexpected changes that happen anywhere else.</p><p>再次，这种测试方法的缺点是，我们对测试中的屏幕外观没有直观的了解。因此，进行测试不足以验证TUI行为：如果我们更改了编辑器代码，则将必须手动并目视检查我们的新更改是否相应地起作用。但是我们的想法是我们只需要对新行为进行一次最少的检查。之后，我们可以放心，我们的测试将捕获其他地方发生的意外更改。</p><p> Let’s get to work by putting these ideas into practice to unit-test the EndBASIC text editor.</p><p> 让我们开始实践这些想法，对EndBASIC文本编辑器进行单元测试。</p><p>  The first thing we need is an abstraction layer between the editor (the TUI) and the console so that we have a point to hook into I/O operations for testing purposes.</p><p>  我们需要的第一件事是编辑器（TUI）和控制台之间的抽象层，以便我们可以挂接到I / O操作以进行测试。</p><p> Fortunately, EndBASIC already had one such abstraction, for two reasons: first, because I designed for testability upfront; and, second, because I intentionally wanted to keep the language’s core detached from any console-manipulation specifics (a necessity to support Unix systems, Windows, and the web).</p><p> 幸运的是，EndBASIC已经有了一个这样的抽象，这有两个原因：首先，因为我是为可测试性而预先设计的；其次，因为我有意要使该语言的核心与任何控制台操作无关（支持Unix系统，Windows和Web，因此都必须脱离）。</p><p>  pub   enum  Key   {    ArrowUp ,   ArrowDown ,   ArrowLeft ,   ArrowRight ,    Backspace ,   Enter ,   Eof ,    Char ( char ),    ...   }    pub   trait   Console   {    ...    fn  read_key ( &amp; mut   self )  -&gt;  io:: Result &lt; Key &gt; ;    ...   }</p><p>  pub枚举键{ArrowUp，ArrowDown，ArrowLeft，ArrowRight，Backspace，Enter，Eof，Char（char），...} pub trait控制台{... fn read_key（＆amp; mut self）-＆gt; io ::结果＆lt;键＆gt; ; ...}</p><p> We have a   Key enumeration to represent key presses at a high level, independent of their key codes. We have a   Console trait (think about this as an abstract base class if you aren’t familiar with Rust) to represent console operations in an abstract way. And the  Console trait provides a  read_key() hook to wait for an individual key press.</p><p> 我们有一个Key枚举，可独立于其按键代码来代表高级按键。我们具有控制台特性（如果您不熟悉Rust，可以将其视为抽象基类）以抽象方式表示控制台操作。控制台特性提供了一个read_key（）挂钩来等待单个按键。</p><p> Given this interface, our editor implements  an event loop based on the return value of  Console::read_key() and uses the generic  Key representation to process either control operations (e.g. moving the cursor) and edit operations (e.g. actual character insertion).</p><p> 有了这个接口，我们的编辑器会根据Console :: read_key（）的返回值实现一个事件循环，并使用通用的Key表示来处理控制操作（例如，移动光标）和编辑操作（例如，实际的字符插入）。 </p><p> And given this interface, supplying fake input data to our TUI is trivial. All we need to do is declare a   MockConsole implementation with a mock  read_key that, for each key press, yields a pre-recorded value taken from a sequence of golden key presses:</p><p>有了这个接口，向我们的TUI提供虚假的输入数据就变得微不足道了。我们需要做的就是声明一个带有模拟read_key的MockConsole实现，对于每个按键，它都会从一系列金键按下中产生一个预先记录的值：</p><p> struct  MockConsole   {    ...    golden_in:  VecDeque &lt; Key &gt; ,    ...   }    impl   Console   for   MockConsole   {    ...    fn  read_key ( &amp; mut   self )  -&gt;  io:: Result &lt; Key &gt;   {    match   self . golden_in . pop_front ()   {    Some ( ch )   =&gt;   Ok ( ch ),    None   =&gt;   Ok ( Key:: Eof ),    }    }    ...   }</p><p> struct MockConsole {... golden_in：VecDeque＆lt;键＆gt; ，...}用于MockConsole {... fn read_key（＆amp; mut self）-＆gt;的impl控制台。 io ::结果＆lt;键＆gt; {匹配自我。 golden_in。 pop_front（）{Some（ch）=＆gt;确定（ch），无=＆gt;确定（密钥：Eof），}} ...}</p><p> Now… you might think that this is overkill given that there already exist console abstraction layers out there. In fact, EndBASIC already uses  the  crossterm crate to support both Unix and Windows, so presumably this library could offer a way to mock the console for testing. Unfortunately, it doesn’t. And even if it did: I needed my own abstraction to keep the language’s core minimal and detached from heavy libraries; and I needed to  bypass  crossterm in the web (WASM) context, for which it cannot be built.</p><p> 现在...考虑到已经存在控制台抽象层，您可能会认为这太过分了。实际上，EndBASIC已经使用crossterm crate来支持Unix和Windows，因此，大概该库可以提供一种模拟控制台进行测试的方法。不幸的是，事实并非如此。即使这样做：我也需要自己的抽象以使语言的核心保持最小化，并与繁重的库分离。而且我需要绕过无法在Web（WASM）上下文中建立交叉项的条件。</p><p>  Now that we have put a basic console abstraction in place to read key presses, we can use it to manipulate the console itself too. Let’s extend our  Console trait with some of the primitives we need for a TUI:</p><p>  现在我们已经放置了一个基本的控制台抽象来读取按键，我们也可以使用它来操纵控制台本身。让我们用TUI所需的一些原语扩展控制台特性：</p><p> pub   trait   Console   {    ...    fn  clear ( &amp; mut   self )  -&gt;  io:: Result &lt; () &gt; ;    fn  locate ( &amp; mut   self ,   row:  u16 ,   col:  u16 )  -&gt;  io:: Result &lt; () &gt; ;    fn  write ( &amp; mut   self ,   bytes:  &amp; [ u8 ])  -&gt;  io:: Result &lt; () &gt; ;    ...   }</p><p> pub trait console {... fn clear（＆amp; mut self）-＆gt; io ::结果＆lt; （）＆gt; ; fnlocate（＆amp; mut self，row：u16，col：u16）-＆gt; io ::结果＆lt; （）＆gt; ; fn write（＆amp; mut self，字节：＆amp; [u8]）-＆gt; io ::结果＆lt; （）＆gt; ; ...}</p><p> Note that these are “high-level” primitives: they tell the console  what to do, but the caller doesn’t care about how that happens. The implementation is free to use ANSI codes wherever possible (maybe via  crossterm, maybe not) and direct Windows conhost manipulation calls when not.</p><p> 请注意，这些是“高级”原语：它们告诉控制台该怎么做，但调用者并不关心它是如何发生的。该实现可以自由使用ANSI代码（可能通过crossterm，也许不能），并在不使用时直接进行Windows conhost操作调用。</p><p> Or, you know, we can implement  a recorder that captures those calls for further validation in our tests and does nothing to the real console:</p><p> 或者，您知道，我们可以实现一个记录器，该记录器捕获这些调用以在测试中进行进一步的验证，而对真正的控制台不做任何事情： </p><p> enum  CapturedOut   {    Clear ,   Locate ( u16 ,   u16 ),   Write ( Vec &lt; u8 &gt; ),    ...   }    struct  MockConsole   {    ...    captured_out:  Vec &lt; CapturedOut &gt; ,    ...   }    impl   Console   for   MockConsole   {    ...    fn  clear ( &amp; mut   self )  -&gt;  io:: Result &lt; () &gt;   {    self . captured_out . push ( CapturedOut:: Clear );    Ok (())    }     fn  locate ( &amp; mut   self ,   row:  u16 ,   column:  u16 )  -&gt;  io:: Result &lt; () &gt;   {    self . captured_out . push ( CapturedOut:: Locate ( row ,   column ));    Ok (())    }     fn  write ( &amp; mut   self ,   bytes:  &amp; [ u8 ])  -&gt;  io:: Result &lt; () &gt;   {    self . captured_out . push ( CapturedOut:: Write ( bytes . to_owned ()));    Ok (())    }    ...   }</p><p>枚举CapturedOut {清除，找到（u16，u16），写（Vec＆lt; u8＆gt;），...} struct MockConsole {... capture_out：Vec＆lt; CapturedOut＆gt; ，...}用于MockConsole {... fn clear（＆amp; mut self）-＆gt;的impl控制台。 io ::结果＆lt; （）＆gt; {自我。 capture_out。推送（CapturedOut :: Clear）;确定（（））} fn定位（＆amp; mut self，行：u16，列：u16）-＆gt; io ::结果＆lt; （）＆gt; {自我。 capture_out。推（CapturedOut ::找到（行，列））; OK（（））} fn write（＆amp; mut self，字节数：＆amp; [u8]）-＆gt; io ::结果＆lt; （）＆gt; {自我。 capture_out。推（CapturedOut ::写（字节。to_owned（）））;好 （（））    }    ...   }</p><p> The  MockConsole will now hook into all console commands emitted by the editor and record them in a  captured_out array that we can later compare against golden data.</p><p> 现在，MockConsole将钩住编辑器发出的所有控制台命令，并将它们记录在capture_out数组中，我们以后可以将其与黄金数据进行比较。</p><p>  The last piece to make all of this palatable is to use the builder pattern to simplify expressing the test data. I’ll not follow my previous  suggestion to use the builder pattern to define test scenarios to the letter, but we’ll be close enough. The goal is to define our test scenarios in a declarative manner, and also be able to interleave causes (key presses) and effects (console changes) so that it’s easy to reason about what’s going on.</p><p>  使所有这些都变得可口的最后一步是使用构建器模式来简化表达测试数据。我不会遵循我以前的建议，即使用构建器模式来定义测试场景，但是我们已经足够接近了。目的是以声明性的方式定义我们的测试方案，并且还可以交错原因（按键）和效果（控制台更改），以便轻松推断正在发生的事情。</p><p>  MockConsoleBuilder: A builder to construct the golden input that the  MockConsole contains. This builder will let us accumulate input via separate calls using whichever representation makes more sense for the data at hand: either with  add_input_chars() to record long sequences of characters without the  Key::Char boilerplate or with  use_input_keys() to precisely inject  Key instances.</p><p>  MockConsoleBuilder：一个构建器，用于构造MockConsole包含的黄金输入。此构建器将使我们能够使用单独的调用来积累输入数据，无论哪种表示形式对手头的数据更有意义：使用add_input_chars（）记录较长的字符序列而无需使用Key :: Char样板，或者使用use_input_keys（）来精确注入Key实例。</p><p> OutputBuilder: A builder to construct the console commands that we expect the  MockConsole to capture. Similarly, this will let us accumulate “raw”  CapturedOut commands via  add() and will also provide us with higher-level operations that encapsulate common sequences of commands that the editor emits. For example, it’s very common for the editor to redraw the whole screen or parts of it, so we encapsulate all commands required to do so behind  refresh() and  quick_refresh(), respectively.</p><p> OutputBuilder：一个构建器，用于构建我们希望MockConsole捕获的控制台命令。同样，这将使我们可以通过add（）累积“原始” CapturedOut命令，并且还为我们提供了更高层次的操作，这些操作封装了编辑器发出的常见命令序列。例如，对于编辑器来说，重绘整个屏幕或屏幕的一部分是很普遍的，因此我们将执行此操作所需的所有命令分别封装在refresh（）和quick_refresh（）之后。</p><p> With these, we are now armed with all necessary knowledge and pieces to put the test cases together.</p><p> 有了这些，我们现在掌握了所有必要的知识和知识，可以将测试用例放在一起。</p><p> To illustrate how the tests might look like, I’ve  copy/pasted one of the editor tests verbatim and inserted detailed commentary to guide you through what’s going on:</p><p> 为了说明测试的样子，我逐字复制/粘贴了其中一个编辑器测试，并插入了详细的注释来指导您进行操作： </p><p> #[test]   fn  test_insert_in_empty_file ()   {    // Create a builder for the MockConsole and the collection of CapturedOut    // values we expect. These two builders let us interleave cause and    // effect, which makes it easier to understand what&#39;s going on.    let   mut   cb   =   MockConsoleBuilder:: new (). with_size ( rowcol ( 10 ,   40 ));    let   mut   ob   =   OutputBuilder:: new ( rowcol ( 10 ,   40 ));     // The first thing the editor does once it starts is clear the screen,    // write a status line, and position the cursor: aka a full screen    // refresh. This is a very common operation, so instead of cluttering    // each test case with the details on how this happens, I abstracted it    // away behind a refresh helper function that inserts these operations    // into the OutputBuilder.    ob   =   ob . refresh ( rowcol ( 0 ,   0 ),   &amp; [ &#34;&#34; ],   rowcol ( 0 ,   0 ));     // The editor is now up and running, waiting for key presses. We inject    // three different letters and then add expectations for each of them:    // namely, we want to see the letters appear in the terminal, we want to    // see the status bar to reflect the new position, and we want the cursor    // to move to a specific location. This is a faster version of the    // full-screen refresh, so I abstracted these sequences away behind    // quick_refresh.    cb   =   cb . add_input_chars ( &#34;abc&#34; );    ob   =   ob . add ( CapturedOut:: Write ( b&#34;a&#34; . to_vec ()));    ob   =   ob . quick_refresh ( rowcol ( 0 ,   1 ),   rowcol ( 0 ,   1 ));    ob   =   ob . add ( CapturedOut:: Write ( b&#34;b&#34; . to_vec ()));    ob   =   ob . quick_refresh ( rowcol ( 0 ,   2 ),   rowcol ( 0 ,   2 ));    ob   =   ob . add ( CapturedOut:: Write ( b&#34;c&#34; . to_vec ()));    ob   =   ob . quick_refresh ( rowcol ( 0 ,   3 ),   rowcol ( 0 ,   3 ));     // We now have a line of text. Let&#39;s press enter in its two forms and    // ensure that the cursor and editor state move accordingly two lines down.    cb   =   cb . add_input_keys ( &amp; [ Key:: NewLine ]);    ob   =   ob . quick_refresh ( rowcol ( 1 ,   0 ),   rowcol ( 1 ,   0 ));    cb   =   cb . add_input_keys ( &amp; [ Key:: CarriageReturn ]);    ob   =   ob . quick_refresh ( rowcol ( 2 ,   0 ),   rowcol ( 2 ,   0 ));     // We are at an empty line, so add one final character to it.    cb   =   cb . add_input_chars ( &#34;2&#34; );    ob   =   ob . add ( CapturedOut:: Write ( b&#34;2&#34; . to_vec ()));    ob   =   ob . quick_refresh ( rowcol ( 2 ,   1 ),   rowcol ( 2 ,   1 ));     // Our test scenario is ready. We now call the run_editor helper which    // constructs the Editor object and connects it to the MockConsole that    // can be obtained from cb.build(). run_editor then starts the editor,    // which will update the MockConsole with commands based on the sequence    // of keys it gets from it. Once the editor completes, we do two things:    // we validate that the raw text contents of the editor match the string    // we pass below, and we compare the captured commands against what we    // pre-recorded in ob.    run_editor ( &#34;&#34; ,   &#34;abc\n\n2\n&#34; ,   cb ,   ob );   }</p><p>＃[test] fn test_insert_in_empty_file（）{//为MockConsole和我们期望的CapturedOut值集合创建一个生成器。这两个构建器使我们可以交错因果关系，///从而更容易理解正在发生的事情。 let mut cb = MockConsoleBuilder :: new（）。 with_size（rowcol（10，40））; let mut ob = OutputBuilder :: new（rowcol（10，40））;复制代码//编辑器启动后要做的第一件事是清除屏幕，//写入状态行，然后定位光标：又名全屏刷新。这是一个非常常见的操作，因此//而不是使每个测试用例都杂乱无章，而是将其抽象化到刷新辅助函数的后面，该函数将这些操作插入到OutputBuilder中。 ob = ob。刷新（rowcol（0，0），＆amp; [＆＃34;＆＃34;]，rowcol（0，0））; //编辑器现在已启动并正在运行，等待按键。我们注入//三个不同的字母，然后为每个字母添加期望值：//即，我们希望看到字母出现在终端中，//我们希望看到状态栏以反映新的位置，并且希望光标//移动到特定位置。这是//全屏刷新的更快版本，因此我在quick_refresh之后将这些序列抽象了。 cb = cb。 add_input_chars（＆＃34; abc＆＃34;）; ob = ob。添加（CapturedOut ::写（b＆＃34; a＆＃34;。to_vec（）））; ob = ob。 quick_refresh（rowcol（0，1），rowcol（0，1））; ob = ob。添加（CapturedOut ::写（b＆＃34; b＆＃34;。to_vec（）））; ob = ob。 quick_refresh（rowcol（0，2），rowcol（0，2））; ob = ob。添加（CapturedOut ::写（b＆＃34; c＆＃34;。to_vec（）））; ob = ob。 quick_refresh（rowcol（0，3），rowcol（0，3））; //现在有一行文字。让我们按两种形式按Enter，并//确保光标和编辑器状态相应地向下移动两行。 cb = cb。 add_input_keys（＆amp; [Key :: NewLine]）; ob = ob。 quick_refresh（rowcol（1，0），rowcol（1，0））; cb = cb。 add_input_keys（＆amp; [Key :: CarriageReturn]）; ob = ob。 quick_refresh（rowcol（2，0），rowcol（2，0））; //我们处于空白行，因此在其中添加最后一个字符。 cb = cb。 add_input_chars（＆＃34; 2＆＃34;）; ob = ob。添加（CapturedOut ::写（b＆＃34; 2＆＃34;。to_vec（）））; ob = ob。 quick_refresh（rowcol（2，1），rowcol（2，1））; //我们的测试场景已准备就绪。现在，我们调用run_editor帮助器，它//构建Editor对象，并将其连接到MockConsole，该MockConsole //可以从cb.build（）获得。然后run_editor启动编辑器，//将根据从中获得的按键顺序//使用命令更新MockConsole。一旦编辑器完成，我们将做两件事：//我们验证编辑器的原始文本内容是否与我们在下面传递的字符串匹配//，并将捕获的命令与我们在ob中预记录的命令进行比较。 run_editor（＆＃34;＆＃34;，＆＃34; abc \ n \ n2 \ n＆＃34;，cb，ob）; }</p><p> And that’s it. The editor logic is a driver for the mock console, and thus we get full observability on what’s happening to the screen. Remember: this doesn’t tell us that what we  see is correct, but a quick manual spot check will tell us that it is. And once we know that the visual behavior is good, enshrining it in code will help us represent tricky corner cases and prevent regressions.</p><p> 就是这样。编辑器逻辑是模拟控制台的驱动程序，因此我们可以完全观察屏幕上发生的情况。请记住：这并不能告诉我们我们所看到的是正确的，但是快速的手动抽查会告诉我们它是正确的。并且一旦我们知道视觉行为是好的，将其包含在代码中将有助于我们呈现棘手的极端情况并防止回归。</p><p> As nice as it sounds, though, these tests do not com</p><p> 虽然听起来不错，但是这些测试并没有</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jmmv.dev/2020/12/unit-testing-a-console-app.html">https://jmmv.dev/2020/12/unit-testing-a-console-app.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/testing/">#testing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1038767.html"><img src="http://img2.diglog.com/img/2020/12/thumb_f9511362cb46960a6797ba0dda4b429c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038767.html">Google推出了健康研究应用程序 </a></div><span class="my_story_list_date">2020-12-10 6:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038754.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5a58f8bcd7585eb5b822efd9fac7e9ad.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038754.html">Adtech公司PubMatic开发了程序化广告的基础架构，在其IPO中筹集了1.18亿美元，在将其股票定价为20美元之后，达到了33.16美元的高位 </a></div><span class="my_story_list_date">2020-12-10 5:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038704.html"><img src="http://img2.diglog.com/img/2020/12/thumb_d56ec09b92e05f134e14a56e2b7b43d5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038704.html">Extra Crunch Partner Perk：借助“ Spotify for Mindfulness＆Sleep”应用程序Aura找到内心的平静 </a></div><span class="my_story_list_date">2020-12-10 2:55</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038702.html"><img src="http://img2.diglog.com/img/2020/12/thumb_1785901c75fa6d1f032c7c5e52b4437f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038702.html">Chrome为开发人员添加了新功能，为扩展程序开发人员引入了新的隐私规则 </a></div><span class="my_story_list_date">2020-12-10 2:55</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>