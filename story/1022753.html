<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>存档URL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">存档URL</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-08 23:27:26</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/a62291d4590d1fd0bee058f8a5f13899.png"><img src="http://img2.diglog.com/img/2020/9/a62291d4590d1fd0bee058f8a5f13899.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>互联网上的链接是永久的还是一年的，以先到者为准。这对任何认真写好推荐信的人来说都是一个大问题，因为链接腐烂每年会削弱所有链接的几个百分点，而且还会增加。</p><p>为了处理链接腐烂，我使用脚本、守护程序和Internet存档服务的组合提出了我的多管齐下的存档策略：定期从我的Web浏览器的日常浏览和我的网站页面转储到我编写的存档守护程序中，该守护程序先发制人地将副本下载到本地，并尝试将它们存档到Internet Archive中。这可确保从几个来源之一无限期地提供副本。然后，通过定期运行链接检查器来检测链接损坏，并且可以立即检查任何新死的链接以寻找替代位置，或者从其中一个归档源恢复。</p><p>作为额外的优势，我的本地档案是以防伪造是一个问题，我演示了一个简单的爬行压缩技巧(特别适用于重复爬行，比如我的)。</p><p>鉴于我对长期内容和广泛链接的兴趣，这是我深切关注的问题。我需要备份的不仅仅是我的文件1，还有我阅读和使用的网页--它们都是我的一部分。在某个主题上发表一篇篇幅广泛的文章是没有多大好处的，因为在这些主题中，一半的链接已经失效，读者既无法验证我的主张，也无法了解我的主张的背景。</p><p>“腐烂是所有复合体固有的。勤奋地想出自己的救赎之道。“。</p><p>在2003年的一次实验中，费特利等人。发现每周大约每200个链接中就有一个从互联网上消失。发现文章中引用的一半在发表10年后不再可访问[讽刺！]，其他研究表明学术文献中的链接腐烂更严重(Spinellis，2003，Lawrence et al.，2001)。Nelson和Allen(2002)检查了数字图书馆中的链接ROT，发现大约3%的对象在一年后不再可以访问。</p><p>评论说，一位朋友在不到9年的时间里在他的一个页面上经历了50%的链接腐烂(并不是1998年的情况更好)，他自己的博客帖子链接到了2天内就死掉的新闻文章；Vitorio检查了1997年的书签，发现总链接腐烂了91%，只有一半的死链接可以从互联网档案馆等来源获得；Ernie Smith在1994年的一本关于互联网的书中找到了1个半工作链接；据估计，网页的平均寿命为100天。一项研究查看了著名期刊上的文章；他们使用的互联网链接并不多，但当他们使用互联网链接时，两年后，大约13%的人死了3。法国公司Linterweb在建立法国外部链接的缓存之前，对网上的外部链接进行了研究，发现-早在2008年-已经有5%的人死了。(英文维基百科从2010年1月到2011年1月从几千个死链接激增到1750万个活跃链接中的11万个。)。对病毒的后续检查发现，十年后的2017年，至少有一半的链接已经死亡或蹲下。2006年1月，最后一个链接的插入成本高达3.8万美元。提供一些存档服务的4书签网站在2014年8月指出，17%的3年期链接和25%的5年期链接已经死亡。令人沮丧的事情还在继续(还在继续)。即使在一个高度稳定、有资金、有计划的环境中，链接腐烂仍然会发生。例如，大约在一年内就消失了(尽管Twitter目前仍然存在)。有时，他们只是悄悄地迷失了方向，比如MySpace承认它丢失了2003-2015年全球上传的所有音乐，并委婉地将大规模删除描述为“我们完全重建了Myspace，并决定从旧的MySpace中转移一些内容”(只有部分2008-2010年的MySpace音乐可以挽救，并由“一项匿名学术研究”放在IA上)。</p><p>我的具体目标日期是2070年，也就是从现在开始的60年后。截至2011年3月10日，gwern.net大约有6800个外部链接(其中约2200个链接到非维基百科网站)5。即使是每年3%的最低估计，也很少人能活到2070年。如果每个链接每年都有97%的存活机会，那么一个链接在2070年存活的可能性是0.97 2070−2011≈0.16(或者换一种说法，任何给定的链接都会死亡的可能性为84%)。如果我们尝试使用50%的链接率进行预测，那么平均将有0个链接存活下来(0.502070年−2011年⋅2200=1.735⋅10−16⋅2200≃0)。简单地假设没有任何链接将会继续存在，这将是一个好主意。</p><p>考虑到这一点，我们可以考虑补救措施。(如果我们对自己撒谎，说将来不会有问题，那么我们就保证会有问题。“人们能忍受真理，因为他们已经在忍受它了。”</p><p>如果你想先发制人地存档一个特定的页面，这很容易：去IA存档它，或者在你的网络浏览器中打印它的一部分，或者对于更复杂的页面，使用浏览器插件(如Firefox、Mozilla存档格式或剪贴簿)。但我发现我访问和链接了太多的网页，以至于我很少提前想到链接损坏来保存副本；我需要的是一种更系统的方法来检测和创建我可能需要的所有网页的链接。</p><p>“每一个新的春天，花朵都不说一句话，还在阐述律法--通过散落的暴风雨知道它的核心是什么。”</p><p>第一个补救措施是一旦链接被破坏，就立即了解它们，这可以让人迅速做出反应，并清除档案或搜索引擎缓存(“懒惰保存”)。我目前使用链接检查器来爬行gwern.net，寻找断开的链接。链接检查器在如下作业中运行：</p><p>@每月链接检查器--检查外部--超时=35--无警告--文件输出=html\--忽略-url=^邮件--忽略-url=^irc--忽略-url=http://.*\.onion\--忽略-url=paypal.com--忽略-url=web.archive ve.org\https://www.gwern.net。</p><p>仅此命令就会出现许多误报。例如，在维基百科链接上会有数百个警告，因为我链接到重定向；而链接检查器尊重禁止它检查活跃性的s，但会发出关于这一点的警告。可以通过编辑~/.linkcheckker/linkcheckerrc来取消这些警告，使其表示忽略警告=http-moved-Permanent，http-Robots-Dended(可用的警告类在linkcheckker-h中列出)。</p><p>你越快知道一条死掉的链路，你就能越早找到替代品或它的新家。</p><p>“你在网上发布的任何东西，只要让人难堪就会在那里，只要有用就会消失。”</p><p>我们可以要求第三方为我们保留一个缓存。有几种可能性：</p><p>还有其他选择，但它们不像Google10或各种商业/政府档案11那样可用。</p><p>您可能会保留它的备份，但您自己的网站/服务器备份可能会丢失(从我个人的经验来看)，所以拥有外部副本是很好的。</p><p>另一个好处是减少了“公交车因素”：如果你明天被公交车撞了，谁来拿你的档案，谁来维护网站和了解备份等等？而如果存档在IA中，人们已经知道如何获得副本，并且有工具可以下载整个域名。</p><p>专注于只备份自己的网站可能会使人忽视对外部链接进行存档的需要。由于链接断开，许多页面毫无意义或价值降低。链接检查器脚本/守护程序还可以存档所有外部链接。</p><p>按照这种思路，我的第一个程序是一个机器人，它启动了WebCite，Internet Archive/Alexa，&amp；Archive.is Requests：，然后很快就有了一个。(或者，如果您不再关心隐私，也可以安装以自动提交到Internet Archive。)。</p><p>核心代码很快被改编成Gitit wiki插件，该插件连接到保存页面功能，并尝试存档新修改的页面Interwiki.hs中的每个链接。</p><p>最后，我编写了Archiver，这是一个监视12/读取文本文件的守护进程。来源可通过GIT克隆https://github.com/gwern/archiver-bot.git.获得。(类似的工具是Archiveror。)</p><p>Archiver的库的一半是适当请求的简单包装器；可执行的一半读取指定的文本文件并循环，因为它(缓慢地)发出请求并删除适当的。</p><p>也就是说，Archiver是一个守护进程，它将处理指定的文本文件，其中每一行都是，并逐个请求存档或爬行。</p><p>Archiver的用法可能类似于Archiver~/.urls.txt gwern@gwern.net。在过去，Archiver有时会因为未知的原因而崩溃，所以我通常将其封装在While循环中，如下所示：虽然为true；do archive ver~/.urls.txt Gwern@gwern.net；Done。如果我想把它放在一个独立的会话中：screen-d-m-S&#34；archive ver&#34；sh-c&#39；虽然为true；do archive ver~/.urls.txt Gwern@gwern.net；Done&#39；。最后，我不是手动启动它，而是使用cron作业在引导时启动它，以便最后调用。</p><p>@reboot睡眠4M&amp；&amp；screen-d-m-S&34；archive ver&#34；sh-c&#39；true；do archive ver~/.urls.txt gwern2@gwern.net\&#34；cd~/www&amp；&amp；NICE-N 20 ionice-c3 wget--unlink--Limit-rate=20k--page-requisites--时间戳\-e机器人=OFF--拒绝.iso、.exe、.gz、.xz、.rar、.7z、.tar、.bin、.zip、.jar、.flv、.mp4、.avi、.webm\--用户代理=&#39；Firefox/4.9&#39；&#34；500。</p><p>远程存档虽然方便，但有一个重大缺陷：存档服务跟不上互联网的增长，而且非常不完整。我经常遇到这种情况，gwern.net上的一个链接失效了，我在Internet Archive或WebCite中找不到它，这是一个普遍的现象：发现35%的普通网页曾经复制到存档服务中，而且通常只有一个副本。</p><p>对于本地缓存，最雄心勃勃的方法是设置一个代理来进行浏览，并逐字记录您的所有Web流量；例如，使用Live Archiving Proxy()或WarcProxy，它将保存为您通过它访问的每个页面。(Zachary Vance还解释了如何为您的浏览设置本地证书。)。</p><p>人们可能不愿意走到这一步，而更喜欢一些轻量级的东西，比如定期从自己的网络浏览器中提取访问过的s的列表，然后尝试将它们存档。</p><p>#！/bin/sh set-euo pipeail cp`find~/.mozilla/-name&#34；places.sqlite&#34；`~/sqlite3 places.sqlite&#34；从moz_places.id=moz_History yvisits.place_id\和access_date&gt；strftime(&#39；%s&#39；，&#39；now)中选择url&#34；|Filter-URL&gt；&gt；~/.tmp rm~/places.sqlite Split-l500~/.tmp~/.tmp-urls rm~/.tmp cd~/www/对于~/.tmp-urls*；do(wget--解除链接--继续--页面必需--时间戳--输入文件$file&amp；&amp；rm$file&amp；)；完成查找~/www-size</p><p>该脚本通过从历史数据库文件13中提取我的Firefox浏览历史来获取它，并将s提供给。</p><p>Wget不是最好的存档工具，因为它不会运行JavaScript或Flash，也不会下载视频等。它会下载包含的JS文件，但JS在未来运行时将会过时，任何动态内容都会消失很久。要做得更好，需要一个类似于保存到/的无头浏览器，但是PhantomJS拒绝支持它，而且我不知道现有的包可以做到这一点。在实践中，静态内容是最重要的归档内容，大多数js的价值首先是非常值得怀疑的，而且任何重要的youtube视频都可以使用youtube-dl手动归档，所以wget的限制并不是那么糟糕。</p><p>该脚本将长长的列表拆分成一组文件，并并行运行那么多个wget，因为wget显然无法同时从多个域下载。Wget也有可能无限期挂起，因此并行下载会继续取得进展。</p><p>Filter-urls命令是另一个shell脚本，它删除了我不想存档的。此脚本是一种黑客攻击，如下所示：</p><p>#！/bin/sh set-euo pipeail cat/dev/stdin|sed-e&#34；s/#.*//&#34；|sed-e&#34；s/&amp；sid=.*$//&#34；|sed-e&#34；s/\/$/&#34；|grep-v-e 4chan-e reddit...。</p><p>删除任何特别大(&gt；4MB)的文件，这些文件可能是视频或音频等媒体文件(播客是特别严重的问题)。</p><p>本地副本不是最好的资源-如果链接以您的工具无法检测到的方式死机，那么您不知道将副本放在某个地方怎么办？但它果断地解决了问题。</p><p>不是自动的：您必须记住调用它，并且它只提供一个本地存档，或者如果您定期将其作为cron作业调用，则可能会创建许多重复的存档。</p><p>不可靠：wget可能挂起，%s可能存档太晚，可能调用不够频繁，&gt；4MB的非视频/音频文件越来越常见…。</p><p>我还想要其他地方的Internet Archive&amp；中的副本，以便让其他人受益，并为我的本地档案提供冗余。</p><p>正是为了解决这些问题，我开始研究存档程序-它将在后台持续运行存档程序，将它们也存档到IA中，并且更聪明地处理媒体文件下载。它已经令人满意得多了。</p><p>Archiver有一个额外的特性，在该特性中，任何第三个参数都被视为任意的sh命令，在每个参数存档之后都可以运行，后面会附加Said。如果您想要将它们加载到Firefox中，或者将它们附加到日志文件中，或者只是以其他方式下载或存档，则可以使用此功能。</p><p>例如，我让Archiver在每个人上运行wget，而不是运行大型本地Archiver：screen-d-m-S&34；archive ver&#34；sh-c&#39；while true；do archive ver~/.urls.txt Gwern@gwern.net&34；cd~/www&amp；&amp；Wget--unlink--Continue--page-requisites--timeStamp-e Robots=off--拒绝.iso、.exe、.gz、.xz、.rar、.7z、.tar、.bin、.zip、.jar、.flv、.mp4、.avi、.webm--user-agent=&#39；Firefox/3.6&#39；120&#34；完成&#39；。(对于需要登录的私有用户，比如，wget仍然可以通过一些帮助来获取它们：安装Firefox扩展导出Cookie，像往常一样在Firefox中登录站点，导出用户的cookies.txt，并添加选项--load-cookies cookies.txt以授予其访问cookie的权限。)。</p><p>或者，您可以使用cURL或专门的归档下载器，如Internet Archive的爬虫Heritrix。</p><p>这样的备份占用的空间并不是那么糟糕；一年的浏览只有30-50 GB，而且更少，这取决于您清理下载的力度有多大。(当然，如果您使用链接检查器来存档整个站点，而不仅仅是您访问的页面，则需要更多。)。从长远来看，存储这些内容是相当可行的；虽然页面大小在2003至2011年间增加了7倍，页面大小平均在400KB左右14，但也一直在运营，磁盘容量增加了约128倍-在2011年，80美元可以买到至少2TB，这相当于每GB 4美分，或者下载的最低估计为80美分；这比某些地方(如Pinboard)收取的25美元年费要好得多。当然，您需要自己备份这些内容。我们在这里相对幸运-大多数互联网文档都是“天生的数字”，很容易迁移到新的格式或在未来进行检查。我们可以下载它们，并担心只有在需要特定文档时才能查看它们，而Web浏览器的向后兼容性可以追溯到20世纪90年代初编写的文件。(当然，如果我们发现我们想要的内容只在Adobe Flash中动态呈现，或者作为一种无法访问的“云”服务，我们可能就完蛋了。)。相比之下，如果我们试图保存程序或软件库，我们将面临一项艰巨得多的任务，那就是保持一个由二进制兼容的虚拟机或解释器组成的工作阶梯15。数字电影保存的情况几乎不值得考虑。</p><p>有一些方法可以减小大小；如果您将其全部压缩，并使用最大压缩选项运行，您可能可以将其压缩到大小的1/5。我发现，通过使用查找重复文件，并使用fdupes--recurse--hardlink~/www/这样的命令将副本转换为节省空间的原始文件，可以将未压缩的文件减少约10%。(显然有很多位相同的JavaScript(例如，)。以及外面的图像。)</p><p>良好的源过滤可以帮助大量减少存档计数。检查我的Firefox浏览历史的手动备份，从2014-02-25到2017-04-22的1153天内，我每天访问2,370,111秒或2055秒；通过我的过滤脚本后，剩下171,446秒，在重复数据消除后，每天会产生39,523秒或~34个唯一的s或每年12,520个唯一的要存档的数据。</p><p>这会将我的归档从65 GB缩小到56 GB，尽管这是以删除许多文件类型(如或JavaScript或图像)来换取一定的归档保真度为代价的。截至2017年4月22日，经过大约6年的归档，在XZ压缩(以降低可搜索性为代价)、积极过滤、偶尔手动删除过大的域名(我觉得IA可能已经足够覆盖这些域名等)之间，我的完整归档重达55 GB。</p><p>填充源文本文件的方法有多种。例如，我有一个脚本Firefox-urls：</p><p>#！/bin/sh set-euo pipeailure cp--force`find~/.mozilla/Firefox/-name&#34；places.sqlite&#34；|SORT|head-1`~/sqlite3-Batch places.sqlite&#34；从moz_Places，moz_historyaccess\where moz_places.id=moz_History yvisits.place_id and\access_date&gt；strftime(&#)中选择url。)*1000000 ORDER BY\ACCESS_DATE；&#34；|过滤器URL rm~/Places.sqlite。</p><p>(Filter-URL与本地存档程序中的脚本相同。如果我不需要本地域，我也不会费心进行远程备份。事实上，由于WebCite的速率限制，Archiver几乎总是处于积压状态，我尤其不希望它将时间浪费在像这样的毫无价值的链接上。)。</p><p>这将获取上一时间段内所有访问过的，并将它们打印到文件中，以便存档程序进行处理。因此，我浏览的所有内容都通过Archiver进行备份。</p><p>非Firefox浏览器也可以使用类似的策略来支持；例如，Zachary Vance的Chromium脚本同样可以从Chromium的历史&amp；书签中提取s。</p><p>更有用的可能是从Markdown文件中提取外部链接并将其打印到标准输出的脚本：link-Extractor.hs</p><p>所以现在我可以用Find了。-name&#34；*.page&#34；，将我的wiki中的100个左右的Markdown文件作为参数传递，并将1000个左右的外部链接添加到存档程序队列(例如，找到。-name&#34；*.page&#34；-type f-Print0|xargs-0~/wiki/haskell/link-Extractor.hs|filter-urls&gt；&gt；~/.urls.txt)；它们最终将被存档/备份。</p><p>有时，即使没有访问某个网站上的每个页面，人们也会对该网站产生长期的兴趣；您可以手动访问这些网站，然后依靠以前的Firefox脚本将s转储到存档程序中，但这并不总是实用或省时的。LinkChecker天生就会抓取它打开的网站，所以它可以在一个域上构建或简单地吐出所有的就不足为奇了；不幸的是，虽然LinkChecker能够以惊人的各种格式输出，但它不能简单地输出以新行分隔的s列表，因此我们需要对输出进行相当程度的后处理。以下是我想要存档整个站点时使用的shell一行程序(请注意，这是一个在大型或高度超链接的站点上运行的错误命令，如。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.gwern.net/Archiving-URLs">https://www.gwern.net/Archiving-URLs</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/存档/">#存档</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/archiving/">#archiving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/链接/">#链接</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>