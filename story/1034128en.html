<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>什么是片上系统(SoC)，为什么我们要关心它们是否是开源的？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">什么是片上系统(SoC)，为什么我们要关心它们是否是开源的？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 04:21:07</div><div class="page_narrow text-break page_content"><p>Modern gadgets are typically built around a single, highly integrated chip, known as a “System on Chip” (SoC). While the earliest home computer motherboards consisted of around a hundred chips, Moore’s Law pushed that down to just a handful of chips by the time 80286 PC/AT clones were mainstream, and the industry has never looked back. Now, a typical SoC integrates a CPU core complex, plus dozens of peripherals, including analog, RF, and power functions; there are even “System in Package” solutions available that package the SoC, RAM, and sometimes even the FLASH die into a single plastic package.</p><p>现代电子产品通常都是围绕一个高度集成的芯片，也就是所谓的“片上系统”(SoC)来制造的。虽然最早的家用电脑主板由大约100个芯片组成，但摩尔定律将这一数字推低到只有几个芯片，当时80286个PC/AT克隆电脑成为主流，而且这个行业从未回头看过。现在，一个典型的SoC集成了一个CPU核心复合体，外加数十个外围设备，包括模拟、射频和电源功能；甚至有“系统集成”解决方案，可以将SoC、RAM，有时甚至闪存芯片封装到一个塑料封装中。</p><p> Modern SoCs are exceedingly complex. The “full user’s manual” for a modern SoC is thousands of pages long, and the errata (“bug list”) – if you’re allowed to see it – can be hundreds of pages alone. I put “full user’s manual” in quotations because even the most open, well-documented SoCs (such as the i.MX series from NXP) require a strict NDA to access thousands of pages of documentation on third party Intellectual Property (IP) blocks for functions such as video decoding, graphics acceleration, and security. Beyond the NDA blocks, there is typically a deeper layer of completely unpublished documentation for disused silicon, such as peripherals that were designed-in but did not make the final cut, internal debugging facilities, and pre-boot facilities. Many of these disused features aren’t even well-known within the team that designed the chip!</p><p>现代的SoC非常复杂。现代SoC的“完整用户手册”长达数千页，勘误表(“错误列表”)--如果你被允许查看的话--可能就有数百页。我引用“完整的用户手册”是因为即使是最开放、文档最齐全的SoC(例如恩智浦的i.MX系列)也需要严格的保密协议才能访问数千页有关第三方知识产权(IP)块的文档，以实现视频解码、图形加速和安全等功能。除了NDA模块之外，通常还有更深层次的完全未发布的废弃硅文档，例如设计好但没有进行最终切割的外围设备、内部调试设施和预引导设施。这些废弃的功能中有许多甚至在设计芯片的团队中都不为人所知！</p><p> Disused silicon is a thing because building chips is less like snapping together Legos, and more like a sculptor chiseling away at a marble block: adding a circuit is much harder than deactivating a circuit. Adding a circuit might cost around $1 million in new masks, while delaying the project by about 70 days (at a cost of 100,000 man-hours worth of additional wages); with proper planning, deactivating a circuit may be as simple as a code change, or a small edit to a single mask layer, at a cost of perhaps $10,000 and a few days (assuming wafers were held at intermediate stages to facilitate this style of edit).</p><p>废弃的硅是一件事，因为构建芯片不像是把乐高拼凑在一起，而更像是雕刻家在大理石块上雕刻：添加电路比停用电路难得多。增加一个电路可能要花费大约100万美元的新掩膜，同时将项目推迟大约70天(代价是10万个工时的额外工资)；如果规划得当，停用一个电路可能就像更改代码或对单个掩模层进行小编辑一样简单，成本可能是1万美元到几天(假设晶片被保存在中间阶段，以促进这种风格的编辑)。</p><p> photo credit: “Man With Mallet &amp; Chisel Bas Relief (Washington, DC)” by takomabibelot is licensed under CC BY 2.0</p><p>图片来源：Takomabibelot的《拿着木槌和凿子的人浮雕(华盛顿特区)》由CC by 2.0授权。</p><p> Thus a typical SoC mask set starts with lots of extra features, spare logic, and debug facilities that are chiseled away (disused) until the final shape of the SoC emerges. As Michelangelo once said “every block of stone has a statue inside it, and it is the task of the sculptor to discover it,” we could say  “every SoC mask set has a datasheet inside it, and it is the task of the validation team to discover it”. Sometimes the final chisel blow happens at boot: an errant feature may be turned off or patched over by pre-boot code that runs even before the CPU executes its first instruction. As a result, even the best documented SoCs will have a non-trivial fraction of transistors that are disused and unaccountable, theoretically invisible to end users.</p><p>因此，典型的SoC掩模组从大量额外的功能、备用逻辑和调试设施开始，这些都被凿掉(废弃)，直到SoC的最终形状出现。正如米开朗基罗曾经说过的那样：“每一块石头里都有一尊雕像，雕塑家的任务就是发现它。”我们可以说，“每一套SoC面具都有一份数据表，而验证团队的任务就是发现它。”有时最后的打击发生在引导时：错误的功能可能会被甚至在CPU执行其第一条指令之前运行的预引导代码关闭或修补。因此，即使是记录最好的SoC，也将有相当一部分晶体管被废弃和不负责任，理论上对最终用户是看不见的。</p><p> From a security standpoint, the presence of such “dark matter” in SoCs is worrisome. Forget worrying about the boot ROM or CPU microcode – the BIST (Built in Self Test) infrastructure has everything you need to do code injection, if you can just cajole it into the right mode. Furthermore, SoC integrators all buy functional blocks such as DDR, PCI, and USB from a tiny set of IP vendors. This means the same disused logic motifs are baked into hundreds of millions of devices, even across competing brands and dissimilar product lines. Herein lies a hazard for an unpatchable, ecosystem-shattering security break!</p><p>从安全的角度来看，SoC中这种“暗物质”的存在令人担忧。忘了担心引导ROM或CPU微码吧--BIST(内置自检)基础设施拥有代码注入所需的一切，只要您能诱使它进入正确的模式即可。此外，SoC集成商都从极少数IP供应商那里购买DDR、PCI和USB等功能块。这意味着，相同的废弃逻辑主题被植入数亿台设备中，即使是在相互竞争的品牌和不同的产品线上也是如此。这就给无法修补、破坏生态系统的安全漏洞埋下了隐患！</p><p> Precursor sidesteps this hazard by implementing its SoC using an FPGA. FPGAs are user-reconfigurable, drastically changing the calculus on the cost of design errors; instead of chiseling away at a block of marble, we are once again building with a Lego set. Of course, this flexibility comes at a cost: an FPGA is perhaps 50x more expensive than a feature-equivalent SoC and about 5-10x slower in absolute MHz. However, it does mean there is no dark matter in Precursor, as every line of code used to describe the SoC is visible for inspection. It also means if logic bugs are found in the Precursor SoC, they can be patched with an update. This drastically reduces the cost to iterate the SoC, making it more economically compatible with an open source approach. In an ideal world, the Precursor SoC design will be thoroughly vetted and audited over the next couple of years, converging on a low-risk path toward a tape out in fixed silicon that can reduce production costs and improve performance all while maintaining a high standard of transparency.</p><p>Premitive使用FPGA实现其SoC，从而避免了这一风险。现场可编程门阵列是用户可重新配置的，极大地改变了设计错误的成本计算；我们不再凿开一块大理石，而是再一次用乐高积木来建造。当然，这种灵活性是有代价的：一个FPGA的价格可能是同等功能的SoC的50倍，在绝对MHz下大约慢5-10倍。然而，这确实意味着在前身中没有暗物质，因为用于描述SoC的每一行代码都是可见的，以供检查。这也意味着，如果在前身SoC中发现逻辑错误，可以通过更新来修补它们。这极大地降低了迭代SoC的成本，使其在经济上与开源方法更加兼容。在理想的情况下，前身SoC设计将在未来几年内进行彻底的审查和审计，集中在低风险的路径上，走向固定硅的磁带生产，在保持高标准透明度的同时，降低生产成本和提高性能。</p><p>  Precursor’s SoC is built using LiteX. LiteX is a framework created by  Florent Kermarrec for defining SoCs using the Migen/MiSoC FHDL, which itself is written in Python 3.6+. The heart of LiteX is a set of “handlers” that will automatically adapt between bus standards and widths. This allows designers to easily mix and match various controllers and peripherals with Wishbone, AXI, and CSR, bus interconnect standards. It is pretty magical to be able to glue an extra USB debug controller into a complex SoC with just a few lines of code, and have an entire infrastructure of bus arbiters and adapters figure themselves out automatically in response. If you want to learn more about LiteX and FPGAs, a great place to start is Florent’s  “FPGA_101” mini-course.</p><p>前身的SoC是使用Litex制造的。Litex是由Florent Kermarrec创建的一个框架，用于使用Migen/MiSoC FHDL定义SoC，而Migen/MiSoC FHDL本身是用Python3.6+编写的。Litex的核心是一组自动在总线标准和宽度之间进行调整的“处理程序”。这使设计人员可以轻松地混合搭配各种控制器和外围设备</p><p>   Above is a block diagram of Precursor’s SoC, as of October 2020. It’s important to pay attention to the date on documentation, because an FPGA-based SoC can and will change over time. We generally eschew pretty, hand-drawn block diagrams like this because they are out of date almost the day they are finished. Instead, our equivalent of a  “programmer’s manual” is dynamically generated by our CI system with every code push, and for Rust programmers we have a tool,  svd2utra that automatically translates SVD files generated by LiteX into a Rust API crate. With an open source FPGA-based SoC, automated CI isn’t merely best practice, it’s essential, because small but sometimes important patches in submodule dependencies will regularly affect your design.</p><p>上图是截至2020年10月的前身系统芯片(SoC)框图。重要的是要注意文档上的日期，因为基于FPGA的SoC可以而且会随着时间的推移而改变。我们通常会避开像这样漂亮的手绘框图，因为它们几乎在完成的那一天就过时了。相反，我们的CI系统在每次代码推送时都会动态生成相当于“程序员手册”的内容。对于Rust程序员，我们有一个工具svd2UTRA，它可以自动将Litex生成的SVD文件转换为Rust API板条箱。对于基于FPGA的开源SoC，自动化CI不仅是最佳实践，而且是必不可少的，因为子模块依赖关系中的小补丁(有时是重要的补丁)会定期影响您的设计。</p><p>  The “Core Complex” currently consists of one RISC-V core, implemented using  Charles Papon’s VexRiscV. We configured it to support the “RV32IMAC” instruction subset, gave it an MMU, and beefed up the caches. The VexRiscV limits cache size to 4kiB, but effective capacity can be increased by upping the cache associativity. We get about a 10% performance boost by tuning the core to have a two-way I-cache, and a four-way D-cache. We also provision a 32 kiB boot ROM, which currently holds  three instructions, but will someday be expanded to include signature checks on code loaded from external memory and a 128kiB on-board SRAM for tightly coupled/higher security operations. The CPU core is adapted to, and arbitrated into, a multi-controller Wishbone bus by LiteX and further adapted into a CSR bus by a dedicated CSR bridge that has been configured to automatically space peripherals on 4-kiB page boundaries, so that they can be individually remapped with the MMU. There’s also an IRQ handler that manages interrupts originating from peripherals sprinkled around the chip.</p><p>“核心复合体”目前由一个RISC-V核心组成，使用Charles Papon的VexRiscV实现。我们将其配置为支持“RV32IMAC”指令子集，为其提供了MMU，并增强了缓存。VexRiscV将缓存大小限制为4kiB，但可以通过提升缓存关联性来增加有效容量。通过将内核调优为具有双向I-缓存和四路D-缓存，我们获得了大约10%的性能提升。我们还提供了32 KiB引导ROM，它目前包含三条指令，但有朝一日会扩展到包括对从外部存储器加载的代码进行签名检查，以及用于紧密耦合/更高安全性操作的128kiB板载SRAM。CPU内核通过Litex适配并仲裁到多控制器Wishbone总线，并通过专用CSR桥进一步适配到CSR总线，该专用CSR桥被配置为在4-KiB页面边界上自动分隔外围设备，以便它们可以单独地与MMU重新映射。还有一个IRQ处理程序，用于管理散布在芯片周围的外围设备产生的中断。</p><p>  The Core Complex also includes a set of mostly boilerplate CSRs which perform the following functions:</p><p>核心复合体还包括一组主要是样板的CSR，它们执行以下功能：</p><p> “Timer 0” is the default timer provided by LiteX. It is a high resolution 32-bit timer clocked at the same frequency as the CPU core.</p><p>定时器0是Litex提供的默认定时器。它是一个高分辨率的32位定时器，时钟频率与CPU内核相同。</p><p> “CRG” is an interface to control the FPGA’s clock generator. Right now we don’t do much with it, but eventually this is going to play a central role in power management and extending battery life.</p><p>“CRG”是一个控制FPGA时钟发生器的接口。目前我们在这方面做的还不多，但最终这将在电源管理和延长电池寿命方面发挥核心作用。</p><p> “Git Info” is a static register that provides information about the state of the git repo from which Precursor was built.</p><p>“Git Info”是一个静态寄存器，它提供有关构建前身的Git repo的状态信息。</p><p> “BtSeed” is a 64-bit number that can be randomized to force entropy into the place-and-route process, in case the end user desires a final FPGA netlist unique to their device without having to modify the code (otherwise the builds are entirely reproducible).</p><p>“BtSeed”是一个64位的数字，它可以被随机化，以便在终端用户不需要修改代码(否则，构建是完全可重现的)的情况下，将熵强制到布局布线过程中，以避免最终的FPGA网表对于他们的设备来说是唯一的(否则，构建是完全可重现的)。</p><p>  “TickTimer” is a low-resolution, 64-bit timer clocked in 1 ms increments. It serves as a source of time for the Xous OS.</p><p>“TickTimer”是一个低分辨率的64位计时器，以1ms为增量计时。它是XOUS操作系统的时间来源。</p><p>  Adjacent to the Core Complex is a Debug block. The Debug block features a full speed USB MAC/PHY that can tunnel Wishbone packets and serve as an alternate Wishbone controller to the CPU. We use this to drive the debug interface on the CPU, thus allowing GDB to connect to Precursor over USB even when the CPU is halted. In fact, one could build Precursor with no RISC-V CPU and just tunnel Wishbone packets over USB for debug and driver development. The debug block also includes a small CSR peripheral called the “Messible”, which is a 64-entry by 8-bit wide FIFO, useful as a mailbox/scratchpad during debugging.</p><p>紧邻核心建筑群的是一个调试块。Debug模块具有全速USB MAC/PHY，可以通过隧道传输Wishbone数据包，并充当CPU的备用Wishbone控制器。我们使用它来驱动CPU上的调试接口，从而使gdb即使在CPU停止时也可以通过USB连接到前身。事实上，人们可以在没有RISC-V CPU的情况下构建前身，只需通过USB传输Wishbone数据包来进行调试和驱动程序开发。调试块还包括一个称为“Messible”的小型CSR外设，它是一个64个条目、8位宽的FIFO，在调试期间用作邮箱/便签簿。</p><p>   The memory space of the RISC-V CPU is mapped onto various peripherals and memory blocks via a  Wishbone bus. For traditional SoC designers, Wishbone is kind of like AXI, but open source. Wishbone supports fancy features like multiple masters, pipelining, and block transfers. A portion of the Wishbone bus space is further mapped onto a bus called the  Configuration and Status Register (CSR) bus.</p><p>RISC-V CPU的存储空间通过Wishbone总线映射到各种外设和内存块上。对于传统的SoC设计者来说，Wishbone有点像AXI，但它是开源的。Wishbone支持多主控、流水线和块传输等奇特功能。Wishbone总线空间的一部分进一步映射到称为配置和状态寄存器(CSR)总线的总线上。</p><p> While Wishbone is high-performance, it requires more interface logic and is happiest when the peripheral’s bit width matches the bus width. CSRs are area-efficient and gracefully accommodates registers of arbitrary bit-width from both a hardware and software API standpoint, but are lower performance. Thus CSRs are ideal for low-to-medium speed I/O tasks (such as the eponymous configuration and status registers), whereas Wishbone is ideal for memory-mapped I/O where improved bandwidth and latency are worth the area overhead.</p><p>虽然Wishbone是高性能的，但它需要更多的接口逻辑，当外围设备的位宽与总线宽度匹配时，它是最令人满意的。CSR具有面积效率高的特点，从硬件和软件API的角度都能很好地容纳任意位宽的寄存器，但性能较低。因此，CSR非常适合于中低速I/O任务(例如同名配置和状态寄存器)，而Wishbone则非常适合内存映射I/O，在这种I/O中，改进的带宽和延迟值得付出面积开销。</p><p>  From a design process, most peripherals start life mapped to CSR space, and are then upgraded to a memory-mapped implementation to meet performance demands. Thus, it’s no coincidence that most peripherals on Precursor are CSR-only devices. Here is a brief description of each CSR peripheral. As a reminder, you can always consult our  reference manual for more details.</p><p>在设计过程中，大多数外设的生命周期都映射到CSR空间，然后升级到内存映射实施，以满足性能需求。因此，先驱上的大多数外设都是仅支持CSR的设备，这并非巧合。以下是对每个CSR外围设备的简要说明。提醒一下，您可以随时查阅我们的参考手册，了解更多详细信息。</p><p> “COM SPI” is the SPI bus that connects to the Embedded Controller (EC) SoC. It’s a 20MHz SPI peripheral that has a fixed transfer width of 16-bits. This block is targeted for an upgrade to a memory mapped I/O block.</p><p>“COM SPI”是连接到嵌入式控制器(EC)SoC的SPI总线。它是一个20 MHz的SPI外设，具有16位的固定传输宽度。此块的目标是升级到内存映射I/O块。</p><p> “I2C” is an I2C bus controller. Currently, only a real time clock (RTC) chip and an audio CODEC chip are are connected to this I2C bus.</p><p>“I2C”是一个I2C总线控制器。目前，只有实时时钟(RTC)芯片和音频编解码器芯片连接到该I2C总线。</p><p> “BtEvents” is a catch-all block for handling various external real-time interrupt sources. Currently it handles interrupts from the EC and RTC chips.</p><p>“BtEvents”是一个包罗万象的块，用于处理各种外部实时中断源。目前，它处理来自EC和RTC芯片的中断。</p><p> “KeyScan” is the keyboard controller. It’s designed to scan a 9×10 keyboard matrix for key hits, using a slow external 32kHz clock source. By decoupling the keyboard scanner from the system core clock, the system can go to a lower power state while waiting for keyboard presses, extending the number of days that Precursor can go between charges.</p><p>“KeyScan”是键盘控制器。它使用一个32 kHz的慢速外部时钟源，可以扫描9×10键盘矩阵中的按键。通过将键盘扫描器与系统核心时钟分离，系统可以在等待键盘按下时进入较低的功率状态，从而延长了前体两次充电的天数。</p><p> “BtPower” is a set of GPIOs dedicated specifically to managing power. It can turn the audio and discrete TRNG on and off, override the EC’s power control commands, activate boost mode for the USB type C port (allowing operation as a DFP or “host”), and engage the self-destruct mechanism.</p><p>“BtPower”是一组专门用于管理权力的GPIO。它可以打开和关闭音频和离散TRNG，覆盖EC的电源控制命令，激活USB C类端口的升压模式(允许作为DFP或“主机”操作)，并启用自毁机制。</p><p> “JTAG” is a set of GPIOs looped back to the FPGA’s JTAG pins. These are used in combination with our  eFuse API drivers to self-provision AES bitstream encryption fuses on the 7 Series FPGA.</p><p>“JTAG”是一组环回到FPGA的JTAG引脚的GPIO。这些功能与我们的eFuse API驱动程序结合使用，可在7系列FPGA上自行配置AES位流加密熔丝。</p><p> “XADC” is the interface for the 7-Series XADC block, which is a 12-bit, multi-channel ADC. This is primarily used for the self monitoring of system voltages. In the final production revision, at least one channel of the ADC will also be available as a configuration option on the GPIO internal header so that users have an easier path to integrating analog sensors into Precursor.</p><p>“XADC”是7系列XADC模块的接口，它是一个12位、多通道ADC。这主要用于系统电压的自我监控。在最终的生产版本中，还将提供至少一个ADC通道作为GPIO内部接口上的配置选项，以便用户可以更轻松地将模拟传感器集成到前身中。</p><p> “UART” is a simple 115200, 8-N-1 serial interface which is connected to the debug header for console I/O.</p><p>“UART”是一个简单的115200、8-N-1串行接口，它连接到控制台I/O的调试头。</p><p> “BtGpio” is a straight-forward digital I/O block for driving the pins on the GPIO internal header. Note that due to the nature of the FPGA’s implementation, it’s not possible to switch between a digital GPIO function and an analog GPIO function without updating the bitstream.</p><p>“BtGpio”是一个直接的数字I/O块，用于驱动GPIO内部接口上的引脚。请注意，由于FPGA实现的性质，在不更新位流的情况下无法在数字GPIO功能和模拟GPIO功能之间进行切换。</p><p>  In addition to the CSR I/Os, a few I/O devices are memory-mapped for high performance:</p><p>除了CSR I/O外，还对少数I/O设备进行内存映射以实现高性能：</p><p> “External SRAM” is a 32-bit wide, asynchronous interface that memory-maps 16 MiB of external SRAM. The SRAM is battery-backed so that it can retain state while the SoC is powered off. The intention is to optimize power by reducing sleep/wake overhead. However, this also means that the self-destruct procedure must first clear sensitive data from SRAM before activating the final blow that knocks out the SoC, as the self-destruct circuitry is also powered by the SRAM’s backup power supply. The External SRAM block also has a CSR interface to read out the configuration mode of the SRAM.</p><p>“外部SRAM”是一个32位宽的异步接口，内存映射16MiB的外部SRAM。SRAM有电池支持，因此它可以在SoC断电时保持状态。其目的是通过减少睡眠/唤醒开销来优化电源。然而，这也意味着自毁程序必须首先清除SRAM中的敏感数据，然后才能激活击穿SoC的最后一击，因为自毁电路也是由SRAM的备用电源供电的。外部SRAM模块还具有CSR接口，用于读出SRAM的配置模式。</p><p> “Audio” is an I2S interface to an external audio CODEC. In addition to a CSR block that configures the I2S interface, it also includes a pair of 256×16 entry memory-mapped sample FIFOs.</p><p>Audio是外部音频编解码器的I2S接口。除了配置I2S接口的CSR模块外，它还包括一对256×16条目内存映射的样本FIFO。</p><p> “SPI OPI” is a high-speed SPI-like interface to external FLASH storage that memory-maps 12 8MiB of non-volatile storage. The “O” in OPI stands for octal – it’s an 8-bit bus that runs at 100MHz DDR speeds. It also includes a pre-fetcher that can hold several cache line’s worth of code, optimizing the case of straight-line code execution. High performance on this bus is essential, since the intention is for the CPU to run most code as XIP out of FLASH. It also features a CSR interface to control operations like block erase and page programming.</p><p>“SPI OPI”是一个与外部闪存类似的高速SPI接口，其内存映射到128MiB的非易失性存储。OPI中的“O”代表八进制--这是一种运行在100 MHz DDR速度的8位总线。它还包括一个预取器，可以容纳多个缓存线的代码，从而优化了直线代码执行的情况。该总线的高性能至关重要，因为其目的是让CPU以XIP形式运行闪存中的大部分代码。它还具有CSR接口，可控制块擦除和页面编程等操作。</p><p> “MemLCD” is the frame buffer for the LCD. The Sharp Memory LCD contains its own internal memory, which allows it to retain an image even when the host is powered off. The MemLCD frame buffer is thus a cache for the LCD itself. It manages which lines of the LCD are dirty and will flush only the dirty lines to the LCD upon requests made via the CSR. This improves the perceived update rate of the LCD, which is limited to 10 Hz if the entire screen is being updated, but improves inversely proportional to the fraction of the screen that is static.</p><p>“MemLCD”是LCD的帧缓冲器。Sharp Memory LCD拥有自己的内部存储器，即使在主机断电的情况下，它也可以保留图像。因此，MemLCD帧缓冲器是LCD本身的高速缓存。它管理LCD的哪些线是脏的，并在通过CSR发出请求时仅将脏线刷新到LCD。这提高了LCD的感知更新率，如果整个屏幕正在更新，则该速率被限制为10 Hz，但与静态屏幕的比例成反比。</p><p>  All the features described thus far consume about 20% of the FPGA’s logic; the majority of the logic in Precursor’s FPGA is dedicated to the Cryptography Complex.</p><p>到目前为止，所描述的所有功能都消耗了大约20%的FPGA逻辑；Premired公司的FPGA中的大部分逻辑都专门用于加密复合体。</p><p>  Above is an amoeba plot that visualizes the relative size of various functions within the Precursor SoC design. Some blocks, such as the semi-redundant SHA-512 and SHA-2 accelerators, are currently included simply because we could fit both of them in the FPGA, and not because we strictly needed both of them. Fortunately, removing the SHA-2 block is as easy as commenting out  four lines of code, saving about 2800 SLICE LUTs or about 9% of the device’s resources. LiteX and the svd2rust scripts take care of everything else!</p><p>上面是一张变形虫图，显示了前身SoC设计中各种功能的相对大小。一些模块，如半冗余的SHA-512和SHA-2加速器，目前之所以包括在内，只是因为我们可以在FPGA中同时安装这两个模块，而不是因为我们严格需要这两个模块。幸运的是，删除SHA-2块就像注释掉四行代码一样简单，节省了大约2800个片LUT或大约9%的设备资源。Litex和svd2rust脚本负责处理其他所有事情！</p><p>   “Engine25519” is an arithmetic accelerator for operations in the prime field 2^255-19. It’s a microcoded, 256-bit arithmetic engine capable of computing a 256-bit multiply plus normalization in about one microsecond, about a 30x speedup over running the equivalent code on the RISC-V CPU. It consumes a huge amount of resources, but was deemed essential because the Betrusted secure communications application is built around the Double-Ratchet Algorithm, which relies heavily on this type of math. The  CI documentation is probably the best starting point to understand more about the Engine25519 implementation. The block is big enough that later on it will get an entire post dedicated to explaining its function.</p><p>“Engine25519”是素数域2^255-19运算的算术加速器。这是一个微码的256位算术引擎，能够在大约1微秒内计算256位乘法和归一化，比在RISC-V CPU上运行同等代码快约30倍。它消耗了大量的资源，但被认为是必不可少的，因为Betrusted安全通信应用程序是基于双棘轮算法构建的，该算法严重依赖于这种类型的数学计算。CI文档可能是更多地了解Engine25519实现的最佳起点。这个区块足够大，稍后它会有一整篇帖子专门解释它的功能。</p><p> “SHA-512” and “SHA-2” are hardware-accelerated SHA hash blocks. They are derived from  Google’s OpenTitan SystemVerilog source code. The SHA-2 block is directly from OpenTitan and included mostly because it was easy to integrate. The SHA-512 block is our own adaptation of the SHA-2 block. This is the historical reason for why we have both in the current build of Precursor, even though most applications will only need one hash or the other to be hardware accelerated.</p><p>“SHA-512”和“SHA-2”是硬件加速的SHA哈希块。它们源自谷歌的OpenTitan SystemVerilog源代码。SHA-2模块直接来自OpenTitan，主要是因为它易于集成。SHA-512模块是我们自己改编的SHA-2模块。这就是为什么我们在当前的Predicor版本中同时拥有这两个散列的历史原因，尽管大多数应用程序只需要一个散列或另一个散列来进行硬件加速。</p><p> “AES” is an AES accelerator also lifted directly from the Google OpenTitan project. It is capable of doing AES 128, 192, and 256, and supports encryption and decryption in ECB, CBC, and CTR modes.</p><p>“AES”是一个AES加速器，也是直接从Google OpenTitan项目升级而来的。它能够执行AES 128、192和256，并支持ECB、CBC和CTR模式下的加密和解密。</p><p> “KeyROM” is a 256×32 ROM implemented using fixed-location LUTs in the FPGA. Since the ROM’s location is fixed, we can use  PrjXray to determine the location of the KeyROM bits in the FPGA’s bitstream. This allows us to edit the key ROMs directly into the FPGA bitstream, thus enabling a transfer of trust from the low-level eFuse AES key into the higher-level functions of the Precursor SoC. We will discuss more about some important, recently-discovered vulerabilities in the FPGA eFuse AES key in a post coming soon.</p><p>“KeyROM”是一个256×32的ROM，使用FPGA中的固定位置LUT实现。由于ROM的位置是固定的，我们可以使用PrjXray来确定在FPGA的位流中KeyROM位的位置。这允许我们将密钥ROM直接编辑到FPGA位流中，从而将信任从低级eFuse AES密钥转移到前身SoC的高级功能。我们将在即将发布的帖子中更多地讨论最近在FPGA eFuse AES密钥中发现的一些重要漏洞。</p><p> “TRNG” is an on-chip, ring oscillator-based TRNG. It uses multiple small rings to collect entropy which are then merged into a single large ring for final measurement. The construction and validation of Precursor’s TRNGs will also get their own post at some point down the road.</p><p>“TRNG”是一种基于环形振荡器的片内TRNG。它使用多个小环来收集熵，然后将其合并成一个大环进行最终测量。先驱的TRNG的构建和验证也将在未来的某个时候获得自己的职位。</p><p> “ICAPE2” is an explicit tie-down for an unused internal debug port in the FPGA fabric. ICAPE2 is Xilinx’s way of allowing an FPGA to introspect and access internal configuration state. We explicitly tie it down so that no other functions can try to claim it. Also, since the ICAPE2 is at a well-known location in the bitstream, it is possible to write a tool that does post-compilation inspection of the bitstream to verify that the ICAPE2 block is in fact deactivated.</p><p>“ICAPE2”是对FPGA结构中未使用的内部调试端口的显式绑定。ICAPE2是Xilinx允许FPGA自省和访问内部配置状态的方式。我们显式绑定它，这样其他函数就不能尝试声明它。此外，由于ICAPE2位于比特流中的公知位置，因此可以编写一个对比特流执行编译后检查的工具，以验证ICAPE2块实际上已停用。</p><p>  That’s it for our whistle-stop tour of the Precursor SoC! We’ve sculpted in the parts that are essential to functionality and security and hope the development community will add more. By commenting out a few lines of code, you can clear out unnecessary blocks and make space for your own creations. Precursor’s code base is entirely open and available for inspection – no hidden test logic or microcode blobs and no NDA required to trace an unambiguous, cycle-accurate path from the release of reset to the execution of the first instruction. This lack of “dark matter” and total transparency of design adds yet another argument in the evidence-based case to trust Precursor’s hardware with your private matters.</p><p>这就是我们的前身SoC的短暂之旅！我们已经在对功能和安全性至关重要的部分进行了雕琢，并希望开发社区能添加更多。通过注释掉几行代码，您可以清除不必要的代码块，并为您自己的创作腾出空间。Premitive的代码库是完全开放的，可供检查-不需要隐藏的测试逻辑或微码斑点，也不需要NDA来跟踪从RESET释放到执行第一条指令的明确、周期准确的路径。缺乏“暗物质”和设计的完全透明性，这在基于证据的案例中又增加了另一个论点，那就是把你的私事托付给前身的硬件。</p><p> If you enjoyed this post, please check out  Precursor’s campaign page for more details and  project updates!</p><p>如果你喜欢这篇文章，请查看先驱的活动页面，了解更多细节和项目更新！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.bunniestudios.com/blog/?p=5971">https://www.bunniestudios.com/blog/?p=5971</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/soc/">#soc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/chip/">#chip</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033986.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a5998791bfaf6fadf5efcd12881d8f6a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033986.html">噢，我的Bash是一个开源的框架，用于管理您的bash配置</a></div><span class="my_story_list_date">2020-11-9 14:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033773.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c080a81f8785ce41c9fcfedc4efe020b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033773.html">Synerise推出AI Cleora算法作为开源</a></div><span class="my_story_list_date">2020-11-8 9:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033736.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f1b00a0ef76d801911fc499e8a1c0500.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033736.html">谷歌开源免费芯片项目提交将于11月15日上线</a></div><span class="my_story_list_date">2020-11-8 9:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033633.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b57e1b882526da8c9b51e36e42f5842f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033633.html">快速开源入侵检测</a></div><span class="my_story_list_date">2020-11-7 11:19</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>