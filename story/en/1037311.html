<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用于索引的树数据结构的演变：听起来不止于此Evolution of tree data structures for indexing: more than it sounds</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Evolution of tree data structures for indexing: more than it sounds<br/>用于索引的树数据结构的演变：听起来不止于此</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 23:53:50</div><div class="page_narrow text-break page_content"><p>I have to admit, my research blog posts are getting longer and longer. From oneside I find it genuinely encouraging, because if one gets so much informationjust by scratching the topic, imagine what’s hidden beneath the surface! Oneuniversity professor once said “what could be interesting in databases?”, andit turns out freaking a lot! On the other side it certainly poses problems forpotential readers. To overcome them I would suggest an interesting approach:print this blog post out, or open it on your tablet/e-reader, where you canmake notes with a pencil or markers. Now while reading it try to spot ideasparticularly exciting for you and mark them. Along the way there would bedefinitely some obscure parts or questions, write them on the sides as well.You can experiment with the diagrams, changing or extending them, or justdrawing funny faces. But do not read everything at once, have no fear ofputting it aside for a while, and read in chunks that are convenient for you.Some parts could be skipped as the text is build out of relatively independenttopics. The table of contents can help and guide you. Having said that we’reready to embark on the journey.</p><p>我必须承认，我的研究博客帖子越来越长。从一方面来看，我发现这确实令人鼓舞，因为如果只是从头开始就获得大量信息，请想象一下隐藏在表面下的东西！一位大学教授曾经说过：“数据库中可能有什么有趣的东西？”，事实证明吓坏了很多！另一方面，它肯定会给潜在读者带来问题。为了克服它们，我建议一种有趣的方法：打印此博客文章，或在平板电脑/电子阅读器上打开它，在这里您可以用铅笔或记号笔做笔记。现在，在阅读的同时，尝试发现一些特别让您兴奋的想法并加以标记。一路上肯定会出现一些晦涩的部分或问题，也要在侧面写上。您可以尝试使用这些图，更改或扩展它们，或者只是绘制有趣的面孔。但是不要一次阅读所有内容，不要担心将其搁置一会儿，并阅读一些对您方便的块。由于文本是由相对独立的主题构成的，因此可能会跳过某些部分。目录可以帮助和指导您。话虽如此，我们已经准备好踏上旅途。</p><p>   Whenever we speak about indexes, especially in PostgreSQL context, there is alot to talk about: B-tree, Hash, GiST, SP-GiST, GIN, BRIN, RUM. But what if Itell you that even the first item in this list alone hiding astonishing numberof interesting details and years of research? In this blog post I’ll try toprove this statement, and we will be concerned mostly with B-tree as a datastructure.</p><p>   每当我们谈论索引时，尤其是在PostgreSQL上下文中，都有很多要谈论的话题：B树，哈希，GiST，SP-GiST，GIN，BRIN，RUM。但是，如果Itell告诉您，即使仅此列表中的第一项，也隐藏了令人惊讶的大量有趣细节和多年研究成果，该怎么办？在这篇博客中，我将尝试证明这一说法，我们将主要关注B树作为数据结构。</p><p>   B-tree is a self-balancing tree data structure that maintains sorted data andallows searches, sequential access, insertions, and deletions in logarithmictime.</p><p>   B树是一种自平衡树数据结构，用于维护排序的数据，并允许在对数时间进行搜索，顺序访问，插入和删除。</p><p> What is your first association with the concept of B-tree? Mine is “old andwell researched, or in other words boring”. And indeed apparently it was firstintroduced in  1970! Not only that, already in 1979 theywere  ubiquitous. Does it mean there is nothing exciting left anymore? Once upon a time I came across a remarkable read called Modern B-Tree techniques which inspired me to digdeeper into the topic and read bunch of shiny new whitepapers. Afterwardstotally by chance I’ve stumbled upon a book “Database Internals: A Deep Diveinto How Distributed Data Systems Work”, which contains great sections onB-tree design. Both works were the triggers to write this blog post. What was Isaying about nothing exciting left? At the end I couldn’t be more wrong.</p><p> 您与B树的第一个关联是什么？矿山是“古老而精心研究的，换句话说就是无聊的”。实际上，它显然是在1970年首次推出的！不仅如此，它们已经在1979年无处不在。这是否意味着不再有激动人心的事情了？曾几何时，我遇到了一篇非凡的读物，称为《现代B树技术》，这启发了我深入研究该主题并阅读了一堆闪亮的新白皮书。之后，偶然地我偶然发现了一本书“数据库内部知识：深入研究分布式数据系统的工作原理”，其中包含有关B树设计的重要部分。这两本书都是写这篇博客文章的诱因。我说什么都没剩下什么令人兴奋的东西？最后，我再没错。</p><p> It turns out that there are multitude of interesting ideas and techniquesaround B-Trees. They’re all coming from the desire to satisfy different (oftenincompatible) needs, as well as adapt to emerging hardware. To demonstrate howmany of those exist, lets play a game. Below you can find a table of names I’vefound in various science papers, together with a couple of silly names I’vecome up myself. Can you find out the fake ones?</p><p> 事实证明，围绕B树有许多有趣的想法和技术。它们全都来自满足不同（通常兼容）的需求以及适应新兴硬件的渴望。为了演示其中存在的数量，让我们玩一个游戏。您可以在下面找到一张表格，这些表格是我在各种科学论文中找到的名称，以及几个我自己想出来的愚蠢名称。你能找出假的吗？</p><p>   Any ideas? Well, I have a confession to make – all of them are real, I justdon’t have enough imagination to come up with such names. Having this in mindhopefully you understand that if we want to make a survey, the first step wouldbe to establish some classification. Not only this will help us to structurethe material, but also will explain why on earth anyone would need to invent somany variations of what we though was so simple!</p><p>   有任何想法吗？好吧，我有一个表白-他们都是真实的，我只是没有足够的想象力想出这样的名字。考虑到这一点，您将理解，如果我们要进行调查，第一步就是建立一些分类。这不仅将帮助我们构造材料，而且还将解释为什么地球上任何人都需要发明许多我们如此简单的变体！</p><p>  To classify different index access methods we need to think about the followingambitious question – is there anything common between almost any index accessmethod? The authors of  RUM conjecture provide an interestinginsight about this topic:</p><p>  为了对不同的索引访问方法进行分类，我们需要考虑以下雄心勃勃的问题–几乎任何索引访问方法之间是否存在共同点？ RUM猜想的作者对这个主题提供了有趣的见解：</p><p> The fundamental challenges that every researcher, systems architect, ordesigner faces when designing a new access method are how to minimize, i)read times, ii) update cost , and iii) memory (or storage) overhead.</p><p>每个研究人员，系统架构师或设计人员在设计新的访问方法时都面临的基本挑战是如何最大程度地减少以下各项：i）读取时间，ii）更新成本，以及iii）内存（或存储）开销。</p><p> In this paper, we conjecture that when optimizing the read-update-memoryoverheads, optimizing in any two areas negatively impacts the third</p><p> 在本文中，我们推测，当优化读取更新内存开销时，在任何两个区域进行优化都会对第三个区域产生负面影响</p><p> This essentially states that if an index access method could be specified as apoint inside “Read”, “Update” (on the Fig. 1 it’s called “Write” forconvenience of drawing), “Memory” space we can observe an interestinginvariant. Every time we modify one index access method to have less overheadfor reading or memory footprint (i.e. shift the corresponding point closer to“Read”/”Memory” corners), we inevitably loose on the updating workload (i.e.getting further away from “Write” corner).</p><p> 这实质上表明，如果可以在“读取”，“更新”（在图1中将其称为“写入”，以方便绘图），“内存”空间中指定一个索引访问方法，则可以观察到一个有趣的不变性。每次我们修改一种索引访问方法以减少读取或占用内存的开销（即，将相应的点移到“读取” /“内存”的角落更近）时，我们不可避免地会松懈更新工作量（即远离“写入”角）。</p><p>  In fact as a non-scientist I would even speculate that there should be anotherdimension called “Complexity”, but the idea is still clear. I will try to showthis invariant at work via examples in this blog post, but it already gives ussome ground under the feet and opportunity to visually represent differentversions of B-tree by moving point on the triangle back and forth. But firstlet’s recall the basics.</p><p>  实际上，作为一个非科学家，我什至会推测应该有另一个维度称为“复杂性”，但是这个想法仍然很明确。我将尝试通过此博客文章中的示例来展示此不变式，但它已经为脚下提供了有用的基础，并提供了通过在三角形上来回移动点来直观表示B树的不同版本的机会。但是，Firstlet回忆起了基础知识。</p><p>  So what is B-tree? Well, it’s a tree data structure: a root node, some numberof branch nodes (marked grey) and a bunch of leaf nodes (marked green):</p><p>  那么什么是B树？嗯，这是一个树数据结构：一个根节点，一些分支节点（标记为灰色）和一堆叶子节点（标记为绿色）：</p><p>  Every node of this tree is usually a page of some certain size and containskeys (shaded slices of a node) and pointers to other nodes (empty slices witharrows). Keys on page are kept in sorted order to facilitate fast search withina page.</p><p>  该树的每个节点通常是一定大小的页面，并包含键（节点的阴影切片）和指向其他节点的指针（带箭头的空切片）。页面上的键按排序顺序保留，以便于快速搜索页面。</p><p> The original B-tree design assumed to have user data in all nodes,branch and leaf. But nowadays the standard approach is a variation calledB +-tree, where user data is present only in leaf nodes and branchnodes contains separator keys (pivot tuples in PostgreSQL terminology). In thisway separation between branch and leave nodes become more strict, allowingbetter flexibility for choosing format of former and making deletion operationscan affect only latter. In fact the original B-tree design is barely worthmentioning these days and I’m doing this just to be precise. SinceB +-tree is sort of default design, we’ll use B-tree andB +-tree interchangeably in this text from now on. An interestingthing to mention here is that the only requirements for separator keys is toguide search algorithm to a correct leaf node. As long as they fulfil thiscondition they can contain anything, no other requirements exist.</p><p> 原始的B树设计假定在所有节点（分支和叶子）中都有用户数据。但是如今，标准方法是一种称为B + -tree的变体，其中用户数据仅存在于叶节点中，而分支节点包含分隔符（PostgreSQL术语中的枢轴元组）。这样，分支和离开节点之间的分离变得更加严格，从而为选择前者的格式和进行删除操作提供了更好的灵活性，从而仅影响后者。实际上，这些天来原始的B树设计几乎不值得一提，而我正在做的就是这样。由于B +树是默认设计，因此从现在开始我们将在本文中交替使用B树和B +树。这里要提到的一个有趣的事情是，对分隔符的唯一要求是将搜索算法引导到正确的叶节点。只要它们满足此条件，它们就可以包含任何东西，不存在其他要求。</p><p> Strictly speaking, only child pointers are truly necessary in this design, butquite often databases also maintain additional neighbour pointers, e.g. what youcan see on the Fig. 2 between the leaf nodes. It could be helpful for someoperations like index scan, but need to be taken into account for nodesplit/merge operations. PostgreSQL uses  Lehman-Yao version,called B link-tree, with links to both left and right sibling nodes(the left link one is actually not presented in the originalB link-tree design, and it makes backward scan somewhat interesting),and there are even implementations like WiredTiger with parent pointers.</p><p>严格来说，在此设计中仅真正需要子指针，但是很多时候数据库还维护其他的邻居指针，例如：您可以在图2中叶节点之间看到。对于某些操作（例如索引扫描）可能会有所帮助，但是节点拆分/合并操作需要考虑在内。 PostgreSQL使用雷曼-姚（Lehman-Yao）版本，称为B链接树，同时具有到左右同级节点的链接（在原始B链接树设计中实际上没有显示左链接，这使得向后扫描有点有趣），并且在那里甚至是带有父指针的WiredTiger之类的实现。</p><p> Having all this in place one can perform a search query by following the pathmarked red on the Fig. 2, first hitting the root, finding a proper separatorkey, following a downlink and landing on a correct page where we deploy binarysearch to find the resulting key.</p><p> 将所有这些都放在适当的位置，就可以执行搜索查询，方法是遵循图2上标记为红色的路径，首先击中根节点，找到合适的分隔符，然后沿着下行链路连接并到达正确的页面，在该页面上我们部署Binarysearch以查找结果键。</p><p> Until now, we were talking only about static parts of B-tree design, but ofcourse there is more to it. For example there is one dynamic aspect of muchimportance (quite often it even scares developers like a nightmare), namelypage splits. What do we need to do when there is a new value to insert, but thetarget page does not have enough space like on the following diagram?</p><p> 到目前为止，我们仅谈论B树设计的静态部分，但是当然还有更多内容。例如，有一个非常重要的动态方面（很多时候它甚至像噩梦一样使开发人员感到恐惧），即页面拆分。当要插入新值但目标页面没有足够的空间时，如下图所示，我们该怎么办？</p><p>  What happens here is we’re trying to insert the new value (shaded box) into thepage with not enough space for it. To maintain the three balanced we need toallocate another leaf page, distribute keys between old and new leaf, promote anew separator key into the parent page and update all required links(left/right siblings if present):</p><p>  此处发生的是，我们正在尝试将新值（阴影框）插入页面，而没有足够的空间。为了保持这三个平衡，我们需要分配另一个叶子页，在旧叶子和新叶子之间分配密钥，在父页面中升级一个新的分隔符，并更新所有必需的链接（如果存在，则为left / right兄弟姐妹）：</p><p>  Curiously enough the new separator key could be chosen freely, it could be anyvalue as long as it separates both pages. We can see what does it change in theoptimization section.</p><p>  奇怪的是，可以自由选择新的分隔键，只要分隔两个页面，它就可以是任何值。我们可以在优化部分看到它的变化。</p><p> Locking is obviously an important part of a page split. No one wants to end upwith concurrency issues when pages get updated while in the middle of a split,so a page to be split is write-locked as well as e.g. right sibling to updateleft-link if present.</p><p> 锁定显然是页面拆分的重要部分。没有人希望在拆分过程中更新页面时遇到并发问题，因此要拆分的页面被写锁定，例如如果存在，则向右兄弟更新updateleft-link。</p><p> As you can see, page splits are introducing performance overhead. We need tobring in a new page, move elements around and everything should be consistentand correctly locked. And already at this pretty much basic point we alreadycan see some interesting trade-offs. For example B*-tree modification tries torebalance data between neighbouring nodes to postpone page split as long aspossible. In terms of trade-offs it looks like a balance between complexity andinsert overhead.</p><p> 如您所见，页面拆分带来了性能开销。我们需要进入一个新页面，四处移动元素，所有内容都应保持一致并正确锁定。在这个非常基本的点上，我们已经可以看到一些有趣的权衡。例如，B * -tree修改尝试在相邻节点之间重新平衡数据，以尽可能长时间地推迟页面拆分。在权衡方面，它看起来像是复杂性和插入开销之间的平衡。</p><p> I didn’t tell you everything about B link-tree and it’s going to be our nexttopic example in this section. Not only Lehman-Yao version adds a link to theneighbour, it also introduces a “high key” to each page, which is an upper boundon the keys that are allowed on page. While obviously introducing a bit memoryoverhead those two changes make it possible to detect a concurrent page splitby checking the page high key, which allows the tree to be searched withoutholding any read locks (except to keep a single page from being modified whilereading it)  [6]. We can think of it as a balance between memoryfootprint and insert overhead.</p><p>我没有告诉您有关B链接树的所有信息，这将是本节中的下一个主题示例。雷曼-姚（Lehman-Yao）版本不仅添加了到邻居的链接，而且还在每个页面上引入了“高键”，这是页面上允许使用的键的上限。虽然显然会引入一点内存开销，但是这两个更改使得可以通过检查页面高键来检测并发页面拆分，这使得无需保留任何读取锁即可进行搜索树（除了防止在读取单个页面时对其进行修改）[6 ]。我们可以将其视为内存占用和插入开销之间的平衡。</p><p> We’ve spent so much time talking about page splits and their importance. For thesake of symmetry one can expect the same from page merges, but surprisinglyit’s usually not the case. There is even the  paper thatstates:</p><p> 我们花了很多时间讨论页面拆分及其重要性。为了保持对称，可以从页面合并中获得相同的效果，但令人惊讶的是通常情况并非如此。甚至有论文指出：</p><p> By adding periodic rebuilding of the tree, we obtain a data structure that istheoreticaly superior to standard B-trees in many ways. Our results suggestthat rebalancing on deletion no only unnecessary but may be harmful.</p><p> 通过添加树的定期重建，我们可以在许多方面获得理论上优于标准B树的数据结构。我们的结果表明，在删除上进行重新平衡不仅不必要，而且可能有害。</p><p> But of course vacuum in PostgreSQL can still reclaim empty pages (see “PageDeletion” in  [6]).</p><p> 但是，当然，PostgreSQL中的真空仍然可以回收空页面（请参见[6]中的“ PageDeletion”）。</p><p> Now just to get taste of a real B-tree let’s generate an index in PostgreSQLand visualize it. The easiest way would be probably to create a small data setwith pgbench and then plot the resulting graph of B-tree nodes and connectionsusing a script from  pg_query_internals, you can see theresult on Fig. 4:</p><p> 现在只是为了品尝真实的B树，我们在PostgreSQL中生成一个索引并将其可视化。最简单的方法可能是使用pgbench创建一个小的数据集，然后使用pg_query_internals中的脚本绘制B树节点和连接的结果图，结果如图4所示：</p><p>   Are you confused, what is this bumpy line? Well, it’s my attempt to fit thevisualization into the screen, because in reality B-trees are extremely wide.Now let’s play a bit and modify the visualization script to show every node asa small dot and use “neato” layout for graphviz:</p><p>   您感到困惑，这条坎bump线是什么？好吧，这是我尝试使可视化效果适合屏幕的原因，因为实际上B树非常宽。现在，让我们玩点儿，修改可视化效果脚本，将每个节点显示为一个小点，并对graphviz使用“ neato”布局：</p><p>  Fig 5. demonstrates nicely another observation about B-trees, they’re indeedextremely wide, short and even sort of bushy. And the very same picture canalso help us to understand another important aspect of B-tree that makes itindeed ubiquitous in database systems. The reason is that with B-tree one canaddress many kinds of workloads with reasonable efficiency, it’s not designedwith only one target in mind. How is that possible? It’s thoroughly explainedin “Modern B-tree techniques”, particularly in “B-tree versus Hash Indexes”section, so I’ll just formulate the summary.</p><p>  图5很好地展示了B树的另一种观察结果，它们确实非常宽，短，甚至丛生。同样的情况也可以帮助我们理解B树的另一个重要方面，使其在数据库系统中无处不在。原因是，使用B树，可以以合理的效率处理多种工作负载，而在设计时就不会只考虑一个目标。那怎么可能？在“现代B树技术”中，尤其是在“ B树与哈希索引”部分中已对此进行了详细说明，因此，我将仅对摘要进行表述。</p><p> For one, B-tree can effectively exploit memory hierarchy, because as you cansee it’s extremely wide, and if an index is “warm” it means most likely allbranches nodes will be present in the buffer pool or could be fetched into thebuffer pool while preparing the query. For leaf pages an efficient evictionpolicy could be deployed as well to address non-uniform workload. In generalspace management in B-tree is rather straightforward and an index can grow orshrink smoothly, whereas graceful grow or shrinking e.g. hash indexes is notfully solved yet.</p><p>首先，B树可以有效地利用内存层次结构，因为您可以看到它非常宽，并且如果索引为“ warm”，则意味着最有可能的所有分支节点都将出现在缓冲池中，或者在准备时可以被提取到缓冲池中查询。对于叶子页，也可以部署有效的驱逐策略，以解决不均匀的工作负载。在一般情况下，B树中的空间管理非常简单，索引可以平滑增长或收缩，而优雅增长或收缩例如哈希索引尚未得到解决。</p><p> Another property of B-tree that helps to address different workloads is itsability to support different form of queries (search with a prefix of the indexkey, or index skip scan) using only one index.</p><p> B树的另一个有助于解决不同工作负载的属性是仅使用一个索引即可支持不同形式的查询（使用索引键前缀的搜索或索引跳过扫描）的能力。</p><p> Last but not least is B-tree flexibility in terms of optimizations. One couldcompose different optimizations at different levels to be able to address someparticular type of workloads mostly without negatively affecting performance inother cases.</p><p> 最后但并非最不重要的一点是B树在优化方面的灵活性。一个人可以在不同级别上进行不同的优化，以便能够在大多数情况下解决特定类型的工作负载而不会对性能产生负面影响。</p><p> Having said all that we can also pinpoint where in the RUM space we can placeB-tree. Since it’s pretty good in read workload, but could be better withmemory footprint and insert workload, we can put it somewhere here:</p><p> 说完所有这些，我们还可以查明在RUM空间中可以放置B树的位置。由于它在读取工作负载方面相当不错，但在内存占用和插入工作负载方面可能会更好，因此我们可以将其放在此处：</p><p>   As we already mentioned, one of the reasons why B-trees are so universal in thedatabases world is their flexibility and extensibility. On can apply variety ofdifferent local optimizations which could be nicely composed withoutsacrificing on something else. Let’s take a loot at some of them.</p><p>   正如我们已经提到的，B树在数据库领域如此普遍的原因之一是它们的灵活性和可扩展性。 On可以应用各种不同的局部优化，这些局部优化可以很好地组合而无需牺牲其他内容。让我们来看看其中一些。</p><p>  Probably the simplest we can do is key normalization, which is apparently aquite old technique  [3]. The idea is pretty simple,if there is an index record with several keys for every column we transformthem into a binary string like on Fig. 7:</p><p>  可能最简单的方法是密钥规范化，这显然是古老的技术[3]。这个想法很简单，如果有一个索引记录，每一列都有几个键，我们将它们转换成如图7所示的二进制字符串：</p><p>  This allows to use simple binary comparison to sort the records during indexcreation or when guiding a search to the correct record. Such an encoded valueneed to take care about nulls and collations and can even include sortdirection. But as always there are pros and cons and in this particular casethe trick is that generally speaking it is impossible to reclaim the originaldata. In certain situations it can even happen that two different valuesproduce the same normalized key (e.g. for languages with lower/upper casesorted case-insensitive). This means that we either:</p><p>  这允许在索引创建期间或在引导搜索到正确的记录时使用简单的二进制比较对记录进行排序。这样的编码值需要注意空值和归类，甚至可以包括排序方向。但是一如既往地有利弊，在这种特殊情况下，窍门是，一般而言，不可能收回原始数据。在某些情况下，甚至可能会发生两个不同的值生成相同的规范化键的情况（例如，对于大小写区分大小写的大小写不区分大小写的语言）。这意味着我们要么：</p><p> need to keep both original data and normalized key or somehow else makesure precise recovery is possible.</p><p>需要同时保留原始数据和规范化密钥，或者以其他方式确保精确恢复是可能的。</p><p> By itself this modification looks pretty innocent, but in fact it enables us toimplement more optimizations on top of it.</p><p> 就其本身而言，这种修改看起来是无害的，但实际上，它使我们能够在其之上实现更多优化。</p><p>  One of such optimizations, which could be much easier implemented with the helpof normalized keys is prefix truncation. And you will be surprised howstraightforward it is. Imagine we have the following keys on one page:</p><p>  借助前缀密钥截断可以更容易地实现此类优化之一。您会惊奇地发现它是如此直接。假设我们在一页上有以下键：</p><p>  Note that the value we store start with the same prefix, which is sort of dataduplication. If we’re going to do a bit of bookkeeping, it’s possible to storethis prefix only once and truncate it from all the keys.</p><p>  请注意，我们存储的值以相同的前缀开头，这是一种重复数据。如果我们要进行一些簿记，则可以仅将此前缀存储一次，然后从所有键中截断该前缀。</p><p>  As you can imagine this optimization is about trade-off between consuming lessspace on leave pages, but doing more job at run-time. To reduce code complexityand run-time overhead, usually prefix truncation is done over the wholepossible key range based on fence keys (those are copies of separator keysposted to the parent during split), although more fine-grained approach can givebetter compression ratio (and more headache for insert operation).</p><p>  可以想象，这种优化是在消耗较少的休假页面空间与在运行时完成更多工作之间进行权衡。为了减少代码复杂性和运行时开销，尽管更细粒度的方法可以提供更好的压缩率（以及更多），但通常通常根据围栏键（在隔离期间将隔离键的副本发布到父级）在整个可能的键范围内进行前缀截断。插入操作时头痛）。</p><p>   Even if prefix truncation is not implemented directly and B-tree pages formatis not changed, dynamic prefix truncation could be used to reduce comparisoncosts based on the knowledge about shared prefix and fence keys. Following thediagram on Fig. 9, if we want to add a new key (an outstanding item) and fencekeys on a page have common prefix (marked as red parts), it means all the keyshave it and could be omitted from comparison (leaving us with only blue part todeal with):</p><p>   即使没有直接实现前缀截断并且不更改B树页面格式，也可以基于有关共享前缀和篱笆密钥的知识，使用动态前缀截断来减少比较成本。按照图9的示意图，如果我们要添加一个新键（一个出色的项目），并且页面上的fencekey具有共同的前缀（标记为红色部分），则意味着所有的键都已被剃除，因此可以从比较中省略（留给我们）仅对蓝色部分进行折磨）：</p><p>  You may also know this approach under  common prefix skippingname in the context of sorting algorithms. Unfortunately terminologyinconsistencies happen relatively often as you can notice throughout the wholeblog post (another interesting example is B*-tree, which called“most misused term in B-tree literature” in  Ubiquitous B-tree).</p><p>  您可能还会在排序算法的上下文中以通用前缀skippingname知道这种方法。不幸的是，术语不一致现象相对频繁发生，因为您可以在整篇博客文章中注意到（另一个有趣的例子是B * -tree，在普遍的B-tree中被称为“ B-tree文学中最被滥用的术语”）。</p><p>  Despite the similar name, suffix truncation is a bit different beast. Thistrick could be applied to separator keys on branch pages and the easiest way toexplain it is to show the diagram. Let’s say we have a page to split:</p><p>尽管名称相似，但后缀截断还是有些不同。此技巧可以应用于分支页上的分隔键，最简单的解释方法是显示该图。假设我们有一个要拆分的页面：</p><p>  In case if this page would be split right in the middle, we end up with the key“Miller Mary”, and to fully distinguish splitted parts the minimal separationkey should be “Miller M”. But as I’ve mentioned above we can actually chooseany available separation key as long as it separates both pages, so why nottake something shorter like in the following example?</p><p>  如果此页面在中间被分割，我们将以键“ Miller Mary”结尾，并且为了完全区分分割的部分，最小的分隔键应为“ Miller M”。但是，如上所述，我们实际上可以选择任何可用的分隔键，只要它可以分隔两个页面，那么为什么不像下面的示例那样使用较短的分隔键呢？</p><p>  That is pretty much the whole idea, to pick up a split point in a such way thatthe resulting separation key will be minimal.</p><p>  这几乎就是整个想法，以这样一种方式来获取分割点，使得最终的分离键将最小。</p><p> Worth mentioning that starting from version 12 PostgreSQL does whole-columsuffix truncation without actually implementing key normalization. There iseven a good overview of all these techniques in the corresponding wiki page.</p><p> 值得一提的是，从版本12开始，PostgreSQL会进行整列后缀截断而不实际实现密钥规范化。相应的Wiki页面上对所有这些技术都有很好的概述。</p><p>  Normally we have to deal with values of variable length, and the regularapproach to handle them is to have an indirection vector on every page withpointers to actual values. In PostgreSQL terminology those pointers are calledline pointers. Every time when we have a key to compare, we first follow apointer and fetch the value it points to. But what if we extend this design abit and equip every such pointer with some useful information, for example afirst few bytes of the normalized key we’re going to find after following thepointer, as with the diagram on Fig. 12 (e.g. first characters a,b,c,d)?</p><p>  通常，我们必须处理可变长度的值，处理它们的常规方法是在每个页面上都有一个间接指向向量，并带有指向实际值的指针。在PostgreSQL术语中，那些指针称为行指针。每当我们有一个要比较的键时，我们首先跟随一个指针并获取它指向的值。但是，如果我们扩大该设计范围并为每个此类指针配备一些有用的信息，例如在跟随指针之后将要找到的标准化密钥的前几个字节，如图12所示，该怎么办（例如，第一个字符a ，b，c，d）？</p><p>  Such a small change allow us to figure out if the value we’re looking for couldbe not found following this pointer since the first few bytes are alreadydifferent. This makes the design more CPU cache friendly, as the indirectionvector is usually small enough to fit into the cache. For more details take alook at  [9].</p><p>  如此小的更改使我们能够确定在此指针之后是否找不到所需的值，因为前几个字节已经不同。这使设计对CPU缓存更友好，因为间接向量通常足够小以适合缓存。有关更多详细信息，请参见[9]。</p><p> Another interesting approach I find somehow similar is overflow pages, whenonly a fixed number of payload bytes is actually stored in the page directlyand the rest goes to the overflow page. Few examples are MySQL InnoDB and  SQLite.</p><p> 我发现另一种有趣的方法是溢出页，当页中实际上只直接存储了一定数量的有效载荷字节，其余部分直接进入溢出页时。很少有MySQL InnoDB和SQLite的例子。</p><p>  Page splits are a big deal in B-tree design, and obviously interestingvariations could be found in the wild about how to deal withthem.  SB-tree is one such example, where to improve page splitefficiency disk space is allocated in large contiguous extents of many pages.This leaves free pages in each extent and whenever a node needs to be split,another node is “allocated” within the same extent from already preallocatedspace, like in the following diagram on Fig. 13:</p><p>页面拆分在B树设计中很重要，显然可以在野外找到如何处理它们的有趣变化。 SB树就是这样一个示例，其中为提高页面拆分效率而在许多页面的较大连续范围内分配了磁盘空间。这在每个范围内都留下了空闲页面，并且每当需要拆分一个节点时，都会在同一节点内“分配”另一个节点。从已经预分配的空间开始扩展，如图13中的下图所示：</p><p>  Of course, it means that an extent itself could reach the point when there is nomore free space and it needs to be split following the same ideas as normalpage split. You maybe surprised what SB-tree is doing here, in basics section,since it’s not a standard approach. Yes, it’s not basic, but I’ve decided tomention it here anyway mostly due to its almost intuitive idea.</p><p>  当然，这意味着扩展区本身可以达到没有可用空间的程度，因此需要按照与正常页面拆分相同的思路进行拆分。您可能会对SB-tree在此处的“基本操作”感到惊讶，因为这不是标准方法。是的，这不是基本知识，但我还是决定在此提起它，主要是因为它几乎是直觉的。</p><p>  Indeed, everything looks great, why do we need to come up with some otherdesigns? Well, as you can remember on the RUM space we put B-tree closer to the“Read” corner and not without the reason. There are several common downsides ofB-tree design:</p><p>  确实，一切看起来都很不错，为什么我们需要提出其他一些设计？嗯，您可以在RUM空间中记住B树，使其更靠近“读取”角，并非没有原因。 B树设计有几个常见的缺点：</p><p> It’s not particularly CPU cache friendly due to pointer-chase, since toperform an operation we need to follow many pointers.</p><p> 由于采用了指针追踪，因此对CPU缓存的友好程度不是特别高，因为要执行一项操作，我们需要遵循许多指针。</p><p> Memory footprint and insert performance are located on different sides ofbalance, we can improve inserts by preallocating pages and keep track of freespace on the page which requires more memory. The same is valid for datacompression.</p><p> 内存占用量和插入性能位于平衡的不同方面，我们可以通过预分配页面来改进插入，并跟踪需要更多内存的页面上的可用空间。这对于数据压缩同样有效。</p><p> B-tree requires lock coupling on page level to synchronize an access, whichdoesn’t scale that well on many-core CPUs or in-memory systems (see [10],  [11]).</p><p> B树需要页面级的锁耦合来同步访问，这在多核CPU或内存系统中无法很好地扩展（请参见[10]，[11]）。</p><p> Bulk inserts is also not particularly efficient out of the box, and ingeneral index maintenance could be pretty tricky (my favorite description ofthis part is paper  “Waves of Misery After Index Creation”).</p><p> 批量插入也不是特别有效，开箱即用的索引维护可能非常棘手（我最喜欢的部分描述是论文“索引创建后的痛苦之波”）。</p><p> At the same time there are some alternative data structures that providesimilar functionality but different set of trade-offs. All this makes the topicpretty dynamic and full of interesting ideas. I’ll try to describe some ofthose designs I find interesting in the following sections. Keep your eyesopened, you will probably notice many common patterns.</p><p>同时，有些替代数据结构提供相似的功能，但权衡取舍不同。所有这些使主题变得非常动态，并且充满了有趣的想法。在以下各节中，我将尝试描述一些我认为有趣的设计。睁大眼睛，您可能会注意到许多常见的模式。</p><p>  If SB-tree could be called intuitive, partitioned B-tree idea sounds ratherconfusing at first. Essentially the suggestion is to maintain partitions withina single B-tree via adding an artificial leading key field (see [14]). Those partitions are nothing but temporary,and after some time will be merged together in background so that in the normalstate there is only one partition. Why on earth would we add</p><p>  如果可以将SB树称为直观树，那么分区B树的想法一开始听起来很混乱。本质上，建议是通过添加人工的前导关键字段来维护具有单个B树的分区（请参见[14]）。这些分区不过是临时分区，一段时间后将在后台合并在一起，因此在正常状态下只有一个分区。我们到底为什么要添加</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/索引/">#索引</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tree/">#tree</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/页面/">#页面</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>