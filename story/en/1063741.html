<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从朱莉娅到生锈 From Julia to Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">From Julia to Rust<br/>从朱莉娅到生锈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 06:52:07</div><div class="page_narrow text-break page_content"><p>I&#39;ve been more serious about learning Rust recently, after dragging on with passive learning for a while. My first real programming language was Julia, and I know other Julians interested in Rust. I&#39;ve written this article for those people in mind, because Rust and Julia are good performance sparring partners, but Rust has a different mindset and tradeoffs that are worth considering.</p><p>在用被动学习持续一段时间后，我最近一直非常认真地学习生锈。我的第一个真正的编程语言是朱莉娅，我知道其他对生锈感兴趣的朱利安。我为那些人写了这篇文章，因为生锈和朱莉娅是良好的表演伙伴，但Rust有一个不同的思想和权衡，值得考虑。</p><p>        There are 3 talks that sold me on Rust being worth learning, the first is  by Carol Nichols and the  second is a lecture by Ryan Eberhardt and Armin Nanavari. The first talks about how about ~70% of all bugs from the big tech corporations are from memory safety and that trains used to not have emergency brakes. The second explains how sytems programming codebases already impose the invariants of resource ownership on the coders - but that reasoning can be horribly error prone, tedious, and automated.</p><p>        有3个谈判可以卖掉我的生锈值得学习，第一个是Carol Nichols，第二个是Ryan Eberhardt和Armin Nanavari的讲座。第一次谈论大科技公司的所有错误达到约70％来自内存安全，曾经没有紧急刹车的火车。第二次解释了系统编程码条的编程如何对编码器中的资源所有权的不变性产生了普及，但推理可能会易于错误，繁琐和自动化。</p><p>  That&#39;s the point of technology! To not have to worry about the previous generations problems because we figured out a way to offload that thinking to a machine.</p><p>  那个＆＃39;它的技术点！不必担心以前的几代问题，因为我们发现了一种卸载到机器的方法。</p><p>  The third talk that really sold me on Rust was  Alex Gaynor&#39;s. It&#39;s bad enough that a bank or a school web site could crash because of memory bugs, but once you take into account the fact that not even the best programmers in the world (sorted by salaries, roughly) can ship safe code, you start to despair a little. Then you hear about the incredibly battle-tested libraries like  sudo  and, as the moral argument goes, you are likely going to put vulnerable people in harm&#39;s way if you keep shipping a broken tool. I buy the urgency of that argument more and more when journalists or human rights advocates get targeted by state actors due to a trivial (but buried) C mistake.</p><p>  真正卖掉我的第三个谈话是亚历克斯gaynor＆＃39; s。它＆＃39是足够的，银行或学校网站可能因内存错误而崩溃，但一旦你考虑到世界上最好的程序员（由工资排序，大致排序）可以发货安全代码，你开始绝望一点。然后你听到了像sudo这样的令人难以置信的战斗库，并且随着道德争论的方式，你可能会把脆弱的人放在伤害中，如果你继续运送一个破碎的工具，那就会伤害伤害。我越来越多地购买该论证的紧迫性，当事员或人权倡导者由于琐碎的（但埋葬）C错误而受到国家行为者的目标。</p><p>  So that&#39;s the spiel for jumping on the Rust train when I argue with myself in the shower. What&#39;s the Rust&#39;s philosophy?</p><p>  所以当我在淋浴时争论生锈火车时，它的斯基辛赛跳跃。什么＆＃39;生锈＆＃39;哲学？</p><p>        You might know Julia&#39;s origin story - there were a gajillion DSLs for scientific computing, BLAS is a mess but implements polymorphism through namespacing for performance needs, and other libraries re-implemented a poor man&#39;s version of multiple dispatch because of the performance constraints. If you add a clever JIT to multiple dispatch capabilites, you can get ~C performance with ease if types can be inferred, and fortunately you can build a general programming language around that paradigm and those trade offs. Eventually, they baptized the language to honor the one true queen of  algorithms.</p><p>        您可能知道朱莉娅＆＃39;苏格兰的故事 - 有一个gajiltion的科学数据库，Blas是一团糟，但通过命名为绩效需求来实现多态性，而其他图书馆重新实施过贫穷的人和第39族版本因为性能约束。如果将聪明的JIT添加到多个调度CapabiLites，则可以轻松获取〜C性能，如果可以推断出类型，幸运的是，您可以在该范例和这些权衡中建立一般的编程语言。最终，他们向语言施洗了语言，以纪念算法的一个真正的女王。</p><p>  Rust comes from a different place: Some years ago in Mozilla, Graydon Hoare and the team got fed up with systems programming and the C/C++ tool chain. They were working on a language that allowed for programmers to be productive in low-level systems, harness concurrency performance without the foot-bazookas, and avoid errors during run time. At first they had different systems for handling the previous problems, until the team pieced together that an ownership system, with a borrow checker at compile time, could kill 2 birds with one stone. Eventually, they named the language after the  fungus.</p><p>  Rust来自不同的地方：几年前，在Mozilla，Graydon Honare和团队厌倦了系统编程和C / C ++工具链。他们正在研究一种语言，允许程序员在低级系统中富有成效，没有足迹的情况下停用并发性能，并在运行时避免错误。起初，他们有不同的系统来处理以前的问题，直到团队拼凑在一起的所有权系统，在编译时借用检查员，可以用一块石头杀死2只鸟。最终，他们在真菌后命名的语言。 </p><p>  Recap: Julians were sick of unreusable code, niche DSLs and hacky polymorphism. With multiple dispatch as the central design feature they solved those problems. Rustaceans were sick of the C/C++ minefields and trying to keep all the invariants of large, error-prone codebases in their head. The idea of ownership and a borrow checker to know those errors  at compile time and be data-race free is what&#39;s got them to where they are now.</p><p>RECAP：朱莉安患了不可用的代码，利基DSL和贺卡多态性。随着中央设计的多次调度，他们解决了这些问题。 Riraceans厌倦了C / C ++雷区，并试图在他们的头脑中保留大型错误易于码码的所有不变性。所有权的概念和借书检查者知道在编译时的错误，并且是数据种类的错误是什么＆＃39;让他们到现在的位置。</p><p>  There&#39;s obviously important details missing on both stories - you can get it from proper historians if you like, this is a brief and informal introduction. I will however, mention the other big Rustian idea of affine types when I talk about how they get a version of generic code we&#39;ve come to know and love in Julia land. Spoiler alert: you can get generic code if you pay the price of a Julia runtime, and that&#39;s not something Rustaceans want. If you want generics at compile time, you have to &#34;prove&#34; to the compiler that your types are constrained to some extent, and you relay that information by tacking on affine types to your code.</p><p>  两层故事中缺少的重要细节显然有明显的细节 - 如果您愿意，您可以从适当的历史学家那里得到它，这是一个简短而非正式的介绍。然而，当我谈论他们如何获得一版本的通用代码时，我会提到另一个大型Ristian类型的仿射类型＆＃39;在朱莉娅的土地上来了解和爱。 SPOILER ALERT：如果您支付Julia运行时的价格，则可以获得通用代码，而且＆＃39;不是鲁西瓦斯的东西。如果您希望在编译时泛型，则必须＆＃34;证明＆＃34;对于编译器，您的类型在某种程度上受到约束，并且您通过在代码上进行仿射类型来传递该信息。</p><p>          If for some reason you&#39;ve already decided that learning Rust is a worthy endeavour, here&#39;s my list of resources to learn. I think they are a good resource to follow in approximate order, but use whatever works, and if it doesn&#39;t, skip it.</p><p>          如果出于某种原因，你已经决定学习生锈是一个值得的努力，这里我的资源列表。我认为他们是近似顺序遵循的好资源，但使用任何作用，如果它没有，跳过它。</p><p>  The Rust book: Click the link to get started with installation and IDE setup. It pays to read it at least once cover to cover and not fret about coming back to the thorny bits.</p><p>  生锈书：单击链接以启动安装和IDE设置。只需一旦盖子覆盖即可覆盖即可覆盖即可才能回到棘手的比特。</p><p>  VSCode Error Lens and  Rustanalyzer: The quicker the feedback loop you get from the compiler, the sooner you can spot mistakes and keep going. These aren&#39;t mandatory but it&#39;s the easiest way to make the feedback loop faster.</p><p>  vscode错误镜头和rustAnalyzer：从编译器中获得的反馈循环更快，您越早可以发现错误并继续前进。这些aren＆＃39; t强制性但它＆＃39; s更快地制作反馈循环的最简单方法。</p><p>  Rust docs: Their version of the Julia manual. Make sure to click the  [+] to see how the code drops down. I still spend time looking at the iterators page.</p><p>  Rust Docs：他们的Julia手册版本。确保单击[+]以查看代码如何下降。我仍然花时间看迭代器页面。</p><p>  Exercism: If you want to get into some guided learning, Exercisms is great, but focuses too much on strings at the beginning for my liking. Make sure to look at the community solutions when you&#39;re done.</p><p>  行业主义：如果你想进入一些导游的学习，运动就是很棒的，但在开始时，专注于弦乐的弦乐。当你完成时，请务必查看社区解决方案。 </p><p>  Advent of Code 2020 by Amos: This was my first &#34;get your hands dirty&#34; with Rust experience. Other articles by Amos are great and friendly too, but this series was useful for figuring out a Rustian workflow and design thinking.</p><p>代码2020由AMOS出发：这是我的第一个＆＃34;让你的手脏＆＃34;经验丰富。 AMOS的其他文章也非常友好，但该系列对于弄清楚探索的工作流程和设计思维是有用的。</p><p>  Ryan Eberhardt Stanford course: University course that gets you up and running with systems programming constraints and problem solving. I&#39;m not its target audience but it was great for understanding Rust&#39;s domain.</p><p>  Ryan Eberhardt Stanford课程：大学课程让您启动和运行系统编程约束和解决问题。我不是它的目标受众，但它非常适合理解生锈＆＃39; s域。</p><p>  Jeff Zarnett programming for performance course repo, with a  full youtube playlist: Another good course for stepping in directly into high performance computing - not done with it yet, but the professor is friendly and enthusiastic.</p><p>  Jeff Zarnett为绩效课程编程进行编程，拥有一个完整的YouTube播放列表：另一个良好的课程，用于直接进入高性能计算 - 还没有完成它，但教授是友好和热情的。</p><p>  Rustlings: I found some exercises too hard the first time I picked up the Rust book. Your Mileage May Vary but I did them solo and suffered. I would recommend pairing up with a buddy before attempting all of it.</p><p>  rustlings：我发现一些练习太难了我第一次拿起铁锈书。你的里程可能有所不同，但我做了独奏和遭受的。在尝试所有内容之前，我建议与伙伴配对。</p><p>  Too many linked lists: Another great walkthrough once you feel more comfortable reading and writing Rust.</p><p>  有太多的链接名单：一旦你觉得更舒适的阅读和写作锈，另一个伟大的演练。</p><p>  Jon Gjengset&#39;s streams: Jon Gjengset is a well-known Rust community member and has amazing quality streams - if you want to see a proficient Rustacean code, this is a good place to start.</p><p>  Jon Gjengset＆＃39; S溪流：Jon Gjengset是一个着名的生锈社区成员，具有惊人的质量流 - 如果您想看到熟练的rustacean代码，这是一个始于一个好的地方。</p><p>  multicore and atomics: Gets into the weeds about all the pain that Rust can save you when you&#39;re implementing low-level tricky concurrency.</p><p>  多芯和原子：进入杂草关于生锈可以拯救你的所有痛苦，当你实现低级棘手的并发性并发。 </p><p>    Alright, so you&#39;re set up to go on a learning journey. What&#39;s Rust look like anyway when compared to Julia?</p><p>好的，所以你＆＃39;重新开始参加学习之旅。与朱莉娅相比，＆＃39;无论如何都是如此？</p><p>    We love composability and multiple dispatch, so let&#39;s look at a short example of how to get the good ol&#39; Julia bang-for-buck, with a 1D point:</p><p>    我们喜欢可组装性和多次调度，所以让我们看看如何获​​得良好的OL＆＃39的简短示例; Julia Bang-for-Buck，有一个1D点：</p><p>  import Base: + struct Point{T&lt;: Real} val::T end+(x::Point{T}, y::Point{T})  where T&lt;: Real = Point{T}(x.val + y.val)a = Point{ Int32}( 1)b = Point{ Int32}( 2)a + b  # worksc = Point{ Float32}( 1.0)d = Point{ Float32}( 2.0)c + d  # Also works!</p><p>  导入基础：+ struct point {t＆lt;：real} val :: t end +（x :: point {t}，y :: point {t}）其中t＆lt;：real = point {t}（x.val + y .val）a = point {int32}（1）b = point {int32}（2）a + b＃worksc = point {float32}（1.0）d = point {float32}（2.0）c + d＃也有效！</p><p>    I make sure to not use any explicit types and let the dispatch system do the rest. You use functions like  zero(...),  eltype(...). With the dispatches, I add them to the appropriate subtype with  where T&lt;:Foo. If I define the appropriate methods, the others get composed atop of them , so I don&#39;t need to define  += once I&#39;ve defined  +. Duck type all the way - when something errors at runtime because I forgot a case (like the fact there&#39;s no type promotion rules above) I just write a function per call I missed and keep hacking on.</p><p>    我确保不使用任何显式类型，让调度系统休息。您使用像零（...），Eltype（...）这样的功能。通过调度，我将它们添加到适当的子类型，其中t＆lt;：foo。如果我定义了相应的方法，则其他人会被他们组成，所以我不需要定义+ =一旦i＆＃39; ve定义+。鸭子类型一路 - 当运行时的东西时出现错误，因为我忘记了一个案例（就像上面的事实一样，我只写了一个函数，我错过了，并继续黑客。</p><p>  Setup a simple type hierarchy, define some functions on your types without using them explicitly, profit from not rewriting all the code, plug and chug as you run into errors or perf hits, look at docstrings in the REPL to help you out. Happy life.</p><p>  设置一个简单类型的层次结构，在类型上定义某些功能而不明确使用它们，从未重写所有代码，即时重写所有代码，即插即用或perf命中，查看Rept中的Docstrings以帮助您。快乐的人生。</p><p>    use std::ops::Add;  struct  &lt;T&gt; { val: T} impl&lt;T: Add&lt;Output = T&gt;&gt; Add  for  &lt;T&gt; {  type   =  Self;  fn  ( self, b:  Self)  -&gt;  Self::Output {  Self { val:  self.val + b.val } }} fn  () {  let  a = Point::&lt; i32&gt;{val:  1};  let  b = Point::&lt; i32&gt;{val:  2};  let  c = Point::&lt; f32&gt;{val:  1.0};  println!( &#34;{:?}&#34;, a + b);  println!( &#34;{:?}&#34;, c == c);}</p><p>    使用std :: ops ::添加;结构＆lt; t＆gt; {val：t} imagr; t：添加＆lt;输出= t＆gt;＆gt;添加＆lt; t＆gt; {type = self; FN（自我，B：自我） - ＆gt; self ::输出{self {val：self.val + b.val}} fn（）{let a = point ::＆lt; I32＆gt; {val：1};让B =点::＆lt; I32＆gt; {val：2};让c = point ::＆lt; F32＆gt; {val：1.0}; Println！（＆＃34; {：？}＆＃34; a + b）; Println！（＆＃34; {：？}＆＃34;，c == c）;}</p><p>    I worked on like half of this code and then had to  look it up. You can run it in the  Rust Playground here. Avid readers will notice the following:</p><p>    我像这段代码的一半一样工作，然后不得不查找它。您可以在此处在Rust Playground中运行它。狂热读者将注意到以下内容： </p><p>  To get generics, you need a  struct for your type, an  impl&lt;T&gt; $TRAIT for Point&lt;T&gt; block where the  add function is defined, and type annotations like  Self::Output,  Add&lt;Output = T&gt;.</p><p>要获得泛型，需要为您的类型提供一个结构，Alich＆lt; t＆gt;点击点＆lt; t＆gt;块在其中定义的添加函数，键入Self ::输出等注释，添加＆lt;输出= t＆gt ;.</p><p>  There&#39;s a sort of &#34;name spacing&#34; with the turbo fish operator:  ::&lt;this one!&gt;. We don&#39;t get functions that can share names but differ in behaviour. Bummer. (We get this in Julia with some nicer outer constructors, but I think it takes from the thrust of the argument.)</p><p>  有一种＆＃34;名称间距和＃34;与涡轮送鱼操作员:::＆lt;这个！＆gt ;.我们不要获得可以共享名称但在行为中不同的函数。 bummer。 （我们用一些更好的外部构造函数来到Julia，但我认为这是争论的推力。）</p><p>  The  println! function is different - it&#39;s a macro, and it runs at parse time, also like Julia&#39;s macros. The chars inside the  {:?} signal that we want debug printing, that we got above with the  #[derive(Debug)]. Rust doesn&#39;t know how to print new structs if you don&#39;t define it,  which, as Lyndon White points out, is one of the problems solved by multiple dispatch .</p><p>  println！功能是不同的 - 它＆＃39; s宏，它在解析时间，也像朱莉娅＆＃39;宏。我们希望调试打印的{：？}信号内的字符，我们使用上面的＃[派生（debug）]。 Rustn＆＃39;如果您没有定义它，那就像Lyndon White指出的那样，它是如何打印新的结构。它是多次调度解决的问题之一。</p><p>  Oh, those  #[things(above_the_struct)] are also macros. I still don&#39;t know how they&#39;re different, but they seem to affect how the compiler interacts with the crate too. Since some traits (like the ones for copying or printing) are so boilerplate heavy and predictable, you can get some behaviour for &#34;free&#34; if you add the right  #[derive(...)] stuff in the declaration. That&#39;s how the  c == c works actually, it&#39;s due to the  PartialEq.</p><p>  哦，那些＃[东西（上面_the_struct）]也是宏。我仍然不知道他们是如何不同的，但它们似乎也会影响编译器如何与箱子相互作用。由于一些特征（如用于复制或打印的人），因此样板沉重和可预测，您可以为＆＃34获得一些行为;免费＆＃34;如果您在声明中添加了右侧＃[派生（...）]。那个＆＃39;它如何实际上工作，它由于PartiaLeq而作出的作用。</p><p>    Slap a  &lt;T&gt; in front of your struct and the fields you want it to be generic over. Look up the functions needed for each trait in the documentation. Setup a brief test case. Doesn&#39;t compile? See what  rustc says and try and tack it on some traits; maybe you missed an affine type with  impl&lt;T: Foo&gt; or the  Self::Output - the compiler guides you through patching up your code. If you&#39;re asking for some generic behaviour, the compiler will complain and you&#39;ll have to add another trait implementation so that  it is damn sure you&#39;re allowed to continue.</p><p>    拍摄＆lt; t＆gt;在您的结构面前以及您希望它泛化的字段。查找文档中每个特征所需的功能。设置一个简短的测试用例。 ＆＃39; t编译？看看Rustc说的是什么，并尝试在一些特征上钉起来;也许你错过了一种带有iclip＆lt; t：foo＆gt的仿射型;或self ::输出 - 编译器通过修补代码来指导您。如果你＆＃39;重新要求一些通用行为，编译器会抱怨和你＆＃39; ll必须添加另一个特征实现，以便该死的确定＆＃39;重新允许继续。</p><p>  I also chose a particularly easy example: there&#39;s no associated data (like a string) in my  Point&lt;T&gt;, so I don&#39;t need to prove to the compiler that my data doesn&#39;t outlive its uses - those are  lifetimes, and they can get hairy, fast, but you&#39;ll run into them eventually. I also don&#39;t know how easily you could handle multiple generic types and the compile time penalties associated with them.</p><p>  我也选择了一个特别容易的例子：在我的点中没有关联的数据（如字符串），所以我不需要向编译器证明我的数据并在＆＃39; t持续它的用途 - 那些是寿命，他们可以快速，快速，但是你最终跑进了他们。我也没有知道您可以如何容易地处理多种通用类型和与它们相关联的编译时间惩罚。</p><p>  There&#39;s more syntax up front compared to Julia, and not just because we&#39;re writing library code here. Pythonistas can pick up Julia within a few hours and be productive. Rust has a lot more surface area to cover in learning the language: references, traits, impls, enums, lifetimes, pattern matching with  match, macros, cargo flags for configuration, ownership and borrowing, Send and Sync...</p><p>  与Julia相比，在前面的比较方面的语法更多，而不仅仅是因为我们在这里编写库代码。 Pythonistas可以在几个小时内拿起朱莉娅并富有成效。 Rust在学习语言时有很多表面积：参考文献，特征，锯片，枚举，寿命，与匹配，宏，货物标志进行配置，所有权和借用，发送和同步...... </p><p>  Whodathunkit, Garbage Collectors let you worry about other things for a small runtime price. They might not be right for every use case but they&#39;re a solid investment.</p><p>Whodathunkit，垃圾收集器让您担心其他事情的小型运行时价格。它们可能对每种用例都不适合，但它们＆＃39;重新投资。</p><p>      There&#39;s a steep wall to climb when starting out with Rust - however, they&#39;ve nailed the user experience for learning tough stuff. I think it was Esteban Kuber who said something along the lines of &#34;We weren&#39;t missing a sufficiently smart compiler, but a more empathetic one&#34;.</p><p>      当与锈病开始时，在那里爬上陡峭的墙壁 - 但是，他们宣布了学习艰难的东西的用户体验。我认为这是沿着＆＃34的线条的Esteban Kuber;我们不喜欢缺少一个足够聪明的编译器，而是一个更加友好的一个＆＃34;</p><p>  Alright, so what&#39;s the view from the top look like? Like Julia, Rust is an incumbent in a crowded space, so how has it punched above it&#39;s weight against the established candidates?</p><p>  好吧，所以什么＆＃39;从顶部看起来像什么样的视图？像朱莉娅一样，Rust是一个拥挤的空间的现任，所以它如何冲到它上面＆＃39;对既定候选人的重量？</p><p>  Here&#39;s a list of all the projects that I&#39;ve found particularly of note to Julians.</p><p>  这里的所有项目的列表都是我＆＃39;在朱莉安人的笔记中发现的所有项目的列表。</p><p>  rayon is the original reason I got interested in Rust. Check their  hello world - the promise is that if you are using iterators, you can swap (mostly)  iter() for  par_iter() and at compile time you can know if your code will run in parallel. That&#39;s just about the friendliest user interface to parallelism besides  Threads.@threads, and with some additional guarantees - a small update loop is easy to keep the invariants in your head, but it really pays when the Rust compiler catches a concurrency bug that spanned multiple files, modules and data structures. Cool tech note: Rayon uses the  same idea for work stealing thread scheduler that Julia&#39;s parallel task run time system uses (inspired by Cilk, get it? &#39;Cuz Rayon is a fake silk? Ha...).</p><p>  人造丝是我对生锈感兴趣的原因。检查他们的Hello World  - 承诺是，如果您使用的是迭代器，则可以在Par_iter（）和编译时交换（大多数）iter（），您可以知道代码是否正常运行。 ＆＃39; s只是关于线程的并行性的最友好的用户界面。@线程，以及一些额外的保证 - 一个小的更新循环很容易保留头部的不变性，但它真的付出代价，但是当Rust编译器捕获并发时确实付出代价跨越多个文件，模块和数据结构的错误。 Cool Tech注意：Rayon使用同样的工作窃取线程调度程序，朱莉娅＆＃39; S并行任务运行时间系统使用（由Cilk启发，得到它？＆＃39; Cuz人造丝是假丝绸......） 。</p><p>  tokio deserves a mention as well for its capabilities for asynchronous programming, but I am not familiar enough with it to comment on it. Rust people get excited about it though!</p><p>  Tokio也值得提及其异步编程的能力，但我不熟悉它可以评论它。生锈人对此感到兴奋！</p><p>    egg and related projects like  herbie: A wicked fast egraph matching engine - a great competitor and inspiration for the Symbolics.jl ecosystem.</p><p>    鸡蛋和相关项目如herbie：一个邪恶的快速快速呈现引擎 - 一个伟大的竞争对手和灵感符号.jl生态系统。 </p><p>  MMtk and GCs: Garbage Collectors are a family of algorithms that share behaviour, and different strategies can be built atop of tweakable parameters. The promise for building a configurable, performant and battle-tested back-end for Garbage Collectors is alive with this project by Steve Blackburn and gang. If you haven&#39;t heard of  Immix or  Floorplan, enjoy the rabbithole. If you&#39;re new to GCs,  this is a good starting point for seasoned Julians.</p><p>MMTK和GCS：垃圾收集器是一个共享行为的一系列算法，可以在可调参数上建立不同的策略。垃圾收集器建立可配置，表演和战斗的后端的承诺与史蒂夫布拉底堡和团伙一起活着这个项目。如果您没有听到Immix或Ploorplan，则享受rabbithole。如果你＆＃39;重新到GCS，这是经验丰富的朱莉安的一个很好的起点。</p><p>  Rust CLI: Rust people feel comfortable working in the terminal, and they&#39;ve taken that user experience Very Seriously and have a top notch performance and user experience for their command line CLIs. Here&#39;s a few of my favorites - you only need to  cargo install foo and they should be properly installed on your system.</p><p>  Rust Cli：Rust人们觉得在终端工作舒适，他们＆＃39;用户体验非常重视，并为他们的命令行CLIS拥有顶级的表现和用户体验。在这里，我的一些最爱 - 你只需要货物安装foo，它们应该在系统上正确安装。</p><p>  zoxide: directory autojumper. I don&#39;t really do  cd ../.. climbing around anymore I just do  z foo a couple of times and that usually guesses right.</p><p>  左撇子：目录自动jumumper。我没有真正做CD .. ......爬行，我爬了几次，这通常猜测。</p><p>  coz: Invaluable tool for  causal profiling.  Emery Berger&#39;s presentation alone is worth knowing about this project. I reeeeeally want to nerdsnipe someone to port this to Julia.</p><p>  COZ：因果分析的宝贵工具。独自展示的emery berger＆＃39是值得了解这个项目。我重新欣喜地希望有人搬到朱莉娅。</p><p>  sled&#39;s approach to benchmarking and databases is top-notch. Also worthy of note is the same author&#39;s  rio crate, which is a Rust interface for the  io_uring linux kernel module, which can significantly speed up asynchronous programming. There&#39;s some WIP PRs for landing this for  libuv, Julia&#39;s thread runtime backend, and that effort  is close to wrapping up.</p><p>  雪橇＆＃39;基准测试和数据库的方法是顶部缺口。值得注意的是同样的作者＆＃39; s rio crate，这是一个用于io_ing linux内核模块的生锈界面，这可以显着加速异步编程。在Libuv，Julia＆＃39; STREEN运行时后端的一些WIP PRS的一些WIP PRS，并且该努力将接近包装。</p><p>  Rust FFT: They beat FFTW in some cases with this one, so it seems worthwhile to take a look 👀 .</p><p>  生锈FFT：在某些情况下，他们在某些情况下击败了FFTW，所以看起来很值得看看♥。</p><p>  Green function evaluation kernels: Newer package, but I&#39;d like to see how special functions pan out in Rust land.</p><p>  绿色函数评估内核：较新的包，但是我喜欢看多功能在锈的土地上的特殊功能。 </p><p>  Polars: A highly tuned dataframes implementation for some use cases. They&#39;ve topped the charts in some of the  H20ai benchmarks, so they&#39;ve definitely got technical chops. (They beat DataFrames.jl because of a sparsification trick which is a bit non-trivial to implement, but there&#39;s not necessarily an impediment to matching their speed.)</p><p>波拉：一些使用案例的高度调整的Dataframes实现。他们＆＃39;在一些H20AI基准中，它们齐全地饰演了图表，所以它们肯定有技术录音。 （他们击败了DataFrames.jl，因为稀疏技巧有点不琐碎，但是在那里＆＃39; s不一定是匹配它们的速度的障碍。）</p><p>  Loom: a model checker for atomic primitives, sister project to  tokio. I think Julia is a more natural fit for this approach given the ease of operator overloading and it will be great to try something similar once Jameson&#39;s atomics PR lands.</p><p>  LOOM：用于原子基元的模型检查器，Tokio的姐妹项目。我认为朱莉娅对这种方法更加自然的契合鉴于操作员过载，这将是一个詹姆森＆＃39;原子学公关的类似一些类似的东西。</p><p>  Creusot: Add some macros to your Rust code, and have it formally verified by Why3.</p><p>  Creusot：将一些宏添加到生锈代码中，并通过Whe3正式验证。</p><p>  proptest: Configure strategies for exploring type instantiations to fuzz your tests, shrink the cases, and automatically track regressions. Impressive stuff!</p><p>  proptest：配置探索型实例化的策略以使您的测试模糊，缩小案例，并自动跟踪回归。令人印象深刻的东西！</p><p>  Gleam and  Lumen: Gleam is a Rust backend for an Erlang based language and Lumen is a Rewritten-in-Rust implementation of the ErlangVM, BEAM. Erlang is a concurrency monster, and their actor based model is scalable as hell for certain workloads. I&#39;m glad to see Julia start to step into that domain with  Actors.jl. This seems to be the  right way to abstract for fault tolerance workloads.</p><p>  闪闪发光的和腔：闪光是一种磨牙后端，是基于erlang的语言，流明是一种重写的res-in-rus-rust-in-rudvm，梁。 Erlang是一个并发怪物，它们的演员的模型可扩展为某些工作负载。我很高兴看到朱莉娅开始逐步参加actors.jl。这似乎是抽象容错工作负载的正确方法。</p><p>  There&#39;s oodles more. Check out  crates.io or  lib.rs if you want to explore more (this is their community based JuliaHub equivalent).</p><p>  在那里更多。如果您想探索更多（这是他们的社区juliahub等效），请签出箱子.IO或lib.rs。</p><p>  I&#39;ll make a special note of  evcxr, a Rust REPL. For now, I don&#39;t think it&#39;s profitable to use Rust with a REPL-like workflow. I&#39;m too used to that in Julia, and that works well there, but I think there&#39;s a risk of digging yourself into a &#34;Everything must be a REPL&#34; mentality and cutting yourself off from learning opportunities. In Rust land, I don&#39;t mind doing as the Rustaceans do and learning to do things around a command line, navigating compiler errors and configuring flags and features for certain behaviours or deployment options. Since that&#39;s the package that I wanted to learn when I bought into Rust, I don&#39;t mind adapting into that mindset. I still wish them all the best and hope they can make the best possible Rust REPL - I&#39;d love to be wrong on this down the road.</p><p>  我＆＃39; ll是一个特殊的evcxr，一个锈的reft。现在，我不认为它＆＃39;＆＃39;使用Rust的工作流程使用Rust。我也习惯了在朱莉娅，在那里工作，但我认为那里的风险将自己挖掘到A＆＃34;一切都必须是曲折＆＃34;心理和削减自己的学习机会。在Rust Land中，我不介意作为rustaceans做和学习在命令行中做事，导航编译器错误和配置某些行为或部署选项的旗帜和功能。自那个＆＃39;当我买进生锈时我想学习的包裹，我不介意调整这一心态。我仍然希望他们一切顺利，并希望他们能够制作最好的锈病 - 我＆＃39; d在这条路上有错。 </p><p>      If you want to dive deep into nitty gritty performance fundamentals, these are the best guides I found for explaining the tradeoffs, gotchas, mental model, and engineering for those tasty, tasty flops.</p><p>如果您想深入进入Nitty Gitty性能基础，这些是我发现的最佳指南，即用于解释那些美味，美味的笨蛋的权衡，Gotchas，Mental Model和工程。</p><p>  COST paper: Maybe doesn&#39;t fit here but this is one of my favorite papers and everyone should read it.</p><p>  成本纸：也许不适合这里，但这是我最喜欢的论文之一，每个人都应该阅读它。</p><p>      So Rust is &#34;worth learning&#34;, but these are roadblocks that I faced and would warn others about to save them some grief.</p><p>      所以Rust是＆＃34;值得学习＆＃34;但是这些是我面临的障碍，并会警告其他人即将拯救他们一些悲伤。</p><p>  You can learn another hobby waiting for Rust projects to compile. The price for compile-time guarantees/being the designated driver in the codebase is offloading more work to the compiler. They&#39;re working on leveraging concurrency for speeding up the pipeline, and it&#39;s gotten better. Let&#39;s just say they also suffer from TTFP 😉 .</p><p>  您可以学习其他业余爱好等待锈的项目编译。编译时担保的价格/是代码库中指定的驱动程序对编译器卸载了更多的工作。他们＆＃39;重新努力利用并发加速管道，并达到更好的＆＃39;让＆＃39; S只是说他们也患有TTFP♥。</p><p>  Learn to run your code with  cargo run --release  and other tricks. This is the equivalent to running your Julia code with globals (or  -O0 flags), and it&#39;s an easy gotcha. This will not change in Rust.</p><p>  学习用货物运行的代码 - 释放和其他技巧。这相当于使用全局（或-o0标志）运行朱莉娅代码，它是一个简单的gotcha＆＃39;这不会改变生锈。</p><p>  Rust people keep saying they have no Garbage Collector, when they have a Region Based Garbage Collector. It&#39;s all fun and games until they have to implement those linked lists...</p><p>  生锈人们一直说他们没有垃圾收集器，当他们有一个基于地区的垃圾收集器时。它＆＃39;既有乐趣和游戏，直到他们必须实施这些链接的清单......</p><p>  Don&#39;t add crates manually! Install  cargo-add, use it to manage crate dependencies. That and some other tricks are great from doing the  AdventOfCode2020 from the article above.</p><p>  Don＆＃39; t手动添加箱子！安装Cargo-Add，使用它来管理Crate依赖项。除了上面的文章中，这与其他一些诀窍很好地完成了adventofcode2020。 </p><p>  For numerics, install  ndarray and  num_traits. Linear Algebra and numerics where not a primary focus of Rust when starting out as they were with Julia.</p><p>用于数字，安装ndArray和num_traits。线性代数和数字，在开始时不是朱莉娅的原始重点。</p><p>  Setup your  rust-analyzer and  error lens plugins on VSCode or IDE asap, you&#39;ll thank me later. Rust-land expects you to be in constant dialogue with the compiler, and making that iteration cycle as ergonomic as possible will yield dividends in the long run. What we don&#39;t get from accessing help docs in the REPL, Rust people keep a terminal tab handy where they run  cargo watch -c and get continuous feedback from the compiler.</p><p>  在vscode或IDE上设置生锈分析仪和错误镜头插件，You＆＃39; LL稍后谢谢。 Rust-Land希望您与编译器保持不变的对话，并使迭代周期尽可能符合人体工程学，从长远来看会产生红利。我们不从Repl中访问Help Docs访问，Rust人员保留终端选项卡，在那里运行Cargo Watch -C并获得编译器的连续反馈。</p><p>  You CAN&#39;T index into a String in Rust with ints!  Instead use slices like  &amp;str[1..] == str[2:end], if I may riff on Rust and Julia syntax in the equality just there.</p><p>  你可以＆＃39; t索引到ruct的字符串中与ints！而是使用像＆amp的片; str [1 ..] == str [2：结束]，如果我可以在那里的平等中的rust和julia语法上riff。</p><p>  Reading from  stdin is a pain as a newcomer. I wanted to try out some competitive coding exercises and reading from  stdin was waaaay too rough for me at first. Eventually I cobbled this template up  link here so that you don&#39;t struggle if you want to try a couple of CodeForces problems.</p><p>  从STDIN阅读是一种痛苦作为新人。我想尝试一些有竞争力的编码练习，并从Stdin阅读是Waaaay起初对我来说太粗糙了。最终我把这个模板旋转到这里联系在这里，以便你不要挣扎，如果你想尝试几个代码的问题。</p><p>  Not having a generic  rand is just painful. So painful. This is my easiest workaround so far for generating a vector of  n random entries:</p><p>  没有仿制兰特只是痛苦。如此痛苦。到目前为止，这是我最简单的解决方法，以生成N个随机条目的向量：</p><p>      There is no  @code_native and friends in Rust - your best bet is to use the Rust Playground and click on the  ... to have it emit the total assembly. This only works for the top 100 most popular crates though. You can  cargo run --release -- --emit=llvm-ir/asm and then fish the results out of  target/, but that&#39;s un</p><p>      没有@code_native和friend在forr  - 你最好的选择是使用铁锈游乐场，然后点击......让它发出总装配。这仅适用于前100名最受欢迎的箱子。您可以货物运行 -   - 释放 -   -   -  emit = llvm-Ir / asm，然后将结果捕获出目标/，但是＆＃39; s联合国</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://miguelraz.github.io/blog/juliatorust/">https://miguelraz.github.io/blog/juliatorust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>