<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Windows计时器分辨率：重大规则更改 Windows Timer Resolution: The Great Rule Change</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Windows Timer Resolution: The Great Rule Change<br/>Windows计时器分辨率：重大规则更改 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-31 02:14:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/c614b3a1cd756127f22b9556f26a7829.png"><img src="http://img2.diglog.com/img/2021/1/c614b3a1cd756127f22b9556f26a7829.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The behavior of the Windows scheduler changed significantly in Windows 10 2004 (aka, the April 2020 version of Windows), in a way that will break a few applications, and there appears to have been no announcement, and the documentation has not been updated. This  isn’t the first time this has happened, but this change seems bigger than last time. So far I have found three programs that hit problems because of this silent change.</p><p>Windows调度程序的行为在Windows 10 2004（又名2020年4月版Windows）中发生了重大变化，这种方式将破坏一些应用程序，并且似乎没有公告，并且文档尚未更新。这不是第一次发生这种情况，但是这种变化似乎比上一次更大。到目前为止，由于这种无声的更改，我发现了三个遇到问题的程序。</p><p> The short version is that calls to   timeBeginPeriod from one process now affect other processes  less than they used to. There is still an effect, and thread delays from  Sleep and other functions may be less consistent than they used to be (see [updated] section below), but in general processes are no longer affected by other processes calling  timeBeginPeriod.</p><p> 简短的版本是，从一个进程调用timeBeginPeriod现在对其他进程的影响要比以前小。仍然会产生影响，并且Sleep和其他函数的线程延迟可能不像以前那样一致（请参阅下面的[updated]部分），但通常，进程不再受调用timeBeginPeriod的其他进程的影响。</p><p>  I think the new behavior is an improvement, but it’s weird, and it deserves to be documented. Fair warning – all I have are the results of experiments I have run, so I can only speculate about the quirks and goals of this change. If any of my conclusions are wrong then please let me know and I will update this.</p><p>  我认为新行为是一种改进，但是很奇怪，值得记录。合理的警告–我所拥有的只是我进行的实验的结果，因此我只能推测这种变化的怪癖和目标。如果我的结论有误，请告诉我，我将对此进行更新。</p><p>  First, a bit of operating-system design context. It is desirable for a program to be able to go to sleep and then wake up a little while later. This actually shouldn’t be done very often – threads should normally be waiting on events rather than timers – but it is sometimes necessary. And so we have the Windows  Sleep function – pass it the desired length of your nap in milliseconds and it wakes you up later, like this:</p><p>  首先，介绍一些操作系统设计上下文。希望程序能够进入睡眠状态，然后稍后再唤醒。实际上，这不应该经常执行-线程通常应该等待事件而不是计时器-但有时这是必要的。因此，我们有了Windows睡眠功能–将其传递给您所需的午睡时间（以毫秒为单位），然后将您唤醒，如下所示：</p><p>  It’s worth pausing for a moment to think about how this is implemented. Ideally the CPU goes to sleep when  Sleep(1) is called, in order to save power, so how does the operating system (OS) wake your thread if the CPU is sleeping? The answer is hardware interrupts. The OS programs a timer chip that then triggers an interrupt that wakes up the CPU and the OS can then schedule your thread.</p><p>  值得暂停一下，以考虑一下它是如何实现的。理想情况下，当调用Sleep（1）时，CPU会进入睡眠状态，以节省电量，因此，如果CPU处于睡眠状态，操作系统（OS）如何唤醒您的线程？答案是硬件中断。操作系统对计时器芯片进行编程，然后该计时器芯片触发中断以唤醒CPU，然后操作系统可以调度线程。</p><p> The  WaitForSingleObject and WaitForMultipleObjects functions also have timeout values and those timeouts are implemented using the same mechanism.</p><p> WaitForSingleObject和WaitForMultipleObjects函数也具有超时值，并且这些超时是使用相同的机制实现的。</p><p> If there are many threads all waiting on timers then the OS could program the timer chip with individual wakeup times for each thread, but this tends to result in threads waking up at random times and the CPU never getting to have a long nap. CPU power efficiency is strongly tied to how long the CPU can stay asleep ( 8+ ms is apparently a good number), and random wakeups work against that. If multiple threads can synchronize or coalesce their timer waits then the system becomes more power efficient.</p><p> 如果有许多线程都在等待计时器，则操作系统可以为每个线程的唤醒时间对计时器芯片进行编程，但这往往会导致线程在随机时间唤醒，并且CPU永远不会出现长时间的小睡。 CPU的电源效率与CPU可以保持睡眠状态的时间紧密相关（8+ ms显然是一个不错的数字），随机唤醒可以解决这一问题。如果多个线程可以同步或合并它们的计时器等待，则系统将变得更加省电。 </p><p> There are lots of ways to coalesce wakeups but the main mechanism used by Windows is to have a global timer interrupt that ticks at a steady rate. When a thread calls  Sleep(n) then the OS will schedule the thread to run when the first timer interrupt fires after the time has elapsed. This means that the thread may end up waking up a bit late, but Windows is not a  real-time OS and it actually cannot guarantee a specific wakeup time (there may not be a CPU core available at that time anyway) so waking up a bit late should be fine.</p><p>有很多方法可以合并唤醒，但是Windows使用的主要机制是使全局计时器中断以稳定的速度跳动。当线程调用Sleep（n）时，操作系统将安排线程在经过该时间后第一个计时器中断触发时运行。这意味着线程可能最终会唤醒得有点晚，但是Windows不是实时操作系统，它实际上不能保证特定的唤醒时间（无论如何那时都可能没有CPU内核），因此唤醒晚一点应该没问题。</p><p> The interval between timer interrupts depends on the Windows version and on your hardware but on every machine I have used recently the  default interval has been 15.625 ms (1,000 ms divided by 64). That means that if you call  Sleep(1) at some random time then you will probably be woken sometime between 1.0 ms and 16.625 ms in the future, whenever the next interrupt fires (or the one after that if the next interrupt is too soon).</p><p> 计时器中断之间的间隔取决于Windows版本和您的硬件，但在我最近使用的每台计算机上，默认间隔为15.625毫秒（1,000毫秒除以64）。这意味着，如果您在某个随机时间调用Sleep（1），那么将来每当下一个中断触发时（或者如果下一个中断过早，则在此之后触发），您可能会在1.0毫秒至16.625毫秒之间的某个时间被唤醒。 。</p><p> In short, it is the nature of timer delays that (unless a busy wait is used, and  please don’t busy wait) the OS can only wake up threads at a specific time by using timer interrupts, and a regular timer interrupt is what Windows uses.</p><p> 简而言之，计时器延迟的本质是（除非使用繁忙的等待，请不要繁忙的等待）操作系统只能通过使用计时器中断在特定的时间唤醒线程，而定期的计时器中断就是Windows使用。</p><p> Some programs (WPF, SQL Server, Quartz, PowerDirector, Chrome, the Go Runtime, many games, etc.) find this much variance in wait delays hard to deal with but luckily there is a function that lets them control this.   timeBeginPeriod  lets a program request a smaller timer interrupt interval by passing in a requested timer interrupt interval. There is also   NtSetTimerResolution  which allows setting the interval with sub-millisecond precision but that is rarely used and never needed so I won’t mention it again.</p><p> 一些程序（WPF，SQL Server，Quartz，PowerDirector，Chrome，Go Runtime，许多游戏等）发现等待延迟中的这种巨大差异很难处理，但是幸运的是，有一个函数可以让他们控制此延迟。 timeBeginPeriod允许程序传入请求的计时器中断间隔，从而请求较小的计时器中断间隔。还有NtSetTimerResolution，它可以以毫秒级的精度来设置时间间隔，但这很少使用，也不需要，因此我不再赘述。</p><p>  Here’s the crazy thing:   timeBeginPeriod can be called by any program and it changes the timer interrupt interval, and the timer interrupt is a  global resource.</p><p>  这很疯狂：任何程序都可以调用timeBeginPeriod，它会更改计时器中断间隔，并且计时器中断是全局资源。</p><p> Let’s imagine that Process A is sitting in a loop calling  Sleep(1). It shouldn’t be doing this, but it is, and by default it is waking up every 15.625 ms, or 64 times a second. Then Process B comes along and calls  timeBeginPeriod(2). This makes the timer interrupt fire more frequently and suddenly Process A is waking up 500 times a second instead of 64 times a second. That’s crazy! But that’s how Windows has always worked.</p><p> 假设进程A坐在一个调用Sleep（1）的循环中。它不应该这样做，但默认情况下，它每15.625毫秒或每秒64次唤醒。然后进程B出现并调用timeBeginPeriod（2）。这使计时器中断更频繁地触发，并且进程A突然每秒唤醒500次，而不是每秒64次。太疯狂了！但这就是Windows始终有效的方式。</p><p> At this point if Process C came along and called  timeBeginPeriod(4) this wouldn’t change anything – Process A would continue to wake up 500 times a second. It’s not last-call-sets-the-rules, it’s lowest-request-sets-the-rules.</p><p> 在这一点上，如果进程C出现并调用timeBeginPeriod（4），则不会有任何变化–进程A将继续每秒唤醒500次。这不是最后确定规则的方法，而是最低要求确定规则的方法。 </p><p> To be more specific, whatever still running program has specified the smallest timer interrupt duration in an outstanding call to  timeBeginPeriod gets to set the global timer interrupt interval. If that program exits or calls   timeEndPeriod then the new minimum takes over. If a single program called  timeBeginPeriod(1) then that is the timer interrupt interval for the entire system. If one program called  timeBeginPeriod(1) and another program then called  timeBeginPeriod(4) then the one ms timer interrupt interval would be the law of the land.</p><p>更具体地说，无论是什么仍在运行的程序在未完成的timeBeginPeriod调用中都指定了最小的计时器中断持续时间，可以设置全局计时器中断间隔。如果该程序退出或调用timeEndPeriod，则新的最小值将接管。如果单个程序名为timeBeginPeriod（1），则这是整个系统的计时器中断间隔。如果一个程序调用了timeBeginPeriod（1），然后另一个程序调用了timeBeginPeriod（4），则一个毫秒的计时器中断间隔将成为定律。</p><p> This matters because a high timer interrupt frequency – and the associated high-frequency of thread scheduling – can waste significant power,  as discussed here.</p><p> 这很重要，因为较高的计时器中断频率（以及相关的线程调度频率）会浪费大量功率，如此处所述。</p><p> One case where timer-based scheduling is needed is when implementing a web browser. The JavaScript standard has a function called   setTimeout which asks the browser to call a JavaScript function some number of milliseconds later. Chromium uses timers (mostly  WaitForSingleObject with timeouts rather than  Sleep) to implement this and other functionality. This often requires raising the timer interrupt frequency. In order to reduce the battery-life implications of this Chromium has been modified recently so that it  doesn’t raise the timer interrupt frequency above 125 Hz (8 ms interval) when running on battery.</p><p> 在实现Web浏览器时，需要基于计时器的计划的一种情况。 JavaScript标准具有一个名为setTimeout的函数，该函数要求浏览器在数毫秒后调用JavaScript函数。 Chromium使用计时器（大多数是带有超时而不是睡眠的WaitForSingleObject）来实现此功能和其他功能。这通常需要提高计时器中断频率。为了减少对电池寿命的影响，最近对此Chromium进行了修改，以便在使用电池供电时不会将计时器中断频率提高到125 Hz（间隔为8毫秒）以上。</p><p>  timeGetTime (not to be confused with GetTickCount) is a function that returns the current time, as updated by the timer interrupt. CPUs have historically not been good at keeping accurate time (their clocks intentionally fluctuate to avoid being FM transmitters, and for other reasons) so they often rely on separate clock chips to keep accurate time. Reading from these clock chips is expensive so Windows maintains a 64-bit counter of the time, in milliseconds, as updated by the timer interrupt. This timer is stored in shared memory so any process can cheaply read the current time from there, without having to talk to the timer chip.  timeGetTime calls  ReadInterruptTick which at its core just reads this 64-bit counter. Simple!</p><p>  timeGetTime（不要与GetTickCount混淆）是一个返回当前时间的函数，该时间由计时器中断更新。历史上，CPU一直不擅长保持准确的时间（由于其他原因，它们的时钟有意波动以避免成为FM发射器），因此它们通常依赖于单独的时钟芯片来保持准确的时间。从这些时钟芯片读取数据非常昂贵，因此Windows会维护一个64位的时间计数器（以毫秒为单位），该时间由计时器中断更新。该计时器存储在共享内存中，因此任何进程都可以廉价地从那里读取当前时间，而不必与计时器芯片对话。 timeGetTime调用ReadInterruptTick，它的核心只是读取此64位计数器。简单！</p><p> Since this counter is updated by the timer interrupt we can monitor it and find the timer interrupt frequency.</p><p> 由于该计数器是通过定时器中断更新的，因此我们可以对其进行监视并找到定时器中断的频率。</p><p>  With the Windows 10 2004 (April 2020 release) some of this quietly changed, but in a very confusing way. I first heard about this through  reports that timeBeginPeriod didn’t work anymore. The reality was more complicated than this.</p><p>  在Windows 10 2004（2020年4月发行）中，其中的一些内容悄然发生了变化，但方式非常混乱。我最初是通过timeBeginPeriod不再工作的报告听说的。现实比这更复杂。</p><p> A bit of experimentation gave confusing results. When I ran a program that called  timeBeginPeriod(2) then  clockres showed that the timer interval was 2.0 ms, but a separate test program with a  Sleep(1) loop was only waking up about 64 times a second instead of the 500 times a second that it would have woken up under previous versions of Windows.</p><p> 进行一些实验得出了令人困惑的结果。当我运行一个名为timeBeginPeriod（2）的程序时，clockres显示计时器间隔为2.0毫秒，但是带有Sleep（1）循环的单独测试程序每秒仅唤醒约64次，而不是每秒500次。在以前的Windows版本中会被唤醒。 </p><p>  I then wrote a pair of programs which revealed what was going on. One program ( change_interval.cpp) just sits in a loop calling  timeBeginPeriod with intervals ranging from 1 to 15 ms. It holds each timer interval request for four seconds, and then goes to the next one, wrapping around when it is done. It’s fifteen lines of code. Easy.</p><p>然后，我编写了两个程序，揭示了正在发生的事情。一个程序（change_interval.cpp）只是坐在一个循环中，调用timeBeginPeriod的时间间隔为1到15 ms。它会将每个计时器间隔请求保留四秒钟，然后转到下一个请求，完成后回绕。这是十五行代码。简单。</p><p> The other program ( measure_interval.cpp) runs some tests to see how much its behavior is altered by the behavior of change_interval.cpp. It does this by gathering three pieces of information.</p><p> 另一个程序（measure_interval.cpp）运行一些测试，以查看change_interval.cpp的行为对其行为的影响。它通过收集三个信息来做到这一点。</p><p> It asks the OS what the current global timer resolution is, using  NtQueryTimerResolution. It measures the precision of  timeGetTime by calling it in a loop until its return value changes. When it changes then the amount it changed by is its precision. It measures the delay of  Sleep(1) by calling it in a loop for a second and counting how many calls it can make. The average delay is just the reciprocal of the number of iterations.</p><p> 它使用NtQueryTimerResolution询问操作系统当前的全局计时器分辨率是多少。它通过循环调用timeGetTime的精度直到其返回值更改，从而测量其精度。当它改变时，它改变的量就是它的精度。它通过在一个循环中调用Sleep（1）并计算其可以进行的调用次数来衡量Sleep（1）的延迟。平均延迟只是迭代次数的倒数。</p><p> @FelixPetriconi ran the tests for me on Windows 10 1909 and I ran the tests on Windows 10 2004. The results (cleaned up to remove randomness) are shown here:</p><p> @FelixPetriconi在Windows 10 1909上为我运行了测试，并且在Windows 10 2004上运行了测试。结果（清理以消除随机性）如下所示：</p><p>  What this means is that  timeBeginPeriod still sets the global timer interrupt interval, on all versions of Window. We can tell from the results of   timeGetTime() that the interrupt fires on at least one CPU core at that rate, and the time is updated. Note also that the 2.0 on row one for 1909 was  2.0 on Windows XP, then 1.0 on Windows 7/8, and is apparently back to 2.0? I guess?</p><p>  这意味着在所有版本的Window上，timeBeginPeriod仍设置全局计时器中断间隔。从timeGetTime（）的结果可以看出，中断以该速率在至少一个CPU内核上触发，并且时间被更新。还要注意，1909年第一行的2.0在Windows XP上是2.0，然后在Windows 7/8上是1.0，显然回到了2.0？我猜？</p><p> However the scheduler behavior changes dramatically in Windows 10 2004. Previously the delay for  Sleep(1) in any process was simply the same as the timer interrupt interval (with an exception for timeBeginPeriod(1)), giving a graph like this:</p><p> 但是，调度程序的行为在Windows 10 2004中发生了巨大变化。以前，在任何进程中，Sleep（1）的延迟都与计时器中断间隔（timeBeginPeriod（1）除外）相同，给出了如下图：</p><p>  In Windows 10 2004 the mapping between  timeBeginPeriod and the sleep delay in another process (one that didn’t call  timeBeginPeriod) is peculiar:</p><p>  在Windows 10 2004中，timeBeginPeriod和另一个过程（未调用timeBeginPeriod）中的睡眠延迟之间的映射是特殊的： </p><p>     As was pointed out in the  reddit discussion, the left half of the graph seems to be an attempt to simulate the “normal” 15.625 ms delay as closely as possible given the available precision of the global timer interrupt. That is, with a 6 millisecond interrupt interval they delay for ~12 ms (two cycles) and with a 7 millisecond interrupt interval they delay for ~14 ms (two cycles) – that matches the data fairly well. However what about with an 8 millisecond interrupt interval? They could sleep for two cycles but that would give an average delay of 16 ms, and the measured value is more like 14.5 ms.</p><p>正如在reddit讨论中指出的那样，鉴于全局计时器中断的可用精度，图表的左半部分似乎是在尽可能接近地模拟“正常” 15.625 ms延迟的尝试。也就是说，在6毫秒的中断间隔内，它们会延迟〜12 ms（两个周期），而在7毫秒的中断间隔下，它们会延迟〜14 ms（两个周期），这与数据非常匹配。但是，中断间隔为8毫秒又如何呢？他们可以睡两个周期，但平均延迟为16 ms，测量值更像14.5 ms。</p><p> Closer analysis shows that  Sleep(1) when another process has called  timeBeginPeriod(8) returns after one interval about 20% of the time and after two intervals the rest. Therefore three calls to  Sleep(1) resulting in a average delay of 14.5 ms. This variation in the handling of Sleep(1) happens sometimes at other timer interrupt intervals but is most consistent when it is set to 8 ms.</p><p> 进一步的分析显示，当另一个进程调用timeBeginPeriod（8）时，一个时间间隔约20％的时间后返回Sleep（1），其余两个时间间隔后返回。因此，三个对Sleep（1）的调用导致平均14.5 ms的延迟。对Sleep（1）的处理上的这种变化有时会在其他定时器中断间隔发生，但是当设置为8 ms时，这种变化最为一致。</p><p> This is all very weird, and I don’t understand the rationale, or the implementation. The intentional inconsistency in the  Sleep(1) delays is particularly worrisome. Maybe it is a bug, but I doubt it. I think that there is complex backwards compatibility logic behind this. But, the most powerful way to avoid compatibility problems is to document your changes, preferably in advance, and this seems to have been slipped in without anyone being notified.</p><p> 这一切都很奇怪，我不了解其原理或实现方式。 Sleep（1）延迟中的故意不一致特别令人担忧。也许这是一个错误，但我对此表示怀疑。我认为这背后有复杂的向后兼容逻辑。但是，避免兼容性问题的最有效方法是，最好是事先记录更改，并且似乎没有通知任何人。</p><p> This behavior also seems to apply to CreateWaitableTimerEx and its so-far-undocumented  CREATE_WAITABLE_TIMER_HIGH_RESOLUTION flag, based on the quick-and-dirty  waitable timer tests that you can find here (requires Windows 10 1803 or higher).</p><p> 这种行为似乎也适用于CreateWaitableTimerEx及其迄今未公开的CREATE_WAITABLE_TIMER_HIGH_RESOLUTION标志，基于您可以在此处找到的快速且可等待的计时器测试（需要Windows 10 1803或更高版本）。</p><p> Most programs will be unaffected. If a process wants a faster timer interrupt then it should be calling  timeBeginPeriod itself. That said, here are the problems that this could cause:</p><p> 大多数程序将不受影响。如果进程需要更快的计时器中断，那么它应该自己调用timeBeginPeriod。也就是说，这可能会导致以下问题：</p><p> A program might accidentally assume that  Sleep(1) and  timeGetTime have similar resolutions, and that assumption is broken now. But, such an assumption seems unlikely. A program might depend on a fast timer resolution and fail to request it. There have been multiple claims that  some games have this problem and there is a tool called  Windows System Timer Tool and another called  TimerResolution 1.2 that “fix” these games by raising the timer interrupt frequency. Those fixes presumably won’t work anymore, or at least not as well. Maybe this will force those games to do a proper fix, but until then this change is a backwards compatibility problem. A multi-process program might have its  master control program raise the timer interrupt frequency and then expect that this would affect the scheduling of its child processes. This used to be a reasonable design choice, and now it doesn’t work. This is how I was alerted to this problem. The product in question now calls  timeBeginPeriod in all of their processes so they are fine, thanks for asking, but their software was misbehaving for several months with no explanation. Since I wrote this article I have received reports of two other multi-process programs with the same problem. It’s an easy fix, but a painful investigation to understand what has gone wrong.</p><p> 程序可能会意外地假设Sleep（1）和timeGetTime具有相似的分辨率，并且该假设现在已被打破。但是，这种假设似乎不太可能。程序可能依赖于快速的计时器分辨率而无法请求。有许多人声称某些游戏存在此问题，并且有一个名为Windows System Timer Tool的工具和另一个名为TimerResolution 1.2的工具，该工具通过提高计时器中断频率来“修复”这些游戏。这些修复程序可能不再起作用，或者至少不会起作用。也许这将迫使这些游戏进行适当的修复，但是在此之前，此更改是向后兼容性问题。多进程程序可能会使其主控制程序提高计时器中断频率，然后期望这会影响其子进程的调度。这曾经是一个合理的设计选择，但现在不起作用。这就是提醒我此问题的方式。现在有问题的产品在其所有过程中都调用timeBeginPeriod，因此很好，谢谢您的询问，但是他们的软件出现了几个月的故障，没有任何解释。自从我撰写本文以来，我已经收到有关其他两个具有相同问题的多进程程序的报告。这是一个简单的解决方法，但是要弄清楚问题出在哪里，这是一个痛苦的调查。</p><p>  The change_interval.cpp test program only works if nothing has requested a higher timer interrupt frequency. Since both Chrome and Visual Studio have a habit of doing this I had to do most of my experimentation with no access to the web while  writing code in notepad. Somebody suggested Emacs but wading into  that  debate is more than I’m willing to do.</p><p>  change_interval.cpp测试程序仅在没有请求更高计时器中断频率的情况下才能运行。由于Chrome和Visual Studio都有这样做的习惯，因此我必须在笔记本中编写代码的同时进行大部分实验，而无法访问网络。有人建议Emacs，但是涉足这场辩论超出了我的意愿。 </p><p> I’d love to hear more about this from Microsoft, including any corrections to my analysis. Discussions:</p><p>我希望能从Microsoft那里获得更多信息，包括对我的分析所做的任何更正。 讨论： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://randomascii.wordpress.com/2021/01/29/windows-timer-resolution-the-great-rule-change-2/">https://randomascii.wordpress.com/2021/01/29/windows-timer-resolution-the-great-rule-change-2/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/计时器/">#计时器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/timer/">#timer</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>