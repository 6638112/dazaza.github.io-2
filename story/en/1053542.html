<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>黑客数值分析指南 Hacker's Guide to Numerical Analysis</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hacker's Guide to Numerical Analysis<br/>黑客数值分析指南 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 09:14:24</div><div class="page_narrow text-break page_content"><p>Consider the following program: # include  &lt;cmath&gt;  # include  &lt;stdio.h&gt; int  main ( )  {  double x  =  12e-9 ;  double c  =  cos (x ) ;  double one_sub_c  =  1  - c ;  double denom  = x *x ;  double yhat  = one_sub_c  / denom ;  printf ( &#34;x: %20.16f\n&#34;  &#34;cx: %20.16f\n&#34;  &#34;one_sub_c: %20.16f\n&#34;  &#34;denom: %20.16f\n&#34;  &#34;yhat: %20.16f\n&#34; , x , c , one_sub_c , denom , yhat ) ;  }</p><p>考虑以下程序：＃包括＆lt; cmath＆gt; ＃包括＆lt; stdio.h＆gt; int main（）{double x = 12e-9;双c = cos（x）;双倍one_sub_c = 1  -  c;双邻接= x * x;双yhat = one_sub_c / denom; Printf（＆＃34; x：％20.16f \ n＆＃34;＆＃34; cx：％20.16f \ n＆＃34;＆＃34; one_sub_c：％20.16f \ n＆＃34;＆＃34;否定： ％20.16f \ n＆＃34;＆＃34; yhat：％20.16f \ n＆＃34;，x，c，one_sub_c，denom，yhat）; }</p><p> which produces the output:  This is     clearly wrong, because we know that        ( 1 − cos ⁡ x ) /  x 2 ) ≤ 1 / 2 (1-\cos x)/x^2) \leq 1/2    ( 1  −    cos  x ) /  x        2 )  ≤    1 / 2. The reason for this terrible result is that: we know        cos ⁡ x \cos x    cos  x to high accuracy, since        x x    x was some fixed quantity.</p><p> 产生输出：这显然是错误的，因为我们知道（1  -  cos⁡x）/ x 2）≤1/ 2（1- \ cos x）/ x ^ 2）\ leq 1/2（1  -  cos x）/ x 2）≤1/ 2.此可怕结果的原因是：我们知道Cos⁡X\ cos x cosx到高精度，因为xxx是一些固定数量。</p><p> 1 − cos ⁡ x 1 - \cos x    1  −    cos  x converted the     error in        cos ⁡ x \cos x    cos  x into its     value.</p><p> 1  -  COS⁡x 1  -  \ cos x 1  -  cos x将cos⁡x\ cos x cosx中的错误转换为其值。</p><p> 1 − cos ⁡ x 1 - \cos x    1  −    cos  x has only one significant figure.</p><p> 1  -  COS⁡x 1  -  \ cos x 1  -  cos x只有一个重要人物。</p><p> In general: x ≡ 1 + ϵ  error of order   ϵ         y ≡ 1 − x = ϵ  value of order   ϵ \begin{aligned}&amp;x \equiv 1 + \epsilon \text{error of order $\epsilon$} \\&amp;y \equiv 1 - x = \epsilon \text{value of order $\epsilon$} \\\end{aligned}                ​            x  ≡  1  +  ϵ  error of order  ϵ     y  ≡  1  −  x  =  ϵ  value of order  ϵ ​</p><p> 一般：x≡1+εorgrantεy≡1 -  x =ε值的ε\ begin {对齐}＆amp; x \ Equiv 1 + \ epsilon \ text {orground $ \ epsilon $} \\ ＆amp; Y \ Equiv 1  -  x = x = epsilon \文本{order $ \ epsilon $} \\\ end {对齐} x≡1+εor er oεy∈1 -  x =ε值ε</p><p> That is, subtracting values close to each other (in this case,        1 1    1 and        x x    x) converts     error order of magnitude into     value order of magnitude.  Alternatively, it brings earlier errors into promience as values.  We can consider the subtraction: x = a − b ;  x ^ =  a ^ −  b ^          a ^ = a ( 1 + Δ a )          b ^ = b ( 1 + Δ b )          ∣   x −  x ^ x ∣         =  ∣   − a Δ a − b Δ b  a − b ∣         =   ∣ − a Δ a − b Δ b ∣  ∣ a − b ∣         =   ∣ a Δ a + b Δ b ∣  ∣ a − b ∣         ≤   max ⁡ ( ∣ Δ a ∣ , ∣ Δ b ∣ ) ( ∣ a ∣ + ∣ b ∣ )  ∣ a − b ∣ \begin{aligned}&amp;x = a - b; \hat x = \hat a - \hat b \\&amp;\hat a = a(1 + \Delta a) \\&amp;\hat b = b(1 + \Delta b) \\&amp;\left| \frac{x - \hat x}{x} \right| \\&amp;= \left| \frac{-a\Delta a - b\Delta b}{a - b} \right| \\&amp;= \frac{|-a\Delta a - b\Delta b|}{|a - b|} \\&amp;= \frac{|a\Delta a + b\Delta b|}{|a - b|} \\&amp;\leq \frac{\max(|\Delta a|, |\Delta b|) (|a| + |b|)}{|a - b|}\end{aligned}                                  ​            x  =  a  −  b ;        x    ^  =        a    ^  −        b    ^           a    ^  =  a ( 1  +  Δ a )           b    ^  =  b ( 1  +  Δ b )               ∣    ∣    ∣    ∣    ∣ ​             x       x  −        x    ^ ​             ∣    ∣    ∣    ∣    ∣ ​         =           ∣    ∣    ∣    ∣    ∣ ​             a  −  b       − a Δ a  −  b Δ b ​             ∣    ∣    ∣    ∣    ∣ ​         =           ∣ a  −  b ∣       ∣  −  a Δ a  −  b Δ b ∣ ​          =           ∣ a  −  b ∣       ∣ a Δ a  +  b Δ b ∣ ​          ≤           ∣ a  −  b ∣       max ( ∣ Δ a ∣ ,  ∣ Δ b ∣ ) ( ∣ a ∣  +  ∣ b ∣ ) ​     ​</p><p> 也就是说，减去彼此接近的值（在这种情况下，11 1和x x x）将误差顺序转换为值级。或者，它将较早的错误带入诸如价值的景点。我们可以考虑减法：x = a  -  b; x ^ = a ^  -  b ^ a ^ = a（1 +δa）b ^ = b（1 +δb）| x-x ^ x | = |  -  aδa-bδba-b | = | -  Aδa-bδb| A-B | = |δa+bδb|  -  b |≤Max⁡（|δa|，|δb|）（| a | + | b |）| A  -  B | \ Begin {对齐}＆amp; x = a  -  b; \帽子x = \帽子a  -  \ hat b \\＆amp; \ hat a = a（1 + \ delta a）\\＆at att b = b（1 + \ delta b）\\＆amp;左| \ frac {x  -  \ hat x} {x} \右| \\＆amp; = \左手| \ frac {-a \ delta a  -  b \ delta b} {a  -  b} \右| \\＆amp; = \ frac {| -a \ delta a  -  b \ delta b |} {| a  -  b |} \\＆amp; = \ frac {| a \ delta a + b \ delta b |}}} { a  -  b |} \\＆amp; \＆leq \ frac {\ max（| \ delta a |，| \ delta b |）（| a | + | b |）} {| a  -  b |} \ end {对齐} x = a  -  b;的x ^ = a ^  -  B ^一个^ =（1 +ΔA）B ^ = B（1 +ΔB）| | | | | XX  - 的x ^ | | | | | = | | | | | A  -  B  -  aδa-bδb| | | | = | a  -  b | |  -  aδa-bδb|α -  b | aδa+bδ B |≤| A  -  B | MAX（|δa|，|δb|）（| A | + | B |）</p><p> This quantity will be large when        ∣ a − b ∣ ≪ ∣ a ∣ + ∣ b ∣ |a - b| \ll |a| + |b|    ∣ a  −    b ∣  ≪    ∣ a ∣  +    ∣ b ∣: that is, when there is heavy cancellation in the subtraction to compute        x x    x.   # include  &lt;cmath&gt;  # include  &lt;stdio.h&gt; int  main ( )  {  double x  =  1000 ;  for ( int i  =  0 ; i  &lt;  60 ;  ++i )  { x  =  sqrt (x ) ;  }  for ( int i  =  0 ; i  &lt;  60 ;  ++i )  { x  = x *x ;  }  printf ( &#34;x: %10.20f\n&#34; , x ) ; }</p><p> 当| A  -  B |«| A | + | B | | A  -  B | \ ll | A | + | B | | A  -  B |«| A | + | B |：即，当减法中有很重的消除时计算x x x。 ＃包括＆lt; cmath＆gt; ＃包括＆lt; stdio.h＆gt; int main（）{double x = 1000; for（int i = 0; i＆lt; 60; ++ i）{x = sqrt（x）; for（int i = 0; i＆lt; 60; ++ i）{x = x * x; printf（＆＃34; x：％10.20f \ n＆＃34;，x）; } </p><p> This produces the output:  That is, even though the function is an identity function, the answer collapses to  1. What is happening?  One way to evaluate this function is as follows: double  f ( double x )  {  return x  ==  0  ?  1  :  ( pow (M_E , x )  -  1 )  / x ;  }</p><p>这会产生输出：即使功能是身份函数，答案崩溃为1.发生了什么？评估此功能的一种方法如下：双F（双x）{返回x == 0？ 1 :( Pow（M_E，x） -  1）/ x; }</p><p> This can suffer from catastrophic cancellation in the numerator. When        x x    x is close to        0 0    0,         e x e^x     e        x is close to 1, and         e x − 1 e^x - 1     e        x  −    1 will magnify the error in         e x e^x     e        x. double  f ( double x )  {  const  double y  =  pow (M_E , x ) ;  return y  ==  1  ?  1  :  (y  -  1 )  /  log (y ) ; }</p><p> 这可能在分子中遭受灾难性的消除。当x x x接近0 0时，e x e ^ x e x接近1，而e x  -  1 e ^ x  -  1 e x-1将在e x e ^ x e x中放大错误。双f（双x）{const double y = pow（m_e，x）;返回y == 1？ 1 :( y  -  1）/ log（y）; }</p><p> This algorithm seems crazy, but there&#39;s insight in it. We can show that the errors cancel! The idea is that neither        ( y − 1 ) (y - 1)    ( y  −    1 ) nor        log ⁡ y \log y    lo g  y are particularly good, the errors accumulated in them almost completely cancel out, leaving out a good value: assume    y ^ = 1  1 =  y ^ ≡  e x ( 1 + δ )  log ⁡ 1 = log ⁡ (  e x ) + log ⁡ ( 1 + δ )  x = − log ⁡ ( 1 + δ )  x = − δ + O (  δ 2 ) \text{assume $\hat y = 1$} \\1 = \hat y \equiv e^x(1 + \delta) \\\log 1 = \log (e^x ) + \log(1 + \delta) \\x = -\log(1 + \delta) \\x = -\delta + O(\delta^2)     assume        y    ^ ​     =  1    1  =          y    ^ ​     ≡     e        x ( 1  +    δ )    lo g  1  =    lo g (  e        x )  +    lo g ( 1  +    δ )    x  =    −  lo g ( 1  +    δ )    x  =    − δ  +    O (  δ        2 )</p><p> 这种算法似乎疯狂，但它的见解＆＃39;我们可以证明错误取消！这个想法是（y-1）（y  -  1）（y  -  1）也不是log⁡y\ log y lo gy特别好，在它们中累积的误差几乎完全抵消，留出了很好的价值：假设y ^ = 1 1 = y ^≡ex（1 +δ）log⁡1= log⁡（ex）+ log⁡（1 +δ）x =  -  log⁡（1 +Δ）x =  - δ+ o（δ 2）\文本{假设$ \ hat y = 1 $} \\ 1 = \ hat y \ Equiv E ^ x（1 + \ delta）\\\ log 1 = log（e ^ x）+ \ log（1 + \ delta）\\ x =  -  \ log（1 + \ delta）\\ x =  -  \ delta + o（\ delta ^ 2）假设y ^ = 1 1 = y ^ ex（1 +Δ） lo g 1 = lo g（ex）+ lo g（1 +δ）x =  -  lo g（1 +δ）x =  - δ+ o（δ2）</p><p> If         y ^ ≠ 1 \hat y \neq 1          y    ^ ​              =    1: f ^ = (  y ^ − 1 ) / log ⁡  y ^ = ( 1 +  ϵ 3 ) (  y ^ − 1 ) ( 1 + ϵ + 1 ) / ( log ⁡  y ^ ( 1 +  ϵ 2 ) ) \hat f = (\hat y - 1)/\log{\hat y} = (1+\epsilon_3)(\hat y - 1)(1 + \epsilon+1)/(\log \hat y(1 + \epsilon_2))          f    ^ ​     =    (       y    ^ ​     −    1 ) /  lo g         y    ^ ​     =    ( 1  +     ϵ        3 ​    ) (       y    ^ ​     −    1 ) ( 1  +    ϵ  +    1 ) / ( lo g        y    ^ ​    ( 1  +     ϵ        2 ​    ) )</p><p> 如果Y ^≠1\ hat y \ neq 1 y ^= 1：f ^ =（y ^  -  1）/ log⁡y^ =（1 +ε3）（y ^  -  1）（1 +ε+ 1）/（日志⁡y ^（1 +ε2））\ hat f =（\ hat y-1）/ \ log {\ hat y} =（1+ \ epsilon_3）（\ hat y-1）（1 + \ epsilon + 1）/（\ log \ hat y（1 + \ epsilon_2））f ^ =（y ^  -  1）/ lo gy ^ =（1 +ε3）（y ^  -  1 ）（1 +ε+ 1）/（lo gy ^（1 +ε2））</p><p>  Rather than think of  +0 and  -0 as distinct numerical values, think of  their sign bit as an auxiliary variable that conveys one bit of information  (or misinformation) about any numerical variable that takes on 0 as its  value.</p><p>  而不是将+0和-0作为不同的数值，而不是将其符号位视为辅助变量，该辅助变量传达了一个关于任何按0作为其值的数字变量的信息（或错误信息）。</p><p> We have two types of zeroes,  +0 and  -0 in IEEE-754. These are used in some cases. The most famous is that        1 / + 0 = + ∞ 1/+0 = +\infty    1 /  +    0  =    + ∞, while        1 / − 0 = − ∞ 1/-0 = -\infty    1 /  −    0  =    − ∞. Here, we proceed to discuss some complex-analytic considerations. Therefore. implementers of compilers  and run-time libraries bear a heavy burden of attention to detail  if applications programmers are to realize the full benefit of the  IEEE style of complex arithmetic. That benefit deserves Some  discussion here if only to reassure implementers that their  assiduity will be appreciated.</p><p> 我们在IEEE-754中有两种类型的零，+0和-0。这些在某些情况下使用。最着名的是1 / + 0 = +∞1/ + 0 = +秒1 / + 0 = +，而1 /  -  0 =  - ∞1/ -0 =  -  \ infty 1 /  -  0 =  - ∞。在这里，我们继续讨论一些复杂的分析考虑因素。所以。如果应用程序员要实现复杂算法的IEEE风格的充分利益，则编译器和运行时库的实施者承担了沉重的关注。如果只是为了向实施者保证他们的惯用，那么这种福利应该在这里讨论。</p><p> − 1 + 0 i = + 0 + i    − 1 − 0 i = + 0 − i  \sqrt{-1 + 0 i} = +0 + i \\\sqrt{-1 - 0 i} = +0 - i \\           − 1  +  0 i      ​     =    + 0  +    i           − 1  −  0 i      ​     =    + 0  −    i</p><p>  -  1 + 0 i = + 0 + i  -  1  -  0 i = + 0  -  i \ sqrt {-1 + 0 i} = +0 + i \\\ sqrt {-1  -  0 i} = +0  -  i \\  -  1 + 0 i = + 0 + i  -  1  -  0 i = + 0  -  i </p><p> These will ensure that          z ∗ = (  z ) ∗ \sqrt{z*} = (\sqrt{z})*           z ∗      ​     =    (        z      ​    ) ∗: copysign ( 1 , + 0 ) = + 1  copysign ( 1 , − 0 ) = − 1  \texttt{copysign}(1, +0) = +1 \\\texttt{copysign}(1, -0) = -1 \\     copysign ( 1 ,  + 0 )  =    + 1     copysign ( 1 ,  − 0 )  =    − 1</p><p>这些将确保z * =（z）* \ sqrt {z *} =（\ sqrt {z}）* z * =（z）*：copysign（1，+ 0）= + 1 copysign（1， -  0）=  -  1 \ texttt {copysign}（1，+0）= +1 \\\ texttt {copysign}（1，-0）= -1 \\ copysign（1，+ 0）= + 1 copySign（ 1， -  0）=  -  1</p><p> These will ensure that        copysign ( x , 1 / x ) = x \texttt{copysign}(x, 1/x) = x     copysign ( x ,  1 / x )  =    x when        x = ± ∞ x = \pm \infty    x  =    ± ∞. An example is provided where the two limits: f ( x + i 0 ) =   lim ⁡  y → 0 − f ( x + i y )         f ( x + i 0 ) =   lim ⁡  y → 0 − f ( x + i y ) \begin{aligned}&amp;f(x + i0) = \lim_{y \rightarrow 0-} f(x + i y) \\&amp;f(x + i0) = \lim_{y \rightarrow 0-} f(x + i y) \\\end{aligned}                ​            f ( x  +  i 0 )  =          y → 0 −    lim ​     f ( x  +  i y )     f ( x  +  i 0 )  =          y → 0 −    lim ​     f ( x  +  i y ) ​</p><p> 这些将确保CopySign（x，1 / x）= x \ texttt {copysign}（x，1 / x）= x copysign（x，1 / x）= x x =±x = \ pm \ infty x =±∞。提供了一个例子，其中两个限制：f（x + i 0）= lim≠y→0  -  f（x + iy）f（x + i 0）= lim y→0  -  f（x + iy）\开始{对齐}＆amp; f（x + i0）= \ lim_ {y \ lightarrow 0-} f（x + iy）\\＆amp; f（x + i0）= \ lim_ {y \ lightarrow 0-} f（ x + iy）\\\结束{对齐} f（x + i 0）= y→0  -  lim f（x + iy）f（x + i 0）= y→0  -  lim f（x + IY）</p><p>  The principal branch of a complex function is a way to select one branch of a complex-function, which tends to be multi-valued. A classical example is the argument function, where        arg ⁡ ( r  e  i θ = θ \arg(r e^{i \theta} = \theta    ar g ( r  e         i θ  =    θ.  However, this is ambiguous: we can map        θ ↦ θ + 2 π \theta \mapsto \theta + 2 \pi    θ  ↦    θ  +    2 π and still have the same complex number. So, we need to fix some standard. We usually pick the &#34;branch&#34; where        0 ≤ θ &lt; 2 π 0 \leq \theta &lt; 2 \pi    0  ≤    θ  &lt;    2 π. In general, we need to carefully handle what happens to the function at the discontinuity. What deserves to be undermined is blind faith in the power of Algebra. We  should not believe that the equivalence class of expressions that all  describe the same complex analytic function can be recognized by algebraic  means alone, not even if relatively uncomplicated expressions are the only  ones considered.</p><p>  复杂函数的主要分支是选择复杂功能的一个分支的方法，这往往是多值的。古典示例是参数函数，其中arg⁡（Reiθ=θ\ arg（re ^ {i \ theta} = \ theta ar g（Reiθ=θ。但是，这是模糊的：我们可以映射θ↦θ+ 2π\ theta \ mapsto \ theta + 2 \piθ↦θ+2π且仍然具有相同的复数。所以，我们需要修复一些标准。我们通常选择＆＃34;分支＆＃34;其中0≤ θ＆lt;2π0\ leq \ theta＆lt; 2 \ pi0≤θ<θ<θ＆lt; 2.一般来说，我们需要仔细处理不连续功能的功能发生的事情。值得被破坏的是盲目的信仰代数的力量。我们不应该相信所有描述相同复杂的分析功能的等效表达式可以单独识别代数手段，即使相对简单的表达式也是唯一考虑的表达式。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://bollu.github.io/a-hackers-guide-to-numerical-analysis.html">http://bollu.github.io/a-hackers-guide-to-numerical-analysis.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/黑客/">#黑客</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数值/">#数值</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guide/">#guide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/theta/">#theta</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>