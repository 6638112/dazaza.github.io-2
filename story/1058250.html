<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>继续传递风格代码表现良好吗？ </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">继续传递风格代码表现良好吗？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 09:40:48</div><div class="page_narrow text-break page_content"><p>延续传递风格是一种强大的技术，允许您摘要在您的程序中进行控制流程。这是一个简单的例子：我们想在一个表中看起来，但有时我们使用的键与任何值都没有。在这种情况下，我们必须做一些不同的事情，但查找代码没有知道来电者想要做什么，并且呼叫者没有知道查找代码如何工作。通常，我们将安排查找代码来返回一个特殊的“未找到键”的值:(让（（答案（查询键表））））（如果（eq答案＆＃39;键 - 未找到）...处理缺少钥匙......计算答案的东西......）</p><p> 这种方法有两个小问题。首先，“未找到键”值必须在查找返回的类型中。考虑一个只能包含整数的表。不幸的是，我们不能声明回答是一个整数，因为它可能是“未找到键”的值。或者，我们可能决定保留一个特殊的整数来指示“未找到键”。然后可以将答案声明为整数，但现在现在无法存储在表中的魔法整数。无论哪种方式，答案都是可以存储在表中的超级类型，我们必须通过将其测试到“未找到的键”来将其投影回来。</p><p> 第二个问题是冗余之一。据推测，查找代码中的某个地方有一个条件的凯恩和＃39;要找到。我们采取分支并返回“未找到的键”值。但是现在来电者测试返回值对“未找到的键”，它也占用分支。如果在Callee拍摄真正的分支，我们只会在呼叫者中占据真正的分支，如果在Callee中拍摄了假分支，我们只会在呼叫者中拍摄错误分支。从本质上讲，我们正在两次支付完全相同的条件。我们＆＃39; ve Reedized控制流程，将requed值注入可能的返回值的空间，通过函数调用边界，然后投影并将值反映回呼叫站点的控制流程。</p><p> 如果我们在延续传递风格中写下这一点，呼叫看起来像这样（Lookup Key表（答案）...计算带有答案的东西......）（lambda（）...处理缺少键...））</p><p> 如果找到，请在答案上调用第一个lambda表达式，但如果答案未排出，则会调用第二个lambda表达式。我们不再有一个特殊的“键找不到”的价值，所以答案可以完全是存储在表中的类型，我们不必保留魔法价值。呼叫者也没有冗余条件测试。</p><p> 这很酷，但有成本。首先是它需要练习来读取继续传递风格代码。我想它需要练习来阅读任何代码，但有些语言使其在兰姆达表达式周围传递额外繁琐。 （有些人似乎积极敌对这个想法。）它＆＃39;直接风格会在持续的情况下更加模糊。</p><p> 第二个成本是性能和效率之一。您传递到延续传递风格计划的Lambda表达式将必须在呼叫者和＃39;环境中关闭，这可能意味着存储分配。当Callee调用其中一个持续存在时，它必须执行函数调用。最后，延续中的词汇范围变量必须从关闭和＃39;环境中获取。直接样式表现更好，因为它避免了所有词汇封闭机​​械，并且可以在本地堆栈帧中保持变量。由于这些原因，如果需要执行，您可能会在继续传递风格中编写代码的保留。 </p><p>延续传递风格看起来很复杂，但你不需要一个足够的Smart™编译器来从中生成有效的代码。这里的查找编码为说明:( defun查找（键表If-notel-not-pound of-not-pound）（（扫描 - 条目（条目）（cond（（null条目）（funcall If-not-found））（ （eq（caar条目）键）（Funcall If-powd（CDAR条目））））（t（扫描 - 条目（CDR条目）））））））（扫描 - 条目表）））</p><p>和样本使用可能是（Defun探测器（东西）（查找物*特殊表*（lambda（价值）（格式t＆＃34;〜s＆＃34;东西值）（lambda（ ）（格式t＆＃34;〜s不特殊。＆＃34;东西）））</p><p> 通常，探测器必须将两个闭包分配以进入查找，并且每个封闭件中的代码将从封闭件中重新排出键的词汇值。 uTWithout改变查找或探测Wecan（DecrimaIm（Inline Lookup））。显然，内联的Thecall将消除函数调用的开销，但观察Whathappens到闭包:( defun探测器（东西）（（lambda（lambda（key表If-notel-not-power）（（扫描 - 条目（表）（扫描 - 条目（表）（表）（cond（（null条目）（funcall If-not-pound））（（eq（caar条目）键）（funcall if-powal（cdar条目）））（t（扫描 - 条目（CDR条目））））） ））（扫描 - 条目表）））的东西*特殊表*（lambda（价值）（格式t＆＃34; s映射到〜s。＆＃34;东西值））（lambda（）（格式t ＆＃34;〜s没有映射。＆＃34;东西））））</p><p>一个decentcompiler™将很容易注意到关键是一个别名的东西，那表是*特殊表*的别名，所以我们得到:( defun探测器（东西）（（lambda（lambda（lambda）（标签（（扫描 - 条目（条目）（cond（（null条目）（funcall If-not-pound））（（eq（caar条目）的东西）（funcall if-power（cdar条目）））（t（t（扫描 - 条目（CDR条目））））））（扫描 - 条目*特殊表*）））（lambda（值）（格式t＆＃34;〜s映射到〜s。＆＃34;东西值））（ lambda（）（格式t＆＃34;〜s没有映射。＆＃34;东西）））</p><p>和if-notel的表单和if-not-foundare副作用，所以它们可以被联合（并且我们预计thecompiler要正确避免意外的变量捕获）:( defun探测器（东西）（（lambda（）（labda（）（扫描 - 条目（条目）（COND（（null条目）（funcall（lambda（）（格式t＆＃34;〜s没有映射。＆＃34;东西）））（（eq（caar条目）的东西） （Funcall（Lambda（价值）（格式t＆＃34;〜s映射到〜s。＆＃34;东西值））（cdar条目）））（t（扫描 - 条目（CDR条目）））））））） （扫描 - 条目*特殊表*））））））</p><p>并且可以删除立即呼叫容托利替兰州lambdas :( defun探测器（东西）（标签（（扫描 - 条目）（cond（null条目）（formatt t＆＃34;〜s没有映射。东西）（（eq（caar条目）的东西）（格式t＆＃34;〜s地图到〜s。＆＃34;事物（cdar值））））（t（扫描 - 条目（CDR条目））） ）））（扫描 - 条目*特殊表*））））</p><p> 我们的体面编译器™已删除所有词汇封闭机​​械，并将持续呼叫转换为直接代码。此代码具有我们所希望的所有功能：没有特殊的“键未找到”值搞定我们的类型，没有冗余分支：（空条目）测试直接分支到相应的处理代码中，我们不分配闭包而且已经关闭的变量现在在帧中直接显而易见。 </p><p>它＆＃39;有点空虚，观察着环中的功能更好。 当然它确实如此。 至少你避免了过程调用。 但是，如果您内联延续的传递风格函数，则任何体面的编译器™都会前往城镇并优化延续开销。 它＆＃39;一个意想不到的奖金。  有时，我发现继续传递风格只是某些代码的抽象，这也是关键的性能。 我不给它一个第二思想。 如果您只需输入关键呼叫，则继续传递风格可能导致高性能代码。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://funcall.blogspot.com/2021/04/can-continuation-passing-style-code.html">http://funcall.blogspot.com/2021/04/can-continuation-passing-style-code.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/传递/">#传递</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/passing/">#passing</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1058175.html"><img src="http://img2.diglog.com/img/2021/4/thumb_e65a082ab00d21475ad725c511ff85bb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1058175.html">在写入一行代码之前，可以学习5产品课程 </a></div><span class="my_story_list_date">2021-4-14 3:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1058058.html"><img src="http://img2.diglog.com/img/2021/4/thumb_dbb91b4aba1ec44b7bbdd6fa72e82979.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1058058.html">Zoho推出了新的低代码工作流自动化产品 </a></div><span class="my_story_list_date">2021-4-13 21:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1057991.html"><img src="http://img2.diglog.com/img/2021/4/thumb_e0445c03735d15e69f43bb319e11ccf1.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057991.html">如何管理一个没有真正的devs试图写代码的军队？ </a></div><span class="my_story_list_date">2021-4-13 13:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1057873.html"><img src="http://img2.diglog.com/img/2021/4/thumb_110f474a6880a6c81ad50551076b94fc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057873.html">AWS发布叉子弹星搜索代码。 宣布新名称：OpenSearch </a></div><span class="my_story_list_date">2021-4-13 1:12</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>