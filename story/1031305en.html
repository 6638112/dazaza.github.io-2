<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Apache Helix-接近实时的rsync复制文件系统</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Apache Helix-接近实时的rsync复制文件系统</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 02:41:21</div><div class="page_narrow text-break page_content"><p>Files written to the master are replicated to the slaves automatically. In this demo, a.txt and b.txt are written to  /tmp/localhost_12001/filestore and they get replicated to other folders.</p><p>写入主服务器的文件会自动复制到从服务器。在本演示中，.txt和b.txt被写入/tmp/localhost_12001/filestore，并被复制到其他文件夹。</p><p>    The other slave  localhost_12003 stops replicating from  localhost_12001 and starts replicating from new master  localhost_12002</p><p>另一个从主机localhost_12003停止从localhost_12001复制，并开始从新的主主机localhost_12002复制。</p><p>    In the end state of this quick demo,  localhost_12002 is the master and  localhost_12003 is the slave. Manually create files under  /tmp/localhost_12002/filestore and see that appear in  /tmp/localhost_12003/filestore</p><p>在这个快速演示的结束状态中，LOCALHOST_12002是主设备，LOCALHOST_12003是从设备。手动在/tmp/localhost_12002/filestore下创建文件，并查看显示在/tmp/localhost_12003/filestore中的文件。</p><p>  There are many applications that require storage for storing large number of relatively small data files. Examples include media stores to store small videos, images, mail attachments etc. Each of these objects is typically kilobytes, often no larger than a few megabytes. An additional distinguishing feature of these use cases is that files are typically only added or deleted, rarely updated. When there are updates, they do not have any concurrency requirements.</p><p>有许多应用需要存储来存储大量相对较小的数据文件。示例包括用于存储小视频、图像、邮件附件等的媒体存储。这些对象中的每一个通常都是千字节，通常不大于几兆字节。这些用例的另一个显著特点是通常只添加或删除文件，很少更新。当有更新时，它们没有任何并发要求。</p><p>  These are much simpler requirements than what general purpose distributed file system have to satisfy; these would include concurrent access to files, random access for reads and updates, posix compliance, and others. To satisfy those requirements, general DFSs are also pretty complex that are expensive to build and maintain.</p><p>与通用分布式文件系统必须满足的要求相比，这些要求要简单得多；这些要求将包括对文件的并发访问、读取和更新的随机访问、POSIX遵从性等。为了满足这些需求，一般的DFS也相当复杂，构建和维护成本很高。</p><p>  A different implementation of a distributed file system includes HDFS which is inspired by Google’s GFS. This is one of the most widely used distributed file system that forms the main data storage platform for Hadoop. HDFS is primary aimed at processing very large data sets and distributes files across a cluster of commodity servers by splitting up files in fixed size chunks. HDFS is not particularly well suited for storing a very large number of relatively tiny files.</p><p>分布式文件系统的另一种实现包括HDFS，它的灵感来自Google的GFS。这是使用最广泛的分布式文件系统之一，它构成了Hadoop的主要数据存储平台。HDFS的主要目标是处理非常大的数据集，并通过将文件拆分成固定大小的块来跨商用服务器群集分发文件。HDFS不是特别适合存储大量相对较小的文件。</p><p>  It’s possible to build a vastly simpler system for the class of applications that have simpler requirements as we have pointed out.</p><p>正如我们已经指出的，可以为需求更简单的应用程序类构建一个非常简单的系统。</p><p>  No updates to files that are already created (or it’s feasible to delete the old file and create a new one)</p><p>不更新已创建的文件(或者删除旧文件并创建新文件是可行的)</p><p>  We call this system a Partitioned File Store (PFS) to distinguish it from other distributed file systems. This system needs to provide the following features:</p><p>我们称此系统为分区文件存储(PFS)，以区别于其他分布式文件系统。该系统需要提供以下功能：</p><p>  Scalability: Files should be distributed across a large number of commodity servers based on the storage requirement</p><p>可扩展性：应根据存储要求将文件分布在大量商用服务器上。</p><p>  Fault-tolerance: Each file should be replicated on multiple servers so that individual server failures do not reduce availability</p><p>容错：每个文件都应该在多个服务器上复制，这样单个服务器故障就不会降低可用性。</p><p>  Apache Helix is a generic cluster management framework that makes it very easy to provide scalability, fault-tolerance and elasticity features. rsync can be easily used as a replication channel between servers so that each file gets replicated on multiple servers.</p><p>Apache Helix是一个通用的集群管理框架，可以非常轻松地提供可伸缩性、容错和弹性特性。Rsync可以很容易地用作服务器之间的复制通道，以便在多个服务器上复制每个文件。</p><p>  For redundancy, we need to have additional replicas called slave. Slaves can optionally serve reads</p><p>为了实现冗余，我们需要额外的副本，称为从副本。从属设备可以选择性地提供读取服务。</p><p>  Every write on the master will result in creation/deletion of one or more files. In order to maintain timeline consistency slaves need to apply the changes in the same order To facilitate this, the master logs each transaction in a file and each transaction is associated with an 64 bit ID in which the 32 LSB represents a sequence number and MSB represents the generation number The sequence number gets incremented on every transaction and the generation is incremented when a new master is elected</p><p>在主服务器上的每一次写入都将导致创建/删除一个或多个文件。为了保持时间线一致性，从设备需要以相同的顺序应用改变以促进这一点，主设备将每个事务记录在文件中，并且每个事务与64位ID相关联，其中32LSB表示序列号，MSB表示世代号。序列号在每个事务上递增，并且当选举新的主设备时，世代递增。</p><p>  Replication is required for slaves to keep up with changes on the master. Every time the slave applies a change it checkpoints the last applied transaction ID. During restarts, this allows the slave to pull changes from the last checkpointed ID. Similar to master, the slave logs each transaction to the transaction logs but instead of generating new transaction ID, it uses the same ID generated by the master.</p><p>从设备需要复制才能跟上主服务器上的更改。每次从服务器应用更改时，它都会对上次应用的事务处理ID设置检查点。在重新启动期间，这允许从服务器从上一个检查点ID提取更改。与主服务器类似，从服务器将每个事务处理记录到事务处理日志中，但它不会生成新的事务处理ID，而是使用由主服务器生成的相同ID。</p><p>  When a master fails, a new slave will be promoted to master. If the previous master node is reachable, then the new master will flush all the changes from previous the master before taking up mastership. The new master will record the end transaction ID of the current generation and then start a new generation with sequence starting from 1. After this the master will begin accepting writes.</p><p>当主机发生故障时，会将新的从机提升为主机。如果以前的主节点是可访问的，则新的主节点将在接管主节点之前刷新与以前的主节点相比的所有更改。新主机将记录当前一代的结束事务ID，然后以从1开始的顺序开始新一代。之后，主机将开始接受写入。</p><p>  This application demonstrates a file store that uses rsync as the replication mechanism. One can envision a similar system where instead of using rsync, one can implement a custom solution to notify the slave of the changes and also provide an api to pull the change files.</p><p>这个应用程序演示了一个使用rsync作为复制机制的文件存储。可以设想一个类似的系统，在该系统中，不使用rsync，而是可以实现一个自定义解决方案来通知从设备更改，还可以提供一个API来拉取更改文件。</p><p>    File server: This component supports file uploads and downloads and writes the files to  file_store_dir. This is not included in this application. The idea is that most applications have different ways of implementing this component and have some associated business logic. It is not hard to come up with such a component if needed.</p><p>文件服务器：该组件支持文件上传和下载，并将文件写入file_store_dir。这不包括在此应用程序中。其想法是，大多数应用程序都有不同的实现此组件的方式，并且有一些相关的业务逻辑。如果需要，想出这样一个组件并不难。</p><p>  File store watcher: This component watches the  file_store_dir directory on the local file system for any changes and notifies the registered listeners of the changes</p><p>文件存储监视器：此组件监视本地文件系统上的file_store_dir目录是否有任何更改，并将更改通知注册的侦听器。</p><p>  Change log generator: This registers as a listener of the file store watcher and on each notification logs the changes into a file under  change_log_dir</p><p>更改日志生成器：它注册为文件存储监视器的侦听器，并在每次通知时将更改记录到change_log_dir下的一个文件中。</p><p>  Cluster state observer: Slave observes the cluster state and is able to know who is the current master</p><p>集群状态观察器：从站观察集群状态，能够知道谁是当前的主站。</p><p>  Replicator: This has two subcomponents  Periodic rsync of change log: This is a background process that periodically rsyncs the  change_log_dir of the master to its local directory</p><p>Replicator：这有两个子组件：更改日志的定期rsync：这是定期将主服务器的change_log_dir重新同步到其本地目录的后台进程。</p><p>  Change Log Watcher: This watches the  change_log_dir for changes and notifies the registered listeners of the change</p><p>Change Log Watcher：它监视change_log_dir中的更改，并将更改通知注册的监听器。</p><p>  On demand rsync invoker: This is registered as a listener to change log watcher and on every change invokes rsync to sync only the changed file</p><p>随需应变rsync调用器：它注册为更改日志观察器的侦听器，并且在每次更改时调用rsync仅同步更改的文件</p><p>  The coordination between nodes is done by Helix. Helix does the partition management and assigns the partition to multiple nodes based on the replication factor. It elects one the nodes as master and designates others as slaves. It provides notifications to each node in the form of state transitions (Offline to Slave, Slave to Master). It also provides notifications when there is change is cluster state. This allows the slave to stop replicating from current master and start replicating from new master.</p><p>节点之间的协调由Helix完成。Helix执行分区管理，并根据复制因子将分区分配给多个节点。它选举一个节点为主节点，并指定其他节点为从节点。它以状态转换(离线到从、从到主)的形式向每个节点提供通知。它还会在群集状态发生更改时提供通知。这允许从主机停止从当前主机复制，而从新主机开始复制。</p><p>  In this application, we have only one partition but its very easy to extend it to support multiple partitions. By partitioning the file store, one can add new nodes and Helix will automatically re-distribute partitions among the nodes. To summarize, Helix provides partition management, fault tolerance and facilitates automated cluster expansion.</p><p>在这个应用程序中，我们只有一个分区，但是很容易将其扩展为支持多个分区。通过对文件存储进行分区，用户可以添加新节点，并且Helix将自动在节点之间重新分配分区。综上所述，Helix提供分区管理、容错和促进自动集群扩展。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://helix.apache.org/0.6.8-docs/recipes/rsync_replicated_file_store.html">https://helix.apache.org/0.6.8-docs/recipes/rsync_replicated_file_store.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/helix/">#helix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>