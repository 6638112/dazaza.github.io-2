<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>胶印分页有什么好处？ 设计基于游标的并行Web API What's good about offset pagination; designing parallel cursor-based web APIs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What's good about offset pagination; designing parallel cursor-based web APIs<br/>胶印分页有什么好处？ 设计基于游标的并行Web API </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-04 10:53:57</div><div class="page_narrow text-break page_content"><p>I was recently writing  a little program to back up the data I’ve put into various social platforms over the years   1. While doing Goodreads, I was reminded that its API is a bit of an oddity because it uses offsets for pagination   2, something that’s understood  to be bad practice by today’s standards. Although convenient to use, offsets are difficult to keep performant in the backend, and have the major undesirable property that any items which are inserted or removed shift the entire result set over across all subsequent pages. Goodreads’ API has been around for a long time, and presumably it uses offsets by virtue of that fact alone, as many of its contemporary APIs did.</p><p>最近，我正在编写一个小程序来备份多年来在各种社交平台中存储的数据。在进行Goodreads时，我想起了它的API有点奇怪，因为它使用了分页2的偏移量从今天的标准来看，这被认为是不好的做法。尽管使用方便，但偏移量很难在后端保持高性能，并且具有主要的不良特性，即插入或删除的任何项目都将整个结果集移到所有后续页面上。 Goodreads的API已有很长的历史了，大概是因为它的事实，就像许多现代API一样，仅凭此事实就使用了偏移量。</p><p> Initially, my program did what it was supposed to do, and naively iterated pages one by one. It fetched page one, then two, then three, and kept going until finding one with an empty set of results. This worked fine, but one of the Goodreads API’s other quirks is that it is  slow. API calls took so long that my program took 35 seconds to iterate just a few hundred objects.</p><p> 最初，我的程序执行了应做的工作，然后天真地一页一页地迭代页面。它先获取第一页，然后获取第二页，然后获取第三页，并继续进行直到找到包含空结果的页面。这种方法效果很好，但是Goodreads API的其他怪癖之一是它运行缓慢。 API调用花费了很长时间，以至于我的程序只花了35秒来迭代几百个对象。</p><p> Luckily, offset pagination does have one very distinct advantage – dead easy parallelizability. Cursor-based pagination is difficult for a client to parallelize because it can’t know what cursor to send for the next page until it’s received the previous one. The API will send back a list of results along with a cursor that specifies where to go next, like “here’s some results, now get the next page at  /objects?starting_after=tok_123”. Not so with offset pagination, where I can not only ask for page 1, but pages 2, 3, and 4 all at the same time.</p><p> 幸运的是，胶印分页确实具有一个非常明显的优势-完全易于并行化。基于光标的分页对于客户端来说很难并行化，因为在接收到上一页之前，它不知道要发送下一页的光标。该API会发回结果列表以及指定下一步操作的游标，例如“这里有一些结果，现在在/ objects？starting_after = tok_123下一页”。胶印分页并不是这样，在这里我不仅可以同时请求第1页，还可以同时请求第2、3和4页。</p><p> I refactored my program to use a simple divide and conquer strategy. Choose a number of consumers, break the page space into equal parts, and have each consumer advance along the pages in its chunk:</p><p> 我将程序重构为使用简单的分而治之的策略。选择多个使用者，将页面空间分成相等的部分，然后让每个使用者沿着其块中的页面前进：</p><p> const numSegments = 6var mutex sync.RWMutexvar readings []*Readingvar wg sync.WaitGroupwg.Add(numSegments)for i := 1; i &lt;= numSegments; i++ { segmentNum := i go func() { page := segmentNum for { pageReadings, err := fetchGoodreadsPage(&amp;conf, client, page) if err != nil { ... } if len(apiReviews) &lt; 1 { break } mutex.Lock() readings = append(readings, pageReadings...) mutex.Unlock() page += numSegments } wg.Done() }()}wg.Wait()</p><p> const numSegments = 6var互斥量同步。RWMutexvar读数[] * Readingvar wg sync.WaitGroupwg.Add（numSegments）for i：= 1;我＆lt; = numSegments; i ++ {segmentNum：= i go func（）{page：= segmentNum for {pageReadings，err：= fetchGoodreadsPage（＆amp; conf，client，page）if err！= nil {...}如果len（apiReviews）＆lt; 1 {break} Mutex.Lock（）读数= append（readings，pageReadings ...）Mutex.Unlock（）页面+ = numSegments} wg.Done（）}（）} wg.Wait（）</p><p> The reduction in runtime was textbook perfect. With six consumers, the program went from 35 seconds to run down to 6. Wow, offset pagination sure is great. Everyone should use it.</p><p> 运行时间的减少非常适合教科书。有了6个使用者，程序从35秒减少到6秒。哇，胶印分页肯定很棒。每个人都应该使用它。</p><p>  But Goodreads is a bit of an aberration here. If all modern APIs use cursor pagination, then offset parallelization doesn’t help us does it?</p><p>  但是Goodreads在这里有点不正常。如果所有现代API都使用游标分页，那么偏移量并行化对我们没有帮助吗？ </p><p> Well, although cursor-based pagination doesn’t parallelize quite as easily as offset, it’s still possible using a similar principle.</p><p>嗯，尽管基于游标的分页并没有像offset那样容易并行化，但是仍然可以使用类似的原理。</p><p> The key is to allow at least one other filter to be specified that would allow users to break up the total search space into parallelizable parts. For example, Stripe’s API allows many list endpoints to filter based on when a resource was created:</p><p> 关键是允许至少指定一个其他过滤器，该过滤器将允许用户将总搜索空间分解为可并行化的部分。例如，Stripe的API允许许多列表终结点根据创建资源的时间进行过滤：</p><p>  Each list endpoint is entirely cursor-based, but clients can divide and conquer by breaking up the total timeline they’re interested in into  N parts for  N consumers, then have each one make list requests with upper and lower time constraints. Each consumer gets a separate cursor, and they paginate happily along their own segment with no duplication.</p><p>  每个列表端点都是完全基于游标的，但是客户可以通过将他们感兴趣的总时间轴分为N个消费者的N个部分来进行分而治之，然后让每个请求列表都具有较高和较低的时间限制。每个使用者都有一个单独的游标，他们愉快地沿自己的细分进行分页，没有重复。</p><p>  This is still efficient to implement on the backend because even with the additional filter, it’s easy to make sure the list can still use an index. Just like with a filter-less cursor, none of the additional offset-related accounting is needed. It’s fast for the client  and fast for the server.</p><p>  在后端实施此方法仍然非常有效，因为即使使用了其他过滤器，也很容易确保列表仍可以使用索引。就像使用无过滤游标一样，不需要其他与​​偏移量有关的记帐。对客户而言，这对服务器来说是最快的。</p><p> It’s worth noting though that using something like a  created timestamp works for this purpose, but it’s not perfectly optimal because it requires consumers to discover the upper and lower time bounds for themselves, and would be challenging to parallelize when objects aren’t distributed uniformly across the timeline. Say you had 100 objects created in 2018, 1,000 in 2019, and a million in 2020. You couldn’t break 2018-2020 into equal chunks and expect the work to parallelize well.</p><p> 值得注意的是，使用诸如创建的时间戳之类的方法可以达到此目的，但这并不是完美的选择，因为它要求消费者发现自己的上下限，并且当对象在各个对象之间分布不均匀时，进行并行化将是一个挑战。时间线。假设您在2018年创建了100个对象，在2019年创建了1000个对象，在2020年创建了100万个对象。您无法将2018-2020年划分成相等的块，并期望工作能够很好地并行化。</p><p> A  really friendly API provider could probably introduce something like a counter specific to each user and object type that increments roughly in line with new objects being created, and allow users to filter on that. Clients could then check the maximum bound, do some simple division based on number of consumers, and go to work.</p><p> 一个真正友好的API提供程序可能会引入诸如针对每个用户和对象类型的计数器之类的计数器，该计数器会随着创建的新对象的增加而大致增加，并允许用户对此进行过滤。然后，客户可以检查最大界限，根据消费者数量进行一些简单划分，然后开始工作。</p><p> 1 Exporting data from Goodreads has become more important of late as they’re planning to  retire API access completely.</p><p> 1最近，从Goodreads导出数据变得越来越重要，因为他们计划完全淘汰API访问。 </p><p> 2 More specifically, it’s actually page based ( ?page=1), but on the backend is the functionally the same as being offset-based.</p><p>2更具体地说，它实际上是基于页面的（？page = 1），但在后端与基于偏移的功能相同。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://brandur.org/fragments/offset-pagination">https://brandur.org/fragments/offset-pagination</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并行/">#并行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/offset/">#offset</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>