<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>奥丁编程语言Odin Programming Language</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Odin Programming Language<br/>奥丁编程语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 16:19:02</div><div class="page_narrow text-break page_content"><p>Odin is a general-purpose programming language with distinct typing built for high performance, modern systems and data-oriented programming.</p><p>Odin是一种通用编程语言，具有独特的类型，专为高性能、现代系统和面向数据的编程而构建。</p><p>  Read the Docs See the Full Demo</p><p>阅读文档，查看完整演示</p><p> package mainimport &#34;core:fmt&#34;main :: proc() {	program := &#34;+ + * 😃 - /&#34;	accumulator := 0	for token in program {		switch token {		case &#39;+&#39;: accumulator += 1		case &#39;-&#39;: accumulator -= 1		case &#39;*&#39;: accumulator *= 2		case &#39;/&#39;: accumulator /= 2		case &#39;😃&#39;: accumulator *= accumulator		case: // Ignore everything else		}	}	fmt.printf(&#34;The program \&#34;%s\&#34; calculates the value %d\n&#34;,	 program, accumulator)}</p><p>包装主要进口和#34；核心：fmt和#34；main:：proc（）{program:=&#34；++*😃 - /&#34;累加器：=0表示程序{switch token{case&#39；+&#39；：累加器+=1 case&#39；-&#39；：累加器-=1 case&#39；*&#39；：累加器*=2 case&#39；/#39；：累加器/=2 case&#39；😃&#39;: 累加器*=累加器case://忽略所有其他内容}fmt。printf（&#34；程序\&#34；%s\&#34；计算值%d\n&#34；，程序，累加器）}</p><p> package mainimport &#34;core:fmt&#34;main :: proc() {	{		a := [3]f32{1, 2, 3}		b := [3]f32{5, 6, 7}		c := a * b		d := a + b		e := 1 + (c - d) / 2		fmt.printf(&#34;%.1f\n&#34;, e) // [0.5, 3.0, 6.5]	}	{		a := [3]f32{1, 2, 3}		b := swizzle(a, 2, 1, 0)		assert(b == [3]f32{3, 2, 1})		c := swizzle(a, 0, 0)		assert(c == [2]f32{1, 1})		assert(c == 1)	}	{		Vector3 :: distinct [3]f32		a := Vector3{1, 2, 3}		b := Vector3{5, 6, 7}		c := (a * b)/2 + 1		d := c.x + c.y + c.z		fmt.printf(&#34;%.1f\n&#34;, d) // 22.0		cross :: proc(a, b: Vector3) -&gt; Vector3 {			i := swizzle(a, 1, 2, 0) * swizzle(b, 2, 0, 1)			j := swizzle(a, 2, 0, 1) * swizzle(b, 1, 2, 0)			return i - j		}		cross_shorter :: proc(a, b: Vector3) -&gt; Vector3 {			i := a.yzx * b.zxy			j := a.zxy * b.yzx			return i - j		}		blah :: proc(a: Vector3) -&gt; f32 {			return a.x + a.y + a.z		}		x := cross(a, b)		fmt.println(x)		fmt.println(blah(x))	}}</p><p>包装主要进口和#34；核心：fmt和#34；main:：proc（）{{a:=[3]f32{1,2,3}b:=[3]f32{5,6,7}c:=a*bd:=a+be:=1+（c-d）/2fmt。[0.5，3.0，6.5]{a:[3]f32{1，2，2，3}b：=3[3]f32{1，2，3}b:[3]b:=Swizz（34；34；34；34；7.3；7.1，1.1，0）1f.[1，1.1，1，1）1f，1f，1f；1f，[1，[0.5，[0.5，3，3.5，3，3，3，3，3.0，3，3，3，3，3，3，3.0，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3，3=（a*b）/2+1 d:=c.x+c.y+c.z fmt。printf（&#34；%.1f\n&#34；，d）//22.0 cross:：proc（a，b:Vector3）->；向量3{i:=swizzle（a，1，2，0）*swizzle（b，2，0，1）j:=swizzle（a，2，0，1）*swizzle（b，1，2，0）返回i-j}cross_shorter:：proc（a，b:Vector3）->；Vector3{i:=a.yzx*b.zxy j:=a.zxy*b.yzx返回i-j}blah:：proc（a:Vector3）->；f32{return a.x+a.y+a.z}x:=cross（a，b）fmt。println（x）fmt。println（blah（x））}</p><p> package mainimport &#34;core:fmt&#34;main :: proc() {	{		Vector3 :: struct {x, y, z: f32}		N :: 2		v_aos: [N]Vector3		v_aos[0].x = 1		v_aos[0].y = 4		v_aos[0].z = 9		fmt.println(len(v_aos))		fmt.println(v_aos[0])		fmt.println(v_aos[0].x)		fmt.println(&amp;v_aos[0].x)		v_aos[1] = {0, 3, 4}		v_aos[1].x = 2		fmt.println(v_aos[1])		fmt.println(v_aos)		v_soa: #soa[N]Vector3		v_soa[0].x = 1		v_soa[0].y = 4		v_soa[0].z = 9		// Same syntax as AOS and treat as if it was an array		fmt.println(len(v_soa))		fmt.println(v_soa[0])		fmt.println(v_soa[0].x)		fmt.println(&amp;v_soa[0].x)		v_soa[1] = {0, 3, 4}		v_soa[1].x = 2		fmt.println(v_soa[1])		// Can use SOA syntax if necessary		v_soa.x[0] = 1		v_soa.y[0] = 4		v_soa.z[0] = 9		fmt.println(v_soa.x[0])		// Same pointer addresses with both syntaxes		assert(&amp;v_soa[0].x == &amp;v_soa.x[0])		// Same fmt printing		fmt.println(v_aos)		fmt.println(v_soa)	}	{		// Works with arrays of length &lt;= 4 which have the implicit fields xyzw/rgba		Vector3 :: distinct [3]f32		N :: 2		v_aos: [N]Vector3		v_aos[0].x = 1		v_aos[0].y = 4		v_aos[0].z = 9		v_soa: #soa[N]Vector3		v_soa[0].x = 1		v_soa[0].y = 4		v_soa[0].z = 9	}	{		// SOA Slices		// Vector3 :: struct {x, y, z: f32}		Vector3 :: struct {x: i8, y: i16, z: f32}		N :: 3		v: #soa[N]Vector3		v[0].x = 1		v[0].y = 4		v[0].z = 9		s: #soa[]Vector3		s = v[:]		assert(len(s) == N)		fmt.println(s)		fmt.println(s[0].x)		a := s[1:2]		assert(len(a) == 1)		fmt.println(a)		d: #soa[dynamic]Vector3		append_soa(&amp;d, Vector3{1, 2, 3}, Vector3{4, 5, 9}, Vector3{-4, -4, 3})		fmt.println(d)		fmt.println(len(d))		fmt.println(cap(d))		fmt.println(d[:])	}	{ // soa_zip and soa_unzip		fmt.println(&#34;\nsoa_zip and soa_unzip&#34;)		x := []i32{1, 3, 9}		y := []f32{2, 4, 16}		z := []b32{true, false, true}		// produce an #soa slice the normal slices passed		s := soa_zip(a=x, b=y, c=z)		// iterate over the #soa slice		for v, i in s {			fmt.println(v, i) // exactly the same as s[i]			// NOTE: &#39;v&#39; is NOT a temporary value but has a specialized addressing mode			// which means that when accessing v.a etc, it does the correct transformation			// internally:			// s[i].a === s.a[i]			fmt.println(v.a, v.b, v.c)		}		// Recover the slices from the #soa slice		a, b, c := soa_unzip(s)		fmt.println(a, b, c)	}}</p><p>包装主要进口和#34；核心：fmt和#34；main:：proc（）{{Vector3:：struct{x，y，z:f32}N:：2v_aos:[N]vector3v_aos[0]。x=1 v_aos[0]。y=4 v_aos[0]。z=9 fmt。println（len（v_aos））fmt。println（v_aos[0]）fmt。println（v_aos[0].x）fmt。println（&amp；v_aos[0].x）v_aos[1]={0,3,4}v_aos[1]。x=2英尺。println（v_aos[1]）fmt。println（v_aos）v_soa:#soa[N]向量3 v_soa[0]。x=1 v_soa[0]。y=4 v_soa[0]。z=9//语法与AOS相同，并将其视为数组fmt。println（len（v_soa））fmt。println（v_soa[0]）fmt。println（v_-soa[0].x）fmt。println（&amp；v_-soa[0].x）v_-soa[1]={0,3,4}v_-soa[1]。x=2英尺。println（v_-soa[1]）//如果需要，可以使用soa语法v_-soa。x[0]=1 v_soa。y[0]=4v_。z[0]=9 fmt。println（v_soa.x[0]）//使用两个语法断言的指针地址相同（&amp；v_soa[0]。x==&amp；v_soa.x[0]）//相同的fmt打印fmt。println（v_aos）fmt。println（v_-soa）}{//使用长度为&lt；=4的数组，这些数组具有隐式字段xyzw/rgba Vector3:：distinct[3]f32 N:：2v_-aos[N]vector3v_-aos[0]。x=1v_-aos[0]。y=4v_-aos[0]。z=9v_-soa:#soa[N]vector3v_-soa[0]。x=1v_-soa[0]。y=4v_-soa[0]。z=9//{x:i8，y:i16，z:f32}N:：3v:#soa[N]向量3v[0]。x=1 v[0]。y=4V[0]。z=9s:#soa[]向量3s=v[：]断言（len=N）fmt。普林顿（s）fmt。println（s[0].x）a:=s[1:2]assert（len（a）==1）fmt。println（a）d:#soa[dynamic]Vector3 append_soa（&amp；d，Vector3{1,2,3}，Vector3{4,5,9}，Vector3{-4，-4,3}）fmt。println（d）fmt。println（len（d））fmt。println（第（d）章）fmt。println（d[：]）}{//soa_-zip和soa_-unzip-fmt.println（&#34；\nsoa_-zip和soa#unzip&#34；）x:[]i32{1,3,9}y:[]f32{2,4,16}z:[]b32{true，false，true}//生成一个#soa切片正常切片经过s:=soa_zip（a=x，b=y，c=z）//在#soa切片上迭代v，s{fmt.println（v，i）//与s[i]完全相同//注意：&#39；v&#39；不是一个临时值，而是有一个专门的寻址模式//这意味着当访问v.a等时，它会在内部执行正确的转换//s[i].a==s.a[i]fmt.println（v.a，v.b，v.c）//从#soa切片a，b，恢复切片，c:=soa_解压fmt。println（a，b，c）}</p><p> package mainmain :: proc() {	// In each scope, there is an implicit value named context. This	// context variable is local to each scope and is implicitly passed	// by pointer to any procedure call in that scope (if the procedure	// has the Odin calling convention).	// The main purpose of the implicit context system is for the ability	// to intercept third-party code and libraries and modify their	// functionality. One such case is modifying how a library allocates	// something or logs something. In C, this was usually achieved with	// the library defining macros which could be overridden so that the	// user could define what he wanted. However, not many libraries	// supported this in many languages by default which meant intercepting	// third-party code to see what it does and to change how it does it is	// not possible.	c := context // copy the current scope&#39;s context	context.user_index = 456	{		context.allocator = my_custom_allocator()		context.user_index = 123		what_a_fool_believes() // the `context` for this scope is implicitly passed to `what_a_fool_believes`	}	// `context` value is local to the scope it is in	assert(context.user_index == 456)	what_a_fool_believes :: proc() {		c := context // this `context` is the same as the parent procedure that it was called from		// From this example, context.user_index == 123		// An context.allocator is assigned to the return value of `my_custom_allocator()`		assert(context.user_index == 123)		// The memory management procedure use the `context.allocator` by		// default unless explicitly specified otherwise		china_grove := new(int)		free(china_grove)		_ = c	}	my_custom_allocator :: mem.nil_allocator	_ = c	// By default, the context value has default values for its parameters which is	// decided in the package runtime. What the defaults are are compiler specific.	// To see what the implicit context value contains, please see the following	// definition in package runtime.}</p><p>package mainmain:：proc（）{//在每个作用域中，都有一个名为context的隐式值。该//上下文变量是每个作用域的本地变量，通过指向该作用域中任何过程调用的指针//隐式传递（如果过程//具有Odin调用约定）.//隐式上下文系统的主要目的是//拦截第三方代码和库并修改其//功能。其中一种情况是修改库分配//内容或记录内容的方式。在C语言中，这通常是通过//库定义宏来实现的，宏可以被重写，以便//用户可以定义他想要的。然而，默认情况下，没有多少库//在许多语言中支持这一点，这意味着拦截//第三方代码以查看它的功能，并改变它的功能//这是不可能的。c:=上下文//复制当前范围&#39；这是上下文。user_index=456{context.allocator=my_custom_allocator（）context.user_index=123_a_fool_相信的内容（）//此范围的` context`隐式传递给` what_fool_相信的内容'}/`context`值是它在断言中的范围的本地值（context.user_index==456）what_fool_相信的内容：：proc（）{c:=context//this`context`与从中调用它的父过程相同//在本例中，context.user_index==123//context.allocator被分配给`my_custom_allocator（）`assert（context.user_index==123）的返回值//内存管理过程使用`上下文。分配器//默认情况下，除非另有明确规定，否则china_grove:=new（int）free（china_grove）\=c}my_custom_分配器：：mem。nil_分配器_u=c//默认情况下，上下文值具有其参数的默认值，该值//在包运行时确定。默认值是特定于编译器的。//要查看隐式上下文值包含的内容，请在包运行时中查看以下//定义。}</p><p> package mainimport &#34;core:fmt&#34;import &#34;core:reflect&#34;main :: proc() {	Foo :: struct {		x: int `tag1`,		y: string `json:&#34;y_field&#34;`,		z: bool, // no tag	}	id := typeid_of(Foo)	names := reflect.struct_field_names(id)	types := reflect.struct_field_types(id)	tags := reflect.struct_field_tags(id)	assert(len(names) == len(types) &amp;&amp; len(names) == len(tags))	fmt.println(&#34;Foo :: struct {&#34;)	for tag, i in tags {		name, type := names[i], types[i]		if tag != &#34;&#34; {			fmt.printf(&#34;\t%s: %T `%s`,\n&#34;, name, type, tag)		} else {			fmt.printf(&#34;\t%s: %T,\n&#34;, name, type)		}	}	fmt.println(&#34;}&#34;)	for tag, i in tags {		if val, ok := reflect.struct_tag_lookup(tag, &#34;json&#34;) ok {			fmt.printf(&#34;json: %s -&gt; %s\n&#34;, names[i], val)		}	}}</p><p>包装主要进口和#34；核心：fmt和#34；进口和#34；核心：反映和#34；main:：proc（）{Foo:：struct{x:int`tag1'，y:string`json:&#34；y#u字段&#34；`，z:bool，//no tag}id:=typeid_of（Foo）名称：=reflect。结构\字段\名称（id）类型：=反映。结构\字段\类型（id）标记：=反射。结构字段标签（id）断言（len（名称）==len（类型）&amp&amp；len（姓名）==len（标签）fmt。println（&#34；Foo:：struct{&#34；）对于标签，我在标签中{name，type:=names[i]，type[i]if tag！=&#34；&#34；{fmt.printf（&#34；\t%s:%t`%s`，\n&#34；，name，type，tag）}其他{fmt.printf（&#34；\t%s:%t、\n&#34；，name，type）}fmt。println（&#34；}&#34；）对于tag，标记{if val，ok:=reflect.struct_tag_lookup（tag，&#34；json&#34；）中的i好的{fmt.printf（&#34；json:%s-&gt；%s\n&#34；，names[i]，val）}}</p><p>  Odin has been designed for readability, scalability, and  orthogonality of concepts. Simplicity is complicated to get right, clear is better than clever.</p><p>Odin是为概念的可读性、可扩展性和正交性而设计的。简单是很难做到的，清晰总比聪明好。</p><p> Odin allows for the highest performance through low-level control over the memory layout,  memory management and custom  allocators and so much more.</p><p>Odin通过对内存布局、内存管理和自定义分配器等的低级别控制，实现了最高的性能。</p><p> Odin is designed from the bottom up for the modern computer, with built-in support for  SOA data types,  array programming, and other features.</p><p>Odin是为现代计算机自下而上设计的，内置了对SOA数据类型、阵列编程和其他功能的支持。</p><p> We go into programming because we love to solve problems. Why shouldn&#39;t our tools bring us joy whilst doing it? Enjoy programming again, with Odin!</p><p>我们从事编程是因为我们喜欢解决问题。为什么不应该&#39；难道我们的工具在工作时不会给我们带来快乐吗？再次享受编程，与奥丁！</p><p> EmberGen is a real-time volumetric fluid simulator that can instantly simulate, render, and export flipbooks, image sequences, and VDB volumes. With EmberGen, you can create anything from fire and smoke, to explosions and magic wisps. EmberGen gives you the creative freedom to iterate on your simulations in a few milliseconds instead of hours.</p><p>EmberGen是一款实时体积流体模拟器，可以即时模拟、渲染和导出动画书、图像序列和VDB体积。有了EmberGen，你可以创造任何东西，从火和烟，到爆炸和魔法。EmberGen为您提供了在几毫秒而不是几个小时内迭代模拟的创造性自由。</p><p> Through EmberGen, Odin runs in production among the giants of the games and film industries: Bethesda, CAPCOM, Codemasters, THQNordic, Warner Bros, Weta Digital, and many others.</p><p>通过EmberGen，奥丁在游戏和电影行业的巨头中进行制作：贝塞斯达、CAPCOM、Codemasters、THQNordic、华纳兄弟、Weta Digital和许多其他公司。</p><p> Odin provides official libraries for all major graphics APIs:  OpenGL,  Vulkan,  Direct3D11,  Direct3D12,  Metal, and  WebGL 1 &amp; 2.</p><p>Odin为所有主要的图形API提供了官方库：OpenGL、Vulkan、Direct3D11、Direct3D12、Metal和WebGL 1&amp；2.</p><p> Odin additionally brings you officially maintained bindings for popular libraries such as  SDL2,  GLFW,  raylib,  microui,  miniaudio and much more, in its   vendor library!</p><p>Odin还提供了官方维护的绑定，用于其供应商库中的流行库，如SDL2、GLFW、raylib、microui、miniaudio等！</p><p> Odin is an open source programming language and contributions from the community are welcome!If you want to help out, check the  issue tracker for open issues that may interest you. Those labelled  help wanted are in particular need of community assistance right now.</p><p>Odin是一种开源编程语言，欢迎社区的贡献！如果你想提供帮助，请查看问题追踪器，了解你可能感兴趣的未决问题。那些被称为需要帮助的人现在特别需要社区援助。</p><p> Join the Odin Discord and help us bring the joy of programming in Odin to all. 🥳</p><p>加入Odin Discord，帮助我们将Odin编程的乐趣带给所有人。🥳</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/奥丁/">#奥丁</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/soa/">#soa</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>