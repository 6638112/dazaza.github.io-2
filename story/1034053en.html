<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>图灵不完全语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">图灵不完全语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 23:42:18</div><div class="page_narrow text-break page_content"><p>Summary: Some languages ban recursion to ensure programs &#34;terminate&#34;. That&#39;s technically true, but usually irrelevant.</p><p>摘要：某些语言禁止递归以确保程序终止。这在技术上是正确的，但通常是无关紧要的。</p><p> In my career there have been three instances where I&#39;ve worked on a programming language that went through the evolution:</p><p>在我的职业生涯中，有三次我致力于一种经历了演变的编程语言：</p><p> Ban recursion and unbounded loops. Proclaim the language is &#34;Turing incomplete&#34; and that all programs terminate.</p><p>禁止递归和无界循环。声明该语言是图灵不完整的，所有程序都将终止。</p><p> Declare that Turing incomplete programs are simpler. Have non-technical people conflate terminate quickly with terminate eventually.</p><p>声明图灵不完整的程序更简单。让非技术人员将快速终止与最终终止混为一谈。</p><p> Realise lacking recursion makes things incredibly clunky to express, turning simple problems into brain teasers.</p><p>意识到缺乏递归使得表达事物变得极其笨拙，把简单的问题变成了脑筋急转弯。</p><p> Before I left university, this process would have sounded ridiculous. In fact, even after these steps happened  twice I was convinced it was the kind of thing that would never happen again. Now I&#39;ve got three instances, it seems worth writing a blog post so for case number four I have something to refer to.</p><p>在我离开大学之前，这个过程听起来很可笑。事实上，即使在这些步骤发生了两次之后，我仍然相信这种事情永远不会再发生。现在我有了三个例子，似乎值得写一篇博客文章，所以对于第四个案例，我有一些东西可以参考。</p><p>  First, let&#39;s consider a small simple statement-orientated first-order programming language. How might we write a non-terminating program? There are two easy ways. Firstly, write a loop -  while (true) {}. Second, write recursion,  void f() { f() }. We can ban both of those, leaving only bounded iteration of the form  for x in xs { .. } or similar. Now the language is Turing incomplete and all programs terminate.</p><p>首先，让我们考虑一种小型的、简单的、面向语句的一阶编程语言。我们怎样才能写出一个非终结性的程序呢？有两种简单的方法。首先，编写一个loop-While(True){}。第二，编写递归，void f(){f()}。我们可以禁止这两种情况，只留下x在xs{..中的表单的有界迭代。)或类似情况。现在图灵语言不完整，所有程序都会终止。</p><p> The lack of recursion makes programs harder to write, but we can always  use an explicit stack with unbounded loops.</p><p>缺少递归使程序更难编写，但我们总是可以使用带有无界循环的显式堆栈。</p><p> The lack of unbounded loops isn&#39;t a problem provided we have an upper bound on how many steps our program might take. For example, we know  QuickSort has worst-case complexity  O(n^2), so if we can write  for x in range(0, n^2) { .. } then we&#39;ll have enough steps in our program such that we never reach the bound.</p><p>如果我们对程序可能执行的步骤有一个上限，那么缺少无限循环并不是问题。例如，我们知道快速排序的最坏情况下的复杂度为O(n^2)，所以如果我们可以在(0，n^2){..。那么我们的程序中就会有足够多的步骤，以至于我们永远不会达到极限。</p><p> But what if our programming language doesn&#39;t even provide a  range function? We can synthesise it by realising that in a linear amount of code we can produce exponentially large values. As an example:</p><p>但是，如果我们的编程语言甚至没有提供范围函数呢？我们可以通过意识到在线性代码中可以产生指数级的大值来综合它。例如：</p><p> double xs = xs ++ xs -- Double the length of a listrepeated x = double (double (double (double (double (double (double (double (double (double [x])))))))))</p><p>Double Xs=Xs++Xs--有条纹的x=Double(Double[x])。</p><p> The function  repeated 1 makes 10 calls to double, and creates a list of length 2^10 (1024). A mere 263 more calls to  double and we&#39;ll have a list long enough to contain each atom in the universe. With some tweaks we can cause doubling to stop at a given bound, and generate numbers in sequence, giving us  range to any bound we pick.</p><p>函数Repeat 1对Double进行了10次调用，并创建了一个长度为2^10(1024)的列表。只要再有263个请求加倍，我们就会有一个足够长的清单，足以容纳宇宙中的每个原子。通过一些调整，我们可以使倍增在给定的界限上停止，并按顺序生成数字，给我们范围到我们选择的任何界限。</p><p> We now have a menu of three techniques that lets us write almost any program we want to do so:</p><p>我们现在有一个包含三种技术的菜单，可以让我们编写几乎任何我们想要编写的程序：</p><p>   Firstly, we still don&#39;t have a Turing complete language. The code will terminate. But there is no guarantee on how long it will take to terminate. Programs that take a million years to finish technically terminate, but probably can&#39;t be run on an actual computer. For most of the domains I&#39;ve seen Turing incompleteness raised, a runtime of seconds would be desirable. Turing incompleteness doesn&#39;t help at all.</p><p>首先，我们还没有一种完整的图灵语言。代码将终止。但不能保证需要多长时间才能终止。从技术上讲，需要一百万年才能完成的程序会终止，但很可能无法在真正的计算机上运行。对于我见过的图灵不完备性提升的大多数领域来说，运行几秒钟将是理想的。图灵的不完整完全无济于事。</p><p> Secondly, after encoding the program in a tortured mess of logic puzzles, the code is much harder to read. While there are three general purpose techniques to encode the logic, there are usually other considerations that cause each instance to be solved differently. I&#39;ve written tree traversals, sorts and parsers in such restricted languages - the result is always a lot of comments and at least one level of unnecessary indirection.</p><p>其次，在一堆错综复杂的逻辑谜题中对程序进行编码后，代码就更难读懂了。虽然有三种通用技术可以对逻辑进行编码，但通常还有其他一些考虑因素会导致每个实例的解决方案各不相同。我已经用这种受限的语言编写了树遍历、排序和解析器-结果总是有很多注释和至少一个级别的不必要的间接。</p><p> Finally, code written in such a complex style often performs significantly worse. Consider QuickSort - the standard implementation takes  O(n^2) time worst case, but  O(n log n) time average case, and  O(log n) space (for the stack). If you take the approach of building an  O(n^2) list before you start to encode a  while loop, you end up with  O(n^2) space and time. Moreover, while in normal QuickSort the time complexity is counting the number of cheap comparisons, in an encoded version the time complexity relates to allocations, which can be much more expensive as a constant factor.</p><p>最后，以如此复杂的风格编写的代码的性能通常要差得多。考虑快速排序--标准实现最坏情况下需要O(n^2)时间，而平均情况下需要O(Nlogn)时间，堆栈需要O(Logn)空间。如果在开始编码While循环之前采用构建O(n^2)列表的方法，那么最终将得到O(n^2)个空间和时间。此外，在普通的快速排序中，时间复杂度是计算廉价比较的次数，而在编码版本中，时间复杂度与分配有关，而作为一个常量因素，分配的成本可能要高得多。</p><p>  Most languages with the standard complement of  if/ for etc which are Turing incomplete do not gain any benefit from this restriction. One exception is in domains where you are proving properties or doing analysis, as two examples:</p><p>大多数具有if/for等标准补语的语言(图灵不完整)不会从这一限制中获得任何好处。一个例外是在证明属性或进行分析的领域，举两个例子：</p><p> Dependently typed languages such as  Idris, which typically have much more  sophisticated termination checkers than just banning recursion and unbounded loops.</p><p>依赖类型的语言，比如Idris，它们通常有比仅仅禁止递归和无限循环复杂得多的终止检查器。</p><p> Resource bounded languages such as  Hume, which allow better analysis and implementation techniques by restricting how expressive the language is.</p><p>资源受限的语言，如休谟，它通过限制语言的表现力来实现更好的分析和实现技术。</p><p> Such languages tend to be a rarity in industry. In all the Turing incomplete programming languages I&#39;ve experienced, recursion was later added, programs were simplified, and programming in the language became easier.</p><p>这样的语言在工业中往往是罕见的。在我经历过的所有图灵不完全编程语言中，后来添加了递归，简化了程序，用这种语言编程变得更容易。</p><p> While most languages I&#39;ve worked on made this evolution in private, one language,  DAML from  Digital Asset, did so in public.  In 2016 they wrote:</p><p>虽然我研究过的大多数语言都是在私下进行的，但有一种语言--来自Digital Asset的DAML--是在公开场合进行的。2016年，他们写道：</p><p> DAML was intentionally designed not to be Turing-complete. While Turing-complete languages can model any business domain, what they gain in flexibility they lose in analysability.</p><p>DAML被故意设计为不是图灵完全的。尽管图灵完全语言可以对任何业务领域进行建模，但它们在灵活性方面所获得的好处却失去了可分析性。</p><p>  If there is no explicit iterator, you can use recursion. Let’s try to write a function that reverses a list, for example.</p><p>如果没有显式迭代器，可以使用递归。例如，让我们尝试编写一个反转列表的函数。</p><p> Note that while I used to work at Digital Asset, these posts both predate and postdate my time there.</p><p>请注意，虽然我曾经在Digital Asset工作，但这些帖子既早于我在数字资产公司工作的时间，也早于我在那里工作的时间。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://neilmitchell.blogspot.com/2020/11/turing-incomplete-languages.html">http://neilmitchell.blogspot.com/2020/11/turing-incomplete-languages.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/图灵/">#图灵</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>