<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C++模板：如何迭代STD:tuple：STD:应用和更多</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C++模板：如何迭代STD:tuple：STD:应用和更多</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 17:28:27</div><div class="page_narrow text-break page_content"><p>在上一篇关于元组迭代的文章中，我们介绍了基本知识。因此，我们实现了一个函数模板，它接受一个元组，并可以很好地将其打印到输出中。还有一个版本带有operator&lt&书信电报；。</p><p>今天我们可以进一步了解其他一些技术。第一个是来自C++17的std:：apply，它是元组的辅助函数。今天的文章还将介绍一些策略，使迭代更通用，并处理定制的可调用对象，而不仅仅是打印。</p><p>这是小系列的第二部分。请参阅本文的第一篇文章，其中我们讨论了基础知识。</p><p>std:：tuple的一个方便助手是C++17中的std:：apply函数模板。它接受一个元组和一个可调用对象，然后使用从元组中获取的参数调用这个可调用对象。</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；int sum（int a，int b，int c）{返回a+b+c；}无效打印（std:：string_视图a、std:：string_视图b）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；a&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；b&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；）\n&#34；；}int main（）{std:：tuple number{1,2,3}；标准：cout&lt&书信电报；标准：：应用（总和、数字）&lt&lt&#39;\n&#39；std：：tuple strs{&#34；Hello&#34；，&#34；World&#34；}；std：：应用（打印，strs）；}</p><p>如您所见，std:：apply接受sum或print函数，然后“展开”元组，并使用适当的参数调用这些函数。</p><p>关键是std:：apply隐藏了所有索引生成和对std:：get&lt&gt；。这就是为什么我们可以用std:：apply替换打印函数，然后不使用index_序列。</p><p>我想到的第一种方法是：创建一个变量函数模板，该模板采用Args。。。并将其传递给std:：apply:</p><p>模板&lt；字体名。。。Args&gt；void printImpl（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；（普列特莱姆（图普里格斯），…）；]模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std：：tuple&lt；Args…&gt；&gt；&gt；{std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&gt；&gt；&gt；&lt；&lt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；[34；]</p><p>问题在于out printImpl是一个可变函数模板，因此编译器必须实例化它。当我们调用std:：apply时，实例化不会发生，而是在std:：apply内部发生。当我们调用std:：apply时，编译器不知道如何调用可调用对象，因此在这个阶段它无法执行模板推导。</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；字体名。。。Args&gt；void printImpl（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；（普列特莱姆（图普里格斯），…）；]模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std:：tuple&lt；Args…&gt；&gt；tp）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；34；（&gt；std:：apply（printImpl&lt；Args…&gt；，tp）；/&lt；std:：cout&lt；&lt；&lt；&lt；&lt；&gt；）和int main（）{std:：tuple tp{10,20,3.14}；printTupleApplyFn（tp）；}</p><p>在上面的示例中，我们帮助编译器创建了请求的实例化，因此它很乐意将其传递给std:：apply。</p><p>struct HelperCallable{template&lt；typename…Args&gt；void操作符（）（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；}；（普列特莱姆（图普里格斯），…）；}；模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std：：tuple&lt；Args…&gt；&gt；&gt；{std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt</p><p>现在，我们所做的，只是传递一个可帮助调用的对象；它是一个具体的类型，因此编译器可以毫无问题地传递它。没有模板参数推导。然后，在某个时刻，编译器将调用HelperCallable（args…），调用该结构的运算符（）。现在一切都很好，编译器可以推断出类型。换句话说，我们推迟了问题的解决。</p><p>因此，我们知道代码可以与助手可调用类型配合使用……那么lambda呢？</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；typename TupleT&gt；void printtupleappy（const-TupleT&amp；tp）{std：：cout&lt；&lt；&lt；&lt；34；（&#34；std：：apply（[]（const-auto&amp；…tupleArgs）{size_-t index=0；auto-printElem=[&amp；index]（const-auto&amp；x）{if（index++gt；0）std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&gt；34；&gt；&gt；（普列特莱姆（图普里格斯），…）；}，tp）标准：：cout&lt&lt&#34;)&#34; ; } intmain（）{std:：tuple tp{10,20,3.14,42和#34；hello和#34；}；printTupleApply（tp）；}</p><p>正如你所看到的，我们在一个lambda中有一个lambda。它类似于我们使用运算符（）的自定义类型。您还可以通过C++透视图来了解转换：这个链接</p><p>因为我们的可调用对象得到一个可变参数列表，所以我们可以使用这些信息，使代码更简单。</p><p>内部lambda中的代码使用索引检查是否需要打印分隔符——它检查是否打印第一个参数。我们可以在编译时执行此操作：</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；typename TupleT&gt；void printTupleApply（const-TupleT&amp；tp）{std:：apply（[]（const-auto&amp；first，const-auto&amp；restArgs）{auto-printElem=[]（const-auto&amp；x）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；x；}；标准：cout&lt&lt&#34;（&#34；&lt；&lt；第一；（printElem（restArgs），…）；），tp）；标准：cout&lt&lt&#34;)&#34; ; } intmain（）{std:：tuple tp{10,20,3.14,42和#34；hello和#34；}；printTupleApply（tp）；}</p><p>这段代码在元组没有元素时会中断——我们可以通过在if constexpr中检查它的大小来修复这一问题，但现在让我们跳过它。</p><p>到目前为止，我们主要关注打印元组元素。所以我们有一个“固定”函数，每个参数都被调用。为了进一步阐述我们的想法，让我们尝试实现一个接受通用可调用对象的函数。例如：</p><p>模板&lt；typename TupleT，typename Fn，std:：size\u t。。。Is&gt；每个元组无效（元组&amp；tp，Fn&amp；Fn，标准：：索引序列&lt；Is…&gt；）{（fn（std：：get&lt；Is&gt；（std：：forward&lt；TupleT&gt；（tp）），…）；}模板&lt；typename TupleT，typename Fn，std:：size\u t TupSize=std:：tuple\u size\u v&lt；标准：：移除_cvref_t&lt；TupleT&gt&gt&gt；对于每个元组无效（TupleT&amp；tp，Fn&amp；Fn）{对于每个元组impl（std:：forward&lt；TupleT&gt；（tp），std:：forward&lt；Fn&gt；（Fn），std:：make_index_sequence&lt；TupSize&gt；{}</p><p>首先，代码使用通用引用（转发引用）传递元组对象。这是支持各种用例所必需的，尤其是当调用方想要修改元组中的值时。这就是为什么我们需要在所有地方使用std:：forward。</p><p>这是C++20 trait中的一个新助手类型，它确保我们从通过通用引用获得的类型中获得“真实”类型。</p><p>下面是一个关于元组迭代链接到Stackoverflow的问题的很好的总结：</p><p>作为T&amp&amp；是转发引用，T将是tuple&lt&gt&amp；或者tuple&lt&gt；康斯特；当左值传入时；但是std:：tuple_size只适用于tuple&lt&gt；，所以我们必须去掉引用和可能的常量。在C++20添加std:：remove_cvref_t之前，使用decation_t是一种简单（如果过度杀戮）的解决方案。</p><p>我们讨论了一个索引序列的实现；我们也可以在std：：apply中尝试同样的方法。它能产生更简单的代码吗？</p><p>模板&lt；typename TupleT，typename Fn&gt；每一个tuple2（TupleT&amp；amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]（auto&amp；…args）{（Fn（args），…）；}无效，标准：前进&lt；TupleT&gt；（tp）；}</p><p>模板&lt；typename TupleT，typename Fn&gt；对于每个tuple2（TupleT&amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]&lt；typename…T&gt；（T&amp；…args）{（Fn（std:：forward&lt；T&gt；（args）），…）}，无效，标准：前进&lt；TupleT&gt；（tp）；}</p><p>此外，如果要坚持使用C++17，可以对参数应用decltype：</p><p>模板&lt；typename TupleT，typename Fn&gt；每一个tuple2（TupleT&amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]（auto&amp；…args）{（Fn（std:：forward&lt；decltype（args）&gt；（args）），…）；}，标准：前进&lt；TupleT&gt；（tp）；}</p><p>背景任务是打印元组元素，并找到转换它们的方法。在这个过程中，我们经历了变量模板、索引序列、模板参数推导规则和技巧、std:：apply和删除引用。</p><p>我很高兴讨论变化和改进。请在下面的评论中告诉我你的想法。</p><p>C++模板：David Vandevoorde、Nicolai M. Josuttis、Douglas Gregor的完整指南（第二版）</p><p>我&#39；如果你&#39；对现代C++有兴趣！了解最近C++标准的所有主要特征！看看这里：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>