<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ffmpeg作为图书馆：libav教程 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ffmpeg作为图书馆：libav教程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 17:10:37</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/e982b9acb557e47bcbc28897befb56bc.png"><img src="http://img2.diglog.com/img/2021/5/e982b9acb557e47bcbc28897befb56bc.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我正在寻找一个教程/书，教我如何开始使用ffmpeg作为库（a.k.a.ibav），然后我找到了＆＃34;如何在少于1k行和＃34中编写视频播放器;教程。不幸的是，它被推翻了，所以我决定写这个。</p><p> 这里的大多数代码都将在c但不用担心：您可以轻松理解并将其应用于您的首选语言.FFFMPEG Libav对Python这样的许多语言有很多绑定，即使您的语言也不是您的语言＆＃ 39; t拥有它，您仍然可以通过FFI（这里的一个例子）来支持它。</p><p> 我们＆＃39; ll从一个快速课程开始，关于视频，音频，编解码器和容器，然后我们＆＃39; ll转到如何使用ffmpeg命令行的崩溃课程，最后我们＆＃39; ll写代码，感觉自由跳过直接跳过该节，学习ffmpeg libav的硬路。</p><p> 有些人常常说互联网视频流是传统电视的未来，无论如何，FFMPEG是值得学习的。</p><p>     如果您有一个序列系列图像并以给定的频率更改它们（让＆＃39; s每秒表示24张图片），您将创建一个幻觉。总结这是视频背后的非常基本的想法：一个系列以给定速率运行的图片/框架。</p><p>    虽然静音视频可以表达各种各样的感受，但为其提供了更多的乐趣。</p><p> 声音是作为压力波的振动，通过空气或任何其他传动介质，例如气体，液体或固体。 </p><p>在数字音频系统中，麦克风将声音转换为模拟电信号，然后是模数转换器（ADC） - 通常使用脉冲码调制（PCM） - 将模拟信号转换为数字信号。</p><p>    Codec是一种压缩或解压缩数字音频/视频的电子电路或软件。它将原始（未压缩的）数字音频/视频转换为压缩格式，反之亦然。 https://en.wikipedia.org/wiki/video_codec.</p><p> 但是如果我们选择在一个文件中收拾数百万图像并将其称为电影，我们可能会结束一个巨大的文件。让＆＃39; s做数学：</p><p> 假设我们正在创建一个具有1080 x 1920（高度x宽度）的视频，并且我们＆＃39; ll每像素（屏幕上的最小点）花3个字节以编码颜色（或24位颜色，给出什么US 16,777,216不同颜色），此视频运行每秒24帧，长30分钟。</p><p> toppf = 1080 * 1920 // total_of_pixels_per_framecpp = 3 // cost_per_pixeltis = 30 * 60 // time_in_secondsfps = 24 // frames_per_secondrequired_storage = tis * fps * toppf * cpp</p><p> 此视频需要大约250.28GB的存储或1.11Gbps的带宽！那个＆＃39;为什么我们需要使用编解码器。</p><p>  容器或包装格式是一种元文件格式，其规范描述了数据和元数据在计算机文件中的不同元素。 https://en.wikipedia.org/wiki/digital_container_format. </p><p>包含所有流的单个文件（主要是音频和视频），它还提供同步和常规元数据，例如标题，分辨率等。</p><p> 通常，我们可以通过查看其扩展来推断文件的格式：例如，视频.Webm可能是使用容器Webm的视频。</p><p>    使用多媒体工作，我们可以使用名为ffmpeg的惊人工具/库。您已经直接或间接地或间接地或使用它（使用Chrome？）。</p><p> 它有一个名为ffmpeg的命令行程序，一个非常简单而强大的二进制文件。对于实例，可以通过键入power命令从mp4转换为容器avi：</p><p>  我们刚刚在这里进行了复制，它正在将一个容器从一个容器转换为另一个容器。FFMPEG也可以进行代码转换，但我们稍后会谈论这一点。</p><p>  FFMPEG确实有一个文档，可以做出很大的工作解释它是如何运作的。</p><p> 要使事物简短，FFMPEG命令行程序期望以下参数格式执行其操作ffmpeg {1} {2} -2} -i {3} {4} {5}，其中： </p><p>第2,3,4和5部分可以与您的需要一样多。＆＃39更容易理解此参数格式的操作：</p><p> ＃警告：此文件约为300MB $ WGet -o bunny_1080p_60fps.mp4 http://distribution.bbb3d.renderfarming.bbb3d.renderfarming.net/video/mp4/bbb_sunflower_1080p_60fps_normal.mp4。ffmpeg \ -y \＃global选项-c：a libfdk_aac -c ：v libx264 \ #inpection options-i bunny_1080p_60fps.mp4 \ #inping url-c：v libvpx-vp9 -c：一个libvorbis \ #pourst optionsbunny_1080p_60fps_vp9.webm＃输出URL</p><p> 该命令采用包含两个流的输入文件MP4（使用H264编解码器和使用H264编解码器编码的视频编码的音频）并将其转换为Webm，也改变其音频和视频编解码器。</p><p> 我们可以简化上面的命令，但请注意，FFMPEG将采用或猜测您的默认值。如果只需键入ffmpeg -i input.avi output.mp4时，它会使用哪些音频/视频编解码器来产生输出。 mp4？</p><p>      什么？将一条流（音频或视频）从一个编解码器转换为另一个编解码器的行为。</p><p> 为什么？有时某些设备（电视，智能手机，控制台等）并不支持x，但y和较新的编解码器提供更好的压缩率。</p><p>      为什么？有时某些设备（电视，智能手机，控制台等）并不支持x，但y有时更新的容器提供现代必修功能。 </p><p>$ ffmpeg \ -i bunny_1080p_60fps.mp4 \ -c copy \＃只是对ffmpeg跳过encodingbunny_1080p_60fps.webm</p><p>    为什么？人们将尝试使用更强大的智能手机或在其4克电视上的光纤互联网连接中使用2G（边缘）连接，因此您应该提供多个具有不同比特率的相同视频的再出现。</p><p>   通常是我们＆＃39; LL使用转频与变化。 Werner Robitza写了另一种必须读/执行关于FFMPEG速率控制的帖子。</p><p>   什么？将一个分辨率转换为另一个分辨率的行为。如前所述，在经常发生之前通常与转置一起使用。</p><p>      什么？产生许多分辨率（比特率）并将媒体拆分为块并通过HTTP提供服务的行为。</p><p> 为什么？提供一种可在低端智能手机或4K电视上观看的灵活媒体，它也可以轻松划衡和部署，但它可以添加延迟。</p><p>  ＃视频流$ ffmpeg -i bunny_1080p_60fps.mp4 -c：v libvpx-vp9 -s 160x90-b：v 250k -keyint_min 150-g 150-an -f webm -dash 1 video_160x90_250k.webm $ ffmpeg -i bunny_1080p_60fps.mp4  - C：v libvpx-vp9-s 320x180 -b：v 500k -keyint_min 150-g 150-an -f webm -dash 1 video_320x180_500k.webm $ ffmpeg -i bunny_1080p_60fps.mp4 -c：v libvpx-vp9 -s 640x360 -b ：v 750k -keyint_min 150-g 150-an -f webm -dash 1 video_640x360_750k.webm $ ffmpeg -i bunny_1080p_60fps.mp4 -c：v libvpx-vp9 -s 640x360 -b：v 1000k -keyint_min 150-g 150-an -f webm -dash 1 video_640x360_1000k.webm $ ffmpeg -i bunny_1080p_60fps.mp4 -c：v libvpx-vp9 -s 1280x720 -b：v 1500k -keyint_min 150-g 150-an -f webm -dash 1 video_1280x720_1500k.webm＃音频Streams $ ffmpeg -i bunny_1080p_60fps.mp4 -c：一个libvorbis -b：一个128k -vn -f webm -dash 1 audio_128k.webm＃dash manifest $ ffmpeg \ -f webm_dash_manifest -i video_160x90_250k.webm \ -f webm_dash_manifest -i Video_320x180_500k.webm \ -f webm_dash_manifest -i video_640x360_750k.webm \  - f webm_dash_manifest -i video_640x360_1000k.webm \ -f webm_dash_manifest -i video_1280x720_500k.webm \ -f webm_dash_manifest -i audio_128k.webm \ -c copy -map 0 -map 1 -map 2 -map 3 -map 4 -map 5 \ -f webm_dash_manifest \ -adaptation_sets＆＃34; id = 0，streams = 0,1,2,3,4 id = 1，流= 5＆＃34; \ \ insmest.mpd. </p><p>FFMPEG有许多和许多其他用法.I与iMovie一起使用它来为YouTube生产/编辑一些视频，您可以专业地使用它。</p><p>   由于FFMPEG作为指令行工具如媒体文件进行必要的任务，因此我们如何在我们的程序中使用它？</p><p> ffmpeg由几个可以集成到我们自己的程序中的图书馆组成。通常，安装FFMPEG时，它会自动安装所有这些库。我是指作为ffmpeg libav的这些库的集合。</p><p> 这个标题是ZED Shaw＆＃39; S系列学习x的斗争，特别是他的书学习了艰难的方式。</p><p>  这个你好世界实际上是赢得＆＃39; t显示消息＆＃34;你好世界＆＃34;在终端中👅👅👅＆＃39;重新打印有关视频的信息，类似于它的格式（容器），持续时间，分辨率，音频通道等的东西，最终，我们＆＃39; ll解码一些框架并保存它们作为图像文件。</p><p>  但在我们开始代码之前，让我们了解FFMPEG Libav架构的工作方式以及其组件如何与他人通信。</p><p>   您＆＃39; ll首先需要将媒体文件加载到名为avformatcontext的组件（视频容器也被称为格式）。它实际上并不完全加载整个文件：它通常只读取标题。 </p><p>一旦我们加载了我们的容器的最小标题，我们就可以访问其流（将其视为基本的音频和视频数据）.Ecte流将在称为AVStream的组件中使用。</p><p>  假设我们的视频有两个流：用AAC编解码器编码的音频和使用H264（AVC）编解码器编码的视频。从每个流中，我们可以提取名为数据包的数据的片段（切片），该数据包将被加载到名为avpacket的组件中。</p><p> 数据包内的数据仍然被编码（压缩），并且为了解码数据包，我们需要将它们传递给特定的avcodec。</p><p> avcodec将它们解码为avframe，最后，此组件为我们提供了未压缩的帧。注意到，使用音频和视频流使用相同的术语/过程。</p><p>  由于一些人在编译或运营的例子时面临问题，我们＆＃39;重新使用Docker作为我们的开发/跑步者环境，我们＆＃39; LL也使用大量的Bunny视频，所以如果你没有＆＃39;它在本地运行命令make fetch_small_bunny_video。</p><p>    我们＆＃39;重新将内存分配给Component AvformatContext，该组件将保存有关格式的信息（容器）。</p><p>  现在我们＆＃39;重新打开文件并读取其标题并填充有关格式的最少信息的AvformatContext（请注意通常编解码器未打开）。用于执行此操作的函数是Avformat_open_Input。它期望AvformatContext，文件名和两个可选参数：avinputformat（如果通过null，ffmpeg将猜测格式）和avdictionary（这是调查器的选项）。 </p><p>要访问流，我们需要从媒体读取数据。函数avformat_find_stream_info确实如此.now，pformatcontext-＆gt; nb_streams将保存流量和pformatcontext-＆gt; streams [i]将给我们我流（avstream）。</p><p>    对于每个流，我们将保留avcodecparameters，它描述了流i的编解码器的属性。</p><p>  使用编解码器属性，我们可以查找查询函数avcodec_find_decoder的正确编解码器，并找到编解码器ID的已注册的解码器并返回avcodec，知道如何en en代码和解码流的组件。</p><p>   //视频和音频特定（PlocalcodeCparameters-＆gt; codec_type == avmedia_type_video）{printf（＆＃34;视频编解码器：分辨率％dx％d＆＃34;，plocalcodecparameters-＆gt;宽度，plocalcodecparameters-＆gt;高度） }}否则if（plocalcodecparameters-＆gt; codec_type == avmedia_type_audio）{printf（＆＃34;音频编解码器：％d频道，样品率％d＆＃34;，plocalcodecparameters-＆gt; plocalcodecparameters-＆gt; sample_rate）; } //常规printf（＆＃34; \ tcodec％s id％dit_rate％lld＆＃34; plocalcodec-＆gt; long_name，plocalcodec-＆gt; id，plocalcodecparameters-＆gt; bit_rate）;</p><p> 使用编解码器，我们可以为avcodeccontext分配内存，这将为我们的解码/编码过程保持上下文，但是我们需要使用编解码器参数填充此编解码器上下文;我们用avcodec_parameters_to_context这样做。</p><p> 填写编解码器上下文后，我们需要打开编解码器。我们调用函数avcodec_open2，然后我们可以使用它。</p><p>  现在我们将从流中读取数据包并将它们解码为帧，但首先，我们需要为两个组件，avpacket和avframe分配内存。 </p><p>让＆＃39; s从具有数据包的函数av_read_frame中从流中馈送我们的数据包。</p><p>  使用函数avcodec_send_packet，将原始数据包（压缩帧）发送到解码器，通过编解码器上下文发送到解码器。</p><p>  使用函数avcodec_receive_frame，通过相同的编解码器上下文从解码器接收来自解码器的原始数据帧（未压缩帧）。</p><p>   printf（＆＃34;帧％c（％d）pts％d dts％d key_frame％d [coded_picture_number％d，display_picture_number％d]＆＃34;，av_get_picture_type_char（pframe-＆gt; pict_type），pcodeccontext-＆gt; frame_number ，pframe-＆gt; pts，pframe-＆gt; pkt_dts，pframe-＆gt; key_frame，pframe-＆gt; coded_picture_number，pframe-＆gt; display_picture_number）;</p><p> 最后，我们可以将解码的帧保存到简单的灰色图像中。这个过程非常简单，我们＆＃39; ll使用pframe-＆gt;索引与平面y，cb和cr相关的数据，我们刚刚选择0（y）以保存我们的灰色图像。</p><p> save_gray_frame（pframe-＆gt;数据[0]，pframe-＆gt; Lineize [0]，Pframe-＆gt;宽度，pframe-＆gt;高度，Frame_FileName）;静态void save_gray_frame（无符号char * buf，int wrap，int xsize，int ysize，char * filename）{file * f; INT I; f = fopen（文件名，＆＃34; w＆＃34;）; //以PGM文件格式编写最小所需的标题// Portable GrayMap格式 - ＆gt; https://en.wikipedia.org/wiki/netpbm_format#pgm_example fprintf（f，＆＃34; p5 \ n％d％d \ n％d \ n＆＃34;，xsize，ysize，255）; //按行写入线（i = 0; i＆lt; ysize; i ++）fwrite（buf + i *包装，1，xsize，f）; fclose（f）;}</p><p>     在我们转到代码之前，转码示例让＆＃39;谈论时间，或者视频播放器如何知道播放帧的正确时间。 </p><p>当我们设计一个视频播放器时，我们需要在给定的速度下播放每个帧，否则会很难看到视频，因为它＆＃39; s如此迅速或慢。</p><p> 因此，我们需要介绍一些逻辑以平稳地播放每个帧。如此，每个帧具有呈现时间戳（PTS），该时间戳（PTS）是在时基中的越来越多的因子，其是由帧速率（FPS）可分割的Rational数（其中称为时间尺寸）。</p><p>  对于FPS = 60/1和TimeBase = 1/60000，每个PTS将增加时间尺寸/ FPS = 1000因此，每个帧的PTS实时可能（假设它开始于0）：</p><p>    对于FPS = 25/1和TimeBase = 1/75，每个PTS将增加时间尺度/ FPS = 3并且PTS时间可能是：</p><p>  现在使用PTS_Time，我们可以找到一种方法来将此与音频PTS_Time或系统时钟同步。 ffmpeg libav通过其API提供这些信息：</p><p>  刚出于好奇，我们保存的框架以DTS订单（帧：1,6,4,2,3,5）发送，但以PTS订单（框架：1,2,3,4,5）播放。此外，请注意与P或I帧相比，B帧有多便宜。</p><p> 日志：avstream-＆gt; r_frame_rate 60 / 1log：avstream-＆gt; time_base 1/60000 ...日志：框架1（类型= i，size = 153797字节）pts 6000 key_frame 1 [dts 0]日志：框架2（类型= B，大小= 8117字节）PTS 7000键键0 [DTS 3]日志：帧3（类型= B，大小= 8226字节）PTS 8000键_Frame 0 [DTS 4]日志：第4帧（类型= B，size = 17699字节）PTS 9000 KEY_FRAME 0 [DTS 2]日志：第5帧（类型= B，大小= 6253字节）PTS 10000 KEY_FRAME 0 [DTS 5]日志：第6帧（类型= P，大小= 34992字节）PTS 11000键_FRAME 0 [DTS 1] </p><p>Remuxing是从一种格式（容器）转换为另一个格式（容器）的行为，例如，我们可以使用ffmpeg疼痛将MPEG-4视频更改为MPEG-TS：  它＆＃39; ll demux mp4，但它赢得了＆＃39; t解码或编码它（-c copy）和结束，它＆＃39;将mux in＆＃39;将它置于mpegts文件中。 如果您不提供格式 -  FFMPEG将尝试基于文件＆＃39的扩展名。  协议层 - 它接受输入（例如，文件，但它也可能是RTMP或HTTP输入）  像素层 - 它也可以将一些过滤器应用于原始帧（如调整大小）可选  协议层 - 并且最后将Muxed数据发送到输出（另一个文件或网络远程服务器）  现在让＆＃39; s代码使用libav提供与ffmpeg input.mp4 -c复制输出中相同的效果。  我们＆＃39;重新从输入（input_format_context）读取并将其更改为另一个输出（output_format_context）。 </p><p>我们开始执行通常分配内存并打开输入格式。对于此特定情况，我们＆＃39;重新打开输入文件并为输出文件分配内存。</p><p> if（（ret = avformat_open_input（＆amp; input_format_context，in_filename，null，null））＆lt; 0）{fprintf（stderr，＆＃34;无法打开输入文件＆＃39;％s＆＃39;＆＃34 ;, in_filename）;转到结束;如果（（ret = avformat_find_stream_info（input_format_context，null））＆lt; 0）{fprintf（stderr，＆＃34;未能检索输入流信息＆＃34;）;转到结束;} avformat_alloc_output_context2（＆amp; output_format_context，null，null，out_filename）; if（！output_format_context）{fprintf（stderr，＆＃34;无法创建输出上下文\ n＆＃34;）; ret = verror_unknown;转到结束;}</p><p> 我们＆＃39;重新remux只能remux的reglys的流，所以我们＆＃39;重新举行什么流我们＆＃39; ll使用索引数组。</p><p>  就在我们分配所需的内存之后，我们＆＃39;重新循环在整个流中，每个我们需要使用avformat_new_stream函数创建新的输出格式上下文。请注意，我们标记aren＆＃39; t视频，音频或字幕的所有流，所以我们可以跳过它们。</p><p> for（i = 0; i＆lt; input_format_context-＆gt; nb_streams; i ++）{avstream * out_stream; avstream * in_stream = input_format_context-＆gt;溪流[i]; avcodecparameters * in_codecpar = in_stream-＆gt; Codecpar; if（in_codecpar-＆gt; codec_type！= avmedia_type_audio＆amp;＆amp; in_codecpar-＆gt; codec_type！= avmedia_type_video＆amp;＆amp; in_codecpar-＆gt; codec_type！= avmedia_type_subtitle）{streams_list [i] =  -  1;继续; streams_list [i] = stream_index ++; OUT_STREAM = AVFORMAT_NEW_STREAM（output_format_context，null）; if（！out_stream）{fprintf（stderr，＆＃34;失败的分配输出流\ n＆＃34;）; ret = verror_unknown;转到结束; } ret = avcodec_parameters_copy（out_stream-＆gt; codecpar，in_codecpar）; if（ret <0）{fprintf（stderr，＆＃34;未能复制编解码器参数\ n＆＃34;）;转到结束; }}</p><p>  if（！（output_format_context-＆gt; format-＆gt; flags＆amp; avfmt_nofile））{ret = avio_open（＆amp; output_format_context-＆gt; pb，out_filename，avio_flag_write）; if（ret＆lt; 0）{fprintf（stderr，＆＃34;无法打开输出文件＆＃39;％s＆＃39;＆＃34;，out_filename）;转到结束; RET = avformat_write_header（output_format_context，null）; if（ret＆lt; 0）{fprintf（stderr，＆＃34;打开输出文件时发生错误\ n＆＃34;）;转到结束;}</p><p> 之后，我们可以从我们的输出流中的输入中复制流，数据包。我们＆＃39; LL循环在它具有数据包（AV_Read_Frame）时，对于每个数据包，我们需要重新计算PTS和DTS，以最终将其写入（AV_Interleaved_Write_Frite_Frame）到我们的输出格式上下文。 </p><p>虽然（1）{avstream * in_stream，* out_stream; RET = AV_READ_FRAME（INPUT_FORMAT_CONTEXT，＆amp;数据包）; if（et＆lt; 0）破裂; in_stream = input_format_context-＆gt; 流[数据包。 stream_index]; if（数据包。stream_index＆gt; = number_of_streams || streams_list [数据包。stall_index]＆lt; 0）{av_packet_unref（＆amp; packet）; 继续; }数据包。 stream_index = streams_list [数据包。 stream_index]; OUT_STREAM = OUTPUT_FORMAT_CONTEXT-＆gt; 流[数据包。 stream_index]; / *复制数据包* /包。 pts = av_rescale_q_r.  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/leandromoreira/ffmpeg-libav-tutorial">https://github.com/leandromoreira/ffmpeg-libav-tutorial</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图书馆/">#图书馆</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/library/">#library</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ffmpeg/">#ffmpeg</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1060601.html"><img src="http://img2.diglog.com/img/2021/5/thumb_84894bb4d07bf999dfa899add06ea92f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1060601.html">Z3教程 </a></div><span class="my_story_list_date">2021-5-5 20:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1059165.html"><img src="http://img2.diglog.com/img/2021/4/thumb_8ebbc36c633b1a3604f6c64ba4740a86.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1059165.html">可执行教程 </a></div><span class="my_story_list_date">2021-4-19 23:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1057377.html"><img src="http://img2.diglog.com/img/2021/4/thumb_ce848ee0f53020caf36ca8e3b6ce7955.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057377.html">用于图像分割的掩模RCNN实现 - 教程 </a></div><span class="my_story_list_date">2021-4-10 4:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1055445.html"><img src="http://img2.diglog.com/img/2021/4/thumb_fd187418a871e01f51259254114e0ff0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1055445.html">警方称他们在youtube上发现了黑手党逃亡，发布烹饪教程 </a></div><span class="my_story_list_date">2021-4-1 20:27</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>