<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>惯用的生锈？ 实施二进制搜索（第2部分） Idiomatic Rust? Implementing binary search (part 2)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Idiomatic Rust? Implementing binary search (part 2)<br/>惯用的生锈？ 实施二进制搜索（第2部分） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-13 08:51:23</div><div class="page_narrow text-break page_content"><p>This is a follow-up to the  original article where I looked at a few waysto improve my Rust implementation of Binary search - with a focus on removing &#39;mistakes&#39;and making it as &#39;idiomatic&#39; as possible.</p><p>这是原始文章的后续行动，我看几种Wathsto提高了我的二进制搜索的生锈实施 - 重点删除＆＃39;错误＆＃39;并使它成为＆＃39;惯用＆＃39;尽可能。</p><p> The most common piece of feedback I received on the first articlewas related to the comparison between the  middle value and  high/ low cursors.</p><p> 我在第一个与中间值和高/低光标之间的比较相关的第一篇文章中收到的最常见的反馈。</p><p>  In my  original Tweet (even before the first article) I had presented a variant of the algorithmthat used pattern matching for this comparison via Rust&#39;s  match construct.</p><p>  在我的原始推文中（甚至在第一篇文章之前）我介绍了通过生锈＆＃39; s匹配构造对此比较的算法的变种。</p><p>  rust  pub   fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; i32&gt; {  let  mut low:  i32 =  0;  let  mut high:  i32 = items.len()  as  i32 -  1;  while low &lt;= high {  let middle = (((high + low) /  2)  as  f64).floor()  as  i32;  match items.get(middle  as  usize) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; high = middle -  1,  Some(current)  if *current &lt; k =&gt; low = middle +  1, _ =&gt; {} } }  None}</p><p>  铁锈酒吧fn（k：i32，项目：＆amp; [i32]） - ＆gt;选择＆lt; I32＆gt; {让MUT LOW：I32 = 0;让MUT HIGH：I32 = items.len（）作为i32  -  1;虽然低<lt; =高{让中间=（（（高+低）/ 2）为f64）.floor（）作为i32;匹配项目。重点（中间为大小）{某些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt;高=中间 -  1，一些（电流）如果*电流＆lt; k =＆gt;低=中间+ 1，_ =＆gt; {} } }  没有任何}</p><p> If we apply the feedback from the  first article to this implementation,we&#39;d end up with the following - which is just a bit cleaner since it removes some casting along with the manual&#39;flooring&#39; I was originally doing.</p><p> 如果我们将第一篇文章的反馈应用于这一实施，我们将＆＃39＆＃39; D结束了以下 - 这只是一个灰尘，因为它可以消除一些铸件以及手册＆＃39;地板＆＃39;我最初在做。</p><p> rust  pub   fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  let  mut low:  usize =  0;  let  mut high:  usize = items.len() -  1;  while low &lt;= high {  let middle = (high + low) /  2;  match items.get(middle) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None; }; high = middle -  1 }  Some(current)  if *current &lt; k =&gt; { low = middle +  1; } _ =&gt; {} } }  None}</p><p> 铁锈酒吧fn（k：i32，项目：＆amp; [i32]） - ＆gt;选择＆lt; Usize＆gt; {让MUT低：USIZE = 0;让mut高：Usize = items.len（） -  1;虽然低<lt; =高{让中间=（高+低）/ 2;匹配项目。重点（中间）{一些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无; };高=中间 -  1}如果*电流＆lt; k =＆gt; {Low =中间+ 1; } _ =＆gt; {} } }  没有任何}</p><p>  This is where it became a bit complicated. I originally received some feedback on Twitterthat suggested because I&#39;m not using the return value of the  match block in any of the arms, along withthe fact that I&#39;m only using it to mutate the high/low cursors, that this could be deemed  not idiomatic Rust...</p><p>  这是它变得有点复杂的地方。我最初接受了Twitterthat的一些反馈，建议，因为I＆＃39; m不使用任何臂中的匹配块的返回值，以及我＆＃39; m只使用它来突变高/低光标，这这可能被视为不惯然的生锈...... </p><p> I fully understood that feedback, and to rectify the match could be written like so:</p><p>我完全明白反馈，并纠正匹配可以写得如此：</p><p> rust  match items.get(middle  as  usize) {  Some(current)  if *current == k =&gt; {  return  Some(middle); },  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1; },  Some(current)  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}}</p><p> Rust匹配项目。（中间为大小）{一些（当前）如果* Current == k =＆gt; {返回一些（中间）; }，一些（当前）如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无};高=中间 -  1; }，某些（电流）如果*电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}}</p><p> Now each match arm has no trailing expression, possibly making it clearer to thenext developer that we didn&#39;t intend on returning a value here from the match block.</p><p> 现在，每个匹配臂都没有尾随表达式，可能会更清楚我们在那里＆＃39; t打算从匹配块返回这里的值。</p><p>    1: Rust makes heavy use of pattern matching, and whilst  match is technically an expressionitself (and therefore can be used as a value), I don&#39;t think it&#39;s an issue if it&#39;s not  always used as a value?.</p><p>    1：rust致力于使用模式匹配，而匹配在技术上是技术性的（因此可以用作一个值），我不觉得它觉得它＆＃39;如果它并非总是如此用作价值？</p><p> 2: It seems like it would be more of an issue if each arm of the match had different semantics. For example, if onearm returned a value and another didn&#39;t. This would make the implementation inconsistent,and the viewpoint may hold more water, but Rust&#39;s type system will not allow this anyway since eacharm of the  match  must return the same value.</p><p> 2：如果匹配的每个ARM具有不同的语义，那似乎会更多的问题。例如，如果Onearm返回一个值，另一个Didn＆＃39; t。这将使实施不一致，并且该观点可以持有更多的水，但是Rust＆＃39; s型系统无论如何都不会允许这种情况，因为匹配的每个arm必须返回相同的值。</p><p> For those 2 reasons, the rest of this post will focus on further improving our algorithmto fully utilize  match - but please reach out on  Twitter if you disagree, I&#39;d loveto continue the conversation 😀</p><p> 对于那些两个原因，这篇文章的其余部分将专注于进一步改进我们的算法，充分利用匹配 - 但如果你不同意，我会在Twitter上伸出援手，我＆＃39; D Loveve继续谈话♥</p><p>   Our algorithm is searching within a slice of  i32 values. On each iteration we are accessing a value from the slicewith the  .get() method. This was done for safety since a runtime panic can occur if you attemptan index-access with a value that would be out-of-bounds.</p><p>   我们的算法在I32值的一片中搜索。在每次迭代中，我们正在访问.get（）方法的Slice中的值。这是为了安全完成，因为如果您尝试索引 - 使用缺失的值，可以发生运行时恐慌。 </p><p> rust   fn  () {  let items =  vec![ 10,  40,  90];  let forth_item = items[ 3];  println!( &#34;{:?}&#34;, forth_item)  // &#39;main&#39; panicked at &#39;index out of bounds:  // the len is 3 but the index is 3&#39;}</p><p>rust fn（）{让项目= vec！[10,40,90];让rest_item =项目[3]; println！（＆＃34; {：？}＆＃34;，thath_item）//＃39; main＆＃39; ＆＃39恐慌;索引超出界限：// len是3但索引是3＆＃39;}</p><p> rust   fn  () {  let items =  vec![ 10,  40,  90];  let first_item = items.get( 0);  println!( &#34;{:?}&#34;, first_item);  // prints `Some(10)`  let forth_item = items.get( 3);  println!( &#34;{:?}&#34;, forth_item)  // prints `None`}</p><p> rust fn（）{让项目= vec！[10,40,90];让First_Item = Items.get（0）; println！（＆＃34; {：？}＆＃34;，first_item）; //打印`某些（10）`letth_item = items.get（3）; println！（＆＃34; {：？}＆＃34;，thath_item）//打印`none`}</p><p> So the second way of accessing a value may be safer, but it comes at the cost of an additional layerof indirection in the form of that  Option type.</p><p> 因此，访问值的第二种方式可以更安全，但它以该选项类型的形式的额外层间间接以成本为代价。</p><p> rust  // return type is Option&lt;i32&gt; let item = items.get( 4) // return type is i32, but may panic let item = items[ 4]</p><p> Rust //返回类型是选项＆lt; i32＆gt;让项目= items.get（4）//返回类型是i32，但可能会恐慌让项目=项目[4]</p><p> This affected our algorithm in the  first article since we needed to use an   if letexpression to expose the current value via the  Some(current) pattern.</p><p> 这在第一篇文章中影响了我们的算法，因为我们需要使用如果LetExpression通过某些（当前）模式暴露当前值。</p><p> rust  // ↓↓↓↓↓↓↓↓↓↓↓↓ if  let  Some(current) = items.get(middle) {  if *current == k {  // snip }  if *current &gt; k {  // snip }  if *current &lt; k {  // snip }}</p><p> rust //↓↓↓↓↓↓↓↓↓↓↓↓如果让某些（当前）= items.get（中间）{if * current == k {// snip}如果* current＆gt; k {// snip}如果*当前＆lt; k {// snip}}</p><p> So, to remove the  Option and therefore also remove  .get() and  Some(current), we&#39;d need to be mathematicallysure to be within the slice bounds - otherwise we&#39;d get a runtime panic! Well it turns out that our originalalgorithm was actually doing all the checks we need - it always ensures the next index access is above zero and is belowthe max length of the slice.</p><p> 因此，要删除选项，因此还删除了.get（）和一些（当前），我们需要在数学上进行数学上的界限 - 否则我们＆＃39; d and to and and＃39;事实证明，我们的原始算法实际上正在执行我们所需的所有检查 - 它始终确保下一个索引访问高于零，并且低于切片的最大长度。 </p><p> This means that in terms of the original article, we could&#39;ve replaced the  if let Some(current) with a simple indexaccess which makes the solution less syntactically noisy and is simpler overall.</p><p>这意味着在原始文章方面，我们可以＆＃39更换了如果让某些（当前）用一个简单的索引传播，这使得解决方案较少嘈杂并且整体更简单。</p><p> rust  // we know this won&#39;t panic since we control &#39;middle&#39; // ↓↓↓↓↓↓↓↓↓↓↓↓↓ let current = items[middle] if current == k {  // snip}</p><p> 生锈//我们知道这是赢得＆＃39;自从我们控制＆＃39;中间＆＃39; //↓↓↓↓↓↓↓↓↓↓↓↓↓当Current == k {// Snip}</p><p> Now we can be confident that a direct index access is always safe, since we control the  middle value, but how doesthis help us with the match expression mentioned previously?</p><p> 现在我们可以相信直接索引访问始终是安全的，因为我们控制了中间价值，但Doesthis如何帮助我们提到的匹配表达式？</p><p>  If all we did was take the  match expression from the beginning of this article, and remove the  Option as mentionedabove, we&#39;d end up with something that looked like this</p><p>  如果我们所做的一切都从本文的开头取出比赛表达式，并将选项删除为提到的，我们＆＃39; d最终得到了这样的东西</p><p> rust  // before match items.get(middle) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 },  Some(current)  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}} // after match items[middle] { current  if current == k =&gt; {  return  Some(middle); }, current  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, current  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}}</p><p> rust //在匹配项目之前。注（中间）{某些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无}; HIGH =中间 -  1}，如果*电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}} //匹配项目[中间] {当前电流== k =＆gt; {返回一些（中间）; }，当前if * current＆gt; k =＆gt; {如果中间== 0 {返回无};高=中间 -  1}，电流IF *电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}}</p><p> Which is barely even an improvement 🙁! If anything, I&#39;d say it&#39;s actually harder to read.</p><p> 这几乎甚至是一个改善♥！如果有的话，我＆＃39; d说它＆＃39实际上更难阅读。</p><p> It&#39;s missing the next big step, which is also another move towards more idiomatic Rust - and that&#39;s to take advantageof the fact that the  Ord trait is implemented for  i32 in the standard library.</p><p> 它缺少下一个大步骤，这也是另一个朝向更惯用的生锈 - 而且达到了ord特征在标准图书馆的i32实施的事实。 </p><p> The  Ord trait has a  .cmp(other) method which returns a variant of the  Ordering enum, it&#39;s definitionlooks like this...</p><p>ord特性有一个.cmp（其他）方法，它返回订购枚举的变体，它＆＃39; s定义列表...</p><p> rust  // std::cmp pub   trait  :  Eq +  PartialOrd&lt; Self&gt; {   fn  (&amp; self, other: &amp; Self) -&gt; Ordering;  // snip}</p><p> rust // std :: cmp pub特性：eq + partialord＆lt;自我＆gt; {FN（＆amp;自我，其他：＆amp; self） - ＆gt;订购; // Snip}</p><p>  rust   fn  () {  let first:  i32 =  1;  let second:  i32 =  3;  let result = first.cmp(&amp;second);  println!( &#34;result = {}&#34;, result)  // outputs `Less`, `Greater` or `Equal` respectively}</p><p>  rust fn（）{让第一：i32 = 1;让第二：i32 = 3;让结果= First.cmp（＆amp;第二）; println！（＆＃34;结果= {}＆＃34;结果）//输出`少，`更大的`或`等于}</p><p> Notice how this is consolidating 3 separate comparisons into a single method call -it removes the need to manually check  equal,  greater, and  less in an imperative style and instead it endsup being more  declarative since we&#39;re no longer defining the actual implementation.</p><p> 请注意，如何将3个单独的比较合并为单个方法调用 -  it删除手动检查等于的需要，更大，更少，更低，而是自我们＆＃39以来的更高的声明性;重新确定实际实现。</p><p> After the call to  .cmp(other) we now have a value which is equal to one of  Ordering&#39;s 3 enum variantsand this is where languages with Pattern Matching really shine since we can do a  match on the variant andsimplify our code quite a bit.</p><p> 调用后.CMP（其他）我们现在有一个值等于订购的一个值和＃39; S 3 Enum Variantsand，这是与模式匹配的语言非常闪耀，因为我们可以在变体上做匹配，并实现了匹配一点点。</p><p> rust  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, Ordering::Less =&gt; low = middle +  1}</p><p> 锈匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt; {如果中间== 0 {返回无}; high = middle  -  1}，订购::少=＆gt;低=中间+ 1}</p><p> Along with being a more declarative style, it&#39;s also much less noisy with far fewer things to mentally parse. 😇</p><p> 随着更宣言的风格，它＆＃39; S也远远少得多，令人沮丧地解析。 😇 </p><p> Also, since the matching on the  Ordering enum is exhaustive, we no-longer needthe empty  _ =&gt; {} as a final catch-all match arm either. 🙏</p><p>此外，由于订购枚举上的匹配是穷的，因此我们不再需要空_ =＆gt; {}作为最终捕获 - 所有匹配臂。 🙏</p><p> A final thing to note here is that since we&#39;re invoking a method implemented for the  Ord trait, it means thatour algorithm could be made more generic in the future to include searching for any type that implements  Ord, andnot just  i32 as in our example. This would make a great follow-on blog post, highlighting the power of traits in Rust, pleasereach out to me on  Twitter if you&#39;d like to see that post happen 🐦</p><p> 此处的最后一件事是因为＆＃39;重新调用为ord特征实现的方法，这意味着在将来可以更通用，以便在寻找实现ord的任何类型，而不是i32的算法我们的例子。这将使这是一个伟大的后续博客文章，突出了Rust的特征的力量，如果你喜欢看到这个帖子发生在Twitter上，请在Twitter上发出特征。</p><p>  After applying both improvements documented so far (removing  Option + doing a single comparison) we end up withthe following implementation - which is clearly a big improvement 👌.</p><p>  到目前为止申请两种改进后（去除选项+做单一比较），我们最终得到了以下实现 - 这显然是一个很大的改善♥。</p><p> rust use std::cmp::Ordering;  fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  if items.is_empty() {  return  None }  let  mut low:  usize =  0;  let  mut high:  usize = items.len() -  1;  while low &lt;= high {  let middle = (high + low) /  2;  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, Ordering::Less =&gt; low = middle +  1 } }  None}</p><p> Rust使用STD :: CMP ::订购; FN（k：I32，项目：＆amp; [I32]） - ＆gt;选择＆lt; Usize＆gt; {如果项目.is_empty（）{return none}让mut低：Usize = 0;让mut高：Usize = items.len（） -  1;虽然低<lt; =高{让中间=（高+低）/ 2;匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt; {如果中间== 0 {返回无}; high = middle  -  1}，订购::少=＆gt; Low = Middle + 1}}无}</p><p>  There are 2 lines in our implementation that still feel &#39;over-engineered&#39; - or rather, it feels likethey could be improved, or removed.</p><p>  我们的实施中有2条线条仍然感觉＆＃39;过度设计的＆＃39; - 或者相反，它感觉可能会改善或移除。</p><p> rust  // this is the opening check in the function if items.is_empty() {  return  None } // part of the `Greater` match arm, need to // ensure we don&#39;t subtract below zero if middle ==  0 {  return  None };</p><p> Frose //这是函数中的开头检查如果Items.Is_empty（）{返回None} //部分）需要//确保我们在中间==中的DON＆＃39; T减去低于零点0 {返回none};</p><p> To solve this, we need to address the core algorithm. If we define  high as the exclusive upper boundand only ever re-assign it to either the length of the slice at the start of the function, or to a subsequentmiddle value, we can be sure that we&#39;ll never decrease its value below zero, and therefore we can removeboth of the checks mentioned above.</p><p> 要解决此问题，我们需要解决核心算法。如果我们将高度定义为独占的上个边界，只需将其重新分配给函数开始时切片的长度，或者到后域值，我们可以确定我们＆＃39; ll永远不会减少它的值零，因此我们可以删除上面提到的检查。 </p><p> We&#39;d be ensuring that none of the mutable  usize cursors can ever drop below zero, and that would allow us to remove thosetwo manual checks.</p><p>我们＆＃39; D是确保没有一个可变的使用光标可以下降到零以下，这将允许我们删除Thosetwo手动检查。</p><p>  That leaves us with the following, which I&#39;m starting to feel happy aboutafter these 2 long blog posts &amp; the feedback I received on Twitter 🙏</p><p>  这让我们留下了以下内容，其中我开始感到快乐，这两个长的博客帖子＆amp;我在Twitter上收到的反馈🙏</p><p> rust use std::cmp::Ordering;  fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  let  mut low:  usize =  0;  let  mut high:  usize = items.len();  while low &lt; high {  let middle = (high + low) /  2;  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; high = middle, Ordering::Less =&gt; low = middle +  1 } }  None}</p><p> Rust使用STD :: CMP ::订购; FN（k：I32，项目：＆amp; [I32]） - ＆gt;选择＆lt; Usize＆gt; {让MUT低：USIZE = 0;让mut高：Usize = items.len（）;虽然低＆lt;高{让中间=（高+低）/ 2;匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt;高=中间，订购::少=＆gt; Low = Middle + 1}}无}</p><p>  This first visualization here shows how all the demos across both posts (apart from thefinal change) play out</p><p>  此处的第一次可视化展示了两个帖子中的所有演示（除了来自The File Change）的所有演示</p><p>  This next visualization shows how much simpler everything becomes when you have  highas the exclusive upper bound - fewer steps are taken overall. Also note how the  highcursor begins at 1 index higher than the end of the list, whereas previously it beganon the last element directly.</p><p>  下一个可视化显示，当您高分之类时，一切都变得更加简单，整体上占用了较少的步骤。另请注意HighCursor如何以比列表结尾的1索引开始，而先前则直接植入最后一个元素。</p><p>   A huge thanks to  Wiebe Cnossen and  Basile Henryfor providing the feedback that inspired this follow-up post.</p><p>   感谢Wiebe Cnossen和Pasile Henry for提供激发此后续帖子的反馈。</p><p>  I&#39;d love to hear any feedback or alternative ways to implement this algorithm in Rust - so please reachout on  Twitter if you have any thoughts 🦀</p><p>  我喜欢听到任何反馈或替代方法来实现这种算法 - 所以如果你有任何想法，请在Twitter上伸出 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shane-o.dev/blog/binary-search-rust-part-2">https://shane-o.dev/blog/binary-search-rust-part-2</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/binary/">#binary</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/匹配/">#匹配</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>