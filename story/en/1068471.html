<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>面向数据的设计或为什么您可以使用OOP（2009） Data-oriented design or why you might shoot yourself in the foot with OOP (2009)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Data-oriented design or why you might shoot yourself in the foot with OOP (2009)<br/>面向数据的设计或为什么您可以使用OOP（2009） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-29 22:42:44</div><div class="page_narrow text-break page_content"><p>Picture this: Toward the end of the development cycle, your game crawls, but you don’t see any obvious hotspots in the profiler. The culprit? Random memory access patterns and constant cache misses. In an attempt to improve performance, you try to parallelize parts of the code, but it takes heroic efforts, and, in the end, you barely get much of a speed-up due to all the synchronization you had to add. To top it off, the code is so complex that fixing bugs creates more problems, and the thought of adding new features is discarded right away. Sound familiar?</p><p>图片：在开发周期结束时，您的游戏爬行，但您没有看到探查器中的任何明显的热点。罪魁祸首？随机内存访问模式和常量缓存未命中。为了尝试提高性能，您尝试并行化代码的部分，但它需要英勇的工作，并且到底，由于您必须添加的所有同步，您几乎没有速度速度。要将其关闭，代码非常复杂，修复错误会产生更多问题，并立即丢弃添加新功能的想法。听起来有点熟？</p><p> That scenario pretty accurately describes almost every game I’ve been involved with for the last 10 years. The reasons aren’t the programming languages we’re using, nor the development tools, nor even a lack of discipline. In my experience, it’s object- oriented programming (OOP) and the culture that surrounds it that is in large part to blame for those problems. OOP could be hindering your project rather than helping it!</p><p> 这种情况非常准确地描述了我过去10年所涉及的每场比赛。原因不是我们正在使用的编程语言，也不是开发工具，也没有缺乏纪律。在我的经验中，它是面向对象的编程（OOP）和围绕它的文化，这在很大程度上归咎于这些问题。 OOP可能会阻碍你的项目而不是帮助它！</p><p>  OOP is so ingrained in the current game development culture that it’s hard to think beyond objects when thinking about a game. After all, we’ve been creating classes representing vehicles, players, and state machines for many years. What are the alternatives? Procedural programming? Functional languages? Exotic programming languages?</p><p>  OOP在目前的游戏开发文化中被加入，在考虑比赛时很难在物体上思考。毕竟，我们一直在创建多年来代表车辆，玩家和国家机器的课程。什么是替代品？程序编程？功能语言？异国情调的编程语言？</p><p> Data-oriented design is a different way to approach program design that addresses all these problems. Procedural programming focuses on procedure calls as its main element, and OOP deals primarily with objects. Notice that the main focus of both approaches is code: plain procedures (or functions) in one case, and grouped code associated with some internal state in the other. Data-oriented design shifts the perspective of programming from objects to the data itself: The type of the data, how it is laid out in memory, and how it will be read and processed in the game.</p><p> 以数据为导向的设计是一种方法，可以解决解决所有这些问题的程序设计。程序编程侧重于过程调用作为其主要元素，OOP主要与对象交易。请注意，这两种方法的主要焦点是代码：在一个案例中的普通程序（或函数），并在另一个内部状态相关联的分组代码。面向数据的设计将编程从对象的编程视角转移到数据本身：数据的类型，如何在内存中布置，以及如何在游戏中读取和处理。</p><p> Programming, by definition, is about transforming data: It’s the act of creating a sequence of machine instructions describing how to process the input data and create some specific output data. A game is nothing more than a program that works at interactive rates, so wouldn’t it make sense for us to concentrate primarily on that data instead of on the code that manipulates it?</p><p> 根据定义编程是关于转换数据：它是创建一系列机器指令的行为，描述了如何处理输入数据并创建一些特定的输出数据。游戏只不过是一个以交互式率有效的程序，因此我们主要在那个数据上集中注意力而不是操纵它的代码是有意义的？</p><p> I’d like to clear up potential confusion and stress that data-oriented design does not imply that something is data- driven. A data-driven game is usually a game that exposes a large amount of functionality outside of code and lets the data determine the behavior of the game. That is an orthogonal concept to data-oriented design, and can be used with any type of programming approach.</p><p> 我想清理潜在的混乱和压力，以至于数据导向的设计并不意味着某些东西是数据驱动的。数据驱动的游戏通常是一个游戏，该游戏在代码之外暴露大量功能，并允许数据确定游戏的行为。这是对数据面向设计的正交概念，并且可以与任何类型的编程方法一起使用。</p><p>  If we look at a program from the data point of view, what does the ideal data look like? It depends on the data and how it’s used. In general, the ideal data is in a format that we can use with the least amount of effort. In the best case, the format will be the same we expect as an output, so the processing is limited to just copying that data. Very often, our ideal data layout will be large blocks of contiguous, homogeneous data that we can process sequentially. In any case, the goal is to minimize the amount of transformations, and whenever possible, you should bake your data into this ideal format offline, during your asset-building process.</p><p>  如果我们从数据的角度查看程序，理想的数据是什么样的？这取决于数据以及它是如何使用的。通常，理想数据是我们可以与最少量的努力一起使用的格式。在最佳情况下，格式将与输出相同，因此处理仅限于刚刚复制该数据。非常经常，我们理想的数据布局将是我们可以顺序地处理的大块连续性的均匀数据块。在任何情况下，目标是最大限度地减少转换量，并尽可能最大限度地释放您的数据，在资产建设过程中脱离此理想格式。 </p><p> Because data-oriented design puts data first and foremost, we can architect our whole program around the ideal data format. We won’t always be able to make it exactly ideal (the same way that code is hardly ever by-the-book OOP), but it’s the primary goal to keep in mind. Once we achieve that, most of the problems I mentioned at the beginning of the column tend to melt away (more about that in the next section).</p><p>由于以数据为导向的设计首先将数据置于数据，我们可以围绕理想的数据格式构建整个程序。我们将永远无法使其完全理想（同样的方式，代码几乎没有逐字oop），但这是牢记的主要目标。一旦我们实现了这一点，列在列开始时提到的大多数问题都倾向于融化（更多关于下一部分的信息）。</p><p> When we think about objects, we immediately think of trees— inheritance trees, containment trees, or message-passing trees, and our data is naturally arranged that way. As a result, when we perform an operation on an object, it will usually result in that object in turn accessing other objects further down in the tree. Iterating over a set of objects performing the same operation generates cascading, totally different operations at each object (see Figure 1a).</p><p> 当我们考虑对象时，我们立即想到树木继承树，遏制树或消息传递树，我们的数据自然地排列。因此，当我们对对象执行操作时，它通常会导致该对象依次进一步访问树中的其他对象。在执行相同操作的一组对象上迭代，在每个对象处生成级联，完全不同的操作（参见图1A）。</p><p> To achieve the best possible data layout, it’s helpful to break down each object into the different components, and group components of the same type together in memory, regardless of what object they came from. This organization results in large blocks of homogeneous data, which allow us to process the data sequentially (see Figure 1b). A key reason why data-oriented design is so powerful is because it works very well on large groups of objects. OOP, by definition, works on a single object. Step back for a minute and think of the last game you worked on: How many places in the code did you have only one of something? One enemy? One vehicle? One pathfinding node? One bullet? One particle? Never! Where there’s one, there are many. OOP ignores that and deals with each object in isolation. Instead, we can make things easy for us and for the hardware and organize our data to deal with the common case of having many items of the same type.</p><p> 为了实现最佳的数据布局，将每个对象分解为不同的组件，以及在内存中的同一类型的组组件，无论它们来自哪些对象，都会有助于它们。该组织导致大块的同类数据块，允许我们顺序处理数据（见图1B）。一种关键原因，为什么数据导向设计如此强大，是因为它在大群对象上工作得很好。 OOP，根据定义，在一个对象上工作。退后一分钟，想想你工作的最后一场比赛：你的代码中有多少个地方你只有一个东西？一个敌人？一辆车？一个路径文件节点？一个子弹？一个颗粒？绝不！哪里有一个，有很多。 OOP忽略了它并以隔离的每个对象处理。相反，我们可以轻松地为我们和硬件制作东西，并组织我们的数据来处理具有许多相同类型的常见情况。</p><p> Does this sound like a strange approach? Guess what? You’re probably already doing this in some parts of your code: The particle system! Data-oriented design is turning our whole codebase into a gigantic particle system. Perhaps a name for this approach that would be more familiar to game programmers would have been particle-driven programming.</p><p> 这听起来像是一种奇怪的方法吗？你猜怎么着？您可能已经在代码的某些部分中执行此操作：粒子系统！以数据为导向的设计将我们的整个CodeBase转化为巨大的粒子系统。也许是游戏程序员更熟悉的这种方法的名称将是粒子驱动的编程。</p><p>  hinking about data first and architecting the program based on that brings along lots of advantages.</p><p>  关于数据的第一和架构程序基于这促成了大量优势。</p><p>  These days, there’s no way around the fact that we need to deal with multiple cores. Anyone who has tried taking some OOP code and parallelizing it can attest how difficult, error prone, and possibly not very efficient that is. Often you end up adding lots of synchronization primitives to prevent concurrent access to data from multiple threads, and usually a lot of the threads end up idling for quite a while waiting for other threads to complete. As a result, the performance improvement can be quite underwhelming.</p><p>  这些天，我们需要处理多个核心的事实。任何尝试使用一些OOP代码和并行化的人都可以证明易于困难，容易出错，并且可能不是很高效。通常，您最终添加了许多同步原语来防止从多个线程中并发访问数据，通常很多线程最终idling，相当于等待其他线程完成。结果，性能改善可能是非常强大的。</p><p> When we apply data-oriented design, parallelization becomes a lot simpler: We have the input data, a small function to process it, and some output data. We can easily take something like that and split it among multiple threads with minimal synchronization between them. We can even take it further and run that code on processors with local memory (like the SPUs on the Cell processor) without having to do anything differently.</p><p> 当我们应用数据设计时，并行化变得更简单：我们有输入数据，一个小功能来处理它，以及一些输出数据。我们可以轻松地采取类似的东西，并在多个线程中拆分，它们之间的同步最小。我们甚至可以进一步获取并在具有本地存储器的处理器上运行该代码（如单元处理器上的spus），而无需以不同的方式执行任何操作。 </p><p>  In addition to using multiple cores, one of the keys to achieving great performance in modern hardware, with its deep instruction pipelines and slow memory systems with multiple levels of caches, is having cache-friendly memory access. Data-oriented design results in very efficient use of the instruction cache because the same code is executed over and over. Also, if we lay out the data in large, contiguous blocks, we can process the data sequentially, getting nearly perfect data cache usage and great performance. Possible optimizations. When we think of objects or functions, we tend to get stuck optimizing at the function or even the algorithm level; Reordering some function calls, changing the sort method, or even re-writing some C code with assembly.</p><p>除了使用多个核心外，还有一个以实现现代硬件在现代硬件中实现良好性能的键，其深度指令管道和具有多个级别高速缓存的慢速存储器系统，具有缓存友好的内存访问。面向数据的设计导致非常有效地使用指令高速缓存，因为同一代码一遍又一遍地执行。此外，如果我们在大型连续块中铺设数据，我们可以顺序处理数据，近乎完美的数据缓存使用和卓越的性能。可能的优化。当我们考虑对象或函数时，我们倾向于在功能甚至算法水平时陷入优化;重新排序某些函数调用，更改排序方法，甚至用程序集重新编写一些C代码。</p><p> That kind of optimization is certainly beneficial, but by thinking about the data first we can step further back and make larger, more important optimizations. Remember that all a game does is transform some data (assets, inputs, state) into some other data (graphics commands, new game states). By keeping in mind that flow of data, we can make higher-level, more intelligent decisions based on how the data is transformed, and how it is used. That kind of optimization can be extremely difficult and time- consuming to implement with more traditional OOP methods.</p><p> 这种优化肯定是有益的，但通过首先思考数据，我们可以更进一步回来并制作更大，更重要的优化。请记住，所有游戏都可以将一些数据（资产，输入，状态）转换为其他数据（图形命令，新游戏状态）。通过牢记数据流动，我们可以基于如何转换数据的方式进行更高级别，更智能的决策，以及如何使用它。通过更传统的OOP方法实现，这种优化可能是非常困难和耗时的。</p><p>  So far, all the advantages of data-oriented design have been based around performance: cache utilization, optimizations, and parallelization. There is no doubt that as game programmers, performance is an extremely important goal for us. There is often a conflict between techniques that improve performance and techniques that help readability and ease of development. For example, re-writing some code in assembly language can result in a performance boost, but usually makes the code harder to read and maintain.</p><p>  到目前为止，所面向数据设计的所有优点都是基于性能：高速缓存利用率，优化和并行化。毫无疑问，作为游戏程序员，表现是我们的一个极为重要的目标。技术之间通常有冲突，从而提高了有助于可读性和易于发展的性能和技术。例如，在汇编语言中重写一些代码可能会导致性能提升，但通常会使代码更加难以读取和维护。</p><p> Fortunately, data-oriented design is beneficial to both performance and ease of development. When you write code specifically to transform data, you end up with small functions, with very few dependencies on other parts of the code. The codebase ends up being very “flat,” with lots of leaf functions without many dependencies. This level of modularity and lack of dependences makes understanding, replacing, and updating the code much easier.</p><p> 幸运的是，面向数据的设计有利于性能和易于发展。当您专门编写代码以转换数据时，您最终可以使用小功能，在代码的其他部分上具有很少的依赖性。 CodeBase最终非常“平坦”，具有许多叶片功能，没有许多依赖项。这种模块化级别和缺乏依赖性使得更容易理解，更换和更新代码。</p><p>  The last major advantage of data-oriented design is ease of testing. As we saw in the June and August Inner Product columns, writing unit tests to check object interactions is not trivial. You need to set up mocks and test things indirectly. Frankly, it’s a bit of a pain. On the other hand, when dealing directly with data, it couldn’t be easier to write unit tests: Create some input data, call the transform function, and check that the output data is what we expect. There’s nothing else to it. This is actually a huge advantage and makes code extremely easy to test, whether you’re doing test-driven development or just writing unit tests after the code.</p><p>  数据导向设计的最后一个主要优点是易于测试。正如我们在6月和8月内在产品栏中所看到的，写入单元测试以检查对象交互并不琐碎。您需要立即设置模拟和测试事物。坦率地说，这有点痛苦。另一方面，在直接与数据交换时，写入单元测试不能更容易：创建一些输入数据，调用变换函数，并检查输出数据是我们期望的。没有别的东西。这实际上是一个巨大的优势，并使代码非常易于测试，无论您是否正在进行测试驱动的开发或代码后的写入单元测试。</p><p>  Data-oriented design is not the silver bullet to all the problems in game development. It does help tremendously writing high-performance code and making programs more readable and easier to maintain, but it does come with a few drawbacks of its own.</p><p>  面向数据的设计不是游戏开发中所有问题的银弹。它确实有助于大量编写高性能代码，并使节目更加可读，更易于维护，但它确实有了几个缺点。</p><p> The main problem with data-oriented design is that it’s different from what most programmers are used to or learned in school. It requires turning our mental model of the program ninety degrees and changing how we think about it. It takes some practice before it becomes second-nature.</p><p> 有针对性设计的主要问题是它与大多数程序员在学校习惯或学习的不同之处。它需要将我们的精神模型转化为90度，并改变了我们如何考虑它。在它成为第二个性质之前，它需要一些练习。 </p><p> Also, because it’s a different approach, it can be challenging to interface with existing code, written in a more OOP or procedural way. It’s hard to write a single function in isolation, but as long as you can apply data-oriented design to a whole subsystem you should be able to reap a lot of the benefits.</p><p>此外，因为它是一种不同的方法，它可能具有挑战性地与现有代码接口，以更多OOP或程序方式编写。在隔离中写一个函数很难，但只要您可以将数据面向设计的设计应用于整个子系统，您应该能够获得很多好处。</p><p>  Enough of the theory and overview. How do you actually get started with data-oriented design? To start with, just pick a specific area in your code: navigation, animations, collisions, or something else. Later on, when most of your game engine is centered around the data, you can worry about data flow all the way from the start of a frame until the end.</p><p>  足够的理论和概述。您如何实际上启用数据设计设计？首先，只需选择代码中的特定区域：导航，动画，碰撞或其他东西。后来，当大多数游戏引擎都以数据为中心时，您可以从帧的开始直到结束时一直担心数据流。</p><p> The next step is to clearly identify the data inputs required by the system, and what kind of data it needs to generate. It’s OK to think about it in OOP terms for now, just to help us identify the data. For example, in an animation system, some of the input data is skeletons, base poses, animation data, and current state. The result is not “the code plays animations,” but the data generated by the animations that are currently playing. In this case, our outputs would be a new set of poses and an updated state.</p><p> 下一步是清楚地识别系统所需的数据输入，以及它需要生成的数据类型。现在可以在OOP条款中思考它，只是为了帮助我们识别数据。例如，在动画系统中，一些输入数据是骨架，基本姿势，动画数据和当前状态。结果不是“代码播放动画”，但是当前播放的动画生成的数据。在这种情况下，我们的输出将是一组新的姿势和更新状态。</p><p> It’s important to take a step further and classify the input data based on how it is used. Is it read- only, read-write, or write-only? That classification will help guide design decisions about where to store it, and when to process it depending on dependencies with other parts of the program.</p><p> 重要的是要进一步迈出一步并基于它的使用方式对输入数据进行分类。它是只读，读写还是只写？该分类将帮助指导关于存储它的位置的设计决策，以及何时根据程序的其他部分的依赖项来处理它。</p><p> At this point, stop thinking of the data required for a single operation, and think in terms of applying it to dozens or hundreds of entries. We no longer have one skeleton, one base pose, and a current state, and instead we have a block of each of those types with many instances in each of the blocks.</p><p> 此时，请停止思考单个操作所需的数据，并根据将其应用到几十或数百个条目方面进行思考。我们不再有一个骨架，一个基本姿势和当前状态，而是我们在每个块中具有许多实例的每个类型的块。</p><p> Think very carefully how the data is used during the transformation process from input to output. You might realize that you need to scan a particular field in a structure to perform a pass on the data, and then you need to use the results to do another pass. In that case, it might make more sense to split that initial field into a separate block of memory that can be processed independently, allowing for better cache utilization and potential parallelization. Or maybe you need to vectorize some part of the code, which requires fetching data from different locations to put it in the same vector register. In that case, that data can be stored contiguously so vector operations can be applied directly, without any extra transformations.</p><p> 非常仔细地仔细考虑如何在转换过程中使用数据从输入到输出。您可能会意识到您需要在结构中扫描特定字段以执行数据的传递，然后您需要使用结果进行另一个传递。在这种情况下，将初始字段拆分为可以独立处理的单独存储器块可能更有意义，允许更好的高速缓存利用率和潜在的并行化。或者也许您需要向量化代码的某些部分，这需要从不同位置获取数据以将其放入相同的向量寄存器中。在这种情况下，可以连续地存储数据，使得可以直接应用矢量操作，而没有任何额外的变换。</p><p> Now you should have a very good understanding of your data. Writing the code to transform it is going to be much simpler. It’s like writing code by filling in the blanks. You’ll even be pleasantly surprised to realize that the code is much simpler and smaller than you thought in the first place, compared to what the equivalent OOP code would have been.</p><p> 现在，您应该对您的数据非常了解。编写代码转换它会更简单。这就像通过填写空白来编写代码。与相同的OOP代码所在的相比，您甚至会感到惊喜地意识到代码比在第一位置更简单和更小。 </p><p> If you think back about most of the topics we’ve covered in this column over the last year, you’ll see that they were all leading toward this type of design. Now it’s the time to be careful about how the data is aligned (Dec 2008 and Jan 2009), to bake data directly into an input format that you can use efficiently (Oct and Nov 2008), or to use non- pointer references between data blocks so they can be easily relocated (Sept 2009).</p><p>如果您思考过去一年的大部分主题，您会发现他们都领导了这种类型的设计。现在是时候要注意数据如何对齐（2008年12月和2009年12月），以便将数据直接烘烤到您可以有效使用的输入格式（OCT和2008年11月），或者使用数据之间的非指针引用块，因此它们可以很容易地重新安置（9月2009年9月）。</p><p>  Does this mean that OOP is useless and you should never apply it in your programs? I’m not quite ready to say that. Thinking in terms of objects is not detrimental when there is only one of each object (a graphics device, a log manager, etc) although in that case you might as well write it with simpler C-style functions and file-level static data. Even in that situation, it’s still important that those objects are designed around transforming data.</p><p>  这是否意味着OOP是无用的，你永远不应该在你的程序中应用它？我不准备好这么做。当对象的思考时，当每个对象（图形设备，日志管理器等中的一个中只有一个时，虽然在这种情况下，但您可能会用简单的C样式函数和文件级静态数据写入。即使在这种情况下，这些对象仍然是在转换数据中设计的。</p><p> Another situation where I still find myself using OOP is GUI systems. Maybe it’s because you’re working with a system that is already designed in an object-oriented way, or maybe it’s because performance and complexity are not crucial factors with GUI code. In any case, I much prefer GUI APIs that are light on inheritance and use containment as much as possible (Cocoa and CocoaTouch are good examples of this). It’s very possible that a data-oriented GUI system could be written for games that would be a pleasure to work with, but I haven’t seen one yet.</p><p> 我仍然发现自己使用OOP的另一个情况是GUI系统。也许是因为你正在使用已经以面向对象方式设计的系统，或者可能是因为性能和复杂性并不是与GUI代码的重要因素。在任何情况下，我更喜欢亮起的GUI API，并尽可能多地使用遏制（Cocoa和Cocoatouch是良好的例子）。这是可以编写的数据导向的GUI系统，以便与之合作，但我还没有见过。</p><p> Finally, there’s nothing stopping you from still having a mental picture of objects if that’s the way you like to think about the game. It’s just that the enemy entity won’t be all in the same physical location in memory. Instead, it will be split up into smaller subcomponents, each one forming part of a larger data table of similar components.</p><p> 最后，如果这是你喜欢考虑游戏的方式，那么没有什么能阻止你的物体的心理图片。这只是敌人实体不会在内存中的相同物理位置。相反，它将被分成较小的子组件，每个子组件，每个形成类似组件的较大数据表的一部分。</p><p> Data-oriented design is a bit of a departure from traditional programming approaches, but by always thinking about the data and how it needs to be transformed, you’ll be able to reap huge benefits both in terms of performance and ease of development.</p><p> 以数据为导向的设计有点偏离传统的编程方法，而是始终思考数据以及如何转换，您将能够在性能和易于发展方面获得巨大的利益。</p><p> Thanks to Mike Acton and Jim Tilander for challenging my ideas over the years and for their feedback on this article.</p><p> 感谢Mike Acton和Jim Tilander多年来挑战我的想法，并为他们的反馈提供了对本文的反馈。</p><p> Picture this: Toward the end of the development cycle, your game crawls, but you don’t see any obvious hotspots in the profiler. The culprit? Random memory access patterns and constant cache misses. In an attempt to improve performance, you try to parallelize parts of the code, but it takes heroic efforts, and, in the end, you barely get much of a speed-up due to all the synchronization you had to add. To top it off, the code is so complex that fixing bugs creates more problems, and the thought of adding new features is discarded right away. Sound familiar?</p><p> 图片：在开发周期结束时，您的游戏爬行，但您没有看到探查器中的任何明显的热点。罪魁祸首？随机内存访问模式和常量缓存未命中。为了尝试提高性能，您尝试并行化代码的部分，但它需要英勇的工作，并且到底，由于您必须添加的所有同步，您几乎没有速度速度。要将其关闭，代码非常复杂，修复错误会产生更多问题，并立即丢弃添加新功能的想法。听起来有点熟？ </p><p> That scenario pretty accurately describes almost every game I’ve been involved with for the last 10 years. The reasons aren’t the programming languages we’re using, nor the development tools, nor even a lack of discipline. In my experience, it’s object- oriented programming (OOP) and the culture that surrounds it that is in large part to blame for those problems. OOP could be hindering your project rather than helping it!</p><p>这种情况非常准确地描述了我过去10年所涉及的每场比赛。原因不是我们正在使用的编程语言，也不是开发工具，也没有缺乏纪律。在我的经验中，它是面向对象的编程（OOP）和围绕它的文化，这在很大程度上归咎于这些问题。 OOP可能会阻碍你的项目而不是帮助它！</p><p>  OOP is so ingrained in the current game development culture that it’s hard to think beyond objects when thinking about a game. After all, we’ve been creating classes representing vehicles, players, and state machines for many years. What are the alternatives? Procedural programming? Functional languages? Exotic programming languages?</p><p>  OOP在目前的游戏开发文化中被加入，在考虑比赛时很难在物体上思考。毕竟，我们一直在创建多年来代表车辆，玩家和国家机器的课程。什么是替代品？程序编程？功能语言？异国情调的编程语言？</p><p> Data-oriented design is a different way to approach program design that addresses all these problems. Procedural programming focuses on procedure calls as its main element, and OOP deals primarily with objects. Notice that the main focus of both approaches is code: plain procedures (or functions) in one case, and grouped code associated with some internal state in the other. Data-oriented design shifts the perspective of programming from objects to the data itself: The type of the data, how it is laid out in memory, and how it will be read and processed in the game.</p><p> 以数据为导向的设计是一种方法，可以解决解决所有这些问题的程序设计。程序编程侧重于过程调用作为其主要元素，OOP主要与对象交易。请注意，这两种方法的主要焦点是代码：在一个案例中的普通程序（或函数），并在另一个内部状态相关联的分组代码。面向数据的设计将编程从对象的编程视角转移到数据本身：数据的类型，如何在内存中布置，以及如何在游戏中读取和处理。</p><p> Programming, by definition, is about transforming data: It’s the act of creating a sequence of machine instructions describing how to process the input data and create some specific output data. A game is nothing more than a program that works at interactive rates, so wouldn’t it make sense for us to concentrate primarily on that data instead of on the code that manipulates it?</p><p> 根据定义编程是关于转换数据：它是创建一系列机器指令的行为，描述了如何处理输入数据并创建一些特定的输出数据。游戏只不过是一个以交互式率有效的程序，因此我们主要在那个数据上集中注意力而不是操纵它的代码是有意义的？</p><p> I’d like to clear up potential confusion and stress that data-oriented design does not imply that something is data- driven. A data-driven game is usually a game that exposes a large amount of functionality outside of code and lets the data determine the behavior of the game. That is an orthogonal concept to data-oriented design, and can be used with any type of programming approach.</p><p> 我想清理潜在的混乱和压力，以至于数据导向的设计并不意味着某些东西是数据驱动的。数据驱动的游戏通常是一个游戏，该游戏在代码之外暴露大量功能，并允许数据确定游戏的行为。这是对数据面向设计的正交概念，并且可以与任何类型的编程方法一起使用。</p><p>   If we look at a program from the data point of view, what does the ideal data look like? It depends on the data and how it’s used. In general, the ideal data is in a format that we can use with the least amount of effort. In the best case, the format will be the same we expect as an output, so the processing is limited to just copying that data. Very often, our ideal data layout will be large blocks of contiguous, homogeneous data that we can process sequentially. In any case, the goal is to minimize the amount of transformations, and whenever possible, you should bake your data into this ideal format offline, during your asset-building process.</p><p>   如果我们从数据的角度查看程序，理想的数据是什么样的？这取决于数据以及它是如何使用的。通常，理想数据是我们可以与最少量的努力一起使用的格式。在最佳情况下，格式将与输出相同，因此处理仅限于刚刚复制该数据。非常经常，我们理想的数据布局将是我们可以顺序地处理的大块连续性的均匀数据块。在任何情况下，目标是最大限度地减少转换量，并尽可能最大限度地释放您的数据，在资产建设过程中脱离此理想格式。</p><p> Because data-oriented design puts data first and foremost, we can architect our whole program around the ideal data format. We won’t always be able to make it exactly ideal (the same way that code is hardly ever by-the-book OOP), but it’s the primary goal to keep in mind. Once we achieve that, most of the problems I mentioned at the beginning of the column tend to melt away (more about that in the next section).</p><p> 由于以数据为导向的设计首先将数据置于数据，我们可以围绕理想的数据格式构建整个程序。我们将永远无法使其完全理想（同样的方式，代码几乎没有逐字oop），但这是牢记的主要目标。一旦我们实现了这一点，列在列开始时提到的大多数问题都倾向于融化（更多关于下一部分的信息）。 </p><p> When we think about objects, we immediately think of trees— inheritance trees, containment trees, or message-passing trees, and our data is naturally arranged that way. As a result, when we perform an operation on an object, it will usually result in that object in turn accessing other objects further down in the tree. Iterating over a set of objects performing the same operation generates cascading, totally different operations at each object (see Figure 1a).</p><p>当我们考虑对象时，我们立即想到树木继承树，遏制树或消息传递树，我们的数据自然地排列。因此，当我们对对象执行操作时，它通常会导致该对象依次进一步访问树中的其他对象。在执行相同操作的一组对象上迭代，在每个对象处生成级联，完全不同的操作（参见图1A）。</p><p>  To achieve the best possible data layout, it’s helpful to break down each object into the different components, and group components of the same type together in memory, regardless of what object they came from. This organization results in large blocks of homogeneous data, which allow us to process the data sequentially (see Figure 1b). A key reason why data-oriented design is so powerful is because it works very well on large groups of objects. OOP, by definition, works on a single object. Step back for a minute and think of the last game you worked on: How many places in the code did you have only one of something? One enemy? One vehicle? One pathfin</p><p>  为了实现最佳的数据布局，将每个对象分解为不同的组件，以及在内存中的同一类型的组组件，无论它们来自哪些对象，都会有助于它们。该组织导致大块的同类数据块，允许我们顺序处理数据（见图1B）。一种关键原因，为什么数据导向设计如此强大，是因为它在大群对象上工作得很好。 OOP，根据定义，在一个对象上工作。退后一分钟，想想你工作的最后一场比赛：你的代码中有多少个地方你只有一个东西？一个敌人？一辆车？一个散文赛</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gamesfromwithin.com/data-oriented-design">https://gamesfromwithin.com/data-oriented-design</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oriented/">#oriented</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1068023.html"><img src="http://img2.diglog.com/img/2021/6/thumb_1ae31aea5d1db10f928f342e7a49c341.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068023.html">Microsoft宣布推出Windows 11，具有新的设计，开始菜单等 </a></div><span class="my_story_list_date">2021-6-25 0:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067890.html"><img src="http://img2.diglog.com/img/2021/6/thumb_8e9c4a34b8de14b57322b2de34c7fb75.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067890.html">意见驱动的设计 </a></div><span class="my_story_list_date">2021-6-24 10:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067868.html"><img src="http://img2.diglog.com/img/2021/6/thumb_dc7d7a20c929b9a5e595bd4fabcdebe0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067868.html">Adobe推出物质3D，Adobe一套3D设计工具Adobe表示，在视频游戏和VFX中有应用程序，并使用AI以简化3D设计的技术复杂性 </a></div><span class="my_story_list_date">2021-6-24 7:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067730.html"><img src="http://img2.diglog.com/img/2021/6/thumb_58f282be7791168c1dd386a61ef64b10.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067730.html">产品设计专家斯科特塘将于7月份加入我们的TC早期 </a></div><span class="my_story_list_date">2021-6-23 23:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>