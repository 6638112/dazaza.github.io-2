<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我如何编写ELM应用程序</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我如何编写ELM应用程序</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 23:44:51</div><div class="page_narrow text-break page_content"><p>Most of my work over the past 10 years has involved writing what is often called a  wizard.</p><p>在过去的10年里，我的大部分工作都涉及到编写通常被称为巫师的东西。</p><p> A wizard is essentially a multi-step process that guides a user through a particular workflow. For example, if you are installing a new application on your computer, the wizard might guide you through the following process:</p><p>向导本质上是一个多步骤的过程，它引导用户完成特定的工作流程。例如，如果要在计算机上安装新应用程序，向导可能会引导您完成以下过程：</p><p>  Most web applications provide something similar. If a user needs to input a large amount of data for the application to then run a bunch of calculations, you could of course just provide the user with one big web form. At a certain size though, a single web form can be intimidating and provide a less than ideal user experience. The canonical way to improve the user experience here is to break up the web form into several separate pages. This is another example of a wizard.</p><p>大多数Web应用程序都提供类似的功能。如果用户需要为应用程序输入大量数据来运行一系列计算，那么您当然可以只向用户提供一个大的Web表单。然而，在一定的大小下，单一的Web表单可能会令人望而生畏，并提供不太理想的用户体验。在这里，改善用户体验的标准方法是将网页拆分成几个单独的页面。这是另一个向导的例子。</p><p>  I’ve tried writing wizards in a number of different web technologies, and so far Elm has proven itself as by far the most robust and painless,  especially when it inevitably comes to changing some conditional logic to meet the mutable needs of various business processes.</p><p>我尝试过用许多不同的Web技术编写向导，到目前为止，Elm已经证明自己是最健壮、最轻松的，特别是当不可避免地要改变一些条件逻辑来满足各种业务流程的可变需求时。</p><p> For any small Elm application, project structure is easy. There is no reason why a 1,000 line Elm application can’t live in a single file. In fact this is really how every Elm application ought to begin its life. Start with a single file with the usual boilerplate and the following contents:</p><p>对于任何小型ELM应用程序，项目结构都很简单。1,000行ELM应用程序没有理由不能保存在一个文件中。事实上，这确实是每个ELM应用程序都应该开始其生命的方式。从具有常见样板和以下内容的单个文件开始：</p><p>  If your web form is complex enough to warrant being broken into separate pages however, then your application is naturally not going to consist of a small number of lines of code. A common concern among less experienced Elm programmers is that one big sum type for all of your messages becomes unwieldy to maintain. The same is said of having one big shallow record for all of the application state, or one big  update function to match all the constructors of the one big  Msg type. This is where unnecessary complexity starts to balloon as programmers add  clever abstractions and misdirections, usually involving both  Html.map and  Cmd.map, separate  update functions for each logical subsection of your application (usually with noticeably awkward type signatures), and some vague hand-waving in the direction of  encapsulation and so-called  Clean Code.</p><p>然而，如果您的Web表单足够复杂，足以被分成多个单独的页面，那么您的应用程序自然不会由少数几行代码组成。经验较少的ELM程序员普遍担心的一个问题是，所有消息的一个大SUM类型维护起来会变得不方便。同样，对于所有应用程序状态都有一个较浅的大记录，或者使用一个大的更新函数来匹配一个大的MSG类型的所有构造函数。这就是不必要的复杂性开始膨胀的地方，因为程序员添加了聪明的抽象和误导(通常涉及Html.map和Cmd.map)，为应用程序的每个逻辑子部分添加单独的更新函数(通常带有明显笨拙的类型签名)，以及朝着封装和所谓的Clean Code方向模糊地挥手。</p><p> I’d argue that this kind of misdirection is almost  never what you want. I’d argue further that this applies  especially to you if your background is in maintaining complex React/Angular applications, where invented complexity is the status quo and this kind of misdirection is simply what you have become desensitised to.</p><p>我认为，这种误导几乎不是你想要的。我进一步认为，如果你的背景是维护复杂的反应/角度应用程序，那么这一点尤其适用于你，在这种情况下，虚构的复杂性是现状，而这种误导只是你已经变得麻木不仁的东西。</p><p> So if the combination of  Html.map and  Cmd.map are to be avoided, how can we scale an Elm application without sacrificing developer ergonomics? In short, the tricks to employ are:</p><p>因此，如果要避免Html.map和Cmd.map的组合，我们如何才能在不牺牲开发人员人机工程学的情况下扩展ELM应用程序呢？简而言之，可以使用的诀窍是：</p><p>  Let’s take a look at a more concrete application of these ideas. As an example, we can model the process of a person applying for a bank loan.</p><p>让我们来看看这些想法的更具体的应用。作为一个例子，我们可以对一个人申请银行贷款的过程进行建模。</p><p> The bank will want to ask the applicant a whole bunch of questions, which we could group into three categories:</p><p>银行会问申请者一大堆问题，我们可以把这些问题分成三类：</p><p>  This would suggest a three-step wizard or a three-page web form. A reasonable place to begin splitting our application apart into three smaller pieces is in our  Msg type.</p><p>这将建议使用三步向导或三页网页表单。开始将我们的应用程序拆分成三个更小的部分的合理位置是在我们的msg类型中。</p><p>  The naïve way to model the messages our application should support is with one big sum type, which might look something like this:</p><p>对我们的应用程序应该支持的消息进行建模的天真方法是使用一个大的SUM类型，该类型可能如下所示：</p><p> type Page = PersonalInformationPage | LoanPurposePage | FinancialDetailsPagetype Msg -- System-wide messages = NoOp | SetPage Page -- etc… -- Personal information | SetFirstName String | SetLastName String | SetAddressLine1 String -- …more messages for the personal information page -- Purpose of the loan | SetPurchaseItemCategory | SetPurchaseItemEstimatedValue -- …more messages for the loan purpose page -- Financial information | SetMonthlyIncomeBeforeTax | SetMonthlyRentPayment -- …more messages about the applicant&#39;s financial details</p><p>类型页面=个人信息页面|贷款目的页面|财务详细信息页面类型消息--系统范围的消息=无操作|设置页面页面--等…。--个人信息|SetFirstName String|SetLastName String|SetAddressLine1 String--…。个人信息页面的更多消息--贷款目的|设置购买项目类别|设置购买项目估计值--…。贷款目的页面的更多消息--财务信息|SetMonthlyIncomeBeforTax|SetMonthlyRentPayment--…。有关申请人财务详细信息的更多信息。</p><p> This  does work, but at some point it becomes cumbersome to support a large number of constructors. The value for “large” is of course determined by the individual programmer’s personal taste and/or pain threshold. To ease this pain, people typically  extract groups of messages into their own separate sum types, which subsequently forces them to write update functions that return a type  other than the top-level  Msg type.</p><p>这确实是可行的，但在某些情况下，支持大量构造函数会变得很麻烦。当然，“大”的值取决于程序员的个人品味和/或痛楚。为了减轻这一痛苦，人们通常将消息组提取到他们自己的单独的SUM类型中，这随后迫使他们编写返回顶级消息类型以外的类型的更新函数。</p><p>  The way to break these groups of constructors out is by first nesting them inside the  Msg type, like this:</p><p>拆分这些构造函数组的方法是首先将它们嵌套在msg类型中，如下所示：</p><p> type PersonalInformationMsg = SetFirstName String | SetLastName String | SetAddressLine1 String -- etc..type LoanPurposeMsg -- etc…type FinancialDetailsMsg -- etc…type Msg = NoOp | SetPage Page | PersonalInformationMsg PersonalInformationMsg | LoanPurposeMsg LoanPurposeMsg | FinancialDetailsMsg FinancialDetailsMsg</p><p>输入PersonalInformationMsg=SetFirstName字符串|SetLastName字符串|SetAddressLine1字符串--等。输入LoanPurposeMsg--等…。键入FinancialDetailsMsg--ETC…。类型msg=NoOp|SetPage Page|PersonalInformationMsg PersonalInformationMsg|LoanPurposeMsg LoanPurposeMsg|FinancialDetailsMsg FinancialDetailsMsg</p><p> The new message types can live in the same file as the top-level  Msg type. They can also be extracted to different files. That’s your choice.</p><p>新消息类型可以与顶级消息类型位于同一文件中。也可以将它们解压缩到不同的文件中。这是你的选择。</p><p> The next thing to tackle is our  update function, since it needs to mirror our  Msg type.</p><p>下一件要处理的事情是我们的更新功能，因为它需要反映我们的味精类型。</p><p>  I’ve seen people advocate for page-specific  update functions which take a page-specific model and return a tuple of that page-specific model and a page-specific  Cmd Msg equivalent. This is typically where you see  Cmd.map sneaking in. These functions almost inevitably end up needing  something from the top-level application-wide state, so you’ll often see some type signature like this:</p><p>我见过有人提倡特定于页面的更新函数，该函数采用特定于页面的模型，并返回该特定于页面的模型的元组和特定于页面的Cmd MSG等效物。这通常是您看到Cmd.map潜入的地方。这些函数最终几乎不可避免地需要来自顶级应用程序范围状态的某些东西，因此您经常会看到一些类似下面这样的类型签名：</p><p>  This is  way too complex already, and this approach doesn’t even actually buy you anything.</p><p>这已经太复杂了，而且这种方法实际上并没有给你带来任何好处。</p><p> The far simpler way to do this is to have every nested  update function take a page-specific message, the  entire application state, and return the same type for that state along with the top-level  Msg type, like this:</p><p>简单得多的方法是让每个嵌套的更新函数获取特定于页面的消息(整个应用程序状态)，并返回该状态的相同类型以及顶级消息类型，如下所示：</p><p> updatePersonalInformation : PersonalInformationMsg -&gt; Model -&gt; (Model, Cmd Msg)updatePersonalInformation msg model = case msg of SetFirstName a -&gt; -- … SetLastName a -&gt; -- … SetAddressLine1 a -&gt; -- … -- etc…update : Msg -&gt; Model -&gt; (Model, Cmd Msg)update msg model = case msg of NoOp -&gt; (model, Cmd.none) SetPage page -&gt; ({ model | page = page }, Cmd.none) PersonalInformationMsg subMsg -&gt; updatePersonalInformation subMsg model LoanPurposeMsg subMsg -&gt; updateLoanPurpose subMsg model FinancialDetailsMsg subMsg -&gt; updateFinancialDetails subMsg model</p><p>更新个人信息：个人信息消息-&&gt;；型号-&&gt;(型号，命令消息)更新个人信息消息型号=设置名a-&&gt;的案例消息--…。设置姓氏a-&gt；--…。设置地址行1 a-&gt；--…。--ETC…。更新：MSG-&&gt;；Model-&&gt;(Model，Cmd MSG)UPDATE MSG model=case msg of NoOp-&&gt;(model，Cmd.one)SetPage page-&gt；({model|page=page}，Cmd.one)PersonalInformationMsg subMsg-&gt；updatePersonalInformation subMsg model LoanPurposeMsg subMsg-&gt；updatePersonalInformation subMsg model LoanPurposeMsg subMsg-&gt；updatePersonalInformation subMsg model LoanPurposeMsg subMsg；upupPages。</p><p>  Of course the whole point of our  update function is to advance the state of our model, and the structure of that model is also something that can swell and become unwieldy, so that’s what we will dissect next.</p><p>当然，我们更新函数的全部目的是提升模型的状态，而模型的结构也可能会膨胀并变得笨重，这就是我们接下来要分析的内容。</p><p>  Near the inception of the project, all of our individual bits of state might exist at the top level of our  Model, which is typically represented as a record. Perhaps something like this:</p><p>在项目开始时，我们所有的个人状态都可能存在于模型的顶层，这通常被表示为记录。也许是这样的：</p><p> type alias Model = { page : Page , firstName : String , lastName : String , addressLine1 : String -- …more personal information fields , purchaseItemCategory : ItemCategory , purchaseItemEstimatedValue : Money -- …more loan purpose fields… -- …and also financial details, and system-wide state, etc… }</p><p>类型别名型号={PAGE：PAGE，名字：字符串，姓氏：字符串，地址行1：字符串--…。更多个人信息字段，PurchaseItemCategory：ItemCategory，PurchaseItemEstimatedValue：Money--…。更多贷款目的字段…。--…。以及财务细节和系统范围的状态等…。}。</p><p> Like the parts of our project we’ve addressed previously, this also can turn into a bit of a mess as it grows. Both application-wide data and page-specific data are mixed in together which feels a bit haphazard. Fortunately, grouping and extracting these fields is typically rather intuitive. We can start by grouping page-specific parts of the state together, and then group further until it no longer  feels messy.</p><p>就像我们之前提到的项目的部分一样，随着它的发展，这也可能会变得有点混乱。应用程序范围的数据和页面特定的数据混合在一起，感觉有点随意。幸运的是，对这些字段进行分组和提取通常相当直观。我们可以先将州中特定于页面的部分分组在一起，然后再进一步分组，直到不再感觉混乱。</p><p> type alias Address = { line1 : String , line2 : String , city : String , postcode : String -- … }type alias PersonalInformation = { firstName : String , lastName : String , address : Address -- … }type alias LoanPurpose = { purchaseItemCategory : ItemCategory , purchaseItemEstimatedValue : Money -- … }type alias FinancialDetails = -- …type alias Model = { page : Page , personalInformation : PersonalInformation , loanPurpose : LoanPurpose , financialDetails : FinancialDetails }</p><p>类型别名地址={行1：字符串，行2：字符串，城市：字符串，邮政编码：字符串--…。}类型别名个人信息={名字：字符串，姓氏：字符串，地址：地址--…。}类型别名LoanPurpose={PurchaseItemCategory：ItemCategory，PurchaseItemEstimatedValue：Money--…。}类型别名财务明细=--…。类型别名Model={page：page，PersonalInformation：PersonalInformation，LoanPurpose：LoanPurpose，FinancialDetails：FinancialDetails}。</p><p> The problem now however is that when we wish to update a deeply-nested field, we need to write all of the code to unwrap each level until we arrive at the depth we need. Illustrated another way, let’s say we want to update the first line of the applicant’s address.</p><p>然而，现在的问题是，当我们希望更新深度嵌套的字段时，我们需要编写所有代码来展开每个级别，直到达到所需的深度。以另一种方式说明，假设我们想要更新申请者地址的第一行。</p><p> Retrieving the value of this field is no problem, as we can use Elm’s dot syntax to succinctly get us all the way there, like this:</p><p>检索此字段的值不成问题，因为我们可以使用ELM的点语法简洁地将我们带到那里，如下所示：</p><p>  What we  can’t do here however is  update that field in a similar fashion,  i.e., Elm won’t allow us to write something like this:</p><p>然而，我们在这里不能做的是以类似的方式更新该字段，也就是说，Elm不允许我们写这样的内容：</p><p> -- This won&#39;t work{ model.personalInformation.address | line1 = newLine1 }-- This also won&#39;t work{ model | personalInformation.address.line1 = newLine1 }</p><p>--这也赢得了作品{model.PersonalInformation.Address|line1=newLine1}--这也赢得了作品{model|PersonalInformation.Address.line1=newLine1}。</p><p> The naïve way to unwrap and subsequently update the field in this record is to write something like this:</p><p>在此记录中解开并随后更新该字段的天真方法是编写如下代码：</p><p> updatePersonalInformation : PersonalInformationMsg -&gt; Model -&gt; (Model, Cmd Msg)updatePersonalInformation msg model = case msg of SetFirstName _ -&gt; -- … SetLastName _ -&gt; -- … SetAddressLine1 newLine1 -&gt; let personalInformation = model.personalInformation address = personalInformation.address newAddress = { address | line1 = newLine1 } newPersonalInformation = { personalInformation | address = newAddress } in ({ model | personalInformation = newPersonalInformation }, Cmd.none) SetAddressLine2 _ -&gt; -- …</p><p>更新个人信息：个人信息消息-&&gt;；型号-&&gt;(型号，命令消息)更新个人信息消息型号=设置名字_-&&gt;；的案例消息--…。设置姓氏_-&gt；--…。SetAddressLine1 newLine1-&gt；let PersonalInformation=Model.PersonalInformation Address=PersonalInformation.Address newAddress={Address|Line1=newLine1}newPersonalInformation={PersonalInformation|Address=newAddress}in({Model|PersonalInformation=newPersonalInformation}，Cmd.None)SetAddressLine2_-&&gt；({Model|PersonalInformation=newPersonalInformation}，Cmd.None)SetAddressLine2_-&gt；</p><p> That’s 14 lines of code to update one single field. Not only is this single example somewhat confusing to follow, you also need to imagine how this update function will look when taking into account the five or so other fields  just in the address record! This is — quite frankly — pretty terrible. The trick here is not to stare out of the window and contemplate rewriting everything in ClojureScript. Instead, the thing to do is write a whole bunch of  lenses.</p><p>更新一个字段需要14行代码。这个例子不仅有点让人费解，还需要想象一下这个更新函数在考虑到地址记录中的大约五个其他字段时会是什么样子！坦率地说，这是相当糟糕的。这里的诀窍是不要盯着窗外，考虑用ClojureScript重写所有内容。相反，我们要做的是写一大堆镜头。</p><p> Conceptually, the lens functions we need are rather simple. We need one function to bridge the gap between each level of our information architecture, and then we just need to glue those functions together.</p><p>从概念上讲，我们需要的镜头功能相当简单。我们需要一个功能来弥合信息体系结构的每一层之间的差距，然后我们只需要将这些功能粘合在一起。</p><p>  In the diagram above, the orange arrows represent the individual lenses that we want in order to move between the different levels of our data structure. The blue arrow is the lens that we will want to use in our  updatePersonalInformation function, and we get this bigger lens by composing the three smaller lenses together.</p><p>在上图中，橙色箭头表示我们想要的各个镜头，以便在数据结构的不同级别之间移动。蓝色箭头是我们要在更新PersonalInformation功能中使用的镜头，我们将三个较小的镜头组合在一起就得到了这个较大的镜头。</p><p> We can write these functions with a handy library called   elm-monocle, and they would look something like the following:</p><p>我们可以使用一个名为elm-moncle的方便的库来编写这些函数，它们看起来如下所示：</p><p> import Monocle.Composeimport Monocle.Lens exposing (Lens)-- lens ApersonalDetailsL : Lens Model PersonalDetailspersonalDetailsL = Lens .personalDetails (\b a -&gt; { a | personalDetails = b })-- lens BpersonalDetailsAddressL : Lens PersonalDetails AddresspersonalDetailsAddressL = Lens .address (\b a -&gt; { a | address = b })-- lens CaddressLine1L : Lens Address StringaddressLine1L = Lens .line1 (\b a -&gt; { a | line1 = b })-- lens DpersonalDetailsAddressLine1L : Lens Model StringpersonalDetailsAddressLine1L : personalDetailsL |&gt; Monocle.Compose.lensWithLens personalDetailsAddressL |&gt; Monocle.Compose.lensWithLens addressLine1L</p><p>Import Monocle.ComposeImport Monocle.Lens曝光(镜头)--镜头APersonalDetailsL：镜头型号PersonalDetailsPersonalDetailsL=镜头.PersonalDetailsL=镜头.PersonalDetails(\b a-&gt；{a|PersonalDetailsAddressL：镜头PersonalDetailsAddressL=镜头.AddressL：镜头PersonalDetailsAddressL=镜头.address(\b a-&gt；{a|。</p><p> You can pretty much ignore the implementation of each of these lenses, as they are mostly just mechanical transformations between each level of our model. It’s better instead to read the type signatures which clearly show that the first lens gets you from  Model to  PersonalDetails, the second lens takes you from  PersonalDetails to  Address, the third lens takes us one level deeper, and the fourth lens combines the first three, taking us all the way from our top-level  Model right the way down to the  String that represents the first line of the applicant’s address.</p><p>您几乎可以忽略这些镜头的实现，因为它们大多只是模型的每个级别之间的机械转换。相反，最好是阅读类型签名，它清楚地显示了第一个镜头让你从模特到个人详细信息，第二个镜头让你从个人详细信息到地址，第三个镜头让我们更深一层，第四个镜头结合了前三个，从我们的顶级模特一直到代表申请者地址第一行的字符串。</p><p> Writing out all of these lenses is admittedly somewhat tedious and it’s mostly boilerplate — which makes me wonder if these couldn’t be generated in some way; a research topic for another day. Once we have these lenses though, we’re able to drastically clean up our update functions.</p><p>诚然，写出所有这些镜头有点乏味，而且大部分都是样板--这让我想知道，这些镜头是不是不能以某种方式生成；这是改天再研究的话题。不过，一旦我们有了这些镜头，我们就可以彻底清理我们的更新功能了。</p><p>  updatePersonalInformation : PersonalInformationMsg -&gt; Model -&gt; (Model, Cmd Msg)updatePersonalInformation msg model = case msg of SetFirstName _ -&gt; -- … SetLastName _ -&gt; -- … SetAddressLine1 newLine1 -&gt; (personalDetailsAddressLine1L.set newLine1 model, Cmd.none) SetAddressLine1 _ -&gt; -- …</p><p>更新个人信息：个人信息消息-&&gt;；型号-&&gt;(型号，命令消息)更新个人信息消息型号=设置名字_-&&gt;；的案例消息--…。设置姓氏_-&gt；--…。SetAddressLine1 newLine1-&gt；(PersonalDetailsAddressLine1L.set newLine1 model，Cmd.None)SetAddressLine1_-&gt；--…。</p><p> This is much more elegant, and the nature of this API means it works even more beautifully when updating several fields at once. You could write something like the following contrivance, for example:</p><p>这要优雅得多，而且这个API的性质意味着它在一次更新多个字段时工作得更好。例如，您可以编写类似以下设计的代码：</p><p> flip : (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; cflip f b a = f a bupdateExampleFields : ExampleMsg -&gt; Model -&gt; (Model, Cmd Msg)updateExampleFields msg model = case msg of SetManyModelFields foo bar baz spam eggs -&gt; model |&gt; nestedExampleFooL.set foo |&gt; nestedExampleBarL.set bar |&gt; nestedExampleBazL.set baz |&gt; montyPythonBreakfastSpamL.set spam |&gt; montyPythonBreakfastEggsL.set eggs |&gt; flip Tuple.pair Cmd.none</p><p>Flip：(a-&gt；b-&&gt；c)-&gt；b-&gt；a-&gt；cflip f b a=f a bupdateExampleFields：ExampleMsg-&gt；Model-&gt；(Model，Cmd MSG)updateExampleFields msg model=case msg of SetManyModelFields Foo bar Baz Spam鸡蛋-&gt；model|&gt。</p><p> As a brief aside, I will at this point sympathise with people who have criticised Elm in the past for some of its most vocal proponents being  frustratingly unhelpful.</p><p>简而言之，在这一点上，我会同情那些过去批评榆树的人，因为他们中一些最直言不讳的支持者毫无帮助，令人沮丧。</p><p> Relatedly, I’ve also come to view lenses as a such a huge mistake that if there were a way for the language to make it impossible to implement lens libraries, I would advocate for it. (Unfortunately, they are not possible to rule out.)</p><p>与此相关的是，我也认为镜片是一个巨大的错误，如果有一种方法可以让这种语言无法实现镜片库，我会支持它。(不幸的是，不能排除这种可能性。)。</p><p> I’m sorry, but sanctimoniously dismissing a powerful technique for working with data structures in a schema that they’ve come to exist in organically  without even bothering to justify the dismissal or provide an alternative technique is just bad.</p><p>我很抱歉，但是冒昧地拒绝使用一种强大的技术来处理模式中的数据结构，而这些数据结构已经有机地存在于其中，甚至没有费心去证明这种解雇是合理的，或者提供了一种替代技术，这是非常糟糕的。</p><p>  Moving swiftly on, and now that our model is satisfactorily wrangled, we can attack the last part of this puzzle which is rendering our model on the page.</p><p>快速前进，现在我们的模型已经得到了令人满意的讨论，我们可以开始解决这个谜题的最后部分了，它将我们的模型呈现在页面上。</p><p>  In the same way that your nested model update functions should return a top-level  Msg type rather than some page-specific message type, the view functions should  also return the top-level  Msg type.</p><p>与嵌套模型更新函数应该返回顶级消息类型(而不是特定于页面的消息类型)相同，视图函数也应该返回顶级消息类型。</p><p>  The question here then is: how do we send a page-specific message into the runtime if the view function has declared in its type signature that it returns a top-level  Msg type in a  Html context? This turns out to be quite simple. We can just use function composition to join the different constructors together.</p><p>那么这里的问题是：如果视图函数在其类型签名中声明它在HTML上下文中返回顶级消息类型，我们如何将页面特定的消息发送到运行时？事实证明，这很简单。我们可以只使用函数组合将不同的构造函数连接在一起。</p><p> If we consider a view function that renders an input for modifying the first line of the applicant’s address as before, we might write it like this:</p><p>如果我们考虑一个视图函数，该函数像以前一样提供用于修改申请者地址第一行的输入，我们可能会这样写它：</p><p> addressLine1Input : Model -&gt; Html MsgaddressLine1Input model = input [ type_ &#34;text&#34; , value model.personalDetails.address.line1 , onInput (PersonalInformationMsg &lt;&lt; SetAddressLine1) ] []</p><p>AddressLine1Input：Model-&gt；HTML MsgressLine1Input model=Input[type_&#34；text&#34；，value model.PersonalDetails.Address.line1，onInput(PersonalInformationMsg&lt；&lt；SetAddressLine1)][]。</p><p> That’s all there is to it really. I am happily employing all of the techniques described above in a number of Elm projects, each of which span several thousand lines of code.</p><p>真的就是这样。我很高兴地在许多ELM项目中使用了上面描述的所有技术，每个项目跨越数千行代码。</p><p> There are a couple of other things you can do to better manage Elm applications as they grow. At Riskbook for example, we use   elm-bridge to generate our Elm types, JSON encoders, and JSON decoders from our Haskell backend. This has worked tremendously for us and I would recommend it, though it’s outside of the scope of this article.</p><p>在ELM应用程序不断增长的过程中，您还可以做一些其他的事情来更好地管理它们。例如，在Riskbook，我们使用elm-bridge从Haskell后端生成ELM类型、JSON编码器和JSON解码器。这对我们非常有效，我会推荐它，尽管这超出了本文的范围。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jezenthomas.com/how-i-write-elm-applications/">https://jezenthomas.com/how-i-write-elm-applications/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/elm/">#elm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/镜头/">#镜头</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035044.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ca2fcc1d2b0f6a4c44f4ccf6529596ac.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035044.html">Oculus Quest 2更新增加了对90赫兹游戏的支持；Oculus Move是一款用于在游戏中跟踪健身指标的应用程序，将于下周推出</a></div><span class="my_story_list_date">2020-11-14 9:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034942.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b87c337b058d6b8e5d57c3a283b1b8c8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034942.html">在PyPI上搜索恶意程序包</a></div><span class="my_story_list_date">2020-11-14 2:24</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034875.html"><img src="http://img2.diglog.com/img/2020/11/thumb_70cb84755c6e1c3dba801123370378e9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034875.html">
PSA：MacOS今早有点崩溃，许多非苹果应用程序在发布时挂起</a></div><span class="my_story_list_date">2020-11-13 19:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034842.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c27e6cec6debacb79347e94968d267b3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034842.html">许多Mac用户在Big Sur发布期间遇到了应用程序减速的问题，可能是由于苹果的OCSP服务无法验证证书的问题</a></div><span class="my_story_list_date">2020-11-13 19:0</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>