<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>证明新的Unix shell是合理的四个特性</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">证明新的Unix shell是合理的四个特性</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 07:30:25</div><div class="page_narrow text-break page_content"><p>On a  lobste.rs thread about the rationale for the Fennel language, Iposted this summary of why Oil exists:</p><p>在一篇关于茴香语言基本原理的lobste.rs帖子中，我发布了关于石油为什么存在的摘要：</p><p> But Oil has a lot more than that, including unifying separate ad hocexpression languages ...</p><p>但是Oil有更多的东西，包括统一单独的广告表达语言……。</p><p> This post elaborates on these points. I&#39;ve condensed the rationale into fourcritical features for the  OSH language.</p><p>这篇文章详细阐述了这些观点。我已经将其基本原理浓缩为职业安全卫生语言的四个关键特征。</p><p> I give examples of each feature, link to docs (in progress), and comment on thefuture of the project.</p><p>我给出了每个功能的示例，链接到文档(正在进行中)，并对项目的未来进行了评论。</p><p>     Recall that  OSH is designed to run existing shell scripts, andhas done that  since early 2018.</p><p>回想一下，OSH是为运行现有的shell脚本而设计的，并且从2018年初开始就这样做了。</p><p> It also fixes warts in the shell language with  opt-in features. These arethe four most important ones.</p><p>它还用Opt-in特性修复了shell语言中的缺点。这是四个最重要的问题。</p><p>   I just finished an overhaul of shell&#39;s flaky  set -e /  errexit mechanism.I&#39;m excited by this, because I started it last year, but put it on the backburner after being stumped!</p><p>我刚刚完成了对壳牌公司易碎的Set-e/Errexit机制的大修。我对此很兴奋，因为我去年就开始了，但在被难住之后，我把它放在了次要位置！</p><p> I believe I&#39;ve figured out every problem now, and would like your feedback.The simple invariant is that  OSH never loses an exit code, which is nottrue of POSIX shell or  bash. Here&#39;s a summary of the enhancements:</p><p>我相信我现在已经解决了所有问题，并希望得到您的反馈。简单不变的是，OSH从不丢失退出代码，而POSIX shell或bash并非如此。以下是增强功能的摘要：</p><p> strict_errexit - A shell option to  detect cases where you would loseerrors in shell, like  if myfunc. This improves your shell scripts, even ifyou run them under another shell! In other words, OSH can be used as a devtool.</p><p>Strict_errexit-一个shell选项，用于检测在shell中丢失错误的情况，如如果myfunc。这改进了您的shell脚本，即使您在另一个shell下运行它们！换句话说，OSH可以用作开发工具。</p><p> inherit_errexit - OSH implements this bash 4.4 option, which is a partialfix for the &#34;command sub errexit&#34; problem.</p><p>Inherit_errexit-OSH实现此bash4.4选项，这是对&#34；命令suberrexit&#34；问题的部分修复。</p><p> command_sub_errexit - A shell option to check for failure at the end ofevery command sub, so you don&#39;t lose errors. This fixes the problem shown in the last panel of a  recentcomic by Julia Evans: &#34;bash is weird sometimes&#34;</p><p>COMMAND_SUB_ERREXIT-在每个命令SUB的末尾检查故障的shell选项，这样您就不会丢失错误。这解决了朱莉娅·埃文斯(Julia Evans)最近一部漫画的最后一个面板中显示的问题：猛烈抨击有时是奇怪的&#34；</p><p> process_sub_fail - Like  pipefail, but for process substitutions. Itallows  errexit to &#34;see&#34; the failure caused by process subs, like the  sortinvocation in  cat foo.txt &lt;(sort /oops/error), @_process_sub_status: A variable that&#39;s analogous to  ${PIPESTATUS[@]}.You may want to inspect the exit status of all processes.</p><p>PROCESS_SUB_FAIL-类管道失败，但用于进程替换。意大利将errexit设置为&#34；参见&#34；进程SUB导致的故障，如cat foo.txt&lt；中的sortinvocation(SORT/OOOPS/ERROR)，@_PROCESS_SUB_STATUS：类似于${PIPESTATUS[@]}的变量。您可能需要检查所有进程的退出状态。</p><p> The  run builtin turns  errexit back on, so  if run myfunc is safe. Italso provides fine-grained control over exit codes.</p><p>Run内置打开errexit，所以如果运行myfunc是安全的。它还提供对退出代码的细粒度控制。</p><p> Yes, there are many solutions, because shell has many problems! But you don&#39;thave to remember all these names. Add  shopt --set oil:basic to the top ofyour program to turn all options. The  strict_errexit failures will remindyou to use the  run wrapper.</p><p>是的，有很多解决方案，因为shell有很多问题！但是你不必记住所有这些名字。将SHOT--设置油：BASIC添加到您的程序的顶部，以打开所有选项。Strict_errexit失败将提醒您使用运行包装器。</p><p> (Aside: I was able to fix all these problems cleanly in the interpreter. Ispent time a lot of time on  Oil&#39;s architecture 4 yearsago precisely so I could fixsuch subtle problems. When the code has a good structure, the &#34;right place&#34;for a fix reveals itself to you. Oil is still improving!)</p><p>(旁白：我能够在解释器中干净利落地解决所有这些问题。4年前，我花了很多时间在石油公司的架构上，这样我就可以解决这些微妙的问题。当代码具有良好的结构时，修复的正确位置就会自动展现给您。(油价仍在改善！)。</p><p>   QSN is the foundation for  Structured Data inOil. It removesthe need to invent ad hoc (and often broken) formats every time you need todeal with user-supplied data in shell. In other words, Oil scripts have analternative to messy parsing and splitting.</p><p>QSN是实现石油领域结构化数据的基础。每当您需要在shell中处理用户提供的数据时，它就不再需要发明特殊的(通常是不完整的)格式。换句话说，除了混乱的解析和拆分之外，Oil脚本还有另一种选择。</p><p>  Here are some short examples. The  write builtin prints its args to stdout,and it accepts a  --qsn flag:</p><p>这里有一些简短的例子。写内建函数将其参数输出到stdout，并接受--qsn标志：</p><p> # Print filenames ONE PER LINE. If a name contains a# newline or other special char, it&#39;s QSN-encoded like# &#39;multi-line \n name with NUL \0 byte&#39;write --qsn -- *.txt</p><p>#打印文件名为每行一个。如果名称包含#换行符或其他特殊字符，则它的QSN编码类似于\n带有NUL\0字节的多行名称--qsn--*.txt。</p><p>  cat list.txt | while read --line --qsn { # _line is implictly set by &#39;read&#39; rm -- $_line}</p><p>Cat list.txt|While read--line--qsn{#_line由&#39；read&#39；rm--$_line}隐式设置。</p><p> I also implemented  read -0 as a synonym for bash&#39;s obscure  read -r -d &#39;&#39;.This allows you to consume  find -print0 output in shell, like  xargs -0does. This format is distinct from QSN, but it&#39;s now easy to convert back andforth between them.</p><p>我还实现了read-0作为bash-r-d；&#39；模糊的read-r-d；&#39；的同义词，这允许您像xargs-0一样在shell中使用find-Print0输出。此格式与QSN不同，但现在很容易在它们之间来回转换。</p><p> This is the first cut of  QSN support. I expect it to evolve based on yourfeedback!</p><p>这是第一次削减QSN支持。我希望它会根据您的反馈而发展！</p><p>    This was done in summer 2019. I described it in  Simple WordEvaluation earlier this year, and you can see examples in Oil Language Idioms.</p><p>这是在2019年夏天完成的。我在今年早些时候的“简单单词评估”中对此进行了描述，您可以在Oil语言习语中看到示例。</p><p>        This blog began in 2016 with an explanation of  staticparsing. I didn&#39;t mention it in the comment quoted inthe intro, but it&#39;s still a crucial part of the project.</p><p>这篇博客始于2016年，对静态解析进行了解释。我在介绍中引用的评论中没有提到这一点，但它仍然是该项目的关键部分。</p><p> I was reminded how important this is when noticing that the authors of bothPerl 5 and the rc shell  made complaints about shell&#39;s dynamicparsing, going back 20-30years!</p><p>当我注意到二三十年前Perl5和RCshell的作者都抱怨shell的动态解析时，我意识到这是多么重要！</p><p> This foundation is still paying dividends. I recently used the static parserto create detailed error messages for command subs:</p><p>这个基金会仍在支付红利。我最近使用静态解析器为命令subs创建了详细的错误消息：</p><p> $  shopt --set errexit command_sub_errexit $  d=$(date %x)date: invalid date ‘%x’ d=$(date %x) ^~[ interactive ]:13: fatal: Command sub exited with status 1 ...</p><p>$SHORT--set errexit command_sub_errexit$d=$(日期%x)日期：无效日期‘%x’d=$(日期%x)^~[交互]：13：FATAL：命令SUB已退出，状态为1...。</p><p>  $  shopt --set process_sub_fail $  cat /dev/null &lt;(sort oops)sort: cannot read: oops: No such file or directory cat /dev/null &lt;(sort oops) ^~[ interactive ]:27: fatal: Exiting with status 2 ...</p><p>$SHORT--set PROCESS_SUB_FAIL$cat/dev/null&lt；(排序oops)排序：无法读取：oops：没有这样的文件或目录cat/dev/null&lt；(排序oops)^~[交互]：27：FATAL：正在退出，状态为2...。</p><p>  In addition, Travis Everett has worked on a shell dependency bundler whichrelies on static parsing.</p><p>此外，Travis Everett还开发了一个依赖于静态解析的shell依赖捆绑器。</p><p>    It was indeed useful to explicitly write out rationale for the language. I&#39;vedone that many times with posts tagged # why-a-new-shell, butexplaining it again helps, even after 4 years. The project is evolving andgetting crisper.</p><p>明确地写出这种语言的基本原理确实很有用。我用#为什么是新贝壳#的帖子多次重复这一点，但即使在4年后再次解释也是有帮助的。这个项目正在发展，并且变得越来越清晰。</p><p>   With the overhaul of  errexit and the  QSN decoder, I believe we now haveall the bases for the  OSH language covered! These featureswill be out with the next release.</p><p>随着Errexit和QSN解码器的大修，我相信我们现在已经具备了OSH语言的所有基础！这些功能将在下一版本中删除。</p><p> The claim is that  these four features alone justify a new Unix shell. Ifwe finish the C++ translation, and end the project here, it would beworthwhile.</p><p>有人声称，仅这四个特性就证明了一个新的Unix shell是合理的。如果我们完成C++翻译，并在这里结束项目，这将是值得的。</p><p>  Elimination of &#34;quoting hell&#34;. Let&#39;s fix it once and for all, rather thanadmonishing every new shell programmer about it for the next 30 years, ashas been done for the past 30!</p><p>消除引述地狱的话。让我们一劳永逸地解决它，而不是在接下来的30年里告诫每一个新的shell程序员，因为过去的30年里已经这样做了！</p><p> If you disagree,  let me know! I would like to hear what otherwarts in the  shell language need to be fixed or otherwise addressed.</p><p>如果你不同意，请告诉我！我想知道shell语言中还有哪些地方需要修复或以其他方式解决。</p><p> (I&#39;m leaving out the interactive shell here, as I believe the first priority isa better shell for programming and automation. A &#34;cloud shell&#34;, if you will.)</p><p>(我在这里省略了交互式shell，因为我认为当务之急是开发一个更好的编程和自动化shell。A&#34；Cloud Shell&#34；如果你愿意，也可以这么说。)。</p><p>   Back in January, I was already  concerned about the scope of the project. Iwrote that  the biggest cut to theproject would be that Oil would be based on  strings, rather thanPython-like data types.</p><p>早在一月份，我就已经担心这个项目的范围了。我写道，该项目最大的削减将是Oil将基于字符串，而不是类似Python的数据类型。</p><p>  The  OSH language is a compatible shell based on  strings(and arrays of strings). Assignments look like  local x=mystr.</p><p>OSH语言是基于字符串(和字符串数组)的兼容shell。赋值看起来像是本地x=mystr。</p><p> The  Oil language has Python-like  types and expressions.Assignments look like  var x = 42 + a[i] + f(x, y). It has agarbage-collected heap of recursive data structures.</p><p>Oil语言有类似Python的类型和表达式，赋值看起来像var x=42+a[i]+f(x，y)。它具有容量收集的递归数据结构堆。</p><p> So what I&#39;m saying now is that the priority going forward is to polish the OSH language, and put off the Oil language until the hazyfuture.</p><p>因此，我现在要说的是，今后的首要任务是完善职业安全与健康语言，而把石油语言推迟到朦胧的未来。</p><p> That means finishing the translation to C++, hooking up the  garbagecollector, and writing  documentation. It may mean preparing the code tobe embedded in another application, like the  fish shell. (I&#39;ve discussed thiswith the maintainer, and there&#39;s some interest. But it&#39;s a lot of work, whichshouldn&#39;t be taken for granted, and there are unsolved problems.)</p><p>这意味着完成到C++的转换，连接垃圾收集器，并编写文档。这可能意味着准备将代码嵌入到另一个应用程序中，比如鱼壳。(我已经和维护员讨论过这个问题，大家都很感兴趣。但这是一项繁重的工作，不应该想当然地认为这是理所当然的，而且还有很多问题没有解决。)。</p><p> Achieving this OSH language milestone feels very doable, since everythingalready works in Python, and something like  915 out of  1685 spec testspass in C++ (yielding a 30x - 50x speedup).</p><p>实现这一OSH语言里程碑感觉非常可行，因为一切都已经在Python中运行，C++的1685个规范测试空间中有915个(产生30倍-50倍的加速比)。</p><p>   But I&#39;m not giving up on the Oil language! I just need help. It exists inprototype form, and your feedback will motivate me to work on it.</p><p>但是我不会放弃石油语言！我只是需要帮助。它以原型的形式存在，您的反馈将激励我继续工作。</p><p>  Four Features of the Oil Language. This post narrowed down OSH to four majorfeatures, and Oil also has four:</p><p>油画语言的四大特点。这个帖子将职业安全与健康缩小到四个主要功能，而Oil也有四个：</p><p> Serialization formats like JSON and QTSV( proposal). Thelatter is a format for  typed tables, built on topof  QSN.</p><p>序列化格式，如JSON和QTSV(建议)。后者是一种用于类型化表格的格式，建立在QSN之上。</p><p>  Big Changes to the Oil Language. A list of recent changes I&#39;ve made, whichshould give potential contributors a feel for the language.</p><p>石油语言的巨大变化。列出了我最近所做的更改，这些更改应该会让潜在的贡献者对这门语言有一个感觉。</p><p> What Distinguishes Python, JS, and Ruby from Perl and PHP. The formerlanguages have a clean data model / memory model: a garbage collected heap withreference semantics.</p><p>Python、JS和Ruby与Perl和PHP的不同之处。前面的语言有一个干净的数据模型/内存模型：带有引用语义的垃圾收集堆。</p><p>  Comments on Comics. I can use these  recentcomics as a way to explain the OSH language. (See other posts tagged # comic.)</p><p>漫画评论。我可以用这些最近的漫画作为解释职业安全卫生语言的一种方式。(参见其他标记为#COMIC的帖子。)。</p><p>   I described 4 essential features of an improved shell language.  Let meknow what you think is missing.</p><p>我描述了改进的shell语言的4个基本特性。让我知道你认为遗漏了什么。</p><p> If you haven&#39;t read it already, see  Why Create a UnixShell?. It&#39;s the most popular page on this site,though I still need to update it for 2021.</p><p>如果您还没有读过，请参阅为什么创建UnixShell？它是这个网站上最受欢迎的页面，不过我仍然需要在2021年更新它。</p><p> I then proposed a focus on making the OSH language &#34;production ready&#34;. I&#39;mstill going to work on the Oil language, but I need help finishing it.</p><p>然后我提议把重点放在让职业安全卫生语言准备好生产上。我还在学习石油语言，但我需要帮助完成它。</p><p>   Speaking of which, several people have pointed out that the dev process for Oilis difficult. I&#39;ve addressed this recently by removing spew from the buildlogs, and adding a lint check for more portable shebangs with  /usr/bin/env.(This just triggered and prevented a regression!)</p><p>谈到这一点，有几个人指出，石油的开发过程是困难的。我最近已经解决了这个问题，从构建日志中删除了spew，并使用/usr/bin/env为更便携的Shebangs添加了一个线条检查(这刚刚触发并防止了回归！)。</p><p> I still would like to make a screencast to show how easy Oil is to work on.After cloning, a 10 or 20 second build process should get you a working bin/osh:</p><p>我仍然想制作一个截屏视频来展示Oil是多么容易工作。在克隆之后，10或20秒的构建过程应该会为您提供一个可工作的bin/Osh：</p><p>   So I&#39;m trying to make Oil more friendly to work on. Reach out if you want tohelp, and if you run into problems.</p><p>因此，我正在努力让“石油”变得更好用。(工业和信息化部电子科学技术情报研究所陈皓)。如果你想帮忙，如果你遇到问题，请伸出援助之手。</p><p>   Thanks to  Till Schröder for great feedback on theOil language. For example, he noticed that I had awkwardly named the  catchbuiltin (now  run).</p><p>感谢Till Schröder对石油语言的巨大反馈。例如，他注意到我给catchbuiltin(现在是Run)起了个笨拙的名字。</p><p> Thanks to Diego Calleja for many updates the Oil docs. This is a huge effortby itself!</p><p>感谢迭戈·卡莱贾多次更新石油文档。这本身就是一个巨大的努力！</p><p>   Those 4 features aren&#39;t the only ones in OSH, but I claim they are sufficient!</p><p>这4个功能并不是OSH中唯一的功能，但我认为它们已经足够了！</p><p> I fixed other problems with shell, and described them with posts tagged# real-problems. I&#39;ve applied that tag to this post, since command_sub_errexit fixes the problem that Julia Evans was perplexed by.</p><p>我用shell修复了其他问题，并用标签为#Real-Problems的帖子来描述它们。我把这个标签贴到了这篇帖子上，因为COMMAND_SUB_ERREXIT解决了朱莉娅·埃文斯(Julia Evans)困惑的问题。</p><p> I believe Oil will be  faster than  bash along 3 dimensions: parsingspeed, runtime compute speed, and runtime I/O speed. However this may requireoptimization after finishing the garbage collector, and we&#39;re short on hands todo that.</p><p>我相信Oil会在3个维度上比bash更快：解析速度、运行时计算速度和运行时I/O速度。然而，这可能需要在完成垃圾收集器后进行优化，而我们缺少人手来做到这一点。</p><p> I&#39;d like Oil to have better  dev tools: tracing, debugging, and crash dumps.I prototyped a crash dump a couple years ago, but I didn&#39;t receive muchfeedback on it. I think OSH has to be more mature before that&#39;s compelling.</p><p>我希望Oil有更好的开发工具：跟踪、调试和崩溃转储。几年前我制作了一个崩溃转储的原型，但没有收到太多反馈。我认为，职业安全与健康必须更加成熟，才能令人信服。</p><p> Subinterpreters ( issue 704) have multiple use cases. There havebeen many failed attempts to add this feature to CPython, whereas embeddedlanguages like Tcl and Lua make good use of them.</p><p>分口译员(问题704)有多个用例。在CPython中添加这个特性的尝试已经失败了很多次，而像Tcl和Lua这样的嵌入式语言很好地利用了它们。</p><p> I even think there are good use cases for embedding WebAssembly in Oil, e.g. asmentioned in the  July post on regular languages.Another use case is to package and distribute portable dev dependencies, likethe  CommonMark renderer. This problem has contributedto the dev process friction mentioned above.</p><p>我甚至认为在Oil中嵌入WebAssembly有很好的用例，比如7月份关于常规语言的文章中提到的，另一个用例是打包和分发可移植的开发依赖项，比如CommonMark渲染器。这个问题导致了上面提到的开发过程摩擦。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.oilshell.org/blog/2020/10/osh-features.html">http://www.oilshell.org/blog/2020/10/osh-features.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/shell/">#shell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/justify/">#justify</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>