<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>基于ARM的AWS EC2实例上的PostgreSQL PostgreSQL on ARM-Based AWS EC2 Instances</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PostgreSQL on ARM-Based AWS EC2 Instances<br/>基于ARM的AWS EC2实例上的PostgreSQL </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 04:04:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/27ac16683872d5cb7430f5d74603d03b.png"><img src="http://img2.diglog.com/img/2021/1/27ac16683872d5cb7430f5d74603d03b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Jobin Augustine    The expected growth of ARM processors in data centers has been a hot topic for discussion for quite some time, and we were curious to see how it performs with PostgreSQL. The general availability of ARM-based servers for testing and evaluation was a major obstacle. The icebreaker was when AWS  announced their ARM-based processors offering in their cloud in 2018. But we couldn’t see much excitement immediately, as many considered it is more “experimental” stuff. We were also cautious about recommending it for critical use and never gave enough effort in evaluating it.  But when the second generation of  Graviton2 based instances was announced in May 2020, we wanted to seriously consider. We decided to take an independent look at the price/performance of the new instances from the standpoint of running PostgreSQL.</p><p>Jobin Augustine数据中心中ARM处理器的预期增长一直是讨论的热门话题，而且我们很好奇它在PostgreSQL中的表现。用于测试和评估的基于ARM的服务器的普遍可用性是一个主要障碍。破冰者是AWS在2018年在其云中宣布其基于ARM的处理器产品的时候。但是我们并没有立即看到太多兴奋，因为许多人认为它是“实验性”的东西。我们对于将其推荐用于关键用途也持谨慎态度，并且从未付出足够的努力来评估它。但是，当基于Graviton2的第二代实例于2020年5月发布时，我们要认真考虑。我们决定从运行PostgreSQL的角度来独立研究新实例的价格/性能。</p><p> Important: Note that while it’s tempting to call this comparison of PostgreSQL on x86 vs arm, that would not be correct. These tests compare PostgreSQL on two virtual cloud instances, and that includes way more moving parts than just a CPU. We’re primarily focusing on the price-performance of two particular AWS EC2 instances based on two different architectures.</p><p> 重要提示：请注意，虽然很想在x86和arm上进行这种PostgreSQL比较，但这并不正确。这些测试将PostgreSQL在两个虚拟云实例上进行了比较，其中不仅包括CPU，还包括更多的活动部件。我们主要关注基于两种不同架构的两个特定AWS EC2实例的性价比。</p><p>  For this test, we picked two similar instances. One is the older 			   m5d . 8xlarge, and the other is a new Graviton2-based 			   m6gd . 8xlarge. Both instances come with local “ephemeral” storage that we’ll be using here. Using very fast local drives should help expose differences in other parts of the system and avoid testing cloud storage. The instances are not perfectly identical, as you’ll see below, but are close enough to be considered same grade. We used Ubuntu 20.04 AMI and PostgreSQL 13.1 from pgdg repo. We performed tests with small (in-memory) and large (io-bound) database sizes.</p><p>  对于此测试，我们选择了两个类似的实例。一种是较旧的m5d。 8xlarge，另一个是基于Graviton2的新m6gd。 8xlarge。这两个实例都带有本地“临时”存储空间，我们将在这里使用它们。使用速度非常快的本地驱动器应有助于揭示系统其他部分的差异，并避免测试云存储。这些实例并不完全相同（如下所示），但距离足够近，可以被认为是同一等级。我们使用了来自pgdg repo的Ubuntu 20.04 AMI和PostgreSQL 13.1。我们使用较小（内存中）和较大（io绑定）的数据库大小进行了测试。</p><p>  Specifications and On-Demand pricing of the instances as per the  AWS Pricing Information for Linux in the Northern Virginia region. With the currently listed prices, 			   m6gd . 8xlarge is 25% cheaper.</p><p>  根据北弗吉尼亚州Linux的AWS定价信息，对实例进行规范和按需定价。使用当前列出的价格，m6gd。 8xlarge便宜25％。</p><p>    Instance : m6gd.8xlarge 	Virtual CPUs : 32RAM : 128 GiB 	Storage : 1 x 1900 NVMe SSD (1.9 TiB)Price : $1.4464 per Hour</p><p>    实例：m6gd.8xlarge虚拟CPU：32内存：128 GiB储存：1 x 1900 NVMe SSD（1.9 TiB）价格：每小时$ 1.4464</p><p>      Instance : m5d.8xlargeVirtual CPUs : 32RAM : 128 GiBStorage : 2 x 600 NVMe SSD (1.2 TiB)Price : $1.808 per Hour</p><p>      实例：m5d.8xlarge虚拟CPU：32内存：128 GiB储存：2 x 600 NVMe SSD（1.2 TiB）价格：每小时$ 1.808</p><p>    We selected Ubuntu 20.04.1 LTS AMIs for the instances and didn’t change anything on the OS side. On the m5d.8xlarge instance, two local NVMe drives were unified in a single raid0 device. PostgreSQL was installed using 			   .deb packages available from the PGDG repository.</p><p>    我们为实例选择了Ubuntu 20.04.1 LTS AMI，并且在操作系统方面未做任何更改。在m5d.8xlarge实例上，两个本地NVMe驱动器统一在一个raid0设备中。 PostgreSQL是使用PGDG信息库中的.deb软件包安装的。 </p><p>   postgres=# select version(); version ---------------------------------------------------------------------------------------------------------------------------------------- PostgreSQL 13.1 (Ubuntu 13.1-1.pgdg20.04+1) on aarch64-unknown-linux-gnu, compiled by gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, 64-bit(1 row)</p><p>postgres =＃选择版本（）; 版-------------------------------------------------- -------------------------------------------------- ------------------------------------ aarch64-unknown-linux-gnu上的PostgreSQL 13.1（Ubuntu 13.1-1.pgdg20.04 + 1），由gcc（Ubuntu 9.3.0-17ubuntu1〜20.04）9.3.0，64位编译（1列）</p><p>     max_connections = &#39;200&#39;shared_buffers = &#39;32GB&#39;checkpoint_timeout = &#39;1h&#39;max_wal_size = &#39;96GB&#39;checkpoint_completion_target = &#39;0.9&#39;archive_mode = &#39;on&#39;archive_command = &#39;/bin/true&#39;random_page_cost = &#39;1.0&#39;effective_cache_size = &#39;80GB&#39;maintenance_work_mem = &#39;2GB&#39;autovacuum_vacuum_scale_factor = &#39;0.4&#39;bgwriter_lru_maxpages = &#39;1000&#39;bgwriter_lru_multiplier = &#39;10.0&#39;wal_compression = &#39;ON&#39;log_checkpoints = &#39;ON&#39;log_autovacuum_min_duration = &#39;0&#39;</p><p>     max_connections =＆＃39; 200＆＃39;shared_buffers =＆＃39; 32GB＆＃39;checkpoint_timeout =＆＃39; 1h＆＃39;max_wal_size =＆＃39; 96GB＆＃39;checkpoint_completion_target =＆＃39; 0.9＆＃39;archive_mode =＆on＆＃39;archive_command =＆＃39; / bin / true＆＃39;random_page_cost =＆＃39; 1.0＆＃39;Effective_cache_size =＆＃39; 80GB＆＃39;maintenance_work_mem =＆＃39; 2GB＆＃39;autovacuum_vacuum_scale_factor =＆＃39; 0.4＆＃39;bgwriter_lru_maxpages =＆＃39; 1000＆＃39;bgwriter_lru_multiplier =＆＃39; 10.0＆＃39;wal_compression =＆＃39; ON＆＃39;log_checkpoints =＆＃39; ON＆＃39;log_autovacuum_min_duration =＆＃39; 0＆＃39;</p><p>    First, a preliminary round of tests is done using pgbench, the micro-benchmarking tool available with PostgreSQL. This allows us to test with a different combination of a number of clients and jobs like:</p><p>    首先，使用pgbench（PostgreSQL附带的微基准标记工具）进行了初步的测试。这使我们可以测试多个客户和工作的不同组合，例如：</p><p>      The default load that 			   pgbench creates is a tpcb-like Read-write load. We used the same on a PostgreSQL instance which doesn’t have checksum enabled.   We could see a  19% performance gain on ARM.</p><p>      pgbench创建的默认负载是类似tpcb的读写负载。我们在未启用校验和的PostgreSQL实例上使用了相同的命令。我们可以看到ARM的性能提高了19％。</p><p>    We were curious whether the checksum calculation has any impact on Performance due to the architecture difference. if the PostgreSQL level checksum is enabled. PostgreSQL 12 onwards, the checksum can be enabled using pg_checksum utility as follows:</p><p>    我们很好奇校验和计算是否由于体系结构差异而对性能有任何影响。如果启用了PostgreSQL级别的校验和。从PostgreSQL 12开始，可以使用pg_checksum实用程序启用校验和，如下所示：</p><p>      To our surprise, the results were marginally better! Since the difference is around just 1.7%, we consider it as a noise. At least we feel that it is ok to conclude that enabling checksum doesn’t have any noticeable performance degradation on these modern processors.</p><p>      令我们惊讶的是，结果略好！由于差异仅为1.7％，因此我们将其视为噪音。至少我们可以断定，启用校验和不会对这些现代处理器造成明显的性能下降。</p><p>  Read-only loads are expected to be CPU-centric. Since we selected a database size that fully fits into memory, we could eliminate IO related overheads.</p><p>  只读负载应以CPU为中心。由于我们选择的数据库大小完全适合内存，因此可以消除与IO相关的开销。 </p><p>  The results showed a  30% gain in tps for the ARM than the x86 instance.</p><p>结果显示，与x86实例相比，ARM的tps增长了30％。</p><p>   We wanted to check whether we could observe any tps change if we have checksum enabled when the load becomes purely CPU centric.</p><p>   我们想检查如果负载完全以CPU为中心时启用校验和，是否可以观察到tps的变化。</p><p>   In pgbench tests, we observed that as the load becomes CPU centric, the difference in performance increases. We couldn’t observe any performance degradation with checksum.</p><p>   在pgbench测试中，我们观察到随着负载以CPU为中心，性能差异会增加。我们无法通过校验和观察到任何性能下降。</p><p>  PostgreSQL calculates and writes checksum for pages when they are written out and read in the buffer pool. In addition, hint bits are always logged when checksums are enabled, increasing the WAL IO pressure. To correctly validate the overall checksum overhead, we would need longer and larger testing, similar to once we did with sysbench-tpcc.</p><p>  当页面被写出并在缓冲池中读取时，PostgreSQL计算并写入页面的校验和。此外，启用校验和时，总是记录提示位，从而增加了WAL IO压力。为了正确地验证总的校验和开销，我们需要更长和更大的测试，这与对sysbench-tpcc所做的类似。</p><p>  We decided to perform more detailed tests using  sysbench-tpcc. We were mainly interested in the case where the database fits into memory. On a side note, while PostgreSQL on the arm server showed no issues, sysbench was much more finicky compared to the x86 one.</p><p>  我们决定使用sysbench-tpcc执行更详细的测试。我们主要对数据库适合内存的情况感兴趣。附带说明一下，虽然臂架服务器上的PostgreSQL没有出现问题，但与x86相比，sysbench更为灵活。</p><p>     With this moderate load, the ARM instance shows around  15.5% better performance than the x86 instance. Here and after, the percentage difference is based on the mean tps value.</p><p>     在这种中等负载下，ARM实例的性能比x86实例高出约15.5％。在此前后，百分比差基于平均tps值。</p><p> You might be wondering why there is a sudden drop in performance towards the end of the test. It is related to checkpointing with 			   full_page_writes. Even though for in-memory testing we used pareto distribution, a considerable amount of pages is going to be written out after each checkpoint. In this case, the instance showing more performance triggered checkpoint by WAL earlier than its counterpart. These dips are going to be present across all tests performed.</p><p> 您可能想知道为什么在测试结束时性能突然下降。它与带有full_page_writes的检查点有关。即使在内存测试中我们使用了pareto分布，每个检查点之后也会写出相当多的页面。在这种情况下，WAL实例比实例实例显示更多的性能触发了WAL检查点。这些下降将在所有执行的测试中出现。 </p><p>      Pushing instances close to their saturation point (remember, both are 32-cpu instances), we see the difference reducing further to  4.5%.</p><p>将实例逼近其饱和点（请记住，两个实例均为32 cpu实例），我们发现差异进一步降低到4.5％。</p><p>   When both instances are past their saturation point, the difference in performance becomes negligible, although it’s still there at  1.4% Additionally, we could observe a  6-7% drop in throughput(tps) for ARM and a  4% drop for x86 when concurrency increased from 64 to 128 on these 32 vCPU machines.</p><p>   当两个实例都超过其饱和点时，性能的差异可以忽略不计，尽管仍为1.4％。此外，当并发时，我们可以观察到ARM的吞吐量（tps）下降了6-7％，x86的下降了4％。在这32个vCPU机器上从64增加到128。</p><p> Not everything we measured is favorable to the Graviton2-based instance. In the IO-bound tests (~200G dataset, 200 warehouses, uniform distribution), we saw less difference between the two instances, and at 64 and 128 threads, regular m5d instance performed better. You can see this on the combined plots below.</p><p> 并非我们所测量的所有内容都适合基于Graviton2的实例。在IO绑定测试（约200G数据集，200个仓库，均匀分布）中，我们看到两个实例之间的差异较小，并且在64和128个线程下，常规m5d实例的性能更好。您可以在下面的组合图中看到这一点。</p><p>  A possible reason for this, especially the significant meltdown at 128 threads for m6gd.8xlarge, is that it lacks the second drive that m5d.8xlarge has. There’s no perfectly comparable couple of instances available currently, so we consider this a fair comparison; each instance type has an advantage. More testing and profiling is necessary to correctly identify the cause, as we expected local drives to negligibly affect the tests. IO-bound testing with EBS can potentially be performed to try and remove the local drives from the equation.</p><p>  造成这种情况的一个可能原因，尤其是对于m6gd.8xlarge在128个线程处发生的严重崩溃是因为它缺少m5d.8xlarge拥有的第二个驱动器。目前尚无完全可比的实例，因此我们认为这是一个合理的比较；每个实例类型都有一个优势。由于我们希望本地驱动器对测试的影响可以忽略不计，因此需要更多测试和配置文件才能正确识别原因。可以执行EBS的IO绑定测试，以尝试从等式中删除本地驱动器。</p><p> More details of the test setup, results of the tests, scripts used, and data generated during the testing are available from  this GitHub repo.</p><p> 可以从此GitHub存储库中获得有关测试设置，测试结果，使用的脚本以及测试期间生成的数据的更多详细信息。</p><p>  There were not many cases where the ARM instance becomes slower than the x86 instance in the tests we performed. The test results were consistent throughout the testing of the last couple of days. While ARM-based instance is 25 percent cheaper, it is able to show a 15-20% performance gain in most of the tests over the corresponding x86 based instances. So ARM-based instances are giving conclusively better price-performance in all aspects. We should expect more and more cloud providers to provide ARM-based instances in the future . Please let us know if you wish to see any different type of benchmark tests.</p><p>  在我们执行的测试中，很少有ARM实例比x86实例慢的情况。在过去几天的整个测试过程中，测试结果均保持一致。尽管基于ARM的实例便宜25％，但在大多数测试中，与基于x86的实例相比，它可以显示15-20％的性能提升。因此，基于ARM的实例在所有方面最终都具有更好的性价比。我们应该期望将来有越来越多的云提供商提供基于ARM的实例。如果您希望查看任何其他类型的基准测试，请告诉我们。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.percona.com/blog/2021/01/22/postgresql-on-arm-based-aws-ec2-instances-is-it-any-good/">https://www.percona.com/blog/2021/01/22/postgresql-on-arm-based-aws-ec2-instances-is-it-any-good/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/aws/">#aws</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/arm/">#arm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实例/">#实例</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>