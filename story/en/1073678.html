<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>当你输入谷歌时会发生什么。进入浏览器，然后按enter？What happens when you type google.com into the browser and press enter?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What happens when you type google.com into the browser and press enter?<br/>当你输入谷歌时会发生什么。进入浏览器，然后按enter？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 03:12:06</div><div class="page_narrow text-break page_content"><p>This repository is an attempt to answer the age-old interview question &#34;Whathappens when you type google.com into your browser&#39;s address box and pressenter?&#34;</p><p>这个知识库试图回答一个由来已久的面试问题#34；当你输入谷歌时会发生什么。进入你的浏览器&#39；s地址框，然后按Enter&#34;</p><p> Except instead of the usual story, we&#39;re going to try to answer this questionin as much detail as possible. No skipping out on anything.</p><p>除了通常的故事，我们&#39；我们将尽可能详细地回答这个问题。任何事都不能漏掉。</p><p> This is a collaborative process, so dig in and try to help out! There are tonsof details missing, just waiting for you to add them! So send us a pullrequest, please!</p><p>这是一个协作的过程，所以请深入挖掘并尝试帮助！有一些细节缺失，只是在等待你添加它们！所以请给我们发一个请求！</p><p>  Read this in  简体中文 (simplified Chinese),  日本語 (Japanese),  한국어(Korean) and  Spanish. NOTE: these have not been reviewed by the alex/what-happens-whenmaintainers.</p><p>读读这篇文章简体中文 （简体中文），日本語 （日语），한국어（韩语）和西班牙语。注：alex未对这些进行审查/维护时会发生什么。</p><p>      The following sections explain the physical keyboard actionsand the OS interrupts. When you press the key &#34;g&#34; the browser receives theevent and the auto-complete functions kick in.Depending on your browser&#39;s algorithm and if you are inprivate/incognito mode or not various suggestions will be presentedto you in the dropdown below the URL bar. Most of these algorithms sortand prioritize results based on search history, bookmarks, cookies, andpopular searches from the internet as a whole. As you are typing&#34;google.com&#34; many blocks of code run and the suggestions will be refinedwith each keypress. It may even suggest &#34;google.com&#34; before you finish typingit.</p><p>以下部分解释了物理键盘操作和操作系统中断。当你按下&#34；g&#34；浏览器接收事件和自动完成功能。取决于你的浏览器&#39；s算法，如果您处于私密/匿名模式或没有，各种建议将在URL栏下方的下拉列表中呈现给您。这些算法大多基于搜索历史、书签、cookie和整个互联网上的热门搜索对结果进行排序和排序。当你输入&#34；谷歌。com&#34；许多代码块会运行，建议会随着每次按键而细化。它甚至可能暗示&#34；谷歌。com&#34；在你完成打字之前。</p><p>   To pick a zero point, let&#39;s choose the Enter key on the keyboard hitting thebottom of its range. At this point, an electrical circuit specific to the enterkey is closed (either directly or capacitively). This allows a small amount ofcurrent to flow into the logic circuitry of the keyboard, which scans the stateof each key switch, debounces the electrical noise of the rapid intermittentclosure of the switch, and converts it to a keycode integer, in this case 13.The keyboard controller then encodes the keycode for transport to the computer.This is now almost universally over a Universal Serial Bus (USB) or Bluetoothconnection, but historically has been over PS/2 or ADB connections.</p><p>要选择一个零点，让&#39；s选择键盘上的Enter键，点击其范围的底部。此时，特定于enterkey的电路闭合（直接或电容）。这允许少量电流流入键盘的逻辑电路，该电路扫描每个按键开关的状态，消除开关快速间歇性闭合的电气噪声，并将其转换为按键代码整数，在本例中为13。然后，键盘控制器对键盘代码进行编码，以便传输到计算机。现在，这几乎普遍通过通用串行总线（USB）或蓝牙连接实现，但历史上一直通过PS/2或ADB连接实现。</p><p>  The USB circuitry of the keyboard is powered by the 5V supply provided overpin 1 from the computer&#39;s USB host controller.</p><p>键盘的USB电路由计算机提供的5V电源供电&#39；USB主机控制器。</p><p>  The host USB controller polls that &#34;endpoint&#34; every ~10ms (minimum valuedeclared by the keyboard), so it gets the keycode value stored on it.</p><p>主机USB控制器轮询&#34；终点#34；每隔10毫秒（键盘声明的最小值），它就会获得存储在键盘上的键码值。</p><p> This value goes to the USB SIE (Serial Interface Engine) to be converted inone or more USB packets that follow the low-level USB protocol.</p><p>该值将传输至USB SIE（串行接口引擎），以便在一个或多个遵循低级USB协议的USB数据包中进行转换。</p><p> Those packets are sent by a differential electrical signal over D+ and D-pins (the middle 2) at a maximum speed of 1.5 Mb/s, as an HID(Human Interface Device) device is always declared to be a &#34;low-speed device&#34;(USB 2.0 compliance).</p><p>这些数据包通过差分电信号通过D+和D-引脚（中间2）以1.5 Mb/s的最大速度发送，因为HID（人机界面设备）设备总是被声明为a&#34；低速装置&#34；（符合USB 2.0标准）。</p><p> This serial signal is then decoded at the computer&#39;s host USB controller, andinterpreted by the computer&#39;s Human Interface Device (HID) universal keyboarddevice driver. The value of the key is then passed into the operatingsystem&#39;s hardware abstraction layer.</p><p>然后在计算机上对该串行信号进行解码&#39；主机USB控制器，并由计算机#39；s人机界面设备（HID）通用键盘设备驱动程序。然后键的值被传递到操作系统&#39；硬件抽象层。</p><p>  When the user puts their finger on a modern capacitive touch screen, atiny amount of current gets transferred to the finger. This completes thecircuit through the electrostatic field of the conductive layer andcreates a voltage drop at that point on the screen. The screen controller then raises an interrupt reporting the coordinate ofthe keypress.</p><p>当用户将手指放在现代电容式触摸屏上时，几乎所有的电流都会传输到手指上。这就完成了通过导电层静电场的电路，并在屏幕上的该点产生电压降。然后，屏幕控制器触发一个中断，报告按键的坐标。</p><p> Then the mobile OS notifies the currently focused application of a press eventin one of its GUI elements (which now is the virtual keyboard applicationbuttons).</p><p>然后，移动操作系统将其GUI元素之一（现在是虚拟键盘应用程序按钮）中的按下事件通知当前关注的应用程序。</p><p> The virtual keyboard can now raise a software interrupt for sending a&#39;key pressed&#39; message back to the OS.</p><p>虚拟键盘现在可以引发软件中断，以发送&#39；按键&#39；消息返回操作系统。</p><p>   The keyboard sends signals on its interrupt request line (IRQ), which is mappedto an  interrupt vector (integer) by the interrupt controller. The CPU usesthe  Interrupt Descriptor Table (IDT) to map the interrupt vectors tofunctions ( interrupt handlers) which are supplied by the kernel. When aninterrupt arrives, the CPU indexes the IDT with the interrupt vector and runsthe appropriate handler. Thus, the kernel is entered.</p><p>键盘在其中断请求行（IRQ）上发送信号，中断控制器将其映射为中断向量（整数）。CPU使用中断描述符表（IDT）将中断向量映射到内核提供的函数（中断处理程序）。当中断到达时，CPU用中断向量对IDT进行索引，并运行相应的处理程序。这样，就进入了内核。</p><p>   The HID transport passes the key down event to the  KBDHID.sys driver whichconverts the HID usage into a scancode. In this case, the scan code is VK_RETURN ( 0x0D). The  KBDHID.sys driver interfaces with the KBDCLASS.sys (keyboard class driver). This driver is responsible forhandling all keyboard and keypad input in a secure manner. It then calls into Win32K.sys (after potentially passing the message through 3rd partykeyboard filters that are installed). This all happens in kernel mode.</p><p>HID传输将按键向下事件传递给KBDHID。将HID使用转换为扫描码的sys驱动程序。在这种情况下，扫描代码为VK_RETURN（0x0D）。KBDHID。sys驱动程序与KBDCLASS接口。sys（键盘类驱动程序）。该驱动程序负责以安全的方式处理所有键盘和小键盘输入。然后调用Win32K。sys（可能通过安装的第三方主板过滤器传递消息后）。这一切都发生在内核模式下。</p><p> Win32K.sys figures out what window is the active window through the GetForegroundWindow() API. This API provides the window handle of thebrowser&#39;s address box. The main Windows &#34;message pump&#34; then calls SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam).  lParam is a bitmaskthat indicates further information about the keypress: repeat count (0 in thiscase), the actual scan code (can be OEM dependent, but generally wouldn&#39;t befor  VK_RETURN), whether extended keys (e.g. alt, shift, ctrl) were alsopressed (they weren&#39;t), and some other state.</p><p>Win32K。sys通过getForeGroundIndow（）API确定哪个窗口是活动窗口。这个API提供了浏览器的窗口句柄#39；s的地址框。主窗口&#34；信息泵&#34；然后调用SendMessage（hWnd、WM_KEYDOWN、VK_RETURN、lParam）。lParam是一个位掩码，表示有关按键的进一步信息：重复计数（在本例中为0）、实际扫描代码（可能取决于OEM，但通常在VK#U返回之前不会出现），是否也按下了扩展键（例如alt、shift、ctrl）（它们没有出现）以及其他一些状态。</p><p> The Windows  SendMessage API is a straightforward function thatadds the message to a queue for the particular window handle ( hWnd).Later, the main message processing function (called a  WindowProc) assignedto the  hWnd is called in order to process each message in the queue.</p><p>Windows SendMessage API是一个简单的函数，它将消息添加到特定窗口句柄（hWnd）的队列中。随后，调用分配给hWnd的主消息处理函数（称为WindowProc），以便处理队列中的每条消息。</p><p> The window ( hWnd) that is active is actually an edit control and the WindowProc in this case has a message handler for  WM_KEYDOWN messages.This code looks within the 3rd parameter that was passed to  SendMessage( wParam) and, because it is  VK_RETURN knows the user has hit the ENTERkey.</p><p>处于活动状态的窗口（hWnd）实际上是一个编辑控件，在本例中，WindowProc有一个用于WM_KEYDOWN消息的消息处理程序。这段代码在传递给SendMessage（wParam）的第三个参数中查找，因为它是VK_RETURN，所以知道用户已经点击了ENTERkey。</p><p>   The interrupt signal triggers an interrupt event in the I/O Kit kext keyboarddriver. The driver translates the signal into a key code which is passed to theOS X  WindowServer process. Resultantly, the  WindowServer dispatches anevent to any appropriate (e.g. active or listening) applications through theirMach port where it is placed into an event queue. Events can then be read fromthis queue by threads with sufficient privileges calling the mach_ipc_dispatch function. This most commonly occurs through, and ishandled by, an  NSApplication main event loop, via an  NSEvent of NSEventType  KeyDown.</p><p>中断信号触发I/O Kit kext键盘驱动程序中的中断事件。驱动程序将信号转换为密钥代码，并将其传递给theOS X Windows Server进程。结果，Windows服务器通过其RMACH端口将事件发送到任何适当的（例如，活动或侦听）应用程序，并将其放入事件队列中。然后，具有足够权限的线程可以调用mach_ipc_dispatch函数从该队列读取事件。这通常通过NSEventType KeyDown的NSEvent通过NSApplication主事件循环发生，并由其处理。</p><p>   When a graphical  X server is used,  X will use the generic eventdriver  evdev to acquire the keypress. A re-mapping of keycodes to scancodesis made with  X server specific keymaps and rules.When the scancode mapping of the key pressed is complete, the  X serversends the character to the  window manager (DWM, metacity, i3, etc), so the window manager in turn sends the character to the focused window.The graphical API of the window that receives the character prints theappropriate font symbol in the appropriate focused field.</p><p>当使用图形X服务器时，X将使用通用事件驱动程序evdev获取按键。使用X服务器特定的密钥映射和规则将密钥码重新映射到扫描码。当按下键的扫描码映射完成时，X服务器将字符发送到窗口管理器（DWM、metacity、i3等），因此窗口管理器依次将字符发送到聚焦窗口。接收字符的窗口的图形API会在相应的聚焦字段中打印相应的字体符号。</p><p>      When no protocol or valid domain name is given the browser proceeds to feedthe text given in the address box to the browser&#39;s default web search engine.In many cases the URL has a special piece of text appended to it to tell thesearch engine that it came from a particular browser&#39;s URL bar.</p><p>当没有提供协议或有效域名时，浏览器继续将地址框中给出的文本反馈给浏览器&#39；默认的网络搜索引擎。在很多情况下，URL会附加一段特殊的文本，告诉搜索引擎它来自特定的浏览器#39；s的URL栏。</p><p>   The browser checks the hostname for characters that are not in  a-z, A-Z,  0-9,  -, or  ..</p><p>浏览器会检查主机名中是否有不在a-z、a-z、0-9、、、或..中的字符。。</p><p> Since the hostname is  google.com there won&#39;t be any, but if there werethe browser would apply  Punycode encoding to the hostname portion of theURL.</p><p>因为主机名是google。com那里赢了&#39；没有，但如果有，浏览器会对URL的主机名部分应用Punycode编码。</p><p>   The browser checks its &#34;preloaded HSTS (HTTP Strict Transport Security)&#34;list. This is a list of websites that have requested to be contacted viaHTTPS only.</p><p>浏览器检查其&#34；预装HST（HTTP严格传输安全）和#34；列表这是一个只要求通过HTTPS联系的网站列表。</p><p> If the website is in the list, the browser sends its request via HTTPSinstead of HTTP. Otherwise, the initial request is sent via HTTP.(Note that a website can still use the HSTS policy  without being in theHSTS list. The first HTTP request to the website by a user will receive aresponse requesting that the user only send HTTPS requests. However, thissingle HTTP request could potentially leave the user vulnerable to a downgrade attack, which is why the HSTS list is included in modern webbrowsers.)</p><p>如果网站在列表中，浏览器将通过HttpSin而不是HTTP发送其请求。否则，初始请求将通过HTTP发送。（请注意，网站仍然可以使用HSTS策略，而不在HSTS列表中。用户对网站的第一个HTTP请求将收到一个应答，请求用户只发送HTTPS请求。但是，这个HTTP请求可能会让用户容易受到降级攻击，这就是为什么HSTS列表包含在mo中。）德恩·韦伯·克鲁斯。）</p><p>   Browser checks if the domain is in its cache. (to see the DNS Cache inChrome, go to chrome://net-internals/#dns).</p><p>浏览器检查域是否在其缓存中。（要查看罗马的DNS缓存，请转到chrome://net-internals/#dns).</p><p> If not found, the browser calls  gethostbyname library function (varies byOS) to do the lookup.</p><p>如果找不到，浏览器将调用gethostbyname库函数（不同的byOS）进行查找。</p><p> gethostbyname checks if the hostname can be resolved by reference in thelocal  hosts file (whose location  varies by OS) before trying toresolve the hostname through DNS.</p><p>gethostbyname在尝试通过DNS解析主机名之前，检查主机名是否可以通过本地主机文件（其位置因操作系统而异）中的引用解析。</p><p> If  gethostbyname does not have it cached nor can find it in the  hostsfile then it makes a request to the DNS server configured in the networkstack. This is typically the local router or the ISP&#39;s caching DNS server.</p><p>如果gethostbyname没有缓存它，也无法在hostsfile中找到它，那么它会向网络堆栈中配置的DNS服务器发出请求。这通常是本地路由器或ISP&#39；正在缓存DNS服务器。</p><p> If the DNS server is on the same subnet the network library follows the ARP process below for the DNS server.</p><p>如果DNS服务器位于同一子网上，则网络库将遵循下面针对DNS服务器的ARP过程。</p><p> If the DNS server is on a different subnet, the network library followsthe  ARP process below for the default gateway IP.</p><p>如果DNS服务器位于不同的子网中，则网络库将遵循以下默认网关IP的ARP过程。</p><p>   In order to send an ARP (Address Resolution Protocol) broadcast the networkstack library needs the target IP address to lookup. It also needs to know theMAC address of the interface it will use to send out the ARP broadcast.</p><p>为了发送ARP（地址解析协议）广播，networkstack库需要查找目标IP地址。它还需要知道用于发送ARP广播的接口的MAC地址。</p><p> The ARP cache is first checked for an ARP entry for our target IP. If it is inthe cache, the library function returns the result: Target IP = MAC.</p><p>ARP缓存首先检查目标IP的ARP条目。如果它在缓存中，库函数将返回结果：Target IP=MAC。</p><p>  The route table is looked up, to see if the Target IP address is on any ofthe subnets on the local route table. If it is, the library uses theinterface associated with that subnet. If it is not, the library uses theinterface that has the subnet of our default gateway.</p><p>查找路由表，查看目标IP地址是否位于本地路由表上的任何子网上。如果是，库将使用与该子网关联的接口。如果不是，库将使用包含默认网关子网的接口。</p><p>  The network library sends a Layer 2 (data link layer of the  OSI model)ARP request:</p><p>网络库发送第2层（OSI模型的数据链路层）ARP请求：</p><p>     If the computer is directly connected to the router the router responsewith an  ARP Reply (see below)</p><p>如果计算机直接连接到路由器，路由器会用ARP应答（见下文）</p><p>  If the computer is connected to a hub, the hub will broadcast the ARPrequest out of all other ports. If the router is connected on the same &#34;wire&#34;,it will respond with an  ARP Reply (see below).</p><p>如果计算机连接到集线器，集线器将从所有其他端口广播ARP请求。如果路由器连接在同一个&#34；电线&#34；，它将以ARP回复（见下文）进行回复。</p><p>  If the computer is connected to a switch, the switch will check its localCAM/MAC table to see which port has the MAC address we are looking for. Ifthe switch has no entry for the MAC address it will rebroadcast the ARPrequest to all other ports.</p><p>如果计算机连接到交换机，交换机将检查其localCAM/MAC表，以查看哪个端口具有我们正在寻找的MAC地址。如果交换机没有MAC地址条目，它会将ARP请求重新广播到所有其他端口。</p><p> If the switch has an entry in the MAC/CAM table it will send the ARP requestto the port that has the MAC address we are looking for.</p><p>如果交换机在MAC/CAM表中有一个条目，它会将ARP请求发送到具有我们正在寻找的MAC地址的端口。</p><p> If the router is on the same &#34;wire&#34;, it will respond with an  ARP Reply(see below)</p><p>如果路由器在同一个&#34；电线&#34；，它将以ARP回复（见下文）进行回复</p><p>   Now that the network library has the IP address of either our DNS server orthe default gateway it can resume its DNS process:</p><p>现在，网络库具有我们的DNS服务器或默认网关的IP地址，它可以恢复其DNS进程：</p><p> The DNS client establishes a socket to UDP port 53 on the DNS server,using a source port above 1023.</p><p>DNS客户端使用1023以上的源端口在DNS服务器上建立到UDP端口53的套接字。</p><p>  If the local/ISP DNS server does not have it, then a recursive search isrequested and that flows up the list of DNS servers until the SOA is reached,and if found an answer is returned.</p><p>如果本地/ISP DNS服务器没有，则需要进行递归搜索，该搜索将沿着DNS服务器列表向上流动，直到到达SOA，如果找到，则返回答案。</p><p>   Once the browser receives the IP address of the destination server, it takesthat and the given port number from the URL (the HTTP protocol defaults to port80, and HTTPS to port 443), and makes a call to the system library functionnamed  socket and requests a TCP socket stream -  AF_INET/AF_INET6 and SOCK_STREAM.</p><p>一旦浏览器接收到目标服务器的IP地址，它就会从URL获取该地址和给定的端口号（HTTP协议默认为port80，HTTPS默认为Port443），并调用名为socket的系统库函数，请求TCP套接字流——AF_INET/AF_INET6和SOCK_流。</p><p> This request is first passed to the Transport Layer where a TCP segment iscrafted. The destination port is added to the header, and a source port ischosen from within the kernel&#39;s dynamic port range (ip_local_port_range inLinux).</p><p>该请求首先被传递到传输层，在传输层中起草了一个TCP段。目标端口被添加到报头中，源端口从内核中被关闭&#39；s动态端口范围（ip_local_port_range inLinux）。</p><p> This segment is sent to the Network Layer, which wraps an additional IPheader. The IP address of the destination server as well as that of thecurrent machine is inserted to form a packet.</p><p>这个片段被发送到网络层，网络层封装了一个额外的iPhone阅读器。插入目标服务器和当前机器的IP地址以形成数据包。</p><p> The packet next arrives at the Link Layer. A frame header is added thatincludes the MAC address of the machine&#39;s NIC as well as the MAC address ofthe gateway (local router). As before, if the kernel does not know the MACaddress of the gateway, it must broadcast an ARP query to find it.</p><p>数据包接下来到达链路层。添加一个帧头，其中包括机器的MAC地址#39；s NIC以及网关（本地路由器）的MAC地址。与之前一样，如果内核不知道网关的MACaddress，它必须广播一个ARP查询来找到它。</p><p>   For most home or small business Internet connections the packet will pass fromyour computer, possibly through a local network, and then through a modem(MOdulator/DEModulator) which converts digital 1&#39;s and 0&#39;s into an analogsignal suitable for transmission over telephone, cable, or wireless telephonyconnections. On the other end of the connection is another modem which convertsthe analog signal back into digital data to be processed by the next  networknode where the from and to addresses would be analyzed further.</p><p>对于大多数家庭或小型企业的互联网连接，数据包将从您的计算机上传送，可能会通过本地网络，然后通过调制解调器（调制器/解调器）转换数字1和#39；s和0&#39；转换成适合通过电话、电缆或无线电话连接传输的模拟信号。在连接的另一端是另一个调制解调器，它将模拟信号转换回数字数据，由下一个网络节点进行处理，在下一个网络节点上，将进一步分析from和to地址。</p><p> Most larger businesses and some newer residential connections will have fiberor direct Ethernet connections in which case the data remains digital andis passed directly to the next  network node for processing.</p><p>大多数大型企业和一些较新的住宅连接将采用光纤或直接以太网连接，在这种情况下，数据仍然是数字的，并直接传递到下一个网络节点进行处理。</p><p> Eventually, the packet will reach the router managing the local subnet. Fromthere, it will continue to travel to the autonomous system&#39;s (AS) borderrouters, other ASes, and finally to the destination server. Each router alongthe way extracts the destination address from the IP header and routes it tothe appropriate next hop. The time to live (TTL) field in the IP header isdecremented by one for each router that passes. The packet will be dropped ifthe TTL field reaches zero or if the current router has no space in its queue(perhaps due to network congestion).</p><p>最终，数据包将到达管理本地子网的路由器。从那里，它将继续进入自治系统#39；s（AS）边界路由器、其他ASE，最后连接到目标服务器。沿途的每个路由器从IP报头中提取目标地址，并将其路由到适当的下一跳。IP报头中的生存时间（TTL）字段对于通过的每个路由器减少一个。如果TTL字段为零或当前路由器队列中没有空间（可能是由于网络拥塞），则数据包将被丢弃。</p><p>  Client chooses an initial sequence number (ISN) and sends the packet to theserver with the SYN bit set to indicate it is setting the ISN</p><p>客户机选择一个初始序列号（ISN），并将设置了SYN位的数据包发送到服务器，以指示其正在设置ISN</p><p> Server copies the (client ISN +1) to its ACK field and adds the ACK flagto indicate it is acknowledging receipt of the first packet</p><p>服务器将（客户机ISN+1）复制到其ACK字段，并添加ACK标志，以指示其正在确认收到第一个数据包</p><p>  When the other side acknowledges receipt of that packet (or a string ofpackets), it sends an ACK packet with the ACK value equal to the lastreceived sequence from the other</p><p>当另一方确认收到该数据包（或一串数据包）时，它发送一个ACK数据包，其ACK值等于从另一方收到的最后一个序列</p><p>   The client computer sends a  ClientHello message to the server with itsTransport Layer Security (TLS) version, list of cipher algorithms andcompression methods available.</p><p>客户端计算机向服务器发送ClientHello消息，其中包含其传输层安全性（TLS）版本、密码算法列表和可用的压缩方法。</p><p> The server replies with a  ServerHello message to the client with theTLS version, selected cipher, selected compression methods and the server&#39;spublic certificate signed by a CA (Certificate Authority). The certificatecontains a public key that will be used by the client to encrypt the rest ofthe handshake until a symmetric key can be agreed upon.</p><p>服务器用ServerHello消息向客户端回复TLS版本、所选密码、所选压缩方法和服务器&#39；由CA（证书颁发机构）签署的spublic证书。证书包含一个公钥，客户端将使用该公钥加密握手的其余部分，直到可以商定一个对称密钥。</p><p> The client verifies the server digital certificate against its list oftrusted CAs. If trust can be established based on the CA, the clientgenerates a string of pseudo-random bytes and encrypts this with the server&#39;spublic key. These random bytes can be used to determine the symmetric key.</p><p>客户端根据其受信任的CA列表验证服务器数字证书。如果可以基于CA建立信任，客户端将生成一个伪随机字节字符串，并使用服务器对其进行加密&#39；spublic钥匙。这些随机字节可用于确定对称密钥。</p><p> The server decrypts the random bytes using its private key and uses thesebytes to generate its own copy of the symmetric master key.</p><p>服务器使用其私钥解密随机字节，并使用这些字节生成自己的对称主密钥副本。</p><p> The client sends a  Finished message to the server, encrypting a hash ofthe transmission up to this point with the symmetric key.</p><p>客户端向服务器发送一条完成的消息，并使用对称密钥加密到目前为止的传输哈希。</p><p> The server generates its own hash, and then decrypts the client-sent hashto verify that it matches. If it does, it sends its own  Finished messageto the client, also encrypted with the symmetric key.</p><p>服务器生成自己的哈希，然后对客户端发送的哈希进行解密，以验证其匹配性。如果是这样，它会将自己完成的消息发送到客户端，并使用对称密钥进行加密。</p><p> From now on the TLS session transmits the application (HTTP) data encryptedwith the agreed symmetric key.</p><p>从现在起，TLS会话将传输使用约定的对称密钥加密的应用程序（HTTP）数据。</p><p>   Sometimes, due to network congestion or flaky hardware connections, TLS packetswill be dropped before they get to their final destination. The sender then hasto decide how to react. The algorithm for this is called  TCP congestioncontrol. This varies depending on the sender; the most common algorithms are cubic on newer operating systems and  New Reno on almost all others.</p><p>有时，由于网络拥塞或硬件连接不良，TLS包在到达最终目的地之前会被丢弃。然后，发送者必须决定如何反应。这种算法称为TCP拥塞控制。这取决于发送者；最常见的算法是新操作系统上的cubic算法和几乎所有其他系统上的New Reno算法。</p><p> For each packet acknowledged, the window doubles in size until it reaches the&#39;slow-start threshold&#39;. In some implementations, this threshold is adaptive.</p><p>对于每个已确认的数据包，窗口的大小都会翻倍，直到达到&#39；慢启动阈值&#39；。在某些实现中，该阈值是自适应的。</p><p> After reaching the slow-start threshold, the window increases additively foreach packet acknowledged. If a packet is dropped, the window reducesexponentially until another packet is acknowledged.</p><p>在达到慢启动阈值后，每个已确认的数据包的窗口都会增加。如果一个数据包被丢弃，窗口将以指数形式缩小，直到另一个数据包被确认。</p><p>   If the web browser used was written by Google, instead of sending an HTTPrequest to retrieve the page, it will send a request to try and negotiate withthe server an &#34;upgrade&#34; from HTTP to the SPDY protocol.</p><p>如果使用的网络浏览器是由谷歌编写的，它将发送一个请求，尝试与服务器进行协商，而不是发送一个HTTPrequest来检索页面；升级&#34；从HTTP到SPDY协议。</p><p> If the client is using the HTTP protocol and does not support SPDY, it sends arequest to the server of the form:</p><p>如果客户端使用HTTP协议且不支持SPDY，则会向服务器发送请求，格式如下：</p><p>  where  [other headers] refers to a series of colon-separated key-value pairsformatted as per the HTTP specification and separated by single newlines.(This assumes the web browser being used doesn&#39;t have any bugs violating theHTTP spec. This also assumes that the web browser is using  HTTP/1.1,otherwise it may not include the  Host header in the request and the versionspecified in the  GET request will either be  HTTP/1.0 or  HTTP/0.9.)</p><p>其中，[other Header]指的是一系列按HTTP规范格式化的以冒号分隔的键值对，并由单个换行符分隔。（这假设正在使用的web浏览器没有任何违反HTTP规范的错误。这还假设web浏览器正在使用HTTP/1.1，否则它可能不会在请求中包含主机头，GET请求中指定的版本将是HTTP/1.0或HTTP/0.9。）</p><p> HTTP/1.1 defines the &#34;close&#34; connection option for the sender to signal thatthe connection will be closed after completion of the response. For example,</p><p>HTTP/1.1定义了&#34；关闭&#34；连接选项，用于发送方在响应完成后发出连接将关闭的信号。例如</p><p>  HTTP/1.1 applications that do not support persistent connections MUST includethe &#34;close&#34; connection option in every message.</p><p>不支持持久连接的HTTP/1.1应用程序必须包括&#34；关闭&#34；每个消息中都有连接选项。</p><p> After sending the request and headers, the web browser sends a single blanknewline to the server indicating that the content of the request is done.</p><p>在发送请求和标题后，web浏览器会向服务器发送一行空白换行符，指示请求的内容已完成。</p><p> The server responds with a response code denoting the status of the request andresponds with a response of the form:</p><p>服务器用表示请求状态的响应代码进行响应，并用以下形式的响应进行响应：</p><p>  Followed by a single newline, and then sends a payload of the HTML content of www.google.com. The server may then either close the connection, or ifheaders sent by the client requested it, keep the connection open to be reusedfor further requests.</p><p>后跟一条换行，然后发送www.google的HTML内容的有效负载。通用域名格式。然后，服务器可以关闭连接，或者如果客户机发送了请求连接的头，则保持连接打开，以便重新用于进一步的请求。</p><p> If the HTTP headers sent by the web browser included sufficient information forthe webserver to determine if the version of the file cached by the webbrowser has been unmodified since the last retrieval (ie. if the web browserincluded an  ETag header), it may instead respond with a request ofthe form:</p><p>如果web浏览器发送的HTTP头包含足够的信息，使web服务器能够确定自上次检索以来，webbrowser缓存的文件版本是否未被修改（即，如果web浏览器包含ETag头），则它可能会改为响应以下请求：</p><p>   After parsing the HTML, the web browser (and server) repeats this processfor every resource (image, CSS, favicon.ico, etc) referenced by the HTML page,except instead of  GET / HTTP/1.1 the request will be GET /$(URL relative to www.google.com) HTTP/1.1.</p><p>解析HTML后，web浏览器（和服务器）对HTML页面引用的每个资源（图像、CSS、favicon.ico等）重复此过程，除了GET/HTTP/1.1之外，请求将是GET/$（相对于www.google.com的URL）HTTP/1.1。</p><p> If the HTML referenced a resource on a different domain than www.google.com, the web browser goes back to the steps involved inresolving the other domain, and follows all steps up to this point for thatdomain. The  Host header in the request will be set to the appropriateserver name instead of  google.com.</p><p>如果HTML引用了与www.google不同的域上的资源。com，web浏览器返回到解析另一个域所涉及的步骤，并遵循该域到目前为止的所有步骤。请求中的主机头将被设置为适当的服务器名，而不是google。通用域名格式。</p><p>   The HTTPD (HTTP Daemon) server is the one handling the requests/responses onthe server-side. The most common HTTPD servers are Apache or nginx for Linuxand IIS for Windows.</p><p>HTTPD（HTTP守护进程）服务器是在服务器端处理请求/响应的服务器。最常见的HTTPD服务器是用于linux的Apache或nginx，以及用于Windows的IIS。</p><p> HTTP Request Method (either  GET,  HEAD,  POST,  PUT, PATCH,  DELETE,  CONNECT,  OPTIONS, or  TRACE). In thecase of a URL entered directly into the address bar, this will be  GET.</p><p>HTTP请求方法（GET、HEAD、POST、PUT、PATCH、DELETE、CONNECT、OPTIONS或TRACE）。如果直接在地址栏中输入URL，则将获取该URL。</p><p>  Requested path/page, in this case - / (as no specific path/page wasrequested, / is the default path).</p><p>请求的路径/页面，在本例中-/（因为没有请求特定的路径/页面，/是默认路径）。</p><p> The server verifies that there is a Virtual Host configured on the serverthat corresponds with google.com.</p><p>服务器验证服务器上是否配置了与google对应的虚拟主机。通用域名格式。</p><p>  The server verifies that the client is allowed to use this method(by IP, authentication, etc.).</p><p>服务器验证是否允许客户端使用此方法（通过IP、身份验证等）。</p><p> If the server has a rewrite module installed (like mod_rewrite for Apache orURL Rewrite for IIS), it tries to match the request against one of theconfigured rules. If a matching rule is found, the server uses that rule torewrite the request.</p><p>如果服务器安装了重写模块（如Apache的mod_rewrite或IIS的URL rewrite），它会尝试根据配置的规则之一匹配请求。如果找到匹配规则，服务器将使用该规则写入请求。</p><p> The server goes to pull the content that corresponds with the request,in our case it will fall back to the index file, as &#34;/&#34; is the main file(some cases can override this, but this is the most common method).</p><p>服务器去提取与请求对应的内容，在我们的例子中，它将返回到索引文件，如&#34/&#34; 是主文件（某些情况下可以覆盖此文件，但这是最常见的方法）。</p><p> The server parses the file according to the handler. If Googleis running on PHP, the server uses PHP to interpret the index file, andstreams the output to the client.</p><p>服务器根据处理程序解析文件。如果Google在PHP上运行，服务器将使用PHP解释索引文件，并将输出流式传输到客户端。</p><p>   Once the server supplies the resources (HTML, CSS, JS, images, etc.)to the browser it undergoes the below process:</p><p>一旦服务器向浏览器提供资源（HTML、CSS、JS、图像等），它将经历以下过程：</p><p> Rendering - Construct DOM Tree → Render Tree → Layout of Render Tree →Painting the render tree</p><p>渲染-构造DOM树→ 渲染树→ 渲染树的布局→绘制渲染树</p><p>   The browser&#39;s functionality is to present the web resource you choose, byrequesting it from the server and displaying it in the browser window.The resource is usually an HTML document, but may also be a PDF,image, or some other type of content. The location of the resource isspecified</p><p>浏览器&#39；s的功能是通过从服务器请求并在浏览器窗口中显示所选的web资源来呈现该资源。资源通常是HTML文档，但也可能是PDF、图像或其他类型的内容。资源的位置是指定的</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/press/">#press</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072778.html"><img src="http://img2.diglog.com/img/2022/2/thumb_289699a22e5045874d70b6fac2ef76da.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072778.html">Android 13的第一次开发者预览已经到来</a></div><span class="my_story_list_date">2022-2-13 2:35</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072775.html"><img src="http://img2.diglog.com/img/2022/2/thumb_4b5d5833c29dc1b8594cfdb3b29bd0fe.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072775.html">谷歌表示，它的Bug赏金计划在2021个国家从62个国家支付了8.7亿美元，从62个国家的670万美元提高到662名研究人员的2020。</a></div><span class="my_story_list_date">2022-2-13 1:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072675.html"><img src="http://img2.diglog.com/img/2022/1/thumb_db856a372314aae2acffb03350ba60ce.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072675.html">谷歌表示，Apple'不应该从欺凌者创造的欺凌中受益</a></div><span class="my_story_list_date">2022-1-11 6:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072574.html"><img src="http://img2.diglog.com/img/2022/1/thumb_79eeacbabaa16541464be5736b1db1dd.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072574.html">物质，苹果，亚马逊，谷歌，三星等智能家庭标准，在CES上获得了显着的势头，〜30家公司展示了支持</a></div><span class="my_story_list_date">2022-1-10 7:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>