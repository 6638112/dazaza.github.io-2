<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>2000年的强大软件提示100％有效 Strong software tips from 2000 that are 100% valid today</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Strong software tips from 2000 that are 100% valid today<br/>2000年的强大软件提示100％有效 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-06 13:57:19</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/d72bc9c7dd1af7ffdbae338f29ea025f.jpg"><img src="http://img2.diglog.com/img/2021/4/d72bc9c7dd1af7ffdbae338f29ea025f.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Have you ever heard of  SEMA? It’s a fairly esoteric system for measuring how good a software team is. No,  wait! Don’t follow that link! It will take you about six years just to  understand that stuff. So I’ve come up with my own, highly irresponsible, sloppy test to rate the quality of a software team. The great part about it is that it takes about 3 minutes. With all the time you save, you can go to medical school.</p><p>你有没有听说过sema？它是一个相当深度的系统，用于测量软件团队有多好。不，等待！不要跟随那个链接！只需要六年来才能了解这东西。所以我已经提出了自己的，高度不负责任的，邋r的测试来评估软件团队的质量。关于它的很大一部分是大约需要3分钟。随着你节省的所有时间，你可以去医学院。</p><p>  The neat thing about The Joel Test is that it’s easy to get a quick  yes or  no to each question. You don’t have to figure out lines-of-code-per-day or average-bugs-per-inflection-point. Give your team 1 point for each “yes” answer. The bummer about The Joel Test is that you  really shouldn’t use it to make sure that your nuclear power plant software is safe.</p><p>  关于joel测试的整洁的事情是，对于每个问题来说，很容易得到一个快速的是或否。您不必弄清楚每日码线或平均误差点。为每个“是”答案给您的团队1分。关于joel测试的虚拟是你真的不应该用它来确保你的核电厂软件是安全的。</p><p> A score of 12 is perfect, 11 is tolerable, but 10 or lower and you’ve got serious problems. The truth is that most software organizations are running with a score of 2 or 3, and they need  serious help, because companies like Microsoft run at 12 full-time.</p><p> 得分为12是完美的，11是可忍受的，但10或更低，你有严重的问题。事实是，大多数软件组织的得分为2或3，他们需要认真的帮助，因为Microsoft等公司在全职12次运行。</p><p> Of course, these are not the only factors that determine success or failure: in particular, if you have a great software team working on a product that nobody wants, well, people aren’t going to want it. And it’s possible to imagine a team of “gunslingers” that doesn’t do any of this stuff that still manages to produce incredible software that changes the world. But, all else being equal, if you get these 12 things right, you’ll have a disciplined team that can consistently deliver.</p><p> 当然，这些不是决定成功或失败的唯一因素：特别是，如果您有一个伟大的软件团队，那么在没有人想要的产品，嗯，人们不会想要它。有可能想象一个“枪手”的团队，这些东西并没有做任何这些东西，仍然可以管理改变世界的令人难以置信的软件。但是，其他一切都是平等的，如果你得到这12件事就是正确的，你将有一个可以一直送达的纪律团队。</p><p> 1. Do you use source control? I’ve used commercial source control packages, and I’ve used  CVS, which is free, and let me tell you, CVS is  fine. But if you don’t have source control, you’re going to stress out trying to get programmers to work together. Programmers have no way to know what other people did. Mistakes can’t be rolled back easily. The other neat thing about source control systems is that the source code itself is checked out on every programmer’s hard drive — I’ve never heard of a project using source control that lost a lot of code.</p><p> 1.您是否使用源控制？我已经使用了商业源控制包，我用过的CVS，这是免费的，让我告诉你，CVS很好。但如果你没有源码控制，你会强调试图让程序员一起工作。程序员无法知道其他人所做的事。错误不能轻易回滚。关于源控制系统的其他整洁的事情是源代码本身被检查在每个程序员的硬盘上 - 我从未听说过使用源控件的项目丢失了很多代码。</p><p> 2. Can you make a build in one step? By this I mean: how many steps does it take to make a shipping build from the latest source snapshot? On good teams, there’s a single script you can run that does a full checkout from scratch, rebuilds every line of code, makes the EXEs, in all their various versions, languages, and #ifdef combinations, creates the installation package, and creates the final media — CDROM layout, download website, whatever.</p><p> 你能在一步中建立一个建设吗？由此我的意思是：从最新的源快照制造运输建设需要多少步骤？在良好的团队中，有一个单个脚本，您可以运行完全结帐，从头开始，重建每一行代码，使前任，在所有各种版本，语言和#ifdef组合中，创建安装包，并创建最终媒体 -  CDROM布局，下载网站，无论如何。</p><p> If the process takes any more than one step, it is prone to errors. And when you get closer to shipping, you want to have a very fast cycle of fixing the “last” bug, making the final EXEs, etc. If it takes 20 steps to compile the code, run the installation builder, etc., you’re going to go crazy and you’re going to make silly mistakes.</p><p> 如果该过程需要多个步骤，则易于错误。当您更接近运输时，您希望拥有一个非常快速的循环，可以修复“最后一个”错误，使最终的出口等。如果需要20个步骤来编译代码，运行安装构建器等，请您“疯了，你会犯愚蠢的错误。 </p><p> For this very reason, the last company I worked at switched from WISE to InstallShield: we  required that the installation process be able to run, from a script, automatically, overnight, using the NT scheduler, and WISE couldn’t run from the scheduler overnight, so we threw it out. (The kind folks at WISE assure me that their latest version does support nightly builds.)</p><p>因此，由于这个原因，我在从WISE切换到InstallShield的最后一家公司过夜，所以我们把它扔掉了。 （明智的那种人士向我保证，他们的最新版本确实支持夜间构建。）</p><p> 3. Do you make daily builds? When you’re using source control, sometimes one programmer accidentally checks in something that breaks the build. For example, they’ve added a new source file, and everything compiles fine on their machine, but they forgot to add the source file to the code repository. So they lock their machine and go home, oblivious and happy. But nobody else can work, so they have to go home too, unhappy.</p><p> 你每天都建造吗？当您使用源代码控制时，有时一个程序员意外地检查打破构建的东西。例如，他们添加了一个新的源文件，一切都在他们的计算机上编译很好，但他们忘了将源文件添加到代码存储库。所以他们锁定了他们的机器，回家，忘记和快乐。但没有其他人可以工作，所以他们也必须回家，不开心。</p><p> Breaking the build is so bad (and so common) that it helps to make daily builds, to insure that no breakage goes unnoticed. On large teams, one good way to insure that breakages are fixed right away is to do the daily build every afternoon at, say, lunchtime. Everyone does as many checkins as possible before lunch. When they come back, the build is done. If it worked, great! Everybody checks out the latest version of the source and goes on working. If the build failed, you fix it, but everybody can keep on working with the pre-build, unbroken version of the source.</p><p> 打破构建是如此糟糕（且很常见）它有助于日常建造，以确保没有破坏不受表发。在大球队上，确保破损的一个好方法是立即修复的，是每天下午进行每日建造，比如，比如午餐时间。每个人都在午餐前尽可能多的木制。当他们回来时，建造完成了。如果它有效，很棒！每个人都会检查源的最新版本并继续工作。如果构建失败，则修复它，但每个人都可以继续使用预构建，不间断版本的来源。</p><p> On the Excel team we had a rule that whoever broke the build, as their “punishment”, was responsible for babysitting the builds until someone else broke it. This was a good incentive not to break the build, and a good way to rotate everyone through the build process so that everyone learned how it worked.</p><p> 在Excel团队上，我们有一项规则，无论是违反其“惩罚”，谁都是负责保佑建筑物，直到别人打破它。这是一个很好的激励，不要打破构建，以及通过构建过程旋转每个人的好方法，以便每个人都学会了它的工作原理。</p><p>  4. Do you have a bug database? I don’t care what you say. If you are developing code, even on a team of one, without an organized database listing all known bugs in the code, you are going to ship low quality code. Lots of programmers think they can hold the bug list in their heads. Nonsense. I can’t remember more than two or three bugs at a time, and the next morning, or in the rush of shipping, they are forgotten. You absolutely have to keep track of bugs formally.</p><p>  你有一个bug数据库吗？我不在乎你说的话。如果您正在开发代码，即使在一个团队中，如果没有组织的数据库，则在代码中列出所有已知的错误，您将运送低质量代码。很多程序员认为他们可以将错误列表置于他们的头脑中。废话。我记得一段时间超过两三个虫子，第二天早上，或在匆忙的运输中，他们被遗忘了。你绝对不得不正式跟踪错误。</p><p> Bug databases can be complicated or simple. A minimal useful bug database must include the following data for every bug:</p><p> 错误数据库可以复杂或简单。最小的有用BUG数据库必须为每个错误包含以下数据：</p><p>  If the complexity of bug tracking software is the only thing stopping you from tracking your bugs, just make a simple 5 column table with these crucial fields and  start using it.</p><p>  如果错误跟踪软件的复杂性是唯一阻止您跟踪错误的东西，只需使用这些关键字段制作一个简单的5列表并开始使用它。 </p><p>  5. Do you fix bugs before writing new code? The very first version of Microsoft Word for Windows was considered a “death march” project. It took forever. It kept slipping. The whole team was working ridiculous hours, the project was delayed again, and again, and again, and the stress was incredible. When the dang thing finally shipped, years late, Microsoft sent the whole team off to Cancun for a vacation, then sat down for some serious soul-searching.</p><p>5.在编写新代码之前修复错误吗？ Microsoft Word for Windows的第一个版本被视为“死亡3月”项目。它永远采取了。它保持滑倒。整个团队正在运作荒谬的时间，该项目再次推迟，再次，再次，压力令人难以置信。当Dame的事情终于发货时，很晚时间，微软将整个团队送到坎昆的假期，然后坐下来为一些严肃的灵魂搜索。</p><p> What they realized was that the project managers had been so insistent on keeping to the “schedule” that programmers simply rushed through the coding process, writing extremely bad code, because the bug fixing phase was not a part of the formal schedule. There was no attempt to keep the bug-count down. Quite the opposite. The story goes that one programmer, who had to write the code to calculate the height of a line of text, simply wrote “return 12;” and waited for the bug report to come in about how his function is not always correct. The schedule was merely a checklist of features waiting to be turned into bugs. In the post-mortem, this was referred to as “infinite defects methodology”.</p><p> 他们意识到的是，项目经理如此坚持保持“安排”，程序员简直通过编码过程，编写极度不好的代码，因为错误修复阶段不是正式计划的一部分。没有尝试将错误计数保持下来。恰恰相反。这个故事是那个程序员，谁不得不编写代码来计算一行文本的高度，只需写入“返回12;”并等待错误的报告来谈论他的功能如何并不总是正确。计划仅仅是等待变成错误的功能的清单。在后验尸中，这被称为“无限缺陷方法”。</p><p> To correct the problem, Microsoft universally adopted something called a “zero defects methodology”. Many of the programmers in the company giggled, since it sounded like management thought they could reduce the bug count by executive fiat. Actually, “zero defects” meant that at any given time, the highest priority is to eliminate bugs  before writing any new code. Here’s why.</p><p> 为了纠正问题，微软普遍采用称为“零缺陷方法”的东西。公司中的许多程序员都咯咯地笑了，因为它听起来像管理层认为他们可以减少执行菲亚特的错误计数。实际上，“零缺陷”意味着在任何给定时间，最高优先级是在编写任何新代码之前消除错误。这就是为什么。</p><p> In general, the longer you wait before fixing a bug, the costlier (in time and money) it is to fix.</p><p> 一般来说，你在修复错误之前等待的时间越长，肋价师（及时和金钱）它是解决。</p><p> For example, when you make a typo or syntax error that the compiler catches, fixing it is basically trivial.</p><p> 例如，当您制作编译器捕获的拼写错误或语法错误时，修复它基本上是微不足道的。</p><p> When you have a bug in your code that you see the first time you try to run it, you will be able to fix it in no time at all, because all the code is still fresh in your mind.</p><p> 当您在您的代码中有一个错误时，您看到第一次尝试运行它时，您将能够在任何时间内修复它，因为您的脑海中的所有代码仍然是新鲜的。</p><p> If you find a bug in some code that you wrote a few days ago, it will take you a while to hunt it down, but when you reread the code you wrote, you’ll remember everything and you’ll be able to fix the bug in a reasonable amount of time.</p><p> 如果你在几天前写的一些代码中找到了一个错误，那将需要一段时间才能追捕它，但是当你重读你写的代码时，你会记得一切，你可以解决一切在合理的时间内的错误。 </p><p> But if you find a bug in code that you wrote a few  months ago, you’ll probably have forgotten a lot of things about that code, and it’s much harder to fix. By that time you may be fixing somebody  else’s code, and they may be in Aruba on vacation, in which case, fixing the bug is like science: you have to be slow, methodical, and meticulous, and you can’t be sure how long it will take to discover the cure.</p><p>但是如果您在几个月前写入的代码中发现错误，那么您可能会忘记大量关于该代码的事情，并且修复了很多东西。到那个时候，你可能会修复别人的代码，他们可能会在休假，在这种情况下，修复了这个错误就像科学：你必须慢，有条不紊，细致，你无法确定很长时间会发现治疗方法。</p><p> And if you find a bug in code that has  already shipped, you’re going to incur incredible expense getting it fixed.</p><p> 如果您在已经发货的代码中找到了一个错误，那么您将引起令人难以置信的费用来解决它。</p><p> That’s one reason to fix bugs right away: because it takes less time. There’s another reason, which relates to the fact that it’s easier to  predict how long it will take to write new code than to fix an existing bug. For example, if I asked you to predict how long it would take to write the code to sort a list, you could give me a pretty good estimate. But if I asked you how to predict how long it would take to fix that bug where your code doesn’t work if Internet Explorer 5.5 is installed, you can’t even  guess, because you don’t know (by definition) what’s  causing the bug. It could take 3 days to track it down, or it could take 2 minutes.</p><p> 这是修复错误的一个原因：因为它需要更少的时间。还有另一个原因，这涉及它更容易预测编写新代码的时间比修复现有错误更容易。例如，如果我要求您预测编写代码来排序列表需要多长时间，您可以给我一个非常好的估计。但是如果我问了如何预测修复您的代码在安装的代码不起作用的情况下需要多长时间，如果安装了Internet Explorer 5.5，则无法猜测，因为您不知道（根据定义）导致的内容错误。可能需要3天才能跟踪它，或者可能需要2分钟。</p><p> What this means is that if you have a schedule with a lot of bugs remaining to be fixed, the schedule is unreliable. But if you’ve fixed all the  known bugs, and all that’s left is new code, then your schedule will be stunningly more accurate.</p><p> 这意味着，如果您有一个剩下很多错误的计划，则计划不可靠。但是，如果您已修复所有已知的错误，并且所有剩余的都是新代码，那么您的日程计划将令人惊叹更准确。</p><p> Another great thing about keeping the bug count at zero is that you can respond much faster to competition. Some programmers think of this as keeping the product  ready to ship at all times. Then if your competitor introduces a killer new feature that is stealing your customers, you can implement just that feature and ship on the spot, without having to fix a large number of accumulated bugs.</p><p> 保持错误计数为零的另一个伟大的事情是您可以响应竞争更快。一些程序员认为这是保持产品随时准备发货。然后，如果您的竞争对手引入窃取客户的杀手新功能，则可以在现场实施该功能并运送，而无需修复大量累计错误。</p><p> 6. Do you have an up-to-date schedule? Which brings us to schedules. If your code is at all important to the business, there are lots of reasons why it’s important to the business to know when the code is going to be done. Programmers are notoriously crabby about making schedules. “It will be done when it’s done!” they scream at the business people.</p><p> 6.您有最新的时间表吗？这将我们带来了安排。如果您的代码对业务一致，那么有很多原因，为什么何时要做代码何时要做的事业就会很重要。程序员是臭名昭着的关于制定时间表的crabby。 “它完成后会完成！”他们在商界人士尖叫。</p><p> Unfortunately, that just doesn’t cut it. There are too many planning decisions that the business needs to make well in advance of shipping the code: demos, trade shows, advertising, etc. And the only way to do this is to have a schedule, and to keep it up to date.</p><p> 不幸的是，这只是没有削减它。有太多的规划决定，即业务需要在运送代码：演示，展览，广告等方面做得好。以及唯一的方法是有一个时间表，并保持最新状态。 </p><p> The other crucial thing about having a schedule is that it forces you to decide what features you are going to do, and then it forces you to pick the least important features and  cut them rather than slipping into  featuritis (a.k.a. scope creep).</p><p>关于有计划的另一个关键的事情是它迫使您决定您要做的功能，然后迫使您选择最不重要的功能并切割它们而不是滑入特征性（A.K.A.范围蠕变）。</p><p> Keeping schedules does not have to be hard. Read my article  Painless Software Schedules, which describes a simple way to make great schedules.</p><p> 保持时间表不一定很难。阅读我的文章无痛的软件计划，它描述了一种制作大小时间的简单方法。</p><p> 7. Do you have a spec? Writing specs is like flossing: everybody agrees that it’s a good thing, but nobody does it.</p><p> 你有规格吗？写作规格就像用过牙线：每个人都同意这是一件好事，但没有人这样做。</p><p> I’m not sure why this is, but it’s probably because most programmers hate writing documents. As a result, when teams consisting solely of programmers attack a problem, they prefer to express their solution in code, rather than in documents. They would much rather dive in and write code than produce a spec first.</p><p> 我不确定为什么这是，但它可能是因为大多数程序员都讨厌写文档。结果，当小组组成的程序员攻击问题时，他们更愿意在代码中表达他们的解决方案，而不是文档。它们相当潜入并写代码而不是生产规范。</p><p> At the design stage, when you discover problems, you can fix them easily by editing a few lines of text. Once the code is written, the cost of fixing problems is dramatically higher, both emotionally (people hate to throw away code) and in terms of time, so there’s resistance to actually fixing the problems. Software that wasn’t built from a spec usually winds up badly designed and the schedule gets out of control.  This seems to have been the problem at Netscape, where the first four versions grew into such a mess that management  stupidly decided to throw out the code and start over. And then they made this mistake all over again with Mozilla, creating a monster that spun out of control and took  several years to get to alpha stage.</p><p> 在设计阶段，当您发现问题时，您可以通过编辑几行文本来轻松解决它们。一旦代码被写入，修复问题的成本会显着更高，在情感上（人们讨厌抛弃代码）以及在时间方面，因此有抵抗实际上解决了问题。从规范内未构建的软件通常会迎接糟糕的设计，并且计划失控。这似乎是Netscape的问题，前四个版本在那里陷入如此混乱，管理愚蠢地决定抛出代码并重新开始。然后他们用Mozilla遍历了这个错误，创造了一个惩罚控制并花了几年才能获得alpha阶段的怪物。</p><p> My pet theory is that this problem can be fixed by teaching programmers to be less reluctant writers by sending them off to take  an intensive course in writing. Another solution is to hire smart program managers who produce the written spec. In either case, you should enforce the simple rule “no code without spec”.</p><p> 我的宠物理论是，通过教导程序员通过向他们写入重症课程来宣传，可以通过教学程序来修复这个问题。另一种解决方案是聘请生产书面规范的智能节目经理。在任何一种情况下，您都应该强制执行简单的规则“没有规格的代码”。</p><p>  8. Do programmers have quiet working conditions? There are extensively documented productivity gains provided by giving knowledge workers space, quiet, and privacy. The classic software management book  Peopleware documents these productivity benefits extensively.</p><p>  8.程序员是否有安静的工作条件？通过提供知识工人空间，安静和隐私，提供了广泛的记录了生产力提高。经典的软件管理书籍人士文凭证这些生产力广泛利益。 </p><p> Here’s the trouble. We all know that knowledge workers work best by getting into “flow”, also known as being “in the zone”, where they are fully concentrated on their work and fully tuned out of their environment. They lose track of time and produce great stuff through absolute concentration. This is when they get all of their productive work done. Writers, programmers, scientists, and even basketball players will tell you about being in the zone.</p><p>这是麻烦。我们都知道知识工作者通过进入“流动”，也被称为“在区域中”，他们完全集中在他们的工作中并完全调整了他们的环境。他们丢失了时间，通过绝对浓度来产生很大的东西。这是他们完成所有富有成效的工作的时候。作家，程序员，科学家，甚至篮球运动员会告诉你关于在该区域的进入。</p><p> The trouble is, getting into “the zone” is not easy. When you try to measure it, it looks like it takes an average of 15 minutes to start working at maximum productivity. Sometimes, if you’re tired or have already done a lot of creative work that day, you just can’t get into the zone and you spend the rest of your work day fiddling around, reading the web, playing Tetris.</p><p> 麻烦是，进入“区域”并不容易。当您尝试测量它时，它看起来平均需要15分钟即可以最大的生产率开始工作。有时，如果你累了或者已经做过了那天已经做了很多创造性的工作，你就无法进入区域，你花了剩下的工作日摆弄，读网，播放俄罗斯。</p><p> The other trouble is that it’s so easy to get knocked  out of the zone. Noise, phone calls, going out for lunch, having to drive 5 minutes to Starbucks for coffee, and interruptions by coworkers —  especially interruptions by coworkers — all knock you out of the zone. If a coworker asks you a question, causing a 1 minute interruption, but this knocks you out of the zone badly enough that it takes you half an hour to get productive again, your overall productivity is in serious trouble. If you’re in a noisy bullpen environment like the type that caffeinated dotcoms love to create, with marketing guys screaming on the phone next to programmers, your productivity will plunge as knowledge workers get interrupted time after time and never get into the zone.</p><p> 其他麻烦的是，被淘汰出局很容易。噪音，电话呼叫，出去享用午餐，不得不开车5分钟到星巴克喝咖啡，以及同事的中断 - 特别是同事的中断 - 所有人都会把你赶出来。如果一位同事问你一个问题，造成1分钟的中断，但这让你走出了足够的局面，足以让你半小时再次获得高效，你的整体生产力是严重的麻烦。如果您处于嘈杂的牛棚环境，像Caffeinated DOTCOMS喜欢创造的类型，随着营销人员在程序员旁边尖叫，您的生产力将暴跌，因为知识工作者在时间之后进行中断而且从未进入该区域。</p><p> With programmers, it’s especially hard. Productivity depends on being able to juggle a lot of little details in short term memory all at once. Any kind of interruption can cause these details to come crashing down. When you resume work, you can’t remember any of the details (like local variable names you were using, or where you were up to in implementing that search algorithm) and you have to keep looking these things up, which slows you down a lot until you get back up to speed.</p><p> 通过程序员，特别努力。生产力取决于能够在短期内记忆中拼凑的很多细节。任何中断都会导致这些细节来崩溃。当您恢复工作时，您无法记住任何详细信息（如您所使用的本地变量名称，或者您在实现该搜索算法时的位置），您必须继续寻找这些东西，从而减慢了您在你恢复速度之前。</p><p> Here’s the simple algebra. Let’s say (as the evidence seems to suggest) that if we interrupt a programmer, even for a minute, we’re really blowing away 15 minutes of productivity. For this example, lets put two programmers, Jeff and Mutt, in open cubicles next to each other in a standard Dilbert veal-fattening farm. Mutt can’t remember the name of the Unicode version of the strcpy function. He could look it up, which takes 30 seconds, or he could ask Jeff, which takes 15 seconds. Since he’s sitting right next to Jeff, he asks Jeff. Jeff gets distracted and loses 15 minutes of productivity (to save Mutt 15 seconds).</p><p> 这是简单的代数。假设（因为证据似乎建议），如果我们中断程序员，即使是一分钟，我们就会吹走15分钟的生产力。对于这个例子，让我们在标准Dilbert小牛肉 - 肥胖农场中将两个程序员，杰夫和笨拙，彼此相邻的开放式隔间。 Mutt无法记住Strcpy函数的Unicode版本的名称。他可以看起来，需要30秒，或者他可以问杰夫，这需要15秒钟。因为他坐在杰夫旁边，他问杰夫。杰夫分散注意力并失去了15分钟的生产力（保存Mutt 15秒）。</p><p> Now let’s move them into separate offices with walls and doors. Now when Mutt can’t remember the name of that function, he could look it up, which still takes 30 seconds, or he could ask Jeff, which now takes 45 seconds and involves standing up (not an easy task given the average physical fitness of programmers!). So he looks it up. So now Mutt loses 30 seconds of productivity, but we save 15 minutes for Jeff. Ahhh!</p><p> 现在让我们将它们移入与墙壁和门的独立办公室。现在，当Mutt不记得该职能的名称时，他可以查找，这仍然需要30秒，或者他可以问Jeff，现在需要45秒并涉及站立（没有鉴于平均身体健康程序员！）。所以他看起来。所以现在Mutt失去了30秒的生产力，但我们为杰夫节省15分钟。啊！</p><p> 9. Do you use the best tools money can buy? Writing code in a compiled language is one of the last things that still can’t be done instantly on a garden variety home computer. If your compilation process takes more than a few seconds, getting the latest and greatest computer is going to save you time. If compiling takes even 15 seconds, programmers will get bored while the compiler runs and switch over to reading  The Onion, which will suck them in and kill hours of productivity.</p><p> 你使用最好的工具可以买到最好的工具吗？编译语言编写代码是仍然无法在花园品种家用电脑上立即完成的最后一件事之一。如果您的汇编过程需要超过几秒钟，请获得最新和最大的计算机将节省您的时间。如果编译需要15秒，程序员将在编译器运行并切换到读取洋葱时会感到厌倦，这将吸入并杀死工作效率。 </p><p> Debugging GUI code with a single monitor system is painful if not impossible. If you’re writing GUI code, two monitors will make things much easier.</p><p>如果不是不可能的，使用单个监视系统的调试GUI代码是痛苦的。如果您正在编写GUI代码，则两个监视器将使事情变得更加容易。</p><p> Most programmers eventually have to manipulate bitmaps for icons or toolbars, and most programmers don’t have a good bitmap editor available. Trying to use Microsoft Paint to manipulate bitmaps is a joke, but that’s what most programmers have to do.</p><p> 大多数程序员最终必须操纵用于图标或工具栏的位图，大多数程序员都没有可用的良好位图编辑器。试图使用Microsoft Paint来操纵位图是一个笑话，但这就是大多数程序员必须做的事情。</p><p> At  my last job, the system administrator kept sending me automated spam complaining that I was using more than … get this … 220 megabytes of hard drive space on the server. I pointed out that given the price of hard drives these days, the cost of this space was significantly less than the cost of the  toilet paper I used. Spending even 10 minutes cleaning up my directory would be a fabulous waste of productivity.</p><p> 在我的最后一份工作中，系统管理员保留了向我发送自动垃圾邮件，抱怨我使用的是......得到它... 220兆字节的服务器上的硬盘空间。我指出，考虑到这些天硬盘价格，这个空间的成本明显低于我使用的卫生纸的成本。花费甚至10分钟清理我的目录将是一个很棒的生产力浪费。</p><p> Top notch development teams don’t torture their programmers. Even minor frustrations caused by using underpowered tools add up, making programmers grumpy and unhappy. And a grumpy programmer is an unproductive programmer.</p><p> 顶级陷波的发展团队不会折磨他们的程序员。甚至使用支持工具引起的轻微挫折，使程序员脾气暴躁和不满。脾气暴躁的程序员是一个不生产的程序员。</p><p> To add to all this… programmers are easily bribed by giving them the coolest, latest stuff. This is a far cheaper way to get them to work for you than actually paying competitive salaries!</p><p> 要添加到所有这些......程序员通过给他们最酷的最新的东西很容易贿赂。这是让他们为您工作而不是实际支付竞争性薪水！</p><p> 10. Do you have testers? If your team doesn’t have dedicated testers, at least one for every two or three programmers, you are either shipping buggy products, or you’re wasting money by having $100/hour programmers do work that can be done by $30/hour testers. Skimping on testers is such an outrageous false economy that I’m simply blown away that more people don’t recognize it.</p><p> 你有测试人员吗？如果您的团队没有专用测试人员，至少为每两个或三个程序员至少有一个，您可以运输BUDGY产品，或者您使用100美元/小时的程序员可以使用30美元/小时测试人员浪费金钱。杀了测试人员是如此令人发指的虚假经济，我只是吹走了更多的人不认识它。</p><p> Read  Top Five (Wrong) Reasons You Don’t Have Testers, an article I wrote about this subject.</p><p> 阅读五个（错误）您没有测试人员的原因，这是我对此主题的文章。 </p><p> 11. Do new candidates write code during their interview? Would you hire a magician without asking them to show you some magic tricks? Of course not.</p><p>11.新候选人在采访时写代码吗？你会雇用一名魔术师，而不是要求他们向你展示一些魔术伎俩吗？当然不是。</p><p> Would you hire a caterer for your wedding without tasting their food? I doubt it. (Unless it’s Aunt Marge, and she would hate you for ever if you didn’t let her make her “famous” chopped liver cake).</p><p> 在没有品尝他们的食物的情况下，你会为​​你的婚礼雇用一个餐饮服务器吗？我对此表示怀疑。 （除非这是阿姨Marge，如果你没有让她让她“着名的”切碎的肝蛋糕），她会永远恨你。</p><p> Yet, every day, programmers are hired on the basis of an impressive resumé or because the interviewer enjoyed chatting with them. Or they are asked trivia questions (“what’s the difference between CreateDialog() and DialogBox()?”) which could be answered by looking at the documentation. You don’t care if they have memorized thousands of trivia about programming, you care if they are able to produce code. Or, even worse, they are asked “AHA!” questions: the kind of questions that seem easy when you know the answer, but if you don’t know the answer, they are impossible.</p><p> 然而，每天，程序员都是根据令人印象深刻的恢复雇用的，或者因为面试官喜欢与他们聊天。或者他们被问到Trivia问题（“CreateIrialog（）和DialogBox（）之间有什么区别？”）可以通过查看文档来回答。你不在乎他们是否已经记住了数千个关于编程的琐事，你会关心他们是否能够生产代码。或者，更糟糕的是，他们被问到“啊哈！”问题：当你了解答案时，那种似乎很容易的问题，但如果你不知道答案，他们是不可能的。</p><p> Please, just  stop doing this. Do whatever you want during interviews, but make the candidate  write some code. (For more advice, read my  Guerrilla Guide to Interviewing.)</p><p> 拜托，只是停止这样做。在采访中做任何你想要的东西，但是让候选人写一些代码。 （有关更多建议，请阅读我的游击指南面试。）</p><p> 12. Do you do hallway usability testing? A  hallway usability test is where you grab the next person that passes by in the hallway and force them to try to use the code you just wrote. If you do this to five people, you will learn 95% of what there is to learn about usability problems in your code.</p><p> 12.你做了走廊可用性测试吗？走廊可用性测试是您抓住走廊中的下一个人并强迫他们尝试使用您刚写的代码的人。如果您这样做到五个人，您将学习95％的关于代码中的可用性问题的内容。</p><p> Good user interface design is not as hard as you would think, and it’s crucial if you want customers to love and buy your product. You can read my  free online book on UI design, a short primer for programmers.</p><p> 良好的用户界面设计并不像你想象的那么难，如果您希望客户喜欢和购买产品，这是至关重要的。您可以在UI设计上阅读我的免费在线书籍，一个用于程序员的短底漆。</p><p> But the most important thing about user interfaces is that if you show your program to a handful of people, (in fact, five or six is enough) you will quickly discover the biggest problems people are having. Read  Jakob Nielsen’s article explaining why. Even if your UI design skills are lacking, as long as you force yourself to do hallway usability tests, which cost nothing, your UI will be much, much better.</p><p> 但是，关于用户界面的最重要的事情是，如果您向少数人展示您的程序，（实际上，五或六个足够），您将迅速发现人们所拥有的最大问题。阅读Jakob Nielsen的文章解释了原因。即使您的UI设计技能缺乏，只要您强制执行走廊可用性测试，您的UI都没有成本，您的UI会更好。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/software/">#software</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>