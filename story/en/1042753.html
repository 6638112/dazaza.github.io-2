<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Futureproof是基于Zig，Neovim和WebGPU构建的GPU着色器的实时编辑器 Futureproof is a live editor for GPU shaders, built on Zig, Neovim, and WebGPU</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Futureproof is a live editor for GPU shaders, built on Zig, Neovim, and WebGPU<br/>Futureproof是基于Zig，Neovim和WebGPU构建的GPU着色器的实时编辑器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:53:58</div><div class="page_narrow text-break page_content"><p>The system also uses FreeType for font rasterizationand  GLFW for windowing,but those are both relatively mature,so I don&#39;t get any points for them.</p><p>该系统还使用FreeType进行字体光栅化，并使用GLFW进行窗口化，但是它们都比较成熟，因此我没有得到任何要点。</p><p>  Neovim is run as a subprocess ( nvim --embed),which communicates on  stdin and  stdoutusing the   msgpack-rpc format.</p><p>  Neovim作为子进程（nvim --embed）运行，它使用msgpack-rpc格式在stdin和stdout上进行通信。</p><p> I wrote   msgpackand   msgpack-rpclibraries in Zig from the ground up,which ended up being &lt; 1 KLOC.</p><p> 我从头开始在Zig中编写了msgpackand msgpack-rpclibraries，最终结果是＆lt; 1个KLOC。</p><p> A listener thread monitors the subprocess&#39;s  stdout,decoding messages then passing events and responses into a pair of queues.The main loop claims and handles events before drawing each frame.</p><p> 侦听器线程监视子进程的标准输出，解码消息，然后将事件和响应传递到一对队列中。主循环在绘制每一帧之前声明并处理事件。</p><p> RPC calls are blocking: the call is encoded and passed to the subprocess&#39;s stdin, then we wait for the listener thread to return the responseon the queue.</p><p> RPC调用处于阻塞状态：该调用已编码并传递到子进程的stdin，然后我们等待侦听器线程返回队列上的响应。</p><p>   Neovim&#39;s abstract UI model is a monospaced grid of a particular width and height.Each cell in the grid has a character and attribute ID;the latter is a lookup into a table of colors, bold, underlines, etc.</p><p>   Neovim的抽象UI模型是具有特定宽度和高度的等距网格，网格中的每个单元格都有一个字符和属性ID;后者是对颜色，粗体，下划线等表格的查找。</p><p> The grid and attribute table are modified through API messages( grid_line,  grid_cursor_goto,  hl_attr_define,  mode_change, etc),so our UI has to keep track of this state.</p><p> 网格和属性表是通过API消息（grid_line，grid_cursor_goto，hl_attr_define，mode_change等）修改的，因此我们的UI必须跟踪此状态。 </p><p> These API calls are evaluated by the main loopand edit state in CPU memory,but we want rendering to be done by the GPU.As it turns out,both Zig and GLSL can import C headers, so Futureproof uses a fun trick:we define a set of  C  structs,populate them on the CPU (in Zig),then copy them to the GPU and use them directly (in GLSL).</p><p>这些API调用由主循环评估，并在CPU内存中处于编辑状态，但是我们希望渲染由GPU完成。事实证明，Zig和GLSL都可以导入C标头，因此Futureproof使用了一个有趣的技巧：我们定义了一个一组C结构，将它们填充到CPU中（在Zig中），然后将它们复制到GPU并直接使用（在GLSL中）。</p><p>   Meta-data tables (attributes, font atlas, etc.) are in a  uniform buffer,as they&#39;re relatively small (11 KB in total)</p><p>   元数据表（属性，字体图集等）位于统一缓冲区中，因为它们相对较小（总计11 KB）</p><p> The character grid is larger (1 MB), and so is passed as a  storage buffer</p><p> 字符网格较大（1 MB），因此作为存储缓冲区传递</p><p> The font is rasterized and packed into a texture on the CPU side.As part of the meta-data, we include the positions and bounding boxesof each character.The font ends up looking something like this:</p><p> 字体被光栅化并打包到CPU端的纹理中。作为元数据的一部分，我们包括每个字符的位置和边界框，最终字体看起来像这样：</p><p>  The grid stores character and attribute indices packed into a  uint32_t per cell.This limits us to 65535 characters, but that&#39;s acceptable.</p><p>  网格将每个单元格的字符和属性索引存储在uint32_t中，这将我们限制为65535个字符，但这是可以接受的。</p><p> In this architecture, the CPU side doesn&#39;t think about vertex positions at all!It simply passes the character grid to a vertex shader and tells it to draw total_tiles * 6 elements.</p><p> 在这种架构中，CPU端根本不考虑顶点位置，它只是将字符网格传递给顶点着色器，并告诉它绘制total_tiles * 6个元素。</p><p> The vertex shader then calculates vertex positions,lays out tiles in the character grid,samples from the font texture, and so on.</p><p> 然后，顶点着色器计算顶点位置，在字符网格中布置图块，从字体纹理中采样，依此类推。 </p><p>    I developed Futureproof on macOS,and there were a few cases where I needed to hook into native APIs.</p><p>我在macOS上开发了Futureproof，在某些情况下我需要使用本机API。</p><p> The  wgpu-native demo simply  writes Objective-C in  main.c,then  compiles with  -x objective-c,meaning the input source file is secretly Objective-C, rather than plain C.</p><p> wgpu-native演示仅在main.c中编写了Objective-C，然后使用-x Objective-c进行编译，这意味着输入源文件是秘密的Objective-C，而不是纯C。</p><p> This doesn&#39;t quite work with Zig, despite my best efforts:the pass-through C compiler doesn&#39;t accept the  -x flag.Instead, we can use the  Objective-C Runtime API directly,inspired by  OS X app in Plain C.</p><p> 尽管我已尽力而为，但它与Zig并不完全兼容：直通C编译器不接受-x标志。相反，我们可以直接使用OS X启发的Objective-C运行时API Plain C中的应用程序。</p><p> In practice, this is  surprisingly clean:We&#39;re not defining our own classes, so we just use sel_getUid,  objc_lookUpClass, and  objc_msgSend. Here&#39;s how we use itto get a string from the pasteboard.</p><p> 实际上，这非常干净：我们没有定义我们自己的类，因此我们只使用sel_getUid，objc_lookUpClass和objc_msgSend。这是我们如何使用它从粘贴板获取字符串的方法。</p><p>   Futureproof attaches itself to the Neovim buffer,so it receives messages whenever the buffer changes.This lets us keep a mirror of the text on the Futureproof side of the RPC barrier.</p><p>   Futureproof会将自身附加到Neovim缓冲区，因此只要缓冲区发生更改，它就会接收消息。这使我们可以在RPC屏障的Futureproof端保留文本的镜像。</p><p> If the text hasn&#39;t changed in some amount of time (200 ms by default),we pass it to  shaderc and attempt to compile it from GLSL to SPIR-V.Errors are parsed out of the return value and passed back into Neovim,showing up in the location list and as signs in the left column.</p><p> 如果文本在一定时间内没有更改（默认为200毫秒），则将其传递给shaderc并尝试将其从GLSL编译为SPIR-V。从返回值中解析出错误并将其传递回Neovim，显示在位置列表中，并在左列显示为标志。</p><p>  After a shader is successfully compiled, the SPIR-V bytecode is passed into WebGPUand rendered with the rest of the GUI.</p><p>  成功编译着色器后，会将SPIR-V字节码传递到WebGPU中，并使用其余的GUI进行渲染。 </p><p> One unexpected challenge was keeping the GUI performant whilerendering a shader in the same GPU queue.For challenging shaders like  this seascape,the shader takes hundreds of milliseconds to render.</p><p>一个意外的挑战是在将着色器渲染到同一GPU队列中的同时保持GUI性能。对于具有挑战性的着色器（如海景），着色器需要数百毫秒的渲染时间。</p><p>  There&#39;s got to be a  good way to handle this,but for Futureproof, I used a hack:when a shader takes too long,the preview image is split into tiles, each of which updates once per GUI frame.The tiles are stored in a separate texture,which is copied into the main texture once all tiles have been rendered.</p><p>  必须有一个很好的方法来处理此问题，但对于Futureproof，我使用了一个技巧：当着色器花费的时间太长时，预览图像会拆分为图块，每个图块在每个GUI框架中更新一次。存储在单独的纹理中，一旦所有图块都已渲染，就将其复制到主纹理中。</p><p> This effectively slows down the shader by a factor of  n^2,where  n is the number of tiles per side.We pick  n to keep the GUI responsive,with a median filter to stop single slow frames from messing things up.</p><p> 这有效地将着色器的速度降低了n ^ 2倍，其中n是每边的瓦片数。我们选择n来保持GUI响应，并使用中值过滤器来阻止单个慢帧将事情弄乱。</p><p> I&#39;d love to hear the  correct way to handle this with WebGPU,but suspect that it will require support for multiple queues,which isn&#39;t yet in the standard.</p><p> 我很想听听使用WebGPU处理此问题的正确方法，但怀疑它需要支持多个队列，而这在标准中尚不支持。</p><p>    I found  one bugearly in development,which received no feedback, so that&#39;s a minor red flag.</p><p>    我发现一个开发中的错误，没有得到任何反馈，因此是一个次要的警告。</p><p> More recently, I discovered a more serious issuewhich makes it easy to deadlock Futureproof.This more concerning,but it may be a problem with how I architected the GUI and live error-marking system;I&#39;m waiting to hear back from the Neovim development team about this issue.</p><p> 最近，我发现了一个更严重的问题，该问题很容易使Futureproof陷入僵局。这虽然很令人担忧，但可能是我如何设计GUI和实时错误标记系统的一个问题；我正等着您的来信。 Neovim开发团队就此问题。</p><p>  Absolutely not!This is to be expected:it&#39;s at 0.7.0, so it&#39;s not  supposed to be stable or bug-free.</p><p>  绝对不是！这是可以预期的：它是0.7.0，所以它不应该稳定或没有错误。 </p><p>     The general-purpose allocator, which can print memory leaks on program exit.This is like running in Valgrind all the time, and makes writingleak-free code part of normal development.</p><p>通用分配器，可以在程序退出时打印内存泄漏，就像一直在Valgrind中运行一样，并使无写泄漏的代码成为正常开发的一部分。</p><p> C library interop is fantastic: you can natively import header files, thencall into C libraries, and it all just works!</p><p> C库互操作性很棒：您可以本地导入头文件，然后调用C库，一切都可以！</p><p> The philosophy of passing explicit allocators around; particularly how arenaallocators can then be used for easy memory management.</p><p> 传递显式分配器的哲学；尤其是如何将arenaallocator用于轻松的内存管理。</p><p> I want to like  comptime evaluation,but it&#39;s a little too shaky right now:I tried to use it for a generic  msgpack struct packer,and often ended up confused whether my code was wrong or the compiler was broken.</p><p> 我想喜欢comptime评估，但是现在有点太不稳定了：我试图将其用于通用msgpack struct packer，并且经常混淆我的代码是否错误或编译器是否损坏。</p><p> More generally, I fear that  comptime is  too powerful:without some kind of concept or trait system, it can be a free-for-all.For example, using   comptime type variables to do genericsis  extremely clever,but it means that generating documentation will be a challenge:after all, it&#39;s powerful enough to return entirely different APIsdepending on the type!</p><p> 更笼统地说，我担心comptime太强大了：没有某种概念或特征系统，它可能是万能的。例如，使用comptime类型变量进行通用化非常聪明，但这意味着生成文档会成为挑战：毕竟，它的功能足以根据类型返回完全不同的API！</p><p> (Of course, this is also true for C++ templates, but they&#39;re hard enough to use thatmost people don&#39;t get too weird with them)</p><p> （当然，对于C ++模板也是如此，但是它们很难用大多数人不会觉得太奇怪的方式来使用）</p><p> Similarly, error handling is a little rough:there&#39;s no way to attach data (e.g. a message) to an errorwhile using the language-level error handling.</p><p> 类似地，错误处理有点粗糙：使用语言级错误处理时，无法将数据（例如消息）附加到错误。 </p><p> Finally, I&#39;m a little iffy on the&#34;strings are simply arrays of  u8&#34; philosophy.Though static strings are guaranteed to be UTF-8,the onus is on the programmer(rather than the type system)to enforce that strings from other sources be correctly encoded.For a detailed look at where this can break,see the discussion of  std::fs::metadata in this post</p><p>最后，我对字符串只是u8的数组有些疑惑。哲学。尽管保证静态字符串为UTF-8，但程序员有责任（而不是类型系统）来强制对来自其他来源的字符串进行正确编码。有关在哪里可以破坏字符串的详细信息，请参见讨论此帖子中的std :: fs :: metadata的内容</p><p>   WebGPU is  fine, but the documentation is lacking.I had to reverse-engineer a lot of behavior from examples,reading the source code,and pre-existing knowledge of modern graphics APIs.As discussed above,the lack of multi-queue rendering was the only real frustration.</p><p>   WebGPU很好，但是缺少文档。我不得不对示例中的许多行为进行逆向工程，读取源代码以及对现代图形API的既有知识。如上所述，缺少多队列渲染是唯一真正的沮丧。</p><p> I was using the   wgpu-native bindings,which seem a bit unloved compared to   wgpu-rs.There&#39;s  one obvious bugwhich I encountered within 5 minutes,and it&#39;s unclear how often it&#39;s synched with  wgpu-rs&#39;s releases.</p><p> 我使用的是wgpu-native绑定，与wgpu-rs相比，它似乎并不受欢迎。我在5分钟内遇到了一个明显的错误，目前尚不清楚与它同步的频率wgpu-rs版本。</p><p> It&#39;s frustrating needing   shadercto go from text to SPIR-V,particularly because a full download unzips to 1.9GB (!!).It looks like   nagaaims to replace it, so I&#39;m optimistic about the future!</p><p> 从文本到SPIR-V都需要shaderrc，这很令人沮丧，尤其是因为完整的下载将其解压缩到1.9GB（!!）。它看起来像是用nagaaims替换的，所以我对未来充满信心！</p><p>   (It&#39;s likely that I&#39;ll build a similar system in Rust,next time I want a framework for semi-interactive graphics programming)</p><p>   （很可能我会在Rust中构建一个类似的系统，下一次我想要一个用于半交互式图形编程的框架）</p><p> The code is  on Github,and forks are welcome;if one achieves critical momentum,I&#39;d be happy to link it here.</p><p> 该代码位于Github上，欢迎使用fork；如果人们获得了关键的发展势头，我很乐意在此处链接它。</p><p>  Here&#39;s a very bad Cornell Box Raytracer that I threw together,basically so I could have a project thumbnail:</p><p>  这是一个非常糟糕的康奈尔Box Raytracer，我把它放在一起，基本上是这样，我可以得到一个项目缩略图： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.mattkeeter.com/projects/futureproof/">http://www.mattkeeter.com/projects/futureproof/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/live/">#live</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>