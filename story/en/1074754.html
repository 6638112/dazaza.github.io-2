<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将Linux内核转移到现代CMoving the Linux Kernel to Modern C</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Moving the Linux Kernel to Modern C<br/>将Linux内核转移到现代C</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 05:02:49</div><div class="page_narrow text-break page_content"><p>The following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider  subscribing to LWN. Thank youfor visiting LWN.net!</p><p>LWN订户已向您提供以下仅限订阅的内容。成千上万的订阅者依靠LWN从Linux和自由软件社区获得最好的消息。如果您喜欢这篇文章，请考虑订阅LWN。感谢您访问LWN。网</p><p> Despite its generally fast-moving nature, the kernel project relies on anumber of old tools. While critics like to focus on the community&#39;sextensive use of email, a possibly more significant anachronism is the useof the 1989 version of the C language standard for kernel code — a standardthat was codified before the kernel project even began over 30 years ago.It is looking like that longstanding practice could be coming to an end assoon as the 5.18 kernel, which can be expected in May of this year. The discussion started with  thispatch series from Jakob Koschel, who is trying to preventspeculative-execution vulnerabilities tied to the kernel&#39;s linked-listprimitives. The kernel makes extensive use of doubly-linked lists definedby   structlist_head: This structure is normally embedded into some other structure; in this way,linked lists can be made with any structure type of interest. Along with thetype, the kernel provides  avast array of functions and macros that can be used to traverse andmanipulate linked lists. One of those is   list_for_each_entry(),which is a macro masquerading as a sort of control structure. To see howthis macro is used, imagine that thekernel included a structure like this: The  list member can be used to create a doubly-linked list of foo structures; a separate  list_head structure is usuallydeclared as the beginning of such a list; assume we have one called foo_list. Traversing this list is possible with code like: struct foo *iterator; list_for_each_entry(iterator, &amp;foo_list, list) { 	do_something_with(iterator); } /* Should not use iterator here */</p><p>尽管内核项目通常运行速度很快，但它依赖于大量旧工具。而批评者喜欢关注社区#39；电子邮件的过度使用，一个可能更严重的时代错误是使用了1989年版的C语言内核代码标准——该标准在30多年前的内核项目开始之前就已被编纂。随着5.18内核的发布，长期以来的实践似乎即将结束，预计将于今年5月发布。讨论从Jakob Koschel的这个补丁系列开始，他试图防止与内核相关的推测性执行漏洞&#39；s链接的列表原语。内核广泛使用structlist_head定义的双链表：这种结构通常嵌入到其他结构中；通过这种方式，可以制作任何感兴趣的结构类型的链表。除了类型之外，内核还提供了一系列函数和宏，可用于遍历和操作链表。其中之一是list_for_each_entry（），这是一个伪装成某种控制结构的宏。要了解这个宏是如何使用的，假设内核包含这样一个结构：list成员可以用来创建foo结构的双链接列表；单独的列表头结构通常被宣布为此类列表的开头；假设我们有一个叫做foo_list的。可以使用如下代码遍历此列表：struct foo*iterator；列出每个条目（迭代器和foo_list，list）{do_something_with（迭代器）；}/*这里不应该使用迭代器*/</p><p> The list parameter tells the macro what the name of the list_head structure is within the  foo structure.This loop will be executed once for each element in the list, with iterator pointing to that element. Koschel included  apatch fixing a bug in the USB subsystem where the iterator passed tothis macro was used after the exit from the macro, which is a dangerous thing to do. Dependingon what happens within the list, the contents of that iterator could besomething surprising, even in the absence of speculative execution.Koschel fixed the problem by reworking the code in question to stop usingthe iterator after the loop. Linus Torvalds  didn&#39;tmuch like the patch and didn&#39;t see how it related tospeculative-execution vulnerabilities. After Koschel  explainedthe situation further, though, Torvalds  agreedthat &#34; this is just a regular bug, plain and simple&#34; and saidit should be fixed independently of the larger series. But then hewandered into the real source of the problem: that the iterator passed tothe list-traversal macros must bedeclared in a scope outside of the loop itself: The whole reason this kind of non-speculative bug can happen is	that we historically didn&#39;t have C99-style &#34;declare variables in	loops&#34;. So list_for_each_entry() - and all the other ones -	fundamentally always leaks the last HEAD entry out of the loop,	simply because we couldn&#39;t declare the iterator variable in the	loop itself.</p><p>list参数告诉宏list_head结构在foo结构中的名称。该循环将对列表中的每个元素执行一次，迭代器将指向该元素。Koschel在USB子系统中修复了一个错误，在该子系统中，迭代器传递给该宏，在退出宏后使用该宏，这是一件危险的事情。根据列表中发生的情况，迭代器的内容可能会令人惊讶，即使在没有推测执行的情况下也是如此。Koschel通过重新编写相关代码，在循环结束后停止使用迭代器，解决了这个问题。莱纳斯·托瓦尔兹没有&#39；我非常喜欢这个补丁，而且没有&#39；我看不出它与特定的执行漏洞有什么关系。然而，在科舍尔进一步解释了情况之后，托瓦尔兹同意&#34；这只是一个普通的bug，简单明了#34；并且saidit应该独立于较大的系列进行修复。但随后他深入到了问题的真正根源：传递给列表遍历宏的迭代器必须在循环本身之外的范围内声明：这种非推测性错误可能发生的全部原因是我们在历史上没有&#39；没有C99风格&#34；在循环中声明变量；。因此，为每个条目列出条目（）——以及所有其他条目——基本上总是将最后一个头部条目漏出循环，仅仅因为我们不能&#39；t在循环本身中声明迭代器变量。</p><p> If it were possible to write a list-traversal macro that could declare itsown iterator, then that iterator would not be visible outside of the loopand this kind of problem would not arise. But, since the kernel is stuckon the C89 standard, declaring variables within the loop is not possible. Torvalds said that perhaps the time had come to look to moving to the  C99 standard — it is still over 20 years old, but is at least recentenough to allow block-level variable declarations. As he noted, this movehasn&#39;t been done in the past &#34; because we had some odd problem withsome ancient gcc versions that broke documented initializers&#34;. But,in the meantime,the kernel has moved its minimum GCC requirement to version 5.1, soperhaps those bugs are no longer relevant. Arnd Bergmann, who tends to keep a close eye on cross-architecturecompiler issues,  agreedthat it should be possible for the kernel to move forward. Indeed, hesuggested that it would be possible to go as far as the  C11standard (from 2011) while the change was being made, though he wasn&#39;tsure that C11 would bring anything new that would be useful to the kernel. It mighteven be possible to move to  C17 oreven the yet-unfinished  C2xversion of the language. That, however, has a downside in that it&#34; would break gcc-5/6/7 support&#34;, and the kernel still supportsthose versions currently. Raising the minimum GCC version to 8.x wouldlikely be more of a jump than the user community would be willing to acceptat this point. Moving to C11 would not require changing the minimum GCC version, though,and thus might be more readily doable. Torvalds  wasin favor of that idea:&#34; I really would love to finally move forward on this, considering thatit&#39;s been brewing for many many years&#34;. After Bergmann  confirmedthat it should be possible to do so, Torvalds  declared:&#34; Ok, somebody please remind me, and let&#39;s just try this early in the5.18 merge window&#34;.The 5.18 merge window is less than one month away, so this is a change thatcould happen in the near future. It is worth keeping in mind, though, thata lot of things can happen between the merge window and the 5.18 release.Moving to a new version of the language standard could reveal any number ofsurprises in obscure places in the kernel; it would not take many of thoseto cause the change to be reverted for now. But, if all goes well, theshift to C11 will happen in the next kernel release. Converting all of theusers of  list_for_each_entry() and variants (of which there arewell over 15,000 in the kernel) to a new version that doesn&#39;t expose theinternal iterator seems likely to take a little longer, though.         ( Log in to post comments)</p><p>如果可以编写一个列表遍历宏来声明自己的迭代器，那么该迭代器在循环之外就不可见，也不会出现这种问题。但是，由于内核是基于C89标准的，在循环中声明变量是不可能的。Torvalds说，也许是时候考虑使用C99标准了——它已经有20多年的历史了，但至少现在允许块级变量声明。正如他所指出的，这项运动没有&#39；过去没有这样做过&#34；因为我们在一些古老的gcc版本中遇到了一些奇怪的问题，这些版本打破了已有的初始值设定项；。但是，与此同时，内核已经将其最低GCC要求移到了5.1版，因此这些错误不再相关。倾向于密切关注跨架构编译器问题的Arnd Bergmann同意，内核应该可以向前发展。事实上，他暗示，在进行更改时，有可能达到C11标准（从2011年开始），尽管他不是&#39；t请相信C11将带来任何对内核有用的新功能。甚至有可能转移到C17，甚至是尚未完成的C2X版本。然而，这也有一个缺点，那就是它#34；将打破gcc-5/6/7的支持&#34；，内核目前仍然支持这些版本。将GCC的最低版本提高到8。x很可能是一个跳跃，而不是用户社区愿意接受这一点。不过，转移到C11不需要更改最低GCC版本，因此可能更容易实现。托瓦尔兹支持这个观点：&#34；考虑到它&#39；它酝酿了很多年；。在伯格曼证实应该可以这样做后，托瓦尔兹宣布：&#34；好的，有人请提醒我，让&#39；让我们在5月初试试这个。18合并窗口&#34；。距离5.18合并窗口还有不到一个月的时间，所以这是一个可能在不久的将来发生的变化。不过，值得记住的是，在合并窗口和5.18版本之间可能会发生很多事情。迁移到新版本的语言标准可能会在内核中不显眼的地方发现任意数量的问题；现在，不需要太多的改变就可以恢复。但是，如果一切顺利，到C11的转换将在下一个内核版本中发生。将list_for_each_entry（）和变体（内核中有超过15000个）的所有用户转换为一个新版本，该版本不&#39；不过，显示内部迭代器似乎需要更长的时间。（登录发表评论）</p><p>  Note that, if for some reason you need to stay with c89, you can always add a block around the for() statement to hold the loop variable.</p><p>请注意，如果出于某种原因需要继续使用c89，则始终可以在for（）语句周围添加一个块来保存循环变量。</p><p> You&#39;d need to do that to each caller, which is a *lot* of code churn.</p><p>你&#39；我需要对每个调用者这样做，这是一个很大的代码搅动。</p><p>  Posted Feb 24, 2022 16:22 UTC (Thu) by  pbonzini ( ✭ supporter ✭, #60935) [ Link]</p><p>由pbonzini于2022年2月24日16:22 UTC（Thu）发布（✭ 支持者✭, #60935）[链接]</p><p>  Instead of leaking a not-necessarily-valid pointer, couldn&#39;t the macro set it to NULL at the end? Actually, I&#39;m surprised there isn&#39;t a standard trick for doing an assignment that will be an error unless the compiler eliminates it as dead code.</p><p>而不是泄漏一个不一定有效的指针，可以&#39；宏是否在末尾将其设置为空？实际上，我&#39；我很惊讶没有&#39；除非编译器将其作为死代码消除，否则这是执行将是错误的赋值的标准技巧。</p><p> Cost. Pretty significant cost in some cases for something that shouldn’t even be necessary.</p><p>费用在某些情况下，购买一些本不必要的东西的成本相当高。</p><p> It should be cost-free in any case where the iteration variable isn&#39;t accessed after the loop, since the compiler would eliminate the dead store. The code change is also fairly trivial: just edit the condition from &#34;&amp;pos-&gt;member != (head)&#34; to &#34;(&amp;pos-&gt;member != (head)) || ((pos = NULL))&#34;.  Unfortunately this alone doesn&#39;t handle loops which exit early due to &#34;break&#34; or &#34;goto&#34;. The &#34;goto&#34; case is unavoidable, but the &#34;break&#34; case can be dealt with by wrapping the macro in a second, trivial loop as shown in this example[0]. Note that the generated code (for gcc 5.1 with -O2) is *identical* between the version with the extra loop (traverse1) and the original version which does not set the iterator to NULL after the loop (traverse2). The initialization of the iterator to the flag state (-1), the condition for the outer loop, and the store of NULL to the iterator after the loop are all successfully eliminated.</p><p>在迭代变量为&#39的任何情况下，它都应该是免费的；t在循环之后访问，因为编译器将消除死存储。代码更改也相当简单：只需从&#34编辑条件&amp；位置-&gt；会员！=（负责人）和#34；至&#34；（&amp；pos-&gt；member！=（head））| |（（pos=NULL））和#34；。不幸的是，仅此一点并不能&#39；t处理由于&#34而提前退出的循环；休息&#34；或&#34；转到&#34；。34岁；后藤&#34；案件不可避免，但&#34；休息&#34；这种情况可以通过将宏包装在第二个简单循环中来处理，如本例[0]所示。请注意，生成的代码（对于带有-O2的gcc 5.1）在带有额外循环（traverse1）的版本和在循环（traverse2）之后未将迭代器设置为NULL的原始版本之间是*相同的*。迭代器初始化为标志状态（-1）、外部循环的条件，以及循环后对迭代器的NULL存储都已成功消除。</p><p> It might work to have:  extern unsigned long list_iterator_live_after_loop;  and &#34;|| ((pos = (void *) list_iterator_live_after_loop), 0)&#34;  I didn&#39;t try changing the kernel macro that way, but my little test code doesn&#39;t link if the iterator is used after the loop, but does link and work if it&#39;s not used. As I recall, the kernel is already using that sort of trick to use compiler optimization to remove an error message only if the compiler can disprove it.</p><p>它可能有以下功能：外部无符号长列表迭代器循环之后的活动循环；和&#34；|124;（（pos=（void*）list_iterator_live_after_loop），0）和#34；我没有&#39；我没有试着那样修改内核宏，但我的小测试代码没有&#39；t link，如果迭代器在循环之后使用，但是如果它&#39，则链接并工作；它没有被使用。我记得，内核已经在使用这种技巧，只有在编译器能够反驳错误消息时，才使用编译器优化来删除错误消息。</p><p>  Oh, I meant to imply that the compiler would eliminate all of those writes except for ones that expose bugs, but then I got side-tracked by wondering if you could make the kernel not even link unless the compiler eliminated the write. Anyway, it wouldn&#39;t affect the generated code unless the compiler can&#39;t tell the code is correct.</p><p>哦，我的意思是，编译器会消除所有这些写操作，除了那些暴露bug的写操作，但后来我想知道，如果编译器不消除写操作，你是否可以使内核甚至不链接，这让我左右为难。无论如何，它不会&#39；除非编译器能够&#39；我说不出代码是正确的。</p><p>  My thought is that it&#39;s silly to require compatibility with standards old enough that even software implementing their newer versions are falling out of long-term support. There are other cases where arguably there&#39;s a risk of causing a flag day, but moving off of C89 isn&#39;t one of them.</p><p>我的想法是&#39；要求与足够旧的标准兼容是愚蠢的，即使是实现新版本的软件也会失去长期支持。还有其他一些案例可以证明&#39；这有可能导致卖旗日，但离开C89不是&#39；我不是他们中的一个。</p><p>   If the plan is to make this move at the beginning of the next cycle, shouldn&#39;t the -next kernel adopt it right now?</p><p>如果计划在下一个周期开始时采取这一行动，那么&#39；下一个内核现在就采用它吗？</p><p>  Yes please, finally! Combined declarations and initializations like every other programming language. More &#39;const&#39; and fewer &#34;this variable &#39;may&#39; be used uninitialized&#34; guessing/silliness. No more reverse Christmas trees.  In even more advanced languages &#39;const&#39; is the default but let&#39;s not get carried away; too much maths that could scare hardware engineers emotionally attached to their registers.</p><p>是的，终于！像其他编程语言一样，组合声明和初始化。更多&#39；常数&#39；更少&#34；这个变量&#39；5月&#39日；在未初始化的情况下使用&#34；猜测/愚蠢。再也没有反向的圣诞树了。用更高级的语言&#39；常数&#39；是默认值，但让&#39；不要忘乎所以；过多的数学运算可能会让硬件工程师在情感上对寄存器产生恐惧。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>