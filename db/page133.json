[{"category": "", "categoryclass": "", "imagename": "207329704eb8d1e83e40e0233abe113d.jpg", "infoid": 1072568, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u4f3c\u4e4e\u6709\u76ee\u7684\u5730\u635f\u574f\u4e86Github\u548c\u8f6f\u4ef6\u6ce8\u518c\u8868NPM\u4e0a\u7684\u4e00\u5bf9\u5f00\u6e90\u5e93 - \u201cfaker.js\u201d\u548c\u201ccolors.js\u201d - \u5343\u4e07\u7528\u6237\u4f9d\u8d56\u4e8e\uff0c\u6e32\u67d3\u5305\u542b\u8fd9\u4e9b\u5e93\u7684\u4efb\u4f55\u9879\u76ee\u65e0\u7528\u7684\u9879\u76ee\uff0c\u5982\u901a\u8fc7Blepeing Computer\u62a5\u9053\u3002\u867d\u7136\u5b83\u770b\u8d77\u6765\u50cfColor.js\u5df2\u66f4\u65b0\u4e3a\u5de5\u4f5c\u7248\u672c\uff0c\u6ce1\u6cab\u5a01\u65af\u7279\u4ecd\u7136\u4f3c\u4e4e\u53d7\u5230\u5f71\u54cd\uff0c\u4f46\u901a\u8fc7\u5411\u524d\u7248\u672c\uff085.5.3\uff09\u4e0b\u8c03\u95ee\u9898\u53ef\u4ee5\u89e3\u51b3\u95ee\u9898\u3002\n\u63a8\u52a8\u4f2a\u88c5\u66f4\u65b0\u540e\u4e24\u5929\uff0c\u4ee5\u540e\u8ffd\u6c42\u63a8\u6587\uff0c\u5c3d\u7ba1\u5728\u7f51\u7ad9\u4e0a\u50a8\u5b58\u4e86\u6570\u767e\u4e2a\u9879\u76ee\uff0c\u4f46\u4ed6\u5df2\u88ab\u6682\u505c\u5230Github\u3002\u7136\u800c\uff0c\u5728\u4f2a\u88c5\u6210\u548c\u989c\u8272\u548c\u989c\u8272\u4e2d\u7684\u53d8\u66f4\u5224\u65ad\u3002\u7136\u800c\uff0c\u5b83\u770b\u8d77\u6765\u50cf\u4ed6\u7684\u60ac\u67b6\u5df2\u7ecf\u88ab\u89e3\u9664\u4e86\u3002\u738b\u56fd\u4e8e1\u67084\u65e5\u63a8\u51fa\u4e86\u717d\u52a8\u8005\u3002\u57281\u67086\u65e5\u88ab\u7981\u6b62\uff0c\u5e76\u6ca1\u6709\u4ecb\u7ecd\u201c\u81ea\u7531\u201d\u7684\u989c\u8272\u7248\u672c.JS\u76f4\u52301\u67087\u65e5\u3002\u76ee\u524d\u8fd8\u4e0d\u6e05\u695a\u666e\u901a\u7684\u5e10\u6237\u662f\u5426\u88ab\u7981\u6b62\u4e86\u3002\u6fd2\u4e34\u8fbe\u5230Github\uff0c\u8bf7\u6c42\u8bc4\u8bba\u8bf7\u6c42\uff0c\u4f46\u6ca1\u6709\u7acb\u5373\u542c\u5230\u3002", "note_en": "A developer appears to have purposefully corrupted a pair of open-source libraries on GitHub and software registry npm \u2014 \u201c faker.js\u201d and \u201c colors.js\u201d \u2014 that thousands of users depend on, rendering any project that contains these libraries useless, as reported by   Bleeping Computer. While it looks like color.js has been updated to a working version, faker.js still appears to be affected, but the issue can be worked around by downgrading to a previous version (5.5.3).\n  Bleeping Computer found that the developer of these two libraries, Marak Squires, introduced a malignant commit (a file revision on GitHub) to colors.js that adds \u201c a new American flag module,\u201d as well as rolled out  version 6.6.6 of faker.js, triggering the same destructive turn of events. The sabotaged versions cause applications to infinitely output strange letters and symbols, beginning with three lines of text that read \u201cLIBERTY LIBERTY LIBERTY.\u201d\n Even more curiously, the faker.js Readme file has also been changed to \u201cWhat really happened with Aaron Swartz?\u201d  Swartz was a prominent developer who helped establish Creative Commons, RSS, and Reddit. In 2011, Swartz was charged for stealing documents from the academic database JSTOR with the purpose of making them free to access, and later committed suicide in 2013. Squires\u2019 mention of Swartz could potentially refer to conspiracy theories surrounding his death.\n As pointed out by  Bleeping Computer, a  number  of  users \u2014 including some working with Amazon\u2019s Cloud Development Kit \u2014 turned to GitHub\u2019s bug tracking system to voice their concerns about the issue. And since  faker.js sees nearly 2.5 million weekly downloads on npm, and  color.js gets about 22.4 million downloads per week, the effects of the corruption are likely far-reaching. For context, faker.js generates fake data for demos, color.js adds colors to javascript consoles.\n In response to the problem,  Squires posted an update on GitHub to address the \u201czalgo issue,\u201d which refers to the glitchy text that the corrupt files produce. \u201cIt\u2019s come to our attention that there is a zalgo bug in the v1.4.44-liberty-2 release of colors,\u201d Squires writes in a presumably sarcastic way. \u201cPlease know we are working right now to fix the situation and will have a resolution shortly.\u201d\n NPM has reverted to a previous version of the faker.js package and Github has suspended my access to all public and private projects. I have 100s of projects.  #AaronSwartz  pic.twitter.com/zFddwn631S\n\u2014 marak (@marak)  January 6, 2022\n Two days after pushing the corrupt update to faker.js, Squires later sent out a tweet noting he\u2019s been suspended from GitHub, despite storing hundreds of projects on the site. Judging by the changelog on both faker.js and colors.js, however, it looks like his suspension has already been lifted. Squires introduced the faker.js commit on January 4th, got banned on January 6th, and didn\u2019t introduce the \u201cliberty\u201d version of colors.js until January 7th. It\u2019s unclear whether Squires\u2019 account has been banned again.  The Verge reached out to GitHub with a request for comment but didn\u2019t immediately hear back.\n The story doesn\u2019t end there, though.  Bleeping Computer dug up one of  Squires\u2019 posts on GitHub from November 2020, in which he declares he no longer wants to do free work. \u201cRespectfully, I am no longer going to support Fortune 500s (and other smaller sized companies) with my free work,\u201d he says. \u201cTake this as an opportunity to send me a six figure yearly contract or fork the project and have someone else work on it.\u201d\n Squires\u2019 bold move draws attention to the moral \u2014 and financial \u2014 dilemma of open-source development, which was likely the goal of his actions. A massive number of websites, software, and apps rely on open-source developers to create essential tools and components \u2014 all for free. It\u2019s the same issue that results in unpaid developers working tirelessly to fix the security issues in their open-source software, like the  Heartbleed scare in 2014 that affected OpenSSL and the more recent  Log4Shell vulnerability found in log4j that left volunteers scrambling to fix.", "posttime": "2022-01-10 06:43:53", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u5f00\u53d1,\u5f00\u6e90,\u5f00\u53d1\u4eba\u5458,source,\u7248\u672c", "title": "\u5f00\u6e90\u5f00\u53d1\u4eba\u5458\u635f\u574f\u5e7f\u6cdb\u4f7f\u7528\u7684\u5e93\uff0c\u5f71\u54cd\u5927\u91cf\u9879\u76ee", "title_en": "Open source developer corrupts widely-used libraries, affecting tons of projects", "transed": 1, "url": "https://www.theverge.com/2022/1/9/22874949/developer-corrupts-open-source-libraries-projects-affected", "via": "", "real_tags": ["\u5f00\u53d1", "\u5f00\u6e90", "\u5f00\u53d1\u4eba\u5458", "source", "\u7248\u672c"]}, {"category": "", "categoryclass": "", "imagename": "", "infoid": 1072567, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u57c3\u83f2\u5c14\u534f\u8bae\u57282012\u5e74\u7684\u5149\u4e4b\u4eae\u662f\u7231\u7acb\u4fe1\u4e2d\u7684\u5927\u89c4\u6a21\u8f6f\u4ef6\u96c6\u6210\u7684\u534f\u8bae\u3002 2016\u5e74\u7231\u7acb\u4fe1\u521d\u6b65\u8d21\u732e\u8be5\u534f\u8bae\u5f00\u6e90\uff0c\u4ece\u90a3\u4ee5\u540e\u4e00\u76f4\u4e0e\u793e\u533a\u5408\u4f5c\uff0c\u4ee5\u521b\u5efa\u5b83\u7684\u5f00\u6e90\u5b9e\u73b0\u3002\u6765\u81ea\u5927\u578b\u7535\u4fe1\u7cfb\u7edf\u7684\u4e16\u754c\uff0c\u5b83\u662f\u4e3a\u53ef\u6269\u5c55\u6027\u548c\u5bf9\u53ef\u8ffd\u6eaf\u6027\u7684\u9700\u6c42\u800c\u8bbe\u8ba1\u7684\u3002\u540c\u65f6\uff0c\u534f\u8bae\u7684\u8bbe\u8ba1\u53ca\u5176\u5b9e\u73b0\u53ef\u786e\u4fdd\u60a8\u53ef\u4ee5\u9009\u62e9\u4e0e\u60a8\u76f8\u5173\u7684\u96f6\u4ef6\u3002\u8fd9\u63d0\u4f9b\u4e86\u4e00\u79cd\u6613\u4e8e\u91c7\u7528\u4f46\u9ad8\u5ea6\u7075\u6d3b\u4e14\u53ef\u6269\u5c55\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u53ef\u4ee5\u968f\u7740\u60a8\u7684\u9700\u6c42\u800c\u589e\u957f\u3002", "note_en": "The Eiffel protocol saw the light of day in 2012 as a protocol for large-scale software integration within Ericsson. In 2016 Ericsson made the initial contribution of the protocol to open source, and has since then been collaborating with the community to create open source implementations of it. Coming from the world of large telecommunications systems it was designed for scalability and high demands on traceability. At the same time, the design of the protocol and its implementations ensures that you can cherry-pick the parts that are relevant to you. This affords an easy-to-adopt yet highly flexible and scalable solution that will grow along with your needs.", "posttime": "2022-01-10 06:39:55", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "ci,traceable,\u534f\u8bae", "title": "EIFFIL  -  CI / CD ECO\u7cfb\u7edf\u7684\u53ef\u8ffd\u8e2a\u5b9e\u65f6\u6d88\u606f\u4f20\u9012\u534f\u8bae", "title_en": "Eiffel \u2013 Traceable real time messaging protocol for CI/CD eco systems", "transed": 1, "url": "https://eiffel-community.github.io/", "via": "", "real_tags": ["ci", "traceable", "\u534f\u8bae"]}, {"category": "", "categoryclass": "", "imagename": "6db74e6e2529a27f59efbb63314a8c2f.jpeg", "infoid": 1072566, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u4eb2\u7231\u7684\u793e\u533a\uff0c\u6211\u4eec\u5f88\u81ea\u8c6a\u80fd\u6210\u4e3a\u7b2c\u4e00\u5bb6\u5ba3\u5e03\u6700\u65b0\u7684RK3588\u4ea7\u54c1 -  Rock5B SBC\u7684\u4f9b\u5e94\u5546\u4e4b\u4e00\u3002\u7279\u70b9\u6982\u8ff0\u5ca9\u4f535B\uff1aRock5B\u4eae\u70b9PI-CO ITX\u5f62\u72b6\u56e0\u5b50\uff082.5\u82f1\u5bf8\uff0c100 x 72mm\uff09RK3588 Powered\uff0c8NM\u5236\u9020\u8fc7\u7a0bQuad A76 2.4GHz +\u56db\u5206\u4e4b\u4e00A55 1.8GHz Mali G610MC4 GPU\uff08\u6700\u591a5\u901a\u90534K UI\uff096T NPU 8K 10bit\u89e3\u7801\u5668\uff0c8K\u7f16\u7801\u5668\u652f\u6301WiFi 6e\u548cBT5.2\u652f\u6301PCIe 3.0 X4 NVME SSD\u4e09\u91cd\u663e\u793a\u5c4f\u652f\u6301\uff08\u5e26HDR\uff09\u4e24\u4e2aHDMI 2.1 up\u52308k @ 60fps\u4e00\u4e2aUSB C W ...", "note_en": "Dear community,  We are so proud to be one of the first vendor to announce our latest RK3588 based product - ROCK5B SBC.  Feature overview for ROCK 5B:    ROCK5B Highlights  PI-co ITX form factor(2.5 inch, 100 x 72mm) RK3588 powered, 8nm manufacturing process  Quad A76 2.4Ghz + Quad A55 1.8Ghz Mali G610MC4 GPU(up to 5 channel 4K UI) 6T NPU 8K 10bit decoder, 8K encoder   Support WiFi 6E and BT5.2 Support PCIe 3.0 x4 NVMe SSD Triple display support(with HDR)  Two HDMI 2.1up to 8K@60FPS One USB C w...", "posttime": "2022-01-10 06:37:59", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u5ca9\u77f3,rock,\u652f\u6301", "title": "\u4ecb\u7ecd\u5ca9\u77f35\u578b\u53f7B  -  ARM\u684c\u9762\u7ea7SBC", "title_en": "Introduce ROCK 5 Model B - ARM desktop level SBC", "transed": 1, "url": "https://forum.radxa.com/t/introduce-rock-5-model-b-arm-desktop-level-sbc/8361", "via": "", "real_tags": ["\u5ca9\u77f3", "rock", "\u652f\u6301"]}, {"category": "", "categoryclass": "", "imagename": "b00058ccd20d70029a6dd084ae39bfb9.jpeg", "infoid": 1072565, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u4f5c\u4e3a\u4f18\u6b65\u5de5\u7a0b\u7684\u4e00\u90e8\u5206\u52aa\u529b\u8fbe\u5230\u76c8\u5229\u80fd\u529b\uff0c\u6700\u8fd1\u6211\u4eec\u7684\u56e2\u961f\u901a\u8fc7\u63d0\u9ad8\u6548\u7387\u6765\u964d\u4f4e\u8ba1\u7b97\u80fd\u529b\u7684\u6210\u672c\u3002\u4e00\u4e9b\u6700\u6709\u5f71\u54cd\u529b\u7684\u5de5\u4f5c\u662fGogc\u4f18\u5316\u3002\u5728\u672c\u535a\u5ba2\u4e2d\uff0c\u6211\u4eec\u5e0c\u671b\u5229\u7528\u9ad8\u6548\uff0c\u4f4e\u98ce\u9669\uff0c\u5927\u89c4\u6a21\uff0c\u534a\u81ea\u52a8\u5316GO GC\u8c03\u6574\u673a\u5236\u5206\u4eab\u6211\u4eec\u7684\u7ecf\u9a8c\u3002\n\u5b83\u4e0d\u77e5\u9053\u5206\u914d\u7ed9\u5bb9\u5668\u7684\u6700\u5927\u5185\u5b58\uff0c\u53ef\u80fd\u5bfc\u81f4\u5185\u5b58\u95ee\u9898\u3002\n\u4f7f\u7528Madv_free\u5185\u5b58\u7b56\u7565\u7684\u670d\u52a1\u5bfc\u81f4\u9519\u8bef\u7684\u5185\u5b58\u6307\u6807\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u7684\u53ef\u89c2\u5bdf\u6027\u5ea6\u91cf\u6807\u51c6\u663e\u793a\u4e8650\uff05\u7684\u5185\u5b58\u5229\u7528\u7387\uff08\u5f53\u5b83\u5b9e\u9645\u4e0a\u5df2\u7ecf\u53d1\u5e03\u4e8650\uff05\u768420\uff05\u65f6\uff09\u3002\u7136\u540e\uff0c\u670d\u52a1\u6240\u6709\u8005\u53ea\u4f7f\u7528\u6b64\u201c\u4e0d\u51c6\u786e\u201d\u5ea6\u91cf\u6807\u51c6\u8c03\u6574Gogc\u3002\n\u8c03\u7528\u8fd0\u884c\u65f6\u3002 setfinalizer\uff08f\uff0cfinalizer handler\uff09\u5728FinalizerHandler\u5185\u90e8\u5141\u8bb8\u5904\u7406\u7a0b\u5e8f\u5728\u6bcf\u4e2aGC\u4e0a\u8fd0\u884c;\u5b83\u57fa\u672c\u4e0a\u6ca1\u6709\u8ba9\u53c2\u8003\u6a21\u5177\uff0c\u56e0\u4e3a\u5b83\u4e0d\u662f\u4fdd\u6301\u6d3b\u529b\u7684\u6602\u8d35\u8d44\u6e90\uff08\u5b83\u53ea\u662f\u4e00\u4e2a\u6307\u9488\uff09\u3002", "note_en": "As part of Uber engineering\u2019s wide efforts to reach profitability, recently our team was focused on reducing cost of compute capacity by improving efficiency. Some of the most impactful work was around GOGC optimization. In this blog we want to share our experience with a highly effective, low-risk, large-scale, semi-automated Go GC tuning mechanism.\n Uber\u2019s tech stack is composed of thousands of microservices, backed by a cloud-native, scheduler-based infrastructure. Most of these services are written in Go. Our team, Maps Production Engineering, has previously played an instrumental role in significantly improving the efficiency of multiple Java services by tuning GC. At the beginning of 2021, we explored the possibilities of having a similar impact on Go-based services. We ran several CPU profiles to assess the current state of affairs and we found that GC was the top CPU consumer for a vast majority of mission-critical services. Here is a representation of some CPU profiles where GC (identified by the  runtime.scanobject method) is consuming a significant portion of allocated compute resources.\n        Emboldened by this finding, we commenced to tune GC for the relevant services. To our delight, Go\u2019s GC implementation and the simplicity of tuning allowed us to automate the bulk of the detection and tuning mechanism. We detail our approach and its impact in the following sections.\n   Go runtime invokes a concurrent garbage collector at periodic intervals unless there is a triggering event before it. The triggering events are based on memory back pressure. Due to this, GC-impacted Go services benefit from more memory, since it reduces the times GC has to run. In addition, we realized that our host-level CPU to memory ratio is 1:5 (1 core : 5 GB RAM), while most Golang services were configured with a 1:1 to 1:2 ratio. Therefore, we were confident that we could leverage using more memory to reduce GC CPU impact. This is a service-agnostic mechanism that can yield a large impact when applied judiciously.\n Delving deep into Go\u2019s garbage collection is beyond the scope of this article, but here are the relevant bits for this work: Garbage collection in Go is concurrent and involves analyzing all objects to identify which ones are still reachable. We would call the reachable objects the \u201clive dataset.\u201d Go offers only one knob,   GOGC,  expressed in percentage of live dataset, to control garbage collection. The   GOGC  value acts as a multiplier for the dataset. The default value of   GOGC  is 100%, which means Go runtime will reserve the same amount of memory for new allocations as the live dataset. For instance:\n  Then the   pacer  is in charge of predicting when it is the best time to trigger GC to avoid hitting the hard target (soft target).\n     We identified that a fixed GOGC value-based tuning is not suitable for services at Uber. Some of the challenges are:\n It is not aware of the maximum memory assigned to the container and can cause out of memory issues.\n Our microservices have a significantly diverse memory utilization portfolio. For example, a sharded system can have very different live datasets. We experienced this in one of our services where the p99 utilization was 1G but the p1 was 100MB, therefore the 100MB instances were having a huge GC impact.\n   The pain points previously presented are the reason for the conception of GOGCTuner. GOGCTuner is a library which simplifies the process of tuning garbage collection for service owners and adds a reliability layer on top of it.\n GOGCTuner dynamically computes the correct GOGC value in accordance with the container\u2019s memory limit (or the upper limit from the service owner) and sets it using Go\u2019s runtime API. Following are the specifics of the GOGCTuner library\u2019s features:\n Simplified configuration for easier reasoning and deterministic calculations. GOGC at 100% is not clear for beginner Go developers and it is not deterministic, because it still depends on the live dataset. On the other hand a 70% limit ensures that the service is always going to use 70% of the heap space.\n Protection against OOMs (Out Of Memory): The library reads the memory limit from the cgroup and uses a default hard limit of 70%, a safe value from our experience. It is important to note that there is a limit to this protection. The tuner can only adjust the buffer allocation, so if your service live objects are higher than the limit the tuner would set a default lower limit of 1.25X your live objects utilization.\n Allow higher GOGC values for corner cases like: As we mentioned above, manual GOGC is not deterministic. We are still relying on the size of the live dataset. What if live_dataset doubles our last peak value? GOGCTuner would enforce the same memory limit at the cost of more CPU. Manual tuning instead could cause OOMs. Therefore, service owners used to give plenty of buffer for these types of scenarios. See the example below:\n           Services using   MADV_FREE  memory policy that results in wrong memory metrics. For instance, our observability metrics were showing 50% memory utilization (when it actually had already released 20% of that 50%). Then service owners were only tuning GOGC using this \u201cinaccurate\u201d metric.\n   We found that we lacked some critical metrics which would give us more insights into garbage collection of each service.\n Intervals between garbage collections : useful to know if we can still tune. For instance, Go forces a garbage collection every 2 minutes. If your service is still having high GC impact, but you already see 120s for this graph, it means that you can no longer tune using GOGC. In this case you would need to optimize your allocations.\n    GC CPU impact : allows us to know which services are the most affected by GC.\n    Live dataset size : helps us to identify memory leaks. The concern noted by service owners was that they saw an increase in memory utilization. In order to show them there was no memory leak we added the \u201clive usage\u201d metric, which showed a steady utilization.\n          Our initial approach was to have a ticker to run every second to monitor the heap metrics, and then adjust GOGC value accordingly. The disadvantage of this approach is that the overhead starts to become considerable, because in order to read heap metrics Go needs to do a STW (  ReadMemStats ) and it is somewhat inaccurate, because we can have more than one garbage collection per second.\n Luckily we were able to find a good alternative. Go has finalizers (  SetFinalizer ), which are functions that run when the object is going to be garbage collected. They are mainly useful for cleaning memory in C code or some other resources. We were able to employ a self-referencing finalizer that resets itself on every GC invocation. This allows us to reduce any CPU overhead. For instance:\n   Calling   runtime . SetFinalizer ( f ,  finalizerHandler )  inside of  finalizerHandler  is what allows the handler to run on every GC; it is basically not letting the reference die, since it is not a costly resource to keep alive (it is just a pointer).\n   After deploying GOGCTuner across a few dozen of our services, we dove deep on a few that showed significant, double-digit improvement in their CPU utilization. Accumulated cost savings from these services alone are around 70K cores. Following are 2 such examples:\n       The resulting CPU utilization reduction improves p99 latency (and associated SLA, user experience) tactically, and cost of capacity strategically (since services are scaled based on their utilization).\n   Garbage collection is one of the most elusive and underestimated performance influencers of an application. Go\u2019s robust GC mechanism and simplified tuning, our diverse, large-scale Go services footprint, and a robust internal platform (Go, compute, observability) collectively allowed us to make such a large-scale impact. We expect to continue improving how we tune GC as the problem space itself is evolving, due to changes in the tech and our competency.\n To reiterate what we mentioned at the introduction: there is no one size fits all solution. We feel GC performance will remain variable in cloud-native setup due to the highly variable performance of both public clouds and containerized workloads that run within. Coupled with the fact that a vast majority of CNCF landscape projects that we use are written in Golang (Kubernetes, Prometheus, Jaeger, etc.), this means any large-scale deployment outside could also benefit from such effort.", "posttime": "2022-01-10 06:37:15", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u534a\u81ea\u52a8,semi,\u5185\u5b58", "title": "\u6211\u4eec\u5982\u4f55\u4f7f\u7528\u534a\u81ea\u52a8GO GC\u8c03\u6574\u4fdd\u5b5870K\u5185\u6838", "title_en": "How We Saved 70K Cores with Semi-Automated Go GC Tuning", "transed": 1, "url": "https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/", "via": "", "real_tags": ["\u534a\u81ea\u52a8", "semi", "\u5185\u5b58"]}, {"category": "", "categoryclass": "", "imagename": "6003c74de391823d5141a450b25fecf9.jpg", "infoid": 1072564, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u6fb3\u5927\u5229\u4e9a\u7684\u6089\u5c3c\u897f\u5317\u6570\u767e\u82f1\u91cc\u7684\u6fb3\u5927\u5229\u4e9a\u4e2d\u592e\u5927\u6559\u5802\uff0c\u4eca\u5929\u7531\u8349\u548c\u7ea4\u7ef4\u6811\u5360\u4e3b\u5bfc\u5730\u4f4d\u3002\u4f46\u79d1\u5b66\u5bb6\u6700\u8fd1\u53d1\u73b0\uff0c\u4e00\u4e9b\u5730\u533a\u7684\u751f\u9508\u5ca9\u77f3\u63a9\u76d6\u4e86\u90c1\u90c1\u8471\u8471\u7684\u96e8\u6797\u7684\u75d5\u8ff9\uff0c\u8fd9\u4e9b\u96e8\u6797\u5728\u4e2d\u95f4\u65f6\u4ee3\u7eaa\u5ff5\u671f\u95f4\u6db5\u76d6\u4e861500\u4e07\u5e74\u524d\u7684\u8302\u5bc6\u96e8\u6797\u3002\n\u8be5\u7f51\u7ad9\u8fd8\u4ea7\u751f\u4e86\u5341\u51e0\u4e2a\u53e4\u8001\u7684arachnids\u3002\u867d\u7136\u6606\u866b\u5177\u6709\u575a\u56fa\u7684\u5916\u9aa8\u9abc\uff0c\u8fc8\u514b\u5c14\u00b7\u5f17\u96f7\u6cfd\uff0c\u582a\u57f9\u62c9\u5927\u5b66\u7684\u75c5\u6bd2\u5b66\u5bb6\u548c\u53e4\u751f\u7269\u5b66\u5bb6\u4ee5\u53ca\u8be5\u7814\u7a76\u7684\u5171\u540c\u4f5c\u8005\uff0c\u5c06\u8718\u86db\u6bd4\u8f83\u201c\u6324\u538b\u888b\u201d\u3002\u56e0\u6b64\uff0c\u6fb3\u5927\u5229\u4e9a\u7684\u8718\u86db\u5316\u77f3\u8bb0\u5f55\u51e0\u4e4e\u4e0d\u5b58\u5728\uff0c\u5728\u9ea6\u683c\u62c9\u65af\u5e73\u5766\u4e4b\u524d\u3002\n\u201c\u7814\u7a76\u8fd9\u4e9b\u5316\u77f3\u751f\u6001\u7cfb\u7edf\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u54ea\u4e9b\u7269\u79cd\u66f4\u80fd\u591f\u9002\u5e94\u8fd9\u4e9b\u53d8\u5316\uff0c\u201d\u9ea6\u514b\u62c9\u7279\u535a\u58eb\u8bf4\u3002 \u201c\u6211\u4eec\u53ef\u4ee5\u5728\u672a\u6765\u7684\u53d8\u5316\u65b9\u9762\u9884\u6d4b\u6700\u591a\u7684\u98ce\u9669\u3002\u201d", "note_en": "Australia\u2019s Central Tablelands, hundreds of miles northwest of Sydney, are dominated today by grasses and spindly trees. But scientists recently discovered that some of the area\u2019s rusted rocks conceal traces of the lush rainforests that covered the area 15 million years ago during the Miocene Epoch.\n The area, McGraths Flat, is not Australia\u2019s only Miocene deposit, but these new fossils are a paleontological boon because of their exquisite preservation. Over the past three years paleontologists have excavated flowers, insects and even a bird\u2019s wispy feather.\n The scientists\u2019 discoveries,  published Friday in the journal Science Advances, help reconstruct Australia\u2019s Miocene rainforest in extensive detail, and the site \u201copens a whole new area of exploration for Australian paleontology,\u201d said Scott Hocknull, a paleontologist at Queensland Museum who was not involved in the research.\n Fifteen million years ago, a river carved through the jungle, leaving an oxbow lake (known as a billabong in Australia) in its wake at McGraths Flat. Nearly devoid of oxygen, this stagnant pool kept scavengers at bay, allowing plant material and animal carcasses to accumulate. As iron-rich runoff from nearby basalt mountains seeped into the billabong, the pool\u2019s low pH caused the iron to precipitate and encase the organic material. As a result, the fossils at McGraths Flat are preserved in a dense, iron-rich rock known as goethite.\n  This method of fossilization is uncommon, Dr. Hocknull said. Because quality fossils are rarely found in igneous rocks, paleontologists often overlook them. However, the fossils from McGraths Flat illustrate that goethite, which is common in Australia, can yield remarkable fossils.\n \u201cThere\u2019s no shortage of goethite,\u201d Dr. Hocknull said. \u201cWe\u2019re essentially a rusting country.\u201d\n   Because of their iron-tinted origins, many of the fossils from McGraths Flat glimmer with a metallic sheen. In addition to pristine plants, the goethite is crawling with fossilized insects. As they split apart the brick-colored slabs of stone, the researchers have discovered a miniature menagerie of giant cicadas, dragonflies and parasitic wasps. And many are remarkably preserved \u2014 some ancient flies sport the detailed imprints of their compound eyes.\n The site has also yielded more than a dozen archaic arachnids. While insects have sturdy exoskeletons, Michael Frese, a virologist and paleontologist at the University of Canberra and a co-author of the study, likens spiders to \u201csquishy bags of liquid.\u201d As a result, Australia\u2019s fossil record of spiders was nearly nonexistent before McGraths Flat.\n  The fossils are so well preserved that the paleontologists were able to observe relationships between species \u2014 something that is often difficult to parse from fossil sites, according to Matthew McCurry, the curator of paleontology at The Australian Museum and the study\u2019s lead author. For example, the team observed parasites fastened to a fish\u2019s tail and a nematode that had infiltrated a longhorn beetle.\n Dr. Frese utilized an electron microscope and microphotography techniques to examine the rainforest\u2019s inhabitants. While imaging a fossilized sawfly, Dr. Frese discovered a clump of pollen on the bee-like insect\u2019s head.\n \u201cWe can tell which flower was visited by this particular sawfly before it fell into the water and met its untimely end,\u201d Dr. Frese said. \u201cThat would not be possible if the quality of preservation was not as high.\u201d\n   The pollen also revealed that the rainforest was surrounded by drier environments, making it likely that McGraths Flat represents a remnant patch of a once larger forest. According to Dr. McCurry, this makes sense considering the climatic trends of the Miocene.\n When these insects scurried around the iron-tainted billabong, Australia was drifting northward, away from Antarctica. As it traveled, its climate drastically dried out, causing the rainforests to retract and leading to widespread extinctions.\n  The researchers believe McGraths Flat offers an intimate glimpse of how this dramatic climate transition affected particular species within the rainforest ecosystem. For instance, some insects found at McGraths Flat endured drier conditions while others are now found only in northern Australia\u2019s remnant pockets of rainforest.\n \u201cStudying these fossil ecosystems, we can see which species were better able to adapt to those changes,\u201d Dr. McCurry said. \u201cWe can potentially predict which are most at risk in terms of future changes.\u201d\n Dr. Frese said that McGraths Flat was particularly useful for reconstructing ancient ecosystems because of the breadth of species it preserved.\n \u201cOur site is different because it\u2019s all small fossils, but in the end, I think it will tell us more about what has happened in the ecosystem,\u201d Dr. Frese said. \u201cYou do not need to find a one-ton terror bird to tell this story.\u201d", "posttime": "2022-01-10 05:43:04", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "rust,\u96e8\u6797,prehistoric,\u53d8\u5316", "title": "\u53f2\u524d\u96e8\u6797\u7684\u5316\u77f3\u5728\u6fb3\u5927\u5229\u4e9a\u751f\u9508\u7684\u5ca9\u77f3\u91cc\u85cf\u8d77\u6765", "title_en": "Fossils of a Prehistoric Rainforest Hide in Australia\u2019s Rusted Rocks", "transed": 1, "url": "https://www.nytimes.com/2022/01/07/science/fossils-australia-rainforest.html", "via": "", "real_tags": ["rust", "\u96e8\u6797", "\u53d8\u5316"]}]