<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CLI指南–帮助您编写更好的命令行程序的指南 CLI Guidelines – A guide to help you write better command-line programs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CLI Guidelines – A guide to help you write better command-line programs<br/>CLI指南–帮助您编写更好的命令行程序的指南 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-05 05:16:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/e8b4ad6300b38ab8ad35f31bca02e31c.jpg"><img src="http://img2.diglog.com/img/2020/12/e8b4ad6300b38ab8ad35f31bca02e31c.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>An  open-source guide to help you write better command-line programs, taking traditional UNIX principles and updating them for the modern day.</p><p>开源指南，可帮助您编写更好的命令行程序，采用传统的UNIX原理并在现代进行更新。</p><p>      Design by  Mark Hurrell. Thanks to Andreas Jansson for early contributions, and Andrew Reitz, Ashley Williams, Brendan Falk, Chester Ramey, Dj Walker-Morgan, Jacob Maine, James Coglan, Michael Dwan, and Steve Klabnik for reviewing drafts.</p><p>      由马克·赫雷尔（Mark Hurrell）设计。感谢Andreas Jansson的早期贡献，以及Andrew Reitz，Ashley Williams，Brendan Falk，Chester Ramey，Dj Walker-Morgan，Jacob Maine，James Coglan，Michael Dwan和Steve Klabnik的初稿。</p><p>   In the 1980s, if you wanted a personal computer to do something for you, you needed to know what to type when confronted with  C:\&gt; or  ~$.Help came in the form of thick, spiral-bound manuals.Error messages were opaque.There was no Stack Overflow to save you.But if you were lucky enough to have internet access, you could get help from Usenet—an early internet community filled with other people who were just as frustrated as you were.They could either help you solve your problem, or at least provide some moral support and camaraderie.</p><p>   在1980年代，如果您想让个人计算机为您做一些事情，那么您需要知道在遇到C：\ gt;时要键入什么内容。或〜$。帮助以厚厚的螺旋装订手册的形式出现。错误消息不透明。没有堆栈溢出来保存您。但是，如果您有幸能够访问Internet，可以从Usenet获得帮助。早期的互联网社区中充斥着与您一样沮丧的其他人，他们可以帮助您解决问题，或者至少提供一些道义上的支持和友善。</p><p> Forty years later, computers have become so much more accessible to everyone, often at the expense of low-level end user control.On many devices, there is no command-line access at all, in part because it goes against the corporate interests of walled gardens and app stores.</p><p> 四十年后，计算机变得所有人都可以使用，这经常以低级的最终用户控制为代价。在许多设备上，根本没有命令行访问权限，部分原因是它违反了公司的企业利益。围墙花园和应用商店。</p><p> Most people today don’t know what the command line is, much less why they would want to bother with it.As computing pioneer Alan Kay said in  a 2017 interview, “Because people don’t understand what computing is about, they think they have it in the iPhone, and that illusion is as bad as the illusion that ‘Guitar Hero’ is the same as a real guitar.”</p><p> 如今，大多数人不知道命令行是什么，更不用说为什么要打扰命令行了。正如计算先驱艾伦·凯（Alan Kay）在2017年的一次采访中所说：“由于人们不了解计算的含义，他们认为在iPhone上安装它，这种错觉与“吉他英雄”与真正的吉他相同的错觉一样糟糕。”</p><p> Kay’s “real guitar” isn’t the CLI—not exactly.He was talking about ways of programming computers that offer the power of the CLI and that transcend writing software in text files.There is a belief among Kay’s disciples that we need to break out of a text-based local maxima that we’ve been living in for decades.</p><p> 凯（Kay）的“真正的吉他”不是CLI，也不完全是CLI。他在谈论编程计算机的方法，这些计算机可以提供CLI的功能，并且可以超越在文本文件中编写软件的功能。凯（Kay）的门徒们认为，我们需要打破常规基于我们已经生活了数十年的基于文本的局部最大值。</p><p> It’s exciting to imagine a future where we program computers very differently.Even today, spreadsheets are by far the most popular programming language, and the no-code movement is taking off quickly as it attempts to replace some of the intense demand for talented programmers.</p><p> 想象一个未来，我们对计算机进行编程的方式会非常令人兴奋。即使在今天，电子表格也是迄今为止最受欢迎的编程语言，无代码运动正在迅速兴起，因为它试图取代对有才华的程序员的某些强烈需求。 </p><p> Yet with its creaky, decades-old constraints and inexplicable quirks, the command line is still the most  versatile corner of the computer.It lets you pull back the curtain, see what’s really going on, and creatively interact with the machine at a level of sophistication and depth that GUIs cannot afford.It’s available on almost any laptop, for anyone who wants to learn it.It can be used interactively, or it can be automated.And, it doesn’t change as fast as other parts of the system.There is creative value in its stability.</p><p>然而，由于其艰苦的工作，数十年的局限性和无法解释的怪癖，命令行仍然是计算机上功能最丰富的角落，它使您可以拉开帷幕，查看实际情况，并在一定程度上与计算机进行创造性的交互GUI无法承受的复杂性和深度。几乎任何笔记本电脑都可以使用它，任何想学习它的人都可以使用。它可以交互使用，也可以自动化，而且其变化速度不如系统的其他部分。 。其稳定性具有创造价值。</p><p> So, while we still have it, we should try to maximize its utility and accessibility.</p><p> 因此，尽管我们仍然拥有它，但我们应该尝试使其实用性和可访问性最大化。</p><p> A lot has changed about how we program computers since those early days.The command line of the past was  machine-first: little more than a REPL on top of a scripting platform.But as general-purpose interpreted languages have flourished, the role of the shell script has shrunk.Today’s command line is  human-first: a text-based UI that affords access to all kinds of tools, systems and platforms.In the past, the editor was inside the terminal—today, the terminal is just as often a feature of the editor.And there’s been a proliferation of  git-like multi-tool commands.Commands within commands, and high-level commands that perform entire workflows rather than atomic functions.</p><p> 自从早期以来，我们对计算机编程的方式发生了很多变化。过去的命令行是机器优先的：仅是脚本平台之上的REPL，但是随着通用解释语言的蓬勃发展， shell脚本缩水了。今天的命令行是人为本的：一个基于文本的UI，可以访问各种工具，系统和平台。过去，编辑器位于终端内部，而如今，终端就像通常是编辑器的功能，并且出现了类似git的多工具命令，包括命令内的命令以及执行整个工作流程而不是原子功能的高级命令。</p><p> Inspired by traditional UNIX philosophy, driven by an interest in encouraging a more delightful and accessible CLI environment, and guided by our experiences as programmers, we decided it was time to revisit the best practices and design principles for building command-line programs.</p><p> 受传统UNIX哲学的启发，出于对鼓励使用更令人愉悦和可访问的CLI环境的兴趣，并以我们作为程序员的经验为指导，我们决定是时候重新考虑构建命令行程序的最佳实践和设计原则了。</p><p>   This document covers both high-level design philosophy, and concrete guidelines.It’s heavier on the guidelines because our philosophy as practitioners is not to philosophize too much.We believe in learning by example, so we’ve provided plenty of those.</p><p>   本文档涵盖了高级设计理念和具体准则。由于我们的实践者哲学不要过多地哲学化，因此准则上的内容要重一些。我们相信通过示例进行学习，因此我们提供了很多示例。</p><p> This guide doesn’t cover full-screen terminal programs like emacs and vim.Full-screen programs are niche projects—very few of us will ever be in the position to design one.</p><p> 本指南未涵盖emacs和vim等全屏终端程序。全屏程序是利基项目，我们中很少有人能够设计一个。</p><p>   If you are creating a CLI program and you are looking for principles and concrete best practices for its UI design, this guide is for you.</p><p>   如果要创建CLI程序，并且正在为其UI设计寻找原理和具体的最佳实践，则本指南适合您。 </p><p> If you are a professional “CLI UI designer,” that’s amazing—we’d love to learn from you.</p><p>如果您是专业的“ CLI UI设计师”，那就太好了–我们很乐意向您学习。</p><p> If you’d like to avoid obvious missteps of the variety that go against 40 years of CLI design conventions, this guide is for you.</p><p> 如果您想避免与40年来的CLI设计惯例相抵触的错误，本指南非常适合您。</p><p> If you want to delight people with your program’s good design and helpful help, this guide is definitely for you.</p><p> 如果您想通过程序的良好设计和有用的帮助使人们满意，那么本指南绝对适合您。</p><p> If you are creating a GUI program, this guide is not for you—though you may learn some GUI anti-patterns if you decide to read it anyway.(Do GUI programmers even read, or do they just look at things?)</p><p> 如果您正在创建GUI程序，那么本指南不适合您-尽管如果您仍然决定阅读该指南，则可能会学到一些GUI反模式。（GUI程序员甚至会阅读，还是只是看东西？）</p><p> If you are designing an immersive, full-screen CLI port of Minecraft, this guide isn’t for you.(But we can’t wait to see it!)</p><p> 如果您正在设计Minecraft的沉浸式全屏CLI端口，则本指南不适合您。（但我们迫不及待想看到它！）</p><p>    Traditionally, UNIX commands were written under the assumption they were going to be used primarily by other programs.They had more in common with functions in a programming language than with graphical applications.</p><p>    传统上，UNIX命令是在假设它们将主要由其他程序使用的情况下编写的，它们在编程语言中的功能比图形应用程序具有更多的共同点。</p><p> Today, even though many CLI programs are used primarily (or even exclusively) by humans, a lot of their interaction design still carries the baggage of the past.It’s time to shed some of this baggage: if a command is going to be used primarily by humans, it should be designed for humans first.</p><p> 如今，即使许多CLI程序主要由人使用（或什至仅由人使用），但它们的许多交互设计仍然保留了过去的包..现在是时候摆脱一些包：了：如果要主要使用命令对于人类，应该首先为人类设计。 </p><p>  A core tenet of  the original UNIX philosophy is the idea that small, simple programs with clean interfaces can be combined to build larger systems.Rather than stuff more and more features into those programs, you make programs that are modular enough to be recombined as needed.</p><p>最初的UNIX哲学的核心宗旨是，可以将具有简洁接口的小型简单程序组合起来以构建更大的系统，而不是在程序中添加越来越多的功能，而是要使程序模块化，以根据需要进行重新组合。</p><p> In the old days, pipes and shell scripts played a crucial role in the process of composing programs together.Their role might have diminished with the rise of general-purpose interpreted languages, but they certainly haven’t gone away.What’s more, large-scale automation—in the form of CI/CD, orchestration and configuration management—has flourished.Making programs composable is just as important as ever.</p><p> 在过去，管道和shell脚本在组合程序的过程中起着至关重要的作用。它们的作用可能会随着通用解释语言的兴起而减弱，但它们并没有消失。大规模的自动化（以CI / CD，业务流程和配置管理的形式）蓬勃发展。使可组合程序变得与以往一样重要。</p><p> Fortunately, the long-established conventions of the UNIX environment, designed for this exact purpose, still help us today.Standard in/out/err, signals, exit codes and other mechanisms ensure that different programs click together nicely.Plain, line-based text is easy to pipe between commands.JSON, a much more recent invention, affords us more structure when we need it, and lets us more easily integrate command-line tools with the web.</p><p> 幸运的是，针对此特定目的而设计的UNIX环境的悠久惯例今天仍然对我们有所帮助。标准的in /​​ out / err，信号，退出代码和其他机制可确保不同的程序很好地单击在一起。文本很容易在命令之间传递。JSON是一种较新的发明，可以在需要时为我们提供更多结构，并使我们可以更轻松地将命令行工具与Web集成。</p><p> Whatever software you’re building, you can be absolutely certain that people will use it in ways you didn’t anticipate.Your software  will become a part in a larger system—your only choice is over whether it will be a well-behaved part.</p><p> 无论您要构建什么软件，您都可以绝对确定人们会以您意想不到的方式使用它。您的软件将成为更大系统中的一部分-您唯一的选择是是否将其做得很好。 。</p><p> Most importantly, designing for composability does not need to be at odds with designing for humans first.Much of the advice in this document is about how to achieve both.</p><p> 最重要的是，针对可组合性的设计不必首先与针对人类的设计相冲突。本文档中的许多建议都涉及如何实现两者。</p><p>  The terminal’s conventions are hardwired into our fingers.We had to pay an upfront cost by learning about command line syntax, flags, environment variables and so on, but it pays off in long-term efficiency… as long as programs are consistent.</p><p>  终端的约定已扎根在我们的手指上。我们必须通过了解命令行语法，标志，环境变量等来支付前期费用，但只要程序保持一致，它就可以长期有效。</p><p> Where possible, a CLI should follow patterns that already exist.That’s what makes CLIs intuitive and guessable; that’s what makes users efficient.</p><p> CLI应该尽可能遵循现有的模式。这就是使CLI直观易懂的原因。这就是使用户高效的原因。 </p><p> That being said, sometimes consistency conflicts with ease of use.For example, many long-established UNIX commands don’t output much information by default, which can cause confusion or worry for people less familiar with the command line.</p><p>话虽如此，有时一致性会与易用性相冲突。例如，许多历史悠久的UNIX命令默认情况下不会输出太多信息，这可能会给不熟悉命令行的人造成混乱或担忧。</p><p> When following convention would compromise a program’s usability, it might be time to break with it—but such a decision should be made with care.</p><p> 当遵循约定会损害程序的可用性时，可能是时候打破它了，但是这样的决定应该谨慎。</p><p>  The terminal is a world of pure information.You could make an argument that information is the interface—and that, just like with any interface, there’s often too much or too little of it.</p><p>  终端是一个纯信息的世界。您可以争辩说信息是界面，而且就像任何界面一样，信息太多或太少。</p><p> A command is saying too little when it hangs for several minutes and the user starts to wonder if it’s broken.A command is saying too much when it dumps pages and pages of debugging output, drowning what’s truly important in an ocean of loose detritus.The end result is the same: a lack of clarity, leaving the user confused and irritated.</p><p> 当挂起几分钟时，一条命令说的太少了，用户开始怀疑它是否坏了;当转储页面和调试输出的页面时，一条命令说了太多了，淹没了松散碎屑中真正重要的部分。最终结果是相同的：缺乏清晰度，使用户感到困惑和恼火。</p><p> It can be very difficult to get this balance right, but it’s absolutely crucial if software is to empower and serve its users.</p><p> 要实现这种平衡可能非常困难，但是对于软件来说，授权和服务于用户至关重要。</p><p>  When it comes to making functionality discoverable, GUIs have the upper hand.Everything you can do is laid out in front of you on the screen, so you can find what you need without having to learn anything, and perhaps even discover things you didn’t know were possible.</p><p>  在使功能变得可发现时，GUI占了上风。您可以做的所有事情都摆在屏幕上的前面，因此您无需学习任何内容就可以找到所需的内容，甚至可以发现自己没有做的事情。''不知道有可能。</p><p> It is assumed that command-line interfaces are the opposite of this—that you have to remember how to do everything.The original  Macintosh Human Interface Guidelines, published in 1992, recommend “See-and-point (instead of remember-and-type),” as if you could only choose one or the other.</p><p> 假定命令行界面与此相反，您必须记住如何做。1992年出版的原始Macintosh Human Interface Guidelines建议“视点（而不是记住类型）”。 ），就像您只能选择其中一个。 </p><p> These things needn’t be mutually exclusive.The efficiency of using the command-line comes from remembering commands, but there’s no reason the commands can’t help you learn and remember.</p><p>这些事情不必相互排斥。使用命令行的效率来自于记住命令，但是没有理由命令不能帮助您学习和记住。</p><p> Discoverable CLIs have comprehensive help texts, provide lots of examples, suggest what command to run next, suggest what to do when there is an error.There are lots of ideas that can be stolen from GUIs to make CLIs easier to learn and use, even for power users.</p><p> 可发现的CLI包含全面的帮助文本，大量示例，建议下一步要执行的命令，建议发生错误时应采取的措施，可以从GUI窃取很多想法以使CLI更加易于学习和使用，甚至对于高级用户。</p><p>   GUI design, particularly in its early days, made heavy use of  metaphor: desktops, files, folders, recycle bins.It made a lot of sense, because computers were still trying to bootstrap themselves into legitimacy.The ease of implementation of metaphors was one of the huge advantages GUIs wielded over CLIs.Ironically, though, the CLI has embodied an accidental metaphor all along: it’s a conversation.</p><p>   GUI设计（特别是在早期）大量使用了隐喻：台式机，文件，文件夹，回收站，这很有意义，因为计算机仍在努力使自己合法化。隐喻的易于实现是其中之一。 GUI具有CLI的巨大优势。但具有讽刺意味的是，CLI始终体现了一个偶然的隐喻：这是一次对话。</p><p> Beyond the most utterly simple commands, running a program usually involves more than one invocation.Usually, this is because it’s hard to get it right the first time: the user types a command, gets an error, changes the command, gets a different error, and so on, until it works.This mode of learning through repeated failure is like a conversation the user is having with the program.</p><p> 除了最简单的命令外，运行一个程序通常还涉及多个调用，通常是因为很难在第一次就正确地执行它：用户键入命令，获取错误，更改命令，获取其他错误等等，直到它起作用为止。这种通过反复失败来学习的模式就像用户与程序进行的对话。</p><p>  Running one command to set up a tool and then learning what commands to run to actually start using it.</p><p>  运行一个命令来设置工具，然后学习运行哪些命令才能真正开始使用它。</p><p> Running several commands to set up an operation, and then a final command to run it (e.g. multiple  git adds, followed by a  git commit).</p><p> 运行多个命令以设置操作，然后运行最终命令以运行该操作（例如添加多个git，然后执行git commit）。</p><p> Exploring a system—for example, doing a lot of  cd and  ls to get a sense of a directory structure, or  git log and  git show to explore the history of a file.</p><p> 探索系统-例如，进行大量的cd和ls操作以了解目录结构，或者通过git log和git show探索文件的历史记录。 </p><p> Acknowledging the conversational nature of command-line interaction means you can bring relevant techniques to bear on its design.You can suggest possible corrections when user input is invalid, you can make the intermediate state clear when the user is going through a multi-step process, you can confirm for them that everything looks good before they do something scary.</p><p>承认命令行交互的对话性质意味着您可以运用相关技术来进行设计。当用户输入无效时，您可以提出可能的更正;当用户经过多步过程时，您可以使中间状态清晰可见，您可以为他们确认在一切令人恐惧之前，一切看起来都不错。</p><p> The user is conversing with your software, whether you intended it or not.At worst, it’s a hostile conversation which makes them feel stupid and resentful.At best, it’s a pleasant exchange that speeds them on their way with newfound knowledge and a feeling of achievement.</p><p> 用户正在与您的软件进行交谈，无论您是否打算使用它。成就。</p><p>   Robustness is both an objective and a subjective property.Software should  be robust, of course: unexpected input should be handled gracefully, operations should be idempotent where possible, and so on.But it should also  feel robust.</p><p>   健壮性既是客观的又是主观的属性，软件当然​​应该健壮：应该对意外的输入进行适当的处​​理，在可能的情况下操作应该是幂等的，但是它也应该健壮。</p><p> You want your software to feel like it isn’t going to fall apart.You want it to feel immediate and responsive, as if it were a big mechanical machine, not a flimsy plastic “soft switch.”</p><p> 您希望自己的软件感觉不会崩溃，而是希望它具有立即响应的感觉，就好像它是一台大型机械机器，而不是脆弱的塑料“软开关”一样。</p><p> Subjective robustness requires attention to detail and thinking hard about what can go wrong.It’s lots of little things: keeping the user informed about what’s happening, explaining what common errors mean, not printing scary-looking stack traces.</p><p> 主观的健壮性需要关注细节并认真思考可能出问题的地方。这有很多小事情：让用户了解正在发生的事情，解释常见错误的含义，而不是打印看上去令人恐惧的堆栈跟踪。</p><p> As a general rule, robustness can also come from keeping it simple.Lots of special cases and complex code tend to make a program fragile.</p><p> 一般而言，鲁棒性也可以来自保持简单性的原因。很多特殊情况和复杂的代码会使程序变得脆弱。</p><p>  Command-line tools are a programmer’s creative toolkit, so they should be enjoyable to use.This doesn’t mean turning them into a video game, or using lots of emoji (though there’s nothing inherently wrong with emoji 😉).It means giving the user the feeling that you are on their side, that you want them to succeed, that you have thought carefully about their problems and how to solve them.</p><p>  命令行工具是程序员的创新工具包，因此应易于使用，这并不意味着将其转变为视频游戏或使用大量表情符号（尽管表情符号inherent本质上并没有错），而是意味着用户感觉自己站在他们一边，希望他们成功，您已经仔细考虑了他们的问题以及如何解决它们。 </p><p> There’s no list of actions you can take that will ensure they feel this way, although we hope that following our advice will take you some of the way there.Delighting the user means  exceeding their expectations at every turn, and that starts with empathy.</p><p>虽然我们希望遵循我们的建议会带给您一些帮助，但您没有可以采取的行动清单来确保他们有这种感觉。让用户高兴意味着每时每刻都超出他们的期望，这始于同情。</p><p>  The world of the terminal is a mess.Inconsistencies are everywhere, slowing us down and making us second-guess ourselves.</p><p>  航站楼的世界一团糟，到处都是不一致的地方，这使我们放慢了脚步并让我们自己去猜测。</p><p> Yet it’s undeniable that this chaos has been a source of power.The terminal, like the UNIX-descended computing environment in general, places very few constraints on what you can build.In that space, all manner of invention has bloomed.</p><p> 但是，不可否认的是，这种混乱一直是力量的源泉。与UNIX降级的计算机环境一样，该终端对您可以构建的内容几乎没有任何限制。在这个空间中，各种各样的发明蓬勃发展。</p><p> It’s ironic that this document implores you to follow existing patterns, right alongside advice that contradicts decades of command-line tradition.We’re just as guilty of breaking the rules as anyone.</p><p> 具有讽刺意味的是，本文档劝告您遵循现有模式，并提出与数十年来命令行传统相矛盾的建议。我们与任何人一样都违反规则。</p><p> The time might come when you, too, have to break the rules.Do so with intention and clarity of purpose.</p><p> 也可能是您必须违反规则的时候了，这样做的目的是明确目的。</p><p> “Abandon a standard when it is demonstrably harmful to productivity or user satisfaction.” — Jef Raskin,  The Humane Interface</p><p> “在明显损害生产力或用户满意度的情况下，请放弃该标准。” —人道界面Jef Raskin</p><p>  This is a collection of specific things you can do to make your command-line program better.</p><p>  这是您可以做的一些特定的事情，可以使您的命令行程序更好。 </p><p> The first section contains the essential things you need to follow.Get these wrong, and your program will be either hard to use or a bad CLI citizen.</p><p>第一部分包含您需要遵循的基本内容。弄错这些错误，您的程序将很难使用或成为不良的CLI公民。</p><p> The rest are nice-to-haves.If you have the time and energy to add these things, your program will be a lot better than the average program.</p><p> 其余的都很不错。如果您有时间和精力来添加这些东西，您的程序将比普通程序好很多。</p><p> The idea is that, if you don’t want to think too hard about the design of your program, you don’t have to: just follow these rules and your program will probably be good.On the other hand, if you’ve thought about it and determined that a rule is wrong for your program, that’s fine.(There’s no central authority that will reject your program for not following arbitrary rules.)</p><p> 这样的想法是，如果您不想对程序的设计考虑得太仔细，则不必：遵循这些规则，您的程序可能会很好。考虑一下并确定规则对您的程序是错误的，这很好。（没有中央机构会拒绝您的程序，因为他们不遵循任意规则。</p><p> Also—these rules aren’t written in stone.If you disagree with a general rule for good reason, we hope you’ll  propose a change.</p><p> 此外，这些规则并不是一成不变的。如果您出于充分的理由不同意一般规则，我们希望您可以提出更改。</p><p>  There are a few basic rules you need to follow.Get these wrong, and your program will be either very hard to use, or flat-out broken.</p><p>  您需要遵循一些基本规则。弄错这些规则，您的程序将很难使用，或者被彻底破坏。</p><p> Use a command-line argument parsing library where you can.Either your language’s built-in one, or a good third-party one.They will normally handle arguments, flag parsing, help text, and even spelling suggestions in a sensible way.</p><p> 尽可能使用命令行参数解析库。您的语言是内置的，还是优秀的第三方。它们通常会以合理的方式处理参数，标记解析，帮助文本甚至拼写建议。</p><p>   Return zero exit code on success, non-zero on failure.Exit codes are how scripts determine whether a program succeeded or failed, so you should report this correctly.Map the non-zero exit codes to the most important failure modes.</p><p>   成功返回零退出代码，失败返回非零退出代码是脚本确定程序成功或失败的方式，因此您应正确报告此错误将非零退出代码映射到最重要的失败模式。 </p><p> Send output to  stdout.The primary output for your command should go to  stdout.Anything that is machine readable should also go to  stdout—this is where piping sends things by default.</p><p>将输出发送到stdout。命令的主要输出应该转到stdout。任何机器可读的内容也应该转到stdout，这是管道在默认情况下发送内容的位置。</p><p> Send messaging to  stderr.Log messages, errors, and so on should all be sent to  stderr.This means that when commands are piped together, these messages are displayed to the user and not fed into the next command.</p><p> 将消息发送到stderr.log消息，错误等都应发送到stderr，这意味着将命令通过管道传输时，这些消息将显示给用户，而不是馈入下一个命令。</p><p>   Display a concise help text by default.If you can, display help by default when  myapp or  myapp subcommand is run.Unless your program is very simple and does something obvious by default (e.g.  ls), or your program reads input interactively (e.g.  cat).</p><p>   默认情况下显示简洁的帮助文本。如果可以，则在运行myapp或myapp子命令时默认显示帮助。除非您的程序非常简单且默认情况下很明显（例如ls），或者您的程序以交互方式读取输入（例如cat ）。</p><p>   jq does this well.When you type  jq, it displays an introductory description and an example, then prompts you to pass  jq --help for the full listing of flags:</p><p>   jq做得很好，当您输入jq时，它会显示介绍性描述和示例，然后提示您传递jq --help以获得标志的完整列表：</p><p> $ jqjq - commandline JSON processor [version 1.6]Usage: jq [options] &lt;jq filter&gt; [file...] jq [options] --args &lt;jq filter&gt; [strings...] jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]jq is a tool for processing JSON inputs, applying the given filter toits JSON text inputs and producing the filter&#39;s results as JSON onstandard output.The simplest filter is ., which copies jq&#39;s input to its outputunmodified (except for formatting, but note that IEEE754 is usedfor number representation internally, with all that that implies).For more advanced filters see the jq(1) manpage (&#34;man jq&#34;)and/or https://stedolan.github.io/jqExample: $ echo &#39;{&#34;foo&#34;: 0}&#39; | jq . { &#34;foo&#34;: 0 }For a listing of options, use jq --help.</p><p> $ jqjq-命令行JSON处理器[1.6版]用法：jq [options]＆lt; jq filter＆gt; [file ...] jq [options] --args＆lt; jq filter＆gt; [strings ...] jq [options] --jsonargs＆lt; jq filter＆gt; [JSON_TEXTS ...] jq是用于处理JSON输入，将给定过滤器应用于其JSON文本输入并以标准输出上的JSON形式生成过滤器结果的工具。最简单的过滤器是。，它会复制jq输入到其输出的输入未修改（格式设置除外，但请注意，IEEE754用于内部数字表示，这意味着所有含义）有关更高级的过滤器，请参见jq（1）联机帮助页（＆＃34; man jq＆＃34;）和/或https://stedolan.github.io/jq示例：$ echo＆＃39; {＆＃34; foo＆＃34 ;: 0}＆＃39; | jq。 {＆＃34; foo＆＃34 ;: 0}有关选项列表，请使用jq --help。</p><p>   Ignore any other flags and arguments that are passed—you should be able to add  -h to the end of anything and it should show help.Don’t overload  -h.</p><p>   忽略传递的任何其他标志和参数，您应该可以在任何内容的末尾添加-h，并且应该显示帮助。请勿重载-h。</p><p>   Provide a support path for feedback and issues.A website or GitHub link in the top-level help text is common.</p><p>   提供反馈和问题的支持途径。顶层帮助文本中的网站或GitHub链接很常见。 </p><p> In help text, link to the web version of the documentation.If you have a specific page or anchor for a subcommand, link directly to that.This is particularly useful if there is more detailed documentation on the web, or further reading that might explain the behavior of something.</p><p>在帮助文本中，链接到文档的Web版本。如果您有子页面的特定页面或锚点，则直接链接到该文档。如果Web上有更详细的文档或可能引起进一步阅读的更多阅读资料，则特别有用。某物的行为。</p><p> Lead with examples.Users tend to use examples over other forms of documentation, so show them first in the help page, particularly the common complex uses.If it helps explain what it’s doing and it isn’t too long, show the actual output too.</p><p> 以示例为先。用户倾向于在其他形式的文档上使用示例，因此请在帮助页面上首先显示它们，尤其是常见的复杂用法。如果它有助于解释其作用并且时间不长，也请显示实际输出。</p><p> You can tell a story with a series of examples, building your way toward complex uses.</p><p> 您可以通过一系列示例来讲述一个故事，为复杂的使用打下基础。</p><p> If you’ve got loads of examples, put them somewhere else, in a cheat sheet command or a web page.It’s useful to have exhaustive, advanced examples, but you don’t want to make your help text really long.</p><p> 如果您有大量的示例，请将它们放在备忘单命令或网页中的其他位置。拥有详尽的高级示例很有用，但您不想使帮助文本过长。</p><p> For more complex use cases, e.g. when integrating with another tool, it might be appropriate to write a fully-fledged tutorial.</p><p> 对于更复杂的用例，例如与其他工具集成时，可能需要编写完整的教程。</p><p> Don’t bother with man pages.We believe that if you’re following these guidelines for help and documentation, you won’t need man pages.Not enough people use man pages, and they don’t work on Windows.If your CLI framework and package manager make it easy to output man pages, go for it, but otherwise your time is best spent improving web docs and built-in help text.</p><p> 不要担心手册页。我们相信，如果您遵循这些指南来获取帮助和文档，则不需要手册页。没有足够的人使用手册页，并且它们无法在Windows上运行。框架和软件包管理器使输出手册页变得容易，但是，否则您最好花费时间来改进Web文档和内置帮助文本。</p><p>  If your help text is long, pipe it through a pager.This is one useful thing that  man does for you.See the advice in the “Output” section below.</p><p>  如果您的帮助文本很长，请将其通过寻呼机传送。这是男人为您做的一件有用的事情。请参见下面“输出”部分中的建议。 </p><p> Display the most common flags and commands at the start of the help text.It’s fine to have lots of flags, but if you’ve got some really common ones, display them first.For example, the Git command displays the commands for getting started and the most commonly used subcommands first:</p><p>在帮助文本的开头显示最常见的标志和命令。有很多标志是可以的，但是如果您有一些真正的标志，请先显示它们。例如，Git命令显示了开始使用的命令首先是最常用的子命令：</p><p> $ gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status…</p><p> $ gitusage：git [--version] [--help] [-C＆lt; path＆gt;] [-c＆lt; name＆gt; =＆lt; value＆gt;] [--exec-path [=＆lt; path＆gt;]] [ --html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir =＆lt; path＆gt;] [--work-tree =＆lt; path＆gt;] [--namespace =＆lt; ; name＆gt;]＆lt; command＆gt; [＆lt; args＆gt;]这些是在各种情况下使用的常见Git命令：启动工作区（另请参阅：git帮助教程）将存储库克隆到新目录中init创建一个空的Git存储库或在当前目录上重新初始化现有的onework更改（另请参阅：每天都有git help）添加将文件内容添加到索引mv移动或重命名文件，目录或符号链接重置将当前HEAD重置为指定状态rm从工作树和索引中删除文件检查历史记录和状态（另请参见：git help修订版）bisect使用二进制搜索查找引入了错误grep的提交打印与模式日志匹配的行显示提交日志显示显示各种对象状态显示工作树状态…</p><p> Use formatting in your help text.Bold headings make it much easier to scan.But, try to do it in a terminal-independent way so that your users aren’t staring down a wall of escape characters.</p><p> 在帮助文本中使用格式。加粗的标题使扫描更加容易。但是，请尝试以不依赖终端的方式进行操作，以免用户盯着转义字符。</p><p> $ heroku apps --helplist your </p><p> $ heroku应用程序-帮助列出您的</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://clig.dev/">https://clig.dev/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指南/">#指南</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1037752.html"><img src="http://img2.diglog.com/img/2020/12/thumb_ed6c62e094a7b50948a1196dc39a0b69.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037752.html">PrimaHealth Credit为选修程序提供即买即付的贷款服务 </a></div><span class="my_story_list_date">2020-12-5 2:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037717.html"><img src="http://img2.diglog.com/img/2020/12/thumb_0f6e752d49e77a75fa4e2c66cf0a7b27.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037717.html">Apple的Screen Recognition是iOS14中的计算机视觉系统，对正在使用的应用程序的图像进行了培训，为盲人用户在屏幕上标记了UI元素 </a></div><span class="my_story_list_date">2020-12-4 22:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037653.html"><img src="http://img2.diglog.com/img/2020/12/thumb_d0937328db7d8211ee116ded6f5cc9c8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037653.html">Twitter最终关闭了其废弃的原型应用程序twttr </a></div><span class="my_story_list_date">2020-12-4 22:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037571.html"><img src="http://img2.diglog.com/img/2020/12/thumb_260bba24c87eda3240d493743c4f779d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037571.html">如果开发人员在他们的应用程序中启用了该选项，则用户现在可以通过Apple的iCloud家庭共享来共享应用程序内购买和订阅 </a></div><span class="my_story_list_date">2020-12-4 21:18</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>