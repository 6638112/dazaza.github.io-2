<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>面向对象编程的风格(在JavaScript中)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">面向对象编程的风格(在JavaScript中)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 06:51:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/36d7c19887832012907f512c7956845c.png"><img src="http://img2.diglog.com/img/2020/11/36d7c19887832012907f512c7956845c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In my research, I’ve found there are four approaches to Object-Oriented Programming in JavaScript:</p><p>在我的研究中，我发现在JavaScript中有四种面向对象编程的方法：</p><p>  Which methods should I use? Which one is “the best” way? Here I’ll present my findings along with information that may help you decide which is right for you.</p><p>我应该使用哪些方法？哪一种是“最好的”方式？在这里，我将介绍我的发现和一些信息，这些信息可能会帮助你决定哪一种是适合你的。</p><p> To make that decision, we’re not just going to look at the different flavors but compare conceptual aspects between them:</p><p>为了做出这个决定，我们不仅要看不同的口味，而且要比较它们之间的概念方面：</p><p>    Object-Oriented Programming is a way of writing code that allows you to create different objects from a common object. The common object is usually called a  blueprint while the created objects are called  instances.</p><p>面向对象编程是一种编写代码的方式，它允许您从一个公共对象创建不同的对象。公共对象通常被称为蓝图，而创建的对象被称为实例。</p><p> Each instance has properties that are not shared with other instances. For example, if you have a Human blueprint, you can create human instances with different names.</p><p>每个实例都具有不与其他实例共享的属性。例如，如果您有一个人工蓝图，则可以创建具有不同名称的人工实例。</p><p> The second aspect of Object-Oriented Programming is about  structuring code when you have multiple levels of blueprints. This is commonly called Inheritance or subclassing.</p><p>当您有多层蓝图时，面向对象编程的第二个方面是关于构建代码。这通常称为继承或子类化。</p><p> The third aspect of Object Oriented Programming is about  encapsulation where you hide certain pieces of information within the object so they’re not accessible.</p><p>面向对象编程的第三个方面是关于封装，即将某些信息隐藏在对象中以使其不可访问。</p><p> If you need more than this brief intro,  here’s an article that introduces this aspect of Object-Oriented Programming if you need help with it.</p><p>如果您需要的不仅仅是这篇简短的介绍，如果您需要帮助，这里有一篇文章介绍了面向对象编程的这一方面。</p><p> Let’s begin with the basics — an introduction to the four flavors of Object-Oriented Programming.</p><p>让我们从基础开始--介绍面向对象编程的四种风格。</p><p>       this lets you store (and access) unique values created for each instance. You can create an instance with the  new keyword.</p><p>这使您可以存储(和访问)为每个实例创建的唯一值。您可以使用new关键字创建实例。</p><p> const chris = new Human(&#39;Chris&#39;, &#39;Coyier&#39;)console.log(chris.firstName) // Chrisconsole.log(chris.lastName) // Coyierconst zell = new Human(&#39;Zell&#39;, &#39;Liew&#39;)console.log(zell.firstName) // Zellconsole.log(zell.lastName) // Liew</p><p>Const Chris=new Human(&#39；Chris&39；，&#39；Coyier&39；)console.log(chris.firstName)//Chrisconsole.log(chris.lastName)//Coyi erconst Zell=new Human(&#39；Zell&39；，&#39；Liew&39；)console.log(zell.firstName)//Zellconsole.log(zell.lastName)//Liew。</p><p>  Classes are said to be the “syntactic sugar” of Constructor functions. As in, Classes are an easier way of writing Constructor functions.</p><p>类被认为是构造函数的“语法糖”。与中一样，类是编写构造函数的一种更简单的方法。</p><p> There’s serious contention about whether Classes are bad (like  this and  this). We’re not going to dive into those arguments here. Instead, we’re just going to look at how to write code with Classes and decide whether Classes are better than constructors based on the code we write.</p><p>关于课程是否不好(像这样和这样)，存在着严重的争论。我们不打算在这里深入讨论这些争论。相反，我们只会看看如何用类编写代码，并根据我们编写的代码来决定类是否比构造函数更好。</p><p>   Notice the  constructor function contains the same code as the Constructor syntax above? We need to do this since we want to initialize values into  this. (We can skip  constructor if we don’t need to initialize values. More on this later under  Inheritance).</p><p>注意到构造函数包含的代码与上面的构造函数语法相同吗？我们需要这样做，因为我们想要将值初始化为这个。(如果不需要初始化值，我们可以跳过构造函数。(稍后在继承一节中有更多关于这方面的内容)。</p><p> At first glance, classes seem to be inferior to constructors — there’s more code to write! Hold your horses and don’t form a conclusion at this point. We have a lot more to cover. Classes begin to shine later.</p><p>乍一看，类似乎不如构造函数--有更多的代码需要编写！别着急，不要在这一点上下结论。我们还有很多东西要讲。晚些时候，课堂开始闪耀光芒。</p><p>    OLOO was coined and popularized by  Kyle Simpson. In OLOO, you define the blueprint as a normal object. You then use a method (often named  init, but that isn’t required in the way  constructor is to a Class) to initialize the instance.</p><p>Oloo是由凯尔·辛普森(Kyle Simpson)创造并普及的。在Oloo中，您可以将蓝图定义为普通对象。然后使用一个方法(通常命名为init，但这不是构造函数对Class的要求)来初始化实例。</p><p> const Human = { init (firstName, lastName ) { this.firstName = firstName this.lastName = lastName }}</p><p>Const Human={init(FirstName，LastName){this.firstName=FirstName this.lastName=LastName}}。</p><p> You use  Object.create to create an instance. After creating the instance, you need to run your  init function.</p><p>您可以使用Object.Create来创建实例。创建实例后，需要运行init函数。</p><p>   const Human = { init () { // ... return this }}const chris = Object.create(Human).init(&#39;Chris&#39;, &#39;Coyier&#39;)console.log(chris.firstName) // Chrisconsole.log(chris.lastName) // Coyier</p><p>Const Human={init(){//...。Return this}}const Chris=Object.create(Human).init(&#39；Chris&#39；，&#39；Coyier&#39；)console.log(chris.firstName)//Chrisconsole.log(chris.lastName)//Coyier。</p><p>  Factory functions are functions that return an object. You can return any object. You can even return a Class instance or OLOO instance — and it’ll still be a valid Factory function.</p><p>工厂函数是返回对象的函数。您可以返回任何对象。您甚至可以返回一个Class实例或Oloo实例--它仍然是一个有效的Factory函数。</p><p>   You don’t need  new to create instances with Factory functions. You simply call the function.</p><p>使用Factory函数创建实例不需要新功能。您只需调用该函数即可。</p><p>  Now that we’ve seen these four OOP setup possibilities, let’s look at how you declare properties and methods on each of them so we can get a little better understanding of working with them before getting to the bigger comparisons we’re trying to make.</p><p>既然我们已经看到了这四种OOP设置的可能性，让我们看看如何在每一种上声明属性和方法，以便在进行更大的比较之前能够更好地理解如何使用它们。</p><p>         If you want to declare a property directly on an instance, you can write the property inside the constructor function. Make sure to set it as the property for  this.</p><p>如果要直接在实例上声明属性，可以在构造函数内编写该属性。确保将其设置为此的属性。</p><p> function Human (firstName, lastName) { // Declares properties this.firstName = firstName this.lastname = lastName // Declares methods this.sayHello = function () { console.log(`Hello, I&#39;m ${firstName}`) }}const chris = new Human(&#39;Chris&#39;, &#39;Coyier&#39;)console.log(chris)</p><p>Function Human(FirstName，LastName){//声明属性this.firstName=FirstName this.lastname=lastName//声明方法this.sayHello=Function(){console.log(`Hello，I&#39；m${FirstName}`)}}const Chris=new Human(&#39；Chris&39；，&#39；Coyier&#39；)console.log(Chris)</p><p>  Methods are commonly declared on the Prototype because Prototype allows instances to use the same method. It’s a smaller “code footprint.”</p><p>方法通常在原型上声明，因为原型允许实例使用相同的方法。这是一个更小的“代码足迹”。</p><p>  function Human (firstName, lastName) { this.firstName = firstName this.lastname = lastName}// Declaring method on a prototypeHuman.prototype.sayHello = function () { console.log(`Hello, I&#39;m ${this.firstName}`)}</p><p>函数Human(FirstName，LastName){this.firstName=firstName this.lastname=lastName}//在协议typeHuman.Prototype.sayHello=Function(){console.log(`Hello，i&#39；m${this.firstName}`)上声明方法}。</p><p>   // Declaring methods on a prototypeHuman.prototype.method1 = function () { /*...*/ }Human.prototype.method2 = function () { /*...*/ }Human.prototype.method3 = function () { /*...*/ }</p><p>//在PrototypeHuman.Prototype.Method1=Function(){/*...*/}Human.Prototype.Meth2=Function(){/*...*/}Human.Prototype.Meth3=Function(){/*...*/}上声明方法。</p><p>  Object.assign(Human.prototype, { method1 () { /*...*/ }, method2 () { /*...*/ }, method3 () { /*...*/ }})</p><p>Object.Assignment(Human.Prototype，{Method1(){/*...*/}，Method 2(){/*...*/}，Method 3(){/*...*/}})。</p><p> Object.assign does not support the merging of Getter and Setter functions. You need another tool.  Here’s why. And here’s  a tool I created to merge objects with Getters and Setters.</p><p>Object.Assign不支持合并getter和Setter函数。你需要另一个工具。原因如下。这是我创建的一个工具，用于将对象与getter和setter合并。</p><p>   class Human { constructor (firstName, lastName) { this.firstName = firstName this.lastname = lastName this.sayHello = function () { console.log(`Hello, I&#39;m ${firstName}`) } }}</p><p>类Human{构造函数(FirstName，LastName){this.firstName=FirstName this.lastname=lastName this.sayHello=Function(){console.log(`Hello，I&#39；m${FirstName}`)}}。</p><p>  It’s easier to declare methods on the prototype. You write the method after  constructor like a normal function.</p><p>在原型上声明方法更容易。像普通函数一样，在构造函数之后编写方法。</p><p> class Human (firstName, lastName) { constructor (firstName, lastName) { /* ... */ } sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) }}</p><p>类Human(FirstName，LastName){构造函数(FirstName，LastName){/*...*/}sayHello(){console.log(`Hello，I&#39；m${this.firstName}`)}}</p><p>  It’s easier to declare multiple methods on Classes compared to Constructors. You don’t need the  Object.assign syntax. You just write more functions.</p><p>与构造函数相比，在类上声明多个方法更容易。您不需要Object.Assign语法。您只需编写更多的函数即可。</p><p>  class Human (firstName, lastName) { constructor (firstName, lastName) { /* ... */ } method1 () { /*...*/ } method2 () { /*...*/ } method3 () { /*...*/ }}</p><p>类Human(名字，姓氏){构造函数(名字，姓氏){/*...*/}方法1(){/*...*/}方法2(){/*...*/}方法3(){/*...*/}}。</p><p>  You use the same process for declaring properties and methods on an instance. You assign them as a property of  this.</p><p>您可以使用相同的过程声明实例上的属性和方法。您将它们指定为此属性的一部分。</p><p> const Human = { init (firstName, lastName) { this.firstName = firstName this.lastName = lastName this.sayHello = function () { console.log(`Hello, I&#39;m ${firstName}`) } return this }}const chris = Object.create(Human).init(&#39;Chris&#39;, &#39;Coyier&#39;)console.log(chris)</p><p>Const Human={init(FirstName，LastName){this.firstName=FirstName this.sayHello=Function(){console.log(`Hello，I&#39；m${FirstName}`)}return this}}const Chris=Object.create(Human).init(&#39；Chris&#39；，&#39；Coyier&#39；)console.log(Chris)。</p><p>   const Human = { init () { /*...*/ }, sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) }}</p><p>Const Human={init(){/*...*/}，sayHello(){console.log(`Hello，I&#39；m${this.firstName}`)}}。</p><p>    function Human (firstName, lastName) { return { firstName, lastName, sayHello () { console.log(`Hello, I&#39;m ${firstName}`) } }}</p><p>函数Human(FirstName，LastName){return{FirstName，lastName，sayHello(){console.log(`Hello，I&#39；m${FirstName}`)}}。</p><p>  You cannot declare methods on the Prototype when you use Factory functions. If you really want methods on the prototype, you need to return a Constructor, Class, or OLOO instance. (Don’t do this since it doesn’t make any sense.)</p><p>使用工厂函数时，不能在原型上声明方法。如果您确实需要原型上的方法，则需要返回构造函数、类或Oloo实例。(不要这样做，因为这没有任何意义。)。</p><p>   Should you declare properties and methods directly on the instance? Or should you use  prototype as much as you can?</p><p>是否应该直接在实例上声明属性和方法？还是应该尽可能多地使用Prototype？</p><p> Many people take pride that JavaScript is a “Prototypal Language” (which means it uses prototypes). From this statement, you may make the assumption that using “Prototypes” is better.</p><p>许多人引以为豪的是，JavaScript是一种“原型语言”(这意味着它使用原型)。从这句话中，你可以假设使用“原型”更好。</p><p>  If you declare properties and methods on instances, each instance will take up slightly more memory. If you declare methods on Prototypes, the memory used by each instance will decrease, but not much. This difference is insignificant with computer processing power what it is today. Instead, you want to look at how easy it is to write code — and whether it is possible to use Prototypes in the first place.</p><p>如果在实例上声明属性和方法，每个实例将占用更多的内存。如果在原型上声明方法，每个实例使用的内存将会减少，但不会太多。与今天的计算机处理能力相比，这种差异微不足道。相反，您想看看编写代码有多容易--以及是否有可能首先使用原型。</p><p> For example, if you use Classes or OLOO, you’ll be better off using Prototypes since the code is easier to write. If you use Factory functions, you cannot use Prototypes. You can only create properties and methods directly on the instance.</p><p>例如，如果您使用类或Oloo，那么使用原型会更好，因为代码更容易编写。如果使用Factory功能，则不能使用原型。您只能直接在实例上创建属性和方法。</p><p> I wrote a separate article on  understanding JavaScript Prototypes if you’re interested in finding out more.</p><p>如果您有兴趣了解更多，我另外写了一篇关于理解JavaScript原型的文章。</p><p>  We can make a few notes from the code we wrote above. These opinions are my own!</p><p>我们可以从上面编写的代码中做一些注释。这些都是我自己的观点！</p><p> OLOO is weird because of the  Object.create part. I gave OLOO a run for a while, but I always forget to write  Object.create. It’s weird enough for me not to use it.</p><p>Oloo很奇怪，因为Object.Create部件。我让Oloo试了一段时间，但我总是忘记写Object.Create。对我来说不用它已经够奇怪的了。</p><p> Classes and Factry Functions are easiest to use. The problem is that Factory functions don’t support Prototypes. But like I said, this doesn’t really matter in production.</p><p>类和Factry函数最易于使用。问题是工厂函数不支持原型。但就像我说的，这在生产中并不重要。</p><p> We’re down to two. Should we choose Classes or Factory functions then? Let’s compare them!</p><p>我们只剩下两个人了。那么我们应该选择类还是工厂函数呢？让我们来比较一下！</p><p>   To continue the discussion on Classes and Factory functions, we need to understand three more concepts that are tied closely to Object-Oriented Programming.</p><p>要继续讨论类和工厂函数，我们需要理解另外三个与面向对象编程密切相关的概念。</p><p>    Inheritance is a loaded word. Many people in the industry use Inheritance incorrectly, in my opinion. The word “inheritance” is used when you receive things from somewhere. For example:</p><p>继承是一个不堪重负的词。在我看来，这个行业的很多人都错误地使用了遗产。当你从某个地方收到东西时，会用到“继承”这个词。例如：</p><p> If you get an inheritance from your parents, it means you get money and assets from them.</p><p>如果你从父母那里继承了遗产，那就意味着你从他们那里得到了钱和资产。</p><p> If you inherit genes from your parents, it means you get your genes from them.</p><p>如果你从父母那里继承了基因，那就意味着你的基因是从他们那里遗传来的。</p><p> If you inherit a process from your teacher, it means you get that process from them.</p><p>如果你从老师那里继承了一个过程，那就意味着你从他们那里得到了这个过程。</p><p>  In JavaScript, Inheritance can mean the same thing: where you get properties and methods from the parent blueprint.</p><p>在JavaScript中，继承意味着同样的事情：从父蓝图获取属性和方法。</p><p> This means  all instances actually inherit from their blueprints. They inherit properties and methods in two ways:</p><p>这意味着所有实例实际上都继承了它们的蓝图。它们以两种方式继承属性和方法：</p><p>  We discussed how to do both methods in the  previous article so refer back to it if you need help seeing these processes in code.</p><p>我们在上一篇文章中讨论了如何使用这两种方法，因此如果您需要在代码中查看这些过程的帮助，请参考本文。</p><p> There’s a  second meaning for Inheritance in JavaScript — where you create a derivative blueprint from the parent blueprint. This process is more accurately called  Subclassing, but people sometimes will call this Inheritance as well.</p><p>在JavaScript中继承还有另一个含义--从父蓝图创建派生蓝图。这个过程更准确地称为子类化，但人们有时也会将其称为继承。</p><p>  Subclassing is about creating a derivative blueprint from a common blueprint. You can use any Object-Oriented Programming flavor to create the Subclass.</p><p>子类化是关于从公共蓝图创建派生蓝图。您可以使用任何面向对象的编程风格来创建子类。</p><p> We’ll talk about this with the Class syntax first because it’s easier to understand.</p><p>我们将首先用Class语法来讨论这一点，因为它更容易理解。</p><p>    For example, let’s say we want to create a  Developer class from a  Human class.</p><p>例如，假设我们想要从Human类创建一个Developer类。</p><p> // Human Classclass Human { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName } sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) }}</p><p>//Human Classclass Human{构造函数(FirstName，LastName){this.firstName=FirstName this.lastName=lastName}sayHello(){console.log(`Hello，i&#39；m${this.firstName}`)}}。</p><p>  class Developer extends Human { constructor(firstName, lastName) { super(firstName, lastName) } // Add other methods}</p><p>类开发人员扩展Human{Construction tor(FirstName，LastName){Super(FirstName，LastName)}//添加其他方法}。</p><p> Note:  super calls the  Human (also called the “parent”) Class. It initiates the  constructor from  Human. If you don’t need extra initiation code, you can omit  constructor entirely.</p><p>注：Super调用Human(也称为“Parent”)类。它从Human启动构造函数。如果不需要额外的启动代码，可以完全省略构造函数。</p><p>  Let’s say a  Developer can code. We can add the  code method directly to  Developer.</p><p>让我们假设开发人员可以编写代码。我们可以将代码方法直接添加到开发人员。</p><p>         function Subclass (...args) { const instance = ParentClass(...args) return Object.assign({}, instance, { // Properties and methods go here })}</p><p>函数子类(...args){const Instance=ParentClass(...args)return Object.Assign({}，Instance，{//Properties and Methods Go Here})}。</p><p> We’ll use the same example — creating a  Developer Subclass — to illustrate this process. Here’s the  Human factory function:</p><p>我们将使用相同的例子--创建一个Developer子类--来说明这个过程。以下是人类工厂的功能：</p><p> function Human (firstName, lastName) { return { firstName, lastName, sayHello () { console.log(`Hello, I&#39;m ${firstName}`) } }}</p><p>函数Human(FirstName，LastName){return{FirstName，lastName，sayHello(){console.log(`Hello，I&#39；m${FirstName}`)}}。</p><p>  function Developer (firstName, lastName) { const human = Human(firstName, lastName) return Object.assign({}, human, { // Properties and methods go here })}</p><p>Function Developer(FirstName，LastName){const Human=Human(FirstName，LastName)return Object.Assign({}，Human，{//Properties and Methods Go Here}))}。</p><p>  function Developer (firstName, lastName) { const human = Human(firstName, lastName) return Object.assign({}, human, { code (thing) { console.log(`${this.firstName} coded ${thing}`) } })}</p><p>Function Developer(FirstName，LastName){const Human=Human(FirstName，LastName)return Object.Assign({}，Human，{code(Thing){console.log(`${this.firstName}code${thing}`)})}。</p><p>    Note: You cannot use  Object.assign if you use Getters and Setters. You’ll need another tool, like   mix. I explain why in  this article.</p><p>注意：如果使用getters和setters，则不能使用Object.Assign。你需要另一个工具，比如Mix。我在这篇文章中解释了其中的原因。</p><p>  Sometimes you need to overwrite the Parent’s method inside the Subclass. You can do this by:</p><p>有时，您需要在子类中覆盖父对象的方法。您可以通过以下方式完成此操作：</p><p>   class Developer extends Human { sayHello () { // Calls the parent method super.sayHello() // Additional stuff to run console.log(`I&#39;m a developer.`) }}const chris = new Developer(&#39;Chris&#39;, &#39;Coyier&#39;)chris.sayHello()</p><p>类Developer扩展Human{sayHello(){//调用父方法Super.sayHello()//运行console.log(`i&#39；m a developer.`)}}const Chris=new Developer(&#39；Chris&39；，&#39；Coyier&#39；)chris.sayHello()</p><p>   function Developer (firstName, lastName) { const human = Human(firstName, lastName) return Object.assign({}, human, { sayHello () { // Calls the parent method human.sayHello() // Additional stuff to run console.log(`I&#39;m a developer.`) } })}const chris = new Developer(&#39;Chris&#39;, &#39;Coyier&#39;)chris.sayHello()</p><p>Function Developer(FirstName，LastName){const Human=Human(FirstName，LastName)return Object.Assign({}，Human，{sayHello(){//调用父方法Human.sayHello()//运行console.log(`i&#39；m a Developer.`)}})}const Chris=new Developer(&#39；Chris&39；，&#39；Coyier&#39；)chris.sayHello()。</p><p>   No talk about Inheritance ever concludes without the mention of Composition. Experts like  Eric Elliot often suggests we should favor  Composition over Inheritance.</p><p>任何关于继承的讨论都会在结束时不提及组合。埃里克·埃利奥特(Eric Elliot)等专家经常建议，我们应该更喜欢合成而不是继承。</p><p> “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”</p><p>“比起类继承，更喜欢对象组合”，“四人帮”，“设计模式：可重用面向对象软件的元素”</p><p> “In computer science, a composite data type or compound data type is any data type which can be constructed in a program using the programming language’s primitive data types and other composite types. […] The act of constructing a composite type is known as composition.” ~ Wikipedia</p><p>在计算机科学中，复合数据类型或复合数据类型是可以在程序中使用编程语言的原始数据类型和其他复合类型构造的任何数据类型。[…]。构造复合类型的行为称为复合。“~维基百科。</p><p>   Composition is the act of combining two things into one. It’s about merging things together. The most common (and simplest) way of merging objects is with  Object.assign.</p><p>作文就是把两样东西组合成一件东西的行为。它是关于将事物融合在一起。合并对象的最常见(也是最简单)方法是使用Object.Assignment。</p><p> const one = { one: &#39;one&#39; }const two = { two: &#39;two&#39; }const combined = Object.assign({}, one, two)</p><p>常量一={一；一}常量二={二：#；二；}常量组合=对象.分配({}，一，二)。</p><p> The use of Composition can be better explained with an example. Let’s say we already have two Subclasses, a  Designer and  Developer. Designers can design, while developers can code. Both designers and developers inherit from the  Human class.</p><p>用一个例子可以更好地解释作文的用法。假设我们已经有两个子类，一个是Designer，一个是Developer。设计人员可以设计，而开发人员可以编写代码。设计者和开发人员都继承了Human类。</p><p>  class Human { constructor(firstName, lastName) { this.firstName = firstName this.lastName = lastName } sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) }}class Designer extends Human { design (thing) { console.log(`${this.firstName} designed ${thing}`) }}class Developer extends Designer { code (thing) { console.log(`${this.firstName} coded ${thing}`) }}</p><p>类Human{structor(firstName，lastName){this.firstName=firstName this.lastName=lastName}sayHello(){console.log(`Hello，i&#39；m${this.firstName}`)}}类设计器扩展Human{Design(Thing){console.log(`${this.firstName}Design${thing}`)}}类开发人员扩展Designer{code(Thing){console.log(`${this.firstName}Design${thing}`)}</p><p> Now let’s say you want to create a third Subclass. This Subclass is a mix of a Designer and a Developer — they can design and code. Let’s call it  DesignerDeveloper (or  DeveloperDesigner, whichever you fancy).</p><p>现在假设您想要创建第三个子类。这个子类是设计人员和开发人员的混合体--他们可以设计和编写代码。我们称它为DesignerDeveloper(或者DeveloperDesigner，随便你喜欢)。</p><p>  We cannot extend  Designer and  Developer classes at the same time. This is impossible because we cannot decide which properties come first. This is often called The Diamond Problem.</p><p>我们不能同时扩展设计器类和开发人员类。这是不可能的，因为我们无法决定哪些房产优先。这通常被称为钻石问题。</p><p>  The Diamond Problem can be easily solved if we do something like  Object.assign – where we prioritize one object over the other. If we use the  Object.assign approach, we may be able to extend classes like this. But this is not supported in JavaScript.</p><p>如果我们做一些像Object.Assignment这样的事情，钻石问题可以很容易地解决--在这种情况下，我们将一个对象优先于另一个对象。如果我们使用Object.Assign方法，我们也许能够像这样扩展类。但这在JavaScript中不受支持。</p><p>   Composition says: Instead of trying to create  DesignerDeveloper via Subclassing, let’s create a new object that stores common features. We can then include these features whenever necessary.</p><p>合成说：与其试图通过子类化来创建DesignerDeveloper，不如创建一个存储公共特性的新对象。然后，我们可以在必要时包括这些功能。</p><p>  const skills = { code (thing) { /* ... */ }, design (thing) { /* ... */ }, sayHello () { /* ... */ }}</p><p>常量技能={code(Thing){/*...*/}，Design(Thing){/*...*/}，sayHello(){/*...*/}}。</p><p> We can then skip  Human altogether and create three different classes based on their skills.</p><p>然后我们可以完全跳过人类，根据他们的技能创建三个不同的职业。</p><p>  class DesignerDeveloper { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName Object.assign(this, { code: skills.code, design: skills.design, sayHello: skills.sayHello }) }}const chris = new DesignerDeveloper(&#39;Chris&#39;, &#39;Coyier&#39;)console.log(chris)</p><p>Class DesignerDeveloper{structor(FirstName，lastName){this.firstName=firstName this.lastName=lastName Object.Assign(this，{code：skills.code，Design：skills.Design，sayHello：skills.sayHello})}}const Chris=new DesignerDeveloper(&#39；Chris&39；，&#39；Coyier&#39；)console.log(Chris)。</p><p>   class Designer { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName Object.assign(this, { design: skills.design, sayHello: skills.sayHello }) }}class Developer { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName Object.assign(this, { code: skills.code, sayHello: skills.sayHello }) }}</p><p>类设计器{构造函数(FirstName，LastName){this.firstName=FirstName this.lastName=LastName Object.Assign(this，{Design：skills.Design，sayHello：skills.sayHello})}}类开发者{构造函数(FirstName，LastName){this.firstName=FirstName this.lastName=LastName Object.Assign(this，{code：skills.code，sayHello：skills.sAssign</p><p> Did you notice we’re creating methods directly on the instance? This is just one option. We can still put methods into the Prototype, but I think the code looks clunky. (It’s as if we’re writing Constructor functions all over again.)</p><p>您注意到我们直接在实例上创建方法了吗？这只是一种选择。我们仍然可以将方法放入原型中，但我认为代码看起来很笨重。(这就好像我们在重新编写构造函数。)。</p><p> class DesignerDeveloper { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName }}Object.assign(DesignerDeveloper.prototype, { code: skills.code, design: skills.design, sayHello: skills.sayHello})</p><p>Class DesignerDeveloper{Construction tor(FirstName，LastName){this.firstName=FirstName this.lastName=lastName}}Object.Assign(DesignerDeveloper.type，{code：skills.code，Design：skills.Design，sayHello：skills.sayHello})。</p><p>  Feel free to use whatever code structure you’re attracted to. The results are kinda the same anyway.</p><p>您可以随意使用您感兴趣的任何代码结构。不管怎么说，结果都差不多。</p><p>   function DesignerDeveloper (firstName, lastName) { return { firstName, lastName, code: skills.code, design: skills.design, sayHello: skills.sayHello }}</p><p>Function DesignerDeveloper(FirstName，LastName){return{FirstName，LastName，code：skills.code，Design：skills.Design，sayHello：skills.sayHello}}。</p><p>   Nobody says we can’t use Inheritance and Composition at the same time. We can!</p><p>没有人说我们不能同时使用继承和组合。我们可以的!。</p><p> Using the example we’ve ironed out so far,  Designer,  Developer, and  DesignerDeveloper  Humans are still humans. They can extend the  Human object.</p><p>使用我们到目前为止已经解决的例子，设计师、开发人员和DesignerDeveloper人类仍然是人类。他们可以延伸人类物体。</p><p> Here’s an example where we use both inheritance and composition with the class syntax.</p><p>下面是一个示例，其中我们在类语法中同时使用继承和组合。</p><p> class Human { constructor (firstName, lastName) { this.firstName = firstName this.lastName = lastName } sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) }}class DesignerDeveloper extends Human {}Object.assign(DesignerDeveloper.prototype, { code: skills.code, design: skills.design})</p><p>类Human{structor(FirstName，LastName){this.firstName=firstName this.lastName=lastName}sayHello(){console.log(`Hello，i&#39；m${this.firstName}`)}}class DesignerDeveloper扩展Human{}Object.Assign(DesignerDeveloper.Prototype，{code：skills.code，Design：skills.Design})</p><p>   function Human (firstName, lastName) { return { firstName, lastName, sayHello () { console.log(`Hello, I&#39;m ${this.firstName}`) } }}function DesignerDeveloper (firstName, lastName) { const human = Human(firstName, lastName) return Object.assign({}, human, { code: skills.code, design: skills.design }}</p><p>函数Human(FirstName，LastName){return{FirstName，LastName，sayHello(){console.log(`Hello，I&#39；m${this.firstName}`)}函数DesignerDeveloper(FirstName，LastName){const Human=Human(FirstName，LastName)return Object.Assign({}，Human，{code：skills.code，Design：skills.Design})}。</p><p>   One final point about Subclassing vs. Composition. Even though experts have pointed out that Composition is more flexible (and hence more useful), Subclassing still has its merits. Many things we use today are built with the Subclassing strategy.</p><p>关于子类化与作文的最后一点。尽管专家指出作文更灵活(因此也更有用)，子类化仍有其优点。我们今天使用的许多东西都是用子类化策略构建的。</p><p> For example: The  click event we know and love is a  MouseEvent.  MouseEvent is a Subclass of a  UIEvent, which in turn is a Subclass of  Event.</p><p>例如：我们所知道和喜爱的点击事件就是鼠标事件(MouseEvent)。MouseEvent是UIEEvent的子类，而UIEEvent又是Event的子类。</p><p>  Another example: HTML Elements are Subclasses of Nodes. That’s why they can use all properties and methods of Nodes.</p><p>另一个例子：HTML元素是节点的子类。这就是为什么它们可以使用节点的所有属性和方法。</p><p>   Classes and Factory functions can both use Inheritance and Composition. Composition seems to be cleaner in Factory functions though, but that’s not a big win over Classes.</p><p>类和工厂函数都可以使用继承和组合。虽然工厂函数中的组合看起来更干净，但这并不比类有多大优势。</p><p>    We’v looked at the four different Object-Oriented Programming flavors so far. Two of them — Classes and Factory functions — are easier to use compared to the rest.</p><p>到目前为止，我们已经了解了四种不同的面向对象编程风格。其中的两个--类和工厂函数--比其他的更容易使用。</p><p>  To continue the discussion on Classes and Factory functions, we need to understand three concepts that are tied closely to Object-Oriented Programming:</p><p>要继续讨论类和工厂函数，我们需要理解与面向对象编程密切相关的三个概念：</p><p>    Encapsulation is a  big word, but it has a simple meaning. Encapsulation is the act of enclosing one thing inside another thing so the thing inside doesn’t leak out. Think about storing water inside a bottle. The bottle prevents water from leaking out.</p><p>封装是一个很大的词，但它的含义很简单。封装就是把一件东西装进另一件东西里，这样里面的东西就不会外泄。想想把水储存在瓶子里吧。这个瓶子可以防止水泄漏。</p><p> In JavaScript, we’re interested in enclosing variables (which can include functions) so these variables don’t leak out into the external scope. This means you need to understand scope to understand encapsulation. We’ll go through an explanation, but you can also use  this article to beef up your knowledge regarding scopes.</p><p>在JavaScript中，我们感兴趣的是封闭变量(可以包括函数)，这样这些变量就不会泄漏到外部作用域。这意味着您需要了解作用域才能理解封装。我们将对其进行解释，但您也可以使用本文来增强有关作用域的知识。</p><p>    When you’re in the block, you can access variables that are declared outside the block.</p><p>当您在块中时，可以访问在块外部声明的变量。</p><p>   But when you’re outside the block, you cannot access variables that are declared inside the block.</p><p>但是，当您在块之外时，您不能访问在块内声明的变量。</p><p>   Note: Variables declared with  var don’t respect block scope. This is why  I recommend you use  let or  const to declare variables.</p><p>注意：用var声明的变量不考虑块作用域。这就是为什么我建议您使用let或const来声明变量。</p><p>  Functions behave like block scopes. When you declare a variable inside a function, they cannot leak out of that function. This works for all variables, even those declared with  var.</p><p>函数的行为类似于块作用域。当您在一个函数内声明一个变量时，它们不能从该函数中泄漏出来。这对所有变量都有效，即使是用var声明的变量也是如此。</p><p>   Likewise, when you’re inside the function, you can access variables that are declared outside of that function.</p><p>同样，当您在函数内部时，可以访问在该函数外部声明的变量。</p><p>   Functions can return a value. This returned value can be used later, outside the function.</p><p>函数可以返回值。此返回值可以稍后在函数外部使用。</p><p>    Closures are an advanced form of Encapsulation. They’re simply functions wrapped in functions.</p><p>闭包是封装的高级形式。它们只是包装在函数中的函数。</p><p>   function outsideFunction () { const food = &#39;Hamburger&#39; console.log(&#39;Called outside&#39;) return function insideFunction () { console.log(&#39;Called inside&#39;) console.log(food) }}// Calls `outsideFunction`, which returns `insideFunction`// Stores `insideFunction` as variable `fn`const fn = outsideFunction() // Calls `insideFunction`fn()</p><p>函数outside Function(){const Food=#39；Hamburger&#39；console.log(&#39；调用外部)返回函数inside Function(){console.log(&#39；调用内部)console.log(Food)}}//调用`outside Function`，它返回`inside Function`//Stores`inside Function`作为变量`fn`const fn=outside Function(。</p><p>   When you build objects, you want to make some properties publicly available (so people can use them). But you also want to keep some properties private (so others can’t break your implementation).</p><p>在构建对象时，您希望使某些属性公开可用(以便人们可以使用它们)。但您也希望保留一些私有属性(这样其他属性就不会破坏您的实现)。</p><p> Let’s work through this with an example to make things clearer. Let’s say we have a  Car blueprint. When we produce new cars, we fill each car up with 50 liters of fu</p><p>让我们通过一个例子来解决这个问题，使事情变得更清楚。假设我们有一张汽车蓝图。当我们生产新车时，我们给每辆车加满50公升的浮油。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://css-tricks.com/the-flavors-of-object-oriented-programming-in-javascript/">https://css-tricks.com/the-flavors-of-object-oriented-programming-in-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/风格/">#风格</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034382.html"><img src="http://img2.diglog.com/img/2020/11/thumb_783a02512ee18caed3b49d2b5e84ac30.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034382.html">独立系统编程会议(11月14日至15日)</a></div><span class="my_story_list_date">2020-11-11 4:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034258.html"><img src="http://img2.diglog.com/img/2020/11/thumb_968087d994d94fe91c78c43db7fa66a6.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034258.html">电子表格：面向大众的函数式编程(2014)[幻灯片]</a></div><span class="my_story_list_date">2020-11-10 21:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033997.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033997.html">对编程任务的定理证明者进行基准测试：YICES与Z3</a></div><span class="my_story_list_date">2020-11-9 16:0</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033755.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68eaef96ef90392715a86ab4529d5a51.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033755.html">费曼、算法编排和基于节点的编程</a></div><span class="my_story_list_date">2020-11-8 9:34</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>