<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使用SQL建模构建生产级工作流How to Build a Production Grade Workflow with SQL Modelling</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Build a Production Grade Workflow with SQL Modelling<br/>如何使用SQL建模构建生产级工作流</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 08:31:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/cf01d435a6ecb9cb4604f6aecd47efaa.jpg"><img src="http://img2.diglog.com/img/2020/11/cf01d435a6ecb9cb4604f6aecd47efaa.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In January of 2014, Shopify built a data pipeline platform for the data science team called Starscream. Back then, we were a smaller team and needed a tool that could deal with everything from ad hoc explorations to machine learning models. We chose to build with PySpark to get the power of a generalized distributed computer platform, the backing of the industry standard, and the ability to tap into the Python talent market.</p><p>2014年1月，Shopify为名为Starscream的数据科学团队构建了一个数据管道平台。那时，我们是一个较小的团队，需要一个工具来处理从临时探索到机器学习模型的所有问题。我们选择使用PySpark进行构建，以获得通用的分布式计算机平台的功能，行业标准的支持以及开发Python人才市场的能力。</p><p> Fast forward six years and our data needs have changed. Starscream now runs 76,000 jobs and writes 300 terabytes a day! As we grew, some types of work went away, but others (like simple reports) became so commonplace we do them every day. While our Python tool based on PySpark was computationally powerful, it wasn’t optimized for these commonplace tasks. If a product manager needed a simple rollup for a new feature by country, pulling it, and modeling it wasn’t a fast task.</p><p> 快进了六年，我们的数据需求已经改变。红蜘蛛现在可运行76,000个工作，每天可写入300 TB！随着我们的成长，某些类型的工作消失了，但是其他类型的工作（例如简单的报告）变得如此司空见惯，我们每天都要做。尽管我们基于PySpark的Python工具具有强大的计算功能，但并未针对这些常见任务进行优化。如果产品经理需要按国家/地区进行新功能的简单汇总，则对其进行提取和建模并不是一项快速的任务。</p><p> We’ll show you how we moved to a SQL modelling workflow by leveraging  dbt (data build tool) and created tooling for testing and documentation on top of it. All together, these features provide Shopify’s data scientists with a robust, production-ready workflow to quickly build straightforward pipelines.</p><p> 我们将向您展示如何利用dbt（数据构建工具）并在其之上创建用于测试和文档编制的工具，从而转向SQL建模工作流程。这些功能共同为Shopify的数据科学家提供了强大的，可立即投入生产的工作流，可快速构建简单的管道。</p><p>  When we interviewed our users to understand their workflow on Starscream, there were two issues we discovered:  development time and  thinking.</p><p>  当我们采访用户以了解他们在Starscream上的工作流程时，我们发现了两个问题：开发时间和思考。</p><p> Development time encompasses the time data scientists use to prototype the data model they’d like to build, run it, see the outcome,and iterate. The PySpark platform isn’t ideal for running straightforward reporting tasks, often forcing data scientists to write boilerplate and it yields long runtimes. This led to long iteration cycles when trying to build models on unfamiliar data.</p><p> 开发时间包括数据科学家用来建立，运行，查看结果并进行迭代的数据模型原型所花费的时间。 PySpark平台不适用于运行简单的报告任务，通常会迫使数据科学家编写样板，并且运行时间长。尝试在不熟悉的数据上构建模型时，这导致较长的迭代周期。</p><p> The second issue,  thinking, is more subtle and deals with the way the programming language forces you to look at the data. Many of our data scientists prefer SQL to python because its structure forces consistency in business metrics. When interviewing users, we found a majority would write out a query in SQL then translate it to Python when prototyping. Unfortunately, query translation is time consuming and doesn’t add value to the pipeline.</p><p> 思考的第二个问题更加微妙，涉及编程语言迫使您查看数据的方式。我们的许多数据科学家更喜欢SQL，而不是python，因为它的结构迫使业务指标保持一致。在采访用户时，我们发现大多数人会用SQL编写查询，然后在进行原型制作时将其转换为Python。不幸的是，查询翻译很耗时，并且无法为管道增加价值。</p><p> To understand how widespread these problems were, we audited the jobs run and surveyed our data science team for the use cases. We found that 70% or so of the PySpark jobs on Starscream were full batch queries that didn’t require generalized computing. We viewed this as an opportunity to make a kickass optimization for a painful workflow.</p><p> 为了了解这些问题的普遍性，我们审核了运行的作业并调查了数据科学团队的用例。我们发现，Starscream上的PySpark作业中约有70％是完全批量查询，不需要通用计算。我们认为这是对痛苦的工作流程进行优化的机会。</p><p>  Our goal was to create a SQL pipeline for reporting that enables data scientists to create simple reporting data faster, while still being production ready. After exploring a few alternatives, we felt that the dbt library came closest to our needs. Their tagline “deploy analytics code faster with software engineering practices” was  exactly what we were looking for in a workflow. We opted to pair it with Google BigQuery as our data store and dubbed the system and its tools, Seamster.</p><p>我们的目标是创建一个用于报告的SQL管道，使数据科学家能够更快地创建简单的报告数据，同时仍可以进行生产。在研究了一些替代方法之后，我们认为dbt库最接近我们的需求。他们的标语“通过软件工程实践更快地部署分析代码”正是我们在工作流程中寻找的。我们选择将其与Google BigQuery配对作为我们的数据存储，并命名为系统及其工具Seamster。</p><p> We knew that any off-the-shelf system wouldn’t be one size fits all. In moving to dbt, we had to implement our own:</p><p> 我们知道，任何现成的系统都无法满足所有需求。在转向dbt时，我们必须实现自己的：</p><p>   With dozens of data scientists making data models in a shared repository, a great user experience would</p><p>   数十名数据科学家在共享存储库中建立数据模型，那么出色的用户体验将</p><p>  By default, dbt declares raw sources in a central  sources.yml. This quickly became a very large file as it included the schema for each source, in addition to the source name. It creates a huge bottleneck for teams editing the same file across multiple PRs.</p><p>  缺省情况下，dbt在中央sources.yml中声明原始源。这很快就变成了一个非常大的文件，因为除了源名称之外，它还包括每个源的架构。它为团队在多个PR中编辑同一文件创建了巨大的瓶颈。</p><p>  To mitigate the bottleneck, we leveraged the flexibility of dbt and created a top-level ‘sources’ directory to represent each raw source with its own source-formatted yaml file. This way, data scientists can parse only the source documentation that’s relevant for them and contribute to the  sources.yml file without stepping on each other’s toes.</p><p>  为了缓解瓶颈，我们利用dbt的灵活性，并创建了一个顶级“ sources”目录来用其自己的源格式的yaml文件表示每个原始源。这样，数据科学家就可以仅解析与其相关的源文档，并为sources.yml文件做出贡献，而不会互相干扰。</p><p>   We also created a Base layer of models using the  ‘ staging’ concept from dbt to implement their best practice of  limiting references to raw data. Our Base models serve as a one-to-one interface to raw sources. They don’t change the grain of the raw source, but do apply renaming, recasting, or any other cleaning operation that relates to the source data collection system.</p><p>   我们还使用dbt的“登台”概念创建了模型的基础层，以实现其将引用限制为原始数据的最佳实践。我们的基本模型充当原始资源的一对一接口。它们不会改变原始数据的来源，但是会应用重命名，重铸或其他任何与源数据收集系统相关的清理操作。</p><p> The Base layer serves to protect users from breaking changes in raw sources. Raw external sources are by definition out of the control of Seamster and can introduce breaking changes for any number of reasons at any point in time. If and when this happens, you only need to apply the fix to the Base model representing the raw source, as opposed to every individual downstream model that depends on the raw source.</p><p> 基本层用于保护用户免受原始资源变化的破坏。根据定义，原始外部资源不在Seamster的控制范围内，并且可以在任何时间点出于多种原因引入重大更改。如果发生这种情况，则只需要将修复程序应用于代表原始源的基本模型，而不是依赖于原始源的每个单独的下游模型。</p><p>  We knew that the tooling improvements of Seamster would be only one part of a greater data platform at Shopify. We wanted to make sure we’re providing mechanisms to support good dimensional modelling practices and support data discovery.</p><p>我们知道，Seamster的工具改进只是Shopify更大数据平台的一部分。我们想确保我们提供的机制可以支持良好的尺寸建模实践并支持数据发现。</p><p> In dbt, a model is simply a .sql file. We’ve extended this definition in Seamster to define a model as a directory consisting of four files:</p><p> 在dbt中，模型只是一个.sql文件。我们在Seamster中扩展了此定义，以将模型定义为包含四个文件的目录：</p><p>  You can further organize models into directories that indicate a data science team at Shopify like ‘finance’ or ‘marketing’.</p><p>  您可以将模型进一步组织到目录中，以指示Shopify中的数据科学团队，例如“财务”或“市场营销”。</p><p> To support a clean data warehouse we’ve also organized data models into these rough layers that differentiate between:</p><p> 为了支持干净的数据仓库，我们还将数据模型组织到这些粗糙的层中，以区分以下内容：</p><p> application-ready: data that isn’t dimensionally modelled but still transformed and clean for consumption by another tool (for example,  training data for a machine learning algorithm)</p><p> 适用于应用的数据：尚未进行尺寸建模但仍经过转换和清理以供其他工具使用的数据（例如，针对机器学习算法的训练数据）</p><p> presentation: shareable and reliable data models that follow dimensional modelling best practices and can be used by data scientists across different domains.</p><p> 演示文稿：遵循维度建模最佳实践的可共享且可靠的数据模型，可供跨不同领域的数据科学家使用。</p><p> With these two changes, a data consumer can quickly understand the data quality they can expect from a model and find the owner in case there is an issue. We also pass this metadata upstream to  other tools to help with the data discovery workflow.</p><p> 通过这两个更改，数据使用者可以快速了解他们可以从模型中获得的数据质量，并在出现问题时找到所有者。我们还将此元数据上游传递给其他工具，以帮助进行数据发现工作流。</p><p>  dbt has native support for ‘schema tests’, which are encoded in a model’s schema.yml file. These tests run against production data to validate data invariants, such as the presence of null values or the uniqueness of a particular key. This feature in dbt serves its purpose well, but we also want to enable data scientists to write unit tests for models that run against fixed input data (as opposed to production data).</p><p>dbt对“模式测试”具有本机支持，该模式编码在模型的schema.yml文件中。这些测试针对生产数据进行，以验证数据不变性，例如空值的存在或特定键的唯一性。 dbt中的此功能很好地实现了其目的，但是我们还希望使数据科学家能够为针对固定输入数据（而不是生产数据）运行的模型编写单元测试。</p><p> Testing on fixed inputs allows the user to test edge cases that may not be in production yet. In larger organizations, there can and will be frequent updates and many collaborators for a single model. Unit tests give users confidence that the changes they’re making won’t break existing behaviour or introduce regressions.</p><p> 在固定输入上进行测试使用户可以测试可能尚未投入生产的边缘情况。在大型组织中，单个模型可能会而且会经常更新，并且会有很多合作者。单元测试使用户充满信心，他们所做的更改不会破坏现有行为或引入回归。</p><p> Seamster provides a Python-based unit testing framework. Data scientists write their unit tests in the  test_model_name.py file in the model directory. The framework enables constructing ‘mock’ input models from fixed data. The central object in this framework is a ‘mock’ data model, which has an underlying representation of a Pandas dataframe. You can pass fixed data to the mock constructor as either a csv-style string, Pandas dataframe, or a list of dictionaries to specify input data.</p><p> Seamster提供了一个基于Python的单元测试框架。数据科学家将其单元测试写入模型目录中的test_model_name.py文件中。该框架可从固定数据构建“模拟”输入模型。该框架的中心对象是“模拟”数据模型，该模型具有Pandas数据框的基本表示形式。您可以将固定数据作为csv样式的字符串，Pandas数据框或字典列表传递给模拟构造器，以指定输入数据。</p><p> Input and expected MockModels are built from static data. The actual MockModel is built from input MockModels by BigQuery. Actual and expected MockModels can assert equality or any Great Expectations expectation.</p><p> 输入和预期的MockModels是从静态数据构建的。实际的MockModel是由BigQuery从输入MockModels构建的。实际和预期的MockModels可以声明相等性或任何“ Great Expectations”期望。</p><p> A constructor creates a test query where a common table expression (CTE) represents each input mock data model, and any references to production models (identified using dbt’s ‘ref’ macro) are replaced by references to the corresponding CTE. Once you execute a query, you can compare the output to an expected result. In addition to an equality assertion, we extended our framework to support all expectations from the open-source  Great Expectations library to provide more granular assertions and error messaging.</p><p> 构造函数会创建一个测试查询，其中一个通用表表达式（CTE）代表每个输入的模拟数据模型，并且对生产模型的任何引用（使用dbt的“ ref”宏标识）都被对相应CTE的引用替换。执行查询后，可以将输出与预期结果进行比较。除了相等声明外，我们还扩展了框架，以支持开源的Great Expectations库中的所有期望，以提供更详细的声明和错误消息。</p><p> The main downside to this framework is that it requires a roundtrip to the query engine to construct the test data model given a set of inputs. Even though the query itself is lightweight and processes only a handful of rows, these roundtrips to the engine add up. It becomes costly to run an entire test suite on each local or CI run. To solve this, we introduced tooling both in development and CI to run the minimal set of tests that could potentially break given the change. This was straightforward to implement with accuracy because of dbt’s lineage tracking support; we simply had to find all downstream models (direct and indirect) for each changed model and run their tests.</p><p> 该框架的主要缺点是，在给定一组输入的情况下，它需要往返于查询引擎才能构建测试数据模型。即使查询本身是轻量级的并且仅处理少量的行，这些到引擎的往返行程仍会累加。在每次本地或CI运行中运行整个测试套件的成本很高。为了解决这个问题，我们在开发和CI中引入了工具，以运行可能会因更改而中断的最少测试集。由于dbt的血统追踪支持，因此可以轻松，准确地实现。我们只需为每个更改的模型找到所有下游模型（直接模型和间接模型）并进行测试即可。</p><p>  Our objective in Seamster’s CI is to give data scientists peace of mind that their changes won’t introduce production errors the next time the warehouse is built. They shouldn’t have to wonder whether removing a column will cause downstream dependencies to break, or whether they made a small typo in their SQL model definition.</p><p>  我们在Seamster CI中的目标是让数据科学家放心，他们的更改不会在下次建造仓库时引入生产错误。他们不必怀疑删除列是否会导致下游依赖项中断，或者他们是否在SQL模型定义中进行了小的打错。</p><p> To achieve this accurately, we would need to build and tear down the entire warehouse on every commit. This isn’t feasible from both a time and cost perspective. Instead, on every commit we materialize every model as a view in a temporary BigQuery dataset which is created at the start of the validation process and removed as soon as the validation finishes. If we can’t build a view because its upstream model doesn’t provide a certain column, or if the SQL is invalid for any reason, BigQuery fails to build the view and produces relevant error messaging.</p><p>为了准确实现这一目标，我们将需要在每次提交时构建和拆除整个仓库。从时间和成本角度来看这都是不可行的。相反，在每次提交时，我们都会在临时BigQuery数据集中将每个模型具体化为视图，该数据集是在验证过程开始时创建的，并在验证完成后立即删除。如果我们由于其上游模型未提供特定列而无法构建视图，或者如果SQL由于任何原因无效，则BigQuery无法构建视图并产生相关的错误消息。</p><p> Currently, We have a warehouse consisting of over 100 models, and this validation step takes about two minutes. We reduce validation time further by only building the portion of the directed acyclic graph (DAG) affected by the changed models, as done in the unit testing approach.</p><p> 目前，我们有一个包含100多个模型的仓库，此验证步骤大约需要2分钟。通过像单元测试方法一样，仅构建受更改模型影响的有向无环图（DAG）部分，可以进一步减少验证时间。</p><p> dbt’s schema.yml serves purely as metadata and can contain columns with invalid names or types ( data_type). We employ the same view-based strategy to validate the contents of a model’s schema.yml file ensuring the schema.yml is an accurate depiction of the actual SQL model.</p><p> dbt的schema.yml纯粹用作元数据，并且可以包含具有无效名称或类型（data_type）的列。我们采用相同的基于视图的策略来验证模型的schema.yml文件的内容，以确保schema.yml是实际SQL模型的准确描述。</p><p>  Like many large organizations, we maintain a data warehouse for reporting where accuracy is key. To power our independent data science teams, Seamster helps by enforcing conformance rules on the layers mentioned earlier (base, application-ready, and presentation layers). Examples include naming rules or inheritance rules which help the user reason over the data when building their own dependent models.</p><p>  像许多大型组织一样，我们维护一个数据仓库以报告准确性是关键。为了支持我们独立的数据科学团队，Seamster通过在前面提到的各层（基础层，应用就绪层和表示层）上执行一致性规则来提供帮助。示例包括命名规则或继承规则，它们可以帮助用户在构建自己的依赖模型时对数据进行推理。</p><p> Seamster CI runs a collection of such rules that ensure consistency of documentation and modelling practices across different data science teams. For example, one warehouse rule enforces that all columns in a schema conform to a prescribed nomenclature. Another warehouse rule enforces that only base models can reference raw sources (via the ‘source’ macro) directly.</p><p> Seamster CI运行这些规则的集合，以确保不同数据科学团队之间的文档和建模实践的一致性。例如，一个仓库规则强制模式中的所有列均符合规定的命名法。另一个仓库规则规定，只有基本模型才能直接引用原始资源（通过“源”宏）。</p><p> Some warehouse rules apply only to certain layers. In the presentation layer, we enforce that any column name needs a globally unique description to avoid divergence of definitions. Since everything in dbt is YAML, most of this rule enforcement is just simple parsing.</p><p> 一些仓库规则仅适用于某些图层。在表示层中，我们强制要求任何列名称都需要一个全局唯一的描述，以避免定义的差异。由于dbt中的所有内容都是YAML，因此大多数规则执行都是简单的解析。</p><p>  To ensure we got it right and worked out the kinks, we ran a multiweek beta of Seamster with some of our data scientists who tested the system out on real models. Since you’re reading about it, you can guess by now that it went well!</p><p>  为了确保我们做对并解决问题，我们与一些在实际模型上测试了系统的数据科学家一起运行了Seamster的多周Beta版。由于您正在阅读它，因此您现在可以猜到它运行良好！</p><p> While productivity measures are always hard, the vast majority of users reported they were shipping models in a couple of days instead of a couple of weeks. In addition, documentation of models increased because this is a feature built into the model spec.</p><p>尽管生产率衡量一直很困难，但是绝大多数用户报告说，它们是在几天而不是几周内交付模型的。此外，由于这是模型规格中内置的功能，因此增加了模型文档。</p><p> Were there any negative results?  Of course. dbt’s current incremental support doesn’t provide safe and consistent methods to handle late arriving data, key resolution, and rebuilds. For this reason, a handful of models (Type  2 dimensions or models in the 1.5B+ event territory) that required incremental semantics weren’t doable— for now. We’ve got big plans though!</p><p> 有否负面结果？当然。 dbt当前的增量支持无法提供安全一致的方法来处理延迟到达的数据，关键解决方案和重建。因此，目前尚无法使用少数需要增量语义的模型（Type 2维度或1.5B +事件区域中的模型）。不过，我们有很大的计划！</p><p>  We’re focusing on updating the tool to ensure it’s tailored to Shopify’s data scientists. The biggest hurdle for a new product (internal and external) is adoption. We know we still have work to do to ensure that our tool is top of mind when users have simple ( but not easy) reporting work. We’re spending time with each team to identify upcoming work that we can speed up by using Seamster. Their questions and comments will be part of our tutorials and documentations for new data scientists.</p><p>  我们专注于更新该工具，以确保它是为Shopify的数据科学家量身定制的。新产品（内部和外部）的最大障碍是采用。我们知道，当用户进行简单（但不容易）的报告工作时，仍然需要确保我们的工具成为首要任务。我们正在与每个团队共度时光，以找出可以通过使用Seamster加快速度的近期工作。他们的问题和评论将成为我们面向新数据科学家的教程和文档的一部分。</p><p> On the engineering front, an exciting next step is looking beyond batch data processing.  Apache Beam and  Beam SQL provide an opportunity to consider a single SQL-centric data modelling tool for both batch and streaming use cases.</p><p> 在工程方面，令人振奋的下一步是超越批处理数据处理。 Apache Beam和Beam SQL提供了一个机会来考虑针对批处理和流传输用例的单个以SQL为中心的数据建模工具。</p><p> We’re also big believers in open source at Shopify. Depending on the dbt’s community needs we’d also like to explore contributing our validation strategy and a unit testing framework to the project.</p><p> 我们也是Shopify开源的忠实拥护者。根据dbt社区的需求，我们还想探索为该项目贡献我们的验证策略和单元测试框架。</p><p> If you’re interested in building solutions from the ground up and would like to come work with us, please check out  Shopify’s career page.</p><p> 如果您有兴趣从头开始构建解决方案，并希望与我们一起工作，请查看Shopify的职业页面。</p><p>  Stories from the teams who build and scale Shopify, the leading cloud-based, multi-channel commerce platform powering over 1,000,000 businesses around the world.</p><p>  来自构建和扩展Shopify的团队的故事，Shopify是领先的基于云的多渠道商业平台，为全球超过1,000,000家企业提供支持。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shopify.engineering/build-production-grade-workflow-sql-modelling">https://shopify.engineering/build-production-grade-workflow-sql-modelling</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>