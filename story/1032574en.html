<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>浮点数的另一种选择</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">浮点数的另一种选择</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 11:19:55</div><div class="page_narrow text-break page_content"><p>Floating-point numbers are fine. They are decently designed and well standardized, they provide a good compromise between performance and precision. They work great most of the time. Until the day when they suddenly don&#39;t and nobody knows why.</p><p>浮点数就行了。它们设计得体，标准化程度高，在性能和精度之间提供了很好的折衷。他们大部分时间都工作得很好。直到有一天，他们突然不再这么做，没有人知道为什么。</p><p>  For me, that day came when I encountered a bug in the Taubin estimator.  Taubin smoothing takes a triangle mesh, a pair of magic numbers called λ and μ, a little time to think, and it makes the input mesh smooth. It also makes sure that the mesh isn&#39;t reduced to a perfectly smooth but rather uninteresting sphere or a point.</p><p>对我来说，那一天到来了，我在Taubin估计器中遇到了一个错误。陶宾平滑需要一个三角形网格，一对称为λ和μ的幻数，花一点时间思考，它会使输入网格平滑。它还可以确保网格不会缩小到一个完美平滑但相当乏味的球体或一个点。</p><p>  The first magic number λ is something between 0 and 1. When it&#39;s 0 — nothing happens at all, and when it&#39;s 1 — nothing good happens either. It should be somewhere in between. Nobody really knows how to pick this number but an experienced engineer can at least make an educated guess.</p><p>第一个幻数λ介于0和1之间。当它为0 - 时什么都不会发生，当它为1 - 时也不会发生任何好事。应该介于两者之间。没有人真的知道如何选择这个数字，但一个有经验的工程师至少可以做出一个有经验的猜测。</p><p>  The second magic number governs shrinkage compensation. It&#39;s a negative number slightly greater than λ in its absolute value. Nobody knows how to pick it either but this time even an educated guess is a challenge.</p><p>第二个魔术数字管理收缩补偿。这是一个在绝对值上略大于λ的负数。也没有人知道如何挑选，但这一次，即使是一个有经验的猜测也是一个挑战。</p><p>  That&#39;s why you need an estimator. Something that picks the μ for you. And we have one. And it was bugged. And I was the one to fix it.</p><p>这就是你需要估算师的原因。为你挑选μ的东西。我们有一个。它被窃听了。我就是那个修好它的人。</p><p>  The first day of the investigation showed that the estimator is in fact entirely correct. The second day of the investigation showed that the tests covering the bug are correct just as well. The third day of the investigation brought a promising hypothesis that the whole story is just a bad dream and all it takes to solve the mystery is to wake up. The fourth morning killed that hypothesis and left me completely clueless.</p><p>第一天的调查表明，估算者实际上是完全正确的。调查的第二天显示，覆盖该漏洞的测试也是正确的。调查的第三天带来了一个有希望的假设，即整个故事只是一场噩梦，解开谜团所需的一切就是醒来。第四天早上否定了这个假设，让我完全不知所措。</p><p>  Luckily I have a friend who is smarter than me and he advised to fuzz the input a little and see what happens then. I did. And something happened. The bug didn&#39;t go away but the μ changed a lot. Way unproportionally to the small changes in the input. Fascinating!</p><p>幸运的是，我有一个比我聪明的朋友，他建议把输入弄得模糊一点，然后看看会发生什么。我做到了。然后发生了一些事。这个错误并没有消失，但是μ改变了很多。与输入中的微小变化不成比例。太棒了！</p><p>  We can expect a computation to work with some error. It&#39;s fine, we get input data from sensors and they embed some error, to begin with. We print out our finished models, and the printers have some limited precision as well so a small error doesn&#39;t upset anyone. It&#39;s all good while the error is small. But what if it isn&#39;t?</p><p>我们可以预期计算会有一些误差。这很好，我们从传感器获得输入数据，而它们首先嵌入了一些错误。我们把成品模型打印出来，而且打印机的精度也很有限，所以一个小小的错误不会让任何人心烦意乱。只要误差很小，一切都是好的。但如果它不是呢？</p><p>  As it turns out, in my case, a completely correct algorithm had a computational error of about 1. Not 1e-16 or 1e-5 but 1. Just 1. So if you expect your μ to be somewhat close to -0.7, and the estimator says it&#39;s 0.3, it is in fact correct. It is still a correct estimation within its error range.</p><p>事实证明，在我的例子中，一个完全正确的算法的计算误差约为1。不是1e-16或1e-5，而是1。只有1。因此，如果你预计μ在某种程度上接近-0.7%，而估计者说它是0.3%，那么它实际上是正确的。在其误差范围内仍是一个正确的估计。</p><p>      Ok, so it&#39;s not the computational error per se that causes trouble but only the unexpected and unpredictable error. Can we predict it though?</p><p>好的，所以造成麻烦的不是计算错误本身，而是意想不到和不可预测的错误。不过，我们能预测到吗？</p><p>  Well, of course, we can. There is a whole field of numerical error analysis for that but let&#39;s be honest, most of the time we use our intuition instead. So how good is our intuition exactly?</p><p>嗯，我们当然可以。对于这一点，有一个完整的数值误差分析领域，但让我们诚实地说，大多数时候我们使用的是我们的直觉。那么我们的直觉到底有多好呢？</p><p>  I propose a game to find out. Let&#39;s take a cubic equation solver. It&#39;s a relatively complex computation with a very simple way to validate its precision. We will pick some roots first and then we will generate the cubic equation for these roots. Then we&#39;ll make the cubic solver find our roots back through the computation. The difference between the original and the computed value for each root will be our measurable error. This error divided by the original value will be our relative error.</p><p>我提议玩个游戏来找出答案。让我们用一个三次方程解算器。这是一个相对复杂的计算，有一个非常简单的方法来验证它的精度。我们将首先选取一些根，然后为这些根生成三次方程。然后，我们将通过计算使立方求解器找到我们的根。每个根的原始值和计算值之间的差异将是我们的可测量误差。这个误差除以原始值就是我们的相对误差。</p><p>      // find roots for ax^3 + bx^2 + cx + d = 0std::array&lt;double, 3&gt; roots_for_cubic(std::array&lt;double, 4&gt; abcd) { double PI = std::atan(1.) * 4.; double a1 = abcd[1] / abcd[0]; double a2 = abcd[2] / abcd[0]; double a3 = abcd[3] / abcd[0]; double q = (a1 * a1 - 3. * a2) / 9.; double sq = -2. * std::sqrt(q); double r = (2. * a1 * a1 * a1 - 9. * a1 * a2 + 27. * a3) / 54.0; double z = r * r - q * q * q; std::array&lt;double, 3&gt; roots; if(z &lt;= 0.) { double t = std::acos(r / std::sqrt(q * q * q)); roots[0] = sq * std::cos(t / 3.) - a1 / 3.; roots[1] = sq * std::cos((t + 2. * PI) / 3.) - a1 / 3.; roots[2] = sq * std::cos((t + 4. * PI) / 3.) - a1 / 3.; } else { roots[0] = pow(std::sqrt(z) + std::abs(r) , 1. / 3.); roots[0] += q / roots[0]; roots[0] *= ( r &lt; 0. ) ? 1 : -1; roots[0] -= a1 / 3.; roots[1] = std::numeric_limits&lt;double&gt;::quiet_NaN(); roots[2] = std::numeric_limits&lt;double&gt;::quiet_NaN(); } return roots;}// find polynomial coefficients a, b, c, and d for the rootsstd::array&lt;double, 4&gt; cubic_for_roots(std::array&lt;double, 3&gt; xs) { return {1. // one of them should be set as a constant , - (xs[0] + xs[1] + xs[2]) , + (xs[0] * xs[1] + xs[1] * xs[2] + xs[2] * xs[0]) , - (xs[0] * xs[1] * xs[2])};}</p><p>//查找ax^3+bx^2+cx+d=0std：：array&lt；double，3&gt；root_for_cubic(std：：array&lt；double，4&gt；abcd){DOUBLE PI=STD：：ATAN(1.)*4；DOUBLE A1=ABCD[1]/ABCD[0]；DOUBLE a2=ABCD[2]/ABCD[0]；DOUBLE A3=ABCD[3]/ABCD[0]；DOUBLE Q=(A1*a1-3.*a2)/9；DOUBLE sq=-2。*std：：sqrt(Q)；双r=(2.*a1*a1*a1-9.*a1*a2+27.。*a3)/54.0；双z=r*r-q*q*q；std：：array&lt；double，3&gt；root；if(z&lt；=0.){Double t=std：：acos(r/std：：sqrt(q*q*q)；root[0]=sq*std：：cos(t/3)-a1/3；root[1]=sq*std：cos((t+2.*Pi)/3.)-A1/3；Root[2]=sq*std：：cos((t+4.*Pi)/3.)-A1/3.；}Else{root[0]=power(std：：sqrt(Z)+std：：ABS(R)，1./3.)；root[0]+=q/root[0]；root[0]*=(r&lt；0.。)？1：-1；ROOTS[0]-=A1/3；ROOTS[1]=std：：numeric_limits&lt；double&gt；：：quiet_NaN()；ROOTS[2]=std：：numeric_limits&lt；double&gt；：：quiet_NaN()；}返回根；}//查找根的多项式系数a、b、c和d std：：Array&lt；Double，4&gt；Cubic_For_Root(std：：Array&lt；Double，3&gt；Xs){return{1.//其中一个应该设置为常量，-(xs[0]+xs[1]+xs[2])，+(xs[0]*xs[1]+xs[1]*xs[2]+xs[2]*xs[0])，-(xs[0]*xs[1]*xs[2])}；}。</p><p>    Now if we pick our roots as 1, 2, and 3, the equation produced will be:</p><p>现在，如果我们选择根为1、2和3，则生成的方程式将为：</p><p>            Well, yes. On the equation this simple there is no error whatsoever. The computation works flawlessly. So let&#39;s start making it worse.</p><p>嗯，是的。在这个简单的方程式上，没有任何误差。计算工作无懈可击。因此，让我们开始让情况变得更糟吧。</p><p>    The slider below lets you pick an interval in the logarithmic scale. The interval may start at 10 -12 and end at 10 12. It&#39;s impossible to predict the exact error up to a single number so you should just pick an appropriate interval that covers the error  *. .  Of course, you can select the whole interval, too. This estimation is guaranteed to be correct. And entirely useless.  ←</p><p>下面的滑块允许您选择对数刻度的间隔。间隔可能从10-12开始，到10-12结束。不可能预测精确的错误，直到一个数字，所以您应该选择一个适当的间隔来覆盖错误*。。当然，您也可以选择整个间隔。这一估计保证是正确的。而且完全没用。←</p><p>  Let&#39;s say we have the roots of 0.001, 2, 3&amp;hairsp000. So to which interval, in your opinion, the maximum relative error for a cubic solver belongs?</p><p>让我们假设我们有0.001、2、3和3支头发的根。那么，在您看来，立方求解器的最大相对误差属于哪个区间？</p><p>      It&#39;s measured as 3.3675e-08 so the estimation between e-8 and e-7 would be more than adequate.</p><p>它被测量为3.3675e-08，所以估计在e-8和e-7之间将是绰绰有余的。</p><p>    Now let&#39;s make our roots even more diverse in magnitude. How about 1e-6, 2, and 3e6?</p><p>现在，让我们让我们的根在规模上更加多样化。1E-6、2和3E6怎么样？</p><p>        It&#39;s significantly more than 1. Since it&#39;s a relative error, this means than the error for the smallest root value is larger than the value itself. So the computation is now essentially uselses.</p><p>它明显大于1。由于它是一个相对误差，这意味着最小根值的误差大于值本身。所以计算现在基本上是有用的。</p><p>  While we&#39;re talking about a synthetic case just to test our solver, it is frigtengly close to the real world numbers. Consider you&#39;re a multi-bilionaire and you want to put your net worth and a few cents in one cubic equation. 10&amp;hairsp000&amp;hairsp000&amp;hairsp000 and a 0.01 has the same difference in magnitude as the roots for our synthetic case. The difference is large but it&#39;s not inconcievable.</p><p>虽然我们谈论的是一个合成案例，只是为了测试我们的解算器，但它非常接近真实世界的数字。考虑一下你是一个拥有多个亿万富翁的人，你想把你的净资产和几美分放在一个立方方程式中。10&amp；air sp000&amp；air sp000&amp；air sp000和a 0.01在大小上与我们的合成案例的词根具有相同的差异。差别很大，但也不是不可接受的。</p><p>          The error is much-much larger than the smallest root value. It&#39;s even larger than the second smallest root value. Essentially, what we got as the output is more noise than the values we&#39;re expecting to compute.</p><p>误差比最小根值大得多。它甚至比第二个最小的根值还要大。从本质上说，我们得到的输出比我们期望计算的值更多的噪音。</p><p>  Note that the computation is still correct. Within, of course, some margin of error. It&#39;s only the scale of this margin that makes the computation useless.</p><p>请注意，计算仍然正确。当然，在一定的误差范围内。只有这个差额的规模才会使计算变得毫无用处。</p><p>    It&#39;s not the error per se that is bad. Error is omnipresent. Every measuring device has its error, every 3D printer and every milling machine has its maximal precision. The error is fine.</p><p>坏的不是错误本身。错误无处不在。每一种测量装置都有其误差，每一台3D打印机和每台铣床都有其最高精度。错误没有问题。</p><p>    People address errors in multiple ways. In metrology, a measured value is supplemented with its absolute error. You don&#39;t say that the temperature outside is 10°, you say it&#39;s 10°&amp;hairsp±&amp;hairsp0.5°. This might seem redundant since this is a small error for the weather outside, but in some other context, this very error might become significant. If you&#39;re measuring body temperature, a 1-degree difference is enough to tell a sick person from a perfectly healthy one. You can not afford a whole 1-degree error in this scenario.</p><p>人们以多种方式处理错误。在计量学中，测量值加上绝对误差。你不能说外面的温度是10°，你要说它是10°&&amp；头发0.5°。这可能看起来是多余的，因为这对于外面的天气来说是一个小错误，但在其他一些上下文中，这个错误可能会变得非常严重。如果你在测量体温，1度的差值就足以区分病人和完全健康的人。在这种情况下，您不能承受整整1度的误差。</p><p>  If you have this input error written down, you can pull it through your computation to see if the resulting error is still tolerable. To do that, you need to exchange your measured numbers for intervals. A number with error becomes an interval: 10°&amp;hairsp±&amp;hairsp0.5° becomes [9.5, 10.5]°.</p><p>如果您写下了此输入错误，则可以通过计算来查看所产生的错误是否仍然可以容忍。要做到这一点，您需要将测量的数字交换为间隔。一个有误差的数字变成一个区间：10°&amp；air sp±&amp；air sp0.5°变成[9.5，10.5]°。</p><p>                    So with intervals, you can accommodate the input error. You can drag it through the computation and see how it plays with other values with their own error. In the end, you will have your computed value within some interval and the size of this interval will indicate the output error. But what about the error of the computation itself?</p><p>因此，通过间隔，您可以适应输入错误。您可以在整个计算过程中拖动它，并查看它如何处理具有其自身错误的其他值。最后，您将在某个间隔内获得计算值，此间隔的大小将指示输出错误。但计算本身的误差又如何呢？</p><p>  A computational error occurs when we can&#39;t store the operation result in the same types we keep our operands in and we&#39;re forced to throw some data away. Let&#39;s say we have Python-style “unlimited” length integers. This means that if our computation only consists of addition, subtraction, and multiplication, we would never face any computational error.</p><p>当我们不能将运算结果存储在我们保存操作数的相同类型中，并且我们被迫丢弃一些数据时，就会发生计算错误。让我们假设我们有Python风格的“无限”长度整数。这意味着，如果我们的计算只包括加法、减法和乘法，我们就不会面临任何计算错误。</p><p>  Of course, with division, things get a little bit different. E. g. we can&#39;t store  16&amp;hairsp¾ in integers so we have to truncate it into 16. In this case, the whole fractional part becomes our error.</p><p>当然，有了除法，事情就有点不同了。例如，我们不能以整数形式存储16，所以我们必须将其截断为16。在这种情况下，整个小数部分就成了我们的错误。</p><p>  We can use pairs of integers to represent rational numbers. This will solve the division issue. However, this type of rational number, while does not accumulate errors, accumulates digits. The more digits it has, the slower the computation goes. At some point, it may simply become impractically slow. Just like with the uncontrollable error, uncontrollable size becomes an issue.</p><p>我们可以用整数对来表示有理数。这将解决划分问题。然而，这类有理数虽然不会累积误差，但会累积数字。它的位数越多，计算速度就越慢。在某种程度上，它可能会变得不切实际地变得缓慢。就像不可控的误差一样，不可控的大小也成了问题。</p><p>  We want a compromise. Some entity that grows error controllably yet still operates in constant speed. And we can get it, for example, by merging two ideas: intervals and rational numbers together.</p><p>我们想要一个折衷方案。某些实体可控制地增长错误，但仍以恒定速度运行。例如，我们可以通过合并两个概念来得到它：区间和有理数。</p><p>  Let&#39;s say, we want to write a number as an interval of its tenths. We can do that most intuitively by throwing away all the digits after the first one.</p><p>比方说，我们想把一个数字写成十分之一的区间。我们可以最直观地做到这一点，去掉第一个数字之后的所有数字。</p><p>    Just like we can do this with decimal fraction, we can do this with any rational number. We can put it between a pair of rational numbers made by finite integers. In this case, every integer is in the range [0, 1, ..., 99].</p><p>就像我们可以对小数做这件事一样，我们可以对任何有理数做这件事。我们可以把它放在由有限个整数组成的一对有理数之间。在这种情况下，每个整数都在[0，1，...，99]范围内。</p><p>    Ok, this is not entirely true. If the number is greater than 99, then we can&#39;t really store it in our tiny rationals but we can say that it&#39;s larger than 99 by assigning the 0 divisor to its upper bound. Of course, it&#39;s just a dirty hack but let&#39;s leave it like that.</p><p>好吧，这不完全是真的。如果这个数字大于99，那么我们不能真的把它存储在我们的小有理数中，但我们可以通过将0除数分配给它的上界来说它大于99。当然，这只是一个卑鄙的黑客行为，但让我们就这样算了吧。</p><p>  Now if we want to accommodate both input error and computational error, all we have to do is to represent an input interval in its finite rational numbers. A finite rational lower bound of this interval and a finite rational upper bound of the same interval.</p><p>现在，如果我们想要同时容纳输入误差和计算误差，我们所要做的就是用它的有限有理数来表示输入区间。该区间的有限有理下界和同一区间的有限有理上界。</p><p>    This entity — a pair of finite rational bounds, represents a real number along with both its input error and representational error. It also grows computational error explicitly while the size of the entity remains constant.</p><p>这个实体 - 是一对有限的有理数界，表示一个实数及其输入误差和表示误差。在实体大小保持不变的情况下，它还会显式增加计算误差。</p><p>  The implementation example is  available on GitHub. Please note that it&#39;s just a proof of concept and not the best possible solution in terms of neither error minimization nor speed.</p><p>GitHub上提供了实现示例。请注意，这只是一个概念证明，并不是最好的可能的解决方案，既不是错误最小化，也不是速度方面的最佳解决方案。</p><p>    The computational error may become a problem at the least appropriate moment. Both rational numbers and intervals are well-known alternatives for floating-point numbers when the error becomes an issue.</p><p>在最不合适的时候，计算误差可能会成为一个问题。当错误成为问题时，有理数和区间都是浮点数的众所周知的替代方案。</p><p>  Rational bounds, being a chimeric product of both ideas, let you manage both measurement error and computational error in a coherent way without compromising performance all that much.</p><p>有理界限是这两种思想的融合产物，允许您以一致的方式管理测量误差和计算误差，而不会对性能造成太大影响。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wordsandbuttons.online/yet_another_alternative_to_floating_point_numbers.html">https://wordsandbuttons.online/yet_another_alternative_to_floating_point_numbers.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/浮点数/">#浮点数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/floating/">#floating</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>