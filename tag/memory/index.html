<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#memory</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#memory</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1066722.html">PROSSIMO  - 互联网最关键的基础设施的内存安全 </a></div><div class="item_title_en"><a target="_blank" href="https://www.memorysafety.org/">Prossimo – Memory safety for the Internet's most critical infrastructure</a><span>(www.memorysafety.org)</span></div><span class="my_story_list_date">2021-6-19 0:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1066722.html"><img src="http://img2.diglog.com/img/2021/6/thumb_dc4bca412d12326a9b2322a50baded20.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">让＆＃39;■rustls TLS库准备好尽可能多地替换OpenSSL。  当我们考虑对当今互联网最关键的代码最关键时，Linux内核位于列表的顶部。  阅读更多  现在是互联网上达到更安全的软件的时候了，这就是为什么我们的内存安全计划正在协调工作，以进一步改进Rustls TLS库。  阅读更多  Apache H......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基础设施/">#基础设施</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组织/">#组织</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1065814.html">Linux与“Memory Folios”：编译内核时有7％的性能提升 </a></div><div class="item_title_en"><a target="_blank" href="https://lore.kernel.org/lkml/20210614201435.1379188-1-willy@infradead.org/">Linux with “memory folios”: got a 7% performance boost when compiling the kernel</a><span>(lore.kernel.org)</span></div><span class="my_story_list_date">2021-6-15 9:49</span><div class="my_story_list_item_desc">[patch v11 13/33] mm / filemap：添加folio_index（），folio_file_page（）和folio_contains（）matthew wilcox（Oracle）2021-06-14 20:14` [patch v11 14/33] mm / filemap：添加folio......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062362.html">Linux 5.13中的一对内存分配改进 </a></div><div class="item_title_en"><a target="_blank" href="https://lwn.net/SubscriberLink/855226/72737207b5650d33/">A pair of memory-allocation improvements in Linux 5.13</a><span>(lwn.net)</span></div><span class="my_story_list_date">2021-5-13 10:55</span><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters
我很确定它＆＃39;应该对一些像堆栈（你在列表中拿出一个页面时，你需要一个页面）。 ＆＃34;列表不太可能遍历＆＃34;意味着没有人可能需要随机访问列表元素（只是第一个项目）。
  如果我正确理解，列表将嵌入到结构页......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分配/">#分配</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061273.html">垃圾收集的事务记忆相似性 </a></div><div class="item_title_en"><a target="_blank" href="https://www.realworldtech.com/forum/?threadid=201184&curpostid=201369">Transactional memory similarity to garbage collection</a><span>(www.realworldtech.com)</span></div><span class="my_story_list_date">2021-5-7 19:3</span><div class="my_story_list_item_desc">Paul A. Clayton（Paaronclayton.delete@this.gmail.com）于4月5日，下午1:53写道：＆gt; [我在这里发布了这一点，因为它更普遍地适用于线程。]＆gt; ＆gt;这里的帖子关于硬件事务记忆似乎让人想起关于垃圾收集的讨论。 ＆gt;由于GC可以被定义为简单的自动内存管......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/收集/">#收集</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1058531.html">内存一致性和高速缓存相干性的引物（2020） </a></div><div class="item_title_en"><a target="_blank" href="https://www.morganclaypool.com/doi/pdf/10.2200/S00962ED2V01Y201910CAC049">A Primer on Memory Consistency and Cache Coherence (2020)</a><span>(www.morganclaypool.com)</span></div><span class="my_story_list_date">2021-4-16 0:51</span><div class="my_story_list_item_desc">该网站使用cookie来提高性能。如果您的浏览器不接受cookie，则无法查看此站点。
    有很多原因，为什么无法正确设置cookie。以下是最常见的原因：
  您在浏览器中禁用了cookie。您需要重置浏览器以接受cookie，或者询问您是否要接受cookie。
  您的浏览器会询问您是否要接受cookie，并......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/一致性/">#一致性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1057875.html">优先考虑内存安全迁移 </a></div><div class="item_title_en"><a target="_blank" href="https://noncombatant.org/2021/04/09/prioritizing-memory-safety-migrations/">Prioritizing Memory Safety Migrations</a><span>(noncombatant.org)</span></div><span class="my_story_list_date">2021-4-13 1:13</span><div class="my_story_list_item_desc">4月11日更新：请看看长时间的Live Sandboxing！尽管你可能已经听到了什么，但沙盒不死。
 随着使用RUDE的所有讨论减少内存不安的错误，Suchas Android在Android开源项目中使用RUST，有很多关于“重写锈病”（或任何其他更安全的语言）的高成本令人担忧的疑虑因为它经常是措辞。操作系统，W......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/考虑/">#考虑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1054089.html">当你有太多的绵羊山草 </a></div><div class="item_title_en"><a target="_blank" href="https://oldvcr.blogspot.com/2021/03/when-you-have-too-much-memory-for.html">When you have too much memory for SheepShaver</a><span>(oldvcr.blogspot.com)</span></div><span class="my_story_list_date">2021-3-23 6:30</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1054089.html"><img src="http://img2.diglog.com/img/2021/3/thumb_2eb4c290064a965c132dfd6a24330f81.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/绵羊/">#绵羊</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/warning/">#warning</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1053776.html">用页面阐明内存管理 </a></div><div class="item_title_en"><a target="_blank" href="https://lwn.net/SubscriberLink/849538/570c2c071df79f7d/">Clarifying memory management with page folios</a><span>(lwn.net)</span></div><span class="my_story_list_date">2021-3-21 17:26</span><div class="my_story_list_item_desc">你知道吗...？ LWN.NET是一个用户支持的出版物;我们依靠订阅者来保持整个操作。请通过购买订阅并在网上保留LWN来帮助。
   内存管理通常在页面的级别工作，这通常是4,096字节，但可能更大。但是，内核延长了页面的概念，包括复合页面，这是一个不连续的单页组。反过来，已经做出了A＆＃34的定义;页面＆＃34;有......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/阐明/">#阐明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/页面/">#页面</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1052892.html">Micron销售3D xpoint记忆Fab并停止进一步发展 </a></div><div class="item_title_en"><a target="_blank" href="https://www.tomshardware.com/news/micron-sell-3d-xpoint-fab-stop-development-intel">Micron to Sell 3D XPoint Memory Fab and Cease Further Development</a><span>(www.tomshardware.com)</span></div><span class="my_story_list_date">2021-3-17 8:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1052892.html"><img src="http://img2.diglog.com/img/2021/3/thumb_e6d681227e913f107bf77faf72e86439.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Micron今天宣布，它在Leti，犹他州销售其3D Xpoint Fab，结束了它生产它与英特尔开发的激进新的记忆技术。该公司计划在2021年底之前出售Fab，并完全退出3D XPoint业务。 Micron将停止由于该公司所说的＆＃34的需求而停止所有进一步发展3D Xpoint的产品;市场验证不足以证明在规模成......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/记忆/">#记忆</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/英特尔/">#英特尔</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1051988.html">蜗牛之间的内存转移，挑战记忆形成标准理论 </a></div><div class="item_title_en"><a target="_blank" href="https://www.statnews.com/2018/05/14/memory-transfer-between-snails-challenges-standard-theory/">Memory transfers between snails, challenges standard theory of memory formation</a><span>(www.statnews.com)</span></div><span class="my_story_list_date">2021-3-12 21:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1051988.html"><img src="http://img2.diglog.com/img/2021/3/thumb_fe77f329f8ecaae9197dc2dfb34c2430.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">洛杉矶 -  UCLA神经科学家在星期一报道，他们通过注射RNA将内存从一只动物转移到另一个动物，这是一种令人挑剔的挑战，挑战在大脑中储存在地点和记忆的广泛看法和如何存储在脑中。
 从David Glanzman的实验室提示，在恢复一天的基于RNA治疗的潜力下，恢复了丢失的记忆，如果正确，可以震动记忆和学习领域。
 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/标准/">#标准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/记忆/">#记忆</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048188.html">缓解开源软件中的内存安全问题 </a></div><div class="item_title_en"><a target="_blank" href="https://security.googleblog.com/2021/02/mitigating-memory-safety-issues-in-open.html">Mitigating Memory Safety Issues in Open Source Software</a><span>(security.googleblog.com)</span></div><span class="my_story_list_date">2021-2-18 10:33</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1048188.html"><img src="http://img2.diglog.com/img/2021/2/thumb_c0e1be35788304c1f8d3f08471141a59.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">缓解开源软件中的内存安全问题 </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045354.html">B细胞记忆的持久性：COVID免疫稳定性的提示 </a></div><div class="item_title_en"><a target="_blank" href="https://arstechnica.com/science/2021/01/the-persistence-of-memory-in-b-cells-hints-of-stability-in-covid-immunity/">The persistence of memory in B cells: Hints of stability in COVID immunity</a><span>(arstechnica.com)</span></div><span class="my_story_list_date">2021-1-20 22:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1045354.html"><img src="http://img2.diglog.com/img/2021/1/thumb_d0829809391cc62b0b57c04b42398779.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">免疫系统对SARS-CoV-2病毒的反应如何仍存在很多不确定性。但是，很明显的是，尽管在大流行初期暴露的人数不断增加，但再感染仍然非常罕见。这表明，至少对于大多数人而言，对病毒的免疫反应具有一定程度的长期记忆。
 但是免疫记忆是复杂的，并且涉及许多独特的免疫特征。很高兴知道SARS-CoV-2参与了哪些治疗，因为这将......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/记忆/">#记忆</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/抗体/">#抗体</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044170.html">InfiniCache：在临时无服务器功能之上构建的内存中缓存 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/mason-leap-lab/infinicache">InfiniCache: In-memory cache that is built atop ephemeral serverless functions</a><span>(github.com)</span></div><span class="my_story_list_date">2021-1-15 20:29</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1044170.html"><img src="http://img2.diglog.com/img/2021/1/thumb_aa16ca34802d7e14a8c399f336ea66b0.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">InfiniCache是​​同类中第一个，具有成本效益的，高性能的内存中对象缓存，它建立在临时云功能之上。 InfiniCache比传统的云缓存服务便宜31倍至96倍。
     2020年3月7日：更新了部署过程，并修复了deploy /下脚本中的错误（路径错误）。
  我们建议EC2代理和Lambda函数位于同一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042588.html">Postgres 13基准测试：内存速度与TPS </a></div><div class="item_title_en"><a target="_blank" href="https://info.crunchydata.com/blog/postgresql-13-benchmark-memory-speed-vs.-tps">Postgres 13 Benchmark: Memory Speed vs. TPS</a><span>(info.crunchydata.com)</span></div><span class="my_story_list_date">2020-12-31 2:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042588.html"><img src="http://img2.diglog.com/img/2020/12/thumb_9fa8c49e06e575b6227694b78b40f5b2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">有些人沉迷于运动或汽车。我遵循计算机硬件。 PC行业将超频而不是亚硝酸盐，plexi机箱而不是铬和RGB照明用作转轮。
 我喜欢的核心挑战是级联进行一些小的改进，以查看是否可以克服瓶颈。单个的改进通常只有几个百分点。当您将收益链接在一起时，收益百分比可能会增加。
 今天，我正在将主测试系统上的内存速度从2133MHz......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039585.html">观看1996年有关如何上网的教学视频，漫步在记忆里 </a></div><div class="item_title_en"><a target="_blank" href="https://arstechnica.com/gaming/2020/12/stroll-down-memory-lane-with-this-1996-instruction-video-on-how-to-internet/">Stroll down memory lane with this 1996 instructional video on How to Internet</a><span>(arstechnica.com)</span></div><span class="my_story_list_date">2020-12-14 23:23</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039585.html"><img src="http://img2.diglog.com/img/2020/12/thumb_3683da658ee8890ac188810c23b83f8e.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">互联网档案馆的内容丰富的图书馆是名副其实的数字内容宝库，其中包括来自现已淘汰的VHS等格式的媒体，目的是保护我们的文化遗产。例子：1996年的一段视频，您需要了解的一切... Internet简介（在假设为系列的目录中列出为95021）最近已上传到档案中。
 即使从最低的技术要求入手，也可以从其绝对的计算能力上感受到......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/教学/">#教学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览/">#浏览</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039379.html">编写内存分配器 </a></div><div class="item_title_en"><a target="_blank" href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/">Writing a Memory Allocator</a><span>(dmitrysoshnikov.com)</span></div><span class="my_story_list_date">2020-12-13 8:49</span><div class="my_story_list_item_desc">这是“垃圾回收算法”类的第六个讲座，专门讨论自动内存管理。
 在讨论收集垃圾的算法之前，我们需要了解如何将这些对象（最终成为垃圾）分配到堆上。在今天的讲座中，我们将讨论内存分配机制。
           如果您喜欢这项工作并觉得有用，请考虑捐赠以支持无广告的高质量教育。
  注意：另请参阅有关编写池分配器和编写标记......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037140.html">安装了多少物理内存？</a></div><div class="item_title_en"><a target="_blank" href="https://toroid.org/linux-physical-memory">How much physical memory is installed?</a><span>(toroid.org)</span></div><span class="my_story_list_date">2020-11-29 22:35</span><div class="my_story_list_item_desc">我经常想计算安装在运行Linux的系统中的物理内存的确切数量，今天我终于偶然发现了令人满意的解决方案：在/ sys / devices / system / memory下查看。我知道我已经在该系统中安装了16GB（或者如果您愿意，可以选择GiB）的内存。我一直觉得令free -greport之类的命令只有15GB作......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/物理/">#物理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036250.html">VSCode内存泄漏问题标记为“超出范围”</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/microsoft/vscode/issues/107999">VSCode memory leak issue marked “out-of-scope”</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-24 13:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036250.html"><img src="http://img2.diglog.com/img/2020/11/thumb_4b7d9ecba1881eda1176c27aaa7da297.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我想指出的是，自从我上个月进行测试（几个月前）以来，这似乎是一种回归，因为vscode的泄漏和非泄漏版本都使用相同的电子版本。但是，很抱歉，我没有做笔记，无法真正记住，也没有资源和时间将这种“回归”一分为二。我至少可以说的是，我仍然可以可靠地重现此内存泄漏。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035817.html">使用jemalloc在Go中手动进行内存管理</a></div><div class="item_title_en"><a target="_blank" href="https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/?repost=1">Manual Memory Management in Go using jemalloc</a><span>(dgraph.io)</span></div><span class="my_story_list_date">2020-11-22 6:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035817.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b245f67c3b3cbeea18876c89a1c8070.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">自2015年成立以来，Dgraph Labs一直是Go语言的用户。五年后，Go代码达到20万行，我们很高兴地报告，我们仍然坚信Go过去并且仍然是正确的选择。我们对Go的兴奋已经超出了构建系统的范围，甚至使我们甚至可以使用Go编写脚本，而这些脚本通常是用Bash或Python编写的。我们发现使用Go可以帮助我们构建干净......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jemalloc/">#jemalloc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035025.html">M1内存和性能</a></div><div class="item_title_en"><a target="_blank" href="https://blog.metaobject.com/2020/11/m1-memory-and-performance.html">M1 Memory and Performance</a><span>(blog.metaobject.com)</span></div><span class="my_story_list_date">2020-11-14 9:4</span><div class="my_story_list_item_desc">M1 Mac现在已经上市了，苹果不仅声称它们绝对是在冒烟，早期的基准测试似乎也证实了这些说法。我并不觉得这令人惊讶，自从Tiger以来，苹果一直高度关注性能，据我所知，从那以后就没有松懈过。M1的一个可能有点令人惊讶的方面是，它只有16G的内存限制。作为一个购买了16千字节的语言卡以在他的苹果上运行Merlin650......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034410.html">ARM内存模型工具：Morello(和一些内存标记)</a></div><div class="item_title_en"><a target="_blank" href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/memory-model-tool-morello-and-some-memory-tagging">ARM Memory Model Tool: Morello (and Some Memory Tagging)</a><span>(community.arm.com)</span></div><span class="my_story_list_date">2020-11-11 5:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034410.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c3c9efae39d7ebcf5fe1d3f84f835c39.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇文章介绍了Morello在内存模型工具中的实现。读者应该对该工具有一些了解，该工具已在前面的文章中介绍：如何使用herd7 Memory Model工具以及如何使用diy7工具自动生成石蕊测试的工作示例。
Morello是ARM开发的基于功能硬件增强型RISC指令(CHERI)的安全架构。更多信息可以在ARM M......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/morello/">#morello</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033606.html">使用jemalloc在围棋中进行手动内存管理</a></div><div class="item_title_en"><a target="_blank" href="https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/">Manual Memory Management in Go using jemalloc</a><span>(dgraph.io)</span></div><span class="my_story_list_date">2020-11-7 11:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1033606.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b245f67c3b3cbeea18876c89a1c8070.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Dgraph Labs自2015年成立以来一直是围棋语言的用户。五年来，我们用了20万行围棋代码，我们很高兴地告诉大家，我们仍然坚信围棋是正确的选择，无论是现在还是现在，我们都坚信围棋是正确的选择。我们对围棋的兴奋已经超越了构建系统，甚至让我们用围棋编写了脚本，这些脚本通常是用Bash或Python编写的。我们发现，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jemalloc/">#jemalloc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031649.html">教程：使用GO进行内存中Git克隆、提交和推送</a></div><div class="item_title_en"><a target="_blank" href="https://ish-ar.io/tutorial-go-git/">Tutorial: In-memory Git clone, commit and push using GO</a><span>(ish-ar.io)</span></div><span class="my_story_list_date">2020-10-28 7:16</span><div class="my_story_list_item_desc">今天的文章是关于如何设置和使用Go-Git库来克隆和更新具有内存文件系统的存储库的教程。如果您希望推送或克隆存储库，而不接触操作系统文件系统并处理权限或临时文件，则此过程非常有用。尽管有关于Git-Go的文档，但我发现由于库的版本和名称不同，所以不是很清楚，有时还会产生误导。基于这个原因，我决定分享这篇教程，希望能对......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029759.html">Linux中的ARM64内存标记扩展</a></div><div class="item_title_en"><a target="_blank" href="https://lwn.net/SubscriberLink/834289/a8f6c7c67ccca2c3/">The Arm64 memory tagging extension in Linux</a><span>(lwn.net)</span></div><span class="my_story_list_date">2020-10-19 17:57</span><div class="my_story_list_item_desc">LWN订户已向您提供以下仅限订阅的内容。数以千计的用户依赖LWN获取来自Linux和自由软件社区的最好消息。如果您喜欢这篇文章，请考虑接受右边的试用报价。感谢您访问LWN.net！
免费试用LWN 1个月：无需付款或信用卡。现在激活您的试用订阅，看看为什么成千上万的读者订阅LWN.net。
5.10内核开发周期合并的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lwn/">#lwn</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024660.html">无虚拟内存的软件内存管理的成本</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2009.06789">The Cost of Software-Based Memory Management Without Virtual Memory</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-9-18 3:10</span><div class="my_story_list_item_desc">下载PDF摘要：虚拟内存已经成为超过三年的标准硬件特性。以增加硬件复杂性为代价，它简化了软件，并承诺在托管进程之间实现强大的隔离。然而，在现代计算系统中，虚拟内存的成本已经显著增加。对于大内存工作负载、虚拟化环境、数据中心计算和带有多个DMA设备的芯片，虚拟内存可能会降低性能并提高功耗。因此，我们将探讨在不依赖硬件支......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟内存/">#虚拟内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024062.html">人类记忆存储类型</a></div><div class="item_title_en"><a target="_blank" href="https://iuliangulea.com/blog/how-people-learn-memory-storage-types/">Human Memory Storage Types</a><span>(iuliangulea.com)</span></div><span class="my_story_list_date">2020-9-15 14:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1024062.html"><img src="http://img2.diglog.com/img/2020/9/thumb_d13a057384c128feb1a1601fc4ddaca3.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">人类的记忆令人着迷。花点时间深入你最古老的回忆，唤起任何与以下内容相关的记忆：
正如“人们如何学习--大脑基础”一书中提到的那样，记忆是同时被激活的成熟的神经模式。这些电路编码了我们的记忆、能力、行为、知识等等。
有趣的是，有不同类型的内存存储，在本文中，我想描述一下它们是什么。
大自然在设计生命(和我们)方面做了一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/记忆/">#记忆</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/信息/">#信息</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023114.html">.NET内存性能分析</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md">.NET Memory Performance Analysis</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-10 7:45</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023114.html"><img src="http://img2.diglog.com/img/2020/9/thumb_bd043b2f03488bb96533bee0c04d1b3c.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">知道什么时候该担心它，如果你需要担心该怎么做。
本文档旨在帮助使用.NET开发应用程序的人员如何考虑内存性能分析，并在需要时找到执行此类分析的正确方法。在此上下文中，.NET包括.NET Framework和.NET Core。为了在垃圾收集器和框架的其余部分获得最新的内存改进，我强烈建议您使用.NET Core(如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gc/">#gc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019612.html">了解Haskell中的内存碎片</a></div><div class="item_title_en"><a target="_blank" href="https://www.well-typed.com/blog/2020/08/memory-fragmentation/">Understanding Memory Fragmentation in Haskell</a><span>(www.well-typed.com)</span></div><span class="my_story_list_date">2020-8-22 0:58</span><div class="my_story_list_item_desc">最近我为Hasura做了一些工作，调查了GraphQL-Engine中一些奇怪的内存行为。在测量内存使用情况时，我们可以询问操作系统(OS)我们的进程使用了多少内存，但是我们也可以使用GHC运行时系统(RTS)的堆分析器。在运行GraphQL-Engine基准之后，操作系统报告的服务器内存使用率远远高于GHC的堆分析......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008534.html">使用锈蚀检查ARM与x86内存型号</a></div><div class="item_title_en"><a target="_blank" href="https://www.nickwilcox.com/blog/arm_vs_x86_memory_model/">Examining ARM vs. x86 Memory Models with Rust</a><span>(www.nickwilcox.com)</span></div><span class="my_story_list_date">2020-6-27 16:4</span><div class="my_story_list_item_desc">随着苹果公司最近宣布，他们将在未来的笔记本电脑和台式机上从Intel X86 CPU转向他们自己的ARM CPU，我认为现在是一个很好的时机来看看可能会影响在Rust工作的系统程序员的一些差异。
ARM CPU与X86不同的一个关键方面是它们的内存模型。本文将介绍什么是内存模型，以及它如何在一个CPU上导致代码正确，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈蚀/">#锈蚀</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007060.html">Patchmap：内存高效的哈希表和伪随机排序</a></div><div class="item_title_en"><a target="_blank" href="https://1ykos.github.io/patchmap/">Patchmap: Memory Efficient Hash Tables and Pseudorandom Ordering</a><span>(1ykos.github.io)</span></div><span class="my_story_list_date">2020-6-18 13:49</span><div class="my_story_list_item_desc">我已经考虑好的散列函数很长时间了，所以将两次乘法和二进制轮换结合起来得到一个输出非常均匀的散列函数并不难。这类似于Malte Skarupke最终所做的，从黄金比例的单次乘法开始，也就是斐波纳契散列，然后用位移位合成它。伽罗瓦域乘法也是一个很好的积木，但我的笔记本电脑有点旧，因此很难进行无进位乘法。
最近我想计算大量......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/patchmap/">#patchmap</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/散列/">#散列</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item active"><a class="page-link" href="/tag/memory/">0</a></li><li class="page-item"><a class="page-link" href="/tag/memory/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>