<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>反应基础：我学到了什么</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">反应基础：我学到了什么</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 22:15:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/dab4eda0c0593d71ee40d9f2ba0248d3.jpg"><img src="http://img2.diglog.com/img/2020/11/dab4eda0c0593d71ee40d9f2ba0248d3.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At this moment in my career, I’m a Javascript fullstack developer in the early stages. I’ve a good knowledge of Javascript, however React gives me sometimes a little more than a headache to understand deeply. I grew up in my learning with class based components, so later, when hooks were introduced, I found a little difficult to transition to this new way of writing React. That’s why I wanted this course.</p><p>在我职业生涯的这个时刻，我是一名早期的Javascript全栈开发人员。我对Javascript有很好的了解，但是Reaction有时会让我更头疼才能深入理解。我是在学习基于类的组件的过程中长大的，所以后来，当钩子被引入时，我发现很难过渡到这种新的编写Reaction的方式。这就是我想上这门课的原因。</p><p> As part of my learning process, I’m going to note down not everything, but what I learnt, for each section. Often my solution was, although working, more complicated and less elegant than Kent’s one. That’s another aspect I wish to improve in my coding.</p><p>作为我学习过程的一部分，我不会记录下每一节的所有内容，而是记下我学过的每一节。通常，我的解决方案虽然可行，但比肯特的方案更复杂，也不那么优雅。这是我希望在编码中改进的另一个方面。</p><p> Of course you will find many more details and, well, the workshop itself directly in  epicreact.devI hope this will be useful to somebody else apart from me, and forgive my mistakes in English (not a native speaker).</p><p>当然，你会在epicreact中找到更多的细节和研讨会本身。dev.我希望这会对除我之外的其他人有用，并原谅我在英语方面的错误(不是以英语为母语的人)。</p><p>  In the first exercise, it’s necessary to make some DOM manipulation with plain Javascript. As I’m using this method in my daily work, I had no difficulties in the first part. As a matter of fact, I’m learning a lot into transforming a codebase that is heavily relying on jQuery into plain Javascript.</p><p>在第一个练习中，有必要使用普通Javascript进行一些DOM操作。由于我在日常工作中使用了这种方法，所以在第一部分中我没有遇到任何困难。事实上，在将严重依赖jQuery的代码库转换为普通Javascript的过程中，我学到了很多。</p><p> However, I did have to do some thinking on the additional exercise, as I’m not used to work with the root element of the body. So I personally didn’t know -but now that I know, it makes sense - that there’s a body object inside the document object. I won’t give here the solution, but it’s an important reminder to always check the parent elements… what are they hiding inside :)</p><p>然而，我确实不得不对额外的锻炼做了一些思考，因为我不习惯于处理身体的根元素。所以我个人并不知道-但现在我知道了，这很有意义-Document对象中有一个Body对象。我不会在这里给出解决方案，但这是一个重要的提醒，要始终检查父元素…。它们里面藏着什么：)。</p><p>  The second exercise of the workshop was already trickier - which I was happy about because definitely I didn’t want to learn again the same stuff.It’s not often, if ever, that we are using the React.createElement. Using JSX we just skip this part, but that’s how it works under the hood.So after learning what jQuery is doing in Javascript, now it’s React in Javascript.</p><p>研讨会的第二个练习已经更棘手了-我对此很高兴，因为我肯定不想再学同样的东西了。我们使用React.createElement的频率很低(如果有的话)。使用JSX我们只需跳过这一部分，但这就是它在暗中工作的方式。所以在了解了jQuery在Javascript中做了什么之后，现在它在Javascript中是Reaction。</p><p> First thing I learnt here is that the famous property ‘children’, in React, corresponds to textContent in plain JS. It makes sense, of course, as a matter of fact we are rendering some text made visually in HTML.</p><p>我在这里了解到的第一件事是，在REACTION中著名的属性‘Child’对应于普通JS中的textContent。当然，这是有意义的，事实上，我们正在呈现一些用HTML可视化生成的文本。</p><p> The second thing is that createElement has three - or more - arguments that can be passed.</p><p>第二件事是createElement有三个(或更多)可以传递的参数。</p><p>  As a matter of fact, the children property doesn’t even have to be defined inside the second argument of createElement, but can be listed at the end of the method.</p><p>事实上，甚至不必在createElement的第二个参数中定义Child属性，但可以在方法的末尾列出。</p><p>  The third exercise was about creating simple JSX elements that Babel will transform in normal JS with React.createElement. As it’s basically almost a reverse engineering of the previous exercises, it was not difficult. However, it was interesting the use of the spread operator inside a div element, which createElement puts in the correct position:</p><p>第三个练习是关于创建简单的JSX元素，Babel将使用React.createElement将这些元素转换为普通的JS。由于它基本上是前几次练习的反向工程，所以并不困难。但是，有趣的是，在div元素中使用了散布操作符，createElement将其放置在正确的位置：</p><p> const className = &#39;myClass&#39;;const children = &#39;this is my text&#39;;const props = { children, className }element = &lt;div {...props}/&gt;</p><p>Const className=&#39；myClass=#39；；const Children=&#39；This is my text&#39；；const props={Children，className}element=&lt；div{...props}/&gt；</p><p>  Another interesting point in the video is about prioritazion of position using the spread operator. Supposing that we have the above props, but then we want to override the className with another name, we have to place the spread props before. In synthesis, the right argument will always override the left ones.</p><p>视频中的另一个有趣之处是关于使用扩散操作符的位置优先排序。假设我们有上面的道具，但是我们想用另一个名称覆盖className，我们必须在放置道具之前放置散布道具。在综合中，右边的参数总是优先于左边的参数。</p><p>   So here we go finally to start creating components. The first part consists in creating a function that basically returns a div, so instead of repeating div div in the rendered element, we just pass the function with the string as “children”. One thing that I knew but forgot explicitly is that if I pass a parameter to the function as an object, the argument must be an object as well. So:</p><p>现在，我们终于开始创建组件了。第一部分在于创建一个基本上返回div的函数，因此我们不在呈现的元素中重复div div，而是将函数与字符串一起作为“Child”传递。我知道但显式忘记的一件事是，如果我将参数作为对象传递给函数，则该参数也必须是对象。所以：</p><p>      Following that, it’s about referring the same helloFunction but make it directly compiled through Babel as an element, without needing to pass through createElement. This is possible thanks to JSX, and it’s enough to make the function name with first letter as capital, and reference it inside the element object as that. HelloFunction = () = {}</p><p>接下来是引用相同的helloFunction，但将其作为元素直接通过babel编译，而不需要通过createElement。多亏了JSX，这是可能的，只需将函数名的第一个字母作为大写，并在Element对象中引用它就足够了。HelloFunction=()={}。</p><p>   Next, it was the time of implementing propTypes for typechecking, giving the same above function to have two parameters, both strings. In the workshop, it’s explained how to make a propTypes function for checking manually the type. But it’s interesting that it’s not taking advantage of the prop-types library. It is true that for a simple check of two props, importing a whole library is excessive; but I don’t think I’ll ever just use two checks.</p><p>接下来，是实现用于类型检查的proTypes的时候了，给出了具有两个参数(都是字符串)的相同的上述函数。在研讨会中，我们解释了如何制作用于手动检查类型的proTypes函数。但有趣的是，它没有利用道具类型库。诚然，对于两个道具的简单检查，导入整个库是过多的；但我认为我永远不会只使用两个检查。</p><p>   I’m not getting either a personalized message, but the standard warning is understandable enough</p><p>我也没有收到个性化的信息，但是标准的警告是可以理解的</p><p>  Ah, here we go, in the next exercise there’s the implementation of the library… ooooops, I went a little over head. But good point, to implement also ‘isRequired’</p><p>啊，我们开始吧，在下一个练习中有一个库…的实现。哎呀，我有点过头了。但好的一点是，要实现也是‘isRequired’</p><p>    In this exercise it was needed to apply style to a custom component in various ways. On a first part, just adding inline styling to a small div; then to a custom component passing its className prop; finally, passing only a string as a size prop and selecting dynamically the style inside the custom component.</p><p>在本练习中，需要以各种方式将样式应用到自定义组件。在第一部分，只需将内联样式添加到一个小div；然后添加到传递其className道具的自定义组件；最后，仅传递一个字符串作为大小道具，并在自定义组件内动态选择样式。</p><p> First note: when making a reusable component, normally it’s good to place all defaults on the left and what the user is providing (spread operator) after, because we don’t want to enforce something.</p><p>第一个注意事项：在制作可重用组件时，通常最好将所有缺省值放在左侧以及用户提供的内容(扩散操作符)之后，因为我们不想强制执行某些内容。</p><p> Second note: as usual I overcomplicated things. As the size property passed would be only small, medium and large, and the classes are called box—small, box—medium, box—large, it’s enough to substitute the size with the size prop passed into the component.</p><p>第二个注解：和往常一样，我把事情搞得过于复杂了。由于传递的Size属性将仅为Small、Medium和Large，并且类称为box-Small、Box-Medium、Box-Large，因此用传递给组件的Size道具替换Size就足够了。</p><p>  adding that to a ternary operator in case it’s the prop is not present.What I did instead was a nested ternary operator with an object created with the classes names inside. Much more complicated, although it was working 😁</p><p>将其添加到一个三元运算符中，以防它不是道具，我所做的是一个嵌套的三元运算符，其中包含一个用类名创建的对象。要复杂得多，尽管它使用的是😁。</p><p> const sizes = { small: &#39;box--small&#39;, medium: &#39;box--medium&#39;, large: &#39;box--large&#39;}className={`box ${size === &#39;small&#39; ? sizes.small : size === &#39;medium&#39; ? sizes.medium : sizes.large}`}</p><p>常量大小={Small：#39；box--Small&#39；，Medium：&#39；box--Medium&#39；，Long：&#39；box--Large&39；}className={`box${size=#39；Small&#39；？尺码。小：尺码=#39；中号？Sizes.Medium：sizes.Large}`}。</p><p>  In the first exercise, the object is creating a submit listener/handler that will call the function in the main component, which is passed through as a prop.</p><p>在第一个练习中，对象将创建一个提交侦听器/处理程序，它将调用作为道具传递的主组件中的函数。</p><p> We can put events (will be React synthetic events) on each element; however, the onSubmit goes inside the form to catch every field that is contained.Synthetic events are objects that React creates that look and behave like regular DOM events.It’s still possible to access the DOM event with  event.nativeEvent, however, the synthetic one is optimized to work with React code, and the virtual DOM.</p><p>我们可以将事件(将是Reaction合成事件)放在每个元素上；但是，onSubmit进入表单内部以捕获所包含的每个字段。合成事件是响应创建的对象，其外观和行为与常规DOM事件相似。仍然可以使用event.nativeEvent访问DOM事件，但是，合成事件已优化为使用Reaction代码和虚拟DOM。</p><p> I created then a function inside the function (a callback), called once the submit button is clicked. And I’ve added the preventDefault() to that event to prevent the page to refresh (as default event for a form).</p><p>然后，我在函数内创建了一个函数(回调)，一旦单击提交按钮就会调用该函数。我已经向该事件添加了brementDefault()，以防止页面刷新(作为表单的默认事件)。</p><p> Another interesting thing is about accessibility. Screen readers need to associate the input with its label. So it’s needed to give the input an id and the label a htmlFor (the same for= parameter in normal HTML). Moreover, this gives the property of focusing on the input when clicking on it.</p><p>另一个有趣的事情是关于可访问性。屏幕阅读器需要将输入与其标签相关联。因此需要为输入提供id和标签htmlFor(与普通HTML中的=参数相同)。此外，这提供了在单击输入时将焦点放在输入上的特性。</p><p> The second part of the exercise was about doing the same as above but using the useRef hook. UseRef are simply reference pointers to an element.First, it’s needed to be imported from ‘react’ and not ‘react-dom’.</p><p>练习的第二部分是关于执行与上面相同的操作，但使用useRef挂钩。UseRef只是指向元素的引用指针，首先，它需要从“action”而不是“action-dom”导入。</p><p> Then, adding the reference to our input &lt;input ref={usernameInput}&gt;In the main function (or custom component), we can call the hook:  const usernameInput = useRef(null);Why null? The argument of useRef is the initial value. But in this case we don’t need that, just what will be in usernameInput.</p><p>然后，将引用添加到Main函数(或自定义组件)中的输入&lt；input ref={usernameInput}&gt；，我们可以调用钩子：const usernameInput=useRef(Null)；为什么是null？UseRef的参数是初始值。但在本例中，我们不需要这些，只需要usernameInput中的内容。</p><p> Finally, we can access all our referenced properties, like the input value, this way:  usernameInput.current.value</p><p>最后，我们可以通过以下方式访问所有引用的属性，如输入值：usernameInput.current.value。</p><p> In the next credit, it was needed to create a controlled input. A controlled input is an input field that is controlled by the component state. That means setting the value of the input by the state:  &lt;input ref={usernameInput} value={username} onChange={handleChange} /&gt;</p><p>在下一个积分中，需要创建受控输入。受控输入是由组件状态控制的输入字段。这意味着通过以下状态设置输入值：&lt；input ref={usernameInput}value={username}onChange={handleChange}/&gt；</p><p> Then, we can set the state at the top of the component:  const [username, setUsername] = useState(&#39;&#39;);And finally, use that state to change the value of the input in the handleChange function. In this case, transforming every key to lowercase:</p><p>然后，我们可以在组件顶部设置状态：const[username，setUsername]=useState(&#39；&#39；)；最后，使用该状态更改handleChange函数中输入值。在本例中，将每个关键点转换为小写：</p><p>  So the flow is the following:input from user —&gt; update input state —&gt; transforming input state -&gt; sending the state as value of the input —&gt; input appears on screens.</p><p>因此流程如下：来自用户的输入-&gt；更新输入状态-&gt；转换输入状态-&gt；将状态作为输入的值发送-&&gt;输入出现在屏幕上。</p><p>  The exercises were just little demonstrations in this case, to show the importance of using a unique index key when showing elements in the DOM through a mapping. Not without, not with the pre-built index of the map function, but with a preset set of keys to use. This allows also React to keep the state of the inputs even with continuous rendering.</p><p>在本例中，这些练习只是一个小小的演示，目的是展示在通过映射显示DOM中的元素时使用唯一索引键的重要性。不是没有，不是使用MAP函数的预置索引，而是使用一组预设的键来使用。这还允许Reaction保持输入的状态，即使在连续渲染的情况下也是如此。</p><p> Not doing so is a mistake that leads to any kind of unpredictable behavior. I did this time ago and it also cost me many points in an interview.</p><p>不这样做是一个错误，会导致任何类型的不可预测的行为。这是我以前做过的，在面试中也花了我很多分。</p><p>  This is all for the Epic React Fundamentals section. I already know that the next workshops will be more challenging, but it was useful to know/be reminded of some basics.</p><p>这就是史诗反应基础部分的全部内容。我已经知道接下来的工作坊会更有挑战性，但是知道/被提醒一些基础知识是很有用的。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://buaiscia.github.io/posts/learning-on-epic-react-fundamentals">https://buaiscia.github.io/posts/learning-on-epic-react-fundamentals</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/基础/">#基础</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/输入/">#输入</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>