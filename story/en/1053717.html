<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从线性撤消历史记录构造撤消树 Construct an Undo Tree from a Linear Undo History</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Construct an Undo Tree from a Linear Undo History<br/>从线性撤消历史记录构造撤消树 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-21 05:28:37</div><div class="page_narrow text-break page_content"><p>Emacs comes with a powerful but arguably strange undo system, it considers the action of undo themselves undo-able, so instead of redo, you just undo a previous undo. This allows you to return to every previous buffer state, something a conventional undo system doesn’t guarantee. But Emacs’s undo history can easily get out of hand when you undo, then undo that undo, then undo the undo of undo… You lose your mental model of the undo history very quickly and end up holding the undo button until you see the desired buffer state.</p><p>Emacs带来了一个强大但可观的奇怪的撤消系统，它考虑了撤消自己撤消的动作，所以而不是重做，你只是撤消以前的撤消。这允许您返回每个先前的缓冲状态，传统的撤消系统无法保证。但是，当你撤消时，Emacs的撤消历史可以很容易地摆脱手，然后撤消该撤消，然后撤消撤消的撤消......你很快就丢失了撤消历史记录的心理模型，并最终保持撤消按钮，直到看到所需的缓冲区状态。</p><p> One idea to take advantage of both worlds is to use an undo tree. An undo tree is easy to navigate and understand. The ubiquitous  undo-tree.el is exactly for that. As a coding challenge, I have been thinking about how to construct a tree out of the linear undo record. That way we can avoid keeping an internal data structure of undos like undo-tree does. This post describes the way I figured out to do that.</p><p> 一个想法利用两个世界都是使用撤消树。撤消树易于导航和理解。无处不在的undo-tree.el正是为此。作为一个编码挑战，我一直在考虑如何从线性撤消记录中构建树。这样，我们可以避免保持撤消树的内部数据结构。这篇文章描述了我弄清楚的方式。</p><p> ;;  An example of ` buffer-undo-list &#39;. (nil  (11369 . 11377 )  ;  Insertion from 11369 to 11377. nil  (11332 . 11344 )  ;  Insertion from 11332 to 11344.  ( &#34;&lt;li&#34; . 11332 )  ;  Deleteion of &#34;&lt;li&#34; to 11322. nil  (t 24653 33109 208947 953000 ) )</p><p> ;; “缓冲区撤消列表”＆＃39; （NIL（11369 11377）;从11369插入113777.nil（11332。11344）;从11332到11344插入。（＆＃34;＆lt; li＆＃34; 11332）;＆＃34;＆lt; Li＆＃34;到11322.nil（t 24653 33109 208947 953000））</p><p> Emacs keeps undo records in  buffer-undo-list. Every time the buffer content changes, Emacs pushes multiple entries onto the list, each representing a change like insertion, deletion, etc. These entries are grouped by the  nil entries as delimiters, so multiple actions can be undone at once. Here I’ll call a group of entries a “modification”.</p><p> EMACS在缓冲区撤消列表中保留撤消记录。每次缓冲内容更改时，EMAC都会将多个条目推到列表上，每个条目都表示插入，删除等更改。这些条目由NIL条目分组为分隔符，因此可以立即撤消多个操作。在这里，我将调用一组条目“修改”。</p><p> For example, if I insert “ABCDE” into a buffer   1, and undo twice, I’ll see “ABC” in the buffer, and two undo modifications would be pushed onto  buffer-undo-list, one for deleting “E” and the other “D”. If we keep undoing, we will keep going back until all edits are undone.</p><p> 例如，如果我将“abcde”插入缓冲区1，并且撤消两次，我将在缓冲区中看到“abc”，并且将推到两个撤消修改，然后将两个用于删除“e”的缓冲区 -  undo-list。另一个“D”。如果我们继续撤消，我们将继续返回，直到所有编辑都已撤消。</p><p> To stop undo and start redo, we press  C-g which breaks the undo chain   2. All the undo records we just created are now considered ordinary modifications and further undo undoes these previous undo’s. So if we undo twice, we are back to “ABCDE”.</p><p> 为了停止撤消并开始重做，我们按下撤消撤消链的C-G。我们刚刚创建的所有撤消记录现在被认为是普通修改，并进一步撤消这些以前的撤消。所以，如果我们撤消两次，我们就会恢复到“ABCDE”。</p><p> How does this “undo chain” work? When we invoke the first undo command, it sets  pending-undo-list to the value of  buffer-undo-list; further undo commands pop modifications from  pending-undo-list and extend  buffer-undo-list. And when we break the undo chain, the next undo command will once again set  pending-undo-list to the value of  buffer-undo-list.</p><p> 这个“撤消链”的工作如何？当我们调用第一个undo命令时，它将待定 - 撤消列表设置为缓冲区撤消列表的值;进一步撤消命令从挂起 - 撤消列表中弹出修改并扩展缓冲区撤消列表。当我们打破撤消链时，下一个undo命令将再次将待定 - 撤消列表设置为缓冲区撤消列表的值。 </p><p> Here’s what happens when branching occurs: if we undo to “ABC”, and insert “F”. Emacs simply pushes a new modification to  buffer-undo-list, just like before.</p><p>以下是在分支发生时发生的事情：如果我们撤消到“ABC”，并插入“F”。 EMACS只需将新的修改推动到缓冲区撤消列表“之前。</p><p> Besides extending  buffer-undo-list, Emacs also maps buffer states to their equivalents. After Emacs undid a modification, it maps the tip of  buffer-undo-list to the tip of  pending-undo-list in  undo-equiv-table. This is the key to construct a tree from the linear undo list.</p><p> 除了扩展缓冲区撤消列表外，EMAC还将缓冲区状态映射到它们的等同物。 Emacs未知修改后，它将缓冲区 - 撤消列表的尖端映射到undo-Equiv-table中的撤消撤消列表提示。这是从线性撤消列表构造树的关键。</p><p> BTW, as shown in the figure,  pending-undo-list and  buffer-undo-list are really pointing to the same list object, just different cons cells in that list.</p><p> BTW，如图所示，撤消撤消列表和缓冲区撤消列表实际指向同一列表对象，即该列表中的不同CONS单元格。</p><p> Here is an example undo tree and the corresponding undo list. The undo list can be viewed as “wrapping around” the tree. To “construct” the tree out of the undo list, we need to know:</p><p> 以下是一个示例撤消树和相应的撤消列表。撤消列表可以被视为“包裹”树。要从撤消列表中“构造”树，我们需要知道：</p><p> Which node to show. In the list, node 5 and 6 are duplicates of earlier nodes and don’t need to appear in the tree.</p><p> 要显示哪个节点。在列表中，节点5和6是早期节点的重复项，不需要出现在树中。</p><p> Establish parent-child relationships between nodes. Starting with node 0, it needs to know node 1 is its child, node 1 needs to know 2 is its child, and so on.</p><p> 在节点之间建立父子关系。从节点0开始，它需要知道节点1是它的孩子，节点1需要知道2是它的孩子，等等。</p><p> Both are easy to figure out with the help of  undo-equvi-table: For a modification  m (the modification that creates buffer state  m), if it is an ordinary change, buffer state  m must be a child of  m-1; if  m is an undo change, then buffer state  m must be equivalent to a previous node, say,  n.  m equivalent to  n means 1) we don’t draw  m in the tree, only  n, and 2) children of  m are children of  n.</p><p> 在undo-equvi-table的帮助下很容易弄清楚：对于修改m（创建缓冲状态m的修改m），如果它是普通的变化，则缓冲状态m必须是m-1的一个孩子;如果m是撤消更改，则缓冲状态m必须等同于上一个节点，例如，n。 m相当于n意味着1）我们不在树中画m，只有n和2）m的孩子是n的孩子。 </p><p> In this example, 2 is an ordinary modification, so 2 is a child of 1. 6 is an undo modification and is equivalent to 2, so we don’t draw 6, only 2; and 6’s child, 7, becomes 2’s child.</p><p>在这个例子中，2是普通的修改，所以2是1. 6的孩子是撤消修改，相当于2，所以我们不绘制6，只有2;和6个孩子，7，成为2个孩子。</p><p> So it turns out that constructing the tree is simple: we first go over  buffer-undo-list to generate a list of modifications. Then we go over the modification list, identify equivalent nodes and establish parent-child relationships. In the end, we can draw out the tree starting from the first node, either depth-first or breadth-first.</p><p> 所以它结果，构造树很简单：我们首先转过缓冲区 - 撤消列表以生成修改列表。然后我们浏览修改列表，识别等效节点并建立父子关系。最后，我们可以从第一个节点开始绘制树，深度第一或宽度。</p><p> Drawing out the tree is only half the story, the undo tree isn’t of any use if we can’t go back and forth in time by moving around on the tree. Say we are at node  m and want to move to node  n. What should Emacs do to bring us back?</p><p> 绘制树只有一半的故事，如果我们不能在树上移动，那么撤消树就不能及时地走向。假设我们在节点m并希望移动到节点n。 Emacs应该让我们回来什么？</p><p> My immediate thought is to just repeatedly call  undo until we are at node  n. It works, but only within 10 yards: simple movements could easily explode the undo list. For example, suppose we are at node 1 and move back to node 0, what happens to the undo list?</p><p> 我的直接思想是刚刚在我们处于节点n之前反复调用撤消。它有效，但只有在10码范围内：简单的动作很容易爆炸撤消列表。例如，假设我们处于节点1并返回到节点0，撤消列表会发生什么？</p><p> We need to undo from 9 all the way back to 0, going back and forth between 1 and 3. Worse, if we now want to go from 0 to 1, we need to undo from 18 to 1. The undo list doubles every time we move back and forth between 0 and 1.</p><p> 我们需要从9次撤消回到0，前回到1到3之间。更糟糕，如果我们现在想要从0到1，我们需要从18到1撤消。撤消列表每次都会加倍我们来回移动到0到1之间。</p><p> Hmm, if we are in an undo chain, undoing from 1 to 0 would be so much easier:  pending-undo-list would point at 1 (instead of 9), and we simply undo modification 1. Why don’t we just do that, regardless of whether we are in an undo chain? During chained undo,  undo pops modifications from  pending-undo-list and feeds them into  primitive-undo. We can similarly find the modification between 0 and 1 and just feed it to  primitive-undo.</p><p> 嗯，如果我们处于撤消链，从1到0撤消将是如此简单：撤消撤消列表将指向1（而不是9），我们只需撤消修改1.为什么我们不做这是，无论我们是在撤消链吗？在链接期间，撤消从撤消撤消列表中的修改并将其送入原始撤消。我们可以类似地找到0到1之间的修改，并将其归因于原始撤消。</p><p> Let’s look at it more closely. If I want to go from buffer state 1 to 2, how do I find a list of modifications to feed to  primitive-undo? We can feed it modification 5 to go 5–4, or modification 9 to go 9–8, both of them move us back to the buffer state at node 2. Or we can even go 9–8–7–6–5–4, or 5–4–3–2.</p><p> 让我们更仔细地看看它。如果我想从缓冲状态1到2，如何找到馈送到原始撤消的修改列表？我们可以将其馈送到5-4，或修改9到9-8，两者都将我们返回到节点2的缓冲状态。或者我们甚至可以去9-8-7-6-5- 4，或5-4-3-2。 </p><p> So, to find a valid “route” from  m to  n, it needs to satisfy: 1) the start is equivalent to  m and the destination is equivalent to  n, and 2) the start is older than the destination, i.e.,  start &gt;  end, because  primitive-undo can only take us backwards in the undo list. Once we found all the valid routes, we pick the shortest one and feed it to  primitive-undo, teleport!</p><p>因此，要从M到N找到有效的“路由”，它需要满足：1）开始等同于M，目的地等同于n，2）开始比目的地较大，即，启动＆gt ;结束，因为原始 - 撤消只能在撤消列表中倒退。一旦我们找到了所有有效的路线，我们都会选择最短的路线并将其喂给原始撤消，传送！</p><p> ;;  Simplified definition of ` vundo-m &#39;. ( cl-defstruct  vundo-m  ;;  As a modification in the mod list: idx undo-list  ;;  A doubly-linked list of equivalent states: prev-eqv next-eqv  ;;  As a node in the tree: children parent point )</p><p> ;;简化的“vundo-m＆＃39; （cl-defstruct vundo-m ;;作为mod列表中的修改：idx undo-list ;;一个双链接的等价状态列表：prev-eqv next-eqv ;;作为树中的节点：儿童父点）</p><p> Github, and  local backup. The package requires the current development branch of Emacs, i.e., Emacs 28. The flow of the program is roughly:</p><p> github和本地备份。该包装需要Emacs的当前开发分支，即Emacs 28.程序的流程大致：</p><p> Kick-start the process in  vundo--refresh-buffer. It determines if we are generating everything from scratch, or incrementally updating our data.</p><p> 启动vundo  - 刷新缓冲区中的进程。它确定我们是否正在从头开始生成所有内容，或逐步更新我们的数据。</p><p> Each modification is stored in a  vundo-m struct, it also represents the corresponding buffer state and the corresponding node in the tree.</p><p> 每个修改都存储在vundo-m struct中，它还表示相应的缓冲状态和树中的相应节点。</p><p> 1  Normally when you insert “ABCDE”, the individual changes are amalgamated into one. Here, for demonstration’s sake, we assume each insertion creates a separate record.</p><p> 1通常在插入“ABCDE”时，单个更改将分配为1。在这里，为了演示，我们假设每个插入都会创建一个单独的记录。</p><p>  3  Although the cons cells are not released,  buffer-undo-list does shrink. That’s fine because all the information we need are stored in our data structures, which don’t change.</p><p>  3虽然未释放CONS单元格，但缓冲区撤消列表确实会缩小。这很好，因为我们所需的所有信息都存储在我们的数据结构中，这不会改变。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://archive.casouri.cat/note/2021/visual-undo-tree/index.html">https://archive.casouri.cat/note/2021/visual-undo-tree/index.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/撤消/">#撤消</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/undo/">#undo</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>