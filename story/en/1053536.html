<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在ECTO（2019）中撰写查询 How to Compose Queries in Ecto (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Compose Queries in Ecto (2019)<br/>如何在ECTO（2019）中撰写查询 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 09:10:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/ee381a199a4607d39a26980fd4d9884d.png"><img src="http://img2.diglog.com/img/2021/3/ee381a199a4607d39a26980fd4d9884d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I’ve been working with Ecto for a little bit now and I keep finding that it can be really helpful to make my queries composable. By that, I mean creating functions that take in a query and return a query so that I can pipe multiple of these query functions together.</p><p>我现在一直在使用Ecto，我一直发现让​​我的疑问可以是非常有帮助的。由此，我的意思是创建在查询中取出的函数并返回查​​询，以便我可以将这些查询函数的倍数在一起。</p><p> Recently, I ran into an issue that I hadn’t seen before and took me some time to get through. The issue was having multiple parts of my query join to different tables (or even join through the same table!). If you want to skip to that, just jump to the end of the blog post  Composing With Multiple Joins.</p><p> 最近，我遇到了一个问题，我以前没见过，带我走了一些时间来完成。该问题是我的查询的多个部分加入不同的表（甚至通过同一个表！）。如果您想跳过那个，只需跳转到博客文章的结尾，编写多个连接。</p><p> tl;dr Using the    as:  option when joining and checking to see if a query already has a join with    has_named_binding?/2  allows you to compose multiple queries that need to do joins</p><p> TL; DR使用AS：选项在加入和检查时查看是否已查询已具有has_named_binding的连接？/ 2允许您撰写需要执行的多个查询</p><p> For everyone else, I’m going to walk through building composable queries from a single query in this post. And to do that, let’s take a look at some cars.</p><p> 对于其他人来说，我将通过在这篇文章中的一个查询中建立可协调的疑问。为此，让我们看看一些汽车。</p><p>  I’m going to be running my queries against a project I’ve made for this blog post called  EctoCars. Follow the steps for the Getting Started section of the repo readme if you want to follow along!</p><p>  我将在为我为这个名为Ectocars的博客文章而制作的项目上运行我的疑问。按照Repo Readme的入门部分的步骤进行操作，如果您要遵循！</p><p>  This image is to help you understand the database domain we’ll be making queries against. There are different transmissions (automatic, manual) and engines (120hp, 250hp). A specification has a transmission and an engine. A car has a specification, a color, a vin number (we don’t need that for this, but it’s just a unique identifier), and a name.</p><p>  此图像是帮助您了解我们将要查询的数据库域。有不同的传输（自动，手动）和发动机（120hp，250hp）。规格具有传输和发动机。一辆汽车有一个规范，一种颜色，VIN号码（我们不需要这个，但它只是一个唯一的标识符）和一个名称。</p><p>  Alright, let’s start this off with a nice simple query. Let’s just find all of the blue cars. For this, we really just need   Ecto.Query.where/3. I like using the  expressions syntax as opposed to the keyword syntax for nice pipe-ability, so we’ll be looking at those examples moving forward. Now I said I wanted to find all the blue cars, but lets make this function a little more reusable so that it can take in any color. To do that, we could have something like this:</p><p>  好吧，让我们用一个很好的简单查询开始这个。让我们找到所有的蓝色汽车。为此，我们真的只需要ecto.query.where / 3。我喜欢使用表达式语法而不是关键字语法进行漂亮的管道能力，所以我们将看看向前移动的示例。现在我说我想找到所有的蓝色车，但是让这函数一点可重复使用，以便它可以采用任何颜色。为此，我们可以有这样的东西： </p><p>  Now to try this out, let’s hop into our IEX session and let’s try out this query by running  EctoCars.Car.with_color(“blue”) |&gt; EctoCars.Repo.all():</p><p>现在要尝试一下，让我们跳进入我们的IEX会话，让我们通过运行异常ex.car.with_color（“blue”）|＆gt; ectocars.repo.all（）：</p><p> iex(1)&gt; EctoCars.Car.with_color(&#34;blue&#34;) |&gt; EctoCars.Repo.all() 18:07:08.057 [debug] QUERY OK source=&#34;cars&#34; db=0.6ms decode=1.1ms queue=1.1ms SELECT c0.&#34;id&#34;, c0.&#34;color&#34;, c0.&#34;vin_number&#34;, c0.&#34;specification_id&#34; FROM &#34;cars&#34; AS c0 WHERE (c0.&#34;color&#34; = $1) [&#34;blue&#34;] [  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 1,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 3,  vin_number: &#34;too_small&#34;  },  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 3,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 1,  vin_number: &#34;my_dream_car&#34;  },  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 4,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 2,  vin_number: &#34;cant_drive_this&#34;  } ]</p><p> IEX（1）＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; Ectocars.repo.all（）18：07：08.057 [Debug]查询OK源=＆＃34;汽车＆＃34; DB = 0.6ms解码= 1.1ms队列= 1.1ms选择C0。＆＃34; ID＆＃34;，C0。＆＃34;颜色＆＃34;，C0。＆＃34; VIN_NUMBER＆＃34;，C0。＆C0。＆＃34; 34;规格_id＆＃34;来自＆＃34;汽车＆＃34;作为C0哪里（C0.＆＃34;颜色＆＃34; = $ 1）[＆＃34;蓝色＆＃34;] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：loaded，＆＃34;汽车＆ ＃34;＆gt;，颜色：＆＃34;蓝色＆＃34; ID：1，规范：＃ecto.association.notloaded＆lt;关联：规范未加载和gt; specification_id：3，vin_number：＆＃34; somall＆＃34; 34; }，％ectocars.car {__meta__：#eco.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：3，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，gt; specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：4，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，规范_ID：2，Vin_number：＆＃34; cant_drive_this＆＃34; }]</p><p> This is looking great, but I really just want the one ideal car for me, not three. Go ahead and try out the query with other colors if you like!</p><p> 这看起来很棒，但我真的只想要一个理想的汽车给我，而不是三辆。继续，如果您愿意，请使用其他颜色尝试查询！</p><p>   Now let’s make our query a little more complex. I can’t really drive a manual car (the last time I tried was with a car with a dead battery and the guy at the lot did not like having to get out and jump the car so many times…), so it’s probably best if I look for an automatic car.</p><p>   现在让我们让我们的查询更加复杂。我真的无法驾驶一辆手动车（我最后一次尝试用一辆带着一辆带有死亡电池的汽车和那个那么多的那家伙，不想出去跳到这么多次......），所以这可能是最好的如果我寻找自动车。</p><p> To accomplish this, we’re going to have to  join to our transmissions table through our specifications table:</p><p> 为实现这一目标，我们将通过我们的规格表加入我们的传输表：</p><p>  You’ll notice here we actually had to join twice to accomplish this. Once through specification and then again to transmission. We again made this query function re-usable by accepting the type of transmission as an argument and then using that in the  where clause at the end.</p><p>  你会在这里注意到我们实际上必须加入两次来实现这一目标。一旦通过规范，然后再次传输。我们再次通过接受作为参数的传输类型然后在末尾的WHERE子句中使用该查询功能可重新使用此查询功能。</p><p> One thing to make sure to be aware of is that the list of letters that we are using as the third argument to  join are just variables that are bound. In the second join for example, there is nothing special about using  [c, s]. Those letters make sense to us because they were the same letters used in the previous function call. If we changed the  s in the second join to another letter, it would not change the query at all. (This will be more important later!)</p><p> 一件事要肯定会意识到我们使用的是要加入的第三个参数的字母列表只是绑定的变量。例如，在第二个连接中，使用[C，S]没有什么特别的。那些字母对我们有意义，因为它们是先前函数调用中使用的相同字母。如果我们在第二个连接到另一个字母中将s更改为时，它根本不会更改查询。 （这将更加重要！） </p><p>  iex(3)&gt; EctoCars.Car.with_transmission(&#34;automatic&#34;) |&gt; EctoCars.Repo.all() 16:33:16.127 [debug] QUERY OK source=&#34;cars&#34; db=3.3ms decode=1.4ms queue=2.8ms SELECT c0.&#34;id&#34;, c0.&#34;color&#34;, c0.&#34;vin_number&#34;, c0.&#34;specification_id&#34; FROM &#34;cars&#34; AS c0 LEFT OUTER JOIN &#34;specifications&#34; AS s1 ON c0.&#34;specification_id&#34; = s1.&#34;id&#34; LEFT OUTER JOIN &#34;transmissions&#34; AS t2 ON s1.&#34;transmission_id&#34; = t2.&#34;id&#34; WHERE (t2.&#34;type&#34; = $1) [&#34;automatic&#34;] [  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 3,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 1,  vin_number: &#34;my_dream_car&#34;  },  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;red&#34;,  id: 2,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 1,  vin_number: &#34;wrong_color&#34;  },  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 1,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 3,  vin_number: &#34;too_small&#34;  } ]</p><p>IEX（3）＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; ectocars.repo.all（）16：33：16.127 [debug]查询ok源=＆＃34;汽车＆＃34; db = 3.3ms解码= 1.4ms队列= 2.8ms选择c0。＆＃34; id＆＃34;，c0。＆＃34;颜色＆＃34;，c0。＆＃34; vin_number＆＃34;，c0。＆＃34; 34;规格_id＆＃34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;在哪里（T2。＆＃34;类型＆＃34; = $ 1）[＆＃34;自动＆＃34;] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34 ;＆gt;，颜色：＆＃34;蓝色＆＃34;，ID：3，规范：＃ecto.association.notloaded＆lt;关联：规范没有加载，规范，specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;红色＆＃34; id：2，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，规范，规格_id：1，Vin_number：＆＃34;错误_color＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：1，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载＆gt;，specification_id：3，vin_number：＆＃34; som_small＆＃34; }]</p><p> Perfect! Just what we were looking for, all of the automatic cars. Again though, too many cars to choose from.</p><p> 完美的！只是我们在寻找的东西，所有的自动汽车。虽然，太多的汽车可供选择。</p><p>   Now what if I’m really looking for all cars with an automatic transmission that are also blue. Well, instead of writing a whole new query, it would be great if we could just reuse the two existing ones.</p><p>   现在，如果我真的在寻找具有蓝色的自动变速器的所有汽车。好吧，而不是写一个全新的查询，如果我们可以重复使用两个现有的那些，这将是很棒的。</p><p> To do this, we’re going to have to refactor the functions a bit to not just take in an argument of type/color, but also an existing query to add on to:</p><p> 为此，我们将不得不重构函数一点，不仅仅是掌握类型/颜色的参数，还可以将现有查询添加到：</p><p>  By making the first argument optional, we can choose to pass in a query we’re in the process of building, or we’ll just default to querying off of the cars table. We can now chain these as if we were just building one long Ecto query:  EctoCars.Car |&gt; EctoCars.Car.with_color(“blue”) |&gt; EctoCars.Car.with_transmission(“automatic”) |&gt; EctoCars.Repo.all():</p><p>  通过使第一个参数可选，我们可以选择在Query中传递我们在建设过程中，或者我们将默认默认为汽车表询问。我们现在可以将这些仿佛刚刚构建一个长的Ecto查询：Ectocars.car |＆gt; ectocars.car.with_color（“蓝色”）|＆gt; Ectocars.car.with_transmission（“自动”）|＆gt; ectocars.repo.all（）：</p><p> iex(5)&gt; EctoCars.Car |&gt; EctoCars.Car.with_color(&#34;blue&#34;) |&gt; EctoCars.Car.with_transmission(&#34;automatic&#34;) |&gt; EctoCars.Repo.all() 16:43:18.287 [debug] QUERY OK source=&#34;cars&#34; db=4.0ms queue=9.5ms SELECT c0.&#34;id&#34;, c0.&#34;color&#34;, c0.&#34;vin_number&#34;, c0.&#34;specification_id&#34; FROM &#34;cars&#34; AS c0 LEFT OUTER JOIN &#34;specifications&#34; AS s1 ON c0.&#34;specification_id&#34; = s1.&#34;id&#34; LEFT OUTER JOIN &#34;transmissions&#34; AS t2 ON s1.&#34;transmission_id&#34; = t2.&#34;id&#34; WHERE (c0.&#34;color&#34; = $1) AND (t2.&#34;type&#34; = $2) [&#34;blue&#34;, &#34;automatic&#34;] [  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 1,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 3,  vin_number: &#34;too_small&#34;  },  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 3,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 1,  vin_number: &#34;my_dream_car&#34;  } ]</p><p> IEX（5）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; ectocars.repo.all（）16：43：18.287 [debug]查询ok source =＆＃34;汽车＆＃34; DB = 4.0ms Queue = 9.5ms选择C0。＆＃34; ID＆＃34;，C0。＆＃34;颜色＆＃34;，C0。＆＃34; Vin_number＆＃34;，C0。＆＃34; specification_id＆＃34; 34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;在哪里（C0。＆＃34;颜色＆＃34; = $ 1）和（t2。＆＃34;类型＆＃34; $ 2; $ 2）[＆＃34;蓝色＆＃34 ;,＆＃34;自动＆＃34;] [ ％Eectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34; id：1，规格：＃ecto.association。未载荷＆lt;关联：规范未加载，规范，规格_id：3，Vin_number：＆＃34; too_small＆＃34; }，％ectocars.car {__meta__：#eco.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：3，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，gt; specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }]</p><p> And there we have it! A composable query that finds me the car I’m looking for. But what about the cars engine? Maybe I want a car with more than 200 horse power.</p><p> 我们终于得到它了！一个可协议的查询，找到我正在寻找的汽车。但是汽车引擎呢？也许我想要一辆拥有超过200马力的汽车。 </p><p>  So following along with what we were doing before, let’s create a query function for the engine:</p><p>因此，随着我们之前所做的操作，让我们为引擎创建一个查询函数：</p><p>   iex(10)&gt; EctoCars.Car |&gt; EctoCars.Car.with_color(&#34;blue&#34;) |&gt; EctoCars.Car.with_transmission(&#34;automatic&#34;) |&gt; EctoCars.Car.with_engine_horse_power(200) |&gt; EctoCars.Repo.all() ** (Ecto.QueryError) lib/ecto_cars/cars/car.ex:37: field `horse_power` in `where` does not exist in schema EctoCars.Transmission in query: from c0 in EctoCars.Car,  left_join: s1 in EctoCars.Specification,  on: c0.specification_id == s1.id,  left_join: t2 in EctoCars.Transmission,  on: s1.transmission_id == t2.id,  left_join: s3 in EctoCars.Specification,  on: c0.specification_id == s3.id,  left_join: e4 in EctoCars.Engine,  on: s1.engine_id == e4.id,  where: c0.color == ^&#34;blue&#34;,  where: t2.type == ^&#34;automatic&#34;,  where: t2.horse_power &gt; ^200,  select: c0 (elixir) lib/enum.ex:1925: Enum.&#34;-reduce/3-lists^foldl/2-0-&#34;/3  (elixir) lib/enum.ex:1418: Enum.&#34;-map_reduce/3-lists^mapfoldl/2-0-&#34;/3  (elixir) lib/enum.ex:1418: Enum.&#34;-map_reduce/3-lists^mapfoldl/2-0-&#34;/3</p><p>   IEX（10）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）**（ecto.queryError）lib / ecto_cars / cars / car.ex：37：Field`hife_power`在schema fectocars中不存在的地方。查询中的转发：从C0中的C0。 CAR，LEFT_JOIN：S1在ECTOCARS.Pecification，ON：C0.Specification_ID == S1.ID，left_join：T2在Ectocars.transmission中，on：s1.transmission_id == t2.id，left_join：s3在fectocars.pecification中，ON： c0.specification_id == s3.id，left_join：e4在ectocars.engine中，on：s1.engine_id == e4.id，其中：c0.color == ^＆＃34;蓝色＆＃34;，其中：t2.type == ^＆＃34;自动＆＃34;，其中：t2.horse_power＆gt; ^ 200，选择：c0（elixir）lib / enum.ex：1925：枚举。＆＃34; -reduce / 3列表^ foldl / 2-0  - ＆＃34; / 3（elixir）lib / enum.ex ：1418：枚举。＆＃34; -map_reduce / 3-lists ^ mapfoldl / 2-0  - ＆＃34; / 3（elixir）lib / enum.ex：1418：枚举。＆＃34; -map_reduce / 3-列表^ mapfoldl / 2-0  - ＆＃34; / 3</p><p>   Let’s see if we can break down what happened here. Looking at the error, it’s saying that  horse_power does not exist on the  Transmission schema. Fair enough, but I thought we were querying the  Engine schema here, right? Well if we look through the query we can see what happened a bit more. First we join to specifications ( s1), then to transmission ( t2), then to specifications ( s3) again (that doesn’t seem great…) and then to engines( e4). Now in the where clause for horse power, we’re looking at t2 instead of e4!!</p><p>   让我们看看我们是否可以分解在此发生的事情。查看错误，这就是传输模式不存在Horse_Power。足够公平，但我以为我们在这里查询发动机架构，对吧？好吧，如果我们通过查询浏览查询，我们可以看到更多发生的事情。首先，我们加入规范（S1），然后转到传输（T2），然后再次调整（S3）（这似乎没有很大......），然后到发动机（E4）。现在在马力的Where条款中，我们正在看T2而不是E4！</p><p> To understand this a bit better, let’s unwrap all these query pieces and just write them out together outside of their functions:</p><p> 要更好地理解这一点，让我们解开所有这些查询的作品，并在其功能之外将它们一起写在一起：</p><p>  Maybe its a little easier to see here. Because of the default way bindings work with  join , the table they are referencing is entirely related to it’s position in that list. So on line 8, when we are intending to query on the engines table, we are really querying against the third table in this query… transmissions! To get this to work as is, we would have to to the following:</p><p>  也许它更容易看到这里。由于默认方式绑定与加入的关系，所引用的表与该列表中的位置完全是相关的。所以在第8行时，我们打算在引擎表上查询时，我们真的在此查询中查询第三表...传输！要获得此项工作，我们必须执行以下操作：</p><p>  First off, I removed the double join to Specification, because really, who needs that. I also updated the join and query to engine so that the bindings list is aware of the existing binding to Transmission. On the plus side, this will work, on the down side, this really kills our composability. As it stands, this query is now dependent on previous queries having been done (to Specification) and that the same exact number of tables were joined to the query before calling this one. There has to be a better way here so that we can keep living in our super cool composable world…</p><p>  首先，我删除了双重加入来规范，因为真的，谁需要那个。我还将加入和查询更新为引擎，以便绑定列表了解与传输的现有绑定。在加方面，这将在下方工作，这真的杀死了我们的可组合性。正如它所致，此查询现在依赖于已完成的先前查询（指定），并且在调用此之前将相同精确的表格连接到查询。这里必须更好的方式，以便我们可以保持生活在我们的超级酷炫的世界中......</p><p>  Named bindings! Having to rely solely on the order that we joined to different tables is bananas. To use named bindings we pass the   as  option when calling  join :  join(query, :left, [c], s in Specification, as: :specifications, on: c.specification_id == s.id). We can then bind our specifications variable later on in the query by using the key  specifications: :  join(query, :left, [c, specifications: s], t in Transmission, as: :transmissions, on: s.transmission_id == t.id). Now let’s go ahead and re-write our functions to use named bindings:</p><p>  命名绑定！必须完全依靠我们加入不同表的顺序是香蕉。要使用命名绑定，请在调用Join时通过AS选项：加入（查询，：左，[C]，S规范，AS：：规范，ON：C.Specification_ID == S.ID）。然后，我们可以通过使用关键规格稍后绑定我们的规格变量：：：加入（查询，：左，[c，规格：s]，t在传输中，如下：：传输，on：s.transmission_id == T.ID）。现在让我们继续前进并重新编写我们的函数来使用命名绑定： </p><p>  I’m not going to show the output from testing each of these individually, but I promise they work ;) But something interesting happens when we try and chain them again…</p><p>我不会将输出显示出来的每个单独测试，但我保证他们的工作;）但是当我们再次尝试链接时，有趣的事情就会发生......</p><p> iex(16)&gt; EctoCars.Car |&gt; EctoCars.Car.with_color(&#34;blue&#34;) |&gt; EctoCars.Car.with_transmission(&#34;automatic&#34;) |&gt; EctoCars.Car.with_engine_horse_power(200) |&gt; EctoCars.Repo.all() ** (Ecto.Query.CompileError) alias `:specifications` already exists  (ecto_cars) lib/ecto_cars/cars/car.ex:35: EctoCars.Car.with_engine_horse_power/2</p><p> IEX（16）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）**（ecto.query.compileError）别名`：规格`已存在（EECTO_CARS）lib / ecto_cars / cars / car.ex：35：Eectocars.car.with_engine_horse_power / 2</p><p>  Ok, a new error! It looks like we cannot re-bind the same key (makes sense…). A simple solution would be to take out the join to specifications in the  with_engine_horse_power function, but then we are again stuck in a place where this function would have to be called only  after a function that joins to specifications was called.</p><p>  好的，一个新的错误！它看起来我们无法重新绑定相同的键（有意义......）。一个简单的解决方案是用_engine_horse_power函数中的连接到规范，但随后我们再次被困在一个地方只有在调用连接到规范的函数之后只能调用此功能。</p><p> I think the best option here is to instead check and see if the query has already joined to a specific table and only re-join if it has not. We can neatly accomplish this with   has_named_binding?. This function allows us to do just that, check and see if a query already has that binding. By making a smaller helper function, we should be in good shape. Let’s see what that refactor looks like:</p><p> 我认为这里的最佳选择是要检查并查看查询是否已加入特定表，并且如果它没有，只会重新加入。我们可以用has_named_binding整理完成此功能？此功能允许我们执行此操作，检查并查看查询是否已具有该绑定。通过制作较小的辅助功能，我们应该处于良好状态。让我们看看重构看起来的样子是什么：</p><p>  The  join_specifications helper function is in charge of checking for the join and adding it to the query if needed. We can now finally write a composable query that does not rely on any specific order or rely on one function always needing to be called before a second can be called!</p><p>  Join_Specifications Helper功能负责检查连接并在需要时将其添加到查询。我们现在可以终于编写一个不依赖于任何特定顺序或依赖于一个功能的可协调查询，始终需要在第二个可以调用之前调用！</p><p> iex(17)&gt; EctoCars.Car |&gt; EctoCars.Car.with_color(&#34;blue&#34;) |&gt; EctoCars.Car.with_transmission(&#34;automatic&#34;) |&gt; EctoCars.Car.with_engine_horse_power(200) |&gt; EctoCars.Repo.all() 17:31:25.303 [debug] QUERY OK source=&#34;cars&#34; db=2.6ms queue=3.8ms SELECT c0.&#34;id&#34;, c0.&#34;color&#34;, c0.&#34;vin_number&#34;, c0.&#34;specification_id&#34; FROM &#34;cars&#34; AS c0 LEFT OUTER JOIN &#34;specifications&#34; AS s1 ON c0.&#34;specification_id&#34; = s1.&#34;id&#34; LEFT OUTER JOIN &#34;transmissions&#34; AS t2 ON s1.&#34;transmission_id&#34; = t2.&#34;id&#34; LEFT OUTER JOIN &#34;engines&#34; AS e3 ON s1.&#34;engine_id&#34; = e3.&#34;id&#34; WHERE (c0.&#34;color&#34; = $1) AND (t2.&#34;type&#34; = $2) AND (e3.&#34;horse_power&#34; &gt; $3) [&#34;blue&#34;, &#34;automatic&#34;, 200] [  %EctoCars.Car{  __meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;cars&#34;&gt;,  color: &#34;blue&#34;,  id: 3,  specification: #Ecto.Association.NotLoaded&lt;association :specification is not loaded&gt;,  specification_id: 1,  vin_number: &#34;my_dream_car&#34;  } ]</p><p> IEX（17）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）17：31：25.303 [debug]查询ok source =＆＃34;汽车＆＃34; DB = 2.6ms队列= 3.8ms选择C0。＆＃34; ID＆＃34;，c0。＆＃34;颜色＆＃34;，c0。＆＃34; Vin_number＆＃34;，c0。＆＃34; specification_id＆＃ 34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;左外加入＆＃34;发动机＆＃34;作为S1上的E3。＆＃34; Engine_ID＆＃34; = E3。＆＃34; ID＆＃34;在哪里（C0。＆＃34;颜色＆＃34; = $ 1）和（t2。＆＃34;类型＆＃34; = $ 2）和（e3.＆＃34;马_power＆＃34;＆gt; $ 3）[＆＃34 ;蓝色＆＃34 ;,＆＃34;自动＆＃34;，200] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;，颜色：＆＃ 34;蓝色＆＃34;，ID：3，规范：＃ecto.association.notloaded＆lt;关联：规范没有加载，规范，规格_id：1，Vin_number：＆＃34; my_dream_car＆＃34; }]</p><p>  And there we have it! I’ve found my perfect car with the help of composable queries.</p><p>  我们终于得到它了！在可协调的疑问，我发现了我完美的汽车。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/flatiron-labs/how-to-compose-queries-in-ecto-b71311729dac">https://medium.com/flatiron-labs/how-to-compose-queries-in-ecto-b71311729dac</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/撰写/">#撰写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/queries/">#queries</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>