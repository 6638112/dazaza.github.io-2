<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SGDT / SIDT小说与现实（2017） SGDT/SIDT Fiction and Reality (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SGDT/SIDT Fiction and Reality (2017)<br/>SGDT / SIDT小说与现实（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 00:07:42</div><div class="page_narrow text-break page_content"><p>PSA: Actual hardware behavior takes precedence over vendor documentation. Or, as they say… trust but verify.</p><p>PSA：实际硬件行为优先于供应商文档。或者，正如他们所说的…信任但要验证。</p><p> A reader recently complained how Intel and AMD do not implement the SGDT and SIDT instructions the same way. AMD documentation states that these instructions ignore any operand size prefixes and always store full 32 bits of base address. Intel documentation on the other hand states that with 16-bit operand size, SGDT/SIDT stores 24 bits of the base address and the 4th byte is zeroed, and while using 32-bit operand size, all 32 bits of the base address are stored.</p><p> 最近有读者抱怨英特尔和AMD如何无法以相同的方式实施SGDT和SIDT指令。 AMD文档指出，这些指令将忽略任何操作数大小的前缀，并始终存储完整的32位基地址。另一方面，英特尔文档指出，SGDT / SIDT使用16位操作数大小存储24位基址，第4个字节清零，而使用32位操作数大小则存储所有32位基址。</p><p> What a mess, right? How is a poor developer supposed to write code that works on all CPUs, and why the heck is AMD inventing its own things? Yet the reality is a bit different…</p><p> 真是一团糟，对不对？贫穷的开发人员应该如何编写可在所有CPU上使用的代码，为什么AMD发明自己的东西呢？然而现实却有所不同……</p><p> The truth is much simpler and more logical: AMD did not invent incompatible behavior, AMD processors merely behave  the same way as Intel CPUs. Does that mean AMD’s documentation is incorrect? Of course not—it is Intel’s documentation which is an elaborate fiction and AMD’s straightforward documentation describes what AMD  and Intel processors do and always have done since 1985.</p><p> 事实要简单得多，也要合乎逻辑：AMD并未发明不兼容的行为，AMD处理器的行为与英特尔CPU相同。这是否表示AMD文档不正确？当然不是-只是英特尔的文档是一本精美的小说，而AMD的直接文档则描述了AMD和Intel处理器自1985年以来所做的事情以及一直以来所做的事情。</p><p> Hard to believe? Perhaps. But Intel’s documentation on this point has been going from contradictory to flat out wrong for several decades now. As far as the OS/2 Museum could ascertain, Intel’s 32-bit CPUs always ignored the operand size prefix and stored the full 32 bits of GDT/IDT base when executing SGDT/SIDT instructions; the CPU behavior never changed, although the documentation did.</p><p> 难以置信？也许。但是，数十年来，英特尔在这方面的文档一直从矛盾变为错误。据OS / 2博物馆所能确定的那样，英特尔的32位CPU在执行SGDT / SIDT指令时总是忽略操作数大小前缀，并存储GDT / IDT基数的完整32位。尽管文档进行了更改，但CPU的行为从未改变。</p><p> Testing a small sample of random processors is perhaps not a convincing proof, but there is at least one fairly widespread piece of software which  relies on always storing the full 32 bits and won’t work otherwise.</p><p> 测试一小部分随机处理器可能不是令人信服的证明，但是至少有一个相当广泛的软件依赖于始终存储完整的32位，否则将无法正常工作。</p><p>  Microsoft’s own Win32s (tested version 1.30c) contains code which executes SGDT in a 16-bit code segment which resides within WIN32S16.DLL (the name is a clear hint about the bitness). But the CPU runs with paging enabled and the GDT is mapped at a virtual address beyond 2GB, i.e. with the top bits always set. If the SGDT instruction clears the top byte, Win32s will crash:</p><p>  微软自己的Win32s（测试版1.30c）包含在WIN32S16.DLL内的16位代码段中执行SGDT的代码（名称清楚地表明了位数）。但是CPU在启用分页的情况下运行，并且GDT映射到2GB以上的虚拟地址，即始终设置高位。如果SGDT指令清除了最高字节，则Win32s将崩溃： </p><p>  To trigger the crash, it may be necessary to run Windows 3.11 for Workgroups with either 32-bit disk access or 32-bit file access enabled (when both are turned off, the crash does not appear to happen; turning on either of the two provokes the crash).</p><p>若要触发崩溃，可能需要在启用了32位磁盘访问或32位文件访问的情况下为工作组运行Windows 3.11（当两者均关闭时，崩溃似乎没有发生；打开两者中的任何一个引发崩溃）。</p><p> When SGDT emulation follows Intel documentation, Win32s is  known to break as shown above. And of course the fix is to emulate what Intel processors do, not what Intel documentation says.</p><p> 当SGDT仿真遵循Intel文档时，Win32s就会中断，如上所示。当然，解决方法是模拟英特尔处理器的功能，而不是英特尔文档中的内容。</p><p> Windows 3.11 for Workgroups + Win32s 1.30c + Freecell is not a wildly exotic combination. It worked on Intel CPUs back in the 1990s, and it still works on Intel processors today when hardware virtualization is used and instructions like SGDT are executed directly by the CPU (not emulated).</p><p> Windows 3.11 for Workgroups + Win32s 1.30c + Freecell并不是一个非常奇特的组合。它早在1990年代就可在Intel CPU上运行，如今，当使用硬件虚拟化并且SGDT之类的指令直接由CPU执行（未仿真）时，它仍可在Intel处理器上运行。</p><p>  So where did the fictional SGDT/SIDT documentation come from? It would be reasonable to assume that perhaps the documentation was written before the implementation was finalized, but that may not be the case. The Intel 386 reference manual from 1986, as well as Intel’s 1992 i486 PRM, are simply schizophrenic.</p><p>  那么虚构的SGDT / SIDT文档是从哪里来的呢？可以合理地假设文档是在实现完成之前编写的，但事实并非如此。 1986年的Intel 386参考手册以及Intel的1992 i486 PRM简直就是精神分裂症。</p><p>  The LGDT and LIDT instructions load a linear base address and limit value from a six-byte data operand in memory into the GDTR or IDTR, respectively. If a 16-bit operand is used with LGDT or LIDT, the register is loaded with a 16-bit limit and a 24-bit base, and the high-order eight bits of the six-byte data operand are not used. If a 32-bit operand is used, a 16-bit limit and a 32-bit base is loaded; the high-order eight bits of the six-byte operand are used as high-order base address bits.</p><p>  LGDT和LIDT指令分别将线性基本地址和极限值从内存中的六字节数据操作数加载到GDTR或IDTR中。如果将16位操作数与LGDT或LIDT一起使用，则该寄存器加载了16位限制和24位基数，并且不使用六字节数据操作数的高8位。如果使用32位操作数，则加载16位限制和32位基数；否则，将加载32位基数。六字节操作数的高八位用作高阶基地址位。</p><p> The SGDT and SIDT instructions always store into all 48 bits of the six-byte data operand. With the 80286, the upper eight bits are undefined after SGDT or SIDT is executed. With the 80386, the upper eight bits are written with the high-order eight address bits, for both a 16-bit operand and a 32-bit operand. If LGDT or LIDT is used with a 16-bit operand to load the register stored by SGDT or SIDT, the upper eight bits are stored as zeros.</p><p> SGDT和SIDT指令始终存储在六字节数据操作数的所有48位中。对于80286，在执行SGDT或SIDT之后，高八位未定义。对于80386，对于16位操作数和32位操作数，高8位均写入高8位地址位。如果LGDT或LIDT与16位操作数一起使用以加载SGDT或SIDT存储的寄存器，则高8位存储为零。</p><p> The above concisely describes the actual behavior of 32-bit Intel processors. But wait, that’s not all. The SGDT/SIDT instruction documentation says this:</p><p> 上面简要介绍了32位Intel处理器的实际行为。但是，等等，还不是全部。 SGDT / SIDT指导文档说： </p><p> SGDT/SIDT copies the contents of the descriptor table register to the six bytes of memory indicated by the operand. The LIMIT field of the register is assigned to the first word at the effective address. If the operand-size attribute is 32 bits, the next three bytes are assigned the BASE field of the register, and the fourth byte is written with zero. The last byte is undefined. Otherwise, if the operand-size attribute is 16 bits, the next four bytes are assigned the 32-bit BASE field of the register.</p><p>SGDT / SIDT将描述符表寄存器的内容复制到操作数指示的六个字节的存储器中。寄存器的LIMIT字段分配给有效地址的第一个字。如果操作数大小属性为32位，则将接下来的三个字节分配给寄存器的BASE字段，并且将第四个字节写入零。最后一个字节是不确定的。否则，如果操作数大小属性为16位，则将为寄存器的32位BASE字段分配接下来的四个字节。</p><p>  The 16-bit forms of the SGDT/SIDT instructions are compatible with the 80286, if the value in the upper eight bits is not referenced. The 80286 stores 1’s in these upper bits, whereas the 80386 stores 0’s if the operand-size attribute is 16 bits. These bits were specified as undefined by the SGDT/SIDT instructions in the iAPX 286 Programmer’s Reference Manual.</p><p>  如果未引用高8位中的值，则SGDT / SIDT指令的16位形式与80286兼容。如果操作数大小属性为16位，则80286在这些高位中存储1，而在80386中存储0。 iAPX 286程序员参考手册中的SGDT / SIDT指令将这些位指定为未定义。</p><p> A keen reader has already noticed that the SGDT/SIDT documentation makes no sense whatsoever—it claims that a 16-bit instruction stores 32-bit base and a 32-bit instruction stores 24-bit base. Perhaps a simple typo, perhaps a hint that the whole thing is suspect.</p><p> 敏锐的读者已经注意到SGDT / SIDT文档毫无意义，它声称16位指令存储32位基数，而32位指令存储24位基数。也许是一个简单的错字，或者暗示整个事情都是可疑的。</p><p> The bigger problem of course is that the LxDT and SxDT documentation flatly contradict each other. SGDT documentation says that operand size matters, but LGDT documentation says that (for SGDT) it does not matter. At least one must be wrong.</p><p> 当然，更大的问题是LxDT和SxDT文档完全矛盾。 SGDT文档说操作数大小很重要，但是LGDT文档说（对于SGDT）无关紧要。至少有一个错误。</p><p>  If the operand-size attribute is 16 bits, the next three bytes are assigned the BASE field of the register, and the fourth byte is undefined. Otherwise, if the operand-size attribute is 32 bits, the next four bytes are assigned the 32-bit BASE field of the register.</p><p>  如果操作数大小属性为16位，则接下来的三个字节分配给寄存器的BASE字段，而第四个字节未定义。否则，如果操作数大小属性为32位，则为后四个字节分配寄存器的32位BASE字段。</p><p> Now it’s merely incorrect but no longer obvious nonsense. There is still a contradiction in that the SGDT/SIDT documentation claims in the main body that 16-bit operand size leaves the fourth BASE byte undefined, while the compatibility note says it’s written with zeros. And the 486 PRM still has LGDT/LIDT and SGDT/SIDT instruction documentation contradict each other. To improve programmer confusion, the 486 PRM also presents the following pseudocode for SGDT/SIDT:</p><p> 现在，这只是不正确的，但不再是显而易见的废话。仍然存在一个矛盾，SGDT / SIDT文档在主体中声称16位操作数的大小使第四个BASE字节未定义，而兼容性说明说它是用零写的。而且486 PRM仍有LGDT / LIDT和SGDT / SIDT指令文档相互矛盾。为了改善程序员的困惑，486 PRM还为SGDT / SIDT提供了以下伪代码：</p><p>  That’s right, the pseudocode is correct, and the text which immediately follows it says something else! What to believe, that is the question… (Answer: The CPU itself!)</p><p>  没错，该伪代码是正确的，紧随其后的文本还显示了其他内容！相信什么，这就是问题……（答案：CPU本身！） </p><p> The Pentium documentation (order no. 241430-004, 1995) presents the same self-contradictory information as the 486 PRM.</p><p>奔腾文档（订购号241430-004，1995年）提供了与486 PRM相同的自相矛盾信息。</p><p> The Pentium Pro documentation (order no. 232691-001, December 1995) improved things, kind of. The LGDT/LIDT instruction documentation no longer describes SGDT/SIDT behavior. And the pseudocode in SGDT/SIDT documentation now matches the text. Curiously, the pseudocode starts with “IF instruction is IDTR” when it should have been “IF instruction is SIDT”. Again, let’s chalk that up to a simple typo.</p><p> Pentium Pro文档（1995年12月，订购号232691-001）改进了某种方式。 LGDT / LIDT指导文档不再描述SGDT / SIDT行为。现在，SGDT / SIDT文档中的伪代码与文本匹配。奇怪的是，当伪代码本应为“ IF指令为SIDT”时，它以“ IF指令为IDTR”开头。同样，让我们​​用一个简单的错字来概括一下。</p><p> Anyway, the Pentium Pro SGDT/SIDT documentation is consistent with itself! Yay! But it’s consistently wrong… oops. Then again, one out of two ain’t so bad, right?</p><p> 无论如何，Pentium Pro SGDT / SIDT文档与其自身保持一致！好极了！但这始终是错误的...哎呀。再说一次，十分之二还不错吧？</p><p> The latest Intel SDM as of this writing (325383-062, March 2017) still presents the same incorrect information. Along the way, there was a split such that SGDT and SIDT are documented separately. Probably as a result of that, the pseudocode for SGDT now starts with a nonsensical “IF instruction is SGDT” statement—well duh, what other instruction did you think SGDT was? (There’s analogous redundant pseudocode for SIDT.) Information about 64-bit support was added years ago, and a few revisions back, the new CR4.UMIP bit was documented. When it comes to 16-bit operand size, the description and pseudocode is just as wrong as it’s been since 1995.</p><p> 截至撰写本文时，最新的英特尔SDM（325383-062，2017年3月）仍然显示相同的错误信息。在此过程中，SGDT和SIDT被分开记录了。可能是这样的结果，SGDT的伪代码现在以无意义的“ IF指令为SGDT”语句开头-嗯，您认为SGDT还有什么其他指令？ （有类似的SIDT冗余伪代码。）有关64位支持的信息是在几年前添加的，并进行了一些修订，并记录了新的CR4.UMIP位。当涉及到16位操作数时，描述和伪代码与1995年以来一样错误。</p><p>  The whole thing looks like a misunderstanding caused by asymmetry between SxDT and LxDT instructions. Intel and AMD both agree that for LGDT and LIDT, operand size  does make a difference, and if 16-bit operand size is used, only 24 bits of the base address are loaded (with the top bits being zeroed). If that is taken into account, then SGDT/SIDT doesn’t need to do anything special.</p><p>  整个情况看起来像是由于SxDT和LxDT指令之间的不对称引起的误解。英特尔和AMD都同意，对于LGDT和LIDT，操作数大小会有所不同，如果使用16位操作数大小，则只会加载基地址的24位（高位为零）。如果考虑到这一点，则SGDT / SIDT不需要做任何特殊的事情。</p><p> Pure 16-bit software will always run with the top 8 bits of GDT/IDT base as zero because LGDT/LIDT can’t do anything else, and therefore SGDT/SIDT simply needs to store the actual 32-bit base as it is, regardless of operand size. In other words, for pure 16-bit code, it does not matter if SGDT stores 24 bits of base address plus a byte of zeros or 32 bits of base address, the result will be identical.</p><p> 纯16位软件将始终以GDT / IDT基数的高8位为零运行，因为LGDT / LIDT无能为力，因此SGDT / SIDT只需要按原样存储实际的32位基数，无论操作数大小如何。换句话说，对于纯16位代码，SGDT存储24位基址加一个零字节或32位基址都没有关系，结果将是相同的。</p><p> But if 16-bit code runs in a 32-bit environment, SGDT/SIDT will store the full 32-bit base. That seems logical and useful because storing 24 bits of a 32-bit address would corrupt the data (see Win32s).</p><p> 但是，如果16位代码在32位环境中运行，则SGDT / SIDT将存储完整的32位基数。这似乎合乎逻辑并且很有用，因为存储32位地址的24位会损坏数据（请参见Win32s）。 </p><p> It is very interesting to see how the documentation got more wrong over the years. It started out as partially correct but inconsistent and the inconsistencies were ironed out, unfortunately removing the correct information and only leaving the erroneous documentation in place. Sometimes Intel gives a distinct impression that processor architects and documentation writers don’t talk to each other much.</p><p>看到这些年来这些文档是如何出错的非常有趣。 最初，它是部分正确的，但是不一致，并且不一致之处已得到解决，很遗憾，这些错误信息删除了正确的信息，只保留了错误的文档。 有时，英特尔给人一种明显的印象，即处理器架构师和文档编写者之间的对话不多。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sidt/">#sidt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>