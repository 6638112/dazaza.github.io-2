<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可怜的，被误解的内部文本</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">可怜的，被误解的内部文本</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 00:21:21</div><div class="page_narrow text-break page_content"><p>←返回3686个单词这种古怪的，非标准的元素文本检索方式，由Internet Explorer引入，后来由于Web兼容性的原因而被WebKit / Blink和Opera共同“复制”。通常将它与textContent结合使用-一种跨浏览器的使用标准属性，然后使用专有属性的方式：</p><p>  或作为众多Mozilla票证中的主要Webcompat违规者（由于Mozilla是拒绝添加此非标准属性的仅有的主要浏览器之一），当某人不知道自己在做什么时，完全跳过textContent“后备”：</p><p>  innerText几乎总是皱眉。毕竟，您为什么要使用一个与“标准”属性相同的非标准属性？很少有人冒险去检查差异，从表面上看，肯定没有差异。那些想进一步研究的人通常会找到它们，但是只有很小的一部分，并且只有在检索文本时才设置它们。</p><p> 早在2009年，我就做到了。我什至还写了这个StackOverflow答案，内容是确切的差异-细微的空格差异，诸如textContent（但不是innerText）包含内容，界面差异（Node与HTMLElement）等等。</p><p> 一直以来，我一直坚信，关于textContent和innerText并没有太多要了解的知识。只需避开innerText，使用此“ combo”进行跨浏览器的代码，请记住一些细微的差别，您真是太棒了。</p><p> 我几乎不知道我只是看着冰山一角，而我对innerText的看法将发生巨大变化。您将听到的故事是Internet Explorer正确执行某些操作，这些属性之间的真正区别以及我们可能希望如何标准化这个红发继子。</p><p>  不久前，我正在帮助某人在浏览器中实现文本编辑器。这是当我意识到textContent和innerText之间的这些看似无关紧要的空格差异多么荒谬的重要时。</p><p>请注意，innerText如何几乎准确地表示文本在页面上的显示方式。另一方面，textContent做一些奇怪的事情-它忽略了和围绕样式设置的元素（在本例中为）创建的换行符。但是它保留标记中定义的空格。它实际上是做什么的？</p><p>  此属性返回此节点及其后代的文本内容。 [...]获取时，不执行序列化，返回的字符串不包含任何标记。不执行空格标准化，并且返回的字符串在元素内容中不包含空格（请参见属性Text.isElementContentWhitespace）。 [...]返回的字符串由该节点的文本内容组成，具体取决于其类型，如下所示：对于ELEMENT_NODE，ATTRIBUTE_NODE，ENTITY_NODE，ENTITY_REFERENCE_NODE，DOCUMENT_FRAGMENT_NODE：每个子节点的textContent属性值的串联，不包括COMMENT_NODE和PROCESSING_INSTRUCTION_NODE节点。如果节点没有子节点，则为空字符串。对于TEXT_NODE，CDATA_SECTION_NODE，COMMENT_NODE，PROCESSING_INSTRUCTION_NODE nodeValue</p><p> 换句话说，textContent返回所有文本节点的串联文本。这几乎就像获取标记（即innerHTML）并将其从标记中剥离一样。注意，没有执行空格标准化，本质上吐出了文本和空格，其方式与在标记中定义的方式相同。如果HTML源代码中有大量的换行符，那么它们也将作为textContent的一部分。</p><p> 在调查这些问题时，我遇到了Mike Wilcox于2010年撰写的精彩博客文章，这几乎是唯一一个试图引起人们对这个问题的关注的地方。在其中，Mike对我在这里描述的相同内容不屑一顾，说出了这些真实的话：</p><p> Internet Explorer在4.0版中实现了innerText，这是一个有用的功能，如果被误解了。 [...]这些属性最常见的用法是在使用RTF编辑器时，当您需要“获取纯文本”或出于其他功能原因时。 [...]因为“不执行空格标准化”，所以textContent本质上在做的事情就像一个PRE元素。标记被剥离，但是否则，我们得到的正是HTML文档中的内容-包括制表符，空格，缺少空格和换行符。它正在从HTML中获取源代码！这真的有什么好处，我真的不知道。</p><p> 了解了这些差异，我们可以看到典型的textContent有多可能令人误解（和危险）。 innerText检索是。就像说：</p><p>    假设我们有一个内容可编辑的区域，用户可以在其中写东西。我们希望对该区域的文本进行自己的拼写更正。为了做到这一点，我们确实想分析文本在浏览器中而不是在标记中的显示方式。我们想知道用户是否键入了换行符或空格，而不是标记中的空格，以便我们可以相应地更正文本。</p><p>这只是纯文本检索的一种用例。也许您可能希望将书面文本转换为另一种格式（PDF，SVG，画布上的图像等），在这种情况下，其外观必须与键入时完全相同。或者，也许您需要知道文本中的光标位置（或其整个长度），因此您需要以显示文本的方式对文本进行操作。</p><p>  考虑innerText的一个好方法是好像选择了文本并将其复制到页面之外。实际上，这正是WebKit / Blink所做的-它对Selection＃toString序列化和innerText使用相同的代码！</p><p> 说到这一点-如果innerText本质上与字符串选择相同，那么是否可以通过Selection＃toString来模拟它呢？</p><p> 可以肯定的是，但是您可以想象，这种事情的性能还有待改进-我们需要保存当前选择，然后更改选择以包含整个元素内容，获取字符串表示形式，然后恢复原始选择：</p><p>  解决方法的这种科学怪人的问题是性能，复杂性和清晰度。获得元素的“纯文本”表示应该并不难。尤其是当已经有一个“实现的”属性来执行此操作时。</p><p>  Internet Explorer做到了这一点-在这种情况下，textContent和Selection＃toString是较差的竞争者； innerText正是我们需要的。除非它是非标准的，并且不受一个主要浏览器支持。值得庆幸的是，至少Chrome（Blink）和Safari（WebKit）足以模仿它。希望它们的实现之间没有偏差。还是在那里？</p><p>  意识到innerText的重要性后，我想看看2个引擎之间的区别。由于那里没有类似的东西，因此我着手探索它。在真正的“跨浏览器混乱”传统中，我发现这并不是为胆小的人而设计的。</p><p>我从Aryeh Gregor的（现在已灭绝的）测试套件开始，并添加了一些其他内容。我还搜索了WebKit / Blink错误跟踪器，并包括了我在其中找到的所有相关信息。</p><p> 上表（以及测试套件中的表）显示了所有细节，但值得一提的是。首先，好消息-Internet Explorer 和元素的内容），然后在IE更改时，它们自然会分开。当前，某些WebKit / Blink行为类似于old-IE，而有些则不然。但是，即使与原始版本相比，WebKit在复制此功能方面也做得很差，或者，似乎他们已经在尝试使其更好！</p><p> 与IE不同，WebKit / Blink在表单元格之间插入选项卡-很有道理！它们还保留大写/小写文本，可以说更好。它们不包含隐藏的元素（“ display：none”，“ visibility：hidden”），这也很有意义。而且它们不包含元素和 / 后备内容的内容（这可能是一个有问题的方面），但也很合理。</p><p>  请注意，IE Tech Preview（Spartan）现在离WebKit / Blink更近了。它们仅有9个方面的不同（相比之下，早期版本中为10-11）。仍然很多，但是至少有一些希望实现融合。最值得注意的是，IE再次停止包含和内容，并且-有史以来第一次-不再包括“ display：none”元素（但不包括“ visibility：hidden”元素-稍后再介绍）。</p><p>  您可能已经发现桌子上缺少Opera。这不仅是因为Opera现在正在使用Blink引擎（本质上具有WebKit行为）。这也是由于这样的事实，当它不在Blink上时，当涉及到innerText时，它确实是顽皮的。为了维持Web兼容性，Opera只是继续进行，并将innerText别名化为textContent。没错，在Opera中，innerText不会返回与我们在IE或WebKit中看到的内容相似的任何内容。表格中根本没有意义；它在各个方面都有所不同，我们可以认为它从未实现。</p><p>   您可以在jsperf.com上找到数十种将innerText和textContent进行比较的测试，而innerText通常要慢几十倍。</p><p>  在这篇博客中，凯利·诺顿（Kelly Norton）谈论的是innerText的速度降低了300倍（尽管这似乎是非常罕见的情况），并建议不要完全使用它。</p><p>了解了这两个属性的基本概念，这不足为奇。毕竟，innerText需要布局知识，而任何涉及布局的东西都是昂贵的。</p><p> 因此，出于所有意图和目的，innerText比textContent明显慢。而且，如果您需要的是在没有任何样式意识的情况下检索元素的文本，则应（绝对）应使用textContent。但是，这种对innerText的样式意识正是我们“按显示”检索文本时所需要的。这是有代价的。</p><p>  您可能对jQuery的text（）方法很熟悉。但是它是如何工作的以及它的用途是什么？ innerText组合还是其他？事实证明，jQuery采取了一条安全的路线-它返回textContent（如果可用），或者手动执行textContent应该做的事情-遍历所有子级并将其nodeValue串联起来。显然，jQuery确实曾经使用innerText，但是随后遇到了很好的旧空白差异，并决定完全放弃它。</p><p> 因此，如果我们想使用jQuery来获取真实的文本表示形式（如innerText），则不能使用jQuery的text（），因为它基本上是跨浏览器的textContent。我们将需要推出自己的解决方案。</p><p>  希望到目前为止，我已经使您确信innerText非常有用。我们讨论了基本概念，浏览器差异，性能影响，并了解了即使是全能的jQuery也无济于事。</p><p> 您可能会认为现在此属性已标准化或至少已成为标准。</p><p>  早在2010年，Google的Adam Barth提议在WHATWG邮件列表中指定innerText。有趣的是，Adam想要的只是以一种安全的方式设置元素的纯文本（而不是标记！）。他也不知道textContent，这肯定是首选的（标准）方法。幸运的是，我前面提到的博客文章Mike Wilcox对此表示赞同：</p><p>除了亚当的评论外，没有标准，稳定的方法来从一系列节点中获取文本。 textContent返回所有内容，包括制表符，空格，甚至脚本内容。 [...] innerText是IE正确的事情之一，就像innerHTML一样。让我们考虑将其设为标准，而不是删除它。</p><p> 在同一线程中，Mozilla的Robert O'Callahan怀疑innerText的用途，但还添加了：</p><p> 但是，如果Mike Wilcox或其他人想证明innerText实际上是有用且需要的功能，我们应该听到它。或者，如果Webkit或Opera的某人想解释为什么添加它，那也将很有用。</p><p> 如果需要Web兼容性，Ian Hixie愿意将其添加到规格中。尽管Rob O'Callahan认为这是一项多余的功能，但WebKit / Apple的Maciej Stachowiak却以以下出色的口吻打动了人们：</p><p> 这是一个真正有用的功能吗？是的，获得呈现的纯文本内容的功能是一项有用的功能，并且从头开始实施就很烦人。为了给出一个非常边缘的数据点，我们的回归文本框架将其用于输出页面的纯文本版本，以进行与布局无关的测试。更具假设性的用途是具有“转换为纯文本”功能的富文本编辑器。对于这些用例，textContent没有那么有用，因为它不能正确处理换行符和未呈现的空白。这些因素往往不利于将其删除。</p><p>  人们可能有很多方法可以做到这一点。例如，“转换为纯文本”功能通常会为列表项目符号（例如“ *”）和项目编号引入字符。 （例如，Mac TextEdit可以。）Safari 5都不可以。难以满足多个具有单个属性的潜在用户的需求。</p><p>   正如罗布指出的那样，“转换为纯文本”肯定是一个模棱两可的任务。实际上，我们可以轻松地创建一个看起来与“纯文本”版本完全不同的测试标记：</p><p>注意，不显示“ opacity：0”元素，但它们是innerText的一部分。同名的“文本缩进：-999px”隐藏技术。列表中的项目符号不被考虑，也不是动态生成的内容（通过:: after伪选择器）。段落仅创建1个换行符，即使实际上它们可能有巨大的边距。</p><p>  如果您将innerText视为从页面复制的文本，则这些“工件”中的大多数都是非常合理的。仅仅因为文本块被赋予“ opacity：0”并不意味着它不应该作为输出的一部分。纯粹是表示方面的问题，就像项目符号，段落之间的间隔或缩进的文本一样。重要的是结构保留-块样式的元素应创建换行，内联的元素应为内联。</p><p> 一个棘手的方面可能是“文本转换”。应该保留大写还是大写文本？ WebKit / Blink认为应该这样做； Internet Explorer没有。它是文本本身的一部分还是仅仅是样式？</p><p> 另一个是“可见性：隐藏”。类似于“不透明度：0”（与“显示：无”不同），文本仍然是流的一部分，只是看不到。常识表明它仍然应该是输出的一部分。尽管Internet Explorer只是这样做，但WebKit / Blink对此表示不同（也奇怪地是，它们的“不透明性：0”行为与此不一致）。</p><p> 浏览器未知的元素带来了另一个问题。例如，WebKit / Blink最近开始支持元素。该元素不会显示，因此它不是innerText的一部分。对于Internet Explorer，它不过是一个未知的内联元素，当然它会输出其内容。</p><p>  2011年，Aryeh Gregor将另一个innerText提议发布到WHATWG邮件列表中。 Aryeh建议：</p><p>  与先前的讨论类似，Mozilla反对使用第3个选项（将其标准化），而Microsoft和Opera反对使用第1个选项（将其删除）。</p><p>（3）的问题在于很难规范；以所有浏览器都可以实现的方式来规范甚至更加困难；无论如何，任何规范都可能与遵循通用方法的现有实现完全不兼容。 [...]</p><p> 确实，正如我们从测试中看到的那样，兼容性是一个严重的问题。如果我们要标准化innerText，我们应该在规范中放入哪两个行为？</p><p>  尚不清楚后者是否实际上是一种选择。这取决于如何指定Selection.toString，以及UA是否愿意对innerText进行与对Selection.toString相同的操作...。到目前为止，我对Selection.toString唯一的建议是操作”，这对于innerText来说既不明确也不可接受。在我看来。</p><p> 最后，剩下的是Aryeh在指定innerText时使用的WHATWG凭单。正如其中一项评论所证明的那样，事情看起来相当严峻：</p><p> 毫无疑问，有人告诉我要删除非Gecko浏览器是不实际的。另一方面，根据渲染树的程度，WebKit在诸如DOM和CSS之类的标准内容方面对于规范而言异常复杂。而且，它可能会因分离的节点而中断（在这种情况下，WebKit的行为完全不同）。 [...]但是Gecko的人似乎对这种复杂性和对DOM属性的依赖性表示不满。另一方面，给人的印象是WebKit根本不愿重写其innerText实现。因此，我想知道，大多数浏览器可能会实现的规范是一种尽可能简单的规范，基本上只是一个兼容垫片。如果多个实现者实际上想要实现我开始编写的innerText规范之类的东西，我很乐意恢复对此的工作，但这并不是我的印象。</p><p> 我们不能删除它，不能更改它，不能指定它依赖于渲染，并且指定它将是非常困难的:)</p><p>  还是有一些希望innerText还是它可以通过2种不同的实现方式永久保留为未指定的遗产？</p><p>我希望测试套件和兼容性表是使事情变得更好的第一步。我们需要确切地了解引擎的差异，并且需要对规范中要包含的内容有充分的了解。我确定这不会涵盖所有情况，但这是一个开始（其他值得探讨的方面：影子DOM，分离的节点）。</p><p> 我认为该测试套件应足以编写90％完整的innerText规范。最大的问题是确定要在IE和WebKit / Blink中选择哪种行为。</p><p>   看到微软最近有多么出色，我真的希望我们能够实现这一目标。</p><p>     检查文本节点是否在“格式化”上下文内（即“空白：pre- *”节点的子节点），在这种情况下，其内容应按原样连接；否则，将所有空格折叠为1。</p><p> 检查节点是否为块样式（“块”，“列表项”，“表”等），在这种情况下，必须用换行符将其包围；否则，它是内联的，其内容按原样输出。</p><p> 然后是诸如忽略，等节点，并在元素之间插入制表符（“ \ t”）（以遵循WebKit / Blink的指导）。</p><p> 这仍然是一个非常简单和天真的实现。首先，它不会折叠块元素之间的换行符，这是一个非常重要的方面。为此，我们需要跟踪更多状态-了解有关先前节点样式的信息。它也不会以“真实”的方式规范空白-例如，具有前导和尾随空格的文本节点，如果是（唯一的节点？）块中的空格，则应将其删除</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://perfectionkills.com/the-poor-misunderstood-innerText/">http://perfectionkills.com/the-poor-misunderstood-innerText/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/可怜/">#可怜</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/innertext/">#innertext</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>