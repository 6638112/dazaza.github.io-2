<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>跳过列表</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">跳过列表</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 09:35:24</div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  In  computer science, a  skip list is a  probabilistic  data structure that allows                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}   search complexity as well as                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}   insertion complexity within an  ordered sequence of            n    {\displaystyle n}   elements. Thus it can get the best features of a sorted  array (for searching) while maintaining a  linked list-like structure that allows insertion, which is not possible in an array. Fast search is made possible by maintaining a linked hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one (see the picture below on the right). Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for. Via the linked hierarchy, these two elements link to elements of the next sparsest subsequence, where searching is continued until finally we are searching in the full sequence. The elements that are skipped over may be chosen probabilistically  [2] or deterministically,  [3] with the former being more common.</p><p>跳转到导航跳转在计算机科学中搜索，跳过列表是一种概率数据结构，其允许O(LOG⁡n){\DisplayStyle{\数学{O}}(\Logn)}搜索复杂度以及O(LOG⁡n){\DisplayStyle{{\数学{O}}(\logn)}插入复杂度在n{\DisplayStyle n}元素的有序序列内。因此，它可以获得排序数组的最佳特性(用于搜索)，同时维护允许插入的类似链表的结构，这在数组中是不可能的。快速搜索是通过维持子序列的链接层次结构实现的，每个连续的子序列跳过的元素比前一个更少(请参见右下图)。搜索从最稀疏的子序列开始，直到找到两个连续的元素，一个小于搜索的元素，一个大于或等于搜索的元素。通过链接的层次结构，这两个元素链接到下一个最稀疏的子序列的元素，在那里继续搜索，直到最后我们在全序列中搜索。跳过的元素可以是概率选择[2]，也可以是确定性选择[3]，前者更为常见。</p><p>    A skip list is built in layers. The bottom layer is an ordinary ordered  linked list. Each higher layer acts as an &#34;express lane&#34; for the lists below, where an element in layer            i    {\displaystyle i}   appears in layer            i  +  1    {\displaystyle i+1}   with some fixed probability            p    {\displaystyle p}   (two commonly used values for            p    {\displaystyle p}   are            1    /   2    {\displaystyle 1/2}   or            1    /   4    {\displaystyle 1/4}  ). On average, each element appears in            1    /   (  1  −  p  )    {\displaystyle 1/(1-p)}   lists, and the tallest element (usually a special head element at the front of the skip list) in all the lists. The skip list contains              log    1    /   p    ⁡  n      {\displaystyle \log _{1/p}n\,}   (i.e. logarithm base            1    /   p    {\displaystyle 1/p}   of            n    {\displaystyle n}  ) lists.</p><p>跳过列表是按层构建的。底层是一个普通的有序链表。每一较高层都充当一条快速车道；对于下面的列表，其中层i{\displaystyle i}中的元素以某个固定概率p{\displaystyle p}出现在层i+1{\displaystyle i+1}中(p{\displaystyle p}的两个常用值是1/2{\displaystyle 1/2}或1/4{\displaystyle 1/4})。平均而言，每个元素出现在1/(1−p){\DisplayStyle 1/(1-p)}列表中，并且出现在所有列表中的最高元素(通常是跳过列表前面的特殊HEAD元素)。跳过列表包含⁡n{\DisplayStyle\LOG_{1/p}n\，}(即n{\DisplayStyle n}的对数底1/p{\DisplayStyle 1/p})列表。</p><p> A search for a target element begins at the head element in the top list, and proceeds horizontally until the current element is greater than or equal to the target. If the current element is equal to the target, it has been found. If the current element is greater than the target, or the search reaches the end of the linked list, the procedure is repeated after returning to the previous element and dropping down vertically to the next lower list. The expected number of steps in each linked list is at most            1    /   p    {\displaystyle 1/p}  , which can be seen by tracing the search path backwards from the target until reaching an element that appears in the next higher list or reaching the beginning of the current list. Therefore, the total  expected cost of a search is                  1  p       log    1    /   p    ⁡  n    {\displaystyle {\tfrac {1}{p}}\log _{1/p}n}   which is                O    (  log  ⁡  n  )      {\displaystyle {\mathcal {O}}(\log n)\,}  , when            p    {\displaystyle p}   is a constant. By choosing different values of            p    {\displaystyle p}  , it is possible to trade search costs against storage costs.</p><p>对目标元素的搜索从顶部列表中的head元素开始，然后水平进行，直到当前元素大于或等于目标。如果当前元素等于目标，则已找到该元素。如果当前元素大于目标，或者搜索到达链表的末尾，则在返回到上一个元素并垂直下降到下一个较低的列表后，重复该过程。每个链表中的预期步数最多为1/p{\displaystyle 1/p}，这可以通过从目标向后跟踪搜索路径，直到到达出现在下一个更高列表中的元素或到达当前列表的开头来查看。因此，当p{\⁡{1}{p}为常量时，搜索的总预期成本为1p log1/pdisplaystyle{\tfrac{1}{p}}\log_{1/p}n}，其为O(log⁡n){\displaystyle{\数学{O}}(\logn)\，}。通过选择不同的p{\displaystyle p}值，可以在搜索成本与存储成本之间进行权衡。</p><p>   The elements used for a skip list can contain more than one pointer since they can participate in more than one list.</p><p>用于跳过列表的元素可以包含多个指针，因为它们可以参与多个列表。</p><p> Insertions and deletions are implemented much like the corresponding linked-list operations, except that &#34;tall&#34; elements must be inserted into or deleted from more than one linked list.</p><p>插入和删除操作的实现方式与相应的链表操作非常相似，不同之处在于必须将元素插入到多个链表中或从多个链表中删除元素。</p><p> O    (  n  )    {\displaystyle {\mathcal {O}}(n)}   operations, which force us to visit every node in ascending order (such as printing the entire list), provide the opportunity to perform a behind-the-scenes derandomization of the level structure of the skip-list in an optimal way, bringing the skip list to                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}   search time. (Choose the level of the i&#39;th finite node to be 1 plus the number of times we can repeatedly divide i by 2 before it becomes odd. Also, i=0 for the negative infinity header as we have the usual special case of choosing the highest possible level for negative and/or positive infinite nodes.) However this also allows someone to know where all of the higher-than-level 1 nodes are and delete them.</p><p>O(N){\displaystyle{\mathcal{O}}(N)}操作强制我们以升序访问每个节点(例如打印整个列表)，提供了以最佳方式执行跳过列表的级别结构的幕后去随机化的机会，从而使跳过列表的搜索时间为O(⁡n){\displaystyle{\mathcal{O}}(\logn)}。(选择第i&#39；个有限节点的级别为1加上在i变为奇数之前可以重复除以2的次数。此外，负无穷大头的i=0，因为我们通常有为负和/或正无限节点选择可能的最高级别的特殊情况。)。但是，这也允许某人知道所有高于级别1的节点的位置并将其删除。</p><p>  make all nodes level 1j ← 1 while the number of nodes at level j &gt; 1  do  for each i&#39;th node at level j  do  if i is odd  and i is not the last node at level j randomly choose whether to promote it to level j+1  else if i is even  and node i-1 was not promoted promote it to level j+1  end if  repeat j ← j + 1 repeat</p><p>如果i为奇数并且i不是级别j上的最后一个节点，则随机选择是否将其提升至级别j+1。否则，如果i为偶数且节点i-1未提升，则将其提升至级别j+1结束(←)。如果重复j←j+1，则将其提升至级别j+1。</p><p> Like the derandomized version, quasi-randomization is only done when there is some other reason to be running an                O    (  n  )    {\displaystyle {\mathcal {O}}(n)}   operation (which visits every node).</p><p>与去随机版本一样，只有在有其他原因需要运行O(N){\displaystyle{\mathcal{O}}时，才会执行准随机化</p><p> The advantage of this quasi-randomness is that it doesn&#39;t give away nearly as much level-structure related information to an  adversarial user as the de-randomized one. This is desirable because an adversarial user who is able to tell which nodes are not at the lowest level can pessimize performance by simply deleting higher-level nodes. (Bethea and Reiter however argue that nonetheless an adversary can use probabilistic and timing methods to force performance degradation.  [4]) The search performance is still guaranteed to be logarithmic.</p><p>这种准随机性的优点是，它不会像去随机化的用户那样向敌方用户提供几乎同样多的与层次结构相关的信息。这是可取的，因为能够辨别哪些节点不在最低级别的敌意用户可以通过简单地删除较高级别的节点来悲观性能。(然而，Bethea和Reiter认为，尽管如此，对手仍然可以使用概率和定时方法来强制降低性能。[4])搜索性能仍然保证是对数的。</p><p> It would be tempting to make the following &#34;optimization&#34;: In the part which says &#34;Next, for each  ith...&#34;, forget about doing a coin-flip for each even-odd pair. Just flip a coin once to decide whether to promote only the even ones or only the odd ones. Instead of                O    (  n  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(n\log n)}   coin flips, there would only be                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}   of them. Unfortunately, this gives the adversarial user a 50/50 chance of being correct upon guessing that all of the even numbered nodes (among the ones at level 1 or higher) are higher than level one. This is despite the property that he has a very low probability of guessing that a particular node is at level  N for some integer  N.</p><p>进行以下优化是很有诱惑力的：在下面写着“接下来，对于每一对……”的部分，忘掉为每对偶数对抛硬币的事。只需抛硬币一次，就可以决定是只促销偶数的还是只促销奇数的。代替O(nlog⁡n){\DisplayStyle{\Mathcal{O}}(n\logn)}掷硬币，将只有O(LogLogStyle N){\DisplayStyle{\Mathcal{O}}(\logn)}个硬币被抛出，而不是O(nlog⁡n){\DisplayStyle{\Mathcal{O}}(\logn)}个硬币。不幸的是，这使得恶意用户在猜测所有偶数编号的节点(在级别1或更高的节点中)都高于级别1之后，有50/50的机会是正确的。这是尽管他猜测特定节点对于某个整数N处于级别N的概率非常低的特性。</p><p> A skip list does not provide the same absolute worst-case performance guarantees as more traditional  balanced tree data structures, because it is always possible (though with very low probability  [5]) that the coin-flips used to build the skip list will produce a badly balanced structure. However, they work well in practice, and the randomized balancing scheme has been argued to be easier to implement than the deterministic balancing schemes used in balanced binary search trees. Skip lists are also useful in  parallel computing, where insertions can be done in different parts of the skip list in parallel without any global rebalancing of the data structure. Such parallelism can be especially advantageous for resource discovery in an ad-hoc  wireless network because a randomized skip list can be made robust to the loss of any single node.  [6]</p><p>跳过列表不能提供与更传统的平衡树数据结构相同的绝对最坏情况性能保证，因为用于构建跳过列表的掷硬币操作总是有可能(尽管概率非常低[5])产生一个很差的平衡结构。然而，它们在实践中工作得很好，并且已经证明随机平衡方案比平衡二叉搜索树中使用的确定性平衡方案更容易实现。跳过列表在并行计算中也很有用，在并行计算中，可以在跳过列表的不同部分并行进行插入，而无需对数据结构进行任何全局重新平衡。这种并行性对于ad-hoc无线网络中的资源发现特别有利，因为可以使随机化跳过列表对任何单个节点的丢失具有鲁棒性。[6]。</p><p>  As described above, a skip list is capable of fast                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}   insertion and removal of values from a sorted sequence, but it has only slow                O    (  n  )    {\displaystyle {\mathcal {O}}(n)}   lookups of values at a given position in the sequence (i.e. return the 500th value); however, with a minor modification the speed of  random access indexed lookups can be improved to                O    (  log  ⁡  n  )    {\displaystyle {\mathcal {O}}(\log n)}  .</p><p>如上所述，跳过列表能够快速O(LOG⁡n){\DisplayStyle{\Mathcal{O}}(\logn)}从排序的序列中插入和移除值，但是它仅具有在序列中给定位置的值的缓慢O(N){\DisplayStyle{\Mathcal{O}}(N)}查找(即返回第500个值)；但是，只要稍加修改，随机访问索引查找的速度就可以提高到O(Logdisplaystyle){\⁡{O}}(\logn)}。</p><p> For every link, also store the width of the link. The width is defined as the number of bottom layer links being traversed by each of the higher layer &#34;express lane&#34; links.</p><p>对于每个链接，还要存储链接的宽度。宽度被定义为每个较高层快速车道链接正在穿越的底层链接的数量。</p><p> For example, here are the widths of the links in the example at the top of the page:</p><p>例如，以下是页面顶部示例中的链接宽度：</p><p> 1 10 o---&gt; o---------------------------------------------------------&gt; o Top level 1 3 2 5 o---&gt; o---------------&gt; o---------&gt; o---------------------------&gt; o Level 3 1 2 1 2 3 2 o---&gt; o---------&gt; o---&gt; o---------&gt; o---------------&gt; o---------&gt; o Level 2 1 1 1 1 1 1 1 1 1 1 1 o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o---&gt; o Bottom levelHead 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th NIL Node Node Node Node Node Node Node Node Node Node</p><p>1 10 o-&gt；o---&gt；o顶层1 3 2 5 o-&gt；o-&&gt；o-&gt；o-&gt；O-&gt；o级别3 1 2 1 2 32 o--&gt；o-&gt；O Level 2 1 1 1 11 1 o-&o底层标题1 2 3 4 5 6 7 8 9 10 Nil节点节点。</p><p> Notice that the width of a higher level link is the sum of the component links below it (i.e. the width 10 link spans the links of widths 3, 2 and 5 immediately below it). Consequently, the sum of all widths is the same on every level (10 + 1 = 1 + 3 + 2 + 5 = 1 + 2 + 1 + 2 + 3 + 2).</p><p>请注意，较高级别链接的宽度是其下方组件链接的总和(即宽度10链接跨越宽度为3、2和5的链接)。因此，每个级别上所有宽度的总和是相同的(10+1=1+3+2+5=1+2+1+2+3+2)。</p><p> To index the skip list and find the i&#39;th value, traverse the skip list while counting down the widths of each traversed link. Descend a level whenever the upcoming width would be too large.</p><p>要为跳过列表编制索引并找到第i个值，请在遍历跳过列表的同时向下计数每个遍历的链接的宽度。只要即将到来的宽度太大，就会下降一个级别。</p><p> For example, to find the node in the fifth position (Node 5), traverse a link of width 1 at the top level. Now four more steps are needed but the next width on this level is ten which is too large, so drop one level. Traverse one link of width 3. Since another step of width 2 would be too far, drop down to the bottom level. Now traverse the final link of width 1 to reach the target running total of 5 (1+3+1).</p><p>例如，要查找第五个位置(节点5)中的节点，请遍历顶层宽度为1的链接。现在还需要四个步骤，但是这一层的下一个宽度是十个，这太大了，所以下降一个层。遍历一个宽度为3的链接。由于宽度为2的另一个台阶太远，请下降到最底层。现在遍历宽度为1的最后一个链接，以达到目标运行总数5(1+3+1)。</p><p> function lookupByPositionIndex(i) node ← head i ← i + 1  # don&#39;t count the head as a step  for level  from top  to bottom  do  while i ≥ node.width[level]  do  # if next step is not too far i ← i - node.width[level]  # subtract the current width node ← node.next[level]  # traverse forward at the current level  repeat  repeat  return node.value end function</p><p>函数lookupByPositionIndex(I)Node←Head I←i+1#≥i+1#don&#39；不将Head算作Level从上到下执行的步骤，而I Level节点。width[Level]do#如果下一步不太远I←i-node.width[Level]#减去当前宽度节点←节点。NEXT[Level]#在当前级别向前遍历重复返回节点。Value结束函数。</p><p> This method of implementing indexing is detailed in  Section 3.4 Linear List Operations in &#34;A skip list cookbook&#34; by William Pugh.</p><p>这种实现索引的方法在William Pugh的跳过列表食谱中的3.4节线性列表操作中有详细介绍。</p><p>    Skip lists are a probabilistic data structure that seem likely to supplant balanced trees as the implementation method of choice for many applications. Skip list algorithms have the same asymptotic expected time bounds as balanced trees and are simpler, faster and use less space.</p><p>跳过列表是一种概率数据结构，似乎有可能取代平衡树作为许多应用程序选择的实现方法。跳表算法具有与平衡树相同的渐近预期时间界，并且更简单、更快、占用更少的空间。</p><p>   Redis, an ANSI-C open-source persistent key/value store for Posix systems, uses skip lists in its implementation of ordered sets.  [8]</p><p>REDIS是用于POSIX系统的ANSI-C开放源码永久键/值存储，它在有序集的实现中使用跳过列表。[8]。</p><p> nessDB, a very fast key-value embedded Database Storage Engine (Using log-structured-merge (LSM) trees), uses skip lists for its memtable.</p><p>NessDB是一个非常快的键值嵌入式数据库存储引擎(使用日志结构合并(LSM)树)，它对其内存表使用跳过列表。</p><p>   Speed Tables are a fast key-value datastore for Tcl that use skiplists for indexes and lockless shared memory.</p><p>速度表是Tcl的快速键值数据存储，它使用跳跃列表作为索引和无锁共享内存。</p><p> leveldb, a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values</p><p>Level db，一个由Google编写的快速键值存储库，提供从字符串键到字符串值的有序映射。</p><p>  SkiMap uses skip lists as base data structure to build a more complex 3D Sparse Grid for Robot Mapping systems.  [10]</p><p>SkiMap使用跳过列表作为基础数据结构，为机器人地图系统构建更复杂的三维稀疏网格。[10]。</p><p> IOWOW, a persistent  C11 key/value storage library uses skip lists as its main data structure.</p><p>IOWOW是一个持久化的C11键/值存储库，它使用跳过列表作为其主要数据结构。</p><p> Skip lists are used for efficient statistical computations of  running medians (also known as moving medians).Skip lists are also used in distributed applications (where the nodes represent physical computers, and pointers represent network connections) and for implementing highly scalable concurrent  priority queues with less lock contention,  [11] or even without locking,  [12]  [13]  [14] as well as lockless concurrent dictionaries.  [15] There are also several US patents for using skip lists to implement (lockless) priority queues and concurrent dictionaries.  [16]</p><p>跳过列表用于运行介质(也称为移动介质)的有效统计计算。跳过列表还用于分布式应用程序(其中节点代表物理计算机，指针代表网络连接)，并用于实现高度可伸缩的并发优先级队列，锁争用较少，[11]甚至没有锁，[12][13][14]以及无锁并发字典。[15]还有几项美国专利用于使用跳过列表来实现(无锁)优先级队列和并发字典。[16]。</p><p>    ^     a     b   Papadakis, Thomas (1993).   Skip Lists and Probabilistic Analysis of Algorithms  (PDF) (Ph.D.). University of Waterloo.</p><p>^a b Papadakis，Thomas(1993)。跳过列表和算法概率分析(PDF)(博士)。滑铁卢大学。</p><p>  ^    Munro, J. Ian; Papadakis, Thomas;  Sedgewick, Robert (1992).  &#34;Deterministic skip lists&#34;  (PDF).  Proceedings of the third annual ACM-SIAM symposium on Discrete algorithms (SODA &#39;92). Orlando, Florida, USA: Society for Industrial and Applied Mathematics, Philadelphia, PA, USA. pp. 367–375.  doi: 10.1145/139404.139478.</p><p>门罗，J·伊恩；帕帕达基斯，托马斯；塞奇威克，罗伯特(1992)。确定性跳过列表(PDF)。第三届ACM-SIAM离散算法年度研讨会论文集(SODA&39；92)。奥兰多，佛罗里达，美国：工业与应用数学学会，宾夕法尼亚州费城，美国。第367-375页。10.1145/139404.139478。</p><p> ^   Bethea, Darrell; Reiter, Michael K. (September 21–23, 2009).   Data Structures with Unpredictable Timing  (PDF). ESORICS 2009, 14th European Symposium on Research in Computer Security. Saint-Malo, France. pp. 456–471, §4 &#34;Skip Lists&#34;.  doi: 10.1007/978-3-642-04444-1_28.  ISBN   978-3-642-04443-4.</p><p>题名/责任者：Reiter，Michael K.。(2009年9月21日至23日)。具有不可预测时序的数据结构(PDF)。ESORICS 2009，第14届欧洲计算机安全研究研讨会。圣马洛，法国。第456-471页，§4和#34；跳过列表&#34；。电话：04444-1_28，电话：10.1007/978-3-642。ISBN978-3-642-04443-4。</p><p> ^   Sen, Sandeep (1991). &#34;Some observations on skip lists&#34;.  Information Processing Letters.  39 (4): 173–176.  doi: 10.1016/0020-0190(91)90175-H.</p><p>^Sen，SanDeep(1991)。关于跳跃列表的一些观察&#34；。信息处理信函。39(4)：173-176。电话：90175-H，电话：10.1016/00200190(91)。</p><p> ^   Shah, Gauri (2003).   Distributed Data Structures for Peer-to-Peer Systems  (PDF) (Ph.D. thesis). Yale University.</p><p>^Shah，Gauri(2003)。对等系统的分布式数据结构(PDF)(博士论文)。耶鲁大学。</p><p> ^    Pugh, William (April 1989).   Concurrent Maintenance of Skip Lists  (PS, PDF) (Technical report). Dept. of Computer Science, U. Maryland. CS-TR-2222.</p><p>威廉·普夫(1989年4月)。同时维护跳过列表(PS、PDF)(技术报告)。部门。美国马里兰州计算机科学学院。CS-TR-2222。</p><p>   ^   Gregorio, Daniele De; Stefano, Luigi Di (2017). &#34;SkiMap: An Efficient Mapping Framework for Robot Navigation&#34;.  arXiv:  1704.05832 [ cs.CV].</p><p>^Gregorio，Daniele de；Stefano，Luigi Di(2017)。SkiMap：一种高效的机器人导航地图框架。Arxiv：1704.05832[cs.CV]。</p><p> ^   Shavit, N.; Lotan, I. (2000).  &#34;Skiplist-based concurrent priority queues&#34;  (PDF).  Proceedings 14th International Parallel and Distributed Processing Symposium. IPDPS 2000. p. 263.  CiteSeerX   10.1.1.116.3489.  doi: 10.1109/IPDPS.2000.845994.  ISBN   978-0-7695-0574-9.</p><p>沙维特，N.；洛坦，I.(2000)。&#34；基于Skiplist的并发优先级队列&#34；(PDF)。第十四届国际并行与分布式处理学术研讨会论文集。IPDPS 2000。第263页。CiteSeerX：10.1.1.116.3489.。DOI：10.1109/IPDPS.2000.84594.。ISBN电话：978-0-7695-0574-9。</p><p> ^   Sundell, H.; Tsigas, P. (2003). &#34;Fast and lock-free concurrent priority queues for multi-thread systems&#34;.  Proceedings International Parallel and Distributed Processing Symposium. p. 11.  CiteSeerX   10.1.1.113.4552.  doi: 10.1109/IPDPS.2003.1213189.  ISBN   978-0-7695-1926-5.</p><p>宋代尔，H.；Tsigas，P.(2003)。用于多线程系统的快速且无锁的并发优先级队列。国际并行与分布式处理学术研讨会论文集。第11页。CiteSeerX：10.1.1.113.4552.。DOI：10.1109/IPDPS.2003.1213189.。ISBN电话：978-0-7695-1926-5。</p><p> ^   Fomitchev, Mikhail; Ruppert, Eric (2004).   Lock-free linked lists and skip lists  (PDF). Proc. Annual ACM Symp. on Principles of Distributed Computing (PODC). pp. 50–59.  doi: 10.1145/1011767.1011776.  ISBN   1581138024.</p><p>米哈伊尔·福米切夫(Fomitchev)；埃里克·鲁珀特(Ruppert)(2004年)。无锁链接列表和跳过列表(PDF)。程序。ACM年度交流会。论分布式计算原理(PODC)。第50-59页。10.1145/1011767.1011776。ISBN为1581138024。</p><p> ^   Bajpai, R.; Dhara, K. K.; Krishnaswamy, V. (2008). &#34;QPID: A Distributed Priority Queue with Item Locality&#34;.  2008 IEEE International Symposium on Parallel and Distributed Processing with Applications. p. 215.  doi: 10.1109/ISPA.2008.90.  ISBN   978-0-7695-3471-8.</p><p>Bajpai，R.；Dhara，K.；Krishnaswamy，V.(2008)。&#34；QPID：具有项目位置的分布式优先级队列&#34；。2008年IEEE并行和分布式处理及其应用国际研讨会。第215页。DOI：10.1109/ISPA.2008.90.。ISBN电话：978-0-7695-3471-8。</p><p> ^   Sundell, H. K.; Tsigas, P. (2004).  &#34;Scalable and lock-free concurrent dictionaries&#34;  (PDF).  Proceedings of the 2004 ACM symposium on Applied computing - SAC &#39;04. p. 1438.  doi: 10.1145/967900.968188.  ISBN   978-1581138122.</p><p>宋代尔，香港；Tsigas，P.(2004)。可伸缩且无锁的并发字典(PDF)。2004年ACM应用计算研讨会论文集-SAC&#39；04。1438页。10.1145/967900.968188。ISBN978-1581138122。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/skip/">#skip</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>