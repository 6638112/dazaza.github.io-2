<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>软件安全的三个层次 The Three Levels of Software Safety</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Three Levels of Software Safety<br/>软件安全的三个层次 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-28 21:46:26</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/7358e63f71b4e326540d7150d64ae1a1.jpeg"><img src="http://img2.diglog.com/img/2020/12/7358e63f71b4e326540d7150d64ae1a1.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The more software eats the world, the more critical safety is … but what exactly does that mean?</p><p>吞噬世界的软件越多，安全性就越关键……但这到底意味着什么？</p><p>  Software engineers are bad at safety because software engineers are not used to th  e idea that software can injure. All around the industry, the mantel of technical leadership has been passed to people about my age, perhaps a few years older. We grew up when computers weren’t so powerful, when their use was an optimization rather than a necessity, when their first commercial successes were in toys. We don’t think about safety as being a relevant issue for software, and we need to change our perspective on that.</p><p>  软件工程师的安全性很差，因为软件工程师不习惯认为软件会造成伤害。在整个行业中，技术领导的风范已经传给了大约我这个年龄的人，也许是几岁。当计算机功能不那么强大，使用计算机是一种优化而非必要，计算机在玩具中首次取得商业成功时，我们就长大了。我们不认为安全是软件的重要问题，我们需要改变对此的看法。</p><p> But what does it mean for software to be safe? It’s easy to conceptualize how a car could be safe or unsafe. Easy to understand how a medical instrument could be safe of unsafe. But code?</p><p> 但是，软件安全意味着什么？很容易概念化汽车的安全性。易于理解的医疗仪器可能是不安全的。但是代码？</p><p> I like to think of software safety as being about three levels of concerns. Understanding where what you are building fits on those three levels, will tell you how best to focus your time and attention in a safety conversation.</p><p> 我喜欢将软件安全视为三个关注点。了解构建的内容在这三个层次上的适合程度，将告诉您如何最好地将时间和精力集中在安全对话上。</p><p>  For years, the only “safety” software developers thought about was “memory safety.” People will still jump to that conclusion, treating safety as a synonym for security.</p><p>  多年来，软件开发人员唯一想到的“安全性”就是“内存安全性”。人们仍然会得出这个结论，将安全视为安全的代名词。</p><p> The connection between memory and safety isn’t just a conflation of terms.   Safety is ultimately about preventing a system from reaching dangerous states. In software, the principle clearinghouse of state change is memory. So the first line of defense preventing a program from reaching a dangerous state is controlling  what can access its memory and  how that memory can be accessed.</p><p> 记忆与安全性之间的联系不只是术语的混用。安全最终是要防止系统达到危险状态。在软件中，状态更改的主要交换所是内存。因此，防止程序进入危险状态的第一道防线是控制可以访问其内存的内容以及如何访问该内存。</p><p> The need to manage what parts of memory a process can access traces its roots back to mainframe timesharing. Resource management and memory safety started as a straight forward customer service issue (if you’re paying for time and someone else is running something that eats up all the memory, it’s a problem). Computer scientists theorized that these annoyances could be weaponized and they almost immediately were starting with the Morris worm in 1988 and continuing to this day.</p><p> 管理进程可以访问内存的哪些部分的需要可以将其根源追溯到大型机分时。资源管理和内存安全起初是直接的客户服务问题（如果您花时间花钱，而其他人正在运行的东西耗尽了所有内存，那将是一个问题）。计算机科学家认为，这些烦恼可以被武器化，它们几乎是从1988年的莫里斯蠕虫开始的，一直持续到今天。 </p><p>  But as software grew in complexity and sophistication, state stopped relying on memory so much. A program could be “stateless” by passing state without storing it from one system to another in a transaction. The more common these kinds of designs became the more concurrency bugs and pure functions became part of conversations with software engineers. Undesirable states could be triggered by transactions happening in the wrong order (race conditions), or by depending on other states which were also in flux.</p><p>但是随着软件的复杂性和复杂性的提高，状态不再那么依赖内存。程序可以通过传递状态而无需在事务中将其从一个系统存储到另一个系统中，从而实现“无状态”。这些设计越常见，并发性错误就越多，纯功能成为与软件工程师对话的一部分。不良状态可能是由错误顺序的交易（竞赛条件）触发的，也可能取决于其他状态的变化。</p><p> Safety at this level of software becomes about predictability (or determinism). The ecosystem that has grown around it includes type systems and formal verification. These were not techniques that were invented the solve safety problems, but the renewed interest from academia and the penetration of such approaches in developer tooling is a direct result of increase awareness of how dangerous unpredictable systems can be.</p><p> 在此软件级别上，安全性与可预测性（或确定性）有关。围绕它发展的生态系统包括类型系统和形式验证。这些不是发明解决安全问题的技术，而是学术界的重新关注以及这种方法在开发人员工具中的渗透，直接导致人们越来越意识到危险的不可预测系统的直接结果。</p><p>  The area of software safety I find the most interesting is also its newest frontier. It’s the unsafe states that can occur when computers become participants in other larger human based systems. Like the issues in level 2, the problems and techniques of level 3 are not new discoveries. Modern technologies — particularly AI — have made them relevant in ways they were not before.</p><p>  我发现最有趣的软件安全领域也是其最新领域。当计算机成为其他更大的基于人的系统的参与者时，可能会出现不安全状态。像第2级中的问题一样，第3级中的问题和技术也不是新发现。现代技术（尤其是AI）使它们以前所未有的方式变得有意义。</p><p> Software has always been present in human systems, but there is a difference between being  present in the system and being a  participant in the system. When you use a database to keep track of inventory, software is present in the system. When you build software that automatically reorders items based on that database, the software is now a participant.</p><p> 软件一直存在于人类系统中，但是存在于系统中和成为系统参与者之间存在差异。当您使用数据库跟踪库存时，系统中存在软件。当您构建基于该数据库自动重新排序商品的软件时，该软件现在已成为参与者。</p><p> The key difference is whether software is recording state or altering state, because safety is ultimately about our likelihood of reaching undesirable states. As software automation becomes more and more prevalent, the issue of how software-initiated state changes can effect other  human participants in the process is moving into the forefront of the conversation around technology.</p><p> 关键区别在于软件是在记录状态还是在更改状态，因为安全性最终与我们达到不良状态的可能性有关。随着软件自动化变得越来越普遍，软件启动的状态更改如何影响流程中其他人员的问题正逐渐转移到围绕技术的对话中。</p><p> Many describe this issue as software  ethics, but for me it is a safety issue. Ethics assumes unsafe states are foreseeable. When a design decision causes an airplane to crash, we do not call ethics into question unless someone can demonstrate that the people who made that decision had information that suggested that outcome was a possibility. Otherwise it’s just an accident.</p><p> 许多人将此问题描述为软件伦理，但对我而言，这是一个安全问题。道德假设不安全状态是可以预见的。当设计决策导致飞机坠毁时，除非有人能够证明做出该决策的人掌握的信息表明可能发生结局，否则我们不会质疑道德。否则，这只是一个意外。</p><p> So far the tools we have to handle Level 3 are user centric design and problem setting processes. User centric design helps broaden our perspectives so we can see more potential outcomes on different potential interactions. Problem setting forces us to set boundaries with our technology. The same way memory safety restricts what states a program can access, problem setting asks software engineers to treat these powerful technologies as scalpels and restrict what parts of the process they can participate in.</p><p> 到目前为止，我们必须处理第3级的工具是以用户为中心的设计和问题设置流程。以用户为中心的设计有助于拓宽视野，因此我们可以在不同的潜在交互中看到更多潜在结果。问题解决迫使我们为技术设定界限。内存安全性限制程序可以访问的状态的方式相同，问题设置要求软件工程师将这些强大的技术视为手术刀，并限制其可以参与过程的哪些部分。 </p><p>  Safety, like risk, is ultimately about scale. At each level, problems that were always there take on new significance and the undesirable states that were always possible become more common. We shift our attention and develop new safety tools and techniques to accommodate these different priorities.</p><p>安全与风险一样，最终都将涉及规模。在每个级别上，始终存在的问题都具有新的意义，而总是可能出现的不良状态变得更加普遍。我们将注意力转移到新的安全工具和技术上，以适应这些不同的优先事项。</p><p> When a program runs on a single machine with a single user, the most relevant safety issues are how that program affects the state of the computer itself. Concurrency issues are still there; ergonomic issues are still there, but the impact either of those issues have is not as significant. If a single isolated computer has concurrency issues all the data needed to it sort out and determine the correct state is on that single computer. If a single user has a negative outcome from using the program it is unlikely to spread to other users unless the program is shared.</p><p> 当程序在具有单个用户的单台计算机上运行时，最相关的安全问题是该程序如何影响计算机本身的状态。并发问题仍然存在。人体工程学问题仍然存在，但是这些问题中的任何一个都不那么重要。如果一台隔离的计算机具有并发性问题，则需要对其进行整理的所有数据并确定该单台计算机上的正确状态。如果单个用户使用该程序带来负面结果，除非共享该程序，否则不太可能传播给其他用户。</p><p> When a single computer grows to a network the first level of safety is still important, but the second level of safety becomes more dangerous. State moves from computer to computer and the blast radius of undesirable state changes increases.</p><p> 当一台计算机成长为网络时，第一安全级别仍然很重要，但是第二安全级别变得更加危险。状态从计算机移到计算机，不良状态变化的冲击波半径增加。</p><p> When digital systems stop merely supporting processes but become load bearing participants of that process, the third level of safety moves to the front of the line. Again the blast radius of undesirable state changes increases, damaging not just machines but causing people to take actions that are misinformed and potentially injurious.</p><p> 当数字系统仅停止支持流程而成为该流程的负载参与者时，第三级安全性将转移到生产线的前端。不良状态变化的爆炸半径再次增加，不仅损坏机器，还导致人们采取错误的行为并可能造成伤害。</p><p> The first step in developing a safety practice is to determine what scale what you are building will reach in the immediate future and focus on building out best practices around that level of safety. Then as you scale the technology, continue to evolve your approach to reflect the concerns of higher levels.</p><p> 制定安全规范的第一步是确定在不久的将来您要构建的规模将达到什么规模，并着重于围绕该安全级别制定最佳实践。然后，在扩展技术时，继续发展您的方法以反映更高层次的关注。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bellmar.medium.com/the-three-levels-of-software-safety-2097610ada60">https://bellmar.medium.com/the-three-levels-of-software-safety-2097610ada60</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/software/">#software</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>