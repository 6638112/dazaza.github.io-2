<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在AWS S3上搜索1B页面，为1000美元/月，以锈蚀和态度制成 Search 1B pages on AWS S3 for 1000$ / month, made in Rust and tantivy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Search 1B pages on AWS S3 for 1000$ / month, made in Rust and tantivy<br/>在AWS S3上搜索1B页面，为1000美元/月，以锈蚀和态度制成 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-07 19:45:44</div><div class="page_narrow text-break page_content"><p>This blog post pairs best with our  common-crawl demo and a glass of vin de Loire.</p><p>这篇博客帖子与我们的共同爬行演示和一杯Vin de Loire配对。</p><p> Six months ago, we founded Quickwit with the objective of building a new breed of full-text search engine that would be 10 times more cost-efficient on very large datasets. How do we intend to do this? Our search engine will search data straight from Amazon S3, achieving true decoupled compute and storage.</p><p> 六个月前，我们创立了QuickWit，目的是建立一种新的全文搜索引擎，这将在非常大的数据集上成本高10倍。我们如何打算这样做？我们的搜索引擎将从Amazon S3中搜索数据，实现真正的解耦和存储。</p><p> For distributed compute engines such as Presto or Spark, decoupled compute and storage has been a reality for a while. However, for search engines, this is a new trend.</p><p> 对于诸如Presto或Spark等分布式计算发动机，解耦计算和存储是一段时间的现实。但是，对于搜索引擎来说，这是一种新的趋势。</p><p> In May 2020, Amazon Elasticsearch Service released UltraWarm, a solution to search straight from Amazon S3 that claims to search petabytes of data in minutes according to this  AWS Online Tech Talk.</p><p> 5月2020年5月，亚马逊Elasticsearch服务发布了UltraWarm，一个解决方案，用于在亚马逊S3中直接搜索，该解决方案根据这次AWS在线技术谈判在几分钟内搜索PetAbytes的数据。</p><p> In March 2021, Elastic also released  frozen tier search, giving Elasticsearch users the possibility to mount and start searching indexes on stored Amazon S3 in a dozen seconds.Amazon and Elastic both built their solution based on some cunning caching layer to search Elasticsearch indexes and communicate sparingly about the performance of their solutions. We, on the other hand, had the luxury to design our search engine from the ground up helping us deliver performance close to what an index residing on an SSD disk can offer.</p><p> 在3月2021年，Elastic还发布了冻结层搜索，使Elasticsearch用户能够在十几个秒秒数中安装和开始在存储的Amazon S3上搜索索引的可能性.AMAZON和弹性都基于一些狡猾的缓存层建立了解决方案，以搜索Elasticsearch索引并进行通信。谨慎地对他们的解决方案的表现。另一方面，我们有奢侈品从地上设计搜索引擎，帮助我们提供靠近驻留在SSD磁盘上的索引提供的性能。</p><p> Our ascetic quest to truly separate compute and storage led us to a solution that is entirely stateless. Not only is our solution more cost-efficient, but our search clusters are also easier to operate. One can add or remove search instances in seconds. Multi-tenant search becomes trivial.</p><p> 我们的禁欲追求真正独立的计算和存储，使我们成为一个完全无状态的解决方案。我们的解决方案不仅可以更具成本效益，但我们的搜索集群也更容易运行。可以在几秒钟内添加或删除搜索实例。多租户搜索变得微不足道。</p><p> As we were developing our engine, we started having conversations with potential users. Often, as we chanted the virtues of our future solution, our claims were met with healthy skepticism.</p><p> 我们正在开发发动机，我们开始与潜在用户进行对话。通常，随着我们阐明未来解决方案的优点，我们的索赔得到了健康的怀疑。 </p><p> Let&#39;s be honest, &#34;10 times cheaper&#34; has a bad teleshopping vibe and there is a plethora of bold performance claims in the database world.</p><p>让＆＃39;是诚实的，＆＃34; 10倍更便宜＆​​＃34;在数据库世界中有一个糟糕的电视氛围，并且在数据库世界中存在大胆的表现索赔。</p><p>  So we set out to build a compelling demo based on a large dataset. The  Common Crawl corpus, consisting of several billion web pages, appeared as the best candidate. Our  demo is simple: the user types the beginning of a phrase and the app finds the most common adjective or noun phrases that follow in the 1 billion web pages that we have indexed.</p><p>  因此，我们开始根据大型数据集建立一个引人注目的演示。常见的爬网语料库，由几亿网页组成，出现成为最佳候选人。我们的演示很简单：用户类型短语的开头和应用程序在我们索引的10亿个网页中查找最常见的形容词或名词短语。</p><p> How does this demo work?At a high level, this demo is built on top of the following components:</p><p> 该演示如何工作？在高级别，此演示建立在以下组件之上：</p><p> an NLP server that extracts adjectives and noun phrases from matching snippets and computes the most common occurrences</p><p> 从匹配片段中提取形容词和名词短语的NLP服务器，并计算最常见的事件</p><p>   The index for this demo contains 1 billion English pages extracted from the latest Common Crawl snapshot. We identified those pages using the excellent natural language detection library,  Whatlang. Our indexing engine written in Rust ran for approximately 24 hours on a single Amazon EC2 instance (m5d.8xlarge) to produce a 6.8 TB index stored on Amazon S3. We are satisfied with that throughput considering that the engine also downloaded and decompressed (gzip) thousands of Common Crawl WET files, performed language detection on each page, stemmed each word in the corpus, and finally built and uploaded the index. This index is split into 180 shards to allow for parallel production and consumption. Quickwit usually performs shard pruning based on the shards’ metadata, unfortunately Common Crawl does not offer such an opportunity.</p><p>   此演示的索引包含10亿英文页面从最新的常见爬网快照中提取。我们通过Whatlang确定了使用优秀的自然语言检测库的页面。我们的索引引擎在单个Amazon EC2实例（M5D.8xlarge）上rutr ran写入大约24小时，以生成存储在Amazon S3上的6.8 TB索引。我们对考虑到发动机的吞吐量也满意，考虑到发动机还下载和解压缩（GZIP）数千次常见的爬网湿文件，在每个页面上执行语言检测，源于语料库中的每个单词，最后构建并上传了索引。该指数分为180个碎片，以允许并行生产和消耗。 QuickWit通常根据碎片的元数据进行碎片修剪，不幸的是常见的爬行并没有提供这样的机会。</p><p>  Our search engine is made up of stateless search instances that simply run our code to fetch and its data directly from Amazon S3. They do not maintain a partial copy of the index or any other data structure on their local disks. This makes scaling and operating the cluster, or handling failures trivially easy. When a query is submitted to the cluster, one instance, chosen randomly among the instances constituting the cluster, becomes the coordinator for the query. The coordinator determines the list of relevant shards for the query, evenly distributes the work among peer search instances, and waits for the partial results to come back. The coordinator merges and sorts those partial results and returns them to the client.For this demo, we deployed our search engine on two Amazon EC2 instances (c5n.2xlarge). Those instances have good CPUs but also provide good network performance, which is key as each instance issues a lot of parallel requests to Amazon S3 and tends to be bound by the network.</p><p>  我们的搜索引擎由无状态搜索实例组成，只需从Amazon S3直接运行我们的代码以获取和数据。它们不会在其本地磁盘上维护索引或任何其他数据结构的部分副本。这使得缩放和操作群集，或者使失败变得简单。当查询被提交到群集时，一个实例在构成群集的实例中随机选择，成为查询的协调器。协调器确定查询的相关碎片列表，均匀地分配对等搜索实例之间的工作，并等待部分结果返回。协调器合并并对这些部分结果进行分类并将其返回给客户端。对于此演示，我们将在两个Amazon EC2实例（C5N.2xlarge）上部署我们的搜索引擎。这些实例具有良好的CPU，但也提供了良好的网络性能，这是每个实例对Amazon S3发出大量并行请求的关键，并且往往受网络绑定。</p><p>  When asked about the performance and latency of our search engine, our answer is invariably the same: “it depends on the query.”</p><p>  当被问及搜索引擎的性能和延迟时，我们的答案总是相同的：“它取决于查询。” </p><p> For a “simple” query that contains five or fewer query terms and is limited to the first hundred hits or less, our search engine is able to answer in one to two seconds. For instance, the latency for the query “+Barack AND +Obama” limited to 200 hits is 1.5 seconds on average. When an index and a query allow for shard pruning, we sometimes have the ability to answer in less than a second.</p><p>对于包含五个或更少的查询术语的“简单”查询，并且仅限于前一百个点击或更少，我们的搜索引擎能够在一到两秒钟内回答。例如，查询“+ barack和+ obama”限制为200次点击的延迟是平均1.5秒。当索引和查询允许碎片修剪时，我们有时能够在不到一秒钟内回答。</p><p> However, for more complex queries that require more bandwidth and processing time, latency is increased. For instance, for this demo, we are not only interested in web pages that contain all the query terms but also those that have them in the right order - think “Barack Obama is the president” vs. “The president is Barack Obama”. In information retrieval lingo, those types of queries are called phrase queries and are supported by most search engines with a double quotes syntax. In our case, we need to fetch an additional data structure that encodes the position of each token in the web pages to process phrase queries. Furthermore, for the need of this demo, we do not limit ourselves to the first n results. On the contrary, we actually want to retrieve all the web pages that match the phrase query and for some very frequent terms, this can be a lot of pages. For that reason, we’ve capped the number of results returned per shard to 1,000. The phrase query “Barack Obama is” reaches that cap and returns 18,000 snippets in 12 to 15 seconds.</p><p> 但是，对于需要更多带宽和处理时间的更复杂查询，增加了延迟。例如，对于此演示，我们不仅对包含所有查询条款的网页感兴趣，而且还有那些以正确的订单有关的网页 - 认为“巴拉克奥巴马是总统”与“总统是巴拉克奥巴马”。在信息检索Lingo中，这些类型的查询称为短语查询，并且由大多数搜索引擎支持，具有双引号语法。在我们的情况下，我们需要获取一个附加数据结构，该数据结构将每个令牌的位置进行编码，以处理短语查询。此外，对于需要这个演示，我们不会将自己限制在第一个结果。相反，我们实际上想要检索与短语查询匹配的所有网页，并且对于一些非常频繁的术语，这可能是很多页面。因此，我们已经盖住了每分碎片返回的结果数量为1,000。短语查询“Barack Obama是”达到该帽，并在12到15秒内返回18,000个片段。</p><p> We are planning on releasing a proper benchmark of our search engine accompanied by a blog post in the upcoming months.</p><p> 我们计划在即将到来的几个月内伴随着博客文章的搜索引擎的适当基准。</p><p>  The NLP server streams up to 18,000 matching snippets from the search engine and pushes them through a Python library called  Pattern to identify and extract adjectives or noun phrases. The server counts each occurrence and when all the fragments have been processed, it returns the most common ones to the front-end, which is then able to display a word cloud.</p><p>  NLP服务器从搜索引擎中流出高达18,000个匹配的片段，并通过称为模式的Python库推动它们以识别和提取形容词或名词短语。服务器计算每次发生，并且当处理所有片段时，它将最常见的部分返回到前端，然后能够显示一个单词云。</p><p>  We estimated that the cost of our experiment is less than $1,000 per month. Storing the index on Amazon S3 costs $160 per month and deploying a small pool of two search instances costs $650 per month. We also incurred a one-time, $45 expense for indexing the dataset. In the future, we should be able to cut costs further by deploying our code on Amazon Graviton instances.</p><p>  我们估计，我们的实验成本每月少于1,000美元。将索引存储在Amazon S3上的费用$ 160每月，并部署两个搜索实例的小池，每月$ 650。我们还颁发了一次性，45美元的费用，用于索引数据集。在未来，我们应该能够通过在Amazon Graviton实例上部署我们的代码进一步降低成本。</p><p>  In the next few months, we will start open-sourcing our search engine. We will accompany the release with a series of blog posts explaining our unique technology and sharing our vision and roadmap.</p><p>  在接下来的几个月里，我们将开始开放我们的搜索引擎。我们将伴随着一系列博客帖子，解释我们独特的技术和分享我们的视野和路线图。</p><p> In the meantime, if you have any questions, think about an interesting use case for our search engine, or are interested in becoming a beta user, get in touch with us at  hello@quickwit.io</p><p> 与此同时，如果您有任何疑问，请考虑我们的搜索引擎的有趣用例，或者有兴趣成为Beta用户，请与我们联系Hello@quickwit.io </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quickwit.io/blog/commoncrawl/">https://quickwit.io/blog/commoncrawl/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/态度/">#态度</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aws/">#aws</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>