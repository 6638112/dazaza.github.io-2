<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Invoke_is_Too_High_Level Invoke_is_Too_High_Level</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Invoke_is_Too_High_Level<br/>Invoke_is_Too_High_Level </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-28 23:44:05</div><div class="page_narrow text-break page_content"><p>I&#39;m in the process of re-certifying for the GREM certification (GIAC Reverse Engineering Malware). Although I&#39;m pretty good with assembly language in a handful of architectures (Motorolla, x86, propeller, and ARM), my skills are shit with Windows and its APIs. In the context of GREM and static code analysis goes, I still have a ways to go; a &#39;not seeing the forest for the trees&#39; issue. I will still likely pass the certification like last time, because I understand most of the concepts in their compartmentalized pieces. My problem is some of the big picture stuff (always has been). I joke about everything being too high level, and honestly, most of the time it really is a joke or an extreme over exaggeration. But for me, I sometimes do have a harder time comprehending an abstraction when it abstracts away how things actually work. For most people, it doesn&#39;t matter how the technology works, so long as it does. However, as a hacker, I have technology &#39;trust issues&#39;; things don&#39;t always &#39;just work.&#39;. And the abstraction likely wont give you any hints as to why the thing failed, the answers are revealed at a lower layer.</p><p>我正在重新认证GREM认证（GIAC反向工程恶意软件）。尽管我在几种体系结构（Motorolla，x86，propeller和ARM）中对汇编语言非常满意，但是我的技能却是Windows及其API。在GREM和静态代码分析的背景下，我还有路要走。一个看不见森林的树木问题。我仍然很可能会像上次一样通过该认证，因为我了解其概念中的大多数概念。我的问题是一些总的来说（一直都是）。我开玩笑说一切都太高了，说实话，在大多数情况下，这确实是个玩笑或夸张的极端。但是对我来说，有时候我很难理解一个抽象，它抽象了事物的实际运行方式。对于大多数人来说，只要技术有效，技术如何运作都无关紧要。但是，作为一名黑客，我遇到了技术和信任问题。事情并不总是能正常工作。而且抽象可能不会给您任何提示，说明事情为什么失败，答案会在较低层显示。</p><p> Blah blah blah, I digress. I wanted to set out to learn many of these Windows APIs in a bit more detail. Reverse engineering usually teaches how to read the code, but my (and probably your) comprehension magnifies when we actually write code. So in this case, I wanted to set out and write a few very simple assembly programs that put the correct arguments on the stack and call a Windows API, just how I see this happening when debugging some malware, just how it is supposed to work. As a point of reference I am using the FLARE VM setup from FireEye. It comes with fasm, so that&#39;s the assembler I will use (I don&#39;t really have religious preferences with an assembler).</p><p> 等等等等，我离题了。我想着手更详细地学习许多这些Windows API。逆向工程通常会教如何读取代码，但是当我们实际编写代码时，我（可能还有您）的理解就会放大。因此，在这种情况下，我想设置并编写一些非常简单的汇编程序，这些程序将正确的参数放在堆栈上并调用Windows API，这就是调试某些恶意软件时我如何看待这种情况，以及它应该如何工作。作为参考，我正在使用FireEye的FLARE VM设置。它带有魅力，因此我将使用汇编器（我对汇编器确实没有宗教偏爱）。</p><p> For API&#39;s, the Windows way is a bit different than the Linux way. For Linux, generally, you put all of your arguments in registers and then do an Int 80 (interrupt to Linux). In windows, with &#39;sdtcall&#39; functions, you push all of your arguments to the stack and Call the Windows API function by name (the corresponding addresses of these functions end up getting linked in). I&#39;m not really opposed to this method, it allows for a large amount of arguments by default, as it&#39;s the stack, not a limited amount of registers.</p><p> 对于API，Windows方式与Linux方式有些不同。对于Linux，通常，您将所有参数都放在寄存器中，然后执行Int 80（中断Linux）。在Windows中，使用＆sdtcall＆＃39;函数，将所有参数推入堆栈，然后按名称调用Windows API函数（这些函数的相应地址最终被链接到其中）。我并不是真的反对这种方法，它默认情况下允许大量参数，因为它是堆栈，而不是有限的寄存器。</p><p> As I didn&#39;t know the fasm ways of assembly, I looked to the Internet for some examples. I wanted to create a simple dialog box. I expected to see a simple assembly program with a .data section with the strings and then the .text (.code) section with some instructions pushing the arguments to the stack and then a call to the API function. For pretty much every google result I got, what I got back was a heavily abstracted version of how this is generally done, and the ironic bonus: NO ASSEMBLY INSTRUCTIONS!</p><p> 由于我不了解汇编的流行方式，因此我在Internet上查找了一些示例。我想创建一个简单的对话框。我希望看到一个简单的汇编程序，其中包含带有字符串的.data节，然后是带有一些指令的.text（.code）节，这些指令将参数推入堆栈，然后调用API函数。对于我所获得的几乎所有Google搜索结果，我得到的都是方法的抽象版本，并且具有讽刺意味的是：没有组装说明！</p><p> Before I get to that, I will say that I eventually figured out the way to do this with real assembly language in the source file. And it was as straight forward as I would have expected it to be. For reference, here is a screenshot of the source program:</p><p> 在此之前，我会说我最终想出了一种使用源文件中的实际汇编语言进行此操作的方法。这和我预期的一样直接。作为参考，这是源程序的屏幕截图：</p><p>    Note that the assembly looks awfully similar to the source. This is no mistake. This is exactly what I&#39;m going for here. Remembering that my goal is to try and understand what is actually going on with these API functions, this is the most comprehensible way to go about this. You&#39;ll notice that all the arguments are on the stack and ready to go for when I&#39;m about to call them. And it is extremely clear how they all got onto the stack (the 4 preceding push instructions).</p><p>    请注意，该程序集看起来与源程序非常相似。没错这正是我要去的地方。记住我的目标是尝试了解这些API函数的实际作用，这是实现此目的的最容易理解的方法。您会注意到，所有参数都在堆栈上，并准备在我要调用它们时使用。而且非常清楚它们是如何进入堆栈的（前面的4个压入指令）。</p><p> Okay. Now let&#39;s talk about the &#39;no assembly required&#39; way that is recommended to write this. Because the source code is easier to read. Because it&#39;s &#39;cleaner code.&#39; Because assembly language is so &#39;hard&#39; to write that you might as well write assembly programs that don&#39;t use assembly instructions (then just give up and fucking use python). Anyway, here&#39;s a screenshot of the &#39;clean&#39; way to do this:</p><p> 好的。现在，我们来讨论不需要组装的情况。建议写这种方式。因为源代码更易于阅读。因为它是更干净的代码。因为汇编语言很难编写您最好编写不使用汇编指令的汇编程序（然后只使用python放弃并他妈的）。无论如何，这是“清理”的屏幕截图方法： </p><p>  It is clearer to read. If there were no comments in my version, then the &#39;invoke&#39; version would be much more obvious in its intentions. But now, here&#39;s a screenshot of how dirty and incomprehensible this is in the debugger:</p><p>阅读起来更清晰。如果我的版本中没有评论，则＆＃39; invoke＆＃39;版本将在其意图上更加明显。但是现在，这是该调试器中的肮脏性和不可理解性的屏幕截图：</p><p>  Before I start ranting and criticizing, I have to be fare and state that the examples I found on the Internet didn&#39;t use a .data section and inlined the strings in the invoke section (cleaner source code). This is the real cause of the mess of the disassembly. Had I used a .data section with this invoke command: &#39;invoke MessageBox,HWND_DESKTOP,message,title1,MB_OKCANCEL&#39;, it woulnd&#39;t be so bad. I digress. So note that even though the source code is &#39;clean,&#39; what&#39;s actually being &#39;assembled&#39; (compiled really) is nothing but. You see as we are about to make the call, all the right arguments are on the stack. I see two of the original pushes needed for two of our arguments (push 1 and push 0). We also need two more arguments; we need pointers to our strings for the title of the window and the message in the window. How on earth did these get into the stack, and what the fuck are these confusing instructions doing in our program. Do we really need to do ARPL, INSB, OUTSD, DAA, and IMUL instructions? Well no, that&#39;s not what is happening. What we are actually seeing is a disassembled representation of our strings. See our first call to &#39;syscalls.40201B&#39;, it&#39;s jumping past our first string. A call normally knows how to return to where we came from by pushing the address of the next instruction to the stack. In this case though, our program doesn&#39;t intend to return to this at all, it is using that pushed address as a side effect, as that address really is the first byte of our string, it serves as a pointer to it, and it is now on the stack conveniently as an argument. So that call jumps us to another call that does the same thing; it skips over the next string that follows it, getting a pointer to it on the stack, indirectly. So that second call instruction brings us all the way down to the &#39;push 0&#39; instruction right before our API call to MessageBoxA. These abused CALL instructions are how we got the string arguments onto the stack.</p><p>  在我开始大声疾呼和批评之前，我得先提个价，并声明我在Internet上找到的示例没有使用.data节，而是在invoke节（更干净的源代码）中插入了字符串。这是造成混乱的真正原因。如果我在此调用命令中使用了.data节：＆＃39;调用MessageBox，HWND_DESKTOP，message，title1，MB_OKCANCEL＆＃39;那就太糟糕了。我离题了。因此请注意，即使源代码是干净的，实际组装的是什么（实际上是编译的）仅此而已。您将看到我们即将进行调用时，所有正确的参数都在堆栈中。我看到了我们两个参数（推1和推0）所需的两个原始推。我们还需要另外两个参数。我们需要指向我们的字符串的指针以获取窗口标题和窗口中的消息。这些到底是如何进入堆栈的，这些令人困惑的指令在我们的程序中到底是做什么的。我们真的需要做ARPL，INSB，OUTSD，DAA和IMUL指令吗？好吧，那不是正在发生的事情。我们实际上看到的是字符串的分解表示。请参见我们对syscalls.40201B的第一个调用，它已经跳过了我们的第一个字符串。通常，通过将下一条指令的地址压入堆栈，调用通常知道如何返回原点。不过，在这种情况下，我们的程序根本不打算返回到该地址，它是使用该推入地址作为副作用的，因为该地址确实是我们字符串的第一个字节，它充当了指向该地址的指针，现在可以方便地将其作为参数放在堆栈中。这样，该呼叫使我们跳至执行相同操作的另一个呼叫。它跳过了紧随其后的下一个字符串，从而间接地在堆栈上获得了指向它的指针。因此，第二个调用指令将我们带到了“推0＃39;”。在我们对MessageBoxA的API调用之前的指令。这些滥用的CALL指令是我们如何将字符串参数传递到堆栈上的。</p><p> The end result is the same. As somebody that has to read or write the assembly source, using invoke is likely a better way to write and collaborate. However, nothing about it is actual assembly language, it abstracts it away. It&#39;s not like this behavior is uncommon or indefensible. Compilers do this kind of thing all the time, even when they aren&#39;t optimized that much (and when they are optimized, wow). Joking aside, using invoke is probably the way to go if your writing something more serious, although, why not just use C? Writing &#34;assembly&#34; in shortcuts and macros with no actual assembly sounds a lot like a higher level language (like C). This is why I always found HLA (High Level Assembly) so objectionable. Though to be clear, I respect the Author of HLA and he has done other really amazing work.</p><p> 最终结果是相同的。作为必须读取或编写汇编源代码的人，使用invoke可能是一种更好的编写和协作方式。但是，关于它的并不是实际的汇编语言，而是将其抽象化了。并非这种行为不常见或无法防御。编译器一直都在做这种事情，即使它们没有做那么多的优化（当它们被优化时，哇）。撇开玩笑，如果您写的东西比较严重，那么使用invoke可能是解决问题的方法，尽管如此，为什么不只使用C呢？写作＆＃34;汇编＆＃34;没有实际汇编的快捷方式和宏中的声音听起来很像是高级语言（例如C）。这就是为什么我总是觉得HLA（高级别程序集）如此令人反感的原因。尽管很清楚，但我尊重HLA的作者，他还做了其他非常出色的工作。</p><p> A lot of arguments of which way is better than which (with many things) comes down to what your doing at the moment. In the use case from the paragraph above, invoke away. But to return to my use case, I&#39;m trying to familiarize myself with some simple Windows API calls by playing with different arguments in assembly and calling them, and then watching them perform their actions in a debugger (as not all API&#39;s will do something visual; I might have to see the stack, registers, and memory getting manipulated). Using invoke for this strategy makes this process all the more confusing.</p><p> 关于哪种方法要比哪种方法（在很多方面）要好得多的很多争论都归结为您目前所做的事情。在上一段的用例中，请调用。但是，回到我的用例，我试图通过在汇编中使用不同的参数并对其进行调用，然后看着它们在调试器中执行其动作，来使自己熟悉一些简单的Windows API调用（因为不是所有的API＆＃ 39; s会做一些视觉上的事情；我可能不得不看一下堆栈，寄存器和内存被操纵了）。为该策略使用invoke会使此过程更加混乱。</p><p> All this said, you might be able to see why I have a little ways to go when it comes to fully reverse engineering Windows binaries. Not to be confused with targeted reversing. I&#39;m somewhat adequate with looking at particular APIs and pulling out IOCs from the artifacts they leave behind, and all the other &#39;cheater&#39; dynamic forms of analysis. But if I ever want to see a bigger and fuller picture, I&#39;m going to want to start writing the assembly that I&#39;m reading and put bigger pieces of the puzzle together. At least, that&#39;s the plan.</p><p> 综上所述，您可能会明白为什么要对Windows二进制文件进行完全逆向工程时，我还有点路要走。不要与有针对性的倒车相混淆。我在研究特定的API并从它们留下的工件以及所有其他作弊者中拉出IOC方面已经足够了。动态形式的分析。但是，如果我想看到更大更完整的图片，我将要开始编写我正在阅读的程序集，并将更大的难题拼凑在一起。至少那是计划。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://xlogicx.net/Invoke_is_Too_High_Level.html">https://xlogicx.net/Invoke_is_Too_High_Level.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/high/">#high</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>