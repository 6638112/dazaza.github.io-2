<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>《无服务器之地》中的编排与编排</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">《无服务器之地》中的编排与编排</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 14:08:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/5fe87ea0d7b10eddc9d1c3b2dc7016dc.png"><img src="http://img2.diglog.com/img/2020/11/5fe87ea0d7b10eddc9d1c3b2dc7016dc.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In orchestration, there is a controller (the ‘orchestrator’) that controls the interaction between services. It dictates the control flow of the business logic and is responsible for making sure that everything happens on cue. This follows the request-response paradigm.</p><p>在编排中，有一个控制器(“编制者”)控制服务之间的交互。它规定了业务逻辑的控制流，并负责确保一切按提示进行。这遵循请求-响应范例。</p><p> In choreography, every service works independently. There are no hard dependencies between them, and they are loosely coupled only through shared events. Each service listens for events that it’s interested in and does its own thing. This follows the event-driven paradigm.</p><p>在编排中，每个服务都独立工作。它们之间没有硬依赖，它们只通过共享事件松散耦合。每个服务监听它感兴趣的事件，并做自己的事情。这遵循事件驱动的范例。</p><p> As always, neither is necessarily better than the other. Depending on the context, one might be more appropriate than the other. And since Lambda itself is inherently event-driven, the choreography approach has become very popular in the serverless community. I’m a huge fan of this approach and have built many event-driven systems using services such as EventBridge, SNS and Kinesis.</p><p>一如既往，两者都不一定比另一个更好。根据上下文的不同，其中一个可能比另一个更合适。由于Lambda本身本质上是事件驱动的，编排方法在无服务器社区中变得非常流行。我是这种方法的铁杆粉丝，已经使用EventBridge、SNS和Kinesis等服务构建了许多事件驱动系统。</p><p> However, in this post, I want to talk about when it’s not a good idea and when you should consider the orchestration approach instead.</p><p>然而，在这篇文章中，我想谈谈什么时候这不是一个好主意，什么时候你应该考虑使用编排方法。</p><p> The TL;DR is that, when it comes to implementing workflows,  you should prefer orchestration within the bounded context of a microservice, but prefer choreography between bounded contexts.</p><p>TL；DR的意思是，在实现工作流时，您应该更喜欢在微服务的有界上下文中进行编排，但更喜欢在有界上下文之间进行编排。</p><p>  Imagine you’re building a food ordering service where customers can order takeaways from their favourite restaurants. A typical order flow might involve the following five steps.</p><p>想象一下，你正在建立一个订餐服务，顾客可以从他们最喜欢的餐厅点外卖。典型的订单流可能涉及以下五个步骤。</p><p>      The customer sees the order confirmation and is eagerly waiting for the food to arrive.</p><p>顾客看到订单确认后，急切地等待着食物的到来。</p><p>  The restaurant clicks the  Complete Order in the app to confirm order has been delivered. This calls the  orders API.</p><p>餐厅点击应用程序中的完整订单，确认订单已经送达。这将调用Orders API。</p><p> Every function acted completely independently. None of them had the notion of the overall order flow, they each only cared about:</p><p>每项功能都是完全独立发挥作用的。他们中没有人有总体订单流的概念，他们各自只关心：</p><p>   Other systems can build on these events – e.g. a  promo-code service might be interested in the  order_completed event and send out discount vouchers to the customer.</p><p>其他系统可以基于这些事件-例如，促销代码服务可能对ORDER_COMPLETED事件感兴趣，并向客户发送折扣券。</p><p> The events are useful artefacts on their own, and can be fed into a data lake to generate business intelligence reports.</p><p>这些事件本身就是有用的人工制品，可以输入到数据湖中以生成商业智能报告。</p><p>  The order flow is not explicitly modelled and exists only as an emergent property of what system does. As such, it’s only captured in the mental model of someone who understands the system end-to-end.</p><p>订单流没有显式建模，只是作为系统所做工作的紧急属性而存在。因此，它只会被端到端理解系统的人的心理模型所捕获。</p><p> From a business point-of-view, it also begs the question “are these really separate processes? Or are they different steps within one process?”.</p><p>从业务的角度来看，这也回避了一个问题：“这些流程真的是分开的吗？抑或是同一过程中的不同步骤？“。</p><p> For business-critical workflows like this, wouldn’t you want someone or some team to take ownership of and be responsible for it? When something goes wrong and you lose millions by the hour, do you want a room full of people looking at each other because no-one understands the process end-to-end?</p><p>对于这样的业务关键型工作流，您难道不想让某个人或某个团队来负责它吗？当事情出了问题，你每小时损失数百万美元，你想让一屋子的人互相看着，因为没有人理解这个过程吗？</p><p> And if there are few people in the company understands how this critical flow works, then it creates an existential risk to the business if these people ever left the company.</p><p>如果公司里几乎没有人了解这种关键流程是如何运作的，那么如果这些人离开公司，就会给公司带来生死存亡的风险。</p><p>  To implement the orchestration approach, I will probably use something like Step Functions and model the order flow as a state machine.</p><p>为了实现编排方法，我可能会使用类似于步骤函数的方法，并将订单流建模为状态机。</p><p>  It’s also worth remembering that, although we no longer need to use events to trigger the next step of the order flow, those events are still useful artefacts on their own. So we should publish those same events from  Task states in the state machine. For example, after the  Notify User state notifies the user via SES, the  Task should also publish the  user_notified event.</p><p>同样值得记住的是，尽管我们不再需要使用事件来触发订单流的下一步，但这些事件本身仍然是有用的构件。因此，我们应该在状态机中发布来自任务状态的相同事件。例如，在NOTIFY USER状态通过SES通知用户之后，任务还应该发布USER_NOTIFIED事件。</p><p> This means we can still decouple the order flow from other business units that wish to build features on top of events related to an order. The aforementioned  promo-code service can still rely on the  order_completed event as before.</p><p>这意味着我们仍然可以将订单流与其他业务部门分离，这些业务部门希望在与订单相关的事件之上构建功能。上述促销代码服务仍然可以像以前一样依赖于ORDER_COMPLETED事件。</p><p>   End-to-end monitoring and reporting are trivial since Step Functions gives you built-in visualization and audit histories.</p><p>端到端的监控和报告非常简单，因为STEP函数为您提供了内置的可视化和审核历史记录。</p><p> Easy to implement timeout – e.g. for a restaurant to accept an order, or for the total duration of the order.</p><p>易于实现超时-例如，餐厅接受订单，或订单的整个持续时间。</p><p> Business logic is in one place, and it’s easy to maintain and manage.</p><p>业务逻辑集中在一个地方，易于维护和管理。</p><p> The order flow is modelled and source controlled. You can literally see it in the Step Functions console.</p><p>对订单流进行建模，并对其进行源代码控制。您可以在STEP Functions控制台中直接看到它。</p><p> The order flow is modelled and source controlled. Yes, it’s that important that it should count as two pros!</p><p>对订单流进行建模，并对其进行源代码控制。是的，这很重要，应该算作两个专业选手！</p><p>  At $25 per million state transitions (which counts  Start and  End by the way), Step Functions is a pricey service.</p><p>每百万次状态转换收费25美元(顺便说一句，这包括开始和结束)，Step Functions是一项昂贵的服务。</p><p> If Step Functions is down, then no orders can be processed. Although the same might be said about Lambda, EventBridge, or any services that are critical to the working of this order flow.</p><p>如果步骤功能关闭，则无法处理任何订单。尽管对于Lambda、EventBridge或对此订单流的工作至关重要的任何服务也可能会说同样的话。</p><p>  Within a bounded context, I have a specific set of responsibilities that are aligned with a business area. And there are hopefully a small number of components that they can all fit inside my head at the same time. Since they all work together to achieve some specific business capability such as processing payments, they form a highly cohesive unit. And since I own everything within this microservice’s bounded context, I’m free to change and reorganize things so long I don’t break my contract with external services.</p><p>在有限的上下文中，我有一组特定的职责，这些职责与某个业务领域保持一致。希望有一小部分组件可以同时放入我的大脑中。由于它们都在一起工作以实现某些特定的业务能力，如处理支付，因此它们形成了一个高度凝聚力的单元。而且，由于我拥有这个微服务的受限上下文中的所有内容，所以只要我不破坏与外部服务的合同，我就可以自由地更改和重组。</p><p>    I love using events to integrate different services together in a loosely-coupled way. But I think it’s a bad idea when it’s done inside the same bounded context because the workflow doesn’t exist as a standalone concept that is explicitly captured and source controlled.</p><p>我喜欢使用事件以松散耦合的方式将不同的服务集成在一起。但我认为，如果它是在相同的受限上下文中完成的，那就不是一个好主意，因为工作流不是作为一个独立的概念而存在的，它明确地被捕获并受源代码控制。</p><p> In these choreographed workflows, the workflow only exists as the sum of loosely connected functions. As we discussed above with the food delivery example, this makes them very difficult to reason about and debug. And there’s no easy way to implement even simple things like workflow level timeouts, or even task level tasks for that matter (e.g. timeout the order if the restaurant doesn’t accept or reject the order within 10 minutes).</p><p>在这些精心设计的工作流中，工作流仅作为松散连接的功能的总和而存在。正如我们在上面的外卖示例中所讨论的，这使得它们很难推理和调试。即使是工作流程级别的超时，甚至是任务级别的任务，也没有简单的方法来实现(例如，如果餐厅在10分钟内没有接受或拒绝订单，就会超时)。</p><p> If this is what you have today, you should consider moving these workflows to Step Functions instead.</p><p>如果这就是您现在所拥有的，那么您应该考虑将这些工作流转移到STEP函数。</p><p> But, between bounded contexts, I’ll publish and subscribe to events through SNS/EventBridge/Kinesis, etc. This is so that different parts of the larger system can stay loosely coupled and only build on each other’s events and can evolve and fail independently.</p><p>但是，在受约束的上下文之间，我将通过SNS/EventBridge/Kinesis等发布和订阅事件。这是为了使更大系统的不同部分可以保持松散耦合，并且只在彼此的事件基础上构建，并且可以独立地发展和失败。</p><p>  Orchestration and choreography don’t have to be mutually exclusive. Whenever I’m introducing state changes inside a state machine (such as changing the status of an order from  pending to  processed), I’ll publish those state changes as events. Other services can listen and react to these state changes, and bringing choreography into the picture.</p><p>编排和编排不一定是相互排斥的。每当我在状态机中引入状态更改(例如将订单的状态从待定更改为已处理)时，我都会将这些状态更改作为事件发布。其他服务可以监听和响应这些状态更改，并将编排带入画面中。</p><p> Let me leave you with my rule-of-thumb when it comes to implementing business workflows:  use orchestration within the bounded context of a microservice, but use choreography between bounded-contexts.</p><p>当涉及到实现业务工作流时，让我给您留下我的经验法则：在微服务的有界上下文中使用编排，但在有界上下文之间使用编排。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://theburningmonk.com/2020/08/choreography-vs-orchestration-in-the-land-of-serverless/">https://theburningmonk.com/2020/08/choreography-vs-orchestration-in-the-land-of-serverless/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/land/">#land</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/订单/">#订单</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035270.html"><img src="http://img2.diglog.com/img/2020/11/thumb_6f5c84856fa29d5f5170a177cc0f6115.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035270.html">将我的无服务器项目转移到Ruby on Rails</a></div><span class="my_story_list_date">2020-11-15 20:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034716.html"><img src="http://img2.diglog.com/img/2020/11/thumb_79e2dde7ebaf4c5659a7e70bd4e424ca.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034716.html">构建Homelab虚拟机服务器</a></div><span class="my_story_list_date">2020-11-12 12:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034061.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ba9a5ffbec05326b99ff326f7a5c40a0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034061.html">四个强大的HTTP标头，您以前不知道</a></div><span class="my_story_list_date">2020-11-10 0:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032963.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1b8d43f0863065c4f954f4168059ebc7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032963.html">CTO可怕的停电故事</a></div><span class="my_story_list_date">2020-11-3 22:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>