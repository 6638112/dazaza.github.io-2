<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们的工程团队使用Python的AST修补10,000多行代码 Our Engineering Team Used Python's AST to Patch 100,000s of Lines of Code</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Our Engineering Team Used Python's AST to Patch 100,000s of Lines of Code<br/>我们的工程团队使用Python的AST修补10,000多行代码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-07 14:21:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/2e19a623144d50d3ed659656645402c1.jpg"><img src="http://img2.diglog.com/img/2021/6/2e19a623144d50d3ed659656645402c1.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>import ast# Simple code that sets a variable var to 1 and then prints it.code = &#34;&#34;&#34;var = 1print(var)&#34;&#34;&#34;# Converts code to AST. Object &#39;head&#39; points to the head of the AST.head = ast.parse(code)print(head)</p><p>导入AST＃简单代码，将变量var设置为1，然后打印它。码=＆＃34;＆＃34;＆＃34; var = 1print（var）＆＃34;＆＃34;＆＃34;＃将代码转换为AST。对象＆＃39;头＆＃39;指向AST.head = AST.Parse（代码）打印（头）</p><p>                          Module( body=[ Assign( targets=[Name(id=&#39;var&#39;, ctx=Store())], value=Num(n=1) ), Expr( value=Call(func=Name(id=&#39;print&#39;, ctx=Load()), args=[Name(id=&#39;var&#39;, ctx=Load())], keywords=[]) ) ])</p><p>                          模块（body = [分配（targets = [name（id =＆＃39; var＆＃39; ctx = store（）]，expr（value = call（func = name （id =＆＃39; print＆＃39;，ctx = load（）），args = [name（id =＆＃39; var＆＃39; ctx = load（））]，关键词= []））] ）</p><p>                                Module( body=[ Assign( targets=[Name(id=&#39;var&#39;, ctx=Store())], value=Num(n=2) ), Expr( value=Call(func=Name(id=&#39;print&#39;, ctx=Load()), args=[Name(id=&#39;var&#39;, ctx=Load())], keywords=[]) ) ])</p><p>                                模块（Body = [Assign（targets = [name（id =＆＃39; var＆＃39; ctx = store（）），expr（value = call（func = name （id =＆＃39; print＆＃39;，ctx = load（）），args = [name（id =＆＃39; var＆＃39; ctx = load（））]，关键词= []））] ）</p><p>                                                            import pandas as pd mi = pd.MultiIndex.from_product([[1, 2], [&#39;a&#39;, &#39;b&#39;]], names=[&#39;x&#39;, &#39;y&#39;]) print(mi.levels[0].name) mi = mi.set_names(&#34;new name&#34;, level=0) print(mi.levels[0].name)</p><p>                                                            ImportPandasaspd MI = PD.MultiIndex.from_Product（[[1,2]，[＆＃39; A＆＃39;，＆＃39; B＆＃39;]，名称= [＆＃39; x＆＃39 ;，＆＃39; y＆＃39;]）打印（mi.levels [0] .name）mi = mi.set_names（＆＃34; newname＆＃34;，level = 0）print（mi.levels [0 ]。名称）</p><p>              import astdef is_multi_index_rename_node(node): &#34;&#34;&#34; Checks if the given node represents the code: &lt;var&gt;.levels[&lt;idx&gt;].name = &lt;val&gt; and returns the corresponding var, idx and val if it does. &#34;&#34;&#34; try: if ( isinstance(node, ast.Assign) and node.targets[0].attr == &#34;name&#34; and node.targets[0].value.value.attr == &#34;levels&#34; ): var = node.targets[0].value.value.value.id idx = node.targets[0].value.slice.value.n val = node.value return True, var, idx, val except: pass return False, None, None, Nonedef get_new_multi_index_rename_node(var, idx, val): &#34;&#34;&#34; Returns AST node that represents the code: &lt;var&gt; = &lt;var&gt;.set_names(&lt;val&gt;, level=&lt;idx&gt;) for the given var, idx and val. &#34;&#34;&#34; return ast.Assign( targets=[ast.Name(id=var)], value=ast.Call( func=ast.Attribute(value=ast.Name(id=var), attr=&#34;set_names&#34;), args=[val], keywords=[ast.keyword(arg=&#34;level&#34;, value=ast.Num(n=idx))], ), )def patch(node): &#34;&#34;&#34; Takes an AST rooted at the give node and patches it. &#34;&#34;&#34; # If it is a leaf node, then no patching needed. if not hasattr(node, &#34;_fields&#34;): return node # For every child of the node, modify it if needed and recursively call patch on it. for (name, field) in ast.iter_fields(node): if isinstance(field, list): for i in range(len(field)): check, var, idx, val = is_multi_index_rename_node(field[i]) if check: field[i] = get_new_multi_index_rename_node(var, idx, val) else: patch(field[i]) else: check, var, idx, val = is_multi_index_rename_node(field) if check: setattr(node, name, get_new_multi_index_rename_node(var, idx, val)) else: patch(field)</p><p>              导入astdef is_multi_index_rename_node（节点）：＆＃34;＆＃34;＆＃34;检查给定节点是否表示代码：＆lt; var＆gt; .Levels [id.]。名称=＆lt; val＆gt;并返回相应的var，iDx和val如果它。 ＆＃34;＆＃34;＆＃34;尝试：如果（isinstance（node，ast.assign）和node.targets [0] .attr ==＆＃34;名称＆＃34;和node.targets [0] .value.value.attr ==＆＃34;级别＆＃34;）：var = node.targets [0] .value.value.value.id idx = node.targetss [0] .value.slice.value.n val = node.value返回true，var，idx， val除：传递返回false，无，无，nonef get_new_multi_index_rename_node（var，idx，val）：＆＃34;＆＃34;＆＃34;返回代表代码的AST节点：＆lt; var＆gt; =＆lt; var＆gt; .set_names（＆lt; val＆gt;，level =＆lt; id.）给给定的var，Idx和val。 ＆＃34;＆＃34;＆＃34; return ast.assign（targets = [ast.name（id = var）]，value = ast.call（func = Ast.Attribute（value = Ast.name（id = var），attr =＆＃34; set_names＆＃34 ;），args = [val]，关键字= [ast.keyword（arg =＆＃34; level＆＃34; value = ast.num（n = idx））]，），）def补丁（节点）：＆ ＃34;＆＃34;＆＃34;扎根于给出节点并修补它。 ＆＃34;＆＃34;＆＃34; ＃如果它是叶节点，则无需修补。如果不是hasattr（节点，＆＃34; _fields＆＃34;）：返回节点＃的节点＃，如果需要，修改它，并递归地调用它。 for（名称，字段）在AST.ITER_FIELDS（节点）中：如果ISINstance（字段，列表）：对于I在范围内（LEN（字段））：检查，var，idx，val = is_multi_index_rename_node（字段[i]）如果检查：字段[i] = get_new_multi_index_rename_node（var，idx，val）else：patch（字段[i]）else：check，var，idx，val = is_multi_index_rename_node（字段）如果检查：setattr（节点，名称，get_new_multi_index_rename_node（var， IDX，VAL））其他：补丁（字段）</p><p>      from intelli_patch import patchimport astimport astunparsecode = &#34;&#34;&#34;import pandas as pdmi = pd.MultiIndex.from_product([[1, 2], [&#39;a&#39;, &#39;b&#39;]], names=[&#39;x&#39;, &#39;y&#39;])mi.levels[0].name = &#34;new name&#34;&#34;&#34;&#34;head = ast.parse(code)patch(head)print(astunparse.unparse(head))</p><p>      来自Intelli_Patch导入PatchImport Astimport Astunparsecode =＆＃34;＆＃34;＆＃34;导入熊猫作为pdmi = pd.multiindex.from_product（[[1,2]，[＆＃39; a＆＃39; a＆＃39; a＆＃39;＆＃39 ; B＆＃39;]]，名称= [＆＃39; x＆＃39 ;,＆＃39; y＆＃39;]）mi.levels [0] .name =＆＃34;新名称＆＃34;＆＃ 34;＆＃34;＆＃34; head = ast.parse（代码）patch（head）print（astunparse.unparse（head））</p><p>      import pandas as pdmi = pd.MultiIndex.from_product([[1, 2], [&#39;a&#39;, &#39;b&#39;]], names=[&#39;x&#39;, &#39;y&#39;])mi = mi.set_names(&#39;new name&#39;, level=0)</p><p>      导入pandas作为pdmi = pd.multiindex.from_product（[[1,2]，[＆＃39; a＆＃39;，＆＃39; b＆＃39;]]，名称= [＆＃39; x＆＃39; ，＆＃39; y＆＃39;]）mi = mi.set_names（＆＃39;新名称＆＃39; level = 0） </p><p>      from intelli_patch import patchimport astimport astunparsecode = &#34;&#34;&#34;import pandas as pdclass C(): def f(): def g(): mi.levels[ 0 ].name = &#34;new name&#34;mi = pd.MultiIndex.from_product([[1, 2], [&#39;a&#39;, &#39;b&#39;]], names=[&#39;x&#39;, &#39;y&#39;])&#34;&#34;&#34;head = ast.parse(code)patch(head)print(astunparse.unparse(head))</p><p>来自Intelli_Patch Import PatchImport Astimport Astunparsecode =＆＃34;＆＃34;＆＃34;导入熊猫作为pdclass c（）：def f（）：def g（）：mi.levels [0]。name =＆＃34;新名称＆＃34; mi = pd.multiindex.from_product（[[1,2]，[＆＃39; a＆＃39 ;,＃39; b＆＃39;]]，名称= [＆＃39; x＆＃ 39;，＆＃39; y＆＃39;]）＆＃34;＆＃34;＆＃34; head = ast.parse（代码）patch（head）print（astunparse.unparse（head））</p><p>      import pandas as pdclass C(): def f(): def g(): mi = mi.set_names(&#39;new name&#39;, level=0)mi = pd.MultiIndex.from_product([[1, 2], [&#39;a&#39;, &#39;b&#39;]], names=[&#39;x&#39;, &#39;y&#39;])</p><p>      导入pandas作为pdclass c（）：def f（）：def g（）：mi = mi.set_names（＆＃39;新名称＆＃39; level = 0）mi = pd.multiindex.from_product（[[1， 2]，[＆＃39; A＆＃39 ;,＆＃39; B＆＃39;]]，名称= [＆＃39; x＆＃39 ;,＆＃39; y＆＃39;]）</p><p>                                                  import astdef check(node): &#34;&#34;&#34; Takes an AST rooted at the given node and checks if there are single character variable names. &#34;&#34;&#34; # If it is a leaf node, then return. if not hasattr(node, &#34;_fields&#34;): return # For every child of the node, check if it is a variable having single character # name and recursively call check on it. for child_node in ast.iter_child_nodes(node): if isinstance(child_node, ast.Name) and len(child_node.id) == 1: print( f&#34;Single character name &#39;{child_node.id}&#39; used at line number {child_node.lineno}&#34; ) check(child_node)</p><p>                                                  进口ASTDEF检查（节点）：＆＃34;＆＃34;＆＃34;在给定节点上扎根AST并检查是否有单个字符变量名称。 ＆＃34;＆＃34;＆＃34; ＃如果它是叶节点，则返回。如果不是hasattr（节点，＆＃34; _fields＆＃34;）：返回每个节点的每个孩子的＃，检查它是否是具有单个字符＃名称和递归调用它的变量。在AST.ITS_CHILD_NODE（节点）中for child_node：如果是isinstance（child_node，ast.name）和len（child_node.id）== 1：打印（f＆＃34;单个字符名称＆＃39; {child_node.id}＆＃ 39;在行号{child_node.lineno}＆＃34;）检查（child_node）</p><p>            Single character name &#39;a&#39; used at line number 2Single character name &#39;b&#39; used at line number 3Single character name &#39;a&#39; used at line number 3Single character name &#39;b&#39; used at line number 4</p><p>            单个字符名称＆＃39; a＆＃39;在线号码2single字符名称＆＃39; b＆＃39;在线号码3single字符名称＆＃39; a＆＃39;在线号码3single字符名称＆＃39; b＆＃39;在第4行使用</p><p>              import astdef check(node): &#34;&#34;&#34; Takes an AST rooted at the given node and checks if there are un-logged except code blocks. &#34;&#34;&#34; # If it is a leaf node, then return. if not hasattr(node, &#34;_fields&#34;): return # For every child of the node, check if it is un-logged except code block # and recursively call check on it. for child_node in ast.iter_child_nodes(node): if isinstance(child_node, ast.ExceptHandler) and not is_logging_present( child_node ): print( f&#34;Neither &#39;error&#39; nor &#39;exception&#39; logging is present within the except block starting at line number {child_node.lineno}&#34; ) check(child_node)def is_logging_present(node): &#34;&#34;&#34; Takes an AST rooted at the given node and checks whether there is an &#39;error&#39; or &#39;exception&#39; logging present in it. &#34;&#34;&#34; # If it is a leaf node, then return False. if not hasattr(node, &#34;_fields&#34;): return False # If it represents an `error` or `exception`function call then return True. if ( isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute) and node.func.attr in [&#34;error&#34;, &#34;exception&#34;] ): return True # Recursively checking if logging is present in the children nodes. for child_node in ast.iter_child_nodes(node): if is_logging_present(child_node): return True return False</p><p>              进口ASTDEF检查（节点）：＆＃34;＆＃34;＆＃34;在给定节点上扎根AST，并检查除代码块外是否有未记录。 ＆＃34;＆＃34;＆＃34; ＃如果它是叶节点，则返回。如果不是hasattr（节点，＆＃34; _fields＆＃34;）：返回＃每个节点的每个孩子，检查除非代码块＃和递归调用检查是否未记录。对于AST.ITER_CHILD_NODE（节点）中的child_node（node）：如果是isinstance（child_node，ast.excepthandler）而不是is_logging_present（child_node）：打印（f＆＃34;既不是＆＃39;错误＆＃39; or＆＃39;日志记录在除了行号{child_node.lineno}＆＃34;）check（child_node）def is_logging_present（node）：＆＃34;＆＃34;＆＃34;扎根于给定节点的AST并检查是否有＆＃39;错误＆＃39;或＃39;例外＆＃39;伐木存在于它中。 ＆＃34;＆＃34;＆＃34; ＃如果它是叶节点，则返回false。如果不是hasattr（节点，＆＃34; _fields＆＃34;）：返回false＃如果它代表一个`错误an或`sexection`function调用，则返回true。 if（isinstance（node，ast.call）和isinstance（node.func，ast.attribute）和[＆＃34;错误＆＃34;＆＃34;例外＆＃34;]）：返回True＃递归检查是否在儿童节点中存在日志记录。对于AST.ITS_CHILD_NODES（节点）的CHILD_NODE：如果是ins_logging_present（child_node）：返回true返回false</p><p>      from unlogged_except_check import checkimport astcode=&#34;&#34;&#34;try: passexcept ValueError: logging.error(&#34;Error occurred&#34;) try: pass except KeyError: logging.exception(&#34;Exception handled&#34;) except NameError: passtry: passexcept: logging.info(&#34;Info level logging&#34;)&#34;&#34;&#34;head = ast.parse(code)check(head)</p><p>      来自Unlogging_except_check导入checkimport Astcode =＆＃34;＆＃34;尝试：passexcept值：logging.Error（＆＃34;发生错误＆＃34;）尝试：pass除了keyerror之外：logging.exception（＆＃34 ;除名称交易：passstry：passexcept：logging.info（＆＃34;信息级日志记录＆＃34;＆＃34;＆＃34; head = Ast.parse（代码）检查（头）</p><p>      Neither &#39;error&#39; nor &#39;exception&#39; logging is present within the except block starting at line number 14Neither &#39;error&#39; nor &#39;exception&#39; logging is present within the except block starting at line number 19</p><p>      既不是＆＃39;错误＆＃39; ＆＃39;例外＆＃39;在除块之外存在日志记录在线数字14neying 14neay＆＃39;错误＆＃39; ＆＃39;例外＆＃39;日志记录存在于除行号19的块之外 </p><p>                                                      Soroco is committed to helping our clients be their best. Our technology enables leaders in the modern enterprise to discover hidden barriers that hold back their teams and customers, and deliver programs that achieve lasting impact, not temporary benefits. Founded in Boston, Soroco’s technology is commercially proven, built to scale, and deployed at global F500 leaders across the globe. Our discovery platform, Scout, unites business and IT stakeholders on a step-by-step journey of transformation. This connected journey helps accelerate our clients’ ambitious cost savings, customer experience, and employee engagement objectives.</p><p>Soroco致力于帮助我们的客户成为最佳状态。 我们的技术使现代企业的领导能够发现隐藏的障碍，遏制其团队和客户，并提供实现持久影响的计划，而不是暂时的福利。 Soroco的技术成立于波士顿，Soroco的技术是商业验证的，以规模构建，并在全球全球F500领导人部署。 我们的发现平台，侦察兵，单位的业务和IT利益相关者在逐步的转型之旅。 这一连接的旅程有助于加快客户的雄心勃勃的成本节约，客户体验和员工参与目标。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://engineering.soroco.com/abstract-syntax-tree-for-patching-code-and-assessing-code-quality/">https://engineering.soroco.com/abstract-syntax-tree-for-patching-code-and-assessing-code-quality/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/团队/">#团队</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/team/">#team</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>