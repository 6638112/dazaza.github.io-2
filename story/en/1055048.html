<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>开发人员工具可以是魔法，而是收集灰尘 Developer tools can be magic but instead collect dust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Developer tools can be magic but instead collect dust<br/>开发人员工具可以是魔法，而是收集灰尘 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 00:23:46</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/88dc8fa8a73ba81d77b3a536dc256060.png"><img src="http://img2.diglog.com/img/2021/3/88dc8fa8a73ba81d77b3a536dc256060.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I started working on advanced developer tools 9 years ago. Back when I started, “programming tools” meant file format viewers, editors, and maybe variants of  grep. I’d mention a deep problem such as inferring the underlying intent of a group of changes, and get questions about how it compares to find-and-replace.</p><p>我在9年前开始研究高级开发人员工具。当我开始时，“编程工具”意味着文件格式查看器，编辑器，以及Grep的变种。我提到了一个深刻的问题，例如推断一组变化的潜在意图，并了解它如何比较以找到和替换。</p><p> Times have changed. It’s no longer shocking when I meet a programmer who has heard of program synthesis or even tried a verification tool. There are now several  1 popular products based on advanced tools research, and AI advances in general have changed expectations. One company, Facebook, has even  deployed automated program-repair internally.</p><p> 时代已经改变了。当我遇到已经听说过程序合成的程序员或甚至尝试验证工具时，它不再令人震惊。现在有几个基于高级工具研究的流行产品，并且AI一般都更改了期望。 Facebook一家公司甚至在内部部署了自动化程序维修。</p><p> In spite of this, tools research is still light-years ahead of what’s being deployed. It is not unusual at all to read a 20 year-old paper with a tool empirically shown to make programmers 4x faster at a task, and for the underlying idea to still be locked in academia.</p><p> 尽管如此，工具研究仍然在部署的内容之前仍然很轻而出广播。读取一个20岁的纸张并不罕见，通过经验证明的工具可以在任务中更快地制作方案，以及仍然被锁定在学术界的潜在想法。</p><p> I’d like to give a taste of what to expect from advanced tools — and the ways in which we are sliding back. I will now present 3 of my favorite tools from the last 30 years, all of which I’ve tried to use, none of which currently run.</p><p> 我想品尝到高级工具的期望 - 以及我们推回的方式。我现在将在过去的30年中展示我最喜欢的3个工具，所有这些工具都尝试使用，其中没有一个目前运行。</p><p>  We often think of software in terms of components. For an operating system, it might be: file system, hardware interface, process manager. An experienced engineer on the project asked to make certain files write to disk faster will know exactly where to go in the code; a newcomer will see an amorphous blob of source files.</p><p>  我们经常在组件方面想到软件。对于操作系统，它可能是：文件系统，硬件接口，过程管理器。项目上的经验丰富的工程师要求将某些文件写入磁盘更快，将确切地知道在代码中的位置;新人将看到源文件的无定形斑点。</p><p> In 1995, as a young grad student at the University of Washington, Gail C. Murphy came up with a new way of learning a codebase called reflexion models.</p><p> 1995年，作为华盛顿大学的年轻毕业生，Gail C.墨菲以一种学习称为反射模型的码级的新方式。</p><p> First, you come up with a rough hypothesis of what you think the components are and how they interact:</p><p> 首先，您提出了对您认为组件的粗略假设以及它们如何互动： </p><p>  Then, you go through the code and write down how you think each file corresponds to the components.</p><p>然后，您通过代码并记下每个文件对应于组件的方式。</p><p>  Now, the tool runs, and computes the actual connectivity of the files (e.g.: class inheritance, call graph). You compare it to your hypothesis.</p><p>  现在，该工具运行，并计算文件的实际连接（例如：类继承，呼叫图）。你将它与你的假设进行比较。</p><p>  Armed with new evidence, you refine your hypothesis, and make your mental model more and more detailed, and better and better aligned with reality.</p><p>  武装新的证据，你会改善你的假设，使你的精神模型越来越详细，更好，更好地与现实保持。</p><p> Around this time, a group at Microsoft was doing an experiment to see if they could re-engineer the Excel codebase to extract out some high-level components. They needed a pretty strong understanding of the codebase, but getting it wouldn’t be so easy, because they were a different team in a different building. One of them saw Gail’s talk on reflexion models and liked it.</p><p> 在这段时间内，微软的一个团队正在做一个实验，看看他们是否可以重新设计Excel代码库来提取一些高级组件。他们需要一个非常强烈的对码比的理解，但取得它不会那么容易，因为他们是不同的建筑中的不同团队。其中一个人看到了Gail关于反射模型的谈话并喜欢它。</p><p> In one day, he created his first cut of a reflexion model for Excel. He then spent the next four weeks refining it as he got more acquainted with the code. Doing so, he reached a level of understanding that he estimates would have taken him 2 years otherwise.</p><p> 在一天，他创造了他的首次削减了Excel的反射模型。然后他在接下来的四周内善待它，因为他更熟悉代码。这样做，他达成了一定程度的理解，他估计会割下他2年。</p><p> Today, Gail’s original RMTool is off the Internet. The C++ analysis tool from AT&amp;T it’s based on, Ciao, is even more off the Internet. They later wrote a Java version, jRMTool, but it’s only for an old version of Eclipse with a completely different API. The code is written in Java 1.4, and is no longer even syntactically correct. I quickly gave up trying to get it to run.</p><p> 今天，Gail的原始RMTool正在互联网上。来自AT＆amp的C ++分析工具是基于，CIAO，甚至更加互联网。他们后来写了一个Java版本，但它只适用于旧版本的Eclipse，具有完全不同的API。代码是用Java 1.4编写的，并且不再是句法正确的。我很快就会起来试图让它运行。</p><p>    About 10 years later, at the Human-Computer Interaction Institute at Carnegie Mellon, Amy Ko was thinking about another problem. Debugging is like being a detective. Why didn’t the program update the cache after doing a fetch? What was a negative number doing here? Why is it so much work to answer these questions?</p><p>    大约10年后，在Carnegie Mellon的人机互动学院，Amy Ko正在考虑另一个问题。调试就像是一个侦探。为什么程序在做提取后没有更新缓存？在这里做的负数是多少？为什么它有很多工作要回答这些问题？ </p><p> Amy had an idea for a tool called the Whyline, where you could ask questions like “Why did  ___ happen?” in an interactive debugger? She built a prototype for Alice, CMU’s graphical programming tool that let kids make 3D animations. People were impressed.</p><p>艾米对一个称为越橘的工具有一个叫做越橘的工具，你可以在那里提出“___为什么发生的原因？”在互动调试器中？她为Alice建立了一个原型，CMU的图形编程工具，让孩子制作3D动画。人们印象深刻。</p><p>  Bolstered by their success, Amy, now a professor, spent another couple years working hard, building up the technology to do this for Java.</p><p>  他们的成功，艾米，现在是一位教授，花了另外几年，建立了这项技术为Java做到这一点。</p><p>    They ran a study. 20 programmers were asked to fix two bugs in ArgoUML, a 150k line Java program. Half of them were given a copy of the Java WhyLine. The programmers with the WhyLine were 4 times more successful than those without, and worked twice as fast.</p><p>    他们跑了一项研究。要求20个程序员在Argouml，一个150k行Java程序中修复两个错误。其中一半被给予了Java Whyline的副本。与村底的程序员比没有那些的人成功4倍，并迅速工作。</p><p> A couple years ago, I tried to use the Java Whyline. It crashed when faced with modern Java bytecode.</p><p> 几年前，我试图使用Java Whyline。当面对现代的Java字节码时，它会崩溃。</p><p>  In 2008, my advisor, Armando Solar-Lezama, was freshly arrived at MIT after single-handedly reviving the field of program synthesis. He had mostly focused on complex problems in small systems, like optimizing physics simulations and bit-twiddling. Now he wanted to solve simple problems in big systems. So much of programming is writing “glue code,” taking a large library of standard components and figuring out how to bolt them together. It can take weeks of digging through documentation to figure out how to do something in a complex framework. Could synthesis technology help? Kuat Yessenov, the Kazakh genius, was tasked with figuring out how.</p><p>  2008年，我的顾问Armando Solar-Lezama在一次手工恢复计划综合领域之后刚刚到达麻省理工学院。他主要专注于小型系统中的复杂问题，例如优化物理模拟和位拖延。现在他想解决大系统中的简单问题。这么多的编程正在写作“胶水代码”，拍摄一个大型的标准组件，并弄清楚如何将它们栓在一起。它可能需要数周的挖掘文档来弄清楚如何在复杂的框架中做某事。可以合成技术帮助吗？哈萨克天才kuat yessenov被任务弄清楚了。</p><p> Glue code is often a game of figuring out what classes and methods to use. Sometimes it’s not so hard to guess: the way you put a widget on the screen in Android, for instance, is with the container’s  addView method. Often it’s not so easy. When writing an Eclipse plugin that does syntax highlighting, you need a chain of four classes to connect the  TextEditor object with the  RuleBasedScanner.</p><p> 胶水代码通常是一个弄清楚使用什么类别和方法的游戏。有时猜测并不难：例如，在Android中放置窗口小部件的方式，例如，具有容器的addview方法。通常它不那么容易。在编写DACTAX突出显示的Eclipse插件时，您需要一个四个类链以将TextEditor对象与RuleBasedScanner连接。</p><p> class  UserConfiguration  extends  SourceViewerConfiguration  {  IPresentationReconciler  getPresentationReconciler ()  {  PresentationReconciler  reconciler  =  new  PresentationReconciler ();  RuleBasedScanner  userScanner  =  new  UserScanner ();  DefaultDamagerRepairer  dr  =  new  DefaultDamagerRepairer ( userScanner );  reconciler . setRepairer ( dr ,  DEFAULT_CONTENT_TYPE );  reconciler . setDamager ( dr ,  DEFAULT_CONTENT_TYPE );  return  reconciler ;  } } class  UserEditor  extends  AbstractTextEditor  {  UserEditor ()  {  userConfiguration  =  new  UserConfiguration ();  setSourceViewerConfiguration ( userConfiguration );  } } class  UserScanner  extends  RuleBasedScanner  {...}</p><p> class userconfiguration扩展sourceviewerconfiguration {ipresentationreconciler getpresentationreconciler（）{presentationreconciler condencer = new presentationreconciler（）; RuleBasedScanner UsersCanner = New UsersCanner（）; defaultdamagerrepairer dr = new defaultdamagerrepairer（userscanner）;和解。 setRepairer（destry_content_type dr）;和解。 setDamager（Dram，default_content_type）;回归和解; }}类UserEditor扩展AbstractTextEditor {UserEditor（）{userconfiguration = new userconfiguration（）; SetSourceViewerConfiguration（用户配置）; }} versientscanner扩展了RuleBasedScanner {...} </p><p> If you can figure out the two endpoints of a feature, what class uses it and what class provides it, he reasoned, then you could ask a computer to figure out what’s in-between. There are other programs out there that implement the functionality you’re looking for. By running them and analyzing the traces, you can find the code responsible for “connecting” those two classes (as a chain of pointer references). You then boil the reference program down to exactly the code that does this — voila, a tutorial! The MatchMaker tool was born.</p><p>如果您可以弄清楚功能的两个端点，那么使用它的类和哪个类提供，他推理，那么你可以要求一台电脑弄清楚之间的内容。还有其他程序在那里实现了您正在寻找的功能。通过运行它们并分析迹线，您可以找到负责“连接”这两个类（作为指针引用链）的代码。然后，您将参考程序置于齐全的代码 -  Voila，教程！ Matchmaker工具出生。</p><p>  In the study, 8 programmers were asked to build a simple syntax highlighter for Eclipse, highlighting two keywords in a new language. Half of them were given MatchMaker and a short tutorial on its use. Yes, there were multiple tutorials on how to do this, but they contained too much information and weren’t helpful. The control group floundered, and averaged 100 minutes. The MatchMaker users quickly got an idea what they were looking for, and took only 50 minutes. Not too bad, considering that an Eclipse expert with 5 years experience took a full 16 minutes.</p><p>  在该研究中，要求8个程序员才能为Eclipse构建一个简单的语法荧光笔，以新语言突出显示两个关键字。其中一半是给予MatchMaker的媒体和一条简短的教程。是的，有多个教程如何执行此操作，但它们包含太多信息并没有帮助。对照组挣扎，平均100分钟。 Matchmaker用户快速了解他们在寻找什么，只需50分钟。不太糟糕，考虑到有5年经验的日食专家完成了16分钟。</p><p> I did actually get to use Matchmaker, seeing as I was asked to work on its successor in my first month of grad school. Pretty nice; I’d love to see it fleshed out and made to work for Android. Alas, we’re sliding back. A few years back, my advisor hired a summer intern to work on MatchMaker. He instantly ran into a barrier: it didn’t work on Java 8.</p><p> 我实际上确实可以使用Matchmaker，看到我被要求在毕业生学校的第一个月工作。很不错;我很乐意看到它搞砸了，为Android工作了。唉，我们正在推回来。几年后，我的顾问聘请了一个夏天实习生在赛马制造商上工作。他瞬间跑进了一个障碍：它不适用于Java 8。</p><p>  The first lesson is that the tools we use are heavily shaped by the choices of eminent individuals. The reason that Reflexion Models are obscure while  Mylyn is among the most popular Eclipse plugins is quite literally because Gail C. Murphy, creator of Reflexion Models, decided to go into academia, while her student Mik Kersten, creator of Mylyn, went into industry.</p><p>  第一课是我们使用的工具被杰出人的选择严重。 Reflexion模型是模糊的原因，而Mylyn是最受欢迎的Eclipse插件，因为盖尔C.墨菲，反射模型的创造者，决定进入学术界，而她的学生Mik Kersten，Mylyn的创造者进入工业。</p><p> Programming tools are not a domain where advances are “an idea whose time has come.” That happens when there are many people working on similar ideas; if one person doesn’t get their idea adopted, then someone else will a few years later. In programming tools, this kind of competition is rare. To illustrate: A famous professor went on sabbatical to start a company building a tool for making websites. I asked him why, if his idea was going to beat all the previous such tools, it hadn’t been done before. His answer was something like “because it requires technology that only I can build.”</p><p> 编程工具不是域名的域名“时间已经到来的想法”。当有很多人致力于类似的想法时会发生这种情况;如果一个人没有得到他们的想法，那么别人会几年后。在编程工具中，这种竞争很少见。为了说明：着名教授继续休假，以启动建立一个制作网站工具的公司。我问他为什么，如果他的想法将击败以前的所有这样的工具，它就没有完成。他的答案是“因为它需要只能建造的技术。”</p><p> The second lesson is that there is something wrong with how we build programming tools. Other fields of computer science don’t seem to have such a giant rift between the accomplishments of researchers and practitioners. I’ve  argued before that this is because the difficulty of building tools depends more on the complexity of programming languages (which are extremely complicated; just see C++) than on the idea, and that, until this changes, no tool can arise without enough sales to pay the large fixed cost of building it. This is why my Ph. D. has been devoted to making tools easier to build. It is also why I am in part disheartened by the proliferation of free but not-so-advanced tools: it lobs off the bottom of the market and makes these fixed-costs harder to pay off.</p><p> 第二课是，我们如何构建编程工具有问题。计算机科学的其他领域似乎没有在研究人员和从业者的成就之间具有如此巨大的裂痕。我曾在此之前争论是因为建筑工具的难度更多地取决于编程语言的复杂性（这是非常复杂的;只是看到C ++）而不是在这个想法上，直到这种变化，没有足够的工具销售额支付大规模建筑物的固定成本。这就是我的pH值。D. D.致力于使工具更容易构建。这也是为什么我部分地通过免费但不足的工具的扩散令人沮丧：它会在市场的底部徘徊，使这些固定成本更加困难。</p><p> But the third lesson is that we as developers can demand so much more from our tools. If you’ve ever thought about building a developer tool, you have so much impressive work to draw from. And if you’re craving better tools, this is what you have to look forward to.</p><p> 但第三课是，我们作为开发人员可以从我们的工具中需求得多。如果您曾经考虑过构建开发人员工具，那么您有很多令人印象深刻的努力才能绘制。如果您渴望更好的工具，这就是您所期待的。 </p><p>     1 I’d list some, but I don’t want to play favorites. I’ll just mention  CodeQL, which is quite advanced and needs no touting.</p><p>1我列出了一些，但我不想玩最爱。 我只是提到码分，这是非常高级的，不需要吹捧。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.pathsensitive.com/2021/03/developer-tools-can-be-magic-instead.html">http://www.pathsensitive.com/2021/03/developer-tools-can-be-magic-instead.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tools/">#tools</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>