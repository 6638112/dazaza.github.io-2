<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CVE-2020-14381的奇怪案例 The curious case of CVE-2020-14381</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The curious case of CVE-2020-14381<br/>CVE-2020-14381的奇怪案例 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-01 17:24:47</div><div class="page_narrow text-break page_content"><p>Today is the one-year anniversary of this interesting kernel bug I workedon last year with  @bluec0re,and as it turns out I wrote something about it during one of these lockdownweekends so I thought I&#39;d release it.  The bug itselfwas discovered by  Jann Hornof Project Zero. While I touch most of the elements required to exploit thebug, I stay superficial here since the exploit itself is not particularlyexciting. What makes this bug interesting to me is its lifecycle, in particularhow unevenly the patch was applied to the various distributions. I also talkbriefly about hardware side-channels since it was the first time I had everused one.</p><p>今天是我去年与@ bluec0re一起工作的这个有趣的内核错误的一周年纪念日，事实证明，我在其中一个锁定周末期间写了一些有关它的内容，所以我认为我会发布它。该漏洞本身是由零号项目的简·霍恩（Jann Hornof）发现的。当我接触到利用该bug所需的大多数元素时，我在这里停留在肤浅的位置，因为利用漏洞本身并没有特别令人兴奋。使我对该bug感兴趣的是它的生命周期，尤其是该补丁如何不均匀地应用于各种发行版。我还简短地谈论了硬件辅助通道，因为这是我第一次使用硬件辅助通道。</p><p> The bug It’s already well-described in the bug tracker, but here is another summary.The  futex syscall&#39;s main parameter is a userland address, and this addressmay belong to a file-backed mapping. In that case, the futex key kernel object heldand  kepta reference to the inode object, but didn’t hold a reference to the file’s mountpoint.If the mountpoint were to go away, its associated kernel structures would befreed, but the inode wouldn’t. That’s an issue because the inode itself hasfields that point to some of these structures, such as its  super_blockstruct.</p><p> 该错误已经在错误跟踪器中进行了详细描述，但这是另一个摘要。futex syscall的主要参数是用户名地址，该地址可能属于文件支持的映射。在这种情况下，futex键内核对象保留并保留对inode对象的引用，但不保留对文件的挂载点的引用。如果挂载点消失，则将释放其关联的内核结构，但是inode不会。这是一个问题，因为inode本身具有指向其中某些结构的字段，例如其super_blockstruct。</p><p> Further use of the inode by  futex code paths may therefore triggeruse-after-frees. One particular code path highlighted by Jann in the bug happenswhen the  futex is destroyed: the last reference to the inode is releasedand the inode needs to be freed. This is done in  iput which then calls iput_final.  iput_final and its subcalls will then call inodemanagement functions stored in the  super_operationsstruct accessed  from the super_blockobject. The first instance happens right at the beginning of  iput_final witha call to the  drop_inodefunction.</p><p> 因此，futex代码路径对索引节点的进一步使用可能会触发释放后使用。 Jann在错误中强调的一个特定代码路径发生在销毁futex时：释放了对索引节点的最后一个引用，并且需要释放索引节点。这是在iput中完成的，然后将其称为iput_final。然后，iput_final及其子调用将调用存储在从super_block对象访问的super_operationsstruct中的inodemanagement函数。第一个实例发生在iput_final的开头，并调用drop_inode函数。</p><p> Exploiting this bug requires being able to: Successfully  umount a mountpoint. A no-go a few years ago, but possible nowadays with the normalization of unprivileged user namespaces. It’s a good example that this feature was never a trivial security tradeoff (unprivileged sandboxes v. augmented kernel attack surface) which in turn makes it somewhat surprising that all mainstream distributions enabled them by default without much debate</p><p> 利用此错误需要能够：成功卸载挂载点。几年前还没做，但如今可以通过非特权用户名称空间的标准化来实现。这是一个很好的例子，该功能绝不是微不足道的安全性折衷（无特权的沙箱诉增强的内核攻击面），这反过来使所有主流发行版默认启用它们而没有太多争议，这有点让人感到惊讶。</p><p>      Do everything in one call, because with an incorrect inode state, a corrupted super_block and some linked lists unlinks to do in the remainder of  iput_final, it’s doubtful we can even get as far as the second  super_operations function pointer call ( evict_inode)</p><p>      只需一次调用即可完成所有操作，因为在iput_final的其余部分中，由于inode状态不正确，super_block损坏以及某些链接列表未链接，我们甚至还无法达到第二个super_operations函数指针调用（evict_inode）</p><p> Exploitation The first exploitation pathway that comes to mind goes as follows: wait for the  super_block to be freed. It’s done in  an RCU callback so one way or another you need to wait for the end of the RCU grace period after  umount returns, e.g. with  membarrier. For a PoC, spraying allocs for the duration of the expedited grace period works well enough since the  super_block slab,  kmalloc-2k, is not super busy.</p><p> 开发想到的第一个开发途径如下：等待super_block被释放。此操作是在RCU回调中完成的，因此您需要在umount返回后等待RCU宽限期的结束，例如与膜拜。对于PoC，由于super_block平板kmalloc-2k并非超级忙，因此在加速宽限期的持续时间内喷洒分配效果很好。</p><p>      point  drop_inode to a chain of gadgets that pivot the stack to either the  super_block or  super_operations bufffers (which are both necessarily in registers and almost fully controlled). Example of common gadgets that would work in this situation would be  push reg; jmp/call [reg+x] that can then be chained with a  pop rsp; ret gadget placed at  [reg+x]</p><p>      将drop_inode指向一系列小工具，这些小工具将堆栈旋转到super_block或super_operations bufffer（必须在寄存器中并且几乎完全受控）。在这种情况下可以使用的常见小工具的示例是push reg； jmp / call [reg + x]，然后可以与pop rsp链接； ret小工具放在[reg + x] </p><p> This would be a sucky exploit to maintain as it relies on precise knowledgeof the kernel image, but that’s as good as it gets for a raw function pointerexecution without a read primitive in kernel space. The portability issuesfor exploits like this are in themselves a significant bonus of SMEP: it rarelyprevents exploitation but makes many candidates much less appealing for weaponization.</p><p>它依赖于对内核映像的精确了解，因此很难维护，但这与在内核空间中没有读取原语的情况下执行原始函数指针执行一样好。此类漏洞利用的可移植性本身就是SMEP的一大收获：它很少阻止漏洞利用，但使许多候选人对武器化的吸引力大大降低。</p><p> We can take SMEP for granted. It’s only one CPU generation / 2 years olderthan SMAP, but not having it is getting really rare. Plus if your exploit doesrely on no-SMEP but your target ends up having software SMEP enabled, whichyou can&#39;t really tell at runtime, you&#39;ve just turned a privesc attempt intoa lost foothold. No-SMAP however is still a thing for the time being. As arandom example the  AWS EC2 CPU rostershows some CPUs that do not support SMAP.</p><p> 我们可以认为SMEP是理所当然的。它只有一个CPU世代，比SMAP早2年，但是没有它的情况却越来越少。另外，如果您的漏洞利用确实依赖于no-SMEP，但您的目标最终启用了SMEP软件，而您在运行时无法真正看出这一点，则您只是将privesc尝试变成了立足之地。但是，暂时没有SMAP仍然是问题。作为一个随机示例，AWS EC2 CPU名册显示一些不支持SMAP的CPU。</p><p> On infoleak bugs In any case, to exploit this bug one needs at least one infoleak. The mostimportant is to get kernel base for gadgets, and then we could use a heap leakor similar to support SMAP-capable CPUs (to have our &#34;attacker-controlledbuffer&#34; in point 3 above in kernel space). A heap/stack leak can often yielda .text address as well so having one would kill two birds with one stone.But, not everyone has the right infoleak in their stash ready to go, contraryto a common anti-KASLR argument. And even when you do have an infoleak bug,it doesn&#39;t mean that it will help with your current exploit.</p><p> 关于信息泄漏漏洞无论如何，要利用此漏洞，至少需要一个信息泄漏。最重要的是获取小工具的内核基础，然后我们可以使用类似堆泄漏器的功能来支持具有SMAP的CPU（在内核空间中的上述第3点中提供“攻击者控制的缓冲区”）。堆/堆栈泄漏通常也可以产生一个.text地址，因此拥有一个将用一块石头杀死两只鸟。但是，并不是每个人都准备好了正确的信息泄漏，这与常见的反KASLR论证相反。即使您确实有一个信息泄漏错误，也并不意味着它将对您当前的利用有所帮助。</p><p> For instance, a good infoleak candidate which was released around the sametime last year would be the one with uninitialized memory in coredumps,  CVE-2020-10732.But short of a public proof-of-concept, one needs to understand the coredumpgeneration code, then find an object in that slab that allows us to get.text, and another one to deduce a heap address you control. In short, at leastas much work as the rest of the exploit we are looking at. And that&#39;s withoutconsidering that using two bugs in one exploit also means that you need totake into account both bugs limitations. Unprivileged user namespaces for themain bug we are looking at (not a thing on e.g. RHEL 7), and for the coredump,well the ability to retrieve the core files, i.e. not running in a container.Luckily for our project, we already knew we were targeting non-SMAP containersso we were able to avoid spending all that effort on an infoleak bug thatwould have ended up being worthless; a luxury that real exploit developperspreparing capabilities ahead of time do not have. But if we were targetingSMAP containers, well that would have been it since more effort would haveexceeded our resource budget for this project.</p><p> 例如，去年同期发布的一个很好的信息泄漏候选对象将是在核心转储中具有未初始化内存的CVE-2020-10732。但是，由于缺乏公共概念验证，因此需要了解核心转储生成代码，然后在该平板中找到一个允许我们获取.text的对象，并找到另一个对象来推断您控制的堆地址。简而言之，至少与我们正在研究的其他漏洞一样多。而且这并不意味着在一个漏洞利用中使用两个错误也意味着您需要考虑两个错误的局限性。我们正在寻找的主要错误（例如RHEL 7上没有的东西）和coredump的特权用户名称空间以及检索核心文件的能力，即不在容器中运行。幸运的是，对于我们的项目，我们已经知道我们我们以非SMAP容器为目标，因此我们能够避免将所有精力都花在一个信息泄漏漏洞上，而该漏洞最终将毫无价值。真正的漏洞利用开发人员无法提前准备功能的奢侈品。但是，如果我们以SMAP容器为目标，那将是这样，因为为此项目付出的更多努力将超出我们的资源预算。</p><p> Hardware side-channels For kernel .text however, the situation is different since there are generic,publicly-documented ways to obtain kernel base: hardware vulns. I personallyhadn’t ever used any and even saw them as a niche exploitation techniquerelying on opaque CPU heuristics that don’t hold across models - not somethingto be considered for resilient exploits. I was simply wrong, but thankfullyhad access to many specialists ( @tehjh, @_fel1x,  @_tsuro)who knew better.</p><p> 硬件辅助通道但是，对于内核.text，情况有所不同，因为存在获取内核基础的通用的，公开记录的方法：硬件漏洞。我个人从未使用过，甚至将其视为利基开发技术，它依赖于不跨模型的不透明CPU启发式算法-弹性漏洞利用不宜考虑。我只是错了，但值得庆幸的是，我可以接触到许多了解更多的专家（@tehjh，@ _ fel1x，@ _ tsuro）。</p><p> While side-channels that allow leaking memory across security boundariesare hopefully bound to be mitigated, there are many side-channels that leakaddresses and which we haven’t heard much about since Spectre and friends.These ones are probably here to stay even longer. For this project I used  Jump Over ASLR,which was published before Spectre in 2016. It’s simple to understand (especiallywith access to the aforementioned people) and there are PoCs that are justwaiting to be adjusted to your own scenario (e.g.  mario_baslrfrom @_fel1x). Jump Over ASLR relies on the inner workings of the Branch TargetBuffer where user and kernel branches may collide. When that happens, the CPUhas more work to do and that can be observed. This allows leaking kernel base as long as you have offsets of branches hit during a short kernel path youcan trigger at will: you can then leverage the low entropy of KASLR to tryall possible base addresses and find the one where the branches are hit.</p><p> 虽然希望可以缓解允许跨安全边界泄漏内存的辅助通道，但有许多泄漏地址的辅助通道，自Spectre和朋友以来我们就没有听说过。这些辅助通道可能会保留更长的时间。在此项目中，我使用了Jump Over ASLR，该版本在Spectre于2016年之前发布。它易于理解（尤其是与上述人员的联系），并且有一些PoC正在等待根据您自己的情况进行调整（例如mario_baslrfrom @ _fel1x）。跳过ASLR依赖于分支TargetBuffer的内部工作原理，用户和内核分支可能会发生冲突。发生这种情况时，CPU有更多工作要做，可以观察到。只要您在任意触发的短内核路径中命中分支的偏移量，就可以泄漏内核基数：然后，您可以利用KASLR的低熵来尝试所有可能的基地址，并找到命中分支的基地址。</p><p> For the parameters (the branches to measure) you can really use whateveryou want. I only tried the  creat syscall with arguments that cause afast return to userland, and then measured whether the  sys_creat and do_sys_open offsets had been hit. The offsets need to be fairly precisebut not to the byte since there seems to be some aliasing going on in the branchpredictor: I originally used  __fentry__ as an additional branch targetat a +5 offset for both symbols which still worked even though I later learnedthese calls get  dynamically patched out.</p><p> 对于参数（要测量的分支），您实际上可以使用任何所需的参数。我只尝试使用导致快速返回用户态的参数的creat syscall，然后测量是否已命中sys_creat和do_sys_open偏移量。偏移量必须相当精确，但不能到字节，因为branchpredictor中似乎存在一些别名：我最初使用__fentry__作为附加分支目标，这两个符号的偏移量均为+5，即使后来我知道这些调用都可以使用动态修补。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.frizn.fr/linux-kernel/cve-2020-14381">https://blog.frizn.fr/linux-kernel/cve-2020-14381</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/奇怪/">#奇怪</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/case/">#case</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>