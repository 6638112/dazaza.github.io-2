<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Java 8升级的原因 Reasons to upgrade from Java 8</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reasons to upgrade from Java 8<br/>从Java 8升级的原因 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-15 23:59:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/5afa94350a0b028eb6165664d0de7a84.jpg"><img src="http://img2.diglog.com/img/2021/4/5afa94350a0b028eb6165664d0de7a84.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Syntactic sugar (like the introduction of  var) is often not enough to convince somebody (especially non-developer) to move forward. This is one of the reasons why Java 8, almost 7 years after its first release, is still widely used. However,  many things have improved apart from the syntax. When taking all of them into account, it may turn out that  you can&#39;t afford to run Java 8  anymore. And no, I don&#39;t mean migrating the code, but simply  updating the JVM used as a runtime!</p><p>句法糖（如var的引入）往往不足以让某人（特别是非开发人员）说服前进。这是java 8，近7年后的第一个释放近7年的原因之一，仍然被广泛使用。然而，许多事情与语法不同。当他们考虑到所有这些时，它可能会发现您可以再运行Java 8。否，我不用映射代码，但只需更新用作运行时使用的JVM！</p><p> Let&#39;s  outline few non-syntactic benefits of upgrading the JVM. For those still running on Java 8, they may become a good starting point for discussions about the change. To those already migrated, they may introduce some less obvious features of the recent JVM.</p><p> 让＆＃39;概述升级JVM的一些非句法好处。对于仍然在Java 8上运行的人来说，他们可能成为关于改变的良好起点。对于已经迁移的人，他们可能会介绍最近的JVM的一些不那么明显的特征。</p><p> Note: In this article, I use the terms &#39;Java&#39; and &#39;JVM&#39; with regards to the Hotspot VM</p><p> 注意：在本文中，我使用条款＆＃39; java＆＃39;和＃39; JVM＆＃39;关于Hotspot VM</p><p>  Even the simplest  Hello world! application needs some time to start (elapsed between calling  java -jar ... and printing the message).  Recent comparisons show, that  since Java 8 the application startup time has already almost halved (comparing to the early builds of Java 16), consistently progressing towards better performance. Although this part takes only a fraction of a second (or at least it should), when combined with numerous optimizations introduced on the JVM level itself results in a noticeable speedup. In other words,  the same app running on the latest JVM should start faster than when running on Java 8.</p><p>  即使是最简单的地狱世界！应用程序需要一些时间开始（在调用java -jar之间经过...并打印消息）。最近的比较显示，因为Java 8申请启动时间几乎减半（与Java 16的早期构建相比），始终如一地进步更好的性能。虽然该部件仅在JVM级别本身上引入的许多优化时，占第二秒（或至少应该是应该的）的分数。换句话说，在最新的JVM上运行的相同应用程序应比在Java 8上运行时更快地开始。</p><p> In order to verify this, I took a  real-life, moderate-sized Spring Boot 2.3 application written in Kotlin (with  jvmTarget = &#39;1.8&#39; to target Java 8 bytecode) and  run it locally with Java 8, 11, and 15. As a startup time measurement, I&#39;ve picked the value reported in logs by the Spring Boot itself. Although it&#39;s not the best measure of the actual startup time (in this case  Quarkus&#39; approach seems to be better), it should be good enough for comparison when the only thing changing is the JVM runtime.</p><p> 为了验证这一点，我拍了一个现实生活，中等大小的春靴2.3在Kotlin编写的应用程序（JVMTarget =＆＃39; 1.8＆＃39;目标Java 8字节码），并使用Java 8运行它， 11和15.作为启动时间测量，I＆＃39; ve选自春天启动本身在日志中报告的值。虽然它不是最好的起始时间的最佳衡量标准（在这种情况下Quarkus＆＃39;方法似乎更好），它应该足够好，以便在更改唯一改变的是JVM运行时进行比较。</p><p>  As you can see,  switching from Java 8 to 11 resulted in a 15% speedup (1 second faster). Java 15 turned out to be a bit slower than 11 (about ~200ms) for some reasons, but it still provides at least 12% improvement over Java 8.</p><p>  如您所见，从Java 8到11切换为15％的加速（1秒更快）。由于某种原因，Java 15结果与11（约〜200ms）有点慢，但它仍然可以通过Java 8提供至少12％的改进。</p><p> Why it matters?  In distributed (replicated) environments, faster startup means that other nodes have to survive the higher load (caused by the temporary decreased number of replicas)  for a shorter period of time. This  reduces the possibility of unexpected service downtime or even cascading failure of the whole system. Additionally, faster startups allow performing the system upgrades quicker and with higher reliability. That means they simply  reduce the outage possibility.</p><p> 为什么这很重要？在分布式（已复制的）环境中，更快的启动意味着其他节点必须在更短的时间段内生存更高的负载（由临时减少的储副副本的数量）。这降低了意外的服务停机时间甚至整个系统的级联失败的可能性。此外，更快的启动允许更快地执行系统升级并具有更高的可靠性。这意味着他们只是减少中断可能性。 </p><p>  Modern   Hotspot JVM has at least  4 types of garbage collectors (GC) intended for production usage:</p><p>现代Hotspot JVM至少有4种类型的垃圾收集器（GC），用于生产使用：</p><p>  Note: there is also a  no-op GC available called Epsilon, but this one is intended for various testing purposes.</p><p>  注意：还有一个名为epsilon的NO-OP GC，但这是针对各种测试的目的。</p><p> Starting from Java 9, the default garbage collector has changed from  Parallel to  G1. The detailed comparison of both GC is far beyond the scope of this post, but in short,   G1 blocks application threads less frequently (so-called &#34;stop-the-world&#34; phase),  resulting in shorter GC pauses. In general, when preferring response time over throughput,  G1 should be a better fit.</p><p> 从Java 9开始，默认的垃圾收集器已从Parally更改为G1。两个GC的详细比较远远超出了这篇文章的范围，但简而言之，G1阻止了应用线程频繁（所谓的＆＃34;停止 - 世界＆＃34;阶段），导致GC暂停较短。通常，当允许吞吐量的响应时间时，G1应该是更好的合适。</p><p> Why one should care about the GC pauses? One thing is obviously  better application responsiveness.  Pauses taking second or more (not so rare with  Parallel GC under high load) may not only  negatively impact user experience, but also  cause failures of the dependent services (e.g. by exhausting their connection pool) or  unexpected application restarts (when due to GC pause app would be identified as non-responsive one).</p><p> 为什么一个人应该关心gc暂停？有一件事显然是更好的应用响应能力。暂停暂停第二个或更多（在高负载下并行GC不少数）可能不仅可以产生负面影响用户体验，而且还导致依赖服务的失败（例如，通过耗尽它们的连接池）或意外的应用程序重启（由于GC暂停时应用程序将被识别为非响应者）。</p><p>    That&#39;s definitely true, but G1&#39;s stability &amp; performance is improving with every new release. Only some of the changes (important bugfixes) are still being backported - simply,  Java 8 does not provide the best possible experience in terms of  G1 and it never will.</p><p>    那个＆＃39;肯定是真实的，但G1＆＃39; S稳定性＆amp;每次新版本都会改​​善性能。只有一些更改（重要的错误修正）仍然被返回 - 简单地，Java 8不提供G1的最佳体验，它永远不会提供。</p><p>   The same applies to  almost every change or improvement being backported to Java 8 (like  initial container awareness introduced with u191):  even if significant, it won&#39;t provide the same level of experience as newer JVMs will.</p><p>   这同样适用于几乎所有的变化或改进都被回到Java 8（如U191所介绍的初始容器意识）：即使是重要的，它也会提供与较新的JVMS的相同程度的经验。</p><p>  Interestingly, recent JVM releases come with another useful feature - the ability to  automatically switch between  Serial and  G1 GC based on resource constraints (CPU, memory). The idea is based on the characteristics of both collectors -  when operating in an environment with limited resources (e.g. single CPU or low memory environment)  Serial, single-threaded GC is often a better choice than any of the multi-threaded ones.</p><p>  有趣的是，最近的JVM版本具有另一个有用的功能 - 基于资源约束（CPU，内存）自动在串行和G1 GC之间切换的能力。该想法基于两个收集器的特征 - 当在具有有限资源的环境中操作（例如，单CPU或低存储器环境）串行时，单线程GC通常是比任何多线程更好的选择。 </p><p>  This seems to be a bit under-documented  Hotspot feature, as I did not find any specific criteria for such a selection. However,  based on my experiments with Java 11 it looks like, that:</p><p>这似乎是一个有效的底层热点功能，因为我没有找到这种选择的任何特定标准。但是，根据我的Java 11看起来像是这样的，那就是：</p><p> with  more than one CPU,   Serial collector is being selected when the environment has  less than 1792 MB of available memory.</p><p> 通过多个CPU，当环境具有小于1792 MB的可用内存时，正在选择串行收集器。</p><p> When running on Java 8,  Parallel GC would be used by default regardless of the environment resource constraints. This could become especially painful when multi-threading capabilities are limited (e.g. single CPU). In such a case, starting multiple GC threads would only cause additional context-switching effectively slowing down the processing.</p><p> 在Java 8上运行时，无论环境资源约束如何，都将使用并行GC。当多线程能力有限时，这可能变得尤其疼痛（例如，单CPU）。在这种情况下，启动多个GC线程只会导致额外的上下文切换有效地减慢处理。</p><p> Proper GC selection is a huge topic of its own, so let&#39;s conclude that  recent JVM versions provide us more suitable defaults than before.</p><p> 适当的GC选择是自己的巨大主题，所以让＆＃39;得出结论，最近的JVM版本提供了比以前更合适的默认值。</p><p>  Upgrading from Java 8 does not always have to start from changes in the code. Java is far more than just a language, and the JVM experiences major changes and improvements with each new release. Switching just a runtime to the newer version should result in  reduced startup time, better garbage collection &amp; higher performance. All those features should also bring benefits in terms of reliability. Although few of the recent features have been backported to Java 8, they can&#39;t compete with the level of experience provided by the more recent ones.  Migrating away from Java 8 is not a matter of  &#39;if&#39; anymore, but only about the  &#39;when&#39;.</p><p>  从Java 8升级并不总是必须从代码的更改开始。 Java不仅仅是一种语言，而且JVM经历了每个新版本的重大变化和改进。只需将运行时间切换到较新版本，应导致启动时间减少，更好的垃圾收集＆amp;表现更高。所有这些功能也应该在可靠性方面带来好处。虽然最近的一些功能已经被回到Java 8，但它们可以竞争更近期的经验水平。远离Java 8不是＆＃39;如果＆＃39;再过，但只有关于＆＃39;何时＆＃39; </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mikemybytes.com/2021/03/16/you-cant-afford-to-run-java-8/">https://mikemybytes.com/2021/03/16/you-cant-afford-to-run-java-8/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/升级/">#升级</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/upgrade/">#upgrade</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>