<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们如何获得我们的[Java]泛型 How we got the [Java] generics we have</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How we got the [Java] generics we have<br/>我们如何获得我们的[Java]泛型 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-01 20:06:27</div><div class="page_narrow text-break page_content"><p>Before we can talk about where generics are going, we first have to talk about where they are, and how they got there. This document will focus primarily on how we arrived at the generics we have now, and why, as a means of setting the groundwork for how the generics we have now will influence the “better” generics we are trying to build.</p><p>在我们谈论泛型的地方之前，我们首先必须谈谈他们所在的位置，以及他们如何到达那里。本文档将主要关注我们现在到达的泛型，以及为什么为为现在的泛型方式设置基础的手段，我们现在将影响我们尝试构建的“更好”的泛型。</p><p> In particular, we emphasize that erasure was in fact the sensible and pragmatic choice for adding generics to Java in 2004 – and many of the forces that led us to choose translation by erasure may still be operating today.</p><p> 特别是，我们强调，擦除实际上是在2004年向Java添加仿制机的明智和务实的选择 - 以及让我们选择通过擦除选择翻译的许多力量可能仍然可以在今天运营。</p><p>  Ask any developer about Java generics, and you’ll likely get an angry (though often uninformed) rant about  erasure. Erasure is probably the most broadly and deeply misunderstood concept in Java.</p><p>  向任何关于Java泛型的开发人员询问，您可能会生气（虽然通常不知情）咆哮。删除可能是Java最广泛而深入的误解概念。</p><p> Erasure is not specific to Java, nor to generics; it is a ubiquitous, and often necessary, tool for translating code at one level into a lower level (such as when compiling from Java source to bytecode, or compiling C source to native code.) This is because as we move down the stack from high-level languages to intermediate representations to native code to hardware, the type abstractions offered by the lower level are almost always simpler and weaker than those at the higher level – and rightly so. (We wouldn’t want bake the semantics of virtual dispatch into the X86 instruction set, or mimic the set of Java’s primitive types in its registers.) Erasure is the technique of mapping richer types at one level to less rich types at a lower level (ideally, after performing sound type checking at the higher level), and is something compilers do every day.</p><p> 擦除不是Java，也不是泛型;它是一种普遍存在的，通常需要的工具，用于将一个级别转换为较低级别（例如从Java源编译到字节码时，或编译C源代码到本机代码。）这是因为我们从堆栈中移动高级语言到中间表示到原始代码到硬件，由较低级别提供的类型抽象几乎总是更简单，弱于更高级别的 - 而且正确地弱。 （我们不希望将虚拟调度的语义释放到X86指令集中，或模拟其寄存器中的Java的基本类型集。）擦除是在一个级别映射更丰富的类型，以在较低级别的较小类型（理想情况下，在更高级别执行声音类型检查后），并且每天都是编译器。</p><p> For example, the Java bytecode set contains instructions for moving integers values between the stack and local variable set ( iload,  istore), and for doing arithmetic on ints ( iadd,  imul, etc.) There are similar instructions for floats ( fload,  fstore,  fmul, etc), longs ( lload,  lstore,  lmul), doubles ( dload,  dstore,  dmul), and object references ( aload,  astore.) But there are no such instructions for bytes, shorts, chars, or booleans – because these types are erased to ints by the compiler, and use the  int-movement and arithmetic instructions. This is a pragmatic design tradeoff in the design of the bytecode instruction set; it reduces the complexity of the instruction set, which in turn can improve the efficiency of the runtime. Many other features of the Java language (e.g., checked exceptions, method overloading, enums, definite assignment analysis, nested classes, capture of local variables by lambdas or local classes, etc) are “language fictions” – they are checked in the Java compiler but erased away in the translation to classfiles.</p><p> 例如，Java字节码集包含用于在堆栈和本地变量集之间移动整数值（IADD，IMUL等）之间移动整数值的指令（IADD，IMUL等）浮动的相似说明（浮灯，FSTORE ，fmul等），龙（lload，lstore，lmul），双打（dload，dstore，dmul）和对象引用（Aload，Astore。），但没有这样的字节，短裤，字符或布尔值的说明 - 因为这些类型由编译器删除到INT，并使用INT移动和算术指令。这是一个务实的设计权衡，用于设计字节码指令集;它降低了指令集的复杂性，从而可以提高运行时的效率。 Java语言的许多其他功能（例如，检查的异常，方法重载，枚举，明确分配分析，嵌套类，Lambdas或本地类别的临界类别捕获）是“语言小说” - 在Java编译器中检查它们但在翻译到Classfiles中。</p><p> Similarly, when compiling C to native code, both signed and unsigned ints are erased into general-purpose registers (there are no separate signed vs unsigned registers), and  const variables are stored in mutable registers and memory locations. We don’t find this sort of erasure weird at all.</p><p> 类似地，当编译C到原生代码时，签名和无符号int都被删除到通用寄存器中（没有单独的符号VS无符号寄存器），并且CONST变量存储在可变寄存器和存储器位置。我们根本没有找到这种擦除怪异。</p><p>  There are two common approaches for translating generic types in languages with parameteric polymorphism –  homogeneous and  heterogeneous translation. In a homogeneous translation, a generic class  Foo&lt;T&gt; is translated into a single artifact, such as  Foo.class (and same for generic methods). In a heterogeneous translation, each instantiation of a generic type or method ( Foo&lt;String&gt;,  Foo&lt;Integer&gt;) is treated as a separate entity, and generates separate artifacts. For example,  C++ uses a heterogeneous translation: different instantiations of a template are completely different types, with different semantics and different generated code. The types  vector&lt;int&gt; and  vector&lt;float&gt; are separate types. On the one hand, this is great for type safety (each instantiation can be separately type-checked after expansion) and for the quality of generated code (as each instantiation can be separately optimized). On the other hand, this means larger code footprint (since  vector&lt;int&gt; and  vector&lt;float&gt; have separate code), and we cannot talk about “vector of something” (as Java does through wildcards), since each instantiation is a wholly unrelated type. (As an extreme demonstration of the possible footprint costs, Scala experimented with an  @specialized annotation that, when applied to type variables, caused the compiler to emit specialized versions for all the primitive types. This sounds cool, but results in a  9  n explosion of generated classes, where   n is the number of specialized type variables in a class, so one can easily generate a 100MB JAR file from a few lines of code.)</p><p>  用参数多态性翻译语言的通用类型有两种常见的方法 - 同质和异质翻译。在同质的翻译中，通用类foo＆lt; t＆gt;被翻译成单个工件，例如foo.class（对于通用方法也相同）。在异构的翻译中，每次实例化通用类型或方法（foo＆lt; string＆gt; foo＆lt; integer＆gt;）被视为单独的实体，并生成单独的伪像。例如，C ++使用异构翻译：模板的不同实例是完全不同的类型，具有不同的语义和不同生成的代码。类型矢量＆lt; int＆gt;和矢量＆lt;浮动＆gt;是单独的类型。一方面，这对于类型的安全性很好（每个实例化可以单独键入膨胀后校验），并且对于所生成的代码的质量（每个实例化可以单独优化）。另一方面，这意味着较大的代码占用（自矢量＆lt; int＆gt;和向量＆lt; float＆gt;有单独的代码），我们不能谈论“某种东西的向量”（作为Java通过通配符），因为每个实例化都是一个完全的不相关的类型。 （作为可能的足迹成本的极端演示，Scala使用@specialized注释试验，当应用于型变量时，使编译器发出所有原始类型的专用版本。这听起来很酷，但导致9 n爆炸生成的类，其中n是类中专用类型变量的数量，所以人们可以从几行代码中轻松生成100MB JAR文件。） </p><p> The choice between homogeneous and heterogeneous translations involves making the sorts of tradeoffs language designers make all the time. Heterogeneous translations offer more type specificity, at the cost of greater static and dynamic footprint, and less sharing at runtime – all of which have performance implications. Homogeneous translations are more amenable to abstracting over parametric families of types, such as Java’s wildcards, or C#’s declaration-site variance (both of which  C++ lacks, where there is nothing in common between  vector&lt;int&gt; and  vector&lt;float&gt;.) For more information on translation strategies, see   this influential paper.</p><p>同质化和异构翻译的选择涉及使得各种权衡语言设计师一直在制作。异构翻译提供更多类型的特异性，以更高的静态和动态足迹，并且在运行时分享较少 - 所有这些都具有性能影响。均匀翻译更适合抽象的类型的类型类型，例如Java的通配符或C＃的声明站点方差（其中C ++缺乏，在载体＆lt; int＆gt之间没有常见的情况下。和向量＆lt; float＆gt;）有关翻译策略的更多信息，请参阅此有影响力的纸张。</p><p>  Java translates generics using a homogeneous translation. Generics are type-checked at compile time, but then a generic type like  List&lt;String&gt; is erased to  List when generating bytecode, and type variables such as  &lt;T extends Object&gt; are erased to the erasure of their bound (in this case,  Object).</p><p>  Java使用同意翻译翻译泛型。泛型是在编译时键入的，但随后是一个泛型类型，如列表＆lt; string＆gt;生成字节码时被删除到列表，以及诸如＆lt; t的键入变量延长对象＆gt;被擦除到他们绑定的擦除（在这种情况下，对象）。</p><p>  class Box&lt;T&gt; { private T t; public T(T t) { this.t = t; } public Box&lt;T&gt; copy() { return new Box&lt;&gt;(t); } public T t() { return t; }}</p><p>  类盒＆lt; t＆gt; {私人t t;公共T（t t）{this.t = t;公共箱子＆lt; t＆gt;复制（）{返回新框＆lt;（t）; public t t（）{返回t; }}</p><p> The  javac compiler emits a single classfile  Box.class, which serves as the implementation for all instantiations of  Box – including wildcards ( Box&lt;?&gt;) and raw types ( Box). Field, method, and supertype descriptors are erased; type variables are erased to their bounds, generic types are erased to their head ( List&lt;String&gt; erases to  List) as follows:</p><p> javac编译器发出单个类文件框.Class，它用作框的所有实例的实现 - 包括通配符（框＆lt;？＆gt;）和原始类型（框）。擦除字段，方法和超级性描述符;类型变量删除到其界限，泛型类型被删除到它们的头部（列表＆lt; string＆gt;删除列表），如下所示：</p><p> class Box { private Object t; public Box(Object t) { this.t = t; } public Box copy() { return new Box(t); } public Object t() { return t; }}</p><p> 类盒{私有对象T;公共盒子（对象t）{this.t = t; }公共框副本（）{返回新框（t）; public对象t（）{return t; }}</p><p> The generic signatures are retained (in the  Signature attribute) so that compilers can see the generic signatures when reading the classfile, but the JVM uses only the erased descriptors in linkage. This translation scheme means that at the classfile level, both the  layout and  API of  Box&lt;T&gt; is erased. At the  use site, the same thing happens: references to  Box&lt;String&gt; are erased to  Box, with a synthetic cast to  String inserted at the use site.</p><p> 保留通用签名（在签名属性中），以便编译器可以在读取类文件时看到通用签名，但JVM仅使用链接中的删除描述符。该转化方案意味着在ClassFile级别，框的布局和API都是框＆lt; t＆gt;被删除了。在使用网站上，发生同样的事情：对框的引用＆lt; string＆gt;被擦除到框，用合成铸造到使用网站的字符串。</p><p>  It is at this point where it is tempting to huff and declare that these were obviously foolish or lazy choices, or that erasure is a dirty hack. After all, why would the compiler throw away perfectly good type information?</p><p>  正是在这一点上，令人诱人令人兴奋，并声明这些是明显愚蠢或懒惰的选择，或者擦除是一个肮脏的黑客。毕竟，编译器为什么会丢弃完全好类型的信息？ </p><p> To better understand the question, we should also ask: were we to reify that type information, what would we expect to do with it, and what are the costs associated with that? There are several different ways we could envision using reified type parameter information:</p><p>为了更好地了解这个问题，我们还应该问：我们是否refify那种类型的信息，我们希望与它有什么关系，以及与此相关的成本是多少？我们可以使用requied类型参数信息设想有几种不同的方式：</p><p> Reflection. For some, “reified generics” merely means that you can ask a  List what it is a list of, whether using language tools like  instanceof or pattern matching on type variables, or using reflective libraries to inquire about the type parameters.</p><p> 反射。对于一些，“Reified Generics”仅仅意味着您可以询问列表列表，无论是使用instanceof或类型变量匹配的语言工具，还是使用反射库询问类型参数。</p><p> Layout or API specialization. In a language with primitive types or inline classes, it might be nice to flatten the layout of a  Pair&lt;int, int&gt; to hold two ints, rather than two references to boxed objects.</p><p> 布局或API专业化。以一种具有原始类型或内联类的语言，可能很好地平整对的布局＆lt; int，int＆gt;持有两个INT，而不是两个对盒装对象的引用。</p><p> Runtime type checking. When a client attempts to put an  Integer in a  List&lt;String&gt; (through, say, a raw  List reference), which would cause heap pollution, it would be nice to catch this and fail at the point where the heap pollution would be caused, rather than (maybe) detecting it later when it hits a synthetic cast.</p><p> 运行时类型检查。当客户端尝试将整数放入列表＆lt; string＆gt; （通过说，一个原始列表参考），它会导致堆污染，捕获这一点并在堆污染的观点来看是很好的，而不是（也许）当它击中合成时投。</p><p> While not mutually exclusive, these three possibilities (reflection, specialization, and type checking) are in aid of different goals (programmer convenience, performance, and safety, respectively) – and have different implications and costs. While it is easy to say “we want reification”, if we drill deeper, we’ll find significant divisions as to which of these are most important, and their relative costs and benefits.</p><p> 虽然不是相互排斥的，这三种可能性（反射，专业化和类型检查）有助于不同的目标（程序员便利性，性能和安全性） - 具有不同的影响和成本。虽然很容易说“我们想要重新化”，如果我们深入钻取，我们将找到重要的分歧，这是最重要的，以及它们的相对成本和福利。</p><p> To understand how erasure was the sensible and pragmatic choice here, we also have to understand what the goals, priorities and constraints, and alternatives were at the time.</p><p> 要了解擦除是如何在这里的明智和务实的选择，我们也必须了解目标，优先事项和限制以及当时的替代品。</p><p>   It must be possible to evolve an existing non-generic class to be generic in a binary-compatible and source-compatible manner.</p><p>   必须以二进制兼容和源兼容的方式逐渐发展现有的非泛型类。 </p><p> This means that existing clients and subclasses of, say,  ArrayList, could continue to recompile without change against the generified  ArrayList&lt;T&gt;, and that existing classfiles would continue to link to the methods of the generified  ArrayList&lt;T&gt;. Supporting this meant that clients and subclasses of generified classes could choose to generify immediately, later, or never, and could do so independently of what maintainers of other clients or subclasses chose to do.</p><p>这意味着，现有的客户端和子类（例如，ArrayList）可以继续重新编译，而不会对生长的ArrayList＆lt; t＆gt;而且现有类文件将继续链接到生成的ArrayList＆lt; t＆gt的方法。支持这意味着生长类的客户端和子类可以选择立即，稍后或从未使用，并且可以独立于其他客户端或子类选择的维护者。</p><p> Without this requirement, generifying a class would require a “flag day” where all clients and subclasses have to be at least recompiled, if not modified – all at once. For a core class such as  ArrayList, this essentially requires all the Java code in the world to be recompiled at once (or be permanently relegated to remain on Java 1.4.) Since such a “flag day” across the entire Java ecosystem was out of the question, we needed a generic type system that allowed core platform classes (as well as popular third-party libraries) to be generified without requiring clients be aware of their generification. (Worse, it wouldn’t have been one flag day, but many, since it is not the case that all the world’s code would have been generified in a single atomic transaction.)</p><p> 如果没有此要求，生成类将需要一个“旗帜日”，其中所有客户端和子类必须至少重新编译，如果没有修改 - 同时所有。对于诸如ArrayList等核心类，这主要需要世界上的所有Java代码一次重新编译（或者永久被降级以保持在Java 1.4上。）由于整个Java生态系统中的这样一个“旗帜日”是问题，我们需要一个通用类型系统，可允许在不需要客户到生成的情况下致力于生成核心平台类（以及流行的第三方库）。 （更糟糕的是，它不会是一个旗帜日，但很多，因为并非如此全球所有代码都在单个原子交易中致力于。）</p><p> Another way to state this requirement is: it was not considered acceptable to orphan all the code out there that could have been generified, or make developers choose between generics and retaining the investment they’ve already made in existing code. By making generification a compatible operation, the investment in that code could be retained, rather than invalidated.</p><p> 陈述这一要求的另一种方法是：孤儿不可接受，可以在那里孤立，或者可以将开发人员选择泛型和保留他们已经在现有代码中所做的投资之间进行选择。通过生成兼容的操作，可以保留该代码的投资，而不是无效。</p><p> The aversion to “flag days” comes from an essential aspect of Java’s design: Java is  separately compiled and  dynamically linked. Separate compilation means that every source file is compiled into one or more class files, rather than compiling a group of sources into a single artifact. Dynamic linkage means that references between classes are linked at run time, based on symbolic information; if class  C invokes method  void m(int x) in  D, then in the classfile for  C we record the name and descriptor ( (I)V) of the method we are invoking, and at link time we look for a method in  D with this name and descriptor, and if a match is found, the call site is linked.</p><p> 厌恶“旗日”来自Java设计的重要方面：Java是单独编译和动态链接的。单独的编译意味着每个源文件都被编译为一个或多个类文件，而不是将一组源编译为单个工件。动态链接意味着基于符号信息，类之间的引用在运行时链接;如果c类调用方法void m（int x），则在c的Classfile中，我们记录我们正在调用的方法的名称和描述符（（i）v），并且在链接时间我们在d中查找方法使用此名称和描述符，如果找到匹配项，则呼叫站点已链接。</p><p> This may sound like a lot of work, but separate compilation and dynamic linkage power one of Java’s biggest advantages – you can compile  C against one version of  D and run with a different version of  D on the class path (as long as you don’t make any  binary incompatible changes in  D.).</p><p> 这可能听起来像很多工作，而是单独的编译和动态联动电源一个Java最大的优势之一 - 您可以编译C的一个版本D并在类路径上使用不同的版本D（只要您不行） T在D.）中进行任何二进制不兼容的变化。</p><p> The pervasive commitment to dynamic linkage is what allows us to simply drop a new JAR on the class path to update to a new version of a dependency, without having to recompile anything. We do this so often we don’t even notice – but if this stopped working, it would indeed be noticed.</p><p> 对动态链接的普遍承诺是允许我们在类路径上丢弃一个新的jar来更新到依赖的新版本，而无需重新编译任何内容。我们这样做，我们甚至不知道 - 但如果这停止工作，那就确实被注意到了。</p><p> At the time generics were introduced into Java, there was already a lot of Java code in the world, and their classfiles were full of references to APIs like  java.util.ArrayList. If we couldn’t generify these APIs compatibly, then we would have to have written  new APIs to replace them, and worse, all of the client code of the old APIs would be stuck with an untenable choice – either stay on 1.4 forever, or rewrite them to use the new APIs, simultaneously (including not only the application code, but all third-party libraries on which the application depends.) This would have devalued almost all the Java code in existence at the time.</p><p> 在泛造造器被引入Java时，世界上已经有很多Java代码，他们的Classfiles充满了对java.util.arraylist的API的引用。如果我们无法兼容地造成这些API，那么我们必须编写新的API来替换它们，更糟糕的是，旧API的所有客户代码都会被困住，无论是永久的选择 - 要么永远停留1.4将它们重写为同时使用新的API（不仅包括应用程序代码，而是应用程序所取决于的所有第三方库。）这将使当时存在几乎所有的Java代码。 </p><p> C# made the opposite choice – to update their VM, and invalidate their existing libraries and all the user code that dependend on it. They could do this at the time because there was comparatively little C# code in the world; Java didn’t have this option at the time.</p><p>C＃使其相反的选择 - 更新其VM，并使其现有的库和依赖于它的所有用户代码无效。他们可以在当时做到这一点，因为世界上有相对较少的C＃代码; Java当时没有此选项。</p><p> One consequence of this choice, though, is that it will be an expected occurrence that a generic class will simultaneously have both generic and non-generic clients or subclasses. This is a boon to the software development process, but it has potential consequences for type safety under such mixed usage.</p><p> 然而，这种选择的一个结果是，它将是预期发生的，即通用类将同时具有通用和非泛型客户端或子类。这是一个福音对软件开发过程，但它对这种混合使用情况下的类型安全具有潜在的后果。</p><p>  Erasing in this manner, and supporting interoperability between generic and non-generic clients, creates the possibility of  heap pollution – that what is stored in the box has a runtime type that is not compatible with the compile-time type that was expected. When a client uses a  Box&lt;String&gt;, casts are inserted whenever a  T would be assigned to a  String, so that heap pollution is detected at the point where data transitions from the world of type variables (the implementation of  Box) to the world of concrete types. In the presence of heap pollution, these casts can fail.</p><p>  以这种方式擦除，并支持通用和非泛型客户端之间的互操作性，会产生堆污染的可能性 - 该框中存储的内容具有与预期的编译时类型不兼容的运行时类型。当客户端使用框＆lt; string＆gt;时，只要将t分配给一个字符串，都会插入投射，从而在从类型变量（框）的数据转换到世界的数据转换的点处检测到堆污染混凝土类型。在存在堆污染的情况下，这些铸件可能会失败。</p><p> Heap pollution can come from when non-generic code uses generic classes, or when we use unchecked casts or raw types to forge a reference to a variable of the wrong generic type. (When we used unchecked casts or raw types, the compiler warns us that heap pollution might result.) For example:</p><p> 堆污染可以来自非通用代码使用泛型类，或者当我们使用未经检查的投影或原始类型时伪造对错误通用类型的变量的引用。 （当我们使用未经检查的演员或原始类型时，编译器警告我们可能会导致堆污染。）例如：</p><p> Box&lt;String&gt; bs = new Box&lt;&gt;(&#34;hi!&#34;); // safeBox&lt;?&gt; bq = bs; // safe, via subtypingBox&lt;Integer&gt; bi = (Box&lt;Integer&gt;) bq; // unchecked cast -- warning issuedInteger i = bi.get(); // ClassCastException in synthetic cast to Integer</p><p> 盒子＆lt;弦＆gt; bs =新框＆lt;＆gt;（＆＃34;嗨！＆＃34;）; // safebox＆lt;＆gt; BQ = BS; //安全，通过亚型箱＆lt;整数＆gt; bi =（框＆lt;整数＆gt;）bq; //未选中的演员 - 警告发出indedInteger i = bi.get（）; // SyntheCence中的ClassCastException for to整数</p><p> The sin in this code is the unchecked cast from  Box&lt;?&gt; to  Box&lt;Integer&gt;; we have to take the developer at their word that the specified  box really is a  Box&lt;Integer&gt;. But the heap pollution is not caught right away; only when we try to  use the  String that was in the box as an  Integer, do we detect that something went wrong. Under the translation we have, if we cast our box to  Box&lt;Integer&gt; and back to  Box&lt;String&gt; before we used it as a  Box&lt;String&gt;, nothing bad happens (for better or worse.) Under a heterogeneous translation,  Box&lt;String&gt; and  Box&lt;Integer&gt; would have different runtime types, and this cast would fail.</p><p> 此代码中的SIN是从框中的未经检查的施法施放。框＆lt; integer＆gt ;;我们必须将开发人员带到他们的单词中，指定的框确实是一个框＆lt; integer＆gt;但堆污染并没有立即捕获;只有当我们尝试使用框中作为整数的字符串时，我们才能检测到出现问题的情况。在翻译下我们有，如果我们将盒子施放到框＆lt;整数＆gt;并返回框＆lt; string＆gt;在我们用它作为一个框之前，它在一个框＆lt; string＆gt;，没有发生任何糟糕的情况（无论好坏。）在异构的翻译下，框＆lt; string＆gt;和框＆lt;整数＆gt;将有不同的运行时类型，此演员将失败。</p><p> The language actually provides quite a strong safety guarantee for generics, as long as we follow the rules:</p><p> 只要我们遵守规则，该语言实际上为泛型提供了相当强烈的安全保证： </p><p> If a program compiles with no unchecked or raw warnings, the synthetic casts inserted by the compiler will never fail.</p><p>如果程序编译没有未选中或原始警告，则编译器插入的合成演员永远不会失败。</p><p> In other words,  heap pollution can only occur when we are interoperating with non-generic code or when we  lie to the compiler. At the point where the heap pollution is discovered, we get a clean exception telling us what type was expected and what type was actually found.</p><p> 换句话说，只有在我们与非通用代码互操作时才会发生堆污染，或者当我们骗他们的编译器时。在发现堆污染的地步时，我们会得到一个干净的例外，告诉我们预期的类型以及实际发现的类型。</p><p>  The design choices surrounding generics were also influenced by the structure of the ecosystem of JVM implementations and of languages running on the JVM. While to most developers “Java” is a monolithic entity, in fact the Java Language and the Java Virtual Machine (JVM) are separate entities, each with their own specification. The Java compiler produces classfiles for the JVM (whose format and semantics are laid out in the Java Virtual Machine Specification), but the JVM will happy run any valid classfile, regardless of what source language it originally came from. By some counts, there are over 200 languages that use the JVM as compilation target, some of which have a lot in common with the Java language (e.g., Scala, Kotlin) and others which are very different languages (e.g., JRuby, Jython, Jaskell.)</p><p>  围绕泛型的设计选择也受到JVM实现和在JVM上运行的语言的结构的影响。虽然到大多数开发人员“Java”是一种单片实体，实际上Java语言和Java虚拟机（JVM）是​​单独的实体，每个实体都有自己的规范。 Java编译器为JVM生成ClassFiles（其格式和语义在Java虚拟机规范中奠定），但JVM会幸福运行任何有效的类文件，无论它最初来自哪种源语言来自它。通过一些计数，有200多种语言，使用JVM作为编译目标，其中一些与Java语言（例如，Scala，Kotlin）和其他语言的其他人有很多共同之处（例如，JRuby，Jython，贾克尔。）</p><p> One reason the JVM has been so successful as a compilation target, even for languages quite different from Java, is that it provides a fairly abstract model for computing, with limited influence from the Java language. The abstraction layer between the language and virtual machine was not only useful for stimulating an ecosystem of other languages that run on the JVM, but also an ecosystem of  independent implementations of the JVM. While the market today has consolidated substantially, at the time that generics were added to Java, there were over a dozen commercially viable implementations of the JVM. Reifying generics would mean that not only would we need to enhance the language to support generics, but also the JVM.</p><p> JVM作为汇编目标的一个原因是汇编目标，即使对于与Java完全不同的语言，它提供了一个相当抽象的计算模型，从Java语言影响有限。语言和虚拟机之间的抽象层不仅适用于刺激在JVM上运行的其他语言的生态系统，还可以是JVM的独立实现的生态系统。虽然当今市场已经大大合并了，但在泛型被添加到Java时，在JVM中有十几种商业上可行的实施。 Reify Generics意味着我们不仅需要增强语言来支持泛型，还需要JVM。</p><p> While it might have been technically possible to add generic support to the JVM at the time, not only would it have been a significant engineering investment requiring substantial coordination and agreement between the many implementors, the ecosystem of languages on the JVM might also have had an opinion about reified generics. If, for example, the interpretation of reification included type checking at runtime, would Scala (with its declaration-site generics) be happy to have the JVM enforce Java’s (invariant) generic subtyping rules?</p><p> 虽然可能在技术上可以在技术上向JVM添加通用支持，但不仅它是许多实施者之间需要大量协调和协议的重要工程投资，但JVM上的语言生态系统也可能有一个关于REIFIZE泛型的意见。例如，如果reationation incound incouded inclation in运行时键入，则Scala（带有声明 - 站点泛型）将很高兴拥有JVM强制java（不变）泛型亚型规则？</p><p>  Taken together, these constraints (both technical and ecosystem) acted as a powerful force to push us towards a homogeneous translation strategy where generic type information is erased at compile time. To summarize, forces that pushed us towards this decision include:</p><p>  携带这些限制（技术和生态系统）作为强大的力量，以推动我们迈向同质翻译策略，其中在编译时删除了通用类型信息。总结一下，将我们推向该决定的力量包括：</p><p> Runtime costs. A heterogeneous translation entails all sorts of runtime costs: greater static and dynamic footprint, greater class-loading costs, greater JIT costs and code cache pressure, etc. This might have put developers in a position where they had to choose between type-safety and performance.</p><p> 运行时成本。异构的翻译需要各种运行时成本：更高的静态和动态占用，更高的类加载成本，更高的JIT成本和代码缓存压力等。这可能会使开发人员在类型安全之间选择的位置。表现。 </p><p> Migration compatibility. There was no known translation scheme at the time that would have allowed a migration to reified generics to be source- and binary-compatible, creating flag days and invalidating developer’s considerable investment in their existing code.</p><p>迁移兼容性。在允许迁移到redified泛型的时间内没有已知的翻译方案是源和二进制兼容的，创建标志日，并使开发人员在其现有代码中的相当大的投资。</p><p> Runtime costs, bonus edition. If reification is interpreted as  checking types at runtime (just as stores into Java’s covariant arrays are dynamically checked), this would have a significant runtime impact, as the JVM would have to perform generic subtyping checks at runtime on every field or array element store, using the language’s generic type system. (This might sound easy and cheap when the type is something simple like  List&lt;String&gt;, but can quickly get expensive when they are something like  Map&lt;? extends List&lt;? super Foo&gt;&gt;, ? super Set&lt;? extends Bar&gt;&gt;. (In fact, later research cast doubt on the  decidability of generic subtyping).</p><p> 运行时成本，奖金版。如果在运行时被解释为检查类型（就像在Java的Covariant阵列中的存储一样），这将具有重要的运行时影响，因为JVM必须在每个字段或阵列元素存储上执行运行时在运行时执行通用子类型检查，使用语言的通用类型系统。 （当类型是简单的列表＆lt; string＆gt;而且，当它们是MAP＆lt; super foo＆gt; super foo＆gt时，这可能听起来很容易和便宜＆gt;（实际上，后来研究对通用亚型的可辨性令人怀疑）。</p><p> JVM ecosystem. Getting a dozen JVM vendors to agree on if, and how, type information would be reified at runtime was a highly questionable proposition.</p><p> JVM生态系统。获得十几个JVM供应商达成协议，以及如何在运行时重新确定类型信息是一个高度可疑的主张。</p><p> Delivery pragmatics. Even if it were possible to get a dozen JVM vendors to agree on a scheme that could actually work, it would have greatly increased the complexity, timeline, and risk of an already substantial and risky effort.</p><p> 交付语用学。即使有十几名JVM供应商达成一个实际工作的计划，它也会大大增加复杂性，时间表，以及已经巨大和风险的努力。</p><p> Language ecosystem. Languages like Scala might not have been happy to have Java’s invariant generics burned into the semantics of the JVM. Agreeing on a set of acceptable cross-language semantics for generics in the JVM would again have increased the complexity, timetable, and risk of an already substantial and risky effort.</p><p> 语言生态系统。像Scala这样的语言可能不满意将Java的不变性泛型刻录到JVM的语义中。同意JVM中的一系列可接受的泛语语义将再次提高复杂性，时间表和风险危险的努力。</p><p> Users would have to deal with erasure (and therefore heap pollution) anyway. Even if type information could be preserved at runtime, there would always be dusty classfiles that were compiled before the class was generified, so there would still be the possibility that any given  ArrayList in the heap had no type information attached, with the attendant risk of heap pollution.</p><p> 无论如何，用户都必须处理擦除（并因此堆污染）。即使在运行时可以保留类型信息，始终会在课程的生成之前编译的Dusty Classfiles，因此堆中的任何给定的ArrayList都没有附加类型信息，具有伴随的风险堆污染。</p><p> Certain useful idioms would have been inexpressible. Existing generic code wi</p><p> 某些有用的成语将是不可压缩的。现有的通用代码Wi </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cr.openjdk.java.net/~briangoetz/erasure.html">https://cr.openjdk.java.net/~briangoetz/erasure.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>