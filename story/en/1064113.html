<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我支持gcc-rs I Support GCC-Rs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">I Support GCC-Rs<br/>我支持gcc-rs </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-08 03:08:27</div><div class="page_narrow text-break page_content"><p>This is an opinion piece written in response to  The Simpler Alternative to GCC-rs (Shnatsel), explaining why I support the GCC-rs project, and why rustc_codegen_gcc is not a substitute for it. While rustc_codegen_gcc, does provide some of the benefits of the gcc-rs, it does not provide all of them. There are benefits specifically to having a distinct frontend, over just the backend, which I will address in this article. This is from the perspective of an author of  lccc, which includes a different alternative implementation of the rust language, though it is further from completion then gcc-rs.</p><p>这是一种响应于GCC-RS（SHNATSEL）的更简单替代品编写的意见片，解释了为什么我支持GCC-RS项目，以及rustC_Codegen_GCC不是替代它。虽然RustC_Codegen_GCC，确实提供了GCC-RS的一些好处，但它不提供所有的所有优势。特别是具有独特的前端有益，即将在这篇文章中地址的后端。这是从LCCC作者的角度来看，其中包括生锈语言的不同替代实施，但它进一步完成然后GCC-RS。</p><p>  Hav  ing multiple implementations, in general, is a good idea. While it can be shown that, at least to begin with, C and C++ had issues with it, it is in my experience this is generally no longer the case. Because I have options available to me, I can choose the compilers I want to support based on the available features and compliance with the standard. I recently raised a Non-compliance bug with Microsoft Visual C++ that prevents my C++ code from compiling. I’ve chosen not to support MSVC until that bug is fixed, and am able to do that because of alternatives like gcc and clang. With rustc, if I have a legitimate issue, I cannot choose to use a different compiler, I can either choose to redesign the code or abandon rust entirely. In fact, this was an issue with lccc, which would have been written in rust but for the lack of any stable ABI at a higher level than C.</p><p>  一般来说，多次实现是一个好主意。虽然可以表明，至少首先，C和C ++有问题，它是我的经验，这通常不再是这种情况。因为我对我提供了选择，我可以根据可用的功能和符合标准选择我想要支持的编译器。我最近介绍了Microsoft Visual C ++的非合规性错误，可防止C ++代码编译。我选择不支持MSVC，直到该错误是固定的，而且由于GCC和Clang等替代方案，就可以这样做。使用RustC，如果我有合法问题，我不能选择使用不同的编译器，我可以选择重新设计代码或完全放弃生锈。事实上，这是LCCC的一个问题，该问题将用Rust编写，但缺乏任何稳定的ABI在比C更高的水平。</p><p> Having competition in the space of rust front ends would give reasons for the compiler authors to fix bugs and otherwise improve, and give users options for when those bugs are present, beyond just “work around it” or “drop the language entirely”.</p><p> 在铁锈前端的空间中竞争将使编译器作者修复错误并以其他方式改进的原因，并为用户提供当这些错误存在时，超越“完全解决”或“完全删除语言”。</p><p> This point does not come without a “however”, though. It is entirely possible that gcc-rs could cause the ecosystem to fracture, if it introduced considerable inconsistencies with established “features” of the rust language and made limited, or no, efforts to fix them. However, part of the solution would be a proper specification of some kind, which I will address later. The other part, of course, would be holding the implementations accountable to fixing non-compliance bugs, by refusing to support implementations that violate the spec. However, this would naturally require a proper specification, as lacking one, users could hold up their code as a reason that all implementations need to perfectly emulate any other implementation, including it’s bugs and unspecified behaviour.</p><p> 然而，这一点没有“然而”。如果它介绍了生锈语言的建立的“特征”并制造了有限，或者不努力，因此完全有可能导致生态系统造成勃起，如果引入了建立的“功能”，或者没有努力解决它们。但是，部分解决方案将是某种的适当规范，我稍后会解决。当然，另一方面将通过拒绝支持违反规范的实施来持有对修复非符合性错误的实现。但是，这将自然需要一个适当的规范，因为缺少一个，用户可以将其代码保持为原因，因为所有实现都需要完全模仿任何其他实现，包括它是错误和未指定的行为。</p><p>  Regarding bootstrapping, having the ability to bootstrap a compiler from any arbitrary point can be useful for more than just introducing the compiler to that platform. It can be useful in security and safety verification of software to be able to start from some known good software (like a C compiler), and build up from there without entering an untrusted domain.</p><p>  关于引导，具有从任何任意点引导编译器的能力可能很有用，而不是仅仅将编译器引入该平台。它可用于软件的安全性和安全验证，以便能够从一些已知的好软件（如C编译器）开始，并在没有进入不受信任的域的情况下从那里积聚。</p><p> Further, while mrustc can be used to shorten the bootstrap chain, it does not shorten it to a reasonable limit, as it’s only capable of building rustc 1.39, as of the last time I checked (which was a couple weeks prior to publishing this article). rustc 1. n is capable of building rustc 1. n+1, and the current stable rustc is 1.52 (nightly on 1.54). Thus, to reach the current stable rustc, from mrustc, one would have to build 13 different versions of rustc, at least. While this is better than 52 versions for sure, it still takes an entirely unreasonable amount of time. In contrast, with Rust compiler written in C++98 (the version that gcc-rs is written), starting from a C compiler, the sequence is simple:</p><p> 此外，虽然MRESTC可以用来缩短自举链，但它不会缩短到合理的限制，因为它只能在我检查的最后一次建立RUSTC 1.39（这是在发布本文之前几周的几周）。 RUSTC 1.N能够建立锈的1.N + 1，电流稳定的锈蚀器是1.52（1.54夜晚）。因此，要从MRESTC到达目前的稳定锈，因此必须至少构建13个不同的rustc版本，至少。虽然这肯定比52个版本更好，但它仍然需要完全不合理的时间。相比之下，在从C编译器开始的C ++ 98（写入GCC-RS的版本的版本中，使用Rust编译器，序列很简单：</p><p>    In the gcc-rs case, there are 2 bootstrap steps. In the mrustc-rustc case, there are 15 bootstrap steps. A compiler written in C++11, 14, 17, or 20 would have 3 steps (gcc 4, gcc 10, target) and a compiler written in rust that targets mrustc would have 4 (gcc 4, gcc 10, mrustc, target). All of these are significantly less than 15, though 15 is an improvement from a potentially unbounded chain, with at least 53 steps. Additionally, gcc is much less expensive, build-timewise, as rustc is. On my system, rustc takes approximately 6 ½ hours to build 2 stages. With — enable-bootstrap (which is optional for gcc, and can be ignored when doing a manual bootstrap), this time is a mere 2 ¼ hours (40 minutes with — disable-bootstrap). gcc 4 is also significantly smaller and cheaper to build, taking only 40 minutes with — enable-bootstrap (after patching it to build on modern linux with gcc 10).</p><p>    在GCC-RS案例中，有2个引导步骤。在MRESTC-RUSTC案例中，有15个引导步骤。在C ++ 11,14,17或20中编写的编译器将有3个步骤（GCC 4，GCC 10，目标），并以RUST编写的编译器，目标MRESTC将具有4（GCC 4，GCC 10，MRESTC，TARGED ）。所有这些都明显小于15，但是15的潜在未绑定的链条改善，至少有53步。此外，作为RustC，GCC昂贵昂贵，构建时昂贵。在我的系统上，Rustc大约需要6个半小时来构建2个阶段。具有 - 启用-obotstrap（对于GCC是可选的，并且可以在执行手动引导时忽略），此时间仅为2¼小时（与禁用 -  bootstrap有40分钟）。 GCC 4的构建也明显较小，更便宜，只需40分钟 -  Enable-Bootstrap（在使用GCC 10时修补现代Linux之后）。 </p><p> Further, mrustc is only capable of targeting x86. Performing this reduction is thus impossible on riscv or aarch64, and for bootstrapping on these platforms, one would have to build every single version of rustc.</p><p>此外，MRESTC仅能够靶向X86。因此，在RISCV或AARCH64上执行此减少，并且用于对这些平台进行启动，必须​​建立每个版本的RUSTC。</p><p> Additionally, even when safety/security verification is not necessary, cross-compilation can introduce unnecessary builds of rustc (which can take minutes, to several hours, to days). For example, when building a linux environment following similar instructions to  Linux From Scratch, to cross compile rustc would involve building it in each stage (pre-tools, tools, and chroot). Having a compiler that is simple to bootstrap would allow someone building such a system to build the rust compiler as late as possible, a lot later than cross-compilation would allow. This issue has been present when building rustc for  iglunix, a self-hosted linux distribution that does not contain any GNU components.</p><p> 此外，即使在不需要安全/安全验证时，交叉编译也可以引入不必要的RUSTC（可能需要几分钟，到几个小时）。例如，在从头开始的Linux类似指令后构建Linux环境时，交叉编译RustC将涉及在每个阶段（工具，工具和Chroot）构建它。具有易于引导的编译器将允许某人构建这样的系统，尽可能迟到构建生锈编译器，而不是交叉编译会允许。在为IGLUNIX构建RustC时，此问题出现了，这是一个不包含任何GNU组件的自托管Linux发行版。</p><p>  One reason for having multiple implementations is to help prompt a specification for the language. It is argued that miri does that job already, however, it is not sufficient for this purpose, for three major reasons:</p><p>  具有多种实现的一个原因是帮助提示语言的规范。有人认为，Miri已经这样做了，但是，这是为了这个目的而不是足够的，因为这三个主要原因是：</p><p> Miri only performs dynamic analysis of programs. It can only check code paths that are evaluated (and not all possible code paths and all possible cases). By extension, you can only check conditionally-compiled code you are capable of building for and running. You can’t check code that is enabled on windows without a windows machine (or virtual machine).</p><p> Miri只执行程序的动态分析。它只能检查评估的代码路径（而不是所有可能的代码路径和所有可能的情况）。通过扩展，您只能检查有条件编译的代码，您能够为其构建和运行。您无法在没有Windows计算机（或虚拟机）的情况下检查在Windows上启用的代码。</p><p> Further, miri doesn’t really help specify it, as the rules it follows are in contention and, with limited exceptions, such as the Stacked Borrows aliasing model and the atomic memory model (the latter due to the fact that rust delegates to the C++ language), cannot be considered in the theoretical, like a well written prose specification can.</p><p> 此外，Miri并没有真正有助于指定它，因为它遵循的规则是争用，并且具有有限的例外，例如堆叠的借助别名模型和原子内存模型（由于生锈代表到C ++而导致的原子内存模型）语言），不能在理论上考虑，如书面散文规范。</p><p> Miri also cannot check code that makes use of inline assembly or FFI calls, which may be necessary in making the specific code either have defined (or undefined) behaviour. Thus miri cannot confirm for all rust code whether or not that code has defined behaviour, even once all the rules are firmly defined.</p><p> MIRI也无法检查使用内联组件或FFI调用的代码，这可能是在使特定代码中有定义（或未确定）行为的情况。因此，Miri无法确认所有生锈代码是否具有定义行为，即使所有规则都牢固定义。</p><p> The  ferrocene project is also helpful in specifying the language, however I think that having the experience of multiple implementers in the design of that specification would be further advantageous, than just those working on the rustc frontend and those of that project.</p><p> Ferrocene项目也有助于指定语言，但我认为拥有多种实施者的经验，在设计该规范中的设计将是进一步的有利的，而不是那些在RustC前端和该项目的设计方面的那些。 </p><p>  While rustc_codegen_gcc does indeed solve many of the issues with rust that gcc-rs propports to solve, it does not provide all of the benefits that the latter may result in. Further, the bootstrapping problem is barely mitigated by the existence of mrustc, and miri is not useful in reasoning entirely about the behaviour of given rust code, the way a proper specification would be. Because of these reasons, among others unmentioned, I support gcc-rs and I hope I’ve convinced you to support it as well.</p><p>虽然RustC_CodeGEN_GCC确实解决了RUCTRY GCC-RS Propports来解决的许多问题，但它并没有提供后者可能导致的所有好处。此外，MRESTC的存在勉强减轻了自动启动问题，以及MIRI 在推理完全是关于给定的生锈代码的行为的推理是没有用的，正确规格的方式是。 由于这些原因，其中包括一个无情，我支持gcc-rs，我希望我能够确信你也支持它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://chorman64.medium.com/why-i-support-gcc-rs-dc69ebfffd60">https://chorman64.medium.com/why-i-support-gcc-rs-dc69ebfffd60</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/gcc/">#gcc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>