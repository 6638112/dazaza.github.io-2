<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TypeScript 4.1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TypeScript 4.1</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 18:11:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/065a3a9a06a786d7328a931d00589001.png"><img src="http://img2.diglog.com/img/2020/11/065a3a9a06a786d7328a931d00589001.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>如果您不熟悉TypeScript，那么它是一种通过在JavaScript上添加类型声明和注释的语法而构建的语言。 TypeScript编译器可以使用此语法对我们的代码进行类型检查，然后输出可在许多不同的运行时上运行的清晰可读的JavaScript。由于TypeScript具有跨编辑器的丰富编辑功能，因此静态类型检查可以在代码运行之前甚至保存文件之前告诉我们代码中的错误。但是，除了进行错误检查外，TypeScript还可以在某些您喜欢的编辑器中为TypeScript和JavaScript提供诸如完成，快速修复和重构之类的功能。实际上，如果您已经在使用Visual Studio或Visual Studio Code，则在编写JavaScript代码时可能已经在使用TypeScript！因此，如果您有兴趣了解更多信息，请访问我们的网站！</p><p>但是，如果您已经在项目中使用TypeScript，则可以通过NuGet获取它，也可以通过以下命令使用npm：</p><p>对于此版本，我们提供了一些令人兴奋的新功能，新的检查标志，编辑器效率更新和速度改进。让我们来看看4.1带来了什么！</p><p>TypeScript中的字符串文字类型使我们可以对需要一组特定字符串的函数和API进行建模。</p><p> function  setVerticalAlignment ( color:  &#34;top&#34; |  &#34;middle&#34; |  &#34;bottom&#34; )  {  // ... } setVerticalAlignment ( &#34;middel&#34; ) ; // ~~~~~~~~ // error: Argument of type &#39;&#34;middel&#34;&#39; is not assignable to // parameter of type &#39;&#34;top&#34; | &#34;middle&#34; | &#34;bottom&#34;&#39;.</p><p>我们还喜欢将字符串文字用作映射类型中的属性名称。从这个意义上讲，它们也可用作构建基块。</p><p> type  Options  =  {  [ K  in  &#34;noImplicitAny&#34; |  &#34;strictNullChecks&#34; |  &#34;strictFunctionTypes&#34; ]?:  boolean } ; // same as // type Options = { // noImplicitAny?: boolean, // strictNullChecks?: boolean, // strictFunctionTypes?: boolean // };</p><p>但是在另一个地方，字符串文字类型可以用作构建块：构建其他字符串文字类型。</p><p>这就是TypeScript 4.1带来模板文字字符串类型的原因。它具有与JavaScript中的模板文字字符串相同的语法，但用于类型位置。当将它与具体文字类型一起使用时，它将通过串联内容来产生新的字符串文字类型。</p><p> type  World  =  &#34;world&#34; ; type  Greeting  =  `hello   ${ World }` ; // same as // type Greeting = &#34;hello world&#34;;</p><p>当工会担任替代职位时会发生什么？它产生可以由每个联合成员表示的每个可能的字符串文字的集合。</p><p> type  Color  =  &#34;red&#34; |  &#34;blue&#34; ; type  Quantity  =  &#34;one&#34; |  &#34;two&#34; ; type  SeussFish  =  `  ${ Quantity |  Color } fish` ; // same as // type SeussFish = &#34;one fish&#34; | &#34;two fish&#34; // | &#34;red fish&#34; | &#34;blue fish&#34;;</p><p> This can be used beyond cute examples in release notes. For example, several libraries for UI components have a way to specify both vertical and horizontal alignment in their APIs, often with both at once using a single string like  &#34;bottom-right&#34;. Between vertically aligning with  &#34;top&#34;,  &#34;middle&#34;, and  &#34;bottom&#34;, and horizontally aligning with  &#34;left&#34;,  &#34;center&#34;, and  &#34;right&#34;, there are 9 possible strings where each of the former strings is connected with each of the latter strings using a dash.</p><p> type  VerticalAlignment  =  &#34;top&#34; |  &#34;middle&#34; |  &#34;bottom&#34; ; type  HorizontalAlignment  =  &#34;left&#34; |  &#34;center&#34; |  &#34;right&#34; ; // Takes // | &#34;top-left&#34; | &#34;top-center&#34; | &#34;top-right&#34; // | &#34;middle-left&#34; | &#34;middle-center&#34; | &#34;middle-right&#34; // | &#34;bottom-left&#34; | &#34;bottom-center&#34; | &#34;bottom-right&#34; declare  function  setAlignment ( value: `${ VerticalAlignment } -${ HorizontalAlignment }` ):   void ; setAlignment ( &#34;top-left&#34; ) ;  // works! setAlignment ( &#34;top-middel&#34; ) ;  // error! setAlignment ( &#34;top-pot&#34; ) ;  // error! but good doughnuts if you&#39;re ever in Seattle</p><p>尽管有很多此类API的示例，但由于我们可以手动将其编写出来，因此这仍然只是一个玩具示例。实际上，对于9个字符串，这可能很好。但是当您需要大量字符串时，应考虑提前自动生成它们，以节省每次类型检查的工作（或仅使用字符串，这将更容易理解）。</p><p>一些实际价值来自动态创建新的字符串文字。例如，想象一个makeWatchedObject API，它接受一个对象并产生一个几乎相同的对象，但是具有一个新的on方法来检测属性的变化。</p><p> let  person  =  makeWatchedObject ( {  firstName:  &#34;Homer&#34; ,  age:  42 ,  // give-or-take  location:  &#34;Springfield&#34; , } ) ; person . on ( &#34;firstNameChanged&#34; ,  ( )  =&gt;  {  console . log ( `firstName was changed!` ) ; } ) ;</p><p> Notice that  on listens on the event  &#34;firstNameChanged&#34;, not just  &#34;firstName&#34;. How would we type this?</p><p> type  PropEventSource &lt; T &gt;  =  {  on ( eventName: `${ string &amp;  keyof  T } Changed` ,  callback:  ( )  =&gt;   void ):   void ; } ; /// Create a &#34;watched object&#34; with an &#39;on&#39; method /// so that you can watch for changes to properties. declare  function  makeWatchedObject &lt; T &gt; ( obj:  T ):  T &amp;  PropEventSource &lt; T &gt; ;</p><p>我们还可以对模板文字类型做一些特殊的事情：我们可以从替换位置推断出来。我们可以使最后一个示例通用，以便从eventName字符串的各个部分进行推断，以找出关联的属性。</p><p> type  PropEventSource &lt; T &gt;  =  {  on &lt; K  extends  string &amp;  keyof  T &gt;  ( eventName: `${ K } Changed` ,  callback:  ( newValue:  T [ K ] )  =&gt;   void  ):   void ; } ; declare  function  makeWatchedObject &lt; T &gt; ( obj:  T ):  T &amp;  PropEventSource &lt; T &gt; ; let  person  =  makeWatchedObject ( {  firstName:  &#34;Homer&#34; ,  age:  42 ,  location:  &#34;Springfield&#34; , } ) ; // works! &#39;newName&#39; is typed as &#39;string&#39; person . on ( &#34;firstNameChanged&#34; ,  newName  =&gt;  {  // &#39;newName&#39; has the type of &#39;firstName&#39;  console . log ( `new name is   ${newName . toUpperCase ( ) }` ) ; } ) ; // works! &#39;newAge&#39; is typed as &#39;number&#39; person . on ( &#34;ageChanged&#34; ,  newAge  =&gt;  {  if  ( newAge  &lt;  0 )  {  console . log ( &#34;warning! negative age&#34; ) ;  } } )</p><p> Here we made  on into a generic method. When a user calls with the string  &#34;firstNameChanged&#39;, TypeScript will try to infer the right type for  K. To do that, it will match  K against the content prior to  &#34;Changed&#34; and infer the string  &#34;firstName&#34;. Once TypeScript figures that out, the  on method can fetch the type of  firstName on the original object, which is  string in this case. Similarly, when we call with  &#34;ageChanged&#34;, it finds the type for the property  age which is  number).</p><p>推理可以以不同的方式组合，通常是对字符串进行解构，并以不同的方式对其进行重构。实际上，为了帮助修改这些字符串文字类型，我们添加了一些新的实用程序类型别名，用于修改字母中的大小写（即转换为小写和大写字符）。</p><p> type  EnthusiasticGreeting &lt; T  extends  string &gt;  = `${ Uppercase &lt; T &gt; }` type  HELLO  =  EnthusiasticGreeting &lt; &#34;hello&#34; &gt; ; // same as // type HELLO = &#34;HELLO&#34;;</p><p>新的类型别名为大写，小写，大写和大写。前两个转换字符串中的每个字符，后两个仅转换字符串中的第一个字符。</p><p>就像刷新一样，映射类型可以基于任意键创建新的对象类型</p><p> type  Options  =  {  [ K  in  &#34;noImplicitAny&#34; |  &#34;strictNullChecks&#34; |  &#34;strictFunctionTypes&#34; ]?:  boolean } ; // same as // type Options = { // noImplicitAny?: boolean, // strictNullChecks?: boolean, // strictFunctionTypes?: boolean // };</p><p>  /// &#39;Partial&lt;T&gt;&#39; is the same as &#39;T&#39;, but with each property marked optional. type  Partial &lt; T &gt;  =  {  [ K  in  keyof  T ]?:  T [ K ] } ;</p><p>到目前为止，映射类型只能使用您提供的键来产生新的对象类型。但是，很多时候您希望能够根据输入来创建新键或过滤掉键。</p><p>因此，TypeScript 4.1允许您使用新的as子句重新映射映射类型中的键。</p><p> type  MappedTypeWithNewKeys &lt; T &gt;  =  {  [ K  in  keyof  T  as  NewKeyType ]:  T [ K ]  // ^^^^^^^^^^^^^  // This is the new syntax! }</p><p>使用这个新的as子句，您可以利用模板文字类型之类的功能轻松地基于旧名称创建属性名称。</p><p> type  Getters &lt; T &gt;  =  {  [ K  in  keyof  T  as  `get  ${ Capitalize &lt; string &amp;  K &gt; }` ]:  ( )  =&gt;  T [ K ] } ; interface  Person  {  name:  string ;  age:  number ;  location:  string ; } type  LazyPerson  =  Getters &lt; Person &gt; ;</p><p>您甚至可以通过从不产生密钥来过滤掉密钥。这意味着在某些情况下，您不必使用额外的Omit帮助程序类型。</p><p> // Remove the &#39;kind&#39; property type  RemoveKindField &lt; T &gt;  =  {  [ K  in  keyof  T  as  Exclude &lt; K ,  &#34;kind&#34; &gt; ]:  T [ K ] } ; interface  Circle  {  kind:  &#34;circle&#34; ;  radius:  number ; } type  KindlessCircle  =  RemoveKindField &lt; Circle &gt; ; // same as // type KindlessCircle = { // radius: number; // };</p><p>在JavaScript中，常见的功能是可以扁平化并建立任意级别的容器类型。例如，考虑Promise实例上的.then（）方法。 .then（...）解开每个诺言，直到找到一个不像“承诺”那样的值，然后将该值传递给回调。数组上还有一个相对较新的flat方法，可以深入了解要展平的深度。</p><p>出于所有实际意图和目的，在TypeScript的类型系统中无法表达这一点。尽管有一些破解方法可以实现，但最终这些类型看起来非常不合理。</p><p>这就是为什么TypeScript 4.1减轻了对条件类型的一些限制-以便他们可以对这些模式进行建模。在TypeScript 4.1中，条件类型现在可以立即在其分支中引用自身，从而更容易编写递归类型别名。</p><p>例如，如果我们想编写一个类型来获取嵌套数组的元素类型，则可以编写以下deepFlatten类型。</p><p> type  ElementType &lt; T &gt;  =  T  extends  ReadonlyArray &lt; infer  U &gt; ?  ElementType &lt; U &gt; :  T ; function  deepFlatten &lt; T  extends  readonly  unknown [ ] &gt; ( x:  T ):  ElementType &lt; T &gt; [ ]  {  throw  &#34;not implemented&#34; ; } // All of these return the type &#39;number[]&#39;: deepFlatten ( [ 1 ,  2 ,  3 ] ) ; deepFlatten ( [ [ 1 ] ,  [ 2 ,  3 ] ] ) ; deepFlatten ( [ [ 1 ] ,  [ [ 2 ] ] ,  [ [ [ 3 ] ] ] ] ) ;</p><p>  type  Awaited &lt; T &gt;  =  T  extends  PromiseLike &lt; infer  U &gt; ?  Awaited &lt; U &gt; :  T ; /// Like `promise.then(...)`, but more accurate in types. declare  function  customThen &lt; T ,  U &gt; (  p:  Promise &lt; T &gt; ,  onFulfilled:  ( value:  Awaited &lt; T &gt; )  =&gt;  U ):  Promise &lt; Awaited &lt; U &gt; &gt; ;</p><p>请记住，尽管这些递归类型功能强大，但应负责任地谨慎使用它们。</p><p>首先，这些类型可以完成很多工作，这意味着它们可以增加类型检查时间。尝试以Collat​​z猜想或斐波那契数列为模型建模可能很有趣，但不要将其放在npm的.d.ts文件中。</p><p>但是，除了计算量大之外，这些类型还可能在足够复杂的输入上达到内部递归深度限制。当达到该递归限制时，将导致编译时错误。通常，最好不要使用这些类型，而要写一些在更实际的示例中失败的东西。</p><p>TypeScript具有称为索引签名的功能。这些签名是一种向类型系统发出信号的信号，用户可以访问任意命名的属性。</p><p> interface  Options  {  path:  string ;  permissions:  number ;  // Extra properties are caught by this index signature.  [ propName:  string ]:  string |  number ; } function  checkOptions ( opts:  Options )  {  opts . path  // string  opts . permissions  // number  // These are all allowed too!  // They have the type &#39;string | number&#39;.  opts . yadda . toString ( ) ;  opts [ &#34;foo bar baz&#34; ] . toString ( ) ;  opts [ Math . random ( ) ] . toString ( ) ; }</p><p>在上面的示例中，“选项”具有索引签名，该索引签名表示未列出的所有已访问属性都应具有字符串|数。这对于假定您知道自己在做什么的乐观代码来说通常很方便，但事实是JavaScript中的大多数值并不支持所有可能的属性名称。例如，大多数类型都不会像前面的示例那样具有Math.random（）创建的属性键的值。对于许多用户而言，这种行为是不希望的，并且感觉到它没有利用--strictNullChecks的完全严格检查。</p><p> That’s why TypeScript 4.1 ships with a new flag called  --noUncheckedIndexedAccess. Under this new mode, every property access (like  foo.bar) or indexed access (like  foo[&#34;bar&#34;]) is considered potentially undefined. That means that in our last example,  opts.yadda will have the type  string | number | undefined as opposed to just  string | number. If you need to access that property, you’ll either have to check for its existence first or use a non-null assertion operator (the postfix  ! character).</p><p> // Checking if it&#39;s really there first. if  ( opts . yadda )  {  console . log ( opts . yadda . toString ( ) ) ; } // Basically saying &#34;trust me I know what I&#39;m doing&#34; // with the &#39;!&#39; non-null assertion operator. opts . yadda! . toString ( ) ;</p><p>使用--noUncheckedIndexedAccess的一个结果是，即使在边界检查循环中，也更严格地检查对数组的索引。</p><p> function  screamLines ( strs:  string [ ] )  {  // this will have issues  for  ( let  i  =  0 ;  i  &lt;  strs . length ;  i ++ )  {  console . log ( strs [ i ] . toUpperCase ( ) ) ;  // ~~~~~~~  // error! Object is possibly &#39;undefined&#39;.  } }</p><p>如果不需要索引，则可以使用for–循环或forEach调用来遍历各个元素。</p><p> function  screamLines ( strs:  string [ ] )  {  // this works fine  for  ( const  str  of  strs )  {  console . log ( str . toUpperCase ( ) ) ;  }  // this works fine  strs . forEach ( str  =&gt;  {  console . log ( str . toUpperCase ( ) ) ;  } ) ; }</p><p>这个标志对于捕获越界错误可能很方便，但是对于很多代码来说可能很嘈杂，因此--strict标志不会自动启用它。但是，如果您对这个功能很感兴趣，则可以随意尝试并确定它是否适合您团队的代码库！</p><p>使用路径映射是相当普遍的-通常是为了更好地导入，通常是为了模拟Monorepo链接行为。</p><p>不幸的是，指定启用路径映射的路径还需要指定一个称为baseUrl的选项，该选项也允许相对于baseUrl到达裸指定符路径。这通常还导致自动导入使用较差的路径。</p><p>在TypeScript 4.1中，可以在没有baseUrl的情况下使用path选项。这有助于避免其中一些问题。</p><p>以前，如果您要启动一个选中的JavaScript项目，则必须同时设置allowJs和checkJs。这在体验中有点烦人，因此默认情况下，checkJs隐含了allowJs。</p><p>TypeScript 4.1通过jsx编译器选项的两个新选项支持React 17即将推出的jsx和jsxs工厂功能：</p><p>这些选项分别用于生产和开发编译。通常，一个选项可以从另一个扩展。例如，用于生产构建的tsconfig.json可能如下所示：</p><p> // ./src/tsconfig.json {  &#34;compilerOptions&#34;:  {  &#34;module&#34;:  &#34;esnext&#34; ,  &#34;target&#34;:  &#34;es2015&#34; ,  &#34;jsx&#34;:  &#34;react-jsx&#34; ,  &#34;strict&#34;:  true  } ,  &#34;include&#34;:  [  &#34;./**/*&#34;  ] }</p><p>JSDoc标记@see标记现在在TypeScript和JavaScript的编辑器中有更好的支持。这使您可以在标记后的虚线名称中使用定位定义之类的功能。例如，在下面的示例中，仅对JSDoc注释中的first或C进行定义即可：</p><p> //  @filename: first.ts export  class  C  {  } //  @filename: main.ts import *  as  first  from  &#39;./first&#39; ; /**  *  @see first.C  */ function  related ( )  {  }</p><p>lib.d.ts可能具有一组更改的API，这可能部分是由于DOM类型是如何自动生成的。一项特定更改是，从ES2016中删除了Reflect.enumerate。</p><p>标记为抽象的成员不能再标记为异步。此处的解决方法是删除async关键字，因为调用方只关心返回类型。</p><p>  Previously, for an expression like  foo &amp;&amp; somethingElse, the type of  foo was  any or  unknown, the type of the whole that expression would be the type of  somethingElse.</p><p>  declare  let  foo:  unknown ; declare  let  somethingElse:  {  someProp:  string  } ; let  x  =  foo  &amp;&amp;  somethingElse ;</p><p> However, in TypeScript 4.1, we are more careful about how we determine this type. Since nothing is known about the type on the left side of the  &amp;&amp;, we propagate  any and  unknown outward instead of the type on the right side.</p><p>我们看到的最常见的模式通常是在检查与布尔值的兼容性时，尤其是在谓词函数中。</p><p> function  isThing ( x:  any ):  boolean  {  return  x  &amp;&amp;  typeof  x  ===  &#39;object&#39;  &amp;&amp;  x . blah  ===  &#39;foo&#39; ; }</p><p> Often the appropriate fix is to switch from  foo &amp;&amp; someExpression to  !!foo &amp;&amp; someExpression.</p><p>     resolve() ~~~~~~~~~error TS2554: Expected 1 arguments, but got 0. An argument for &#39;value&#39; was not provided.</p><p>这是因为resolve不再具有可选参数，因此默认情况下现在必须为它传递一个值。通常，使用Promises会捕获合法错误。典型的解决方法是为其传递正确的参数，有时还要添加一个显式的类型参数。</p><p>  However, sometimes  resolve() really does need to be called without an argument. In these cases, we can give  Promise an explicit  void generic type argument (i.e. write it out as  Promise&lt;void&gt;). This leverages new functionality in TypeScript 4.1 where a potentially- void trailing parameter can become optional.</p><p>在JavaScript中，对象传播（如{... foo}）不会对虚假值起作用。因此，在类似{... foo}的代码中，如果foo为null或未定义，则会跳过foo。</p><p>  interface  Person  {  name:  string ;  age:  number ;  location:  string ; } interface  Animal  {  name:  string ;  owner:  Person ; } function  copyOwner ( pet?:  Animal )  {  return  { ... ( pet  &amp;&amp;  pet . owner ) ,  otherStuff:  123  } } // We could also use optional chaining here: function  copyOwner ( pet?:  Animal )  {  return  { ... ( pet? . owner ) ,  otherStuff:  123  } }</p><p>在这里，如果定义了pet，则pet.owner的属性将散布在其中；否则，不会将任何属性散布到返回的对象中。</p><p>{x：数字} | {x：数字，名称：字符串，年龄：数字，位置：字符串}</p><p>这准确地模拟了操作的发生方式：如果定义了pet，Person的所有属性都将存在；其他</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/">https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034611.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ed4d9f6bb8a5a76b5af188414a92585d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034611.html">大规模采用打字稿的感悟</a></div><span class="my_story_list_date">2020-11-12 2:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034305.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c048e76e97f37c2c2721591fa63f0f86.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034305.html">F#5</a></div><span class="my_story_list_date">2020-11-11 1:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034217.html"><img src="http://img2.diglog.com/img/2020/11/thumb_84e9ef6db136f3fbdf494272e186a3fb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034217.html">使用Scala 3进行显式项推理</a></div><span class="my_story_list_date">2020-11-10 15:24</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033662.html"><img src="http://img2.diglog.com/img/2020/11/thumb_76fee038427af967d4a62ff40c6ab0a4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033662.html">为什么输入Erlang很难：标准Erlang</a></div><span class="my_story_list_date">2020-11-7 14:13</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>