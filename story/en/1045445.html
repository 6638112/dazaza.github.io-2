<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>动态类型系统甚至没有更简单 Dynamic type systems aren’t even simpler</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dynamic type systems aren’t even simpler<br/>动态类型系统甚至没有更简单 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-21 06:04:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/224804ad769abdd559c7f8dfbe53a170.jpg"><img src="http://img2.diglog.com/img/2021/1/224804ad769abdd559c7f8dfbe53a170.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Alexis King just published a great blog post titled  “No, dynamic type systems are not inherently more open”.</p><p>亚历克西斯·金（Alexis King）刚刚发表了一篇很棒的博客文章，标题为“不，动态类型系统本质上并不开放”。</p><p> That reminded me of the talk I gave last year at FOSDEM, titled  “Minimalism versus types”, where I advocated for static types from a slightly different angle. I tried to convince people that types in dynamically-typed programs are often more complicated than people realize. And often more complicated than in typical statically-typed languages.</p><p> 这让我想起了我去年在FOSDEM上发表的名为“极简主义与类型”的演讲，在该演讲中，我从稍微不同的角度主张静态类型。我试图说服人们，动态类型程序中的类型通常比人们意识到的要复杂。而且通常比典型的静态类型语言复杂。</p><p> People often say the opposite, that static type systems are more complicated, and dynamically-typed languages are simpler. At the surface level, this seems true: in a dynamic world you just go merrily declaring variables, assigning values and doing things with them, without ever having to write down any types, no matter how trivial or complex they are. Things can’t get any simpler in the typing department than “doing nothing”, right?</p><p> 人们经常说相反的话，静态类型系统更复杂，而动态类型语言则更简单。从表面上看，这似乎是对的：在动态世界中，您只是轻松地声明变量，分配值并使用它们进行处理，而不必写下任何类型，无论它们多么琐碎或复杂。在打字部门，事情比“什么都不做”要简单得多，对吧？</p><p> Well, types are nothing more than the shapes and allowed behaviors of your data. So it’s not like you don’t have shapes and behaviors in any program, regardless of the language… so, you have types, whether you write them or not. They are there, even in assembly language, even if at a conceptual level, as the sets of “valid values” your program can manipulate. And you have to think about them, and they have to make sense, and they have to do the right thing. So, in short, in a correct dynamically-typed program the types need to be just as correct as they are in a statically-typed one (or else you’ll get runtime errors).</p><p> 好吧，类型不过是数据的形状和允许的行为而已。因此，这并不意味着您在任何程序中都没有形状和行为，而与语言无关……因此，无论是否编写代码，都拥有类型。即使在汇编语言中，即使在概念上，它们也都存在，它们是程序可以操纵的“有效值”集合。您必须考虑它们，它们必须有意义，并且它们必须做正确的事情。因此，简而言之，在正确的动态类型程序中，类型必须与在静态类型中的类型一样正确（否则会出现运行时错误）。</p><p> In other words, the types are there, but you have to run the type checker  in your head. And you know what’s funny? When people don’t write down the types, they often end up with types that are often more complicated than the types from people who do write them. The complexity just goes under the radar, so it piles up.</p><p> 换句话说，类型在那里，但是您必须在头脑中运行类型检查器。您知道有趣的事吗？当人们不写下类型时，他们最终往往会得到比写它们的人更复杂的类型。复杂性只是在雷达之下，因此堆积如山。</p><p> One day you open that module which you haven’t touched in six months, and you see a function call where the third argument is  null. You need to remember what kinds of variables you can pass to that third argument, or read the whole source code to figure it out. You follow through the code to see all places that third argument is used and realize the accepted type of the third argument depends on what you give to the second argument. Congratulations, you’re dealing with a  dependent type, which means you’ve just surpassed Haskell in terms of type system complexity. Compilers that deal with this kind of type system are so complex they are effectively proof assistants (and are at the  forefront of  programming language research), and here you are dealing with those data types with your brain (and your faith in your ability to come up with sufficient tests) alone.</p><p> 有一天，您打开了六个月没有接触过的模块，并且看到了一个函数调用，其中第三个参数为空。您需要记住可以传递给第三个参数的变量类型，或者阅读整个源代码以弄清楚该变量。您可以通过代码来查看使用第三个参数的所有位置，并认识到第三个参数的可接受类型取决于您赋予第二个参数的内容。恭喜，您正在处理从属类型，这意味着您在类型系统复杂性方面已经超过了Haskell。处理这种类型系统的编译器是如此复杂，它们是有效的证明助手（并且处于编程语言研究的最前沿），在这里您正在用脑来处理这些数据类型（以及对自己的能力的信念）进行足够的测试）。</p><p> Given that there is no mechanical type checker to prescribe what is expressible, and that the dynamic runtime will accept anything as long as the program doesn’t crash, when doing typechecking in your head you essentially have the world’s most powerful and complicated type checker at your disposal. And once you start making use of this power, you end up dealing with the world’s most complicated type system.</p><p> 鉴于没有机械类型检查器来规定可表达的内容，并且只要程序不会崩溃，动态运行时就可以接受任何内容，因此当您脑海中进行类型检查时，您实际上拥有世界上功能最强大，最复杂的类型检查器您的处置。一旦开始利用这种能力，您就不得不面对世界上最复杂的类型系统。 </p><p> And when you give people expressive power, they use it. In my experience, people go wild constructing complicated structures in dynamic languages that they normally wouldn’t in static languages. It’s not that static languages are less powerful (Turing equivalence, blah blah), but they make the things you’re doing more obvious to you (Alexis’s post has  some great examples). In a dynamically-typed program people are all to keen to make variables and data structures perform double or triple duty ( “this is a X but also a Y under circumstances Z”), but when they have to write down what they’re doing as types, it’s like a little conscience check, and they think twice before creating a more complex type for something that could be described in a simpler way (simple example: they’ll probably make two plain functions instead of making one function that takes a string argument that changes the behavior of other arguments). Static types nudge you towards simpler, less “clever” solutions (and we all know what kind of solution is more maintainable in the long run).</p><p>当您赋予人们表达能力时，他们就会使用它。以我的经验，人们疯狂地使用动态语言来构造复杂的结构，而通常不会使用静态语言来构造。并不是说静态语言的功能不那么强大（等价，等等），而是它们使您正在做的事情对您更加明显（Alexis的帖子中有一些很好的例子）。在动态类型的程序中，人们都渴望使变量和数据结构执行双重或三重职责（“在Z情况下，这是X但在Y时也是Y”），但是当他们不得不写下正在做的事情时作为类型，这就像进行一点良心检查一样，在为可以用更简单方式描述的事物创建更复杂的类型之前，他们三思而后行（简单的示例：他们可能会制作两个简单的函数，而不是制作一个使用更改其他参数行为的字符串参数）。静态类型会向您推销更简单，更少“聪明”的解决方案（从长远来看，我们都知道哪种解决方案更可维护）。</p><p> But okay, let’s assume we avoid “clever” and pick the same solutions in either. Writing the same program in a static or a dynamic language to process the same data in the same way, you will end up with  values of roughly the same types in both. The fact that the  variables have static types or not does not change that.</p><p> 但是，好的，我们假设我们避免使用“聪明”方法，并在其中任一方法中选择相同的解决方案。用静态或动态语言编写相同的程序以相同的方式处理相同的数据，您最终将在两者中得到大致相同类型的值。变量是否具有静态类型这一事实不会改变这一点。</p><p> “But in a dynamic language I don’t have to write the types! It’s less work!”</p><p> “但是使用动态语言，我不必编写类型！少工作了！”</p><p> “Not having to” write types but having to think about them anyway is like doing math “not having to” write anything down and doing all calculations in your head. How is it an advantage to  not use pen and paper to track down your train of thought as you do a complex calculation, and instead be restricted to do it only in your head? And how is an advantage to  not have a mechanical tool — like a calculator, which can actually compute the things you wrote down — to check whether what you wrote with pen and paper makes sense?</p><p> “不必”写类型，但是无论如何都要思考它们，就像在做数学“不必”写下任何东西，然后在脑海中进行所有计算一样。在进行复杂的计算时不使用笔和纸来追踪思路有什么好处，而是被限制为仅在脑海中进行计算？如果没有机械工具（例如可以实际计算您所写下的东西的计算器）来检查用笔和纸写的东西是否有意义，这又有什么优势呢？</p><p> I’m lazy, so I hate doing any math in my head. I’ll take writing things down and have a machine check it for me any day of the week. Why wouldn’t I want the same when programming? That’s what computers are for, right? To save us from computing things in our head. So I’ll write my types, and have the compiler check whether they make sense, thank you very much. It’s less work.</p><p> 我很懒，所以我讨厌脑子里做任何数学运算。我会记下来，并在一周中的任何一天都有机器为我检查。为什么在编程时我不想要相同的东西？那就是计算机的用途，对不对？使我们免于计算大脑中的事物。因此，我将编写我的类型，并让编译器检查它们是否有意义，非常感谢。减少了工作量。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hisham.hm/2020/01/20/dynamic-type-systems-arent-even-simpler/">https://hisham.hm/2020/01/20/dynamic-type-systems-arent-even-simpler/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>