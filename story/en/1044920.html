<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>异或链接列表 XOR Linked List</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">XOR Linked List<br/>异或链接列表 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-19 01:58:28</div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  An  XOR linked list is a type of  data structure used in  computer programming. It takes advantage of the  bitwise XOR operation to decrease storage requirements for  doubly linked lists.</p><p>跳转至导航跳转至搜索异或链接列表是计算机编程中使用的一种数据结构。它利用按位XOR运算来减少双向链表的存储要求。</p><p>   An ordinary doubly linked list stores addresses of the previous and next list items in each list node, requiring two address fields:</p><p>   普通的双向链接列表在每个列表节点中存储上一个和下一个列表项的地址，需要两个地址字段：</p><p> ... A B C D E ... –&gt; next –&gt; next –&gt; next –&gt; &lt;– prev &lt;– prev &lt;– prev &lt;–</p><p> ... A B C D E ... –＆gt;下一个–＆gt;下一个–＆gt;下一个–＆gt; ＆lt; –上一个＆lt; –上一个＆lt; –上一个＆lt; –</p><p> An XOR linked list compresses the same information into  one address field by storing the bitwise XOR (here denoted by ⊕) of the address for  previous and the address for  next in one field:</p><p> 一个XOR链表通过在一个字段中存储前一个地址和下一个地址的按位XOR（此处用denoted表示）将相同的信息压缩到一个地址字段中：</p><p> ... A B C D E ... &lt;–&gt; A⊕C &lt;-&gt; B⊕D &lt;-&gt; C⊕E &lt;-&gt;</p><p> ... A B C D E ...-- A⊕C- B⊕D- C⊕E-</p><p>   When traversing the list from left to right: supposing the cursor is at C, the previous item, B, may be XORed with the value in the link field (B⊕D). The address for D will then be obtained and list traversal may resume. The same pattern applies in the other direction.</p><p>   当从左向右遍历列表时：假设光标在C处，则前一项B可以与链接字段（B⊕D）中的值进行XOR运算。然后将获得D的地址，并且可以继续遍历列表。相同的方向适用于另一个方向。</p><p> i.e. addr(D) = link(C) ⊕ addr(B) where link(C) = addr(B)⊕addr(D) so addr(D) = addr(B)⊕addr(D) ⊕ addr(B) addr(D) = addr(B)⊕addr(B) ⊕ addr(D) since X⊕X = 0 =&gt; addr(D) = 0 ⊕ addr(D) since X⊕0 = x =&gt; addr(D) = addr(D) The XOR operation cancels addr(B) appearing twice in the equation and all we are left with is the addr(D).</p><p> 即addr（D）=链接（C）⊕addr（B）其中，link（C）= addr（B）⊕addr（D），所以addr（D）= addr（B）⊕addr（D）⊕addr（B）由于X = X = 0 =>，所以addr（D）= addr（B）→addr（B）→addr（D）。由于X = 0 = x =>，所以addr（D）= 0 0 addr（D）。 addr（D）= addr（D）XOR操作取消等式中出现两次的addr（B），剩下的就是addr（D）。 </p><p> To start traversing the list in either direction from some point, the address of two consecutive items is required. If the addresses of the two consecutive items are reversed, list traversal will occur in the opposite direction.  [1]</p><p>要从某个点开始沿任一方向遍历列表，需要两个连续项的地址。如果两个连续项的地址相反，则列表遍历将以相反的方向进行。 [1]</p><p>    The R2 register always contains the XOR of the address of current item C with the address of the predecessor item P: C⊕P. The Link fields in the records contain the XOR of the left and right successor addresses, say L⊕R. XOR of R2 (C⊕P) with the current link field (L⊕R) yields C⊕P⊕L⊕R.</p><p>    R2寄存器始终包含当前项C的地址与先前项P：C⊕P的地址的异或。记录中的链接字段包含左右后继地址的XOR，例如L⊕R。 R2（C⊕P）与当前链接字段（L⊕R）的XOR得出C⊕P⊕L⊕R。</p><p> If the predecessor was L, the P(=L) and L  cancel out leaving C⊕R.</p><p> 如果前任是L，则P（= L）和L抵消，剩下C⊕R。</p><p> If the predecessor had been R, the P(=R) and R cancel, leaving C⊕L.</p><p> 如果前任是R，则P（= R）和R抵消，剩下C⊕L。</p><p> In each case, the result is the XOR of the current address with the next address. XOR of this with the current address in R1 leaves the next address. R2 is left with the requisite XOR pair of the (now) current address and the predecessor.</p><p> 在每种情况下，结果都是当前地址与下一个地址的XOR。将其与R1中的当前地址进行XOR运算将保留下一个地址。 R2保留了（现在）当前地址和先前地址的必要XOR对。</p><p>  Two XOR operations suffice to do the traversal from one item to the next, the same instructions sufficing in both cases. Consider a list with items  {…B C D…} and with R1 and R2 being  registers containing, respectively, the address of the current (say C) list item and a work register containing the XOR of the current address with the previous address (say C⊕D). Cast as  System/360 instructions:</p><p>  两个XOR操作足以完成从一项到下一项的遍历，在两种情况下，相同的指令就足够了。考虑一个列表，其中包含项{…BCD…}，并且R1和R2是分别包含当前（例如C）列表项的地址的寄存器和包含当前地址与先前地址（例如C）的XOR的工作寄存器。 ⊕D）。投射为System / 360指令：</p><p> X R2,Link R2 &lt;- C⊕D ⊕ B⊕D (i.e. B⊕C, &#34;Link&#34; being the link field in the current record, containing B⊕D)XR R1,R2 R1 &lt;- C ⊕ B⊕C (i.e. B, voilà: the next record)</p><p> X R2，链接R2 ＜-C⊕D⊕B⊕D（即B⊕C，＆＃34；链接＆＃34；是当前记录中的链接字段，包含B⊕D）。 -C⊕B⊕C（即B，下一个记录） </p><p> End of list is signified by imagining a list item at address zero placed adjacent to an end point, as in  {0 A B C…}. The link field at A would be 0⊕B. An additional instruction is needed in the above sequence after the two XOR operations to detect a zero result in developing the address of the current item,</p><p>通过想象一个位于{0 A B C…}中与端点相邻的地址零处的列表项来表示列表的末尾。 A处的链接字段为0⊕B。在两次异或运算之后，需要按上述顺序添加一条指令来检测零结果，从而开发出当前项目的地址，</p><p> A list end point can be made reflective by making the link pointer be zero. A zero pointer is a  mirror. (The XOR of the left and right neighbor addresses, being the same, is zero.)</p><p> 通过使链接指针为零，可以使列表端点具有反射性。零指针是一面镜子。 （左右邻居地址的XOR相同，为零。）</p><p>  The price for the decrease in memory usage is an increase in code complexity, making maintenance more expensive;</p><p>  减少内存使用量的代价是代码复杂度的增加，从而使维护更加昂贵；</p><p> Most  garbage collection schemes do not work with data structures that do not contain literal  pointers;</p><p> 大多数垃圾回收方案不适用于不包含文字指针的数据结构。</p><p> Not all languages support  type conversion between pointers and integers, XOR on pointers is not defined in some contexts;</p><p> 并非所有的语言都支持指针和整数之间的类型转换，在某些上下文中未定义对指针的XOR。</p><p> While traversing the list the address of the previously accessed node is needed to calculate the next node&#39;s address and the pointers will be unreadable if one isn&#39;t traversing the list—for example, if the pointer to a list item was contained in another data structure;</p><p> 在遍历列表时，需要使用先前访问的节点的地址来计算下一个节点的地址，并且如果不遍历该列表（例如，如果指向列表项的指针），则指针将不可读包含在另一个数据结构中；</p><p> XOR linked lists do not provide some of the important advantages of doubly linked lists, such as the ability to delete a node from the list knowing only its address or the ability to insert a new node before or after an existing node when knowing only the address of the existing node.</p><p> XOR链表没有提供双链表的一些重要优点，例如仅知道地址就可以从列表中删除节点的能力，或者仅知道地址就可以在现有节点之前或之后插入新节点的能力。现有节点的 </p><p> Computer systems have increasingly cheap and plentiful memory, therefore storage overhead is not generally an overriding issue outside specialized  embedded systems. Where it is still desirable to reduce the overhead of a linked list,  unrolling provides a more practical approach (as well as other advantages, such as increasing cache performance and speeding  random access).</p><p>计算机系统具有越来越便宜和充足的内存，因此存储开销通常不是专用嵌入式系统之外的首要问题。如果仍然需要减少链接列表的开销，则展开将提供一种更实用的方法（以及其他优势，例如提高缓存性能和加快随机访问的速度）。</p><p>  The underlying principle of the XOR linked list can be applied to any reversible binary operation. Replacing XOR by addition or subtraction gives slightly different, but largely equivalent, formulations:</p><p>  XOR链表的基本原理可以应用于任何可逆的二进制操作。通过加法或减法替换XOR得出的公式略有不同，但基本相同：</p><p>  ... A B C D E ... &lt;–&gt; A+C &lt;-&gt; B+D &lt;-&gt; C+E &lt;-&gt;</p><p>  ... A B C D E ...-- A + C- B + D- C + E-</p><p> This kind of list has exactly the same properties as the XOR linked list, except that a zero link field is not a &#34;mirror&#34;. The address of the next node in the list is given by subtracting the previous node&#39;s address from the current node&#39;s link field.</p><p> 除了零链接字段不是＆＃34; mirror＆＃34;之外，这种列表具有与XOR链接列表完全相同的属性。通过从当前节点的链接字段中减去前一个节点的地址，可以得出列表中下一个节点的地址。</p><p>  ... A B C D E ... &lt;–&gt; C-A &lt;-&gt; D-B &lt;-&gt; E-C &lt;-&gt;</p><p>  ... A B C D E ...-- C-A- D-B- E-C-</p><p> This kind of list differs from the standard &#34;traditional&#34; XOR linked list in that the instruction sequences needed to traverse the list forwards is different from the sequence needed to traverse the list in reverse. The address of the next node, going forwards, is given by  adding the link field to the previous node&#39;s address; the address of the preceding node is given by  subtracting the link field from the next node&#39;s address.</p><p> 这种列表与标准＆＃34;传统＆＃34;不同。 XOR链表的不同之处在于向前遍历该列表所需的指令序列与反向遍历该列表所需的序列不同。通过将链接字段添加到上一个节点的地址，可以得出下一个节点的地址（向前）。通过从下一个节点的地址中减去链接字段，可以得出前一个节点的地址。</p><p> The subtraction linked list is also special in that the entire list can be relocated in memory without needing any patching of pointer values, since adding a constant offset to each address in the list will not require any changes to the values stored in the link fields. (See also  serialization.) This is an advantage over both XOR linked lists and traditional linked lists.</p><p> 减法链接列表的特殊之处还在于，可以在不对指针值进行任何修补的情况下将整个列表重定位到内存中，因为向列表中的每个地址添加恒定偏移量将不需要对链接字段中存储的值进行任何更改。 （另请参见序列化。）与XOR链表和传统链表相比，这是一个优势。 </p><p>     ^    &#34;XOR Linked List - A Memory Efficient Doubly Linked List | Set 1 - GeeksforGeeks&#34;.  GeeksforGeeks. 2011-05-23 .</p><p>^＆＃34; XOR链接列表-内存有效的双重链接列表| 设置1-GeeksforGeeks＆＃34;。 极客。 2011-05-23。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/XOR_linked_list">https://en.wikipedia.org/wiki/XOR_linked_list</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/链接/">#链接</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linked/">#linked</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地址/">#地址</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>