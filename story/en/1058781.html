<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Postgres中的连接管理指南 Guide to Connection Management in Postgres</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Guide to Connection Management in Postgres<br/>Postgres中的连接管理指南 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-17 01:15:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/f2d4a39c9101739759fdbdb9520f06c4.jpg"><img src="http://img2.diglog.com/img/2021/4/f2d4a39c9101739759fdbdb9520f06c4.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Connection pooling and management is one of those things most people ignore far too long when it comes to their database. When starting out, you can easily get by without it. With 1 or 2 application servers spawning 5-10 connections, even the tiniest of Postgres servers can handle such. Even with our $35 a month   hobby plan on   Crunchy Bridge, we can push 5,000 transactions per second through which is quite a bit for &lt; 20 connections.</p><p>连接池和管理是大多数人在数据库中忽略了太久的东西之一。在开始时，您可以轻松地通过它。带有1或2个应用程序服务器5-10连接，即使是最小的Postgres服务器也可以处理。即使我们在嘎吱嘎吱的桥梁上为35美元的爱好计划，我们也可以每秒推出5,000次交易，这是一个非常有点＆lt; 20个连接。</p><p> As you grow into the hundreds, better connection management is a quick and easy win. Most think you only need a connection pooler at massive scale when you&#39;re scaling reads   beyond a single node, but the best time is far before that. Let&#39;s dig into the three variations of connection pooling and how to identify if you can benefit from a connection pooler and where.</p><p> 随着您的发展，更好的连接管理是一种快速而轻松的胜利。大多数人认为，当您＆＃39;重新缩放超出单个节点时，您只需要在大规模刻度上的连接池，但在此之前最佳时间。让＆＃39; s挖掘连接池的三种变体以及如何识别您是否可以从连接池和位置中受益。</p><p>  Most web frameworks these days support server multiple web requests at a time; they do this via multiple threads or workers. Each backend of your web server serving up a request may need a database connection. So if you have a single web server running, but have 2 x number of cores (say 4)   workers running, you&#39;ll have 8 backends at a time attempting to connect to your database.</p><p>  大多数Web框架这些天一次支持服务器多个Web请求;它们通过多个线程或工人来完成这件事。服务于请求的Web服务器的每个后端可能需要数据库连接。因此，如果您有一个单个Web服务器运行，但有2 x核心（例如4）运行的工作人员，您＆＃39; ll一次尝试连接到数据库8个后端。</p><p> Each new connection to your database is going to take some time to establish, often because of TLS negotiation. By connecting fresh each request, you may be spending 50ms connecting to your database to execute a 1ms query (lots of wasted time there). So the result is to tweak your database connection library to &#34;persist&#34; connections or maintain a pool of them. Each library differs a bit here, but regardless, having some standard pool of connections already open and connected from your application framework can help in overall performance per request.</p><p> 与数据库的每个新连接将花一些时间建立，通常是因为TLS协商。通过连接新的每个请求，您可能会花费50ms连接到数据库，以执行1ms查询（其中很多浪费时间）。因此，结果是将数据库连接库调整为＆＃34;持续＆＃34;连接或维持它们的池。每个图书馆都在这里有点不同，但无论如何，已经从应用程序框架中打开和连接的一些标准连接池可以帮助每个请求的整体性能。</p><p>   With the above application side pooling in place you may be fine with one or two web servers. But when you scale to 20 web servers, you may now have 200 connections open to your database. 99% of the time these connections are sitting there idle not doing anything. Those wasted connections have some extra overhead in coordination each time a query is executed. But worse yet, they sit and consume wasted memory, which is one of the most valuable resources for your database.</p><p>   使用上面的应用程序侧池到位，您可能很好地使用一个或两个Web服务器。但是，当您缩放到20个Web服务器时，您现在可以对数据库打开200个连接。 99％的这些连接坐在那里闲着没有做任何事情。每次执行查询时，这些浪费的连接都会在协调中具有一些额外的开销。但更糟糕的是，他们坐下来消耗浪费的内存，这是您数据库最有价值的资源之一。</p><p> A connection pooler that sits on a server near your database, or on the same server in front of your database can help on these idle transactions. A connection pooler like pgBouncer to your application looks exactly like Postgres. But sits  between Postgres and your database and does the heavy lifting of giving out connections as they&#39;re needed. So your application issues a request to get a connection, pgBouncer says sure here you go, but pgBouncer will not pass the connection to the actual Postgres database until you start to execute a query.</p><p> 一个连接池位于数据库附近的服务器上，或在数据库前面的同一服务器上可以帮助这些空闲事务。像PGBouncer一样的连接池看起来与Postgres完全一样。但坐在Postgres和您的数据库之间，并进行大量提升，以便为他们提供连接。因此，您的应用程序发出一个请求来获得连接，PGBouncer在这里肯定地说，但PGBouncer不会将连接与实际Postgres数据库传递，直到开始执行查询。</p><p> The best way to tell if you would benefit from pgBouncer is by checking for idle connections in your database. If you&#39;re in the high 10s or if you have more idle than active connections it can be a big benefit:</p><p> 判断您是否会受益于PGBouncer的最佳方式是通过检查数据库中的空闲连接。如果你＆＃39;在高10岁的时候，如果你比活动连接更怠速，那可能是一个大的好处： </p><p> SELECT count(*),         state  FROM pg_stat_activity  GROUP BY 2;  count |             state -------+-------------------------------      7 | active     69 | idle     26 | idle in transaction     11 | idle in transaction (aborted) (4 rows)</p><p>选择count（*），从pg_stat_activity group by 2的状态;数目|.国家------- + --------------------------- 7 |活跃69 |空闲26 |交易11 |闲置11 |交易中闲置（中止）（4行）</p><p>  Often when people hear connection pooling they think: scaling out your reads across multiple databases. Here you have some routing that will send reads to a particular read replica while writes continue to go to the primary. There are some Postgres tools that help with this (pgPooler), but they tend to come with a bit of expert usage required.</p><p>  通常，当人们听到连接池时，他们认为：跨多个数据库扩展读取。在这里，您有一些路由将向特定的读取副本发送读取，而写入继续转到主要。有一些Postgres工具有助于实现这一（PGPooler），但它们往往需要有一点专家使用。</p><p> Increasingly, this is being built into more and more frameworks. Django for example, doesn&#39;t have this turnkey but you can specify routing for various models in a pretty straightforward way. Rails has some libraries that help with routing via specific models.</p><p> 越来越多地建立越来越多的框架。 Django例如，没有这个交钥匙，但你可以以非常简单的方式指定各种型号的路由。 Rails有一些库通过特定模型帮助路由。</p><p>  Try to group reads by model as much as possible (this will keep more of the same data in hot memory).</p><p>  尝试按模型组读取读取（这将在热存储器中保持更多的数据）。</p><p>  In scaling your application the database is one area where there are often 10-15 basic steps you can take to get to a much larger scale. Connection pooling both in the application side and server side via pgBouncer are one such step you should always take for production applications.</p><p>  在缩放应用程序中，数据库是一个往往有10-15个基本步骤的一个区域，您可以获得更大的比例。通过PGBouncer在应用程序侧和服务器端中的连接池都是您应该始终占用生产应用的步骤。</p><p> We&#39;re excited to support built-in connection pooling with pgBouncer on Crunchy Bridge, as a fully managed database as a service. We want to take care of all the headache of maintaining a database for you. And within Crunchy Postgres, whether you are running on bare metal VMs or leveraging our Kubernetes Operator, pgBouncer is available for you there as well. In short, we use pgBouncer and you should too.</p><p> 我们＆＃39;重新兴奋地支持用PGBouncer上的Crunchy Bridge上的内置连接汇集，作为作为服务的完全托管的数据库。我们希望为您维护数据库的所有头痛。在脆弱的Postgres中，无论您是在裸机VM上运行还是利用我们的Kubernetes运算符，也可以在您那里为您提供PGBouncer。简而言之，我们使用pgbouncer，你也应该。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.crunchydata.com/blog/your-guide-to-connection-management-in-postgres">https://blog.crunchydata.com/blog/your-guide-to-connection-management-in-postgres</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/管理/">#管理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/连接/">#连接</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>