<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>以数据导向设计的冒险 - 第3B部分：内部参考 Adventures in data-oriented design – Part 3b: Internal References</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Adventures in data-oriented design – Part 3b: Internal References<br/>以数据导向设计的冒险 - 第3B部分：内部参考 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-18 22:20:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/7cf484ceeae6bc7fc2161eddc603cd15.jpg"><img src="http://img2.diglog.com/img/2021/3/7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As promised in the  last blog post, today we are going to take a look at how Molecule handles internal references to data owned by some other system in the engine.</p><p>正如在最后一个博客帖子中所承诺的那样，今天我们将看一下分子如何处理发动机中其他系统所拥有的数据的内部引用。</p><p> First, a quick recap of reasons why we don’t want to use pointers for referencing data is in order:</p><p> 首先，快速回顾我们不想使用用于引用数据的指针的原因是顺序：</p><p> With raw pointers, ownership is sometimes unclear. If I’m handed a pointer, do I need to delete the instance? Who owns it? How long can I hold on to it? This very quickly leads to double-deletes and/or dangling pointers. Both are kinds of bugs which can be hard to find if you’re unlucky.</p><p> 使用原始指针，所有权有时候不清楚。如果我递给了一个指针，我是否需要删除实例？谁拥有它？我能坚持多久？这很快就会导致双删除和/或悬挂指针。两者都是各种各样的错误，如果你不幸，这很难找到。</p><p> The above can be somewhat alleviated by using a shared_ptr&lt;&gt; or some reference-counting mechanism, but now we have added additional overhead which isn’t really necessary. Ownership is still unclear – when is the data behind the reference-counted pointer actually freed? Who else holds on to it?</p><p> 以上，通过使用Shared_ptr＆lt;＆gt可以稍微缓解。或者一些参考计数机制，但现在我们增加了额外的开销，这并非真正需要。所有权尚不清楚 - 参考指针背后的数据实际上是什么时候？还有谁坚持下去？</p><p> How are pointers replicated or copied, e.g. across the network? You always have to have some kind of serialization mechanism in place because you cannot just send pointers across the network – the address they contain won’t make sense in a different address space.</p><p> 指针如何复制或复制，例如，跨网络？您总是必须有某种序列化机制，因为您不能仅在网络上发送指针 - 它们包含的地址在不同的地址空间中不会有意义。</p><p> Pointers don’t support relocation. Ultimately, the system who owns the data should also be responsible for managing the data’s memory. Therefore, a system might want to move things around in memory, e.g. for run-time defragmentation. Notifying each and every instance that might hold a pointer to system-internal data is tedious and error-prone.</p><p> 指针不支持重定位。最终，拥有数据的系统也应负责管理数据的内存。因此，系统可能希望在内存中移动事物，例如，用于运行时碎片整理。通知每个可能持有指向系统内部数据的指针的每个实例都是繁琐和容易出错的。</p><p> So, let us now take a closer look at how we can store internal references without running into the above-mentioned problems.</p><p> 所以，现在让我们仔细看看我们如何存储内部引用而不达到上述问题。 </p><p>  In the Molecule Engine,  handles are used to refer to internal data. That is, they refer to data owned by some system  directly, and not via some indirection. This is also the reason why they are called  internal references.</p><p>在分子发动机中，手柄用于指内部数据。也就是说，它们是指直接由某种系统拥有的数据，而不是通过某种间接。这也是他们称为内部参考的原因。</p><p> What are handles? Basically, they are indices into the data, but with a twist. One can think of handles as „smart indices“. But before going into detail about handles, which problems do plain indices already solve?</p><p> 什么是处理？基本上，它们是数据的指数，但扭曲。人们可以将句柄视为“智能索引”。但在详细介绍句柄之前，普通索引已经解决了哪些问题？</p><p> You cannot accidentally call  delete or  free() on an index. Furthermore, if a system only deals with indices as input and output parameters, it should be clear that the system also owns the data.</p><p> 您不能在索引上意外呼叫删除或免费（）。此外，如果系统仅将索引涉及输入和输出参数，则应清楚该系统还拥有数据。</p><p> Indices can be easily replicated and copied. They also support data relocation out-of-the-box: if we want to access the data at e.g. index 3, it doesn’t matter where the data itself resides, as long as it remains in the same order. It can reside at address 0xA000 or 0xB000 or someplace else – data[3] will give us the data we want.</p><p> 可以轻松复制和复制索引。它们还支持数据重定位出框外：如果我们希望在例如，例如访问数据。索引3，数据本身所在的位置并不重要，只要它保持相同的顺序。它可以驻留在地址0xa000或0xb000或某个elseplace  - 数据[3]将给我们我们想要的数据。</p><p>  We cannot detect access to stale/deleted data. We might try to access the data at index 3, but that might have been freed already since our last access.</p><p>  我们无法检测到陈旧/删除数据的访问。我们可能会尝试访问索引3的数据，但自上次访问以来可能已经释放了。</p><p> Whole data blocks can be moved around in memory, but the order of individual data items cannot be changed, because that would mess up our indices.</p><p> 整个数据块可以在内存中移动，但单个数据项的顺序无法更改，因为这会搞定我们的索引。</p><p> Handles help us with the first problem, but also don’t support arbitrary relocation of individual data items. This is what  IDs or  external references are for, but those will be the topic of the next post.</p><p> 处理帮助我们有第一个问题，但也不支持任意重新安置各个数据项。这是ID或外部参考的是，但这些是下一篇文章的主题。 </p><p> The question remains: how do we turn indices into handles that can detect access to already deleted data?</p><p>问题仍然存在：我们如何将指数转换为可以检测到已删除数据的访问的句柄？</p><p> The idea is quite simple: instead of only using an index, a handle also stores the generation in which the index was created. The generation is simply a monotonically increasing counter that gets incremented each time a data item is deleted. The generation is stored both inside the handle, and for each data item. Whenever we want to access data using a handle, the index’ generation and the data item’s generation need to match.</p><p> 这个想法非常简单：而不是仅使用索引，句柄还存储创建索引的生成。这一代只是一个单调增加的计数器，每次删除数据项时都会递增。该生成存储在手柄内，以及每个数据项。每当我们想要使用句柄访问数据时，索引的生成和数据项的生成需要匹配。</p><p>  Going back to our example from the last post, let us assume our render backend provides space for 4k vertex buffers. New vertex buffers are allocated using a pool-allocator/free-list internally, and users only deal with a  VertexBufferHandle.</p><p>  从上一篇文章返回我们的示例，让我们假设我们的渲染后端为4K顶点缓冲区提供空间。新的顶点缓冲区在内部使用池分配器/自由列表分配，用户只能处理VertexBufferHandle。</p><p> Initially, our pool of vertex buffers is empty, and all generations are set to zero.</p><p> 最初，我们的Vertex缓冲区池为空，并且所有世代都设置为零。</p><p> 4096 Vertex buffers:+----+----+----+----+----+----+| VB | VB | VB | .. | VB | VB |+----+----+----+----+----+----+4096 Generations:+----+----+----+----+----+----+| 0 | 0 | 0 | .. | 0 | 0 |+----+----+----+----+----+----+</p><p> 4096个顶点缓冲区：+ ---- + ---- + ---- + ---- + ---- + ---- +| vb | vb | vb | .. | vb | vb |+ ---- + ---- + ---- + ---- + ---- + ---- +4096代：+ ---- + ---- + ---- + ---- + ---- + ---- +| 0 | 0 | 0 | .. | 0 | 0 |+ ---- + ---- + ---- + ---- + ---- + ---- +</p><p> The first time we allocate a vertex buffer, the handle will contain an index of 0, and a generation of 0. Future vertex buffer handles will have a different index, and also a generation of 0. Assume we now destroy the first vertex buffer we allocated. The generation of the slot that contained it will increment, yielding the following layout:</p><p> 首次分配顶点缓冲区，句柄将包含0的索引，而且将来的0生成0.将来的索引有一个不同的索引，也是0的生成。假设我们现在摧毁我们的第一个顶点缓冲区分配。包含它将增量的插槽的生成，产生以下布局：</p><p> +----+----+----+----+----+----+| VB | VB | VB | .. | VB | VB |+----+----+----+----+----+----++----+----+----+----+----+----+| 1 | 0 | 0 | .. | 0 | 0 |+----+----+----+----+----+----+</p><p> + ---- + ---- + ---- + ---- + ---- + ---- +| vb | vb | vb | .. | vb | vb |+ ---- + ---- + ---- + ---- + ---- + ---- ++ ---- + ---- + ---- + ---- + ---- + ---- +| 1 | 0 | 0 | .. | 0 | 0 |+ ---- + ---- + ---- + ---- + ---- + ---- + </p><p> If we now want to access that vertex buffer using the handle, we check its generation against the one stored with our vertex buffer, and find that they don’t match – meaning that we tried to access already deleted data.</p><p>如果我们现在要使用句柄访问该顶点缓冲区，我们会检查其生成与带有我们的顶点缓冲区存储的那样，并发现它们不匹配 - 这意味着我们尝试访问已删除的数据。</p><p>    One thing we haven’t talked about yet is how handles can be implemented. As almost always, the simplest solutions are the best, so a trivial struct will suffice in this case:</p><p>    我们尚未谈过的一件事是如何实现句柄。尽管如此，最简单的解决方案是最好的，因此在这种情况下，琐碎的结构就足够了：</p><p>  In practice, you normally would not use two 32-bit integers for both the index and the generation, but rather use  bitfields instead. In the case of our vertex buffer handles, we need 12 bits for storing indices in the range [0, 4095], which leaves 20 bits for the generation if we want our handles to be 32-bit integers. Hence, our handles would look more like the following:</p><p>  在实践中，您通常不会为索引和生成使用两个32位整数，而是使用位域。在我们的顶点缓冲区句柄的情况下，我们需要12位用于在范围内存储索引[0,4095]，如果我们希望我们的句柄是32位整数，则为生成离开20位。因此，我们的手柄看起来更像以下内容：</p><p>  This means that the generation overflows after 1048576 vertex buffers have been deleted  in the same slot in our pool. Theoretically, this means that we could wrongly access a vertex buffer via an old handle that was generated more than 1048576 vertex buffer create/delete cycles ago, in that very slot. In practice this should never happen, unless we store an old handle for ages, create/delete buffers like crazy, and never access the buffer using that handle in the meantime. Yet, depending on the number of bits you are willing to spend this  can happen, so it is something to keep in mind.</p><p>  这意味着在1048576顶点缓冲区后的生成溢出已在我们池中的同一插槽中删除。从理论上讲，这意味着我们可以通过生成超过1048576个顶点缓冲区创建/删除周期前的旧句柄来错误地访问顶点缓冲区，在那个非常插槽中。在实践中，这不应该发生，除非我们为年龄存储旧句柄，否则会像疯狂一样创建/删除缓冲区，并不在使用该句柄使用该句柄访问缓冲区。然而，取决于您愿意花费的位数可能发生，因此需要记住。</p><p> Last but not least, another nice thing about handles that I mentioned in the previous blog post is that they use less memory than a pointer. Most handles can store their index and generation in a single 32-bit integer, which means they need half the amount of memory compared to 64-bit pointers. Additionally, we really only need to store the generation inside a handle for detecting access to stale data. We should not need that in a retail build, hence handles can be as small as 16-bit integers in those builds, if your indices only need to be in the range [0, 65535].</p><p> 最后但并非最不重要的是，关于我在上一个博客文章中提到的句柄的另一个好事是它们使用的内存不如指针。大多数手柄可以在单个32位整数中存储它们的索引和生成，这意味着它们需要与64位指针相比的一半内存量。此外，我们真的只需要将生成存储在句柄内，以检测对陈旧数据的访问。我们不应在零售版本中需要，因此，如果您的指标只需要在范围内，则句柄可以在那些构建中的16位整数中的一个小于16位整数。[0,65535]。</p><p>  In Molecule, I use a generic handle implementation which defines the underlying data types according to certain build rules, and also  static_asserts whether the bits fit into that type. The basic struct is as follows:</p><p>  在分子中，我使用通用句柄实现，该句柄实现根据某些构建规则来定义底层数据类型，并且STITY_ASSERTS是位于该类型的位置。基本结构如下：</p><p>    And that concludes today’s post! In the next part in the series, we will discuss how external references also allow for moving individual data items around in memory, without user code having to care about that.</p><p>    这结束了今天的帖子！在该系列的下一部分中，我们将讨论外部引用如何允许在内存中移动各个数据项，而无需关注的用户代码。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.molecular-matters.com/2013/05/17/adventures-in-data-oriented-design-part-3b-internal-references/">https://blog.molecular-matters.com/2013/05/17/adventures-in-data-oriented-design-part-3b-internal-references/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/导向/">#导向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/句柄/">#句柄</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>