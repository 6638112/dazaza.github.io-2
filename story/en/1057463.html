<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>NoSQL数据建模技术 NoSQL Data Modeling Techniques</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">NoSQL Data Modeling Techniques<br/>NoSQL数据建模技术 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-10 14:54:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/9ed8cb932486b016b5c2e4751d096413.png"><img src="http://img2.diglog.com/img/2021/4/9ed8cb932486b016b5c2e4751d096413.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>NoSQL databases are often compared by various non-functional criteria, such as scalability, performance, and consistency. This aspect of NoSQL is well-studied both in practice and theory because specific non-functional properties are often the main justification for NoSQL usage and fundamental results on distributed systems like the  CAP theorem apply well to NoSQL systems.  At the same time, NoSQL data modeling is not so well studied and lacks the systematic theory found in relational databases. In this article I provide a short comparison of NoSQL system families from the data modeling point of view and digest several common modeling techniques.</p><p>NoSQL数据库通常由各种非功能标准进行比较，例如可伸缩性，性能和一致性。在实践和理论中，NoSQL的这一方面在实践和理论中都是很好地研究，因为特定的非功能性质通常是NoSQL使用和基本结果的主要理由，就像帽定理一样适用于NoSQL系统。与此同时，NoSQL数据建模并不是很好地研究，并且缺乏在关系数据库中发现的系统理论。在本文中，我提供了从数据建模的数据建模和摘要几个常见建模技术中的NoSQL系统系列的短暂比较。</p><p> I would like to thank  Daniel Kirkdorffer who reviewed the article and cleaned up the grammar.</p><p> 我要感谢Daniel Kirkdorffer审查了这篇文章并清理了语法。</p><p> To  explore data modeling techniques, we have to start with a more or less systematic view of NoSQL data models that preferably reveals trends and interconnections. The following figure depicts imaginary “evolution” of the major NoSQL system families, namely, Key-Value stores, BigTable-style databases, Document databases, Full Text Search Engines, and Graph databases:</p><p> 为了探索数据建模技术，我们必须从一个或多或少地系统的NoSQL数据模型视图开始，优选地揭示趋势和互连。下图描绘了主要的NoSQL系统系列的虚构的“演变”，即键值存储，BigTable样式数据库，文档数据库，全文搜索引擎和图形数据库：</p><p>  First, we should note that SQL and relational model in general were designed long time ago to interact with the end user. This user-oriented nature had vast implications:</p><p>  首先，我们应该注意，SQL和关系模型通常是长时间设计的，以与最终用户进行交互。这种面向用户的大自然具有巨大影响：</p><p> The end user is often interested in aggregated reporting information, not in separate data items, and SQL pays a lot of attention to this aspect.</p><p> 最终用户通常对聚合报告信息感兴趣，而不是在单独的数据项中，并且SQL对此方面有很大的注意。</p><p> No one can expect human users to explicitly control concurrency, integrity, consistency, or data type validity. That’s why SQL pays a lot of attention to transactional guaranties, schemas, and referential integrity.</p><p> 没有人可以预期人类用户明确控制并发，完整性，一致性或数据类型有效性。这就是为什么SQL对事务担保，模式和参照完整性付出很多人关注。</p><p> On the other hand, it turned out that software applications are not so often interested in in-database aggregation and able to control, at least in many cases, integrity and validity themselves. Besides this, elimination of these features had an extremely important influence on the performance and scalability of the stores. And this was where a new evolution of data models began:</p><p> 另一方面，它证明了软件应用程序通常对数据库内聚合并能够控制，至少在许多情况下，完整性和有效性本身都有感兴趣。除此之外，消除这些功能对商店的性能和可扩展性具有极大的影响。这是数据模型的新演变开始的地方： </p><p> Key-Value storage is a very simplistic, but very powerful model. Many techniques that are described below are perfectly applicable to this model.</p><p>钥匙值存储是一种非常简单，但非常强大的模型。以下描述的许多技术完全适用于该模型。</p><p> One of the most significant shortcomings of the Key-Value model is a poor applicability to cases that require processing of key ranges. Ordered Key-Value model overcomes this limitation and significantly improves aggregation capabilities.</p><p> 关键值模型最重要的缺点之一是对需要处理关键范围的情况的适用性差。订购的键值模型克服了这个限制，显着提高了聚合能力。</p><p> Ordered Key-Value model is very powerful, but it does not provide any framework for value modeling. In general, value modeling can be done by an application, but BigTable-style databases go further and model values as a map-of-maps-of-maps, namely, column families, columns, and timestamped versions.</p><p> 订购的键值模型非常强大，但它没有提供任何框架的值建模。通常，值建模可以通过应用程序完成，但是大型式数据库可以进一步完成，并将值作为映射地图，即列，列族，列和时间戳版本。</p><p> Document databases advance the BigTable model offering two significant improvements. The first one is values with schemes of arbitrary complexity, not just a map-of-maps. The second one is database-managed indexes, at least in some implementations. Full Text Search Engines can be considered a related species in the sense that they also offer flexible schema and automatic indexes. The main difference is that Document database group indexes by field names, as opposed to Search Engines that group indexes by field values. It is also worth noting that some Key-Value stores like Oracle Coherence gradually move towards Document databases via addition of indexes and in-database entry processors.</p><p> 文档数据库推出了两种重大改进的BIGTABLE模型。第一个是具有任意复杂性方案的值，而不仅仅是映射地图。第二个是数据库管理的索引，至少在一些实现中。完整文本搜索引擎可以被视为一个有关的物种，以至于它们还提供灵活的架构和自动索引。主要区别在于，文件数据库组索引由字段名称，而不是搜索引擎，该引擎由字段值组索引。还值得注意的是，Oracle Cherce等一些键值存储通过添加索引和数据库内输入处理器逐渐转向文档数据库。</p><p> Finally, Graph data models can be considered as a side branch of evolution that origins from the Ordered Key-Value models. Graph databases allow one model business entities very transparently ( this depends on that), but hierarchical modeling techniques make other data models very competitive in this area too. Graph databases are related to Document databases because many implementations allow one model a value as a map or document.</p><p> 最后，图数据模型可以被视为从有序键值模型起源的侧面分支。图表数据库允许一个模型业务实体非常透明地（这取决于此），但分层建模技术也使其他数据模型在该区域中非常竞争。图形数据库与文档数据库有关，因为许多实现允许将一个型号为映射或文档。</p><p>  The rest of this article describes concrete data modeling techniques and patterns. As a preface, I would like to provide a few general notes on NoSQL data modeling:</p><p>  本文的其余部分介绍了具体数据建模技术和模式。作为序言，我想提供关于NoSQL数据建模的一些概要说明：</p><p> NoSQL data modeling often starts from the application-specific queries as opposed to relational modeling: Relational modeling is typically driven by the structure of available data. The main design theme is  “ What answers do I have?”</p><p> NoSQL数据建模通常从应用程序特定的查询开始，而不是关系建模：关系建模通常由可用数据的结构驱动。主要设计主题是“我有什么答案？” </p><p> NoSQL data modeling is typically driven by application-specific access patterns, i.e. the types of queries to be supported. The main design theme is  “What questions do I have?”</p><p>NoSQL数据建模通常由特定于应用程序的访问模式驱动，即要支持的查询类型。主要设计主题是“我有什么问题？”</p><p> NoSQL data modeling often requires a deeper understanding of data structures and algorithms than relational database modeling does. In this article I describe several well-known data structures that are not specific for NoSQL, but are very useful in practical NoSQL modeling.</p><p> NoSQL数据建模通常需要更深入地了解数据结构和算法，而不是关系数据库建模。在本文中，我描述了几种没有特定于NoSQL的众所周知的数据结构，但在实用的NoSQL建模中非常有用。</p><p>  Relational databases are not very convenient for hierarchical or graph-like data modeling and processing. Graph databases are obviously a perfect solution for this area, but actually most of NoSQL solutions are surprisingly strong for such problems. That is why the current article devotes a separate section to hierarchical data modeling.</p><p>  关系数据库不是非常方便的层次结构或图形数据建模和处理。图表数据库显然是这个领域的完美解决方案，但实际上大多数NoSQL解决方案对于此类问题令人惊讶地强大。这就是当前文章将单独的部分分离到分层数据建模的原因。</p><p> Although data modeling techniques are basically implementation agnostic, this is a list of the particular systems that I had in mind while working on this article:</p><p> 虽然数据建模技术基本上是实现不可知论，但这是我在研究本文时所遇到的特定系统的列表：</p><p>     Denormalization can be defined as the copying of the same data into multiple documents or tables in order to simplify/optimize query processing or to fit the user’s data into a particular data model. Most techniques described in this article leverage denormalization in one or another form.</p><p>     DeNormalization可以定义为将相同数据复制到多个文档或表中，以便简化/优化查询处理或将用户的数据拟合到特定数据模型中。本文中描述的大多数技术利用了一种或另一种形式的非正规化。</p><p>  Query data volume or  IO per query VS  total data volume. Using denormalization one can group all data that is needed to process a query in one place. This often means that for different query flows the same data will be accessed in different combinations. Hence we need to duplicate data, which increases total data volume.</p><p>  查询数据卷或每个查询的IO与总数据卷。使用DeMormAlization可以将所有数据组分组在一个地方处理查询所需的数据。这通常意味着对于不同的查询流，将以不同的组合访问相同的数据。因此，我们需要重复数据，这增加了总数据量。</p><p> Processing complexity VS  total data volume. Modeling-time normalization and consequent query-time joins obviously increase complexity of the query processor, especially in distributed systems. Denormalization allow one to store data in a query-friendly structure to simplify query processing.</p><p> 处理复杂度与总数据卷。建模 - 时间归一化和随后的查询时间加入显然提高了查询处理器的复杂性，尤其是分布式系统。 Denormalization允许一个存储在查询友好结构中的数据以简化查询处理。 </p><p>    Key-Value Stores and Graph Databases typically do not place constraints on values, so values can be comprised of arbitrary format. It is also possible to vary a number of records for one business entity by using composite keys. For example, a user account can be modeled as a set of entries with composite keys like  UserID_name, UserID_email, UserID_messages and so on. If a user has no email or messages then a corresponding entry is not recorded.</p><p>键值存储和图形数据库通常不会在值上放置约束，因此值可以包含任意格式。还可以通过使用复合键来改变一个商业实体的多个记录。例如，用户帐户可以用userid_name，userid_email，userid_messid_messidage等组合为一组与复合键的条目建模。如果用户没有电子邮件或消息，则不会记录相应的条目。</p><p> BigTable models support soft schema via a variable set of columns within a  column family and a variable number of  versions for one  cell.</p><p> Bigtable模型通过列族内的变量一组列支持软架构，以及一个单元格的可变版本。</p><p> Document databases are inherently schema-less, although some of them allow one to validate incoming data using a user-defined schema.</p><p> 文档数据库本质上是概要的，尽管其中一些允许使用用户定义的架构验证传入数据。</p><p> Soft schema allows one to form classes of entities with complex internal structures (nested entities) and to vary the structure of particular entities.This feature provides two major facilities:</p><p> 软架构允许其中一个组成具有复杂内部结构（嵌套实体）的实体类，并改变特定实体的结构。这功能提供了两个主要设施：</p><p> Masking of “technical” differences between business entities and modeling of heterogeneous business entities using one collection of documents or one table.</p><p> 使用一系列文件或一张表掩盖业务实体与异构企业实体建模之间的“技术”差异。</p><p> These facilities are illustrated in the figure below. This figure depicts modeling of a product entity for an eCommerce business domain. Initially, we can say that all products have an ID, Price, and Description. Next, we discover that different types of products have different attributes like Author for Book or Length for Jeans. Some of these attributes have a one-to-many or many-to-many nature like Tracks in Music Albums. Next, it is possible that some entities can not be modeled using fixed types at all. For example, Jeans attributes are not consistent across brands and specific for each manufacturer. It is possible to overcome all these issues in a relational normalized data model, but solutions are far from elegant. Soft schema allows one to use a single Aggregate (product) that can model all types of products and their attributes:</p><p> 这些设施如下图所示。该图描绘了电子商务业务域的产品实体的建模。最初，我们可以说所有产品都有ID，价格和描述。接下来，我们发现不同类型的产品具有不同的属性，如牛仔裤的书籍或长度。其中一些属性有一个多对多或多对多的性质，如音乐专辑中的曲目。接下来，可能无法使用固定类型建模某些实体。例如，牛仔裤属性在品牌上并不一致，并且对每个制造商特定。可以在关系规范化数据模型中克服所有这些问题，但解决方案远非优雅。软架构允许人们使用单个聚合（产品），可以模拟所有类型的产品及其属性：</p><p>  Embedding with denormalization can greatly impact updates both in performance and consistency, so special attention should be paid to update flows.</p><p>  嵌入Denormalization可以极大地影响性能和一致性的更新，因此应特别注意更新流程。 </p><p>   Joins are rarely supported in NoSQL solutions. As a consequence of the “question-oriented” NoSQL nature, joins are often handled at design time as opposed to relational models where joins are handled at query execution time. Query time joins almost always mean a performance penalty, but in many cases one can avoid joins using Denormalization and Aggregates, i.e. embedding nested entities. Of course, in many cases joins are inevitable and should be handled by an application. The major use cases are:</p><p>NoSQL解决方案很少支持联合。由于“面向问题的”NoSQL性质，Joins通常在设计时处理，而不是在查询执行时间处理连接的关系模型。查询时间连接几乎总是意味着性能损失，但在许多情况下，可以避免使用DeNormalization和聚合，即嵌入嵌套实体。当然，在许多情况下，加入是不可避免的，应该由申请处理。主要用例是：</p><p> Aggregates are often inapplicable when entity internals are the subject of frequent modifications. It is usually better to keep a record that something happened and join the records at query time as opposed to changing a value . For example, a messaging system can be modeled as a User entity that contains nested Message entities. But if messages are often appended, it may be better to extract Messages as independent entities and join them to the User at query time:</p><p> 当实体内部是频繁修改的主题时，聚合通常不可应用。通常更好地保留事件发生的记录并在查询时间下加入记录，而不是更改值。例如，消息传递系统可以被建模为包含嵌套消息实体的用户实体。但是，如果往往附加消息，则可以更好地将消息作为独立实体提取，并在查询时间将其加入用户：</p><p>   In this section we discuss general modeling techniques that applicable to a variety of NoSQL implementations.</p><p>   在本节中，我们讨论适用于各种NoSQL实现的一般建模技术。</p><p>  Many, although not all, NoSQL solutions have limited transaction support. In some cases one can achieve transactional behavior using distributed locks or  application-managed MVCC, but it is common to model data using an Aggregates technique to guarantee some of the ACID properties.</p><p>  许多人，虽然不是全部，NoSQL Solutions的交易支持有限。在某些情况下，人们可以使用分布式锁或应用程序管理的MVCC来实现交易行为，但是使用聚合技术模拟数据以保证一些酸性。</p><p> One of the reasons why powerful transactional machinery is an inevitable part of the relational databases is that normalized data typically require multi-place updates. On the other hand, Aggregates allow one to store a single business entity as one document, row or key-value pair and update it atomically:</p><p> 强大的交易机械是关系数据库的不可避免部分的原因之一是归一化数据通常需要多个地点更新。另一方面，聚合允许将单个业务实体存储为一个文档，行或键值对并原子更新：</p><p>  Of course, Atomic Aggregates as a data modeling technique is not a complete transactional solution, but if the store provides certain guaranties of atomicity, locks, or test-and-set instructions then Atomic Aggregates can be applicable.</p><p>  当然，作为数据建模技术的原子聚集体不是完整的事务解决方案，但如果商店提供某些保证的原子性，锁定或测试和设置的指令，则可以适用原子聚集体。</p><p>   Perhaps the greatest benefit of an unordered Key-Value data model is that entries can be partitioned across multiple servers by just hashing the key. Sorting makes things more complex, but sometimes an application is able to take some advantages of ordered keys even if storage doesn’t offer such a feature. Let’s consider the modeling of email messages as an example:</p><p>   也许无序键值数据模型的最大益处是，只需散列密钥即可通过多个服务器划分条目。排序使事情变得更加复杂，但有时应用程序即使存储不提供这样的功能也能够采取某些优点。让我们考虑电子邮件的建模作为示例： </p><p> Some NoSQL stores provide atomic counters that allow one to generate sequential IDs. In this case one can store messages using  userID_messageID as a composite key. If the latest message ID is known, it is possible to traverse previous messages. It is also possible to traverse preceding and succeeding messages for any given message ID.</p><p>一些NoSQL存储提供原子计数器，允许一个生成顺序ID。在这种情况下，可以使用userid_messageid作为复合密钥存储消息。如果已知最新消息ID，则可以遍历先前的消息。对于任何给定的消息ID，也可以遍历前面和后续消息。</p><p> Messages can be grouped into buckets, for example, daily buckets. This allows one to traverse a mail box backward or forward starting from any specified date or the current date.</p><p> 消息可以分组为桶，例如，每日存储桶。这允许一个人从任何指定的日期或当前日期开始向后或向前遍历邮箱。</p><p>   Dimensionality Reduction is a technique that allows one to map multidimensional data to a Key-Value model or to other non-multidimensional models.</p><p>   减少维度是一种允许人们将多维数据映射到键值模型或其他非多维模型的技术。</p><p> Traditional geographic information systems use some variation of a Quadtree or R-Tree for indexes. These structures need to be updated in-place and are expensive to manipulate when data volumes are large. An alternative approach is to traverse the 2D structure and flatten it into a plain list of entries. One well known example of this technique is a Geohash. A Geohash uses a Z-like scan to fill 2D space and each move is encoded as 0 or 1 depending on direction. Bits for longitude and latitude moves are interleaved as well as moves. The encoding process is illustrated in the figure below, where black and red bits stand for longitude and latitude, respectively:</p><p> 传统地理信息系统使用四叉树或R树的一些变体进行索引。这些结构需要更新，并且当数据量大时，可以操纵昂贵。替代方法是遍历2D结构并将其平坦化为纯粹的条目列表。本技术的一个众所周知的例子是岩石。 Geohash使用z样扫描来填充2D空间，并且每个移动根据方向编码为0或1。经度和纬度移动的比特是交错的以及移动。编码过程在下图中示出，其中黑色和红色位分别用于经度和纬度：</p><p>  An important feature of a Geohash is its ability to estimate distance between regions using bit-wise code proximity, as is shown in the figure. Geohash encoding allows one to store geographical information using plain data models, like sorted key values preserving spatial relationships. The Dimensionality Reduction technique for BigTable was described in [6.1]. More information about Geohashes and other related techniques can be found in [6.2] and [6.3].</p><p>  Geohash的一个重要特征是它能够使用位方面的代码接近区域估计区域之间的距离，如图所示。 Geohash编码允许使用普通数据模型存储地理信息，例如保留空间关系的排序键值。 [6.1]中描述了Bigtable的维数减少技术。有关地磁和其他相关技术的更多信息，请参见[6.2]和[6.3]。</p><p>   Index Table is a very straightforward technique that allows one to take advantage of indexes in stores that do not support indexes internally. The most important class of such stores is the BigTable-style database. The idea is to create and maintain a special table with keys that follow the access pattern. For example, there is a master table that stores user accounts that can be accessed by user ID. A query that retrieves all users by a specified city can be supported by means of an additional table where city is a key:</p><p>   索引表是一种非常简单的技术，允许一个人利用在内部不支持索引的商店中的索引。这些商店中最重要的类别是BigTable风格的数据库。该想法是创建和维护一个特殊的表，其中包含遵循访问模式的键。例如，有一个主表，用于存储可以由用户ID访问的用户帐户。可以通过额外的表来支持检索指定城市所有用户的查询，其中City是一个键的额外表：</p><p>  An Index table can be updated for each update of the master table or in batch mode. Either way, it results in an additional performance penalty and become a consistency issue.</p><p>  可以为主表或批处理模式更新索引表。无论哪种方式，它会导致额外的性能惩罚并成为一致性问题。 </p><p>    Composite key is a very generic technique, but it is extremely beneficial when a store with ordered keys is used. Composite keys in conjunction with secondary sorting allows one to build a kind of multidimensional index which is fundamentally similar to the previously described Dimensionality Reduction technique. For example, let’s take a set of records where each record is a user statistic. If we are going to aggregate these statistics by a region the user came from, we can use keys in a format  (State:City:UserID) that allow us to iterate over records for a particular state or city if that store supports the selection of key ranges by a partial key match (as BigTable-style systems do):</p><p>复合键是一种非常通用的技术，但是当使用有序密钥的商店时，它是非常有益的。复合键与二级排序结合允许一个人构建一种多维指标，它基本上类似于先前描述的维度减少技术。例如，让我们拍一组记录，每个记录是用户统计信息。如果我们将通过用户来自的区域聚合这些统计信息，我们可以使用格式（状态：城市：userid）使用键，该键允许我们迭代特定状态或城市的记录，如果该商店支持选择钥匙范围由部分关键匹配（作为Bigtable-Signd Systems）：</p><p>     Composite keys may be used not only for indexing, but for different types of grouping. Let’s consider an example. There is a huge array of log records with information about internet users and their visits from different sites ( click stream). The goal is to count the number of unique users for each site. This is similar to the following SQL query:</p><p>     复合键不仅可以用于索引，而是用于不同类型的分组。让我们考虑一个例子。有一个大量的日志记录，其中包含有关Internet用户的信息及其来自不同站点的访问（单击流）。目标是计算每个站点的唯一用户的数量。这类似于以下SQL查询：</p><p>    The idea is to keep all records for one user collocated, so it is possible to fetch such a frame into memory (one user can not produce too many events) and to eliminate site duplicates using hash table or whatever. An alternative technique is to have one entry for one user and append sites to this entry as events arrive. Nevertheless, entry modification is generally less efficient than entry insertion in the majority of implementations.</p><p>    该想法是保留一个用户并源的所有记录，因此可以将这种帧提取到内存中（一个用户不能产生太多事件）并使用哈希表或其他任何用户消除站点复制品。当事件到达时，替代技术是将一个用户的一个条目和将站点附加到该条目。尽管如此，进入修改通常比大多数实现中的进入插入效率低。</p><p>   This technique is more a data processing pattern, rather than data modeling. Nevertheless, data models are also impacted by usage of this pattern. The main idea of this technique is to use an index to find data that meets a criteria, but aggregate data using original representation or full scans. Let’s consider an example. There are a number of log records with information about internet users and their visits from different sites ( click stream). Let assume that each record contains user ID, categories this user belongs to (Men, Women, Bloggers, etc), city this user came from, and visited site. The goal is to describe the audience that meet some criteria (site, city, etc) in terms of unique users for each category that occurs in this audience (i.e. in the set of users that meet the criteria).</p><p>   该技术更像是数据处理模式，而不是数据建模。然而，数据模型也受到这种模式的使用影响。此技术的主要思想是使用索引来查找符合标准的数据，但使用原始表示或全扫描聚合数据。让我们考虑一个例子。有许多日志记录具有有关Internet用户的信息及其来自不同站点的访问（单击流）。假设每个记录包含用户ID，该用户属于（男性，女性，博主等），城市这个用户来自和访问的网站。目标是描述在本次受众中发生的每个类别的唯一用户（即，在符合标准的用户集中）的唯一用户，符合某些标准（网站，城市等）。</p><p> It is quite clear that a search of users that meet the criteria can be efficiently done using inverted indexes like  {Category -&gt; [user IDs]} or  {Site -&gt; [user IDs]}. Using such indexes, one can intersect or unify corresponding user IDs (this can be done very efficiently if user IDs are stored as sorted lists or bit sets) and obtain an audience. But describing an audience which is similar to an aggregation query like</p><p> 很明显，使用像{类别 - ＆gt等{类别 - ＆gt这样的反相索引可以有效地完成符合标准的用户搜索[用户IDS]}或{site  - ＆gt; [用户IDS]}。使用这种索引，可以相交或统一相应的用户ID（如果用户ID被存储为排序列表或比特集）并获得受众，则可以非常有效地完成。但是描述了类似于聚合查询的受众</p><p>  cannot be handled efficiently using an inverted index if the number of categories is big. To cope with this, one can build a direct index of the form  {UserID -&gt; [Categories]} and iterate over it in order to build a final report. This schema is depicted below:</p><p>  如果类别数量大，则无法使用反相索引有效处理。要应对这一点，可以构建形式的直接索引{userid  - ＆gt; [类别]}并迭代它才能建立最终报告。此模式如下所示：</p><p>  And as a final note, we should take into account that random retrieval of records for each user ID in the audience can be inefficient. One can grapple with this problem by leveraging batch query processing. This means that some number of user sets can be precomputed (for different criteria) and then all reports for this batch of audiences can be computed in one full scan of direct or inverse index.</p><p>  作为最终说明，我们应该考虑到观众中每个用户ID的记录随机检索可能效率低。可以通过利用批处理查询处理来掌握此问题。这意味着可以预先计算一些用户集（对于不同的标准），并且可以在直接或逆索引的一个全扫描中计算本批次的所有报告。 </p><p>    Trees or even arbitrary graphs (with the aid of denormalization) can be modeled as a single record or document.</p><p>树木甚至是任意图（借助非正式化）可以被建模为单个记录或文档。</p><p> This techniques is efficient when the tree is accessed at once (for example, an entire tree of blog comments is fetched to show a page with a post).</p><p> 当一次访问树时，此技术是有效的（例如，获取整个博客评论的整个树以显示具有帖子的页面）。</p><p>    Adjacency Lists are a straightforward way of graph modeling – each node is modeled as an independent record that contains arrays of direct ancestors or descendants. It allows one to search for nodes by identifiers of their parents or children and, of course, to traverse a graph by doing one hop per query. This approach is usually inefficient for getting an entire subtree for a given node, for deep or wide traversals.</p><p>    邻接列表是图形建模的直接方式 - 每个节点都被建模为独立的记录，其中包含直接祖先或后代的数组。它允许人们通过父母或儿童的标识来搜索节点，当然，当然，通过每查询执行一跳来遍历图形。对于给定节点的整个子树，这种方法通常是低效的，用于深层或宽遍历。</p><p>   Materialized Paths is a technique that helps to avoid recursive traversals of tree-like structures. This technique can be considered as a kind of denormalization. The idea is to attribute each node by identifiers of all its parents or children, so that it is possible to determine all descendants or predecessors of the node without traversal:</p><p>   物化路径是一种有助于避免树状结构的递归遍历的技术。这种技术可以被认为是一种非正规化。该想法是通过其所有父母或儿童的标识符来归因于每个节点，因此可以在没有遍历的情况下确定节点的所有后代或前辈：</p><p>  This technique is especially helpful for Full Text Search Engines because it allows one to convert hierarchical structures into flat documents. One can see in the figure above that all products or subcategories within the  Men’s Shoes category can be retrieved using a short query which is simply a category name.</p><p>  这种技术对全文搜索引擎特别有帮助，因为它允许其中将分层结构转换为平面文档。一个人可以在上图中看到，可以使用简称为类别名称的短查询来检索男鞋类别中的所有产品或子类别。</p><p> Materialized Paths can be stored as a set of IDs or as a single string of concatenated IDs. The latter option allows one to search for nodes that meet a certain partial path criteria using regular expressions. This option is illustrated in the figure below (path includes node itself):</p><p> 物化路径可以存储为一组ID或作为单个连接ID串。后一个选项允许一个人搜索使用正则表达式遇到某个部分路径标准的节点。此选项如下图所示（路径包括节点本身）：</p><p>    Nested sets is a standard technique for modeling tree-like structures. It is widely used in relational databases, but it is perfectly applicable to Key-Value Stores and Document Databases. The idea is to store the leafs of the tree in an array and to map each non-leaf node to a range of leafs using start and end indexes, as is shown in the figure below:</p><p>    嵌套集是一种用于建模树状结构的标准技术。它广泛用于关系数据库，但它完全适用于键值存储和文档数据库。该想法是将树的叶子存储在阵列中并使用开始和结束索引将每个非叶节点映射到一系列叶片，如下图所示： </p><p>  This structure is pretty efficient for immutable data because it has a small memory footprint and allows one to fetch all leafs for a given node without traversals. Nevertheless, inserts and updates are quite costly because the addition of one leaf causes an extensive update of indexes.</p><p>这种结构对于不可变数据非常有效，因为它具有小的内存占用空间，并且允许一个在没有遍历的情况下为给定节点获取所有叶子。然而，插入和更新是非常昂贵的，因为添加一个叶子会导致索引的大量更新。</p><p>   Search Engines typically work with flat documents, i.e. each document is a flat list of fields and values. The goal of data modeling is to map business entities to plain documents and this can be challenging if the entities have a complex internal structure. One typical challenge mapping documents with a hierarchical structure, i.e. documents with nested documents inside. Let’s consider the following example:</p><p>   搜索引擎通常使用平面文档，即，每个文档都是字段和值的平面列表。数据建模的目标是将业务实体映射到纯文档，如果实体具有复杂的内部结构，这可能是具有挑战性的。一个典型的挑战映射具有层次结构的文档，即内部具有嵌套文档的文档。让我们考虑以下例子：</p><p>  Each business entity is some kind of resume. It contains a person’s name and a list of his or her skills with a skill level. An obvious way to model such an entity is to create a plain document with  Skill and  Level fields. This model allows one to search for a person by skill or by level, but queries that combine both fields are liable to result in false matches, as depicted in the figure above.</p><p>  每个企业实体都是某种简历。它包含一个人的姓名和他或她的技能列表，技能水平。一种模拟此类实体的显而易见的方法是使用技能和级别字段创建纯文档。该模型允许一个人通过技能或级别搜索人，但是将两个字段组合的查询易于导致假匹配，如上图所示。</p><p> One way to overcome this issue was suggested in [4.6]. The main idea of this technique is to index each skill and corresponding level as a dedicated pair of fields  Skill_i and  Level_i, and to search for all these pairs simultaneously (where the number of OR-ed terms in a query is as high as the maximum number of skills for one person):</p><p> 在[4.6]中提出了一种克服这个问题的方法。这种技术的主要思想是将每个技能和对应级别索引为专用对字段skill_i和level_i，并同时搜索所有这些对（查询中的术语数量高达最大值一个人的技能数量）：</p><p>  This approach is not really scalable because query complexity grows rapidly as a function of the</p><p>  这种方法并不是可以扩展，因为查询复杂性随着函数而迅速增长</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/">https://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>