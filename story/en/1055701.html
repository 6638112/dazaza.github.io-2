<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>BackPropagation 101. Backpropagation 101</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Backpropagation 101<br/>BackPropagation 101. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-02 13:52:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/2683aa45086c838a3eaef58642d6c6d0.jpg"><img src="http://img2.diglog.com/img/2021/4/2683aa45086c838a3eaef58642d6c6d0.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Imagine you’re a project manager, somewhere deep inside a vast company. You havean inbox, an outbox, and three people in your team: Alex, Bo, and Casey. Workcomes into your inbox, you allocate it to someone in your team, they performthe work and get the results back to you, and you move those results to youroutbox. Some time later, and potentially out-of-order, you’ll receive feedbackon the work you submitted. Of course, when you receive the feedback, it won’t belabelled according to the person who did it — the bureaucracy above youneither knows nor cares about Alex, Bo and Casey. All the tasks will have an IDattached, and you’ll pass that ID on when you move the results forward. Lateryou’ll use the ID to figure out how to handle the feedback.</p><p>想象一下你是一个项目经理，在广阔的公司内部。你留下了收件箱，发件箱和你团队中的三个人：亚历克斯，博和凯西。工作组合到您的收件箱中，您将其分配给团队中的某人，他们执行工作并将结果寄回给您，然后将这些结果移动到您的Outoutbox。一段时间后，潜在的超出订单，您将收到您提交的工作的Feedbackon。当然，当你收到反馈时，它不会根据这样做的人来标记 - 你不到的官僚机构都知道，也不关心亚历克斯，博和凯西。所有任务都将具有idAttached，并且当您将结果前进时，您将通过该ID。稍后会使用ID来弄清楚如何处理反馈。</p><p> def  handle_work (team , inbox , outbox , feedback_from_above ) :  . . .  while  True :  if not_empty (inbox ) : task_id , task  =  next (inbox ) worker  = choose_worker (team ) results  = worker (task ) outbox .send (task_id , results )  if not_empty (feedback_from_above ) : task_id , feedback  =  next (feedback_from_above )  . . .</p><p> def handle_work（团队，收件箱，发件箱，Feedback_from_above）：。 。 。虽然真实：如果not_empty（收件箱）：task_id，task = next（收件箱）worker = spey_wayer（team）结果= worker（任务）发件箱.send（task_id，结果）如果not_empty（feedback_from_above）：task_id，反馈= next（feedback_from_above ）。 。 。</p><p> Because you don’t know when you’ll get the feedback, you have some state totrack. You need to keep track of who did what task, so you can route thefeedback to the right person. If Alex did the task and you give the feedback toBo, your team will not improve. And your team members have some state to tracktoo: they need to understand each piece of feedback in terms of the specifictask it relates to. You want them to be able to get feedback like, “This wasn’tambitious enough”, notice that their proposal was way under-budget, and see whatthey should’ve done differently in that specific scenario.</p><p> 因为你不知道你什么时候得到反馈，你有一些州totrack。您需要跟踪谁做了什么任务，因此您可以将FeedBack路由到合适的人。如果亚历克斯做了任务并且你给出了反馈的Tobo，你的团队将不会改善。您的团队成员对TrackToo有一些状态：他们需要了解它与特定ask的每条反馈都涉及。您希望他们能够获得反馈，“这不够”，注意到他们的提案是预算的，看看在那种特定情景中应该不同的事情。</p><p> Alex, Bo and Casey should each keep their own notes about their projects, andthe specifics of exactly what they should do differently should be up to them— you don’t want to micromanage that. You have a great team. If you just routethe information around, they’ll take care of the rest. So to make your routingjob easier, you ask everyone to return you a  callback to pass along thefeedback when it’s ready. The callback is created by the worker on your team,and it should wrap whatever state they need to act upon the feedback when/if itcomes. With this system, all you need to do is file all the callbacks correctlywhen you’re passing work forward, and then retrieve the right handle when thefeedback comes in.</p><p> Alex，Bo和Casey应该每个人都保留他们的项目的笔记，并且确实究竟他们应该不同地做出不同的事情应该取决于他们 - 你不想微笑。你有一个伟大的团队。如果你只是围绕信息，他们会照顾其余的。因此，让您的RoutingJob更轻松，您可以在准备就绪时向大家返回给您沿着FEDBACK的回调。回调是由团队的工作人员创建的，它应该包裹在何时/如果ITCOMS的反馈时所需的任何状态。通过此系统，您需要做的就是正确地文件所有回调，当您传递到前进时，然后在进入FED进出时检索右句柄。</p><p> def  handle_work (team , inbox , outbox , feedback_from_above ) : pending_feedback  =  { }  while  True :  if not_empty (inbox ) : task_id , task  =  next (inbox ) worker  = choose_worker (team ) results , handle_feedback  = worker (task ) pending_feedback [task_id ]  = handle_feedback outbox .send (task_id , results )  if not_empty (feedback_from_above ) : task_id , feedback  =  next (feedback_from_above ) handle_feedback  = pending_feedback [task_id ] handle_feedback (feedback )</p><p> def handle_work（团队，收件箱，发件箱，exputback_from_above）：虽然true ] = handle_feedback发出框.send（task_id，结果）如果not_empty（feedback_from_above）：task_id，反馈= next（feedback_from_above）handle_feedback = pending_feedback [task_id] supple_feedback（反馈）</p><p> This system definitely makes your job easy, and all the information is gettingrouted correctly. But something’s still missing. Alex, Bo and Casey havefeedback too: about their inputs. They are getting feedback about their work,and are doing their best to incorporate it and improve. But their ownperformance is also dependent on the specific inputs they were given. It’salways the case that if the input for a given task had been a little bitdifferent, the output would’ve been different as well. When incorporating thefeedback on their work, the workers in your team will thus have feedback on theoriginal inputs they were given, and how those inputs could have been better toensure outputs that would have been closer to what the people above you reallywanted. Currently all this feedback is getting lost, and there’s no way for thepeople who produced those inputs to learn what your team wants from them. So youneed another outbox, pointed in the other direction, to propagate the feedbackfrom your workers to the people preparing their inputs.</p><p> 这个系统肯定会使您的工作简单，所有信息都已正确归因于。但是有些东西仍然缺失。 Alex，Bo和Casey HasfedBack也是：关于他们的投入。他们正在反馈他们的工作，并尽力融入它并改善。但他们的OwperFormance也取决于他们给出的具体输入。它是一种情况，如果给定任务的输入已经有点比特，输出也会不同。纳入他们的工作时，您团队中的工人将有关于他们所提供的理解投入的反馈，以及这些投入如何更好地提出更好的放弃输出，这将更接近您的人真实的人。目前，所有这些反馈都迷路了，而且没有办法生产这些投入的人，以了解你的团队对他们的想法。所以你是另一个向另一个方向指出的发件箱，将你的工人传播给准备他们投入的人员。</p><p>  Of course, you need to make a clear distinction between the feedback that yourteam received on their outputs, and the feedback that your team produced abouttheir inputs, and make sure that the correct pieces of feedback end up with theright people.</p><p>  当然，您需要明确区分您的输出中收到的反馈以及您的团队产生的反馈意见，并确保正确的反馈部分最终与Theright人员结束。 </p><p> Imagine if Alex had created a proposal that could potentially run over-budget,and you had passed that proposal upwards. Later you pass along feedback to Alexthat says: “Not ambitious enough; client asked for bold”. That’s a feedbackmessage for Alex, about Alex’s work. The team who made the input proposal thenneeds to hear Alex’s feedback on the original inputs: “The client context wasoriginally described as ‘risk sanctioned’, which is ambiguous phrasing. Pleasebe more clear when specifying the requirements.” If instead you passed them thefeedback intended for Alex, the team below you would be misled. They’d move inthe wrong direction. So you need to be careful that everything’s routedcorrectly. The feedback into Alex and the feedback out of Alex are notinterchangeable.</p><p>想象一下，如果亚历克斯创建了一个可能会运行过预算的提案，你已经向上通过了这一提议。后来你传递给亚历克斯列斯的反馈：“不够雄心勃勃;客户要求大胆“。这是亚历克斯的反馈，关于亚历克斯的工作。作出了输入提案的团队，然后听到亚历克斯关于原始投入的反馈：“客户上下文更加令人含糊地描述为”风险批准“，这是模棱两可的措辞。在指定要求时，请更清楚。“如果您将它们传递给亚历克斯的倒带，下面的团队将被误导。他们会移动错误的方向。所以你需要小心一切都是胜利的。反馈亚历克斯和亚历克斯的反馈是通行的。</p><p> def  handle_work (team , inbox , outbox , feedback_from_above , feedback_to_below ) : pending_feedback  =  { }  while  True :  if not_empty (inbox ) : task_id , task  =  next (inbox ) worker  = choose_worker (team ) results , handle_feedback  = worker (task ) pending_feedback [task_id ]  = handle_feedback outbox .send (task_id , results )  if not_empty (feedback_from_above ) : task_id , feedback  =  next (feedback_from_above ) handle_feedback  = pending_feedback [task_id ] feedback_to_below .send (task_id , handle_feedback (feedback ) )</p><p> def handle_work（团队，收件箱，发件箱，Fexback_from_above）：pending_feedback = {}虽然true：如果not_empty（收件箱）：task_id，task = next（收件箱）工作者=选择_worker（团队）结果，hander_feedback = worker（任务）pending_feedback [task_id] = handle_feedback发件箱.send（task_id，结果）如果not_empty（feedback_from_above）：task_id，反馈= next（feedback_from_above）handle_feedback = pending_feedback [task_id] evedback_to_below .send（task_id，handle_feedback（task_id）</p><p> With work passing forward, and corrections being fed back, your team and thepeople feeding you work are operating smoothly. The corrections you’re askingAlex, Bo and Casey to make get more and more minor; and in turn, the correctionsthey’re passing back are getting smaller too. Life is good, work is easy… Soyou start to have some time on your hands.</p><p> 通过转发的工作，并送回更正，您的团队和饲养您工作的人正在顺利运作。你询问的更正，博和凯西让越来越小;反过来，通过背部的正门情况也越来越小。生活是好的，工作很容易......豆腐开始有一段时间在你手上。</p><p> One day you’re watching a TED talk about management, and you hear about the“wisdom of crowds”: if you combine several independent estimates, you can get amore accurate result. You only have a crowd of three, but you’re getting a lotof budget estimation tasks, so why not give it a try?</p><p> 有一天，你正在观看关于管理的TED谈论，你听到了“人群的智慧”：如果你结合了几个独立的估计，你可以获得Amore准确的结果。你只有三个人群，但你得到了一个预算预算估计任务，所以为什么不给它试试？</p><p> For the next budget estimation task, instead of giving it to just one worker,you decide to get them all to work on it separately. You don’t tell them abouteach others’ work, because you don’t want groupthink — you want them to allcome up with a separate estimate. You then add them all up, and send off theresult.</p><p> 对于下一个预算估算任务，而不是将其交给一个工人，而是您决定将它们分别用于处理它。你没有告诉他们关于其他人的工作，因为你不想要groupthink  - 你希望他们用一个单独的估计来实现。然后，您将它们全部添加，并发送OFF。</p><p> alex_estimate , give_alex_feedback  = alex (task )bo_estimate , give_bo_feedback  = bo (task )casey_estimate , give_casey_feedback  = casey (task )estimate  = alex_estimate  + bo_estimate  + casey_estimate</p><p> alex_eStimate，get_alex_feedback = alex（任务）bo_estimate，get_bo_feedback = bo（task）casey_eStimate，get_ceasy_feedback = casey（任务）estimate = alex_eStimate + bo_estimate + casey_emity</p><p> Looking back on what you know now, just adding them up does feel kind ofsilly… But the rest of the TED talk was some weird stuff about jellybeans andyou stopped paying attention. So this is what you did. Anyway, the estimate yousent off was way too high, so now you’d better give everyone the feedback sothey can adjust for next time. Since this was a numerical estimate, the feedbackis very simple: it’s just a number. You don’t actually know very much about thisnumber and what it really represents, but you get a bonus if your team outputswork such that smaller numbers come back. The closer to 0 the feedback becomes,the bigger the bonus. You incentivise your team accordingly.</p><p> 回顾你现在所知道的，只是加入它们会感到友好......但其余的谈话是关于Jellybeans的奇怪的东西，以及你停止了注意力。所以这就是你所做的。无论如何，你估计的估计是太高的，所以现在你最好给每个人的反馈困扰可以在下次调整。由于这是一个数字估计值，这是一个非常简单的反馈：这只是一个数字。您实际上并不是非常了解Thingnumber以及它真正代表的东西，但如果您的团队输出措施，则获得奖金，这样较小的数字返回。反馈变得越靠到0，奖金越大。你相应地激励你的团队。 </p><p> The first time you just sum up their estimates, the combined estimate wayovershoots, and your feedback is far from zero. How should you split up thefeedback between Alex, Bo and Casey, and when they have feedback in turn, howshould you pass that along?</p><p>您第一次总结其估计，估计的估计多样镜头，以及您的反馈远非零。你应该如何在亚历克斯，博和凯西之间分开进军，而当他们反过来反馈时，你会怎样通过它？</p><p>  One way to think about this is that there’s three people, and one piece offeedback. So we should divide it up between all three estimates equally. But youthink about this some more, and decide that you really don’t feel likemicromanaging this: you just want the  combined score to come out right. So youfigure that you’ll just give all of the feedback to everyone, and see how thatworks out. Sure, your team may be a bit confused at first, but they’ll quicklyadjust their spreadsheets or whatever and the combined estimate will get closerand closer to the mark.</p><p>  考虑这一点的一种方法是有三个人，而且一件脱钩。所以我们应该在所有三个估计之间划分它。但是你更多的是更多的，并决定你真的不感到憎恨这个：你只想综合得分出来。所以你只需给每个人提供所有反馈，看看这是如何解决的。当然，你的团队起初可能有点混乱，但他们会迅速调整他们的电子表格或其他什么，并且综合估计将越来越近于标记。</p><p> There’s also the question of how to pass on Alex, Bo and Casey’s feedback abouttheir inputs. It turns out for these cost estimates, everything comes in anicely structured format: the “inputs” are just a table of numbers, which wereall estimates from another team, who are passing information into your inbox. SoAlex, Bo and Casey all produce feedback that’s in the same format — it’s atable of numbers of the same size and shape as the inputs (because that’s whatit relates to).</p><p> 还有关于如何传递Alex，Bo和Casey关于对他人的反馈的问题。事实证明，这些成本估计，一切都以易于结构化的格式：“输入”只是一个数字表，来自另一个团队的Wereall估计，他们将信息传递到您的收件箱中。 Soalex，Bo和Casey都产生了相同格式的反馈 - 它是与输入相同大小和形状的数量（因为这是涉及的）。</p><p> Alex, Bo and Casey take their bonuses seriously, so they’re very specific abouthow their feedback should be interpreted. Each of them gives you their feedbacktable and tells you, “Look, tell the people producing this data that if they hadgiven us inputs such that these numbers were zero, our own feedback would havebeen zero and we’d all make our bonus. Now, I know we shouldn’t leap toconclusions and base everything off this one sample. And I know I need to makeadjustments as well. If I make some changes and they make some changes eachtime, we’ll get there after a bit of iteration.”</p><p> 亚历克斯，博和凯西认真对待他们的奖金，因此他们非常具体地对他们的反馈应该被解释。他们每个人都会给你他们的反馈并告诉你，“看看，告诉人们产生这个数据，如果他们提出了我们的输入，这样这些数字为零，我们自己的反馈将归零，我们都会产生奖金。现在，我知道我们不应该跳转到这个样本的所有东西。而且我知道我也需要掌控调整。如果我做出一些改变，他们每天做一些改变，我们会在一些迭代之后到达那里。“</p><p> So now you have three of these feedback tables, that all relate to the sameexample. How should you propagate that back? The only sensible thing is toadd them all up and pass them on, so that’s what you do. More of these workestimates come in, and you keep passing them through your combination team andpassing the feedback back down. It’s kind of a hassle to keep track of all theinternals though — it’s messed up your neat system. So you have a bright idea:you create a little filing system for yourself, so you can keep track of thecombination and treat it just like another team member.</p><p> 所以现在你有三个反馈表，都与Sameexample相关。你应该如何传播它？唯一合理的事情是蟾蜍全力以赴并将它们传递，所以这就是你所做的。更多这些练习程序进来，你一直通过你的组合团队，并向下反馈。虽然跟踪所有内部，但它有点麻烦 - 它搞砸了你的整洁系统。所以你有一个明亮的想法：你为自己创造了一个小文件系统，所以你可以跟踪大量组织，就像另一个团队成员一样。</p><p> Alex, Bo and Casey all behave with a pretty simple interface when it comes tothese estimates, because the data is all nice and regular. We can specify theinterface using Python 3’s type-annotation syntax, so we can understand whatdata we’re passing around a bit better. The inputs are a table, so we’ll writetheir type as  Array2d — i.e., a two-dimensional array. The output will be asingle number, so a float. Each worker also returns a callback, to handle thefeedback about their output, and provide the feedback about their inputs.</p><p> 亚历克斯，博和凯西都表现出一个很简单的界面，达到估计，因为数据都很好，常规。我们可以使用Python 3的类型注释语法指定接口，因此我们可以了解我们更好地传递的时间。输入是表，因此将重写为Array2D  - 即，二维数组。输出将是asingle number，所以浮动。每个工人还返回一个回调，以处理其输出的反馈，并提供有关其输入的反馈。</p><p>  It’ll be helpful if we can refer to objects that follow this  estimate_projectsAPI in the type annotations. The type-annotations solution to this is to definea “protocol”. The specifics are a bit weird, but it comes out looking like this:</p><p>  如果我们可以引用类型注释中的eStisms_ProjectSapi的对象，它会有所帮助。对此的类型 - 注释解决方案是“协议”。细节有点奇怪，但它看起来像这样： </p><p>  This gives us a new type,  Estimator, that we can use to describe our workerfunctions. As we start combining workers, we’ll be passing functions intofunctions — so it’ll be helpful to have some annotations to see what’s goingon more easily.</p><p>这为我们提供了一种新型，估算器，我们可以用来描述我们的工作功能。当我们开始组合工人时，我们将通过功能传递功能 - 所以有一些注释会有所帮助，看看更容易出现的问题。</p><p> To make our combination worker, we just need to return a function that has thesame signature. Inside the addition estimator, we’ll call Alex, Bo and Casey inturn, add up the output, and return it along with the callback. For notationalconvenience, we’ll prefix the feedback for some quantity with  re_, like it’s areply to that variable.</p><p> 要制作我们的组合工作者，我们只需要返回一个具有Chesame签名的函数。在加法估算器内，我们将致电Alex，Bo和Casey Inturn，添加输出，并将其与回调一起返回。为有关的信任，我们将向RE_前缀为某些数量的反馈，就像它一样对该变量很大。</p><p> def  combine_by_addition (alex : Estimator , bo : Estimator , casey : Estimator )  - &gt; Estimator :  def  run_addition_estimate (inputs : Array2d )  - &gt;  float : a_estimate , give_a_feedback  = alex (inputs ) b_estimate , give_b_feedback  = bo (inputs ) c_estimate , give_c_feedback  = casey (inputs ) summed  = a_estimate  + b_estimate  + c_estimate  def  handle_feedback (re_summed :  float )  - &gt; Array2d :  # Pass the feedback re output &#39;summed&#39; to each worker, and add up their  # feedbacks re input re_input  =  ( give_a_feedback (re_summed )  + give_b_feedback (re_summed )  + give_c_feedback (re_summed )  )  return re_input  return summed , handle_feedback  return run_addition_estimate</p><p> def combine_by_addition（alex：估算器，bo：估算器，casey：估算器） - ＆gt;估算器：def run_addition_estimate（输入：array2d） - ＆gt; float：a_estimate，get_a_feedback = alex（输入）b_eStimate，get_b_feedback = bo（输入）c_estimate，get_c_feedback = casey（输入）summed = a_estimate + b_eStimate + c_estimate def handle_feedback（re_summed：float） - ＆gt; Array2D：＃通过反馈RE输出＆＃39; SUMBED＆＃39;对每个工人，并添加它们的#feckback refin re_input =（get_a_feedback（re_summed）+ get_b_feedback（re_summed）+ get_c_feedback（re_summed））返回re_input return sumped，suppl_feedback return run_addition_eStimate</p><p> We can now use our “addition” worker just like anyone else in our team. And infact, if we learned tomorrow that “Casey” was actually a front for a vast systemof combination like this… well, what of it? We’d still be passing in inputs,passing along the outputs, providing the output feedback, and making sure theinput feedback gets propagated. Nothing would change.</p><p> 我们现在可以像我们团队中的任何其他人一样使用我们的“加法”工人。和Infact，如果我们明天了解到“凯西”实际上是一个庞大的系统组合的前面......好吧，它是什么？我们仍然通过输入，传递输出，提供输出反馈，并确保incut反馈得到传播。没有什么会改变。</p><p> After a few iterations of corrections, the combined-by-addition “worker” you’vecreated starts producing great results — so good that even the vastbureaucracy around you takes notice. As well as a great bonus, you get a few newteam members: Dani, Ely and Fei. You start thinking of new ways to combine them.You also make some quick changes to your addition system. Now that you have moreworkers, you want to make it a bit more general.</p><p> 在几个迭代的修正之后，副作用的“工人”你被精心的开始产生了伟大的结果 - 这也很好，即使你周围的倒来普通橡胶印迹也会通知。除了一个伟大的奖金，你得到了一些新的成员：丹尼，伊利和费。您开始思考结合它们的新方法。您还对您的加法系统进行了一些快速更改。现在你有更多的工作者，你想让它更一般。</p><p> def  combine_by_addition (workers : List [Estimator ] )  - &gt; Estimator :  def  addition_combination (inputs : Array2d )  - &gt;  float : callbacks  =  [ ] summed  =  0  for worker  in workers : result , callback  = worker (inputs ) summed  += result callbacks .append (worker )  def  handle_feedback (re_summed :  float )  - &gt; Array2d : re_input  = callbacks [ 0 ] (re_summed )  for callback  in callbacks [ 1 : ] : re_input  += callback (re_summed )  return re_input  return summed , handle_feedback  return addition_combination</p><p> def combine_by_addition（workers：list [估算器]） - ＆gt;估算器：def附加_combination（输入：array2d） - ＆gt; float：callbacks = []求和= 0，适用于工人的工作人员：结果，回调=工作者（输入）求和+ =结果回调.append（worker）def handle_feedback（re_summed：float） - ＆gt; array2d：re_input =回调中的回调[0]（re_summed）在回调中[1：]：re_input + =回调（re_summed）return re_input return sumped，suppl_feedback return附加_combination</p><p> As for new combinations, one obvious idea harks back to your original “wisdom ofthe crowds” inspiration. Instead of just adding up the outputs, you couldaverage them. Easy. But how to handle the feedback? Should we just pass thatalong directly, like we did with the addition, or should we divide the feedbackby the number of workers?</p><p> 至于新的组合，一个明显的主意背心回到你原来的“人群的智慧”的灵感。您可以毫不犹跟添加输出，而不是加上输出。简单。但如何处理反馈？我们应该直接通过那个，就像我们这样做的那样，或者我们应该划分工人数量的反馈吗？ </p><p> It actually won’t really matter: the team members all understand the feedback tomean, “Change your model slightly, so that this number becomes closer to zero.Also, give us similar feedback about inputs.” If you give them feedback that’sthree times too big, and they make changes that pushes that number towards zero,they’ll also be pushing the “real” feedback score towards zero. You can’t reallysteer them wrong just by messing up the magnitude, so long as you do itconsistently. Still, messing up the magnitude makes things messy: if you’re notcareful, it could easily lead to more relevant errors later. So best to handleeverything consistently, and make the appropriate division.</p><p>它实际上并不重要：团队成员都了解反馈突钝，“稍微改变模型，以便此数字变得更接近零.ALSO，给我们有关输入的类似反馈。”如果您给他们的反馈，那就太大了，它们会使更改推动零零，它们也将将“真实”的反馈分数推向零。只要你做到这一点，你就无法真正地稳住他们错了。仍然，弄乱幅度让事情凌乱：如果你不当，它可以很容易地在以后导致更相关的错误。如此最好始终如一地处理，并制定适当的划分。</p><p> def  combine_by_average (workers : List [Estimator ] )  - &gt; Estimator :  def  combination_worker_averaging (inputs : Array2d )  - &gt;  float : callbacks  =  [ ] summed  =  0  for worker  in workers : result , callback  = worker (inputs ) summed  += result callbacks .append (worker ) average  = summed  /  len (workers )  def  handle_feedback (re_average :  float )  - &gt; Array2d : re_result  = re_average  /  len (workers ) re_input  = callbacks [ 0 ] (re_result )  for callback  in callbacks [ 1 : ] : re_input  += callback (re_result )  return re_input  return average , handle_feedback  return combination_worker_averaging</p><p> def combine_by_average（workers：list [估算器]） - ＆gt;估算器：def componal_worker_averaging（输入：array2d） - ＆gt; float：callbacks = []求和= 0，适用于工人的工作人员：结果，回调=工作者（输入）求和+ =结果回调.Append（工人）普通=总结/ Len（Worker）Def Handle_feedback（re_average：float） - ＆gt; re_result = re_average / len（workers）re_input =回调回调中的回调[1：]：re_input + =回调（re_result）返回re_input返回平均值，handle_feedback返回componal_worker_averaging</p><p> Looking at this, there’s a lot of obvious duplication with the addition. We’redoing the exact same thing as it, as part of the averaging process. Why don’t wejust make an addition worker, and only implement the averaging step?</p><p> 看了这一点，添加了很多明显的复制品。我们将其与其完全相同的事情，作为平均过程的一部分。为什么不遵守加法工作者，只实施平均步骤？</p><p> def  combine_by_average (workers : List [Estimator ] )  - &gt; Estimator : addition_worker  = combine_by_addition (workers )  def  combination_worker_averaging (inputs : Array2d )  - &gt;  float : summed , handle_summed_feedback  = addition_worker (inputs ) average  = summed  /  len (workers )  def  handle_feedback (re_average :  float )  - &gt; Array2d : re_summed  = re_average  /  len (workers ) re_input  = handle_summed_feedback (re_summed )  return re_input  return average , handle_feedback  return combination_worker_averaging</p><p> def combine_by_average（workers：list [估算器]） - ＆gt;估算器：Accopt_Worker = Combine_By_Addition（Workers）Def Comby_Worker_Averaging（输入：Array2D） - ＆gt; float：summed，handle_summed_feedback =附加_worker（输入）平均= summed / len（workers）def handle_feedback（re_average：float） - ＆gt; array2d：re_summed = re_average / len（workers）re_input = supple_summed_feedback（re_summed）return re_input返回平均值，suppl_feedback返回comby_worker_averaging</p><p> If you only use each worker in one team, and you keep the team sizes fixed, theaddition and averaging approaches end up performing the same. The extra divisionstep doesn’t end up mattering. This actually makes a lot of sense, consideringwhat we realized about the feedback for the averaging: in both approaches, theworkers are going to end up making similar updates, just rescaled — and overtime, they’ll easily recalibrate their outputs to the scaling term, either way.</p><p> 如果您只使用一个团队中的每个工人，并且您将团队尺寸固定，则缩小和平均方法最终表现相同。额外的部门不会最终辞职。这实际上是很有意义的，考虑到我们实现了对平均的反馈意识：在这两种方法中，Workers将最终提出类似的更新，刚刚重新安装 - 加班，他们将轻松地将其输出重新校准到缩放术语，无论哪种方式。</p><p> Summing and averaging are sort of the same, but surely there are other ways theworkers could collaborate? So you go back and read more management books, andeveryone seems to be saying you should just listen to whoever speaks theloudest. None of the books say it  like that, but if you actually followedtheir advice, that’s pretty much what you’d end up doing. This seems reallydumb, but uh… okay, let’s try it? Your team really doesn’t communicate byspeaking, so “loudest” can’t be taken too literally. Let’s take it to meanselecting the highest estimate.</p><p> 求和和平均是有点相同的，但肯定还有其他方式可以合作？所以你回去阅读更多管理书籍，似乎似乎说你应该听听谁说话。没有一本书都说这样的，但如果你实际上跟进了这个建议，那就是你最终做的事情。这似乎真的很棒，但呃......好吧，让我们试试吧？你的团队真的没有录音，所以“最响亮”不能被剥削。让我们接受它来识别最高估计。</p><p> def  combine_by_maximum (workers : List [Estimator ] )  - &gt; Estimator :  def  combination_worker_maximum (inputs : Array2d )  - &gt;  float : max_estimate  =  None handle_for_max  =  None  for worker  in workers : estimate , handle_feedback  = worker (inputs )  if max_estimate  is  None  or estimate  &gt; max_estimate : max_estimate  = estimate handle_for_max  = handle_feedback  return max_estimate , handle_for_max  return combination_worker_maximum</p><p> def combine_by_maximum（workers：list [估算器]） - ＆gt;估算器：def componal_worker_maximum（输入：array2d） - ＆gt; float：max_estimate = none suppl_for_max = none是否有工人的工作者：估计，handle_feedback =如果max_estimate是none或estimate＆gt的工人（输入）。 max_estimate：max_estimate = estimate handle_for_max = handle_feedback return max_estimate，handle_for_max返回modam_worker_maximum </p><p> You combine two workers,  Dani and  Ely, into a new team using thismaximum-based approach, and you can almost feel your bonus slipping away as youput them into action: surely if we’re always taking the maximum, our estimatesare going to climb up and up, right? But to your surprise, that’s not whathappens. The worker who submits the high estimate is the one who gets thefeedback, so they’ll learn not to produce such a high estimate for that inputnext time. Dani and Ely aren’t competing to have their outputs selected — fromtheir perspective, they’re working completely independently. They’re just tryingto make adjustments so that their feedback scores get closer to zero.</p><p>你将两个工人丹尼结合起来，进入一个新的团队，使用基于这个基于amaximp的方法，你几乎可以让你的奖金滑落，因为你进入动作，肯定是我们总是获得最大值，我们的估计是为了攀登和起来，对吧？但是为了你的惊喜，那不是Whathappens。提交高估计的工人是获得FEDBACK的人，所以他们会学会不产生这种INPUTNEXT时间的如此高的估计。丹尼并没有竞争他们的产出所选的 - 从他们的角度来看，他们完全独立工作。他们只是在试图进行调整，以便他们的反馈分数更接近零。</p><p> Is it weird that only the worker with the highest estimate gets any feedback?Shouldn’t we be trying to train all of them based on what we learned from theexample as well? We actually can’t do that, because we don’t have feedback thatrelates to all the outputs: we only submitted one output, so we only getfeedback about that one output. The feedback represents a request for change: ittells the workers how we’d like their output to be different next time, giventhe same input. We don’t know that about the other workers’ estimates, becausewe didn’t submit them.</p><p> 只有最高估计的工人才会获得任何反馈意见吗？我们是否应该尝试根据我们从外申学中学到的东西来训练所有这些？我们实际上不能这样做，因为我们没有反馈到所有输出中的反馈：我们只提交了一个输出，所以我们只留下了一个输出。反馈代表更改的请求：ITTELSS Workers我们在下次相同的情况下，我们希望其输出不同，Giventhe相同的输入。我们不知道关于其他工人的估计，因为我们没有提交他们。</p><p> Your  combine_by_maximum(Dani, Ely) team works surprisingly well, so you decideto break your usual hands-off policy, and actually look at some of the data totry to figure out what’s going on, even going so far as to set up a combine_by_average(Alex, Bo) team for comparison. After a bit of sifting, youdiscover some interesting patterns, especially concerning two of the inputcolumns.</p><p> 你的combine_by_maximum（dani，丹尼）团队令人惊讶地令人惊讶地工作，所以你解救了你平常的脱离政策，实际上看着一些数据，以弄清楚正在发生的事情，即使是建立一个combine_by_average（ Alex，Bo）团队进行比较。经过一点筛分，youdiscover一些有趣的模式，特别是关于两个inputColumns。</p><p> Based on the estimates and feedback, you see that if the inputs have a 1 in thecolumn labelled “Located in California”, that generally means the estimatesshould be higher. There’s also a column labelled “Renewable Energy”, and a 1 forthat also leads to higher estimates, generally. But when there’s a 1 for bothcolumns, the estimates should come out a fair bit lower than you’d expect, basedon the two columns individually.</p><p> 基于估计和反馈，您可以看到，如果输入在TheColumn标记为“位于加利福尼亚州”中，则通常意味着估计值得更高。还有一个标有“可再生能源”的专栏，一般也导致估计更高。但是，当两个科学家来说，估计值应该比你预期的价格低得分，这是一系列单独的两列。</p><p> The  combine_by_average(Alex, Bo) team is really struggling with this: whateverthey’re doing individually, it’s not taking this combination factor into account— they’re both overshooting on the  California+Renewable examples, and whenthere’s a run of those examples, they start  undershooting on the examples thatare just  California or just  Renewable. The average doesn’t help.</p><p> combine_by_average（alex，bo）团队真的在努力解决这个问题：无论有什么单独做的，它都没有将这种组合因素置于账户 - 他们都在加州+可再生例子的过度处理，而且他们的普遍存在的情况仅仅在那些只是加利福尼亚州或只是可再生的例子上开始强壮。平均来没有帮助。</p><p>  While the averaging doesn’t help, the  combine_by_maximum(Dani, Ely) teammanages to follow their individual feedbacks to an interesting “collaborative”solution. Effectively, the  max operation allows the workers to “specialise”:Dani doesn’t worry about examples outside of California, and Ely doesn’t worryabout projects that don’t concern renewables. This means Ely’s weighting for“California” is really a w</p><p>  虽然平均没有帮助，但Combine_By_Maximum（Da​​ni，Iely）TeamManages遵循他们的个人反馈到一个有趣的“协作”解决方案。有效地，最大操作允许工人“专注”：Dani不用担心加利福尼亚州以外的例子，而且不会担心不符合可再生能源的项目。这意味着对“加利福尼亚”的加权是一个w</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://thinc.ai/docs/backprop101">https://thinc.ai/docs/backprop101</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/反馈/">#反馈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>