<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>出于错误的原因，正确的做法是：牙线并不意味着安全The right thing for the wrong reasons: FLOSS doesn't imply security</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The right thing for the wrong reasons: FLOSS doesn't imply security<br/>出于错误的原因，正确的做法是：牙线并不意味着安全</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 15:50:58</div><div class="page_narrow text-break page_content"><p>I find it quite easy to handle views different from my own. I feel more troubled when I see people agree with me for the wrong reasons.</p><p>我发现处理不同于我自己的观点很容易。当我看到人们以错误的理由同意我的观点时，我会感到更不安。</p><p> It’s no secret that I’m a passionate supporter of software freedom: I’ve written two posts about how Free, Libre, and Open-Source software ( FLOSS) is necessary but insufficient to preserve user autonomy:</p><p>我是软件自由的热情支持者，这已经不是什么秘密了：我写了两篇文章，阐述了自由、自由和开源软件（FLOSS）对维护用户自主性的必要性，但还不够：</p><p> Whatsapp and the Domestication of Users The phenomenon of a class of predatory businesses models I call “user domestication” and defense measures: FLOSS, open platforms, and simplicity.</p><p>Whatsapp和用户本土化一类掠夺性商业模式的现象我称之为“用户本土化”和防御措施：牙线、开放平台和简单性。</p><p> Keeping Platforms Open How open platforms can lose their openness, and what measures can prevent this. The Web, XMPP, email, and Matrix are examples that highlight both sides of the issue.</p><p>保持平台开放开放平台如何失去开放性，以及有什么措施可以防止这种情况。Web、XMPP、电子邮件和矩阵都是突出问题双方的例子。</p><p>  One of the biggest parts of the Free and Open Source Software definitions is the freedom to study a program and modify it; in other words, access to editable source code. I agree that such access is essential; however, far too many people support source availability for the  wrong reasons. One such reason is that source code is necessary to have any degree of transparency into how a piece of software operates, and is therefore necessary to determine if it is at all secure or trustworthy. Although security through obscurity is certainly not a robust measure, this claim has two issues:</p><p>自由开源软件定义中最大的一个部分是研究和修改程序的自由；换句话说，访问可编辑的源代码。我同意这种接触是必要的；然而，太多人出于错误的原因支持源可用性。其中一个原因是，源代码对软件的运行方式具有一定程度的透明性是必要的，因此有必要确定它是否安全或可信。虽然通过模糊性实现安全性肯定不是一个可靠的措施，但这种说法有两个问题：</p><p> Source code describes what a program is designed to do; it is unnecessary and insufficient to determine if what it actually does aligns with its intended design.</p><p>源代码描述程序的设计目的；确定其实际功能是否与预期设计相符是不必要且不充分的。</p><p> I’d like to expand on these issues, focusing primarily on compiled binaries. Bear in mind that I do not think that source availability is  useless from a security perspective (it certainly makes audits easier), and I  do think that source availability is required for user freedom. I’m arguing only that  source unavailability doesn’t imply insecurity, and  source availability doesn’t imply security. It’s possible (and often preferable) to perform security analysis on binaries, without necessarily having source code. In fact, vulnerability discovery doesn’t typically rely on source code analysis.</p><p>我想进一步讨论这些问题，主要关注已编译的二进制文件。请记住，我不认为从安全角度来看，源可用性是无用的（这当然会使审核更容易），我确实认为源可用性是用户自由所必需的。我只是认为源不可用并不意味着不安全，源可用性也不意味着安全。对二进制文件执行安全性分析是可能的（而且通常更可取），而不一定要有源代码。事实上，漏洞发现通常不依赖于源代码分析。</p><p> PS: this stance is not absolute; I concede to several good counter-arguments 	 at the bottom!</p><p>附言：这种立场不是绝对的；我承认底部有几个很好的反驳！</p><p>  I don’t think anyone seriously claims that software’s security instantly improves the second its source code is published. The argument I’m responding to is that source code is necessary to understand what a program does and how (in)secure it is, and without it we can’t know for sure.</p><p>我不认为有人真的认为软件的安全性会在源代码发布后立即得到改善。我要回应的论点是，源代码对于理解一个程序的功能和安全性是必要的，没有它我们就无法确定。</p><p> Assuming a re-write that fundamentally changes a program’s architecture is not an option  1, software security typically improves by fixing vulnerabilities via something resembling this process:</p><p>假设从根本上改变程序架构的重写不是选项1，软件安全通常会通过类似以下过程的方式修复漏洞来提高：</p><p>  Source code is typically helpful (sometimes essential) to Step 3. If someone has completed Step 3, they will require source code in order to proceed to Step 4. Source code  isn’t necessary for Steps 1 and 2; these steps rely on understanding how a program misbehaves. For that, we use  reverse engineering and/or  fuzzing.</p><p>源代码通常对第3步很有帮助（有时是必不可少的）。如果有人完成了步骤3，他们将需要源代码才能继续执行步骤4。步骤1和2不需要源代码；这些步骤依赖于理解程序的错误行为。为此，我们使用逆向工程和/或模糊化。</p><p>  Understanding  how a program is designed is not the same as understanding  what a program does. A reasonable level of one type of understanding does not imply the other.</p><p>理解一个程序是如何设计的和理解一个程序做什么是不一样的。一种理解的合理水平并不意味着另一种。</p><p> Source code  2 is essential to describe a program’s high-level, human-comprehensible design; it represents a contract that outlines how a developer  expects a program to behave. A compiler or interpreter  3 must then translate it into machine instructions. But source code isn’t always easy to map directly to machine instructions because it is part of a complex system:</p><p>源代码2对于描述程序的高级、人类可理解的设计至关重要；它代表了一份合同，概述了开发人员对程序的预期行为。然后，编译器或解释器3必须将其翻译成机器指令。但源代码并不总是容易直接映射到机器指令，因为它是复杂系统的一部分：</p><p> Compilers (sometimes even interpreters) can apply optimizations and hardening measures that are difficult to reason about. This is especially true for  JIT compilers that leverage run-time information.</p><p>编译器（有时甚至是解释器）可以应用难以推理的优化和强化措施。对于利用运行时信息的JIT编译器来说尤其如此。</p><p> The operating system itself may be poorly understood by the developers, and run a program in a way that contradicts a developer’s expectations.</p><p>开发人员可能不太了解操作系统本身，并且以与开发人员期望相矛盾的方式运行程序。</p><p>   All of the above points apply to each dependency and the underlying operating system, which can impact a program’s behavior.</p><p>以上所有要点都适用于每个依赖项和底层操作系统，这可能会影响程序的行为。</p><p> Furthermore, all programmers are flawed mortals who don’t always fully understand source code. Everyone who’s done a non-trivial amount of programming is familiar with the feeling of encountering a bug during run-time for which the cause is impossible to find…until they notice it staring them in the face on Line 12. Think of all the bugs that  aren’t so easily noticed.</p><p>此外，所有程序员都是有缺陷的凡人，他们并不总是完全理解源代码。每一个做过大量编程的人都熟悉在运行时遇到错误的感觉，原因是不可能找到的……直到他们注意到它在第12行盯着他们看。想想那些不容易被注意到的错误。</p><p> Reading the source code, compiling, and passing tests isn’t sufficient to show us a program’s final behavior. The only way to know what a program does when you run it is to…run it.  4</p><p>阅读源代码、编译并通过测试并不足以向我们展示程序的最终行为。知道程序在运行时做什么的唯一方法是…运行它。4.</p><p>  Almost all programmers are fully aware of their limited ability, which is why most already employ techniques to analyze run-time behavior that don’t depend on source code. For example, developers of several compiled languages  5 can build binaries with sanitizers to detect undefined behavior, races, uninitialized reads, etc. that human eyes may have missed when reading source code. While source code is necessary to  build these binaries, it isn’t necessary to run them and observe failures.</p><p>几乎所有的程序员都充分意识到自己的能力有限，这就是为什么大多数程序员已经使用不依赖源代码的技术来分析运行时行为。例如，几种编译语言5的开发人员可以构建带有净化程序的二进制文件，以检测人眼在读取源代码时可能错过的未定义行为、种族、未初始化读取等。虽然构建这些二进制文件需要源代码，但没有必要运行它们并观察失败。</p><p> Distributing binaries with sanitizers and debug information to testers is a valid way to collect data about a program’s potential security issues.</p><p>向测试人员分发带有消毒器和调试信息的二进制文件是收集有关程序潜在安全问题的数据的有效方法。</p><p>  It’s hard to figure out which syscalls and files a large program program needs by reading its source, especially when certain libraries (e.g. the libc implementation/version) can vary. A syscall tracer like   strace(1)  6 makes the process trivial.</p><p>通过读取大型程序的源代码，很难确定它需要哪些系统调用和文件，尤其是在某些库（例如libc实现/版本）可能不同的情况下。像strace（1）6这样的系统调用跟踪器使这个过程变得微不足道。</p><p> A personal example: the understanding I gained from  strace was necessary for me to write my  bubblewrap scripts. These scripts use   bubblewrap(1) to sandbox programs with the minimum permissions possible. Analyzing every relevant program and library’s source code would have taken me months, while  strace gave me everything I needed to know in an afternoon: analyzing the  strace output told me exactly which syscalls to allow and which files to grant access to, without even having to know what language the program was written in. I generated the initial version of the syscall allow-lists with the following command  7:</p><p>个人例子：我从strace那里获得的理解对我编写bubblewrap脚本是必要的。这些脚本使用BubbleRap（1）以尽可能低的权限对程序进行沙箱处理。分析每一个相关的程序和库的源代码都会花费我几个月的时间，而strace在一个下午就给了我我需要知道的一切：分析strace的输出会准确地告诉我允许哪些系统调用以及允许访问哪些文件，甚至不需要知道程序是用什么语言编写的。我使用以下命令7生成了syscall allow list的初始版本：</p><p> strace name-of-program program-args 2&gt;&amp;1 \	| rg &#39;^([a-z_]*)\(.*&#39; --replace &#39;$1&#39; \	| sort | uniq</p><p>程序args 2的strace名称&gt&amp；1\|rg&#39^（[a-z]*）\（.&#39；--替换&#39；$1&#39；\|排序| uniq</p><p> This also extends to determining how programs utilize the network: packet sniffers like  Wireshark can determine when a program connects to the network, and where it connects.</p><p>这还扩展到确定程序如何利用网络：Wireshark等数据包嗅探器可以确定程序何时连接到网络，以及连接到哪里。</p><p> These methods are not flawless. Syscall tracers are only designed to shed light on how a program interacts with the kernel. Kernel interactions tell us plenty (it’s sometimes all we need), but they don’t give the whole story. Furthermore, packet inspection can be made a bit painful by transit encryption  8; tracing a program’s execution alongside packet inspection can offer clarity, but this is not easy.</p><p>这些方法并非完美无缺。系统调用跟踪器的设计只是为了阐明程序如何与内核交互。内核交互告诉了我们很多（有时这是我们所需要的），但它们并不能说明全部情况。此外，通过传输加密8，包检查可能会有点痛苦；跟踪程序的执行和数据包检查可以提供清晰的信息，但这并不容易。</p><p> For more information, we turn to   core dumps, also known as memory dumps. Core dumps share the state of a program during execution or upon crashing, giving us greater visibility into exactly what data a program is processing. Builds containing debugging symbols (e.g.  DWARF) have more detailed core dumps. Vendors that release daily snapshots of pre-release builds typically include some symbols to give testers more detail concerning the causes of crashes. Web browsers are a common example: Chromium dev snapshots, Chrome Canary, Firefox Nightly, WebKit Canary builds, etc. all include debug symbols. Until recently,  Minecraft: Bedrock Edition included debug symbols which were used heavily by the modding community.  9</p><p>更多信息，我们转向核心转储，也称为内存转储。内核转储共享程序在执行期间或崩溃时的状态，让我们更清楚地了解程序正在处理的数据。包含调试符号（例如DWARF）的构建有更详细的核心转储。发布预发布版本的每日快照的供应商通常会包含一些符号，以向测试人员提供有关崩溃原因的更多细节。Web浏览器是一个常见的例子：Chrome开发快照、Chrome Canary、Firefox Nightly、WebKit Canary构建等等。所有这些都包括调试符号。直到最近，Minecraft:Basefine版还包括调试符号，这些符号被modding社区大量使用。9</p><p>  In 2020, Zoom Video Communications came under scrutiny for marketing its “Zoom” software as a secure, end-to-end encrypted solution for video conferencing. Zoom’s documentation claimed that it used “AES-256” encryption. Without source code, did we have to take the docs at their word?</p><p>2020年，Zoom Video Communications因将其“Zoom”软件作为安全的端到端加密视频会议解决方案进行营销而受到审查。Zoom的文档声称它使用了“AES-256”加密。如果没有源代码，我们是否必须按照文档的要求行事？</p><p> The Citizen Lab didn’t. In April 2020, it published  a report revealing critical flaws in Zoom’s encryption. It utilized Wireshark and  mitmproxy to analyze networking activity, and inspected core dumps to learn about its encryption implementation. The Citizen Lab’s researchers found that Zoom actually used an incredibly flawed implementation of a weak version of AES-128 (ECB mode), and easily bypassed it.</p><p>公民实验室没有。2020年4月，它发布了一份报告，揭示了Zoom加密的关键缺陷。它利用Wireshark和mitmproxy分析网络活动，并检查核心转储以了解其加密实现。公民实验室的研究人员发现，Zoom实际上使用了一个缺陷极大的AES-128弱版本（ECB模式）实现，并且很容易绕过它。</p><p> Syscall tracing, packet sniffing, and core dumps are great, but they rely on manual execution which might not hit all the desired code paths. Fortunately, there are other forms of analysis available.</p><p>系统调用跟踪、数据包嗅探和核心转储都很好，但它们依赖于手动执行，而手动执行可能不会命中所有所需的代码路径。幸运的是，还有其他形式的分析可用。</p><p>  Tracing execution and inspecting memory dumps can be considered forms of reverse engineering, but they only offer a surface-level view of what’s going on. Reverse engineering gets much more interesting when we analyze a binary artifact.</p><p>跟踪执行和检查内存转储可以被视为逆向工程的形式，但它们只提供了正在发生的事情的表面视图。当我们分析二进制工件时，逆向工程变得更加有趣。</p><p> Static binary analysis is a powerful way to inspect a program’s underlying design. Decompilation (especially when supplemented with debug symbols) can re-construct a binary’s assembly or source code. Symbol names may look incomprehensible in stripped binaries, and comments will be missing. What’s left is more than enough to decipher control flow to uncover how a program processes data. This process can be tedious, especially if a program uses certain forms of binary obfuscation.</p><p>静态二进制分析是检查程序底层设计的强大方法。反编译（尤其是在添加调试符号时）可以重新构造二进制程序集或源代码。符号名称在精简的二进制文件中可能看起来不可理解，注释也将丢失。剩下的足以破译控制流，揭示程序如何处理数据。这个过程可能会很乏味，尤其是当程序使用某种形式的二进制模糊处理时。</p><p> The goal doesn’t have to be a complete understanding of a program’s design (incredibly difficult without source code); it’s typically to answer a specific question, fill in a gap left by tracing/fuzzing, or find a well-known property. When developers publish documentation on the security architecture of their closed-source software, reverse engineering tools like decompilers are exactly what you need to verify their honesty (or lack thereof).</p><p>目标不一定是完全理解一个程序的设计（没有源代码是非常困难的）；它通常是为了回答一个特定的问题，填补跟踪/模糊留下的空白，或者找到一个著名的属性。当开发人员发布关于其封闭源代码软件的安全体系结构的文档时，反编译器等逆向工程工具正是验证其诚实性（或缺乏诚实性）所需要的。</p><p> Decompilers are seldom used alone in this context. Instead, they’re typically a component of reverse engineering frameworks that also sport memory analysis, debugging tools, scripting, and sometimes even IDEs. I use  the radare project, but  Ghidra is also popular. Their documentation should help you get started if you’re interested.</p><p>在这种情况下，反编译器很少单独使用。相反，它们通常是逆向工程框架的一个组成部分，也支持内存分析、调试工具、脚本编写，有时甚至是IDE。我用的是radare项目，但Ghidra也很受欢迎。如果你感兴趣，他们的文档可以帮助你开始。</p><p>  These reverse-engineering techniques–a combination of tracing, packet sniffing, binary analysis, and memory dumps–make up the workings of most modern malware analysis. See  this example of a fully-automated analysis of the Zoom Windows installer. It enumerates plenty of information about Zoom without access to its source code: reading unique machine information, anti-VM and anti-reverse-engineering tricks, reading config files, various types of network access, reading info on mounted volumes, and more.</p><p>这些反向工程技术——追踪、数据包嗅探、二进制分析和内存转储的组合——构成了大多数现代恶意软件分析的工作原理。请参见此Zoom Windows安装程序的全自动分析示例。它列举了大量有关Zoom的信息，而无需访问其源代码：读取唯一的机器信息、反VM和反反向工程技巧、读取配置文件、各种类型的网络访问、读取已装入卷的信息，等等。</p><p> To try this out yourself, use a sandbox designed for dynamic analysis.  Cuckoo is a common and easy-to-use solution, while  DRAKVUF is more advanced.</p><p>要亲自尝试，请使用为动态分析设计的沙盒。布谷鸟是一种常见且易于使用的解决方案，而德拉克夫则更为先进。</p><p>  The Intel Management Engine (ME) is a mandatory subsystem of all Intel processors (after 2008) with extremely privileged access to the host system. Active Management Technology (AMT) runs atop it on the subset of Intel processors with “vPro” branding. The latter can be disabled and is intended for organizations to remotely manage their inventory (installing software, monitoring, remote power-on/sleep/wake, etc).</p><p>英特尔管理引擎（ME）是所有英特尔处理器（2008年之后）的必选子系统，对主机系统具有极高的访问权限。主动管理技术（AMT）运行在带有“vPro”品牌的英特尔处理器子集上。后者可以被禁用，用于组织远程管理其库存（安装软件、监控、远程通电/睡眠/唤醒等）。</p><p> The fact that Intel ME has such deep access to the host system and the fact that it’s proprietary have both made it the subject of a high degree of scrutiny. Many people (most of whom have little experience in the area) connected these two facts together to allege that the ME is a backdoor, often by confusedly citing functionality of Intel AMT instead of ME. Is it really impossible to know for sure?</p><p>Intel ME对主机系统的访问如此深入，而且它是专有的，这两个事实都使它成为了高度审查的主题。许多人（大多数人在这方面几乎没有经验）将这两个事实联系在一起，声称ME是一个后门，通常是通过混淆地引用Intel AMT的功能而不是ME。真的不可能确定吗？</p><p> I picked Intel ME+AMT to serve as an extreme example: it shows both the power and limitations of the analysis approaches covered. ME isn’t made of simple executables you can just run in an OS because it sits far below the OS, in what’s sometimes called “Ring -3”.  10 Analysis is limited to external monitoring (e.g. by monitoring network activity) and reverse-engineering unpacked partially-obfuscated firmware updates, with help from official documentation. This is slower and harder than analyzing a typical executable or library.</p><p>我选择“英特尔ME+AMT”作为一个极端的例子：它显示了所涵盖的分析方法的威力和局限性。ME不是由简单的可执行文件组成的，你可以在操作系统中运行，因为它位于操作系统的下方，有时被称为“Ring-3”。10分析仅限于外部监测（例如，通过监测网络活动）和反向工程（在官方文件的帮助下，未打包的部分模糊固件更新）。这比分析典型的可执行文件或库更慢、更难。</p><p> Answers are a bit complex and…more boring than what sensationalized headlines would say. Reverse engineers such as Igor Skochinsky and Nicola Corna (the developers of  me-tools and  me_cleaner, respectively) have  analyzed ME, while researchers such as Vassilios Ververis have  thoroughly analyzed AMT in 2010. Interestingly, the former pair argues that auditing binary code is preferable to source code.</p><p>答案有点复杂……比耸人听闻的头条新闻更无聊。伊戈尔·斯科钦斯基（Igor Skochinsky）和尼古拉·科纳（Nicola Corna，分别是me tools和me_cleaner的开发者）等逆向工程师对me进行了分析，而瓦西里奥斯·维弗里斯（Vassilios Verververis）等研究人员在2010年对AMT进行了彻底的分析。有趣的是，前两人认为审计二进制代码比审计源代码更可取。</p><p> Simply monitoring network activity and systematically testing all claims made by the documentation allowed Ververis to uncover a host of security issues in Intel AMT. However, no undocumented features have (to my knowledge) been uncovered. The problematic findings revolved around flawed/insecure implementations of documented functionality. In other words: there’s been no evidence of AMT being “a backdoor”, but its security flaws could have had a similar impact. Fortunately, AMT can be disabled. What about ME?</p><p>只需监控网络活动并系统地测试文档中的所有声明，Ververis就可以发现Intel AMT中的大量安全问题。然而，据我所知，还没有发现任何未记录的特征。这些有问题的发现围绕着有缺陷/不安全的文档化功能实现展开。换句话说：没有证据表明AMT是“后门”，但它的安全缺陷可能也有类似的影响。幸运的是，AMT可以被禁用。那我呢？</p><p> This is where some binary analysis comes in. Neither Skochinsky’s  ME Secrets presentation nor the  previously-linked one he gave with Corna seem to enumerate any contradictions with  official documentation.</p><p>这就是一些二进制分析的用武之地。无论是斯科钦斯基的《我的秘密》演讲，还是之前他与科纳的关联演讲，似乎都没有列举任何与官方文件相矛盾的地方。</p><p> Unfortunately, some components are poorly understood due to being obfuscated using  Huffman compression with unknown dictionaries. Understanding the inner workings of the obfuscated components blurs the line between software reverse-engineering and figuring out how the chips are actually made, the latter of which is nigh-impossible if you don’t have access to a chip lab full of cash. However, black-box analysis does tell us about the capabilities of these components: see page 21 of “ME Secrets”. Thanks to zdctg for clarifying this.</p><p>不幸的是，由于使用哈夫曼压缩和未知字典进行混淆，一些组件的理解很差。了解模糊组件的内部工作原理模糊了软件逆向工程和芯片实际制造之间的界限，如果你没有足够的资金进入芯片实验室，后者几乎是不可能的。然而，黑盒分析确实告诉我们这些组件的功能：请参阅“我的秘密”第21页。感谢zdctg对此的澄清。</p><p> Skochinsky’s and Corna’s analysis was sufficient to clarify (but not completely contradict) sensationalism claiming that ME can remotely lock any PC (it was a former opt-in feature), can spy on anything the user does (they clarified that access is limited to unblocked parts of the host memory and the integrated GPU, but doesn’t include e.g. the framebuffer), etc.</p><p>Skochinsky和Corna的分析足以澄清（但并非完全反驳）耸人听闻的说法，即ME可以远程锁定任何PC（这是以前的选择加入功能），可以监视用户所做的任何事情（他们澄清，访问仅限于主机内存和集成GPU的未阻塞部分，但不包括帧缓冲区等），等等。</p><p> While claims such as “ME is a black box that can do anything” are misleading, ME not without its share of vulnerabilities. My favorite look at its issues is a presentation by Mark Ermolov and Maxim Goryachy at Black Hat Europe 2017:  How to Hack a Turned-Off Computer, or Running Unsigned Code in Intel Management Engine.</p><p>虽然诸如“我是一个可以做任何事情的黑匣子”之类的说法是误导性的，但我并非没有自己的弱点。我最喜欢看的问题是马克·埃莫洛夫和马克西姆·戈里亚希在2017年黑帽欧洲大会上的演讲：如何破解关闭的计算机，或在英特尔管理引擎中运行未签名的代码。</p><p> In short: ME being proprietary doesn’t mean that we can’t find out how (in)secure it is. Binary analysis when paired with runtime inspection can give us a good understanding of what trade-offs we make by using it. While ME has a history of serious vulnerabilities, they’re nowhere near what  borderline conspiracy theories claim.  11</p><p>简言之：我拥有所有权并不意味着我们无法了解它的安全性。二元分析与运行时检查相结合，可以让我们很好地理解使用二元分析所做的权衡。虽然我有过严重的脆弱性历史，但它们与边缘阴谋论所宣称的相去甚远。11</p><p> (Note: Intel is not alone here. Other chips typically have equivalents, e.g. AMD Secure Technology).</p><p>（注：英特尔并不是唯一一家这样做的公司。其他芯片通常也有类似的产品，例如AMD安全技术）。</p><p>  Manual invocation of a program paired with a tracer like  strace won’t always exercise all code paths or find edge-cases.  Fuzzing helps to bridge this gap: it automates the process of causing a program to fail by generating random or malformed data to feed it. Researchers then study failures and failure-conditions to isolate a bug.</p><p>手动调用一个与strace这样的跟踪器相匹配的程序并不总是能够执行所有代码路径或找到边缘情况。模糊化有助于弥合这一差距：它通过生成随机或格式错误的数据来为程序提供数据，从而使导致程序失败的过程自动化。然后，研究人员研究故障和故障条件，以隔离一个bug。</p><p> Fuzzing doesn’t necessarily depend on access to source code, as it is a black-box technique. Fuzzers like  American Fuzzy Loop (AFL) normally use 	 special builds, but  other fuzzing setups can work with just about any binaries. In fact, some types of fuzz tests (e.g.  fuzzing an API for a web service) hardly need any implementation details.</p><p>模糊不一定依赖于对源代码的访问，因为它是一种黑盒技术。像American Fuzzy Loop（AFL）这样的模糊程序通常使用特殊的构建，但其他模糊设置可以使用几乎任何二进制文件。事实上，某些类型的模糊测试（例如，模糊web服务的API）几乎不需要任何实现细节。</p><p> Fuzzing frequently catches bugs that are only apparent by running a program, not by reading source code. Even so, the biggest beneficiaries of fuzzing are open source projects.  cURL,  OpenSSL, web browsers, text rendering libraries (HarfBuzz, FreeType) and toolchains (GCC, Clang, the official Go toolchain, etc.) are some notable examples.     wrote about  fuzzing curl:</p><p>Fuzzing经常捕获只有通过运行程序而不是通过读取源代码才能发现的bug。即便如此，模糊化的最大受益者还是开源项目。cURL、OpenSSL、web浏览器、文本呈现库（HarfBuzz、FreeType）和工具链（GCC、Clang、官方Go工具链等）都是一些值得注意的例子。写了关于起毛卷曲：</p><p> I&#39;ve said it before but let me say it again: fuzzing is really the top method to find problems in curl once we&#39;ve fixed all flaws that the static analyzers we use have pointed out. The primary fuzzing for curl is done by OSS-Fuzz, that tirelessly keeps hammering on the most recent curl code.</p><p>我&#39；我以前说过，但让我再说一遍：一旦我们&#39；我们修复了静态分析器指出的所有缺陷。curl的主要fuzzing是由OSS Fuzz完成的，它不懈地不断修改最新的curl代码。</p><p> If you want to get started with fuzzing, I recommend checking out  the quick-start guide for American Fuzzy Loop. Some languages like Go 1.18 also have fuzzing tools available right in the standard library.</p><p>如果你想开始模糊化，我建议你看看《美国模糊循环快速入门指南》。Go 1.18等一些语言的标准库中也提供了模糊工具。</p><p>  A recent example of how fuzzing helps spot a vulnerability in an open-source project is  CVE-2022-0185: a Linux 0-day found by the Crusaders of Rust a few weeks ago. It was discovered using the  syzkaller kernel fuzzer. The process was documented on Will’s Root:</p><p>最近的一个例子是CVE-2022-0185，它说明了模糊处理如何帮助发现开源项目中的漏洞：几周前，Crustaders of Rust发现了一个Linux 0-day。它是使用SyzCaller内核模糊器发现的。该过程记录在Will的根目录中：</p><p>  I  highly encourage giving it a read; it’s the perfect example of fuzzing with sanitizers to find a vulnerability, reproducing the vulnerability (by writing a tiny C program),  then diving into the source code to find and fix the cause, and finally reporting the issue (with a patch!). When source isn’t available, the vendor would assume responsibility for the “find and fix” steps.</p><p>我强烈建议大家读一读；这是一个完美的例子，可以使用消毒剂进行模糊处理，找到漏洞，复制漏洞（通过编写一个小型C程序），然后深入源代码查找并修复原因，最后报告问题（使用补丁！）。当来源不可用时，供应商将承担“查找并修复”步骤的责任。</p><p> The fact that some of the most-used pieces of FLOSS in existence have been the biggest beneficiaries of source-agnostic approaches to vulnerability analysis should be quite revealing. The source code to these projects has received attention from millions of eyes, yet they  still invest in fuzzing infrastructure and vulnerability-hunters prefer analyzing artifacts over inspecting the source.</p><p>现有的一些最常用的牙线是脆弱性分析中来源不可知方法的最大受益者，这一事实应该很有启发性。这些项目的源代码已经受到了数百万人的关注，但他们仍然投资于模糊基础设施，漏洞搜寻者更喜欢分析工件而不是检查源代码。</p><p>  I readily concede to several points in favor of source availability from a security perspective:</p><p>从安全角度来看，我很乐意承认几点支持源可用性：</p><p> Source code can make analysis  easier by  supplementing source-independent approaches. The lines between the steps I mentioned in the 	 four-step vulnerability-fixing process are blurry.</p><p>源代码可以通过补充与源代码无关的方法来简化分析。我在四步漏洞修复过程中提到的步骤之间的界限很模糊。</p><p> Patching vulnerabilities is important. Source availability makes it possible for the community, package maintainers, or reporters of a vulnerability to patch software. Package maintainers often blur the line between “packager” and “contributor” by helping projects migrate away from abandoned/insecure dependencies. One example that comes to mind is the Python 2 to Python 3 transition for projects like Calibre.  12 Being able to fix issues independent of upstream support is an important mitigation against  user domestication.</p><p>修补漏洞很重要。源可用性使社区、软件包维护人员或报告者能够发现补丁软件的漏洞。软件包维护人员经常通过帮助项目从废弃/不安全的依赖关系中迁移，模糊“打包者”和“贡献者”之间的界限。想到的一个例子是针对Calibre等项目的Python 2到Python 3的转换。12能够独立于上游支持解决问题，是防止用户驯化的重要措施。</p><p> Some developers/vendors don’t distribute binaries that make use of modern toolchain-level exploit mitigations (e.g.  PIE,  RELRO, stack canaries, automatic variable initialization,   CFI, etc.  13). In these cases, building software yourself with these mitigations (or delegating it to a distro that enforces them) requires source code availability (or at least some sort of intermediate representation).</p><p>一些开发人员/供应商不发布使用现代工具链级漏洞缓解措施的二进制文件（例如PIE、RELRO、stack Canaris、自动变量初始化、CFI等13）。在这些情况下，使用这些缓解措施自己构建软件（或将其委托给实施这些缓解措施的发行版）需要源代码可用性（或至少某种中间表示）。</p><p> Closed-source software may or may not have builds available that include sanitizers and debug symbols.</p><p>封闭源代码软件可能有也可能没有包含消毒器和调试符号的可用版本。</p><p> Although fuzzing release binaries is possible, fuzzing is much easier to do when source code is available. Vendors of proprietary software seldom release special fuzz-friendly builds, and filtering out false-positives can be quite tedious without understanding high-level design.</p><p>虽然模糊化发布二进制文件是可能的，但在源代码可用时，模糊化要容易得多。专有软件的供应商很少发布特殊的模糊友好版本，如果不了解高级设计，过滤误报可能会非常繁琐。</p><p> It is certainly possible to notice a vulnerability in source code. Excluding low-hanging fruit typically caught by static code analysis and peer review, it’s not the main way most vulnerabilities are found nowadays (thanks to    for  reminding me about what source analysis does accomplish).</p><p>当然，在源代码中可能会发现一个漏洞。除了静态代码分析和同行评审通常会带来的低效成果外，这并不是当今发现大多数漏洞的主要方式（感谢您提醒我源代码分析的作用）。</p><p> Software as a Service can be incredibly difficult to analyze, as we typically have little more than the ability to query a server. Servers don’t send core dumps, server-side binaries, or trace logs for analysis. Furthermore, it’s difficult to verify which software a server is running.  14 For services that require trusting a server, access to the server-side software is important from both a security and a user-freedom perspective</p><p>软件即服务的分析可能非常困难，因为我们通常只具备查询服务器的能力。服务器不发送核心转储、服务器端二进制文件或跟踪日志进行分析。此外，很难验证服务器正在运行哪个软件。14对于需要信任服务器的服务，从安全和用户自由的角度来看，访问服务器端软件都很重要</p><p> Most of this post is written with the assumption that binaries are inspectable and traceable. Binary obfuscation and some forms of content protection/ DRM violate this assumption and actually do make analysis more difficult.</p><p>本文的大部分内容都假设二进制文件是可检查和可追踪的。二进制混淆和某些形式的内容保护/DRM违反了这一假设，实际上会使分析变得更加困难。</p><p> Beyond source code, transparency into the development helps assure users of complianc</p><p>除了源代码，开发过程的透明度有助于确保用户遵守</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reasons/">#reasons</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>