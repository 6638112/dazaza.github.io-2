<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>凭借读过太多“教程”的人的函数和Monads </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">凭借读过太多“教程”的人的函数和Monads </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 08:44:01</div><div class="page_narrow text-break page_content"><p>标题实际上是真的。这可能不是第一次了解这些概念的最佳位置，因为我将专注于敲击对他们的误解。</p><p>  我曾答应自己，我不会加入堆上的函件或monad＆＃34;教程＆＃34;但我戴着斗争。当我看到一个红线评论时，抱怨归赛跑者是如何理解的，这太难以理解了，这让我感到难过，因为对函数界面的正确响应是，＆＃34;那个＆＃39; s它？＆＃34;。虽然Monad合法有点有趣和复杂，但对这不是一个不同的反应。</p><p> 我知道人们的臭名昭着的影响;＆＃34; Monads然后发布他们自己的特质，占据了他们。在我的辩护中，这不是我写的东西在我的＆＃34之后写的东西！啊哈！＆＃34;时刻，我在Haskell＆＃39的情况下了解他们多年的上下文，实际上......这个不是关于那个＆＃34;啊HA！＆＃34;一瞬间。这只是关于它们的东西。即使你完全了解我在这篇文章中写的一切，也是真实的＆＃34;啊哈！＆＃34;在哪里实现了Monad接口周围建立的图书馆的有用是有用的，首次搜索＆＃39的obogle上的类型; re喜欢这应该存在，事实证明它实际上已经存在，那个＆＃39仍然在你的未来。事实上，我很故意没有试图传达这种感觉，以简单地获得Monad接口是什么。哪个是＆＃39; t，严格来说，这是一个经验的先决条件，但它确实有所帮助。</p><p>    事实：如果您有一个斑点的源头，并且可以将blob变成一件事的函数，您可以将它们放在一起以创建一个事物来源。</p><p>  如果我有一个：一个整数列表，b：一个函数要将整数转换为字符串，我可以轻松地创建c：字符串列表。</p><p> 如果我有一个：一个散列表到字符串，b：将字符串转换为booleans的函数，我可以拥有c：一个整数的哈希表到booleans。</p><p> 杜。明显地。它听起来甚至略微复杂的唯一原因只是英国人＆＃39; t对A＆＃34有很好的相当于一个＆＃34;变量＆＃34;当你与他们判刑时，它总是听起来很复杂。概念本身如果不是ELI5，那么在ELI12范围内。 </p><p>我不会说我从A和B到C到C.每种情况都不同，但每次都很简单。采用更多的英语单词来说它而不是在你喜欢的语言中实施它。</p><p> 什么是归韵特？仿函数是一个接口（或＆＃34; trait＆＃34;＆＃34;概念＆＃34;＆＃34; typeclass＆＃34;或者你的语言偏好;＆＃34;界面＆＃34;从现在开始我故意尝试使用更多常见的术语），允许您将上图作为一流语言元素的事实。在Haskell＆＃39; S案例，通过提供FMAP实现来实现的函数。对于上述示例，该功能将：</p><p> 列表实现：拍摄B中的函数并在所有元素上运行它并返回一个名单，通常称为地图。</p><p> 哈希表实现：拍摄B中的函数并在所有值上运行它，返回具有相同密钥和新值的新哈希表。</p><p> 函数实现：返回运行函数的函数，然后在结果中运行B中的函数。这通常称为功能组合。</p><p> 最后一个是略有棘手的，但是如果你认为他们的隐喻中的函数作为在左侧输入的黑匣子并在右侧提供它们的输出，那就是在右侧猛击它的＆＃39; s刚刚撞击它第一个创造一个新的。这就是为什么我说＆＃34;＆＃34的来源;某物;这里的原理是非常一般的，延伸超出功能，容器和我所拥有的所有其他方便的单词......它适用于您可能获得的任何值。</p><p>   这实际上是它的一切;一种讨论这种简单的操作，在整个一堆类型中讨论了简单的操作。 </p><p>因为甚至在偶尔彻底的作家混乱，它＆＃39;很容易在博客帖子中太兴奋，最终与我们能够建立的东西。</p><p> 我将在本篇文章的其余部分中重复一致化为更常见的界面：迭代器。为什么汇流符＆＃34;重要＆＃34;或＆＃34;有趣的＆＃34 ;?出于同样的原因，迭代器界面是。自编程开始以来存在迭代器，就像＆＃34;仿函数＆＃34;做过。单个迭代器实现通常非常无聊，有时甚至是彻头彻尾的微不足道，例如沿着阵列迭代。但如果你有一堆＆＃34的ad-hoc实现;迭代器＆＃34;那个＆＃39; t融合在一起，你可以＆＃39; t创建一个斜衣包。一旦您有一个常见的合同和连贯的名称，您就可以在曾经是几乎 - 但不相同的实现的混乱混乱的顶部开始建立。</p><p> 作为失踪的语言的现代示例，Go缺少任何类型的语言或图书馆支持和＃34;迭代器＆＃34;，因此共同使用中至少有三个迭代模式，并且常见的常见反饰特（使用范围频道，具有体面的语义，但对于大多数用例而言，性能可怕）。缺乏这一概念，也缺乏迭代机或类似的图书馆等任何东西。</p><p> 它与仿函数完全相同。正如现在可能的各种功能一样并且只知道他们正在服用它们的效果和＃34;迭代器＆＃34;通过命名，连贯＆＃34;函数＆＃34;可以编写语言函数中的概念，从而利用常用功能。</p><p> 重要的是对界面的复杂性进行特定实现的信用复杂性。函数（）字符串的界面后面可以呈现某些特定字符串的常量返回，或者通过获取网页并返回其文本来解释几乎全书的一系列事件......但是后者＆＃39; s复杂性应仅考虑到特定的实现，而不是它可以符合的函数（）字符串接口。</p><p> 类似地，算法可以像映射到列表中的传入功能一样简单，或者它可能需要在数据结构上进行任意复杂的遍历，例如跳过列表和新的一个新的遍历。但这不是一个复杂的操作，因为＆＃34;仿函数复杂，而且它是一个复杂的操作，因为跳过列表很复杂。 Functor接口本身不会占复杂。</p><p> 重要的是不要借鉴我们可以处理迭代器的复杂性以实现界面的实现。可以采取三个迭代器，反转其中一个迭代器，将另外两个与减少函数组合，并仅从结果中占据Prime索引值，但这不会影响迭代器只是函数的事实打电话给Get＆＃34;下一个值＆＃34; </p><p>出于他们自己的原因，数学家使用＆＃34;函数＆＃34;作为一个具体的名词。 Haskell复制了这一点，因此您多久听到一次＆＃34;函授＆＃34;</p><p> 但是，接口是描述数据结构的形容词，这就是为什么它们通常以许多语言命名为可行的后缀（可迭代，可序列化等）程序员更好地忽略它作为可用或欺骗或类似的东西或类似的东西。</p><p> 不幸的是，我们没有＆＃34的预先存在的动词形式;使用函数界面＆＃34;我们的方式＆＃34;迭代＆＃34;对于可迭代或＆＃34;序列化＆＃34;用于序列化。我们最接近的是＆＃34;地图＆＃34;这是欺骗性的，因为该术语通常具有一些具体数据结构的心理形象，可能只是一个列表，映射，尽管它更普遍。我建议采取一个无意义的术语，如功能和拥有它，而不是用正方形概念卡入圆形概念洞。</p><p> 如果你发现自己困惑，我建议＆＃34;可用和＃34;对自己。最终，您将自然地开始听到仿函数只是你对自己的说法的同义词。您也可以考虑＆＃34;功能＆＃34;，它易于靠近＆＃34;功能＆＃34;，但带来＆＃34的想法;我们可以将函数应用于它＆＃34;，尽管是一个具有一定签名的特殊功能。</p><p> 在你现在阅读的帖子的上下文中，这可能会觉得自己是尼特。但是，我认为它实际上是人们对理解函授和Monad界面的问题的重要贡献者。我试图在这篇文章中一直仔细使用这些词语作为形容词，因为当你用它们作为名词时，你会在你对待大多数名词时尝试对待它们时变得非常令人困惑。很多人都说好像你可以拥有＆＃34;一个函数＆＃34;或＆＃34;一个monad＆＃34;在你的手中，开始尝试谈论他们的＆＃34;做＆＃34;从有关具体实施情况的背景下剥夺。但是你可以＆＃39; t这样做，比你能谈论和＃34的具体实施;一个迭代器＆＃34;剥夺了它是一个具体实施的东西。治疗＆＃34; Monad＆＃34;和＆＃34;函数＆＃34;因为名词导致很多混乱。</p><p>  仿函数可以应用于areN＆＃39; t容器的许多东西。我们已经看到了已经有职能的＆＃39。在非Haskell实现中是一个常见的错误，以假设算子实现只能继续容器。</p><p> 当我在线提出这个时，不可避免地有人说＆＃34;嗯，如果你眯着电脑，功能是容器，那些其他东西是容器，所以他们始终在容器上工作。＆＃34 ;对于我说，如果一切都是一个容器，那么这个词容器没有意义。我想你的时候＆＃39;重新渲染有用的词语只是为了符合你的误解，你跳进你的迷宫迷宫，只是迷惑你的镜子。最合理的方法是丢弃误解并理解算子并不总是容器。 </p><p>看起来你呼吁这个功能＆＃34; fmap＆＃34;使用两个参数，一个将一个添加到整数的函数和整数列表。当仿函数被认为是名词时，这可以复合混淆，因为，什么是fmap？也许是＆＃39;＆＃34;函数＆＃34 ;?在OO语言中，函数在它们上没有任何类型的接口分辨率。</p><p>   也就是说，在列表上调用方法。事实上它甚至特别相关，此时＆＃34; fmap＆＃34;参与一个接口，因为这在编译时都是静态可解决的，就像它是许多其他语言一样。这样做，OO程序员没有想象解决解决和＃34; FMAP＆＃34;可能涉及查看列表本身的定义。</p><p> 这不是Haskell如何解析名称。它是一个面向对象的名称。但如果你不想学习Haskell并仅仅想了解所有这一切＆＃34; Monad＆＃34;和＆＃34;函数＆＃34;炒作是，这是一个更好的比喻，因为哈斯克尔正在做什么而不是对FMAP的想法作为某种奇怪的魔法功能。它靠近方法名称解析为＆＃34; fmap＆＃34;在特定数据结构上实现。 （再次，ISN＆＃39; t相当鲜明的;它现在足够接近了。）</p><p>   fmap ::（a  - ＆gt; b） - ＆gt; f a  - ＆gt; F B.</p><p> 这只是说，如果你有一种拍摄A和产生B的方法，你有一个源头，你可以拥有BS的源头。</p><p>  这是完整的定义。没有额外的隐藏机械，哈克尔在某种程度上自动调用你＆＃34;使用函授＆＃34;像许多语言一样，没有围绕解决方法包裹的额外转换或奇怪的东西。就像OO解析了一个覆盖的方法（没有自动转换）一样，所有魔法都在挑选正确的实施;一旦解决了语言没有做任何其他事情。</p><p> 是什么制作数据结构＆＃34;函件＆＃34 ;?它具有令人明智的FMAP实现，无论哪种数据结构都在。如果它有一个明智的实现，我们可以给它，这使它成为一个仿函数，而不是另外的方式。理论上这就是它如何用某种界面的概念来工作，但有时文书工作可以妨碍它，让它感觉像它一样，这是另一条路的，所以某种东西尚未＆＃39 ; t一个迭代，直到我故意使它成为一个。但我认为它更加成熟的编程视图，以便将数据结构呈现为给定接口的一组可能的明智实现，可能是空的或多于一个，并且您只需选择是指解释它语言。你通常不是＆＃39; t＆＃34;创建＆＃34;这些实现。至少对于这些更简单的，更多数学类型的接口。 </p><p>上面的函数定义具有f a，它是＆＃34的haskell符号;由a＆＃34参数化的类型f;那个＆＃39; s摘要与类型变量，但在例子中容易;列表int是一个＆＃34;列表＆＃34;由＆＃34; int＆＃34;，意思是它可以持有INTS。</p><p> 虽然在完整的Haskell中，这可能会变得更加复杂，因为简单的类型I＆＃39; m在此帖子中使用您可以在视觉上进行比赛。要匹配f a列出int，我们设置f = list和a = int。</p><p> 不幸的是，两个哈斯克尔＆＃39;最重要的类型得到特殊套餐，视觉匹配它们很难。 Haskell而不是列出int，而是使用[int]，这在新手的最糟糕的时间内令人困惑。</p><p> 幸运的是，我们可以将此写成[] int。它已经有效的haskell语法。然后我们可以在视觉上匹配：f = []和a = int。我现在不要写很多Haskell代码，但是我一直在采用它如何在我的类型中所在的列表，因为我认为特殊情况非常有用。</p><p> 另一个混淆类型是函数类型a  - ＆gt;湾对于教学目的，它是更好的拼写（ - ＆gt;）a b。同样，当今法律哈斯克尔语法，虽然你不幸需要括号。在这种情况下，对于（ - ＆gt;），f =（ - ＆gt;）a和剩余部分是b。仍然有点摘要，所以通过观察您可以转换（ - ＆gt;）字符串int和a（ - ＆gt;）int int的输出，使其具体化。如果您有一些功能，请将其转换为（ - ＆gt;）int int。 （ - ＆gt;）int string，因为重要的是你是＆＃34的函数的输出;功能＆＃34;匹配您申请的功能的输入，在这种情况下是int。</p><p> 我在我的代码中没有使用它，因为它的手动类型签名到处都是凶猛的事情。尽管如此，重要的是要记住它的真正意味着什么。</p><p> 在这种情况下，图案匹配中的f＆＃34;前件＆＃34;而不是第一个元素。如果您不打算在Haskell进行编程，只需将我的通知为此，这是一个法律匹配，让这款清洗到您身上;如果您打算在Haskell＆＃39中编程。LL找到这赢得了＆＃39; T.无论是如何，它对理解Monad接口是如此，我将沿着现在沿着狂欢的方式移动。 </p><p>当您有一些源A的数据结构是MONADISIS，以及一种拍摄A并将其转换为相同的B源的方式，并将全部转向相同的B源。和＆＃34;函数＆＃34;我正在使用这个词＆＃34;来源＆＃34;作为最接近的英语单词，我可以想到为类型的最大泛型概念;您有一个ints列表，或产生int的函数，或者从用户输入等获得int的方式等。</p><p> Class Monad M在哪里（＆gt;＆gt; =）:: m a  - ＆gt; （a  - ＆gt; m b） - ＆gt; M B.</p><p> 英语真的在这里绊倒，但在英语描述与定义之间，我希望基本的想法遇到。它可能也没有帮助我们有一个职能称为＆gt;＆gt; =，这很难发音。它＆＃39; s发音＆＃34;绑定＆＃34;，这只是稍微有用的是，仍然无法唤起任何有用的图像。设＆＃39;■参加一个具体的例子：</p><p>  独自一人，＆＃39; s不是一个令人困惑的功能。在这个特殊的情况下，有许多可能的明智的实现。显然，我们沿着ints列表迭代，将它们逐一传递给生成字符串列表的东西，并且将所有这些结果连接到最终列表中。 （我们必须这样做，因为最终结果可以＆＃39; t是列表（列表字符串）;那个＆＃39; s一个单独的类型。）</p><p>   所有Monad都是＆＃39;它是一些＆＃34;方法＆＃34;这符合该接口规范。</p><p> 理解这不是人们的意思＆＃34;了解Monad＆＃34;这是＆＃34;什么＆＃34; Monad接口，但不是＆＃34;为什么＆＃34;但我认为这是一个往往在其他作品中过于迅速的一步（如果不是彻头彻尾的跳过），所以让＆＃39;留在这里，咀嚼那个＆＃34;什么＆＃34;就一点点。</p><p> 再一次，我想强调，就像以OO语言一样，就像FMAP一样，没有特殊的魔法哈斯克尔调用，因为＆＃34;它＆＃39; sonad＆＃34;所有Haskell都是查找界面＆＃39; s的实现并传递参数。＆＃34; do符号＆＃34;但这只是这个功能呼叫的语法 - 糖重点;它仍然没有进一步操纵参数，没有胁迫，没有改进输入，没有改进输出，没有。自本文是关于理解和＃34; Monad＆＃34;如果没有深入了解了Haskell特定的细节，我将忽略它，因为它只是语法糖。 </p><p>绑定只是一种函数，它采用一些包装类型，一个函数，它是一个内部值并返回包装的函数，以及该类型的最终包装值。</p><p>  再次，没有谜。它需要一个可能具有int的内容，将其转换为字符串，然后返回一个字符串或任何内容的内容。</p><p>  显然，你不知道Blorp的＆＃39。我把它命名，我甚至不知道它的所作所为。但是你可以看到这将是＆＃34; bind＆＃34;对于Blorp，特定类型int和string。</p><p> 所有Monad都是＆＃39;就像迭代器周围没有魔法一样迭代＆＃39;下一个方法，就像函件周围没有魔法一样，这就是一切都是一切都是如此。事实上，它字面上可以＆＃39; t更复杂，因为这是一个接口。所有接口都可以做到一个特定的方法。没有别的发生。如果您发现您当前的Monad的概念不匹配，它坚持在那里＆＃39;一个大球O＆＃39;这里的神秘面纱，扔掉它。它只不过是将特定函数声明为此接口的实现以及当您使用时的后续分辨率机械。没有什么。更多的。</p><p> 不，我不是在A＆＃34中的意思;如果你看右图，这个艰难的概念就会很容易。我并不意味着它一直试图简化一些解释，因为这是一个简化的解释。这就是Monadic实现是什么。它并非简化。它完全准确的描述。它不再少于特定接口的实现的规范。它与迭代器和仿函数和销毁以及许多语言的所有其他众所周知的接口相同。</p><p> 我在文本中结合了这一点，希望你＆＃39; LL在继续之前慢下来并处理这个。很多人真的在他们的头上建立了这个特殊的界面，就像从根本上神秘的东西。但这就是Monad的一切。</p><p> 这是一个卷饼吗？这是一个太空服吗？它是其他一些奇怪的比喻吗？不，你不需要一个奇怪的隐喻来了解这一部分。事实上，你宁愿需要缺乏奇异的隐喻，因为他们是神话 </p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.jerf.org/iri/post/2958">http://www.jerf.org/iri/post/2958</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/monads/">#monads</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>