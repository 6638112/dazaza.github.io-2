<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CVE-2021-20226参考计数错误，导致本地特权Escalati CVE-2021–20226 a reference counting bug which leads to local privilege escalati</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CVE-2021–20226 a reference counting bug which leads to local privilege escalati<br/>CVE-2021-20226参考计数错误，导致本地特权Escalati </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-22 03:20:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/210f593e732f9350456ce26758de933b.png"><img src="http://img2.diglog.com/img/2021/6/210f593e732f9350456ce26758de933b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this article, I would like to give you a technical description of CVE-2021–20226(  ZDI-2021–001 ) which is published before. I discovered this vulnerability and reported it to the vendor via the Zero Day Initiative. This article is not intended to inform you of the dangers of vulnerabilities, but to share tips from a technical point of view.</p><p>在本文中，我想为您提供之前发布的CVE-2021-20226（ZDI-2021-001）的技术描述。我发现这脆弱性并通过零日计划向供应商报告给供应商。本文并非旨在通知您漏洞的危险，而是从技术角度分享提示。</p><p> An overview of the vulnerabilities and attack methods can be found at the links below. This blog will explain in a little more detail.</p><p> 可以在下面的链接找到漏洞和攻击方法的概述。此博客将更详细地解释。</p><p>  If you   have any questions or found any mistakes, I’d appreciate it if you could contact me individually. And, the code in this article basically refers to the Linux Kernel source code at  Linux kernel 5.6.19.</p><p>  如果您有任何疑问或发现任何错误，如果您可以单独与我联系，我会感激。而且，本文中的代码基本上是指Linux内核5.6.19的Linux内核源代码。</p><p> io_uring is one of the actively updated features as of 2021, and the information changes as the version changes (many changes have been made since the time I discovered it). Therefore, please note that the information is not up-to-date even at the time of writing the blog.</p><p> IO_URICE是2021年的主动更新的功能之一，并且信息随着版本的变化而变化（自发现时间以来已经进行了许多变化）。因此，请注意，即使在撰写博客时，信息也不是最新的。</p><p>  I will explain the outline of the PoC I wrote, but I will not post the actual code.</p><p>  我将解释我写的Poc的轮廓，但我不会发布实际代码。</p><p>    Please refer to some blogs/slides posted on the Internet for specs and detailed descriptions from the user’s perspective.  From here, I will continue to explain the outline of io_uring on the assumption that you understand it.</p><p>    请参阅Internet上发布的一些博客/幻灯片，以获取用户的角度的规格和详细说明。从这里，我将继续解释你理解它的假设的IO_uring的轮廓。</p><p> In io_uring, a file descriptor is first generated by a dedicated system call ( io_uring_setup), and by issuing  mmap() system call to it, Submission Queue(SQ) and Completion Queue(CQ) are mapped/shared in userspace memory. This is used as ring buffer by both sides(Kernel/Userspace). Entries for each system call such as read/write/send/recv are registered by writing SQE(Submission Queue Entry) to the shared memory. And then execution is started by calling  io_uring_enter().</p><p> 在IO_URIP中，文件描述符首先由专用的系统调用（IO_URE_SETUP）生成，并且通过发出MMAP（）系统调用，提交队列（SQ）和完成队列（CQ）在用户空间内存中映射/共享。这用作两侧的环形缓冲器（内核/用户空间）。通过将SQE（提交队列条目）写入共享内存，注册了每个系统呼叫的条目，例如读/写/发送/ reCV。然后通过调用io_ougn_enter（）启动执行。 </p><p>   By the way, the important part this time is the implementation of asynchronous execution, so I will focus on that. To explain it first, io_uring is not always executed asynchronously, but it is  executed asynchronously as needed. Please refer to the code below first.(After this, the Kernel v5.8 will be used to explain the behavior. The behavior may be slightly different from your environment.)</p><p>顺便说一下，这次重要的部分是实现异步执行的实现，所以我将专注于此。首先解释它，IO_URE并不总是异步地执行，但它根据需要异步执行。请先参考以下代码。（在此之后，内核v5.8将用于解释行为。行为可能与您的环境略有不同。）</p><p> #define _GNU_SOURCE #include &lt;sched.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/fcntl.h&gt; #include &lt;err.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #include &lt;linux/io_uring.h&gt; #define SYSCHK(x) ({ \  typeof(x) __res = (x); \  if (__res == (typeof(x))-1) \  err(1, &#34;SYSCHK(&#34; #x &#34;)&#34;); \  __res; \ }) static int uring_fd; struct iovec *io; #define SIZE 32 char _buf[SIZE]; int main(void) {  // initialize uring  struct io_uring_params params = { };  uring_fd = SYSCHK(syscall(__NR_io_uring_setup, /*entries=*/10, &amp;params));  unsigned char *sq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,  MAP_SHARED, uring_fd,  IORING_OFF_SQ_RING));  unsigned char *cq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,  MAP_SHARED, uring_fd,  IORING_OFF_CQ_RING));  struct io_uring_sqe *sqes = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,  MAP_SHARED, uring_fd,  IORING_OFF_SQES)); io = malloc(sizeof(struct iovec)*1);  io[0].iov_base = _buf;  io[0].iov_len = SIZE; struct timespec ts = { .tv_sec = 1 };  sqes[0] = (struct io_uring_sqe) {  .opcode = IORING_OP_TIMEOUT,  //.flags = IOSQE_IO_HARDLINK,  .len = 1,  .addr = (unsigned long)&amp;ts  };  sqes[1] = (struct io_uring_sqe) {  .opcode = IORING_OP_READV,  .addr = io,  .flags = 0,  .len = 1,  .off = 0,  .fd = SYSCHK(open(&#34;/etc/passwd&#34;, O_RDONLY))  };  ((int*)(sq_ring + params.sq_off.array))[0] = 0;  ((int*)(sq_ring + params.sq_off.array))[1] = 1;  (*(int*)(sq_ring + params.sq_off.tail)) += 2; int submitted = SYSCHK(syscall(__NR_io_uring_enter, uring_fd,  /*to_submit=*/2, /*min_complete=*/0,  /*flags=*/0, /*sig=*/NULL, /*sigsz=*/0));  while(1){  usleep(100000);  if(*_buf){  puts(&#34;READV executed.&#34;);  break;  }  puts(&#34;Waiting.&#34;);  } }</p><p> #define _gnu_source #include＆lt; sched.h＆gt; #include＆lt; stdio.h＆gt; #include＆lt; string.h＆gt; #include＆lt; stdlib.h＆gt; #include＆lt; signal.h＆gt; #include＆lt; sys / syscall.h＆gt; #include＆lt; sys / fcntl.h＆gt; #include＆lt; err.h＆gt; #include＆lt; unistd.h＆gt; #include＆lt; sys / mman.h＆gt; #include＆lt; linux / io_uring.h＆gt; #define syschk（x）（{\ typeof（x）__res =（x）; \ if（__res ==（typeof（x）） -  1）\ err（1，＆＃34; syschk（＆＃34;＃ X＆＃34;）＆＃34;）; \ __res; \}）静态intring_fd; struct iovec * io; #define size 32 char _buf [size]; int main（void）{//初始化uring struct io_uping_params params = {}; uring_fd = syschk（syscall（__ nr_io_uring_setup，/ *条目= * / 10，＆amp; params））; unsigned char * sq_ring = syschk（null，0x1000，prot_read | prot_write，map_shared，uring_fd，iing_off_sq_ring））; unsigned char * cq_ring = syschk（null，0x1000，prot_read | prot_write，map_shared，uring_fd，iing_off_cq_ring））; struct io_uring_sqe * sqes = syschk（mmap（null，0x1000，prot_read | prot_write，map_shared，uring_fd，iings_off_sqes））; io = malloc（sizeof（struct iovec）* 1）; io [0] .iov_base = _buf; IO [0] .iov_len = size; struct timespec ts = {.tv_sec = 1}; SQEES [0] =（struct io_uring_sqe）{.opcode = iOrience_op_timeout，//.flags = iosqe_io_hardlink，.len = 1，.addr =（unsigned long）＆amp; ts}; SQEES [1] =（struct io_uring_sqe）{.opcode = iOrience_op_readv，.addr = Io，.flags = 0，.len = 1，.off = 0，.fd = syschk（打开（＆＃34; / etc / passwd＆ ＃34;，o_rdonly））}; （（int *）（sq_ring + params.sq_off.array））[0] = 0; （（int *）（sq_ring + params.sq_off.array）[1] = 1; （*（int *）（sq_ring + params.sq_off.tail））+ = 2; int提交= syschk（syscall（__ nr_io_uping_enter，uring_fd，/ * to_submit = * / 2，/ * min_complete = * / 0，/ * flags = * / 0，/ * sig = * / null，/ * sigsz = * / 0 ））;虽然（1）{ULEEP（100000）; if（* _ buf）{puts（＆＃34; readv执行。＆＃34;）;休息;放（＆＃34;等待。＆＃34;）; }}</p><p> In this code, after performing the necessary setup for the operations  IORING_OP_TIMEOUT and  IORING_OP_READV, it starts execution and then checks every 0.1 seconds to see if  readv() is complete. It seems that  readv() will be completed after 1 second, considering that it is executed in the order of ring buffer. However, when I actually run it, the result was as follows.</p><p> 在此代码中，在执行ITORION_OP_TIMEOUT和IORING_OP_READV执行必要的设置之后，它开始执行，然后每0.1秒检查一次，以查看READV（）是否完成。似乎readv（）将在1秒后完成，考虑到它按环缓冲区的顺序执行。但是，当我实际运行时，结果如下。</p><p>  That is, execution of  readv() was completed immediately. This is because, as I said earlier, it is  executed asynchronously as needed, but in this case an execution of  readv() can be completed immediately (because it is known that its execution does not stop). So subsequent operation was compeleted first ( IORING_OP_TIMEOUT was ignored for the time being). As a test, check that  readv() is executed synchronously (= in the handler of the system call) with the following systemtap[¹] script.</p><p>  也就是说，立即完成READV（）的执行。这是因为，正如我之前所说的那样，它根据需要异步地执行，但在这种情况下，可以立即完成READV（）的执行（因为已知其执行不会停止）。所以后续操作首先互动（ITORING_OP_TIMEOUT忽略）。作为测试，使用以下SystemTap [¹]脚本检查readv（）是否同步执行（=在系统调用的处理程序中）。</p><p> [¹]: A tool that allows you to flexibly execute scripts, such as tracing Kernel (but not only) functions and outputting variables at the traced points. I love this tool because Kernel debugging is a hassle.</p><p> [¹]：允许您灵活地执行脚本的工具，例如跟踪内核（但不仅）函数并在跟踪点输出变量。我喜欢这个工具，因为内核调试是一个麻烦。</p><p>  ↓ This is the output when the previous program (name of the file is  sample) is executed while above systemtap script is being executed. If it is asynchronous, it is easy to imagine that the execution task is registered in some worker, but since it is executed synchronously here, the name of the executable file which called the system call is printed.</p><p>  ↓当在执行上述SystemTap脚本时执行先前的程序（文件名为样本的名称）时，这是输出。如果是异步，很容易想象执行任务在某些工作人员中注册，但由于它在此处执行，因此打印名为系统调用的可执行文件的名称。</p><p>   So where did  IORING_OP_TIMEOUT go? The answer is “ passed to the Kernel Thread because it was determined that asynchronous execution was needed”. There are several criteria for this, and if they meet, they will be enqueued into the Queue for asynchronous execution. Here are some examples.</p><p>   那么我在哪里呢？答案是“传递给内核线程，因为确定需要异步执行”。有几个标准，如果它们相遇，它们将被排队进入异步执行的队列中。这里有些例子。 </p><p>  } else if (req-&gt;flags &amp; REQ_F_FORCE_ASYNC) {  ......  /*  * Never try inline submit of IOSQE_ASYNC is set, go straight  * to async execution.  */  req-&gt;work.flags |= IO_WQ_WORK_CONCURRENT;  io_queue_async_work(req);</p><p>}否则如果（req-＆gt;标志＆amp; req_f_force_async）{...... / * *切勿尝试内联提交IOSQE_ASYNC设置，直接*到异步执行。 * / req-＆gt; work.flags | = io_wq_work_concurrent; io_queue_async_work（req）;</p><p>  2. Decisions by the logic prepared for each operation. (e.g. Add IOCB_NOWAIT flag when calling  readv() and return EAGAIN if execution is expected to stop)</p><p>  2.由为每次操作准备的逻辑决定。 （例如，在调用READV（）时添加IOCB_NOWAIT标志，如果预计执行停止，则返回EAGAIN）</p><p> static int io_read(struct io_kiocb *req, struct io_kiocb **nxt,  bool force_nonblock) {  ......  ret = rw_verify_area(READ, req-&gt;file, &amp;kiocb-&gt;ki_pos, iov_count);  if (!ret) {  ssize_t ret2; if (req-&gt;file-&gt;f_op-&gt;read_iter)  ret2 = call_read_iter(req-&gt;file, kiocb, &amp;iter);  else  ret2 = loop_rw_iter(READ, req-&gt;file, kiocb, &amp;iter); /* Catch -EAGAIN return for forced non-blocking submission */  if (!force_nonblock || ret2 != -EAGAIN) {  kiocb_done(kiocb, ret2, nxt, req-&gt;in_async);  } else { copy_iov:  ret = io_setup_async_rw(req, io_size, iovec,  inline_vecs, &amp;iter);  if (ret)  goto out_free;  return -EAGAIN;  }  }  ...... }</p><p> static int io_read（struct io_kiocb * req，struct io_kiocb ** nxt，bool force_nonblock）{...... ret = rw_verify_area（阅读，req-＆gt;文件，＆amp; kiocb-＆gt; ki_pos，iov_count）; if（！RET）{SSIZE_T RET2; if（req-＆gt; file-＆gt; f_op-＆gt; read_iter）ret2 = call_read_iter（req-＆gt;文件，kiocb，＆amp; erer）; else ret2 = loop_rw_iter（读取，req-＆gt;文件，kiocb，＆amp; erer）; / *捕获强制非阻塞提交的返回* / if（！force_nonblock || ret2！= -iagain）{kiocb_done（kiocb，ret2，nxt，req-＆gt; in_async）; } else {copy_iov：ret = io_setup_async_rw（req，io_size，Iovec，Inline_vecs，＆amp; erer）;如果（RET）转到OUT_FREE;返回-Again; }} ......}</p><p>  When EAGAIN is returned, it is enqueued into the Queue for asynchronous execution (if it is a type of operation that uses file descriptors, it gets references to the  file structure here).</p><p>  返回EAGAIN时，它会导出进入异步执行的队列（如果它是一种使用文件描述符的操作，它会在此处获取对文件结构的引用）。</p><p> static void __io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe) {  ...... ret = io_issue_sqe(req, sqe, &amp;nxt, true); /*  * We async punt it if the file wasn&#39;t marked NOWAIT, or if the file  * doesn&#39;t support non-blocking read/write attempts  */  if (ret == -EAGAIN &amp;&amp; (!(req-&gt;flags &amp; REQ_F_NOWAIT) ||  (req-&gt;flags &amp; REQ_F_MUST_PUNT))) { punt:  if (io_op_defs[req-&gt;opcode].file_table) {  ret = io_grab_files(req);  if (ret)  goto err;  } /*  * Queued up for async execution, worker will release  * submit reference when the iocb is actually submitted.  */  io_queue_async_work(req);  goto done_req;  }  ...... }</p><p> 静态void __io_queue_sqe（struct io_kiocb * req，const struct io_uring_sqe * sqe）{...... ret = io_issue_sqe（req，sqe，＆amp; nxt，true）; / * *如果文件没有标记为Nowait，或者如果文件*＆＃39; t支持非阻塞读/写尝试* / if（RET == -AGAIN＆amp; ！（req-＆gt; flags＆amp; req_f_nowait）||（req-＆gt;标志＆amp; req_f_must_punt）））{punt：if（io_op_defs [req-＆gt;操作码] .file_table）{ret = io_grab_files（req）;如果（RET）GOTO ERR; } / * *排队到异步执行，Worker将在实际提交IOCB时发布*提交参考。 * / io_queue_async_work（req）; goto done_req; } ......}</p><p>  static int io_issue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,  struct io_kiocb **nxt, bool force_nonblock) {  struct io_ring_ctx *ctx = req-&gt;ctx;  int ret; switch (req-&gt;opcode) {  case IORING_OP_NOP:  ret = io_nop(req);  break;  case IORING_OP_READV:  case IORING_OP_READ_FIXED:  case IORING_OP_READ:  if (sqe) {  ret = io_read_prep(req, sqe, force_nonblock);  if (ret &lt; 0)  break;  }  ret = io_read(req, nxt, force_nonblock);  break;</p><p>  static int io_issue_sqe（struct io_kiocb * req，const struct io_uring_sqe * sqe，struct io_kiocb ** nxt，bool force_nonblock）{struct io_ring_ctx * ctx = req-＆gt; ctx; int ret;切换（req-＆gt;操作码）{case iing_op_nop：ret = io_nop（req）;休息;案例IORING_OP_READV：CASE IORICE_OP_READ_FIXED：case iousing_op_read：if（sqe）{ret = io_read_prep（req，sqe，force_nonblock）; if（et＆lt; 0）破裂; } ret = io_read（req，nxt，force_nonblock）;休息;</p><p>  3. When the  IOSQE_IO_LINK|IOSQE_IO_HARDLINK flag is used(the execution order is specified) and the operation whose execution order is earlier is determined to require asynchronous execution.</p><p>  3.使用IOSQE_IO_LINK | IOSQE_IO_HARDLINK标志（指定执行顺序）和更早地执行其执行顺序的操作以确定需要异步执行。 </p><p> (Connect as a link as described in the code below, execute in order, and if condition 2 is met in the middle, whole link will be enqueued into the asynchronous execution queue)</p><p>（如下面的代码中所述连接为链接，按顺序执行，如果在中间满足条件2，则将在异步执行队列中排出整个链接）</p><p> static bool io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,  struct io_submit_state *state, struct io_kiocb **link) {  ......  /*  * If we already have a head request, queue this one for async  * submittal once the head completes. If we don&#39;t have a head but  * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be  * submitted sync once the chain is complete. If none of those  * conditions are true (normal request), then just queue it.  */  if (*link) {  ......  list_add_tail(&amp;req-&gt;link_list, &amp;head-&gt;link_list); /* last request of a link, enqueue the link */  if (!(sqe_flags &amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK))) {  io_queue_link_head(head);  *link = NULL;  }  } else {  ......  if (sqe_flags &amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK)) {  req-&gt;flags |= REQ_F_LINK;  INIT_LIST_HEAD(&amp;req-&gt;link_list); if (io_alloc_async_ctx(req)) {  ret = -EAGAIN;  goto err_req;  }  ret = io_req_defer_prep(req, sqe);  if (ret)  req-&gt;flags |= REQ_F_FAIL_LINK;  *link = req;  } else {  io_queue_sqe(req, sqe);  }  } return true; }</p><p> 静态bool io_submit_sqe（struct io_kiocb * req，const struct io_uring_sqe * sqe，struct io_submit_state * struct，struct io_kiocb **链接）{...... / * *如果我们已经有一个头请求，则为异步队列这一个头部完成后提交。如果我们没有＆＃39; t有一个头，但是* iosqe_io_link在sqe中设置，开始一个新的头。一旦链条完成，这将是*提交同步。如果没有那些*条件是真的（正常请求），那么只需队列。 * / if（*链接）{...... list_add_tail（＆amp; req-＆gt; link_list，＆amp; head-＆gt; link_list）; / *链接的最后一个请求，inqueue链接* / if（！（sqe_flags＆amp;（iosqe_io_link | iosqe_io_hardlink）））{io_queue_link_head（head）; * link = null; }}否则{......如果（sqe_flags＆amp;（iosqe_io_link | iosqe_io_hardlink））{req-＆gt; flags | = req_f_link; init_list_head（＆amp; req-＆gt; link_list）; if（io_alloc_async_ctx（req））{ret = -eagain; goto err_req; } ret = io_req_defer_prep（req，sqe）; if（ret）req-＆gt; flags | = req_f_fail_link; *链接= req; } else {io_queue_sqe（req，sqe）; }}返回true; }</p><p>  Strictly speaking,  IORING_OP_TIMEOUT is a little special and does not return EAGAIN like shown in 2. But (I think) it is easy to understand, so I use it as a sample. As shown below, by linking an operation that requires asynchronous execution ( IORING_OP_TIMEOUT) with another operation, you can see that the previous  IORING_OP_READV is certainly executed after waiting for 1 second.</p><p>  严格来说，IORING_OP_TIMEOUT是一个小小的特殊性，并且不会返回EAGAIN，如2.但（我认为）很容易理解，所以我用它作为一个样本。如下所示，通过将需要异步执行（IORING_OP_TIMEOUT）与另一个操作的操作链接，您可以看到先前的IORING_OP_READV在等待1秒后肯定执行。</p><p> Add  IOSQE_IO_HARDLINK flag to the  IORING_OP_TIMEOUT operation in the sample code above to clarify that it is linked to the subsequent operation.</p><p> 将IOSQE_IO_HARDLINK标志添加到上面的示例代码中的IORING_OP_TIMEOUT操作，以阐明它链接到后续操作。</p><p>    At this time, if you display the name of the process that is executing  io_read() in the same way as before, you will get the following output.</p><p>    此时，如果以与以前相同的方式执行执行IO_READ（）的进程的名称，则会获得以下输出。</p><p>  As you can see by looking at the process list, this is a Kernel Thread.</p><p>  正如您通过查看进程列表所看到的，这是一个内核线程。</p><p> $ ps aux | grep -A 2 -m 1 sample garyo 131388 0.0 0.0 2492 1412 pts/1 S+ 19:03 0:00 ./sample root 131389 0.0 0.0 0 0 ? S 19:03 0:00 [io_wq_manager] root 131390 0.0 0.0 0 0 ? S 19:03 0:00 [io_wqe_worker-0]</p><p> $ PS AUX | Grep -a 2-u型1样品Garyo 131388 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0. S 19:03 0:00 [IO_WQ_MANAGER]根131390 0.0 0.0 0 0？ S 19:03 0:00 [IO_WQE_WORKER-0] </p><p> Hereafter, this Kernel Thread will be referred to as a “worker”. This worker is generated by the following code and then, dequeues and executes the asynchronous execution tasks from Queue.</p><p>此后，此内核线程将被称为“工人”。此工作人员由以下代码生成，然后，Dequeue和执行队列的异步执行任务。</p><p> static bool create_io_worker(struct io_wq *wq, struct io_wqe *wqe, int index) {  ...... worker-&gt;task = kthread_create_on_node(io_wqe_worker, worker, wqe-&gt;node,  &#34;io_wqe_worker-%d/%d&#34;, index, wqe-&gt;node);  ...... }</p><p> 静态bool create_io_worker（struct io_wq * wq，struct io_wqe * wqe，int index）{...... worker-＆gt; task = kthread_create_on_node（io_wqe_wayer，worker，wqe-＆gt;节点，＆＃34; io_wqe_worker-％d /％d＆＃34;，index，wqe-＆gt;节点）; ......}</p><p>  Aside: As explained earlier,   IORING_OP_TIMEOUT  behaves slightly differently from the figure below, but it is described as such for simplicity. Strictly speaking, when   io_timeout()  is called, it sets   io_timeout_fn()  in the handler and starts the timer. After the time set by the timer has elapsed,   io_timeout_fn()  is called to load the operations connected to the link in the asynchronous execution queue. In other words,   IORING_OP_TIMEOUT  itself is not enqueued in the asynchronous execution queue. TIMEOUT is used in the explanation so that it is easy to imagine that execution will stop.</p><p>  旁边：如前所述，IORING_OP_TIMEOUT从下图略有不同，但它被描述为简单起见。严格来说，当调用io_timeout（）时，它会在处理程序中设置IO_TIMEOUT_FN（）并启动计时器。在通过定时器的时间设置后，调用IO_TimeOut_fn（）以将连接到异步执行队列中的链路的操作加载。换句话说，IORING_OP_TIMEOUT本身不会在异步执行队列中排队。超时用于解释中，因此很容易想象执行将停止。</p><p>   It was found out that asynchronous processing is performed by a worker running as a Kernel Thread. However, there is a precaution here. Since worker is runninng as a Kernel Thread, the execution context is different from the thread which calls io_uring related system calls. Here, the “execution context” means the  task_struct structure associated with the process and various information associated with it. For example,  mm (Manage the virtual memory space of the process) ,  cred (holds UID/GID/Capability), files_struct (holds a table for file descriptors. There’s an array of  file structure in  files_struct structure, and file descriptor is its index) and so on.</p><p>   发现异步处理由运行作为内核线程的工作者执行。但是，这里有预防措施。由于Worker runninng作为内核线程，因此执行上下文与调用IO_uping相关系统调用的线程不同。这里，“执行上下文”是指与处理相关联的任务组结构和与之相关联的各种信息。例如，mm（管理进程的虚拟内存空间），cred（保存UID / gid / capability），files_struct（保存文件描述符的表。文件_struct结构中的文件结构数组，文件描述符是其索引） 等等。</p><p> Of course, if it doesn’t refer to these structures in the thread that calls the system call, it may refer to the wrong virtual memory or file descriptor table, or issue I/O operations with Kernel Thread privileges (≒ root) [²].</p><p> 当然，如果它没有引用调用系统调用的线程中的这些结构，它可以指的是错误的虚拟内存或文件描述符表，或使用内核线程权限（≒root）发出I / O操作[² ]。</p><p> [²]: By the way, this was an actual vulnerability, and at that time it forgot to switch cred, and operations were able to be executed with root privileges. Although the operation equivalent to open  open() was not implemented at that time, it was possible to notify the privilege in sendmsg’s SCM_CREDENTIALS option that notifies the sender’s authority. It is a problem around D-Bus because the authority is confirmed by it.  https://www.exploit-db.com/exploits/47779</p><p> [²]：顺便说一下，这是一种实际漏洞，而且当时它忘了切换信用，并且可以用root权限执行操作。虽然当时未实现相当于打开的Open（）的操作，但是可以在SendMsg的SCM_Credentials选项中通知通知发件人的权限的权限。这是D-Bus周围的问题，因为权威是由它确认的。 https://www.exploit-db.com/exploits/47779.</p><p> Therefore, in io_uring, those references are passed to the worker so that the worker shares the execution context by switching its own context before execution. For example, you can see that then references to  mm and  cred are passed to the  req-&gt;work in the following code.</p><p> 因此，在IO_URICE中，这些引用将传递给工人，以便工作者通过在执行之前通过切换自己的上下文来共享执行上下文。例如，您可以看到，然后将引用MM和CRECT传递给REQ-＆GT;在以下代码中工作。 </p><p> static inline void io_req_work_grab_env(struct io_kiocb *req,  const struct io_op_def *def) {  if (!req-&gt;work.mm &amp;&amp; def-&gt;needs_mm) {  mmgrab(current-&gt;mm);  req-&gt;work.mm = current-&gt;mm;  }  if (!req-&gt;work.creds)  req-&gt;work.creds = get_current_cred();  if (!req-&gt;work.fs &amp;&amp; def-&gt;needs_fs) {  spin_lock(&amp;current-&gt;fs-&gt;lock);  if (!current-&gt;fs-&gt;in_exec) {  req-&gt;work.fs = current-&gt;fs;  req-&gt;work.fs-&gt;users++;  } else {  req-&gt;work.flags |= IO_WQ_WORK_CANCEL;  }  spin_unlock(&amp;current-&gt;fs-&gt;lock);  }  if (!req-&gt;work.task_pid)  req-&gt;work.task_pid = task_pid_vnr(current); }</p><p>静态内联void io_req_ward_grab_env（struct io_kiocb * req，const struct io_op_def * def）{if（！req-＆gt; work.mm＆amp; def-＆gt; caven-＆gt; caven-＆gt; comper_mm）{mmgrab（current-＆gt; mm）; Req-＆gt; Work.mm =电流 - ＆gt; mm; }如果（！req-＆gt; work.creds）req-＆gt; work.creds = get_current_cred（）; if（！req-＆gt; work.fs＆amp;＆amp; def-＆gt; capid_fs）{spin_lock（＆amp; current-＆gt; fs-＆gt;锁定）; if（！current-＆gt; fs-＆gt; in_exec）{req-＆gt; work.fs = current-＆gt; fs; req-＆gt; work.fs-＆gt;用户++; } else {req-＆gt; work.flags | = io_wq_wark_cancel; } Spin_unlock（＆amp; current-＆gt; fs-＆gt;锁定）; }如果（！req-＆gt; work.task_pid）req-＆gt; work.task_pid = task_pid_vnr（当前）; }</p><p>  You can see that the reference to  files_struct is passed to the  req-&gt;work in the following code.</p><p>  您可以看到对files_struct的引用传递给req-＆gt;在以下代码中工作。</p><p> static int io_grab_files(struct io_kiocb *req) {  ......  if (fcheck(ctx-&gt;ring_fd) == ctx-&gt;ring_file) {  list_add(&amp;req-&gt;inflight_entry, &amp;ctx-&gt;inflight_list);  req-&gt;flags |= REQ_F_INFLIGHT;  req-&gt;work.files = current-&gt;files;  ret = 0;  }  ...... }</p><p> static int io_grab_files（struct io_kiocb * req）{...... if（ctx-＆gt; ring_fd）== ctx-＆gt; ring_file）{list_add（＆amp; req-＆gt; indight_entry，＆amp; ctx-＆gt ;填充_List）; Req-＆gt;标志| = req_f_inflight; req-＆gt; work.files = current-＆gt;文件; RET = 0; } ......}</p><p>  Then, before execution, these are replaced with the contents of the worker’s  current (a macro that gets the  task_struct currently running thread).</p><p>  然后，在执行之前，将它们替换为工作人员的当前内容（获取当前正在运行的Task_struct的宏）。</p><p> static void io_worker_handle_work(struct io_worker *worker)  __releases(wqe-&gt;lock) {  struct io_wq_work *work, *old_work = NULL, *put_work = NULL;  struct io_wqe *wqe = worker-&gt;wqe;  struct io_wq *wq = wqe-&gt;wq; do {  ...... if (work-&gt;files &amp;&amp; current-&gt;files != work-&gt;files) {  task_lock(current);  current-&gt;files = work-&gt;files;  task_unlock(current);  }  if (work-&gt;fs &amp;&amp; current-&gt;fs != work-&gt;fs)  current-&gt;fs = work-&gt;fs;  if (work-&gt;mm != worker-&gt;mm)  io_wq_switch_mm(worker, work);  if (worker-&gt;cur_creds != work-&gt;creds)  io_wq_switch_creds(worker, work);  ......  work-&gt;func(&amp;work);  ......  } while (1); }</p><p> 静态void io_wayer_handle_work（struct io_wayer * worker）__leleases（wqe-＆gt; lock）{struct io_wq_ware * work，* old_work = null，* put_work = null; struct io_wqe * wqe = worker-＆gt; wqe; struct io_wq * wq = wqe-＆gt; wq; do {......如果（工作 - ＆gt;文件＆amp; current-＆gt;文件！= work-＆gt;文件）{task_lock（current）; current-＆gt; files = work-＆gt;文件; Task_unlock（当前）; }如果（工作 - ＆gt; fs＆amp;＆amp; current-＆gt; fs！=工作 - ＆gt; fs）current-＆gt; fs =工作 - 和gt; fs; if（工作 - ＆gt; mm！= worker-＆gt; mm）io_wq_switch_mm（worker，work）; if（worker-＆gt; cur_creds！= work-＆gt; creds）io_wq_switch_creds（工人，工作）; ......工作 - ＆gt; func（＆amp;工作）; ......}虽然（1）; }</p><p>  Now, let’s move on to the explanation of the vulnerabilities. In the code below (I posted earlier), you can see that the worker is passing a reference to the  files_struct structure of the thread executing the system call to the structure that the worker will refer later  without incrementing the reference counter.</p><p>  现在，让我们继续解释漏洞。在下面的代码中（我之前发布），您可以看到工作人员正在向执行系统调用的线程的文件传递给工作者将在不递增参考计数器的情况下引用的结构。</p><p> static int io_grab_files(struct io_kiocb *req) {  ......  if (fcheck(ctx-&gt;ring_fd) == ctx-&gt;ring_file) {  list_add(&amp;req-&gt;inflight_entry, &amp;ctx-&gt;inflight_list);  req-&gt;flags |= REQ_F_INFLIGHT;  req-&gt;work.files = current-&gt;files;  ret = 0;  }  ...... }</p><p> static int io_grab_files（struct io_kiocb * req）{...... if（ctx-＆gt; ring_fd）== ctx-＆gt; ring_file）{list_add（＆amp; req-＆gt; indight_entry，＆amp; ctx-＆gt ;填充_List）; Req-＆gt;标志| = req_f_inflight; req-＆gt; work.files = current-＆gt;文件; RET = 0; } ......} </p><p>  By the way, as explained briefly earlier, when enqueueing a task in the Queue for asynchronous execution, the reference to the  file structure is retained first from the specified file descriptor (passed to the  io_kiocb structure).</p><p>顺便说一下，如简要介绍的说明，当在队列中延长任务时，从指定的文件描述符（传递给IO_kiocb结构）首先保留对队列中的队列中的参考。</p><p> static int io_req_set_file(struct io_submit_state *state, struct io_kiocb *req,  const struct io_uring_sqe *sqe) {  struct io_ring_ctx *ctx = req-&gt;ctx;  unsigned flags;  int fd; flags = READ_ONCE(sqe-&gt;flags);  fd = READ_ONCE(sqe-&gt;fd); if (!io_req_needs_file(req, fd))  return 0; if (flags &amp; IOSQE_FIXED_FILE) {  if (unlikely(!ctx-&gt;file_data ||  (unsigned) fd &gt;= ctx-&gt;nr_user_files))  return -EBADF;  fd = array_index_nospec(fd, ctx-&gt;nr_user_files);  req-&gt;file = io_file_from_index(ctx, fd);  if (!req-&gt;file)  return -EBADF;  req-&gt;flags |= REQ_F_FIXED_FILE;  percpu_ref_get(&amp;ctx-&gt;file_data-&gt;refs);  } else {  if (req-&gt;needs_fixed_file)  return -EBADF;  trace_io_uring_file_get(ctx, fd);  req-&gt;file = io_file_get(state, fd);  if (unlikely(!req-&gt;file))  return -EBADF;  } return 0; }</p><p> static int io_req_set_file（struct io_submit_state * state，struct io_kiocb * req，const struct io_uring_sqe * sqe）{struct io_ring_ctx * ctx = req-＆gt; ctx;无符号旗帜; int fd;标志= READ_ONCE（SQE-＆GT;标志）; fd = read_once（sqe-＆gt; fd）; if（！io_req_needs_file（req，fd））返回0; if（标志＆amp; iosqe_fixed_file）{if（不可能（！ctx-＆gt; file_data ||（未签名）fd＆gt; = ctx-＆gt; nr_user_files）return -ebadf; fd = array_index_nospec（fd，ctx-＆gt; nr_user_files）; req-＆gt; file = io_file_from_index（ctx，fd）; if（！req-＆gt;文件）返回-ebadf; req-＆gt;标志| = req_f_fixed_file; percpu_ref_get（＆amp; ctx-＆gt; file_data-＆gt; refs）; }否则{if（req-＆gt; caless_fixed_file）return -ebadf; trace_io_uping_file_get（CTX，FD）; req-＆gt; file = io_file_get（州，FD）; if（不太可能（！req-＆gt;文件））返回-ebadf;返回0; }</p><p>   So the worker does not have to retrieve it from the file descriptor again and does not need to refer to the  files_struct structure. If so, it seems that there is no problem that the reference counter of the  files_struct structure is not incremented(because it is not used).  But this assumption is not true in Linux Kernel 5.5 and later. This is because system calls that affect file descriptor tables, such as  open/ close/ accept , are now available via io_uring. Obviously, these system calls affect the file descriptor table, so it looks like something can be used for exploitation However,</p><p>   因此，工作人员不必再次从文件描述符中检索它，并且不需要引用files_struct结构。如果是这样，似乎没有问题是files_struct结构的参考计数器未递增（因为未使用它）。但是在Linux内核5.5及更高版本中，此假设不存在。这是因为现在可以通过IO_UPURS获得影响文件描述符表的系统调用，例如打开/关闭/接受。显然，这些系统调用会影响文件描述符表，因此它看起来可以用于利用的东西，</p><p> Even if you simply calls  open/ close/ accept etc., nothing can happen if the  files_struct structure is available.   — Of course, system calls have  countermeasures when handling the same file by multiple threads, so it is not possible to simply cause a race condition between the calling thread and the worker.</p><p> 即使您只需调用Open / Close / Incept等，如果Files_struct结构可用，则不会发生任何内容。 - 当然，当通过多个线程处理相同的文件时，系统调用具有对策，因此无法在调用线程和工人之间引起竞争条件。</p><p> By freeing the  files_struct with setting reference counter to 0, a new process may reuse it as a  files_struct for that process. The worker will get a reference to the new process’s  files_struct when reused.  — But  file structure is already obtained from the file descriptor, ̶s̶o̶ ̶i̶t̶ ̶c̶a̶n̶n̶o̶t̶ ̶g̶e̶t̶ ̶a̶ ̶r̶e̶f̶e̶r̶e̶n̶c̶e̶ ̶t̶o̶ ̶t̶h̶e̶ ̶f̶i̶l̶e̶ ̶s̶t̶r̶u̶c̶t̶u̶r̶e̶ ̶o̶f̶ ̶t̶h̶e̶ ̶n̶e̶w̶ ̶p̶r̶o̶c̶e̶s̶s̶ (This was a lie. I’ll describe in “aside” part.)  — It’s possible to insert a  file structure into the file descriptor table of a new process by opening a file. But it will not be referenced. (Because people don’t use fixed file descriptor number while programming.)</p><p> 通过将Files_struct设置为0，新进程可以将其作为该进程的文件重用。重用时，工作人员将参考新进程的Files_struct。 - 但是，文件结构已经从文件描述符获得的，所以它̶c̶a̶n̶n̶o̶t̶得到一个参考文件结构的新的进程（这是一个谎言，我将描述在“搁置”的一部分。） - 这是可能的插入文件通过打开文件，结构进入新进程的文件描述符表。但它不会被引用。 （因为人们在编程时不使用固定文件描述符编号。）</p><p> Here, I will explain the mechanism around the reference counter of the  file structure in  countermeasures when handling the same file by multiple threads. Yes, it’s a spoiler. The conclusion will be that it can actually be abused.</p><p> 在这里，我将在通过多个线程处理相同文件时，在对策中解释文件结构的参考计数器的机制。是的，这是一个扰流板。结论将是它实际上可以滥用。</p><p>  To understand how the reference counters in the  file structure work, we first need to understand what open/close actually does. Of course, the behavior changes depending on the actual file to be opened, but the following can be said in common.</p><p>  要了解文件结构中的参考计数器如何工作，我们首先需要了解实际打开/关闭的内容。当然，行为根据要打开的实际文件而变化，但以下内容可以常见。 </p><p>    static struct file *__alloc_file(int flags, const struct cred *cred) {  struct file *f;  int error; f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);  ......  atomic_long_set(&amp;f-&gt;f_count, 1);  ......  return f; }</p><p>静态结构文件* __ alloc_file（int标志，const struct cred * cred）{struct文件* f; int错误; f = kmem_cache_zalloc（filp_cachep，gfp_kernel）; ...... atomic_long_set（＆amp; f-＆gt; f_count，1）; ......返回f; }</p><p>   static long do_sys_openat2(int dfd, const char __user *filename,  struct open_how *how) {  ......  fd = get_unused_fd_flags(how-&gt;flags);  if (fd &gt;= 0) {  struct file *f = do_filp_open(dfd, tmp, &amp;op);  if (IS_ERR(f)) {  put_unused_fd(fd);  fd = PTR_ERR(f);  } else {  fsnotify_open(f);  fd_install(fd, f);  }  }  putname(tmp);  return fd; }</p><p>   静态long do_sys_openat2（int dfd，const char __user * filename，struct open_how * how）{...... fd = get_unused_fd_flags（how-＆gt; flags）; if（fd＆gt; = 0）{struct文件* f = do_filp_open（dfd，tmp，＆amp; op）; if（is_err（f））{put_unused_fd（fd）; fd = ptr_err（f）; } else {fsnotify_open（f）; fd_install（fd，f）; }} putname（tmp）;返回FD; }</p><p>     int __close_fd(struct files_struct *files, unsigned fd) {  struct file *file;  struct fdtable *fdt; spin_lock(&amp;files-&gt;file_lock);  fdt = files_fdtable(files);  if (fd &gt;= fdt-&gt;max_fds)  goto out_unlock;  file = fdt-&gt;fd[fd];  if (!file)  goto out_unlock;  rcu_assign_pointer(fdt-&gt;fd[fd], NULL);  __put_unused_fd(files, fd);  spin_unlock(&amp;files-&gt;file_lock);  return filp_close(file, files); out_unlock:  spin_unlock(&amp;files-&gt;file_lock);  return -EBADF; }</p><p>     int __close_fd（struct files_struct * files，unsigned fd）{struct文件*文件;结构fdtable * fdt; spin_lock（＆amp; files-＆gt; file_lock）; fdt = files_fdtable（文件）; if（fd＆gt; = fdt-＆gt; max_fds）goto out_unlock; file = fdt-＆gt; fd [fd];如果（！文件）转到out_unlock; rcu_assign_pointer（fdt-＆gt; fd [fd]，null）; __put_unused_fd（文件，fd）; spin_unlock（＆amp; files-＆gt; file_lock）;返回filp_close（文件，文件）; Out_unlock：Spin_unlock（＆amp; files-＆gt; file_lock）;返回-ebadf; }</p><p>     The important thing here is the  fget()/ fput() functio</p><p>     这里重要的是fget（）/ fput（）functio</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a">https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/计数/">#计数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/privilege/">#privilege</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/io/">#io</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>