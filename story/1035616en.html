<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您不需要任何服务网格You don't need no service mesh</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">You don't need no service mesh<br/>您不需要任何服务网格</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 19:45:24</div><div class="page_narrow text-break page_content"><p>Service meshes have attracted an enormous amount of hype around them. With at least a few talks about service meshes during each tech conference, one can easily be convinced that having a service mesh in their infrastructure is a must. However, hype isn’t a good indicator of whether the new shiny tech is the right solution for your problems. So below, I’ll try to express an anti-hype opinion on service meshes to hopefully make it less confusing when you want to decide whether you may or may not need one.</p><p>服务网格在其周围吸引了大量宣传。在每次技术会议期间至少进行了几次有关服务网格的讨论，可以轻松地说服必须在其基础架构中拥有服务网格。但是，炒作并不能很好地表明新的闪亮技术是否可以解决您的问题。因此，在下面，我将尝试对服务网格进行反炒作，以期在您决定是否需要它时减少混乱。</p><p>  There’s a lesson here, and I’m not going to be the one to figure it out.</p><p>这里有一个教训，我不会成为一个要解决的问题。</p><p> Let’s take a step back in history and take a look at one of the  early articles about introducing Envoy at Lyft.</p><p>让我们回顾一下历史，看看有关介绍Lyft的Envoy的早期文章之一。</p><p> As it turns out, almost every company with a moderately-sized service oriented architecture is having the same problems that Lyft did prior to the development and deployment of Envoy:</p><p>事实证明，几乎每个具有中等规模的面向服务架构的公司都存在与Lyft在开发和部署Envoy之前所遇到的相同问题：</p><p> An architecture composed of a variety of languages, each containing a half-baked RPC library, including partial (or zero) implementations of rate limiting, circuit breaking, timeouts, retries, etc.</p><p>一种由多种语言组成的体系结构，每种语言都包含一个半熟的RPC库，包括速率限制，电路中断，超时，重试等的部分（或零）实现。</p><p> While Envoy is not a service mesh by itself, the outlined problems describe the exact reason why service meshes were invented. They add “rate limiting, circuit breaking, …” and other reliability, observability, and security features to the services by enforcing the communication to go through the service mesh proxies, a data plane. Additionally, they require a separate component, a control plane, to control the configuration.</p><p>尽管Envoy本身并不是服务网格，但概述的问题描述了发明服务网格的确切原因。通过强制通信经过服务网格代理（即数据平面），它们为服务添加了“速率限制，断路……”以及其他可靠性，可观察性和安全性功能。此外，它们需要一个单独的组件（控制平面）来控制配置。</p><p> However, at this point, a lot of people miss the context in which service meshes were introduced. Service meshes are able to solve the problem not because it’s impossible to solve them in any other way. There are many battle-proof RPC libraries that take on the challenges of a separate data plane layer,  Finagle,  gRPC,  Armeria,  Servicetalk, to name a few. After all, the very first service mesh - Linkerd 1.0  is powered by Finagle. The RPC libraries will need a component which provides service discovery and configuration management to make it a true mesh. For instance, Zookeeper, or Consul, a component that service meshes call a control plane.</p><p>但是，在这一点上，很多人都错过了引入服务网格的环境。服务网格能够解决问题不是因为不可能以其他任何方式解决它们。有许多具有战斗力的RPC库正面临着单独的数据平面层的挑战，例如Finagle，gRPC，Armeria，Servicetalk等。毕竟，第一个服务网格-Linkerd 1.0由Finagle支持。 RPC库将需要一个组件来提供服务发现和配置管理，以使其成为真正的网格。例如，服务网格的Zookeeper或Consul，称为控制平面。</p><p> Why introduce a new concept to solve the problems that have been solved before? The service mesh concept wasn’t introduced to address problems that hadn’t been addressed before but rather address them in a way that doesn’t require any modifications to the application code, which is incredibly convenient when it’s hard to introduce an RPC layer into an existing heterogeneous microservice environment.</p><p>为什么要引入一个新概念来解决以前已经解决的问题？没有引入服务网格概念来解决以前从未解决过的问题，而是以不需要对应用程序代码进行任何修改的方式解决这些问题，当难以在其中引入RPC层时，这非常方便现有的异构微服务环境。</p><p> When you hear service mesh, Istio with Envoy might be the first thing that comes to mind, but it wasn’t the first service mesh to enter the market. Linkerd authors who pioneered the space, described exactly this situation in the  &#34;why is the service mesh necessary&#34;. Interestingly, in many hype-y articles on the Internet this context is often forgotten, or omitted.</p><p>当您听到服务网格时，Istio和Envoy可能是您想到的第一件事，但这并不是第一个进入市场的服务网格。率先开发此空间的Linkerd作者在“为什么需要服务网格”中准确地描述了这种情况。有趣的是，在Internet上许多宣传文章中，这种情况经常被忘记或省略。</p><p> Solving a problem well, even if it’s a problem that a lot of people have, doesn’t magically provide the tech with a lot of hype. There is always a sponsor behind it. I don’t know who the sponsor was here, and I’m going to speculate, but it’s hard to sell an RPC library in the world where open source is a fundamental requirement. There is no clear business model there, that’s why most of the mature RPC libraries were open-sourced by large tech companies for which it’s not a part of the core business model. A library is just code, not a piece of infrastructure. Service meshes are a different story. It’s an isolated non-trivial piece of infrastructure. As a vendor, not only can you provide consultancy around the configuration and deployment, but you can also sell complete hosted solutions around it.</p><p>很好地解决问题，即使很多人都遇到了问题，也无法为技术带来很多炒作。背后总是有一个赞助商。我不知道赞助人是谁，我将推测，但是在开源是基本要求的世界上，很难出售RPC库。那里没有明确的业务模型，这就是为什么大多数成熟的RPC库都是由大型科技公司开源的，而它并不是核心业务模型的一部分。库只是代码，而不是基础架构的一部分。服务网格是另一回事。这是一个孤立的重要基础设施。作为供应商，您不仅可以提供有关配置和部署的咨询，还可以出售围绕它的完整托管解决方案。</p><p> Now that we’ve established the problems, the solution, and most importantly, the context in which the solution was made, let’s take a look at the alternatives. The most obvious one, in the spirit of KISS, is to use an RPC library for your preferred language. Here is where the context is crucial: if you have a large fleet of services, each written in its own language/ecosystem, and the only language that they share is HTTP then having a single shared RPC library is going to be hard. Perhaps, you’ve got a fabric of deployed and running services, but everyone is afraid of touching them, no one knows how they work, and each redeploy is an adventure. A service mesh is here to help you, because at least you’ll be able to roll out new infrastructure features to the mesh regularly.</p><p>现在，我们已经确定了问题，解决方案，最重要的是，提出解决方案的背景已经确定，让我们看一下替代方案。秉承KISS的精神，最明显的方法是使用RPC库作为您的首选语言。这是上下文至关重要的地方：如果您有大量的服务，每个服务都以自己的语言/生态系统编写，并且它们共享的唯一语言是HTTP，那么拥有一个共享的RPC库将变得很困难。也许，您已经部署和运行了一些服务，但是每个人都害怕接触它们，没人知道它们是如何工作的，每次重新部署都是一次冒险。服务网格可以为您提供帮助，因为至少您可以定期向网格中推出新的基础架构功能。</p><p> On the other hand, if you have a fleet of healthy services written in a single application stack, then it’s a good idea to think twice before introducing a service mesh. By simply introducing or evolving a shared RPC library, you’ll get the exact same benefits and avoid dealing with the downsides of maintaining service meshes. By studying the service mesh limitations thoroughly, you can avoid finding yourself in the trough of disillusionment.</p><p>另一方面，如果您在单个应用程序堆栈中编写了一系列健康的服务，那么在引入服务网格之前最好三思而后行。通过简单地引入或发展共享的RPC库，您将获得完全相同的好处，并且避免了维护服务网格的弊端。通过彻底研究服务网格限制，您可以避免陷入幻想破灭的低谷。</p><p>  The ecosystem of the service mesh of your choice will likely be different from the ecosystem of your services. Beautiful websites always make you believe that the solution is plug’n’play, always works and never goes down. In reality, sooner or later problems, bugs, quirks in behaviour will reveal themselves, as they always do. At that point, you’ll need to have engineers who work on the service-mesh’s ecosystem which when it’s different from the main app, effectively limits the set of people who can introduce changes or fix problems. This is likely to reintroduce silos, which is against the whole DevOps spirit. Yes, having a DevOps team of engineers who are doing DevOps-y things  is against DevOps.</p><p>您选择的服务网格的生态系统可能与您服务的生态系统不同。漂亮的网站总是让您相信该解决方案是即插即用的，始终有效，而且永远不会失败。实际上，迟早出现的问题，错误，行为怪异都会像往常一样暴露出来。到那时，您需要让工程师在服务网格的生态系统中工作，当该生态系统与主应用程序不同时，该生态系统将有效地限制可以引入更改或解决问题的人员。这很可能会重新引入孤岛，这与整个DevOps精神背道而驰。是的，拥有一个正在进行DevOps-y事务的DevOps工程师团队会反对DevOps。</p><p> Not only having a proxy in front of each service adds overhead (often significant, talking about  90pt rather than 99pt in the performance summary  doesn’t make software run faster) and consumes resources, but you also requires time (or rather a team of people) to manage them. Yes, it can help to make some of the tasks potentially easier - yay, you can now add canary deployments with a few lines of YAML to simple applications now. However, you still need to manage canary deployments of the proxies themselves which don’t have a proxy in front of them. The problems just get pushed up the stack.</p><p>不仅在每个服务之前都有一个代理会增加开销（通常很重要，在性能摘要中谈论90pt而不是99pt并不会使软件运行更快）并消耗资源，而且您还需要时间（或者一组人） ）进行管理。是的，它可以帮助简化某些任务-是的，您现在可以将带有几行YAML的Canary部署添加到简单的应用程序中。但是，您仍然需要管理代理本身的金丝雀部署，这些代理之前没有代理。问题刚被推高了。</p><p> As you’re reading this paragraph, HTTP/3 is slowly being rolled out to the Internet. It uses UDP as transport. Why use UDP rather than create a completely new protocol you ask? That’s because anything but TCP and UDP is simply “blocked” by the boxes, various proxies on the internet - routers, gateways, etc. This phenomenon got named  ossification. So, only TCP or UDP are left is the practical chose, and even UDP is partially blocked by various corporate proxies which slows down the adoption.</p><p>在阅读本段时，HTTP / 3正在缓慢地推广到Internet。它使用UDP作为传输。为什么使用UDP而不是创建您要求的全新协议？那是因为，除了TCP和UDP外，其他任何东西都只是被盒子，互联网上的各种代理（路由器，网关等）“阻止”了。这种现象被称为ossification。因此，仅保留TCP或UDP是实际选择，甚至UDP也被各种公司代理部分阻止，这减慢了采用速度。</p><p> Even though your microservice environment is probably much smaller compared to the Internet, you can draw parallels with service meshes. Proxies can ossify your application architecture by limiting how your services talk to each other, and there is not much benefit in having proxies if you can bypass them. Suppose you want to build a reactive application which is using RSocket over pure tcp? Or perhaps a message-driven application using an actor model? Or maybe push the performance boundaries with Aeron? Not going to happen until the box in the middle becomes aware of the protocol.</p><p>即使您的微服务环境相比Internet而言可能要小得多，您也可以与服务网格进行比较。代理可以通过限制服务之间的通信方式来僵化您的应用程序体系结构，并且如果可以绕过代理，则代理并没有太大好处。假设您要构建一个在纯tcp上使用RSocket的反应式应用程序？还是使用角色模型的消息驱动的应用程序？还是可以突破Aeron的性能界限？直到中间的方框意识到协议后，这种情况才会发生。</p><p> What does it all mean for you as an engineer? The answer to whether you need to adopt the service mesh approach comes down to the state of the microservice environment you’re trying to improve. As we have established, compared to an RPC framework, service meshes allow you to:</p><p>这对您作为工程师意味着什么？是否需要采用服务网格方法的答案取决于您要改善的微服务环境的状态。正如我们已经建立的，与RPC框架相比，服务网格使您能够：</p><p>  The point 1. is important when for whatever reason you can’t redeploy your services very often, e.g. maybe no one remembers how it’s done anymore, or maybe there are other restrictions. The point 2. is important when your stack is heterogeneous, e.g. some services are built in Go, some in Java, some in Haskell, etc. Where are you on the interval from a huge set of heterogeneous services with unknown deployment schedules to a set of homogenous regularly deployed services defines whether a service mesh is the best solution for you.</p><p>如果您出于某种原因无法经常重新部署服务（例如，也许没人记得它是如何做的，或者还有其他限制。当您的堆栈是异构的时，例如点2。有些服务是用Go构建的，有些是用Java构建的，有些是用Haskell生成的，依此类推。您处于从部署计划未知的大量异构服务到定期进行均匀部署的同类服务之间的时间间隔，以确定服务网格是否是最佳的为您解决。</p><p> Service meshes have a lot of hype around them, and way too much in my opinion. However, before committing to a piece of technology, it’s crucial to understand the problems it solves, and the context in which the solution was made. A service mesh is not an ultimate “good practice” but simply one of the patterns to solve a set of issues, and it’s quite a heavy one.</p><p>服务网格周围有很多炒作，我认为这太多了。但是，在致力于一项技术之前，了解其解决的问题以及制定解决方案的环境至关重要。服务网格并不是最终的“良好实践”，而仅仅是解决一系列问题的一种模式，而且相当繁重。</p><p> Rather than jumping on board, look carefully - the last thing you want is to find out that you have invested in a solution for a problem that you don’t have. Service meshes are an amazing piece of tech solving a whole lot of problems. Not in every case, it is the best solution.</p><p>与其仔细观察，不如不做任何准备-您要做的最后一件事就是发现您已为解决您没有的问题投资了解决方案。服务网格是解决许多问题的令人惊奇的技术。并非在每种情况下，它都是最佳解决方案。</p><p>  &#34;You don&#39;t need no Service Mesh&#34;. Just published a new blog post with an anti-hype opinion on the over-hyped topic.  https://t.co/SVXS3nWKzj</p><p>“您不需要任何服务网格”。刚刚发表了一篇新博客文章，对被过度炒作的话题发表了反炒作的看法。 https://t.co/SVXS3nWKzj</p><p>— Sergey Tselovalnikov (@SerCeMan)  July 23, 2020</p><p>-Sergey Tselovalnikov（@ SerCeMan）朱莉娅23，2020</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://serce.me/posts/23-07-2020-you-dont-need-no-service-mesh/">https://serce.me/posts/23-07-2020-you-dont-need-no-service-mesh/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/service/">#service</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>