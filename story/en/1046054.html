<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计Ruby无服务器运行时 Designing a Ruby Serverless Runtime</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Designing a Ruby Serverless Runtime<br/>设计Ruby无服务器运行时 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-24 04:15:07</div><div class="page_narrow text-break page_content"><p>Last week, Google  announced the public beta of the Ruby runtime for  Cloud Functions, Google’s functions-as-a-service (FaaS) hosting platform. Ruby support has lagged a bit behind other languages over the past year or so, but now that we’ve caught up, I thought I’d share some of the design process behind the product.</p><p>上周，Google宣布了Ruby运行时针对Cloud Functions（Google的功能即服务（FaaS）托管平台）的公开测试版。在过去的一年左右的时间里，对Ruby的支持已经落后于其他语言，但是现在我们已经赶上了，我想我会分享该产品背后的一些设计过程。</p><p> This article is not a traditional design document. I won’t go through the design itself step-by-step. Instead, I want to discuss some of the design issues we faced, the decisions we made, and why we made them, because it was an interesting exercise in figuring out how to fuse Ruby conventions with those of the public cloud. Some of the trade-offs we made are, I think, emblematic of the challenges the Ruby community as a whole is facing as the industry evolves.</p><p> 本文不是传统的设计文档。我不会逐步介绍设计本身。相反，我想讨论我们面临的一些设计问题，做出的决定以及为什么做出这些决定，因为这是弄清楚如何将Ruby约定与公共云的约定融合在一起的有趣练习。我认为，我们做出的一些权衡标志着整个Ruby社区随着行业的发展而面临的挑战。</p><p>  Bringing Ruby support to a serverless product is a lot more involved than you might expect. At the most basic level, a language runtime is just a Ruby installation, and sure, it’s not hard to configure a Ruby image and install it on a VM. But things become more complex when you bring “serverless” into the mix. Severless is much more than just automatic maintenance and scaling. It’s an entirely different way of thinking about compute resources, one that goes contrary to much of we’ve been taught about deploying Ruby apps for the past fifteen years. When the Ruby team at Google Cloud took on the task of designing the Ruby runtime for Cloud Functions, we were also taking on the daunting task of proposing a  Ruby way of doing serverless. While remaining true to the Ruby idioms, practices, and tools familiar to our community, we also had to rethink how we approach web application development at almost every level, from code, to dependencies, persistence, testing, everything.</p><p>  为无服务器产品提供Ruby支持比您预期的要复杂得多。从最基本的角度来看，语言运行时只是Ruby的安装，并且可以肯定的是，配置Ruby映像并将其安装在VM上并不难。但是，当您将“无服务器”加入其中时，事情会变得更加复杂。 Severless不仅仅是自动维护和扩展。这是对计算资源的完全不同的思考方式，这与过去15年中我们学到的有关部署Ruby应用程序的许多知识背道而驰。当Google Cloud的Ruby团队承担为Cloud Functions设计Ruby运行时的任务时，我们还承担了提出Ruby的无服务器方式的艰巨任务。在保持社区熟悉的Ruby习惯用法，实践和工具不变的同时，我们还必须重新思考如何在几乎每个级别上进行Web应用程序开发，从代码到依赖，持久性，测试等所有方面。</p><p> This article will examine our approach to five different aspects of the design: function syntax, concurrency and lifecycle, testing, dependencies, and standards. In each case, we’ll see a balance between the importance of remaining true to our Ruby roots, and the desire to embrace the new serverless paradigms. We tried very hard to maintain continuity with the traditional Ruby way of doing things, and we also took cues from other Google Cloud Functions language runtimes, as well as precedents set by serverless products from other cloud providers. However, in a few cases, we chose to blaze a different trail. We did so when we felt that current approaches either abused a language feature, or were misleading and encouraged the wrong ideas about serverless app development.</p><p> 本文将研究我们在设计的五个不同方面的方法：函数语法，并发性和生命周期，测试，依赖项和标准。在每种情况下，我们都将在保持忠实于Ruby根源的重要性与拥抱新的无服务器范式的愿望之间取得平衡。我们非常努力地保持与传统Ruby处理方式的连续性，并且还从其他Google Cloud Functions语言运行时中汲取了线索，并借鉴了其他云提供商的无服务器产品所树立的先例。但是，在少数情况下，我们选择另辟trail径。当我们认为当前的方法滥用语言功能或误导并鼓励有关无服务器应用程序开发的错误想法时，我们就这样做了。</p><p> It’s possible, even likely, that some of these decisions will eventually prove to have been wrong. That’s why I’m offering this article now, to discuss what we’ve done and to start the conversation about how we as the Ruby community practice serverless app development. The good news is that Ruby is a very flexible language, and we will have plenty of opportunity to adapt as we learn and as our needs evolve.</p><p> 其中某些决定最终有可能甚至最终被证明是错误的。这就是为什么我现在提供这篇文章，以讨论我们已经做的事情，并开始关于我们作为Ruby社区如何实践无服务器应用程序开发的对话。好消息是Ruby是一种非常灵活的语言，随着我们的学习和需求的发展，我们将有很多机会适应。</p><p> So let’s take a look at some of the initial design decisions and trade-offs we made and why we made them.</p><p> 因此，让我们看一下我们做出的一些初始设计决策和权衡，以及做出这些决策的原因。</p><p>  “Functions-as-a-Service” (FaaS) is currently one of the more popular serverless paradigms. Google’s Cloud Functions is just one implementation. Many other major cloud providers have their own FaaS product, and there are  open source implementations as well.</p><p>  “功能即服务”（FaaS）当前是较流行的无服务器范例之一。 Google的Cloud Functions只是一种实现。许多其他主要的云提供商都拥有自己的FaaS产品，并且也有开源实现。 </p><p> The idea, of course, is to use a programming model centered not around web servers, but around  functions: stateless pieces of code that take input arguments and return results. It seems like a simple, almost obvious, change in terminology, but it actually has profound implications.</p><p>当然，这种想法是使用一种编程模型，该模型不以Web服务器为中心，而是以函数为中心：无状态的代码段，它们接受输入参数并返回结果。这似乎是一个简单，几乎显而易见的术语更改，但实际上具有深远的意义。</p><p>  The first challenge for Ruby is that, unlike many other programming languages, Ruby actually  doesn’t have first-class functions. Ruby is first and foremost an object-oriented language. When we write code and wrap it in a  def, we are writing a  method, code that runs in response to a  message sent to an  object. This is an important distinction, because the objects and classes that form the context of a method call are not part of the serverless abstraction. So their presence can complicate a serverless application, and even mislead us when we’re writing it.</p><p>  Ruby面临的第一个挑战是，与许多其他编程语言不同，Ruby实际上没有一流的功能。 Ruby首先是一种面向对象的语言。当我们编写代码并将其包装在def中时，我们正在编写一种方法，该代码将响应发送给对象的消息而运行。这是一个重要的区别，因为形成方法调用上下文的对象和类不是无服务器抽象的一部分。因此，它们的存在会使无服务器应用程序复杂化，甚至在编写应用程序时会误导我们。</p><p> For example, some FaaS frameworks let you write a function with a  def at the top level of a Ruby file:</p><p> 例如，某些FaaS框架使您可以在Ruby文件的顶层编写带有def的函数：</p><p>  While this code appears straightforward, it’s important to remember what it actually does. It adds this “function” as a private method on the  Object class, the base class of the Ruby class hierarchy. In other words, the “function” has been added to  nearly every object in the Ruby virtual machine. (Unless, of course, the application changes the main object and class context when loading the file, a technique that carries other risks.) At best, this breaks encapsulation and single responsibility. At worst, it risks interfering with the functionality of your application, its dependencies, or even the Ruby standard library. This is why such “top level” methods, while common in simple single-file Ruby scripts and Rakefiles, are not recommended in larger Ruby applications.</p><p>  尽管这段代码看起来很简单，但重要的是要记住它的实际作用。它将此“函数”作为私有方法添加到Object类（Ruby类层次结构的基类）上。换句话说，“功能”已被添加到Ruby虚拟机中的几乎每个对象中。 （当然，除非应用程序在加载文件时更改主要对象和类上下文，否则该技术会带来其他风险。）充其量，这会破坏封装和单一职责。最坏的情况是，它有可能干扰应用程序的功能，其依赖项甚至是Ruby标准库的风险。这就是为什么在大型Ruby应用程序中不建议在简单的单文件Ruby脚本和Rakefile中使用这种“顶层”方法的原因。</p><p> The Google Ruby team decided this issue was serious enough that we chose a different syntax, writing functions as blocks:</p><p> Google Ruby小组认为此问题非常严重，我们选择了另一种语法，将函数编写为块：</p><p>  This provides a Ruby-like way to define functions without modifying the  Object base class. It also has a few side benefits:</p><p>  这提供了一种类似于Ruby的方法来定义函数，而无需修改Object基类。它还有一些附带好处：</p><p> The name (“handler” in this case) is just a string argument. It doesn’t need to be a legal Ruby method name, nor is there any concern of it colliding with a Ruby keyword.</p><p> 名称（在这种情况下为“ handler”）只是一个字符串参数。它不必是合法的Ruby方法名称，也不必担心它与Ruby关键字冲突。 </p><p>  Blocks exhibit more traditional lexical scoping than do methods, so this will behave more similarly to functions in other languages.</p><p>块比方法具有更多的传统词法作用域，因此其行为与其他语言中的函数更相似。</p><p>  The block syntax makes it easier to manage function definitions. For example, it’s possible to “undefine” functions cleanly, which is important for testing.</p><p>  块语法使管理函数定义更加容易。例如，可以干净地“取消定义”功能，这对于测试很重要。</p><p>  It requires a library to provide the interface for defining functions as blocks. (Here, Ruby follows other language runtimes for Cloud Functions by utilizing a  Functions Framework library.)</p><p>  它需要一个库来提供用于将功能定义为块的接口。 （此处，Ruby通过使用Functions Framework库遵循了Cloud Functions的其他语言运行时。）</p><p>   Concurrency is hard. This is one of the key observations underlying the design of serverless in general, and functions-as-a-service in particular: that we live in a concurrent world and we need ways to cope. The functional paradigm addresses concurrency by insisting that functions not share state (except through an external persistence system such as a queue or database).</p><p>   并发很难。这是一般无服务器，尤其是功能即服务的设计所基于的主要观察之一：我们生活在一个并发的世界中，我们需要应对之道。功能范例通过坚持功能不共享状态（通过队列或数据库之类的外部持久性系统除外）来解决并发问题。</p><p> This is in fact another reason we chose to use block syntax rather than method syntax. Methods imply objects, which carry state in the form of instance variables, state that might not work as expected in a stateless FaaS environment. Eschewing methods is a subtle but effective syntactic way to discourage practices we know to be problematic.</p><p> 实际上，这是我们选择使用块语法而不是方法语法的另一个原因。方法隐含以实例变量形式携带状态的对象，这些状态在无状态FaaS环境中可能无法按预期工作。回避方法是一种微妙但有效的句法方式，可以阻止我们知道存在问题的做法。</p><p> That said, what if you need to share  resources, such as database connection pools? When would you initialize such resources, and how would you access them?</p><p> 就是说，如果您需要共享资源（例如数据库连接池）怎么办？您何时会初始化此类资源，以及如何访问它们？</p><p> For this purpose, the Ruby runtime supports  startup functions that can initialize resources and passes them into function calls. Importantly, while the startup function can create resources, normal functions can only read them.</p><p> 为此，Ruby运行时支持可初始化资源并将其传递到函数调用中的启动功能。重要的是，尽管启动功能可以创建资源，但普通功能只能读取它们。 </p><p> require  &#34;functions_framework&#34; # Use an on_startup block to initialize a shared client and store it in # the global shared data. FunctionsFramework . on_startup  do  require  &#34;google/cloud/storage&#34;  set_global  :storage_client ,  Google :: Cloud :: Storage . new end # The shared storage_client can be accessed by all function invocations # via the global shared data. FunctionsFramework . http  &#34;storage_example&#34;  do  | request |  bucket  =  global ( :storage_client ). bucket  &#34;my-bucket&#34;  file  =  bucket . file  &#34;path/to/my-file.txt&#34;  file . download . to_s end</p><p>需要＆＃34; functions_framework＆＃34; ＃使用on_startup块初始化共享客户端并将其存储在＃全局共享数据中。功能框架。 on_startup确实需要＆＃34; google / cloud / storage＆＃34; set_global：storage_client，Google :: Cloud :: Storage。 new end＃所有功能调用均可通过全局共享数据访问共享的storage_client。功能框架。 http＆＃34; storage_example＆＃34;做要求| bucket =全局（：storage_client）。桶＆＃34;我的桶＆＃34;文件=桶。文件＆＃34; path / to / my-file.txt＆＃34;文件。下载 。发送</p><p> Notice that we chose to define special methods  global and  set_global to interact with global resources. (By the way, these are not methods on Object, but methods on a specific class we use as the function context.) Again, we could have used more traditional idioms such as Ruby global variables, or even a constructor and instance variables, to pass information from startup code to function calls. However, those idioms would have communicated the wrong things. We’re not writing ordinary Ruby classes and methods where sharing data is normal, but  serverless functions where sharing data is hazardous if even possible, and we felt it was important for the  syntax to emphasize the distinction. The special methods were a deliberate design decision, to discourage practices could be dangerous in the presence of concurrency.</p><p> 注意，我们选择定义特殊方法global和set_global与全局资源进行交互。 （顺便说一句，这些不是对象上的方法，而是我们用作函数上下文的特定类上的方法。）同样，我们可以使用更多传统习语（例如Ruby全局变量，甚至构造函数和实例变量）来将信息从启动代码传递给函数调用。但是，这些成语会传达错误的信息。我们不是在编写正常共享数据的普通Ruby类和方法，而是编写无服务器功能（即使有可能共享数据也是危险的），并且我们认为语法必须强调区别。特殊的方法是经过深思熟虑的设计决策，在存在并发的情况下阻止实践可能很危险。</p><p>  A strong testing culture is central to the Ruby community. Popular frameworks, such as Rails, acknowledge this and encourage active testing by providing testing tools and scaffolding as part of the framework, and the Ruby runtime for Google Cloud Functions follows suit by providing testing tools for serverless functions.</p><p>  强大的测试文化对于Ruby社区至关重要。流行的框架（例如Rails）承认了这一点，并通过提供测试工具和框架作为框架的一部分来鼓励主动测试，而Google Cloud Functions的Ruby运行时则通过提供无服务器功能的测试工具来效仿。</p><p> The FaaS paradigm actually fits very well with tests. Functions are by nature easily testable; simply pass in arguments and assert against results. In particular, you don’t need to spin up a web server to run tests, because web servers are not part of the abstraction. The Ruby runtime provides a module of helper methods for creating HTTP request and Cloud Event objects to use as inputs, and otherwise most tests are very straightforward to write.</p><p> FaaS范式实际上非常适合测试。功能本质上易于测试；只需传递参数并声明结果即可。特别是，您不需要启动网络服务器来运行测试，因为网络服务器不是抽象的一部分。 Ruby运行时提供了一个辅助方法模块，用于创建HTTP请求和Cloud Event对象以用作输入，否则大多数测试都非常容易编写。</p><p> One of the main testing challenges we encountered, though, had to do with testing  initialization code. Indeed, this is an issue that some of Google’s Ruby team members have had with other frameworks, including Rails: it is difficult to test an app’s initialization process, because framework initialization typically happens outside the tests, before they run. We therefore designed a way for tests to isolate the entire lifecycle of a function, including initialization. This allows us to run initialization within a test, and even repeat it multiple times allowing tests of different aspects:</p><p> 但是，我们遇到的主要测试挑战之一与测试初始化​​代码有关。确实，这是Google的一些Ruby团队成员在其他框架（包括Rails）中遇到的一个问题：测试应用程序的初始化过程非常困难，因为框架初始化通常在测试运行之前就在测试之外进行。因此，我们设计了一种测试方法，以隔离功能的整个生命周期，包括初始化。这使我们可以在测试中运行初始化，甚至可以重复多次以进行不同方面的测试：</p><p> require  &#34;minitest/autorun&#34; require  &#34;functions_framework/testing&#34; class  MyTest  &lt;  Minitest :: Test  # Include testing helper methods  include  FunctionsFramework :: Testing  def  test_startup_tasks  # Run the lifecycle, and test the startup tasks in isolation.  load_temporary  &#34;app.rb&#34;  do  globals  =  run_startup_tasks  &#34;storage_example&#34;  assert_kind_of  Google :: Cloud :: Storage ,  globals [ :storage_client ]  end  end  def  test_storage_request  # Rerun the entire lifecycle, including the startup tasks, and  # test a function call.  load_temporary  &#34;app.rb&#34;  do  request  =  make_get_request  &#34;https://example.com/foo&#34;  response  =  call_http  &#34;storage_example&#34; ,  request  assert_equal  200 ,  response . status  end  end end</p><p> 需要＆＃34;最小/自动运行＆＃34;需要＆＃34; functions_framework / testing＆＃34;类MyTest＆lt; Minitest ::测试＃包括测试辅助方法，包括FunctionsFramework ::测试def test_startup_tasks＃运行生命周期，并单独测试启动任务。 load_temporary＆＃34; app.rb＆＃34;做全局变量= run_startup_tasks＆＃34; storage_example＆＃34; assert_kind_of Google :: Cloud :: Storage，全局变量[：storage_client] end end def test_storage_request＃重新运行整个生命周期，包括启动任务，并＃测试函数调用。 load_temporary＆＃34; app.rb＆＃34;做请求= make_get_request＆＃34; https：//example.com/foo&#34;响应= call_http＆＃34; storage_example＆＃34; ，要求assert_equal 200，响应。状态结束结束结束</p><p> The  load_temporary method loads function definitions in a sandbox, isolating them and their initialization from other test runs. That and other helper methods are defined in the  FunctionsFramework::Testing module, which can be included in minitest or rspec tests.</p><p> load_temporary方法将功能定义加载到沙箱中，将它们及其初始化与其他测试运行隔离开。该方法和其他辅助方法在FunctionsFramework :: Testing模块中定义，可以包含在minitest或rspec测试中。 </p><p> So far we’ve really provided only basic testing tools for the Ruby runtime, and I expect we’ll add significantly to the toolset as our users develop more apps and we identify more of the common testing patterns. But I strongly believe testing tools are an important part of any library, especially one that purports to be a framework or runtime, and so it was a core part of our design from the start.</p><p>到目前为止，我们实际上仅提供了针对Ruby运行时的基本测试工具，并且我希望随着用户开发更多应用程序并确定更多常见测试模式，我们将大大增加该工具集。但是我坚信测试工具是所有库的重要组成部分，尤其是那些声称是框架或运行时的库，因此从一开始它就是设计的核心部分。</p><p>  Most nontrivial Ruby apps require third-party gems. For Ruby apps that use Google Cloud Functions, we require at least one gem, the  functions_framework that provides the Ruby interfaces for writing functions. You may also need other gems for handling data, authenticating and integrating with other services, and so forth. Dependency management is a crucial part of any runtime framework.</p><p>  大多数不平凡的Ruby应用程序都需要第三方gem。对于使用Google Cloud Functions的Ruby应用程序，我们至少需要一个gem，即functions_framework，它提供用于编写​​函数的Ruby接口。您可能还需要其他gem来处理数据，进行身份验证并与其他服务集成等等。依赖性管理是任何运行时框架的关键部分。</p><p> We made several design decisions around dependency management. And the first and most important was to embrace  Bundler.</p><p> 我们围绕依赖项管理做出了一些设计决策。首先，也是最重要的是拥抱邦德勒。</p><p> I know that sounds a bit frivolous. Most Ruby apps these days use Bundler anyway, and there are very few alternatives, hardly any in widespread use. But we actually took it a step further and built Bundler deep into our infrastructure,  requiring that apps use it in order to work with Cloud Functions. We did this because, knowing exactly how an app will manage its dependencies would allow us to implement some important optimizations.</p><p> 我知道这听起来有点轻浮。如今，大多数Ruby应用程序仍在使用Bundler，并且几乎没有替代品，几乎没有广泛使用。但实际上，我们进一步走了一步，将Bundler深入构建到我们的基础架构中，要求应用程序使用它才能与Cloud Functions一起使用。我们这样做是因为，确切地知道应用程序将如何管理其依赖项将使我们能够实施一些重要的优化。</p><p>  Vital to a good FaaS system is the speed of deployments and cold starts. In a serverless world, your code might be updated, deployed, and torn down many times in rapid succession, so it’s crucial to eliminate bottlenecks such as resolving and installing dependencies. Because we standardize on one system for dependency management, we are able to  cache dependencies aggressively. We judged that the performance gains of implementing such caching, as well as the reduced load on the Rubygems.org infrastructure, far outweighed the reduced flexibility of not being able to use an alternative to Bundler.</p><p>  良好的FaaS系统的关键是部署和冷启动的速度。在无服务器的世界中，您的代码可能会快速连续地更新，部署和拆除多次，因此消除瓶颈（如解决和安装依赖项）至关重要。因为我们在一个系统上对依赖关系管理进行了标准化，所以我们能够积极地缓存依赖关系。我们认为，实现这种缓存的性能提高以及Rubygems.org基础结构上的负载减少，远远超过了无法使用Bundler替代项所带来的灵活性降低。</p><p> Another feature, or maybe quirk, of the Ruby runtime for Google Cloud Functions, is that it will fail deployments if the gem lockfile is missing or inconsistent. We require that  Gemfile.lock is present when you deploy. This was another decision made to enforce a best practice. If the lockfile gets reresolved during deployment, your builds may not be repeatable, and you may not be running against the same dependencies you tested with. We avoid this by requiring an up-to-date  Gemfile.lock file, and again, we are able to enforce this because we require the use of Bundler.</p><p> Google Cloud Functions的Ruby运行时的另一个功能（也许是怪癖）是，如果gem lockfile丢失或不一致，部署将失败。部署时，我们要求Gemfile.lock存在。这是执行最佳实践的另一个决定。如果在部署过程中重新解析了锁定文件，则您的构建可能无法重复，并且可能无法与测试时使用的依赖项相同。我们通过要求使用最新的Gemfile.lock文件来避免这种情况，并且由于我们需要使用Bundler，因此我们能够执行此操作。</p><p>  Finally, good designs lean on standards and prior art. We had to innovate a bit to define robust functions in Ruby, but when it comes to representing the function arguments, there were already existing libraries or emerging standards to follow.</p><p>  最后，好的设计取决于标准和现有技术。我们不得不进行一些创新，以便在Ruby中定义健壮的函数，但是在表示函数参数时，已经存在现有的库或新兴标准。 </p><p> For example, in the near term, many functions will respond to  web hooks, and will need information about the incoming HTTP request. It would not be difficult to design a class that represents an HTTP request, but the Ruby community already has a standard API for this sort of thing:  Rack. We adopted the Rack request class for our event parameters, and we support standard Rack responses for return values.</p><p>例如，在短期内，许多功能将响应Web挂钩，并且将需要有关传入HTTP请求的信息。设计一个代表HTTP请求的类并不难，但是Ruby社区已经为这种事情提供了一个标准的API：Rack。我们为事件参数采用了Rack请求类，并且支持返回值的标准Rack响应。</p><p> require  &#34;functions_framework&#34; FunctionsFramework . http  &#34;http_example&#34;  do  | request |  # request is a Rack::Request object.  logger . info  &#34;I received  #{ request . request_method }  from  #{ request . url } !&#34;  # You can return a standard Rack response array, or use one of  # several convenience formats.  [ 200 ,  {},  &#34;ok&#34; ] end</p><p> 需要＆＃34; functions_framework＆＃34;功能框架。 http＆＃34; http_example＆＃34;做要求| ＃request是一个Rack :: Request对象。记录器。信息＆＃34;我收到＃{请求。来自＃{request的request_method}。 url}！＆＃34; ＃您可以返回标准的机架响应阵列，或使用＃几种便捷格式之一。 [200，{}，＆＃34; ok＆＃34; ] 结束</p><p> Not only does this provide a familiar API, but it also makes it easy to integrate with other Rack-based libraries. For example, it is easy to layer a  Sinatra app atop Cloud Functions because they both speak Rack.</p><p> 这不仅提供了熟悉的API，而且还使它易于与其他基于Rack的库集成。例如，将Sinatra应用程序放在Cloud Functions上很容易，因为它们都说Rack。</p><p> In the longer term, we increasingly expect functions-as-a-service to fit as a component in  evented systems. Event-based architectures are rapidly growing in popularity, often surrounding event queues such as  Apache Kafka. And a crucial element of an event architecture is a standard way to describe the events themselves, a standard understood by event senders, brokers, transport, and consumers.</p><p> 从长远来看，我们越来越希望功能即服务能够作为事件系统中的组件来使用。基于事件的体系结构迅速流行，通常围绕诸如Apache Kafka之类的事件队列。事件体系结构的关键要素是描述事件本身的标准方法，这是事件发送者，代理，传输和消费者所理解的标准。</p><p> Google Cloud Functions has thrown its support behind  CNCF CloudEvents, an emerging standard for describing and delivering events. In addition to HTTP requests, Cloud Functions can also receive data in the form of a CloudEvent, and the runtime will even convert some legacy event types to CloudEvents when calling your function.</p><p> Google Cloud Functions已将其支持支持CNCF CloudEvents（一种用于描述和传递事件的新兴标准）。除了HTTP请求之外，Cloud Functions还可以以CloudEvent的形式接收数据，并且运行时甚至会在调用函数时将某些旧式事件类型转换为CloudEvents。</p><p> require  &#34;functions_framework&#34; FunctionsFramework . cloud_event  &#34;my_handler&#34;  do  | event |  # event is a CloudEvent object defined by the cloud_events gem  logger . info  &#34;I received a CloudEvent of type  #{ event . type } !&#34; end</p><p> 需要＆＃34; functions_framework＆＃34;功能框架。 cloud_event＆＃34; my_handler＆＃34;做事件＃event是一个由cloud_events gem logger定义的CloudEvent对象。信息＆＃34;我收到了＃{event类型的CloudEvent。输入}！＆＃34;结束</p><p> To support CloudEvents in Ruby, the Google Ruby team worked closely with the CNCF Serverless Working Group, and even volunteered to take over development of the  Ruby SDK for CloudEvents. This turned out to be a lot of work, but we considered it crucial to be able to use the official, standard Ruby interfaces, even if we had to implement it ourselves.</p><p> 为了在Ruby中支持CloudEvents，Google Ruby小组与CNCF无服务器工作组密切合作，甚至自愿接管了CloudEvents Ruby SDK的开发。事实证明，这是很多工作，但是我们认为，即使必须自己实现它，使用正式的标准Ruby接口也至关重要。 </p><p>  “Serverless” and “functions-as-a-service” hosting has garnered a lot of interest over the past few years. I think the jury is still out on how useful it will be for most workloads, but the possibilities are intriguing. “Zero”-devops, automatic maintenance and scaling, no servers to maintain, and pay only for the compute resources you actually use. I recently  moved this very blog from a personal  Kubernetes cluster to Google’s managed  Cloud Run service, and slashed my monthly bill from dozens of dollars down to pennies.</p><p>在过去的几年中，“无服务器”和“功能即服务”托管引起了很多关注。我认为对于大多数工作负载的实用性尚无定论，但可能性令人着迷。 “零”开发，自动维护和扩展，无需维护服务器，仅支付您实际使用的计算资源。我最近将这个博客从一个个人Kubernetes集群转移到了Google托管的Cloud Run服务，并将我的每月账单从几十美元削减到了几美分。</p><p> That said, serverless is a fundamentally different way of thinking about compute resources, and as an industry we are still very early in our understanding of the implications. As my team designed the Ruby runtime for Google Cloud Functions, we were mindful about the ways the serverless paradigm interacts with our normal Ruby practices. In some cases, as with testing, it encourages us to double down on the good parts of Ruby culture. In others, as with how to express and notate a function in a language that strictly speaking doesn’t have them, it challenges our ideas of how to present code and communicate its intent.</p><p> 也就是说，无服务器是从根本上不同的方式来考虑计算资源，并且作为一个行业，我们对含义的理解还处于早期。在我的团队为Google Cloud Functions设计Ruby运行时时，我们很注意无服务器范例与常规Ruby实践的交互方式。在某些情况下，就像进行测试一样，它鼓励我们更加深入地研究Ruby文化。在其他情况下，就像如何使用严格说来没有语言的语言来表达和注释功能一样，它也挑战了我们关于如何呈现代码和传达其意图的想法。</p><p> But in all cases, the experience of designing the runtime reminded me that we’re in a industry of constant change. Serverless is just the latest in a string of disruptions that have included the public cloud in general, and even Rails, and Ruby itself. It’s not yet clear how much serverless will stick, but it is here today, and it’s up to us to respond with curiosity, creativity, and a willingness not to take what we know for granted.</p><p> 但是在所有情况下，设计运行时的经验提醒我，我们处于一个不断变化的行业。无服务器只是一系列中断中的最新一次，包括一般的公共云，甚至包括Rails以及Ruby本身。目前尚不清楚会出现多少无服务器，但今天就在这里，我们有责任以好奇心，创造力和愿意不理会我们想当然的方式做出回应。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://daniel-azuma.com/blog/2021/01/20/designing-a-ruby-serverless-runtime">https://daniel-azuma.com/blog/2021/01/20/designing-a-ruby-serverless-runtime</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/运行/">#运行</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>