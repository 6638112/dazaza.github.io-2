<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Dropbox中的异步任务调度</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dropbox中的异步任务调度</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 03:49:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/9035d492b01b5b9d4a3e22813a50167b.png"><img src="http://img2.diglog.com/img/2020/11/9035d492b01b5b9d4a3e22813a50167b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I joined Dropbox not long after graduating with a Master’s degree in computer science. Aside from an internship, this was my first big-league engineering job. My team had already begun designing a critical internal service that most of our software would use: It would handle asynchronous computing requests behind the scenes, powering everything from dragging a file into a Dropbox folder to scheduling a marketing campaign.</p><p>我在计算机科学硕士毕业后不久就加入了Dropbox。除了实习，这是我在大联盟的第一份工程工作。我的团队已经开始设计一个关键的内部服务，我们的大多数软件都会使用它：它将在幕后处理异步计算请求，为从将文件拖入Dropbox文件夹到安排营销活动的一切提供动力。</p><p> This Asynchronous Task Framework (ATF) would replace multiple bespoke async systems used by different engineering teams. It would reduce redundant development, incompatibilities, and reliance on legacy software. There were no open-source projects or buy-not-build solutions that worked well for our use case and scale, so we had to create our own. ATF is both an important and interesting challenge, though, so we were happy to design, build and deploy our own in-house service.</p><p>这个异步任务框架(ATF)将取代不同工程团队使用的多个定制的异步系统。它将减少重复开发、不兼容性和对遗留软件的依赖。没有适合我们用例和规模的开源项目或购买而不是构建的解决方案，所以我们必须创建自己的解决方案。ATF既是一个重要的挑战，也是一个有趣的挑战，所以我们很高兴设计、构建和部署我们自己的内部服务。</p><p> ATF not only had to work well, it had to work well at scale: It would be a foundational building block of Dropbox infrastructure. It would need to handle 10,000 async tasks per second from the start, and be architected for future growth. It would need to support nearly 100 unique async task types from the start, again with room to grow. There were at least two dozen engineering teams that would want to use it for entirely different parts of our codebase, for many products and services.</p><p>ATF不仅必须运转良好，而且必须在规模上运转良好：它将成为Dropbox基础设施的基础构件。它从一开始就需要每秒处理10,000个异步任务，并为未来的增长量身定做。它需要从一开始就支持近100种独特的异步任务类型，而且还有增长的空间。至少有24个工程团队希望将其用于我们代码库的完全不同的部分，用于许多产品和服务。</p><p> As any engineer would, we Googled to see what other companies with mega-scale services had done to handle async tasks. We were disappointed to find little material published by engineers who built supersized async services.</p><p>就像任何工程师都会做的那样，我们在谷歌上搜索，看看其他拥有大规模服务的公司在处理异步任务方面做了什么。我们失望地发现，建造超大型异步服务的工程师几乎没有发表什么材料。</p><p> Now that ATF is deployed and currently serving 9,000 async tasks scheduled per second and in use by 28 engineering teams internally, we’re glad to fill that information gap. We’ve documented Dropbox ATF thoroughly, as a reference and guide for the engineering community seeking their own async solutions.</p><p>现在ATF已经部署，目前每秒为9000个计划的异步任务提供服务，并由28个工程团队在内部使用，我们很高兴能填补这一信息空白。我们详细记录了Dropbox ATF，作为寻求自己的异步解决方案的工程界的参考和指南。</p><p>  Scheduling asynchronous tasks on-demand is a critical capability that powers many features and internal platforms at Dropbox. Async Task Framework (ATF) is the infrastructural system that supports this capability at Dropbox through a callback-based architecture. ATF enables developers to define callbacks, and schedule tasks that execute against these pre-defined callbacks.</p><p>按需调度异步任务是一项关键功能，它为Dropbox的许多功能和内部平台提供了支持。异步任务框架(ATF)是通过基于回调的架构在Dropbox支持此功能的基础设施系统。ATF使开发人员能够定义回调，并调度针对这些预定义回调执行的任务。</p><p> Since its introduction over a year ago, ATF has gone on to become an important building block in the Dropbox infrastructure, used by nearly 30 internal teams across our codebase. It currently supports 100+ use cases which require either immediate or delayed task scheduling.</p><p>自一年多前引入以来，ATF已经成为Dropbox基础设施中的重要构建块，被我们代码库中的近30个内部团队使用。它目前支持100多个需要立即或延迟任务调度的用例。</p><p>  Some basic terms repeatedly used in this post, defined as used in the context of this discussion.</p><p>在这篇文章中反复使用的一些基本术语，定义为在本讨论的上下文中使用。</p><p>  Task: Unit of execution of a lambda. Each asynchronous job scheduled with ATF is a task.</p><p>任务：执行波长的单位。使用ATF调度的每个异步作业都是一个任务。</p><p> Collection: A labeled subset of tasks belonging to a lambda. If  send email is implemented as a lambda, then  password reset email and  marketing email would be collections.</p><p>集合：属于lambda的带标签的任务子集。如果将Send Email实现为lambda，则密码重置电子邮件和营销电子邮件将是集合。</p><p>  Task scheduling Clients can schedule tasks to execute at a specified time. Tasks can be scheduled for immediate execution, or delayed to fit the use case.</p><p>任务调度客户端可以调度任务在指定时间执行。任务可以计划为立即执行，也可以根据用例推迟执行。</p><p> Priority based execution Tasks should be associated with a priority. Tasks with higher priority should get executed before tasks with a lower priority once they are ready for execution.</p><p>基于优先级的执行任务应该与优先级相关联。一旦优先级较高的任务准备好执行，就应该在优先级较低的任务之前执行。</p><p> Task gating ATF enables the the gating of tasks based on lambda, or a subset of tasks on a lambda based on collection. Tasks can be gated to be completely dropped or paused until a suitable time for execution.</p><p>任务选通ATF允许基于lambda的任务选通，或者基于集合的lambda上的任务子集的选通。可以选择完全删除或暂停任务，直到合适的执行时间。</p><p>  At-least once task execution The ATF system guarantees that a task is executed at least once after being scheduled. Execution is said to be complete once the user-defined callback signals task completion to the ATF system.</p><p>至少一次任务执行，ATF系统保证任务在被调度后至少执行一次。一旦用户定义的回调向ATF系统发出任务完成的信号，就可以说执行完成了。</p><p> No concurrent task execution The ATF system guarantees that at most one instance of a task will be actively executing at any given in point. This helps users write their callbacks without designing for concurrent execution of the same task from different locations.</p><p>无并发任务执行ATF系统保证在任何给定时间点最多有一个任务实例在活动执行。这有助于用户编写回调，而无需设计从不同位置并发执行同一任务。</p><p> Isolation Tasks in a given lambda are isolated from the tasks in other lambdas. This isolation spans across several dimensions, including worker capacity for task execution and resource use for task scheduling. Tasks on the same lambda but different priority levels are also isolated in their resource use for task scheduling.</p><p>给定lambda中的隔离任务与其他lambda中的任务隔离。这种隔离跨越多个维度，包括任务执行的工作人员能力和任务调度的资源使用。相同lambda但不同优先级上的任务在用于任务调度的资源使用上也是孤立的。</p><p>  High availability for task scheduling The ATF service is 99.9% available to accept task scheduling requests from any client.</p><p>任务调度的高可用性ATF服务99.9%可用于接受来自任何客户端的任务调度请求。</p><p>  Idempotence A single task on a lambda can be executed multiple times within the ATF system. Developers should ensure that their lambda logic and correctness of task execution in clients are not affected by this.</p><p>幂等在ATF系统中，一个lambda上的单个任务可以多次执行。开发人员应该确保他们的lambda逻辑和客户端任务执行的正确性不受此影响。</p><p> Resiliency Worker processes which execute tasks might die at any point during task execution. ATF retries abruptly interrupted tasks, which could also be retried on different hosts. Lambda owners must design their lambdas such that retries on different hosts do not affect lambda correctness.</p><p>执行任务的弹性工作进程可能在任务执行过程中的任何时刻死亡。ATF重试突然中断的任务，也可以在不同的主机上重试。Lambda所有者必须设计他们的lambda，以便在不同主机上重试不会影响lambda的正确性。</p><p> Terminal state handling ATF retries tasks until they are signaled to be complete from the lambda logic. Client code can mark a task as successfully completed, fatally terminated, or retriable. It is critical that lambda owners design clients to signal task completion appropriately to avoid misbehavior such as infinite retries.</p><p>终端状态处理ATF重试任务，直到从lambda逻辑发信号通知它们完成。客户端代码可以将任务标记为成功完成、致命终止或可重试。重要的是，lambda所有者将客户端设计为适当地发出任务完成的信号，以避免无限次重试等错误行为。</p><p>   In this section, we describe the high-level architecture of ATF and give brief description of its different components. (See Fig. 1 above.) In this section, we describe the high-level architecture of ATF and give brief description of its different components. (See Fig. 1 above.) Dropbox  uses gRPC for remote calls and our in-house  Edgestore to store tasks.</p><p>在这一部分中，我们描述了ATF的高层体系结构，并简要描述了它的不同组件。(见上图1)。在这一节中，我们描述ATF的高层体系结构，并对其不同组件进行简要描述。(见上文图1。)。Dropbox使用GRPC进行远程调用，并使用我们内部的Edsterore来存储任务。</p><p>   Frontend  This is the service that schedules requests via an RPC interface. The frontend accepts RPC requests from clients and schedules tasks by interacting with ATF’s task store described below.</p><p>前端这是通过RPC接口调度请求的服务。前端接受来自客户端的RPC请求，并通过与ATF的任务存储交互来调度任务，如下所述。</p><p> Task Store  ATF tasks are stored in and triggered from the task store. The task store could be any generic data store with indexed querying capability. In ATF’s case, We use our in-house metadata store Edgestore to power the task store. More details can be found in the  D ata  M odel section below.</p><p>任务存储区ATF任务存储在任务存储区中，并从任务存储区触发。任务存储可以是具有索引查询能力的任何通用数据存储。在ATF的例子中，我们使用我们内部的元数据存储Edsterore来支持任务存储。更多细节可以在下面的Data模型部分找到。</p><p> Store Consumer  The Store Consumer is a service that periodically polls the task store to find tasks that are ready for execution and pushes them onto the right queues, as described in the queue section below. These could be tasks that are newly ready for execution, or older tasks that are ready for execution again because they either failed in a retriable way on execution, or were dropped elsewhere within the ATF system.</p><p>商店消费者商店消费者是一项服务，它定期轮询任务存储以查找准备执行的任务，并将它们推入正确的队列，如下面的队列部分所述。这些任务可能是新准备执行的任务，也可能是因为在执行时以可回收的方式失败，或者在ATF系统中的其他位置被丢弃而准备再次执行的较旧任务。</p><p> repeat every second: 1. poll tasks ready for execution from task store 2. push tasks onto the right queues 3. update task statuses</p><p>每秒钟重复一次：1.从任务存储中轮询准备执行的任务2.将任务推送到正确的队列中3.更新任务状态。</p><p> The Store Consumer polls tasks that failed in earlier execution attempts. This helps with the at-least-once guarantee that the ATF system provides. More details on how the Store Consumer polls new and previously failed tasks is presented in the  Lifecycle of a task section below.</p><p>Store Consumer轮询在较早的执行尝试中失败的任务。这有助于ATF系统提供至少一次的保证。有关Store Consumer如何轮询新的和以前失败的任务的更多详细信息，请参见下面的任务生命周期部分。</p><p> Queue  ATF uses AWS  Simple Queue Service (SQS) to queue tasks internally. These queues act as a buffer between the Store Consumer and Controllers (described below). Each  &lt;lambda, priority&gt;  pair gets a dedicated SQS queue. The total number of SQS queues used by ATF is  #lambdas x #priorities.</p><p>队列ATF使用AWS简单队列服务(SQS)在内部对任务进行排队。这些队列充当Store Consumer和控制器(如下所述)之间的缓冲区。每个&lt；lambda、Priority&gt；对都有一个专用的SQS队列。ATF使用的SQS队列总数是#lambdas x#Priority。</p><p> Controller  Worker hosts are physical hosts dedicated for task execution. Each worker host has one controller process responsible for polling tasks from SQS queues in a background thread, and then pushing them onto process local buffered queues. The Controller is only aware of the lambdas it is serving and thus polls only the limited set of necessary queues.</p><p>控制器工作主机是专用于任务执行的物理主机。每个工作主机都有一个控制器进程，负责从后台线程中的SQS队列轮询任务，然后将它们推送到进程本地缓冲队列中。控制器只知道它正在服务的lambdas，因此只轮询所需队列的有限集合。</p><p> TheController serves tasks from its process local queue as a response to  NextWork RPCs. This is the layer where execution level task prioritization occurs. The Controller has different process level queues for tasks of different priorities and can thus prioritize tasks in response to  NextWork RPCs.</p><p>控制器提供来自其进程本地队列的任务，作为对NExtWORK RPC的响应。这是执行级别任务优先级排序发生的层。控制器对不同优先级的任务有不同的进程级别队列，因此可以响应NExtWORK RPC来确定任务的优先级。</p><p> Executor  The Executor is a process with multiple threads, responsible for the actual task execution. Each thread within an Executor process follows this simple loop:</p><p>执行器执行器是一个具有多个线程的进程，负责实际任务的执行。Executor进程中的每个线程都遵循这个简单的循环：</p><p>  Each worker host has a single Controller process and multiple executor processes. Both the Controller and Executors work in a “pull” model, in which active loops continuously long-poll for new work to be done.</p><p>每个工作主机都有一个控制器进程和多个执行器进程。控制器和执行器都在“拉”模式下工作，在这种模式下，活动循环不断地长时间轮询要完成的新工作。</p><p> Heartbeat and Status Controller (HSC) The HSC serves RPCs for claiming a task for execution ( ClaimTask), setting task status after execution ( SetResults) and heartbeats during task execution ( Heartbeat).  ClaimTask requests originate from the Controllers in response to  NextWork requests.  Heartbeat and  SetResults requests originate from executor processes during and after task execution. The HSC interacts with the task store to update the task status on the kind of request it receives.</p><p>心跳和状态控制器(HSC)HSC为RPC提供服务，用于声明要执行的任务(ClaimTask)、设置执行后的任务状态(SetResults)以及任务执行期间的心跳(HeartBeats)。ClaimTask请求来自控制器，以响应NExtWORK请求。心跳和SetResults请求源自任务执行过程中和之后的Executor进程。HSC与任务存储交互，以更新其接收到的请求类型的任务状态。</p><p>  ATF uses our in-house metadata store, Edgestore, as a task store. Edgestore objects can be Entities or Associations ( assoc), each of which can have user-defined attributes. Associations are used to represent relationships between entities. Edgestore supports indexing only on attributes of associations.</p><p>ATF使用我们内部的元数据存储库Edsterore作为任务存储库。Edsterore对象可以是实体或关联(ASSOC)，每个实体或关联都可以有用户定义的属性。关联用于表示实体之间的关系。Edsterore仅支持对关联属性进行索引。</p><p> Based on this design, we have two kinds of ATF-related objects in Edgestore. The ATF association stores scheduling information, such as the next scheduled timestamp at which the Store Consumer should poll a given task (either for the first time or for a retry). The ATF entity stores all task related information that is used to track the task state and payload for task execution. We query on associations from the Store Consumer in a pull model to pick up tasks ready for execution.</p><p>基于这个设计，我们在Edsterore中有两种与ATF相关的对象。ATF关联存储调度信息，例如商店消费者应轮询给定任务的下一个调度时间戳(第一次轮询或重试轮询)。ATF实体存储用于跟踪任务执行的任务状态和有效载荷的所有任务相关信息。我们在Pull模型中查询来自Store Consumer的关联，以挑选准备执行的任务。</p><p>  When it is time to process the task,  Store Consumer pulls the task from  Edgestore and pushes it to a related  SQS queue.</p><p>到了处理任务的时候，Store Consumer从Edsterore拉出任务并将其推送到相关的SQS队列。</p><p> Executor makes  NextWork RPC call to  Controller, which pulls tasks from the  SQS queue, makes a  ClaimTask RPC to the HSC and then returns the task to the  Executor.</p><p>Executor向控制器发出NExtWORK RPC调用，后者从SQS队列中提取任务，向HSC发出ClaimTask RPC，然后将任务返回给Executor。</p><p> Executor invokes the callback for the task. While processing,  Executor performs  Heartbeat RPC calls to  Heartbeat and Status Controller (HSC). Once processing is done,  Executor performs  TaskStatus RPC call to  HSC.</p><p>Executor调用任务的回调。在处理过程中，Executor对心跳和状态控制器(HSC)执行心跳RPC调用。处理完成后，Executor执行对HSC的TaskStatus RPC调用。</p><p> Every state update in the lifecycle of a task is accompanied by an update to the next trigger timestamp in the  assoc. This ensures that the Store Consumer pulls the task again if there is no change in state of the task within the next trigger timestamp. This helps ATF achieve its at-least-once delivery guarantee by ensuring that no task is dropped.</p><p>任务生命周期中的每个状态更新都伴随着对ASSOC中下一个触发器时间戳的更新。这确保了如果任务的状态在下一个触发时间戳内没有变化，Store Consumer将再次拉回该任务。这有助于ATF通过确保不丢弃任何任务来实现其至少一次交付保证。</p><p> Following are the task entity and association states in ATF and their corresponding timestamp updates:</p><p>以下是ATF中的任务实体和关联状态及其相应的时间戳更新：</p><p> Re-enqueue task if it has been in  enqueued state for too long. This can happen if the queue loses data or the controller goes down after polling the queue and before the task is claimed.</p><p>如果任务处于入队状态太久，请重新入队。如果队列丢失数据或控制器在轮询队列之后、任务被认领之前关闭，则可能发生这种情况。</p><p> Re-enqueue if task is claimed but never transfered to  processing. This can happen if Controller is down after claiming a task. Task status is changed to  enqueued after re-enqueue.</p><p>如果任务被认领但从未转移到处理中，请重新排队。如果控制器在声明任务后关闭，则可能会发生这种情况。任务状态在重新入队后更改为已入队。</p><p> Re-enqueue if task hasn’t sent  heartbeat for too long. This can happen if Executor is down. Task status is changed to  enqueued after re-enqueue.</p><p>如果任务太长时间没有发送心跳信号，请重新排队。如果Executor关闭，可能会发生这种情况。任务状态在重新入队后更改为已入队。</p><p>   At-least-once task execution  At-least-once execution is guaranteed in ATF by retrying a task until it completes execution (which is signaled by a  Success or a  FatalFailure state). All ATF system errors are implicitly considered retriable failures, and lambda owners have an option of marking tasks with a  RetriableFailure state. Tasks might be dropped from the ATF execution pipeline in different parts of the system through transient RPC failures and failures on dependencies like Edgestore or SQS. These transient failures at different parts of the system do not affect the at-least-once guarantee, though, because of the system of timeouts and re-polling from Store Consumer.</p><p>在ATF中，通过重试任务直到其完成执行(由Success或FatalFailure状态表示)，可以保证任务至少执行一次。所有ATF系统错误都被隐含地认为是可恢复的故障，并且lambda所有者可以选择将任务标记为RetriableFailure状态。任务可能会从系统不同部分的ATF执行流水线中通过暂时性的RPC故障和依赖项(如Edsterore或SQS)中的故障丢弃。不过，由于Store Consumer的超时和重新轮询系统，系统不同部分的这些暂时性故障不会影响至少一次的保证。</p><p> No concurrent task execution  Concurrent task execution is avoided through a combination of two methods in ATF. First, tasks are explicitly claimed through an exclusive task state ( Claimed) before starting execution. Once the task execution is complete, the task status is updated to one of  Success,  FatalFailure or  RetriableFailure. A task can be claimed only if its existing task state is  Enqueued (retried tasks go to the  Enqueued state as well once they are re-pushed onto SQS).</p><p>没有并发任务执行通过ATF中两种方法的组合来避免并发任务执行。首先，在开始执行之前，通过独占任务状态(声明)显式声明任务。任务执行完成后，任务状态将更新为Success、FatalFailure或RetriableFailure之一。只有当任务的现有任务状态为已排队时，才能声明该任务(重试任务在被重新推送到SQS后也将进入已排队状态)。</p><p> However, there might be situations where once a long running task starts execution, its heartbeats might fail repeatedly yet the task execution continues. ATF would retry this task by polling it from the store consumer because the heartbeat timeouts would’ve expired. This task can then be claimed by another worker and lead to concurrent execution.</p><p>但是，可能会出现这样的情况：一旦长时间运行的任务开始执行，其检测信号可能会反复失败，但任务仍在继续执行。ATF将通过从商店消费者轮询来重试该任务，因为心跳超时已经到期。然后，该任务可以由另一个Worker认领并导致并发执行。</p><p> To avoid this situation, there is a termination logic in the Executor processes whereby an Executor process terminates itself as soon as three consecutive heartbeat calls fail. Each heartbeat timeout is large enough to eclipse three consecutive heartbeat failures. This ensures that the Store Consumer cannot pull such tasks before the termination logic ends them—the second method that helps achieve this guarantee.</p><p>为了避免这种情况，在Executor进程中有一个终止逻辑，一旦连续三次心跳调用失败，Executor进程就会自行终止。每个心跳超时都足够大，足以使连续三次心跳故障黯然失色。这确保了Store Consumer无法在终止逻辑结束任务之前拉出这些任务--这是帮助实现这一保证的第二种方法。</p><p> Isolation  Isolation of lambdas is achieved through dedicated worker clusters, dedicated queues, and dedicated per-lambda scheduling quotas. In addition, isolation across different priorities within the same lambda is likewise achieved through dedicated queues and scheduling bandwidth.</p><p>通过专用的工作者集群、专用的队列和专用的每波长调度配额实现了对波长的隔离。此外，同样通过专用队列和调度带宽实现同一波长内不同优先级的隔离。</p><p> Delivery latency  ATF use cases do not require ultra-low task delivery latencies. Task delivery latencies on the order of a couple of seconds are acceptable. Tasks ready for execution are periodically polled by the Store Consumer and this period of polling largely controls the task delivery latency. Using this as a tuning lever, ATF can achieve different delivery latencies as required. Increasing poll frequency reduces task delivery latency and vice versa. Currently, we have calibrated ATF to poll for ready tasks once every two seconds.</p><p>交付延迟ATF使用案例不需要超低的任务交付延迟。任务交付延迟在几秒左右是可以接受的。准备好执行的任务由Store Consumer定期轮询，这段轮询在很大程度上控制了任务交付延迟。ATF将此作为调谐杠杆，可以根据需要实现不同的交付延迟。提高轮询频率可以减少任务交付延迟，反之亦然。目前，我们已将ATF校准为每两秒轮询一次就绪任务。</p><p>  ATF is designed to be a self-serve framework for developers at Dropbox. The design is very intentional in driving an ownership model where lambda owners own all aspects of their lambdas’ operations. To promote this, all lambda worker clusters are owned by the lambda owners. They have full control over operations on these clusters, including code deployments and capacity management. Each executor process is bound to one lambda. Owners have the option of deploying multiple lambdas on their worker clusters simply by spawning new executor processes on their hosts.</p><p>ATF是为Dropbox的开发者设计的自助式框架。这种设计非常有意于推动一种所有权模式，在这种模式下，lambda所有者拥有其lambdas运营的所有方面。为了促进这一点，所有的lambda工人集群都归lambda所有者所有。他们可以完全控制这些群集上的操作，包括代码部署和容量管理。每个执行器进程都绑定到一个lambda。所有者可以选择在其工作集群上部署多个lambda，只需在其主机上生成新的执行器进程即可。</p><p>  As described above, ATF provides an infrastructural building block for scheduling asynchronous tasks. With this foundation established, ATF can be extended to support more generic use cases and provide more features as a framework. Following are some examples of what could be built as an extension to ATF.</p><p>如上所述，ATF提供了用于调度异步任务的基础结构构建块。在此基础上，ATF可以进行扩展以支持更通用的用例，并提供更多作为框架的功能。以下是可以作为ATF扩展的一些示例。</p><p> Periodic task execution  Currently, ATF is a system for one-time task scheduling. Building support for periodic task execution as an extension to this framework would be useful in unlocking new capabilities for our clients.</p><p>周期性任务执行目前，ATF是一种一次性任务调度系统。构建对定期任务执行的支持，将其作为此框架的扩展，将有助于为我们的客户释放新功能。</p><p> Better support for task chaining  Currently, it is possible to chain tasks on ATF by scheduling a task onto ATF that then schedules other tasks onto ATF during its execution. Although it is possible to do this in the current ATF setup, visibility and control on this chaining is absent at the framework level. Another natural extension here would be to better support task chaining through framework-level visibility and control, to make this use case a first class concept in the ATF model.</p><p>更好地支持任务链目前，通过将一个任务调度到ATF上，然后在其执行期间将其他任务调度到ATF上，可以在ATF上链接任务。尽管在当前的ATF设置中可以做到这一点，但在框架级别上缺乏对此链接的可见性和控制。这里的另一个自然扩展是通过框架级别的可见性和控制更好地支持任务链，使此用例成为ATF模型中的第一类概念。</p><p> Dead letter queues for misbehaving tasks  One common source of maintenance overhead we observe on ATF is that some tasks get stuck in infinite retry loops due to occasional bugs in lambda logic. This requires manual intervention from the ATF framework owners in some cases where there are a large number of tasks stuck in such loops, occupying a lot of the scheduling bandwidth in the system. Typical manual actions in response to such a situation include pausing execution of the lambdas with misbehaving tasks, or dropping them outright.</p><p>行为不端任务的死信队列我们在ATF上观察到的维护开销的一个常见来源是，由于lambda逻辑中偶尔出现的错误，一些任务会陷入无限重试循环。这需要ATF框架所有者的手动干预，在某些情况下，有大量任务滞留在这样的循环中，占用了系统中的大量调度带宽。响应这种情况的典型手动操作包括暂停执行行为不佳的lambdas，或者直接丢弃它们。</p><p> One way to reduce this operational overhead and provide an easy interface for lambda owners to recover from such incidents would be to create dead letter queues filled with such misbehaving tasks. The ATF framework could impose a maximum number of retries before tasks are pushed onto the dead letter queue. We could create and expose tools that make it easy to reschedule tasks from the dead letter queue back into the ATF system, once the associated lambda bugs are fixed.</p><p>减少这种操作开销并为lambda所有者提供从此类事件中恢复的简单界面的一种方法是创建充满此类不良行为任务的死信队列。在任务被推入死信队列之前，ATF框架可以施加最大重试次数。一旦修复了相关的lambda错误，我们可以创建和公开工具，使将任务从死信队列重新调度回ATF系统变得容易。</p><p>  We hope this post helps engineers elsewhere to develop better async task frameworks of their own. Many thanks to everyone who worked on this project: Anirudh Jayakumar, Deepak Gupta, Dmitry Kopytkov, Koundinya Muppalla, Peng Kang, Rajiv Desai, Ryan Armstrong, Steve Rodrigues, Thomissa Comellas, Xiaonan Zhang and Yuhuan Du.</p><p>我们希望这篇文章能帮助其他地方的工程师开发他们自己的更好的异步任务框架。非常感谢参与这个项目的每个人：Anirudh Jayakumar、Deepak Gupta、Dmitry Kopytkov、Koundinya Muppalla、彭康、Rajiv Desai、Ryan Armstrong、Steve Rodrigues、Thomissa Comellas、张晓楠和杜玉环。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://dropbox.tech/infrastructure/asynchronous-task-scheduling-at-dropbox">https://dropbox.tech/infrastructure/asynchronous-task-scheduling-at-dropbox</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/dropbox/">#dropbox</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/task/">#task</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>