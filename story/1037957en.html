<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一种特殊的地狱：C和C ++中的intmax_t A Special Kind of Hell: intmax_t in C and C++</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Special Kind of Hell: intmax_t in C and C++<br/>一种特殊的地狱：C和C ++中的intmax_t </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-06 03:54:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/b28292cfd6e08266eb3ade4fe4286595.jpg"><img src="http://img2.diglog.com/img/2020/12/b28292cfd6e08266eb3ade4fe4286595.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>C and C++ as languages have a few things separating them from each other, mostly in their minute details and, occasionally, larger feature sets like designated initializers. But there is a disturbingly high amount of C++ that can simply do C’s job far better than C, including when it comes to solving some of the biggest problems facing the evolution of C and C++.</p><p>C和C ++作为语言有一些东西使它们彼此分开，主要是在它们的详细信息上，偶尔还有较大的功能集，例如指定的初始化程序。但是，令人烦恼的是，大量的C ++可以简单地完成C的工作，远胜于C，包括解决C和C ++的发展面临的一些最大问题时。</p><p> Let’s take a contemporary problem plaguing both C and C++, affecting everyone from standard library maintainers to project developers, that has been going on for the last 20 or so years:  intmax_t.</p><p> 让我们来解决一个同时困扰C和C ++的当代问题，它影响了从标准库维护人员到项目开发人员的所有人，过去20年来一直如此：intmax_t。</p><p>  The concept behind  intmax_t is simple enough: it is the largest integer type that your implementation and its standard library support in conjunction. Here is a few things  intmax_t controls inside the implementation:</p><p>  intmax_t背后的概念很简单：它是您的实现及其标准库共同支持的最大整数类型。这是实现内的intmax_t控件的一些内容：</p><p> it is the maximum number of bits that can be printed portably, e.g. with  printf(&#34;%j&#34;, (intmax_t)value) (C and C++);</p><p> 它是可移植打印的最大位数，例如用printf（＆＃34;％j＆＃34 ;,（intmax_t）value）（C和C ++）;</p><p>  intmax_t is the largest type for which  std::numeric_limits applies, including most types up to and including that type (C++ only);</p><p>  intmax_t是std :: numeric_limits适用的最大类型，包括直到该类型并包括该类型的大多数类型（仅C ++）；</p><p>  intmax_t underpins  std::chrono’s casts and similar (e.g. no information is lost during conversions out of and into the system) (C++ only);</p><p>  intmax_t支持std :: chrono的强制转换和类似操作（例如，在系统内外转换期间不会丢失任何信息）（仅适用于C ++）；</p><p>  and, there are a set of integer operations provided by the standard library (like absolute value and quotient / remainder operations) that can be done with the maximum bit precision available to the implementation (C and C++).</p><p>  并且，标准库提供了一组整数运算（如绝对值和商/余数运算），可以用实现中可用的最大位精度来完成（C和C ++）。 </p><p> These properties forge the basis of  intmax_t’s purpose. Lossless storage, pass-through operations, and more can all be achieved by relying on this implicit contract of the type. Since it is a type definition, the “real” integer type underneath it can be swapped out and people relying on it can be upgraded seamlessly!</p><p>这些属性构成了intmax_t目的的基础。依靠这种类型的隐式契约，可以实现无损存储，传递操作等。由于它是类型定义，因此它下面的“实数”整数类型可以换出，依赖它的人们可以无缝升级！</p><p>   C has a much higher commitment to not breaking old code and keeping “developers close to the machine”. What this actually translates to for most Application Binary Interfaces is very simplistic “name mangling” schemes (i.e., none),  weak linkers, and other shenanigans. The end result is that we expose C developers to platform details that become invisible dependencies for their code that must be preserved at all costs. For example, let’s take a C Standard function that uses  intmax_t,  imaxabs:</p><p>   C对不破坏旧代码并保持“开发人员靠近机器”的承诺更高。对于大多数应用程序二进制接口，这实际上是非常简单的“名称修改”方案（即，没有），弱链接程序和其他恶作剧。最终结果是，我们使C开发人员暴露于平台细节，这些细节成为其代码的不可见依赖项，必须不惜一切代价保留它们。例如，让我们来看一个使用intmax_t，imaxabs的C标准函数：</p><p>  and, let’s try to figure out how we can upgrade someone off of this usage without breaking their code too badly. We will try fixing this in both C and C++.</p><p>  并且，让我们尝试找出如何在不严重破坏其代码的情况下将某人升级为这种用法。我们将尝试在C和C ++中修复此问题。</p><p>  Taking  intmax_t, let’s do a no-brainer usage case: calling a function with  intmax_t input and return types. The syntax and usage ends up looking like this:</p><p>  以intmax_t为例，我们不费吹灰之力地进行使用：调用具有intmax_t输入和返回类型的函数。语法和用法最终看起来像这样：</p><p> #include &lt;inttypes.h&gt; int  main  ()  {	 intmax_t  original  =  ( intmax_t ) - 2 ;	 intmax_t  val  =  imaxabs ( val );	 return  ( int ) val ; }</p><p> #include＆lt; inttypes.h＆gt; int main（）{intmax_t original =（intmax_t）-2; intmax_t val = imaxabs（val）; return（int）val; }</p><p> Easy enough! But, there’s also a hidden dependency here, based on how the code is compiled. While many people compile their C standard library as a static library and only generate final binary code for what they use as to have a “self-contained” binary, the vast majority of the shared ecosystem depends on shared libraries/dynamically linked libraries for the standard. This means that when a program is milled through an operating system at program startup, the “loader” runs off to find the symbol  imaxabs inside some system library (e.g.,  /lib/x86_64-linux-gnu/libc-2.27.so for an “amd64” system). Harmless enough, right? Well, it turns out to be a bit of a problem in practice, because the name  imaxabs is all that’s used in C to figure out what subroutine to talk with in some shared library,</p><p> 很简单！但是，根据代码的编译方式，这里也存在隐藏的依赖关系。虽然许多人将其C标准库编译为静态库，并且仅生成最终二进制代码以用作拥有“自包含”二进制文件的代码，但绝大多数共享生态系统都依赖于共享库/动态链接库来实现。标准。这意味着，在程序启动时通过操作系统铣削程序时，“加载程序”将运行以在某些系统库中找到符号imaxabs（例如，/lib/x86_64-linux-gnu/libc-2.27.so “ amd64”系统）。足够无害了吧？嗯，实际上这是一个问题，因为imaxabs就是C语言中用来弄清楚在某些共享库中要使用的子例程的名称，</p><p>   The glibc maintainers decide they’re going to change from  long long as their  intmax_t and move to  __int256_t for most platforms, because most platforms support it and they have a lot of customers asking for it.</p><p>   glibc维护者决定，只要大多数平台支持intmax_t，它们就将从长期更改为__int256_t，因为大多数平台都支持它，并且有很多客户要求它。 </p><p>  They upgrade the  libc to its next version for various Linux distribution, and everyone links against it when they look for the default  libc.</p><p>他们将libc升级到适用于各种Linux发行版的下一个版本，并且每个人都在寻找默认的libc时链接到它。</p><p>  You have an application. Your code was not changed or updated, so it was not recompiled. It calls  imaxabs. The argument it passes is a  long long, because that was the type at the time you last compiled and shipped your software.</p><p>  您有一个应用程序。您的代码未更改或更新，因此未重新编译。它称为imaxabs。它传递的参数很长，因为这是您上次编译和交付软件时的类型。</p><p>  The  imaxabs used to lookup the function to call finds the version that takes a  __int256_t in the new  libc.</p><p>  用于查找要调用的函数的imaxabs在新libc中查找采用__int256_t的版本。</p><p>  Different registers are used to pass and return the function value than expected by the  imaxabs function call in the  libc binary, because your application is in  long long mode but glibc expects a  __int256_t.</p><p>  libc二进制文件中使用了不同的寄存器来传递和返回imaxabs函数调用所期望的函数值，这是因为您的应用程序处于long long模式，但是glibc期望使用__int256_t。</p><p> This is one of the manifestations of what is called an “Application Binary Interface (ABI) Break”. ABI Breaks are generally undetectable, silent breaks that occur within the runtime of a program that completely destroy any dependency your program has on that functionality for correctness. It typically happens when a subtle detail – the registers used to negotiate a large integral value between a shared library and its application, the amount of padding a structure might have on a certain build, the ordering and layout of class members, the interpretation of bits even if the layout or passing convention of a type never changes, and even more – changes.</p><p> 这是所谓的“应用程序二进制接口（ABI）中断”的体现之一。通常，ABI中断是在程序运行时发生的不可检测的无提示中断，它会完全破坏您的程序对该功能的依赖性，以确保准确性。它通常在以下情况发生：细微的细节-用于在共享库及其应用程序之间协商较大整数值的寄存器，结构在特定版本上可能具有的填充量，类成员的排序和布局，位的解释即使类型的布局或传递约定从不改变，甚至更大。</p><p>  Not necessarily. C is a simple language, and it both sells itself on and prides itself as such. So much so, that it’s even part of the  language’s rolling charter. There’s barely any name mangling because there’s no overloading. If you want “virtual functions” you need to hand-craft your virtual table structure and initialize it yourself. There’s barely any lookup or entity negotiation: what you write –  however scary or cursed – is what you get, in a general sense. (No, it’s not “portable assembly”. Compilers tear C code apart and make it far more efficient than the code people stuff into it. It’s not even a direct model of the machine anymore: just an abstract one.)</p><p>  不必要。 C是一种简单的语言，它既可以推销自己，也可以以此为荣。如此之多，以至于它甚至是该语言滚动宪章的一部分。几乎没有名称混乱，因为没有重载。如果您需要“虚拟功能”，则需要手工制作虚拟表结构并自己进行初始化。几乎没有任何查找或实体协商：您所写的内容（无论多么令人恐惧或被诅咒）是您所获得的一般意义上的东西。 （不，这不是“便携式程序集”。编译器将C代码拆开，使其比人们所填充的代码效率更高。它甚至不再是计算机的直接模型：仅仅是一个抽象模型。）</p><p> Still, sometimes even C can’t get away from it. The function  imaxabs relates to exactly one entity that, for historical reasons, was pinned to a function taking and returning a  long long. Upgrading it means dealing with this schism between what the user expects ( intmax_t that got upgraded and can print  __int128_t/ __int256_t) with old, non-recompiled code that maintains the old invariant ( long long, a 64-bit number).</p><p> 尽管如此，有时甚至C也无法摆脱它。函数imaxabs恰好与一个实体有关，由于历史原因，该实体被固定到采用并返回long long的函数上。升级意味着要处理用户期望的值（升级后的intmax_t并可以打印__int128_t / __int256_t）与保持旧不变式（长long，64位数字）的旧的未重新编译的代码之间的这种分裂。 </p><p>  Okay, so symbols can be repurposed between library versions that lead to ABI breaks. What are the ways to defend against such a world, in C?</p><p>好的，因此可以在导致ABI中断的库版本之间重新使用符号。用C语言捍卫这样一个世界的方式是什么？</p><p>    … as a way to provide the  imaxabs function. It is a bit like artisanal, hand-crafted, free-range, and organic ABI versioning (or, as I have affectionately come to call it: personal masochism to make up for language failures). This mostly works, until… it doesn’t!</p><p>    …作为提供imaxabs功能的一种方式。它有点像手工的，手工制作的，自由范围的和自然的ABI版本控制（或者，正如我亲切地称呼它：个人受虐狂以弥补语言失败）。这通常可以工作，直到……不行！</p><p>  This is the “ABI Breaks Guaranteed” section in the C Standard. It’s real name is “§7.1.4 Use of library functions”. Reproduced below is the relevant piece that condemns us, emphasis mine:</p><p>  这是C标准中的“保证ABI中断”部分。它的真名是“第7.1.4节库函数的使用”。下面转载的是谴责我们的相关文章，重点是我的：</p><p> Any function declared in a header may be additionally implemented as a function-like macro defined in the header, so if a library function is declared explicitly when its header is included, one of the techniques shown below can be used to ensure the declaration is not affected by such a macro.  Any macro definition of a function can be suppressed locally by enclosing the name of the function in parentheses, because the name is then not followed by the left parenthesis that indicates expansion of a macro function name. For the same syntactic reason, it is permitted to take the address of a library function even if it is also defined as a macro.  The use of  #undef to remove any macro definition will also ensure that an actual function is referred to.</p><p> 标头中声明的任何函数都可以另外实现为标头中定义的类函数宏，因此，如果在包含标头时显式声明了库函数，则可以使用以下所示的一种技术来确保不声明该函数受这样的宏影响。通过在函数名称中用括号括起来，可以在本地抑制函数的任何宏定义，因为该名称之后不带有表示宏函数名称扩展的左括号。出于相同的语法原因，即使将库函数也定义为宏，也可以采用该函数的地址。使用#undef删除任何宏定义也将确保引用实际函数。</p><p> Not only can a user suppress a function-like macro invocation by using the same trick used on  &lt;windows.h&gt; like  (max)(value0, value1), but the C Standard Library permits them to also undefine function names:</p><p> 用户不仅可以通过使用＆lt; windows.h＆gt;上的相同技巧来抑制类函数的宏调用。类似于（max）（value0，value1），但C标准库允许它们也取消定义函数名称：</p><p>  // user code: main.c #include &lt;inttypes.h&gt; #undef imaxabs // awh geez int  main  ()  {	 intmax_t  val  =  - 1 ;	 intmax_t  absval  =  imaxabs ( val );  // awH GEEZ	 return  ( int ) absval ; }</p><p>  //用户代码：main.c #include＆lt; inttypes.h＆gt; #undef imaxabs // awh geez int main（）{intmax_t val =-1; intmax_t absval = imaxabs（val）; // awH GEEZ return（int）absval; }</p><p>   Alright, the C Standard basically loads a double barrel and brings our only standardized mitigation strategy out back behind the barn. What’s left? Well, implementation-specific insanity, that’s what:</p><p>   好吧，C标准基本上可以装载双枪管，并将我们唯一的标准化缓解策略带回到谷仓后面。还剩什么？好吧，针对实施的精神错乱，那就是： </p><p>  This is pseudo-code. But, wouldn’t you believe it, some implementations actually do things very similar to this to get around these problems! The things they do are far more involved, like actually dropping down to the level of the linker and creating symbol maps and other exceedingly painful workarounds. The sed scripts and the awk scripts and the bash starts coming out, people are doing lots of text processing to get symbol names and match them to versioned symbol names…</p><p>这是伪代码。但是，您不相信吗，某些实现实际上可以执行与此类似的操作来解决这些问题！他们所做的事情涉及更多，例如实际下降到链接器级别并创建符号映射和其他非常痛苦的解决方法。 sed脚本，awk脚本和bash开始问世，人们正在做大量文本处理以获取符号名称并将其与版本化的符号名称匹配...</p><p>  Still, given the mess, it does save us from the problem. In C code you get to use “the real name”  imaxabs as Our Lord and Savior intended, the binary gets linked to  ___glibc228_imaxabs, and everyone’s happy. There’s only one problem with this kind of fix…</p><p>  尽管如此，考虑到混乱，它确实使我们摆脱了问题。在C代码中，您可以按我们的主人和救主的意图使用“真实名称” imaxabs，将二进制文件链接到___glibc228_imaxabs，每个人都很高兴。这种修复方法只有一个问题……</p><p>  QoI is great for the pure, theoretical standard. We get to write sexy narratives in the C standard and call them “Recommended Practice”, with little footnotes furtively implying a more wonderful world while waggling our eyebrows seductively at hot, young developers in our area. Just come along, it’s going to be so great, we’re going have soooooo much fun, just go with that lovely little implementation right over there, you’re making such fine progress, enjoy yourself and come back soon my purrecious Software Engineer!~</p><p>  QoI非常适合纯粹的理论标准。我们开始用C标准编写性感的叙述，并将其称为“推荐做法”，用小脚注暗示着更美好的世界，同时诱人地为我们所在地区的年轻新手吸引着眉毛。快来吧，它会很棒，我们将获得很多乐趣，只需在那儿执行那个可爱的小实现，您就可以取得如此出色的进步，尽情享受并很快回来，我那纯洁的软件工程师！ 〜</p><p> Then you wake up in an alleyway with your bit wallet pillaged and your preconditions violated. Your head is swimming from unspecified behavior, and it turns out that the implementation:</p><p> 然后，您会在小巷中醒来，抢走您的零钱包，并且违反了前提条件。您的头脑从未指明的行为中冒出来，事实证明该实现：</p><p> learned 0 lessons from  size_t requiring the entire industry over to have different binaries for 64-bit just to change its definition;</p><p> 从size_t中学到了0课，要求整个行业为64位设置不同的二进制文件，以更改其定义；</p><p> Hurt, confused, you come to us, the Standards Committee. You tell us that you’re bamboozled and bruised, that this wonderful implementation named  TenDRA said you could do these amazing things, that you’d get to see standards-conforming explosions and fireworks, that it would be rad…</p><p> 伤害，困惑，您来找我们标准委员会。您告诉我们，您感到困惑不解，这个名为TenDRA的出色实现说您可以做这些令人惊奇的事情，可以看到符合标准的爆炸和烟火，而且值得推荐……</p><p>  We explain that, see, it’s not illegal, what TenDRA did. No, you don’t get automatic access to their exclusive footnotes. We have to serve the implementations that don’t actually want to do the recommended practice, why didn’t you check your implementation’s documentation, how come you didn’t contact the maintainers? Really there’s nothing we can do for you here, you had the freedom to pick, why didn’t you pick a better implementation? If your ideas were really so popular, how come they haven’t been implemented the way you expected, huh? Why are you not pushing TenDRA to the left—</p><p>  我们向您解释，TenDRA所做的并非违法。不，您不会自动访问他们的专有脚注。我们必须为实际上并不想执行推荐做法的实施提供服务，为什么您不查看实施的文档，为什么不联系维护者呢？真的，这里我们无能为力，您可以自由选择，为什么不选择更好的实施方案呢？如果您的想法真的很流行，为什么没有按照您的期望来实现它们，是吧？为什么不将TenDRA推向左侧- </p><p> As a governing body WG14 will take a recommended implementation seriously. We will also take the DeathStation 9000 seriously. It’s conforming, after all. This isn’t the implementation’s fault:</p><p>作为管理机构，WG14将认真对待建议的实施方案。我们还将认真对待DeathStation 9000。毕竟，这是合规的。这不是实现的错：</p><p>   In our desperate bid to hammer out rules for ourselves and make sure all code ever written in C forever continues to compile forever, we tied our hands as a Standards Committee. We get frustrated with ABI problems with  intmax_t and in  printf, but the honest to god truth is that we asked for this.</p><p>   为了拼命地为自己制定规则并确保永远用C语言编写的所有代码永远继续编译，我们竭尽全力，成为标准委员会。对于intmax_t和printf中的ABI问题，我们感到沮丧，但老实说，就是我们要求这样做。</p><p>  The  bug reports roll in to C and C++ implementations, the  quirky patches get started.  Why is  __int128_t a pariah, where’s the up-and-coming  __int256_t support, why can’t we use  __int512_t with  numeric_limits, why is  _ExtInt(1024) not a “real extended integer type”, et cetera et cetera. We would like to blame ABI but the fault is our own at this point: we crafted a world where Names Are Forever, Abstractions Are Evil, Macros Are Bad, and now the rules we made to chain the complexity of the world of C are now staring us back in the face with one hell of a wicked grin. We valued simplicity to the point of self-parody and – to some extent – self-destruction.</p><p>  该错误报告将发布到C和C ++实现中，这些古怪的补丁程序开始了。为什么__int128_t是pariah，即将出现的__int256_t支持在哪里，为什么我们不能将__int512_t与numeric_limits一起使用，为什么_ExtInt（1024）不是“真正的扩展整数类型”，等等？我们想归咎于ABI，但这是我们自己的错：我们设计了一个世界，其中名字永远存在，抽象是邪恶的，宏是坏的，现在我们为链接C世界的复杂性而制定的规则现在邪恶的笑容使我们凝视在脸上。我们重视简单性，以至于自我模仿，并在某种程度上自我毁灭。</p><p>  For C? None. I am not even kidding: no less than  5 papers discussed over  3-4 Standards meetings have been  burned on this topic. There’s no combination of ISO Standard C features that can fix this problem without breaking somebody. Not even the upcoming idea for  lambdas and auto (see §6.5.2.6 Lambda expressions) in C can fix this problem:</p><p>  对于C？没有。我什至没有开玩笑：在这个主题上，不少于5篇论文在3-4个标准会议上讨论过。没有ISO标准C功能的组合可以解决此问题而又不会破坏别人。甚至C语言中即将出现的关于lambdas和auto的想法（请参见§6.5.2.6Lambda表达式）也无法解决此问题：</p><p>   int  main  ()  {	 typedef  ( intmax_t )( f_t )( intmax_t );	 f_t *  f_ptr0  =  imaxabs ;  // fine, function pointer decay	 f_t *  f_ptr1  =  &amp; imaxabs ;  // oops	 return  0 ; }</p><p>   int main（）{typedef（intmax_t）（f_t）（intmax_t）; f_t * f_ptr0 = imaxabs; //好，函数指针衰减f_t * f_ptr1 =＆amp; imaxabs; // oops返回0; }</p><p> By how lambdas are defined, that returns an object pointer, not a function pointer. This means old code using this syntax is broken. It also brings into question what, exactly,  would be the address of that function pointer? A feature would need to be crafted as “lambdas, but you can control what the ‘address of’ operator returns”. Of course, just writing that sentence has ten thousand C developers crying out: “No, C must be simple, operator overloading is the DEVIL’S MISTRESS!”.</p><p> 通过lambda的定义方式，它返回对象指针，而不是函数指针。这意味着使用此语法的旧代码已损坏。这也使人怀疑该函数指针的地址是什么？需要将一个功能设计为“ lambda”，但您可以控制“操作者的地址”返回的内容。当然，只要写上这句话，一万名C开发人员就会大喊：“不，C必须简单，操作员重载是DEVIL的缺点！”</p><p>   C++ can solve their ABI issue according to their own library rules, today. We just need to tap into a little bit of that spicy devilry:</p><p>   今天，C ++可以根据自己的库规则解决其ABI问题。我们只需要挖掘一点辛辣的味道： </p><p> namespace  std  {	 extern  &#34;C&#34;  __int128_t  __i128abs  ( __int128_t  v2 )  noexcept ;	 using  intmax_t  =  __int128_t ;	 struct  __imaxabs  {	 private:		 using  __imaxabs_ptr  =  intmax_t ( * )( intmax_t )  noexcept ;	 public:		 constexpr  __imaxabs_ptr  operator &amp;  ()  const  noexcept  {			 return  &amp; __i128abs ;		 }		 constexpr  operator  __imaxabs_ptr  ()  const  noexcept  {			 return  &amp; __i128abs ;		 }	 };	 inline  constexpr  const  __imaxabs  imaxabs  =  __imaxabs {}; }</p><p>命名空间std {extern＆＃34; C＆＃34; __int128_t __i128abs（__int128_t v2）noexcept;使用intmax_t = __int128_t; struct __imaxabs {private：using __imaxabs_ptr = intmax_t（*）（intmax_t）noexcept; public：constexpr __imaxabs_ptr运算符＆amp; （）const noexcept {return＆amp; __i128abs; } constexpr运算符__imaxabs_ptr（）const noexcept {return＆amp; __i128abs; };内联constexpr const __imaxabs imaxabs = __imaxabs {}; }</p><p> Unfortunately, we tied C++ itself to C compatibility. That means we will never take a step like this, because that means the C Library’s definition of  intmax_t on your system would differ from your C++ library. Ensue shenanigans, etc. etc. Note that it’s not impossible for C++ to do this even still, because of this wording:</p><p> 不幸的是，我们将C ++本身与C兼容性联系在一起。这意味着我们将永远不会采取这样的步骤，因为这意味着您系统上C库对intmax_t的定义将与C ++库不同。避免使用shenanigans等。请注意，由于以下措辞，C ++仍然可以做到这一点：</p><p> The C++ standard library also makes available the facilities of the C standard library, suitably adjusted to ensure static type safety.—  C++ Working Draft, §16.2 The C standard library ([library.c/1])</p><p> C ++标准库还提供了经过适当调整以确保静态类型安全的C标准库的设施。— C ++工作草案，§16.2C标准库（[library.c / 1]）</p><p> Much as we could use the above to weasel our way out of staying identical, implementations want so badly for  imaxabs(value) to have the exact same meaning as  std::imaxabs(value). So, yes, maybe it’s true that…</p><p> 就像我们可以使用上面的方法来避免保持一致一样，实现非常希望imaxabs（value）与std :: imaxabs（value）具有完全相同的含义。所以，是的，也许是……</p><p>   When it comes to covering the same feature set as C, we specifically will not push the envelope or go beyond our limitations. We will load our footgun proudly and blow the leg off of our fundamentals, then  force well-meaning developers into a implementation-defined hell fire. Compatibility is a feature and it is absolutely worth it, of course!</p><p>   当涉及到与C相同的功能集时，我们明确地不会超越极限或超出我们的限制。我们将自豪地装载脚枪，从根本上摆脱困境，然后迫使好心的开发人员陷入实施定义的地狱之火。兼容性是一项功能，绝对值得！</p><p>  The only way to fix this in reality is defining your own C library implementation that had aggressive symbol versioning support from the implementation and an investment in forward compatibility. And honestly, who’s wild enough to do that in this day and age?</p><p>  实际解决此问题的唯一方法是定义自己的C库实现，该实现从实现中获得了积极的符号版本支持，并投资了向前兼容性。老实说，在这个时代，谁能做到如此疯狂？ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://thephd.github.io/intmax_t-hell-c++-c">https://thephd.github.io/intmax_t-hell-c++-c</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地狱/">#地狱</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/kind/">#kind</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/imaxabs/">#imaxabs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>