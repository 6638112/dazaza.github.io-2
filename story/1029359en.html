<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>这么长时间以来，C++仍然活该吗？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">这么长时间以来，C++仍然活该吗？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-17 08:03:54</div><div class="page_narrow text-break page_content"><p>Traditionally C++ has been seen by many (and you know who you are) as just plain bad: the code is unreadably verbose, error messages are undecipherable, it&#39;s unsafe, compilation takes forever and so on. In fact making fun of C++ is even a fun pastime for some. All of this was certainly true in the 90s and even as recent as 10 years ago. But is it still the case? What would be a good way to determine this?</p><p>传统上，C++一直被许多人(你知道自己是谁)视为糟糕透顶：代码冗长得无法阅读，错误消息无法破译，它不安全，编译耗时很长，等等。事实上，对一些人来说，取笑C++甚至是一种有趣的消遣。所有这一切在90年代肯定是正确的，甚至在10年前也是如此。但情况还是这样吗？确定这一点的好方法是什么？</p><p>  Let&#39;s write a fairly simple program that solves a sort-of-real-worldish problem and see what comes out of it. The problem we want to solve is the following:</p><p>让我们写一个相当简单的程序来解决某种现实世界的问题，看看会有什么结果。我们要解决的问题是：</p><p> Find all files with the extension .txt recursively in the subdirectories of the current directory, count the number of times each word appears in them and print the ten most common words and the number of times they are used.</p><p>在当前目录的子目录中递归查找扩展名为.txt的所有文件，统计每个单词在其中出现的次数，并打印最常用的十个单词及其使用次数。</p><p> We&#39;re not going to go for extreme performance or handling all possible corner cases, instead going for a reasonable implementation. The full code can be found by following  this link.</p><p>我们不会追求极端的性能或处理所有可能的角落情况，而是追求合理的实现。点击此链接可以找到完整的代码。</p><p> The first thing we need is a way to detect files with a given extension and words within text. This calls for regular expressions:</p><p>我们首先需要一种方法来检测具有给定扩展名的文件和文本中的单词。这需要正则表达式：</p><p>   This might a bit verbose, but quite readable. This only works for ASCII text, but for the purposes of this experiment it is sufficient. To calculate the number of times each word is seen, we need a hash table:</p><p>这可能有点冗长，但可读性很好。这只适用于ASCII文本，但对于本实验而言，这就足够了。要计算每个单词出现的次数，我们需要一个哈希表：</p><p>                    This is a bit verbose, but it takes care of all the state tracking needed to run the regex multiple times on the same input string. Doing the same by hand is fairly tedious and error prone. Now that we have the matches, we need to convert them to standalone lowercase words.</p><p>这有点冗长，但它负责对同一输入字符串多次运行正则表达式所需的所有状态跟踪。手工执行相同的操作相当繁琐且容易出错。现在我们有了匹配项，我们需要将它们转换为独立的小写单词。</p><p>    Lowercasing strings is a bit cumbersome, granted, but this is at least fairly readable. Then on to incrementing the word count.</p><p>诚然，小写字符串有点麻烦，但这至少是相当可读的。然后继续递增字数。</p><p>    That&#39;s all that is needed to count the words. This can&#39;t be done directly in the hash map so we need to convert the data to an an array. It needs some setup code.</p><p>这就是计算单词所需的全部内容。这不能直接在散列映射中完成，所以我们需要将数据转换为一个AN数组。它需要一些设置代码。</p><p>    Since we know how many entries will be in the array, we can reserve enough space for it in advance. Then we need to iterate over all entries and add them to the array.</p><p>由于我们知道数组中将有多少条目，因此可以提前为其预留足够的空间。然后，我们需要迭代所有条目，并将它们添加到数组中。</p><p>  This uses the new structured bindings feature, which is a lot more readable than the old way of dealing with iterator objects or pairs with their  firsts and their  seconds and all that horror. Fortunately no more.</p><p>这使用了新的结构化绑定特性，这比处理迭代器对象或对的第一次和第二次以及所有这些恐怖的旧方式可读性强得多。幸运的是没有了。</p><p>  The simple way of getting the 10 most used entries is to sort the array and then grab the 10 first elements. Let&#39;s do something slightly swaggier instead [0]. We&#39;ll do a partial sort and discard all entries after 10. For that we need a descending sorting criterion as a lambda.</p><p>获取10个最常用条目的简单方法是对数组进行排序，然后获取前10个元素。让我们做些稍微夸张一点的事吧[0]。我们将进行部分排序，并丢弃10之后的所有条目。为此，我们需要一个降序排序标准作为lambda。</p><p>  auto count_order_desc = [](const WordCount &amp;w1, const WordCount &amp;w2) { return w2.count &lt; w1.count; };</p><p>Auto count_order_desc=[](const wordcount&amp；w1，const wordcount&amp；w2){return w2.count&lt；w1.count；}；</p><p>          As safety and security are important features in current sofware development, let&#39;s examine how safe this program is. There are two main safety points: thread safety and memory safety. As this program has only one thread, it can be formally proven to be thread safe. Memory safety also divides into two main things to note: use after frees (or dangling references) and out of bound array accesses.</p><p>由于安全和安保是当前软件开发中的重要功能，让我们来检查一下该程序的安全性。有两个主要的安全点：线程安全和内存安全。因为这个程序只有一个线程，所以可以正式证明它是线程安全的。内存安全还分为两个主要注意事项：在释放(或悬空引用)之后使用和越界数组访问。</p><p>  In this particular program there are no dangling references. All data is in value types and the only references are iterators. They are all scoped so that they never live past their usages. Most are not even stored into named variables but instead passed directly as function arguments (see especially the call to  partial_sort). Thus they can not be accessed after they have expired. There is no manual resource management of any kind. All resources are freed automatically. Running the code under Valgrind yields zero errors and zero memory leaks.</p><p>在这个特定的程序中，没有悬而未决的引用。所有数据都是值类型，唯一的引用是迭代器。它们都有作用域，所以它们的寿命永远不会超过它们的用法。大多数甚至没有存储到命名变量中，而是直接作为函数参数传递(特别请参阅对PARTIAL_SORT的调用)。因此，它们在过期后无法访问。没有任何类型的手动资源管理。所有资源都会自动释放。在Valgrind下运行代码会产生零错误和零内存泄漏。</p><p>  There is one place in the code where an out-of-bounds access is possible: when creating the iterator pointing to 10 elements past the beginning of the array [2]. If you were to forget to check that the array has at least 10 elements, that would be an immediate error. Fortunately most standard libraries have a way to enable checks for this. Here&#39;s what GCC reports at runtime if you get this wrong:</p><p>在代码中有一个地方可以进行越界访问：当创建指向数组开头之后的10个元素的迭代器时[2]。如果您忘记检查数组是否至少有10个元素，这将是一个直接的错误。幸运的是，大多数标准库都有一种方法来启用对此的检查。如果你弄错了，这里是GCC在运行时报告的内容：</p><p>  Error: attempt to advance a dereferenceable (start-of-sequence) iterator  100000 steps, which falls outside its valid range.</p><p>错误：试图将可取消引用(序列开始)迭代器前进100000步，这超出了其有效范围。</p><p>  Not really a perfect safety record, but overall it&#39;s fairly good and certainly a lot better than implementing the same by manually indexing arrays.</p><p>这并不是一个完美的安全记录，但总体来说，它相当不错，而且肯定比通过手动索引数组来实现同样的记录要好得多。</p><p>  Compiling the program takes several seconds, which is not great. This is mostly due to the regex header, which is known to be heavyweight. Some of the compiler messages encountered during development were needlessly verbose. The actual errors were quite silly, though, such as passing arguments to functions in the wrong order. This could definitely be better. It is reported that the use of concepts in C++20 will fix most of this issue, but there are no practical real-world usage reports yet.</p><p>编译程序需要几秒钟，这不是很好。这在很大程度上是由于regex标头，众所周知它是重量级的。在开发过程中遇到的一些编译器消息是不必要的冗长。不过，实际的错误相当愚蠢，比如以错误的顺序将参数传递给函数。这绝对可以更好。据报道，C++20中概念的使用将解决这个问题的大部分，但目前还没有实际的使用报告。</p><p>  This code compiles, runs and works [1] on all major platforms using only the default toolchain provided by the OS vendor without any external dependencies or downloads. This is something that no other programming language can provide as of date. The closest you can get is plain C, but its standard library does not have the necessary functionality. Compiling the code is also simple and can be done with a single command:</p><p>此代码仅使用操作系统供应商提供的默认工具链在所有主要平台上编译、运行和工作[1]，没有任何外部依赖或下载。这是到目前为止没有其他编程语言可以提供的功能。您能得到的最接近的是纯C语言，但是它的标准库没有必要的功能。编译代码也很简单，只需一条命令即可完成：</p><p>    If we try to look at the end result with objective eyes it would seem to be fairly nice. The entire implementation takes fewer than 60 lines of code. There&#39;s nothing immediately terrible that pops up. What is happening at each step is fairly understandable and readable. There&#39;s nothing that one could immediately hate and despise for being &#34;awful&#34;, as is tradition.</p><p>如果我们试着用客观的眼光来看待最终的结果，这似乎是相当好的。整个实现只需不到60行代码。没有什么可怕的东西会立即冒出来。每一步发生的事情都是相当容易理解和阅读的。按照传统，没有什么东西会让人立即因为自己的可怕而憎恨和鄙视。</p><p>  This is not to say you could still not hate C++. If you want to, go right ahead. There are certainly reasons for it. But if you choose to do that, make sure you hate it for real actual reasons of today, rather than things that were broken decades ago but have been fixed since.</p><p>这并不是说你仍然可以不讨厌C++。如果你愿意，那就去吧。这当然是有原因的。但如果你选择这样做，确保你讨厌它是出于今天真正的实际原因，而不是几十年前损坏但后来被修复的东西。</p><p>  [0] There is an even more efficient solution using a priority queue that does not need the intermediate array. Implementing it is left as an exercise to the reader.</p><p>[0]还有一种使用不需要中间数组的优先级队列的更有效的解决方案。将其实现留给读者作为练习。</p><p> [1] Reader beware, I have only proven this code to be portable, not tried it.</p><p>[1]读者请注意，我只是证明了这段代码是可移植的，还没有试过。</p><p> [2] The implementation in [0] does not have this problem as no iterators are ever modified by hand.</p><p>[2][0]中的实现没有这个问题，因为没有任何迭代器是手动修改的。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nibblestew.blogspot.com/2020/10/does-c-still-deserve-bad-rap-it-has-had.html">https://nibblestew.blogspot.com/2020/10/does-c-still-deserve-bad-rap-it-has-had.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/长时间/">#长时间</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deserve/">#deserve</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>