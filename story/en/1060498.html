<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用WebRTC，WebSocket和Go将视频聊天到我的个人网站 Building video chat into my personal website using WebRTC, WebSockets, and Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building video chat into my personal website using WebRTC, WebSockets, and Go<br/>使用WebRTC，WebSocket和Go将视频聊天到我的个人网站 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:22:56</div><div class="page_narrow text-break page_content"><p>2021-05-02  Recently I&#39;ve become more and more interested in how  WebRTC works, so a few weeks ago I decided to add a page to my website where I could set up peer-to-peer video chats. There are plenty of libraries and services out there to make this extremely easy, but knowing that WebRTC is now well supported natively across browsers and devices, I wanted try doing everything myself with minimal dependencies. It turned out to be a fun project to set up. It was also hard to find simple examples and explanations of this, so I hope to provide that here.</p><p>最近2021-05-02最近我越来越感兴趣的是WebRTC如何工作，所以几周前我决定将一个页面添加到我的网站上，我可以在那里设置点对点的视频聊天。在那里有大量的库和服务，使这极其简单，但知道WebRTC现在在浏览器和设备上本地充分支持，我想尝试使用最小的依赖性来做一切。它结果是一个有趣的项目来设置。也很难找到这个简单的例子和​​解释，所以我希望在这里提供。</p><p>    I was able to do everything I needed on the frontend with vanilla Javascript and HTML. The only HTML that is necessary are some  &lt;video&gt; elements to display local and remote video streams:</p><p>    我能够使用vanilla javascript和html来完成我所需要的一切。唯一需要的HTML是一些＆lt;视频＆gt;显示本地和远程视频流的元素：</p><p>    I needed to identify who the current user is and who they want to to talk to. I don&#39;t have users or cookies or anything like that on my website, so I&#39;m just using url query parameters and generating a unique link for each &#39;user&#39;. Below, peer1 will be able to visit the first link to talk to peer2 and vice versa:</p><p>    我需要确定当前用户是谁以及他们想和谁交谈。我没有在我的网站上有用户或cookie或cookie，所以我＆＃39; m只是使用URL查询参数，并为每个＆＃39生成唯一的链接;用户＆＃39;下面，PEER1将能够访问与PEER2交谈的第一个链接，反之亦然：</p><p>      A peer-to-peer connection is the goal here, but in order to do that, I need some way for the two users to communicate initially to let each other know where they are on the web and what kind of data they are sending to each other. I&#39;ll explain the backend implementation later, but this websocket will allow that initial communication to happen via my backend server:</p><p>      点对点连接是这里的目标，但为了做到这一点，我需要某种方式让两个用户最初沟通，以便彼此相互了解他们在网上以及他们发送的数据是什么样的数据彼此。我＆＃39; ll稍后解释后端实现，但此WebSocket将允许通过我的后端服务器发生初始通信：</p><p>    This initial communication consists of messages that are created and handled by a  RTCPeerConnection object:</p><p>    此初始通信由RTCPeerConnection对象创建和处理的消息组成：</p><p>    Take a look at  this if you want to get a better idea of what is actually going on with the connection that will be set up and the format of the messages being exchanged. There are three types of messages we care about: offers, answers, and ICE (Interactive Connectivity Establishment) candidates. Offer and answer messages mostly contain information about the media stream, and ICE candidate messages are about how to establish the actual peer connection across the web.</p><p>    看看这个，如果你想更好地了解将建立的连接实际发生的事情以及正在交换消息的格式。我们关心三种类型的信息：提供，答案和冰（互动连接建立）候选人。优惠和应答消息主要包含有关媒体流的信息，而Ice候选消息是关于如何在Web上建立实际对等连接的信息。</p><p>  navigator.mediaDevices.getUserMedia() will request access to the current user&#39;s camera and microphone, creating a media  stream which is displayed locally, then used with  peerConnection to create the &#39;offer&#39; message and send it to the peer with the  ws connection:</p><p>  Navigator.MediaDevices.getUsermedia（）将请求访问当前用户＆＃39; S相机和麦克风，创建一个在本地显示的媒体流，然后与PEERConnection一起使用以创建＆＃39;优惠＆＃39;消息并使用WS连接发送到对等体： </p><p>  navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(stream =&gt; { let element = document.getElementById(&#39;local_video&#39;); element.srcObject = stream; element.play().then(() =&gt; { stream.getTracks().forEach(track =&gt; peerConnection.addTrack(track, stream)); peerConnection.onnegotiationneeded = () =&gt; { peerConnection.createOffer().then(offer =&gt; { return peerConnection.setLocalDescription(offer); }).then(() =&gt; { ws.send(JSON.stringify(peerConnection.localDescription)); }); } });});</p><p>Navigator.MediaDevices.getUsermedia（{视频：True，Audio：True}）。然后（Stream =＆gt; {Let Element = Document.getElementById（＆＃39; local_video＆＃39; compents.srcobject = stream; compentr （）.then（（）=＆gt; {stream.gettracks（）。foreach（track =＆gt; peerconnection.addtrack（track，stream）; peerconnection.onnegotiationneeded =（）=＆gt; {peerconnection.createoffer（）。然后（报价=＆gt; {return peerconnection.setlocaldescription（优惠）;}）。然后（（）=＆gt; {ws.send（json.stringify（peerconnection.localdescription））;}）;}）;</p><p>  In the meantime, a bit more configuration on  peerConnection is necessary to set up how to display the stream received from the peer, and how send the ICE candidate messages to the peer through the websocket:</p><p>  与此同时，需要在Peerconnection上进行更多配置来设置如何显示从对等体接收的流，以及如何通过WebSocket向对等体发送冰候选消息：</p><p>  peerConnection.ontrack = evt =&gt; { let element = document.getElementById(&#39;remote_video&#39;); element.srcObject = evt.streams[0]; element.play();};peerConnection.onicecandidate = evt =&gt; { if (evt.candidate) { ws.send(JSON.stringify({type: &#39;candidate&#39;, ice: evt.candidate})); }}</p><p>  peerconnection.ontrack = evt =＆gt; {让元素= document.getElementByID（＆＃39; remote_video＆＃39;）;元素.srcobject = evt.streams [0];元素.play（）;}; peerconnection.onicCandidate = EVT =＆gt; {if（evt.candidate）{ws.send（json.stringify（{type：＆＃39;候选人＆＃39; ice：evt.Candidate}）; }}</p><p>  That takes care of sending the offers, answers and ICE candidates, now the websocket and peerConnection need to be able to receive them and take the appropriate actions:</p><p>  这需要提供提供优惠，答案和冰候选，现在WebSocket和Peerconnection需要能够接收并采取适当的操作：</p><p>  ws.onmessage = (evt) =&gt; { const message = JSON.parse(evt.data); switch (message.type) { case &#39;offer&#39;: { peerConnection.setRemoteDescription(message).then(() =&gt; { return peerConnection.createAnswer() }).then(answer =&gt; { return peerConnection.setLocalDescription(answer) }).then(() =&gt; { ws.send(JSON.stringify(peerConnection.localDescription)); }); break; } case &#39;answer&#39;: { peerConnection.setRemoteDescription(message); break; } case &#39;candidate&#39;: { peerConnection.addIceCandidate(new RTCIceCandidate(message.ice)); break; } }};</p><p>  ws.onmessage =（evt）=＆gt; {const message = json.parse（evt.data）;切换（message.type）{案例＆＃39;优惠＆＃39 ;: {peerconnection.setremotedescription（消息）.then（（）=＆gt; {return peerconnection.createanswer（）}）。然后（答案=＆gt; {返回peerconnection.setlocaldescription（答案）}）。然后（（）=＆gt; {ws.send（json.stringify（peerconnection.localdescription））;}）;休息; }案例＆＃39;答案＆＃39 ;: {peerconnection.setremotedescription（消息）;休息; }}案例＆＃39;候选人＆＃39 ;: {peerconnection.addiceCandidate（new rtciceCandidate（message.ice））;休息; }};</p><p>      On the backend, I needed some way to handle multiple active websocket connections and pass messages between them. My website is written in Go, and my first implementation held all the active websocket connections in memory in a  map. When a message came in from one peer, I could look up the other peer&#39;s websocket connection in the map and pass on the message.</p><p>      在后端，我需要某种方式来处理多个活动的WebSocket连接并在它们之间传递消息。我的网站是通过go写的，我的第一个实现在地图中持有内存中的所有活动的WebSocket连接。当消息从一个同行中出现时，我可以在地图中查找另一个同行和＃39;在地图中的WebSocket连接并传递给消息。</p><p>  This worked when running the app locally, but because my website is deployed on GCP Cloud Run with multiple running instances, I couldn&#39;t rely on both peers&#39; websockets being connected to the same instance and in the same memory. A simple shared  map was not viable, so I looked for something else.</p><p>  这在本地运行应用程序时工作，但由于我的网站部署在GCP云上运行多个运行实例，我可以＆＃39; t依赖于同行和＃39; WebSockets连接到相同的实例和同一内存。一个简单的共享地图不可行，所以我寻找别的东西。 </p><p>  For passing messages around on the backend, the first thing that came to mind on GCP was  Pub/Sub, and it turned out to be a nice solution. First, I set up a client:</p><p>对于在后端传递消息，GCP上铭记的第一件事是PUB / SUB，结果证明是一个很好的解决方案。首先，我设置了客户：</p><p>  import &#34;cloud.google.com/go/pubsub&#34;var pubSub *pubsub.Clientfunc Initialize() error { pubSub, err = pubsub.NewClient(context.Background(), &#34;mattbutterfield&#34;) if err != nil { return err } return nil}</p><p>  导入＆＃34; cloud.google.com/go/pubsub&#34; var pubsub * pubsub.clientfunc initialize（）错误{pubsub，err = pubsub.newclient（context.background（），＆＃34; mattbutterfield＆＃34; ）如果err！= nil {returner} return nil}</p><p>    Detects who the current user is and who they want to connect to based on the url query parameters.</p><p>    检测当前用户是谁以及他们想要基于URL查询参数连接的人。</p><p>  Finds or creates a shared Pub/Sub topic that both peers&#39; instances of this handler can publish and subscribe to.</p><p>  查找或创建同行和＃39的共享PUB /子主题;此处理程序的实例可以发布和订阅。</p><p>  func VideoConnections(w http.ResponseWriter, r *http.Request) { ws, err := websocket.Accept(w, r, nil) if err != nil { log.Fatal(err) } defer closeWS(ws) userID := strings.ToLower(r.URL.Query().Get(&#34;userID&#34;)) peerID := strings.ToLower(r.URL.Query().Get(&#34;peerID&#34;)) peers := []string{userID, peerID} sort.Strings(peers) topicName := fmt.Sprintf(&#34;video-%s-%s&#34;, peers[0], peers[1]) topic := pubSub.Topic(topicName) topic.EnableMessageOrdering = true ctx := context.Background() exists, err := topic.Exists(ctx) if err != nil { log.Fatal(err) } if !exists { log.Printf(&#34;Topic %s doesn&#39;t exist - creating it&#34;, topicName) _, err = pubSub.CreateTopic(ctx, topicName) if err != nil { log.Fatal(err) } } cctx, cancelFunc := context.WithCancel(ctx) go wsLoop(ctx, cancelFunc, ws, topic, userID) pubSubLoop(cctx, ctx, ws, topic, userID)}</p><p>  Func VideoConnections（W http.ResponseWriter，R * Http.Request）{WS，ERR：= WebSocket.accept（W，R，NIL）如果ERR！= nil {log.fatal（err）}推迟关闭（WS）UserID： = strings.tring.Tolower（r.url.query（）。获得（＆＃34; userid＆＃34;））peerid：= strings.tolower（r.url.query（）。获得（＆＃34; peerid＆＃34; ））对等体：= []字符串{userid，peerID} sort.strings（对等体）主题名称：= fmt.sprintf（＆＃34;视频 - ％s-％s＆＃34;，同行[0]，对等体[1] ）主题：= pubsub.topic（topicname）主题.enableMessageordering = true ctx：= context.background（）存在，err：= topic.exist（ctx）如果err！= nil {log.fatal（err）}如果存在{log.printf（＆＃34;主题％s不存在 - 创建它 - 创建它＆＃34;，主题名称）_，err = pubsub.createTopic（CTX，Pointname）如果Err！= nil {log.fatal（Err cctx，cancelfunc：= context.withcancel（ctx）go wsloop（ctx，cancelfunc，ws，主题，userid）pubsubloop（cctx，ctx，ws，主题，userid）}</p><p>  wsLoop listens for new messages coming to the websocket and publishes them to the Pub/Sub topic with an ordering key, to ensure everything arrives in the order it was sent:</p><p>  WSLoop侦听到WebSocket的新消息，并通过订购密钥将它们发布到Pub / sub主题，以确保所有内容到达它发送的顺序：</p><p>  func wsLoop(ctx context.Context, cancelFunc context.CancelFunc, ws *websocket.Conn, topic *pubsub.Topic, userID string) { log.Printf(&#34;Starting wsLoop for %s...&#34;, userID) orderingKey := fmt.Sprintf(&#34;%s-%s&#34;, userID, topic.ID()) for { if _, message, err := ws.Read(ctx); err != nil { log.Printf(&#34;Error reading message %s&#34;, err) break } else { log.Printf(&#34;Received message to websocket: &#34;) msg := &amp;pubsub.Message{ Data: message, Attributes: map[string]string{&#34;sender&#34;: userID}, OrderingKey: orderingKey, } if _, err = topic.Publish(ctx, msg).Get(ctx); err != nil { log.Printf(&#34;Could not publish message: %s&#34;, err) return } } } cancelFunc() log.Printf(&#34;Shutting down wsLoop for %s...&#34;, userID)}</p><p>  func wsloop（ctx context.context，cancelfunc context.canceffunc，ws * websocket.conn，主题* pubsub.topic，userid字符串）{log.printf（＆＃34;启动wsloop for％s ...＆＃34;， UserID）OrderingKey：= fmt.sprintf（＆＃34;％s-％s＆＃34; userid，topic.id（））for {if _，message，err：= ws.read（CTX）; err！= nil {log.printf（＆＃34;读取消息％s＆＃34错误）break} else {log.printf（＆＃34;收到的消息到websocket：＆＃34;）msg：=＆amp ; pubsub.message {data：message，属性：map [string]字符串{＆＃34; sender＆＃34; somentringkey：somingswey，}如果_，err = topic.publish（ctx，msg）.get（ CTX）; err！= nil {log.printf（＆＃34;无法发布消息：％s＆＃34;，err）return}}}}}}}}}}}}}}}}} compelfunc（）log.printf（＆＃34;关闭wsloop for％s ... ＆＃34;，userid）} </p><p>  Finally,  pubSubLoop listens for new messages published to the Pub/Sub topic and writes them to the websocket:</p><p>最后，Pubsubloop侦听发布到PUB /子主题的新消息，并将它们写入WebSocket：</p><p>  func pubSubLoop(cctx, ctx context.Context, ws *websocket.Conn, topic *pubsub.Topic, userID string) { log.Printf(&#34;Starting pubSubLoop for %s...&#34;, userID) subscriptionName := fmt.Sprintf(&#34;%s-%s&#34;, userID, topic.ID()) sub := pubSub.Subscription(subscriptionName) if exists, err := sub.Exists(ctx); err != nil { log.Printf(&#34;Error checking if sub exists: %s&#34;, err) return } else if !exists { log.Printf(&#34;Creating subscription: %s&#34;, subscriptionName) if _, err = pubSub.CreateSubscription( context.Background(), subscriptionName, pubsub.SubscriptionConfig{ Topic: topic, EnableMessageOrdering: true, }, ); err != nil { log.Printf(&#34;Error creating subscription: %s&#34;, err) return } } if err := sub.Receive(cctx, func(c context.Context, m *pubsub.Message) { m.Ack() if m.Attributes[&#34;sender&#34;] == userID { log.Println(&#34;skipping message from self&#34;) return } log.Printf(&#34;Received message to pubSub: &#34;) if err := ws.Write(ctx, websocket.MessageText, m.Data); err != nil { log.Printf(&#34;Error writing message to %s: %s&#34;, userID, err) return } }); err != nil { log.Printf(&#34;Error setting up subscription Receive: %s&#34;, err) } log.Printf(&#34;Shutting down pubSubLoop for %s...&#34;, userID)}</p><p>  Func Pubsubloop（CCTX，CTX Context.Context，WS * WebSocket.conn，主题* pubsub.topic，UserID字符串）{log.printf（＆＃34; logpsubloop for％s ...＆＃34; hessid）subscriptionname ：= fmt.sprintf（＆＃34;％s-％s＆＃34;，userid，topic.id（））子：= pubsub.subscription（subscriptionname）如果存在，err：= sub.exists（CTX）; err！= nil {log.printf（＆＃34;如果sub存在的错误检查：％s＆＃34; err）返回}如果！存在{log.printf（＆＃34;创建订阅：％s＆＃34; ，supencriptionname）如果_，err = pubsub.createsubscription（context.background（），supmoctionname，pubsub.subscref {topic：主题，enablemessageoring：true，}，）; err！= nil {log.printf（＆＃34;创建订阅错误：％s＆＃34;错误）return}}如果err：= sub.receive（cctx，func（c context.context，m * pubsub.message，m * pubsub.message ）{m.ack（）如果m.attributes [＆＃34;发件人＆＃34;] == userid {log.println（＆＃34;从self＆＃34跳过消息）return} log.printf（＆＃34 ;收到的消息到pubsub：＆＃34;）如果err：= ws.write（ctx，websocket.messageText，m.data）; err！= nil {log.printf（＆＃34;错误写入％s错误写入消息： ％s＆＃34;，userid，err）return}}; err！= = nil {log.printf（＆＃34;收到的错误设置：％s＆＃34;，err）} log.printf（＆＃34;关闭pubsubloop for％s ...＆＃34;，用户身份）}</p><p>  And with that, I have a working solution. I&#39;ve tested it on various computers and mobile browsers, on different networks across some distances. The peer-to-peer connection is usually crystal clear. It feels better than the mainstream video conferencing tools, which is quite satisfying. It was good to dive in to some technical areas that I hadn&#39;t explored before and come out with something that I understand and works well.</p><p>  而且，我有一个工作解决方案。我在各种计算机和移动浏览器上测试了它，在不同的网络上进行了一些距离。对等连接通常是晶体清晰的。它感觉比主流视频会议工具更好，这非常令人满意。潜入我曾经探讨过的一些技术领域是良好的，并与我理解和运作良好的东西出来。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mattbutterfield.com/blog/2021-05-02-adding-video-chat">https://mattbutterfield.com/blog/2021-05-02-adding-video-chat</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/webrtc/">#webrtc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/video/">#video</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/消息/">#消息</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>