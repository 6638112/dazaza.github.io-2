<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>清理您的Postgres数据库 Cleaning Up Your Postgres Database</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cleaning Up Your Postgres Database<br/>清理您的Postgres数据库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 11:57:49</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/1e4aa0c9f9e5ded7eae59321f29ae2ce.png"><img src="http://img2.diglog.com/img/2021/3/1e4aa0c9f9e5ded7eae59321f29ae2ce.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Last week I was on a call with someone giving an overview of   Crunchy Bridge, our multi-cloud fully managed database as a service. During the call they asked about what was the best way to get a sense of how their database was doing, a   health check if you will. I mentioned a few monitoring tools such as   pganalyze and  pgMonitor that were good options, but that we could also dig in live and see how things were.</p><p>上周我正在呼吁有人概述嘎吱嘎吱的桥梁，我们的多云完全托管数据库作为服务。在呼吁期间，他们询问了解他们的数据库如何做的最佳方式是什么，如果您愿意，健康检查。我提到了一些监测工具，如Pgganalyze和PGMonitor，这是良好的选择，但我们也可以在生活中挖掘，看看事情是如何。</p><p> The person I was talking to was very similar to many of the customers we run databases for - an application developer, without a full time DBA on staff. They needed a little extra guidance and support and they were outgrowing their existing hosting provider, so we dug in to do a bit of spring cleaning and assessment on their database.</p><p> 我正在谈论的人与我们的许多客户相似，我们为应用程序开发人员运行数据库，而没有全职DBA员工。他们需要一点额外的指导和支持，他们正在超越现有的托管提供商，所以我们挖掘了一些在他们的数据库中进行了一些春季清洁和评估。</p><p> While I’m generally happy to spend a few minutes with anyone interested to talk about how Crunchy could help and to dig into your database with you, I’m also a fan of self-servicing. Here’s a walk through of each of the pieces we looked at (all within a few minutes) to help give some actionable steps on how to improve their database performance.</p><p> 虽然我一般很高兴与有兴趣谈论谈话有兴趣的人花几分钟，但我也可以和你一起挖掘你的数据库，但我也是自助服务的粉丝。以下是我们查看的每个碎片（几分钟之内），帮助提供一些可操作的步骤如何提高数据库性能。</p><p>  The first thing you&#39;re going to want to look at is your cache hit ratio and index hit ratio. Your cache hit ratio is going to give the percentage of time your data is served from within memory vs. having to go to disk. Generally serving data from memory vs. disk is going to orders of magnitude faster, thus the more you can serve from memory the better. For a typical web application making a lot of short requests I&#39;m going to target &gt; 99% here.</p><p>  您的第一件事＆＃39;重新想要查看的是您的缓存命中率和索引命中率。您的缓存命中率将提供您在内存与内存中服务的时间百分比。必须转到磁盘。一般从内存与磁盘服务的数据进入幅度的顺序更快，因此您可以从内存中服务得更好。对于典型的Web应用程序，制作很多短请求i＆＃39; m将要瞄准＆gt;这里有99％。</p><p>  sql SELECT   &#39;index hit rate&#39; AS name,   (sum(idx_blks_hit)) / nullif(sum(idx_blks_hit + idx_blks_read),0) AS ratio FROM pg_statio_user_indexes UNION ALL SELECT  &#39;table hit rate&#39; AS name,   sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read),0) AS ratio FROM pg_statio_user_tables;</p><p>  SQL选择＆＃39;索引命中率＆＃39;作为名称，（SUM（idx_blks_hit））/ nullif（sum（idx_blks_hit + idx_blks_read），0）为pg_statio_user_indexes联合的比例全部选择＆＃39;表命中率＆＃39;作为名称，sum（heap_blks_hit）/ nullif（sum（eacp_blks_hit）+ sum（eacp_blks_read），0）为pg_statio_user_tables的比率;</p><p> In their case, the cache hit ratio looked good and healthy. Had it been something like 80% or 90%, the solution is simple:   get your database more memory by upgrading to the next step up.</p><p> 在他们的情况下，缓存命中比率看起来很好，健康。如果它有类似的80％或90％，那么解决方案很简单：通过升级到下一步，通过升级来获取更多内存。</p><p> From here we went ahead and took a look at the indexes and how often they&#39;re used. When you query a database the default behavior is going to be: scan the entire table to find records that match. This works fine when your table is 10 records, but for any sizable application scanning millions of records is simply not feasible. It is likely you&#39;ve added some indexes as you&#39;ve gone along to speed things up. In the below query you&#39;ll see how often you used an index when querying each respective table:</p><p> 从这里我们继续看看索引，他们经常使用频率。查询数据库时，默认行为将是：扫描整个表以查找匹配的记录。当您的表是10条记录时，这会很好，但对于扫描数百万记录的任何相同的应用程序根本不可行。你很可能是＆＃39; ve添加了一些索引，因为你已经走了一些索引。在下面查询您＆＃39; ll查看您在查询每个相应表时使用索引的频率： </p><p>  sql SELECT relname,    CASE idx_scan      WHEN 0 THEN &#39;Insufficient data&#39;      ELSE (100 * idx_scan / (seq_scan + idx_scan))::text    END percent_of_times_index_used,    n_live_tup rows_in_table  FROM    pg_stat_user_tables  ORDER BY    n_live_tup DESC;         relname        | percent_of_times_index_used | rows_in_table -----------------------+-----------------------------+---------------  account               | 11                          |          5409  deploy                | 69                          |         58276  app                   | 93                          |          5345  team                  | 98                          |          1801  firewall_rule         | 9                           |           984  ...</p><p>SQL选择Relname，案例IDX_SCAN 0然后＆＃39;数据＆＃39不足;否则（100 * idx_scan /（seq_scan + idx_scan））:: text exp percent_of_times_Under，n_live_tup rows_in_table从pg_stat_user_tables顺序由n_live_tup desc排序; Relname | percent_of_times_index_used | Rows_in_table ------------------------------------------ ---- + --------------帐户| 11 | 5409部署| 69 | 58276 App | 93 | 5345团队| 98 | 1801防火墙_rule | 9 | 984 ......</p><p>   Here I&#39;ve got a couple of things that would be worth digging in further to adding some indexes. The first is the  account table. While the  account table only has 5,409 records it is likely to continue growing and is clearly missing some needed indexes since only 11% of the time an index is used when querying that table. The other table of interest is the  deploy table. As we can see the  deploy table is the largest one. The  deploy table has some indexes as they are used 69% of the time, but some workflow in the table is querying and not having an index that helps.</p><p>   在这里，我有几件事是值得进一步的东西来增加一些索引。第一个是帐户表。虽然帐户表只有5,409条记录，可能会继续生长，并且显然缺少一些所需的索引，因为只有11％的时间在查询该表时使用索引。其他兴趣表是部署表。我们可以看到部署表是最大的。 Deploy表具有一些索引，因为它们是69％的时间，但表中的一些工作流程是查询的，而不是有帮助的索引。</p><p>  Once we saw that their indexing was in good shape we shifted to what we could clean-up. As an application grows and matures you likely have some things you did early on that are now and unnecessary tax. The thing to look for here is your unused indexes-these are indexes that exist within the database but your queries are not utilizing them. This means you&#39;re getting slower throughput on writes with well no benefit from the index existing.</p><p>  一旦我们看到他们的索引状况良好，我们就会转向我们可以清理的东西。随着应用程序的增长和成熟，您可能会在现在和不必要的税收上进行一些事情。这里要查找的是您未使用的索引 - 这些是数据库中存在的索引，但您的查询不利用它们。这意味着你＆＃39;重新获得较慢的吞吐量，没有索引现有的索引。</p><p>  sql SELECT   schemaname || &#39;.&#39; || relname AS table,   indexrelname AS index,   pg_size_pretty(pg_relation_size(i.indexrelid)) AS index_size,   idx_scan as index_scans FROM pg_stat_user_indexes ui JOIN pg_index i ON ui.indexrelid = i.indexrelid WHERE NOT indisunique AND idx_scan &lt; 50 AND pg_relation_size(relid) &gt; 5 * 8192 ORDER BY pg_relation_size(i.indexrelid) / nullif(idx_scan, 0) DESC NULLS FIRST, pg_relation_size(i.indexrelid) DESC;</p><p>  SQL选择Schemaname || ＆＃39;＆＃39; || Relname作为表，indexrelname作为index，pg_size_pretty（pg_relation_size（i.indexrelid））作为index_size，idx_scan为来自pg_stat_user_indexes ui的index_scans加入pg_index i上的ui.indexrelid = i.indexrelid，其中not IndisUnique和Idx_scan＆lt; 50和pg_relation_size（Relid）＆gt;通过pg_relation_size（i.indexrelid）/ nullif（idx_scan，0）desc null，pg_relation_size（i.indexrelid）desc; 5 * 8192</p><p>  While you want to go through removing these indexes with caution you’re usually quite safe to remove these extra indexes that have no usage and are simply slowing down your throughput.</p><p>  虽然您要删除这些索引，但谨慎地删除这些索引，您通常会非常安全地删除没有使用的额外索引，并且只是放慢吞吐量。</p><p>  One very common habit when you are starting out is to put everything in your database. This isn’t all bad, Postgres is quite versatile and can   handle a lot of what you can throw at it. But some very specific tables often can make sense in other data stores, if you have a table called  messages,  logs,  events in your Postgres database there is a good chance it’s consuming the bulk of your storage, is your largest table, and could benefit from being moved outside of your main Postgres database.</p><p>  当您开始时，一个非常常见的习惯是将所有内容放在您的数据库中。这不是坏事，postgres是相当多样的，可以处理很多你可以抛弃的东西。但是，一些非常特定的表通常可以在其他数据存储中有意义，如果您有一个名为消息，日志，日志，事件数据库的表，则会有很好的机会，它会消耗大部分存储，是您最大的桌子，并且可以受益从Main Postgres数据库之外移动。</p><p>  I’ve said for many years   pg_stat_statements is one of the most   useful extensions for Postgres. It records queries that are run against your database and a number of stats about them. It is a great place to go once a month or so and look up what queries are slowest on average as well as ones that consume the most total time against your system.</p><p>  我已经说过多年PG_Stat_Statements是Postgres最有用的扩展之一。它记录了对数据库运行的查询以及关于它们的许多统计数据。每月一次左右的地方是一个很好的地方，并查找Qualies的速度最慢，以及消耗最多时间对系统的疑虑。 </p><p> We’ll dig into  pg_stat_statements more in the future, but for now if you want a quick look this query can give you a preview:</p><p>我们将来更多地挖掘pg_stat_statements，但现在如果您想要快速外观，则此查询可以为您提供预览：</p><p>  SELECT     (total_time / 1000 / 60) as total_minutes,     (total_time/calls) as average_time,     query   FROM pg_stat_statements   ORDER BY 1 DESC   LIMIT 50;</p><p>  选择（total_time / 1000/60）作为total_minutes，（total_time / calual）作为sultial_time，从pg_stat_statements outder qual qual desc limit 50查询。</p><p>  You don’t need to understand how MVCC underlies Postgres, or how to determine during a failover that it is safe to failover to have a well tuned Postgres database. Much of the tuning and improvements that can happen for your database aren’t the result of transaction logs and linux huge page tuning, rather it can be identifying N+1 queries, or just paying attention to wasteful things like “logs” consuming space and not providing value. Walking through the above, without advanced knowledge of Postgres should give you a good starting point to clean up.</p><p>  您无需了解MVCC如何下潜的Postgres，或者如何在故障转移期间确定它是安全的故障转移才能进行良好调整的Postgres数据库。对于您的数据库可能发生的大部分调整和改进不是事务日志和Linux巨大页面调整的结果，而是可以识别n + 1查询，或者只是注意浪费像“日志”的浪费空间不提供价值。走过上面，没有先进的Postgres知识应该给你一个良好的起点来清理。</p><p> And as always if you do find yourself wanting extra support and guidance in your Postgres journey, we’re always happy to chat here  @crunchydata.</p><p> 如果您在Postgres旅程中发现自己想要额外的支持和指导，我们总是很乐意在这里聊天@CrunchyData。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://blog.crunchydata.com/blog/cleaning-up-your-postgres-database">http://blog.crunchydata.com/blog/cleaning-up-your-postgres-database</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/postgres/">#postgres</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>