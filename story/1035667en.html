<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>优化Web应用程序100x就像添加99台服务器Optimizing Your Web App 100x Is Like Adding 99 Servers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Optimizing Your Web App 100x Is Like Adding 99 Servers<br/>优化Web应用程序100x就像添加99台服务器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 23:10:34</div><div class="page_narrow text-break page_content"><p>A lot of tech discussion these days is focused around scaling web app infrastructures to handle huge traffic.</p><p>如今，许多技术讨论都集中在扩展Web应用程序基础结构以处理巨大流量方面。</p><p> Hacker News abounds with posts about Kubernetes, distributed systems and database replication; the  Large-Scale System Design Primer on GitHub is extremely well-loved (113k stars) and chock full of advice on memcache clusters and DB sharding.</p><p> 黑客新闻中充斥着有关Kubernetes，分布式系统和数据库复制的文章； GitHub上的“大规模系统设计入门”非常受人欢迎（11.3万颗星），并且充斥着有关内存缓存集群和数据库分片的建议。</p><p> In all the heady excitement of getting your web-based notepad app ready to handle 10 billion daily users, it&#39;s important not to forget the power of modern computing hardware and how far simple optimizations can go.</p><p> 使基于Web的记事本应用程序可以处理每天100亿用户的所有令人兴奋的事情中，重要的是不要忘记现代计算硬件的强大功能以及简单的优化可以走多远。</p><p> You&#39;re probably not Facebook. Setting up FAANG-level infrastructure won&#39;t make your company into a FAANG, any more than a cargo cult can summon supply-bearing planes by building fake runways and wooden ATC towers.</p><p> 您可能不是Facebook。建立FAANG级别的基础设施并不会使您的公司成为FAANG，这就像货运人员可以通过建造假跑道和木制ATC塔来召唤有货飞机一样。</p><p> There&#39;s a place for big, scalable cluster infrastructures, but it&#39;s a larger scale than many organizations think.</p><p> 大型的，可伸缩的群集基础结构有一定的位置，但是它的规模比许多组织想象的要大。</p><p>  It may sound obvious, but - optimizing your app to fulfill a request in 1/10 the time is like adding 9 servers to a cluster. Optimizing to 1/100 the time (reducing requests from say 1.5 sec to 15ms) is like adding 99 servers.</p><p>听起来似乎很明显，但是-优化您的应用程序以在1/10的时间内完成请求就像将9台服务器添加到集群中一样。优化时间到1/100（将请求从1.5秒减少到15ms）就像添加99台服务器。</p><p> That&#39;s a 1U server doing the work of  two 42U server racks, formerly busy turning inefficient code into heat.</p><p> 那是一台1U服务器，可以完成两个42U服务器机架的工作，以前是忙于将低效的代码转化为热量。</p><p> That may be an extreme case - but unnecessary bloat is common, and these kinds of gains could be as simple as adding a well-chosen index to speed up a common query by 10x or 100x, or caching some seldom-changing response in memory rather than re-rendering it every time.</p><p> 那可能是一个极端的情况-但是不必要的膨胀是很常见的，而这些好处很简单，例如添加一个精心选择的索引以将常见查询速度提高10倍或100倍，或者在内存中缓存一些很少变化的响应，而不是每次都重新渲染它。</p><p>  Cleaner, more maintainable code and systems - optimizing often just means simplifying and removing unnecessary parts</p><p>  更干净，更可维护的代码和系统-优化通常只是意味着简化和删除不必要的部分</p><p> Snappier experience for users (latency is generally lower if you can optimize enough to run on a single server rather than a bunch of networked ones)</p><p> 给用户带来更愉悦的体验（如果您可以优化以在单个服务器而不是一堆联网服务器上运行，则延迟通常会更低）</p><p>  Happier users - developers can focus more on solving users&#39; problems and less on infrastructure</p><p>用户更幸福-开发人员可以将更多精力放在解决用户的问题上，而将精力放在基础架构上</p><p> Of course there&#39;s a tradeoff between the cost of cloud infrastructure and the cost of paying developers to optimize; but paying developers to set up app clusters and database replication costs money too, and has fewer of the benefits and cost savings.</p><p> 当然，在云基础架构的成本和向开发人员支付优化费用之间需要权衡；但是向开发人员付费以建立应用程序集群和数据库复制也要花钱，并且收益和成本节省更少。</p><p>  Writing the game engine in C++ for  Weapon Hacker, a side project of mine, taught me a lot about how powerful modern hardware really is.</p><p>  用C ++为Weapon Hacker（我的一个附带项目）编写游戏引擎，使我了解到很多现代硬件的真正功能。</p><p> Coming from a C# / Python / Javascript / JIT-compiled world, my early experiments putting graphics on the screen in native C++ and DirectX were startling; the compiled executable was tiny, started up instantly, and could put hundreds of thousands of objects on the screen at 60 frames per second without breaking a sweat.</p><p> 来自C＃/ Python / Javascript / JIT编译的世界，我早期的将图形显示在本机C ++和DirectX中的实验令人吃惊；编译后的可执行文件很小，可以立即启动，并且可以以每秒60帧的速度在屏幕上放置数十万个对象，而不会费力。</p><p> A 60 FPS target gives games about 16ms to do all the work they need to in a frame. Weapon Hacker doesn&#39;t even compare to what modern AAA engines do, but it generates its random worlds in about 15ms (which last for about an hour-long playthru), and it handles frames with thousands of particles, physics objects, textures, font glyphs and graphical primitives, as well as sound mixing and music streaming, in about 5ms on a 2010-era CPU.</p><p> 一个60 FPS的目标为游戏提供了大约16ms的时间来完成其在一帧中所需的全部工作。 Weapon Hacker甚至无法与现代AAA引擎相比，但是它会在15毫秒内生成随机世界（持续约一小时的播放时间），并且可以处理包含数千个粒子，物理对象，纹理，字体的帧字形和图形图元，以及声音混合和音乐流，在2010年代的CPU上大约需要5毫秒。</p><p> Compared to a game engine, the job of most web apps is incredibly mundane: take a request (some HTTP text) and return a response (some HTML or JSON or some such). And yet, 100ms or 500ms request processing times are common. Sometimes the info returned is expensive to generate, but it pays not to forget that in the end it&#39;s just inputting some bytes and outputting some bytes.</p><p>与游戏引擎相比，大多数Web应用程序的工作异常平凡：接收请求（某些HTTP文本）并返回响应（某些HTML或JSON等）。但是，100ms或500ms的请求处理时间很常见。有时返回的信息生成起来很昂贵，但值得一提的是不要忘记最后只是输入一些字节并输出一些字节。</p><p> Given the relative simplicity of the task, 16ms of processing per request (after subtracting network latency) should be achievable in most web applications.</p><p> 考虑到任务的相对简单性，在大多数Web应用程序中，每个请求（减去网络延迟）后的处理时间应为16ms。</p><p> On a cheap $5/month dual-core cloud VM, that would allow about 7,500 requests per minute. Or 7,500 pageviews, if you offload static stuff to a CDN. That means 10.8M per day, or 324M pageviews per month.</p><p> 在每月5美元的便宜双核云虚拟机上，每分钟允许大约7500个请求。如果将静态内容卸载到CDN，则可以达到7,500次综合浏览量。这意味着每天1080万，或每月3.24亿的网页浏览量。</p><p> Of course traffic wouldn&#39;t be evenly spread throughout the day, and cloud computing is generally priced for burst loads. But, let&#39;s be honest - your traffic isn&#39;t anywhere near 324M pageviews, right?</p><p> 当然，流量不会一整天平均分配，并且云计算通常针对突发负载定价。但是，说实话-您的访问量不在324M浏览量附近，对吧？</p><p> If not, condolences that Notepadly.io isn&#39;t a market behemoth yet - but congratulations, you can divert some time from multi-master replication and spot instance auto-scaling, and add a cool Clippy virtual assistant instead. Your users will thank you for it.</p><p> 如果不是这样，就对Notepadly.io尚未成为市场巨头表示哀悼-但是，祝贺您，您可以将时间从多主复制和竞价型实例自动扩展中转移出来，并添加一个很棒的Clippy虚拟助手。您的用户将对此表示感谢。</p><p>  Server-side optimization is a big topic, and there are likely people much better at it (and at explaining it) than I am, so here are just a few general pointers.</p><p>服务器端优化是一个很大的话题，可能有人会比我做得更好（并且在解释方面），所以这里只是一些一般性的建议。</p><p>  This can be as simple as putting timers around sections of code to see how many milliseconds they take to execute. Or, look at TTFB (time to first byte) in the Network tab of your browser&#39;s dev tools.</p><p>  这可以像在代码段周围放置计时器一样简单，以查看它们执行多少毫秒。或者，在浏览器的开发工具的“网络”标签中查看TTFB（至第一个字节的时间）。</p><p> 2ms and 200ms requests seem similar to human perception, despite a massive 100x time difference, so it pays to have hard data.</p><p> 尽管存在100倍的巨大时差，但2ms和200ms的请求似乎与人类的感知相似，因此拥有硬数据是值得的。</p><p> Run simple stress tests to see how much traffic your app can handle. A simple one-page python script on a nearby VM or a dev machine can easily spin up a bunch of threads to make requests as fast as possible. Count the number of completed requests in, say, 30 seconds and watch your server&#39;s CPU, memory and IO usage to see where they max out.</p><p> 运行简单的压力测试以查看您的应用程序可以处理多少流量。附近的VM或开发机上的一个简单的一页python脚本可以轻松启动一堆线程以尽可能快地发出请求。计算完成请求的数量（例如30秒），并观察服务器的CPU，内存和IO使用情况，以查看最大数量的请求。</p><p> Compare your stress test results to your day-to-day traffic, and aim for enough headroom that a normal day&#39;s traffic peaks at ~1% capacity (or whatever makes your business).</p><p> 将压力测试结果与您的日常流量进行比较，并争取足够的净空，以使正常流量的峰值达到约1％的容量（或与您的业务无关的任何容量）。</p><p>  Optimize your database queries - add a well-chosen index, or delete an unneeded one (indices are separate internal tables, so you can sometimes save a lot of storage space and I/O time by removing one); tweak your WHERE conditions to narrow down the rows the DB has to scan through internally</p><p>优化数据库查询-添加一个精心选择的索引，或者删除一个不需要的索引（索引是独立的内部表，因此有时通过删除一个索引可以节省很多存储空间和I / O时间）；调整您的WHERE条件以缩小数据库内部必须扫描的行</p><p> Reduce the number of HTTP requests; don&#39;t let REST purists tell you you need a separate URL for each entity - if your app always needs customer &amp; order data at the same time, make it a single API call</p><p> 减少HTTP请求的数量；不要让REST纯粹主义者告诉您每个实体需要一个单独的URL-如果您的应用始终总是同时需要客户和订单数据，请使其成为单个API调用</p><p>   Make sure your web server and database are set up and tuned right - that they have enough memory, threads, etc.</p><p>   确保正确设置并调整了Web服务器和数据库-它们具有足够的内存，线程等。</p><p> Consider a fast single-file database like  SQLite; it&#39;s not for every application, but I&#39;ve found it handles individual queries about 5x faster than the big client-server DBMS&#39;s, with about 1/5 the storage space, and with much less administrative complexity. With its performance numbers it can actually power large sites. It also supports sharding scenarios (e.g. a database file per customer) which can get around the write-concurrency limitations for some applications.</p><p> 考虑一个快速的单文件数据库，例如SQLite。它并不适用于所有应用程序，但是我发现它处理单个查询的速度比大型客户端服务器DBMS快5倍左右，存储空间约为1/5，管理复杂性则低得多。凭借其性能数字，它实际上可以为大型站点提供动力。它还支持分片方案（例如每个客户一个数据库文件），可以解决某些应用程序的写并发限制。</p><p> Learn about code performance - in particular the dominance of memory latency as a slowdown factor, and the high price of I/O. Chandler Carruth has  a great talk on these from a C++ perspective. And Mike Acton&#39;s  talk on data-oriented design is a classic.</p><p> 了解有关代码性能的信息-特别是内存延迟（作为减速因素）的优势以及I / O的高昂价格。从C ++的角度来看，Chandler Carruth对此进行了精彩的演讲。迈克·阿克顿（Mike Acton）关于面向数据设计的演讲是经典之作。</p><p>  Cloud hosts usually let you upgrade to a higher-powered VM pretty easily in the event of some viral flood of traffic; in AWS, on my clients&#39; projects, we have been able to launch more powerful EC2 instances (and vise-versa, consolidate to smaller, cheaper instances) by cloning to an AMI image, launching a new instance, and rerouting the same elastic IP, in about 5 minutes. If you freeze data changes, you can even stay online during the transition.</p><p>云主机通常使您可以在出现病毒性流量泛滥时轻松升级到性能更高的VM。在AWS上，在我客户的项目中，我们能够通过克隆到AMI映像，启动新实例并重新路由相同的弹性IP来启动功能更强大的EC2实例（反之亦然，整合为更小，更便宜的实例） ，大约需要5分钟。如果冻结数据更改，则在过渡期间甚至可以保持联机状态。</p><p> That could buy you time to think about clustering if you reach the scale where you need it.</p><p> 如果您达到了所需的规模，那可能会让您有时间思考群集。</p><p>  There&#39;s a time and a scale for big distributed computing setups. But modern CPUs and cloud VMs are insanely fast, and the job of most web apps is incredibly mundane - you can get very far with some basic optimizations, and will likely do the world, your developers and your users some favors in the process.</p><p>  大型分布式计算设置存在时间和规模。但是，现代的CPU和云VM的运行速度异常惊人，大多数Web应用程序的工作异常平凡-您可以通过一些基本的优化而走得很远，并且可能会在整个过程中为整个世界，您的开发人员和用户带来好处。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lukerissacher.com/blog/optimizing_your_web_app">https://lukerissacher.com/blog/optimizing_your_web_app</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>