<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>悲伤的域名系统解释</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">悲伤的域名系统解释</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-15 15:46:32</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/b4532d7463994d1c86bfe6f62b32ee79.png"><img src="http://img2.diglog.com/img/2020/11/b4532d7463994d1c86bfe6f62b32ee79.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This week, at the  ACM CCS 2020 conference, researchers from UC Riverside and Tsinghua University announced a new attack against the Domain Name System (DNS) called  SAD DNS (Side channel AttackeD DNS). This attack leverages recent features of the networking stack in modern operating systems (like Linux) to allow attackers to revive a classic attack category: DNS cache poisoning. As part of a coordinated disclosure effort earlier this year, the researchers contacted Cloudflare and other major DNS providers and we are happy to announce that 1.1.1.1 Public Resolver is no longer vulnerable to this attack.</p><p>本周，在ACM CCS 2020大会上，来自加州大学河滨分校和清华大学的研究人员宣布了一种针对域名系统(DNS)的新攻击，称为SAD DNS(侧通道攻击的DNS)。该攻击利用现代操作系统(如Linux)中网络堆栈的最新功能，使攻击者能够恢复一种经典的攻击类别：DNS缓存中毒。作为今年早些时候一项协同披露工作的一部分，研究人员联系了Cloudflare和其他主要的DNS提供商，我们很高兴地宣布，1.1.1.1 Public Resolver不再容易受到这种攻击。</p><p> In this post, we’ll explain what the vulnerability was, how it relates to previous attacks of this sort, what mitigation measures we have taken to protect our users, and future directions the industry should consider to prevent this class of attacks from being a problem in the future.</p><p>在这篇文章中，我们将解释该漏洞是什么，它与之前的这类攻击有什么关系，我们已经采取了哪些缓解措施来保护我们的用户，以及该行业应该考虑的未来方向，以防止此类攻击在未来成为问题。</p><p>  The Domain Name System (DNS) is what allows users of the Internet to get around without memorizing long sequences of numbers. What’s often called the “phonebook of the Internet” is more like a helpful system of translators that take natural language domain names (like blog.cloudflare.com or gov.uk) and translate them into the native language of the Internet: IP addresses (like 192.0.2.254 or [2001:db8::cf]). This translation happens behind the scenes so that users only need to remember hostnames and don’t have to get bogged down with remembering IP addresses.</p><p>域名系统(DNS)使互联网用户无需记住长串数字就可以四处走动。通常被称为“互联网电话簿”的东西更像是一个有用的翻译系统，它将自然语言域名(如blog.cloudflare.com或gov.uk)翻译成互联网的本地语言：IP地址(如192.0.2.254或[2001：DB8：：cf])。这种转换是在幕后进行的，因此用户只需要记住主机名，而不必陷入记住IP地址的泥潭。</p><p> DNS is both a system and a protocol. It refers to the hierarchical system of computers that manage the data related to naming on a network and it refers to the language these computers use to speak to each other to communicate answers about naming. The DNS protocol consists of pairs of messages that correspond to questions and responses. Each DNS question (query) and answer (reply) follows a standard format and contains a set of parameters that contain relevant information such as the name of interest (such as blog.cloudflare.com) and the type of response record desired (such as A for IPv4 or AAAA for IPv6).</p><p>DNS既是一种系统，也是一种协议。它指的是在网络上管理与命名相关的数据的计算机的分层系统，它指的是这些计算机用来相互交谈以交流有关命名的答案的语言。DNS协议由对应于问题和回答的消息对组成。每个DNS问题(查询)和答案(回复)都遵循标准格式，并包含一组参数，其中包含相关信息，如感兴趣的名称(如blog.cloudflare.com)和所需的响应记录类型(如A代表IPv4或AAAA代表IPv6)。</p><p>  These DNS messages are exchanged over a network between machines using a transport protocol. Originally, DNS used UDP, a simple stateless protocol in which messages are endowed with a set of metadata indicating a source port and a destination port. More recently, DNS has adapted to use more complex transport protocols such as TCP and even advanced protocols like TLS or HTTPS, which incorporate encryption and strong authentication into the mix (see Peter Wu’s blog post about  DNS protocol encryption).</p><p>这些DNS消息使用传输协议在机器之间的网络上交换。最初，DNS使用UDP，这是一种简单的无状态协议，在该协议中，消息被赋予一组指示源端口和目的端口的元数据。最近，DNS已经适应了使用更复杂的传输协议，如TCP，甚至高级协议，如TLS或HTTPS，它们将加密和强身份验证结合在一起(参见Peter Wu关于DNS协议加密的博客文章)。</p><p> Still, the most common transport protocol for message exchange is UDP, which has the advantages of being fast, ubiquitous and requiring no setup. Because UDP is stateless, the pairing of a response to an outstanding query is based on two main factors: the source address and port pair, and information in the DNS message. Given that UDP is both stateless and unauthenticated, anyone, and not just the recipient, can send a response with a forged source address and port, which opens up a range of potential problems.</p><p>不过，最常见的消息交换传输协议是UDP，它具有快速、无处不在且不需要设置的优点。由于UDP是无状态的，因此对未完成查询的响应配对取决于两个主要因素：源地址和端口对以及DNS消息中的信息。鉴于UDP既是无状态的，也是未经身份验证的，任何人(不仅仅是接收者)都可以使用伪造的源地址和端口发送响应，这会带来一系列潜在问题。</p><p>  Since the transport layer is inherently unreliable and untrusted, the DNS protocol was designed with additional mechanisms to protect against forged responses. The first two bytes in the message form a message or transaction ID that must be the same in the query and response. When a DNS client sends a query, it will set the ID to a random value and expect the value in the response to match. This unpredictability introduces entropy into the protocol, which makes it less likely that a malicious party will be able to construct a valid DNS reply without first seeing the query. There are other potential variables to account for, like the DNS query name and query type are also used to pair query and response, but these are trivial to guess and don’t introduce an additional entropy.</p><p>由于传输层本质上是不可靠和不可信的，因此DNS协议设计了额外的机制来防止伪造响应。消息中的前两个字节构成了查询和响应中必须相同的消息或事务ID。当DNS客户端发送查询时，它会将ID设置为随机值，并期望响应中的值匹配。这种不可预测性在协议中引入了熵，这使得恶意方不太可能在没有首先看到查询的情况下构建有效的DNS回复。还有其他潜在的变量需要考虑，比如DNS查询名称和查询类型也用于配对查询和响应，但这些变量很容易猜测，并且不会引入额外的熵。</p><p> Those paying close attention to the diagram may notice that the amount of entropy introduced by this measure is only around 16 bits, which means that there are fewer than a hundred thousand possibilities to go through to find the matching reply to a given query. More on this later.</p><p>密切关注该图的人可能会注意到，该度量引入的熵量只有16位左右，这意味着要找到与给定查询匹配的答案的可能性不到十万种。稍后会详细介绍这一点。</p><p>  DNS servers fall into one of a few main categories: recursive resolvers (like 1.1.1.1 or 8.8.8.8), nameservers (like the  DNS root servers or  Cloudflare Authoritative DNS). There are also elements of the ecosystem that act as “forwarders” such as  dnsmasq. In a typical DNS lookup, these DNS servers work together to complete the task of delivering the IP address for a specified domain to the client (the client is usually a stub resolver - a simple resolver built into an operating system). For more detailed information about the DNS ecosystem, take a look at  our learning site. The SAD DNS attack targets the communication between recursive resolvers and nameservers.</p><p>DNS服务器主要分为以下几类：递归解析器(如1.1.1.1或8.8.8.8)、名称服务器(如DNS根服务器或Cloudflare权威DNS)。生态系统中也有一些元素充当“转发器”，如dnsmasq。在典型的DNS查找中，这些DNS服务器协同完成将指定域的IP地址传递给客户端的任务(客户端通常是存根解析器-操作系统中内置的简单解析器)。有关DNS生态系统的更多详细信息，请访问我们的学习网站。SAD DNS攻击的目标是递归解析程序和名称服务器之间的通信。</p><p> Each of the participants in DNS (client, resolver, nameserver) uses the DNS protocol to communicate with each other. Most of the latest innovations in DNS revolve around  upgrading the transport between users and recursive resolvers to use encryption. Upgrading the transport protocol between resolvers and authoritative servers is a bit more complicated as it requires a new discovery mechanism to instruct the resolver when to (and when not to use) a more secure channel.  Aside from a few examples like  our work with Facebook to encrypt recursive-to-authoritative traffic with DNS-over-TLS, most of these exchanges still happen over UDP. This is the core issue that enables this new attack on DNS, and one that we’ve seen before.</p><p>DNS中的每个参与者(客户端、解析器、名称服务器)使用DNS协议相互通信。大多数最新的DNS创新都围绕着将用户和递归解析器之间的传输升级为使用加密。升级解析器和权威服务器之间的传输协议稍微复杂一些，因为它需要新的发现机制来指示解析器何时使用(以及何时不使用)更安全的通道。除了一些例子，比如我们与Facebook合作，使用TLS上的DNS对递归到权威的流量进行加密，大多数这些交换仍然发生在UDP上。这是启用这种针对DNS的新攻击的核心问题，也是我们以前见过的。</p><p>  Prior to 2008, recursive resolvers typically used a single open port (usually port 53) to send and receive messages to authoritative nameservers. This made guessing the source port trivial, so the only variable an attacker needed to guess to forge a response to a query was the 16-bit message ID. The attack  Kaminsky described was relatively simple: whenever a recursive resolver queried the authoritative name server for a given domain, an attacker would flood the resolver with DNS responses for some or all of the 65 thousand or so possible message IDs. If the malicious answer with the right message ID arrived before the response from the authoritative server, then the DNS cache would be effectively poisoned, returning the attacker’s chosen answer instead of the real one for as long as the DNS response was valid (called the TTL, or time-to-live).</p><p>在2008年前，递归解析器通常使用单个开放端口(通常是端口53)向权威名称服务器发送和接收消息。这使得猜测源端口变得微不足道，所以攻击者需要猜测的唯一变量就是16位消息ID。卡明斯基描述的攻击相对简单：每当递归解析器查询给定域的权威名称服务器时，攻击者就会向解析器发送约65,000个可能的消息ID中的部分或全部的DNS响应。如果具有正确消息ID的恶意答案在来自权威服务器的响应之前到达，则DNS缓存实际上是有毒的，只要DNS响应有效(称为TTL，即生存时间)，就会返回攻击者选择的答案，而不是真正的答案。</p><p> For popular domains, resolvers contact authoritative servers once per TTL (which can be as short as 5 minutes), so there are plenty of opportunities to mount this attack. Forwarders that cache DNS responses are also vulnerable to this type of attack.</p><p>对于流行的域名，解析程序每个TTL联系一次权威服务器(最短可达5分钟)，因此有大量机会发动这种攻击。缓存DNS响应的转发器也容易受到此类攻击。</p><p>  In response to this attack, DNS resolvers started doing source port randomization and careful checking of the security ranking of cached data. To poison these updated resolvers, forged responses would not only need to guess the message ID, but they would also have to guess the source port, bringing the number of guesses from the tens of thousands to over a billion. This made the attack effectively infeasible. Furthermore, the IETF published  RFC 5452 on how to harden DNS from guessing attacks.</p><p>为了应对此攻击，DNS解析器开始对源端口进行随机化，并仔细检查缓存数据的安全等级。要毒害这些更新的解析器，伪造的响应不仅需要猜测消息ID，还需要猜测源端口，从而使猜测的次数从数万次增加到10亿次以上。这使得攻击实际上是不可行的。此外，IETF还发布了RFC5452，内容是如何加强DNS免受猜测攻击。</p><p> It should be noted that this attack did not work for DNSSEC-signed domains since their answers are digitally signed. However, even now in 2020, DNSSEC is far from universal.</p><p>应该注意的是，此攻击不适用于DNSSEC签名的域，因为它们的答案是数字签名的。然而，即使现在是2020年，DNSSEC还远未普及。</p><p>  Another way to avoid having to guess the source port number and message ID is to split the DNS response in two. As is often the case in computer security, old attacks become new again when attackers discover new capabilities. In 2012, researchers Amir Herzberg and Haya Schulman from Bar Ilan University  discovered that it was possible for a remote attacker to defeat the protections provided by source port randomization. This new attack leveraged another feature of UDP: fragmentation. For a primer on the topic of UDP fragmentation, check out our  previous blog post on the subject by Marek Majkowski.</p><p>避免猜测源端口号和消息ID的另一种方法是将DNS响应一分为二。与计算机安全领域的常见情况一样，当攻击者发现新功能时，旧的攻击又会变成新的攻击。2012年，巴伊兰大学(Bar Ilan University)的研究人员阿米尔·赫兹伯格(Amir Herzberg)和哈亚·舒尔曼(Haya Schulman)发现，远程攻击者有可能破坏源端口随机化提供的保护。这种新的攻击利用了UDP的另一个特性：碎片化。有关UDP碎片主题的入门读物，请查看我们之前由Marek Majkowski撰写的关于该主题的博客文章。</p><p> The key to this attack is the fact that all the randomness that needs to be guessed in a DNS poisoning attack is concentrated at the beginning of the DNS message (UDP header and DNS header).If the UDP response packet (sometimes called a datagram) is split into two fragments, the first half containing the message ID and source port and the second containing part of the DNS response, then all an attacker needs to do is forge the second fragment and make sure that the fake second fragment arrives at the resolver before the true second fragment does. When a datagram is fragmented, each fragment is assigned a 16-bit IDs (called IP-ID), which is used to reassemble it at the other end of the connection. Since the second fragment only has the IP-ID as entropy (again, this is a familiar refrain in this area), this attack is feasible with a relatively small number of forged packets. The downside of this attack is the precondition that the response must be fragmented in the first place, and the fragment must be carefully altered to pass the original section counts and UDP checksum.</p><p>此攻击的关键在于，在DNS中毒攻击中需要猜测的所有随机性都集中在DNS消息(UDP报头和DNS报头)的开头。如果UDP响应数据包(有时称为数据报)被分成两个片段，前半部分包含消息ID和源端口，第二部分包含部分DNS响应，则攻击者需要做的就是伪造第二个片段，并确保假的第二个片段在真正的第二个片段到达解析程序之前到达解析程序。当数据报被分段时，每个分段都会被分配一个16位的ID(称为IP-ID)，用于在连接的另一端对其进行重组。由于第二个片段只有IP-ID作为熵(同样，这也是这一领域的常见问题)，因此利用相对较少数量的伪造数据包可以进行此攻击。此攻击的缺点是必须首先将响应分成碎片，并且必须仔细更改碎片以通过原始区段计数和UDP校验和。</p><p>  Also discussed in the original and  follow-up papers is a method of forcing two remote servers to send packets between each other which are fragmented at an attacker-controlled point, making this attack much more feasible. The details are in the paper, but it boils down to the fact that the control mechanism for describing the maximum transmissible unit (MTU) between two servers -- which determines at which point packets are fragmented -- can be set via a forged UDP packet.</p><p>在最初和后续文章中还讨论了一种强制两台远程服务器在攻击者控制的点上相互发送数据包的方法，从而使这种攻击更加可行。这些细节都在论文中，但归根结底，描述两个服务器之间的最大可传输单位(MTU)的控制机制--它决定了在哪个点上包被分割--可以通过伪造的UDP包来设置。</p><p>  We explored this risk in a previous blog post in the context of certificate issuance last year when we introduced our  multi-path DCV service, which mitigates this risk in the context of certificate issuance by making DNS queries from multiple vantage points. Nevertheless, fragmentation-based attacks are proving less and less effective as DNS providers move to eliminate support for fragmented DNS packets (one of the major goals of  DNS Flag Day 2020).</p><p>我们在去年的一篇博客文章中探讨了这种风险，当时我们介绍了我们的多路径DCV服务，该服务通过从多个有利位置进行DNS查询，降低了证书颁发环境中的这种风险。然而，随着DNS提供商采取行动消除对碎片DNS数据包的支持(这是2020年DNS旗帜日的主要目标之一)，基于碎片的攻击被证明越来越不有效。</p><p>  Another way to defeat the source port randomization is to use some measurable property of the server that makes the source port easier to guess. If the attacker could ask the server which port number is being used for a pending query, that would make the construction of a spoofed packet much easier. No such thing exists, but it turns out there is something close enough - the attacker can discover which ports are surely closed (and thus avoid having to send traffic). One such mechanism is the ICMP “port unreachable” message.</p><p>另一种阻止源端口随机化的方法是使用服务器的某些可测量属性，从而更容易猜测源端口。如果攻击者可以询问服务器正在将哪个端口号用于挂起的查询，这将使构建欺骗数据包变得容易得多。不存在这样的东西，但事实证明有一些足够接近的东西-攻击者可以发现哪些端口肯定是关闭的(从而避免了发送流量)。一种这样的机制是ICMP“端口不可达”消息。</p><p> Let’s say the target receives a UDP datagram destined for its IP and some port, the datagram either ends up either being accepted and silently discarded by the application, or rejected because the port is closed. If the port is closed, or more importantly, closed to the IP address that the UDP datagram was sent from, the target will send back an ICMP message notifying the attacker that the port is closed. This is handy to know since the attacker now doesn’t have to bother trying to guess the pending message ID on this port and move to other ports. A single scan of the server effectively reduces the search space of valid UDP responses from 2 32 (over a billion) to 2 17 (around a hundred thousand), at least in theory.</p><p>假设目标收到发往其IP和某个端口的UDP数据报，该数据报要么被应用程序接受并静默丢弃，要么因为端口关闭而被拒绝。如果端口关闭，或者更重要的是，关闭了发送UDP数据报的IP地址，则目标将发回ICMP消息，通知攻击者该端口已关闭。了解这一点很方便，因为攻击者现在不必费心猜测此端口上挂起的消息ID并移动到其他端口。对服务器的一次扫描有效地将有效UDP响应的搜索空间从232(超过10亿)减少到217(大约10万)，至少在理论上是这样。</p><p> This trick doesn’t always work. Many resolvers use “connected” UDP sockets instead of “open” UDP sockets to exchange messages between the resolver and nameserver. Connected sockets are tied to the peer address and port on the OS layer, which makes it impossible for an attacker to guess which “connected” UDP sockets are established between the target and the victim, and since the attacker isn’t the victim, it can’t directly observe the outcome of the probe.</p><p>这个把戏并不总是奏效的。许多解析器使用“连接的”UDP套接字而不是“开放的”UDP套接字在解析器和名称服务器之间交换消息。连接的套接字绑定到操作系统层上的对等地址和端口，这使得攻击者无法猜测在目标和受害者之间建立了哪些“连接的”UDP套接字，而且由于攻击者不是受害者，所以它不能直接观察探测的结果。</p><p> To overcome this, the researchers found a very clever trick: they leverage ICMP rate limits as a side channel to reveal whether a given port is open or not. ICMP rate limiting was introduced (somewhat ironically, given this attack) as a security feature to prevent a server from being used as an unwitting participant in a  reflection attack. In broad terms, it is used to limit how many ICMP responses a server will send out in a given time period. Say an attacker wanted to scan 10,000 ports and sent a burst of 10,000 UDP packets to a server configured with an ICMP rate limit of 50 per second, then only the first 50 would get an ICMP “port unreachable” message in reply.</p><p>为了克服这个问题，研究人员发现了一个非常聪明的窍门：他们利用ICMP速率限制作为辅助通道来揭示给定端口是否打开。ICMP速率限制是作为一种安全功能引入的(考虑到这种攻击有点讽刺意味)，目的是防止服务器在不知情的情况下被用作反射攻击的参与者。概括地说，它用于限制服务器在给定时间段内发送的ICMP响应的数量。假设攻击者想要扫描10,000个端口，并向配置了每秒50个ICMP速率限制的服务器发送10,000个UDP数据包，则只有前50个端口会收到ICMP“port unreacable”消息作为回应。</p><p> Rate limiting seems innocuous until you remember one of the core rules of data security:  don’t let private information influence publicly measurable metrics. ICMP rate limiting violates this rule because the rate limiter’s behavior can be influenced by an attacker making guesses as to whether a “secret” port number is open or not.</p><p>在记住数据安全的核心规则之一之前，速率限制似乎无伤大雅：不要让私人信息影响可公开测量的指标。ICMP速率限制违反了这一规则，因为速率限制器的行为可能会受到攻击者猜测某个“秘密”端口号是否开放的影响。</p><p>  An attacker wants to know whether the target has an open port, so it sends a spoofed UDP message from the authoritative server to that port. If the port is open, no ICMP reply is sent and the rate counter remains unchanged. If the port is inaccessible, then an ICMP reply is sent (back to the authoritative server, not to the attacker) and the rate is increased by one. Although the attacker doesn’t see the ICMP response, it has influenced the counter. The counter itself isn’t known outside the server, but whether it has hit the rate limit or not  can be measured by any outside observer by sending a UDP packet and waiting for a reply. If an ICMP “port unreachable” reply comes back, the rate limit hasn’t been reached. No reply means the rate limit has been met. This leaks one bit of information about the counter to the outside observer, which in the end is enough to reveal the supposedly secret information (whether the spoofed request got through or not).</p><p>攻击者想知道目标是否有开放的端口，因此它从权威服务器向该端口发送伪造的UDP消息。如果端口打开，则不会发送ICMP回复，并且速率计数器保持不变。如果端口不可访问，则会发送ICMP回复(返回给权威服务器，而不是攻击者)，并且速率会增加1。虽然攻击者看不到ICMP响应，但它已经影响了计数器。该计数器本身在服务器之外是未知的，但任何外部观察者都可以通过发送UDP数据包并等待回复来测量它是否达到了速率限制。如果返回ICMP“port unreacable”回复，则表示尚未达到速率限制。没有回复意味着已经达到了速率限制。这会向外部观察者泄露关于计数器的一丁点信息，最终足以泄露所谓的秘密信息(无论欺骗请求是否通过)。</p><p>  Concretely, the attack works as follows: the attacker sends a bunch (large enough to trigger the rate limiting) of probe messages to the target, but with a forged source address of the victim. In the case where there are no open ports in the probed set, the target will send out the same amount of ICMP “port unreachable” responses back to the victim and trigger the rate limit on outgoing ICMP messages. The attacker can now send an additional verification message from its own address and observe whether an ICMP response comes back or not. If it does then there was at least one port open in the set and the attacker can divide the set and try again, or do a linear scan by inserting the suspected port number into a set of known closed ports. Using this approach, the attacker can narrow down to the open ports and try to guess the message ID until it is successful or gives up, similarly to the original Kaminsky attack.</p><p>具体地说，攻击的原理如下：攻击者向目标发送一串探测消息(大到足以触发速率限制)，但带有伪造的受害者源地址。在被探测集合中没有打开的端口的情况下，目标将向受害者发回相同数量的ICMP“端口无法到达”响应，并触发传出ICMP消息的速率限制。攻击者现在可以从自己的地址发送额外的验证消息，并观察ICMP响应是否返回。如果是，则该集合中至少有一个端口打开，攻击者可以分割该集合并重试，或者通过将可疑的端口号插入一组已知的关闭端口来执行线性扫描。使用这种方法，攻击者可以缩小到开放端口，并尝试猜测消息ID，直到成功或放弃，类似于最初的卡明斯基攻击。</p><p>  First, the target IP, or a set of target IPs must be discovered. This might be trivial in some cases - a single forwarder, or a fixed set of IPs that can be discovered by probing and observing attacker controlled zones, but more difficult if the target IPs are partitioned across zones as the attacker can’t see the resolver egress IP unless she can monitor the traffic for the victim domain.</p><p>首先，必须发现目标IP或一组目标IP。在某些情况下，这可能是微不足道的-单个转发器，或者一组固定的IP，可以通过探测和观察攻击者控制的区域来发现，但如果目标IP被跨区域分区，则会更加困难，因为攻击者看不到解析器出口IP，除非她可以监控受害者域的通信量。</p><p> The attack also requires a large enough ICMP outgoing rate limit in order to be able to scan with a reasonable speed. The scan speed is critical, as it must be completed while the query to the victim nameserver is still pending. As the scan speed is effectively fixed, the paper instead describes a method to potentially extend the window of opportunity by triggering the victim&#39;s  response rate limiting (RRL), a technique to protect against floods of forged DNS queries. This may work if the victim implements RRL and the target resolver doesn’t implement a retry over TCP ( A Quantitative Study of the Deployment of DNS Rate Limiting shows about 16% of nameservers implement some sort of RRL).</p><p>攻击还需要足够大的ICMP传出速率限制才能以合理的速度扫描。扫描速度非常关键，因为它必须在对受害者名称服务器的查询仍处于挂起状态时完成。由于扫描速度实际上是固定的，因此本文描述了一种通过触发受害者的响应速率限制(RRL)来潜在地延长机会窗口的方法，RRL是一种防止伪造的DNS查询泛滥的技术。如果受害者实现了RRL，而目标解析器没有通过TCP实现重试(对部署DNS速率限制的定量研究显示，大约16%的名称服务器实现了某种类型的RRL)，这可能会奏效。</p><p> Generally, busy resolvers will have ephemeral ports opening and closing, which introduces false positive open ports for the attacker, and ports open for different pending queries than the one being attacked.</p><p>通常，繁忙的解析程序会有短暂的端口打开和关闭，这会给攻击者带来误报打开的端口，并为与被攻击的查询不同的待定查询打开端口。</p><p> We’ve implemented an additional mitigation to 1.1.1.1 to prevent message ID guessing - if the resolver detects an ID enumeration attempt, it will stop accepting any more guesses and switches over to TCP. This reduces the number of attempts for the attacker even if it guesses the IP address and port correctly, similarly to how the number of password login attempts is limited.</p><p>我们已经实现了对1.1.1.1的额外缓解，以防止消息ID猜测-如果解析器检测到ID枚举尝试，它将停止接受任何更多的猜测，并切换到TCP。这减少了攻击者的尝试次数，即使它正确地猜测了IP地址和端口，这与密码登录尝试次数的限制类似。</p><p>  Ultimately these are just mitigations, and the attacker might be willing to play the long game. As long as the transport layer is insecure and DNSSEC is not widely deployed, there will be different methods of chipping away at these mitigations.</p><p>归根结底，这些只是减刑，攻击者可能愿意玩长期游戏。只要传输层是不安全的，并且DNSSEC没有被广泛部署，就会有不同的方法来削弱这些缓解措施。</p><p> It should be noted that trying to hide source IPs or open port numbers is a form of security through obscurity. Without strong cryptographic authentication, it will always be possible to use spoofing to poison DNS resolvers. The silver lining here is that DNSSEC exists, and is designed to protect against this type of attack, and DNS servers are  moving to explore cryptographically strong transports such as TLS for communicating between resolvers and authoritative servers.</p><p>需要注意的是，试图隐藏源IP或开放端口号是一种通过隐藏来实现安全的方式。如果没有强大的加密身份验证，总是有可能使用欺骗来毒害DNS解析器。这里的一线希望是DNSSEC的存在，它的设计是为了防止这种类型的攻击，而且DNS服务器正在探索加密的强大传输，例如用于解析程序和权威服务器之间通信的TLS。</p><p> At Cloudflare, we’ve been helping to reduce the friction of DNSSEC deployment, while also  helping to improve transport security in the long run. There is also an effort to increase entropy in DNS messages with  RFC 7873 - Domain Name System (DNS) Cookies, and make DNS over TCP support mandatory  RFC 7766 - DNS Transport over TCP - Implementation Requirements, with even more  documentation around ways to mitigate this type of issue available in different places. All of these efforts are complementary, which is a good thing. The DNS ecosystem consists of many different parties and software with different requirements and opinions, as long as the operators support at least one of the preventive measures, these types of attacks will become more and more difficult.</p><p>在Cloudflare，我们一直在帮助减少DNSSEC部署的摩擦，同时从长远来看也有助于提高运输安全。还有一项努力是使用RFC 7873-域名系统(DNS)Cookie增加DNS消息中的熵，并使基于TCP的DNS支持强制的RFC 7766-基于TCP的DNS传输-实现要求，并在不同的地方提供更多关于缓解此类问题的方法的文档。所有这些努力都是相辅相成的，这是一件好事。DNS生态系统由许多不同的各方和具有不同要求和观点的软件组成，只要运营商至少支持其中一种预防措施，这些类型的攻击就会变得越来越困难。</p><p> If you are an operator of an authoritative DNS server, you should consider taking the following steps to protect yourself from this attack:</p><p>如果您是权威DNS服务器的操作员，则应考虑采取以下步骤来保护自己免受此攻击：</p><p> Block the outgoing ICMP “port unreachable” messages with iptables or lower the ICMP rate limit on Linux</p><p>使用iptable阻止传出的ICMP“端口不可达”消息或降低Linux上的ICMP速率限制。</p><p> We’d like to thank the researchers for responsibly disclosing this attack and look forward to working with them in the future on efforts to strengthen the DNS.</p><p>我们要感谢研究人员负责任地披露了这一攻击，并期待着在未来与他们合作，努力加强DNS。</p><p>  DNS  Security  DNS Poisoning  Side Channels  Vulnerabilities</p><p>DNS安全DNS毒化侧通道漏洞</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudflare.com/sad-dns-explained/">https://blog.cloudflare.com/sad-dns-explained/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/域名/">#域名</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dns/">#dns</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>