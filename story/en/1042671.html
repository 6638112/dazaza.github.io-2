<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>LINK知道大约80x86处理器（1997） Strange Things LINK Knows about 80x86 Processors (1997)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Strange Things LINK Knows about 80x86 Processors (1997)<br/>LINK知道大约80x86处理器（1997） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:08:51</div><div class="page_narrow text-break page_content"><p>The history of the dominant operating systems designed for Intel’s processors is such that software intended to work at or near the level of the operating system is sometimes developed by programmers who did not write the operating system itself. These programmers mean to add features to the operating system—and it may be that inventive additions by programmers outside Microsoft have contributed much to the stability and success of Microsoft’s operating systems in the consumer market.</p><p>专门为英特尔处理器设计的主流操作系统的历史使得有时要由不编写操作系统本身的程序员来开发旨在在操作系统级别或接近操作系统级别运行的软件。这些程序员意在为操作系统添加功能，并且可能是Microsoft以外的程序员的创造性添加为Microsoft操作系统在消费市场上的稳定性和成功做出了很大贡献。</p><p> Because they work more closely with the processor than some think should ever be necessary in a well-designed operating system, low-level programmers of Intel’s 80x86 processors are occasionally faced with the practical problem of identifying the processor more precisely than simply distinguishing an 80386 from an 80486 from a Pentium. It is also the nature of these programmers to wonder whether they are working from the full story—and suspicions of this sort have not been allayed by the occasional revelation that Intel’s processors support instructions that Intel does not document.</p><p> 由于它们与处理器的协作更加紧密，而不是某些精心设计的操作系统所必需的，因此，英特尔80x86处理器的低级程序员有时会遇到这样的实际问题，即比简单地将80386与其他处理器区分开来更精确地识别处理器。奔腾的80486。这些程序员的本性也是想知道他们是否从整体上进行工作，并且偶尔会被英特尔处理器支持英特尔未记录的指令的事实所掩盖，这种怀疑并没有得到缓解。</p><p> Going at least as far back as the use of an undocumented LOADALL instruction for a RAM disk driver in an early DOS version, Microsoft has been seen to know more about Intel’s processors than could be learned just by studying Intel’s 80x86 manuals. This is only to be expected in programs that Microsoft writes as components of the operating systems that Intel’s processors are most often bought to support, though it does raise the question of whether similar information is as readily available to developers of utility programs that replace or enhance operating system functionality or to other designers of operating systems for Intel’s processors. That unusual knowledge of these processors occasionally finds its way into applications (most notably, development tools such as assemblers, compilers and linkers) is more clearly unsatisfactory, since in the market of these programs, Microsoft is generally just one of many.</p><p> 至少可以追溯到早期DOS版本中对RAM磁盘驱动器使用未记录的LOADALL指令的过程，人们发现Microsoft对Intel处理器的了解远远超过仅研究Intel的80x86手册所学的知识。这只是在Microsoft作为英特尔处理器最常购买的操作系统组件编写的程序中可以预期的，尽管它确实提出了这样的问题：替换或增强的实用程序的开发者是否容易获得类似信息？操作系统功能或英特尔处理器的其他操作系统设计人员。显然，这些处理器的特殊知识偶尔会进入应用程序（最著名的是诸如汇编器，编译器和链接器之类的开发工具）的应用程序，因为在这些程序的市场中，Microsoft通常只是众多程序之一。</p><p> In 1997, I examined two Microsoft programs for unusual knowledge of Intel’s processors, intending to write a paper in two parts. The first showed Microsoft’s 32-bit linker, which was then fairly new, as knowing opcodes for as many as 15 instructions that do not seem to have been documented for everyone. A second part was to look at the operating system kernel from Windows NT 4.0 for some finer points of CPU identification, but it never got beyond a draft. (That said, see CPU Identification by the Windows Kernel, which treads some of the same ground but is up-to-date for Windows Vista.)</p><p> 1997年，我检查了两个Microsoft程序，以了解有关英特尔处理器的不同寻常的知识，打算分两部分撰写论文。第一个显示了Microsoft的32位链接器，当时还相当新，因为它知道多达15条指令的操作码，而这些指令似乎并未为每个人提供。第二部分是从Windows NT 4.0看操作系统内核，以获取CPU识别的更多细节，但是它从来没有超出草稿范围。 （也就是说，请参阅Windows内核的CPU识别，该描述具有相同的基础，但对于Windows Vista是最新的。）</p><p> This article is essentially what was originally published as a Word document titled  Strange Things That Microsoft Knows About Intel’s 80x86 Processors. It describes how a linker that was supplied with different versions of Microsoft Visual C++ knows the opcodes and operand requirements of a dozen or so 80x86 instructions that Intel does not seem to have documented for general knowledge:  LOADALL,  CFLSH, WRECR,  RDECR, SVDC,  RSDC, SVLDT,  RSLDT, SVTS,  RSTS, SMINT,  XBTS, IBTS,  ZALLOC.</p><p> 本文本质上是最初作为Word文档发布的标题为“ Microsoft知道英特尔80x86处理器的奇怪事物”的文档。它描述了随Microsoft Visual C ++的不同版本提供的链接器如何了解英特尔似乎没有为一般常识所记录的十几条80x86指令的操作码和操作数要求：LOADALL，CFLSH，WRECR，RDECR，SVDC， RSDC，SVLDT，RSLDT，SVTS，RSTS，SMINT，XBTS，IBTS，ZALLOC。</p><p> (I am grateful to Robert Collins and Christian Ludloff for their separate information that seven of these, namely  SVDC, RSDC,  SVLDT, RSLDT,  SVTS, RSTS and  SMINT, are not actually Intel’s instructions but are documented as instructions for Cyrix’s 80x86 look-alike processors. I would never have thought to look.)</p><p> （我感谢Robert Collins和Christian Ludloff分别提供的信息，其中七个（即SVDC，RSDC，SVLDT，RSLDT，SVTS，RSTS和SMINT）实际上不是Intel的说明，但已作为Cyrix 80x86外观的说明记录处理器。我永远也不会想到。）</p><p>  In the versions of Microsoft Visual C++ for developing 32-bit applications, the linker has an option to dump the contents of its input files (which may be object files or executables). You turn LINK into a COFF Binary File Dumper by giving LINK the  /dump switch on the command line or, more usually, by running LINK indirectly from a stub program called DUMPBIN.</p><p>  在用于开发32位应用程序的Microsoft Visual C ++版本中，链接器可以选择转储其输入文件（可能是目标文件或可执行文件）的内容。通过在命令行上给LINK / dump开关，或更常见的是，从称为DUMPBIN的存根程序间接运行LINK，可以将LINK转换为COFF二进制文件转储程序。 </p><p> The following table shows the versions of LINK that have been examined for this paper. All come from releases of Microsoft Visual C++, the linker supplied with the Windows 95 DDK being apparently an amendment of the linker from some version of Microsoft Visual C++ 2.0. [1]</p><p>下表显示了本文已检查的LINK版本。所有这些都来自Microsoft Visual C ++的发行版，Windows 95 DDK附带的链接器显然是对Microsoft Visual C ++ 2.0某些版本的链接器的修正。 [1]</p><p>  Among the features offered for the file dump is a simple disassembly of code sections. This option is invoked by also giving the linker the /disasm switch. Microsoft’s linker can recognise files developed for many processors—indeed, for a few more than are listed in relevant Microsoft documentation—and can disassemble code for all but one of them. [2]</p><p>  为文件转储提供的功能中包括对代码段的简单反汇编。通过还给链接器/ disasm开关来调用此选项。微软的链接器可以识别为许多处理器开发的文件（实际上，比相关的Microsoft文档中列出的文件少一些），并且可以反汇编其中一个文件的代码。 [2]</p><p>  The R10000 machine is a relatively recent addition to the list of supported machines: it is not recognised by LINK version 2.60.</p><p>  R10000机器是受支持机器列表中相对较新的一种：LINK版本2.60无法识别它。</p><p>  Over the four versions studied, the disassembler for Intel’s processors knows of 15 instructions that do not appear in opcode maps supplied with Intel’s widely available manuals. The following table shows these unusual opcodes and the corresponding instructions, using placeholders to represent the operands that LINK includes with the instruction mnemonic when disassembling.</p><p>  在研究的四个版本中，用于英特尔处理器的反汇编程序知道15条指令，这些指令未出现在英特尔广泛提供的手册随附的操作码图中。下表显示了这些异常的操作码和相应的指令，在分解时使用占位符表示LINK包含在指令助记符中的操作数。</p><p>  Placeholders for operands are adapted from the convention used in Intel’s manuals. Thus,  reg16 and  reg32 stand for 16-bit and 32-bit general registers, and  sreg stands for a segment register. The  r/m16 and r/m32 combinations may be filled by a register or by a memory reference. The  mem80 and mem256 placeholders are for references to memory only, specifically to ten-byte and 32-byte variables. The esi16 and  esi32 placeholders are for references to memory but with  DS:SI or  DS:ESI as the implied address.</p><p>  操作数的占位符改编自英特尔手册中使用的约定。因此，reg16和reg32代表16位和32位通用寄存器，而sreg代表段寄存器。 r / m16和r / m32组合可以由寄存器或存储器引用填充。 mem80和mem256占位符仅用于引用内存，尤其是十字节和32字节变量。 esi16和esi32占位符用于引用内存，但使用DS：SI或DS：ESI作为隐含地址。</p><p> Strictly speaking, recognition of opcodes by LINK does not imply that the corresponding instructions ever existed for any of Intel’s processors. It could be, for instance, that the programmer who prepared LINK’s disassembly tables worked from an opcode map that reflected only some intention at Intel. On the other hand, Microsoft’s use of an opcode map with more detail than the one Intel makes available to most programmers is clearly no one-shot: different versions of the linker use disassembly tables that support different selections from the preceding table and which do not match up easily with published opcode maps for successive processors.</p><p> 严格来说，LINK对操作码的识别并不意味着相应的指令曾经存在于任何英特尔处理器上。例如，准备LINK的反汇编表的程序员可能是通过操作码映射工作的，该操作码映射仅反映了英特尔的一些意图。另一方面，Microsoft对操作码映射的使用比Intel向大多数程序员提供的操作码映射更详细，这显然不是一次性的：不同版本的链接器使用反汇编表，这些反汇编表支持与上表不同的选择，并且不支持与已发布的用于后续处理器的操作码映射轻松匹配。</p><p> Consider that LINK version 2.60 knows of all the documented Pentium instructions. It does not know of the  FCOMI, FCOMIP,  FUCOMI and  FUCOMIP instructions that Intel documents as being introduced for the Pentium Pro, nor of the  RDPMC instruction that Intel documents as being available on the Pentium Pro and the Pentium with MMX technology. Yet this version of LINK does recognise opcodes for the CMOV cc and FCMOV cc instructions that Intel documents as having been introduced for the Pentium Pro. [3]</p><p> 考虑到LINK版本2.60知道所有已记录的奔腾指令。它不知道英特尔为奔腾Pro引入的FCOMI，FCOMIP，FUCOMI和FUCOMIP指令，也不知道英特尔向Pentium Pro和具有MMX技术的奔腾提供的RDPMC指令。但是，此版本的LINK确实可以识别Intel记载为Pentium Pro引入的CMOV cc和FCMOV cc指令的操作码。 [3] </p><p> It is possible that the disassembly tables in LINK version 2.60 were prepared for the Pentium Pro, but some instructions were omitted by oversight. It may be that the conditional move instructions were designed first among new instructions for the Pentium Pro and were merely anticipated when the disassembly tables were prepared. Finally, it could be that the conditional move instructions existed, undocumented, on at least some Pentium processors and that this was known to whoever prepared the disassembly tables for LINK version 2.60.</p><p>LINK版本2.60中的拆卸表可能是为Pentium Pro准备的，但是一些说明被忽略了。有条件移动指令可能是在Pentium Pro的新指令中首先设计的，只是在准备拆卸表时才预料到的。最后，可能是条件移动指令至少在某些奔腾处理器上存在，没有记录，而对于为LINK版本2.60准备拆卸表的任何人都知道。</p><p> LINK version 3.00 knows of all instructions that are documented for the Pentium Pro, but not of any MMX instructions. It is also the only version studied that recognises opcodes for the seven instructions  SVDC, RSDC,  SVLDT, RSLDT,  SVTS, RSTS and  SMINT. Note that disassembly of the opcode 0Fh 7Eh as  SMINT conflicts with Intel’s (presumably later) assignment of that opcode as a MOVD instruction for reading a dword from an MMX register. LINK version 3.10, which introduces support for MMX instructions, drops all seven of these instructions, which we may surmise exist only on the Pentium Pro, if at all.</p><p> LINK版本3.00知道有关Pentium Pro的所有说明，但不了解任何MMX说明。它也是研究的唯一可识别七种指令SVDC，RSDC，SVLDT，RSLDT，SVTS，RSTS和SMINT的操作码的版本。请注意，作为SMINT的操作码0Fh 7Eh的反汇编与Intel（可能稍后）将该操作码分配为MOVD指令以从MMX寄存器读取dword冲突。引入了对MMX指令的支持的LINK版本3.10删除了所有这7条指令，我们推测这些指令只有在Pentium Pro上才存在。</p><p> Operands that LINK gives for the instructions  SVDC and  RSDC are consistent with an interpretation of the mnemonics as suggesting that the instructions save and restore the internal descriptor cache that corresponds to a given segment register. The descriptor cache would presumably consist of a dword each for the base and limit, and a word of access rights and other flags. A similar interpretation of  SVLDT, RSLDT,  SVTS and RSTS as operating on the internal descriptors for the current LDT and TSS would have those instructions also access ten bytes of memory.</p><p> LINK为指令SVDC和RSDC给出的操作数与对助记符的解释一致，表明该指令保存和恢复了与给定段寄存器相对应的内部描述符缓存。描述符高速缓存大概由一个双字组成，每个双字分别代表基数和限制，以及访问权限和其他标志的字。 SVLDT，RSLDT，SVTS和RSTS对当前LDT和TSS的内部描述符进行的类似解释将使这些指令也访问十个字节的内存。</p><p>  The correctness of LINK’s knowledge of operands should not be taken for granted, however. LINK makes rather too many errors even when disassembling documented instructions:</p><p>  但是，LINK的操作数知识的正确性不应被视为理所当然。甚至在拆卸文档说明时，LINK也会产生太多错误：</p><p> Given a  DEC instruction that operates on a byte, LINK disassembles it as decrementing a dword (assuming here that the disassembly is of 32-bit code and no prefix overrides the operand size). In the language of Intel’s opcode maps, LINK disassembles  DEC Eb as  DEC Ev. This error is fixed in LINK versions 3.10 and 4.20. [4]</p><p> 给定一个对字节进行操作的DEC指令，LINK会将其作为递减的dword进行反汇编（假设此处的反汇编是32位代码，并且没有前缀覆盖操作数的大小）。在Intel操作码映射的语言中，LINK将DEC Eb分解为DEC Ev。 LINK版本3.10和4.20中修复了此错误。 [4]</p><p>  For a practical example of ambiguity caused by this error, consider that LINK’s disassembly of an instruction as “dec eax” may truly mean  DEC EAX but might also mean  DEC AL. Resolving this ambiguity typically requires reference to an opcode map or list of instruction encodings.</p><p>  对于此错误引起的歧义的实际示例，请考虑LINK将指令反汇编为“ dec eax”可能确实意味着DEC EAX，但也可能意味着DEC AL。解决这种歧义性通常需要引用操作码映射或指令编码列表。</p><p>  For all the instructions that move to and from control, debug and test registers, LINK disassembles the operands in the wrong order. This error is fixed in LINK version 4.20, but not for the instructions that operate on test registers (which exist only on 80386 and 80486 processors).</p><p>  对于所有往返于控制，调试和测试寄存器的指令，LINK会以错误的顺序反汇编操作数。此错误已在LINK版本4.20中修复，但不适用于测试寄存器（仅存在于80386和80486处理器上）上的指令。 </p><p>  Given the long form of  IMUL instruction with three word or dword operands, LINK’s disassembly shows the last operand (that is, the immediate data) as a byte. In the language of Intel’s opcode maps, LINK lists  IMUL Gv,Ev,Iv as  IMUL Gv,Ev,Ib.</p><p>鉴于IMUL指令的长格式包含三个字或双字操作数，LINK的反汇编将最后一个操作数（即立即数据）显示为一个字节。在Intel操作码映射的语言中，LINK将IMUL Gv，Ev，Iv列为IMUL Gv，Ev，Ib。</p><p>  For a practical example of ambiguity caused by this error, consider that LINK’s disassembly of an instruction as “imul eax,eax,78h” may truly be a multiplication by 12345678h (or by any other dword whose low byte is 78h). The correct immediate operand is shown among the opcode bytes that precede the instruction mnemonic in the disassembly.</p><p>  对于由该错误引起的歧义的一个实际示例，请考虑LINK将指令反汇编为“ imul eax，eax，78h”可能确实是12345678h（或任何其他低字节为78h的dword）的乘法。在反汇编中，在指令助记符之前的操作码字节中显示了正确的立即操作数。</p><p>  LINK recognises the  FCOMI,  FUCOMI,  FCOMIP and  FUCOMIP instructions as taking only ST,ST(0) as its operands. Opcodes that indicate use of any stack register except  ST(0) as the second operand are not accepted as valid.</p><p>  LINK将FCOMI，FUCOMI，FCOMIP和FUCOMIP指令识别为仅以ST，ST（0）作为其操作数。指示使用除ST（0）以外的任何堆栈寄存器作为第二操作数的操作码均无效。</p><p>  For the  MOVD and   MOVQ instructions, LINK disassembles the operands in the wrong order. For the  MOVD instruction there is an additional problem. Specifically, the operand that Intel documents as a general register or memory address is instead interpreted as an MMX register or memory address. In the language of Intel’s opcode maps, LINK disassembles  MOVD Pd,Ed as  MOVD Qd,Pd, and similarly in the other direction.</p><p>  对于MOVD和MOVQ指令，LINK以错误的顺序反汇编操作数。对于MOVD指令，还有另一个问题。具体来说，英特尔记录为通用寄存器或内存地址的操作数将被解释为MMX寄存器或内存地址。在Intel操作码映射的语言中，LINK将MOVD Pd，Ed分解为MOVD Qd，Pd，并且在另一个方向上也是如此。</p><p>  Given a packed shift instruction with the count as immediate data, LINK allows the destination operand to be an MMX register or memory address, though Intel documents the instruction as allowing only an MMX register as the destination. In the language of Intel’s opcode maps, LINK disassembles the Group A instructions as having operands Qq,Ib instead of Pq,Ib.</p><p>  给定一个以计数作为立即数据的打包移位指令，尽管英特尔将指令记录为仅允许MMX寄存器作为目标，但LINK允许目标操作数为MMX寄存器或内存地址。在Intel操作码映射的语言中，LINK将A组指令反汇编为操作数Qq，Ib而不是Pq，Ib。</p><p>  LINK disassembles the opcode 82h as a  MOV of immediate data into al. In doing this, LINK follows an error that appears in some opcode maps from Intel. [5] The opcode 82h in fact denotes an arithmetical or logical instruction from Group 1 ( ADD,  OR,  ADC,  SBB,  AND,  SUB,  XOR or  CMP, depending on bits in the second byte). The operands are an 8-bit register or byte of memory and a byte of immediate data. The opcode differs from 80h only in requiring sign-extension of the immediate data—but sign-extension from a byte to a byte is meaningless. The opcode 82h is redundant and rarely appears in program code.</p><p>  LINK将操作码82h作为即时数据的MOV分解为al。在执行此操作时，LINK会出现一个错误，该错误出现在Intel的某些操作码图中。 [5]实际上，操作码82h表示来自第1组（ADD，OR，ADC，SBB，AND，SUB，XOR或CMP，取决于第二个字节中的位）的算术或逻辑指令。操作数是8位寄存器或内存字节，以及立即数字节。操作码与80h的区别仅在于要求立即数进行符号扩展，但是从一个字节到一个字节的符号扩展是没有意义的。操作码82h是冗余的，很少出现在程序代码中。</p><p> There are also instructions that LINK decodes correctly but represents inappropriately (not that the difference is anything but a fine point). Examples that involve some significant loss of information from the disassembly are:</p><p> 还有一些说明，LINK可以正确解码，但表示不正确（并非区别只不过是一点）。涉及从分解中丢失大量信息的示例是： </p><p> Given an instruction that forms an immediate operand by sign-extending from a byte in the opcode sequence, LINK shows the immediate data as a byte and not as the full operand after sign-extension.</p><p>给定一条指令，该指令通过从操作码序列中的字节进行符号扩展来形成立即操作数，则LINK将立即数据显示为字节，而不是符号扩展后的完整操作数。</p><p>  For a practical example of ambiguity caused by this misrepresentation, consider that LINK’s disassembly of an instruction as “cmp eax,0ffh” may truly mean  CMP EAX,000000FFh but might also mean  CMP EAX,0FFFFFFFFh. Resolving this ambiguity typically requires reference to an opcode map or list of instruction encodings, or sufficient understanding of general principles of encoding to infer sign-extension from the instruction’s length.</p><p>  对于由这种错误表示引起的歧义的实际示例，请考虑LINK将指令反汇编为“ cmp eax，0ffh”可能确实意味着CMP EAX，000000FFh，但也可能意味着CMP EAX，0FFFFFFFFh。要解决这种歧义，通常需要参考操作码图或指令编码列表，或充分了解编码的一般原理，以便根据指令的长度推断符号扩展。</p><p>  For instructions that work with memory variables larger than a dword, LINK shows the memory references as dword pointers.</p><p>  对于使用大于dword的内存变量的指令，LINK将内存引用显示为dword指针。</p><p>  For a practical example of ambiguity caused by this misrepresentation, consider that LINK’s disassembly of an instruction as “fld dword ptr [eax]” may denote an  FLD of a single-real (32 bits), double-real (64h bits) or extended-real (80 bits). Resolving this ambiguity typically requires reference to an opcode map or list of instruction encodings.</p><p>  对于由这种错误表示引起的歧义的实际示例，请考虑将LINK的指令反汇编为“ fld dword ptr [eax]”可能表示单实数（32位），双实数（64h位）或扩展的FLD。 -真实（80位）。解决这种歧义性通常需要引用操作码映射或指令编码列表。</p><p> Of the undocumented instructions recognised by LINK, the 80386 LOADALL (opcode 0Fh 07h) is certainly disassembled with the wrong operand. For the purpose of listing operands, LINK treats the 80386 LOADALL the same as it treats LODSW and  LODSD, so that the operand is shown to be a word or dword at  DS:SI or  DS:ESI (depending on the operand and address sizes). The reality is that the 80386  LOADALL takes its operand from  ES:DI or  ES:EDI (depending on the address size) and works with a 0127h-byte region of memory rather than a word or dword. [6] Curiously, Microsoft has better information in another of its programs: the WDEB386.EXE debugger that Microsoft includes with various Windows SDKs and DDKs shows the 80386 LOADALL as taking the byte at ES:DI or  ES:EDI as its operand.</p><p> 在LINK识别的未记录指令中，80386 LOADALL（操作码0Fh 07h）肯定是用错误的操作数反汇编的。为了列出操作数，LINK对待80386 LOADALL的方式与对待LODSW和LODSD的方式相同，因此在DS：SI或DS：ESI上，该操作数被显示为一个字或双字（取决于操作数和地址大小） 。实际情况是80386 LOADALL从ES：DI或ES：EDI（取决于地址大小）获取其操作数，并使用0127h字节的内存区域而不是字或dword。 [6]奇怪的是，Microsoft在其另一个程序中拥有更好的信息：Microsoft随各种Windows SDK和DDK一起提供的WDEB386.EXE调试器显示80386 LOADALL将ES：DI或ES：EDI的字节作为其操作数。</p><p>  From the perspective of Software Analysis as a technique of software development or as a future academic discipline, it is very interesting that LINK’s opcode tables have so many errors, even for instructions that are well-known. Indeed, this article’s primary motivation was not to list some undocumented CPU instructions but to demonstrate the feasibility and practical value of having a second person check a first person’s programming work for errors.</p><p>  从软件分析作为一种软件开发技术或一门未来的学术学科的角度来看，很有趣的是LINK的操作码表有这么多错误，即使是众所周知的指令也是如此。确实，本文的主要动机不是要列出一些未记录的CPU指令，而是要证明让第二人检查第一人的编程工作是否有错误是可行和实用的。</p><p> Successive versions of the program have corrected some errors but not others, which suggests that the program’s manufacturer has a will to have the correct tables but a difficulty in detecting the errors. Moreover, with successive upgrades to support instructions for new processors, new errors have been introduced. The program’s opcode tables are presumably generated through macros. Although these may be convenient for development, they may also obscure errors from someone who reviews the program’s source code. The manufacturer could have detected more errors by having someone review the relevant code and data as actually generated in the program. The article demonstrates that this can be done even by someone external to the manufacturer without already knowing the format of those tables, still less without the source code. It may even be that such a process of review is commercially feasible.</p><p> 该程序的后续版本已纠正了某些错误，但未纠正其他错误，这表明该程序的制造商有意愿拥有正确的表格，但很难发现错误。此外，随着对支持新处理器指令的不断升级，引入了新的错误。该程序的操作码表大概是通过宏生成的。尽管这些代码可能便于开发，但它们也可能掩盖了查看程序源代码的人的错误。通过让某人查看程序中实际生成的相关代码和数据，制造商可以检测到更多的错误。本文证明，即使制造商外部的人也可以做到这一点，而无需知道那些表的格式，而没有源代码则更少。这种审查过程甚至可能在商业上是可行的。 </p><p> [1] See the README.TXT file in the MSVC20 directory for a hint that none of the linkers from the several Microsoft Visual C++ 4.x releases can be relied on to link object files correctly if building Virtual Device Drivers (VxDs), even though documentation in these products continues to describe a  /vxd switch.</p><p>[1]请参阅MSVC20目录中的README.TXT文件，以获取有关以下提示的信息：即使构建虚拟设备驱动程序（VxD），也无法依靠多个Microsoft Visual C ++ 4.x发行版中的链接器正确链接目标文件。尽管这些产品中的文档继续描述/ vxd开关。</p><p>  [2] Machine types are documented in Microsoft’s  Portable Executable and Common Object File Format (PE/COFF) Specification 4.1, which is on the MSDN Library CD, and as symbols beginning with  IMAGE_FILE_MACHINE in the WINNT.H header file supplied with both Microsoft Visual C++ and the Win32 SDK.</p><p>  [2]机器类型记录在MSDN Library CD上的Microsoft便携式可执行和公共对象文件格式（PE / COFF）规范4.1中，并且在Microsoft Visual Visual随附的WINNT.H头文件中以IMAGE_FILE_MACHINE开头的符号表示。 C ++和Win32 SDK。</p><p>  [3] For information about instruction compatibility, see the  Intel Architecture Software Developer’s Manual, Volume 2: Instruction Set Reference for the Pentium Pro, Order Number 243191, and available via anonymous FTP at download.intel.com in the directory design/pro/manuals.</p><p>  [3]有关指令兼容性的信息，请参阅《 Intel体系结构软件开发人员手册，第2卷：奔腾Pro的指令集参考》，订单号243191，可通过匿名FTP在download.intel.com上的design / pro /目录中获得。手册。</p><p>  [4] A Microsoft Knowledge Base (MSKB) article that describes these errors and notes any fixes is something I should be happy to cite, but I could not find one, for instance by looking among articles listed as containing “DUMPBIN” in the Knowledge Base collections on the MSDN Library CD (January 1997), the Microsoft Visual C++ 4.2 CD and the TechNet CD (February 1997). Analysts of Microsoft’s bug-reporting practices may care to consider that no matter how many articles in the MSKB describe bugs, there is no reason to suppose that the MSKB lists even a tiny proportion of bugs known to Microsoft.</p><p>  [4]我应该很高兴地引用Microsoft知识库（MSKB）一篇文章，其中描述了这些错误并指出了所有修复程序，但是我找不到它，例如，通过在知识中列为包含“ DUMPBIN”的文章中查找MSDN Library CD（1997年1月），Microsoft Visual C ++ 4.2 CD和TechNet CD（1997年2月）上的基础集合。微软错误报告实践的分析师可能会考虑，无论MSKB中有多少篇文章描述了错误，都没有理由假设MSKB仅列出了Microsoft已知的一小部分错误。</p><p>  [5] See for instance the opcode maps presented as Appendix A in Intel’s  386 DX Microprocessor Programmer’s Reference Manual (Order Number 230985) or, more recently and available on-line from www.intel.com, the  Pentium Pro Family Developer’s Manual, Volume 3: Operating System Writer’s Guide (Order Number 242692). The latter at least has a footnote to mark opcode 82h as reserved.</p><p>  [5]例如，请参阅《英特尔386 DX微处理器程序员参考手册》（订单号230985）中附录A所示的操作码映射，或者最近从www.intel.com上获得的《奔腾Pro系列开发人员手册》第5卷， 3：操作系统作家指南（订单号242692）。后者至少具有脚注以将操作码82h标记为保留。</p><p>  [6] This instruction seems to have been brought to wide attention by Robert Collins in an article published in  Tech Specialist, October, 1991, and available on-line at www.x86.org (which is probably where most interested readers will find it for the first time). Before publication of that article, the instruction was certainly known to BIOS developers, the most notable use being for emulation of the 80286  LOADALL on 80386 machines.</p><p>  [6] Robert Collins在1991年10月发表于Tech Specialist的一篇文章中似乎已经引起了人们的广泛关注，该文章可在www.x86.org上在线获得（可能是最感兴趣的读者可以从中找到它的地方）首次）。在该文章发表之前，BIOS开发人员当然知道该指令，最值得注意的用途是在80386计算机上模拟80286 LOADALL。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.geoffchappell.com/notes/windows/archive/linkcpu.htm">https://www.geoffchappell.com/notes/windows/archive/linkcpu.htm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/link/">#link</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/strange/">#strange</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>