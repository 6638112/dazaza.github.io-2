<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#寄存器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#寄存器</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061815.html">8086的本地寄存器分配器 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/alexfru/regal86">Local Register Allocator for 8086</a><span>(github.com)</span></div><span class="my_story_list_date">2021-5-11 5:38</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1061815.html"><img src="http://img2.diglog.com/img/2021/5/thumb_534cddea77c539bdfb1ba02877288c2c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是贪婪自下而上的本地寄存器分配器的实现，英特尔8086 CPU。它可以用作简单编译器的一部分。特别是，它可以用于C编译器，其INT为16位，CHAR为8位。
 为了使事物有趣和交互式，它具有从代表具有16位整数ALU操作，常量和内存负载和存储的表达式的树木生成8086个汇编代码（可编译为DOS .com程序）的代码......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/register/">#register</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061537.html">我如何建造世界上第一个超声波扫描仪 </a></div><div class="item_title_en"><a target="_blank" href="https://www.alextoussaint.com/2021-04-28_How-I-built-an-ultrasonic-3d-scanner.html">How I built the world's first 3D ultrasonic scanner</a><span>(www.alextoussaint.com)</span></div><span class="my_story_list_date">2021-5-10 7:44</span><div class="my_story_list_item_desc">这里＆＃39;我如何在空中工作的世界中建立第一个超声波3D扫描仪，使用搁板的组件（＆lt; $ 100）。 1
 四年前，我15岁，想要建立一个自主的无人机来提供焦炭罐头。为此，我需要一个准确的3D地图，我的无人机周围环境避免墙壁和物体。 Lidars太昂贵了，猛烈2点＆＃39; T良好。有超声波传感器，但它们只能在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/建造/">#建造</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/built/">#built</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061386.html">在Cranelift中的代码生成底漆 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.benj.me/2021/02/17/cranelift-codegen-primer/">A primer on code generation in Cranelift</a><span>(blog.benj.me)</span></div><span class="my_story_list_date">2021-5-8 22:58</span><div class="my_story_list_item_desc">Cranelift是以锈迹编程语言编写的代码生成器，其旨在成为快速代码生成器，其输出以合理速度运行的机器代码。
 Cranelift编译模型在一个逐个中组成，持有有关外部实体的额外信息，如外部函数，内存地址等。此模型允许同时和并行编译各个函数，支持快速编译的目标。它的设计方法可以在Firefox中允许在Firefox......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码生成/">#代码生成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1061030.html">ARM与RISC-V矢量扩展 </a></div><div class="item_title_en"><a target="_blank" href="https://erik-engheim.medium.com/arm-vs-risc-v-vector-extensions-992f201f402f">ARM vs. RISC-V Vector Extensions</a><span>(erik-engheim.medium.com)</span></div><span class="my_story_list_date">2021-5-6 23:40</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1061030.html"><img src="http://img2.diglog.com/img/2021/5/thumb_0988df8556f24d1bffdfba3bf3d70189.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">带有矢量指令的微处理器将成为未来的大事。为什么？因为自动驾驶，语音识别，图像识别都基于机器学习和机器学习都是关于矩阵和向量。
 但这不是唯一的原因。自从我们半正式宣布的摩尔法律结束以来，我们一直在墙上敲打着墙上的脑袋，试图为多年来一直进行更多的表现。在微处理器设计的黄金时期，我们每年可以简单地加倍CPU的时钟频率，每......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vector/">#vector</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1059087.html">解剖Apple M1 GPU，第III部分 </a></div><div class="item_title_en"><a target="_blank" href="https://rosenzweig.io/blog/asahi-gpu-part-3.html">Dissecting the Apple M1 GPU, Part III</a><span>(rosenzweig.io)</span></div><span class="my_story_list_date">2021-4-19 22:12</span><div class="my_story_list_item_desc">在1月份调查Apple M1 GPU的几个星期后，我能够使用自己的开源代码绘制三角形。虽然我开始解剖指令集，但指定为机器代码的着色器。真正的图形驱动程序需要从高级着色语言（GLSL或金属）的编译器到原生二进制文件。我们对M1 GPU指令集的理解已在过去几个月中提出。上周，我开始编写一个针对Apple GPU的免费和开......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1053544.html">Cranelift，第3部分：注册分配中的正确性 </a></div><div class="item_title_en"><a target="_blank" href="https://cfallin.org/blog/2021/03/15/cranelift-isel-3/">Cranelift, Part 3: Correctness in Register Allocation</a><span>(cfallin.org)</span></div><span class="my_story_list_date">2021-3-20 9:15</span><div class="my_story_list_item_desc">这篇文章是关于Cranelift的三部分系列中的最后一个。在第一篇文章，Icovered整体背景和指令选择问题中;在第二个帖子中，通过仔细的algorithmicdesign，它深入潜入编译器性能。
 在这篇文章中，我想潜入我们如何工程师和工作的核查正确性，这也许是编译项目最重要的方面。编译器通常是一个复杂的野兽：要......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/注册/">#注册</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/part/">#part</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042219.html">Apple M1上存在未记录的arm64 ISA扩展 </a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/dougallj/7a75a3be1ec69ca550e7c36dc75e0d6f">Undocumented arm64 ISA extension present on the Apple M1</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-12-29 1:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042219.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">＃在M1上的行为。 其中一些可能是错误的-我还没有扭转  ＃使名称冲突更加混乱，但这并不是一个不好的地方  ＃将x，y和z描述为寄存器组，其中64字节的每一行是一个  ＃到61，以及第61位中的1位标志（充当0x40字节加载/存储  ＃amx2（z），但是8和9的结果分别在amx0和amx1（x / y）中，并且似乎......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/m1/">#m1</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/arm64/">#arm64</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030827.html">调试器工作原理：获取和设置x86寄存器</a></div><div class="item_title_en"><a target="_blank" href="https://www.moritz.systems/blog/how-debuggers-work-getting-and-setting-x86-registers-part-1/">How Debuggers Work: Getting and Setting x86 Registers</a><span>(www.moritz.systems)</span></div><span class="my_story_list_date">2020-10-24 7:31</span><div class="my_story_list_item_desc">在本文中，我将简要描述用于在32位和64位x86CPU上转储和恢复不同类型寄存器的方法。第一部分将重点介绍通用寄存器、调试寄存器和浮点寄存器，直至SSE扩展提供的XMM寄存器。我将解释如何通过ptrace(2)接口获取它们的值。
Ptrace(2)API通常在所有现代BSD系统和Linux中使用，因为它们都是从4.3......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/work/">#work</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028971.html">LDM：我最喜欢的手臂指令</a></div><div class="item_title_en"><a target="_blank" href="https://keleshev.com/ldm-my-favorite-arm-instruction/">LDM: My Favorite ARM Instruction</a><span>(keleshev.com)</span></div><span class="my_story_list_date">2020-10-15 22:34</span><div class="my_story_list_item_desc">☰Vladimir Keleshev·2020-10-13LDM-或load Multiple-是我最喜欢的ARM指令集汇编指令。原因如下。
这里，它需要一个基址寄存器(在本例中为R4)和一个寄存器集(在本例中为{R0，R1，R2，R3})。它将来自基址寄存器中的地址的连续字加载到集合中的寄存器中。在此示例中，可以使......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/手臂/">#手臂</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/favorite/">#favorite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024868.html">Z80，8位数字处理器</a></div><div class="item_title_en"><a target="_blank" href="http://www.andreadrian.de/oldcpu/Z80_number_cruncher.html">Z80, the 8-bit Number Cruncher</a><span>(www.andreadrian.de)</span></div><span class="my_story_list_date">2020-9-19 0:7</span><div class="my_story_list_item_desc">作者：Andre Adrian版本：2011年6月4日Z80是Zilog在1976年推出的8位CPU。它就像英特尔8085(1976)，一种改进的英特尔8080设计。Intel8080(1974)是改进后的Intel8008。8008(1972)是DATAPOINT 2200CPU(1971)的MOS版本，它由100......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/数字/">#数字</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bit/">#bit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023538.html">我的MMIO抽象历险记</a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/Measter/2108508ba25ebe3978a6c10a1e01b9ad">My Adventures in MMIO Abstraction</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-9-12 15:48</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023538.html"><img src="http://img2.diglog.com/img/2020/9/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">几年前，我在Reddit上看到一个简单的流氓游戏，叫做coreRR。它非常简单；关卡只是一个有两面墙的盒子，只有一个敌人类型，有基本的人工智能，没有健康或性格属性，唯一的目标是看看你在死之前能走多远。由于没有更好的事情可做，我想为Arduino Nano编写一个端口会是一个有趣的小项目。所需的唯一输入是四个移动键，显......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/抽象/">#抽象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mmio/">#mmio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016857.html">用RISC-V矢量指令编程</a></div><div class="item_title_en"><a target="_blank" href="https://gms.tf/riscv-vector.html">Programming with RISC-V Vector Instructions</a><span>(gms.tf)</span></div><span class="my_story_list_date">2020-8-7 18:48</span><div class="my_story_list_item_desc">开放RISC-V指令集体系结构(ISA)中最有趣的部分可能是矢量扩展(RISC-V&34；V&34；)。与一般的单指令多数据(SIMD)指令集相比，RISC-V矢量指令是矢量长度不可知的(VLA)。因此，RISC-V&34；V&34；CPU可以灵活地选择矢量寄存器大小，而RISC-V&34；V&34；
本文比较了两种......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/矢量/">#矢量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012944.html">利用硬件虚拟化(KVM)加速QEMU上的IOS</a></div><div class="item_title_en"><a target="_blank" href="https://alephsecurity.com/2020/07/19/xnu-qemu-kvm/">Accelerating iOS on QEMU with hardware virtualization (KVM)</a><span>(alephsecurity.com)</span></div><span class="my_story_list_date">2020-7-20 7:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012944.html"><img src="http://img.diglog.com/img/2020/7/thumb_037bafef14a7df5150548b800b102b52.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">作者Lev Aronsky(@levaronsky)*虽然QEMU一开始是一个仿真硬件的平台(特别是主机CPU不支持的架构)，但后来的版本获得了使用硬件辅助虚拟化执行代码的能力。这可以带来巨大的性能优势，因为大多数执行的操作码都是由CPU直接执行的，而不是被翻译成许多模拟原始操作码行为的本地操作码。
使用虚拟化需要支......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟化/">#虚拟化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012746.html">Intel8086处理器的寄存器：从芯片到晶体管</a></div><div class="item_title_en"><a target="_blank" href="http://www.righto.com/2020/07/the-intel-8086-processors-registers.html">The Intel 8086 processor's registers: from chip to transistors</a><span>(www.righto.com)</span></div><span class="my_story_list_date">2020-7-19 0:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012746.html"><img src="http://img.diglog.com/img/2020/7/thumb_00186c773e2a8556ddd2c2d1714ed65a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">英特尔8086微处理器是有史以来最有影响力的芯片之一；它导致了今天主导台式机和服务器计算的x86架构。我一直在根据芯片照片对8086进行逆向工程，在这篇文章中，我讨论了它的寄存器文件是如何实现的。
8086芯片，显示寄存器存储。上部寄存器由总线接口单元用于存储器访问，而通用下部寄存器由执行单元使用。指令缓冲器是预取指......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/芯片/">#芯片</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/处理器/">#处理器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/registers/">#registers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008256.html">制作我们自己的可执行打包程序，第13部分，线程本地存储</a></div><div class="item_title_en"><a target="_blank" href="https://fasterthanli.me/blog/2020/thread-local-storage/">Making our own executable packer, part 13, Thread-local storage</a><span>(fasterthanli.me)</span></div><span class="my_story_list_date">2020-6-26 2:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1008256.html"><img src="http://img.diglog.com/img/2020/6/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">欢迎回来，感谢你加入我们的阅读笔记…。关于ELF文件的系列文章的第13部分介绍了它们是什么，它们可以做什么，动态链接器对它们做了什么，以及我们自己如何做到这一点。
到目前为止，我一直很成功地避免谈论TLS(不，不是那个)，但我想我们已经到了不能再拖延的地步了，所以。
我们从艰难地阅读文件的经历中知道，作为一个用户端应......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/执行/">#执行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/local/">#local</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007735.html">硬件浮点</a></div><div class="item_title_en"><a target="_blank" href="https://blog.stephenmarz.com/2020/06/14/hardware-floating-point/">Hardware Floating Point</a><span>(blog.stephenmarz.com)</span></div><span class="my_story_list_date">2020-6-23 7:31</span><div class="my_story_list_item_desc">本文是更大的教程“OS历险记：使用Rust制作RISC-V操作系统”中的一篇文章。
到目前为止，我们只使用整数指令。但是，既然我们希望支持用户进程，就必须能够支持硬件浮点单元(FPU)。在RISC-V中，这相当简单，但如果我们不小心，可能会导致一些麻烦。
首先，必须通过mstatus寄存器(更具体地说是FS位(位14......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/floating/">#floating</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003744.html">AVX-512掩码寄存器，再一次</a></div><div class="item_title_en"><a target="_blank" href="https://travisdowns.github.io/blog/2020/05/26/kreg2.html">AVX-512 Mask Registers, Again</a><span>(travisdowns.github.io)</span></div><span class="my_story_list_date">2020-5-26 10:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1003744.html"><img src="http://img.diglog.com/img/2020/5/thumb_a12c356d5b84ff0b094142e86074d346.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">几个帖子之前，我们查看了AVX-512面具注册器。具体地说，八个建筑一下的物理语域的数量，以及其他一些行为，如归零习语。最近，一张SKX的高分辨率冲模出现了，我想通过肉眼检查来核实我们的登记数量会很酷。当我试图做到这一点时，我发现了另一件有趣的事情，而不是…。
我们对这张Fritzchens Fritz最近在Flic......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/掩码/">#掩码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mask/">#mask</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003637.html">将MUSL移植到PS4的历险</a></div><div class="item_title_en"><a target="_blank" href="https://dayzerosec.com/posts/adventures-of-porting-musl-to-ps4/">Adventures of Porting MUSL to PS4</a><span>(dayzerosec.com)</span></div><span class="my_story_list_date">2020-5-25 14:29</span><div class="my_story_list_item_desc">在过去一年左右的时间里，我一直在与OpenOrbis团队合作开发一个工具链，通过使用官方SDK材料在不违反版权法的情况下为PS4构建自制软件。这并不是一项容易的任务，构建在没有官方工具的情况下在系统上运行的自制软件带来了许多挑战。这些挑战中的关键是：
Sony使用的libc库不遵守其他libc库遵循的标准。
虽然处理......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/移植/">#移植</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/porting/">#porting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003064.html">装配视角</a></div><div class="item_title_en"><a target="_blank" href="https://blog.stephenmarz.com/2020/05/20/assemblys-perspective/">Assembly’s Perspective</a><span>(blog.stephenmarz.com)</span></div><span class="my_story_list_date">2020-5-21 9:35</span><div class="my_story_list_item_desc">如果您没有生活在与冠状病毒隔离的岩石下，您可能听说过C成为汇编语言2.0，或者听说过新的汇编语言，或者听说过这个。嗯，这篇文章将讨论C语言和汇编语言是如何一起跳舞的-探戈？华尔兹？谁知道呢？
我通常写关于操作系统的文章，但我不能完全用一种语言编写操作系统。这可能是可以做到的，但对我来说，我纯粹是用汇编语言编写引导加载......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/装配/">#装配</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/assembly/">#assembly</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>