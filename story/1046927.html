<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>循环依赖是邪恶的 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">循环依赖是邪恶的 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-31 00:45:50</div><div class="page_narrow text-break page_content"><p>关于F＃的最常见的抱怨之一是，它要求代码按依赖关系顺序排列。也就是说，您不能使用前向引用来引用编译器尚未看到的代码。</p><p>  “ .fs文件的顺序使其难以编译……我的F＃应用程序仅包含50行代码，但是即使编译最微小的非常规应用程序，它的工作量也超过了其价值。有没有办法使F＃编译器更像C＃编译器，从而使其与文件传递到编译器的顺序没有那么紧密地联系在一起？” [fpish.net]</p><p>  “在尝试使用F＃构建一个略高于玩具的项目后，我得出的结论是，使用当前的工具，即使维护一个中等复杂性的项目也非常困难。” [www.ikriv.com]</p><p>  “ F＃编译器太线性了。 F＃编译器应自动处理所有类型解析问题，而与声明顺序无关” [www.sturmnet.org]</p><p>  “在该论坛上已经讨论了F＃项目系统令人讨厌（且恕我恕我直言不必要的）限制的主题。我在说控制编译顺序的方式” [fpish.net]</p><p> 好吧，这些抱怨是没有根据的。您当然可以使用F＃构建和维护大型项目。 F＃编译器和核心库是两个明显的示例。</p><p> 实际上，大多数这些问题归结为“为什么F＃不能像C＃”。如果您来自C＃，则习惯于使编译器自动连接所有内容。必须显式地处理依赖关系是非常烦人的，甚至是老式的和回归的。 </p><p>这篇文章的目的是解释（a）依赖管理为什么很重要，以及（b）一些可以帮助您解决它的技术。</p><p>  我们都知道依赖是我们生存的祸根。程序集依存关系，配置依存关系，数据库依存关系，网络依存关系–总是存在。</p><p> 因此，作为专业人士，我们的开发人员往往会付出很多努力来使依赖项更易于管理。这个目标以许多不同的方式体现出来：接口隔离原理，控制反转和依赖注入；使用NuGet进行软件包管理；用人偶/厨师进行配置管理；等等。从某种意义上说，所有这些方法都在试图减少我们必须了解的事物的数量以及可能破坏的事物的数量。</p><p> 当然，这不是一个新问题。经典书籍“大规模C ++软件设计”的很大一部分致力于依赖性管理。正如作者约翰·拉科斯（John Lakos）所说：</p><p> “通过避免组件之间不必要的依赖关系，可以大大降低子系统的维护成本”</p><p> 这里的关键词是“不必要的”。什么是“不必要的”依赖？当然要看情况。但是几乎总是不需要一种特定的依赖关系-循环依赖关系。</p><p>  要了解循环依赖为何有害，让我们重新回顾一下“组件”的含义。 </p><p>组件是好东西。无论您将它们视为软件包，程序集，模块，类还是其他类，它们的主要目的都是将大量代码分解为更小且更易于管理的部分。换句话说，我们正在采用分而治之的方法来解决软件开发问题。</p><p> 但是，为了对维护，部署等有用，一个组件不应该只是随机的东西集合。它应该（当然）仅将相关代码分组在一起。</p><p> 因此，在理想世界中，每个组件都将完全独立于其他任何组件。但是通常（当然），总是需要一些依赖项。</p><p> 但是，现在我们有了带有依赖项的组件，我们需要一种方法来管理这些依赖项。一种标准的方法是使用“分层”原理。我们可以有“高级”层和“低级”层，关键规则是：每一层应仅依赖于其下的层，而不应依赖于其上的层。</p><p> 我敢肯定，您对此非常熟悉。这是一些简单图层的示意图：</p><p>  但是现在，当您像下面这样引入从底层到顶层的依赖关系时，会发生什么？</p><p>  通过从下到上具有依赖性，我们引入了邪恶的“循环依赖性”。 </p><p>从逻辑角度来看，此替代分层与原始分层相同。</p><p>   发生严重错误！很明显，我们真的搞砸了。</p><p> 实际上，一旦组件之间有了任何形式的循环依赖关系，您唯一可以做的就是将它们全部放入同一层。</p><p>  换句话说，循环依赖已完全破坏了我们的“分而治之”的方法，这就是首先拥有组件的全部原因。现在，我们不再只有三个组成部分，而只有一个“超级组成部分”，它比所需的要大三倍，而且更复杂。</p><p>   有关此主题的更多信息，请参见StackOverflow答案和有关Patrick（NDepend）的Patrick Smacchia进行分层的文章。</p><p>  首先，我们来看一下.NET程序集之间的循环依赖关系。以下是布莱恩·麦克纳马拉（Brian McNamara）的一些战争故事（我的重点）：</p><p> .Net Framework 2.0出现了这个问题。 System.dll，System.Configuration.dll和System.Xml.dll彼此无望地纠缠在一起。这以各种丑陋的方式表现出来。例如，我在VS调试器中发现了一个简单的[bug]，在尝试加载符号时遇到断点时，调试对象实际上会崩溃，这是由这些程序集之间的循环依赖性引起的。另一个故事：我的一个朋友是Silverlight初始版本的开发人员，任务是尝试精简这三个程序集，而第一个艰巨的任务是尝试解开循环依赖关系。 “免费相互递归”在小范围内非常方便，但会在很大程度上破坏您的利益。 </p><p>VS2008比计划的交货时间晚了一周，因为VS2008依赖于SQL Server，而SQL Server依赖于VS，哎呀！最终，他们无法生产出所有产品都具有相同内部版本号的完整产品版本，因此必须争先恐后才能使其正常运行。 [fpish.net]</p><p> 因此，有大量证据表明程序集之间的循环依赖关系很糟糕。实际上，程序集之间的循环依赖关系被认为非常糟糕，以至于Visual Studio甚至都不允许您创建它们！</p><p> 您可能会说：“是的，我可以理解为什么循环依赖关系对程序集不利，但是为什么要麻烦程序集内的代码呢？”</p><p> 好吧，出于完全相同的原因！分层允许更好的分区，更容易的测试和更整洁的重构。您可以在有关“狂野”的依赖周期的相关文章中看到我的意思，其中我比较了C＃项目和F＃项目。 F＃项目中的依赖项不像意大利面条。</p><p>  我在这里宣扬一个不受欢迎的职位，但是我的经验是，当您被迫考虑和管理系统各个级别的“软件组件之间的依赖顺序”时，世界上的一切都会变得更好。针对F＃的特定UI /工具可能还不理想，但我认为该原则是正确的。这是您想要的负担。这是更多的工作。 “单元测试”还需要更多工作，但我们已经达成共识，认为工作“值得”，因为从长远来看，它可以节省您的时间。对于“订购”，我有同样的感觉。系统中的类和方法之间存在依赖关系。您将忽略这些依赖关系，后果自负。一个强迫您考虑此依赖关系图（大致是组件的拓扑结构）的系统可能会引导您开发具有更简洁的体系结构，更好的系统分层以及更少的不必要依赖关系的软件。</p><p>  如果您喜欢我用图片解释事物的方式，请查看我的“域建模使功能”这本书是对域驱动设计，类型建模和功能编程的友好介绍。</p><p>   好的，我们同意循环依赖性不好。那么，我们如何检测到它们然后将其清除呢？ </p><p>让我们从检测开始。 有许多工具可帮助您检测代码中的循环依赖关系。  如果您使用的是C＃，则需要使用诸如不可估量的NDepend之类的工具。  但是，如果您使用的是F＃，那么您会很幸运！ 您可以免费获得循环依赖项检测！  您可能会说：“非常有趣，我已经了解F＃的循环依赖禁令-这真让我发疯！ 我该怎么做才能解决问题并使编译器满意？”  由Disqus提供动力的博客评论 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fsharpforfunandprofit.com/posts/cyclic-dependencies/">https://fsharpforfunandprofit.com/posts/cyclic-dependencies/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/循环/">#循环</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/依赖/">#依赖</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1037493.html"><img src="http://img2.diglog.com/img/2020/12/thumb_1a2de7e2e02fa22ae98ba812fc0fbf75.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037493.html">吉他循环踏板上的堆叠操作 </a></div><span class="my_story_list_date">2020-12-4 20:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033982.html"><img src="http://img2.diglog.com/img/2020/11/thumb_bcbec852e4c9b149fa58f5cd153ff653.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033982.html">事件循环在JavaScript中是如何工作的？[视频]</a></div><span class="my_story_list_date">2020-11-9 14:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032716.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0ea36f1a84c429f0262b1270d8f19905.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032716.html">
像鞋业公司千福尔这样的初创品牌正在给时尚业带来循环经济</a></div><span class="my_story_list_date">2020-11-2 11:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1012958.html"><img src="http://img.diglog.com/img/2020/7/thumb_45d6bf35734355c1b834cb21f5361718.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1012958.html">“末日滚动”会滋生焦虑。下面是如何停止这个循环的方法</a></div><span class="my_story_list_date">2020-7-20 9:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>