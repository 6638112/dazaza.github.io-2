<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>BEVY 0.5：数据导向游戏引擎内置锈 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">BEVY 0.5：数据导向游戏引擎内置锈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-07 04:13:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/48db8eb787e01587afbae8abe49292fa.png"><img src="http://img2.diglog.com/img/2021/4/48db8eb787e01587afbae8abe49292fa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>由于88个贡献者，283次拉出请求，以及我们慷慨的赞助商，我很高兴宣布封口的BEVY 0.5释放！</p><p> 对于那些不知道的人来说，Bevy是一款令人耳目无驰的简单数据驱动的游戏引擎。您可以查看快速入门指南即可开始。 Bevy也是免费和开放的源！您可以在GitHub上获取完整的源代码。</p><p> Bevy 0.5比我们过去的释放（并花费了一些更长），因为我们制作了许多基础变化。如果计划将应用程序或插件更新为Bevy 0.5，请查看我们的0.4到0.5迁移指南。</p><p>     BEVY现在在渲染时使用PBR着色器。 PBR是一种半标准方法，渲染试图使用现实世界＆＃34的近似;物理基于＆＃34;照明和材料特性。我们在很大程度上利用来自灯丝PBR实施的技术，但我们还从不真实和迪士尼融合了一些想法。</p><p> BEVY＆＃39; SDARDITEDMATERIAL现在具有Base_COLOR，粗糙度，金属，反射和发光性。它现在还支持Base_color，Normal_map，Metallic_roughness，发射和遮挡属性的纹理。</p><p>      GLTF装载机现在支持正常地图，金属/粗糙度，遮挡和发光纹理。我们的＆＃34;飞行头盔＆＃34; GLTF示例利用新的PBR纹理支持，结果如此：</p><p>    以前，很难与GLTF资产互动，因为场景/网格/纹理/和材料仅加载为＆＃34;子资产＆＃34;由于新的顶级GLTF资产类型，现在可以导航GLTF资产的内容： </p><p>//在启动时加载gltf资产fn setup（mut命令：命令，资产：res＆lt; assetserver＆gt;）{让掌握=资产。加载（＆＃34; flight_helmet.gltf＆＃34;）;命令。 INSERT_RESOURCE（手柄）;} //在时间稍后的时间点（手柄：res＆lt; gltf＆gt;，gltfs：res＆lt; gltfs＆lt;，GLTF资产，GLTF资产访问GLTF资产res＆lt; squarymaterial＆gt;＆gt;）{令gltf = gltfs。获得（＆amp; handle）。 unwrap（）;让matering_handle = gltf。 named_materials。得到（＆＃34; Metalpartsmat＆＃34;）。 unwrap（）;让材料=材料。得到（Material_Handle）。 unwrap（）;}</p><p>  此版本标志着Bevy＆＃39; ECS的巨大一步。它对Bevy应用程序的组成以及它们的执行程度有重大影响：</p><p>     直到这一点，bevy为我们的ECS核心使用了一系列重叉的HEC。自从Bevy＆＃39;第一个发布，我们学到了很多关于Bevy＆＃39; ECS的需求。我们还与其他ECS项目领导者合作，如桑德·佩佩斯（Lead Flecs Developer）和Gijs-Jan Roelofs（Xenonauts ECS框架开发商）。作为一个＆＃34; ECS社区＆＃34;，我们＆＃39; Ve开始归零ECS的未来。</p><p> Bevy ECS V2是我们进入该未来的第一步。这也意味着BEVY ECS不再是A＆＃34; HECS FORK＆＃34;我们自己出去了！</p><p>   原型ECS：存储＆＃34的组件;表＆＃34;使用静态模式。每个＆＃34;列＆＃34;存储给定类型的组件。每个＆＃34;行＆＃34;是一个实体。</p><p>   为实体和＃39; S组件的更昂贵的添加/删除操作提供的成本，因为所有组件都需要复制到新的原型＆＃39; s＆＃34;表＆＃34;</p><p> 友好友好：实体只在一个原型中存在，因此访问相同组件但在不同的原型中可以并行运行 </p><p>稀疏设置ECS：在密集包装阵列中存储相同类型的组件，这些组件由密集包装的无符号整数（实体ID）稀疏地索引</p><p> 查询迭代比原型ECS慢（默认情况下）慢，因为每个实体＆＃39; S组件可以处于稀疏集中的任何位置。这个＆＃34;随机访问＆＃34;模式isn＆＃39; t缓存友好。此外，有一个额外的间接层，因为您必须首先将实体ID映射到组件数组中的索引。</p><p>  ＆＃34;组件包＆＃34;用于通过案例的基础来优化迭代性能（但包装彼此冲突）</p><p> 不太平行友好：系统需要锁定整个组件存储（不粒状）或单个实体（昂贵）</p><p> 选择ECS框架的开发人员被困难了。选择一个＆＃34; archetypal＆＃34; ＆＃34的框架;到处快速迭代＆＃34;但没有能力廉价添加/删除组件，或选择A＆＃34;稀疏集合＆＃34;框架可廉价地添加/删除组件，但具有较慢的迭代性能或手动（和冲突）Pack优化。</p><p>  在Bevy ECS v2中，我们也可以吃蛋糕并吃它。它现在具有上面的两个组件存储类型（如果需要，可以在稍后添加更多）：</p><p>  这些存储类型完全相互补充。默认情况下，查询迭代快。如果开发人员知道他们想要在高频下添加/删除组件，他们可以将存储设置为＆＃34;稀疏集合＆＃34 ;: </p><p>该基准测试说明了从具有5个其他4x4矩阵组件的实体添加和删除单个4x4矩阵组件10,000次。 ＆＃34;其他＆＃34;包括组件以帮助说明＆＃34;表存储＆＃34; （由Bevy 0.4，Bevy 0.5（表）和军团使用，需要移动＆＃34;其他＆＃34;组件到新表。</p><p>  您可能已经注意到Bevy 0.5（表）也比Bevy 0.4更快，即使它们都使用＆＃34;表存储＆＃34;这主要是新原型图的结果，这显着降低了原型变化的成本。</p><p>   世界查询（和其他系统参数）现在是有状态的。这允许我们：缓存原型（和表）匹配，这可以解决（天真）原型型ECS的另一个问题：查询性能随着原型的数量而越来越差（发生碎​​片）。</p><p> 缓存查询获取和筛选状态昂贵的Fetch / Filter操作部分（例如散列TypeId以查找ComponentID），现在只有在首次构造查询时发生一次</p><p> 逐步构建状态在添加新原型时，我们只处理新的原型（无需重建旧原型的状态）</p><p>   然而，对于系统来说，这是一个不破坏的变化。查询状态管理由相关的SystemParam内部完成。</p><p> 由于新的查询系统，我们已经实现了一些非常重要的性能。 </p><p>该基准测试运行一个匹配单个原型和＃39; t匹配的5个实体的查询匹配100匹配100其他原型。这是＆＃34的合理测试;现实世界＆＃34;在游戏中的查询，通常有许多不同的实体＆＃34;类型＆＃34;，大多数Don＆＃39; t匹配给定查询。此测试使用＆＃34;表存储＆＃34;穿过董事会。</p><p>  Bevy 0.5为像新的案件标志着它的巨大改进，感谢新的＆＃34;有状态疑问＆＃34;每次运行迭代器时，都需要检查每个原型的每个原型，而Bevy 0.5摊销成本为零。</p><p>  这是ECS_Bench_Suite frag_iter基准测试。它以27个原型运行查询，每个ISIchetypes都有20个实体。然而，与＆＃34不同;稀疏碎片迭代店基准＆＃34;没有＆＃34;无与伦比的＆＃34;原型。此测试使用＆＃34;表存储＆＃34;穿过董事会。</p><p>  这里的收益与最后一个基准相比较小，因为没有任何无与伦比的原型＆＃39;然而，由于更好的迭代器/查询iclip，仍然仍然获得了一个很好的提升，将匹配原型的成本摊销到零，而for_each迭代器。</p><p>  开发人员现在可以选择使用快速查询:: for_each（）迭代器，从而产生＆＃34的迭代速度改进;碎片迭代＆＃34;，对未经用迭代的次要〜1.2x迭代速度改进。</p><p> FN系统（查询：查询＆lt;（＆amp; a，＆amp; mut b）＆gt;）{//您现在可以选择为速度提升查询执行此操作。 for_ach_mut（|（a，mut b）| {}）; //然而，普通迭代器仍然可用于查询中的（a，mut b）。 ITER_MUT（）{}}</p><p> 我们将继续鼓励＆＃34;正常＆＃34;迭代器，因为它们更灵活，更多＆＃34;生锈惯用＆＃34;但是当额外的＆＃34; oomf＆＃34;需要，for_each会在那里......等你:) </p><p>明确定义系统顺序的唯一方法是创建新阶段。这两个都是batterplate-ey并防止并行性（因为阶段运行＆＃34;一个逐个＆＃34;按顺序）。我们注意到系统订购是一个常见的要求和阶段只是Weren＆＃39; t切割它。</p><p> 系统有＆＃34;隐含的＆＃34;在访问冲突的资源时订购。这些排序很难理由。</p><p> ＆＃34;隐式排序＆＃34;产生的执行策略，通常在桌面上留下了很多平行潜力。</p><p> 幸运的是，@ratysz一直在这一领域做了很多研究，并自愿捐助一个新的执行官。新的执行程序解决了上述所有问题，并添加了一堆新的可用性改进。 ＆＃34;订购＆＃34;规则现在已经死了 - 简单：</p><p>    现在可以分配一个或多个SystemLabels。然后可以通过其他系统（阶段内）引用这些标签以在具有该标签的系统之前或之后运行：</p><p>    可以使用实现SystemLabel特征的任何类型。在大多数情况下，我们建议为它们定义自定义类型和派生SystemLabel。这可以防止拼写错误，允许封装（在需要时），并允许IDES到AutoComplete标签：</p><p> ＃[派生（调试，散列，零件，eq，clone，systemlabel）] Pub枚举物理系统{UpdateVelocity，Moreforms，Moreforms}应用程序。 add_system（update_velocity。system（）。标签（物理系统:: updatevelocity）））。 add_system（移动。系统（）。标签（物理系统::移动）。之后（物理系统:: UpdateVelocity））; </p><p>多对多标签是一个强大的概念，使得依赖于产生给定行为/结果的许多系统方便。例如，如果您有一个毕竟需要运行的系统＆＃34;物理＆＃34;已经完成更新（见上面的示例），您可以标记所有＆＃34;物理系统＆＃34;使用相同的物理标签：</p><p> ＃[派生（调试，哈希，零件，eq，克隆，systemlabel）] pub struct物理;＃[派生（调试，散列，偏见，eq，clone，systemlabel）] pub枚举物理系统{updatevelocity，moreform，moreface。 add_system（update_velocity。系统（）。标签（物理系统:: updateVelocity）。标签（物理））。 add_system（移动。系统（）。标签（物理系统::移动）。标签（物理）。（物理系统:: updateVelocity）之后。 add_system（runs_after_physics。系统（）。在（物理）之后）;</p><p> Bevy Plugin作者应该在其公共API中将标签导出，使其用户能够在插件提供的逻辑之前/之后插入系统。</p><p>   Systemsets是一种对一组系统应用相同配置的新方法，这显着削减了样板。 ＆＃34;物理＆＃34;上面的示例可以是如下所示的：应用程序。 add_system_set（systemset :: new（）//将此标签添加到集合中的所有系统。标签（物理）。with_system（update_velocity。系统（）。标签（物理系统:: updatevelocity））。with_system（移动。系统（） 。标签（物理系统::运动）。之后（物理系统:: UpdateVelocity））））</p><p> Systemsets也可以在（标签）和之后（标签）之前使用，以在给定标签之前/之后的设置中运行所有系统。</p><p> 这对于需要运行相同的运行频率的系统组也非常有用。</p><p> APP //此集合中的所有系统都将每两秒运行一次。 add_system_set（systemset :: new（）。with_run_criteria（fixedtimestep :: step（2.0））。with_system（foo。system（））。with_system（bar。system（））） </p><p>运行标准现在与系统分离，并在可能的情况下重新使用。例如，上面示例中的固定数据项标准只会运行一次运行一次。执行者将重新使用Foo和Bar系统的标准和＃39; S结果。</p><p>  fn every_other_time（mut has_ran：local＆lt; bool＆gt;） - ＆gt;肩膀{* has_ran =！* has_ran;如果* has_ran {wallrun ::是} els {wallrun :: no}}应用程序。 add_stage（systemstage :: parallel（）。with_system_run_criteria（every_other_time。system（）。标签（＆＃34; every_other_time＆＃34;）））））。 add_system（foo。system（）。with_run_criteria（＆＃34; every_other_time＆＃34;））</p><p> 运行标准的结果也可以是＆＃34;管道和＃34;进入其他标准，这使得有趣的组成行为：</p><p> fn direcle_in_a_blue_moon（In（输入）：在＆lt; antrun＆gt;，moon：res＆lt; moon＆gt;） - ＆gt;杨柳{如果月亮。 is_blue（）{input} else {wallrun :: no}}应用程序。 add_system（foo with_run_criteria（＆＃34; every_other_time＆＃34; pipe（are_in_a_blue_moon。system（）））</p><p>  虽然新的执行程序现在更容易理解，但它确实介绍了一类新的错误：＆＃34;系统订单含糊不清＆＃34;当两个系统与相同的数据交互时，但没有明确的排序定义，它们产生的输出是非确定性的（并且通常不是作者预期的）。</p><p>  fn increntment_counter（mut计数器：Resmut＆lt;）{*计数器+ = 1;} fn print_every_other_time（计数器：res＆lt; Usize＆gt;）{如果*计数器％2 == 0 {println！ （＆＃34; ran＆＃34;）; }} 应用程序  。 add_system（increntment_counter。system（））。 add_system（print_every_other_time。system（））</p><p> 作者清楚地预定print_every_other_time来运行其他更新。但是，由于这些系统没有定义了订单，它们可以以不同的顺序运行每个更新，并在两个更新的过程中打印任何内容的情况： </p><p>更新 -  increment_counter（柜台现在等于1） -  print_every_other_time（没有打印）更新 -  print_very_other_time（没有打印） -  increment_counter（柜台现在等于2）</p><p> 旧的executor将隐式强制increntment_counter首先运行，因为它与print_every_other_time冲突，它首先插入。但是新的执行官要求您在此处（我们认为是一件好事）。</p><p> 为了帮助检测到这类错误，我们构建了一个选择的工具，检测这些含糊不点并记录它们：</p><p>  然后在我们运行我们的应用程序时，我们将看到打印到我们终端的以下消息：</p><p> 检测到的执行顺序歧义，您可能希望在其中一些系统之间添加显式依赖关系：*并行系统： - ＆＃34;＆amp;应用程序:: increntment_counter＆＃34;和＃34;＆amp; app :: print_every_other_time＆＃34;冲突：[＆＃34; USIZE＆＃34;]</p><p> 歧义探测器发现了一个冲突和提到，添加了显式依赖性将解决冲突：</p><p>  有一些案例，歧义不是一个错误，例如无序集合的操作等资产。这就是为什么我们不默认启用探测器。您可以自由地忽略这些歧义，但如果要抑制探测器中的消息（无需定义依赖项），则可以将您的系统添加到AN＆＃34; ambiguity集合＆＃34 ;: </p><p>我想强调这是完全可选的。 Bevy代码应该是符合人体工程学和＆＃34;有趣＆＃34;来写。如果洒在歧义落在任何地方且＃39;你的一杯茶，只是不要担心它！</p><p> 我们也正在积极寻求关于新执行官的反馈。我们相信新的实施更容易理解并鼓励自我记录代码。改善的并行性也很好！但是我们希望听到用户（新用户都开始新的用户，并将其代码库移植到新的执行程序）。这个空间都是关于设计权衡和反馈，并有助于我们确保我们做出正确的电话。</p><p>   全局变更检测，在任何ECS组件或资源的更改/添加状态下运行查询的能力，刚刚获得了一个重大的可用性提升：现在在帧/更新中检测到更改：</p><p> //这仍然是相同的变化检测API我们都知道和爱，//唯一的区别是它＆＃34;只是作品＆＃34;在每种情况下。 FN系统（查询：查询＆lt;实体，已更改为＆gt;）{//迭代所有实体，其组件自//在查询中的e的上次运行此系统的最后运行。 erter（）{}}</p><p> 全局变更检测已经是一个特征，它与其他ECS框架相比设置了BEVY，但现在它是完全＆＃34;傻瓜证明＆＃34;无论系统订购，阶段成员资格或系统运行标准如何，它都可以工作。</p><p> 旧行为是＆＃34;系统检测到在它们之前遇到的系统中的变化＆＃34;这是因为当添加/修改每个组件/资源时，我们使用BOOL跟踪。此标志对于帧结束时的每个组件被清除。因此，用户必须非常谨慎地了解操作顺序，并使用像＆＃34这样的功能;系统运行标准＆＃34;如果系统在给定更新中运行，则可能导致更改删除。</p><p> 我们现在使用聪明的＆＃34;世界蜱＆＃34;设计允许系统检测自上次运行以来任何时间点发生的更改。 </p><p>最后一个Bevy发布添加状态，它使开发人员能够根据状态＆lt; t＆gt的值运行ECS系统组;资源。系统可以根据＆＃34运行系统生命周期事件＆＃34;，例如on_enter，on_update和on_exit。各国像单独的东西一样制造;加载屏幕＆＃34;和＃34;在游戏中＆＃34;在Bevy ECS中更容易编码逻辑。</p><p> 旧的实现在很大程度上工作，但它有很多怪癖和局限性。首先，它需要添加一个新的Statesge，它在并行，增加的样板，并强制订购所需的地方，而且需要。此外，一些生命周期事件没有始终按预期行事。</p><p> 新的状态实现是基于新的并行执行程序和＃39; s systemset和runcrieria特征的顶部构建了更自然，灵活的，并行API，这些API在现有概念上构建而不是创建新的：</p><p> ＃[派生（调试，克隆，eq，partialeq，哈希）] enum appstate {menu，ingame，} fn main（）{app :: build（）。 add_state（appstate ::菜单）。 add_system_set（systemset :: on_enter（appstate ::菜单）。with_system（setup_menu。system（）））。 add_system_set（systemset :: on_update（appstate :: menu）。with_system（menu_logic。system（）））。 add_system_set（systemset :: on_exit（appstate ::菜单）。with_system（cleanup_menu。system（）））。 add_system_set（systemset :: On_Enter（AppState :: Invame）。with_system（setup_game。system（）））。 add_system_set（systemset :: on_update（appstate :: gamene）。with_system（game_logic。system（））。with_system（more_game_logic。system（）））。跑步 （）;}</p><p> 现在使用A＆＃34;基于堆栈的状态机＆＃34;模型。这为州过渡的许多选项打开了：</p><p> FN系统（MUT状态：Resmut＆lt;状态＆gt;＆gt;）{//队列向上推出一个状态更改，将新状态推送到//堆栈（保留以前的状态）状态。推（AppState :: Invame）。 unwrap（）; //延出一个状态更改，该更改删除//堆栈上的当前状态并恢复为先前的状态状态。流行音乐 （）。 unwrap（）; //向上延迟覆盖///＃34;顶部＆＃34的当前状态的状态更改;堆栈状态。 SET（AppState :: Invame）。 unwrap（）; //队列替换状态更改的状态更改。替换（AppState :: Invame）。 unwrap（）;}</p><p> 就像旧的实现一样，状态更改应用于同一帧。这意味着可以从状态A-＆gt; b-＆gt; c，并在不跳过框架的情况下运行相关的状态生命周期事件。这是在＆＃34的顶部构建;循环运行标准＆＃34;我们也用于我们的我们的＆＃34;修复了TimeStep＆＃3 </p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bevyengine.org/news/bevy-0-5/">https://bevyengine.org/news/bevy-0-5/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/导向/">#导向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oriented/">#oriented</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1056581.html"><img src="http://img2.diglog.com/img/2021/4/thumb_04fbc45ff13cfc08b6ba1661720b4cee.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056581.html">在游戏男孩（慢慢地）挖掘比特币 </a></div><span class="my_story_list_date">2021-4-7 3:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056575.html"><img src="http://img2.diglog.com/img/2021/4/thumb_c215b05da56cb532c913afcb472f18fa.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056575.html">我们可以在PlayStation和Xbox Spring销售中找到最好的游戏交易 </a></div><span class="my_story_list_date">2021-4-7 1:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056497.html"><img src="http://img2.diglog.com/img/2021/4/thumb_a89ebc40e093ac5c7a3d3d3feace1bd7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056497.html">E3将于6月12日至15日作为免费虚拟会议举行，组织者表示，2022年在La中发生一个人的活动 </a></div><span class="my_story_list_date">2021-4-6 21:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056465.html"><img src="http://img2.diglog.com/img/2021/4/thumb_a040f87a002046a88f0ec9ddcf6a426f.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056465.html">抱歉scrum，游戏可能会为你结束 </a></div><span class="my_story_list_date">2021-4-6 17:25</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>