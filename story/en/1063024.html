<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用于微控制器的虚拟机 A virtual machine for microcontrollers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A virtual machine for microcontrollers<br/>用于微控制器的虚拟机 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-03 23:00:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/3e6b41de3e60cf9ac4a81766322bc984.png"><img src="http://img2.diglog.com/img/2021/6/3e6b41de3e60cf9ac4a81766322bc984.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>About the author: Kasper Lund is a programming languages and virtual machine veteran. He co-founded the  V8 and  Dart  projects at Google and brought adaptive optimizations to JavaScript as the tech lead for the  Crankshaft project. He lives near Aarhus, Denmark, where he is the co-founder of Toit.</p><p>关于作者：Kasper Lund是一款编程语言和虚拟机退伍军人。他共同创立了Google的V8和Dart项目，并为JavaScript带来了适应性优化作为曲轴项目的技术领导。他住在丹麦的Aarhus附近，他是Toit的联合创始人。</p><p>  One of my first experiences with low-level system software was building my own operating system for the x86 from scratch. Putting my code — and nothing but my code — on a floppy disk and booting from it, made me incredibly excited. I was slightly less excited whenever I inadvertently introduced some bug in my code that caused a  triple fault that made my computer reboot. The trial-and-error approach to addressing such bugs was interesting detective work, but it wasn’t very productive. I felt like the primary purpose of my — and indeed any other — operating system was to provide meaningful, actionable feedback about misbehaving software, so I spent most of my time fiddling with page and descriptor tables to use the hardware-provided means for catching and reporting such issues.</p><p>  我的第一个与低级系统软件的经验之一是从头开始构建自己的操作系统。放置我的代码 - 除了我的代码 - 在软盘上并从中启动，让我令人难以置信的兴奋。每当我无意中引入我的代码中的一些错误时，我略显不那么兴奋，导致我的计算机重启的三重故障。解决这些错误的试用和错误方法是有趣的侦探工作，但它并不是很富有成效。我觉得我的主要目的是我 - 确实是任何其他操作系统的目的是提供有关行为不端的软件的有意义，可操作的反馈，因此我大部分时间都摆脱了页面和描述符表来使用用于捕获的硬件提供的手段报告此类问题。</p><p> When the first versions of Linux arrived on the scene, I realized just how much work it would be to build my own truly useful operating system, so when I joined Google in 2006 my interests had swung to the language implementation side of things (Java, Smalltalk) and I happily spent years making JavaScript run fast in your browser. It was all about software and enabling developers to do more. I liked it.</p><p> 当第一个版本的Linux到达现场时，我才能建立自己真正有用的操作系统的工作，所以当我加入2006年加入谷歌时，我的兴趣已经转向事物的语言实施方面（Java， SmallTalk）和我愉快地花了旧浏览器中的JavaScript在浏览器中运行。这是关于软件，使开发人员能够做更多。我喜欢它。</p><p> I know now that enabling software developers is definitely my thing, so I have been thrilled to see how the close cousin of the subject of my  master’s thesis — the internet of things (IoT) — has been going through a phase where the focus on connectivity and hardware has been matched with a focus on functionality provided by software. Today, lots of developers come to IoT from software backgrounds and they pick tools that make them productive. They choose hardware like the Raspberry Pi instead of a power-efficient microcontroller, because coupled with Linux, it gives them a high-level and robust foundation for their work.</p><p> 我现在知道，启用软件开发人员绝对是我的事情，所以我很兴奋，看看我师父论文的主题的关心堂兄 - 事情互联网（IOT） - 一直经历了一个阶段，在那里专注于连接的阶段硬件与专注于软件提供的功能匹配。今天，很多开发人员都来自软件背景的IoT，他们选择了使它们富有成效的工具。它们选择像覆盆子PI等硬件，而不是高功率高效的微控制器，因为与Linux相结合，它为他们提供了高级和强大的工作基础。</p><p>  If you want to build for microcontrollers, you’re forced to use a different, much less refined development workflow. Soldering irons, C compilers, and flashing via USB connectors is on the menu if you go that route. It can be a rather painful experience, so brace yourself. In a nutshell, the problem is that on microcontrollers everything is firmware that is compiled, linked, and deployed together using really old-fashioned tools. Changing anything means changing everything. All the different pieces of your codebase also crash together, so if you introduce a bug in one part of your code, chances are that it will ruin the entire functionality of your device, rendering your device useless on a good day and completely  bricked on a rainy day.</p><p>  如果您想为微控制器构建，您将被迫使用不同的，更加精致的开发工作流程。通过USB连接器焊接熨斗，C编译器和闪烁，如果您走该路由，请在菜单上。这可能是一种相当痛苦的经历，所以你自己就能支撑。简而言之，问题是在微控制器上，一切都是编译，链接和部署在一起使用真正的旧式工具的固件。改变任何东西意味着改变一切。所有不同的Codebase也会一起崩溃，因此如果您在代码的一部分中介绍了一个错误，那么它将破坏您的设备的整个功能，使您的设备在美好的一天中无用，并完全砖块下雨天。</p><p> Modern computers have grown operating systems that support developers by giving them safety rails and fault isolation, but this level of support and security hasn’t yet reached microcontrollers. It is time for a change!</p><p> 现代计算机通过提供安全轨和故障隔离，实现了支持开发人员的操作系统，但这种支持和安全性尚未到达微控制器。现在是改变的时候了！</p><p>  Microcontrollers usually run so-called real-time operating systems ( RTOS). The reason they run these stripped down operating systems that deemphasize security and robustness is that a typical operating system relies on the hardware to provide multiple protection domains and memory isolation. Without that hardware support, the operating system only deals with simpler things like scheduling, synchronization, and memory allocation.</p><p>  微控制器通常运行所谓的实时操作系统（RTOS）。它们运行这些剥离的操作系统的原因，这些系统不视义安全和稳健性是典型的操作系统依赖于硬件提供多个保护域和内存隔离。没有硬件支持，操作系统仅处理更简单的事件，如调度，同步和内存分配。 </p><p> It is possible to provide fault tolerance and isolation through software, but it requires a software layer that shields the applications that run on top of it from the underlying hardware. This layer is typically called a  virtual machine.</p><p>通过软件可以提供容错和隔离，但它需要一个软件层，该软件层屏蔽从底层硬件上运行的应用程序。该层通常称为虚拟机。</p><p> You may have heard about two different kinds of virtual machines: The ones that emulate a concrete computing system and the ones that provide a platform-independent managed environment for a specific class of high-level languages to run in. Because of its significantly lower system requirements, we have focused on the latter kind and designed an embedded virtual machine in the tradition of Java — not Docker — for microcontrollers. It runs on the  ESP32 chips from  Espressif Systems, and it augments the primitive  FreeRTOS operating system that is bundled in Espressif’s IoT Development Framework ( ESP-IDF) with the capabilities for safely running platform-independent software applications side-by-side.</p><p> 您可能已经听说过两种不同的虚拟机：模拟混凝土计算系统的那些和那些为特定类别的高级语言提供独立于平台的托管环境。由于其系统显着降低要求，我们专注于后一种类型，并设计了一个嵌入式虚拟机，在Java的传统 - 而不是Docker  - 对于微控制器。它在eSP32芯片上从ESPRESSIF系统中运行，它增加了基本的FreERTOS操作系统，该系统捆绑在eSpressif的IOT开发框架（ESP-IDF）中，并以并排安全地运行独立的软件应用程序。</p><p>  The concepts of operating system, virtual machine and programming language are closely related. From the perspective of a developer, we have hidden the operating system and the physical hardware and given them a high-level language and environment to work in. It is just like how modern web browsers let developers run their applications across Windows, Linux and macOS on different kinds of processors, but this time for microcontrollers. The Toit virtual machine implementation is our secret sauce, and no it isn’t  just another operating system.</p><p>  操作系统，虚拟机和编程语言的概念密切相关。从开发人员的角度来看，我们隐藏了操作系统和物理硬件，并给出了一个高级语言和环境。它就像现代Web浏览器如何让开发人员在Windows，Linux和MacOS中运行他们的应用程序在不同种类的处理器上，但这一次用于微控制器。 Toit Virtual Machine实现是我们的秘密酱，而且不仅仅是另一个操作系统。</p><p> An operating system is a collection of things that don’t fit into a language. There shouldn’t be one.  —   Dan Ingalls</p><p> 操作系统是一种不适合语言的东西的集合。不应该有一个。 -  Dan Ingalls.</p><p>  The Toit platform allows you to install independently developed applications side-by-side on a small microcontroller like the ESP32. The virtual machine has built-in support for constructing application images in flash, based on a stream of bits and  relocation information. The relocation information is crucial, because it allows the device to freely pick the location in flash where it installs the application. We do not have the luxury of using  virtual memory to let the system believe an application always runs from a particular location in memory, so we have to adapt the application image to the actual location in flash that it ends up being stored in.</p><p>  Toit平台允许您并排在像ESP32这样的小型微控制器上并排安装独立开发的应用程序。虚拟机基于位和重定位信息流构建闪存中的应用图像的内置支持。重定位信息至关重要，因为它允许设备自由地选择闪存中安装应用程序的位置。我们没有使用虚拟内存的奢侈内存让系统认为应用程序始终从内存中的特定位置运行，因此我们必须将应用程序映像调整到闪存中的实际位置，即它最终存储在闪存中。</p><p>  The Toit platform streams the application images via  CoAP over  TLS and the device receives 32 words at a time and relocates them before writing them into flash. We have designed it so we never have to keep the full image in RAM, because that is a fairly limited resource. Once we’re done with all the application image bits, we validate them using a checksum mechanism and finally commit the header, turning the application into a valid and runnable piece of functionality.</p><p>  TOIT平台通过COAP通过COAP将应用程序图像流传输，并且设备一次接收32个单词并在将它们写入闪存之前重新安置它们。我们已经设计了它，所以我们永远必须在RAM中保持完整的形象，因为这是一个相当有限的资源。一旦完成所有应用程序映像位，我们使用校验和机制验证它们并最终提交标题，将应用程序转换为有效和可运行的功能。</p><p>  A typical Toit application image is around 30KB in total. The vast majority of that is the bytecodes that describe the behavior of individual methods in an easily interpretable form. We extract the essential information from the program’s hierarchy, classes and interfaces, and store them in a compact form. Similarly, we save space by collectively storing methods as one flattened sequence of bytes in something that resembles the .text segment of an ELF file. The only structured objects in the images are the compile-time constants that go with the application.</p><p>  典型的Toit应用程序图像总共约为30kB。绝大多数是以一种易于解释的形式描述单个方法行为的字节码。我们从程序的层次结构，类和接口中提取基本信息，并以紧凑的形式存储它们。同样，我们通过将方法统称为类似于ELF文件的.text段的某些字节的一个扁平字节序列来节省空间。图像中唯一的结构化对象是使用该应用程序的编译时常量。 </p><p> The Toit virtual machine ends up acting like a flash-based filesystem with a dynamic relocating linker for installing, upgrading, and uninstalling application images that can run directly from flash. The applications are completely separate and only share what is provided by the virtual machine on the device.</p><p>Toit虚拟机最终与基于闪存的文件系统相同，具有动态重定位链接器，用于安装，升级和卸载可以直接从Flash运行的应用程序映像。应用程序完全分开，仅共享设备上虚拟机提供的内容。</p><p>  For robustness and security reasons, applications need a safe environment on your microcontroller to run within. When an application starts up, the Toit virtual machine allocates a new process structure in memory. The structure includes an object heap that is isolated from the rest of the system, so we have a place to keep all objects allocated by code running in that particular process. The footprint of a minimal process is 4KB of RAM and that includes the object heap. Start small and grow only when necessary!</p><p>  出于稳健性和安全性原因，应用程序需要在您的微控制器上进行安全的环境来运行。应用程序启动时，Toit虚拟机会分配内存中的新进程结构。该结构包括与系统的其余部分隔离的对象堆，因此我们有一个可以保留在该特定进程中运行的代码分配的所有对象的位置。最小过程的足迹是4KB的RAM，包括物体堆。开始小，只在必要时长大！</p><p> Once the process has been set up, the virtual machine tells the scheduler that the process is ready to run. The processes are scheduled on top of a fixed number of FreeRTOS threads — one for each core of the CPU — but you can easily have more processes than threads. In most cases, we run with two threads on the ESP32, because it is a dual-core processor. The threads have a small, fixed execution stack associated with them and they  service the individual processes one at a time by running the applications associated with them for a while until the threads are preempted by the scheduler and move on to another process. Multiple preemptively scheduled processes with completely isolated address spaces. Check.</p><p> 设置过程后，虚拟机会告诉调度程序，该过程已准备好运行。该过程计划在固定数量的FreerTOS线程之上 - 一个用于CPU的每个核心 - 但您可以轻松拥有比线程更多的进程。在大多数情况下，我们在esp​​32上使用两个线程运行，因为它是双核处理器。线程具有与它们相关联的小，固定的执行栈，并且通过运行与它们相关联的应用程序一段时间来实现单个进程一段时间，直到线程被调度器预先按到另一个进程。具有完全隔离的地址空间的多个先发分便的程序。查看。</p><p> Inside the processes, the application consists of multiple  light-weight tasks that each have their own execution stack. These stacks are allocated in the object heap and they grow on demand, so you don’t have to preallocate nor pick the right stack sizes for your tasks. The system takes care of that for you. The tasks are cooperatively scheduled, so it is only when one task cannot make progress that we pick another task in the same process and continue running its code.</p><p> 在进程中，应用程序包括多个轻量级任务，每个都有每个都有自己的执行堆栈。这些堆栈在对象堆中分配，它们按需增长，因此您不必预先采用或为您的任务选择正确的堆栈大小。该系统为您提供了处理。任务是协作计划的，因此只有在一个任务无法在同一过程中选择另一个任务并继续运行其代码时，才会才能进行进展。</p><p>  This setup gives your applications their own isolated memory areas. This is important for security and robustness, but it is also the perfect way to support decomposing your device functionality into meaningful and decoupled modular applications. Internally, applications can be composed of multiple task-based activities and it is extremely cheap to do blocking operations like waiting for events, because you are only blocking a light-weight task, not an entire process or the FreeRTOS thread. This leads to understandable code that is easy to write and it avoids the need for most asynchronous operations:</p><p>  此设置为您的应用程序提供了他们自己的孤立内存区域。这对于安全性和稳健性非常重要，但它也是支持将您的设备功能分解成有意义和解耦的模块化应用程序的完美方式。在内部，应用程序可以由基于任务的活动组成，阻止等待事件的操作非常便宜，因为您只阻止了轻量级任务，而不是整个过程或Freertos线程。这导致可理解的代码易于编写，避免对大多数异步操作的需求：</p><p>  Another benefit is that the object heaps of the processes can be garbage collected completely independently. We see pause times of less than a millisecond, because the individual heaps are small and manageable. Building scalable and sophisticated garbage collectors for complex systems like we did for JavaScript is fun, but for an embedded device it is better to design the system so the memory management can be kept simple. Really small heaps are a great way to allow that.</p><p>  另一个好处是，该过程的对象堆可以是垃圾完全独立收集的。我们看到暂停时间小于毫秒，因为各个堆很小而且可管理。为复杂系统构建可扩展和复杂的垃圾收集器，如我们为JavaScript做的很有趣，但对于嵌入式设备来说，更好地设计系统，因此内存管理可以保持简单。真的小堆是一种很好的方式来允许这一点。</p><p>  Once you have a good handful of processes running on your microcontroller, you want to make sure they don’t unnecessarily consume too much of your most precious resource: RAM. The best way to achieve that is to make sure that the virtual machine itself doesn’t come with too much overhead and stays lean when executing your code.</p><p>  一旦您在微控制器上运行了很多少数流程，您希望确保他们不会不必要地消耗太多珍贵的资源：RAM。实现这一目标的最佳方法是确保虚拟机本身不会带有太多的开销并在执行代码时保持精益。 </p><p> For dynamic and flexible programming languages, a common source of overhead is actually the optimization techniques used to make method calls fast. When a virtual machine executes your method calls like:</p><p>对于动态和灵活的编程语言，常见的开销来源实际上是用于使方法呼叫快速的优化技术。当虚拟机执行方法时，请调用：</p><p>  it needs to determine which  append method to invoke based on the runtime type of months. Historically, this has been optimized by having a method lookup table that uses extremely fast hashing to find and validate the right  append method, but the hash table is updated at runtime and must be stored in RAM. To avoid too many collisions, it also needs to have a pretty decent size, so this adds quite a bit of overhead for the sole purpose of making method calls fast.</p><p>  它需要根据运行时类型的数月确定要调用哪个附加方法。从历史上看，通过使用方法查找表来优化，该表使用极快的散列来查找和验证右追加方法，但哈希表在运行时更新，并且必须存储在RAM中。为了避免太多的碰撞，它也需要具有相当不良的大小，因此这对于快速制作方法调用的唯一目的，这增加了相当多的开销。</p><p> In Google’s V8 JavaScript engine, we ended up using an even more expensive approach that associated so-called   inline caches with all the individual places in your code where you call methods. Among other things, such an inline cache stores the last method called at that point in the code and since that changes over time, the caches must be in RAM. It is fast, but prohibitively expensive in terms of memory.</p><p> 在Google的V8 JavaScript引擎中，我们最终使用了更昂贵的方法，即关联所谓的内联缓存与您呼叫方法的代码中的所有各个位置。除此之外，这种内联高速缓存存储了在代码中的该点调用的最后一个方法，因为随着时间的推移，缓存必须在RAM中进行变化。它是快速的，但在记忆方面非常昂贵。</p><p> For Toit, we knew that we needed something better that would allow us to perform efficient method calls directly from flash with no RAM overhead. We started by doing a depth first numbering of all the Toit classes in the system and noted how that trivially led to consecutive numbers for all subclasses of a given class.</p><p> 对于Toit，我们知道我们需要更好的东西，使我们能够直接从Flash执行高效的方法调用，没有RAM开销。我们首先在系统中进行深度首次编号，并指出，对于给定类的所有子类，将其普遍导致到连续数字。</p><p>  That means methods are inherited by classes within a specific class number range. As an example, if class  B defines a method called  append, the method  B.append is inherited by all classes with numbers in the [1, 3] range. If class  F also defines an  append method, the  F.append method is only applicable for instances of  F. You can easily associate a method name with all the class number ranges its different implementations are inherited by. Through that you can form a one-dimensional dispatch table specific for the method name  append that looks like this:</p><p>  这意味着方法由特定类编号范围内的类继承。例如，如果B类定义了一个名为Append的方法，则方法B.Append由[1,3]范围中的所有类别继承。如果F类还定义了Append方法，则F.Append方法仅适用于F的实例。您可以轻松关联与其不同实现的所有类编号的方法名称。通过此，您可以对所示的方法名称进行特定于特定的一维调度表：</p><p>  So to call  append on an object, all you have to do is to find the entry in the table that corresponds to the class number of the object you’re calling  append on. It is a cheap constant-time operation and nothing in the table needs to change as a result of the lookup, so the table fits nicely in flash. There are lots of holes in the table which is wasteful, but if you’re careful you can actually use those holes for other such tables by overlapping them and compressing the overall dispatch data structure you need to store in flash.</p><p>  所以要在对象上调用附加，您所要做的就是在表格中找到与您所在对象的类的类对应的表中的条目。这是一个廉价的恒定时间操作，表中的任何内容都需要由于查找而改变，因此表格在Flash中非常适合。桌子里有很多洞，这是浪费的，但如果你小心你可以通过重叠它们来实际上可以为其他这样的表一起使用这些漏洞并压缩您需要在闪存中存储的整体调度数据结构。</p><p> The compression technique is known as  selector-based row displacement, and it removes pretty much all the unnecessary holes in the tables if done right. You can read much more about it in Karel Driesen’s book,  Efficient Polymorphic Calls.</p><p> 压缩技术称为基于选择器的行位移，如果完成，它会消除表中的所有不必要的孔。您可以在Karel Driesen的书中阅读更多关于它的信息，有效的多态电话。 </p><p>  Some folks claim that the S in IoT stands for security. With the current state of the developer experience for microcontrollers, it could also stand for software or simplicity. They are all missing. Developers deserve a robust foundation for their on-device functionality. Armed with that, they will be empowered to experiment more and innovate faster. If the same foundation allows simple, modular software to replace complex, monolithic firmware and provides memory safety and sandboxing to strengthen security, are we not pretty close to putting the S in IoT? Your C compiler and your primitive real-time operating system will not get you there.</p><p>有些人声称IOT中的S代表安全。随着微控制器的开发人员体验的当前状态，它也可以代表软件或简单性。他们都丢失了。开发人员为其在设备上功能提供了强大的基础。随之而来，他们将被赋予更快地尝试并更快创新。如果相同的基础允许简单，模块化软件替换复杂的单片固件并提供内存安全和沙箱加强安全性，我们还不接近将S放在IOT中吗？您的C编译器和原始的实时操作系统将不会让您在那里。</p><p>  Programming languages and virtual machines are here to help make you a better programmer — and through some of the techniques I’ve outlined in this post, Toit gives you those benefits even on microcontrollers. Toit is built by a team of software platform experts from Google and Uber that believe that if you feel uncomfortable updating the software on your devices in production, you are not doing it often enough. The problem isn’t you, it is your platform. Stop worrying about triple faults and start worrying about moving fast enough to stay relevant.</p><p>  编程语言和虚拟机在这里有助于让您成为一个更好的程序员 - 以及通过我在这篇文章中概述的一些技术，即使在微控制器上也为您提供这些好处。 Toit是由谷歌和优步专家的软件平台专家团队构建，相信如果您在生产中更新软件，则不会经常这样做。问题不是你，这是你的平台。停止担心三倍的错误，并开始担心快速移动以保持相关性。</p><p> You can read more about our  new language or even  try it out if you’re curious to see some of this in action.</p><p> 您可以阅读更多关于我们新语言的信息，甚至可以尝试一下，如果您在行动中看到其中一些。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.toit.io/why-doesnt-v8-fit-on-my-microcontroller-71dc6e2d8f5c">https://blog.toit.io/why-doesnt-v8-fit-on-my-microcontroller-71dc6e2d8f5c</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟机/">#虚拟机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/machine/">#machine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>