<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Safari现在支持具有私有源的文件系统访问APISafari now supports File System Access API with private origin</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Safari now supports File System Access API with private origin<br/>Safari现在支持具有私有源的文件系统访问API</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 23:01:21</div><div class="page_narrow text-break page_content"><p>It is very common for an application to interact with local files. For example, a general workflow is opening a file, making some changes, and saving the file. For web apps, this might be hard to implement. It is possible to simulate the file operations using IndexedDB API, an HTML input element with the  file type, an HTML anchor element with the  download attribute, etc, but that would require a good understanding of these standards and careful design for a good user experience. Also, the performance may not be satisfactory for frequent operations and large files.</p><p>应用程序与本地文件交互是非常常见的。例如，常规工作流是打开文件、进行一些更改并保存文件。对于网络应用来说，这可能很难实现。可以使用IndexedDB API、具有文件类型的HTML输入元素、具有下载属性的HTML锚元素等来模拟文件操作，但这需要对这些标准有很好的理解，并仔细设计以获得良好的用户体验。此外，对于频繁操作和大文件，性能可能不令人满意。</p><p> The  File System Access API makes it possible for web apps to have easy and efficient file access. It provides a way to create, open, read, and write files directly. It also allows apps to create directories and enumerate their contents.</p><p>文件系统访问API使web应用程序能够轻松高效地访问文件。它提供了一种直接创建、打开、读取和写入文件的方法。它还允许应用程序创建目录并枚举其内容。</p><p>  WebKit has added support for the File System Access API with  the origin private file system — a private storage endpoint to some  origin. Conceptually, every origin owns an independent directory, and a page can only access files or directories in its origin’s directory. For example,  https://webkit.org cannot read files created by  https://apple.com.</p><p>WebKit在origin private File System中增加了对文件系统访问API的支持，该文件系统是某个origin的专用存储端点。从概念上讲，每个源站都拥有一个独立的目录，页面只能访问其源站目录中的文件或目录。例如https://webkit.org无法读取由创建的文件https://apple.com.</p><p> Based on the implementation of different browsers, one entry in the origin private file system does not necessarily map to an entry in the user’s local filesystem — it can be an object stored in some database. That means a file or directory created via the File System Access API may not be easily retrieved from outside of the browser.</p><p>基于不同浏览器的实现，源私有文件系统中的一个条目不一定映射到用户本地文件系统中的一个条目——它可以是存储在某个数据库中的对象。这意味着通过文件系统访问API创建的文件或目录可能无法从浏览器外部轻松检索。</p><p>  The API is currently unavailable for Safari windows in Private Browsing mode. For where is it available, its storage lifetime is the same as other persistent storage types like IndexedDB and LocalStorage. The storage policy will conform to the  Storage Standard. Safari users can view and delete file system storage for a site via Preferences on macOS or Settings on iOS.</p><p>该API目前不适用于处于私人浏览模式的Safari windows。对于可用的位置，其存储寿命与IndexedDB和LocalStorage等其他持久存储类型相同。存储策略将符合存储标准。Safari用户可以通过macOS上的首选项或iOS上的设置查看和删除站点的文件系统存储。</p><p>  The File System Access API with origin private file system is enabled in WebKit from  r284131. It is available in Safari on:</p><p>源私有文件系统的文件系统访问API在r284131的WebKit中启用。在Safari网站上提供：</p><p>  In Safari on macOS 12.4 and iOS 15.4, we introduced the  getFile() method of  FileSystemFileHandle.</p><p>在macOS 12.4和iOS 15.4上的Safari中，我们介绍了FileSystemFileHandle的getFile（）方法。</p><p>   FileSystemHandle, which represents an entry in the file system. It is available in Worker and</p><p>FileSystemHandle，表示文件系统中的一个条目。它有工人和工人两种</p><p>   FileSystemSyncAccessHandle, which provides an exclusive duplex stream for synchronous read and write on an entry. Unlike the interfaces above, which exist in both Window and Worker contexts,  FileSystemSyncAccessHandle is only available in Worker.</p><p>FileSystemSyncAccessHandle，它提供一个专用的双工流，用于同步读写条目。与上面的界面不同，FileSystemSyncAccessHandle既存在于窗口上下文中，也存在于工作上下文中，FileSystemSyncAccessHandle仅在工作上下文中可用。</p><p> With these basic interfaces in mind, let’s look at how to use them by diving into some examples.</p><p>考虑到这些基本接口，让我们通过一些示例来了解如何使用它们。</p><p>   In the origin private file system, a  FileSystemHandle represents either the root directory of the origin’s space, or a descendant of the root directory. Therefore, the first step is to get the root  FileSystemDirectoryHandle. It is done via   StorageManager interface.</p><p>在源私有文件系统中，FileSystemHandle表示源空间的根目录或根目录的后代。因此，第一步是获取根文件系统DirectoryHandle。这是通过StorageManager界面完成的。</p><p>   With a  FileSystemDirectoryHandle object like root, you can get access to its child with some specific name using  getDirectoryHandle() and  getFileHandle() methods.</p><p>使用像root这样的FileSystemDirectoryHandle对象，您可以使用getDirectoryHandle（）和getFileHandle（）方法以特定的名称访问其子对象。</p><p> // Create a file named Untiled.txt under root directory. const  untitledFile  =  await  root. getFileHandle( &#34;Untitled.txt&#34;, {  &#34;create&#34;  :  true }); // Get access to existing Untitled.txt file. // untitledFile and existingUntitledFile point to the same entry. const  existingUntitledFile  =  await  root. getFileHandle( &#34;Untitled.txt&#34;); // Create a directory named Diary Folder. const  diaryDirectory  =  await  root. getDirectoryHandle( &#34;Diary Folder&#34;, {  &#34;create&#34;  :  true });</p><p>//创建一个名为Untiled的文件。根目录下的txt。const untitledFile=等待根。getFileHandle（&#34；Untitled.txt&#34；，{&#34；create&#34；：true}）//访问现有的无标题文件。txt文件。//untitledFile和existingUntitledFile指向同一条目。const existingUntitledFile=等待根。getFileHandle（&#34；Untitled.txt&#34；）//创建一个名为“日记文件夹”的目录。const diaryDirectory=wait root。getDirectoryHandle（&#34；日记文件夹&#34；，{&#34；创建&#34；：true}）；</p><p>  To move around the file or directory a  FileSystemHandle represents, you can use the  move() method. The first parameter is a  FileSystemDirectoryHandle representing the target parent directory, and the second parameter is a  USVString representing the target file name. The string must be a  valid file name.</p><p>要在FileSystemHandle表示的文件或目录中移动，可以使用move（）方法。第一个参数是代表目标父目录的FileSystemDirectoryHandle，第二个参数是代表目标文件名的USVString。字符串必须是有效的文件名。</p><p> // Move Untitled.txt from /root/ to /root/Diary Folder/. await  untitledFile. move( diaryDirectory,  untitledFile. name); // Rename Untitled.txt to Feb_01.txt await  untitledFile. move( diaryDirectory,  &#34;Feb_01.txt&#34;); // The two steps above can be combined as: // await untitledFile.move(diaryDirectory, &#34;Feb_01.txt&#34;);</p><p>//移动无标题。txt从/root/到/root/Diary文件夹/。等待untitledFile。移动（日记目录，untitledFile.name）；//改名为Untitled。txt至2001年2月。txt等待untitledFile。move（日记目录，&#34；Feb#u 01.txt&#34；）//以上两个步骤可以组合为：//wait untitledFile。move（日记目录，&#34；Feb#u 01.txt&#34；）；</p><p>  To find out if a  FileSystemHandle is a descendant of an existing  FileSystemDirectoryHandle, and to get their relative path, you can use the  resolve() method. The result is an array of component names that forms the path.</p><p>要确定FileSystemHandle是否是现有FileSystemDirectoryHandle的后代，并获取它们的相对路径，可以使用resolve（）方法。结果是形成路径的组件名称数组。</p><p> // Get access to Feb_01.txt in Diary Folder. const  diaryFile  =  await  diaryDirectory. getFileHandle( &#34;Feb_01.txt&#34;); // Resolve path between Feb_01.txt and root. const  relativePath  =  await  root. resolve( diaryFile); // relativePath is [&#34;Diary Folder&#34;, &#34;Feb_01.txt&#34;].</p><p>//访问2月1日。日志文件夹中的txt。const diaryFile=wait diaryDirectory。getFileHandle（&#34；Feb_01.txt&#34；）//解析2月1日之间的路径。txt和root。const relativePath=等待根。解析（日记文件）；//relativePath是[&#34；日记文件夹&#34；，&#34；Feb#u 01.txt&#34；]。</p><p>  The methods introduced above require you to know the name of target, but if you don’t know the name, you can still get it by enumerating the contents of an existing directory with  async iterators returned by the  keys(),  values(), and  entries() methods.</p><p>上面介绍的方法要求您知道目标的名称，但是如果您不知道名称，您仍然可以通过使用keys（）、values（）和entries（）方法返回的异步迭代器枚举现有目录的内容来获得它。</p><p> // Create a directory named Trash under the root directory. const  trashDirectory  =  await  root. getDirectoryHandle( &#34;Trash&#34;, {  &#34;create&#34;  :  true }); // Find directories under root/ and print their names. const  directoryNames  = []; for  await ( const  handle  of  root. values()) {  if ( handle. kind  = =  &#34;directory&#34;) {  directoryNames. push( handle. name); }} // directoryNames is [&#34;Trash&#34;, &#34;Diary Folder&#34;].</p><p>//在根目录下创建一个名为Trash的目录。const trashDirectory=wait root。getDirectoryHandle（&#34；垃圾&#34；，{&#34；创建&#34；：true}）；//在root/下查找目录并打印它们的名称。const directoryNames=[]；for await（root.values（）的常量句柄）{if（handle.kind==&#34；directory&#34；）{directoryNames.push（handle.name）；}}//目录名是[&#34；垃圾和#34；&#34；日记文件夹和#34；]。</p><p>  With a  FileSystemDirectoryHandle object, you can delete its child entries by name with the  removeEntry() method.</p><p>对于FileSystemDirectoryHandle对象，可以使用removentry（）方法按名称删除其子项。</p><p> // Delete Feb_01.txt in Diary Folder. await  diaryDirectory. removeEntry( diaryFile. name); // Delete Trash and all its descendants. await  root. removeEntry( trashDirectory. name, {  &#34;recursive&#34;  :  true });</p><p>//删除2月1日。日志文件夹中的txt。等待日记目录。removentry（diaryFile.name）；//删除垃圾及其所有后代。等待根。removeEntry（trashDirectory.name，{&#34；recursive&#34；：true}）；</p><p>  Once you have the  FileSystemFileHandle representing the target file, you can read its properties and content by converting it to a   File object using the  getFile() method. You can get file information and content using interfaces of  File.</p><p>一旦有了表示目标文件的FileSystemFileHandle，就可以通过使用getFile（）方法将其转换为文件对象来读取其属性和内容。您可以使用文件的接口获取文件信息和内容。</p><p>   Another way to read a file is to use the  read() method of the  FileSystemSyncAccessHandle interface. You can create a  FileSystemSyncAccessHandle from a  FileSystemFileHandle object using the  createSyncAccessHandle() method. Since  FileSystemSyncAccessHandle is only available in Worker contexts, you will need to  create a dedicated Worker first.</p><p>读取文件的另一种方法是使用FileSystemSyncAccessHandle接口的read（）方法。可以使用createSyncAccessHandle（）方法从FileSystemFileHandle对象创建FileSystemSyncAccessHandle。由于FileSystemSyncAccessHandle仅在工作上下文中可用，因此需要先创建一个专用的工作上下文。</p><p> Unlike  getFile() that returns a Promise,  read() is synchronous, and thus provides better performance. If you’re aiming for the most efficient file access,  FileSystemSyncAccessHandle is the way to go.</p><p>与返回承诺的getFile（）不同，read（）是同步的，因此提供了更好的性能。如果您的目标是实现最高效的文件访问，那么FileSystemSyncAccessHandle就是最佳选择。</p><p> To write a file, you can use the synchronous  write() method of  FileSystemSyncAccessHandle. In the current implementation, this is the only way to write a file in WebKit.</p><p>要编写文件，可以使用FileSystemSyncAccessHandle的synchronous write（）方法。在当前的实现中，这是在WebKit中编写文件的唯一方法。</p><p> To implement synchronous read and write operations, a  FileSystemSyncAccessHandle must have exclusive access to a file entry. Therefore, the attempt to create a second  FileSystemSyncAccessHandle on an entry will fail, if the previous  FileSystemSyncAccessHandle is not closed properly.</p><p>要实现同步读写操作，FileSystemSyncAccessHandle必须以独占方式访问文件条目。因此，如果前一个FileSystemSyncAccessHandle未正确关闭，则尝试在条目上创建第二个FileSystemSyncAccessHandle将失败。</p><p> // Get access to the existing Draft.txt file. const  root  =  await  navigator. storage. getDirectory(); const  draftFile  =  await  root. getFileHandle( &#34;Draft.txt&#34;); // Create FileSystemSyncAccessHandle on the file. const  accessHandle  =  await  draftFile. createSyncAccessHandle(); // Get size of the file. const  fileSize  =  await  accessHandle. getSize(); // Read file content to a buffer. const  readBuffer  =  new  ArrayBuffer( fileSize); const  readSize  =  accessHandle. read( readBuffer, {  &#34;at&#34; :  0 }); // Write a sentence to the end of the file. const  encoder  =  new  TextEncoder(); const  writeBuffer  =  encoder. encode( &#34;Thank you for reading this.&#34;); const  writeSize  =  accessHandle. write( writeBuffer, {  &#34;at&#34;  :  readSize }); // Truncate file to 1 byte. await  accessHandle. truncate( 1); // Persist changes to disk. await  accessHandle. flush(); // Always close FileSystemSyncAccessHandle if done. await  accessHandle. close();</p><p>//获取现有草稿。txt文件。const root=等待导航器。存储getDirectory（）；const draftFile=wait root。getFileHandle（&#34；Draft.txt&#34；）//在文件上创建FileSystemSyncAccessHandle。const accessHandle=wait draftFile。createSyncAccessHandle（）；//获取文件的大小。const fileSize=wait accessHandle。getSize（）；//将文件内容读取到缓冲区。const readBuffer=new ArrayBuffer（文件大小）；const readSize=accessHandle。read（readBuffer，{&#34；at&#34；：0}）；//在文件末尾写一个句子。const encoder=new textcoder（）；const writeBuffer=编码器。encode（&#34；感谢您阅读本文。&#34；）；const writeSize=accessHandle。write（writeBuffer，{&#34；at&#34；：readSize}）；//将文件截断为1字节。等待访问句柄。截断（1）；//将更改保存到磁盘。等待访问句柄。flush（）；//如果完成，请始终关闭FileSystemSyncAccessHandle。等待访问句柄。close（）；</p><p>  If your web app needs to interact with files, you should try the new File System Access API. It provides interfaces that are similar to the native file system API, with optimized performance.</p><p>如果你的web应用需要与文件交互，你应该尝试新的文件系统访问API。它提供了类似于本机文件系统API的接口，具有优化的性能。</p><p> As the standard evolves and development goes on, we will keep adding or updating interfaces and methods according to the  File System Access API spec. If you encounter any issue when using this API, please file a bug on  bugs.webkit.org under the “Website Storage” component. You may also create a new bug report for feature requests, describing your use case and why the feature is important. If you have any question or suggestion about the API itself, you can file a spec issue in the  WICG repo. Your feedback is very important to us.</p><p>随着标准的发展和发展，我们将根据文件系统访问API规范不断添加或更新接口和方法。如果您在使用此API时遇到任何问题，请在bug上提交bug。webkit。“网站存储”组件下的组织。您还可以为功能请求创建一个新的bug报告，描述您的用例以及该功能的重要性。如果您对API本身有任何疑问或建议，可以在WICG repo中提交规范问题。你的反馈对我们非常重要。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/访问/">#访问</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/supports/">#supports</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>