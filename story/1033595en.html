<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>图灵完备性问题</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">图灵完备性问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:08:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/588a96d6002ca4532492f7f791645b37.png"><img src="http://img2.diglog.com/img/2020/11/588a96d6002ca4532492f7f791645b37.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Can we write programs with predictable execution that could be automatically parallelized? Part of the work of Alan Turing and Alonzo Church on  computability demonstrated that for some programs it cannot be determined ahead of time whether or not the program can be computed. This constitutes the crux of the  Halting Problem. This &#34;Turing-Completeness Problem&#34; is not an issue with what they have shown, but how the software development process is hindered by the lack of assurances on computability and our industry&#39;s lack of recognition of the burden this has put onto software developers. Further, it has been exacerbated by recent computing mechanisms, such as multithreading, NUMA, GPGPU, and distributed computing, which have moved away from the &#34;single tape&#34; Turing Machine model of computation that most programming languages are founded upon.</p><p>我们能否编写具有可预测执行的程序，这些程序可以自动并行化？艾伦·图灵(Alan Turing)和阿隆佐·丘奇(Alonzo Church)在可计算性方面的部分工作表明，对于某些程序来说，无法提前确定该程序是否可以计算。这构成了停顿问题的症结所在。图灵完整性问题不是他们所展示的问题，而是软件开发过程如何因为缺乏对可计算性的保证，以及我们的行业没有认识到这给软件开发人员带来的负担而受阻。此外，最近的计算机制(如多线程、NUMA、GPGPU和分布式计算)进一步加剧了这种情况，这些机制已经脱离了大多数编程语言所基于的图灵机计算模型。</p><p> The following snippet of C code succinctly contains the problems of Turing completeness complicating modern development:</p><p>下面的C代码片段简洁地包含了使现代开发复杂化的图灵完整性问题：</p><p>  Automatic Parallelization - It&#39;s not possible to automatically parallelize this code. The number of nodes is not clear to the compiler for it to potentially bunch those calls across threads, and it&#39;s also unclear if the function call mutates the node and adds/removes nodes to process.</p><p>自动并行化-它不可能自动并行化这段代码。对于可能跨线程捆绑这些调用的编译器来说，节点数并不清楚，也不清楚函数调用是否会改变节点并添加/删除要处理的节点。</p><p> Halting Problem - It&#39;s not possible to know if the code will halt, even ignoring the idea that  doSomethingWith may always add a new  node to the one it is processing, there&#39;s nothing stopping a node from pointing at itself and never halting that way.</p><p>停止问题--它不可能知道代码是否会停止，甚至忽略了这样一个想法：使用do SomethingWith可能总是向它正在处理的节点添加一个新节点，没有什么可以阻止节点指向自己，并且永远不会以这种方式停止。</p><p> Automatic parallelization is only a problem because we want/need to parallelize our code. Until very recently this was a niche need as  computing power had been increasing exponentially for decades and has only flattened in the past decade. If this was still the case it is likely that it would have remained a niche problem that only experts need to worry about, but with multicore now the norm even in personal laptops and unlikely to go away as  signal propagation itself becomes the limiting factor, it has become a problem for the average developer, as well.</p><p>自动并行化只是一个问题，因为我们想/需要并行化我们的代码。直到最近，这还只是一种利基需求，因为计算能力几十年来一直呈指数级增长，在过去十年才趋于平缓。如果情况仍然如此，它很可能仍然是一个只有专家才需要担心的利基问题，但随着多核现在甚至在个人笔记本电脑中也是常态，而且随着信号传播本身成为限制因素，它不太可能消失，它也成为了普通开发者的问题。</p><p> The issue with the Halting Problem itself is much more contentious. Turing demonstrated that it is not possible to determine whether arbitrary compute will halt or run forever so this lack of determinism has been tolerated as an unfortunate reality of all compute that must simply be dealt with. However, we posit that no  practially useful computation will take forever because its result cannot affect the finite reality of our lives, so programmers have already been finding an imperfect subset of Turing completeness for their own problem domains in an ad-hoc intuitive sense to be able to actually produce valuable calculations for their users.</p><p>停顿问题本身的争议要大得多。图灵证明，不可能确定任意计算是否将停止或永远运行，因此这种缺乏决定论一直被容忍为所有必须简单处理的计算的不幸现实。然而，我们假设没有任何实际有用的计算会永远持续下去，因为它的结果不会影响我们生活的有限现实，所以程序员已经在特别直观的意义上为他们自己的问题域找到图灵完备性的一个不完美的子集，以便能够真正为他们的用户产生有价值的计算。</p><p> In a single-threaded world, this problem has been mostly a small annoyance -- on those occasions where you have written infinitely-looping code, find the section of code that the processor is executing over and over again, study how it entered this state, and figure out how to prevent that state from occurring again -- or abort on detection of said state. But in a multi-threaded, multi-machined cluster computing world, on those occasions where you have written an infinite loop, even detecting an infinite loop that spans multiple machines is a challenge, let alone gathering the data you need to debug the cause of this invalid state. This is further exacerbated by the non-determinism inherent to multiple interacting Turing machines not executing in lockstep with each other making reproduction of the problem even more difficult.</p><p>在单线程环境中，这个问题主要是一个小麻烦--当您编写无限循环代码时，找到处理器反复执行的代码段，研究它是如何进入这种状态的，并找出如何防止该状态再次发生--或者在检测到该状态时中止。但是在多线程、多机器的集群计算世界中，在编写无限循环的情况下，即使检测跨越多台机器的无限循环也是一项挑战，更不用说收集调试这种无效状态的原因所需的数据了。多台相互作用的图灵机器不能同步执行所固有的不确定性进一步加剧了这一问题，这使得问题的再现变得更加困难。</p><p> Side-stepping the Halting Problem by defining a barely-Turing-incomplete subset, also makes the automatic parallelization story possible. Now the compiler can work with code that it can determine where and how it could parallelize the work and has the ability to model its finite execution time to determine whether or not parallelization is worth it under various conditions.</p><p>通过定义一个勉强不完整的图灵子集来避开停顿问题，也使得自动并行化成为可能。现在，编译器可以使用可以确定在哪里以及如何并行化工作的代码，并且能够对其有限的执行时间进行建模，以确定在各种条件下并行化是否值得。</p><p> This is the thesis of  the Alan programming language, that with minor syntax constraints (that we believe the vast majority of developers will not notice, or at least won&#39;t mind) we can be sure that the code you write always halts, and we can parallelize your code for you. We can make models for runtime estimates at compile time that only require the size and &#34;shape&#34; of the data to get an answer and can therefore determine not only how to parallelize your code, but whether or not it makes sense given the data being operated on. We have not yet accomplished all of these claims, but this is now only a matter of time and effort. :)</p><p>这就是Alan编程语言的主题，即只要有很小的语法约束(我们相信绝大多数开发人员不会注意到，或者至少不会注意到)，我们可以确保您编写的代码总是停止，并且我们可以为您并行化您的代码。我们可以在编译时为运行时估计建立模型，这些模型只需要数据的大小和形状就可以得到答案，因此不仅可以确定如何并行化代码，而且可以确定在给定要操作的数据的情况下是否有意义。我们还没有完成所有这些要求，但现在这只是一个时间和努力的问题。：)。</p><p> The root of most of the problems with the example C code involves the ambiguity in the data structure and the behavior of the user-defined function. The other problem is that the while loop is an unbounded looping construct that cannot be reasoned about except &#34;the body of the while loop is executed zero or more times.&#34; In Alan,  arbitrary looping and recursion are disallowed, and all data is built on top of data types with knowable constraints, no arbitrary JUMP statements or data pointer logic allowed.</p><p>示例C代码的大多数问题的根源在于数据结构和用户定义函数的行为不明确。另一个问题是，While循环是一个无界循环构造，除了While循环的主体被执行零次或多次之外，无法对其进行推理。&#34；在Alan中，不允许任意循环和递归，并且所有数据都建立在具有可知约束的数据类型之上，不允许任意跳转语句或数据指针逻辑。</p><p> What this means in practice is that instead of writing that while loop above for your list of nodes, you would write something like:</p><p>实际上，这意味着不是在上面为节点列表编写While循环，而是编写如下内容：</p><p>  Your intent to perform a side-effect action on each of the nodes in the list is clear, and the Alan compiler can determine the &#34;purity&#34; of the function -- whether or not it mutates the input argument or an outer scope -- to determine if it  could execute the operations in parallel. Then at runtime it can use the estimated execution time of the function, the number of nodes in the  nodes array, and the cost to distribute that work across multiple threads, to decide  if it will execute the operations in parallel.</p><p>对列表中的每个节点执行副作用操作的意图很明显，Alan编译器可以确定函数的纯度--它是否改变了输入参数或外部作用域--以确定它是否可以并行执行这些操作。然后，在运行时，它可以使用函数的估计执行时间、节点数组中的节点数以及跨多个线程分配工作的成本来决定是否并行执行这些操作。</p><p>  fn example(file1: string, file2: string): Array&lt;Array&lt;int64&gt;&gt; { const matrix1 = loadFile(file1).parseMatrix() const matrix2 = loadFile(file2).parseMatrix() return matrix1 * matrix2}</p><p>Fn示例(file1：string，File2：string)：Array&lt；Array&lt；int64&gt；&gt；{const matrix1=loadFile(File1).parseMatrix()const matrix2=loadFile(File2).parseMatrix()return matrix1*matrix2}。</p><p> Not only is the matrix multiplication a trivially parallelizable operation that likely will be parallelized for any large-ish matrix, but reading the files from disk and then parsing their contents may be done in parallel before the matrix multiplication because the performance benefit is there to do so.</p><p>矩阵乘法不仅是一个微不足道的可并行化操作，对于任何大型矩阵都有可能并行化，而且从磁盘读取文件然后解析其内容可能会在矩阵乘法之前并行完成，因为这样做会带来性能上的好处。</p><p> To accomplish automatic parallelization, we need something different from a classic Turing tape to compile to. We call this the Alan Graphcode: a bytecode format with graph annotations that is guaranteed to have no cycles. A dependency graph of operations to perform, with some of these also having a subgraph of operations to perform, provides us with the information we need to know which operations are safe to execute in parallel, coupled with (implied) operation execution time estimates to determine if it makes sense to do so.</p><p>要实现自动并行化，我们需要一些与传统图灵磁带不同的东西来编译。我们称之为Alan Graphcode：一种带有图形注释的字节码格式，保证没有循环。要执行的操作的依赖图(其中一些操作还具有要执行的操作子图)为我们提供了了解哪些操作可以安全并行执行所需的信息，以及(隐含的)操作执行时间估计，以确定这样做是否有意义。</p><p> Alan&#39;s acyclic graphcode seems incompatible with any sort of control flow at first glance, though, since a dependency graph of operations that must all be executed appears to preclude the behavior of  JUMP operations, like the classic  JNZ (Jump if Not Zero).  Alan allows  if statements and even  guaranteed halting versions of classic looping constructs are in a standard library that provide a predictable &#34;worst case&#34; execution time based on a maximum iteration count allowed. We will demonstrate how Alan allows control flow with a graph-based representation that makes automatic parallelization possible.</p><p>乍一看，Alan的非循环图形代码似乎与任何类型的控制流不兼容，因为必须全部执行的操作的依赖图似乎排除了跳转操作的行为，就像经典的JNZ(Jump If Not Zero)。Alan允许IF语句甚至经典循环构造的有保证的暂停版本都在一个标准库中，该库根据允许的最大迭代次数提供可预测的最坏情况执行时间。我们将演示Alan如何通过基于图形的表示来允许控制流，从而使自动并行化成为可能。</p><p>  Here two operations  OP1 and  OP2 run, then a  JNZ runs. If the check is not zero, it skips to only run  OP5 and  OP6, otherwise it runs  OP3 and  OP4 before running  OP5 and  OP6.</p><p>这里运行两个操作OP1和OP2，然后运行JNZ。如果检查不是零，它跳到只运行op5和op6，否则在运行op5和op6之前运行op3和op4。</p><p>  var a = op1();var b = op2(a);if (b) { var c = op3(); a = op4(c);}var d = op5(a);return op6(d);</p><p>Var a=op1()；var b=op2(A)；如果(B){var c=op3()；a=op4(C)；}var d=op5(A)；返回op6(D)；</p><p>   Here, the conditional call is a special  COND node that may or may not execute the specified graph named  if. All of the nodes of the main graph are executed, but the  COND operation may or may not execute the inner subgraph. There is absolutely no parallelization possible based on the set of dependencies, but it&#39;s clear that  OP5 can&#39;t run until both  OP1 and  COND(if) are run.</p><p>在这里，条件调用是一个特殊的Cond节点，它可能执行也可能不执行名为if的指定图。主图的所有节点都会执行，但Cond操作可能会执行内部子图，也可能不会执行。基于依赖关系集，绝对不可能进行并行化，但很明显，op5在op1和cond(If)都运行之前不能运行。</p><p> Back to classic Turing machines, what is the opposite of an  if statement in a Turing tape? It&#39;s not  else if or  else as those are just other forward jumps on different conditions. The opposite of an  if is a  do-while statement, because that is a jump  backwards.</p><p>回到经典的图灵机，图灵磁带中if语句的反义词是什么？这不是其他的如果或者不是，因为这些只是在不同条件下的其他向前跳跃。If的对立面是do-While语句，因为这是向后跳转。</p><p>  var a = op1();var b = op2(a);do { var c = op3(); a = op4(c); var d = op5(a);} while (d);op6(a);</p><p>Var a=op1()；var b=op2(A)；do{var c=op3()；a=op4(C)；var d=op5(A)；}虽然(D)；op6(A)；</p><p>   Here a  DOWHILE opcode runs the loop sub-graph over and over until the expected condition is met. So with these two special opcodes  COND and  DOWHILE we can reproduce the behavior of  JNZ&#39;s forwards and backwards jumping and we can enter infinite loops with  DOWHILE, meaning we should be Turing Complete.</p><p>在这里，DOWHILE操作码一遍又一遍地运行循环子图，直到满足预期的条件。因此，有了这两个特殊的操作码COND和DOWHILE，我们就可以重现JNZ向前和向后跳跃的行为，我们可以用DOWHILE进入无限循环，这意味着我们应该是图灵完成的。</p><p> So how do we make this barely  not Turing complete? We make a list/array type a first class citizen in the VM itself and then we only add operations that know the bounds that they are to operate on based on that list or some other condition that cannot be  directly mutated by the user&#39;s own code.</p><p>那么，我们如何才能让图灵几乎不完整呢？我们在VM本身中创建一个列表/数组类型为一等公民，然后根据该列表或其他一些不能被用户自己的代码直接改变的条件，我们只添加知道它们要操作的界限的操作。</p><p> Now for an array of data we can have an  each opcode that applies a given sub-graph of operations to every node in the array. The Alan runtime, or AVM, can tell based on the expected execution time of the graph and the number of nodes and the cost to send that data to multiple threads whether or not to do a fork-join or not. Probably no for 10 elements and probably yes for 10 billion, but where&#39;s the threshold and why? That&#39;s something better left for a computer to decide in realtime based on the data rather than a developer.</p><p>现在，对于数据数组，我们可以使用Each操作码，将给定的操作子图应用于数组中的每个节点。Alan运行时或AVM可以根据图形的预期执行时间、节点数以及将数据发送到多个线程的成本来判断是否执行fork-Join。对于10个元素可能是否定的，对于100亿元素可能是肯定的，但门槛在哪里？为什么？这更好地让计算机根据数据实时做出决定，而不是由开发人员来决定。</p><p> This is the fundamental structure behind  Alan and it&#39;s AVM. There are more goodies around automatic transforms of the graph to better optimize IO that we have partially working right now and automatic rewriting of the graph for stream processing that we&#39;re still figuring out, but with just this we can get better parallelization strategies automatically while keeping your own code short and clean.</p><p>这是艾伦及其AVM背后的基本结构。关于图形的自动转换以更好地优化IO(我们目前正在进行部分工作)和为流处理自动重写图形(我们仍在研究中)有更多的好处，但仅此一点，我们就可以自动获得更好的并行化策略，同时保持您自己的代码简短和干净。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://alan-lang.org/the-turing-completeness-problem.html">https://alan-lang.org/the-turing-completeness-problem.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/完备/">#完备</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>