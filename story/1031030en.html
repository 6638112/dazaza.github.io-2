<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>“抗锈”的表现型系统</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">“抗锈”的表现型系统</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 09:01:21</div><div class="page_narrow text-break page_content"><p>Herein I share an experienced developer&#39;s first foray into a real-world Rust project. It focuses closely on the type system, and the key insights I needed to begin &#34;thinking in Rust&#34;. Written for those getting to grips with the language, it will be especially useful if your background isn&#39;t functional programming.</p><p>在这里，我与大家分享一位经验丰富的开发人员首次涉足现实世界的锈蚀项目。它密切关注类型系统，以及我开始思考铁锈所需要的关键洞察力。它是为那些掌握这门语言的人编写的，如果您的背景不是函数式编程，它将特别有用。</p><p> Although originally conceived as part 2 of 2, this can be read as a standalone entry. In  part 1, written for a general audience, I detail the maker project, a Raspberry Pi Tide Clock, and the heartwarming story behind its origins.</p><p>虽然最初设想为第2部分(共2部分)，但可以将其作为独立条目读取。在为普通读者编写的第1部分中，我详细介绍了Maker项目、一个Raspberry Pi Tide时钟，以及它起源背后的温馨故事。</p><p>   As a working programmer with several mainstream languages under your belt (eg  Java,  C#,  javascript,  python, etc) it&#39;s reasonable to expect that after a bit of orientation with quirks and syntax you&#39;ll find yourself somewhat productive. If you know Rust you won&#39;t be surprised when I say my experience was... humbling.</p><p>作为一名精通几种主流语言(如Java、C#、javascript、python等)的程序员，我们有理由期待，在熟悉了一些怪癖和语法之后，您会发现自己的工作效率有所提高。如果你了解铁锈，当我说我的经历是……时，你不会感到惊讶。令人羞愧。</p><p> The last time I felt so dumb was probably more than a decade ago, as a novice programmer teaching myself Object Orientated Programming (OOP). I think that&#39;s the point, new paradigms require effort to build a working mental model for. And depending on where you start on the ladder you might have quite a lot of mental rebuilding to do.</p><p>我上一次感到如此愚蠢可能是在十多年前，当时我还是一名程序员新手，自学面向对象编程(OOP)。我认为这就是重点，新的范例需要努力为其建立一个有效的心理模型。根据你在阶梯上的起点，你可能有相当多的精神重建工作要做。</p><p> Rust intentionally tries to be &#34;boring&#34;. That is to say, its DNA borrows liberally from prior art. If you&#39;re familiar with manual memory management ( C,  C++,  Obj-C) you&#39;ll probably understand pointers in Rust. If you&#39;re familiar with functional languages ( Haskell,  Elm,  Clojure,  OCaml) you&#39;ll have an immediate start recognising the type system. The reason it aims for boring is because it spends its entire novelty budget on the one unique idea: automatic scope based memory allocation (aka the borrow checker). This is the knockout feature:  the performance of C with the safety of garbage collected languages.</p><p>铁锈故意让人厌烦。也就是说，它的DNA大量借用了现有技术。如果您熟悉手动内存管理(C、C++、Obj-C)，您可能会理解Rust中的指针。如果您熟悉函数式语言(Haskell、Elm、Clojure、OCaml)，您将立即开始识别类型系统。它的目标是枯燥乏味的原因是因为它将整个新奇预算花在一个独特的想法上：基于范围的自动内存分配(也称为借用检查器)。这是击倒一切的特性：C语言的性能与垃圾收集语言的安全性。</p><p> Plenty  of ink  has been  written about ownership and the borrow checker. It follows the most unprecedented feature would have the most said about it. There seems to be a common refrain: &#34; It&#39;s really hard at first, but stick with it. You&#39;ll see, it changes everything&#34;. Sounds suspiciously like Vim or Emacs users (please don&#39;t fight me). Is it the promised land or just a severe case of Stockholm syndrome?</p><p>关于所有权和借阅支票的问题，已经写了很多墨水。它遵循了人们谈论得最多的最史无前例的功能。似乎有一种常见的说法：一开始真的很难，但要坚持下去。你会看到，它改变了一切。听起来像是Vim或Emacs的用户(请不要和我争)。这是应许之地，还是仅仅是斯德哥尔摩综合症的严重病例？</p><p> Nevertheless, extensive reading had prepared me to expect a big ol&#39; messy fight with the borrow checker. We did tussle, but it went better than expected. Ironically, after years of  C# game development, performance concerns have taught me much of the internal dialogue needed to reason about memory lifetimes: &#34;Is this allocated on the stack or heap? Is this going to create allocation (garbage collection) pressure? Is this copying data or mutating it in place?&#34;</p><p>尽管如此，广泛的阅读让我准备好与借阅检查员进行一场激烈的争斗。我们确实发生了争执，但比预想的要好。具有讽刺意味的是，经过多年的C#游戏开发，性能问题教会了我很多关于内存寿命的内部对话：&#34；这是在堆栈还是堆上分配的？这是否会造成分配(垃圾收集)压力？这是在原地复制数据还是改变数据？&#34；</p><p> In this sense, when the borrow checker complained I could at least appreciate what it was trying to protect me against. And as to be expected, it may be a while yet before I fully grok lifetimes. Controversially though, &#34;Rust&#39;s expressive type system&#34; put up a stiffer fight than I anticipated.</p><p>从这个意义上说，当借阅检查员抱怨时，我至少可以欣赏它试图保护我免受的伤害。不出所料，我可能还需要一段时间才能完全摸索人生。然而，有争议的是，铁锈的表现型系统进行了一场比我预期的更艰难的斗争。</p><p>  Before anyone grabs a pitchfork, this isn&#39;t a rant about the unnecessary burden of type systems. Throughout my career, I&#39;ve favoured statically and strongly typed programming languages. I believe in correctness, and tooling should help you get there. It&#39;s why Rust excites me.</p><p>在任何人拿起干草叉之前，这并不是在抱怨类型系统不必要的负担。在我的职业生涯中，我一直偏爱静态和强类型的编程语言。我相信正确性，而工具应该会帮助您做到这一点。这就是铁锈让我兴奋的原因。</p><p> Taken to its ultimate conclusion, one arrives at  Haskell and other pure functional programming (FP) languages. FP&#39;s conceit is trading performance for correctness. As a concerned game developer, this never felt like a bargain I could entertain. Not that it&#39;s prevented FP idioms from seeping into the groundwater of other programming languages (see  LINQ in  C# or  map() filter() reduce() in  javascript as examples).</p><p>作为最终结论，我们来到了Haskell和其他纯函数式编程(FP)语言。FP&#39；的自负是用性能来换取正确性。作为一名忧心忡忡的游戏开发者，我从来没有觉得这是一笔可以讨价还价的东西。这并不是说它阻止了FP习惯用法渗入其他编程语言的地下水(参见C#中的LINQ或JavaScript中的map()filter()filter()Reduce()作为示例)。</p><p> You can see signs of this functional DNA written all over Rust too, immutability by default being the most obvious. However, Rust strikes a wonderfully pragmatic balance. Imperative programming is not outlawed, and many escape hatches exist. Rust is, as far as I&#39;m aware,  the first language that allows you to deploy functional concepts as zero-cost abstractions. If the borrow checker is the obvious hit single, this is the real album sleeper hit.</p><p>您也可以在铁锈上看到这种功能DNA的迹象，默认情况下，不变性是最明显的。然而，“铁锈”达到了惊人的务实平衡。命令式编程并不是非法的，而且存在许多逃生舱。据我所知，Rust是第一种允许您将函数概念部署为零成本抽象的语言。如果借阅检查器是显而易见的热门单曲，那么这就是真正的专辑卧铺热门。</p><p> I think my undoing was simply that I had a false expectation of equivalence. I&#39;m confident in my type literacy and I can, if we must, talk in-depth about Java design patterns. I&#39;ve never courted a &#34;proper&#34; functional language, but I recognise their influence. I understood &#34;expressive type system&#34; to be a superset of what I already know. In some respects it is, but in others, it was fundamentally different. I want to share some of my &#34;aha&#34; moments because I haven&#39;t seen much written with this lens...</p><p>我认为我的失败只是因为我对等价物抱有错误的期望。我对我的类型识别力很有信心，如果有必要的话，我可以深入讨论Java设计模式。我从来没有追求过一种恰当的功能语言，但我认识到它们的影响。我认为表现型系统是我已经知道的内容的超集。在某些方面是这样的，但在另一些方面，它是根本不同的。我想和大家分享我的一些瞬间，因为我还没有看到太多用这个镜头写的东西。</p><p>  To anyone following my footsteps:  setup your dev environment for code intelligence and type hints is my best advice. I intentionally offer it here before any code samples make you glaze over and miss it.</p><p>对于任何追随我脚步的人：为代码智能和类型提示设置您的开发环境是我最好的建议。我特意在这里提供它，以免任何代码样本让您目瞪口呆并错过它。</p><p>  At the time of writing (Oct 2020), I found Visual Studio Code with the   rust-analyzer extension to be the most reliable path. I learnt this only after naively installing the   Rust extension, which provides a front end for both the earlier   RLS and the more modern   rust-analyzer. However, in my experience, the native  rust-analyzer extension was vastly superior.</p><p>在撰写本文时(2020年10月)，我发现带有锈蚀分析器扩展的Visual Studio代码是最可靠的途径。我只是在幼稚地安装了Rust Extension之后才学会了这一点，它为早期的RLS和更现代的防锈分析仪提供了一个前端。然而，根据我的经验，本地的防锈分析仪要好得多。</p><p>  If you can express something as a type, the compiler can offer you guarantees about it. An expressive type system allows you to model domains that weren&#39;t possible before, often using simpler machinery too. Rust takes this affordance and runs with it. Types are used for everything, and I do mean  everything. A lot of problems didn&#39;t quite make sense until I learnt to recognise them for what they were: type errors.</p><p>如果您可以将某些内容表示为类型，则编译器可以为您提供有关它的保证。富于表现力的类型系统允许您对以前不可能实现的领域进行建模，通常也使用更简单的机器。拉斯特接受了这一启示，并随波逐流。类型用于所有事情，我的意思是说所有事情都是类型。很多问题都没有多大意义，直到我学会认识到它们的本质：打字错误。</p><p> However, starting out, there are a few obvious differences I&#39;d put into the &#34;quirks&#34; category. They seem foreign and strange, but acclimatisation comes quickly. I&#39;ll only briefly touch on them for those who&#39;ve never seen Rust before. Exhaustive coverage exists in  the Rust book and  elsewhere.</p><p>然而，一开始，我把一些明显的不同之处归入了怪癖类别。他们看起来既陌生又陌生，但适应很快就会到来。我只为那些从未见过“锈”的人简单介绍一下。在“铁锈”一书和其他地方都有详尽的报道。</p><p>  pub  struct    {  pub x :  f32 ,  // f32 = 32 bit floating point number type   pub y :  f32 ,  pub z :  f32 }</p><p>Pub struct{pub x：f32，//f32=32位浮点数类型pub y：f32，pub z：f32}。</p><p>   pub  struct    {  pub x :  f32 ,  pub y :  f32 ,  pub z :  f32 } impl    {	 pub  fn  init (x : f32 , y : f32 , z : f32 ) -&gt;   {			 //Create and return a new struct		  {			x ,			y ,			z ,		 }	 } }</p><p>Pub struct{pub x：f32，pub y：f32，pub z：f32}impl{pub FN init(x：f32，y：f32，z：f32)-&gt；{//创建并返回新结构{x，y，z，}。</p><p> &#34;Okay, separate  impl blocks seem like a weird choice. Kinda reminds me of  C header files...&#34;</p><p>好吧，分开的Iml积木看起来是个奇怪的选择。有点让我想起C头文件...&#34；</p><p> Calling methods defined in types is done with a  C++ like syntax, e.g.  Type::method_name(). However, once an instance exists (aka memory has been allocated), members are accessed with regular dot syntax, e.g.  instance.method_name():</p><p>调用类型中定义的方法使用类似于C++的语法，例如Type：：Method_Name()。但是，一旦实例存在(也就是分配了内存)，就会使用常规的点语法访问成员，例如instance.method_name()：</p><p> fn  main ( )  {  let position  =   :: init ( 0.0 ,  1.0 ,  0.0 ) ;  //Type resolution  let y  = position .y ;  // Instance Resolution }</p><p>Fn main(){let position=：：init(0.0，1.0，0.0)；//类型分辨率let y=position.y；//实例分辨率}。</p><p>  pub  struct    {  pub x :  f32 ,  pub y :  f32 ,  pub z :  f32 } // Define a shared API trait    {  fn  draw ( &amp; self ) ; } // Implement concrete behaviour on the MyData struct impl    for    {		 //Self works like &#39;this&#39;. Sort of...	 //The difference is we have to declare it manually  fn  draw ( &amp; self )  {  //Draw item using self.x, self.y, self.z  } }</p><p>Pub struct{pub x：f32，pub y：f32，pub z：f32}//定义共享API特征{fn raw(&amp；self)；}//在MyData struct Impll上实现具体行为，{//self类似于&#39；this&#39；。有点像是..。//不同之处在于我们必须手动声明FN Draw(&amp；self){//使用self.x，self.y，self.z}绘制项目}。</p><p> &#34;Okay, so like  Trait is just a different way to spell  Interface? Gotcha. But no inheritance? That&#39;s pretty wild. But composition over inheritance, am I right?&#34;</p><p>好的，那么LIKE特征只是一种不同的接口拼写方式？抓到你了。但是没有遗产吗？那太疯狂了。但是组合胜过继承，我说得对吗？</p><p> Now that we&#39;ve implemented the  Drawable Trait, we can call its methods on our struct:</p><p>既然我们已经实现了可绘制特征，我们就可以在我们的struct上调用它的方法了：</p><p>  That&#39;s enough for now, but know there are other plenty of other commendable  type features, some of which we&#39;ll discuss later.</p><p>现在这已经足够了，但是我们知道还有很多其他值得称赞的类型功能，我们稍后会讨论其中的一些。</p><p>  Giant monolithic classes are considered a code smell. A signal that responsibilities need to be separated into separate concerns. Still, OOP maintains the feeling of discrete units. Data and behaviour are contained within the cell walls of the class, or at least within the inheritance chain.</p><p>巨大的单块类被认为是一种代码气味。这是一个信号，表明责任需要被分成不同的关注点。尽管如此，OOP仍然保持了分立单元的感觉。数据和行为包含在类的胞壁中，或者至少包含在继承链中。</p><p> Rust, by comparison, feels inside out, &#34;itty bitty&#34; and piecemeal. What might have been a single class is instead an accumulation of structs and traits, each defining their own narrow window into data and behaviour.  In this talk, the creator of Clojure, another functional language, describes this quality as &#34;ad-hoc polymorphism&#34;. Using only what you need, when you need it. This granular approach maximises the immutable surface area, mutability is limited to where it&#39;s necessary.</p><p>相比之下，生锈给人的感觉是由里到外，零星零碎。本来可能是单个类的东西反而是结构和特征的累积，每个结构和特征都定义了自己的数据和行为的狭窄窗口。在这次演讲中，另一种函数式语言Clojure的创建者将这种特性描述为即席多态性。在你需要的时候，只使用你需要的东西。这种颗粒状的方法最大化了不变的表面积，易变性被限制在它需要的地方。</p><p> In the flame wars of &#34;was OOP a giant mistake?&#34;, it&#39;s debatable whether  Rust allows you to write OOP code. I understand this now not as a wholesale rejection: abstraction and encapsulation remain necessary tools. However, Rust forces you to leave behind features ardents consider harmful, inheritance being the obvious example. Call it &#34;OOP, the good bits&#34; if you will.</p><p>在激烈的战争中，OOP是一个巨大的错误吗？Rust是否允许你编写OOP代码是值得商榷的。我现在理解这并不是完全拒绝：抽象和封装仍然是必要的工具。然而，铁锈迫使你留下狂热者认为有害的特征，继承就是一个明显的例子。如果你愿意，可以称之为“好点子”(the Good Bits&34；OOP)。</p><p> Ideas like composition over inheritance or separating data from behaviour have been around for a long time within the OOP world. However, FP encourages new principles, determinism and the avoidance of side effects. Let&#39;s look at an example.</p><p>组合重于继承或将数据与行为分离等思想在OOP世界中已经存在很长一段时间了。然而，FP鼓励新的原则、决定论和避免副作用。让我们来看一个例子。</p><p>  Tony Hoare, the inventor of the null pointer called it  his billion-dollar mistake. Any programmer knows the misery of finding an error log littered with  Null Reference Exception. But  null values are fundamental, like the oxygen we breathe. Whenever I tried to contemplate an alternative I suffered a failure of imagination.  &#34;No null values? Far out man.&#34;</p><p>零指针的发明者托尼·霍尔(Tony Hoare)称这是他数十亿美元的错误。任何程序员都知道查找散布着Null引用异常的错误日志的痛苦。但零值是基本的，就像我们呼吸的氧气一样。每当我试图考虑另一种选择时，我都会遭遇想象力的失败。&#34；是否没有空值？很远的人。&#34；</p><p> For a while, in prior languages, I attempted to answer this question by initialising variables with a default value instead of  null. That worked when the default value meant something, otherwise, it just piped junk data into the system. Still, in successful cases, I began to appreciate the guarantee it offered. Any downstream code could trust a variable would be valid and not have to muddy itself with unexpected exceptions.</p><p>有一段时间，在以前的语言中，我试图通过用缺省值而不是NULL来初始化变量来回答这个问题。当缺省值有意义时，这是有效的，否则，它只是将垃圾数据输送到系统中。尽管如此，在成功的案例中，我开始欣赏它提供的保证。任何下游代码都可以相信变量是有效的，并且不会因为意外的异常而使自身变得混乱。</p><p> Software is such that, unfortunately, there will always be cases where initialisation or access of a resource fails. FP provides us with a more complete answer here. It correctly recognises  valid|invalid or  success|failure as a separate concern from the referencing of data. It does so by shifting responsibility to a separate type.</p><p>不幸的是，软件总是会有资源初始化或访问失败的情况。FP在这里为我们提供了一个更完整的答案。它正确地将有效|无效或成功|失败识别为独立于数据引用的关注点。它通过将责任转移到一个单独的类型来做到这一点。</p><p>  var item  : Item  =  GetItem ( ) ; if (item  !=  null )  {  //Do something with resource   print (item ) ;  } function GetItem  :  Item  ( )  {  if ( /*success*/ )  {  var newItem  =  new   ( ) ;  return newItem ;  }  return  null ; }</p><p>Var Item：Item=GetItem()；If(Item！=null){//处理资源print(Item)；}函数GetItem：Item(){if(/*Success*/){var newItem=new()；return newItem；}return null；}。</p><p> Let&#39;s rewrite that in Rust. For the sake of comparison I&#39;m using a non-idiomatic style:</p><p>让我们在“铁锈”中重写这一点。为了便于比较，我使用了一种非惯用风格：</p><p> let item_option  =  get_item ( ) ; match item_option  {   (item )  =&gt;  {  //Do something with resource  println! ( &#34;{}&#34; , item ) ;  }    =&gt;  { } } ; fn  get_item ( )  -&gt;   &lt;  &gt;  {  if  /* success */  {  let new_item  =    { } ;  return   (new_item ) ;  }  return   ; }</p><p>让Item_Option=Get_Item()；Match Item_Option{(Item)=&gt；{//使用资源println！(&#34；{}&34；，Item)；}=&gt；{}}；fn get_Item()-&gt；&lt；&gt；{if/*Success*/{let new_item={}；return(New_Item)；}返回；}。</p><p> What&#39;s going on here? If we look at the  get_resource() function, we see it returns  None when it fails. Is that just a different way to spell  null? Well not exactly, the key is the return type  Option&lt;Item&gt;. The type  Item defines the bit we care about, but what&#39;s the  Option&lt;...&gt; malarkey around it?  Option is a generic structure that comes with Rust, to understand it lets take a closer look:</p><p>这是怎么回事？如果我们查看get_resource()函数，我们会看到它在失败时返回NONE。这只是另一种拼写null的方式吗？不完全是，关键是返回类型选项&lt；item&gt；。类型项定义了我们关心的位，但是围绕它的选项是什么？Option是Rust附带的通用结构，为了理解它，让我们仔细看看：</p><p>  We can see this is very simple, it&#39;s just an enum with two values,  Some(T) and  None. The generic placeholder,  T, allows us to compose in our payload, as we did with  Option&lt;Item&gt;. Similarly, we can see  get_item() performs a concrete substitution when it returns  Some(newItem),  newItem being an instance of  Item.</p><p>我们可以看到这非常简单，它只是一个有两个值的枚举，一些(T)和没有。通用占位符T允许我们在有效负载中进行组合，就像我们对选项&lt；Item&gt；所做的那样。类似地，我们可以看到get_item()在返回一些(NewItem)时执行了一个具体的替换，newItem是Item的一个实例。</p><p> Essentially we have a wrapper around our value that says if it&#39;s valid or not.  item no longer has any knowledge of its validity. Its existence is proof enough to eliminate the  Null state. However to get access to it we need to first tear off the wrapping paper. This is what the match construct is all about:</p><p>从本质上说，我们有一个包装器来包装我们的值，说明它是否有效。项目不再知道其有效性。它的存在足以证明消除了空态。然而，要拿到它，我们首先需要撕下包装纸。这就是Match构造的全部内容：</p><p> match item_option  {   (item )  =&gt;  {  //Do something with resource  println! ( &#34;{}&#34; , item ) ;  }    =&gt;  { } } ;</p><p>Match Item_Option{(Item)=&gt；{//使用资源println！(&#34；{}&34；，Item)；}=&gt；{}}；</p><p> It&#39;s called pattern matching and it&#39;s a  switch statement, but for types. Here the  Some branch is the only code path with a valid reference to  item. The compiler won&#39;t let you access  item outside of this scope. And that&#39;s how an expressive type system fixes the billion-dollar mistake.</p><p>它被称为模式匹配，它是一个switch语句，但是针对的是类型。在这里，Some分支是唯一具有对Item的有效引用的代码路径。编译器不会允许您访问超出此范围的项。这就是表现型系统修复数十亿美元错误的方式。</p><p> Edit: Based on reader feedback it would be good to give an example of what idiomatic code  might look like. &#34;Declarative&#34; code is less about style, as it is about the promise &#34;this thing&#39;s behaviour is consistent&#34; and knowable. To begin we can  match directly on the  get_item() function call:</p><p>编辑：根据读者反馈，最好给出一个惯用代码可能是什么样子的示例。声明性代码与其说是关于风格，不如说是关于承诺这件事的行为是一致的，并且是可知的。首先，我们可以直接匹配get_item()函数调用：</p><p>  We can also use this pattern within other functions too. Doing so is worthwhile if we want to unlock composable functions:</p><p>我们也可以在其他函数中使用此模式。如果我们想要解锁可组合函数，那么这样做是值得的：</p><p> fn  process_item (input :   &lt;  &gt; ) -&gt;   &lt;  &gt; {	 match input  {		  (item )  =&gt;  {			 /* modify item */			  (item )		 } ,		   =&gt;  	 } }</p><p>Fn PROCESS_ITEM(INPUT：&lt；&gt；)-&gt；&lt；&gt；{匹配输入{(Item)=&gt；{/*修改项目*/(Item)}，=&gt；}}。</p><p> Rust also provides shorthand,  if let is syntax sugar, a concise way to express interest in single branch of a  match statement. Putting it all together, we can state the whole problem as a single expression:</p><p>Rust还提供了速记(如果let is语法糖)，这是一种表达对Match语句的单个分支感兴趣的简明方式。把所有这些放在一起，我们可以用一个表达式来描述整个问题：</p><p> if  let   (item )  =  process_item ( get_item ( ) ) {	 println! ( &#34;Success, item is {}&#34; , item ) ; } fn  get_item ( )  -&gt;   &lt;  &gt;  {  if  /* success */  {  let new_item  =    { } ;  return   (new_item ) ;  }  return   ; } fn  process_item (input :   &lt;  &gt; ) -&gt;   &lt;  &gt; {	 match input  {		  (item )  =&gt;  {			 /* modify item */			  (item )		 } ,		   =&gt;  	 } }</p><p>If let(Item)=Process_Item(get_Item()){println！(&#34；Success，Item is{}&34；，Item)；}fn Get_Item()-&gt；&lt；&gt；{if/*Success*/{let new_Item={}；return(New_Item)；}return；}fn process_Item(input：&lt；&gt；)-&gt；&lt；&gt；{匹配输入{(Item)=&gt；{/*修改项目*/(Item)}，=&gt；}}。</p><p> Like all things, both styles have benefits and drawbacks. An exact discussion of which is better, when and why, is for another day. However, by having a single expression of functions, if we know that those functions are &#34;pure&#34;, we have some powerful promises about the correctness of our program. This, as I understand it, is FP&#39;s whole jam. I&#39;ll add, by virtue of  mut and mutation, Rust is not pure by default like  Haskell. So in the same way you could ask is Rust OOP, you could rightfully ask is Rust FP?</p><p>就像所有的东西一样，这两种风格都有优点和缺点。确切的讨论哪个更好，什么时候更好，为什么更好，可以改天再讨论。但是，通过使用单一的函数表达式，如果我们知道这些函数是纯函数，我们就可以对程序的正确性做出一些强有力的保证。据我所知，这就是FP&#39；的全部障碍。我要补充的是，由于mut和突变，铁锈不像哈斯克尔那样默认是纯净的。以同样的方式，你可以问是铁锈OOP吗，你可以理所当然地问是铁锈FP吗？</p><p>  Hopefully, it&#39;s clear why  Option&lt;Item&gt; and  Item are different types. The compiler will give you type errors if you try to use them interchangeably. It&#39;s self-evident when you&#39;re consuming a method you wrote (e.g.  get_item()) and you know it returns an  Option&lt;T&gt;. However, when using the std library or 3rd party crates, some innocuous scenarios caught me out. Consider the following:</p><p>希望它清楚为什么选项&lt；物品和物品是不同的类型。如果您试图互换使用它们，编译器会给您输入错误。当您重新使用您编写的方法(例如get_item())，并且您知道它返回一个选项时，这是不言而喻的。然而，在使用STD库或第三方机箱时，一些无伤大雅的场景让我大吃一惊。考虑以下问题：</p><p>  Define a list  [1,2,3] and get a reference to the first element using the  first() method. A perfectly reasonable thing to write in any other language. If I&#39;d had  rust-analyzer enabled, it would warn me of the trouble by adding a type hint after the  first variable:</p><p>定义一个list[1，2，3]，并使用first()方法获取对第一个元素的引用。用任何其他语言写都是完全合理的。如果我启用了锈蚀分析器，它会通过在第一个变量后面添加一个类型提示来警告我这个问题：</p><p>  Because it&#39;s impossible to return the first element of an empty array,  first() instead returns an  Option&lt;&amp;i32&gt;, an  &amp;i32 with an &#34;is this safe?&#34; wrapper around it. Only if the array is populated will its value will be  Some(&amp;i32), otherwise it resolves to  None. Therefore attempts to consume it directly, as an  &amp;i32 (aka a  &amp; reference to an  i integer of  32 bits), will fail. That&#39;s exactly what happens in our assertion above:</p><p>因为不可能返回空数组的第一个元素，所以first()返回一个选项&lt；&amp；I32&gt；，&amp；I32用一个&#34；包装表示安全吗？&#34；。只有当数组被填充时，它的值才会是一些(&amp；I32)，否则它将解析为None。因此，将其作为&amp；I32(也称为引用32位的i整数)直接使用的尝试将失败。这正是我们在上面的断言中发生的事情：</p><p> //Is the first element, my_list[0], equal to my_list.first()? assert_eq! ( &amp;my_list [ 0 ] , first ) ; error [ E0277 ] : can  compare ` &amp; {integer }` with `   &lt; &amp; {integer } &gt;`  | 5  |  assert_eq! ( &amp;my_list [ 0 ] , first ) ;  |  ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^no implementation  for  | ` &amp; {integer }  ==    &lt; &amp; {integer } &gt;`</p><p>//第一个元素my_list[0]是否等于my_list.first()？Assert_eq！(&amp；my_list[0]，first)；错误[E0277]：可以将`&amp；{INTEGER}`与`&lt；&amp；{INTEGER}&gt；`|5|ASSERT_EQ！{INTEGER}&gt；`。</p><p> Rust is full of this type sleight of hand, it crops up everywhere. Being forced to deal with it feels like eating your broccoli. But eating your greens is the foundation of the warm fuzzy feeling FP programmers often cite: &#34;If the code compiles, you can trust the code will run&#34;. Rust creates a similar sentiment, although if you cheat using backdoors, you will weaken this promise.</p><p>铁锈到处都是这种花招，到处都是。被迫处理这件事感觉就像吃了你的西兰花。但是，吃蔬菜是FP程序员经常引用的温暖模糊感觉的基础：如果代码编译成功，您可以相信代码将会运行。生锈造成了类似的情绪，尽管如果你走后门作弊，你会削弱这一承诺。</p><p> In the above example, like before, you can use a  match statement to tear off the  Option wrapping paper. Or you can cheat your way out of it by using  unwrap():</p><p>在上面的示例中，与前面一样，您可以使用Match语句撕下选项包装纸。或者，您可以通过使用UnWrap()来欺骗：</p><p>  Here  unwrap() is a shorthand for shedding the  Option wrapper. However, it does so by choosing to ignore the  None path. This means we court the danger of an empty list causing a runtime panic. It&#39;s not surprising that most, if not all, of my runtime errors came from choosing sneaky convenience over rigid safety.</p><p>这里，unWrap()是去除选项包装器的一种快捷方式。但是，它通过选择忽略无路径来执行此操作。这意味着我们面临空列表导致运行时恐慌的危险。不足为奇的是，我的大部分(如果不是全部)运行时错误都来自于选择偷偷摸摸的便利性，而不是僵化的安全性。</p><p>  The following structure is closely related to  Option&lt;T&gt; and is used for any operations that might need to return an explicit error message, like disk IO.</p><p>以下结构与选项&lt；T&gt；密切相关，可用于任何可能需要返回显式错误消息的操作，如磁盘IO。</p><p>  Ok(T) is semantically equivalent to  Some(T), and  Err(E) is a  None that contains an error of type  E. Learning  the toolbox used to manipulate these patterns is a fundamental part of learning Rust. However, there&#39;s a key feature I want to point out.</p><p>OK(T)在语义上等同于某些(T)，而Err(E)是一个包含E类型错误的None。学习用于操作这些模式的工具箱是学习Rust的基本部分。然而，有一个关键的特点我想指出。</p><p> Ok(T) and  Err(E), just like  Some(T) and  None, are different variants. In  Java or  C# this wouldn&#39;t be possible, firstly  generics&lt;T&gt; aren&#39;t allowed on enums, secondly backing fields (or associated data) must be of the same underlying type, commonly an  int. In Rust, it&#39;s perfectly reasonable to create an  enum whose variants are different types:</p><p>OK(T)和ERR(E)，就像某些(T)和NONE一样，是不同的变体。在Java或C#中，这是不可能的，首先，枚举不允许使用泛型；其次，支持字段(或相关数据)必须是相同的底层类型，通常是int。在Rust中，创建一个变体为不同类型的枚举是完全合理的：</p><p>  This is a powerful way to model the result of a complex function with very divergent branching logic. Being able to  match all possibilities in a single statement can make it simpler to understand the consequences of this code. It&#39;s another notch in Rust&#39;s &#34;expressive&#34; type system toolbelt.</p><p>这是对具有非常不同的分支逻辑的复杂函数的结果进行建模的一种强大方式。能够在一条语句中匹配所有可能性可以更容易地理解此代码的结果。这是另一个刻痕铁锈类型的系统工具带的表现力。</p><p>  There&#39;s a subtle difference in the feeling I get from Rust types that&#39;s hard to explain. In OOP languages, objects tend to be an accumulation of types. Each superclass and interface aggregates and embellishes on top of the type you&#39;re working with. An instance of an object gives you the keys to the kingdom for every public or inherited member. There are also a robust set of built-in tools to transform from one type to another. It&#39;s inclusive by default.</p><p>我从铁锈类型中得到的感觉有一个微妙的不同，这是很难解释的。在OOP语言中，对象往往是类型的累积。每个超类和接口都在您正在使用的类型之上进行聚合和修饰。对象的实例为您提供每个公共或继承成员的王国的密钥。还有一组健壮的内置工具可以从一种类型转换为另一种类型。默认情况下，它是包含式的。</p><p> This expectation was an initial source of frustration in Rust. I spent a lot of time trying to transform a result by casting it into the destination I needed. However, due to the itty-bitty style I mentioned before, idiomatic Rust is often exclusive by default.</p><p>这种期望是“铁锈”中最初令人沮丧的原因。我花了很多时间试图通过将结果投射到我需要的目的地来转换结果。但是，由于我在前面提到的itty-bitty风格，所以在缺省情况下通常是独占的。</p><p> Let&#39;s explain this further with a real-world example. The   rppal crate provides an interface for a Raspberry Pi&#39;s 40  GPIO pins, which are used to communicate with hardware peripherals. To make an LED blink would be a matter of setting the voltage at the connected pin high or low. Similarly, pins can also be used to receive data from the outside world by measuring input voltage from sensors. It&#39;s important to know that read and write have mutually exclusive functionality, and this needs to be modelled in software.</p><p>让我们用一个现实世界的例子进一步解释这一点。Rppal板条箱为树莓PI的40个GPIO引脚提供接口，这些引脚用于与硬件外设通信。要使LED闪烁，只需将连接的引脚上的电压设置为高或低即可。同样，引脚也可以用来通过测量传感器的输入电压来接收来自外部世界的数据。重要的是要知道，读取和写入具有相互排斥的功能，这需要在软件中建模。</p><p> The  rppal crate is interesting because its history details  a refactor to a more idiomatic pin API. I&#39;m going to present a bastardised toy version here because I want to focus on the evolution rather than specifics. First, the old way:</p><p>RPPAL板条箱很有趣，因为它的历史详细说明了重构为更惯用的pin API。我将在这里展示一个私生子的玩具版本，因为我想把重点放在进化上，而不是具体的细节上。第一，老办法：</p><p> const  LED  :  u8  =  5 ; const  SENSOR  :  u8  =  6 ; //Config let led_pin  :    = gpio . getPin ( LED ) ;led_pin . set_mode (   ) ;  let sensor_pin  :    = gpio . getPin ( SENSOR ) ;sensor_pin . set_mode (   ) ;  //Write outputled_pin . write (  ::  ) ; led_pin . write (  ::  ) ;  //Read input let level  = sensor_pin . read ( ) ;</p><p>常量LED：U8=5；常量传感器：U8=6；//配置LET LED_PIN：=GPIO。GetPin(LED)；led_pin。Set_mode()；让SENSOR_PIN：=GPIO。GetPin(传感器)；Sensor_pin。Set_mode()；//写入outputed_pin。WRITE(：：)；LED_PIN。Write(：：)；//读取输入LET LEVEL=SENSOR_PIN。Read()；</p><p> Seems reasonable?  gpio.getPin() collects a pin based off its numbered id.  set_mode configures it for output or input.  read() and  write() then carry out the business we came for. Notice though that once a pin&#39;s mode is set, the developer is responsible for upholding the contract. Nothing will prevent the following:</p><p>看起来合理吗？GetPin()根据编号的id收集PIN。Set_mode将其配置为输出或输入。Read()和write()，然后执行我们要执行的业务。但请注意，一旦设置了个人识别码模式，开发商就有责任维护合同。没有什么可以阻止以下情况：</p><p>  Depending on the circumstances, consequences range from harmless to permanent hardware damage. This kind of compromise happens often in the &#34;kitchen sink&#34; </p><p>根据情况的不同，后果从无害到永久性硬件损坏不等。这种妥协经常发生在厨房的水槽里。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://thefuntastic.com/blog/fighting-rusts-type-system">https://thefuntastic.com/blog/fighting-rusts-type-system</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/表现型/">#表现型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031016.html"><img src="http://img2.diglog.com/img/2020/10/thumb_4c7caf2581b4d14b9be121f26f94dc9c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031016.html">三个开源Sonos项目：Rust中高效的嵌入式开发</a></div><span class="my_story_list_date">2020-10-25 6:15</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030894.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c95c6640c04b0b64f58812e5c40b98fc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030894.html">安全系统编程为何生锈</a></div><span class="my_story_list_date">2020-10-24 8:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030856.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9a5520fddb66d2afe0ad8c8b42c9a0f1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030856.html">微软在欧洲反垄断文件中抨击松懈投诉</a></div><span class="my_story_list_date">2020-10-24 7:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030843.html"><img src="http://img2.diglog.com/img/2020/10/thumb_edc04706699783a8ac9ecad29f8d3132.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030843.html">消息人士：州和联邦调查人员料最快11月对Facebook提起反垄断指控</a></div><span class="my_story_list_date">2020-10-24 7:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>