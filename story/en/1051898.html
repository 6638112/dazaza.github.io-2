<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>基于新的浏览器的木偶替换器，以及我们如何建造它 The new browser-based puppeteer REPL, and how we built it</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The new browser-based puppeteer REPL, and how we built it<br/>基于新的浏览器的木偶替换器，以及我们如何建造它 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-12 07:49:27</div><div class="page_narrow text-break page_content"><p>Without out a doubt, one of the most helpful tools when working with any browser automation library is a visual debugger.  We&#39;ve written quite a bit about it. Since browserless is built specifically for developers, we&#39;re always striving to provide the best experience possible with debugging ⁠— and weren&#39;t satisfied with the state-of-the-art with the newer automation libraries. Simply put:  headless: false isn&#39;t  quite enough to debug puppeteer, nor is any current live &#34;REPL&#34; out there.</p><p>毫无疑问，使用任何浏览器自动化库时，最有用的工具之一是可视调试器。我们＆＃39; ve写了很多关于它。由于无论是专门为开发人员建立的，我们始终努力提供最佳体验，并通过更新的自动化图书馆对最先进的技术提供满意的。简单地说：无头：虚假的isn＆＃39; t足以调试木偶，也不是任何当前生活＆＃34; repl＆＃34;在那里。</p><p> Today, we&#39;re happy to announce that our complete re-write of the  debugger is now live 🎉! It includes all the features of what we wanted in a debugger, and  more.</p><p> 今天，我们很高兴宣布我们完全重新编写调试器现在活着🎉！它包括我们在调试器中想要的所有功能，以及更多。</p><p> The new REPL web-app We&#39;ve been using this debugger internally for quite some time, and have found it  incredibly useful. A short list of features include:</p><p> 新的Repl Web-App我们＆＃39;在内部使用这个调试器进行了很长一段时间，并发现它非常有用。简短的功能列表包括：</p><p>  Quite a bit of planning, research and development went into building this editor out. Since we found it to be such a useful tool, we also thought it&#39;d be interesting to go over some of its core fundamentals and how we went about building it. Let me pause and say this before we get to far: if you do one thing today,  just try out the debugger. If you do two things, read below on how we built it!</p><p>  相当多的规划，研发进入了这一编辑器。由于我们发现它是这样一个有用的工具，我们也认为它＆＃39; D＆＃39是有趣的，越过其一些核心基本面以及我们如何建立它。让我暂停并在迄今为止之前说出来：如果你今天做一件事，那就试试了调试器。如果你做两件事，请阅读下面我们如何建造它！</p><p>  Without a doubt the most &#34;useful&#34; aspect of any debugger or REPL is the editing experience. Since we&#39;re big fans of VS-code, we decided to use the  fantastic  monaco-editor library that powers it. Getting monaco up and running with your favorite libraries can be somewhat of a hassle, so we scoped back the amount of packages that are typed to just two for now:  node and  puppeteer. Given that both of these packages have typings already, it&#39;s simply a matter of loading them into the editor. Doing so is fairly straightforward once you have your editor object setup, so that&#39;s our first step!</p><p>  毫无疑问，最多＆＃34;有用＆＃34;任何调试器或repl的方面是编辑体验。自从我们＆＃39;重大粉丝的VS-Code，我们决定使用强大的梦幻般的摩纳哥编辑库。通过您最喜欢的库旋转和运行摩洛尼亚可以有点麻烦，因此我们现在备份键入为仅两个的软件包：节点和木偶。鉴于这两个包都有打字已经，它只是将它们加载到编辑器中的问题。一旦您拥有编辑器对象设置，就这样做是相当简单的，所以我们的第一步！</p><p>  // Setup the environment for typescript/javascript supportself.MonacoEnvironment = { getWorkerUrl:  ( _moduleId:  any, label:  string) =&gt; {  if (label ===  &#39;typescript&#39; || label ===  &#39;javascript&#39;) {  return  &#39;./ts.worker.bundle.js&#39;; }  return  &#39;./editor.worker.bundle.js&#39;; }}; // Instantiate the editor const editor = monaco.editor.create( document.getElementById( &#39;code&#39;), { value: initialCode, language:  &#39;typescript&#39;, theme:  &#39;vs-dark&#39;, fontSize:  14, wordWrap:  &#39;on&#39;, scrollBeyondLastLine:  false, automaticLayout:  true, minimap: { enabled:  false }});</p><p>  //为类型/ javascript supportself.monacoenvironment = {getworkerurl :( _moduleid：任何，标签：字符串）=＆gt;; {if（label ===＆＃39; typescript＆＃39; ||标签===＆＃39; javascript＆＃39;）{return＆＃39; ./ ts.worker.bundle.js＆＃39 ;;返回＆＃39; ./ editor.worker.bundle.js＆＃39 ;; }}; //实例化编辑器const编辑器= monaco.editor.create（document.getelementById（＆＃39;代码＆＃39;），{value：initialcode，language：＆＃39; typectift＆＃39 ;,主题：＆＃39; VS-Dark＆＃39;，fontsize：14，WordWrap：＆＃39;＆＃39;，scrollbeyondlastline：false，sucemainlaylayout：true，minimap：{已启用：false}}）;</p><p> Once setup,  monaco has an API for injecting typings into it as well as the configuration for the TypeScript compiler. Setting up a new TS project is relatively straightforward:</p><p> 一旦设置，摩纳哥有一个用于将键入注入其的API以及类型标注编译器的配置。设置新的TS项目相对简单： </p><p> // Specify that this is a node-like environmentmonaco.languages.typescript.typescriptDefaults.setCompilerOptions({ allowNonTsExtensions:  true, target: monaco.languages.typescript.ScriptTarget.ES2020, moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,  module: monaco.languages.typescript.ModuleKind.CommonJS,});</p><p>//指定这是一个类似节点的neamentionmonaco.languages.typescript.typescriptdefaults.setCompilerOptions（{allowNontsextensions.Sture，Target：Monaco.languages.Typescript.scripttarget.es2020，moduleresolution：monaco.languages.typescript.moduleresolutionkind.nodejs，moduly.nodejs ：monaco.languages.typescript.modulekind.commonjs，}）;</p><p> Now that everything is setup it&#39;s simply a matter of loading our types into the editor. This part turned out to be a bit tricky, since  monaco wants types as a plain-string property. Thankfully, we&#39;re using WebPack to bundle up the project, so &#34;loading&#34; these types is as simple as requiring them as raw files:</p><p> 现在一切都是设置它＆＃39; s只是一个将我们类型加载到编辑器中的问题。这部分原来有点棘手，因为摩纳哥想要类型作为普通字符串属性。谢天谢地，我们＆＃39;重新使用webpack捆绑项目，所以＆＃34;加载＆＃34;这些类型与要求它们为原始文件一样简单：</p><p> // First load the types as a plain string const puppeteerTypes =  require( &#39;!!raw-loader!puppeteer-core/lib/types.d.ts&#39;); // ... later, add the puppeteer types into the editormonaco.languages.typescript.typescriptDefaults.addExtraLib( puppeteerTypes.default,  &#39;node_modules/@types/puppeteer/index.d.ts&#39;,);</p><p> //首先将类型加载为普通字符串const puppeteertypes =要求（＆＃39; !!原始装载机！木偶核心/ lib / type.d.ts＆＃39;）; //...后，将木偶仪器类型添加到editormonaco.languages.typescript.typescriptdefaults.addextralib（puppeteertypes.default，＆＃39; node_modules/@types/pppeteer/index.d.ts&#39 ;,）;</p><p> For the purposes of our editor, we actually do some manipulation of the types so that they&#39;re globally exported (and don&#39;t need to be required).  The full source can be found here, for those who want to see the whole project.</p><p> 出于我们的编辑的目的，我们实际上可以进行一些操作，以便它们出口全球范围内的类型（并且不需要＆＃39; T.对于那些想要查看整个项目的人来说，可以在此处找到完整的来源。</p><p>  Without a doubt, the second most helpful thing is actually seeing what the browser is up to ⁠— especially in the environment it&#39;s running in. We&#39;ve seen cases where things worked just fine on local machines, but had issues in the cloud, so having the browser  actually execute in the cloud was important to us for full transparency. To do this we reached into Chrome&#39;s DevTools Protocol to screencast frames of video directly back to your browser. This means that  your browser is actually running the puppeteer code and viewing the session, meaning there&#39;s no other network hops being made.</p><p>  毫无疑问，第二个最有帮助的事情实际上看到了浏览器达到了⁠的东西 - 尤其是在环境中运行的环境。我们在当地机器上工作的情况很好，但是云中的问题，因此浏览器实际上在云中执行的浏览器对我们来说很重要，以便完全透明度。要做到这一点，我们达到了Chrome＆＃39; s devtools协议，直接返回浏览器的截止视频帧。这意味着您的浏览器实际上正在运行木偶代码并查看会话，这意味着没有其他网络啤酒花。</p><p>  const browser =  await puppeteer.connect({ browserWSEndpoint }) .catch( ( error) =&gt; {  console.error(error);  throw error; }); const page =  await browser.newPage(); // Use the page&#39;s client to start the screencast const client = (page  as  any)._client  as CDPSession; await client.send( &#39;Page.startScreencast&#39;, { format:  &#39;jpeg&#39;, quality:  100 }); // Wire up the screencast...client.on( &#39;Page.screencastFrame&#39;,   () =&gt;  console.log( &#34;TODO&#34;));</p><p>  const浏览器= await poppeteer.connect（{browserwsendpoint}）.catch（（错误）=＆gt; {console.error（错误）;抛出错误;}）; const page = await browser.newpage（）; //使用页面＆＃39; s客户端开始跳斯卡constract =（页面页面页面）._客户端作为cdpsession; await client.send（＆＃39; page.startscreencast＆＃39; {格式：＆＃39; jpeg＆＃39;质量：100}）; //连接屏幕CastCast ... Client.on（＆＃39;页面.CEreencyFrame＆＃39;，（）=＆gt; console.log（＆＃34; todo＆＃34;））;</p><p> Now that we&#39;ve got our browser and page boilerplate setup, it&#39;s just a matter of wiring up the screencast even so that we can draw it on the we-browser locally. Doing so isn&#39;t that complicated, however requires a bit of setup. For this particular case, we&#39;ll actually be drawing onto a  &lt;canvas&gt; element inside the browser.</p><p> 现在，我们＆＃39; vere get我们的浏览器和页面样板设置，它只是一个接线的问题，即使我们可以在本地浏览器上绘制它。这样做的是＆＃39;然而，复杂的是，需要一些设置。对于这种特殊情况，我们＆＃39; LL实际上是绘制在＆lt;帆布＆gt上;浏览器内的元素。 </p><p> const $canvas =  document.querySelector( &#39;#screencast&#39;) const ctx = $canvas.getContext( &#39;2d&#39;); const img =  new Image();onScreencastFrame( ( { data }) =&gt; { img.onload =   () =&gt; ctx.drawImage(img,  0,  0, $canvas.width, $canvas.height); img.src =  &#39;data:image/png;base64,&#39; + data;});</p><p>const $ canvas = document.querySelector（＆＃39;＃39;＃39;）const ctx = $ canvas.getcontext（＆＃39; 2d＆＃39;）; const img = new image（）; onscreencastframe（（{data}）=＆gt; {img.onload =（）=＆gt; ctx.drawimage（img，0,0，$ canvas.width，$ canvas.height）; img .src =＆＃39;数据：图像/ png; base64，＆＃39; +数据;}）;</p><p> Once both are all setup, you can do the following in the browser (assuming you have a  &lt;canvas id=&#34;screencast&#34;&gt; in your page):</p><p> 一旦两个都设置了，您可以在浏览器中执行以下操作（假设您有一个＆lt; canvas id =＆＃34; screencast＆＃34;＆gt;在您的页面中）：</p><p> const $canvas =  document.querySelector( &#39;#screencast&#39;) const ctx = $canvas.getContext( &#39;2d&#39;); const img =  new Image(); const browser =  await puppeteer.connect({ browserWSEndpoint }) .catch( ( error) =&gt; {  console.error(error);  throw error; }); const page =  await browser.newPage(); const client = (page  as  any)._client  as CDPSession; await client.send( &#39;Page.startScreencast&#39;, { format:  &#39;jpeg&#39;, quality:  100});client.on( &#39;Page.screencastFrame&#39;, onScreencastFrame);onScreencastFrame( ( { data }) =&gt; { img.onload =   () =&gt; ctx.drawImage(img,  0,  0, $canvas.width, $canvas.height); img.src =  &#39;data:image/png;base64,&#39; + data;});</p><p> const $ canvas = document.querySelector（＆＃39;＃39;＃39;）const ctx = $ canvas.getcontext（＆＃39; 2d＆＃39;）; const img = new image（）; const浏览器= await poppeteer.connect（{browserwsendpoint}）.catch（（错误）=＆gt; {console.error（错误）;抛出错误;}）; const page = await browser.newpage（）; const client =（页面页面）._客户作为cdpsession; await client.send（＆＃39; page.startscreencast＆＃39; {format：＆＃39; jpeg＆＃39;质量：100}）; client.on（＆＃39;页面。页面。，onscreencastframe page.screencastframe＆＃39;，onscreencastframe ）; onscreencastframe（（{data}）=＆gt; {img.onload =（）=＆gt; ctx.drawimage（img，0,0，$ canvas.width，$ canvas.height）; img.src =＆＃39 ;数据：图像/ png; base64，＆＃39; +数据;}）;</p><p> This really is just the start: we don&#39;t talk much about how keyboard and mouse events are handled, but if you want to see the full code  feel free to do so here.</p><p> 这真的只是开始：我们不谈论如何处理键盘和鼠标事件，但如果您想看到完整的代码随意这样做。</p><p>  The last bit of work is handling downloads: things that your code might run that produces some kind of static asset like a PDF or PNG file. To do that, we had to get a one more library in the project to help us out:  file-type. This module, at its core, accepts a binary blob of some kind and tells us what it is. For us this mostly helps the editor to discern from PDF and PNG images, but can potentially be expanded to other formats as well.</p><p>  最后一点工作正在处理下载：您的代码可能运行的事情会产生某种像PDF或PNG文件的静态资产。为此，我们必须在项目中获得一个更多的图书馆来帮助我们：文件类型。这个模块在其核心，接受了某种二进制斑点并告诉我们它是什么。对于我们而言，这主要有助于编辑从PDF和PNG图像中辨别，但也可能扩展到其他格式。</p><p> Once the page&#39;s code has ran, we look at what the script returns and make an educated guess as to what&#39;s supposed to happen. Since this is all being ran inside a WebWorker, we can  eval the code with some sand-boxing. Remember: this is all ran inside the user&#39;s browser  inside a WebWorker so while it&#39;s generally a bad idea to  eval most of the time, we made an exception here.</p><p> 一旦页面＆＃39; s代码已经ran，我们会查看脚本返回的内容，并对应该发生的事情进行受过教育的猜测。由于这一切都在网络工作中都跑了，因此我们可以使用一些沙拳来评估代码。请记住：这一切都在用户＆＃39;在网络中的浏览器中遇到了它的浏览器，所以当它大多数时间都是一个坏主意，我们在这里造成了例外。</p><p> const browser =  await puppeteer.connect({ browserWSEndpoint }); const page =  await browser.newPage(); // Code is written in an encapsulated function, so we invoke it with the // proper arguments in order for it to run. eval(code)({ page }) .then( async (res:  any) =&gt; {  // Need to handle res here as it could be anything the function returns... }) .catch( ( e:  Error) =&gt; {  // Inject errors into the page so that they show up in the cloud browser&#39;s devtools... neat! page &amp;&amp; page.evaluate( ( err) =&gt;  console.error(err), e.toString()); });</p><p> const browser = await puppeteer.connect（{browserwsendpoint}）; const page = await browser.newpage（）; //代码以封装的函数编写，因此我们将其与//正确的参数调用它，以便它运行。 eval（代码）（{页面}）.then（async（res：domence）=＆gt; {//需要在这里处理res，因为它可能是函数返回的任何东西...}）.catch（（e：错误） =＆gt; {//将错误注入页面，以便它们显示在云浏览器中显示＆＃39; s devtools ...... neat！页面＆amp; page.evaluate（（err）=＆gt; console.error（错误），e.tostring（））;}）; </p><p> For handling of downloads, we have a pretty simple function that checks what it is:</p><p>为了处理下载，我们有一个非常简单的功能，检查它是什么：</p><p> import FileType  from  &#39;file-type/browser&#39;; async   function  ( response?:  string |  Uint8Array):  &lt;{  type:  string, payload:  any,} |  null&gt; {  // Nothing being returned triggers no actions  if (!response) {  return  null; }  // PDF/PNG are Uint8Arrays in the browser  // If no type is determined, don&#39;t do anything  if (response  instanceof  Uint8Array) {  const  type = ( await FileType.fromBuffer(response) || { mime:  undefined }).mime;  if (! type) {  return  null; }  return {  type, payload: response}; }  // Here we check for page.content responses (html) via a simple check that it starts with the &#34;&lt;&#34; character  if ( typeof response ===  &#39;string&#39;) {  return {  type: response.startsWith( &#39;&lt;&#39;) ?  &#39;text/html&#39; :  &#39;text/plain&#39;, payload: response, } }  // Check if it&#39;s a JSON blob that we should download instead  if ( typeof response ===  &#39;object&#39;) {  return {  type:  &#39;application/json&#39;, payload:  JSON.stringify(response,  null,  &#39; &#39;), }; }  return {  type:  &#39;text/plain&#39;, payload: response, };}</p><p> 从＆＃39导入文件类型;文件类型/浏览器＆＃39 ;; async函数（响应？：string | uint8Array）：＆lt; {type：string，payload：dom，} | null＆gt; {//没有任何返回的触发器如果（！响应）{return null; } // pdf / png是浏览器中的uInt8Arrays //如果没有确定类型，如果（响应instanceof uint8Array）{const类型=（等待fileType.flbuffer（响应）|| {mime：未定义}）。哑剧; if（！type）{返回null; }返回{类型，有效载荷：响应}; } //在这里，我们通过简单的检查来检查Page.Content响应（HTML）它以＆＃34开头;＆lt;＆＃34;字符if（respaction ===＆＃39; string＆＃39;）{return {type：response.startswith（＆＃39;＆＃39;）？ ＆＃39; text / html＆＃39; ：＆＃39;文本/ plain＆＃39;，有效载荷：响应，}} //检查它＆＃39; sa json blob，我们应该下载（typeof response ===＆＃39;对象＆＃39;） {return {type：＆＃39;应用程序/ json＆＃39;，payload：json.stringify（响应，null，＆＃39;＆＃39;），}; }返回{type：＆＃39;文本/ plain＆＃39;，有效载荷：响应，};}</p><p> Finally, once we have the type of file that&#39;s being returned, we can trigger the browser to download it:</p><p> 最后，一旦我们有返回的文件类型，我们可以触发浏览器下载它：</p><p> import FileType  from  &#39;file-type/browser&#39;; import pupeteer  from  &#39;puppeteer&#39;; const browser =  await puppeteer.connect({ browserWSEndpoint }); const page =  await browser.newPage(); async   function  ( response?:  string |  Uint8Array):  &lt;{  type:  string, payload:  any} |  null&gt; {  if (!response) {  return  null; }  if (response  instanceof  Uint8Array) {  const  type = ( await FileType.fromBuffer(response) || { mime:  undefined }).mime;  if (! type) {  return  null; }  return {  type, payload: response}; }  if ( typeof response ===  &#39;string&#39;) {  return {  type: response.startsWith( &#39;&lt;&#39;) ?  &#39;text/html&#39; :  &#39;text/plain&#39;, payload: response, } }  if ( typeof response ===  &#39;object&#39;) {  return {  type:  &#39;application/json&#39;, payload:  JSON.stringify(response,  null,  &#39; &#39;), }; }  return {  type:  &#39;text/plain&#39;, payload: response, };} const downloadFile =  ( download) =&gt; {  const fileName =  &#39;my-download&#39;;  const blob =  new Blob([download.payload], {  type: download.type });  const link =  document.createElement( &#39;a&#39;); link.href =  window.URL.createObjectURL(blob); link.download = fileName;  return link.click();}; eval(code)({ page }) .then( async (res:  any) =&gt; {  const payload = makeDownload(res);  if (payload) { downloadFile(payload); } }) .catch( ( e:  Error) =&gt; { page &amp;&amp; page.evaluate( ( err) =&gt;  console.error(err), e.toString()); });</p><p> 从＆＃39导入文件类型;文件类型/浏览器＆＃39 ;;从＆＃39导入蛹;木偶＆＃39 ;; const browser = await puppeteer.connect（{browserwsendpoint}）; const page = await browser.newpage（）;异步函数（响应？：string | uint8array）：＆lt; {type：string，payload：dom} | null＆gt; {if（！响应）{返回null; }如果（responsionsof uint8Array）{const类型=（等待filetype.flbbudeer（响应）|| {mime：未定义}）。mime; if（！type）{返回null; }返回{类型，有效载荷：响应}; }如果（resefof response ===＆＃39; string＆＃39;）{return {type：response.startswith（＆＃39;＆＃39;＆＃39;）？ ＆＃39; text / html＆＃39; ：＆＃39;文本/ plain＆＃39;，payload：响应，}}如果（typeof response ===＆＃39;对象＆＃39;）{return {type：＆＃39;应用程序/ json＆＃39;，有效载荷：json.stringify（响应，null，＃39;＆＃39;），}; } return {type：＆＃39;文本/ plain＆＃39;，有效载荷：响应，}; const downloadfile =（下载）=＆gt; {const filename =＆＃39;我的下载＆＃39 ;; const blob = new blob（[download.payload]，{type：download.type}）; const link = document.createelement（＆＃39; a＆＃39;）; link.href = window.url.createobjecturl（blob）; link.dowload = filename; return.Click（）;}; eval（代码）（{页面}）.then（async（res：domence）=＆gt; {const payload = makedownload（res）; if（powload）{downloadfile（payload）;}}）.catch（（E：错误）=＆gt; {页面＆amp;＆amp; page.evaluate（（err）=＆gt; console.error（err），e.tostring（））;}）;</p><p>  While this is just a highlight of some of the technologies we used to build the live debugger, there&#39;s a lot more that went into the project. We didn&#39;t touch upon our tab implementation, how we load puppeteer into the browser, or even how we save your code!  You should definitely check out the repo and see the whole project in its glory. Finally,  you should definitely check out our debugger, and make use of it when something isn&#39;t working properly in your headless workloads.</p><p>  虽然这只是我们用于构建现场调试器的一些技术的亮点，但是在那里进入了该项目的更多技术。我们在我们的选项卡实现时触摸了，我们如何将木质仪器加载到浏览器中，甚至我们如何保存代码！你肯定应该看看回购并在荣耀中看到整个项目。最后，您肯定应该查看我们的调试器，并在您无头工作负载中正常工作时使用它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://docs.browserless.io/blog/2021/03/10/new-live-debugger.html">https://docs.browserless.io/blog/2021/03/10/new-live-debugger.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/木偶/">#木偶</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>