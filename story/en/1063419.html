<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一种简单的连续交叉语言（GO，RUD，C / C ++）eBPF编写的分析器 A simple continuous cross-language (Go, Rust, C/C++) profiler written in eBPF</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A simple continuous cross-language (Go, Rust, C/C++) profiler written in eBPF<br/>一种简单的连续交叉语言（GO，RUD，C / C ++）eBPF编写的分析器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-04 08:07:46</div><div class="page_narrow text-break page_content"><p>In the last  blog post, we discussed the basics of CPU profilers for compiled languages like Go, C++ and Rust. We ended by saying we wanted a sampling-based profiler that met these two requirements:</p><p>在最后的博客文章中，我们讨论了CPU分析器的基础知识为Go，C ++和Rust等编译语言。我们通过表示我们想要一个基于采样的探查器，符合这两个要求：</p><p> Does not require recompilation or redeployment: This is critical to Pixie’s auto-telemetry approach to observability. You shouldn’t have to instrument or even re-run your application to get observability.</p><p> 不需要重新编译或重新部署：这对Pixie的自动遥测方法至关重要。您不应该对仪器甚至重新运行您的应用程序以获得可观察性。</p><p> Has very low overheads: This is required for a continuous (always-on) profiler, which was desirable for making performance profiling as low-effort as possible.</p><p> 具有非常低的开销：这是连续（始终开启）分析器所必需的，这是希望尽可能低成本的性能分析。</p><p> A few existing profilers met these requirements, including the Linux  perf tool. In the end, we settled on the BCC eBPF-based profiler developed by Brendan Gregg  [1] as the best reference. With eBPF already at the heart of the Pixie platform, it was a natural fit, and the efficiency of eBPF is undeniable.</p><p> 一些现有的探查器满足了这些要求，包括Linux PERF工具。最后，我们在Brendan Gregg [1]开发的基于BCC的EBPF的分析器上作为最佳参考。使用EBPF已经在Pixie平台的核心，它是一种自然的合适，EBPF的效率是不可否认的。</p><p> If you’re familiar with eBPF, it’s worth checking out the source code of the  BCC implementation. For this blog, we’ve prepared our own simplified version that we’ll examine in more detail.</p><p> 如果您熟悉EBPF，值得查看BCC实现的源代码。对于此博客，我们已准备好我们将更详细地检查的简化版本。</p><p>  The code to our simple eBPF-based profiler can be found  here, with further instructions included at the end of this blog (see  Running the Demo Profiler). We’ll be explaining how it works, so now’s a good time to clone the repo.</p><p>  可以在此处找到基于简单的EBPF的分析器的代码，其中包含此博客末尾的进一步说明（请参阅运行演示探查器）。我们将解释它的工作原理，所以现在是克隆回购的好时机。</p><p> Also, before diving into the code, we should mention that the Linux developers have already put in dedicated hooks for collecting stack traces in the kernel. These are the main APIs we use to collect stack traces (and this is how the official BCC profiler works well). We won’t, however, go into Linux’s implementation of these APIs, as that’s beyond the scope of this blog.</p><p> 此外，在潜入代码之前，我们应该提到Linux开发人员已经投入专用钩子，用于在内核中收集堆栈迹线。这些是我们用于收集堆栈迹线的主要API（这是官方BCC Profiler如何运作的方式）。但是，我们不会进入Linux的实现这些API，因为这超出了这个博客的范围。 </p><p> With that said, let’s look at some BCC eBPF code. Our basic structure has three main components:</p><p>有了这一说，让我们看看一些BCC EBPF代码。我们的基本结构有三个主要组成部分：</p><p>   A  BPF_STACK_TRACE data structure called  stack_traces to hold sampled stack traces. Each entry is a list of addresses representing a stack trace. The stack trace is accessed via an assigned stack trace ID.</p><p>   一个bpf_stack_trace数据结构，称为stack_traces来保存采样堆栈痕迹。每个条目都是表示堆栈跟踪的地址列表。通过分配的堆栈跟踪ID访问堆栈跟踪。</p><p> A  BPF_HASH data structure called  histogram which is a map from the sampled location in the code to the number of times we sampled that location.</p><p> 一个名为直方图的bpf_hash数据结构，它是从代码中的采样位置的地图到我们采样该位置的次数。</p><p> A function  sample_stack_trace that will be periodically triggered. The purpose of this eBPF function is to grab the current stack trace whenever it is called, and to populate/update the  stack_traces and  histogram data structures appropriately.</p><p> 将定期触发的函数sample_stack_trace。此EBPF功能的目的是在调用时抓住当前堆栈跟踪，并适当地填充/更新Stack_traces和直方图数据结构。</p><p>   As we’ll see in more detail later, we’ll set up our BPF code to trigger on a periodic timer. This means every X milliseconds, we’ll interrupt the CPU and trigger the eBPF probe to sample the stack traces. Note that this happens regardless of which process is on the CPU, and so the eBPF profiler is actually a system-wide profiler. We can later filter the results to include only the stack traces that belong to our application.</p><p>   由于我们稍后将在更详细地看到，我们将在定期计时器上设置我们的BPF代码来触发。这意味着每一个x毫秒，我们都会中断CPU并触发EBPF探测器来对堆栈进行示例。请注意，无论CPU上是否有哪个进程都会发生这种情况，因此EBPF Profiler实际上是一个系统范围的分析器。我们可以稍后过滤结果，仅包含属于我们应用程序的堆栈迹线。</p><p>    Surprisingly, that’s it! That’s the entirety of our BPF code for our profiler. Let’s break it down...</p><p>    令人惊讶的是，就是这样！这是我们分析器的全部内容代码。让我们打破它......</p><p> Remember that an eBPF probe runs in the context when it was triggered, so when this probe gets triggered it has the context of whatever program was running on the CPU. Then it essentially makes two calls to  stack_traces.get_stackid(): one to get the current user-code stack trace, and another to get the kernel stack trace. If the code was not in kernel space when interrupted, the second call simply returns EEXIST, and there is no stack trace. You can see that all the heavy-lifting is really done by the Linux kernel.</p><p> 请记住，eBPF探测器在触发时在上下文中运行，因此当此探测器触发时，它具有在CPU上运行的任何程序的上下文。然后它基本上拨打了两个调用stack_traces.get_stackId（）：一个来获取当前用户代码堆栈跟踪，另一个用于获取内核堆栈跟踪。如果代码中断时不在内核空间中，则第二个呼叫只是返回EExist，并且没有堆栈跟踪。您可以看到所有繁重的升降机都是由Linux内核完成的。 </p><p> Next, we want to update the counts for how many times we’ve been at this exact spot in the code. For this, we simply increment the counter for the entry in our histogram associated with the tuple {pid, user_stack_id, kernel_stack_id}. Note that we throw the PID into the histogram key as well, since that will later help us know which process the stack trace belongs to.</p><p>接下来，我们要更新代码中我们在此确切位置的次数的计数。为此，我们只需将计数器递增，以便在与元组{pid，user_stack_id，kernel_stack_id}相关联的直方图中的条目中的条目。请注意，我们也将PID抛入直方图，因为稍后将帮助我们知道堆栈跟踪所属的进程。</p><p>  While the eBPF code above samples the stack traces we want, we still have a little more work to do. The remaining tasks involve:</p><p>  虽然上面的EBPF代码样本我们想要的堆栈痕迹，但我们仍有一点工作要做。其余任务涉及：</p><p>   Setting up our BPF program to run periodically turns out to be fairly easy. Again, credit goes to the BCC and eBPF developers. The crux of this setup is the following:</p><p>   设置我们的BPF程序以定期运行，以便相当容易。再次，信用进入BCC和EBPF开发人员。此设置的关键如下：</p><p>  Here we’re telling the BCC to set up a trigger based on the CPU clock by setting up an event based on  PERF_TYPE_SOFTWARE/PERF_COUNT_SW_CPU_CLOCK. Every time this value reaches a multiple of  sampling_period_millis, the BPF probe will trigger and call the specified  probe_fn, which happens to be our  sample_stack_trace BPF program. In our demo code, we’ve set the sampling period to be every 10 milliseconds, which will collect 100 samples/second. That’s enough to provide insight over a minute or so, but also happens infrequently enough so it doesn’t add noticeable overheads.</p><p>  在这里，我们将通过基于perf_type_software / perf_count_sw_cpu_clock设置一个事件，通过设置事件来设置基于CPU时钟的触发器来设置触发器。每次此值达到SAMPLING_PERIOD_MILLIS的倍数时，BPF探测器将触发并调用指定的探测器_FN，这恰好是我们的SAMPLE_STACK_TRACE BPF程序。在我们的演示代码中，我们将采样周期设置为每10毫秒，这将收集100个样本/秒。这足以提供超过一分钟左右的洞察力，但也很少发生足够的事情，因此它不会添加明显的开销。</p><p> After deploying our BPF code, we have to collect the results from the BPF maps. We access the maps from user-space using the BCC APIs:</p><p> 部署我们的BPF代码后，我们必须从BPF地图中收集结果。我们使用BCC API从用户空间访问地图：</p><p>  Finally, we want to convert our addresses to symbols, and to concatenate our user and kernel stack traces. Fortunately, BCC has once again made our life easy on this one. In particular, there is a call  stack_traces.get_stack_symbol, that will convert the list of addresses in a stack trace into a list of symbols. This function needs the PID, because it will lookup the debug symbols in the process’s object file to perform the translation.</p><p>  最后，我们希望将我们的地址转换为符号，并连接我们的用户和内核堆栈痕迹。幸运的是，BCC再次让我们的生活很容易。特别是，有一个Call Stack_traces.get_stack_symbol，它将将堆栈跟踪中的地址列表转换为符号列表。此功能需要PID，因为它将在进程对象文件中查找调试符号以执行翻译。</p><p>  It actually turns out that the process of turning the stack traces into symbols is the part of this process that introduces the most overhead. The actual sampling of stack traces is negligible. Our next blog post will discuss the performance challenges of making this basic profiler ready for production.</p><p>  它实际上证明将堆栈迹线转换为符号的过程是此过程的一部分引入最大的开销。堆叠迹线的实际采样可忽略不计。我们的下一个博客文章将讨论使这一基本探查器准备生产的基本探查者的性能挑战。 </p><p>   The code and instructions for running the simple eBPF based profiler can be found  here.</p><p>可以在此处找到运行简单的EBPF的分析器的代码和说明。</p><p> The code was designed to have as few dependencies as possible, but you need BCC installed. Follow the instructions in   README.md for more details on building the profiler and a toy app to profiler.</p><p> 该代码旨在具有尽可能少的依赖项，但您需要安装BCC。遵循Readme.md中的说明。有关构建分析器和玩具应用程序的更多详细信息，请访问Profiler。</p><p>     You can then experiment by running it against other running processes in your system. Some processes may not have debug symbols installed, in which case you will see the  [UNKNOWN] marker.</p><p>     然后，您可以通过在系统中运行其他正在运行的进程来进行实验。某些过程可能没有安装调试符号，在这种情况下，您将看到[未知]标记。</p><p> Another fun experiment is to run it against a program written in a different language, like Python or Java. You’ll see stack traces, but they’re probably not what you’re expecting. For example, with Python, what you’ll see is the Python interpreter’s stack traces rather than the Python application (Note: you’ll need the interpreter’s debug symbols to see the functions; On Ubuntu, you can get these by running something like  apt install python3.6-dbg) . We’ll cover profiling for Java and interpreted languages in a future post.</p><p> 另一个有趣的实验是将其与用不同语言编写的程序运行，如Python或Java。你会看到堆栈痕迹，但它们可能不是您所期待的。例如，使用Python，您将看到的是Python解释器的堆栈迹线而不是Python应用程序（注意：您需要翻译的调试符号来查看功能;在Ubuntu上，您可以通过运行类似的东西来获得这些功能安装python3.6-dbg）。我们将在未来的帖子中介绍java和解释语言的分析。</p><p> In part three of this series, we’ll discuss the challenges we faced in building out this simple profiler into a production ready profiler.</p><p> 在本系列的第三部分中，我们将讨论将此简单的探查器建立在生产准备探查器中的挑战。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.px.dev/cpu-profiling-2/">https://blog.px.dev/cpu-profiling-2/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>