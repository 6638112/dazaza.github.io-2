<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MacOS网守和文件隔绕行 macOS gatekeeper and file quarantine bypass</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">macOS gatekeeper and file quarantine bypass<br/>MacOS网守和文件隔绕行 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 11:09:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/8eb17107aa6f71b7b42a18efd51ac2f5.png"><img src="http://img2.diglog.com/img/2021/4/8eb17107aa6f71b7b42a18efd51ac2f5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>👾 Want to play along? I’ve uploaded a sample  Proof of Concept…when run, it simply pops Calculator.app.   ⚠️ Malware</p><p>👾想玩吗？我上传了一个概念样本证明...运行时，它只是弹出计算器.App。 ⚠️恶意软件</p><p> I’ve also uploaded a malware sample ( Shlayer.zip) that exploited this vulnerability in the wild as a 0day! (password: infect3d)</p><p> 我还上传了一个恶意软件示例（shlayer.zip），它在野外爆炸了这个漏洞，作为0day！ （密码：Infect3D）</p><p>     &#34;All_Your_Macs_Are_Belong_To_Us.pdf&#34;.    But first, go update your macOS systems to 11.3, as it contains a patch for a massive bug that affects all recent versions of macOS…a bug that is the topic of this blog post.</p><p>     ＆＃34; all_your_macs_are_belong_to_us.pdf＆＃34;但首先，Go将麦克斯系统更新为11.3，因为它包含一个庞大的错误的修补程序，它会影响所有最近版本的麦克斯...一个是这个博客文章主题的错误。</p><p> This bug trivially bypasses many core Apple security mechanisms, leaving Mac users at grave risk:</p><p> 这个错误逐渐绕过了许多核心Apple安全机制，让Mac用户处于严重风险：</p><p>  opened → owned …and especially worrisome, turns out malware authors are  already exploiting it in the wild as an 0day. Yikes!</p><p>  打开→拥有......特别是令人担忧的是，拒绝恶意软件作者已经在野外利用它作为0day。哎呀！</p><p> Apple patched the bug as CVE-2021-30657, noting &#34;a malicious application may bypass Gatekeeper checks&#34; The security researcher  Cedric Owens uncovered the flaw and initially reported the bug to Cupertino. Epic find Cedric! 🤩</p><p> Apple将Bug修补为CVE-2021-30657，注意到＆＃34;恶意申请可以绕过门卫检查＆＃34;安全研究员CEDRIC OWENS揭示了缺陷，最初向CUPERTINO报告了错误。史诗发现康复！ 🤩</p><p> Cedric notes the bug manifested while building red team payloads via the  appify developer tool. He’s posted a must read, that provides step by step details on how this bug may be practically leveraged to surreptitiously deliver payloads in red team exercises:</p><p> CEDRIC注意通过“应用”开发人员工具构建红色团队有效载荷的同时表现出的错误。他发布了一个必须读取的，这一步一步一步地详细说明这个错误是如何实际利用，以偷偷地在红色团队练习中偷偷地提供有效载荷： </p><p>   &#34;macOS Gatekeeper Bypass (2021) Addition&#34;. However, as the underlying cause of the bug remained unknown, our blog post focuses on uncovering the reason …ultimately discovering a flaw that lay deep within macOS’s policy subsystem(s).</p><p>＆＃34;麦斯卡斯守门人旁路（2021）加法＆＃34;然而，随着错误的根本原因仍然是未知的，我们的博客文章侧重于揭示的原因......最终发现在麦斯科斯政策子系统中奠定深处的缺陷。</p><p> There’s a rather massive amount of information presented in this blog post, so let’s break down what we’re going to cover:</p><p> 在这个博客文章中提供了相当大量的信息，因此让我们分解我们要覆盖的东西：</p><p> Background:   We begin the post with a discussion of common (user-assisted) infection vectors and highlight security mechanisms that Apple has introduced to keep users safe. It is important to understand these core macOS security mechanisms, as they are the very mechanisms the bug trivially and wholly bypasses.</p><p> 背景：我们开始讨论普通（用户辅助）感染载体的帖子，并突出苹果推出的安全机制，以使用户保持安全。了解这些核心麦克斯的安全机制非常重要，因为它们是琐碎的错误和完全绕过的错误。</p><p>    Root Cause Analysis:   The core of the blog post digs deep into the bowels of macOS to uncover the root cause of the bug. In this section, we&#39;ll detail the flaw which ultimately results in the misclassification of quarantined items, such as malicious applications. Such misclassified apps, even if unsigned (and unnotarized), will be allowed to run uninhibited. No alerts, no prompts, and not blocked. Oops!</p><p>    根本原因分析：博客帖子的核心深入挖掘摩托斯的肠道，揭开了错误的根本原因。在本节中，我们＆＃39;请详细说明缺陷，最终导致被隔离物品的错误分类，例如恶意应用程序。这种错误分类的应用程序，即使是无符号（和不排他性的），将被允许运行不羁。没有警报，没有提示，没有阻止。哎呀！</p><p>    In the Wild (0day):   Unfortunately a subversive malware installer is already exploiting this flaw in the wild, as a 0day. In this section of the post, we briefly discuss this worrisome finding.</p><p>    在野外（0day）：不幸的是，一个颠覆恶意软件安装程序已经在野外利用这个缺陷，作为0day。在该帖子的这一部分，我们简要讨论了这个令人担忧的发现。</p><p>    The Patch:   Next, after reverse-engineering Apple&#39;s 11.3 update, we describe how Cupertino addressed this flaw. And good news, once patched macOS users should regain full protection.</p><p>    补丁：接下来，逆向工程苹果＆＃39; S 11.3更新后，我们描述了Cupertino如何解决这个缺陷。和好消息，一旦修补的摩托斯用户应该重新获得全面保护。</p><p>    Protections &amp;  Detections:   Finally, we&#39;ll wrap things up with a brief discussion on protections, most notably highlighting the fact that  BlockBlock already provided sufficient protection against this 0day. Here, we&#39;ll also discuss a novel idea aimed at detecting previous attacks that exploited this flaw, and provide a simple Python script,  scan.py, to automate such detection!</p><p>    保护＆amp;检测：最后，我们＆＃39; LL介绍了关于保护的简要讨论，最显着地突出了阻滞块已经提供了足够的保护，这是对这个0day的这种事实。在这里，我们＆＃39; LL还讨论了一个新颖的想法，旨在检测到攻击这个缺陷的先前攻击，并提供简单的Python脚本，Scan.py来自动解决此类检测！ </p><p>  The majority of Mac malware infections are a result of users (naively, or mistakenly) running something they should not. And while such infections, yes, do require user interaction, they are still massively successful. In fact, the recently discovered  Silver Sparrow malware, successfully infected over 30,000 Macs in a matter of weeks, even though such infections did require such user interactions. (See: “ Mysterious Silver Sparrow Malware Found Nesting on 30K Macs&#34;).</p><p>大多数Mac恶意软件感染是用户（天真或错误）运行他们不应该的结果。虽然这种感染，是的，但是，需要用户互动，但它们仍然非常成功。事实上，最近发现的Silver Sparrow恶意软件，在几周内成功地感染了超过30,000 Mac，即使此类感染确实需要这样的用户互动。 （参见：“Mysterious Silver Sparrow Malware发现在30k Macs＆＃34;）上嵌套。</p><p> And how do malware authors convince such users to infect themselves? Ah, in a myriad of creative, wily, and surreptitious ways such as:</p><p> 恶意软件作者如何说服这些用户感染自己？啊，在一个无数的创造性，狡猾，偷偷摸摸的方式，如：</p><p>  Yes, when the user falls for some of these infection vectors (e.g. pirated applications) we collectively shake our heads and wonder “ well, what did you expect!?&#34;, however other infection vectors are far more surreptitious and arguably the user is not at fault in any way. For example, in a supply chain attack, where a legitimate software distribution website is hacked and legitimate products are trojanized, it’s unreasonable to blame any user who inadvertently downloads and runs such software.</p><p>  是的，当用户落下一些感染载体（例如盗版应用程序）时，我们共同摇动我们的头脑和奇迹“好吧，你期望了什么！？＆＃34;但其他感染载体更侧视，可以说不是以任何方式都没有错。例如，在供应链攻击中，被黑客攻击和合法产品的基准攻击，并且特制于特洛伊，因此责备无意中下载并运行此类软件的用户是不合理的。</p><p> Regardless of who’s at fault (or not), Apple seems to feel personally attacked. Besides of course wanting what’s best for their  shareholders users, they have an image to uphold! Remember, “ Macs Don’t Get Malware!” (tm).</p><p> 无论谁在故障（或不），苹果似乎都感到亲自攻击。除了想要对他们的股东用户最适合的课程，他们有一个秉承的形象！请记住，“Mac不会得到恶意软件！” （Tm值）。</p><p> All kidding (and criticisms) aside, over the years Apple has taken several important steps aimed at preventing any and all “user-assisted” infections. Here, we briefly recap such major steps that include the addition of OS-level security mechanisms such as File Quarantine, Gatekeeper, and Application Notarization. An understanding of these foundation macOS protection mechanism is important as many users, and even some enterprises have come to (solely) depend on them. Which is fine(ish), unless Apple ships buggy code that undermines all such protections!</p><p> 除了多年来，所有开玩笑（和批评），苹果都采取了几个重要的步骤，旨在预防任何和所有“用户辅助”感染。在这里，我们简要重新回顾了包括添加OS级安全机制（如文件隔离，网守和应用公证）的主要步骤。对这些基础Macos保护机制的理解是重要的，因为许多用户都很重要，甚至一些企业已经到了（完全）取决于他们。除非Apple船舶破坏了所有此类保护的错误代码，否则这是罚款（ISH）！</p><p>  File Quarantine, was introduced in OSX Leopard (10.5), all the way back in 2007! When a user first opens a downloaded file such as an application, File Quarantine provides a warning to the user that requires explicit confirmation before allowing the file to execute. The idea is simply to ensure that the user understands that they are indeed opening an application (even if the file looks like, say, a PDF document).</p><p>  文件隔离，在osx豹（10.5）中引入了2007年的一路返回！当用户首先打开诸如应用程序的下载文件时，文件隔离区向用户提供了在允许文件执行之前需要显式确认的警告。这个想法只是为了确保用户理解它们确实打开了应用程序（即使文件看起来像，例如，PDF文档）。</p><p> For an example of File Quarantine in action let’s look at the  OSX.LaoShu malware. In order to surreptitiously trick users into infecting themselves, attackers sent targeted victims customized emails with a link to a malicious URL. If the user clicked on the link, a malicious application (masquerading as a PDF document) would be automatically downloaded:</p><p> 有关文件隔离的示例，请允许我们查看osx.laoshu恶意软件。为了让用户偷偷摸摸自己感染自己，攻击者将针对性受害者发送定制的电子邮件与恶意URL的链接。如果用户点击链接，将自动下载恶意应用程序（伪装为PDF文档）： </p><p>  A malicious app (OSX.LaoShu), masquerading as a PDF (image credit: Sophos). If the user would attempt to open what they (understandably) believed was a PDF document, File Quarantine would spring into action, alerting the user that this was in fact an application,  not a harmless PDF document:</p><p>恶意应用程序（OSX.Laoshu），伪装为PDF（图片信用：Sophos）。如果用户将尝试打开它们（可理解）认为是PDF文档，则文件隔离会将弹出到行动，警告用户实际上是一个申请，而不是无害的PDF文件：</p><p>  File Quarantine in action (image credit: Sophos). Ideally the user would recognize their (near) faux pas and the infection would be thwarted thanks to File Quarantine! It should be noted that even today, a File Quarantine prompt is shown for approved (i.e. notarized) applications.</p><p>  文件隔离在行动中（图像信用：Sophos）。理想情况下，用户将认识到他们的（近的）人造PAS，感谢文件检疫将被挫败！应该指出的是，即使在今天，批准的（即公证）申请的文件隔离提示也会显示。</p><p>  Unfortunately users kept infecting themselves, often by ignoring or simply clicking through File Quarantine alerts. To combat this, as well as evolving malware infection vectors, Apple introduced Gatekeeper in OSX Lion (10.7). Built atop File Quarantine, Gatekeeper checks the code signing information of downloaded items and blocks those that do not adhere to system policies. (For example, it checks that items are signed with a valid developer ID):</p><p>  遗憾的是，用户通常通过忽略或只需通过文件隔离警报来感染自己。为了解决这个问题，以及不断发展恶意软件感染载体，Apple在osx狮子（10.7）中引入了门守。内置文件隔离，网守检查下载项目的代码，并阻止那些不遵守系统策略的信息。 （例如，它检查项目是否使用有效的开发人员ID签名）：</p><p>  A Gatekeeper overview Apple’s logic was rooted in the (mis)belief that malware authors would not be able to obtain such Apple Developer IDs, and thus their malware would remain unsigned and thus generically blocked by Gatekeeper. In the image above, note that when unsigned malware is executed, Gatekeeper will block it and alert the user. Moreover, there is no option in the Gatekeeper prompt to allow the (unsigned) code to run. Thus the user is protected. Hooray?</p><p>  一个网守概述Apple的逻辑植根于（MIS）信念中，恶意软件作者无法获得此类Apple开发人员ID，因此他们的恶意软件将保持无符号，因此由Gatekeeper慷慨地阻止。在上面的图像中，注意当执行未签名的恶意软件时，网守将阻止并警告用户。此外，网守提示没有选项以允许（未签名）的代码运行。因此，用户受到保护。赫雷？</p><p> Of course it turned to be fairly trivial for attackers to obtain Apple Developer IDs and thus sign their malicious creations. For example in a supply chain attack against the popular  MacUpdate.com website, attackers trojanized and (re)signed popular software such as Firefox:</p><p> 当然，它转身对攻击者获得苹果开发人员ID的相当微不足道，从而签署他们的恶意创作。例如，在对流行的Macupdate.com网站的供应链攻击中，攻击者Trojanized和（RE）签署了Firefox等流行软件：</p><p>  Trojanized Firefox (note: &#34;Developer ID Application: Ramos Jaxson&#34;) If users downloaded and ran the trojanized Firefox, Gatekeeper would allow it …as it was “validly” (re)signed. Thus the system would be infected.</p><p>  Trojanized Firefox（注意：＆＃34;开发人员ID应用程序：Ramos Jaxson＆＃34;）如果用户下载并运行了Trojanized Firefox，则网守将允许它......因为它是“有效地”（RE）签名。因此，系统将被感染。</p><p> Unfortunately even today, it’s still trivial for attackers to obtain such Apple Developer IDs and thus sign their malicious creations:</p><p> 遗憾的是，即使在今天，攻击者仍然琐碎的攻击者获得此类Apple开发人员ID，因此签署恶意创作： </p><p>  I noticed dozen websites flourishing (even through google ads) for buying/selling/renting Apple developer entreprise accounts and Apple developer certificates. I guess the macOS malware season has started 😂🌻🌼  pic.twitter.com/PQnrUKQhUF</p><p>我注意到十几个网站繁荣（甚至通过谷歌广告）购买/销售/租用Apple开发人员企业账户和Apple开发人员证书。我猜麦斯科斯恶意软件已经开始😂🌻🌼pic.twitter.com/pqnrukqhuf</p><p>— taha karim ז (@lordx64)  April 3, 2021</p><p> -  Taha Karimז（@ Lordx64）4月3日，2021年4月3日</p><p> It should be noted that even if Gatekeeper is bypassed a File Quarantine prompt would still be shown to the user. Recall that such a prompt requires explicit user-approval. Still, as Gatekeeper failed to be a panacea, Apple had to respond …yet again.</p><p> 应该注意的是，即使网守被绕过文件隔离提示，仍将显示给用户。回想一下，这样的提示需要明确的用户批准。尽管如此，由于守门人未能成为灵丹妙药，苹果必须再次回应......又一次。</p><p>  Most recently, macOS Catalina (10.15) took yet another step at combating user-assisted infections with the introduction of Application Notarization requirements. These requirements ensure that Apple has scanned and approved all software before it is allowed to run, giving users, (as noted by Apple), “confidence” that the software, “has been checked for malicious components”:</p><p>  最近，MacOS Catalina（10.15）在引入应用公证要求时，在打击用户辅助感染的另一步。这些要求确保苹果在允许运行之前扫描并批准所有软件，给予用户，（如苹果指出的），“信心”那个软件，“已经检查了恶意组件”：</p><p>  A notarization overview Note that similar to a Gatekeeper alert, in a Notarization alert there is no option for the user to allow the unnotarized code to run. Thus code that has not been scanned and notarized by Apple will be blocked.</p><p>  公证概述注意，类似于网守警报，在公证警报中，用户无法选中允许不传达的代码运行。因此，Apple未被扫描和公证的代码将被阻止。</p><p> Notarization is clearly the most draconian, yet arguably “best” approach yet to protect macOS users from inadvertently infecting themselves.…and rather humorously has resulted in hackers sliding into my DMs, as notarization apparently ruined their whole operation. Ha!</p><p> 公证显而易见的是最具武装组织，但可以说是“最好的”方法，尚未保护麦斯科斯州用户从无意中感染自己。......而且相当悲惨导致黑客滑入我的DMS，因为公证显然毁了他们的整个操作。哈！</p><p>  Notarization vs. Hackers  Before we detail a logic flaw in macOS that allows an attacker to trivially and reliably bypass  all of these foundational mitigations, let’s briefly talk about the quarantine attribute. You may have been wondering, how does macOS know to analyze a file in order to possibly display a File Quarantine, Gatekeeper, or Notarization prompt? The answer is the quarantine attribute!</p><p>  公证与黑客在我们详细介绍麦克斯中的逻辑缺陷之前，允许攻击者进行微不足道，可靠地绕过所有这些基础，让我们简要介绍隔离区属性。您可能一直在想，麦克斯如何知道如何分析文件，以便可能显示文件隔离，网守或公证提示？答案是Quarantine属性！ </p><p> Simply put, whenever an item is downloaded from the Internet (via an application such as a browser), macOS or the application that downloaded the item, will tag it with an extended attribute, named  com.apple.quarantine. You can confirm this for yourself. First download any file via your browser and then run macOS’s “extended attribute” utility,  xattr along with the path to file:</p><p>只需放置，只要项目从Internet（通过诸如浏览器的应用程序）下载，麦斯卡斯或下载该项目的应用程序，都将使用名为com.apple.quartine的扩展属性标记为它。您可以为自己确认这一点。首先通过浏览器下载任何文件，然后运行MacOS的“扩展属性”实用程序，XATTR以及文件路径：</p><p>  Note that the  -p option will print out the contents of the specified extended attribute. For the  com.apple.quarantine this includes various flags, a time stamp, the responsible application that downloaded the file, and a UUID that maps to a key in the  com.apple.LaunchServices.QuarantineEventsV* database.</p><p>  请注意，-p选项将打印出指定的扩展属性的内容。对于com.apple.quartine这包括各种标志，时间戳，下载文件的负责任的应用程序，以及映射到com.apple.launchservices.quarantineventsv *数据库中的密钥的uuid。</p><p> Whenever the user first attempts to open a file that contains a quarantine attribute (i.e. anything downloaded from the Internet), macOS will launch the process in a suspended state. Then, the system will perform a myriad of complex checks on the file, designed to trigger the appropriate alert or prompt. On modern versions of macOS the user will either be shown:</p><p> 每当用户首次尝试打开包含隔离属性的文件（即从Internet下载的任何内容），麦斯科座将在暂停状态下启动进程。然后，系统将在文件上执行无数的复杂检查，旨在触发适当的警报或提示。在现代版本的MacOS上，用户将被显示：</p><p> A (File Quarantine) prompt requiring explicit user consent (if the item is validly signed and notarized).  …or</p><p> a（文件隔离区）提示要求明确的用户同意（如果项目有效签名和公证）。 …或者</p><p> A (Notarization) alert informing the user that the file cannot be run (if the item is not validly signed and notarized).</p><p> a（公证）警报通知用户无法运行文件（如果项目未有效地签名和公证）。</p><p> If the process is allowed (signed &amp; notarized) and the user approves it, the system will then unsuspend (resume) it …allowing it to now execute.</p><p> 如果允许该过程（签名＆amp;公证）和用户批准，则系统将毫无疑问（恢复）它...允许它现在执行。</p><p> If a file does not contain the com.apple.quarantine attribute, macOS assumes it&#39;s a local file. As such, none of the checks will be performed and thus no prompts/alerts will be shown. This is by design, and is not a bug.  While this means malware that is  already on the box can download unsigned/unnotarized (second-stage) payloads, strip the quarantine attribute, then launch said payloads without fear of alerts …the fact remains the  initial malware (or its delivery mechanism) will possess the quarantine attribute, and thus will be subjected to such checks and/or alerts when launched.</p><p> 如果文件不包含com.apple.quartine属性，则MacOS假定它＆＃39; s一个本地文件。因此，均未执行任何检查，因此不会显示提示/警报。这是通过设计，而不是一个错误。虽然这意味着已经在框上的恶意软件可以下载无符号/不排他性（第二阶段）有效载荷，但是剥离隔离区属性，然后启动所述有效负载而不担心警报......事实仍然是初始恶意软件（或其交付机制）将拥有隔离属性，因此将在推出时进行此类支票和/或警报。 </p><p> But what if I told you there was a trivial and reliable way to bypass any and all such prompts!? …meaning, if a user simply double-clicks on the file, game freaking over!? 🥲</p><p>但如果我告诉过你，绕过任何和所有此类提示，那么何时何地绕过任何琐碎和可靠的方式！？ ......意思，如果用户只需双击该文件，游戏吓坏了！？ 🥲</p><p>  Since 2007 (when File Quarantine was introduced) macOS has alerted users whenever they attempt to launch an application that has been downloaded from the Internet. And now, on recent versions of macOS, unless that application has been scanned and explicitly approved (notarized) by Apple, macOS will refuse to run the file …or will it!?</p><p>  自2007年以来（引入文件隔离区时）麦斯科斯队启动了用户在尝试启动从互联网下载的应用程序时提醒用户。而现在，在最近的麦斯科斯版本中，除非该申请已经被Apple扫描并明确批准（公证），宏将拒绝运行该文件......或者会拒绝！</p><p> Unfortunately as we’ll see, due to a subtle logic bug deep within Apple’s policy engine, it was possible to craft a malicious application that though unsigned (and hence unnotarized), would be allowed to launch with no prompts nor alerts. No File Quarantine prompt, no Gatekeeper alert, no Notarization alert …nothing!</p><p> 不幸的是，由于Apple的策略引擎中深入了解了一个微妙的逻辑错误，可以制作一个恶意应用程序，虽然无符号（并且因此不公开），将被允许在没有提示和警报时启动。没有文件隔离提示，没有网守警报，没有公证警报......没有！</p><p> In the following demo, a proof of concept application named “Patricks_Resume” is downloaded. Though it appears to be a harmless PDF document, when opened, though unsigned, unnotarized, and quarantined, it’s able to launch Calculator.app (or really do pretty much anything else):</p><p> 在以下演示中，下载了名为“patricks_resume”的概念应用程序的证明。虽然它似乎是一个无害的PDF文件，但是在打开时，虽然无符号，不通的和隔离，但它能够启动Calculator.App（或者真的做得几乎没有其他事情）：</p><p>  Note that the exploited system is a fully patched M1 Macbook, running the latest macOS Big Sur (11.2.3).</p><p>  请注意，已剥削的系统是一个完全修补的M1 MacBook，运行最新的MacOS Big Sur（11.2.3）。</p><p>     Unsigned, unnotarized, and quarantined  It appears that this bug was introduced in macOS 10.15 ...thus older versions of macOS do not seem be vulnerable. If I had to guess, it was likely introduced along with macOS 10.15’s new notarization logic. Thus the goal of attempting to secure and lock down macOS wholly backfired:</p><p>     毫无符号，不排他性和隔离，似乎在MacOS中引入了此错误...因此，旧版本的宏似乎并不脆弱。如果我不得不猜到，很可能与MacOS 10.15的新公证逻辑一起引入。因此，尝试安全和锁定宏的目标是完全被反馈的：</p><p>  ...meanwhile, at Cupertino? (image credit: @urupzia)</p><p>  ......同时，在Cupertino？ （图片信用：@URUPZIA） </p><p>  Obviously this vulnerability is massively bad, as it affords malware authors the ability to return to their proven methods of targeting and infecting macOS users. Though we’ll talk about 3rd-party methods of protections (that existed before Apple’s patch!) as well as methods of detections exploitation attempts of this bug, first let’s walk through the process of uncovering the root cause, the underlying flaw.</p><p>显然，这种漏洞是非常糟糕的，因为它提供了恶意软件作者的能力返回他们经过验证的目标和感染麦斯科斯用户的方法。虽然我们将谈论第三方保护方法（苹果的补丁之前存在！）以及检测该错误的剥削尝试方法，首先让我们走过揭开根本原因的过程，潜在的缺陷。</p><p> Our analysis was performed on a fully patched macOS Big Sur (11.2.3) system. Due to &#34;security&#34; features on M1 systems (that hinder debugging), we&#39;ll stick to a Intel/x86_64 system. However as the flaw is a logic issue, the systems underlying architecture is irrelevant (as illustrated in the exploitation of a M1 system in the video above).</p><p> 我们的分析是对完全修补的麦斯科斯大学（11.2.3）系统进行的。由于＆＃34;安全＆＃34; M1系统上的功能（阻碍调试），我们＆＃39; LL坚持到英特尔/ X86_64系统。然而，随着缺陷是逻辑问题，底层架构的系统是无关的（如上面视频中的M1系统的开发方式所示）。</p><p> Though the underlying flaw is found deep in the bowels of macOS, don’t worry we’ll gently ease in.</p><p> 虽然潜在的缺陷在麦克斯的肠子深处发现，但不要担心我们会轻松地轻松。</p><p> First, take a look at the our proof of concept application ( PoC.app) that triggers the vulnerability (as this will be launched with no alerts nor prompts, even though it’s unsigned, unnotarized, and quarantined).</p><p> 首先，查看我们对触发漏洞的概念应用程序（Poc.App）的证明（因为这将无法提醒，即使它是无符号，不排他性和隔离的）。</p><p>  Our proof of concept application   The application’s bundle is “missing” several standard components, most notably there is no  Info.plist file. (An  Info.plist file contains meta information about an application, such as the path to its executable).   Instead, the application is solely composed of a directory named  PoC.app, a  Contents subdirectory, a  MacOS sub-subdirectory, and then within that, a file whose name matches that of the (top-level) application ( PoC).</p><p>  我们的概念应用证明应用程序的捆绑包是“缺少”几个标准组件，最值得注意的是没有信息文件。 （INFO.PLIST文件包含有关应用程序的元信息，例如其可执行​​文件的路径）。相反，应用程序仅由名为PoC.App的目录，内容子目录，麦斯科群组子目录，然后在其中的文件中组成，该文件与（顶级）应用程序（PoC）匹配的文件。</p><p> The application’s executable component ( PoC) is not a mach-O binary, but rather a (bash) script:</p><p> 应用程序的可执行组件（PoC）不是Mach-O二进制文件，而是A（Bash）脚本：</p><p> In terms of the first observation, it turns out that many of the standard components of an application’s bundle (e.g. the  Info.plist file) are indeed optional. In fact, it appears that the system treats anything that ends in  .app as an application. To test this, simply create an empty folder name  foo.app and double-click it. Though it errors out (as it’s just a folder, with no executable content), the error prompt confirms that the system did indeed try to launch it as an application:</p><p> 就第一次观察而言，事实证明，应用程序捆绑包的许多标准组件（例如，INFO.PLIST文件）确实是可选的。事实上，系统似乎将在.app中作为应用程序结束的任何东西。要测试此功能，只需创建一个空文件夹名称foo.app并双击它。虽然它错误（因为它只是一个文件夹，没有可执行内容），但错误提示确认系统确实尝试将其推出为应用程序： </p><p>  ...tried (and failed) to launch as an app Turns out, if we add a  Contents folder, then (within that) a  MacOS folder, and finally (within that) an executable item …it will successfully run! Though rather bare-boned, that’s apparently all that’s needed. It’s worth reiterating that without an  Info.plist file, the executable item’s name,  must match the name of the application. This is how macOS is still able to ascertain what to execute when the user double clicks the “app”. Hence, for our bare-bones proof of concept application ( PoC.app), the item’s name must be  PoC:</p><p>...通过应用程序来启动（和失败）来启动（如果我们添加内容文件夹，那么（在其中）麦斯科群岛文件夹中，最后（在那之内）可以成功运行！虽然相当赤裸裸的是，这显然是所需要的。值得重新重新介绍，没有info.plist文件，可执行项目的名称必须与应用程序的名称匹配。这就是MacOS仍然能够确定当用户双击“App”时执行的内容。因此，对于我们的裸骨概念应用程序（PoC.App）证明，项目的名称必须是PoC：</p><p>  Our bare-boned PoC app&#39;s bundle structure  The &#34; appify&#34; developer script on github, will programmatically create such a bare-bones application for you (that unintentionally, will trigger this vulnerability).</p><p>  我们裸BOC应用程序＆＃39; S捆绑结构＆＃34; Appify＆＃34; GitHub上的开发人员脚本将以编程方式为您创建如此裸露的应用程序（无意中会触发此漏洞）。</p><p> Before moving on, let’s ratchet up macOS application policy to its highest and most restrictive level, so that only applications from the macOS app store are allowed. In theory this means that external applications, even if notarized will be blocked by the OS:</p><p> 在继续前进之前，让我们将MacOS应用程序策略颠簸到最高，最严格的级别，以便只允许来自麦斯科座应用商店的应用程序。在理论上这意味着外部应用程序，即使公证化将被操作系统阻止：</p><p>  Application policy It’s important though to note that the vulnerability also presents itself at lower / the default policy settings. That is to say, it is unrelated and unaffected by the system policy settings.</p><p>  应用程序策略虽然指出，该漏洞还呈现较低/默认策略设置。也就是说，它是不相关的并且不受系统策略设置的影响。</p><p> Let’s now upload this “bare-bones” application, and then download it to simulate an attack. Once downloaded, we can confirm that, as expected, the application has been automatically tagged with the  com.apple.quarantine extended attribute:</p><p> 让我们现在上传这个“裸骨”应用程序，然后下载它来模拟攻击。一旦下载，我们可以确认，正如所预期的那样，应用程序已自动使用com.apple.quartine扩展属性自动标记：</p><p>  Thus we can assume (and later confirm) that the bug is not related to a missing (or say corrupted)  com.apple.quarantine attribute. And due to the presence of this quarantine attribute, we’ll see it will  still be evaluated by macOS’s “should-this-application-be-allowed-to-run” logic.</p><p>  因此，我们可以假设（并稍后确认）该错误与丢失（或损坏）com.apple.quartine属性无关。由于存在此隔离属性，我们将看到它仍将通过MacOS的“应该 - 此应用程序被允许运行”逻辑评估。</p><p> We can also confirm (via a tools such as  WhatsYourSign), that the application is unsigned (and thus also unnotarized):</p><p> 我们还可以确认（通过诸如Whatsyoursign等工具），该应用程序是无符号（因此也不是不协调）： </p><p>  PoC.app: unsigned/unnotarized Due to the fact that the application has been tagged with a quarantine attribute, and that it is unsigned (and thus not notarized), one would certainly think it would be soundly blocked by macOS. But as we noted early this is not the case …it’s allowed to run uninhibited.</p><p>poc.app：由于应用程序已被标记为隔离属性，并且它是无符号（因此未公证）的事实，因此肯定会认为它会被宏封锁所封锁的事实，因为它毫无符合。但正如我们早早所说，这不是这种情况......它被允许运营不羁。</p><p> As the quarantined application is allowed (with no alerts nor prompts), this implies a bug is somewhere in macOS’s application “evaluation” logic. Unfortunately (for us), when a user launches an application no less than half a dozen user-mode applications, system daemons and the kernel are involved.</p><p> 由于允许隔离的应用程序（没有警报或提示），这意味着一个错误是麦斯科斯州应用程序“评估”逻辑的某个错误。不幸的是（对于我们），当用户启动应用程序时不少于有多次用户模式应用程序，涉及系统守护程序和内核。</p><p> In a 2016 talk at ShmooCon titled, “ Gatekeeper Exposed; Come, See, Conquer&#34;, I provided a detailed (although now somewhat dated) walk-through of these interactions:</p><p> 在2016年在Shmoocon的谈话中标题为“Gatekeeper暴露”来吧，看，征服＆＃34;我提供了详细的（虽然现在有些日期了）这些互动：</p><p>  Launching an application is a complicated ordeal Since this talk, Apple has expanded (read: complicated) this process, adding XPC calls into its system policy daemon,  syspolicyd, and its XProtect (anti-virus) agent,  XprotectService.</p><p>  启动应用程序是一个复杂的折磨，因为此话语以来，Apple已扩展（阅读：复杂）此过程，将XPC调用添加到其系统策略守护程序，syspolicyd及其xprotect（反病毒）代理，xprotectservice。</p><p> Instead of painstakingly walking through every single one of these interprocess and kernel interactions, let’s see if we can first zero in on the likely location of the bug via a more passive approach …log messages!</p><p> 而不是煞费苦心地行走每一个口学和内核互动，而让我们看看我们是否可以通过更多被动方法来首先归零。日志消息！</p><p>  Recall that our problematic proof of concept application is a rather abnormal “bare-bones” application whose executable component is a script (versus a normal mach-O binary).</p><p>  回想一下，我们的概念应用程序证明是一个相当异常的“裸骨”应用程序，其可执行组件是脚本（与正常MACH-O二进制）。</p><p> Our idea to get a better sense of where the bug may lie is rather simple. While monitoring system logs let’s run:</p><p> 我们的想法让虫子可能撒谎的更好的位置相当简单。监视系统日志让我们运行： </p><p> A “normal” application …containing the standard application bundle files (such as an  Info.plist file), as well as standard mach-O executable.</p><p>一个“正常”应用程序...包含标准应用程序捆绑文件（例如Info.Plist文件），以及标准MACH-O可执行文件。</p><p> A script-based application ( Script.app) …containing the standard application bundle files (such as an  Info.plist file), but a (bash) script as its executable.</p><p> 基于脚本的应用程序（Script.App）...包含标准应用程序包文件（例如Info.Plist文件），但是（Bash）脚本作为其可执行文件。</p><p> Our proof-of-concept application ( PoC.app) …missing the standard application bundle files (such as an  Info.plist file),  and having a (bash) script as its executable.</p><p> 我们的概念验证应用程序（PoC.App）...缺少标准应用程序包文件（例如info.plist文件），并将（bash）脚本作为可执行文件。</p><p> All three are unsigned and downloaded from the Internet (i.e. tagged with the  com.apple.quarantine extended attribute). As the “normal” and script-based application are both blocked (as expected) ideally we’ll quickly uncover any divergent logic which can point us decisively in the direction of a bug which allows our PoC to run!</p><p> 这三个都是无符号的，从互联网上下载（即，用com.apple.quartine扩展属性标记）。随着“正常”和基于脚本的应用程序都被阻止（如预期），理想情况下，我们将迅速揭示任何不同的逻辑，这些逻辑可以在允许我们PoC运行的错误方向上果断地指向我们！</p><p> On recent versions of macOS, Apple has unified all logging and provided a new utility (aptly named)  log to parse and view all log messages. If executed with the  stream parameter, the  log utility will s</p><p> 在最近的麦克斯版本上，Apple统一所有日志记录，并提供了一个新的实用程序（Aptly命名）日志来解析并查看所有日志消息。如果使用Stream参数执行，则日志实用程序将是</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://objective-see.com/blog/blog_0x64.html">https://objective-see.com/blog/blog_0x64.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/网守/">#网守</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>