<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用方案查找两个排序整数列表的中位数 Using Scheme to Find the Median of Two Sorted Integer Lists</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using Scheme to Find the Median of Two Sorted Integer Lists<br/>使用方案查找两个排序整数列表的中位数 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 06:46:57</div><div class="page_narrow text-break page_content"><p>I have been picking up the basics of Scheme recently as part of reading and working my way through Chris Hanson and Gerald Jay Sussman’s  Software Design for Flexibility. Scheme is a dialect of Lisp created in the 1970s by Gerald Jay Sussman and Guy L. Steele. As such, it is older than some other well-known dialects like Common Lisp, Clojure and Racket, all of which have been influenced by Scheme. Specifically, I am using  MIT/GNU Scheme – there are apparently pretty large differences between implementations due to the minimalism of the language specification.</p><p>我最近一直在借鉴方案的基础知识，作为通过Chris Hanson和Gerald Jay Sussman的软件设计的阅读和努力工作的一部分。计划是在20世纪70年代创建的LISP方言，由Gerald Jay Sussman和Guy L. Steele。因此，它比普通的LISP，Clojure和球拍等其他一些众所周知的方言，所有这些都是由方案的影响。具体而言，由于语言规范的极简主义，实现的实施方式显然存在很大的差异。</p><p> I don’t have much experience with Lisps, apart from some noodling with Clojure in our functional programming group at work years ago. So a few months ago, in order to get familiar with the syntax and some of the more basic constructs (leaving the metaprogramming and so on for later), I solved a few problems from LeetCode, one of which was  Median of Two Arrays, which I will now proceed to explain.</p><p> 除了在几年前的工作规划集团的某些面条的某些面条，我没有太多的Lisps经验。所以几个月前，为了熟悉语法和一些更基本的构造（留下了几个基本的构造，我解决了来自LeetCode的一些问题，其中一个是两个阵列的中位数，哪个我现在将继续解释。</p><p> The problem is this: given two sorted integer lists, calculate the median value of the combination of the two lists, ideally in  O(log(m+n)) time. For example:</p><p> 问题是：给定两个排序的整数列表，计算两个列表组合的中位值，理想地在O（日志（m + n））时间。例如：</p><p>  Let us start by implementing a kind of naïve, slow version. Getting the median of a single sorted list is trivial: it is either the central value if the list has an odd-numbered length, or the mean of the two central values otherwise. So the naïve approach is to combine the two lists, sort the combined list and get the median from the combined and sorted list. An implementation could look something like this:</p><p>  让我们开始实现一种天真，慢速。获取单个排序列表的中位数是微不足道的：如果列表具有奇数长度，或者两个中心值的平均值，则是中央值。因此，Naïve方法是组合两个列表，对组合列表进行排序并从组合和排序的列表中获取中位数。实施可以看出这样的东西：</p><p> ;; Returns the median value of two sorted integer lists.  ( define  ( slow-median l1 l2 )   ( let  ( ( l  ( sort  ( append l1 l2 ) &lt; ) ) )   ( if  ( =  ( modulo  ( length l )  2 )  0 )   ( /  ( +  ( list-ref l  ( integer-floor  ( -  ( length l )  1 )  2 ) )   ( list-ref l  ( integer-ceiling  ( -  ( length l )  1 )  2 ) ) )   2 )   ( list-ref l  ( integer-floor  ( length l )  2 ) ) ) ) )</p><p> ;;返回两个排序整数列表的中位值。 （定义（慢中位L1 L2）（设（l（l（sort（prote（附加（附加（附加）））））（如果（modulo（modelo（lence l）2）0）（/（+（list-ref l（list-ref l））（/（列表 -  ref l（整数地板（ - （长度L）1）2）））（列表-fiLe（整数 - 上限（ - （长度l）1）2）））2）（列表-fr（整数 - 楼层（长度L）） 2）））））））</p><p> The procedure begins by merging the two lists ( append) and sorting the new list in ascending order ( sort ... &lt;). Then it checks whether the combined list has an even-numbered length. If so, it gets the two central values and returns their mean. If not, it returns the single central value. ( list-ref here returns the list element at a given index;  integer-floor is integer division rounded down;  integer-ceiling is integer division rounded up.)</p><p> 该过程开始通过合并两个列表（附加）并按升序排序新列表（排序......）。然后它检查组合列表是否具有均匀长度。如果是这样，它可以获得两个中心值并返回其平均值。如果没有，它会返回单个中心值。 （list-ref此处返回给定索引处的列表元素;整数分割舍入;整数天花板是整数分区圆形。）</p><p>  The more efficient algorithm for solving this problem is basically a more complicated variant of  binary search. It is more complicated than the common binary search both because it is searching two lists simultaneously and because the search in each list depends on the values of the other list.</p><p>  求解此问题的更有效的算法基本上是二进制搜索的更复杂的变体。它比常见的二进制搜索更复杂，因为它正在同时搜索两个列表，因为每个列表中的搜索都取决于其他列表的值。 </p><p> The highlighted answer on LeetCode is pretty abstruse. (There is a better explanation  here.) The gist of it is that we can rephrase the problem to one not of finding the median of two sorted lists, but of finding how many elements each of the two lists have that are the median or are below the median. So for example in  (1,3,5) (2,4) the first list contributes two values (one and three) and the second list contributes one (two), since the median is three. If we have these two sublists, calculating the median is trivial.</p><p>Leetcode上的突出显示的答案是漂亮的奥斯特。 （这里有一个更好的解释。）主旨是我们可以将问题重新查找一个不寻找两个排序列表中位数的问题，而是找到两个列表中的每个列表中的多少元素或者是在中位数下方。例如，在（1,3,5）（2,4）中，第一个列表贡献了两个值（一个和三个），第二个列表贡献一个（两），因为中位数是三个。如果我们有这两个子师，计算中位数是微不足道的。</p><p> So the algorithm will solve that problem first. The way to solve that problem is to recursively divide both lists in half. If the last element of the first half of each list is smaller than the first element of the opposite list’s second half, then we are good to go – the two first halves are the values up to and including the median. If, on the other hand, the last element of the first half of one list is larger than the first element of the second half of the other list, then we know that the first half of the other list is below the median, but we still need to do this same comparison between the first half of the first list and the second half of the other list in order to find the rest of the elements below the median.</p><p> 因此，算法将首先解决该问题。解决这个问题的方法是递归地将两个列表划分为一半。如果每个列表的前半部分的最后一个元素小于相反列表的下半部分的第一个元素，那么我们很好 - 这两个第一个半数是达到和包括中位数的值。如果另一方面，如果一个列表的前半部分的最后一部分大于其他列表的后半部分的第一个元素，那么我们知道其他列表的前半部分位于中位数以下，但我们仍需要在第一个列表的前半部分和其他列表的下半部分仍然需要进行相同的比较，以便在中位数下方找到其余元素。</p><p>  Now we see that the last value of the first half of the first list is larger than the first value of the second half of the second list: 7 &gt; 5. That means that the first half of the second list,  (2,3,4), is below the median, but we still don’t know which of the elements in the first half of the first list and the second half of the second list are. So we return  () (2,3,4) (because the second list contributed three elements) plus the result of calling the procedure recursively with those two lists,  (1,4,7) and  (5,6).</p><p>  现在我们看到第一个列表的前半部分的最后一个值大于第二个列表的下半部分的第一个值：7＆gt;这意味着第二个名单的上半场（2,3,4），低于中位数，但我们仍然不知道第一个列表的前半部分和下半部分的哪个元素第二个列表是。所以我们返回（）（2,3,4）（因为第二个列表贡献了三个元素）加上递归调用该过程的过程，其中两个列表（1,4,7）和（5,6）。</p><p>  Neither list has a first half whose last element is larger than the first element of the other list’s second half, in other words 4 ≤ 6 and 5 ≤ 7, so we are good to go here and return  (1,4) (5) (because the first list contributed two elements and the second list one).</p><p>  既没有列表都没有上半部的最后一半，其最后一个元素大于其他列表的下半部分的第一元素，其他单词4≤6和5≤7，所以我们很好地走到这里并返回（1,4）（5） （因为第一个列表贡献了两个元素和第二个列表）。</p><p> In total, the algorithm returns  () (2,3,4) ++ (1,4) (5) = (1,4) (2,3,4,5), giving us a median of  (4 + 5) / 2 = 4.5.</p><p> 总共算法返回（）（2,3,4）++（1,4）（5）=（1,4）（2,3,4,5），给我们一个（4 + 5 ）/ 2 = 4.5。</p><p> I hope that makes some kind of sense. The actual algorithm is a little bit more complicated, because it needs to track the precise number of elements that remain to make up the desired number, the number of elements smaller than and including the median (six in the example above, because the two lists had ten elements in total, and when the total is even, we need both central values). This seems necessary because the algorithm can’t always round up or always round down when splitting the lists – it depends on the context. So that is actually fed into the recursive procedure at each step in addition to the two lists. I call this value  desired-n inside the procedure. Maybe there is a way to make the algorithm work without this addition, but I could not find it.</p><p> 我希望这有一种感觉。实际算法有点复杂，因为它需要跟踪剩余的元素数量，这些元素仍然可以构成所需的数量，元素数量小于和包括中位数（上面的示例中的六个，因为这两个列表总共有十个元素，当总数甚至时，我们需要两个中心值）。这似乎是必要的，因为在分割列表时，算法不能总是舍入或始终舍入 - 这取决于上下文。因此，除了两个列表之外，它实际上是在每个步骤的递归过程中。我在过程内调用此值期望-N。也许有一种方法可以在没有这种添加的情况下使算法工作，但我找不到它。</p><p> One more thing. I have been calling the procedure’s inputs  lists, but in fact this second implementation will use not lists but vectors. That is because we will be doing a lot of accessing by index, which should be  O(1) for vectors but  O(n) for lists (at least I am assuming that is the case; the MIT/GNU Scheme reference manual doesn’t seem to say).</p><p> 还有一件事。我一直在调用过程的输入列表，但实际上，这第二个实施将不是未列出而不是向量。这是因为我们将通过索引进行大量访问，这应该是向量的o（1），而是用于列表的O（n）（至少我假设是这种情况;麻省理工学院/ GNU方案参考手册并未似乎说）。 </p><p> Before turning our eyes to the actual implementation we will need to write some utility procedures. Amazingly, as far as I can tell, there is no procedure in MIT/GNU Scheme for checking whether a vector is empty or not (though there is one,  null?, for lists). So let us begin with that one:</p><p>在将眼睛转向实际实现之前，我们需要编写一些实用程序。令人惊讶的是，据我所知，MIT / GNU方案中没有程序用于检查矢量是否为空（虽然有一个，但是列表）。所以让我们从那个开始：</p><p> ;; Returns :t if the vector is empty; otherwise returns :f.  ( define  ( vector-null? v )  ( =  0  ( vector-length v ) ) )</p><p> ;;返回：T如果向量是空的;否则返回：f。 （定义（矢量 -  null？v）（= 0（矢量 - 长度v）））</p><p> What’s more, though there is a procedure for getting the first (or the eighth!) element of a vector, there is no procedure for getting the last element of a vector. This is straightforward:</p><p> 更重要的是，虽然有一个用于获取矢量的第一个（或第八个）元素的过程，但没有用于获取矢量的最后一个元素的过程。这很简单：</p><p> ;; Returns the last element of the vector.  ( define  ( vector-last v )  ( vector-ref v  ( -  ( vector-length v )  1 ) ) )</p><p> ;;返回向量的最后一个元素。 （定义（矢量 - 上次v）（Vector-ref v（ - （矢量 - 长度v）1）））</p><p> Finally, we will implement a procedure for doing a pairwise concatenation of two pairs of vectors. That is, we concatenate the first elements of both pairs, then concatenate the second elements of both pairs and return a pair with the two concatenations.  cons here is a procedure for creating a new pair;  car gets the first element in a pair;  cdr gets the second element.  [1]</p><p> 最后，我们将实现一对方法两对向量的一对级联的过程。也就是说，我们连接两对的第一个元素，然后连接两对的第二个元素并与两个连接返回一对。以下是创建新对的过程;汽车在一对中获取第一个元素; CDR获取第二个元素。 [1]</p><p> ;; Returns the pairwise concatenations of two pairs of vectors.  ( define  ( ++ p1 p2 )  ( cons  ( vector-append  ( car p1 )  ( car p2 ) )   ( vector-append  ( cdr p1 )  ( cdr p2 ) ) ) )</p><p> ;;返回两对向量的成对连接。 （定义（++ P1 P2）（缺点（载体 - 附加（CAR P1）（CAR P2））（矢量 - 附加（CDR P1）（CDR P2）））））））</p><p>  1 ]=&gt;  ( vector-null? # ( ) )  ;Value: #t   1 ]=&gt;  ( vector-null? # ( 3  1  4 ) )  ;Value: #f   1 ]=&gt;  ( vector-last # ( 3  1  4 ) )  ;Value: 4   1 ]=&gt;  ( ++  ( cons # ( 1  2 ) # ( 3  4 ) )  ( cons # ( 5  6 ) # ( 7  8 ) ) )  ;Value: (#(1 2 5 6) . #(3 4 7 8))</p><p>  1] =＆gt; （矢量 -  null？＃（））;值：#t 1] =＆gt; （矢量 -  null？＃（3 1 4））;值：#f 1] =＆gt; （矢量 - 最后＃（3 1 4））;值：4 1] =＆gt; （++（cons＃（1 2）＃（3 4））（cons＃（5 6）＃（7 8））;值:(＃（1 2 5 6）。＃（3 4 7 8）） </p><p>  ;; Returns the median value of two sorted integer lists.  ( define  ( fast-median vector1 vector2 )   ( assert  ( &gt;  ( +  ( vector-length vector1 )  ( vector-length vector2 ) )   0 ) )   ;; This procedure takes two vectors `v1&#39; and `v2&#39; and an   ;; integer `desired-n&#39; and determines how the `desired-n&#39;   ;; number of smallest values are distributed between the two   ;; vectors. It returns a pair of vectors, the values in each   ;; vector respectively that make up the list of the   ;; `desired-n&#39; smallest values.   ;;   ;; Example:   ;;   ;; (lp #(1 3) #(4 5 6) 3) =&gt; (#(1 3) . #(4))   ( define  ( lp v1 v2 desired-n )   ( let*  ( ( split1  ( cond  ( ( vector-null? v1 )  0 )   ( ( vector-null? v2 ) desired-n )   ( else  ( integer-floor   ( +  ( vector-length v1 )  1 )  2 ) ) ) )   ( split2  ( - desired-n split1 ) )   ( head1  ( vector-head v1 split1 ) )   ( tail1  ( vector-tail v1 split1 ) )   ( head2  ( vector-head v2 split2 ) )   ( tail2  ( vector-tail v2 split2 ) ) )   ( cond  ( ( vector-null? head1 )  ( cons # ( ) head2 ) )   ( ( vector-null? head2 )  ( cons head1 # ( ) ) )   ( ( and  ( not  ( vector-null? tail2 ) )   ( &gt;  ( vector-last head1 )  ( vector-first tail2 ) ) )   ( ++  ( cons # ( ) head2 )   ( lp head1  tail2   ( - desired-n  ( vector-length head2 ) ) ) ) )   ( ( and  ( not  ( vector-null? tail1 ) )   ( &gt;  ( vector-last head2 )  ( vector-first tail1 ) ) )   ( ++  ( cons head1 # ( ) )   ( lp tail1  head2   ( - desired-n  ( vector-length head1 ) ) ) ) )   ( else  ( cons head1 head2 ) ) ) ) )   ( let*  ( ( median-idx  ( lambda  ( n )  ( if  ( = n  0 )   0   ( +  ( integer-floor n  2 )  1 ) ) ) )   ( combined-length  ( +  ( vector-length vector1 )   ( vector-length vector2 ) ) )   ( desired-n  ( median-idx combined-length ) )   ( nums-left-of-median  ( lp vector1 vector2 desired-n ) )   ( combined-length-is-even  ( =  ( modulo combined-length  2 )   0 ) )   ( last-two  ( lambda  ( v )  ( vector-tail  v  ( max  0  ( -  ( vector-length v )  2 ) ) ) ) )   ( highest-nums  ( vector-append   ( last-two  ( car nums-left-of-median ) )   ( last-two  ( cdr nums-left-of-median ) ) ) )   ( sorted  ( sort! highest-nums &lt; ) )   ( highest-two  ( last-two sorted ) )   ( median  ( if combined-length-is-even   ( /  ( +  ( vector-first highest-two )   ( vector-last highest-two ) )  2 )   ( vector-last highest-two ) ) ) )  median ) )</p><p>;;返回两个排序整数列表的中位值。 （定义（快速中值Vector1 Vector22）（断言（+（+（载体长度向量1）（载体长度向量2））0）;这个程序需要两个向量`v1＆＃39;和`v2＆＃39;和一个;;整数`期望-N＆＃39;并确定所需的-N＆＃39 ;;;;;向量。它返回一对向量，每个矢量，每个值; ;载体分别构成了组成的列表;;`期望-N＆＃39;最小的值。;;;;;;;;( lp＃（1 3）＃（4 5 6）3）=＆gt; （＃（1 3）。＃（4））（定义（LP v1 v2所需-n）（设*（split1（cond1（（vector-null？v1）0）（（向量 -  null？v2）期望 - n）（否则（整数（+（+（+（载体长度V1）1）2）））））（split2（ - 期望-n split1））（头部1（矢量 - 头部V1 split1））（尾部1（矢量尾V1 split1））（Head2（载体头V2分裂2））（尾部2（矢量 - 尾V2分裂2）））（COND（（载体 -  null？head1）（cons＃（）h EAD2）））（（矢量 -  null？ head2）（缺点head1＃（）））（（和（不是（vector-null？tail2））（＆gt;（矢量 - 第一个head1）（矢量 - 第一尾部2）））（++（cons＃（）head2） （LP Head1 Tail2（ - 期望-N（载体长度Head2）））））））（（和（Vector-Null？tail1））（＆gt;（矢量 - 上一个head2）（矢量 - 第一尾部1）））（ ++（缺点head1＃（））（lp tail1 head2（ - 期望 -  n（矢量长度头1））））））（else（cons head1 head2）））））（let *（（中位-idx（lambda（lambda）））（let *（ n）（如果（= n 0）0（+（整数N 2）1）））））（组合 - 长度（+（向量 - 长向量1）（向量 - 长向量2）））（所需-N（中位数） -IDX组合长度））（NUMS  - 中位数（LP vector1 Vector2所需-N））（组合长度 - 偶数（=（模数组合长度2）0））（Last-2（Lambda （v）（载体尾V（max 0（ - （矢量长度v）2））））））（最高字（矢量 - 附加（最后二（车Nums-Le） ft-of中位数））（最后二（CDR Nums-Lefian）））））（排序（排序！最高的数字＆lt; ））（最高两次（最后两种分类））（中位数（如果组合长度为-En-op（/（+（+（+（向量 - 第一最高）（矢量 - 载体 - 最后））2）（矢量 - 最后最高二）））））中位数）））</p><p>  1 ]=&gt;  ( fast-median # ( 1  3 ) # ( 2 ) )  ;Value: 2   1 ]=&gt;  ( fast-median # ( 1  2 ) # ( 3  4 ) )  ;Value: 5/2   1 ]=&gt;  ( fast-median # ( 1  4  7  8  9 ) # ( 2  3  4  5  6 ) )  ;Value: 9/2</p><p>  1] =＆gt; （快速中位数＃（1 3）＃（2））;值：2 1] =＆gt; （快速中位数＃（1 2）＃（3 4））;值：5/2 1] =＆gt; （快速中位数＃（1 4 7 8 9）＃（2 3 4 5 6））;价值：9/2</p><p> This procedure is a lot faster than the previous one. I haven’t figured out a nice way of benchmarking procedures in Scheme, but running them for large lists,  slow-median takes several seconds to compute, whereas  fast-median is instantaneous:</p><p> 此过程比前一个更快。我还没有弄清楚方案中的基准措施的好方法，但为大型清单运行它们，慢中位需要几秒钟来计算，而快速中位数是瞬间的：</p><p> 1 ]=&gt;  ( define l1  ( iota  1000000  1 ) )  ; iota creates a sequence  ;Value: l1   1 ]=&gt;  ( define l2  ( iota  1500000  10000 ) )  ;Value: l2   1 ]=&gt;  ( slow-median l1 l2 )  ; takes a couple of seconds  ;Value: 630000   1 ]=&gt;  ( define v1  ( list-&gt;vector l1 ) )  ;Value: v1   1 ]=&gt;  ( define v2  ( list-&gt;vector l2 ) )  ;Value: v2   1 ]=&gt;  ( fast-median v1 v2 )  ; instantaneous  ;Value: 630000</p><p> 1] =＆gt; （定义L1（IOTA 1000000 1））; iota创建一个序列;值：l1 1] =＆gt; （定义L2（IOTA 1500000 10000））;值：L2 1] =＆gt; （慢中位L1 L2）;需要几秒钟;值：630000 1] =＆gt; （定义V1（List-＆gt; Vector L1））;值：V1 1] =＆gt; （定义V2（列表 - ＆gt; Vector L2））;值：v2 1] =＆gt; （v1 v2快速中值）;瞬间;价值：630000</p><p> The procedure is made up of 37 lines in total, comments and utility procedures excluded.  [2] The  highlighted Java and Python solutions at LeetCode are made up of 34 and 24 lines of code respectively. These versions are probably nicer than the one I wrote. It all seems somewhat easier in imperative code, given that the algorithm is both looking at subsets of the two provided lists and constantly comparing to elements outside those subsets. This makes it easier to work with indices rather than actually splitting up the lists, as is more natural in functional programming. But I don’t leave out the possibility that there is a Scheme procedure out there far more beautiful and just as fast as the one that I have come up with.</p><p> 该过程总共由37行组成，评论和公用事业程序被排除在外。 [2] LeetCode的突出显示的Java和Python解决方案分别由34和24行代码组成。这些版本可能比我写的那样更好。鉴于该算法既看起来且经常比较这些子集外部的元素，否则似乎都似乎有点容易。这使得与索引更容易使用指数而不是实际分割列表，就像功能规划一样自然。但我并不遗漏有一个方案程序的可能性更加美丽，就像我想出的那样快。</p><p>  These confusing names are historical baggage.  car is short for  contents of the address part of register and  cdr  contents of the decrement part of register. I assume  cons is short for  construct or something like that. See Hanson &amp; Sussman,  Software Design for Flexibility, Appendix B.  ↩︎</p><p>  这些令人困惑的名字是历史行李。汽车的内容是寄存器的地址部分的内容和登记册减量部分的CDR内容。我假设构造或类似的东西是简短的。查看Hanson＆amp; Sussman，软件设计灵活性，附录B.↩︎</p><p> Actually, the code presented here is made up of more lines because I had to compress it horizontally in order to fit on the desktop version of the website.  ↩︎</p><p> 实际上，这里呈现的代码由更多的行组成，因为我必须水平压缩它，以适应网站的桌面版本。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.erichgrunewald.com/posts/using-scheme-to-find-the-median-of-two-sorted-integer-lists/">https://www.erichgrunewald.com/posts/using-scheme-to-find-the-median-of-two-sorted-integer-lists/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/方案/">#方案</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/find/">#find</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>