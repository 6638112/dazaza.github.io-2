<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>交付高质量软件的心智模型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">交付高质量软件的心智模型</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 02:42:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/ca21841d42e8781869636fa985a428f8.png"><img src="http://img2.diglog.com/img/2020/10/ca21841d42e8781869636fa985a428f8.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Below are a few statements / assumptions that would help me explain the idea and the goal of this post:</p><p>下面是一些陈述/假设，可以帮助我解释这篇文章的想法和目标：</p><p> It is important that the software is built and delivered in a reasonably short time</p><p>重要的是，软件的构建和交付要在合理的短时间内完成。</p><p>  There are lots of methods and ways of working to develop software, and there is no single way that is correct for all organisations</p><p>开发软件的方法和方式有很多种，没有一种方法对所有组织都是正确的。</p><p> The goal of this post is to share an approach or a combination of approaches I learned in my career to deliver software products faster and with higher quality. There is nothing I invented here. It is merely a summary of methods suggested and tested by companies, individuals through books and frameworks, and applied in a few companies I worked with.</p><p>这篇文章的目标是分享我在职业生涯中学到的一种方法或一种方法的组合，以更快、更高质量地交付软件产品。这里没有我发明的任何东西。它仅仅是公司和个人通过书籍和框架建议和测试的方法的总结，并在我工作过的几家公司中应用。</p><p> I do not suggest to  consider this as a delivery/quality strategy. A delivery/quality strategy needs to be tailored to each organisation based on observations and analysis of existing methods, processes and behaviours. However, I do like to think of it as a mental model that I refer to when building a software delivery and quality strategy.</p><p>我不建议将此视为交付/质量策略。需要根据对现有方法、流程和行为的观察和分析，为每个组织量身定做交付/质量策略。然而，我确实喜欢将其视为构建软件交付和质量策略时参考的心理模型。</p><p> One additional thing I try to highlight in this post is a common misconception about “Testing” vs “Quality”, and the resort towards End to end testing (which is not an incorrect thing) when things go wrong.</p><p>我在这篇文章中想要强调的另外一件事是关于“测试”与“质量”的常见误解，以及当事情出错时求助于端到端测试(这并不是一件错误的事情)。</p><p> Please reach out to me to further discuss and challenge this model. I would love to hear your feedback (A few ways to reach out can be found on my  personal website).</p><p>请联系我进一步讨论和挑战这一模式。我很想听听你的反馈(在我的个人网站上可以找到几种联系方式)。</p><p>  It is common to encounter lots of struggle with software delivery, and there are multiple reasons for that struggle, which would be different in each organisation. However, there is usually a common theme around quality problems.</p><p>在软件交付方面遇到很多困难是很常见的，而造成这种困难的原因是多方面的，这在每个组织中都是不同的。然而，围绕质量问题通常有一个共同的主题。</p><p> Quality is difficult to define. This requires lots of communication with the team and the stakeholders to understand what is acceptable and what is not. Before starting with any change, it would be ideal to talk to people and get their opinion on the current product quality and system behaviour — different individuals would have different opinions based on their roles and their definition of quality.</p><p>质量很难下定义。这需要与团队和风险承担者进行大量沟通，以了解哪些是可接受的，哪些是不可以接受的。在开始任何改变之前，理想的做法是与人们交谈，了解他们对当前产品质量和系统行为的看法-不同的人会根据他们的角色和他们对质量的定义有不同的看法。</p><p>  Do a “software delivery retrospective” that would enable people to identify the pain points in the current release process, in the coding practices, or the planning practices, etc. Start with identifying the problems</p><p>做一个“软件交付回顾”，使人们能够识别当前发布过程中的痛点，编码实践中的痛点，或者规划实践中的痛点，等等。从识别问题开始。</p><p>  Usually, quality struggles / problems are solved by addressing tests first. This is not incorrect. However, it is necessary to keep in mind that testing is a single component that helps improve quality. So the team needs to consider other components as well.</p><p>通常，质量斗争/问题通过首先解决测试来解决。这不是不正确的。但是，有必要记住，测试是帮助提高质量的单个组件。因此，团队还需要考虑其他组件。</p><p>  We want to deliver fast with quality, and we want to start somewhere. There isn’t enough time for discussions, retrospectives and planning. Everybody wants to get moving fast, and nothing is wrong with that. So the team usually proceeds with increasing the test coverage, starting with unit tests, and ending with E2E tests. That is a great thing to do, and I highly encourage it. But before getting into the details of this approach, I would like to talk a bit about End to End tests.</p><p>我们想要高质量的快速交货，我们想从某个地方开始。没有足够的时间进行讨论、回顾和规划。每个人都希望行动迅速，这没有什么错。因此，团队通常从增加测试覆盖率入手，从单元测试开始，到E2E测试结束。这是一件很棒的事情，我强烈鼓励这样做。但在详细介绍此方法之前，我想先谈谈端到端测试。</p><p> 90% of the people I know in the software development/testing domain say that E2E tests are not good. They’re lengthy, brittle, slow, fragile, flakey, and they cost a lot of money. My personal experience aligns with this description, and I think these tests are usually abandoned within a year or two, depending on the speed of the organisation in reassessing its quality processes (or overall development — and delivery — processes) and adapting new ways of working that could potentially make that pain go away, maybe with some trade-offs.</p><p>我在软件开发/测试领域认识的90%的人说E2E测试不好。它们又长又脆，速度慢，易碎，易碎，而且要花很多钱。我的个人经验与这种描述一致，我认为这些测试通常会在一两年内被放弃，这取决于组织重新评估其质量流程(或整体开发-和交付-流程)和调整新的工作方式的速度，这些新的工作方式可能会消除这种痛苦，可能需要进行一些权衡。</p><p> Possibly it could be understood from the previous paragraph that I am suggesting to avoid writing E2E tests since they’re abandoned anyways after a certain period of time. In fact, I am not. I am proposing to go back to the basics, take a pragmatic approach,  minimize the amount of E2E tests to lower the cost, and address the quality problem differently.</p><p>从上一段可能可以理解，我建议避免编写E2E测试，因为它们在一定时间后无论如何都会被放弃。事实上，我不是。我建议回归基础，采取务实的方法，最大限度地减少E2E测试的数量，以降低成本，并以不同的方式解决质量问题。</p><p>    E2E tests typically simulate real user scenarios. As focusing on the user is what every organisation aims for, this makes E2E tests a super good idea.</p><p>E2e测试通常模拟真实的用户场景。由于关注用户是每个组织的目标，这使得E2E测试成为一个超级好主意。</p><p>   E2E tests help exercise the application with all of its parts connected together, which would identify bugs that the component tests did not</p><p>E2e测试有助于在应用程序的所有部分连接在一起的情况下运行应用程序，这将识别组件测试没有发现的bug</p><p> In addition to that, we like to live a stress free life (or lower the stress levels in our lives). Adding E2E tests would provide confidence before releasing to production, which would give stakeholders some peace of mind.</p><p>除此之外，我们喜欢过一种没有压力的生活(或者降低我们生活中的压力水平)。增加E2E测试将在投产前提供信心，这将给利益相关者带来一些安心。</p><p>   I believe that putting the end user first, automating the regression suite, preventing bugs from slipping to production (as much as possible), and aiming to live a stress free life are all   rightful and great choices.</p><p>我相信，把最终用户放在第一位，自动化回归套件，(尽可能)防止bug滑向生产，并致力于过一种没有压力的生活，这些都是正确和伟大的选择。</p><p> Deciding to solve these issues through adding E2E tests is easy because the team could identify the user scenarios, then automate them through browser simulation. Usually, the team is under lots of pressure to fix/improve the system quality, and picking up E2E would look like the fastest way to go. But as with any decisions, other factors need to be taken into consideration.</p><p>决定通过添加E2E测试来解决这些问题很容易，因为团队可以识别用户场景，然后通过浏览器模拟将其自动化。通常，团队在修复/改进系统质量方面压力很大，采用E2E看起来是最快的方式。但与任何决定一样，还需要考虑其他因素。</p><p> Simply the E2E tests are brittle, expensive to write, time consuming to run and difficult to maintain. They’re fragile, and small changes to the application would break these tests.</p><p>简单地说，E2E测试很脆弱，编写成本很高，运行起来很耗时，而且很难维护。它们很脆弱，对应用程序的微小更改都会破坏这些测试。</p><p> Using this approach to address quality problems would become quickly a problem itself, forming an ice-cream cone:</p><p>使用这种方法来解决质量问题本身很快就会成为一个问题，形成一个冰激凌蛋筒：</p><p>    In this approach, the E2E tests are a second line of defense, and they cover dependencies that might have been overlooked. So they’re good to have, but they do not solve the primary problem. Having E2E in place does not mean the quality problem is solved.</p><p>在这种方法中，E2E测试是第二道防线，它们涵盖了可能被忽略的依赖项。所以拥有它们是好的，但它们不能解决主要问题。E2E到位并不意味着质量问题得到解决。</p><p> Even with a reasonable amount of unit tests (and possibly some integration tests), a long running suite of E2E tests, and a very big sheet of manual tests, regression bugs might still be encountered in production — More on this in the following section (under Code → Automation → E2E). What can we do?</p><p>即使有相当数量的单元测试(可能还有一些集成测试)、长时间运行的E2E测试套件和非常多的手动测试，在生产中仍然可能会遇到回归错误-下一节(在代码→自动化→E2E下)将详细介绍这一点。我们能做什么？</p><p> These questions could be a hint that it is the time to look at the overall approach regarding delivering a high quality software.</p><p>这些问题可能暗示现在是时候考虑有关交付高质量软件的总体方法了。</p><p>  Notice here that I mentioned quality and not testing, as these are 2 different things. Testing is just one of the activities that would lead to a better quality (it could be argued whether it is the main activity or not — we will not get into that debate).</p><p>请注意，这里我提到了质量和不是测试，因为这是两件不同的事情。测试只是会带来更好质量的活动之一(可以争论它是否是主要活动-我们不会讨论这一问题)。</p><p> In this section we will answer some of the previous questions indirectly (putting end user first, stop bugs from going to productions, etc.).</p><p>在本节中，我们将间接回答前面的一些问题(将最终用户放在第一位，阻止bug进入生产，等等)。</p><p> Testing should not happen before a release. We should be constantly testing before, during and after the release. I like the following visualisation from Dan Ashby about  continuous testing:</p><p>测试不应该在发布之前进行。我们应该在发布之前、发布期间和发布之后不断地进行测试。我喜欢丹·阿什比(Dan Ashby)关于持续测试的以下可视化描述：</p><p>  But how to do that practically, there are lots of work that need to happen, and all teams are limited on time and resources. This is not easy and requires discipline and adaptability:</p><p>但如何切实做到这一点，有很多工作需要完成，而且所有团队的时间和资源都是有限的。这并不容易，需要纪律和适应能力：</p><p>  Question / Challenge all feature requests (Why do we need it? Is that the correct thing to implement?)</p><p>询问/质询所有功能请求(我们为什么需要它？这是要实施的正确做法吗？)。</p><p>  Discuss the testing of the user story (Does it require testing on the UI level, would integration testing or unit testing be sufficient?)</p><p>讨论用户情景的测试(是否需要UI级别的测试，集成测试或单元测试是否足够？)。</p><p> Most of the time, the product already exists, we cannot just abandon the existing manual tests (especially if there isn’t enough coverage at another level). As the team discusses the impact on other areas early on, this would give a hint whether any further manual regression testing is needed. This is mainly a risk assessment.</p><p>大多数情况下，产品已经存在，我们不能放弃现有的手动测试(特别是如果在另一个级别没有足够的覆盖率)。当团队在早期讨论对其他领域的影响时，这将给出是否需要任何进一步的手动回归测试的提示。这主要是风险评估。</p><p>  Discuss if the branching method is helping with the development of the granular user stories and releasing them</p><p>讨论分支方法是否有助于细粒度用户情景的开发和发布</p><p> It might seem that branching is something we set up once and forget about it, but in fact, it is good to assess it every now and again. As the development process evolve, it might be needed to adjust the branching strategy accordingly. For example, it does not make lots of sense to have a release branch if we are releasing continuously, or having 2 main branches, etc.</p><p>分支似乎是我们曾经建立并忘记的东西，但实际上，时不时地对其进行评估是有好处的。随着开发过程的发展，可能需要相应地调整分支策略。例如，如果我们连续发布，或者有两个主分支，那么拥有一个发布分支就没有多大意义。</p><p>  Pairing between the tester and the developer before starting with the development could be very useful (Test First approach — should not take more than 15 minutes per user story)</p><p>在开始开发之前，测试人员和开发人员之间的配对可能非常有用(测试优先方法-每个用户故事花费的时间不应超过15分钟)。</p><p> Write down the variations in a one liner on the Jira ticket (or as a test if possible)</p><p>在吉拉机票上写下一个班轮的变化(如果可能的话，也可以作为测试)。</p><p>  Discuss how to deploy the user story (can the backend go first? can it be tested separately? can it be released to production without affecting anything else in the system?)</p><p>讨论如何部署用户情景(可以先部署后端吗？可以单独测试吗？是否可以在不影响系统中任何其他内容的情况下将其发布到生产中？)。</p><p> Re-visit what needs to be automated and at which level — good to have a high level agreement on who is implementing what</p><p>重新访问需要自动化的内容和级别-就谁在实施哪些内容达成高级别协议是有益的。</p><p> Decide whether the item being developed requires to be tested by someone else on local before having it merged to the main branch</p><p>确定正在开发的项目在合并到主分支之前是否需要由其他人在本地进行测试。</p><p> Code review is very important — giving enough time for the review helps identify issues at a very early stage of the process — if the review is not being paired on then it could be benficial to run the latest code on local and give it some exploratory testing as well</p><p>代码审查非常重要--为审查留出足够的时间有助于在过程的早期阶段识别问题--如果审查没有配对，那么在本地运行最新的代码并对其进行一些探索性测试可能是有益的。</p><p> Needless to say, create unit tests, and exercise their failure by changing the input and/or the actual code temporarily</p><p>不用说，创建单元测试，并通过临时更改输入和/或实际代码来测试它们的失败</p><p> Test locally, whether by the tester or another engineer. This is much better than testing in the test environment (this will show failures early on in the process, where the solution written is still fresh) — It is likely that another engineer or tester might not be needed based on the pairing done early on</p><p>本地测试，无论是由测试人员还是由其他工程师进行测试。这比在测试环境中进行测试要好得多(这将在流程早期显示失败，在那里编写的解决方案仍然新鲜)-基于早期完成的配对，很可能不需要另一个工程师或测试人员。</p><p> Manually test what is implemented locally (exploratory visual testing) — yes, open that app and make sure it’s behaving as expected</p><p>手动测试本地实施的内容(探索性视觉测试)-是的，打开该应用程序并确保其行为符合预期。</p><p> Cover the main business cases (e.g. if the user story suggests implementing a field that allows setting up a value, then the E2E for it would be to set up a correct value, save then verify the value got saved — we do not test a wrong value at this level, or if a button got enabled or disabled)</p><p>涵盖主要业务案例(例如，如果用户情景建议实现允许设置值的字段，则E2E将设置正确的值，保存然后验证保存的值-我们不会在此级别测试错误的值，或者按钮是否启用或禁用)。</p><p> What about other cases that are not covered (e.g. a button should be disabled)? These variations should be covered at a different level if possible. If that was not possible, then it should be sufficient to be covered through manual exploratory testing during development — What if it got broken in production later on? if it’s a primary scenario it would be covered by tests and wouldn’t go to production. If it’s a secondary scenario then it’s alright to get broken in production, as long as we have the means to fix it quickly and get it to work (Release method is important here) — but maybe that’s not an option for the business. In this case, it is good to look at visual testing methods such as snapshot testing that get executed maybe on a daily basis, where a comparison between current and previous UI happens. Note that having a bug free software is not possible even with lots of tests in place.</p><p>其他未覆盖的情况怎么办(例如，应禁用按钮)？如果可能，这些变体应该在不同的级别上涵盖。如果这是不可能的，那么在开发期间通过手动探索性测试来覆盖它就足够了-如果它后来在生产中被破坏了怎么办？如果这是一个主要场景，那么它将在测试中涵盖，不会投入生产。如果这是第二种情况，那么在生产中出现故障也没问题，只要我们有办法快速修复它并使其正常工作(发布方法在这里很重要)-但这可能不是业务的选择。在这种情况下，最好看看可能每天执行的可视测试方法，比如快照测试，其中会比较当前和以前的UI。请注意，即使有大量的测试，也不可能有无bug的软件。</p><p> The verification should be done in the fastest way possible. For example, we should not open another page to verify that the setting got saved correctly if we can verify faster that network request got submitted with the correct value (the other page should be exercises in its own test where we verify the values saved are retrieved correctly)</p><p>应该以尽可能快的方式进行验证。例如，如果我们可以更快地验证网络请求是用正确的值提交的，我们就不应该打开另一个页面来验证设置是否被正确保存(另一个页面应该在它自己的测试中进行练习，在该测试中我们验证保存的值是否被正确检索)。</p><p> Setting up the data and accessing the feature being tested should happen in the fastest possible way. For example, if we need to click multiple button to get to the field we’re trying to update, it would be better to directly navigate to that page and set up the field if that’s faster (clicking the buttons to get to the field should be exercised in a different scenario) — In case we needed to create user to be able to get a field visible to test, the better create the user in the fastest possible way, whether through API, insertion in the DB, or even mocking that record if that’s possible</p><p>设置数据和访问正在测试的功能应该以尽可能快的方式进行。例如，如果我们需要单击多个按钮才能到达我们试图更新的字段，如果这样更快的话，最好直接导航到该页面并设置字段(单击按钮到达字段应该在不同的场景中执行)-如果我们需要创建用户以使字段可见以进行测试，则越好地以尽可能快的方式创建用户，无论是通过API、插入到数据库中，还是在可能的情况下模拟该记录。</p><p>    Could include  contract tests, which would help make other integration and E2E tests easier and more performant</p><p>可以包括合同测试，这将有助于使其他集成和E2E测试更容易、更有效。</p><p>  Unit testing helps find problems early in the development cycle, which could be bugs or flaws in the specifications</p><p>单元测试有助于在开发周期的早期发现问题，这些问题可能是规范中的错误或缺陷</p><p> Unit tests provide confidence when refactoring a piece of code, upgrading a library or extending a feature (e.g. in regression testing), and allow the developer to make sure the module is still working correctly</p><p>单元测试在重构代码片段、升级库或扩展功能时(例如在回归测试中)提供了信心，并允许开发人员确保模块仍然正常工作。</p><p> Unit tests make the integrations tests become much easier, as we’re testing parts of the program then testing the sum of these parts</p><p>单元测试使集成测试变得容易得多，因为我们正在测试程序的各个部分，然后测试这些部分的总和。</p><p> Unit tests allow coverage of inputs, outputs and error conditions, which would help in covering more edge case</p><p>单元测试允许覆盖输入、输出和错误条件，这将有助于覆盖更多边缘情况。</p><p>  Good to keep an eye on the merges in case multiple people where working around the same area, test areas of conflict</p><p>密切关注合并，以防多人在同一区域、冲突测试区附近工作。</p><p> The build is similar to the branch, is something good to keep assessing and finding ways to enhance it. Is the build slow? is there steps in the build that we can get rid of?</p><p>构建类似于分支，是值得不断评估和寻找增强它的方法的好东西。建造速度慢吗？在构建过程中有没有我们可以去掉的步骤？</p><p>  It is very important to separate these 2 components. This is something to be discussed on a user story basis, where the team defines whether a feature flag is needed or not</p><p>将这两个组件分开是非常重要的。这是在用户故事的基础上讨论的内容，团队定义是否需要功能标志。</p><p> The release &amp; deployment is the cornerstone of this proposed model. It is proposed to use a continuous deployment strategy for the following reasons:</p><p>发布和部署是这一提议模型的基石。出于以下原因，建议使用持续部署战略：</p><p> Minimize the risk. As we add more code (features/fixes) to a single release, the risk will increase.</p><p>把风险降到最低。随着我们向单个版本添加更多代码(功能/修复)，风险将会增加。</p><p> Faster time to production, which means a faster feedback loop, whether from customer if it was released, or from “Testing in production” if it was a hidden feature</p><p>更快的生产时间，这意味着更快的反馈循环，无论是来自客户的反馈(如果是发布的)，还是来自“在生产中测试”的反馈(如果它是一个隐藏的功能。</p><p> This would give a faster delivery cycle with better quality in general. Some concerns would be that bugs are still being introduced to production, even with an extensive manual testing regression executed before a release, so how would this be avoided with multiple deployments?</p><p>这通常会带来更快的交货周期和更好的质量。有些人会担心，即使在发布之前执行了大量的手动测试回归，错误仍然会被引入到生产中，那么如何在多个部署中避免这种情况呢？</p><p> Mainly this should all be covered through the planing to the development, where the team assessed the area of impact. If a large piece of code is going to be deployed/released, this is a hint that it needs to be further groomed and split into multiple deployable stories (it is always worth it to invest this time early on in the process)</p><p>主要是这些都应该通过开发的规划来覆盖，团队在那里评估影响的区域。如果要部署/发布一大段代码，这是一个提示，它需要进一步整理并拆分成多个可部署的故事(在流程的早期投资总是值得的)。</p><p> Even if there is an impact, it’s easier to regress an area impacted by a single change than by multiple changes</p><p>即使有影响，受单个更改影响的区域也比受多个更改影响的区域更容易后退。</p><p> Alongside this comes the culture of reaction to failure. Problems will arise, and the ability to solve these items quickly is key to success. So there should be a good monitoring and “testing in production” practice to respond fast</p><p>随之而来的是对失败的反应文化。问题会出现，能否迅速解决这些问题是成功的关键。因此，应该有一个良好的监控和“生产测试”实践，以便快速响应。</p><p> I know it seems a bit counter-intuitive that releasing more frequently reduces risk. However, what happens in reality is that this will show weak points in the process and the system, and helps strengthen them.</p><p>我知道，更频繁的释放会降低风险，这似乎有点违反直觉。然而，现实中发生的情况是，这将显示出过程和制度中的薄弱环节，并有助于加强它们。</p><p> To summarize, adopting this process that’s chosen by some of the most successful companies in the world would help with:</p><p>总而言之，采用世界上一些最成功的公司选择的这一过程将有助于：</p><p> Reducing the deployment risk — doing smaller changes means there’s less probability something will go wrong, and it’s easier to fix should a problem appear</p><p>降低部署风险-进行较小的更改意味着出现问题的可能性较小，并且更容易在出现问题时进行修复</p><p> Faster feedback loop — the end user will be able to reflect faster on the feature if it was visible. Alternatively, testing in production with some juicy data would be of great benefit</p><p>更快的反馈循环-如果该功能可见，最终用户将能够更快地对其进行反映。或者，使用一些有用的数据在生产中进行测试将会有很大的好处。</p><p> The following graph visualizes how we’re splitting the risk, increasing our speed, and making our response to problem faster:</p><p>下图直观地显示了我们如何分散风险、提高速度以及更快地响应问题：</p><p>   Feedback in production is one of the most powerful tools that would allow us to respond quickly to incidents</p><p>生产中的反馈是使我们能够快速响应事件的最强大的工具之一。</p><p>  Effective monitoring can help discover issues quickly (for example if the performance degraded after a release, we can respond quickly)</p><p>有效的监控有助于快速发现问题(例如，如果发布后性能下降，我们可以快速响应)。</p><p> Monitoring info can help prioritise exploratory tests for future releases where the focus can be directed to highly used components</p><p>监视信息有助于确定未来版本的探索性测试的优先顺序，在这些版本中，可以将重点放在高使用率的组件上。</p><p>  The log files would provide low-level details to diagnose root cause of an issue on prod</p><p>日志文件将提供低级详细信息，以诊断生产问题的根本原因。</p><p> Exploratory testing in production is nice and helps the developer experience how the user is seeing the feature</p><p>产品中的探索性测试很不错，可以帮助开发人员体验用户对该功能的看法。</p><p> Automated E2E smoke testing in production is also a great idea, as a third line of defense</p><p>生产中的自动化E2E烟雾测试也是一个很好的想法，作为第三道防线</p><p>  This process needs to be flexible and adjustable to meet both business and teams needs. Quality is a very wide and subjective term. It is important to understand what it means to our product stakeholders. However, delivering quality software products usually can be done through a combination of culture, architecture, tests, and process.</p><p>此流程需要灵活和可调整，以满足业务和团队需求。质量是一个非常宽泛和主观的术语。了解这对我们的产品利益相关者意味着什么，这一点很重要。然而，交付高质量的软件产品通常可以通过文化、体系结构、测试和过程的组合来完成。</p><p>    Going with a distributed architecture, and using microservices will enable frequent updates on each service independently (arguably)</p><p>采用分布式体系结构，并使用微服务将独立(可以说)实现对每个服务的频繁更新。</p><p>  Automated tests with high quality are necessary in this approach in order to be confident when releasing.</p><p>在这种方法中，高质量的自动化测试是必要的，以便在发布时充满信心。</p><p>   Have we catered for the items we discussed earlier — putting the end user first, automating the regression suite, preventing bugs from slipping to production (as much as possible), and aiming to live a stress free life?</p><p>我们是否满足了前面讨论的事项-将最终用户放在首位、使回归套件自动化、(尽可能)防止bug滑向生产，并以无压力的生活为目标？</p><p> We put the end user first, we are giving the end user a very fast access to newly implemented items, with a low risk of getting things broken (we are also taking the user opinion in consideration as well through the fast feedback)</p><p>我们把最终用户放在第一位，我们让最终用户能够非常快速地访问新实施的项目，而且损坏的风险很低(我们还通过快速反馈考虑了用户的意见)。</p><p> We have automated the manual regression suite — this might take a long long long time, which we might not have, and that would cause other problems. We came with an approach to automate the testing of what is impacted and what is important. We also suggested fast feedback, fast fix loop. Isn’t that better?</p><p>我们已经自动化了手动回归套件-这可能需要很长时间，我们可能没有，这会导致其他问题。我们提供了一种自动测试受影响内容和重要内容的方法。我们还建议快速反馈，快速修复循环。这样不是更好吗？</p><p> Preventing bugs from slipping to production (as much as possible) — we are suggesting a proactive approach to aggressively refine, plan, create tests and small chucks of code, and pair early on in the process to prevent issues from slipping to production</p><p>防止bug滑向生产(尽可能多)-我们建议采用一种积极主动的方法来积极地细化、计划、创建测试和小代码块，并在流程的早期进行配对，以防止问题滑向生产。</p><p> Aiming to live a stress free life — I don’t think this exists, but we managed our stress over time through deploying low risk items that are well tested individually</p><p>目标是过一种没有压力的生活-我不认为这是存在的，但随着时间的推移，我们通过部署经过单独测试的低风险项目来管理我们的压力</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ali-haydar.medium.com/lessons-learned-about-software-quality-or-delivery-3a05ca2e4609">https://ali-haydar.medium.com/lessons-learned-about-software-quality-or-delivery-3a05ca2e4609</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/高质量/">#高质量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/model/">#model</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031299.html"><img src="http://img2.diglog.com/img/2020/10/thumb_8cd663f339ad543bf74f1f21c235b12a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031299.html">勒索软件袭击了佐治亚州的一个县。这并没有阻止它的计票工作。</a></div><span class="my_story_list_date">2020-10-27 2:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031262.html"><img src="http://img2.diglog.com/img/2020/10/thumb_53f7e04e3aedb911704c908651d3137c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031262.html">
新冠肺炎下调软件巨头营收和利润预期后，思爱普股价大幅下跌</a></div><span class="my_story_list_date">2020-10-27 0:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031247.html"><img src="http://img2.diglog.com/img/2020/10/thumb_732353dcfb2cd5b4428ddd40e334510a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031247.html">
水质和分配监测软件Ketos筹集1800万美元</a></div><span class="my_story_list_date">2020-10-26 22:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031242.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fbcaf123169b8dafcabb71982fd03a98.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031242.html">总部位于伦敦的PrimaryBid开发连接散户投资者和上市公司的软件，筹集4230万欧元的B系列资金</a></div><span class="my_story_list_date">2020-10-26 22:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>