<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>线性哈斯克尔中纯粹的目的地传递风格</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">线性哈斯克尔中纯粹的目的地传递风格</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:07:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/022ae1f163e3837faf7572f4d1b4761b.png"><img src="http://img2.diglog.com/img/2020/11/022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>My goal today is to convince you that destination-passing style isneat, actually. And that  linear types makedestination-passing purely functional. But first, I must answer aquestion.</p><p>我今天的目标是让你们相信，事实上，传递目的地的风格是整洁的。而这种线性类型使目的地传递变得纯粹起作用。但首先，我必须回答一个问题。</p><p>  If you’ve ever programmed in C, C++, or Fortran, you are sure to haveencountered the style of programming which sometimes goes by the name destination-passing style. It is the practice of writing,  e.g. anarray-producing functions as, instead, taking an empty array as anextra argument and filling it. Consider, for example, the C  strcpy function:</p><p>如果你曾经用C、C++或Fortran编程，你肯定会遇到这种编程风格，这种风格有时被称为目标传递风格。这是一种编写实践，例如，将数组生成函数作为额外参数接受空数组并填充它。例如，考虑C strcpy函数：</p><p>  It copies the string in  source to the array  destination (it alsoreturns  destination when it’s done).</p><p>它将源中的字符串复制到数组目标(完成后还返回目标)。</p><p> The name “destination-passing style” itself seems to be more common inthe functional programming language compilation literature, however. Cprogrammers don’t appear to have a name for it. So it is likely thatyou have never encountered it.</p><p>然而，在函数式编程语言编译文献中，“目的地传递风格”这个名称似乎更常见。C程序员似乎没有给它起个名字。所以很可能你从未遇到过它。</p><p>  Why, indeed, care about destination-passing? It does let you ask a newquestion: “whose responsibility is it to allocate the array?“. If Iwere to write an array copy in Haskell, it would have type</p><p>事实上，为什么要关心目的地传递呢？它确实让您提出了一个新问题：“分配数组是谁的责任？”如果我要用Haskell编写数组副本，它的类型为。</p><p>  And there is no way around  copyArray allocating an array itself. Thequestion doesn’t even exist. With  strcpy, I can either choose toallocate an array, and pass it immediately to  strcpy, or, I candelegate the allocation of the array to someone else.</p><p>而且也没有办法避免CopyArray本身分配一个数组。这个问题根本不存在。使用strcpy，我可以选择分配一个数组，然后立即将其传递给strcpy，或者将数组的分配分配给其他人。</p><p> But, once I can ask this question, what can I do with it? I cancompose it! Let’s imagine that we have a function to split an array intwo</p><p>但是，一旦我可以问这个问题，我能用它做什么呢？我可以作曲！假设我们有一个将数组一分为二的函数。</p><p>   copyArray2  ::  Array  a  -&gt;  Array  a copyArray2  a  =  case  splitArray  a  of  ( al ,  ar )  -&gt;  copyArray  al  &lt;&gt;  copyArray  ar</p><p>CopyArray2：：Array a-&gt；Array a CopyArray2 a=case SplitArray a of(al，Ar)-&gt；Copy Array al&lt；&gt；Copy Array ar</p><p> When the question doesn’t exist, each call to  copyArray has, no matter what,to allocate an array, which is then copied into a new array. It meansthat we are making a superfluous copy of our original array,only to discard it immediately. This is quite wasteful.</p><p>当问题不存在时，无论发生什么情况，每次对CopyArray的调用都必须分配一个数组，然后将该数组复制到一个新的数组中。这意味着我们正在制作原始数组的多余副本，但却立即将其丢弃。这是相当浪费的。</p><p>  Often, you can, indeed, rely on array fusion to avoid too egregious abehaviour. Array fusion, such as implemented in the excellent  vectorlibrary will eliminate a ton of intermediate allocations.</p><p>通常情况下，你确实可以依靠数组融合来避免过于恶劣的行为。数组融合，例如在优秀的向量库中实现，将消除大量的中间分配。</p><p> However, fusion is unreliable. Sometimes, a simple refactoring willpush a function’s size beyond what GHC is willing to inline, and itwill break an entire fusion pipeline. Most of the time, this is fine,but not when you are dependent on fusion happening. And if you needGHC to produce code without allocations, why not write your program directly as you wantit, rather than try and coax the compiler into hopefully eliminatingthe allocations for you.</p><p>然而，聚变是不可靠的。有时，简单的重构会使函数的大小超出GHC愿意内联的范围，并且会破坏整个融合管道。大多数情况下，这是可以的，但当您依赖于融合发生时，情况就不同了。如果您需要GHC在没有分配的情况下生成代码，为什么不直接编写您想要的程序，而不是尝试诱使编译器为您消除分配。</p><p> This has been a guiding principle in the development of the lineartypes project:  compiler optimisations are great, as you don’t needto think about a lot of things; until you do, and you find yourselfsecond-guessing the optimiser. When that happens, we want lineartypes to empower you to write the code that you mean, withoutsacrificing Haskell’s type safety.</p><p>这一直是线性类型项目开发中的指导原则：编译器优化是很棒的，因为您不需要考虑很多事情；直到您这样做了，您才发现自己在事后猜测优化器。当这种情况发生时，我们希望线性类型使您能够编写您想要的代码，而不牺牲Haskell的类型安全性。</p><p> Besides, in the  article about F̃, a restricted array-basedfunctional language which compiles to very efficient code, the authorsfind significant performance gains for using destination-passing ontop of an array fusion optimisation. They only use destination-passingin the optimiser, though, not as a language feature.</p><p>此外，在一篇关于F̃的文章中，作者发现，在数组融合优化的基础上使用目标传递可以显著提高性能。F Language是一种受限的基于数组的函数式语言，可以编译成非常高效的代码。不过，他们只在优化器中使用目的地传递，而不是将其作为一种语言功能。</p><p> Finally, fusion doesn’t always work. Suppose I rewrite my  copyArray2function to use threads to better utilise my multicore architecture</p><p>最后，核聚变并不总是有效的。假设我重写了CopyArray2函数，以使用线程来更好地利用我的多核体系结构。</p><p> copyArray3  ::  Array  a  -&gt;  IO  ( Array  a ) copyArray3  =  case  splitArray  a  of  ( al ,  ar )  -&gt;  do  ( bl ,  br )  &lt;-  concurrently  ( evaluate  $  copyArray  al )  ( evaluate  $  copyArray  ar )  return  $  bl  &lt;&gt;  br</p><p>CopyArray3：：Array a-&gt；IO(数组a)CopArray3=case plitArray a of(al，ar)-&gt；do(bl，br)&lt；-并发(求值$CopyArray al)(求值$CopyArray ar)返回$bl；lt；&gt；br。</p><p> This is beyond a fusion framework ability to optimise. Or maybe I wantto copy my array into a memory mapped buffer. The point is: fusionwill do a lot for you, just not everything.</p><p>这超出了融合框架的优化能力。或者，我可能想要将数组复制到内存映射缓冲区中。关键是：融合会给你带来很多好处，但不是一切。</p><p>  The obvious way to encode destination-passing style, in Haskell, is tomove all our computation to  ST, so that  copyArray would be</p><p>在Haskell中，对目的地传递方式进行编码的最明显的方法是将我们所有的计算都移到ST，这样CopyArray将是。</p><p>  But it’s not very congruent with how functional programmers writetheir programs. It does lift all of the above limitations, at theprice of adding state everywhere, which is an entire error-inducingsurface that functional programming usually avoids.</p><p>但这与函数式程序员编写程序的方式不太一致。它确实取消了所有上述限制，代价是到处添加状态，这是函数式编程通常避免的整个错误诱导面。</p><p> It’s a huge price to pay, and that’s why the  vector library is notstructured like this. It does feature mutable arrays, but immutablearrays are very much encouraged.</p><p>这是一个巨大的代价，这就是为什么矢量库不是这样的结构。它确实具有可变数组，但非常推荐使用不可变的耳光。</p><p> This is where  linear types help. Indeed, let’s take astep back and ask: what makes a destination impure to begin with?</p><p>这就是线性类型有用的地方。的确，让我们退一步问一问：是什么让目的地从一开始就不纯洁？</p><p> If I read out a cell, then write to it, then read it again: I’ll see adifferent result the second time.</p><p>如果我读出一个单元格，然后写到它，然后再读一遍：第二次我会看到不同的结果。</p><p> If I write to the same cell twice, the writes need to be ordered,otherwise the result would be non-deterministic.</p><p>如果我向同一单元写入两次，则需要对写入进行排序，否则结果将是不确定的。</p><p> Reading a cell which has not been initialised is non-deterministic(though in most case, we can salvage this by initialising every cellwith  undefined)</p><p>读取尚未初始化的单元格是不确定的(尽管在大多数情况下，我们可以通过将每个单元格初始化为UNDEFINED来挽救这种情况)。</p><p> All of these behaviours are prohibited in pure code. But we couldavoid all the prohibited behaviours if we could make sure that eachcell is written to exactly once before being read. Aha! Exactly once,this is the sort of thing that linear types are good at! Ok, so let’stry again:</p><p>所有这些行为在纯代码中都是被禁止的。但是，如果我们能确保每个细胞在被读取之前只被写入一次，我们就可以避免所有被禁止的行为。啊哈！只有一次，这是线性类型擅长的事情！好的，那么让我们再来一次：</p><p>  This means that  copyArray is a  pure function which uses its destination(in its entirety) exactly once. We only need to make sure that thereis only ever a unique pointer to a destination array, which we do withthe  alloc function:</p><p>这意味着CopyArray是一个纯函数，它只使用其目的地(全部)一次。我们只需要确保只有一个指向目标数组的唯一指针，这是我们使用Alloc函数实现的：</p><p>  A destination is allocated for the scope of the linear function. Atthe end of the function, we know that the destination has been fullyfilled, and so we get an array out. From this destination-passingversion of  copyArray, by the way, it is easy to retrieve thedirect style variant:</p><p>为线性函数的作用域分配目的地。在函数结束时，我们知道目的地已被填满，因此我们得到一个数组。顺便说一句，从这个目的地传递版本的CopyArray中，很容易检索到直接样式变体：</p><p> copyArray&#39;  ::  Array  a  -&gt;  Array  a copyArray&#39;  a  =  alloc  ( length  a )  ( \ d  -&gt;  copyArray  a  d )</p><p>复制数组：：数组a-&gt;数组a复制数组a=分配(长度a)(\d-&gt;；复制数组a d)。</p><p> The reverse, as I’ve been arguing throughout this post, is very muchnot true. So the destination-passing function is the more fundamentalone.</p><p>相反的，正如我在这篇文章中一直在争论的那样，很大程度上是不正确的。所以目的地传递函数是更基本的。</p><p>   Then, it is just a matter of following the types (the curious-looking  &amp; \case construction is due to a limitation of the currentimplementation of linear types in GHC, see  here)</p><p>然后，这只是一个遵循类型的问题(奇怪的&amp；\case结构是由于GHC中线性类型的当前实现的限制，请看这里)。</p><p> copyArray2  ::  Array  a  -&gt;  DArray  a ⊸  ( ) copyArray2  a  d  =  case  splitArray  a  of  ( al ,  ar )  -&gt;  splitDArray  d  &amp;  \ case  ( dl ,  dr )  -&gt;  copyArray  al  dl  `lseq`  copyArray  ar  dr</p><p>CopyArray2：：Array a-&gt；dArray a⊸()CopyArray2 a d=case拆分数组a，共(al，ar)-&gt；拆分数组d；\case(dl，dr)-&gt；Copy阵列dl`lseq‘Copy阵列ar DR。</p><p> Voilà! No superfluous allocation. Not because of the optimiser, butbecause of the semantics of my program: it doesn’t allocate an arrayanywhere.</p><p>哇！没有多余的分配。这不是因为优化器，而是因为我的程序的语义：它不会在任何地方分配数组。</p><p> You’ll find a more complete destination array interface in  the Data.Array.Destination module of linear-base.</p><p>您可以在LINEAR-BASE的Data.Array.Destination模块中找到更完整的目标数组接口。</p><p>  One of the features of linear types, is that they often allow toexpose as pure interfaces objects which appear to be intrinsicallyimpure. But I want to argue that, in the case of destinations, we’veactually done more than this: we’ve made the interface  better thanthe impure interface. Not because pure interfaces are better thanimpure interfaces (though it’s a defensible position), but because thelinear destination interface is a more faithful representation of whatdestinations mean.</p><p>线性类型的一个特点是，它们通常允许将本质上看起来不纯净的对象公开为纯接口。但我想说的是，在目的地的情况下，我们实际上做了更多的事情：我们改进了界面，而不是不纯的界面。这并不是因为纯接口比纯接口更好(尽管这是一个合理的立场)，而是因为线性目标接口更忠实地表示了目标的含义。</p><p> There is no longer confusion about what is an input and what is anoutput: inputs are  Array, and outputs are  DArray. Destinations arethere solely for output, they can’t be used as a temporary store ofdata. And the types ensure that they are fully filled, and that wedon’t accidentally overwrite an output, by the time the destination isread back as an array.</p><p>不再混淆什么是输入，什么是输出：输入是数组，输出是DArray。目的地只用于输出，不能用作数据的临时存储。这些类型确保它们已完全填满，并且在目标作为数组读回时，我们不会意外覆盖输出。</p><p>  If you want to go a bit deeper into this particular brand of weed, letme leave you with a handful of comments which you can take either asclosing this blog post, or opening new avenues.</p><p>如果你想更深入地了解这一特定品牌的大麻，让我给你留下几条评论，你可以把它们作为关闭这篇博客的帖子，或者打开新的途径。</p><p> The  alloc function takes a destination-consuming function as anargument, instead of returning a destination directly. This style iscommon in Linear Haskell, as a means to enforce uniqueness. It issometimes seen as a limitation of Linear Haskell’s design. Howeverin this particular case, the function is necessary to  delimit thescope of the destination. In fact, the  alloc function isvirtually identical to that of the  F̃ article, where thereis no linear typing whatsoever.</p><p>Alloc函数将使用目的地的函数作为参数，而不是直接返回目的地。这种风格在线性Haskell中很常见，作为一种强制唯一性的手段。这有时被视为线性哈斯克尔设计的局限。然而，在这种特殊情况下，该函数对于界定目的地的范围是必要的。事实上，Alalc函数实际上与F̃文章中的函数相同，在该文章中没有任何线性类型。</p><p> Affine types (affine arguments are consumed  at most once,rather than  exactly once for linear arguments) are sometimespreferable to linear types. For instance affine types appear to represent streamingcomputations better. Butin the case of destinations we really do want linear types: itwouldn’t make as much sense to return from  alloc with apartially-filled destination.</p><p>仿射类型(仿射参数最多使用一次，而不是线性参数恰好使用一次)有时比线性类型更可取。例如，仿射类型似乎更好地表示流计算。但在目的地的情况下，我们确实需要线性类型：从分配的目的地返回部分填充的目的地没有多大意义。</p><p> When using linear types to make a pure interface to array functionswhich, in fact, mutate an array for efficiency (like in  this moduleof linearbase),we lose the ability to alias the mutable array in exchange forpurity. Sometimes it’s a perfectly acceptable trade-off, but somealgorithms depend on sharing mutation for efficiency, these are notavailable with linear pure mutable arrays. We are not making such atrade-off for destinations: linear destinations, being pure output,are, arguably, a more faithful interface for destination-passingstyle than mutable array.</p><p>当使用线性类型来建立数组函数的纯接口时，实际上是为了提高效率而改变数组(就像在这个线性基数的模中)，我们失去了用可变数组的别名来换取纯洁性的能力。有时这是一个完全可以接受的折衷方案，但有些算法依赖于共享变异来提高效率，这在线性纯可变数组中是无法实现的。我们没有对目的地进行这样的取舍：线性目的地是纯输出，可以说是目的地传递风格的一个比可变数组更忠实的接口。</p><p> Have you noticed how in the destination-passing  copyArray2, thecall to array concatenation from the direct-style implementation hasbeen replaced by a call to  splitDArray? And, if you have, have youalso noticed the symmetry between these two functions?</p><p>您有没有注意到，在目标传递的复制Array2中，直接样式实现中的Call到数组连接被替换为对SplitDArray的调用？如果你有，你有没有注意到这两个函数之间的对称性？</p><p> uncurry  ( &lt;&gt; )  ::  ( Array  a ,  Array  a )  -&gt;  Array  a splitDArray  ::  Darray  a ⊸  ( DArray  a ,  DArray  a )</p><p>取消复制(&lt；&gt；)：：(数组a，数组a)-&gt；数组拆分DArray：：Darray a⊸(数据数组a，数据数组a)</p><p> This is not a coincidence. There is a sort of duality betweendestinations and constructors. This duality happens when writingdestinations for other types than array types as well. I  spoke of thisphenomenon at Haskell Exchange 2017.</p><p>这不是巧合。目的地和建设者之间存在一种二元性。当写入除数组类型以外的其他类型的目标时，也会发生这种二元性。我在2017年哈斯克尔交易所(Haskell Exchange 2017)上谈到了这种现象。</p><p> If I define  type PushArray a = DArray a ⊸ (), then the type of copyArray</p><p>如果我定义类型PushArraya=DArray a⊸()，则复制数组的类型。</p><p>    We can give  PushArrays a (restricted) array interface, then we don’teven need to abandon direct style to benefit from destinations. Thisis part of the Data.Array.Polarizedframework in linear-base.</p><p>我们可以给PushArray一个(受限的)数组接口，那么我们甚至不需要放弃直接样式来从目的地获益。这是线性基座中数据、阵列、偏振框架的一部分。</p><p> In  a previous blogpost,I had written about how linear types made it possible to manipulatecompact data representation directly. The  Need type in that blogpost is, in fact, a form of destination.</p><p>在之前的一篇博文中，我曾写过线性类型如何使直接操作压缩数据表示成为可能。事实上，博客帖子中所需类型是目的地的一种形式。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.tweag.io/blog/2020-11-11-linear-dps/">https://www.tweag.io/blog/2020-11-11-linear-dps/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/传递/">#传递</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数组/">#数组</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>