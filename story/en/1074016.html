<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Fullmoon–基于Redbean的Lua web框架部署为单个文件Fullmoon – Redbean-based Lua web framework deployed as single file</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fullmoon – Redbean-based Lua web framework deployed as single file<br/>Fullmoon–基于Redbean的Lua web框架部署为单个文件</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 04:36:34</div><div class="page_narrow text-break page_content"><p>Fullmoon is a  fast and minimalistic web frameworkbased on  Redbean-- a portable, single-file distributable web server.</p><p>Fullmoon是一个基于Redbean的快速而简约的web框架，Redbean是一个可移植的、单文件可分发的web服务器。</p><p> Everything you need comes in a single file with no external dependencies(both for development and distribution) that runs on Windows, Linux, ormacOS. The following is a complete example of a Fullmoon application:</p><p>您需要的一切都在一个文件中，没有运行在Windows、Linux和ormacOS上的外部依赖项（用于开发和分发）。以下是Fullmoon应用程序的完整示例：</p><p> local fm  =  require   &#34;fullmoon &#34;fm. setTemplate(  &#34;hello &#34;,   &#34;Hello, {%&amp; name %} &#34;)fm. setRoute(  &#34;/hello/:name &#34;,  function( r)  return fm. serveContent(  &#34;hello &#34;, {name  = r. params. name})  end)fm. run()</p><p>本地fm=require&#34；满月&#34；调频。setTemplate（&#34；你好&#34；，&#34；你好，{%&amp；name%}&#34；）调频。setRoute（&#34；/hello/：name&#34；，函数（r）返回fm。serveContent（&#34；hello&#34；，{name=r.params.name}）结束）fm。跑（）</p><p> After it&#39;s  packaged with Redbean, it can be launchedusing  ./redbean.com, which starts a server that returns &#34;Hello, world&#34;to an HTTP(S) request sent to  http://localhost:8080/hello/world.</p><p>之后&#39；它是用红豆包装的，可以发射/红豆。com，它启动一个返回&#34；你好，世界&#34；发送到的HTTP（S）请求http://localhost:8080/hello/world.</p><p>    Redbean is a single-file distributable cross-platform web server withunique and powerful qualities. While there are several Lua-basedweb frameworks ( Lapis, Lor, Sailor, Pegasus, and others),none of them integrate with Redbean (although there is an experimentalframework  anpan).</p><p>Redbean是一个单文件可分发的跨平台web服务器，具有独特而强大的特性。虽然有几种基于Lua的Web框架（Lapis、Lor、Seall、Pegasus等），但它们都没有与Redbean集成（尽管有一个实验框架anpan）。</p><p> Fullmoon is a lightweight and minimalistic web framework that iswritten from the perspective of showcasing all the capabilities thatRedbean provides by extending and augmenting them in the simplest andthe most efficient way. It runs fast and comes with batteries included(routes, templates, JSON generation and more).</p><p>Fullmoon是一个轻量级的、极简的web框架，它通过以最简单、最高效的方式扩展和增强RedBean提供的所有功能来展示。它运行速度快，自带电池（路由、模板、JSON生成等）。</p><p> Fullmoon follows the Lua philosophy and provides a minimal set of toolsto combine as needed and use as the basis to build upon.</p><p>Fullmoon遵循Lua的理念，提供了一套最少的工具，可以根据需要进行组合，并作为构建的基础。</p><p>       You can download a copy of Redbean by running the following commands(skip the second one if you&#39;re on Windows):</p><p>您可以通过运行以下命令下载Redbean的副本（如果您在Windows上，请跳过第二个命令）：</p><p>    Save your code to a file named  .init.lua (for example, the Luacode shown in the  description).</p><p>将代码保存到名为的文件中。初始化。lua（例如，描述中显示的Luacode）。</p><p> Another option is to place your framework code into a separate file(for example,  .lua/myapp.lua) and add  require &#34;myapp&#34; to  .init.lua.</p><p>另一个选项是将框架代码放在一个单独的文件中（例如，.lua/myapp.lua），并添加require&#34；myapp&#34；到初始化。卢阿。</p><p>   If your framework code is stored in a separate Lua file, make sure toplace it inside the  .lua/ folder and zip that file as well.</p><p>如果您的框架代码存储在单独的Lua文件中，请确保将其放入。lua/文件夹并将该文件压缩。</p><p>    Point your browser to  http://127.0.0.1:8080/hello/world and you shouldsee &#34;Hello, world&#34; (assuming you are using the code shown in the introduction or the one in the  usage section).</p><p>将浏览器指向http://127.0.0.1:8080/hello/world你应该看到&#34；你好，世界&#34；（假设您使用的代码如简介或用法部分所示）。</p><p>  The simplest application would need to load the module, configure oneroute, and run the application:</p><p>最简单的应用程序需要加载模块、配置oneroute并运行应用程序：</p><p>  This application responds to any request for  /hello URL with returning&#34;Hello, world&#34; content (and 200 HTTP status) and responds with returning404 status for all other requests.</p><p>此应用程序将返回&#34；你好，世界&#34；内容（和200 HTTP状态），并对所有其他请求返回404状态。</p><p>  setRoute(route[, action]): registers a route.If  route is a string, then it is used as a route  expressionto compare the request path against. If it is a table, then itselements are strings that are used as  routes andits hash values are  conditions that the routesare checked against.If the second parameter is a  function, then it is executedif all conditions are satisfied. If it is a string, then it is used asa route expression and the request is processed as if it is sent atthe specified route (acts as an internal redirect).If any condition is not satisifed, then the next route is checked. Theroute expression can have multiple  parametersand  optional parts. The action handler acceptsa  request table that provides access to request and routeparameters, as well as  headers and  cookies.</p><p>setRoute（route[，action]）：注册一条路由。如果route是一个字符串，那么它将被用作一个route表达式来比较请求路径和。如果它是一个表，那么它的元素是用作路由的字符串，它的哈希值是路由检查的条件。如果第二个参数是函数，则在满足所有条件时执行。如果它是一个字符串，那么它将用作路由表达式，并且处理请求的方式就像在指定的路由上发送请求一样（充当内部重定向）。如果任何条件不满足，则检查下一条路线。路由表达式可以有多个参数和可选部分。操作处理程序acceptsa请求表，提供对请求和routeparameters以及头和cookie的访问。</p><p> setTemplate(name, template): registers a template with the specifiedname.If  template is a string, then it&#39;s compiled into a template handler.If it is a function, it is stored and called when rendering of thetemplate is requested. If it&#39;s a table, then its first element is atemplate or a function and the rest are used as options. For example,specifying  ContentType as one of the options sets the  Content-Typeheader for the generated content. Two templates ( 500 and  json) areprovided by default and can be overwritten.</p><p>setTemplate（名称、模板）：使用指定的名称注册模板。如果模板是字符串，那么它是&#39；它被编译成一个模板处理程序。如果它是一个函数，则在请求呈现模板时存储并调用它。如果是&#39；s是一个表，然后它的第一个元素是一个模板或一个函数，其余元素用作选项。例如，将ContentType指定为选项之一将为生成的内容设置ContentTypeHeader。默认情况下提供两个模板（500和json），可以覆盖。</p><p> serveResponse(status[, headers][, body]): sends an HTTP responseusing provided  status,  headers, and  body values. headers is an optional table populated with HTTP header name/valuepairs. If provided, this set of headers  removes all other headersset earlier during handling of the same request. Header names are case-insensitive, but provided aliases for header names with dashesare  case-sensitive:  {ContentType = &#34;foo&#34;} is an alternative formfor  {[&#34;Content-Type&#34;] = &#34;foo&#34;}.  body is an optional string.</p><p>ServerResponse（status[，headers][，body]）：使用提供的status、headers和body值发送HTTP响应。headers是一个可选表，由HTTP头名称/值对填充。如果提供了此标题集，则在处理同一请求期间，此标题集会删除之前的所有其他标题集。标头名称不区分大小写，但为带有破折号的标头名称提供的别名区分大小写：{ContentType=&#34；foo&#34；}是{[&#34；内容类型&#34；]=&#34;foo&#34；}。body是可选字符串。</p><p> serveContent(name, parameters): renders a template using providedparameters. name is a string that names the template (as set by a  setTemplatecall) and  parameters is a table with template parameters (referencedas variables in the template).</p><p>serveContent（名称、参数）：使用提供的参数呈现模板。name是命名模板的字符串（由setTemplatecall设置），parameters是带有模板参数的表（模板中引用为变量）。</p><p> run([options]): runs the server using configured routes.By default the server listens on localhost and port 8080. These valuescan be changed by setting  addr and  port values in the  options table.</p><p>运行（[options]）：使用配置的路由运行服务器。默认情况下，服务器监听本地主机和端口8080。可以通过在选项表中设置addr和port值来更改这些值。</p><p>  All examples include a standalone module (a  .lua file), which needs to becopied into  /.lua folder (along with  fullmoon.lua file). Running examplesrequires including a  require statement in the  .init.lua file, which loadsthe module, so for the showcase example,  .init.lua includes the following:</p><p>所有的例子都包括一个独立的模块（一个.lua文件），它需要被复制到/。lua文件夹（以及fullmoon.lua文件）。运行示例要求在中包含require语句。初始化。lua文件，加载模块，因此对于showcase示例。初始化。lua包括以下内容：</p><p>        The TechEmpower example implements various test types forthe  web framework benchmarksusing Fullmoon and in-memory sqlite database.</p><p>TechEmpower示例使用Fullmoon和内存中的sqlite数据库实现web框架基准测试的各种测试类型。</p><p>      The htmx board example demostrates a simple fullmoon application that generatesHTML fragments delivered to the client using  htmx library.</p><p>HTMXBoard示例演示了一个简单的fullmoon应用程序，该应用程序使用htmx库生成交付给客户机的TML片段。</p><p>     Note 1: since all the data is stored in memory,  this example requires runningredbean with -u (uniprocess) option.</p><p>注1：由于所有数据都存储在内存中，因此本例要求运行带有-u（uniprocess）选项的runningredbean。</p><p> Note 2: this examples retrieves htmx, hyperscript, and sortable libraries fromexternal resources, but these libraries can be also stored as local assets,thus providing a completely self-sufficient portable distribution package.</p><p>注2：本示例从外部资源检索htmx、hyperscript和可排序库，但这些库也可以存储为本地资产，从而提供一个完全自给自足的便携分发包。</p><p>       takes the path URL and matches it against each route URL in the orderin which routes are registered</p><p>获取路径URL，并按照注册路由的顺序将其与每个路由URL进行匹配</p><p>  calls a specified action handler (passing a request table) for thoseroutes that satisfy all conditions</p><p>为满足所有条件的对象调用指定的操作处理程序（传递请求表）</p><p> serves the response if anything other than  false or  nil returnedfrom the action handler (and continues the process otherwise)</p><p>如果操作处理程序返回的不是false或nil，则服务于响应（否则继续该过程）</p><p> In general, route definitions bind request URLs (and a set of conditions)to action handlers (which are regular Lua function). All conditions arechecked in a random order for each URL that matches the route definition.As soon as any condition fails, the route processing is aborted and thenext route is checked  with one exception: any condition can set the  otherwise value, which triggers aresponse with the specified status.</p><p>通常，路由定义将请求URL（和一组条件）绑定到操作处理程序（这是常规的Lua函数）。对于与路由定义匹配的每个URL，都会以随机顺序检查所有条件。一旦任何条件失败，路由处理将中止，并检查下一条路由，但有一个例外：任何条件都可以设置“否则”值，这将触发具有指定状态的响应。</p><p> If no route matches the request, then the default 404 processing istriggered, which can be customized by registering a custom 404 template( fm.setTemplate(&#34;404&#34;, &#34;My 404 page...&#34;)).</p><p>如果没有与请求匹配的路由，则启动默认的404处理，可以通过注册自定义的404模板（fm.setTemplate（&#34；404&#34；，&#34；My 404 page…&#34；）来定制。</p><p>  Each route takes a path that matches exactly, so the route  &#34;/hello&#34;matches requests for  /hello and doesn&#39;t match  /hell,  /hello-world,or  /hello/world. To match a path where  /hello is only a part of it, optional parameters and splat can be used).</p><p>每条路线都有一条完全匹配的路径，因此路线&#34/你好&#34；匹配请求/你好和不&#39；t match/hello world或/hello/world。要匹配/hello只是其中一部分的路径，可以使用可选参数和splat）。</p><p>  This application responds with &#34;Hello, World!&#34; for all requestsdirected at the  /hello path and returns 404 for all other requests.</p><p>此应用程序的响应为&#34；你好，世界&#34; 对于在/hello路径上定向的所有请求，返回404，用于所有其他请求。</p><p>  In addition to fixed routes, any path may include placeholders forparameters, which are identified by a  : followed immediately bythe parameter name:</p><p>除了固定路由之外，任何路径都可能包含参数的占位符，这些占位符后面紧跟着参数名，后面是：来标识：</p><p>  Each parameter matches one or more characters except  /, so the route &#34;/hello/:name&#34; matches  /hello/alice,  /hello/bob,  /hello/123 anddoes not match  /hello/bob/and/alice (because of the non-matchedforward slashes) or  /hello/ (because the length of the to-be-matchedfragment is zero).</p><p>每个参数匹配一个或多个字符，除了/，因此路由&#34/你好/:name&#34；匹配/hello/alice、/hello/bob、/hello/123和不匹配/hello/bob/和/alice（因为不匹配的正斜杠）或/hello/（因为要匹配的片段的长度为零）。</p><p>  Parameters can be accessed using the request table and its  paramstable, such that  r.params.name can be used to get the value of the name parameter from the earlier example.</p><p>可以使用请求表及其paramstable访问参数，例如r.params。name可用于从前面的示例中获取name参数的值。</p><p> There is another kind of parameter called splat that is written as  *and matches zero or more characters,  including a forward slash ( /).The splat is also stored in the  params table under the  splat name.For example, the route  &#34;/download/*&#34; matches  /download/my/file.zipand the splat gets the value of  my/file.zip. If multiple splats areneeded in the same route, then splats can be assigned names similar toother parameters:  /download/*path/*fname.zip (although the same resultcan be achieved using  /download/*path/:fname.zip, as the first splatis going to capture all path parts except the filename).</p><p>还有另一种称为splat的参数，它写为*并匹配零个或多个字符，包括正斜杠（/）。splat还存储在params表中的splat名称下。例如，路线&#34/下载/*&#34；匹配/下载/我的/文件。zipand splat获取my/file的值。拉链如果同一路线中需要多个splat，则可以为splat分配类似于其他参数的名称：/download/*path/*fname。zip（尽管使用/download/*path/:fname.zip可以获得相同的结果，因为第一个splati将捕获除文件名以外的所有路径部分）。</p><p> All parameters (including the splat) can appear in any part of the pathand can be surrounded by other text, which needs to be matched exactly.This means that the route  &#34;/download/*/:name.:ext&#34; matches /download/my/path/file.zip and  params.name gets  file, params.ext gets  zip and  params.splat gets  my/path values.</p><p>所有参数（包括splat）都可以出现在路径的任何部分，并且可以被其他文本包围，这些文本需要精确匹配。这意味着路线&#34/下载/*/：姓名：分机&#34；匹配/download/my/path/file。zip和params。name获取文件，params。ext获得zip和params。splat获取my/path值。</p><p>  Any specified route fragment or parameter can be declared as optional bywrapping it into parentheses:</p><p>任何指定的路由片段或参数都可以通过将其括在括号中声明为可选：</p><p>  In the example above, both  /hello and  /hello/Bob are going to beaccepted, but not  /hello/, as the trailing slash is part of theoptional fragment and  :name still expects one or more characters.</p><p>在上面的示例中，/hello和/hello/Bob都将被接受，但不接受/hello/，因为尾部斜杠是可选片段的一部分，并且：name仍然需要一个或多个字符。</p><p> Any unmatched optional parameter gets  false as its value, so in thecase above &#34;Hello, World!&#34; gets returned for the  /hello request URL.</p><p>任何不匹配的可选参数的值都为false，因此在上述情况下&#34；你好，世界&#34; 为/hello请求URL返回。</p><p> More than one optional parameter can be specified and optionalfragments can be nested, so both  &#34;/posts(/:pid/comments(/:cid))&#34; and &#34;/posts(/:pid)/comments(/:cid)&#34; are valid route values.</p><p>可以指定多个可选参数，并且可以嵌套optionalfragments，因此&#34/帖子（/：pid/评论（/：cid））和#34；和&#34/帖子（/：pid）/评论（/：cid）和#34；是有效的路由值。</p><p>  The default value for the parameters is all characters (except  /) oflength one or more. To specify a different set of valid characters, itcan be added at the end of the variable name; for example, using :id[%d] instead of  :id changes the parameter to match only digits.</p><p>参数的默认值是一个或多个长度的所有字符（除了/）。要指定一组不同的有效字符，可以将其添加到变量名的末尾；例如，使用：id[%d]而不是：id将参数更改为仅匹配数字。</p><p>  The following Lua character classes are supported:  %w,  %d,  %a, %l,  %u, and  %x; any punctuation character (including  % and  ])can also be escaped with  %. Negative classes (written in Lua as  %W)are  not supported, but not-in-set syntax is supported, so  [^%d]matches a parameter that doesn&#39;t include any digits.</p><p>支持以下Lua字符类：%w、%d、%a、%l、%u和%x；任何标点符号（包括%和]）也可以用%转义。不支持负类（以Lua的形式写成%W），但不支持set语法，因此[^%d]匹配的参数不&#39；不包括任何数字。</p><p> Note that the number of repetitions can&#39;t be changed (so  :id[%d]*is not a valid way to accept zero-or-more digits), as only sets areallowed and the values still accept one or more characters. If moreflexibility in describing acceptable formats is needed, then  customvalidators can be used to extend the matching logic.</p><p>注意重复的次数可以是&#39；不能更改（因此：id[%d]*不是接受零或多个数字的有效方法），因为只允许设置，并且值仍然接受一个或多个字符。如果需要更灵活地描述可接受的格式，那么可以使用CustomValidator来扩展匹配逻辑。</p><p>  Query and form parameters can be accessed in the same way as the pathparameters using the  params table in the  request table that ispassed to each action handler. Note that if there is a conflict betweenparameter and query/form names, then parameter names take precedence.</p><p>查询和表单参数的访问方式与使用请求表中的params表的pathparameters相同，请求表已传递给每个操作处理程序。请注意，如果参数和查询/表单名称之间存在冲突，则参数名称优先。</p><p>  Despite all earlier examples showing a single route, it&#39;s rarely thecase in real applications; when multiple routes are present, they arealways  evaluated in the order in which they are registered.</p><p>尽管之前所有的例子都显示了一条路线，但它&#39；在实际应用中很少出现这种情况；当存在多条路由时，它们总是按照注册顺序进行评估。</p><p> One  setRoute call can also set multiple routes when they have the sameset of conditions and share the same action handler:</p><p>当多个路由具有相同的条件集并共享相同的操作处理程序时，一个setRoute调用还可以设置多个路由：</p><p>    Given that routes are evaluated in the order in which they are set, moreselective routes need to be set first, otherwise they may not get achance to be evaluated:</p><p>考虑到路由是按照设置的顺序进行评估的，因此需要首先设置更多选择性路由，否则它们可能无法获得评估的机会：</p><p>  If the routes are set in the opposite order,  /user/bob may never bechecked as long as the  &#34;/user/:name&#34; action handler returns somenon- false result.</p><p>如果按相反的顺序设置路由，/user/bob可能永远不会被检查，只要&#34/user/：name&#34；操作处理程序返回一些非错误的结果。</p><p>  Each route can be provided with an optional name, which is useful inreferencing that route when its URL needs to be generated based onspecific parameter values. Provided  makePath function accepts eithera route name or a route URL itself as well as the parameter table andreturns a path with populated parameter placeholders:</p><p>每个路由都可以提供一个可选名称，当需要基于特定参数值生成其URL时，该名称在引用该路由时非常有用。提供的makePath函数接受路由名称或路由URL本身以及参数表，并使用填充的参数占位符返回路径：</p><p> fm. setRoute(  &#34;/user/:name &#34;, handlerName)fm. setRoute({  &#34;/post/:id &#34;, routeName  =   &#34;post &#34;}, handlerPost)fm. makePath(  &#34;/user/:name &#34;, {name  =   &#34;Bob &#34;})   --&gt; /user/Bobfm. makePath(  &#34;/post/:id &#34;, {id  =  123})   --&gt; /post/123fm. makePath(  &#34;post &#34;, {id  =  123})   --&gt; /post/123, same as the previous one</p><p>调频。setRoute（&#34；/user/：name&#34；，handlerName）fm。setRoute（{&#34；/post/：id&#34；，routeName=&#34；post&#34；}，handlerPost）fm。makePath（&#34；/user/：name&#34；，{name=&#34；Bob&#34；}）--&gt/用户/Bobfm。makePath（&#34；/post/：id&#34；，{id=123}）--&gt/邮政/123fm。makePath（&#34；post&#34；，{id=123}）--&gt/第123页，与前一页相同</p><p> If two routes use the same name, then the name is associated with theone that was registered last, but both routes are still present.</p><p>如果两条路由使用相同的名称，则该名称与上次注册的一条路由关联，但两条路由仍然存在。</p><p> The route name can also be used with external/static routes that areonly used for URL generation.</p><p>路由名称还可以用于仅用于URL生成的外部/静态路由。</p><p>  If the route is only used for path generation, then it doesn&#39;t even needto have a route handler:</p><p>如果路由仅用于路径生成，则它不会&#39；甚至不需要有一个路由处理程序：</p><p>    If an application needs to execute different functions depending onspecific values of request attributes (for example, a method), thislibrary provides two main options: (1) check for the attribute value anaction handler (for example, using  request.method == &#34;GET&#34; check) and(2) add a condition that filters out requests such that only requestsusing the specified attribute value reach the action handler. Thissection describes the second option in more detail.</p><p>如果应用程序需要根据请求属性（例如，方法）的特定值执行不同的功能，该库提供了两个主要选项：（1）检查属性值操作处理程序（例如，使用request.method=&#34；GET&#34；check）和（2）添加一个条件，过滤掉请求，以便只有使用指定属性值的请求才能到达操作处理程序。本节将更详细地介绍第二个选项。</p><p>  Each registered route by default responds to all HTTP methods (GET, PUT,POST, etc.), but it&#39;s possible to configure each route to only respondto specific HTTP methods:</p><p>默认情况下，每个注册的路由都会响应所有HTTP方法（GET、PUT、POST等），但它&#39；可以将每个路由配置为只响应特定的HTTP方法：</p><p>  In this case, the syntax  fm.GET&#34;/hello(/:name)&#34; configures the routeto only accept  GET requests. This syntax is equivalent to passing atable with the route and any additional filtering conditions:</p><p>在本例中，语法为fm。获得&#34/你好（/：name）和#34；将路由配置为仅接受GET请求。此语法相当于通过路由和任何附加过滤条件传递atable：</p><p>  If more than one method needs to be specified, then a table with a listof methods can be passed instead of one string value:</p><p>如果需要指定多个方法，则可以传递带有方法列表的表，而不是一个字符串值：</p><p>  Every route that allows a  GET request also (implicitly) allows a HEAD request and that request is handled by returning all headerswithout sending the body itself. If for some reason this implicithandling is not desirable, then adding  HEAD = false to the methodtable disables it (as in  method = {&#34;GET&#34;, &#34;POST&#34;, HEAD = false}).</p><p>每个允许GET请求的路由也（隐式）允许HEAD请求，该请求通过返回所有HEADERS而不发送正文本身来处理。如果出于某种原因，这种隐式处理是不可取的，那么将HEAD=false添加到methodtable中会禁用它（如method={&#34；GET&#34；，&#34；POST&#34；，HEAD=false}）。</p><p> Note that requests with non-matching methods don&#39;t get rejected, butrather  fall through to be checked by other routes andtrigger the 404 status returned if they don&#39;t get matched (with one exception).</p><p>请注意，使用非匹配方法的请求不会&#39；不要被拒绝，而是通过其他路线进行检查，如果没有&#39，则触发返回的404状态；没有匹配（只有一个例外）。</p><p>  In addition to  method, other conditions can be applied using  host, clientAddr,  serverAddr,  scheme, request headers, and parameters.For example, specifying  name = &#34;Bob&#34; as one of the conditions ensuresthe value of the  name parameter to be &#34;Bob&#34; for the action handler tobe called.</p><p>除了方法之外，还可以使用主机、ClientAddress、serverAddr、scheme、请求头和参数应用其他条件。例如，指定name=&#34；鲍勃&#34；其中一个条件是确保name参数的值为&#34；鲍勃&#34；以便调用操作处理程序。</p><p> Any request header can be checked using the header name as the key, so ContentType = &#34;multipart/form-data&#34; is satisfied if the value of the Content-Type header is  multipart/form-data. Note that the headervalue may include other elements (a boundary or a charset as part ofthe  Content-Type value) and only the actual media type is compared.</p><p>可以使用头名称作为键来检查任何请求头，因此ContentType=&#34；多部分/表格数据&#34；如果内容类型头的值是多部分/表单数据，则满足。请注意，headervalue可能包括其他元素（作为内容类型值的一部分的边界或字符集），并且只比较实际的媒体类型。</p><p>  String values are not the only values that can be used in conditionalroutes. If more than one value is acceptable, passing a table allows toprovide a list of acceptable values. For example, if  Bob and  Aliceare acceptable values, then  name = {Bob = true, Alice = true}expresses this as a condition.</p><p>字符串值不是条件路由中可以使用的唯一值。如果可以接受多个值，则传递一个表可以提供可接受值的列表。例如，如果Bob和Alicear是可接受的值，那么name={Bob=true，Alice=true}将其表示为一个条件。</p><p> Two special values passed in a table allow to apply a  regex or a pattern validation:</p><p>表中传递的两个特殊值允许应用正则表达式或模式验证：</p><p> regex: accepts a string that has a regular expression. For example, name = {regex = &#34;^(Bob|Alice)$&#34;} has the same result as the hashcheck shown earlier in this section</p><p>正则表达式：接受包含正则表达式的字符串。例如，name={regex=&#34；^（Bob | Alice）$&#34；}与本节前面显示的哈希检查结果相同</p><p> pattern: accepts a string with a Lua patern expression. For example, name = {pattern = &#34;^%u%l+$&#34;} accepts values that start with anuppercase character followed by one or more lowercase characters.</p><p>模式：接受带有Lua Patren表达式的字符串。例如，name={pattern=&#34；^%u%l+$&#34；}接受以大写字符开头，后跟一个或多个小写字符的值。</p><p> These two checks can be combined with the table existence check: name = {Bob = true, regex = &#34;^Alice$&#34;} accepts both  Bob and  Alicevalues. If the first table-existence check fails, then the results ofthe  regex or  pattern expression is returned.</p><p>这两个检查可以与表存在性检查结合使用：name={Bob=true，regex=&#34；^Alice$&#34；}接受Bob和Alicevalues。如果第一个表存在性检查失败，则返回正则表达式或模式表达式的结果。</p><p> The last type of a custom validator is a function. The provided functionreceives the value to validate and its result is evaluated as  false or true. For example, passing  id = tonumber ensures that the  id valueis a number. As another example,  clientAddr = fm.isLoopbackIp ensuresthat the client address is a loopback ip address.</p><p>自定义验证器的最后一种类型是函数。提供的函数接收要验证的值，其结果被评估为false或true。例如，传递id=tonumber可以确保id值是一个数字。另一个例子是clientAddr=fm。isLoopbackIp确保客户端地址是环回ip地址。</p><p>   local  function  isLessThan( n)  return  function( l)  return  tonumber(l)  &lt; n  end endfm. setRoute(fm. POST{  &#34;/upload &#34;, ContentLength  =  isLessThan( 100000)},  function( r)  ...handle the upload ...  end)</p><p>本地函数小于（n）返回函数（l）返回到数字（l）&lt；n end endfm。setRoute（fm.POST{&#34；/upload&#34；，ContentLength=isLessThan（100000）}，函数（r）。。。处理上传。。。(完)</p><p> It&#39;s important to keep in mind that the validator function actuallyreturns a function that is going to be called during a request to applythe check. In the previous example, the returned function accepts aheader value and compares it with the limit passed during its creation.</p><p>它&#39；请记住，验证器函数实际上会返回一个函数，该函数将在应用检查的请求期间被调用。在上一个示例中，返回的函数接受一个header值，并将其与创建过程中传递的限制进行比较。</p><p>  In some cases, failing to satisfy a condition is a sufficient reason toreturns some response back to the client without checking other routes.In a case like this, setting  otherwise value to a number or a functionreturns either a response with the specified status or the result of thefunction:</p><p>在某些情况下，不满足条件是将某些响应返回给客户端而不检查其他路由的充分理由。在这种情况下，将“否则”值设置为数字或函数将返回具有指定状态的响应或函数结果：</p><p> local  function  isLessThan( n)  return  function( l)  return  tonumber(l)  &lt; n  end endfm. setRoute(fm. POST{  &#34;/upload &#34;, ContentLength  =  isLessThan( 100000), otherwise  =  413},  function( r)  ...handle the upload ...  end)</p><p>本地函数小于（n）返回函数（l）返回到数字（l）&lt；n end endfm。setRoute（fm.POST{&#34；/upload&#34；，ContentLength=isLessThan（100000），否则=413}，函数（r）。。。处理上传。。。(完)</p><p> In this example the routing engine matches the route and then validatesthe two conditions comparing the method value with  POST and the valueof the  Content-Length header with the result of the  isLessThenfunction. If one of the conditions doesn&#39;t match, the status specifiedby the  otherwise value is returned with the rest of the response.</p><p>在本例中，路由引擎匹配路由，然后验证两个条件：将方法值与POST进行比较，将内容长度头的值与IslessThen函数的结果进行比较。如果其中一个条件不符合&#39；t match，否则值指定的状态将与响应的其余部分一起返回。</p><p> If the returned status needs to only apply to the  ContentLength check,then the  otherwise value along with the validator function can bemoved to a table associated with the  ContentLength check:</p><p>如果返回的状态只需要应用于ContentLength检查，则可以将otherwise值与validator函数一起移动到与ContentLength检查关联的表中：</p><p>  The difference between the last two examples is that in this exampleonly the  ContentLength check failure triggers the 413 response (andall other methods falls through to other routes), while in the previousone both  method and  ContentLength check failures trigger the same413 response.</p><p>最后两个示例之间的区别在于，在本例中，只有ContentLength检查失败触发413响应（所有其他方法都会通过其他路由），而在前一个示例中，方法和ContentLength检查失败都会触发相同的413响应。</p><p> Note that when the checked value is  nil, the check against a table isdeemed to be valid and the route is not going to be rejected. Forexample, a check for an optional parameter made against a string( name = &#34;Bo&#34;) fails if the value of  params.name is  nil, but passesif the same check is made against a table ( name = {Bo=true, Mo=true}),including regex/pattern checks. If this is not desirable, then a customvalidator function can explicitly check for the correct value.</p><p>注意，当checked值为nil时，对表的检查被认为是有效的，路由不会被拒绝。例如，根据字符串（name=&#34；Bo&#34；）检查可选参数如果参数的值为0，则失败。name为nil，但如果对一个表（name={Bo=true，Mo=true}）进行了相同的检查，包括正则表达式/模式检查，则会通过。如果不需要这样做，那么customvalidator函数可以显式检查正确的值。</p><p>  fm. setRoute({  &#34;/hello(/:name) &#34;, method  = {  &#34;GET &#34;,   &#34;POST &#34;, otherwise  =  405}},  function( r)  return   &#34;Hello,  &#34; ..(r. params. name  or   &#34;World! &#34;)  end)</p><p>调频。setRoute（{&#34；/hello（/：name）&#34；，method={&#34；GET&#34；，&#34；POST&#34；，否则=405}），函数（r）返回&#34；你好&#34。。（r.params.name或&#34；World！&#34；）(完)</p><p> In this case, if this endpoint is accessed with the  PUT method, theninstead of checking other routes (because the  method condition is notsatisfied), the 405 status is returned, as configured with the specified otherwise value.  As already mentioned,this route accepts a  HEAD request too (even when not listed), as a GET request is accepted.</p><p>在这种情况下，如果使用PUT方法访问该端点，则不会检查其他路由（因为不满足方法条件），而是返回405状态，如使用指定的“否则”值配置的。如前所述，当GET请求被接受时，该路由也会接受HEAD请求（即使未列出）。</p><p> When the 405 (Bad method) status is returned and the  Allow header isnot set, it is set to the list of methods allowed by the route. In thecase above it is set to  GET, POST, HEAD, OPTIONS values, as those arethe methods allowed by this configuration. If the  otherwise value is afunction (rather than a number), then returning a proper result andsetting the  Allow header is the responsibility of this function.</p><p>当405（坏方法）状态返回且未设置允许标头时，它被设置为路由允许的方法列表。在上面的案例中，它被设置为GET、POST、HEAD、OPTIONS值，因为这些是此配置允许的方法。如果“否则”值是一个函数（而不是一个数字），则该函数负责返回正确的结果并设置Allow标头。</p><p> The  otherwise value can also be set to a function, which provides moreflexibility than just setting a status value. For example, setting otherwise = fm.serveResponse(413, &#34;Payload Too Large&#34;) triggers aresponse with the specified status and message.</p><p>也可以将“否则”值设置为函数，这比仅设置状态值更灵活。例如，设置否则=fm。服务器响应（413和34；负载太大和34；）触发器响应指定的状态和消息。</p><p>  An action handler receives all incoming HTTP requests filtered for aparticular route. Each of the examples shown so far includes an actionhandler, which is passed as a second parameter to the  setRoute method.</p><p>操作处理程序接收所有传入的HTTP请求，这些请求经过特定路由过滤。目前显示的每个示例都包含一个actionhandler，它作为第二个参数传递给setRoute方法。</p><p> Multiple action handlers can be executed in the course of handling onerequest and as soon as one handler returns a result that is evaluated asa non- false value, the route handling process ends. Returning  falseor  nil from an action handler continues the processing, which allowsimplementing some common processing that applies to multiple routes(similar to what is done u</p><p>在处理onerequest的过程中可以执行多个操作处理程序，一旦一个处理程序返回一个评估为非假值的结果，路由处理过程就结束。从操作处理程序返回False或nil将继续处理，这允许实现一些应用于多个路由的常见处理（类似于u</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/lua/">#lua</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/redbean/">#redbean</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/路由/">#路由</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>