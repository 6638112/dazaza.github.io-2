<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CMake和C ++软件包管理的未来 CMake and the Future of C++ Package Management</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CMake and the Future of C++ Package Management<br/>CMake和C ++软件包管理的未来 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 19:57:30</div><div class="page_narrow text-break page_content"><p>I recently encountered a CMake feature which I wasn’t aware of. It’s  FetchContent. I’m sure this is not news to most people since it was added in CMake 3.14  1 and that’s been around since February of 2019, so two years now, but this feature is a revelation.</p><p>我最近遇到了一个我不知道的CMake功能。它是FetchContent。我敢肯定，这对大多数人来说不是什么新闻，因为它是在CMake 3.14 1中添加的，并且自2019年2月以来一直存在，所以已经有两年了，但这是一个启示。</p><p> It can… no, it should… no, it  must become the stepping stone for future of C and C++ package managers.</p><p> 它可以……不，应该……不，它必须成为C和C ++包管理器未来的垫脚石。</p><p> … after an issue with it is resolved, which I will talk about furhter down in the post</p><p> …问题解决后，我将在后续文章中进一步探讨</p><p>  It’s pretty straight forward, actually. By using two CMake functions:  FetchContent_Declare and  FetchContent_MakeAvailable  2 users can declare a named content item which can then be… well… fetched  in configure time. The key here is, as opposed to  file(DOWNLOAD ...), this allows three important things:</p><p>  实际上，这非常简单。通过使用两个CMake函数：FetchContent_Declare和FetchContent_MakeAvailable，两个用户可以声明一个命名的内容项，然后可以…好……在配置时获取。与file（DOWNLOAD ...）相对，此处的关键是允许三点重要：</p><p> Define the means by which the content is produced (not just source, but also types of sources)</p><p> 定义产生内容的方式（不仅是来源，还包括来源类型）</p><p>  include (FetchContent ) FetchContent_Declare ( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG release-1.8.0 ) FetchContent_Declare ( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git GIT_TAG v2.5.0 ) # After the following call, the CMake targets defined by googletest and # Catch2 will be defined and available to the rest of the build FetchContent_MakeAvailable (googletest Catch2 )</p><p>  包括（FetchContent）FetchContent_Declare（googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG版本1.8.0）FetchContent_Declare（Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git GIT_TAG v2.5.0） ＃在以下调用之后，将定义由googletest和＃Catch2定义的CMake目标，并且可用于其余版本FetchContent_MakeAvailable（googletest Catch2）</p><p>   I get it. Conan, vcpkg and the many  3 others that exist are great, but they are external. Of course I’ve experimented with the popular C++ package managers, but I’ve been reluctant to actually start using one for my projects. They may have CMake integrations but they are not triggered by CMake. They try — and succeed — to be more than CMake. The thing is that, like it or not, CMake is, or at least getting really close to being, the de-facto standard build system for C++  4. CMake is terrible in many ways, but it has proven to be the best we’ve have  5.</p><p>   我知道了。柯南，vcpkg和其他3个都很棒，但是它们是外部的。当然，我已经尝试了流行的C ++程序包管理器，但是我一直不愿意在我的项目中开始使用它。它们可能具有CMake集成，但不是由CMake触发的。他们尝试-并且成功-不仅仅是CMake。事实是，无论是否喜欢，CMake都是（或至少真的接近）了C ++ 4的事实上的标准构建系统。CMake在许多方面都很糟糕，但是事实证明，它是我们最好的。我有5。 </p><p>    Oh, this package has  CMakeLists.txt? You don’t need to download a binary when you can just fetch it and  add_subdirectory… it  6. It will inherit everything you need from your project.</p><p>哦，这个包有CMakeLists.txt吗？只要下载二进制文件并添加到add_subdirectory…，就无需下载二进制文件。它会继承项目中所需的一切。</p><p>  Sure, you can define different packages depending on platform,  triplet, and other configurations from other package managers, but you’re using their language. And then you have to either reimplement the same configuration analysis in you CMake files, or use some exports from those package managers, which is not always easy. If your package manager is within CMake, you already, inevitably, have all the tools to configure your build. The information for  the compiler, the  standard, the  target platform, the  architecture, the  linkage, and  everything else is already there.</p><p>  当然，您可以根据平台，三元组和其他程序包管理器的其他配置来定义不同的程序包，但是您使用的是它们的语言。然后，您必须在CMake文件中重新实现相同的配置分析，或者使用那些包管理器中的某些导出，这并不总是那么容易。如果您的软件包管理器在CMake中，则您不可避免地已经拥有配置构建的所有工具。有关编译器，标准，目标平台，体系结构，链接以及其他所有信息的信息已经存在。</p><p>   …and everything works, everything is up to date, and everything is there. You are ready to build.</p><p>   ……一切正常，一切都是最新的，一切都在那里。您已准备好进行构建。</p><p>   Of course you can use the raw calls, even though they are not yet a package manager.  Adobe do exactly that.</p><p>   当然，您可以使用原始调用，即使它们还不是程序包管理器。 Adobe正是这样做的。</p><p> And, though the feature has been around for some time, I’m only aware of a single package manager which is built with it:  CPM.</p><p> 而且，尽管该功能已经存在了一段时间，但我只知道一个内置的软件包管理器：CPM。</p><p> Now, CPM is awesome and I’ve started using it in my personal projects. Everything new I make uses CPM and I’ve migrated some old stuff, too. However it’s not a mature and complete package manager. It can’t error on package version inconsistencies (though it can detect them) and it’s not built to handle binary packages. Source only. That, however, might be the thing you need. It is enough for most of my needs. I wholeheartedly recommend it for personal and/or small projects.</p><p> 现在，CPM非常棒，我已经开始在个人项目中使用它。我制作的所有新内容都使用CPM，并且也迁移了一些旧内容。但是，它不是一个成熟而完整的软件包管理器。它不会因软件包版本不一致而出错（尽管它可以检测到它们），并且它不是为处理二进制软件包而构建的。仅来源。但是，这可能就是您需要的东西。这足以满足我的大多数需求。我全力推荐用于个人和/或小型项目。</p><p>  There is a huge problem. Not with CPM, but with FetchContent itself. FetchContent can’t be  the API package managers are built upon today.</p><p>  有个大问题。不是使用CPM，而是使用FetchContent本身。 FetchContent不能成为当今构建的API包管理器。 </p><p> This problem is performance. FetchContent is just too slow to be used for a serious load. It’s not an unfixable problem, but as far as I understand the issue, it will most likely have to be reimplemented. Here’s a table with me experimentig on different machines containing roughly  7 how much time it takes to run FetchContent per content item, or package.  Here’s the CMakeLists.txt I used. Note that these times are not from fetching the packages. They are from a “noop” run. One which identifies that everything is up to date, and does nothing.</p><p>这个问题就是性能。 FetchContent太慢，无法用于严重的负载。这不是一个无法解决的问题，但是据我了解，这个问题很可能必须重新实施。这是一张与我一起在不同机器上进行实验的表格，其中包含大约7个内容项目或数据包运行FetchContent所需的时间。这是我使用的CMakeLists.txt。请注意，这些时间并非来自获取软件包。它们来自“空头”运行。一种标识一切都是最新的，什么也没做的。</p><p>  That’s at  configure time, so every time the CMake scripts are touched, it will get executed. As you can see even the best time of roughly 200 ms per item is pretty bad, but the Windows times of over 1 second are abysmal. It’s simply prohibitive for a project with hundreds or even tens of dependencies to spend 1 second per dependency only to confirm that it’s up to date.</p><p>  这是在配置时，因此每次触摸CMake脚本时，它将被执行。如您所见，即使每个项目大约200毫秒的最佳时间也是很糟糕的，但是Windows超过1秒的时间却非常糟糕。对于具有数百个甚至数十个依赖项的项目来说，每个依赖项花1秒只是为了确认它是最新的，这简直是禁止的。</p><p> I opened  an issue on CMake’s tracker  8 about that, and hopefully it will get addressed in some way. I even have some ideas of how this can be addressed from the outside, just with CMake user code, but I hope it won’t come to this.</p><p> 我在CMake的跟踪器8上打开了一个有关的问题，希望可以通过某种方式解决。我什至对仅使用CMake用户代码如何从外部解决此问题有一些想法，但我希望不会有这个想法。</p><p> I truly believe that this is the future of C++ package management. If the preformance issue is fixed (or worked around), I think in several years C++ package management will be based on FetchContent. Whether CPM will become  the new de-facto standard or some other not-yet-written software, I can’t tell, but this is it! I can feel it!</p><p> 我坚信这是C ++软件包管理的未来。如果性能问题已解决（或解决），我认为几年后C ++软件包管理将基于FetchContent。 CPM会成为新的事实上的标准还是其他尚未编写的软件，我不知道，但这就是事实！我能感觉到！</p><p>  aka CMake Pi (3.14% sure I’m the first one ever making this joke)  ↩</p><p>  aka CMake Pi（3.14％的人确定我是第一个开这个玩笑的人）↩</p><p>      I know.  Technically CMake is a “build system generator” and not a “build system”, but, really, for most intents and purposes you  can think of it as a build system.  ↩</p><p>      我知道。从技术上讲，CMake是“构建系统生成器”，而不是“构建系统”，但是实际上，对于大多数意图和目的，您都可以将其视为构建系统。 ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://ibob.github.io/blog/2020/01/13/cmake-package-management/">http://ibob.github.io/blog/2020/01/13/cmake-package-management/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件包/">#软件包</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/future/">#future</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cmake/">#cmake</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>