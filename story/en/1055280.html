<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用fzf改善壳体工作流程 Improving Shell Workflows with Fzf</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Improving Shell Workflows with Fzf<br/>用fzf改善壳体工作流程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-01 19:37:56</div><div class="page_narrow text-break page_content"><p>Working in a shell usually involves executing the same set of commands again and again; what changes is the order in which the commands are executed, and the parameters that are passed to the command. One way to improve shell workflows is finding patterns in the execution order of commands and extracting those into little scripts; this can often be helpful and is part of what makes working in a shell so powerful. Another way is to understand how the parameters are added and try to simplify this; that’s what I will focus mostly on in this blog post.</p><p>在shell中工作通常涉及一次又一次地执行相同的命令;更改是执行命令的顺序，以及传递给命令的参数。改进shell工作流的一种方法是在命令的执行顺序中找到模式，并将这些模式提取为小脚本;这通常会有所帮助，是在如此强大的壳体中工作的一部分。另一种方法是了解如何添加参数并尝试简化这一点;这就是我将在这个博客文章中关注的是我的重点。</p><p> Typical parameters in my workflows are file names or git branch names (looking at my  history,  git is by far my most used command). Typing them in manually is often cumbersome and error-prone, and that’s why I avoid doing it whenever possible. Depending on the command there might be tab completion which can help a lot, but it is not always the most convenient. In this blog post I will show how to use  fzf as an alternative.</p><p> 我的工作流程中的典型参数是文件名或Git分支名称（看着我的历史，Git是迄今为止我最常用的命令）。在手动中键入它们通常会繁琐和容易出错，这就是为什么我避免在尽可能做的原因。根据命令的不同，可能有标签完成可以帮助很多，但它并不总是最方便的。在此博客文章中，我将展示如何使用FZF作为替代方案。</p><p> The basic functionality of  fzf is very simple: it reads a set of lines from  stdin, provides a user interface to select one or more lines, and writes the selected lines to  stdout. This sounds very basic, but it is in fact very powerful. The  fzf wiki has a ton of examples on how this functionality can be used effectively. This is a great resource, and I have taken several of the functions shown there into my repertoire and use them almost daily. But in your own shell usage, you will often discover workflows that are fairly specific to your use cases; they are not general enough to be found on a wiki like this, but it is still useful to automate them for your own usage.</p><p> FZF的基本功能非常简单：它从STDIN读取一组行，提供了一个用户界面来选择一个或多个行，并将所选行写入STDOUT。这听起来非常基本，但实际上非常强大。 FZF Wiki有很多关于如何有效使用该功能的示例。这是一个很好的资源，我已经拍摄了几个函数，在我的曲目中，几乎每天都使用它们。但在您自己的shell使用情况下，您经常会发现对您使用案例相当具体的工作流程;它们不足以在这样的Wiki上找到足够的一般性，但自动为自己的用途自动化它们仍然很有用。</p><p> To show how I usually approach this, I am going to describe four shell workflows that I used to follow, and then show how to write a shell function with  fzf that makes the workflow more convenient. They are (in increasing complexity):</p><p> 为了展示我如何往往接近这个，我将描述我曾经遵循的四个shell工作流，然后展示如何用fzf写一个shell函数，使工作流程更方便。它们（在越来越复杂）中：</p><p>  For most of them, I will show a simple function that covers most use cases, and then extend this function with more functionality that makes it even more convenient or robust.</p><p>  对于其中大多数，我将显示一个简单的函数，涵盖大多数用例，然后使用更多功能扩展此功能，使其更方便或强大。</p><p>   I keep my python virtual environments in a central place in  ~/.venv. To activate one of the environments, I used to</p><p>   我将我的Python虚拟环境保留在〜/ .venv的中央处。要激活其中一个环境，我曾经习惯过</p><p>  This workflow can be improved by using a tool like  virtualenvwrapper, but it is also a good example of a workflow that can be easily improved with  fzf. The easiest solution can be just one line.</p><p>  可以使用像VirtualEnvWrapper这样的工具来改进此工作流，但它也是可以使用FZF轻松提升工作流的一个很好的例子。最简单的解决方案可以只是一行。 </p><p>     (add this to your  .bashrc to make it permanent) and then use it as follows</p><p>（将此添加到您的.bashrc以使其永久化），然后使用它如下</p><p>  A minor problem with the script is that if you exit out of  fzf by pressing  Ctrl-D, the script will fail with</p><p>  脚本的一个次要问题是，如果通过按CTRL-D退出FZF，脚本将失败</p><p>  You can choose to ignore this since it has the desired effect: no virtual environment is activated. But a fix is also straightforward: we can store the result of  fzf in a variable and only try to activate the virtual environment if the variable is non-empty.</p><p>  您可以选择忽略此内容，因为它具有所需的效果：未激活虚拟环境。但是修复程序也很简单：我们可以将FZF的结果存储在变量中，并且如果变量是非空的，则只需尝试激活虚拟环境。</p><p>    Another pattern that I found myself repeating was during clean up of my git branches. For every feature or experiment I create a new branch in git. Once the feature is merged to the main branch or the experiment is no longer needed, the branch can be deleted. But I usually don’t delete the branch immediately. Instead, the branches pile up until it reaches a point where it makes navigating the branches with active code harder. When I actually come around to clean up the branches, the workflow looks something like this.</p><p>    我发现自己重复的另一种模式在清理我的Git分支机构期间。对于每个功能或实验，我在git中创建一个新的分支。一旦将该功能合并到主分支或不再需要实验，可以删除分支。但我通常不会立即删除分支。相反，分支机构堆积起来，直到它到达它使得与活动代码更加难以导航分支的点。当我实际来到清理分支机构时，工作流程看起来像这样。</p><p>  Sometimes I’m not sure whether the branch can really be deleted, so I first need to run  git log on it to see what it actually contains, and then delete the branch as above. I then repeat this process until all stale branches are deleted.</p><p>  有时我不确定分支是否可以真正删除，所以我首先需要运行git登录它以查看它实际包含的内容，然后按照上面删除分支。然后我重复此过程，直到删除所有陈旧的分支。</p><p> This workflow is another good example which can be made a lot easier with  fzf. This time we pass the  --multi option to  fzf, which allows selecting multiple entries with  &lt;tab&gt;.</p><p> 这个工作流是另一个很好的例子，可以使用fzf更轻松。这次我们将-Multi选项传递给FZF，允许使用＆lt; tab＆gt选择多个条目。</p><p>     This version mostly works, but there are a few improvements that we can do. First,  git branch shows all branches, including the one that is currently checked out, marked with a  *. Since you cannot delete the branch that is currently checked out, it doesn’t make sense to show it in the first place. We can omit it by piping the output of  git branch through  grep --invert-match &#39;\*&#39;.</p><p>     此版本主要是有效的，但我们可以做一些改进。首先，git branch显示所有分支机构，包括目前检查的分支，标有*。由于您无法删除当前检查的分支，因此首先显示它并没有意义。我们可以通过将Git分支输出通过Grep  -  Invert-Match＆＃39; \ *＆＃39; \ *＆＃39; \ *＆＃39; </p><p> Another issue is that we pass  $branches_to_delete unquoted to  git branch -D; we need to do this because  git needs to receive every branch as a separate argument. If you use a linter like  shellcheck, it will complain about this line, since unquoted variables can cause globbing and word splitting. In our case this is a false alarm since branch names cannot contain globbing characters; nevertheless, I think it’s a good practice to avoid unquoted variables whenever possible. One way to do this is to pipe the output of  fzf through  xargs directly into  git branch -D instead of storing it in a variable. If we add the  --no-run-if-empty option to  xargs, it will only call  git if there was at least one branch selected.</p><p>另一个问题是，我们将$ branches_to_delete除以git branch -d;我们需要这样做，因为Git需要将每个分支接收为单独的参数。如果您使用像Shellcheck这样的Linter，它将抱怨这条线，因为未引入的变量可能导致Globbing和Word Spritting。在我们的情况下，这是一个误报，因为分支名称不能包含Globbing字符;尽管如此，我认为尽可能避免未引发的变量是一个很好的做法。这样做的一种方法是将FZF的输出直接管制到Git分支-D中，而不是将其存储在变量中。如果我们向Xargs添加 - 不运行的IF-NAULE选项，如果至少选择了至少一个分支，则只会调用git。</p><p> Finally, I mentioned that it might be useful to see the output of  git log for the selected branch. We can do so with the  --preview option of  fzf. The value of  --preview can be any command; it will be executed whenever a new line is selected in  fzf, and the output is shown in a preview window. In the command,  {} acts as a placeholder that is replaced with the currently selected line.</p><p> 最后，我提到它可能有助于查看所选分支的Git日志的输出。我们可以使用fzf的--preview选项来实现。 --preview的值可以是任何命令;每当在FZF中选择新行时，它将被执行，并且输出显示在预览窗口中。在命令中，{}充当用当前所选行替换的占位符。</p><p>   Note that we also pipe the output of  git branch through  cut -c 3-, which removes the first two characters from every line. If you look at the output of  git branch, you’ll see that every branch except the current one is prefixed by two spaces. If we would not remove them with  cut, the preview command would be executed as  git log &#39;  branch-name&#39;, which causes  git to complain because of the leading whitespace. (An alternative would be to use  git log {..} as a preview command, which will strip the whitespace from the selected line.)</p><p>   请注意，我们还通过切割-c 3-将Git分支的输出管道，该删除每行的前两个字符。如果查看Git分支的输出，您将看到除了当前的每个分支，由两个空格为前缀。如果我们不会用剪切删除它们，则预览命令将被执行为git log＆＃39;分支名称＆＃39;，由于领先的空格，因此引起了Git抱怨。 （替代方案是使用Git Log {..}作为预览命令，它将从所选行中剥离空格。）</p><p> Here is an example where we delete the same three branches as above, but we get more information while we do so.</p><p> 以下是我们删除相同的三个分支的示例，但我们在我们这样做时获得更多信息。</p><p>   For code reviews, I often find it helpful to check out the code under review. The  GitHub CLI makes this easy: if you execute  gh pr checkout &lt;pr-number&gt; in a git repository, it will check out the pull request with number  &lt;pr-number&gt; to a local branch. But where do we get  &lt;pr-number&gt; from? In my workflow, I would</p><p>   对于代码审查，我经常发现签出审查的代码有助于。 GitHub CLI使其简单：如果执行GH Pr Checkout＆lt; pr-number＆gt;在GIT存储库中，它将通过数字＆lt; pr-number＆gt检查拉出请求。到当地分支机构。但我们在哪里得到＆lt; pr-number＆gt;从？在我的工作流程中，我会</p><p>  This works well for one or two-digit numbers, but even for three-digit numbers I sometimes have to switch back to the browser to make sure that I remembered the number correctly.</p><p>  这适用于一个或两位数的数字，但即使是三位数字，我有时也必须切换回浏览器以确保我记得正确的数字。</p><p> In my  last blog post I already described how to query the GitHub API with  gh; we can use this here to get  &lt;pr-number&gt; automatically. Specifically, we can get the open pull requests from the GitHub API with</p><p> 在我的最后一个博客文章中，我已经描述了如何用gh查询github api;我们可以在此处使用它来获得＆lt; pr-number＆gt;自动地。具体来说，我们可以使用GitHub API获取打开的拉拔请求 </p><p>  It returns an array of JSON objects, one for each pull request. We need to convert this array of JSON objects to a format that  fzf can interpret: a separate row for every pull request. If we think about the data that we need, the first thing is the pull request number that we want to pass to  gh checkout. We also need some way to identify the pull request that we are interested, and the title is the most obvious candidate. We can use  jq’s string interpolation to extract this information into a JSON string.</p><p>它返回一系列JSON对象，一个用于每个拉出请求。我们需要将此阵列的JSON对象转换为FZF可以解释的格式：每个拉出请求的单独行。如果我们考虑我们需要的数据，那么第一件事就是我们要传递给GH结账的拉出请求号。我们还需要一些方法来识别我们感兴趣的拉申请，而标题是最明显的候选人。我们可以使用JQ的字符串插值来将此信息提取到JSON字符串中。</p><p>  (The  --raw-output string evaluates the JSON string; without it, every row would be surrounded by quote characters.) For example, if I execute this in a directory with a checkout of  https://github.com/junegunn/fzf, it outputs</p><p>  （ -  Raw-Output String评估JSON字符串;没有它，每行都会被引用字符包围。）例如，如果我在具有https://github.com/junegunn/结帐的目录中执行此操作FZF，它输出</p><p> #2368 - ansi: speed up parsing by roughly 7.5x#2349 - Vim plugin fix for Cygwin 3.1.7 and above#2348 - [completion] Default behaviour to use fd if present else use find.#2302 - Leading double-quote for exact match + case sensitive search#2197 - Action accept-1 to accept a single match#2183 - Fix quality issues#2172 - Draft: Introduce --print-selected-count#2131 - #2130 allow sudo -E env fzf completion#2112 - Add arglist support to fzf.vim#2107 - Add instructions on command for installing fzf with Guix and/or Guix System#2077 - Use fzf-redraw-prompt in history widget#2004 - Milis Linux support#1964 - Use tmux shell-command#1900 - Prompt generally signals that the shell is ready#1867 - add {r}aw flag to disable quoting in templates#1802 - [zsh completion] Expand aliases recursively#1705 - Option to select line index of input feed and to output cursor line index#1667 - $(...) calls should be quoted: \&#34;$(...)\&#34;#1664 - Add information about installing using Vundle#1616 - Use the vim-specific shell instead of the environment variable#1581 - add pre / post completion &#39;hooks&#39;#1439 - Suppress the zsh autocomplete line number output#1299 - zsh completion: Add support for per-command completion triggers.#1245 - Respect switchbuf option#1177 - [zsh] let key bindings be customized through zstyle#1154 - Improve kill completion.#1115 - _fzf_complete_ssh: support Include in ssh configs#559 - [vim] use a window-local variable to find the previous window#489 - Bash: Key bindings fixes</p><p> ＃2368  -  Ansi：加速解析大约7.5倍＃2349  - 用于Cygwin 3.1.7和上面的Vim插件修复＃2348  -  [完成]使用FD的默认行为如果习惯使用。＃2302  - 领先的双引用完全匹配+区分大小写搜索＃2197  - 动作接受-1接受单一匹配＃2183  - 修复质量问题＃2172  - 草稿：介绍 - 印刷所选 - 计数＃2131  - ＃2130允许sudo -e env fzf完成＃ 2112  - 添加arglist支持fzf.vim＃2107  - 添加有关命令的指令与guix和/或guix system＃2077  - 使用fzf-redraw-stult在历史小部件＃2004  -  milis linux支持＃1964  - 使用tmux shell -command＃1900  - 提示出现shell准备好＃1867  - 添加{r} aw标志禁用模板中的引用＃1802  -  [zsh完成]递归延伸别名＃1705  - 选择输入馈送的线索索引和选择输入源的线索索引和到输出光标线索引＃1667  -  $（...）应引用：\＆＃34; $（...）\＆＃34;＃1664  - 添加有关使用Vundle＃1616安装有关安装的信息 - 使用Vim - 特定的shell而不是环境变量＃1581  - 添加前/后完成＆＃39;钩子＆＃39;＃1439  - 抑制zsh自动完成行号输出＃1299  -  zsh完成：为每个命令完成触发添加支持。＃ 1245  - 尊重switchbuf选项＃1177  -  [zsh]让关键绑定通过zstyle＃1154自定义 - 改善终止完成。＃1115  -  _fzf_complete_ssh：支持包括在ssh configs＃559  -  [vim]使用窗口局部变量来查找上一个窗口＃489  -  Bash：密钥绑定修复</p><p> If we pipe this into  fzf it will allow us to select any of those lines and write it to  stdout. We are only interested in the number, so we extract it using  sed and a regex with capture group. Our first version of a working script looks like this.</p><p> 如果我们将其送入FZF，则允许我们选择任何这些行并将其写入STDOUT。我们只对该号码感兴趣，因此我们使用SED和ReGEx与捕获组提取。我们的第一个工作脚本的版本如下所示。</p><p>     This is probably enough for most use cases (and the  GitHub blog has an even simpler script which uses the output of  gh directly). But maybe the title is not be enough to determine the pull request that we are interested in; more information might help. For example, we could show the description of the pull request in the preview window, or other information that we can get from the API.</p><p>     这可能足以让大多数用例（并且GitHub博客有一个更简单的脚本，它直接使用GH的输出）。但也许标题是不够确定我们感兴趣的拉请求;更多信息可能有所帮助。例如，我们可以在预览窗口中显示拉拉请求的描述，或者我们可以从API获取的其他信息。</p><p> In the function to delete branches above, we populated the preview window by calling  git log on the currently selected branch. A first idea would be to try something similar here and query the API for the currently selected pull request. But querying the API whenever we select a different line would create annoying delays and would make it hard to use. Luckily, we don’t need to query the API again. We already have all the data we need from the first call to the API. What we can do is to extend our  jq template string to extract all the information that we care about, and then use a feature from  fzf that allows us to hide some information from the input lines in the selection window and show it in the preview.</p><p> 在上面删除分支的函数中，我们通过在当前所选分支上调用git log来填充预览窗口。第一个想法是在这里尝试类似的东西，并查询当前选择的拉请求的API。但是，每当我们选择不同的线时查询API会产生令人讨厌的延迟，并使难以使用。幸运的是，我们不需要再次查询API。我们已经拥有了第一个调用API的所有数据。我们可以做的是扩展我们的JQ模板字符串以提取我们关心的所有信息，然后使用FZF的功能，允许我们从选择窗口中的输入行隐藏一些信息并在预览中显示它。</p><p> fzf considers each line as an array of fields. By default, fields are separated by whitespace sequences (tabs and spaces), but we can control the separator with the  --delimiter option. For example, if we set  --delimiter=&#39;,&#39; and pass the row  first,second,third to  fzf, then the fields are  first,,  second,, and  third. By itself, this is not useful yet. But using the  --with-nth option, we can control the fields that are displayed in the selection window. For example,  fzf --with-nth=1,2 will only display the first and second field of each row. Furthermore, we saw above that we can write  {} as a placeholder in the preview command and  fzf will replace it with the currently selected row. But  {} is just the simplest form of a placeholder. We can also specify field indices within the braces and  fzf will replace the placeholder with those fields.</p><p> FZF将每行视为一系列字段。默认情况下，字段由空格序列（选项卡和空格）分隔，但我们可以使用--delimiter选项控制分隔符。例如，如果我们设置--delimiter =＆＃39;，＆＃39;并将行首先传递，第二，第三到FZF，那么字段是第一个，第二，，第三个字段。本身，这尚未有用。但是使用--with-nth选项，我们可以控制选择窗口中显示的字段。例如，fzf --with-nth = 1,2将仅显示每行的第一和第二字段。此外，我们在上面看到，我们可以将{}写入{}作为预览命令中的占位符，而FZF将用当前选定的行替换它。但{}只是占位符的最简单形式。我们还可以在括号内指定字段指数，FZF将替换与这些字段的占位符。 </p><p> Here is an example where we use both  --with-nth and  --preview, using  &lt;tab&gt; as a delimiter.</p><p>以下是我们使用的示例--with-nth和--preview，使用＆lt; tab＆gt;作为分隔符。</p><p>  fzf will split each line at a tab character; the  --with-nth=1 option instructs  fzf to show the first part in the selection window; the  {2} in the preview command will be replaced with the second part, and since it is passed to  echo, it will just be displayed.</p><p>  FZF将在标签字符下拆分每行; --with-nth = 1选项指示fzf显示选择窗口中的第一部分;预览命令中的{2}将用第二部分替换，并且由于它被传递到回声，它将显示它。</p><p>  We will use this to show some useful information in the preview window. Let’s first look at the final script, and then we’ll go through it step by step.</p><p>  我们将使用它来在预览窗口中显示一些有用的信息。让我们先看看最终脚本，然后我们将逐步浏览它。</p><p>   There are some changes to the simple function. We extract the  jq template string into a variable and extend it with more information: the author, the timestamps when the pull request was created and last updated, and the description of the pull request. All of this information is contained in the JSON returned by the GitHub API when we call  gh api &#39;repos/:owner/:repo/pulls&#39;.</p><p>   简单的功能有一些变化。我们将JQ模板字符串解压缩到变量中并使用更多信息扩展：作者，创建拉拉请求时的时间戳以及上次更新的时间戳，以及提取请求的描述。所有这些信息都包含在GitHub API呼叫GH API＆＃39; Repos /：Owner /：Repo / Pulls＆＃39;</p><p> Notice that we separated the new information from the number and title by a tab character  \t. We use this also as a delimiter for  fzf, and then show the pull request number and title in the selection window (using  --with-nth=1) and the rest in the preview window (using  --preview=&#39;echo -e {2}&#39;).</p><p> 请注意，我们通过标签字符\ t将新信息与标题和标题分开。我们也使用它作为fzf的分隔符，然后在选择窗口中显示拉请求编号和标题（使用--with-nth = 1）和预览窗口中的其余部分（使用--preview =＆＃39; echo -e {2}＆＃39;）。</p><p> Notice also that this time we don’t use the  --raw-output option for  jq. The reason is a bit subtle. The strings that we create with  jq contain escaped newline characters. If we pass the  --raw-output option to  jq, it will interpret all escaped characters; in particular, it will write a literal new line character for any  \n in the string. For example, compare the output of</p><p> 另请注意，这次我们不使用JQ的 - 拖尾输出选项。原因有点微妙。我们使用JQ创建的字符串包含逃逸的换行符。如果我们将-raw-opput选项传递给JQ，它将解释所有转义的字符;特别是，它将在字符串中为任何\ n编写一个文字新行字符。例如，比较输出</p><p>        The first version is problematic. Remember that  fzf is a row-based program. It takes a list of rows, allows the user to select one or more of them, and outputs the selected rows. This means that with the  --raw-output option, every pull request would show up as multiple rows in  fzf; this is clearly not what we want. So instead, we let  jq output the escaped version to ensure that every pull request corresponds to a single row.</p><p>        第一个版本是有问题的。请记住，FZF是基于行的程序。它需要一行列表，允许用户选择其中一个或多个，并输出所选行。这意味着使用 -  raw-output选项，每个拉出请求将显示为fzf中的多行;这显然不是我们想要的。因此，我们让JQ输出转义版本，以确保每个拉出请求对应于单行。 </p><p> This however introduces new problems. First, we still want the preview window to show literal new line characters, not  \n though; we solve this by using  echo -e as a preview command (the  -e enables interpretation of the escaped characters). The second problem is that without the  --raw-output option,  jq will show the quote characters at the start end the end of the string, and it will print our delimiter  \t as an escaped character. We solve this by removing the quotes manually, and by replacing the first escaped tab character by an actual tab character; that’s what the  sed is doing after the  jq.</p><p>然而，这引入了新问题。首先，我们仍然想要预览窗口来显示文字新行字符，而不是\ n;我们通过使用echo -e作为预览命令来解决此问题（-e启用逃逸字符的解释）。第二个问题是，没有 -  raw-output选项，JQ将在Start的开始结束时显示引号字符，并且它将将我们的分隔符\ t作为转义字符。我们通过手动删除引号来解决此问题，并通过实际标签字符替换第一个转义的选项卡字符;这就是JQ之后的东西正在做的事情。</p><p> Finally, notice that we specify  --preview-window=top:wrap so that  fzf wraps lines in the preview window and displays it at the top of the screen instead of the right.</p><p> 最后，请注意我们指定--preview-window = top：包装以便在预览窗口中的fzf包裹线，并在屏幕顶​​部而不是右侧显示它。</p><p>    We saw above how we can use  fzf do delete git branches. Now let’s look at the opposite: creating new branches. At my workplace, we are using JIRA for issue tracking. Every feature branch usually corresponds to some JIRA issue. To keep track of this correspondence, I use the following naming scheme for my git branches. Let’s say that the JIRA project is named  BLOG, and I’m currently working on the issue BLOG-1232 with title “Add a verbose flag to the startup script”. Then I will name my branch  BLOG-1232/add-a-verbose-flag-to-the-startup-script; the description part usually gives enough information to determine the feature that the branch corresponds to, and the  BLOG-1232 part lets me jump to the JIRA ticket if I need to look up more details about the issue.</p><p>    我们看到了我们如何使用FZF删除Git分支。现在让我们看看相反的：创建新分支机构。在我的工作场所，我们正在使用JIRA进行问题跟踪。每个特征分支通常都对应于一些JIRA问题。要跟踪此对应关系，我将使用以下命名方案进行Git分支。假设JIRA项目名为博客，我目前正在使用标题“向启动脚本添加详细标志”问题博客-1232。然后我会命名我的分支博客-1232 / add-a-renbose-flag-the-startup脚本;描述部分通常提供足够的信息来确定分支对应的特征，并且博客-1232允许我允许我跳转到JIRA机票，如果我需要查找有关该问题的更多详细信息。</p><p>   Usually, I have to switch between browser and terminal several times, and I still manage to create typos in the branch name.</p><p>   通常，我必须多次在浏览器和终端之间切换，并且我仍然可以在分支名称中创建拼写错误。</p><p> This is another workflow can be entirely automated. As with the GitHub pull requests, we can get the issues from the JIRA API. The function that we’ll create is similar to  pr-checkout, but there are a few notable differences.</p><p> 这是另一个工作流程可以完全自动化。与GitHub拉拔请求一样，我们可以从JIRA API获取问题。我们创建的函数类似于Pr-checkout，但存在一些显着的差异。</p><p> First, there is no convenient CLI tool like  gh to communicate with the JIRA API. We have to talk to it directly using  curl. Second, at least the JIRA server I am using doesn’t allow the creation of access tokens, which forces us to use basic authentication with username and password when talking to the API. I don’t want to store my password in a shell script, or in fact in any unencrypted file, so we’ll be using  secret-tool for a more secure password storage. And finally, the creation of the branch name requires more logic than a simple text extraction; we’ll use a combination of  cut,  sed, and  awk.</p><p> 首先，没有方便的CLI工具像GH一样与JIRA API通信。我们必须直接使用卷曲与它交谈。其次，至少我使用的JIRA服务器不允许创建访问令牌，这在与API交谈时使用用户名和密码使用基本身份验证。我不想将密码存储在shell脚本中，或者实际上在任何未加密的文件中，所以我们将使用秘密工具进行更安全的密码存储。最后，分支名称的创建需要比简单文本提取更多的逻辑;我们将使用切割，sed和awk的组合。</p><p> Let’s again first look at the final script and then try to understand how it works.</p><p> 让我们再次先查看最终脚本，然后尝试了解它的工作原理。 </p><p>   We can see three parts. First, the  curl command and its variables to talk to the JIRA API. Then the conversion of the API output into rows that are read by  fzf; this part is the same as in  pr-checkout. And finally converting the output of  fzf into our desired format for the branch name.</p><p>我们可以看到三个部分。首先，卷曲命令及其变量与JIRA API交谈。然后将API输出的转换成FZF读取的行;这部分与PR-Checkout中的相同。最后将FZF的输出转换为分支名称的所需格式。</p><p> The biggest change compared to  pr-checkout is the  curl command. We are using the  JIRA search endpoint which expects a  jql (JIRA query language) string as a URL parameter. In my case, I’m interested in all issues of the  BLOG project which are assigned to me, and which are marked as  In Progress. The  jql string contains spaces, equal signs and parenthesis, all of which are not allowed in a URL, so they need to be encoded.  curl can do this automatically with the  --data-urlencode option; since this option uses a  POST request by default we need to add the  --get option to switch it back to a  GET request. We also use the  --user option which instructs  curl to add the basic authentication header. Finally, we add the  --silent option to omit any progress information and the  --compressed option to save some bandwidth.</p><p> 与PR-Checkout相比的最大变化是Curl命令。我们使用JIRA搜索端点，该端点预计将为JQL（JIRA查询语言）字符串作为URL参数。在我的情况下，我对分配给我的博客项目的所有问题都很感兴趣，并将其标记为正在进行中。 JQL字符串包含空格，等于符号和括号，所有这些都不允许在URL中，因此需要编码它们。卷曲可以使用--data-urlencode选项自动执行此操作;由于此选项默认使用Post Post请求，因此我们需要添加--get选项将其切换回G获取请求。我们还使用-User选项，该选项指示CURL添加基本身份验证标题。最后，我们添加--Silent选项以省略任何进度信息和 - 构C抑制的选项以保存一些带宽。</p><p> We are then using the same technique as above to convert every array entry in the JSON response into a single row, separating the search string and the preview by a tab character and passing it to  fzf to allow the user to select an entry. The output of  fzf will be a row like  BLOG-1232. Add a verbose flag to the startup script&lt;tab&gt;{...preview part}. We use  cut to strip away the preview part of the row (by default,  cut uses  &lt;tab&gt; as a delimiter, and  -f1 instructs it to output the first field), resulting in  BLOG-1232. Add a verbose flag to the startup script. Then  sed replaces the first  .  by a tab character, and replaces any non-alphanumeric character by a  - (but preserving our newly introduced tab character) which yields  BLOG-1232&lt;tab&gt;Add-a-verbose-flag-to-the-startup-script. Finally,  awk takes the string, splits it at the tab character, converts the second part to lower case and puts both parts back together with  / as a separator.</p><p> 然后，我们使用与上述相同的技术将JSON响应中的每个数组条目转换为单行，将搜索字符串和标签字符分开并将其传递给FZF以允许用户选择一个条目。 FZF的输出将是博客-1232等行。将详细标志添加到启动脚本＆lt; tab＆gt; {...预览部分}。我们使用剪切来剥离行的预览部分（默认情况下，剪切使用＆lt;作为分隔符，-f1指示它输出第一个字段），导致博客-1232。将详细标志添加到启动脚本。然后sed取代了第一个。通过标签字符，并通过a  - （但保留我们的新引入的标签字符）替换任何非字母数字字符，该字符产生博客-1232＆lt; tab＆gt; add-a-renbose-flag-the-startup-script。最后，AWK拍摄字符串，将其拆分在标签字符上，将第二部分转换为小写，并将两个部件与/作为分隔符组合在一起。</p><p>   I presented four of my typical shell workflows and showed how they can be simplified with  fzf. The resulting functions range from a simple one-liner to more complex functions with API calls and non-trivial logic, but all of them have in common that they reduce a workflow of several steps to a single command without any parameters.</p><p>   我介绍了四个典型的shell工作流程，并显示了如何用fzf简化它们。由此产生的函数范围从一个简单的单行函数到更复杂的功能，具有API调用和非微不足道的逻辑，但所有这些都是共同的，因此它们在没有任何参数的情况下将几个步骤的工作流程降低到单个命令。</p><p> The exact workflows that I presented might not be relevant to you. But hopefully the general technique might be: try to observe how you add parameters to commands and see if this can be automated. The parameters could be files in a fixed location (like the  virtual environments), or they could be parameters that you can get through another command (like  git branches) or through an API (like the  pull request number or the  JIRA title).</p><p> 我呈现的确切工作流可能与您无关。但希望一般技术可能是：尝试观察你如何为命令添加参数，并查看是否可以自动化。参数可以是固定位置中的文件（如虚拟环境），或者它们可能是您可以通过另一个命令（如git分支）或通过API（如拉请求号码或JIRA标题）的参数。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://seb.jambor.dev/posts/improving-shell-workflows-with-fzf/">https://seb.jambor.dev/posts/improving-shell-workflows-with-fzf/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/改善/">#改善</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shell/">#shell</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>