<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用侧面频道攻击PROGCOMP Hacking a ProgComp with Side Channels</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hacking a ProgComp with Side Channels<br/>用侧面频道攻击PROGCOMP </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-07 05:36:10</div><div class="page_narrow text-break page_content"><p>As of this writing, I have the best score on  this Game of Codes problem by a factor of 10.  I cheated to get it. Here’s how.</p><p>就像这种撰写一样，我在这个代码游戏中获得了最佳分数。我欺骗了它。就是这样。</p><p> Game of Codes is a programming competition that follows the typical progcomp format. There are 10 problems, each with two or three test cases. When you submit your code, it is fed inputs via stdin, and writes solutions to stdout. Each correct answer earns you a point; the leaderboard ranks the submitted programs firstly by points, and secondly by the lowest elapsed time for your program to complete the test cases.</p><p> 代码游戏是一种编程竞争，遵循典型的progcomp格式。有10个问题，每个问题都有两个或三个测试用例。当您提交代码时，它通过STDIN输入输入，并将解决方案写入STDOUT。每个正确的答案都会让你成为一个观点;排行榜首先按积分排列所提交的程序，其次是您的程序完成测试用例的最低经过时间。</p><p> That last bit is important, because it means that the programmer  must not be allowed to see the test cases. If they could, it would be trivial to hard-code the correct answer for each test input. This isn’t a problem in progcomps like  Advent of Code, because they don’t score you based on execution time, only submission time. But when speed matters, gaining knowledge of the test inputs allows you to write the theoretically-optimal program for a given problem: read input, consult answer table, write output. Two syscalls and a few microseconds of array lookups.</p><p> 最后一点很重要，因为这意味着不允许程序员看到测试用例。如果他们可以，它将普遍普通代码每个测试输入的正确答案。这不是代码中的Progcomps中的问题，因为他们没有根据执行时间得分，只有提交时间。但是，当速度很重要时，获得测试输入的知识允许您为给定的问题编写理论上最佳程序：读取输入，请咨询答案表，写入输出。两个syscalls和几微秒的数组查找。</p><p> Now, Game of Codes tries very hard to hide the test inputs. They don’t allow you to see the output of your program; only whether it succeeded or failed. This prevents you from simply printing the test inputs to stdout. Furthermore, your program runs in a restricted environment: the filesystem is read-only, and network calls are blocked. So you can’t sneak the inputs out via HTTP request or other network-based means.</p><p> 现在，代码的游戏很难隐藏测试输入。他们不允许您查看程序的输出;只有它是否成功或失败了。这可以防止您只需将测试输入打印到STDOUT。此外，您的程序在受限制的环境中运行：文件系统是只读的，并且阻止了网络调用。因此，您无法通过HTTP请求或其他基于网络的方式潜入输入。</p><p> But one hole is left unplugged: the leaderboard lists the execution time of each submission. And that’s a side channel. Specifically, we can use a  timing attack to recover information about the test inputs, using only the recorded execution time of the program. This is the attack I used to achieve a (near-) optimal time on the “Invasion” problem linked above. But first, to understand the method, let’s look at a simpler problem.</p><p> 但是一个漏洞熄灭：排行榜列出了每个提交的执行时间。那是一个侧面频道。具体地，我们可以使用时序攻击来恢复有关测试输入的信息，仅使用程序的记录的执行时间。这是我用于在上面链接的“入侵”问题上实现（近）最佳时间的攻击。但首先，要了解方法，让我们来看看一个更简单的问题。</p><p>  Here’s the problem description for “Islands,” a program that is easy prey for the timing attack. When conducting the attack, we want to minimize the amount of information that we have to transmit. Notice that although the example input is fairly verbose, the example  output is a small set of small numbers. So in this case we will leak the output rather than the input. The distinction doesn’t matter much; either way, we’ll be able to construct our optimal solution.</p><p>  这是“岛屿”的问题描述，这是一个简单的时间攻击的程序。进行攻击时，我们希望最大限度地减少我们必须传输的信息量。请注意，虽然示例输入相当​​冗长，但示例输出是一组一小段少数。因此，在这种情况下，我们将泄漏输出而不是输入。区别并不重要;无论哪种方式，我们都可以构建我们的最佳解决方案。</p><p> First, we need to solve the problem, since the Game of Codes server only tells you the execution time of successful tests. Once we have a working program, we can establish baseline timings for each test case. My program ran each test case runs in about 30ms. We then introduce our leak code by adding a  sleep call. We’ll sleep for  n seconds, where  n is the value we want to leak, starting with the first output:</p><p> 首先，我们需要解决问题，因为代码服务器的游戏只能告诉您成功测试的执行时间。一旦我们有一个工作计划，我们就可以为每个测试用例建立基线时序。我的程序运行了大约30ms的每个测试用例。然后，我们通过添加睡眠呼叫来介绍我们的泄漏代码。我们将睡觉为n秒，其中n是我们想要泄漏的值，从第一个输出开始： </p><p>  When we push this code to the Game of Codes server, we get a response that looks like this (actual values changed):</p><p>当我们将此代码推到代码服务器的游戏时，我们得到一个如此如此的响应（实际值已更改）：</p><p> Compiling...&gt; go build -o runCompilation success in 267.644988msRunning examples...Example 1 success in 2.032274213sRunning tests...Test 1 success in 4.045206722sTest 2 success in 7.037433879s1 examples succeeded.2 tests succeeded in 14.082640601s.</p><p> 编译...＆gt; Go Build -o Runcompilation成功在267.644988MSRunning示例中</p><p> Boom, we just leaked our first outputs! Test 1 ran in 4 seconds, so its first output is 4; likewise, the first output of Test 2 is 7. The example ran in 2 seconds, so the first output should be a 2 – and we can confirm from the problem description that it is.</p><p> 繁荣，我们刚刚泄露了我们的第一个输出！测试1在4秒内运行，因此其第一个输出为4;同样，测试2的第一个输出为7.示例在2秒内运行，因此第一个输出应该是2  - 并且我们可以从问题描述中确认它是。</p><p> Now it’s just a matter of repeating this process for  output[1],  output[2], and so on. We’ll know when we’ve found all of them when the tests start failing – that means the program crashed due to accessing an index of  outputs that doesn’t exist. We can also check our progress as we go by overwriting the contents of  outputs with our leaked values before writing them to stdout. If our leaked values are incorrect, overwriting the actual values will cause the test to fail.</p><p> 现在，这只是重复输出[1]，输出[2]等的此过程的问题。我们会知道当测试开始失败时我们发现所有这些都有 - 这意味着由于访问不存在的输出索引而导致的程序崩溃。我们还可以通过在将泄漏值写入STDOUT之前通过覆盖输出的内容来查看我们的进度。如果我们的泄漏值不正确，则覆盖实际值会导致测试失败。</p><p> Once we know all the outputs, we need to tackle another problem: matching each input with its output. In other words, we need a way for our program to identify which input it’s processing. Unsurprisingly, we can leak this information the same way as before. In the case of “Islands,” the first number of the input is sufficient to distinguish between the test cases. But since the input numbers are large, we can’t multiply them by a full second like we did for the outputs – the test would take too long to run. Instead, we’ll sleep for  inputs[0] * time.Millisecond. But when we do this, we run into a new complication: variance. If the execution time varies by more than 1ms compared to our baseline, then our leaked value will be wrong. It could take quite a few tries to recover the correct input.</p><p> 一旦我们知道所有输出，我们需要解决另一个问题：将每个输入与其输出匹配。换句话说，我们需要一种方法来为我们的程序确定哪个输入它正在处理。不出所料，我们可以与以前相同的方式泄漏此信息。在“岛屿”的情况下，第一个输入的输入足以区分测试用例。但由于输入数字很大，我们不能将它们乘以一个完整的第二次，就像我们为输出所做的那样 - 测试需要太长而运行。相反，我们将睡觉为输入[0] * time.millisecond。但是当我们这样做时，我们遇到了一个新的并发症：方差。如果执行时间与我们的基线相比有超过1ms，则我们泄露的值将是错误的。恢复正确的输入可能需要很多尝试。</p><p> Fortunately, we can improve upon this by using a two-stage approach. First, we’ll use a 1ms multiplier to get an “initial guess” for the input value. Then we’ll run the program again, but this time subtract our guess from the input, and multiply the remainder by 1s. For example, let’s say our baseline execution time is 26ms. On our first run, we multiply by 1ms, and the execution time is 854ms. That gives us an initial guess of 828. On the second run, we subtract 828 from  input and multiply by 1s, resulting in an execution time of 4.024s. This tells us (with high confidence) that the actual value is 828 + 4 = 832.</p><p> 幸运的是，我们可以通过使用两阶段方法来改善这一点。首先，我们将使用1ms乘数来获得输入值的“初始猜测”。然后我们将再次运行该程序，但此时间从输入中减去我们的猜测，并将其余乘以1s。例如，假设我们的基线执行时间为26ms。在我们第一次运行时，我们乘以1ms，执行时间为854ms。这为我们提供了初步猜测828.在第二个运行中，我们从输入中减去828，乘以1S，导致执行时间为4.024s。这告诉我们（具有高置信度），实际值为828 + 4 = 832。</p><p> Once we’ve matched each test input to its outputs, we can write the “optimal program” (actual values changed):</p><p> 一旦我们将每个测试输入与其输出匹配，我们就可以编写“最佳程序”（改变的实际值）： </p><p> func main() {  // read 4 bytes to determine which test we&#39;re running fst :=  make([] ,  4) os.Stdin.Read(fst[:])  switch  (fst) {  case  &#34;3000&#34;:  // Example os.Stdout.WriteString( &#34;2\n1\n0\n4\n3\n5\n&#34;)  case  &#34;1234&#34;:  // Test 1 os.Stdout.WriteString( &#34;1\n2\n3\n4\n5\n6\n7\n&#34;)  case  &#34;5678 &#34;:  // Test2 os.Stdout.WriteString( &#34;1\n2\n3\n4\n5\n6\n7\n&#34;) }}</p><p>func main（）{//读取4个字节以确定我们＆＃39;重新运行fst：= make（[]，4）os.stdin.read（fst [：]）开关（fst）{case＆＃34 ; 3000＆＃34 ;: //示例os.stdout.writeString（＆＃34; 2 \ n1 \ n0 \ n4 \ n3 \ n5 \ n＆＃34;）案例＆＃34; 1234＆＃34;：//测试1 os.stdout.writeString（＆＃34; 1 \ n2 \ n3 \ n4 \ n5 \ n6 \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n7;）案例＆＃34; 5678＆＃34 ;: // test2 os.stdout.writestring（＆ ＃34; 1 \ n2 \ n3 \ n4 \ n5 \ n6 \ n7 \ n＆＃34;）}}</p><p> This performs quite well – but surprisingly, it isn’t fast enough to top the scoreboard. I’m not sure why this is, but somehow the top program runs 5ms faster than this code. Fortunately, the same is not true of…</p><p> 这表现得非常好 - 但令人惊讶的是，它并不足够快，以获得记分牌。我不确定为什么，但不知何故，顶部程序比这个代码快5毫秒。幸运的是，......的不属于......</p><p>  This problem presents some new challenges, but I knew that I could get the top leaderboard position if I solved it. When I started, the fastest program ran in about 500ms. The nice thing about these optimal programs is that their speed is independent of the computational complexity of the actual problem; the code is always just a lookup table. So I expected that I could submit a solution that ran approximately as fast as my Islands solution: 30ms.</p><p>  这个问题存在一些新的挑战，但如果我解决了它，我知道我可以得到顶级排行榜。当我开始时，最快的程序在大约500ms中运行。关于这些最佳程序的好处是它们的速度与实际问题的计算复杂性无关;代码始终只是查找表。所以我期望我可以提交一个解决方案，即迅速作为我的岛屿解决方案：30ms。</p><p> The  problem description indicates that this problem boils down to computing a bunch of hashes and subsequently matching messages to hashes in order to reconstruct the original “message chain.” I wrote a straightforward (unoptimized) solution, which ran in about 25ms for the first two test inputs, and 1.5s for the third. Then I set about recovering the outputs.</p><p> 问题描述表明，此问题归结为计算一堆哈希和随后将消息与哈希匹配，以便重建原始的“消息链”。我写了一个直接的（未优化的）解决方案，在前两个测试输入中运行了大约25米，并为第三个测试输入1.5s。然后我设置恢复输出。</p><p> The expected output for this problem is a bunch of concatenated message strings. Recovering all that string data would be tedious, but fortunately there’s an easy way to compress it. Since each message comes from an element in the input array, we can simply leak the index of each message, rather than the messages themselves. To check whether this was reasonable, the first thing I leaked was the number of messages in each test output. The first test had 4 messages; the second had 19; and the third had 501. I could recover the first two manually, but no way was I going to leak 501 values by hand. To compound the problem, the values I intended to leak were large, which meant that there’s no way I could multiply them by 1s; I would need to use the guess-and-check strategy mentioned earlier for every value. This called for some automation.</p><p> 此问题的预期输出是一堆连接的消息字符串。恢复所有字符串数据将是乏味的，但幸运的是，有一种简单的方法来压缩它。由于每个消息来自输入阵列中的一个元素，因此我们可以简单地泄露每个消息的索引，而不是消息本身。要检查这是否合理，我泄露的第一件事是每个测试输出中的消息数。第一次测试有4条消息;第二个有19个;第三个有501.我可以手动恢复前两位，但没有办法我会用手泄漏501个价值。为了复制问题，我打算泄漏的值很大，这意味着我无法将它们乘以1s;我需要使用前面提到的猜测和检查策略。这呼吁某些自动化。</p><p> I wrote a small Go program that repeatedly generated new code, pushed it to the Game of Codes server, parsed the response, and used the timing information to generate the next iteration. The generated code included a check so that it would fail if it guessed the wrong value; the observer could then notice this failure, revert the last commit, and attempt to guess the value again. This meant I could mostly let the program run unsupervised.</p><p> 我写了一个小型程序，重复生成的新代码，将其推到代码服务器的游戏，解析响应，并使用时间信息来生成下一次迭代。生成的代码包括一个检查，以便如果猜测错误值，它会失败;然后，观察者可以注意到此故障，还原最后的提交，并尝试再次猜测该值。这意味着我最能让程序运行无监督。</p><p> But when I fired up the program, it quickly became apparent that the frequency of these “retries” was unacceptably high. My baseline execution time of 1.5s had significant variance, causing lots of incorrect guesses even when using the two-phase guess-and-check approach. Tests also took a long time to run – sometimes as long as 50 seconds – meaning that a wrong guess could cause a delay of over 2 minutes. I needed to refine my approach.</p><p> 但是当我解雇该计划时，很快就会变得显而易见的是，这些“重试”的频率是不可接受的。我的基线执行时间为1.5s具有显着的方差，即使使用两阶段猜测和检查方法，也会导致许多不正确的猜测。测试也花了很长时间才能运行 - 有时只要50秒 - 这意味着错误的猜测可能会导致延迟超过2分钟。我需要改进我的方法。 </p><p> After a lot of head-scratching, I had an epiphany that in retrospect seemed embarrassingly obvious. By padding the baseline execution time, I could reduce the variance, allowing me to decrease the sleep multiplier. In code:</p><p>经过大量的头部划伤，我有一个昙花一现，回想起来似乎令人尴尬的明显。通过填充基线执行时间，我可以减少方差，让我减少睡眠倍增器。在代码：</p><p> func main() { start := time.Now()  // ... solution code goes here ... time.Sleep( 5 * time.Second - time.Since(start)) time.Sleep(sleepMultiplier * leakedValue)}</p><p> func main（）{start：= time.now（）// ...解决方案代码进入这里...时间。leep（5 * time.second  -  time.since（start））time.sleep（sleepMultiplier * liftedValue） }</p><p> I measured, and indeed, this approach clamped the variance to a few milliseconds. As a result, I was able to drop the sleep multiplier to 10ms and do away with guess-and-check; most of the time, the first guess was accurate enough that a second pass wasn’t needed. I gleefully deployed this new code and watched it chug away. This was a slow process, since the Game of Codes server was rate-limited to enforce a 10s delay between each push. But at 15s per value, it only took two hours to calculate all 501.</p><p> 我测量了，实际上，这种方法将方差夹在几毫秒。因此，我能够将睡眠倍增器放入10毫秒并使用猜测和检查;大多数时候，第一次猜测足够准确，即不需要第二次通过。我荣耀地部署了这段新代码并观看了它的跳闸。这是一个缓慢的过程，因为代码服务器的游戏是限制性的，因为在每个推动之间强制实施10s延迟。但在每价值15岁时，只需两个小时即可计算所有501。</p><p> Once all the values were calculated, I constructed a near-optimal solution for the problem (actual values changed):</p><p> 一旦计算所有值，我构建了一个问题的近最优解（实际值改变）：</p><p> var Example = [] { 2,  1,  3} var Test1 = [] { 1,  2,  3,  4} var Test2 = [] { 1,  2,  3, ...}  // 16 values omitted var Test3 = [] { 1,  2,  3, ...}  // 498 values omitted func main() {  var js [][ 2]  json.NewDecoder(os.Stdin).Decode(&amp;js)  var indices []   switch  len(js) {  case  6: indices = Example  case  1: indices = Test1  case  2: indices = Test2  case  3: indices = Test3 } messages :=  make([] ,  len(indices))  for i :=  range indices { messages[i] = js[indices[i]][ 1] } os.Stdout.WriteString(strings.Join(messages,  &#34; &#34;))}</p><p> var示例= [] {2,1，3} var test1 = [] {1,2,3,4} var test2 = [] {1,2,3，...} // 16值省略var test3 = [] {1,2,3，...} // 498值省略func main（）{var js [] [2] json.newdecoder（os.stdin）.decode（＆amp; js）var indices []开关len（js）{case 6：indices =示例=示例案例1：indices = test1 case 2：indices = test2 case 3：indices = test3}消息：= make（[]，len（indices））用于i：=范围索引{消息[i] = js [indices [i]] [1]}} os.stdout.writeString（strings.join（消息，＆＃34;＆＃34;））}</p><p>  &gt; go build -o runCompilation success in 210.389187msRunning examples...Example 1 success in 15.855545msRunning tests...Test 1 success in 14.883978msTest 2 success in 15.048268msTest 3 success in 16.664773ms1 examples succeeded.3 tests succeeded in 46.597019ms.</p><p>  ＆gt; Go Build -o Runcompilation成功在210.389187MSRunning示例中取得了成功......示例1在15.855545MsRunning测试中取得成功......测试1成功14.883978MSTEST 2成功21.048268MST最多的成功3次成功在16.664773MS1中取得了成功，其中26.597019ms成功了。</p><p> SUCCESS! We lost some time here due to slow JSON parsing, but this solution is still 10x faster than anyone else’s!</p><p> 成功！由于json解析慢，我们在这里丢失了一段时间，但这种解决方案仍然比其他任何人都快10倍！ </p><p>  Pulling off this hack was pretty fun. People seem to be split on whether it counts as cheating or not. It’s true that I only used publically-available information – I didn’t exploit a buffer overflow in the server code or anything like that – but this is obviously not how the problems were intended to be solved. I feel a bit guilty about stealing the top leaderboard position from someone who spent a lot of time optimizing their code. But hey, I invested a fair amount of time in my approach too, so… it’s a wash. For what it’s worth, I don’t plan to execute this attack on any other Game of Codes problems, and I discourage anyone else from doing so. I hope the Game of Codes team found my antics amusing (rather than threatening), and I hope this postpiqued your interest in timing attacks and other side channels.</p><p>拉开这个黑客很有趣。人们似乎是拆分它是否被视为作弊。确实，我只使用公开可用的信息 - 我没有利用服务器代码中的缓冲区溢出或类似的东西 - 但这显然不是如何解决问题。我觉得有点愧疚地从花费大量时间优化代码的人那里偷走顶级排行榜的罪名。但是，嘿，我也在我的方法中投入了相当多的时间，所以......这是一个洗。对于它的价值，我不打算对任何其他代码游戏执行这次攻击，我劝阻其他人这样做。我希望Codes团队的比赛发现我的滑稽动态有趣（而不是威胁），我希望这会发现您对时序攻击和其他侧渠道的兴趣。</p><p>  Update: The Game of Codes team removed my submission from the leaderboard,but it is still viewable  here. They also posted an announcementclarifying that hard-coded solutions will not be eligible to win prizes. Isupport their decision.</p><p>  更新：代码游戏团队从排行榜中删除了我的提交，但此处仍然可见。他们还发布了一项公告，宣布了解硬编码的解决方案将没有资格赢得奖品。 isupport他们的决定。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lukechampine.com/progcomp.html">https://lukechampine.com/progcomp.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/攻击/">#攻击</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/progcomp/">#progcomp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>