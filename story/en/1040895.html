<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>无锁编程简介 An Introduction to Lock-Free Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An Introduction to Lock-Free Programming<br/>无锁编程简介 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-20 23:39:13</div><div class="page_narrow text-break page_content"><p>Lock-free programming is a challenge, not just because of the complexity of the task itself, but because of how difficult it can be to penetrate the subject in the first place.</p><p>无锁编程是一个挑战，这不仅是因为任务本身很复杂，而且还因为一开始很难穿透该主题。</p><p>  I was fortunate in that my first introduction to lock-free (also known as lockless) programming was Bruce Dawson’s excellent and comprehensive white paper,  Lockless Programming Considerations. And like many, I’ve had the occasion to put Bruce’s advice into practice developing and debugging lock-free code on platforms such as the Xbox 360.</p><p>  幸运的是，我对无锁（也称为无锁）编程的第一个介绍是Bruce Dawson出色而全面的白皮书《无锁编程注意事项》。和许多人一样，我曾有机会将布鲁斯的建议付诸实践，以便在Xbox 360等平台上开发和调试无锁代码。</p><p>  Since then, a lot of good material has been written, ranging from abstract theory and proofs of correctness to practical examples and hardware details. I’ll leave a list of references in the footnotes. At times, the information in one source may appear orthogonal to other sources: For instance, some material assumes  sequential consistency, and thus sidesteps the memory ordering issues which typically plague lock-free C/C++ code. The new  C++11 atomic library standard throws another wrench into the works, challenging the way many of us express lock-free algorithms.</p><p>  从那时起，已经写了很多好的材料，从抽象理论和正确性证明到实际示例和硬件细节。我将在脚注中留下参考文献列表。有时，一个来源中的信息可能看起来与其他来源正交：例如，某些材料假定了顺序一致性，因此回避了通常困扰无锁C / C ++代码的内存排序问题。新的C ++ 11原子库标准又使工作陷入困境，挑战了我们许多人表达无锁算法的方式。</p><p>  In this post, I’d like to re-introduce lock-free programming, first by defining it, then by distilling most of the information down to a few key concepts. I’ll show how those concepts relate to one another using flowcharts, then we’ll dip our toes into the details a little bit. At a minimum, any programmer who dives into lock-free programming should already understand how to write correct multithreaded code using mutexes, and other high-level synchronization objects such as semaphores and events.</p><p>  在本文中，我想重新引入无锁编程，首先是对其进行定义，然后将大部分信息精简为几个关键概念。我将使用流程图说明这些概念之间的关系，然后我们将脚趾深入细节。至少，任何从事无锁编程的程序员都应该已经了解如何使用互斥锁以及信号和事件等其他高级同步对象编写正确的多线程代码。</p><p>    People often describe lock-free programming as programming without mutexes, which are also referred to as  locks. That’s true, but it’s only part of the story. The generally accepted definition, based on academic literature, is a bit more broad. At its essence, lock-free is a property used to describe some code, without saying too much about how that code was actually written.</p><p>    人们通常将无锁编程描述为没有互斥锁的编程，也称为锁。没错，但这只是故事的一部分。根据学术文献，公认的定义要宽泛一些。从本质上讲，无锁是用于描述某些代码的属性，而无需过多地讲述该代码的实际编写方式。</p><p>   Basically, if some part of your program satisfies the following conditions, then that part can rightfully be considered lock-free. Conversely, if a given part of your code doesn’t satisfy these conditions, then that part is not lock-free.</p><p>   基本上，如果程序的某些部分满足以下条件，则可以合理地认为该部分是无锁的。相反，如果代码的给定部分不满足这些条件，则该部分不是无锁的。</p><p>    In this sense, the  lock in lock-free does not refer directly to mutexes, but rather to the possibility of “locking up” the entire application in some way, whether it’s deadlock, livelock – or even due to hypothetical thread scheduling decisions made by your worst enemy. That last point sounds funny, but it’s key. Shared mutexes are ruled out trivially, because as soon as one thread obtains the mutex, your worst enemy could simply never schedule that thread again. Of course, real operating systems don’t work that way – we’re merely defining terms.</p><p>    从这种意义上讲，无锁的锁定并不直接指互斥，而是指以某种方式“锁定”整个应用程序的可能性，无论是死锁，活动锁，甚至是由假设的线程调度决定造成的。你最大的敌人最后一点听起来很有趣，但这很关键。共享互斥量很少被排除，因为一旦一个线程获得了互斥量，您最大的敌人就根本再也不会调度该线程了。当然，真正的操作系统不能那样工作-我们只是在定义术语。 </p><p>  Here’s a simple example of an operation which contains no mutexes, but is still not lock-free. Initially, X = 0. As an exercise for the reader, consider how two threads could be scheduled in a way such that neither thread exits the loop.</p><p>这是一个简单的操作示例，其中不包含互斥锁，但仍然不是无锁的。最初，X =0。作为读者的练习，请考虑如何调度两个线程，以使两个线程都不退出循环。</p><p>    Nobody expects a large application to be entirely lock-free. Typically, we identify a specific set of lock-free operations out of the whole codebase. For example, in a lock-free queue, there might be a handful of lock-free operations such as  push,  pop, perhaps  isEmpty, and so on.</p><p>    没有人期望大型应用程序完全没有锁。通常，我们从整个代码库中识别出一组特定的无锁操作。例如，在无锁队列中，可能会有少量的无锁操作，例如推，弹出，也许为isEmpty等。</p><p>  Herlihy &amp; Shavit, authors of  The Art of Multiprocessor Programming , tend to express such operations as class methods, and offer the following succinct definition of lock-free (see  slide 150): “In an infinite execution, infinitely often some method call finishes.” In other words, as long as the program is able to keep  calling those lock-free operations, the number of  completed calls keeps increasing, no matter what. It is algorithmically impossible for the system to lock up during those operations.</p><p>  赫利希＆amp; Shavit是《多处理器编程艺术》的作者，倾向于将此类操作表示为类方法，并提供了以下简洁的无锁定义（请参见幻灯片150）：“在无限执行中，无数次通常会完成一些方法调用。”换句话说，只要程序能够继续调用那些无锁操作，无论如何，已完成的调用数量都会不断增加。从算法上讲，系统在这些操作期间无法锁定。</p><p>  One important consequence of lock-free programming is that if you suspend a single thread, it will never prevent other threads from making progress, as a group, through their own lock-free operations. This hints at the value of lock-free programming when writing interrupt handlers and real-time systems, where certain tasks must complete within a certain time limit, no matter what state the rest of the program is in.</p><p>  无锁编程的一个重要结果是，如果挂起单个线程，它将永远不会阻止其他线程作为一个整体通过它们自己的无锁操作取得进展。这在编写中断处理程序和实时系统时暗示了无锁编程的价值，其中无论程序其余部分处于什么状态，某些任务都必须在一定时间内完成。</p><p>  A final precision: Operations that are  designed to block do not disqualify the algorithm. For example, a queue’s pop operation may intentionally block when the queue is empty. The remaining codepaths can still be considered lock-free.</p><p>  最后的精度：设计为阻止的操作不会使算法失去资格。例如，当队列为空时，队列的弹出操作可能会故意阻塞。其余代码路径仍然可以认为是无锁的。</p><p>    It turns out that when you attempt to satisfy the non-blocking condition of lock-free programming, a whole family of techniques fall out: atomic operations, memory barriers, avoiding the ABA problem, to name a few. This is where things quickly become diabolical.</p><p>    事实证明，当您尝试满足无锁编程的非阻塞条件时，就会出现一整套技术：原子操作，内存障碍，避免ABA问题，仅举几例。在这里，事物迅速变得令人着迷。</p><p>  So how do these techniques relate to one another? To illustrate, I’ve put together the following flowchart. I’ll elaborate on each one below.</p><p>  那么这些技术如何相互联系？为了说明，我整理了以下流程图。我将在下面详细说明。 </p><p>      Atomic operations are ones which manipulate memory in a way that appears indivisible: No thread can observe the operation half-complete. On modern processors, lots of operations are already atomic. For example, aligned reads and writes of simple types are usually atomic.</p><p>原子操作是一种以似乎不可分割的方式操作内存的操作：没有线程可以观察到该操作是半完成的。在现代处理器上，许多操作已经是原子的。例如，简单类型的对齐读取和写入通常是原子的。</p><p>  Read-modify-write (RMW) operations go a step further, allowing you to perform more complex transactions atomically. They’re especially useful when a lock-free algorithm must support multiple writers, because when multiple threads attempt an RMW on the same address, they’ll effectively line up in a row and execute those operations one-at-a-time. I’ve already touched upon RMW operations in this blog, such as when implementing a  lightweight mutex, a  recursive mutex and a  lightweight logging system.</p><p>  读-修改-写（RMW）操作更进一步，使您能够自动执行更复杂的事务。当无锁算法必须支持多个编写器时，它们特别有用，因为当多个线程在同一地址上尝试RMW时，它们将有效地连续排成一行并一次执行这些操作。我已经在此博客中介绍了RMW操作，例如在实现轻量级互斥锁，递归互斥量和轻量级日志记录系统时。</p><p>  Examples of RMW operations include   _InterlockedIncrement on Win32,   OSAtomicAdd32 on iOS, and   std::atomic&lt;int&gt;::fetch_add in C++11. Be aware that the C++11 atomic standard does not guarantee that the implementation will be lock-free on every platform, so it’s best to know the capabilities of your platform and toolchain. You can call   std::atomic&lt;&gt;::is_lock_free to make sure.</p><p>  RMW操作的示例包括Win32上的_InterlockedIncrement，iOS上的OSAtomicAdd32以及C ++ 11中的std :: atomic  :: fetch_add。请注意，C ++ 11原子标准不能保证该实现在每个平台上都是无锁的，因此最好了解您的平台和工具链的功能。您可以调用std :: atomic＆lt;＆gt; :: is_lock_free来确保。</p><p>  Different CPU families  support RMW in different ways. Processors such as PowerPC and ARM expose  load-link/store-conditional instructions, which effectively allow you to implement your own RMW primitive at a low level, though this is not often done. The common RMW operations are usually sufficient.</p><p>  不同的CPU系列以不同的方式支持RMW。诸如PowerPC和ARM之类的处理器公开了加载链接/存储条件指令，这些指令可以有效地使您在较低的级别上实现自己的RMW原语，尽管这种做法并不经常执行。普通的RMW操作通常就足够了。</p><p>  As illustrated by the flowchart, atomic RMWs are a necessary part of lock-free programming even on single-processor systems. Without atomicity, a thread could be interrupted halfway through the transaction, possibly leading to an inconsistent state.</p><p>  如该流程图所示，即使在单处理器系统上，原子RMW也是无锁编程的必要部分。如果没有原子性，线程可能会在事务进行到一半时被中断，从而可能导致状态不一致。</p><p>    Perhaps the most often-discussed RMW operation is  compare-and-swap (CAS). On Win32, CAS is provided via a family of intrinsics such as   _InterlockedCompareExchange. Often, programmers perform compare-and-swap in a loop to repeatedly attempt a transaction. This pattern typically involves copying a shared variable to a local variable, performing some speculative work, and attempting to publish the changes using CAS:</p><p>    也许最经常讨论的RMW操作是比较交换（CAS）。在Win32上，通过诸如_InterlockedCompareExchange之类的内部函数家族提供CAS。通常，程序员在循环中执行比较和交换操作以重复尝试事务。这种模式通常涉及将共享变量复制到局部变量，执行一些推测性工作，并尝试使用CAS发布更改：</p><p>  void LockFreeQueue::push(Node* newHead){  for (;;) {  // Copy a shared variable (m_Head) to a local. Node* oldHead = m_Head;  // Do some speculative work, not yet visible to other threads. newHead-&gt;next = oldHead;  // Next, attempt to publish our changes to the shared variable.  // If the shared variable hasn&#39;t changed, the CAS succeeds and we return.  // Otherwise, repeat.  if (_InterlockedCompareExchange(&amp;m_Head, newHead, oldHead) == oldHead)  return; }}</p><p>  void LockFreeQueue :: push（Node * newHead）{  为（;;） {  //将共享变量（m_Head）复制到本地。 节点* oldHead = m_Head;  //做一些推测性的工作，其他线程还看不到。 newHead-＆gt; next = oldHead;  //接下来，尝试将我们的更改发布到共享变量。  //如果共享变量未更改，则CAS成功并返回。  //否则，请重复。  如果（_InterlockedCompareExchange（＆m_Head，newHead，oldHead）== oldHead）  返回; }} </p><p>  Such loops still qualify as lock-free, because if the test fails for one thread, it means it must have succeeded for another – though some architectures offer a  weaker variant of CAS where that’s not necessarily true. Whenever implementing a CAS loop, special care must be taken to avoid the  ABA problem.</p><p>这样的循环仍然可以认为是无锁的，因为如果一个线程的测试失败，则意味着它必须在另一个线程上成功-尽管某些体系结构提供了较弱的CAS变体，但不一定如此。每当实现CAS循环时，都必须特别注意避免ABA问题。</p><p>    Sequential consistency means that all threads agree on the order in which memory operations occurred, and that order is consistent with the order of operations in the program source code. Under sequential consistency, it’s impossible to experience memory reordering shenanigans like  the one I demonstrated in a previous post.</p><p>    顺序一致性意味着所有线程都同意发生内存操作的顺序，并且该顺序与程序源代码中的操作顺序一致。在顺序一致性下，不可能像我在上一篇文章中演示的那样经历内存重新排序的恶作剧。</p><p>  A simple (but obviously impractical) way to achieve sequential consistency is to disable compiler optimizations and force all your threads to run on a single processor. A processor never sees its own memory effects out of order, even when threads are pre-empted and scheduled at arbitrary times.</p><p>  一种实现顺序一致性的简单（但显然不切实际）的方法是禁用编译器优化，并强制所有线程在单个处理器上运行。即使线程在任意时间被抢占和调度，处理器也永远不会看到自己的内存影响。</p><p>  Some programming languages offer sequentially consistency even for optimized code running in a multiprocessor environment. In C++11, you can declare all shared variables as C++11 atomic types with default memory ordering constraints. In Java, you can mark all shared variables as  volatile. Here’s the example from my  previous post, rewritten in C++11 style:</p><p>  某些编程语言甚至可以为在多处理器环境中运行的优化代码提供顺序一致性。在C ++ 11中，可以将所有共享变量声明为具有默认内存排序约束的C ++ 11原子类型。在Java中，可以将所有共享变量标记为volatile。这是我上一篇文章的示例，该示例以C ++ 11样式重写：</p><p>  std::atomic&lt; int&gt; X( 0), Y( 0); int r1, r2; void thread1(){ X.store( 1); r1 = Y.load();} void thread2(){ Y.store( 1); r2 = X.load();}</p><p>  std :: atomic＆lt; int＆gt; X（0），Y（0）; int r1，r2; 无效thread1（）{ X.store（1）; r1 = Y.load（）;} 无效thread2（）{ Y.store（1）; r2 = X.load（）;}</p><p>  Because the C++11 atomic types guarantee sequential consistency, the outcome r1 = r2 = 0 is impossible. To achieve this, the compiler outputs additional instructions behind the scenes – typically memory fences and/or RMW operations. Those additional instructions may make the implementation less efficient compared to one where the programmer has dealt with memory ordering directly.</p><p>  因为C ++ 11原子类型保证顺序一致性，所以结果r1 = r2 = 0是不可能的。为此，编译器会在后台输出其他指令-通常是内存围栏和/或RMW操作。与程序员直接处理内存排序的指令相比，那些额外的指令可能会使实现效率降低。</p><p>    As the flowchart suggests, any time you do lock-free programming for multicore (or any  symmetric multiprocessor), and your environment does not guarantee sequential consistency, you must consider how to prevent  memory reordering.</p><p>    如流程图所示，每当您对多核（或任何对称多处理器）进行无锁编程，并且您的环境不能保证顺序一致性时，您必须考虑如何防止内存重新排序。 </p><p>  On today’s architectures, the tools to enforce correct memory ordering generally fall into three categories, which prevent both  compiler reordering and  processor reordering:</p><p>在当今的体系结构上，用于执行正确的内存排序的工具通常分为三类，这既阻止了编译器的重新排序，也阻止了处理器的重新排序：</p><p>  A lightweight sync or fence instruction, which I’ll talk about in  future posts;</p><p>  轻量级同步或防护说明，我将在以后的文章中讨论；</p><p>  Acquire semantics prevent memory reordering of operations which follow it in program order, and release semantics prevent memory reordering of operations preceding it. These semantics are particularly suitable in cases when there’s a producer/consumer relationship, where one thread publishes some information and the other reads it. I’ll also talk about this more in a  future post.</p><p>  获取语​​义可防止按照程序顺序对其后面的操作进行内存重新排序，而释放语义则可防止对其之前的操作进行内存重新排序。这些语义特别适用于存在生产者/消费者关系的情况，其中一个线程发布一些信息，而另一个线程读取它。在以后的文章中，我还将对此进行更多讨论。</p><p>    Different CPU families have different habits when it comes to memory reordering. The rules are documented by each CPU vendor and followed strictly by the hardware. For instance, PowerPC and ARM processors can change the order of memory stores relative to the instructions themselves, but normally, the x86/64 family of processors from Intel and AMD do not. We say the former processors have a more  relaxed memory model.</p><p>    在内存重新排序方面，不同的CPU系列具有不同的习惯。每个CPU供应商都记录了这些规则，并严格遵循了硬件。例如，PowerPC和ARM处理器可以相对于指令本身更改内存存储的顺序，但是通常，英特尔和AMD的x86 / 64系列处理器不会。我们说以前的处理器具有更宽松的内存模型。</p><p>  There’s a temptation to abstract away such platform-specific details, especially with C++11 offering us a standard way to write portable lock-free code. But currently, I think most lock-free programmers have at least some appreciation of platform differences. If there’s one key difference to remember, it’s that at the x86/64 instruction level, every load from memory comes with acquire semantics, and every store to memory provides release semantics – at least for non-SSE instructions and non-write-combined memory. As a result, it’s been common in the past to write lock-free code which works on x86/64, but  fails on other processors.</p><p>  倾向于抽象出这些特定于平台的细节，尤其是C ++ 11为我们提供了编写可移植的无锁代码的标准方法。但是目前，我认为大多数无锁程序员至少对平台差异有所了解。如果需要记住一个关键的区别，那就是在x86 / 64指令级别上，每次从内存中加载都会获取语义，并且每次存储到内存都将提供释放语义–至少对于非SSE指令和非写组合内存。因此，过去通常会编写可在x86 / 64上运行但在其他处理器上无法运行的无锁代码。</p><p>  If you’re interested in the hardware details of how and why processors perform memory reordering, I’d recommend Appendix C of  Is Parallel Programming Hard. In any case, keep in mind that memory reordering can also occur due to compiler reordering of instructions.</p><p>  如果您对处理器如何以及为什么执行内存重新排序的硬件详细信息感兴趣，我建议您阅读《并行编程难》的附录C。无论如何，请记住，由于编译器对指令的重新排序也可能导致内存重新排序。</p><p>  In this post, I haven’t said much about the practical side of lock-free programming, such as: When do we do it? How much do we really need? I also haven’t mentioned the importance of validating your lock-free algorithms. Nonetheless, I hope for some readers, this introduction has provided a basic familiarity with lock-free concepts, so you can proceed into the additional reading without feeling too bewildered. As usual, if you spot any inaccuracies, let me know in the comments.</p><p>  在这篇文章中，我没有对无锁编程的实际方面说太多，例如：什么时候做？我们真正需要多少？我也没有提到验证无锁算法的重要性。尽管如此，我希望对某些读者来说，本入门对无锁概念有基本的了解，因此您可以继续阅读更多内容而不会感到困惑。与往常一样，如果您发现任何不正确之处，请在评论中告诉我。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">https://preshing.com/20120612/an-introduction-to-lock-free-programming/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lock/">#lock</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/无锁/">#无锁</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>