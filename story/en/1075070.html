<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用数据记录喝酒Drinking with Datalog</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Drinking with Datalog<br/>用数据记录喝酒</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 04:08:01</div><div class="page_narrow text-break page_content"><p>$ head facts/recipesmartini &lt;- london dry ginmartini &lt;- dry vermouthdaiquiri &lt;- light rumdaiquiri &lt;- lime juicedaiquiri &lt;- simple syrupmargarita &lt;- blanco tequila or reposado tequilamargarita &lt;- lime juicemargarita &lt;- orange liqueurmargarita &lt;- lime wedge...</p><p>$head facts/Recipes马提尼&lt；-伦敦干吉尼马提尼&lt；-干苦艾酒轻拉姆代基里&lt；-酸橙汁白兰地&lt；-简单糖浆玛格丽塔&lt；-布兰科龙舌兰或雷帕萨多龙舌兰&lt；-酸橙汁玛格利塔&lt；-橙汁玛格丽塔&lt；-石灰楔。。。</p><p>   Gosh, that’s not very many. What could I add to my bar to expand my options?</p><p>天哪，不多。我可以在吧台上添加什么来扩展我的选择？</p><p> $ cat results/shopping-listlondon dry gin -&gt; gimletlondon dry gin -&gt; martinichampagne -&gt; airmailcognac -&gt; between-the-sheetssherry -&gt; sherry-cobblerrhum agricole -&gt; ti-punch</p><p>$cat结果/购物清单伦敦干杜松子酒-&gt；吉姆莱特伦敦杜松子酒-&gt；martinichampagne-&gt；airmailcognac-&gt；在床单之间Hery-&gt；雪莉柯布勒胡姆阿格里科尔-&gt；钛冲压机</p><p>  No you’re wrong it’s smart. Take a closer look at that  Daiquiri: the recipe calls for lime juice, but we don’t have lime juice in our bar. We only have lime. So why does it show up as mixable?</p><p>不，你错了，这很聪明。仔细看一看Daiquiri：菜谱上要求加酸橙汁，但我们的酒吧里没有酸橙汁。我们只有酸橙。那么为什么它会显示为可混合的呢？</p><p> I’m so glad you asked. These results are generated by something called  Mixologician, a tiny Datalog program I wrote.</p><p>我很高兴你这么问。这些结果是由我编写的一个名为Mixologician的小型数据记录程序生成的。</p><p> And Mixologician  knows some rules. It knows that limes make lime juice – and lime wedge, and lime zest, etc. It even knows that  lime zest plus sugar makes lime cordial – so it knows that we’re only one ingredient away from being able to make a  Gimlet, even though we don’t  technically have a single ingredient that the drink calls for.</p><p>调酒师知道一些规则。它知道酸橙可以制成酸橙汁——酸橙楔、酸橙皮等等。它甚至知道酸橙皮加糖可以制成酸橙热饮——所以它知道，我们离制作小金环只有一种原料，尽管从技术上讲，我们没有一种饮料需要的单一原料。</p><p>   I like cocktails. Once upon a time, I liked to go to restaurants and order cocktails. But for  some reason I haven’t been going to restaurants for a while, and instead I’ve been making cocktails at home.</p><p>我喜欢鸡尾酒。从前，我喜欢去餐馆点鸡尾酒。但由于某种原因，我有一段时间没去餐馆了，而是在家里做鸡尾酒。</p><p> But I don’t want to mix the same cocktails every time. A big part of what I enjoyed about the restaurant-cocktail-ordering experience was the variety: every fancy hipster restaurant I used to frequent had its own cocktail menu – it’s own unique set of drinks, full of ingredients I had never heard of.</p><p>但我不想每次都混合同样的鸡尾酒。我喜欢这家餐厅的鸡尾酒点餐体验的很大一部分是多样性：我经常光顾的每一家时髦餐厅都有自己的鸡尾酒菜单——它有自己独特的一套饮料，里面有我从未听说过的配料。</p><p>  See, I don’t have a very comprehensive liquor collection. I’ve got the basics, sure, and over the course of quarantining I’ve acquired a few  fancier ingredients. But fancy ingredients usually aren’t very versatile: I bought a bottle of Amaro Nonino once to mix a  Paper Plane. But it turns out I don’t like really Paper Planes. So now I just have, like, 97.1% of a bottle of Amaro Nonino, and nothing to do with it.  1</p><p>看，我没有一个非常全面的酒类收藏。我有基本的，当然，在隔离的过程中，我获得了一些更高级的成分。但花式配料通常不是万能的：我曾经买过一瓶Amaro Nono来混合纸飞机。但事实证明我不喜欢真正的纸飞机。所以现在我只喝了97.1%的阿玛罗诺诺，与此无关。1.</p><p>  So I wrote a little program to tell me: given what I have in my bar right now,  what should I add that will enable me to make the maximum number of new cocktails. Or in other words, what is my most efficient purchase – what is the ingredient that I am most “blocked on.”</p><p>所以我写了一个小程序来告诉我：考虑到我现在在酒吧里拥有的东西，我应该添加什么才能让我最大限度地制作新鸡尾酒。或者换句话说，我最有效的购买方式是什么——我最“受阻”的成分是什么</p><p>  I thought this would be a good opportunity to try out  Datalog, a word that  I’d heard before.</p><p>我想这将是一个尝试Datalog的好机会，我以前听过Datalog这个词。</p><p> Now, you might be thinking that this sounds like a trivial problem, and you can just write a couple lines of Python to do set subtraction based on what you have and what you need and then just filter down to the cocktails missing exactly one ingredient.</p><p>现在，你可能会认为这听起来像是一个小问题，你可以编写几行Python，根据你拥有的和你需要的进行集减法运算，然后过滤掉只缺少一种成分的鸡尾酒。</p><p>  The reason logic programming seemed appropriate to me was the idea of these “production rules:” ingredients that can become (or combine to become) other ingredients.</p><p>逻辑编程对我来说似乎合适的原因是这些“生产规则”的想法：可以成为（或结合成为）其他成分的成分。</p><p> Now, I’m not saying that it would be  hard to model that in your favorite scripting language, but it’s not really  obvious any more how to do it without a guess-and-check sort of brute force search. Not that there’s anything wrong with that; it just feels like a more natural fit for logic programming.</p><p>现在，我并不是说用你最喜欢的脚本语言来建模会很困难，但如果不使用猜测和检查之类的暴力搜索，如何实现这一点已经不太明显了。并不是说这有什么问题；它感觉更适合逻辑编程。</p><p> Or not! Who knows. It’s not like I know anything about logic programming. This whole thing is just an excuse to try it out.</p><p>或者不是！谁知道呢。我对逻辑编程一无所知。这整件事只是一个尝试的借口。</p><p>  The code, like all code, is on GitHub. You can look through the project – I would recommend starting with  the tests, as they provide a sort of literate guide to how it works.</p><p>与所有代码一样，该代码也在GitHub上。你可以浏览一下这个项目——我建议从测试开始，因为它们提供了一种关于它如何工作的知识指南。</p><p> But I dare say the code is not all that interesting, by itself: if you already know Datalog, it’s trivial; if you don’t, it’s inscrutable.</p><p>但我敢说，代码本身并没有那么有趣：如果你已经知道数据日志，那么它就微不足道了；如果你不这样做，这是难以理解的。</p><p> So instead, I’m going to walk through the final result piece by piece, and talk about some of the missteps and mistakes I made along the way. Since this was my first encounter with Datalog, it took me a little while before I was able to “think” the way that Datalog wanted me to – and I think the errors I made along the way are a lot more interesting than the final result.</p><p>因此，我将一件一件地浏览最终结果，并讨论我在这一过程中犯下的一些错误。由于这是我第一次接触Datalog，我花了一段时间才能够“思考”Datalog希望我的方式——我认为我在这一过程中犯的错误比最终结果有趣得多。</p><p>     Custom types make the rest of the code more readable, and will let the compiler catch dumb mistakes like mixing up the order of my relations.</p><p>自定义类型使代码的其余部分更具可读性，并让编译器捕捉到愚蠢的错误，比如混淆关系的顺序。</p><p> symbol is what Datalog calls “string” – I point this out because it might be a little confusing if you’re used to LISP or Ruby or some other language that uses the term differently.</p><p>symbol就是Datalog所说的“字符串”——我指出这一点是因为如果你习惯于LISP、Ruby或其他一些使用不同术语的语言，可能会有点困惑。</p><p>   I had a lot of trouble thinking about relations until I had an insight that seems very obvious in hindsight: I actually use relations all the time, in relational databases. So it might be useful to think of  Has like a table in SQL, with a single column. It’s not quite the same thing, but I found it was a decent starting point for thinking about how to “shape” my data.</p><p>我在思考关系时遇到了很多困难，直到我有了一个事后看来非常明显的见解：我实际上一直在关系数据库中使用关系。因此，把Has想象成SQL中的一个表，只包含一列，可能会很有用。这不完全是一回事，但我发现这是思考如何“塑造”我的数据的一个不错的起点。</p><p> That  .input line just loads a list of ingredients from  a text file – one ingredient per line. Inserts rows into our table, if you will – except that in Datalog, “rows” are called “facts.”</p><p>那个输入行只是从文本文件中加载一个成分列表——每行一种成分。如果愿意，可以在我们的表中插入行——除了在数据日志中，“行”称为“事实”</p><p>  This relation is more interesting: these are our recipes. Although in a traditional language we might think of a recipe as  { name : string, ingredients : List&lt;string&gt; }, we have to sort of bend things to fit into the “table-like” representation of relations.</p><p>这种关系更有趣：这些是我们的食谱。虽然在传统语言中，我们可能会认为食谱是{name:string，components:List&lt；string&gt；}，我们必须在某种程度上改变事物，以适应关系的“表格式”表示。</p><p> Again, we just load data from  a plain text file. By default, Soufflé wants to read tab-separated values, but I made a custom delimiter because I think it reads a little nicer, and so that I wouldn’t have to deal with tabs. Nobody wants to deal with tabs.</p><p>同样，我们只是从纯文本文件加载数据。默认情况下，Souffle希望读取以制表符分隔的值，但我制作了一个自定义分隔符，因为我认为它的读取效果更好，所以我不必处理制表符。没人想处理标签。</p><p> .decl Begets(in : Ingredient, out : Ingredient).input Begets(filename=&#34;begets&#34;, delimiter=&#34; -&gt; &#34;).input Begets(filename=&#34;auto-begets&#34;, delimiter=&#34; -&gt; &#34;)</p><p>.decl产生（输入：成分，输出：成分）。输入Begets（文件名=&#34；Begets&#34；，分隔符=&#34；-&gt；&#34；）。输入开始（文件名=&#34；自动开始&#34；，分隔符=&#34；-&gt；&#34；）</p><p> Begets is a relation we’re going to talk a lot about later. For now, just think of it as a bunch of statements like “limes beget lime juice” or “Cognac begets brandy” – ingredients that can  become other ingredients, or ingredients that can  act as other ingredients. The name  Begets is weird and a little clumsy; I’ll explain why I chose it over  Makes or  ActsAs or something once we see how it’s used.</p><p>Begets是一段我们以后会经常谈论的关系。现在，只要把它想象成一堆像“酸橙生酸橙汁”或“干邑生白兰地”这样的说法——这些成分可以成为其他成分，或者可以作为其他成分。“生儿育女”这个名字很奇怪，有点笨拙；一旦我们看到它的使用方式，我会解释为什么我会选择它而不是make或actsa之类的东西。</p><p> I load  Begets from two separate files because  one is hand-curated and the other is autogenerated – I’ll explain why that is later, when we talk about the recipe book.</p><p>我从两个独立的文件加载Begets，因为一个是手工制作的，另一个是自动生成的——我将在稍后讨论食谱时解释为什么会这样。</p><p>  These are our “multi-ingredient ingredients.” Think flavored syrups, basically –  look in the file for some examples:</p><p>这些是我们的“多种成分”基本上，想想调味糖浆——看看文件中的一些例子：</p><p>  I only bothered to support two-ingredient combinations, because that covers basically everything. But you could add another  Composite3() relation or something to support more ingredients, if you wanted.</p><p>我只费心支持两种成分组合，因为这基本上涵盖了所有东西。但是，如果你愿意，你可以添加另一个Composite3（）关系或其他东西来支持更多成分。</p><p> Wait, why can  recipes have arbitrarily many ingredients, if  Composites can’t? Why not do the same thing here, and just make a “table” of ingredient combinations?</p><p>等等，如果复合材料不能，为什么食谱中可以任意添加许多成分？为什么不在这里做同样的事情，只是做一个“表”的成分组合？</p><p> Okay, great question. Basically, I think it would add a distracting level of complexity to this example, so I’m leaving it as an exercise for the reader. I haven’t actually tried to do it, but I  think that it would work, and you could even generalize the concept of a “recipe” to be any “combination of one or more things” and only have one type and everything would be beautiful and elegant but much harder to walk through in a blog post.</p><p>好的，问得好。基本上，我认为这会给这个例子增加一个分散注意力的复杂程度，所以我把它留给读者作为练习。实际上我还没有尝试过，但我认为它会起作用，你甚至可以把“食谱”的概念概括为任何“一种或多种事物的组合”，只有一种类型，所有东西都会很漂亮、优雅，但在博客文章中很难理解。</p><p>   I don’t load this one from a file. Instead I’m basically saying “ x is a recipe if it appears in the first ‘column’ of the  Needs relation.” You could think of this as analogous to a SQL view, kinda like:</p><p>我不会从文件中加载这个。相反，我基本上是说，“如果x出现在需求关系的第一列，那么它就是一个配方。”您可以将其视为类似于SQL视图，有点像：</p><p>  I made  IsRecipe just as a helper, because I think it’s a lot more explicit than writing  Needs(x, _) when I mean “all recipes.”</p><p>我把IsRecipe作为一个助手，因为我认为它比我所说的“所有食谱”更明确</p><p> .decl IsIngredient(x : Ingredient)IsIngredient(x) :- Needs(_, x).IsIngredient(x) :- Begets(x, _).IsIngredient(x) :- Begets(_, x).IsIngredient(x) :- Composite(x, _, _).IsIngredient(x) :- Composite(_, x, _).IsIngredient(x) :- Composite(_, _, x).</p><p>.decl-isingredent（x：成分）isingredent（x）：-Needs（ux）。IsingCredit（x）：-Begets（x，u）。IsIngredient（x）：-产生（ux）。IsingElement（x）：-Composite（x，，）。IsingElement（x）：-Composite（x，x，x）。IsingElement（x）：-Composite（，，x）。</p><p> This is another helper, but it has multiple rules. All of those are kind of “unioned” together. Basically: “ x is an ingredient if it is used in a recipe or if it appears in a begets rule or in a composite description.”</p><p>这是另一个助手，但它有多个规则。所有这些都是某种“联合”在一起的。基本上：“x是一种成分，如果它被用在配方中，或者出现在贝格茨规则或复合描述中。”</p><p> We  could just list out every ingredient in a file somewhere, but I think declaring the relation  intensionally is a lot nicer. Also I wanted to show off that for the first time in my life I managed to use that term correctly.  2</p><p>我们可以在某个地方列出一个文件中的所有成分，但我认为在意向上声明这种关系要好得多。我还想炫耀一下，这是我有生以来第一次正确使用这个词。2.</p><p>  The next relation is pretty trivial:  Unbuyable is a list of things like  egg white that appear as ingredients but that I don’t want to appear in the final output, because I can’t actually  buy egg whites at the store. Like  Begets, I have some autogenerated and some hand-curated entries.</p><p>下一个关系非常简单：Unbuyable是一个类似蛋清的列表，它作为配料出现，但我不想出现在最终输出中，因为我实际上无法在商店购买蛋清。像Begets一样，我也有一些自动生成和手工策划的作品。</p><p>   That first rule basically says “all ingredients beget themselves.” I would like to be able to just write  Begets(x, x)., but Datalog doesn’t allow that kind of “infinite” rule – it needs me to provide a domain for  x, and that’s when our  IsIngredient helper comes in.</p><p>第一条规则基本上是说“所有成分都会产生它们自己。”我希望能够写出Begets（x，x）。，但Datalog不允许这种“无限”规则——它需要我为x提供一个域，这就是我们的iSingCredit助手的作用。</p><p> This is why the relation is called “begets” instead of “makes” or “produces” or something. Originally it was called  Makes, and I had awkward expressions like “if you have  x or you have  y such that  Makes(y, x) then&amp;mldr” By making everything beget itself, I was able to dramatically simplify the “shopping list” calculation.</p><p>这就是为什么这种关系被称为“生儿育女”，而不是“制造”或“生产”之类的东西。最初它被称为Makes，我有一些尴尬的表达方式，比如“如果你有x或者你有y使得（y，x）那么&amp；mldr”，通过让一切都开始，我能够极大地简化“购物清单”的计算。</p><p> That second rule just says that  Begets is transitive: if limes make lime peel, and lime peel makes lime zest, then limes make lime zest. I actually didn’t bother to write my rules at quite that level of granularity, but I  could if I wanted to.</p><p>第二条规则只是说Begets是传递性的：如果酸橙皮产生酸橙皮，酸橙皮产生酸橙皮，那么酸橙皮产生酸橙皮。实际上，我并没有费心在这样的粒度级别编写规则，但如果我愿意，我可以。</p><p>   Basically, if you have an input (e.g. lemon), and the input begets something else (e.g. lemon juice), then you also have the “output.” But you can’t use the word  output because it’s reserved and you’ll get a confusing error message if you try:</p><p>基本上，如果你有一个输入（例如柠檬），而输入产生了其他东西（例如柠檬汁），那么你也有“输出”但是不能使用“输出”这个词，因为它是保留的，如果您尝试以下操作，会收到令人困惑的错误消息：</p><p> Error: syntax error, unexpected relation qualifier output, expecting )in file mixologician.dl at line 32Has(output) :- Has(in), Begets(in, output).----^---------------------------------------1 errors generated, evaluation aborted</p><p>错误：语法错误，意外的关系限定符输出，预期）在文件MixLogician中。第32行的dl Has（输出）：-Has（输入），Begets（输入，输出）----^---------------------------------------1生成错误，评估中止</p><p> You might remember that we originally loaded  Has from a file, and it was just a flat list of what Datalog calls “facts.” But now we’re adding facts to it dynamically – we started out thinking of it as a table, but now it’s sort a weird table/view hybrid thing. So the SQL analogy sort of breaks down a bit.</p><p>您可能还记得，我们最初从一个文件中加载了Has，它只是Datalog称之为“事实”的一个简单列表但现在我们正在动态地向它添加事实——我们一开始认为它是一个表，但现在它是一种奇怪的表/视图混合的东西。因此，SQL类比有点崩溃。</p><p> And yes, it might be a little confusing to think about the fact that  Begets(x, x), so we’re making a sort of self-referential infinite statement here: “if you have  x then you have  x because  x begets  x.” But Datalog doesn’t mind.</p><p>是的，考虑到生（x，x）这个事实可能会有点困惑，所以我们在这里做一种自我引用的无限陈述：“如果你有x，那么你有x，因为x生x。”但数据日志并不介意。</p><p> Begets(x, result) :- Composite(result, first, second), Has(first), Begets(x, second).Begets(x, result) :- Composite(result, first, second), Has(second), Begets(x, first).</p><p>Begets（x，result）：-Composite（result，first，second）、Has（first）、Begets（x，second）。Begets（x，result）：-Composite（result，first，second）、Has（second）、Begets（x，first）。</p><p> Here we say that one component of a “composite ingredient” begets that composite ingredient, but only if you already have the other component.</p><p>在这里，我们说“复合成分”中的一种成分产生了该复合成分，但前提是你已经有了另一种成分。</p><p> This is the first complicated rule we have, so I’m going to work up to this from simpler examples. This was the first thing I tried:</p><p>这是我们掌握的第一条复杂规则，所以我将从更简单的例子中学习。这是我第一次尝试：</p><p>  That says “lime zest begets lime cordial  if you have sugar, and sugar begets lime cordial  if you have lime zest.”</p><p>也就是说，“如果你有糖，酸橙皮生酸橙皮，如果你有酸橙皮，糖生酸橙皮。”</p><p> And this actually works pretty well – but, you know, we don’t want to write that in code. We want to load these facts from files, so we bring in the  Composite relation:</p><p>这实际上非常有效——但是，你知道，我们不想用代码来写。我们想从文件中加载这些事实，所以我们引入了复合关系：</p><p>  That’s just a restatement of what we wrote last time, but now it applies to anything in our  Composite relation.</p><p>这只是我们上次写的东西的重述，但现在它适用于我们复合关系中的任何东西。</p><p> But there’s a  subtle problem with this logic. Namely: lime  zest begets lime cordial, but  lime does not. And I usually don’t keep lime zest stocked by itself, so according to this logic, I can’t make lime cordial even if I have lime.</p><p>但这种逻辑有一个微妙的问题。也就是说：酸橙的热情会产生酸橙的热情，但酸橙不会。而且我通常不会自己储存石灰皮，所以根据这个逻辑，即使我有石灰，我也不能使石灰热乎乎的。</p><p> So that’s the reason we have this bit of indirection: really anything that  begets lime zest also begets lime cordial, as long as you also have sugar. So let’s look at the working rule in “concrete” form, without the  Composite relation:</p><p>所以这就是我们有点间接的原因：只要你还有糖，任何能产生酸橙热情的东西也能产生酸橙热饮。让我们看看“具体”形式的工作规则，没有复合关系：</p><p> Begets(x, &#34;lime cordial&#34;) :- Has(&#34;sugar&#34;), Begets(x, &#34;lime zest&#34;).Begets(x, &#34;lime cordial&#34;) :- Has(&#34;lime zest&#34;), Begets(x, &#34;sugar&#34;).</p><p>贝吉斯（x，&#34；莱姆热诚&#34；）：有（&#34；糖&#34；），生菜（x，&#34；酸橙皮&#34；）。贝吉斯（x，&#34；莱姆热诚&#34；）：有（&#34；酸橙皮&#34；），生出（x，&#34；糖&#34；）。</p><p> I think that’s a lot easier to read, and you can imagine applying the same  Composite replacement here to get to the “full” rule above.</p><p>我认为这更容易阅读，你可以想象在这里应用相同的复合替换来获得上面的“完整”规则。</p><p>  Begets(x, &#34;lime cordial&#34;) :- Has(y), Begets(y, &#34;sugar&#34;), Begets(x, &#34;lime zest&#34;).Begets(x, &#34;lime cordial&#34;) :- Has(y), Begets(y, &#34;lime zest&#34;), Begets(x, &#34;sugar&#34;).</p><p>贝吉斯（x，&#34；莱姆热诚&#34；）：有（y），生（y，&#34；糖&#34；），生菜（x，&#34；酸橙皮&#34；）。贝吉斯（x，&#34；莱姆热诚&#34；）：有（y），生（y，&#34；酸橙皮&#34；），生出（x，&#34；糖&#34；）。</p><p> I only mention this because I actually  wrote that first, before I realized that it was unnecessary: because of the rule that  Has(out) :- Has(in), Begets(in, out)., we cover this case by virtue of the  Has(&#34;lime zest&#34;) bit.  3</p><p>我之所以提到这一点，是因为在我意识到这是不必要的之前，我实际上先写了这篇文章：因为有一条规则：Has（out）：-Has（in），beggets（in，out）。，我们通过Has（&#34；石灰皮&#34；）来报道这个案例一点3.</p><p>   This is a pretty trivial helper relation – a drink is missing an ingredient if it needs it and we don’t have it. This is our first example of relation negation, which is a fun phrase.</p><p>这是一个非常琐碎的帮手关系——如果一种饮料需要某种成分，而我们没有这种成分，那么它就缺少了这种成分。这是我们第一个关系否定的例子，这是一个有趣的短语。</p><p>  And we use it to declare all of the drinks that we are able to mix – which is to say, all drinks that do not have any missing ingredients.</p><p>我们用它来声明我们能够混合的所有饮料——也就是说，所有不含任何缺失成分的饮料。</p><p>   But Soufflé rejects that: we need to restrict the domain of the relation. You can maybe think of this as trying to create a SQL table with every value that does not exist in another SQL table – you’d run out of disk space pretty quickly. Or, if you’re Soufflé, you’d run out of memory, I guess?</p><p>但Souffle否认了这一点：我们需要限制这种关系的范围。您可能会认为这是在尝试创建一个SQL表，其中包含另一个SQL表中不存在的所有值，这会很快耗尽磁盘空间。或者，如果你是蛋奶酥，我猜你的记忆力会耗尽？</p><p>  I think this offers an interesting insight into the nature of Datalog: although we write rules as if we’re declaring functions, in the end I  think all relations need to be able to be realized as a big pile of tuples. The engine might be able to optimize out the actual realization, but it needs to be  possible. I think. Like I said, I don’t actually know anything about Datalog.</p><p>我认为这为数据日志的本质提供了一个有趣的洞察：尽管我们编写规则就像我们在声明函数一样，但最终我认为所有关系都需要能够实现为一大堆元组。引擎可能能够优化实际实现，但它需要成为可能。我想。就像我说的，我对数据日志一无所知。</p><p>  This relation is very simple, and I added it the first time I actually tried to  use Mixologician to find a drink to make. Instead of just a list of names, it’s exactly my recipe book filtered to the recipes that I can make – so I can search for specific ingredients, if I’m in the mood for something in particular.</p><p>这种关系非常简单，我第一次尝试使用Mixologician来制作饮料时就添加了这种关系。它不仅仅是一个名字列表，而是我的食谱，过滤到我可以制作的食谱中——这样我就可以搜索特定的成分，如果我想做一些特别的东西的话。</p><p> But the last rule is the meatiest. So without further ado, the reason we’re all here:</p><p>但最后一条规则是最美味的。因此，我们来到这里的原因是：</p><p> .decl Enables(missing : Ingredient, drink : Recipe)Enables(ingredient, drink) :- !Unbuyable(ingredient), Missing(drink, out), Begets(ingredient, out), count : { Missing(drink, _) } = count : { Begets(ingredient, product), Missing(drink, product) }..output Mixable(filename=&#34;mixable&#34;).output MixableRecipe(filename=&#34;mixable-recipes&#34;, delimiter=&#34; &lt;- &#34;).output Enables(filename=&#34;shopping-list&#34;, delimiter=&#34; -&gt; &#34;)</p><p>.decl启用（缺少：配料、饮料：配方）启用（配料、饮料）：-！不可购买的（配料），缺少的（饮料，产品），缺少的（饮料，产品），计数：{Missing（饮料，）}=count:{Begets（配料，产品），缺少的（饮料，产品）}。。输出可混合（文件名=&#34；可混合&#34；）。输出可混合配方（文件名=&#34；可混合配方&#34；，分隔符=&#34；&lt；-&#34；）。输出启用（文件名=&#34；购物清单&#34；，分隔符=&#34；-&gt；&#34；）</p><p>  I’m going to spend a lot of time talking about that  Enables rule, so I wanted to get the  .output lines out of the way first. While I was writing this program, I would frequently dump out other relations too, as a way to debug things. It was pretty useful.</p><p>我会花很多时间来讨论这条规则，所以我想得到答案。先把输出线让开。当我编写这个程序时，我也会经常抛出其他关系，作为调试东西的一种方式。它非常有用。</p><p>  Enables(ingredient, drink) :- !Unbuyable(ingredient), Missing(drink, out), Begets(ingredient, out), count : { Missing(drink, _) } = count : { Begets(ingredient, product), Missing(drink, product) }.</p><p>启用（配料、饮料）：-！不可购买（配料）、缺失（饮料、产品）、缺失（饮料、产品）、计数：{Missing（饮料、产品）}=count:{Begets（配料、产品）、缺失（饮料、产品）}。</p><p> The  !Unbuyable(ingredient) clause is trivial – it just exists to filter out things like  lime zest that we don’t want to see in our output. Let’s ignore that for now:</p><p>这个Unbuyable（配料）条款很琐碎——它的存在只是为了过滤掉我们不想在产品中看到的东西，比如酸橙皮。让我们暂时忽略这一点：</p><p> Enables(ingredient, drink) :- Missing(drink, out), Begets(ingredient, out), count : { Missing(drink, _) } = count : { Begets(ingredient, product), Missing(drink, product) }.</p><p>启用（成分，饮料）：-Missing（饮料，out），Begets（成分，out），count:{Missing（饮料，）}=count:{Begets（成分，产品），Missing（饮料，产品）}。</p><p> In English: “ ingredient enables you to make  drink if  drink is missing something that  ingredient can beget, and if the  only missing ingredients in  drink can be begotten by  ingredient.”</p><p>在英语中：“如果饮料缺少某种成分可以产生的东西，如果饮料中唯一缺少的成分可以由成分产生，那么成分可以让你制作饮料。”</p><p>  Well, no, but that’s what it  means. It really says “ ingredient enables you to make  drink if  drink is missing something that  ingredient can beget, and if the number of missing ingredients in  drink is equal to the number of missing ingredients in  drink that can be begotten by  ingredient.” We’re really comparing set cardinality, not set equality, but since one set is a subset of the other, the only way they can have the same cardinality is if the sets are identical.  4 We  would compare set equality if we could, but as far as I can tell Soufflé can’t do that.</p><p>不，但这就是它的意思。它真的说，“如果饮料中缺少某种成分可以产生的东西，如果饮料中缺少的成分的数量等于饮料中缺少的成分的数量，那么成分可以让你制作饮料。”我们实际上是在比较集合的基数，而不是集合的相等性，但是由于一个集合是另一个集合的子集，所以它们可以具有相同基数的唯一方法是如果集合是相同的。4如果可以的话，我们会比较set equality，但据我所知，Souffle不能这么做。</p><p> So hopefully that makes sense. It’s a  pretty simple expression, in the end. But it took me  hours to write it. Really! I think I spent  multiple hours coming up with that one rule. It was extremely fun and educational, but I feel like a lot of the benefit of the journey is lost when you just jump right to the final answer.</p><p>希望这是有道理的。说到底，这是一个非常简单的表达。但我花了好几个小时才写完。真正地我想我花了好几个小时想出了一条规则。这是非常有趣和有教育意义的，但我觉得当你直接跳到最后的答案时，这段旅程的很多好处都消失了。</p><p>  Well, sure, but I want to take a few steps back, and talk about how I got here. I want you to come on a journey with me, which will end with that expression. But will start with something very different.</p><p>当然，但我想后退几步，谈谈我是如何来到这里的。我希望你和我一起踏上一段旅程，以那句话结束。但会从非常不同的事情开始。</p><p> See, when I first started, I was not thinking in Datalog. I was thinking in “logic.” I wanted to write something like this:</p><p>看，当我第一次开始时，我没有在数据日志中思考。我在用“逻辑”思考我想写这样的东西：</p><p>   I wanted to be able to say “show me ingredients that I don’t currently have, but that  if I had them  then I would be able to mix a new drink.” That’s, like, the logical expression that I spent a long time trying to translate into Datalog, but that it just isn’t possible to say – there’s no “hypothetical” operator. Maybe I could write something like that in Prolog, though? As previously stated, I don’t know anything about logic programming.</p><p>我想说“给我看看我目前没有的成分，但是如果我有了它们，我就可以混合一种新的饮料。”这是我花了很长时间试图翻译成数据日志的逻辑表达式，但这是不可能的——没有“假设”运算符。也许我可以在序言中写些类似的东西？如前所述，我对逻辑编程一无所知。</p><p> So anyway, I quickly realized it was just not possible to express that in Datalog. So I tried to do something simpler: just find recipes that are missing exactly one ingredient. Forget all about  Begets or  Composites or whatever; we’ll add that back in later. For now, how do you just find recipes that are “almost” mixable?</p><p>所以不管怎样，我很快意识到，在数据日志中表达这一点是不可能的。所以我试着做一些简单的事情：只需找到缺少一种成分的食谱。忘记所有关于生儿育女或合成物的事；我们稍后再加进去。现在，你怎么才能找到“几乎”可以混合的食谱呢？</p><p>   Which was my extremely clumsy attempt at translating the standard first-order logic “uniqueness” expression:</p><p>这是我在翻译标准一阶逻辑“唯一性”表达式时极其笨拙的尝试：</p><p>  Basically I was trying to say “ drink is missing  ingredient and it isn’t missing anything else.” But that doesn’t work: I was still thinking in “logic,” and not in Datalog.</p><p>基本上我想说的是“饮料缺少了成分，它没有遗漏任何其他东西。”但这不起作用：我仍然在用“逻辑”思考，而不是用数据日志。</p><p> Eventually, while  reading the docs, I saw the   count aggregate, and was able to write this – my first expression that actually told me something interesting:</p><p>最终，在阅读文档时，我看到了计数的总和，并能够写下这句话——我的第一个表达实际上告诉了我一些有趣的事情：</p><p>      Error: Witness problem: argument grounded by an aggregator&#39;s inner scope is used ungrounded in outer scope in file mixologician.dl at line 53AlmostMixable(drink) :- count : { Missing(drink, _) } = 1.--------------^--------------------------------------------1 errors generated, evaluation aborted</p><p>错误：见证问题：聚合器以参数为基础&#39；在file mixologician中，s的内部作用域在外部作用域中不接地使用。第53AlmostMixable（drink）行的dl:-count:{Missing（drink，）}=1--------------^--------------------------------------------1生成错误，评估中止</p><p> And I figured out that I needed the first  Missing(drink, _) in order to “ground” the variable – you get it. You run into the same types of errors when you use SQL aggregate expressions – referencing variables that don’t “exist” at the same level. I don’t really know the right words to talk about this intelligibly.</p><p>我发现我需要第一个缺失的（饮料）来“磨碎”变量——你明白了。当使用SQL聚合表达式时，会遇到相同类型的错误——引用在同一级别“不存在”的变量。我真的不知道该用什么词来清楚地谈论这件事。</p><p> Anyway, once I got there, I wanted to  see the ingredient that was missing. But that was an easy change – just stop ignoring that variable:</p><p>总之，我一到那里，就想看看缺少的配料。但这是一个简单的改变——别再忽视这个变量了：</p><p>  And that’s great! That does tell me what drinks are missing one ingredient.</p><p>太棒了！这确实告诉我哪些饮料缺少一种成分。</p><p> But now we need to worry about ingredients that “make” other ingredients. And at this point, all I had was a relation that looked like this:</p><p>但现在我们需要担心那些“制造”其他成分的成分。在这一点上，我所拥有的只是一个看起来像这样的关系：</p><p>  Basically, I didn’t have the  Begets(x, x) rule yet – but we’ll get there.</p><p>基本上，我还没有Begets（x，x）规则——但我们会做到的。</p><p>  Enables(ingredient, drink) :- Missing(drink, ingredient), count : { Missing(drink, _) } = 1.Enables(in, drink) :- Makes(in, missing), Enables(missing, drink).</p><p>启用（成分，饮料）：-Missing（饮料，成分），count:{Missing（饮料，饮料）}=1。启用（in，drink）：-make（in，missing），Enables（missing，drink）。</p><p>  But that second  Enables rule isn’t sufficient for everything: it basically says “if a drink is missing one ingredient, then acquiring anything that makes that ingredient will also allow you to make the drink.”</p><p>但这第二条规则并不能满足所有要求：它基本上是说“如果一种饮料缺少一种成分，那么获得任何制造这种成分的东西也可以让你制作这种饮料。”</p><p> This works for something simple, like “limes give you lime juice so now you can make a Margarita.” But what if a drink is missing  multiple ingredients, all of which could be made by acquiring a single new ingredient? This comes up in practice with the  Gimlet: say you have gin and sugar, but you’re missing lime juice and lime cordial. You only need to buy limes, but the Gimlet is missing two ingredients, so it doesn’t show up.</p><p>这适用于一些简单的事情，比如“酸橙给你酸橙汁，现在你可以做玛格丽塔了。”但是，如果一种饮料缺少多种成分，而所有这些成分都可以通过获取一种新成分来制作，那该怎么办？这在Gimlet的实践中出现：假设你有杜松子酒和糖，但你缺少了莱姆汁和莱姆酒。你只需要买酸橙，但是这个小玩意儿缺少两种成分，所以它不会出现。</p><p>   Enables(ingredient, drink) :- Missing(drink, ingredient), count : { Missing(drink, _) } = 1.Enables(ingredient, drink) :- Missing(drink, out), Makes(ingredient, out), count : { Missing(drink, _) } = count : { Makes(ingredient, product), Missing(drink, product) }.</p><p>启用（成分，饮料）：-Missing（饮料，成分），count:{Missing（饮料，饮料）}=1。启用（成分，饮料）：-Missing（饮料，out），make（成分，out），count:{Missing（饮料，）}=count:{make（成分，产品），Missing（饮料，产品）}。</p><p> For a while I thought this worked. It  looked like it </p><p>有一段时间我觉得这很管用。看起来是这样的</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/记录/">#记录</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/drinking/">#drinking</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/成分/">#成分</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>