<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>LLVM Clang 12合并了对x86_64微体系结构级别的支持</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">LLVM Clang 12合并了对x86_64微体系结构级别的支持</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 04:25:55</div><div class="page_narrow text-break page_content"><p>Florian Weimer  fweimer@redhat.com    Fri Jul 10 17:30:09 GMT 2020  Most Linux distributions still compile against the original x86-64baseline that was based on the AMD K8 (minus the 3DNow! parts, for IntelEM64T compatibility).There has been an attempt to use the existing AT_PLATFORM-based loadingmechanism in the glibc dynamic linker to enable a selection of optimizedlibraries. But the general selection mechanism in glibc is problematic: hwcaps subdirectory selection in the dynamic loader &lt; https://sourceware.org/pipermail/libc-alpha/2020-May/113757.html&gt;We also have the problem that the glibc version of &#34;haswell&#34; is distinctfrom GCC&#39;s -march=haswell (and presumably other compilers): Definition of &#34;haswell&#34; platform is inconsistent with GCC &lt; https://sourceware.org/bugzilla/show_bug.cgi?id=24080&gt;And that the selection criteria are not what people expect: Epyc and other current AMD CPUs do not select the &#34;haswell&#34; platform subdirectory &lt; https://sourceware.org/bugzilla/show_bug.cgi?id=23249&gt;Since the hwcaps-based selection does not work well regardless ofarchitecture (even in cases the kernel provides glibc with data), Iworked on a new mechanism that does not have the problems associatedwith the old mechanism: [PATCH 00/30] RFC: elf: glibc-hwcaps support &lt; https://sourceware.org/pipermail/libc-alpha/2020-June/115250.html&gt;(Don&#39;t be concerned that these patches have not been reviewed; we arebusy preparing the glibc 2.32 release, and these changes do not alterthe glibc ABI itself, so they do not have immediate priority. I&#39;mfairly confident that a version of these changes will make it into glibc2.33, and I hope to backport them into Fedora 33, Fedora 32, and Red HatEnterprise Linux 8.4. Debian as well, but I have never done anythinglike it there, so I don&#39;t know if the patches will be accepted.)Out of the box, this should work fairly well for IBM POWER and Z, wherethere is a clear progression of silicon versions (at least on paper—virtualization may blur the picture somewhat).However, for x86, we do not have such a clear progression ofmicro-architecture versions. This is not just as a result of theAMD/Intel competition, but also due to ongoing product differentiationwithin one chip vendor. I think we need these levels broadly for thefollowing reasons:* Selecting on individual CPU features (similar to the old hwcaps mechanism) in glibc has scalability issues, particularly for LD_LIBRARY_PATH processing.* Developers need guidance about useful targets for optimization. I think there is value in limiting the choices, in the sense that “if you are able to test three builds in total, these are the things you should build”.* glibc and the compilers should align in their definition of the levels, so that developers can use an -march= option to build for a particular level that is recognized by glibc. This is why I think the description of the levels should go into the psABI supplement.* A preference order for these levels avoids falling back to the K8 baseline if the platform progresses to a new version due to glibc/kernel/hypervisor/hardware upgrades.I&#39;m including a proposal for the levels below. I use single letters forthem, but I expect that the concrete implementation of this proposalwill use names like “x86-100”, “x86-101”, like in the glibc patchreferenced above. (But we can discuss other approaches.)I looked at various machines in the Red Hat labs and talked to Intel andAMD engineers about this, but this concrete proposal is based on my ownanalysis of the situation. I excluded CPU features related tocryptography and cache management, including hardware transactionalmemory, and CPU timing. I assume that we will see some of thesefeatures being disabled by the firmware or the kernel over time. Thatwould eliminate entire levels from selection, which is not desirable.For cryptographic code, I expect that localized selection of anoptimized implementation works because such code tends to be isolatedblocks, running for dozens of cycles each time, not something that getsscattered all over the place by the compiler.We previously discussed not emitting VZEROUPPER at later levels, but Idon&#39;t think this is beneficial because the ABI does not havecallee-saved vector registers, so it can only be useful with localfunctions (or whatever LTO considers local), where there is no ABIimpact anyway.I did not include FSGSBASE because the FS base is already available at%fs:0. Changing the FS base in userspace breaks too much, so the mainbenefit is the tighter encoding of rdfsbase, which seems very slim.Not covered in this are tuning decisions. I think we can benefit fromsome variance in this area between implementations; it should not affectcorrectness. 32-bit support is also a separate matter.* Level ACMPXCHG16B, LAHF/SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3This is one step above the K8 baseline and corresponds to a mainline CPUmodel ca. 2008 to 2011. It is also implemented by recent-ishgenerations of Intel Atom server CPUs (although I haven&#39;t tested thelatest version). A 32-bit variant would have to list many additionalCPU features here.* Level BAVX, plus everything in level A.This step is so small that it probably can be dropped, unless thebenefits from using VEX encoding are truly significant.For AVX and some of the following features, it is assumed that therun-time selection takes full support coverage (from silicon to thekernel) into account.* Level CAVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, plus everything in level B.This is close to what glibc currently calls &#34;haswell&#34;.* Level DAVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL, plus everything inlevel C.This is the AVX-512 level implemented by Xeon Scalable Processors, notthe Xeon Phi variant.glibc (or an alternative loader implementation) would search forlibraries starting at level D, going back to level A, and finally thebaseline implementation in the default library location.I expect that some distributions will also use these levels to set abaseline for the entire distribution (i.e., everything would be built tolevel A or maybe even level C), and these libraries would then beinstalled in the default location.I&#39;ll be glad if I can get any feedback on this proposal. I plan to turnit into a merge request for the x86-64 psABI document eventually.Thanks,Florian</p><p>Florian Wemer fwemer@redhat.com Fri Jul 10 17：30：09 GMT 2020大多数Linux发行版仍然基于基于AMD K8的原始x86-64基准进行编译(除了3D Now！部件，以实现英特尔EM64T兼容性)。有人试图在Glibc动态链接器中使用现有的基于AT_Platform的加载机制，以实现对优化库的选择。但Glibc中的通用选择机制是有问题的：动态加载器&lt；https://sourceware.org/pipermail/libc-alpha/2020-May/113757.html&gt；We中的hwcaps子目录选择也存在一个问题，即Glibc版本的hwcaps子目录选择不同于GCC版本的hwcaps=haswell(可能还有其他编译器)：hwcaps子目录选择平台的定义与GCC&lt；https://sourceware.org/bugzilla/show_bug.cgi?id=24080&gt；不一致。而且选择标准并不是人们所期望的：ePEC和其他当前的AMDCPU没有选择平台子目录&lt；https://sourceware.org/bugzilla/show_bug.cgi?id=23249&gt；Since基于hwcaps的选择无论采用哪种架构都不能很好地工作(即使在内核向Glibc提供数据的情况下也是如此)，我研究了一种新机制，它不存在与旧机制相关的问题：[Patch 00/30]rfc：ELF：Glibc-hwcaps support&lt；[Patch 00/30]RFC：ELF：Glibc-hwcaps support&lt；[Patch 00/30]rfc：ELF：Glibc-hwcaps support&lt；Https://sourceware.org/pipermail/libc-alpha/2020-June/115250.html&gt；(Don&#39；t需要注意的是，这些补丁没有经过审查；我们正忙于准备Glibc 2.32版本，而这些更改并不会改变Glibc ABI本身，因此它们没有立即优先考虑的事项。我不太相信这些变化的一个版本将会出现在glibc2.33中，我希望将它们移植到Fedora 33、Fedora 32和Red HatEnterprise Linux 8.4中。Debian也是，但我从来没有在那里做过任何喜欢的事情，所以我不知道补丁是否会被接受。)对于IBM POWER和Z来说，这应该可以很好地工作，那里的芯片版本有明显的进展(至少在纸面上--虚拟化可能会有点模糊)。但是，对于x86，我们没有那么明确的微体系结构版本的进展。这不仅是AMD/英特尔竞争的结果，也是由于同一家芯片供应商之间持续的产品差异化。我认为我们广泛地需要这些级别，原因如下：*在Glibc中选择单个CPU特性(类似于旧的hwcaps机制)存在可伸缩性问题，特别是对于LD_LIBRARY_PATH处理。*开发人员需要关于有用的优化目标的指导。我认为限制选择是有价值的，因为“如果您总共能够测试三个构建，那么这些就是您应该构建的东西”。*glibc和编译器应该在他们对级别的定义上保持一致，这样开发人员就可以使用-march=选项来构建由glibc识别的特定级别。这就是为什么我认为应该在psABI附录中介绍这些级别的原因。*如果平台由于libc/内核/虚拟机管理程序/硬件升级而升级到新版本，则这些级别的优先顺序可以避免退回到K8基准。我用单个字母来表示它们，但我希望这个提议的具体实现将使用类似于“x86-100”、“x86-101”的名称，就像上面提到的Glibc补丁一样。(但我们可以讨论其他方法。)我查看了红帽实验室的各种机器，并与英特尔和AMD的工程师讨论了这一点，但这个具体的建议是基于我自己对情况的分析。我排除了与密码和缓存管理相关的CPU功能，包括硬件事务内存和CPU计时。我假设随着时间的推移，我们会看到其中一些功能被固件或内核禁用。对于密码代码，我希望优化实现的本地化选择是可行的，因为这样的代码往往是孤立的块，每次运行几十个周期，而不是被编译器分散到各处。我们之前讨论过不在后面的级别发出VZEROUPPER，但我不认为这是有益的，因为ABI没有直接保存的向量寄存器，所以它只能用于本地。更改用户空间中的文件系统基数会造成太多中断，因此主要好处是rdfsbase的编码更紧密，这看起来非常精简。这里没有讨论调优决策。我认为我们可以从实现之间在这方面的一些差异中获益；这不应该影响正确性。32位支持也是另一回事。*级别ACMPXCHG16B、LAHF/SAHF、POPCNT、SSE3、SSE4.1、SSE4.2、SSSE3这比K8基准高出一级，相当于主线CPU型号约2008至2011年。它也是即时消息</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sourceware.org/pipermail/libc-alpha/2020-July/116135.html">https://sourceware.org/pipermail/libc-alpha/2020-July/116135.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/体系结构/">#体系结构</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/support/">#support</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/glibc/">#glibc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>