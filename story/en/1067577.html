<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Python中的子类化：Redux Subclassing in Python: Redux</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Subclassing in Python: Redux<br/>Python中的子类化：Redux </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-23 06:49:40</div><div class="page_narrow text-break page_content"><p>The conflict between subclassing and composition is as old as object-oriented programming. The latest crop of languages like  Go or  Rust prove that you don’t  need subclassing to successfully write code. But what’s a  pragmatic approach to subclassing in Python, specifically?</p><p>子类和组成之间的冲突与面向对象的编程一样古老。最新的语言（如Go或Rust）证明您不需要子类别以成功编写代码。但具体怎样？</p><p> Anybody who follows me long enough knows that I’m firmly in the  composition-over-inheritance camp. However,  Python is designed in a way that you  can’t write idiomatic code without subclassing  sometimes. My goal for this article is to meditate on the question when that  sometimes is and untangle my gut feelings on the topic  1.</p><p> 任何跟随我的人都足以让我坚持在构成过度继承营地。但是，Python的设计是以某种方式设计的，无需子类别就无法编写惯例代码。当时有时候是，在第1主题的情况下，我对这篇文章的目标是思考问题。</p><p> I realize this blog post is  long. In fact, it’s the longest piece of prose I’ve written since my thesis in 2006. Objectively, I should’ve split it up into  at least three parts. It would be better for engagement ( SEO!  Social media! Clicks!) and it would make it more likely that people  actually read it to the end.</p><p> 我意识到这个博文很长。事实上，它是我2006年论文自上文以来的最长的散文。客观地，我应该将其分成至少三个部分。这将是更好的参与（SEO！社交媒体！点击！），它会使人们实际读到尽头。</p><p> But I want it to stand for itself. I want it to be a distilled essence of what I’ve learned over the years. Of course,  you can feel free to take as many breaks as you like – this article isn’t going anywhere!</p><p> 但我希望它能成为自己。我希望它成为多年来学到的东西的蒸馏精华。当然，你可以随意服用尽可能多的休息 - 这篇文章不会在任何地方！</p><p> But please do me the courtesy of holding back angry comments until reading it in its  entirety. No matter what your allegiance is, I hope you’ll be able to read it with an open mind.</p><p> 但请给我礼貌地拿回愤怒的评论，直到整体读它。无论你的忠诚是什么，我希望你能用开放的思想阅读它。</p><p> Let’s start with  nuance. One of the reasons why many discussion on subclassing are so frustratingly fruitless is that there isn’t just one type of inheritance. As the wonderful article   Why inheritance never made any sense explains  2,  there are  three types that should never be mixed – no matter how you feel about subclassing in general.</p><p> 让我们从细微差别开始。许多关于子类化讨论的原因之一是如此令人沮丧的果蝇是不仅仅是一种类型的继承。作为奇妙的文章，为什么继承从未做出任何意义解释2，有三种类型应该永远不会混合 - 无论你如何对统一的对子。</p><p> That makes it possible that three people argue against each other, each one being right in their own way, never finding common ground. We’ve all seen these discussions unfold.</p><p> 这使得三个人可能互相争论，每个人都以自己的方式正确，从不找到共同点。我们都看到这些讨论展开了。 </p><p> In my experience – if used strictly separately – one is good, one is optional but useful, and one is bad. Most problems with subclassing stem from the fact that we try to use more than one type of subclassing at once – or from focusing the object design on the bad type.</p><p>在我的经验中 - 如果严格使用 - 一个是好的，一个是可选的，但有用，一个是坏的。子类化子类的大多数问题源于我们尝试一次使用多种类型的子类或将物体设计聚焦在坏类型上。</p><p> In all cases  you sacrifice reading convenience for writing convenience. That is not necessarily  bad, because software design is all about trade-offs and you can come to the conclusion that it’s perfectly worth it in certain cases. This is why  I  don’t expect you to agree with everything that follows. But I hope to provoke some thoughts that will help you to make that decision in the future.</p><p> 在所有情况下，你牺牲了阅读方便的便利。这不一定是糟糕的，因为软件设计都是关于权衡的，你可以得出结论，在某些情况下它是完全值得的。这就是为什么我不希望你同意所遵循的一切。但我希望挑起一些有助于你将来做出这种决定的想法。</p><p> But now, without further ado, let’s look at the three types. Starting with the bad one.</p><p> 但现在，没有进一步的ADO，让我们看看三种类型。从坏的开始。</p><p>   Most criticism of subclassing comes from code sharing and rightfully so. I don’t feel that I have a lot to add to it, so instead I’m going to link to exceptional prior art by people far smarter and more eloquent than me:</p><p>   对子类的大多数批评来自代码共享，所以就是这样。我不觉得我有很多东西要加入它，所以我将通过远远聪明地聪明地与特殊的现有技术联系起来，比我更雄辩：</p><p>   Variation over more than one axis. This is the major practical takeaway from Brandon’s post and the second half of Sandi’s talk. It’s not easily explained so I’ll refer to their works, but the essence is: if you want to customize more than one behavioral aspect of a class, code sharing via subclassing won’t work. It leads to a   subclass explosion.</p><p>   在多个轴上的变化。这是布兰登帖子的主要实用外卖和桑迪谈的下半场。它不容易解释，所以我会引用他们的作品，但本质是：如果要自定义一个类的一个行为方面，则通过子类化的代码共享将无法正常运行。它导致子类爆炸。</p><p> Class and instance namespaces get muddled. If you’ve got an attribute  self.x in a class that inherits from one or more base classes, it takes research and mental energy to find out where  x is coming from. This is true while  reading code and this is also true while  debugging.</p><p> class和实例命名空间变得混乱。如果您在从一个或多个基本类继承的类中有属性self.x，则需要研究和精神能量，以了解x来自的位置。读取代码时，这是正确的，并且在调试时也是如此。</p><p> It also means that there’s always the danger of two classes in the same hierarchy – that don’t know about each other – trying to have an attribute with the same name. Python has the concept of the double underscore prefix ( __x) to deal with this scenario, but that has been frowned upon and argued to prefer principle of  consenting adults.</p><p> 它还意味着在同一层次结构中始终存在两个类的危险 - 这对彼此不了解 - 尝试具有相同名称的属性。 Python具有双重下划线前缀（__X）的概念来处理此方案，但这一直被吓到并认为更喜欢同意成人的原则。 </p><p> The problem is that  informed consent is impossible if all parties aren’t informed. This problem gets exponentially worse with multiple inheritance and its extreme form of  mixins. You’re relying on classes – that you potentially don’t control and that know nothing about each other – getting along in a  shared namespace.</p><p>问题是，如果没有通知所有各方，那么知情同意是不可能的。这一问题与多种继承及其极端形式的混合形式呈呈指重较差。你依靠类 - 你可能没有控制，这对彼此一无所知 - 相交在共享命名空间中。</p><p> Another problem is that you have  no control over the methods and attributes that  you expose from the base classes to  your users. They are just there, tarnishing your API surface. Potentially changing over time as your base classes evolve and add or rename methods and attributes. This is among the reason why   attrs (and ultimately  dataclasses) chose to use  class decorators instead of subclassing: you have to be deliberate in what you attach to a class. It’s impossible to accidentally leak something to all subclasses.</p><p> 另一个问题是您无法控制您从基本类别向用户曝光的方法和属性。它们就在那里，玷污了你的API表面。随着时间的推移，随着基本类的发展和添加或重命名方法和属性，可能会随着时间的推移而变化。这是attrs（和最终DataClasses）选择使用类装饰器而不是子类化的原因之一：您必须在附加到课程的内容中进行故意。不可能意外地泄露给所有子类。</p><p> Confusing indirections. This is a special case of the previous problem and the main point of Augie’s and Nathaniel’s talk. If every method is on  self, it’s unclear where it’s coming from when looking at the call. Unless you are  very careful, every attempt at understanding control flow ends in a  wild goose chase. Once multiple inheritance comes into play, you better read up on the  MRO and   super(). I think it’s fair to say that something is amiss if  a question that boils down to “what is  super() even for?” gets almost 3,000 upvotes and more than 1,000 bookmarks on  StackOverflow.</p><p> 令人困惑的间接。这是前一个问题的特例，奥维尔和纳撒尼尔谈话的要点。如果每种方法都在自我上，那就不清楚它来自观看呼叫时的到来。除非你非常小心，否则每次尝试控制流量都以野鹅追逐结束。一旦多次继承发挥作用，最好在MRO和SUPER（）上阅读。我认为这是公平的，说如果一个问题归结为“超级（）即使是什么？”在stackoverflow上获得近3,000个升值和超过1,000个书签。</p><p> All of this gets extra problematic if you build APIs that require subclassing for either implementing or overwriting existing methods that get called from somewhere else. Both  Twisted and  asyncio have committed these sins in their  Protocol  3 classes respectively and it scarred me forever. The most common problems are that it’s complicated to find out which methods exist (especially in deep hierarchies like   Twisted’s) and the often silent failure if you name your method subtly wrong and the base class doesn’t find it.  4</p><p> 如果您构建了用于实现或覆盖从其他地方调用的现有方法，则构建需要子类化的API，则此此会产生额外的问题。扭曲和异步都曾分别致力于他们的协议3课程，它永远伤痕累累。最常见的问题是，找出存在哪些方法（特别是在扭曲的深层层次中）和通常沉默的故障，如果你命名你的方法，那么基本班没有找到它。 4.</p><p> “Also the subclassing based design was a huge mistake” is probably the most-commonly uttered sentence in programming.</p><p> “也是基于子类的设计是一个巨大的错误”可能是编程中最常见的句子。</p><p>— Cory Benfield (@Lukasaoz)  April 6, 2017</p><p> -  2017年4月6日Cory Benfield（@Lukasaoz）</p><p>  I use subclassing for code sharing only if I need to bend the behavior of a class  that I don’t control. I consider it a less egregious type of   monkey patching. Usually it’s better to write an   Adapter,   Facade,   Proxy, or   Decorator, but there are cases where the amount of methods that you’d need to delegate make that cumbersome if you want to change only a small detail  5.</p><p>  只有当我需要弯曲我不控制的类的行为时，我只使用子类别进行代码共享。我认为这是一种令人难以置恶的猴子补丁。通常最好编写适配器，门面，代理或装饰员，但有些情况下，您需要委派的方法的数量会使您想要仅更改一个小细节5。 </p><p>   Abstract Data Types (ADTs) are mainly for  tightening interface contracts. You want to be able to say that you want an object with certain properties (attributes, methods) and don’t care about the rest. In many languages they are called  interfaces which sounds a lot less pretentious, which is why I will be using that term from now on.</p><p>摘要数据类型（ADTS）主要用于收紧界面合同。您希望能够说您希望具有某些属性（属性，方法）的对象，并不关心其余部分。在许多语言中，它们被称为接口，这听起来不那么自命不凡，这就是为什么我从现在开始使用这个术语。</p><p> Since Python is dynamically typed and type annotations are strictly optional, you  don’t need formal interfaces. However, having a way to explicitly define an interface that you require for a piece of code to function is very useful. And since the advent of type checkers like   Mypy, they’ve become   verified API documentation, which I find wonderful.</p><p> 由于Python是动态键入的，并且键入注释是严格的可选，因此您不需要正式接口。但是，有一种方法可以明确定义一个代码函数所需的接口非常有用。自从像Mypy这样的类型跳棋的出现以来，他们已经成为验证的API文档，我找到了精彩。</p><p> For example, if you want to write a function that receives objects with a  read() method, you would somehow define an interface  Reader that has that method (the  how will be explained in a minute) and use it like this:</p><p> 例如，如果要编写带有read（）方法的对象的函数，则以某种方式定义具有该方法的接口读取器（如何在一分钟内解释）并将其使用如下：</p><p>  Your  printer() function doesn’t care what  read() is doing as long as it returns a string it can print. It can return a pre-defined string, read a file, or make a web API call.  printer() doesn’t care and your type checker will yell at you if you try to call any other method than  read() on it.</p><p>  只要它返回它可以打印的字符串，您的打印机（）函数不关心读取（）正在做的事情。它可以返回预定义的字符串，读取文件，或制作Web API调用。打印机（）不关心，如果您尝试调用任何其他方法，则将您的类型检查器对其喊叫。</p><p>   Abstract base classes (ABCs) are a less powerful version of   zope.interface and work using  nominal subtyping. They have been around since Python 2.6 and the standard library is  full of them.</p><p>   摘要基本类（ABCS）是Zope.Interface的强大版本，使用名义亚型。自从Python 2.6和标准图书馆充满了它们，他们已经存在。</p><p> Please note that not every abstract base class is also an abstract data type. Sometimes it’s just an  incomplete class that you’re supposed to complete by subclassing it and implementing its abstract methods – not an interface. The distinction is not always 100% clear though.</p><p> 请注意，并非每个抽象基类也是一种抽象数据类型。有时它只是一个不完整的课程，你应该通过对它进行对它进行组织并实现其抽象方法来完成 - 而不是接口。虽然，但区别并不总是100％。</p><p> Protocols avoid subclassing by using  structural subtyping. They have been added in Python 3.8, but   typing-extensions make them available as far back as Python 3.5.</p><p> 协议通过使用结构亚型来避免子类化。它们已在Python 3.8中添加，但键入 - 扩展使它们可用作Python 3.5。 </p><p> Nominal subtyping and  structural subtyping are big words, but fortunately they are straightforward to explain.</p><p>标称亚型和结构亚型是大词，但幸运的是他们很简单地解释。</p><p>  Nominal subtyping means you have to  tell the type system that your class is a subtype of an interface definition. ABCs usually do that via subclassing but you can use the   register() method too.</p><p>  标称子类型意味着您必须告诉类型系统，您的类是接口定义的子类型。 ABC通常通过子类化，但您也可以使用寄存器（）方法。</p><p> This is how you would define the  Reader interface from the introduction and mark  FooReader and  BarReader as implementations of it:</p><p> 这就是您如何将读者界面定义从介绍和标记Fooreader和Barreader的方式：</p><p> import  abc class  Reader ( metaclass = abc . ABCMeta ):  @abc . abstractmethod  def  read ( self )  -&gt;  str :  ... class  FooReader ( Reader ):  def  read ( self )  -&gt;  str :  return  &#34;foo&#34; class  BarReader :  def  read ( self )  -&gt;  str :  return  &#34;bar&#34; Reader . register ( BarReader ) assert  isinstance ( FooReader (),  Reader ) assert  isinstance ( BarReader (),  Reader )</p><p> 导入ABC类阅读器（Metaclass = ABC。ABCMETA）：@ABC。 AbstractMethod Def Read（Self） - ＆gt; str：... class fooreader（读者）：def读（self） - ＆gt; str：返回＆＃34; foo＆＃34;课程禁令：Def读（Self） - ＆gt; str：返回＆＃34;酒吧＆＃34;读者。注册（Barreader）断言（Fooreader（），读者）断言isinstance（Barreader（），读者）</p><p> If  FooReader didn’t have a method called read, instantiation would fail  at runtime. If you use the  register() route as with  BarReader, the interface is  not verified at runtime and it becomes a (as the docs call it) “virtual subclass”. This gives you the freedom to use more dynamic – or magical – means to provide the desired interface. Since  register() takes the implementing object as its argument, you can use it as a class decorator and save yourself two empty lines.</p><p> 如果Fooreader没有称为读取的方法，则实例化将在运行时失败。如果您使用寄存器（）路由与禁令者一样，则在运行时未验证接口，并且它将成为一个（作为文档调用它）“虚拟子类”。这为您提供了使用更多动态或神奇方式来提供所需接口的自由。由于register（）将实现对象作为其参数，您可以将其用作类装饰器并保存两个空行。</p><p> In nominal subtyping, multiple inheritance is not only accepted but  encouraged, because ideally no methods, no behaviors, are being inherited and hopelessly intermixed – only class identities are being compounded. A class can implement many different interfaces and the smaller an interface, the better.</p><p> 在标称亚型中，多重继承不仅被接受但鼓励，因为理想情况下没有任何方法，没有行为，并且无法遗传和绝望地混合 - 只有类别才会复制。一个类可以实现许多不同的接口和较小的界面，更好。</p><p>  One “upside” of using ABCs to define interfaces is that by subclassing them, you can smuggle in code sharing by adding regular methods to your abstract base class. But as mentioned at the beginning:  mixing subclassing types is a bad idea. Code sharing is a bad idea. Multiple inheritance makes it an extra bad idea. To be fair, I have seen good uses of this pattern, but you have to be very judicious with your approach.</p><p>  使用ABC来定义接口的一个“Upids”是通过对它们进行对它们进行对，可以通过将常规方法添加到抽象基类来分割代码共享中。但正如开始的那样：混合子类类型是一个坏主意。代码共享是一个坏主意。多重继承使它成为一个额外的坏主意。要公平，我已经看到了这种模式的良好用途，但你必须与你的方法非常明智。 </p><p>  Structural subtyping is  duck typing for types: if your class fulfills the constraints of a   Protocol, it is  automatically considered a subtype of it. Therefore, a class can implement  many  Protocols from all kinds of packages without knowing about them!</p><p>结构亚型是鸭键入类型：如果您的类满足协议的约束，则会自动被认为是它的子类型。因此，一个类可以在不知道它们的情况下从各种包中实现许多协议！</p><p> By default, this only works with type checkers, but if you apply   typing.runtime_checkable(), you can also perform  isinstance() checks against them.</p><p> 默认情况下，这仅适用于类型检查器，但如果应用键入键入.Runtime_Checkable（），您也可以执行isInstance（）检查。</p><p>  from  typing  import  Protocol ,  runtime_checkable @runtime_checkable class  Reader ( Protocol ):  def  read ( self )  -&gt;  str :  ... class  FooReader :  def  read ( self )  -&gt;  str :  return  &#34;foo&#34; assert  isinstance ( FooReader (),  Reader )</p><p>  从键入导入协议，runtime_checkable @runtime_checkable类读者（协议）：def读取（self） - ＆gt; str：... class fooreader：def读（self） - ＆gt; str：返回＆＃34; foo＆＃34;断言isinstance（Fooreader（），读者）</p><p> As you can see:  FooReader doesn’t know that the  Reader protocol exists at all!</p><p> 正如您所看到的那样：Fooreader不知道读者协议存在！</p><p>  What I  really like about  Protocols is how it allows me to define what interface I  need completely non-intrusively and that definition can live along with the  consumer of the interface. That’s great when you have different implementations of the same interface in the same code base. For example you could have an interface  MailSender that sends an e-mail in production but just prints it to the console in development  6.</p><p>  我真正喜欢协议是如何定义我完全非侵入性的接口，并且该定义可以与接口的消费者一起定义。当您在同一代码库中具有不同的接口的不同实现时，这很好。例如，您可以在生产中发送电子邮件，但只需将其打印到开发6中的控制台。</p><p> Or if you only use a small subset of a third-party class and want to be explicit which subset that is. This is great (verified!) documentation and helps when implementing fakes for your tests.</p><p> 或者，如果您只使用第三方类的小子集，并且希望明确哪个子集。这是伟大的（验证！）文档，并在为测试实施假货时帮助。</p><p> For more details on  Protocols and  structural subtyping, check out  glyph’s   I Want A New Duck.</p><p> 有关协议和结构亚型的更多详细信息，请查看雕文，我想要一只新鸭。 </p><p> While this type of subclassing is  mostly harmless, you  don’t need subclassing for abstract data types in Python thanks to  typing.Protocol and ABCs’s  register() methods.</p><p>虽然这种类型的子类化大多是无害的，但由于键入，因此您不需要对Python中的抽象数据类型进行子类化.Ptotocol和ABCS的register（）方法。</p><p>  So we’ve had one subclassing type that’s harmful and one subclassing type that’s unnecessary. Now we’ve reached the good type. In fact, you can’t get around this kind of inheritance in Python even if you wanted. Unless you want to stop using  Exceptions.</p><p>  所以我们有一个对余额的子类型，这是一个不必要的余额。现在我们已经达到了好类型。事实上，即使你想要，你就无法绕过Python的这种继承。除非您想停止使用异常。</p><p> Interestingly, specialization is often misunderstood. Intuitively it’s easy: if we say that a class B specializes base class A, we say that class B is A with  additional properties. A dog is an animal. An A350 is a passenger airplane. They have all the properties of their base class(es) and  add attributes, methods, or just a place in a hierarchy  7.</p><p> 有趣的是，专业化往往误解了。直观很容易：如果我们说B类专门为基础A类，我们说B类是具有额外属性的。一只狗是一种动物。 A350是乘客飞机。它们具有其基类的所有属性，并添加属性，方法或在层次结构中的一个位置。</p><p> Despite this alluring simplicity, it’s often used incorrectly. The most notorious mistake is saying that a square is a specialization of a rectangle, because geometrically, it  is a special case. However,  a square is not a rectangle  plus more.</p><p> 尽管这种诱人的简单性，但它经常使用不正确。最臭名昭着的错误说明，广场是矩形的专业化，因为几何上，这是一个特殊的情况。但是，一个正方形不是矩形加上更多。</p><p> You can’t use a square everywhere where you can use a rectangle, unless the code  knows that it has to expect a square too  8. If you can’t interact with an object as if it’s an instance of its base class, you’re violating the   Liskov substitution principle  9 and you can’t write  polymorphic code.</p><p> 除非代码知道它必须期望一个正方形，否则您无法使用矩形的广场。如果您无法与对象进行交互，就像它是其基类的实例一样，那么您重新侵犯LISKOV替换原则9，您无法编写多态代码。</p><p> If you look closely, you realize that interfaces from the previous section are a special case of specialization. You always specialize an generic API contract into something  concrete! The key difference is that abstract data types are…well…abstract.</p><p> 如果您仔细观察，您会意识到前一节的接口是专业化的特殊情况。您始终将通用API合同专门为混凝土！关键差异是抽象数据类型是......嗯......摘要。</p><p>  I find specialization extremely useful when I’m trying to represent  data that is strictly hierarchical.</p><p>  当我尝试代表严格分层的数据时，我发现专业化非常有用。 </p><p> For instance, imagine you want to represent e-mail accounts as classes. They all share some data like their ID in the database and the address, but then – depending on the type of the account – they (can) have additional attributes. Importantly, these added attributes and methods change little to nothing of the existing ones. For example, a mailbox that stores e-mails on the server needs login information in form of a password hash. An account that accepts e-mails and only forwards them to an another e-mail address does not  10.</p><p>例如，想象一下，您希望将电子邮件帐户表示为类。它们都在数据库和地址中与其ID一起分享一些数据，但是 - 根据帐户的类型 - 它们（CAN）具有额外的属性。重要的是，这些添加的属性和方法几乎没有于现有的属性。例如，存储服务器上电子邮件的邮箱需要密码哈希的形式登录信息。接受电子邮件的帐户，只将它们转发到另一个电子邮件地址不10。</p><p>    class  Mailbox :  id :  UUID  addr :  str  pwd :  str class  Forwarder :  id :  UUID  addr :  str  targets :  list [ str ]</p><p>    类邮箱：ID：UUID ADDR：STR PWD：STR类转发器：ID：UUID ADDR：STR目标：列表[str]</p><p> The address type is encoded in the class and each class has only the fields it uses. And if your model is this simple, this would  absolutely be the way to go. Any attempts at de-duplication only make sense if you have  many more fields and more types.</p><p> 地址类型在类中编码，每个类仅具有它使用的字段。如果你的模型很简单，这绝对是去的方式。如果您有更多的字段和更多类型，则在重复重复的任何尝试都只有意义。</p><p> Any method that you’d add to either class would be completely independent from the other – leaving no room for confusion. You can also use these classes with a type checker using the  Union type:  Mailbox | Forwarder.</p><p> 您添加到任一类的任何方法都将完全独立于另一个 - 留下困惑的空间。您还可以使用union类型的类型检查程序使用这些类：邮箱|转发器。</p><p>  Usually it’s a good idea to start with this approach  in any case because   duplication is far cheaper than the wrong abstraction. Seeing all possible fields in front of you makes further design decisions a lot easier.</p><p>  通常在任何情况下以这种方法开始这种方法是一个好主意，因为复制比错误的抽象更便宜。看到您面前的所有可能的字段更容易更轻松地进行更轻松的设计决策。</p><p>   This is a design that you might end up with when you try to avoid inheritance at all cost, but still avoid repeating yourself:</p><p>   这是一种设计，当您尝试避免所有成本的遗产时，您可能最终会结束，但仍然避免重复自己：</p><p> class  AddrType ( enum . Enum ):  MAILBOX  =  &#34;mailbox&#34;  FORWARDER  =  &#34;forwarder&#34; class  EmailAddr :  type :  AddrType  id :  UUID  addr :  str  # Only useful if type == AddrType.MAILBOX  pwd :  str  |  None  # Only useful if type == AddrType.FORWARDER  target :  list [ str ]  |  None</p><p> class addrtype（枚举。枚举）：邮箱=＆＃34;邮箱＆＃34;转发器=＆＃34;转发器＆＃34; Class EmailAddr：类型：addrtype ID：uuid addr：str＃只有在type == addrtype.mailbox pwd：str | none＃只有在incy == addrtype.forwarder target：list [str] |没有任何 </p><p> Technically, this is more  DRY, but it makes the  usage of the instances of the class a lot more awkward. The type/existence of most fields entirely depend on the value of the  type field, which only exists because all address types share the same class type.</p><p>从技术上讲，这更干燥，但它使课堂的情况使用更加尴尬。大多数字段的类型/存在完全取决于类型字段的值，它只存在，因为所有地址类型都共享相同的类类型。</p><p> It contradicts my favorite design principle to make  illegal state unrepresentable and is impossible to sensibly check using a type checker, which would complain about accessing  None-able fields all the time.</p><p> 它与我最喜欢的设计原则相矛盾，使非法状态不可思议，并且不可能使用类型检查器明智地检查，这将抱怨一直访问不可能的字段。</p><p> The fact that all behavior working on this class would be lumped together leads to a lot of conditions ( if- elif- else statements) that increase the complexity of your code significantly. The whole point of polymorphism is to avoid that.</p><p> 所有在此类上工作的行为都将被列入大量条件（IF-ELIF  -  else语句），这会显着提高代码的复杂性。全态的整点是避免这种情况。</p><p> Having optional attributes  11  is potentially a red flag. Having fields that need a  comment to explain  when to use them is a  May Day Rally. As controversial type annotations are, in this case they clearly point out to you that there’s a problem with your models. Without them, you’d have to notice that your code is more complex than it should be, which isn’t as straight-forward.</p><p> 具有可选属性11可能是一个红旗。拥有需要评论的字段来解释何时使用它们是五月一天的集会。由于争议类型的注释是，在这种情况下，他们显然指出了您的模型存在问题。如果没有它们，您必须注意到您的代码比应该的代码更加复杂，这不是直截了当的。</p><p>  You can make the situation a bit less painful and move mailbox-specific data into a class and make just  that field optional. It’s better but still unnecessarily clunky.</p><p>  您可以使情况更少疼痛，将邮箱特定数据移动到类中，并使该字段可选。它更好但仍然不必要的笨重。</p><p>  This approach inverts the last one and looks silly with our overly simplistic data model, but let’s just pretend that  EmailAddr has many more fields such that it’s worth being wrapped into an own class:</p><p>  这种方法将最后一个反转并与我们过于简单的数据模型看起来很傻，但是让我们假装EmailAddr有更多的领域，使得值得被包装为自己的课程：</p><p> class  EmailAddr :  id :  UUID  addr :  str class  Mailbox :  email :  EmailAddr  pwd :  str  class  Forwarder :  email :  EmailAddr  targets :  list [ str ]</p><p> Class EmailAddr：ID：UUID ADDR：STR类邮箱：电子邮件：EmailAddr PWD：Str类转发器：电子邮件：EmailAddr目标：列表[str] </p><p> This approach is not that bad! We’ve got no optional fields and all data relationships are clear. As readability and clarity goes, there’s nothing to complain about.</p><p>这种方法并不那么糟糕！我们没有任何可选字段，所有数据关系都很清楚。随着可读性和清晰度，没有什么可以抱怨的。</p><p> Except that it’s also very clunky and you don’t need to consult Guido to realize that it’s everything but Pythonic. So why does it look so contrived, although composition is supposed to be better than inheritance?  EmailAddr and  Mailbox/ Forwarder are  too closely related – it’s even awkward to name the field to store it. Composition isn’t failing us, but  in this case forcing an has-a relationship feels like going against the grain.</p><p> 除了它也是非常笨重的，你不需要咨询Guido来意识到这是一切而是蟒蛇。那么为什么它看起来如此思考，虽然构成应该比遗传更好？ EmailAddr和邮箱/转发器太密切相关 - 命名字段甚至尴尬地存储它。作文并没有失败我们，但在这种情况下强迫一个人的关系感觉就像违反谷物。</p><p> But it’s useful to show us something about our models: they all have common base information and are closely related. So let’s go the final step and use Python’s way of sharing a common base and use specialization by subclassing. We will come back to composition when I improve the design of a subclassing-based design in a later section of this article.</p><p> 但向我们展示我们的模型很有用：它们都有共同的基础信息并密切相关。因此，让我们走出最后一步，并使用Python的方式共享公共基础并通过子类化专业。当我在本文的后续部分中提高基于子类设计的设计时，我们将回到作文。</p><p>  Finally, the approach that’s in my opinion most ergonomic, DRY, obvious, and feasible to type check:</p><p>  最后，在我看来的方法最符合人体工程学，干燥，明显，可行的类型检查：</p><p>  Whenever you have a  Mailbox, you  know you have a  pwd field – and so do your type checkers. The type is encoded in the class, so you don’t have to repeat it in a field. A  Mailbox strictly  is an  EmailAddr  plus more.</p><p>  每当您有一个邮箱时，您就知道您有一个PWD字段 - 等等。该类型在类中编码，因此您不必在字段中重复它。邮箱严格是ModeAddr加上更多。</p><p> As for code, you now have to be aware of the  rules of responsible subclassing like the aforementioned   Liskov substitution principle. This  is additional complexity and mental overhead, but the boundaries and responsibilities are much clearer.</p><p> 至于代码，您现在必须了解对上述LISKOV替代原则的负责任子类的规则。这是额外的复杂性和精神开销，但边界和责任都更加清晰。</p><p> Reading clarity suffers as with all kinds of subclassing, because you have to assemble the final class in your head to know what fields exist. But effectively you get the same classes like in the first approach. As long as you don’t overdo it and ideally keep the definitions physically close to each other, it’s the best trade-off in situations like this.</p><p> 阅读清晰度与各种子类一样受到各种子类，因为您必须组装最终类以了解存在的字段。但有效地在第一种方法中获得了相同的课程。只要你没有过度，理想地保持身体彼此的定义，这是在这样的情况下最好的权衡。 </p><p> It’s so useful that I’ve  used it in my  parsing library for PEM files and have yet to regret it.</p><p>我在我的解析库中为PEM文件中使用它是如此有用，但尚未后悔。</p><p>  A general advice to derive from this section is to always focus on the  shape of your data  first and only  then what to do with it.</p><p>  从本节中派生的一般建议是首先始终关注数据的形状，只有那么与之有关。</p><p> Once you have the shape nailed down, the behavior comes much more naturally. A good example of that is the   Sans I/O movement that is unequivocally  data first, since the behavior is supposed to be replaceable  by design.</p><p> 一旦你的形状钉下了，行为就会变得更加自然。一个很好的例子，这是一个不确定数据的SAN I / O运动首先，因为该行为应该是通过设计替代的。</p><p> As long as you avoid cross-hierarchy interactions between methods while specializing, you should be fine. But always ask yourself if a  function wouldn’t be enough –  especially if you’re coordinating work between two or more classes and there’s no polymorphism to take advantage of. If you can’t decide what class a method belongs to, the answer is often  neither.</p><p> 只要你避免在专业化时方法之间的交叉层次结构，你应该没问题。但总是问自己，如果一个函数是不够的 - 特别是如果你正在协调两个或更多课程之间的工作，并且没有多态性来利用。如果您无法确定方法所属的类，答案通常都不是。</p><p> Finally make sure to learn about   @singledispatch; it will feel like magic if you haven’t yet.</p><p> 最后一定要了解@singledispatch;如果你还没有，它会觉得魔法。</p><p>   The last approach is so useful that it sneaked into we-don’t-subclass  Go under the moniker of   embedding:</p><p>   最后一个方法是如此有用，即它潜入我们的勿忘映射下的emiddation：</p><p>  Instances of  Mailbox now have an attribute  addr as if it was defined within it:  https://play.golang.org/p/WSjJA6MYUDb. But you still have to be explicit  when initializing and there’s no actual  hierarchy. There’s n</p><p>  邮箱实例现在具有属性addr，就好像它在其中定义了：https://play.golang.org/p/wsjja6myudb。但初始化时，您仍然必须明确，并且没有实际层次结构。有n </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hynek.me/articles/python-subclassing-redux/">https://hynek.me/articles/python-subclassing-redux/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类化/">#类化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>