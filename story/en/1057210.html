<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>黎明（第1部分） Dawn (Part 1)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dawn (Part 1)<br/>黎明（第1部分） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 12:10:09</div><div class="page_narrow text-break page_content"><p>Allow me to introduce you to Dawn, a work-in-progress programming language. I amdesigning Dawn to be a practical, general-purpose programming language thatcombines the factorability of  Forth, the purity and expressivenessof  Haskell, and the performance and control of  C,with safety and correctness guarantees beyond those provided by Rust. Now, if you’re at all familiar with these languages, thenjust from reading that sentence you might have an inkling that I’m either acrackpot or painfully naive. If you did, then I applaud your skepticism.Nonetheless, I believe I have glimpsed a path to this seemingly impossibleconfluence of properties, and in this series of blog posts I hope to share atleast a part of that vision with you.</p><p>请允许我向您介绍黎明，这是一名工作进度的编程语言。我是一种实用，通用的编程语言，即Haskell的纯洁和表达性的实用，通用编程语言，以及C的性能和控制，安全性和正确性保证了Rust提供的那些。现在，如果你熟悉这些语言，那么只需阅读那句话，你可能会有一个墨水，即我要么是accrackpot或痛苦的天真。如果你这样做，那么我赞扬了你的怀疑主义。无论如何，我相信我已经瞥见了这个看似不可能的属性的道路，并且在这一系列博客帖子中我希望与你共享这一愿景的一部分。</p><p> In order to properly motivate the choices made in Dawn, we’ll talk about each ofthese four languages, how they achieve these remarkable properties, and how wecan leverage their strengths and temper their weaknesses, starting with Forth.</p><p> 为了适当地激励在黎明中制造的选择，我们将谈论四种语言，如何实现这些非凡的属性，以及Wecan如何利用他们的优势和脾气暴躁，从而开始。</p><p> Forth is a remarkably small and simple programming language in which functionsare defined as a sequence of operations on a stack. In Forth, functionparameters are not given names. Instead, parameters are implicitly passed viathe stack. This results in highly factorable and refactorable code, sincefunctions can be trivially split and recombined along any syntactic boundary. According to Chuck Moore, Forth’s original designer, thisfactorability is the defining characteristic of Forth:</p><p> FART是一种非常小而简单的编程语言，其中功能定义为堆栈上的一系列操作。在第四，功能参数不是给出的名称。相反，参数通过堆栈隐式传递。这导致高度重置和可重构的代码，因为可以沿任何句法边界分开和重新组合。根据Chuck Moore，Forth的原始设计师，实践性是定义特征：</p><p> Forth is highly factored code. I don’t know anything else to say, except thatForth is definitions. If you have a lot of small definitions, you are writingForth. In order to write a lot of small definitions, you have to have a stack.</p><p> 是高度考虑的代码。除非是定义，我还不知道别的话说。如果您有很多小定义，则您正在写入福可中。为了编写大量的小定义，你必须有一个堆栈。</p><p> Another, more general, way to describe such a programming language is to say itis  concatenative. Concatenative programming languages are closely relatedto  combinatory logic, which is further closely related to the  APLfamily of programming languages. The common thread among all of these is theconcept of “point-free” or  “tacit” programming, in which functions aredefined entirely as the composition of other functions.</p><p> 另一个，更一般，描述这种编程语言的方式是说ITIS连接。连接性编程语言与组合逻辑密切相关，这与编程语言的APLFIMINGE相对相关。所有这些中的常见线程是Concept的“无点”或“默契”编程，其中函数完全作为其他功能的组成。</p><p> Unfortunately, this style of programming has historically come with a fewdisadvantages. First, the strict ordering of values on the Forth stacknecessitates some minimum amount of stack shuffling, which can be tedious anderror prone and obscure the meaning of programs. Second (and related), as anyonewho has tried to understand someone else’s Forth or APL code can attest, thelack of parameter and value names can lead to what is often called “write-onlycode”—that is, code that is prohibitively difficult to read andunderstand. Finally, concatenative and tacit programming languages havehistorically, almost universally, been weakly or dynamically typed, which, insome respects, limits their refactorability when compared to strong staticallytyped languages.</p><p> 不幸的是，这种规划风格历史上有几个态度。首先，严格的数值排序到第四次是最少的堆栈混洗数量，这可能是乏味的andError容易发生，掩盖程序的含义。第二（和相关），因为任何人都试图了解别人的别人或APL代码可以证明，那个参数和价值名称可以导致经常被称为“写入次代码” - 这是，对难以读取的代码难​​以阅读andunderstand。最后，与强大的统计学语言相比，结束和默塞特编程语言几乎普遍地宣传，几乎普遍地普遍地逐步打字，这绝对地限制了它们的重新读取性。</p><p> Most of these advantages and disadvantages are well described by Jon Purdy in his 2012blog post titled  “Why Concatenative Programming Matters”,which I highly recommend stopping to read right now, before you continue readingbelow. In the section titled “The Dark Side”, Jon gives an example oftranslating the following function, given in traditional mathematical notation,</p><p> 这些优势和缺点中的大部分是由Jon Purdy在他的2012Blog帖子中阐述的，标题为“为什么连接规划事项”，在继续阅读读物之前，我强烈推荐停止读取。在标题为“黑暗面”的部分中，JON举例说明了传统的数学符号中的以下功能的示例， </p><p>    For anyone familiar with traditional mathematical notation, the meaning of thefirst definition will immediately be quite clear. In contrast, even to someoneextremely familiar with the meaning of each of the terms in the concatenativedefinition, the overall meaning of the definition is obscured by the presence ofvarious stack shuffling terms, namely  drop,  dup,  swap, and  rot3. Thesituation is significantly improved by refactoring the concatenative notation touse a newly defined  square function and the higher-order functions  bi and dip:</p><p>对于熟悉传统数学符号的人来说，渠道定义的含义将立即非常清楚。相比之下，甚至有人熟悉所在阶段中的每个术语的含义，定义的整体含义被不多的堆栈混洗术，即掉落，杜普，交换和rot3模糊。通过重构连接符号效果新定义的方形函数和高阶函数BI和DIP来显着提高介绍：</p><p>  But, the underlying meaning is still not as immediately clear as it is for thetraditional mathematical notation.</p><p>  但是，潜在的含义仍然没有立即明确，因为它是对分子数学符号的影响。</p><p> Upon recognizing this distinct and persistent disadvantage to concatenativenotation, many concatenative programming language designers, such as SlavaPestov, the designer of  Factor, and Jon Purdy, the designer of Kitten, decided to include an escape hatch—a way to bindvalues to local named variables. Unfortunately, this breaks one of the primaryadvantages of concatenative notation: that functions can be trivially split andrecombined at any syntactic boundary—i.e. their factorability.</p><p> 在认识到这种不同和持续的抵消对支援的缺点时，许多连接性编程语言设计师，例如SlavaPestov，因子设计师和小猫的设计者Jon Purdy，决定包括逃生舱口 - 一种对本地命名变量的方法。遗憾的是，这部分地破坏了连接性符号的初级态度之一：可以在任何句法边界-1中逐渐分裂函数。他们的因子。</p><p> In Dawn, I have taken a novel approach that retains factorability. Rather thanavoiding stack shuffling by assigning values to local named variables, a Dawnprogrammer may make use of an arbitrary number of arbitrarily named stacks. InDawn, the function  f(x, y, z) = y² + x² − |y| might be defined like this:</p><p> 在黎明时，我采取了一种重大保留因子的新方法。通过将值分配给本地命名变量而不是为vavoiding stackling而不是，dawnprogrammer可以使用任意数量的任意命名堆栈。 Indawn，功能f（x，y，z）=y²+x² -  | y |可能是如此定义：</p><p> {fn square =&gt; clone mul}{fn f =&gt; {spread $x $y $z} {$z drop} {$y clone square pop} {$x square pop} add {$y abs pop} sub}</p><p> {Fn Square =＆gt;克隆mul} {fn f =＆gt; {Spread $ x $ y $ z} {$ z drop} {$ y clone square pop} {$ x square pop}添加{$ y abs pop} sub}</p><p>  First, the definition of  square is quite straightforward. It  clones thevalue on the top of the current stack and then  multiplies the top two values,leaving their product on top of the current stack. This is the same as thedefinition  square =&gt; dup ×, given above, just with  clone instead of  dupand  mul instead of  ×.</p><p>  首先，方形的定义非常简单。它克隆当前堆栈顶部的Value，然后将顶部两个值乘以，将其产品留在当前堆叠的顶部。这与中锋广场=＆gt;杜普×，上面给出的，只需克隆而不是杜帕和MUL而不是×。</p><p>  {spread $x $y $z} is syntactic sugar  1 that takes the top 3 values from thecurrent stack (the stack from which  f was called) and spreads them to thestacks  $x,  $y, and  $z, respectively, with the top-most (right-most)value going to  $z.</p><p>  {Spread $ x $ y $ z}是句法糖1，它从ChiCurrent堆栈中取出前3个值（被称为F的堆栈）并分别将它们传播到x，$ y和$ z，其中最高（最右）的价值达到$ z。 </p><p> {$z drop} drops the value from the top of the  $z stack. That value isthen permanently gone. (It’s passed on! It is no more! It has ceased to be!)</p><p>{$ z drop}从$ z堆栈的顶部删除值。那个价值是永久消失的。 （它通过了！它不再是！它已经停止了！）</p><p> {$y clone square pop} clones the value at the top of the  $y stack,squares it, and then pops the square off the  $y stack onto the currentstack.</p><p> {$ y clone square pop}克隆$ y堆栈顶部的值，平方体，然后将正方形从$ y堆栈上弹出到CusterStack上。</p><p> {$x square pop} squares the value at the top of the  $x stack and thenpops the square off of the  $x stack onto the current stack.</p><p> {$ x square pop}将$ x堆栈顶部的值与$ x堆栈的正方形正方形方块在当前堆栈上。</p><p> add takes the top two values from the current stack, adds them together,and leaves the sum on top of the current stack.</p><p> 添加从当前堆栈中取出顶部两个值，将它们放在一起，并在当前堆栈的顶部离开总和。</p><p> {$y abs pop} takes the remaining value from the top of the  $y stack,takes the absolute value of it, and then pops the absolute value off the  $ystack onto the current stack.</p><p> {$ y abs pop}从$ y堆栈的顶部取下剩余值，取出它的绝对值，然后将$ ystack从$ ystack上弹出到当前堆栈上。</p><p> sub takes the top two values from the current stack, subtracts theright-most from the left-most, and leaves the difference on top of thecurrent stack.</p><p> 子来自当前堆栈的顶部两个值，从左侧减去大多数大多数，并留下差异堆叠的差异。</p><p> While this Dawn translation is certainly more verbose than the traditionalmathematical notation, I hope you can see (now that I have explained what eachterm means) that it is a fairly direct syntactic translation, and that theoverall meaning is nearly as clear as it is for the traditional mathematicalnotation. The additional verbosity in the Dawn translation is due, in largepart, to all functions in Dawn being  linear, in the sense of  linearlogic—that is, every value is used exactly once. In orderto simulate using a value less than or more than once, the combinators  dropand  clone must be used, which increases verbosity. However, as we’ll seelater, when we talk about Haskell, C, and Rust, the inherent linearity ofconcatenative notation is another major motivation for making Dawn aconcatenative programming language—the price paid in increased verbosityin this example is more than made up for by the dividends of performance,control and reduced verbosity in other examples.</p><p> 虽然这个黎明翻译肯定比传统的传统符号更冗长，但我希望你能看到（现在我已经解释了每个人的手段），这是一个相当直接的句法翻译，而Theoverall意思几乎可以清楚地清楚传统的数学。黎明翻译中的额外冗长是在大型方面到期的，到黎明的所有功能都是线性的，在LineAregic的意义上 - 也就是说，每个值都是一次使用一次。为了使用少于或多于一次的值模拟，必须使用组合物滴克隆，这增加了冗长。然而，当我们谈论Haskell，C和Rust时，谈论黎明的催化符号的固有线性度是制作黎明宣传的编程语言的另一个主要动力 - 在增加的媒体上支付的价格不仅仅是由在其他例子中表现，控制和冗长的股息。 </p><p> Furthermore, though it may not be immediately obvious, this function definitioncan be trivially split and recombined at any valid syntactic boundary. To beclear, it would not be valid to start with  {$y clone square pop} {$x square pop}and extract  square pop} {$x square into a helper function. It is not valid tosplit nested curly brace pairs. However, you could easily refactor {$y clone square pop} {$x square pop} into {$y clone} {$y square} $y-&gt; {$x square} $x-&gt;(where  $y-&gt; and  $x-&gt; are syntactic sugar for  {$y pop} and  {$x pop}),and then it would be perfectly valid to extract  {$y square} $y-&gt; {$x square}into a helper function.</p><p>此外，尽管它可能不立即显而易见，但是这种函数定义扫描被术语分裂并在任何有效的句法边界处重新组合。要成为{$ y克隆广场pop} {$ x square pop}和提取square pop} {$ x square进入辅助功能，它不会有效。它没有有效的tosplit嵌套卷曲支撑对。但是，您可以轻松地重新推荐{$ y clone square pop} {$ x square pop}进入{$ y clone} {$ y square} $ y-＆gt; {$ x square} $ x-＆gt;（其中$ y-＆gt;和$ x-＆gt;是{$ y pop}和{$ x pop}的句法糖，然后它将完全有效地提取{ $ y square} $ y-＆gt; {$ x square}进入辅助功能。</p><p> In Dawn, there are no local variables to hoist out or rename—there areonly functions that operate on named stacks. Conceptually, these named stackscan be considered to be different parts of one big multi-stack. In Forth,functions are defined as a sequence of operations on a stack… except for thefunctions with side effects, such as setting a global variable or performinginput or output. In Dawn, every function is defined as a sequence of operationson a multi-stack. There are no exceptions.</p><p> 在Dawn中，没有局部变量呼吸或重命名 - 那里的函数在命名堆栈上运行。概念上，这些命名的StackScan被认为是一个大多数堆栈的不同部分。在阶段，函数被定义为堆栈的一系列操作...之外，除了具有副作用的功能，例如设置全局变量或执行intopput或输出。在黎明时，每个功能都被定义为多堆栈的一系列操作。没有例外情况。</p><p> In the next post, we will talk about Haskell and see how it’s possible for thereto be no exceptions to this rule—that is, how Dawn, like Haskell, is a purely functional language, and why you should care. We’llalso see how we can further enhance the refactorability of Dawn beyond that of(the vast majority of) existing concatenative programming languages throughstrong, static, inferred types. And finally, we’ll begin to see why the inherentlinearity of concatenative notation is well worth the cost of occasionallyincreased verbosity.</p><p> 在下一个帖子中，我们将谈论Haskell，看看它是如何对此规则的例外情况 - 也就是说，像Haskell一样黎明是一种纯粹的功能语言，以及你应该关心的原因。我们会看到我们如何进一步提高黎明的重构，超出了（绝大多数）现有的连接性编程语言，静态，推断的类型。最后，我们将开始看看为什么连接符号的固有线性非常值得偶尔增加冗长的成本。</p><p>    In the current  Dawn Phase 1 prototype, {spread $x $y $z} is trivially expanded by the front-end into ($s1&lt;- $s2&lt;- $s3&lt;-) ($s3-&gt; $x&lt;-) ($s2-&gt; $y&lt;-) ($s1-&gt; $z&lt;-).  ↩︎</p><p>    在目前的黎明阶段1原型中，{Spread $ x $ y $ z}通过前端进入（$ s1和s2＆lt; $ s3＆lt; $ s3＆lt; $ s3＆lt; $ x x＆lt;  -  $ s3 $ y $ z} ）（$ s2-＆gt; $ y＆lt ;-）（$ s1-＆gt; $ z＆lt; -)。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.dawn-lang.org/posts/introducing-dawn-(part-1)/">https://www.dawn-lang.org/posts/introducing-dawn-(part-1)/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/黎明/">#黎明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dawn/">#dawn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/定义/">#定义</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>