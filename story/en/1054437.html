<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>诚实的微服务 Honest Microservices</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Honest Microservices<br/>诚实的微服务 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 20:14:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/5d00be61a292956124167ca7613e886f.jpg"><img src="http://img2.diglog.com/img/2021/3/5d00be61a292956124167ca7613e886f.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Recently there was a  discussion in the tech community, &#34;Why SOLID is all wrong&#34;. We have these discussions every few years or so, and about every imaginable aspect of creating technology.</p><p>最近在科技界讨论，＆＃34;为什么扎实是错误的，而＃34;我们每年左右都有这些讨论，以及创造技术的每个可想象的方面。</p><p>  Have you seen this new thing called X? It&#39;s like Y only with more coolness.</p><p>  你见过这个新的东西叫x吗？它＆＃39; y只是更酷的y。</p><p> We re-brand the same old topics different ways, then come back to the same discussion, only using different terms and slightly-different types of X. (But this X is NOTHING like that old X. This is actually Y.)</p><p> 我们重新品牌相同的旧主题不同的方式，然后回到同一讨论，只使用不同的术语和略有不同类型的x。（但是这个x就像那个旧的x。这实际上是y。）</p><p> I have never seen us go through such a cycle where things got simpler. Each cycle through always involves new books, new consultants, new conferences, new user groups. No matter whether the problem being fixed is big or small, no matter whether the average developer needs the new fix or not, each loop through always gets more complex.</p><p> 我从未见过我们经历这样一个循环，事情变得更简单。每个周期都始终涉及新的书籍，新顾问，新会议，新用户组。无论解决的问题是大的还是小，无论平均开发人员是否需要新的修复，每个循环都会始终变得更加复杂。</p><p> Hyperbolic, ranting essays about loving or hating something get noticed. Reasoned discussions that progress over time do not. Such is the way of the web. As one observer put it, &#34;I&#39;m done with essays titled &#39;I tried Microservices and it ruined my marriage!&#39;&#34; There&#39;s far too much drama, and when you try to pin people down on foundations, there&#39;s also far too much hand-wavy &#34;Just write simple code&#34;, and &#34;Keep your code clean&#34;. These are platitudes, not applied foundational theory in which to build technology systems.</p><p> 双曲线，咆哮关于爱或讨厌的东西被注意到的东西。随着时间的推移，讨论的讨论不会。这就是网的方式。作为一个观察者，＆＃34;我完成了标题＆＃39;我尝试了微服务和它毁了我的婚姻！＆＃39;＆＃34;＆＃34; ＆＃39;太多的戏剧，当你试图把人们放在基础上，那里有太多的手摇＆＃34;只是写简单的代码＆＃34;和＆＃34;保持您的代码清洁＆＃34;。这些是陈词滥调，而不是应用技术系统的基础理论。</p><p>  If you&#39;ve been following along with the books and blog essays, you know we&#39;ve built a theoretical foundation for both analysis and design, both the process of reasoning about what to code, and organizing the code itself. One thing naturally leads to another, and before you know it you have a way of coding that involves neither slogans nor homilies.</p><p>  如果你和书籍和博客散文一起举行了，你就会知道我们的理论基础，为分析和设计构建了一个理论基础，这两个方法都是关于编码的方式，并组织代码本身的过程。有一件事自然地导致另一件事，并且在你知道它之前，你有一种编码方式，既不涉及口号也不是荷兰。</p><p> In general, it&#39;s been  Info-Ops I (what to build), followed by  Info-Ops 2 (how to build it). They both used the same underlying theory. Info-Ops 2 introduced  Code Cognitive Load. This led naturally to  Incremental Strong Typing. CCL could be used no matter how you code. IST could be used in most environments but naturally pushed you into a certain style of coding.  One logically follows the other, and we end up at Honest Microservices.</p><p> 一般来说，它＆＃39; s是信息 -  ops i（建立什么），其次是INFO-OPS 2（如何构建它）。他们都使用了相同的潜在理论。 INFO-OPS 2引入了代码认知负载。这自然导致增量强大打字。无论您如何代码如何，都可以使用CCL。 IST可以在大多数环境中使用，但自然会将您推入某种程度的编码。一个逻辑上遵循另一个，我们最终得到诚实的微服务。 </p><p> Key point: I did not start off with the intention of inventing or talking about anything new. I simply wanted an underlying self-consistent logical theory that would cover all aspects of technology development. Developing that forced me here. (Much against my will)</p><p>关键点：我没有开始发明或谈论任何新的东西。我只是想要一个潜在的自我一致的逻辑理论，将涵盖技术发展的各个方面。在这里强迫我的发展。 （很多反对我的意志）</p><p>  Why the word &#34;honest&#34; in the title? Because once the buzzword &#34;microservices&#34; became popular a long time back, the cycle of bullshit began again. By now the term is so polluted that good luck trying to have a conversation about it. Here are things that are not honest microservices:</p><p>  为什么这个词＆＃34;诚实＆＃34;在标题中？因为曾经是流行语＆＃34;微服务和＃34;很长一段时间后，废话的周期开始了。到目前为止，这个术语如此污染，祝你有关于它的对话。以下是不是诚实的微服务：</p><p>  Development patterns where you deploy things into containers. You want containers,  do containers. Fine with me. Deployment decisions have nothing to with microservices. If you&#39;re coupling your code to the architecture that tightly, re-read #2.</p><p>  将您部署到容器中的开发模式。你想要集装箱，做容器。我都可以。部署决策无需微服务。如果您＆＃39;将代码耦合到架构中紧密，重新读取＃2。</p><p> Things with some cool language. Once again, if you like cool languages, use them. Sounds fun. It&#39;s just has nothing to do with microservices.</p><p> 一些酷语言的东西。再一次，如果你喜欢很酷的语言，请使用它们。听起来很有趣。它＆＃39;与微服务无关。</p><p> Systems with thousands of little tiny pieces of code scattered all over the place making it impossible to reason about anything. You&#39;re loving the idea to death. You&#39;ve gone too far the other way. Both the &#34;micro&#34; and &#34;service&#34; part are equally important.*</p><p> 拥有数千个小小的代码的系统散落在整个地方，使其无法理解任何东西。你＆＃39;喜欢死亡的想法。你＆＃39;除了另一种方式走得太远了。 ＆＃34;微＆＃34;和＃34;服务＆＃34;部分同样重要。*</p><p> Five is particularly interesting, as many proponents of microservices who actually have some idea of where they&#39;re going  end up here. That&#39;s why Incremental Strong Typing demands Honest Microservices: it teaches appropriate scoping and explains how the types of things inside your code (types of things, hardy har har. I&#39;m here all week, folks!) directly relate to and drive your scope -- and vice-versa. This isn&#39;t &#34;Do microservices because they&#39;re cool&#34;. This is &#34;You do CCL right, you do IST right, you&#39;re forced to actually start writing Honest Microservices&#34; (Although many resist this procedure for some time) There is no sales pitch or coolness. It just is.</p><p> 五个特别有趣，正如他们在这里最终结束的地方，那么许多微服务的许多同意者。那个＆＃39;为什么增量强大的打字要求诚实的微服务：它教授适当的范围，并解释了代码内的东西类型（物品类型，哈哈哈哈。我整个星期，人们在这里，人们都在这里，人们！）直接相关并推动你的范围 - 而反之亦然。这是不是＃39; T＆＃34;做微服务，因为它们＆＃39;重新酷＆＃34;这是＆＃34;你做了ccl吧，你做得对，你＆＃39;重申实际上开始写诚实的微兽和＃34; （虽然许多人抵制了这一程序一段时间）没有销售俯仰或凉爽。它只是。</p><p>  An app that cannot crash. It has a way to fail gracefully but that doesn&#39;t involve some downstream coder poking through your call stack.</p><p>  一个无法崩溃的应用程序。它有一种方式，优雅地失败，但这不涉及一些下游编码器通过呼叫堆栈戳戳。 </p><p> An app that does one and only one useful business function. What&#39;s that? See IST.</p><p>一个App，它只有一个且只有一个有用的业务功能。那是什么＆＃39;见Ist。</p><p>   An app that can be reasoned about, modified, or completely replaced by a maintenance programmer many years from now with little or no preparation.</p><p>   一个应用程序，可以在几年内从现在或没有准备的情况下使用维护程序员所遵守，修改或完全替换。</p><p>    These tests exist in a compilation unit separate from the app itself and are in no way coupled to it.</p><p>    这些测试存在于从应用程序本身分开的编译单元中，并且无法耦合到它。</p><p> When in doubt, think of your compiled app as a pure function running inside a program. That program is a plain, vanilla, default operating system.</p><p> 如有疑问，请将编译的应用程序视为在程序内运行的纯功能。该程序是平原，vanilla，默认操作系统。</p><p> Following these rules directly forces code into a shape that it easy to understand, manage, refactor, and discuss with business partners. Doing this involves no special hardware or deployment requirements. You can deploy the same set of apps thousands of times around the world or all on your local computer. Deployment has zero impact on code, and vice-versa. Congratulations. You&#39;ve reached the spot where DevSecOps are three equal concepts, instead of each of them fighting to take control from the other two.</p><p> 以下规则直接迫使代码变为易于理解，管理，重构和与商业伙伴讨论的形状。这样做涉及没有特殊的硬件或部署要求。您可以在全球范围内或全部在本地计算机上部署相同的应用程序集。部署对代码具有零影响，反之亦然。恭喜。你＆＃39; ve达到了Devsecops是三个平等概念的地方，而不是每个人都战斗，以控制其他两个。</p><p>  That&#39;s exactly what I would have if somebody had told me about this ten years ago. (My second objection is that it sounds like a chore and no fun at all. I love having fun coding, and this can be fun, but that&#39;s a discussion for another day)</p><p>  如果有人在十年前告诉我这一点，那么＃39;究竟是什么。 （我的第二个反对意见是它听起来像是一个苦差而且根本没有乐趣。我喜欢玩得开心的编码，这可能很有趣，但是讨论了另一天的讨论）</p><p> Here&#39;s the thing: if you&#39;ve followed the rules above, you&#39;ve solved your complexity problem as you coded the system. Tests are decoupled from the apps that fulfill them. When microservice A feeds microservices B and C which then feed a dozen more microservices, those un-typed, dynamic text feeds can be tested as a whole. Outputs have to work with inputs. Error paths can&#39;t exist without tests.</p><p> 这里的事情：如果你＆＃39;在上面的规则之后，你＆＃39;你解决了你编写了系统的复杂性问题。测试与实现它们的应用程序分离。当MicroService A Feeds MicroServices B和C然后馈送十几个微服务时，可以作为整体测试那些未键入的动态文本源。输出必须使用输入。错误路径可以＆＃39; t存在没有测试。 </p><p>    What do compilers do? They do a lot of things, but basically they organize the logical symbols and their relationship along with the data required such that the computer has the resources it needs to do the things the programmer wants it to do.</p><p>编译器做什么？他们做了很多东西，但基本上他们组织了逻辑符号及其关系以及所需的数据，使得计算机有需要执行程序员希望它的资源。</p><p> There&#39;s no reason that this has to result in a single deployment unit. In fact, that&#39;s been our entire shtick all along; if we decouple all the things and work only in small units, we can then re-arrange those units in any way we like. We can also maintain those units much easier.</p><p> 没有理由导致单个部署单元。事实上，＆＃39;一直是我们的整个小嘴巴;如果我们只用小单位脱钩并工作，我们可以以任何方式重新安排这些单位。我们还可以保持这些单位更容易。</p><p> If a normal compiler compiles to an executable, a supercompiler would compile to a cloud deployment. All of those considerations like database engines, scalability, load-balancing, health checks, certificates, pods, edge-computing strategies, CDNs, and so forth would exist as supercompiler options and config files.</p><p> 如果正常编译器编译为可执行文件，则超级媒体将编译为云部署。所有这些考虑因素，如数据库引擎，可伸缩性，负载平衡，运行状况检查，证书，豆科码，边缘计算策略，CDN等都将作为Supercompiler选项和配置文件存在。</p><p> We&#39;ve even got a model of how the innards of the compiler should work, how to assemble functions in a hot-swap, flexible way: the  Erlang OTP model. There&#39;s no reason that general way of working with live code wouldn&#39;t work with other languages now that we&#39;ve separated things out. A supercompiler even gives us a lot of other things, like a place to bolt in  TLA+ so that we don&#39;t run into concurrency issues.</p><p> 我们甚至得到了编译器内部应该如何工作的模型，如何以热插拔，灵活的方式组装功能：Erlang OTP模型。没有理由与实时代码一起使用的一般方式＆＃39;现在我们与其他语言一起使用，我们将事物分开。超级媒利员甚至给我们很多其他东西，就像一个在TLA +中螺栓的地方，所以我们不达到并发问题。</p><p> We should look at some sample code. We should build a primitive supercompiler. We should talk about where  OO and  SOLID and all of that other goodness comes into play (It  definitely does). But none of those discussions would have any common ground if we don&#39;t begin by recognizing that fundamental principles can drive technology development from idea to deployment, without involving a thousand context switches. I know this because that&#39;s how it happened the first time. The second time let&#39;s do it so we don&#39;t loop back through here again in ten years.</p><p> 我们应该查看一些示例代码。我们应该建立一个原始的超级媒体。我们应该谈谈OO和扎实的地方，以及其他善良都在发挥之中（绝对是这样）。但是，如果我们通过认识到基本原则可以从想法推动部署的技术开发，而不涉及一千个上下文交换，那么这些讨论都不会有任何共同之处。我知道这个是因为它第一次发生这种情况。第二次让＆＃39; s这样做，所以我们在十年内再次通过这里循环。</p><p> Keep it simple, write clean code, brush your teeth, make your code testable: in our business we&#39;re never at a lack of famous smart people giving motivational speeches trying to get us to do the right thing. They mean well. And these things are true as far as they go. They just don&#39;t go very far.</p><p> 保持简单，写清洁的代码，刷牙，让你的代码可测试：在我们的业务中我们从未缺乏着名的智能人，给我们做正确的言论。它们意味着好。据他们所以，这些事情是真实的。他们只是不要走得太远。</p><p> My dudes. We gotta break out of this infinite loop. Every cycle through we just continue making things (for the average user) needlessly more and more complex. Please, more making stuff people want and less one bunch of nerds marketing cool stuff to another bunch. Future generations will thank us.**</p><p> 我的帅哥。我们必须突破这种无限循环。每个循环通过我们只是继续制作东西（为平均用户）不必要地越来越复杂。请更多的东西让人们想要和少量一堆书呆子营销酷东西到另一个束。未来几代人会感谢我们。** </p><p>  *You may think that other concepts, such as  Domain-Driven Design (DDD) or  Ubiquitous Language (UL) also belongs in this list. While great concepts and things I believe in and use daily, the process we&#39;re using is working from the bottom-up starting with CCL and IST. We&#39;ll get to DDD and UL, but we&#39;re going to come to conclusions that change the way you use them. They&#39;re not needed here and putting them here would blow up the scope of the essay.</p><p>*您可能认为其他概念，例如域驱动设计（DDD）或普遍的语言（UL）也属于此列表。虽然我相信和每天使用的概念和事物，但我们＆＃39的过程;重新使用的过程是从CCL和IST开始的自下而上。我们＆＃39; ll到达ddd和ul，但我们＆＃39;重申得出结论，改变你使用它们的方式。它们＆＃39;在这里不需要，并将它们放在这里会炸毁文章的范围。</p><p> **It&#39;s a fair cop to say &#34;Daniel, you&#39;re just taking well-established patterns of computing and adding a new label to them. You&#39;re just starting the bullshit loop again at #1&#34; Here&#39;s the difference: the compiler analogy means that the average beginner programmer only has to work a simple IDE to create solutions in whatever environment they find themselves in.  They type one line of code to make the IDE run, then begin making stuff people want. The rest of it goes away, but like all compilation processes at the same time it can also get extremely complex without changing that person&#39;s development experience. This is my acceptance test for what I am describing. Make that work and you can call it anything you&#39;d like. But for the love of the Great Pumpkin and All Things Charlie Brown, pick some label and stick with it.</p><p> **它＆＃39;是一个公平的警察＆＃34;丹尼尔，你＆＃39; re＆＃39; re＆＃39; re＆＃39; refure at＆＃39; refure at＆＃39; ref of the complate的计算模式，并向他们添加新标签。 you＆＃39;重新开始在＃1＆＃34中再次启动废话循环;这里的差异：编译器类比意味着平均初学者程序员只能在他们发现自己的任何环境中创建一个简单的IDE来创建解决方案。它们键入了一行代码以使IDE运行，然后开始制作人们想要的东西。其余部分消失，但与所有编译过程同时一样，在不改变该人的发展经验的情况下也会变得非常复杂。这是我对我描述的内容的验收测试。做那个工作，你可以称之为你的任何东西＆＃39; d喜欢。但是对于伟大的南瓜和棕色的所有东西的爱，挑选一些标签并坚持下去。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danielbmarkham.com/honest-microservices/">https://danielbmarkham.com/honest-microservices/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/honest/">#honest</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>