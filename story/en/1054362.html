<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>生锈1.51. Rust 1.51</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust 1.51<br/>生锈1.51. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 19:45:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/10c030b2429f801a5aed8756bdece9d2.jpg"><img src="http://img2.diglog.com/img/2021/3/10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The Rust team is happy to announce a new version of Rust, 1.51.0. Rust is aprogramming language that is empowering everyone to build reliable andefficient software.</p><p>锈队很乐意宣布新版Rust，1.51.0。 Rust是一种专动图的语言，它能够赋予每个人来构建可靠的更丰富的软件。</p><p> If you have a previous version of Rust installed via rustup, getting Rust1.51.0 is as easy as:</p><p> 如果您有通过Rustup安装的先前版本的RUDE，则rust1.51.0可以简单：</p><p>  If you don&#39;t have it already, you can  get  rustupfrom the appropriate page on our website, and check out the detailed release notes for 1.51.0 on GitHub.</p><p>  如果您已将其＆＃39;它已经存在，您可以在我们的网站上提供保险箱，并在GitHub上查看1.51.0的详细发行说明。</p><p>  This release represents one of the largest additions to the Rust language and Cargo in quite a while, stabilizing an MVP of const generics and a new feature resolver for Cargo. Let&#39;s dive right into it!</p><p>  此版本代表了锈语言和货物的最大补充之一，在很长一段时间内，稳定了Const Generics的MVP和货物的新功能解析器。让＆＃39;潜入潜水！</p><p>  Before this release, Rust allowed you to have your types be parameterized over lifetimes or types. For example if we wanted to have a  struct that is generic over the element type of an array, we&#39;d write the following:</p><p>  在此版本之前，RUDE允许您使用寿命或类型的参数化类型。例如，如果我们想要在数组的元素类型上泛型的结构，我们＆＃39; d写下以下内容：</p><p> struct FixedArray&lt;T&gt; { // ^^^ Type generic definition list: [T; 32] // ^ Where we&#39;re using it.}</p><p> 结构固定阵列＆lt; t＆gt; {// ^^^键入通用定义列表：[t; 32] // ^我们＆＃39;重新使用它。}</p><p> If we then use  FixedArray&lt;u8&gt;, the compiler will make a monomorphic version of  FixedArray that looks like:</p><p> 如果我们然后使用固定阵列＆lt; u8＆gt;，编译器将制作一个单声道的固定阵列，看起来像： </p><p>  This is a powerful feature that allows you to write reusable code with no runtime overhead. However, until this release it hasn&#39;t been possible to easily be generic over the  values of those types. This was most notable in arrays which include their length in their type definition ( [T; N]), which previously you could not be generic over. Now with 1.51.0 you can write code that is generic over the values of any integer,  bool, or  char type! (Using  struct or  enum values is still unstable.)</p><p>这是一个功能强大的功能，允许您编写没有运行时开销的可重用代码。但是，直到此版本，它已在这些类型的值上容易地通用。这在阵列中最值得注意的是它们在其类型定义中的长度（[t; n]），这之前您不能泛型。现在有1.51.0，您可以编写通过任何整数，BOOL或CHAR类型的值的泛型代码！ （使用struct或枚举值仍然不稳定。）</p><p> This change now lets us have our own array struct that&#39;s generic over its type  and its length. Let&#39;s look at an example definition, and how it can be used.</p><p> 此更改现在让我们拥有自己的数组结构，它的类型和它的类型是通用的。让＆＃39; s看一个示例定义，以及如何使用它。</p><p> struct Array&lt;T, const LENGTH: usize&gt; { // ^^^^^^^^^^^^^^^^^^^ Const generic definition. list: [T; LENGTH] // ^^^^^^ We use it here.}</p><p> 结构阵列＆lt; t，const length：measize＆gt; {// ^^^^^^^^^^^^^^^^^^^^^^^ const generic定义。列表：[T;长度] // ^^^^^^我们在这里使用它。}</p><p> Now if we then used  Array&lt;u8, 32&gt;, the compiler will make a monomorphic version of  Array that looks like:</p><p> 现在，如果我们使用阵列＆lt; u8,32＆gt;，编译器将制作一个看起来的数组的单声道版本：</p><p>  Const generics adds an important new tool for library designers in creating new, powerful compile-time safe APIs. If you&#39;d like to learn more about const generics you can also check out the  &#34;Const Generics MVP Hits Beta&#34; blog post for more information about the feature and its current restrictions. We can&#39;t wait to see what new libraries and APIs you create!</p><p>  Const Generics为库设计师添加了一个重要的新工具，以创建新的强大的编译时间安全API。如果你喜欢了解更多关于Const Generics的更多信息，您也可以查看＆＃34; Const Generics MVP HITS Beta＆＃34;博客帖子有关该功能及其当前限制的更多信息。我们可以等待查看您创造的新图书馆和API！</p><p>  As part of const generics stabilising, we&#39;re also stabilising a new API that uses it,  std::array::IntoIter.  IntoIter allows you to create a by value iterator over any array. Previously there wasn&#39;t a convenient way to iterate over owned values of an array, only references to them.</p><p>  作为Const Geacerics稳定的一部分，我们也稳定使用它的新API，STD :: Array :: Intor。 Inist允许您在任何数组上通过value迭代器创建一个。以前有没有一种方便的方法来迭代数组的拥有价值，只引用它们。</p><p> fn main() { let array = [1, 2, 3, 4, 5]; // Previously for item in array.iter().copied() { println!(&#34;{}&#34;, item); } // Now for item in std::array::IntoIter::new(array) { println!(&#34;{}&#34;, item); }}</p><p> fn main（）{let array = [1,2,3,4,5]; //以前用于array.ITER（）中的项目。复制（）{println！（＆＃34; {}}＆＃34;，项目）; } //现在在std :: array :: initer :: new（array）{println！（＆＃34; {}}＆＃34;，项目）; }} </p><p> Note that this is added as a separate method instead of  .into_iter() on arrays, as that currently introduces some amount of breakage; currently  .into_iter() refers to the slice by-reference iterator. We&#39;re exploring ways to make this more ergonomic in the future.</p><p>请注意，这将添加为单独的方法而不是阵列上的.Into_iter（），因为目前介绍了一定量的断裂;目前.Into_iter（）是指切片旁参考迭代器。我们＆＃39;重新探索未来使这种更符合人体工程学的方法。</p><p>  Dependency management is a hard problem, and one of the hardest parts of it is just picking what  version of a dependency to use when it&#39;s depended on by two different packages. This doesn&#39;t just include its version number, but also what features are or aren&#39;t enabled for the package. Cargo&#39;s default behaviour is to merge features for a single package when it&#39;s referred to multiple times in the dependency graph.</p><p>  依赖管理是一个难题，它的最困难的部分之一是恰好挑选在它＆＃39; s依赖于两个不同的包时使用的依赖性。这不包括其版本号，还包括它的版本号，还有哪些功能和＃39; t＆＃39; t为包启用。货物＆＃39; s默认行为是在依赖图中的多次引用时合并单个包的功能。</p><p> For example, let&#39;s say you had a dependency called  foo with features A and B, which was being used by packages  bar and  baz, but  bar depends on  foo+A and  baz depends on  foo+B. Cargo will merge both of those features and compile  foo as  foo+AB. This has a benefit that you only have to compile  foo once, and then it can reused for both  bar and  baz.</p><p> 例如，假设您有一个名为foo的依赖性a和b，它被包装吧和baz使用，但是栏依赖于foo + a，并且Baz取决于foo + b。货物将合并这些功能，并将foo作为foo + ab编译。这有一个好处，你只需要编译一个foo，然后它可以重复使用栏和baz。</p><p> However, this also comes with a downside. What if a feature enabled in a build-dependency is not compatible with the target you are building for?</p><p> 但是，这也有一个缺点。如果在构建依赖关系中启用的功能与您正在构建的目标不兼容，那么</p><p> A common example of this in the ecosystem is the optional  std feature included in many  #![no_std] crates, that allows crates to provide added functionality when  std is available. Now imagine you want to use the  #![no_std] version of  foo in your  #![no_std] binary, and use the  foo at build time in your  build.rs. If your build time dependency depends on  foo+std, your binary now also depends on  foo+std, which means it will no longer compile because  std is not available for your target platform.</p><p> 生态系统中的一个常见示例是在许多＃！[no_std]箱中包含的可选std功能，允许箱子在标准下提供额外的功能。现在想象一下你想在你的＃！[no_std]二进制文件中使用＃！[no_std]版本，并在构建时使用foo .rs。如果您的构建时间依赖性取决于Foo + STD，则您的二进制型现在也取决于Foo + STD，这意味着它将不再编译，因为STD不适用于您的目标平台。</p><p> This has been a long-standing issue in cargo, and with this release there&#39;s a new  resolver option in your  Cargo.toml, where you can set  resolver=&#34;2&#34; to tell cargo to try a new approach to resolving features. You can check out  RFC 2957 for a detailed description of the behaviour, which can be summarised as follows.</p><p> 这在货物中是一个长期存在的问题，并在此释放出来的释放＆＃39;是您的货物中的一个新的解析器选项.Toml，您可以在其中设置Resolver =＆＃34; 2＆＃34;告诉货物尝试解决功能的新方法。您可以查看RFC 2957以了解行为的详细说明，可以如下汇总。</p><p> Dev dependencies — When a package is shared as a normal dependency and a dev-dependency, the dev-dependency features are only enabled if the current build is including dev-dependencies.</p><p> dev依赖关系 - 当程序包作为正常依赖项和开发依赖性时，只有当前构建包括开发依赖性，才会启用开发依赖性功能。 </p><p> Host Dependencies — When a package is shared as a normal dependency and a build-dependency or proc-macro, the features for the normal dependency are kept independent of the build-dependency or proc-macro.</p><p>主机依赖项 - 当程序包作为正常依赖项和构建依赖项或proc-宏共享时，对正常依赖关系的功能保持独立于构建依赖性或proc-宏。</p><p> Target dependencies — When a package appears multiple times in the build graph, and one of those instances is a target-specific dependency, then the features of the target-specific dependency are only enabled if the target is currently being built.</p><p> 目标依赖 - 当包在构建图中多次出现多次时，其中一个实例是目标特定依赖项，那么如果目前正在构建目标，则仅启用目标特定依赖项的功能。</p><p> While this can lead to some crates compiling more than once, this should provide a much more intuitive development experience when using features with cargo. If you&#39;d like to know more, you can also read the  &#34;Feature Resolver&#34; section in the Cargo Book for more information. We&#39;d like to thank the cargo team and everyone involved for all their hard work in designing and implementing the new resolver!</p><p> 虽然这可以导致一些不止一次编译的箱子，但这应该在使用货物的功能时提供更直观的开发经验。如果你＆＃39; d想了解更多，你也可以阅读＆＃34;特征解析器＆＃34;有关更多信息的货物书籍部分。我们喜欢感谢货物团队和所有参与他们在设计和实施新的解析程序的所有辛勤工作的人！</p><p>   While not often highlighted in the release, the Rust teams are constantly working on improving Rust&#39;s compile times, and this release marks one of the largest improvements in a long time for Rust on macOS. Debug information maps the binary code back to your source code, so that the program can give you more information about what went wrong at runtime. In macOS, debug info was previously collected into a single  .dSYM folder using a tool called  dsymutil, which can take some time and use up quite a bit of disk space.</p><p>   虽然在发布中不经常突出显示，但防锈队不断努力改善生锈＆＃39;在编译时段，这一版本标志着麦克斯锈病的最大改进之一。调试信息将二进制代码映射回源代码，以便该程序可以为您提供有关运行时出现问题的更多信息。在MacOS中，先前使用名为dsymutil的工具收集到单个.dsym文件夹中的调试信息。这可能需要一些时间并使用相当多的磁盘空间。</p><p> Collecting all of the debuginfo into this directory helps in finding it at runtime, particularly if the binary is being moved. However, it does have the drawback that even when you make a small change to your program,  dsymutil will need to run over the entire final binary to produce the final  .dSYM folder. This can sometimes add a lot to the build time, especially for larger projects, as all dependencies always get recollected, but this has been a necessary step as without it Rust&#39;s standard library didn&#39;t know how to load the debug info on macOS.</p><p> 将所有DebugInfo收集到此目录中有助于在运行时查找它，特别是如果在移动二进制文件时。但是，它确实有缺点，即使您对您的程序进行小的更改时，Dsymutil也需要在整个最终二进制文件中运行以产生最终的.dsym文件夹。这有时可以为构建时间添加很多，特别是对于较大的项目，因为所有依赖性总是被回忆，但这是一个必要的一步，因为没有它生锈＆＃39; s标准图书馆没有知道如何加载调试摩托斯的信息。</p><p> Recently, Rust backtraces switched to using a different backend which supports loading debuginfo without needing to run  dsymutil, and we&#39;ve stabilized support for skipping the  dsymutil run. This can significantly speed up builds that include debuginfo and significantly reduce the amount of disk space used. We haven&#39;t run extensive benchmarks, but have seen a lot of reports of people&#39;s builds being a lot faster on macOS with this behavior.</p><p> 最近，Rust Backtrets切换到使用不同的后端，支持加载debuginfo，而无需运行dsymutil，我们＆＃39; ve稳定的支持跳过dsymutil运行。这可以显着加速包括DebugInfo的构建，并显着减少所使用的磁盘空间量。我们哈比＆＃39; t运行广泛的基准，但已经看到了很多人的报告＆＃39;在麦斯斯的情况下，在麦斯斯的速度越来越大。</p><p> You can enable this new behaviour by setting the  -Csplit-debuginfo=unpacked flag when running  rustc, or by setting the   split-debuginfo  [profile] option to  unpacked in Cargo. The &#34;unpacked&#34; option instructs rustc to leave the .o object files in the build output directory instead of deleting them, and skips the step of running dsymutil. Rust&#39;s backtrace support is smart enough to know how to find these .o files. Tools such as lldb also know how to do this. This should work as long as you don&#39;t need to move the binary to a different location while retaining the debug information.</p><p> 您可以通过在运行rustc时设置-csplit-debuginfo =未包装标志来启用此新行为，或通过设置拆分 -  debuginfo [profile]选项在货物中解压缩。 ＆＃34;未包装和＃34;选项指示RUSTC将.o对象文件留在构建输出目录中，而不是删除它们，并跳过运行dsymutil的步骤。 Rust＆＃39; s回溯支持足以知道如何找到这些.o文件。 LLDB等工具也知道如何执行此操作。这应该只有在保留调试信息的同时需要将二进制文件移动到不同的位置。 </p><p>   In total, this release saw the stabilisation of 18 new methods for various types like  slice and  Peekable. One notable addition is the stabilisation of  ptr::addr_of! and  ptr::addr_of_mut!, which allow you to create raw pointers to unaligned fields. Previously this wasn&#39;t possible because Rust requires  &amp;/&amp;mut to be aligned and point to initialized data, and  &amp;addr as *const _ would then cause undefined behaviour as  &amp;addr needs to be aligned. These two macros now let you safely create unaligned pointers.</p><p>总的来说，该释放稳定为18种新方法，可以为各种类型和偷窥。一个值得注意的添加是稳定PTR :: ADDR_OF！和ptr :: addr_of_mut！，允许您将原始指针创建为未对齐的字段。以前这不是可能的，因为Rust需要＆amp; /＆amp; um; um; um;＆amp;＆amp; addr为* const _然后导致未定义的行为与＆amp; addr需要对齐。这两个宏现在让您安全创建未对齐的指针。</p><p> use std::ptr;#[repr(packed)]struct Packed { f1: u8, f2: u16,}let packed = Packed { f1: 1, f2: 2 };// `&amp;packed.f2` would create an unaligned reference, and thus be Undefined Behavior!let raw_f2 = ptr::addr_of!(packed.f2);assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);</p><p> 使用std :: ptr;＃一个未预定的参考，因此是未定义的行为！LET RAW_F2 = PTR :: ADDR_OF！（packed.f2）; assert_eq！（不安全{raw_f2.read_unaligned（），2）;</p><p>    There are other changes in the Rust 1.51.0 release: check out what changed in  Rust,  Cargo, and  Clippy.</p><p>    Rust 1.51.0发布中还有其他更改：查看Rust，Cargo和Clippy中的改变。</p><p>  Many people came together to create Rust 1.51.0. We couldn&#39;t have done it without all of you.  Thanks!</p><p>  很多人聚集在一起创造生锈1.51.0。我们无法完成它，没有你们。谢谢！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html">https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>