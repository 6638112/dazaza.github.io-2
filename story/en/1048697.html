<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cranelift，第2部分：编译器效率，CFG和分支窥孔优化器 Cranelift, Part 2: Compiler Efficiency, CFGs, and a Branch Peephole Optimizer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cranelift, Part 2: Compiler Efficiency, CFGs, and a Branch Peephole Optimizer<br/>Cranelift，第2部分：编译器效率，CFG和分支窥孔优化器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-21 07:59:37</div><div class="page_narrow text-break page_content"><p>This post is the second in a three-part series about Cranelift.In the  first post, Idescribed the context around Cranelift and our project to replace itsbackend code-generation infrastructure, and detailed theinstruction-selection problem and how we solve it. The remaining twoposts will be deep-dives into some interesting engineering problems.</p><p>这篇文章是有关Cranelift的三部分系列文章中的第二篇。在第一篇文章中，我描述了Cranelift及其替代后台代码生成基础结构的项目的上下文，并详细说明了指令选择问题以及如何解决它。剩下的两篇文章将深入探讨一些有趣的工程问题。</p><p> In this post, I want to dive into the  compiler performance aspect ofour work more deeply. (In the next post we’ll explore correctness.)There are many interesting aspects of compilation speed I could talkabout, but one particularly difficult problem is the handling of control flow: how do we translate structured control flow at theWasm level into control-flow graphs at the IR level, and finally tobranches in a linear stream of instructions at the machine-code level?</p><p> 在本文中，我想更深入地探讨我们工作中的编译器性能方面。 （在下一篇文章中，我们将探讨正确性。）我可以谈论编译速度的许多有趣方面，但是一个特别困难的问题是控制流的处理：我们如何将Wasm级别的结构化控制流转换为控制流在IR级别绘制图形，最后在机器代码级别以线性指令流分支？</p><p> Doing this translation efficiently requires careful attention to theoverall pass structure, with the largest wins coming when one cancompletely eliminate a category of work. We’ll see this in how wecombine several passes in a traditional lowering design (critical-edgesplitting, block ordering, redundant-block elimination, branchrelaxation, branch target resolution) into  inline transforms thathappen during other passes (lowering of the CLIF, or Cranelift IR,into machine-specific IR; and later, binary emission).</p><p> 有效地进行此翻译需要仔细注意整个过程的结构，当一个人可以完全消除一类工作时，最大的胜利就来了。我们将如何将传统降低设计中的几次通过（临界边缘分割，块排序，冗余块消除，分支松弛，分支目标分辨率）组合为在其他通过（降低CLIF或Cranelift IR）时会发生的内联变换，转换为机器专用的IR；然后再转换为二进制发射）。</p><p> This post basically describes the  MachBuffer,a “smart machine-code buffer” that knows about branches and edits themon-the-fly as we emit them, and the  BlockLoweringOrder,which allows us to lower code in final basic-block order, with splitcritical edges inserted implicitly, by traversing a never-materializedimplicit graph. The work was done mostly in  Cranelift PR#1718, whichresulted in a ~10% compile-time improvement and a ~25%compile+run-time improvement on a CPU-intensive benchmark ( bz2).</p><p> 这篇文章基本上描述了MachBuffer，这是一个“智能机器代码缓冲区”，它了解分支并在发出分支时即时编辑它们，以及BlockLoweringOrder，它使我们能够以最终的基本块顺序降低代码，并使用splitcritical通过遍历从未实现的隐式图来隐式插入边。这项工作主要在Cranelift PR＃1718中完成，在CPU密集型基准（bz2）上，编译时性能提高了约10％，编译+运行时性能提高了约25％。</p><p>  Before we discuss any of that, we need to review control-flow graphs(CFGs)! The CFG is a fundamental data structure used in almost allmodern compilers. In brief, it represents how execution (i.e., programcontrol) may flow through instructions, using graph nodes to representlinear sequences of instructions and graph edges to represent allpossible control-flow transfers at branch instructions.</p><p>  在讨论其中任何一项之前，我们需要查看控制流程图（CFG）！ CFG是几乎所有现代编译器中使用的基本数据结构。简而言之，它代表执行（即程序控制）如何流经指令，使用图形节点表示指令的线性序列，并使用图形边缘表示分支指令处所有可能的控制流转移。</p><p> At the end of the instruction selection process, which we learnedabout in the  previous post, we have a function body lowered into VCode that consists of  basic blocks. A basicblock is a contiguous sequence of instructions that has no outboundbranches except at the end, and has no inbound branches except at thebeginning. In other words, it is “straight-line” code: executionalways starts at the top and proceeds to the end. An examplecontrol-flow graph (CFG) consisting of four basic blocks is shownbelow:</p><p> 在上一篇文章中了解的指令选择过程结束时，我们将一个函数主体简化为包含基本块的VCode。基本块是连续的指令序列，除了结尾处没有出站分支，除了开头没有其他入站分支。换句话说，它是“直线”代码：执行总是从顶部开始，一直到结束。下面显示了一个由四个基本块组成的示例控制流图（CFG）：</p><p>  Control-flow graphs are excellent data structures for compilers touse. By making the flow of execution explicit as graph edges, ratherthan reasoning about instructions in order in memory as the processorsees them, many analyses can be performed more easily. For example, dataflow analysisproblems can be solved easily because the CFG makes traversal ofpossible control-flow transfers easy. Graph-based representations ofthe program also allow easier  moving and insertion of code: it isless error-prone to manipulate an explicit graph than to reason aboutimplicit control-flow (e.g. fallthrough from a not-taken conditionalbranch). Finally, the graph representation factors out the question of block ordering, which can be important for performance; we canaddress this problem separately by choosing how we serialize the graphnodes (blocks). For these reasons, most compiler IRs, includingCranelift’s CLIF and  VCode, are CFG-based.</p><p>  控制流图是供编译器使用的出色数据结构。通过将执行流程明确地显示为图形边缘，而不是按处理器中的处理顺序按顺序对指令进行推理，可以更轻松地执行许多分析。例如，由于CFG使遍历所有可能的控制流变得容易，因此可以轻松解决数据流分析问题。程序的基于图的表示形式还允许更轻松地移动和插入代码：操作显式图比解释隐式控制流（例如，由于未采用条件分支导致的失败）容易出错。最后，图形表示法排除了块排序的问题，这对性能可能很重要。我们可以通过选择如何序列化graphnodes（块）来分别解决这个问题。由于这些原因，大多数编译器IR（包括Cranelift的CLIF和VCode）都基于CFG。 </p><p> (Historical note: control-flow graphs were invented by the late Frances Allen, wholargely established the algorithmic foundations that modern compilersuse. Her paper  A catalogue of optimizingtransformations  1covers essentially all of the important optimizations used today andis well worth a read.)</p><p>（历史记录：控制流图是由已故的Frances Allen发明的，他在很大程度上建立了现代编译器使用的算法基础。她的论文“优化转换目录” 1基本上涵盖了当今使用的所有重要优化，非常值得一读。）</p><p>  To represent a CFG’s end-of-block branches at the instruction level,we can use  two-way branches: these are instructions that brancheither to one basic-block target if some condition is true, or anotherif the condition is false. (Basic blocks can also end in simpleunconditional single-target branches.) We wrote such a branch as  ifr0, L1, L2 above; this means that the block  L0 will be followed inexecution either by  L1 or  L2, depending on the value in  r0.  2</p><p>  为了在指令级别上表示CFG的块末分支，我们可以使用双向分支：这是在某些条件为true时分支到一个基本块目标，在条件为false时分支到另一个基本块目标的指令。 （基本块也可以以简单的无条件单目标分支结尾。）我们在上面编写了诸如ifr0，L1，L2之类的分支。这意味着将根据r0中的值在块L0之后执行L1或L2。 2</p><p>  However, CPUs rarely have such two-way branch instructions. Instead,conditional control-flow in common ISAs is almost always provided witha  conditional branch with fallthrough. This is an instruction that,if some condition is true, branches to another location; otherwise,does nothing, and allows execution to continue sequentially. This is abetter fit for a hardware implementation for a number of reasons: it’seasier to encode one target than two (the destination of the jumpmight be quite far away for some branches, and instructions havelimited bits available), and it’s usually the case that the compilercan place one of the successor blocks immediately afterward anyway.</p><p>  但是，CPU很少有这样的双向分支指令。取而代之的是，普通ISA中的条件控制流几乎总是带有带有失败的条件分支。这是一条指令，如果满足某些条件，则转移到另一个位置；否则，不执行任何操作，并允许顺序执行。出于多种原因，这更适合于硬件实现：编码一个目标要比两个目标更容易（对于某些分支，跳转的目标可能相距很远，并且指令具有有限的可用位），通常是这种情况无论如何，编译器可以立即放置后续块之一。</p><p> Now, this isn’t much of a problem if we just want a working compiler;instead of a two-way branch</p><p> 现在，如果我们只想要一个工作正常的编译器，而不是双向分支，就没什么问题了</p><p>    where  br_if branches to  L1 or falls through to the unconditional goto. But this is not so efficient in many cases. Consider whatwould happen if we laid out basic blocks in the order  L0,  L2, L1,  L3:</p><p>    br_if分支到L1或掉到无条件的goto。但这在许多情况下不是那么有效。考虑一下如果我们按L0，L2，L1，L3的顺序布置基本块会发生什么：</p><p> L0: ... br_if r0, L1 goto L2 L2: ... goto L3 L1: ... goto L3 L3: ... return</p><p> L0：... br_if r0，L1转到L2 L2：...转到L3 L1：...转到L3 L3：...返回</p><p> There are two redundant unconditional branches ( goto instructions),each of which uselessly branches to the following instruction. We canremove both of them with no ill effects, taking advantage instead of fallthrough, or allowing execution to proceed directly from the endof one block to the start of the next one:</p><p> 有两个冗余的无条件分支（goto指令），每个分支都无用地分支到以下指令。我们可以删除它们，而不会造成不良影响，可以利用它而不是失败，或者允许执行从一个块的结尾直接开始到下一个块的开始： </p><p> L0: ... br_if r0, L1 // ** Otherwise, fall through to L2 ** L2: ... goto L3 L1: ... // ** Always fall through to L3 ** L3: ... return</p><p>L0：... br_if r0，L1 // **否则落入L2 ** L2：...转到L3 L1：... // **始终落入L3 ** L3：...返回</p><p> This seems like an easy enough problem to solve: we just need torecognize when a branch is redundant and remove it, right? Well, yes,but we can do much better than that in some cases; we’ll dig into thisproblem in significantly more depth below!</p><p> 这似乎是一个很容易解决的问题：我们只需要识别分支何时冗余并删除它，对吗？是的，但是在某些情况下我们可以做得更好。我们将在下面更深入地探讨这个问题！</p><p>  So far, we’ve written our machine instructions in a way that humanscan read, using  labels to refer to locations in the instructionstream. At the hardware level, however, these labels do not exist;instead, the machine code branches contain target  addresses (usuallyencoded as relative  offsets from the branch instruction). In otherwords, we do not see  goto L3, but rather  goto +32.</p><p>  到目前为止，我们已经以人工扫描的方式编写了机器指令，并使用标签引用了指令流中的位置。但是，在硬件级别上，这些标签不存在；相反，机器代码分支包含目标地址（通常被编码为与分支指令的相对偏移量）。换句话说，我们看不到goto L3，而是goto +32。</p><p> This gives rise to several complications when emitting machine codefrom a list of instruction  structs. At the most basic level, wehave to resolve labels to offsets and then patch the branchesappropriately. This is analogous to (but at a lower level than) thejob of a  linker:we resolve symbols to concrete values after deciding placement, andthen edit the code according to  relocations to refer to thosesymbols. In other words, whenever we emit a branch, we make a note (arelocation, or “label use” in our  MachBackend) to go back later andpatch it with the resolved label offset.</p><p> 当从指令结构列表中发出机器代码时，这会引起一些复杂性。在最基本的层次上，我们必须将标签解析为偏移量，然后适当地修补分支。这类似于链接程序的工作（但比链接程序的工作低）：我们在确定放置位置后将符号解析为具体值，然后根据重定位来编辑代码以引用这些符号。换句话说，无论何时发出分支，我们都会做一个记录（在MachBackend中的位置，或“标签使用”），以便以后返回并使用解析的标签偏移量对其进行修补。</p><p> The second, and more interesting, problem arises because not allbranch instructions can necessarily refer to all possible labels! As aconcrete example, on AArch64, conditional branches have a ±1 MB range,and unconditional branches have a ±128 MB range. This arises out ofinstruction-encoding considerations: particularly infixed-instruction-size ISAs (such as ARM, MIPS, and RISC V), less thana full machine word of bits are available for the immediate jumpoffset that is embedded in the instruction word. (The instructionitself is always a machine-word wide, and we need some bits for theopcode and condition code too!) On x86, we have limits for a differentreason: the variable-width encoding allows either a one-byte offset(allowing a ±128 byte range) or four-byte offset (allowing a ±2 GBrange).</p><p> 出现第二个更有趣的问题是因为并非所有分支指令都必须引用所有可能的标签！作为一个具体示例，在AArch64上，条件分支的范围为±1 MB，无条件分支的范围为±128 MB。这是出于指令编码的考虑：特别是指令大小固定的ISA（例如ARM，MIPS和RISC V），对于嵌入在指令字中的立即跳转偏移，可用的机器字不到完整位。 （指令本身总是一个机器字宽，并且我们还需要一些用于操作码和条件代码的位！）在x86上，我们有一个不同原因的限制：可变宽度编码允许一个字节的偏移量（允许± 128字节范围）或四字节偏移量（允许±2 GB范围）。</p><p> To make a branch to a far-off label, then, on some machines we need toeither use a different sort of branch than the default choice for theinstruction selector, or we need to use a form of  indirection, bytargetting the original branch to  another branch, the latter in aspecial form. The former is tricky because we do not know whether atarget will be in-range until all code is lowered and placement iscomputed; so we need to either optimistically or pessimistically lowerbranches to the shortest or longest form (respectively) and possiblyswitch later. To make matters worse, as we edit branches to use ashorter or longer form, their length may change, moving  othertargets into or out of range; in the most general solution, this is a“fixpoint problem”, where we iterate until no more changes occur.</p><p> 为了建立到遥远标签的分支，然后，在某些计算机上，我们需要使用与指令选择器默认选择不同的另一种分支，或者需要通过将原始分支定位到另一个分支来使用间接形式，后者为特殊形式。前者很棘手，因为在降低所有代码并计算位置之前，我们不知道目标是否在范围内。因此，我们需要乐观地或悲观地将下支行分别设为最短或最长的形式，并可能稍后再切换。更糟的是，当我们编辑分支以使用更短或更长时间的形式时，它们的长度可能会发生变化，从而使其他目标移入或移出范围；在最通用的解决方案中，这是一个“定点问题”，我们在其中进行迭代，直到不再发生任何更改为止。</p><p>  So far, we have a way to produce  correct machine code. To emit thefinal code for a two-target branch, we can emit a conditional-followed by unconditional-branch machine instruction. To resolvebranch targets correctly, we can assume that any target could beanywhere in memory, and always use the long form of a branch; then wejust need to come back in one final pass and fill in the offsets whenwe know them.</p><p>  到目前为止，我们已经有了产生正确机器代码的方法。为了发出两个目标分支的最终代码，我们可以发出条件跟随的无条件分支机器指令。为了正确解析分支目标，我们可以假定任何目标都可以在内存中的任何位置，并且始终使用分支的长格式；那么我们只需要最后一次通过，然后在我们知道偏移量的情况下填写它们即可。 </p><p> We can do much better than this, though! Below I’ll describe fourproblems and the ways that they are traditionally solved.</p><p>但是，我们可以做得更好！下面，我将描述四个问题以及传统上解决这些问题的方式。</p><p>  We described above how  branch fallthroughs allow us to omit somesome unconditional branches once we know for sure the order that basicblocks will appear in the final binary. In particular, the simplelowering of a two-way branch  if r0, label_if_true, label_if_false totwo one-way branches</p><p>  上面我们描述了一旦确定确定基本块将出现在最终二进制文件中的顺序，分支穿透就如何允许我们省略一些无条件分支。尤其是将r0，label_if_true，label_if_false的双向分支简单降低到两个单向分支</p><p>  has a completely redundant and useless  goto! In general, if a branchtarget is the very next instruction, we can delete that branch.</p><p>  具有完全冗余且无用的goto！通常，如果下一个指令是branchtarget，则可以删除该分支。</p><p> However, there are slightly more complex cases where we can also findsome improvements. Consider the inverted version of the above:</p><p> 但是，在有些更复杂的情况下，我们也可以找到一些改进。考虑上述内容的反向版本：</p><p>  No branch here branches to its fallthrough, so one might think thatboth branches are necessary. But in practice, on most CPUarchitectures, all conditional branches have  inverted forms. Forexample, the x86 instruction  JE (jump if equal) can be inverted to JNE (jump if not equal). If we are allowed to edit branch conditionsas well, then we can rewrite the above as:</p><p>  这里没有分支分支到其失败，因此可能会认为两个分支都是必要的。但是实际上，在大多数CPU架构上，所有条件分支的形式都是相反的。例如，可以将x86指令JE（如果相等则跳转）转换为JNE（如果不相等则跳转）。如果也允许编辑分支条件，则可以将以上内容重写为：</p><p>    It is sometimes the case that after optimizations, a basic block iscompletely  empty aside from a final unconditional branch. This canoccur when all of the code in an if- or else-block is optimized awayor moved elsewhere in the function body. It can also occur when ablock was inserted to  split a critical edge (see below).</p><p>    有时，经过优化后，除了最终的无条件分支外，基本块完全为空。当优化if或else块中的所有代码或将其移到函数体中的其他位置时，可能会发生这种情况。当插入块以分割临界边缘时，也会发生这种情况（请参见下文）。</p><p> Thus, a common optimization is   jumpthreading: when onebranch points directly to another, we can just edit the first branchto point to the final target. Generalized, we can “chase through” anynumber of branches to eliminate intermediate steps. For example:</p><p> 因此，常见的优化是跳转线程：当一个分支直接指向另一个分支时，我们只需编辑第一个分支即可指向最终目标。概括地说，我们可以“遍历”任意数量的分支以消除中间步骤。例如： </p><p>    note that the intermediate branches  were not removed: they may stillbe the targets of  other branches. We skip over them when startingfrom the first branch. However, if we know some other way that thesebranches are unused, we can then delete them, reducing code size.</p><p>请注意，中间分支未删除：它们可能仍然是其他分支的目标。从第一个分支开始时，我们将跳过它们。但是，如果我们知道未使用这些分支的其他方式，则可以删除它们，从而减小代码大小。</p><p>  As we noted above, the “branch relaxation” problem is that we mustchoose one of  multiple forms for each branch instruction, each ofwhich may have a different range (maximal distance from currentprogram-counter location). This is complex because the needed rangedepends on the final locations of the branch and its target, which inturn depends on the size of instructions in the machine code; but someof those instructions are themselves branches. We thus have a circulardependency.</p><p>  如上所述，“分支松弛”问题是我们必须为每个分支指令选择多种形式中的一种，每种形式都可能具有不同的范围（与当前程序计数器位置的最大距离）。这很复杂，因为所需范围取决于分支及其目标的最终位置，而分支的最终位置又取决于机器代码中指令的大小。但是其中一些指令本身就是分支。因此，我们具有循环依赖关系。</p><p> There will always be  some way to branch to an arbitrary location inthe processor’s address space, so there is always the trivial butinefficient solution of using worst-case branch forms. However, we canusually do much better, because the majority of branches will be torelatively small offsets.</p><p> 总会有某种方法可以分支到处理器地址空间中的任意位置，因此始终存在使用最坏情况的分支形式的琐碎但效率低下的解决方案。但是，我们通常可以做得更好，因为大多数分支的偏移量相对较小。</p><p> The usual approach to solving this problem involves a “fixpointcomputation”: an iterative loop that continues to make improvementsuntil none are left. This is where the “relaxation” of branchrelaxation comes from: we modify branch instructions to have moreoptimal forms as we discover that targets are within range; and as wedo this, we recompute code offsets and see if this enables any otherrelaxations. As long as the relationship between branch range andbranch instruction size is monotonic (smaller required range allowsfor shorter instruction), this will always converge to a uniquefixpoint; but it is potentially expensive, and involves stickydata-structure design questions if we want the code editing and/oroffset recomputation to be fast.</p><p> 解决此问题的常用方法涉及“定点计算”：一个不断进行改进直到不遗余力的迭代循环。这就是分支放松的“放松”的来源：当我们发现目标在范围内时，我们修改分支指令以具有更优化的形式。然后，我们重新计算代码偏移量，看看是否可以启用其他松弛。只要分支范围和分支指令大小之间的关系是单调的（所需范围越小，指令越短），它将始终收敛到唯一的固定点；但是它可能很昂贵，并且如果我们希望代码编辑和/或偏移重新计算速度更快，则会涉及粘性数据结构设计问题。</p><p>  For a number of reasons, we usually want to  split  criticaledgesin the control-flow graph. A critical edge is any control-flowtransfer edge that comes  from a block with multiple out-edges, andgoes  to a block with multiple in-edges. We sometimes need to insertsome code to run whenever the program follows a critical edge: e.g.,the register allocator may need to “fix up” the machine state, movingvalues around in registers as expected by the target block. Considerwhere we might insert such code: we can’t insert it prior to the jump,because this would execute no matter what out-edge istaken. Similarly, we can’t insert it at the target of the jump,because this would execute for any entry into the target block, notjust transfers over the particular edge.</p><p>  由于多种原因，我们通常希望在控制流图中拆分临界边。关键边缘是指来自具有多个外边缘的块并到达具有多个内边缘的块的任何控制流传输边缘。每当程序遇到关键边缘时，有时我们都需要插入一些代码才能运行：例如，寄存器分配器可能需要“修正”机器状态，从而按目标块的预期在寄存器中移动值。考虑一下我们可以在哪里插入这样的代码：我们不能在跳转之前插入它，因为无论采用什么边缘，该代码都可以执行。同样，我们无法将其插入跳转目标，因为这将对目标块中的任何条目执行，而不仅仅是在特定边沿上转移。</p><p> The solution is to “split” the critical edge: that is, create a newbasic block, edit the branch to point to this block, and then createan unconditional branch in the block to the original target. Thisbasic block is a place where we can insert whatever fixup code weneed, and it will execute  only when control flow transfers from theone specific block to the other. A critical-edge split is illustratedin the following figure:</p><p> 解决方案是“分割”关键边缘：即创建一个新基本块，编辑分支以指向该块，然后在该块中创建一个到原始目标的无条件分支。这个基本块是我们可以插入所需的任何固定代码的地方，并且仅在控制流从一个特定块转移到另一个特定块时才执行。下图显示了临界边缘拆分：</p><p>  There are multiple ways in which we could handle this problem: wecould preemptively split every critical edge; or we could split themon demand, only when we need to insert code. The latter would requireediting the CFG in place, and for various reasons, we would prefer toavoid doing this: it invalidates many analysis results, andcomplicates data structures. It is also much simpler to reason aboutmany algorithms if we can assume that edges are alreadysplit. However, splitting every edge will leave many empty blocks,because we  usually do not need to insert any fixup code on an edge.In addition, splitting an edge raises the question of  where toinsert the split-block. If we take the simplest approach and append itto the end of the function, we probably significantly reduce thenumber of branch-fallthrough simplifications we can make; a smarterheuristic that placed the block near its predecessor or successorwould be better.</p><p>  有多种方法可以解决此问题：我们可以抢先分割每个关键优势；或者我们可以仅在需要插入代码时才拆分需求。后者需要就地编辑CFG，并且由于各种原因，我们宁愿避免这样做：它会使许多分析结果无效，并使数据结构复杂化。如果我们可以假设边缘已经被分割，那么对许多算法进行推理也要简单得多。但是，拆分每个边缘将留下许多空白块，因为我们通常不需要在边缘上插入任何固定代码。此外，拆分边缘还带来了将拆分块插入哪里的问题。如果我们采用最简单的方法并将其附加到函数的末尾，则可能会通过简化来显着减少分支落入的数量。将块放置在其前任或后继位置附近的智能启发式方法会更好。 </p><p>  The traditional approach to all of these problems is to decompose thetask into a number of  passes and perform  in-place edits with thosepasses. For example, in LLVM, IR is lowered into a machine-specificform ( MachineFunction of  MachineBasicBlocks) with an explicitnotion of layout and with machine-level branch instructions; thenedits are made, taking care to update branches when the layoutchanges.</p><p>解决所有这些问题的传统方法是将任务分解为多个遍，并使用这些遍执行就地编辑。例如，在LLVM中，IR可以简化为机器特定的形式（MachineBasicBlocks的MachineFunction），具有明确的布局概念和机器级别的分支指令。然后进行编辑，注意在布局更改时更新分支。</p><p>  Compute reachability, and delete “dead blocks” (blocks that are nolonger reachable). (Also done by  BranchFolding in LLVM.)</p><p>  计算可达性，并删除“死块”（不再可达的块）。 （也由LLVM中的BranchFolding完成。）</p><p>  Compute a block order that tries to minimize jump distances andplaces at least one successor directly after every block whenpossible. (In LLVM, the  MachineBlockPlacementpass.)</p><p>  计算一个试图最小化跳跃距离的程序段顺序，并在可能的情况下在每个程序段之后直接放置至少一个后继程序。 （在LLVM中，为MachineBlockPlacementpass。）</p><p>  Linearize the code from the CFG nodes into a single stream ofmachine instructions using this block order. (In LLVM, blocks areinitially lowered into the  MachineFunction and then reordered by MachineBlockPlacement.)</p><p>  使用此块顺序将来自CFG节点的代码线性化为单个机器指令流。 （在LLVM中，块最初被降低到MachineFunction中，然后由MachineBlockPlacement重新排序。）</p><p>    Compute block offsets based on machine-code size of currentinstruction sequence, assuming worst-case size for every branch.</p><p>    假设每个分支的最坏情况下的大小，根据当前指令序列的机器代码大小计算块偏移。</p><p>  Scan over branches, checking whether block locations allow forshorter forms due to nearer targets. Update branches and recomputeblock offsets if so. Continue until fixpoint. (In LLVM, the  BranchRelaxationdoes this.)</p><p>  扫描分支，检查块位置是否由于目标较近而允许格式较短。如果是这样，更新分支并重新计算块偏移。继续直到定点。 （在LLVM中，BranchRelaxation这样做。）</p><p>  Fill in branch targets using final offsets. Branches are now in aform ready for machine-code emission.</p><p>  使用最终偏移量填写分支目标。分支现已准备就绪，可以发出机器代码。 </p><p> Clearly this will work, and with some care (especially in theblock-placement heuristics), it will produce very good code. But theabove steps require  many in-place edits. This is both slow (we arere-doing some work every time we edit the code) and forces us to usedata structures that allow for such edits (e.g., linked list), whichimposes a tax on every other operation on the IR. Is there a betterway?</p><p>显然，这是可行的，并且经过谨慎处理（尤其是在块放置启发法中），它将产生非常好的代码。但是上述步骤需要许多就地编辑。这既很慢（每次编辑代码时我们都要做一些工作），并且迫使我们使用允许进行此类编辑的ata结构（例如链表），这对IR上的所有其他操作都加了税。有没有更好的办法？</p><p>  It would be ideal if we could avoid some of the code-transform passesdescribed above; can we? It turns out that one can actually do thefunctional equivalent of  all of the above as part of other,pre-existing work:</p><p>  如果能够避免上述某些代码转换过程，那将是理想的；我们可以吗？事实证明，作为其他现有工作的一部分，一个人实际上可以完成上述所有工作：</p><p> We can decide the final block order ahead of time, and do ourCLIF-to-VCode lowering in this order, so VCode never needs to bereordered; it is already linearized. We can also insertcritical-edge splits as part of this lowering.</p><p> 我们可以提前确定最终的块顺序，并按此顺序降低CLIF到VCode的顺序，因此无需重新排序VCode。它已经线性化。我们还可以插入临界边缘拆分作为此降低操作的一部分。</p><p>  We can do  all of the other work – inverting conditionals,threading jumps, removing dead blocks, and handling various branchsizes – in a streaming approach during machine-code emission! Thekey insight is that we can do a sort of “peephole optimization”: wecan immediately delete and re-emit branches at the  tail of theemission buffer. By tracking some auxiliary state during the singleemission scan, such as reachability, labels at current emissionpoint, a list of unresolved label-refs earlier in code, and a“deadline” for short-range branches, we can do everything we needto do without ever backing up more than a few contiguous branchesat the end of the buffer.</p><p>  在机器代码发出期间，我们可以通过流方法完成所有其他工作-反转条件，线程跳转，清除死块以及处理各种分支大小！关键的见解是，我们可以执行某种“窥孔优化”：我们可以立即删除并重新发射发射缓冲区尾部的分支。通过在单次发射扫描期间跟踪一些辅助状态，例如可达性，当前发射点处的标签，代码前面的未解析标签引用列表以及短距离分支的“最后期限”，我们可以做所有需要做的事情，而无需做任何事情在缓冲区末尾备份多个连续的分支。</p><p>   As part of the instruction-selection pipeline described in the previous post, we needto iterate over the basic blocks in the CLIF and, for each block,lower its code to VCode instructions. We would like to do thisiteration in the same order as our final machine code layout so thatwe don’t need to reorder the VCode later.</p><p>   作为上一篇文章中描述的指令选择管道的一部分，我们需要遍历CLIF中的基本块，并针对每个块将其代码降低为VCode指令。我们希望以与最终机器代码布局相同的顺序进行此迭代，这样我们以后就无需重新排序VCode。</p><p> The only constraint that the lowering algorithm imposes is that weexamine  value uses before  value defs, which we can ensure byvisiting a block before any of its dominators. That leaves a lot offreedom in how we do the lowering.</p><p> 降低算法所施加的唯一约束是weexamine在value defs之前使用value，这可以通过在其任何支配者之前访问块来确保。这就给我们如何降低工作留了很多自由。</p><p> If that were the whole problem, we could just do a postordertraversal and be done with it. In fact, the problem is complicated byone other factor: critical-edge splitting!</p><p> 如果这是整个问题，那么我们可以做一个遍历后遍历并完成它。实际上，这个问题还由于另一个因素而变得复杂：临界边缘分裂！ </p><p> Recall that we described above that we must either preemptively splitall critical edges or else find a way to edit-in-place later. To avoidthe complexities of edit-in-place, we choose to split them all. Notethat this is cheap as far as our CFG lowering is concerned, becauseour later branch optimizations will remove empty blocks almost forfree. (The register allocator’s analyses may become more expensivewith a higher block count, but in practice we have not found this tobe much of a problem.)</p><p>回想一下我们在上面描述的内容，我们必须先抢先分割所有关键边缘，否则必须找到一种以后进行就地编辑的方法。为了避免就地编辑的复杂性，我们选择将它们全部分割。请注意，就我们的CFG降低而言，这是便宜的，因为我们以后的分支优化将几乎免费地删除空块。 （随着块数的增加，寄存器分配器的分析可能会变得更加昂贵，但实际上，我们发现这并不是一个大问题。）</p><p> The challenge is in generating these blocks in the correct place  onthe fly. To generate the lowering order, we define a  virtual graphthat is never actually materialized, whose nodes are implied by theCLIF blocks and edges (every CLIF edge becomes a split-edge block) andwhose edges are defined only by a successor function. To generate thelowering order, we perform a  depth-firstsearch over thevirtual graph, recording the postorder. Thispostorder is guaranteed to see uses before defs, as required. The DFSitself is a pretty good heuristic for block placement: it will tend togroup structured-control-flow code together into its hierarchicalunits.</p><p> 挑战在于在飞行中的正确位置生成这些块。为了生成降序，我们定义了一个虚拟图，该图从未实际实现，其节点由CLIF块和边（每个CLIF边变为裂边块）隐含，而其边仅由后继函数定义。为了生成降序，我们对虚拟图执行深度优先搜索，记录后序。保证可以根据需要在defs之前查看此postorder的用法。 DFSitself是一个很好的启发式块放置方法：它将趋向于将结构化控制流代码分组到其层次单元中。</p><p> There are additional details in  theimplementationthat ensure we split only critical edges rather than all edges, thatrecord block-successor information directly as we produce loweredblocks so that the subsequent backend stages do not need to recomputeit, and some other small optimizations.</p><p> 该实现中还有其他细节，可确保我们仅分割关键边缘而不是所有边缘，并在生成降低的块时直接记录块后继信息，以便后续后端阶段无需重新计算，以及其他一些小的优化。</p><p> This is illustrated in the following figure, showing a CLIF-level CFGtransformed with split edges and merged edge-blocks then linearized ata conceptual level; </p><p> 下图对此进行了说明，该图显示了CLIF级别CFG，该CFG级别已用分割边缘和合并的边缘块进行了转换，然后线性化了ata概念级别；</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cfallin.org/blog/2021/01/22/cranelift-isel-2/">https://cfallin.org/blog/2021/01/22/cranelift-isel-2/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/part/">#part</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分支/">#分支</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>