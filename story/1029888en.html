<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Git 2.29亮点</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Git 2.29亮点</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 03:23:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/1f2b2be319b55f9d6b730c81d2e39952.png"><img src="http://img2.diglog.com/img/2020/10/1f2b2be319b55f9d6b730c81d2e39952.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The open source Git project  just released Git 2.29 with features and bug fixes from over 89 contributors, 24 of them new. Last time  we caught up with you, Git 2.28 had just been released. One version later, let’s take a look at the most interesting features and changes that have happened since then.</p><p>开源的Git项目刚刚发布了Git2.29版本，包含了来自89个贡献者的功能和错误修复，其中24个是新的。上次我们追上你的时候，Git 2.28刚刚发布。再过一个版本，让我们来看看自那以后发生的最有趣的特性和变化。</p><p>  Git 2.29 includes experimental support for writing your repository’s objects using a SHA-256 hash of their contents, instead of using SHA-1.</p><p>Git2.29包含对使用内容的SHA-256散列(而不是使用SHA-1)编写存储库对象的试验性支持。</p><p> What does all of that mean? To explain, let’s start from the beginning.</p><p>这一切意味着什么？为了解释，让我们从头说起。</p><p> When you add files to a repository, Git copies their contents into  blob objects in its local database, and creates  tree objects that refer to the blobs. Likewise, when you run  git commit, this creates a  commit object that refers to the tree representing the committed state. How do these objects “refer” to each other, and how can you identify them when interacting with Git? The answer is that each object is given a unique name, called its  object id, based on a hash of its contents. Git uses SHA-1 as its hash algorithm of choice, and depends on the object ids of different objects to be unique.</p><p>当您将文件添加到存储库时，Git会将其内容复制到其本地数据库中的BLOB对象中，并创建引用BLOB的树状对象。同样，当您运行git Commit时，这将创建一个引用表示提交状态的树的提交树对象。这些对象如何“引用”彼此，在与Git交互时如何识别它们？答案是，基于其内容的散列，每个对象都被赋予一个唯一的名称，称为其唯一的对象ID。Git使用SHA-1作为其选择的散列算法，并依赖于不同对象的对象ID是唯一的。</p><p> Back in  this blog post, we estimated that even if you had five million programmers writing one commit every second, you would only have a 50% chance of accidentally generating a collision before the Sun engulfs the Earth.  Some  published  attacks exist which use tricks that exploit weaknesses in SHA-1 that can reduce the effort required to generate a collision, but these attacks still cost tens of thousands of dollars to execute, and no known examples have been published which target Git.</p><p>回到这篇博客文章中，我们估计，即使你有500万程序员每秒编写一个提交，在太阳吞噬地球之前，你也只有50%的机会意外地产生碰撞，但确实存在一些公开发表的攻击，它们利用SHA-1的弱点，可以减少产生碰撞所需的工作量，但这些攻击的执行成本仍然高达数万美元，而且还没有发布针对Git的已知示例。</p><p> Like we stated back in that earlier blog post, Git (and providers that use it, like GitHub) checks each object it hashes to see if there is evidence that that object is part of a colliding pair. This prevents GitHub from accepting both the benign and malicious halves of the pair, since the mathematical tricks required to generate a collision in any reasonable amount of time can be detected and rejected by Git.</p><p>正如我们在之前的博客文章中所说的那样，Git(以及使用它的提供商，如GitHub)检查它散列的每个对象，看看是否有证据表明该对象是冲突对的一部分。这可以防止GitHub同时接受该对中的良性和恶意两部分，因为在任何合理的时间内生成冲突所需的数学技巧都可以被Git检测和拒绝。</p><p> Even so, any weaknesses in a cryptographic hash are a bad sign. Even though Git has implemented detections that prevent the known attacks from being carried out, there’s no guarantee that new attacks won’t be found and used in the future. So the Git project has been preparing a transition plan to begin using a new object format with no known attacks: SHA-256.</p><p>即便如此，密码散列中的任何弱点都是不好的征兆。即使Git已经实现了阻止已知攻击执行的检测，也不能保证将来不会发现和使用新的攻击。因此，Git项目一直在准备过渡计划，以开始使用一种新的对象格式，并且没有已知的攻击：SHA-256。</p><p>  $  git --version git version 2.29.0$  git init --object-format=sha256 repo Initialized empty Git repository in /home/ttaylorr/repo/.git/$   cd repo$   echo   &#39;Hello, SHA-256! &#39;  &gt;README.md$  git add README.md$  git commit -m   &#34;README.md: initial commit &#34; [master (root-commit) 6e92961] README.md: initial commit  1 file changed, 1 insertion(+)  create mode 100644 README.md$  git rev-parse HEAD 6e929619da9d82c78dd854dfe237c61cbad9e95148c1849b1f96ada5ee800810</p><p>$git--version git version2.29.0$git init--object-format=sha256repo/HOME/ttaylorr/repo/.git/$cd repo$ECHO&#39；您好，sha-256！&#39；&gt；readme.md$git add readme.md$git Commit-m&#34；readme.md：初始提交&#34；[主(根-提交)6e92961]readme.md：初始提交1个文件已更改，1插入(+)创建模式100644 README.md$git rev-parse head 6e929619da9d82c78dd854dfe237c61cbad9e95148c1849b1f96ada5ee800810</p><p> As of version 2.29, Git can operate in either a full SHA-1 or full SHA-256 mode. It is currently not possible for repositories using different object formats to interoperate with one another, but eventual support is planned. It is also important to note that there are no major providers (including GitHub) which support hosting SHA-256-enabled repositories at the time of writing.</p><p>从2.29版开始，Git可以在完全SHA-1或完全SHA-256模式下运行。目前，使用不同对象格式的存储库不可能相互互操作，但计划提供最终的支持。还需要注意的是，在撰写本文时，还没有主要的提供商(包括GitHub)支持托管启用了SHA-256的存储库。</p><p> In future releases, Git will support interoperating between repositories with different object formats by computing both a SHA-1 and SHA-256 hash of each object it writes, and storing a translation table between them. This will eventually allow repositories that store their objects using SHA-256 to interact with (sufficiently up-to-date) SHA-1 clients, and vice-versa. It will also allow converted SHA-256 repositories to have their references to older SHA-1 commits still function as normal (e.g., if I write a commit whose message references an earlier commit by its SHA-1 name, then Git will still be able to follow that reference even after the repository is converted to use SHA-256 by consulting the translation table).</p><p>在未来的版本中，Git将通过计算其写入的每个对象的SHA-1和SHA-256散列，并在它们之间存储转换表，从而支持不同对象格式的存储库之间的互操作。这最终将允许使用SHA-256存储其对象的存储库与(充分最新的)SHA-1客户端交互，反之亦然。它还允许转换后的SHA-256存储库让它们对旧SHA-1提交的引用仍然正常工作(例如，如果我编写了一个提交，其消息通过其SHA-1名称引用了以前的提交，那么Git仍然能够遵循该引用，即使在通过查询转换表将存储库转换为使用SHA-256之后也是如此)。</p><p> For more about SHA-256 in Git, and what some of the future releases might look like, you can read  Git’s transition plan.</p><p>有关Git中SHA-256的更多信息，以及未来发布的一些版本可能是什么样子，您可以阅读Git的过渡计划。</p><p>   When you run  git fetch origin, all of the branches from the remote  origin repository are fetched into your local  refs/remotes/origin/ hierarchy. How does Git know which branches to fetch, and where to put them?</p><p>当您运行git Fetch Origin时，来自远程原始数据存储库的所有分支都将提取到您的本地文件引用/远程/原始/原始数据层次结构中。Git如何知道要获取哪些分支，以及将它们放在哪里？</p><p> The answer is that your configuration file contains one or more “refspecs” for each remote (remember that a “ref” is Git’s word for any named point in history: branches, tags, etc). When you run  git clone, it sets up a default refspec to be used when you fetch from your origin repository:</p><p>答案是您的配置文件包含每个遥控器的一个或多个“refspecs”(请记住，“ref”是Git对历史上任何命名点的描述：分支、标记等)。当您运行git克隆时，它会设置一个默认refspec，以便在您从原始存储库中提取时使用：</p><p>  This refspec tells Git to fetch what’s on the left side of the colon (everything in  refs/heads/; i.e., all branches) and to write them into the hierarchy on the right-hand side. The  * means “match everything” on the left-hand side and “replace with the matched part” on the right-hand side.</p><p>这个refspec告诉Git获取冒号左侧的内容(引用/头/中的所有内容；即所有分支)，并将它们写入右侧的层次结构中。左手边的意思是“全部匹配”，右手边的意思是“用匹配的零件替换”。</p><p> You can have multiple refspecs, and they can refer to individual refs. For example, this command instructs Git to additionally fetch any  git notes from the remote (the  --add is important so that we don’t overwrite the default refspec that fetches branches):</p><p>可以有多个参照等级库，它们可以参照单个参照。例如，此命令指示Git另外从远程获取任何git笔记(a--add参数很重要，这样我们就不会覆盖获取分支的默认refspec)：</p><p>  Refspecs are used by  git push, as well. Even if you type only  git push origin mybranch, that last  mybranch is really a shorthand for  refs/heads/mybranch:refs/heads/mybranch. This allows you to express more complicated scenarios. Say you’re tagging and want to push all of the tags you have, but you’re not quite ready to share the tips of all of your branches. Here, you could write something like:</p><p>参考规格也被GIT推送使用。即使你只输入一个git推送原点myBranch，最后的那个myBranch也真的是对refs/head/myBranch：refs/head/myBranch的一种速记。这使您可以表达更复杂的场景。假设您正在添加标签，并希望推送您拥有的所有标签，但您还没有完全准备好分享所有分支的提示。在这里，您可以编写如下内容：</p><p>  Prior to Git 2.29, refspecs could only be used to say which selection of reference(s) you want. So, if you wanted to fetch all branches except one, you’d have to list them out as arguments one by one. Of course, that assumes that you know the names of all the other references beforehand, so in practice this would look something like:</p><p>在Git 2.29之前，refspecs只能用来说明您需要选择哪种参照。因此，如果要提取除一个分支之外的所有分支，则必须将它们作为参数逐个列出。当然，这假设您事先知道所有其他引用的名称，因此在实践中应该类似于：</p><p> $  git ls-remote origin   &#39;refs/heads/* &#39;  |  grep -v ref-to-exclude |  awk &#39;{ print $2:$2 }&#39; |  xargs git fetch origin</p><p>$git ls-Remote Origin&#39；Refs/Heads/*&#39；|grep-v ref-to-exclude|awk&#39；{print$2：$2}&#39；|xargs git获取原点。</p><p> to get all refs in  refs/heads/* except for  refs/heads/ref-to-exclude. Yeesh; there must be a better way.</p><p>要获取除要排除的参考/头/参考之外的所有参考中的参考/头/*，请执行以下操作。是啊，一定有更好的办法。</p><p> In Git 2.29, there is: negative refspecs. Now, if a refspec begins with  ^ it indicates which references are to be excluded. So, instead of the above, you could write instead something like:</p><p>在Git 2.29中，有：负折射。现在，如果refspec以^开头，则表示要排除哪些引用。因此，您可以改写如下内容，而不是上面的内容：</p><p>  and achieve the same result. When a negative refspec is present, the server considers a reference worth sending if it matches at least one positive refspec and does not match any negative refspecs. Negative refspecs behave exactly as you expect, with a couple of caveats:</p><p>并达到同样的效果。当存在负refspec时，如果引用与至少一个正refspec匹配并且不匹配任何负refspec，则服务器认为该引用值得发送。负反射的行为完全符合您的预期，但有几个警告：</p><p> Negative refspecs can contain wildcard patterns, but cannot specify the destination. These wouldn’t mean anything, anyway (you wouldn’t want to say  ^refs/heads/foo/*:refs/heads/bar/* which means, literally, “map heads from  foo to  bar, but don’t send me any  foo refs to begin with”). To exclude a wildcard refspec, you’d just write  ^refs/heads/foo/*.</p><p>负参照规范可以包含通配符模式，但不能指定目标。这些无论如何都不会有任何意义(你不会想说^refs/head/foo/*：refs/head/bar/*，这就是说，从字面上来说，“把头从Foo映射到bar，但不要一开始就给我发任何foo/reff”)。要排除通配符refspec，只需编写^refs/head/foo/*。</p><p> While positive refspecs can refer to a single object by its object id, negative refspecs cannot.</p><p>正折射可以通过对象ID引用单个对象，而负折射不能。</p><p> And of course those negative refspecs work equally well in configuration values. If you always want to fetch every branch except  foo, you can just add it to your config:</p><p>当然，这些负反射在配置值中也同样有效。如果您总是想获取除foo之外的所有分支，只需将其添加到您的配置中即可：</p><p>    While you have almost certainly used (or heard of)  git log, the same might not be necessarily true of  git shortlog. For those who haven’t,  git shortlog acts a lot like  git log, except instead of displaying commits in a sequence, it groups them by the author.</p><p>虽然您几乎肯定使用过(或听说过)git日志，但对于git Shorlog可能不一定如此。对于那些没有这样做的人来说，Git Shorlog的行为很像Git日志，不同的是它不是按顺序显示提交，而是按照作者对它们进行分组。</p><p> In fact, the Git release notes end with a shortlog of all of the patches in the release, broken out by their author, generated by  git shortlog [ source]. At the time of writing, they look something like this:</p><p>事实上，Git版本说明以版本中所有补丁的简短日志结尾，这些补丁由其作者细分，由Git Short log生成[来源]。在撰写本文时，它们看起来如下所示：</p><p> Aaron Lipman (12): t6030: modernize &#34;git bisect run&#34; tests rev-list: allow bisect and first-parent flags cmd_bisect__helper: defer parsing no-checkout flag [...]Adrian Moennich (1): ci: fix inconsistent indentationAlban Gruin (1): t6300: fix issues related to %(contents:size)[...]</p><p>Aaron Lipman(12)：t6030：Modiize&#34；git二等分运行&#34；测试版本列表：允许二等分和第一父标志cmd_bisect__helper：延迟解析无签出标志[...]Adrian Moennich(1)：CI：修复不一致的缩进Alban Gruin(1)：t6300：修复与%(Contents：Size)[...]相关的问题。</p><p> In older versions of Git,  git shortlog could only group by commit author (the default behavior), and optionally by the committer identity (with  git shortlog -c). This restricts who gets the credit for a commit by who that commit’s author/committer is. So, if your project uses  the ‘Co-authored-by’ trailer (like  this commit in  git/git does), then your co-authors are out of luck: there is no way to tell  git shortlog to group commits by co-authors.</p><p>在旧版本的Git中，Git Shorlog日志只能按提交作者分组(默认行为)，也可以选择按提交者身份分组(使用.git Shorlog-c)。这限制了谁通过提交的作者/提交者获得提交的信用。所以，如果你的项目使用的是“合著者”预告片(就像这个在git/git中提交的预告片一样)，那么你的合著者就不走运了：没有办法告诉你git短日志是合著者的群组提交。</p><p> …That is, until Git 2.29! In this release,  git shortlog learned a new  --group argument, to specify how commits are grouped and assigned credit. It takes  --group=author (the default behavior from before) and  --group=committer (equivalent to  git shortlog -c), but it also accepts a  --group=trailer:&lt;field&gt; argument.</p><p>…。也就是说，直到Git2.29！在此版本中，Git Shorlog学习了一个新的分组参数-GROUP参数，以指定如何对提交进行分组和分配信用。它使用--group=Author(前面的默认行为)和a--group=commter log(等同于git Shorlog-c)，但它还接受参数：--group=trailer：&lt；field&gt；。</p><p> Passing the latter allows us to group commits by their co-authors, and it also allows for more creative uses. If your project is using the  Reviewed-by trailer, you can use  git shortlog to see who is reviewing the most patches:</p><p>通过后者，我们可以按合著者对提交进行分组，还可以使用更具创造性的用途。如果您的项目使用的是预告片审阅者，您可以使用git快捷日志查看谁审阅的补丁最多：</p><p> $  git shortlog -ns --group=trailer:reviewed-by v2.28.0..  | head -n5  40 Eric Sunshine  10 Taylor Blau  4 brian m. carlson  2 Elijah Newren  1 Jeff King</p><p>$GIT SHORTLOG-NS--GROUP=预告片：审阅-由v2.28.0..。海德-N5 40埃里克·阳光10泰勒·布劳4布莱恩·M·卡尔森2以利亚·纽伦1杰夫·金。</p><p> git shortlog also allows multiple  --group=&lt;type&gt; arguments, in which case commits are counted once per each grouping. So, if you want to see who is  contributing the most whether that individual is the primary author, or is listed as a co-author, then you can write:</p><p>Git Shortlog还允许多个参数--group=&lt；type&gt；，在这种情况下，每个分组都会计算一次提交。因此，如果你想看看谁贡献最多，无论这个人是第一作者，还是被列为共同作者，那么你可以写道：</p><p>  …putting authors and co-authors on equal footing. Instead of counting, you can also use the  --format option to find other fun ways to show the data. For example:</p><p>…。使作者和合著者处于平等的地位。除了计数，您还可以使用--format选项找到其他有趣的方式来显示数据。例如：</p><p> $  git shortlog --format=  &#34;...helped %an on %as &#34; --group=trailer:helped-by v2.28.0..v2.29.0 Chris Torek (3):  ...helped René Scharfe on 2020-08-12  ...helped René Scharfe on 2020-08-12  ...helped René Scharfe on 2020-08-12 David Aguilar (1):  ...helped Lin Sun on 2020-05-07 Denton Liu (1):  ...helped Shourya Shukla on 2020-08-21 Derrick Stolee (2):  ...helped Taylor Blau on 2020-08-25  ...helped Taylor Blau on 2020-09-17 [...]</p><p>$GIT SHORTLOG--format=&#34；...在%AS&#34；上帮助%an。--group=预告片：帮助-由v2.28.0..v2.29.0 Chris Torek(3)：...在2020-08-12帮助勒内·沙尔夫...在2020-08-12帮助勒内·沙尔夫...在2020-08-12帮助勒内·沙尔夫大卫·阿吉拉尔(1)：...帮助孙林在2020-05-07 Denton Liu(1)：...在2020-08-21帮助Shourya Shukla Derrick Stolee(2)：...帮助Taylor Blau在2020-08。-25...在2020-09-17帮助泰勒·布劳[...]。</p><p>   git for-each-ref learned a few new tricks in Git 2.29. Since there are a good handful of them, let’s start there:</p><p>Git for-each-ref在Git2.29中学习了一些新技巧。既然它们很多，我们就从这里开始吧：</p><p> git for-each-ref usually outputs the name, type, and object id of each ref, but you can find out a lot more with its   --format option. Git 2.29 learned some new fields, including  contents:size,  subject:sanitize, and more consistent  :short modifiers to get abbreviated object ids. These last few were contributed by  Hariom Verma, a Google Summer of Code student working on the Git project.[ source,  source]</p><p>Git for-each-ref通常输出每个ref的名称、类型和对象ID，但是您可以通过它的“--format”选项找到更多信息。Git 2.29学习了一些新字段，包括内容：Size、主题：Sanitize，以及更一致的元素：短修饰符，以获取缩写的对象ID。最后几个是由从事Git项目的谷歌代码之夏(Google Summer Of Code)学生哈里姆·维尔马(Hariom Verma)贡献的。[来源，来源]。</p><p> git for-each-ref can now take multiple  --merged and  --no-merged arguments, printing references if they are reachable from at least one  --merged argument, and aren’t reachable from any  --no-merged ones.[ source]</p><p>Git for-each-ref现在可以接受多个不合并的参数和不合并的参数，如果至少一个不合并的参数可以访问，则打印引用，而不能从任何不合并的参数中访问。[来源]。</p><p> Now with all of the  git for-each-ref updates out of the way, let’s move on to all of the rest of the tidbits:</p><p>现在，所有的GIT for-each-ref更新都消失了，让我们继续看一下其他所有的花絮：。</p><p> When your  git merge results in a merge conflict, you’re greeted by a message that looks something like the following (this example is  courtesy of Elijah Newren):  CONFLICT (rename/delete): foo.c deleted in b01dface... Removedunnecessary stuff and renamed in HEAD. Version HEAD of foo.c leftin tree.</p><p>当您的git合并导致合并冲突时，您会看到如下所示的消息(此示例由Elijah Newren提供)：Conflicts(Rename/Delete)：foo.c DELETED in b01dface...(此示例由Elijah Newren提供)：Conflict(Rename/Delete)：foo.c DELETED in b01dface...。删除了不必要的东西，并在Head中重新命名。Foo.c左侧树的版本头。</p><p> Can you tell what this message means? In versions of Git prior to 2.29, it was ambiguous: did Git remove stuff and rename files in  HEAD, or is “Removed unnecessary stuff” the name of a commit message? It turns out that it’s the latter, but you had no way of knowing that!</p><p>你能说出这条信息是什么意思吗？在2.29之前的Git版本中，这一点是模棱两可的：Git是删除了头部中的内容并重命名了文件，还是将“删除了不必要的内容”作为提交消息的名称？事实证明是后者，但你没有办法知道这一点！</p><p> In 2.29, Git will now enclose the subject of a commit message in parenthesis, making much clearer what part of the conflict message came from a commit, and what part was generated by Git.</p><p>在2.29中，Git现在将COMMIT消息的主题括在括号中，使冲突消息的哪一部分来自COMMIT，哪些部分由Git生成。</p><p> Here’s an easy one! Git supports a configuration option called  merge.renormalize. In case you’re not familiar on the entirety of Git’s  nearly 5,000 line  man git-config, here’s a refresher:  merge.renormalize causes Git to check-out and check-in each stage of a three-way merge. This can be useful if the line-endings change between two branches you’re working on.This configuration used to not get picked up by  git checkout -m (and a few related invocations), but now it is![ source]</p><p>这里有一个简单的问题！Git支持名为.merge.renormalize的配置选项。如果你不熟悉Git的近5000行/人git-config的全部内容，这里有一个刷新器：.merge.renormalize会导致Git检出和签入三向合并的每个阶段。如果您正在处理的两个分支之间的行尾发生变化，这可能会很有用。这个配置过去不会被.git checkout-m命令(以及一些相关的调用)拾取，但现在它可以了！[来源]。</p><p> In our highlights from Git 2.26, we talked about  protocol v2, which became the default in that release. Between 2.26 and 2.27, a bug in this new protocol was found and fixed (see   4fa3f00abb for the juicy details). For safety,  Git 2.27 went back to protocol “v0” to ease back the transition, and  marked the feature experimental in Git 2.28.Now that we’ve had a few chances to iron out any linger bugs after Git 2.28, protocol v2 is re-enabled as the default protocol in Git 2.29.[ source]</p><p>在Git2.26的亮点中，我们讨论了v2协议，该协议在该版本中成为默认协议。在2.26和2.27之间，发现并修复了这个新协议中的错误(有关详细信息，请参阅4fa3f00abb)。为了安全起见，Git 2.27回到了协议“V0”，以简化过渡，并在Git 2.28中标记了这一功能实验版本。现在我们有一些机会来消除Git 2.28之后的任何挥之不去的错误，协议v2在Git 2.29中被重新启用为默认协议。[来源]。</p><p> git bisect is an incredibly handy tool to use when trying to determine the source of a bug. You mark a “good” and “bad” endpoint, and then Git leads you through a binary search between the endpoints to find the commit that introduced the problem.In Git 2.29,  git bisect learned a new  --first-parent option to modify which commits are traversed between those endpoints. One way to understand this option is to imagine what happens when bisecting through a merge. Before, your bisection would include commits on the branch being merged in, in addition to the merge commit itself.Passing  --first-parent tells Git to avoid considering commits that are only on the branch being merged in as a potential source of the bug. If your workflow is such that only the merges on the main branch are interesting stopping points (because you primarily work by merging pull requests, and each individual pull request may have work-in-progress commits that might not even build), then  --first-parent lets you skip all that.</p><p>当试图确定错误的来源时，Git二等分是一个非常方便的工具。您标记一个“好”和“坏”端点，然后Git将引导您在端点之间进行二进制搜索，以找到导致问题的提交。在Git 2.29中，Git二等分学习了一个新的“父级优先”选项来修改在这些端点之间遍历哪些提交。理解此选项的一种方法是想象当通过合并一分为二时会发生什么。在此之前，除了合并提交本身之外，您的一分为二还将包括正在合并的分支上的提交。传递“第一父级”会告诉Git避免将仅在合并中的分支上的提交视为潜在的bug来源。如果您的工作流是这样的：只有主分支上的合并是有趣的停止点(因为您主要通过合并Pull请求来工作，并且每个单独的Pull请求可能都有可能甚至不会构建的正在进行的提交)，那么“第一父级”允许您跳过所有这些操作。</p><p> Git optionally includes a remote backend for pushing and pulling from a  MediaWiki instance. It is generally unsupported and not compiled by default, but a recently discovered vulnerability can lead to arbitrary command execution, which has been patched in this release.Note that you are only affected by this vulnerability if you use the mediawiki backend against an untrusted MediaWiki instance (chances are if you have to ask yourself whether or not you are affected, you probably aren’t).[ source]</p><p>Git可选地包括一个远程后端，用于从一个新的MediaWiki实例进行推送和拉取。它通常不受支持，并且在默认情况下不会编译，但最近发现的漏洞可能导致执行任意命令，此版本中已打了补丁。请注意，只有在对不受信任的MediaWiki实例使用mediawiki后端时，您才会受到此漏洞的影响(如果您必须问自己是否受到影响，则很可能不会)。[SOURCE]。</p><p> Git uses the low-level  git index-pack command to receive a  git push or process a  git fetch. In Git 2.29,  git index-pack learned to work more efficiently on multi-core machines, which means all of your pushes and fetches should get faster just by upgrading.[ source,  source]</p><p>Git使用低级的.git index-pack命令接收一个.git推送命令或处理一个.git获取。在Git2.29中，Git索引包学会了在多核计算机上更高效地工作，这意味着您的所有推送和读取只需升级就可以变得更快。[来源，来源]。</p><p> When you create a merge commit, the default message reads something like “Merge  $upstream into  $dest“. Historically, merges into the main branch would omit the “into  $dest” part.Git 2.29 learned  the  merge.suppressDest configuration. Any branch in this multi-valued config variable will cause  git merge to omit “into  $dest” part.[ source]</p><p>当您创建合并提交时，默认消息类似于“Merge at$upstream”into$DEST“。从历史上看，合并到主分支会省略“Into$DEST”部分。Git 2.29是从dmerge.suppressDest配置中了解到的。此多值配置变量中的任何分支都会导致GIT合并程序省略“INTO$DEST”部分.[来源]。</p><p>  That’s just a sample of changes from the latest release. For more, check out  the release notes for 2.29, or  any previous version in  the Git repository.</p><p>这只是最新版本更改的一个示例。有关更多信息，请在Git存储库中查看2.29的发行说明，或查看任何以前的版本。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2020-10-19-git-2-29-released/">https://github.blog/2020-10-19-git-2-29-released/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>