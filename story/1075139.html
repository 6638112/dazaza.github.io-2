<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GCC铁锈月报，2022年2月</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GCC铁锈月报，2022年2月</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 08:55:37</div><div class="page_narrow text-break page_content"><p>再次感谢开源安全公司和Embecosm对该项目的持续支持。</p><p>2月对GCC来说是一个重要的月份；我们之前的谷歌代码暑期学生阿瑟·科恩（Arthur Cohen）在德国的Embecosm加入我们，全职从事编译器的工作。有了额外的资源，我们可以拆分工作并委派任务，从而允许进行多个复杂的工作流，这将使Philip能够处理类型系统中的切片和bug。</p><p>关于我们的宏扩展里程碑，我们已经准备好了构建块，并且支持大多数声明性宏，尽管仍然有一些怪癖和错误需要解决。这个里程碑的剩余时间将用于设置内置宏和修复bug。</p><p>除了宏之外，2月份的工作重点是代码清理和bug修复，这是富有成效的。</p><p>是我们下一个社区电话的时候了，欢迎加入！🙂</p><p>添加对索引和范围项目的支持，以及用于切片类型检查PR974的锅炉板</p><p>我们已经改进了我们的规范路径跟踪，以便我们可以为遗留的损坏方案建立路径。例如，嵌套在模块下的impl块在其路径中被赋予一个impl前缀。</p><p>struct Foo（i32）；mod A{impl Foo{fn test（&amp；self）->i32{self.0}}}fn test（）{let A=Foo（123）；let b:i32=A.test（）；}</p><p>如您所见，我们有示例的板条箱名称-&gt；结构A-&gt；impl块例如：：A-&gt；函数名测试。</p><p>i32示例：：A:：&lt；impl示例：：Foo&gt；：：test（const struct example:：Foo&amp；const self）{i32 D.85；D.85=self-&gt；0；返回D.85；}void example:：test（）{const struct example:：Foo a；const i32 b；try{a.0=123；b=example:：a:&lt；impl example:：Foo&gt；：：test（&amp；a）；}最后{a={CLOBBER}；}</p><p>我们在cfg扩展中添加了对any、all和not谓词的支持，因此在本例中，这确保了为all谓词指定A和B。</p><p>struct Foo；impl Foo{#[cfg（all（A，B））]fn test（&amp；self）{}fn main（）{let A=Foo；A.test（）}</p><p>Rust允许我们为配置扩展指定键值对，这主要与主机/os/cpu选项有关，例如os=“linux”，但下面是一个示例，您可以在编译器资源管理器中尝试。</p><p>struct Foo；impl Foo{#[cfg（A=&#34；B&#34；）]fn test（&amp；self）{}fn main（）{let a=Foo；a.test（）；}</p><p>不带任何选项的Inline类似于C风格的Inline关键字，它向编译器提示此函数是内联的良好候选函数。Inline always可以通过GCC的Inline always属性实现：https://gcc.gnu.org/onlinedocs/gcc/Inline.html.最后，我们永远不能将函数标记为DECL_不可线性。一个区别是，内联优化需要启用优化。因此，当在-O0编译时，不会发生内联，任何级别大于此级别，都将强制执行内联传递。</p><p>方法解析方面的工作一直在稳步进行，我们现在支持deref_mut lang项目，因此对于需要a&amp；我们尝试从任何相关的接收者处获取所需的间接引用。</p><p>外部人员&#34；C&#34；{fn printf（s:*const i8，…）；}#[lang=&#34；deref&#34；]pub trait Deref{type Target；fn Deref（&amp；self）->self:：Target；}#[lang=&#34；deref#mut&#34；]pub trait DerefMut:Deref{fn Deref_mut（&amp；mut self）&gt；&amp；mut self:：Target；}impl&lt；T&gt；德雷夫；T{type Target=T；fn-deref（&amp；self）&gt；&amp；T{*self}impl&lt；T&gt；德雷夫；mut T{type Target=T；fn deref（&amp；self）&gt；&amp；T{*self}发布结构条（i32）；impl Bar{pub fn foobar（&amp；mut self）->i32{self.0}pub struct Foo&lt；T&gt；（T） )；impl&lt；T&gt；为Foo&lt；T&gt；{type Target=T；fn deref（&amp；self）&gt；&amp；self:：Target{&amp；self.0}}impl&lt；T&gt；对Foo&lt；T&gt；{fn deref_mut（&amp；mut self）&gt；&amp；mut self：：Target{safe{let a=&amp#34；mut_deref\n\0&#34；；let b=a as*const str；let c=b as*const i8；printf（c）；}&amp；莫特·赛尔夫。0}pub fn main（）-&gt；i32{let bar=bar（123）；let mut foo:foo&lt；bar&gt；=foo（bar）；let foobar=foo.foobar（）；foobar-123}</p><p>我们已经合并了我们的第一个宏观扩张通道。这里采用的方法是，我们重用现有的解析器来调用作为MacroFragmentType枚举的一部分指定的适当函数。如果解析器在解析该项时没有错误，那么它必须是匹配的。然后，一旦我们匹配了一个规则，我们就有了每个片段匹配的令牌开始/结束偏移的映射，然后用它来调整和创建宏规则定义的新令牌流，这样当我们将其提供给解析器时，令牌就已经被替换了。生成的表达式或项随后附加到相应的宏调用，然后解析名称并用于hir降低。</p><p>在这个例子中，宏有两个规则，所以我们证明我们匹配了适当的规则，并分别转录了它。</p><p>宏规则！添加{（$a:expr，$b:expr）=&gt；{$a+$b}；（$a:expr）=&gt；{$a}；}fn main（）-&gt；i32{let mut x=add！（1）；x+=add！（2,3）；x-6}</p><p>宏规则！测试{（$a:ident，$b:ty）=&gt；{struct$a（$b）；}；}测验（富，i32）；fn main（）-&gt；i32{let a=Foo（123）；a.0-123}</p><p>这里我们考虑宏调用的上下文，并将其解析为AST:：Items。如果未能匹配规则，编译器错误如下所示：</p><p>&lt；来源&gt；：11:17：错误：未能匹配宏1 |宏|规则中的任何规则！加{| ~..11 |让mut x=add！（1,2,3）|^</p><p>当转录规则实际上没有完全使用时，添加了更多错误处理，例如：</p><p>在rust中，范围被转换为结构，因此，指定某种约束的语法片段实际上是可以赋值和操作的。这是我们支持切片过程中的一个组成部分。</p><p>#[lang=&#34；RangeFull&#34；]pub struct RangeFull#[lang=&#34；范围&#34；]pub struct Range&lt；Idx&gt；{pub start:Idx，pub end:Idx，}#[lang=&#34；RangeFrom&#34；]pub struct RangeFrom&lt；Idx&gt；{pub start:Idx，}#[lang=&#34；RangeTo&#34；]酒吧结构RangeTo&lt；Idx&gt；{pub end:Idx，}#[lang=&#34；range inclusive&#34；]pub struct range inclusive&lt；Idx&gt；{pub start:Idx，pub end:Idx，}fn test（）{let a=1..2；//range let b=1..；//range from let c=..3；//range to let d=0..=2；//range inclusive}</p><p>支持切片的另一个构建块是支持索引lang item core:：ops:：index的能力，这样一个范围就可以作为参数，core:：slice:：index中的代码实际上可以成为从数组中获取切片的起点。</p><p>#[lang=&#34；索引&#34；]特质指数&lt；Idx&gt；{type Output；fn index（&amp；self，index:Idx）-&gt；&amp；self:：Output；}struct Foo（i32，i32）；impl索引&lt；isize&gt；对于Foo{type Output=i32；fn index（&amp；self，index:isize）->；i32{let a=Foo（1,2）；let b=a[0]；let c=a[1]；c-b-1}</p><p>宏匹配臂可以包含重复运算符，它指示传递单个标记或元变量的多个实例的可能性。</p><p>您可以使用Kleene运算符表示此类重复：有三种变体可用，？，+及*。每一个都对应于与运算符关联的标记数量的不同界限，类似于正则表达式。</p><p>宏规则！kleene{（$a:ident$（，）？）=&gt；{{}；（$（$i:literal tok）+）=&gt；{{ }}; （$（$e:expr）*）=&gt；{{ }};}</p><p>单数标识符，带有零个或一个逗号（模式：&lt；逗号&gt；，kleene运算符：？（0-&gt；1））</p><p>一个或多个文本后跟分隔符tok（模式$i:literal tok，kleene运算符：+（1-&gt；+inf））</p><p>实现宏重复的第一步是匹配给定给用户的实际模式。我们现在能够匹配简单的重复，但仍有一些限制和缺陷。例如，Rust引用指定了在片段说明符之后使用的有效分隔符，我们还没有检查这些分隔符。例如，禁止在$&lt&gt；：expr说明符，因为这可能会导致歧义：表达式后唯一允许的分隔符是=&gt&书信电报；逗号&gt；或</p><p>一旦匹配了这些重复模式，就很容易计算出用户给出了多少重复模式。我们将这些数据与片段的其余部分一起存储，以确保在转录时将所述模式扩展正确的次数。</p><p>我们将匹配重复3次，并将重复量3归因于$e元变量。</p><p>在匹配这些重复之后，我们可以递归地扩展模式中包含的所有标记。</p><p>再次考虑前面的声明和调用，我们可以将以下模式解析为要展开的模式：</p><p>然后，该模式被递归地扩展，就好像它是一个常规的宏调用一样。为了确保每个元变量得到正确的扩展，我们只给新的替代上下文提供匹配片段的子集。</p><p>宏规则！lit_plus_tok{（$（$e:literal tok）*）=&gt；{}lit_plus_tok！（&#34；rustc&#34；tok&#39；v&#39；tok 1.59 tok）；//原始匹配片段：{&#34；lit&#34；：[&#34；rustc&#34；，&#39；v&#39；，1.59]}//然后我们用{&#34；lit&#34；：[&#34；rustc&#34；]曾经与{&#34；lit&#34；：[&#39；v&#39；]}，//最后一次是{&#34；lit&#34；：[1.59]}，</p><p>同样，我们还没有实现某些限制：一些说明符急切地得到扩展，而一些保留在用户输入的表单下。</p><p>同样，并不是所有的重复模式都被恰当地覆盖。为了全面、正确地实施，有些问题仍有待解决。</p><p>为了实现某些特定的行为，rust标准库需要在编译器中内置一些宏。你可以在这里找到完整的清单。</p><p>GCCR的实施应考虑到标准rust库的编译，因为core和std都依赖于它们。</p><p>这些宏在核心库中定义为空，它们的转录器在编译器中作为一个简单函数提供。我们在GCCR中实现这些内置函数，作为返回抽象语法树片段的函数，这些片段在宏扩展阶段插入，然后与用户代码的其余部分一起降低到中间表示形式。</p><p>我们面前有一长串宏，其中一些应该可以轻松实现。如果你有兴趣参与进来，我们已经打开了关于内置宏的3个好的第一个问题，以及如何解决它们的详细指南。</p><p>非常感谢bjorn3对内置宏及其实现细节的帮助。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gcc/">#gcc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>