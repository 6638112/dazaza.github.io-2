<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>StoneKnifeForth（带有元圆编译器） StoneKnifeForth (With a Metacircular Compiler)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">StoneKnifeForth (With a Metacircular Compiler)<br/>StoneKnifeForth（带有元圆编译器） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-18 19:58:56</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/ce00794a028c72d5981243d49a05839d.png"><img src="http://img2.diglog.com/img/2021/2/ce00794a028c72d5981243d49a05839d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is StoneKnifeForth, a very simple language inspired by Forth. Itis not expected to be useful; instead, its purpose is to show howsimple a compiler can be. The compiler is a bit under two pages ofcode when the comments are removed.</p><p>这就是StoneKnifeForth，这是一种受Forth启发的非常简单的语言。预计它不会有用；相反，其目的是显示编译器的简单程度。删除注释时，编译器在两页代码下有点不足。</p><p> This package includes a “metacircular compiler” which is written inStoneKnifeForth and compiles StoneKnifeForth to an x86 Linux ELFexecutable.</p><p> 该软件包包括一个用“ StoneKnifeForth”编写的“元圆环编译器”，并将StoneKnifeForth编译为x86 Linux ELFexecutable。</p><p> There is also a StoneKnifeForth interpreter written in Python (testedwith Python 2.4). It seems to be about 100× slower than code emittedby the compiler.</p><p> 还有一个用Python编写的StoneKnifeForth解释器（已通过Python 2.4测试）。它似乎比编译器发出的代码慢100倍。</p><p>   compiling a version of the compiler from which comments and extrawhitespace have been “trimmed”, using the compiler compiled with thecompiler, takes about 0.02 seconds.</p><p>   使用通过编译器编译的编译器，编译从其中“删除”了注释和多余空格的编译器版本大约需要0.02秒。</p><p> So this is a programming language implementation that can recompileitself from source twice per 24fps movie frame. The entire “trimmed”source code is 1902 bytes, which is less than half the size of thenearest comparable project that I’m aware of,  otccelf, which is 4748bytes.</p><p> 因此，这是一种编程语言实现，可以每24fps电影帧从源代码重新编译一次。整个“修剪后的”源代码均为1902字节，不到我所知的最新类似项目otccelf（即4748字节）的一半。</p><p> As demonstrated by the interpreter written in Python, the programminglanguage itself is essentially machine-independent, with very fewx86 quirks:</p><p> 正如用Python编写的解释器所演示的那样，编程语言本身实质上是与机器无关的，很少有x86怪癖：</p><p>  (It would be fairly easy to make a tiny “compiler” if the sourcelanguage were, say, x86 machine code.)</p><p>  （如果源语言是x86机器代码，那么做一个小的“编译器”将很容易。） </p><p> The output executable is 4063 bytes, containing about 1400instructions.  valgrind reports that it takes 1,813,395 instructionsto compile itself. (So you would think that it could compile itselfin 2.6 ms. The long runtimes are a result of reading its input onebyte at at time.)</p><p>输出的可执行文件是4063字节，包含大约1400条指令。 valgrind报告说，它需要1,813,395条指令进行编译。 （因此，您会认为它可以在2.6 ms内自行编译。长时间运行是由于一次读取其输入字节的结果。）</p><p>   Alan Kay frequently expresses enthusiasm over the metacircular Lispinterpreter in the Lisp 1.5 Programmer’s Manual. For example, in http://acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=273&amp;page=4he writes:</p><p>   艾伦·凯（Alan Kay）在《 Lisp 1.5程序员手册》中经常表达对亚圆Lisp解释器的热情。例如，在http://acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=273&amp;page=4中，他写道：</p><p> Yes, that was the big revelation to me when I was in graduateschool — when I finally understood that the half page of code onthe bottom of page 13 of the Lisp 1.5 manual was Lisp initself. These were “Maxwell’s Equations of Software!” This is thewhole world of programming in a few lines that I can put my handover.I realized that anytime I want to know what I’m doing, I can justwrite down the kernel of this thing in a half page and it’s notgoing to lose any power. In fact, it’s going to gain power bybeing able to reenter itself much more readily than most systemsdone the other way can possibly do.</p><p> 是的，那是我读研究生时给我的最大启示-当我最终理解Lisp 1.5手册第13页底部的一半代码是Lisp本身时。这些就是“麦克斯韦的软件方程式！”这是整个编程世界，我可以进行几行切换。我意识到，只要我想知道自己在做什么，就可以将这个东西的内核写下一半，而不会丢失任何东西力量。实际上，它将比大多数系统通过其他方式可能完成的重新进入更加容易，从而获得动力。</p><p> But if you try to implement a Lisp interpreter in a low-level languageby translating that metacircular interpreter into it (as  I did laterthat year) you run into a problem. The metacircular interpreterglosses over a large number of things that turn out to be nontrivialto implement — indeed, about half of the code is devoted to thingsoutside of the scope of the metacircular interpreter. Here’s a listof issues that the Lisp 1.5 metacircular interpreter neglects, somesemantic and some merely implementational:</p><p> 但是，如果您试图通过将元循环解释器翻译成低级语言来实现它，那么就会遇到问题。元循环解释器对大量的事情产生了重要的影响，而事实证明，这些事情对实现而言并非无关紧要-实际上，大约一半的代码专用于元循环解释器范围之外的事情。这是Lisp 1.5元圆解释器忽略的一些问题，有些语义上的问题，而仅仅是一些实现方面的问题：</p><p>  In John C. Reynolds’s paper, “ Definitional InterpretersRevisited”, Higher-Order and Symbolic Computation, 11, 355–361(1998), he says:</p><p>  在约翰·雷诺兹（John C. Reynolds）的论文“ Revisited InterpretersRevisited”，高阶和符号计算，第11卷，第355–361页（1998年）中，他说：</p><p> In the fourth and third paragraphs before the end of Section 5, Ishould have emphasized the fact that a metacircular interpreter isnot really a deﬁnition, since it is trivial when the deﬁninglanguage is understood, and otherwise it is ambiguous. Inparticular, Interpreters I and II say nothing about order ofapplication, while Interpreters I and III say little abouthigher-order functions. Jim Morris put the matter more strongly:</p><p> 在第5节结束之前的第四段和第三段中，我应该强调一个事实，即元圆解释器并不是真正的定义，因为当理解定义语言时，它是微不足道的，否则它是模棱两可的。特别是，口译员I和II对应用程序顺序一无所知，而口译员I和III对高阶功能一无所知。吉姆·莫里斯（Jim Morris）更加坚决地说：</p><p> The activity of deﬁning features in terms of themselves is highlysuspect, especially when they are as subtle as functionalobjects. It is a fad that should be debunked, in my opinion. Areal signiﬁcance of [a self-deﬁned] interpreter . . . is that itdisplays a simple universal function for the language inquestion.</p><p> 就自身而言，定义要素的活动令人高度怀疑，尤其是当它们与功能对象一样微妙时。我认为，这是一种时尚，应予以揭穿。 [自定义的]解释程序的区域意义。 。 。它显示了一个简单的通用语言查询功能。 </p><p> On the other hand, I clearly remember that John McCarthy’sdeﬁnition of LISP [1DI], which is a deﬁnitional interpreter in thestyle of II, was a great help when I ﬁrst learned that language. Butit was not the sole support of my understanding.</p><p>另一方面，我清楚地记得约翰·麦卡锡（John McCarthy）对LISP [1DI]的定义，它是一种II风格的定义解释器，当我第一次学习该语言时，它就提供了很大的帮助。但是，这并不是我的理解的唯一支持。</p><p> (For what it’s worth, it may not even the case that self-definedinterpreters are necessarily Turing-complete; it might be possible towrite a non-Turing-complete metacircular interpreter for anon-Turing-complete language, such as David Turner’s Total FunctionalProgramming systems.)</p><p> （就其价值而言，自定义解释器不一定是图灵完备的；甚至可以为非图灵完备的语言编写非图灵完备的元圆解释器，例如David Turner的Total FunctionalProgramming系统）</p><p> A metacircular compiler forces you to confront this extra complexity.Moreover, metacircular compilers are self-sustaining in a way thatinterpreters aren’t; once you have the compiler running, you are freeto add features to the language it supports, then take advantage ofthose features in the compiler.</p><p> 元循环编译器迫使您面对这种额外的复杂性。此外，元循环编译器以一种解释器没有的方式实现自我维持。一旦运行了编译器，就可以随意向其支持的语言中添加功能，然后利用编译器中的这些功能。</p><p> So this is a “stone knife” programming tool: bootstrapped out ofalmost nothing as quickly as possible.</p><p> 因此，这是一个“石刀”编程工具：几乎一无所获。</p><p>  When I wrote Ur-Scheme, my thought was to see if I could figure outhow to develop a compiler incrementally, starting by building a smallworking metacircular compiler in less than a day, and adding featuresfrom there. I pretty much failed; it took me two and a half weeks toget it to compile itself successfully.</p><p>  当我写Ur-Scheme时，我的想法是看我是否可以找出如何逐步开发编译器的方法，首先是在不到一天的时间内构建一个小型的元圆编译器，然后从中添加功能。我几乎失败了；我花了两个半星期的时间才能成功地进行自我编译。</p><p> Part of the problem is that a minimal subset of R5RS Scheme powerfulenough to write a compiler in — without making the compiler evenlarger due to writing it in a low-level language — is still arelatively large language. Ur-Scheme doesn’t have much arithmetic,but it does have integers, dynamic typing, closures, characters,strings, lists, recursion, booleans, variadic functions,  let tointroduce local variables, character and string literals, a sort ofcrude macro system, five different conditional forms (if, cond, case,and, or), quotation, tail-call optimization, function argument countverification, bounds checking, symbols, buffered input to keep it fromtaking multiple seconds to compile itself, and a library of functionsfor processing lists, strings, and characters. And each of thosethings was added because it was necessary to get the compiler to beable to compile itself. The end result was that the compiler is 90kilobytes of source code, about 1600 lines if you leave out thecomments.</p><p> 问题的一部分是，R5RS计划的最小子集足以在其中编写编译器，而不会因使用低级语言编写而使编译器更大，而仍然是比较大的语言。 Ur-Scheme并没有太多算术功能，但它确实具有整数，动态类型，闭包，字符，字符串，列表，递归，布尔值，可变参数函数，让我们介绍局部变量，字符和字符串文字，一种粗略的宏系统，五种不同的条件形式（if，cond，case和or），引号，尾调用优化，函数参数计数验证，边界检查，符号，缓冲输入（以使其无需花费几秒钟的时间自行编译）以及用于处理的函数库列表，字符串和字符。并添加了所有这些内容，因为必须使编译器能够自行编译。最终结果是编译器的源代码为90 KB，如果不加注释，则大约为1600行。</p><p> Now, maybe you can write 1600 lines of working Scheme in a day, but Isure as hell can’t. It’s still not a very large compiler, ascompilers go, but it’s a lot bigger than  otccelf. So I hypothesizedthat maybe a simpler language, without a requirement for compatibilitywith something else, would enable me to get a compiler bootstrappedmore easily.</p><p> 现在，也许您一天可以编写1600行工作方案，但是我确信这是不可能的。编译器来看，它仍然不是一个很大的编译器，但是它比otccelf大得多。因此，我假设也许是一种更简单的语言，而不要求与其他任何东西兼容，这将使我能够更轻松地引导编译器。 </p><p> So StoneKnifeForth was born. It’s inspired by Forth, so it inheritsmost of Forth’s traditional simplifications:</p><p>于是StoneKnifeForth诞生了。它受到了Forth的启发，因此继承了大部分Forth的传统简化形式：</p><p>    Surprisingly, the language that results is still almost bearable towrite a compiler in, although it definitely has the flavor of anassembler.</p><p>    出人意料的是，尽管它确实具有汇编程序的风格，但所产生的语言仍然几乎可以用其编写编译器。</p><p> Unfortunately, I still totally failed to get it done in a day. It was15 days from when I first started scribbling about it in my notebookuntil it was able to compile itself successfully, although  git onlyshows active development happening on six of those days (includingsome help from my friend Aristotle). So that’s an improvement, butnot as much of an improvement as I would like. At that point, it was13k of source, 114 non-comment lines of code, which is definitely alot smaller than Ur-Scheme’s 90k and 1600 lines. (Although there areanother 181 lines of Python for the bootstrap interpreter.)</p><p> 不幸的是，我仍然无法在一天内完成它。从我第一次在笔记本中开始对其进行刻划直到它能够成功编译它已经有15天了，尽管git仅显示出在那六天中发生了积极的发展（包括我朋友亚里斯多德的一些帮助）。这是一种改进，但并不是我想要的那样多的改进。到那时，它只有13k的源代码和114条非注释行，绝对比Ur-Scheme的90k和1600行小很多。 （虽然还有另外181行Python用于引导程序解释器。）</p><p> It’s possible to imagine writing and debugging 114 lines of code in aday, or even 300 lines. It’s still maybe a bit optimistic to think I coulddo that in a day, so maybe I need to find a way to increaseincrementality further.</p><p> 可以想象一天编写和调试114行代码，甚至300行。认为我可以在一天内做到这一点仍然有些乐观，因此也许我需要找到一种进一步增加增量的方法。</p><p> My theory was that once I had a working compiler, I could add featuresto the language incrementally and test them as I went. So far Ihaven’t gotten to that part.</p><p> 我的理论是，一旦有了一个可以运行的编译器，就可以逐步向语言中添加功能并在进行测试时对其进行测试。到目前为止，Ihaven尚未涉及到这一部分。</p><p>   In order to find the optimal cost/benefit ratio, Wirth used a highlyintuitive metric, the origin of which is unknown to me but that mayvery well be Wirth’s own invention. He used the compiler’sself-compilation speed as a measure of the compiler’squality. Considering that Wirth’s compilers were written in thelanguages they compiled, and that compilers are substantial andnon-trivial pieces of software in their own right, this introduced ahighly practical benchmark that directly contested a compiler’scomplexity against its performance. Under the self-compilation speedbenchmark, only those optimizations were allowed to be incorporatedinto a compiler that accelerated it by so much that the intrinsiccost of the new code addition was fully compensated.</p><p>   为了找到最佳的成本/收益比，Wirth使用了一种高度直观的指标，该指标的起源对我来说还是未知的，但这很可能是Wirth自己的发明。他使用编译器的自编译速度来衡量编译器的质量。考虑到Wirth的编译器是用他们所编译的语言编写的，并且编译器本身就是实质性的，非平凡的软件，因此引入了高度实用的基准，直接使编译器的复杂性与性能发生了竞争。在自编译速度基准下，仅允许将这些优化合并到编译器中，以加快编译速度，以至于新代码添加的内在成本得到了充分补偿。</p><p> Wirth is clearly one of the great apostles of simplicity inprogramming, together with with Edsger Dijkstra and Chuck Moore. ButI doubt very much that the Oberon compiler could ever compile itselfin 2 million instructions, given the complexity of the Oberonlanguage.</p><p> Wisth与Edsger Dijkstra和Chuck Moore一起显然是简化编程的伟大使徒之一。但是我非常怀疑，鉴于Oberon语言的复杂性，Oberon编译器能否以200万条指令进行编译。 </p><p> R. Kent Dybvig used the same criterion; speaking of the 1985–1987development of Chez Scheme,  he writes:</p><p>R. Kent Dybvig使用了相同的标准。在谈到1985-1987年的Chez计划的发展时，他写道：</p><p> At some point we actually instituted the following rule to keep alid on compilation overhead: if an optimization doesn’t make thecompiler itself enough faster to make up for the cost of doing theoptimization, the optimization is discarded. This ruled out severaloptimizations we tried, including an early attempt at a sourceoptimizer.</p><p> 在某个时候，我们实际上制定了以下规则来保持编译开销：如果优化不能使编译器自身更快地弥补执行优化的费用，则该优化将被放弃。这排除了我们尝试的几种优化，包括早期尝试使用sourceoptimizer。</p><p>  The obvious way that it could be useful is that you could read it andlearn things from it, then put them to use in actually usefulsoftware. This section is about the far-fetched ways instead.</p><p>  它可能有用的一种明显方式是，您可以阅读它并从中学到东西，然后将其用于实际有用的软件中。本节是关于牵强的方法。</p><p> If you want to counter Ken Thompson’s “Trusting Trust” attack, youwould want to start with a minimal compiler on a minimal chip;StoneKnifeForth might be a good approach.</p><p> 如果您想对抗肯·汤普森（Ken Thompson）的“信任信任”（Trusting Trust）攻击，则希望以最小的编译器和最小的芯片开始； StoneKnifeForth可能是一个很好的方法。</p><p>    There are straightforward changes to reduce the executable sizefurther, but they would make the compiler more complicated, notsimpler. Some of the most-referenced routines should be open-coded,which should also speed it up, as well as making them available toother programs compiled with the same compiler. Here are the routinesthat were called in more than 10 places some time ago:</p><p>    有一些直接的更改可以进一步减少可执行文件的大小，但是它们会使编译器更加复杂，而不是更简单。一些引用最多的例程应该是开放代码的，这也应该加快速度，并使它们可用于使用同一编译器编译的其他程序。以下是一段时间前在十多个地方调用的例程：</p><p> 11 0x169 xchg 13 0xc20 Lit 22 0x190 - (now replaced by +, which is only used in 25 places) 25 0x15b pop 26 0x1bc = 35 0x13d dup 60 0x286 .</p><p> 11 0x169 xchg 13 0xc20亮22 0x190-（现在由+代替，仅在25个地方使用）25 0x15b pop 26 0x1bc = 35 0x13d dup 60 0x286。</p><p> Of these,  xchg,  pop,  -,  =, and  dup could all be open-codedat zero or negative cost at the call sites, and then their definitionsand temporary variables could be removed.</p><p> 其中，xchg，pop，-，=和dup都可以在呼叫站点以零成本或负成本进行开放编码，然后可以删除它们的定义和临时变量。 </p><p> I tried out open-coding  xchg,  pop,  dup, and  +. The executableshrank by 346 bytes (from 4223 bytes to 3877 bytes, an 18% reduction;it also executed 42% fewer instructions to compile itself, from1,492,993 down to 870,863 on the “trimmed” version of itself), and thesource code stayed almost exactly the same size, at 119 non-commentlines; the machine-code definitions were one line each. They looklike this:</p><p>我尝试了对xchg，pop，dup和+进行开放编码。该可执行文件缩减了346字节（从4223字节减少到3877字节，减少了18％；在自身的“修剪”版本上，它也减少了42％的指令进行编译，从1,492,993减少到870,863），并且源代码几乎保持不变大小完全相同，共有119条非注释行；机器代码定义各占一行。他们看起来像这样：</p><p> dup &#39;d = [ pop 80 . ; ] ( dup is `push %eax` )dup &#39;p = [ pop 88 . ; ] ( pop is `pop %eax` )dup &#39;x = [ pop 135 . 4 . 36 . ; ] ( xchg is xchg %eax, (%esp)dup &#39;+ = [ pop 3 . 4 . 36 . 89 . ; ] ( `add [%esp], %eax; pop %ecx` )</p><p> dup＆＃39d = [pop 80。 ; ]（dup是`push％eax`）dup＆＃39; p = [pop 88。 ; ]（pop是`pop％eax`）dup＆＃39; x = [pop 135。 4。 36。 ; ]（xchg是xchg％eax，（％esp）dup＆＃39; + = [pop 3。4。36。89。;]（`add [％esp]，％eax; pop％ecx`）</p><p> However, I decided not to do this. The current compiler alreadycontains 58 bytes of machine code, and this would add another 9 bytesto that. The high-level Forth definitions ( : dup X ! ; and thelike) are, I think, easier to understand and verify the correctnessof; and they don’t depend on lower-level details like whatarchitecture we’re compiling for, or how we represent the stacks.Additionally, it adds another step to the bootstrap process.</p><p> 但是，我决定不这样做。当前的编译器已经包含58个字节的机器代码，这将再增加9个字节。我认为高级Forth定义（：dup X！;等）更容易理解和验证的正确性。并且它们不依赖于底层细节，例如我们要编译的体系结构或我们如何表示堆栈。此外，它为引导过程增加了另一步。</p><p>  Forth uses two stacks: one for procedure nesting (the “return stack”)and one for parameter passing (the “data stack” or “operand stack”).This arrangement is shared by other Forth-like languages such asPostScript and HP calculator programs. Normally, in Forth, unlike inthese other languages, the “return stack” is directly accessible tothe user.</p><p>  Forth使用两个堆栈：一个用于过程嵌套（“返回堆栈”），另一个用于参数传递（“数据堆栈”或“操作数堆栈”）。这种安排由其他类似Forth的语言共享，例如PostScript和HP计算器程序。通常，在Forth中，与其他语言不同，用户可以直接访问“返回堆栈”。</p><p> Right now, StoneKnifeForth stores these two stacks mostly in memory,although it keeps the top item of the operand stack in  %eax. Theregisters  %esp and  %ebp point to the locations of the stacks inmemory; the one that’s currently being used is in  %esp, and theother one is in  %ebp. So the compiler has to emit an  xchg %esp, %ebp instruction whenever it switches between the two stacks. As aresult, when compiling itself, something like 30% of the instructionsit emits are  xchg %esp, %ebp.</p><p> 现在，StoneKnifeForth主要将这两个堆栈存储在内存中，尽管它会将操作数堆栈的顶部保留在％eax中。寄存器％esp和％ebp指向堆栈内存的位置。当前正在使用的一个在％esp中，另一个在％ebp中。因此，每当在两个堆栈之间切换时，编译器必须发出xchg％esp，％ebp指令。因此，在编译自身时，发出的指令中有30％左右是xchg％esp，％ebp。</p><p> Inspired, I think, by colorForth, I considered just keeping theoperand stack pointer in  %edi and using it directly from there,rather than swapping it into  %esp. The x86 has a  stosdinstruction (GCC calls it  stosl) which will write a 32-bit value in %eax into memory at  %edi and increment (or decrement)  %edi by 4,which is ideal for pushing values from  %eax (as in  Lit, to makeroom for the new value). Popping values off the stack, though,becomes somewhat hairier. The  lodsd or  lodsl instruction thatcorresponds to  stosl uses  %esi instead of  %edi, you have to set“DF”, the direction flag, to get it to decrement instead ofincrementing, and like  stosl, it accesses memory  before updatingthe index register, not after.</p><p> 我认为，受colorForth的启发，我考虑仅将操作数堆栈指针保留在％edi中并从那里直接使用它，而不是将其交换到％esp中。 x86具有存储指令（GCC称为stosl），它将在％edi中将％eax中的32位值写入内存，并将％edi递增（或递减）4，这对于从％eax推入值（如点亮，为新值腾出空间）。但是，从堆栈中弹出值会变得有些毛茸茸。对应于stosl的lodsd或lodsl指令使用％esi而不是％edi，您必须设置“ DF”（方向标志），使其减量而不是递增，并且像stosl一样，它在更新索引寄存器之前而不是之后访问内存。</p><p> So, although we would eliminate a lot of redundant and ugly  xchginstructions in the output, as well as the  Restack,  u,  U, and %flush functions, a bunch of the relatively simple instructionsequences currently emitted by the compiler would become hairier.I think the changes are more or less as follows:</p><p> 因此，尽管我们将消除输出中的大量冗余和丑陋的xchgin指令以及Restack，u，U和％flush函数，但编译器当前发出的一堆相对简单的指令序列将变得更加毛茸茸。变化大致如下： </p><p> ! is currently  pop (%eax); pop %eax, which is three bytes; thisoccurs 17 times in the output. The new code would be:sub $8, %edimov 4(%edi), %ecxmov %ecx, (%eax)mov (%edi), %eaxThis is ten bytes.  store, the byte version of  !, is similar.</p><p>！当前流行（％eax）；弹出％eax，它是三个字节；这会在输出中出现17次。新代码将是：sub $ 8，％edimov 4（％edi），％ecxmov％ecx，（％eax）mov（％edi），％eax这是十个字节。存储，！的字节版本与此类似。</p><p> - is currently  sub %eax, (%esp); pop %eax, which is four bytes;this occurs 23 times in the output. The new code would be sevenbytes:sub $4, %edisub %eax, (%edi)mov (%edi), %eaxThere&#39;s something analogous in  &lt;, although it only occurs threetimes.</p><p> -当前为％eax（％esp）；弹出％eax，它是四个字节;这在输出中发生23次。新代码将为7个字节：sub $ 4，％edisub％eax，（％edi）mov（％edi），％eax＆lt;＆lt; 39;类似的东西，虽然它只出现3次。</p><p> in  JZ,  jnz, and  Getchar, there are occurrences of  pop %eax,which is one byte (88). The new code would be five bytes:sub $4, %edimov (%edi), %eax JZ occurs 38 times in the output,  jnz occurs 5 times, andGetchar occurs once.</p><p> 在JZ，jnz和Getchar中，会出现弹出％eax，它是一个字节（88）。新代码将为5个字节：$ 4，subedmov（％edi），％eax JZ在输出中发生38次，jnz发生5次，Getchar发生一次。</p><p> There are 193 occurrences of  push %eax in the output code at themoment, each of which is followed by a move-immediate into %eax.These would just change to  stosd, which is also one byte.</p><p> 当时在输出代码中有193次推送％eax出现，每一次紧随其后的是立即移动到％eax中，这些都将变为stosd，这也是一个字节。</p><p> So this change would increase the amount of machine code in thecompiler source by 10 - 3 + 7 - 4 + 5 - 1 + 5 - 1 + 5 - 1 = 22 bytes,which is a lot given that there’s only 58 bytes there now; I thinkthat would make the compiler harder to follow, although  Restack doestoo. It would also increase the size of the compiler output by (10 -3) * 17 + (7 - 4) * 23 + (5 - 1) * (38 + 5 + 1) = 364 bytes, althoughit would eliminate 430  xchg %esp, %ebp instructions, two bytes each,for a total of 2 * 430 - 364 = 496 bytes less; and the resultingprogram would gain (4 - 2) * 17 + (3 - 2) * 23 + (2 - 1) * (38 + 5 +</p><p> 因此，此更改将使编译器源中的机器代码数量增加10-3 + 7-4 + 5-1 + 5-1 + 5-1 = 22字节，这是一个很大的数字，因为现在那里只有58个字节；我认为这会使编译器更难遵循，尽管Restack也不行。它还将使编译器输出的大小增加（10 -3）* 17 +（7-4）* 23 +（5-1）*（38 + 5 +1）= 364字节，尽管这将消除430 xchg％ esp，％ebp指令，每个两个字节，总共2 * 430-364 =少496个字节；结果程序将获得（4-2）* 17 +（3-2）* 23 +（2-1）*（38 + 5 +</p><p>  My initial thought was that it would be silly to space-optimizepopping at the expense of pushing; although they happen the samenumber of times during the execution of the program, generally moredata is passed to callees than is returned to callers, so the numberof push sites is greater than the number of pop sites. (In thisprogram, it’s about a factor of 2, according to the above numbers.)Also, consumers of values from the stack often want to do somethinginteresting with the top two values on the stack, not just discard thetop-of-stack:  - subtracts,  &lt; compares,  ! and  store send it tomemory. Only  JZ and  jnz (and  pop) just want to discardtop-of-stack — but to my surprise, they make up half of the pops.</p><p>  我最初的想法是，以推挤为代价，对空间进行优化弹出是很愚蠢的。尽管它们在程序执行期间发生相同的次数，但通常传递给被调用方的数据要多于返回给调用方的数据，因此，推送站点的数量大于弹出站点的数量。 （在该程序中，根据上述数字，它大约是2的倍数。）此外，堆栈值的使用者经常想对堆栈中的前两个值做一些有趣的事情，而不仅仅是丢弃堆栈顶部：-减去＆lt;比较，！并存储发送给内存。只有JZ和jnz（和流行音乐）只想放弃堆栈顶部-但令我惊讶的是，它们占流行音乐的一半。</p><p> However, I wasn’t thinking about the number of places in the compilerwhere machine code would be added. What if I used  %esi instead of %edi, to get a single-byte single-instruction pop (in the form of lodsl) instead of a single-byte push? This would make  Lit (theonly thing that increases the depth of the operand stack) uglier, andeach of the 193 occurrencies of  push %eax that result from the 193calls to  Lit in the compilation process would get four bytes bigger(totaling 772 extra bytes) but the seven or so primitives that decrease the depth of the operand stack would gain less extracomplexity. And we’d still lose the  xchg %esp, %ebp crap, includingthe code to avoid emitting them.</p><p> 但是，我没有考虑要在编译器中添加机器代码的位置数量。如果我使用％esi而不是％edi来获取单字节单指令pop（以lodsl的形式）而不是单字节推入怎么办？这会使Lit（增加操作数堆栈深度的唯一操作）变得更丑陋，并且在编译过程中193次调用Lit导致的193％推送％eax出现的每种193次都会变大4个字节（总共增加772个字节），但是减小操作数堆栈深度的七个原语将获得较少的额外复杂性。而且我们仍然会丢失xchg％esp，％ebp废话，包括避免发出它们的代码。 </p><p>    If we move the creation of the ELF header and  Msyscall and  /buf torun-time instead of compile-time, we could eliminate the  # and byte compile-time directives, both from the compiler and theinterpreter; the output would be simpler;  Msyscall and  /bufwouldn&#39;t need two separate names and tricky code to poke them into theoutput; the tricky code wouldn’t need a nine-line comment explainingit; the characters ‘E’, ‘L’, and ‘F’ wouldn’t need to be magicnumbers.</p><p>如果将ELF标头和Msyscall和/ buf的创建移至运行时而不是编译时，则可以从编译器和解释器中消除＃和字节编译时指令；输出将更简单； Msyscall和/ bufwouldn不需要两个单独的名称和棘手的代码将它们戳到输出中；棘手的代码不需要用9行注释来解释它；字符“ E”，“ L”和“ F”不需要是幻数。</p><p>   Maybe building a compiler for a slightly bigger and better language ontop of this one. Maybe something like Lua, Scheme, or Smalltalk. Afirst step toward that would be something that makes parsing a littlemore convenient. Another step might be to establish some kind ofintermediate representation in the compiler, and perhaps some kind ofpattern-matching facility to make it easier to specify rewrites on theintermediate representation (either for optimizations or for codegeneration).</p><p>   也许在此基础之上构建一种用于更大，更好的语言的编译器。也许像Lua，Scheme或Smalltalk之类的东西。第一步是使解析更加方便。另一步骤可能是在编译器中建立某种中间表示，或者某种某种模式匹配功能，以使其更容易在中间表示上指定重写（用于优化或代码生成）。</p><p> Certainly the system as it exists is not that convenient to programin, the code is pretty hard to read, and when it fails, it is hard todebug — especially in the compiler, which doesn’t have any way to emiterror messages. Garbage collection, arrays with bounds-checking,finite maps (associative arrays), strong typing (any typing, really),dynamic dispatch, some thing that saves you from incorrect stackeffects, metaprogramming, and so on, these would all help; aninteractive REPL would be a useful non-linguistic feature.</p><p> 当然，现有的系统编程起来并不方便，代码很难阅读，并且在失败时也很难调试-尤其是在编译器中，它没有发出错误消息的任何方式。垃圾回收，带有边界检查的数组，有限映射（关联数组），强类型（实际上是任何类型），动态派发，可以使您免于不正确的堆栈效应，元编程等的所有这些工作；交互式REPL将是有用的非语言功能。</p><p>  I (Kragen Javier Sitaker) wrote StoneKnifeForth in 2008 and publishedit immediately in Argentina. I didn&#39;t add an explicit copyrightlicense at the time, but here is one now:</p><p>  我（Kragen Javier Sitaker）于2008年撰写了StoneKnifeForth，并立即在阿根廷出版。当时我没有添加明确的版权许可，但现在是一个：</p><p>     is a small imperative programming language that is just powerfulenough to compile itself (compiler bootstrapping).</p><p>     是一种小的命令式编程语言，具有强大的编译能力（编译器自举）。</p><p>  Version 0.9 was released 15 Jul 2006. The 1000 source lines include arecursive-descent parser and a hand-coded lexer.</p><p>  0.9版于2006年7月15日发布。1000条源代码行包括递归下降语法分析器和手工编码的词法分析器。</p><p>  // return 1 if ch is in s, 0 elsefunc in(ch: char, s: array char): intvar i: intbegin i = 0 while s[i] # 0 do if ch = s[i] then return 1 endif i = i + 1 wend return 0end</p><p>  //如果ch在s中，则返回1，否则返回0 elsefunc in（ch：char，s：array char）：intvar i：intbegin i = 0而s [i]＃0如果ch = s [i]，则返回1 endif i = i + 1温德返回0end </p><p>       Jack Crenshaw’s  Let’s Build a Compiler. This is a how-to bookthat walks you through an incrementally-constructed compiler for a toylanguage, written in Pascal, in about 340 pages of text. The text isreally easy to read, but it will still take at least three to tenhours to read. It uses recursive-descent parsing, no intermediaterepresentation, and it emits 68000 assembly code.</p><p>杰克·克伦肖（Jack Crenshaw）的“让我们构建一个编译器”。 这是一本使用手册，它引导您逐步完成以Pascal编写的约340页文字的玩具语言编译器的编译。 文字确实很容易阅读，但仍然至少需要三到十个小时才能阅读。 它使用递归下降解析，没有中间表示，并且发出68000汇编代码。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/kragen/stoneknifeforth">https://github.com/kragen/stoneknifeforth</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>