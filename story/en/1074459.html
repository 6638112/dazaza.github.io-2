<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>自动合并：一种类似JSON的数据结构（CRDT），可以同时修改Automerge: A JSON-like data structure (a CRDT) that can be modified concurrently</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Automerge: A JSON-like data structure (a CRDT) that can be modified concurrently<br/>自动合并：一种类似JSON的数据结构（CRDT），可以同时修改</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 16:21:56</div><div class="page_narrow text-break page_content"><p>A common approach to building JavaScript apps involves keeping the state of your application inmodel objects, such as a JSON document. For example, imagine you are developing a task-tracking appin which each task is represented by a card. In vanilla JavaScript you might write the following:</p><p>构建JavaScript应用程序的一种常见方法是将应用程序的状态保存在模型对象中，例如JSON文档。例如，假设您正在开发一个任务跟踪应用程序，其中每个任务都由一张卡片表示。在vanilla JavaScript中，您可以编写以下内容：</p><p> const  doc  =  {  cards:  [ ]  } // User adds a card doc . cards . push ( {  title:  &#39;Reticulate splines&#39; ,  done:  false  } ) // User marks a task as done doc . cards [ 0 ] . done  =  true</p><p>const doc={cards:[]}//用户添加一个卡片文档。卡。push（{title:&#39；网状样条线&#39；，done:false}）//用户将任务标记为已完成文档。卡片[0]。完成=正确</p><p> Automerge is used in a similar way, but the big difference is that it supports  automatic syncingand merging:</p><p>Automerge的使用方式类似，但最大的区别在于它支持自动同步和合并：</p><p> You can have a copy of the application state locally on several devices (which may belong to thesame user, or to different users). Each user can independently update the application state ontheir local device, even while offline, and save the state to local disk.</p><p>您可以在多个设备（可能属于同一用户或不同用户）上本地拥有应用程序状态的副本。每个用户都可以独立地更新其本地设备上的应用程序状态，甚至在脱机时，并将状态保存到本地磁盘。</p><p> When a network connection is available, Automerge figures out which changes need to be synced fromone device to another, and brings them into the same state.</p><p>当网络连接可用时，Automerge会计算出哪些更改需要从一个设备同步到另一个设备，并使它们处于相同的状态。</p><p> (Similar to git, which lets you push your own changes, and pull changes from other developers,when you are online.)</p><p>（与git类似，git允许您在联机时推送自己的更改，并从其他开发人员那里获取更改。）</p><p> If the state was changed concurrently on different devices, Automerge automatically merges thechanges together cleanly, so that everybody ends up in the same state, and no changes are lost.</p><p>如果状态在不同的设备上同时更改，Automerge会自动将更改干净地合并在一起，这样每个人都会处于相同的状态，并且不会丢失任何更改。</p><p> Automerge keeps track of the changes you make to the state, so that you can view old versions,compare versions, create branches, and choose when to merge them.</p><p>自动合并跟踪您对状态所做的更改，以便您可以查看旧版本、比较版本、创建分支，以及选择何时合并它们。</p><p>  Network-agnostic. Automerge is a pure data structure library that does not care about whatkind of network you use. It works with any connection-oriented network protocol, which could beclient/server (e.g. WebSocket), peer-to-peer (e.g. WebRTC), or entirely local (e.g. Bluetooth).Bindings to particular networking technologies are handled by separate libraries;see the section on  Sending and receiving changes for examples.It also works with unidirectional messaging: you can send an Automerge file as email attachment,or on a USB drive in the mail, and the recipient will be able to merge it with their version.</p><p>网络不可知论者。Automerge是一个纯数据结构库，它不关心您使用的网络类型。它适用于任何面向连接的网络协议，可以是客户端/服务器（如WebSocket）、对等（如WebRTC）或完全本地（如蓝牙）。特定网络技术的绑定由单独的库处理；有关示例，请参阅“发送和接收更改”一节。它也适用于单向消息：你可以通过电子邮件附件或邮件中的USB驱动器发送自动合并文件，收件人可以将其与他们的版本合并。</p><p> Immutable state. An Automerge object is an immutable snapshot of the application state at onepoint in time. Whenever you make a change, or merge in a change that came from the network, youget back a new state object reflecting that change. This fact makes Automerge compatible with thefunctional reactive programming style of  React and Redux, for example.</p><p>不变的状态。自动合并对象是应用程序状态在某个时间点的不可变快照。无论何时进行更改，或合并来自网络的更改，都会返回一个反映该更改的新状态对象。例如，这一事实使Automerge与React和Redux的功能反应式编程风格兼容。</p><p> Automatic merging. Automerge is a  Conflict-Free Replicated Data Type ( CRDT),which allows concurrent changes on different devices to be merged automatically without requiring anycentral server. It is based on  academic research on JSON CRDTs, butthe details of the algorithm in Automerge are different from the JSON CRDT paper, and we areplanning to publish more detail about it in the future.</p><p>自动合并。自动合并是一种无冲突的复制数据类型（CRDT），它允许自动合并不同设备上的并发更改，而无需任何中央服务器。它基于对JSON CRDT的学术研究，但Automerge中的算法细节与JSON CRDT论文不同，我们计划在未来发布更多细节。</p><p> Fairly portable. We&#39;re not yet making an effort to support old platforms, but we have testedAutomerge in Node.js, Chrome, Firefox, Safari, MS Edge, and  Electron.For TypeScript users, Automerge comes with type definitionsthat allow you to use Automerge in a type-safe way.</p><p>相当便携。我们&#39；我们还没有努力支持旧平台，但我们已经在Node中测试了融合。js、Chrome、Firefox、Safari、MS Edge和Electron。对于TypeScript用户，Automerge附带了类型定义，允许您以类型安全的方式使用Automerge。</p><p> Automerge is designed for creating  local-first software,i.e. software that treats a user&#39;s local copy of their data (on their own device) as primary, ratherthan centralising data in a cloud service. The local-first approach enables offline working whilestill allowing several users to collaborate in real-time and sync their data across multipledevices. By reducing the dependency on cloud services (which may disappear if someone stops payingfor the servers), local-first software can have greater longevity, stronger privacy, and betterperformance, and it gives users more control over their data.The  essay on local-first software goes into moredetail on the philosophy behind Automerge, and the pros and cons of this approach.</p><p>Automerge旨在创建本地第一软件，即处理用户的软件#39；将其数据的本地副本（在自己的设备上）作为主副本，而不是将数据集中在云服务中。本地优先的方法允许脱机工作，同时允许多个用户实时协作，并跨多个设备同步他们的数据。通过减少对云服务的依赖（如果有人停止支付服务器的费用，云服务可能会消失），local first软件可以拥有更长的使用寿命、更强的隐私和更好的性能，并让用户对其数据拥有更多的控制权。关于local first software的文章更详细地介绍了Automerge背后的理念，以及这种方法的优缺点。</p><p> However, if you want to use Automerge with a centralised server, that works fine too! You still getuseful benefits, such as allowing several clients to concurrently update the data, easy sync betweenclients and server, being able to inspect the change history of your app&#39;s data, and support forbranching and merging workflows.</p><p>然而，如果你想在一个集中服务器上使用Automerge，那也可以！您仍然可以获得一些有用的好处，例如允许多个客户端同时更新数据，客户端和服务器之间轻松同步，能够检查应用程序的更改历史记录&#39；支持分支和合并工作流。</p><p>  If you&#39;re using npm,  npm install automerge. If you&#39;re using yarn,  yarn add automerge. Then youcan import it with  require(&#39;automerge&#39;) as in  the example below (or import * as Automerge from &#39;automerge&#39; if using ES2015 or TypeScript).</p><p>如果你&#39；重新使用npm，npm安装自动合并。如果你&#39；重新使用纱线，纱线添加自动合并。然后可以使用require（&#39；自动合并&#39；）导入它如下面的示例所示（如果使用ES2015或TypeScript，则从&#39；自动合并&#39；导入*作为自动合并）。</p><p>  yarn build — creates a bundled JS file  dist/automerge.js for web browsers. It includes thedependencies and is set up so that you can load through a script tag.</p><p>纱线构建-创建捆绑的JS文件dist/automerge。用于web浏览器的js。它包括依赖项，并设置为可以通过脚本标记加载。</p><p>     // This is how you load Automerge in Node. In a browser, simply including the // script tag will set up the Automerge object. const  Automerge  =  require ( &#39;automerge&#39; ) // Let&#39;s say doc1 is the application state on device 1. // Further down we&#39;ll simulate a second device. // We initialize the document to initially contain an empty list of cards. let  doc1  =  Automerge . from ( {  cards:  [ ]  } ) // The doc1 object is treated as immutable -- you must never change it // directly. To change it, you need to call Automerge.change() with a callback // in which you can mutate the state. You can also include a human-readable // description of the change, like a commit message, which is stored in the // change history (see below). doc1  =  Automerge . change ( doc1 ,  &#39;Add card&#39; ,  doc  =&gt;  {  doc . cards . push ( {  title:  &#39;Rewrite everything in Clojure&#39; ,  done:  false  } ) } ) // Now the state of doc1 is: // { cards: [ { title: &#39;Rewrite everything in Clojure&#39;, done: false } ] } // Automerge also defines an insertAt() method for inserting a new element at // a particular position in a list. Or you could use splice(), if you prefer. doc1  =  Automerge . change ( doc1 ,  &#39;Add another card&#39; ,  doc  =&gt;  {  doc . cards . insertAt ( 0 ,  {  title:  &#39;Rewrite everything in Haskell&#39; ,  done:  false  } ) } ) // { cards: // [ { title: &#39;Rewrite everything in Haskell&#39;, done: false }, // { title: &#39;Rewrite everything in Clojure&#39;, done: false } ] } // Now let&#39;s simulate another device, whose application state is doc2. We // initialise it separately, and merge doc1 into it. After merging, doc2 has // a copy of all the cards in doc1. let  doc2  =  Automerge . init ( ) doc2  =  Automerge . merge ( doc2 ,  doc1 ) // Now make a change on device 1: doc1  =  Automerge . change ( doc1 ,  &#39;Mark card as done&#39; ,  doc  =&gt;  {  doc . cards [ 0 ] . done  =  true } ) // { cards: // [ { title: &#39;Rewrite everything in Haskell&#39;, done: true }, // { title: &#39;Rewrite everything in Clojure&#39;, done: false } ] } // And, unbeknownst to device 1, also make a change on device 2: doc2  =  Automerge . change ( doc2 ,  &#39;Delete card&#39; ,  doc  =&gt;  {  delete  doc . cards [ 1 ] } ) // { cards: [ { title: &#39;Rewrite everything in Haskell&#39;, done: false } ] } // Now comes the moment of truth. Let&#39;s merge the changes from device 2 back // into device 1. You can also do the merge the other way round, and you&#39;ll get // the same result. The merged result remembers that &#39;Rewrite everything in // Haskell&#39; was set to true, and that &#39;Rewrite everything in Clojure&#39; was // deleted: let  finalDoc  =  Automerge . merge ( doc1 ,  doc2 ) // { cards: [ { title: &#39;Rewrite everything in Haskell&#39;, done: true } ] } // As our final trick, we can inspect the change history. Automerge // automatically keeps track of every change, along with the &#34;commit message&#34; // that you passed to change(). When you query that history, it includes both // changes you made locally, and also changes that came from other devices. You // can also see a snapshot of the application state at any moment in time in the // past. For example, we can count how many cards there were at each point: Automerge . getHistory ( finalDoc ) . map ( state  =&gt;  [ state . change . message ,  state . snapshot . cards . length ] ) // [ [ &#39;Initialization&#39;, 0 ], // [ &#39;Add card&#39;, 1 ], // [ &#39;Add another card&#39;, 2 ], // [ &#39;Mark card as done&#39;, 2 ], // [ &#39;Delete card&#39;, 1 ] ]</p><p>//这是在节点中加载自动合并的方式。在浏览器中，只需包含//script标记即可设置自动合并对象。const Automerge=require（&#39；Automerge&#39；）//让&#39；假设doc1是设备1上的应用程序状态。//再往下走&#39；我将模拟第二台设备。//我们初始化文档，使其最初包含一个空的卡片列表。让doc1=Automerge。from（{cards:[]}）//doc1对象被视为不可变的——您绝不能直接更改它。要更改它，需要调用自动合并。带有回调//的change（），您可以在其中改变状态。您还可以包括一个人类可读的//更改描述，比如提交消息，它存储在//更改历史记录中（见下文）。doc1=自动合并。change（doc1，&#39；Add card&#39；，doc=&gt；{doc.cards.push（{title:&#39；在Clojure中重写所有内容&#39；，done:false}）//现在doc1的状态是：//{cards:[{title:&#39；在Clojure中重写所有内容&#39；，done:false}]//Automerge（）还定义了一种插入方法，用于在//列表中的特定位置。如果愿意，也可以使用splice（）。doc1=自动合并。更改（doc1，&#39；添加另一张卡片&#39；，doc=&gt；{doc.cards.insertAt（0，{title:&#39；重写Haskell中的所有内容&#39；，done:false}）/{cards://{title:&#39；重写Haskell中的所有内容&#完成：false}，/{title:&&#39；重写Clojure中的所有内容&#完成：false}；s模拟另一个设备，其应用程序状态为doc2。我们//单独初始化它，并将doc1合并到其中。合并后，doc2//拥有doc1中所有卡片的副本。让doc2=自动合并。init（）doc2=Automerge。merge（doc2，doc1）//现在在设备1上进行更改：doc1=Automerge。更改（doc1，&#39；将卡片标记为已完成&#39；，doc=&gt；{doc.cards[0].done=true}）/{cards://{title:&#39；在Haskell中重写所有内容&#39；，完成：true}，/{title:&#39；在Clojure中重写所有内容&#39；，完成：false}//，并且在设备1未知的情况下，也在设备2上进行更改：doc2=Automerge。改变（doc2，&#39；删除卡片&#39；，doc=&gt；{Delete doc.cards[1]}）/{cards:[{title:&#39；重写Haskell中的所有内容&#39；，done:false}///现在是关键时刻。让&#39；s将设备2/的更改合并回设备1。你也可以用另一种方式合并，你&#39；我会得到同样的结果。合并的结果记住&#39；重写//Haskell&#39中的所有内容；设定为真，这&#39；用Clojure&#39改写一切；已//删除：让finalDoc=Automerge。合并（doc1，doc2）/{cards:[{title:&#39；在Haskell中重写所有内容&#39；，done:true}]}//作为最后一个技巧，我们可以检查更改历史。自动合并//自动跟踪每次更改，以及&#34；提交消息&#34；//你传给了change（）。当您查询该历史记录时，它既包括//您在本地所做的更改，也包括来自其他设备的更改。您//还可以在//过去的任何时刻查看应用程序状态的快照。例如，我们可以计算每个点有多少张牌：自动合并。getHistory（finalDoc）。映射（state=&gt；[state.change.message，state.snapshot.cards.length]）/[&[39；Initialization&[39,0]，/[&[39；Add card&#39；，1]，/[39；Add card&#39；，2]，/[&[39；Mark card as done&#39；，2]，/[39；Delete card&[39；]</p><p>     Automerge.from(initialState) creates a new Automerge document and populates it with the contentsof the object  initialState.</p><p>自动合并。from（initialState）创建一个新的自动合并文档，并用对象initialState的内容填充它。</p><p>   An Automerge document must be treated as immutable. It is  never changed directly, only with the Automerge.change function, described  below.</p><p>自动合并文档必须视为不可变。它永远不会直接更改，只有通过自动合并。更改功能，如下所述。</p><p> At the moment, Automerge does not enforce this immutability due to the performance cost. If you want to make thedocument object strictly immutable you can pass an option:  Automerge.init({freeze: true}) or Automerge.load(string, {freeze: true}).</p><p>目前，由于性能成本的原因，Automerge没有强制执行这种不变性。如果要使文档对象严格不可变，可以传递一个选项：Automerge。初始化（{freeze:true}）或自动合并。加载（字符串，{freeze:true}）。</p><p>  Automerge.change(doc, message, changeFn) enables you to modify an Automerge document  doc,returning an updated copy of the document.</p><p>自动合并。更改（doc、message、changeFn）允许您修改自动合并文档文档，并返回文档的更新副本。</p><p> The  changeFn function you pass to  Automerge.change() is called with a mutable version of  doc,as shown below.</p><p>传递给自动合并的changeFn函数。change（）是通过doc的可变版本调用的，如下所示。</p><p> The optional  message argument allows you to attach an arbitrary string to the change, which is notinterpreted by Automerge, but saved as part of the change history. You can omit the  messageargument and simply call  Automerge.change(doc, callback).</p><p>可选的message参数允许您将任意字符串附加到更改，该更改不会被自动合并解释，而是保存为更改历史的一部分。您可以省略messageargument，只需调用Automerge。更改（文档，回拨）。</p><p>  newDoc  =  Automerge . change ( currentDoc ,  doc  =&gt;  {  // NOTE: never modify `currentDoc` directly, only ever change `doc`!  doc . property  =  &#39;value&#39;  // assigns a string value to a property  doc [ &#39;property&#39; ]  =  &#39;value&#39;  // equivalent to the previous line  delete  doc [ &#39;property&#39; ]  // removes a property  // all JSON primitive datatypes are supported  doc . stringValue  =  &#39;value&#39;  doc . numberValue  =  1  doc . boolValue  =  true  doc . nullValue  =  null  doc . nestedObject  =  { }  // creates a nested object  doc . nestedObject . property  =  &#39;value&#39;  // you can also assign an object that already has some properties  doc . otherObject  =  {  key:  &#39;value&#39; ,  number:  42  }  // Arrays are fully supported  doc . list  =  [ ]  // creates an empty list object  doc . list . push ( 2 ,  3 )  // push() adds elements to the end  doc . list . unshift ( 0 ,  1 )  // unshift() adds elements at the beginning  doc . list [ 3 ]  =  Math . PI  // overwriting list element by index  // now doc.list is [0, 1, 2, 3.141592653589793]  // Looping over lists works as you&#39;d expect:  for  ( let  i  =  0 ;  i  &lt;  doc . list . length ;  i ++ )  doc . list [ i ]  *=  2  // now doc.list is [0, 2, 4, 6.283185307179586]  doc . list . splice ( 2 ,  2 ,  &#39;automerge&#39; )  // now doc.list is [0, &#39;hello&#39;, &#39;automerge&#39;, 4]  doc . list [ 4 ]  =  {  key:  &#39;value&#39;  }  // objects can be nested inside lists as well  // Arrays in Automerge offer the convenience functions `insertAt` and `deleteAt`  doc . list . insertAt ( 1 ,  &#39;hello&#39; ,  &#39;world&#39; )  // inserts elements at given index  doc . list . deleteAt ( 5 )  // deletes element at given index  // now doc.list is [0, &#39;hello&#39;, &#39;world&#39;, 2, 4] } )</p><p>newDoc=自动合并。change（currentDoc，doc=&gt；{//注意：永远不要直接修改'currentDoc'，只更改'doc'！doc.property=&#39；value&#39；//为属性doc[&#39；property&#39；]指定字符串值=&#39;价值&#39；//相当于上一行删除文档[&#39；属性&#39；]//删除属性//支持所有JSON基元数据类型。stringValue=&#39；价值&#39；医生。numberValue=1个文档。布尔值=真文档。空值=空文档。nestedObject={}//创建一个嵌套对象文档。嵌套对象。财产=&#39；价值&#39；//还可以指定已经具有某些属性的对象。otherObject={key:&#39；value&#39；，number:42}//完全支持数组。list=[]//创建一个空的list对象doc。列表push（2，3）//push（）将元素添加到结束文档中。列表unshift（0，1）//unshift（）在文档的开头添加元素。列表[3]=数学。PI//通过索引覆盖列表元素//现在是文档。列表是[0,1,2,3.141592653589793]//在列表上循环就像你&#39；d expect:for（让i=0；i&lt；doc.list.length；i++）doc。list[i]*=2//now doc。清单是[0,2,4,6.283185307179586]文件。列表拼接（2,2和#39；自动合并和#39；）//现在医生。列表是[0，&#39；你好&#39；&#39；自动合并&#39；，4]doc。列表[4]={key:&#39；value&#39；}//对象也可以嵌套在列表中//自动合并中的数组提供了方便的函数“insertAt”和“deleteAt”doc。列表插页（1，&#39；你好&#39；&#39；世界&#39；）//在给定的索引文档中插入元素。列表deleteAt（5）//删除给定索引处的元素//现在是doc。列表是[0，&#39；你好&#39；&#39；世界&#39；，2，4]）</p><p> The  newDoc returned by  Automerge.change() is a regular JavaScript object containing all theedits you made in the callback. Any parts of the document that you didn&#39;t change are carried overunmodified. The only special things about it are:</p><p>自动合并返回的newDoc。change（）是一个常规JavaScript对象，包含您在回调中所做的所有编辑。文件中您未提及的任何部分&#39；改变不会被改变。它唯一的特点是：</p><p> Every object has a unique ID, which you can get by passing the object to the Automerge.getObjectId() function. This ID is used by Automerge to track which object is which.</p><p>每个对象都有一个唯一的ID，可以通过将对象传递给自动合并来获得该ID。getObjectId（）函数。自动合并使用此ID跟踪哪个对象是哪个对象。</p><p> Objects also have information about  conflicts, which is used when several users make changes tothe same property concurrently (see  below). You can get conflicts usingthe  Automerge.getConflicts() function.</p><p>对象还包含有关冲突的信息，当多个用户同时更改同一属性时会使用这些信息（见下文）。您可以使用自动合并获取冲突。getConflicts（）函数。</p><p>  If you have previously worked with immutable state in JavaScript, you might be in the habit ofusing  idioms like these:</p><p>如果您以前在JavaScript中使用过不可变状态，您可能会习惯使用以下习惯用法：</p><p> state  =  Automerge . change ( state ,  &#39;Add card&#39; ,  doc  =&gt;  {  const  newItem  =  {  id:  123 ,  title:  &#39;Rewrite everything in Rust&#39; ,  done:  false  }  doc . cards  =  {  ids:  [... doc . cards . ids ,  newItem . id ] ,  entities:  { ... doc . cards . entities ,  [ newItem . id ]:  newItem  }  } } )</p><p>状态=自动合并。更改（state，&#39；Add card&#39；，doc=&gt；{const newItem={id:123，title:&#39；重写Rust中的所有内容&#39；，done:false}doc.cards={id:[…doc.cards.ids，newItem.id]，entications:{…doc cards.enties，[newItem.id]：newItem}）</p><p> While this pattern works fine outside of Automerge, please  don&#39;t do this in Automerge! Pleaseuse mutable idioms to update the state instead, like this:</p><p>虽然这种模式在自动合并之外运行良好，但请不要&#39；不要在自动合并中这样做！请使用可变习惯用法来更新状态，如下所示：</p><p> state  =  Automerge . change ( state ,  &#39;Add card&#39; ,  doc  =&gt;  {  const  newItem  =  {  id:  123 ,  title:  &#39;Rewrite everything in Rust&#39; ,  done:  false  }  doc . cards . ids . push ( newItem . id )  doc . cards . entities [ newItem . id ]  =  newItem } )</p><p>状态=自动合并。更改（state，&#39；Add card&#39；，doc=&gt；{const newItem={id:123，title:&#39；重写Rust中的所有内容&#39；，done:false}doc.cards.ids.push（newItem.id）doc。卡。实体[newItem.id]=newItem}）</p><p> Even though you are using mutating APIs, Automerge ensures that the code above does not actuallymutate  state, but returns a new copy of  state in which the changes are reflected. The problemwith the first example is that from Automerge&#39;s point of view, you are replacing the entire doc.cards object (and everything inside it) with a brand new object. Thus, if two usersconcurrently update the document, Automerge will not be able to merge those changes (instead, youwill just get a conflict on the  doc.cards property).</p><p>即使您使用的是变异API，Automerge也会确保上面的代码不会实际改变状态，而是返回反映更改的状态的新副本。第一个例子的问题是来自Automerge&#39；在s看来，您正在替换整个文档。卡片对象（以及其中的所有内容）带有一个全新的对象。因此，如果两个用户同时更新文档，Automerge将无法合并这些更改（相反，您只会在doc.cards属性上遇到冲突）。</p><p> The second example avoids this problem by making the changes at a fine-grained level: adding oneitem to the array of IDs with  ids.push(newItem.id), and adding one item to the map of entitieswith  entities[newItem.id] = newItem. This code works much better, since it tells Automergeexactly which changes you are making to the state, and this information allows Automerge to dealmuch better with concurrent updates by different users.</p><p>第二个示例通过在细粒度级别进行更改来避免这个问题：使用ID向ID数组中添加oneitem。推送（newItem.id），并将一个项目添加到实体映射中，实体[newItem.id]=newItem。这段代码工作得更好，因为它准确地告诉Automerge您正在对状态进行哪些更改，并且此信息允许Automerge更好地处理不同用户的并发更新。</p><p> As a general principle with Automerge, you should make state updates at the most fine-grainedlevel possible. Don&#39;t replace an entire object if you&#39;re only modifying one property of thatobject; just assign that one property instead.</p><p>作为自动合并的一般原则，应该尽可能以最精细的粒度级别进行状态更新。唐&#39；如果&#39；您只修改该对象的一个属性；只需分配一个属性即可。</p><p>  Automerge.save(doc) serializes the state of Automerge document  doc to a byte array( Uint8Array), which you can write to disk (e.g. as a file on the filesystem if you&#39;re usingNode.js, or to IndexedDB if you&#39;re running in a browser). The serialized data contains the fullchange history of the document (a bit like a Git repository).</p><p>自动合并。save（doc）将自动合并文档doc的状态序列化为字节数组（Uint8Array），您可以将其写入磁盘（例如，如果重新使用node.js，则将其作为文件系统上的文件；如果在浏览器中运行，则将其写入IndexedDB）。序列化的数据包含文档的完整更改历史（有点像Git存储库）。</p><p>  const  actorId  =  &#39;1234-abcd-56789-qrstuv&#39; const  doc1  =  Automerge . init ( actorId ) const  doc2  =  Automerge . from ( {  foo:  1  } ,  actorId ) const  doc3  =  Automerge . load ( str ,  actorId )</p><p>const actorId=&#39；1234-abcd-56789-qrstuv和#39；const doc1=自动合并。init（actorId）const doc2=自动合并。from（{foo:1}，actorId）const doc3=Automerge。加载（str，actorId）</p><p> The  actorId is a string that uniquely identifies the current node; if you omit  actorId, arandom UUID is generated. If you pass in your own  actorId, you must ensure that there can neverbe two different processes with the same actor ID. Even if you have two different processesrunning on the same machine, they must have distinct actor IDs.</p><p>actorId是唯一标识当前节点的字符串；如果省略actorId，将生成arandom UUID。如果传入自己的actorId，则必须确保不能有两个具有相同参与者ID的不同进程。即使在同一台计算机上运行两个不同的进程，它们也必须具有不同的参与者ID。</p><p> Unless you know what you are doing, you should stick with the default, and let  actorId beauto-generated.</p><p>除非你知道自己在做什么，否则你应该坚持默认设置，让actorId beauto生成。</p><p>  The Automerge library itself is agnostic to the network layer — that is, you can use whatevercommunication mechanism you like to get changes from one node to another. There are currently a fewoptions, with more under development:</p><p>自动合并库本身对网络层来说是不可知的——也就是说，你可以使用你喜欢的任何通信机制从一个节点到另一个节点进行更改。目前有几个选项，还有更多正在开发中：</p><p> Use  Automerge.getChanges() and  Automerge.applyChanges() to manually capture changes on onenode and apply them on another. These changes are encoded as byte arrays ( Uint8Array). You canalso store a log of these changes on disk in order to persist them.</p><p>使用自动合并。getChanges（）和自动合并。applyChanges（）手动捕获onenode上的更改并将其应用于另一个。这些更改被编码为字节数组（Uint8Array）。您还可以将这些更改的日志存储在磁盘上，以便将其持久化。</p><p> Use  Automerge.generateSyncMessage() to generate messages, send them over any transport protocol(e.g. WebSocket), and call  Automerge.receiveSyncMessage() on the recipient to process themessages. The sync protocol is documented in SYNC.md.</p><p>使用自动合并。generateSyncMessage（）生成消息，通过任何传输协议（如WebSocket）发送消息，并调用Automerge。收件人上的receiveSyncMessage（）来处理消息。同步协议以同步方式记录。医学博士。</p><p> There are also a number of external libraries that provide network sync for Automerge; these arein the process of being updated for the Automerge 1.0 data format and sync protocol.</p><p>还有一些外部库为自动合并提供网络同步；正在更新Automerge 1.0数据格式和同步协议。</p><p>  // On one node let  newDoc  =  Automerge . change ( currentDoc ,  doc  =&gt;  {  // make arbitrary change to the document } ) let  changes  =  Automerge . getChanges ( currentDoc ,  newDoc ) // broadcast changes as a byte array network . broadcast ( changes ) // On another node, receive the byte array let  changes  =  network . receive ( ) let  [ newDoc ,  patch ]  =  Automerge . applyChanges ( currentDoc ,  changes ) // `patch` is a description of the changes that were applied (a kind of diff)</p><p>//在一个节点上，让newDoc=Automerge。更改（currentDoc，doc=&gt；{//对文档进行任意更改}）让更改=自动合并。getChanges（currentDoc，newDoc）//将更改作为字节数组网络广播。广播（更改）//在另一个节点上，接收字节数组let changes=network。receive（）让[newDoc，patch]=自动合并。applyChanges（currentDoc，changes）/'patch'是对应用的更改的描述（一种差异）</p><p> Note that  Automerge.getChanges(oldDoc, newDoc) takes two documents as arguments: an old state anda new state. It then returns a list of all the changes that were made in  newDoc since  oldDoc. Ifyou want a list of all the changes ever made in  doc, you can call  Automerge.getAllChanges(doc).</p><p>注意自动合并。getChanges（oldDoc，newDoc）将两个文档作为参数：旧状态和新状态。然后返回自oldDoc以来在newDoc中所做的所有更改的列表。如果你想要一个文档中所有更改的列表，你可以调用Automerge。getAllChanges（文档）。</p><p> The counterpart,  Automerge.applyChanges(oldDoc, changes) applies the list of  changes to thegiven document, and returns a new document with those changes applied. Automerge guarantees thatwhenever any two documents have applied the same set of changes — even if the changes were appliedin a different order — then those two documents are equal. That property is called  convergence,and it is the essence of what Automerge is all about.</p><p>对应的自动合并。applyChanges（oldDoc，changes）将更改列表应用于给定文档，并返回应用了这些更改的新文档。Automerge保证，无论何时，只要任何两个文档应用了相同的更改集（即使更改以不同的顺序应用），那么这两个文档都是相等的。这种特性被称为收敛，它是自动合并的本质。</p><p> Automerge.merge(doc1, doc2) is a related function that is useful for testing. It looks for anychanges that appear in  doc2 but not in  doc1, and applies them to  doc1, returning an updatedversion of  doc1. See the  Usage section abovefor an example using  Automerge.merge().</p><p>自动合并。merge（doc1，doc2）是一个相关的函数，用于测试。它查找doc2中出现但doc1中未出现的任何更改，并将其应用于doc1，返回doc1的更新版本。有关使用自动合并的示例，请参见上面的用法部分。合并（）。</p><p>  Automerge allows different nodes to independently make arbitrary changes to their respective copiesof a document. In most cases, those changes can be combined without any trouble. For example, ifusers modify two different objects, or two different properties in the same object, then it isstraightforward to combine those changes.</p><p>自动合并允许不同的节点独立地对文档的各自副本进行任意更改。在大多数情况下，这些变化可以毫无困难地结合起来。例如，如果用户修改了两个不同的对象，或者同一个对象中的两个不同属性，那么将这些更改合并在一起是向前的。</p><p> If users concurrently insert or delete items in a list (or characters in a text document), Automergepreserves all the insertions and deletions. If two users concurrently insert at the same position,Automerge will arbitrarily place one of the insertions first and the other second, while ensuringthat the final order is the same on all nodes.</p><p>如果用户同时插入或删除列表中的项目（或文本文档中的字符），AutoMerge将保留所有插入和删除操作。如果两个用户同时在同一位置插入，Automerge将任意将其中一个插入放在第一位，另一个放在第二位，同时确保所有节点上的最终顺序相同。</p><p> The only case Automerge cannot handle automatically, because there is no well-defined resolution, is when users concurrently update the same property in the same object (or, similarly, the sameindex in the same list). In this case, Automerge arbitrarily picks one of the concurrently writtenvalues as the &#34;winner&#34;:</p><p>自动合并无法自动处理的唯一情况是，当用户同时更新同一对象中的同一属性（或者，类似地，同一列表中的sameindex）时，因为没有明确定义的解决方案。在这种情况下，Automerge会任意选择其中一个并发writenValue作为&#34；获胜者&#34；：</p><p> // Initialize documents with known actor IDs let  doc1  =  Automerge . change ( Automerge . init ( &#39;actor-1&#39; ) ,  doc  =&gt;  {  doc . x  =  1 } ) let  doc2  =  Automerge . change ( Automerge . init ( &#39;actor-2&#39; ) ,  doc  =&gt;  {  doc . x  =  2 } ) doc1  =  Automerge . merge ( doc1 ,  doc2 ) doc2  =  Automerge . merge ( doc2 ,  doc1 ) // Now, doc1 might be either {x: 1} or {x: 2} -- the choice is random. // However, doc2 will be the same, whichever value is chosen as winner. assert . deepEqual ( doc1 ,  doc2 )</p><p>//使用已知的参与者ID初始化文档，让doc1=Automerge。更改（Automerge.init（&#39；actor-1&#39；），doc=&gt；{doc.x=1}）让doc2=Automerge。更改（Automerge.init（&#39；actor-2&#39；），doc=&gt；{doc.x=2}）doc1=Automerge。合并（doc1，doc2）doc2=自动合并。merge（doc2，doc1）//现在，doc1可能是{x:1}或{x:2}——选择是随机的。//然而，doc2将是相同的，无论选择哪个值作为赢家。明确肯定deepEqual（doc1、doc2）</p><p> Although only one of the concurrently written values shows up in the object, the other values arenot lost. They are merely relegated to a conflicts object. Suppose  doc.x = 2 is chosen as the&#34;winning&#34; value:</p><p>虽然只有一个并发写入的值显示在对象中，但其他值不会丢失。它们只不过是一个冲突对象。假设医生。选择x=2作为&#34；获胜&#34；价值：</p><p> doc1  // {x: 2} doc2  // {x: 2} Automerge . getConflicts ( doc1 ,  &#39;x&#39; )  // {&#39;1@01234567&#39;: 1, &#39;1@89abcdef&#39;: 2} Automerge . getConflicts ( doc2 ,  &#39;x&#39; )  // {&#39;1@01234567&#39;: 1, &#39;1@89abcdef&#39;: 2}</p><p>doc1/{x:2}doc2/{x:2}自动合并。getConflicts（doc1和#39；x和#39；）//{&#39;1@01234567&#39;: 1, &#39;1@89abcdef&#39;: 2} 自动合并。getConflicts（doc2和#39；x和#39；）//{&#39;1@01234567&#39;: 1, &#39;1@89abcdef&#39;: 2}</p><p> Here, we&#39;ve recorded a conflict on property  x. The object returned by  getConflicts contains theconflicting values, both the &#34;winner&#34; and the &#34;loser&#34;. You might use the information in theconflicts object to show the conflict in the user interface. The keys in the conflicts object arethe internal IDs of the operations that updated the property  x.</p><p>在这里，我们&#39；我在属性x上记录了冲突。getConflicts返回的对象包含冲突值，包括&#34；获胜者&#34；以及&#34；失败者&#34；。您可以使用Conflicts对象中的信息在用户界面中显示冲突。冲突对象中的键是更新属性x的操作的内部ID。</p><p> The next time you assign to a conflicting property, the conflict is automatically considered to beresolved, and the conflict disappears from the object returned by  Automerge.getConflicts().</p><p>下次分配给冲突属性时，冲突将自动被视为已解决，并且冲突将从自动合并返回的对象中消失。getConflicts（）。</p><p>  An Automerge document internally saves a complete history of all the changes that were ever made toit. This enables a nice feature: looking at the document state at past points in time, a.k.a. &#34;tim</p><p>自动合并文档会在内部保存所有更改的完整历史记录。这实现了一个很好的功能：查看过去时间点的文档状态，也称为&#34；提姆</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/更改/">#更改</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>