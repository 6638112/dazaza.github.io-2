<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>编译Lisp：指令编码插曲</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">编译Lisp：指令编码插曲</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 13:54:02</div><div class="page_narrow text-break page_content"><p>欢迎回到编译Lisp系列。在这个激动人心的新更新中，我们将学习更多关于x86-64指令编码的知识，而不是在堆上分配更多有趣的东西或添加过程调用。</p><p>我之所以写这段插曲，是因为我把编译器代码中的一个寄存器(krbp改成了krsp)，所有的地狱都崩溃了-结果程序崩溃了，rasm2/Cutter在给我的二进制文件时解码古怪的指令，等等。在两个非常有趣但非常令人沮丧的小时里，我了解了为什么会有这些问题以及如何解决它们。你也应该学一学。</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，0xc0+dst)；buffer_write32(buf，src)；}。</p><p>这些函数都声称要对x86-64指令进行编码。大多数情况下，他们是这样做的，但他们不会讲述整个故事。此函数假定对mov reg64，imm32格式的指令进行编码。它是怎么做到的？我不知道!。</p><p>他们里面都有这些神奇的数字！什么是kRexPrefix？嗯，现在是0x48。这对我们有什么意义吗？不！情况变得更糟了。0xc7和0xc0在那里做什么？为什么我们要将DST添加到0xc0？在这场调试和阅读盛会之前，我不可能告诉你。还记得我在上一篇文章中提到的我是如何从Compiler Explorer上读取编译后的输出中获得这些十六进制字节的吗？嗯。</p><p>事实证明，这不是一个健壮的开发策略，至少对于x86-64是这样。对于一些更规则或更可预测的指令集，它可能是可以的，但不是这个指令集。</p><p>那么我们接下来要去哪里呢？我们如何找出如何将这些神秘的魔法和咒语带到更好地映射到硬件上的东西上呢？那么，我们再一次将Tom 1拖入调试会话，并调出大号的“英特尔软件开发人员手册”(Intel Software Developer Manual)。</p><p>这是一本长达26MB、5000页的手册，由四卷组成。这非常吓人。这就是为什么我不想早点把它拔出来，从一开始就正确地做这件事的原因…。但我们到了这里，最终需要做好这件事。</p><p>我不会假装理解这本手册的全部内容，这篇文章也不会成为手册的指南。我将只解释我发现哪些部分和图表对理解这些东西是如何工作有用的。</p><p>我只打开过第二卷，指令集参考。在嗡嗡作响2300页中，描述了每条Intelx86-64指令及其编码方式。指令按字母顺序列出，并根据每个指令名的第一个字母拆分集合。</p><p>让我们来看看第3章，特别是第1209页的MOV指令。对于那些不想下载大量PDF的读者，本网站提供了一组HTML格式的相同数据。这是MOV的页面。</p><p>此页面包含MOV指令的所有变体。还有其他以MOV开头的指令，如MOVAPD、MOVAPS等，但它们的差异足够大，以至于它们是不同的指令。</p><p>操作码，它描述了指令流中字节的布局。它描述了我们将如何对指令进行编码。</p><p>指令，它给出指令的类似文本汇编的表示形式。这对于找出我们实际上想要编码的是哪一个很有用。</p><p>OP/EN代表“操作数编码”，据我所知，它使用一个符号来描述操作数顺序，下一页的“指令操作数编码”表中将进一步解释该符号。</p><p>64位模式，它告诉您指令是否可以在64位模式下使用(“有效”)或不可以(我猜是其他模式)。</p><p>Compat/Leg模式，它告诉您指令是否可以在其他模式下使用，我认为是32位模式还是16位模式。我不知道。但这与我们无关。</p><p>DESCRIPTION，它提供操作码的“简明英语”描述，用于单词“简明”和“英语”的一些定义。</p><p>其他说明的表格布局略有不同，因此您必须弄清楚其他列的含义。</p><p>下面是表格中一些行的预览，HTML由FelixCloutier前面提到的Web文档提供：</p><p>如果您查看表中的最后一个条目，您将看到REX.W+C7/0id。这看起来眼熟吗？也许吧，如果你眯着眼睛看一下的话？</p><p>结果发现，这就是对我们最初想要的指令进行编码的描述，但是它的编码器很糟糕。让我们试着想办法用这个来使我们的编码器做得更好。要做到这一点，我们首先需要了解英特尔指令的一般布局。</p><p>我在第2卷第2章(第527页)的开头部分“保护模式、真实地址模式和虚拟8086模式的指令格式”中找到了这些信息。</p><p>您可能和我一样想知道“Optional”、“If Required”和“…”之间的区别。，或者一个也没有“。我无法解释，抱歉。</p><p>我将在这里简要解释每个组件，然后逐个剖析我们想要的特定MOV指令，这样我们就可以进行一些实践练习。</p><p>有几种指令前缀，如REX(第2.2.1节)和VEX(第2.3节)。我们将重点介绍REX前缀，因为许多人(大多数？)都需要它们。X86-64指令，我们没有发出向量指令。</p><p>REX前缀用于指示通常可能引用32位寄存器的指令应该改为引用64位寄存器。也有一些其他的东西，但是我们最关心的是寄存器的大小。</p><p>有关操作码的简要说明，请参阅第2.1.2节(第529页)。其要点是操作码是指令的核心。这是Mova MOV而不是停止的原因。其他字段都会修改此字段所赋予的含义。</p><p>有关ModR/M和SIB字节的简要说明，请参阅第2.1.3节(第529页)。要点是它们对要使用的寄存器源和目标进行编码。</p><p>有关位移和立即字节的简要说明，请参阅第2.1.4节(第529页)。要点是它们对指令中使用的文字数字进行编码，而不对寄存器或任何东西进行编码。</p><p>如果你糊涂了，没关系。一旦我们把手弄脏了，情况可能会变得更明朗。如果这是您第一次像这样处理汇编，那么在真空中阅读所有这些信息是相当有用的，但我首先包含这一节是为了帮助解释如何使用参考资料。</p><p>都拿到了吗？也许吧?。不是吗？是啊，我也是。但不管怎样，让我们继续前进吧。下面是我们要编码的指令：REX.W+C7/0id。</p><p>首先，让我们了解一下REX.W。根据更详细地解释REX前缀的第2.2.1节，有几个不同的前缀。有一个有用的表格(第535页的表2-4)记录了它们。以下是包含相同信息的位图：</p><p>0100 W R X B高位低位REX位3是W前缀。如果为1，则表示操作数为64位。如果为0，则“操作数大小[由CS.D确定]”。不确定那是什么意思。</p><p>位2、1和0是我们最终可能不会使用的其他类型的REX前缀，因此我在这里省略它们。如果你有好奇心，请进一步阅读手册！</p><p>此MOV指令调用REX.W，这意味着此字节将类似于0b01001000，也称为我们的朋友0x48。一号谜团，解开了！</p><p>这是十六进制文字0xc7。这是操作码。还有几个具有操作码C7的其他条目，由指令中的其他字节修改(modr/M、sib、rex、…)。那就是。将其写入指令流。第二个谜团，解开了！</p><p>如果指令不需要第二操作数，则REG/OPCODE字段可用作操作码扩展。这种用法由表中的第六行(标记为“/digit(操作码)”)表示。请注意，第六行中的值以十进制形式表示。</p><p>这有点混乱，因为此操作显然有第二个操作数，由表中的“MI”表示，它显示操作数1为ModRM：r/m(W)，操作数2为imm8/16/32/64。我认为这是因为它没有第二个寄存器操作数，所以这个空间是空闲的-立即数在指令中的不同位置。</p><p>在任何情况下，这意味着我们必须确保在ModR/M字节的reg部分放入十进制0。稍后我们将详细介绍ModR/M字节。</p><p>ID是指立即双字(32位)。它被称为双字，因为一个字(Iw)是16位。按规模递增的顺序，我们有：</p><p>这意味着我们必须将我们的32位值写出到指令流中。这些符号和编码在3.1.1.1节(第596页)中有进一步的解释。</p><p>REX Op ModR/M IMMEDIATE 0 1 2 3 7如果我们尝试对特定指令mov rax，100进行编码，它将如下所示：</p><p>REX Op ModR/M Immediate 0 1 2 3 7 0x48 0xc7 0xc0 0x64 0x00 0x00 0x00这就是您阅读表格的方式！慢慢地，一块一块地，用一杯好茶来帮助你渡过难关。现在我们已经读完了表，让我们继续编写一些代码。</p><p>在编写代码时，您通常需要比我们到目前为止看到的表多引用两个表。这些表格是表2-2“具有ModR/M字节的32位寻址表单”(第532页)和表2-3“带有SIB字节的32位寻址表单”(第533页)。虽然这些表描述的是32位的量，但是有了REX前缀，所有的ES都被替换为R，并且突然之间它们就可以描述64位的量了。</p><p>在弄清楚如何将ModR/M和SIB字节组合在一起时，这些表非常有用。</p><p>给定一个寄存器dst和一个立即的32位整数src，我们将对此指令进行编码。让我们按顺序做所有的步骤。</p><p>由于指令调用REX.W，因此我们可以保持第一行与前面相同：</p><p>ModR/M字节是代码稍有不同的地方。我们想要一个抽象来为我们构建它们，而不是像某种动物一样手动抛出整数。</p><p>要做到这一点，我们应该知道它们是如何组合在一起的。ModR/M字节包括：</p><p>MOD(高2位)，描述要在ModR/M表中使用的大行。</p><p>REG(中间3位)，描述第二个寄存器操作数或操作码扩展(如上面的/0)。</p><p>Byte modrm(byte mod，byte rm，byte reg){return(mod&amp；0x3)&lt；&lt；6)|((reg&amp；0x7)&lt；&lt；3)|(rm&amp；0x7)；}。</p><p>参数的顺序与位的顺序略有不同。我这样做是因为在调用函数时会使调用者看起来更自然一些。因为太混乱了，我以后再换吧。</p><p>将0b11(3)作为mod传递，因为我们希望直接移入64位寄存器，而不是[reg]，这意味着我们希望取消引用指针中的值。</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，modrm(/*direct*/3，dst，0))；//...}</p><p>对于上面的指令mov rax，100，其产生与此布局相同的modrm字节：</p><p>ModR/M mod reg RM 11 000 direct/0 Rax 000我没有把mods的数据类型放在一起，因为我不知道我是否能够很好地表达它。所以现在我只是添加了一个评论。</p><p>最后，我们有即期价值。正如我上面所说的，所有这一切都需要写出一个32位的数量，就像我们一直做的那样：</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，modrm(/*direct*/3，dst，0))；buffer_write32(buf，src)；}。</p><p>现在你就知道了！我们花了2500个字才读到这微不足道的4个字节。真正的成功是我们一路结交的朋友。</p><p>“但是Max，”你说，“这会产生和以前所有情况下一样的输出！为什么要这么麻烦呢？这是怎么回事？“。</p><p>嗯，亲爱的读者，MOD为3(直接)意味着当DST是RSP时没有特殊情况下的逃生舱口。这与其他MOD不同，在其他MOD中，表中的RSP应该是[--][--]。该FunkySymbol表示ModR/M字节后面必须有一个标度-索引-基数(SIB)字节。这意味着此指令的总体格式应为以下布局：</p><p>REX Op ModR/M 0 1 2 3 SIB 4 disp 5例如，如果您尝试对mov[RSP-8]、rax进行编码，则值应如下所示：</p><p>REX Op ModR/M 0 1 2 3 0x48 0x89 0x44 SIB 4 disp 5 0x24 0xf8这就是像emit_store_reg_direct(mov[reg+disp]，src)这样的指令与我设计的自制编码方案出现严重错误的地方。当该指令中的DST为RSP时，预计下一个字节为SIB。而当你输出其他数据时(比方说，立即8位位移)，你就会得到非常时髦的寻址模式。这到底是什么玩意儿？</p><p>这是实际的反汇编程序集，我通过rasm2运行我的二进制代码得到的。我们的编译器绝对不会发出任何复杂的东西，这就是我发现问题的原因。</p><p>好吧，所以这是错的。我们不能只是盲目地乘法和加法。那么Dowe做了什么？</p><p>再看一下表2-2(第532页)。请注意，尝试将RSP与任何类型的位移一起使用都需要SIB。</p><p>现在再看一下表2-3(第533页)。我们要用这个把SIB组装起来。</p><p>我们从第2.1.3节了解到，与ModR/M一样，SIB由三个字段组成：</p><p>英特尔的语言不是很清楚，有点循环。让我们来看一下示例说明来澄清一下：</p><p>请注意，index和base指的是寄存器，scale指的是1、2、4或8中的一个，disp是某个立即值。</p><p>这是一种指定内存偏移量的紧凑方式。它便于读取和写入数组和结构。如果我们想写入和读取堆栈指针rsp的随机偏移量，那么它也是必需的。</p><p>让我们先回到列举所有类型的MOV指令的表(第1209页)。我们要查找的特定操作码是REX.W+89/r或MOV r/m64，r64。</p><p>到现在为止还好。看起来很眼熟。现在我们有了指令前缀和操作码，是时候写入ModR/M字节了。我们的ModR/M将包含以下信息：</p><p>因为我们有两个寄存器操作数，所以第二个操作数是任何寄存器的REG(操作码字段说/r)。</p><p>Void emit_store_reg_direct(buffer*buf，Indirect dst，Register src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；//错误！Buffer_Write8(buf，modrm(/*disp8*/1，dst.。注册表，源))；//...}。</p><p>但不，这是不对的。结果是，正如我不断提到的，当dst.reg是RSP时，您仍然需要做这个特殊的事情。在这种情况下，Rm必须是特殊的None值(由表指定)。然后您还必须写入ASIB字节。</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；//...}否则{buffer_write8(buf，modrm(/*disp8*/1，dst.。注册表，服务器))；}//...}。</p><p>精明的读者会知道krsp和kIndexNoone的整数值是4。我不知道这是否是英特尔设计者故意的。也许它应该是这样的，所以编码更容易，并且不需要对ModR/M和SIB都有特殊情况。也许这是偶然的。不管怎样，我发现它非常微妙，我想明确地说出来。</p><p>ModR/M mod reg rm 11 100 disp8 Rax NONE 000让我们继续写入SIB字节。我做了一个类似modrm的sib助手函数，只有两个小的不同：参数是从低位到高位的顺序，参数有自己的特殊类型，而不只是字节。</p><p>Tyfinf enum{Scale1=0，Scale2，Scale4，Scale8，}scale；tyfinf enum{kIndexRax=0，kIndexRcx，kIndexRdx，kIndexRbx，kIndexNone，kIndexRbp，kIndexRsi，kIndexRdi}Index；byte sib(寄存器基数，索引索引，小数位数){return((scale&amp；0x3)&lt；&lt；6)|(index&amp；0x7)&lt；&lt；3)|(base&amp；0x7)；}。</p><p>我创建所有这些数据类型都是为了提高可读性，但是如果您不想使用它们，也可以不使用它们。Index one是唯一有一个小问题的：kIndexRsp应该在哪里是kIndexNone，因为您不能将RSP用作索引寄存器。</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；buffer_write8(buf，sib(krsp，kIndexNone，scale1))；}{buffer_write8(buf，modrm(/*disp8*/1，dst.。注册表，服务器))；}//...}。</p><p>SIB规模索引基数00 100 0无RSP 100这是一种非常冗长的表示[RSP+DISP]的方式，但它也可以。现在剩下的就是编码那个位移了。要做到这一点，我们只需将其写出来：</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；buffer_write8(buf，sib(krsp，kIndexNone，scale1))；}{buffer_write8(buf，modrm(/*disp8*/1，dst.。Reg，src))；}buffer_write8(buf，disp8(间接。Disp))；}。</p><p>非常好。现在轮到您着手在编译器中转换其余的汇编函数了！我发现将modrm/sib/displ8调用提取到一个helper函数中非常有用，因为它们大多是相同的并且非常重复。</p><p>这是一篇很长的帖子。这是到目前为止整个系列中最长的帖子，甚至是。我们可能应该有一些具体的外卖。</p><p>也许还有第三件事，我不知道-这个帖子有点多。</p><p>希望你喜欢。我要去试着睡个好觉。直到下一次，我们将实现过程调用！</p><p>这是POST中所有指令编码图的组合。如果您再次看到此文本，则意味着您的浏览器无法呈现SVG。</p><p>如果你是这个博客的狂热读者(这些人存在吗？请把手伸向我。我很乐意聊天。)，你可能会注意到汤姆经常被拉进恶作剧的圈套。这是因为Tom是我遇到过的最好的调试器，他擅长反向工程，而且他知道很多低级的事情。我想现在他正致力于改进RISC-V板的开源工具，以此为乐。但他也非常善良，乐于助人，而且通常对我陷入的任何荒谬的情况都感兴趣。也许我应该在这个网站的某个地方加一份汤姆编年史的名单。不管怎么说，每个人都需要一个TOM。--↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-10/">https://bernsteinbear.com/blog/compiling-a-lisp-10/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1029348.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c51e4db2a1d234d9b999247de43b0b4d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029348.html">使用多阶段构建的较小的Docker映像</a></div><span class="my_story_list_date">2020-10-17 6:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028888.html"><img src="http://img2.diglog.com/img/2020/10/thumb_239bb5b07a2c9f9cf3f664f649f25217.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028888.html">将SQL存储过程(如LANGUAGE)转换为C for SQLite的编译器</a></div><span class="my_story_list_date">2020-10-15 4:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027361.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9e006679c4e31e5eb57c277f6878a6b6.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027361.html">在用户将泄漏的代码编译到正常运行的操作系统后确认Windows XP泄漏</a></div><span class="my_story_list_date">2020-10-1 3:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027345.html"><img src="http://img2.diglog.com/img/2020/10/thumb_e5e69b4ff60daa309a222f467a868fe5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027345.html">从泄露的源代码编译的Windows XP和Server 2003</a></div><span class="my_story_list_date">2020-10-1 3:26</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>