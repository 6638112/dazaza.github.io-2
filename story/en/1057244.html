<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>nix是终极devops toolkit Nix is the ultimate DevOps toolkit</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nix is the ultimate DevOps toolkit<br/>nix是终极devops toolkit </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 19:00:07</div><div class="page_narrow text-break page_content"><p>At Channable we use Nix to build and deploy our services and to manage our development environments. This was not always the case: in the past we used a combination of ecosystem-specific tools and custom scripts to glue them together. Consolidating everything with Nix has helped us standardize development and deployment workflows, eliminate “works on my machine”-problems, and avoid unnecessary rebuilds. In this post we want to share what problems we encountered before adopting Nix, how Nix solves those, and how we gradually introduced Nix into our workflows.</p><p>在通道，我们使用NIX构建和部署我们的服务并管理我们的开发环境。这种情况并非总是如此：过去，我们使用了一种生态系统的工具和自定义脚本的组合来将它们粘在一起。巩固与NIX的所有内容都帮助我们标准化了开发和部署工作流程，消除了“我的机器上的工作” - 问题，并避免不必要的重建。在这篇文章中，我们希望在采用NIX之前分享我们遇到的哪些问题，NIX如何解决这些问题，以及我们如何逐步将NIX介绍到我们的工作流程中。</p><p>  About 1.5 years ago we decided to gradually adopt Nix. First only for development environments and CI, later also for deploys and production use. Up until then we had used a variety of tools to build, package, and deploy our software:</p><p>  大约1.5年前，我们决定逐步采用尼克斯。首先仅适用于开发环境和CI，后面也用于部署和生产使用。直到那时我们使用了各种工具来构建，包和部署我们的软件：</p><p>  For building APT packages we used a variety of  make,  docker, and a home-grown build tool called  channabuild. This worked well enough for a while, but our list of build requirements kept growing and we quickly discovered that we did not have the time to build and maintain a high-quality build system.  1 This is why we decided to give Nix a try.</p><p>  对于构建APT包，我们使用了各种制作，Docker和一个名为Chranebuild的家庭成长构建工具。这已经很好地工作了一段时间，但我们的构建要求清单不断增长，我们很快发现我们没有时间建立和维护高质量的构建系统。 1这就是为什么我们决定尝试给予nix。</p><p> We started by dipping one tiny toe in the water. One day our CI build broke because of a backwards incompatible change in a new release of Haskell’s build tool Stack, and CI always installed the latest version. Nix enables pinning all programs, including Stack, so this was a nice opportunity for a couple of Nix advocates in the company to try it out in a single repository.</p><p> 我们开始在水中浸入一个小脚趾。有一天，我们的CI构建破坏了，因为哈尔克尔的构建工具堆栈的新版本倒退不兼容，而CI始终安装了最新版本。 NIX使别捕所有程序，包括堆栈，所以这对公司中的几个NIX倡导者来说这是一个很好的机会，以便在一个存储库中尝试一下。</p><p> In the next step, Nix was used to build a Python environment with the right libraries for some benchmark scripts. These small steps turned out to be very successful, for the month after that, plans were being made to migrate our biggest Haskell repository to being built using Nix. Over time, more and more projects were migrated to Nix. First by moving over the local development setup, then the continuous integration setup, and lastly the software packages that get deployed to production.</p><p> 在下一步中，NIX用于构建具有合适库的Python环境，用于某些基准脚本。这些小型步骤竟然是非常成功的，在此之后的一个月，正在制作计划迁移我们最大的Haskell存储库以使用NIX建造。随着时间的推移，越来越多的项目被迁移到NIX。首先通过通过本地开发设置移动，然后是连续集成设置，最后一个部署到生产的软件包。</p><p> Having a couple of Nix advocates was crucial to kickstart the enthusiasm for Nix in the rest of the company. Their approach to start small and migrate piece by piece turned out to be successful. We soon realized that Nix solves many of the problems that we had, and saves us quite a bit of problem solving time in the long run.</p><p> 拥有几个尼克斯倡导者对于在公司其余的尼克斯踢球时至关重要。他们的方法开始逐渐迁移，结果原来是成功的。我们很快意识到NIX解决了我们许多我们所拥有的问题，并在长期运行中拯救了一些解决问题的问题。</p><p>  Our main motivation to switch to Nix was its promise to solve a number of thorny issues with our builds, and with our deploy process. It is worth looking at these problems in detail, since many other organizations writing software face similar issues, and we hope that this experience report will help you make a more informed decision if you are considering adopting Nix in your organization.</p><p>  我们的主要动机来切换到NIX是它承诺解决我们的构建和我们的部署过程中的一些棘手问题。值得注意的是详细研究这些问题，因为许多其他组织编写了软件面临类似的问题，我们希望这一经验报告可以帮助您提出更明智的决定如果您正在考虑在您的组织中采用NIX。 </p><p> Let’s see how we used Nix to solve three concrete problems in our builds.</p><p>让我们看看我们如何在我们的构建中解决三个具体问题。</p><p>  For our largest Python projects, we used a combination of Pip, Virtualenv, and APT. We would install our dependencies in a virtualenv with Pip, and package that together with our code as an APT package to be installed in production. While it served us well for many years, it had its pain points:</p><p>  对于我们最大的Python项目，我们使用了PIP，VirtualenV和APT的组合。我们将在VirtualEnv中使用PIP安装依赖项，并将其与我们的代码一起作为APT包安装在生产中。虽然它在很多年份供应我们的时候，它的痛点：</p><p> It was difficult to update a single dependency while keeping the others pinned (including transitive dependencies). In the end we created some scripts around  pip freeze to generate two  requirements.txt files: one to pin direct dependencies, one to pin transitive dependencies.</p><p> 在保持其他固定（包括传递依赖项）的同时很难更新单个依赖。最后，我们创建了一些围绕pip freeze的脚本来生成两个要求.txt文件：一个引脚直接依赖，一个到引脚传递依赖项。</p><p> This did not leave any room to distinguish development dependencies from runtime dependencies, so we either installed the development dependencies in production, or asked developers to  pip install the remaining dependencies manually.</p><p> 这并没有留下任何空间来区分从运行时依赖性的开发依赖关系，因此我们要么在生产中安装开发依赖关系，或者将开发人员询问到PIP手动安装剩余的依赖项。</p><p> After somebody changes  requirements.txt, all other developers need to run  pip install, but how do they know? “Did you run  pip install?” used to be our most common troubleshooting response in the development chatroom.</p><p> 在某人更改要求之后，所有其他开发人员都需要运行pip安装，但他们如何知道？ “你有没有运行pip安装？”曾经是我们在开发聊天室中最常见的故障排除响应。</p><p> Installing packages with APT is not atomic: APTs updates files in-place one by one. Because we start Python processes many times per second, if one started during a deployment, it could import a mix of the old and new code. This regularly lead to puzzling bugs.</p><p> 使用APT安装包不是原子：APTS将文件逐一更新。因为我们每秒开始Python处理很多次，因为在部署期间开始时，它可能导入旧代码的混合。这经常导致令人费解的错误。</p><p> Installing the APT package could take minutes, because aside from the code it contained several large resources. These had to be packaged, downloaded, and extracted for every release, even though these files changed infrequently.</p><p> 安装APT包可能需要几分钟，因为除了它包含几个大资源的代码之外。即使这些文件不经常更改，必须为每个版本进行打包，下载并提取，并提取。 </p><p> We briefly explored Pipenv in some of our smaller projects, but quickly discovered that it does not solve any of these problems, and it  creates some problems of its own, so we moved on.</p><p>我们在一些较小的项目中简要介绍了Pipenv，但很快发现它没有解决这些问题的任何问题，它创造了自己的一些问题，所以我们继续前进。</p><p>   Products loaded in the Channable tool can be exported to a wide range of marketplaces. Each marketplace has their own set of categories to categorize products in. To support this, we periodically import data models from marketplaces, and save them in files in a standardized text-based format. These files are easy to generate and review, but not efficient to use at runtime, so we convert them into SQLite databases at build time. Generating these databases for all marketplaces we support takes about 30 minutes. This impacted our CI times and the local developer experience.</p><p>   装载在通道工具中的产品可以导出到各种市场。每个Marketplace都有自己的一组类别来对产品进行分类。要支持此产品，我们会定期从MarketPlaces导入数据模型，并以标准化的基于文本的格式将其保存在文件中。这些文件很容易生成和审查，但在运行时使用不高效，因此我们将它们转换为在构建时的SQLite数据库中。为所有市场的所有市场生成这些数据库，我们支持大约需要30分钟。这影响了我们的CI次和当地开发人员体验。</p><p> We tried to be smart about re-generating databases only when the inputs changed, but there were always subtle cases that lead to incorrect results, and every developer still had to generate all artifacts to get a local development environment running. Another pain point was switching Git branches: if you switch to a branch that has a change in one of the inputs, you need to re-generate the corresponding database … but once you switch back, you need to do that again!</p><p> 我们尝试才能智能地在输入输入时重新生成数据库，但始终存在导致结果不正确的细微案例，并且每个开发人员仍然必须生成所有工件以获得运行的本地开发环境。另一个痛点是切换Git分支：如果切换到一个输入的一个输入的分支，则需要重新生成相应的数据库......但是一旦切换回来，您需要再次执行此操作！</p><p>  Build category databases on CI, so no developer has to wait for the database to be built</p><p>  在CI上构建类别数据库，因此没有开发人员必须等待构建的数据库</p><p> Instead of making our own caching infrastructure more advanced we saw this as an opportunity to try and use Nix to build the category databases. The Nix store would automatically keep multiple versions of the category databases available. We could easily share the databases between machines when we setup a cache for our build outputs. Building category databases on CI and pushing them to the cache became a possibility.</p><p> 我们将此作为尝试使用NIX构建类别数据库的机会，而不是使我们自己的缓存基础架构更高级。 NIX存储将自动保留可用的类别数据库的多个版本。当我们为构建输出设置缓存时，我们可以轻松地共享计算机之间的数据库。在CI上构建类别数据库并将其推向缓存成为可能性。</p><p>  Another problem that we ran into when relying on the system packaging workflow using APT were backwards-incompatible changes in system-packaged libraries. For example,  libicu has incompatible  sonames across different Ubuntu versions. This meant that for upgrading the Ubuntu version on our servers, we had to separately build and package our application for each Ubuntu version that we intended to use it with. That also meant we would sometimes necessarily develop against different versions of third-party libraries on our own machines than what we ran in production.</p><p>  我们在依赖于使用APT的系统包装工作流程时遇到的另一个问题是系统打包库中的倒退 - 不兼容。例如，Libicu在不同的Ubuntu版本上具有不兼容的Sonames。这意味着为了在我们的服务器上升级Ubuntu版本，我们必须单独构建和包装我们的应用程序，我们打算使用它的每个Ubuntu版本。这也意味着我们有时必须对自己的机器进行不同版本的第三方图书馆而不是我们在生产中遇到了什么。</p><p>  Much like Haskell, Nix is based on a number of revolutionary ideas, that, when put together, enhance the state-of-the-art of how we build our software.  Unlike Haskell, it is much less polished and comes with plenty of sharp edges. Although almost 20 years old, the project is currently still evolving at a rapid (and accelerating!) pace, and seems to have reached escape velocity. Yet, at its core it has also reached a level of maturity and stability that it can be recommended for production use.</p><p>  很像Haskell，NIX是基于许多革命性的想法，即在汇集时，提升我们如何建立我们的软件的最先进。与Haskell不同，它的抛光得多，并且具有大量锋利的边缘。虽然近20岁了，该项目目前仍处于快速（并加速！）节奏，似乎已达到逃避速度。然而，在其核心，它还达到了一定程度的成熟和稳定性，可以推荐用于生产使用。 </p><p> To fully understand the advantages that Nix offers, it is necessary to have a cursory understanding of the different projects in the Nix ecosystem. We will give a very short overview of the different parts here.</p><p>为了充分了解NIX提供的优势，有必要对NIX生态系统中的不同项目进行练习型理解。我们将在此处提供非常简短的概述。</p><p> We like to think of Nix as the ultimate DevOps toolkit. It comes with a number of power tools:</p><p> 我们喜欢将NIX视为终极Devops Toolkit。它配备了许多电动工具：</p><p> The Nix programming language — The core idea of Nix is that build instructions and dependency management are best done with a fully fledged declarative programming language.</p><p> NIX编程语言 -  NIX的核心思想是构建指令和依赖管理最好用完全成熟的声明性编程语言完成。</p><p> The Nix CLI tools — Programs that evaluate Nix programs to build or install packages, debug Nix code, and manage installed packages.</p><p> NIX CLI工具 - 评估NIX程序以构建或安装包，调试NIX代码和管理已安装的软件包的程序。</p><p> Nixpkgs, the Nix package archive — One of the biggest package repositories  in the world, in the shape of a git repository containing Nix code. Also contains the standard library for the Nix programming language.</p><p> nixpkgs，nix包存档 - 世界上最大的包存储库之一，是包含nix代码的git存储库的形式。还包含nix编程语言的标准库。</p><p> NixOS — A full-blown Linux distribution, built and managed entirely through Nix. We will ignore it in this article, since we are not using it at the time.</p><p> nixos  - 一个完整的Linux发行版，完全通过nix构建和管理。我们将在本文中忽略它，因为我们当时没有使用它。</p><p> Nix the language allows us to define packages for our services. For every package we declare:</p><p> NIX语言允许我们为我们的服务定义软件包。对于我们宣布的每个包装： </p><p> Any other packages it depends on, either our own, or packages from Nixpkgs. These can be runtime dependencies or build-time dependencies.</p><p>任何其他包它取决于我们自己或来自nixpkgs的包。这些可以是运行时依赖性或构建时间依赖性。</p><p>  The commands to run to turn the source code into a binary or other build output.</p><p>  要运行的命令将源代码转换为二进制或其他构建输出。</p><p> Nix stores the build outputs in a directory derived from the package declaration and its inputs. This means that if any of the inputs change, the output will be stored in a different path, which allows multiple build results to co-exist.</p><p> nix存储从包声明及其输入派生的目录中的构建输出。这意味着如果任何输入改变，则输出将存储在不同的路径中，这允许多个构建结果共存。</p><p> Furthermore, Nix can compute the path of the output directory before it starts building anything. Binary caches can cache these directories. If a path exists in a binary cache, then Nix can download it from there instead of running the command locally to produce the build output.</p><p> 此外，NIX可以在开始建立任何内容之前计算输出目录的路径。二进制缓存可以缓存这些目录。如果在二进制缓存中存在路径，则NIX可以从那里下载它，而不是在本地运行命令以生成构建输出。</p><p> When using Nixpkgs, it is possible to pin a specific revision of the Nixpkgs revision. In a sense, this acts like a global lockfile for the entire software ecosystem. Usually Nixpkgs provides a single version of a package, but in complex situations a single Nixpkgs revision can provide multiple versions of a package in parallel, like Python 3.8 and 3.9. The packages from Nixpkgs are all available from the default Nix binary cache.</p><p> 使用nixpkgs时，可以针对nixpkgs修订的特定修订。从某种意义上说，这就像整个软件生态系统的全球锁密文件一样。通常nixpkgs提供单个版本的包，但在复杂的情况下，单个nixpkgs修订版可以并行提供多个版本，如python 3.8和3.9。来自nixpkgs的包从默认的nix二进制缓存中获得。</p><p>  As anybody who ever had to generate a 10,000 line makefile, or template an enormous sea of YAML, will attest to, having a full-blown programming language to specify your builds is a honking great idea. Having fully declarative builds is a nice ideal, but it is a chimera. Any sufficiently complex build will at some point require some build steps that can no longer be declared declaratively. This is the point at which developers will usually resort to hacks like shelling out to bash scripts, to circumvent the limitations of the build system.</p><p>  由于任何人都必须生成10,000线的Makefile，或者模板巨大的山脉，将证明有一个全面的编程语言来指定您的构建是一个令人讨厌的好主意。拥有完全陈述的构建是一个很好的理想，但它是一个嵌合体。在某些情况下，任何具有足够复杂的构建都需要一些无法再声明的构建步骤。这是开发人员通常会诉诸BASH脚本的黑客的点，以规避构建系统的局限性。</p><p> Furthermore, having a single open-source mono-repo for all external packages comes with a number of major advantages. It makes it very easy to pull in any external dependencies, not just the ones from your programming language. Say, for example, you want to have Postgres and Redis available on CI to run some integration tests. With most other systems, you would have to set this up yourself with some bash and duct-tape. With Nix you get one unified build environment in which you can set up anything you need (and pin it to the right version, so that your test still passes in the future).</p><p> 此外，对于所有外部封装具有单个开源单次仓库，具有许多主要优点。它使得在任何外部依赖项中都非常容易，而不仅仅是来自您的编程语言的依赖性。例如，您希望在CI上使用Postgres和Redis来运行一些集成测试。使用大多数其他系统，您必须使用一些Bash和Dut-Tape来解决这个问题。使用NIX，您可以获得一个统一的构建环境，您可以在其中设置您需要的任何东西（并将其引导到正确的版本，以便您的测试将来仍然通过）。 </p><p> Finally, having a mono-repo for all packages is also a kind of  social technology that enables contributions from everywhere, while providing a central place for testing and quality control.  nixpkgs contains more than  55000 projects, with only Arch’s AUR having more projects available.</p><p>最后，为所有包装进行单声头仓库也是一种社交技术，可以从各处提供贡献，同时提供测试和质量控制的中心。 nixpkgs包含超过55000个项目，只有拱门的AUR可提供更多项目。</p><p>  Let’s go over our packaging and development problems once more, and see how Nix solves these.</p><p>  让我们再次覆盖我们的包装和发展问题，并了解NIX如何解决这些问题。</p><p> Updating single dependencies. With Nix we pin the Nixpkgs version, which in turn pins the packages we use from there, but on top of that, Nix makes it easy to override packages to just the version we need, so for packages that we depend on directly, we do this to have more control.</p><p> 更新单个依赖项。使用nix我们引用nixpkgs版本，这又引脚了我们从那里使用的包，但在那之上，nix使得覆盖包装覆盖包只是我们需要的版本，所以我们可以直接依赖的包裹覆盖这有更多的控制。</p><p> Separarating runtime and development dependencies. With  pkgs.buildEnv, it is easy to build a development environment that includes all runtime dependencies plus development packages, and in production we don’t reference this environment.</p><p> 分离运行时和开发依赖项。使用PKGS.BuildEnv，很容易构建一个开发环境，包括所有运行时依赖性加上开发包，在生产中我们不引用此环境。</p><p> Avoiding manual installation steps. With Nix, we either prefix the commands we run with  nix run -c, or we enter a development shell with  nix run -c $SHELL. Nix then extends the  PATH to make the packages we need available. Nix builds  default.nix when it runs, so it always uses the latest version. If  default.nix changes due to a  git pull, the next  nix run will pull in the new dependencies.</p><p> 避免手动安装步骤。使用nix，我们要么为我们使用nix运行-c运行的命令，或者我们使用nix运行-c $ shell输入开发shell。然后，NIX扩展了路径以使我们需要的包裹提供。 nix构建default.nix运行时，它始终使用最新版本。如果default.nix由于git pull而更改，下一个nix运行将拉动新的依赖项。</p><p> Atomic installation. Nix installs packages at a path that depends on all of the build inputs, so a new version of a package can be installed alongside the old version. We first ensure that all the required files are present, and then we can atomically replace one systemd unit file, or symlink in  /usr/bin, and make it point to the new path.</p><p> 原子安装。 NIX在依赖于所有构建输入的路径上安装包，因此可以与旧版本一起安装一个新版本的包。我们首先确保存在所有所需的文件，然后我们可以原始替换一个系统文件文件，或符号链接/ usr / bin，并使其指向新路径。</p><p> Instant rollbacks. Because the old version does not get removed when we install a new version of a package, rolling back is as simple as making the symlink or systemd unit point to the previous path again. Old versions do get garbage collected at some point, but we explicitly keep the past 3 versions around.</p><p> 即时回滚。由于旧版本未在安装新版本的程序包时未被删除，因此回滚就像将Symlink或SystemD单位再次指向上一条路径一样简单。旧版本确实会在某些时候收集垃圾，但我们明确地保持过去的3个版本。 </p><p> Sharing large resources between versions. By packaging large resources as separate Nix packages, they can be shared between multiple versions of our services. Because multiple versions of the resources can be installed alongside each other, our services reference the exact version they need, and atomic deploys still work, which would not be possible with APT packages.</p><p>在版本之间共享大资源。通过将大资源包装为单独的NIX软件包，可以在我们的多个版本之间共享它们。由于多个版本的资源可以与彼此一起安装，因此我们的服务引用了所需的确切版本，原子型部署仍然可以使用，这将无法使用APT包。</p><p> Avoiding rebuilds when switching branches. Nix puts build outputs in a subdirectory of  /nix/store, in a path that depends on the build description. If the path already exists, because it was built previously, there is no need to build it again, so a build after switching back and forth between branches is a no-op.</p><p> 切换分支时避免重建。 nix将构建输出放在/ nix / store的子目录中，在依赖于构建描述的路径中。如果该路径已存在，因为它以前构建，则无需再次构建它，因此在分支机构之间来回切换之后的构建是NO-OP。</p><p> Sharing build outputs between machines. Because Nix computes the path where it is going to store a build output before building it, it can also query a binary cache to get the output from there, instead of building it.  Cachix  3 makes it easy to set up such a cache for private use. After a first build we push to this cache, and then nobody else needs to build the output again.</p><p> 在机器之间共享构建输出。由于NIX计算要在构建之前存储构建输出的路径，因此它还可以查询二进制缓存以从那里获取输出，而不是构建它。 Cachix 3可以轻松设置私人使用的缓存。在第一个构建之后，我们推向此缓存，然后没有其他人需要再次构建输出。</p><p> Reusing build outputs from CI. The binary cache can be filled by any trusted user, which can be CI. So now we build every target only once, and developers, but also other CI runs, can reuse the output from the cache.</p><p> 从CI重用构建输出。二进制缓存可以由任何可信用户填充，任何可信用户可以是CI。所以现在我们只构建一次每个目标，而且开发人员也可以重用缓存中的输出。</p><p> Breaking changes in system dependencies. Packages built with Nix depend only on other packages managed by Nix, not on system libraries, so our packages are now independent of the host OS; we can deploy the same package to Ubuntu 18.04 and 20.04.</p><p> 破坏系统依赖性的变化。使用NIX构建的软件包仅依赖于NIX管理的其他包，而不是在系统库上，因此我们的软件包现在独立于主机操作系统;我们可以将相同的包部署到Ubuntu 18.04和20.04。</p><p>  Whenever a large project gets settled on one way of doing things, it starts to become comfortable. So much so that the peculiarities of this one way of doing things become interwoven into the very nature of the project. In our case, all the code, workflows and systems were built on top of Haskell’s  stack or Python’s  virtualenv, Ansible, APT packages and servers running Ubuntu. Nix is a different approach to what all these tools provide, one that at first glance seems incompatible with the existing tools. The first challenge was finding out how we could start using Nix in an otherwise established workflow.</p><p>  每当一个大型项目在一种做事的方式落户时，它就开始变得舒适。这么多，以至于这种做事方式的特殊性被交织在项目的本质上。在我们的情况下，所有代码，工作流和系统都是基于Haskell的堆栈或Python的virtualenv，Ansible，Apt软件包和运行Ubuntu的服务器的顶部。 NIX是一种不同的方法，可以提供所有这些工具的提供，首先浏览一眼似乎与现有工具不兼容。第一个挑战是发现我们如何在建立的工作流程中开始使用NIX。</p><p> Fortunately, Nix can take over parts of the above mentioned workflow. In a first step for a Haskell project, we replaced the code in a Python script that called  stack for compiling, and  dpkg-deb for creating an APT package, with some Nix code that compiled the Haskell project and put it in an APT package instead. This change was invisible to the rest of the packaging and deployment process, as the output was still an APT package. Besides, building the APT package with Nix already gave us build reproducibility. After swapping out more components of the build/deploy process, we found that each individual step gave us more of the benefits that Nix offers, despite the rest of the process still being done the old way. This boosted our motivation to continue.</p><p> 幸运的是，NIX可以接管上述工作流程的部分。在Haskell项目的第一步中，我们在一个Python脚本中的代码替换了一个名为Compling的Python脚本，以及用于创建APT包的DPKG-DEC，其中一些NIX代码编译了Haskell项目，然后将其放在APT包中。随着输出仍然是APT包，此更改对其其余的包装和部署过程是看不见的。此外，使用NIX构建APT包已经给了我们建立再现性。在交换构建/部署进程的更多组件之后，我们发现每个单独的步骤都给了我们更多的利益，尽管剩下的过程仍然是旧的方式。这提高了我们继续的动力。 </p><p> Swapping out one piece at a time gives relative peace of mind, except for the pieces that run on production. With Channable, an outage is very likely to frustrate customers. More importantly, it is even more likely to cause intense stress for the developers involved. We don’t like stress, so we made sure to make the switch as safe and well tested as is reasonably possible. This was done by first switching over staging servers. For services that are load balanced on several servers, we could switch one server at a time. Installing both the APT version and Nix version simultaneously was also possible for some packages. In the end most of the packages were switched over without problems. The damage was very much limited for the ones that did cause trouble.</p><p>除了在生产上运行的碎片外，一次交换一件就会提供相对的安心。通过途径，中断可能会挫败客户。更重要的是，更有可能对所涉及的开发人员造成强烈的压力。我们不喜欢压力，所以我们确保将开关作为安全性和经过良好的测试，这是合理可能的。这是通过首先切换暂存服务器来完成的。对于在多个服务器上负载平衡的服务，我们可以一次切换一个服务器。某些软件包也可以同时安装APT版本和NIX版本。最后，大多数包裹都在没有问题的情况下切换。对于那些造成麻烦的人来说，损害非常有限。</p><p> With a bit of creativity, one can continue swapping out bits and pieces, slowly building a sense of comfort for the new way. It is important that this new sense of comfort is also built among colleagues working on different parts of the system. To prevent surprises, they will need to be aware of the most important changes, why they are happening and how to work with them. To achieve this, we gave presentations to the development team, introducing them to Nix. Later this was followed by an in-depth workshop. Every direct change to the workflow was accompanied by a development announcement mail to explain the change. We have found that enthusiasm grew amongst our colleagues, and that many of them have become enthusiasts themselves.</p><p> 有了一点创造力，可以继续交换位和碎片，慢慢地为新的方式建立舒适感。重要的是，这种新的舒适感也是在系统的不同部分工作的同事中建立。为了防止惊喜，他们需要了解最重要的变化，为什么他们正在发生以及如何与他们合作。为实现这一目标，我们向开发团队提供了演示，向NIX介绍。后来，这是一个深入的研讨会。每次直接更改工作流程都伴随着开发公告邮件来解释更改。我们发现热情在我们的同事中，他们中的许多人都成为了自己的爱斯斯特。</p><p>  At Channable we use Nix to build and deploy our services and to manage our development environments. Over the course of more than a year, we gradually adopted Nix, replacing language-specific package managers (for Python), or using Nix to pin them (for Haskell), so we have a uniform way to manage development environments across repositories, OS versions, and execution environments. We use Nix to package and distribute our services to our production servers, which brought us fast and atomic deploys, and instant rollbacks. Having a domain-specific programming language at our disposal, and a package collection maintained by a vibrant community, enabled us to do this.</p><p>  在通道，我们使用NIX构建和部署我们的服务并管理我们的开发环境。在一年多的过程中，我们逐渐采用NIX，替换特定语言的包管理器（用于Python），或者使用nix引脚（对于haskell），因此我们有一个统一的方式来管理跨存储器的开发环境，操作系统版本和执行环境。我们使用NIX将我们的服务包装并将我们的服务分发给我们的生产服务器，它带来了快速和原子部署和即时回滚。拥有域特定的编程语言，以及由充满活力的社区维护的包裹收集，使我们能够这样做。</p><p>  With special thanks to Laurens Duijvesteijn, Wesley Bowman, Sayyed Naqi, the entire DevOps team, and everybody else who joined in this effort.</p><p>  特别感谢Laurens Duijvesteijn，Wesley Bowman，Sayyed Naqi，整个Devops团队，以及其他加入这项工作的人。</p><p>   1: As anyone who has ever written a build system will attest to, it is easy to get started, but gets complex very quickly. Dependency-handling? Sure, let’s add a DAG execution system. Isolation? Of course, let’s use  chroot or Linux namespaces. Caching? Let’s just hash all inputs and put that in a GCS bucket. Incremental builds? Let’s only recompute the build steps that changed. etc.  ↩︎</p><p>   1：由于任何写过构建系统的人都将证明，很容易开始，但很快就会变得复杂。依赖处理？当然，让我们添加一个DAG执行系统。隔离？当然，让我们使用Chroot或Linux命名空间。缓存？让我们只是哈希所有的输入并将其放在GCS桶中。增量构建？让我们只重新计算改变的构建步骤。等等</p><p> 2: In principle, this is of course true of all build systems. But Nix makes it much easier to keep all build inputs around for the long term, by having all build instructions for all external packages in a giant mono-repo. The important part in Nix is to pin the exact version of nixpkgs that you depend on, and additionally to take care that all build inputs outside of nixpkgs are part of your own repo.  ↩︎</p><p> 2：原则上，这当然是所有构建系统。但是，NIX通过在巨型单次repo中拥有所有外部包的所有外部包来保持所有构建的所有构建输入，更容易保持所有构建输入。 NIX中的重要部分是针对您依赖的NIXPKG的确切版本，另外要注意NIXPKGS之外的所有构建输入都是您自己的回购的一部分。 ↩︎</p><p> 3: Shout out to the amazing service of Cachix, their service has saved us a lot of trouble, and the few times something went wrong, it was often already fixed by the time we noticed.  ↩︎</p><p> 3：喊出来给凯乔的惊人服务，他们的服务已经节省了很多麻烦，而几次出错的时间出了一些问题，它经常已经修复了我们注意到的时间。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tech.channable.com/posts/2021-04-09-nix-is-the-ultimate-devops-toolkit.html">https://tech.channable.com/posts/2021-04-09-nix-is-the-ultimate-devops-toolkit.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/终极/">#终极</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ultimate/">#ultimate</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>