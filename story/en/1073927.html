<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>延迟工作与SidekiqDelayed Job vs. Sidekiq</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Delayed Job vs. Sidekiq<br/>延迟工作与Sidekiq</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 21:54:16</div><div class="page_narrow text-break page_content"><p>Most applications need background jobs for mailers, regular clean-ups, or any other time-consuming operation that doesn&#39;t require a user to be present.</p><p>大多数应用程序都需要后台工作来收发邮件、定期清理或任何其他不需要&#39；不需要用户在场。</p><p> Several gems support job queues and background processing in the Rails world —  Delayed Job and  Sidekiq being the two most popular ones.</p><p>在Rails世界中，有几种Gem支持作业队列和后台处理——延迟作业和Sidekiq是两种最流行的Gem。</p><p> In this post, we will take a detailed look at Delayed Job and Sidekiq, including how they fare against each other.</p><p>在这篇文章中，我们将详细介绍延迟工作和Sidekiq，包括它们彼此的表现。</p><p>  Delayed Job is a direct extraction from Shopify and uses a table to maintain all background jobs.It follows a very simple pattern. Any Ruby object that responds to a  perform method can be enqueued in the jobs table.</p><p>延迟作业是直接从Shopify中提取的，并使用一个表来维护所有后台作业。它遵循一个非常简单的模式。任何响应perform方法的Ruby对象都可以在jobs表中排队。</p><p> In addition, if you don&#39;t need to maintain special job objects (although this is highly recommended for testability and clear separation of long-running operations), it also allows you to call  .delay.method(params) on any Ruby object. It will process the method in the background.</p><p>此外，如果你没有&#39；不需要维护特殊的作业对象（尽管强烈建议这样做是为了可测试性和长期运行操作的清晰分离），它还允许您调用。延迟任何Ruby对象上的方法（params）。它将在后台处理该方法。</p><p>  Many teams choose Delayed Job because it is simple and uses their already existing database. They don&#39;t need to spend/maintain other resources.</p><p>许多团队选择延迟作业是因为它很简单，并且使用了他们已经存在的数据库。他们没有&#39；不需要花费/维护其他资源。</p><p> However, it will still take up space in your database table. If you have too many jobs queued at the same time, you might need more disk space to accommodate them all.</p><p>但是，它仍然会占用数据库表中的空间。如果同时排队的作业太多，可能需要更多的磁盘空间来容纳所有作业。</p><p> Sidekiq, on the other hand, uses Redis as its data store to maintain all job metadata.This comes with the obvious benefit of being much faster than the regular database systems Delayed Jobs uses.In addition to this, each Sidekiq process spawns multiple threads to process the jobs even faster.</p><p>另一方面，Sidekiq使用Redis作为其数据存储来维护所有作业元数据。这带来了明显的好处，比常规数据库系统快得多。除此之外，每个Sidekiq进程都会产生多个线程，以更快地处理作业。</p><p> For each background job in Sidekiq, we need a specialized class that includes the  Sidekiq::Worker concern and responds to the  perform method.To enqueue the job, we need to call  perform_async(arg1, arg2) on the worker with the arguments.</p><p>对于Sidekiq中的每个后台作业，我们需要一个专门的类，该类包含Sidekiq:：Worker关注点并响应perform方法。为了让作业排队，我们需要在带有参数的worker上调用perform_async（arg1，arg2）。</p><p> Rails already provides a mature job framework for top-level declaration and handling of jobs.Both Delayed Job and Sidekiq support running jobs through ActiveJob&#39;s unified API.Just inherit from  ApplicationJob and call  perform_later on your job class to enqueue the job to the configured queuing backend.</p><p>Rails已经为作业的顶级声明和处理提供了成熟的作业框架。延迟作业和Sidekiq都支持通过ActiveJob运行作业&#39；这是一个统一的API。只需从ApplicationJob继承并稍后在作业类上调用perform_，即可将作业排队到配置的排队后端。</p><p> The advantage of running jobs with Active Job is that your application code becomes framework agnostic, and switching from Delayed Job to Sidekiq (or vice versa) becomes pretty easy. The   ActiveJob::TestHelper also makes testing enqueued jobs a breeze.</p><p>使用活动作业运行作业的优点是，应用程序代码变得与框架无关，从延迟作业切换到Sidekiq（反之亦然）变得非常容易。TestHelper还使测试排队作业变得轻而易举。</p><p> But the abstraction provided by Active Job also comes with a performance overhead, as job data has to be wrapped before it&#39;s pushed to the store.Sidekiq claims that ActiveJob is about 2-20x slower when pushing to Redis, with ~3x the processing overhead.</p><p>但活动作业提供的抽象也带来了性能开销，因为作业数据必须在它之前进行包装#39；他被推到了商店。Sidekiq声称，当推到Redis时，ActiveJob的速度大约慢2-20倍，处理开销约为3倍。</p><p> Now that we know the basics of Delayed Jobs and Sidekiq, let&#39;s dive deeper into their differences and what each brings to the table.</p><p>既然我们已经了解了延迟工作和Sidekiq的基本知识，那就让&#39；让我们更深入地了解他们的差异，以及他们各自带来的好处。</p><p> For basic applications, both Sidekiq and Delayed Job provide a good set of features out of the box.These include assigning job priorities, named queues, and auto-retry on failures.</p><p>对于基本应用程序，Sidekiq和Delayed Job都提供了一组现成的功能。其中包括分配作业优先级、命名队列和失败时自动重试。</p><p> Delayed Job also provides a way to configure max run time out of the box (Sidekiq does not).</p><p>延迟作业还提供了一种配置开箱即用的最大运行时间的方法（Sidekiq没有）。</p><p> Sidekiq, on the other hand, provides support for  Middleware to update job metadata, skip queuing a job, or execute a job.Sidekiq supports more callbacks, though  some hooks are available for Delayed Job apps. Instead of callbacks, you can use Delayed Job with Active Job (namely, the  before_enqueue and  around_perform callbacks inbuilt into Rails).</p><p>另一方面，Sidekiq为中间件提供了更新作业元数据、跳过作业排队或执行作业的支持。Sidekiq支持更多回调，不过有些钩子可用于延迟的工作应用程序。您可以将延迟作业与活动作业（即嵌入Rails中的before_enqueue和about_perform回调）一起使用，而不是回调。</p><p> Web UI is another feature that comes out of the box with Sidekiq.This provides historical statistics about jobs and information about workers, currently enqueued and dead jobs.You can perform operations like deleting or running jobs immediately without going through the console.</p><p>WebUI是Sidekiq提供的另一项功能。它提供了有关工作的历史统计数据和有关工人、当前排队工作和死亡工作的信息。无需通过控制台即可执行删除或运行作业等操作。</p><p> Delayed Job does not have an inbuilt Web UI, but   delayed_job_web gives access to a basic Web UI with similar features to Sidekiq&#39;s.</p><p>Delayed Job没有内置的Web UI，但Delayed_Job_Web提供了一个基本的Web UI，其功能与Sidekiq和#39类似；s</p><p> Performance-wise, Sidekiq beats Delayed Job quite convincingly.According to  Sidekiq&#39;s open-source benchmark, it is approximately 30x faster than Delayed Job.There are two major reasons for this:</p><p>就性能而言，Sidekiq相当令人信服地击败了延迟工作。根据Sidekiq和#39；它是一个开源的基准测试，比延迟的作业快30倍左右。这主要有两个原因：</p><p> Redis is much faster at querying data than traditional databases like Postgres because it stores data in memory as opposed to the disk.</p><p>Redis查询数据的速度比Postgres等传统数据库快得多，因为它将数据存储在内存中，而不是磁盘中。</p><p> Delayed Job runs a single thread to process jobs, compared to Sidekiq, which uses multiple threads.</p><p>延迟作业运行单个线程来处理作业，而Sidekiq使用多个线程。</p><p> While all of this looks great on paper, the differences do not matter much unless you work on a big scale (something like 10k jobs per minute).The exact number also depends on the average run time of a job. The longer the run time, the less the performance overhead of Delayed Job matters.</p><p>虽然所有这些在纸面上看起来都很好，但这些差异并不重要，除非你进行大规模的工作（大约每分钟10万个工作岗位）。确切的数字还取决于作业的平均运行时间。运行时间越长，延迟作业的性能开销就越小。</p><p> If you&#39;re worried about the performance of Delayed Job, you can make some performance optimizations.The exact indexes to use will depend on the statistics of your job system.For example, if you use multiple queues and only one gets a major chunk of jobs, a simple index on the queue column ( add_index :delayed_jobs, :queue) can significantly improve performance.</p><p>如果你&#39；如果您担心延迟工作的性能，您可以进行一些性能优化。要使用的确切索引将取决于工作系统的统计数据。例如，如果您使用多个队列，但只有一个队列获得了大部分作业，那么在队列列上创建一个简单的索引（add_index:delayed_jobs，：queue）可以显著提高性能。</p><p> Both Delayed Job and Sidekiq have a similar deployment strategy for workers.Using Heroku, you just need to add entries inside your  Procfile to start the job processor and run the workers.</p><p>延迟工作和Sidekiq对员工都有类似的部署策略。使用Heroku，只需在Procfile中添加条目，即可启动作业处理器并运行workers。</p><p> Here&#39;s where things start to get a bit more interesting. Sidekiq has a concurrency option to control how many threads it runs.Most of the Sidekiq vs. Delayed Job benchmarks mention Sidekiq&#39;s very high concurrency of up to 25 threads, which contributes to its super-fast performance.</p><p>这里&#39；这是事情开始变得更有趣的地方。Sidekiq有一个并发选项来控制它运行的线程数。大多数Sidekiq与延迟工作基准都提到Sidekiq和#39；它有高达25个线程的高并发性，这有助于它的超高速性能。</p><p> But in a real setting, you have to limit the threads to something more conservative.The actual number depends on how heavy your application is and what kinds of jobs you perform.What I have seen in practice is that if you run a worker on 512MB memory (equivalent to  standard-1x on Heroku), the number of threads is somewhere between 2 and 5 instead of 25.</p><p>但在实际环境中，你必须将线程限制在更保守的范围内。实际数量取决于你的应用程序有多重以及你执行的工作类型。我在实践中看到的是，如果在512MB内存（相当于Heroku上的standard-1x）上运行一个worker，线程数将介于2到5之间，而不是25个。</p><p> &#39;Taming Rails memory bloat&#39; by Mike Perham, the creator of Sidekiq, discusses memory issues in more detail and is well worth a read.I won&#39;t jump into the full discussion, but he recommends that you set  MALLOC_ARENA_MAX=2 on all workers that run Sidekiq.</p><p>&#39;驯服Rails内存膨胀&#39；Sidekiq的创始人迈克·佩尔姆（Mike Perham）更详细地讨论了记忆问题，值得一读。我赢了&#39；Don’不要直接进入完整的讨论，但他建议对所有运行Sidekiq的员工设置MALLOC_ARENA_MAX=2。</p><p> Using  jemalloc instead of regular  malloc helps too. The exact way to do this depends on the platform you use, but it is pretty simple on Heroku. Just set  heroku-buildpack-jemalloc as the first buildpack (ahead of the  heroku/ruby buildpack).</p><p>使用jemalloc代替常规malloc也有帮助。具体方法取决于您使用的平台，但在Heroku上非常简单。只需将heroku buildpack jemalloc设置为第一个buildpack（在heroku/ruby buildpack之前）。</p><p> As we discussed, Delayed Job runs on your existing database instance.You might need to increase:</p><p>正如我们所讨论的，延迟的作业在现有数据库实例上运行。您可能需要增加：</p><p>  depending on the job load or the number of workers you run. But the only resource you need is the job processor.</p><p>取决于工作负荷或运行的工人数量。但你唯一需要的资源就是作业处理器。</p><p> On the other hand, Sidekiq requires a Redis instance to handle jobs.If you also use Redis as a cache store, it is recommended that you use a separate instance configured as a &#34;persistent store&#34; for Sidekiq jobs.</p><p>另一方面，Sidekiq需要一个Redis实例来处理作业。如果您还将Redis用作缓存存储，建议您使用配置为&#34；持久存储&#34；为Sidekiq工作。</p><p> Since Redis works best when everything fits in memory, if you have too many jobs (for example, if Sidekiq stops processing them for some time due to an issue in the app), it might take some downtime to clear everything up.This is especially troublesome if you have Redis on the same server as your app.They will start competing for memory, leading to swapping and eventually destroying your app&#39;s performance.</p><p>由于Redis在所有东西都放在内存中时效果最好，如果你有太多的作业（例如，如果Sidekiq由于应用程序中的问题而停止处理它们一段时间），可能需要一些停机时间来清理所有东西。如果你的应用程序和Redis在同一台服务器上，这尤其麻烦。他们将开始争夺内存，导致交换并最终摧毁你的应用程序&#39；这是她的表现。</p><p> One important point to note about Redis is that it has to be configured with  maxmemory-policy noeviction to avoid silent drops of Sidekiq&#39;s data.Otherwise, you will find yourself missing jobs that need to be performed, without any trace.</p><p>关于Redis需要注意的一点是，它必须配置maxmemory策略noeviction，以避免Sidekiq&#39；这是数据。否则，你会发现自己缺少需要执行的工作，没有任何痕迹。</p><p> The most notable addition to Pro is  Batch Jobs that can run in parallel, be monitored, and interact as a group, invoking a callback when all jobs are done. Pro also has improved reliability features to ensure that no jobs are dropped silently, even during network problems.</p><p>Pro最值得注意的新增功能是批处理作业，这些作业可以并行运行、被监控，并作为一个组进行交互，在所有作业完成后调用回调。Pro还具有改进的可靠性功能，以确保即使在网络出现问题时，也不会有任何作业被悄无声息地丢弃。</p><p> The Enterprise version comes with yet more features. If you are looking for something that a regular Sidekiq installation can&#39;t solve,  explore the paid Sidekiq features.</p><p>企业版还具有更多功能。如果你正在寻找一些常规Sidekiq安装可以&#39；t解决，探索付费Sidekiq功能。</p><p> In practice, the free version of Sidekiq still works great.But it is good to know that there are paid options you can upgrade to as needed, instead of switching to a different solution.</p><p>实际上，Sidekiq的免费版本仍然非常有效。但很高兴知道，有一些付费选项可以根据需要升级，而不是切换到其他解决方案。</p><p> There is a huge community behind both Sidekiq and Delayed Job. However, it is not always easy to find quick answers to your questions in StackOverflow or the official documentation.</p><p>Sidekiq和延迟工作背后都有一个巨大的社区。然而，在StackOverflow或官方文档中找到问题的快速答案并不总是那么容易。</p><p> On the development side, things are not looking very bright for Delayed Job.There was some minor work done on Delayed Job in December 2021 and January 2022, but it doesn&#39;t seem like it is getting any major developments going forward. It appears to be in maintenance-only mode, and there are a lot of open issues on Github.</p><p>在发展方面，延迟工作的前景并不乐观。在2021年12月和2022年1月，一些延迟的工作做了一些小的工作，但不超过39。它似乎没有取得任何重大进展。它似乎处于仅维护模式，Github上有很多未解决的问题。</p><p> In contrast, Sidekiq is still under active development, and its creator is working full time on it.There are very few open issues, and they get addressed regularly.</p><p>相比之下，Sidekiq仍在积极开发中，它的创建者正在全天致力于此。公开的问题很少，而且经常得到解决。</p><p> In this post, we covered two major job processing systems for Rails applications — Sidekiq and Delayed Job — taking a look at some of their pros and cons.</p><p>在这篇文章中，我们介绍了Rails应用程序的两个主要作业处理系统——Sidekiq和Delayed job，并分析了它们的一些优缺点。</p><p> There are different use cases for each. It all depends on the budget and scale of your operation.</p><p>每个应用程序都有不同的用例。这完全取决于你的预算和运营规模。</p><p> If performance and long-term maintainability are of importance, Sidekiq is a no-brainer.On the other hand, if running costs are a concern, Delayed Job can help you there.</p><p>如果性能和长期可维护性很重要，那么Sidekiq是一个不需要动脑筋的工具。另一方面，如果运营成本是一个问题，延迟工作可以帮助你做到这一点。</p><p> Whether you choose Delayed Job or Sidekiq, good luck with your project and happy coding!</p><p>无论你选择延迟工作还是Sidekiq，祝你的项目好运，编码愉快！</p><p> P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press,  subscribe to our Ruby Magic newsletter and never miss a single post!</p><p>如果你&#39；I’’我想在Ruby Magic的帖子出版后尽快阅读，订阅我们的Ruby Magic时事通讯，永远不要错过任何一篇帖子！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/delayed/">#delayed</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sidekiq/">#sidekiq</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>