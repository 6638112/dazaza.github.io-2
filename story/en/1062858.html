<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你不能在生锈中做的事情（而是做什么） Things you can’t do in Rust (and what to do instead)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Things you can’t do in Rust (and what to do instead)<br/>你不能在生锈中做的事情（而是做什么） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-15 19:17:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/1335d66bc65674f27e9a515476334cf5.png"><img src="http://img2.diglog.com/img/2021/5/1335d66bc65674f27e9a515476334cf5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As a moderator of the  Rust subreddit, I regularly happen upon posts about developers’ attempts to transpose their respective language paradigms to Rust, with mixed results and varying degrees of success.</p><p>作为Rust SubredDit的主持人，我经常发生关于开发人员试图转移各自语言范例的帖子才能生锈，以及混合结果和不同程度的成功。</p><p> In this guide, I’ll describe some of the issues developers encounter when transposing other language paradigms to Rust and propose some alternative solutions to help you work around Rust’s limitations.</p><p> 在本指南中，我将描述开发人员在将其他语言范例转发时遇到的一些问题，并提出了一些替代解决方案，以帮助您在Rust的限制上工作。</p><p>  Arguably the most-asked-about missing feature coming from object-oriented languages is inheritance. Why wouldn’t Rust let a struct inherit from another?</p><p>  可以说是来自面向对象语言的最遗憾的功能是继承。为什么不生锈让struct从另一个人继承？</p><p> You could surely argue that even in the OO world, inheritance has a bad reputation and practitioners usually favor composition if they can. But you could also argue that allowing a type to perform a method differently might improve performance and is thus desirable for those specific instances.</p><p> 你肯定会争辩说，即使在OO世界中，继承人也有一个糟糕的声誉，从业者通常有利于组合。但是，您还可以争辩说，允许类型以不同方式执行方法可能提高性能，因此对于这些特定实例而言是可取的。</p><p>  interface Animal { void tell(); void pet(); void feed(Food food);}class Cat { public void tell() { System.out.println(&#34;Meow&#34;); } public void pet() { System.out.println(&#34;purr&#34;); } public void feed(Food food) { System.out.println(&#34;lick&#34;); }}// this implementation is probably too optimistic...class Lion extends Cat { public void tell() { System.out.println(&#34;Roar&#34;); }}</p><p>  界面动物{void tell（）; void pet（）; void饲料（食品食品）;}类Cat {public void tell（）{system.out.println（＆＃34; meow＆＃34;）; public void pet（）{system.out.println（＆＃34; purr＆＃34;）;公共空缺饲料（食品食品）{system.out.println（＆＃34; lick＆＃34;）;此实现可能太乐观了... Class Lion扩展Cat {public void tell（）{system.out.println（＆＃34;咆哮＆＃34;）; }}</p><p>  trait Animal { fn tell(&amp;self); fn pet(&amp;mut self); fn feed(&amp;mut self, food: Food);}struct Cat;impl Animal for Cat { fn tell(&amp;self) { println!(&#34;Meow&#34;); } fn pet(&amp;mut self) { println!(&#34;purr&#34;); fn feed(&amp;mut self, food: Food) { println!(&#34;lick&#34;); }}</p><p>  特质动物{FN告诉（＆amp; self）; FN PET（＆amp; mut self）; Fn Feed（＆amp; mut自我，食品：食物）;} struct cat; ich ic of tam act {fn tell（＆amp; self）{println！（＆＃34; meow＆＃34;）; FN PET（＆amp; mut self）{println！（＆＃34; purr＆＃34;）; Fn饲料（＆amp; mut自我，食物：食物）{println！（＆＃34; lick＆＃34;）; }}</p><p>  struct Lion;impl Animal for Lion { fn tell(&amp;self) { println!(&#34;Roar&#34;); } // Error: Missing methods pet and feed}</p><p>  STRUCT LION;锯割的狮子{FN告诉（＆amp; self）{println！（＆＃34;咆哮＆＃34;）; } //错误：缺少方法宠物和饲料} </p><p> The simplest way is, obviously, to duplicate the methods. Yes, duplication is bad. So is complexity. Create a free method and call that from the  Cat and  Lion impl if you need to deduplicate the code.</p><p>显然，最简单的方式是复制这些方法。是的，复制很糟糕。复杂性也是如此。如果您需要重复使用该代码，请创建一个免费的方法并从Cat和Lion ich ich ich呼叫。</p><p> But wait, you might say, what about the polymorphism part of the equation? That’s where it gets complicated. Where OO languages usually give you dynamic dispatch, Rust makes you choose between static and dynamic dispatch, and both have their costs and benefits.</p><p> 但是等等，你可能会说，那些关于方程的多态性部分呢？这就是它变得复杂的地方。如果OO语言通常会给您动态调度，Rust会让您在静态和动态调度之间进行选择，并且都有其成本和福利。</p><p> // static dispatchlet cat = Cat;cat.tell();let lion = Lion;lion.tell();// dynamic dispatch via enumenum AnyAnimal { Cat(Cat), Lion(Lion),}// `impl Animal for AnyAnimal` left as an exercise for the readerlet animals = [AnyAnimal::Cat(cat), AnyAnimal::Lion(Lion)];for animal in animals.iter() { animal.tell();}// dynamic dispatch via &#34;fat&#34; pointer including vtablelet animals = [&amp;cat as &amp;dyn Animal, &amp;lion as &amp;dyn Animal];for animal in animals.iter() { animal.tell();}</p><p> //静态探索猫=猫; cat.tell（）;让狮子=狮子; lion.tell（）; //通过enumenum anyanimal {cat（猫），狮子（狮子），狮子（狮子），狮子（狮子），鼠标为Anyanimal`留下了Readerlet Animage的练习= [Anyanimal :: Cat（Cat），Anyanimal ::狮子（狮子）];对于动物的动物。Its（）{Animal.tell（）;} //通过＆＃34;脂肪＆＃34;指针包括vtablecelet动物= [＆amp;猫作为＆amp; dyn动物，＆amp;狮子＆amp; dyn动物];对于动物的动物。ters（）{amall.tell（）;}</p><p> Note unlike in garbage collected languages, each variable has to have a single concrete type at compile time. Also, for the enum case, delegating the implementation of the trait is tedious, but crates such as  ambassador can help.</p><p> 注意与垃圾收集的语言不同，每个变量必须在编译时具有单个混凝土类型。此外，对于枚举案例，委派特征的实施是乏味的，但大使等板条箱可以提供帮助。</p><p>  Finally, it’s possible to implement a trait for all classes that implement one of a number of other traits, but it requires specialization, which is a nightly feature for now (though there is a  workaround available, even packed in a  macro crate if you don’t want to write out all the boilerplate required). Traits may very well inherit from each other, though they only prescribe behavior, not data.</p><p>  最后，可以为实现许多其他特征的所有类来实现一个特征，但它需要专业化，这是现在的夜间功能（尽管有一个可用的解决方法，但如果您不提供宏观箱想要写出所有需要的样板）。特征可能很好地彼此继承，尽管它们只规定行为，而不是数据。</p><p>  Many folks coming from C++ to Rust will at first want to implement a “simple” doubly linked list but quickly learn that it’s actually far from simple. That’s because Rust wants to be clear about ownership, and thus doubly linked lists require quite complex handling of pointers vs. references.</p><p>  来自C ++来源的许多人员将首先想要实现“简单”的双链列表，但快速了解它实际上远非简单。那是因为Rust想要清楚所有权，因此双重链接列表需要相当复杂的指针与参考。</p><p>   Well, they’ll add the  Option and  Box when they note that this otherwise fails. But once they try to implement insertion, they’re in for an unpleasant surprise:</p><p>   好吧，他们会在注意到这一点失败时，他们将添加选项和框。但是一旦他们试图实现插入，它们就会出现不愉快的惊喜： </p><p> impl&lt;T&gt; MyLinkedList&lt;T&gt; { fn insert(&amp;mut self, value: T) { let next_node = self.next_node.take(); self.next_node = Some(Box::new(MyLinkedList { value, previous_node: Some(Box::new(*self)), // Ouch next_node, })); }}</p><p>ichsl lt; t＆gt; MyLinkedList＆lt; t＆gt; {fn插入（＆amp; mut self，value：t）{let next_node = self.next_node.take（）; self.next_node = some（box :: new（mylinkedlist {value，previous_node：some（box :: new（* self）），//哎哟next_node，}））））; }}</p><p> Of course, the  borrow checker won’t allow this. The  ownership of values is completely muddled.  Box owns the data it contains, and thus each node in the list would be owned by the previous and next node in the list. Rust only ever allows one owner per data, so this will at least require a  Rc or  Arc to work. But even this becomes cumbersome quickly, not to mention the overhead from reference counts.</p><p> 当然，借款检查器不会允许这个。价值的所有权完全混乱。框拥有它包含的数据，因此列表中的每个节点都将由列表中的上一个节点和下一个节点拥有。生锈只允许每个数据允许一个所有者，因此这将至少需要RC或ARC工作。但即使这也很快就会变得麻烦，而不是提及参考数量的开销。</p><p> Luckily, you don’t have to write a doubly linked list because the standard library already contains one ( std::collections::LinkedList). Also, it is quite rare that this will give you good performance compared to simple  Vecs, so you may want to measure accordingly.</p><p> 幸运的是，您无需编写双链接的列表，因为标准库已包含一个（std :: collections :: linkedlist）。此外，与简单的VEC相比，这将使您提供良好的性能，因此您可能希望相应地衡量。</p><p> If you  really want to write a doubly linked list, you can refer to “ Learning Rust With Entirely Too Many Linked Lists,” which may help you both write linked lists and learn a lot about  unsafe Rust in the process.</p><p> 如果您真的想编写双链接的列表，您可以引用“使用完全太多链接的列表学习生锈”，这可能会帮助您两个写链接的列表，并在此过程中学习很多关于不安全的Rust。</p><p> (Aside: Singly-linked lists are absolutely fine to build out of a chain of boxes. In fact, the Rust compiler contains an  implementation.)</p><p> （抛开：单独的清单绝对是盒子的盒子。实际上，Rust编译器包含一个实施。）</p><p> The same mostly applies to graph structures, although you’ll likely need a dependency for handling graph data structures.  petgraph is the most popular at the moment, providing both the data structure and a number of graph algorithms.</p><p> 同样主要适用于图形结构，尽管您可能需要对处理图数据结构的依赖性。 Petgraph是目前最受欢迎的，提供数据结构和多个图形算法。</p><p>  When faced with the concept of self-referencing types, it’s fair to ask, “Who owns this?” Again, this is a wrinkle in the ownership story that the borrow checker isn’t usually happy with.</p><p>  当面对自我引用类型的概念时，要问，“谁拥有这个？”再次，这是借用检查者通常不满的所有权故事的皱纹。 </p><p> You’ll encounter this problem when you have an ownership relation and want to store both the owning and owned object within one struct. Try this naïvely and you’ll have a bad time trying to get the lifetimes to work.</p><p>当您拥有所有权关系并希望在一个结构中存储所有拥有和拥有的对象时，您将遇到此问题。尝试这个天真，你会有一个糟糕的时间，试图获得工作的生命。</p><p> We can only guess that many Rustaceans have turned to unsafe code, which is subtle and really easy to get wrong. Of course, using a plain pointer instead of a reference will remove your lifetime worries, as pointers carry no lifetime. However, this is taking up the responsibility of managing the lifetime manually.</p><p> 我们只能猜测许多Rustaceans转向不安全的代码，这是微妙的，真的很容易出错。当然，使用普通指针而不是参考将移除您的终身担忧，因为指针携带一生。但是，这是占据手动管理寿命的责任。</p><p> Luckily there are some crates that take the solution and present a safe interface, such as the  rental and  once_self_cell crates.</p><p> 幸运的是，有一些箱子采取解决方案并呈现一个安全的界面，例如租赁和_FORT_SELF_CELL板条箱。</p><p>  People coming from C and/or C++ — or, less often, from dynamic languages — are sometimes accustomed to creating and modifying global state throughout their code. For  example, one Redditor ranted that “It’s completely safe and yet Rust doesn’t let you do it.”</p><p>  来自C和/或C ++的人们 - 或者少于动态语言 - 有时习惯于在整个代码中创建和修改全球状态。例如，一个Redditor咆哮着“这是完全安全的，而且生锈不会让你这样做。”</p><p>  #include &lt;iostream&gt;int i = 1;int main() { std::cout &lt;&lt; i; i = 2; std::cout &lt;&lt; i;}</p><p>  #include＆lt; iostream＆gt; int i = 1; int main（）{std :: cout <lt;一世;我= 2; std :: cout＆lt;＆lt;一世;}</p><p>  static I: u32 = 1;fn main() { print!(&#34;{}&#34;, I); i = 2; // &lt;- Error: Cannot mutate global state print!(&#34;{}&#34;, I);}</p><p>  静态I：u32 = 1; fn main（）{print！（＆＃34; {}}＆＃34; i）;我= 2; //＆lt;错误：无法变异全球州打印！（＆＃34; {}}＆＃34; i）;}</p><p> Many Rustaceans will tell you that you just don’t need that state to be global. Of course, in such a simple example, this is true. But for a good number of use cases, you really do need global mutable state — e.g., in some embedded applications.</p><p> 许多rustaceans会告诉你，你只是不需要那个国家成为全球性的。当然，在这样一个简单的例子中，这是真的。但对于许多使用情况，您真的需要全局变形状态 - 例如，在某些嵌入式应用程序中。 </p><p> There is, of course a way to do it, using  unsafe. But before you reach for that, depending on your use case, you may just want to use a  Mutex instead to be really sure. Or, if the mutation is only needed once for initialization, a  OnceCell or  lazy_static will solve the problem neatly.</p><p>当然，使用不安全的方式做到这一点。但是在您到达之前，根据您的用例，您可能只想使用互斥锁，而是真正确定。或者，如果只需要突变一次进行初始化，则oncecell或lazy_static将整齐地解决问题。</p><p> With that said, especially in the embedded world where every byte counts and resources are often mapped into memory, having a mutable static is often the preferred solution. So if you really must do it, it would look like this:</p><p> 与此同说，特别是在嵌入式世界中，每个字节计数和资源通常被映射到存储器中，具有可变静态通常是首选解决方案。所以，如果你真的必须这样做，那将是这样的：</p><p> static mut DATA_RACE_COUNTER: u32 = 1;fn main() { print!(&#34;{}&#34;, DATA_RACE_COUNTER); // I solemny swear that I&#39;m up to no good, and also single threaded. unsafe { DATA_RACE_COUNTER = 2; } print!(&#34;{}&#34;, DATA_RACE_COUNTER);}</p><p> static mut data_race_counter：u32 = 1; fn main（）{print！（＆＃34; {}}＆＃34; data_race_counter）; //我索蒙尼发誓，我没有好，也是单线的。不安全{data_race_counter = 2;打印！（＆＃34; {}＆＃34;，data_race_counter）;}</p><p> Again, you shouldn’t do this unless you really need to. And if you need to ask whether it’s a good idea, the answer is no.</p><p> 再次，除非你真的需要，否则你不应该这样做。如果你需要询问这是一个好主意，答案是否定的。</p><p>    This fails because the array was never initialized. We then try to assign values into it, but without telling the compiler, it won’t even reserve a place for us to write on the stack. Rust is picky like that; it distinguishes the  array from its contents. Furthermore it requires both to be initialized before we can read them.</p><p>    这失败，因为数组从未初始化。然后我们尝试将值分配给它，但没有告诉编译器，它甚至不会为我们写在堆栈上的地方。生锈是挑剔的;它将数组与其内容区分开来。此外，它需要在我们读取它们之前初始化。</p><p> By initializing  let array = [0usize; 512];, we solve this problem at the cost of a double initialization, which may or may not get optimized out — or, depending on the type, may even be impossible. See “ Unsafe Rust: How and when (not) to use it” for a solution.</p><p> 通过初始化let array = [0usize; 512];我们以双重初始化的成本解决了这个问题，这可能会或可能不会被优化 - 或者，根据类型，甚至可能是不可能的。请参阅“不安全的生锈：如何以及何时（不）使用它”解决方案。</p><p> Debugging Rust applications can be difficult, especially when users experience issues that are difficult to reproduce. If you’re interested in monitoring and tracking performance of your Rust apps, automatically surfacing errors, and tracking slow network requests and load time,  try LogRocket.    LogRocket is like a DVR for web apps, recording literally everything that happens on your Rust app. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. LogRocket also monitors your app’s performance, reporting metrics like client CPU load, client memory usage, and more.</p><p> 调试生锈应用可能是困难的，特别是当用户遇到难以重现的问题时。如果您有兴趣监控和跟踪生锈应用的性能，自动浮出误差，以及跟踪慢速网络请求和负载时间，请尝试Logrocket。 Logrocket就像Web应用程序的DVR，字面上录制了生锈应用程序上发生的一切。而不是猜测为什么问题发生，而是可以聚合和报告您的应用程序在发生问题时的状态。 Logrocket还监视您的应用程序的性能，报告客户端CPU负载，客户端内存用法等度量标准。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/">https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/不能/">#不能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>