<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一年的Elixir：它如何比较红宝石 One Year of Elixir: How It Compares to Ruby</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">One Year of Elixir: How It Compares to Ruby<br/>一年的Elixir：它如何比较红宝石 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-07 07:52:07</div><div class="page_narrow text-break page_content"><p>Last year I started a new job at  Brex where Elixir is the primary programming language for business logic. This was my first real adventure into Elixir after working in Ruby (mostly) for my professional career. Since José Valim came from the Ruby world, Elixir was a common buzzword I heard for years. I had done a tutorial or two here and there but never gotten to really use it. Now, looking back at the past year I’ve become fairly comfortable with Elixir, and wanted to outline some of the things I really enjoy about Elixir and some of the things I miss from Ruby.</p><p>去年我在BREX开始了一份新工作，Elixir是业务逻辑的主要编程语言。这是我在Ruby（主要）为我的职业生涯工作后第一个真正的冒险。由于JoséGalim来自Ruby World，因此Elixir是我多年来听到的常见流行语。我在这里做过了一个教程或两个，但从未真正使用它。现在，回顾过去一年，我对elixir变得相当舒适，并希望概述一些我真正喜欢的一些关于酏剂的东西，以及我想念的一些我想念的东西。</p><p>  First off there are lots of great things about the Elixir programming language. This post by no means is going to cover all them or talk about when you should use Elixir vs Ruby. These are solely a few of my opinions and observations I’ve gathered over the past year on Elixir coming from a Ruby (on Rails) background.</p><p>  首先有很多关于Elixir编程语言的好事。这篇文章绝不是将所有这些帖子覆盖或谈论，何时应该使用Elixir vs Ruby。这些只是我在过去一年中收集的一些意见和观察，从Ruby（在Rails）背景中收集了Elixir。</p><p>  Processes are an abstraction built into the language (thanks erlang), that are extremely lightweight in terms of memory and CPU and allow code to run in isolation and concurrently. Processes provide the building blocks for concurrency in Elixir and allow us to write distributed and fault tolerant code. Because of processes writing concurrent code in Elixir is incredibly simple and straightforward. However in Ruby, there is the concept of the Global Interpreter Lock (GIL) which prevents multiple Ruby threads from executing at the same time.</p><p>  进程是一种抽象，内置于语言（谢谢Erlang），在内存和CPU方面非常轻量级，并且允许代码以隔离运行并同时运行。进程为Elixir中的并发性提供了构建块，并允许我们编写分布式和容错代码。由于流程在Elixir中编写并发代码非常简单和简单。但是在Ruby中，存在全局解释器锁（GIL）的概念，这可以防止多个Ruby线程同时执行。</p><p>  Elixir does a really good job when it comes to documentation. Via hexdocs, developers can easily write documentation inline with their code and then generate and host it for free! This makes it incredibly low effort to create documentation for your OSS. The Elixir language and other libraries developed by the core team take full advantage of hexdocs, creating very robust documentation. Hexdocs are very well designed which makes them incredibly easy to read and navigate as well. You can even write and run tests from documentation which is a great way to write multi-purpose code examples in your documentation. Just take a look at the  Elixir DateTime docs, the below  @doc module attribute will generate the hexdocs and the examples will be run during tests just by adding  doctest DateTime to the xxx_test.exs file.</p><p>  在文献中，Elixir在文件方面做得非常好。通过Hexdocs，开发人员可以轻松地与其代码内联编写文档，然后免费生成并托管它！这使得为​​您的OSS创建文档令人难以置信的努力。核心团队开发的Elixir语言和其他库充分利用了六角洲，创造了非常强大的文档。 Hexdocs设计得很好，这使得它们难以读和导航。您甚至可以从文档中编写和运行测试，这是在文档中编写多功能代码示例的重要方法。只需查看Elixir DateTime Docs，下面的@doc模块属性将生成Hexdocs，并且通过将Doctest DateTime添加到XXX_Test.exs文件中的测试期间，将在测试期间运行示例。</p><p> &#34;&#34;&#34; Compares two datetime structs. Returns `:gt` if the first datetime is later than the second and `:lt` for vice versa. If the two datetimes are equal `:eq` is returned. Note that both UTC and Standard offsets will be taken into account when comparison is done. ## Examples iex&gt; dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: &#34;AMT&#34;, ...&gt; hour: 23, minute: 0, second: 7, microsecond: {0, 0}, ...&gt; utc_offset: -14400, std_offset: 0, time_zone: &#34;America/Manaus&#34;} iex&gt; dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: &#34;CET&#34;, ...&gt; hour: 23, minute: 0, second: 7, microsecond: {0, 0}, ...&gt; utc_offset: 3600, std_offset: 0, time_zone: &#34;Europe/Warsaw&#34;} iex&gt; DateTime.compare(dt1, dt2) :gt &#34;&#34;&#34;      &#34;1.4.0&#34;   compare (Calendar .datetime ( ) , Calendar .datetime ( ) )  ::  :lt  |  :eq  |  :gt  def compare ( ... )  do  ...</p><p> ＆＃34;＆＃34;＆＃34;比较两个DateTime结构。如果第一个DateTime晚于第二个DATETIME而返回“：GT`，则为”：LT`反之亦然。如果两个日期时间是平等的`：返回EQ`。请注意，在完成比较时，将考虑UTC和标准偏移。 ##示例IEX＆gt; dt1 =％datetime {年：2000，月：2，日：29，zone_abbr：＆＃34; amt＆＃34; ...＆gt;小时：23，分钟：0，第二：7，微秒：{0，0}，...＆gt; UTC_OFFSET：-14400，std_offset：0，time_zone：＆＃34;美国/ Manaus＆＃34;} Iex＆gt; dt2 =％datetime {年：2000，月：2，日：29，zone_abbr：＆＃34; cet＆＃34; ...＆gt;小时：23，分钟：0，第二：7，微秒：{0，0}，...＆gt; UTC_OFFSET：3600，std_offset：0，time_zone：＆＃34;欧洲/华沙＆＃34;} Iex＆gt; DateTime.comPare（DT1，DT2）：GT＆＃34;＆＃34;＆＃34; ＆＃34; 1.4.0＆＃34;比较（日历.datetime（），calendar .datetime（））:::LT | ：EQ | ：GT DEF比较（...）做...</p><p>  When I was in college I took a functional programming course which taught me  OCaml. This was my first foray into functional programming and way back then I realized how incredibly powerful and useful pattern matching was. No more complex and hard to read switch/if statements. So when I first started writing Elixir, I was excited to get to use  pattern matching again. For example, the  = sign is the match operator in Elixir not assignment. Pattern matching allows us to match simple values, data structures, and even functions. So what does this look like in practice?</p><p>  当我在大学时，我采取了一个功能的程序编程课程，教我OCAML。这是我第一次进入功能规划和回来的方式，然后我意识到了令人难以置信的强大和有用的模式匹配是多么令人难以置信的。没有更复杂，难以读取交换机/ if语句。因此，当我第一次开始写Elixir时，我很高兴再次使用模式匹配。例如，= sign是Elixir中的匹配操作员而不是赋值。模式匹配允许我们匹配简单的值，数据结构甚至函数。那么这在实践中是什么样的？</p><p> Here we can see how we can extract values of a tuple into variables. We also see an example of the pin operator  ^ which will match the current value vs extracting it into a variable. This makes writing assertive code straightforward.</p><p> 在这里，我们可以看到我们如何将元组的值提升为变量。我们还看到了PIN运算符^的示例，它将与当前值vs提取到变量中的匹配。这使得简单地写作自信的代码。 </p><p> iex &gt;  {a , b , c }  =  { :hello ,  &#34;world&#34; ,  42 } { :hello ,  &#34;world&#34; ,  42 }iex &gt; a :helloiex &gt; b &#34;world&#34;iex &gt;  ^c  =  34 * *  (MatchError ) no match of right hand side    34</p><p>IEX＆gt; {a，b，c} = {：你好，＆＃34;世界＆＃34; ，42} {：你好，＆＃34;世界＆＃34; ，42} iex＆gt;答：Helloiex＆gt; B＆＃34;世界＆＃34; iex＆gt; ^ c = 34 * *（matchError）没有右手边的匹配</p><p> Another example of the power of pattern matching is to dynamically dispatch functions based on the parameters. For example the below shows the  first function defined to handle three different parameter patterns and dynamically choose the correct function definition.</p><p> 图案匹配权的另一个例子是基于参数动态分配函数。例如，下面显示定义为处理三种不同参数模式的第一函数，并动态选择正确的函数定义。</p><p>  And lastly it can be great for control flows via  case statements or  with statements like the below, which will only continue along the current flow if the previous pattern matches. For example,  coordinate must be a three-tuple, and each  evaluate function must return an ok tuple to do the final addition. If any pattern doesn’t match it will go to the  else clause and attempt to pattern match there to return 0 (There is a scenario where no pattern matches though and we get a  MatchError)</p><p>  最后，通过案例陈述或如下陈述，控制流程非常棒，如果先前的模式匹配，则只能沿着当前流程继续沿着当前流程。例如，坐标必须是三元组，每个评估函数必须返回确定的元组以进行最终添加。如果任何模式不匹配它将转到else子句，并尝试将匹配匹配返回0（虽然没有模式匹配的情况，但我们得到一个鼠置场景。</p><p> with  {x , y , z }  &lt;- coordinate ,  { :ok , x_val }  &lt;- evaluate (x ) ,  { :ok , y_val }  &lt;- evaluate (y ) ,  { :ok , z_val }  &lt;- evaluate (z )  do x_val  + y_val  + z_val else  nil  -&gt;  0  { :error , _reason }  -&gt;  0 end</p><p> 使用{x，y，z}＆lt;  - 坐标，{：确定，x_val}＆lt;  - 评估（x），{：确定，y_val}＆lt;  - 评估（y），{：确定，z_val}＆lt;  - 评估（z）do x_val + y_val + z_val else nil  - ＆gt; 0 {：错误，_REAN}  - ＆gt; 0结束</p><p>  The Elixir standard library comes with a number of useful functions and modules, as well as first class tooling. First off Exunit and async tests are a big win over Ruby. When working in Ruby, the first thing was to pull in RSpec and any necessary matchers, but in Elixir this isn’t necessary because exunit is built into the language. You have a test framework out of the box, and it allows you to run tests asynchronously as well! This was a huge pain point back when I was in a Ruby on Rails monolith, running all the tests synchronously just got slower and slower over time but in Elixir even in a large service it’s relatively fast with async tests runs. Another great built in tool in Elixir is  Mix which is “a build tool that ships with Elixir and provides tasks for creating, compiling, testing your application, managing its dependencies and much more.” Mix allows you to quickly and easily 1) start new Elixir projects via  mix new, 2) manage your dependencies and retrieve them via  mix deps.get, 3) run tests via  mix test, and 4) format your code to make it easy to read and digest via  mix format. In Ruby this would be replaced by about 4 separate tools:  rails new or templates for starting new projects, 2) bundler for managing and retrieving dependencies, 3) RSpec for running tests, and 4) Rubocop or another third party tool for formatting and checking your code. This makes it incredibly straightforward and easy to get a project up and running with ease.</p><p>  Elixir标准库配有许多有用的功能和模块，以及一流的工具。首先，外出和异步测试在Ruby中是一个大的胜利。在Ruby工作时，第一件事就是拉到RSPEC和任何必要的匹配，但在Elixir中，这不是必需的，因为散发是语言的。您可以开箱即用测试框架，它还允许您异步运行测试！这是一个巨大的痛苦点，当我在铁路巨石上的Ruby时，随着时间的推移同步地运行所有测试，但在Elixir中，即使在大型服务中，也与Async测试运行相对较快。 Elixir中的另一个伟大的工具是混合，它是“带有Elixir的构建工具，并提供用于创建，编译，测试应用程序，管理其依赖项的任务。”混合允许您快速且轻松地通过MIX New，2）启动新的Elixir项目，2）通过Mix Deps.get，3）通过Mix测试运行测试，4）格式化您的代码可以轻松地进行测试通过混合格式读取和摘要。在Ruby中，这将替换为4个单独的工具：Rails新项目或模板，用于启动新项目，2）Bundler用于管理和检索依赖项，3）RSPEC用于运行测试，4）Rubocop或其他用于格式化和检查的第三方工具你的代码。这使得它非常简单且易于通过轻松获得项目和运行。</p><p>  Pipes ( |&gt;) are a great way to easily chain function calls together in Elixir, similar to how you would chain function calls in Ruby. Before I knew becoming acquainted with Elixir, pipe operators were a bit confusing, but after a quick introduction you can easily spot them and understand the flow of code.</p><p>  管道（|＆gt;）是轻松链接函数调用在Elixir中的好方法，类似于你将如何在Ruby中呼叫。在我知道熟悉Elixir之前，管道运营商有点混乱，但在快速介绍后，您可以轻松地发现它们并理解代码的流程。</p><p>      That being said, there are still a lot of good things about Ruby and some things I miss. These are probably the biggest two things I’ve really missed over the past year.</p><p>      据说，关于红宝石还有很多好事和我想念的一些事情。这些可能是过去一年中真正错过的最大两件事。 </p><p>  Personally, the greatest thing about Ruby is the massive community and resources around it. Ruby started in 1995 whereas Elixir is a lot newer, being initially released in 2011. Ruby and Ruby on Rails have gained massive user bases and because of this have a huge number of resources. One of the best things about Ruby is the fact that there will almost always be a library(gem) for what you want to do and they generally are well maintained. On top of that there’s a plethora of tutorials and resources to learn Ruby. A big pain point with Elixir is the smaller community and lack of open source libraries. Although there are a lot of learning resources for new Elixir developers. There’s also a lot of great libraries built by the core Elixir team for most needs, but there’s still not a lot of libraries in comparison to other languages. At Brex, we have needed to write a number of internal Elixir libraries for our specific needs or for third party services which don’t have an SDK in Elixir. A couple of other issues are that a lot of Elixir libraries aren’t well maintained and go dormant often or are maintained by a single maintainer which makes it hard to get updates in a timely manner. That being said Elixir is still a fairly young language and with its continued growth hopefully it will improve.</p><p>就个人而言，Ruby最伟大的事情是它周围的大量社区和资源。 Ruby于1995年开始，而Elixir是一个较新的，最初在2011年发布。Ruby和Ruby在Rails上获得了大量的用户基础，因为这有很多资源。关于Ruby的最佳事物之一是，几乎总是将永远是您想要做的内容（Gem），并且它们通常保持良好。最重要的是，有一个富豪的教程和资源来学习Ruby。具有Elixir的大痛点是较小的社区和缺乏开源库。虽然新的Elixir开发商有很多学习资源。 Core Elixir团队的大多数需要也有很多伟大的图书馆，但与其他语言相比，仍然没有很多图书馆。在BREX，我们需要为我们的特定需求或第三方服务编写许多内部ELIXIR库，或者在Elixir中没有SDK。其他一些问题是，许多以纯粹的西仙图书馆都没有得到很好的维护，经常保持休眠，或者由单个维护者维护，这使得难以及时获得更新。被称为Elixir仍然是一个相当年轻的语言，并且持续增长，希望它将改善。</p><p>  Monkey patching is a way to extend or change a Ruby class, including within libraries, dynamically by writing code directly into your project. This makes it incredibly easy to personalize or customize library functionality for your personal needs or patch a bug as a stop gap until the underlying library can be fixed. In Elixir you can wrap open source libraries with your own code to extend or personalize it but this can be a lot of boilerplate and extra code to just add a simple change. More often than not this may also involve writing a macro which  should generally be avoided whenever possible. However, this doesn’t allow you to fix bugs in an underlying library like monkey patching does. You would need to fork a library and make the change yourself then point your project to your branch in order to do this without waiting for the underlying library to be fixed.</p><p>  猴子补丁是一种扩展或更改Ruby类的方法，包括库中，通过将代码直接写入项目中动态地进行动态。这使得令人难以置信的易于个性化或自定义图书馆功能，以便您的个人需求或修补错误作为停止间隙，直到可以修复底层库。在Elixir中，您可以使用自己的代码包装开源库以扩展或个性化，但这可能是大量的样板和额外的代码，只需添加简单的更改。通常，这也可能涉及写一种宏，只要尽可能避免。但是，这不允许您修复像猴子修补的底层库中的错误。您需要拼写一个库并使自己的变化，然后将项目指向分支以便在不等待潜在的图书馆修复这一点。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://boredhacking.com/one-year-of-elixir/">https://boredhacking.com/one-year-of-elixir/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/elixir/">#elixir</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>