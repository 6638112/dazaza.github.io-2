<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用system.io.pipelines在c＃中的性能助推器 Performance Booster with System.IO.Pipelines in C#</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Performance Booster with System.IO.Pipelines in C#<br/>使用system.io.pipelines在c＃中的性能助推器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-04 01:34:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/5f9666d0130a96ba0eeb79c5eb30073b.png"><img src="http://img2.diglog.com/img/2021/6/5f9666d0130a96ba0eeb79c5eb30073b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As our industry has embraced the new strategies for handling the production workloads which include containers (Read as K8s) or Serverless (Read as Functions As A Service), the developers don’t have the luxury of unlimited computing resources on the production environments. Those days are gone where it was easy to acquire a large virtual machine with many cores and high memory for application deployment needs. As a .net developer though you are working with managed code and you rely on GC (Garbage collector) to do the job, the onus is now on you to write highly performant code which can run anywhere right from docker containers to IoT devices. With advent of C#8 and .NET core , Microsoft .NET team has been very cognizant of memory allocations. Every new version comes with modern APIs that can increase the performance of the application to X times more compared with older version of traditional APIs. In this blog post I will be showcasing the file I/O operations with 3 different techniques and will benchmark each technique. From the benchmarks results it will be pretty evident that System.IO.Pipelines wins by a considerable margin both in the time of execution and memory allocation.</p><p>由于我们的行业已接受处理包括容器（读为K8S）或无服务器的生产工作负载的新策略或无服务器（作为服务的函数读取），开发人员没有在生产环境中具有无限制的计算资源的奢侈。那些日子已经消失，可以轻松获取具有许多核心和高内存的大型虚拟机，以进行应用程序部署需求。作为.NET开发人员虽然您使用托管代码而且您依赖GC（垃圾收集器）进行作业，但ONU现在正在编写高度性能的代码，该代码可以从Docker容器到IoT设备的任何位置运行。随着C＃8和.NET核心的出现，Microsoft .NET团队一直非常认识到内存分配。每个新版本都配有现代API，可以将应用程序的性能提高到与旧版传统API的旧版。在此博客文章中，我将以3种不同的技术展示文件I / O操作，并将对每个技术进行基准。从基准测试结果，System.io.pipelines在执行和内存分配时都会非常明显。</p><p>  We will be experimenting with reading a large csv file (100,000 records with 5 fields) of employee data. I’m sure you must encounter this challenge many times in your career where you have to parse a large csv file. This challenge creates a enough pressure on GC. The considerations around garbage collection are particularly important when thinking about performance. This is because garbage collection takes up CPU time, reducing the time spent on the actual data processing. Not only this, but each time a garbage collection is triggered, much of the work is suspended so that the remaining references can be evaluated. This can drastically effect the amount of time taken to process the data. I’ve chosen three techniques for this challenge.</p><p>  我们将尝试阅读员工数据的大型CSV文件（具有5个字段的10万条记录）。我相信您必须在您的职业生涯中遇到此挑战，在那里您必须解析大型CSV文件。这一挑战在GC上创造了足够的压力。垃圾收集周围的考虑因素时尤为重要。这是因为垃圾收集占用CPU时间，减少了在实际数据处理上花费的时间。不仅如此，而且每次触发垃圾收集时，都会暂停大部分工作，以便可以评估其余的引用。这可以大大影响处理数据所需的时间量。我为这一挑战选择了三种技术。</p><p> Using  CSVHelper : This is a popular library for parsing csv files in .NET ecosystem.</p><p> 使用CSVhelper：这是一个流行的库，用于在.NET生态系统中解析CSV文件。</p><p> Using IAsyncEnumerable : This API was introduced from C#8 where a data stream (chunks of data) can be processed instead of whole file.</p><p> 使用IASyncenumerable：从C＃8引入此API，其中可以处理数据流（数据块）而不是整个文件。</p><p> Using System.IO.Pipelines : This API was shipped with .NET core 2.1 and is internally used by Kestrel , web server for AspNET core for high performance to process many requests per second received from the socket. It is available as  Nuget package download.David Fowler who has architected these APIs as an excellent  post of its introduction.</p><p> 使用system.io.pipelines：此API已使用.NET Core 2.1附带，并且由Kestrel，用于ASPNet核心的Web服务器内部用于高性能，以处理从套接字收到的每秒的许多请求。它可以作为Nuget包下载.David福勒，他们将这些API归档为其介绍的优秀帖子。</p><p> The source code of this post is available on my  Github repo. The repo also consists of tests which has benchmarks results.</p><p> 我的github repo上有此帖子的源代码。 Repo还包括具有基准结果的测试。</p><p>   The entry point public method is  ProcessFileAsync , which creates the instance of PipeReader class , it reads that data and converts into buffer, which is of data type of   ReadOnlySequence&lt;byte&gt; . This buffer data is then passed to  ParseLines method as a ref along with the position of the PipeReader , which has 0 value as it is in the beginning position.  ParseLines method tries to navigate the new line using  NewLine as a delimiter. This process continue till the end position of PipeReader is reached. After parsing is finish the PipeRead position is moved till the end of the buffer and it is marked as processed (line number 35 and 43).</p><p>   进入点公共方法是processFileAsync，它创建了Pipereader类的实例，它读取该数据并转换为缓冲区，这是readonlysequence的数据类型＆lt; byte＆gt; 。然后将该缓冲区数据传递给Parselines方法作为参考，以及Pipereader的位置，其具有0值，因为它处于开始位置。 Parselines方法尝试使用换行符导航新行作为分隔符。此过程继续到达牵引液位器的最终位置。解析完成后，完成牵引位置直到缓冲器的末端，标记为加工（线号35和43）。 </p><p> The actual data processing takes place in the static class  LineParser in the  ParseLine method, after omitting the header row of csv file it tries to capture the each field data value by finding the  &#34;,&#34; position , and then try to extract string value with UTF8 Encoding using  index offsets and ranges pattern. Each field is processed one by one and it is tracked by  fieldCount variable.</p><p>实际数据处理在Parstine方法中的静态类LineParser中进行，在省略CSV文件的标题行之后，它尝试通过查找＆＃34来捕获每个字段数据值;，＆＃34;位置，然后尝试使用索引偏移和范围模式使用UTF8编码提取字符串值。每个字段一个接一个地处理，并且由FieldCount变量跟踪。</p><p>   Creating an ArrayPool of  Employee type .  ArrayPool&lt;T&gt; is a high performance pool of managed arrays. It is a thread safe pool with custom max length.</p><p>   创建员工类型的ArrayPool。 Arraypool＆lt; t＆gt;是一个高性能的托管阵列。它是一个带有自定义最大长度的线程安全池。</p><p> Next thing is to call the  Rent method which requires you to specify minimum length of the buffer. Keep in mind, that what  Rent returns might be bigger than what you have asked for.</p><p> 接下来的事情是调用租金方法，该方法要求您指定缓冲区的最小长度。请记住，租金返回可能比您所要求的更大。</p><p> Once you are done using it, you just  Return it to the  SAME pool.  Return method has an overload, which allows you to cleanup the buffer so subsequent consumer via  Rent will not see the previous consumer’s content. By default the contents are left unchanged.</p><p> 一旦使用它，您只需将其返回到同一个池中。返回方法具有过载，允许您清理缓冲区，因此通过租金后续消费者不会看到以前的消费者的内容。默认情况下，内容不变。</p><p>  table { border-collapse: collapse; display: block; width: 100%; overflow: auto; }	td, th { padding: 6px 13px; border: 1px solid #ddd; text-align: right; }	tr { background-color: #fff; border-top: 1px solid #ccc; }	tr:nth-child(even) { background: #f8f8f8; } BenchmarkDotNet=v0.13.0, OS=macOS Big Sur 11.4 (20F71) [Darwin 20.5.0]Intel Core i9-9880H CPU 2.30GHz, 1 CPU, 16 logical and 8 physical cores.NET SDK=5.0.203 [Host] : .NET 5.0.6 (5.0.621.22011), X64 RyuJIT DefaultJob : .NET 5.0.6 (5.0.621.22011), X64 RyuJIT</p><p>  表{边界崩溃：崩溃;显示：块;宽度：100％;溢出：自动; TD，TH {填充：6px 13px;边框：1px solid #ddd;文字对齐：右; } tr {背景 - 颜色：#fff;边界 - 顶部：1px solid #ccc; } TR：nth-​​child（偶数）{背景：＃f8f8f8; } BenchmarkDotnet = V0.13.0，OS = MacOS Big Sur 11.4（20F71）[达尔文20.5.0]英特尔酷睿I9-9880H CPU 2.30GHz，1 CPU，16逻辑和8物理核心网= 5.0.203 [主机] ：.Net 5.0.6（5.0.621.22011），x64 ryujit defaultjob：.Net 5.0.6（5.0.621.22011），x64 ryujit</p><p>   As from the result above PipeLines method is clear winner which just took 143.1 milliseconds to process the data and with just 44 MB of memory allocation</p><p>   由于来自上述Pipelines方法，方法是清晰的赢家，它刚刚拍摄了143.1毫秒来处理数据，只需44 MB的内存分配 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://goldytech.wordpress.com/2021/05/31/performance-booster-with-system-io-pipelines-in-c/">https://goldytech.wordpress.com/2021/05/31/performance-booster-with-system-io-pipelines-in-c/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/booster/">#booster</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>