<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#函数</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#函数</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021389.html">使用Zygote-Train XOR开始使用Julia中的自动微分</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/sorta-sota/learning-xor-with-julia-and-zygote-16003f171ae0">Getting started with automatic differentiation in Julia with Zygote – train XOR</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-8-31 15:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021389.html"><img src="http://img.diglog.com/img/2020/8/thumb_f212400c15f73748b906d1115946a14e.gif" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">嗨。这是一个关于构建一个非常简单的多层感知器来近似异或函数的教程，对于它的朋友来说称为XOR函数。这也可能是您对Julia编程语言的介绍，并且代表了我使用该语言的一些早期实验。Julia是为科学计算而开发的，多亏了即时编译，表面上看，它是一种速度更快的Python。该语言的一个有趣特性是，当您看到神经网络中密集层的数......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/automatic/">#automatic</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021267.html">生成漂亮的调用图，第二部分</a></div><div class="item_title_en"><a target="_blank" href="https://yurichev.com/news/20200823_callgraphs2/">Generating nice callgraphs, part II</a><span>(yurichev.com)</span></div><span class="my_story_list_date">2020-8-30 16:49</span><div class="my_story_list_item_desc">通常，您在IDA中看到一个函数，并想知道它能做什么？什么可以执行？但你只能看到它的身体。
这个脚本与以前的不同，它将从当前函数开始绘制调用图，递归深入，直到某个限制，因为整个调用图可能很大，很难导航。
例如，Linux内核中的vsnprintf()函数：kernel_vsnprintf.png。现在你可以谈谈这件事了......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/调用/">#调用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nice/">#nice</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021258.html">Matlot++-C++绘图工具</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/alandefreitas/matplotplusplus">Matplot++ – A Plotting Tool for C++</a><span>(github.com)</span></div><span class="my_story_list_date">2020-8-30 13:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021258.html"><img src="http://img.diglog.com/img/2020/8/thumb_3d7c565fa04f0e3b74ad8b390cf3bca3.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">数据可视化可以帮助程序员和科学家识别他们数据中的趋势，并有效地将这些结果与他们的同行交流。现代C++正被用于各种科学应用程序，该环境可以从满足科学数据可视化典型设计目标的图形库中获益良多。除了将结果导出到其他环境的选项外，C++中常用的替代方案要么是依赖于现有用户界面的非专用库，要么是绑定到其他语言。Matlot++......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/plotting/">#plotting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021163.html">短函数是一种气味--函数长度科学综述</a></div><div class="item_title_en"><a target="_blank" href="https://softwarebyscience.com/very-short-functions-are-a-code-smell-an-overview-of-the-science-on-function-length/">Short functions are a smell – an overview of the science on function length</a><span>(softwarebyscience.com)</span></div><span class="my_story_list_date">2020-8-30 0:38</span><div class="my_story_list_item_desc">这是我从科学角度研究编程概念的博客系列的第一部分。在这一部分中，我挖掘了我能找到的与函数长度有关的每一项研究，填补了一些原始研究的空白，并检验了我们可以学到的东西。
2000年后似乎没有专门关注函数长度的研究，但是通过最初的研究，我们发现现代代码库表现出类似的行为。
我们还发现，在实证实验中，短函数会使代码调试速度变......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/functions/">#functions</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/研究/">#研究</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018964.html">哈斯克尔迷你图案手册</a></div><div class="item_title_en"><a target="_blank" href="https://kowainik.github.io/posts/haskell-mini-patterns">Haskell Mini-Patterns Handbook</a><span>(kowainik.github.io)</span></div><span class="my_story_list_date">2020-8-19 2:49</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1018964.html"><img src="http://img.diglog.com/img/2020/8/thumb_7aa7350e7964a3de12bc7988c038a9dd.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">尽管Haskell是一种强大的语言，可以帮助实现健壮和可维护的程序，但在Haskell可能性的海洋中导航是具有挑战性的。该语言为您提供了大量令人惊叹的方法，但要了解如何以及在哪里正确使用它们并不总是微不足道的。
幸运的是，与任何其他主流编程语言一样，Haskell也有其生成高质量代码的最佳实践和推荐方法。了解Hask......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/图案/">#图案</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mini/">#mini</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018838.html">新的7级散列函数：Prvhash</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/avaneev/prvhash">New Level 7 Hash Function: Prvhash</a><span>(github.com)</span></div><span class="my_story_list_date">2020-8-18 14:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1018838.html"><img src="http://img.diglog.com/img/2020/8/thumb_1e17a42d3aea60901c99a8b81432bec4.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">PRVHASH是生成从消息导出的伪随机数序列的散列函数。产生的散列非常接近于位频率的正态分布。PRVHASH在概念上类似于Keccak方案，但完全不同于该概念的实现。
PRVHASH可以生成32位到无限位的散列，从而产生与所选散列长度无关的粗略质量的散列。PRVHASH基于64位数学运算。超过256位的散列仍然需要广......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hash/">#hash</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/散列/">#散列</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018802.html">如何掷半个骰子</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@tglaiel/how-to-roll-half-a-dice-21631c1fe694">How to Roll Half a Dice</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-8-18 9:12</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1018802.html"><img src="http://img.diglog.com/img/2020/8/thumb_91e83c9116961df7280a0330b2e9964e.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">假设您正在设计一个游戏，为了确定一个动作的成功，您要掷骰子20(20个面的骰子)。即使您正在制作一款没有骰子的数字游戏，这也是一个将概率与上下文关联起来的有用工具。我们中的大多数人以前都掷过骰子，所以我们大多数人都直观地知道这种随机的机会是什么感觉。
现在假设您想让一个角色“幸运”。不是滚动一个d20，而是滚动两个d......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/骰子/">#骰子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/roll/">#roll</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018782.html">λ演算的一种电路表示法</a></div><div class="item_title_en"><a target="_blank" href="https://csvoss.com/circuit-notation-lambda-calculus">A circuit-like notation for lambda calculus</a><span>(csvoss.com)</span></div><span class="my_story_list_date">2020-8-18 7:26</span><div class="my_story_list_item_desc">最近，我一直在为λ演算发明一个可视化的书写系统。
兰姆达演算(λ演算)是一种原始函数式编程，最初是由阿隆佐·丘奇发明的，当时他正试图解决导致图灵发明图灵机的相同问题。这是关于计算的另一种推理方式。
Python的λ是从λ演算中借用的一个想法。在Python中，您可以使用如下所示的lambda表达式来定义返回数字平方的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/电路/">#电路</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notation/">#notation</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018544.html">不带浏览器的WebAssembly第1部分</a></div><div class="item_title_en"><a target="_blank" href="https://alexene.dev/2020/08/17/webassembly-without-the-browser-part-1.html">WebAssembly without the browser part 1</a><span>(alexene.dev)</span></div><span class="my_story_list_date">2020-8-17 3:58</span><div class="my_story_list_item_desc">大多数WebAssembly在线教程和示例都侧重于在浏览器中使用它，以加速网站或Web应用程序的各种功能。但是，有一个领域的WebAssembly功能非常强大，但没有太多讨论：浏览器场景之外的领域。这就是我们将在这一系列帖子中关注的。
网络人经常给事物带来恶名(web-GPU就是另一个例子)。WebAssembly既......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/browser/">#browser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018399.html">BQN：Marshall Lochbaum的APL变体</a></div><div class="item_title_en"><a target="_blank" href="https://mlochbaum.github.io/BQN/">BQN: An APL Variant from Marshall Lochbaum</a><span>(mlochbaum.github.io)</span></div><span class="my_story_list_date">2020-8-16 5:8</span><div class="my_story_list_item_desc">在这里试试吧！在线版目前主要适用于小程序；更多选项请参见running.md。
BQN是APL血统中的一种新的编程语言，旨在消除APL传统中不一致和繁琐的方面，并将伟大的思想建立在更坚实的基础上。BQN面向现有的和有抱负的APL系列程序员，使用它需要对函数和多维数组有扎实的理解。但是，由于BQN侧重于提供简单、一致和......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/marshall/">#marshall</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apl/">#apl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017345.html">绘制逼真的图形</a></div><div class="item_title_en"><a target="_blank" href="https://statmodeling.stat.columbia.edu/2005/12/26/making_realisti/">Sketching Realistic Graphs</a><span>(statmodeling.stat.columbia.edu)</span></div><span class="my_story_list_date">2020-8-10 22:50</span><div class="my_story_list_item_desc">前几天我试着画伯特和厄尼，真的很难。我旁边就有他们的照片，但我的画简直令人难以置信地粗糙，更多的是“语言”而不是“视觉”，因为我描绘的是伯特和厄尼的关键方面，但照片看起来一点也不像他们。我知道画画很难-偶尔，我会坐一个小时画一个场景，要让它看起来像我看到的东西总是要做很多工作-但我没有意识到画卡通人物会这么难！
这让......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/逼真/">#逼真</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/realistic/">#realistic</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017292.html">运行中的Codata，或者如何连接FP和OOP</a></div><div class="item_title_en"><a target="_blank" href="https://www.javiercasas.com/articles/codata-in-action/">Codata in action, or how to connect FP and OOP</a><span>(www.javiercasas.com)</span></div><span class="my_story_list_date">2020-8-10 13:38</span><div class="my_story_list_item_desc">我的朋友Juan Paucar向我介绍了第28届欧洲编程研讨会(ESOP 2019)中与Codata相关的一篇论文。我对codata非常感兴趣，主要是因为它以一种范畴论的方式与数据相关，但是，像往常一样，我并不理解其中的许多单词。这篇论文帮助我理解了很多，也帮助我理解和塑造了如何连接FP和OOP世界的想法。但是，在此......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/连接/">#连接</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/action/">#action</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017121.html">一个用纸制作3D几何形状的网站</a></div><div class="item_title_en"><a target="_blank" href="https://felixboiii.github.io/paper-plotter/">A website to make 3D geometry shapes out of paper</a><span>(felixboiii.github.io)</span></div><span class="my_story_list_date">2020-8-9 12:12</span><div class="my_story_list_item_desc">在这张画布上，您可以看到函数将是什么样子。您可以调整变量以获得所需的结果。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/用纸/">#用纸</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shapes/">#shapes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016363.html">去功能化与弗莱德定理</a></div><div class="item_title_en"><a target="_blank" href="https://bartoszmilewski.com/2020/08/03/defunctionalization-and-freyds-theorem/">Defunctionalization and Freyd’s Theorem</a><span>(bartoszmilewski.com)</span></div><span class="my_story_list_date">2020-8-5 17:27</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1016363.html"><img src="http://img.diglog.com/img/2020/8/thumb_0afc9342391b9d827689e5397b6df638.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">函数式编程的主要思想是像对待任何其他数据类型一样对待函数。特别是，我们希望能够将函数作为参数传递给其他函数，将它们作为值返回，并将它们存储在数据结构中。但是函数是哪种数据类型呢？它是一种类型，当与另一段称为参数的数据配对时，可以将其传递给名为Apply的函数以产生结果。
在实践中，函数应用隐含在语言的语法中。但是，正......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/功能化/">#功能化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/freyd/">#freyd</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016165.html">逐步改进DOM</a></div><div class="item_title_en"><a target="_blank" href="https://blog.functorial.com/posts/2018-04-08-Incrementally-Improving-The-DOM.html">Incrementally Improving the DOM</a><span>(blog.functorial.com)</span></div><span class="my_story_list_date">2020-8-4 22:58</span><div class="my_story_list_item_desc">上一次，我试图说服您，您可能不需要虚拟DOM，并且许多常见的UI模式可以用完全静态的页面重现，更改只发生在树属性和文本节点的叶子上。对于一些更复杂的UI模式，我重新添加了有限形式的动态行为，允许元素具有动态的子列表。
这可能并不令人惊讶，因为在Reaction普及虚拟DOM(使用Mustache模板之类的东西)之前，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/改进/">#改进</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/improving/">#improving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015807.html">哈斯克尔与里斯普的哲学差异</a></div><div class="item_title_en"><a target="_blank" href="https://chrisdone.com/posts/haskell-lisp-philosophy-difference/">A philosophical difference between Haskell and Lisp</a><span>(chrisdone.com)</span></div><span class="my_story_list_date">2020-8-3 4:43</span><div class="my_story_list_item_desc">Lisp(例如Common Lisp、Emacs Lisp)和Haskell的哲学上的一个不同之处在于，后者自由地使用许多完成单个任务的微小函数。这就是所谓的可组合性，或UNIX哲学。在Lisp中，过程倾向于接受配置其行为的许多选项。这被称为整体主义，或者像厨房水槽或瑞士军刀那样的程序。
哪一个更好，可以在另一个帖子......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/哲学/">#哲学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014237.html">深度JavaScript章节：环境和闭包如何在JavaScript中工作？</a></div><div class="item_title_en"><a target="_blank" href="https://exploringjs.com/deep-js/ch_environments.html">Deep JavaScript chapter: How do environments and closures work in JavaScript?</a><span>(exploringjs.com)</span></div><span class="my_story_list_date">2020-7-26 16:17</span><div class="my_story_list_item_desc">在本章中，我们将进一步了解ECMAScript语言规范是如何处理变量的。
环境是ECMAScript规范用来管理变量的数据结构。它是一个字典，其键是变量名，值是这些变量的值。每个作用域都有其关联的环境。环境必须能够支持以下与变量相关的现象：
函数f(X){return x*2；}函数g(Y){const tmp=y+......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013305.html">探究为什么Python不需要“main”函数</a></div><div class="item_title_en"><a target="_blank" href="https://utcc.utoronto.ca/~cks/space/blog/python/WhyNoMainFunction">An exploration of why Python doesn't require a 'main' function</a><span>(utcc.utoronto.ca)</span></div><span class="my_story_list_date">2020-7-22 0:9</span><div class="my_story_list_item_desc">许多语言通过调用必须具有特定名称的函数来开始运行您的程序。在C语言(以及许多C派生语言)中，这只称为main()；在Go中，它是它的main.main()(主包中的main()函数)。众所周知，Python不需要任何这样的函数，即使您创建了一个名为main()的函数，它也不会自动调用。最近我读到“为什么Python没......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/main/">#main</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012929.html">数组函数与最小功率法则</a></div><div class="item_title_en"><a target="_blank" href="https://jesseduffield.com/array-functions-and-the-rule-of-least-power/">Array Functions and the Rule of Least Power</a><span>(jesseduffield.com)</span></div><span class="my_story_list_date">2020-7-20 4:5</span><div class="my_story_list_item_desc">1998年，万维网的发明者蒂姆·伯纳斯·李(Tim Berners-Lee)提出了最小功耗原则：
计算机科学在20世纪60年代到80年代花费了大量的精力来制造尽可能强大的语言。如今，我们必须意识到选择最有力的解决方案而不是最弱的解决方案的原因。
在语言的计算能力和确定该语言中的程序正在做什么的能力之间有一个重要的权衡......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/数组/">#数组</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/functions/">#functions</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009168.html">15分钟后学习Lua</a></div><div class="item_title_en"><a target="_blank" href="http://tylerneylon.com/a/learn-lua/">Learn Lua in 15 Minutes</a><span>(tylerneylon.com)</span></div><span class="my_story_list_date">2020-7-1 6:6</span><div class="my_story_list_item_desc">--两个破折号开始一行注释。--[[添加两个和]&#39；s使其成为多行comment.--]]--1.变量和流control.。-num=42--所有数字都是双精度的。--Don&#39；t惊慌失措，64位双精度数有52位用于--存储精确的int值；机器精度--对于需要&lt；52位的整数来说不是问题。s=&#39......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learn/">#learn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008773.html">实现指数函数</a></div><div class="item_title_en"><a target="_blank" href="https://www.pseudorandom.com/implementing-exp">Implementing the Exponential Function</a><span>(www.pseudorandom.com)</span></div><span class="my_story_list_date">2020-6-29 4:5</span><div class="my_story_list_item_desc">我探索了实现指数函数$f(X)=e^x$的几种复杂的逼近技术，包括泰勒级数逼近、拉格朗日插值、切比雪夫插值、Carathéodory-Fejer逼近和MinimMax逼近。这也是对使用这些方法来近似其他函数的更一般的介绍。在此过程中，我详细介绍了每种方法的相关理论，并应用数值分析方法对各种形式的误差进行了导航。我还以......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008208.html">Logistic回归从头开始</a></div><div class="item_title_en"><a target="_blank" href="https://philippmuens.com/logistic-regression-from-scratch/">Logistic Regression from the Ground Up</a><span>(philippmuens.com)</span></div><span class="my_story_list_date">2020-6-25 23:27</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1008208.html"><img src="http://img.diglog.com/img/2020/6/thumb_702786ea2e3cc8793adf6f331fcd8768.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">您可以在我的GitHub上的实验室存储库中找到工作代码示例(包括这个示例)。
有时，为了预测新的、看不见的数据，有必要将现有数据分成几类。这个问题叫做分类，可以用来从数据中学习这些类的算法之一叫做Logistic回归。
在本文中，我们将深入研究Logistic回归模型，以了解它与其他回归模型(如线性回归或多元线性回归......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/回归/">#回归</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007967.html">Rust函数式语言特点</a></div><div class="item_title_en"><a target="_blank" href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">Rust Functional Language Features</a><span>(doc.rust-lang.org)</span></div><span class="my_story_list_date">2020-6-24 22:48</span><div class="my_story_list_item_desc">Rust的设计灵感来自许多现有的语言和技术，其中一个重要的影响是函数式编程。函数式编程通常包括使用函数作为值，在参数中绕过它们，从其他函数返回函数，将它们赋给变量以供以后执行，等等。
在本章中，我们不会讨论什么是函数式编程或什么不是函数式编程的问题，而是讨论Rust的一些特性，这些特性类似于许多语言中通常称为函数式的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007033.html">逆向工程Snapchat：混淆技术</a></div><div class="item_title_en"><a target="_blank" href="https://hot3eed.github.io/snap_part1_obfuscations.html">Reverse Engineering Snapchat: Obfuscation Techniques</a><span>(hot3eed.github.io)</span></div><span class="my_story_list_date">2020-6-18 7:53</span><div class="my_story_list_item_desc">当你每天有2亿以上的用户时，你肯定想让你的API不让垃圾邮件制造者和公司知道，所以你必须在授权它对你的服务器进行API调用的二进制文件中保守一个秘密。Snapchat(10.81.6.81版)通过在每个请求中包括X-Snapchat-Client-Auth-Token标头来实现此目的，典型的请求如下所示：
忘了对这个......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/逆向工程/">#逆向工程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/工程/">#工程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006807.html">NETGEAR 79台设备的0天漏洞分析和利用</a></div><div class="item_title_en"><a target="_blank" href="https://blog.grimm-co.com/2020/06/soho-device-exploitation.html?m=1">Netgear 0-day Vulnerability Analysis and Exploit for 79 devices</a><span>(blog.grimm-co.com)</span></div><span class="my_story_list_date">2020-6-16 21:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006807.html"><img src="http://img.diglog.com/img/2020/6/thumb_f6ca0df7d33dfed07f101223c77772b0.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">NETGEAR R7000经过一天的辛勤研究，放松、放松、轻松地做一些事情，这是一件很有趣的事情。虽然与10-15年前相比，现代软件开发流程极大地提高了商业软件的质量，但消费者网络设备在很大程度上被甩在了后面。因此，当需要一些快速乐趣和良好的信心提升时，我喜欢分析SOHO设备。本博客描述了一个这样的会话，即审核Net......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/day/">#day</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006392.html">数学即代码</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Jam3/math-as-code">Math-as-Code</a><span>(github.com)</span></div><span class="my_story_list_date">2020-6-13 16:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006392.html"><img src="http://img.diglog.com/img/2020/6/thumb_b381ca50d413d7197716cf96ffb37849.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这是一个参考，通过显示与JavaScript代码的比较，使开发人员更容易进入数学表示法。
本指南尚未完成。如果您看到错误或想要贡献，请开票或发送公关。
注意：为简洁起见，一些代码示例使用了NPM包。您可以参考他们的GitHub Repos以了解实现的详细信息。
根据作者、上下文和研究领域(线性代数、集合论等)的不同，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数学/">#数学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/math/">#math</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006180.html">康托函数，又名。魔鬼阶梯：0导数的递增函数</a></div><div class="item_title_en"><a target="_blank" href="https://en.wikipedia.org/wiki/Cantor_function">Cantor function, a.k.a. devil's staircase: increasing function with 0 derivative</a><span>(en.wikipedia.org)</span></div><span class="my_story_list_date">2020-6-12 3:13</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006180.html"><img src="http://img.diglog.com/img/2020/6/thumb_60479f280f4e30f392f772f18206e7f1.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">跳转到导航跳转在数学中搜索，康托函数是一个连续的函数，但不是绝对连续的。这在分析中是一个臭名昭著的反例，因为它挑战了关于连续性、导数和测度的天真直觉。虽然它处处是连续的，几乎处处都有零导数，但当它的自变量从0到1时，它的值仍然从0到1。因此，从某种意义上说，该函数看起来非常像一个常数，不能增长，而在另一种意义上，它确......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/function/">#function</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006042.html">静态分析</a></div><div class="item_title_en"><a target="_blank" href="https://nim-lang.org/blog/2020/06/08/static-analysis.html">Static Analysis</a><span>(nim-lang.org)</span></div><span class="my_story_list_date">2020-6-11 2:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006042.html"><img src="http://img.diglog.com/img/2020/6/thumb_a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">什么是静态分析(SA)？好的，静态意味着“非动态”，即不在运行时或在运行期间。静态分析是在软件开发的上下文中在编译时或接近编译时完成的事情。但静态分析只是形式链的一部分，除了列车控制系统等关键系统外，通常不会充分利用它。
完整的形式化链条从形式化规范开始，形式化需求评估是形式化规范的一个重要前提，这一部分涉及的问题是......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/静态/">#静态</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/static/">#static</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004032.html">“麦克斯韦软件方程式”考查(2008)</a></div><div class="item_title_en"><a target="_blank" href="http://www.righto.com/2008/07/maxwells-equations-of-software-examined.html">“Maxwell's equations of software” examined (2008)</a><span>(www.righto.com)</span></div><span class="my_story_list_date">2020-5-28 13:1</span><div class="my_story_list_item_desc">最近的一篇帖子引用了艾伦·凯(Alan Kay)的一句话，即表达Lisp本身就是麦克斯韦的软件方程式：是的，这是我在研究生院时得到的一个重大启示--当时我终于明白，Lisp1.5手册第13页底部的半页代码本身就是Lisp。这就是“麦克斯韦软件方程式！”
这句话出现在网络上的许多地方，但代码本身更难找到。这令人惊叹的半......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方程式/">#方程式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/equations/">#equations</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002878.html">其他语言中的错误抽象示例</a></div><div class="item_title_en"><a target="_blank" href="https://www.reddit.com/r/haskell/comments/glz389/examples_of_incorrect_abstractions_in_other/">Examples of Incorrect Abstractions in Other Languages</a><span>(www.reddit.com)</span></div><span class="my_story_list_date">2020-5-20 5:19</span><div class="my_story_list_item_desc">你有没有其他语言或语言特性的库的例子，它们真的应该实现一个众所周知的概念(Monoid、Monad、Alternative等等)，但它们没有实现，因为它们(可能)不知道这个概念？例如违反法律、缺少函数、过于复杂的函数类型等。
我遇到过很多这样的例子，他们总是折磨我。但无论如何，我现在什么都想不起来了。
级别1，因为即......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/抽象/">#抽象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/incorrect/">#incorrect</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/函数/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/函数/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/函数/page2.html">2</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>