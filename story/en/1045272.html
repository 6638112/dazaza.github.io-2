<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go中的命令路径安全 Command Path Security in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Command Path Security in Go<br/>Go中的命令路径安全 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-20 11:20:42</div><div class="page_narrow text-break page_content"><p>Today’s  Go security releasefixes an issue involving PATH lookups in untrusted directoriesthat can lead to remote execution during the  go  get command.We expect people to have questions about what exactly this meansand whether they might have issues in their own programs.This post details the bug, the fixes we have applied,how to decide whether your own programs are vulnerable to similar problems,and what you can do if they are.</p><p>今天的Go安全性发行版修复了涉及在不受信任的目录中进行PATH查找的问题，该问题可能导致在go get命令期间远程执行。我们希望人们对这究竟意味着什么以及他们自己的程序中是否可能存在问题有疑问。我们已应用的修复程序，如何确定您自己的程序是否容易遭受类似问题的影响，以及解决该问题的方法。</p><p>    One of the design goals for the  go command is that most commands – including go  build,  go  doc,  go  get,  go  install, and  go  list – do not runarbitrary code downloaded from the internet.There are a few obvious exceptions:clearly  go  run,  go  test, and  go  generate  do run arbitrary code – that&#39;s their job.But the others must not, for a variety of reasons including reproducible builds and security.So when  go  get can be tricked into executing arbitrary code, we consider that a security bug.</p><p>    go命令的设计目标之一是大多数命令-包括go build，go doc，go get，go install和go list-不要从互联网上下载任意代码。有几个明显的例外： ，执行测试和执行生成操作会运行任意代码–这是他们的工作。但是出于各种原因（包括可复制的内部版本和安全性），其他代码都不能执行。因此，当可以使用get get诱骗执行任意代码时，我们认为这是一个安全漏洞。</p><p> If  go  get must not run arbitrary code, then unfortunately that meansall the programs it invokes, such as compilers and version control systems, are also inside the security perimeter.For example, we&#39;ve had issues in the past in which clever use of obscure compiler featuresor remote execution bugs in version control systems became remote execution bugs in Go.(On that note, Go 1.16 aims to improve the situation by introducing a GOVCS settingthat allows configuration of exactly which version control systems are allowed and when.)</p><p> 如果go get一定不能运行任意代码，那么不幸的是，这意味着它调用的所有程序（例如编译器和版本控制系统）也都在安全范围内。例如，过去，我们曾遇到过巧妙使用问题版本控制系统中晦涩的编译器功能或远程执行错误变成了Go中的远程执行错误。（请注意，Go 1.16旨在通过引入GOVCS设置来改善这种情况，该设置允许准确配置允许哪个版本控制系统以及何时使用。）</p><p> Today&#39;s bug, however, was entirely our fault, not a bug or obscure feature of  gcc or  git.The bug involves how Go and other programs find other executables,so we need to spend a little time looking at that before we can get to the details.</p><p> 但是，今天的错误完全是我们的错，而不是gcc或git的错误或晦涩的功能。该错误涉及Go和其他程序如何查找其他可执行文件，因此我们需要花一点时间来研究一下可以了解详细信息。</p><p>    All operating systems have a concept of an executable path( $PATH on Unix,  %PATH% on Windows; for simplicity, we&#39;ll just use the term PATH),which is a list of directories.When you type a command into a shell prompt,the shell looks in each of the listed directories,in turn, for an executable with the name you typed.It runs the first one it finds, or it prints a message like “command not found.”</p><p>    所有操作系统都具有可执行路径的概念（在Unix上为$ PATH，在Windows上为％PATH％；为简单起见，我们仅使用术语PATH），它是目录的列表。一个shell提示符，shell在列出的每个目录中依次查找以您键入的名称的可执行文件。它将运行找到的第一个可执行文件，或者显示诸如“找不到命令”之类的消息。</p><p> On Unix, this idea first appeared in Seventh Edition Unix&#39;s Bourne shell (1979). The manual explained:</p><p> 在Unix上，这个想法首先出现在第七版Unix的Bourne shell（1979）中。手册说明：</p><p> The shell parameter  $PATH defines the search path for the directory containing the command.Each alternative directory name is separated by a colon ( :).The default path is  :/bin:/usr/bin.If the command name contains a / then the search path is not used.Otherwise, each directory in the path is searched for an executable file.</p><p> shell参数$ PATH定义了包含命令的目录的搜索路径，每个替代目录名都用冒号（:)分隔，默认路径是：/ bin：/ usr / bin，如果命令名包含/，则不使用搜索路径。否则，在路径中的每个目录中搜索可执行文件。 </p><p> Note the default: the current directory (denoted here by an empty string,but let&#39;s call it “dot”)is listed ahead of  /bin and  /usr/bin.MS-DOS and then Windows chose to hard-code that behavior:on those systems, dot is always searched first,automatically, before considering any directories listed in  %PATH%.</p><p>请注意默认值：当前目录（此处用空字符串表示，但我们称其为“点”）在/ bin和/ usr / bin之前列出。MS-DOS，然后Windows选择了硬编码这样的行为：在那些系统上，始终先自动搜索点，然后再考虑％PATH％中列出的任何目录。</p><p> As Grampp and Morris pointed out in theirclassic paper “ UNIX Operating System Security” (1984),placing dot ahead of system directories in the PATHmeans that if you  cd into a directory and run  ls,you might get a malicious copy from that directoryinstead of the system utility.And if you can trick a system administrator to run  ls in your home directorywhile logged in as  root, then you can run any code you want.Because of this problem and others like it,essentially all modern Unix distributions set a new user&#39;s default PATHto exclude dot.But Windows systems continue to search dot first, no matter what PATH says.</p><p> 正如Grampp和Morris在其经典论文“ UNIX操作系统安全性”（UNIX Operating System，1984）中指出的那样，在PATH中的系统目录之前放置点是指，如果您将CD插入目录并运行ls，则可能会从该目录中获得恶意副本，而不是从目录中获取恶意副本。如果您可以欺骗系统管理员以root用户身份在主目录中运行ls，那么您可以运行所需的任何代码。由于这个问题以及类似的问题，基本上所有现代Unix发行版都设置了一个新用户＆ ＃39;默认的PATH排除点。但是，无论PATH怎么说，Windows系统都会继续首先搜索点。</p><p>   on a typically-configured Unix,the shell runs a  go executable from a system directory in your PATH.But when you type that command on Windows, cmd.exe checks dot first.If  .\go.exe (or  .\go.bat or many other choices) exists, cmd.exe runs that executable, not one from your PATH.</p><p>   在通常配置的Unix上，shell在PATH的系统目录中运行go可执行文件。但是在Windows上键入该命令时，cmd.exe首先检查点。如果是。\ go.exe（或。\ go.bat或许多其他选择）存在，cmd.exe运行该可执行文件，而不是您的PATH中的一个。</p><p> For Go, PATH searches are handled by   exec.LookPath,called automatically by  exec.Command.And to fit well into the host system, Go&#39;s  exec.LookPathimplements the Unix rules on Unix and the Windows rules on Windows.For example, this command</p><p> 对于Go来说，PATH搜索由exec.LookPath处理，然后由exec.Command自动调用。为了更好地适应宿主系统，Go的exec.LookPath实现了Unix上的Unix规则和Windows上的Windows规则。 ，此命令</p><p>  behaves the same as typing  go  version into the operating system shell.On Windows, it runs  .\go.exe when that exists.</p><p>  行为与在操作系统外壳中键入go version相同。在Windows上，如果存在则运行。\ go.exe。</p><p> (It is worth noting that Windows PowerShell changed this behavior,dropping the implicit search of dot, but  cmd.exe and theWindows C library   SearchPath functioncontinue to behave as they always have.Go continues to match  cmd.exe.)</p><p> （值得注意的是，Windows PowerShell更改了此行为，删除了隐式的点搜索，但cmd.exe和Windows C库的SearchPath函数继续像往常一样运行。Go继续匹配cmd.exe。）</p><p>    When  go  get downloads and builds a package that contains import  &#34;C&#34;, it runs a program called  cgo to prepare the Goequivalent of the relevant C code.The  go command runs  cgo in the directory containing the package sources.Once  cgo has generated its Go output files,the  go command itself invokes the Go compileron the generated Go filesand the host C compiler ( gcc or  clang)to build any C sources included with the package.All this works well.But where does the  go command find the host C compiler?It looks in the PATH, of course. Luckily, while it runs the C compilerin the package source directory, it does the PATH lookupfrom the original directory where the  go command was invoked:</p><p>    当go get下载并构建包含import＆＃34; C＆＃34;的软件包时，它将运行一个名为cgo的程序来准备相关C代码的Goequivalent.go命令在包含软件包源代码的目录中运行cgo。 cgo已经生成了Go输出文件，go命令本身会在生成的Go文件和宿主C编译器（gcc或clang）上调用Go编译器以构建软件包中包含的所有C源代码。所有这些都很好用。找到主机C编译器？它当然在PATH中。幸运的是，当它在包源目录中运行C编译器时，它将从调用go命令的原始目录中进行PATH查找： </p><p>  So even if  badpkg\gcc.exe exists on a Windows system,this code snippet will not find it.The lookup that happens in  exec.Command does not knowabout the  badpkg directory.</p><p>因此，即使Windows系统上存在badpkg \ gcc.exe，该代码段也将找不到它。exec.Command中发生的查找并不知道badpkg目录。</p><p> The  go command uses similar code to invoke  cgo,and in that case there&#39;s not even a path lookup,because  cgo always comes from GOROOT:</p><p> go命令使用类似的代码来调用cgo，在这种情况下，甚至没有路径查找，因为cgo始终来自GOROOT：</p><p>  This is even safer than the previous snippet:there&#39;s no chance of running any bad  cgo.exe that may exist.</p><p>  这比以前的代码段更安全：没有机会运行可能存在的任何错误的cgo.exe。</p><p> But it turns out that cgo itself also invokes the host C compiler,on some temporary files it creates, meaning it executes this code itself:</p><p> 但是事实证明，cgo本身还会在它创建的某些临时文件上调用宿主C编译器，这意味着它自己执行以下代码：</p><p>  Now, because cgo itself is running in  badpkg,not in the directory where the  go command was run,it will run  badpkg\gcc.exe if that file exists,instead of finding the system  gcc.</p><p>  现在，由于cgo本身在badpkg中运行，而不是在运行go命令的目录中运行，因此如果该文件存在，它将运行badpkg \ gcc.exe，而不是查找系统gcc。</p><p> So an attacker can create a malicious package that uses cgo andincludes a  gcc.exe, and then any Windows userthat runs  go  get to download and build the attacker&#39;s packagewill run the attacker-supplied  gcc.exe in preference to any gcc in the system path.</p><p> 因此，攻击者可以创建一个使用cgo并包含gcc.exe的恶意程序包，然后所有运行Windows的Windows用户都可以下载并构建攻击者的程序包，该程序将优先于攻击者提供的gcc.exe来运行该程序。系统路径。</p><p> Unix systems avoid the problem first because dot is typically notin the PATH and second because module unpacking does notset execute bits on the files it writes.But Unix users who have dot ahead of system directoriesin their PATH and are using GOPATH mode would be as susceptibleas Windows users.(If that describes you, today is a good day to remove dot from your pathand to start using Go modules.)</p><p> Unix系统首先避免了该问题，因为通常在路径中不包含点，其次是因为模块解压缩未设置其写入文件的执行位。但是，在PATH中在系统目录之前加点并使用GOPATH模式的Unix用户将像Windows一样容易受到感染。用户（如果能描述您的情况，那么今天是从路径中删除点并开始使用Go模块的好日子。） </p><p>     It&#39;s obviously unacceptable for the  go  get command to downloadand run a malicious  gcc.exe.But what&#39;s the actual mistake that allows that?And then what&#39;s the fix?</p><p>使用go get命令下载并运行恶意gcc.exe显然是不可接受的，但是允许这样做的实际错误是什么呢？那么解决方法是什么呢？</p><p> One possible answer is that the mistake is that  cgo does the search for the host C compilerin the untrusted source directory instead of in the directory where the  go commandwas invoked.If that&#39;s the mistake,then the fix is to change the  go command to pass  cgo the full path to thehost C compiler, so that  cgo need not do a PATH lookup into the untrusted directory.</p><p> 一个可能的答案是错误是cgo在不受信任的源目录中而不是在调用go命令的目录中搜索主机C编译器。如果那是错误的，那么解决方法是更改​​go命令将cgo的完整路径传递给主机C编译器，因此cgo无需在不可信目录中进行PATH查找。</p><p> Another possible answer is that the mistake is to look in dotduring PATH lookups, whether happens automatically on Windowsor because of an explicit PATH entry on a Unix system.A user may want to look in dot to find a command they typedin a console or shell window,but it&#39;s unlikely they also want to look there to find a subprocess of a subprocessof a typed command.If that&#39;s the mistake,then the fix is to change the  cgo command not to look in dot during a PATH lookup.</p><p> 另一个可能的答案是错误是在PATH查找过程中查找，无论是在Windows上自动发生还是在Unix系统上由于显式的PATH条目而自动发生。用户可能希望在dot中查找以找到他们在控制台或shell窗口中键入的命令，但不太可能他们也希望在该处查找键入命令的子进程的子进程。如果那是错误的话，则解决方法是更改​​cgo命令，使其在执行过程中不要在点中查找PATH查找。</p><p> We decided both were mistakes, so we applied both fixes.The  go command now passes the full host C compiler path to  cgo.On top of that,  cgo,  go, and every other command in the Go distributionnow use a variant of the  os/exec package that reports an error if it wouldhave previously used an executable from dot.The packages  go/build and  go/import use the same policy fortheir invocation of the  go command and other tools.This should shut the door on any similar security problems that may be lurking.</p><p> 我们确定这两个都是错误，所以我们都应用了这两个修复程序。go命令现在将完整的主机C编译器路径传递给cgo。最重要的是，cgo，go和Go发行版中的所有其他命令现在都使用os /的变体如果exec软件包以前使用过dot的可执行文件，则会报告一个错误。go / build和go / import软件包对go命令和其他工具的调用使用相同的策略，这应该可以避免出现任何类似的安全问题可能会潜伏。</p><p> Out of an abundance of caution, we also made a similar fix incommands like  goimports and  gopls,as well as the libraries golang.org/x/tools/go/analysisand golang.org/x/tools/go/packages,which invoke the  go command as a subprocess.If you run these programs in untrusted directories –for example, if you  git  checkout untrusted repositoriesand  cd into them and then run programs like these,and you use Windows or use Unix with dot in your PATH –then you should update your copies of these commands too.If the only untrusted directories on your computerare the ones in the module cache managed by  go  get,then you only need the new Go release.</p><p> 出于谨慎考虑，我们还对goimports和gopls等命令以及golang.org/x/tools/go/analysis和golang.org/x/tools/go/packages库进行了类似的修复，它们调用了如果您在不受信任的目录中运行这些程序，例如，如果git checkout不受信任的存储库并cd进入它们，然后运行类似的程序，则您使用Windows或在PATH中使用带点的Unix，那么您应该如果您计算机上唯一不受信任的目录是go get管理的模块缓存中的目录，那么您只需要新的Go版本即可。</p><p> After updating to the new Go release, you can update to the latest  gopls by using:</p><p> 更新到新的Go版本之后，您可以使用以下方法更新到最新的gopls：</p><p>    You can update programs that depend on  golang.org/x/tools/go/packages,even before their authors do,by adding an explicit upgrade of the dependency during  go  get:</p><p>    您甚至可以在依赖golang.org/x/tools/go/packages的程序之前更新依赖于golang.org/x/tools/go/packages的程序，方法是在go get期间添加对依赖关系的显式升级： </p><p>  For programs that use  go/build, it is sufficient for you to recompile themusing the updated Go release.</p><p>对于使用go / build的程序，您只需使用更新的Go版本重新编译它们即可。</p><p> Again, you only need to update these other programs if youare a Windows user or a Unix user with dot in the PATH and you run these programs in source directories you do not trustthat may contain malicious programs.</p><p> 同样，仅当您是Windows用户或Unix用户（在PATH中带有点）并且您在不信任的源目录中运行这些程序（可能包含恶意程序）时，才需要更新这些其他程序。</p><p>    If you use  exec.LookPath or  exec.Command in your own programs,you only need to be concerned if you (or your users) run your programin a directory with untrusted contents.If so, then a subprocess could be started using an executablefrom dot instead of from a system directory.(Again, using an executable from dot happens always on Windowsand only with uncommon PATH settings on Unix.)</p><p>    如果您在自己的程序中使用exec.LookPath或exec.Command，则只需要担心您（或您的用户）是否在目录中包含不受信任的内容中运行程序即可;如果是这样，则可以使用dot中的可执行文件来启动子进程。 （同样，在Windows上总是使用dot的可执行文件，而在Unix上只有不常见的PATH设置。）</p><p> If you are concerned, then we&#39;ve published the more restricted variantof  os/exec as   golang.org/x/sys/execabs.You can use it in your program by simply replacing</p><p> 如果您担心的话，我们将更受限制的os / exec变体发布为golang.org/x/sys/execabs。您可以在程序中使用它，只需替换</p><p>        We have been discussing on golang.org/issue/38736whether the Windows behavior of always preferring the current directoryin PATH lookups (during  exec.Command and  exec.LookPath)should be changed.The argument in favor of the change is that it closes the kinds ofsecurity problems discussed in this blog post.A supporting argument is that although the Windows  SearchPath APIand  cmd.exe still always search the current directory,PowerShell, the successor to  cmd.exe, does not,an apparent recognition that the original behavior was a mistake.The argument against the change is that it could break existing Windowsprograms that intend to find programs in the current directory.We don’t know how many such programs exist,but they would get unexplained failures if the PATH lookupsstarted skipping the current directory entirely.</p><p>        我们已经在golang.org/issue/38736上进行了讨论，是否应该更改Windows总是在PATH查找中始终偏爱当前目录的Windows行为（在exec.Command和exec.LookPath期间）。有关此博客文章中讨论的安全性问题。一个支持性的观点是，尽管Windows SearchPath API和cmd.exe始终始终搜索当前目录，但cmd.exe的后继者PowerShell却没有，显然可以看出原始行为是错误的反对此更改的观点是，它可能会破坏打算在当前目录中查找程序的现有Windows程序。我们不知道有多少这样的程序，但是如果PATH查找开始完全跳过当前目录，它们将导致无法解释的故障。</p><p> The approach we have taken in  golang.org/x/sys/execabs maybe a reasonable middle ground.It finds the result of the old PATH lookup and then returns aclear error rather than use a result from the current directory.The error returned from  exec.Command(&#34;prog&#34;) when  prog.exe exists looks like:</p><p> 我们在golang.org/x/sys/execabs中采用的方法可能是合理的中间立场，它会找到旧PATH查找的结果，然后返回明显的错误而不是使用当前目录中的结果.exec返回的错误存在prog.exe时.Command（＆＃34; prog＆＃34;）如下所示：</p><p>  For programs that do change behavior, this error should make very clear what has happened.Programs that intend to run a program from the current directory can use exec.Command(&#34;./prog&#34;) instead (that syntax works on all systems, even Windows).</p><p>  对于确实改变了行为的程序，此错误应该使发生的事情非常清楚。打算从当前目录运行程序的程序可以使用exec.Command（＆＃34; ./ prog＆＃34;）代替（语法有效在所有系统上，甚至Windows）。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.golang.org/path-security">https://blog.golang.org/path-security</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/路径/">#路径</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/path/">#path</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/命令/">#命令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>