<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通过Internet控制旧式电子设备</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">通过Internet控制旧式电子设备</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 01:02:09</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/29596a51f4b18a9b2578b9c998df3deb.png"><img src="http://img2.diglog.com/img/2020/11/29596a51f4b18a9b2578b9c998df3deb.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I’m fascinated by the idea of smart consumer electronics. When it comes to tools I use on a daily ba sis, I’m sort of a control freak and like to utilize them as much as I can, from wherever I can. Unfortunately though, some of these tools are legacy electronics, like my air conditioner, and I simply don’t want to spend money buying a new smart AC because this one just works fine. So for quite some time, I had been wondering if there was a way to smart up my AC in a cost-effective manner. I then realised last week that I had a Raspberry Pi, as well as  Adafruit’s CircuitPlayground Express, which I had got as part of conference swag lying around in my desk drawer. These little beasts were essentially begging to be utilized for some good as I had not played much with them.</p><p>我对智能消费电子产品的想法很着迷。当谈到我在日常生活中使用的工具时，我有点像一个控制狂，喜欢在任何我能用到的地方尽可能多地使用它们。不幸的是，这些工具中有一些是传统的电子产品，比如我的空调，我根本不想花钱买一台新的智能空调，因为这一台工作得很好。因此，很长一段时间以来，我一直在想，是否有一种方法可以让我的空调变得更具成本效益。然后，上周我意识到，我有一辆树莓PI，还有一辆Adafruit的Circuit Playround Express，这是我在办公桌抽屉里作为会议礼品的一部分得到的。这些小野兽本质上是在乞求被利用来做一些好事，因为我没有和它们玩太多。</p><p> I noticed that CircuitPlayground Express had an embedded IR transceiver. While it doesn’t have its own OS and Internet connectivity, I thought I could use it as a substitute for my AC remote in some way. Soon I also realised that the Internet connectivity void could be filled by the Raspberry Pi! Next thing I knew, I was scouring through the specs of these boards, trying to devise a way to use them in conjunction to smarten up my AC. After spending days on this problem (some of which were very, very frustrating), I was finally able to accomplish what I wanted!</p><p>我注意到Circuit Playround Express有一个嵌入式红外收发器。虽然它没有自己的操作系统和互联网连接，但我想我可以在某种程度上用它来替代我的交流遥控器。很快，我也意识到互联网连接的空白可以由树莓PI来填补！接下来我所知道的就是，我仔细研究了这些电路板的规格，试图设计出一种将它们结合使用的方法，以使我的AC变得更聪明。在这个问题上花了几天时间(有些问题非常非常令人沮丧)之后，我终于能够实现我想要的了！</p><p> As a starting step, the first thing I did was build a way to remotely turn on my AC — and by remotely I mean from anywhere in the world! In this article, I’ll be demonstrating how I used few open source tools along with the aforementioned boards to bring the power of Internet to my legacy air conditioner, which has no other means of I/O except infrared.</p><p>作为第一步，我做的第一件事就是建立了一种远程打开我的AC的方法-我说的远程是指从世界的任何地方！在本文中，我将演示如何使用少量开源工具和前述主板将Internet的力量带到我的传统空调上，它除了红外线之外没有其他I/O方式。</p><p>     Now, if you don’t have CircuitPlayground Express (CPX), you can substitute it with any IR module, like  this. I used CPX because I already had it. Also, what we’ll be doing isn’t resource intensive, so any cloud box with basic specs will work, including free tier ones (in fact, I used a free-tier AWS EC2 box for this).</p><p>现在，如果您没有Circuit Playround Express(CPX)，您可以将其替换为任何IR模块，如下所示。我用CPX是因为我已经有了。此外，我们要做的不是资源密集型的，所以任何有基本规格的云盒都可以工作，包括免费的第一层(事实上，我为此使用的是自由层的AWS EC2盒)。</p><p>  On the software end, we will need the following tools (I’ll explain their usage later in the article):</p><p>在软件方面，我们将需要以下工具(我将在本文后面解释它们的用法)：</p><p> Shortcuts app on iOS / IFTTT on Android (I only describe the steps for iOS but they’ll be almost identical for Android)</p><p>IOS上的快捷键应用程序/Android上的IFTTT(我只描述了iOS上的步骤，但Android上的步骤几乎相同)。</p><p>   In order for us to be able to switch on the AC from CPX, we first need to see how the remote control does it. Sure, it sends an infrared signal to the receiver in AC, but we need to know how this signal looks like so that we can imitate it from CPX.</p><p>为了让我们能够从CPx打开交流电源，我们首先需要看看遥控器是如何做到这一点的。当然，它会向交流电中的接收器发送红外信号，但我们需要知道这个信号是什么样子，这样我们才能在CPX上模仿它。</p><p> Figuring this out was arguably the hardest part for me, because the  official Adafruit tutorial and many other tutorials on the Web assume that devices we we’re working with follow the NEC infrared protocol. Unfortunately that wasn’t the case with me and I realised that after painful 4 hours of scratching my head. Different companies use different protocols, and Fujitsu General doesn’t use NEC. I then tried to get the IR codes for my AC model directly from the docs of Arduino libraries like  these, but deciphering them was even harder.</p><p>弄清楚这一点对我来说可能是最困难的部分，因为Adafruit官方教程和网上的许多其他教程都假设我们正在使用的设备遵循NEC红外协议。不幸的是，我的情况并非如此，在痛苦地挠了4个小时的头之后，我意识到了这一点。不同的公司使用不同的协议，富士通通用不使用NEC。然后，我试图直接从Arduino库的文档中获得我的AC型号的IR代码，但要破译它们就更难了。</p><p> Much later, I thought — what if I don’t try to obtain the decoded sequence from the IR pulses, but rather just imitate the pulses directly? For this, I experimented with the  pulseio CPX library (preinstalled on the board)and discovered that imitating my AC remote this way was much easier — plus this approach also generalizes to all infrared protocols, not just NEC!</p><p>很久以后，我想-如果我不试图从IR脉冲中获得解码序列，而是直接模拟脉冲会怎么样？为此，我试验了Pulseio CPX库(预装在电路板上)，发现用这种方式模仿我的交流遥控器要容易得多-此外，这种方法还适用于所有红外协议，而不仅仅是NEC！</p><p>  After connecting CPX to my laptop via USB, I first imported the necessary libraries and set up the IR receiver in mu-editor’s REPL. Then I pointed my AC remote control towards the CPX board and hit the power button on it. CPX received the IR pulses sent from the remote control, which I then printed on screen:</p><p>在通过USB将CPX连接到我的笔记本电脑之后，我首先导入了所需的库，并在Mu-Editor‘s REPL中设置了IR接收器。然后我把我的交流遥控器对准CPx板，按下了上面的电源按钮。CPx收到遥控器发送的IR脉冲，然后我将其打印在屏幕上：</p><p>  I ignored the stray values (generally short in length), and copied the large blob that shows up just after remote sends the power-on signal to CPX.</p><p>我忽略了杂散值(通常长度较短)，并复制了Remote将开机信号发送到CPx之后立即出现的大斑点。</p><p> I repeated the process to check if values are same all the time. Notice that individual pulses have slightly different numbers for each transmission, but as we’ll see later, they work just fine as long as they’re together. The only significant pulse array you can see above is when I’d accidentally sent power-off signal from the remote control instead of power-on.</p><p>我重复了这个过程，以检查值是否始终相同。请注意，每个传输的单个脉冲的数字略有不同，但正如我们稍后将看到的那样，只要它们在一起，它们就可以很好地工作。您在上面看到的唯一重要的脉冲阵列是当我不小心从遥控器发出断电信号而不是开机时。</p><p> I then copied the pulse array for power-on signal and stored it in a separate place (Notes app on my laptop).</p><p>然后，我复制了通电信号的脉冲阵列，并将其存储在单独的位置(笔记本电脑上的Notes应用程序)。</p><p>  This bit was much easier. In the mu-editor REPL, I stored the power-on pulse array as a variable (the same pulse array I’d copied earlier). Then I initialized and configured the IR transmitter on CPX board. A standard frequency of transmission is 38kHz, with a signal duty cycle (“on-time”) of 32768, or 2¹⁵. Before sending the pulses, this library requires them to be converted to half-words, which I can be done via the pre-installed  array library itself.</p><p>这一点要容易得多。在u编辑器REPL中，我将开机脉冲数组存储为变量(与我之前复制的脉冲数组相同)。然后对CPx板上的红外发射器进行初始化和配置。标准传输频率为38 kHz，信号占空比(“ON-Time”)为32768，或2？⁵。在发送脉冲之前，该库要求将其转换为半字，这可以通过预装的阵列库本身来完成。</p><p>  The moment of truth for me was when I finally pressed enter after the  pulseout.send(power_on_sig) line. Immediately after pressing enter, I heard the clicking beep from my AC and it did turn on! 🥳</p><p>对我来说，关键时刻是在Pulseout.send(Power_On_Sig)行之后终于按了Enter键。按Enter键后，我立即听到交流电源发出滴答声，它确实打开了！🥳。</p><p> A nice, neat little trick to try out is seeing CPX sending the IR pulses via a super-slow-mo camera. Since IR pulses are sent super quickly, and therefore not visible to the naked eye, you can capture them on video and play it back in slow-mo to see it in action — notice the blinking whitish dot in the middle of the board:</p><p>一个不错的、巧妙的小把戏可以试一试，那就是看到CPX通过一个超慢镜头发送红外脉冲。由于红外脉冲发送速度极快，因此肉眼看不到，因此您可以用视频捕获它们，并以慢镜头播放以查看实际情况-请注意电路板中央闪烁的白点：</p><p>  Now that the core functionality of my solution had been figured out, rest of the steps were relatively smoother. Next thing to find out how to signal CPX itself to fire these IR pulses towards the AC. Interestingly, the USB cable that powers up CPX can also be used as a serial input-output periphery. So I decided that a simple way to signal CPX about when to transmit IR pulses would be to send bytes representing the string  &#34;on&#34; through the USB. CPX will fire the IR pulses every time it receives this sequence of bytes from its mini-USB port. I also decided to add a flash of green to the LED’s on CPX as a cool way of acknowledging received command to turn on the AC. The overall code for this is fairly simple:</p><p>既然我的解决方案的核心功能已经弄清楚了，剩下的步骤就相对流畅了。接下来要了解如何向CPx自身发出信号，以向AC发射这些IR脉冲。有趣的是，为CPX通电的USB电缆也可以用作串行输入输出外围设备。因此，我决定通知CPx何时发送IR脉冲的一种简单方法是通过USB发送表示字符串的字节(&#34；On&#34；on&#34；On&#34；on&#34；on)。CPx将在每次从其迷你USB端口接收到此字节序列时触发IR脉冲。我还决定在CPx上的LED上增加一个绿色的闪烁，作为确认接收到打开交流的命令的一种很酷的方式。这方面的总体代码相当简单：</p><p>  So that was how CPX handles serial input and infrared output. Now I needed a way to send commands to CPX via the Internet, so that I can indirectly control my AC remotely. This is where Raspberry Pi came in. I SSH-ed to my Pi, installed Flask on it via Python’s package manager  pip, and then wrote a simple server that sends bytes over USB representing the commands. What I envisioned is, whenever I make a GET  /switch/on request to this server, it should send  on bytes via USB to CPX, which in turn sends corresponding IR signals to my AC to switch itself on. Here’s the mostly-self-explanatory code for the server:</p><p>这就是CPX处理串行输入和红外输出的方式。现在我需要一种通过互联网向CPX发送命令的方式，这样我就可以间接地远程控制我的交流。这就是树莓派的用武之地。我通过SSH连接到我的PI，通过Python的包管理器pip在上面安装了Flask，然后编写了一个简单的服务器，它通过USB发送表示命令的字节。我设想的是，每当我向该服务器发出GET/SWITCH/ON请求时，它应该通过USB将字节发送到CPX，CPX再将相应的IR信号发送到我的AC以打开它自己。以下是服务器的大部分不言自明的代码：</p><p>  After connecting CPX to my Raspberry Pi via USB, I fired up this server on Pi via  python3 command_sender.py. Next, from my laptop, I sent a  cURL GET request to my Pi (via home LAN), as follows:</p><p>在通过USB将CPX连接到我的Raspberry PI之后，我通过python3命令_sender.py在PI上启动了这个服务器。接下来，我从我的笔记本电脑向我的PI(通过家庭LAN)发送了一个cURL GET请求，如下所示：</p><p>  And yet again, my AC turned on gracefully as soon as I pressed enter! This was one of those rare occasions when my code works as intended in the very first run 😄. But this happiness didn’t last long as I was about to hit a kind of dead end.</p><p>再一次，我一按回车键，我的AC就优雅地打开了！这是我的代码在第一次运行😄时能够正常工作的极少数情况之一。但是这种快乐并没有持续很长时间，因为我即将走进一条死胡同。</p><p>  The system I was trying to build wouldn’t be of much utility if I couldn’t access it via Internet. It worked till now because I was sending commands to Raspberry Pi while being on the same home Wifi network.</p><p>如果我不能通过互联网访问，我试图建立的系统就不会有太大的用处。它一直工作到现在，因为我在同一个家庭Wifi网络上向树莓Pi发送命令。</p><p> While the straightforward way to make the Pi accessible via the public Internet was to enable port-forwarding on my home router, I didn’t want to do that mostly because of two reasons:</p><p>虽然使PI可以通过公共Internet访问的直接方法是在我的家庭路由器上启用端口转发，但我不想这样做，主要是因为两个原因：</p><p> I didn’t want to expose my home network’s public IP (I’m not a security whiz but I just didn’t feel safe doing this).</p><p>我不想暴露我的家庭网络的公共IP(我不是安全专家，但我只是觉得这样做不安全)。</p><p> My ISP can change the public IP address of my home without informing me, which can lead to headaches and unnecessary reconfiguration.</p><p>我的ISP可以在不通知我的情况下更改我家的公共IP地址，这可能会导致头痛和不必要的重新配置。</p><p> Anticipating the unreliability of this approach, I decided to look for alternatives. I was aware that reverse proxies are a common way to solve these kinds of problems, since they don’t require messing with router configurations and are relatively safer since connections are always initiated from within the network. A cool reverse proxy solution I was familiar with is   ngrok , but the problem with  ngrok is that the free version only allows connectivity for 8 hours. Then there is another solution built specifically for Raspberry Pi’s is  dataplicity, but it’s terminal interface has some bugs and the free version is quite limited, just like  ngrok. Moreover, I wanted to avoid as much external dependencies as possible.</p><p>预见到这种方法的不可靠性，我决定寻找替代方法。我知道反向代理是解决这类问题的常用方法，因为它们不需要处理路由器配置，而且相对安全，因为连接总是从网络内部发起的。我熟悉的一个很酷的反向代理解决方案是ngrok，但ngrok的问题是免费版本只允许连接8小时。还有另一个专门为Raspberry Pi构建的解决方案是dataplicity，但是它的终端界面有一些错误，而且免费版本非常有限，就像ngrok一样。此外，我希望尽可能多地避免外部依赖。</p><p> “In computer networks, a  reverse proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client, appearing as if they originated from the server itself.” — Wikipedia</p><p>“在计算机网络中，反向代理是代表客户端从一个或多个服务器检索资源的一种代理服务器。然后这些资源被返回给客户端，看起来好像它们来自服务器本身。“-维基百科。</p><p> After searching the Web for a while, I discovered a free and open-source tool called   frp, short for “fast reverse proxy”, that can be set up as a reverse proxy server, and has an extensive set of configurations available. I tinkered with it for a while and found it to be a great fit for my needs. Leveraging its power, I decided to go with the following approach:</p><p>在Web上搜索了一段时间后，我发现了一个称为FRP的免费开源工具，它是“快速反向代理”的缩写，可以设置为反向代理服务器，并且有大量可用的配置。我修修补补了一会儿，发现它非常适合我的需要。利用它的力量，我决定采用以下方法：</p><p> I would set up a public-Internet facing box on AWS, that will act as a reverse proxy server. This means I’ll be sending my AC control requests to the IP of this box, and it will in turn forward that request to the Pi in my home. This is better than doing port forwarding, as I don’t have to mess with my router settings and change configuration every time my ISP changes the public IP for my home network. It is also safer as I can fine tune access to devices in my home network, way beyond the basic security configuration most home routers provide. More benefits of using a reverse proxy can be found in  this Stackoverflow answer.</p><p>我会在AWS上设置一个面向公共互联网的盒子，作为反向代理服务器。这意味着我将把我的AC控制请求发送到这个盒子的IP，然后它会将该请求转发给我家里的PI。这比进行端口转发要好，因为每次ISP更改我家庭网络的公用IP时，我都不必弄乱我的路由器设置和更改配置。它也更安全，因为我可以微调对家庭网络中设备的访问，远远超出大多数家庭路由器提供的基本安全配置。在此堆栈溢出答案中可以找到使用反向代理的更多好处。</p><p>  As I said earlier, I used AWS for provisioning a box, but any other cloud provider will work just as good. After provisioning, I SSH-ed to the box and downloaded  frp on it. Server side configuration is simple, I just had to add a couple of lines to  frps.ini file:</p><p>正如我前面所说的，我使用AWS来配置机箱，但是任何其他云提供商都会工作得一样好。配置后，我通过SSH连接到机箱并在其上下载了FRP。服务器端配置很简单，我只需向frps.ini文件添加几行：</p><p>  frp will be using this port (7000) for internal communication with clients (Pi in our case).</p><p>FRP将使用此端口(7000)与客户端(本例中为PI)进行内部通信。</p><p> Next, I installed  tmux and then triggered a  tmux session. Then I started the  frp server from within it. After that I detached from the session so that reverse proxy session keeps running even after I disconnect from the box:</p><p>接下来，我安装了tmux，然后触发了tmux会话。然后我从里面启动了FRP服务器。在那之后，我与会话分离，以便反向代理会话即使在我与计算机断开连接后也能继续运行：</p><p>  Then I SSHed to my Raspberry Pi again, downloaded  frp on it, and configured the  frpc.ini file as such:</p><p>然后，我再次通过SSH连接到我的Raspberry PI，在上面下载了FRP，并按如下方式配置了frpc.ini文件：</p><p> [common] server_addr = &lt;public ip of my AWS EC2 instance&gt; server_port = 7000 [web] type = tcp local_ip = 127.0.0.1 local_port = 5000 remote_port = 6000</p><p>[常用]我的AWS EC2实例的服务器地址=&lt；公网IP&gt；服务器端口=7000[web]type=TCP LOCAL_IP=127.0.0.1 LOCAL_PORT=5000 REMOTE_PORT=6000。</p><p> Here,  server_port is same as  bind_port that I’d set on the server — 7000. Now,  remote_port and  local_port values mean that the reverse proxy server will accept requests on port 6000 and forward them to port 5000 on the Pi. I also modified the inbound settings of my EC2 instance’s security group so that ports 7000 and 8000 can be accessed.</p><p>这里，server_port与我在server-7000上设置的bind_port相同。现在，REMOTE_PORT和LOCAL_PORT值意味着反向代理服务器将接受端口6000上的请求，并将它们转发到PI上的端口5000。我还修改了EC2实例安全组的入站设置，以便可以访问端口7000和8000。</p><p> Next, I installed  tmux on the Pi too, and after opening a  tmux session I started the command sender Flask server ( note that I did not set up a production server but a development server, since I was still experimenting) as well as the  frp client, and then finally detached from this session and disconnected from the Pi:</p><p>接下来，我也在PI上安装了tmux，在打开tmux会话之后，我启动了命令发送器Flask服务器(请注意，我没有设置生产服务器，而是开发服务器，因为我仍在进行实验)以及FRP客户端，最后从该会话分离并断开与PI的连接：</p><p>  Most of my setup was done at this point. I connected my laptop to my mobile data, then made the following  cURL call:</p><p>我的大部分设置都是在这一点上完成的。我把我的笔记本电脑连接到我的移动数据上，然后打了以下卷发电话：</p><p>  …and the AC beeped to life yet again, this time via a signal sent over the public Internet!</p><p>…。而空调又一次呼唤着生命，这一次是通过公共互联网发送的信号！</p><p>  The only thing remaining was to set up a way to conveniently make this API call from my phone to turn the AC on — I didn’t want to memorise the IP address of my EC2 machine, so I finally decided to put the Shortcuts app on my phone to some use, as that was another thing I rarely used until now, and I really wanted to try it out.</p><p>剩下的唯一一件事就是设置一种方法，方便地从我的手机调用这个API来打开AC-我不想记住我的EC2机器的IP地址，所以我最终决定把手机上的快捷方式应用程序投入一些用途，因为这是另一个我现在很少使用的东西，我真的很想尝试一下。</p><p>  Open Shortcuts app  &gt;   Create Shortcut  &gt;   Add Action  &gt;   Web  &gt;   URL  &gt;   add my API call  &gt; Tapped on    +  to add another action &gt;   Get Contents of URL  (this makes the actual GET request for the URL configured in previous action)</p><p>打开快捷方式APP&&gt;创建快捷方式&&gt;添加操作&&gt;Web&&gt;URL&&gt;单击+添加我的API调用&&gt;以添加另一个操作&&gt;获取URL的内容(这将生成对上一操作中配置的URL的实际GET请求)。</p><p>  While still on my mobile data, I opened the Shortcuts app on my phone and tapped on the shortcut I just created. Here’s what happened:</p><p>当我还在使用我的移动数据时，我打开了手机上的快捷键应用程序，点击了我刚刚创建的快捷键。事情是这样发生的：</p><p>  So that’s how I made my AC remotely accessible. It can only power-on right now, but other functionalities can be added easily, now that the barebones have been set up. The AWS box I created can act as a single hub for all communications to and from legacy electronics. Not only can I send commands to the AC, it’s also possible to get its state and create controlled feedback loops for a smart temperature system — a lot of things can be implemented!</p><p>所以我就是这样让我的空调可以远程访问的。它现在只能通电，但现在可以很容易地添加其他功能，因为基本设备已经设置好了。我创建的AWS机器可以充当与传统电子产品之间的所有通信的单一集线器。我不仅可以向AC发送命令，还可以获取其状态并为智能温度系统创建受控反馈回路-可以实现很多事情！</p><p>  frp also provides a dashboard to monitor traffic, you can enable it via adding these lines to  frps.ini file:</p><p>FRP还提供了一个控制面板来监控流量，您可以通过将以下行添加到frps.ini文件来启用它：</p><p>  Don’t forget to create an inbound rule for this port (9000 in this example) so that the dashboard can be accessed. It looks something like this:</p><p>不要忘记为此端口(本例中为9000)创建入站规则，以便可以访问仪表板。它看起来像这样：</p><p>  I hope this article inspires you to work on your own DIY projects with Raspberry Pi, CircuitPlayground Express and legacy devices! Let me know your thoughts and feedback in the comments!</p><p>我希望这篇文章能启发您使用Raspberry Pi、Circuit Playround Express和传统设备进行自己的DIY项目！请在评论中告诉我您的想法和反馈！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://schedutron.medium.com/build-smart-home-systems-on-top-of-legacy-electronics-d85640d2e5ea">https://schedutron.medium.com/build-smart-home-systems-on-top-of-legacy-electronics-d85640d2e5ea</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/控制/">#控制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/legacy/">#legacy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpx/">#cpx</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>