<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PostgreSQL中时间序列记录的高效均匀采样</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PostgreSQL中时间序列记录的高效均匀采样</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-15 06:05:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/9438fbac79b2cbad82a805d71ec1d152.png"><img src="http://img2.diglog.com/img/2020/10/9438fbac79b2cbad82a805d71ec1d152.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我一直在开发一个应用程序，它的核心是存储大量数据，这些数据主要是通过使用外键和时间戳字段来组织的。表自己的主键是基于UUID的，将外键与单个记录本身的UUID组合在一起，并且它有一个使用JSONB类型的主数据字段，因为它可以接收任意数据。该表可以看到频繁的、定期的插入和周期性的删除，旧数据会随着时间的推移而变得稀疏，但是对于每个外键，可能会有数万条记录分布在数十万条记录中，或者对于其他外键，可能会有数百万条其他记录。</p><p>这一切都非常简单，但是当开始编写从该表生成数据图的代码时，我遇到了一个难题。</p><p>如何确保API不会返回太多数据呢？数据点过多只意味着发送的数据比用户可能需要的要多，这也会导致绘图工具不得不处理比它想要的更多的数据，以获得快速、响应的性能。</p><p>如何才能高效地查找数据而不运行查询则需要大量的时间呢？在我们的示例中，数据由API返回到基于Reaction的前端，而Snappy应用程序的性能取决于Snappy API的性能。</p><p>在应用程序历史的早期，我得出了一个解决方案。如果我对要查询的数据点数量有一个最大上限，比如500个，那么我可以查询与查询匹配的记录总数，然后一个小整数除法会给我一个查询时使用的间隔。</p><p>一旦确定了记录计数，就可以计算用于查询记录样本的间隔。</p><p>也就是说，如果有5000个数据点，我想要对其中的500个数据点进行采样，那么我需要每10条记录进行一次查询。要找到那个间隔，看起来就像这样：</p><p>一旦有了间隔，PostgreSQL就可以使用一种技术来选择该间隔上的记录。ROW_NUMBER()是一个窗口函数，它为结果集中的每一行分配一个序列号。一旦为每条记录分配了一个单调递增的序列号，就可以在WHERE子句中使用该编号。</p><p>这招奏效了！当您希望从某个结果集中选择每第n条记录，并且希望让数据库而不是您的应用程序来执行工作时，这是一种可行的通用技术。与将所有数据放入应用程序并使其负责对数据进行排序和修剪不需要的行相比，在数据库中进行这样的数据管理几乎总是更快、占用的资源更少。</p><p>这种方法有几个性能问题，当表开始显着增长时，这些问题就会变得明显。</p><p>首先，拉计数并不便宜。MySQL维护表的全局记录计数，作为其MyISAM数据格式的一部分。然而，PostgreSQL对其表使用了一种称为多版本并发控制策略，这实质上意味着数据库的不同视图可能会看到不同的行集。因此，没有单一的、简单的记录计数可供它依靠。因此，当您在PostgreSQL中对表中的记录进行计数时，数据库需要实际遍历数据并对所有可见记录进行计数。</p><p>如果您只是想估计表中的总行数，有一种方法可以非常便宜地获得：</p><p>但是，当您只想计算记录的一个子集，并且该值只是一个估计值时，这是不起作用的。这是查询规划器使用的估计值，因此它通常应该始终在实际值的10%左右，但它不太可能完全匹配，除非表大小更改很少。还有其他计数策略，但它们都有权衡或固有的不准确性，因此对于此用例，仅为了在计算所需的查询间隔时获得要使用的记录计数是无法回避的前期时间和资源成本。</p><p>该技术的第二个开销部分是在WHERE子句中结合使用ROW_NUMBER()和模数(%)。这意味着数据库在运行查询时必须遍历每条可能的记录，以便找出哪些记录满足WHERE子句。因此，如果有150000条记录，但一个人只想要其中的500条，那么所有150000条记录仍将被扫描。</p><p>这些因素加在一起，使得这种方法对于作为驱动UI的API的一部分特别运行的查询来说变得异常缓慢。</p><p>这是一个使用先前技术在真实数据库上进行查询的真实示例，并且此示例的优点在于，它使用的索引(跨数据字段的BTREE索引，因为在生产中，我们将结果限制为具有一种特定类型数据的字段)在我运行此示例时已经预热并缓存在数据库的工作集中，因此此结果是此技术在此数据库上的最佳情况。如果该索引不可用或未使用，考虑到该索引筛选器拒绝了近180,000行，则速度会更慢。这太慢了，不能通过API请求直接触发，因为用户将等待半分钟，才能让数据开始显示在他们的浏览器中。</p><p>事实证明，PostgreSQL提供了一个高性能选项来采样表中的随机数据集。可以将TABLESAMPLE子句放在查询的FROM部分中，该查询将对表的子集进行采样。</p><p>这将返回大约5%的MyTable行的大致随机集合。如果需要特定的行数，有一个扩展可以提供，即TSM_SYSTEM_ROWS。</p><p>这将从表中返回500行的随机集合。可以在使用TABLESAMPLE的查询中使用WHERE子句，以便只选择感兴趣的行，但TABLESAMPLE在WHERE子句之前应用，这使得此方法不适合我的用例。例如：</p><p>这将首先从整个数据集中选择500个随机行，然后尝试从该集中查找与WHERE子句匹配的记录。这可能会导致查询只返回非常少且相当不可预测的实际需要的数据行数。此外，因为记录是随机的，所以不能保证它们在整个数据集中均匀分布。如果出于统计原因查询数据，这可能很好，但当为图表提取数据时，这并不理想。</p><p>因此，虽然TABLESAMPLE可能是在整个表中选择随机记录集的一种非常快速的方法，但当我们需要一组均匀分布于整个数据集的行，而只针对表总数据的一部分，并且我们希望对其选择的行数有一些可预测的控制时，它就不起作用了。</p><p>当要解决的问题是随机选择表行时，还有其他可用的解决方案，但对于选择N个或接近N个均匀分布的数据点，这些解决方案中没有一个特别有用，并且从中可以找到的灵感有限。</p><p>作为快速概述，最简单的方法是只在WHERE子句中插入与随机数的比较：</p><p>这将选择总行的大约10%，但它需要全表扫描。如果需要特定数量的随机行，可以在ORDER BY子句中使用随机化来实现。这要慢得多，特别是在大表上，因为全表扫描之后是某种整表扫描，但它确实可以工作：</p><p>如果表使用递增的整数主键进行索引，并且键中没有太多间隙，则可以通过使用ID范围内生成的随机数序列来执行相当快速的随机记录选择。</p><p>如果遥测表使用整数主键编制索引，并且它有650000条记录，几乎没有间隙(没有删除任何块)，则上面的代码将遍历生成的一系列整数，并将生成一组介于1到650000之间的不同的随机整数。您可以将FROM子句中的代码视为生成随机数组的for循环的SQL版本。然后，连接将这些数字用作记录ID，它将返回限制为500条记录的最终集合。我们拉出500条以上的记录，以防出现一些缺口，以避免找不到500条记录。考虑到已经提到的注意事项，此技术非常快速，虽然它不能应用于使用UUID索引的表的情况，但我认为可以推广此实现思想中的核心概念，以提供适用于时间索引数据的非常快速的解决方案。</p><p>我得出的解决方案可以在几毫秒内返回表中某个数据子集的时间分布样本。它利用PostgreSQL通过函数生成系列数据的能力，以及在构建查询时API服务器内部的一些数学运算，以创建一个查询，该查询在正确索引后，将非常快速地返回均匀分布的数据。</p><p>这个想法取决于这样一个事实，即所有记录都带有一个时间戳，该时间戳保留了它们在时间序列中的位置。因此，如果数据库本身可以生成一系列均匀分布在整个数据范围内的时间戳，则查询可以返回一个时间戳和下一个时间戳之间的间隔行。这将导致一组行数不超过所需的最大值集，但如果间隔太小而无法在每个行内查找数据，则行数可能会更小，并且PostgreSQL处理此查询的速度快得出奇。</p><p>因此，如果我们想要从数据库中提取从2020-09-01 00：00：00：00到2020-09-15 23：59：59期间的500个特定类型的数据点，那么第一步是计算出在这些开始时间戳和结束时间戳之间需要多少间隔才能获得500步。这是一个简单的数学运算：</p><p>此方法利用PostgreSQL Generate_Series()函数，该函数获取起始值、结束值和间隔，并从它们生成一组值。</p><p>但是，PostgreSQL提供了一种方便的机制来绕过子查询的这一限制。PostgreSQL允许用户定义自定义类型。使用此功能，可以定义同时包含JSONB和没有时区实体的时间戳的类型，对于上面遇到的限制而言，这将被视为单个数据项。</p><p>然后，可以重写查询以返回此自定义类型的单个实例，从而消除错误并使其按预期工作。</p><p>当针对与原始的基于row_number()的解决方案相同的数据集进行评估时：</p><p>我会注意到，平均来说，它实际上并没有那么快。我用来执行这些测试的数据库实例是一个非常小的t3.microAmazon RDS实例，因此计时结果有一定的可变性，大多数结果从比本例稍微快一点到大约9ms不等，平均接近8ms。此外，如果在执行查询时索引不在高速缓存中，则在上述测试环境中，第一次执行时的查询性能对于该第一次查询下降到约40ms。实际上，对于我们的应用程序，这个查询最终平均只比原来的查询快大约3250倍。</p><p>为您的数据集适当地调优您的数据库，并且您的缓冲区足够大，以容纳一个合理的工作集，这一点很重要。如果数据库引擎必须从存储中提取非常大量的数据，那么等待IO操作就会影响整体查询性能。</p><p>对于缺少(data？&#39；load_avg&#39；：：text)过滤器的基本查询，执行时间进一步减少了一半。</p><p>这在我们的用例中用处有限，因为我们希望能够具体选择正在绘制的数据，但它只是用来说明基本技术可以有多快。</p><p>这比我开始通过更好的解决方案解决这个问题时所希望或期望的要快得多。允许数据库生成间隔，然后接受数据库在该间隔中找到的第一条记录，以不能保证数据点之间的绝对精确周期为代价，快速生成跨总时间集均匀分布的结果集。在实验测试中，数据点往往分布在时间间隔周围，但偶尔会有几对点，其中一个落在时间间隔的末尾，下一个落在开始附近，反之亦然。</p><p>如果需要数据点之间的精确周期，此技术仍然可以提供出色的结果。只需在LIMIT子句前添加一个ORDER BY T.CREATED_AT，就可以保证每个数据点都是在其间隔中找到的第一个数据点。即。</p><p>而使用ORDER BY时，所选择的数据点虽然与前一个集合有显著重叠，但由该特定查询的间隔(2592秒约为43.2分钟)分隔得更加严格。</p><p>使用order by会降低性能，因为它会强制数据库对每个间隔中的结果进行排序。然而，成本不一定是令人担忧的原因：</p><p>前面提到的关于数据库调优的警告尤其适用于此版本的查询。因为涉及到排序，所以它对工作集中的数据的差异更加敏感。但是，即使在最坏的情况下，没有数据在工作集中，这个查询仍然比基于row_number()的解决方案快几倍。</p><p>SQL和PostgreSQL都是工具包，几乎总是有多种方法可以做到这一点，而且随着人们在期望的结果上投入更多的时间，就有可能得到更深层次的细微差别和改进。对于从较大的表中选择时间分布的行样本，可能有比此更好的技术，但此技术比更幼稚的版本快得多，并且它以提供极佳用户体验的速度准确地交付了我们的应用程序所需的结果。同时，还有一些事情可能会让它变得更快，特别是在整个数据集增长的情况下。例如，由于查询始终集中在单个服务器ID上，因此按server_id进行分区可能是成功的。</p><p>不过，最后，自由使用PostgreSQL的解释分析来理解数据库引擎在执行查询时所做的工作，以及实验和大量失败，以及随着解决方案的改进而逐步进行的小改进，使我们从一个返回大量数据的解决方案转变为一个返回大量数据，但等待这些结果的时间长得离谱的解决方案，而这个解决方案仍然以比我开始重新实现该查询时所期望的速度更快的速度返回了很好的结果，这将使我们从一个返回大量数据的解决方案转变为一个仍然以比我开始重新实现该查询时所期望的速度更快的速度返回大量结果的解决方案。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.joshsoftware.com/2020/10/14/efficient-evenly-distributed-sampling-of-time-series-records-in-postgresql/">https://blog.joshsoftware.com/2020/10/14/efficient-evenly-distributed-sampling-of-time-series-records-in-postgresql/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/序列/">#序列</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/evenly/">#evenly</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1012816.html"><img src="http://img.diglog.com/img/2020/7/thumb_fba1512e2431f8be0db90dd0fa8e645e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1012816.html">入门读物：使用声音进行预测性维护</a></div><span class="my_story_list_date">2020-7-19 10:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1012175.html"><img src="http://img.diglog.com/img/2020/7/thumb_6569a1ea3027e4a2cbdcc9a6168c7495.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1012175.html">研究人员产生完整的人类X染色体序列</a></div><span class="my_story_list_date">2020-7-16 6:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1011856.html"><img src="http://img.diglog.com/img/2020/7/thumb_4cd6e3ee274bfe0fcae21faec9f8c399.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1011856.html">科学家首次实现人类X染色体的完全组装</a></div><span class="my_story_list_date">2020-7-15 5:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1007552.html"><img src="http://img.diglog.com/img/2020/6/thumb_620dae4229626ee37a27475f04dbbf53.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1007552.html">腐败、稀疏、不规则、丑陋：对时间序列的深度学习</a></div><span class="my_story_list_date">2020-6-22 2:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>