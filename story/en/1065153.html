<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>零停机Postgres迁移，完成了 Zero downtime Postgres migration, done right</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Zero downtime Postgres migration, done right<br/>零停机Postgres迁移，完成了 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 00:05:57</div><div class="page_narrow text-break page_content"><p>In this blog post we describe how to migrate a Postgres database to a new instance with zero downtime using Bucardo. We will describe how to avoid common pitfalls like data loss, deteriorated performance and data integrity failures. We have successfully used this process to migrate our Postgres databases from version 9.5 to 12.5 on RDS, but the process isn’t restricted to RDS only, and does not depend on anything AWS specific. This migration strategy should be possible with any self-hosted or managed Postgres.</p><p>在此博客文章中，我们介绍如何使用Bucardo将Postgres数据库迁移到具有零停机的新实例。我们将介绍如何避免像数据丢失，恶化性能和数据完整性失败等常见陷阱。我们已成功使用此过程将我们的Postgres数据库从9.5版本迁移到RDS上，但该过程仅限于RDS，并且不依赖于特定的任何AWS。任何自托管或管理的Postgres都应该进行这种迁移策略。</p><p>  In this article we will talk about migrating multiple web applications, like microservices, from one database to another. Modern architectures consist of multiple apps (or micro-services if you prefer), while each app has more than one running instance to facilitate scaling. In order to be able to move your apps to a new database, you must first make sure that data in both databases are in-sync, and remain so at any given point in time, otherwise your clients will end up losing data, or even end up with an invalid state.</p><p>  在本文中，我们将讨论从一个数据库到另一个数据库中迁移多个Web应用程序，如微服务。现代架构包括多个应用程序（或如果您喜欢的微服务），而每个应用程序都有多个运行实例以方便缩放。为了能够将应用程序移动到新数据库，您必须首先确保两个数据库中的数据同步，并且在任何给定的时间点保持如此，否则您的客户将最终失去数据，甚至最终最终有无效状态。</p><p> A naive solution for this is to stop writing to the old database, take a snapshot, restore it to a new database, and resume your operations there. This scenario includes an unacceptable amount of downtime, and is unsuitable for a production environment. We only mention this for educational purposes, since it is the easiest way to ensure that you won’t lose any data, but you may lose a few customers.</p><p> 一个天真的解决方案是为了停止写入旧数据库，拍摄快照，将其恢复到新数据库，并在那里恢复操作。这种情况包括一个不可接受的停机量，不适合生产环境。我们只提到这一点是为了教育目的，因为它是确保您不会丢失任何数据的最简单方法，但您可能会丢失一些客户。</p><p> A more realistic approach is to set up a near real-time bidirectional replication between the two databases so that, ideally, apps can read from and write to both without noticing any difference. This approach will allow you to gradually move your apps one by one, one instance at a time, without downtime and without affecting your users. Since we want our applications to be able to write to both databases, we need to go after multi-master replication. A Google search for “multi-master replication in Postgres” will present you with  plenty of solutions, each one with several advantages and disadvantages to consider. We decided to proceed with  Bucardo because it is open-source, fast, and provides easy monitoring and a conflict resolution mechanism.</p><p> 一种更现实的方法是在两个数据库之间建立一个近乎实时的双向复制，因此，理想情况下，应用程序可以从并写入两者而不明显任何差异。此方法将允许您逐个将应用程序逐步移动，一个实例一次，无需停机，而不会影响您的用户。由于我们希望我们的应用程序能够写入两个数据库，因此我们需要在多主机复制后进行。谷歌搜索“Postgres中的多主复制”将向您提供大量解决方案，每个解决方案都有几个优点和缺点。我们决定继续进行Bucardo，因为它是开源，快速，并提供简单的监控和冲突解决机制。</p><p>  Bucardo acts as a middle man between two Postgres instances. You can have Bucardo running on any machine you like, as long as it can reach the source and the target databases. Once you install it and set multi-master replication, Bucardo will add some  extra triggers to all the tables you have selected to replicate. The instance that you run Bucardo on utilizes a separate Postgresql database locally in order to save the synchronization state. This way you can pause and restart synchronization at will. When a change occurs, a trigger will add all affected primary keys to a “delta” table in the Bucardo instance’s Postgres, and another trigger will “kick” the sync. Each time the sync is kicked, Bucardo will compare the affected rows of each table for all masters and pick a winner, then it will sync the changes to the rest of the databases. Picking a winner is not straightforward, and a conflict can occur at this point. (We analyze conflicts in a different section.)</p><p>  Bucardo作为两个Postgres实例之间的中间人。只要它可以到达源和目标数据库，您就可以在您喜欢的机器上运行Bucardo。安装它并设置多主复制后，Bucardo将为您选择复制的所有表添加一些额外的触发器。运行Bucardo的实例在本地使用单独的PostgreSQL数据库以保存同步状态。这样，您可以暂停并重新启动同步。发生更改时，触发器将为Bucardo实例的Postgres中的“Delta”表添加所有受影响的主键，另一个触发器将“启动”同步。每次同步被踢，Bucardo都会将每个表的受影响的行进行比较，以为所有主人选择赢家，然后它将与其其余数据库的更改同步。挑选胜利者并不简单，此时可能发生冲突。 （我们分析了不同部分中的冲突。）</p><p>   Several guides online suggest that the proper way to use Bucardo is to take a snapshot of the source database, restore it to a new one, and then kick-off a multi-master Bucardo sync. Don’t do that! If you do so, you are about to get a data loss proportional to your current database size and write traffic. This is because taking the snapshot and restoring it requires a significant amount of time. During that time frame the source database will start to drift as writes occur, and this drift must be synchronized as well in order to ensure that both masters contain the same data. The catch here is that people believe that Bucardo will do some kind of back-filling, but it turns out that it is unreliable at this task and will probably fail to sync big drifts. You can always use a tool that compares data across databases in order to ensure that drift has been eliminated, but if the datasets are huge, a lot of time will be wasted and we can’t afford that if zero-downtime is what we are looking for. Additionally, with enough replication lag, you could end up with in-flight sync detected as false positive drift.</p><p>   几个指南在线表明，使用bucardo的正确方法是拍摄源数据库的快照，将其恢复到一个新的，然后启动多主站bucardo同步。不要这样做！如果您这样做，您即将获得与当前数据库大小和写流量成比例的数据丢失。这是因为拍摄快照并恢复它需要大量的时间。在此期间，源数据库将在发生写入时开始漂移，并且必须同步此漂移，以确保两个主机包含相同的数据。这里的抓住是人们认为Bucardo会做一些背包，但事实证明，这项任务是不可靠的，可能无法同步大漂移。您可以始终使用将数据库跨数据库进行比较的工具，以确保已消除漂移，但如果数据集是巨大的，则会浪费大量时间，如果零停机是我们所在的寻找。此外，有足够的复制滞后，您最终可能会被检测为假正漂移的飞行同步。</p><p>   You can start Bucardo sync and tell it to cache all drift in its local database by using the  autokick=0 flag. Unfortunately, this option is critical but is not documented! This step is critical and to our knowledge the only explicit reference happens in this excellent  blog post by David E. Wheeler.</p><p>   您可以使用autokick = 0标志启动Bucardo Sync并告诉它以缓存其本地数据库中的所有漂移。不幸的是，这个选项至关重要，但没有记录！这一步骤至关重要，我们的知识唯一明确的参考由David E. Wheeler的优秀博客文章中发生。 </p><p> Note autokick=0. This ensures that while deltas are logged, they will not be copied anywhere until we tell Bucardo to do so.</p><p>注意autokick = 0。这可确保在记录Deltas时，在我们告诉Bucardo这样做之前，他们将不会被复制。</p><p> What you achieve by using this flag is that you can cache the delta in the Bucardo instance locally until you have enough time to prepare your new database. This is critical, especially for big drifts.</p><p> 使用此标志的实现是什么，您可以在本地可以在Bucardo实例中缓存Delta，直到您有足够的时间准备新数据库。这是至关重要的，特别是对于大漂移。</p><p>   You have two options here. You can either take an all-inclusive snapshot from your first database and restore it to a new instance, or you can start with a new empty database and transfer users, schemas, and then data - in that order - separately. We recommend the latter approach. The reason is that after benchmarking both solutions, the second one was cleaner. We had the chance to dismiss old user accounts, temporary tables and fine-grain the user permissions from scratch.</p><p>   这里有两个选择。您可以从您的第一个数据库中获取全包快照并将其恢复为新实例，或者您可以从新的空数据库开始，传输用户，架构，然后转移数据 - 以该顺序分别 - 单独。我们建议后一种方法。原因是在基准测试后，第二个是清洁剂。我们有机会从头开始撤消旧用户帐户，临时表和细粒度。</p><p> In case you are using AWS RDS, the proposed solution is faster too. Taking snapshots can cost you several minutes, depending on your database size. Additionally, if you are migrating from an unencrypted server to one that uses encryption-at-rest, like we did, you need to take a snapshot, encrypt the snapshot, and then restore it to a new RDS instance. This was way more time-consuming, and minimal migration time was a key goal for us.</p><p> 如果您使用AWS RDS，所提出的解决方案也更快。拍摄快照可以花费几分钟，具体取决于您的数据库大小。此外，如果要从未加密的服务器迁移到使用加密 - 休息的服务器，如我们所做的那样，您需要拍摄快照，加密快照，然后将其还原到新的RDS实例。这是更耗时的方式，最小的迁移时间是我们的主要目标。</p><p>  Before you start Bucardo sync you need to configure it properly. You need to specify the two databases, their type (master/replica), and what parts of the database should be included in the sync. You can bulk add all tables from a schema, which is very helpful for databases with lots of tables.</p><p>  在开始Bucardo同步之前，您需要正确配置。您需要指定两个数据库，它们的类型（Master /副本）以及数据库的哪些部分应包含在同步中。您可以批量添加架构中的所有表，这对具有大量表的数据库非常有帮助。</p><p> Bucardo can not synchronize tables without a primary key (PK), which is totally expected, since it couldn’t distinguish unique entries otherwise. We had to exclude some tables in the process that acted as a cache for various table migrations and didn’t include a PK. Some unused tables were also excluded so we didn’t transfer unused data to our new database. Bucardo supports this easily: after you add all tables, you can remove the tables you want to exclude.</p><p> Bucardo无法同步没有主键（PK）的表，该表完全预期，因为它无法区分唯一条目。我们不得不在过程中排除一些表，该表充当各种表迁移的缓存，并且不包含PK。一些未使用的表也被排除在外，因此我们没有将未使用的数据转移到我们的新数据库。 Bucardo轻松支持此项：添加所有表后，您可以删除要排除的表。</p><p>  Bucardo won’t migrate Postgres users. You need to transfer your user accounts manually. We wrote a script for this purpose that you can  find here. The script goes to the new database, creates the new users with their passwords retrieved from a configuration server, and then sets their permissions. Although you might not keep your datastores as-code, it’s a good practice to keep their users as-code in order to be able to restore them in case of disaster.</p><p>  Bucardo不会迁移Postgres用户。您需要手动传输您的用户帐户。我们为此目的写了一个脚本，您可以在这里找到。该脚本进入新数据库，从配置服务器检索的密码创建新用户，然后设置其权限。虽然您可能不会以代码保留您的数据存储，但它是一个很好的做法，以便在灾难中可以恢复它们。 </p><p>  You can use Postgres and its  pg_dump/pg_restore tools to transfer your schemas and data. This is an easy step, with a catch. Remember that at this point we already have Bucardo up and running to record drift, so restoring data on the target server would be interpreted as changes to sync back to the source database. This is why we need to restore data onto the target Postgres database using a replica session, by enabling the  session_replication_role=replica flag. We will need to disable it before we kick-off your continuous synchronization.</p><p>您可以使用Postgres及其PG_DUMP / PG_RESTORE工具来传输您的模式和数据。这是一个简单的一步，捕获。请记住，此时我们已经有Bucardo启动并运行录制漂移，因此将在目标服务器上恢复数据将被解释为要同步到源数据库的更改。这就是通过启用Session_Replication_Role =副本标志，我们需要使用副本会话将数据还原到目标Postgres数据库上的原因。我们需要在启动连续同步之前禁用它。</p><p>  High availability, a prerequisite for a zero-downtime migration, typically mandates that each application has more than one running instance. Typically each one should be drained before restarted, so there is no way to switch all instances to the new database at the exact same point in time - if there is such a thing anyway. So there will always be a critical - shorter or longer - time window in which the same application will write to both databases, and it is during that time when conflicts can occur.</p><p>  高可用性，零停机迁移的先决条件通常是每个应用程序都有多于一个运行实例的要求。通常每个每个人都应该在重新启动之前排出，因此无法在完全相同的时间点将所有实例切换到新数据库 - 如果无论如何都有这样的事情。因此，将始终存在关键 - 或长时间窗口，其中相同的应用程序将写入两个数据库，并且在此期间可能发生冲突时。</p><p> Conflicts are rare, since they require two writes to take place in both databases before Bucardo can replicate those two records across. With a near-zero replication time, chances are you won’t have any conflicts at all, but this migration is happening in a critical production environment and so they can’t be ignored.</p><p> 冲突很少见，因为他们需要在Bucardo可以复制两种记录之前在两个数据库中进行两次写入。通过近零复制时间，您根本不会有任何冲突，但这种迁移正在发生在关键的生产环境中，因此他们不能被忽略。</p><p> Imagine two clients trying to book the same house for the same date. If they both try to do so at the exact same time and each one is pointed to a different database, a conflict may occur. Bucardo comes with a  conflict resolution mechanism that gives you two basic options: either let Bucardo handle conflicts automatically (the default option), or abort the sync and resolve them manually. This is the most critical part of the migration process, so let’s analyze it further.</p><p> 想象一下，两位客户试图为同一日期预订同一个房子。如果他们都尝试在完全相同的时间内完成，并且每个都指向不同的数据库，则可能发生冲突。 Bucardo附带一个冲突解决机制，为您提供了两个基本选项：让Bucardo处理冲突（默认选项），或中止同步并手动解决它们。这是迁移过程中最关键的部分，因此让我们进一步分析。</p><p> If your table has an auto-incremented ID as a primary key, Postgres will automatically pick the next ID from the corresponding sequence. Bucardo syncs sequences as well. Assume that in the above example you have a  bookings table with an auto-incremented ID as a PK, and that the latest record ID is 42. Concurrent inserts happen and two different records are created in both databases, both having 43 as a PK but different data. If you let Bucardo handle the conflict, it will keep only the latest one and delete the other. You will end up with a missing booking that appeared successful for your client. Your database will be in a valid state, but you will have lost data that is unable to be recovered. This is a dead end!</p><p> 如果您的表具有自动递增的ID作为主键，Postgres将自动从相应的序列中选择下一个ID。 Bucardo同步序列也是如此。假设在上面的例子中，您将具有自动递增ID作为PK的预订表，并且最新的录制ID为42.并发插入发生，两个数据库中创建了两个不同的记录，两个数据库都是一个pk但是不同的数据。如果让Bucardo处理冲突，它将只保留最新的一个并删除另一个。您最终会丢失遗失的预订，这些预订对于您的客户来说也是成功的。您的数据库将处于有效状态，但您将丢失无法恢复的数据。这是一个死胡同！</p><p> Before jumping into the solution, let’s consider another scenario. Assume that your table uses UUIDs as a PK. Replaying the above scenario with the concurrent bookings would create two distinct records with two distinct PKs in the two databases. This time no conflicts occur. Bucardo will successfully sync both records in both databases, but your data would still be invalid from the business perspective, since you can’t book the same house twice. So it is clear at this point that database validity does not guarantee you valid data from the business perspective. You need to be careful how you handle conflicts so your customers won’t experience problems down the road.</p><p> 在跳入解决方案之前，让我们考虑另一种情况。假设您的表格使用UUID作为PK。使用并发预订重播上述方案将创建两个不同的记录，两个数据库中有两个不同的PKS。这次没有发生冲突。 Bucardo将成功同步两个数据库中的记录，但您的数据仍然无法从业务角度无效，因为您无法预订同一所房子两次。因此，目前可以清楚地清楚，数据库有效性并不保证您从业务角度上有效的数据。您需要小心您处理冲突，因此您的客户不会在道路上遇到问题。</p><p> Bucardo supports custom resolution strategies. You could program your own strategy based on your business needs, but this can quickly get too complex and too time consuming. Another approach is to create your own tools to detect and resolve data violations during the migration. This is no easy task: it must be designed based on the complexity of your data, and it will likely require too much development effort.</p><p> Bucardo支持自定义分辨率策略。您可以根据您的业务需求编程自己的策略，但这可以很快得到太复杂和太耗时。另一种方法是创建自己的工具来检测和解决迁移期间的数据违规。这不是一项简单的任务：必须根据数据的复杂性设计，可能需要太多的开发工作。 </p><p> Our solution was to make sure that conflicts won’t happen at all by achieving two conditions before beginning migration. First, we worked to minimize the transition time between the databases in order to minimize conflict probability. This was achieved by scripting the reconfiguration of the apps to point to the new database, one instance at a time, but for all the different apps in parallel. The second, and most important step, was that just before we started switching apps to the new database, we revoked write permissions from the app users in the old database. This way we could be sure that conflicts would be impossible, with the trade-off of a small amount of time where a percentage of database writes would fail. This - of course - requires your applications to gracefully handle failed database writes. Your applications should do this independently from any database migration, since this is critical for production environments.</p><p>我们的解决方案是通过在开始迁移之前实现两个条件，确保冲突根本不会发生。首先，我们努力最小化数据库之间的过渡时间，以最大限度地减少冲突概率。这是通过跨对应用程序的重新配置来指向新数据库，一次实例来实现这一点，但是对于并行的所有不同应用程序。第二个和最重要的步骤是，就在我们开始将应用程序切换到新数据库之前，我们从旧数据库中的App用户撤消了写入权限。这样，我们可以确保冲突是不可能的，在少量时间内的少量时间下的权衡将失败。这 - 当然 - 要求您的应用程序优雅地处理失败的数据库写入。您的应用程序应独立于任何数据库迁移执行此操作，因为这对生产环境至关重要。</p><p>    In this section we will present the steps we followed and the script each one of these corresponds to. We have uploaded our code to this  GitHub repository, which we will break down into pieces below.</p><p>    在本节中，我们将介绍我们遵循的步骤，并且脚本每个其中一个对应于。我们已将代码上载到此GitHub存储库，我们将分解为下面的碎片。</p><p>  Spin up a new instance (EC2 in our case). The instruction will assume you run Debian OS.</p><p>  旋转新实例（在我们的情况下EC2）。该指令将假设您运行Debian OS。</p><p>    (Optional) If you have previously used Bucardo in the source database, you may need to clean the old triggers by running the  uninstall_bucardo.sh. Before you run it, take a look at the  uninstall.template that we generated based on our database. You need to list all your tables there.</p><p>    （可选）如果您之前使用过源数据库中的Bucardo，则可能需要通过运行uninstall_bucdo.sh来清理旧触发器。在您运行之前，请查看我们基于我们的数据库生成的uninstall.template。您需要在那里列出所有表格。</p><p> You need to manually run  $ bucardo install in order to complete local Bucardo installation.</p><p> 您需要手动运行$ Bucardo安装以完成本地Bucardo安装。</p><p>  Take a good look at the  configure.sh script. Here you will need to edit the script in order to match your migration scenario. You need to define descriptive names for the Bucardo objects and specify your excluded tables or omit this option. After you understand what this script does, you can proceed to run it. The script does the following: Sets up  .pgpass file and a Bucardo alias command in order to avoid interruptions from interactive prompts that ask for your passwords during the process</p><p>  仔细查看Configure.sh脚本。在这里，您需要编辑脚本以匹配迁移方案。您需要为Bucardo对象定义描述性名称，并指定您的排除表或省略此选项。在您了解此脚本所做的操作后，您可以继续运行它。脚本执行以下操作：设置.pgpass文件和bucardo alias命令，以避免在进程中询问密码的交互式提示中断</p><p> Configures Bucardo databases,  herds,  database groups and  sync. If you need to get more familiar with the Bucardo object types, there is  a list in their documentation page.</p><p> 配置Bucardo数据库，群体，数据库组和同步。如果您需要更熟悉Bucardo对象类型，则文档页面中有一个列表。 </p><p> Initializes an empty database in the new Postgresql host and creates the users by  running this script. You need to edit the script to specify your roles here. Passwords are retrieved by the  vars.sh file we sourced earlier.</p><p>在新PostgreSQL主机中初始化一个空数据库，并通过运行此脚本创建用户。您需要编辑脚本以在此指定您的角色。我们早先源的vars.sh文件检索密码。</p><p>   Transfers the database data in a compressed format. While data is transferred and drift starts to pile up, Bucardo will save it locally and replay it once the autokick flag changes value</p><p>   以压缩格式传输数据库数据。虽然数据被传输并漂移开始堆积，但是Bucardo将在本地保存并重新扮演一旦Autokick标志改变值</p><p> Resets the value of the autokick flag in order for the local caching to stop and then reloads the configuration in order for the sync to respect the new value</p><p> 重置Autokick标志的值，以便将本地缓存停止，然后重新加载配置，以便同步尊重新值</p><p> Now that the continuous sync is in-place, it is time to start moving the apps in the new database. For us, this was done by changing the application parameters in the configuration server and then redeploying them one by one. During this step, we needed to make users’ permissions read-only in the old database. Once the first instance of our apps connected to the new database, we changed the permissions in the old one by running the  revoke_write_access_from_old_db.sql script. Timing is critical at this point.</p><p> 现在连续同步就是就地，是时候开始在新数据库中移动应用程序了。对我们来说，这是通过在配置服务器中更改应用程序参数然后将其重新部署一个逐一的应用程序来完成。在此步骤中，我们需要在旧数据库中使用户的权限。一旦我们的应用程序连接到新数据库，我们通过运行Revoke_Write_Access_from_old_db.sql脚本更改了旧版本中的权限。定时在这一点上至关重要。</p><p>  While you have sync running you should verify data replication. We did it by using the forking  pgdatadiff tool. We also extended it by allowing the data diff to  exclude tables.</p><p>  虽然您有同步运行，但应验证数据复制。我们通过使用叉子PGDataDiff工具来完成它。我们还通过允许数据差异排除表来扩展它。</p><p> After you have switched all apps to the new database, you can stop the Bucardo sync and dismiss its machine. You should once again run  uninstall_bucardo.sh in order to clean-up your new database from the triggers.</p><p> 将所有应用切换到新数据库后，您可以停止Bucardo同步并解雇其计算机。您应该再次运行uninstall_bucardo.sh，以便从触发器清理新数据库。</p><p>  Migrating your postgresql database to a new instance comes with great challenges. No matter the tool you chose to do it, the challenges you will face remain the same:</p><p>  将PostgreSQL数据库迁移到新实例具有巨大的挑战。无论你选择这样做的工具，你将面临的挑战保持不变： </p><p>  In this article we describe how we solved them. One of the major difficulties we had was the absence of a similar tutorial online, so we had to improvise and iterate through our solution many times until we did it correctly. Your feedback is needed to improve the process and make it valuable for others who might face the same problems.</p><p>在本文中，我们描述了我们如何解决它们。我们缺少的主要困难之一是在线缺乏同类教程，因此我们必须多次通过我们的解决方案即兴创作和迭代，直到我们正确地完成。您需要您的反馈来改进过程，并使其对可能面临同样问题的其他人有价值。</p><p>   The beginning of 2020 found us using two Postgres 9.5 instances that we had been using since the very early days of Blueground. In January 2020, we had to dismiss old instances and use new ones because Amazon was about to  migrate to new SSL/TLS certificates. This migration ended up with a recoverable data loss for us, which cost us a few hard days to fix. What went wrong was that we trusted Bucardo to sync our drift automatically, which - as mentioned - was buggy and failed. This year, we had to do it again, because of  Postgres 9.5 EOL date, or else they would have been forcibly upgraded by AWS. This time we were determined to pay attention to every little detail. We believed we could do it fast, reliably, and fail-safe, and we did it.</p><p>   2020年初发现我们使用了从蓝色初期以来我们使用过的两篇文章9.5实例。 2020年1月，我们不得不解雇旧实例并使用新的实例，因为亚马逊即将迁移到新的SSL / TLS证书。这种迁移最终有了可收回的数据丢失，这为我们花了几个艰难的日子来解决。出错的是，我们信任Bucardo自动同步我们的漂移，如上所述 - 是错误的，失败了。今年，我们不得不再次这样做，因为Postgres 9.5 EOL日期，否则他们将被AWS强行升级。这次我们决心关注每一个细节。我们相信我们可以快速，可靠地和失败安全，我们做到了。</p><p>  First of all, we need to explain why we didn’t let Amazon upgrade our databases on-the-fly, without us intervening at all. Amazon offers an  upgrade process, but it has some serious disadvantages when compared to migrating to a new database instance:</p><p>  首先，我们需要解释为什么我们没有让亚马逊在飞行中升级我们的数据库，而无需我们根本。亚马逊提供升级过程，但与迁移到新数据库实例相比，它有一些严重的缺点：</p><p> AWS RDS does not offer you an instant rollback option. With two instances during the migration process, rollback would be a simple reconfiguration of our apps to point to the old database. This was a huge fail-safe measure during the whole process.</p><p> AWS RDS不向您提供即时回滚选项。在迁移过程中有两个实例，回滚将是我们应用程序的简单重新配置，以指向旧数据库。这是整个过程中的巨大故障安全措施。</p><p> Transparency. If RDS had failed to upgrade the database, had delays, or performance issues, we couldn’t do any action at all. In production environments you need to have a solid rollback plan in case anything goes south.</p><p> 透明度。如果RDS未能升级数据库，则有延迟或性能问题，我们根本无法执行任何行动。在生产环境中，您需要有一个坚实的回滚计划，以防任何南方。</p><p> Some features that we wanted were not available in the current instances, like encryption-at-rest and RDS insights.</p><p> 我们想要的一些功能在当前的情况下，如加密 - 休息和RDS Insights。</p><p> We went with Bucardo because we wanted a solution sandboxed within our VPC, so production data never gets exposed on the Internet. The result was a successful migration without the risk of losing data. The migration process had a total duration of less than 2 hours, which was considered a relative success!</p><p> 我们与Bucardo一起去，因为我们希望在我们的VPC中解决一个Sandboxed，因此生产数据永远不会在互联网上暴露。结果是一个成功的迁移，没有丢失数据的风险。迁移过程的总持续时间不到2小时，被认为是相对成功！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://engineering.theblueground.com/blog/zero-downtime-postgres-migration-done-right/">https://engineering.theblueground.com/blog/zero-downtime-postgres-migration-done-right/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/postgres/">#postgres</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>