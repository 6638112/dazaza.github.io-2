<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Linux服务Polkit中发布了7岁的特权升级错误 Patch Released for 7-Year-Old Privilege Escalation Bug In Linux Service Polkit</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Patch Released for 7-Year-Old Privilege Escalation Bug In Linux Service Polkit<br/>在Linux服务Polkit中发布了7岁的特权升级错误 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-15 23:07:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/b466617a2cebbdfdb2ef667f5f2ef27f.png"><img src="http://img2.diglog.com/img/2021/6/b466617a2cebbdfdb2ef667f5f2ef27f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>polkit is a system service installed by default on many Linux distributions. It’s used by  systemd, so any Linux distribution that uses systemd also uses polkit. As a member of  GitHub Security Lab, my job is to help improve the security of open source software by finding and reporting vulnerabilities. A few weeks ago, I found a privilege escalation vulnerability in polkit. I coordinated the disclosure of the vulnerability with the polkit maintainers and with  Red Hat’s security team. It was publicly disclosed, the fix was released on June 3, 2021, and it was assigned  CVE-2021-3560.</p><p>Polkit是默认情况下安装的系统服务，在许多Linux发行版上安装。它由SystemD使用，因此使用SystemD的任何Linux发行版也使用Polkit。作为GitHub安全实验室的成员，我的工作是通过查找和报告漏洞来帮助提高开源软件的安全性。几周前，我发现了Polkit的特权升级脆弱性。我协调了Polkit维护者和Red Hat的安全团队的漏洞披露。它公开披露，修复已于6月3日，2021年6月3日发布，并分配了CVE-2021-3560。</p><p> The vulnerability enables an unprivileged local user to get a root shell on the system. It’s easy to exploit with a few standard command line tools, as you can see in this  short video. In this blog post, I’ll explain how the exploit works and show you where the bug was in the source code.</p><p> 该漏洞使未经特权的本地用户能够在系统上获取根外壳。使用少数标准命令行工具很容易利用，正如您在此短视频中看到的那样。在这个博客文章中，我将解释漏洞利用如何工作，并向您展示错误的源代码中的错误。</p><p>      The bug I found was quite old. It was introduced seven years ago in commit  bfa5036 and first shipped with polkit version 0.113. However, many of the most popular Linux distributions didn’t ship the vulnerable version until more recently.</p><p>      我发现的错误很旧。它在七年前推出了Commit BFA5036，首先用Polkit版本0.113发布。但是，许多最受欢迎的Linux发行版直到最近没有发货。</p><p> The bug has a slightly different history on  Debian and its derivatives (such as  Ubuntu), because Debian uses a  fork of polkit with a different version numbering scheme. In the Debian fork, the bug was introduced in commit  f81d021 and first shipped with version 0.105-26. The most recent stable release of Debian,  Debian 10 (“buster”), uses version 0.105-25, which means that it isn’t vulnerable. However, some Debian derivatives, such as Ubuntu, are based on  Debian unstable, which is vulnerable.</p><p> 该错误在Debian及其衍生品（如ubuntu）上有一个略有不同的历史记录，因为Debian使用具有不同版本编号方案的Polkit叉。在Debian Fork中，Bug于Commit F81D021引入，并首次发布版本0.105-26。 Debian，Debian 10（“Buster”）最近稳定的发布，使用版本0.105-25，这意味着它并不脆弱。但是，一些Debian衍生品，如Ubuntu，基于Debian不稳定，这是脆弱的。</p><p> Here’s a table with a selection of popular distributions and whether they’re vulnerable (note that this isn’t a comprehensive list):</p><p> 这是一张具有各种流行分布的表，以及它们是否易受攻击（请注意这不是一个全面的列表）：</p><p>   polkit is the system service that’s running under the hood when you see a dialog box like the one below:</p><p>   POLKIT是在引擎盖下运行的系统服务，当您看到如下所示的对话框时：</p><p>  It essentially plays the role of a judge. If you want to do something that requires higher privileges—for example, creating a new user account—then it’s polkit’s job to decide whether or not you’re allowed to do it. For some requests, polkit will make an instant decision to allow or deny, and for others it will pop up a dialog box so that an administrator can grant authorization by entering their password.</p><p>  它基本上扮演法官的角色。如果您想做一些需要更高权限的东西 - 例如，创建一个新的用户帐户 - 那么它是Polkit的作业，以决定您是否允许这样做。对于某些请求，Polkit将使即时决定允许或拒绝，并且对于其他人来说，它将弹出一个对话框，以便通过输入密码来授予授权。 </p><p> The dialog box might give the impression that polkit is a graphical system, but it’s actually a background process. The dialog box is known as an  authentication agent and it’s really just a mechanism for sending your password to polkit. To illustrate that polkit isn’t just for graphical sessions, try running this command in a terminal:</p><p>该对话框可能会使Polkit是一个图形系统的印象，但它实际上是一个后台过程。该对话框称为身份验证代理，它真的只是将密码发送给Polkit的机制。为了说明Polkit不仅适用于图形会话，请尝试在终端中运行此命令：</p><p>  pkexec is a similar command to   sudo, which enables you to run a command as root. If you run  pkexec in a graphical session, it will pop up a dialog box, but if you run it in a text-mode session such as SSH then it starts its own text-mode authentication agent:</p><p>  pkexec是sudo的类似命令，它使您可以像root一样运行命令。如果在图形会话中运行pkexec，则会弹出一个对话框，但如果在文本模式会话中运行它，例如ssh，则启动自己的文本模式身份验证代理：</p><p> $ pkexec reboot==== AUTHENTICATING FOR org.freedesktop.policykit.exec ===Authentication is needed to run `/usr/sbin/reboot&#39; as the super userAuthenticating as: Kevin Backhouse,,, (kev)Password:</p><p> $ pkexec reboot ====验证org.freedesktop.policykit.exec ===验证是否需要运行`/ usr / sbin / reboot＆＃39;作为Super UserauthenticatingAs：Kevin Backhouse ,,,（kev）密码：</p><p> Another command that you can use to trigger  polkit from the command line is   dbus-send. It’s a general purpose tool for sending D-Bus messages that’s mainly used for testing, but it’s usually installed by default on systems that use D-Bus. It can be used to simulate the D-Bus messages that the graphical interface might send. For example, this is the command to create a new user:</p><p> 您可以使用从命令行触发Polkit的另一个命令是DBUS-SEND。它是发送主要用于测试的D-Bus消息的通用工具，但通常在使用D-Bus的系统上默认安装。它可用于模拟图形界面可能发送的D-Bus消息。例如，这是创建新用户的命令：</p><p>  If you run that command in a graphical session, an authentication dialog box will pop up, but if you run it in a text-mode session such as  SSH, then it fails immediately. That’s because, unlike  pkexec,  dbus-send does not start its own authentication agent.</p><p>  如果在图形会话中运行该命令，将弹出身份验证对话框，但如果在文本模式会话中运行它，例如SSH，则会立即失败。那是因为，与pkexec不同，dbus-send不会启动自己的身份验证代理。</p><p>  The vulnerability is surprisingly easy to exploit. All it takes is a few commands in the terminal using only standard tools like   bash,   kill, and   dbus-send.</p><p>  脆弱性令人惊讶地易于利用。只需使用Bash，kill和dbus-send等标准工具，所有所需的是终端中的一些命令。</p><p> The proof of concept (PoC) exploit I describe in this section depends on two packages being installed:  accountsservice and  gnome-control-center. On a graphical system such as Ubuntu Desktop, both of those packages are usually installed by default. But if you’re using something like a non-graphical RHEL server, then you might need to install them, like this:</p><p> 概念证明（PoC）Inspoit我在本节中介绍取决于已安装的两个软件包：AccountSservice和Gnome-Control-Center。在诸如Ubuntu桌面之类的图形系统上，默认情况下通常安装这两个包。但是，如果您使用的是非图形RHEL服务器，那么您可能需要安装它们，如下所示： </p><p>  Of course, the vulnerability doesn’t have anything specifically to do with either  accountsservice or  gnome-control-center. They’re just polkit clients that happen to be convenient vectors for exploitation. The reason why the PoC depends on  gnome-control-center and not just  accountsservice is subtle—I’ll explain that  later.</p><p>当然，该漏洞没有任何与AccountSservice或Gnome-Control-Center有关的东西。他们只是恰好是剥削的便利载体的光伏客户。 PoC取决于Gnome-Control-Center的原因，而不仅仅是SupplayService是微妙的 - 我会稍后解释一下。</p><p> To avoid repeatedly triggering the authentication dialog box (which can be annoying), I recommend running the commands from an SSH session:</p><p> 要避免反复触发身份验证对话框（这可能很烦人），我建议您从SSH会话运行命令：</p><p>  The vulnerability is triggered by starting a  dbus-send command but killing it while polkit is still in the middle of processing the request. I like to think that it’s theoretically possible to trigger by smashing Ctrl+C at just the right moment, but I’ve never succeeded, so I do it with a small amount of bash scripting instead. First, you need to measure how long it takes to run the  dbus-send command normally:</p><p>  通过启动DBUS-SEND命令但在PORKIT仍处于处理请求的中间而终止时，触发该漏洞。我喜欢认为它在理论上是可以在正确的时刻粉碎Ctrl + C的理论上，但我从未成功过，所以我用少量的Bash脚本来这样做。首先，您需要测量运行DBUS-SEND命令的时间正常需要多长时间：</p><p>    That took 16 milliseconds for me, so that means that I need to kill the  dbus-send command after approximately 8 milliseconds:</p><p>    对我来说，这需要16毫秒，这意味着我需要在大约8毫秒后杀死dbus-send命令：</p><p> dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:boris string:&#34;Boris Ivanovich Grishenko&#34; int32:1 &amp; sleep 0.008s ; kill $!</p><p> dbus-send --system --dest = org.freedesktop.accounts  -  type = method_call --print-reply / org / freedesktop /帐户org.freedesktop.accounts.createuser字符串：鲍里斯字符串：＆＃34; Boris Ivanovich Grishenko＆ ＃34; INT32：1＆amp;睡眠0.008s;杀$！</p><p> You might need to run that a few times, and you might need to experiment with the number of milliseconds in the delay. When the exploit succeeds, you’ll see that a new user named  boris has been created:</p><p> 您可能需要运行几次，并且您可能需要尝试延迟中毫秒的数量。当漏洞利用成功时，您将看到已创建名为Boris的新用户：</p><p>  Notice that  boris is a member of the  sudo group, so you’re already well on your way to full privilege escalation. Next, you need to set a password for the new account. The D-Bus interface expects a hashed password, which you can create using  openssl:</p><p>  请注意，Boris是Sudo集团的成员，因此您已经很好地前往全方位升级。接下来，您需要为新帐户设置密码。 D-Bus接口期望散列密码，您可以使用openssl创建： </p><p>  Now you just have to do the same trick again, except this time call the  SetPassword D-Bus method:</p><p>现在，您只需再次执行相同的技巧，除此之外，致电SetPassword D-Bus方法：</p><p> dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User1002 org.freedesktop.Accounts.User.SetPassword string:&#39;$5$Fv2PqfurMmI879J7$ALSJ.w4KTP.mHrHxM2FYV3ueSipCf/QSfQUlATmWuuB&#39; string:GoldenEye &amp; sleep 0.008s ; kill $!</p><p> dbus-send --system --dest = org.freedesktop.accounts  -  type = method_call --print-reply / org / freedesktop /帐户/ user1002 org.freedesktop.accounts.user.setpassword字符串：＆＃39; $ 5 $ fv2pqfurmmi879j7 $ alsj.w4ktp.mhrhxm2fyv3esipcf / qsfqulatmwuub＆＃39;字符串：Goldeneye＆amp;睡眠0.008s;杀$！</p><p> Again, you might need to experiment with the length of the delay and run it several times until it succeeds. Also, note that you need to paste in the correct user identifier (UID), which is “1002” in this example, plus the password hash from the  openssl command.</p><p> 同样，您可能需要尝试延迟的长度并在成功之前运行几次。此外，请注意，在此示例中，您需要粘贴在正确的用户标识符（UID）中，即“1002”，从openssl命令中加上密码哈希。</p><p>     To help explain the vulnerability, here’s a diagram of the five main processes involved during the  dbus-send command:</p><p>     要帮助解释漏洞，这是DBUS-SEND命令期间涉及的五个主要进程的图：</p><p>  The two processes above the dashed line— dbus-send and the authentication agent—are unprivileged user processes. Those below the line are privileged system processes. In the center is  dbus-daemon, which handles all of the communication: the other four processes communicate with each other by sending D-Bus messages.</p><p>  虚线 -  DBUS-SEND和身份验证代理上方的两个进程是非特权的用户进程。线以下的人是特权系统进程。在中心是DBUS-守护程序，它处理所有通信：其他四个过程通过发送D-Bus消息来彼此通信。</p><p> dbus-daemon plays a very important role in the security of polkit, because it enables the four processes to communicate securely and check each other’s credentials. For example, when the authentication agent sends an authentication cookie to polkit, it does so by sending it to the  org.freedesktop.PolicyKit1 D-Bus address. Since that address is only allowed to be registered by a root process, there is no risk of an unprivileged process intercepting messages.  dbus-daemon also assigns every connection a “unique bus name:” typically something like “:1.96”. It’s a bit like a process identifier (PID), except without being vulnerable to  PID recycling attacks. Unique bus names are currently chosen from a 64-bit range, so there’s no risk of a vulnerability caused by a name being reused.</p><p> DBus-守护程序在Polkit的安全性中起着非常重要的作用，因为它使四个进程能够安全地沟通并检查彼此的凭据。例如，当认证代理向Polkit发送身份验证cookie时，它会通过将其发送到org.freedesktop.policykit1 d-bus地址来实现。由于该地址仅被允许通过根进程注册，因此没有虚拟化进程拦截消息的风险。 DBus-守护程序还分配了每个连接A“唯一总线名称：”通常是“：1.96”。除了不容易受到PID回收攻击的情况下，它有点像进程标识符（PID）。目前从64位范围内选择唯一的总线名称，因此没有被重用的名称引起的漏洞的风险。</p><p>  accounts-daemon receives the D-Bus message from  dbus-send. The message includes the unique bus name of the sender. Let’s assume it’s “:1.96”. This name is attached to the message by  dbus-daemon and cannot be forged.</p><p>  帐户 - 守护程序从DBUS-SEND接收D-BUS消息。该消息包括发件人的唯一总线名称。让我们假设它是“：1.96”。此名称由dbus-emon附加到邮件中，无法伪造。 </p><p>   If the UID of connection :1.96 is “0,” then polkit immediately authorizes the request. Otherwise, it sends the authentication agent a list of administrator users who are allowed to authorize the request.</p><p>如果连接的UID：1.96是“0”，那么Polkit立即授权请求。否则，它会发送验证代理允许授权请求的管理员用户列表。</p><p>  Why does killing the  dbus-send command cause an authentication bypass? The vulnerability is in step four of the sequence of events listed above. What happens if polkit asks  dbus-daemon for the UID of connection :1.96, but connection :1.96 no longer exists?  dbus-daemon handles that situation correctly and returns an error. But it turns out that polkit does not handle that error correctly. In fact, polkit mishandles the error in a particularly unfortunate way: rather than rejecting the request, it treats the request as though it came from a process with UID 0. In other words, it immediately authorizes the request because it thinks the request has come from a root process.</p><p>  为什么杀死DBUS-SEND命令会导致身份验证旁路？该漏洞是上面列出的事件序列的步骤四。如果Polkit向DBus-守护程序询问连接的UID：1.96，但连接：1.96不再存在？ DBUS-Daemon正确处理这种情况并返回错误。但事实证明，Polkit不会正确处理该错误。事实上，Polkit以特别是令人不幸的方式解释了错误：而不是拒绝请求，它处理请求，好像它来自一个使用UID 0的过程。换句话说，它立即授权该请求，因为它认为请求已提出要求从根过程中。</p><p> Why is the timing of the vulnerability non-deterministic? It turns out that polkit asks  dbus-daemon for the UID of the requesting process multiple times, on different codepaths. Most of those codepaths handle the error correctly, but one of them doesn’t. If you kill the  dbus-send command early, it’s handled by one of the correct codepaths and the request is rejected. To trigger the vulnerable codepath, you have to disconnect at just the right moment. And because there are multiple processes involved, the timing of that “right moment” varies from one run to the next. That’s why it usually takes a few tries for the exploit to succeed. I’d guess it’s also the reason why the bug wasn’t previously discovered. If you could trigger the vulnerability by killing the  dbus-send command immediately, then I expect it would have been discovered a long time ago, because that’s a much more obvious thing to test for.</p><p> 为什么漏洞的时间是非决定性的？事实证明，Polkit在不同的CodePath上向DID询问DBUS-守护程序的UID。大多数那些CodePaths正确地处理错误，但其中一个没有。如果早期杀死DBUS-SEND命令，它由其中一个正确的CodePath处理，请求被拒绝。要触发漏洞的Codepath，您必须在正确的时刻断开连接。并且因为有多个进程涉及，所以“正确时刻”的时间从一个运行到下一个时变化。这就是为什么它通常需要几点努力实现成功。我猜这也是先前未发现错误的原因。如果您可以立即杀死DBUS-SEND命令可以触发漏洞，那么我希望它会很久以前发现，因为这是测试的更明显的事情。</p><p> The function which asks  dbus-daemon for the UID of the requesting connection is named   polkit_system_bus_name_get_creds_sync:</p><p> 向请求连接的UID询问DBUS-守护程序的功能名为polkit_system_bus_name_get_creds_sync：</p><p>  The behavior of   polkit_system_bus_name_get_creds_sync is strange, because when an error occurs, the function sets the error parameter but still returns  TRUE. It wasn’t clear to me, when I wrote my  bug report, whether that was a bug or a deliberate design choice. (It turns out that it was a bug, because the polkit developers have  fixed the vulnerability by returning  FALSE on error.) My uncertainty arose from the fact that  almost all the callers of  polkit_system_bus_name_get_creds_sync don’t just check the Boolean result, but also check that the error value is still  NULL before proceeding. The cause of the vulnerability was that the error value wasn’t checked in the following stack trace:</p><p>  polkit_system_bus_name_get_creds_sync的行为是奇怪的，因为发生错误时，函数设置错误参数，但仍然返回true。当我写下我的错误报告时，这对我来说并不清楚，这是一个错误还是刻意的设计选择。 （事实证明这是一个错误，因为Polkit开发人员通过返回错误时，返回错误时，我的不确定性来自Polkit_system_bus_name_get_creds_sync的几乎所有呼叫者_creds_sync，而且也不只是检查布尔结果，还要检查在继续之前，错误值仍为null。漏洞的原因是在以下堆栈跟踪中未选中错误值：</p><p> 0 in polkit_system_bus_name_get_creds_sync of  polkitsystembusname.c:3881 in polkit_system_bus_name_get_user_sync of  polkitsystembusname.c:5112 in polkit_backend_session_monitor_get_user_for_subject of  polkitbackendsessionmonitor-systemd.c:3033 in check_authorization_sync of  polkitbackendinteractiveauthority.c:11214 in check_authorization_sync of  polkitbackendinteractiveauthority.c:12275 in polkit_backend_interactive_authority_check_authorization of  polkitbackendinteractiveauthority.c:9816 in polkit_backend_authority_check_authorization of  polkitbackendauthority.c:2277 in server_handle_check_authorization of  polkitbackendauthority.c:7907 in server_handle_method_call of  polkitbackendauthority.c:1272</p><p> 0在polkitsystembusname.c的polkit_system_bus_name_get_creds_sync：3881在polkitsystembusname.c的polkit_system_bus_name_get_user_sync：5112在polkitbackendsessionmonitor-systemd.c的polkit_backend_session_monitor_get_user_for_subject：3033在polkitbackendinteractiveauthority.c的check_authorization_sync：11214在polkitbackendinteractiveauthority.c的check_authorization_sync：12275在polkitbackendinteractiveauthority.c的polkit_backend_interactive_authority_check_authorization： 9816在polkit_backend_authority_check_check_achorzization的polkitbackendauthority.c：2277在server_handle_check_achorization的polkitbackendauthority.c：7907在server_handle_method_call的polkitbackendauthority.c：1272</p><p>  /* every subject has a user; this is supplied by the client, so we rely * on the caller to validate its acceptability. */user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv-&gt;session_monitor, subject, NULL, error);if (user_of_subject == NULL) goto out;/* special case: uid 0, root, is _always_ authorized for anything */if (POLKIT_IS_UNIX_USER (user_of_subject) &amp;&amp; polkit_unix_user_get_uid (POLKIT_UNIX_USER (user_of_subject)) == 0) { result = polkit_authorization_result_new (TRUE, FALSE, NULL); goto out; }</p><p>  / *每个主题都有一个用户;这由客户提供，因此我们依靠呼叫者验证其可接受性。 * / user_of_subject = polkit_backend_session_monitor_get_user_for_subject（priv-＆gt; session_monitor，主题，null，错误）;如果（user_of_subject == null）转到; / *特殊情况：UID 0，root，是oxalways_授权用于任何* / if（polkit_is_unix_user（ user_of_subject）＆amp;＆amp; polkit_unix_user_get_uid（polkit_unix_user（user_of_subject））== 0）{结果= polkit_authorization_result_new（true，false，null）;转到; } </p><p>   I mentioned earlier that my PoC depends on  gnome-control-center being installed, in addition to  accountsservice. Why is that? The PoC doesn’t use  gnome-control-center in any visible way, and I didn’t even realize that I was depending on it when I wrote the PoC! In fact, I only found out because the Red Hat security team couldn’t reproduce my PoC on RHEL. When I tried it for myself on a RHEL 8.4 VM, I also found that the PoC didn’t work. That was puzzling, because it was working beautifully on Fedora 32 and CentOS Stream. The crucial difference, it turned out, was that my RHEL VM was a non-graphical server with no GNOME installed. So why does that matter? The answer is  policykit.imply annotations.</p><p>我之前提到过我的PoC依赖于accountService的安装，而不是安装了Gnome-Control-Center。这是为什么？ PoC不以任何可见的方式使用Gnome-Control-Center，我甚至没有意识到当我写下PoC时，我取决于它！事实上，我只发现了因为红帽安全团队无法重现我的poc。当我在RHEL 8.4 VM上尝试自己尝试它时，我也发现POC不起作用。这是令人费解的，因为它在Fedora 32和Centos Stream上工作得很好。事实证明，这是一个关键差异，是我的RHEL VM是一个没有安装GNOME的非图形服务器。那么为什么这么想？答案是policykit.imply注释。</p><p> Some polkit actions are essentially equivalent to each other, so if one has already been authorized then it makes sense to silently authorize the other. The GNOME settings dialog is a good example:</p><p> 一些Polkit操作基本上相同，因此如果已经授权，则默默授权对方有意义。 GNOME设置对话框是一个很好的例子：</p><p>  After you’ve clicked the “Unlock” button and entered your password, you can do things like adding a new user account without having to authenticate a second time. That’s handled by a  policykit.imply annotation, which is defined in this  config file:</p><p>  在点击“解锁”按钮并输入密码后，您可以执行类似于添加新用户帐户的内容，而无需第二次验证。这是由policykit.imply Annotation处理，这些注释在此配置文件中定义：</p><p>    In other words, if you’re authorized to perform  controlcenter admin actions, then you’re also authorized to perform  accountsservice admin actions.</p><p>    换句话说，如果您被授权执行ControlCenter管理员操作，那么您还授权执行ContainService管理员操作。</p><p> When I attached  GDB to polkit on my RHEL VM, I found that I wasn’t seeing the vulnerable stack trace that I listed earlier. Notice that step four of the stack trace is a recursive call from  check_authorization_sync to itself. That happens on  line 1227, which is where polkit checks the  policykit.imply annotations:</p><p> 当我在rhel VM上附加GDB到Polkit时，我发现我没有看到我之前列出的弱势堆栈跟踪。请注意，堆栈跟踪中的步骤四是从Check_Authorization_sync到自身的递归调用。在第1227行发生，这是Polkit检查PolicyKit.implate注释的地方：</p><p> PolkitAuthorizationResult *implied_result = NULL;PolkitImplicitAuthorization implied_implicit_authorization;GError *implied_error = NULL;const gchar *imply_action_id;imply_action_id = polkit_action_description_get_action_id (imply_ad);/* g_debug (&#34;%s is implied by %s, checking&#34;, action_id, imply_action_id); */implied_result = check_authorization_sync (authority, caller, subject, imply_action_id, details, flags, &amp;implied_implicit_authorization, TRUE, &amp;implied_error);if (implied_result != NULL) { if (polkit_authorization_result_get_is_authorized (implied_result)) { g_debug (&#34; is authorized (implied by %s)&#34;, imply_action_id); result = implied_result; /* cleanup */ g_strfreev (tokens); goto out; } g_object_unref (implied_result); }if (implied_error != NULL) g_error_free (implied_error);</p><p> polkitauthorizationResult * implied_result = null; polkitimplicitauthorization inclied_impliced_authorization; gerror * millized_error = null; const gchar * imply_action_id; imply_action_id = polkit_action_description_get_action_id（imply_ad）; / * g_debug（＆＃34;％s由％s，checked＆＃34; action_id， imply_action_id）; * / millized_result = check_authorization_sync（权限，来电，主题，imply_action_id，详细信息，标志和amp; true_implicit_authorization，true，＆amp; millied_error）;如果（moplied_result！= null）{if（polkit_authorization_result_get_get_Is_Authorized（amplied_result））{g_debug（＆＃34 ;被授权（由％s）＆＃34;，imply_action_id）;结果= illiDed_result; / *清理* / g_strfreev（令牌）;转到; g_object_unref（implied_result）; }如果（implied_error！= null）g_error_free（implied_error）;</p><p> The authentication bypass depends on the error value getting ignored. It was ignored on  line 1121, but it’s still stored in the  error parameter, so it also needs to be ignored by the caller. The block of code above has a temporary variable named  implied_error, which is ignored when  implied_result isn’t null. That’s the crucial step that makes the bypass possible.</p><p> 身份验证旁路取决于忽略错误值。它在1121号线忽略，但它仍然存储在错误参数中，因此您还需要被呼叫者忽略。上面的代码块具有名为Implied_Error的临时变量，当ImpliDed_Result而不是null时，它会被忽略。这是使旁路成为可能的关键步骤。 </p><p> To sum up, the authentication bypass only works on polkit actions that are implied by another polkit action. That’s why my PoC only works if gnome- control-center is installed: it adds the  policykit.imply annotation that enables me to target  accountsservice. That does not mean that RHEL is safe from this vulnerability, though. Another attack vector for the vulnerability is   packagekit, which is installed by default on RHEL and has a suitable  policykit.imply annotation for the  package-install action.  packagekit is used to install packages, so it can be exploited to install  gnome-control-center, after which the rest of the exploit works as before.</p><p>总结一致，身份验证旁路仅适用于其他Polkit操作所暗示的Polkit操作。这就是为什么如果安装了GNOME-Control-Center，我的Poc只能有效：它会添加策略kit.implate annotation，使我能够实现accountsservice。然而，这并不意味着Rhel是安全的这个脆弱性。漏洞的另一个攻击矢量是ProdanceKit，它默认在RHEL上安装，并且具有适当的PolybleKit.imply Annotation为包安装操作。 PackageKit用于安装软件包，因此可以利用它来安装GNOME-Control-Center，之后exproit的其余部分都如前所述。</p><p>  CVE-2021-3560 enables an unprivileged local attacker to gain root privileges. It’s very simple and quick to exploit, so it’s important that you update your Linux installations as soon as possible. Any system that has polkit version 0.113 (or later) installed is vulnerable. That includes popular distributions such as RHEL 8 and Ubuntu 20.04.</p><p>  CVE-2021-3560启用一个未特权的本地攻击者来获得root权限。它非常简单快捷，漏洞利用，因此您可以尽快更新Linux安装。安装了Polkit版本0.113（或更高版本）的任何系统都很脆弱。包括流行分布，如Rhel 8和Ubuntu 20.04。</p><p> And if you like nerding out about security vulnerabilities (and how to fix them) check out some of the other work that the  Security Lab team is doing or follow us on  Twitter.</p><p> 如果您喜欢讨论安全漏洞（以及如何修复它们），请查看安全实验室团队正在在Twitter上执行或关注我们的其他一些工作。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/">https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/升级/">#升级</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/released/">#released</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/polkit/">#polkit</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>