<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>建立一个可伸缩的单块状物 Building a Scalable Monolith</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building a Scalable Monolith<br/>建立一个可伸缩的单块状物 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 22:22:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/12534878024f2b752df5037acf105cf1.jpeg"><img src="http://img2.diglog.com/img/2021/3/12534878024f2b752df5037acf105cf1.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Monolith or microservices?  The eternal question many software engineers face when having to design and deploy their brand new system. You will find diehard followers for both approaches. Some will tell you that  monoliths are the best thing you could have, as they are easy to deploy and maintain. Others will claim that monoliths are for “IT dinosaurs” and that they are hard to scale, look at the Googles, Amazons, and Netflixes of the world, they are all using microservices. The truth is that  there is no “one size fits all” solution, and each architecture will fit different purposes, systems and companies. For Google’s scale, of course it makes sense to use microservices, scaling and maintaining a monolith would be a complete nightmare. However, for applications and platforms with a few thousand daily users, a monolith may suffice.</p><p>单层或微服务？永恒的问题很多软件工程师在必须设计和部署全新系统时面临。您将找到两种方法的Diehard粉丝。有些人会告诉你巨石是你能拥有的最好的事情，因为它们很容易部署和维护。其他人会声称整料队是“IT恐龙”，并且他们很难规模，看看世界的谷歌，亚马逊和Netflix，它们都使用微服务。事实是，没有“一种尺寸适合所有”解决方案，每个架构都会适应不同的目的，系统和公司。对于谷歌的规模，当然，使用微服务，缩放和维护纪念碑是一个完整的噩梦。然而，对于具有几千用户的应用和平台，巨石可能就足够了。</p><p> But I am not writing this publication to make an argument for or against monoliths or microservices, but to challenge our assumptions and raise the following question: with the recent technological advancements,  can we finally design a “one size fits all” architecture able to support Amazon’s scale (OK, maybe Amazon is too much, let’s consider Slack), with the simplicity of deployment and maintenance of a “traditional” monolith?</p><p> 但我不是在写这个出版物，为巨大或微服务作出争论，而是为了挑战我们的假设并提出以下问题：随着最近的技术进步，我们最终可以设计一个能够支持的“一种尺寸适合所有”建筑亚马逊的规模（好吧，也许亚马逊太多了，让我们考虑松弛），以简单的部署和维护“传统”纪念？</p><p> “There is no industry consensus on whether either approach is strictly-better. Despite that ambivalence, there is general agreement of two points:</p><p> “无论做方面是否严格更好地就没有行业共识。尽管矛盾，但总协议分为两点：</p><p> Monoliths that exceed some threshold will be broken apart eventually. At a large enough scale, only a service-oriented design is workable.</p><p> 最终超过一些门槛的巨石将被分解。以足够大的规模，只有服务导向的设计是可行的。</p><p> There are only two options. It’s either service-oriented or a monolith, and you must choose.”</p><p> 只有两个选项。它是面向服务的或一巨石，你必须选择。“</p><p>  A monolith is a server-side system that runs everything in the same place. A monolithic application is usually a single program that starts up, listens to a few ports for network requests from end-users, gives service to these end-users, and eventually terminates.  Maintaining the infrastructure is easy, is just one server running an application. Scaling, on the other hand, may be hard. The fact that everything is in the same place means that launching a new replica of the application to spread the load between them may lead to inconsistencies or useless redundancy. Also, the code for a monolithic application is usually structured in the same repo, it is not divided in modules like is the case for microservices, where each service has its own repo. I don’t have a strong opinion on if this is good or bad, but it is what it is. An example of a monolithic application is the typical Django App we have all learned respect and love.</p><p>  单型是一个服务器端系统，在同一个地方运行一切。单片应用程序通常是启动的单个程序，侦听来自最终用户的网络请求的几个端口，为这些最终用户提供服务，并最终终止。维护基础架构很容易，只是运行应用程序的一个服务器。另一方面，缩放可能很难。一切都处于同一个地方的事实意味着启动应用程序的新副本以扩散它们之间的负载可能导致不一致或无用的冗余。此外，单片应用程序的代码通常在相同的repo中构建，它不会在模块中划分为微服务的情况，每个服务都有自己的回购。如果这是好的或坏的，我没有强烈的意见，但它是它的。单片应用程序的一个例子是我们拥有所有学到的尊重和爱的典型的Django应用程序。</p><p> Microservices architectures are just monoliths that have been broken down into smaller pieces. Instead of having a Django App responsible for serving the frontend of your app, exposing a REST API to interact with the whole system, and talk to your database, you have a set of services: an API of user authentication, a service to serve the frontend assets, an API to process payments, and the code of each of them is conveniently structured and maintained in its own repo. The reasoning behind this alternative design pattern is actually very sound.  By distributing the work among many different components, you make the system as a whole able to handle more requests than when we stuck all together in the same place. However, by doing so, we introduce more complexity, which requires more effort, and therefore often more people-power and more money. It is not the same to manage the infrastructure for a single big service, than for a bag of small interconnected services (potentially distributed).</p><p> MicroServices架构只是一块被分解成较小块的巨石。而不是拥有负责服务的Django应用程序，而是将REST API与整个系统进行交互，并与您的数据库交谈，您拥有一组服务：用户身份验证的API，服务为服务前端资产，用于处理付款的API，以及它们中的每一个的代码都是方便的结构和维护在自己的回购中。这种替代设计模式背后的推理实际上是非常的声音。通过在许多不同的组件之间分配工作，您将使系统作为一个能够处理更多的请求，而不是当我们粘在一起的地方。然而，通过这样做，我们介绍了更多的复杂性，这需要更多的努力，因此往往更多的人力和更多的钱。管理基础设施是单一大型服务的基础架构不一样，而不是用于小型互连服务（可能分布式）。 </p><p> “A distributed system is one in which the failure of  a  computer  you  didn’t  even  know  existed can render your own computer unusable.” -- Leslie Lamport</p><p>“分布式系统是您甚至没有知道的计算机的失败的系统可以呈现自己的计算机无法使用。” -  Leslie Lamport.</p><p> Some may argue, “but wait a moment, that makes sense for ‘traditional’ microservice architectures, but what about serverless functions”. Agree,  serverless architectures simplify many of the complexities introduced by microservice architectures, but they also introduce new challenges. The gains you may gain for the ease of maintenance may be eclipsed by serverless difficult testing (now you don’t need to test each service of the application and their integration, but each function and their integration), potential vendor lock-in (we have Docker as the “standard environment” for microservices, but we don’t have this for serverless functions, each vendor has its own offer and tooling to manage this). Serverless architectures are moving towards that “one size fits all” solution, but they may not be enough.</p><p> 有些人可能会争辩，“但等一下，这对”传统的“微服务架构来说是有道理的，但无服务器函数呢”。同意，无服务器架构简化了MicroService架构引入的许多复杂性，但它们也引入了新的挑战。您可能获得易于维护的收益可能是由无服务器困难测试的黯淡（现在您不需要测试应用程序的每个服务及其集成，而是每个功能及其集成），潜在的供应商锁定（我们将Docker作为MicroServices作为“标准环境”，但我们没有这一点对于无服务器功能，每个供应商都有自己的要约和工具来管理这个）。无服务器架构正在朝向“一种尺寸适合所有”解决方案，但它们可能还不够。</p><p> And finally, we have the  neo-monolith approach which  divides the application into different services hosted in the same infrastructure (we get a cleaner code structure and an eventual simpler transition to microservices, but with the advantage of monolithic infrastructure management).</p><p> 最后，我们拥有Neo-Monolith方法，它将应用程序划分为在同一基础架构中托管的不同服务（我们获得更清晰的代码结构，并且最终转换到微服务，但具有单片基础设施管理的优势）。</p><p> With this, we now have a clearer view of the current landscape. A lot has been written about the pros and cons of monoliths v.s. Microservices v.s. serverless. Take a look at  this post,  this one, or maybe  this one for some interesting viewpoints on the pros and cons of microservices. But what have changed for me to consider our ability to build better architectures?</p><p> 有了这个，我们现在有更清晰的目前景观。关于整料五股的优缺点，已经写了很多。 microServices V.S.无刀。看看这篇文章，或者这一个，或者这一个是关于微服务的优点和缺点的一些有趣的观点。但是我改变了什么，以考虑我们建立更好的架构的能力？</p><p> The problem with prematurely turning your application into a range of services is chiefly that it violates the #1 rule of distributed computing: Don’t distribute your computing! At least if you can in any way avoid it.</p><p> 过早地将应用程序转化为一系列服务的问题主要是违反了分布式计算的第1条规则：不要分发您的计算！至少如果你可以以任何方式避免它。</p><p>  The three technologies that have made me re-evaluate our ability to build a “one size fits all” architecture for web systems are the following:</p><p>  让我重新评估我们建立“一种尺寸”的网络系统架构的三种技术如下：</p><p> Web Assembly: My excitement about the possibilities of this new technology is well-known to all of you assiduously following my publications. I’ve written extensively about   Wasm as a Universal Bytecode,  Wasm as a docker replacement, and  going towards a universal runtime with Wasm. One of the drawbacks I mentioned about serverless functions is the lack of a standard runtime environment, but  the fact is that we may have it already, Wasm, and it may be the key to a new scalable and maintainable architecture. Actually, some companies such as  Fastly are already using Wasm in their serverless proposals.</p><p> Web汇编：我对这项新技术的可能性的兴奋，遵循我的出版物的所有人都众所周知。我已经写了大肆宣传为普通字节码，WASM作为Docker替换，并朝着WASM的普遍运行时间。我提到的关于无服务器函数的缺点是缺乏标准运行时环境，但事实是我们可能已经拥有了WASM，并且它可能是新可扩展和可维护架构的关键。实际上，一些速度的公司已经在无服务器提案中使用了WASM。 </p><p> The Web3 stack: I get it, I am quite biased, but I really think  web3 protocols are the future of the Internet in several respects, as I’ve also already  mentioned in some of my publications. Someone looking to deploy their web platform nowadays needs to choose wisely the cloud provider where he is going to host his infrastructure as this may influence the availability and SLA of their application (as well as other concerns mentioned above such as vendor lock-in, etc.).  We refer to the cloud as that global platform able to fulfill all our computational and connectivity needs, when in reality the cloud is a disjoint group of infrastructure providers capable of fulfilling these needs. When we talk about our Internet connection, we don’t care that much about the ISP that is giving us the access, because the Internet has become a commodity, this has not yet been the case for the cloud.  Web3 stack protocols and the decentralization of the Internet is what is going to finally transform the cloud into a commodity. My feeling is that a commoditized cloud would finally bring us the “one size fits all” architecture we are looking for, as it will be supported by default by “the new Internet”.</p><p>Web3堆栈：我得到它，我很偏见，但我真的认为Web3协议是互联网的未来，因为我在我的一些出版物中也已经提到了。现在有人希望部署他们的Web平台，需要明智地选择云提供商，他将托管他的基础架构，因为这可能会影响其应用程序的可用性和SLA（以及上述其他问题，例如供应商锁定等问题。）。当实际上，我们将云引用云，因为全局平台能够满足我们所有的计算和连接需求，云是一种能够满足这些需求的脱节组的基础架构提供商组。当我们谈论我们的互联网连接时，我们不关心向我们提供访问权限的ISP，因为互联网已成为一种商品，但云的情况尚未如此。 WEB3堆栈协议和互联网的权力下放是最终将云变为商品的原因。我的感觉是，商品化云最终会给我们带来我们正在寻找的“一种尺寸适合所有”架构，因为它将被“新互联网”默认支持。</p><p> Suborbital Atmo: Atmo makes it easy to create a powerful server application without needing to worry about scalability, infrastructure, or complex networking. Atmo enables you to write small self-contained functions called Runnables using a variety of languages, and define your business logic by declaratively composing them. Atmo then automatically scales out a flat network of instances to handle traffic using its meshed message bus and embedded job scheduler. Atmo can handle request-based traffic, and soon will be able to handle events sourced from various systems like Kafka or EventBridge. So essentially, you deploy a serverless infrastructure as if it was a monolith. I’ve been tinkering with Atmo, and its underlying modules for some weeks now, and I think it is a great piece of technology and  a good example of how this “one size fits all” solution over a decentralized cloud could look like. I won’t go in depth on how Atmo works (at least for now), but I highly recommend giving it a good look, and checking out  this issue ;) (could this be the beginning of something big?)</p><p> 亚坏常规：Atmo可以轻松创建强大的服务器应用程序，而无需担心可扩展性，基础架构或复杂网络。 ATMO使您可以使用各种语言编写名为Runnables的小型自包含函数，并通过声明方式编写它们来定义业务逻辑。然后，atmo自动缩放一个平面的实例网络，以处理使用其网格消息总线和嵌入的作业调度程序来处理流量。 Atmo可以处理基于请求的流量，很快就可以处理来自像Kafka或EventBridge等各种系统的事件。所以基本上，您部署了一个无服务器的基础架构，仿佛它是一巨石。我已经滋补了Atmo，它的底层模块现在几个星期了几个星期，我认为这是一个很好的技术，以及一个良好的例子，这是如何在分散的云上的“一种尺寸适合所有”解决方案。我不会深入了解atmo工作（至少现在），但我强烈推荐给它一个好的外观，并检查出这个问题;）（这可能是大的东西的开始吗？）</p><p>  If monoliths are hard to scale and microservices are too complex, then how do you design a system that can scale with your traffic and your development team without becoming a pain to operate, maintain and expand its functionality? Over the past few years, it has become clear that a middle-ground is needed. I don’t expect this solution to work for everyone, but most products aren’t serving the kind of traffic that really makes the microservice effort worth it. --  @coohix</p><p>  如果Monoliths难以规模，微服务太复杂，那么您如何设计一个可以与您的流量和开发团队一起扩展的系统，而不会成为操作，维护和扩展其功能的痛苦？在过去的几年里，很明显需要中间地面。我不希望这个解决方案为每个人工作，但大多数产品都没有提供真正使得MicroService努力值得它的流量。 -  @coohix.</p><p>  In my  TWIL#2 from a few weeks ago I mentioned that I built for a hackathon a proof of concept of  how I imagined computation over IPFS would work ( you can check out the code here). This idea already glimpsed how a global cloud would look like.  You run computations in the network without having to worry about who is running it, or where the resources are. Of course, a trustless model as such wouldn’t scale without an incentive system that rewards peers contributing their resources to keep the network running (especially if we want an SLA and certain guarantees, but lets leave this out of the picture for now).</p><p>  在我的尺寸在几周前，我提到我提到我为Hackathon建立了一个概念证明，我如何想象于IPFS的计算将有效（你可以在这里看看代码）。这个想法已经瞥了一眼全球云如何看起来像。您在网络中运行计算，而无需担心谁运行它，或者资源的位置。当然，没有一个无数的模型，因为没有激励系统，没有奖励同行奖励他们的资源以保持网络运行的激励系统（特别是如果我们想要SLA和某些保证，但是现在让我们离开这张照片）。</p><p> With a decentralized network as IPFS already in place,  why not trying to offer developers the ability to host applications scalable-by-design, and easy to maintain? IPFS is a decentralized content-addressable network, so it has CDN capabilities by-design. Peers looking to run some job (or get some file), will fetch it from its nearest neighbor (if possible), without having to worry about finding the server hosting the service, because resources in a content-addressed network are location-independent.  All of these concepts could potentially make the “monolith v.s. microservices” argument outdated. Actually, almost a year ago I already wrote a publication explaining  how a recent standard such as WebBundles were a perfect fit for content-addressable networks.</p><p> 使用分散的网络已经成为IPFS已经到位，为什么不试图为开发人员提供托管应用程序的可扩展设计，易于维护？ IPFS是一个分散的内容可寻址网络，因此它具有CDN功能的设计。寻求运行一些作业（或获取一些文件）的同行将从其最近的邻居（如果可能）获取它，而无需担心查找托管服务的服务器，因为内容解决网络中的资源无关。所有这些概念都可能使“整体五”制作。 microServices“Argument过时了。实际上，差不多年前我已经编写了一个出版物，解释了最近的诸如网络邮票的标准是如何完美适合内容可寻址网络。</p><p> Changing the way the core of the Internet works can make decade old arguments outdated such as the architecture wars,  and it all starts with the “actual” commoditization of the cloud through protocols that expose the cloud as a single global entity, not as a disjoint fight between different providers. Adoption is key for this change of paradigm to become a reality.  All of this should translate into better alternatives for developers and users. Can  Atmo over IPFS be the beginning of this “revolution”. We’ll see…</p><p> 更改互联网工作的核心方式可以使十年的旧参数过时，例如架构战争，它一切都是通过将云作为单个全局实体公开的协议的“实际”商品化，而不是脱节在不同的提供者之间争取。采用是这种改变的关键，以成为现实的这种变化。所有这一切都应转化为开发人员和用户的更好的替代方案。 Atmo对IPF可以成为这个“革命”的开始。我们拭目以待… </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://adlrocha.substack.com/p/adlrocha-building-a-scalable-monolith">https://adlrocha.substack.com/p/adlrocha-building-a-scalable-monolith</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/伸缩/">#伸缩</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scalable/">#scalable</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>