<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>“朱莉娅与锈”中的和类型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">“朱莉娅与锈”中的和类型</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-31 12:35:11</div><div class="page_narrow text-break page_content"><p>正如我在本博客的其他帖子中提到的(这里肯定很多人都会同意)，我坚信设计程序的一个很好的开始是找出人们试图解决的现实问题的良好表示形式，即定义适当的类型。定义类型的一种有用的技术是所谓的SUM类型。有趣的是，它们在不同的编程语言中的用法完全不同，我想在本文中以Rust和Julia为例简要说明这一点。</p><p>备注：Julia和Rust是我最喜欢的编程语言，它们特别适合演示我的观点。但是，如果您不使用这两种语言，这不应该阻止您阅读！首先，这两种语言都有相当直观的语法，并且这里显示的代码非常基本，所以您应该能够跟上。第二，您可以用继承的语言(例如Java)代替Julia，或者用您的标记并集语言代替Rust(例如Haskell)。即使不是这样，您也可能会学到一些东西！</p><p>假设您正在创建一个星际游戏，其中玩家可以居住在三个不同的恒星系统中：太阳(太阳人)、北极星(北极星)和半人马座阿尔法星(半人马座)。显而易见的第一步是为这三个类别中的每一个定义类型：</p><p>(当然，您可以向这些结构中添加一些字段，但这不是这里的重点。)。</p><p>现在，假设您需要将玩家值存储在另一个对象(如游戏状态)中：</p><p>Homestar(Player：：Solarian)=&#34；Sun&#34；Homestar(Player：：Polarian)=&#34；Homestar(Player：：Centaurian)=&#34；Alpha Centauri&34；Homestar(Player：：Player)=&#34；UNKNOWN&#34；#或`ERROR(&#34；UNKNOWN Player class&#34；)`。</p><p>Rust没有子类型，但是您可以通过特征(类似于其他语言中的接口)定义类型之间的关系。</p><p>但是GameState结构怎么办呢？我们可以利用特征对象，我们只知道它们实现了特定的Trait。我们特别不知道对象的大小，所以我们需要引用它。如果您熟悉Rust，您就知道这要么意味着使用“普通”引用(&amp；或&amp；mut)和处理生命周期注释(老实说，不是我最喜欢的)，要么使用盒值。如果您不熟悉这一点，无论如何在这里都无关紧要。GameState可能如下所示：</p><p>这是可行的，但确实限制了我们对Player特性所能做的事情，因为它需要是对象安全的。例如，问候任意类的另一位Player。</p><p>Greet(Self：：Polarian，Other：：Player)=println(&#34；Hi！&34；)Greet(Self：：Polarian，Other：：Solarian)=println(&#34；您的星星不是由三颗独立的星星组成吗？可悲！&#34；)。</p><p>Julia和Rust都提供了使用类型参数定义泛型类型。此外，还可以对这些参数进行约束。这允许我们像策略1那样做一些简单的事情，但不会在GameState结构中隐藏具体的播放器类型：</p><p>特征玩家{...}struct Solarian；实施Solarian玩家{...}struct GameState&lt；P：玩家&gt；{白天：U64，玩家：p}。</p><p>通常可以认为这种方法的性能更好，因为编译器可以发出具体类型(单形化)的代码，而不是携带跟踪子类型和虚拟方法表的笨拙的超级类型。(据我所知，Julia中的类型player和Rust中的类型Box&lt；dyn player&gt；的实例工作起来非常相似。)。</p><p>然而，这种方法有一个主要问题：抽象泄漏。GameState结构的用户现在必须决定为参数P选择哪种具体类型，这在Rust中非常严格，在Julia中不是很严格。这可能是可以的，但通常足够多的GameState是处理该问题的正确位置，并且确实应该隐藏该细节。</p><p>因此，经验法则是：在代码中“深入”考虑此问题的泛型，但不要错过需要将其保留在内部的抽象级别。</p><p>到目前为止，对于Rust来说，这些方法并不真正令人满意。但是枚举来了！枚举(或枚举)是由具体而显式的可能值列表(所谓的变体)组成的类型。</p><p>在Rust中，这些值甚至可以拥有自己的数据，这些数据非常适合我们的情况：</p><p>枚举PlayerClass{SOL(Solarian)，Pol(Polarian)，Cent(Centaurian)}struct GameState{DAYTIME：U64，Player：PlayerClass}Impll PlayerClass{FN HOSTAR(&amp；Self)-&gt；string{Use PlayerClass：：*；Match Self{SOL(_)=&gt；String：From(&#34；Sun&#34；)，...}}FN问候语(&amp。Match(Self，Other){(Cent(_)，Pol(_))=&gt；println！(&#34；您好，三星同行！&#34；)，...}；}}。</p><p>这确实解决了我们以前的所有问题，因此是解决这种情况的首选模式。</p><p>存在，并且它将为您提供一个正好具有这三个可能值的PlayerClass类型，但是枚举不是一等公民。(不过，查看@acroexpand@enum Foo A B C，看看枚举在Julia中是如何“工作”是非常有趣的。)但这与我们甚至没有关系，更重要的是，Julia中的枚举变体不能携带额外的数据！因此，Solarian、Polarian和Centaurian结构字段中的所有信息都不能构建到Playaurian结构中，这一点甚至与我们无关，更重要的是，Julia中的枚举变体不能携带额外的数据！因此，Solarian、Polarian和Centaurian结构字段中的所有信息都不能构建到Playaurian结构中。</p><p>实施PlayerClass{fn Take Damage(&amp；mut self){Match&amp；mut self{PlayerClass：：SOL(Solarian)=&gt；solarian.Health-=42，...}；}}。</p><p>您现在可能已经猜到了，但是一般的建议是：在Julia中使用子类型，在Rust中使用子类型。但是有一个警告：枚举不能从“外部”扩展。如果您计划让库用户添加新的类型变体，则必须使用某种特征方法。</p><p>如果您对Rust或Julia比较熟悉，那么本文的很大一部分内容可能对您来说非常明显：“当然我使用子类型，这就是每个人都喜欢Julia的原因！”或者“我当然使用枚举，它们是Rust的关键特性之一！”你可能会说。</p><p>如果您是Julia开发人员(不失一般性)，了解Rust中的相应模式可能会帮助您更快地设计合适的类型(如果您遇到这种情况，反之亦然)，但我发现这两种模式看起来相当不同，可以在相同的情况下使用，如果您是一名Julia开发人员，了解Rust中的相应模式可能会帮助您更快地设计合适的类型；反之亦然。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://andreaskroepelin.de/blog/sum_types/">https://andreaskroepelin.de/blog/sum_types/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1020632.html"><img src="http://img.diglog.com/img/2020/8/thumb_185819839ff9afaf29c89befd5a768c6.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1020632.html">Julia用户最有可能叛逃到Python进行数据科学</a></div><span class="my_story_list_date">2020-8-27 15:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019435.html"><img src="http://img.diglog.com/img/2020/8/thumb_b11f89659628dbadda8d760c74a1ff8d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019435.html">朱莉娅州(JuliaCon 2020)</a></div><span class="my_story_list_date">2020-8-21 3:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1016072.html"><img src="http://img.diglog.com/img/2020/8/thumb_62e41380a98895e35be644194f7ece74.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1016072.html">C O M P U T E R 1.0-由Victoria Manganiello和Julian Goldman展示的纺织品</a></div><span class="my_story_list_date">2020-8-4 9:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1009963.html"><img src="http://img.diglog.com/img/2020/7/thumb_266534afd2860ee4071d5ef1902d9615.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1009963.html">默认情况下打开Julia语言遥测</a></div><span class="my_story_list_date">2020-7-6 1:59</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>