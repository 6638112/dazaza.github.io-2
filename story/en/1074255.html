<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>尼克斯：一个时机已经成熟的想法Nix: An idea whose time has come</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nix: An idea whose time has come<br/>尼克斯：一个时机已经成熟的想法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 17:40:26</div><div class="page_narrow text-break page_content"><p>Joe Armstrong, one of the creators of Erlang, once described Erlang as the quest for programs that you “ write once, run forever.” Nix, in comparison, might be the quest for programs that run wherever, whenever. Nix often scares newcomers and experienced devs alike, because it proposes a fairly radical overhaul to how we think about package management and how we run software in general. In this post, I’m going to illustrate which problems Nix solves and argue that this change in perspective has profound implications for software tooling.</p><p>Erlang的创建者之一乔·阿姆斯特朗（Joe Armstrong）曾将Erlang描述为对“编写一次，永远运行”的程序的追求相比之下，Nix可能是对随时随地运行的程序的追求。Nix经常让新手和经验丰富的开发人员感到害怕，因为它提出了一个相当彻底的改革，来改变我们对包管理的看法，以及我们如何运行软件。在这篇文章中，我将说明Nix解决了哪些问题，并认为这种视角的变化对软件工具有着深远的影响。</p><p> Dealing with package managers is core to today’s developer experience, yet remains riddled with pitfalls. We tend to outsource our trust to a package cache, like NPM or Hex, and then incorporate whatever they return into our systems. Most of the time this works fine, as the package manager has incentives to act honestly. As an example of where this central point of failure becomes problematic, attackers can modify a package to include malware in what is known as a  digital supply chain attack. What we really want, and what no package manager can give us today, is reproducibility.</p><p>与包经理打交道是当今开发人员体验的核心，但仍然充满陷阱。我们倾向于将我们的信任外包给一个包缓存，比如NPM或Hex，然后将它们返回的任何东西合并到我们的系统中。大多数情况下，这很好，因为包经理有诚实行事的动机。例如，当这个中心故障点出现问题时，攻击者可以修改软件包，将恶意软件包括在所谓的数字供应链攻击中。我们真正想要的，也是当今任何软件包经理都无法提供的，是可复制性。</p><p> By  reproducibility, we mean the ability to recreate, bit for bit, the build of a package on your own system. Whatever package is thrown your way, you can rebuild it locally and check whether you have the expected build output. This is analogous to verifying a binary downloaded from the Web by computing its sha256 hash, and comparing it to the one provided by the publisher of the binary. In Nix’s case, however, you’re building the package from source. Why is this important? Because it removes the need to trust the provider and makes the cost of detecting a failure or an attack much lower for the developer. Reproducibility means security for your systems and applications, and peace of mind for your developers.</p><p>所谓可复制性，我们指的是在你自己的系统上一点一点地重建一个软件包的能力。无论抛出什么包，您都可以在本地重建它，并检查是否具有预期的生成输出。这类似于通过计算从Web下载的二进制文件的sha256哈希值，并将其与二进制文件发布者提供的哈希值进行比较，从而验证二进制文件。然而，在Nix的例子中，您是从源代码构建包的。为什么这很重要？因为它消除了对提供商的信任，并使开发人员检测故障或攻击的成本大大降低。可再现性意味着系统和应用程序的安全，以及开发人员的安心。</p><p> The way in which one gets to this reproducible state is by assuming nothing about the local environment. Everything in Nix must be declared explicitly by the user. Most build tools or environments rely on assumptions about the local environment and try to deal with it as best they can, but if you want to provide a way to build anything, anywhere, you have to forgo any tether to the local environment. Nix does this by forcing you to declare the packages you want, and how to fit them together. Because every part of your environment or build is explicit, you can achieve isolation and reproducibility.</p><p>一个人达到这种可复制状态的方式是不考虑当地环境。Nix中的所有内容都必须由用户明确声明。大多数构建工具或环境都依赖于对本地环境的假设，并试图尽可能地处理它，但如果你想提供一种在任何地方构建任何东西的方法，你必须放弃与本地环境的任何束缚。Nix通过强制您声明所需的包以及如何将它们组合在一起来实现这一点。因为环境或构建的每个部分都是明确的，所以可以实现隔离和再现性。</p><p>  Nix is both a package manager–a source of prebuilt packages which one can download and run–and a functional language to help us to write “build expressions” in a reproducible way. A Nix expression is a function with one side-effect: creating the spec of the build itself.</p><p>Nix既是一个包管理器——一个可以下载和运行的预构建包的来源——也是一种功能性语言，帮助我们以可复制的方式编写“构建表达式”。Nix表达式是一个有一个副作用的函数：创建构建本身的规范。</p><p> “The main idea of the Nix approach is to store software components in isolation from each other in a central component store, under path names that contain cryptographic hashes of all inputs involved in building the component” –  Eelco Dolstra‘s Ph.D.  thesis</p><p>“Nix方法的主要思想是将软件组件彼此隔离地存储在一个中央组件存储中，路径名包含构建组件所涉及的所有输入的密码散列”——Eelco Dolstra的博士论文</p><p>  First, everything built with Nix gets put in a central store, by default `/nix/store`, which is a departure from your Linux FHS (Filesystem Hierarchy Standard). You know very little about a package installed on your system the traditional way: how was it built? What does it depend on? Nix makes package definitions self-contained.</p><p>首先，使用Nix构建的所有东西都会放在一个中央存储中，默认情况下为“/Nix/store”，这与Linux FHS（文件系统层次结构标准）不同。对于以传统方式安装在系统上的软件包，您知之甚少：它是如何构建的？这取决于什么？Nix使包定义变得独立。</p><p> Second, every built artifact is identified with a hash, which is the summary identifier of the complete dependency graph of the package, the platform-specific build steps involved, and the Nix expression which defines how to build it. For example, my local version of “ bat” v. 0.18.3, a popular cli replacement for “cat”, is stored under the following path: “/nix/store/fm6m39f7fr94bch5q1nssrrv6w6c8d2n-bat-0.18.3/bin/bat” with the following graph of dependencies.</p><p>其次，每个构建的工件都用一个散列来标识，散列是包的完整依赖关系图的摘要标识符、涉及的特定于平台的构建步骤，以及定义如何构建它的Nix表达式。例如，我的本地版本“bat”v.0.18.3是“cat”的流行cli替代品，它存储在以下路径下：“/nix/store/fm6m39f7fr94bch5q1nssrrv6w6c8d2n-bat-0.18.3/bin/bat”，并带有以下依赖关系图。</p><p>  This graph completely describes the flow of dependencies. Change the order, or change any dependency of bat, and the output hash changes, resulting in a new entry in the nix store. As far as Nix is concerned, it would be a totally new package. Since you know the hash of the output before you build it, you don’t need to backup packages themselves, just their build expressions. It means you can share the full spec of a local environment with a coworker, and know it will be executed exactly as it was run on your machine. It means you can have multiple environments, and multiple versions of a package, coexisting peacefully on your machine. And it gives you those assurances across languages and platforms: you gain a unified interface for packaging software, with everything you need to run it. Most of the time, it “just works”.</p><p>该图完整地描述了依赖关系的流程。更改bat的顺序或任何依赖项，输出哈希就会更改，从而在nix存储中产生一个新条目。就尼克斯而言，这将是一个全新的方案。因为在构建输出之前就知道了输出的哈希值，所以不需要备份包本身，只需要备份它们的构建表达式。这意味着您可以与同事共享本地环境的完整规范，并且知道它将完全按照在您的机器上运行的方式执行。这意味着你可以有多个环境，一个软件包的多个版本，在你的机器上和平共存。它为您提供了跨语言和跨平台的保证：您获得了打包软件的统一界面，以及运行软件所需的一切。大多数时候，它“只是起作用”。</p><p> This alone is a welcome development, but another perhaps less appreciated benefit is that, while sharing software through space is easy today, sharing it through time is often much harder. For a made-up example, let’s imagine your company maintains a tool built 25 years ago with the C compiler from that time. It can’t be upgraded safely because the entire world’s banking system would fall apart if it did. Maybe you keep a dedicated laptop as a digital time capsule to maintain this tool. Instead, you can create a Nix shell with whatever version of the tools you need, pinned and never upgraded. This environment is isolated, and plays nice with all your other C versions on your system since it’s just another Nix package. You can share this environment with anybody and they’re one `nix-shell` command away from having the same environment as you.</p><p>这本身就是一个受欢迎的发展，但另一个可能不太受欢迎的好处是，虽然今天通过空间共享软件很容易，但通过时间共享软件往往要困难得多。举一个虚构的例子，假设您的公司维护一个25年前用当时的C编译器构建的工具。它无法安全升级，因为如果升级，整个世界的银行系统都会崩溃。也许你会用一台专用笔记本电脑作为数字时间胶囊来维护这个工具。相反，你可以用你需要的任何版本的工具创建一个Nix外壳，这些工具是固定的，从来没有升级过。这个环境是隔离的，可以很好地与系统上的所有其他C版本配合使用，因为它只是另一个Nix包。你可以与任何人共享这个环境，他们只需一个`nix shell`命令，就可以拥有与你相同的环境。</p><p> “We build our computers the way we build our cities–over time, without a plan, on top of ruins.” –  Ellen Ullman</p><p>“我们用建造城市的方式建造计算机——随着时间的推移，没有计划，在废墟之上。”——艾伦·乌曼</p><p> Nix undoubtedly has a steep learning curve, and there are two reasons for that. First, using Nix entails rethinking a lot of accepted wisdom and practices that have become second nature for a developer. Unlearning is hard. Second, Nix surfaces all the complexity involved in building software and forces you to deal with it. In order to make builds truly reproducible, this is largely inevitable. But once the “Nix way” is integrated, and the community tooling leveraged, your system becomes wonderfully transparent. No more chasing down configs and building tooling across your system and various languages. You gain a unified interface for dealing with building, composing, and sharing software artifacts across ecosystems. Nothing is hidden from you, and you can change whatever you like. In that sense, it belongs squarely in the Linux FOSS tradition.</p><p>尼克斯无疑有着陡峭的学习曲线，这有两个原因。首先，使用Nix需要重新思考许多公认的智慧和实践，这些智慧和实践已成为开发人员的第二天性。忘却学习很难。其次，Nix揭示了构建软件所涉及的所有复杂性，并迫使您处理它。为了使构建真正可复制，这在很大程度上是不可避免的。但是，一旦“尼克斯方式”被集成，社区工具被利用，你的系统就会变得非常透明。不再需要在您的系统和各种语言中追踪配置和构建工具。您将获得一个统一的界面，用于处理跨生态系统的软件构件的构建、组合和共享。没有什么是瞒着你的，你可以随心所欲地改变。从这个意义上讲，它完全属于Linux自由和开放源码软件的传统。</p><p> Nix is out of the “science experiment phase”, but is still evolving. However, many companies used Nix in production today, for example, Target,  Replit, and  Shopify. While the complexity of Nix can be daunting, I suspect we’ll look back in 20 years and wonder how we got along without it. In the meantime, enjoy being a few years ahead of the curve :).</p><p>Nix已经脱离了“科学实验阶段”，但仍在发展中。然而，许多公司在今天的生产中使用了Nix，例如Target、Replit和Shopify。虽然尼克斯的复杂性可能令人望而生畏，但我怀疑我们会在20年后回顾，并想知道没有它我们会如何相处。同时，享受领先几年的生活：）。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/尼克斯/">#尼克斯</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/idea/">#idea</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>