<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如果您拥有的只是数据库，那么一切看起来都像钉子一样 If All You Have Is a Database, Everything Looks Like a Nail</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">If All You Have Is a Database, Everything Looks Like a Nail<br/>如果您拥有的只是数据库，那么一切看起来都像钉子一样 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-08 09:46:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/bda615c1ec32a9c9fbdc190d120b29f2.png"><img src="http://img2.diglog.com/img/2020/12/bda615c1ec32a9c9fbdc190d120b29f2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Back in 1978 when I took my first job programming, it was to build a database system.  At age 22, I didn’t know what that was but it didn’t matter.  I needed the job.  That startup company eventually became a shutdown company and in 1982, I went to work at  Tandem Computers working on the infrastructure that a few years later became  Tandem’s NonStop SQL.</p><p>早在1978年，当我开始我的第一份工作编程时，它就是建立一个数据库系统。 22岁那年，我不知道那是什么，但这并不重要。我需要这份工作。那家初创公司最终成为一家关机公司.1982年，我去Tandem Computers工作，从事基础架构的工作，几年后成为Tandem的NonStop SQL。</p><p> At Tandem, I learned that a database supporting a company’s business was a complex and sophisticate creature.  Not only did it need to provide access to the customer’s data, it needed online DDL, high availability, archive, offsite tape rotation and management, online backups, access control, monitoring and operational support, and even replication to a remote data center.  I called this last feature   geologic fault tolerance.</p><p> 在Tandem，我了解到支持公司业务的数据库是一个复杂而复杂的生物。它不仅需要提供对客户数据的访问，还需要在线DDL，高可用性，存档，异地磁带轮换和管理，在线备份，访问控制，监视和操作支持，甚至复制到远程数据中心。我称这为最后一个功能地质容错。</p><p> Databases were big, powerful, and expensive.  You were lucky to have one and only the largest conglomerate company could afford more than one.  Furthermore, the large mainframe computer system and its database were SO expensive, it was quite practical to hire dozens of programmers to build an application that did exactly what you want.</p><p> 数据库庞大，功能强大且昂贵。您很幸运拥有一家，而且只有最大的企业集团能够负担得起不止一家。此外，大型主机计算机系统及其数据库非常昂贵，因此聘请数十名程序员来构建能够完全满足您需求的应用程序是非常实际的。</p><p> This led to a few recurring patterns at most companies owning shiny new expensive databases:</p><p> 这导致大多数拥有闪亮的新的昂贵数据库的公司出现了一些重复出现的模式：</p><p>    Stuffing non-relational immutable documents, photos, audio files, movies, and other inanimate objects into your innocent and unprepared relational database.</p><p>    将非关系不可变文档，照片，音频文件，电影和其他无生命的对象填充到您无辜且未经准备的关系数据库中。</p><p>   Once your company acquired a database, one or more DBAs (Data Base Administrators), and a setup in a datacenter, each new application at your company wanted to use your database, too!  This was reasonable since the company really couldn’t afford ANOTHER mainframe.  You really should share the one you have.</p><p>   一旦您的公司收购了一个数据库，一个或多个DBA（数据库管理员）以及一个数据中心中的设置，公司中的每个新应用程序也都希望使用您的数据库！这是合理的，因为该公司确实买不起另一个主机。您确实应该分享自己的一份。</p><p> Soon, the database was surrounded by  High Priests of Database who constantly cultivated and curated the schema for the tables and more as new functionality and new applications were added to the shared system.  As the database became more central to the operations of the company, it was  mission critical.  Greater and greater care was placed on all the aspects needed to keep that database running 24 by 7 or as close as possible.  When the database was down, the company was down and that was not a good thing.</p><p> 很快，数据库被数据库大祭司所包围，他们不断地为表创建和管理表的架构，并且随着新功能和新应用程序被添加到共享系统中而不断发展。随着数据库对于公司运营变得越来越重要，它的任务至关重要。在保持数据库以24 x 7或尽可能接近的速度运行所需的所有方面上，都投入了越来越多的关注。当数据库关闭时，公司也关闭了，那不是一件好事。 </p><p> All the care and feeding of corporate data was soon focused on the core enterprise database.  Between the database providers and the enterprise database owners, the stuff needed to ensure the safety of the data got pretty damned good.</p><p>公司数据的所有维护和提供很快都集中在核心企业数据库上。在数据库提供者和企业数据库所有者之间，确保数据安全所需的东西真该死。</p><p> At first, each application used its very own tables and made sure to mind its own business.  Eventually, it just seemed easier to read another application’s tables than to negotiate how to invoke the other app using messages or interfaces.  What’s the harm?</p><p> 最初，每个应用程序都使用自己的表，并确保考虑到自己的业务。最终，与协商如何使用消息或接口调用另一个应用程序相比，阅读另一个应用程序的表似乎更容易。有什么害处？</p><p> Soon, there was an established trend that increased the entropy and intertwining of applications and tables.  It became common to have transactional updates across tables for different apps.</p><p> 很快，一个确定的趋势增加了应用程序和表格的熵和相互缠绕。跨表为不同应用程序进行事务更新变得很普遍。</p><p> “Hygiene” was interpreted as “Hi, Jean!” as you asked your database administrator for access to another application’s table.</p><p> “卫生”被解释为“嗨，吉恩！”当您要求数据库管理员访问另一个应用程序的表时。</p><p>  When other kinds of data needed a home, the owners of that data quite reasonably want it to receive the same loving care and protection that was offered by the database.</p><p>  当其他类型的数据需要房屋时，这些数据的所有者非常合理地希望它获得数据库所提供的相同的关怀和保护。</p><p> These precious artifacts were sometimes large in size like scans of documents, photographs, and occasionally even movies!  Since SQL can accept blobs, they could stash lots of data in dusty corners of the database.  This had big advantages for the people stashing the stuff and big disadvantages for the folks operating the database.</p><p> 这些珍贵的文物有时会很大，例如扫描文档，照片甚至是电影！由于SQL可以接受Blob，因此它们可以将大量数据存储在数据库的尘土飞扬的角落。这对人们存储资料有很大的好处，而对操作数据库的人则有很大的不利之处。</p><p> It’s great for the consumers of the database!  Easy and clean storage of your random data with backup, high availability, and storage capacity just magically working.  In addition, the data can be updated transactionally with the other stuff you have in the database.  No worries and the best care you can get for your data!  Life is GREAT!</p><p> 对数据库的使用者来说非常好！轻松，干净地存储您的随机数据，并具有备份，高可用性和神奇的存储容量。此外，数据可以与数据库中的其他内容进行事务性更新。不用担心，可以为您的数据提供最好的照顾！生活是美好的！ </p><p> It’s a nightmare for the administrators of the database!  All of a sudden, your database starts getting fatter.  Soon, you are purchasing more of the most expensive storage solutions allowable by law.  Immutable data like photos and images of documents are coexisting on the  SANs (Storage Area Networks) supporting your database.  This is inefficient because SANs are extremely expensive high-end hardware designed for update in place.  Using them as a repository for immutable stuff is like using a finely crafted Rolex watch as a paperweight.</p><p>这是数据库管理员的噩梦！突然之间，您的数据库开始变得越来越胖。很快，您将购买更多法律允许的最昂贵的存储解决方案。诸如照片和文档图像之类的不可变数据共存于支持数据库的SAN（存储区域网络）上。这是低效的，因为SAN是设计用于就地更新的极其昂贵的高端硬件。将它们用作不可变材料的存储库就像使用精巧的劳力士手表作为镇纸一样。</p><p> Extricating these precious and bulky data items from the database is not as easy as it may seem.  The immutable nature of scanned paper documents and other media is of tremendous help.  You can allocate a 128-bit UUID for the document and store the document somewhere else.  This identifier can then be kept in the database associated with some relational record.</p><p> 从数据库中提取这些珍贵而庞大的数据项并不像看起来那样容易。扫描纸质文档和其他介质的一成不变性质具有巨大的帮助。您可以为文档分配128位UUID，并将文档存储在其他位置。然后，可以将该标识符保存在与某些关系记录关联的数据库中。</p><p> Quickly, you realize that while this can offload the storage capacity to a less expensive storage medium, there are challenges:</p><p> 很快，您意识到，尽管这可以将存储容量转移到更便宜的存储介质上，但仍存在挑战：</p><p> Updates to the system are non-transactional.  In general, you need to update the new unified system by:</p><p> 系统更新是非事务性的。通常，您需要通过以下方式更新新的统一系统：</p><p> Step-1:  In transaction-T1 on the database, update the relational system saying that you intend to insert an object with UUID-X into a column in a table understood by the application.  Another column manages the state of the object in store holding immutable objects.</p><p> 步骤1：在数据库上的transaction-T1中，​​更新关系系统，说您打算将具有UUID-X的对象插入应用程序可以理解的表的列中。另一列管理持有不可变对象的存储区中对象的状态。</p><p>  Step-3:  Finally, in transaction-T2, update state of the object in the additional column so you know the object can be consumed by the application.</p><p>  步骤3：最后，在transaction-T2中，更新附加列中对象的状态，以便您知道应用程序可以使用该对象。</p><p> Oops… Later you learn that a failure in the multi-step insert may cause problems.  A failure after step-1 and before step-2 causes abandoned and incomplete insertion as seen in the application when it looks at the table.  A failure after step-2 and before step-3 leaves abandoned and useless objects in the immutable store.</p><p> 糟糕，稍后您会发现多步插入失败可能会导致问题。步骤1之后和步骤2之前的故障会导致放弃和不完整的插入，如在应用程序中查看表时所看到的。在第2步之后和第3步之前的故障使不可变存储中的废弃对象无用。 </p><p> To deal with this, you need a side table of in-progress inserts and deletes.  At least, this can be transactional with the insert into the application’s table.</p><p>为了解决这个问题，您需要一个正在进行的插入和删除的边表。至少，这可以与应用程序表中的插入内容进行事务处理。</p><p> Next, you realize you’d better timestamp the ongoing work, too, so you can notice when something is old enough to warrant cleanup due to a failed insert.  Now, your system is reasonably stable and you have a team party.</p><p> 接下来，您会意识到也最好为正在进行的工作加上时间戳，以便您可以注意到什么时候旧的东西由于插入失败而足以进行清理。现在，您的系统相当稳定，并且您有一个团队聚会。</p><p> A few months or years later, the immutable store for the blobs is reaching capacity.  Now, you need another crash program to update all the tables in the relational system to include a store ID.  That allows you to keep blobs in many stores.</p><p> 几个月或几年后，blob的不变存储已达到容量。现在，您需要另一个崩溃程序来更新关系系统中的所有表以包括商店ID。这样您就可以在许多商店中保存斑点。</p><p> That’s when you realize you don’t know WHERE all the tables in the database are that hold immutable blobs.  Applications have been adding blobs to the immutable store without coordinating that effort.  Crap!</p><p> 那就是当您意识到不知道数据库中的所有表都保存不可变的Blob的时候。应用程序一直在不协调的情况下将blob添加到不可变存储中。废话！</p><p> A new level of indirection must be added pushing management of the blobs into dedicated tables and encapsulating updates into specialized modules.  Mostly, applications abide by this but not always.  Old usages referencing the first immutable store must be grandfathered into the system since it’s neigh on impossible to track them down and kill them.</p><p> 必须添加新的间接级别，以将Blob的管理推到专用表中，并将更新封装到专用模块中。通常，应用程序会遵守此规则，但并非总是如此。引用第一个不可变商店的旧用法必须纳入系统，因为它几乎无法追踪并杀死它们。</p><p> Using this new level of indirection, you can more easily manage replication across datacenters and even migration of the immutable blob store to a new datacenter.</p><p> 使用这种新的间接级别，您可以更轻松地管理跨数据中心的复制，甚至可以将不可变的Blob存储迁移到新的数据中心。</p><p>  I’m quite fond of the word “cleave” since it is its own antonym.  You can’t be ALL bad if you’re self-contradicting!</p><p>  我非常喜欢“劈开”一词，因为它是它自己的反义词。如果你自相矛盾，你不会全都坏！ </p><p> One of the BIGGEST problems in software engineering is disentangling the  big ball of mud.  These intertwined and interdependent massive pieces of code can sometimes contain tens of millions of lines of code being curated by many thousands of software engineers.</p><p>软件工程中最大的问题之一是解开泥泞的大球。这些相互交织，相互依存的大量代码有时可能包含由成千上万的软件工程师策划的数千万行代码。</p><p> Unfortunately, many times the social and economic pressures of sharing the precious database caused the creation of your very own big ball of mud.  Once the application culture encouraged unfettered access to any table, it’s VERY hard to change.  It’s hard culturally and its hard to do the software engineering to accomplish the change.</p><p> 不幸的是，很多时候，共享宝贵的数据库所带来的社会和经济压力造成了您自己的大泥潭。一旦应用程序文化鼓励不受限制地访问任何表，就很难更改。在文化上很难，并且很难进行软件工程来完成更改。</p><p> To have a prayer to change this, it must be incremental.  You must drive both carrots and sticks. This can evolve into new ways to accomplish the disentanglement by:</p><p> 要祈祷改变这一点，它必须是渐进的。您必须同时驾驶胡萝卜和棍子。这可以通过以下方法演变成实现解纠缠的新方法：</p><p> Sometimes people stage read-only copies of tables. These are asynchronously updated from the authoritative owning application. Other applications then “own” the read-only copy in their application set of tables.</p><p> 有时人们登台表的只读副本。这些是从权威拥有的应用程序异步更新的。然后，其他应用程序“拥有”其应用程序表集中的只读副本。</p><p> In this way, sometimes there’s success over many years of investment to disentangle.</p><p> 通过这种方式，有时需要多年的成功投资才能摆脱困境。</p><p> Typically, these efforts are driven by the armchair  enterprise architects who haven’t coded in decades, spout philosophical adages, and draw pretty pictures.    Oh… wait… that’s ME!  I haven’t coded since 1988, never shut up, and love to have my laptop on my lap in a big easy chair.  And I DO draw pretty pictures!  Sheesh!</p><p> 通常，这些努力是由扶手椅式企业架构师推动的，这些企业架构师数十年来没有编写代码，吐出哲学格言并绘制漂亮的图画。哦……等等……就是我！自1988年以来我就没有编码，从不闭嘴，并且喜欢将笔记本电脑放在大腿上的安乐椅上。我会画漂亮的图画！嘘！</p><p> Many times these architectural projects are hobbled by the natural cultural clash between these  ivory tower thinkers (like me) and the folks that need to do the real work.  Most successful efforts to disentangle huge systems are only partially successful.  When they are, it’s because they are led with lots of attention to the cultural challenges, fair and thoughtful compensation for success when accomplishing goals, prioritizing disentanglement against new features, and avoiding  them versus us team dynamics.  That requires true leadership.  I wish you the best of luck.</p><p> 这些建筑项目常常被象牙塔思维者（像我这样）和需要做真实工作的人们之间的自然文化冲突所困扰。解开大型系统的最成功的努力只是部分成功。当他们成为现实时，是因为他们引起了人们对文化挑战的极大关注，在达成目标时成功地给予了公平和周到的补偿，优先考虑了对新功能的了解，并避免了它们与我们的团队动力。这需要真正的领导。祝你好运。 </p><p> In some ways, it is MUCH easier to cleave apart a huge application than to cleave together two applications with disparate heritage.  When you acquire another company, their application is based on a dramatically different corporate culture, different understandings of even the simplest concepts like “customer”, and a massive mess as their metadata is combined with your metadata.</p><p>在某些方面，将一个巨大的应用程序分开比将具有不同传统的两个应用程序分开要容易得多。当您收购另一家公司时，他们的应用程序基于完全不同的公司文化，对最简单概念（例如“客户”）的不同理解，以及它们的元数据与您的元数据相结合的混乱局面。</p><p> Cleaving apart huge application is like straightening the streets of downtown Boston, notorious for having a city map created based on cow paths in the 1630s.  Straightening the streets would have been easier without the skyscrapers in the way.</p><p> 分割巨大的应用程序就像拉直波士顿市中心的街道一样，以在1630年代基于母牛的路径创建城市地图而臭名昭著。如果没有摩天大楼，拉直街道本来会更容易。</p><p>   You’ve pulled out the immutable blobs and only had modest success disentangling the different applications.  Hence, they still all need to be on the SAME database.</p><p>   您拔出了不可变的Blob，但在区分不同的应用程序方面仅取得了一定的成功。因此，它们仍然都需要位于SAME数据库中。</p><p> Scale up: You try very hard to   scale up the database.  Buying bigger and better hardware can go a long way.</p><p> 扩大规模：您非常努力地扩大数据库规模。购买更大更好的硬件可能会走很长一段路。</p><p> Scale out: Next, you try to   scale out the database hoping to use multiple computers in a cluster to get a bigger database.</p><p> 向外扩展：接下来，您尝试向外扩展数据库，希望使用集群中的多台计算机来获得更大的数据库。</p><p>    Applications are always developed hand-in-glove with their platform.  In this case, a major part of that platform is the database.  Moving an existing large application to a new database can be more traumatic than concurrently getting a new job, moving to a new town, divorcing your spouse, and marrying someone in Las Vegas you met the night before.  It usually has about the same success rate.</p><p>    应用程序总是与其平台紧密结合而开发的。在这种情况下，该平台的主要部分是数据库。将现有的大型应用程序迁移到新数据库可能比同时获得一份新工作，迁移到新城镇，与配偶离婚并在前一天晚上遇到的拉斯维加斯结婚要痛苦得多。它通常具有大约相同的成功率。</p><p> There are many subtle aspects to your database that are SURE to impact many, many parts of your multi-million lines of code application.  Some of these are:</p><p> 数据库中有许多微妙的方面，这些方面肯定会影响数百万行代码应用程序中的很多部分。其中一些是： </p><p> Usage of non-standard database features.  Every database vendor has cool and wonderful non-standard stuff.  Most of the time, esoteric use of these has been deeply entrenched into the code base since they were added by a programmer now long gone.</p><p>使用非标准数据库功能。每个数据库供应商都有很棒的很棒的非标准内容。大多数时候，这些秘诀的使用已经深深扎根于代码库中，因为它们早已由程序员添加了。</p><p> Concurrency semantics.  The subtleties of  MVCC (Multi-Version Concurrency Control) versus  Serializability versus  Repeatable Reads versus  Read Committed are not for the faint of heart.  I guarantee they are very rarely good topics for discussion on a first date!  I also guarantee that sliding different concurrency semantics under an existing large application is a  fool’s errand.</p><p> 并发语义。 MVCC（多版本并发控制）与可序列化性与可重复读取与已提交读取的精妙之处并不在于胆小。我保证它们很少是第一次讨论的好话题！我还保证在现有的大型应用程序下滑动不同的并发语义是一个愚蠢的事情。</p><p> Optimistic versus Pessimistic Concurrency Control.  In  optimistic concurrency control, the work of the transaction is done BEFORE ensuring you don’t bump into other transactional updates.  If you do collide, the transaction is aborted.  It is frequently (but not always) more efficient.  In  pessimistic concurrency control, resources are locked to ensure you don’t fail when completing.  While typically more expensive, it can prevent floundering when optimistic concurrency repeatedly fails to commit due to conflicts.  While the choice between optimistic and pessimistic does not actually affect the correctness of changes made by the application,  changing the databases behavior away from the application’s expectations can EASILY cause so many performance problems the application is useless.</p><p> 乐观与悲观并发控制。在乐观并发控制中，在确保您不会遇到其他交易更新之前，已完成交易的工作。如果发生冲突，事务将中止。它通常（但不总是）更有效率。在悲观并发控制中，资源被锁定以确保完成时不会失败。尽管通常比较昂贵，但是当乐观并发由于冲突而反复提交失败时，它可以防止陷入困境。虽然在乐观和悲观之间进行选择实际上不会影响应用程序所做更改的正确性，但将数据库行为更改为超出应用程序预期的范围可能会轻易导致许多性能问题，而应用程序则无用。</p><p> Taking an application from one set of expectations to another is like taking an aged grandparent in their 90s from one country to another one.  It ain’t easy at best!</p><p> 将申请从一组期望转移到另一个期望，就像将90多岁的祖父母从一个国家带到另一个国家一样。充其量是不容易的！</p><p> Furthermore, even if you take the same database from a centralized system to a distributed system, the application performance will almost certainly suffer in some ways while you may gain some scaling.  Coordinating locks and concurrency will have different performance challenges and the transition will be a rough road at best. Tuning an application to a distributed database requires patience and insight.</p><p> 此外，即使您将同一数据库从集中式系统转移到分布式系统，几乎可以肯定的是，在获得一定程度的扩展的同时，应用程序的性能肯定会受到某些影响。协调锁和并发将面临不同的性能挑战，并且过渡最多将是一条艰难的路。将应用程序调整到分布式数据库需要耐心和洞察力。</p><p> Applications are deeply aware of the peculiarities and quirks of their database.  Just getting one to run scaled out distributed database past a modest number of nodes is rarely easy and frequently impossible.  Getting it to run fast with lower latency is even harder.</p><p> 应用程序深知其数据库的特性和怪癖。仅仅让一个服务器运行经过一定数量的节点就可以向外扩展的分布式数据库很难，而且常常是不可能的。使它以较低的延迟快速运行更加困难。</p><p>  Databases are special and curious critters.  I love them and definitely think they are a pain-in-the-back.  Maybe even lower.</p><p>  数据库是特殊而奇怪的生物。我爱他们，并且绝对认为他们是痛苦的。甚至更低。 </p><p> Having a lot of databases in your company is annoying and expensive, especially the challenges of operating them. The best advice I can give to a user of a database is to use it carefully and sparingly.  If at all possible:</p><p>公司中拥有许多数据库既烦人又昂贵，特别是在操作数据库方面遇到的挑战。我可以给数据库用户的最佳建议是谨慎谨慎地使用它。如果可能的话：</p><p> Manage blobs.  Create a formalized mechanism to handle blobs, even if you keep them in the database in the short run and move them elsewhere later,</p><p> 管理Blob。创建一种规范化的机制来处理Blob，即使您将它们在短期内保留在数据库中，之后再将其移至其他位置，</p><p>  Use messaging across applications.  Connect the applications with some form of asynchronous messaging even if it’s simply implemented as rows in a database table enqueued and dequeued in separate transactions.  That, combined with isolating the applications can make the move to multiple databases practical.</p><p>  在应用程序之间使用消息传递。将应用程序与某种形式的异步消息连接起来，即使该消息只是简单地实现为在单独事务中排队和出队的数据库表中的行。结合隔离应用程序，可以使向多个数据库的迁移变得切实可行。</p><p> Of course, that requires discipline.  Discipline is something I am woefully short on so I’m not going to point fingers.</p><p> 当然，这需要纪律。纪律是我严重缺乏的东西，所以我不会指责。</p><p>  What aspects of a relational database make it so much more industrial strength and capable of supporting mission critical applications?  Is this intrinsic to the relational model or is it simply a consequence of the large management and operational investments in database systems to date?</p><p>  关系数据库的哪些方面使其具有更大的工业实力并能够支持关键任务应用程序？这是关系模型所固有的，还是仅仅是迄今为止对数据库系统的大量管理和运营投资的结果？</p><p> Are these technological challenges or social challenges?  Is there a difference? How can you tell the difference?</p><p> 这些是技术挑战还是社会挑战？有区别吗？您如何分辨差异？</p><p>  Are these problems simply due to earlier (very reasonable) assumptions that have moved away from being applicable?   Is this simply   the way we do things around here that gets us into this pickle?</p><p>  这些问题是否仅仅是由于早先的（非常合理的）假设已经不适用而造成的？这仅仅是我们在这里做事的方式，使我们陷入这种泡菜吗？ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pathelland.substack.com/p/if-all-you-have-is-a-database-everything">https://pathelland.substack.com/p/if-all-you-have-is-a-database-everything</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1037928.html"><img src="http://img2.diglog.com/img/2020/12/thumb_4127889d7ffc4d7a5111b930a149f25b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037928.html">游戏用户界面数据库，游戏界面设计的综合参考 </a></div><span class="my_story_list_date">2020-12-6 0:17</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037574.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a8416ccf1614d03cdc14263ddaa3bef3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037574.html">报告：在数据库密码保留在卫生部网站的源代码中之后，至少有2.43亿巴西人的数据被暴露了六个月 </a></div><span class="my_story_list_date">2020-12-4 21:20</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037523.html"><img src="http://img2.diglog.com/img/2020/12/thumb_75c52d4ff3293caad2872f785084a0f7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037523.html">CoroBase：使用C ++ 20协程隐藏缓存未命中的数据库引擎 </a></div><span class="my_story_list_date">2020-12-4 21:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037302.html"><img src="http://img2.diglog.com/img/2020/11/thumb_7793a5bd5e73c68cc2427cf44682478c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037302.html">Materialise获4000万美元SQL流数据库投资</a></div><span class="my_story_list_date">2020-11-30 23:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>