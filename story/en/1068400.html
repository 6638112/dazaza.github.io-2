<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析，不要验证（2019） Parse, Don't Validate (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parse, Don't Validate (2019)<br/>解析，不要验证（2019） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 15:53:53</div><div class="page_narrow text-break page_content"><p>Historically, I’ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me “How did you come up with this approach?” I find I can’t give them a satisfying answer. I know it didn’t just come to me in a vision—I have an iterative design process that doesn’t require plucking the “right” approach out of thin air—yet I haven’t been very successful in communicating that process to others.</p><p>从历史上看，我已经努力找到一个简洁的，简单的方法来解释练习类型驱动的设计意味着什么。太多，当有人问我“你是怎么想起这种方法的？”我发现我不能给他们一个令人满意的答案。我知道它不仅仅是在愿景中来找我 - 我有一个迭代的设计过程，不需要采取薄薄的空气中的“正确”的方法，但我并没有成功地向他人沟通该过程。</p><p> However, about a month ago,  I was reflecting on Twitter about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it’s only three words long:</p><p> 然而，大约一个月前，我在静态和动态类型的语言中经历了解析json的差异，我反映了Twitter，最后，我意识到了我正在寻找的东西。现在我有一个单身，Snappy口号，封装了什么类型的驱动设计对我来说意味着什么，更好，但它只有三个字长：</p><p>   Alright, I’ll confess: unless you already know what type-driven design is, my catchy slogan probably doesn’t mean all that much to you. Fortunately, that’s what the remainder of this blog post is for. I’m going to explain precisely what I mean in gory detail—but first, we need to practice a little wishful thinking.</p><p>   好吧，我会承认：除非你已经知道什么类型的驱动设计，否则我的吸引人的口号可能对你来说并不意味着这一切。幸运的是，这就是这个博客帖子的其余部分。我将正是在血腥细节中的意思解释 - 但首先，我们需要练习一下一般的一厢情愿。</p><p>  One of the wonderful things about static type systems is that they can make it possible, and sometimes even easy, to answer questions like “is it possible to write this function?” For an extreme example, consider the following Haskell type signature:</p><p>  关于静态系统的一个美妙的事情是，他们可以使他们能够实现，有时甚至容易，以回答“它可以写这个功能是可能的？”对于一个极端的例子，请考虑以下Haskell类型签名：</p><p>  Is it possible to implement  foo? Trivially, the answer is  no, as  Void is a type that contains no values, so it’s impossible for  any function to produce a value of type  Void.  1 That example is pretty boring, but the question gets much more interesting if we choose a more realistic example:</p><p>  是否有可能实现foo？溯源，答案是否，因为void是一个不包含值的类型，所以任何功能都不可能产生类型void的值。 1示例非常无聊，但如果我们选择更现实的例子，问题会更有趣：</p><p>  This function returns the first element from a list. Is it possible to implement? It certainly doesn’t sound like it does anything very complicated, but if we attempt to implement it, the compiler won’t be satisfied:</p><p>  此函数从列表中返回第一个元素。是否有可能实施？它肯定没有听起来它做了什么非常复杂的，但如果我们试图实现它，编译器将不会满足：</p><p>  warning: [-Wincomplete-patterns] Pattern match(es) are non-exhaustive In an equation for ‘head’: Patterns not matched: []</p><p>  警告：[-wincomplete-patterns]模式匹配在“头”的等式中是非详尽无遗的：模式不匹配：[] </p><p> This message is helpfully pointing out that our function is  partial, which is to say it is not defined for all possible inputs. Specifically, it is not defined when the input is  [], the empty list. This makes sense, as it isn’t possible to return the first element of a list if the list is empty—there’s no element to return! So, remarkably, we learn this function isn’t possible to implement, either.</p><p>此消息有助于指出，我们的功能是部分的，这就是说它没有为所有可能的输入定义。具体地，当输入是[]，空列表时未定义。这是有道理的，因为如果列表是空的，则无法返回列表的第一个元素 - 没有元素要返回！因此，显着的，我们学习该功能也无法实现。</p><p>  To someone coming from a dynamically-typed background, this might seem perplexing. If we have a list, we might very well want to get the first element in it. And indeed, the operation of “getting the first element of a list” isn’t impossible in Haskell, it just requires a little extra ceremony. There are two different ways to fix the  head function, and we’ll start with the simplest one.</p><p>  对于来自动态键入的背景的人来说，这似乎令人困惑。如果我们有一个列表，我们可能非常希望得到它的第一个元素。事实上，Haskell的“获取名单的第一个元素”的操作并非不可能，它只是需要一点额外的仪式。有两种不同的方法来修复头部功能，我们将从最简单的方式开始。</p><p>  As established,  head is partial because there is no element to return if the list is empty: we’ve made a promise we cannot possibly fulfill. Fortunately, there’s an easy solution to that dilemma: we can weaken our promise. Since we cannot guarantee the caller an element of the list, we’ll have to practice a little expectation management: we’ll do our best return an element if we can, but we reserve the right to return nothing at all. In Haskell, we express this possibility using the  Maybe type:</p><p>  正如所建立的那样，如果列表为空，则头部是部分的，因为如果列表是空的，则没有元素：我们已经提出了一个我们不可能实现的承诺。幸运的是，对该困境有一种简单的解决方案：我们可以削弱我们的承诺。由于我们不能保证来电者列表的一个元素，我们必须练习一点期望管理：如果我们可以，我们会尽力回归一个元素，但我们保留了任何返回的权利。在Haskell，我们使用可能类型的可能性表示：</p><p>  This buys us the freedom we need to implement  head—it allows us to return  Nothing when we discover we can’t produce a value of type  a after all:</p><p>  这为我们提出了我们需要实现头部的自由 - 它允许我们在发现我们无法生成毕竟没有产生类型的值时返回任何内容：</p><p>  Problem solved, right? For the moment, yes… but this solution has a hidden cost.</p><p>  问题解决了，对吧？暂时，是的...但是这个解决方案有隐藏的成本。</p><p> Returning  Maybe is undoubtably convenient when we’re  implementing  head. However, it becomes significantly less convenient when we want to actually use it! Since  head always has the potential to return  Nothing, the burden falls upon its callers to handle that possibility, and sometimes that passing of the buck can be incredibly frustrating. To see why, consider the following code:</p><p> 当我们实施头时，返回可能是无疑的方便。但是，当我们想要实际使用它时，它变得明显不太方便！由于头部总是有可能返回任何东西，因此负担落在呼叫者身上，以处理这种可能性，有时，降压的传递可能会令人难以置信的令人沮丧。要查看为什么，请考虑以下代码：</p><p> getConfigurationDirectories  ::  IO  [ FilePath ] getConfigurationDirectories  =  do  configDirsString  &lt;-  getEnv  &#34;CONFIG_DIRS&#34;  let  configDirsList  =  split  &#39;,&#39;  configDirsString  when  ( null  configDirsList )  $  throwIO  $  userError  &#34;CONFIG_DIRS cannot be empty&#34;  pure  configDirsList main  ::  IO  () main  =  do  configDirs  &lt;-  getConfigurationDirectories  case  head  configDirs  of  Just  cacheDir  -&gt;  initializeCache  cacheDir  Nothing  -&gt;  error  &#34;should never happen; already checked configDirs is non-empty&#34;</p><p> getconfigurationDirectories :: io [filepath] getconfigurationdirectories = do configdirsstring＆lt;  -  getenv＆＃34; config_dirs＆＃34;让configdirslist = split＆＃39;，＆＃39; configdirsstring何时（null configdirslist）$ throwe $ usererror＆＃34; config_dirs不能为空＆＃34; pure configdirslist main :: io（）main = do configdirs＆lt;  -  getconfigurationDirectories案例Head CommendIns的只是Cachedir  - ＆gt; InitializeCache Cachedir什么都没有 - ＆gt;错误＆＃34;永远不会发生;已经检查的configdirs是非空的＆＃34; </p><p> When  getConfigurationDirectories retrieves a list of file paths from the environment, it proactively checks that the list is non-empty. However, when we use  head in  main to get the first element of the list, the  Maybe FilePath result still requires us to handle a  Nothing case that we know will never happen! This is terribly bad for several reasons:</p><p>当getConfigurationDirectories从环境中检索文件路径列表时，它主动检查列表是非空的。但是，当我们用头部使用头部获取列表的第一个元素时，可能仍然需要我们处理我们所知道永远不会发生的事情的事情！这有几个原因非常糟糕：</p><p> First, it’s just annoying. We already checked that the list is non-empty, why do we have to clutter our code with another redundant check?</p><p> 首先，这只是烦人。我们已经检查了该列表是非空的，为什么我们必须将代码与另一个冗余支票混乱？</p><p>  Second, it has a potential performance cost. Although the cost of the redundant check is trivial in this particular example, one could imagine a more complex scenario where the redundant checks could add up, such as if they were happening in a tight loop.</p><p>  其次，它具有潜在的性能成本。虽然在该特定示例中冗余检查的成本是微不足道的，但是可以想象一个更复杂的场景，其中冗余检查可以加起来，例如它们在紧密的循环中发生。</p><p>  Finally, and worst of all, this code is a bug waiting to happen! What if  getConfigurationDirectories were modified to stop checking that the list is empty, intentionally or unintentionally? The programmer might not remember to update  main, and suddenly the “impossible” error becomes not only possible, but probable.</p><p>  最后，最糟糕的是，这段代码是等待发生的错误！如果修改了GetConfigurationDirectories以停止检查列表是否为空，故意或无意中，该怎么办？程序员可能不记得更新主要，突然间“不可能”的错误变得不仅可能，而且可能。</p><p> The need for this redundant check has essentially forced us to punch a hole in our type system. If we could statically  prove the  Nothing case impossible, then a modification to  getConfigurationDirectories that stopped checking if the list was empty would invalidate the proof and trigger a compile-time failure. However, as-written, we’re forced to rely on a test suite or manual inspection to catch the bug.</p><p> 对此冗余检查的需求基本上迫使我们在我们的类型系统中打孔。如果我们可以静态证明无所事事，那么修改到GetConfigurationDirectories，停止检查列表是否为空，无效，验证并触发编译时失败。但是，按照写作，我们被迫依靠测试套件或手动检查来捕获错误。</p><p>  Clearly, our modified version of  head leaves some things to be desired. Somehow, we’d like it to be smarter: if we already checked that the list was non-empty,  head should unconditionally return the first element without forcing us to handle the case we know is impossible. How can we do that?</p><p>  显然，我们的修改版本的头部留下了一些需要的东西。不知何故，我们希望它更智能：如果我们已经检查了该列表是非空的，则应无条件地返回第一个元素而不强迫我们处理我们所知道的情况是不可能的。我们怎样才能这样做？</p><p>   The previous section illustrated that we can turn that partial type signature into a total one by weakening the promise made in the return type. However, since we don’t want to do that, there’s only one thing left that can be changed: the argument type (in this case,  [a]). Instead of weakening the return type, we can  strengthen the argument type, eliminating the possibility of  head ever being called on an empty list in the first place.</p><p>   上一节说明了，通过削弱返回类型所做的承诺，我们可以将该部分类型签名转换为总体。但是，由于我们不想这样做，只剩下一件事可以更改：参数类型（在这种情况下，[a]）。我们可以加强参数类型，而不是削弱返回类型，而是消除首先在空名单上调用头部的可能性。 </p><p> To do this, we need a type that represents non-empty lists. Fortunately, the existing  NonEmpty type from  Data.List.NonEmpty is exactly that. It has the following definition:</p><p>为此，我们需要一种表示非空列表的类型。幸运的是，来自data.list.nonuspty的现有的非空类型正好。它具有以下定义：</p><p>  Note that  NonEmpty a is really just a tuple of an  a and an ordinary, possibly-empty  [a]. This conveniently models a non-empty list by storing the first element of the list separately from the list’s tail: even if the  [a] component is  [], the  a component must always be present. This makes  head completely trivial to implement:  2</p><p>  请注意，非空A实际上只是一个普通的，可能是空的[a]的元组。这通过将列表的第一个元素与列表的尾部分开存储来方便地绘制非空列表：即使[A]组件是[]，必须始终存在组件。这使得头部完全微不足道实现：2</p><p>  Unlike before, GHC accepts this definition without complaint—this definition is  total, not partial. We can update our program to use the new implementation:</p><p>  与之前不同，GHC接受此定义而无需投诉 - 此定义是完全的，而不是部分。我们可以更新我们的程序以使用新的实现：</p><p> getConfigurationDirectories  ::  IO  ( NonEmpty  FilePath ) getConfigurationDirectories  =  do  configDirsString  &lt;-  getEnv  &#34;CONFIG_DIRS&#34;  let  configDirsList  =  split  &#39;,&#39;  configDirsString  case  nonEmpty  configDirsList  of  Just  nonEmptyConfigDirsList  -&gt;  pure  nonEmptyConfigDirsList  Nothing  -&gt;  throwIO  $  userError  &#34;CONFIG_DIRS cannot be empty&#34; main  ::  IO  () main  =  do  configDirs  &lt;-  getConfigurationDirectories  initializeCache  ( head  configDirs )</p><p> getconfigurationDirectories :: IO（nonempty filepath）getconfigurationDirectories = do configdirsstring＆lt;  -  getenv＆＃34; config_dirs＆＃34;让configdirslist = split＆＃39;，＆＃39; configdirsstring case nonempty configdirslist只是nonemptyconfigdirslist  - ＆gt;纯粹的nonemptyconfigdirslist nother  - ＆gt; Throwio $ userError＆＃34; config_dirs不能为空＆＃34; main :: io（）main = do configdirs＆lt;  -  getconfigurationDirectories initializecache（head configdirs）</p><p> Note that the redundant check in  main is now completely gone! Instead, we perform the check exactly once, in  getConfigurationDirectories. It constructs a  NonEmpty a from a  [a] using the  nonEmpty function from  Data.List.NonEmpty, which has the following type:</p><p> 请注意，主要的冗余支票现在完全消失了！相反，我们在GetConfigurationDirectories中完成一次检查一次。它使用来自data.list.nonusemy的非空函数来构造来自[a]的非空的A.NONEMPTY，其具有以下类型：</p><p>  The  Maybe is still there, but this time, we handle the  Nothing case very early in our program: right in the same place we were already doing the input validation. Once that check has passed, we now have a  NonEmpty FilePath value, which preserves (in the type system!) the knowledge that the list really is non-empty. Put another way, you can think of a value of type  NonEmpty a as being like a value of type  [a], plus a  proof that the list is non-empty.</p><p>  也许仍在那里，但这一次，我们在我们的程序中很早就处理了什么意思：在我们已经完成输入验证的同一个地方就在同一个地方。一旦检查已通过，我们现在有一个非空的文件符值，它保留（在类型系统中！）列表确实是非空的知识。换句话说，您可以考虑类型的非空闲A值，就像[a]类型的值，加上列表非空的证明。</p><p> By strengthening the type of the argument to  head instead of weakening the type of its result, we’ve completely eliminated all the problems from the previous section:</p><p> 通过加强头部参数的类型而不是削弱其结果的类型，我们完全从上一节中删除了所有问题： </p><p> The code has no redundant checks, so there can’t be any performance overhead.</p><p>代码没有冗余检查，因此不能有任何性能开销。</p><p>  Furthermore, if  getConfigurationDirectories changes to stop checking that the list is non-empty, its return type must change, too. Consequently,  main will fail to typecheck, alerting us to the problem before we even run the program!</p><p>  此外，如果GetConfigurationDirectories更改以停止检查列表是非空的，则其返回类型也必须更改。因此，主要将无法进行TypeCreck，在我们运行该计划之前提醒我们解决问题！</p><p> What’s more, it’s trivial to recover the old behavior of  head from the new one by composing  head with  nonEmpty:</p><p> 更重要的是，通过用nonempty撰写头部从新的行为恢复头脑的旧行为是微不足道的：</p><p>  Note that the inverse is  not true: there is no way to obtain the new version of  head from the old one. All in all, the second approach is superior on all axes.</p><p>  请注意，逆不正确：无法从旧版本获取新版本的头部。总而言之，所有轴上的第二种方法都是优越的。</p><p>  You may be wondering what the above example has to do with the title of this blog post. After all, we only examined two different ways to validate that a list was non-empty—no parsing in sight. That interpretation isn’t wrong, but I’d like to propose another perspective: in my mind, the difference between validation and parsing lies almost entirely in how information is preserved. Consider the following pair of functions:</p><p>  您可能想知道上面的示例与此博客文章的标题有关。毕竟，我们只检查了两种不同的方法来验证列表是非空的 - 没有解析视线。这种解释没有错，但我想提出另一个视角：在我的脑海中，验证和解析之间的区别几乎完全是如何保留的信息。考虑以下功能：</p><p> validateNonEmpty  ::  [ a ]  -&gt;  IO  () validateNonEmpty  ( _ : _ )  =  pure  () validateNonEmpty  []  =  throwIO  $  userError  &#34;list cannot be empty&#34; parseNonEmpty  ::  [ a ]  -&gt;  IO  ( NonEmpty  a ) parseNonEmpty  ( x : xs )  =  pure  ( x :| xs ) parseNonEmpty  []  =  throwIO  $  userError  &#34;list cannot be empty&#34;</p><p> ValidatenOnusempty :: [a]  - ＆gt; io（）validatenonempty（_：_）= pure（）validatenonempty [] = throwio $ userError＆＃34;列表不能为空＆＃34; Parsenonempty :: [a]  - ＆gt; io（nonempty a）parsenonempty（x：xs）= pure（x：| xs）parsenonempty [] = throwio $ usererror＆＃34;列表不能为空＆＃34;</p><p> These two functions are nearly identical: they check if the provided list is empty, and if it is, they abort the program with an error message. The difference lies entirely in the return type:  validateNonEmpty always returns  (), the type that contains no information, but  parseNonEmpty returns  NonEmpty a, a refinement of the input type that preserves the knowledge gained in the type system. Both of these functions check the same thing, but  parseNonEmpty gives the caller access to the information it learned, while  validateNonEmpty just throws it away.</p><p> 这两个函数几乎相同：检查所提供的列表是否为空，如果是，则它们中止了具有错误消息的程序。差异完全在返回类型中：ValidAtenOnempty始终返回（），不包含信息的类型，但帕索纳纽瓦斯返回Nonempty A的输入类型，这些输入类型保留了类型系统中所获得的知识。这两个函数都检查了同样的事情，但帕索纳纽马克拨备了来电者访问它所学到的信息，而ValidAtenHempty刚刚抛弃它。 </p><p> These two functions elegantly illustrate two different perspectives on the role of a static type system:  validateNonEmpty obeys the typechecker well enough, but only  parseNonEmpty takes full advantage of it. If you see why  parseNonEmpty is preferable, you understand what I mean by the mantra “parse, don’t validate.” Still, perhaps you are skeptical of  parseNonEmpty’s name. Is it really  parsing anything, or is it merely validating its input and returning a result? While the precise definition of what it means to parse or validate something is debatable, I believe  parseNonEmpty is a bona-fide parser (albeit a particularly simple one).</p><p>这两个功能优雅地说明了静态系统的作用的两种不同的视角：ValidatenOnempty obeys足够的TypeChecker，但只有Parsenempley充分利用它。如果你看到为什么ParsenAnempty是优选的，你明白Mantra“解析，不要验证的意思。尽管如此，你仍然是对帕索纳克的名字持怀疑态度。它真的解析了什么，还是它只是验证它的输入并返回结果？虽然对解析或验证某些东西的精确定义是值得简言的，但我认为Parsennempty是一个真正的解析器（尽管是一个特别简单的解析器）。</p><p> Consider: what is a parser? Really, a parser is just a function that consumes less-structured input and produces more-structured output. By its very nature, a parser is a partial function—some values in the domain do not correspond to any value in the range—so all parsers must have some notion of failure. Often, the input to a parser is text, but this is by no means a requirement, and  parseNonEmpty is a perfectly cromulent parser: it parses lists into non-empty lists, signaling failure by terminating the program with an error message.</p><p> 考虑：什么是解析器？实际上，解析器只是消耗较少结构输入的功能，并产生更多结构化输出。通过其本质，解析器是一个部分函数 - 域中的某些值与范围中的任何值都不对应 - 因此所有解析器必须具有一些故障概念。通常，对解析器的输入是文本，但这绝不是一个要求，帕索纳姆空质量是一个完美的哼唱者解析器：它将列表解析为非空列表，通过用错误消息终止程序来解析为非空列表。</p><p> Under this flexible definition, parsers are an incredibly powerful tool: they allow discharging checks on input up-front, right on the boundary between a program and the outside world, and once those checks have been performed, they never need to be checked again! Haskellers are well-aware of this power, and they use many different types of parsers on a regular basis:</p><p> 在这种灵活的定义下，解析器是一个令人难以置信的强大工具：它们允许在程序和外部世界之间的边界上对输入进行拨出检查，并且一旦执行这些检查，他们从不需要再次检查！ Haskellers很清楚这一电源，他们定期使用许多不同类型的解析器：</p><p> The  aeson library provides a  Parser type that can be used to parse JSON data into domain types.</p><p> AESON库提供了一种解析器类型，可用于将JSON数据解析为域类型。</p><p>    Database libraries like  persistent and  postgresql-simple have a mechanism for parsing values held in an external data store.</p><p>    像持久性和postgreSQL-Simply的数据库库有一个机制，用于解析在外部数据存储中的解析值。</p><p>  The  servant ecosystem is built around parsing Haskell datatypes from path components, query parameters, HTTP headers, and more.</p><p>  仆人生态系统围绕Parsing Haskell数据类型从路径组件，查询参数，HTTP标头等内构建。</p><p> The common theme between all these libraries is that they sit on the boundary between your Haskell application and the external world. That world doesn’t speak in product and sum types, but in streams of bytes, so there’s no getting around a need to do some parsing. Doing that parsing up front, before acting on the data, can go a long way toward avoiding many classes of bugs, some of which might even be security vulnerabilities.</p><p> 所有这些库之间的共同主题是它们坐在Haskell应用程序和外部世界之间的边界上。这个世界在产品和总和中没有说话，但在字节的溪流中，因此没有必要进行一些解析。在对数据行事之前，对前面进行解析，可以走很长的路要避免许多类别的错误，其中一些甚至可能是安全漏洞。 </p><p> One drawback to this approach of parsing everything up front is that it sometimes requires values be parsed long before they are actually used. In a dynamically-typed language, this can make keeping the parsing and processing logic in sync a little tricky without extensive test coverage, much of which can be laborious to maintain. However, with a static type system, the problem becomes marvelously simple, as demonstrated by the  NonEmpty example above: if the parsing and processing logic go out of sync, the program will fail to even compile.</p><p>对前面解析所有内容的这种方法的一个缺点是它有时需要在实际使用之前长时间解析值。以一种动态类型的语言，这可以使解析和处理逻辑同步一点棘手而没有广泛的测试覆盖，其中大部分可能是费力的维护。但是，对于静态类型系统，问题变得非常简单，如上面的非空白示例所示：如果解析和处理逻辑超出同步，则程序将无法编译。</p><p>  Hopefully, by this point, you are at least somewhat sold on the idea that parsing is preferable to validation, but you may have lingering doubts. Is validation really so bad if the type system is going to force you to do the necessary checks eventually anyway? Maybe the error reporting will be a little bit worse, but a bit of redundant checking can’t hurt, right?</p><p>  希望在这一点上，您至少销售了解析优于验证的想法，但您可能会挥之不去的疑虑。验证是否真的如此糟糕，如果类型系统将强迫您迫使您最终进行必要的检查？也许错误报告将有点差，但有点冗余检查不能伤害，对吧？</p><p> Unfortunately, it isn’t so simple. Ad-hoc validation leads to a phenomenon that the  language-theoretic security field calls  shotgun parsing. In the 2016 paper,  The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them, its authors provide the following definition:</p><p> 不幸的是，它并不是那么简单。 ad-hoc验证导致语言 - 理论安全场呼叫猎枪解析的现象。在2016年的论文中，宝贝七炮塔：Langsec错误的分类以及如何开除它们，其作者提供以下定义：</p><p> Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.</p><p> Shotgun解析是一个编程反图案，解析和输入验证代码与在输入时的处理代码抛出云的处理代码和传播，并希望没有任何系统的理由，其中一个或另一个人会捕获所有的“坏”案例。</p><p>  Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.</p><p>  Shotgun解析必然剥夺了拒绝无效输入而不是处理它的能力的程序。输入流中的晚期错误将导致已处理的某些部分无效输入，结果是程序状态难以准确预测。</p><p> In other words, a program that does not parse all of its input up front runs the risk of acting upon a valid portion of the input, discovering a different portion is invalid, and suddenly needing to roll back whatever modifications it already executed in order to maintain consistency. Sometimes this is possible—such as rolling back a transaction in an RDBMS—but in general it may not be.</p><p> 换句话说，不解析其所有输入前面的程序运行了在输入的有效部分作用的风险，发现不同的部分是无效的，并且突然需要回滚它已经执行的任何修改以便保持一致性。有时这是可能的 - 例如在RDBMS中回滚事务 - 但通常它可能不是。</p><p> It may not be immediately apparent what shotgun parsing has to do with validation—after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called “impossible” cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it’s regularly necessary.</p><p> 它可能不会立即显而易见的是霰弹枪解析与验证 - 毕竟，如果您完成所有验证，请减轻霰弹枪解析的风险。问题是基于验证的方法使得非常困难或无法确定一切是否实际验证，如果可能实际上发生了一些所谓的“不可能”的情况。整个程序必须假设在任何地方提出异常，这不仅可能是必要的。 </p><p> Parsing avoids this problem by stratifying the program into two phases—parsing and execution—where failure due to invalid input can only happen in the first phase. The set of remaining failure modes during execution is minimal by comparison, and they can be handled with the tender care they require.</p><p>解析通过将程序分为两个阶段解析和执行来避免此问题 - 仅在第一个阶段发生无效输入导致的故障。执行期间的剩余故障模式的集合最小，并且可以通过它们所需的温柔照顾来处理。</p><p>  So far, this blog post has been something of a sales pitch. “You, dear reader, ought to be parsing!” it says, and if I’ve done my job properly, at least some of you are sold. However, even if you understand the “what” and the “why,” you might not feel especially confident about the “how.”</p><p>  到目前为止，这个博客帖子一直是销售播放的东西。 “你，亲爱的读者，应该是解析！”它说，如果我妥善完成了我的工作，至少有些人卖掉了。然而，即使你了解“什么”和“为什么”，你也可能对“如何”觉得特别有信心。</p><p>  Suppose you are writing a function that accepts a list of tuples representing key-value pairs, and you suddenly realize you aren’t sure what to do if the list has duplicate keys. One solution would be to write a function that asserts there aren’t any duplicates in the list:</p><p>  假设您正在编写一个接受代表键值对的元组列表的函数，并且您突然意识到如果列表具有重复键，则不确定您该怎么办。一个解决方案是编写一个函数，该函数是列表中没有任何重复项：</p><p>  However, this check is fragile: it’s extremely easy to forget. Because its return value is unused, it can always be omitted, and the code that needs it would still typecheck. A better solution is to choose a data structure that disallows duplicate keys by construction, such as a  Map. Adjust your function’s type signature to accept a  Map instead of a list of tuples, and implement it as you normally would.</p><p>  但是，这个检查很脆弱：它很容易忘记。因为它的返回值未使用，因此可以始终省略它，并且需要它仍然可以typecheck的代码。更好的解决方案是选择一种数据结构，该数据结构可以通过施工禁止重复键，例如地图。调整函数的类型签名以接受地图而不是元组列表，并根据您的正常实现它。</p><p> Once you’ve done that, the call site of your new function will likely fail to typecheck, since it is still being passed a list of tuples. If the caller was given the value via one of its arguments, or if it received it from the result of some other function, you can continue updating the type from list to  Map, all the way up the call chain. Eventually, you will either reach the location the value is created, or you’ll find a place where duplicates actually ought to be allowed. At that point, you can insert a call to a modified version of  checkNoDuplicateKeys:</p><p> 完成后，您的新功能的呼叫站点可能会无法进行TypeCreck，因为它仍然被传递了元组列表。如果呼叫者通过其中一个参数给出了值，或者从其他函数的结果收到它，您可以继续将类型从列表更新到映射，一直呼叫链。最终，您将达到创建值的位置，或者您可以找到实际应允许重复的地方。此时，您可以插入调用CheckNoduplignKeys的修改版本：</p><p> checkNoDuplicateKeys  ::  ( MonadError  AppError  m ,  Eq  k )  =&gt;  [( k ,  v )]  -&gt;  m  ( Map  k  v )</p><p> CheckNoduplicateKeys ::（MonadError Apperror M，EQ K）=＆gt; [（k，v）]  - ＆gt; m（map k v）</p><p> Now the check  cannot be omitted, since its result is actually necessary for the program to proceed!</p><p> 现在，无法省略检查，因为它的结果实际上是该程序所必需的！ </p><p>  Use a data structure that makes illegal states unrepresentable. Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Don’t be afraid to refactor.</p><p>使用使非法状态不足的数据结构。使用您合理的最精确的数据结构来模拟您的数据。如果使用当前使用的编码来解除特定可能性太难过，请考虑备用编码，可以更轻松地表达您要关心的属性。不要害怕重构。</p><p>  Push the burden of proof upward as far as possible, but no further. Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before  any of the data is acted upon.  3</p><p>  尽可能将证明的负担推动，但没有进一步。将您的数据达到您尽快所需的最精确的表示。理想情况下，这应该发生在系统的边界，在任何数据采取行动之前。 3.</p><p>  If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow.</p><p>  如果一个特定的代码分支最终需要一条数据的更精确表示，则一旦选择分支，就会将数据解析为更精确的表示。明智地使用和类型允许您的数据类型反映和适应控制流程。</p><p> In other words, write functions on the data representation you  wish you had, not the data representation you are given. The design process then becomes an exercise in bridging the gap, often by working from both ends until they meet somewhere in the middle. Don’t be afraid to iteratively adjust parts of the design as you go, since you may learn something new during the refactoring process!</p><p> 换句话说，在您希望拥有的数据表示上写入功能，而不是您给出的数据表示。然后设计过程成为桥接间隙的运动，通常通过从两端工作，直到它们在中间的某个地方遇到。不要害怕在你去的时候迭代调整设计的部件，因为你可以在重构过程中学习新的东西！</p><p>  Let your datatypes inform your code, don’t let your code control your datatypes. Avoid the temptation to just stick a  Bool in a record somewhere because it’s needed by the function you’re currently writing. Don’t be afraid to refactor code to use the right data representation—the type system will ensure you’ve covered all the places that need changing, and it will likely save you a headache later.</p><p>  让您的数据类型通知您的代码，不要让您的代码控制数据类型。避免诱惑只需在某处粘在一个唱片中，因为您目前正在编写的功能是必需的。不要害怕重构代码使用正确的数据表示 - 类型系统将确保您已介绍了需要更改的所有位置，并且稍后可能会节省头疼。</p><p>  Treat functions that return  m () with deep suspicion. Sometimes these are genuinely necessary, as they may perform an imperative effect with no meaningful result, but if the primary purpose of that effect is raising an error, it’s likely there’s a better way.</p><p>  处理返回m（）的函数，深度怀疑。有时这些是真正必要的，因为它们可能表现出没有有意义的结果的命令效果，但如果该效果的主要目的是提高错误，那就可能有更好的方法。</p><p>  Don’t be afraid to parse data in multiple passes. Avoiding shotgun parsing just means you shouldn’t act on the input data before it’s fully parsed, not that you can’t use some of the inp</p><p>  不要害怕在多次通过中解析数据。避免霰弹枪解析只意味着您在完全解析之前不应该在输入数据上行事，而不是您不能使用一些INP </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/don/">#don</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>