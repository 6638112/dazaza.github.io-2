<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Zig 0.8.0发行说明 Zig 0.8.0 Release Notes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Zig 0.8.0 Release Notes<br/>Zig 0.8.0发行说明 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 07:04:09</div><div class="page_narrow text-break page_content"><p>Zig is a general-purpose programming language and toolchain for maintaining  robust,  optimal, and  reusable software.</p><p>ZIG是一种通用编程语言和工具链，用于维护强大，最佳和可重复使用的软件。</p><p>  Backed by the  Zig Software Foundation, the project is  financially sustainable and offers billable hours for core team members:</p><p>  该项目支持ZIG软件基金会，该项目是经济可持续的，为核心团队成员提供满足的时间：</p><p>      This release features  7 months of work and changes from  144 different contributors, spread among  2711 commits.</p><p>      此版本具有7个月的工作和从144个不同的贡献者的变化，在2711次提交之间传播。</p><p>          A green check mark (✅) indicates the target meets all the requirements for the support tier. The other icons indicate what is  preventing the target from reaching the support tier. In other words, the icons are  to-do items. If you find any wrong data here please  submit a pull request!</p><p>          绿色复选标记（✅）表示目标符合支持层的所有要求。另一个图标指示可防止目标到达支持层的内容。换句话说，图标是做项目。如果您在此发现有错误的数据，请提交拉动请求！</p><p>    Not only can Zig generate machine code for these targets, but the standard library cross-platform abstractions have implementations for these targets.</p><p>    Zig不仅可以为这些目标生成机器代码，但标准库跨平台抽象具有这些目标的实现。</p><p>    📦 The CI server automatically produces pre-built binaries for these targets, on every commit to master, and updates  the download page with links.</p><p>    📦CIServer自动为这些目标生成预构建的二进制文件，每个提交寄存器，并使用链接更新下载页面。</p><p>      🐛 All the behavior tests and applicable standard library tests pass for this target. All language features are known to work correctly. Experimental features do not count towards disqualifying an operating system or architecture from Tier 1.</p><p>      🐛所有行为测试和适用的标准库测试此目标的传递。已知所有语言功能都可以正常工作。实验特征不计入签订第1层的操作系统或架构。 </p><p>    💀 If the Operating System is proprietary then the target is not marked deprecated by the vendor,  such as macos/x86.</p><p>💀如果操作系统是专有的，则该目标未被供应商弃用，例如MacOS / X86。</p><p>      📖 The standard library supports this target, but it&#39;s possible that some APIs will give an &#34;Unsupported OS&#34; compile error. One can link with libc or other libraries to fill in the gaps in the standard library.</p><p>      📖标准图书馆支持此目标，但它可能会提供一些API将给予＆＃34;不支持的OS＆＃34;编译错误。一个可以链接与libc或其他库来填补标准库中的空白。</p><p>  🔍 These targets are known to work, but may not be automatically tested, so there are occasional regressions.</p><p>  🔍已知这些目标工作，但可能不会自动测试，因此有偶尔的回归。</p><p>  Some tests may be disabled for these targets as we work toward  Tier 1 Support.</p><p>  当我们对第1层支持的工作时，可能会对这些目标禁用某些测试。</p><p>      These targets are not frequently tested; one will likely need to contribute to Zig in order to build for these targets.</p><p>      这些目标没有经常测试;一个可能需要为Zig做出贡献，以便为这些目标建立。</p><p>        If this target is provided by LLVM, LLVM may have the target as an experimental target, which means that you need to use Zig-provided binaries for the target to be available, or build LLVM from source with special configure flags.  zig targets will display the target if it is available.</p><p>        如果LLVM提供此目标，则LLVM可能将目标作为实验目标，这意味着您需要使用Zig提供的二进制文件来获得目标的目标，或者从具有特殊配置标志的源构建LLVM。如果可用，则Zig目标将显示目标。</p><p>  This target may be considered deprecated by an official party,  such as macosx/i386 in which case this target will remain forever stuck in Tier 4.</p><p>  该目标可以被官方聚会弃用，例如MacOSX / I386，在这种情况下，此目标将保持在第4层中永久粘在一起。 </p><p>  This target may only support  -femit-asm and cannot emit object files ( -fno-emit-bin enabled by default and cannot be overridden).</p><p>此目标只能支持 - 缩放ASM，无法发出目标文件（默认启用 -  emno-emit-bin，并且无法被覆盖）。</p><p>    32-bit x86 macOS, 32-bit ARM macOS, powerpc32 and powerpc64 macOS, because Apple has officially dropped support for them.</p><p>    32位X86 MacOS，32位ARM MacOS，PowerPC32和PowerPC64 MacOS，因为Apple已正式删除了对它们的支持。</p><p>      Avoid redundantly providing Windows TLS startup symbols when linking libc because they are already provided by libcrt.</p><p>      链接Libc时，避免冗余提供Windows TLS启动符号，因为它们已由Libcrt提供。</p><p>                          Implemented nt path conversion for windows. Fixes  . and  .. not working in  std.fs paths.</p><p>                          为Windows实现了NT路径转换。修复。并且..不在STD.FS路径中工作。</p><p>    Since Zig ships with  MinGW-w64, Zig can be used to compile C and C++ code on Windows without having MSVC installed. However, before this release, it was not obvious how to take advantage of this feature, since the default behavior was to integrate with MSVC.</p><p>    由于Zig船用MingW-W64，Zig可用于在Windows上编译C和C ++代码而不安装MSVC。但是，在此版本之前，它不明显利用此功能，因为默认行为是与MSVC集成。</p><p>  In this release, the default behavior is to ignore MSVC and do everything based only on the Zig installation. This makes using Zig to compile C and C++ code on Windows an &#34;it just works&#34; experience.</p><p>  在此版本中，默认行为是忽略MSVC，并仅基于Zig安装执行所有操作。这使得使用Zig在Windows AN＆＃34上编译C和C ++代码;它只是有效＆＃34;经验。</p><p>  MSVC integration can be achieved by using  -target native-native-msvc. Note that mingw-w64 is ABI-compatible with MSVC, so any build artifacts produced by one are consumable by the other. However the respective C header files are not always API-compatible, which is why there is still a use case for overriding the default.</p><p>  可以通过使用-target本机 - 原生-MSVC来实现MSVC集成。请注意，MINGW-W64与MSVC相兼容，因此由一个产生的任何构建工件都是由另一个的消耗品。但是，相应的C头文件并不总是API兼容，这就是为什么仍然是默认默认的用例。 </p><p>      With the advent of the  Self-Hosted Linker, Zig is now able to generate well-formed and codesigned binaries on arm64 macOS (aka the Apple Silicon). It is also able to cross-compile C, C++, and Zig code to an arm64 and x86_64 macOS. Additionally, arm64 nightly binaries of Zig are automatically generated by our Continuous Integration service, meaning both arm64 and x86_64 macOS are now  Tier 1 targets.</p><p>随着自主托管链接器的出现，Zig现在能够在ARM64 MacOS（AKA Apple Silicon）上生成良好形成的和代号的二进制文件。它还能够将C，C ++和Zig代码交叉编译到ARM64和X86_64 MacOS。此外，ARM64每晚Zig二进制文件由我们的连续集成服务自动生成，这意味着ARM64和X86_64 MacOS都是Tier 1目标。</p><p>  To facilitate incremental linking, the self-hosted compiler is now by default generating   dSYM bundles which store DWARF debug information and debug symbols on macOS. This puts Zig on path of becoming a true replacement for the Xcode development environment.</p><p>  为了便于增量链接，自主主机编译器现在默认生成DSYM捆绑包，存储DWARF调试信息和在MACO上的调试符号。这将Zig放在Xcode开发环境中成为真正替代的路径。</p><p>  Finally, as a side experiment, Jakub added in  Zig Build System integration with  Darling (#8760), a translation layer of macOS syscalls to Linux, with the intention of being able to cross test MachO binaries and macOS specific tests directly on Linux simply by passing in an additional flag  -Denable-darling to  zig build test.</p><p>  最后，作为一个侧面实验，jakub在Zig构建系统集成与达令（＃8760），是麦斯科斯州Syscalls到Linux的翻译层，其目的是能够简单地在Linux上直接交叉测试Macho二进制文件和麦斯科斯特定测试在Zig Build Test中传递额外的旗帜Dadling。</p><p>  In 0.8.0, Zig provides libc header files for macOS, for both  x86_64-macos and  aarch64-macos, using the experimental  fetch-them-macos-headers project. There is a myth that Apple&#39;s C header files have an encumbered license, but that is not the case. They are licensed under the  Apple Public Source License which is in fact quite permissive.</p><p>  在0.8.0中，Zig使用实验的Fetch-Hom-MacOS-Rements项目为X86_64-MacOS和AARCH64-MACOS提供Libc标题文件。有一个神话是Apple＆＃39; s c头文件的占用许可证，但这不是这种情况。它们在苹果公共源许可证下许可，实际上是非常宽容的。</p><p>  Zig 0.8.0 relies on these headers even when compiling natively, as long as there are no system dependencies.  This makes Zig able to compile C and C++ code on macOS without XCode installed (#6773).</p><p>  Zig 0.8.0即使在编译此时，也依赖于这些标题，只要没有系统依赖性即可。这使得Zig能够在没有安装Xcode的情况下编译C和C ++代码（＃6773）。</p><p>      The  Self-Hosted Compiler gained a work-in-progress  WebAssembly Backend, which provides the ability for Zig to compile to wasm without  LLVM.</p><p>      自托管编译器获得了一个进展的webassembly后端，它提供了zig编译为没有llvm的wasm的能力。</p><p>  Zig now ships with  WASI libc and supports cross-compiling C code to WASI. This also makes Zig a tempting alternative to downloading and building  WASI libc and/or  WASI SDK manually (#8837).</p><p>  Zig现在与Wasi Libc一起船舶，并支持交叉编译C代码。这也使Zig成为手动下载和构建WASI LIBC和/或WASI SDK的诱惑替代品（＃8837）。 </p><p>    Just like every other target,  zig build-lib now builds a static archive for wasm, unless  -dynamic is specified.</p><p>就像每个其他目标一样，Zig Build-lib现在为WASM构建了一个静态存档，除非指定了动态。</p><p>    Al Hoang contributed some initial work to get Zig to run under  Haiku. Some things that are now working:</p><p>    Al Hoang贡献了一些初步的工作来让Zig在Haiku下运行。一些现在工作的东西：</p><p>        LLVM 12 brings in csky support.  glibc already supported csky, but Zig did not ship glibc header files for it since LLVM did not have a backend for it. Zig 0.8.0 additionally ships glibc header files for csky.</p><p>        LLVM 12带来CSKY支持。 Glibc已经支持CSKY，但Zig没有为此发出Glibc头文件，因为LLVM没有它的后端。 Zig 0.8.0另外还为CSKY划船Glibc头文件。</p><p>          Pass  -mthumb when compiling C/C++ code. The Clang driver requires this flag and ignores the target triple.</p><p>          在编译C / C ++代码时传递-MOUMB。 Clang驱动程序需要此标志并忽略目标三倍。</p><p>                        Zig now has CI test coverage for  powerpc-linux-none and  powerpc-linux-musl. The issue blocking  glibc support is #4927.</p><p>                        Zig现在具有PowerPC-Linux-None和PowerPC-Linux-Musl的CI测试覆盖范围。阻止Glibc支持的问题是＃4927。</p><p>      LemonBoy made progress working around #4926, preventing Zig from being able to build  glibc on  i386-linux-gnu. He got it working, and the tests passing, but it revealed a flaw (#8930) in the  Standard Library having to do with allocation alignments on all 32-bit targets. This issue is not solved in 0.8.0 but is planned to be addressed in the 0.8.1 bug fix release. After that, we expect to have test coverage for  i386-linux-gnu.</p><p>      Lemonboy在＃4926中取得进展，防止Zig能够在I386-Linux-GNU上构建Glibc。他得到了它的工作，并且测试通过，但它揭示了标准库中的漏洞（＃8930）与所有32位目标上的分配对齐有关。此问题未在0.8.0中解决，但计划在0.8.1错误修复版本中解决。之后，我们期望对I386-Linux-GNU进行测试覆盖范围。</p><p>    During the 0.8.0 release cycle, Zig&#39;s MIPS support was greatly improved, gaining full test coverage for little-endian mips, including building  musl and  glibc.</p><p>    在0.8.0释放周期期间，Zig＆＃39; Zig＆＃39; SIPS支持大大提高，为小型MIPS获得了全面的测试覆盖范围，包括建筑物和GLIBC。 </p><p>  However, all MIPS targets regressed with the release of  LLVM 12, despite having  an open release blocker bug filed. Not only this, but the fix has been in LLVM main branch for a whole month, as of the time of this writing, and yet the fix did not make it into 12.0.1-rc1, again despite the bug being marked as a 12.0.1 release blocker.</p><p>然而，尽管提交了开放式发布阻止器错误，但所有MIPS目标都会随着LLVM 12的发布而退化。不仅如此，而且修复程序已经在LLVM主分支整个月，截至本文的时间，然而，解决方案没有将其成12.0.1-RC1，尽管错误被标记为12.0 .1释放阻止器。</p><p>  As soon as LLVM releases a bug fix version which includes the fix, Zig can re-enable MIPS test coverage.</p><p>  一旦LLVM发布一个包含修复的错误修复版本，Zig就可以重新启用MIPS测试覆盖范围。</p><p>    The language reference is updated to reflect the changes to the language and standard library in this release cycle.</p><p>    更新语言引用，以反映此发布周期中语言和标准库的更改。</p><p>                  docgen: use  std.Progress API so that we see a terminal progress bar when waiting for the docs to build.</p><p>                  DOCGEN：使用STD.Progress API，以便在等待文档构建时看到终端进度栏。</p><p>  Contributors: Andrew Kelley, Carlos Zúñiga, Dave Gauer, Devin Bayer, Eleanor Bartle, Frank Denis, Jakub Konka, Jay Petacat, Jonas Carpay, Josh Holland, Josh Wolfe, LemonBoy, Martin Wickham, Mathieu Guay-Paquet, Matthew Borkowski, Ryan Liptak, Tadeo Kondrak, Veikka Tuominen, data-man, Jacob G-W, xackus</p><p>  贡献者：Andrew Kelley，CarlosZúñiga，Devin Gauer，德国拜耳，埃莉诺·拜耳，Jakub Konka，Jay Petacat，Jonas Carpay，Josh Holland，Josh Wolfe，Lemonboy，Martin Wickham，Mathieu Guay-Paquet，Matthowe Borkowski，Ryan Liptak ，Tadeo Kondrak，Veikka Tuominen，Data-Man，Jacob Gw，Xackus</p><p>    Compared to other releases, the Zig language saw fewer changes this cycle, providing a relatively stable target for the  Self-Hosted Compiler implementation. Still, there were a few additions and breaking changes.</p><p>    与其他版本相比，Zig语言看到此循环的更改更改，为自托管编译器实现提供相对稳定的目标。尽管如此，还有几种添加和破坏变化。</p><p>    const A =  extern  enum { foo, bar }; const B =  packed  enum { foo, bar };</p><p>    const a = extern enum {foo，bar}; const b = packed enum {foo，bar}; </p><p>  test.zig:1:11:  error: enums do not support &#39;packed&#39; or &#39;extern&#39;; instead provide an explicit integer tag typeconst A = extern enum { foo, bar }; ^ test.zig:2:11:  error: enums do not support &#39;packed&#39; or &#39;extern&#39;; instead provide an explicit integer tag typeconst B = packed enum { foo, bar }; ^</p><p>test.zig：1：11：错误：枚举不支持＆＃39;包装＆＃39;或＆＃39; extern＆＃39 ;;而是提供一个显式整数标签Typeconst A = Extern Enum {foo，bar}; ^ test.zig：2：11：错误：枚举不支持＆＃39;包装＆＃39;或＆＃39; extern＆＃39 ;;而是提供一个显式整数标签TypeConst B = Packed Enum {foo，bar}; ^</p><p>  This error is caught by the  Self-Hosted Compiler (due to  Whole-File AST Lowering) but not yet caught by the  Bootstrap Compiler. Related proposal: #8970</p><p>  自托管编译器（由于整个文件AST降低）捕获此错误，但尚未由Bootstrap编译器捕获。相关提案：＃8970</p><p>                        Nameless tests are exempt from  --test-filter parameters, making it possible to use  --test-filter while still pointing  zig test at the root source file.</p><p>                        无名的测试是免于--Test-Filter参数，使得可以使用--Test-il过滤器，同时仍然指向root源文件的Zig测试。</p><p>          $ ./zig test a.zigb.test &#34;fail&#34;... FAIL (TestUnexpectedResult) /home/andy/Downloads/zig/lib/std/testing.zig:310:14: 0x24d54b in std.testing.expect (test) if (!ok) return error.TestUnexpectedResult; ^ /home/andy/Downloads/zig/build/b.zig:7:5: 0x2068b1 in b.test &#34;fail&#34; (test) try std.testing.expect(false); ^2 passed; 0 skipped; 1 failed.error: the following test command failed with exit code 1:zig-cache/o/577deb476721d8dde8bc782f2c61ed2f/test /home/andy/Downloads/zig/build/zig$ ./zig test a.zig --test-filter passAll 2 tests passed.</p><p>          $ ./zig test a.zigb.test＆＃34; fail＆＃34; fail ...失败（testunexpectedresult）/home/andy/downloads/zig/lib/std/testing.zig：310:14：0x24d54b在std中。 testing.expect（测试）如果（！确定）返回错误.testunexpedresult; ^ /home/andy/downloads/zig/build/b.zig：7:5：0x2068b1在b.tiest＆＃34;失败＆＃34; （测试）尝试std.testing.expect（false）; ^ 2通过; 0跳过; 1失败。错误2测试通过了。</p><p>       const std =  @import( &#34;std&#34;); const Enum =  enum { one, two, three }; test  &#34;old code&#34; {  const T =  @TagType(Enum);  try std.testing.expectEqual( u2, T);}</p><p>       const std = @import（＆＃34; std＆＃34;）; const enum =枚举{一，两个，三个};测试＆＃34;旧代码＆＃34; {const t = @tagtype（枚举）;尝试std.testing.Expectequal（U2，T）;}</p><p>      const std =  @import( &#34;std&#34;); const Enum =  enum { one, two, three }; const TagType = std.meta.TagType; test  &#34;new code&#34; {  const T = TagType(Enum);  try std.testing.expectEqual( u2, T);}</p><p>      const std = @import（＆＃34; std＆＃34;）; const enum =枚举{一，两个，三个}; const tagtype = std.meta.tagtype;测试＆＃34;新代码＆＃34; {const t = tagtype（枚举）;尝试std.testing.Expectequal（U2，T）;}</p><p>       nosuspend blocks now allow   resume inside their scope, because resuming a suspended async function call is actually a synchronous operation.</p><p>       nosuspend块现在允许在其范围内恢复，因为恢复暂停的异步函数调用实际上是一个同步操作。 </p><p>  nosuspend blocks now allow   async function calls inside their scope, because starting an async function call is actually a synchronous operation, since the caller is not awaiting on the callee for a return value.</p><p>nosuspend块现在允许异步函数调用它们的范围内，因为启动异步函数调用实际上是一个同步操作，因为呼叫者在Callee上不等待返回值。</p><p>      pub  const CallingConvention =  enum { Unspecified, C, Naked, Async, Inline, Interrupt, Signal, Stdcall, Fastcall, Vectorcall, Thiscall, APCS, AAPCS, AAPCSVFP, SysV,};</p><p>      Pub const callingConvention =枚举{未指定，C，裸体，异步，内联，中断，信号，stdcall，fastcall，VectorCall，ThisCall，APC，AAPCS，AAPCSVFP，SYSV，};</p><p>     const std =  @import( &#34;std&#34;); const expect = std.testing.expect; const maxInt = std.math.maxInt; test  &#34;unsigned negation wrapping&#34; {  try testUnsignedNegationWrappingEval( 1);  comptime  try testUnsignedNegationWrappingEval( 1);} fn  testUnsignedNegationWrappingEval(x:  u16) ! void {  try expect(x ==  1);  const neg = -%x;  try expect(neg == maxInt( u16));}</p><p>     const std = @import（＆＃34; std＆＃34;）; const期望= std.testing.expect; const maxint = std.math.maxint;测试＆＃34;未签名的否定包装＆＃34; {try testunsignednegationWrappteval（1）;编辑尝试testunsignednegationWrappingeval（1）;} fn testunsignednegationWrappteval（x：u16）！ void {尝试期待（x == 1）; const neg =  - ％x;尝试期待（neg == maxint（u16））;}</p><p>            const std =  @import( &#34;std&#34;); const builtin =  @import( &#34;builtin&#34;);  // &lt;--- look here test  &#34;old code&#34; {  const StackTrace = builtin.StackTrace;}</p><p>            const std = @import（＆＃34; std＆＃34;）; const buildin = @import（＆＃34;内置＆＃34;）; //＆lt; ---看这里测试＆＃34;旧代码＆＃34; {const stacktrace = buildin.stacktrace;}</p><p> $ zig test test.zig ./docgen_tmp/test.zig:5:31:  error:  container &#39;builtin&#39; has no member called &#39;StackTrace&#39; const StackTrace = builtin.StackTrace;  ^</p><p> $ zig test test.zig ./docgen_tmp/test.zig：5:31：错误：容器＆＃39;内置＆＃39;没有成员叫做＆＃39; Stacktrace＆＃39; Const StackTrace = BuildIn.Stacktrace; ^</p><p>     const std =  @import( &#34;std&#34;); const builtin = std.builtin;  // &lt;--- look here test  &#34;new code&#34; {  const StackTrace = builtin.StackTrace;}</p><p>     const std = @import（＆＃34; std＆＃34;）; const buildin = std.builtin; //＆lt; ---看这里测试＆＃34;新代码＆＃34; {const stacktrace = buildin.stacktrace;}</p><p>     const std =  @import( &#34;std&#34;); const builtin = std.builtin;  // &lt;--- look here test  &#34;deprecated code&#34; {  const native_arch = builtin.cpu.arch;  // deprecated!}</p><p>     const std = @import（＆＃34; std＆＃34;）; const buildin = std.builtin; //＆lt; ---看这里测试＆＃34;已弃用的代码＆＃34; {const native_arch = buildin.cpu.arch; //弃用！} </p><p>     const std =  @import( &#34;std&#34;); const builtin =  @import( &#34;builtin&#34;);  // &lt;--- look here test  &#34;new code&#34; {  const native_arch = builtin.cpu.arch;  // OK}</p><p>const std = @import（＆＃34; std＆＃34;）; const buildin = @import（＆＃34;内置＆＃34;）; //＆lt; ---看这里测试＆＃34;新代码＆＃34; {const native_arch = buildin.cpu.arch; // 好的}</p><p>     In the previous release, as well as this release, the main Zig compiler everybody uses is the bootstrap compiler, written in C++, also known as &#34;stage1&#34;. Despite the main focus of this release cycle being the  Self-Hosted Compiler, there were some improvements to stage1 as well.</p><p>     在上一个版本中，以及此版本，每个人都使用的主要Zig编译器是Bootstrap编译器，写在C ++中，也称为＆＃34; Stage1＆＃34;尽管此释放周期的主要重点是自主主机编译器，但也有一些改进。</p><p>  Add architecture-specific clobbers to asm(). We&#39;re basically following Clang&#39;s lead, add the necessary clobbers to minimize the risk of generating wrong code.</p><p>  将特定于架构的clobbers添加到ASM（）。 We＆＃39; Re基本上追随铿cl＆＃39; s铅，添加必要的clobbers，以最大限度地减少生成错误代码的风险。</p><p>          Emit a compile error instead of falling back to C for unsupported calling convention. (#6829)</p><p>          发出编译错误，而不是倒回C以获取不受支持的调用约定。 （＃6829）</p><p>                        Allow variable capture for multi-prong switch arms, handling the multi-prong case as we do with range cases (#7188).</p><p>                        允许多叉开关臂的可变捕获，在使用范围案例（＃7188）时处理多叉壳。</p><p>  Let LLVM legalize the overflowing ops on vectors, because it is smart enough to produce tight overflow checking sequences.</p><p>  让LLVM将溢出的OPS合法化向量上，因为它足以产生紧密的溢出检查序列。</p><p>                Apply LLVM ssp attributes globally instead of per-function. Otherwise LLVM asserts with: &#34;stack protected callee but caller requested no stack protector&#34;</p><p>                在全局应用LLVM SSP属性而不是每函数。否则LLVM伴随着：＆＃34;堆栈受保护的Callee，但呼叫者请求没有堆栈保护器＆＃34; </p><p>                          Rework tokenizer to match  Self-Hosted Compiler. Mainly, this makes the stage1 and stage2 logic match each other, making it easier to maintain both at the same time. It is also a negligible memory usage improvement.</p><p>返回销价匹配自托管编译器。主要是，这使得Stage1和Stage2逻辑彼此匹配，使得同时保持两者。它也是一种可忽略的内存使用情况。</p><p>  Store target info in the LLVM module for every function. This is needed to let LLVM (or, better, libLTO) produce code using the target options specified by the user (#8803).</p><p>  为每个功能存储LLVM模块中的目标信息。这是需要使用用户指定的目标选项（＃8803）的目标选项来生产代码所需的这一点。</p><p>              Resolve builtin types and values via  std.builtin rather than via   @import( &#34;builtin&#34;). This helps avoid the need for   usingnamespace used in  builtin.zig or in  std.builtin.</p><p>              通过std.builtin解决内置的类型和值，而不是通过@import（＆＃34;内置＆＃34;）。这有助于避免在构建中使用的名称空间或在std.builtin中使用。</p><p>  The good news here is that nearly all these fixes come with additional behavior tests, which we can use to verify the  Self-Hosted Compiler does not regress.</p><p>  这里的好消息是，几乎所有这些修复都有附加的行为测试，我们可以用来验证自托管的编译器不会退化。</p><p>  One especially noteworthy change here is LemonBoy&#39;s fix to ask LLVM to produce compact code in -OReleaseSmall mode. Previously, using -OReleaseSmall sometimes resulted in larger output binaries than -OReleaseFast! (#7048, #7077)</p><p>  这里的一个特别值得注意的变化是lemonboy＆＃39; s fix，以便在-oreleasemall模式下在-oreleasemall模式下生产紧凑码。以前，使用-OreleaseMall有时导致输出二进制文件较大！ （＃7048，＃7077）</p><p>  Big, big thanks to LemonBoy for solving so many stage1 bugs during this release cycle. This is high effort, low-appreciation, huge-impact work that he has been doing. But in reality he has been single-handedly keeping us afloat while we work towards finishing the  Self-Hosted Compiler.</p><p>  很大，很大，感谢Lemonboy在此发布周期中解决这么多阶段1错误。这是努力，低估，他一直在做的巨大影响力。但实际上，他一直在单手中让我们漂浮在完成自主主办的编译器时。</p><p>  Contributors: LemonBoy, Andrew Kelley, Koakuma, Veikka Tuominen, Tadeo Kondrak, Michael Dusan, Jakub Konka, frmdstryr, Mathieu Guay-Paquet, Sreehari S, Al Hoang, Alexandros Naskos, Isaac Freund, Jay Petacat, Josh Wolfe, Lee Cannon, Matthew Knight, Nathan Michaels, Sizhe Zhao, Timon Kruiper, Woze Parrot, Jacob G-W, lars, pfg, xackus</p><p>  贡献者：lemonboy，安德鲁克利，萨卡穆卡，veikka tuominen，tadeo kondrak，迈克尔道斯·斯塔克，雅典konka，弗拉米斯，麦克风，哈康，亚历山大号艾萨克·弗慎，杰什·佩罗特，吉什沃尔夫，李大炮，马修骑士，内森迈克尔斯，赵壮，蒂蒙克鲁奈，Woze Parrot，Jacob Gw，Lars，Pfg，Xackus </p><p>      This was a rough release cycle for downstream users of LLVM. During testing of the release candidates, we found and reported 7 regressions from LLVM 11. However, despite having reproducible regressions reported as release blockers, the LLVM project tagged release 12.0.0. Not only were there open regressions at this time, but the 12.0.0 tag did not even tag the tip of the release/12.x branch - so there were  fixes already committed into the release branch that did not make it into the tag.</p><p>这是LLVM下游用户的粗略释放循环。在测试释放候选者期间，我们发现并报告了LLVM 11的7个回归。然而，尽管报告了作为释放阻滞剂的可再生回归，但LLVM项目标记为12.0.0版。此时不仅有开放的回归，而且12.0.0标记甚至没有标记释放/ 12.x分支的尖端 - 所以已经提交到没有使其进入标记的发布分支的修复程序。</p><p>  At the time of this writing, there are  31 open release blockers for 12.0.1, and yet LLVM has already tagged 12.0.1-rc1. As  Michał Górny puts it:</p><p>  在本写作时，有31个打开的释放阻滞剂12.0.1，但LLVM已经标记了12.0.1 rc1。正如MichałGórny所说：</p><p>  I&#39;ve started testing, hit two bugs I&#39;ve already reported for 12.0.0 RCsand figured out I&#39;m wasting my time. It seems that LLVM reachedthe point where releases are pushed through just for the sake ofreleases and QA doesn&#39;t exist.</p><p>  我开始测试，击中了两个错误我已经报道了12.0.0 rcsand弄清楚了我的时间。似乎LLVM达到了释放的点，只为炸弹释放，并且QA不存在QA＆＃39;</p><p>  I hope the LLVM project can step up and take releases and regressions more seriously.</p><p>  我希望LLVM项目能够更加认真地加强和释放释放和回归。</p><p>  Either way, it is starting to become clear that  transitioning LLVM to an optional dependency, and thereby providing an alternative to the LLVM monoculture, is becoming more and more of an attractive feature for the Zig project to offer. In this release you can see that we have broken ground on this front:  x86-64 Backend,  AArch64 Backend,  ARM Backend,  WebAssembly Backend,  RISC-V 64 Backend,  C Backend,  SPIR-V Backend</p><p>  无论哪种方式，它开始清楚地将LLVM转换为可选的依赖性，从而为LLVM单一文化提供替代方案，正在成为ZIG项目提供的越来越多的特征。在此版本中，您可以看到我们在这个前面打破了地面：x86-64后端，aarch64后端，arm后端，webassembly后端，risc-v 64后端，c backend，spir-v后端</p><p>    The main focus of this release cycle was the self-hosted compiler (also known as &#34;stage2&#34;).</p><p>    此释放周期的主要重点是自主主机编译器（也称为＆＃34; Stage2＆＃34;）。</p><p>  Despite the fact that .zig source code by default is still compiled in this release using the  Bootstrap Compiler, the main driver code is already self-hosted, as well as many features, such as  zig cc,  C Translation, and  CPU Feature Detection. Improvements made to &#34;stage2&#34; in these areas do in fact affect the main Zig user experience.</p><p>  尽管如此，默认情况下，默认情况下仍然在此版本中使用Bootstrap编译器编译，主要驱动程序代码已经是自托管的，以及许多功能，如Zig CC，C翻译和CPU功能检测。对＆＃34的改进; Stage2＆＃34;在这些领域实际上影响了主要的Zig用户体验。 </p><p>    LemonBoy added a framework for host CPU detection on Linux based on parsing  /proc/cpuinfo, and implemented the model detection for  64-bit SPARC targets as proof of concept.</p><p>Lemonboy基于解析/ PROC / CPUInfo对Linux上的主机CPU检测添加了一个框架，并实现了64位SPARC目标作为概念证明的模型检测。</p><p>    The CPU detection code is nearly at feature parity with LLVM. We do support detecting the native CPU on Sparc systems and macOS, our ARM/AArch64 model list is quite comprehensive, and so is our PPC one. The only missing pieces are:</p><p>    CPU检测代码几乎处于具有LLVM的特征奇偶校验。我们确实支持检测SPARC系统和麦克斯的本机CPU，我们的ARM / AARCH64模型列表非常全面，我们的PPC One也是如此。唯一缺失的部分是：</p><p>  ARM32 detection on Darwin hosts (it is doubtful anybody is planning on running the compiler on a old-ass iPhone)</p><p>  ARM32对达尔文主机的检测（令人疑问的任何人都计划在Old-As iPhone上运行编译器）</p><p>  As a result of all this work, we dropped LLVM&#39;s host CPU detection method as a fallback. This is one less dependency that Zig has on LLVM, bringing us one step closer to making LLVM an optional extension rather than a required dependency.</p><p>  由于所有这项工作，我们丢弃了LLVM＆＃39;将主机CPU检测方法作为回退。这是Zig在LLVM上的依赖性较少，使我们更接近使LLVM成为可选的扩展而不是所需的依赖性。</p><p>    Zig&#39;s target CPU feature awareness is a superset of LLVM&#39;s, which means that for every target CPU feature Zig is aware of, it must know whether and how to map that to LLVM&#39;s target CPU feature.</p><p>    Zig＆＃39; S目标CPU特征意识是LLVM＆＃39; s的超集，这意味着对于每个目标CPU功能Zig都知道，它必须知道是否以及如何将其映射到LLVM＆＃39; S目标CPU功能。</p><p>  For this purpose Andrew created the  update_cpu_features.zig tool. This tool generates .zig code that contains enums and data declarations for all the various CPUs that Zig is aware of.</p><p>  为此目的，Andrew创建了update_cpu_features.zig工具。此工具生成.zig代码，其中包含Zig所知的所有各种CPU的枚举和数据声明。</p><p>      Before this release, updating target CPU features in response to LLVM updates was a manual process, in which it was too easy to introduce bugs.</p><p>      在此版本之前，更新目标CPU功能响应LLVM更新是一个手动过程，其中它太容易引入错误。 </p><p>  Now, the tool completely automates the process, and there are no longer any manual steps involved when LLVM updates, other than re-running the tool.</p><p>现在，该工具完全自动化该过程，并且在LLVM更新时不再涉及的任何手动步骤，而不是重新运行该工具。</p><p>  Additionally, Andrew improved it to parallelize work for each target, making it run much faster, despite wading through many megabytes of llvm-tblgen JSON dumps.</p><p>  此外，Andrew改进了它，以对每个目标并行化工作，尽管通过许多LLVM-TBLGEN JSON Dumps涉及许多兆字节，但使它会更快地运行。</p><p>    In the  --watch REPL, empty command re-runs previous command. This can be especially useful combined with the new  update-and-run command.</p><p>    在--watch repl中，空命令重新运行以前的命令。这可以特别有用，与新的更新和运行命令相结合。</p><p>      I have been reading Richard Fabian&#39;s book,  Data-Oriented Design, and finally things started to &#34;click&#34; for me. I&#39;ve had these ideas swirling around in my head for years, but only recently do I feel like I have an intuitive grasp on how modern CPUs work, especially with regards to L1 cache, and the relative latencies of uncached memory loads vs computations.</p><p>      我一直在读Richard Fabian＆＃39;书籍，以数据为导向的设计，最后事情开始＆＃34;点击＆＃34;为我。我有这些想法在我脑海里旋转多年，但最近我觉得我有一个直观的掌握现代CPU工作如何，特别是对于L1缓存，以及未加工的内存负荷的相对延迟vs计算。</p><p>  Compilation speed is a top priority for the design of both the Zig self-hosted compiler as well as the language itself. I have been careful to design the language in a way as to unlock the potential of an ambitiously fast compiler.</p><p>  编译速度是设计ZIG自主主机编译器以及语言本身的首要任务。我一直小心地设计语言，以解锁潜在的快速编译器的潜力。</p><p>  In this release cycle, I took the time to rework the memory layout of 3 out of 4 phases of the compiler pipeline:</p><p>  在此版本周期中，我花了时间重新制作了编译器管道的4个阶段的内存布局：</p><p>  tokenize ➡️ parse ➡️ ast lowering ➡️ semantic analysis ➡️ machine code gen</p><p>  标记➡️解析➡️AST降低➡️语义分析➡️机代码 </p><p>  Each arrow in this diagram represents a phase in the compiler pipeline inputting data in one form, and outputting data in a different form, for the next phase.</p><p>该图中的每个箭头表示编译器流水线中的相位以一种形式输入数据，并以不同的形式输出数据，用于下一阶段。</p><p>    I decided to try to reduce the number of heap-allocated bytes of the  token list as well as the  AST, as a pilot test for doing a similar strategy for ZIR and AIR later. I had a few key insights here:</p><p>    我决定尝试减少令牌列表的堆分配字节数以及AST，作为对ZIR和AIR的类似策略的试验试验。我在这里有一些主要的见解：</p><p>  Underlying premise: using less memory will make things faster, because of fewer allocations and better cache utilization. Also using less memory is valuable in and of itself.</p><p>  基础前提：使用较少的内存将使事情更快，因为较少的分配和更好的缓存利用率。同样使用较少的内存在其本身和本身的价值是有价值的。</p><p>  Using a  Struct-Of-Arrays for tokens and AST nodes, saves the bytes of padding between the enum tag (which kind of token is it; which kind of AST node is it) and the next fields in the struct. It also improves cache coherence, since one can peek ahead in the tokens array without having to load the source locations of tokens.</p><p>  对于令牌和AST节点使用阵列结构，保存枚举标记之间的填充字节（哪种令牌;它是哪种AST节点）和结构中的下一个字段。它还提高了缓存一致性，因为人们可以在令牌阵列中窥视，而无需加载令牌的源位置。</p><p>  Token memory can be conserved by only having the tag (1 byte) and byte offset (4 bytes) for a total of 5 bytes per token. It is not necessary to store the token ending byte offset because one can always re-tokenize later, but also most tokens the length can be trivially determined from the tag alone, and for ones where it doesn&#39;t, string literals for example, one must parse the string literal again later anyway in astgen, making it free to re-to</p><p>  可以通过仅具有标记（1字节）和字节偏移量（4字节）来保存令牌存储器，每个令牌总共5个字节。没有必要存储令牌结束字节偏移，因为稍后可以始终重新销量，但是大多数令牌的长度可以单独地从标签中窥探，并且对于它而不是其中，例如它的字符串文字。 ，一个人必须在astgen中稍后再次解析字符串文字，使其自由地重新实现</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ziglang.org/download/0.8.0/release-notes.html">https://ziglang.org/download/0.8.0/release-notes.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发行/">#发行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/release/">#release</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>